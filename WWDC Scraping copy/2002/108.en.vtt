WEBVTT

00:00:07.190 --> 00:00:11.560
Good morning, and welcome to the Managing
Kernels Extension Session.

00:00:11.650 --> 00:00:12.560
I'm Craig Keithley.

00:00:12.560 --> 00:00:16.000
I'm Apple's USB and FireWire evangelist.

00:00:16.260 --> 00:00:17.610
As part of that,
I work with a lot of people

00:00:17.680 --> 00:00:20.180
that work on kernel extensions.

00:00:20.270 --> 00:00:23.670
As we talked about in the past session
-- and this is an important message to

00:00:23.670 --> 00:00:27.480
get across -- our preference is that
folks don't write kernel extensions.

00:00:27.480 --> 00:00:32.570
And you can look even in our own system,
where the printing I/O module in Tioga,

00:00:32.650 --> 00:00:38.210
the image capture architecture,
camera modules, scanner drivers, etc.

00:00:38.210 --> 00:00:40.290
are all running in user space.

00:00:40.290 --> 00:00:43.320
They don't need to
have kernel extensions.

00:00:43.680 --> 00:00:45.380
There are, of course,
some situations where

00:00:45.380 --> 00:00:46.260
you need to do that.

00:00:46.260 --> 00:00:50.160
Network kernel extensions,
certain file systems extensions,

00:00:50.290 --> 00:00:52.500
and mass storage drivers,
those sorts of things do

00:00:52.500 --> 00:00:53.820
require kernel extensions.

00:00:53.840 --> 00:00:59.780
And that puts you as developers into
some very important considerations.

00:00:59.800 --> 00:01:03.660
You need to be aware of how
to handle the KEXT cache.

00:01:03.860 --> 00:01:07.340
You need to be aware of
file write permissions,

00:01:07.410 --> 00:01:07.840
et cetera.

00:01:07.860 --> 00:01:10.560
So in order to go through the
managing kernel extensions,

00:01:10.560 --> 00:01:15.590
I'd like to welcome Dean Reece,
the I/O Kit Software Engineering Manager.

00:01:15.590 --> 00:01:15.590
Thank you.

00:01:20.530 --> 00:01:21.620
Good morning.

00:01:21.620 --> 00:01:23.210
Thanks for coming.

00:01:23.210 --> 00:01:24.900
Let's dive right in.

00:01:24.900 --> 00:01:28.330
So today I'm going to talk about -- start
off with a little bit of what kecks are.

00:01:28.330 --> 00:01:30.750
By this time I suspect most
of you know what kecks are.

00:01:30.860 --> 00:01:33.040
But I'll talk about it a
bit anyway just to make sure

00:01:33.130 --> 00:01:34.760
everybody is up on the same page.

00:01:34.760 --> 00:01:38.630
I'm going to talk a little bit about when
to use them and when not to use them.

00:01:38.860 --> 00:01:40.690
Craig's already covered that a bit.

00:01:40.690 --> 00:01:44.520
But I'll talk about some of the
decision points to help you decide

00:01:44.520 --> 00:01:47.230
why you do or don't live in a kernel.

00:01:47.260 --> 00:01:50.060
And talk -- actually most of the
presentation is about some of the

00:01:50.060 --> 00:01:53.660
details around actually deploying kecks,
building them, debugging them,

00:01:53.750 --> 00:01:54.910
things like that.

00:01:54.910 --> 00:01:59.530
And we'll hopefully get you out
of some pitfalls along the way.

00:02:00.220 --> 00:02:03.180
So by this time you've probably
seen this slide a couple times.

00:02:03.380 --> 00:02:06.690
Everything I'm talking about today
is down in the Darwin kernel.

00:02:06.690 --> 00:02:11.780
Everything that KEXTs do run entirely
inside the kernel address space.

00:02:11.780 --> 00:02:16.080
So if you're in here interested
in user space drivers,

00:02:16.080 --> 00:02:19.520
as Craig talked about,
we won't be talking about those here.

00:02:19.570 --> 00:02:23.100
We'll be talking a little bit about
how in kernel drivers can communicate

00:02:23.110 --> 00:02:26.670
to entities outside the kernel,
but we're really focused

00:02:26.670 --> 00:02:28.350
on Darwin at this point.

00:02:28.890 --> 00:02:31.240
And to expand on the
Darwin view a little bit,

00:02:31.350 --> 00:02:34.640
you'll see I/O Kit and drivers
sort of off to the side

00:02:34.640 --> 00:02:36.830
there as a vertical stack.

00:02:36.940 --> 00:02:39.550
We're -- I/O Kit is
based on Mach primitives.

00:02:39.650 --> 00:02:41.740
We're entirely mock-based.

00:02:41.830 --> 00:02:45.030
We do work with BSD since
BSD provides our networking

00:02:45.480 --> 00:02:49.880
and our storage infrastructure,
but I/O Kit itself doesn't have any

00:02:49.910 --> 00:02:52.450
BSD primitives or any BSD tie-ins.

00:02:52.460 --> 00:02:55.990
It's really a service provider to BSD.

00:02:57.750 --> 00:02:59.480
Okay.

00:02:59.480 --> 00:03:03.520
So most basic definition,
Kernel Extensions provide you

00:03:03.520 --> 00:03:06.350
a way to extend the kernel,
Mac OS X kernel.

00:03:06.430 --> 00:03:10.340
In particular,
they're a bundle that will include

00:03:10.340 --> 00:03:13.880
the binary code that gets loaded and
run in the kernel and some descriptive

00:03:13.880 --> 00:03:16.540
information about why to load it,
when to load it, how to load it,

00:03:16.560 --> 00:03:17.660
and so on.

00:03:17.750 --> 00:03:20.780
Now, there are three kinds of
Kernel Extensions that we

00:03:20.780 --> 00:03:22.190
make use of in Mac OS X.

00:03:22.320 --> 00:03:24.280
There are I/O Kit drivers and families.

00:03:24.310 --> 00:03:25.440
I kind of lumped those together.

00:03:25.440 --> 00:03:29.390
They're actually a little bit different,
but for the purposes of KEXT management,

00:03:29.470 --> 00:03:32.000
you can really consider them the same.

00:03:32.120 --> 00:03:35.990
There are network kernel extensions,
obviously things that plug

00:03:35.990 --> 00:03:39.940
into the BSD network stacks,
and file system extensions.

00:03:39.940 --> 00:03:43.560
These would be typically
loadable file systems.

00:03:43.680 --> 00:03:47.150
Now, as has been said in
several previous sessions,

00:03:47.270 --> 00:03:51.340
you really want to avoid using
loadable file systems or developing

00:03:51.340 --> 00:03:55.120
loadable file systems or loadable
network plug-ins at this point as

00:03:55.140 --> 00:03:57.550
Apple is still evolving those APIs.

00:03:57.700 --> 00:04:05.900
We've had the power of Unix and the
power of our BSD kernel is very,

00:04:05.920 --> 00:04:07.740
very powerful.

00:04:08.250 --> 00:04:11.590
But at the same time,
the Unix kernel has grown up with

00:04:11.700 --> 00:04:15.400
the assumption that you rebuild
things from release to release.

00:04:15.470 --> 00:04:19.400
So there hasn't been a lot of
emphasis put on binary compatibility.

00:04:19.490 --> 00:04:21.960
And as a result,
it's very hard for us to extend

00:04:21.960 --> 00:04:25.050
the BSD parts of the kernel
in a way that don't break file

00:04:25.380 --> 00:04:27.460
system or network plug-ins.

00:04:27.540 --> 00:04:30.150
I/O Kit, of course,
is a new development at Apple,

00:04:30.170 --> 00:04:34.070
and we knew that this was rebuilding
drivers every time we released the

00:04:34.070 --> 00:04:37.290
OS was not going to be acceptable to
our developers or our customer base.

00:04:37.410 --> 00:04:41.330
So I/O Kit has some infrastructure
for dealing with binary compatibility.

00:04:41.410 --> 00:04:46.380
It's not perfect, but it goes a long way
towards easing the problem.

00:04:46.520 --> 00:04:49.780
And so at this point,
we recommend just developing

00:04:49.800 --> 00:04:54.470
I/O Kit drivers in I/O Kit-style
libraries or families.

00:04:55.520 --> 00:04:59.420
So, obviously, if you can avoid shipping
a Kernel Extension at all,

00:04:59.680 --> 00:05:02.850
that's the best possible solution.

00:05:03.820 --> 00:05:07.000
Development inside the kernel is of
course harder than outside of the kernel

00:05:07.000 --> 00:05:11.950
because it's deeper in the system,
it's harder to debug.

00:05:12.630 --> 00:05:13.580
crashes are fatal.

00:05:13.580 --> 00:05:17.010
If you're running inside the kernel
and you hit something that would

00:05:17.010 --> 00:05:21.040
cause a user process to exit,
that's going to cause the kernel to exit,

00:05:21.140 --> 00:05:22.880
which means the whole
machine stops running.

00:05:23.000 --> 00:05:25.310
So if you can keep your
code outside the kernel,

00:05:25.310 --> 00:05:27.790
then the system will be more stable.

00:05:27.790 --> 00:05:30.030
It's a better user experience.

00:05:30.250 --> 00:05:32.650
Also,
kernel resources are more expensive,

00:05:32.650 --> 00:05:37.430
and it's kind of hard to quantify this,
but keep in mind that by default,

00:05:37.530 --> 00:05:41.880
memory that you allocate inside
the kernel is wired memory.

00:05:41.970 --> 00:05:45.390
The actual text of your driver,
the binary, when it's loaded,

00:05:45.450 --> 00:05:46.900
that's wired memory.

00:05:48.020 --> 00:05:51.040
: In kernel threads have
the ability to run at higher

00:05:51.040 --> 00:05:53.950
priorities than user land threads.

00:05:54.060 --> 00:05:57.330
So, again, you're going to be running it
probably at a higher priority than

00:05:57.330 --> 00:05:59.010
an equivalent user land thread.

00:05:59.010 --> 00:06:01.600
You have some controls over
that if you tune your driver

00:06:01.690 --> 00:06:05.150
in user land or kernel land,
you can avoid that problem.

00:06:05.280 --> 00:06:08.150
But basically,
running inside the kernel is going

00:06:08.150 --> 00:06:09.340
to be a little bit more expensive.

00:06:09.340 --> 00:06:11.380
It gets you closer to the metal,
so it allows you to do things

00:06:11.380 --> 00:06:12.670
you couldn't otherwise do.

00:06:12.820 --> 00:06:16.220
For instance, if you have to respond
directly to an interrupt,

00:06:16.320 --> 00:06:19.180
I don't mean running in the
interrupt context per se,

00:06:19.180 --> 00:06:21.930
but if you have a driver
that needs to take a hardware

00:06:21.930 --> 00:06:24.490
interrupt and do some work,
then you probably need to

00:06:24.490 --> 00:06:25.850
live inside the kernel.

00:06:25.850 --> 00:06:29.800
Now, this shouldn't be confused
with a USB interrupt pipe or

00:06:29.800 --> 00:06:33.840
soft interrupts that are used
in other areas of the system.

00:06:33.910 --> 00:06:38.220
This would be like a PCI card
generating an interrupt on the bus.

00:06:38.510 --> 00:06:40.990
The other reason to live inside
the kernel is if your primary

00:06:40.990 --> 00:06:42.640
client lives inside the kernel.

00:06:42.640 --> 00:06:44.990
Now, examples of this would
be storage drivers.

00:06:45.060 --> 00:06:47.680
They need to live inside the
kernel because the file systems

00:06:47.710 --> 00:06:49.270
themselves live inside the kernel.

00:06:49.350 --> 00:06:52.380
Since 99% of the time,
your media is going to be

00:06:52.400 --> 00:06:55.550
accessed through a file system,
it would be inefficient to have the

00:06:55.550 --> 00:06:59.780
file system driver outside of the
kernel and then have the file system

00:06:59.780 --> 00:07:03.370
driver itself inside the kernel because
that data would have to make multiple

00:07:03.480 --> 00:07:05.780
trips across the user kernel boundary.

00:07:05.780 --> 00:07:08.190
There are some cases when
that's perfectly reasonable.

00:07:08.200 --> 00:07:12.640
In particular, a low bandwidth case,
that might be fine because the amount

00:07:12.640 --> 00:07:15.420
of data you're moving is small enough
that the multiple crossings make sense.

00:07:15.420 --> 00:07:16.000
But if you have a data driver
that's not going to be able to move,

00:07:16.000 --> 00:07:16.000
then you're going to have to
make multiple trips across

00:07:16.000 --> 00:07:16.000
the user kernel boundary.

00:07:16.000 --> 00:07:16.000
In particular, a low bandwidth case,
that might be fine because the amount

00:07:16.000 --> 00:07:16.000
of data you're moving is small enough
that the multiple crossings make sense.

00:07:16.000 --> 00:07:16.080
So, if you have a data
driver inside the kernel,

00:07:16.090 --> 00:07:16.500
you're going to have to make multiple
trips across the user kernel.

00:07:16.500 --> 00:07:24.980
So, you want to have as few
boundary crossings as possible.

00:07:25.230 --> 00:07:30.590
So, the storage drivers
live inside the kernel.

00:07:30.590 --> 00:07:33.240
The file systems stack on top of them.

00:07:35.470 --> 00:07:39.840
So, to talk about what a KEXT looks like,
to a user, it's just a thing.

00:07:39.840 --> 00:07:41.730
It's an icon they drag and drop.

00:07:41.730 --> 00:07:45.120
To developers,
it's a folder containing resources.

00:07:45.220 --> 00:07:48.210
There's really two things in
there that you're going to

00:07:48.210 --> 00:07:49.740
care about most of the time.

00:07:49.740 --> 00:07:52.570
The, really the only required
thing is a property list.

00:07:52.570 --> 00:07:55.880
Now, if you're familiar with
the Mac OS X bundle format,

00:07:55.980 --> 00:07:57.890
a kernel extension is just a bundle.

00:07:57.890 --> 00:07:59.780
There's nothing magic about it.

00:08:00.470 --> 00:08:04.540
But the property list is sort
of the table of contents,

00:08:04.540 --> 00:08:05.310
you could say.

00:08:05.400 --> 00:08:08.890
It contains an XML property list
that contains some standard keys

00:08:08.900 --> 00:08:13.480
like the CFBundle identifier,
which is sort of a global

00:08:13.580 --> 00:08:16.680
name that your bundle goes by,
versions,

00:08:16.890 --> 00:08:19.840
How you load, your matching criteria,
what family you load on,

00:08:19.850 --> 00:08:22.680
all these things are specified
in that XML property list.

00:08:22.730 --> 00:08:27.410
This is read in by the KEXT management
system and used to determine when to load

00:08:27.470 --> 00:08:29.240
your driver and how to go about doing it.

00:08:29.290 --> 00:08:33.080
The other piece that most Kernel
Extensions include is a binary.

00:08:33.410 --> 00:08:35.240
Now, it's actually not required.

00:08:35.420 --> 00:08:38.440
There are a few cases where you
can have a perfectly useful driver

00:08:38.440 --> 00:08:39.840
that doesn't contain a binary.

00:08:39.850 --> 00:08:41.740
It seems a little odd.

00:08:41.800 --> 00:08:44.480
But this is the power of
the XML property list.

00:08:44.540 --> 00:08:49.840
Because of the way that
I/O Kit uses classes,

00:08:49.900 --> 00:08:54.100
you can actually provide a property list
that contains a few overrides and say,

00:08:54.140 --> 00:08:57.500
"I actually want you to load the binary
out of this other Kernel Extension,

00:08:57.530 --> 00:09:00.150
but you're going to pass in
my personality as opposed

00:09:00.150 --> 00:09:02.890
to his." So in that way,
you can override some behaviors.

00:09:03.010 --> 00:09:06.700
We don't use this a whole lot,
but it is particularly useful if

00:09:06.700 --> 00:09:09.760
you have a generic driver that
wants to allow a third party to,

00:09:09.760 --> 00:09:11.740
say, override one particular detail.

00:09:11.740 --> 00:09:15.500
And as long as the person who wrote
that main driver is looking for that

00:09:15.500 --> 00:09:20.220
property and is expecting that override,
a binary list driver is actually

00:09:20.220 --> 00:09:22.010
a pretty good way to go.

00:09:22.190 --> 00:09:24.740
Other things that can go inside
the Kernel Extension bundle:

00:09:24.840 --> 00:09:27.060
localizable string files, icons.

00:09:27.140 --> 00:09:30.740
These are things that the KEXT management
system pretty much ignores,

00:09:30.850 --> 00:09:33.460
but these might be useful if you've
got a preference panel that wants

00:09:33.600 --> 00:09:35.440
to get the localized resources.

00:09:35.530 --> 00:09:39.370
Or other things: you can have utility
binaries stuck in there,

00:09:39.550 --> 00:09:40.790
firmware images.

00:09:40.910 --> 00:09:42.630
Pretty much anything that
you want to bundle along with

00:09:42.640 --> 00:09:45.100
your driver that you want,
from the user's perspective,

00:09:45.100 --> 00:09:48.800
to be an atomic unit that they
drag and drop as a single thing.

00:09:48.890 --> 00:09:50.590
Now, of course,
the user can't tunnel down inside

00:09:50.640 --> 00:09:53.180
there to double-click something,
so you're really not going

00:09:53.250 --> 00:09:55.890
to put an application down
inside your Kernel Extension.

00:09:56.040 --> 00:10:00.940
But you could do that and
create a link if you wanted to.

00:10:02.600 --> 00:10:04.980
The other thing that's important is
you can put other kernel extensions

00:10:04.990 --> 00:10:06.660
inside your kernel extensions.

00:10:06.730 --> 00:10:08.690
There's a plugins folder I'll
show you in a minute that

00:10:08.900 --> 00:10:10.460
contains a place to put them.

00:10:10.590 --> 00:10:13.900
Actually, let's get right to that.

00:10:13.990 --> 00:10:17.260
So the Info.plist I've
already talked about.

00:10:17.260 --> 00:10:20.740
Here are the -- I managed to
talk ahead of the slides here.

00:10:20.820 --> 00:10:25.190
So here's some of the properties
that would be in the Info.plist.

00:10:25.280 --> 00:10:29.470
The CFBundleIdentifier is the global
identifier for all bundles on the system,

00:10:29.470 --> 00:10:31.060
and drivers are no different.

00:10:31.430 --> 00:10:36.680
We recommend that you use a
reverse DNS-style name here.

00:10:36.770 --> 00:10:40.830
Apple, for example,
we use com.apple.driver or com.apple

00:10:40.830 --> 00:10:44.200
I/O Kit for our kernel extensions.

00:10:44.270 --> 00:10:46.990
But you would use whatever would
be appropriate for your own.

00:10:47.000 --> 00:10:50.940
We'd ask that you not use
com.apple for obvious reasons.

00:10:51.560 --> 00:10:55.840
The bundle version, again,
is a standard property that

00:10:55.840 --> 00:11:00.700
uses more or less the Mac OS 9
vers-resource-style versioning.

00:11:00.870 --> 00:11:04.490
We're considering expanding this since
it's kind of constrained on the number

00:11:04.490 --> 00:11:07.750
of digits you can have in each field,
but for today we still enforce a

00:11:07.750 --> 00:11:11.560
vers-resource-style version here.

00:11:11.570 --> 00:11:14.450
The short version string is
the same thing but with the

00:11:14.450 --> 00:11:16.520
build stage information removed.

00:11:17.410 --> 00:11:20.130
OS Bundle Libraries,
I'll talk about more in a little while,

00:11:20.150 --> 00:11:22.340
but this is used to
describe what you depend on,

00:11:22.340 --> 00:11:24.300
what your kernel extension depends on.

00:11:24.330 --> 00:11:27.540
And I/O Kit personalities obviously
only make sense for I/O Kit drivers,

00:11:27.640 --> 00:11:31.850
but that would be where you would
describe the matching information

00:11:31.890 --> 00:11:34.380
for your particular I/O Kit driver.

00:11:35.360 --> 00:11:37.350
This is the binary.

00:11:37.410 --> 00:11:39.490
As I said earlier, it's optional.

00:11:39.710 --> 00:11:41.070
It is in a Mako format.

00:11:41.140 --> 00:11:43.130
If you use our tools,
that's what you'll get by default.

00:11:43.370 --> 00:11:46.170
There's nothing magic
you have to do there.

00:11:47.300 --> 00:11:50.880
There are two standard entry points
into a Kernel Extension's binary.

00:11:50.880 --> 00:11:53.800
They can be named whatever you want,
but sort of generically we call

00:11:53.810 --> 00:11:55.600
them Module Start and Module Stop.

00:11:55.780 --> 00:11:57.070
And the idea here is very simple.

00:11:57.270 --> 00:11:59.800
When your module is first loaded,
your Kernel Extension binary

00:11:59.870 --> 00:12:03.400
is first loaded,
the start entry point is called.

00:12:03.400 --> 00:12:04.780
You can succeed or fail.

00:12:04.930 --> 00:12:07.550
If you fail,
your Kernel Extension is unloaded.

00:12:07.550 --> 00:12:10.510
If you succeed,
your Kernel Extension is considered

00:12:10.580 --> 00:12:14.910
loaded and is added to the list of
drivers that show up under Kextstat,

00:12:15.000 --> 00:12:19.220
which you may have
previously known as KModstat.

00:12:19.220 --> 00:12:22.460
Module Stop will get called later on when
somebody tries to unload your driver,

00:12:22.640 --> 00:12:24.060
and again, you can succeed or fail.

00:12:24.190 --> 00:12:26.710
If you succeed,
then your driver will be unloaded.

00:12:26.710 --> 00:12:29.280
If you fail,
your driver sticks around and can be

00:12:29.300 --> 00:12:32.280
attempted to be stopped again later.

00:12:32.280 --> 00:12:36.120
Now, I/O Kit drivers don't implement
these functions because that's

00:12:36.120 --> 00:12:37.430
done for you by I/O Kit.

00:12:37.430 --> 00:12:40.730
I/O Kit uses these hooks to
get your classes published into

00:12:40.730 --> 00:12:44.020
our class management system,
our runtime system,

00:12:44.120 --> 00:12:47.900
and then we use other techniques
for actually starting your driver.

00:12:47.940 --> 00:12:50.640
But if you're writing a
non-I/O Kit Kernel Extension,

00:12:50.640 --> 00:12:53.290
these are the only two entry
points that are defined for

00:12:53.290 --> 00:12:54.820
Kernel Extensions by default.

00:12:56.950 --> 00:13:01.620
So the plugins folder is a place
for you to put other bundles and,

00:13:01.620 --> 00:13:04.210
in particular, kernel extensions.

00:13:04.300 --> 00:13:06.490
So if you want to nest,

00:13:06.700 --> 00:13:14.720
The KEXT is a kernel extension
that is built into a kernel.

00:13:14.720 --> 00:13:14.720
The kernel extension is a kernel

00:13:14.980 --> 00:13:17.210
That to the user appears to be one thing.

00:13:17.300 --> 00:13:19.890
You can also put other
non-Kext bundles in there.

00:13:19.890 --> 00:13:22.980
Here in this example,
you'll see there's a user client,

00:13:23.030 --> 00:13:27.020
a bundle that's used to get
user-level access to this driver.

00:13:27.020 --> 00:13:29.820
You can put other
completely unrelated bundle,

00:13:29.820 --> 00:13:32.490
well, un-IOKit or un-Kernel
Extension bundles in there.

00:13:32.490 --> 00:13:35.500
Hopefully,
they would be related to the driver.

00:13:35.810 --> 00:13:37.810
Important note though,
we only support one level

00:13:37.820 --> 00:13:40.950
of Kernel Extension nesting,
so you can't have a KEXT within

00:13:40.950 --> 00:13:42.080
a KEXT within a KEXT.

00:13:42.230 --> 00:13:44.910
The bottom level one will be ignored.

00:13:47.170 --> 00:13:51.380
Okay, obviously you're not required
to have any plug-ins.

00:13:51.380 --> 00:13:55.410
And I think I've already talked

00:13:55.610 --> 00:13:58.340
It's a very powerful concept to
deliver something to the user

00:13:58.340 --> 00:13:59.540
that appears to be very simple.

00:13:59.540 --> 00:14:01.570
You can have an arbitrary
number of things,

00:14:01.650 --> 00:14:04.620
moving pieces in there,
that the user sees as one thing.

00:14:09.860 --> 00:14:12.040
Now, Kernel Extensions can
be used as libraries.

00:14:12.150 --> 00:14:14.460
This is something that most
third parties haven't used.

00:14:14.500 --> 00:14:18.600
Some have if you have a complicated
product that you're supporting.

00:14:18.650 --> 00:14:19.750
But this is very important.

00:14:19.770 --> 00:14:22.540
I want to spend some
time talking about this.

00:14:22.580 --> 00:14:26.050
I/O Kit itself is
largely presented to you,

00:14:26.050 --> 00:14:29.420
the developer,
as a collection of library KEXTs.

00:14:29.480 --> 00:14:34.440
Now, when you set your OS bundle
dependencies property,

00:14:34.510 --> 00:14:37.260
that's your way of telling our
KEXT loading system what Kernel

00:14:37.260 --> 00:14:39.680
Extensions you need to link against.

00:14:40.680 --> 00:14:42.840
You also specify a
version number in there,

00:14:43.000 --> 00:14:45.410
which is used to help us tell
whether you're compatible or not.

00:14:45.460 --> 00:14:47.160
I'll talk more about
that in a little while.

00:14:47.220 --> 00:14:48.560
But basically what
you're doing is saying,

00:14:48.560 --> 00:14:51.690
"I depend on this other
kernel extension." Now,

00:14:51.690 --> 00:14:54.040
those kernel extensions
can in turn depend on other

00:14:54.140 --> 00:14:55.740
kernel extensions and so on.

00:14:55.780 --> 00:14:57.810
We build up a dependency
graph at load time.

00:14:57.890 --> 00:15:00.680
When you want to load your driver,
we look at its dependencies

00:15:00.680 --> 00:15:02.400
and its dependencies,
dependencies, and so on,

00:15:02.400 --> 00:15:06.080
and we build up this graph of
required kernel extensions.

00:15:06.130 --> 00:15:08.890
And then we flatten it,
and then we start or

00:15:08.890 --> 00:15:10.340
load all those drivers.

00:15:10.340 --> 00:15:14.010
If we see that it's already loaded
and has been successfully started,

00:15:14.160 --> 00:15:16.310
obviously there's nothing to do.

00:15:16.790 --> 00:15:19.290
But at the, sort of the end of this
graph will be your driver.

00:15:19.300 --> 00:15:21.460
So once all of its
dependencies have been met,

00:15:21.490 --> 00:15:23.380
your driver will be loaded.

00:15:23.450 --> 00:15:25.750
It's important to know, though,
that by listing something

00:15:25.860 --> 00:15:28.530
as a dependency,
your driver will be linked against them.

00:15:28.600 --> 00:15:31.300
So all the rules for
static linking apply.

00:15:31.410 --> 00:15:35.320
If the module you're linking
against exports 50 symbols,

00:15:35.360 --> 00:15:37.440
those symbols are now your symbols.

00:15:37.480 --> 00:15:40.080
And all of the dependencies
that they have,

00:15:40.080 --> 00:15:41.610
you've just inherited those symbols.

00:15:41.710 --> 00:15:47.410
Now, those symbols that you've inherited,
or that you're linking against,

00:15:47.430 --> 00:15:49.710
aren't necessarily visible
to other kernel extensions,

00:15:49.750 --> 00:15:53.180
because they may not have listed
the same dependencies that you have.

00:15:53.260 --> 00:15:56.290
But this is how you go
about getting libraries.

00:15:56.320 --> 00:15:58.720
Now, you can build your own
libraries in the same way.

00:15:58.890 --> 00:16:01.490
You can define a kernel extension.

00:16:01.970 --> 00:16:05.330
That contains 15 APIs that
your collection of drivers

00:16:05.330 --> 00:16:07.100
all want to be able to share.

00:16:07.110 --> 00:16:09.870
You can put it in a kernel
extension by itself,

00:16:09.940 --> 00:16:13.870
and you can provide the OS bundle
compatible version property.

00:16:13.870 --> 00:16:17.340
This is the magic that turns your
kernel extension into a library.

00:16:18.860 --> 00:16:26.210
That property tells us that your driver
is expected to be used as a dependency

00:16:26.300 --> 00:16:27.440
by some other kernel extension.

00:16:27.440 --> 00:16:30.240
If this property is absent,
then that's your way of saying

00:16:30.240 --> 00:16:33.320
you don't expect somebody
to list you as a dependency.

00:16:33.750 --> 00:16:36.880
So the value of this property,
the actual thing on the

00:16:36.880 --> 00:16:40.100
right-hand side of the assignment,
is the oldest version number

00:16:40.250 --> 00:16:42.300
with which you are compatible.

00:16:44.540 --> 00:16:45.840
We'll make this really clear.

00:16:45.930 --> 00:16:48.530
So you have a CFBundle version number.

00:16:48.710 --> 00:16:50.080
Every driver does.

00:16:50.190 --> 00:16:52.140
This is the version of
your current driver,

00:16:52.140 --> 00:16:53.770
your current kernel extension.

00:16:54.570 --> 00:16:59.200
The OS bundle compatible version
specifies the oldest version with which

00:16:59.540 --> 00:17:03.400
the APIs you export are compatible,
or binary compatible.

00:17:03.530 --> 00:17:07.220
So your CFBundle version and
your OS bundle compatible version

00:17:07.770 --> 00:17:09.370
define a range of version numbers.

00:17:09.600 --> 00:17:12.970
Oldest is the OS bundle version,
compatible version,

00:17:12.970 --> 00:17:15.830
and newest is CFBundle version.

00:17:15.830 --> 00:17:15.830
That range

00:17:16.130 --> 00:17:22.070
is what a client driver can use to
determine if it's binary compatible.

00:17:22.270 --> 00:17:23.980
Actually, the KEXT system uses this.

00:17:24.080 --> 00:17:26.870
I believe I have an example of this here.

00:17:27.340 --> 00:17:33.250
So, if you have a driver that depends
on a library that you provide,

00:17:33.580 --> 00:17:35.680
Let's say the library is version 2.

00:17:35.680 --> 00:17:37.350
It doesn't matter what
version the driver is,

00:17:37.460 --> 00:17:39.500
but the library is version 2.

00:17:39.530 --> 00:17:40.170
Excuse me.

00:17:40.390 --> 00:17:44.630
The driver that you're loading
depends on version 2 of the library.

00:17:44.740 --> 00:17:47.850
Now the library could be up to version 3,
but as long as it says it's

00:17:47.900 --> 00:17:52.200
backwards compatible to version 1,
that driver is considered compatible.

00:17:52.330 --> 00:17:55.130
And the reason is the
range from 1.0 to 3.0,

00:17:55.300 --> 00:17:59.310
obviously 2.0 is included in that range.

00:18:01.690 --> 00:18:01.970
Okay.

00:18:02.190 --> 00:18:06.000
So we've talked about
nesting kernel extensions.

00:18:06.000 --> 00:18:09.160
And we talked about using
kernel extensions as libraries.

00:18:09.360 --> 00:18:14.050
Another thing that you can do is use
I/OKit's built in matching capabilities,

00:18:14.050 --> 00:18:17.500
again if you're an I/OKit KEXT,
to bring in other kernel

00:18:17.500 --> 00:18:19.620
extensions in your suite as needed.

00:18:19.660 --> 00:18:23.690
Now, if you look at any of our families,
if you're writing an I/OKit KEXT then you

00:18:23.880 --> 00:18:27.830
by definition are looking at some family,
your driver is going to

00:18:27.830 --> 00:18:29.200
match in on that family.

00:18:29.300 --> 00:18:31.780
That family is going to publish a nub,
it's going to call

00:18:31.780 --> 00:18:33.690
register service on it,
that's going to kick

00:18:33.770 --> 00:18:36.870
off I/OKit's matching,
your driver will be considered as one of

00:18:36.870 --> 00:18:41.380
the possibilities and will be loaded and
started and probed and all that stuff,

00:18:41.450 --> 00:18:43.450
or probed and started.

00:18:44.030 --> 00:18:45.400
: You can use that as well.

00:18:45.410 --> 00:18:48.380
Most of the machinery for
that is built in I/O service.

00:18:48.400 --> 00:18:50.860
You just inherit it with your driver.

00:18:50.860 --> 00:18:53.300
So it need not be a public open family.

00:18:53.440 --> 00:18:56.830
It doesn't have to be something that,
you know, anybody can use.

00:18:56.920 --> 00:19:00.170
It can be a sort of a private
library that you make use of

00:19:00.170 --> 00:19:04.240
yourself or a private matching
engine that you use yourself.

00:19:04.330 --> 00:19:07.490
So basically all you have to do
is have your driver create a nub,

00:19:07.490 --> 00:19:09.270
and that nub can be any class.

00:19:09.270 --> 00:19:12.870
Generally we'll define some class,
you know, I/O, my nub.

00:19:12.980 --> 00:19:14.480
It won't be I/O actually.

00:19:14.480 --> 00:19:16.670
That's reserved by Apple.

00:19:16.670 --> 00:19:17.540
So my nub.

00:19:17.640 --> 00:19:21.590
Hopefully with a little
bit more specific name than

00:19:22.070 --> 00:19:24.140
When you've defined,
instantiated one of those classes

00:19:24.230 --> 00:19:27.490
and it's registered itself,
that causes the matching

00:19:27.490 --> 00:19:28.910
engine to kick off.

00:19:29.130 --> 00:19:33.930
The KEXT Management System is going
to look for drivers that list that

00:19:34.230 --> 00:19:38.020
particular class as what it matches on.

00:19:38.910 --> 00:19:43.980
So the next piece of your driver
suite can match in on that object.

00:19:44.040 --> 00:19:46.920
Now let's assume that your driver
or your small set of drivers are

00:19:46.930 --> 00:19:53.130
the only thing that lists that as
the class that they match against.

00:19:53.130 --> 00:19:53.130
Well, when you do that,

00:19:53.610 --> 00:19:55.520
Only your little private set
of drivers is going to be

00:19:55.560 --> 00:19:56.940
in the running for that nub.

00:19:57.270 --> 00:19:59.360
They'll each be attached and probed.

00:19:59.450 --> 00:20:01.930
And in your probe
routine for your driver,

00:20:01.960 --> 00:20:04.740
you can decide if this
driver is appropriate or not.

00:20:04.890 --> 00:20:09.260
And your client driver,
which is also your driver,

00:20:09.280 --> 00:20:11.860
since it's a multiple driver suite.

00:20:12.120 --> 00:20:14.440
can decide that it's
inappropriate and unload,

00:20:14.530 --> 00:20:19.990
or it can continue and become
part of the active set.

00:20:20.530 --> 00:20:23.810
But you can have as many different
classes of nubs as you want.

00:20:24.000 --> 00:20:28.050
You can have your probe routine look at
the nub to decide based on properties.

00:20:29.310 --> 00:20:32.440
It's a very flexible engine,
and I recommend very strongly

00:20:32.440 --> 00:20:36.070
that if you're interested in
dividing your drivers up this way,

00:20:36.070 --> 00:20:38.840
that you go off and look at
Darwin and look at some of the

00:20:38.840 --> 00:20:39.950
source code for our families.

00:20:39.960 --> 00:20:42.730
It really doesn't need
to be very complicated.

00:20:44.210 --> 00:20:48.320
So the reasons for breaking
up a driver are really,

00:20:48.330 --> 00:20:52.790
you only want to do this for,
basically for two reasons.

00:20:52.870 --> 00:20:55.870
So a NIT time code is one of them,
but that's kind of a special case,

00:20:56.100 --> 00:20:58.880
because obviously you can just build
a NIT time code into your driver.

00:20:58.880 --> 00:21:02.820
If your NIT time code is very large,
particularly like a firmware image,

00:21:02.900 --> 00:21:06.690
having it in a separate loadable
will help ease the cost of the memory

00:21:06.690 --> 00:21:09.960
footprint of your driver setup,
because the runtime

00:21:09.960 --> 00:21:14.640
code will stick around,
but you could unload your firmware.

00:21:14.730 --> 00:21:18.010
The two real reasons to divide
up your Kernel Extension is if

00:21:18.010 --> 00:21:22.830
you have product variants that
allow for mix and match drivers.

00:21:22.830 --> 00:21:27.550
You've got one PCI card family that has,
you know, maybe three different

00:21:27.590 --> 00:21:28.720
kinds of functions on it.

00:21:28.720 --> 00:21:33.920
Maybe one product variant has an audio,
a video, and some other kind of device,

00:21:33.920 --> 00:21:37.940
and a different version of the card
also has a SCSI storage channel on it,

00:21:37.940 --> 00:21:41.790
and maybe a different variant of
the card has something else on else.

00:21:42.280 --> 00:21:45.060
In that case, you probably don't want to
have one big monolithic driver

00:21:45.060 --> 00:21:47.490
driving all those functions,
but you could have one basic

00:21:47.490 --> 00:21:50.920
driver that matches on your cards,
determines what's there,

00:21:51.040 --> 00:21:54.520
publishes nubs for each of the functions,
and then has function-specific

00:21:54.520 --> 00:21:55.740
drivers match in.

00:21:55.740 --> 00:21:58.320
It's a perfectly appropriate
use of I/O Kit matching.

00:21:58.340 --> 00:22:00.780
That's effectively what we do,
if you think about it.

00:22:00.890 --> 00:22:04.270
You consider the PCI bus
locating various functions,

00:22:04.270 --> 00:22:08.360
various devices hanging off of it,
and probing each of those drivers.

00:22:08.490 --> 00:22:11.000
Well, you can think of your card,
in that case, or your product, as a bus,

00:22:11.000 --> 00:22:14.900
so to speak, that a variety of
devices may hang off of.

00:22:15.530 --> 00:22:19.780
Another reason to split your
driver up is sort of the opposite.

00:22:19.840 --> 00:22:22.800
You've got one peripheral,
but it may attach to the

00:22:22.800 --> 00:22:24.490
system in a variety of ways.

00:22:24.620 --> 00:22:29.890
Now,
I'll use a generic ADB or USB device.

00:22:29.940 --> 00:22:32.460
We can say a mouse,
but we have generic drivers for that.

00:22:32.650 --> 00:22:36.490
So, USB toaster or an ADB toaster.

00:22:37.450 --> 00:22:38.460
The device is the same.

00:22:38.630 --> 00:22:41.490
The actual packets that you're getting
and processing may be the same,

00:22:41.570 --> 00:22:44.440
but your way of attaching
to it is different.

00:22:44.540 --> 00:22:49.390
Now, you could attack this by providing
two completely different drivers that

00:22:49.390 --> 00:22:51.540
have nothing in common at runtime.

00:22:51.540 --> 00:22:55.160
Maybe they share some source code,
but one matches on the ADB family,

00:22:55.160 --> 00:22:56.820
one matches on the USB family.

00:22:56.950 --> 00:22:58.440
99% of the code's identical.

00:22:58.440 --> 00:23:00.360
It's just duplicated.

00:23:00.480 --> 00:23:04.060
Or you can make use of
something that I/O Kit allows,

00:23:04.160 --> 00:23:06.270
and that is to split your
driver into two pieces.

00:23:06.400 --> 00:23:09.320
You can have one very small
piece that matches on ADB,

00:23:09.330 --> 00:23:13.420
the ADB device, one small piece that
matches on the USB device,

00:23:13.500 --> 00:23:18.560
and then those can instantiate a nub
or can actually be the nub by simply

00:23:18.560 --> 00:23:21.130
calling register service on themselves.

00:23:21.200 --> 00:23:24.300
That will match in the one
big driver that's common,

00:23:24.350 --> 00:23:27.750
the bulk of your driver
that does all the real work.

00:23:29.570 --> 00:23:32.080
Now, if you've already shipped
a product like this,

00:23:32.080 --> 00:23:34.980
maybe you have,
there's absolutely nothing stopping

00:23:35.070 --> 00:23:37.990
you from putting all of those
classes into one kernel extension.

00:23:38.080 --> 00:23:41.450
In fact, we would generally encourage
you to put as much as you can

00:23:41.560 --> 00:23:43.250
into one kernel extension.

00:23:43.360 --> 00:23:46.250
The reason you split up in this
case is because of the dependencies.

00:23:46.360 --> 00:23:48.860
Remember, when you declare that you're
dependent on something,

00:23:48.860 --> 00:23:52.790
we have to load it, initialize it,
and all of the things it depends on.

00:23:52.910 --> 00:23:58.300
On a modern Macintosh,
the ADB family is pretty much not used.

00:23:58.700 --> 00:24:04.390
If you have one driver that depends both
on the USB family and on the ADB family,

00:24:04.470 --> 00:24:06.380
it's going to bring both
of those families in,

00:24:06.510 --> 00:24:08.900
whether or not you actually use them.

00:24:09.990 --> 00:24:12.270
So by splitting your driver
into three kernel extensions,

00:24:12.390 --> 00:24:17.030
a USB-specific one, an ADB-specific one,
and then the generic chunk

00:24:17.150 --> 00:24:20.380
that does all the work,
only the appropriate one will match in.

00:24:20.380 --> 00:24:23.970
The USB one will match in or
the ADB one will match in.

00:24:24.260 --> 00:24:28.190
and then they will match in the big one,
but you won't bring the ADB family in if

00:24:28.230 --> 00:24:33.320
your device is plugged in via USB port,
and vice versa on one of the older

00:24:33.320 --> 00:24:37.040
G3s that doesn't have USB by default.

00:24:37.220 --> 00:24:41.990
If you have your device attached by ADB,
the USB family wouldn't be loaded.

00:24:42.260 --> 00:24:44.940
Keep in mind the difference between
being loaded and being active.

00:24:45.050 --> 00:24:47.330
Being loaded simply means the
code is resident in the kernel.

00:24:47.340 --> 00:24:49.490
It doesn't mean anybody is running it.

00:24:49.620 --> 00:24:53.810
Active or instantiated is when
your driver is actually in use.

00:24:55.520 --> 00:25:00.760
Alright, I want to talk a little bit
about when drivers load.

00:25:00.770 --> 00:25:04.990
This has been discussed on
the Darwin groups a good bit.

00:25:05.600 --> 00:25:07.360
I believe that there's
a document out there,

00:25:07.360 --> 00:25:09.430
I think on the next slide
I've got a reference to it,

00:25:09.530 --> 00:25:13.030
that describes the various
stages of bootloading.

00:25:13.150 --> 00:25:16.550
But by default,
if you don't have this OS bundle required

00:25:16.670 --> 00:25:18.910
property in your kernel extension,

00:25:19.260 --> 00:25:22.130
Your driver will only be
considered for loading relatively

00:25:22.130 --> 00:25:24.860
late in the boot process,
well before the login panel,

00:25:24.980 --> 00:25:28.440
but after the machine
has gone multi-user.

00:25:28.610 --> 00:25:33.420
Now, there are cases where you need
to have a driver come in earlier.

00:25:33.520 --> 00:25:37.110
In theory,
you should only have to do that if the

00:25:37.110 --> 00:25:42.130
driver may be used for the root device,
the startup volume.

00:25:42.630 --> 00:25:45.130
So OS bundle required would
be added in that case.

00:25:45.300 --> 00:25:48.690
There are a few other types of drivers
that may need to come in early.

00:25:48.790 --> 00:25:53.350
And also I'm aware that a few of
our families have generic drivers

00:25:53.510 --> 00:25:56.470
that will match in very early,
so you might need to have this

00:25:56.470 --> 00:25:58.050
property in order to compete.

00:25:58.160 --> 00:26:02.560
But the next slide,
I think I show the various levels.

00:26:02.800 --> 00:26:04.690
So what happens?

00:26:04.690 --> 00:26:09.700
Boot-ex is the piece of
Mac OS X that starts the kernel.

00:26:09.700 --> 00:26:11.220
So it really has a couple functions.

00:26:11.220 --> 00:26:14.640
One of them is to load the kernel itself,
and the other one is to load

00:26:14.650 --> 00:26:18.110
all the drivers necessary for
getting to the file system,

00:26:18.130 --> 00:26:19.590
getting to the startup

00:26:20.610 --> 00:26:23.300
In order to make that fast,
we create this cache file.

00:26:23.300 --> 00:26:25.310
We call it extensions.imkext.

00:26:25.350 --> 00:26:27.790
imkext stands for multicast.

00:26:28.290 --> 00:26:31.200
Now,
if you've developed at all with 10.1,

00:26:31.200 --> 00:26:33.700
you've probably encountered this file.

00:26:34.520 --> 00:26:37.520
The whole point of it is to avoid
the booter having to go and scan

00:26:37.520 --> 00:26:39.400
the whole extensions folder.

00:26:39.530 --> 00:26:42.700
So we decide based on modification date.

00:26:42.810 --> 00:26:45.900
If the cache is newer than
the extensions folder,

00:26:46.020 --> 00:26:48.340
then we assume the cache is good.

00:26:48.340 --> 00:26:49.020
This is important.

00:26:49.020 --> 00:26:51.000
I'll talk a little more about this later.

00:26:51.120 --> 00:26:54.560
So the cache is basically just
a compressed archive of all the

00:26:54.570 --> 00:26:59.160
drivers that have OS bundle root
set to an appropriate value.

00:27:01.300 --> 00:27:05.590
If the cache is stale or missing,
then BootX actually does go and

00:27:05.590 --> 00:27:08.500
scan the entire extensions folder,
looking for drivers that

00:27:08.500 --> 00:27:10.900
have the right properties,
and will load them individually.

00:27:10.900 --> 00:27:14.330
It's a much slower process,
so obviously we want to boot off

00:27:14.330 --> 00:27:16.300
the cache as much as possible.

00:27:16.810 --> 00:27:18.630
So Boot-X just simply brings them in.

00:27:18.640 --> 00:27:21.020
It doesn't actually link them
or try to make use of them.

00:27:21.020 --> 00:27:23.740
So it's loaded the kernel,
it's loaded all of the drivers

00:27:23.740 --> 00:27:26.060
either in the cache or individually.

00:27:26.150 --> 00:27:27.610
Then it starts the kernel.

00:27:27.630 --> 00:27:31.020
At this point, the kernel is basically
detached from the outside world.

00:27:31.020 --> 00:27:34.290
It has no ability to do I/O.

00:27:34.780 --> 00:27:38.100
All it has is the drivers
that Budex brought in.

00:27:38.100 --> 00:27:41.380
So it's going to go through
and as drivers are requested,

00:27:41.380 --> 00:27:44.980
it's going to choose from the list
of drivers that Budex brought in and

00:27:44.980 --> 00:27:46.440
instantiate those and make use of them.

00:27:46.440 --> 00:27:50.090
And that's going to build up, hopefully,
enough devices, enough access to get

00:27:50.150 --> 00:27:51.740
you to the root volume.

00:27:51.800 --> 00:27:55.150
Once you've got the root volume,
BSD can finish its startup

00:27:55.150 --> 00:27:56.620
because it now has a root device.

00:27:56.840 --> 00:28:01.450
And Machinit runs and we can have
other processes starting to run.

00:28:01.500 --> 00:28:05.840
At some point, the ETSI RC script runs
and it will start Kextd.

00:28:05.910 --> 00:28:08.730
Kextd is the daemon that
is responsible for keeping

00:28:08.770 --> 00:28:11.060
KEXTs loaded and unloaded as needed.

00:28:14.160 --> 00:28:18.180
At this point, Kexty contacts the kernel,
the in-kernel code that

00:28:18.180 --> 00:28:21.780
manages the boot time stuff,
and says, "I'm going to take over

00:28:21.780 --> 00:28:24.680
KEXT management duties." Again,
this is part of that "kernel

00:28:24.690 --> 00:28:26.550
resources are expensive" mantra.

00:28:26.690 --> 00:28:29.850
We basically implemented
this whole system twice,

00:28:29.860 --> 00:28:31.760
just because this heavyweight
stuff doesn't need to live

00:28:31.760 --> 00:28:33.820
in the kernel after booting.

00:28:33.900 --> 00:28:36.770
So the kernel resident linking code
is jettisoned to free up that memory,

00:28:36.850 --> 00:28:40.340
as well as all the images that
Boot-Ex loaded that we didn't use.

00:28:40.470 --> 00:28:42.510
We speculatively load a lot of drivers.

00:28:42.590 --> 00:28:45.580
We may not need more than half
of them or a quarter of them.

00:28:45.750 --> 00:28:48.980
So then Kexty processes KEXT load
requests from that point on.

00:28:48.980 --> 00:28:53.200
The kernel talks to Kexty,
says please load this kernel extension,

00:28:53.200 --> 00:28:56.770
and it gets loaded on
the kernel's behalf.

00:28:58.430 --> 00:29:00.400
Now, why do Kernel Extensions load?

00:29:00.460 --> 00:29:03.740
I get this question a good bit.

00:29:03.740 --> 00:29:06.340
One of the very important things
is we do not load a Kernel

00:29:06.400 --> 00:29:09.240
Extension simply because it's installed.

00:29:09.450 --> 00:29:12.580
This is sort of a philosophical
point with the way KEXTs work.

00:29:12.680 --> 00:29:14.750
Something has to generate
the demand for them.

00:29:14.960 --> 00:29:16.330
They're a way to extend the kernel.

00:29:16.330 --> 00:29:20.360
I/O Kit has a pretty
extensive mechanism for this.

00:29:20.360 --> 00:29:26.980
The device detection and matching will
bring the drivers in by calling Kexty.

00:29:26.980 --> 00:29:30.120
File system kernel extensions are
loaded because you want to mount a

00:29:30.120 --> 00:29:32.700
volume that needs to make use of them.

00:29:32.700 --> 00:29:33.680
That makes sense, right?

00:29:33.680 --> 00:29:36.700
If you start the machine up
and you never add another disk,

00:29:36.700 --> 00:29:39.120
you probably don't need to have
all those other file systems

00:29:39.120 --> 00:29:41.120
loaded until you see new media.

00:29:41.240 --> 00:29:45.420
So doing it at mount
time seems to make sense,

00:29:45.470 --> 00:29:47.280
and that works well.

00:29:48.770 --> 00:29:51.420
NKEs are typically
loaded by startup items.

00:29:51.480 --> 00:29:54.500
In some cases,
they're loaded by particular actions,

00:29:54.500 --> 00:29:58.860
like if you go to make a PPP connection,
the PPP kernel extension may be

00:29:58.860 --> 00:30:01.690
loaded when it wasn't loaded before.

00:30:01.850 --> 00:30:05.200
But basically, throughout the system,
a kernel extension isn't

00:30:05.200 --> 00:30:06.630
loaded just because it's there.

00:30:06.690 --> 00:30:10.880
It's loaded because something has said,
"Yes, I have a need for this."

00:30:11.400 --> 00:30:15.090
This really goes back to the three
universes I presented early on.

00:30:15.100 --> 00:30:17.540
I said there's I/O Kit, NKEs,
and file systems.

00:30:17.660 --> 00:30:21.740
Your kernel extension needs to fit
into a place carved out for it.

00:30:21.740 --> 00:30:25.810
It needs to count on having
the kernel call into it.

00:30:25.980 --> 00:30:30.010
It needs to be able to call into
the kernel and have APIs to talk to.

00:30:30.110 --> 00:30:33.860
Module start and module stop are
not very interesting by themselves.

00:30:33.950 --> 00:30:36.850
You can run the Hello Kernel
tutorial that shows you how to

00:30:36.920 --> 00:30:39.400
write a kernel extension that
does nothing but print out,

00:30:39.460 --> 00:30:44.280
"Okay, I'm loaded." Beyond that,
there's not very much interesting stuff

00:30:44.370 --> 00:30:49.570
you can do without having some sort of
a deeper relationship with the kernel.

00:30:49.880 --> 00:30:51.990
Having something generate
that demand is the way to go.

00:30:52.000 --> 00:30:56.250
If there really isn't anything,
you've sort of stepped outside the

00:30:56.360 --> 00:30:59.610
universe of these three standard areas,
and you're doing something

00:30:59.610 --> 00:31:00.760
sort of on the fringe.

00:31:00.760 --> 00:31:03.380
You need to have the kernel
extension loaded all the time.

00:31:03.380 --> 00:31:04.440
It's not a file system.

00:31:04.440 --> 00:31:07.050
It's not an NKE,
and you don't want to use

00:31:07.050 --> 00:31:08.780
I/O Kit because it's not a device.

00:31:08.780 --> 00:31:13.630
You can have a startup item that
calls Kextload and loads that driver

00:31:13.780 --> 00:31:15.080
every time the machine starts.

00:31:15.140 --> 00:31:16.350
So that would be the workaround.

00:31:16.360 --> 00:31:17.170
That's the way to do that.

00:31:17.200 --> 00:31:18.670
That should be rare.

00:31:18.940 --> 00:31:21.810
You should really avoid doing something
like that unless you just simply have

00:31:21.840 --> 00:31:23.580
no other way to accomplish your goal.

00:31:27.960 --> 00:31:31.550
So the exact rules for what
generates the event is going to--

00:31:31.550 --> 00:31:35.340
the load request event is going to
vary depending on the situation.

00:31:35.380 --> 00:31:39.240
So what causes a kernel
extension to unload?

00:31:39.650 --> 00:31:41.610
More or less the reverse.

00:31:41.670 --> 00:31:46.280
I/O Kit has class reference counts,
or instance reference counts.

00:31:46.280 --> 00:31:51.540
So we track what classes you've defined,
and we track how many

00:31:51.540 --> 00:31:55.640
instances there are of those,
and instances of subclasses of

00:31:55.710 --> 00:31:58.270
classes that you've defined,
and so on.

00:31:58.270 --> 00:32:02.430
And what we try to do is wait until all
of your objects that have been allocated

00:32:02.430 --> 00:32:05.890
out of that driver have been freed,
and no other drivers are loaded

00:32:05.950 --> 00:32:07.500
that list user dependency.

00:32:07.500 --> 00:32:10.580
We believe that at this point you're
completely clean and can be unloaded.

00:32:10.670 --> 00:32:13.240
About a minute later, we'll unload you.

00:32:13.240 --> 00:32:17.020
Now, we included that time delay there
because we figure somebody might

00:32:17.020 --> 00:32:19.840
be rearranging their desktop,
unplugging a mouse,

00:32:19.840 --> 00:32:23.500
unplugging a keyboard or a camera or
whatever to get this hub plugged in.

00:32:23.500 --> 00:32:26.670
And we don't want to have this instant
flurry of unloading all the drivers,

00:32:26.690 --> 00:32:29.140
and then 15 seconds later
when they plug it all back up,

00:32:29.210 --> 00:32:31.050
have a flurry of reloading them.

00:32:31.100 --> 00:32:32.620
So we kind of do it lazily.

00:32:32.620 --> 00:32:34.970
If you're a developer,
that can be a little annoying because

00:32:34.970 --> 00:32:37.280
you're trying to do this load,
debug, unload cycle.

00:32:37.280 --> 00:32:40.700
Be aware that you need to manually
unload your driver if you want

00:32:40.700 --> 00:32:43.270
it out of there immediately.

00:32:43.500 --> 00:32:49.090
File system Kernel Extensions can
unload in their unmount commands

00:32:49.140 --> 00:32:51.070
if they want at unmount time.

00:32:51.860 --> 00:32:53.380
NKEs typically don't unload.

00:32:53.590 --> 00:32:57.000
Sometimes they do,
but they tend to be services

00:32:57.000 --> 00:32:59.860
that are available for the
entire lifetime of the system,

00:32:59.860 --> 00:33:03.190
so they'll load in a startup
item and stay loaded.

00:33:03.760 --> 00:33:07.080
But again, something like PPP,
if you don't have an active connection,

00:33:07.080 --> 00:33:10.700
that Kernel Extension can be unloaded
when the connection goes away.

00:33:11.900 --> 00:33:16.960
So, again, you can use the KEXT unload
utility to try to unload a KEXT.

00:33:17.030 --> 00:33:19.500
Though the Kernel Extension has
the final word there.

00:33:19.500 --> 00:33:20.800
I mean, they're wired into the kernel.

00:33:20.800 --> 00:33:22.020
They've got pointers everywhere.

00:33:22.220 --> 00:33:24.440
The KEXT unload request can fail.

00:33:24.520 --> 00:33:27.750
And, in fact,
when you're developing Kernel Extensions,

00:33:27.750 --> 00:33:31.230
that's one of the first things you
want to try to keep -- get working

00:33:31.290 --> 00:33:35.360
and keep working is making sure that
your Kernel Extension can unload.

00:33:35.360 --> 00:33:37.190
Make sure you're not having
references wired around.

00:33:37.240 --> 00:33:39.160
So, once you get that working,
every time you rev the

00:33:39.210 --> 00:33:42.090
driver and test it again,
make sure unloading still works.

00:33:42.140 --> 00:33:44.200
It's a sure sign you've got some
kind of a reference count problem

00:33:44.200 --> 00:33:46.740
if we refuse to unload your driver.

00:33:48.580 --> 00:33:50.560
Binary compatibility.

00:33:50.680 --> 00:33:54.770
So as I said earlier,
Kernel Extension management is based...

00:33:54.890 --> 00:33:57.950
Aside from the XML property list,
everything that we do is

00:33:57.980 --> 00:33:59.210
based on static linking.

00:33:59.260 --> 00:34:01.440
The rules are very straightforward.

00:34:01.530 --> 00:34:03.110
It's all based on what symbols are there.

00:34:03.220 --> 00:34:07.030
You can use the NM utility to dump
the symbols of a kernel extension

00:34:07.030 --> 00:34:10.220
binary to see what's there,
what's defined, what's undefined,

00:34:10.310 --> 00:34:11.880
see how all the linking works.

00:34:11.970 --> 00:34:13.950
But basically,
we've got what's in the kernel

00:34:13.950 --> 00:34:16.490
extension symbol table to work with,
and that's it.

00:34:17.420 --> 00:34:22.120
So in order to be successful at having
a driver that works on future releases,

00:34:22.200 --> 00:34:26.570
you have to list all the
CFBundle identifiers that you depend on.

00:34:27.340 --> 00:34:29.550
Now there's a document,
Kernel Extension Dependencies,

00:34:29.550 --> 00:34:32.640
it needs to be updated for this release
and we'll be doing that shortly.

00:34:32.770 --> 00:34:35.880
But it describes what versions
of what families shipped with

00:34:35.880 --> 00:34:39.050
the various releases of Mac OS X,
so you can use an appropriate

00:34:39.660 --> 00:34:41.440
version that you depend on.

00:34:41.580 --> 00:34:43.640
But it's important.

00:34:44.120 --> 00:34:47.840
The kernel, the big monolithic block,
mock-under-bore kernel,

00:34:47.870 --> 00:34:50.160
is divided into four separate areas.

00:34:50.160 --> 00:34:53.960
There's Mach, there's BSD,
there's I/O Kit, there's libkern,

00:34:53.960 --> 00:34:55.660
and there's actually a few others.

00:34:55.700 --> 00:34:58.720
But these are the ones that
you would list as dependencies

00:34:58.720 --> 00:35:00.000
in your kernel extension.

00:35:00.060 --> 00:35:04.630
If your kernel extension uses
both BSD and I/O Kit headers,

00:35:04.630 --> 00:35:09.950
you really need to list both
I/O Kit and BSD as a dependency.

00:35:10.860 --> 00:35:13.310
Today, if you don't do that,
let's say you just list I/O Kit,

00:35:13.310 --> 00:35:16.430
but you're including
BSD headers on the side.

00:35:16.530 --> 00:35:19.640
Imagine that in a future release,
Apple decides, "Oh,

00:35:19.640 --> 00:35:22.250
we're going to split up the kernel
and have I/O Kit and BSD and

00:35:22.250 --> 00:35:29.380
Mach loaded separately." I don't
think we're likely to do that because

00:35:29.380 --> 00:35:29.380
it doesn't really buy us anything,
but the architecture supports it.

00:35:30.020 --> 00:35:32.700
In that case,
you would have an unexpressed dependency.

00:35:32.700 --> 00:35:35.220
You depend on BSD,
but you didn't express it.

00:35:35.220 --> 00:35:37.430
So what's going to happen is
we're going to try to load you.

00:35:37.430 --> 00:35:39.680
We think we've met all your dependencies.

00:35:39.710 --> 00:35:41.340
We linked you against I/O Kit.

00:35:41.390 --> 00:35:42.990
But you're going to
have undefined symbols.

00:35:43.000 --> 00:35:45.730
It's exactly like having a binary
that you're trying to compile,

00:35:45.840 --> 00:35:48.140
but you haven't listed all
the libraries that you need.

00:35:48.140 --> 00:35:52.260
You can't get that final executable
until you've listed all your libraries.

00:35:52.260 --> 00:35:56.170
So it's important that
you get those right.

00:35:56.520 --> 00:35:59.150
Another thing that is
important to understand,

00:35:59.150 --> 00:36:02.600
you need to build using the
headers from the oldest version of

00:36:02.600 --> 00:36:04.590
the OS on which you want to run.

00:36:05.250 --> 00:36:10.740
This is particularly important for
I/O Kit because of the way C++ works.

00:36:10.850 --> 00:36:16.090
But basically what you want to do is say,
I want to run on Mac OS 10.1.0.

00:36:16.160 --> 00:36:20.100
So you pick the headers that were
associated with that release,

00:36:20.230 --> 00:36:23.970
and you build using those headers,
you'll get code that's compatible

00:36:23.970 --> 00:36:26.090
with anything from that release on.

00:36:26.410 --> 00:36:30.370
Our direction here is to provide
a more configurable system sort of

00:36:30.370 --> 00:36:34.890
built into the headers so that we can,
at build time, look at your dependencies,

00:36:34.890 --> 00:36:37.780
look at the versions you've
listed for your dependencies,

00:36:37.780 --> 00:36:40.860
and make sure by using
preprocessor tricks that you're

00:36:40.860 --> 00:36:43.940
only getting the APIs that were
appropriate for that release.

00:36:43.940 --> 00:36:48.220
So if you're trying to use something
that's outside of the version that

00:36:48.220 --> 00:36:51.360
you've declared a dependency on,
you would get a compile time failure.

00:36:51.680 --> 00:36:52.710
We don't have that in place yet.

00:36:52.750 --> 00:36:53.940
That's what we're working on.

00:36:53.940 --> 00:36:56.340
So that would allow you to
use newer headers as long as

00:36:56.340 --> 00:36:57.950
your dependencies were right.

00:36:57.960 --> 00:36:59.870
But for now,
you need to stick with the oldest

00:36:59.880 --> 00:37:01.420
headers that are appropriate.

00:37:03.320 --> 00:37:06.880
GCC transition.

00:37:07.130 --> 00:37:13.670
Jaguar contains the ability to take an
older driver and we call it remangling.

00:37:13.710 --> 00:37:18.420
We basically take the C++ symbols
and remangle them into GCC3 symbols,

00:37:18.420 --> 00:37:19.820
which are different.

00:37:19.820 --> 00:37:21.720
And we can load them then.

00:37:21.780 --> 00:37:25.280
I/O Kit and the kernel's
C++ infrastructure are

00:37:25.440 --> 00:37:29.440
natively GCC3 and Jaguar.

00:37:29.580 --> 00:37:33.340
In older versions,
it was based on GCC295 or 297

00:37:33.340 --> 00:37:39.040
or various minor variants there,
but the ABI was pretty much 295.

00:37:39.040 --> 00:37:42.460
So if you want your driver or
your kernel extension to run

00:37:42.460 --> 00:37:47.850
on a system prior to Jaguar,
then you need to use the old compiler.

00:37:48.060 --> 00:37:52.160
Now, you can do this by taking
the -- specifying the 295

00:37:52.230 --> 00:37:56.150
compiler in Project Builder,
or you can just use an

00:37:56.170 --> 00:37:58.620
older development tools,
depending on what you're practicing.

00:37:58.620 --> 00:38:03.130
preferences are,
but something to keep in mind.

00:38:04.800 --> 00:38:08.060
Okay, this has been said a few times,
I just want to make it clear.

00:38:08.110 --> 00:38:11.980
If you can avoid direct
use of Mach and BSD APIs,

00:38:12.070 --> 00:38:15.280
then your kernel extension is
going to have a lot better chance

00:38:15.290 --> 00:38:17.020
of working on future releases.

00:38:17.620 --> 00:38:20.990
BSD and Mach are going to change.

00:38:21.040 --> 00:38:24.390
We're going to introduce new
APIs that are forward supportable,

00:38:24.390 --> 00:38:26.400
and we're going to
deprecate the existing APIs.

00:38:26.480 --> 00:38:28.480
Right now,
we just simply advertise structures

00:38:28.480 --> 00:38:32.620
and internal components that are so
intrinsic to the way the kernel operates,

00:38:32.670 --> 00:38:35.470
if we ever want to change those,
we have to break binary compatibility.

00:38:35.560 --> 00:38:41.170
So if you can avoid use of those APIs,
your life will be better.

00:38:43.520 --> 00:38:46.050
So how do you find out
about the new APIs?

00:38:46.060 --> 00:38:49.540
Well, tracking the Darwin list is
a really good way to do it.

00:38:49.540 --> 00:38:53.260
Most of the people working in the
kernel space tend to linger there.

00:38:53.260 --> 00:38:56.100
We'll post important
shifts like this there.

00:38:56.100 --> 00:38:58.740
Obviously,
the new emerging APIs are likely to

00:38:58.740 --> 00:39:02.890
show up there first because they'll
be checked in as we're evolving them.

00:39:03.250 --> 00:39:05.970
And of course,
your normal developer relations

00:39:05.970 --> 00:39:09.810
contacts here at Apple will be able
to give you the information on that.

00:39:11.670 --> 00:39:15.540
Another thing to avoid
is mixing API sets.

00:39:15.690 --> 00:39:19.000
Now, since we've kind of told you to
stick with I/O Kit for the time

00:39:19.000 --> 00:39:23.690
being for Kernel Extensions,
a very important example

00:39:24.390 --> 00:39:26.400
Let's say you're writing an
I/O Kit driver and you need to

00:39:26.420 --> 00:39:28.940
get access to a physical address.

00:39:28.950 --> 00:39:32.540
You really should be sticking with
I/O Kit APIs if it's an I/O Kit driver.

00:39:32.540 --> 00:39:35.230
In particular,
you should be using the I/O memory

00:39:35.230 --> 00:39:40.100
descriptor and I/O memory cursor classes
to get at your physical addresses.

00:39:41.210 --> 00:39:45.090
If you call PMAP extract directly,
you're going around I/O Kit,

00:39:45.160 --> 00:39:47.680
you're going into Mach,
and that happens to be an

00:39:47.680 --> 00:39:49.700
API that is going to change.

00:39:49.770 --> 00:39:55.610
So you definitely want to try to
migrate away from mixed use of API sets.

00:39:55.720 --> 00:39:58.850
Try to stick within the
abstraction that you've chosen.

00:39:58.860 --> 00:40:02.360
If you're an I/O Kit driver,
use all I/O Kit APIs except

00:40:02.360 --> 00:40:04.710
where you just absolutely cannot.

00:40:08.100 --> 00:40:10.720
So, manipulating a kernel
extension from an application.

00:40:10.850 --> 00:40:13.600
This is really talking about
installing them and uninstalling them.

00:40:13.600 --> 00:40:17.110
There have been a few problems,
and I think Apple needs to be a

00:40:17.160 --> 00:40:21.270
little bit more clear on how you go
about actually manipulating them.

00:40:21.460 --> 00:40:24.700
The problem here is the
file system is the database.

00:40:24.980 --> 00:40:27.650
and we're limited by what
the file system can do.

00:40:27.660 --> 00:40:30.840
The Kexty and KEXT management
system that's sitting there

00:40:30.910 --> 00:40:34.300
watching for files to come and go,
we don't have file notifications,

00:40:34.300 --> 00:40:35.790
so we can't tell that a file's popped up.

00:40:37.680 --> 00:40:41.380
So what I would recommend is to
try to keep operations atomic.

00:40:41.450 --> 00:40:44.480
You should actually install
your driver somewhere other

00:40:44.480 --> 00:40:45.590
than its final destination.

00:40:45.600 --> 00:40:48.220
Probably temp is a good choice.

00:40:48.640 --> 00:40:51.570
And then when you move it
into the extensions folder,

00:40:51.590 --> 00:40:55.920
that kernel extension is going
to show up as a single operation.

00:40:56.230 --> 00:40:59.390
Now, it hasn't really been a problem,
but you can imagine

00:40:59.390 --> 00:41:02.630
what would happen is if,
let's say the user is

00:41:02.630 --> 00:41:06.250
doing their install,
and at the same instant they say, oh,

00:41:06.250 --> 00:41:07.470
I'll go ahead and plug my device in.

00:41:07.500 --> 00:41:12.790
So they plug in the device,
and I/O Kit says, oh, okay, well,

00:41:12.790 --> 00:41:14.090
let's look for a driver for this.

00:41:14.100 --> 00:41:16.620
And it goes and finds the
half-installed kernel extension.

00:41:16.620 --> 00:41:19.680
The Info.plist may be there,
but the binary isn't

00:41:19.680 --> 00:41:20.820
there or isn't all there.

00:41:20.820 --> 00:41:23.000
You're going to get
unpredictable results.

00:41:23.000 --> 00:41:25.840
So by installing it somewhere else
and then moving it into place,

00:41:26.100 --> 00:41:28.560
you're guaranteed that it's
either all there or all not there.

00:41:28.560 --> 00:41:30.400
So you get more deterministic behavior.

00:41:30.400 --> 00:41:32.050
Same thing for removing them.

00:41:32.060 --> 00:41:35.550
If you're removing a kernel extension,
you should move it to slash temp.

00:41:35.600 --> 00:41:37.880
In fact,
you don't even need to delete it.

00:41:37.960 --> 00:41:40.020
Our system will take care
of that on the next reboot.

00:41:40.020 --> 00:41:41.210
All right.

00:41:42.330 --> 00:41:44.610
"A lot guarantees you're not going
to have partially removed Kernel

00:41:44.610 --> 00:41:48.060
Extensions that we might try to load.

00:41:48.090 --> 00:41:51.060
Also, you don't even have to
install your Kernel Extensions

00:41:51.110 --> 00:41:53.090
in the Extensions folder.

00:41:53.170 --> 00:42:00.210
In particular,
if you have an application that it only

00:42:00.210 --> 00:42:00.210
makes sense for the Kernel Extension to
be in use while that app is running.

00:42:00.340 --> 00:42:02.750
An example of that might
be a security dongle.

00:42:02.900 --> 00:42:05.300
Now, hopefully this will be USB and
you'll be able to make use of

00:42:05.300 --> 00:42:08.270
a user land driver for that,
but let's say for whatever reason

00:42:08.270 --> 00:42:11.700
you really needed to load something
into the kernel when the app was

00:42:11.760 --> 00:42:13.610
running for security purposes.

00:42:14.620 --> 00:42:17.880
You could actually put that driver
inside your application wrapper,

00:42:17.890 --> 00:42:20.340
and it would never even be
considered for loading at any

00:42:20.370 --> 00:42:24.740
other time until your app runs,
and then the app can load the driver.

00:42:24.740 --> 00:42:28.200
What it needs to do is have a
little separate set UID utility,

00:42:28.200 --> 00:42:31.730
a little binary that can run,
and it basically forks

00:42:31.730 --> 00:42:33.600
and execs KEXT load.

00:42:33.690 --> 00:42:35.790
In the future,
we want to come up with a library

00:42:36.030 --> 00:42:39.240
for KEXT management that you
can do this programmatically,

00:42:39.350 --> 00:42:43.130
and we're also looking at the
possibility of relaxing some of

00:42:43.160 --> 00:42:46.440
the restrictions on having to be
root to load a kernel extension.

00:42:46.440 --> 00:42:50.590
But for now, these are the rules as
we've had in the past.

00:42:52.310 --> 00:42:55.440
KEXT Preferences.

00:42:55.470 --> 00:42:59.490
I've had a number of
questions about these lately,

00:42:59.490 --> 00:42:59.490
and

00:42:59.960 --> 00:43:02.740
I really would encourage
people to come up with creative

00:43:02.740 --> 00:43:05.810
ways to avoid needing them,
because if you have a setting

00:43:05.900 --> 00:43:09.730
that the user has to set,
that's one move away from the

00:43:09.740 --> 00:43:13.020
ideal Macintosh user experience,
which is no settings at all.

00:43:13.020 --> 00:43:14.930
You just use the system.

00:43:15.320 --> 00:43:16.740
More importantly, it adds state.

00:43:16.850 --> 00:43:19.590
This is state that may get corrupt.

00:43:19.790 --> 00:43:22.520
It's state that may get left behind
when they remove the package,

00:43:22.520 --> 00:43:24.300
and now you've got some
corrupt left on the disk.

00:43:24.390 --> 00:43:25.720
It's just state.

00:43:25.810 --> 00:43:28.230
And if you can avoid it,
you're much better off.

00:43:28.270 --> 00:43:32.120
I fully recognize there are cases
where you cannot avoid having state.

00:43:32.320 --> 00:43:36.120
And so we have a few
mechanisms that you can use.

00:43:36.210 --> 00:43:38.040
We're working on improving them,
as always.

00:43:38.040 --> 00:43:39.680
We want to make your lives easier.

00:43:39.810 --> 00:43:41.880
But at the same time,
we don't want to make it so

00:43:41.880 --> 00:43:45.110
easy that drivers and kernel
extensions become very stateful,

00:43:45.210 --> 00:43:46.870
because that would not be
a good user experience,

00:43:46.940 --> 00:43:49.430
and nobody would benefit.

00:43:49.580 --> 00:43:52.710
First off, do not store preferences
inside of your KEXT bundle.

00:43:52.930 --> 00:43:55.580
Consider your KEXT bundle read-only.

00:43:55.860 --> 00:43:58.390
Consider it something that's in ROM.

00:43:58.860 --> 00:44:01.620
Now, that being said,
you do have your resources

00:44:01.620 --> 00:44:04.490
folder that the KEXT management
system largely ignores,

00:44:04.500 --> 00:44:07.360
so you could put something in there.

00:44:07.360 --> 00:44:08.960
But in the future,
we may choose to do things

00:44:08.960 --> 00:44:13.480
like do bundle signing,
signature verification.

00:44:13.480 --> 00:44:16.650
And so if you have some part
of your driver that's changing,

00:44:16.870 --> 00:44:19.590
your driver is going
to violate its -- or --

00:44:19.830 --> 00:44:26.480
The KEXT should be stored
in a library of preferences.

00:44:26.830 --> 00:44:34.020
The file should be named for
your CFBundle identifier,

00:44:34.020 --> 00:44:40.620
and the file should be an infop list,
an XML file.

00:44:41.630 --> 00:44:44.460
You can use, in fact,
CFPreferences you can use

00:44:44.480 --> 00:44:46.090
to manage those files.

00:44:46.110 --> 00:44:47.940
There's a whole set of
APIs for doing that.

00:44:48.180 --> 00:44:50.400
You have to do it from user space,
though.

00:44:50.520 --> 00:44:53.450
In kernel drivers and kernel
extensions cannot directly

00:44:53.450 --> 00:44:55.350
access files in the file system.

00:44:55.440 --> 00:44:56.970
We do this to avoid circularity.

00:44:57.100 --> 00:45:00.400
We don't want the kernel generating I/O.

00:45:00.540 --> 00:45:06.570
The kernel is a service that's there
for applications and environments

00:45:06.570 --> 00:45:10.500
and such to make requests of,
but the kernel itself shouldn't be

00:45:10.500 --> 00:45:13.200
making a lot of I/O requests in general.

00:45:13.350 --> 00:45:16.830
So what happens is your driver suite,
the set of things you

00:45:16.850 --> 00:45:20.240
ship with your driver,
should include either a standalone app

00:45:20.340 --> 00:45:25.300
or a preference pane or something that
the user can run to set the settings,

00:45:25.330 --> 00:45:27.200
and then it will modify that file.

00:45:27.200 --> 00:45:29.200
You're also going to need a utility.

00:45:29.200 --> 00:45:30.200
It can be the same as the one
that you're using for the kernel.

00:45:30.200 --> 00:45:33.670
It can be the same one, in fact,
to push the settings down to the driver.

00:45:33.750 --> 00:45:36.790
Now,
what I'd recommend is let your driver

00:45:36.790 --> 00:45:39.580
have a reasonable default behavior.

00:45:39.700 --> 00:45:41.770
Again,
you need to decide what to do in the

00:45:41.770 --> 00:45:45.670
case that the preferences haven't been
set or the preferences are corrupt.

00:45:45.730 --> 00:45:48.320
So if you're going to
have to have preferences,

00:45:48.320 --> 00:45:51.700
make sure that the absence of
the preference isn't fatal.

00:45:52.680 --> 00:45:57.400
The utility, when it gets run,
can look up your driver by class,

00:45:57.460 --> 00:46:00.680
can communicate with it,
and can set whatever those

00:46:00.680 --> 00:46:04.050
preferences need to be for
the remainder of the runtime.

00:46:04.210 --> 00:46:08.180
If you need to have some preference
set very early in the startup,

00:46:08.220 --> 00:46:10.770
you probably have to have a startup item.

00:46:10.840 --> 00:46:13.750
Now, I would request again
that you not do this,

00:46:13.840 --> 00:46:18.120
because that's something that's going to
be run every time the system gets booted,

00:46:18.180 --> 00:46:23.070
and whether or not the user
intends to use that device or not.

00:46:23.120 --> 00:46:26.740
So it's best if you can have the
preferences attached with an action.

00:46:26.850 --> 00:46:30.330
For example,
if you're making a PPP connection,

00:46:30.450 --> 00:46:32.430
you don't need to have your
modem configured prior to

00:46:32.430 --> 00:46:34.400
that connection being made.

00:46:34.450 --> 00:46:36.240
If something is going to
auto-answer the modem,

00:46:36.240 --> 00:46:37.990
say it's sitting around
waiting for faxes,

00:46:38.030 --> 00:46:41.800
at some point it's going to attach to the
modem and configure it for auto-answer.

00:46:41.830 --> 00:46:43.750
At that point,
it can set up any preferences

00:46:43.750 --> 00:46:45.410
that are necessary along the way.

00:46:45.460 --> 00:46:48.100
Now, this obviously only works if
you're owning the whole system.

00:46:48.100 --> 00:46:49.540
You can set up a stack
from top to bottom,

00:46:49.570 --> 00:46:50.190
including the app.

00:46:50.380 --> 00:46:54.100
But that's the kind of thinking I would
really encourage you to veer towards,

00:46:54.100 --> 00:47:00.370
is try to associate the preference with
the action and not with the driver.

00:47:02.090 --> 00:47:05.500
So there are a variety of mechanisms for
communicating with your kernel extension.

00:47:05.560 --> 00:47:09.300
I/O Kit has standard set
properties mechanisms.

00:47:09.300 --> 00:47:11.530
We have I/O user clients.

00:47:11.590 --> 00:47:14.450
And if you're in the BSD space,
you can use device nodes.

00:47:14.580 --> 00:47:16.440
You can use sockets.

00:47:16.440 --> 00:47:18.240
There's probably other
mechanisms as well.

00:47:18.240 --> 00:47:20.460
Mach has certainly got plenty.

00:47:20.500 --> 00:47:23.900
Most of I/O kit's communication
mechanisms are fundamentally

00:47:23.900 --> 00:47:25.470
based on Mach messaging.

00:47:25.510 --> 00:47:28.340
So you can look at the
I/O Kit source in Darwin and see

00:47:28.340 --> 00:47:30.410
how we're doing that if you want.

00:47:30.560 --> 00:47:32.840
So just a few random tips
that I want to throw out here.

00:47:32.840 --> 00:47:37.790
If you're trying to figure out how to
get your driver loaded or unloaded,

00:47:38.010 --> 00:47:40.540
add the I/O Kit debug property.

00:47:40.930 --> 00:47:44.200
The KEXT is a property type set in your
personality inside your property list.

00:47:44.200 --> 00:47:45.060
It's an integer value.

00:47:45.060 --> 00:47:47.790
Make sure that you set the
property type to integer.

00:47:47.790 --> 00:47:51.800
And you want to set 65535,
just all bits set.

00:47:51.860 --> 00:47:54.800
I'm not particularly familiar
with what individual bits do.

00:47:54.800 --> 00:47:56.180
I'm not sure that they are even used.

00:47:56.210 --> 00:47:59.100
But if you set all the bits,
you'll get all the debugging info.

00:47:59.240 --> 00:48:02.020
And in the system log,
the families will log some

00:48:02.020 --> 00:48:06.040
information about why they did
or didn't match on your driver.

00:48:06.140 --> 00:48:09.260
What's nice is since you're only
setting this property in your driver,

00:48:09.330 --> 00:48:12.510
you're not getting logging information
for every driver in the system,

00:48:12.510 --> 00:48:13.760
just your driver.

00:48:13.830 --> 00:48:15.300
Of course,
when you go to ship your driver,

00:48:15.380 --> 00:48:17.350
make sure and take that
property out or set it to zero.

00:48:20.170 --> 00:48:23.090
A couple other tools that are handy.

00:48:23.090 --> 00:48:26.340
IOReg, most of you probably use this.

00:48:26.390 --> 00:48:27.790
This is a very important tool.

00:48:27.790 --> 00:48:29.920
If you do IOReg-c in
the name of your class,

00:48:29.940 --> 00:48:32.610
it's going to do sort of the
skeleton outline of all the,

00:48:32.860 --> 00:48:36.860
everything in the registry,
but it'll expand just your classes.

00:48:36.860 --> 00:48:39.700
This is a good way to find out, one,
if your driver is

00:48:39.700 --> 00:48:41.560
instantiated and connected.

00:48:41.560 --> 00:48:44.620
And two, if your driver isn't unloading
and it's still in the registry,

00:48:44.620 --> 00:48:46.000
well, that's why.

00:48:46.000 --> 00:48:48.300
Because if you're in the registry,
then the registry has a

00:48:48.300 --> 00:48:50.980
reference against you,
has a retain against you.

00:48:50.980 --> 00:48:53.060
And we don't unload you if
you have any references.

00:48:53.060 --> 00:48:55.840
So obviously your driver
won't unload until it's out

00:48:55.910 --> 00:48:57.130
of the registry at a minimum.

00:48:59.140 --> 00:49:03.000
Another thing that can be handy
is the IO Class Count utility.

00:49:03.000 --> 00:49:04.970
You can give it any number of classes.

00:49:05.120 --> 00:49:07.510
What I recommend you do,
and this is something I've done

00:49:07.700 --> 00:49:10.760
with drivers I've worked on,
get a list of all the

00:49:10.760 --> 00:49:12.430
classes that you use.

00:49:12.600 --> 00:49:32.600
[Transcript missing]

00:49:33.640 --> 00:49:37.400
Run this command, plug the device in,
run the command again,

00:49:37.520 --> 00:49:38.920
unplug your device, run it again.

00:49:38.990 --> 00:49:41.110
Do this about ten times.

00:49:41.770 --> 00:49:45.160
and make sure that the class
counts stay more or less the same.

00:49:45.200 --> 00:49:49.120
Now, you'll want to do the first plug and
unplug to let I/O Kit kind of settle.

00:49:49.180 --> 00:49:52.260
It's going to load your kernel
extension on the first plug and

00:49:52.430 --> 00:49:56.150
that's going to cause some references
to be taken and you can ignore those.

00:49:56.240 --> 00:50:00.580
But once everything is
kind of steady state,

00:50:00.690 --> 00:50:04.990
plugging and unplugging the device,
you would expect to see all of those

00:50:04.990 --> 00:50:04.990
classes--class counts remain flat.

00:50:05.430 --> 00:50:09.060
If they're not, you're probably leaking.

00:50:09.090 --> 00:50:11.680
I encountered this in a driver I wrote.

00:50:11.680 --> 00:50:12.700
Everything worked perfectly.

00:50:12.700 --> 00:50:15.420
Didn't have any problems at all,
but I did this little trick

00:50:15.420 --> 00:50:18.290
on it when I was about ready
to ship it and I noticed I was

00:50:18.290 --> 00:50:20.220
leaking I/O string references.

00:50:20.220 --> 00:50:21.240
And was able to fix that.

00:50:21.240 --> 00:50:24.670
And, you know, again,
it's not a problem the user would see,

00:50:24.850 --> 00:50:28.460
but it can cause memory leaks,
which is certainly a bad thing.

00:50:28.460 --> 00:50:30.030
It's a very -- this is
a tool to catch those.

00:50:30.180 --> 00:50:31.960
Also, it'll help you figure out
why you're not unloading.

00:50:32.030 --> 00:50:34.670
Oh, look,
my class has still got two references.

00:50:34.670 --> 00:50:38.440
It's not in the registry,
but it still has references.

00:50:38.440 --> 00:50:40.710
That would explain why your
driver isn't unloading.

00:50:42.700 --> 00:50:44.940
So debugging panics and hangs.

00:50:44.940 --> 00:50:48.220
First off,
you need to run this NVRAM command.

00:50:48.350 --> 00:50:50.530
Set your boot args to at least four.

00:50:50.710 --> 00:50:53.380
There's a, you know, a few different

00:50:53.960 --> 00:50:57.260
This bit basically says that you're
going to allow the machine to be remotely

00:50:57.260 --> 00:51:01.700
debugged and that you can break in,
particularly if there's a hang.

00:51:01.700 --> 00:51:06.980
Command power on -- I think it's
command power on most machines will

00:51:06.980 --> 00:51:09.810
break into debugger connection.

00:51:10.030 --> 00:51:12.900
The machine will attempt
to connect to a debugger,

00:51:12.900 --> 00:51:14.690
whatever it's running.

00:51:15.030 --> 00:51:17.220
So even if it's hung,
and this is one of the

00:51:17.220 --> 00:51:19.580
hardest things to debug,
everything works fine,

00:51:19.580 --> 00:51:21.390
all of a sudden the system freezes hard.

00:51:21.430 --> 00:51:24.040
You don't know what it is,
whether it's even in your code.

00:51:24.150 --> 00:51:26.460
If you have this set and
you break into the debugger,

00:51:26.460 --> 00:51:30.260
you can use a second machine to connect
to it and look at all the stacks of

00:51:30.370 --> 00:51:34.320
every process running on the machine,
get a tremendous amount of information.

00:51:34.320 --> 00:51:37.970
Another little tip there is don't put
your driver in system library extensions.

00:51:38.090 --> 00:51:41.810
Don't have it be part of the normal
boot-up set because it's kind of hard

00:51:41.810 --> 00:51:45.280
to filter what your driver is doing from
the background noise of all the other

00:51:45.450 --> 00:51:47.120
drivers in the system being loaded.

00:51:47.220 --> 00:51:52.470
So have it in a separate directory and
load it manually when you need to use it.

00:51:52.470 --> 00:51:55.320
That allows you to set
up all of your test jigs.

00:51:57.450 --> 00:52:00.140
Make use of the two-machine
debugging capability we have.

00:52:00.340 --> 00:52:03.650
I know a lot of people have been
sort of hesitant to use it because

00:52:03.730 --> 00:52:06.060
it does take some getting used to.

00:52:06.060 --> 00:52:07.890
It's a little bit
different way of debugging,

00:52:08.010 --> 00:52:09.450
but it's incredibly powerful.

00:52:09.630 --> 00:52:13.480
And in fact, it's the only way to get
at some kinds of bugs.

00:52:13.570 --> 00:52:18.110
So the new KEXT suites that Nik is going
to be talking about in a few minutes

00:52:18.290 --> 00:52:23.080
make it much easier to get the symbols
out of your loaded kernel extensions.

00:52:23.150 --> 00:52:26.170
And again, GDB lets you do a
tremendous amount of things.

00:52:26.490 --> 00:52:29.200
I will log in printf inside the

00:52:29.490 --> 00:52:32.010
We're aware that it's not synchronous,
and we're aware that it

00:52:32.010 --> 00:52:32.820
has limited bandwidth.

00:52:33.000 --> 00:52:34.220
That's by design.

00:52:34.260 --> 00:52:39.120
I/O log is there to log sporadic
events to the console that the user

00:52:39.120 --> 00:52:42.020
might want to know about or the system
administrator might want to know about.

00:52:42.110 --> 00:52:44.910
It's not really intended to
be a debugging mechanism.

00:52:44.910 --> 00:52:46.560
It's often used that way.

00:52:46.560 --> 00:52:50.480
But it has a limited buffer size,
and it has a limited throughput.

00:52:50.480 --> 00:52:54.110
This is done on purpose because we
don't want this service running on

00:52:54.110 --> 00:52:55.880
the system to be a resource hog.

00:52:55.900 --> 00:52:57.640
It's supposed to be invisible.

00:52:57.680 --> 00:53:02.720
Now, if you are using this, a little tip:
Login -- when you get the login panel,

00:53:02.950 --> 00:53:05.010
login is greater than console.

00:53:05.120 --> 00:53:09.220
This will kill the Windows server
and put up a raw text screen

00:53:09.280 --> 00:53:10.630
that is the Darwin console.

00:53:12.020 --> 00:53:14.390
From there,
I believe IO logs are synchronous,

00:53:14.430 --> 00:53:15.550
or very close to it.

00:53:15.630 --> 00:53:19.020
So you get much,
much closer logging to the actual hang

00:53:19.020 --> 00:53:21.030
or panic that you're trying to debug.

00:53:23.870 --> 00:53:26.780
And when you're doing that,
if you need to, remotely logging in from

00:53:26.850 --> 00:53:30.710
another machine to trigger the
panic condition is convenient.

00:53:32.020 --> 00:53:35.260
Okay,
so to prepare Kernel Extension to deploy,

00:53:35.380 --> 00:53:37.220
first off,
make sure the code is ready for release.

00:53:37.230 --> 00:53:39.870
This is stuff you already know,
but I'll just put it out there.

00:53:40.150 --> 00:53:42.220
Make sure you don't have any
asserts or debugger calls or

00:53:42.220 --> 00:53:45.160
anything like that that's going
to cause the machine to trap.

00:53:45.270 --> 00:53:47.060
Get rid of diagnostic messages.

00:53:47.060 --> 00:53:49.440
We see -- we've even shipped them.

00:53:49.460 --> 00:53:54.740
I'm disappointed to say drivers still
have diagnostic messages in them.

00:53:55.110 --> 00:53:58.060
Remove the I/O Kit debug property
or set the value to zero.

00:53:58.180 --> 00:53:59.300
You can do either one.

00:53:59.390 --> 00:54:01.760
That will turn off the extra logging.

00:54:01.840 --> 00:54:05.230
And don't forget to set
appropriate version numbers.

00:54:06.380 --> 00:54:09.580
So that's getting your
source ready to ship.

00:54:09.580 --> 00:54:13.510
You need to build in Project Builder
using the deployment build style.

00:54:13.550 --> 00:54:16.480
Now, if you go to, I believe,
the Targets pane,

00:54:16.590 --> 00:54:20.780
one of the parts of that window pane
will show you different build styles.

00:54:20.880 --> 00:54:21.980
There's, by default, only two.

00:54:21.980 --> 00:54:23.540
There's Development and Deployment.

00:54:23.540 --> 00:54:27.650
And with those two build styles,
Development includes a lot more symbols.

00:54:27.660 --> 00:54:31.960
You don't really want those to go out
because it makes your binary very big,

00:54:31.960 --> 00:54:34.400
and it's unnecessary information.

00:54:34.460 --> 00:54:37.250
If you don't build this way or
it's not convenient for you,

00:54:37.460 --> 00:54:41.300
at least run strip-s on your
binary inside your KEXT first.

00:54:41.330 --> 00:54:46.290
This will basically do the same thing
as what Building for Deployment will do.

00:54:47.520 --> 00:54:48.990
Now when you package
your kernel extension,

00:54:49.140 --> 00:54:52.220
use a tool like PackageMaker
that Apple provides,

00:54:52.220 --> 00:54:55.400
and there's actually a document that
walks you through all the process.

00:54:55.400 --> 00:54:59.400
You really don't need to multiply
package your kernel extension.

00:54:59.400 --> 00:55:06.400
I've seen some that are a disk image
of a stuffit file of a tar archive.

00:55:06.590 --> 00:55:08.510
Not a good user experience
and it really doesn't help.

00:55:08.600 --> 00:55:10.580
You only need one level of
packaging to protect the

00:55:10.580 --> 00:55:12.740
innards of the kernel extension.

00:55:12.790 --> 00:55:16.580
And again, if you have a sophisticated
enough installer that can

00:55:16.580 --> 00:55:20.540
have an installation script,
actually expand your kernel extension

00:55:20.540 --> 00:55:23.980
into temp or somewhere else,
and then have the script copy

00:55:24.020 --> 00:55:25.950
it into the final destination.

00:55:27.670 --> 00:55:31.270
Always test your driver after
you've run the official installer.

00:55:31.350 --> 00:55:35.290
We've seen cases where somebody has
done all their QA on a driver that

00:55:35.370 --> 00:55:38.960
they've built using Project Builder,
and then they put it in

00:55:38.960 --> 00:55:40.390
the package and ship it.

00:55:40.960 --> 00:55:45.950
The packaging process can
actually mess your driver up.

00:55:46.100 --> 00:55:49.500
In particular, file ownership and
permission is very important.

00:55:49.660 --> 00:55:54.740
This is something we didn't enforce
properly in previous releases,

00:55:54.740 --> 00:55:57.660
and in Jaguar we now do
enforce them properly,

00:55:57.660 --> 00:55:59.360
or going to be.

00:55:59.360 --> 00:56:01.970
Actually,
the developer C that you have now has

00:56:02.000 --> 00:56:04.400
sort of a compromise for compatibility.

00:56:04.510 --> 00:56:06.870
All the files and
directories in your driver,

00:56:06.900 --> 00:56:12.000
in your KEXT, have to be owned by root,
and the group should be set to wheel.

00:56:13.070 --> 00:56:16.660
The permissions need to be 7.5.5
for directories and 6.4.4 for files.

00:56:16.810 --> 00:56:18.050
This is very important.

00:56:18.130 --> 00:56:21.000
The key thing we're getting
to here is the KEXT,

00:56:21.010 --> 00:56:24.040
every piece of the KEXT has to
be owned by root and may not be

00:56:24.170 --> 00:56:27.900
writable by any user other than root.

00:56:27.920 --> 00:56:30.770
So there are other variations of
file permissions that can work,

00:56:30.840 --> 00:56:33.490
but if you meet those two criteria,
you should be okay.

00:56:33.500 --> 00:56:37.400
Owned by root,
may not be writable by non-root users.

00:56:37.410 --> 00:56:39.460
We recommend using
these exact permissions,

00:56:39.460 --> 00:56:43.180
that's what we ship with and it's
what our tools produce by default.

00:56:43.180 --> 00:56:43.490
Check that.

00:56:43.540 --> 00:56:45.820
After you package your
KEXT and run the installer,

00:56:45.820 --> 00:56:48.440
check that it's installing
with correct permissions.

00:56:49.880 --> 00:56:52.190
Okay, I'm going to turn the stage
over to Nik Gervae now.

00:56:52.350 --> 00:56:55.540
He's the engineer responsible
for the KEXT tool suite.

00:56:55.540 --> 00:56:57.990
And thank you for your attention.

00:57:01.220 --> 00:57:04.840
If you tried using any
of the Qex tools by now,

00:57:04.840 --> 00:57:08.240
you've probably noticed a few changes.

00:57:08.260 --> 00:57:09.750
Let me get right into that.

00:57:09.830 --> 00:57:12.680
We've basically got a whole
new code base and tool set.

00:57:12.700 --> 00:57:14.870
It's much more extensible and
maintainable than the old stuff was.

00:57:14.870 --> 00:57:16.570
We'll be able to add
features more easily.

00:57:16.700 --> 00:57:19.070
And it's built on a
comprehensive library.

00:57:19.070 --> 00:57:22.000
In prior releases,
some of the Qex tools were built

00:57:22.030 --> 00:57:25.320
using basically different libraries
or not even using a library.

00:57:25.400 --> 00:57:28.010
So they didn't share the same logic.

00:57:28.010 --> 00:57:29.190
Now we do that.

00:57:29.210 --> 00:57:31.750
Although this library is not
available for third-party use yet,

00:57:31.750 --> 00:57:32.770
we have to clean up the API.

00:57:32.940 --> 00:57:36.080
You can check it out and see
how it works in Darwin under the

00:57:36.080 --> 00:57:38.950
I/O Kit user and Qex tools projects.

00:57:39.450 --> 00:57:43.920
The tools themselves now are Kextload,
which takes over all of the features

00:57:44.070 --> 00:57:48.300
that Kmodload and KmodSIMS used to have,
adds a lot of features for debugging,

00:57:48.300 --> 00:57:51.820
and nearly used up the
alphabet adding options.

00:57:51.930 --> 00:57:53.570
It's installed with the base system.

00:57:53.680 --> 00:57:55.450
As Dean mentioned,
this is what you use from

00:57:55.450 --> 00:57:58.580
applications to load a KEXT,
and it's usage compatible

00:57:58.720 --> 00:58:00.140
with prior versions.

00:58:00.250 --> 00:58:02.330
Kextunload similarly
obsoletes Kmodunload.

00:58:02.360 --> 00:58:05.650
It is installed with the base system,
and it's usage compatible

00:58:05.660 --> 00:58:07.070
with prior versions.

00:58:07.570 --> 00:58:10.680
Two new ones:
Kextstat obsoleting Kmodstat.

00:58:10.940 --> 00:58:13.200
You don't have to be
root to run this anymore.

00:58:13.250 --> 00:58:15.300
And it's installed with
the developer tools,

00:58:15.300 --> 00:58:17.130
not in the base system.

00:58:17.220 --> 00:58:18.740
There's a lot of conveniences added.

00:58:18.740 --> 00:58:20.200
This is mostly for developers.

00:58:20.330 --> 00:58:26.500
Kextcache obsoleting mkextcache is
likewise installed with the base system.

00:58:26.950 --> 00:58:30.040
And then there's Kexty,
which is not a tool per se.

00:58:30.040 --> 00:58:32.770
This is what tracks
I/O Kit load requests.

00:58:32.960 --> 00:58:34.540
It is installed with the base system.

00:58:34.540 --> 00:58:38.160
You should consider it an implementation
detail and not rely on it in your apps.

00:58:38.270 --> 00:58:42.160
Don't rely on the presence of
the executable or the process.

00:58:42.260 --> 00:58:45.960
There are options that you
can use to help in debugging,

00:58:45.960 --> 00:58:48.230
and the man page covers those.

00:58:48.440 --> 00:58:50.920
Now, using Kextload,
some of the new options that are

00:58:50.920 --> 00:58:53.060
added is additional verbose logging.

00:58:53.060 --> 00:58:55.210
You have up to six levels
of verbose logging,

00:58:55.210 --> 00:58:56.750
which can get pretty chatty.

00:58:56.990 --> 00:58:59.460
However, the seed you have has one bug.

00:58:59.520 --> 00:59:03.540
Don't use level 6 when you're
loading a KEXT right now.

00:59:03.540 --> 00:59:05.530
To generate symbols,
you use -s and give it the name of

00:59:05.530 --> 00:59:06.840
a directory to put the symbols in.

00:59:06.840 --> 00:59:09.460
It will automatically figure out
your dependencies and generate

00:59:09.720 --> 00:59:12.670
dependencies for them all and
dump them into that directory.

00:59:12.690 --> 00:59:17.730
You don't have to type kmodsims --d
this --d that --d this --d that.

00:59:19.440 --> 00:59:23.150
If you don't want to load it
when generating your symbols,

00:59:23.150 --> 00:59:26.910
you use -n, which means don't load,
and you have a whole bunch

00:59:26.920 --> 00:59:28.000
of ways of doing that.

00:59:28.000 --> 00:59:30.390
The man page covers
some of the usage cases.

00:59:30.500 --> 00:59:33.630
If you just say -n and -s,
it will ask you interactively

00:59:33.630 --> 00:59:35.540
for each of the load addresses.

00:59:35.650 --> 00:59:38.800
Or you can specify each
dependency's load address with -a.

00:59:38.940 --> 00:59:41.670
Or you can use -A,
which means this is the machine

00:59:41.670 --> 00:59:43.790
that I'm getting debug symbols for.

00:59:44.080 --> 00:59:47.170
Find out what they are in
the kernel and just do it.

00:59:49.210 --> 00:59:51.780
There's also -k which remains
for specifying the kernel that

00:59:51.780 --> 00:59:55.780
you want to use if you're using
a different kernel binary.

00:59:55.900 --> 00:59:59.640
More stuff using Kextload is that if
you're debugging a driver start function,

00:59:59.680 --> 01:00:04.480
you can use -l which means load it
only but do not start I/O Kit matching.

01:00:04.630 --> 01:00:08.500
Similarly, you can use -m which means the
driver is already loaded but probably

01:00:08.640 --> 01:00:10.280
not matched against anything.

01:00:10.390 --> 01:00:12.770
So trigger the matching
routine which will cause any

01:00:12.770 --> 01:00:14.420
start routines to get invoked.

01:00:14.590 --> 01:00:17.650
For other KEXTs that don't use
the I/O Kit start routines,

01:00:17.750 --> 01:00:21.900
you have to use -i which basically
pauses at each stage of loading,

01:00:21.980 --> 01:00:26.500
including right when the KEXT has been
loaded into the kernel's VM space,

01:00:26.500 --> 01:00:29.350
but before its module
start has been called.

01:00:29.390 --> 01:00:33.640
And there's a variant on that -I which
will also pause for every dependency.

01:00:33.640 --> 01:00:37.800
So if you're debugging a library,
you can use it there as well.

01:00:37.910 --> 01:00:41.430
Because Kextload figures all of
the dependencies out for you,

01:00:41.530 --> 01:00:44.420
it might be a little inconvenient if
you've got a problem with the kernel.

01:00:44.420 --> 01:00:46.410
So you can use -d to check a particular
thing that you want to check,

01:00:46.410 --> 01:00:48.800
a particular dependency
resolution scenario.

01:00:48.820 --> 01:00:52.400
To get over that, you can use -d, -r,
and -e.

01:00:52.420 --> 01:00:57.440
-d specifies an explicit dependency that
isn't in the library extensions folder.

01:00:57.440 --> 01:01:01.320
-r adds a whole new folder,
so if you have a bunch of libraries

01:01:01.320 --> 01:01:05.080
that you've built and you don't want to
put them in system library extensions,

01:01:05.080 --> 01:01:08.980
you can say -r and specify a
directory and that's where they'll be.

01:01:09.000 --> 01:01:12.290
-e means skip the system library
extensions folder altogether if

01:01:12.290 --> 01:01:13.840
you really want to be paranoid
about what you're getting.

01:01:13.840 --> 01:01:17.920
Another convenience,
during development you can use the -z

01:01:17.920 --> 01:01:20.820
option and it will skip authentication.

01:01:20.820 --> 01:01:23.520
You still have to be root to
load a KEXT into the kernel.

01:01:23.520 --> 01:01:26.880
But -z will bypass any checks on
the file ownership and permissions

01:01:26.880 --> 01:01:28.820
while you're doing the build cycle.

01:01:28.820 --> 01:01:31.820
Because you don't want to have
to chown and chmaw your KEXT.

01:01:31.830 --> 01:01:34.120
Now the seed you have,
that is in the base and the developer

01:01:34.120 --> 01:01:35.820
tools versions for when Jaguar ships.

01:01:35.820 --> 01:01:38.780
That option will not be
present in the user version

01:01:38.790 --> 01:01:40.790
because it's a security hole.

01:01:40.870 --> 01:01:44.980
Also, KEXT load performs the new strict
authentication in the seed if you use any

01:01:44.980 --> 01:01:46.800
of the new options as well as with -i.

01:01:46.800 --> 01:01:51.900
To maintain compatibility with
older KEXTs and their installers,

01:01:51.900 --> 01:01:54.460
if it's just invoked with
no options and with a KEXT,

01:01:54.530 --> 01:01:56.790
it will not perform the
strict authentication.

01:01:56.800 --> 01:01:59.330
When Jaguar ships will be
improving that somewhat and

01:01:59.390 --> 01:02:03.040
if we run into an older KEXT,
we'll probably prompt the user

01:02:03.040 --> 01:02:05.030
and ask them if it's okay.

01:02:05.670 --> 01:02:09.600
Another option for verifying your KEXT,
a lot of problems you've probably seen

01:02:09.600 --> 01:02:13.360
with debugging your KEXT is because
it just won't load in the first place.

01:02:13.400 --> 01:02:15.880
You can use the "-t" option with
Kextload now and it will perform a

01:02:15.880 --> 01:02:19.810
comprehensive set of checks on your KEXT,
making sure the plist is okay,

01:02:19.810 --> 01:02:21.860
making sure the authentication
checks are there,

01:02:21.860 --> 01:02:24.000
and making sure the
dependencies can be resolved.

01:02:24.080 --> 01:02:30.100
And it will print out a nice little
format showing exactly what's wrong.

01:02:30.180 --> 01:02:35.090
You can always run kextload
"-nt" on your KEXT.

01:02:35.090 --> 01:02:37.940
You can do that as a test
during development and before

01:02:37.940 --> 01:02:38.940
you ship your software.

01:02:38.950 --> 01:02:43.790
I highly recommend that part of your
QA process have your people install

01:02:43.790 --> 01:02:48.470
the KEXT and then run kextload "-nt" on
it and see if there's any diagnostics.

01:02:49.360 --> 01:02:53.190
The Kextcache tool,
which replaces mkextcache,

01:02:53.230 --> 01:02:55.740
has some changes in behavior.

01:02:55.850 --> 01:02:59.210
There's different ways of
specifying local and network boot.

01:02:59.370 --> 01:03:02.820
I don't know that many of you use that,
but as you can see up here,

01:03:02.970 --> 01:03:05.080
the behavior is a little bit different.

01:03:05.080 --> 01:03:08.920
-l and -n honor things you
name on the command line.

01:03:08.920 --> 01:03:12.240
If you specified a KEXT explicitly,
you probably want it in there.

01:03:12.240 --> 01:03:16.080
But I've added -L and -N,
which screens them all.

01:03:16.210 --> 01:03:17.600
This one also has one small bug.

01:03:17.600 --> 01:03:20.790
If you name a KEXT on the command line,
it will not scan for plugins.

01:03:20.920 --> 01:03:23.760
I've already fixed that, of course,
but too late for you guys to get it.

01:03:23.790 --> 01:03:26.310
A quick workaround for that is
to put that KEXT into a directory

01:03:26.660 --> 01:03:28.650
and then specify the directory.

01:03:29.140 --> 01:03:31.100
To examine loaded KEXTs,
you use KextStat.

01:03:31.100 --> 01:03:32.970
Again,
it does not require running as root.

01:03:33.090 --> 01:03:35.250
Some conveniences are that you
can skip all the ones built

01:03:35.250 --> 01:03:38.950
into the kernel by using -k,
so the listing will be a little shorter.

01:03:39.050 --> 01:03:40.810
You can skip the
top-level header with -l,

01:03:40.810 --> 01:03:42.920
which is useful for
shell skip processing.

01:03:43.030 --> 01:03:45.540
And you can get information about
a specific KEXT using -b and

01:03:45.540 --> 01:03:47.970
giving the bundle identifier.

01:03:48.200 --> 01:03:52.540
To find a KEXT from an application,
we're adding some proper

01:03:52.540 --> 01:03:54.590
APIs to KEXT management.

01:03:54.600 --> 01:03:55.800
We call this function.

01:03:55.920 --> 01:03:58.530
KextManagerCreateURLForBundleIdentifier.

01:03:58.530 --> 01:04:02.060
That will go talk to Kexty,
and if Kexty knows about that extension,

01:04:02.210 --> 01:04:05.760
you'll get back the URL to that
extension so that you can get to the

01:04:05.760 --> 01:04:09.700
resources directory and load any icons
or other resources that you need.

01:04:10.210 --> 01:04:13.000
Finally, we're going to wrap up with
a little bit of history.

01:04:13.090 --> 01:04:15.210
Prior to now,
the focus has been on getting

01:04:15.210 --> 01:04:16.680
KEXT management working.

01:04:16.770 --> 01:04:19.580
So for 10.0,
it was boot time driver loading support.

01:04:19.670 --> 01:04:21.980
For 10.1, we wanted to improve
boot time performance,

01:04:22.130 --> 01:04:24.450
so we added the mKext cache.

01:04:24.550 --> 01:04:26.680
And now with Jaguar,
we're finally updating the toolset

01:04:26.680 --> 01:04:28.080
and building a base for new features.

01:04:28.380 --> 01:04:32.240
There's also some more improvements
to performance in the footprint.

01:04:32.460 --> 01:04:36.250
Future directions will be paired
between kernel and user space code.

01:04:36.480 --> 01:04:39.640
Right now the logic is a little
bit different and we're hoping

01:04:39.640 --> 01:04:41.070
to make that be the same.

01:04:41.330 --> 01:04:44.630
Again, kernel APIs are evolving,
so the kernel KMOD API,

01:04:44.880 --> 01:04:48.300
which I doubt any of you are using,
don't use it anyway.

01:04:48.390 --> 01:04:51.210
Um, finally we're going to
make the KEXT management

01:04:51.230 --> 01:04:55.540
library available to apps,
probably add KEXT bundle signing,

01:04:55.540 --> 01:04:58.580
and get more input from
you on what you want.

01:04:58.580 --> 01:05:00.900
And that leads us to the roadmap.

01:05:00.900 --> 01:05:02.180
So is Keith there?

01:05:04.090 --> 01:05:05.660
Just keep reading this?

01:05:06.040 --> 01:05:06.300
Okay.

01:05:06.440 --> 01:05:09.990
The next one is the Darwin roadmap,
which already happened.

01:05:10.060 --> 01:05:11.620
Hope you were there.

01:05:11.870 --> 01:05:13.440
Another one that already
happened is yesterday,

01:05:13.440 --> 01:05:17.140
Open Source, Apple and You, Session 103.

01:05:17.140 --> 01:05:23.510
We just had the Darwin kernel
a little while ago,

01:05:23.510 --> 01:05:23.510
and after lunch today will be
Feedback Forum 2 on Darwin.

01:05:24.050 --> 01:05:24.880
Who to contact?

01:05:24.900 --> 01:05:26.900
That would be Craig Keithley,
who is right there.

01:05:26.900 --> 01:05:28.890
He's our USB and FireWire
technology evangelist,

01:05:28.970 --> 01:05:31.690
and there's his email
address right there.

01:05:32.310 --> 01:05:35.060
and for more information,
Apple's developer website and the

01:05:35.070 --> 01:05:36.940
Darwin project website and mail groups.

01:05:39.860 --> 01:05:41.090
Documentation includes man pages.

01:05:41.100 --> 01:05:43.800
I rewrote all the man
pages for these KEXT tools,

01:05:43.800 --> 01:05:45.840
so have a look at them.

01:05:47.330 --> 01:05:51.470
Kextload in particular has a very long
man page with lots of usage scenarios,

01:05:51.470 --> 01:05:54.040
so if you're trying to figure out
how to do one particular thing,

01:05:54.220 --> 01:05:55.050
read that.

01:05:55.120 --> 01:05:57.150
There's a release note
and there's revised

01:05:57.150 --> 01:05:59.180
I/O Kit documentation on the website.

01:05:59.240 --> 01:06:01.200
And now it's time for our Q&A.
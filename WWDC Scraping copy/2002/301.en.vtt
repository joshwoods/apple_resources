WEBVTT

00:00:14.750 --> 00:00:15.700
Good morning.

00:00:15.700 --> 00:00:17.780
Welcome to Cocoa: What's New.

00:00:18.010 --> 00:00:20.500
Today we're going to tell you
what we did to Cocoa since the

00:00:20.500 --> 00:00:25.000
last time we were together,
about a year ago.

00:00:27.680 --> 00:00:29.010
The talk is divided into two parts.

00:00:29.100 --> 00:00:31.440
First, we're going to talk about
changes in the Foundation kit,

00:00:31.440 --> 00:00:33.470
followed by changes in
the Application kit.

00:00:33.670 --> 00:00:36.300
Note that in Foundation,
we did not have too many

00:00:36.360 --> 00:00:39.840
public API changes in 10.1,
so most of the changes here

00:00:39.840 --> 00:00:41.600
are actually new to Jaguar.

00:00:41.600 --> 00:00:43.980
To highlight here,
NSNet services are the new

00:00:43.980 --> 00:00:47.290
APIs to support Rendezvous,
and we have a new keyed archiving

00:00:47.290 --> 00:00:49.540
mechanism that I want to tell you about.

00:00:49.600 --> 00:00:51.630
Then we're going to talk
about the AppKit changes,

00:00:51.630 --> 00:00:54.600
first quickly covering the
changes we introduced in 10.1,

00:00:54.600 --> 00:00:57.600
followed by the changes
we've introduced in Jaguar.

00:00:57.640 --> 00:00:59.400
Now note that there's
a lot of topics here,

00:00:59.400 --> 00:01:01.600
and we're going to be
jumping from topic to topic,

00:01:01.600 --> 00:01:03.580
so hopefully it's not
too disorienting for you.

00:01:03.620 --> 00:01:06.890
So at this point,
I'd like to invite Chris Parker on

00:01:06.890 --> 00:01:10.460
stage to talk about some
of the Foundation changes.

00:01:15.500 --> 00:01:16.460
My name is Chris Parker.

00:01:16.540 --> 00:01:17.500
I'm a foundation engineer.

00:01:17.500 --> 00:01:21.720
I've been working a little
bit on some of these things.

00:01:21.740 --> 00:01:23.290
First off, managed preferences.

00:01:23.330 --> 00:01:26.660
We've made some changes to
NS File Manager since 10.1 and

00:01:26.660 --> 00:01:28.350
brought some new stuff in for Jaguar.

00:01:28.460 --> 00:01:32.050
There have been some updates
to NSURL Handle and the new

00:01:32.050 --> 00:01:34.460
Rendezvous APIs in Foundation.

00:01:34.590 --> 00:01:36.790
So starting off, it's over here.

00:01:37.010 --> 00:01:37.960
Managed preferences.

00:01:37.970 --> 00:01:41.390
Your applications may be operating
in an environment where the

00:01:41.390 --> 00:01:43.890
user doesn't have the ability
to change certain preferences.

00:01:43.910 --> 00:01:47.390
A lab administrator in a school or
a parent in a single machine may set

00:01:47.390 --> 00:01:50.330
some preferences for a user to use,
and they shouldn't be

00:01:50.330 --> 00:01:51.730
able to change those.

00:01:51.840 --> 00:01:54.610
So what we do is we put a
forced preferences domain at the

00:01:54.610 --> 00:01:57.430
beginning of the search path,
and keys that appear in

00:01:57.430 --> 00:01:59.010
that domain always win out.

00:01:59.010 --> 00:02:01.810
So users shouldn't be
able to set these things.

00:02:01.870 --> 00:02:04.640
Applications should disable their
controls where the user can't

00:02:04.690 --> 00:02:07.480
change a preference key to give
them a better user experience.

00:02:07.480 --> 00:02:11.000
You don't want them hammering on that
button if they can't change the value.

00:02:11.000 --> 00:02:12.300
So what we've done is forced preferences.

00:02:12.300 --> 00:02:12.300
Managed preferences.

00:02:12.300 --> 00:02:12.300
Your applications may be operating
in an environment where the

00:02:12.300 --> 00:02:12.300
user doesn't have the ability
to change certain preferences.

00:02:12.300 --> 00:02:12.300
They should be able to change those.

00:02:12.300 --> 00:02:12.300
So what we've done is forced preferences.

00:02:12.300 --> 00:02:12.300
Your applications may be operating
in an environment where the

00:02:12.300 --> 00:02:12.300
user doesn't have the ability
to change certain preferences.

00:02:12.300 --> 00:02:12.300
You don't want them hammering on that
button if they can't change the value.

00:02:12.360 --> 00:02:15.300
What we've done is forced
values will always be returned

00:02:15.300 --> 00:02:16.590
when you use object for key.

00:02:16.880 --> 00:02:20.900
So if the administrator has placed a
value in that forced preferences domain,

00:02:20.900 --> 00:02:24.100
you'll always get it when you
ask for it with object for key.

00:02:24.200 --> 00:02:27.410
We've also provided a couple of routines
for you to be able to pick out whether

00:02:27.440 --> 00:02:29.020
or not those objects are forced.

00:02:29.070 --> 00:02:32.810
That's object is forced for key and
object is forced for key and domain.

00:02:32.960 --> 00:02:37.800
And these will return true if there's
been a value forced for that key.

00:02:39.970 --> 00:02:42.180
Some changes for NS File Manager.

00:02:42.380 --> 00:02:48.040
As of 10/1,
we started doing some resource

00:02:48.040 --> 00:02:50.990
fork and catalog info preservation
when you do moves and copies.

00:02:50.990 --> 00:02:53.360
We're trying to expand
on that a little bit.

00:02:53.570 --> 00:02:56.460
We're also putting in support for
the BSD file flags for the file

00:02:56.460 --> 00:02:58.990
immutable and file append only bits.

00:02:58.990 --> 00:03:03.330
We've got some information
there for file creation date,

00:03:03.620 --> 00:03:07.850
the HFS creator and type codes,
as well as the account information

00:03:07.850 --> 00:03:10.340
for the owner and owner group IDs.

00:03:10.340 --> 00:03:13.910
We're also supplying an API to do
some intermediate directory creation.

00:03:14.070 --> 00:03:17.480
You'll be able to create a whole
series of directories at once rather

00:03:17.480 --> 00:03:19.730
than having to iterate through a path.

00:03:20.000 --> 00:03:22.460
There have been some
updates to NSURL handle.

00:03:22.460 --> 00:03:25.040
We've added some FTP support.

00:03:25.080 --> 00:03:28.760
A lot of bugs got shaken out over the
course of the last several months.

00:03:28.860 --> 00:03:31.270
We now have asynchronous hostname lookup,
so you're not going to block

00:03:31.370 --> 00:03:35.000
when you try and open up this
thing to look for a hostname.

00:03:35.090 --> 00:03:37.190
There's going to be some
tighter integration with system

00:03:37.190 --> 00:03:40.400
configuration planned out,
and although it's not here,

00:03:40.450 --> 00:03:43.950
by the time Jaguar ships,
I've been told this is going to

00:03:43.950 --> 00:03:46.230
also support FTP proxy support.

00:03:49.330 --> 00:03:52.670
This NSNet Services stuff is our
implementation in the foundation

00:03:52.670 --> 00:03:55.500
level of the Rendezvous API.

00:03:55.500 --> 00:03:57.950
This exposes some of the lower level
features that have been put into

00:03:57.950 --> 00:04:00.920
Core Foundation and into the OS.

00:04:00.920 --> 00:04:03.960
If you do a top on a Jaguar machine,
you'll probably see a little

00:04:03.960 --> 00:04:06.870
thing called MDNS responder,
and that's part of what's doing

00:04:06.870 --> 00:04:08.650
the work for Rendezvous there.

00:04:08.820 --> 00:04:11.490
This exposes all of that
stuff at the foundation level.

00:04:11.670 --> 00:04:14.980
This allows us to do dynamic
discovery of TCP/IP services.

00:04:14.980 --> 00:04:19.350
You don't need any prior knowledge of the
address of the thing you're looking for,

00:04:19.350 --> 00:04:20.550
the host name, anything like that.

00:04:20.550 --> 00:04:23.400
You're just going to be able to
find it right on the network.

00:04:23.400 --> 00:04:26.730
You advertise services,
and then once you want to

00:04:26.730 --> 00:04:28.450
look for those services,
you're going to discover them,

00:04:28.450 --> 00:04:30.020
and then discovered services,
once you find them,

00:04:30.020 --> 00:04:33.800
you resolve them to be able to
actually make the connection.

00:04:34.460 --> 00:04:37.540
So when you start publishing a service,
you're going to have to pick a domain.

00:04:37.540 --> 00:04:41.740
Right now that's local.arpa,
and that's basically your local subnet.

00:04:41.740 --> 00:04:44.530
Okay, services that you offer are
also going to have a name,

00:04:44.650 --> 00:04:47.040
a type, and a port.

00:04:47.040 --> 00:04:48.940
And you'll also create a delegate
object which is going to listen

00:04:48.940 --> 00:04:54.240
for events that the NSNet services
objects will tell you about.

00:04:54.280 --> 00:04:57.600
Okay, so when you first create this,
you're going to alloc one up

00:04:57.740 --> 00:05:01.720
and then init it with a domain,
a type, the name, and the port.

00:05:01.750 --> 00:05:06.620
The type string is a little bit of magic,
but that's based on the services

00:05:06.620 --> 00:05:08.570
that are in Etsy services.

00:05:09.220 --> 00:05:12.760
You'll set the delegate to some other
object and then just tell it to publish.

00:05:12.760 --> 00:05:15.660
And that'll start advertising itself
on the network with that information.

00:05:15.700 --> 00:05:18.890
What the user will wind up seeing
is something like Nifty Demo Server.

00:05:18.980 --> 00:05:21.300
And that's about the only
thing they need to worry about.

00:05:21.410 --> 00:05:24.080
The delegate implements methods
like NetServiceWillPublish

00:05:24.200 --> 00:05:26.730
that's going to say,
"Yes, I'm about to go out and make this

00:05:26.960 --> 00:05:30.660
service available on the network."
And NetServiceDidNotPublish will

00:05:30.660 --> 00:05:32.070
be where you catch an error.

00:05:32.370 --> 00:05:35.160
The network wasn't ready,
there's been a name collision,

00:05:35.160 --> 00:05:36.290
that kind of thing.

00:05:37.970 --> 00:05:39.470
When you want to go out
and look for these things,

00:05:39.470 --> 00:05:42.460
you need an NSNetServiceBrowser object.

00:05:42.760 --> 00:05:45.010
Since domains and services are dynamic,
each of these things can

00:05:45.050 --> 00:05:46.200
come and go off the network.

00:05:46.270 --> 00:05:48.670
So this is going to tell you about
all the different events that

00:05:48.670 --> 00:05:53.630
happen when this domain disappears
or when a service shuts down.

00:05:53.700 --> 00:05:57.660
And again, you're going to use a
delegate to get these events.

00:05:57.780 --> 00:06:01.450
So when you want to discover domains,
I need to find what domains

00:06:01.450 --> 00:06:03.160
are available to browse.

00:06:03.350 --> 00:06:06.500
You just do a standard alloc
init sequence and then again,

00:06:06.500 --> 00:06:08.540
set a delegate and then just
tell it to search for all the

00:06:08.540 --> 00:06:09.400
domains that are available.

00:06:09.400 --> 00:06:11.620
Tell me everything that's out there.

00:06:12.020 --> 00:06:14.950
You'll get "Did find domain"
messages on your delegate.

00:06:15.000 --> 00:06:15.840
That's NetService Browser.

00:06:15.840 --> 00:06:20.980
"Did find domain more coming." The "more
coming" part is to let you know that

00:06:21.180 --> 00:06:24.650
if there is something else coming up,
you're going to want to hold

00:06:24.650 --> 00:06:26.800
off on any expensive UI updates.

00:06:26.890 --> 00:06:29.120
"Did remove domain" says, "Oh,
it went away.

00:06:29.240 --> 00:06:31.610
I should remove it from my list."

00:06:32.860 --> 00:06:35.770
Once you've found domains,
you're going to want to find

00:06:35.770 --> 00:06:37.800
services within that domain.

00:06:37.900 --> 00:06:42.720
So you may want to use another object,
set it up, set the delegate,

00:06:42.720 --> 00:06:46.550
and then just tell it to search for
services of type in a given domain.

00:06:46.640 --> 00:06:49.340
Just like there's did find
domain and did remove domain,

00:06:49.340 --> 00:06:51.960
there's did find service
and did remove service.

00:06:52.050 --> 00:06:54.170
And these will tell you what happened.

00:06:57.590 --> 00:07:00.110
Once you get it, for instance,
in your did find service

00:07:00.170 --> 00:07:03.310
more coming method,
you'll want to hang on to it.

00:07:03.410 --> 00:07:07.720
You're going to get one of these
NSNet services when the event comes in.

00:07:07.810 --> 00:07:09.640
You're going to want to hang on to it,
and then you're going

00:07:09.640 --> 00:07:10.220
to want to resolve it.

00:07:10.260 --> 00:07:12.720
And this will allow you to get
all the information you need to be

00:07:12.720 --> 00:07:15.680
able to hand it off to something
that will allow you to make the

00:07:16.050 --> 00:07:18.090
connection to that other machine.

00:07:20.220 --> 00:07:22.760
This API is asynchronous,
so you do have to have a run loop

00:07:22.760 --> 00:07:24.900
running when you're going to use it.

00:07:25.000 --> 00:07:29.110
The NetService objects
that you create to resolve,

00:07:29.140 --> 00:07:30.130
okay, you can't use to publish.

00:07:30.140 --> 00:07:32.050
So anything you get from
a NetService browser,

00:07:32.090 --> 00:07:34.140
you can't publish it
immediately with that.

00:07:34.140 --> 00:07:35.680
Those are things that are
happening on other machines.

00:07:35.680 --> 00:07:37.170
The only things you can publish
are the things that you're going to

00:07:37.180 --> 00:07:39.670
make available on your own computer.

00:07:40.180 --> 00:07:43.000
And NSNet Service browser objects can
only go after one thing at a time.

00:07:43.000 --> 00:07:44.860
So you can't tell a
browser object to say,

00:07:44.950 --> 00:07:46.980
"Go search for domains," and then
immediately tell it to go search

00:07:47.030 --> 00:07:48.930
for services within that domain.

00:07:48.940 --> 00:07:54.690
You can either create another one or
you can tell the first one to stop

00:07:54.690 --> 00:07:54.690
and then start a new kind of search.

00:07:55.700 --> 00:07:58.430
There have been a bunch of
other foundation changes,

00:07:58.430 --> 00:08:01.200
but Chris Kane is going
to tell you about those.

00:08:08.800 --> 00:08:12.370
So I'm going to wrap up the
Foundation changes here before we

00:08:12.380 --> 00:08:14.700
bring Ali back to talk about AppKit.

00:08:14.700 --> 00:08:17.700
I'm going to talk a little bit
about the new archiving mechanism

00:08:17.700 --> 00:08:19.700
that we've added to Jaguar.

00:08:19.710 --> 00:08:24.250
Some of the new property list
format and new APIs to deal with

00:08:24.250 --> 00:08:26.700
property lists in Foundation.

00:08:26.700 --> 00:08:32.700
How you do some version checking so
that you can safely use these new APIs.

00:08:32.760 --> 00:08:35.700
And a few other miscellaneous topics.

00:08:35.800 --> 00:08:39.700
So first, let's talk about NSArchiver.

00:08:39.700 --> 00:08:45.700
NSArchiver has always had a
number of issues or limitations.

00:08:45.700 --> 00:08:54.100
To unarchive an object,
you have to know what order and what

00:08:54.100 --> 00:08:59.700
state was archived in the archive for
that object at some point in the past.

00:08:59.700 --> 00:09:05.700
And all the values must be unarchived in
the same order that they were archived.

00:09:05.700 --> 00:09:09.700
You also cannot skip values.

00:09:09.700 --> 00:09:13.630
For example,
you cannot choose to not unarchive

00:09:13.700 --> 00:09:18.580
some state that was previously
unarchived if you don't want it anymore,

00:09:18.620 --> 00:09:19.700
for example.

00:09:19.700 --> 00:09:25.730
You also cannot probe the archive to see,
well, was this piece of state

00:09:25.730 --> 00:09:26.700
saved in the past?

00:09:26.700 --> 00:09:29.700
And if so, unarchive it.

00:09:29.700 --> 00:09:33.700
You would want to do that, for example,
if you had many different

00:09:33.700 --> 00:09:33.700
versions of a class.

00:09:33.700 --> 00:09:34.300
You would want to do that, for example,
if you had many different

00:09:34.390 --> 00:09:34.690
versions of a class.

00:09:34.700 --> 00:09:38.330
In the past,
we wanted to see what version

00:09:38.680 --> 00:09:40.700
or what state had been saved.

00:09:40.700 --> 00:09:43.700
And for some reason, you didn't know.

00:09:44.810 --> 00:09:47.510
All of this,
these three limitations where

00:09:47.580 --> 00:09:51.900
you must unarchive values in the
same order that you archive them,

00:09:51.950 --> 00:09:57.930
you must unarchive all the values,
and you cannot ask to unarchive

00:09:57.930 --> 00:10:02.690
values which weren't actually saved,
make both forwards and

00:10:02.760 --> 00:10:07.680
backwards compatibility,
dealing with archives that are old or

00:10:07.680 --> 00:10:12.700
archives that are new on older systems,
make both of those very cumbersome.

00:10:13.290 --> 00:10:15.000
So we've introduced keyed archiving.

00:10:15.000 --> 00:10:18.580
This isn't a new idea
with us by any means.

00:10:18.670 --> 00:10:24.540
We've introduced keyed archiving
mechanism into Cocoa for Jaguar.

00:10:24.720 --> 00:10:29.390
This allows you to unarchive
values in any order.

00:10:29.720 --> 00:10:35.140
You can choose to unarchive only the
values that you want in that particular

00:10:35.140 --> 00:10:40.460
version of the class and ignore
values which were previously saved,

00:10:40.460 --> 00:10:41.700
if you wish.

00:10:41.890 --> 00:10:43.700
And you can test the archive.

00:10:43.700 --> 00:10:47.700
You can ask for values which
may not be in the archive.

00:10:48.050 --> 00:10:49.700
You ask by name.

00:10:49.700 --> 00:10:54.360
And if the value that you're asking for,
for example,

00:10:54.480 --> 00:10:59.700
you want to get some flags or some
other state out of the archive,

00:10:59.700 --> 00:11:04.300
is not there,
the new mechanism will return you some

00:11:04.300 --> 00:11:06.430
default value appropriate to the type.

00:11:06.630 --> 00:11:11.670
For example, if you try to unarchive an
object and it's not there,

00:11:11.720 --> 00:11:13.470
we will return nil.

00:11:14.970 --> 00:11:20.310
So,
eliminating those three main limitations,

00:11:20.310 --> 00:11:24.300
and I'm just talking about those three,
there are other...

00:11:24.760 --> 00:11:25.950
and Chris Kuhn.

00:11:25.950 --> 00:11:31.940
The key to archiving is simplifying
backwards and forwards compatibility.

00:11:32.120 --> 00:11:37.680
We still do type checking, however,
which is that if you encode an object,

00:11:37.930 --> 00:11:40.360
you must, say, decode an object.

00:11:40.610 --> 00:11:44.220
Or if you encode an int,
you must decode an int.

00:11:44.220 --> 00:11:48.270
You cannot decode it later as a float,
for example.

00:11:48.300 --> 00:11:54.540
We still enforce type checking,
and that's primarily to help you help us.

00:11:54.770 --> 00:11:56.940
Because we're also customers of this API.

00:11:56.940 --> 00:12:04.840
Find errors in the encoding
and decoding code in classes.

00:12:04.840 --> 00:12:07.580
We do allow some simple conversions.

00:12:07.580 --> 00:12:11.820
For example, you can encode a float
and decode it as a double,

00:12:11.890 --> 00:12:13.190
or vice versa.

00:12:13.190 --> 00:12:17.070
You can encode a 64-bit int
and decode it as a 32-bit int,

00:12:17.070 --> 00:12:20.400
and as long as it fits in 32 bits,
you're okay.

00:12:20.400 --> 00:12:22.590
Otherwise, we will raise an exception.

00:12:22.600 --> 00:12:25.300
So what does the new API look like?

00:12:25.560 --> 00:12:27.460
Well, very straightforward.

00:12:27.670 --> 00:12:31.630
NSKeyedArchiver and NSKeyedUnarchiver
are two new classes.

00:12:31.820 --> 00:12:36.550
These behave very much like the
NSArchiver and NSUnarchiver classes that

00:12:36.550 --> 00:12:38.580
you are probably already familiar with.

00:12:38.680 --> 00:12:41.610
The NSCoding protocol has not changed.

00:12:41.610 --> 00:12:43.200
It remains the same.

00:12:43.200 --> 00:12:47.920
You still use encodeWithCoder
and the initWithCoder methods.

00:12:48.220 --> 00:12:55.170
The new coder methods which take
string keys to identify the values,

00:12:55.170 --> 00:13:02.470
some of them are given here as examples,
like decode bool for key.

00:13:03.680 --> 00:13:08.330
Not all the Coder subclasses
are going to do keyed archiving.

00:13:08.470 --> 00:13:13.500
For example, we don't own,
Apple doesn't provide all the subclasses

00:13:13.520 --> 00:13:14.920
of NSCoder that are out there.

00:13:14.950 --> 00:13:18.800
Obviously you guys have written
some NSCoder subclasses and

00:13:18.800 --> 00:13:23.550
we can't obviously force your
classes now to do keyed archiving.

00:13:23.600 --> 00:13:29.430
So, there's a way now in NSCoder to
test to see if a Coder does the new

00:13:29.430 --> 00:13:35.600
keyed coding mechanism and that's
the allowed keys coding method.

00:13:36.280 --> 00:13:42.550
Currently in Foundation,
in the Jaguar drop seed

00:13:43.120 --> 00:13:48.750
that you have gotten,
only keyed archiver and NSKeed

00:13:48.800 --> 00:13:51.600
unarchiver do keyed coding.

00:13:51.600 --> 00:13:52.600
In the future,
we'll be able to do keyed archiving.

00:13:52.600 --> 00:13:52.710
So, there's a way now in NSCoder to
test to see if a Coder does the new

00:13:52.710 --> 00:13:52.890
keyed coding mechanism and that's
the allowed keys coding method.

00:13:52.890 --> 00:13:53.010
Currently in Foundation,
in the Jaguar drop seed

00:13:53.010 --> 00:13:53.120
that you have gotten,
only keyed archiver and NSKeed

00:13:53.120 --> 00:13:53.600
unarchiver do keyed coding.

00:13:53.600 --> 00:13:58.010
In the future, we're going to have,
say for example, the NSPortCoder set of

00:13:58.290 --> 00:14:04.520
classes do keyed coding,
but they don't in that CD you have.

00:14:04.960 --> 00:14:07.010
for Jaguar right now.

00:14:07.120 --> 00:14:09.830
Let's run through a quick example.

00:14:09.930 --> 00:14:13.430
In this code,
I'm gonna archive an object.

00:14:13.740 --> 00:14:17.980
Archive an integer, some flags,
and archive another object.

00:14:18.120 --> 00:14:19.860
That's pretty straightforward.

00:14:19.890 --> 00:14:23.380
The class, in its initWithCoder,
in this case,

00:14:23.380 --> 00:14:28.540
is going to choose to unarchive
the second object first,

00:14:28.770 --> 00:14:32.030
and I don't know why I would do this.

00:14:32.040 --> 00:14:36.870
Obviously you can unarchive things in
the same order that you archive them,

00:14:36.870 --> 00:14:38.550
just as you always have.

00:14:38.550 --> 00:14:42.560
But if you want to, you can, for example,
if you're going to make a decision

00:14:43.140 --> 00:14:48.200
based on one piece or two pieces
of the state in an archive,

00:14:48.240 --> 00:14:52.870
you could request those first
and then decide what different

00:14:52.880 --> 00:14:55.660
code path you're going to follow.

00:14:55.810 --> 00:14:59.290
Here in the fifth line of code,

00:15:00.040 --> 00:15:05.110
Code is trying to unarchive
a value for the key shape,

00:15:05.150 --> 00:15:07.400
which wasn't previously archived.

00:15:07.450 --> 00:15:10.430
And what's going to happen
is that decode_int for key

00:15:10.810 --> 00:15:14.760
is going to return zero,
and the shape instance variable

00:15:14.760 --> 00:15:17.080
is going to have the value zero.

00:15:17.280 --> 00:15:19.700
Finally, I'm going to show an error.

00:15:19.760 --> 00:15:22.200
Here,
we're going to decode float for key,

00:15:22.370 --> 00:15:23.510
the flags.

00:15:23.760 --> 00:15:27.280
Obviously, as I said before,
we still do type checking.

00:15:27.480 --> 00:15:32.860
So,
the float value for flags doesn't exist,

00:15:33.000 --> 00:15:34.800
and we're going to throw an exception.

00:15:34.830 --> 00:15:39.150
That's because we encoded the
flags as an int previously.

00:15:40.110 --> 00:15:43.480
So, some other notes on the
keyed archiving mechanism,

00:15:43.530 --> 00:15:45.500
just in passing.

00:15:45.870 --> 00:15:49.090
Now you can store as
many values as you like,

00:15:49.270 --> 00:15:52.520
with string names, obviously,
at the top level of the

00:15:52.520 --> 00:15:53.990
archive as you wish.

00:15:54.380 --> 00:15:58.830
Generally in the past, with an archive,
you did encode root object

00:15:58.980 --> 00:16:02.360
and encoded one object,
typically encoded one

00:16:02.360 --> 00:16:04.000
object at the top level.

00:16:04.030 --> 00:16:07.600
Now I think it will become much
more common for you to save

00:16:07.600 --> 00:16:12.000
potentially many different objects,
all named, at the top level.

00:16:12.000 --> 00:16:17.000
And of course you can unarchive
them in any order that you wish,

00:16:17.000 --> 00:16:23.000
or you can choose not to unarchive all of
them if you're later reading an archive.

00:16:23.370 --> 00:16:29.300
You should use a unique prefix on
the key names for encoded state.

00:16:29.300 --> 00:16:34.300
And Cocoa is going to use the prefix NS,
obviously.

00:16:34.640 --> 00:16:40.220
And this is to avoid colliding with
any keys that your superclasses

00:16:40.220 --> 00:16:44.380
may have already chosen or
may choose in the future,

00:16:44.380 --> 00:16:47.550
which they may not be using right now.

00:16:48.390 --> 00:16:53.970
You can also use the
non-keyed coding mechanisms.

00:16:54.170 --> 00:17:01.680
Obviously the NSCoder still implements
methods like encode value of obc type at,

00:17:02.050 --> 00:17:04.980
and those are inherited by
the new NSKeyedArchiver and

00:17:04.980 --> 00:17:06.760
NSKeyedUnarchiver classes.

00:17:06.760 --> 00:17:10.650
We don't recommend this,
and what will happen is

00:17:10.650 --> 00:17:14.440
that the information will
be stored in the archive,

00:17:14.440 --> 00:17:18.040
but for those cases where you
still use the old methods,

00:17:18.040 --> 00:17:20.740
you are still subject
to the old restrictions.

00:17:20.740 --> 00:17:24.590
That is, for those old bits of state,
you still have to unarchive

00:17:24.590 --> 00:17:28.210
them in the same order,
you still have to read all of them,

00:17:28.280 --> 00:17:36.810
and you still have to not try to read
values which you didn't previously save.

00:17:38.470 --> 00:17:42.260
So what is the output of a keyed archive?

00:17:42.400 --> 00:17:43.630
What does a keyed archive look like?

00:17:43.710 --> 00:17:48.840
Well, today,
keyed archives come in two flavors.

00:17:48.920 --> 00:17:50.040
Both of them property lists.

00:17:50.040 --> 00:17:53.380
Either an XML property
list of the type found in,

00:17:53.380 --> 00:17:57.160
say, 10.1,
or a new binary format property list that

00:17:57.310 --> 00:18:00.050
I'll be talking about in a little while.

00:18:00.060 --> 00:18:04.220
Now, the output of an archiver,
a keyed archiver,

00:18:04.220 --> 00:18:07.050
won't always be a property list.

00:18:07.370 --> 00:18:10.430
These are just the two formats
that we've introduced so far,

00:18:10.430 --> 00:18:13.300
and we may introduce more
formats in the future.

00:18:13.720 --> 00:18:20.550
IB allows you to save a Nib document in
the Jaguar snapshot that you've gotten.

00:18:20.570 --> 00:18:25.930
If you look in the preferences panel,
it talks about, with a radio button,

00:18:26.020 --> 00:18:31.100
a pre-10.2 format,
a 10.2 and later format,

00:18:31.280 --> 00:18:32.140
and both formats.

00:18:32.960 --> 00:18:39.260
What this allows you to do is save a
Nib file with either NSArchiver output,

00:18:39.260 --> 00:18:44.530
NSKeedArchiver output, or both.

00:18:44.720 --> 00:18:50.460
If you save a Nib file, for example,
in both, you can take that Nib and

00:18:50.460 --> 00:18:54.720
then read it back on 10.1,
as long as you haven't used any

00:18:54.720 --> 00:18:59.340
of the new features in 10.2,
new widgets or what have you.

00:18:59.380 --> 00:19:02.060
Of course, this is true into the future.

00:19:02.060 --> 00:19:02.140
This is true into the future.

00:19:02.510 --> 00:19:05.270
It's not just true of the
10.1 to 10.2 transients,

00:19:05.380 --> 00:19:09.840
but it will always be true that as
long as you don't use any new features

00:19:09.840 --> 00:19:15.730
and you're using old archiving,
you have to make sure you don't

00:19:15.750 --> 00:19:20.600
take that back to an older
system if you use new features.

00:19:23.040 --> 00:19:26.180
So there's a lot more information
in the foundation release notes.

00:19:26.180 --> 00:19:31.240
I wrote like 13 pages of
release notes on how to do the

00:19:31.240 --> 00:19:33.940
conversion of existing classes.

00:19:33.940 --> 00:19:35.900
They're init with coders
and encode with coders,

00:19:35.900 --> 00:19:39.450
have to be modified to take
advantage of keyed coding.

00:19:39.620 --> 00:19:46.550
And how to plan for and do
compatibility within the classes.

00:19:46.860 --> 00:19:52.440
Planning, with keyed archiving,
planning becomes almost as important

00:19:52.510 --> 00:19:58.590
and potentially even more important than
with the old NS archiver where really

00:19:58.590 --> 00:20:02.720
you had to deal with everything in the
init with coder on the reading side.

00:20:02.720 --> 00:20:06.400
Now with keyed archiving you
can do more on the encoding

00:20:06.400 --> 00:20:08.450
side to plan for the future.

00:20:10.580 --> 00:20:13.940
I mentioned this new binary
property list format.

00:20:13.940 --> 00:20:17.540
We've introduced this because it's
more compact representation of

00:20:17.540 --> 00:20:20.830
a property list and it's faster.

00:20:20.830 --> 00:20:25.870
Especially for big property lists,
it can be quite a bit faster

00:20:26.180 --> 00:20:27.580
to read the binary format.

00:20:27.690 --> 00:20:29.690
There's a lot less information,
for example,

00:20:29.700 --> 00:20:32.940
that has to come off the disk.

00:20:32.970 --> 00:20:38.480
The binary format also opens up
the possibility for us to add some

00:20:38.480 --> 00:20:43.920
additional efficiency capabilities and
these will probably come after Jaguar.

00:20:43.920 --> 00:20:47.870
They will probably not come
in Jaguar at this point.

00:20:48.360 --> 00:20:54.720
Another note, just in passing,
we've bumped the version string that

00:20:54.830 --> 00:20:58.300
you find in an XML property list to 1.0.

00:20:58.300 --> 00:21:00.930
It used to be 0.9.

00:21:01.150 --> 00:21:03.220
There have been no changes
in the property list format.

00:21:03.220 --> 00:21:06.790
We've simply incremented the
version to get it at 1.0.

00:21:06.790 --> 00:21:11.020
And we're also calling
this new binary format 1.0.

00:21:11.040 --> 00:21:17.620
This becomes interesting because we now
have APIs where you can choose which

00:21:17.970 --> 00:21:21.780
format you save right out to the disk.

00:21:21.880 --> 00:21:28.680
You can choose 1.0, 2.0,
whatever there will be in the future.

00:21:30.220 --> 00:21:33.410
As I was saying,
we've added a new class and it's

00:21:33.430 --> 00:21:36.850
property list serialization and
it has these methods to allow you

00:21:36.850 --> 00:21:40.630
to choose to write an archive,
a property list in

00:21:40.630 --> 00:21:42.380
whichever format you choose.

00:21:42.400 --> 00:21:45.820
Also read,
and on the read side it will tell

00:21:45.830 --> 00:21:50.730
you what format the file was so
that you can preserve whichever

00:21:50.880 --> 00:21:53.300
format the file started in.

00:21:53.300 --> 00:21:56.890
If you're going to read in a file,
make some changes, write it back out.

00:21:57.000 --> 00:22:01.710
We've deprecated an
serializer and a deserializer.

00:22:01.820 --> 00:22:06.300
and these have also never
supported the new property list

00:22:06.380 --> 00:22:11.520
types that we added in Mac OS X,
new relative to OpenSTEPP.

00:22:11.540 --> 00:22:18.450
The NSBoolean,
or the Boolean number and date objects,

00:22:18.530 --> 00:22:22.080
as far as allowing them
to be property lists.

00:22:23.380 --> 00:22:26.800
So let me take a break here at this
point and talk about how do you

00:22:26.800 --> 00:22:31.290
use these new APIs and features
that we've been talking about.

00:22:31.360 --> 00:22:37.060
Such that your new binary in
10.2 could also run on 10.1.

00:22:37.090 --> 00:22:41.740
Well, the first thing to do is always use
Objective-C runtime checks if you can.

00:22:41.740 --> 00:22:47.440
If it's possible with whatever
the particular API is,

00:22:47.450 --> 00:22:49.900
use runtime checks
when they're available.

00:22:49.940 --> 00:22:54.780
So check for classes
with NSClass from string,

00:22:55.660 --> 00:22:59.140
Check for methods with
response to selector.

00:22:59.170 --> 00:23:02.350
If you must,
you can go to the globals that

00:23:02.460 --> 00:23:05.530
AppKit and Foundation export and
its Foundation version number

00:23:05.660 --> 00:23:10.510
and its AppKit version number.

00:23:12.080 --> 00:23:18.260
What you do with those is that we
have recorded the historical values

00:23:18.710 --> 00:23:25.480
like the 10.1 version of Foundation in
Foundation API in one of the headers such

00:23:25.500 --> 00:23:28.400
as NS Foundation version number 10.1.

00:23:28.440 --> 00:23:30.340
You can compare against that.

00:23:30.370 --> 00:23:33.990
You can compare using the global
to see if the current version is

00:23:34.010 --> 00:23:38.010
larger than the historical version
to find out if you're running on a

00:23:38.040 --> 00:23:40.870
version which is newer than 10.1.

00:23:40.990 --> 00:23:45.780
Sometimes the release notes also mention
a particular version number and provide

00:23:45.800 --> 00:23:50.940
a constant for which you can test to see,
okay, am I running, for example,

00:23:50.960 --> 00:23:57.380
on an app kit which has, for example,
I don't want to give away any of

00:23:57.380 --> 00:24:02.230
Ali's features like directional tabs.

00:24:02.230 --> 00:24:02.230
I will.

00:24:03.600 --> 00:24:11.140
So if you want to avoid using new API,
if you don't want to risk it,

00:24:11.200 --> 00:24:14.050
because you want your app definitely
to be able to run in 10.1,

00:24:14.050 --> 00:24:18.100
there's this new header
called availabilitymacros.h.

00:24:18.110 --> 00:24:20.930
It's part of the system,
not part of Cocoa, per se.

00:24:20.930 --> 00:24:24.640
And it simply defines some constants
that can be used to protect,

00:24:24.740 --> 00:24:33.470
you know, if-def API and headers,
protect them against accidental damage.

00:24:33.500 --> 00:24:36.720
So you can use this as a declaration
if you're compiling your project,

00:24:36.720 --> 00:24:43.430
for example, so that you're only
getting 10.1 declarations.

00:24:43.620 --> 00:24:49.210
A couple of tips for OBC programmers
are that you should not subclass

00:24:49.210 --> 00:24:53.120
new classes if you want them
to run on an older system.

00:24:53.160 --> 00:24:55.700
That's just not going to work
because the new class obviously

00:24:55.700 --> 00:24:57.360
won't be on the older system.

00:24:57.500 --> 00:24:59.740
And you should not reference
new global variables.

00:24:59.740 --> 00:25:03.100
Those are the two most
common problems we see.

00:25:03.100 --> 00:25:08.690
Obviously, people do fail to check for
responding to a selector,

00:25:08.810 --> 00:25:12.800
for example, before messaging an object.

00:25:12.870 --> 00:25:15.980
But those are problems that
can easily be solved by calling

00:25:16.020 --> 00:25:17.590
something like response to selector.

00:25:17.980 --> 00:25:21.290
These other problems,
like subclassing a new class,

00:25:21.340 --> 00:25:23.470
are much harder to discover.

00:25:24.170 --> 00:25:27.880
So Foundation now supports Unicode 3.2.

00:25:27.890 --> 00:25:32.030
This includes a much larger
range of Unicode characters.

00:25:32.030 --> 00:25:32.780
What is it?

00:25:33.080 --> 00:25:41.020
17 times larger range than
the old 0 to 65,536 range.

00:25:41.120 --> 00:25:42.390
535, I should say.

00:25:42.490 --> 00:25:47.460
The string model is based
on 16-bit characters,

00:25:47.460 --> 00:25:54.340
and so what an NSString will do to
represent these higher Unicode characters

00:25:54.340 --> 00:25:56.790
is use Unicode 3.2 surrogate pairs.

00:25:56.800 --> 00:26:01.970
Now, code which is examining a string
should always have been using

00:26:01.970 --> 00:26:06.550
the range of composed character
sequence at index method to

00:26:06.760 --> 00:26:12.360
iterate over the string or examine
individual radians that you've got.

00:26:12.360 --> 00:26:13.360
So, this is a very important
thing to remember.

00:26:13.360 --> 00:26:14.360
And this is still true.

00:26:14.360 --> 00:26:20.330
Now, in Jaguar,
this method is going to return ranges

00:26:20.330 --> 00:26:24.450
for surrogate pairs that it finds.

00:26:25.830 --> 00:26:28.500
So there's some new NSString API as well.

00:26:28.500 --> 00:26:33.310
Some methods to trim and pad the
characters off the ends of strings,

00:26:33.310 --> 00:26:37.040
and these are commonly used.

00:26:37.510 --> 00:26:43.900
There's some new methods to pre-compose
and decompose strings per algorithms

00:26:43.900 --> 00:26:47.360
defined in the Unicode 3.2 spec.

00:26:47.380 --> 00:26:51.440
And there's a new method I'm going to
mention in passing on NSMutableString to

00:26:51.480 --> 00:26:57.100
efficiently replace all the occurrences
of a string inside of another string,

00:26:57.120 --> 00:26:59.530
and that's the method that
I've listed here at the bottom.

00:26:59.530 --> 00:27:01.380
I'm not going to read it.

00:27:04.250 --> 00:27:08.100
Now, in 10.2,
during the development of 10.2,

00:27:08.100 --> 00:27:12.190
we found that a number of places
in NSString were not checking as

00:27:12.190 --> 00:27:19.610
strictly as they might for various
out-of-bounds values and null values.

00:27:19.720 --> 00:27:23.330
And so the type checking in
10.2 is made much more strict

00:27:23.730 --> 00:27:26.290
on parameter errors like that.

00:27:26.380 --> 00:27:28.060
And these are programming errors.

00:27:28.060 --> 00:27:30.050
You need to fix them.

00:27:30.530 --> 00:27:34.230
For 10.1 apps,
apps compiled and linked on 10.1,

00:27:34.230 --> 00:27:35.940
we maintain compatibility.

00:27:36.010 --> 00:27:40.140
However, compatibility was often a crash.

00:27:40.140 --> 00:27:44.040
And so, compatibility is not
necessarily always a good thing.

00:27:44.040 --> 00:27:48.160
Now you'll get an exception
for these types of errors.

00:27:48.690 --> 00:27:53.930
UTF-8 conversions also, for example,
are now less forgiving than they were

00:27:53.930 --> 00:27:58.830
about invalid UTF-8 sequences in 10.1.

00:27:59.540 --> 00:28:05.020
So finally I'm going to wrap
up by mentioning an often used,

00:28:05.080 --> 00:28:09.700
often needed rather, method,
which is we've added a new

00:28:09.700 --> 00:28:14.970
method on NSObject called
performSelectorOnMainThread with

00:28:15.570 --> 00:28:17.990
argument waitUntilDoneModes.

00:28:18.100 --> 00:28:19.610
That's the full one.

00:28:19.610 --> 00:28:23.170
There's another convenience.

00:28:23.970 --> 00:28:29.220
Often with the app kit,
you have to get some work done.

00:28:29.560 --> 00:28:32.700
There's a thread in the background,
and it wants to do some work.

00:28:32.700 --> 00:28:37.670
And it needs to get that work
done by the main thread due to,

00:28:37.670 --> 00:28:39.770
well, whatever reason.

00:28:41.610 --> 00:28:47.790
Now, to do this in the past,
we've often recommended DIO.

00:28:47.990 --> 00:28:50.630
You set up a DIO connection
on the main thread,

00:28:50.740 --> 00:28:54.740
and your background thread looks it up,
sends messages via DIO between

00:28:54.740 --> 00:28:55.730
one thread and another.

00:28:55.830 --> 00:29:01.710
Well, this has never been a really
appealing workaround solution for us,

00:29:01.800 --> 00:29:06.200
but it's the best we could recommend.

00:29:06.710 --> 00:29:09.620
The new method,
performSelectorOnMainThread,

00:29:09.620 --> 00:29:14.600
is much cheaper than setting
up a big DO subsystem.

00:29:14.740 --> 00:29:17.740
You don't have to marshal
arguments back and forth.

00:29:17.790 --> 00:29:23.100
And I had one person
who had just gone in,

00:29:23.210 --> 00:29:25.860
ripped out, said, "Oh,
I wish I'd had this when I first wrote

00:29:25.940 --> 00:29:30.660
the code." They ripped out 100 lines of
their code and called this one function.

00:29:30.730 --> 00:29:34.500
And they said,
"This is the best method ever."

00:29:35.350 --> 00:29:39.810
We do maintain ordering for a
particular background thread,

00:29:39.810 --> 00:29:42.100
you know, sending to the main thread,
or the main thread can

00:29:42.100 --> 00:29:43.650
execute this method as well.

00:29:43.840 --> 00:29:46.990
We do maintain the order
of those invocations,

00:29:46.990 --> 00:29:51.530
but obviously, there's no ordering
guaranteed amongst threads,

00:29:51.530 --> 00:29:55.840
or amongst a background thread and the
main thread performing this method.

00:29:56.610 --> 00:30:00.640
Now let me bring Ali Ozer back out
to talk about the APCIT changes

00:30:00.640 --> 00:30:03.940
that occurred in 10.1 and 10.2.

00:30:03.940 --> 00:30:05.900
Ali?

00:30:12.820 --> 00:30:15.770
Just to highlight this method again,
if you are doing AppKit programming

00:30:15.770 --> 00:30:18.510
and you're using multiple threads,
this method is your friend.

00:30:18.740 --> 00:30:22.150
It's as useful as the performAfterDelay
method that some of you might be using.

00:30:22.480 --> 00:30:25.800
That one lets you perform
tomorrow what you can do today.

00:30:25.800 --> 00:30:28.350
The other one allows you to
have somebody else perform

00:30:28.460 --> 00:30:29.800
what you can perform instead.

00:30:29.800 --> 00:30:31.800
So these are both very useful methods.

00:30:31.800 --> 00:30:36.800
Okay, so we're going to first talk a
little bit about 10.1 AppKit changes.

00:30:36.800 --> 00:30:40.720
Just the highlights because many of you
are already probably familiar with these.

00:30:40.820 --> 00:30:42.790
And then we're going to
dive into Jaguar changes.

00:30:42.800 --> 00:30:47.740
One of the biggest areas of
change in 10.1 was NSDocument.

00:30:47.800 --> 00:30:52.610
We added the ability to track documents
on file systems that support it,

00:30:52.970 --> 00:30:57.800
meaning if your document is open in
an NSDocument-based app and the user

00:30:57.800 --> 00:31:01.800
renames the volume or renames the
folder that encloses the document,

00:31:01.870 --> 00:31:04.300
moves the document, and so on,
your app will notice this

00:31:04.300 --> 00:31:05.800
immediately and take action.

00:31:05.800 --> 00:31:07.800
And that is good
Macintosh user experience.

00:31:07.800 --> 00:31:10.800
It also preserves attributes
and aliases to documents.

00:31:10.800 --> 00:31:13.050
You move the document to a
new location on your desktop,

00:31:13.120 --> 00:31:15.760
you re-save it again,
the new location is maintained.

00:31:15.800 --> 00:31:18.870
And also aliases to that
document will also be maintained.

00:31:18.870 --> 00:31:21.270
These are all natural
things that should work,

00:31:21.270 --> 00:31:23.800
and with NSDocument-based
apps it does work.

00:31:23.800 --> 00:31:26.380
NSDocument in 10.1 also
supports hidden extensions,

00:31:26.380 --> 00:31:29.000
which I will actually talk in a
little detail about because this is

00:31:29.000 --> 00:31:30.800
an important feature we introduced.

00:31:30.800 --> 00:31:31.800
Okay, so we're going to talk about 10.1.

00:31:33.480 --> 00:31:36.550
As most of you know,
file extensions are a good

00:31:36.610 --> 00:31:41.320
idea for compatibility with
other systems and the web.

00:31:42.430 --> 00:31:42.480
I think most of you agree with that.

00:31:42.890 --> 00:31:44.920
Well, we also know that they
confuse some users,

00:31:44.920 --> 00:31:46.800
scare others,
and some users are just plain

00:31:46.800 --> 00:31:48.400
disgusted by file extensions.

00:31:48.400 --> 00:31:50.260
And that's true too,
because they get in the way of

00:31:50.260 --> 00:31:52.040
naming their files the way they want.

00:31:52.150 --> 00:31:57.300
So, what we did in 10.1 is to introduce
this concept of hidden file extensions.

00:31:57.400 --> 00:32:01.840
And this isn't just hiding the
file extension across all files.

00:32:01.860 --> 00:32:04.980
This is hide the file
extension on a per-file basis.

00:32:05.040 --> 00:32:07.280
So, it's a pretty powerful feature.

00:32:07.360 --> 00:32:09.120
The extension is still in the name.

00:32:09.210 --> 00:32:10.280
It's not displayed.

00:32:10.280 --> 00:32:15.780
If the user wants to save their
image as WWDCphoto and hits return,

00:32:15.840 --> 00:32:20.200
that is the name that they see in Finder,
in the Save panel,

00:32:20.390 --> 00:32:21.430
in their window title bar.

00:32:21.700 --> 00:32:26.510
However, in the file system,
the file is called WWDCphoto.jpg.

00:32:27.810 --> 00:32:31.260
So let me just talk a little bit
about what it takes to take advantage

00:32:31.260 --> 00:32:33.460
of this feature in your application.

00:32:33.460 --> 00:32:36.820
When you put up a save panel,
you need to call this method

00:32:36.820 --> 00:32:39.280
saying that you are willing to
deal with hidden extensions.

00:32:39.280 --> 00:32:43.080
And this caused the save panel to get a
little more UI and look for this case.

00:32:43.440 --> 00:32:44.920
And then when the save
panel is dismissed,

00:32:44.990 --> 00:32:47.200
you ask, is the extension hidden?

00:32:47.250 --> 00:32:50.700
This basically indicates whether the
user wanted the extension hidden or not.

00:32:50.700 --> 00:32:53.530
And based on this,
you will hide the extension.

00:32:53.570 --> 00:32:56.240
Now note that the file name
the save panel returns will

00:32:56.240 --> 00:32:57.760
still have the extension.

00:32:57.780 --> 00:33:02.720
It will always be called WWDCphoto.jpg,
and this will tell you whether

00:33:02.740 --> 00:33:04.040
you should hide the extension.

00:33:04.150 --> 00:33:07.280
If the extension should be hidden,
you would use NSFileManager

00:33:07.350 --> 00:33:10.030
and this new attribute,
NSFileExtensionHidden,

00:33:10.040 --> 00:33:13.090
on the second line there,
to set its value to yes.

00:33:13.290 --> 00:33:15.800
And you might already have
code like this in your app to

00:33:15.800 --> 00:33:17.280
set attributes on your files.

00:33:17.460 --> 00:33:20.490
Here is yet one more attribute
you would use this for.

00:33:20.840 --> 00:33:23.150
And finally,
when dealing with hidden extensions,

00:33:23.200 --> 00:33:25.350
if you do want to show
the name of a file,

00:33:25.430 --> 00:33:27.380
you should be using this
file manager method,

00:33:27.380 --> 00:33:31.700
displayNameAtPath,
which returns to you the user-visible,

00:33:31.700 --> 00:33:34.100
the human-readable name of the file.

00:33:34.320 --> 00:33:36.720
So in this case,
it will not have the .jpg if

00:33:36.720 --> 00:33:38.700
the file extension was hidden.

00:33:38.790 --> 00:33:41.800
And the savePanel, finder,
windowTitleBars,

00:33:41.920 --> 00:33:46.550
etc., those already call this method,
obviously, so you don't have to

00:33:46.550 --> 00:33:48.460
worry about those cases.

00:33:48.580 --> 00:33:51.220
The good thing is NSDocument
does all this for you.

00:33:51.220 --> 00:33:53.950
So if you're not an NSDocument-based app,
for instance, TextEdit,

00:33:54.130 --> 00:33:56.450
it does this by hand,
but if you're NSDocument-based,

00:33:56.640 --> 00:33:57.960
all of this happens for you.

00:33:58.170 --> 00:34:00.660
There are a few override
points or methods you can call

00:34:00.710 --> 00:34:03.780
to customize this behavior,
like find out if the user did want

00:34:03.780 --> 00:34:06.020
the hidden extension and so on,
but in general,

00:34:06.020 --> 00:34:07.220
you don't have to worry about it.

00:34:07.260 --> 00:34:09.720
So NSDocument is your friend.

00:34:10.640 --> 00:34:14.310
In TextSystem in 10.1,
we added support for filter services

00:34:14.460 --> 00:34:16.050
and we taught it how to speak.

00:34:16.060 --> 00:34:18.200
Filter services,
if you're familiar with NSImages'

00:34:18.200 --> 00:34:20.790
support of filter services,
work the same way.

00:34:21.140 --> 00:34:26.680
Methods in the TextSystem
that open files generically,

00:34:26.680 --> 00:34:28.870
meaning just by file path or by URL,
now know how to open files that

00:34:28.940 --> 00:34:30.240
can be opened via a filter service.

00:34:30.340 --> 00:34:33.070
What I mean by here is if the user
has a filter service that converts

00:34:33.380 --> 00:34:37.020
Word documents or RightNow documents,
say, to RTF,

00:34:37.050 --> 00:34:40.440
the TextSystem can now open them after
running them through the filter service.

00:34:42.450 --> 00:34:44.500
And just like in S-Image,
there are methods to tell

00:34:44.500 --> 00:34:47.530
you what the native types
supported by the text system are,

00:34:47.630 --> 00:34:52.650
so RTF, etc., and what the filter
service converted types are,

00:34:52.650 --> 00:34:56.430
so you can make decisions based
on the return values here.

00:34:56.570 --> 00:34:59.470
And also note that if you open
a file and it was converted,

00:34:59.510 --> 00:35:02.450
you get this key converted
in the document's attributes

00:35:02.450 --> 00:35:06.210
dictionary with a value of true,
indicating that the file was converted.

00:35:06.290 --> 00:35:10.130
So you can indicate to the
user that this file was loaded

00:35:10.130 --> 00:35:12.200
as a result of conversion.

00:35:12.340 --> 00:35:14.150
The text system now knows how to speak.

00:35:14.410 --> 00:35:15.670
This one is fairly straightforward.

00:35:15.680 --> 00:35:19.840
It's a very high-level API that
is connected to responder methods.

00:35:19.940 --> 00:35:23.240
The startSpeaking,
stopSpeaking menu items will drive these,

00:35:23.240 --> 00:35:26.180
and if you actually implement
these on your responder classes,

00:35:26.300 --> 00:35:29.910
the menu items will also
apply to your classes as well.

00:35:31.560 --> 00:35:35.600
In between 10.0 and 10.1,
one of the things we did to the system

00:35:35.600 --> 00:35:37.540
was a lot of performance improvements.

00:35:37.540 --> 00:35:41.880
And one area where performance was
improved was live resizing of windows.

00:35:41.880 --> 00:35:47.620
And one way to achieve this is via
these APIs that we publicized in 10.1.

00:35:47.640 --> 00:35:51.200
You can find out when a view
starts a live resize or when the

00:35:51.350 --> 00:35:54.710
window starts a live resize or
when the window ends live resizing.

00:35:54.720 --> 00:35:58.110
You'll get these method calls once,
at the beginning and at the end.

00:35:58.160 --> 00:36:00.080
And even if your view is
inserted and removed from the

00:36:00.160 --> 00:36:02.860
view hierarchy repeatedly,
like the columns of a browser,

00:36:02.860 --> 00:36:04.860
you'll still only get these methods once.

00:36:04.860 --> 00:36:07.310
These methods allow you to
set up some state and tear

00:36:07.390 --> 00:36:08.790
down that state at the end.

00:36:08.840 --> 00:36:12.330
For example,
if your view does some very complicated

00:36:12.330 --> 00:36:15.210
drawing that takes some time,
during live resize,

00:36:15.210 --> 00:36:16.580
you might want to take a shortcut.

00:36:16.580 --> 00:36:18.660
You might want to cache
parts of the view.

00:36:18.660 --> 00:36:20.910
If you're a map program,
you might want to not display

00:36:20.910 --> 00:36:23.980
every little village in the
map and just draw less things.

00:36:23.980 --> 00:36:28.100
If you use these methods at the end,
you do want your view to be redrawn.

00:36:28.100 --> 00:36:31.080
You just say set needs display, yes,
and the view will be redrawn

00:36:31.080 --> 00:36:31.460
once the view is redrawn.

00:36:31.500 --> 00:36:32.500
Once the live resize is over.

00:36:32.500 --> 00:36:35.240
There's also additional
convenience method in live resize,

00:36:35.240 --> 00:36:36.580
which is fairly easy.

00:36:36.580 --> 00:36:39.520
You can just call it from your draw
rect to see if you're in live resize.

00:36:39.520 --> 00:36:42.020
If you are, do less work,
and the live resize will

00:36:42.080 --> 00:36:43.570
be smoother for the user.

00:36:43.580 --> 00:36:47.960
This also applies to split view resizing
and any other live resizing situations.

00:36:49.870 --> 00:36:53.160
This application in 10.1 has the ability
to set the contents of a doc menu.

00:36:53.210 --> 00:36:54.380
This is fairly straightforward.

00:36:54.480 --> 00:37:00.070
You can provide a menu in a Nib and
provide the name of that Nib file.

00:37:00.200 --> 00:37:01.140
That's fairly static.

00:37:01.370 --> 00:37:04.000
Or you can provide the
menu via a delegate method,

00:37:04.000 --> 00:37:05.690
which is of course more dynamic.

00:37:05.990 --> 00:37:10.040
Many of you have reported this bug
where the sender in these cases was the

00:37:10.130 --> 00:37:12.720
application object and not the menu item.

00:37:12.730 --> 00:37:14.800
This has been fixed in Jaguar.

00:37:14.800 --> 00:37:16.310
We also have doc notifications.

00:37:16.350 --> 00:37:18.950
Some of you might have noticed
those bouncing doc icons and

00:37:18.950 --> 00:37:20.800
wondered where they're coming from.

00:37:20.800 --> 00:37:25.620
There are two APIs that let you start
a notification and end a notification.

00:37:26.060 --> 00:37:28.760
These are automatic for modal
panels in an active app.

00:37:28.810 --> 00:37:31.530
What happens is if your
app is in the background,

00:37:31.530 --> 00:37:35.410
not active, and it puts up a modal panel,
instead of that modal panel

00:37:35.410 --> 00:37:37.630
coming right to the front,
right in your face,

00:37:37.740 --> 00:37:39.970
interrupting your typing,
the doc icon automatically

00:37:39.970 --> 00:37:40.800
starts bouncing.

00:37:40.830 --> 00:37:43.790
You don't have to do anything
for modal panels in this case.

00:37:43.800 --> 00:37:44.770
Note that you can set the
settings for the doc menu.

00:37:44.810 --> 00:37:48.800
The only thing I'll add in Jaguar is in
case this bouncing wasn't enough for you,

00:37:48.800 --> 00:37:51.800
this will also cause some speaking
and other things to happen.

00:37:51.800 --> 00:37:52.800
You'll see it.

00:37:53.600 --> 00:39:15.900
[Transcript missing]

00:39:17.370 --> 00:39:18.890
Okay, I didn't skip anything.

00:39:19.040 --> 00:39:19.460
No.

00:39:20.070 --> 00:39:23.290
Okay, so now I'm going to go to
the Jaguar AppKit changes,

00:39:23.290 --> 00:39:26.300
which is the bulk of the
rest of the talk here.

00:39:26.300 --> 00:39:27.060
Text system.

00:39:27.110 --> 00:39:29.240
We have more changes in the text system.

00:39:29.320 --> 00:39:32.440
Now as you saw in Scott's talk yesterday,
it comes with more

00:39:32.440 --> 00:39:33.300
built-in spelling checkers.

00:39:33.300 --> 00:39:36.790
And there's an interesting
little story here,

00:39:36.790 --> 00:39:39.300
spelling checking disasters.

00:39:39.300 --> 00:39:43.990
That colorful over there was
supposed to be spelled the proper

00:39:44.060 --> 00:39:46.300
way for people coming from England.

00:39:46.300 --> 00:39:50.300
But PowerPoint spell checker at the
last minute seems to have fixed it,

00:39:50.300 --> 00:39:55.060
so here I am up there with
my point somewhat ruined.

00:39:55.420 --> 00:39:58.360
Anyway, if you're using the
British English spell checker,

00:39:58.550 --> 00:40:01.300
which is distinct from the
American spell checker,

00:40:01.300 --> 00:40:03.300
you would get colorful to
be recognized with a U.

00:40:03.300 --> 00:40:05.700
And there's also
multilingual spell checker,

00:40:05.700 --> 00:40:08.400
which does recognize many
languages at once if you're

00:40:08.400 --> 00:40:10.300
doing a lot of multilingual work.

00:40:10.330 --> 00:40:12.280
So that's fairly obvious.

00:40:12.280 --> 00:40:15.300
We finally added support for
right centered and decimal tabs.

00:40:15.300 --> 00:40:20.300
And we've also added support
for bidirectional text.

00:40:20.300 --> 00:40:22.290
The tab stops is fairly straightforward.

00:40:22.290 --> 00:40:25.130
For many years now,
you might have seen these little

00:40:25.290 --> 00:40:29.330
widgets in the ruler of TextCited
and other Cocoa applications,

00:40:29.400 --> 00:40:30.260
and they were dimmed.

00:40:30.300 --> 00:40:32.300
Well, now they aren't, so that's that.

00:40:32.520 --> 00:40:39.020
And the enum values were there before,
so there's no new API.

00:40:39.760 --> 00:40:43.940
Bi-directional text,
as some of you are probably aware,

00:40:43.940 --> 00:40:46.750
bi-directional text is needed
for proper support of Hebrew,

00:40:46.750 --> 00:40:48.200
Arabic, and some other scripts.

00:40:48.330 --> 00:40:54.220
It's not just right-to-left text,
it's actually the ability to put the

00:40:54.380 --> 00:41:01.200
English and Japanese normal left-to-right
scripts with these other scripts going

00:41:01.200 --> 00:41:03.450
in the same line at the same time,
which actually has a lot

00:41:03.580 --> 00:41:04.660
of complicated rules.

00:41:04.780 --> 00:41:07.520
Selections can now be disjoint.

00:41:07.610 --> 00:41:10.360
When you make a selection,
you'll see two or three boxes and so on.

00:41:10.690 --> 00:41:15.200
So it's actually fairly
complex functionality in there.

00:41:15.310 --> 00:41:21.240
One thing we've said with regards to this
feature before is that the tech system

00:41:21.240 --> 00:41:26.210
is ready for this feature API-wise,
and we will not add any new APIs.

00:41:26.320 --> 00:41:27.860
It turns out that was true.

00:41:27.870 --> 00:41:30.000
We did not really add any new APIs.

00:41:30.120 --> 00:41:33.060
The only API we added is
some highly obscure thing,

00:41:33.060 --> 00:41:34.460
which most of you won't need.

00:41:34.460 --> 00:41:36.690
It's basically a new glyph
attribute indicating the

00:41:36.690 --> 00:41:38.100
bi-directional text levels.

00:41:38.210 --> 00:41:41.080
We did also add a new
typesetter subclass,

00:41:41.190 --> 00:41:45.050
because we want to keep the old
typesetter there for those of you

00:41:45.050 --> 00:41:49.020
who might have subclassed it or who
might have a need to use that exact

00:41:49.020 --> 00:41:51.160
typesetter with its typesetting rules.

00:41:51.270 --> 00:41:54.640
But the new typesetter subclass
will be the default typesetter,

00:41:54.640 --> 00:41:58.600
so by default most apps will just get
this functionality out of the box.

00:41:58.720 --> 00:42:02.530
Now note that in the Jaguar CD you got,
the new typesetter subclass

00:42:02.530 --> 00:42:04.260
is not enabled by default.

00:42:05.890 --> 00:42:11.810
Localized File System View,
you probably saw this in

00:42:11.810 --> 00:42:11.810
Scott Forstall's talk yesterday.

00:42:12.630 --> 00:42:18.670
Here we show the file system to you
in localized for the user's language.

00:42:18.670 --> 00:42:20.340
We're not localizing the file system.

00:42:20.390 --> 00:42:23.630
The file system names, the folders, etc.

00:42:23.710 --> 00:42:24.970
are not renamed.

00:42:25.080 --> 00:42:28.340
Instead, we just display localized
names for different entities,

00:42:28.340 --> 00:42:31.740
which allows different users on the
same machine to see the file system

00:42:31.740 --> 00:42:33.550
entities in their own language.

00:42:34.730 --> 00:42:38.250
Now some of you might be saying,
you're recycling slides, aren't you?

00:42:38.300 --> 00:42:41.940
Because this is the slide I just
showed 15 slides ago where I said,

00:42:41.950 --> 00:42:44.600
use this if you want to get
proper hidden extension behavior.

00:42:44.630 --> 00:42:47.650
Well, it turns out in Jaguar you can
use this if you want to get proper

00:42:47.650 --> 00:42:49.500
localized file system view behavior.

00:42:49.570 --> 00:42:52.990
This method now not only
does hidden extensions,

00:42:52.990 --> 00:42:55.300
it will also localize as well.

00:42:56.690 --> 00:42:59.800
Now some of you might be wondering,
oh great, now how do I localize my app

00:42:59.900 --> 00:43:02.300
name so it appears localized?

00:43:02.420 --> 00:43:04.550
The process is actually
pretty straightforward.

00:43:04.990 --> 00:43:09.240
It's what you already do, really,
for the most part.

00:43:09.370 --> 00:43:11.770
You add CFBundle.name to your Info.plist.

00:43:11.770 --> 00:43:13.370
PV already puts one there for you.

00:43:13.690 --> 00:43:16.090
It needs to be the same
as bundle's actual name.

00:43:16.190 --> 00:43:21.640
So if your bundle is called textedit.app,
your CFBundle.name is textedit.

00:43:21.730 --> 00:43:24.990
That's because if the
username is textedit.old or

00:43:25.030 --> 00:43:29.370
some simple word processor,
at that point it's no longer localized

00:43:29.370 --> 00:43:31.880
because the name has been changed.

00:43:31.990 --> 00:43:34.210
Then you add this key
ls.has.localized.displayname

00:43:34.210 --> 00:43:35.100
to your Info.plist.

00:43:35.210 --> 00:43:37.480
This is probably the only
special thing you need to do.

00:43:37.480 --> 00:43:38.980
This is for performance reasons.

00:43:38.980 --> 00:43:41.660
We decided we needed
to have a separate key.

00:43:41.780 --> 00:43:45.190
Then you would have a CFBundle.name
in your Info.plist.strings,

00:43:45.190 --> 00:43:47.040
which you might already have added.

00:43:47.200 --> 00:43:49.630
So CFBundle.name in
your Info.plist.strings

00:43:49.720 --> 00:43:50.980
provides localized names.

00:43:51.050 --> 00:43:54.540
This other key tells the system
that there is a localized name.

00:43:54.610 --> 00:43:56.690
Note that in addition to
localizing your app name,

00:43:56.690 --> 00:43:58.990
you can localize your bundles
with the same process.

00:43:59.070 --> 00:44:01.340
You can localize
arbitrary folders as well.

00:44:01.500 --> 00:44:05.970
This will be documented in
the release notes in Jaguar.

00:44:07.520 --> 00:44:08.930
So tab views.

00:44:09.000 --> 00:44:10.710
Chris already spilled
the beans on this one.

00:44:10.750 --> 00:44:13.170
But anyway, so there's directional tabs.

00:44:13.680 --> 00:44:17.110
Before we only had the northward,
the upward facing tabs.

00:44:17.350 --> 00:44:18.200
Actually that's not really true.

00:44:18.200 --> 00:44:21.740
We also had the rather shy
and elusive tabless tab view,

00:44:21.740 --> 00:44:23.560
which actually is more useful
than some people think.

00:44:23.620 --> 00:44:25.270
But anyway,
the one in the middle was also there,

00:44:25.270 --> 00:44:27.040
although most people
probably didn't use it.

00:44:27.160 --> 00:44:40.670
Now we have the left, right,
and the bottom tab views as well.

00:44:40.670 --> 00:44:40.670
The interesting thing here
is that there's no new APIs.

00:44:40.670 --> 00:44:40.670
Again, all the API was there.

00:44:40.670 --> 00:44:40.670
But the methods that you might
override or call to draw the

00:44:40.670 --> 00:44:40.670
labels do the right thing.

00:44:40.940 --> 00:44:44.140
In that, they transform the coordinate
system for you and then call you.

00:44:44.140 --> 00:44:46.720
So if you do drawing,
if you write some text,

00:44:46.790 --> 00:44:50.230
they will appear in the
orientation shown here.

00:44:50.300 --> 00:44:51.190
So you don't have to worry about it.

00:44:51.200 --> 00:44:54.720
If you want to do something special,
then you might have to do other

00:44:54.720 --> 00:44:57.340
coordinate system transforms yourself.

00:44:57.610 --> 00:44:59.510
NSImage now,
there are a lot of bug fixes and

00:44:59.610 --> 00:45:01.800
performance enhancements in NSImage.

00:45:01.950 --> 00:45:03.220
These are the top three.

00:45:03.340 --> 00:45:04.840
It now supports animated images.

00:45:04.840 --> 00:45:08.570
This is a support at very
low level where NSImage reps

00:45:08.570 --> 00:45:11.930
created from animated images,
for instance animated GIF files,

00:45:11.930 --> 00:45:17.560
have these three properties which lets
you find out what the frame count is,

00:45:17.560 --> 00:45:20.640
what the duration is,
and also set what the current frame is.

00:45:20.750 --> 00:45:23.040
Now, it's possible, of course,
using this API,

00:45:23.140 --> 00:45:25.790
it's possible to do all sorts
of animated image stuff.

00:45:25.910 --> 00:45:30.550
We are looking at getting feature into
NSImageView and NSText for Jaguar.

00:45:30.760 --> 00:45:33.460
Currently, the support is in NSImageRep.

00:45:33.600 --> 00:45:36.880
Progressive image loading allows you
to load an image in the background

00:45:36.880 --> 00:45:40.300
and display it to the user in pieces
as the image becomes available.

00:45:40.410 --> 00:45:41.790
There are four delegate methods.

00:45:41.890 --> 00:45:44.140
All you have to do is implement
the last one for the simplest

00:45:44.200 --> 00:45:48.540
approach here while you are here
when the image is finally loaded.

00:45:48.620 --> 00:45:50.880
But, for instance,
you can also override the second

00:45:51.200 --> 00:45:54.210
method to find out when the header
of the image has been loaded so you

00:45:54.260 --> 00:45:57.820
know how big it is and you can start
displaying a placeholder if you want.

00:45:57.960 --> 00:46:00.460
You can also override the
third one to find out as the

00:46:00.460 --> 00:46:01.980
image chunks are coming in.

00:46:02.050 --> 00:46:06.850
There is also a more sophisticated
API down in ImageRep for if you

00:46:06.860 --> 00:46:10.110
are the one getting the data and
you want to pass it to NSImage,

00:46:10.280 --> 00:46:12.690
you can also use that API.

00:46:13.030 --> 00:46:16.600
And finally, we are making caching
policy more explicit.

00:46:16.680 --> 00:46:20.840
Here, by caching,
I mean NSImage's ability to put bitmaps,

00:46:20.840 --> 00:46:21.900
PDFs, etc.

00:46:21.900 --> 00:46:23.200
in off-screen windows.

00:46:23.440 --> 00:46:26.000
Clearly, if all the images are cached
in off-screen windows,

00:46:26.050 --> 00:46:28.990
they're faster,
but also there's more memory used.

00:46:29.090 --> 00:46:32.440
So, NSImage does make the decision
by itself on a per-image basis,

00:46:32.440 --> 00:46:34.980
but if you're dealing
with hundreds of images,

00:46:35.050 --> 00:46:39.110
you might find that it's better for your
app's purposes to set the policy on a

00:46:39.140 --> 00:46:40.990
per-image basis one way or the other.

00:46:40.990 --> 00:46:42.990
This API will do that.

00:46:45.900 --> 00:46:48.230
There's a little stylized spinning
arrow on the side for you,

00:46:48.230 --> 00:46:51.490
but basically this is a control
that was missing in Cocoa.

00:46:51.530 --> 00:46:54.900
We've added this as a variant
of progress indicator class.

00:46:54.900 --> 00:46:57.690
It's because this is pretty
much the same thing as an

00:46:57.690 --> 00:46:59.900
indeterminate progress indicator.

00:46:59.900 --> 00:47:02.800
You can set the style by default,
you get the bar,

00:47:02.880 --> 00:47:05.870
but if you set the style you
can get the spinning one.

00:47:05.940 --> 00:47:08.890
There's also more API in
progress indicator.

00:47:08.900 --> 00:47:09.850
You can now size to fit it.

00:47:09.900 --> 00:47:13.960
You can create a spinning arrow
that's as big as your screen,

00:47:14.030 --> 00:47:16.840
but if you size to fit it will give
you the natural recommended size.

00:47:16.890 --> 00:47:20.040
You can also set whether the
spinning arrows or the bar is

00:47:20.040 --> 00:47:21.890
displayed when it's stopped.

00:47:21.910 --> 00:47:24.440
Typically the spinning arrows are
not displayed when it's stopped,

00:47:24.520 --> 00:47:27.170
for instance, so this controls that.

00:47:27.730 --> 00:47:30.610
NS Toolbar now has a small icon mode.

00:47:30.820 --> 00:47:33.710
We will automatically resize
your images for you if you want,

00:47:33.710 --> 00:47:36.660
or you can provide small images
if you really want to control

00:47:36.700 --> 00:47:38.390
every pixel in that toolbar.

00:47:38.530 --> 00:47:40.620
The API is fairly straightforward.

00:47:40.630 --> 00:47:43.060
It's much like the other toolbar APIs.

00:47:43.210 --> 00:47:46.720
One thing that people have been
asking in NS Workspace is to get

00:47:46.810 --> 00:47:50.400
more information about launched
applications and running applications.

00:47:50.400 --> 00:47:54.560
This is something that you guys
had to go to the process manager

00:47:54.560 --> 00:47:56.500
in Carbon for on occasion.

00:47:56.650 --> 00:48:02.820
Now what we've done is the notifications
for launching apps now include in

00:48:02.820 --> 00:48:07.620
the user info dictionary these keys:
the path of the application, the PID,

00:48:07.620 --> 00:48:08.300
and so on.

00:48:08.360 --> 00:48:10.850
So you can find out more
about launched applications.

00:48:10.920 --> 00:48:13.190
In addition,
you can ask what are the launched

00:48:13.220 --> 00:48:16.560
applications so far and what's
the current active application.

00:48:16.650 --> 00:48:19.860
These return either an array
of dictionaries or a dictionary

00:48:19.860 --> 00:48:23.020
which contain the keys
I showed on the previous slide.

00:48:24.660 --> 00:48:28.820
Yesterday you saw the textured,
the metal background window.

00:48:28.910 --> 00:48:32.980
So that's shown here at the end there.

00:48:33.310 --> 00:48:35.410
Textured background window mask.

00:48:35.470 --> 00:48:41.580
We call it textured just in
case it changes from metal.

00:48:41.580 --> 00:48:41.580
But anyway, so this

00:48:42.260 --> 00:48:47.670
This is now available to you either
through IB or through API to use.

00:48:47.770 --> 00:48:50.930
Now one warning about this,
every window and every app

00:48:50.930 --> 00:48:52.590
on the system is metal.

00:48:52.660 --> 00:48:55.930
The system is going to look rather heavy.

00:48:56.410 --> 00:49:00.790
The idea here is you would want to use
this either in one window apps like

00:49:00.930 --> 00:49:06.200
Calculator or apps where the window
represents an interface to the device.

00:49:06.200 --> 00:49:10.200
iTunes, iPhoto, those are good examples.

00:49:10.300 --> 00:49:13.780
You should not use this style
of window for your panels,

00:49:13.780 --> 00:49:17.200
your auxiliary windows, your sheets,
and so on.

00:49:17.200 --> 00:49:21.190
Those still use the
favorite corduroy pattern.

00:49:21.390 --> 00:49:24.690
Now the one I didn't talk about,
non-activating panel mask.

00:49:24.800 --> 00:49:27.200
If your app wants to put up
a panel that gets user input,

00:49:27.200 --> 00:49:29.390
like keyboard entry,
but you don't want your

00:49:29.470 --> 00:49:31.350
app to become active,
this is the style of

00:49:31.420 --> 00:49:32.820
panel you want to use.

00:49:32.820 --> 00:49:35.070
It's useful on certain occasions.

00:49:35.090 --> 00:49:37.490
It's certainly used by the system.

00:49:37.720 --> 00:49:39.960
In addition to the
textured background stuff,

00:49:40.070 --> 00:49:42.700
we've also added slightly finer control.

00:49:42.910 --> 00:49:46.030
You can now make windows
movable by window background.

00:49:46.290 --> 00:49:48.600
This is appropriate, clearly,
for textured windows

00:49:48.600 --> 00:49:51.410
which have no title bar,
but also for other windows where

00:49:51.590 --> 00:49:54.660
there's no obvious title bar,
like a clock and so on.

00:49:54.930 --> 00:49:57.200
This will make the window
move from anywhere.

00:49:57.330 --> 00:49:59.920
In addition,
you can set the background color of

00:50:00.000 --> 00:50:04.070
a window to an arbitrary color or,
in fact, even a texture, as you know,

00:50:04.070 --> 00:50:07.330
because NS colors can represent textures,
patterns.

00:50:07.500 --> 00:50:15.420
And again, don't use this everywhere,
but there are cases where it's handy.

00:50:16.110 --> 00:50:21.000
Yesterday in Scott's talk,
you heard about Carbon/CoCoa integration.

00:50:21.130 --> 00:50:25.260
So the goal here is,
for you Cocoa developers,

00:50:25.410 --> 00:50:28.750
the goal here is for you to
allow writing plug-ins in Cocoa,

00:50:28.760 --> 00:50:30.460
say, for existing Carbon applications.

00:50:30.460 --> 00:50:34.440
And you saw that Photoshop demo where
a Cocoa plug-in worked in Photoshop.

00:50:34.530 --> 00:50:38.290
A few weeks ago, we did not think that
would be possible at all,

00:50:38.340 --> 00:50:40.460
but it turns out it was.

00:50:40.580 --> 00:50:43.890
And also,
you want your Cocoa app to be able

00:50:43.890 --> 00:50:46.860
to use existing Carbon plug-ins.

00:50:46.860 --> 00:50:50.060
Or maybe you're transitioning
from one environment to the other

00:50:50.060 --> 00:50:53.220
and you want to use existing code
fragments in your application.

00:50:53.340 --> 00:50:55.100
And that's what our
goal here is to enable.

00:50:55.210 --> 00:50:58.960
It doesn't enable really
fine control within a window.

00:50:58.960 --> 00:51:02.300
You can't have a Carbon button,
a Cocoa button, a Carbon toolbar,

00:51:02.300 --> 00:51:04.210
a Cocoa drawer all talking to each other.

00:51:04.220 --> 00:51:07.920
That's more fine control than
we're providing at this point.

00:51:08.040 --> 00:51:09.620
But one thing that really surprised me.

00:51:09.620 --> 00:51:10.460
I was working on these systems.

00:51:10.460 --> 00:51:13.710
I was working on these slides,
like 1:00 AM a few weeks ago.

00:51:14.080 --> 00:51:17.440
And I brought up the color
panel in PowerPoint on Jaguar,

00:51:17.700 --> 00:51:19.220
and it was a Cocoa color panel.

00:51:19.230 --> 00:51:21.220
And I just, I didn't even guess.

00:51:21.220 --> 00:51:25.500
I knew that we had hooked up the thing,
but I didn't know that

00:51:25.500 --> 00:51:29.210
PowerPoint was using the standard

00:51:29.630 --> 00:51:32.530
Standard Color APIs in Carbon,
which is GetColor.

00:51:32.530 --> 00:51:35.360
So what in fact has happened
is Carbon currently,

00:51:35.430 --> 00:51:38.380
for its GetColor APIs,
uses the Cocoa Color panel.

00:51:38.380 --> 00:51:39.700
And it uses it modally.

00:51:39.910 --> 00:51:42.730
So the color panel had to
learn how to work modally.

00:51:42.820 --> 00:51:45.540
In addition, the font panel,
Carbon also uses the

00:51:45.630 --> 00:51:46.970
Cocoa font panel now.

00:51:46.970 --> 00:51:50.820
And that one there's new APIs for,
because the existing Carbon font

00:51:50.820 --> 00:51:52.820
APIs are all in terms of the menus.

00:51:52.830 --> 00:51:56.180
So there's new APIs which,
once Carbon developers adopt,

00:51:56.230 --> 00:51:58.730
they will be able to use the Cocoa font.

00:51:59.550 --> 00:52:02.000
the Cocoa FOD panel.

00:52:02.110 --> 00:52:04.310
To do this integration,

00:52:05.500 --> 00:52:08.260
These two APIs,
which actually I think were there before,

00:52:08.380 --> 00:52:11.060
but these two APIs now
have a lot more smarts.

00:52:11.140 --> 00:52:14.500
You can create an NSWindow around a
CarbonWindow with initWithWindowRef.

00:52:14.530 --> 00:52:17.000
WindowRef is the Carbon way
to refer to a window.

00:52:17.010 --> 00:52:19.630
Once you do this,
you can now start treating that

00:52:19.870 --> 00:52:22.100
CarbonWindow as if it was a CocoaWindow.

00:52:22.120 --> 00:52:24.110
In addition,
you can return a CarbonWindow

00:52:24.110 --> 00:52:25.700
from an existing CocoaWindow.

00:52:25.700 --> 00:52:27.890
Obviously, in the first case,
if you provide the WindowRef,

00:52:27.890 --> 00:52:28.920
that's what you'll get back.

00:52:29.170 --> 00:52:32.100
But if you have some
arbitrary CocoaWindow,

00:52:32.100 --> 00:52:34.340
you can call this,
and it will create a WindowRef

00:52:34.490 --> 00:52:35.700
and return it to you.

00:52:35.700 --> 00:52:38.010
And then you can start
making Carbon calls on that,

00:52:38.010 --> 00:52:40.100
or you can pass it to Carbon subsystems.

00:52:40.100 --> 00:52:42.080
And if you need to interact
with Carbon subsystems,

00:52:42.170 --> 00:52:46.000
probably the thing you want to do is
start handling events via CarbonEvents

00:52:46.200 --> 00:52:48.950
and learn about CarbonEvents.

00:52:50.530 --> 00:53:00.100
To load Cocoa bundles in Carbon apps,
you would load the bundle with CFBundle.

00:53:00.100 --> 00:53:03.240
One thing you need to assure
is if the Carbon app has not

00:53:03.240 --> 00:53:07.130
linked against Cocoa at all,
you need to call NSApplicationLoad to

00:53:07.130 --> 00:53:10.400
initialize the Cocoa application stack.

00:53:10.610 --> 00:53:13.400
This can be called either from the
bundle or from the application.

00:53:13.460 --> 00:53:17.400
Where it's called depends on
which one is the one who knows.

00:53:17.400 --> 00:53:19.810
For instance,
if you're writing a Cocoa bundle

00:53:19.880 --> 00:53:22.720
to work in a Carbon application,
and the Carbon application is an

00:53:22.780 --> 00:53:26.400
unsuspecting application like Photoshop,
you probably put this call in your

00:53:26.400 --> 00:53:29.400
bundle because you know you want to
work in the context of Carbon app.

00:53:29.400 --> 00:53:31.740
Or vice versa,
maybe there's a Carbon app that

00:53:31.740 --> 00:53:33.690
wants to use existing Cocoa bundles.

00:53:33.730 --> 00:53:36.800
For instance, a Carbon app wants to
use Cocoa screensavers,

00:53:36.840 --> 00:53:40.400
and the Carbon app would be
responsible for calling this function.

00:53:42.890 --> 00:53:44.350
Quick note about NSPaceBoard.

00:53:44.620 --> 00:53:47.200
This was a frequently requested feature.

00:53:47.200 --> 00:53:50.020
There's now a new data type,
the vCard/Pboard type.

00:53:50.020 --> 00:53:54.330
So if your app deals in vCards,
deals in people trade or whatever,

00:53:54.630 --> 00:53:58.630
you can now use this as a standard way to
trade vCard information with other apps.

00:53:58.950 --> 00:54:02.210
But more interestingly,
we have AddressBook.framework,

00:54:02.330 --> 00:54:05.940
a brand new public framework which
has Objective-C Cocoa APIs to

00:54:05.940 --> 00:54:09.290
get to that underlying people
information that Scott and

00:54:09.390 --> 00:54:11.800
Steve were talking about yesterday.

00:54:11.800 --> 00:54:14.290
So this is,
there are a bunch of AD classes

00:54:14.350 --> 00:54:17.680
and a bunch of good APIs and
you can hear all about this in

00:54:17.680 --> 00:54:19.800
the AddressBook framework talk.

00:54:21.290 --> 00:54:22.490
Accessibility.

00:54:22.490 --> 00:54:25.920
You saw demos of this yesterday.

00:54:25.990 --> 00:54:33.670
This is to allow writing
assistive applications.

00:54:33.670 --> 00:54:33.670
Assistive applications are these

00:54:33.770 --> 00:54:36.830
Applications that run outside
of other applications,

00:54:36.830 --> 00:54:39.680
but that either control those
applications or get more information

00:54:39.790 --> 00:54:41.350
to them to communicate to the user.

00:54:41.440 --> 00:54:44.340
The screen reader you saw
was an example of that.

00:54:44.410 --> 00:54:47.730
Or alternate input devices,
devices that are way beyond the

00:54:47.730 --> 00:54:52.130
simple keyboard and mouse interface,
ones that are really radically different.

00:54:52.230 --> 00:54:57.050
These use the accessibility
features to provide users access

00:54:57.390 --> 00:55:00.000
to all the other applications.

00:55:00.080 --> 00:55:03.430
There are two sets of APIs here.

00:55:03.820 --> 00:55:04.980
There are actually three.

00:55:05.000 --> 00:55:07.420
The one API is the C APIs,
which the assistive

00:55:07.420 --> 00:55:08.890
application creator uses.

00:55:09.040 --> 00:55:13.440
The screen reader or the alternate
input device would use these C APIs.

00:55:13.540 --> 00:55:15.880
Most of you probably won't be
writing assistive applications,

00:55:15.900 --> 00:55:19.740
but it doesn't mark
the opportunity there.

00:55:19.830 --> 00:55:21.930
These are the C APIs like this.

00:55:22.270 --> 00:55:25.690
These C APIs in turn know how
to talk to Cocoa or Carbon.

00:55:25.790 --> 00:55:28.490
There are Cocoa APIs,
which you are probably

00:55:28.620 --> 00:55:30.000
more interested in.

00:55:30.000 --> 00:55:34.620
for providing accessibility
features to these apps.

00:55:35.650 --> 00:55:39.060
The way this works is UI elements
in Cocoa applications implement this

00:55:39.060 --> 00:55:42.890
informal protocol called NSAccessibility
and they just have to implement a

00:55:42.890 --> 00:55:45.600
few methods on their UI elements.

00:55:45.870 --> 00:55:53.610
This API basically presents
the hierarchy of objects:

00:55:53.620 --> 00:55:54.600
NSApplication, Windows,
Views inside them, Controls, etc.

00:55:54.600 --> 00:55:56.600
as a hierarchy of these UI elements.

00:55:56.760 --> 00:56:00.120
Note that built-in controls
in Cocoa implement this and in

00:56:00.120 --> 00:56:03.600
fact many subclasses you guys
create will also just work.

00:56:03.820 --> 00:56:07.470
But if you have some really wacky
subclasses or you create some

00:56:07.470 --> 00:56:10.600
UI element totally from scratch,
you might want to look at this

00:56:10.600 --> 00:56:13.600
accessibility protocol to see
what it takes to implement that.

00:56:13.750 --> 00:56:16.850
Because just by implementing that your
app will be speakable and drivable

00:56:16.850 --> 00:56:18.600
by these assistive applications.

00:56:18.850 --> 00:56:21.690
There's a lot more details of
this in the Cocoa Controls and

00:56:21.690 --> 00:56:23.600
Cocoa Accessibility on Thursday.

00:56:24.640 --> 00:56:26.140
Scripting.

00:56:26.390 --> 00:56:31.990
We've added a lot of nifty features to
scripting as well and a lot of bug fixes.

00:56:32.090 --> 00:56:34.500
NSAppleScript is probably the
most interesting thing there.

00:56:34.500 --> 00:56:36.540
It's a new class which
allows you to load,

00:56:36.690 --> 00:56:39.890
compile,
and execute Apple scripts of any format.

00:56:40.050 --> 00:56:45.210
It also even allows you to get back
pretty printed scripts in RTF so you

00:56:45.210 --> 00:56:49.500
can display them in your application if
need be and let the user deal with them.

00:56:49.630 --> 00:56:51.940
There's also automatic support
for properties property,

00:56:51.940 --> 00:56:54.010
better conversions between
various data types,

00:56:54.130 --> 00:56:56.770
and there's a whole talk for
Cocoa scripting where Mark will talk

00:56:56.820 --> 00:57:02.130
about scripting in general and the
changes we've introduced in Jaguar.

00:57:02.780 --> 00:57:05.550
So that's really all I have to say.

00:57:05.550 --> 00:57:10.260
Now, one thing to note is that the Jaguar
release notes on your CD are current.

00:57:10.260 --> 00:57:12.330
So they do include these
changes we've talked about.

00:57:12.460 --> 00:57:15.260
They also include many more changes
we haven't talked about here.

00:57:15.400 --> 00:57:20.080
Also note that not all the
changes we've talked about are

00:57:20.080 --> 00:57:23.400
necessarily in the header files yet.

00:57:23.560 --> 00:57:25.260
I mean, many are, but some aren't.

00:57:25.330 --> 00:57:27.940
And also,
some of the things we talked about

00:57:27.940 --> 00:57:29.830
might change further before Jaguar.

00:57:29.960 --> 00:57:33.100
Because after all, we still have a few
months to ship Jaguar,

00:57:33.100 --> 00:57:35.910
and we're still doing
engineering on this stuff.

00:57:36.590 --> 00:57:39.560
So anyway, these two files,
apt-get.html and foundation.html,

00:57:39.560 --> 00:57:41.440
have a lot of information.

00:57:41.600 --> 00:57:47.690
I also want to point out one more thing
in regards to what's new in Cocoa.

00:57:47.930 --> 00:57:50.390
As you know,
Apple is delivering Cocoa and here

00:57:50.490 --> 00:57:53.800
we are telling you about all the
enhancements we're doing in Cocoa.

00:57:54.130 --> 00:57:55.460
There's a lot of stuff.

00:57:55.660 --> 00:58:00.290
But one additional thing to note
is that Apple is also delivering

00:58:00.290 --> 00:58:01.850
applications that use Cocoa.

00:58:01.990 --> 00:58:04.800
They're the old favorites:
Project Builder, Interface Builder,

00:58:04.800 --> 00:58:07.340
you know and you love them, hopefully.

00:58:07.440 --> 00:58:12.230
They're the recent favorites: iDVD2,
iPhoto, those are Cocoa applications.

00:58:12.370 --> 00:58:15.700
And one thing you might not realize
is the apps Steve showed yesterday,

00:58:15.780 --> 00:58:19.970
Address Book, Sherlock 3, and iChat,
those are all Cocoa applications as well.

00:58:20.060 --> 00:58:24.090
And for all new applications,
Apple is always seriously considering

00:58:24.320 --> 00:58:27.790
Cocoa as the way to deliver those
to you and to all the users.

00:58:28.380 --> 00:58:30.300
Okay, whoop!

00:58:30.490 --> 00:58:31.810
Documentation.

00:58:31.910 --> 00:58:33.660
If you weren't at the
Cocoa intro talk yesterday,

00:58:33.660 --> 00:58:39.740
one exciting documentation announcement
from Matt Rolofson was that the

00:58:39.940 --> 00:58:43.200
AppKit and Foundation reference
will be available in printed

00:58:43.200 --> 00:58:45.260
form in summer or late summer.

00:58:45.300 --> 00:58:47.020
Anyway,
look for that in your ADC mailings.

00:58:47.040 --> 00:58:50.420
I think that's very exciting for
those of us who still like to look

00:58:50.660 --> 00:58:54.390
through books and papers and so on
and can't deal with too many windows

00:58:54.510 --> 00:58:56.150
on our screen at the same time.

00:58:56.300 --> 00:58:59.620
There's more information there,
the Learning Cocoa book and the new

00:58:59.620 --> 00:59:02.300
building applications and the website,
clearly.

00:59:02.300 --> 00:59:05.210
Here's a roadmap of the
various Cocoa talks.

00:59:05.270 --> 00:59:10.300
The API techniques will go into some of
the not-so-subtle and subtle API issues,

00:59:10.300 --> 00:59:12.300
design techniques, etc.

00:59:12.370 --> 00:59:15.300
Scripting, controls, accessibility,
I already talked about those.

00:59:15.300 --> 00:59:17.620
Drawing and text,
these are all overviews of

00:59:17.920 --> 00:59:20.730
these Cocoa technologies,
touching upon some of the new things

00:59:20.730 --> 00:59:22.300
that have also happened recently.

00:59:22.300 --> 00:59:24.300
In addition, earlier you heard about
the new Cocoa tools.

00:59:24.960 --> 00:59:28.290
Earlier you heard about
the Rendezvous stuff.

00:59:28.290 --> 00:59:31.190
You can go to the CF Network talk
or Zero Configuration Networking

00:59:31.300 --> 00:59:36.300
to hear more about how the
Rendezvous stuff is implemented.

00:59:36.300 --> 00:59:38.300
Address Book Frameworks is on Friday.

00:59:38.300 --> 00:59:40.300
That's the new address book APIs.

00:59:40.300 --> 00:59:44.090
And there's the Cocoa feedback
session for those of you

00:59:44.090 --> 00:59:46.300
who are here Friday at 5pm.

00:59:46.300 --> 00:59:48.300
Hope to see you there.

00:59:48.300 --> 00:59:51.180
And I'd like to invite Heather Hickman,
the Cocoa Technology Manager,

00:59:51.180 --> 00:59:52.300
on stage to run the QA.

00:59:52.300 --> 00:59:54.360
on stage to run the Q&A.
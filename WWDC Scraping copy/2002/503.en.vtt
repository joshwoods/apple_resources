WEBVTT

00:00:01.300 --> 00:00:04.000
Ladies and gentlemen,
please welcome graphics

00:00:04.000 --> 00:00:07.590
and imaging evangelist,
Travis Brown.

00:00:10.090 --> 00:00:11.470
Good afternoon, everyone.

00:00:11.590 --> 00:00:14.340
Welcome to session 503,
Exploring the Quartz Compositor.

00:00:14.340 --> 00:00:19.400
We're really excited about being
able to tell you about new compositor

00:00:19.400 --> 00:00:21.100
technology such as Quartz Xtreme.

00:00:21.100 --> 00:00:24.160
But more importantly,
we're really excited to be able

00:00:24.220 --> 00:00:27.580
to sort of begin to articulate
why Mac OS X's visual pipeline

00:00:27.580 --> 00:00:29.230
is organized the way it is.

00:00:29.300 --> 00:00:31.500
Over the past year,
a lot of developers have

00:00:31.510 --> 00:00:34.800
expressed concerns about getting
their pixels to the screen.

00:00:34.800 --> 00:00:38.750
It wasn't readily apparent why we had
architected the system the way it was.

00:00:38.900 --> 00:00:43.560
But hopefully, in yesterday's keynote,
it sort of became clear that we're

00:00:43.560 --> 00:00:47.300
doing some very innovative things
with regards to how we approach

00:00:47.300 --> 00:00:49.250
graphics acceleration on the platform.

00:00:49.300 --> 00:00:53.600
And the fact that Quartz Xtreme
is able to accelerate 2D content,

00:00:53.600 --> 00:00:58.890
3D content, and video and accelerate them
seamlessly and with minimal CPU overhead

00:00:58.890 --> 00:01:00.590
because it fully leverages the GPU.

00:01:00.600 --> 00:01:03.190
So this is what we're going to be
talking about in today's session.

00:01:03.200 --> 00:01:04.700
But one thing I want
to make really clear.

00:01:04.700 --> 00:01:07.140
That's a point of confusion just
on the early buzz that we've seen

00:01:07.160 --> 00:01:08.660
that Quartz Xtreme has generated.

00:01:08.700 --> 00:01:13.100
Is that even though Quartz Xtreme is
a hardware accelerated architecture,

00:01:13.100 --> 00:01:16.460
we still have been working and
optimizing the existing Quartz

00:01:16.600 --> 00:01:20.800
Compositor architecture that we've had in
the system since we shipped Mac OS 10.0.

00:01:20.800 --> 00:01:23.330
So that's a good story for
all our customers who are

00:01:23.330 --> 00:01:24.900
going to be running Jaguar.

00:01:24.900 --> 00:01:26.270
They're going to get
improved performance.

00:01:26.400 --> 00:01:27.570
And we're going to talk about that today.

00:01:27.600 --> 00:01:30.480
But for customers with the
right hardware in their systems,

00:01:30.510 --> 00:01:32.790
we're going to fully leverage
that hardware to give them the

00:01:32.930 --> 00:01:34.600
best possible graphics experience.

00:01:34.600 --> 00:01:37.790
Now to take you further and
tell you more about this,

00:01:37.800 --> 00:01:40.430
I want to welcome Peter Graffagnino,
Director of Graphics and

00:01:40.430 --> 00:01:41.600
Imaging Engineering to stage.

00:01:41.600 --> 00:01:42.590
Thank you.

00:01:42.600 --> 00:01:44.600
Thanks, Travis.

00:01:44.600 --> 00:01:46.590
Hi, everybody.

00:01:47.800 --> 00:01:52.040
Welcome to our session on Network Server?

00:01:52.040 --> 00:01:54.260
No, I don't think so.

00:01:54.330 --> 00:01:56.560
Exploring the Quartz Compositor.

00:01:56.560 --> 00:01:57.700
My name is Peter Graffagnino.

00:01:57.700 --> 00:02:01.470
I manage the graphics and
imaging group at Apple.

00:02:01.630 --> 00:02:05.720
And what we're going to do today
is give you kind of a-- I'll

00:02:05.720 --> 00:02:07.990
do some introduction stuff,
and then I'm going to have a

00:02:08.010 --> 00:02:12.210
couple of the engineers who worked
on the overall architecture and

00:02:12.210 --> 00:02:17.640
the OpenGL implementation come
up and talk you through how we do

00:02:17.640 --> 00:02:22.700
the windowing system on OS X and
how we accelerate it with OpenGL.

00:02:23.680 --> 00:02:24.930
So some background comments.

00:02:25.040 --> 00:02:28.400
First of all, you've seen the
architecture diagram before.

00:02:28.420 --> 00:02:32.530
We have three basic drawing APIs that
people get to the screen with.

00:02:32.630 --> 00:02:37.940
We have Quartz, Quartz 2D for 2D drawing,
OpenGL for 3D,

00:02:37.960 --> 00:02:42.540
and QuickTime for video multimedia.

00:02:42.950 --> 00:02:48.450
And the Quartz Compositor sits
underneath those APIs and blends

00:02:48.450 --> 00:02:53.400
the content from those APIs onto the
screen to present it to the user.

00:02:53.590 --> 00:02:56.900
So what we've really done is
taking the windowing system,

00:02:56.910 --> 00:02:59.880
which we call the Quartz Compositor,
and made it orthogonal to any

00:02:59.880 --> 00:03:01.400
of the drawing models you have.

00:03:01.400 --> 00:03:06.500
So a new drawing model could come along,
for example, and we could composite that

00:03:06.500 --> 00:03:09.660
into the desktop just the
way we do everything else.

00:03:09.980 --> 00:03:13.090
So I think it's a really good thing
in OS X that we clearly separated

00:03:13.420 --> 00:03:16.710
drawing APIs from window presentation.

00:03:16.770 --> 00:03:19.010
And this is really not a new idea.

00:03:19.140 --> 00:03:22.850
The computer graphics industry for a
while has been compositing together

00:03:23.270 --> 00:03:25.860
the results of different applications.

00:03:25.860 --> 00:03:28.940
In the old days, you had, you know,
one program could do a sphere,

00:03:29.080 --> 00:03:31.800
another program could do fractal terrain,
and you didn't want to

00:03:31.800 --> 00:03:33.060
run them all every frame.

00:03:33.060 --> 00:03:34.630
So you would, you know,
if you had a bug in your

00:03:34.710 --> 00:03:37.200
fractal terrain renderer,
you wouldn't have to run your

00:03:37.200 --> 00:03:39.140
sphere renderer every frame again.

00:03:39.330 --> 00:03:43.200
And so this idea of sort of caching
results and being able to composite

00:03:43.200 --> 00:03:49.440
things together was developed in this
1984 SIGGRAPH paper by Porter and Duff,

00:03:49.450 --> 00:03:51.640
where they introduced the
alpha channel and the whole

00:03:51.640 --> 00:03:53.480
compositing algebra concept.

00:03:53.480 --> 00:03:57.000
And what we're doing is just using
that on the display in real time

00:03:57.070 --> 00:04:00.790
to create the desktop for Mac OS X.

00:04:01.000 --> 00:05:02.300
[Transcript missing]

00:05:05.810 --> 00:05:08.420
So this allows us to create
a fully composited desktop

00:05:08.490 --> 00:05:10.660
experience as you see here.

00:05:10.660 --> 00:05:14.800
We've got accelerated 3D
in the lower left corner.

00:05:14.800 --> 00:05:16.920
We've got a demo from NVIDIA.

00:05:17.130 --> 00:05:21.600
You know,
the ubiquitous transparent terminal,

00:05:21.600 --> 00:05:24.650
which always goes over good at WWDC.

00:05:24.750 --> 00:05:28.560
And the volume control,
you can see it composited into the scene.

00:05:28.710 --> 00:05:31.970
The transparent clock and QuickTime,
2D PDF,

00:05:32.120 --> 00:05:33.960
everything being blended together.

00:05:33.960 --> 00:05:36.460
Nice anti-aliased icons on the dock.

00:05:36.640 --> 00:05:38.820
So it really kind of ups
the production values,

00:05:38.820 --> 00:05:43.710
if you will, of the desktop display
compositing everything together.

00:05:44.820 --> 00:05:47.390
And with that,
I'm going to turn it over to Ralph,

00:05:47.390 --> 00:05:50.310
who's going to go in more
detail about the general

00:05:50.470 --> 00:05:52.740
compositing architecture on OS X.

00:05:52.860 --> 00:05:54.740
Ralph?

00:05:58.000 --> 00:06:03.500
[Transcript missing]

00:06:08.230 --> 00:06:11.790
So as Peter said,
the Quartz Compositor is the piece that

00:06:11.920 --> 00:06:15.930
takes the content provided by all the
applications and mixes them together to

00:06:15.930 --> 00:06:17.680
produce the final on-screen presentation.

00:06:17.720 --> 00:06:21.120
And the Quartz Compositor
in our implementation has

00:06:21.120 --> 00:06:23.160
quite a number of features.

00:06:23.160 --> 00:06:28.620
It can do transparency, as you know,
from menus and volume control.

00:06:28.620 --> 00:06:29.680
It can do drop shadows.

00:06:29.680 --> 00:06:32.570
It can scale content,
like you see that in the dock,

00:06:32.650 --> 00:06:36.660
where the dock icons are actually
windows that have a fixed size.

00:06:36.780 --> 00:06:40.700
And just in the Compositor themselves,
they get scaled to the destination size.

00:06:44.500 --> 00:06:46.700
This is how it works.

00:06:46.700 --> 00:06:50.320
When an application creates a window,
it sends a message to a

00:06:50.320 --> 00:06:52.240
process running on OS X.

00:06:52.240 --> 00:06:56.650
That process, if you use TOP or PS,
you will see it has the

00:06:56.680 --> 00:07:00.200
name of Window Manager,
which is kind of pedestrian.

00:07:00.200 --> 00:07:04.230
It contains the Quartz
Compositing Engine.

00:07:04.240 --> 00:07:07.180
The message goes over to
the Quartz Compositor,

00:07:07.180 --> 00:07:11.810
and the Quartz Compositor allocates
a buffer to contain the content

00:07:11.940 --> 00:07:14.450
that the application will draw on.

00:07:14.500 --> 00:07:20.040
That piece of memory is then mapped back
into the application's address space.

00:07:20.040 --> 00:07:26.800
So both the application as the Quartz
Compositor have access to these bits.

00:07:27.050 --> 00:07:29.440
Then the application draws
something into these bits.

00:07:29.460 --> 00:07:32.400
You're using various
methods like Quartz 2D,

00:07:32.480 --> 00:07:35.760
Quick Draw, QuickTime, or whatever.

00:07:36.210 --> 00:07:39.290
At one point, the application decides,
now it's time to present

00:07:39.290 --> 00:07:40.940
these final results on-screen.

00:07:40.940 --> 00:07:42.860
So it sends another message
to Quartz Compositor,

00:07:42.860 --> 00:07:45.050
which says, flush this.

00:07:45.170 --> 00:07:49.600
And Quartz Compositor then the
whole machinery kicks in that does

00:07:49.600 --> 00:07:51.280
the transparency and whatever.

00:07:51.390 --> 00:07:53.980
So if there is translucent
content on top of your window,

00:07:54.250 --> 00:07:58.000
at that point, these two,
the content of the translucent

00:07:58.000 --> 00:08:00.220
window and your window get combined.

00:08:01.710 --> 00:08:04.630
Okay, so, word about flushing.

00:08:04.640 --> 00:08:09.300
For the most part,
as an application programmer,

00:08:09.300 --> 00:08:12.660
you don't really have
to worry about that.

00:08:12.740 --> 00:08:15.940
Cocoa and Carbon both
take care of you for that.

00:08:15.980 --> 00:08:20.510
What's essentially
happening in the event loop,

00:08:20.580 --> 00:08:24.700
the event comes in,
it gets distributed to whichever

00:08:24.700 --> 00:08:27.620
object needs to respond to events,
and when the control

00:08:27.830 --> 00:08:30.960
returns to the event loop,
these frameworks will

00:08:31.040 --> 00:08:33.420
essentially call flush for all
the drawing that has happened.

00:08:33.500 --> 00:08:37.490
Every now and then,
you will have to call flush yourself.

00:08:37.500 --> 00:08:39.640
For example, when...

00:08:41.190 --> 00:08:45.560
Your drawing is very complex,
and you would like to give feedback to

00:08:45.660 --> 00:08:48.900
the user by showing intermediate results.

00:08:49.100 --> 00:08:52.920
So, you could call flush every
now and then in between to,

00:08:52.920 --> 00:08:55.050
you know,
every second or so to show that there's

00:08:55.050 --> 00:08:57.470
still something going on and the
application is still working on it.

00:08:57.500 --> 00:08:58.540
Okay.

00:08:58.540 --> 00:09:01.220
So, usually, however,
we are more interested

00:09:01.220 --> 00:09:04.520
in flushing rates that,
you know, are somewhere close to the

00:09:04.630 --> 00:09:07.580
display refresh so that the
user experience is very smooth

00:09:07.650 --> 00:09:11.580
and everything looks like it's,
you know, a physical object and whatever.

00:09:12.460 --> 00:09:15.560
So, to achieve that,
flushing is actually synced

00:09:15.560 --> 00:09:17.240
to the display refresh.

00:09:17.240 --> 00:09:21.110
So, if you have a CRT,
this means the flush will happen in

00:09:21.110 --> 00:09:25.900
a way that the entire update area
will appear on screen in one piece.

00:09:25.960 --> 00:09:28.400
So, there's not,
the video beam will not cut through

00:09:28.410 --> 00:09:30.190
it while it is refreshing the cube.

00:09:30.200 --> 00:09:33.100
Similarly, LCDs have a refresh rate, too.

00:09:33.100 --> 00:09:36.060
So, they don't have a beam,
but there's still a rate at which the

00:09:36.060 --> 00:09:38.030
frames go over the wire to the display.

00:09:38.040 --> 00:09:41.960
So, flushing is enforced to be synced.

00:09:42.460 --> 00:09:42.900
So, if you have a CRT,
you can see that the screen is

00:09:42.900 --> 00:09:43.300
now flashing to the display.

00:09:43.300 --> 00:09:45.720
However,
from the application's perspective,

00:09:45.740 --> 00:09:48.130
flushing is asynchronous,
which means when the

00:09:48.130 --> 00:09:51.390
application calls flush,
the control immediately returns to the

00:09:51.390 --> 00:09:55.360
application because it really just sent
this message over to the other process,

00:09:55.360 --> 00:09:57.120
which then does its thing.

00:09:57.120 --> 00:10:00.010
So, in...

00:10:02.300 --> 00:10:07.480
Since Mac OS 10.0,
flushing has been asynchronous,

00:10:07.610 --> 00:10:11.360
and that's a gain, for example,
if you have a dual processor machine.

00:10:11.360 --> 00:10:14.710
Because then, the second processor will
essentially run the window manager,

00:10:14.710 --> 00:10:17.150
which does the flush,
while the first processor is

00:10:17.150 --> 00:10:20.510
still available for your program
to do whatever it needs to do.

00:10:20.520 --> 00:10:23.560
In the case of Quartz Extreme,
flushing is actually

00:10:23.950 --> 00:10:26.160
asynchronous in a different way.

00:10:26.160 --> 00:10:29.770
Because in Quartz Extreme,
the bits are no longer pushed by the

00:10:29.770 --> 00:10:31.930
CPU over the bus to the video card.

00:10:31.960 --> 00:10:36.300
It's just, it tells the video card, okay,
here are the bits, DMA them over.

00:10:36.300 --> 00:10:39.920
So, in the case of two CPUs,
then you actually have two CPUs

00:10:39.920 --> 00:10:41.980
available during the flush.

00:10:41.980 --> 00:10:42.560
Okay.

00:10:45.660 --> 00:10:50.020
So that allows you to do an
interesting optimization.

00:10:50.240 --> 00:10:54.810
So if you would produce a frame
and then do the flush and then

00:10:54.810 --> 00:10:57.540
produce the next frame and the
flush and do them in sequence,

00:10:57.650 --> 00:11:00.480
well, it will take a certain amount
of time to do the flush.

00:11:00.610 --> 00:11:03.960
Because it is asynchronous,
it allows you to--

00:11:04.300 --> 00:11:08.260
Prepare the next frame that you want to
present while the flush is in progress.

00:11:08.260 --> 00:11:13.360
So, in the best case,
preparing the frame and flushing

00:11:13.360 --> 00:11:15.540
the frame would be exactly
the same amount of time.

00:11:15.540 --> 00:11:17.820
Then you get a 2x speed
improvement out of this.

00:11:17.820 --> 00:11:24.440
So, the important thing here is,
in most cases, the application frameworks

00:11:24.440 --> 00:11:25.960
will take care of that for you.

00:11:26.100 --> 00:11:30.120
Because typical scenario is,
event comes in and you update

00:11:30.120 --> 00:11:34.700
your model of whatever it is the
user is modifying with that event.

00:11:34.740 --> 00:11:39.170
And at the end, you redraw,
you update the screen to reflect

00:11:39.180 --> 00:11:41.370
the change in that model.

00:11:41.380 --> 00:11:45.770
So, if you repeat that,
then event comes in and update the

00:11:45.800 --> 00:11:51.070
model can run in parallel with the
flushing of the previous frame.

00:11:52.810 --> 00:11:56.070
So if your model is really trivial,
like you have a little rubber band,

00:11:56.160 --> 00:11:58.480
so the model is really
just updating a rectangle,

00:11:58.480 --> 00:11:59.730
then you will not get much out of it.

00:11:59.900 --> 00:12:03.120
But if you're doing some
reasonable amount of computation,

00:12:03.120 --> 00:12:05.240
you can get a nice speed
improvement by doing that.

00:12:06.060 --> 00:12:09.640
So the key message is here,
most of the time,

00:12:09.640 --> 00:12:10.840
this is automatic for you.

00:12:10.840 --> 00:12:14.240
It's really the only case where
you can actually spoil that is by,

00:12:14.250 --> 00:12:17.810
if the event comes in and
you immediately decide,

00:12:17.880 --> 00:12:21.020
well, let's draw this little
control over there first,

00:12:21.060 --> 00:12:23.640
and then go off and do
all the computation.

00:12:23.640 --> 00:12:25.640
Because as soon as you
hit the drawing surface,

00:12:25.640 --> 00:12:28.720
your application has to wait until
the flush has actually happened.

00:12:28.720 --> 00:12:33.340
So I will have a little
demo that shows that.

00:12:43.240 --> 00:12:48.010
Okay, so first of all in the
bottom right corner,

00:12:48.010 --> 00:12:51.800
I have a little frame rate counter
which measures how many frames come

00:12:51.800 --> 00:12:54.080
out of the Quartz compositing engine.

00:12:54.080 --> 00:12:56.910
So whatever I do,
you see the needle goes up

00:12:56.910 --> 00:13:00.920
and tells you the frame rate
of whatever it is I'm doing.

00:13:01.660 --> 00:13:04.840
So, let's turn this off.

00:13:04.840 --> 00:13:08.180
This little application does
quite a bit of computation,

00:13:08.180 --> 00:13:09.890
and it produces one frame after another.

00:13:09.900 --> 00:13:14.780
So, if I just start that, you see,
this computes a lot of

00:13:14.780 --> 00:13:16.510
floating point math.

00:13:16.680 --> 00:13:20.380
and we've seen it runs, you know,
45 frames per second.

00:13:20.380 --> 00:13:23.740
It peaks and then depending
on how far you zoom in,

00:13:23.740 --> 00:13:25.200
it will drop over time.

00:13:27.050 --> 00:13:30.050
This was the case of
the synchronous flush.

00:13:30.050 --> 00:13:33.400
And the way I implemented this is,
there's a timer which

00:13:33.540 --> 00:13:36.480
fires 60 times a second,
and I either compute the

00:13:36.480 --> 00:13:39.520
frame and then flush it,
or I draw a single pixel

00:13:39.520 --> 00:13:42.780
in the top left corner,
compute the frame, and then flush it.

00:13:42.780 --> 00:13:46.990
So drawing that single pixel will
exactly do what I mentioned before.

00:13:47.010 --> 00:13:49.830
It spoils that parallelism
you get for free.

00:13:50.510 --> 00:13:53.720
So when I actually remove
that single pixel call,

00:13:53.720 --> 00:13:59.460
you see the frame rate peaks at
almost 60 frames per second now.

00:13:59.460 --> 00:14:01.820
Okay.

00:14:01.820 --> 00:14:05.820
So that's it for the demo.

00:14:16.200 --> 00:14:20.780
So the important thing to notice there
is these frame rates I just showed,

00:14:20.780 --> 00:14:23.880
this is about the order of magnitudes
which we expect things to be.

00:14:23.890 --> 00:14:27.170
So I measured this
machine we're using here,

00:14:27.170 --> 00:14:30.260
and the flush for this machine and
this graphics card and this window

00:14:30.260 --> 00:14:32.450
size is about 9 milliseconds,
which is,

00:14:32.450 --> 00:14:36.890
if flushing were the only thing you do,
you get 110 frames per second.

00:14:37.810 --> 00:14:40.960
So that means if your
application produces less than,

00:14:40.990 --> 00:14:44.570
say, 20 frames per second,
then saving these 9 milliseconds is

00:14:44.650 --> 00:14:47.460
probably not going to be a big deal,
so really don't bother.

00:14:47.460 --> 00:14:52.330
And you probably have other
places where optimization time

00:14:52.330 --> 00:14:55.210
is better spent than doing that.

00:14:55.220 --> 00:14:58.880
But if you're trying to get a
really smooth user experience

00:14:58.880 --> 00:15:01.980
and you know you're in the 30
plus frames per second already,

00:15:01.980 --> 00:15:06.040
then taking care of this might give
you another 20 or something like that.

00:15:06.040 --> 00:15:06.800
Okay.

00:15:10.700 --> 00:15:15.460
Another feature of the Quartz Compositor
is that window buffers can be compressed.

00:15:15.460 --> 00:15:19.750
So, because every window has its buffer,
that can take up quite

00:15:19.800 --> 00:15:21.100
an amount of memory.

00:15:21.100 --> 00:15:24.940
And to take care of that,
there's a mechanism in Jaguar

00:15:24.940 --> 00:15:28.880
which allows window buffers to
get compressed when they are idle.

00:15:28.880 --> 00:15:32.650
So, idle means if a window hasn't been
touched by the application for,

00:15:32.650 --> 00:15:36.230
you know, 5 to 10 seconds or so,
in the background,

00:15:36.300 --> 00:15:39.440
the window server will go and
take the window buffer away from

00:15:39.440 --> 00:15:41.290
the application and compress it.

00:15:41.320 --> 00:15:45.090
Because typical windows have, you know,
a lot of white space and so on,

00:15:45.460 --> 00:15:46.730
compression ratios are fairly good.

00:15:46.790 --> 00:15:48.520
There's about 3 to 4x as typical.

00:15:50.660 --> 00:15:54.110
One neat feature about the Quartz
Compositor is damage repair can be

00:15:54.110 --> 00:15:58.250
done directly from compressed windows
without decompressing the entire thing.

00:15:58.260 --> 00:16:01.090
That means if, for example,
your Finder window has been

00:16:01.170 --> 00:16:04.820
compressed because it didn't do
anything in the recent few seconds,

00:16:04.820 --> 00:16:08.520
and you have a text edit window on top,
if you move that text edit window away,

00:16:08.520 --> 00:16:10.960
you reveal certain parts
of the Finder window,

00:16:10.960 --> 00:16:14.670
and if the Finder window is compressed,
we can decompress only the parts

00:16:14.670 --> 00:16:17.830
that have been revealed without
decompressing the entire thing.

00:16:18.770 --> 00:16:21.090
So the message to application
developers here is,

00:16:21.230 --> 00:16:23.640
well, if you don't do anything
with your window,

00:16:23.640 --> 00:16:26.840
well, don't draw in it,
and you get an additional

00:16:26.840 --> 00:16:28.750
nice memory and speed savings.

00:16:28.820 --> 00:16:30.000
Okay.

00:16:31.500 --> 00:16:34.390
The cool thing about this is it's
completely transparent to applications.

00:16:34.400 --> 00:16:37.400
There is absolutely nothing
you have to do about it.

00:16:37.490 --> 00:16:40.960
Essentially,
whenever a primitive is drawn,

00:16:41.030 --> 00:16:46.100
at the bottom end, the Windows Backing
Store lock is acquired.

00:16:46.180 --> 00:16:48.140
And at that point,
if the window is compressed,

00:16:48.140 --> 00:16:50.530
it will get decompressed
for the application.

00:16:50.530 --> 00:16:53.960
And you will never know this, hopefully.

00:16:57.990 --> 00:17:02.260
Another feature about the
Quartz Compositor is surfaces.

00:17:02.370 --> 00:17:04.800
So a window doesn't
only have a back buffer,

00:17:04.800 --> 00:17:07.900
it can have a number of
surfaces attached to it.

00:17:08.010 --> 00:17:10.060
Now,
a surface is just an additional buffer

00:17:10.060 --> 00:17:13.860
that typically lives in video RAM,
and it enables certain kinds

00:17:14.050 --> 00:17:16.010
of hardware acceleration.

00:17:16.320 --> 00:17:24.390
So, it is mainly used for OpenGL, DVD,
and for QuickTime playback.

00:17:24.770 --> 00:17:28.930
In that case, in OpenGL,
in the OpenGL case,

00:17:29.030 --> 00:17:34.060
the surface is essentially a piece
of VRAM where OpenGL can draw

00:17:34.180 --> 00:17:36.100
into it hardware accelerated.

00:17:36.190 --> 00:17:41.240
And in the case of DVD and QuickTime,
it's a YUV surface so that the conversion

00:17:41.240 --> 00:17:43.900
from YUV to RGB can be done in hardware.

00:17:43.980 --> 00:17:48.690
And this is essentially the key to
enable the seamless mixing of 3D,

00:17:48.690 --> 00:17:50.170
2D, and video.

00:17:51.970 --> 00:17:55.010
So here is the same
architecture diagram again,

00:17:55.150 --> 00:17:58.100
slightly expanded.

00:17:58.210 --> 00:18:01.650
In the software compositor case,
so that's the composite that is

00:18:01.650 --> 00:18:05.930
in 10.1 and this is in Jaguar,
if you don't have a graphics card

00:18:05.990 --> 00:18:08.970
that can support Quartz Extreme.

00:18:10.260 --> 00:18:13.820
You have applications drawing
either in the window backing store,

00:18:13.870 --> 00:18:15.730
which is in...

00:18:15.800 --> 00:18:32.200
[Transcript missing]

00:18:32.400 --> 00:18:45.200
[Transcript missing]

00:18:46.140 --> 00:18:52.020
Usually, essentially the message here is
there is no tax associated with

00:18:52.110 --> 00:18:55.240
the Quartz Compositor if you
don't do things like translucent

00:18:55.280 --> 00:18:58.210
terminals on top of your content.

00:19:00.100 --> 00:19:05.040
Okay,
so this is a look at what's going on,

00:19:05.040 --> 00:19:08.860
well, without going to extremes,
meaning if you don't have Quartz Extreme.

00:19:08.860 --> 00:19:11.420
So, blending is done with the CPU.

00:19:11.420 --> 00:19:15.200
So,
the Quartz Compositor contains a fairly

00:19:15.290 --> 00:19:21.570
hairy piece of code that can take an
arbitrary number of layers at the same

00:19:21.660 --> 00:19:24.340
time and produce an output blended pixel.

00:19:24.340 --> 00:19:26.690
So, it is, in a sense,
it is optimal in terms

00:19:26.690 --> 00:19:28.090
of memory bandwidth.

00:19:28.270 --> 00:19:31.900
So, every pixel that ends up
on-screen is read exactly once,

00:19:31.900 --> 00:19:36.210
and every pixel that needs to go
on-screen is written exactly once.

00:19:36.220 --> 00:19:38.480
And in the meantime,
there are no temporary

00:19:38.480 --> 00:19:40.010
buffers available at all.

00:19:40.020 --> 00:19:41.520
Okay.

00:19:43.710 --> 00:19:46.000
This code makes use of multiple CPUs.

00:19:46.140 --> 00:19:49.130
So if you have a dual CPU system,
then the screen update is

00:19:49.130 --> 00:19:54.280
actually sliced into two bands,
and each CPU works on one of them.

00:19:55.480 --> 00:19:58.400
There's also some degree
of hardware acceleration.

00:19:58.480 --> 00:20:00.780
For example,
when you move a window around

00:20:00.780 --> 00:20:04.410
and the center is opaque,
then that part is actually moved with

00:20:04.410 --> 00:20:06.480
the graphics card without using the CPU.

00:20:08.500 --> 00:20:13.060
and that new bullet should
actually be one further up as well.

00:20:13.060 --> 00:20:18.870
So in Jaguar, the entire Compositor is
tuned for the Velocity Engine.

00:20:18.880 --> 00:20:22.580
So you can easily say if you
don't have Quartz Extreme,

00:20:22.580 --> 00:20:27.400
every pixel on-screen that you have on
Jaguar went through the Velocity Engine.

00:20:27.400 --> 00:20:30.770
It's kind of an interesting
milestone to achieve that

00:20:30.790 --> 00:20:33.060
all the paths are vectorized.

00:20:33.820 --> 00:20:39.770
And that gives us about a factor of two
in reasonably complex areas and about

00:20:39.780 --> 00:20:42.470
a factor of four in very hairy areas.

00:20:42.520 --> 00:20:46.940
So in the case of five translucent
terminal windows on top of each other,

00:20:46.940 --> 00:20:50.410
you get about a 4X speed
improvement over 10.1.

00:20:50.440 --> 00:20:54.870
We also added 2D hardware
acceleration for scrolling.

00:20:54.880 --> 00:20:59.850
So how that is done,
it's actually just a...

00:21:00.480 --> 00:21:03.290
The Quartz Compositor has a
humongous amount of bookkeeping,

00:21:03.290 --> 00:21:06.260
essentially, to make sure that when
the application scrolls,

00:21:06.260 --> 00:21:08.410
and some time later the
application flushes,

00:21:08.410 --> 00:21:11.220
that at the time of the flush we
still remember which pieces we

00:21:11.230 --> 00:21:14.590
scrolled and can use the all-screen
move for moving these bits.

00:21:14.600 --> 00:21:18.360
That, again, at the bottom level,
has given us about a three-time

00:21:18.360 --> 00:21:21.360
speed improvement for
normal scrolling distances,

00:21:21.360 --> 00:21:24.350
like about two text lines
or something like that.

00:21:25.370 --> 00:21:30.160
And at the top end, we've seen, you know,
in text edit, about 30% or so,

00:21:30.160 --> 00:21:32.500
because a lot of other stuff is,
of course, going on in the system.

00:21:32.520 --> 00:21:34.120
Okay.

00:21:34.120 --> 00:21:38.660
So with that, I'll give it back to Peter.

00:21:45.900 --> 00:21:47.920
Okay,
so I'm going to talk for a few minutes

00:21:47.950 --> 00:21:53.090
about Quartz Extreme from a high level,
about kind of some of the

00:21:53.090 --> 00:21:55.970
motivations for why we did that,
and then Ken Dyke is going to come up

00:21:56.090 --> 00:22:00.920
and go through some of the gory details
and do all the fun demos for you.

00:22:00.920 --> 00:22:02.440
So why did we do this?

00:22:02.570 --> 00:22:06.870
Well, we knew that we were going to
be going down a path like this

00:22:06.870 --> 00:22:08.880
for quite a number of years now.

00:22:08.880 --> 00:22:11.820
It's been pretty obvious that
GPUs were getting more and more

00:22:12.210 --> 00:22:14.120
capable of doing things like this.

00:22:14.330 --> 00:22:18.080
And the model--so we went for
the model kind of before the

00:22:18.080 --> 00:22:19.560
GPUs were quite ready for it.

00:22:19.560 --> 00:22:21.070
And fortunately,
we had things like Velocity

00:22:21.080 --> 00:22:26.320
Engine and smart people like
Ralph who can make it work really

00:22:26.320 --> 00:22:29.420
well on existing architectures.

00:22:29.470 --> 00:22:31.280
But the model can be
computationally expensive,

00:22:31.290 --> 00:22:33.860
especially when you start having
to read pixels back over the

00:22:33.920 --> 00:22:35.380
bus in order to blend them.

00:22:35.470 --> 00:22:39.250
You know, if you're doing the translucent
volume control over DVD,

00:22:39.250 --> 00:22:41.380
for example, is one of the worst cases.

00:22:41.380 --> 00:22:42.420
In fact, in Puma,
we don't even have--we don't

00:22:42.420 --> 00:22:43.380
have--we don't have any of those.

00:22:43.380 --> 00:22:46.570
We don't--we can't spare
the CPU to do that,

00:22:46.570 --> 00:22:49.280
so we do it over a gray rectangle.

00:22:49.280 --> 00:22:53.120
So--and also, there's issues about,
you know, some concerns about us

00:22:53.120 --> 00:22:54.940
taking the frame buffer away.

00:22:54.940 --> 00:22:58.480
And we weren't really able to tell the
whole story of why we're going down

00:22:58.480 --> 00:23:00.340
this architecture until this year.

00:23:00.500 --> 00:23:03.460
So it's good to be able to talk
about Quartz Extreme and hopefully

00:23:03.460 --> 00:23:07.260
make you understand why we're
kind of moving in this direction

00:23:07.260 --> 00:23:09.610
for our graphics architecture.

00:23:10.030 --> 00:23:13.300
So Quartz Extreme is really
just an implementation of the

00:23:13.430 --> 00:23:15.390
Quartz Compositor on OpenGL.

00:23:15.480 --> 00:23:18.350
The desktop is really just a 3D scene.

00:23:18.440 --> 00:23:23.440
The nice thing about it is it removes
the transparency tax for video and 3D.

00:23:23.440 --> 00:23:25.700
Since everything is over
on the graphics card,

00:23:25.750 --> 00:23:28.360
if I have to mix the
volume control over DVD,

00:23:28.360 --> 00:23:33.410
it's just an extra blending layer,
and it's really not much extra work.

00:23:33.660 --> 00:23:35.040
It also frees up the CPU.

00:23:35.040 --> 00:23:39.360
The CPU's not involved in doing any
of the blending calculations and can

00:23:39.360 --> 00:23:44.360
do other things in your application
or for other users or whatever.

00:23:44.360 --> 00:23:47.940
And it allows us to kind of showcase
the GPU and the user interface.

00:23:47.940 --> 00:23:49.900
So there's a lot of
bandwidth in these cards,

00:23:49.920 --> 00:23:52.550
and I think over time we'll be
adding more and more sort of

00:23:52.550 --> 00:23:55.940
flourishes in the user interface,
and maybe on your high-end card,

00:23:55.940 --> 00:23:59.240
you get a little fancier window
animation or some extra effects.

00:23:59.310 --> 00:24:05.060
For the customers who spent the money,
why not entertain them a little bit more?

00:24:05.300 --> 00:24:08.140
So, and I think over time,
we've got a lot of headroom

00:24:08.140 --> 00:24:09.130
with this architecture.

00:24:09.140 --> 00:24:11.700
I think we're really going to be
able to do some dramatic things.

00:24:11.770 --> 00:24:15.020
And I think it's just sort of
the tip of the iceberg right now.

00:24:15.550 --> 00:24:19.260
To kind of motivate things even further,
I thought I'd talk about

00:24:19.730 --> 00:24:21.880
programmed I/O versus DMA.

00:24:22.310 --> 00:24:25.650
And in working with devices,
there are kind of two basic ways.

00:24:25.760 --> 00:24:28.500
Back to computer architecture 101.

00:24:28.600 --> 00:24:32.030
You know, there's programmed I/O,
where the CPU pushes data and

00:24:32.070 --> 00:24:36.590
commands to a relatively slow device,
and it's not necessarily the

00:24:36.600 --> 00:24:38.700
most efficient use of the CPU.

00:24:38.700 --> 00:24:42.000
A more complicated model but
more efficient model is to

00:24:42.000 --> 00:24:46.220
set up DMA for the device,
where the device can actually pull

00:24:46.220 --> 00:24:50.040
the data out of memory or commands
out of main memory that it might

00:24:50.040 --> 00:24:54.000
need and process that while the
CPU is free to do other things.

00:24:54.000 --> 00:24:55.850
And when it's done,
it can either interrupt the

00:24:55.900 --> 00:25:00.100
CPU or the CPU can wait,
depending upon what is appropriate.

00:25:00.100 --> 00:25:03.630
And so CPU drawing in the frame
buffer is really sort of just

00:25:03.720 --> 00:25:05.890
programmed I/O and not very efficient.

00:25:06.000 --> 00:25:08.000
I mean,
you think about your gigahertz CPU,

00:25:08.290 --> 00:25:12.210
talking over 100 megahertz I/O bus,
it's really not the best thing to be

00:25:12.220 --> 00:25:14.000
doing with the cycles on the machine.

00:25:14.100 --> 00:25:19.540
So that's why we're moving more and
more towards a DMA architecture.

00:25:19.620 --> 00:25:23.100
In fact, Quartz Extreme is
complete DMA architecture.

00:25:23.100 --> 00:25:27.170
All of the window textures
are pulled from the GPU rather

00:25:27.280 --> 00:25:29.540
being pushed by the CPU.

00:25:30.900 --> 00:25:34.660
The other important thing to kind of
keep in mind in all of this is the

00:25:34.660 --> 00:25:41.160
kind of evolution rates of CPUs versus
the evolution rates of GPUs right now.

00:25:41.200 --> 00:25:46.480
For example,
the traditional Moore's Law for CPUs is

00:25:46.480 --> 00:25:49.640
that performance doubles every 18 months,
and that's proved to be

00:25:49.640 --> 00:25:51.530
roughly true over the years.

00:25:51.560 --> 00:25:56.700
For GPUs, performance has been recently
doubling every six months,

00:25:56.700 --> 00:26:00.100
and one of the vendors talks
about the Moore's Law cube effect,

00:26:00.100 --> 00:26:04.290
where you're actually getting
three times the exponential growth,

00:26:04.540 --> 00:26:08.600
three times in the exponent,
because it's six months instead of 18.

00:26:08.600 --> 00:26:12.500
And another way to compare it
is in terms of transistor count,

00:26:12.500 --> 00:26:15.900
the G4 having about 10
million transistors,

00:26:15.900 --> 00:26:22.880
and the latest G4's 4Ti from Nvidia has
about 63 million transistors in it.

00:26:23.100 --> 00:26:25.480
So really,
you can see that there's just more and

00:26:25.480 --> 00:26:27.230
more logic being thrown into the problem.

00:26:27.300 --> 00:26:31.270
And one of the reasons is the GPU vendors
have an extra degree of freedom in

00:26:31.430 --> 00:26:35.900
that they have a lot of parallelism
in the problem they're trying to solve.

00:26:35.900 --> 00:26:37.700
You've got a lot of pixels on the screen.

00:26:37.700 --> 00:26:41.090
You need to do the same thing to
megabytes and megabytes of data.

00:26:41.270 --> 00:26:44.940
You can just replicate gates and
get lots of pipelines going at once.

00:26:45.440 --> 00:26:48.300
This is not really true for CPUs, which,
you know,

00:26:48.370 --> 00:26:52.030
may have 4K page sizes and are just sort
of nibbling at the memory instead of

00:26:52.030 --> 00:26:54.600
taking it in huge gulps like the GPU can.

00:26:54.600 --> 00:26:58.350
So it's clearly a curve we want to ride,
and we think all of you want to ride,

00:26:58.370 --> 00:27:01.390
too, is that GPU-- for things
that the GPU can do,

00:27:01.590 --> 00:27:04.810
let the GPU do it and do it fast.

00:27:05.510 --> 00:27:10.020
And we think this is the beginning of
kind of a new graphics platform for us.

00:27:10.120 --> 00:27:12.280
You know,
every day we have new ideas of the

00:27:12.280 --> 00:27:15.150
kinds of things we can do with this,
and I'm sure you guys will

00:27:15.160 --> 00:27:17.130
impress us with stuff,
too.

00:27:17.230 --> 00:27:20.400
It's really kind of a
next-generation windowing system.

00:27:20.610 --> 00:27:23.140
There are various hacks
out there that do,

00:27:23.150 --> 00:27:26.940
you know, transparent menus and
transparent terminals,

00:27:26.940 --> 00:27:28.680
but a lot of them are really just hacks.

00:27:28.800 --> 00:27:32.700
We wanted to do it right,
and we have a full compositing

00:27:32.700 --> 00:27:36.540
engine and a fully composited model,
as Ralph talked about.

00:27:36.550 --> 00:27:38.760
And we think that this is
kind of an inflection point,

00:27:38.760 --> 00:27:41.220
if you will,
in platform graphics in terms of really

00:27:41.220 --> 00:27:45.850
factoring out the windowed presentation
and the layer compositing for the desktop

00:27:45.960 --> 00:27:51.770
from the--whether you're doing 2D,
3D, or video, a really nice architecture

00:27:51.840 --> 00:27:56.000
that's gonna have a lot of
headroom as we move forward.

00:27:56.000 --> 00:27:57.740
And it's a combination
of a lot of things.

00:27:57.740 --> 00:28:01.750
There's obviously all the great work
the vendors are doing with GPUs and

00:28:01.750 --> 00:28:03.160
just making them more and more advanced.

00:28:03.160 --> 00:28:07.280
And some of the great architectural
work we've done in the OS to

00:28:07.330 --> 00:28:11.720
really treat the GPU as a--almost
as a traditional DMA device,

00:28:11.840 --> 00:28:16.430
but with very high bandwidth transfers
and getting the CPU disengaged

00:28:16.460 --> 00:28:20.690
from babysitting the device and
just letting it take the memory.

00:28:20.830 --> 00:28:22.660
The other nice thing
about Quartz Extreme,

00:28:22.660 --> 00:28:25.640
and if you've gone to-- well,
if you've gone to

00:28:25.710 --> 00:28:30.200
OpenGL early bird session,
you would have found this out,

00:28:30.300 --> 00:28:36.180
that all of the advances that we
do to--that--in OpenGL to enable

00:28:36.180 --> 00:28:40.410
Quartz Extreme are available
to the OpenGL programmer.

00:28:40.540 --> 00:28:44.920
So all of the extensions we've
done for FastDMA texturing,

00:28:44.920 --> 00:28:48.880
for synchronization with
NV Fence-- or sorry,

00:28:48.880 --> 00:28:52.120
with Apple Fence,
all of those things are available

00:28:52.120 --> 00:28:54.760
to you as a OpenGL writer.

00:28:54.760 --> 00:28:57.960
So we kind of made the bet that
the things we were gonna need

00:28:57.960 --> 00:29:03.080
to do to OpenGL to make it great
to support the windowing system,

00:29:03.080 --> 00:29:05.740
are just gonna be great things
to do to OpenGL in general,

00:29:05.740 --> 00:29:08.210
and I think that's
worked out pretty well.

00:29:08.900 --> 00:29:11.230
So with that,
I'm going to invite Ken Dyke up,

00:29:11.230 --> 00:29:14.780
who is going to take you through
the Quartz Xtreme implementation.

00:29:14.860 --> 00:29:15.280
Ken?

00:29:15.440 --> 00:29:16.170
Great.

00:29:16.180 --> 00:29:17.950
Thanks, Peter.

00:29:20.900 --> 00:29:26.280
All right, so I'm going to talk to you
guys a little bit about what's

00:29:26.280 --> 00:29:30.800
going on behind the scenes,
what is accelerated, what's not,

00:29:30.800 --> 00:29:33.540
and sort of how we pulled off some of it.

00:29:33.570 --> 00:29:35.820
There's been a lot of speculation
on the Web about what it does,

00:29:35.820 --> 00:29:38.980
what it doesn't do,
does it take all my VRAM, et cetera.

00:29:38.980 --> 00:29:43.520
Right now, what it does is it accelerates
all compositor operations.

00:29:43.520 --> 00:29:45.440
This is the type of stuff
that Ralph talked about,

00:29:45.800 --> 00:29:49.080
window warps, all of the transparency,
scaling effects,

00:29:49.080 --> 00:29:51.940
blending of drop shadows,
all the type of stuff you see

00:29:51.940 --> 00:29:55.770
in the Aqua interface is now
fully hardware accelerated.

00:29:55.900 --> 00:29:58.440
It doesn't accelerate
Quartz 2D or Quick Draw.

00:29:58.440 --> 00:30:02.230
That's all still basically being
done with the CPU right now.

00:30:02.700 --> 00:30:05.560
Now, the caveat to that is obviously we
can get those bits to the screen a

00:30:05.640 --> 00:30:07.740
lot faster than we used to be able to.

00:30:07.740 --> 00:30:10.300
We've done some measurements of this,
and right now we can usually get stuff

00:30:10.300 --> 00:30:13.690
from your window backing store after
it's been drawn up into video memory

00:30:13.690 --> 00:30:15.800
at about 400 megabytes per second.

00:30:15.940 --> 00:30:17.440
Now, you know,
a lot of people used to go,

00:30:17.440 --> 00:30:20.430
"I can write the fastest copy bits
routine in the world." I don't

00:30:20.430 --> 00:30:24.560
think you could get 400 megabytes
no matter how well you did.

00:30:24.820 --> 00:30:27.640
And, of course,
it's all implemented in OpenGL.

00:30:27.800 --> 00:30:29.660
So, why OpenGL?

00:30:29.780 --> 00:30:32.090
Well, 2D is sort of done, you know?

00:30:32.100 --> 00:30:36.660
It's -- nobody is -- nobody is doing
anything with it anymore in the GPUs.

00:30:36.790 --> 00:30:39.870
They sort of, like, all stalled out at
sort of the Quick Draw,

00:30:39.970 --> 00:30:42.860
GDI sort of level,
and that's where everything's, you know,

00:30:42.980 --> 00:30:43.170
done.

00:30:43.180 --> 00:30:47.770
You've got, you know, foreground color,
background color, fills, index support,

00:30:47.790 --> 00:30:50.400
and all that junk,
but it's not going anywhere anymore.

00:30:50.570 --> 00:30:54.180
So, 3D, on the other hand,
we've still got, you know,

00:30:54.270 --> 00:30:55.870
gigapixel fill rates coming.

00:30:56.040 --> 00:30:58.840
I forget what the quoted
numbers are in the GeForce 4,

00:30:58.840 --> 00:31:00.700
but they're insane.

00:31:01.010 --> 00:31:02.370
We're starting to get
lots of video memory,

00:31:02.370 --> 00:31:03.340
so it's not a big deal.

00:31:03.340 --> 00:31:06.880
If you want to get lots of window
backing stores cached in video memory,

00:31:06.880 --> 00:31:11.460
for example,
you can have DVD going and video and

00:31:11.460 --> 00:31:15.680
lots of 3D stuff all at the same time,
and it's not a big issue.

00:31:15.790 --> 00:31:18.740
The other thing is the GPUs are finally
getting good support for 2D data.

00:31:18.740 --> 00:31:21.620
Traditionally,
previous generation hardware

00:31:21.620 --> 00:31:22.020
could do 3D pretty well,
but there are a lot of

00:31:22.080 --> 00:31:23.140
things that are not.

00:31:23.340 --> 00:31:24.080
So, I think it's important
to keep that in mind.

00:31:24.080 --> 00:31:26.920
There are a lot of limitations,
and I'll get into those in a little bit,

00:31:27.050 --> 00:31:30.780
but some of the current GPU stuff,
like I said,

00:31:30.780 --> 00:31:34.140
it's really getting good for 2D content,
believe it or not.

00:31:34.200 --> 00:31:37.180
And, of course,
OpenGL is the industry standard for 3D,

00:31:37.230 --> 00:31:40.940
and most of the GPUs these
days are built around OpenGL,

00:31:40.940 --> 00:31:44.780
regardless of what Microsoft might
have you believe otherwise.

00:31:44.820 --> 00:31:47.640
OpenGL has a nice stable set of
rasterization rules and the way

00:31:47.640 --> 00:31:50.240
things are supposed to work,
and it doesn't change

00:31:50.240 --> 00:31:52.270
every nine months or so.

00:31:52.970 --> 00:31:56.820
So, and while we think
OpenGL and Mac OS X rocks,

00:31:56.820 --> 00:32:00.510
and I want to like spend a
little bit of time on this,

00:32:00.750 --> 00:32:02.900
because this is where a lot of
the confusion I think has come in.

00:32:02.900 --> 00:32:06.870
We did a lot of work years
ago looking in the overall

00:32:06.870 --> 00:32:11.180
architecture on OS X to figure out,
you know, if we're going to accelerate

00:32:11.180 --> 00:32:13.320
the Windows server,
what are we going to have to deal with?

00:32:13.480 --> 00:32:16.280
Well, the Windows server needs to
put textures in video memory,

00:32:16.280 --> 00:32:18.640
and 3D apps need to put texture,
and Quake wants its

00:32:18.640 --> 00:32:21.520
textures in there too,
and QuickTime wants video memory.

00:32:22.070 --> 00:32:23.790
So, what do you do when you run out?

00:32:23.790 --> 00:32:27.220
Well,
we can't have the windowing system stop

00:32:27.300 --> 00:32:28.700
work when you run out of video memory.

00:32:28.700 --> 00:32:29.890
That's just not going to work.

00:32:30.020 --> 00:32:32.640
So,
we did a lot of work towards virtualizing

00:32:32.640 --> 00:32:35.600
memory management in the system,
for example.

00:32:35.720 --> 00:32:38.920
So, if you've got Quake running,
and you've got DVD playing,

00:32:38.920 --> 00:32:40.810
and you've got the accelerated
Windows server running,

00:32:41.100 --> 00:32:42.720
they're all sharing
the same video memory.

00:32:42.820 --> 00:32:45.610
Now, if you stop doing things,
stop moving around Windows,

00:32:45.610 --> 00:32:47.490
and all you're doing is
sitting there playing Quake in

00:32:47.560 --> 00:32:51.060
full-screen mode or something,
it can get all the video memory.

00:32:51.160 --> 00:32:53.090
It'll page,
it will page everything else out.

00:32:53.260 --> 00:32:54.030
Don't worry about it.

00:32:54.030 --> 00:32:54.960
It's not a big deal.

00:32:55.140 --> 00:32:59.310
You know, and we did this too, because,
like I said, we can't have you

00:32:59.340 --> 00:33:02.240
create that 57th window,
and now all of a sudden you don't

00:33:02.270 --> 00:33:03.640
get Quartz Extreme working anymore.

00:33:03.640 --> 00:33:06.670
We really had to make sure that
everything is paged virtually,

00:33:06.670 --> 00:33:09.560
just like the virtual memory
management system in MoC.

00:33:09.700 --> 00:33:11.500
We also, you know,
had to do a lot of tight

00:33:11.500 --> 00:33:13.150
integration with the Windows Server.

00:33:13.300 --> 00:33:15.690
The graphics drivers have a lot
of communication back and forth.

00:33:15.880 --> 00:33:18.420
They know that when there's a
surface that they can just blip

00:33:18.420 --> 00:33:21.210
the stuff straight to the screen,
the Windows Server can tell them, "Hey,

00:33:21.210 --> 00:33:22.650
this is completely opaque.

00:33:22.650 --> 00:33:25.750
You can just do the
fast 2D blip." However,

00:33:25.800 --> 00:33:28.440
if there's something obscured,
you've got the clock over it,

00:33:28.440 --> 00:33:31.340
or if you're playing DVD and
you've got the volume control,

00:33:31.340 --> 00:33:33.980
the Windows System can
tell the graphics driver,

00:33:33.980 --> 00:33:35.740
"Hey,
you've got to get the Quartz Compositor

00:33:35.740 --> 00:33:38.960
involved because it's the only one that
can make the display right for this."

00:33:39.070 --> 00:33:40.840
So that's exactly the way it works.

00:33:40.890 --> 00:33:43.340
So, like I said,
there's a lot of tight integration

00:33:43.350 --> 00:33:47.120
between the windowing system
and the graphics drivers.

00:33:47.240 --> 00:33:50.510
And along with that,
Apple is really heavily involved

00:33:50.510 --> 00:33:52.190
in the graphics driver development.

00:33:52.210 --> 00:33:55.430
We have full source code to
all the graphics drivers,

00:33:55.600 --> 00:33:58.500
and when we need to make experiments or,
you know,

00:33:58.510 --> 00:34:00.620
just generally toy around with ideas,
which is a lot of how we

00:34:00.700 --> 00:34:03.110
came up with this stuff,
you know, we can just go and do that.

00:34:03.200 --> 00:34:06.200
We don't have to call up NVIDIA and go,
"Hey, would you try this thing for us

00:34:06.200 --> 00:34:07.540
when you get a chance?" We just
can get the stuff out there.

00:34:07.550 --> 00:34:09.680
We can go and do it,
see how it turns out,

00:34:09.720 --> 00:34:12.120
and integrate the sources back to them.

00:34:12.240 --> 00:34:14.880
Now, in doing this,
we came up with some new

00:34:14.910 --> 00:34:18.740
extensions that were really
driven by the compositor needs.

00:34:18.740 --> 00:34:22.380
And we'll get into these in some of
the OpenGL sessions later this week.

00:34:22.510 --> 00:34:24.300
But just to give you an example,
two of these,

00:34:24.300 --> 00:34:27.610
GL Client Storage and GL Texture Ranger,
used to let us get backing stores up

00:34:27.610 --> 00:34:31.520
into video memory at that 400 megabytes
per second I was talking you about.

00:34:31.640 --> 00:34:33.940
So the CPU doesn't have to
touch any of that stuff.

00:34:34.080 --> 00:34:37.500
And the great part about these extensions
is they're available to all you guys.

00:34:37.500 --> 00:34:38.500
And they're available to all of you.

00:34:38.500 --> 00:34:39.460
You know, we're not cheating.

00:34:39.460 --> 00:34:41.800
You guys can use all the same stuff
we're doing in the Windows server.

00:34:43.420 --> 00:34:47.410
So you guys should think of the Quartz
Compositor as just another OpenGL app.

00:34:47.620 --> 00:34:50.460
It loads the same drivers
that you guys have access to.

00:34:50.460 --> 00:34:56.480
You know,
there's no cheating going on here again.

00:34:56.480 --> 00:34:58.780
And as Peter has said,
you really should also think

00:34:58.910 --> 00:35:00.480
of the desktop as a 3D scene.

00:35:00.560 --> 00:35:03.800
Every single pixel, if need be,
can go through the entire OpenGL pipe.

00:35:03.950 --> 00:35:07.850
Anything you can do with a GPU,
we can now do to any pixel on the screen.

00:35:07.850 --> 00:35:13.250
I'm not going to give away everything,
but, you know, use your imagination.

00:35:13.250 --> 00:35:16.150
You guys have seen a lot of cool effects
this week from some of the other demos,

00:35:16.200 --> 00:35:18.490
so you can imagine what
types of things we could do.

00:35:18.610 --> 00:35:21.920
In general, everything on the screen ends
up being a textured polygon,

00:35:22.030 --> 00:35:24.360
usually just a textured
quad of some kind,

00:35:24.360 --> 00:35:27.470
surfaces, windows, menus,
everything basically just

00:35:27.470 --> 00:35:30.590
turned in--it's a window,
it gets turned into a textured polygon.

00:35:30.760 --> 00:35:32.100
Same thing with surfaces.

00:35:32.250 --> 00:35:34.740
All the compositing is done with
standard OpenGL blending and,

00:35:34.740 --> 00:35:36.300
in some cases, multi-texturing.

00:35:36.320 --> 00:35:39.170
You know,
it's all really pretty standard.

00:35:41.050 --> 00:35:45.210
So in the Quartz Extreme world,
the sort of green box

00:35:45.210 --> 00:35:46.380
has moved out of the way.

00:35:46.520 --> 00:35:49.700
He's really just sort of sitting
in the driver's seat telling

00:35:49.700 --> 00:35:53.020
the GPU through OpenGL how to
get everything to the screen.

00:35:53.160 --> 00:35:56.400
So an application, for example,
does this stuff,

00:35:56.560 --> 00:36:00.240
draws it into its window backing store,
tells the Windows server, hey,

00:36:00.240 --> 00:36:02.100
I need to get this stuff on the screen.

00:36:02.170 --> 00:36:05.560
Quartz Extreme wakes up and says, okay,
fine, I can do that.

00:36:05.810 --> 00:36:08.130
Tells OpenGL, hey,
get this stuff into video memory

00:36:08.180 --> 00:36:09.620
and get it on the screen right now.

00:36:09.620 --> 00:36:11.200
And that's basically the way it works.

00:36:11.310 --> 00:36:14.980
In the case of OpenGL or QuickTime,
generally the data is already

00:36:14.980 --> 00:36:18.960
on a surface in video memory,
so we just have to turn around and

00:36:19.050 --> 00:36:21.080
turn that surface into a texture.

00:36:24.170 --> 00:36:27.100
and So, does it work on my PowerBook?

00:36:27.310 --> 00:36:28.970
Question on everybody's mind.

00:36:29.010 --> 00:36:32.060
So, these are generally the
requirements we had.

00:36:32.280 --> 00:36:35.520
We're recommending 32
megabytes of video memory.

00:36:35.520 --> 00:36:38.690
That's not a completely hard limit,
so it works on the second

00:36:38.690 --> 00:36:40.220
generation tie books.

00:36:40.220 --> 00:36:44.880
AGB2X right now is definitely
required for us to get the

00:36:44.880 --> 00:36:47.580
bandwidth we need into video memory.

00:36:47.910 --> 00:36:52.090
We need the hardware to support all of
the core graphics native formats without

00:36:52.090 --> 00:36:54.630
having to have the CPU touch the data.

00:36:54.770 --> 00:36:58.090
It's kind of pointless if we
have to make extra CPU copies,

00:36:58.090 --> 00:37:00.140
reformat the data around
to do a bunch of junk,

00:37:00.290 --> 00:37:01.800
and then put it in video memory.

00:37:01.920 --> 00:37:04.040
Because in a lot of cases,
we end up having to expand the data,

00:37:04.040 --> 00:37:07.670
so then use even more video memory,
and it's not really worthwhile.

00:37:07.800 --> 00:37:10.000
The other really,
really critical one is we have to be

00:37:10.020 --> 00:37:12.370
able to support non-par of two textures.

00:37:12.530 --> 00:37:16.240
Traditional OpenGL,
each dimension had to be, you know, 1, 2,

00:37:16.240 --> 00:37:19.860
4, 8, 16, 32, 64, et cetera,
in each direction.

00:37:19.930 --> 00:37:23.240
With rectangle textures,
it's pretty much arbitrary,

00:37:23.240 --> 00:37:25.450
and you can imagine the cases
where we would need this.

00:37:25.550 --> 00:37:29.980
If you're playing back video,
for example, DVD at 720 by 480,

00:37:30.050 --> 00:37:31.940
we don't want to have to, like,
turn around and do funky

00:37:32.020 --> 00:37:34.000
scaling or anything,
which would just tie up

00:37:34.000 --> 00:37:35.660
even more video memory to,
like,

00:37:35.660 --> 00:37:37.680
convert that into a par of two texture.

00:37:37.820 --> 00:37:40.680
So that's really a
showstopper on some hardware.

00:37:40.680 --> 00:37:42.400
I'll get into that in a minute.

00:37:42.400 --> 00:37:44.560
Multitexture is also required.

00:37:44.560 --> 00:37:48.990
There's cases where we have, like,
alpha channels, even with 16-bit windows,

00:37:49.000 --> 00:37:51.050
and we need to be able to
combine the sort of 8-bit alpha

00:37:51.130 --> 00:37:55.400
channel with the 16-bit texture,
and we use multitexture to do that.

00:37:55.400 --> 00:37:58.340
And we're recommending
256 megs of system memory,

00:37:58.340 --> 00:38:00.710
and this just has to do with
the fact that we end up tying

00:38:01.200 --> 00:38:04.160
up AGP space quite a bit,
so you don't want to, like,

00:38:04.160 --> 00:38:07.090
wire down all the memory in the system.

00:38:09.320 --> 00:38:11.170
So here's the quick upshot.

00:38:11.520 --> 00:38:13.840
All of the NVIDIA stuff is supported.

00:38:14.030 --> 00:38:17.440
GeForce 2 MX, GeForce 3, GeForce 4 MX,
GeForce 4.

00:38:17.440 --> 00:38:20.800
Radeon AGPs are all supported,
including the ones in the

00:38:20.830 --> 00:38:22.600
second generation tie book.

00:38:22.820 --> 00:38:25.810
And Rage 128 is not
going to be supported.

00:38:25.860 --> 00:38:28.690
And it's not because it doesn't
have enough video memory.

00:38:28.730 --> 00:38:29.720
That's part of it.

00:38:29.760 --> 00:38:32.530
But it doesn't support all
the texture formats we need.

00:38:32.530 --> 00:38:34.510
It doesn't support non-power of textures.

00:38:34.580 --> 00:38:36.200
The functionality just isn't there.

00:38:36.200 --> 00:38:40.420
It's not that I wouldn't like it to
work on my machines with Rage 128's too.

00:38:40.460 --> 00:38:41.050
I can't have it.

00:38:41.130 --> 00:38:42.560
I don't know how to make it work.

00:38:42.560 --> 00:38:44.710
There doesn't seem to
be any way to do that.

00:38:45.660 --> 00:38:49.250
So, give you guys a demo and see
if we can bring the system

00:38:49.250 --> 00:38:50.140
to its knees a little bit.

00:38:50.140 --> 00:38:53.170
Everybody's been doing the
fun demos that look cool,

00:38:53.250 --> 00:38:56.150
but let's see what we can really do here.

00:38:56.200 --> 00:38:59.440
So, let me get rid of Ralph's thing.

00:39:00.180 --> 00:39:03.650
So let's see,
what else can I do to beat on this?

00:39:03.660 --> 00:39:04.500
Let's see.

00:39:04.500 --> 00:39:06.100
Oh,
I guess I should have left that up there.

00:39:06.160 --> 00:39:08.460
So you guys have seen all these,
obviously, before.

00:39:08.510 --> 00:39:10.330
Hopefully, anyway.

00:39:10.830 --> 00:39:13.320
Again, I can get as many of these
things stacked up as I want.

00:39:13.540 --> 00:39:17.040
You know, this is similar to DVD,
in which case we're compositing

00:39:17.040 --> 00:39:19.240
on top of OpenGL content.

00:39:19.240 --> 00:39:23.430
So if I get these over
here-- Where'd you guys go?

00:39:25.540 --> 00:39:27.630
I can still bring all those
terminal windows off on top of

00:39:27.730 --> 00:39:32.500
these guys and still see I can--
I can get it to fade out if I want,

00:39:32.500 --> 00:39:34.520
but it takes a while.

00:39:35.480 --> 00:39:38.600
and even now I can sit here and
still drag this around pretty good.

00:39:38.600 --> 00:39:42.890
I don't think with the software
compositor we'd be quite doing this good.

00:39:42.980 --> 00:39:46.530
It's fast, but it's not this fast.

00:39:48.470 --> 00:39:50.430
Alright,
well I've got other demos but I'll have

00:39:50.430 --> 00:39:52.680
to save them for a little bit later.

00:39:52.680 --> 00:39:54.900
They're good though.

00:39:56.870 --> 00:39:58.800
All right, thanks.

00:39:58.800 --> 00:40:00.460
Oops.

00:40:00.470 --> 00:40:02.810
So as you can see,
there's really no transparency tax.

00:40:02.860 --> 00:40:07.130
If you've got a fast graphics card,
you can just keep piling this stuff up.

00:40:07.210 --> 00:40:09.220
You know, like I said,
I probably lost count of

00:40:09.220 --> 00:40:10.340
the number of layers there.

00:40:10.340 --> 00:40:12.100
There's probably 20 or
so terminal windows,

00:40:12.100 --> 00:40:15.320
so that's 40 layers of
transparency on top of DVD.

00:40:15.440 --> 00:40:19.850
Whereas before, we couldn't even do the
simple little volume control.

00:40:20.000 --> 00:40:21.390
And obviously the GD works.

00:40:21.400 --> 00:40:26.700
You can GD underneath transparency,
all that fun Aqua UI stuff.

00:40:26.800 --> 00:40:28.350
So...

00:40:28.690 --> 00:40:30.950
It gives us a lot more CPU headroom,
you know.

00:40:30.950 --> 00:40:33.130
I forgot I should have run this
and I'll try it again later,

00:40:33.600 --> 00:40:36.010
but even with all that transparency up,
the CPU monitors are just

00:40:36.030 --> 00:40:37.390
sitting there doing nothing.

00:40:37.400 --> 00:40:38.880
I mean,
it's like they're decoding the DVD and

00:40:38.880 --> 00:40:40.260
they don't have any other work to do.

00:40:40.260 --> 00:40:41.690
They don't have to worry
about the compositing.

00:40:41.690 --> 00:40:43.360
It's not CPU's problem.

00:40:43.360 --> 00:40:46.080
You know, as you can see,
we've sort of got completely

00:40:46.080 --> 00:40:48.640
seamless integration now of
DVD with the rest of the system.

00:40:48.700 --> 00:40:52.060
We don't have to worry about we need
to treat DVD windows special because

00:40:52.160 --> 00:40:54.040
they take a lot of CPU horsepower.

00:40:54.040 --> 00:40:55.780
It's just like any other
window in the system.

00:40:55.780 --> 00:41:00.580
And the cool part about this,
and the demo sort of

00:41:00.770 --> 00:41:03.790
shows this a little bit,
is this gives us a lot of exciting

00:41:03.860 --> 00:41:05.490
new possibilities on OS X.

00:41:05.670 --> 00:41:08.850
Where before, you know,
on like SGI hardware or

00:41:08.850 --> 00:41:11.260
even some PC hardware,
you know, a lot of people said, you know,

00:41:11.260 --> 00:41:12.190
I have to have overlays.

00:41:12.200 --> 00:41:13.380
You know, I've got GL.

00:41:13.380 --> 00:41:15.270
I need to draw something on top of it.

00:41:15.330 --> 00:41:16.870
You know,
you guys don't have overlay support.

00:41:16.870 --> 00:41:17.820
What are you going to do?

00:41:17.820 --> 00:41:20.940
Well, why do you need overlays when
you can layer 20 windows on top

00:41:20.940 --> 00:41:22.640
of something with transparency?

00:41:22.640 --> 00:41:23.740
Now you can do it with blending.

00:41:23.740 --> 00:41:25.640
There's no pixel, you know.

00:41:25.780 --> 00:41:28.540
You can't do it with per
pixel issues anymore.

00:41:28.550 --> 00:41:30.850
Another cool thing we can do,
which I'll get demo

00:41:30.850 --> 00:41:34.220
here in just a minute,
is underlay surfaces.

00:41:34.240 --> 00:41:37.130
And there's a couple other cool things,
too.

00:41:37.630 --> 00:41:40.530
So underlay OpenGL surfaces
are sort of a new thing.

00:41:40.540 --> 00:41:45.220
In previous versions of Jack--
or previous versions of Jaguar--

00:41:45.300 --> 00:41:48.180
previous versions of Mac OS X,

00:41:48.730 --> 00:41:51.700
Surfaces were always basically
sitting on top of the window.

00:41:51.700 --> 00:41:53.010
You couldn't get rid of them.

00:41:53.020 --> 00:41:54.920
You know, they were just always there.

00:41:54.920 --> 00:41:56.980
You could reorder surfaces
relative to each other,

00:41:56.980 --> 00:41:59.660
but they were still always
on top of your 2D content.

00:41:59.660 --> 00:42:01.650
You know, people have always, you know,
they'd say,

00:42:01.660 --> 00:42:04.650
I'm drawing 2D in my view or whatever,
and I'm not seeing any of it.

00:42:04.720 --> 00:42:05.440
Well, it's drawing.

00:42:05.440 --> 00:42:07.120
It's just drawing into
the window backing store,

00:42:07.120 --> 00:42:08.280
which is completely obscured.

00:42:08.280 --> 00:42:11.370
So with the Compositor, though,
it becomes pretty,

00:42:11.370 --> 00:42:14.200
I don't want to say easy from
an implementation standpoint,

00:42:14.200 --> 00:42:16.960
but from a compositing standpoint,
there's no reason why we can't flip

00:42:16.960 --> 00:42:20.500
this around and put the surface
underneath the window backing store.

00:42:20.500 --> 00:42:24.420
So now, if you want to do your 3D stuff,
you can draw, you know,

00:42:24.420 --> 00:42:27.360
using Quartz or Quick Draw,
you can draw on top of OpenGL,

00:42:27.360 --> 00:42:30.080
and as long as you've sort
of punched a hole in it,

00:42:30.260 --> 00:42:32.740
you can see what's behind
it and basically allow the

00:42:32.800 --> 00:42:34.300
GL stuff to poke through.

00:42:34.300 --> 00:42:38.420
Now, what this sort of alludes to is that
there's still independent buffers.

00:42:38.420 --> 00:42:40.600
You can draw to your 2D, clear it,
draw 2D, clear it,

00:42:40.660 --> 00:42:43.100
and you don't have to modify
your GL content every frame.

00:42:43.100 --> 00:42:45.550
Likewise, you can sit there and
animate the 3D content,

00:42:45.600 --> 00:42:47.500
and you don't have to redraw the 2D.

00:42:47.510 --> 00:42:50.480
It just sits there and gets
composited by the Windows server.

00:42:52.150 --> 00:42:57.530
So, leave, and give you guys a
demo of that real quick.

00:43:01.500 --> 00:43:05.740
Let's get into this real quick.

00:43:05.740 --> 00:43:07.490
Oh, where is he here?

00:43:07.570 --> 00:43:07.920
So here we go.

00:43:08.100 --> 00:43:11.350
So, you know, world's most complicated

00:43:12.610 --> 00:43:14.560
OpenGL demo, spinning lit cube.

00:43:14.560 --> 00:43:16.860
I think this is about 10 lines of code.

00:43:16.960 --> 00:43:19.720
But one thing you really
couldn't do before in Puma,

00:43:19.720 --> 00:43:22.520
for example, oops, 10.1,
is sit there and just

00:43:22.520 --> 00:43:23.980
draw and paint with it.

00:43:23.980 --> 00:43:26.370
So this is just splatting
with Core Graphics,

00:43:26.370 --> 00:43:28.050
a little round little thing.

00:43:28.060 --> 00:43:30.170
You know,
so the frame rate just keeps up.

00:43:30.170 --> 00:43:33.290
I can paint in here as much as
I want and go and clear it all out.

00:43:33.290 --> 00:43:36.120
So all of you guys have said,
I want to do 2D over OpenGL.

00:43:36.120 --> 00:43:37.600
Well, now you can do it.

00:43:37.600 --> 00:43:39.410
You can just sort of clear it all out.

00:43:39.420 --> 00:43:41.420
Make a little Etch-a-Sketch thing.

00:43:41.420 --> 00:43:44.570
And if I just had to use Metal,
I was just like, okay, that's cool,

00:43:44.570 --> 00:43:45.460
it's in there.

00:43:45.460 --> 00:43:48.440
So another thing that would be
common for an OpenGL implementation

00:43:48.450 --> 00:43:49.730
would be to do selection.

00:43:49.850 --> 00:43:53.430
So I can just, just to simulate what that
might look like and just,

00:43:53.590 --> 00:43:56.320
you know,
say this is a fairly big OpenGL surface,

00:43:56.410 --> 00:43:59.040
I can just now take my 2D and I go, okay,
well,

00:43:59.040 --> 00:44:01.980
now I can just like do some selection
similar to what Finder does.

00:44:02.000 --> 00:44:04.040
But I can do the selection stuff in 2D.

00:44:04.040 --> 00:44:07.190
I don't have to do it
with OpenGL anymore.

00:44:08.930 --> 00:44:11.040
Unfortunately, I can't do both.

00:44:11.040 --> 00:44:15.030
I'll show you guys this again,
but the app's pretty simplistic.

00:44:15.110 --> 00:44:16.940
It only lets me do one at a time.

00:44:16.940 --> 00:44:19.590
So anyway, so that's underlay surfaces.

00:44:19.740 --> 00:44:20.230
Thanks.

00:44:20.230 --> 00:44:21.690
Go back to slides.

00:44:24.680 --> 00:44:25.710
So how do you do this?

00:44:25.850 --> 00:44:28.230
Well, it's actually pretty easy.

00:44:28.240 --> 00:44:30.700
You can actually order a
surface above or below a window.

00:44:30.990 --> 00:44:32.990
Obviously, above is the default.

00:44:33.070 --> 00:44:38.450
So there's basically a new method for
NSOpenGL context or an existing call in

00:44:38.450 --> 00:44:41.960
Carbon for AGL that's been there forever,
AGL set integer.

00:44:41.960 --> 00:44:45.040
But now you can basically say, hey,
the surface that I'm attached to

00:44:45.050 --> 00:44:48.600
that my OpenGL context is using,
I want to order that beneath the window.

00:44:48.600 --> 00:44:50.580
So it's pretty simple, as you can see.

00:44:50.580 --> 00:44:51.800
That's all the code it takes.

00:44:53.500 --> 00:44:58.530
You just call set values for parameter
and pass in NSGL CP surface order,

00:44:58.660 --> 00:45:00.490
and you can set it to negative one.

00:45:00.690 --> 00:45:03.300
Probably should use a
better constant for that.

00:45:03.740 --> 00:45:05.700
Basically, one is above,
negative one's below.

00:45:05.900 --> 00:45:07.380
Same thing for Carbon.

00:45:07.380 --> 00:45:09.390
Works exactly the same way.

00:45:10.140 --> 00:45:14.960
So things to watch out for when you're
doing underlay style drawing with OpenGL.

00:45:14.960 --> 00:45:18.750
You have to punch a hole using
clear color in your backing store

00:45:18.840 --> 00:45:20.990
or nothing's going to show up.

00:45:21.090 --> 00:45:23.720
So for the Cocoa example,
it's pretty simple.

00:45:23.810 --> 00:45:27.290
NSColor clear color set and just
do a rect fill on your bounds.

00:45:27.290 --> 00:45:30.140
Or if you're using Carbon,
I believe the correct call

00:45:30.170 --> 00:45:32.700
is CGContextClearRect,
and that will paint the clear

00:45:32.700 --> 00:45:34.140
color in your backing store.

00:45:34.230 --> 00:45:36.410
So there's a couple of things
to watch out for in this.

00:45:36.470 --> 00:45:41.060
It's really easy to just blindly
write your sort of draw rect method

00:45:41.180 --> 00:45:44.880
for your NSView subclass if you're in
Cocoa land to just always update your

00:45:44.880 --> 00:45:48.450
GL content every time it needs to
be redrawn and to repaint the clear.

00:45:48.450 --> 00:45:49.620
That's pretty wasteful.

00:45:49.630 --> 00:45:51.700
Usually only one or the other changes.

00:45:51.780 --> 00:45:53.940
So you really want to watch out for that.

00:45:54.220 --> 00:45:57.100
A little trick I'll share with you
that I found while actually doing one

00:45:57.200 --> 00:46:02.390
of these demos is to actually--when
you know that the GL content is dirty,

00:46:02.390 --> 00:46:05.370
you can actually set a flag
in your view that says,

00:46:05.440 --> 00:46:07.710
okay, just the GL content's dirty.

00:46:07.810 --> 00:46:08.820
Then you can call the standard Cocoa.

00:46:08.840 --> 00:46:08.840
Set clear.

00:46:08.850 --> 00:46:09.600
And that's pretty easy.

00:46:09.600 --> 00:46:10.580
You can call the standard Cocoa.

00:46:10.580 --> 00:46:11.570
Set needs display on your view.

00:46:11.780 --> 00:46:15.300
The next part of the trick is
you modify your isOpaque call,

00:46:15.330 --> 00:46:19.310
or method rather,
to always return the value of that flag.

00:46:19.330 --> 00:46:23.680
So what happens when the view
system goes to render everything,

00:46:23.680 --> 00:46:27.250
if it goes--gets down to your view,
realizes that, hey, everything's,

00:46:27.250 --> 00:46:30.530
you know, you've said that you're opaque,
it's just going to stop right then

00:46:30.530 --> 00:46:33.740
and there and draw and it won't
try drawing anything behind you.

00:46:33.760 --> 00:46:36.140
So it's actually a neat
little trick to do.

00:46:36.590 --> 00:46:39.840
So the other thing to watch
out for is extra flushes.

00:46:40.030 --> 00:46:43.560
It's also pretty easy if you're
going to-- if you draw with 2D,

00:46:43.640 --> 00:46:46.590
that's going to cause the Quartz
Compositor to do one flush to the screen.

00:46:46.600 --> 00:46:48.820
And then if you're drawing with GL,
it can cause another

00:46:48.820 --> 00:46:50.320
redundant flush to the screen.

00:46:50.420 --> 00:46:56.320
So there are some cases where
you kind of want to figure out

00:46:56.320 --> 00:46:59.150
which guy you want driving.

00:46:59.150 --> 00:46:59.150
If--in some cases, you may just want to
draw some stuff in 2D.

00:46:59.900 --> 00:47:32.500
[Transcript missing]

00:47:33.070 --> 00:47:35.300
So the other cool thing
that's my personal favorite,

00:47:35.320 --> 00:47:37.490
and one of the first things I did
when I got this stuff running

00:47:37.540 --> 00:47:38.940
was transparent OpenGL surfaces.

00:47:39.010 --> 00:47:42.010
Now you guys have seen
all my demo materials been

00:47:42.010 --> 00:47:44.100
stolen for stuff up till now.

00:47:44.120 --> 00:47:48.740
But you can get the Compositor to
use the destination alpha channel if

00:47:48.740 --> 00:47:51.760
you've got a 32-bit OpenGL context.

00:47:51.760 --> 00:47:53.520
Now obviously, you know,
you guys can tell what

00:47:53.520 --> 00:47:54.330
you can do with this.

00:47:54.340 --> 00:47:57.650
You can get OpenGL, you know,
objects to basically

00:47:57.740 --> 00:47:59.020
appear sort of standalone.

00:47:59.100 --> 00:48:02.890
Now you don't have to do it quite like
we've done in most of the demos so far,

00:48:02.890 --> 00:48:05.680
and I'll give you an
example of it in a second.

00:48:05.680 --> 00:48:08.560
Now the things to watch out
for is that the surface content

00:48:08.650 --> 00:48:10.150
has to be premultiplied.

00:48:10.500 --> 00:48:13.490
Normally what that means is,
or the way to achieve that

00:48:13.540 --> 00:48:16.780
in OpenGL is first draw your
content on a completely black,

00:48:16.950 --> 00:48:17.820
clear background.

00:48:17.830 --> 00:48:21.220
You know, so call geoclearcolor with
all zeros and then geoclear,

00:48:21.220 --> 00:48:23.090
geocolorbuffer bit, whatever.

00:48:23.160 --> 00:48:26.570
That gets you starting on
something clear fundamentally.

00:48:26.570 --> 00:48:30.070
Make sure then when you draw that you've,
if you're doing any kind

00:48:30.160 --> 00:48:32.730
of blending effects,
that you've actually got blending enabled

00:48:32.740 --> 00:48:35.100
so that the alpha value that ends up at,
excuse me,

00:48:35.100 --> 00:48:40.140
in the destination buffer has the right
value and that OpenGL has multiplied your

00:48:40.230 --> 00:48:44.940
color values times the source alphas so
that the blending comes out correctly.

00:48:45.080 --> 00:48:49.740
So I'll give you guys a quick
demo of transparent surfaces.

00:48:49.940 --> 00:48:52.730
So what I did is I took a little

00:48:53.030 --> 00:48:58.270
Application that I've been fooling around
with in my non-existent spare time.

00:48:59.210 --> 00:49:04.620
It's basically just a Lego model
viewer that I've been toying with.

00:49:04.640 --> 00:49:07.480
And it's also a gratuitous use of metal.

00:49:07.650 --> 00:49:11.250
and So what you've got
here is this 3D object,

00:49:11.270 --> 00:49:12.740
in this case just a little train.

00:49:13.050 --> 00:49:15.840
But you can see that he's basically
composited on the metal background.

00:49:15.840 --> 00:49:18.540
You can't tell that there's
an OpenGL surface here at all.

00:49:18.770 --> 00:49:20.760
And the really cool part is
that I'm actually using the

00:49:20.760 --> 00:49:23.250
GeForce 4's multi-sample support.

00:49:23.320 --> 00:49:27.080
So you get nice--let's see if
this is going to work here.

00:49:27.080 --> 00:49:29.800
Oh, it's off.

00:49:29.800 --> 00:49:32.040
All right, here.

00:49:32.040 --> 00:49:34.280
Sidestep here for a second.

00:49:41.570 --> 00:49:45.440
You can actually see that the edges are
all nice and anti-aliased on everything.

00:49:45.440 --> 00:49:47.880
So you get this really smooth effect,
just sort of like it was

00:49:47.920 --> 00:49:49.000
drawn with Quartz 2D.

00:49:50.500 --> 00:49:56.100
[Transcript missing]

00:49:59.070 --> 00:50:01.240
But, you know, obviously you don't have
to do anything like this,

00:50:01.330 --> 00:50:03.850
but you could certainly,
as another example,

00:50:03.850 --> 00:50:05.910
where I think this would be useful,
is you've got some kind of really

00:50:06.020 --> 00:50:08.930
cool custom control you want to draw,
and it's obviously better

00:50:08.980 --> 00:50:10.100
to draw it with OpenGL.

00:50:10.100 --> 00:50:13.350
You can now sort of do it,
and you don't have to have the

00:50:13.350 --> 00:50:17.200
little black or white or blue box
around your OpenGL content anymore.

00:50:17.200 --> 00:50:19.900
You can really have
completely stand-alone,

00:50:19.990 --> 00:50:22.400
completely stand-alone 3D
objects in your windows now.

00:50:26.700 --> 00:50:31.840
Let's see, now I've got another fun demo
of transparent surfaces here.

00:50:31.960 --> 00:50:36.390
So if you guys were alive in the 80s,
you probably have seen this before.

00:50:36.460 --> 00:50:37.800
But I've done a few tricks.

00:50:37.800 --> 00:50:41.800
I've played a few--oops, sorry.

00:50:42.380 --> 00:50:47.730
Idiot Driver, try it again.

00:50:47.730 --> 00:50:47.730
So I've done a few mods, made it bigger.

00:50:47.860 --> 00:50:49.260
added lighting.

00:50:49.340 --> 00:50:51.600
Now, the Amiga was pretty
cool when it did this.

00:50:51.800 --> 00:50:53.840
They cheated a lot in this demo.

00:50:53.870 --> 00:50:55.690
I don't know how many of you know,
but all they did was color

00:50:55.690 --> 00:50:58.770
cycling and play field animation,
so they didn't have to blit or anything.

00:50:58.840 --> 00:51:01.830
I'm actually drawing this in real 3D,
lighting it.

00:51:01.940 --> 00:51:03.800
Now, believe it or not,
this whole thing is being

00:51:03.800 --> 00:51:05.200
composited under the desktop.

00:51:05.270 --> 00:51:07.600
Well, you say, "Well, it's opaque." Well,
that's fine,

00:51:07.600 --> 00:51:10.710
but what if it's out of the window?

00:51:13.690 --> 00:51:16.400
So, that one didn't get stolen.

00:51:16.400 --> 00:51:19.130
Now if that isn't enough,
what if you want to play

00:51:19.210 --> 00:51:21.590
Space Invaders on your desktop?

00:51:25.900 --> 00:51:29.700
How come--hold on a second.

00:51:29.710 --> 00:51:33.440
It's supposed to be
underneath the desktop.

00:51:33.520 --> 00:51:34.430
That's no fun.

00:51:34.440 --> 00:51:38.170
Well, I'm not gonna go recompile it,
but... See,

00:51:38.170 --> 00:51:39.640
I can sit here and actually play it.

00:51:39.650 --> 00:51:41.770
Doo-doo-doo.

00:51:43.040 --> 00:51:46.110
Completely useless, yes, but you know,
you're not going to do it on

00:51:46.110 --> 00:51:47.890
your XP box anytime soon either.

00:51:48.100 --> 00:51:50.320
Probably a few years.

00:51:56.520 --> 00:52:00.750
So, fortunately not all my material
got stolen for the keynote.

00:52:00.750 --> 00:52:02.340
It's kind of hard.

00:52:02.460 --> 00:52:04.590
Can I go back to slides, please?

00:52:05.930 --> 00:52:07.690
All right, so how do I enable that?

00:52:07.780 --> 00:52:08.400
I want to do that.

00:52:08.400 --> 00:52:09.100
That's really cool.

00:52:09.100 --> 00:52:11.100
I want to make fun demos for my friends.

00:52:11.140 --> 00:52:14.450
It's a lot--it's very similar to what
we just did with ordering surfaces.

00:52:14.450 --> 00:52:17.780
In this case,
you just use NSOpenGL CP surface

00:52:17.780 --> 00:52:20.490
opacity and you can basically
just say my surface is now,

00:52:20.490 --> 00:52:22.070
you know, use the alpha channel.

00:52:22.070 --> 00:52:24.310
That's now important and
the Windows server will

00:52:24.530 --> 00:52:26.400
take--will do that for you.

00:52:26.430 --> 00:52:29.750
And I alluded to this a minute ago,
but this is another one of those cases

00:52:29.860 --> 00:52:33.370
where I actually--this is the case where
I ran into the sort of double rendering.

00:52:33.370 --> 00:52:35.780
When I first did the train demo,
it was kind of slow and I was like,

00:52:35.780 --> 00:52:38.410
"Well, what's going on?" So it turned out
what was happening was every time

00:52:38.470 --> 00:52:43.150
I had marked my view as basically--I
had to mark my view as transparent.

00:52:43.150 --> 00:52:46.480
I had to return no for isOpake,
otherwise the window back--metal

00:52:46.550 --> 00:52:47.720
background wouldn't draw.

00:52:47.920 --> 00:52:50.550
But now then what was happening is
every single time I'd redrew my view,

00:52:50.550 --> 00:52:54.120
it would redraw the metal background
and performance wasn't that great,

00:52:54.120 --> 00:52:54.840
you know.

00:52:54.850 --> 00:52:54.850
It's--it's--

00:52:55.100 --> 00:54:07.500
[Transcript missing]

00:54:08.940 --> 00:54:12.900
So all this new
functionality is pretty cool,

00:54:13.190 --> 00:54:15.320
but you guys are like,
"What do I do on a RAGE 128?" Well,

00:54:15.380 --> 00:54:18.560
as it turns out,
all of the overlay and underlay

00:54:18.560 --> 00:54:23.340
surface stuff and transparent surfaces
are supported in the software case.

00:54:23.340 --> 00:54:27.730
You don't have to have Quartz Xtreme
enabled on your machine to do,

00:54:27.730 --> 00:54:31.800
like, the little LEGO demo like I did.

00:54:31.900 --> 00:54:34.700
If you're doing fairly
small OpenGL surfaces,

00:54:34.820 --> 00:54:37.090
performance will probably be okay.

00:54:37.090 --> 00:54:41.320
I can actually run the Boeing demo small,
for example, if, you know,

00:54:41.320 --> 00:54:43.830
with a small surface with the
Compositor--hardware Compositor

00:54:43.880 --> 00:54:45.160
turned off and it does okay.

00:54:45.220 --> 00:54:47.630
If it gets really big,
we have to pull a lot of data

00:54:47.650 --> 00:54:49.340
across the bus and it slows down.

00:54:49.460 --> 00:54:54.440
And again, the main bottleneck in this is
the CPU read from video memory.

00:54:54.550 --> 00:54:55.870
That's pretty tough to do.

00:54:55.870 --> 00:54:59.420
It's a 66 megahertz wide,
32-bit bus with hellish read times.

00:54:59.490 --> 00:55:04.470
It's just--you read a byte and take
a nap and another one comes back.

00:55:05.300 --> 00:55:07.620
So if you're doing something that
you know is going to be really

00:55:07.670 --> 00:55:11.240
expensive and you want to maybe not
do it if Quartz Extreme isn't there,

00:55:11.240 --> 00:55:14.320
you can call CG Display Uses
OpenGL Acceleration on a

00:55:14.320 --> 00:55:18.400
per-display basis to figure out
if Quartz Extreme is around.

00:55:18.400 --> 00:55:23.570
So if you've got, for example,
GeForce 3 in your system and

00:55:23.600 --> 00:55:28.900
you've also got a PCI Radeon,
it's very likely that the PCI card

00:55:28.900 --> 00:55:32.520
won't have Quartz Extreme enabled on it.

00:55:32.700 --> 00:55:35.520
And you can test for that so that if
you move the window over to that screen,

00:55:35.520 --> 00:55:38.500
you can stop doing something that's
so expensive that your windows

00:55:38.500 --> 00:55:41.780
would think your app is slow or
a bummer or something like that.

00:55:43.320 --> 00:55:48.700
So anyway, so just the sort of real
quick recap on all of this.

00:55:48.910 --> 00:55:51.090
The main thing we went for is, you know,
reduced CPU usage.

00:55:51.120 --> 00:55:55.100
All of the effects in the world are cool,
but if your CPU is dragged

00:55:55.100 --> 00:55:58.560
down into the dirt,
it's not as much fun.

00:55:58.710 --> 00:56:01.510
The other point, hopefully,
I got across with the million

00:56:01.510 --> 00:56:03.760
terminal windows thing is that
the compositing is really,

00:56:03.760 --> 00:56:04.690
really, really fast.

00:56:04.730 --> 00:56:07.900
You know, with 10 gigabytes per
second of memory bandwidth,

00:56:08.050 --> 00:56:12.460
which is probably an order of magnitude
more than the CPU has access to,

00:56:12.570 --> 00:56:14.900
we can blow pixels all over
the screen all day long,

00:56:14.900 --> 00:56:17.900
and it's pretty hard, as we saw,
to drag the GPU down doing it.

00:56:17.900 --> 00:56:20.820
So if Quartz Extreme is around,
take advantage of this stuff.

00:56:20.980 --> 00:56:23.350
It's almost free.

00:56:23.500 --> 00:56:26.690
We've now got completely
seamless integration between 3D,

00:56:26.800 --> 00:56:29.260
2D, DVD, everything else in the system.

00:56:29.260 --> 00:56:33.810
You know, you don't have to worry now if
I've got my OpenGL CAD app or

00:56:33.810 --> 00:56:36.500
something and I want to pop up,
you know, some kind of window on top

00:56:36.500 --> 00:56:40.040
of it for menus or whatever,
like, for example, Maya's Hotbox,

00:56:40.060 --> 00:56:42.400
there isn't going to be a performance
issue with bringing that up and down

00:56:42.400 --> 00:56:45.260
really quickly because the CPU doesn't
have to go across the bus and

00:56:45.410 --> 00:56:47.630
composite a fairly big window anymore.

00:56:47.640 --> 00:56:49.900
So take advantage of this stuff again.

00:56:50.730 --> 00:56:53.470
and related to that

00:56:53.900 --> 00:56:56.990
You should really take home
that with Quartz Extreme,

00:56:57.010 --> 00:56:59.340
transparent windows and surfaces
are better than overlays.

00:56:59.340 --> 00:57:00.980
You don't have just one, you have N.

00:57:01.120 --> 00:57:02.200
How many do you want?

00:57:02.310 --> 00:57:06.840
Do you want one overlay for selection,
another one for statistics,

00:57:06.840 --> 00:57:09.390
10 more for whatever you want?

00:57:09.560 --> 00:57:13.310
You can really do that.

00:57:14.200 --> 00:57:16.200
There was a demo I forgot to do.

00:57:16.200 --> 00:57:17.530
I don't actually have code for it.

00:57:17.530 --> 00:57:18.650
I just thought of it.

00:57:18.650 --> 00:57:24.180
So I'll just explain it to you
so you guys know you can do this.

00:57:25.370 --> 00:57:25.880
Sorry.

00:57:25.880 --> 00:57:28.980
This is what happens when
all of your stuff gets taken.

00:57:32.060 --> 00:57:35.280
One of the other cool little hacks
I did at one time was to-- with

00:57:35.370 --> 00:57:40.570
the underlay surface stuff-- well,
actually, here.

00:57:40.790 --> 00:57:41.660
We'll do this on the fly.

00:57:41.690 --> 00:57:42.670
This is completely ad hoc.

00:57:42.770 --> 00:57:44.940
Can we go back to the
demo machine real quick?

00:57:45.010 --> 00:57:50.840
So this was not planned, I promise.

00:57:50.980 --> 00:57:53.370
Where is the source?

00:58:00.300 --> 00:58:10.100
[Transcript missing]

00:58:10.700 --> 00:58:15.060
Interface Builder here and pull
up my really ultra-complicated UI.

00:58:15.180 --> 00:58:18.660
One of the cool things I can do is just
take some Cocoa controls and kind of

00:58:18.800 --> 00:58:21.920
drop them in on top of my GL content now.

00:58:30.800 --> 00:58:33.600
I don't know if I'll be able to make
this one do exactly what I want.

00:58:33.600 --> 00:58:40.190
Anybody know how to make
that not draw the background?

00:58:40.200 --> 00:58:42.760
Let's see, actually, if I just do this.

00:58:50.300 --> 00:58:51.540
Oops.

00:58:51.590 --> 00:58:53.300
Save.

00:58:53.300 --> 00:58:56.300
Cross my fingers.

00:58:56.300 --> 00:58:58.300
So now I've got Cocoa Controls
on top of OpenGL.

00:58:58.300 --> 00:59:01.630
In fact,
I can sit down here and type in a

00:59:01.630 --> 00:59:05.300
text edit control on top of OpenGL.

00:59:05.300 --> 00:59:09.300
And again, you know,
you can see the text is all anti-aliased

00:59:09.300 --> 00:59:11.300
on top of the OpenGL content.

00:59:14.130 --> 00:59:15.600
and his little ad hoc demo.

00:59:15.600 --> 00:59:19.260
But I mean, this can be useful, like,
where you've just got, you know,

00:59:19.350 --> 00:59:22.850
you want to pop up a control somewhere
dynamically over your GL content.

00:59:22.920 --> 00:59:24.850
You don't want to have to
open another window for it.

00:59:24.860 --> 00:59:27.120
It's anyway just something
I thought I would-- I can

00:59:27.150 --> 00:59:29.390
paint over the control and...

00:59:29.700 --> 00:59:38.800
[Transcript missing]

00:59:46.340 --> 00:59:49.070
and so I'd like to welcome
Travis back up to go over the roadmap.

00:59:49.200 --> 00:59:56.190
Thank you, Ken.

00:59:56.200 --> 00:59:58.130
Hopefully the mic's working.

00:59:58.200 --> 00:59:58.200
Yes, there it is.

00:59:58.240 --> 01:00:01.390
Yeah,
actually I just want to let you know,

01:00:01.390 --> 01:00:03.200
as you saw, we have a variety of demos.

01:00:03.200 --> 01:00:05.770
And even on stage,
Ken was able to think up things that

01:00:05.770 --> 01:00:08.190
he can do with this new technology,
Quartz Xtreme.

01:00:08.200 --> 01:00:11.470
I think it's very important that
this is really going to be a canvas

01:00:11.470 --> 01:00:13.200
for your imagination as developers.

01:00:13.200 --> 01:00:16.860
Because a lot of the things that you
were unable to do with various types

01:00:16.900 --> 01:00:20.190
of media that were playing back on the
computer are now completely possible.

01:00:20.200 --> 01:00:23.190
So it gives you the opportunity to think
outside the box of your applications

01:00:23.200 --> 01:00:25.200
and do incredible new things.

01:00:25.200 --> 01:00:28.350
And hopefully incredible new things
will really show off the power of

01:00:28.430 --> 01:00:30.200
your application and also Mac OS X.

01:00:30.200 --> 01:00:33.200
What I want to do here real quickly
is point out a couple sessions.

01:00:33.200 --> 01:00:38.200
We have a lot more graphics and
imaging content for you here at WWDC.

01:00:38.280 --> 01:00:42.200
And for people, just in case you have
been in other tracks,

01:00:42.200 --> 01:00:43.200
I'll just quickly show you some
of the things that we've done.

01:00:43.200 --> 01:00:46.840
I'll just quickly step through most
of the sessions that we have planned

01:00:46.840 --> 01:00:50.190
today in case you want to view them
later on the DVD or maybe ADC TV.

01:00:50.360 --> 01:00:54.200
Obviously we had the graphics and
imaging overview earlier today.

01:00:54.200 --> 01:00:57.640
And this is where we went over all the
updates that we have in graphics and

01:00:57.640 --> 01:01:00.160
imaging for you at this year's WWDC.

01:01:00.200 --> 01:01:04.200
A lot of announcements,
not just Quartz Xtreme.

01:01:04.200 --> 01:01:07.200
We also talked in depth about
Quartz 2D and our PDF support.

01:01:07.200 --> 01:01:09.200
We also had new announcements there.

01:01:09.200 --> 01:01:10.580
And then obviously this
is today's session,

01:01:10.680 --> 01:01:12.170
503: Exploring the Quartz Compositor.

01:01:12.200 --> 01:01:16.280
Key thing is we've had a lot
of innovations in OpenGL,

01:01:16.280 --> 01:01:17.200
such as programmability.

01:01:17.200 --> 01:01:20.200
And there's a session dealing
with OpenGL programmability,

01:01:20.200 --> 01:01:23.200
which helps you leverage the latest
in what some of the hardware,

01:01:23.200 --> 01:01:29.110
such as the GeForce 4 Ti that we've been
demonstrating on today is capable of.

01:01:29.720 --> 01:01:32.270
We also have an interesting
pair of OpenGL sessions,

01:01:32.270 --> 01:01:34.860
which is Integrated Graphics
1 and Integrated Graphics 2.

01:01:34.860 --> 01:01:38.760
A lot of what we've been
doing with Quartz Extreme is

01:01:38.760 --> 01:01:42.590
integrating the visual pipeline
on Mac OS X so that these medias,

01:01:42.590 --> 01:01:46.520
2D, 3D, and multimedia slash video,
are no longer independent

01:01:46.520 --> 01:01:47.160
from one another.

01:01:47.160 --> 01:01:48.640
They can be seamlessly
used and integrated.

01:01:48.640 --> 01:01:52.990
A lot of the techniques that we've
used to create the Quartz Extreme are

01:01:52.990 --> 01:01:57.310
going to be available for you to learn
and use in your own applications.

01:01:57.850 --> 01:02:00.400
And this is where you'll learn the
tricks to create those new applications,

01:02:00.420 --> 01:02:03.980
those new classes of applications that
you can develop that I just spoke about.

01:02:03.980 --> 01:02:07.980
So Integrated Graphics 1,
Integrated Graphics 2, very important,

01:02:07.980 --> 01:02:09.580
particularly Integrated Graphics 2.

01:02:09.580 --> 01:02:13.750
I think a lot more content
relating to how to do compositing,

01:02:13.760 --> 01:02:15.700
advanced compositing,
will be communicated there.

01:02:15.700 --> 01:02:19.320
Obviously, part of what we do in graphics
and imaging is printing.

01:02:19.320 --> 01:02:21.000
We have a lot of information on printing.

01:02:21.000 --> 01:02:24.090
We have a session on Darwin printing,
which is going to talk

01:02:24.180 --> 01:02:26.720
about the CUPS announcement,
the Common Unix Printing System,

01:02:27.040 --> 01:02:29.580
that we talked about in the
Graphics and Imaging Overview.

01:02:29.580 --> 01:02:33.200
Also, we have a bit on ColorSync,
and we're going to actually show

01:02:33.200 --> 01:02:37.280
ColorSync use a lot of the power
of OpenGL to do interesting things

01:02:37.280 --> 01:02:41.270
with dynamic color correction,
doing things like color correcting

01:02:41.270 --> 01:02:43.990
media that you wouldn't think would
be able to be color corrected.

01:02:44.000 --> 01:02:45.430
Thank you.

01:02:45.940 --> 01:02:48.940
We also have a general
printing session on Mac OS X.

01:02:48.940 --> 01:02:51.840
We also have an OpenGL dealing
with advanced 3D.

01:02:51.840 --> 01:02:54.950
And then an important one for anyone
who's doing anything with OpenGL is to

01:02:55.050 --> 01:02:56.300
go to the performance and optimization.

01:02:56.300 --> 01:03:01.430
There's lots of new optimizations in
Mac OS X's OpenGL stack that came about

01:03:01.500 --> 01:03:04.720
because we wanted to develop something
as cutting-edge as the Compositor.

01:03:04.720 --> 01:03:08.220
So that session is going to teach
you a lot of the fast paths through

01:03:08.390 --> 01:03:12.150
the system to get the ultimate of
performance in your applications.

01:03:12.620 --> 01:03:15.180
We also have some announcements
for the Image Capture Framework,

01:03:15.290 --> 01:03:17.980
which is the technology that allows
you to easily use your digital camera,

01:03:17.980 --> 01:03:20.790
plug it in,
and have your digital camera just work.

01:03:21.360 --> 01:03:24.710
Interesting point is we've announced that
Image Capture also supports scanners.

01:03:24.720 --> 01:03:27.570
There's going to be lots of information
on scanner support in Mac OS X as well.

01:03:27.580 --> 01:03:31.670
Then a big one that's important if
you're doing principally 2D stuff is

01:03:31.670 --> 01:03:34.380
graphics and imaging performance tuning.

01:03:34.380 --> 01:03:36.160
You know, big area.

01:03:36.160 --> 01:03:39.660
We get a lot of developer questions on
how do I make my application go faster

01:03:39.670 --> 01:03:41.660
under Mac OS X when drawing graphics.

01:03:41.680 --> 01:03:42.590
We're going to answer a lot of those.

01:03:42.600 --> 01:03:43.740
So we're going to have a lot of
those questions in that session.

01:03:43.760 --> 01:03:46.820
Now, in the remaining ten minutes,
what I'd like to do -- well,

01:03:46.840 --> 01:03:48.950
before I do that,
let me just let you guys know

01:03:49.040 --> 01:03:50.760
how to get in contact with me.

01:03:50.760 --> 01:03:53.760
Again, I'm Travis Brown,
the graphics and imaging evangelist.

01:03:53.760 --> 01:03:56.650
My job is to work with you to help
you adopt technologies like Quartz

01:03:56.650 --> 01:03:59.730
Extreme and also listen to what you need,
what you want out of Apple,

01:03:59.780 --> 01:04:02.900
the types of technologies and
enhancements to the technology

01:04:02.900 --> 01:04:06.680
portfolio that we do have that you'd
like to see us potentially provide.

01:04:06.760 --> 01:04:08.760
So I'm the conduit for that.

01:04:08.770 --> 01:04:10.760
So if you have any questions,
send me an email.

01:04:10.760 --> 01:04:11.760
Travis@apple.com.

01:04:12.620 --> 01:04:12.690
you
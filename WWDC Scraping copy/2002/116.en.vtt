WEBVTT

00:00:09.740 --> 00:00:11.520
Good afternoon and welcome
to this session on USB.

00:00:11.610 --> 00:00:14.460
This is something like the
fourth or fifth year that

00:00:14.500 --> 00:00:17.140
I've spoken at WWDC about USB.

00:00:17.140 --> 00:00:21.840
Most of the people around Apple know
that USB is one of my favorite subjects.

00:00:21.940 --> 00:00:25.710
I worked on the original
USB team that put it on the iMac,

00:00:25.770 --> 00:00:28.000
and I've got to tell you,
even to this day,

00:00:28.010 --> 00:00:29.580
I still have a lot of fun with it.

00:00:29.900 --> 00:00:32.650
So today we're going to talk about,
primarily,

00:00:32.650 --> 00:00:37.080
the things that we're doing with regard
to listening to developer feedback,

00:00:37.150 --> 00:00:40.240
collecting information,
how we're addressing their issues,

00:00:40.240 --> 00:00:43.460
the kinds of tools that we want to work
on and we are working on in the future.

00:00:43.460 --> 00:00:46.070
And we've got a lot of great
stuff to show you today.

00:00:46.080 --> 00:00:48.060
So having said that,
let me bring out Rhoaads

00:00:48.060 --> 00:00:49.710
Hollowell and Fernando Urbinan.

00:01:01.230 --> 00:01:06.200
Welcome.

00:01:06.200 --> 00:01:09.620
Today we're going to do things
probably a little bit differently.

00:01:09.620 --> 00:01:15.260
Rather than trying to tell you
the basic building blocks of doing

00:01:15.260 --> 00:01:18.310
USB development for Mac OS X,
we're going to assume that you know

00:01:18.310 --> 00:01:21.590
some of the basic building blocks,
and we're going to discuss some of

00:01:21.590 --> 00:01:25.220
the issues that we have found over
the last year or so that have been

00:01:25.220 --> 00:01:29.960
the questions and stumbling blocks
for developers with USB drivers in X.

00:01:29.960 --> 00:01:34.440
We also want to share with you some of
the new tools that we have developed

00:01:34.490 --> 00:01:38.950
and some techniques that we have put
together over the past year or so for

00:01:38.950 --> 00:01:43.860
doing some sort of tips and tricks,
if you will, with USB development.

00:01:47.770 --> 00:01:50.260
So here's what we're
going to teach you today.

00:01:50.290 --> 00:01:53.180
We're going to show you
what documentation for

00:01:53.280 --> 00:01:57.170
USB development is available,
which for those of you who are new

00:01:57.170 --> 00:02:00.290
to USB development for Mac OS X,
this will be the place

00:02:00.290 --> 00:02:00.990
where you'll start.

00:02:01.000 --> 00:02:06.090
We're going to show you how to use
open source and the Darwin repository

00:02:06.090 --> 00:02:08.420
to get access to the USB code.

00:02:09.240 --> 00:02:13.760
We're going to teach you a little
bit about I/O service termination,

00:02:13.760 --> 00:02:17.750
which has been one of the stumbling
blocks for people who are developing

00:02:17.750 --> 00:02:20.620
kernel extension drivers for Mac OS X.

00:02:20.760 --> 00:02:24.890
But we're also going to show
you some tips on how to develop

00:02:25.020 --> 00:02:27.300
a codeless kernel extension.

00:02:27.440 --> 00:02:30.940
If you came to the I/O KIPT managing
kernel extension session,

00:02:31.260 --> 00:02:35.770
you heard Dean talk about that you
could write a kernel extension that

00:02:35.870 --> 00:02:40.680
only has the the the the p-list file,
and did not contain any code.

00:02:40.680 --> 00:02:46.070
We're going to show you some specific
examples of how you can use that to

00:02:46.070 --> 00:02:49.160
help you with USB devices in Mac OS X.

00:02:49.160 --> 00:02:52.730
We're going to teach a little
bit about how to diagnose and get

00:02:52.730 --> 00:02:56.600
around exclusive access errors,
which has been one of the biggest

00:02:56.770 --> 00:03:00.040
problems that our developers
have seen with Mac OS X.

00:03:00.250 --> 00:03:05.330
We're going to show you a new tool,
USB Prober for Mac OS X.

00:03:08.700 --> 00:03:12.100
And we're going to do some live
two-machine debugging to show

00:03:12.100 --> 00:03:17.300
you exactly how easy it is to
do two-machine debugging if you

00:03:17.300 --> 00:03:20.430
have to have a kernel driver.

00:03:20.980 --> 00:03:22.180
So first of all, documentation.

00:03:22.180 --> 00:03:25.520
If you are new to
USB development with Mac OS X,

00:03:25.520 --> 00:03:28.580
you need to start with the
basic Darwin documentation.

00:03:28.580 --> 00:03:33.110
Then you move on to understanding
sort of some fundamentals of

00:03:33.110 --> 00:03:35.350
I/O Kit driver development.

00:03:35.360 --> 00:03:38.740
And then finally,
we encourage you to look at the document

00:03:38.800 --> 00:03:41.300
for working with USB device interfaces.

00:03:41.320 --> 00:03:47.340
This document tells you how to develop
USB drivers that run in user space.

00:03:48.020 --> 00:03:51.750
And this is where we prefer
that most people do their work.

00:03:51.840 --> 00:03:55.040
We prefer that you stay out
of the kernel if you can,

00:03:55.040 --> 00:03:58.640
but we understand that sometimes you
have to do some things in the kernel.

00:03:58.640 --> 00:04:04.100
And finally, the overall USB technology
homepage is listed here,

00:04:04.100 --> 00:04:08.110
and all of these URLs will be available
on the main URLs page for the conference.

00:04:10.470 --> 00:04:15.320
There's some tips and tricks
documents that we've developed,

00:04:15.320 --> 00:04:17.860
and we will be developing more,
but these are the ones

00:04:17.860 --> 00:04:19.140
that we have right now.

00:04:19.140 --> 00:04:23.550
We have tips on how to diagnose
matching issues with USB driver

00:04:23.550 --> 00:04:25.340
matching for Mac OS X.

00:04:25.340 --> 00:04:29.150
We have a document for how to make
sense of the various IOCit error

00:04:29.270 --> 00:04:33.520
codes that you might see coming
back from USB calls you might make.

00:04:34.140 --> 00:04:38.500
And issues that people have run
up against with boot time loading

00:04:38.500 --> 00:04:41.110
of their kernel extension drivers.

00:04:43.680 --> 00:04:47.440
Okay, first of all,
let's talk about open source.

00:04:47.450 --> 00:04:53.130
The Darwin repository contains
the entirety of the USB code that

00:04:53.190 --> 00:04:55.240
we develop at Apple Computer.

00:04:55.380 --> 00:04:57.610
At least, we on the USB team develop.

00:04:57.720 --> 00:05:00.040
There are some drivers through
other groups on the team,

00:05:00.040 --> 00:05:04.030
but all of the code that
includes the I/O USB family,

00:05:04.050 --> 00:05:07.260
which the USB core team
is responsible for,

00:05:07.260 --> 00:05:09.580
is open sourced.

00:05:09.860 --> 00:05:13.270
The CVS module for this
is called IOUsbFamily,

00:05:13.270 --> 00:05:15.090
and this is a live CVS module.

00:05:15.100 --> 00:05:19.100
Anytime we check in
changes to the USB family,

00:05:19.100 --> 00:05:22.570
those changes are available for
developers to look at immediately.

00:05:22.580 --> 00:05:31.090
We maintain tags in this repository,
and these tags use the Mac OS X build

00:05:31.170 --> 00:05:39.300
numbers as identifiers for a particular
set of code modules in the USB family

00:05:39.300 --> 00:05:40.940
that match a particular release.

00:05:40.940 --> 00:05:44.340
So, for example,
if you have the latest version of 10.1.4,

00:05:44.340 --> 00:05:47.450
which is,
and you look at the build version

00:05:47.470 --> 00:05:52.960
in the About This Mac dialog box,
you see that that's build version 5Q125.

00:05:52.960 --> 00:05:58.670
There is a tag in the IOUsbFamily
repository that has the same name,

00:05:58.670 --> 00:06:03.830
IOUsbFamily-5Q125,
and that tag corresponds to the

00:06:03.830 --> 00:06:08.400
version of the USB code that
is in that release of Mac OS X.

00:06:09.130 --> 00:06:12.260
Similarly, if you have the Jaguar
CDs that were handed out,

00:06:12.570 --> 00:06:17.880
the tag for that would
be IOUsbFamily-6C35,

00:06:17.880 --> 00:06:21.110
and that's the current Jaguar build.

00:06:21.160 --> 00:06:25.540
And every time a build is released to
the public or seeded to developers,

00:06:25.540 --> 00:06:31.060
we will make sure that we have a
corresponding tag in the USB family,

00:06:31.060 --> 00:06:33.650
so finding the code that
matches what's running on the

00:06:33.650 --> 00:06:35.410
machine should be pretty easy.

00:06:36.910 --> 00:06:38.620
So we're going to have a demo of that.

00:06:38.900 --> 00:06:44.190
Nano's going to show us how to get
to the CVS repository on Darwin.

00:06:44.330 --> 00:06:44.500
Nano?

00:06:44.500 --> 00:06:50.160
First, you need to start at
the new Darwin homepage,

00:06:50.160 --> 00:06:54.280
which is actually at
developer.apple.com slash Darwin.

00:06:54.280 --> 00:07:00.170
And I'm going to traverse really
quickly to where the IO USB family

00:07:00.680 --> 00:07:04.060
module interface to CVS web is.

00:07:04.580 --> 00:07:08.210
All this is also available
from the command line,

00:07:08.210 --> 00:07:09.520
and that's how we use it.

00:07:09.600 --> 00:07:15.180
But the CVS web interface
is pretty easy to deal with.

00:07:15.210 --> 00:07:17.640
So first we go to the
open source project.

00:07:17.640 --> 00:07:21.800
The USB family is part of
the Darwin open source.

00:07:21.800 --> 00:07:26.180
And right here at the top,
you can see the up-to-a-minute

00:07:26.180 --> 00:07:27.940
source in the CVS repository.

00:07:29.750 --> 00:07:35.160
And in the next page,
we see that the CVS web interface

00:07:35.260 --> 00:07:40.980
will allow us to see the actual
repository at the top level.

00:07:40.980 --> 00:07:46.110
On the bottom here,
you see all the projects

00:07:46.230 --> 00:07:49.280
that are part of Darwin.

00:07:49.280 --> 00:07:54.350
If we scroll down to IOUSB family...

00:07:54.530 --> 00:07:58.010
We can click on it,
and then you'll be at the top

00:07:58.010 --> 00:08:00.720
of the IOUsb family repository.

00:08:00.720 --> 00:08:04.370
You can see that we have the CDC driver,
the composite driver,

00:08:04.370 --> 00:08:09.220
our family itself is right here.

00:08:09.220 --> 00:08:10.810
That's where the USB stack is.

00:08:11.460 --> 00:08:17.270
This does not show a file that I just
checked in this morning called readme.rtf

00:08:17.270 --> 00:08:24.740
that I suggest that you read as soon as
you download the IOUsb family in order

00:08:25.420 --> 00:08:29.700
to work with it and see what we're doing.

00:08:29.700 --> 00:08:35.760
It gives you some hints on how to
build a family if you so desire,

00:08:35.780 --> 00:08:40.490
how to build your drivers unstripped,
and any information that

00:08:40.550 --> 00:08:41.440
we want to communicate.

00:08:41.460 --> 00:08:49.240
About our module will be in that file.

00:08:49.240 --> 00:08:53.770
So anytime that you check it out,
you should actually go

00:08:53.770 --> 00:08:56.100
and read the readme file.

00:08:56.100 --> 00:09:00.100
At the bottom,
CVS Web has this interface that

00:09:00.100 --> 00:09:05.380
allows you to select a particular
tag that you want to download

00:09:05.610 --> 00:09:08.500
through the CVS Web interface.

00:09:08.500 --> 00:09:10.340
And as you can see,
here are the tags that

00:09:10.340 --> 00:09:11.430
we were mentioning.

00:09:11.460 --> 00:09:14.690
I'm not going to do
anything else with it.

00:09:14.720 --> 00:09:19.430
I just encourage you to go to the
web interface and download the

00:09:19.430 --> 00:09:22.100
family and see what we're doing.

00:09:22.120 --> 00:09:24.540
Now we can go back to the slide, please.

00:09:24.620 --> 00:09:26.800
Thank you, Nano.

00:09:32.000 --> 00:09:37.070
It's possible with this Darwin repository
for USB family for you as an interested

00:09:37.070 --> 00:09:44.660
USB developer to get live release notes,
if you will, by being notified by email

00:09:44.660 --> 00:09:47.940
anytime anybody at Apple checks
in any code to this family.

00:09:47.940 --> 00:09:50.140
So if you'd like to do that,
here's how you do it.

00:09:50.230 --> 00:09:53.840
You send an email to Majordomo here,
you subscribe saying I want

00:09:53.840 --> 00:09:57.030
the logs for USB family,
and whenever any of us commits

00:09:57.030 --> 00:10:00.360
any changes to the repository,
you can find out all about it.

00:10:01.220 --> 00:10:03.500
And I added this information
to the readme file,

00:10:03.500 --> 00:10:05.170
so you don't need to copy it down.

00:10:05.200 --> 00:10:06.190
There you go.

00:10:06.220 --> 00:10:10.770
We also encourage anyone doing
USB development for Mac OS X to

00:10:10.840 --> 00:10:13.490
subscribe to the USB public list.

00:10:13.560 --> 00:10:17.950
And the way to do that is to
just go to lists.apple.com

00:10:17.950 --> 00:10:20.530
and subscribe to the USB list.

00:10:20.560 --> 00:10:23.720
It also contains an archive,
so if you have any kind of

00:10:23.720 --> 00:10:28.010
beginner-type questions,
we encourage you to search the archives.

00:10:28.060 --> 00:10:33.270
And remind you that if you use this...
If you use this USB mailing list,

00:10:33.290 --> 00:10:39.020
that anytime you reply to someone
else that's replying on the list,

00:10:39.020 --> 00:10:41.780
especially if it's an
internal Apple developer,

00:10:41.780 --> 00:10:44.820
please reply to the entire list.

00:10:44.940 --> 00:10:47.660
Because it's difficult for us
to try to manage individual

00:10:47.660 --> 00:10:49.480
private communication channels.

00:10:51.830 --> 00:10:58.220
Now, I want to remind you,
the IOUsb family repository contains

00:10:58.500 --> 00:11:01.960
A number of Apple drivers,
the Apple Composite driver,

00:11:01.960 --> 00:11:07.410
the Apple Hub driver, the HID driver,
the keyboard driver, mouse driver,

00:11:07.410 --> 00:11:08.170
and so forth.

00:11:08.240 --> 00:11:12.500
The naming conventions that
we use for these drivers,

00:11:12.500 --> 00:11:15.840
some of them begin with the letters I-O.

00:11:15.840 --> 00:11:20.600
For example, the I-O USB HID driver is
a generic HID driver that

00:11:20.740 --> 00:11:23.450
manages generic HID interfaces.

00:11:24.580 --> 00:11:27.180
If the name of the
driver begins with I-O,

00:11:27.180 --> 00:11:29.960
then we encourage you to use
this driver and subclass it.

00:11:30.040 --> 00:11:33.500
And we guarantee that as we
move forward through different

00:11:33.510 --> 00:11:36.510
versions of the operating system,
your driver,

00:11:36.840 --> 00:11:40.540
which is a subclass of this driver,
will remain binary compatible from

00:11:40.780 --> 00:11:43.010
one version of Mac OS X to the next.

00:11:43.040 --> 00:11:47.690
If, however, the name of the driver
begins with the word Apple,

00:11:47.690 --> 00:11:53.020
such as the Apple USB keyboard driver
or the Apple USB Composite driver,

00:11:53.590 --> 00:11:58.580
this is not a driver that is intended to
be subclassed by third-party developers.

00:11:58.690 --> 00:12:03.280
And we don't guarantee that such a
driver will remain binary compatible with

00:12:03.400 --> 00:12:05.190
future versions of the operating system.

00:12:05.630 --> 00:12:08.550
However, because all of this source
code is open sourced,

00:12:08.720 --> 00:12:13.700
feel free to borrow the source code from
our drivers to develop your own drivers.

00:12:14.000 --> 00:12:19.770
But just do not subclass it if the
name of the driver begins with Apple.

00:12:20.280 --> 00:12:23.480
Now I want to talk a little bit about
I/O Kit termination because this has

00:12:23.690 --> 00:12:30.030
been an area that has been problematic
both for some internal Apple drivers

00:12:30.030 --> 00:12:31.400
and for third-party drivers.

00:12:31.400 --> 00:12:35.350
And specifically this is what
happens when a device is unplugged.

00:12:36.550 --> 00:12:42.690
Beginning with OS 10.1,
there were some new I/O Kit mechanisms

00:12:42.810 --> 00:12:48.660
that were added to help facilitate
the process of terminating a driver,

00:12:48.660 --> 00:12:52.040
an I/O Kit driver,
when a device actually went away.

00:12:52.060 --> 00:12:54.760
When your device is
unplugged from the bus,

00:12:54.910 --> 00:12:59.440
we terminate the nub for that device,
which causes a recursive termination

00:12:59.440 --> 00:13:02.090
to terminate the drivers and so forth.

00:13:02.690 --> 00:13:06.040
Before 10.1, it was difficult.

00:13:06.430 --> 00:13:09.530
It was difficult to cleanly
terminate if you had outstanding I.O.

00:13:09.540 --> 00:13:13.210
With 10.1 and going forward,
there are now two new I.O.

00:13:13.210 --> 00:13:16.450
service methods,
will terminate and did terminate.

00:13:16.500 --> 00:13:19.220
One is called near the beginning
of the termination sequence,

00:13:19.220 --> 00:13:22.370
and the other one is called near
the end of the termination sequence.

00:13:22.380 --> 00:13:26.260
And by using these two new
methods in your driver,

00:13:26.260 --> 00:13:30.050
you can cleanly get yourself
out of the I/O Kit tree

00:13:30.050 --> 00:13:34.860
without panicking the kernel,
which was one of the problems.

00:13:34.880 --> 00:13:39.380
We recommend that you... no longer,
particularly in kernel drivers,

00:13:39.520 --> 00:13:42.560
use the kio service
message is terminated.

00:13:42.580 --> 00:13:46.740
So, for example, your driver can contain
a will terminate method,

00:13:47.010 --> 00:13:50.090
and when this method is called,
your driver is inactive.

00:13:50.180 --> 00:13:54.690
If you call is inactive on yourself,
you will see that it returns true.

00:13:54.900 --> 00:13:59.300
At that point,
you need to cancel any outstanding I.O.

00:13:59.300 --> 00:14:02.740
that your driver has pending.

00:14:02.820 --> 00:14:06.290
An interrupt read, for example,
or any kind of asynchronous...

00:14:06.450 --> 00:14:08.740
read or write call to the bus.

00:14:08.860 --> 00:14:12.260
You need to issue the
call to cancel that,

00:14:12.300 --> 00:14:17.120
but you don't necessarily have to
wait for the callback to return.

00:14:17.330 --> 00:14:19.390
Then,
when you get the didTerminate method,

00:14:19.390 --> 00:14:20.460
you need to check.

00:14:20.460 --> 00:14:22.240
Termination is almost complete.

00:14:22.240 --> 00:14:24.390
You need to decide if you
have to go away or not.

00:14:24.460 --> 00:14:27.050
If all the outstanding
I.O., any callbacks,

00:14:27.050 --> 00:14:30.790
any timers, everything that you have that
might be outstanding I.O.

00:14:30.790 --> 00:14:33.950
is complete, then all you have to do
is close your provider,

00:14:33.990 --> 00:14:36.590
and your driver will
automatically get unloaded.

00:14:36.660 --> 00:14:38.520
If, however, there's I.O.

00:14:38.520 --> 00:14:41.900
that is still hanging around,
you need to leave your driver

00:14:41.900 --> 00:14:43.840
open with a flag that says,
OK,

00:14:43.840 --> 00:14:47.780
I still have outstanding I.O., and when
that final piece of outstanding I.O.

00:14:47.780 --> 00:14:51.800
returns, you close your provider,
and your driver will cleanly exit.

00:14:51.800 --> 00:14:54.320
And if you want examples of this,
look at all of the

00:14:54.430 --> 00:14:57.640
Apple-supplied drivers in Darwin,
and you will see how we use

00:14:57.640 --> 00:14:59.640
willTerminate and didTerminate.

00:15:03.030 --> 00:15:04.600
Now, Codeless Kernel Extensions.

00:15:04.600 --> 00:15:06.710
This is something that we've
been talking about on the

00:15:06.710 --> 00:15:11.540
USB list now for a few months,
and we have had people interested

00:15:11.600 --> 00:15:17.230
in this and have been trying
to put together some specific

00:15:17.260 --> 00:15:20.810
examples of how this can be used.

00:15:21.090 --> 00:15:23.710
This is a case where you
create a kernel extension,

00:15:23.800 --> 00:15:27.360
a KEXT project,
that has no code in it at all.

00:15:27.440 --> 00:15:34.630
It only has p-lists, bundle settings,
that will cause I/O Kit to match

00:15:34.630 --> 00:15:40.680
drivers that are already in the system,
whether they're supplied by the

00:15:40.680 --> 00:15:44.380
USB team or by something else,
and it causes a behavior

00:15:44.380 --> 00:15:47.890
change on those drivers,
or a behavior change in

00:15:47.930 --> 00:15:49.480
the default USB system.

00:15:50.190 --> 00:15:54.980
So, where Apple supplies some class
drivers for certain types of devices,

00:15:54.980 --> 00:15:59.860
you can provide a vendor-specific
driver that has no code in it,

00:16:00.160 --> 00:16:04.410
that causes a different driver
to match against your device,

00:16:04.500 --> 00:16:09.950
and therefore changing the functionality
of the Apple-supplied class drivers.

00:16:10.000 --> 00:16:13.980
You can use Project Builder to
create these codeless KEXTs,

00:16:13.980 --> 00:16:18.980
but again, you can make them with no
code in them whatsoever.

00:16:19.320 --> 00:16:23.040
So, for example,
let's say we have a HID device.

00:16:23.080 --> 00:16:26.510
How about a USB to ADB adapter?

00:16:26.620 --> 00:16:31.420
And this device normally publishes
a couple of HID interfaces,

00:16:31.420 --> 00:16:34.080
one for a keyboard, one for a mouse,
but we're not interested

00:16:34.080 --> 00:16:35.280
in these HID interfaces.

00:16:35.300 --> 00:16:38.690
We're not going to use an ADB mouse
or an ADB keyboard on this device.

00:16:38.720 --> 00:16:44.350
Instead, we're going to attach a
special ADB device to this,

00:16:44.380 --> 00:16:49.040
and we want Classic to be
able to grab the USB device,

00:16:49.410 --> 00:16:54.200
and use the ADB with a Classic driver,
a Classic ADB driver,

00:16:54.200 --> 00:17:00.140
to talk to the ADB device that's on here,
and it's neither a keyboard nor a mouse.

00:17:00.140 --> 00:17:05.360
Well, the problem with Mac OS X is that
because the device is a composite device,

00:17:05.380 --> 00:17:09.200
the Apple Composite driver loads,
and then it publishes two interfaces,

00:17:09.200 --> 00:17:12.780
and the HID driver and keyboard driver
match against those two interfaces,

00:17:12.780 --> 00:17:15.550
and Classic cannot get to this device.

00:17:15.580 --> 00:17:19.300
Classic does not, by default,
take any composite device.

00:17:19.320 --> 00:17:22.950
But we want Classic to have this device,
and we don't want the Apple Composite

00:17:22.950 --> 00:17:24.700
driver to have this device.

00:17:24.700 --> 00:17:30.700
So we need to add the Classic must-seize
Boolean to the nub of the device

00:17:30.700 --> 00:17:34.200
to make sure that Classic takes it,
and we also need to make sure

00:17:34.200 --> 00:17:36.940
that the Composite driver does
not try to control the device

00:17:36.940 --> 00:17:40.190
and publish the two interfaces.

00:17:40.500 --> 00:17:42.430
So we need a vendor-specific text.

00:17:42.430 --> 00:17:46.440
Well, here's the personality that we
create for this vendor-specific text.

00:17:46.440 --> 00:17:49.780
There are two personalities in here.

00:17:49.780 --> 00:17:53.800
The first one is an IOService driver.

00:17:53.800 --> 00:17:58.070
We tell it, we give the vendor ID and
product ID for the device,

00:17:58.120 --> 00:18:02.320
and we tell it that the device
driver for this is IOService.

00:18:02.560 --> 00:18:06.060
Now, those of you who have done
text development know that

00:18:06.070 --> 00:18:09.750
IOService is the base class
for almost all I/O Kit drivers.

00:18:09.750 --> 00:18:13.290
In fact, it is the base class
for all I/O Kit drivers,

00:18:13.290 --> 00:18:15.400
and most I/O Kit nubs as well.

00:18:15.760 --> 00:18:20.140
And so the thing about IOService
that is very interesting for this

00:18:20.140 --> 00:18:24.230
particular device is that it has a
start method that has one line of code,

00:18:24.240 --> 00:18:25.400
which is return true.

00:18:25.400 --> 00:18:27.710
And that's exactly what we want.

00:18:27.780 --> 00:18:31.020
We want a driver that
will say that it started,

00:18:31.020 --> 00:18:33.660
but won't actually do
anything with the device.

00:18:33.660 --> 00:18:37.220
So by providing this personality
and telling it that the bundle

00:18:37.270 --> 00:18:41.830
we are using is I/O Kit itself,
we can match IOService to this nub,

00:18:42.170 --> 00:18:43.310
and that's it.

00:18:43.430 --> 00:18:45.350
The driver will just say, yeah,
I'm running this device,

00:18:45.350 --> 00:18:46.320
and will do nothing else.

00:18:46.420 --> 00:18:49.380
It won't open it,
it won't send any information to it,

00:18:49.380 --> 00:18:50.860
it won't communicate with it at all.

00:18:50.890 --> 00:18:54.020
Then there's a second personality,
which uses an Apple-supplied

00:18:54.020 --> 00:18:57.040
driver that's been in the
system since the very beginning.

00:18:57.040 --> 00:19:01.730
And what this driver does is it actually
does not even have a start method,

00:19:01.730 --> 00:19:03.380
it has a probe method.

00:19:03.380 --> 00:19:06.410
This driver's name is AppleUSBMergeNub.

00:19:06.410 --> 00:19:12.660
And the probe method of this driver
takes its own personality dictionary,

00:19:13.320 --> 00:19:16.460
and looks for something called
IOProviderMergeProperties.

00:19:16.460 --> 00:19:18.920
And any properties that
are in that dictionary,

00:19:18.920 --> 00:19:26.270
it puts them into the provider
dictionary of that driver at probe time.

00:19:26.280 --> 00:19:29.320
And then once it's added those
personalities to its provider,

00:19:29.320 --> 00:19:32.340
it returns false, saying, no,
I'm not interested in this device.

00:19:32.420 --> 00:19:36.840
So it comes in, gets probed,
changes the property list of its parent,

00:19:36.970 --> 00:19:40.600
and then goes away without,
but has left a side effect in that the

00:19:40.720 --> 00:19:42.930
property list of its parent has changed.

00:19:43.100 --> 00:19:48.380
So by providing this MergeNub driver with
a property of IOProviderMergeProperties,

00:19:48.530 --> 00:19:52.810
this will then add the classic
must-seize property to the parent.

00:19:52.820 --> 00:19:59.060
Finally, because this personality of this
codeless KEXT needs to compete

00:19:59.450 --> 00:20:04.870
with the AppleUSB composite driver
at boot time or at root time,

00:20:04.880 --> 00:20:08.390
we need to specify the OSBundle
required string of root,

00:20:08.510 --> 00:20:12.880
saying this driver needs to compete
very early in the boot process.

00:20:12.980 --> 00:20:16.720
By providing this
particular property list,

00:20:16.750 --> 00:20:21.820
we can now completely change the
behavior with this USB to ADB dongle.

00:20:25.390 --> 00:20:27.150
Alright,
we're going to have a second example.

00:20:27.150 --> 00:20:31.640
The Apple USB composite driver
matches against any device

00:20:31.900 --> 00:20:33.340
that's a composite device.

00:20:33.440 --> 00:20:39.460
That is, the B device class and the
B device subclass are both

00:20:39.460 --> 00:20:42.840
zero in the device descriptor.

00:20:43.360 --> 00:20:46.290
But there are some
vendor-specific devices,

00:20:46.650 --> 00:20:51.260
that is, the B device class is 255,
that need the same functionality

00:20:51.260 --> 00:20:55.070
that the Apple USB composite
driver already provides.

00:20:55.130 --> 00:20:56.620
And that functionality is twofold.

00:20:56.640 --> 00:21:00.350
It calls set configuration on the
first configuration it can find

00:21:00.350 --> 00:21:04.690
in the configuration descriptor,
and it handles any reconfiguration

00:21:04.690 --> 00:21:07.020
necessary if the device gets reset.

00:21:07.020 --> 00:21:10.020
For example,
if there's a hub that seems to be

00:21:10.110 --> 00:21:13.340
misbehaving and we need to reset the hub,
that causes a reset.

00:21:13.360 --> 00:21:16.360
And that also causes any devices
downstream to also get reset.

00:21:16.510 --> 00:21:21.100
So we want the composite driver to match
against our vendor-specific device.

00:21:21.140 --> 00:21:23.140
This will cause the
interfaces to get created,

00:21:23.140 --> 00:21:27.700
and those interfaces might
be class type interfaces,

00:21:27.700 --> 00:21:30.510
a HID interface or so forth.

00:21:30.920 --> 00:21:36.640
So, here's a personality that matches
against this rainbow dongle that we have.

00:21:36.640 --> 00:21:39.820
And basically it says, okay,
if you see this vendor

00:21:39.820 --> 00:21:44.920
ID and this product ID,
then take the Apple USB composite driver

00:21:44.920 --> 00:21:46.800
and match it against the device nub.

00:21:46.840 --> 00:21:48.250
And that's it.

00:21:48.450 --> 00:21:52.820
And now the Apple USB composite
driver will match against

00:21:53.030 --> 00:21:56.380
a vendor-specific device,
and yet we've added

00:21:56.380 --> 00:21:57.680
no code to the kernel.

00:21:57.680 --> 00:21:59.350
It's using existing code modules.

00:22:04.490 --> 00:22:06.350
Finally, I want to talk a little
bit about USB log.

00:22:06.480 --> 00:22:11.180
People have been using I/O log
for debugging purposes with

00:22:11.280 --> 00:22:13.400
their kernel extensions,
and it's not really

00:22:13.400 --> 00:22:14.630
the purpose of I/O log.

00:22:14.640 --> 00:22:20.050
It's intended to be a way to
get information to the log

00:22:20.050 --> 00:22:23.470
for severe error conditions.

00:22:23.570 --> 00:22:26.960
But we do want people to be
able to use logging as a way

00:22:26.960 --> 00:22:28.730
of debugging kernel extensions.

00:22:28.830 --> 00:22:34.220
So we came up with a replacement
for USB log called I/O log.

00:22:34.930 --> 00:22:35.550
I mean backwards.

00:22:35.550 --> 00:22:37.440
A placement for IOLOG called USB log.

00:22:37.440 --> 00:22:41.940
It uses the same printf style
formatting that IOLOG uses,

00:22:41.940 --> 00:22:43.790
but it adds a filtering mechanism.

00:22:43.790 --> 00:22:48.300
You can specify levels from
1 to 7 for your log messages,

00:22:48.300 --> 00:22:53.060
and then there are back-end processes
that we'll talk about in a minute that

00:22:53.140 --> 00:22:58.180
will take those messages and will strip
out the messages at certain levels.

00:22:59.780 --> 00:23:05.360
Now, the interesting thing about this
is that if you have a klog KEXT,

00:23:05.360 --> 00:23:09.780
which we provide in the SDK,
in your extensions folder,

00:23:09.780 --> 00:23:13.300
then these log messages that you
provide will actually get sent

00:23:13.390 --> 00:23:16.660
to an application and user space,
and in this case it's the new

00:23:16.660 --> 00:23:18.700
USB prober tool that we will show later.

00:23:18.700 --> 00:23:23.020
But, if the klog KEXT is not there,
then your messages will continue to

00:23:23.020 --> 00:23:27.290
go into IOLOG like they always have,
only they'll be stripped to a certain

00:23:27.290 --> 00:23:29.760
level depending on how the family is.

00:23:29.760 --> 00:23:34.500
So, you can have these
messages go into prober,

00:23:34.510 --> 00:23:41.950
and then you can use prober to filter
out the messages in more than one way.

00:23:44.490 --> 00:23:49.050
Now,
the biggest benefit of USB log is that

00:23:49.050 --> 00:23:51.750
it has a really big buffer behind it,
unlike IO log.

00:23:51.760 --> 00:23:54.800
And so you won't miss,
you won't drop any messages,

00:23:54.800 --> 00:23:58.690
even if you tend to spew a lot
of information into this log.

00:23:58.710 --> 00:24:00.540
It's very difficult to
overflow the buffer.

00:24:00.540 --> 00:24:06.290
And the way you use it is you define a
debug level that you're interested in,

00:24:06.290 --> 00:24:08.860
and then you include the IO USB log code.

00:24:09.230 --> 00:24:12.910
Now, one of the neat features of this
is that we've set it up so that if

00:24:12.920 --> 00:24:17.270
you define a debug level of zero,
and compile your code,

00:24:17.650 --> 00:24:23.770
then all of your log messages end
up getting stripped out because

00:24:23.770 --> 00:24:25.320
USB log is actually a macro.

00:24:25.320 --> 00:24:28.620
And if the debug level is zero,
that macro defines to a no-op.

00:24:28.700 --> 00:24:32.140
So that's a way to reduce the
code size of your kernel extension

00:24:32.290 --> 00:24:34.810
when it's time to ship it,
at the expense of not having

00:24:34.810 --> 00:24:36.370
these log messages in it anymore.

00:24:36.380 --> 00:24:38.900
And here's a sample usage of this.

00:24:39.260 --> 00:24:40.270
Log message.

00:24:40.400 --> 00:24:44.150
You'll see that one of the things that
we did in the sample message that we

00:24:44.150 --> 00:24:49.880
have done in most of our own code is
at the beginning of the printf string,

00:24:49.920 --> 00:24:53.390
we put a %s, bracket, %p,
and then we fill those

00:24:53.390 --> 00:24:56.560
strings with a get name,
which is the actual name

00:24:56.560 --> 00:24:59.620
of your class object,
and the this pointer so that

00:24:59.620 --> 00:25:03.270
you can differentiate identical
class objects from each other.

00:25:06.000 --> 00:25:08.280
Okay, I'm going to turn it
over to Fernando Urbina,

00:25:08.560 --> 00:25:11.030
and he's going to talk
about user LAN drivers.

00:25:11.160 --> 00:25:15.080
Thank you.

00:25:17.150 --> 00:25:20.180
Let me go back one slide here.

00:25:20.300 --> 00:25:28.140
I wanted to talk about a couple
of things related to user space

00:25:28.140 --> 00:25:31.600
USB drivers or applications.

00:25:31.700 --> 00:25:36.200
The first thing that you need to do
if you're working with a USB device,

00:25:36.280 --> 00:25:41.290
you need to know when the device shows
up and when that device goes away.

00:25:41.800 --> 00:27:25.300
[Transcript missing]

00:27:26.170 --> 00:27:33.630
One of the questions that we get the most
in the list is from people saying that

00:27:33.770 --> 00:27:37.790
they're writing a user space application,
they try to open their device,

00:27:38.020 --> 00:27:44.590
and they get a KIO return
exclusive error.

00:27:45.200 --> 00:27:53.290
USB and I/O Kit use open
semantics to arbitrate access to

00:27:53.290 --> 00:27:55.880
a USB device or a USB interface.

00:27:56.120 --> 00:28:04.100
This means that only one component can
have access to the device at a time.

00:28:04.310 --> 00:28:07.220
And so, when you get access,
the first thing,

00:28:07.220 --> 00:28:11.160
or you get the access once you
open the device or the interface.

00:28:11.160 --> 00:28:14.610
If somebody else tries to open
that device or the interface,

00:28:14.610 --> 00:28:18.410
they'll get this error,
and they won't be able to use

00:28:18.410 --> 00:28:21.280
it until you close the device.

00:28:21.360 --> 00:28:27.270
So when you get this error, you...

00:28:27.560 --> 00:28:34.310
It probably means that another
KEXT in the kernel has gained access

00:28:34.450 --> 00:28:40.580
to that device before you want it,
or another user client has a device open.

00:28:43.790 --> 00:28:49.160
How can you tell if it's a text or a
user client that has a device open?

00:28:49.160 --> 00:28:53.600
As we'll show in a little bit,
you can use USB prover and the

00:28:53.600 --> 00:29:00.270
IO registry pane of the application
to examine the IO service plane and

00:29:00.680 --> 00:29:03.960
determine who has the device open.

00:29:03.980 --> 00:29:09.680
In this example,
we have an Apple optical USB mouse,

00:29:09.850 --> 00:29:16.080
that's the IO USB device,
and the indented component there

00:29:16.080 --> 00:29:19.120
is the Apple USB composite.

00:29:19.120 --> 00:29:24.390
In the IO service plane,
this means that the Apple USB composite

00:29:24.390 --> 00:29:27.160
is the driver for this device.

00:29:27.160 --> 00:29:31.670
Underneath that driver,
we have the IO USB interface

00:29:31.770 --> 00:29:33.960
for the actual driver.

00:29:33.980 --> 00:29:35.980
The IO USB interface is the
actual interface to the mouse,

00:29:36.100 --> 00:29:41.210
and the Apple USB optical mouse
has matched to that interface,

00:29:41.210 --> 00:29:45.010
and it's the driver for that interface.

00:29:45.560 --> 00:29:51.840
In the case of a user client controlling,
being the driver for a device,

00:29:51.850 --> 00:29:57.480
in this example we have this scanner,
what you will notice is that we

00:29:57.490 --> 00:30:03.000
have the IOU USB device user client
as the driver for the device.

00:30:03.000 --> 00:30:07.570
The user client is actually a
KEXT that provides the interface

00:30:07.570 --> 00:30:10.240
to the user space applications.

00:30:15.200 --> 00:30:18.490
So great,
now you've found that some other object

00:30:18.720 --> 00:30:22.380
has the device that you want access to.

00:30:22.380 --> 00:30:23.340
How do you solve it?

00:30:23.440 --> 00:30:29.310
Well, it depends on whether it's a
kernel extension or a user client.

00:30:29.320 --> 00:30:33.270
In the case of a kernel extension,
like the examples Rhoaads

00:30:33.440 --> 00:30:39.540
was talking about earlier,
you can write a codeless text with just

00:30:39.560 --> 00:30:45.030
having a personality in your infop list.

00:30:45.100 --> 00:30:53.770
The code will then be sent to the device,
which will then be assigned to

00:30:54.210 --> 00:31:01.110
the device and the user will
be able to return the code.

00:31:01.400 --> 00:31:06.330
and its characteristic that it has
of returning true from the start

00:31:06.330 --> 00:31:13.840
method to trump the class driver that
will probably match to that device.

00:31:13.840 --> 00:31:17.730
And by trump I mean that because
it's a vendor-specific KEXT,

00:31:17.770 --> 00:31:24.590
it'll match at a higher criteria and the
system will load that driver instead.

00:31:24.750 --> 00:31:31.570
If, on the other hand,
you have a user client using your device,

00:31:31.570 --> 00:31:36.480
and in most cases,
the user client that is going

00:31:36.570 --> 00:31:40.740
to grab your device is Classic,
then you have two options.

00:31:42.020 --> 00:31:46.440
Like we showed, again,
you can have a codelet text

00:31:46.440 --> 00:31:51.800
that says Classic must not
cease in its info playlist,

00:31:51.800 --> 00:31:56.070
and that will just tell Classic to never,
ever grab your device.

00:31:56.120 --> 00:32:01.980
That's a little drastic,
and there is a better way of doing it.

00:32:02.060 --> 00:32:08.510
In our documentation folder under
your developer tree in the disk,

00:32:08.510 --> 00:32:11.380
we have a document called Classic.

00:32:11.560 --> 00:32:14.390
USB device arbitration.

00:32:14.550 --> 00:32:20.630
You can use that document to implement
the arbitration scheme where you will be

00:32:20.630 --> 00:32:26.780
able to share the device with Classic,
and so the user will have an overall

00:32:26.780 --> 00:32:31.340
better experience because his
device is not shut out from Classic.

00:32:31.340 --> 00:32:36.030
In those cases,
you will be using the USB device

00:32:36.030 --> 00:32:41.850
OpenSees or USB interface
OpenSees to tell Classic that,

00:32:41.940 --> 00:32:45.450
hey, please give up that device or
interface because I really want it,

00:32:45.750 --> 00:32:49.210
and then you go ahead and wait
for it until you can open it.

00:32:52.110 --> 00:32:57.720
In the Jaguar CD that you have,
if you came to the Managing Kernel

00:32:57.980 --> 00:33:04.490
Extension session yesterday,
you'll see that we now have a very rich

00:33:04.490 --> 00:33:10.540
kextload command that does everything
that you ever wanted to do with KEXTs.

00:33:11.320 --> 00:33:19.020
For those of you that are doing kernel
debugging in the current 10.1.4 system,

00:33:19.020 --> 00:33:26.460
it is a pain to generate symbols
with a new kextload command.

00:33:26.460 --> 00:33:29.190
It's really easy,
and later on we'll show you a

00:33:29.190 --> 00:33:30.970
little demo on how it works.

00:33:30.980 --> 00:33:36.470
Again, now with the 1.87 SDK that
was released a few weeks ago,

00:33:36.470 --> 00:33:41.300
we have the kernel login KEXT that
we're very excited about.

00:33:41.300 --> 00:33:46.720
And if you use USB log in your drivers,
you'll get back to the kind of

00:33:46.720 --> 00:33:49.580
login that we had in Mac OS 9.

00:33:51.110 --> 00:33:57.030
And finally, we have USB Prober,
and it's just like old times,

00:33:57.100 --> 00:33:59.310
but even better.

00:34:00.510 --> 00:34:05.250
I would like to bring
out now Nimaa Parivaar.

00:34:05.250 --> 00:34:11.830
He's an intern that works in our system,
sorry, in our team,

00:34:11.950 --> 00:34:15.750
and he wrote USB Prover.

00:34:17.920 --> 00:34:22.970
We just gave him a pile of code,
and he went by himself and produced

00:34:22.970 --> 00:34:24.560
this wonderful application.

00:34:24.560 --> 00:34:28.320
This is the...

00:34:29.650 --> 00:34:31.170
Interface for USB Prober.

00:34:31.350 --> 00:34:33.830
You have four main tabs at the top.

00:34:34.010 --> 00:34:38.480
The bus probe, kernel extensions,
I/O registry, and USB logger.

00:34:38.480 --> 00:34:44.340
We're going to be going
through each of those panes.

00:34:44.340 --> 00:34:50.180
The first pane, the bus probe pane,
shows you all the USB devices

00:34:50.180 --> 00:34:53.570
that are connected to your system.

00:34:54.200 --> 00:34:56.450
We are obviously an application.

00:34:56.450 --> 00:34:57.940
We're from user land.

00:34:57.940 --> 00:35:01.800
And so what we're doing is issuing
device requests to the family

00:35:01.800 --> 00:35:06.560
to get information about all the
devices that are connected there.

00:35:06.560 --> 00:35:12.810
We get the device descriptors,
we parse it, and we present it in a very

00:35:13.660 --> 00:35:15.780
straightforward manner.

00:35:15.780 --> 00:35:18.800
If there are strings,
we go and get the strings.

00:35:18.800 --> 00:35:21.360
We get the configuration descriptor.

00:35:21.360 --> 00:35:24.180
In this example, it's a hit device.

00:35:24.200 --> 00:35:29.510
So there is also a hit
descriptor that we go and get it.

00:35:29.770 --> 00:35:35.350
We parse it, and we go and show it to
you and interpret all the

00:35:35.350 --> 00:35:38.410
fields in the descriptors.

00:35:38.420 --> 00:35:42.480
It's very handy to know what's there.

00:35:42.480 --> 00:35:47.210
We're going to be improving
the tool as we go along,

00:35:47.210 --> 00:35:54.180
so that hopefully it's going to become
a really useful tool for you to use.

00:35:54.200 --> 00:35:56.200
The next tab is the
kernel extensions tab.

00:35:56.200 --> 00:36:01.180
This has two different flavors.

00:36:01.450 --> 00:36:05.550
In this case,
we're showing all USB drivers

00:36:06.120 --> 00:36:07.930
that are in the system.

00:36:07.930 --> 00:36:09.770
We're kind of cheating a little bit.

00:36:09.770 --> 00:36:16.840
We're showing any driver that
has USB as part of its name.

00:36:16.880 --> 00:36:23.190
And we also show the version
number of that driver.

00:36:23.460 --> 00:36:25.710
This is handy when you're doing
developing to know exactly

00:36:25.800 --> 00:36:29.980
what was loaded in the system.

00:36:29.980 --> 00:36:34.340
We also can go ahead and show all the
drivers that are loaded in the system.

00:36:34.340 --> 00:36:40.610
So if your USB driver kernel extension
doesn't have USB in the name,

00:36:40.610 --> 00:36:43.210
you can still go ahead and find it.

00:36:44.920 --> 00:36:48.320
The next pane is the I/O registry pane.

00:36:48.480 --> 00:36:51.380
This has two different flavors, again.

00:36:51.610 --> 00:36:59.210
If we go to the I/O USB plane,
it is a representation of the

00:36:59.210 --> 00:37:02.340
I/O USB plane in the I/O registry.

00:37:02.560 --> 00:37:06.880
This plane shows the
bus topology for USB.

00:37:07.160 --> 00:37:12.340
If you follow the indentations,
it just means that you have a hub that

00:37:12.660 --> 00:37:17.680
has an Apple extended USB keyboard
connected to it and an optical USB mouse,

00:37:17.710 --> 00:37:18.630
etc.

00:37:18.680 --> 00:37:25.750
It's handy to see the bus topology.

00:37:26.180 --> 00:37:31.280
The IOService plane actually
shows the client-provider

00:37:31.280 --> 00:37:34.410
relationship for IOService.

00:37:34.420 --> 00:37:38.600
So here you can actually see,
like I showed in my slide,

00:37:38.630 --> 00:37:42.390
which driver is attached
to a particular device.

00:37:42.540 --> 00:37:48.670
For example, in the iMate,
we can disclose that device and

00:37:48.760 --> 00:37:53.440
see that IOService is indeed,
like Rhoaads showed in

00:37:53.440 --> 00:37:59.860
his Codeless Text example,
the driver for the iMate to USB adapter.

00:37:59.860 --> 00:38:07.140
If we then go and look at the USB token,
again, that is a vendor-specific device,

00:38:07.140 --> 00:38:09.830
and we can go back to
the bus probe window,

00:38:09.920 --> 00:38:13.520
look at the device descriptor,
see that it is indeed a

00:38:13.530 --> 00:38:15.400
vendor-specific device.

00:38:15.400 --> 00:38:18.630
That means that we really don't
have a driver for that device.

00:38:18.760 --> 00:38:23.340
However, I have loaded those kernel
extensions that Rhoaads wrote,

00:38:23.360 --> 00:38:29.350
and we see that the Apple USB composite
actually matched to that device.

00:38:29.420 --> 00:38:32.070
The composite driver,
what it does is reads the

00:38:32.080 --> 00:38:35.200
configuration descriptor,
does a set configuration,

00:38:35.200 --> 00:38:42.040
and that created the
IOSB interface for that device.

00:38:42.060 --> 00:38:46.650
So that was a nice way of modifying
the behavior of our built-in composite

00:38:47.290 --> 00:38:50.040
driver to actually drive your device.

00:38:50.040 --> 00:38:53.950
Finally, we have the USB logger window.

00:38:55.520 --> 00:39:01.120
This is where you will see all the
messages that are displayed by USB log.

00:39:01.260 --> 00:39:05.380
We have the different levels
that you can set up from 1 to 7.

00:39:05.380 --> 00:39:08.040
In this case,
we're going to leave it at 5,

00:39:08.060 --> 00:39:09.830
so we get to see lots of stuff.

00:39:09.920 --> 00:39:11.880
I have a family in this machine compiled.

00:39:11.880 --> 00:39:13.020
We've all logged in on.

00:39:13.020 --> 00:39:19.600
So if we go ahead and start,
and then unplug the token,

00:39:21.080 --> 00:39:26.330
We see the hub driver realizing that
there was a disconnect and blah,

00:39:26.530 --> 00:39:29.800
blah, blah, blah, blah, and everything,
and you can see how we're

00:39:29.800 --> 00:39:32.200
finalizing and aborting pipes.

00:39:32.680 --> 00:39:36.620
Then when he plugs it back in,
we again get a lot of

00:39:36.620 --> 00:39:39.720
information on what is going on.

00:39:39.820 --> 00:39:43.070
There's also this nice filter
button that you can say,

00:39:43.280 --> 00:39:46.760
you know, I want to see only the
lines that contain token.

00:39:47.520 --> 00:39:52.560
And he refreshes that,
and then you can see just your device.

00:39:52.560 --> 00:39:55.630
Or even if you want to put
in your log some specific,

00:39:55.720 --> 00:40:00.410
you know, key that you can then filter,
it's really useful as well.

00:40:02.790 --> 00:40:08.750
You have this and on this Boolean thing
there that you can expand your filter on.

00:40:08.780 --> 00:40:12.950
Finally,
the other thing is when you stop it,

00:40:13.540 --> 00:40:18.040
before you start,
you can decide that you want to

00:40:18.200 --> 00:40:20.340
dump the log to a file as well.

00:40:20.340 --> 00:40:23.130
This comes in handy when you're
actually getting a panic.

00:40:24.220 --> 00:40:35.340
He actually flushes the log to
a file so that when you reboot,

00:40:35.340 --> 00:40:40.190
you'll have the last
few lines in that file.

00:40:40.200 --> 00:40:44.490
And then you can decide
what was going on.

00:40:44.910 --> 00:40:46.760
Anyways, we're really excited about this.

00:40:46.760 --> 00:40:52.140
It is,
if we can go back to the presentation,

00:40:52.140 --> 00:40:53.760
available now.

00:40:54.180 --> 00:40:59.270
And you can go at this obtuse FTP URL.

00:40:59.610 --> 00:41:04.360
I'm going to be sending this
URL to the list because it's

00:41:04.360 --> 00:41:07.100
not in the conference's URL.

00:41:07.100 --> 00:41:10.280
It was written in Cocoa by Nimma.

00:41:10.280 --> 00:41:11.600
He did a tremendous job.

00:41:11.600 --> 00:41:19.420
We're really, really excited about being
able to give you guys this

00:41:19.560 --> 00:41:21.060
because it's written in Cocoa.

00:41:21.060 --> 00:41:22.290
You can print out of it.

00:41:22.290 --> 00:41:23.500
You can cut and paste.

00:41:24.580 --> 00:41:27.380
And in a few weeks,
we are actually going to be

00:41:27.380 --> 00:41:32.040
checking in the code to our
USB family module in Darwin.

00:41:32.040 --> 00:41:36.610
We want to give it a little test
drive inside and fix any obvious

00:41:36.950 --> 00:41:39.600
bugs before we put it out there.

00:41:39.600 --> 00:41:43.420
But then it'll be there.

00:41:43.420 --> 00:41:49.100
Anybody can go and modify it,
and you'll send us any improvements,

00:41:49.100 --> 00:41:51.350
and we'll check them out and put them in.

00:41:57.000 --> 00:42:00.380
Now, you know,
the message is stay out of the kernel,

00:42:00.380 --> 00:42:02.580
stay out of the kernel,
stay out of the kernel.

00:42:02.580 --> 00:42:05.060
However,
sometimes you have to be in the kernel.

00:42:05.060 --> 00:42:09.230
So, for the rest of the presentations,
I'm going to give you a little

00:42:09.230 --> 00:42:15.540
bit of kernel debugging overview.

00:42:15.540 --> 00:42:19.060
And then we're going to go to
the demo machines and actually

00:42:19.070 --> 00:42:21.120
show two-machine debugging.

00:42:21.120 --> 00:42:25.860
You have two types of debugging
when you're developing a kernel.

00:42:26.240 --> 00:42:30.570
And after the fact debugging,
where a customer tells you that your

00:42:30.570 --> 00:42:34.270
kernel extension made his machine panic.

00:42:34.340 --> 00:42:38.160
Or, when you're actually
developing your driver,

00:42:38.160 --> 00:42:42.460
you want to do a little bit of symbolic
debugging to see what's going on.

00:42:42.480 --> 00:42:48.140
In both cases,
you need to generate symbols so that

00:42:48.140 --> 00:42:52.570
you can use GDB to look at your source.

00:42:52.580 --> 00:42:56.200
So,
you have to build the keck-swift symbol.

00:42:56.200 --> 00:43:00.820
And then you actually use kecksload,
the new kecksload,

00:43:00.820 --> 00:43:07.310
to generate the symbol file that has the
actual addresses of the running kecks.

00:43:07.440 --> 00:43:11.870
You can do this either locally
in the machine that is going

00:43:11.870 --> 00:43:13.880
to panic in the future.

00:43:13.880 --> 00:43:18.880
Or, if it was a customer,
you can use the addresses that

00:43:18.880 --> 00:43:25.100
the kernel panic message presented
and generate the symbol file.

00:43:25.570 --> 00:43:28.580
at your, uh, local machine.

00:43:29.120 --> 00:43:31.450
How to build with symbols?

00:43:31.450 --> 00:43:35.800
With the new development tools,
you need to put this huge line.

00:43:35.800 --> 00:43:36.530
Don't worry about it.

00:43:36.620 --> 00:43:38.860
That's in the README that
I spoke about earlier.

00:43:38.860 --> 00:43:50.340
The idea here is that you're building
a kernel extension that is unstripped.

00:43:50.340 --> 00:43:50.470
The results when you run this

00:43:50.600 --> 00:43:59.500
[Transcript missing]

00:44:00.900 --> 00:44:06.500
The syntax to generate the symbol files,
depending whether you are

00:44:06.500 --> 00:44:12.090
running on the machine that is
panicking or on another machine.

00:44:12.920 --> 00:44:18.500
The new user interface presents a
very nice multi-language picture

00:44:18.500 --> 00:44:23.100
that tells the user to reboot
his machine or her machine.

00:44:23.370 --> 00:44:27.760
However, upon reboot,
the old panic message with

00:44:27.760 --> 00:44:30.520
all the addresses that are
interesting for you developers is

00:44:30.590 --> 00:44:32.850
actually saved at this location.

00:44:32.860 --> 00:44:38.770
However, there is a way to disable
this new user interface,

00:44:38.770 --> 00:44:44.620
and it is done by
specifying this command,

00:44:44.620 --> 00:44:46.680
setting the boot
arguments for the machine.

00:44:48.250 --> 00:44:52.500
Again,
you would use these addresses to generate

00:44:52.500 --> 00:44:59.940
the symbol files and then use GDB on the
backtrace to find why it was panicking.

00:45:02.570 --> 00:45:04.810
If the machine is not available,
what you do is you

00:45:04.850 --> 00:45:08.840
generate the symbol file,
then inside of GDB,

00:45:08.840 --> 00:45:12.140
you go and you do an add symbol
file of your symbol file,

00:45:12.140 --> 00:45:19.980
and then do a list, that's the L here,
of the reference address.

00:45:19.980 --> 00:45:24.020
And then it should show you,
as we'll see if the

00:45:24.110 --> 00:45:27.680
demo gods are with us,
a listing of your code

00:45:28.050 --> 00:45:30.150
and the line number.

00:45:31.340 --> 00:45:35.710
If you have the machine available,
I would encourage you to read

00:45:35.730 --> 00:45:40.810
and go through the Hello Debugger
tutorial in the developer site.

00:45:40.840 --> 00:45:45.340
That gets you going on how to do it,
and then all this might

00:45:45.520 --> 00:45:47.660
make a little more sense.

00:45:47.660 --> 00:45:52.700
And we should see if we can do it now.

00:45:52.830 --> 00:45:56.050
What we're going to do is
two kinds of debugging.

00:45:56.060 --> 00:46:06.180
The first kind is a... The first
kind is a debugging while you're

00:46:06.180 --> 00:46:09.180
first starting your driver,
development of your driver.

00:46:09.180 --> 00:46:18.700
So we're going to attempt to break
at the start method of the driver.

00:46:18.800 --> 00:46:19.940
So we have a mouse here.

00:46:21.600 --> 00:46:25.590
That I wrote a kernel extension for.

00:46:25.590 --> 00:46:29.340
And now, on this machine,
what Rhoaads is going to do,

00:46:29.340 --> 00:46:34.520
he is going to load that extension
without the mouse being connected.

00:46:34.520 --> 00:46:40.760
That'll bring it up into,
that'll load it into the kernel,

00:46:40.780 --> 00:46:46.300
and then we'll be able to
generate those symbols.

00:46:46.920 --> 00:46:51.830
We're going to move those symbols
from his machine to my machine.

00:46:52.330 --> 00:46:56.010
And then I'm going to start
GDB and we're going to set a

00:46:56.010 --> 00:46:57.600
breakpoint at the start method.

00:46:57.600 --> 00:47:02.100
Then he's going to go and plug
the mouse in and we'll see that

00:47:02.130 --> 00:47:05.760
we do break in the start method.

00:47:05.760 --> 00:47:09.470
So the first thing he's doing is
he's loading the kernel extension.

00:47:09.480 --> 00:47:13.330
And we have about a minute before it
gets unloaded if we don't plug the mouse.

00:47:17.110 --> 00:47:21.220
Now he is generating the symbols.

00:47:21.280 --> 00:47:24.470
Kexload-S, go ahead.

00:47:24.480 --> 00:47:26.660
We have mounted the...

00:47:28.530 --> 00:47:33.330
We mounted my volume so
the symbols are here.

00:47:33.350 --> 00:47:37.460
So on this other machine,
I'm going to go and gdb

00:47:37.460 --> 00:47:40.340
slash mac underscore kernel.

00:47:44.050 --> 00:47:47.930
Target Remote KDP.

00:47:47.980 --> 00:47:49.300
That's what you need to do.

00:47:49.340 --> 00:47:50.330
Attach.

00:47:50.490 --> 00:47:51.000
Oh, I need the address.

00:47:51.000 --> 00:47:55.290
And I think you can go and do that.

00:47:55.290 --> 00:47:59.030
He's actually hitting the NMI switch now.

00:48:00.000 --> 00:48:05.400
and let's see if we can attach to it.

00:48:06.600 --> 00:48:08.040
Connected.

00:48:08.040 --> 00:48:12.990
You can see on his machine that
his mouse is not moving at all.

00:48:14.540 --> 00:48:22.140
And on my machine, it said connected,
so we are in GDB and we have

00:48:22.780 --> 00:48:24.000
attached to his machine.

00:48:24.000 --> 00:48:28.340
So now,
what we want to do is add the symbol

00:48:28.340 --> 00:48:32.630
file that he created of the kernel
extension that we want to debug.

00:48:32.640 --> 00:48:37.210
So we go add symbol file.

00:48:40.800 --> 00:48:51.800
[Transcript missing]

00:48:55.100 --> 00:48:58.700
You can use tab completion,
which is very nice.

00:48:58.860 --> 00:49:01.800
It tells you if you
really want to add that.

00:49:01.860 --> 00:49:03.610
And we...

00:49:05.300 --> 00:49:06.300
Excuse me.

00:49:06.300 --> 00:49:07.240
We added the symbol file.

00:49:07.240 --> 00:49:12.270
Now we can go ahead and put
a break in the start method.

00:49:12.320 --> 00:49:15.150
So we say break.

00:49:15.460 --> 00:49:22.160
Nanos, Maus, if you hit escape,
question mark, it lists all the methods.

00:49:22.160 --> 00:49:23.760
And I want this.

00:49:25.100 --> 00:49:27.160
The start method.

00:49:27.160 --> 00:49:30.590
And it says the break-on was set.

00:49:30.760 --> 00:49:32.660
I hit continue.

00:49:32.840 --> 00:49:35.810
And now his mouse is working.

00:49:36.010 --> 00:49:38.000
He just plugged in that other mouse.

00:49:38.000 --> 00:49:45.860
And bingo,
we broke up in GDB at Nano's mouse start.

00:49:46.630 --> 00:49:56.200
I can go ahead now and do a list that
will show us where in the code we are.

00:49:56.200 --> 00:50:00.670
We have broken a line 91,
which is right at the

00:50:00.670 --> 00:50:04.510
beginning of the start method.

00:50:05.090 --> 00:50:09.500
Hit next, and it'll just single
step through the code.

00:50:19.900 --> 00:50:23.430
Oh, it's going.

00:50:23.590 --> 00:50:25.740
I hit continue.

00:50:25.760 --> 00:50:29.810
Why don't you go ahead and break
again using the NMI button.

00:50:41.200 --> 00:51:11.000
[Transcript missing]

00:51:24.900 --> 00:51:28.200
Okay, we are back attached to his device.

00:51:28.200 --> 00:51:34.560
What I wanted to do next was
put a break point in actually

00:51:34.560 --> 00:51:35.780
the interrupt handler routine.

00:51:35.780 --> 00:51:40.740
Something that was very hard to do in
Mac OS 9 is to debug interrupt routines

00:51:40.820 --> 00:51:45.060
that are running at an interrupt level.

00:51:45.060 --> 00:51:49.880
So here we can do break nanos.

00:51:49.880 --> 00:51:59.770
Oh, that's right,
we have to add the symbol file.

00:51:59.770 --> 00:51:59.770
Thank you, Rhoaads.

00:52:08.000 --> 00:52:12.000
Nanos, good.

00:52:12.100 --> 00:52:14.010
Nanos Mouse.

00:52:14.620 --> 00:52:20.320
The mouse moved routine is what
actually the interrupt ends up calling.

00:52:23.710 --> 00:52:28.320
Sorry, it's called mouse-- sorry.

00:52:29.010 --> 00:52:31.610
Move mouse.

00:52:31.970 --> 00:52:33.750
Hit continue.

00:52:33.870 --> 00:52:36.390
And the other one.

00:52:40.500 --> 00:52:42.110
We lost control of it.

00:52:42.240 --> 00:52:52.020
Well, we had another demo that we can
use that is actually showing how

00:52:52.020 --> 00:52:56.540
to debug after you get a panic
and you get the panic back trace.

00:52:56.690 --> 00:52:59.890
So if this works,
when he hits the middle button,

00:53:00.030 --> 00:53:03.200
the machine should panic.

00:53:03.270 --> 00:53:04.160
Okay?

00:53:04.180 --> 00:53:06.560
It panicked.

00:53:06.720 --> 00:53:13.670
So what we do now is...

00:53:18.300 --> 00:53:24.520
features of the kexload command
that is in Jaguar is that if you

00:53:24.590 --> 00:53:28.940
take a listing like this that
has a bunch of IOCit modules,

00:53:29.160 --> 00:53:33.320
which include your driver and all
of your driver's dependencies,

00:53:33.340 --> 00:53:36.480
and each module happens to
have a particular address,

00:53:36.480 --> 00:53:40.010
with the new kexload command,
you can actually just,

00:53:40.070 --> 00:53:44.230
kexload will ask you what the
address of every single dependency

00:53:44.230 --> 00:53:46.350
in your dependency chain is.

00:53:46.350 --> 00:53:49.490
So you're no longer typing
kmod sims dash d this,

00:53:49.490 --> 00:53:51.760
dash d that, dash d the other.

00:53:51.810 --> 00:53:54.440
It asks you what each
dependency address is,

00:53:54.440 --> 00:53:57.420
and it builds the symbol
file for you accordingly,

00:53:57.510 --> 00:54:01.480
so that he can actually build the symbol
files on the machine that he's trying

00:54:01.480 --> 00:54:04.680
to use to look at where the panic is.

00:54:04.680 --> 00:54:13.910
So how you do that is, again,
you'd use kexload minus...

00:54:15.640 --> 00:54:21.580
Minus S is the directory where you
want to put those symbol files.

00:54:21.580 --> 00:54:25.580
And then...

00:54:26.750 --> 00:54:29.460
The kernel extension.

00:54:29.460 --> 00:54:33.990
Again,
this is my unstripped kernel extension.

00:54:35.400 --> 00:54:47.000
[Transcript missing]

00:54:48.600 --> 00:54:56.300
[Transcript missing]

00:54:57.560 --> 00:54:59.820
And finally, Nano's Mouse.

00:54:59.820 --> 00:55:05.280
1-E-7-6-9-0-0-0

00:55:08.150 --> 00:55:12.330
Okay, it generated those,
it put them in slash part 10.

00:55:12.330 --> 00:55:14.570
So what do you do now?

00:55:14.570 --> 00:55:18.000
You go again into gdb slash mac kernel.

00:55:18.000 --> 00:55:23.070
You add the symbol file.

00:55:27.220 --> 00:55:32.380
and the rest of the software.

00:55:32.400 --> 00:55:33.460
You say yes.

00:55:33.490 --> 00:55:36.630
And now you look at the backtrace

00:55:37.520 --> 00:55:41.540
You find, you know,
the first suspect address.

00:55:41.540 --> 00:55:45.460
In this case,
because Nano's mouse was the first

00:55:46.100 --> 00:55:49.650
kernel extension in that dependency,
that's probably the one

00:55:49.820 --> 00:55:51.500
that caused the panic.

00:55:51.600 --> 00:55:58.550
And so we looked and see which
address looks like it is the culprit,

00:55:58.970 --> 00:56:02.860
and we find 1E7 6B 468.

00:56:02.950 --> 00:56:05.010
That's the fourth
address in the backtrace.

00:56:05.570 --> 00:56:08.500
and we list that.

00:56:10.100 --> 00:56:13.450
That's why we panicked,
because we had an IO panic

00:56:13.530 --> 00:56:15.150
instruction there.

00:56:15.150 --> 00:56:21.060
But again, this tells us that it's
in the move mouse method,

00:56:21.460 --> 00:56:23.560
line 569.

00:56:23.560 --> 00:56:28.360
You notice 569 is the line
after the actual panic occurred.

00:56:29.360 --> 00:56:35.680
You could actually also display
the actual PowerPC instruction

00:56:35.680 --> 00:56:43.630
by typing the address,
minus 4, and then you can see that the

00:56:43.630 --> 00:56:43.630
address is in the move mouse mode.

00:56:44.900 --> 00:56:49.860
and it's a call to the IO panic.

00:56:49.900 --> 00:56:55.440
You can, again, use GDB to look at the
previous 40 instructions.

00:56:55.480 --> 00:57:00.780
We could also look at the
next address in the backtrace,

00:57:00.780 --> 00:57:03.070
which was...

00:57:03.900 --> 00:57:10.300
[Transcript missing]

00:57:10.880 --> 00:57:16.030
and you see that it is actually in
our interoperable handler routine,

00:57:16.030 --> 00:57:21.610
line 821, but it's actually line 820
where we called moveMouse,

00:57:21.610 --> 00:57:24.680
which is the...

00:57:25.620 --> 00:57:27.870
The reason we panic because
we put this IO panic.

00:57:27.870 --> 00:57:32.650
Of course, when you have your KEXT,
and obviously you're

00:57:32.650 --> 00:57:37.310
not calling IO panic,
you have to do a little detective work

00:57:37.310 --> 00:57:41.210
to figure out why you were panicking.

00:57:41.220 --> 00:57:47.760
But at least this gives you an
idea of how to use GDB symbol files

00:57:47.760 --> 00:57:51.380
to determine what was going on.

00:57:52.090 --> 00:57:55.120
I apologize with the previous demo.

00:57:55.120 --> 00:57:59.030
We were going to show you
you can use print of the

00:57:59.030 --> 00:58:03.220
referencing that this pointer,
and then you'll get access to

00:58:03.560 --> 00:58:05.500
all the fields in your method.

00:58:05.500 --> 00:58:08.500
You can then see what their values are.

00:58:08.500 --> 00:58:14.470
One of the particularly important
fields is the retain count of the

00:58:14.470 --> 00:58:19.820
object because a lot of panics,
and I mean a lot of panics,

00:58:19.820 --> 00:58:25.530
happen because somebody released
the object and you didn't go away.

00:58:25.530 --> 00:58:30.700
Your driver didn't go away for X reason,
so that retain count might be zero,

00:58:30.770 --> 00:58:33.780
which means that you have been released
and you have no business being around.

00:58:33.780 --> 00:58:37.540
We can go back to the slides, please.

00:58:40.070 --> 00:58:42.510
Again, these are resources.

00:58:42.600 --> 00:58:46.510
There's the USB Implementers Forum.

00:58:46.800 --> 00:58:52.400
[Transcript missing]

00:58:52.720 --> 00:58:57.100
I don't have a time machine, so,
you know, the only thing I can say

00:58:57.100 --> 00:59:00.940
is tomorrow is the feedback
session for FireWire and USB,

00:59:00.940 --> 00:59:05.840
and we are hoping that you'll come and
give us some feedback on what we're doing

00:59:05.940 --> 00:59:08.590
right and what we're not doing right.

00:59:11.650 --> 00:59:15.040
Craig Keithley is the
evangelist for USB on FireWire.

00:59:15.040 --> 00:59:21.010
You probably all know him,
so Keithley at Apple.com is his...

00:59:22.430 --> 00:59:23.540
Email.

00:59:23.580 --> 00:59:25.600
Again, USB developer list.

00:59:25.600 --> 00:59:28.450
It's a free resource.

00:59:28.470 --> 00:59:31.440
We are always hanging around.

00:59:31.440 --> 00:59:34.160
We try to answer as soon as we can,
but sometimes we're busy,

00:59:34.160 --> 00:59:35.260
so we don't answer right away.

00:59:35.260 --> 00:59:40.750
But we are always reading the emails,
so please use it.
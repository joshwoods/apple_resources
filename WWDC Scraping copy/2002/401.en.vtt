WEBVTT

00:00:10.600 --> 00:00:11.600
Hello everyone.

00:00:11.600 --> 00:00:13.100
Welcome to Java Graphics session.

00:00:13.100 --> 00:00:14.600
My name is Gerard Ziemski.

00:00:14.600 --> 00:00:18.600
I'm Java Classes Engineer and
my responsibility is graphics.

00:00:18.640 --> 00:00:21.600
I would like to welcome
also Vladimir Lotak.

00:00:21.600 --> 00:00:22.600
Vlad, tell us who you are.

00:00:22.600 --> 00:00:24.590
Hi there.

00:00:24.600 --> 00:00:29.600
I work on Java Classes and my specialty
would be anything to do with events.

00:00:29.800 --> 00:00:32.600
Vlad will help me with some demos.

00:00:32.600 --> 00:00:34.590
So, let's get started.

00:00:38.270 --> 00:00:39.430
Session overview.

00:00:39.550 --> 00:00:42.440
In this session we'll cover three topics.

00:00:42.440 --> 00:00:44.500
First of all,
I'll give you a brief introduction

00:00:44.500 --> 00:00:49.400
to Java graphics on Mac OS X for the
benefits of those of you who do not

00:00:49.500 --> 00:00:51.190
know that much about Java graphics.

00:00:51.240 --> 00:00:55.920
And specifically I'll focus on some
of the features Mac OS X provides you.

00:00:56.810 --> 00:00:59.930
Then I will talk about advanced topics.

00:00:59.930 --> 00:01:04.090
In that part I will talk to
you about things that you as a

00:01:04.110 --> 00:01:05.830
developer should be aware of.

00:01:05.980 --> 00:01:10.950
Things that may help you
explain and understand how to

00:01:11.070 --> 00:01:14.080
make the most of your program,
how to make it run the

00:01:14.220 --> 00:01:15.160
fastest as possible.

00:01:15.160 --> 00:01:19.480
And if something goes wrong,
possibly tell you why things go wrong.

00:01:19.680 --> 00:01:25.940
And specifically I will focus on
graphics performance and imaging.

00:01:26.750 --> 00:01:28.640
And then I'll talk about future.

00:01:28.720 --> 00:01:33.460
And there, in that part,
I'll tell you a bit where we come

00:01:33.460 --> 00:01:37.140
from and what we are thinking of
doing next with Java graphics,

00:01:37.140 --> 00:01:39.690
specifically on Mac OS X.

00:01:41.240 --> 00:01:43.780
So let's talk about
Java graphics on Mac OS X.

00:01:43.950 --> 00:01:47.640
Again,
here I will try to inject some of the

00:01:47.700 --> 00:01:53.940
details and implementation specific
details of Mac OS X implementation

00:01:54.210 --> 00:01:56.390
for Java graphics.

00:01:59.270 --> 00:02:01.450
First of all,
you have to realize that our

00:02:01.450 --> 00:02:06.840
implementation of Java graphics on
Mac OS X is based on the Quartz engine.

00:02:07.530 --> 00:02:10.790
When we started working on
Java2D implementation some time ago,

00:02:10.800 --> 00:02:12.060
we had a choice.

00:02:12.160 --> 00:02:16.840
We could have gone with the SAN provided
source code that implemented

00:02:16.890 --> 00:02:19.900
the renderer and its software.

00:02:19.960 --> 00:02:21.500
We could have done that.

00:02:21.600 --> 00:02:25.300
In this way,
we would stay very closely matched with

00:02:25.630 --> 00:02:30.500
what Java graphics looks like and how
it behaves like on other platforms.

00:02:30.540 --> 00:02:34.600
We also had a choice to
base our own implementation

00:02:34.710 --> 00:02:39.910
of Java graphics on Quartz,
and we decided to go with Quartz.

00:02:40.460 --> 00:02:45.340
I'll talk in this part
about three things.

00:02:45.460 --> 00:02:48.470
First, I'll introduce to you
briefly the graphics,

00:02:48.470 --> 00:02:52.400
original graphics object and
what you could do with it.

00:02:52.560 --> 00:02:57.400
Then I'll talk a little bit in more
detail about the Graphics2D features.

00:02:57.550 --> 00:03:00.820
And lastly,
I'll talk to you about specific

00:03:00.820 --> 00:03:06.190
features that Mac OS X brings with
its Java graphics implementation.

00:03:09.860 --> 00:03:11.450
The original graphics object.

00:03:11.650 --> 00:03:15.280
The original graphics object was
primarily designed to be fast

00:03:16.070 --> 00:03:22.040
and the key underlying concept
in graphics was to make it fast,

00:03:22.360 --> 00:03:25.800
all the primitives were
supposed to go over the network.

00:03:25.800 --> 00:03:30.050
So the primitives were limited in scopes,
they were very basic and

00:03:30.050 --> 00:03:31.540
that's what you have.

00:03:31.820 --> 00:03:34.840
With the original graphics
object you could draw lines,

00:03:34.840 --> 00:03:37.800
rectangles, ovals, polygons,
simple graphics primitives,

00:03:37.800 --> 00:03:38.790
but they were fast.

00:03:40.410 --> 00:03:43.280
You had limited access to the color.

00:03:43.390 --> 00:03:46.120
What you basically had was a solid color.

00:03:46.290 --> 00:03:50.420
You could choose whatever you wanted to,
but it had to be a solid color.

00:03:50.710 --> 00:03:53.620
Moreover, transparency,
the alpha channel,

00:03:53.620 --> 00:03:55.840
it was all tricky to access that.

00:03:55.960 --> 00:04:00.170
And in Graphics2D,
that feature has been added to

00:04:00.280 --> 00:04:05.250
make it much more easier for
you to play with transparency.

00:04:06.100 --> 00:04:11.240
Original Graphics Object had
very limited support for images.

00:04:11.350 --> 00:04:14.540
It had only one type of an image,
which in a way makes it

00:04:14.540 --> 00:04:17.640
a little bit simpler,
because with Graphics2D you have,

00:04:17.700 --> 00:04:20.660
I'll talk about this a little bit more,
you have several different buffered

00:04:20.660 --> 00:04:27.600
image types and depending on the platform
and depending on how you use them,

00:04:28.000 --> 00:04:33.220
things may not go as smoothly
as you would want them to be.

00:04:33.220 --> 00:04:36.400
So the basic images support
was there in Graphics Object.

00:04:36.610 --> 00:04:41.940
You could do things like animation
using the producer-consumer model.

00:04:41.940 --> 00:04:46.300
So you could do some interesting
things with Graphics,

00:04:46.340 --> 00:04:50.400
but Graphics2D goes
much more beyond that.

00:04:50.400 --> 00:04:53.500
In text, you had very basic also
support for the text.

00:04:53.500 --> 00:04:57.030
What you could do primarily
was simply draw a string.

00:04:57.030 --> 00:05:00.480
That was about it that you
could do with Graphics.

00:05:00.590 --> 00:05:07.260
So as you can see,
you can do a lot of things with Graphics.

00:05:07.390 --> 00:05:12.230
You can do a lot of things with graphics.

00:05:13.360 --> 00:05:18.100
Graphics2D is, first of all,
highly extensible.

00:05:18.250 --> 00:05:22.670
What that means is if there
is something missing in

00:05:22.670 --> 00:05:27.940
Graphics2D that you wanted to have,
you have interface that are provided

00:05:27.950 --> 00:05:30.130
for you that you can simply implement.

00:05:30.190 --> 00:05:35.990
You can create your own objects,
and you can simply take them,

00:05:35.990 --> 00:05:37.710
plug them in,
and everything else will just work.

00:05:38.080 --> 00:05:39.390
It is also low-level.

00:05:39.520 --> 00:05:45.780
What that means is it gives you an
access to things that really covered

00:05:45.780 --> 00:05:48.160
the basics of what graphics is.

00:05:48.270 --> 00:05:51.350
For example,
with buffered images you have the

00:05:51.350 --> 00:05:53.360
access directly to the pixels.

00:05:53.530 --> 00:05:57.700
You can find information about
the layout of the pixels.

00:05:57.770 --> 00:06:00.940
All of that is encapsulated
in the raster objects,

00:06:01.020 --> 00:06:01.760
color model.

00:06:01.960 --> 00:06:04.770
You can look it up,
and you can find out information about

00:06:04.770 --> 00:06:06.490
this and use it to your advantage.

00:06:06.590 --> 00:06:09.800
So you have an access to really low level

00:06:10.000 --> 00:06:26.100
[Transcript missing]

00:06:26.580 --> 00:06:31.690
If you wanted to implement
modern web browser,

00:06:31.760 --> 00:06:33.500
you could do this.

00:06:33.610 --> 00:06:38.970
The Java advanced images itself,
which we don't have on Mac OS X,

00:06:39.440 --> 00:06:44.770
But Java Advanced Images itself is
implemented on top of Graphics2D.

00:06:46.130 --> 00:06:50.640
They didn't have to implement
their specific native hooks in

00:06:50.640 --> 00:06:52.000
order to do some fancy stuff.

00:06:52.000 --> 00:06:59.820
All of that, the underlying features are
already there in Graphics2D.

00:07:03.810 --> 00:07:06.250
Graphics2D,
in order to understand Graphics2D,

00:07:06.270 --> 00:07:11.200
be really successful using it,
you have to realize and you have to

00:07:11.200 --> 00:07:18.160
really understand three basic principles,
and that is, what is graphic context?

00:07:19.040 --> 00:07:24.340
What are the graphics context attributes
and also the graphics objects?

00:07:24.350 --> 00:07:25.900
So what are those?

00:07:26.050 --> 00:07:30.490
The graphics context is,
you can think of it as the surface.

00:07:30.510 --> 00:07:34.960
If you're drawing whatever it is,
a primitive image, single pixel,

00:07:34.960 --> 00:07:36.660
you have to draw it somewhere.

00:07:36.800 --> 00:07:41.420
That is represented to
you as a graphics context.

00:07:41.690 --> 00:07:46.780
Graphics Context Attributes.

00:07:46.780 --> 00:07:46.780
This lets you control the

00:07:47.130 --> 00:07:51.490
The features of the context itself,
things like what kind of

00:07:51.630 --> 00:07:56.300
color you want to use,
what kind of color model,

00:07:56.410 --> 00:08:01.000
do you want to use transparency or not,
do you want to use

00:08:01.000 --> 00:08:03.290
transformation matrix or not,
those are the graphics

00:08:03.290 --> 00:08:04.260
context attributes.

00:08:04.260 --> 00:08:05.640
You should be familiar with those.

00:08:06.020 --> 00:08:09.140
What is there, what is available,
how to use them?

00:08:09.540 --> 00:08:13.160
Graphics objects,
those refer to the actual

00:08:14.670 --> 00:08:16.640
objects that you can render.

00:08:16.910 --> 00:08:21.270
So those are basically shapes, images,
and text.

00:08:21.690 --> 00:08:26.100
All of them are represented as objects,
and you can do some interesting things

00:08:26.100 --> 00:08:28.680
with them because they're objects.

00:08:28.710 --> 00:08:32.280
Now, if you want to be really
successful with Graphics2D,

00:08:32.280 --> 00:08:35.900
you have to go a little bit beyond that,
and you should have a clear understanding

00:08:36.020 --> 00:08:39.360
of buffered images and transformations.

00:08:39.480 --> 00:08:43.100
And right here,
I'll talk to you a little bit more about

00:08:43.120 --> 00:08:45.790
buffered images and transformations.

00:08:46.090 --> 00:08:49.960
This is a basic concept in Graphics
and if you want to play with them

00:08:49.960 --> 00:08:51.840
and if you want to combine them,
you need to realize

00:08:51.840 --> 00:08:53.740
what effects they have.

00:08:53.840 --> 00:08:58.190
And also it is important to you as a
developer because we do have some bugs.

00:08:58.420 --> 00:09:02.890
So you need to be aware of,
it would be helpful if you knew

00:09:02.950 --> 00:09:08.430
what the effect of combination of
transformations is supposed to be.

00:09:08.470 --> 00:09:10.530
If things go wrong,
you should be able to realize

00:09:10.530 --> 00:09:13.440
that this is probably not because
you're doing something wrong,

00:09:13.440 --> 00:09:16.240
but it's probably because there
is a bug in our implementation

00:09:16.240 --> 00:09:19.080
and then just tell us about this,
we'll fix it.

00:09:23.190 --> 00:09:28.640
So right here I'll tell you--
I'll just give you three examples

00:09:29.550 --> 00:09:32.310
of the Graphics2D features.

00:09:32.820 --> 00:09:35.230
Because our implementation
is based on Quartz,

00:09:35.270 --> 00:09:38.170
you can do all of that in Quartz.

00:09:38.510 --> 00:09:41.700
And on the left I showed you
an example of the concept,

00:09:41.700 --> 00:09:45.400
the name of the concept
as it refers to in Java.

00:09:45.540 --> 00:09:50.850
On the right I show you just bits of
information of what we as Apple had

00:09:50.850 --> 00:09:56.100
to do in order to make it run,
to implement this using Quartz.

00:09:56.260 --> 00:09:59.320
So first, shape objects.

00:10:00.260 --> 00:10:01.200
Shape objects.

00:10:01.200 --> 00:10:04.030
They are primarily defined as paths.

00:10:04.050 --> 00:10:08.680
If you look at Quartz,
everything in there, even a line,

00:10:08.700 --> 00:10:10.200
the line is not just a line.

00:10:10.200 --> 00:10:11.970
It is a path.

00:10:13.210 --> 00:10:15.340
In Graphics2D,
you have an access to that.

00:10:15.480 --> 00:10:16.510
So what is a pad?

00:10:16.780 --> 00:10:18.900
This is a concept of your visual pen.

00:10:18.900 --> 00:10:22.100
You pick up a pen, you put it down,
and you start drawing.

00:10:22.100 --> 00:10:23.900
You start defining a pad.

00:10:24.090 --> 00:10:29.660
The pad can consist of line segments,
can consist of cubic

00:10:29.660 --> 00:10:32.230
and quadratic curves.

00:10:34.260 --> 00:10:37.560
So this is basic concept behind shapes,
but now we have shape

00:10:37.680 --> 00:10:41.290
objects here in Graphics2D,
and that means you can do

00:10:41.290 --> 00:10:42.150
some interesting things.

00:10:42.150 --> 00:10:45.740
For example,
you can use a shape and actually

00:10:45.740 --> 00:10:50.330
use it not only to draw,
but for example to define a clip.

00:10:50.500 --> 00:10:54.270
So we have an example here
where we had a glyph vector,

00:10:54.270 --> 00:10:58.190
and then we simply asked the
glyph vector for its shape,

00:10:58.190 --> 00:11:02.390
and once we had that shape object,
we simply used it not only

00:11:02.390 --> 00:11:05.990
to draw it on the surface,
but to define a clip.

00:11:06.050 --> 00:11:08.370
This is an example.

00:11:09.580 --> 00:11:13.060
So this is an example of objects in Java.

00:11:13.160 --> 00:11:15.350
Now we have an access
also to compositing.

00:11:15.460 --> 00:11:19.190
This is an interesting
feature because nowadays,

00:11:19.190 --> 00:11:22.970
and I'm sure you're familiar
with Aqua Look and Feel,

00:11:23.040 --> 00:11:27.540
so you can see how
many transparencies and

00:11:28.310 --> 00:11:34.300
and Andy Eliasson are involved in
drawing modern graphics user interface.

00:11:34.330 --> 00:11:39.620
You have an access to all of
that through compositing model.

00:11:40.100 --> 00:11:42.330
So for example,
what you can do is you can set

00:11:42.470 --> 00:11:47.740
different transparency values and
then obtain interesting effects.

00:11:47.740 --> 00:11:53.000
If you wanted to implement nice
drag and drop feedback action,

00:11:53.300 --> 00:11:56.710
you can simply render the object
that you're about to drag as a

00:11:56.710 --> 00:12:01.450
translucent image and you can use that
in order to give feedback to the user.

00:12:01.520 --> 00:12:04.380
You can do that very
easily with transparencies.

00:12:09.800 --> 00:12:12.390
and Mike Skipwin.

00:12:12.440 --> 00:12:13.840
Strokes.

00:12:13.860 --> 00:12:17.090
This is another interesting
feature in Java2D.

00:12:17.320 --> 00:12:24.490
You not only can render a line, a path,

00:12:24.600 --> 00:13:15.300
[Transcript missing]

00:13:18.220 --> 00:13:22.300
So beyond Java2D,
because our implementation

00:13:22.300 --> 00:13:24.490
is based on Quartz,

00:13:25.690 --> 00:13:30.290
What is important to you is
to realize that on Mac OS X,

00:13:30.290 --> 00:13:31.560
Windows all double buffered.

00:13:31.560 --> 00:13:35.190
If you use swing application,

00:13:35.530 --> 00:13:41.410
There is a way to turn on or off
double buffering in the swing.

00:13:42.040 --> 00:13:45.360
On Mac OS X,
that operation is set to a no-op.

00:13:45.470 --> 00:13:48.500
You can try and set it
to be double buffered,

00:13:48.580 --> 00:13:52.100
but because the windows on
Mac OS X are already double buffered,

00:13:52.130 --> 00:13:53.380
we don't do anything.

00:13:53.600 --> 00:13:56.660
However,
you may want and try to implement

00:13:56.660 --> 00:13:58.790
your own double buffering mechanism.

00:13:58.910 --> 00:14:02.730
In some instances,
that might be necessary.

00:14:02.890 --> 00:14:07.240
However, most of the time you should
not probably do that.

00:14:07.310 --> 00:14:11.280
What you will end up doing is
simply triple buffer and you

00:14:11.280 --> 00:14:13.630
will pay a penalty for that.

00:14:13.730 --> 00:14:18.450
So, with your application just try
and run it in Mac OS X and see

00:14:18.450 --> 00:14:22.860
whether you really require your
own double buffering mechanism.

00:14:22.970 --> 00:14:25.320
Probably you will not.

00:14:27.380 --> 00:14:29.370
PDF underpinnings.

00:14:29.430 --> 00:14:38.810
Quartz itself uses PDF to describe a
scene in a resolution-independent way.

00:14:39.340 --> 00:14:43.770
What it means is if your
destination context is screen,

00:14:43.770 --> 00:14:48.140
the pixels are actually baked
in at a certain resolution,

00:14:48.140 --> 00:14:51.210
the resolution of the screen,
and that's how it is presented

00:14:51.230 --> 00:14:55.260
then on the final destination,
final context, which is your screen.

00:14:56.020 --> 00:15:02.140
However, you can render your scene

00:15:02.390 --> 00:15:06.660
to a printer, which is a different device
accessible to you from Java2D.

00:15:06.660 --> 00:15:10.420
If you do that,
you're seen as being rendered

00:15:10.420 --> 00:15:13.300
in a resolution-independent way.

00:15:13.860 --> 00:15:17.990
What you could do is then specify,
I don't really want to print it.

00:15:18.080 --> 00:15:21.380
I want to save it, for example,
as a PDF file.

00:15:21.460 --> 00:15:25.380
And what you will get is right
from your Java application,

00:15:25.690 --> 00:15:29.410
Your scene can be rendered
in a PDF file very,

00:15:29.410 --> 00:15:30.780
very easily.

00:15:31.590 --> 00:15:34.500
So somebody asked me yesterday a
question about they had a problem

00:15:34.500 --> 00:15:39.910
and what they wanted to do was
they wanted to do exactly this,

00:15:39.910 --> 00:15:43.330
except they probably didn't realize that

00:15:43.510 --> 00:15:44.780
this support is already in there.

00:15:44.800 --> 00:15:47.810
What they tried to do was,
they tried to render an image,

00:15:47.860 --> 00:15:50.540
they tried to render
a scene into an image,

00:15:50.540 --> 00:15:55.120
and because the printer has much
higher resolution than a screen,

00:15:55.120 --> 00:16:01.700
what they tried to do was they tried to
render their scene in a much bigger image

00:16:01.700 --> 00:16:05.850
so that once they created the image,
once they rendered their

00:16:06.000 --> 00:16:09.250
scene into the image,
they simply wanted to send that

00:16:09.300 --> 00:16:10.880
image right to the printer.

00:16:10.970 --> 00:16:15.360
Now, the problem was they weren't sure
what is the resolution of the printer.

00:16:15.380 --> 00:16:16.170
So that's one of the problems.

00:16:16.180 --> 00:16:19.340
The second problem is once
you render it to the image,

00:16:19.340 --> 00:16:24.450
what you're sending to the
printer then is this huge job.

00:16:25.100 --> 00:16:26.540
An image is simply a bunch of pixels.

00:16:26.540 --> 00:16:27.220
It's a bitmap.

00:16:27.250 --> 00:16:29.080
It's a lot of information
to send to a printer.

00:16:29.080 --> 00:16:31.920
It would be much easier to
simply create a PDF file and

00:16:31.920 --> 00:16:33.700
then send that to the printer.

00:16:38.240 --> 00:16:43.730
Can we take this off, please?

00:16:43.800 --> 00:16:45.240
Go to the slides.

00:16:45.340 --> 00:16:46.900
This one.

00:16:49.800 --> 00:16:51.700
and Fun Support.

00:16:51.760 --> 00:16:57.100
Now again, when we had the source code,
when we were starting to work on

00:16:57.100 --> 00:17:00.290
graphics on Java2D on Mac OS X,

00:17:00.870 --> 00:17:06.470
We also had a choice to go with Sans'
own sort of renderer for the fonts.

00:17:06.620 --> 00:17:07.730
We decided not to.

00:17:07.740 --> 00:17:09.980
We decided to go with Quartz.

00:17:09.980 --> 00:17:13.740
And because of that,
we get beautiful looking,

00:17:13.960 --> 00:17:16.730
beautifully anti-alias fonts.

00:17:17.580 --> 00:17:20.640
That's what we have here in Mac OS X.

00:17:20.720 --> 00:17:22.790
So let's move on.

00:17:22.860 --> 00:17:25.320
So this is the second
part of the session,

00:17:25.320 --> 00:17:26.860
advanced topics.

00:17:26.860 --> 00:17:30.540
I call it advanced,
but it doesn't mean it's difficult.

00:17:30.670 --> 00:17:35.280
It simply means that I'll cover
here some topics that may not be,

00:17:35.540 --> 00:17:38.340
you may not think of them necessarily.

00:17:38.340 --> 00:17:42.330
You may not be aware of them,
but you probably should.

00:17:44.610 --> 00:17:46.580
So I'll talk to you
about rendering hints,

00:17:46.580 --> 00:17:52.100
the graphical context in more detail,
and graphics for acceleration,

00:17:52.200 --> 00:17:55.630
and then I'll give you
some hints and tips.

00:17:57.160 --> 00:17:57.800
Rendering hints.

00:17:57.800 --> 00:18:01.310
First of all,
they're optional to implement.

00:18:01.310 --> 00:18:07.340
On Mac OS X,
we have support for only few hints.

00:18:07.360 --> 00:18:12.940
We have support for text rendering
hints and graphics rendering hints.

00:18:13.500 --> 00:18:18.700
Now, the default settings of these hints
on other platforms is different

00:18:18.790 --> 00:18:20.780
than what it is on Mac OS X.

00:18:20.780 --> 00:18:24.490
That is because on Mac OS X,
we have implemented our

00:18:24.500 --> 00:18:27.990
own Aqua look and feel,
and we wanted that to match

00:18:28.180 --> 00:18:32.080
as closely as possible to the
native Aqua look and feel.

00:18:32.080 --> 00:18:37.040
What that means is we had to turn
anti-aliasing on for the text.

00:18:37.040 --> 00:18:42.900
Otherwise, you would see the buttons with
this ugly non-aliased text.

00:18:43.530 --> 00:18:44.480
It just didn't look good.

00:18:44.480 --> 00:18:46.160
So we had to do this.

00:18:46.210 --> 00:18:49.540
However,
if you know that your application

00:18:49.560 --> 00:18:55.320
does not need to use the hints
and to use the anti-aliasing,

00:18:55.320 --> 00:18:57.040
you can override that.

00:18:57.120 --> 00:19:02.450
You can use the runtime options
for the text and for the graphics,

00:19:02.670 --> 00:19:05.040
and you can set it to false.

00:19:07.600 --> 00:19:10.860
Also, what you could do is,
in your applications,

00:19:10.860 --> 00:19:14.260
once you have the access to
the graphics to the object,

00:19:14.390 --> 00:19:22.250
you can use the setRenderingHint method
and set your hints to whatever you want.

00:19:23.160 --> 00:19:26.600
And lastly,
there are other rendering hints.

00:19:26.610 --> 00:19:31.860
For example,
there is a rendering hint that lets you

00:19:32.200 --> 00:19:37.500
specify what kind of interpolation
to use for your images that you draw

00:19:37.500 --> 00:19:43.040
on a screen and those images are
scaled either upwards or downwards.

00:19:43.250 --> 00:19:47.540
This hint,
the support for it exists in Quartz,

00:19:48.550 --> 00:19:51.340
and the implementation of
this will not be difficult.

00:19:51.340 --> 00:19:54.060
However, that's one of the hints,
for example, that we're missing.

00:19:54.060 --> 00:19:58.710
So, yes, on Mac OS X,
we don't implement all of

00:19:58.720 --> 00:20:03.830
the rendering hints yet,
but we probably will.

00:20:05.750 --> 00:20:07.060
Graphical context.

00:20:07.070 --> 00:20:10.820
Let's talk about this in a little detail.

00:20:10.820 --> 00:20:13.040
Now this is important
for you to understand.

00:20:13.040 --> 00:20:15.420
First of all,
conceptually you have to understand

00:20:15.460 --> 00:20:20.540
that there are two different
types of context depending on the

00:20:20.710 --> 00:20:22.250
What kind of service do they provide?

00:20:22.250 --> 00:20:26.410
You have a source context,
an image for example,

00:20:26.410 --> 00:20:30.010
where its purpose is simply to
serve as a source of the pixels,

00:20:30.010 --> 00:20:32.820
and you simply grab pixels
from the source context,

00:20:32.870 --> 00:20:34.700
and then you do whatever
you want with them.

00:20:34.720 --> 00:20:39.350
And usually what that ends up
being is you simply put them down,

00:20:39.350 --> 00:20:41.820
or your destination context.

00:20:41.820 --> 00:20:46.220
So we have two types of context,
source and destination.

00:20:46.320 --> 00:20:49.890
And then based on their
image representation,

00:20:49.890 --> 00:20:52.720
there also can be of different types.

00:20:52.720 --> 00:20:58.200
Now this comes because in
Java2D you have buffered images.

00:20:58.200 --> 00:21:05.730
And buffered images were added
because there was a need to represent

00:21:07.190 --> 00:21:10.340
platform specific types of images.

00:21:10.410 --> 00:21:14.100
So you have,
you have types of images such as RGB,

00:21:14.100 --> 00:21:22.070
RBGR, and here is where problems
may occur on Mac OS X.

00:21:22.070 --> 00:21:22.070
So, let's look at the problems

00:21:25.690 --> 00:21:30.070
So let's talk about
the flow of the pixels.

00:21:30.310 --> 00:21:37.560
If you think about your Java application,
then this would be this box on the right.

00:21:37.860 --> 00:21:41.460
What you usually do is you
have a source of a pixel,

00:21:41.580 --> 00:21:44.980
whatever it is,
the source context or your graphics

00:21:45.030 --> 00:21:47.760
primitives object that you want to draw.

00:21:47.760 --> 00:21:51.380
They go then and they end up being
drawn on the graphics context,

00:21:51.380 --> 00:21:54.020
the destination in your Java application.

00:21:54.690 --> 00:21:58.980
However,
this is not the end of life of pixels.

00:21:59.280 --> 00:22:03.880
The way they're being displayed on
the screen is they have to be natively

00:22:03.950 --> 00:22:06.860
put almost physically on the screen.

00:22:06.860 --> 00:22:07.960
How does that happen?

00:22:07.990 --> 00:22:14.280
Well, natively there is another context,
the final destination context,

00:22:14.630 --> 00:22:18.520
which represents a window,
which represents screen.

00:22:19.340 --> 00:22:24.840
In Quartz,
that is the native window surface.

00:22:24.970 --> 00:22:28.350
Now the problem here is that

00:22:30.690 --> 00:22:34.160
In Java,
you have the access to many different

00:22:34.260 --> 00:22:38.550
types of context based on their
image representation and also on the

00:22:38.680 --> 00:22:40.600
color space model that you're using.

00:22:40.740 --> 00:22:44.160
However, when we had to implement
this on Mac OS X,

00:22:44.420 --> 00:22:45.820
we were slightly limited.

00:22:45.970 --> 00:22:52.480
So, suppose this is how many different
context types you have in Java.

00:22:53.700 --> 00:23:00.560
Then Quartz can only represent that many,
a subset of original

00:23:00.560 --> 00:23:04.600
Java2D types of context,
can represent only that

00:23:04.600 --> 00:23:07.100
many as a source context.

00:23:07.210 --> 00:23:12.110
Then, again, you take a subset of that,
and this is what Quartz can

00:23:12.110 --> 00:23:14.230
do as a destination context.

00:23:14.270 --> 00:23:18.250
And then yet another step,
you take a subset of that,

00:23:18.250 --> 00:23:23.130
and only this is the subset of
context that Quartz can use in order

00:23:23.130 --> 00:23:25.990
to draw on the final destination.

00:23:26.000 --> 00:23:30.790
So, what is of interest to us is that
natively there are only two context

00:23:30.800 --> 00:23:33.030
types that Quartz can handle.

00:23:33.030 --> 00:23:40.860
And that is the RGB, the integer,
32-bit representation, and RGB,

00:23:40.860 --> 00:23:43.960
16-bit representation.

00:23:44.700 --> 00:23:46.990
So let's go to the demo.

00:23:47.560 --> 00:23:52.080
Can we turn this on?

00:23:52.080 --> 00:23:52.080
Right.

00:23:54.000 --> 00:23:57.500
Let me show you what
that means in practice.

00:23:57.640 --> 00:24:02.280
So, Vlad, what is the buffered image
type we have set right now?

00:24:02.510 --> 00:24:05.760
We are running 16-bit RGB 555.

00:24:05.890 --> 00:24:08.240
So this is what we have it set right now.

00:24:08.240 --> 00:24:10.740
The key point here also
is that the computer,

00:24:10.740 --> 00:24:13.590
the monitor itself is
set to 1000 color mode.

00:24:13.770 --> 00:24:19.080
What this means is if you
refer to this picture,

00:24:19.200 --> 00:24:20.580
All the contexts match.

00:24:20.720 --> 00:24:21.320
Why?

00:24:21.730 --> 00:24:25.850
Because the monitor is set
to thousands colors mode,

00:24:25.920 --> 00:24:27.360
which is 16-bit.

00:24:27.490 --> 00:24:31.680
And then we use a perfect image,
which is 555, which is 16-bit.

00:24:31.810 --> 00:24:38.560
So there's no conversion that needs
to happen anywhere on this path.

00:24:38.670 --> 00:24:39.780
So the pixels just flow.

00:24:39.940 --> 00:24:41.570
So this is the best we can do.

00:24:41.690 --> 00:24:43.650
And what is the frame rate?

00:24:43.740 --> 00:24:47.450
Anywhere in between 120
to 140 frames a second.

00:24:47.630 --> 00:24:49.090
Alright, so let's remember that number.

00:24:49.230 --> 00:24:52.690
Now let's switch to another type.

00:25:02.550 --> 00:25:04.470
Alright,
you can see it's a little bit slower.

00:25:04.600 --> 00:25:06.200
What is the frame rate?

00:25:06.360 --> 00:25:09.400
And that's about half of
what we were getting before,

00:25:09.400 --> 00:25:10.960
70 roughly.

00:25:11.060 --> 00:25:13.540
And the type of the context right there,
the image?

00:25:13.610 --> 00:25:17.740
And we are looking at 32-bit
alpha RGB pre-multiplied.

00:25:17.850 --> 00:25:22.000
So natively, this is a context that
actually Quartz can handle.

00:25:22.120 --> 00:25:23.810
However, the

00:25:23.910 --> 00:25:28.140
Because the computer,
the monitor is set to thousands of modes,

00:25:28.140 --> 00:25:30.240
right now it cannot handle that directly.

00:25:30.360 --> 00:25:33.530
So there needs to be
conversion that takes place,

00:25:33.530 --> 00:25:35.890
and that conversion
takes place right here.

00:25:35.980 --> 00:25:39.710
It doesn't happen in Java,
it happens in Quartz itself,

00:25:39.710 --> 00:25:42.400
but the conversion takes place
and we are losing some speed.

00:25:42.400 --> 00:25:46.900
As you can see,
we only get half of the speed.

00:25:46.980 --> 00:25:48.830
And can we switch to another time?

00:25:48.880 --> 00:25:50.350
Sure.

00:25:55.800 --> 00:26:02.000
Now we are looking at a 32-bit
A BGR pre-multiplied and we are

00:26:02.000 --> 00:26:07.120
about 25% of the original speed,
45 or so frames a second.

00:26:07.170 --> 00:26:09.530
So we are slower yet again.

00:26:09.710 --> 00:26:11.340
Now why?

00:26:11.340 --> 00:26:14.560
You have to realize the key
point here is this is BGR type.

00:26:15.020 --> 00:26:20.190
What that means is for every single
frame we have to walk through every

00:26:20.190 --> 00:26:23.860
single pixel and we have to swap R and B.

00:26:24.000 --> 00:26:29.970
So this is an example where things
go wrong right here in this step.

00:26:30.600 --> 00:26:35.680
This happens in Java code and this is
the code that we are responsible for.

00:26:35.880 --> 00:26:40.760
Right now we are not using things
like Altevec to try and optimize that.

00:26:40.790 --> 00:26:42.590
We could and probably we will.

00:26:42.590 --> 00:26:45.990
So there are things that we can
do about this to speed it up.

00:26:46.460 --> 00:26:51.120
However, right now you just have to
pay penalty and that penalty

00:26:51.250 --> 00:26:53.480
is never going to go away.

00:26:53.480 --> 00:26:58.090
We can make it smaller by trying to
use smarter algorithms but we can

00:26:58.250 --> 00:27:00.480
do things like for example capitals.

00:27:00.500 --> 00:27:03.250
We can cache pixels once we swap R and B.

00:27:03.250 --> 00:27:03.950
Why not?

00:27:04.080 --> 00:27:09.030
Because if you have a buffered image
you have the access to data buffers.

00:27:09.030 --> 00:27:13.010
If you have the access to data
buffers we do not know when you

00:27:13.010 --> 00:27:15.540
can draw directly on those pixels.

00:27:15.540 --> 00:27:17.690
So we cannot detect that.

00:27:19.260 --> 00:27:23.350
What that means is we have to assume
that once you call data buffer,

00:27:23.370 --> 00:27:27.240
you call getRaster, and then you extract
from the data buffer,

00:27:27.330 --> 00:27:30.560
you start manipulating the pixels,
which is the case you

00:27:30.560 --> 00:27:33.470
have to do for animation,
for example.

00:27:33.790 --> 00:27:36.090
We cannot cache that conversion.

00:27:36.260 --> 00:27:39.660
That conversion has to happen
for every single frame.

00:27:39.730 --> 00:27:41.660
So there's penalty, speed penalty.

00:27:41.660 --> 00:27:43.260
It's never going to go away.

00:27:43.390 --> 00:27:46.720
It will get smaller with
better implementations.

00:27:46.840 --> 00:27:47.740
And we can do that.

00:27:47.740 --> 00:27:50.360
We'll work on that.

00:27:50.360 --> 00:27:52.100
Thanks.

00:27:52.130 --> 00:27:53.460
Slides off.

00:27:53.590 --> 00:27:55.640
Can we take slides off here?

00:28:01.900 --> 00:28:05.750
On JavaDev,
there was a thread about three

00:28:05.750 --> 00:28:09.600
weeks ago and some of you asked,
"So what's the deal

00:28:09.600 --> 00:28:10.920
with the Plasma Output?

00:28:11.020 --> 00:28:15.900
Why is it so slow?" And the
reason was actually two-fold.

00:28:15.930 --> 00:28:19.050
First of all, the original,
the Plasma Output uses the

00:28:19.050 --> 00:28:22.900
original image type and it uses
the producer-consumer model,

00:28:22.900 --> 00:28:27.610
which means that when
we try and render that,

00:28:27.610 --> 00:28:33.010
we have to convert that
image into a buffered image.

00:28:33.010 --> 00:28:34.900
So this is where the penalty happens,
first of all,

00:28:34.900 --> 00:28:38.900
because we have to create a buffered
image object for every single frame.

00:28:38.900 --> 00:28:39.850
So we have to do that.

00:28:39.910 --> 00:28:43.900
And also, unfortunately, well,
more fortunately,

00:28:43.900 --> 00:28:47.900
Plasma Output uses the index color model.

00:28:47.960 --> 00:28:51.640
Index color model in back days,
it was used as a sort

00:28:51.640 --> 00:28:52.900
of compression object.

00:28:52.900 --> 00:28:55.590
in order to...

00:28:56.810 --> 00:29:01.540
In order to represent an image
in a smaller number of pixels,

00:29:01.650 --> 00:29:03.600
we had index color.

00:29:03.780 --> 00:29:06.480
So the color was represented
simply by an index,

00:29:06.630 --> 00:29:12.180
by a simple number, as opposed to,
for example, 32-bit value for a pixel.

00:29:12.940 --> 00:29:19.220
However, right now on Mac OS X,
we don't support index images directly.

00:29:19.220 --> 00:29:24.800
So what happens is we have to
convert the index color model

00:29:24.800 --> 00:29:30.290
to the direct color model,
and that incurs a penalty.

00:29:31.060 --> 00:29:35.030
However, there are things you can do
about this as a developer.

00:29:35.250 --> 00:29:39.440
First of all,
important things to realize is that

00:29:41.650 --> 00:29:47.040
So this is just pieces of the
code that are in original applet,

00:29:47.080 --> 00:29:48.260
the Plasma applet.

00:29:48.370 --> 00:29:53.330
What you can do is you can
switch to using buffered images.

00:29:53.360 --> 00:29:56.900
and Don Hardcode the
types of the context.

00:29:56.900 --> 00:30:02.560
Because you never know what can change
in the underlying implementation.

00:30:02.590 --> 00:30:06.350
Quartz may decide to implement
different destination context

00:30:06.360 --> 00:30:10.300
that may be faster and we may
want to switch to them internally.

00:30:10.300 --> 00:30:14.330
So there's a way for you
to obtain the best context

00:30:14.350 --> 00:30:17.510
without hardcoding any values.

00:30:17.850 --> 00:30:20.860
And this is a piece of code
that shows you how to do this.

00:30:20.860 --> 00:30:24.220
So notice there we don't
hardcode anything there,

00:30:24.290 --> 00:30:26.620
especially the type of the context.

00:30:26.700 --> 00:30:28.960
We just ask the system questions.

00:30:28.960 --> 00:30:31.190
Give me your graphics environment.

00:30:31.190 --> 00:30:32.610
Give me your device.

00:30:32.610 --> 00:30:34.410
Give me the configuration.

00:30:34.460 --> 00:30:36.790
And give me the default color model.

00:30:36.960 --> 00:30:40.280
We ask all those questions
and then we create a buffered

00:30:40.280 --> 00:30:42.390
image to represent our context.

00:30:42.390 --> 00:30:44.190
We use that information.

00:30:44.190 --> 00:30:47.720
And then you're guaranteed
that if you do this,

00:30:47.740 --> 00:30:48.520
on Mac OS X,
you're going to get a lot of information.

00:30:48.520 --> 00:30:53.620
And you'll get the best matching context.

00:30:53.620 --> 00:30:58.180
And keep in mind,
if your monitor is set to 32 bit mode,

00:30:58.190 --> 00:31:01.420
millions of colors,
then it will end up being

00:31:01.420 --> 00:31:03.050
the integer ARGB pre.

00:31:03.330 --> 00:31:06.940
And if your monitor is set to 16,
to thousands of colors mode,

00:31:06.950 --> 00:31:12.120
then that will end up
being new short 555 RGB.

00:31:12.120 --> 00:31:15.790
But don't hardcode those values anywhere.

00:31:17.410 --> 00:31:21.500
Can we switch to demo one, please?

00:31:21.910 --> 00:31:30.510
I will show you now the Plasma
Upload as modified by me.

00:31:38.700 --> 00:31:41.970
Vlad is trying to get that ready.

00:31:42.650 --> 00:31:44.640
I'll show you that demo later.

00:31:44.840 --> 00:31:49.480
In the meantime,
let's go to another slide.

00:31:49.780 --> 00:31:50.960
Hardware acceleration.

00:31:50.960 --> 00:31:54.230
This is a topic I like to talk about.

00:31:54.410 --> 00:31:58.280
Hardware acceleration.

00:31:58.280 --> 00:31:58.280
Introduction.

00:31:59.920 --> 00:32:00.970
We ready?

00:32:00.990 --> 00:32:01.090
Mm-hmm.

00:32:01.210 --> 00:32:03.000
Okay,
do you guys want to see the Plasma demo?

00:32:03.000 --> 00:32:04.400
Just speed it up?

00:32:04.400 --> 00:32:07.700
Okay.

00:32:07.700 --> 00:32:10.420
Can we switch, please, to demo one again?

00:32:30.500 --> 00:32:36.510
is a-- it's in that iBook?

00:32:46.910 --> 00:32:50.240
We're running this on the iBooks,
so the frames rates will

00:32:50.240 --> 00:32:51.600
not be as impressive.

00:32:51.710 --> 00:32:56.490
But relatively to each other,
this should still give you an idea.

00:32:56.610 --> 00:33:02.270
Right now we're running at
about 34 frames per second.

00:33:02.650 --> 00:33:04.490
This is the modified version.

00:33:04.600 --> 00:33:08.240
Remember,
the modification was pretty much only

00:33:08.810 --> 00:33:11.310
making sure we're using the correct

00:33:12.120 --> 00:33:12.960
Context type.

00:33:13.200 --> 00:33:13.860
That's all.

00:33:13.860 --> 00:33:18.370
So this is the new one, modified.

00:33:18.430 --> 00:33:21.850
So we get 32, maximum 37.

00:33:21.850 --> 00:33:26.420
And now let's run the original

00:33:45.320 --> 00:33:48.200
This is the original one
running at around 22,

00:33:48.200 --> 00:33:51.360
21, 20 frames per second.

00:33:51.530 --> 00:33:56.450
So you have, there was 35 say versus 22.

00:33:56.730 --> 00:33:58.830
So you have nice,

00:33:58.840 --> 00:34:02.390
Nice increase in speed
by not doing much at all,

00:34:02.390 --> 00:34:04.780
just making sure we're using
the correct image type.

00:34:04.810 --> 00:34:11.780
That's all.

00:34:14.430 --> 00:34:20.100
So let's move on and talk
about hardware acceleration.

00:34:20.250 --> 00:34:23.600
Here we have some demo machines.

00:34:23.690 --> 00:34:27.090
There are dual 1 GHz machines.

00:34:29.000 --> 00:34:34.200
The performance of them is 15 gigaflops.

00:34:34.290 --> 00:34:40.410
One gigaflop is one billion
floating operations per second.

00:34:41.510 --> 00:34:45.830
You may be surprised to know that
there is actually equally faster

00:34:45.830 --> 00:34:50.290
CPU sitting right in there in this box,
and that is the graphics video card.

00:34:50.420 --> 00:34:55.310
Those computers have GeForce
4 MX video graphics card,

00:34:55.530 --> 00:35:00.340
which have performance of 15 gigaflops.

00:35:01.000 --> 00:35:03.660
So let's take an advantage of that.

00:35:03.740 --> 00:35:06.100
And this is where hardware
acceleration comes in.

00:35:06.210 --> 00:35:10.440
Normally, this CPU,
this graphical processing unit that sits

00:35:10.550 --> 00:35:13.600
right there on your video graphics card,
is not doing much at all.

00:35:13.680 --> 00:35:19.200
So hardware acceleration is trying
to actually utilize that extra CPU,

00:35:19.200 --> 00:35:20.390
if you will.

00:35:21.110 --> 00:35:26.320
Now, on Mac OS X, there's only one way to
achieve hardware acceleration,

00:35:26.420 --> 00:35:28.900
and that is through OpenGL.

00:35:29.020 --> 00:35:31.200
You'll hear a lot about OpenGL.

00:35:31.290 --> 00:35:34.600
You probably heard about Quartz Extreme.

00:35:34.760 --> 00:35:37.860
So if you are interested
in graphics on Mac OS X,

00:35:37.890 --> 00:35:41.760
I would suggest that you pay attention
to where OpenGL is moving because

00:35:41.760 --> 00:35:47.100
it is going to be an underlying
mechanism for us implementing

00:35:47.100 --> 00:35:49.960
hardware acceleration efforts.

00:35:50.630 --> 00:35:56.430
Because we're using OpenGL,
OpenGL was designed with speed in mind

00:35:56.620 --> 00:36:01.600
as opposed to Quartz where these guys
really pay attention to the quality.

00:36:01.710 --> 00:36:06.320
And you look at every single pixel
and it's just almost hand tweaked

00:36:06.380 --> 00:36:08.590
by these guys to look pretty.

00:36:08.650 --> 00:36:12.360
OpenGL doesn't care much
about anti-alias pixels,

00:36:12.470 --> 00:36:14.500
it cares about the speed.

00:36:14.640 --> 00:36:17.960
So if you use hardware acceleration,
you'll gain the speed but

00:36:17.980 --> 00:36:19.530
you will lose the quality.

00:36:19.590 --> 00:36:22.080
You have to be aware of that.

00:36:22.660 --> 00:36:23.300
The activation.

00:36:23.300 --> 00:36:30.040
Many of you were unhappy with our
decision to use the opt-in mechanism

00:36:30.100 --> 00:36:31.600
for turning on hardware acceleration.

00:36:31.600 --> 00:36:36.600
Because what that means for you is
whenever we introduce a new computer,

00:36:36.600 --> 00:36:38.570
you have to update your application.

00:36:38.600 --> 00:36:46.340
We understood that and we changed
that mechanism to be opt-out.

00:36:46.630 --> 00:36:47.600
So I think we'll be happier with that.

00:36:47.600 --> 00:36:52.600
Once you start playing with this,
please give us feedback on this.

00:36:54.110 --> 00:36:56.340
Heuristic and fallbacks.

00:36:56.340 --> 00:37:00.240
There are things we cannot do
using hardware acceleration yet.

00:37:00.330 --> 00:37:05.690
In those cases, we will have to fall back
on the solder renderer,

00:37:05.750 --> 00:37:06.990
on the Quartz,

00:37:07.580 --> 00:37:11.460
make an under Quartz
itself to render the scene.

00:37:11.460 --> 00:37:16.950
We are using heuristic in order to
determine what we can do using higher

00:37:17.130 --> 00:37:19.970
acceleration and what we can't do.

00:37:19.970 --> 00:37:24.900
For example,
drawing fonts at sizes larger than 24.

00:37:25.040 --> 00:37:26.940
is not going to be hardware accelerated.

00:37:26.960 --> 00:37:28.240
Why not?

00:37:28.370 --> 00:37:34.200
Because the way we hardware accelerate
the text is we render every single

00:37:34.500 --> 00:37:37.800
glyph off screen to an image.

00:37:37.800 --> 00:37:40.520
And then when the time comes
to actually draw the text,

00:37:40.520 --> 00:37:43.320
we are simply extracting those
pieces of the image and we're

00:37:43.320 --> 00:37:44.800
blotting them on the screen.

00:37:44.800 --> 00:37:46.000
So this is very fast.

00:37:46.070 --> 00:37:49.910
However, if you increase the font size,
at a certain point,

00:37:49.910 --> 00:37:53.380
the image we would have to create
in order to represent the glyphs

00:37:53.490 --> 00:37:58.470
is going to be just too big and
is going to be too memory--.

00:38:00.200 --> 00:38:02.430
It would take too much memory
in order to represent that.

00:38:02.570 --> 00:38:06.200
So, for example,
heuristic is the piece of the code

00:38:06.200 --> 00:38:11.970
that determines when we can use our
acceleration and we cannot use it.

00:38:14.000 --> 00:38:16.260
UI framework implications.

00:38:16.260 --> 00:38:20.570
What this refers to is
basically do not double buffer.

00:38:20.570 --> 00:38:24.710
If you want to use hardware acceleration,
do not double buffer because

00:38:24.710 --> 00:38:31.980
OpenGL is a mechanism for
accelerating drawing on screen.

00:38:32.320 --> 00:38:35.670
If you double buffer,
it means that you're rendering a

00:38:35.670 --> 00:38:38.700
scene to buffered image off screen.

00:38:38.700 --> 00:38:41.060
That is not being hardware accelerated.

00:38:41.060 --> 00:38:43.600
We cannot do that yet.

00:38:43.600 --> 00:38:45.900
We will.

00:38:45.900 --> 00:38:49.380
So let me show you then a
demo of hardware acceleration.

00:38:50.990 --> 00:38:52.760
Can we switch to demo one?

00:38:52.760 --> 00:38:54.460
Give it another second, Gerard.

00:38:54.640 --> 00:38:55.790
Another second?

00:38:55.860 --> 00:38:58.060
Okay.

00:38:58.180 --> 00:39:00.560
Can we go back to slides, please?

00:39:04.230 --> 00:39:11.750
Power Acceleration.

00:39:11.750 --> 00:39:11.750
Now, let me tell you... I'll have two
different demos showing two different...

00:39:13.660 --> 00:39:15.990
Two different issues where
hardware acceleration helps.

00:39:16.130 --> 00:39:18.790
First of all, images.

00:39:19.070 --> 00:39:22.940
If you think of the flow of the
pixels in a slightly different way,

00:39:23.030 --> 00:39:25.540
you have to realize that if
you have a buffered image,

00:39:25.540 --> 00:39:30.940
for example, that represents your image,
the pixels live in your RAM.

00:39:31.040 --> 00:39:35.040
In order to show them on the screen,
they have to go through the CPU bus,

00:39:35.150 --> 00:39:37.440
they have to go to the
video graphics card,

00:39:37.540 --> 00:39:39.540
and then from the video
graphics card to the screen.

00:39:39.560 --> 00:39:41.630
That's a long path.

00:39:43.230 --> 00:39:45.940
So what can we do about this?

00:39:46.100 --> 00:39:51.090
Well, with OpenGL,
and this is an implementation detail,

00:39:51.270 --> 00:39:55.630
what you can do is we can represent
the static images as textures.

00:39:55.760 --> 00:39:59.340
So then we upload it once
to the video graphics card,

00:39:59.460 --> 00:40:02.240
then the image, all the pixels,
live right there on the

00:40:02.260 --> 00:40:04.100
video graphics card itself.

00:40:04.190 --> 00:40:08.690
When you want to render that image,
we simply say,

00:40:08.690 --> 00:40:13.940
render the texture with that number,
with that index.

00:40:14.120 --> 00:40:17.800
and then when you think about this,
the flow of the pixel,

00:40:17.800 --> 00:40:21.220
the path the pixels have to go through in
order to be shown on the screen is much,

00:40:21.340 --> 00:40:21.760
much shorter.

00:40:21.760 --> 00:40:25.820
They simply, they already exist,
they live on the video graphics card.

00:40:25.820 --> 00:40:29.840
So in order to be shown to the screen,
they take a very, very short path.

00:40:29.840 --> 00:40:32.020
Right from the video RAM to the screen.

00:40:32.040 --> 00:40:32.390
Boom.

00:40:32.410 --> 00:40:33.050
That's it.

00:40:34.670 --> 00:40:36.600
So this is one aspect of
hardware acceleration.

00:40:36.600 --> 00:40:41.830
Now another one is if you render
simple primitives like drawing lines,

00:40:41.830 --> 00:40:45.000
rectangles,
this is what the hardware--this is what

00:40:45.000 --> 00:40:50.590
the Video Graphics card were designed for
in order to speed up those operations.

00:40:50.840 --> 00:40:54.020
So those are not bus intensive.

00:40:54.030 --> 00:40:56.500
So for example,
the same demo just drawing

00:40:56.500 --> 00:41:01.810
lines on my app book versus on
this dual 1 gigahertz machine,

00:41:01.810 --> 00:41:05.640
the demo that would simply
render lines is not going to

00:41:05.640 --> 00:41:08.170
be that different because...

00:41:08.330 --> 00:41:10.480
The call to draw a line is very simple.

00:41:10.560 --> 00:41:16.360
We just pass four parameters, x, y,
and another x, y, and that's it.

00:41:16.500 --> 00:41:35.000
[Transcript missing]

00:41:38.840 --> 00:41:41.000
ImageTiles demo.

00:41:41.100 --> 00:41:44.680
This one will show off the images.

00:41:52.620 --> 00:41:54.380
So we have an image here.

00:41:54.380 --> 00:41:57.500
Another thing to keep in mind
is with hardware acceleration,

00:41:57.500 --> 00:41:59.790
transformations are for free.

00:42:00.580 --> 00:42:03.370
If you think about software
renderer like Quartz,

00:42:03.370 --> 00:42:07.330
if you apply a transformation matrix,
then every single pixel has to be

00:42:07.330 --> 00:42:11.040
remapped using a software algorithm,
an algorithm in software.

00:42:11.200 --> 00:42:13.090
Here, the hardware will do
all that job for you.

00:42:13.270 --> 00:42:18.300
So, it is a little bit of cheating, but,
well, I'll show you.

00:42:18.310 --> 00:42:22.890
So, we can do this.

00:42:22.890 --> 00:42:22.890
Let's reset that.

00:42:24.440 --> 00:42:27.560
And let's look at the
frame per second rate.

00:42:27.660 --> 00:42:31.490
So we are getting around
300 frames per second.

00:42:31.590 --> 00:42:35.660
Now let me switch
hardware acceleration off.

00:42:41.550 --> 00:42:43.600
This is with hardware acceleration off.

00:42:43.640 --> 00:42:47.060
Now it is Quartz that is
doing all of the work.

00:42:49.050 --> 00:42:52.540
14 frames per second.

00:42:52.640 --> 00:42:55.370
So this is a demo showing you the images.

00:42:55.470 --> 00:42:59.490
Now let me show you a simple demo
that shows you the performance of

00:42:59.530 --> 00:43:03.000
drawing simple graphics primitives.

00:43:03.030 --> 00:43:05.000
Drawing lines.

00:43:05.060 --> 00:43:08.580
So here we have a very
simple 3D model viewer.

00:43:12.450 --> 00:43:21.540
So we have 63 frames per second
and around 1500 lines every frame.

00:43:21.540 --> 00:43:23.620
We have this model,

00:43:26.180 --> 00:43:29.520
So this is how it looks with
hardware acceleration on.

00:43:29.520 --> 00:43:31.500
Let me go back to a very simple model,
Qube.

00:43:31.600 --> 00:43:36.660
There's no perspective here,
so that's why it looks a little weird.

00:43:36.660 --> 00:43:40.370
Let me turn hardware acceleration off.

00:43:47.680 --> 00:43:49.360
So this is with hardware
acceleration off.

00:43:49.360 --> 00:43:53.540
I'm not sure if you can guys tell
whether this looks better or not.

00:43:53.540 --> 00:43:54.800
But this is hardware acceleration off.

00:43:54.910 --> 00:43:58.480
So we're starting with very small,
very simple model.

00:43:58.690 --> 00:44:00.590
This is it.

00:44:02.000 --> 00:44:02.880
This model.

00:44:04.110 --> 00:44:05.980
Look how slow things get.

00:44:09.120 --> 00:44:09.850
and this.

00:44:09.850 --> 00:44:15.490
Now let me turn hardware
acceleration on right here.

00:44:15.490 --> 00:44:19.660
Did you see any difference
in the quality of the model?

00:44:19.840 --> 00:44:23.000
Although, let me turn it off.

00:44:23.040 --> 00:44:26.020
This is the Quartz
hardware acceleration off.

00:44:26.080 --> 00:44:28.870
This is OpenGL hardware acceleration on.

00:44:29.070 --> 00:44:32.800
Now,
if your application cares to draw many,

00:44:32.800 --> 00:44:36.250
many lines per second,
then probably you're not going to miss

00:44:36.580 --> 00:44:42.950
those pixels that are anti-aliased
and look just slightly bit better.

00:44:43.180 --> 00:44:47.440
So there are certain applications
which you can simply not do if you

00:44:47.450 --> 00:44:48.740
do not have hardware acceleration.

00:44:48.740 --> 00:44:53.700
Can we have slides, please?

00:44:58.880 --> 00:45:01.080
That was a demo.

00:45:01.080 --> 00:45:03.090
And now hints and tips.

00:45:03.150 --> 00:45:05.340
Use hardware acceleration if possible.

00:45:05.440 --> 00:45:07.790
Just turn it on, see if it helps.

00:45:07.820 --> 00:45:10.610
If it doesn't help, turn it off,
leave it off, don't worry.

00:45:10.610 --> 00:45:12.900
If it helps, fine, use it.

00:45:12.950 --> 00:45:14.910
Use appropriate image types.

00:45:14.980 --> 00:45:15.910
Don't hard code them.

00:45:15.940 --> 00:45:20.360
I showed you a piece of code that
showed you how to find out what

00:45:20.360 --> 00:45:25.160
is the best representation of
an image on a specific platform.

00:45:25.200 --> 00:45:27.240
It's not platform specific.

00:45:27.330 --> 00:45:28.440
There wasn't any coding there.

00:45:28.440 --> 00:45:30.350
We didn't hard code anything.

00:45:30.460 --> 00:45:31.640
We just asked questions.

00:45:31.640 --> 00:45:34.400
Use clipping if possible.

00:45:34.400 --> 00:45:37.260
If you know there's a scene
where you don't have to bother

00:45:37.260 --> 00:45:40.500
rendering certain parts of it,
use clipping in order to make

00:45:40.500 --> 00:45:44.320
it smaller and easier for the
underlying mechanism to draw.

00:45:44.320 --> 00:45:46.100
Cache fonts objects.

00:45:46.100 --> 00:45:51.070
Creating font objects on Mac OS X in
Java is a very expensive call.

00:45:51.170 --> 00:45:54.730
So if you have to work with fonts,
cache them.

00:45:54.760 --> 00:45:56.620
Don't recreate them.

00:45:56.620 --> 00:45:58.380
Do not double buff.

00:45:58.450 --> 00:46:03.430
and do not mix AWT and swing.

00:46:05.700 --> 00:46:09.720
Now the future.

00:46:09.860 --> 00:46:14.120
1.4 is our future and we're moving there.

00:46:14.350 --> 00:46:21.160
We started working on this and you'll
have a developer preview of our 1.4.

00:46:21.160 --> 00:46:22.420
You can play with this.

00:46:22.600 --> 00:46:25.490
And there are certain
interesting features in 1.4

00:46:25.490 --> 00:46:27.380
that we're looking forward to.

00:46:27.380 --> 00:46:30.220
For example,
Plugable Image I/O Framework.

00:46:30.220 --> 00:46:32.340
This is an interesting feature.

00:46:32.340 --> 00:46:37.230
It makes your application not really
care about understanding what the

00:46:37.410 --> 00:46:45.060
underlying image representation is,
whether it is PNG or JPEG or TIFF.

00:46:45.060 --> 00:46:47.740
Somebody else,
a third party can implement a

00:46:47.860 --> 00:46:51.390
plugin for you and you can simply
use it in your code and your

00:46:51.390 --> 00:46:55.820
application doesn't have to care,
doesn't have to know what is the

00:46:55.820 --> 00:46:58.940
actual representation of the image.

00:46:59.390 --> 00:47:02.320
In 1.4 we also get better
font and text support.

00:47:02.550 --> 00:47:04.840
And now this is an interesting point.

00:47:04.900 --> 00:47:06.910
True type hinted fonts.

00:47:06.920 --> 00:47:11.340
Now you remember me mentioning
to you that we're not using

00:47:11.340 --> 00:47:13.190
the sans solver font renderer.

00:47:13.200 --> 00:47:14.940
We're using Quartz to render fonts.

00:47:14.940 --> 00:47:18.360
So things like this,
they're already there.

00:47:18.520 --> 00:47:21.180
Because we're using Quartz,
because Quartz supports

00:47:21.290 --> 00:47:25.060
true type hinted fonts,
we support true type hinted fonts.

00:47:25.060 --> 00:47:26.920
So we already have that feature.

00:47:27.940 --> 00:47:33.800
Unicode 3.0 binding algorithm,
that will help you if your application

00:47:33.800 --> 00:47:36.060
has to be internationalized.

00:47:36.060 --> 00:47:39.180
If you need to handle
Hebrew or Arabic text.

00:47:40.560 --> 00:47:44.500
This algorithm will help you
determine the layout of the text.

00:47:44.550 --> 00:47:46.490
So it's not a nice feature.

00:47:46.500 --> 00:47:48.500
We're looking forward to having that.

00:47:49.510 --> 00:47:55.610
Also in 1.4 you'll have a
full portrait of Compositing

00:47:55.610 --> 00:48:02.000
Rules support so you can play with
the transparencies and with alphas.

00:48:02.260 --> 00:48:05.940
In more greater detail than was possible.

00:48:05.940 --> 00:48:08.880
And on this slide,
I put these two features

00:48:09.160 --> 00:48:16.100
specifically together because they're
interesting from our point of view.

00:48:16.120 --> 00:48:21.210
First of all, new pipeline architecture,
that is 1.4.

00:48:21.210 --> 00:48:26.290
What that refers to is it gives you,
it tries and cash

00:48:28.120 --> 00:48:30.260
the attributes of the context.

00:48:30.260 --> 00:48:34.260
So if you set a color,
if you change one color to the other,

00:48:34.260 --> 00:48:36.800
it will not invalidate into our pipeline.

00:48:36.800 --> 00:48:43.640
It will try and be smart about this and
not try to invalidate into our pipeline,

00:48:43.640 --> 00:48:47.660
but just the piece of the code that
represents the graphics attributes.

00:48:47.660 --> 00:48:52.560
Now, this is interesting to us because we
already have that in our implementation.

00:48:52.560 --> 00:48:55.960
We already have the
architecture that supports that.

00:48:55.960 --> 00:49:02.660
For those of you who were here last year,
we talked to you about our pen model,

00:49:02.660 --> 00:49:06.460
and this is something that
John Berkey came up with,

00:49:06.460 --> 00:49:08.160
and I helped him implement this.

00:49:08.200 --> 00:49:09.900
Hey, John.

00:49:10.240 --> 00:49:14.050
And so we already have that.

00:49:14.820 --> 00:49:17.220
Volatile Images.

00:49:17.440 --> 00:49:25.200
This is what SAN does in order to
hardware accelerate drawing primitives.

00:49:25.270 --> 00:49:27.690
Again, I just showed you the
hardware acceleration demo.

00:49:27.690 --> 00:49:29.500
We are already doing this.

00:49:29.620 --> 00:49:36.390
Now the difference here is that
because Swing is double buffered,

00:49:36.390 --> 00:49:36.390
they

00:49:36.640 --> 00:49:41.740
decided to optimize off-screen drawing.

00:49:41.790 --> 00:49:48.230
So they came up with this volatile image
object that lets you hardware accelerate

00:49:49.310 --> 00:49:52.960
your scene to off-screen context.

00:49:52.960 --> 00:49:57.690
That's slightly different from
what a hardware acceleration is,

00:49:57.690 --> 00:49:57.690
which

00:49:57.900 --> 00:50:00.890
In our case,
we only have the on-screen context.

00:50:00.890 --> 00:50:05.580
So that's pretty much the difference,
but we can and we will do this as well.

00:50:05.580 --> 00:50:09.920
And the interesting point is that we
already went through much of this,

00:50:09.920 --> 00:50:11.990
so we already know how to do this.

00:50:11.990 --> 00:50:17.040
It will be pretty easy for us to actually
implement a lot of images on Mac OS X.

00:50:19.760 --> 00:50:21.210
And it's really very
similar to what we have.

00:50:21.600 --> 00:50:25.900
They offer fast paths for images,
and so do we.

00:50:25.900 --> 00:50:29.670
And I explained to you why those
static images can be hard to

00:50:29.920 --> 00:50:33.130
accelerate and can be drawn very,
very fast.

00:50:33.140 --> 00:50:36.300
And they support basic 2D operations.

00:50:36.300 --> 00:50:38.660
We go a little bit beyond that.

00:50:38.670 --> 00:50:43.100
We try to optimize more primitives,
but we are so limited.

00:50:43.100 --> 00:50:47.080
But we can certainly do
what Volta images can do.

00:50:47.770 --> 00:50:51.680
And they also cast glyphs
for high-tech performance

00:50:51.800 --> 00:50:57.900
[Transcript missing]

00:50:58.110 --> 00:51:01.440
So these two features are
interesting because you guys

00:51:01.440 --> 00:51:03.750
already actually have them.

00:51:05.840 --> 00:51:08.740
So let's talk about 3D graphics.

00:51:08.770 --> 00:51:13.620
Java3D, as you probably know,
we are working with Sun on that

00:51:13.800 --> 00:51:16.280
and that's what I can tell you.

00:51:16.280 --> 00:51:18.850
We're just working on that.

00:51:19.720 --> 00:51:23.320
Geo4Java,
so what can you do if you actually want

00:51:23.400 --> 00:51:26.300
to do 3D graphics in Java in Mac OS X?

00:51:26.330 --> 00:51:28.730
Well, the answer is Geo4Java.

00:51:28.730 --> 00:51:32.370
And to talk about this,
I would like to invite Ken Russell.

00:51:40.510 --> 00:51:54.500
: So what we'd like to show
you is another demonstration

00:51:54.500 --> 00:51:54.510
of a new feature in JDK 1.4.

00:51:54.700 --> 00:51:57.160
and I are going to talk about
a new application called NewIO.

00:51:57.160 --> 00:51:59.710
NewIO can help accelerate
your graphical applications,

00:51:59.710 --> 00:52:02.900
although not the 2D graphical
applications that you've seen today.

00:52:02.980 --> 00:52:05.840
It can actually help accelerate
3D graphical applications.

00:52:05.840 --> 00:52:08.560
It can also accelerate
non-graphical applications,

00:52:08.560 --> 00:52:14.830
like if you're doing
high-throughput sound.

00:52:15.430 --> 00:52:15.780
Let's fire this up.

00:52:39.710 --> 00:52:41.780
So this is not running off the iBook.

00:52:41.780 --> 00:52:42.370
Oh, it isn't.

00:52:42.380 --> 00:52:42.900
Okay, that's fine.

00:52:42.900 --> 00:52:43.410
No problem.

00:52:43.410 --> 00:52:44.240
That's good.

00:52:48.950 --> 00:52:53.100
Okay, so what we've got here
is a large dataset.

00:52:53.170 --> 00:52:57.660
It's a terrain dataset and this is
actually of the Grand Canyon in Arizona.

00:52:57.960 --> 00:52:59.520
It's a pretty large data set.

00:52:59.520 --> 00:53:03.510
It's about 300 megabytes in size,
and it's too large to fit in main

00:53:03.510 --> 00:53:07.760
memory typically on most computers,
although actually not

00:53:07.910 --> 00:53:09.560
on Mac OS X hardware.

00:53:09.560 --> 00:53:12.730
So what do we have to do?

00:53:12.740 --> 00:53:16.180
We have to take the data set and
downsample it to a reasonable size

00:53:16.220 --> 00:53:19.690
that can actually be processed
by the computer in real time.

00:53:20.600 --> 00:53:25.040
Now, what this application is showing
off is how you can use new I.O.

00:53:25.040 --> 00:53:28.590
to do all of the processing
that's necessary to render this

00:53:28.590 --> 00:53:32.820
terrain data set in real time in
the Java programming language.

00:53:34.100 --> 00:55:40.000
[Transcript missing]

00:55:41.740 --> 00:55:51.680
and David Levy are the two main speakers.

00:55:51.680 --> 00:55:51.680
The first speaker is David Levy,
who is the

00:55:55.190 --> 00:55:59.670
Now what's phenomenal about this is
that you can develop on OS X with

00:55:59.740 --> 00:56:02.610
the great operating system,
the great developer tools,

00:56:02.650 --> 00:56:04.690
and the great OpenGL implementation.

00:56:04.770 --> 00:56:06.820
and you can get really
high performance out of it.

00:56:06.820 --> 00:56:09.020
You can approach C++ speeds.

00:56:09.060 --> 00:56:11.280
We're getting, frankly,
in some of these demo applications,

00:56:11.320 --> 00:56:15.740
90 to 100% of C++ speed at this
point using the Hotspot JVM.

00:56:15.760 --> 00:56:20.750
And you can deploy, in addition to OS X,
you can deploy on any platform

00:56:20.750 --> 00:56:24.960
that has a JDK 1.4 implementation,
which is good for you, the developer,

00:56:24.960 --> 00:56:28.730
because you get more possible
market penetration for your app,

00:56:28.730 --> 00:56:31.390
but you get the advantage of
developing on a great operating

00:56:31.390 --> 00:56:32.840
system with great hardware.

00:56:33.930 --> 00:56:35.840
That's really all I've got to say.

00:56:35.950 --> 00:56:36.800
Thanks, Ken.

00:56:36.840 --> 00:56:37.840
That was great.

00:56:43.990 --> 00:56:45.060
Go back to slides, please.

00:56:45.060 --> 00:56:52.820
That was Ken,
sharing JL for Java and native I.O.

00:56:54.400 --> 00:56:56.430
Now, where to go from here?

00:56:56.510 --> 00:56:59.900
Obviously, there are some interesting
Java sessions that you probably

00:56:59.900 --> 00:57:03.350
should think about attending,
but also,

00:57:03.390 --> 00:57:06.930
if you're interested in graphics,
I would like to reiterate that

00:57:06.930 --> 00:57:11.700
you should pay close attention to
OpenGL and what we are doing with it.

00:57:11.800 --> 00:57:16.900
So, there are many OpenGL sessions
in this year's WWDC.

00:57:16.900 --> 00:57:20.580
I would encourage you to
at least check it out.

00:57:24.300 --> 00:57:29.130
And let's go to Q&A.
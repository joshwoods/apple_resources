WEBVTT

00:00:08.100 --> 00:00:09.000
Good afternoon, everyone.

00:00:09.000 --> 00:00:13.760
Welcome to session 516,
Graphics & Imaging Performance Tuning.

00:00:13.830 --> 00:00:17.800
And the reason we're having this
session this year is because the fact

00:00:17.880 --> 00:00:20.500
that I work in developer relations,
I get a lot of email for developers.

00:00:20.550 --> 00:00:22.040
It's part of my job.

00:00:22.110 --> 00:00:27.200
And a week, or practically a day,
doesn't go by that I don't get an email

00:00:27.200 --> 00:00:31.930
from a developer who is going into
excruciatingly great detail on how I can

00:00:31.930 --> 00:00:36.900
draw lines faster in Quick Draw under
Mac OS 9 than you can do on Mac OS X.

00:00:36.950 --> 00:00:41.200
And a lot of that has to do with
the new visual architecture that's

00:00:41.300 --> 00:00:45.140
in Mac OS X and the fact that
it's a different visual pipeline.

00:00:45.200 --> 00:00:48.350
And we spent a lot of time at this
year's WWC addressing that issue with

00:00:48.350 --> 00:00:51.640
things such as Quartz Extreme and
even optimizations that are in the

00:00:52.130 --> 00:00:55.520
software Quartz compositor that
runs if you don't have a system

00:00:55.540 --> 00:00:57.900
capable of supporting Extreme.

00:00:57.960 --> 00:01:00.070
But the key thing is there's
a two-way street in this.

00:01:00.070 --> 00:01:02.900
It's that since the visual
pipeline is different,

00:01:02.950 --> 00:01:05.540
there are optimizations that
developers need to do to leverage

00:01:05.550 --> 00:01:05.800
that pipeline appropriately.

00:01:05.850 --> 00:01:09.070
And that's what we're going to
be talking about in this session.

00:01:09.200 --> 00:01:11.810
We're going to talk about the tricks
and secrets to unlock some of the

00:01:11.810 --> 00:01:15.760
performance you feel might be trapped
in your applications on Mac OS X.

00:01:15.760 --> 00:01:20.440
So to start the presentation,
I'd like to invite Haroon Shaikh,

00:01:20.440 --> 00:01:22.580
manager of the Quartz
engineering department,

00:01:22.580 --> 00:01:23.510
to the stage.

00:01:27.600 --> 00:01:32.430
Thanks, Travis.

00:01:32.470 --> 00:01:34.070
What are we going to cover today?

00:01:34.210 --> 00:01:36.830
Primarily, we're going to be looking at
performance tuning from the

00:01:36.930 --> 00:01:39.940
perspective of the course compositor,
as Travis mentioned,

00:01:39.980 --> 00:01:44.640
but also look at QuickDraw performance
on Mac OS X for Carbon applications.

00:01:44.700 --> 00:01:47.610
We'll have a few demos,
and the rest of the talk,

00:01:47.640 --> 00:01:51.350
we'll actually spend some time looking
at tips and recommendations from us

00:01:51.480 --> 00:01:55.180
to you on QuickDraw and Quartz 2D.

00:01:56.760 --> 00:02:00.800
So since Mac OS X 10.0,
performance has been an issue.

00:02:00.800 --> 00:02:03.400
10.1 addressed many of those issues.

00:02:03.470 --> 00:02:09.580
Jaguar continues to address many of
the other issues with performance.

00:02:09.760 --> 00:02:12.560
What I'll be doing through the
rest of the talk is punctuating

00:02:12.580 --> 00:02:15.900
the slides with what we've done
with system level optimizations

00:02:16.260 --> 00:02:19.670
and recommendations for you.

00:02:19.840 --> 00:02:23.870
Some of the contents of the talk has
actually come from developers like

00:02:24.140 --> 00:02:26.830
you looking at performance feedback,
some of the things that

00:02:26.930 --> 00:02:29.800
they've been struggling with.

00:02:29.850 --> 00:02:33.910
So your feedback has always been
important and going forward,

00:02:33.910 --> 00:02:37.270
let us know if you still
have performance concerns.

00:02:40.670 --> 00:02:43.160
We're going to be talking about
the quartz compositor today,

00:02:43.220 --> 00:02:46.800
Quartz 2D, and also Quick Draw,
which is part of Carbon.

00:02:46.890 --> 00:02:49.550
So this is part of the
architecture diagram.

00:02:50.720 --> 00:02:54.120
So hopefully by now you know
what the Quartz compositor is.

00:02:54.280 --> 00:02:57.240
It's responsible for
all your screen display.

00:02:57.320 --> 00:03:02.400
It takes content from multiple
applications and sends that over

00:03:02.400 --> 00:03:05.190
to the frame buffer for display.

00:03:05.560 --> 00:03:08.580
This year we've actually
introduced Quartz Extreme,

00:03:08.590 --> 00:03:12.850
and that's actually using hardware
acceleration to perform the composite

00:03:12.850 --> 00:03:15.500
operation on the GPU itself.

00:03:15.500 --> 00:03:21.490
So it's actually freed up a lot
of the CPU for other processing.

00:03:22.670 --> 00:03:27.100
People have asked, you know,
we don't have access to the screen,

00:03:27.250 --> 00:03:29.390
give it to us,
or we want to just get to the

00:03:29.510 --> 00:03:30.700
screen as fast as possible.

00:03:30.700 --> 00:03:36.300
You now understand why we've actually
done this with the new architecture.

00:03:36.300 --> 00:03:40.160
And we've accomplished this primarily
because we've had this window

00:03:40.240 --> 00:03:44.500
backwrapper abstraction so that
you draw into your back-end store

00:03:44.500 --> 00:03:49.200
the windowing system on Mac OS X.

00:03:49.200 --> 00:03:53.090
And the Quartz compositor will be
responsible for taking that content

00:03:53.090 --> 00:03:55.100
and flushing that to the screen.

00:03:55.100 --> 00:03:59.970
So this is the architecture slide
for the software compositor.

00:04:01.350 --> 00:04:04.660
You've got applications that are
drawing into some form of a buffer,

00:04:04.690 --> 00:04:07.760
be it the window backing
store or surfaces.

00:04:08.670 --> 00:04:12.920
The Quartz compositor takes the content
from those buffers and composites them

00:04:13.050 --> 00:04:15.380
and sends them off to the frame buffer.

00:04:18.080 --> 00:04:22.960
The buffers themselves are a shared piece
of memory that is shared between the

00:04:22.960 --> 00:04:25.000
application and the course compositor.

00:04:25.000 --> 00:04:28.100
So in order for an application
to draw into that buffer,

00:04:28.100 --> 00:04:33.000
they're usually calling Quartz 2D or
Quick Draw to draw into that buffer.

00:04:33.000 --> 00:04:37.000
And when Quartz 2D or
Quick Draw draws into that buffer,

00:04:37.000 --> 00:04:41.130
they have to lock down the bits,
draw into it, and unlock the bits,

00:04:41.130 --> 00:04:43.000
and then call the flush operation.

00:04:43.000 --> 00:04:49.000
Then the compositor takes over and
performs its compositing magic.

00:04:51.820 --> 00:04:53.480
For Jaguar,
we've actually introduced Quartz

00:04:53.480 --> 00:04:55.240
Extreme that you've heard about already.

00:04:55.370 --> 00:04:58.860
And Quartz Extreme is performing
hardware acceleration.

00:04:59.000 --> 00:05:01.040
It's taking...

00:05:01.210 --> 00:05:05.920
The same buffer content,
pushing that to the frame buffer,

00:05:05.920 --> 00:05:11.910
letting the GPU pick the bits up
from the window backing stores.

00:05:12.580 --> 00:05:15.620
You'll notice compared to
the software compositor,

00:05:15.620 --> 00:05:18.320
there is hardware
acceleration being used here.

00:05:18.500 --> 00:05:23.580
That's not to say the software compositor
does not use any hardware acceleration.

00:05:23.810 --> 00:05:26.790
The software compositor does
use hardware acceleration,

00:05:26.850 --> 00:05:29.440
especially, for example,
if you're doing opaque window drags.

00:05:29.500 --> 00:05:34.790
So it's not to say that there's
only hardware acceleration

00:05:34.860 --> 00:05:36.690
in the Quartz Extreme.

00:05:39.960 --> 00:05:42.240
So the first piece of recommendation
we normally come up with

00:05:42.330 --> 00:05:44.060
is avoid the extra buffer.

00:05:44.330 --> 00:05:47.760
People are used to drawing to
yet another off-screen buffer,

00:05:47.860 --> 00:05:51.670
taking those contents,
performing a copy bits operation

00:05:52.120 --> 00:05:54.740
into your Windows Backing Store.

00:05:54.740 --> 00:05:56.700
So avoid that wherever possible.

00:05:56.770 --> 00:05:59.680
Once again, buffers cost extra memory.

00:05:59.800 --> 00:06:02.790
The copy bits operation
is yet another step.

00:06:02.800 --> 00:06:06.650
So if wherever possible,
try and avoid it.

00:06:10.660 --> 00:06:14.370
You've also got off-screen
windows in your application.

00:06:14.470 --> 00:06:18.000
These are windows that
have been ordered out.

00:06:18.060 --> 00:06:22.120
You want to avoid them, primarily,
once again, because these buffers

00:06:22.120 --> 00:06:24.610
will consume memory.

00:06:24.860 --> 00:06:29.440
What we recommend is always use
one-shot windows so that all your

00:06:29.440 --> 00:06:32.740
off-screen windows will have disappeared.

00:06:32.740 --> 00:06:38.490
The buffer contents will
disappear in the sense that when

00:06:38.490 --> 00:06:41.610
you order a window on screen,
you draw into it.

00:06:41.790 --> 00:06:45.420
Now when you order it out
because you minimized or you've

00:06:45.420 --> 00:06:50.120
hidden the application window,
if you're using one-shot windows,

00:06:50.120 --> 00:06:52.430
the buffer content disappears.

00:06:52.560 --> 00:06:55.480
When those are ordered back in
because you've maximized or you've

00:06:55.550 --> 00:06:58.730
ordered those windows back in,
that's when you'll get a

00:06:58.730 --> 00:07:00.860
window repainted message.

00:07:00.860 --> 00:07:05.420
And that's usually much,
much faster than paging in the

00:07:05.420 --> 00:07:08.530
back-in-store memory off of disk.

00:07:09.400 --> 00:07:15.140
So unless you've got really content
in your buffers that takes a long,

00:07:15.140 --> 00:07:18.240
long time for you to draw,
always use one-shot windows.

00:07:18.240 --> 00:07:21.910
And Carbon and Cocoa do this differently,
so look at how they

00:07:21.910 --> 00:07:26.510
recommend you do this,
but always use those wherever possible.

00:07:29.620 --> 00:07:36.660
Another common mistake that developers
end up doing is you create a window,

00:07:36.660 --> 00:07:40.340
you then look at the preference
file somewhere to determine

00:07:40.340 --> 00:07:43.400
what the size of the window
should be and resize the window.

00:07:43.400 --> 00:07:47.130
Once again, this is just redundant
operations in the system.

00:07:47.260 --> 00:07:51.230
You're putting up a window that
is going to be destroyed anyways,

00:07:51.390 --> 00:07:56.760
so make sure you specify the
window size appropriately.

00:07:59.050 --> 00:08:03.240
In order for us to continue maintaining
a backing store abstraction,

00:08:03.340 --> 00:08:05.500
we're asking people not to
assume that the backing store

00:08:05.500 --> 00:08:06.400
will be in system memory.

00:08:06.400 --> 00:08:08.070
It can move.

00:08:08.200 --> 00:08:14.320
This will allow us to further add future
performance optimizations in the system.

00:08:17.820 --> 00:08:19.540
Now,
flushing is the operation that actually

00:08:19.650 --> 00:08:23.610
takes your content from the window
back buffer or from the buffer and

00:08:23.610 --> 00:08:26.050
sends that off to the frame buffer.

00:08:26.540 --> 00:08:30.220
Now, flushing can be done both
implicitly or explicitly for you.

00:08:30.280 --> 00:08:33.620
Implicitly by Carbon or Cocoa.

00:08:33.660 --> 00:08:37.220
When you've done your drawing,
at the end of the update,

00:08:37.220 --> 00:08:41.670
Carbon or Cocoa will send off a
flush request on your behalf to

00:08:41.680 --> 00:08:46.590
flush all the dirty regions that
have been accumulated so far.

00:08:46.980 --> 00:08:49.340
You may also choose to
do your own flushing.

00:08:49.420 --> 00:08:51.700
And you can use
Quick Draw Flush Port Buffer,

00:08:51.700 --> 00:08:56.300
CG Context Flush,
or even an AppKit Flush Window.

00:08:57.780 --> 00:09:01.700
One thing to keep in mind about
flushing is flushing is asynchronous.

00:09:01.790 --> 00:09:06.170
So what that means is basically when you
execute the flush command or when the

00:09:06.230 --> 00:09:11.850
application executes the flush command,
the window compos-- the software--

00:09:11.900 --> 00:09:14.320
the Quartz compositor is actually
responsible for taking those

00:09:14.320 --> 00:09:15.790
bits and sending them off.

00:09:15.960 --> 00:09:18.210
You are free to go and
do whatever you want.

00:09:18.420 --> 00:09:23.100
So we'll have a demo showing how you can
take advantage of asynchronous flushing.

00:09:24.830 --> 00:09:28.260
The flush operation does not
block until it's completed.

00:09:28.260 --> 00:09:32.240
It's only when you lock down the
bits again whenever you do issue

00:09:32.240 --> 00:09:34.200
yet another drawing command.

00:09:34.300 --> 00:09:41.250
If the flush has not succeeded by then,
that's the time when the lock

00:09:41.390 --> 00:09:44.460
will actually block until the
previous flush has completed.

00:09:44.600 --> 00:09:46.440
So take advantage of that.

00:09:46.560 --> 00:09:49.400
Make sure you do not execute
any redundant flushing.

00:09:49.400 --> 00:09:53.160
Delay your drawing until you need to.

00:09:53.290 --> 00:09:56.310
keep it together as much as possible.

00:09:57.030 --> 00:10:02.760
Now, as has been mentioned before,
the fastest way to get your bits to

00:10:02.760 --> 00:10:06.310
the screen or to the frame buffer
is to draw into your window backing

00:10:06.360 --> 00:10:09.230
store and execute that flush command.

00:10:09.240 --> 00:10:14.700
The Quartz compositor will take all
opportunities on the system to send

00:10:14.730 --> 00:10:20.340
that over the bus and send that to
the frame buffer as fast as possible.

00:10:20.820 --> 00:10:23.440
Now, with Quartz Extreme,
we're using AGP transfer.

00:10:23.440 --> 00:10:28.940
Those backing stores are
textured through OpenGL.

00:10:28.940 --> 00:10:33.260
It's being pulled off the system
memory as fast as possible.

00:10:37.580 --> 00:10:40.950
Another thing to keep in mind
about flushing is all flushing

00:10:41.010 --> 00:10:42.600
is actually beam synced.

00:10:42.680 --> 00:10:46.430
And that's primarily to give you
that nice visual presentation that

00:10:46.530 --> 00:10:50.100
Mac OS X does where everything
appears to the screen atomically.

00:10:50.190 --> 00:10:52.330
There's no window tearing.

00:10:53.010 --> 00:10:57.850
So on CRTs, you've got a refresh rate of
anywhere from 60 to 120 hertz

00:10:57.850 --> 00:10:59.240
depending on your monitor.

00:10:59.240 --> 00:11:01.820
But keep in mind,
LCD panels also happen to have

00:11:01.870 --> 00:11:03.480
a screen update frequency.

00:11:03.480 --> 00:11:07.220
And as a result,
they are typically at 60 hertz also.

00:11:07.220 --> 00:11:12.010
If you're trying to flush
anything faster than 60 hertz,

00:11:12.040 --> 00:11:13.720
your eye is not going to see it.

00:11:14.010 --> 00:11:16.370
Those are just redundant operations,
so try and avoid those.

00:11:16.380 --> 00:11:21.040
Try and shoot for a refresh rate of
anywhere from 30 to 60 frames per second.

00:11:21.040 --> 00:11:23.790
Those are reasonable rates
for your application.

00:11:23.810 --> 00:11:25.400
If you're not getting
those type of rates,

00:11:25.780 --> 00:11:28.160
profile, try and find out what's
going on in the system.

00:11:31.590 --> 00:11:35.700
A new feature for Jaguar
is scroll acceleration.

00:11:35.810 --> 00:11:38.320
Usually the slowest part
of any memory transfer from

00:11:38.520 --> 00:11:43.630
main memory to system memory,
that's the slowest part usually.

00:11:43.710 --> 00:11:45.460
With Course Extreme,
it's actually faster,

00:11:45.570 --> 00:11:49.260
but the more you can minimize
the amount of data transfer,

00:11:49.260 --> 00:11:50.260
the better.

00:11:50.260 --> 00:11:55.500
So for Jaguar,
we've actually accelerated scrolling.

00:11:55.620 --> 00:11:58.910
And we do that by only sending
over across the bus what is the

00:11:58.910 --> 00:12:01.460
new region that's been updated.

00:12:01.460 --> 00:12:04.330
At the lowest level,
this operation is three times faster.

00:12:04.460 --> 00:12:08.940
You may not see a factor of three in
your application necessarily because

00:12:08.940 --> 00:12:11.160
there's usually lots more going on.

00:12:11.160 --> 00:12:15.620
So scroll rack and a scroll view,
any imaging that you do through

00:12:15.620 --> 00:12:20.610
CG will have roughly about a
30% improvement depending on

00:12:20.670 --> 00:12:23.080
how much area is being scrolled.

00:12:23.320 --> 00:12:27.400
The recommendation here is use
scroll rec wherever possible.

00:12:27.400 --> 00:12:33.370
We'll show in the demo where there
are cases where scroll recs or scroll

00:12:33.630 --> 00:12:37.560
views are not being used appropriately,
and so scroll acceleration

00:12:37.560 --> 00:12:40.090
is not necessarily hooked up.

00:12:40.830 --> 00:12:45.590
In Jaguar,
if you're copying from a window back

00:12:45.590 --> 00:12:51.860
buffer into the same window back buffer,
if you're using core graphics or quarts,

00:12:51.970 --> 00:12:53.940
this will also take advantage
of this optimization.

00:12:53.940 --> 00:12:56.820
QuickDraw currently isn't,
but for Jaguar we will make sure that

00:12:56.890 --> 00:12:58.710
that will also take advantage of this.

00:12:58.720 --> 00:12:59.890
Okay.

00:13:02.820 --> 00:13:05.830
You're also familiar with overlays,
but in case you're not,

00:13:05.930 --> 00:13:09.600
overlays are nothing more than
a series of layers of content.

00:13:09.640 --> 00:13:12.900
And in this example,
you've got a transparent window

00:13:12.900 --> 00:13:16.610
with some controls on top of the
content that you can compose on

00:13:16.610 --> 00:13:19.560
top of your existing content.

00:13:20.200 --> 00:13:25.140
So with Corts Extreme,
we've actually made overlays

00:13:25.140 --> 00:13:27.970
accelerated in the sense that

00:13:29.540 --> 00:13:34.900
The transparency tax that was
present with the course compositor

00:13:34.900 --> 00:13:38.230
is no longer a tax anymore,
and primarily because all of

00:13:38.230 --> 00:13:40.240
the compositing is actually
being done in the GPU,

00:13:40.240 --> 00:13:42.950
so feel free to take
advantage of overlays,

00:13:43.130 --> 00:13:45.770
you know,
come up with nice applications that take

00:13:45.940 --> 00:13:48.020
advantage of overlays in the system.

00:13:48.020 --> 00:13:51.210
You can use overlays in your system by,
in Carbon,

00:13:51.280 --> 00:13:55.750
using the Carbon Overlay window class,
Cocoa, you can do the same thing

00:13:55.750 --> 00:13:57.710
with a different approach.

00:13:58.380 --> 00:14:03.920
You can always fall back to
Quartz to clear the window so

00:14:04.330 --> 00:14:08.560
that all the alpha is set to zero,
and then from that point onwards

00:14:08.570 --> 00:14:11.280
you can start drawing on top of it,
and you effectively have

00:14:11.280 --> 00:14:12.820
an overlay on your window.

00:14:14.870 --> 00:14:19.600
Keep in mind that if you use Quartz,
Iteris, Plex, Alpha,

00:14:19.600 --> 00:14:21.680
Quickdraw is generally alpha agnostic.

00:14:21.680 --> 00:14:24.390
So anything you draw into
your transparent window

00:14:24.690 --> 00:14:28.620
through Quickdraw will touch,
set the alpha to FF when it's

00:14:28.740 --> 00:14:31.560
drawing into the window buffer.

00:14:34.540 --> 00:14:37.780
Yet another feature for Jaguar
is backing stroke compression.

00:14:37.820 --> 00:14:41.000
So you've heard about it
already in a previous session.

00:14:41.070 --> 00:14:46.180
But all it is,
is you've got windows that are

00:14:46.180 --> 00:14:48.460
generally inactive in the system.

00:14:48.520 --> 00:14:52.210
After a delay of 5 to 10 seconds,
those windows will become

00:14:52.210 --> 00:14:57.340
compressed and the Quartz compositor
takes care of that for you.

00:14:58.740 --> 00:15:01.990
They get decompressed only when
you write into that backing store,

00:15:01.990 --> 00:15:08.940
so try and avoid redundant drawing into
your backing store when not necessary.

00:15:09.030 --> 00:15:11.810
You don't want to necessarily
compress/decompress,

00:15:11.910 --> 00:15:15.140
but the system is
pretty smart about that.

00:15:15.970 --> 00:15:19.950
On average, we get a compression ratio of
anywhere from 3:1 to 4:1 and really

00:15:19.950 --> 00:15:23.320
depends on the window contents
that you've got on your screen.

00:15:25.970 --> 00:15:29.570
One of the reasons it's a benefit is the
Quartz compositor can actually composite

00:15:29.580 --> 00:15:33.540
that directly from the compressed data,
only decompressing what's necessary.

00:15:33.610 --> 00:15:38.250
The backing storage remains compressed
unless you're drawing into it.

00:15:38.740 --> 00:15:40.930
So this is a system level
optimization that does not

00:15:40.940 --> 00:15:42.520
require any changes on your part.

00:15:42.610 --> 00:15:45.670
It should be completely
transparent to you.

00:15:48.090 --> 00:15:51.450
Other areas of performance
tunings are related to the

00:15:51.540 --> 00:15:54.040
use of the velocity engine.

00:15:54.130 --> 00:15:56.300
So for Jaguar,
we've got some more graphics operations

00:15:56.300 --> 00:15:58.870
that are now taking advantage of it.

00:15:59.220 --> 00:16:02.650
The software Quartz compositor
is now fully vectorized,

00:16:02.710 --> 00:16:04.720
so it's not to say that there
hasn't been any performance

00:16:04.720 --> 00:16:06.640
tuning on the software compositor.

00:16:06.790 --> 00:16:09.800
That's taking advantage
of the velocity engine.

00:16:09.920 --> 00:16:12.860
There are blitters in the
system that are now taking

00:16:12.870 --> 00:16:15.790
advantage of the velocity engine.

00:16:16.610 --> 00:16:19.620
The example I show is QuickDrawCopyBits
when you're copying into

00:16:19.620 --> 00:16:20.700
a Windows Backing Store.

00:16:20.760 --> 00:16:24.700
That's not done yet,
but we're looking at doing that shortly.

00:16:24.760 --> 00:16:29.710
And also Backing Store Compression is
taking advantage of vectorized code.

00:16:29.880 --> 00:16:31.560
This is a simple recommendation.

00:16:31.560 --> 00:16:34.100
If you happen to allocate
your own bitmaps,

00:16:34.100 --> 00:16:37.960
make sure that the row bytes that
you specify are divisible by 16,

00:16:37.960 --> 00:16:45.740
as that will allow more optimizations
to kick in on the Velocity Engine.

00:16:45.830 --> 00:16:50.080
And now I'd like to actually bring up
Ralph Bruhner to talk about Quartz Debug.

00:17:00.830 --> 00:17:03.700
Okay, I'm going to do a few demos here.

00:17:03.700 --> 00:17:09.040
First thing I'd like to show
is the asynchronous flushing

00:17:09.040 --> 00:17:11.320
that Haroon was mentioning.

00:17:11.780 --> 00:17:16.900
So I have a little app here that,
when it's started,

00:17:16.930 --> 00:17:21.720
does quite a bit of floating
point computation and just renders

00:17:21.800 --> 00:17:25.070
frames from the mental road sets.

00:17:25.230 --> 00:17:29.380
First thing I'd like to show is if you
don't make use of asynchronous flushing,

00:17:29.400 --> 00:17:34.220
by the way in the bottom right corner we
have this little speedometer here which

00:17:34.290 --> 00:17:35.760
essentially is the frame rate counter.

00:17:35.760 --> 00:17:39.750
It measures the number of frames
that the quartz compositor pumps out.

00:17:39.750 --> 00:17:43.050
So it works for everything in the system,
even the Docker.

00:17:45.220 --> 00:17:51.020
So, without asynchronous flushing,
you can see the needle peaks at 40,

00:17:51.020 --> 00:17:52.100
45 frames per second.

00:17:52.100 --> 00:17:56.560
And from then on it will
drop slowly because the

00:17:56.560 --> 00:17:58.660
computation gets more expensive.

00:18:00.450 --> 00:18:04.310
The same thing with
asynchronous flashing.

00:18:04.350 --> 00:18:08.560
And we're peaking at 55, 58 or so.

00:18:10.530 --> 00:18:15.880
So the only difference between these
two modes is there's a timer firing

00:18:15.880 --> 00:18:20.000
60 times a second because the goal
is to produce 60 frames per second.

00:18:20.090 --> 00:18:23.350
And at the beginning we do
some computation to render the

00:18:23.370 --> 00:18:26.070
next frame and then we draw it.

00:18:26.390 --> 00:18:33.170
And this is quite natural way to do
things and it exploits asynchronous

00:18:33.280 --> 00:18:38.660
flushing without any additional
work because in the first part where

00:18:38.660 --> 00:18:41.370
you actually do the computation,
during that time the previous

00:18:41.370 --> 00:18:43.310
frame can be flushed to the screen.

00:18:43.330 --> 00:18:48.260
So when I disable this little checkbox
here to defeat asynchronous flushing,

00:18:48.260 --> 00:18:52.320
the only thing I do is right before
I do a computation I draw a single

00:18:52.350 --> 00:18:54.520
pixel in one of these windows.

00:18:55.520 --> 00:18:59.710
And that causes us to hit that lock
to wait until the flush has happened

00:18:59.780 --> 00:19:01.480
and then we start the computation.

00:19:01.480 --> 00:19:05.140
And as we see this really can make
15 frames per second difference.

00:19:05.140 --> 00:19:08.210
Okay.

00:19:14.140 --> 00:19:16.600
The next thing I'd like
to show is Quartz Debug,

00:19:16.600 --> 00:19:21.000
which is a tool that is,
it was in 10.1 and it's

00:19:21.480 --> 00:19:24.590
slightly improved for Jaguar.

00:19:25.490 --> 00:19:29.260
What it helps you doing is it
turns the Quartz compositor,

00:19:29.260 --> 00:19:32.540
it turns the certain debug flags
on in the Quartz compositor.

00:19:32.630 --> 00:19:36.940
So for example, I can select flash screen
updates and from then on,

00:19:37.020 --> 00:19:39.790
whenever an application flushes,

00:19:40.550 --> 00:19:44.890
The error that gets flushed flashes in
yellow first for a short period of time.

00:19:44.900 --> 00:19:48.300
And so you can see what
kind of drawing is going on.

00:19:48.330 --> 00:19:52.600
This is a good thing to find out if you
flush certain things multiple times.

00:19:52.600 --> 00:19:57.000
If you thought you didn't do any drawing
in a certain area and it flashes,

00:19:57.000 --> 00:20:00.720
then it's probably an indication
that some part of your code is

00:20:00.720 --> 00:20:05.610
executed there where you probably
didn't want it to execute.

00:20:05.790 --> 00:20:09.560
So, to illustrate that,
we can look at scroll

00:20:09.560 --> 00:20:11.640
acceleration in Jaguar.

00:20:11.750 --> 00:20:16.390
So when I scroll in text edit,
we see only the bottom part,

00:20:16.590 --> 00:20:19.050
the part that needs to be redrawn
from one frame to the next,

00:20:19.050 --> 00:20:20.100
is actually redrawn.

00:20:20.300 --> 00:20:25.410
And the part in the middle just
gets the hardware acceleration.

00:20:25.520 --> 00:20:29.740
So for comparison,
if I look at Project Builder,

00:20:29.750 --> 00:20:31.440
Project Builder flushes
actually everything.

00:20:31.440 --> 00:20:35.260
So we're going to fix that
for the final release.

00:20:36.000 --> 00:20:37.730
Okay.

00:20:37.850 --> 00:20:43.290
So,
other flags you have in Quartz Debug is

00:20:43.350 --> 00:20:47.290
Autoflush drawing,
which is whenever a primitive is drawn,

00:20:47.300 --> 00:20:48.660
we immediately call flush.

00:20:48.660 --> 00:20:54.580
So that simulates a bit like the
Mac OS 9 style drawing where you

00:20:54.580 --> 00:20:56.130
see drawing trickle on the screen.

00:20:56.140 --> 00:21:01.430
So when I go and change stuff here,
you see everything flickers

00:21:01.520 --> 00:21:06.070
because everything is drawn
and immediately shown.

00:21:07.620 --> 00:21:12.510
Most interesting,
this is... that sounded like Yoda.

00:21:12.510 --> 00:21:13.240
Sorry.

00:21:17.070 --> 00:21:19.740
You can see this when you
turn both of these on.

00:21:19.840 --> 00:21:24.400
You say Auto Flush Drawing and you
say Flush in Yellow whenever we flush.

00:21:24.400 --> 00:21:29.790
So you can switch to an application.

00:21:32.000 --> 00:21:39.120
And then for example see how the
menu is drawn or how individual text

00:21:39.210 --> 00:21:41.810
lines are drawn and stuff like that.

00:21:42.560 --> 00:21:45.190
So, because the entire system
goes into that mode,

00:21:45.320 --> 00:21:47.860
things tend to be really, really slow.

00:21:47.920 --> 00:21:51.690
And what you can do about that is
we have this little hotkey here.

00:21:51.780 --> 00:21:53.860
This is control option command T.

00:21:53.860 --> 00:21:57.050
So you can only turn it on for those
drawings you're interested in and not,

00:21:57.060 --> 00:21:59.150
usually you're not
optimizing the menu drawings,

00:21:59.150 --> 00:22:01.690
so that's kind of helpful.

00:22:05.150 --> 00:22:08.670
There's also a really
mean switch up here,

00:22:08.670 --> 00:22:11.880
which is called Flash Identical Updates.

00:22:12.080 --> 00:22:18.080
So Quartz then does quite a bit
of work when the area that gets

00:22:18.080 --> 00:22:21.680
flushed gets compared before it's
flushed against what's already in

00:22:21.680 --> 00:22:26.500
the screen and it flashes in red
whichever pixel hasn't changed.

00:22:26.500 --> 00:22:31.530
So if you do drawing that is redundant,
then everything shows up in red.

00:22:31.570 --> 00:22:35.420
So as an example,

00:22:36.530 --> 00:22:40.520
I can see that the carrot here
has a little red border around it

00:22:40.650 --> 00:22:41.960
because these bits get flushed.

00:22:42.040 --> 00:22:45.360
Now, these of course are a really small
area and we don't really care about it,

00:22:45.370 --> 00:22:48.160
but the interesting thing is
if I move the cursor around,

00:22:48.260 --> 00:22:52.260
we see that that little bar up there
is redrawn for every cursor movement,

00:22:52.260 --> 00:22:56.000
and that's, for example,
one of the things you should

00:22:56.000 --> 00:22:58.060
look out for and optimize.

00:23:00.510 --> 00:23:01.920
Okay.

00:23:01.920 --> 00:23:08.170
The last feature of Quartz
Debug is Show Window List.

00:23:08.170 --> 00:23:12.400
So it gives you this
little NSBrowser view.

00:23:13.300 --> 00:23:18.340
of all the windows on the system and
the applications that created them.

00:23:18.460 --> 00:23:21.710
So for example, I have Quartz debug here.

00:23:22.710 --> 00:23:26.550
So there is one window
which is 4.5 kilobytes,

00:23:26.680 --> 00:23:31.570
another one is 270 kilobytes,
and another one is 88.

00:23:31.930 --> 00:23:37.120
So the 88 one is 1K by 22 pixels,
so that's our menu bar.

00:23:37.230 --> 00:23:39.420
The other one is 270k.

00:23:39.420 --> 00:23:43.390
It's this little window with
the nice quartz image in it.

00:23:43.520 --> 00:23:46.680
And then there's a third one
which is an off-screen image,

00:23:46.690 --> 00:23:50.920
which is essentially the little checkbox
which is cached in an off-screen image.

00:23:50.920 --> 00:23:55.730
So what you can do is you can look
at the windows that have been created

00:23:55.730 --> 00:24:00.760
by your application and try to avoid
windows that are off-screen because

00:24:00.760 --> 00:24:03.630
they're just taking up memory and they're
mapped into a different address space

00:24:03.810 --> 00:24:05.340
where they probably don't need to be.

00:24:06.500 --> 00:24:08.970
So this is kind of a handy tool.

00:24:08.990 --> 00:24:15.060
You can also go and sort by size and
then by application and then you have

00:24:15.270 --> 00:24:18.560
every application at the top list.

00:24:18.640 --> 00:24:23.900
Terminal has a 700 something kilobytes
window here and stuff like that.

00:24:23.930 --> 00:24:28.490
Another thing here...

00:24:28.940 --> 00:24:36.890
So we have one in Finder has 330K and has
a little C behind the kilobytes number.

00:24:37.050 --> 00:24:38.440
C means compressed.

00:24:38.570 --> 00:24:41.720
So these are the windows that got

00:24:41.880 --> 00:24:44.590
were idle for more than 10
seconds or so and then got

00:24:44.700 --> 00:24:46.360
compressed by the Windows server.

00:24:46.360 --> 00:24:51.400
So another thing to look out for,
if your application has Windows on

00:24:51.400 --> 00:24:54.870
screen and after 20 seconds or
so they're still not compressed,

00:24:55.090 --> 00:24:59.500
maybe you're dirting them continuously
and that's a hint to look at.

00:25:02.000 --> 00:25:05.760
Essentially, the recommendation is, well,
you know, if you're idle,

00:25:05.760 --> 00:25:09.390
don't do anything because it spoils
other optimizations in the system.

00:25:10.810 --> 00:25:14.500
Okay, with that,
that was it for the demo.

00:25:14.610 --> 00:25:18.120
Now I would like to invite
Joseph Maurer up here.

00:25:32.160 --> 00:25:37.400
Freedom for Lower Bavaria!

00:25:37.400 --> 00:25:39.450
Now I got your attention.

00:25:39.620 --> 00:25:44.340
I know it's Friday afternoon,
we're all tired, we want to go home.

00:25:44.370 --> 00:25:48.360
That's why I'm going to
make it sweet and short.

00:25:50.230 --> 00:25:53.540
This is some kind of table of contents.

00:25:53.630 --> 00:25:58.640
I was thinking about how
to present this subject.

00:25:58.740 --> 00:26:00.970
One idea was

00:26:01.380 --> 00:26:08.590
First, to convince you that all the
rumors about bad performance

00:26:08.590 --> 00:26:08.590
of Quick Draw on 10 are wrong,

00:26:08.820 --> 00:26:14.130
and then to explain why
Quick Draw is so slow on 10

00:26:14.790 --> 00:26:16.570
But this wouldn't work well.

00:26:16.690 --> 00:26:20.900
So it's just a potpourri of

00:26:21.490 --> 00:26:24.500
What comes to mind in this matter?

00:26:24.510 --> 00:26:29.590
First item: I hate benchmarks.

00:26:30.170 --> 00:26:33.130
Everybody can write
applications that run slow,

00:26:33.150 --> 00:26:33.680
right?

00:26:33.750 --> 00:26:35.810
You don't need to make an effort.

00:26:35.940 --> 00:26:41.900
And you cannot believe how many bugs
I have received over the last two years.

00:26:41.950 --> 00:26:46.000
Benchmark bugs that said,
"This benchmark runs 20 times

00:26:46.000 --> 00:26:49.640
as slow on 10 than on 9." Yeah,
alright.

00:26:49.710 --> 00:26:51.890
I know.

00:26:52.090 --> 00:26:54.860
I guess that's why I'm here now, right?

00:26:56.280 --> 00:27:02.100
Not that I wouldn't want to make
some jokes here from time to time.

00:27:02.150 --> 00:27:06.360
Of course I use benchmarks to
sample and to figure out why

00:27:06.360 --> 00:27:10.640
we have all these performance
problems on 10 with Quick Draw.

00:27:10.740 --> 00:27:16.100
So my favorites are sampling
and microsecond timing.

00:27:16.160 --> 00:27:19.840
The question came up yesterday
how to determine execution times.

00:27:19.840 --> 00:27:21.980
My favorite is uptime.

00:27:22.040 --> 00:27:26.140
It gives my machine
multiples of 40 nanoseconds.

00:27:26.360 --> 00:27:26.360
That's good enough.

00:27:26.420 --> 00:27:31.260
And I can convert it and
display and work with it.

00:27:32.620 --> 00:27:35.450
Well,
we have learned over the whole week,

00:27:35.450 --> 00:27:38.890
I guess, that frames per second

00:27:39.490 --> 00:27:46.520
The favorite benchmark on systems
before X don't work well on X.

00:27:46.520 --> 00:27:49.990
In order to figure out how many
frames you get on the screen,

00:27:49.990 --> 00:27:52.160
you would have to flush each frame.

00:27:52.210 --> 00:28:00.770
And flushing just chokes up when it goes
beyond the refresh rate of the display.

00:28:00.930 --> 00:28:02.520
So, reduce flushing.

00:28:02.580 --> 00:28:06.870
And the benchmark, the frames per second
benchmark is broken.

00:28:07.320 --> 00:28:11.090
There's this other item
of hardware acceleration.

00:28:11.090 --> 00:28:16.410
Ever since it became
known that on Mac OS X

00:28:17.760 --> 00:28:23.990
Quick Draw would be tricked into drawing
into a window buffer in RAM instead

00:28:24.010 --> 00:28:30.340
of directly into VRAM on corresponding
to the screen's frame buffer.

00:28:30.510 --> 00:28:33.500
Everybody understood that this

00:28:34.200 --> 00:28:50.600
[Transcript missing]

00:28:50.670 --> 00:28:55.950
If instead you have to write them
out in your even optimized software

00:28:56.190 --> 00:28:59.100
split loop you're going to suffer.

00:28:59.150 --> 00:29:02.040
And that's one aspect
of what we have seen.

00:29:02.100 --> 00:29:06.090
You know, ever since Quick Draw has
been tricked into

00:29:07.610 --> 00:29:09.620
Drawing into the window
back buffer instead of the

00:29:09.770 --> 00:29:14.730
screen as it still believes.

00:29:15.360 --> 00:29:22.750
Somebody has to give in the whole big
picture of the forward vision that

00:29:22.830 --> 00:29:24.060
you have learned about this week.

00:29:24.060 --> 00:29:28.240
And QuikTour is the one to give
here in this specific case.

00:29:28.260 --> 00:29:31.560
On the other hand,
don't believe that just because

00:29:31.560 --> 00:29:35.430
these specific copy bits
operations onto the destination,

00:29:35.530 --> 00:29:37.800
if it's the screen destination,
the window,

00:29:37.800 --> 00:29:42.010
are not highly accelerated anymore,
that everything is just hopeless

00:29:42.010 --> 00:29:43.770
now for QuikTour drawing.

00:29:44.660 --> 00:29:48.500
For one, fortunately,
all this hardware acceleration

00:29:48.500 --> 00:29:52.220
on 9 and previous systems
is not as good as you think.

00:29:52.300 --> 00:29:55.510
Which is good for me because so
I can get at situations where

00:29:55.580 --> 00:29:57.980
QuikTour on 10 is actually faster.

00:29:57.980 --> 00:30:02.010
The other...

00:30:03.450 --> 00:30:11.980
The idea about comes from I mean has
been spelled out by Peter Graffagnino.

00:30:12.000 --> 00:30:16.470
Peter Graffagnino,
one of his favorite sentences is you

00:30:16.470 --> 00:30:19.920
know by the end of the day everybody
will have many more processor

00:30:19.920 --> 00:30:22.680
cycles everything will be faster.

00:30:22.710 --> 00:30:24.960
He doesn't say which day.

00:30:25.990 --> 00:30:32.030
You may have seen that I have
demos in preparation so by

00:30:32.080 --> 00:30:36.900
the end of today we will see
situations where things are faster.

00:30:37.690 --> 00:30:41.100
Meanwhile, you have had time to read
the reasoning why hardware

00:30:41.100 --> 00:30:44.710
acceleration on X is different,
how it is different,

00:30:44.710 --> 00:30:48.230
and I try to convince you that
it's eventually from the narrow

00:30:48.230 --> 00:30:52.630
point of view of Quick Draw,
it's not such a big deal after all.

00:30:55.800 --> 00:31:02.890
What tends to be a big deal potentially
in some situations is the additional

00:31:02.890 --> 00:31:08.300
requirement for QuickDraw to maintain
a dirty region for each drawing.

00:31:08.400 --> 00:31:12.550
You do not want in each
flushing operation,

00:31:12.550 --> 00:31:15.530
even if you do it only 60 times a second,
you do not want to flush the

00:31:15.630 --> 00:31:18.340
whole window content each time.

00:31:19.080 --> 00:31:24.780
So the maintenance of the dirty
region turns out to be costly.

00:31:24.890 --> 00:31:29.960
It gets costly with increasing
complexity of the region.

00:31:30.160 --> 00:31:32.410
I'm not sure but the

00:31:33.240 --> 00:31:38.180
The penalty of region processing
goes at least with the square

00:31:38.180 --> 00:31:39.510
of the region complexity.

00:31:39.570 --> 00:31:41.930
It might be worse.

00:31:43.830 --> 00:31:48.440
When, for one, you have a very often a
non-trivial clip region.

00:31:48.440 --> 00:31:54.400
Each time a simple, dirty rectangle, say,
gets added to the dirty region,

00:31:54.400 --> 00:31:56.600
it gets intersected with the clip region.

00:31:56.600 --> 00:32:01.060
And we cannot do anything
about it if we would not,

00:32:01.250 --> 00:32:06.700
so many clients depend on the
region to be flushed eventually be

00:32:06.700 --> 00:32:10.180
intersected with the clip region.

00:32:10.180 --> 00:32:15.760
Think about the finder's desktop,
for example.

00:32:16.070 --> 00:32:21.420
CopyBits the whole desktop content
and just clips out the little icon

00:32:21.530 --> 00:32:24.120
surfaces that need to be updated.

00:32:24.200 --> 00:32:25.140
The finder relies on it.

00:32:25.230 --> 00:32:30.050
If it would not each time intersect,
the finder would each time

00:32:30.050 --> 00:32:33.530
flush the whole screen surface.

00:32:34.780 --> 00:32:39.040
You have an intersection,
you have a region reunion,

00:32:39.040 --> 00:32:44.210
and all in all ends up in
the samples when you do your

00:32:44.300 --> 00:32:47.700
sampling of performance problems.

00:32:47.880 --> 00:32:52.830
So after some time of learning,
we came up with the right approach,

00:32:52.830 --> 00:32:56.060
the right trick, which is

00:32:56.500 --> 00:33:00.190
To set the dirty region before
you start a sequence of drawing

00:33:00.400 --> 00:33:05.290
to a big rectangular region,
just as big as you need for your drawing,

00:33:06.240 --> 00:33:07.820
and go from there.

00:33:07.920 --> 00:33:10.870
And it turns out that
things go miraculously much,

00:33:11.010 --> 00:33:12.260
much faster.

00:33:12.370 --> 00:33:16.520
The worst case is a drawing where you
do a lot of math and then each time

00:33:16.520 --> 00:33:20.660
you found some convergence point,
you plot the single point.

00:33:20.750 --> 00:33:23.890
You get a point here, a point there,
a point here, a point there,

00:33:23.890 --> 00:33:28.160
and after a while you're waiting
until you get 100,000 points.

00:33:28.260 --> 00:33:30.580
Well, this is the worst case for regions.

00:33:30.830 --> 00:33:33.580
Each time you add a single
isolated point to a region.

00:33:33.700 --> 00:33:37.480
And these are the cases we are
drawing on 10 when compared

00:33:37.480 --> 00:33:39.600
with 9 in the same Carbon app.

00:33:39.690 --> 00:33:41.920
It's not just 20 times slower.

00:33:42.000 --> 00:33:44.940
It can be much, much slower even.

00:33:45.190 --> 00:33:49.880
Fortunately, many of you have made the
experience asking themselves now,

00:33:49.910 --> 00:33:52.580
"Why didn't I run into this?"

00:33:53.120 --> 00:33:59.430
I never observed this type of problem
because you did a big erase rect on

00:33:59.430 --> 00:34:04.580
your window content before you started
drawing and this erase rect dirtied the

00:34:04.580 --> 00:34:10.690
whole rectangle so all the additional
little drawings they got shortcut,

00:34:10.690 --> 00:34:14.890
the region processing realized
I don't have anything to do it's

00:34:14.890 --> 00:34:21.780
already completely enclosed and this
makes the problem go away but if the

00:34:21.780 --> 00:34:27.320
region you erased was not a simple
rectangle but was clipped with some

00:34:27.320 --> 00:34:31.900
some fancy clip region instead then
you are running into the problem

00:34:33.760 --> 00:34:40.130
and finally another candidate for
optimization of quick draw on ten

00:34:40.340 --> 00:34:44.890
which just doesn't exist on nine
is this Locked Port Pits story.

00:34:45.450 --> 00:34:49.860
Because of the fact that
each window buffer now is

00:34:49.860 --> 00:34:54.980
managed by the Windows Server,
and when you start drawing into it,

00:34:54.980 --> 00:34:59.830
you need to make sure that it gets locked
down and that you have access to it,

00:35:00.030 --> 00:35:02.640
you need to make this
lock port it's called.

00:35:02.860 --> 00:35:06.500
Quick Draw needs to do this for
each and every single API call,

00:35:06.500 --> 00:35:10.350
even if it's just to set a single point,
a single pixel.

00:35:11.370 --> 00:35:17.990
I have been told over many many months
that Lockport is negligible performance

00:35:18.900 --> 00:35:24.480
wise and certainly it is if your drawing
thanks to dirty region management or

00:35:24.610 --> 00:35:28.460
such is so slow that it doesn't show up.

00:35:28.530 --> 00:35:34.770
Once you are getting in the range where
you are teasing it out then it does make

00:35:34.840 --> 00:35:37.660
a difference and we will look at that.

00:35:37.790 --> 00:35:45.900
So the principle here is lock port bits
can be nested and once they are nested,

00:35:45.900 --> 00:35:47.870
once you have the lock,
it just increments the lock count and

00:35:47.940 --> 00:35:49.880
doesn't basically cost anything anymore.

00:35:49.990 --> 00:35:53.980
Why do I say be careful?

00:35:54.090 --> 00:35:59.350
System 10 has become pretty complicated
and many things are going on on the

00:35:59.450 --> 00:36:02.590
Windows Server side which are often,
when you look at it,

00:36:02.800 --> 00:36:06.370
counter-intuitive or puzzling.

00:36:07.060 --> 00:36:10.770
Holding a lock,
and there are other people here who

00:36:10.770 --> 00:36:18.340
know this much better than I do,
can under certain circumstances stress

00:36:18.860 --> 00:36:22.520
the tolerance of the system design.

00:36:22.590 --> 00:36:32.980
And you may end up in problems which
we would not like to have to deal with.

00:36:33.370 --> 00:36:36.660
The rule of thumb is
don't push it too hard.

00:36:36.800 --> 00:36:41.570
Try to get everything done within a
couple seconds at most or release the

00:36:41.570 --> 00:36:44.780
lock and then come back and continue.

00:36:46.990 --> 00:36:50.430
At this point in time,
I would like to bring up

00:36:50.520 --> 00:36:53.100
on stage Phil Schiller,

00:36:53.950 --> 00:36:57.660
Senior Vice President of
Worldwide Product Marketing.

00:36:57.660 --> 00:36:59.970
Yeah, I guess not.

00:37:04.040 --> 00:37:08.630
What I meant to do was to put him on
the 10 machine and I would have used

00:37:08.790 --> 00:37:13.170
the system 9 and then we would have done
our competition and I would have won.

00:37:15.000 --> 00:37:19.240
- Well, I have to do it alone.

00:37:19.310 --> 00:37:23.500
Before we switch a couple
of words to scrolling,

00:37:23.570 --> 00:37:26.160
the scrolling demo is a no-show.

00:37:26.340 --> 00:37:32.590
I said I hated benchmarks,
I hate scrolling benchmarks even more.

00:37:32.890 --> 00:37:36.520
I don't want,
I hate it when it scrolls too fast.

00:37:36.640 --> 00:37:39.810
And I have a bad experience
with scrolling benchmarks from

00:37:39.810 --> 00:37:42.400
a couple years ago on 8.5.

00:37:42.480 --> 00:37:48.710
I got in the last weeks before final a
bug that text drawing was so damn slow,

00:37:48.780 --> 00:37:51.280
terribly slow, big disaster.

00:37:51.400 --> 00:37:55.360
And the way the tester measured it was by
scrolling through a long text document.

00:37:55.470 --> 00:37:59.320
It took me hours to
figure out that in fact,

00:37:59.320 --> 00:38:03.230
HIToolbox, the control manager,
had put in throttles to

00:38:03.320 --> 00:38:08.250
slow down scrolling due to
a user interface request.

00:38:08.680 --> 00:38:10.340
So that's why.

00:38:10.390 --> 00:38:13.100
This doesn't mean that
scrolling is not the problem.

00:38:13.160 --> 00:38:14.360
Why is scrolling a problem?

00:38:14.360 --> 00:38:21.170
Has been a problem up until now
is because Quick Draw has to do

00:38:21.170 --> 00:38:25.890
this huge massive move of bytes
in the backing store before it

00:38:25.890 --> 00:38:27.540
can get flushed and show up.

00:38:27.590 --> 00:38:32.000
Whereas before scrolling
happened right in video RAM.

00:38:32.110 --> 00:38:35.320
So for Jaguar, scrolling as you have
learned has been accelerated.

00:38:35.370 --> 00:38:41.490
It has been hooked up to uh,
the scroll-rect call-in quick draw.

00:38:41.810 --> 00:38:47.030
It still is not hooked up completely
to a pure direct copy bits call

00:38:47.030 --> 00:38:48.630
in cases where it could be used.

00:38:49.200 --> 00:38:53.180
This is going to happen next week.

00:38:54.110 --> 00:38:57.300
But still,
the problems which Ralph showed

00:38:57.460 --> 00:39:02.090
where somebody scrolls a window
content and everything gets yellow

00:39:02.530 --> 00:39:11.570
may not even have to do with
improper use of scroll rect or such.

00:39:11.730 --> 00:39:15.200
I know that it's much easier when
you have a huge document and the

00:39:15.200 --> 00:39:19.120
window really is just a window into
this document to maintain the source

00:39:19.130 --> 00:39:22.020
rectangle and just do a single copy
of it while you are scrolling through.

00:39:23.460 --> 00:39:29.760
The problem is, in this case,
the scroll rect optimization that

00:39:29.760 --> 00:39:34.170
now goes back to hardware accelerated
scrolling cannot be applied.

00:39:34.170 --> 00:39:35.020
There's no way.

00:39:35.070 --> 00:39:38.490
Which means,
it means more work for you to replace

00:39:38.600 --> 00:39:43.600
this simple copy bits call with a
moving source rectangle by some more

00:39:43.600 --> 00:39:48.490
bookkeeping and a direct scroll rect
call in the window and then filling

00:39:48.680 --> 00:39:51.550
in the little area that gets exposed.

00:39:52.260 --> 00:39:55.700
This was what I had to add
to scrolling and then finally

00:39:55.700 --> 00:40:01.150
we get to the demo machine,
please.

00:40:05.600 --> 00:40:12.500
So we are coming to the second.

00:40:12.500 --> 00:40:16.630
Yeah, this machine is faster
than my machine at home.

00:40:18.860 --> 00:40:21.150
We got these reports about frame rates.

00:40:21.240 --> 00:40:23.290
Now suddenly here I display frame rates.

00:40:23.460 --> 00:40:24.960
355, pretty good.

00:40:25.140 --> 00:40:28.320
The window is too small.

00:40:28.320 --> 00:40:32.810
Yeah, that's more like it.

00:40:35.700 --> 00:40:44.170
You see that we spend 8 milliseconds
for so many copy-witch calls.

00:40:44.330 --> 00:40:50.390
During 1.8 seconds and we spend 106
microseconds in the flash port buffer

00:40:50.700 --> 00:40:56.050
on average the theoretical frame rate is
the number of copy bits calls per second

00:40:56.820 --> 00:41:00.300
that came out of one of the G worlds.

00:41:00.350 --> 00:41:01.640
I have 20 G worlds in the background.

00:41:01.640 --> 00:41:08.100
They differ only by a little
moving out of this pattern.

00:41:09.140 --> 00:41:13.420
Of course I don't flush 111 times,
but I could.

00:41:13.500 --> 00:41:15.490
So if I would,

00:41:18.100 --> 00:41:22.510
I flush 80 times per second,
I flush 90 times per second and so on.

00:41:22.760 --> 00:41:26.230
And if you watch,
maybe we don't get so far

00:41:26.370 --> 00:41:29.000
here and we won't waste time.

00:41:29.050 --> 00:41:31.980
You should play around with this at home.

00:41:32.250 --> 00:41:38.870
and then run into puzzling situations
and convince yourself that just don't

00:41:38.870 --> 00:41:41.440
do it because we won't help you fix it.

00:41:41.470 --> 00:41:45.860
You run into situations where it doesn't
make sense to flush 140 times a second.

00:41:45.870 --> 00:41:49.140
It depends on hardware,
it depends on many other instances.

00:41:49.170 --> 00:41:54.070
It's a similar game as
the one that Ralph demoed.

00:41:54.190 --> 00:41:57.110
If you start drawing,
in this case copy bits before the

00:41:57.110 --> 00:42:01.740
previous flush has completed then
you're just locking up and suddenly

00:42:02.160 --> 00:42:06.240
your copy bits calls themselves
appear to become much slower.

00:42:06.260 --> 00:42:08.360
Why would copy bits become slower?

00:42:08.380 --> 00:42:10.400
It's always the same code.

00:42:10.430 --> 00:42:13.760
Well, something secret is
going on in the system.

00:42:13.840 --> 00:42:18.260
The application gets starved
out of processor cycles.

00:42:18.290 --> 00:42:20.040
It's held back.

00:42:20.070 --> 00:42:21.880
And these are subtle things.

00:42:21.910 --> 00:42:24.280
They are too complicated for myself.

00:42:24.420 --> 00:42:30.010
So, um,
play around with it but don't take it

00:42:30.300 --> 00:42:37.030
as an invitation and an encouragement
and to heat up the frame rate race.

00:42:37.440 --> 00:42:42.800
What I like much more, my favorite,
is this one.

00:42:44.010 --> 00:42:48.840
There's a long story to it and the
drawing is so slow that I thought

00:42:48.840 --> 00:42:50.900
I had time to tell the story.

00:42:51.130 --> 00:42:55.900
Well here it turns out
that it's not that slow.

00:42:55.900 --> 00:43:03.900
But imagine that this wireframe drawing
comes from a real world application and

00:43:03.900 --> 00:43:06.900
the people want to design the architects.

00:43:06.900 --> 00:43:10.680
They want to turn this around
interactively and in real

00:43:10.680 --> 00:43:12.900
time make modifications to it.

00:43:12.900 --> 00:43:20.340
With waiting 7 seconds or up to 20-30
seconds on slower machines for this

00:43:20.570 --> 00:43:22.900
to redraw is completely impossible.

00:43:22.900 --> 00:43:30.930
By the way on system 9 the same
drawing takes 2 seconds instead of 7.

00:43:31.910 --> 00:43:34.080
which is still way too slow.

00:43:34.240 --> 00:43:36.300
So what did Jean-Paul Armand do?

00:43:36.560 --> 00:43:42.120
He wrote his own Brezenham and brought
it down to something under half a second.

00:43:42.270 --> 00:43:45.870
So with less than half a
second you can push it around

00:43:46.430 --> 00:43:49.200
the cathedral and work on it.

00:43:49.450 --> 00:43:54.900
and when he found out
that on system 10 his

00:43:55.790 --> 00:43:59.180
On system 10.1,
here we are running Jaguar,

00:43:59.180 --> 00:44:01.300
which is different.

00:44:01.390 --> 00:44:06.380
On 10.1, he spent about 20 seconds
redrawing the wireframe.

00:44:06.880 --> 00:44:12.100
He made a big noise on the development
list and I took him aside and said hey

00:44:12.260 --> 00:44:17.200
let's work on this together and the first
thing we figured out was the dirty region

00:44:17.240 --> 00:44:20.870
processing is there so a hidden key

00:44:22.110 --> 00:44:23.820
and David B.

00:44:24.760 --> 00:44:28.680
By the way, these two applications,
they will show up hopefully

00:44:28.680 --> 00:44:33.930
next week or sometime soon on
developer.appl.com with the source

00:44:33.930 --> 00:44:38.500
code so you can really figure out what
I'm doing there and what's going on.

00:44:42.470 --> 00:44:45.510
So with something like
two-thirds of a second,

00:44:45.610 --> 00:44:47.180
that's not so bad.

00:44:47.180 --> 00:44:50.550
But remember there was something
else on the slides which we

00:44:50.550 --> 00:44:53.280
could use to improve performance.

00:44:53.280 --> 00:44:56.320
The key L for lock port bits.

00:44:56.320 --> 00:45:00.400
There you go.

00:45:00.400 --> 00:45:03.190
Now it's better than his brazen hum.

00:45:05.500 --> 00:45:10.520
So now you can go home and tell your
people there was an old Bavarian

00:45:10.850 --> 00:45:12.500
who taught an old dog new tricks.

00:45:28.800 --> 00:45:30.970
Thanks Joseph.

00:45:30.970 --> 00:45:36.140
So Joseph's just showing you how you
can actually get performance on quick

00:45:36.200 --> 00:45:39.160
draw applications to what you expected.

00:45:39.210 --> 00:45:43.960
So take advantage of those two tips.

00:45:44.930 --> 00:45:47.200
Going forward,
I will spend the rest of the

00:45:47.200 --> 00:45:50.800
session talking about tips and
tricks in general regarding Quartz,

00:45:50.870 --> 00:45:53.250
2D, and Quickdraw also.

00:45:54.410 --> 00:46:00.630
So one of the biggest requests we've
had during the last year or two is,

00:46:00.930 --> 00:46:04.530
Quartz has this great anti-aliasing,
how can I get this in

00:46:04.530 --> 00:46:07.360
my Carbon application?

00:46:08.600 --> 00:46:14.040
We've actually added this feature in
for Jaguar so that this will allow you

00:46:14.130 --> 00:46:21.300
to have carts render your glyphs for
you and you will get the same level

00:46:21.300 --> 00:46:25.300
of text-centered aliasing quality that
you see in the rest of the system.

00:46:26.100 --> 00:46:29.300
We do this using the new
API called Quick Draw,

00:46:29.300 --> 00:46:31.500
swap text flags.

00:46:31.650 --> 00:46:33.840
It's not on by default,
and I'll mention why later.

00:46:33.840 --> 00:46:39.740
But you can use this to
pass in the first flag,

00:46:39.740 --> 00:46:40.980
which is use CG text rendering.

00:46:40.980 --> 00:46:46.500
Here we're using Core Graphics of
Quartz to do the rendering of the text,

00:46:46.540 --> 00:46:48.580
but using the metrics in QuickDraw.

00:46:48.580 --> 00:46:53.980
If you choose, you can actually use CG to
do the rendering and at the

00:46:53.990 --> 00:46:55.470
same time use the CG metrics.

00:46:55.480 --> 00:46:58.960
The difference between the
two is one will cause a relay

00:46:58.960 --> 00:47:02.940
out because QuickDraw metrics,
you're used to, you know how the text

00:47:03.020 --> 00:47:03.770
is going to position.

00:47:03.780 --> 00:47:08.210
It's only the glyph will
be rendered with Quartz.

00:47:09.710 --> 00:47:12.810
Using CG text metrics,
they are subpixel positions,

00:47:12.810 --> 00:47:15.030
so you've got fractional
components in there,

00:47:15.030 --> 00:47:18.450
and as a result,
you'll actually get better-looking text.

00:47:18.600 --> 00:47:21.500
So you want to take advantage,
make the decision which

00:47:21.500 --> 00:47:24.900
one you prefer better,
and use that in your application.

00:47:24.940 --> 00:47:28.350
You can always fall back to the
traditional quick draw rendering

00:47:28.570 --> 00:47:30.550
using the last flag I mentioned here.

00:47:30.960 --> 00:47:34.900
Using Quick Draw Soft Text Flags,
that's an application-wide setting.

00:47:34.900 --> 00:47:37.220
If you want,
you can also do it on a per-put basis

00:47:37.400 --> 00:47:40.780
using the API I mentioned at the bottom.

00:47:42.190 --> 00:47:47.340
One of the reasons it's not on by
default is there are limitations.

00:47:47.480 --> 00:47:51.260
Quickdraw's imaging model is
different from Quartz's imaging model,

00:47:51.260 --> 00:47:55.060
so not all the text styles and
transfer modes are supported.

00:47:55.180 --> 00:47:58.860
So in those cases, it will fall back to
Quickdraw text rendering.

00:47:59.730 --> 00:48:08.830
There is a feature in Quick Draw called
Glyph Squishing that fixed the

00:48:08.940 --> 00:48:15.250
rendering of glyphs where the font
styles-- the font itself did not

00:48:15.290 --> 00:48:17.960
have correct vertical metrics.

00:48:18.040 --> 00:48:19.670
So we'll actually do some
squishing of the glyphs.

00:48:19.950 --> 00:48:22.060
That's once again not
supported in Quartz.

00:48:22.180 --> 00:48:25.130
Just recognize that that's
not going to be there.

00:48:26.990 --> 00:48:29.940
Using CG text metrics
will cause relay out,

00:48:29.940 --> 00:48:32.210
as I mentioned earlier,
and because it's actually

00:48:33.410 --> 00:48:37.500
positioned on a subpixel boundary,
it will be slower.

00:48:37.500 --> 00:48:40.200
So that's why it's up to
you as a developer to make a

00:48:40.200 --> 00:48:44.030
decision as to whether you want
CG rendering in your system or not,

00:48:44.030 --> 00:48:47.870
or whether you want
text to reflow or not.

00:48:48.210 --> 00:48:51.390
We cannot do this on by default
in the system because every

00:48:51.390 --> 00:48:53.200
application is different.

00:48:53.430 --> 00:48:58.930
There will be a Q&A available for this
discussing these things in more detail.

00:49:00.690 --> 00:49:03.540
So you've got a Carbon application,
you want to move over to using

00:49:03.540 --> 00:49:05.800
Quartz 2D in your application.

00:49:05.830 --> 00:49:06.900
You've got a Quick Draw port.

00:49:06.920 --> 00:49:07.940
How do you get a CG context?

00:49:08.030 --> 00:49:11.730
You use Quick Draw's Begin CG context.

00:49:12.350 --> 00:49:15.000
That gives you a context for that port.

00:49:15.010 --> 00:49:19.400
You go ahead, do your port rendering,
and then when you're done with it,

00:49:19.420 --> 00:49:22.140
you do a quick draw and CG context.

00:49:22.150 --> 00:49:26.890
You cannot intersperse quick
draw rendering inside of that.

00:49:27.060 --> 00:49:32.330
If you want to do that,
you have to perform the end CG context.

00:49:32.820 --> 00:49:36.460
One common thing that most people run
into is they forget to flush the context.

00:49:36.580 --> 00:49:39.080
So before the end CG context,
make sure you do call the

00:49:39.170 --> 00:49:40.500
CG context flush routine.

00:49:40.830 --> 00:49:44.600
That's how you'll get your
content onto the screen.

00:49:45.130 --> 00:49:46.850
But given that we've
already mentioned that,

00:49:46.850 --> 00:49:50.860
you know, avoid redundant flushing,
what you may instead want to choose to

00:49:50.870 --> 00:49:52.720
do is to use a CG context synchronized.

00:49:52.720 --> 00:49:55.050
And what that will do is you
may have multiple contexts,

00:49:55.110 --> 00:49:57.180
multiple controls,
multiple views that are all

00:49:57.180 --> 00:49:58.660
drawing at the same drawing.

00:49:58.660 --> 00:50:02.680
You don't want all of those
to flush on their own.

00:50:02.680 --> 00:50:04.140
You want it all to appear atomically.

00:50:04.140 --> 00:50:06.840
Use a CG context synchronized
instead of the flush routine.

00:50:06.980 --> 00:50:11.140
And that will add to the dirty region
and so that when at the end of the

00:50:11.140 --> 00:50:15.320
event loop when Carbon does its
flushing of all the dirty region,

00:50:15.320 --> 00:50:17.060
it will all come up as one single flush.

00:50:19.850 --> 00:50:24.440
Another tip related to this
is you should now be able to

00:50:24.500 --> 00:50:27.460
replace your poster picture
comments with Quartz 2D rendering.

00:50:27.460 --> 00:50:30.780
So where you've got existing
poster picture comments,

00:50:30.780 --> 00:50:34.340
replace those using a
Begin CG Context drawer.

00:50:34.340 --> 00:50:40.680
Do the equivalent rendering using Quartz,
primarily because the imaging model is

00:50:40.710 --> 00:50:42.480
the same between PDF and PostScript.

00:50:42.600 --> 00:50:44.440
So that should be an
easy transition for you.

00:50:44.490 --> 00:50:45.740
You can use that.

00:50:45.930 --> 00:50:49.910
And the benefit there is it's not only
going to print on PostScript printers,

00:50:49.980 --> 00:50:54.300
but it will also print on ink charts.

00:50:56.510 --> 00:51:01.400
Another nice feature that we have
added that has been there since 10.1

00:51:01.400 --> 00:51:06.440
is the ability to actually render
PIC drawings into a CG context.

00:51:06.570 --> 00:51:11.010
So the benefit you get here
is it actually uses CG to

00:51:11.010 --> 00:51:13.860
do the rendering of the PIC.

00:51:15.010 --> 00:51:17.940
It will also respect any of the
Quartz 2D transformations that you

00:51:17.940 --> 00:51:19.640
may have set up into the context,
and now you can actually

00:51:19.640 --> 00:51:22.580
rotate your pics,
transform them however

00:51:22.580 --> 00:51:23.850
you want them to be.

00:51:24.760 --> 00:51:30.870
Other simple benefits you will get
is it actually substitutes shades of

00:51:30.930 --> 00:51:33.700
gray instead of the PIXMAP patterns
that you might be used to.

00:51:33.730 --> 00:51:36.700
So it's better shown as an example.

00:51:36.700 --> 00:51:39.700
So this is Quickdraw rendering the PICT.

00:51:39.700 --> 00:51:42.680
And now this is Quartz
rendering the PICT.

00:51:43.120 --> 00:51:45.240
And as I was mentioning,
all your vector line art is

00:51:45.240 --> 00:51:49.660
actually rendered using Quartz,
and your pattern has been

00:51:49.740 --> 00:51:51.760
replaced by a shade of gray.

00:51:53.050 --> 00:51:56.690
There are limitations to this,
once again, given the two imaging

00:51:56.690 --> 00:51:57.640
models being different.

00:51:57.670 --> 00:52:02.500
So there's no special transfer modes
that are present in Quick Draw.

00:52:02.500 --> 00:52:07.290
The CG doesn't necessarily have those,
so stay away from XR.

00:52:07.300 --> 00:52:11.430
We don't necessarily
support them in Quartz 2D.

00:52:11.630 --> 00:52:12.930
There is also a performance difference.

00:52:13.050 --> 00:52:17.370
One is using native quick draw
to actually render the pic.

00:52:17.800 --> 00:52:20.000
The other one is actually going
through a conversion process.

00:52:20.040 --> 00:52:23.290
But this is a good opportunity for you
to actually convert your pics into PDF,

00:52:23.290 --> 00:52:27.250
which is the recommended
way of processing these.

00:52:27.290 --> 00:52:31.710
It's very easy to create a PDF context,
make this single call to draw

00:52:31.710 --> 00:52:35.210
that pic into the PDF context,
and now you've actually

00:52:35.270 --> 00:52:37.000
converted your pic into a PDF.

00:52:39.900 --> 00:52:44.560
Another common request we have is how
do I actually get my graphics importers

00:52:44.560 --> 00:52:47.220
in QuickTime to work with Quartz?

00:52:47.440 --> 00:52:50.690
We're working with the QuickTime team to
better integrate the two technologies,

00:52:50.720 --> 00:52:53.160
but in the meantime we've actually
got some sample code that I'll

00:52:53.230 --> 00:52:55.390
just quickly go over today.

00:52:55.730 --> 00:52:59.030
In this case,
all we're doing is we're creating a

00:52:59.110 --> 00:53:01.940
32-bit ARGB G World on off-screen buffer.

00:53:01.940 --> 00:53:05.140
Get the graphics imported to
actually draw into that buffer.

00:53:05.140 --> 00:53:09.940
One of the limitations of this is
everything is flattened into 32-bit ARGB.

00:53:09.940 --> 00:53:12.700
So if you happen to have
an image that is CMYK,

00:53:12.700 --> 00:53:15.700
you would have to make
that choice on your own,

00:53:15.740 --> 00:53:20.280
or be it any other color
space or 8-bit or 16-bit data.

00:53:20.280 --> 00:53:22.330
Don't forget color profiles.

00:53:22.360 --> 00:53:24.470
Everything is managed.

00:53:25.480 --> 00:53:27.250
Using color sync in Quartz.

00:53:27.340 --> 00:53:31.120
So get the color profile,
color sync color profile from QuickTime.

00:53:31.120 --> 00:53:33.590
Convert that into a CG color space.

00:53:33.660 --> 00:53:36.420
There's a convenience function
that we provide for you to do that.

00:53:36.460 --> 00:53:39.380
Once you've got that,
you can get all your information about

00:53:39.380 --> 00:53:40.890
that image using the graphics importer.

00:53:40.900 --> 00:53:44.000
And when you create the image,
like the width, height,

00:53:44.050 --> 00:53:47.010
the alpha information, anything else,
that's available from

00:53:47.010 --> 00:53:47.860
the graphics importer.

00:53:49.440 --> 00:53:52.630
Specify the data provider,
and you've got an image ref.

00:53:52.740 --> 00:53:57.290
Now you can actually draw it into
the CG image context-- CG context.

00:53:58.670 --> 00:54:03.510
When you're working with images,
recognize that the CG image reps

00:54:03.590 --> 00:54:05.440
at the moment are not cached.

00:54:05.580 --> 00:54:07.430
Possibly that might change in the future,
but at the moment

00:54:07.560 --> 00:54:13.100
everything is specified,
it's rendered in the source data format.

00:54:13.230 --> 00:54:17.600
So if you're downsampling images
and doing a lot of color matching,

00:54:17.660 --> 00:54:20.520
if color matching
becomes an issue for you,

00:54:20.640 --> 00:54:22.950
do the caching yourself.

00:54:23.040 --> 00:54:26.550
For example,
you may have an iPhoto-like application

00:54:26.550 --> 00:54:29.440
where you're drawing a lot of thumbnails.

00:54:29.610 --> 00:54:32.700
The best thing is to draw it into
an off-screen bitmap context,

00:54:32.790 --> 00:54:35.000
cache the results,
create a new CG image out of it,

00:54:35.090 --> 00:54:40.000
and use that where it's already
downsampled for you and the color

00:54:40.010 --> 00:54:43.600
matching is already done for
you in the off-screen buffer.

00:54:43.730 --> 00:54:46.850
Use the JPEG data providers.

00:54:47.600 --> 00:54:50.690
The PNG data providers
that are new for Jaguar.

00:54:50.770 --> 00:54:54.140
The benefit there is you are now passing
compressed data as much as possible

00:54:54.140 --> 00:54:56.140
through the workflow to the screen.

00:54:56.210 --> 00:54:57.460
And it's primarily
important for printing,

00:54:57.460 --> 00:55:02.080
so you've got lots of digital
cameras with high quality JPEGs,

00:55:02.080 --> 00:55:05.560
3 megapixel JPEGs or whatever.

00:55:05.650 --> 00:55:08.410
Use the JPEG data provider.

00:55:08.480 --> 00:55:11.640
The spool files that you'll
be generating will be much,

00:55:11.730 --> 00:55:12.810
much smaller.

00:55:12.930 --> 00:55:14.950
Another point about those data
providers is you can actually

00:55:14.950 --> 00:55:18.230
use custom data providers for any
of the non-native formats that

00:55:18.310 --> 00:55:20.740
might not be supported by Quark2D.

00:55:20.790 --> 00:55:23.440
So even for the JPEG and
PNG data provider,

00:55:23.440 --> 00:55:24.340
you can use those.

00:55:24.360 --> 00:55:30.080
So you can use not only the convenience
ones that we provide from memory,

00:55:30.200 --> 00:55:34.460
from disk, through a URL,
but you can also write your

00:55:34.460 --> 00:55:35.930
own custom data provider.

00:55:36.020 --> 00:55:39.450
For example, you may want to get the
data from a resource file.

00:55:42.540 --> 00:55:45.470
Another common problem that
people ask us about is why

00:55:45.470 --> 00:55:47.860
are complicated paths so slow?

00:55:48.260 --> 00:55:54.110
There's a difference between what...
The definition of what a complex path is,

00:55:54.110 --> 00:55:57.970
as far as Quartz 2D is concerned,
is really dependent on the number

00:55:57.970 --> 00:55:59.000
of intersections in that path.

00:55:59.000 --> 00:56:02.500
For example, in the bottom left,
I've actually got this pattern,

00:56:02.710 --> 00:56:05.500
which is all rendered as one single path.

00:56:05.720 --> 00:56:11.030
Now, recognize that there is a difference
between a single path and if this

00:56:11.030 --> 00:56:14.700
was represented as multiple paths,
all composed of line segments.

00:56:14.700 --> 00:56:17.700
The difference is actually seen
in the intersection region.

00:56:17.700 --> 00:56:23.760
So when Quartz actually
scan converts this data,

00:56:23.790 --> 00:56:28.020
it takes into account the self
intersections of that path and it

00:56:28.090 --> 00:56:32.190
will make sure that it actually
does not do any double drawing.

00:56:32.420 --> 00:56:38.470
If you've got a single
hairline pixel wide path,

00:56:38.470 --> 00:56:42.780
very likely you may not care
about the intersections because

00:56:42.780 --> 00:56:44.800
they're not going to be visible.

00:56:44.930 --> 00:56:49.130
So in that case you may want
to use multiple paths instead

00:56:49.140 --> 00:56:51.430
of a single complicated path.

00:56:52.310 --> 00:56:53.700
There is a difference in the rendering.

00:56:53.760 --> 00:56:59.850
If the quality of rendering of a
single path is not as important to you,

00:56:59.970 --> 00:57:01.300
go with multiple paths.

00:57:01.570 --> 00:57:04.990
They'll be much faster for you.

00:57:05.510 --> 00:57:08.690
The other thing to keep in mind is
with multiple paths and single paths,

00:57:08.690 --> 00:57:11.630
the difference will also be in your
line joints and your line caps.

00:57:11.630 --> 00:57:14.030
So take those into account.

00:57:14.120 --> 00:57:17.400
Avoid using line caps and line
joints when not necessary,

00:57:17.400 --> 00:57:22.550
especially if you've got
small hairline lines.

00:57:24.610 --> 00:57:27.770
Lastly, I just want to cover
another component of course,

00:57:27.770 --> 00:57:29.000
which is the CG Direct Display.

00:57:29.000 --> 00:57:32.600
This is for applications
that are drawing full screen

00:57:32.670 --> 00:57:35.740
applications or games and whatnot.

00:57:35.820 --> 00:57:40.080
For Jaguar, we've actually added some new
APIs to actually get at information

00:57:40.440 --> 00:57:42.770
about list all the online displays.

00:57:42.930 --> 00:57:45.520
We've already had something that would
actually list all the active displays.

00:57:45.740 --> 00:57:48.370
It becomes important
when you're mirroring.

00:57:48.770 --> 00:57:50.920
There's a difference between
active versus online displays.

00:57:51.010 --> 00:57:54.870
Active is the display that is actually--
there's only one single active display.

00:57:54.950 --> 00:57:57.380
All the other online displays
are actually mirrored to

00:57:57.380 --> 00:57:59.320
that single active display.

00:57:59.360 --> 00:58:02.240
We've also got some new
APIs to do some reconfiguring.

00:58:02.410 --> 00:58:05.590
Turn on mirroring,
set the origin of displays.

00:58:05.790 --> 00:58:09.920
And one new API that you might
be interested in is to check to

00:58:10.010 --> 00:58:13.940
see if Quartz Xtreme is actually
running on a particular display.

00:58:14.060 --> 00:58:18.700
That can depend from display to display
depending on the video card you have,

00:58:18.700 --> 00:58:21.330
whether it's on a PCI bus
or an AGP bus or not.

00:58:21.510 --> 00:58:24.890
So you can use that to check to
see if it's actually running.

00:58:25.860 --> 00:58:29.270
And also we'll also be providing
you with a new API to actually get

00:58:29.330 --> 00:58:33.230
the screen DPI given that we've
got a wide variety of monitors

00:58:33.260 --> 00:58:36.480
out there with different DPIs.

00:58:38.790 --> 00:58:45.490
Lastly, use your performance
tools like Quartz Debug,

00:58:45.610 --> 00:58:48.930
Sampler,
and Sample to profile your applications.

00:58:49.020 --> 00:58:52.160
You've heard the mantra before, "Profile,
profile, and then profile some

00:58:52.160 --> 00:58:53.750
more." Use those tools.

00:58:53.860 --> 00:58:55.050
There's also the other tools.

00:58:55.060 --> 00:58:58.530
If you've been at other sessions earlier,
there's the Chud framework that

00:58:58.630 --> 00:59:02.680
provides a new performance tool
to get to the processor level.

00:59:02.950 --> 00:59:06.940
Those are your Shikari and
your Monster type of tools.

00:59:07.060 --> 00:59:08.880
Take advantage of those.

00:59:08.950 --> 00:59:10.660
You've got lots of documentation.

00:59:10.890 --> 00:59:14.310
The one that I recommend is the
Mac OS X Performance Document.

00:59:14.440 --> 00:59:18.310
We've got quite a few
Quartz 2D documents.

00:59:18.990 --> 00:59:21.760
And we've also got upcoming tech
notes and QA about some of the

00:59:21.760 --> 00:59:27.900
QuickDraw performance issues and
the QuickDraw text aliasing feature.

00:59:27.960 --> 00:59:32.590
And now I'd like to invite Travis back
up to go through the rest of the slides.

00:59:37.080 --> 00:59:41.460
What I want to do is take a quick
section and just tell you about the one

00:59:41.460 --> 00:59:44.640
remaining session we have today at WWDC,
and it's an important one.

00:59:44.640 --> 00:59:46.420
It's the feedback forum.

00:59:46.550 --> 00:59:49.380
And this is the place where if
you want to give us feedback

00:59:49.380 --> 00:59:52.120
on what we've been doing,
obviously for Jaguar

00:59:52.240 --> 00:59:58.720
or feedback in general,
please come join us in room J1 at 5:00.

00:59:58.910 --> 01:00:02.060
What I'd like to do is let
you have my email address,

01:00:02.060 --> 01:00:04.760
even though many of you already know it.

01:00:04.890 --> 01:00:07.100
You can contact me at travis@apple.com.

01:00:07.150 --> 01:00:12.050
And this is relating to pretty
much most of the graphics stack in

01:00:12.050 --> 01:00:14.190
Mac OS X with the exception of OpenGL.

01:00:14.290 --> 01:00:16.840
So if you have questions relating to
what was discussed today or if you

01:00:16.840 --> 01:00:22.500
have questions relating to printing,
image capture, color sync, Quartz 2D,

01:00:22.500 --> 01:00:25.230
feel free to contact me.
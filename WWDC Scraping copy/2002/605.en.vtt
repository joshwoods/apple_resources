WEBVTT

00:00:05.080 --> 00:00:06.590
Okay, good morning.

00:00:06.620 --> 00:00:08.720
I can see everybody can hear me.

00:00:08.830 --> 00:00:10.160
Thanks for coming to this session.

00:00:10.190 --> 00:00:13.760
This is on developing
QuickTime components.

00:00:15.240 --> 00:00:18.950
I'm Gary Woodcock from Discrete.

00:00:18.990 --> 00:00:23.230
And what we're going to cover today
are concepts that are common to writing

00:00:23.230 --> 00:00:26.080
all types of QuickTime components.

00:00:26.130 --> 00:00:31.340
So we're not actually going to focus on
the details of any particular component,

00:00:31.450 --> 00:00:35.690
like an image compressor
or a movie exporter,

00:00:35.690 --> 00:00:39.770
but we'll go over the basics of
things that you'll have to do for

00:00:39.770 --> 00:00:39.770
any type of component that you write.

00:00:41.320 --> 00:00:43.080
And hopefully what you'll
take away from this session is

00:00:43.480 --> 00:00:47.780
how to leverage QuickTime to
deploy your own technologies.

00:00:47.780 --> 00:00:50.570
For example,
let's say you have come up with the

00:00:50.580 --> 00:00:52.990
world's best compression algorithm.

00:00:52.990 --> 00:00:57.010
We'd all love to see that in QuickTime,
and there's mechanisms where you

00:00:57.010 --> 00:01:01.440
can make that technology available,
and those mechanisms are components.

00:01:02.480 --> 00:01:06.740
QuickTime is the most flexible
and open media architecture

00:01:06.740 --> 00:01:09.350
that's out there on any platform.

00:01:09.350 --> 00:01:14.250
We as developers have a really
unprecedented ability to customize

00:01:14.250 --> 00:01:17.580
QuickTime to do new and different things.

00:01:20.140 --> 00:01:22.800
Okay, you can also use components
as an extensibility

00:01:22.800 --> 00:01:25.160
mechanism for your software.

00:01:25.260 --> 00:01:28.950
This would be a type of thing
where if you didn't want to-- well,

00:01:28.950 --> 00:01:31.970
if you wanted to encapsulate
functionality in your

00:01:31.970 --> 00:01:34.930
application in a modular way,
components are a way

00:01:35.050 --> 00:01:36.330
that you can do that.

00:01:36.330 --> 00:01:39.770
So you could actually have--
use components as plug-ins,

00:01:39.770 --> 00:01:40.660
for example.

00:01:40.660 --> 00:01:44.770
So you might have a spelling checker
component or a grammar component

00:01:44.890 --> 00:01:46.910
for a word processing application.

00:01:47.050 --> 00:01:48.570
You could actually
bundle them up this way.

00:01:50.090 --> 00:01:55.320
Okay, you should be familiar with C,
the memory manager, the resource manager,

00:01:55.340 --> 00:01:57.240
and of course, the component manager.

00:01:57.240 --> 00:02:01.400
We'll go through a brief review of the
component manager a little later today.

00:02:04.630 --> 00:02:07.540
Okay, so we're going to cover
what is a component,

00:02:07.570 --> 00:02:12.720
why should I write one,
how do I write and debug a component,

00:02:12.780 --> 00:02:15.860
How do I create my own kind of component?

00:02:15.870 --> 00:02:17.170
And then how do I deliver it?

00:02:17.240 --> 00:02:19.020
How do I get it to a
customer or an end user?

00:02:22.140 --> 00:02:25.370
Basically, a component is just another
type of code library.

00:02:25.470 --> 00:02:28.290
We've probably all
written static libraries,

00:02:28.290 --> 00:02:31.000
shared libraries of various types.

00:02:31.000 --> 00:02:35.240
A component is really, at its heart,
just another type of code library.

00:02:35.240 --> 00:02:39.910
It can be used by multiple clients,
so it has the concept of reusability.

00:02:41.760 --> 00:02:46.250
It can be private or public,
so there's a notion of scoping.

00:02:46.380 --> 00:02:48.410
And it can be versioned.

00:02:49.280 --> 00:02:52.550
and you might say to yourself, "Well,
gee, that's not really all that

00:02:52.550 --> 00:02:55.790
unique," but components have a
very interesting feature in that

00:02:55.880 --> 00:03:00.300
they can be searched by capability
as opposed to a name or a symbol.

00:03:00.300 --> 00:03:04.200
Basically, you can say,
"I need this type of functionality,"

00:03:04.200 --> 00:03:07.280
and there's various levels of
granularity that you can request this,

00:03:07.280 --> 00:03:10.860
but you might say,
"I need to get access to a JPEG codec

00:03:11.000 --> 00:03:14.160
or a decompressor." You can actually
ask for that type of functionality

00:03:14.160 --> 00:03:17.940
without really caring who implements it,
what its name is,

00:03:17.940 --> 00:03:21.180
what the symbol tables look like,
and all the usual things that you

00:03:21.310 --> 00:03:25.990
have to deal with with typical
DLL or shared library mechanisms.

00:03:26.330 --> 00:03:30.130
You can also use components to directly
extend the capabilities of QuickTime.

00:03:30.140 --> 00:03:34.260
In other words, we as developers,
we can make QuickTime do things

00:03:34.270 --> 00:03:36.430
that it didn't do out of the box.

00:03:36.830 --> 00:03:40.200
And then, of course, you can deliver your
components on Windows.

00:03:40.200 --> 00:03:43.020
You can deliver it on Mac OS 9, Mac OS X.

00:03:43.020 --> 00:03:48.530
And it's largely the same
code in all those places.

00:03:50.440 --> 00:03:51.420
Okay, so what else can they do?

00:03:51.420 --> 00:03:56.260
Components have a notion of being
able to inherit functionality.

00:03:56.260 --> 00:03:59.250
Basically, you can capture other
kinds of components.

00:03:59.260 --> 00:04:03.440
You can delegate functions to base
components to help you do your work

00:04:03.440 --> 00:04:05.320
when you're writing a component.

00:04:05.390 --> 00:04:08.930
An example of this would be
the base image decompressor,

00:04:08.970 --> 00:04:12.700
where Apple's made it very easy
to write your own decompressor by

00:04:12.780 --> 00:04:16.580
handing off a lot of the maintenance
and housekeeping functions to a base

00:04:17.110 --> 00:04:19.090
component that will do that for you.

00:04:19.290 --> 00:04:23.800
So you can concentrate on just
writing the differentiating code

00:04:23.800 --> 00:04:26.430
for your image decompressor.

00:04:27.550 --> 00:04:29.800
Components can also
expose user interface.

00:04:29.800 --> 00:04:33.170
Probably some of the most popular
or most prominent examples of that

00:04:33.180 --> 00:04:36.840
would be the movie controller is a
component that exposes interface.

00:04:36.860 --> 00:04:40.390
The standard compression
dialog is another component

00:04:40.400 --> 00:04:42.210
that has user interface.

00:04:42.770 --> 00:04:46.480
Okay, you can use -- your component can
use other components to create a

00:04:46.490 --> 00:04:48.840
fairly complex chain of functionality.

00:04:48.880 --> 00:04:54.580
Think of something like
the sequence grabber,

00:04:54.680 --> 00:05:00.170
which makes it fairly easy for
an application to put video

00:05:00.170 --> 00:05:00.170
acquisition into their application.

00:05:00.170 --> 00:05:00.170
It's a component that actually uses,
you know,

00:05:00.490 --> 00:05:05.120
Half a dozen or more different components
to get that functionality into your app.

00:05:05.210 --> 00:05:08.320
And you don't actually know about it,
because you have a very simple

00:05:08.320 --> 00:05:10.320
API that you're using at the top level.

00:05:10.320 --> 00:05:15.180
But these things can be chained together
to do some really amazing things.

00:05:16.010 --> 00:05:20.000
Okay, so real quickly,
let's compare components to

00:05:20.000 --> 00:05:21.650
other types of libraries.

00:05:21.690 --> 00:05:23.900
So this is just a quick table.

00:05:23.900 --> 00:05:25.860
You can see search by name.

00:05:26.000 --> 00:05:27.960
Generally speaking,
everybody can do that.

00:05:28.010 --> 00:05:35.800
Components are unique in that
they can search by capability,

00:05:35.800 --> 00:05:35.800
and we'll talk about this in a
little bit more detail in a moment.

00:05:36.160 --> 00:05:37.340
Dynamically loaded?

00:05:37.380 --> 00:05:38.380
Sort of.

00:05:38.380 --> 00:05:41.850
Windows and OS X have this ability.

00:05:41.850 --> 00:05:44.090
OS 9 components do not.

00:05:46.600 --> 00:05:51.570
You can use a variety of
languages to write components.

00:05:51.670 --> 00:05:54.770
I actually haven't tried to
write a component in Objective-C.

00:05:54.840 --> 00:05:59.020
If any of you ever try that,
I'd love to hear the results of that.

00:05:59.120 --> 00:06:03.300
But pretty much any type of language
you can use to write a component.

00:06:04.340 --> 00:06:06.120
And then, of course,
as we mentioned earlier,

00:06:06.130 --> 00:06:08.480
they're supported on a wide
variety of operating systems.

00:06:08.480 --> 00:06:11.320
Basically, anywhere QuickTime runs,
you could potentially

00:06:11.320 --> 00:06:12.360
deliver your component.

00:06:14.540 --> 00:06:16.170
Okay, some popular components.

00:06:16.470 --> 00:06:19.810
These are just things that
developers often write.

00:06:20.010 --> 00:06:22.400
Image codecs,
movie importers and exporters,

00:06:22.400 --> 00:06:26.680
graphics importers, exporters,
video digitizers, media handlers.

00:06:26.680 --> 00:06:29.970
These are all examples of components
that third-party developers have

00:06:30.080 --> 00:06:31.680
written to extend QuickTime.

00:06:31.680 --> 00:06:37.630
And there are many examples of
this in the marketplace today.

00:06:38.560 --> 00:06:41.930
At its heart,
a component contains a dispatcher,

00:06:42.180 --> 00:06:49.150
which is basically just a mechanism
to route client requests to

00:06:49.150 --> 00:06:49.150
a routine in your component.

00:06:49.700 --> 00:06:51.490
There are four required
component routines.

00:06:51.600 --> 00:06:53.070
We'll go through each of these in detail.

00:06:53.220 --> 00:06:55.990
Every component should implement these.

00:06:56.420 --> 00:07:00.370
There are some optional component
routines that are defined,

00:07:00.370 --> 00:07:03.970
your choice as to whether
you want to implement them.

00:07:04.230 --> 00:07:08.900
And then each component type
has a set of interfaces that

00:07:08.900 --> 00:07:12.050
are associated with the type.

00:07:12.190 --> 00:07:17.120
So, for example,
a video digitizer component has probably

00:07:17.120 --> 00:07:23.840
over 100 different routines that
are defined for that component type.

00:07:24.750 --> 00:07:27.900
And then, whoops, I'm sorry,
support resources.

00:07:28.020 --> 00:07:31.960
These are the component resource,
might be the component resource

00:07:31.960 --> 00:07:35.560
map if your component needs
to export public resources.

00:07:35.560 --> 00:07:38.160
Again, we'll talk about these in
more detail a little later.

00:07:38.160 --> 00:07:41.030
But basically these things,
pretty much any component

00:07:41.030 --> 00:07:42.640
will have this as a minimum.

00:07:45.230 --> 00:07:48.220
Okay,
real quick component manager review.

00:07:48.220 --> 00:07:52.140
So the component manager
basically manages the components

00:07:52.140 --> 00:07:56.100
and the connections from
clients to those components.

00:07:57.020 --> 00:08:02.890
and it's actually part of Mac OS and on
Windows it's delivered with QuickTime.

00:08:04.970 --> 00:08:07.360
Components are always
identified by a type,

00:08:07.360 --> 00:08:09.070
a subtype, and a manufacturer.

00:08:09.300 --> 00:08:13.500
These are 4CC codes.

00:08:13.580 --> 00:08:14.500
Not too much you have
to worry about here.

00:08:14.500 --> 00:08:16.820
There's a lot that are
predefined by Apple.

00:08:16.980 --> 00:08:20.910
Lowercase types are, as usual,
reserved for Apple,

00:08:20.910 --> 00:08:25.090
so as a third-party developer,
you need to use either a mix

00:08:25.150 --> 00:08:29.560
of uppercase and lowercase or
something along those lines,

00:08:29.620 --> 00:08:31.710
but stay away from the
all lowercase things.

00:08:31.710 --> 00:08:31.710
Those are reserved.

00:08:32.620 --> 00:08:35.600
Okay, you have to register a
component before you can use it.

00:08:35.610 --> 00:08:38.180
There's a variety of mechanisms
that you can do this,

00:08:38.430 --> 00:08:42.790
depending on whether you want to
make your component widely available

00:08:42.790 --> 00:08:47.290
to all kinds of applications or
whether you want to use it privately,

00:08:47.290 --> 00:08:50.360
and we'll talk about
that in a little bit.

00:08:50.360 --> 00:08:54.100
We already mentioned that.

00:08:54.100 --> 00:08:54.100
Each component has its own unique API.

00:08:54.930 --> 00:08:57.720
This is an example of how
you would find a component.

00:08:57.720 --> 00:09:02.460
So in this case,
we have a math component type.

00:09:02.540 --> 00:09:06.240
This is actually the sample component
that will be in the sample code.

00:09:06.240 --> 00:09:08.810
There will be a URL later for
where you can go download that.

00:09:09.070 --> 00:09:13.140
But what we're saying here is basically
we want to get a math component.

00:09:13.140 --> 00:09:16.610
We don't really care what subtype
or what manufacturer it is.

00:09:16.700 --> 00:09:21.760
Just go find the first one that
you can locate and give me its ID.

00:09:21.760 --> 00:09:24.100
We could refine this search.

00:09:24.650 --> 00:09:29.900
If, for example, there were, you know,
the Super Food Company had a particular

00:09:29.900 --> 00:09:33.820
type of math component that had
extremely good precision or something,

00:09:33.820 --> 00:09:37.830
we could actually substitute the
4cc for that manufacturer in the

00:09:38.120 --> 00:09:42.590
component manufacturer field to say,
I really want to find that component.

00:09:42.600 --> 00:09:44.770
In other words,
don't just give me any one.

00:09:44.910 --> 00:09:47.270
Give me that particular one.

00:09:49.000 --> 00:09:51.300
Opening a component is really easy.

00:09:51.300 --> 00:09:55.120
You take the component ID and
you call open a component,

00:09:55.120 --> 00:09:59.900
you get a component instance,
which is your connection as a client.

00:09:59.930 --> 00:10:03.590
The only thing to point out here,
there's an older call called

00:10:03.590 --> 00:10:06.400
open component that does
not return a result code,

00:10:06.400 --> 00:10:10.350
so I would encourage everyone to use
this form of the call because it will

00:10:10.350 --> 00:10:12.380
actually give you the result code.

00:10:14.630 --> 00:10:19.350
You can query a component to see if a
particular selector in its component type

00:10:19.770 --> 00:10:24.520
interface is actually supported before
you use it or before you try to call it.

00:10:24.590 --> 00:10:30.750
The call component can do,
and it takes your component instance

00:10:30.750 --> 00:10:35.640
along with the selector of interest,
and then it returns basically

00:10:35.740 --> 00:10:40.570
zero if it's not supported,
and then if it returns anything else,

00:10:40.600 --> 00:10:42.260
it's supported.

00:10:42.920 --> 00:10:46.340
So you can call this to find out
before you try to call a routine

00:10:46.340 --> 00:10:48.650
whether it'll actually work or not.

00:10:50.920 --> 00:10:55.500
version,
basically every component has a version.

00:10:55.500 --> 00:11:00.210
It returns a long and the high
word of the long is actually

00:11:00.210 --> 00:11:02.610
the interface revision.

00:11:02.610 --> 00:11:06.800
So if you are writing
your own component API,

00:11:06.830 --> 00:11:13.560
you'll define normally a 1 for
your component interface version.

00:11:13.890 --> 00:11:19.090
The lower two bytes are actually
the implementation version.

00:11:19.090 --> 00:11:23.290
So as you do bug fixes or you bump
the revision of the implementation,

00:11:23.330 --> 00:11:24.670
you would actually bump that number.

00:11:27.640 --> 00:11:30.020
Okay, you can... Components,
this is what I was referring to a

00:11:30.020 --> 00:11:37.140
little earlier about being able to
do some limited form of inheritance.

00:11:37.140 --> 00:11:40.560
You can target components,
and what this call is basically

00:11:40.640 --> 00:11:46.140
saying is when you would normally
call your component internally

00:11:46.140 --> 00:11:52.280
to do a particular function,
if you make this call to a component,

00:11:52.280 --> 00:11:53.940
this says, use the target instead.

00:11:53.940 --> 00:11:54.940
Don't call yourself.

00:11:55.200 --> 00:11:55.920
Call the target.

00:11:57.060 --> 00:12:02.450
This allows another component
to be able to override another

00:12:02.670 --> 00:12:06.850
component's behavior by forcing
that component to call out to it.

00:12:09.160 --> 00:12:11.220
It's actually a really
simple thing to support,

00:12:11.220 --> 00:12:12.220
as we'll see later.

00:12:12.220 --> 00:12:14.940
Okay,
then closing a component is very simple.

00:12:14.940 --> 00:12:18.830
You just close the component instance,
and that's it.

00:12:20.950 --> 00:12:25.200
There are some platform
differences I'd like to point out.

00:12:25.260 --> 00:12:30.220
On the Mac OS 9 and earlier,
there's a global registration

00:12:30.220 --> 00:12:32.290
list for components.

00:12:32.370 --> 00:12:36.070
Basically,
there's one big list of components that

00:12:36.070 --> 00:12:43.960
all processes and address spaces can see,
and so you can actually see component

00:12:43.960 --> 00:12:47.770
instance counts for things that
are not actually in your process.

00:12:48.200 --> 00:12:49.920
In OS X and Windows, this isn't true.

00:12:49.920 --> 00:12:53.500
You get a local list for each process.

00:12:53.500 --> 00:12:57.610
There are some implications to
that we'll talk about in a moment.

00:12:59.730 --> 00:13:02.130
Component reference constants.

00:13:02.130 --> 00:13:07.130
These are a 32-bit value that can
be stored with the component ID.

00:13:07.310 --> 00:13:10.930
The idea here is that that
value can be retrieved by any

00:13:11.080 --> 00:13:13.310
instance of that component.

00:13:14.950 --> 00:13:18.030
Okay,
and we'll talk about how that's used.

00:13:18.030 --> 00:13:23.620
Modification seeds and instance counting,
again, these on OS X and Windows only

00:13:23.620 --> 00:13:25.910
work on a per-process basis.

00:13:25.910 --> 00:13:28.780
They don't work across all processes.

00:13:28.870 --> 00:13:35.320
So I might count two instances of a
JPEG decompressor in one process on OS X,

00:13:35.320 --> 00:13:40.200
and in a different process
there may be one instance.

00:13:40.230 --> 00:13:43.630
But I don't actually, they don't have any
relationship to one another.

00:13:44.370 --> 00:13:47.850
other than their JPEG components.

00:13:49.590 --> 00:13:51.800
Okay, this sometimes trips people up.

00:13:51.800 --> 00:13:56.220
Carbon components don't
actually run on OS 9.

00:13:56.220 --> 00:13:58.240
See, this one crop up every now and then.

00:13:58.240 --> 00:14:00.440
If you want to build
a component for OS 9,

00:14:00.440 --> 00:14:03.700
you actually still need to
link against interface slide.

00:14:06.200 --> 00:14:09.180
And on OS X and Windows,
the register and unregister routines

00:14:09.370 --> 00:14:13.140
are actually invoked each time
a new QuickTime process starts.

00:14:13.230 --> 00:14:16.370
So if you have a component
that implements these things,

00:14:16.480 --> 00:14:19.600
it will actually get called
each time on OS X and Windows.

00:14:19.600 --> 00:14:23.120
On OS 9 earlier,
it was really just when the component was

00:14:23.120 --> 00:14:25.750
first registered for the entire system.

00:14:25.750 --> 00:14:31.950
So there are, again,
implications to that,

00:14:31.950 --> 00:14:31.950
and let's talk about those.

00:14:32.230 --> 00:14:34.480
Okay,
so you actually want to avoid using the

00:14:34.480 --> 00:14:38.970
component refcon to store common instance
data across processes or address spaces.

00:14:38.970 --> 00:14:41.650
This doesn't work on OS X and Windows.

00:14:41.680 --> 00:14:44.790
What used to happen in
OS X is people would say,

00:14:44.790 --> 00:14:47.800
I want to do some,
like a lookup table setup,

00:14:47.800 --> 00:14:51.860
and I'd store it in a handle or
a pointer off the refcon with the

00:14:51.860 --> 00:14:55.930
idea that any time that component
was opened in any process,

00:14:55.930 --> 00:14:58.350
I could actually get that value.

00:14:59.290 --> 00:15:02.790
Okay,
that doesn't work on OS X in Windows.

00:15:03.550 --> 00:15:06.890
Okay, again,
one of the older usages of register

00:15:07.120 --> 00:15:12.620
and unregister was sort of a one-time
setup and teardown type of routine.

00:15:12.620 --> 00:15:18.020
As we noted earlier, on OS X and Windows,
these two routines actually

00:15:18.030 --> 00:15:21.750
get called each time that
your QuickTime process begins.

00:15:21.750 --> 00:15:25.740
So if you really have a
one-time thing you need to do,

00:15:25.740 --> 00:15:27.410
this doesn't work.

00:15:27.460 --> 00:15:31.730
Also on OS X, you may actually incur
additional application launch

00:15:31.730 --> 00:15:33.280
overhead or boot overhead.

00:15:33.430 --> 00:15:37.110
For the process, because you actually are
running these things multiple

00:15:37.160 --> 00:15:38.600
times instead of just once.

00:15:38.600 --> 00:15:44.200
So you want to avoid doing that sort of
thing in register and unregister on OS X.

00:15:46.320 --> 00:15:50.090
Okay, and then as we noted earlier,
you really, if you want to limit

00:15:50.090 --> 00:15:54.040
connections to your component,
counting instances is probably

00:15:54.040 --> 00:15:55.760
not the best way to do that.

00:15:55.860 --> 00:16:00.170
If you had some hardware resource,
for example, that you really could only

00:16:00.170 --> 00:16:03.430
have one connection to that,
and you were using a component

00:16:03.900 --> 00:16:06.800
to wrap the interface,
because you get a different

00:16:06.800 --> 00:16:09.990
copy of that component,
or a different registration

00:16:09.990 --> 00:16:13.590
of it per process,
you can't actually limit the connections

00:16:13.600 --> 00:16:15.760
to your hardware resource this way.

00:16:18.300 --> 00:16:21.820
Okay, development tools.

00:16:21.820 --> 00:16:25.320
In the sample code that's posted,
what I did is I actually used

00:16:25.320 --> 00:16:29.250
Project Builder for OS X,
Code Warrior for the OS 9 and earlier,

00:16:29.330 --> 00:16:32.290
and Visual Studio.net
for the Windows code.

00:16:32.290 --> 00:16:35.420
There are other environments you can use.

00:16:35.500 --> 00:16:39.140
For example, you can use Code Warrior to
build Windows components.

00:16:39.500 --> 00:16:44.600
These are just sort of the
prominent environments for

00:16:44.600 --> 00:16:45.070
the various operating systems.

00:16:47.130 --> 00:16:49.680
Okay, so you're probably saying, okay,
can we really start now?

00:16:49.680 --> 00:16:50.490
What are we doing?

00:16:50.500 --> 00:16:54.020
Okay, what we're going to do is we're
going to try to define a component

00:16:54.060 --> 00:16:56.440
that can actually add two
numbers and give you the result.

00:16:56.500 --> 00:17:01.040
Something that would take
you one line of C code,

00:17:01.150 --> 00:17:06.610
we're going to stretch out into
a bunch of lines of C code.

00:17:06.610 --> 00:17:10.010
But it'll be illustrative of the
process of what you have to do to write

00:17:10.010 --> 00:17:10.010
an interface and write a component.

00:17:10.990 --> 00:17:13.890
We'll support all the required routines
and most of the optional routines,

00:17:13.890 --> 00:17:17.380
and then we're going to see how
calls in the client program translate

00:17:17.660 --> 00:17:19.260
to routines in the component.

00:17:23.150 --> 00:17:24.120
Okay, so here's our API.

00:17:24.120 --> 00:17:31.900
And it's... It looks a little strange,
but there's some similarities to what

00:17:31.900 --> 00:17:36.220
you would do if you were defining an
API for any other kind of code library.

00:17:36.220 --> 00:17:42.310
In the highlighted portion,
we have basically a return code,

00:17:42.320 --> 00:17:43.560
which is the component result.

00:17:43.560 --> 00:17:45.930
We have the name of the function,
which is math add.

00:17:45.940 --> 00:17:47.480
And then we have an argument list.

00:17:47.540 --> 00:17:51.340
And the first argument in any
component call is going to

00:17:51.340 --> 00:17:52.250
be the component instance.

00:17:52.400 --> 00:17:53.840
This is your connection to the component.

00:17:53.840 --> 00:17:57.860
And then the rest of the arguments are
the interesting arguments for the call.

00:17:57.860 --> 00:18:01.260
In this case, we have, you know,
the first number, the second number,

00:18:01.260 --> 00:18:03.700
and then we return a
result of the addition.

00:18:03.700 --> 00:18:08.300
The rest of what's there is...
You'll see that the first line,

00:18:08.300 --> 00:18:10.760
the kmath add select,
is actually a selector.

00:18:10.760 --> 00:18:12.100
That's a component selector.

00:18:12.100 --> 00:18:19.130
Component selectors for things
that... in interfaces you write

00:18:19.260 --> 00:18:20.690
or interfaces that you use.

00:18:21.940 --> 00:18:23.250
Most cases will be positive.

00:18:23.530 --> 00:18:30.780
The base selectors, which are the open,
close version, and can do,

00:18:30.780 --> 00:18:33.410
and some of the optional ones,
these are all negative selectors.

00:18:33.420 --> 00:18:36.440
So negative selectors are
reserved for use by Apple.

00:18:36.440 --> 00:18:39.650
So none of us actually will
get to define any of those.

00:18:39.700 --> 00:18:45.010
You'll also see if you
go look in any of the,

00:18:45.020 --> 00:18:49.720
like quicktimecomponents.h, for example,
you'll see selector numbers

00:18:49.720 --> 00:18:51.560
for the various component
types that are in there.

00:18:51.700 --> 00:18:52.730
Thank you.

00:18:52.970 --> 00:18:57.390
The rest of this is
basically some macros.

00:18:57.410 --> 00:19:01.390
Xtern API is basically a helpful
macro that keeps you from having

00:19:01.390 --> 00:19:05.310
to write things like Xtern
Pascal underscore underscore,

00:19:05.470 --> 00:19:08.200
DeclSpec, DLL import,
whatever it might be.

00:19:08.200 --> 00:19:12.360
If you use this, it will actually,
when you compile,

00:19:12.540 --> 00:19:14.940
insert the right stuff for you.

00:19:14.980 --> 00:19:17.180
So it's pretty handy.

00:19:17.970 --> 00:19:24.950
The component call now is a macro
that really is associating the amount

00:19:24.950 --> 00:19:29.760
of space needed by your argument
list for the component manager.

00:19:29.760 --> 00:19:33.880
So that's why we see
the size of calls here.

00:19:33.880 --> 00:19:36.390
Basically what we're saying
is we need eight bytes of

00:19:36.400 --> 00:19:37.950
space for our argument list.

00:19:41.790 --> 00:19:44.700
Okay,
there's also some constants that we need.

00:19:44.700 --> 00:19:47.790
So we mentioned our type, subtype,
and manufacturer earlier.

00:19:47.910 --> 00:19:52.770
So for the sake of this demonstration,
we're going to use math

00:19:52.770 --> 00:19:54.560
and WWDC and Apple.

00:19:54.560 --> 00:20:02.190
We need a resource ID for our component,
and then we have our interface version

00:20:02.190 --> 00:20:05.670
and our implementation version.

00:20:05.670 --> 00:20:06.080
So they're both one because
we're creating something new.

00:20:08.160 --> 00:20:11.930
Okay,
every component needs instance storage,

00:20:11.930 --> 00:20:15.870
or every component instance
needs some storage.

00:20:15.990 --> 00:20:18.930
What's listed here is basically
the minimal stuff that almost

00:20:18.930 --> 00:20:20.440
every component will need.

00:20:20.450 --> 00:20:25.090
The self is the reference that
the component manager assigned

00:20:25.150 --> 00:20:27.780
when open component was called.

00:20:27.780 --> 00:20:30.830
So we actually get that in our component,
and we can actually use that

00:20:30.970 --> 00:20:34.280
to call other routines in our
interface from within our component.

00:20:35.740 --> 00:20:39.860
Target, if you recall earlier
our discussion of that,

00:20:40.150 --> 00:20:43.750
this is when our component
is targeted externally,

00:20:43.750 --> 00:20:48.340
this is the instance that is passed
in and that we store in our component.

00:20:49.890 --> 00:20:54.040
This will allow us to where we would
call self or use self to call one

00:20:54.040 --> 00:20:58.120
of our internal routines or call
one of our routines internally,

00:20:58.120 --> 00:21:02.040
excuse me, we would instead use target
if we had been targeted.

00:21:05.500 --> 00:21:08.260
Okay, the dispatcher.

00:21:08.280 --> 00:21:12.090
And this causes a lot of issues.

00:21:12.220 --> 00:21:15.150
It basically is just responsible
for mapping our selectors to the

00:21:15.200 --> 00:21:17.380
routines that we've implemented.

00:21:17.380 --> 00:21:21.950
You can write it yourself,
and you can go through the pain

00:21:22.060 --> 00:21:26.590
of dealing with mixed-mode logic
and routine descriptors and all

00:21:26.590 --> 00:21:29.930
sorts of other gnarly stuff,
or you can use the component

00:21:29.930 --> 00:21:33.860
dispatch helper.c file,
which I strongly recommend everyone use,

00:21:33.930 --> 00:21:37.380
and it will handle all
of that stuff for you.

00:21:37.380 --> 00:21:39.580
It's not very hard to use.

00:21:39.580 --> 00:21:42.070
We'll go through it in detail here.

00:21:42.610 --> 00:21:44.930
Again, do use that.

00:21:45.020 --> 00:21:48.540
If you really want to see what it does,
you can preprocess the file,

00:21:48.540 --> 00:21:51.310
your component file,
and dump out the C code and look at

00:21:51.310 --> 00:21:53.100
what the dispatcher does for you.

00:21:53.100 --> 00:21:55.750
And then maybe that might convince
you that you don't actually want

00:21:55.750 --> 00:21:56.930
to hand code all that stuff.

00:21:59.240 --> 00:22:04.080
Okay, so the dispatch helper is
part of the QuickTime SDK.

00:22:04.080 --> 00:22:07.200
And what we're going to do is we're
going to write a dispatch header file

00:22:07.200 --> 00:22:11.230
and go through all the defines that
you actually need to create to make

00:22:11.370 --> 00:22:13.720
it generate the right thing for you.

00:22:14.600 --> 00:22:20.500
Okay, so we have a dispatch header file,
and the first part of it looks like this.

00:22:20.500 --> 00:22:23.100
We'll go through each line here.

00:22:23.170 --> 00:22:27.590
So the first line,
we have a component selector offset.

00:22:28.340 --> 00:22:31.430
This is basically the number
of base selectors that we're

00:22:31.460 --> 00:22:34.000
specifying in our component.

00:22:34.000 --> 00:22:40.480
This number I put 10 here,
that's actually the total number

00:22:40.480 --> 00:22:40.480
of base selectors that are defined
by the component manager today.

00:22:40.690 --> 00:22:43.400
It's a contiguous number
of base selectors.

00:22:43.400 --> 00:22:45.680
It's not the total possible number.

00:22:45.680 --> 00:22:51.150
If you put 10, in your dispatch file,
you'll need to have 10 entries.

00:22:51.350 --> 00:22:53.780
We'll go through that in a moment.

00:22:53.780 --> 00:22:57.920
Then we have the number of selector
ranges that we're going to define.

00:22:57.920 --> 00:23:03.140
A selector range is really,
every component has a range of selectors

00:23:03.140 --> 00:23:08.640
for the component manager calls,
open, close, can-do, version.

00:23:08.640 --> 00:23:12.430
And then presumably for it to be useful,
there's at least one range

00:23:12.430 --> 00:23:14.150
for the component type.

00:23:14.180 --> 00:23:15.880
So we have one range.

00:23:15.920 --> 00:23:21.300
We're going to use our math component
interface that we're defining.

00:23:21.770 --> 00:23:25.700
Again,
it's a contiguous range of selectors,

00:23:25.700 --> 00:23:31.100
and there are two other defines
that help the component dispatch

00:23:31.100 --> 00:23:36.940
helper understand how to interpret
some of the range information.

00:23:36.940 --> 00:23:39.150
The first is a range shift.

00:23:39.150 --> 00:23:42.000
A lot of folks get hung up on this one.

00:23:42.000 --> 00:23:46.790
It's basically the amount that a
selector value is shifted left and then

00:23:46.990 --> 00:23:48.900
incremented to produce its range number.

00:23:49.780 --> 00:23:51.660
I have an example listed here.

00:23:51.660 --> 00:23:57.040
If we had a selector value,
if our math add select value was, say,

00:23:57.040 --> 00:24:06.070
0101, if we shifted left by 8,
we'd get 1, and then we would actually

00:24:06.070 --> 00:24:09.620
say we'd add 1 to that,
and it would actually be in range 2.

00:24:09.620 --> 00:24:13.580
In our particular case,
when we define our selector as 0,

00:24:13.580 --> 00:24:18.710
we shift that left, we get 0, we add 1,
it's in component range 1.

00:24:20.190 --> 00:24:21.180
So that's all it is.

00:24:21.180 --> 00:24:26.240
It's just a shift in the increment to
get the range that your selectors are in.

00:24:26.570 --> 00:24:29.460
Okay,
so that tells us how to find the range.

00:24:29.520 --> 00:24:33.780
We also need to be able to find what
entry we're talking about within a range,

00:24:33.780 --> 00:24:35.920
and the range mask helps us do that.

00:24:35.960 --> 00:24:43.060
So we can actually use this value
to mask against the selector

00:24:43.060 --> 00:24:46.960
to get the particular entry
in a given component range.

00:24:46.960 --> 00:24:52.100
So if we use the 01-01 example again,
that would actually

00:24:52.180 --> 00:24:53.610
map to routine entry 1.

00:24:54.520 --> 00:24:56.760
Okay, so we'd mask off that first 01.

00:24:56.760 --> 00:24:57.900
We'd be left with 01.

00:24:57.900 --> 00:24:58.700
That's our entry.

00:25:01.750 --> 00:25:04.380
Okay,
so that's really all there is to that.

00:25:04.380 --> 00:25:06.870
We have a storage type
that we need to define.

00:25:06.980 --> 00:25:10.550
If you recall back,
we talked about each component

00:25:10.550 --> 00:25:12.580
instance needs storage.

00:25:12.670 --> 00:25:13.370
That can be a pointer.

00:25:13.380 --> 00:25:14.730
It can be a handle.

00:25:14.820 --> 00:25:18.700
This is just declaring what
kind of a thing that it is.

00:25:18.700 --> 00:25:21.710
Generally speaking,
unless you've just got a really

00:25:22.040 --> 00:25:26.410
huge set of component information,
you need to keep track of

00:25:26.410 --> 00:25:28.070
it on an instance basis.

00:25:28.290 --> 00:25:31.260
Most of the time I just
use pointer for this.

00:25:33.650 --> 00:25:36.720
Okay, so here's our,
this was our range zero, if you will.

00:25:36.720 --> 00:25:40.490
These are our base selectors that
the component manager defines.

00:25:40.520 --> 00:25:46.080
So what we see here is we're
going to support basically

00:25:46.280 --> 00:25:52.150
the first six selectors,
open, close, can do, version, register,

00:25:52.690 --> 00:25:54.230
target, did I say six?

00:25:54.320 --> 00:25:55.780
It's actually seven, and unregister.

00:25:55.780 --> 00:26:00.020
For those components or those selectors,
we're not going to write a routine for,

00:26:00.020 --> 00:26:01.860
we'll define component error for.

00:26:01.940 --> 00:26:04.970
It just tells the dispatcher that
return an error code for that if

00:26:04.970 --> 00:26:07.460
anybody tries to call it because
we don't actually implement it.

00:26:10.320 --> 00:26:13.900
Okay, and again, these selectors,
the order is actually significant here.

00:26:13.900 --> 00:26:17.860
So this actually,
get public resource has a value of

00:26:17.860 --> 00:26:20.900
minus 10 for its selector value.

00:26:20.900 --> 00:26:27.600
Open has a minus 1, so it's significant,
the order of declaration here.

00:26:27.600 --> 00:26:30.480
And again,
negative selectors are reserved by Apple.

00:26:31.160 --> 00:26:33.020
Okay, so here's our range.

00:26:33.090 --> 00:26:35.760
We have one selector, and it's math add.

00:26:35.760 --> 00:26:38.080
And it's just that simple.

00:26:38.080 --> 00:26:44.160
We have a component call that says,
again, it's just another macro.

00:26:44.160 --> 00:26:45.430
And then we have a
component call that says,

00:26:45.430 --> 00:26:45.430
again, it's just another macro.

00:26:45.650 --> 00:26:48.500
There are some other
ones you can use here.

00:26:48.500 --> 00:26:49.860
We aren't going to
have it in our example,

00:26:50.040 --> 00:26:52.180
but other things that you can
have are component delegate.

00:26:52.180 --> 00:26:58.920
If you have a component that
your component opens that you

00:26:59.510 --> 00:27:06.210
want to pass calls off to,
you can actually tell the dispatcher to

00:27:06.210 --> 00:27:07.510
call that component instead of calling
your component for a particular selector.

00:27:10.810 --> 00:27:15.480
Okay, there's a bunch of defines that
the component dispatch helper

00:27:15.480 --> 00:27:17.560
actually needs to do its job.

00:27:17.640 --> 00:27:19.690
And we'll go through these.

00:27:22.040 --> 00:27:26.280
So this define is really just
the prefix of our component-- the

00:27:26.320 --> 00:27:28.540
names of our component routines.

00:27:28.540 --> 00:27:31.430
In this case, I've used __math.

00:27:31.540 --> 00:27:34.240
So if you looked in-- when
you look in the sample code,

00:27:34.240 --> 00:27:37.280
you'll actually see a routine
in the body of the component

00:27:37.280 --> 00:27:39.060
that's called __mathopen.

00:27:39.170 --> 00:27:45.260
So all that's happening here is
the dispatch helper's using this

00:27:45.260 --> 00:27:49.610
to catenate to the base selector
names and our API selector names.

00:27:51.330 --> 00:27:55.550
This is just telling the dispatcher
what kind of storage we have.

00:27:55.680 --> 00:28:00.560
Our storage type is actually
MathGlobal's pointer.

00:28:00.560 --> 00:28:06.690
We define this value so that the
dispatcher knows that's the kind of

00:28:06.920 --> 00:28:09.840
data type we use for our storage.

00:28:13.530 --> 00:28:17.040
And then we have a prefix
for any of the universal proc

00:28:17.130 --> 00:28:21.860
pointer information that we need,
which in this case is UPP math.

00:28:21.940 --> 00:28:24.820
If you look in some, again,
in some of the

00:28:24.820 --> 00:28:29.620
QuickTime component headers,
you'll see the same type of stuff for

00:28:29.620 --> 00:28:35.170
all the components basically have a UPP,
VD, you know, get max source rack,

00:28:35.190 --> 00:28:38.150
for example, for a video digitizer.

00:28:38.150 --> 00:28:42.900
So this is just the prefix that's used.

00:28:43.590 --> 00:28:47.320
And then we tell it where to
actually find the dispatch file.

00:28:47.350 --> 00:28:50.760
This is basically the stuff that says,
"Here's the component ranges.

00:28:50.980 --> 00:28:55.010
Here are the entries that we're
actually supporting in our component."

00:28:56.860 --> 00:29:03.480
And then we have an API-unique set
of defines for our math interface,

00:29:03.480 --> 00:29:06.800
the base name and the globals.

00:29:06.800 --> 00:29:09.840
In most cases,
it's safe to just use the same stuff

00:29:09.840 --> 00:29:14.260
that you defined for the component
base and the component globals.

00:29:14.270 --> 00:29:18.330
There's really not much need
to make those different.

00:29:19.330 --> 00:29:23.080
Okay, so finally we get to the point
where we can start to include

00:29:23.100 --> 00:29:26.830
all of this into our .c file,
and this is the order in which we

00:29:26.840 --> 00:29:30.590
would actually do the includes,
and it too is significant.

00:29:30.590 --> 00:29:32.220
You want to pull things in.

00:29:32.310 --> 00:29:36.810
The base components select this k.h file,
our math selectors, k.h,

00:29:36.860 --> 00:29:38.780
and then the dispatch helper.

00:29:38.780 --> 00:29:43.090
So all the stuff that the dispatch
helper actually needs to generate the

00:29:43.120 --> 00:29:45.490
dispatcher has to be included first.

00:29:45.490 --> 00:29:49.170
You're probably asking,
what is this k.h file?

00:29:49.210 --> 00:29:50.680
file.

00:29:52.140 --> 00:29:56.540
And these are some of the utility macros
that are actually needed by the helper.

00:29:56.540 --> 00:30:00.700
And rather than go through
this in exhaustive detail,

00:30:00.700 --> 00:30:07.010
and I have a hard time remembering
this myself from instance to instance

00:30:07.010 --> 00:30:11.610
of work that I do with components,
you could actually just treat

00:30:11.700 --> 00:30:13.720
this more or less as a template.

00:30:13.720 --> 00:30:16.090
And if you need to write
your own interface,

00:30:16.600 --> 00:30:22.140
you can take this and basically change
math to whatever your needs are.

00:30:22.140 --> 00:30:25.770
And it's basically stuff that
here's how you catenate things,

00:30:25.800 --> 00:30:33.020
here are the storage types, the prefixes,
things of that nature.

00:30:33.020 --> 00:30:35.620
It just helps the component
manager understand how it can put

00:30:35.780 --> 00:30:38.430
together all these defines and
build out the dispatcher names.

00:30:40.930 --> 00:30:46.890
Okay, and then we also have another
expression of our prototype.

00:30:46.910 --> 00:30:50.490
It looks similar to what we
defined in the selectors.h,

00:30:50.490 --> 00:30:53.950
but it's expressed with some
of the defines that we use,

00:30:54.010 --> 00:30:56.730
like the math globals,
add math base name,

00:30:56.900 --> 00:31:01.200
which is that underscore,
underscore math thing we talked about.

00:31:01.260 --> 00:31:08.190
So it's really just the same expression
of the API in a slightly different way.

00:31:10.000 --> 00:31:13.690
Okay, and then we have this
UPP proc info constant.

00:31:13.890 --> 00:31:18.040
And actually, if you look at this in
the QuickTime headers,

00:31:18.140 --> 00:31:22.640
you'll actually see these usually
expressed as some hex number.

00:31:22.860 --> 00:31:27.390
And basically what you see here is
a bunch of macros and defines that

00:31:27.530 --> 00:31:33.220
will actually generate a similar hex
number if you actually preprocess this.

00:31:33.220 --> 00:31:36.740
You'd get some 32-bit long hex number.

00:31:37.440 --> 00:31:41.050
Again, it's about telling the component
manager how much space that you

00:31:41.050 --> 00:31:44.540
need for your return values and
for your arguments in your routine.

00:31:44.540 --> 00:31:46.920
And that's really what this is about.

00:31:51.540 --> 00:31:55.830
Okay, let's look at how each of the
routines are actually implemented.

00:31:55.980 --> 00:31:58.150
So this is the open routine.

00:31:59.050 --> 00:32:02.770
Again,
these are intended to show the minimum

00:32:03.430 --> 00:32:07.270
things that a component would need to do.

00:32:07.280 --> 00:32:10.430
You open a component,
and the first thing that you actually

00:32:10.440 --> 00:32:14.410
need to do is allocate some storage
for your component instance state.

00:32:14.420 --> 00:32:16.500
That's the new pointer call there.

00:32:16.500 --> 00:32:19.940
Then we actually tell the
component manager to associate

00:32:19.950 --> 00:32:22.090
that storage with our instance.

00:32:22.100 --> 00:32:25.100
That's what the set component
instance storage is about.

00:32:25.740 --> 00:32:30.140
And then you see a line there that
is global self equals global target.

00:32:30.140 --> 00:32:34.890
This is just so that anywhere
where we might call one of

00:32:35.040 --> 00:32:39.160
our API routines internally,
we'll just always use target.

00:32:39.160 --> 00:32:42.240
So we don't have to actually keep
track of whether it's self or target.

00:32:42.240 --> 00:32:44.960
We'll just always use that,
and we'll initialize it to be self,

00:32:45.050 --> 00:32:48.670
so that we're always calling
internally to start with.

00:32:54.360 --> 00:32:56.400
Okay,
and the close routine is pretty simple.

00:32:56.400 --> 00:33:00.810
The biggest thing to remember
here is just be sure to clean

00:33:00.810 --> 00:33:02.880
up everything that you're using.

00:33:02.880 --> 00:33:06.540
So for this particular example,
it's very simple.

00:33:06.540 --> 00:33:09.870
We just need to dispose
of our instance storage.

00:33:09.870 --> 00:33:15.490
But if you had other types of data
that you had in handles or pointers,

00:33:15.490 --> 00:33:18.220
you need to clean that up here.

00:33:18.220 --> 00:33:21.720
This might be a good place
to close down connections to

00:33:21.720 --> 00:33:24.090
hardware if you needed to do that.

00:33:24.820 --> 00:33:27.480
Basically,
put the system back to where it was,

00:33:27.480 --> 00:33:30.400
where you found it when
you actually opened,

00:33:30.400 --> 00:33:31.580
as much as possible.

00:33:34.160 --> 00:33:37.020
Okay, the version routine, again,
very simple.

00:33:37.020 --> 00:33:39.900
It's just return your
version information.

00:33:41.240 --> 00:33:45.840
So those are those constants that we
defined as our implementation is one

00:33:45.840 --> 00:33:48.190
and our interface version is one.

00:33:48.190 --> 00:33:51.660
So that's a very simple
routine to implement.

00:33:51.660 --> 00:33:54.780
Okay, then we have the can-do routine.

00:33:56.810 --> 00:33:59.250
I actually put this slide
together before I knew there

00:33:59.250 --> 00:34:00.840
was actually Jamba Juice here.

00:34:00.840 --> 00:34:03.910
But in any event,
you don't actually have to write this if

00:34:04.020 --> 00:34:06.290
you use the component dispatch helper.

00:34:06.290 --> 00:34:08.260
It will write this routine for you.

00:34:08.280 --> 00:34:11.740
So you get it for free if you use
the component dispatch helper.

00:34:15.620 --> 00:34:16.810
Okay, register routine.

00:34:16.820 --> 00:34:22.040
Now, this routine is optional.

00:34:22.040 --> 00:34:24.380
You don't have to implement it.

00:34:24.510 --> 00:34:29.520
It can be used to check to see what
kind of environment you're dealing in.

00:34:29.520 --> 00:34:32.290
In this example, what I did was say,
all right,

00:34:32.400 --> 00:34:35.850
let's go make sure that a particular
version of QuickTime is actually

00:34:35.860 --> 00:34:40.120
present before I allow this
component to be registered for use.

00:34:40.120 --> 00:34:45.150
So what happens here is
if QuickTime 4.1.2 isn't,

00:34:45.320 --> 00:34:48.670
or later, isn't installed,
we actually won't

00:34:48.740 --> 00:34:51.660
register this component,
and it won't be available for use.

00:34:51.660 --> 00:34:56.110
So things you might do here are
if you required a particular

00:34:56.240 --> 00:34:59.590
operating system service or a
particular feature of QuickTime,

00:34:59.600 --> 00:35:03.560
that sort of thing,
you might check for that here,

00:35:03.560 --> 00:35:07.120
and then not allow the
component to be used.

00:35:07.120 --> 00:35:10.990
If you do use this routine,
you do need to set the component

00:35:10.990 --> 00:35:13.980
wants registered message flag
in your component resource,

00:35:13.980 --> 00:35:16.000
and we'll look at that a little later.

00:35:19.250 --> 00:35:20.340
Okay, the target routine.

00:35:20.340 --> 00:35:22.900
Again, this is fairly simple.

00:35:22.900 --> 00:35:27.080
If you recall earlier in the open,
we set the target field

00:35:27.080 --> 00:35:29.400
to be pointing to self.

00:35:29.410 --> 00:35:34.910
And here what happens is we
simply update that value with what

00:35:34.910 --> 00:35:38.060
gets passed into this routine.

00:35:38.060 --> 00:35:41.890
So we update target to be target,
and then we continue to use it the

00:35:41.900 --> 00:35:43.860
way we were using it all along.

00:35:43.900 --> 00:35:49.180
And then if it gets set to null,
we'll just reset back to target.

00:35:49.200 --> 00:35:50.870
himself.

00:35:52.570 --> 00:35:53.380
Okay, unregister.

00:35:53.380 --> 00:35:56.460
Again, this is another optional routine.

00:35:56.460 --> 00:35:57.670
You don't have to support it.

00:35:57.740 --> 00:36:01.500
I actually couldn't think of
a really good example here.

00:36:01.500 --> 00:36:02.870
It's not used all that often.

00:36:03.030 --> 00:36:07.730
But if there was some particular cleanup
that you needed to do in general for your

00:36:07.810 --> 00:36:12.650
component that you couldn't do in Close,
this is kind of your last

00:36:13.010 --> 00:36:15.650
opportunity to do that cleanup.

00:36:15.850 --> 00:36:19.340
And if you want to use this routine,
again, there's another flag.

00:36:19.500 --> 00:36:22.670
There's a flag in the resource,
in your component resource called

00:36:22.670 --> 00:36:24.160
component wants unregister.

00:36:24.160 --> 00:36:29.570
And it's actually in the
component register flags field.

00:36:29.570 --> 00:36:33.130
And you have to set that
flag or this routine won't be

00:36:35.460 --> 00:36:37.970
The component manager has this
notion of public resources.

00:36:37.980 --> 00:36:42.940
So components can have
public and private resources.

00:36:42.940 --> 00:36:46.180
And private resources are
really those things that you

00:36:46.180 --> 00:36:48.610
want to use in your component,
but you don't really

00:36:48.610 --> 00:36:49.970
want anybody else to use.

00:36:49.980 --> 00:36:54.180
Public resources are those things that
your component may use internally,

00:36:54.180 --> 00:36:57.050
but you would actually want,
or you would want to provide

00:36:57.050 --> 00:37:00.400
the ability for other clients
of your component to use.

00:37:03.160 --> 00:37:08.350
You do this by means of a THNR resource,
a component resource map,

00:37:08.420 --> 00:37:14.500
and it associates your private component
type and ID with a public type and ID.

00:37:14.500 --> 00:37:19.680
Places where you see this
in QuickTime today are,

00:37:19.680 --> 00:37:21.140
for example, for MIME types.

00:37:21.160 --> 00:37:22.820
You might see this kind of a mapping.

00:37:27.250 --> 00:37:33.050
A client gets access to these resources
by calling getComponentPublicResource.

00:37:33.390 --> 00:37:37.850
And you don't actually have to
implement get public resource in

00:37:38.060 --> 00:37:39.740
your component for this to work.

00:37:39.840 --> 00:37:44.950
You only really need to have
the component map resource.

00:37:44.950 --> 00:37:48.610
If you have resources that are actually
dynamically created on the fly,

00:37:48.610 --> 00:37:51.440
like you can't actually
compile them into a .r file,

00:37:51.440 --> 00:37:56.100
you may actually need to implement
this routine in your component.

00:37:56.100 --> 00:37:59.320
But if it's just sort of a straight
mapping from static resources,

00:37:59.320 --> 00:38:02.060
you don't actually have
to implement this routine.

00:38:04.470 --> 00:38:07.130
Okay, finally, after all that,
we're to the point where

00:38:07.130 --> 00:38:08.360
we can add two numbers.

00:38:08.390 --> 00:38:11.460
So, this is our math add routine.

00:38:11.460 --> 00:38:13.900
Pretty simple.

00:38:13.900 --> 00:38:16.710
We just check to make
sure we got good values,

00:38:16.780 --> 00:38:19.560
we add the numbers,
we return it back out.

00:38:21.630 --> 00:38:28.060
We have a component now, and you think,
can I actually start to

00:38:28.060 --> 00:38:30.540
use it from a client?

00:38:30.540 --> 00:38:31.870
Well, not quite yet.

00:38:31.870 --> 00:38:37.760
We actually need to write some glue to
allow clients to call your component.

00:38:37.760 --> 00:38:43.170
The glue basically facilitates the
handoff from the client to the component

00:38:43.170 --> 00:38:46.780
manager and then to the component.

00:38:46.780 --> 00:38:51.090
It is possible to hard link
this into an application.

00:38:51.260 --> 00:38:57.890
This usually ends up as a shared library,
for example,

00:38:58.060 --> 00:39:01.760
on Mac OS 9 or a framework on OS X.

00:39:01.760 --> 00:39:07.010
You can, again,
make this private if you want to so

00:39:07.060 --> 00:39:11.220
that only your client can see it.

00:39:12.160 --> 00:39:15.220
We're going to create a stub library
that our component and any of our

00:39:15.220 --> 00:39:17.120
clients can actually link against.

00:39:19.230 --> 00:39:22.820
And there's gonna be some glue helper
routines that are defined here.

00:39:22.840 --> 00:39:24.440
And I'm gonna go through
this kind of quickly,

00:39:24.440 --> 00:39:28.760
'cause it's fairly, uh, gnarly.

00:39:28.950 --> 00:39:30.760
But again, you can use a lot of this.

00:39:30.840 --> 00:39:35.020
A lot of this is kind of boilerplate,
and a lot of it is really-- the

00:39:35.170 --> 00:39:38.020
stuff that isn't boilerplate
is really wrapped around,

00:39:38.020 --> 00:39:42.700
again, communicating how much space
your component needs for its

00:39:42.850 --> 00:39:44.940
result codes and argument list.

00:39:44.940 --> 00:39:49.200
So you can think of this as kind
of another way to express that.

00:39:49.200 --> 00:39:52.000
So this is the helper
for a call mac component,

00:39:52.000 --> 00:39:58.350
and you'll notice there's, again,
the information here about the result

00:39:59.120 --> 00:40:02.420
size and the stack routine information.

00:40:02.710 --> 00:40:05.030
on Windows it's a little messier.

00:40:05.300 --> 00:40:11.170
You have to actually manually fill
out a component parameter structure,

00:40:11.220 --> 00:40:18.130
and that requires you to do a little
finagling with how many parameters

00:40:18.210 --> 00:40:20.860
you actually have so that you can
fill out that structure correctly.

00:40:20.860 --> 00:40:26.070
In this case, for our Math.Add routine we
actually have three parameters.

00:40:26.070 --> 00:40:29.390
So you can see that we
have--there's a params array at

00:40:29.390 --> 00:40:31.350
the bottom if you can see that.

00:40:31.350 --> 00:40:33.440
So we have three of those.

00:40:33.440 --> 00:40:37.290
If this only had one parameter,
we'd actually have a structure

00:40:37.290 --> 00:40:39.170
that only had the param zero.

00:40:40.470 --> 00:40:42.590
Fortunately, most of the time you're
not writing your own API,

00:40:42.590 --> 00:40:44.020
so you don't have to go through all this.

00:40:44.140 --> 00:40:47.480
For any of the existing component types,
this is all handled for you already.

00:40:49.380 --> 00:40:55.270
Okay, and then there's yet another
expression of our API and how to,

00:40:55.670 --> 00:40:59.140
what to do when this API is encountered.

00:40:59.140 --> 00:41:02.840
So this is, again,
calling through our helper routines.

00:41:02.840 --> 00:41:07.880
And again, it's very gnarly,
but the thing to bear in mind is we're

00:41:07.880 --> 00:41:13.640
basically building up this component
parameter structure so the component

00:41:13.640 --> 00:41:19.280
manager gets the data in the form it
needs before it passes the data line.

00:41:19.300 --> 00:41:21.940
And that's what all that is about.

00:41:21.990 --> 00:41:25.740
All of that stuff is in the sample code,
so there is a working

00:41:25.740 --> 00:41:29.610
example for Windows,
Mac OS X, Mac OS 9, it's all there,

00:41:29.680 --> 00:41:32.760
so you can see frameworks
and shared libraries,

00:41:32.760 --> 00:41:34.830
figure out how to do this glue.

00:41:34.830 --> 00:41:36.550
It is all there for you.

00:41:38.270 --> 00:41:40.650
On Windows,
there's another thing that you need to

00:41:40.750 --> 00:41:42.670
do before you can get rolling with this.

00:41:42.730 --> 00:41:44.680
A component on Windows is
basically a DLL,

00:41:44.750 --> 00:41:46.550
so you need a main entry point.

00:41:46.550 --> 00:41:49.190
This doesn't actually do anything.

00:41:49.190 --> 00:41:53.290
It needs to be there to define
how we get into the component,

00:41:53.300 --> 00:41:56.270
but as you can see, it just returns true.

00:41:56.270 --> 00:42:00.630
It doesn't actually do anything
on the switch statement.

00:42:00.640 --> 00:42:07.630
You also need to export the name
of your component dispatcher.

00:42:07.630 --> 00:42:11.990
That's usually done with
a module definition file.

00:42:12.270 --> 00:42:17.310
Again, this is Windows-only stuff.

00:42:17.820 --> 00:42:22.480
Okay, let's take a quick look at some
of the component resource stuff.

00:42:22.530 --> 00:42:25.880
People get kind of hung up on this one,
too,

00:42:25.880 --> 00:42:31.900
and usually it is either an issue with
flags or in the way that you're defining

00:42:31.900 --> 00:42:35.780
your code type or your platform type.

00:42:35.850 --> 00:42:38.290
So the things I actually
have highlighted here,

00:42:38.290 --> 00:42:40.920
you'll see why in just a moment.

00:42:40.920 --> 00:42:43.270
We have our component type,
component subtype,

00:42:43.280 --> 00:42:45.390
component manufacturer.

00:42:45.390 --> 00:42:47.970
We have some flags information.

00:42:48.130 --> 00:42:52.060
The STRN that you see there is
just a component name resource.

00:42:52.120 --> 00:42:53.780
We'll show that in a minute.

00:42:53.780 --> 00:42:55.740
Then there's an info resource.

00:42:55.740 --> 00:42:57.130
We don't have an icon.

00:42:57.200 --> 00:43:00.430
That's why after the STRI stuff,
there's two zeros that

00:43:00.430 --> 00:43:02.240
would normally be for icons.

00:43:02.320 --> 00:43:04.290
We have a variety of flags here.

00:43:04.290 --> 00:43:09.100
We actually support unregister,
so you'll notice that's actually set.

00:43:09.100 --> 00:43:14.070
The component has multiple platforms
flag is a little bit misleading because

00:43:14.070 --> 00:43:17.740
in this particular example with PowerPC,
we only actually have one

00:43:17.740 --> 00:43:21.590
platform we're building,
but you still need that flag set.

00:43:21.740 --> 00:43:26.460
It basically lets you see the
component extension and define that.

00:43:26.460 --> 00:43:28.700
So in most cases, you'll have that set.

00:43:28.720 --> 00:43:31.680
We have the component wants
register message set because

00:43:31.680 --> 00:43:33.500
we actually implemented that.

00:43:33.500 --> 00:43:38.140
Underscore PPC is just our
code resource type on PowerPC,

00:43:38.260 --> 00:43:41.780
and then we indicate our
platform there as well.

00:43:41.780 --> 00:43:43.170
well.

00:43:43.560 --> 00:43:48.510
You'll notice at the very bottom we
say we have a component resource map.

00:43:48.600 --> 00:43:50.500
That's the THNR.

00:43:50.510 --> 00:43:55.860
So what's different between
this and a Carbon CFM?

00:43:55.960 --> 00:43:58.700
Very little.

00:43:58.700 --> 00:44:03.770
We now have a code fragment resource
that is referring to our code,

00:44:03.830 --> 00:44:07.040
and we changed the platform type.

00:44:08.300 --> 00:44:09.660
Okay, how about MachO?

00:44:09.680 --> 00:44:11.600
Again, very little different.

00:44:11.600 --> 00:44:14.200
We have a DLLE entry
for our code resource,

00:44:14.310 --> 00:44:17.360
and we still have a
PowerPC native entry point.

00:44:17.730 --> 00:44:20.350
Lastly, Windows.

00:44:20.600 --> 00:44:21.500
Very similar.

00:44:21.500 --> 00:44:25.000
We have the DLLE,
but we have a platform Win32.

00:44:25.000 --> 00:44:30.160
So all the rest of that stuff stayed
the same for the component resource.

00:44:30.470 --> 00:44:34.400
But those are the things that make it,
that people get a little hung up on,

00:44:34.400 --> 00:44:38.780
so I wanted to point out that, you know,
largely these things can stay

00:44:38.780 --> 00:44:41.210
very similar across platforms.

00:44:42.250 --> 00:44:44.890
Okay, the code fragment resource,
if you're building that

00:44:44.890 --> 00:44:46.800
type of a component,
a couple things I wanted

00:44:46.800 --> 00:44:47.480
to point out here.

00:44:47.480 --> 00:44:51.410
It's a standard code fragment resource,
but you'll notice in the highlight

00:44:51.500 --> 00:44:54.670
portion we have the CPNT,
which indicates it's a component,

00:44:54.670 --> 00:44:57.290
and then there's this
weird hex value there.

00:44:57.300 --> 00:45:05.280
That actually turns out to simply
be our component resource ID,

00:45:05.280 --> 00:45:06.930
so it's 128,
just expressed as a hex number.

00:45:08.300 --> 00:45:11.290
Okay,
for our Windows and our Mac OS stuff,

00:45:11.290 --> 00:45:14.370
we have a DLL e-resource,
and this is where we

00:45:14.370 --> 00:45:16.630
define the dispatcher name.

00:45:16.630 --> 00:45:19.890
Pay careful attention to this,
because this is often something

00:45:19.950 --> 00:45:23.120
that trips people up when they
try to register their components

00:45:23.120 --> 00:45:24.950
for the first time and use them.

00:45:24.960 --> 00:45:29.760
If there are differences, for example,
on the Windows side between the name

00:45:29.900 --> 00:45:33.690
that you exported and what you have here,
it won't work.

00:45:33.690 --> 00:45:37.090
You need to make sure that those
names are actually the same,

00:45:37.150 --> 00:45:38.300
that they line up.

00:45:40.510 --> 00:45:47.540
Okay, the string name and string info
resources are pretty self-explanatory.

00:45:47.540 --> 00:45:51.550
So when somebody calls get
component info on your component,

00:45:51.640 --> 00:45:56.960
this is the name and the info handles
that will be returned back to the client.

00:45:56.960 --> 00:46:02.740
You can pretty much put
whatever you want here.

00:46:02.880 --> 00:46:05.070
Try to put something explanatory
of what your component does.

00:46:06.780 --> 00:46:09.900
Okay, here's our component resource map.

00:46:09.940 --> 00:46:13.740
And all we really did here,
just again for the

00:46:13.740 --> 00:46:19.050
purposes of an example,
is we have our string name resource,

00:46:19.060 --> 00:46:25.510
and I just mapped it out to be a
public resource of type STR with ID 1.

00:46:25.510 --> 00:46:30.870
So if you actually called get public
resource with type STR and ID 1,

00:46:30.870 --> 00:46:35.700
you would actually get our
component string name resource.

00:46:37.220 --> 00:46:41.500
One thing to notice that I forgot to
mention earlier about public resources,

00:46:41.500 --> 00:46:44.360
they're called resources,
they're not actually

00:46:44.600 --> 00:46:46.310
resource manager handles.

00:46:46.590 --> 00:46:47.850
They're handles.

00:46:47.880 --> 00:46:53.290
So you don't want to call
release resource on them,

00:46:53.290 --> 00:46:53.290
you want to call dispose handle
when you get rid of them.

00:46:57.360 --> 00:47:00.800
Okay,
on Windows we have these interesting

00:47:00.800 --> 00:47:06.630
tools called res and reswac that you need
to run to get your resource information

00:47:06.630 --> 00:47:09.460
attached to your QuickTime component.

00:47:09.580 --> 00:47:13.610
And res is,
if any of you are familiar with the old

00:47:13.640 --> 00:47:19.550
MPW tools for doing resource compilation,
this is very similar,

00:47:19.590 --> 00:47:24.720
except it's a DOS console app
that compiles QuickTime .r

00:47:24.800 --> 00:47:26.860
files into .qtr files.

00:47:27.220 --> 00:47:29.970
Okay,
so it's just sort of a Windows-compatible

00:47:29.970 --> 00:47:31.740
form of the resource for it.

00:47:33.290 --> 00:47:37.110
And then there's another utility
called ResWack that you use to

00:47:37.110 --> 00:47:41.500
actually combine the QTR file
into your Windows component DLL.

00:47:43.330 --> 00:47:46.320
Okay,
and ordinarily these things you can set

00:47:46.320 --> 00:47:49.110
up as just a post-build batch execution.

00:47:49.110 --> 00:47:53.520
Once you're done compiling on Windows,
you can just run a batch file

00:47:53.520 --> 00:47:56.000
that takes care of this for you.

00:47:56.450 --> 00:47:59.680
An example of this is in the sample code.

00:48:00.600 --> 00:48:04.300
Okay, registering components.

00:48:04.300 --> 00:48:05.340
There's three ways we can do this.

00:48:05.540 --> 00:48:09.870
You can do auto-registration,
which basically means I'm just going to

00:48:09.870 --> 00:48:14.200
let the system take care of this for me,
register my component for me.

00:48:14.250 --> 00:48:19.240
So you leave it up to basically
the component manager to decide

00:48:19.580 --> 00:48:22.720
when to register your component.

00:48:22.720 --> 00:48:28.520
Typically that will be when the
QuickTime process on OS X starts up.

00:48:29.500 --> 00:48:30.090
Your component will get picked
up by the component manager,

00:48:30.090 --> 00:48:30.480
and then you can register your component.

00:48:30.500 --> 00:48:34.360
You can also get a component picked up in
the local registration for that process.

00:48:34.410 --> 00:48:37.790
There's also an application called
Reinstaller 3 that's useful if any

00:48:37.790 --> 00:48:41.240
of you are doing Mac OS 9 or earlier
type of testing or development.

00:48:41.240 --> 00:48:43.650
This actually lets you
register a component without

00:48:43.710 --> 00:48:46.510
actually having to reboot,
which is the normal way that you

00:48:46.510 --> 00:48:48.320
would get a component in on OS 9.

00:48:48.320 --> 00:48:53.230
And the last way is a
programmatic registration.

00:48:54.810 --> 00:48:58.640
So the auto registration
basically you just have to put

00:48:58.640 --> 00:49:00.100
the components in the right place.

00:49:00.140 --> 00:49:04.110
On OS 9, that's in the
QuickTime extensions folder,

00:49:04.110 --> 00:49:09.290
in extensions, inside system folder,
and then you reboot.

00:49:09.840 --> 00:49:13.350
On OS X,
you put this into library QuickTime or

00:49:13.350 --> 00:49:16.430
user's username library QuickTime.

00:49:16.480 --> 00:49:18.370
You don't have to reboot.

00:49:18.930 --> 00:49:23.400
On Windows, you put this in your
System32 QuickTime directory.

00:49:23.400 --> 00:49:27.520
On older versions of Windows, prior to,
say, Windows 2K,

00:49:27.520 --> 00:49:31.370
it might actually be System QuickTime,
for example,

00:49:31.410 --> 00:49:34.470
on Windows 98 or something like that.

00:49:35.930 --> 00:49:39.040
And we did,
we just talked about Reinstaller 3.

00:49:39.040 --> 00:49:42.010
This is the URL where you
can actually get this utility

00:49:42.010 --> 00:49:43.570
if you want to download it.

00:49:43.650 --> 00:49:48.880
You can also get to this just off
the main QuickTime developer pages.

00:49:53.350 --> 00:50:00.970
Okay, programmatic registration.

00:50:00.970 --> 00:50:00.970
So register component basically,
basically

00:50:01.160 --> 00:50:06.040
If you have the description of the
component and its main entry point,

00:50:06.040 --> 00:50:11.780
you can use this routine to register
the component local to your application.

00:50:12.110 --> 00:50:15.270
The other way you can do it is if
you've got the component resource,

00:50:15.270 --> 00:50:19.170
you can call register component resource,
and this will do a similar thing.

00:50:20.550 --> 00:50:27.310
So you're probably wondering, though,
why this would be interesting.

00:50:28.060 --> 00:50:32.430
So the first thing is you actually
don't want other clients to

00:50:32.550 --> 00:50:33.910
see your component or use it.

00:50:33.980 --> 00:50:36.070
Why would you ever want to do that?

00:50:36.190 --> 00:50:39.260
Well,
if you were in the Wednesday sessions,

00:50:39.300 --> 00:50:42.820
Tom Dowdy actually mentioned
something about how you could use,

00:50:42.820 --> 00:50:46.240
if you had a proprietary file format,
for example, in your application,

00:50:46.240 --> 00:50:49.320
and maybe you used a lot of
the other file formats that

00:50:49.320 --> 00:50:53.420
QuickTime already supports,
you could actually have a more consistent

00:50:53.420 --> 00:51:00.120
user experience if you implemented
your file format as an exporter,

00:51:00.120 --> 00:51:03.670
and then you could leverage
all the QuickTime UI,

00:51:03.670 --> 00:51:08.670
make it a very seamless experience,
no matter whether people were exporting

00:51:08.730 --> 00:51:11.550
to your file format or to other
formats that QuickTime supported.

00:51:11.590 --> 00:51:13.010
It would all look very much the same.

00:51:13.020 --> 00:51:17.680
So you get some leverage
out of the UI by doing that.

00:51:17.710 --> 00:51:22.710
You may also want to just...
It's an interesting way to do

00:51:22.720 --> 00:51:24.580
some source-level debugging.

00:51:24.580 --> 00:51:29.640
You can just link it in directly with
your app and debug through it that way.

00:51:31.800 --> 00:51:33.860
Okay, debugging components.

00:51:33.860 --> 00:51:38.210
Source level debugging is available
in all major development environments.

00:51:38.300 --> 00:51:40.440
This didn't actually used to
be the case some years ago.

00:51:40.440 --> 00:51:43.390
It was kind of a pain to
actually debug components.

00:51:43.390 --> 00:51:52.290
But in Project Builder,
in Visual Studio.net, in Code Warrior,

00:51:52.290 --> 00:51:53.110
all these environments,
you can actually do

00:51:53.110 --> 00:51:53.110
source level debugging.

00:51:54.040 --> 00:51:58.790
Okay, if you're still doing some 9x work,
you have the thing, dcommand,

00:51:58.810 --> 00:52:01.360
for a max bug,
and this will actually show

00:52:01.470 --> 00:52:05.720
you a full printout of all the
components that are in your system,

00:52:05.720 --> 00:52:09.500
how many instances are open,
what their refcon values are,

00:52:09.500 --> 00:52:11.710
all sorts of interesting information.

00:52:11.710 --> 00:52:14.380
So it's pretty helpful on that platform.

00:52:15.400 --> 00:52:17.360
And there's some stuff
you can do on Windows.

00:52:17.360 --> 00:52:21.060
There's, you know, first of all,
one of the things you may want to do is

00:52:21.100 --> 00:52:25.120
make sure that your QuickTime resources
actually got into your component DLL,

00:52:25.120 --> 00:52:28.920
and you can use the Visual Studio editor
if you want to just open up and

00:52:28.920 --> 00:52:32.110
look and see if it got attached,
or you can use a tool called

00:52:32.220 --> 00:52:35.920
ResDet to see whether the
component was attached properly.

00:52:39.360 --> 00:52:49.280
Okay, as usual, debug string,
output debug string are your friends.

00:52:49.280 --> 00:52:49.280
You want to use them liberally.

00:52:49.900 --> 00:52:53.230
and you can find out whether your
routines are actually being called,

00:52:53.240 --> 00:52:55.460
in what order, that sort of thing.

00:52:55.460 --> 00:52:59.070
So they all work great.

00:53:00.620 --> 00:53:04.290
One quick thing I want to talk about is,
okay, now I've got a component,

00:53:04.290 --> 00:53:05.840
how do I get it to an end user?

00:53:08.140 --> 00:53:09.630
You can ship it yourself.

00:53:09.660 --> 00:53:11.750
So if you have,
as we were talking earlier,

00:53:11.750 --> 00:53:14.810
you've got an application,
and in the case certainly where if

00:53:14.810 --> 00:53:18.110
you don't want other people to use it,
you just ship it with your app,

00:53:18.150 --> 00:53:20.280
or even if you do want
other people to use it,

00:53:20.320 --> 00:53:21.880
you can ship it that way.

00:53:21.880 --> 00:53:25.010
Apple actually provides
another mechanism,

00:53:25.010 --> 00:53:28.780
which is the QuickTime Component
Download Program.

00:53:31.420 --> 00:53:34.680
This is very interesting if
you're doing an exporter,

00:53:34.770 --> 00:53:36.250
an importer, a codec.

00:53:36.330 --> 00:53:42.760
There are a number of third parties
today that have codecs that you can

00:53:42.920 --> 00:53:45.800
get in exporters through this program.

00:53:45.800 --> 00:53:48.560
So if you're doing
that type of component,

00:53:48.600 --> 00:53:51.930
I'd encourage you to
contact Apple about that.

00:53:54.590 --> 00:53:54.780
Okay.

00:53:54.860 --> 00:53:58.780
The rest of the time here I really want
to spend going through common problems

00:53:58.780 --> 00:54:01.340
that people have developing components.

00:54:02.300 --> 00:54:04.260
Okay, so this is common.

00:54:04.260 --> 00:54:08.660
My component compiles and links,
never shows up, it's never registered,

00:54:08.740 --> 00:54:10.270
my clients can't see it.

00:54:11.800 --> 00:54:16.340
Okay, so the first obvious thing to do
here is you want to make sure that

00:54:16.680 --> 00:54:19.470
your register routine isn't failing.

00:54:19.480 --> 00:54:23.580
In other words, that it's not returning
that it can't register.

00:54:23.580 --> 00:54:25.920
That's an obvious thing to check.

00:54:26.030 --> 00:54:30.160
If you're auto-registering,
make sure you put the component

00:54:30.160 --> 00:54:30.160
in the right directory.

00:54:31.880 --> 00:54:34.480
This is something we talked
about a little earlier.

00:54:34.480 --> 00:54:37.680
You want to make sure
that your DLLE resource on

00:54:37.680 --> 00:54:43.560
Mac OS X and Windows is defined,
and that it's actually lining up,

00:54:43.710 --> 00:54:45.460
that you have the same
names in both places.

00:54:45.460 --> 00:54:47.440
And then for Carbon,
you want to make sure that you

00:54:47.440 --> 00:54:48.860
have a code fragment resource.

00:54:48.860 --> 00:54:56.690
So if these are messed up at all,
chances are really good your component

00:54:56.690 --> 00:54:56.690
is not going to do anything for you.

00:54:57.330 --> 00:54:59.790
Okay,
and then this was the earlier statement

00:54:59.800 --> 00:55:03.540
about making sure you don't have
a mismatch in spelling or whatever

00:55:03.780 --> 00:55:07.980
between your dispatcher name and
the name you're actually exporting.

00:55:11.590 --> 00:55:15.030
okay, my custom components routine has
wacky values in its arguments

00:55:15.030 --> 00:55:19.790
and it sometimes crashes,
locks up, does other nonsocial

00:55:19.790 --> 00:55:22.610
or unsociable behavior.

00:55:22.710 --> 00:55:25.830
If you're doing your own API,
you want to make sure that you've

00:55:25.830 --> 00:55:28.710
actually declared all that stuff we
talked about a little earlier about

00:55:28.820 --> 00:55:33.030
making sure we had the return values
and the stack arguments -- I mean,

00:55:33.030 --> 00:55:36.660
the routine arguments all defined
correctly in terms of sizes.

00:55:36.660 --> 00:55:38.980
If you do that wrong,
this can be the kind of

00:55:38.980 --> 00:55:40.250
behavior that you see.

00:55:40.370 --> 00:55:44.030
So it might be the kind of a thing where
you said you needed two bytes for an

00:55:44.030 --> 00:55:46.260
argument and you actually need four.

00:55:46.260 --> 00:55:49.570
So you can get a stack misalignment.

00:55:52.700 --> 00:55:55.820
Okay, my component's register
routine never gets called.

00:55:55.820 --> 00:55:58.260
So the component looks
like it's coming up,

00:55:58.380 --> 00:56:00.570
and I can see it,
but the register routine

00:56:00.570 --> 00:56:01.840
never gets called.

00:56:01.840 --> 00:56:04.830
You want to make sure that that
component wants register message

00:56:04.830 --> 00:56:08.030
flag is set in the component entry,
platform entry of your

00:56:08.140 --> 00:56:09.630
component resource.

00:56:09.700 --> 00:56:15.050
And there's actually another
place where this can be set,

00:56:15.050 --> 00:56:19.190
and it's in the 68K flags field at the
beginning of the component resource.

00:56:19.190 --> 00:56:19.190
I

00:56:19.510 --> 00:56:22.690
Don't think there's too many people
doing 68k component development.

00:56:22.700 --> 00:56:26.230
So for all intents and purposes,
that's an obsolete field.

00:56:26.230 --> 00:56:28.590
So you need to make sure
that you not only define it,

00:56:28.590 --> 00:56:30.370
you need to put it in the right place.

00:56:34.300 --> 00:56:39.010
Okay, and then if you're actually doing
the thing we described earlier where

00:56:39.010 --> 00:56:43.200
you're calling register component
or register component resource,

00:56:43.330 --> 00:56:47.420
you'll actually need to manually
call your register routine.

00:56:48.810 --> 00:56:51.460
So if you're doing this from
within your application code

00:56:51.510 --> 00:56:55.210
to register your component,
it won't actually call register for you.

00:56:55.220 --> 00:56:56.340
You need to do that yourself.

00:56:56.340 --> 00:56:59.260
There is a call in the component
manager in components.h,

00:56:59.260 --> 00:57:02.090
call component register,
that you can use to do this.

00:57:05.980 --> 00:57:08.930
Okay,
my components routine never gets called.

00:57:09.030 --> 00:57:11.940
Not just register,
but nothing gets called.

00:57:11.940 --> 00:57:15.300
This is usually,
you want to make sure that you've

00:57:15.300 --> 00:57:20.230
accounted for and lined up your
selectors in your dispatch file.

00:57:20.230 --> 00:57:20.230
So,

00:57:20.760 --> 00:57:25.010
This can be an error in how
you've defined your range

00:57:25.010 --> 00:57:28.480
shift mask or your range mask.

00:57:28.550 --> 00:57:35.060
It could be an error in how you've
defined the values for your selectors.

00:57:35.060 --> 00:57:40.920
So you need to just basically go through
that and make sure what they should be.

00:57:40.940 --> 00:57:44.200
Go through that with a fine-tooth comb,
and that usually solves

00:57:44.200 --> 00:57:45.620
a lot of these problems.

00:57:45.620 --> 00:57:46.370
Topics include components versus
other shared code mechanisms,

00:57:46.370 --> 00:57:46.930
anatomy of a basic component,
the component dispatch helper,

00:57:46.930 --> 00:57:46.930
cross-platform considerations,
debugging techniques,

00:57:46.930 --> 00:57:46.930
and common pitfalls.

00:57:46.930 --> 00:57:46.930
Topics include components versus
other shared code mechanisms,

00:57:46.930 --> 00:57:46.930
anatomy of a basic component,
the component dispatch helper,

00:57:46.930 --> 00:57:46.930
cross-platform considerations,
debugging techniques,

00:57:46.930 --> 00:57:46.930
and common pitfalls.

00:57:48.120 --> 00:57:51.760
okay, my component opens another one
of my components and needs to

00:57:51.900 --> 00:57:53.070
share internal state with it.

00:57:53.140 --> 00:57:56.330
Okay, if you recall earlier,
we were talking about how you can't

00:57:56.330 --> 00:57:59.880
actually use component ref cons anymore
to do this kind of thing reliably,

00:57:59.880 --> 00:58:04.650
which is a way that some components
in the past on OS 9 used to do this.

00:58:04.700 --> 00:58:09.990
What you can do is,
with the material that

00:58:09.990 --> 00:58:12.150
we've gone over today,
we showed you how to write

00:58:12.150 --> 00:58:13.390
a new component type.

00:58:13.420 --> 00:58:20.970
That same mechanism can be used to
extend an existing component interface.

00:58:21.080 --> 00:58:26.720
Okay, so let's say I was writing
an image decompressor,

00:58:26.720 --> 00:58:32.280
and it was actually a hardware resource
that was running on a board that

00:58:32.280 --> 00:58:34.280
maybe also does video acquisition.

00:58:34.280 --> 00:58:38.400
I'm probably creating
an unusual example here.

00:58:38.400 --> 00:58:41.080
So you have two components
that are trying to share

00:58:41.080 --> 00:58:42.410
the same hardware resource.

00:58:42.420 --> 00:58:47.470
You'd actually like them to be able
to find out whether one or the other

00:58:47.480 --> 00:58:48.980
of them has control of the hardware.

00:58:48.980 --> 00:58:54.660
You could potentially do that by
extending either the image decompressor

00:58:54.660 --> 00:58:59.680
API with a private selector or the
VDig API with a private selector

00:58:59.680 --> 00:59:02.970
that can allow those two components
to communicate with each other.

00:59:04.530 --> 00:59:07.660
And you would use the same
techniques that you use for

00:59:07.660 --> 00:59:10.060
defining a new component type API.

00:59:14.710 --> 00:59:20.440
Okay, so speaking of hardware resources,
this one comes up a lot too.

00:59:20.450 --> 00:59:24.060
I need to connect to a hardware
resource for my component,

00:59:24.090 --> 00:59:29.140
and the hardware only supports a single
connection to the physical device.

00:59:29.140 --> 00:59:33.250
And to make matters worse,
I could maybe have multiple

00:59:33.580 --> 00:59:35.880
physical devices present.

00:59:35.880 --> 00:59:38.250
How should my component handle this?

00:59:38.390 --> 00:59:44.230
So I want a component to be the
wrapper around this hardware resource.

00:59:45.160 --> 00:59:46.540
That's a good one.

00:59:46.560 --> 00:59:49.970
This is a difficult problem to solve.

00:59:49.970 --> 00:59:54.260
And some approaches,
you could register your

00:59:54.260 --> 00:59:57.880
component once for each physical
device that's in the system.

00:59:57.880 --> 01:00:00.770
And you could say, okay,
for each of those components,

01:00:00.770 --> 01:00:02.860
I'm only going to allow one instance.

01:00:02.860 --> 01:00:05.320
Okay, there's some drawbacks to that.

01:00:05.380 --> 01:00:07.980
First of all,
it assumes that you can actually

01:00:07.980 --> 01:00:12.350
uniquely and persistently identify
these devices that are in the system.

01:00:12.350 --> 01:00:14.380
Maybe that's not always the case.

01:00:15.100 --> 01:00:18.350
And that it's possible that
you can track device connection

01:00:18.390 --> 01:00:20.080
status across address spaces.

01:00:23.210 --> 01:00:27.540
Okay, another approach you might use is,
I register my component once,

01:00:27.540 --> 01:00:31.880
allow multiple instances of the component
up to the number of devices that

01:00:31.880 --> 01:00:34.460
I actually have installed in the system.

01:00:36.710 --> 01:00:39.650
There are some of the
same qualifications here,

01:00:39.650 --> 01:00:43.070
and it makes it a little
more difficult to count the

01:00:43.140 --> 01:00:51.230
devices that are in the system,
because from the component manager level,

01:00:51.270 --> 01:00:54.640
what I would have to do is actually
keep opening the component to figure out

01:00:54.640 --> 01:00:54.640
how many of these devices were there.

01:00:56.700 --> 01:00:59.440
I could register the component once,
and then I just don't have

01:00:59.440 --> 01:01:00.550
any limitations at all.

01:01:01.450 --> 01:01:04.860
In other words,
I implement some type of elaborate

01:01:04.860 --> 01:01:09.060
mechanism to share a single hardware
connection amongst all these instances.

01:01:09.060 --> 01:01:13.790
The obvious thing that happens here
is the more instances they get open,

01:01:13.880 --> 01:01:16.600
my performance very likely
goes down because I'm having

01:01:16.600 --> 01:01:18.460
to manage between these things.

01:01:20.510 --> 01:01:24.430
There's not really a good answer here,
and a lot of this you actually want

01:01:24.430 --> 01:01:28.730
to push down to the driver level for
your hardware device so it can actually

01:01:28.770 --> 01:01:31.100
tell your component information.

01:01:31.100 --> 01:01:34.070
The general thing here is you
probably want to not try to do

01:01:34.210 --> 01:01:37.930
all of this sort of stuff in your
component because it's very difficult.

01:01:37.930 --> 01:01:40.830
You actually want to try to
push it to a lower level.

01:01:40.860 --> 01:01:46.980
Now that said, if any of you were in the
video-intensive application session,

01:01:46.980 --> 01:01:54.190
Sean Williams, he showed some stuff
with the IIDC cameras.

01:01:54.220 --> 01:01:59.420
Basically what was cool there is
there's a class of devices for which

01:01:59.420 --> 01:02:03.920
Apple's providing support where you
actually can have these devices with

01:02:03.970 --> 01:02:09.820
unique IDs on your FireWire bus,
and it can persist state

01:02:09.820 --> 01:02:11.920
between hot plug and unplug.

01:02:11.920 --> 01:02:15.840
There's a lot of progress being
made in this area to help people

01:02:15.840 --> 01:02:18.320
with this problem with components.

01:02:18.360 --> 01:02:20.130
So I don't know if there's
any other questions.

01:02:20.140 --> 01:02:22.360
I would encourage you to,
if you didn't get to see that session,

01:02:22.360 --> 01:02:25.500
then at least when the DVDs
of the conference come out,

01:02:25.500 --> 01:02:27.440
you may want to go look at that session.

01:02:27.440 --> 01:02:31.030
There was some very interesting
stuff talked about there.

01:02:33.130 --> 01:02:35.100
Okay, so as we noted,
there's not really a

01:02:35.100 --> 01:02:36.290
magic bullet on this one.

01:02:36.470 --> 01:02:44.070
You'll have to experiment to see
what actually works best for you,

01:02:44.070 --> 01:02:47.170
but again,
you probably want to push a lot

01:02:47.170 --> 01:02:47.170
of this connection management
stuff out of the component down

01:02:47.170 --> 01:02:47.170
to a lower level in your software.

01:02:48.220 --> 01:02:50.890
Okay,
just some closing advice to summarize

01:02:51.030 --> 01:02:53.150
some of the things from the session.

01:02:53.150 --> 01:02:56.880
You don't want to allow multiple
instances of your component if

01:02:56.950 --> 01:02:59.100
you can't actually support it.

01:02:59.100 --> 01:03:03.550
You need to make sure you clean up
properly when your component's closed.

01:03:05.760 --> 01:03:09.910
I encourage you to use Gestalt
to find out if the services you

01:03:09.910 --> 01:03:14.510
need are actually there before
your component is registered,

01:03:14.510 --> 01:03:17.210
before you allow clients to use it.

01:03:19.450 --> 01:03:23.160
Use the component dispatch helper.

01:03:23.160 --> 01:03:26.270
Having done this for
many years for both ways,

01:03:26.270 --> 01:03:28.290
this is hugely useful.

01:03:28.530 --> 01:03:31.450
And like I say,
if you need to convince yourself,

01:03:31.450 --> 01:03:35.760
take the sample code that's available
and preprocess the C file and look

01:03:35.860 --> 01:03:38.260
at what the dispatcher does for you.

01:03:38.420 --> 01:03:41.090
It does a lot of work for you.

01:03:42.660 --> 01:03:46.080
Don't forget that the component
manager has platform differences if

01:03:46.080 --> 01:03:49.400
you're actually trying to develop
for systems beyond Mac OS X.

01:03:52.010 --> 01:03:55.380
Okay, before you actually go through the
exercise of writing your own API,

01:03:55.380 --> 01:04:01.170
we saw that it's fairly involved to do,
you should probably go through

01:04:01.170 --> 01:04:02.780
the QuickTime APIs first.

01:04:02.870 --> 01:04:08.320
It has a lot of different APIs,
and perhaps you can get by with,

01:04:08.430 --> 01:04:14.680
if you can get by with using them,
the ones that are there, that's great,

01:04:14.680 --> 01:04:15.610
or maybe you can actually use one that's
close and extend it to get what you need.

01:04:17.180 --> 01:04:19.730
Okay,
there's a QuickTime API mailing list.

01:04:19.730 --> 01:04:24.080
I encourage everyone to subscribe to
that if you're doing component work.

01:04:24.190 --> 01:04:27.150
There's a lot of developers there that
have a lot of helpful hints and tips.

01:04:29.100 --> 01:04:32.500
And this is the roadmap for today.

01:04:32.500 --> 01:04:37.980
And one thing I want to get to is,
let's see, so we have MPEG-4 today.

01:04:39.540 --> 01:04:45.800
The sample code for this
session is at that URL.

01:04:45.840 --> 01:04:55.560
There's actually both Mac and
Windows files there for you to download.

01:04:55.560 --> 01:05:00.630
It illustrates everything we
talked about in the session today.

01:05:00.630 --> 01:05:03.620
So you can go get that and try it out.

01:05:03.650 --> 01:05:09.360
Please feel free to contact
me at garywoodcock.com.

01:05:09.400 --> 01:05:14.510
After this session, we can talk outside,
or you can also email me.

01:05:14.510 --> 01:05:17.820
That's our session for today,
and I'd like to thank

01:05:17.820 --> 01:05:19.430
everybody very much for coming.
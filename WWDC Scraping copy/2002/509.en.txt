---
Title:  ColorSync & Digital Media
Year:   2002
Web:    https://nonstrict.eu/wwdcindex/wwdc2002/509/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Good afternoon everyone. I'm Travis Brown. I'm the graphics and imaging evangelist here at Apple. I want to welcome you to session 509, which is ColorSync & Digital Media. Before we jump into session content, I want to just sort of take a moment to sort of reiterate the fact that Apple feels that color is incredibly important to our developers and our users. This is because we really see color as a platform advantage on the Macintosh.

Color management really has some of its genesis in the work that was done at Apple with the original ColorSync. We've also extended that to include many major companies in the founding of the International Color Consortium. So color management is alive and well at Apple. It's something we believe is critically important.

We want to have the experience as seamless as possible. For example, last year we spoke a lot about how we've integrated ColorSync in conjunction with Quartz 2D, which is Mac OS X's new drawing API. This integration allows users to get what they expect. The fact that if they see color on the screen, they can see it.

They can print it, which is something sort of striven for by all the color scientists and color management experts out there. But it's something that's a really difficult problem to solve. And now that we've done that degree of integration and that kind of capabilities are available in the operating system, we've started to look at other opportunities for ColorSync.

And that's one of the sort of features of the session. We're going to be talking about not only ColorSync with regards to what's going on with ColorSync, some fine point details on ColorSync and how it's integrated in the operating system, but also we're going to be showing off doing things with video. And color management.

Doing things with video and color management in real time, which those really didn't all go together. And we're going to show in terms of they're sort of mutually exclusive concepts. And that's what we're going to show here today. So what I want to do is invite David Hayward, ColorSync engineer to the stage to take you through the session.

Thank you, Travis. Well, welcome all today to the ColorSync & Digital Media session. We have a lot to talk about today. Again, we'll be talking especially about digital media at the end of the session, but there's several other things I'd like to talk about as well. First of all, I want to start the presentation with a general overview of ColorSync and color management in general for those of you who may be new to the concept. Following that, I want to go to describe a more elaborate example of the chain of operations that can occur on an image on Mac OS X now that it's fully integrated into the system and how to avoid some common pitfalls.

After that, I'll be giving an update on ColorSync and Jaguar and what changes we've made for the upcoming release. Following that, Luke will be coming up on stage and talking about ColorSync and the Quartz. And then lastly, I'll be talking about the exciting stuff of ColorSync and live action video.

So first of all, an overview of ColorSync for those of you who are new. Today we're all blessed with the problem of having a wide variety of color devices that we all work with day in and day out. These, you know, all sorts of devices, digital cameras, digital scanners, LCD displays, tube displays, inkjet printers, presses, all of these devices work with colors in very, very different ways.

Different color spaces and all of them have a different gamut or range of colors that they can represent. The problem that this creates is that it's very difficult for a document that's created on one device to look correct when outputted on other devices, which is something we try to do more and more today as we repurpose content.

So the solution to this problem is ColorSync, which provides a complete color management system in order to correct color across these wide and disparate devices. That said, ColorSync can also be used, in addition to doing device color management, can also be used to do color special effects. And that's something I'll be showing a little bit later when it comes to talking about digital video.

So ColorSync, in order to provide this solution for a wide variety of devices, is a very open system and extendable. And it achieves this extensibility and openness by basing itself on two open foundations. The first is the ICC profile format, and the second are color management modules, or CMMs. I'm going to talk a little bit about each of these for those of you who might be new.

ICC Profiles. What is an ICC Profile? An ICC Profile is a cross-platform file format which is defined by the International Color Consortium. You can go to their website at www.color.org and you can get all the detailed information about the file format there, the current and past versions of the specification. To summarize briefly what the file format is, it's a document that contains data and tables that transform color between an individual device's unique color space into an intermediate interchange space based on the common way that humans perceive color.

In general, profiles fall into one of several classes. You can have typical classes such as input for scanner and camera, display and output classes, but there's also a couple other classes that are lesser known, such as abstract classes and name profile classes. Again, this ICT profile format is designed to be very broad and flexible. In addition to being able to represent a wide range of devices, it can also represent standard spaces such as NTSC, PAL, you name it.

So the other foundation that ColorSync rests upon that allows for it to be open and extendable are color management modules, or CMMs. And the CMMs provide the mathematical engine that does all the color transformation based on the data that's found inside profiles. Now, Apple provides the default CMM on Mac OS X.

It's very similar to the CMM that we've shipped in past releases all the way back to Mac OS 9. But it's also possible for third parties to provide their own CMMs if needed. In general, this is not that often needed, but if you have custom solutions that you want to provide to a specific market, then it's possible to add a third-party CMM into ColorSync, and it'll be used everywhere in the system.

So now that we've talked about those basic ingredients, I want to give a very simplified model of how ColorSync works in practice. At the top we have an application, which some of you may be writing, and it will use ColorSync. And it can use ColorSync either directly or indirectly through other APIs that are provided on the Mac OS. But the basic premise is very simple. The idea is you want to get an image, a source image, from a file. And ideally that file will be tagged with a profile that represents the device from which that document originated.

As long as that profile is tagged with a profile, or as long as that image is tagged with a profile, then we now know the colorimetry and the color behavior of the device from which that came. This allows us to now display that image correctly on the user's display.

We do this by determining the profile for the display and then setting up a ColorSync transformation between the source profile, the camera's profile in this example, and the user's display profile. The idea behind this is that now when the image is displayed on the screen, it will be a faithful reproduction, or as faithful as possible, to the original content, original scene.

A similar process occurs when printing. In a simplified description, when it comes time to print, the original document with its embedded profile is sent to the printer where we can determine what the printer profile is. And again, the end result is that when printed, the document will, as faithfully as possible, reproduce the original scene.

This next slide provides a diagram of how ColorSync fits into the overall Mac OS X architecture. And now more than ever, it's well integrated into the Mac OS X. As you see at the top, as you may be familiar from other presentations, we have Carbon and Cocoa applications, both of which can call ColorSync.

You can get a lot of functionality directly out of Cocoa or by calling Quartz, or if you want, your application can still call ColorSync directly if you wish, if you want to provide very specific functionality to your users. In either case, no matter how ColorSync is called, ColorSync is built up on top of the Darwin Foundation that's part of Mac OS X, and CMMs are loaded dynamically as needed. Thank you.

So to finish up the summary of the overview of ColorSync, I just want to give a brief description of the key components that make up ColorSync on Mac OS X. First of all, there's a couple pieces that provide user interface to users. First is the ColorSync preference panel, which provides basic preferences for novice users. Secondarily is the ColorSync utility application, which provides more advanced functionality. Then we have the ColorSync API, or the ColorSync framework. On Mac OS X, this is provided as part of the application services framework. ColorSync is made up of about 120 APIs.

In general, these APIs fall into a couple broad categories. First category are a set of APIs that are used for doing basic profile access. These APIs allow you to read profiles, write profiles, create new profiles, etc. Next, there are a set of API that allow you to search for profiles or iterate over all the profiles that are installed on the user's system.

The third category of API are what we refer to as device integration API. These were introduced first in Mac OS X-1 and these provide very advanced functionality so that device drivers such as image capture, display manager and printing can register devices with ColorSync and most importantly register the profiles for these devices. It is also possible using this API for calibrators to change the profiles for each device from the factory profile that is created for it automatically.

Lastly, there is a set of API for dealing with what we call color worlds. A color world is ColorSync's opaque object that represents a concatenation of one or more profiles. Once you've opened profiles, you can create a color world, and once you have a color world, you can match pixels. and then again, as I mentioned before, the other key pieces of ColorSync are CMMs and profiles.

So now that we have a basic understanding of ColorSync and color management, I want to go into a more elaborate example. And you could argue that this is a bit of an extreme example, but to a certain extent it shows how well ColorSync is integrated into the system, because for a given document, it can have a long life and be affected by multiple parts of the system, all of which may support ColorSync. So let me go into a brief description of a somewhat extreme example.

First of all, let's say a document begins its life after it is acquired by the image capture architecture and a profile is associated with that document. After that, it may be edited by a Carbon application, which hopefully will preserve the contents of that profile. Later on, it might be converted by a drag-and-drop utility, which is based on QuickTime graphics importers. Later on, that document could be opened in preview, where it will be displayed correctly on the screen.

But when it comes time to print, then another series of actions occur. The document will be rastered by courts, sent through to the printer driver, and hopefully, if all goes well, it ends up on the output of your printer. So this is a long sequence of operations, and it illustrates just how well integrated ColorSync is into our system, because ColorSync can have a place to operate at each one of these stages. However, like any good chain, there is opportunity for weak links in those chains. So I want to describe. a couple problems that are common and are easy to avoid.

So for one thing, when an image is acquired by image capture, it is often the case that a camera will not register a profile. Part of the reason for this is that it can be difficult to create a general profile for a camera because cameras are designed to work in a wide variety of lighting conditions.

But that said, even so, it's possible to create general profiles, and if a camera is being used in a specific environment, it's possible to create a good profile for that. Obviously, if you don't have a profile for a camera, then other stages later on in the chain will have to make assumptions based on user preferences for how to handle untagged data.

Later on, when a document is edited by a Carbon application or converted by a QuickTime tool, it's important that apps must check for embedded profiles and preserve that when the document is rewritten to disk. I'll describe an easy solution to this problem in the subsequent slide. Also, when it comes time to print, the data will be rastered by quartz and converted to the printer's color space. But again, some printers don't register profiles, and there's some consequences to that that you should be made aware of, especially if you're a printer driver manufacturer.

So let me go into one set of code examples for how you can avoid one of these common weak links. As an example, what I have is a hypothetical application, a drag-and-drop application, for example, that converts a file format from whatever format it currently is to TIFF. And it does this by leveraging the graphics importer-exporter functionality that's part of QuickTime, which is a very convenient set of API that handles all this for you.

So what I have is a basic function, which is called convertToTIFF, it takes an input file and will put the result into an output file. And the way it works is by first getting the graphics importer for the supplied file. After that, it creates a destination graphics exporter component by just looking for the hard-coded TIFF component.

Obviously, you could be more elaborate and allow the user to choose a destination file format, but for this example, I just hard-coded TIFF. Once we have the importer and exporter component, we want to connect the two of these together. We do that with the next two calls, which basically tell the exporter to pull data from the importer and output it to the file.

It's very handy. So on this next page, we have the code that's actually critical in order to preserve ColorSync profile information. And it's actually not a lot of work. Once you do that, however, you'll have a utility that works well in the ColorSync chain of operations. All I'm doing here is calling the import, graphics importer, asking it for the embedded profile, and then taking that embedded profile and telling the exporter that this is the profile to use for the exporter. If you don't do this, the profile will be lost. Once you've made these two short calls, all you have to do is call graphics export or do export, clean up, and everything's done.

One of the other weak links in the chain that's important to be aware of is the conversion that occurs with ColorSync when printing occurs. It's important to remember that Quartz matches all color data, whether it's tagged with a profile or not, to the printer's registered color space. The reason behind this objective is so that all the data is sent to the printer in a common color space, which actually can make it more convenient for printer drivers.

However, if your printer driver does not register a profile, then Quartz will match all the data to an assumed profile, which is currently the display profile. Again, this achieves the objective of having all data sent to the profile in a common space, but one of the caveats is that that color space will be different from one machine to another because one machine will have a different display profile from another. So this is something to be aware of if you're writing printer drivers.

After the printer driver receives the matched data, several printer drivers will do additional color management. They're free to do so, and that may make a lot of sense. Again, it's further justification for a printer driver to register a profile, because the way most printer drivers do additional color management is to have known tables that convert from an input color space to their ink-specific color spaces. And having a known colorimetry as the input is critical in order to achieve this effectively.

So the next subject I'd like to talk about today is an update of ColorSync for Jaguar and what we've changed in the upcoming system. We've made changes in a couple broad areas. We've made changes to the profiles we ship, some minor changes to the framework, and the preference pane in the utility. I'll talk about each of these in a little bit more detail.

So we've updated some of the profiles that we ship by default with Mac OS X. And these are important default profiles which are often used by users for data that doesn't have, or for images that don't have profiles embedded in them. So it's important to be aware of these changes.

For one thing, the generic RGB profile will be changing slightly. In the past, the generic RGB profile was based on the venerable Apple Color 13-inch display. And so it was roughly based on P22 phosphor set with a 9300 degree white point and a 1.8 gamma. And what we're trying to do is to make minor changes to that to make it more standard. For one, we're changing the phosphors to be exactly P22.

We're changing the white point to be D65, which actually is a closer match to most other profiles. And we're changing the white points to be LCD display white points. And it also avoids the overly blue cast of tube displays. The gamma is being left at 1.8 since this is a long tradition for the Mac.

The generic CMYK profile has also changed. The generic CMYK profile was originally based on the Apple Color LaserWriter printer. Since that's no longer available, there's not too much reason keeping the generic CMYK profile based on it. Instead, we're basing the generic CMYK profile on the standard swap color space. It's a subsampled version of the TR-001 swap profile, which provides nice, smooth CMYK results with a profile that's relatively small in size.

We've made lots of minor changes to the ColorSync framework. In particular, one area that we've made some changes in are in notifications that are sent out by the framework. Some of these were existing notifications, but I'd like to talk about them today while we're on the subject of notifications.

In general, on Mac OS X, it's a good idea for applications not to periodically call frameworks to see if something changed. When a phone rings, it's best to wait for it to ring to pick it up rather than to periodically lift up the handset to see if anyone's on the other line, which is what a lot of applications do today when it comes to checking for profiles.

So there are several notifications that are sent out. Several of these notifications are sent out whenever the device drivers notice a change in state of ColorSync devices. For example, when you plug in an external display to a portable, the display manager will automatically kick in, recognize the display, query its EDID information, create a profile, and call ColorSync to say that a new device with this profile has been recognized. This is a really powerful functionality and it allows us to get great plug-and-play color. And your application might want to be aware that this has occurred.

In order to do this, you can listen for notifications for either when a device is recognized, when it is removed, or when the profile for that device changes. The notification that we've added most recently is a notification that is sent whenever the user changes a setting in the ColorSync prefs pane. The user changes, for example, the preferred CMM, a notification is now sent to anyone who cares to listen.

To give an example of this in action, here's a brief code snippet that shows a common operation that people want to do. A lot of applications are matching data to the screen and they need to know the profile for the main display. Again, what a lot of applications have done in the past is to periodically check to see if this profile has changed. Instead, you can install a notification handler.

This code sample is written in Cocoa. There's similar code that you could write that's based on Core Foundation, which has the same premise and the same notifications. In the first function, all we're doing, we call this early on in the program, and the key thing here is to call the NSDistributedNotificationCenter to get its default center. This is the center to which all global messages are sent to all applications. Once we have that object, we can tell that object that we want to listen for a certain notification. In this example, we're listening for notifications whenever a device is added, removed, or changed.

In any of these cases, what we want to have happen is we want to have our function call, our selector called notification at the bottom of the screen. This will be called whenever these changes occur. And in this very trivial example, all that occurs is we call CMGetDefaultProfileByUseDisplay to update our global profile.

Another area that we've made changes in in ColorSync is in the ColorSync preference pane, which is probably the first thing people see about ColorSync. For one thing, we've removed the Devices tab. The Devices tab in the ColorSync Prefs pane is, was a legacy tab from our first attempt in ColorSync to add support for devices. Since then, we've added the full device integration layer, which allows for much more flexibility. And for this reason, the old API is supported only for backward compatibility.

For this reason, the devices tab in the preferences pane has also been removed. Instead, that user functionality can be found either in specific device UI, for example, in the monitors preference, or in the ColorSync utility for the one-stop shopping location. The other thing we've removed from ColorSync's press pane is the ability to import and export workflows. We found in actual practice few people were making use of this functionality, and to a certain extent its capabilities were not as needed now on Mac OS X since we have a multi-user operating system with multiple preferences.

While on the subject of the preference pane, I'll mention to those of you who may not be aware, but with all the pop-ups that show profiles in the preference pane, we have tooltips. And those tooltips show you the full path to the profile so that you can see what the file name of the profile is.

The other user interface component that we've made changes in for Jaguar is ColorSync Utility. One area of ColorSync Utility that we always update with every release is Profile First Aid. Profile First Aid provides basic functionality to diagnose and repair common problems that are found in many profiles. It's always a good idea if your application or printer driver ships profiles to check them with Profile First Aid. Also, if you've come across profiles that have problems that are not detected by Profile First Aid, let us know and we can try to add it to the next release.

Also, as I mentioned before, since the ColorSync Devices tab is removed from the preference pane, it's now more important than ever to be aware of the ColorSync Devices browser that's part of ColorSync Utility. Again, this provides one-stop shopping so the user can see all the ColorSync devices that are installed in the system, what their current profiles are, what their factory profiles are.

And lastly, the feature that's been long awaiting in ColorSync utility is the ability to inspect profiles. This is something we've had often requested. So instead of talking about it, I'll show it in action. So the long awaited profile inspector. Again, ColorSync utility looks much the same as before. We have profile first aid.

We have the profiles tab, which shows all the profiles that are installed in the system. And then we have the devices tab. What we can do now, however, that we couldn't do before, is we can go on to a profile, such as generic CMYK, and now we can actually see a 3D plot of the profile. So we can see this.

And what's particularly interesting is it provides an easy way, like if you're going seeing an RGB profile, we can flip between one RGB profile and another RGB profile and see the differences between them. One thing that's sort of interesting to note is the gamut on these two are very close, but you'll notice that the grid lines change. And what that's showing is the different in the linearity of the two devices.

But there's actually much more to this. If I go and open this profile and double click on it, we now bring up a new window. So here's the new functionality. What we see here is the basic description of the header of the profile, and then we can look at each of the tags. For example, the description tag shows the ASCII name, Unicode name, and the Mac name. We can go and edit some of these tags if we wish to. See the copyright information, white point. What else do we have here?

Here's a viewer for the A to B tag. We have a description of what the tag means in human readable form. So this tag is an intent zero, 8-bit, device to PCS conversion table. Bit of a mouthful. And here's it represented in 3D, but if you want to see the actual content, you can flip through the tabs. These tabs are the order in which they're applied.

There's the matrix, the input LUTs, which in this case are all linear. We have a set of table values, so we can see the different table values for different... while holding output of the L channel, for example, or the A channel for different values of C and Y or K.

It's always a trick to be able to represent this information in an easy fashion since it's multidimensional. And then the output curves. Again, this is a simple profile, so it doesn't have any curves here. And then lastly, we can see it in 3D. And we can zoom in, zoom out.

What else do we have? This is a little interesting. This is showing the gamut tag of a profile. Gamut tags of a profile are sampled at multiple points, so the data looks sort of like the A to B tag, but because they're sampled, it has some granularity to it. The last tag in this profile is the multi-localized description tag. This shows you the name of the generic CMYK profile and all the languages that Mac OS X is localized for. And you can even go in here and change them or edit them if you wish.

So for the most part, the profile inspector is just a viewer. There are a few tags that you can edit, such as the name and most of the text tags you can edit. So, a long-awaited feature. We'll add more to it in the future, but finally got around to it.

So with that, I will hand the microphone over to Luke, who will be talking for a bit about ColorSync and Quartz. Thank you, David. If you attended the last year's ColorSync session, you already heard from us that ColorSync is integrated into Mac OS X. As it was mentioned on several occasions, it means that ColorSync also provides services to other system components.

This is especially important for Quartz, which is the Mac OS X graphics system based on the PDF imaging model. And for the benefit of those who did not have a chance to be here last year, I would like to present one more time an overview of how Quartz solves the problem of color management by working together with ColorSync. Also, I would like to show you how some of the ColorSync functionality is accessible through Quartz.

Our objective was to integrate graphics and color management by meeting some basic requirements. First of all, Quartz needs the ability to composite different color spaces and opacity. To meet this requirement, ColorSync is used to convert data from different color spaces into one space selected by Quartz as a working space for compositing.

This also has to be a scalable solution which could serve the needs of a wide variety of applications. On one end, the involvement of an application in color management can be very minimal and limited just to the use of some predefined settings provided by Quartz. On the other end, an application may need the same full control over color management as it does when accessing ColorSync directly. The other requirements were color accuracy, performance, and compatibility with PDF.

In simple terms, Quartz color management is built around ColorSync, which is used as an engine to process color data needed by Quartz. To better understand this design, let's review some basic concepts pertaining to color in PDF and ColorSync and compare them with those used in Quartz. In PDF, color is defined by one of the known color spaces: device, calibrated, or ICC based.

As many of you know, this list reflects the progress of color management over the years. Initially, only device color spaces were known. And from today's perspective, we know that these merely recognize three different process color models. And because color appearance is device dependent, they are the worst choice for faithful color reproduction across different devices. Next, calibrated color was invented, along with the idea of color conversions through device-independent spaces. The advantage of calibrated color was a significant improvement in color reproduction over device color spaces.

Later on, calibrated color evolved into ICC profiles. which now are the de facto standard for color characterization among color professionals and can be embedded in almost all known color data formats. In PDF, ICC profiles can be embedded by the use of ICC-based color space. Color conversions in PDF can be defined as a function of the source color space, destination color space, and rendering intent.

Similar concepts exist in ColorSync and ICC. Color is defined by an ICC profile, which as we know is the most general form of color space description. Color conversions are also similar to those in PDF, with an option for adding intermediate profiles between the source and destination. These additional profiles can be used for a variety of reasons, such as soft proofing, color device simulation, color correction, gamut compression, special effects, and so forth.

The color model in Quartz is based on a combination of the PDF and ICC models. The most important point about this model is that all color spaces are expressed internally as ICC profiles and any color space is composed of one or more profiles. This way we can preserve the PDF concept of a simple match from source to destination but at the same time we are able to create multi-stage color transformations needed by advanced color management. And if a need arises to embed such a color space in PDF, a sequence of profiles can be concatenated by ColorSync into a single profile.

In Quartz, device color spaces are assigned default profiles, and PDF calibrated spaces are simply repackaged into ICC profiles by using their calibration record. Quartz also provides special color spaces for drawing directly to the screen. DisplayRGB is a color space based on the ColorSync system profile. And DisplayGray is a color space composed of a device link profile converting gray to RGB, followed by the system profile.

Another kind are user default color spaces, which can be very useful if an application wants to give the user a choice of a profile to be used as a default for a specific process color model. These color spaces point directly to the ColorSync default profiles for documents, which can be selected by the user in the ColorSync control panel.

Another simple but important concept that Quartz inherited from PDF is color space equivalence. An implied rule is that color conversions are required only if the source color space is different from the destination. Quartz is using this rule for properly organize the flow of the color data through multiple stages of rendering. It may be important to know that also the evaluation of color space equivalence is performed by ColorSync.

Now, let's see how all the ideas that we discussed come together in the Quartz drawing model. There are three main components involved in this model: an application generating the graphics content, Quartz providing rendering services, and the destination for the rasterized data. In terms of color management, the application can request cords to render content in any of the color spaces.

In the first step, Quartz will verify the source and destination color spaces and change them into ICC profiles if needed. Then, if required, ColorSync will convert data from any of the source color spaces to the working space. And finally, when compositing is completed, the rasterized data can be sent to desired destination.

Now, let me show you how convenient Quartz color management can be for some more advanced color operations. For example, applying special effects can be very easily achieved simply by adding an abstract profile to the working space. Another example could be soft proofing. The only thing we need to do is to add the printer profile to the working space. And this way all color adjustments defining the printer profile can be shown on the display.

So far, we have talked about the main flow of the color data from the source to the destination when the content is rasterized. But there is one more option possible here. The content can be spooled into PDF without rasterizing. to be handed to the printing component of the OS, for example. But there is important detail about this data. All colors will be tagged in this full PDF, and the profiles will be assigned exactly the same way as they were for asterization.

So this concludes my talk about ColorSync and Chords. So I'd like to thank you for your attention and I'll pass the microphone back to David. All right. Thank you very much, Luke. So the last section I want to talk about today is color sync and video. Most of what we talked about so far is traditional color sync color management.

And as I outlined earlier, the premise behind this is to convert between source devices and destination devices. However, oftentimes with video applications, there's a different workflow that's used. More traditional video color correction involved turning knobs, whether they be software or hardware, in order to achieve desired visual effects.

Both of these models are valid and useful. In actuality, an ideal system would involve both of these capabilities. So what we're proposing here is a system that combines these two models together into one color sync workflow. And this workflow uses, first, an assigned source or embedded profile in order to abstract out any differences between one source video and another source video.

Then the application of one or more abstractions in order to achieve visual effects. And then finally, the application of a destination profile so that that can be targeted for output. There are several advantages of this model. For one thing, abstract profiles can operate in a perceptually uniform LAB space based on human perception rather than based on the peculiar behavior of a specific device. Abstract profiles can also be archived as a standard ICC profile for further use.

What is also particularly useful is that the destination can be changed later. The manipulations that are made are not dependent on any source or destination profile. This allows the destination to be changed so that if your content needs to be retargeted either for the web or for a DVD or for film, you can apply a destination profile at the end that's applicable to that specific device.

So one question that's commonly asked when we propose using ColorSync on video is, well, does it perform fast enough? And actually, today, using software-only solutions and ColorSync, you actually can achieve adequate performance for basic preview of video or certainly adequate performance of non-real-time offline processing. And you can get very nice results. Using OpenGL hardware, we can actually leverage hardware on the video card, which would otherwise be unused, in order to actually achieve what we're calling ColorSync in real time.

The idea behind using real-time ColorSync is to make use of the per-pixel 3D texture map that's available on some modern video cards, such as the GeForce Ti card, and there's other cards coming out that also support this capability. And it actually makes a great case study for how well ColorSync is integrated into the Mac OS X system, because in order to achieve this goal, we need to bring a lot of technologies together at the same time. We need to integrate ColorSync, OpenGL, QuickTime, Quartz, in the following matter.

Here's a basic summary for how it works. First of all, what we want to do is play QuickTime content onto a Quartz OpenGL surface, and what we want to do is attach to that surface a 3D texture map that's filled with data that's generated from a ColorSync color world.

Probably the best thing to do at this point is to describe this in action, so I'll switch over and do a quick demonstration. Okay. So what I have here is a little application I've been working on. And what it does is it allows you to open up either still images or movies. And right now it's just showing black. I want to go over the control panel first. What we see over here is a floating palette that describes the color world or transformation that we're going to apply in real time on this video.

First of all, we have the source profile. Following that, we have an abstract profile, which is currently set to none. We can add a proofer profile to simulate what it would look like on a press. If anyone could figure out how to print a movie onto a press, maybe that would be useful.

Finally, we can specify a destination profile, which hopefully would be the screen in this case, but may also be another standard color space if you're outputting it to disk. So let me see if I can give a brief example. Let me start playing this movie a bit here. So. But what we have is a movie here.

Let's see, I'll play it through. And what I can do is at this point, I can, let's say, just change the source profile. And it's kind of hard to see right now because I have a wipe here that's showing the before and after. The before is on the left side and the after is on the right side.

I can also change it vertically. Another way I can view this movie is if I hit the tab key, I can show the before and after side by side. So let's do that for now. So as you can see, if I change different profiles, you can get some subtle differences. But where things really get exciting is when we turn on the abstract profile.

Now instead of pulling an abstract profile from disk, what I'm actually doing here is creating an abstract profile on the fly based on the slider values. So what I can do here is change these slider values and it'll adjust the hue. So for example, let me advance the movie a bit here.

And so we got this screen here. And let's say we want to change the color of the screen from blue to purple. So all we have to do is change the hue knob. And now what we're doing, and you can see I'm doing this real time here, we can create a profile for every time the slider value changes. I'm creating a new abstract profile and sending that resulting color world to the OpenGL surface so that then all subsequent pixels are mapped according to that concatenated color.

So now we have a nice result here, which is we've got a nice purple screen. Let me play the movie a little bit further. And we'll see that there's a problem that the shirt and the person's face is all, everything's distorted. So let's do something a little bit more fancy here, which is instead of applying the hue change to the entire image, what I'm going to do is limit the range of colors that it's affected to be just between in the blue range.

So now I can go back and play the movie. And the guy's shirt looks fine, but when we go back to seeing the screen, it's purple. And you can see it's doing this all real time on the fly. In fact, even if I can change saturation, change it from extremely saturated to black and white, I can change the hue all real time. So that's it.

So, with that, I have a few final slides. For one thing, places to go for more information on ColorSync to get more technical details. For one thing, for end user information, you can go to www.apple.com slash ColorSync to get all the marketing information on ColorSync. For developer SDK, you can go to the developer SDK's URL. Also, a good place to go for information and to ask questions is to the two ColorSync email lists.

There's a list for developers, ColorSync dev, and a list for users called ColorSync users. And, of course, if you have any comments or feedback you'd like to provide to us, feel free to send an email to ColorSync at Apple.com. Also, there's documentation, both a reference and an introduction to color management, and there's some tech notes that you might want to read as well.

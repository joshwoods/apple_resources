WEBVTT

00:00:11.750 --> 00:00:16.660
The official title of this is Delivering
Content via Interactive QuickTime.

00:00:16.660 --> 00:00:18.400
To be quite honest,
I don't know what that means.

00:00:18.440 --> 00:00:23.690
What we're going to focus on here is
programming QuickTime interactivity.

00:00:23.700 --> 00:00:29.310
So I'm assuming that a large part of my
audience here are software developers,

00:00:29.310 --> 00:00:34.320
and ideally you will have written
a QuickTime-savvy application.

00:00:34.430 --> 00:00:39.080
What I want to do today is talk about
some things you might need to do

00:00:39.120 --> 00:00:41.680
to make your application interact.

00:00:41.700 --> 00:00:43.500
active savvy.

00:00:44.360 --> 00:00:47.930
My name is Tim Monroe and I'm
with QuickTime Engineering.

00:00:47.930 --> 00:00:49.980
So I want to talk about
three things today.

00:00:50.040 --> 00:00:53.540
One, how to create some of those
cool movies that Eric showed

00:00:53.540 --> 00:00:54.920
us in the previous session.

00:00:54.920 --> 00:00:57.870
Second,
I want to look a little bit at how

00:00:57.950 --> 00:01:02.720
to use QuickTime API to do some
additional sorts of things that you

00:01:02.720 --> 00:01:05.440
can't do just in the movie itself.

00:01:05.440 --> 00:01:08.330
And the third thing I want to do,
as I said,

00:01:08.470 --> 00:01:12.370
is to focus on some things that
you could do to your application

00:01:12.370 --> 00:01:14.900
to make them interactive,
savvy.

00:01:14.950 --> 00:01:18.130
I'm going to do these
actually in the reverse order.

00:01:18.320 --> 00:01:21.160
I'm going to start off by
looking at a little bit review

00:01:21.160 --> 00:01:23.580
about what interactivity is.

00:01:23.580 --> 00:01:26.700
By now,
especially after Eric and Ben's session,

00:01:26.700 --> 00:01:30.130
you should have a pretty
good idea of what it is that

00:01:30.310 --> 00:01:32.620
characterizes interactivity.

00:01:32.620 --> 00:01:36.790
Just to review a little bit,
objects in the movie can

00:01:36.870 --> 00:01:39.010
respond to events from the user.

00:01:39.010 --> 00:01:42.150
Typically those are mouse
and keyboard events.

00:01:42.150 --> 00:01:47.650
We can have different types of
media interacting with one another.

00:01:47.900 --> 00:01:51.060
Objects in the media can be
scripted or have intelligent

00:01:51.200 --> 00:01:55.300
behaviors assigned to them,
and these objects can communicate

00:01:55.410 --> 00:02:00.400
with one another in the same
movie or even between movies.

00:02:02.060 --> 00:02:03.520
Again, this should be review.

00:02:03.640 --> 00:02:08.960
We have two intrinsically
interactive media types in QuickTime,

00:02:08.980 --> 00:02:12.680
namely QuickTime VR and Flash.

00:02:12.960 --> 00:02:16.950
In addition,
there are sprite tracks and text

00:02:17.030 --> 00:02:22.840
tracks can be scripted or wired
as we saw in the previous session.

00:02:22.890 --> 00:02:26.820
And finally,
we can use QuickTime functions to

00:02:26.820 --> 00:02:32.800
add interactive dynamic behaviors
to non-interactive tracks.

00:02:34.430 --> 00:02:37.670
So let's start by talking about,
suppose you've got a

00:02:37.670 --> 00:02:40.130
QuickTime savvy application.

00:02:40.400 --> 00:02:44.230
Is there anything additional you need to
do to make it work well with the kinds

00:02:44.230 --> 00:02:46.190
of movies we saw in the previous session?

00:03:06.980 --> 00:03:07.000
The answer is yes,
and I have outlined here four different

00:03:07.000 --> 00:03:07.000
levels of interactive awareness.

00:03:07.000 --> 00:03:07.000
First, I call interactive challenged.

00:03:07.000 --> 00:03:07.000
Second, interactive aware.

00:03:07.000 --> 00:03:07.000
Interactive smart.

00:03:07.000 --> 00:03:07.000
And then, if you're really good,
your app can be an interactive genius.

00:03:07.000 --> 00:03:07.000
So what are those?

00:03:07.570 --> 00:03:11.870
An interactive challenged application
does not use a movie controller

00:03:11.870 --> 00:03:13.630
to guide the movie's actions.

00:03:13.960 --> 00:03:18.530
If you were in the 601 session today,
we tried to drive the point home that

00:03:18.590 --> 00:03:22.380
if you have a QuickTime application
that plays QuickTime movies,

00:03:22.420 --> 00:03:25.930
you want to use a movie
controller to do that.

00:03:26.140 --> 00:03:30.240
However, it's possible that even if
you do use a movie controller,

00:03:30.310 --> 00:03:32.020
you can try to be too clever.

00:03:32.260 --> 00:03:35.120
And here's a couple of lines
of code where the developer

00:03:35.200 --> 00:03:37.440
has tried to be too clever.

00:03:37.520 --> 00:03:41.030
What they've said is, well,
if the movie isn't playing,

00:03:41.030 --> 00:03:45.860
that is to say, if getMovieRate is zero,
there's no point in giving

00:03:45.860 --> 00:03:48.370
the event to MCIsPlayerEvent.

00:03:48.680 --> 00:03:53.200
This was fine for linear movies perhaps,
but for interactive movies

00:03:53.510 --> 00:03:55.190
it will fail miserably.

00:03:56.810 --> 00:04:00.640
A step up is interactive aware.

00:04:00.700 --> 00:04:03.800
And this sort of just means that
you're not interactive challenged.

00:04:03.800 --> 00:04:07.840
You use a movie controller to guide
your movies and you install a movie

00:04:07.840 --> 00:04:16.820
controller action filter procedure
to handle movie controller actions.

00:04:16.950 --> 00:04:16.950
I've got electrodes coming out here.

00:04:19.330 --> 00:04:23.140
Step up from interactive
aware is interactive smart.

00:04:23.150 --> 00:04:25.700
What do you need to do
to be interactive smart?

00:04:25.700 --> 00:04:31.040
Well, you need to handle key-up events,
you need to support full-screen playback,

00:04:31.080 --> 00:04:33.690
you need to support the kind
of intermovie communication we

00:04:33.690 --> 00:04:36.890
saw in the previous session,
and you need to support what

00:04:36.890 --> 00:04:38.940
I call application messages.

00:04:39.010 --> 00:04:42.940
Each one of these I'll talk
about in more detail as we go on.

00:04:43.890 --> 00:04:46.270
Finally,
if you're really clever and you've really

00:04:46.320 --> 00:04:50.200
got a great application and you want to
be an interactive genius application,

00:04:50.200 --> 00:04:54.310
you need to do two more things,
namely support skinned movies and

00:04:54.320 --> 00:04:56.220
support contextual pop-up menus.

00:04:57.950 --> 00:05:03.970
Let's go to the demo machine and see what
I mean by skin movies and context menus.

00:05:04.860 --> 00:05:07.060
We've actually seen quite
a number of skins today,

00:05:07.060 --> 00:05:11.580
so I'll do this quite briefly.

00:05:13.970 --> 00:05:17.840
Here is a very simple skin movie.

00:05:17.850 --> 00:05:19.140
It's got a video track there.

00:05:19.140 --> 00:05:20.870
Unfortunately,
I can't play the video track because

00:05:20.870 --> 00:05:22.800
I don't have clearance to do that.

00:05:22.880 --> 00:05:25.160
And I didn't get time to
replace the video track.

00:05:25.200 --> 00:05:28.700
But I can grab in my
Apple and move it around.

00:05:28.720 --> 00:05:31.900
I could click in here and
start the video playing.

00:05:32.000 --> 00:05:33.740
So there's QuickTime Player.

00:05:33.760 --> 00:05:36.890
It's got at least that much
interactive savvy that it can

00:05:36.910 --> 00:05:39.760
open and display skin movies.

00:05:39.790 --> 00:05:43.120
But of course,
other applications can too.

00:05:43.140 --> 00:05:48.900
Let's drop that same movie onto

00:05:49.620 --> 00:05:54.930
This custom application and I also
get skinned movie support there.

00:05:55.400 --> 00:06:00.270
Now this is a sample
application called QtSkins.

00:06:00.270 --> 00:06:04.670
That sample code has been up
on the web for quite a while,

00:06:05.070 --> 00:06:07.800
but I'll warn you if
you go get that today,

00:06:07.800 --> 00:06:09.960
it won't work under the
current builds of OS X.

00:06:09.960 --> 00:06:11.130
There's some problems with it.

00:06:11.270 --> 00:06:15.090
I'm currently working on upgrading it,
so in about a week or so,

00:06:15.090 --> 00:06:19.990
you can go there and grab the source code
and have a skin-savvy app in no time.

00:06:22.990 --> 00:06:26.840
Let's talk about contextual menus.

00:06:26.840 --> 00:06:29.900
To do that, I'm going to launch Explorer.

00:06:29.900 --> 00:06:35.290
By contextual menus,
I mean the kind of thing

00:06:35.480 --> 00:06:39.020
you get in a Flash movie.

00:06:39.020 --> 00:06:39.020
Let's go to...

00:06:39.180 --> 00:06:43.650
"Just a random website that may
have some Flash content on it.

00:06:43.670 --> 00:06:46.970
So here I've got some,
I've got a Flash movie.

00:06:47.110 --> 00:06:49.970
And how can I tell that's a Flash movie?

00:06:50.050 --> 00:06:55.040
If I control click in there,
I get this nice contextual pop-up menu.

00:06:55.040 --> 00:06:58.570
This is also characteristic
of the Flash player,

00:06:58.650 --> 00:07:02.250
but they added it so that
you could sort of zoom in,

00:07:02.250 --> 00:07:05.850
do various other things in the browser."

00:07:09.650 --> 00:07:13.050
Now, to achieve the level
of interactive genius,

00:07:13.070 --> 00:07:16.360
it would be nice to have that same
capability in your application.

00:07:16.360 --> 00:07:18.950
And here again,
I've got a sample application.

00:07:18.950 --> 00:07:21.840
I'm just going to take
a sample flash file,

00:07:21.840 --> 00:07:24.000
open it in this application.

00:07:24.000 --> 00:07:27.400
This flash file,
when I use my arrow keys,

00:07:27.500 --> 00:07:30.300
the little ladybug moves around.

00:07:30.300 --> 00:07:33.670
This is a QuickTime movie.

00:07:33.670 --> 00:07:38.460
And again, if I do my control click,
in this application,

00:07:38.460 --> 00:07:39.580
I've got the ability to create a movie.

00:07:39.600 --> 00:07:40.440
I've got the ability to zoom in.

00:07:40.440 --> 00:07:44.320
And I get that wonderful flash
vector graphics that looks

00:07:44.380 --> 00:07:45.520
good at all magnifications.

00:07:47.130 --> 00:07:52.420
I can go back, zoom out,
and pull up the About box

00:07:52.840 --> 00:07:53.570
for that application.

00:07:53.600 --> 00:07:57.640
Okay, back to slides, please.

00:08:03.080 --> 00:08:06.940
So I'll talk a little bit later
about exactly what you need to do to

00:08:06.950 --> 00:08:11.290
support skins and the contextual menu,
but let's start at the lower level and

00:08:11.300 --> 00:08:13.140
talk about how to be interactive aware.

00:08:13.140 --> 00:08:17.830
The essential thing is that you use a
movie controller to control your movies,

00:08:17.830 --> 00:08:21.720
and the main thing you want to do
in that regard is to install a movie

00:08:21.720 --> 00:08:24.320
controller action filter procedure.

00:08:25.130 --> 00:08:28.620
A movie controller is quite a
polite piece of code in that

00:08:28.740 --> 00:08:32.940
before it does anything important,
it tells your application

00:08:33.130 --> 00:08:37.020
about it and gives you a chance
to augment its behaviors or,

00:08:37.020 --> 00:08:38.980
in fact, cancel what it's about to do.

00:08:38.980 --> 00:08:43.690
We do this with what's called a movie
controller action filter procedure,

00:08:43.770 --> 00:08:45.530
which we install like this.

00:08:45.600 --> 00:08:47.900
Now, there's several versions
of this function.

00:08:47.900 --> 00:08:52.110
The one I'm calling here is
MCSetActionFilterWithRefCon.

00:08:53.010 --> 00:08:57.780
What I get here additional is
that I can pass an arbitrary

00:08:57.970 --> 00:09:01.170
four-byte reference constant.

00:09:01.180 --> 00:09:03.590
In this case, as you can see,
I'm passing something

00:09:03.700 --> 00:09:04.860
called myWindowData.

00:09:04.860 --> 00:09:07.510
Presumably,
that's a handle or a pointer to some

00:09:07.570 --> 00:09:10.100
data that's associated with this window.

00:09:12.300 --> 00:09:15.480
What do I do inside
my action filter proc?

00:09:15.550 --> 00:09:21.360
I'm going to be given MC actions
as one of the parameters.

00:09:21.360 --> 00:09:24.440
And what I want to do, for instance,
if I get a MC action

00:09:24.440 --> 00:09:29.960
controller size changed action,
is to resize my window to

00:09:29.980 --> 00:09:32.990
hold the resized movie.

00:09:33.340 --> 00:09:36.220
In this case,
you'll notice I'm turning false,

00:09:36.220 --> 00:09:41.760
indicating to the movie controller
that I haven't handled that action.

00:09:41.760 --> 00:09:43.950
That is to say that
I don't want to cancel it.

00:09:44.170 --> 00:09:48.320
If I were to return true,
I would be canceling the

00:09:48.680 --> 00:09:51.020
controller size change.

00:09:52.270 --> 00:09:55.630
So that's essentially what you
need to do to be interactive aware.

00:09:55.860 --> 00:09:58.720
To be interactive smart,
one thing we need to do is

00:09:58.760 --> 00:10:00.340
to support the key up event.

00:10:00.380 --> 00:10:03.880
Now back in 1984 when
the MacÂ OS was developed,

00:10:04.260 --> 00:10:07.120
they thought key up
events are fairly useless.

00:10:07.120 --> 00:10:10.240
Who in the world would want to do
something in response to a key up event?

00:10:10.280 --> 00:10:14.220
So the default behavior for
Macintosh applications is

00:10:14.300 --> 00:10:16.460
to filter out key up events.

00:10:16.460 --> 00:10:19.670
Well it turns out that in Flash,
you can do things when

00:10:19.670 --> 00:10:21.350
you've got a key up event.

00:10:22.050 --> 00:10:27.140
So to fully support Flash,
we had to add to QuickTime the capability

00:10:27.230 --> 00:10:30.470
to pass this key up event through.

00:10:30.860 --> 00:10:36.440
So what you need to do is to enable
your application to get the event.

00:10:36.750 --> 00:10:40.060
And how you do that depends on
exactly how you're doing the coding.

00:10:40.180 --> 00:10:42.980
If you have a WaitNextEvent application,
you'll want to call

00:10:42.980 --> 00:10:45.240
setEventMask to every event.

00:10:45.330 --> 00:10:49.020
If you have a CarbonEvent application,
you'll want to register to

00:10:49.020 --> 00:10:53.300
receive the KEvent raw key up.

00:10:53.430 --> 00:10:55.110
Now what do you do when
you get this event?

00:10:55.410 --> 00:10:59.490
You just give it to the movie controller
and the right thing will happen.

00:11:01.060 --> 00:11:03.690
The next thing we want to do to
be interactive smart is to be able

00:11:03.750 --> 00:11:06.560
to play back movies full screen.

00:11:07.420 --> 00:11:10.900
QuickTime provides two functions,
begin full screen and end full screen,

00:11:10.900 --> 00:11:13.980
that we can use to play
a movie back full screen.

00:11:13.980 --> 00:11:19.400
It's actually a little bit trickier than
just calling these functions because

00:11:19.400 --> 00:11:22.260
when you put a movie into full screen,
you have to adjust various

00:11:22.780 --> 00:11:24.000
movie controller settings.

00:11:24.080 --> 00:11:26.990
For instance, you have to tell it,
you're no longer playing

00:11:26.990 --> 00:11:30.050
in this small rectangle,
you're playing in this big rectangle.

00:11:32.630 --> 00:11:36.040
And it turns out that there are actually
a number of ways that you can be told

00:11:36.160 --> 00:11:39.480
to put a movie into full screen mode.

00:11:39.510 --> 00:11:43.730
One of them is a movie can have a
piece of movie user data of type

00:11:43.900 --> 00:11:49.080
PTV that indicates that this movie
wants to be played full screen.

00:11:49.120 --> 00:11:52.330
So when you open a movie file,
you should look for that

00:11:52.440 --> 00:11:53.920
piece of movie user data.

00:11:53.940 --> 00:11:57.630
If you find it,
make sure that it says to put the

00:11:57.720 --> 00:12:00.690
movie full screen and then do so.

00:12:01.050 --> 00:12:04.500
Another way that you can be told
to put a movie full screen is by

00:12:04.510 --> 00:12:09.940
receiving various application messages,
which we'll talk more about later.

00:12:10.020 --> 00:12:13.060
But let's look at a demo of that.

00:12:13.120 --> 00:12:15.390
Back to the demo machine.

00:12:21.000 --> 00:12:24.410
So here I have four different
files that I want to open.

00:12:24.570 --> 00:12:27.680
The first one is called Full Screen Atom.

00:12:27.950 --> 00:12:32.330
And this has that PTV atom that
tells me that I want to put the

00:12:32.340 --> 00:12:34.300
movie into full screen mode.

00:12:34.430 --> 00:12:38.130
So let's drag that onto my
sample application here.

00:12:40.910 --> 00:12:44.890
The movie opens and then immediately
goes full screen and starts playing.

00:12:44.890 --> 00:12:49.400
If I hit escape,
I come back out of full screen.

00:12:49.470 --> 00:12:52.200
Another way a movie could want to
go full screen is if the user says,

00:12:52.360 --> 00:12:54.780
"Please put this into full
screen." For instance,

00:12:54.780 --> 00:12:58.490
if there's a menu item that says,
"Play full screen," again,

00:12:58.580 --> 00:13:00.100
we'll go full screen.

00:13:00.100 --> 00:13:03.170
We can start it and play it through.

00:13:05.200 --> 00:13:09.420
So there's two ways so far we can be told
to go full screen with the movie user,

00:13:09.490 --> 00:13:12.900
Adam, and with a menu command.

00:13:13.070 --> 00:13:16.880
Let me illustrate what
I call application messages.

00:13:16.920 --> 00:13:20.990
Here is a simple sprite movie.

00:13:22.500 --> 00:13:24.800
It's got a single sprite
here on the movie.

00:13:24.830 --> 00:13:28.240
And I have it configured so
that when I click on the sprite,

00:13:28.300 --> 00:13:31.460
it sends a message to the
application that says,

00:13:31.500 --> 00:13:33.990
wouldn't you please put
me into full screen mode?

00:13:34.220 --> 00:13:34.830
So let's do that.

00:13:34.980 --> 00:13:36.040
Click.

00:13:36.100 --> 00:13:39.840
And the application,
being interactive smart,

00:13:39.910 --> 00:13:43.920
knows how to handle that message
and put it into full screen mode.

00:13:43.960 --> 00:13:51.190
The final way we can be told to go
full screen is by opening a Flash file.

00:13:52.500 --> 00:14:20.100
[Transcript missing]

00:14:23.530 --> 00:14:25.180
Okay,
so that's all I'm going to talk about for

00:14:25.230 --> 00:14:27.450
the moment in terms of interactive savvy.

00:14:27.450 --> 00:14:31.120
I've left a few things undone at
the level of interactive smart,

00:14:31.280 --> 00:14:33.980
which I'll come back to later,
and I haven't yet talked about

00:14:34.100 --> 00:14:35.500
the interactive genius level.

00:14:37.650 --> 00:14:43.060
So what, if we have an application,
can we do within the application to

00:14:43.100 --> 00:14:45.660
add interactive behaviors to our movie?

00:14:45.740 --> 00:14:49.520
Well,
QuickTime has a whole bunch of APIs that

00:14:49.520 --> 00:14:52.460
we can call to do various things.

00:14:52.550 --> 00:14:56.440
In this case,
the interactive behavior is provided

00:14:56.440 --> 00:14:59.430
by the playback application.

00:14:59.720 --> 00:15:02.390
Now let's take a demo of that.

00:15:07.300 --> 00:15:12.630
Here I have a QuickTime VR movie
and I'm going to drop it on this

00:15:12.820 --> 00:15:17.510
Custom Application and you'll see
that as soon as the movie opens up it

00:15:17.510 --> 00:15:20.500
starts automatically panning around.

00:15:21.100 --> 00:15:24.000
In addition,
I've got this... the program is smart

00:15:24.000 --> 00:15:27.780
enough to know that when I click here,

00:15:28.300 --> 00:15:56.400
[Transcript missing]

00:15:57.900 --> 00:16:04.580
So let's sort of deconstruct that and see
how to do that using the QuickTime API.

00:16:05.090 --> 00:16:07.550
First thing we need to do is
install some sort of timer.

00:16:07.810 --> 00:16:11.580
Now what timer you use will depend
upon your development environment.

00:16:11.650 --> 00:16:13.840
Cocoa and Windows have timers.

00:16:13.860 --> 00:16:18.220
In a WaitNextEvent application we
could just be in our main event

00:16:18.240 --> 00:16:20.100
loop looking for tick count.

00:16:20.180 --> 00:16:27.590
Here I'm installing a CarbonEventLoop
timer to fire after a specified delay.

00:16:28.300 --> 00:16:33.270
I'm passing into the timer an
indication of what callback function

00:16:33.320 --> 00:16:36.230
to call when that timer triggers.

00:16:36.230 --> 00:16:38.620
And I'm also passing it
in a piece of data here,

00:16:38.620 --> 00:16:40.180
my instance.

00:16:40.210 --> 00:16:46.340
An instance here is an identifier for
the QuickTime VR movie that I've opened.

00:16:47.750 --> 00:16:50.890
When the timer fires,
what I want to do is get

00:16:50.960 --> 00:16:54.430
the current pan angle,
increment it by some amount,

00:16:54.500 --> 00:16:58.200
here by one degree,
and then set that pan angle.

00:16:58.200 --> 00:17:01.760
So I'm getting the pan angle
and constantly incrementing

00:17:01.760 --> 00:17:04.020
it whenever the timer fires.

00:17:04.050 --> 00:17:07.320
You'll notice that I've
got a global variable here,

00:17:07.460 --> 00:17:09.920
g if okay to auto spin.

00:17:10.020 --> 00:17:14.380
So I'm going to set the new
pan angle only if that is true.

00:17:16.050 --> 00:17:17.600
Why do I need that?

00:17:17.620 --> 00:17:22.210
Well, if I get a click in the movie,
the movie controller will send

00:17:22.360 --> 00:17:28.040
my MC Action proc an action
of type MC Action Mouse Down.

00:17:28.090 --> 00:17:30.000
What do I want to do on a mouse down?

00:17:30.020 --> 00:17:33.650
I want to say stop spinning,
and then I want to set another

00:17:34.400 --> 00:17:37.180
timer to kick off in 10 seconds.

00:17:37.330 --> 00:17:40.770
and you can see down below is
my second timer which just sets

00:17:40.900 --> 00:17:45.540
that global variable to true and
effectively starts the spinning again.

00:17:45.570 --> 00:17:50.440
So here with maybe twenty lines of code
added to my application I've got some

00:17:50.860 --> 00:17:52.680
fairly interesting interactive behaviors.

00:17:56.560 --> 00:18:00.080
Let's take another example
of some interactive behaviors

00:18:00.630 --> 00:18:05.900
I can get by using the APIs.

00:18:07.760 --> 00:18:13.770
I'm going to open this
QuickTime VR movie in QuickTime Player.

00:18:14.240 --> 00:18:17.170
When I run my mouse over
a hotspot and click it,

00:18:17.260 --> 00:18:19.410
I'll go to a new node.

00:18:22.320 --> 00:18:25.140
and you can see that the default
behavior of QuickTime VR is

00:18:25.160 --> 00:18:27.640
simply to jump to the new node.

00:18:27.660 --> 00:18:32.040
I find that kind of jarring,
so what I did was write a

00:18:32.040 --> 00:18:34.040
special application that

00:18:37.800 --> 00:18:42.920
When I go from one node to the next,
it's going to use the QuickTime effects

00:18:43.020 --> 00:18:47.050
architecture to do a nice smooth
crossfade between the current node

00:18:47.050 --> 00:18:48.740
picture and the target node picture.

00:18:48.740 --> 00:18:50.070
So let's do that.

00:18:50.220 --> 00:18:51.400
Here I am in my special app.

00:18:51.490 --> 00:18:54.660
I'll click the hotspot,
and I get a nice crossfade when

00:18:54.720 --> 00:18:56.660
I go from one node to the next.

00:18:56.660 --> 00:19:00.740
If I come back,
again I get that crossfade.

00:19:00.900 --> 00:19:04.390
Now notice I'm not using a
canned linear movie here.

00:19:04.390 --> 00:19:07.700
If I, for instance,
zoom in and change my pan

00:19:07.700 --> 00:19:11.740
angle and go to the new node,
the crossfade happens from the

00:19:11.840 --> 00:19:13.760
current picture to the new node.

00:19:19.430 --> 00:19:23.400
Back to slides please.

00:19:23.420 --> 00:19:25.400
Okay, how did I do that?

00:19:25.500 --> 00:19:27.760
Again,
I took advantage of several callback

00:19:27.760 --> 00:19:29.770
functions that QuickTime VR provides me.

00:19:29.910 --> 00:19:32.500
In particular,
I use what are called node leaving

00:19:32.500 --> 00:19:36.230
procedures and node entering procedures.

00:19:37.030 --> 00:19:40.630
A node leaving procedure is called
when the user clicks a hotspot

00:19:40.780 --> 00:19:43.710
to go from one node to the other.

00:19:44.400 --> 00:19:47.360
So when I get a node
leaving procedure called,

00:19:47.380 --> 00:19:48.680
what do I want to do?

00:19:48.710 --> 00:19:51.610
Well, I'm going to call these
four lines of code,

00:19:51.630 --> 00:19:53.570
which create an
off-screen graphics world.

00:19:53.590 --> 00:19:56.780
They set the movie to draw
into that graphics world,

00:19:56.780 --> 00:20:00.250
and then I call moviesTask to
actually draw the movie into

00:20:00.250 --> 00:20:02.560
that off-screen graphics world.

00:20:02.560 --> 00:20:04.730
Nothing on the screen has changed.

00:20:04.730 --> 00:20:08.370
I've merely taken the current
picture and drawn it into a block

00:20:08.370 --> 00:20:10.610
of memory that the user can't see.

00:20:12.240 --> 00:20:16.910
When I enter the new node,
I want to do a similar thing.

00:20:17.850 --> 00:20:22.040
I want to create a new
graphics world off-screen,

00:20:22.040 --> 00:20:23.200
a new G world.

00:20:23.240 --> 00:20:27.420
I want to set the movie now to draw into
that second off-screen graphics world.

00:20:27.420 --> 00:20:30.400
I want to call movies
task to get it to draw.

00:20:30.400 --> 00:20:33.970
And now what I've got is two
off-screen graphics world,

00:20:34.050 --> 00:20:36.720
one with a picture of
the node I'm leaving,

00:20:36.720 --> 00:20:39.640
one with a picture of
the node I'm going into,

00:20:39.640 --> 00:20:43.160
and I'll run this function,
my run transition effect,

00:20:43.270 --> 00:20:47.780
to use the QuickTime effects APIs to
draw a nice crossfade between those two.

00:20:47.800 --> 00:20:49.280
too.

00:20:50.320 --> 00:20:55.040
When I'm done drawing that,
I will reset the controller port and the

00:20:55.040 --> 00:21:00.750
movie port to the on-screen window and
then tell the movie that I've changed it.

00:21:02.570 --> 00:21:04.960
Here's an overview
diagram of what I've done.

00:21:04.980 --> 00:21:07.940
Step one, the movie's drawing into
the on-screen window.

00:21:08.110 --> 00:21:10.260
Step two,
I draw it into an off-screen G world.

00:21:10.690 --> 00:21:15.380
Step three, I draw the entered node
into an off-screen G world,

00:21:15.490 --> 00:21:17.470
run the transition effect.

00:21:17.730 --> 00:21:20.980
and then finally reset
everything back to the window.

00:21:20.980 --> 00:21:23.720
So it may look complicated,
but in fact it's fairly simple code,

00:21:23.770 --> 00:21:25.670
and I get a very nice effect from that.

00:21:28.070 --> 00:21:32.340
Now it occurred to me once I had done
that demo that I could apply this

00:21:32.340 --> 00:21:37.250
same logic to a standard linear movie.

00:21:37.250 --> 00:21:40.600
And let's go back to demo
machine and see that.

00:21:49.220 --> 00:21:54.990
Now first I'm going to open this
linear movie in just a run of the

00:21:54.990 --> 00:21:57.660
off the shelf QuickTime application.

00:21:57.670 --> 00:22:00.290
And I'm going to click down
here in the controller bar.

00:22:00.290 --> 00:22:02.950
And again,
the default behavior is just to

00:22:03.060 --> 00:22:05.390
jump to that new time in the movie.

00:22:05.690 --> 00:22:08.770
Again, that's OK,
but we can do better than that.

00:22:08.900 --> 00:22:13.790
So let's open that same movie
in this special application.

00:22:14.370 --> 00:22:17.300
and then click somewhere at the
controller bar and now we get a

00:22:17.300 --> 00:22:19.270
nice crossfade to that new time.

00:22:23.250 --> 00:22:24.380
Very nice effect.

00:22:24.410 --> 00:22:31.180
And I've got this little app
set up so that I can perhaps,

00:22:31.180 --> 00:22:33.940
instead of a crossfade,
do a random radial transition.

00:22:33.940 --> 00:22:37.980
This is good stuff.

00:22:38.040 --> 00:22:38.900
I could do this all day.

00:22:44.920 --> 00:22:46.580
OK, back to the slides, please.

00:22:46.600 --> 00:22:51.850
So here's how I did the
time jump transition.

00:22:51.860 --> 00:22:55.700
Again, I'm exploiting my movie controller
action filter procedure.

00:22:55.820 --> 00:22:59.880
I'm now looking for an action
of type MCAction go to time.

00:22:59.880 --> 00:23:03.520
The movie controller sends
me this when it wants me to,

00:23:03.520 --> 00:23:05.590
lo and behold, go to a new time.

00:23:05.600 --> 00:23:08.480
And in that case,
I'll call this application-specific

00:23:08.610 --> 00:23:11.160
function doTimeJump,
which essentially does the

00:23:11.250 --> 00:23:14.470
same sort of thing I did before
by getting the two images and

00:23:14.470 --> 00:23:17.830
running a decompression sequence
to make that effect between them.

00:23:17.840 --> 00:23:20.110
The only difference is
that with the VR case,

00:23:20.220 --> 00:23:23.040
I was using node entering and
leaving procedures to trigger it.

00:23:23.300 --> 00:23:25.980
Now I'm using a movie
controller action to trigger it.

00:23:27.830 --> 00:23:30.530
Now the QuickTime,
I could go on and on for the entire

00:23:30.590 --> 00:23:33.700
hour here with these kinds of examples.

00:23:33.840 --> 00:23:34.000
Why?

00:23:34.000 --> 00:23:38.230
Because the QuickTime APIs are just
full of these callback procedures

00:23:38.240 --> 00:23:42.710
that I can use to get my grubby
little mitts into its workings.

00:23:42.860 --> 00:23:45.510
I could, for instance,
use intercept procedures to

00:23:45.510 --> 00:23:48.310
add directional sounds so
that when I'm panning around,

00:23:48.310 --> 00:23:52.620
I can adjust the volume and balance of
a sound that's playing to make it look

00:23:52.740 --> 00:23:55.870
like the sound is somewhere in that node.

00:23:56.150 --> 00:23:59.890
I could use what are called time-based
callback functions to do things

00:23:59.940 --> 00:24:03.260
when the movie reaches its end or
is at the beginning or is indeed

00:24:03.260 --> 00:24:06.260
at any time in the middle there.

00:24:06.400 --> 00:24:09.990
If I have a text track,
I could define a text loading

00:24:09.990 --> 00:24:13.800
procedure that is called whenever
a new text sample gets loaded.

00:24:13.860 --> 00:24:17.370
A useful thing to do there would be to
look at the actual text which is being

00:24:17.390 --> 00:24:20.060
loaded and do something to that text.

00:24:20.210 --> 00:24:21.180
And on and on and on.

00:24:21.440 --> 00:24:26.710
Really the sky's the limit when
you have the APIs at your disposal.

00:24:28.330 --> 00:24:32.560
The limitations here, however,
are that when I use

00:24:32.560 --> 00:24:37.280
QuickTime functions like this to
do special interactive things,

00:24:37.390 --> 00:24:41.300
for the user to get that experience,
they need my special application.

00:24:41.410 --> 00:24:44.400
So they need this special
playback application.

00:24:44.540 --> 00:24:47.040
Now in some cases,
this might not be a problem at all.

00:24:47.140 --> 00:24:50.470
If I'm putting out
kiosks or a CD-ROM title,

00:24:50.600 --> 00:24:55.970
I can put the playback application
right there where the user can get it.

00:24:58.730 --> 00:25:02.670
However, it's kind of tricky if I'm
in some other situation.

00:25:02.790 --> 00:25:05.030
For instance,
if I want this stuff to work on the web,

00:25:05.230 --> 00:25:09.140
in a web browser, I can't ship a special
playback application.

00:25:09.190 --> 00:25:13.500
I'm not about to write a web
browser that does my special stuff.

00:25:13.540 --> 00:25:19.940
Well, even here we can get this
capability to some degree.

00:25:20.370 --> 00:25:38.920
The first thing we could do is take
the intelligence out of the playback

00:25:38.920 --> 00:25:38.920
application and put it into the movie.

00:25:38.920 --> 00:25:38.920
We saw a lot of examples of
this in the previous session.

00:25:38.920 --> 00:25:38.920
This is what I call scripting the media.

00:25:38.920 --> 00:25:38.920
Make the media intelligent,
not the playback application.

00:25:39.130 --> 00:25:41.340
The second thing I could
do would be to say,

00:25:41.340 --> 00:25:45.760
"I really want to do it my way,
and lo and behold,

00:25:45.760 --> 00:25:48.340
the current scripting behaviors
don't let me do that kind of

00:25:48.470 --> 00:25:53.060
stuff." I could write a custom media
handler that had that logic in it,

00:25:53.420 --> 00:25:56.940
and then using the new third-party
component download program,

00:25:57.300 --> 00:26:02.610
get that custom media handler
distributed to my viewing public.

00:26:03.800 --> 00:26:06.180
All right,
so that's what we can do with the APIs.

00:26:06.410 --> 00:26:09.500
Now let's see how we can
make the media intelligent.

00:26:09.670 --> 00:26:12.070
So what is the scripted interactivity?

00:26:12.310 --> 00:26:16.250
This is where the movie itself
contains the logic for these

00:26:16.290 --> 00:26:18.990
dynamic interactive behaviors.

00:26:19.550 --> 00:26:25.530
The advantage of that is that that movie
can exhibit those behaviors anywhere

00:26:25.530 --> 00:26:29.580
this QuickTime movie is played back,
in the web browser, in QuickTime Player,

00:26:29.750 --> 00:26:32.360
or indeed in any
QuickTime-savvy application.

00:26:34.910 --> 00:26:39.300
QuickTime now supports two
basic types of scripting.

00:26:39.320 --> 00:26:42.100
Since we support
Flash inside of QuickTime,

00:26:42.170 --> 00:26:47.290
we can take advantage of
Flash's ActionScript capability.

00:26:47.450 --> 00:26:51.090
Or, as we saw previously,
QuickTime provides its own type

00:26:51.180 --> 00:26:53.800
of scripting called Wired Actions.

00:26:53.910 --> 00:26:56.140
Let's take a look at each of those.

00:26:56.240 --> 00:26:58.540
Back to the demo machine.

00:27:04.960 --> 00:27:11.910
Let's look at a very simple example
of some flash interactivity.

00:27:11.910 --> 00:27:15.470
Here we have a simple movie where
I can move my cursor over these

00:27:15.540 --> 00:27:20.570
objects and drag them around and
make kind of a neat little eggplant.

00:27:20.660 --> 00:27:25.270
Very simple interactivity,
just being to drag objects around.

00:27:25.420 --> 00:27:28.910
Slightly more complex interactivity,

00:27:29.700 --> 00:27:40.500
[Transcript missing]

00:27:42.470 --> 00:27:43.510
Okay, how did I do that?

00:27:43.570 --> 00:27:44.480
Let's go back to slides.

00:27:44.480 --> 00:27:49.830
This is the entire scripting
that's attached to one of those

00:27:49.830 --> 00:27:51.440
objects in the Eggplant movie.

00:27:51.440 --> 00:27:55.300
It says that when the mouse goes down,
start dragging,

00:27:55.380 --> 00:27:59.180
and then the name of an object,
and when the mouse comes up,

00:27:59.180 --> 00:28:00.420
stop dragging.

00:28:00.420 --> 00:28:03.900
Start drag and stop drag are two
functions that are built into Flash.

00:28:03.970 --> 00:28:06.610
Essentially, they say,
you've given me an object,

00:28:06.700 --> 00:28:09.810
I'm going to make it follow the
cursor until you call stop drag,

00:28:09.960 --> 00:28:12.340
which happens when the mouse is released.

00:28:12.400 --> 00:28:17.710
Very simple scripting to get that
cool drag ability to Flash objects.

00:28:17.810 --> 00:28:23.400
The lines is slightly more complicated,
and I won't tear this apart entirely,

00:28:23.400 --> 00:28:25.840
but as you can see,
what's going on is they're reading

00:28:25.930 --> 00:28:29.170
the current position of the mouse,
this underscore root dot

00:28:29.170 --> 00:28:31.080
underscore X mouse and Y mouse.

00:28:31.160 --> 00:28:34.110
They're doing a little bit
of math or trigonometry here,

00:28:34.110 --> 00:28:37.180
figuring out a rotation for the lines,
and then setting the

00:28:37.180 --> 00:28:38.650
rotation of that object.

00:28:42.420 --> 00:28:43.540
Okay, so much for Flash.

00:28:43.540 --> 00:28:46.200
Again, Flash scripting is the kind
of thing we could spend hours

00:28:46.280 --> 00:28:47.710
and hours talking about.

00:28:47.830 --> 00:28:53.060
It's sort of this limitless capability
of adding cool interactive behaviors

00:28:53.070 --> 00:28:55.000
to objects in a Flash movie.

00:28:55.300 --> 00:28:57.840
More generally,
we can add what are called wired

00:28:57.840 --> 00:29:01.470
actions to QuickTime movies.

00:29:01.900 --> 00:29:07.170
We do this by creating what are
called wired atoms and attaching

00:29:07.170 --> 00:29:11.460
those wired atoms to various
kinds of QuickTime tracks.

00:29:11.460 --> 00:29:15.750
The wired atom indicates two things:
what events are going to trigger it

00:29:15.850 --> 00:29:20.330
and what to do when it gets triggered.

00:29:20.390 --> 00:29:22.680
And a wired track is simply
a track that contains one or

00:29:22.680 --> 00:29:25.060
more of these wired atoms.

00:29:25.900 --> 00:29:33.220
Action wiring in QuickTime is just about
as full-bodied as ActionScript in Flash.

00:29:33.780 --> 00:29:36.550
We have all sorts of programming
constructs that we can use

00:29:36.580 --> 00:29:37.940
to create wired actions.

00:29:37.940 --> 00:29:41.820
We can define constants,
have variables with changing values,

00:29:41.820 --> 00:29:46.030
we can set things to happen in a loop,
we can branch according to, say,

00:29:46.030 --> 00:29:49.240
the value of variable,
we have operands that allow

00:29:49.280 --> 00:29:52.610
us to query the environment
and base our actions upon,

00:29:52.610 --> 00:29:55.560
say,
what kind of machine we're running on.

00:29:55.800 --> 00:29:56.880
Thank you.

00:29:57.890 --> 00:29:59.770
This is what a wired atom looks like.

00:30:00.010 --> 00:30:03.840
It's a hierarchical
structure of these atoms.

00:30:04.130 --> 00:30:08.430
Every atom has three pieces of
information associated with it.

00:30:08.540 --> 00:30:13.500
It has a type, it has an ID,
and it has some data.

00:30:13.500 --> 00:30:18.420
Now in this case, the top level atom is
of type KQT event type,

00:30:18.420 --> 00:30:25.750
and its ID is some value that indicates
what event is going to trigger this atom.

00:30:25.750 --> 00:30:29.760
Here we have identifiers
for the standard events,

00:30:29.760 --> 00:30:32.440
mouse over, mouse down,
various key downs,

00:30:32.440 --> 00:30:36.940
things can happen on idle events,
fairly rich vocabulary there.

00:30:37.060 --> 00:30:40.200
Now what is the data associated
with that top level atom?

00:30:40.200 --> 00:30:43.470
It is another atom,
so I'm building up hierarchical

00:30:43.950 --> 00:30:45.480
collections of atoms.

00:30:45.650 --> 00:30:49.190
That other atom is of type K action.

00:30:49.290 --> 00:30:55.750
It's going to specify what action
to do when that event occurs.

00:30:56.160 --> 00:31:01.640
The action here has a type which
indicates which action to perform,

00:31:01.720 --> 00:31:07.420
and it may also need some parameter atoms
that give you some optional parameters.

00:31:07.860 --> 00:31:08.960
How do I build those?

00:31:09.030 --> 00:31:13.140
QuickTime provides a number of functions
that we can use to build atom containers,

00:31:13.270 --> 00:31:17.740
that is to say things that hold atoms,
and then within that container, atoms.

00:31:17.800 --> 00:31:21.220
Now here,
this slide and the next slide is all the

00:31:21.320 --> 00:31:29.550
code minus any error checking that we
would like to have to build a wired atom.

00:31:29.820 --> 00:31:32.100
Let's just briefly run through this.

00:31:32.130 --> 00:31:36.700
First thing I do is call
QtNewAtomContainer to build a container.

00:31:36.980 --> 00:31:40.800
Then I'm going to start inserting
children into that container.

00:31:40.800 --> 00:31:45.560
The first child I insert is
of type KQTEventMouseClick.

00:31:45.960 --> 00:31:49.200
So this event, sorry,
this wired atom is going to be

00:31:49.330 --> 00:31:53.760
triggered by a mouse click on
whatever object it's attached to.

00:31:53.900 --> 00:31:57.560
Into that atom, I add an action atom.

00:31:57.660 --> 00:32:02.500
Then continuing, the action here is going
to be K action go to URL.

00:32:02.690 --> 00:32:07.210
So when I have this finished, this atom,
and I attach it to something

00:32:07.210 --> 00:32:10.220
in a QuickTime movie,
when that object gets clicked,

00:32:10.220 --> 00:32:15.260
it's going to open my web browser and
go to whatever URL I've specified.

00:32:15.340 --> 00:32:17.360
What URL was it?

00:32:17.360 --> 00:32:20.480
It was www.apple.com.

00:32:21.360 --> 00:32:27.200
So, those two pages of code are
letting me build a wired atom.

00:32:27.280 --> 00:32:30.630
Now my job is to put that wired
atom somewhere in a QuickTime movie

00:32:30.630 --> 00:32:32.460
so that it actually does some good.

00:32:34.120 --> 00:32:37.400
The first thing we can
attach it to is a sprite.

00:32:37.610 --> 00:32:40.270
A sprite is a

00:32:40.300 --> 00:33:08.300
[Transcript missing]

00:33:16.740 --> 00:33:20.340
Okay, first let's look at a little
bit of mouse following.

00:33:20.410 --> 00:33:26.940
Here's a sprite movie that just follows
the location of the mouse or cursor

00:33:26.940 --> 00:33:29.700
and changes its image accordingly.

00:33:29.820 --> 00:33:31.700
Nothing exciting there.

00:33:31.840 --> 00:33:34.450
We saw in Flash that
I could drag things around.

00:33:34.760 --> 00:33:36.630
I can also do that with wired sprites.

00:33:36.870 --> 00:33:40.960
Here as I move that over my cursor
changes and I can drag that sprite

00:33:40.970 --> 00:33:43.380
around inside the sprite movie.

00:33:44.170 --> 00:33:51.390
I can set sprites moving around,
and this sprite has some wiring

00:33:51.390 --> 00:33:55.240
attached to it that's reading
its position and determining

00:33:55.350 --> 00:33:58.400
where it is within the movie box,
and when it reaches the edge,

00:33:58.470 --> 00:34:03.870
it's changing the direction of travel
in one or both of the directions.

00:34:04.740 --> 00:34:11.240
I can put several of those in a movie and
I can make them interact with each other.

00:34:11.310 --> 00:34:14.680
So here you saw that when they
bang against each other they bounce

00:34:14.680 --> 00:34:17.660
away at the appropriate angle.

00:34:17.700 --> 00:34:20.370
And finally let's go back to that

00:34:20.880 --> 00:34:33.150
is the creator of the new,
highly-appreciated,

00:34:33.150 --> 00:34:33.150
and highly-appreciated, web browser.

00:34:33.150 --> 00:34:33.150
He is the

00:34:39.240 --> 00:34:42.260
So there we see in a very
simple way how to wire sprites.

00:34:42.410 --> 00:34:44.410
Back to slides, please.

00:34:45.630 --> 00:34:49.380
We can also wire text tracks.

00:34:49.440 --> 00:34:51.660
This is kind of a fun thing.

00:34:51.820 --> 00:34:54.620
How do I wire a text track?

00:34:54.720 --> 00:34:57.360
Where do I put the wired atom
when I have a text track?

00:34:58.270 --> 00:35:03.290
A text media sample consists really
just of a bunch of text followed by

00:35:03.450 --> 00:35:05.740
one or more text atom extensions.

00:35:05.740 --> 00:35:08.800
So I have the text in the
sample and I can stick some

00:35:08.800 --> 00:35:11.140
additional data after that text.

00:35:11.500 --> 00:35:17.120
One of these types of additional data
is called a wired text atom extension.

00:35:17.300 --> 00:35:20.670
And within that wired
text atom extension,

00:35:20.670 --> 00:35:26.340
I can have what are called hypertext
item atoms that pick out various ranges

00:35:26.340 --> 00:35:31.850
of text and associate the dynamic
behaviors with a text in that range.

00:35:31.880 --> 00:35:36.350
And the contents of the hypertext
item atom is simply the wired atom

00:35:36.520 --> 00:35:38.520
or what I call the event atom.

00:35:38.520 --> 00:35:40.800
And here's a little bit better look.

00:35:41.100 --> 00:35:43.420
So I The text sample
consists of a length,

00:35:43.800 --> 00:35:46.360
some text, a text atom extension.

00:35:46.360 --> 00:35:49.740
The text atom extension
can look like this.

00:35:49.740 --> 00:35:52.960
And you can see that
down at the bottom there,

00:35:53.150 --> 00:35:57.100
I've added in my kqt event type atom.

00:35:57.930 --> 00:36:01.680
is a great example of how to
create a video presentation

00:36:02.500 --> 00:36:04.870
that is as simple as possible.

00:36:11.210 --> 00:36:13.830
Here's a text movie that I'm opening.

00:36:13.860 --> 00:36:15.520
It says, please take me to Apple or CNN.

00:36:15.520 --> 00:36:22.800
This has in that text sample the
kind of structure that we saw there.

00:36:22.800 --> 00:36:25.240
I have two ranges here of hypertext.

00:36:25.280 --> 00:36:27.900
When I run my mouse over,
you can see it changes

00:36:27.900 --> 00:36:30.980
from blue to purple,
indicating that if I click there,

00:36:31.230 --> 00:36:32.470
something may happen.

00:36:32.470 --> 00:36:35.610
Again, if I click the Apple,
it's going to launch my browser

00:36:35.610 --> 00:36:37.240
and take me to Apple.com.

00:36:37.500 --> 00:36:41.920
So exactly the same text wired atom
that I built to put into the sprite,

00:36:41.950 --> 00:36:45.980
I can put into this text track
and have it do the same thing.

00:36:50.010 --> 00:36:52.350
Okay, so we've got wired sprites,
we've got wired text.

00:36:53.060 --> 00:36:56.380
There's two other kinds of
tracks that we can wire.

00:36:56.380 --> 00:36:58.450
One of them is Flash.

00:36:58.450 --> 00:37:03.260
I can't go into as much detail
on Flash because the format of a

00:37:03.260 --> 00:37:06.520
Flash file is horribly complicated.

00:37:06.940 --> 00:37:11.430
The fundamental idea is that
a Flash button or a frame can

00:37:11.710 --> 00:37:14.930
contain a list of actions,
an action list.

00:37:14.930 --> 00:37:19.100
This list of actions,
or each action in that list,

00:37:19.280 --> 00:37:24.710
has a tag which identifies
which action to execute.

00:37:24.940 --> 00:37:30.090
Macromedia was kind enough to
reserve a tag for us that we

00:37:30.110 --> 00:37:35.520
can use to put QuickTime wired
actions into the Flash movie.

00:37:36.140 --> 00:37:39.380
And what is the data that
goes along with that action?

00:37:39.490 --> 00:37:44.400
It's simply the action of the atom
container that we built earlier.

00:37:44.520 --> 00:37:47.190
So let's take a look at that.

00:37:56.340 --> 00:37:59.100
Here again is our simple
little flash button.

00:37:59.160 --> 00:38:04.040
What I've done is do a little bit of
programming to take that Atom container

00:38:04.040 --> 00:38:08.320
that we built earlier and stick it into
the action list associated with this

00:38:08.350 --> 00:38:11.380
button so that when I click the button,
what's going to happen?

00:38:11.380 --> 00:38:13.980
It's going to open my web
browser and take me to Apple.com.

00:38:31.380 --> 00:38:31.710
So this exact same Atom,
event Atom that I built,

00:38:31.710 --> 00:38:31.710
I was able to attach to sprites, text,
and flash.

00:38:31.710 --> 00:38:31.710
And let's go back to slides.

00:38:31.710 --> 00:38:31.710
Now we'll want to attach
that to some QuickTime VR.

00:38:33.050 --> 00:38:36.630
Now,
if we can take these wired actions and

00:38:36.660 --> 00:38:42.080
associate them with either specific
hotspots within a QuickTime VR movie

00:38:42.130 --> 00:38:44.920
or with the node as a whole.

00:38:44.920 --> 00:38:47.980
So we could have it set up so
that when a hotspot is clicked,

00:38:47.980 --> 00:38:52.930
the wired atom gets triggered and
does whatever it's supposed to do.

00:38:53.090 --> 00:38:53.090
Now, the

00:38:53.250 --> 00:38:56.710
Bottom two bullet points show you
exactly where to put that Atom

00:38:56.760 --> 00:38:59.520
container inside a QuickTime VR movie.

00:38:59.540 --> 00:39:02.600
Again, the structure of a VR movie
is fairly complicated,

00:39:02.690 --> 00:39:06.260
so I won't go into that in detail,
but I will give you a

00:39:06.260 --> 00:39:09.260
demo of how that can work.

00:39:17.060 --> 00:39:22.220
So here I'm opening this movie with
QuickTime Player or I could open it in

00:39:22.350 --> 00:39:25.000
any old QuickTime savvy application.

00:39:25.080 --> 00:39:27.180
And you'll notice what did
it do when it opened up?

00:39:27.250 --> 00:39:29.670
It started auto-spinning.

00:39:30.140 --> 00:39:33.720
So the same behavior that I thought
a few minutes ago I needed

00:39:33.810 --> 00:39:37.350
a custom application to get,
now I see that I can

00:39:37.840 --> 00:39:39.210
get with a smart movie.

00:39:39.230 --> 00:39:44.650
That is to say, by adding some wiring to
the QuickTime VR movie.

00:39:45.000 --> 00:39:50.740
So let's go back to slides and see
how I built that particular atom.

00:39:50.890 --> 00:39:52.770
Very much the same thing I did earlier.

00:39:52.780 --> 00:39:55.180
I start off by creating
an atom container.

00:39:55.180 --> 00:39:59.490
Into that atom container,
I add an event atom with

00:39:59.610 --> 00:40:01.680
the ID kqtevent idle.

00:40:01.680 --> 00:40:07.320
So now I want the action to occur
not when the hotspot gets clicked,

00:40:07.420 --> 00:40:09.700
but just every so often.

00:40:09.700 --> 00:40:12.490
Okay, whenever this track gets idled.

00:40:12.510 --> 00:40:18.370
And I can specify the frequency with
which I get idle events in my movie.

00:40:18.390 --> 00:40:22.080
Then to that event atom,
I add an action atom.

00:40:22.090 --> 00:40:26.900
The action this time is going to
be k action qtvr set pan angle.

00:40:27.020 --> 00:40:30.160
In this case,
I need a parameter atom to say

00:40:30.190 --> 00:40:32.550
what pan angle should I set it to.

00:40:32.720 --> 00:40:35.760
And here I'm sending it to my pan angle.

00:40:35.900 --> 00:40:37.520
What is my pan angle?

00:40:37.610 --> 00:40:39.380
Back here, it's one.

00:40:39.600 --> 00:40:43.460
So I'm saying, okay,
let's set the current pan

00:40:43.460 --> 00:40:46.650
angle to be one degree that

00:40:46.990 --> 00:40:51.870
Now the way I get this to auto spin is
by adding what's called a flags atom.

00:40:51.870 --> 00:40:54.380
And again, to go back,
you'll see the flags

00:40:54.490 --> 00:40:57.960
I'm adding are K action,
flag action is delta.

00:40:58.050 --> 00:41:02.920
That tells the movie controller,
when I said to set the pan angle to one,

00:41:03.020 --> 00:41:05.950
I didn't mean go to one in the panorama.

00:41:05.970 --> 00:41:09.420
I meant increment the
current pan angle by one.

00:41:09.600 --> 00:41:12.370
So again,
here with about 20 lines of code,

00:41:12.370 --> 00:41:14.260
I've built up a wired atom.

00:41:14.290 --> 00:41:21.140
I've attached it to my QuickTime VR movie
to get this dynamic auto spin behavior.

00:41:22.220 --> 00:41:26.520
Now one very nice feature of Wired
Atoms or Wired Actions is that

00:41:26.600 --> 00:41:32.560
I can target various things in
the movie to apply the action to.

00:41:32.800 --> 00:41:35.790
So every wired action has a
default target that depends

00:41:35.840 --> 00:41:37.600
on the kind of action it is.

00:41:37.730 --> 00:41:40.050
Set pan angle,
obviously the default target

00:41:40.200 --> 00:41:43.380
there is a QuickTime VR movie.

00:41:43.570 --> 00:41:47.930
It's possible though that I could target
some other object and I do that by adding

00:41:48.060 --> 00:41:55.500
a target atom to my wired atom that
specifies which other object to target.

00:41:55.560 --> 00:41:58.420
I can in fact even target
objects in another movie.

00:41:58.420 --> 00:42:01.790
Let's take a look at this.

00:42:07.920 --> 00:42:17.140
Now at the simplest level...
Why doesn't that want to open?

00:42:35.800 --> 00:42:42.390
"I'm going to open a sheet then
and open it in a real application."

00:42:45.310 --> 00:42:47.060
I don't know why
QuickTime Player doesn't want to open it,

00:42:47.060 --> 00:42:48.640
it just doesn't like that movie.

00:42:48.700 --> 00:42:50.720
But it is a valid QuickTime movie file.

00:42:50.720 --> 00:42:52.500
Here I have two sprites.

00:42:52.500 --> 00:42:56.290
When I click on one sprite,
the other sprite will rotate 90 degrees.

00:42:56.290 --> 00:42:59.690
You can see by clicking
on the right-hand sprite,

00:42:59.690 --> 00:43:02.220
the left-hand sprite is rotating.

00:43:02.710 --> 00:43:04.800
Similarly, I can click this guy.

00:43:04.800 --> 00:43:09.230
So each sprite is changing the
rotation of the other sprite.

00:43:13.400 --> 00:43:19.640
Let's take another example.

00:43:19.640 --> 00:43:22.740
Here's an example of
intermovie communication.

00:43:22.810 --> 00:43:26.450
So on this side,
I've got my ripple sprite.

00:43:26.660 --> 00:43:31.600
It's just a sprite with a
ripple effect applied to it.

00:43:31.630 --> 00:43:35.070
Over here, I've got another sprite,
and I've got it set up so

00:43:35.250 --> 00:43:38.180
that when I click on it,
the ripple sprite will

00:43:38.320 --> 00:43:40.280
disappear or come back.

00:43:40.350 --> 00:43:44.700
So here, messages are being sent from the
one movie to the other movie saying,

00:43:44.730 --> 00:43:47.890
yo, Sprite, change your visibility state.

00:43:48.560 --> 00:43:53.100
And let's take one final example
of intermovie communication.

00:43:53.140 --> 00:43:55.410
This is kind of a nice one.

00:43:59.270 --> 00:44:01.320
Here I've opened three movies.

00:44:01.420 --> 00:44:06.680
Two of them are QuickTime VR panoramas
showing the Donner Lake area in

00:44:06.680 --> 00:44:09.370
the winter and in the summer.

00:44:11.100 --> 00:44:37.720
And here I have a third movie
which is a sprite movie.

00:44:37.720 --> 00:44:37.720
It's got some controls in
it and when I roll over it,

00:44:37.720 --> 00:44:37.720
it's sending messages to each
of those panoramas saying,

00:44:37.720 --> 00:44:37.720
"Wouldn't you kindly
spin around?" And again,

00:44:37.720 --> 00:44:37.720
they do the right things here.

00:44:37.720 --> 00:44:37.720
I can zoom them both, zoom them both out.

00:44:37.720 --> 00:44:37.720
And if you want to get nauseated,
you can just run your controller,

00:44:37.720 --> 00:44:37.720
your mouse back and forth over this
and get a real nice earthquake effect.

00:44:39.470 --> 00:44:41.510
Okay.

00:44:41.510 --> 00:44:42.410
Back to slides, please.

00:44:42.410 --> 00:44:46.400
What do I need to do to support
intermovie communication?

00:44:46.400 --> 00:44:49.860
If you've got a QuickTime-savvy
application and you've never heard

00:44:49.860 --> 00:44:53.170
of intermovie communication before,
and you were to open those two

00:44:53.170 --> 00:44:55.990
movies or those three movies,
what you'd find is that

00:44:55.990 --> 00:44:57.450
they don't communicate.

00:44:57.530 --> 00:44:58.620
Why?

00:44:58.620 --> 00:45:01.950
Well,
the movie controller that's handling any

00:45:02.010 --> 00:45:07.620
of those movies needs some help from your
application to find the target movie.

00:45:07.640 --> 00:45:11.750
A movie controller really just knows
about the movie that it's attached to.

00:45:11.750 --> 00:45:15.910
It doesn't know that you have other
windows open that may contain movies.

00:45:16.030 --> 00:45:21.720
So what it does is say, okay,
I've got this wired action here.

00:45:21.720 --> 00:45:26.770
I want to tell the movie
summer.mov to change its pan angle,

00:45:26.770 --> 00:45:28.910
but I'm not summer.mov.

00:45:29.090 --> 00:45:31.780
I'm just some sprite movie.

00:45:31.780 --> 00:45:33.100
What does it do?

00:45:33.100 --> 00:45:37.360
It sends itself a movie
controller action.

00:45:37.870 --> 00:45:41.740
of type MC_action getExternalMovie.

00:45:41.780 --> 00:45:44.690
Because it knows that it's
not just out there by itself.

00:45:44.820 --> 00:45:46.940
It's got an application underneath.

00:45:47.150 --> 00:45:50.460
So it's essentially saying, look,
application, I need some help.

00:45:50.460 --> 00:45:53.700
I need you to tell me
where this movie is.

00:45:53.920 --> 00:45:57.390
So it's going to either ask for you
to give it a movie specified by a

00:45:57.430 --> 00:46:00.960
certain name or by a certain ID.

00:46:01.770 --> 00:46:05.470
Your job, when you get this
MC Action Get External Movie,

00:46:05.470 --> 00:46:09.100
is to go through your list of
open movies looking for the

00:46:09.160 --> 00:46:11.450
movie that it wants you to find.

00:46:11.610 --> 00:46:14.340
How do you get a movie's name or ID?

00:46:14.420 --> 00:46:18.260
This is stored in some movie user data.

00:46:18.260 --> 00:46:21.600
So your job is to look at each movie,
look at its user data,

00:46:21.680 --> 00:46:25.150
see if it has the appropriate
kind of user data that gives

00:46:25.150 --> 00:46:26.530
the movie a name or an ID.

00:46:26.600 --> 00:46:29.960
If you find it,
then you tell the movie controller,

00:46:29.960 --> 00:46:30.810
"I found it.

00:46:30.870 --> 00:46:34.020
Here's the movie you want
to send that message to."

00:46:34.400 --> 00:46:37.660
QuickTime 5 introduced a couple
other movie controller actions that

00:46:37.720 --> 00:46:42.580
you should consider supporting,
namely Get Movie Name and Get Movie ID.

00:46:42.580 --> 00:46:45.150
And these are where a
movie controller says,

00:46:45.150 --> 00:46:46.790
what's my name?

00:46:46.880 --> 00:46:50.200
And it needs help from you again
to look at the movie user data

00:46:50.210 --> 00:46:54.080
attached to the movie to figure
out what the movie's name or ID is.

00:46:55.770 --> 00:46:59.130
So again, if you want to be really good,
interactive, smart with your application,

00:46:59.190 --> 00:47:02.990
support these three
movie controller actions,

00:47:02.990 --> 00:47:06.540
and you will have thereby
enabled intermovie communication.

00:47:08.200 --> 00:47:10.070
Now let's talk about
application messages.

00:47:10.180 --> 00:47:14.060
We saw a couple examples of that earlier,
namely where the QuickTime movie

00:47:14.400 --> 00:47:18.480
or the Sprite movie were sending
messages to the application saying,

00:47:18.480 --> 00:47:21.140
I'd really like to go full screen.

00:47:21.540 --> 00:47:25.760
So before we had movies
talking amongst themselves,

00:47:25.760 --> 00:47:29.070
now we have movies talking
to the application,

00:47:29.070 --> 00:47:31.310
telling it to do things.

00:47:31.570 --> 00:47:34.700
So application messages provide
a way for interactive media to

00:47:34.820 --> 00:47:37.600
communicate with the application.

00:47:37.620 --> 00:47:39.910
Again, there are two types of
application messages,

00:47:40.080 --> 00:47:45.120
what I call QuickTime application
messages and Flash application messages.

00:47:45.380 --> 00:47:48.130
QuickTime application messages
were introduced fairly

00:47:48.170 --> 00:47:50.990
recently in QuickTime 5.

00:47:51.750 --> 00:47:55.200
And the way you generate one of these,
or one way to generate one,

00:47:55.200 --> 00:48:00.100
is by using a wired action
of type KactionSendAtMessage.

00:48:00.200 --> 00:48:02.640
So for instance,
when I click on a button,

00:48:02.640 --> 00:48:09.270
that could execute the action,
send this application

00:48:09.280 --> 00:48:11.840
message to the application.

00:48:11.870 --> 00:48:18.370
And the parameter there would specify
which message you want to send.

00:48:18.730 --> 00:48:22.940
When the movie controller
gets that request,

00:48:22.970 --> 00:48:26.820
it says, "Okay, I'll send this to the
application." How does it do it?

00:48:26.940 --> 00:48:31.400
It sends the MCActionFilter
proc an action of type

00:48:31.530 --> 00:48:35.130
MCActionAppMessageReceived,
saying, "Look, I just got this message.

00:48:35.130 --> 00:48:39.050
Would you like to do
anything in response to that

00:48:39.270 --> 00:48:44.210
Now QuickTime defines five messages
of which three are useful to us,

00:48:44.210 --> 00:48:46.990
but you can in fact define
your own custom messages.

00:48:47.020 --> 00:48:50.200
So this would be a way for you to
create some interactive content

00:48:50.710 --> 00:48:54.810
that communicated with your
application to do special things.

00:48:55.490 --> 00:48:59.960
These are the three messages that
I think we all should be handling,

00:48:59.990 --> 00:49:04.200
namely enter full screen requested,
exit full screen requested,

00:49:04.250 --> 00:49:05.690
and close window requested.

00:49:05.820 --> 00:49:09.640
So you could get a message that
says I want to go full screen,

00:49:09.640 --> 00:49:14.610
or I'd really like to exit full screen,
or wouldn't you really like to

00:49:14.610 --> 00:49:17.470
close the window that contains me?

00:49:17.940 --> 00:49:20.060
Now you'll notice that I have
a comment here that says,

00:49:20.060 --> 00:49:20.900
be careful here.

00:49:20.900 --> 00:49:25.140
And I say that because at one
point I wasn't careful here

00:49:25.230 --> 00:49:26.690
and it led to bad things.

00:49:26.690 --> 00:49:28.260
How wasn't I careful?

00:49:28.260 --> 00:49:31.070
Well, I thought, okay,
I'm going to get this window

00:49:31.070 --> 00:49:32.710
close requested message.

00:49:32.710 --> 00:49:35.330
I know how to close a window, right?

00:49:35.400 --> 00:49:38.480
I handle the close item in the file menu.

00:49:38.480 --> 00:49:41.840
I'll just call the same function
I call there right here,

00:49:41.940 --> 00:49:42.580
right?

00:49:42.810 --> 00:49:43.550
Doesn't that make sense?

00:49:43.550 --> 00:49:46.130
Well, to me it made sense.

00:49:46.200 --> 00:49:51.570
The trouble was the function that
closes a window did a couple of things.

00:49:51.570 --> 00:49:56.720
First, it looked to see whether the
data in the window had changed.

00:49:56.720 --> 00:49:59.710
If so, it would put up a nice
dialogue to the user saying,

00:49:59.750 --> 00:50:02.990
do you want to change or save
these changes or discard them?

00:50:02.990 --> 00:50:06.990
When that was done, it would then get rid
of the movie controller,

00:50:06.990 --> 00:50:09.820
the movie,
and finally destroy the window.

00:50:11.310 --> 00:50:13.120
Well, I have some news for you.

00:50:13.180 --> 00:50:16.120
Destroying a movie controller
inside a movie controller action

00:50:16.280 --> 00:50:19.340
filter procedure is not a good idea.

00:50:19.410 --> 00:50:22.000
You will crash fairly immediately
if you try to do that.

00:50:22.190 --> 00:50:26.620
So, be careful there.

00:50:26.950 --> 00:50:30.660
So let's look at a
QuickTime application message demo.

00:50:30.700 --> 00:50:32.810
Back to Demos.

00:50:41.500 --> 00:50:47.040
Here is a simple one.

00:50:47.110 --> 00:50:49.340
Here again is a text movie.

00:50:49.360 --> 00:50:53.480
Again,
I've wired up several stretches of text.

00:50:53.690 --> 00:50:57.810
In particular,
the Apple here is wired to send the

00:50:57.990 --> 00:51:01.540
close window message to the application.

00:51:01.550 --> 00:51:04.740
And so when I click there,
the window goes away.

00:51:04.770 --> 00:51:10.000
And I didn't crash because I was
careful in my MC Action Filter proc.

00:51:10.010 --> 00:51:13.910
Let's open a couple of movies here.

00:51:16.100 --> 00:51:21.220
Now I'm going to, this movie on the right
here is a Flash movie again,

00:51:21.220 --> 00:51:24.860
and I have got it wired to

00:51:27.960 --> 00:51:34.190
send a message to the application
that did this little earthquake thing.

00:51:34.190 --> 00:51:34.190
Let's do that again.

00:51:34.570 --> 00:51:37.480
You'll notice that the windows
themselves are moving around,

00:51:37.580 --> 00:51:38.420
right?

00:51:38.590 --> 00:51:41.740
That's something that the
application has to do.

00:51:41.800 --> 00:51:43.520
That can't happen from within QuickTime.

00:51:43.730 --> 00:51:49.880
So this was a very nice use of sending
a custom application message from the

00:51:49.880 --> 00:51:54.480
Flash movie to the application saying,
let's do all this window

00:51:54.480 --> 00:51:56.090
jiggling and play a sound.

00:52:00.400 --> 00:52:06.660
Actually, if we play this thing full
screen and then kick it off,

00:52:06.690 --> 00:52:09.450
that's kind of cool.

00:52:15.700 --> 00:52:23.800
[Transcript missing]

00:52:26.550 --> 00:52:29.400
So actually these application
messages are very powerful.

00:52:29.400 --> 00:52:32.500
We have some predefined
application messages,

00:52:32.560 --> 00:52:38.850
but you can define your own custom ones
to modify your application's behavior.

00:52:41.150 --> 00:52:50.250
So, Flash application messages are
emitted when you have an action

00:52:50.250 --> 00:52:50.250
script that has the FS command in it.

00:52:50.730 --> 00:52:55.620
When the Flash Media Handler
gets an FS command to execute,

00:52:55.750 --> 00:52:59.900
it sends to our
MovieControllerActionFilter proc

00:52:59.950 --> 00:53:03.050
an action of type MCActionDoScript.

00:53:03.740 --> 00:53:08.450
Associated with this action are
two text strings that I can look

00:53:08.450 --> 00:53:11.280
at to see how to interpret the
action or indeed what it is.

00:53:11.420 --> 00:53:16.910
So once again in our MCActionFilter proc,
I see that I am receiving an

00:53:16.910 --> 00:53:21.230
action of type MCActionDoScript,
and I will call my application

00:53:21.540 --> 00:53:23.640
function mydofs command.

00:53:23.640 --> 00:53:25.330
What does that look like?

00:53:25.430 --> 00:53:26.380
It's fairly simple.

00:53:26.380 --> 00:53:30.570
I just look at the command and the
arguments that are passed to me,

00:53:30.960 --> 00:53:34.160
and if I get full screen,
I'll call myEnterFullScreen.

00:53:34.160 --> 00:53:37.260
If I get full screen set to false,
I'll exit full screen.

00:53:37.260 --> 00:53:39.420
Very straightforward.

00:53:41.400 --> 00:53:44.640
Uh... actually we already demoed
the Flash application message,

00:53:44.840 --> 00:53:45.030
right?

00:53:45.150 --> 00:53:48.270
When I clicked the Flash button,
it sent a message to

00:53:48.380 --> 00:53:52.620
my application saying,
"Let's shake all those windows around."

00:53:53.870 --> 00:53:58.410
Okay,
now we're back with interactive genius.

00:53:58.660 --> 00:54:02.120
Recall that I needed to do two
things to be an interactive genius:

00:54:02.320 --> 00:54:06.620
support skin movies,
and the second one was support

00:54:06.620 --> 00:54:09.860
a flash contextual pop-up menu.

00:54:10.260 --> 00:54:12.940
We've seen many examples
of skin movies today,

00:54:13.090 --> 00:54:15.960
and fundamentally,
a skin movie is simply a movie

00:54:15.960 --> 00:54:18.390
with a custom window shape.

00:54:19.420 --> 00:54:23.960
Now, if you want to be able
to open skinned movies,

00:54:24.270 --> 00:54:26.880
you need some special
code in your application.

00:54:27.070 --> 00:54:29.300
This is not something
that QuickTime can handle.

00:54:29.390 --> 00:54:32.920
It really knows nothing about the kind
of window that the movie is displayed in.

00:54:33.010 --> 00:54:36.110
It needs help from your
application to do that.

00:54:36.330 --> 00:54:37.460
How do we do that?

00:54:37.560 --> 00:54:40.840
Well, I'll give you sort of the
beginnings of what you need to do,

00:54:40.920 --> 00:54:43.870
because, of course,
how you draw and shape a window

00:54:43.870 --> 00:54:47.580
depends on what development
environment you're using.

00:54:48.210 --> 00:54:53.250
In any case, what we need to do is first
get information about what

00:54:53.250 --> 00:54:56.220
shape this window should be.

00:54:56.390 --> 00:55:02.300
I can do that by seeing if there's a
skin track associated with the movie.

00:55:02.300 --> 00:55:10.750
So I'll call getMovieInTrackType and
look for a skin track or actually a skin

00:55:10.870 --> 00:55:14.530
with the movie track characteristic.

00:55:15.000 --> 00:55:18.220
If I find a track that
has skin data in it,

00:55:18.220 --> 00:55:24.520
I want to get the track media
and also the track media handler.

00:55:25.020 --> 00:55:29.700
QuickTime 5 introduced a new function
called Media Get Public Info.

00:55:29.740 --> 00:55:33.480
And so to get the content
region of the window,

00:55:33.480 --> 00:55:37.780
I will call it with the
four-character code SKCR.

00:55:37.780 --> 00:55:41.460
To get the drag region,
I'll call it with SKDR.

00:55:41.460 --> 00:55:45.140
So at this point,
I have the shapes that my window

00:55:45.140 --> 00:55:48.770
is supposed to be in by making
these very simple QuickTime calls.

00:55:48.820 --> 00:55:53.020
How I then use that information,
as I say, is platform-dependent.

00:55:53.640 --> 00:55:57.220
Windows has a function
called SetWindowRegion that

00:55:57.220 --> 00:55:59.140
is very simple to call.

00:55:59.140 --> 00:56:01.170
I give it a region that
has that shape in it,

00:56:01.180 --> 00:56:03.300
and it will draw the
window in that shape.

00:56:03.380 --> 00:56:08.410
Carbon has similar capabilities,
and so does Cocoa.

00:56:10.790 --> 00:56:15.670
Now how do I support the
Flash contextual pop-up menu?

00:56:15.840 --> 00:56:19.290
The easiest way to do it,
again inside my MC Action filter prop,

00:56:19.400 --> 00:56:23.700
is to look for an action of
type MC Action Mouse Down.

00:56:24.000 --> 00:56:27.360
When I do that,
and if the Control key is down,

00:56:27.370 --> 00:56:32.170
I'll call my special application
function that pops up the menu,

00:56:32.170 --> 00:56:35.780
tracks it,
and does the appropriate things.

00:56:36.760 --> 00:56:40.980
So let's summarize a bit.

00:56:41.250 --> 00:56:44.840
If you have an application that
supports QuickTime movies and

00:56:44.840 --> 00:56:48.000
you'd like to be able to handle
all these interactive behaviors,

00:56:48.090 --> 00:56:49.270
you need to do these things.

00:56:49.270 --> 00:56:52.200
Use a movie controller,
that's a given really.

00:56:52.200 --> 00:56:55.960
Support intermovie communication,
that's fairly straightforward,

00:56:55.960 --> 00:56:59.200
it just means iterating through
your windows to look for movies

00:56:59.220 --> 00:57:01.140
that have a specified name or ID.

00:57:01.140 --> 00:57:04.240
Support the key up event,
no matter how useless

00:57:04.240 --> 00:57:05.670
you may think it is.

00:57:06.220 --> 00:57:11.150
Flash doesn't think it's useless,
so please get it and hand

00:57:11.150 --> 00:57:13.840
it to the movie controller.

00:57:13.840 --> 00:57:16.880
Handle application messages,
we've seen how to do that either

00:57:16.880 --> 00:57:21.500
with Flash application messages or
with QuickTime application messages.

00:57:21.760 --> 00:57:24.610
Support skinned movies,
that's a little more complicated

00:57:24.610 --> 00:57:26.610
but it's fairly straightforward.

00:57:26.720 --> 00:57:28.520
And finally,
support full screen playback.

00:57:28.520 --> 00:57:32.360
If you do all of these things,
your application will be up

00:57:32.360 --> 00:57:34.260
there at the genius level.

00:57:34.330 --> 00:57:37.870
People will not be amazed
at how little you can do,

00:57:37.870 --> 00:57:40.590
but amazed by how much you can do.

00:57:41.640 --> 00:57:48.020
Okay, let's reflect for a moment
at what we've learned today.

00:57:48.510 --> 00:57:55.150
One thing we've seen is that we can
use QuickTime's APIs to embed various

00:57:55.150 --> 00:57:58.950
interactive behaviors in our application.

00:57:58.990 --> 00:58:01.710
That is to say,
to have our application support

00:58:01.830 --> 00:58:06.980
various interactive behaviors such as
auto-spinning the VR movie or doing the

00:58:07.140 --> 00:58:10.730
earthquake when I press the flash button.

00:58:11.020 --> 00:58:13.950
The downside of that, again,
is that for people to get these

00:58:13.950 --> 00:58:17.020
special interactive behaviors,
they need my special application.

00:58:18.840 --> 00:58:23.950
So one thing that you can consider
doing is to export these interactive

00:58:24.000 --> 00:58:25.920
behaviors as wired actions.

00:58:26.110 --> 00:58:30.240
That is to say, take the intelligence out
of your application and put

00:58:30.420 --> 00:58:32.710
it into the movie itself.

00:58:32.710 --> 00:58:35.830
That way these wonderful behaviors
can be available everywhere

00:58:36.410 --> 00:58:38.020
that movie is played back.

00:58:39.800 --> 00:58:42.180
Now I've seen several applications
that are really quite good at putting

00:58:42.180 --> 00:58:46.040
together multimedia presentations,
but they require a special

00:58:46.040 --> 00:58:49.640
playback application to
play back that presentation.

00:58:50.380 --> 00:58:54.070
And in virtually all the cases I've seen,
the kinds of interactivity

00:58:54.070 --> 00:58:57.300
that they're using could easily
be moved from the playback

00:58:57.300 --> 00:58:59.560
application into the movie itself.

00:59:00.240 --> 00:59:04.080
So that I think is a very good thing
to try to do if you have one of these

00:59:04.200 --> 00:59:08.720
applications that allows people to
author dynamic interactive media.

00:59:08.740 --> 00:59:09.960
Thank you.

00:59:10.830 --> 00:59:15.790
Second possibility here, as we've seen,
we can have the movies send

00:59:15.790 --> 00:59:17.720
messages to your application.

00:59:17.840 --> 00:59:22.340
Flash can do it and wired
QuickTime tracks can do it.

00:59:22.420 --> 00:59:25.640
Well, this raises a very
interesting possibility.

00:59:25.640 --> 00:59:29.800
You could have a QuickTime movie
be the primary user interface

00:59:29.800 --> 00:59:31.500
for your application.

00:59:31.560 --> 00:59:35.610
One of the least fun things
about programming on various

00:59:35.610 --> 00:59:40.480
platforms is getting the UI looking
just right on each platform.

00:59:40.700 --> 00:59:46.200
One very nice way around that problem
is to create a QuickTime movie that has

00:59:46.200 --> 00:59:50.310
got buttons or pop-up menus or whatever,
text input fields,

00:59:50.380 --> 00:59:54.170
all the things that your application
needs to get information from the user,

00:59:54.260 --> 00:59:57.910
have that movie be the front
end for your application.

00:59:58.120 --> 01:00:02.920
The advantage there is that the UI is
going to be the same on whatever

01:00:02.960 --> 01:00:05.930
platform this movie is played back on.

01:00:07.300 --> 01:00:12.300
And that's pretty much
what I have to say today.

01:00:12.300 --> 01:00:13.630
Well, these we've all seen.

01:00:13.850 --> 01:00:15.540
No point in looking at that.

01:00:15.610 --> 01:00:19.320
There are three upcoming sessions that
I think will be interesting to you.

01:00:19.370 --> 01:00:22.040
There's a feedback
forum coming on Friday.

01:00:22.090 --> 01:00:24.630
There's a very good session,
QuickTime for the web.

01:00:24.810 --> 01:00:27.930
If you're interested in QuickTime and
how it works within browsers,

01:00:27.990 --> 01:00:30.540
that would be an excellent
session to go to.

01:00:30.620 --> 01:00:35.070
And also we have a technical
overview of MPEG-4.

01:00:35.680 --> 01:00:41.240
For more information about all this,
you can go to the website where we

01:00:41.630 --> 01:00:44.820
have a large set of documentation.

01:00:44.820 --> 01:00:50.810
Two other places that I especially
like are www.blueabuse.com.

01:00:50.810 --> 01:00:53.340
This is put together by
the Totally Hip People.

01:00:53.340 --> 01:00:56.660
It's a very nice resource
for interactive QuickTime.

01:00:57.580 --> 01:01:00.090
Another location I want to
mention is Mac Tech Magazine.

01:01:00.090 --> 01:01:02.890
In the past couple of years,
they've been publishing a lot

01:01:02.940 --> 01:01:06.320
of articles about QuickTime,
which I think will be very useful.

01:01:07.820 --> 01:01:11.370
And sample code,
basically everything I've shown

01:01:11.370 --> 01:01:16.280
you today is using off-the-shelf
sample code applications or minor

01:01:16.280 --> 01:01:18.180
modifications of that sample code.

01:01:18.200 --> 01:01:22.530
So there's nothing I've done here
now that you can't do in the privacy

01:01:22.530 --> 01:01:26.530
of your own home using sample code
that is available now on the web.

01:01:26.600 --> 01:01:30.120
The one caveat, as I said earlier,
is that the skin sample code

01:01:30.210 --> 01:01:33.160
is slightly out of date,
and within the next week or so

01:01:33.290 --> 01:01:36.660
it should be updated to give you
just the behaviors you saw there.

01:01:38.240 --> 01:01:40.420
And finally,
let me remind you that this week

01:01:40.520 --> 01:01:43.700
you have a very special opportunity
to sit down with members of

01:01:43.710 --> 01:01:47.480
the QuickTime engineering team,
bringing in your code problems

01:01:47.480 --> 01:01:51.020
and having us hopefully solve them
or at least give you some insight

01:01:51.020 --> 01:01:52.720
as to how you might approach it.

01:01:52.840 --> 01:01:55.170
And that's what I've got to say.

01:01:55.180 --> 01:01:56.300
Thank you very much.
WEBVTT

00:00:12.320 --> 00:00:14.930
Thank you very much.

00:00:14.960 --> 00:00:19.160
I'd like to thank all of you for
taking the Advil this morning after

00:00:19.160 --> 00:00:23.740
the beer bash and coming on out to
hear our quick time for Java talk.

00:00:23.740 --> 00:00:27.080
We have some exciting new
features that we're going to be

00:00:27.240 --> 00:00:29.530
showing tonight or this morning,
excuse me.

00:00:29.530 --> 00:00:31.490
I think it's still last night.

00:00:31.520 --> 00:00:36.240
We're also going to have Anat come up a
little bit later to show you how to do

00:00:36.240 --> 00:00:42.110
some optimization on your code and to
use some programming methods for some

00:00:42.330 --> 00:00:48.530
topics that are maybe somewhat less
understood or a little bit confusing.

00:00:48.540 --> 00:00:50.580
We'll be showing that a little bit later.

00:00:50.580 --> 00:00:53.290
Before I begin,
I'd like to start off by displaying

00:00:53.300 --> 00:00:57.080
our names because I'm an egomaniac.

00:00:57.080 --> 00:01:00.690
We're going to start out just summarizing
what QuickTime for Java is before

00:01:01.220 --> 00:01:04.500
we go into some of the new features.

00:01:04.500 --> 00:01:05.220
So we're going to start off by showing
you some of the new features that

00:01:05.220 --> 00:01:05.280
we're going to be showing tonight.

00:01:05.280 --> 00:01:05.280
We're going to start off by showing
you some of the new features that

00:01:05.280 --> 00:01:05.280
we're going to be showing tonight.

00:01:05.280 --> 00:01:05.300
So we're going to start off by showing
you some of the new features that

00:01:05.300 --> 00:01:05.300
we're going to be showing tonight.

00:01:05.300 --> 00:01:05.300
So we're going to start off by showing
you some of the new features that

00:01:05.300 --> 00:01:05.300
we're going to be showing tonight.

00:01:05.390 --> 00:01:09.300
QuickTime for Java is really based
on two separate technologies.

00:01:09.300 --> 00:01:12.190
There's QuickTime, of course,
most of you here are

00:01:12.300 --> 00:01:13.700
probably familiar with.

00:01:13.700 --> 00:01:19.640
It's a mature cross-platform flexible
media framework that provides a number of

00:01:19.840 --> 00:01:25.660
services that allow you to play movies,
play sounds, do virtual reality,

00:01:25.660 --> 00:01:27.300
things like that.

00:01:27.360 --> 00:01:32.480
And it's also based upon Java,
which is Sun Microsystems' fully featured

00:01:32.480 --> 00:01:35.260
modern object-oriented language feature.

00:01:35.260 --> 00:01:39.250
So it's featuring garbage collection,
the ability to deploy

00:01:39.250 --> 00:01:43.710
your applet in a browser,
or to use the new Web Start features

00:01:43.720 --> 00:01:45.760
that were brought to Java.

00:01:45.760 --> 00:01:49.010
And you can also make use
of those features with your

00:01:49.010 --> 00:01:50.640
QuickTime for Java application.

00:01:50.640 --> 00:01:55.190
And the biggest key here is the
ability to deploy your application

00:01:55.300 --> 00:01:56.720
in a cross-platform manner.

00:01:56.720 --> 00:02:01.770
So what is it that QuickTime for
Java that's based on these

00:02:01.870 --> 00:02:03.740
two technologies include?

00:02:03.990 --> 00:02:06.810
Well, first of all, it's a very powerful,
as I mentioned,

00:02:06.810 --> 00:02:11.340
it's cross-platform Java class library
that allows you to access the native

00:02:11.550 --> 00:02:14.370
QuickTime runtime on your platform.

00:02:14.390 --> 00:02:17.400
And it provides two
different types of services.

00:02:17.400 --> 00:02:20.080
And the first,
and perhaps most primitive,

00:02:20.080 --> 00:02:26.010
is the presentation of QuickTime C APIs,
so that from your Java applet or

00:02:26.010 --> 00:02:29.820
application or Web Start application,
you can call the

00:02:29.820 --> 00:02:33.320
QuickTime C APIs directly.

00:02:33.320 --> 00:02:35.220
And we've organized
these in an obvious way,

00:02:35.220 --> 00:02:37.690
and we've done a lot of work
on the Web Start application.

00:02:37.780 --> 00:02:41.580
And we've also done a lot of work
on the Web Start application.

00:02:41.580 --> 00:02:45.000
We've done a lot of work on
the Web Start application.

00:02:45.000 --> 00:02:48.960
And we've done a lot of work
on the Web Start application,

00:02:48.960 --> 00:02:52.960
and we've done a lot of work
on the Web Start application.

00:02:52.960 --> 00:02:56.530
And we've also done a lot of work
on the Web Start application,

00:02:56.580 --> 00:03:01.400
and we've done a lot of work
on the Web Start application.

00:03:01.470 --> 00:03:06.190
And then we've also done a lot of
work on the Web Start application.

00:03:06.200 --> 00:03:12.200
And we've also done a lot of work
on the Web Start application.

00:03:12.200 --> 00:03:18.430
So, we've done a lot of work on
the Web Start application.

00:03:18.770 --> 00:03:22.700
And we've also done a lot of work
on the Web Start application.

00:03:22.790 --> 00:03:24.800
And we've also done a lot of work
on the Web Start application.

00:03:24.800 --> 00:03:29.790
And we've also done a lot of work
on the Web Start application.

00:03:29.800 --> 00:03:34.790
And we've also done a lot of work
on the Web Start application.

00:03:34.790 --> 00:03:34.790
And we've also done a lot
of work on the Web Start

00:03:35.490 --> 00:03:37.550
Okay,
so let's talk about what platforms are

00:03:37.580 --> 00:03:39.640
available to you as a Java developer.

00:03:39.640 --> 00:03:43.870
We support Mac OS,
and we're referring there specifically

00:03:43.950 --> 00:03:47.020
to the classic Mac OS 9 runtime.

00:03:47.020 --> 00:03:50.400
That requires MRJ 2.1 and above.

00:03:50.400 --> 00:03:55.470
We also work on Windows,
and that's all the slew of NT,

00:03:55.470 --> 00:03:59.650
Windows 98, Windows 2000.

00:03:59.660 --> 00:04:03.460
All those we support,
as long as you have a Sun-compatible GRE.

00:04:04.300 --> 00:04:08.800
And we also are bundled on Mac OS X using
the Java 2 Standard Edition.

00:04:08.800 --> 00:04:12.110
And the great thing about that
platform is that everything's

00:04:12.110 --> 00:04:14.770
pre-installed for you,
so your users don't have to

00:04:14.770 --> 00:04:18.640
install any additional software,
and you as a developer can depend on

00:04:18.640 --> 00:04:20.760
those services being available to you.

00:04:22.660 --> 00:04:26.130
So let's talk about now some of
the new features that are available

00:04:26.240 --> 00:04:29.840
with QuickTime for Java that
are provided by QuickTime 6.

00:04:29.840 --> 00:04:32.880
For those of you that have been
to previous QuickTime sessions,

00:04:32.880 --> 00:04:36.210
you may have heard all this buzz
around MPEG-4 and the new video

00:04:36.350 --> 00:04:38.940
features that are brought by that.

00:04:38.940 --> 00:04:41.370
Additionally,
we've added support for new idle

00:04:41.370 --> 00:04:47.340
manager routine that we're going to
be talking about in later slides.

00:04:47.400 --> 00:04:50.230
But in addition to the
new 6 functionality,

00:04:50.240 --> 00:04:54.820
we still have complete coverage
of the QuickTime 4 and 5 APIs,

00:04:54.820 --> 00:04:58.160
as well as some additional
functionality and services.

00:04:58.160 --> 00:05:03.560
And new in this release is support
on Windows for the JDK 1.4.

00:05:03.600 --> 00:05:08.420
So those of you that are in that space
can now transparently use 1.4 without

00:05:08.420 --> 00:05:11.240
any additional changes to your code.

00:05:11.300 --> 00:05:13.350
So that's a nice feature.

00:05:13.830 --> 00:05:18.710
Okay,
continuing on in the new feature space

00:05:18.860 --> 00:05:23.430
is a new manager called the idle manager.

00:05:23.440 --> 00:05:27.740
And what exactly does this
allow you to do as a developer?

00:05:27.840 --> 00:05:31.920
Before I go into that,
I'd actually kind of like to summarize

00:05:31.920 --> 00:05:35.600
the way things used to work before
this idle manager was introduced,

00:05:35.600 --> 00:05:39.640
so that you can understand the
need for that new technology.

00:05:40.970 --> 00:05:45.370
Previously in QuickTime,
applications that used QuickTime needed

00:05:45.370 --> 00:05:49.740
to call a number of calls,
such as MCIsPlayerEvent to determine

00:05:49.770 --> 00:05:55.800
if a specific event coming in on the
event loop is for the QuickTime player,

00:05:55.800 --> 00:06:01.020
or MCIdle to allow QuickTime to have
some idle time to perform tasks such

00:06:01.020 --> 00:06:06.320
as decompression or display of videos,
and movies, tasks, and task media.

00:06:06.320 --> 00:06:10.820
And these calls were required to
be called on a periodic basis.

00:06:10.840 --> 00:06:15.830
But the problem is that the
developer doesn't necessarily know

00:06:15.830 --> 00:06:24.080
how frequently these calls need to
be called in order to provide enough

00:06:24.200 --> 00:06:25.720
time for QuickTime to do its work.

00:06:25.720 --> 00:06:29.700
And I'd also like to point out that
for QuickTime for Java developers,

00:06:29.700 --> 00:06:33.480
occasionally these calls may
be called implicitly for you,

00:06:33.480 --> 00:06:35.580
so you might not even realize
that they're being called

00:06:35.700 --> 00:06:36.630
for you on your behalf.

00:06:36.730 --> 00:06:41.030
So there was a lot of confusion here,
since it was difficult... for

00:06:41.030 --> 00:06:45.080
the developer to determine how
often QuickTime needed time

00:06:45.310 --> 00:06:46.920
to perform its operations.

00:06:46.920 --> 00:06:52.400
So this is especially true in the case
of a movie where you have a wired sprite,

00:06:52.400 --> 00:06:56.930
and the rate of the movie could be zero,
yet, for example,

00:06:56.940 --> 00:07:00.030
if you had a fire effect that's
still animating even when the

00:07:00.030 --> 00:07:01.250
rate of the movie is zero.

00:07:01.360 --> 00:07:04.290
So you couldn't depend on
the rate to determine if you

00:07:04.290 --> 00:07:05.840
needed to make these calls.

00:07:05.840 --> 00:07:11.940
And so most developers would just pick
some delay time that seems reasonable,

00:07:11.940 --> 00:07:14.580
and just call that routine,
those routines,

00:07:14.580 --> 00:07:16.060
over and over and over again.

00:07:16.180 --> 00:07:21.170
And this is a problem,
primarily because it's wasteful.

00:07:21.710 --> 00:07:26.300
There'd be a lot of cases when
you'd call the idle routines,

00:07:26.490 --> 00:07:29.740
and QuickTime wouldn't really
need the time to do any work,

00:07:29.770 --> 00:07:35.170
so it would just sit there and you'd
be wasting valuable CPU processor time.

00:07:36.820 --> 00:07:42.260
So in order to allay these problems,
we've introduced a new idle manager API.

00:07:42.260 --> 00:07:46.230
And the whole purpose of this is
that you no longer have to look

00:07:46.260 --> 00:07:49.880
into your crystal ball and say,
oh, when does QuickTime need time?

00:07:49.880 --> 00:07:52.750
You can actually request
that from QuickTime.

00:07:52.750 --> 00:07:53.880
Brilliant idea.

00:07:54.440 --> 00:07:58.340
So what you do in QuickTime for
Java is from your movie object

00:07:58.440 --> 00:08:02.640
you call getTimeUntilNextTask and
specify the scale that you wish

00:08:02.640 --> 00:08:04.560
that time to be delivered in.

00:08:04.560 --> 00:08:07.100
And you'd get a delay return to you.

00:08:08.910 --> 00:08:12.610
And this allows you to determine exactly
when the next time QuickTime thinks

00:08:12.610 --> 00:08:14.300
that it needs processing time.

00:08:14.300 --> 00:08:18.210
If you wanted to, say,
in your movies task,

00:08:18.600 --> 00:08:23.320
specify that same interval,
you then call taskAll with the delay that

00:08:23.390 --> 00:08:25.540
was returned to you by the idle manager.

00:08:25.540 --> 00:08:28.880
And then the tasker object
will use that new delay value.

00:08:30.120 --> 00:08:36.610
There's also a mechanism whereby you
can register a callback with QuickTime,

00:08:36.610 --> 00:08:40.020
and that's called the next
task needed sooner callback.

00:08:40.020 --> 00:08:43.940
And the way that works is
you can tell QuickTime...

00:08:45.390 --> 00:08:49.150
Okay, I know that you told me that
you didn't need any time for

00:08:49.250 --> 00:08:51.500
the next five milliseconds,
but if you do,

00:08:51.500 --> 00:08:56.120
here's this routine that you can call
to notify me that something came up,

00:08:56.220 --> 00:08:58.810
you made a mistake,
and you need time more quickly

00:08:58.810 --> 00:09:00.840
than you last reported to me.

00:09:00.840 --> 00:09:04.500
So in order to set up that callback,
you implement the next

00:09:04.500 --> 00:09:09.300
time-needed-sooner interface and
override the public execute method.

00:09:11.210 --> 00:09:14.030
So a little bit more detail
about how that callback works.

00:09:14.030 --> 00:09:19.570
To install a callback,
you call setNextPathNeededSoonerCallback,

00:09:19.570 --> 00:09:24.870
say that five times fast,
and pass in your class that

00:09:24.870 --> 00:09:29.480
implements that interface into it.

00:09:29.760 --> 00:09:33.260
When QuickTime decides that
it needs additional time,

00:09:33.360 --> 00:09:36.340
for example,
if a network operation happened or

00:09:36.340 --> 00:09:41.830
if there was some kind of a callback
within that movie that fired,

00:09:41.830 --> 00:09:47.090
and QuickTime decides, oh my god,
I need time more soon or sooner

00:09:47.100 --> 00:09:52.260
than I previously reported,
it will go ahead and call

00:09:52.330 --> 00:09:54.420
your callback for you.

00:09:54.910 --> 00:09:56.640
and your execute method.

00:09:56.640 --> 00:10:01.800
So to remove that same callback,
you call removeNextTaskNeededSooner

00:10:01.800 --> 00:10:04.520
callback with the same callback.

00:10:04.520 --> 00:10:07.790
And since you're specifying
a callback in that routine,

00:10:07.790 --> 00:10:11.800
it's important to note that you
don't have to have just one callback.

00:10:11.800 --> 00:10:15.590
You can install as many
of those as you want.

00:10:16.150 --> 00:10:19.610
Okay, so now that we've talked
a little bit about that,

00:10:19.610 --> 00:10:23.190
I'd like to talk about some
additional new features supported in

00:10:23.200 --> 00:10:25.240
QuickTime for Java with QuickTime 6.

00:10:25.260 --> 00:10:28.060
And that's primarily support for Flash 5.

00:10:28.260 --> 00:10:28.640
Yay!

00:10:28.640 --> 00:10:33.210
A lot of people were complaining
because there were some new... Yeah,

00:10:33.210 --> 00:10:34.970
Ant over there,
he's just doing flips right

00:10:35.140 --> 00:10:36.420
now because he loves Flash.

00:10:36.500 --> 00:10:41.800
It enhances the action
syrup capabilities of Flash,

00:10:41.990 --> 00:10:45.750
provides HTML text rendering,
XML data exchange,

00:10:46.100 --> 00:10:49.200
and all sorts of other features
that people were clamoring about,

00:10:49.200 --> 00:10:50.680
so we put it into QuickTime.

00:10:50.680 --> 00:10:53.900
Additionally,
in QuickTime 6 is support for

00:10:53.900 --> 00:10:56.700
variable bitrate sound compression.

00:10:56.730 --> 00:11:02.780
Previously, you could play back a sound
that used VBR compression,

00:11:02.780 --> 00:11:04.500
but you couldn't actually encode one.

00:11:04.500 --> 00:11:05.580
Well, now you can.

00:11:08.140 --> 00:11:12.920
Okay, so another brand new feature that
people have been clamoring about

00:11:12.920 --> 00:11:17.500
a lot is support for QuickTime for
Java in a swing-based component.

00:11:17.500 --> 00:11:20.420
So I'd like to talk about
that a little bit now.

00:11:20.420 --> 00:11:25.160
What we've done is we've
added a new component.

00:11:25.160 --> 00:11:28.990
And the reason for this is
that our previous component,

00:11:28.990 --> 00:11:31.290
QTCanvas, was heavyweight.

00:11:31.300 --> 00:11:36.040
And incorporating this into a swing
application was very problematic.

00:11:36.780 --> 00:11:40.810
As you can see by the diagram here,
we have a QTCanvas that

00:11:40.810 --> 00:11:42.220
is inside of a window.

00:11:42.220 --> 00:11:50.100
And because it's a heavyweight component
on top of a lightweight component,

00:11:50.100 --> 00:11:53.400
all the lightweight components
are being drawn over.

00:11:53.400 --> 00:11:57.820
And that is somewhat undesirable
for people doing swing applications.

00:11:57.820 --> 00:12:00.160
So what do you do now?

00:12:00.160 --> 00:12:05.500
Well, now new in QuickTime for Java 6,
we have a new class, JQTCanvas,

00:12:05.500 --> 00:12:06.680
which is a lightweight.

00:12:06.720 --> 00:12:07.480
component.

00:12:07.840 --> 00:12:08.120
Yay!

00:12:10.200 --> 00:12:12.200
Thank you.

00:12:12.200 --> 00:12:16.020
So this provides most of the
functionality of QT Canvas.

00:12:16.550 --> 00:12:21.010
On Mac OS X, it's hardware accelerated,
so that enhances the frame rate.

00:12:21.010 --> 00:12:23.070
And it's pretty easy to use.

00:12:23.480 --> 00:12:27.920
And when I talk about providing most
of the functionality of the QT Canvas,

00:12:27.920 --> 00:12:29.320
there are some caveats.

00:12:29.370 --> 00:12:33.060
And those are primarily caused by
the fact that your drawing of the

00:12:33.060 --> 00:12:36.710
movie is being done off-screen,
and then it has to be transferred

00:12:36.710 --> 00:12:39.360
on-screen into a lightweight component.

00:12:39.360 --> 00:12:43.010
And this introduces a lot
of the same limitations as

00:12:43.010 --> 00:12:45.210
you have in the compositor.

00:12:45.210 --> 00:12:48.770
Primarily, well,
you have a lower frame rate because

00:12:48.860 --> 00:12:51.860
you have to do twice as much work,
draw off-screen, then copy on-screen.

00:12:51.860 --> 00:12:55.680
And you also can't display
a movie controller in that,

00:12:55.680 --> 00:13:01.080
simply because QuickTime can't
display movie controllers off-screen.

00:13:01.080 --> 00:13:03.040
So you can't have that feature.

00:13:03.040 --> 00:13:06.310
However, if you like,
you could either make your own

00:13:06.310 --> 00:13:09.040
controller using lightweight components.

00:13:09.360 --> 00:13:10.740
And tie those to your movie.

00:13:10.740 --> 00:13:14.540
Or you could choose to detach
your controller and have that in

00:13:14.550 --> 00:13:16.970
a heavyweight component elsewhere
where it wouldn't interfere with

00:13:17.060 --> 00:13:18.150
your lightweight components.

00:13:18.180 --> 00:13:21.510
And Anant will be talking about how
to do that later in the presentation.

00:13:23.180 --> 00:13:28.300
So additionally,
all time-based clients that you

00:13:28.310 --> 00:13:34.300
want to use in your lightweight
swing component need to implement

00:13:34.300 --> 00:13:37.860
the drawing notifier interface,
because that's the mechanism whereby

00:13:37.860 --> 00:13:43.230
the swing JQT canvas is told that it
has a frame that needs to be updated.

00:13:43.240 --> 00:13:47.570
And examples of those classes
are SWCompositorMoviePresenter

00:13:47.570 --> 00:13:49.340
and QTFectPresenter.

00:13:49.340 --> 00:13:53.620
You can look in the Javadoc to see
which classes implement that interface.

00:13:55.680 --> 00:13:57.280
So, how do you use jqt-canvas?

00:13:57.280 --> 00:14:00.640
Well, it's remarkably similar to
using the regular canvas.

00:14:00.640 --> 00:14:04.670
In fact, most of your code you can just
change by adding a little j

00:14:04.670 --> 00:14:06.370
in front and it will work.

00:14:06.480 --> 00:14:09.940
So, but for those of you that
have never done that before,

00:14:09.940 --> 00:14:13.180
you create a new canvas,
jqt-canvas in this example,

00:14:13.200 --> 00:14:16.810
using the same sizing parameters
and constraints as you used

00:14:16.810 --> 00:14:18.940
with the previous component.

00:14:19.900 --> 00:14:30.650
Set the client.

00:14:31.050 --> 00:14:31.050
In this case,
we're using a movie player object.

00:14:31.050 --> 00:14:31.050
Creating a new movie player,
associating a movie with it,

00:14:31.050 --> 00:14:31.050
and then calling setClient on that.

00:14:31.360 --> 00:14:34.020
And then we add the
JQT canvas to the frame.

00:14:34.080 --> 00:14:37.970
In this case, you'll note that if you're
adding it to a J frame,

00:14:37.970 --> 00:14:41.970
you need to get the content frame
first before you can add it.

00:14:42.060 --> 00:14:46.360
And then if you're on Mac OS X,
there's a property called

00:14:46.470 --> 00:14:48.800
useMacOSX acceleration.

00:14:48.800 --> 00:14:51.680
And right now,
because we haven't had a lot of

00:14:51.690 --> 00:14:56.040
feedback as to how well this works,
we set that by default to false.

00:14:56.150 --> 00:14:59.490
Once we get feedback from
people that that's working,

00:14:59.580 --> 00:15:01.260
we set that to false.

00:15:01.300 --> 00:15:03.220
working fine,
then we'll probably make true the

00:15:03.220 --> 00:15:06.170
default so you don't have to have this

00:15:08.370 --> 00:15:10.380
Okay,
and what everybody loves most of all,

00:15:10.380 --> 00:15:12.510
and I'm going to show a
demo of how this works.

00:15:16.830 --> 00:15:22.820
Okay, so we have a little example here.

00:15:22.820 --> 00:15:25.640
And what we have going on,
those of you might recognize

00:15:25.640 --> 00:15:29.900
this as being a swing component
with J internal frames.

00:15:29.900 --> 00:15:33.150
And as you can see here,
we have an internal frame

00:15:33.150 --> 00:15:36.700
window here that we're moving
all around in the video.

00:15:36.700 --> 00:15:41.970
Go ahead and change this
to something really big.

00:15:43.900 --> 00:15:45.900
"All working just fine.

00:15:45.900 --> 00:15:49.580
You also noticed it is a minimized,
reduced stat.

00:15:49.580 --> 00:15:53.620
You can see the transparent
effects right over the movie here.

00:15:53.620 --> 00:15:58.020
So it's truly compositing in
a swing component just fine.

00:15:58.170 --> 00:16:00.380
Frame rate is great.

00:16:00.380 --> 00:16:02.990
You can't really tell any difference
between that and something that

00:16:02.990 --> 00:16:04.400
you'd see in a QuickTime player.

00:16:04.400 --> 00:16:07.440
And even more fun..."

00:16:09.220 --> 00:16:15.050
This is MPEG-4 playing
in a J internal frame.

00:16:16.380 --> 00:16:21.140
Overlapping another internal frame,
not drawing on top, behaving correctly,

00:16:21.140 --> 00:16:22.880
excellent frame rate.

00:16:22.940 --> 00:16:29.640
This is about 900k bitrate, I believe.

00:16:29.640 --> 00:16:36.260
So that's pretty neat to see that kind
of thing happening in a TrueSwing demo.

00:16:45.150 --> 00:16:45.630
So it works.

00:16:45.820 --> 00:16:46.350
Use it.

00:16:46.450 --> 00:16:48.340
And please give us feedback.

00:16:48.340 --> 00:16:52.390
If you see any cases where you
think something should be working

00:16:52.390 --> 00:16:54.840
and you're having trouble,
let us know.

00:16:54.840 --> 00:16:56.810
We're always looking at
those kind of things,

00:16:56.820 --> 00:16:58.840
and we really do
appreciate your feedback.

00:17:01.180 --> 00:17:05.440
Okay, continuing on for current
features in QuickTime for Java.

00:17:05.440 --> 00:17:10.200
As I mentioned earlier,
we've provided a couple of enhancements,

00:17:10.200 --> 00:17:14.960
such as the support for
the JDK 1.4 on Windows.

00:17:14.960 --> 00:17:18.920
We will be having that on
Mac OS X once that's available.

00:17:19.840 --> 00:17:24.190
This on Windows doesn't
require any API-level changes.

00:17:24.460 --> 00:17:26.780
It's completely transparent to the user.

00:17:26.780 --> 00:17:32.390
We have a new
Movie Media Handler support.

00:17:32.720 --> 00:17:33.680
Excuse me.

00:17:33.790 --> 00:17:36.670
So that if you have a movie
that includes other movies,

00:17:36.820 --> 00:17:37.810
you can do that.

00:17:38.090 --> 00:17:44.270
We have some additional getter and
setter calls on QTVR view parameter.

00:17:44.540 --> 00:17:48.680
And we have a public constructor
for the sequence grabber output.

00:17:48.680 --> 00:17:52.630
And now we support file names
with accent and characters.

00:17:52.630 --> 00:17:53.700
Yay.

00:17:55.330 --> 00:17:58.830
An additional bug fix,
which is high on people's list,

00:17:59.000 --> 00:18:02.160
were some enhancements
for the Mac OS X dialogs.

00:18:02.320 --> 00:18:06.830
There used to be a bug where if you
had a native dialog displaying in Java,

00:18:06.830 --> 00:18:08.480
it would just be blank.

00:18:08.520 --> 00:18:11.250
So for those of you that
are still seeing that,

00:18:11.250 --> 00:18:12.510
try your Jaguar CD.

00:18:12.510 --> 00:18:13.640
That's all fixed.

00:18:13.750 --> 00:18:15.160
It's working great.

00:18:15.160 --> 00:18:18.680
We also have a number of
fixes in the sequence grabber

00:18:18.680 --> 00:18:20.760
so that that actually works.

00:18:22.520 --> 00:18:24.690
You can have,
and let us know if you find a case

00:18:24.690 --> 00:18:27.470
where you're still having problems
with that because we believe

00:18:27.480 --> 00:18:28.680
it to be working correctly now.

00:18:28.680 --> 00:18:35.560
You now can have a SGData proc added,
and the sequence grabber will call that

00:18:35.560 --> 00:18:40.580
function when it records some data,
and that allows you to have

00:18:40.580 --> 00:18:44.310
the opportunity to do some
editing or manipulating on

00:18:44.320 --> 00:18:46.780
that data before it gets drawn.

00:18:46.780 --> 00:18:49.740
And there's just some little
code here for those of you

00:18:49.740 --> 00:18:51.570
that don't know how to do that.

00:18:52.200 --> 00:18:55.810
You basically call setDataProc from
the sequence grabber and create

00:18:55.810 --> 00:18:59.570
your own class which implements
the SGDataProc interface and

00:18:59.610 --> 00:19:01.640
then override the execute method.

00:19:01.640 --> 00:19:06.630
And you return an int which tells you
whether you changed the data or zero

00:19:06.740 --> 00:19:09.420
if you didn't change any of the data.

00:19:09.420 --> 00:19:11.240
So that all works now.

00:19:12.830 --> 00:19:15.930
Still from the previous version,
QuickTime 5,

00:19:15.930 --> 00:19:18.780
we have support for the presentation API.

00:19:18.780 --> 00:19:24.520
This has been enhanced in QuickTime 6
so that you now can do MPEG-4 streaming.

00:19:24.520 --> 00:19:30.920
And this API allows you to broadcast
from a sequence grabber source,

00:19:31.050 --> 00:19:38.280
such as an audio device, microphone, CD,
or a video device, such as a DV camera.

00:19:38.280 --> 00:19:44.030
We also have support now in
the API to pick another source,

00:19:44.190 --> 00:19:47.640
such as a file that resides on
disk for the sequence grabber.

00:19:47.640 --> 00:19:50.140
And that's all done through
the sourcer component,

00:19:50.140 --> 00:19:51.500
and that's all there now.

00:19:51.500 --> 00:19:53.690
So go ahead and try that.

00:19:53.790 --> 00:19:58.040
Your broadcast can be unicast, multicast,
and it's user configurable

00:19:58.040 --> 00:19:59.800
using a settings dialog.

00:20:02.290 --> 00:20:03.850
Okay, so that's all I have.

00:20:03.850 --> 00:20:07.840
Now I'd like to turn over the
presentation to Anant Sonone,

00:20:07.840 --> 00:20:10.560
who is on the QuickTime for
Java engineering team,

00:20:10.560 --> 00:20:13.750
and he's going to be talking about
efficient programming methods.

00:20:13.760 --> 00:20:15.480
Thank you.

00:20:15.480 --> 00:20:17.550
Anant?

00:20:20.780 --> 00:20:21.520
Thank you very much, Michael.

00:20:21.520 --> 00:20:26.050
That was a nice introduction to the
new QuickTime for Java 6 features.

00:20:26.050 --> 00:20:29.520
Now, for the rest of the session,
I want to talk about certain issues

00:20:29.670 --> 00:20:33.420
that the developers have raised
regarding QuickTime for Java in general.

00:20:33.420 --> 00:20:37.370
And also, we're going to look at
certain programming tasks

00:20:37.700 --> 00:20:41.050
that developers need to do,
and we're going to show how

00:20:41.450 --> 00:20:46.060
efficiently we can program using
these QuickTime for Java APIs.

00:20:46.720 --> 00:20:50.860
As you know, QuickTime is so massive,
QuickTime for Java certainly has

00:20:50.860 --> 00:20:54.170
to support all those features,
and that makes QuickTime for

00:20:54.170 --> 00:20:55.570
Java API also pretty big.

00:20:55.650 --> 00:21:00.530
That is kind of confusing and sometimes
leads to certain programming ways for

00:21:00.530 --> 00:21:03.260
developers which make it inefficient.

00:21:03.260 --> 00:21:07.800
So the best way of doing this,
that is what I want to tell you.

00:21:10.190 --> 00:21:10.460
Whoops.

00:21:10.460 --> 00:21:13.250
All right.

00:21:13.640 --> 00:21:17.340
The first topic that I've chosen to
talk about is the detached controller.

00:21:17.340 --> 00:21:20.400
Now, actually,
before we dive into the details

00:21:20.400 --> 00:21:24.640
of what a detached controller is
and how and why we should use it,

00:21:24.640 --> 00:21:28.160
I want to introduce to those
newbies in the crowd as to

00:21:28.160 --> 00:21:30.350
what movie controllers are.

00:21:31.040 --> 00:21:34.940
So, movie controllers basically
present the user with an interface

00:21:34.940 --> 00:21:36.420
for controlling the movie.

00:21:36.420 --> 00:21:42.180
So what you can do is you can either
stop and start the playback of a movie,

00:21:42.180 --> 00:21:46.580
you can jump within the time base of a
movie by clicking within the controller,

00:21:46.580 --> 00:21:49.470
or you can even, you know,
play with the sound.

00:21:49.520 --> 00:21:52.050
Not only that,
even if you see the picture

00:21:52.050 --> 00:21:55.730
that's displayed over here,
that's the standard way in

00:21:55.730 --> 00:21:58.140
which a controller is displayed.

00:21:58.140 --> 00:22:02.520
The controller bar is always... It's
always beneath the movie content.

00:22:02.520 --> 00:22:05.790
So this is the standard way a
movie will always be displayed

00:22:05.810 --> 00:22:07.580
along with the controller.

00:22:07.580 --> 00:22:12.860
There's no other place that the
controller can be displayed if

00:22:13.000 --> 00:22:15.130
it's displayed in the standard way.

00:22:15.140 --> 00:22:20.940
So now, if you want to basically change
the position of the controller,

00:22:20.940 --> 00:22:24.810
place it in the top,
or you want to display it in some other

00:22:25.100 --> 00:22:29.060
window besides the movie content itself,
you'll have to detach the controller.

00:22:29.060 --> 00:22:33.620
And... That is where detached
controllers come into picture.

00:22:33.660 --> 00:22:39.370
So, this is a pictorial representation of
how a detached controller will look.

00:22:39.630 --> 00:22:44.260
You can see that the controller has been
detached from the movie content itself.

00:22:44.490 --> 00:22:48.390
So, Spider-Man is happy to go in
some other window he wants to,

00:22:48.390 --> 00:22:51.730
and the controller can
stay in some other window.

00:22:51.860 --> 00:22:56.930
So let's now go further into
this and see when one would want

00:22:57.180 --> 00:23:00.170
to use a detached controller.

00:23:00.470 --> 00:23:05.680
When an application basically wants to
treat the movie content and the movie

00:23:05.680 --> 00:23:09.610
controller as two graphical entities,
you would want to detach the

00:23:09.710 --> 00:23:11.430
controller from the movie itself.

00:23:11.600 --> 00:23:17.440
Not only that, by detaching it,
you have more than one advantage.

00:23:17.440 --> 00:23:20.960
You can slave multiple movies
to a single controller.

00:23:20.960 --> 00:23:26.520
So suppose the application has
multiple time bases running,

00:23:26.520 --> 00:23:29.620
which are active,
and suppose you want to control all

00:23:29.620 --> 00:23:33.520
these movies using a single controller,
you can do that.

00:23:33.650 --> 00:23:36.710
You detach all the movies from
the controller and just have

00:23:36.710 --> 00:23:40.730
one single controller placed,
which will control all the other movies.

00:23:42.490 --> 00:23:46.090
By detaching the controller,
as Michael told you previously,

00:23:46.170 --> 00:23:47.680
movie controllers have a constraint.

00:23:47.680 --> 00:23:49.440
That is, they cannot be drawn off screen.

00:23:49.440 --> 00:23:51.940
So they cannot be used
in a swing component.

00:23:51.940 --> 00:23:55.280
So the only option remains
is to detach the controller,

00:23:55.280 --> 00:23:59.260
place that controller in a different
heavyweight component like a

00:23:59.350 --> 00:24:02.980
QT canvas in a separate window,
and place the movie content

00:24:02.980 --> 00:24:04.440
in a swing component.

00:24:04.440 --> 00:24:08.310
That way you can have the movie and the
controller in two separate windows and

00:24:08.440 --> 00:24:10.660
display the movie in a swing component.

00:24:12.160 --> 00:24:14.390
Not only that,
you can actually get rid of the

00:24:14.390 --> 00:24:18.260
controller completely and have your own
custom controller to control the movie.

00:24:20.490 --> 00:24:27.020
So here is some code over here which
shows you how to basically do that.

00:24:27.020 --> 00:24:30.780
You create a QT canvas for
holding the controller.

00:24:30.780 --> 00:24:34.860
And then you create the movie
controller itself by using

00:24:34.860 --> 00:24:36.570
the movie controller class.

00:24:36.670 --> 00:24:39.280
Pass it the movie that
you want to display.

00:24:39.980 --> 00:24:42.140
Now, here's the important call.

00:24:42.240 --> 00:24:44.900
Controller.setAttached false.

00:24:45.100 --> 00:24:49.500
Here you're telling the controller that
I want you to detach from the movie.

00:24:54.400 --> 00:24:58.260
Once you have detached the controller,
now you want to display this

00:24:58.260 --> 00:25:00.340
controller in the canvas.

00:25:00.340 --> 00:25:03.800
For that, you will need to pass this
controller to a drivable object,

00:25:03.800 --> 00:25:06.540
which will basically display
the controller in the canvas.

00:25:06.540 --> 00:25:11.590
For that, you need to create a QT player
object and pass it to the controller.

00:25:11.600 --> 00:25:16.460
Then, once you have done that,
you will pass the QT player to

00:25:16.460 --> 00:25:19.150
the canvas and set the client.

00:25:20.710 --> 00:25:24.480
Now that's for the controller,
to display the controller.

00:25:24.480 --> 00:25:26.600
The second part is to display the movie.

00:25:26.600 --> 00:25:29.270
To display the movie, again,
you'll need a drawable object.

00:25:29.270 --> 00:25:32.700
In this case, we're going to use a movie
player object and pass in the

00:25:32.700 --> 00:25:34.400
movie that we need to display.

00:25:34.400 --> 00:25:38.230
And again, similarly,
we'll set the client

00:25:38.460 --> 00:25:42.590
for the movie canvas,
which we create and display

00:25:42.640 --> 00:25:45.110
the movie player in there.

00:25:45.820 --> 00:25:51.560
So let's see the demonstration of
how a detached controller would work.

00:26:05.270 --> 00:26:12.750
So what you see over here is
three separate components,

00:26:12.790 --> 00:26:15.720
all of them having their own time
basis and they're happily running.

00:26:15.720 --> 00:26:19.720
So you have two movies over
here with their own controllers.

00:26:19.720 --> 00:26:26.370
And now what you can do is
basically when I press this button,

00:26:26.520 --> 00:26:28.770
detach it...

00:26:30.500 --> 00:26:31.930
Okay, cool.

00:26:32.180 --> 00:26:36.960
So what's done is it's basically detached
the controller from both the movies and

00:26:37.090 --> 00:26:41.240
it's placed the controller on top of it.

00:26:42.920 --> 00:26:47.980
And what you see is the first
movie is the master time base,

00:26:47.980 --> 00:26:50.250
and the rest of the two
have been slaved to it.

00:26:50.260 --> 00:26:55.340
So you saw in the beginning that the
second movie was much bigger in duration,

00:26:55.450 --> 00:27:00.630
but now since it has been slaved
to the first movie time base,

00:27:00.660 --> 00:27:04.390
it's all kind of like getting back
once the first movie stops playing,

00:27:04.500 --> 00:27:06.420
and it goes back to the beginning.

00:27:07.200 --> 00:27:11.560
And this is a good example of, you know,
slaving movies to each other and

00:27:11.560 --> 00:27:15.670
using the attached controller
to control multiple time bases.

00:27:27.070 --> 00:27:27.410
All right.

00:27:27.540 --> 00:27:37.140
So the second topic of discussion
is playing a sound file.

00:27:37.140 --> 00:27:40.290
Now,
why did we choose to discuss this one

00:27:40.360 --> 00:27:45.410
is because one of the mistakes that
we have done previously is we actually

00:27:45.410 --> 00:27:50.720
released some code in the SDK that
obviously played the sound file,

00:27:50.720 --> 00:27:54.270
but that wasn't the right way
to play it or that wasn't the

00:27:54.270 --> 00:27:56.410
most efficient way to play it.

00:27:56.540 --> 00:28:00.530
We want to rectify that and show you
what is the best way of doing that.

00:28:00.620 --> 00:28:06.140
So the previous example and documentation
recommended using a QTDrawable object.

00:28:08.370 --> 00:28:11.040
In case of a sound file,
when you just want to play a sound file,

00:28:11.160 --> 00:28:12.300
there's nothing to draw.

00:28:12.300 --> 00:28:14.340
You're just going to play
some sound bytes over there.

00:28:14.340 --> 00:28:17.930
But in the previous example,
we are using the standard way.

00:28:18.260 --> 00:28:23.100
That is,
we recommended using a QTPlayer object,

00:28:23.100 --> 00:28:27.210
and we also needed an
explicit call task on it.

00:28:28.310 --> 00:28:34.770
This led to the fact that on Mac OS X,
since the QTPlayer was being not

00:28:34.800 --> 00:28:39.520
set as the client of the canvas,
because we weren't using a canvas,

00:28:39.520 --> 00:28:48.380
the movie controller that was being used
was getting set to an off-screen port,

00:28:48.460 --> 00:28:50.880
and that was creating
a problem on Mac OS X,

00:28:50.880 --> 00:28:54.080
and the movie controller was getting
drawn somewhere in the menu bar.

00:28:54.100 --> 00:28:57.760
So there were these graphical artifacts
that we wanted to overcome as well.

00:28:57.920 --> 00:29:03.050
So here is a better way
of playing a sound file.

00:29:05.110 --> 00:29:08.740
What you do is open the movie
file that you want to play

00:29:08.740 --> 00:29:12.080
using the movie.form file,
pass in the sound file to that.

00:29:12.480 --> 00:29:16.770
Here's the important class over here,
task.movies class.

00:29:16.820 --> 00:29:22.600
So basically, task.movies class,
what it does is it basically tasks all

00:29:22.600 --> 00:29:26.780
the active time bases of the movies
that are present in an application.

00:29:26.920 --> 00:29:29.500
So basically what you do is
whenever you have an active time

00:29:29.630 --> 00:29:33.530
base that needs to be tasked,
you basically call task.movies

00:29:33.530 --> 00:29:35.220
addMovie and start.

00:29:35.220 --> 00:29:40.020
This will basically increment the counter
that the task.movies has and says that,

00:29:40.290 --> 00:29:42.440
okay, I've got one client
which needs to be tasked.

00:29:42.540 --> 00:29:45.940
And when you add another time,
it will basically increment the

00:29:45.940 --> 00:29:47.680
counter and so on and so forth.

00:29:47.800 --> 00:29:52.030
So this will provide those active
time bases with the task time

00:29:52.030 --> 00:29:54.690
that's needed to process and play.

00:29:55.320 --> 00:29:57.790
And then you basically call--

00:29:57.800 --> 00:30:16.300
[Transcript missing]

00:30:18.090 --> 00:30:18.500
All right.

00:30:18.730 --> 00:30:23.930
So now we're going to look at
some different topic over here,

00:30:23.930 --> 00:30:27.180
which is the wide action
or the wide sprite movies.

00:30:27.180 --> 00:30:31.660
Over the last,
we have been having requests from

00:30:31.660 --> 00:30:37.660
the developers regarding having
some way of creating wide action

00:30:37.660 --> 00:30:40.820
movies using some QTJava APIs.

00:30:40.820 --> 00:30:44.550
We have been working in this
direction to give you an interface

00:30:44.730 --> 00:30:47.980
for the wide action movie APIs that
QuickTime currently provides.

00:30:48.010 --> 00:30:58.740
We have been working in this
direction to give you an interface

00:30:59.190 --> 00:31:11.050
for the wide action movie APIs that
QuickTime currently provides.

00:31:11.050 --> 00:31:11.050
We have been working in this
direction to give you an interface

00:31:11.050 --> 00:31:11.050
for the wide action movie APIs that
QuickTime currently provides.

00:31:11.200 --> 00:31:16.440
Just to give you a brief introduction
as to what wide-action movies are,

00:31:16.470 --> 00:31:21.210
movies that contain interactive
components are called wide movies.

00:31:21.270 --> 00:31:26.480
Any movie with which you can interact,
basically click a mouse and get some

00:31:26.540 --> 00:31:31.090
interaction from the movie content,
is called a wide movie.

00:31:31.100 --> 00:31:35.710
What happens in a sense is,
user input is translated into events,

00:31:35.860 --> 00:31:39.700
which can basically target
various components in a movie.

00:31:39.700 --> 00:31:43.940
It can be the movie itself,
or a particular track in the movie,

00:31:43.940 --> 00:31:49.600
or it can even target a particular
sprite in the sprite track of the movie.

00:31:49.600 --> 00:31:53.870
What happens is,
events fire actions which modify certain

00:31:53.870 --> 00:31:57.000
or particular properties of the target.

00:31:57.000 --> 00:32:00.150
In case of a sprite, for example,
what you will do is change

00:32:00.150 --> 00:32:04.640
the... image index of the sprite
that's currently being displayed.

00:32:04.640 --> 00:32:09.060
And that way you can achieve the
interactive effect over there.

00:32:14.500 --> 00:34:29.100
[Transcript missing]

00:34:29.320 --> 00:34:33.420
Now, the keyframe samples,
the sprite track, the override samples,

00:34:33.420 --> 00:34:37.720
all of these in QuickTime are represented
using the QTAtoms architecture.

00:34:37.720 --> 00:34:43.180
So you can look at the movie as a whole,
as an entire hierarchy of

00:34:43.290 --> 00:34:45.960
atoms and atom containers.

00:34:45.960 --> 00:34:48.820
So the movie is a top-level
atom container which has the

00:34:49.030 --> 00:34:51.960
sprite track atom container,
and sprite tracks has various

00:34:51.960 --> 00:34:54.910
atom containers of keyframe
samples and so on and so forth.

00:34:55.080 --> 00:35:01.590
So this is a complete tree of atom
containers which is basically passed by

00:35:01.590 --> 00:35:04.920
QuickTime and the movie is displayed.

00:35:04.920 --> 00:35:08.750
This holds true for any movie,
not just sprite movies.

00:35:12.660 --> 00:35:16.580
So when normally using
the C QuickTime APIs that

00:35:16.580 --> 00:35:19.410
are currently available,
what are the challenges

00:35:19.410 --> 00:35:21.390
developers are facing?

00:35:21.740 --> 00:35:25.440
As people who might have probably
used these C QuickTime APIs,

00:35:25.440 --> 00:35:32.040
you would have understood the
amount of difficulty one has to go

00:35:32.040 --> 00:35:36.990
through to understand those cryptic
and big API names themselves.

00:35:37.270 --> 00:35:42.090
And the architecture in general itself
is pretty difficult to understand.

00:35:42.100 --> 00:35:48.310
Not only that,
C QuickTime APIs are pretty tedious

00:35:48.310 --> 00:35:54.160
to use because they have n number
of parameters and there are these

00:35:54.280 --> 00:35:55.900
flags that you need to take care of.

00:35:56.020 --> 00:36:02.740
And keeping that in mind is kind of
like a pretty daunting task to do it.

00:36:02.740 --> 00:36:08.460
Using C APIs also makes your
application platform dependent.

00:36:08.460 --> 00:36:11.740
And also, there are issues that
you need to take care of.

00:36:11.870 --> 00:36:15.560
So if you're making a movie
for Windows or on Mac,

00:36:15.710 --> 00:36:17.140
you have to take care of the issues.

00:36:17.140 --> 00:36:21.670
These all things lead to
a major development curve.

00:36:21.910 --> 00:36:25.140
So basically,
you have to invest time in reading

00:36:25.140 --> 00:36:29.140
the material and understanding this,
and that is going to be a big overhead.

00:36:30.140 --> 00:36:33.420
And if you're thinking of
using a third-party tool,

00:36:33.420 --> 00:36:39.540
that probably might not be suited
for your kind of needs if you're

00:36:39.550 --> 00:36:42.310
using it to do just small things.

00:36:42.460 --> 00:36:45.320
So third-party tools can
prove to be expensive.

00:36:47.940 --> 00:36:51.020
So, that is where QuickTime for
Java APIs that we are

00:36:51.130 --> 00:36:53.400
introducing come into picture.

00:36:53.400 --> 00:36:57.610
Reasons are, obviously,
those which QuickTime for

00:36:57.750 --> 00:37:02.490
Java API leverage from Java,
which is the object-oriented model.

00:37:02.500 --> 00:37:07.770
Our APIs are also set on those same,
excuse me,

00:37:07.810 --> 00:37:11.260
on the same object-oriented model.

00:37:11.260 --> 00:37:16.040
Using this, Java APIs make application
cross-platform.

00:37:16.320 --> 00:37:18.040
So, you don't have to worry
about the Indian issues.

00:37:18.040 --> 00:37:20.100
We are going to take care
of all the Indian issues.

00:37:20.100 --> 00:37:24.820
You just run your application,
run it on Mac or Windows, any platform,

00:37:24.820 --> 00:37:28.340
it will run the same and create movies,
or you can modify movies,

00:37:28.340 --> 00:37:30.820
whatever you want, using those APIs.

00:37:30.820 --> 00:37:34.640
So, people even coming from
the background of Java,

00:37:34.640 --> 00:37:39.610
which don't have much exposure to see
QuickTime API or even understanding

00:37:39.610 --> 00:37:42.610
of the QTAtoms architecture,
can use these classes to

00:37:42.610 --> 00:37:44.440
create wire-sprite movies.

00:37:44.920 --> 00:37:49.050
And, you know, you get kind of a jump
start using these classes.

00:37:49.060 --> 00:37:53.130
So, obviously, this is leading to a very
small learning curve.

00:37:55.610 --> 00:38:02.910
So let's go further and see
how these APIs can be used.

00:38:03.060 --> 00:38:06.480
So we're going to look at an
example of how to create or

00:38:06.490 --> 00:38:08.740
modify a wide sprite movie.

00:38:08.740 --> 00:38:12.270
What you would do is basically
create a new movie file with

00:38:12.590 --> 00:38:13.980
a single sprite track in it.

00:38:14.560 --> 00:38:20.010
Then you make a single keyframe
sample containing the sprites

00:38:20.030 --> 00:38:22.650
and all of the image data in it.

00:38:22.650 --> 00:38:26.410
Then what you would do is basically
set the sprite track's properties.

00:38:26.500 --> 00:38:29.060
So you can, as I told you,
even the sprite track

00:38:29.130 --> 00:38:33.120
is an Atom container,
you can set the properties

00:38:33.160 --> 00:38:35.320
for the sprite track.

00:38:35.320 --> 00:38:37.910
Then you create override samples
as needed and override the

00:38:37.920 --> 00:38:40.820
properties of the sprites that
were declared in the keyframe.

00:38:40.820 --> 00:38:46.130
And then once you have done that,
you have to wire all these sprites.

00:38:46.230 --> 00:38:52.850
And that is done by setting the actions
on the sprites for specified user events.

00:38:55.610 --> 00:39:01.710
Keeping all that in mind and
the overall format of the Wired

00:39:01.710 --> 00:39:07.380
Sprite track and the architecture,
we have laid out this

00:39:07.460 --> 00:39:12.030
package of Wired Sprite,
which has grouped a bunch

00:39:12.030 --> 00:39:16.320
of atom containers into
logical classes over here.

00:39:16.320 --> 00:39:19.100
For example,
actionAtom basically represents

00:39:19.340 --> 00:39:23.190
the actionAtom containers,
which holds the actions which are

00:39:23.190 --> 00:39:26.520
targeting either the sprite or the track.

00:39:28.170 --> 00:39:32.130
Image container, as the name says,
holds the images which are shared by the

00:39:32.130 --> 00:39:36.220
different sprites in the sprite track.

00:39:36.610 --> 00:39:38.070
Sample frame.

00:39:38.110 --> 00:39:41.580
A sample frame either
represents a keyframe or it

00:39:42.410 --> 00:39:44.260
represents an override sample.

00:39:44.260 --> 00:39:48.420
So you can basically create a keyframe
or sample frame using this class.

00:39:48.500 --> 00:39:51.530
And the rest of the classes
represent the sprite atom,

00:39:51.780 --> 00:39:53.820
represent the individual sprites.

00:39:53.940 --> 00:39:59.540
The sprite track atom basically
represents the sprite track in the movie.

00:39:59.540 --> 00:40:03.060
And there are these utility classes
and other constant classes in there.

00:40:09.280 --> 00:40:15.300
So let's look at how you can use these
classes to create the white sprite movie.

00:40:15.300 --> 00:40:19.310
As usual,
you'll call the createMovieFrom file on

00:40:19.310 --> 00:40:22.200
the movie class to create a new movie.

00:40:22.200 --> 00:40:27.750
Now this is an empty movie which doesn't
have a resource yet and no track in it.

00:40:28.210 --> 00:40:32.640
So follow that with the
movie.addSpriteTrack call,

00:40:32.640 --> 00:40:36.060
which will basically add a
track to the sprite movie.

00:40:36.060 --> 00:40:38.760
Then the track basically contains media.

00:40:38.760 --> 00:40:43.370
So you will have to call new sprite
media and pass in the track for

00:40:43.510 --> 00:40:45.860
which you want to create the media.

00:40:45.860 --> 00:40:50.580
Now you have come to a point
where the actual action begins,

00:40:50.690 --> 00:40:54.380
and you have to start adding the keyframe
samples and the override samples.

00:40:54.380 --> 00:41:00.800
So we create a keyframe
sample using the sample frame,

00:41:00.800 --> 00:41:07.070
and now to the keyframe you're going
to add the image data that you create

00:41:07.160 --> 00:41:09.160
using the image container class.

00:41:09.330 --> 00:41:10.900
And call the makeImageContainer.

00:41:11.280 --> 00:41:16.210
That gives you an object which
you can call the addSpriteImageOn,

00:41:16.220 --> 00:41:20.810
and you can add your images and pass in
the image information and the various

00:41:20.810 --> 00:41:22.990
properties for the images to it.

00:41:22.990 --> 00:41:29.060
So that will basically create the image
data bank for you in the keyframe sample.

00:41:30.450 --> 00:41:35.520
Now, once you have created the
image data for the sprites,

00:41:35.520 --> 00:41:38.670
you have to create the sprites itself.

00:41:38.720 --> 00:41:42.520
That you do using the spriteAtom class.

00:41:42.520 --> 00:41:45.840
So you create a new
spriteAtom and pass in the ID,

00:41:45.940 --> 00:41:50.520
which is unique for every sprite
that's in the keyframe sample.

00:41:50.520 --> 00:41:53.310
And as I told you,
sprites have different properties.

00:41:53.310 --> 00:41:56.920
And in the keyframe, as I said,
you have to define the initial scene,

00:41:56.920 --> 00:41:59.340
so you have to set the
initial properties.

00:41:59.340 --> 00:42:03.560
And that is done using
the setProperties call.

00:42:03.560 --> 00:42:07.180
So you have set, for example,
setImageIndex will set the image index,

00:42:07.370 --> 00:42:09.320
setGraphicsMode will
set the graphics mode.

00:42:09.320 --> 00:42:12.760
So these are the different properties,
and we have all these set

00:42:12.770 --> 00:42:15.830
actions on the spriteAtom class,
which will help you set

00:42:15.830 --> 00:42:17.320
all these properties.

00:42:17.320 --> 00:42:22.960
Then you move on to create the
actual actions that will be

00:42:22.960 --> 00:42:26.380
attached to the sprite itself.

00:42:26.380 --> 00:42:30.600
So what you do is,
you create these actionAtom

00:42:30.600 --> 00:42:32.520
using the actionAtom class.

00:42:32.640 --> 00:42:36.700
And again,
using the setAction methods and

00:42:36.700 --> 00:42:40.460
passing in the event on which
you want to fire the action,

00:42:40.570 --> 00:42:42.440
you call the setAction.

00:42:42.440 --> 00:42:46.650
For example,
you can fire a setVisible action method

00:42:46.740 --> 00:42:51.600
on the sprite and pass in the event,
for example, on mouseEnter,

00:42:51.600 --> 00:42:54.150
I want the sprite to be visible.

00:42:54.280 --> 00:42:59.320
So you say spriteAction dot set
spriteVisible and pass in the

00:42:59.340 --> 00:43:01.600
event and the action itself.

00:43:01.880 --> 00:43:07.480
And the data, which is either I want to
make it visible or invisible.

00:43:07.580 --> 00:43:12.640
And finally, when you have made a bunch
of these actions together,

00:43:12.640 --> 00:43:16.340
you can basically set all these
actions on the sprite by calling the

00:43:16.340 --> 00:43:20.120
setAction method on the spriteAtom
class and passing the action

00:43:20.120 --> 00:43:22.200
object that you have created.

00:43:22.540 --> 00:43:28.990
Once we have done that,
now you want to add the sprite atom.

00:43:29.300 --> 00:43:31.650
Then you call the
keyframe.addSpriteAtom and pass in

00:43:31.770 --> 00:43:33.320
the sprite that you have created.

00:43:33.320 --> 00:43:37.660
So image container and the sprites,
as I said, is a part of the keyframe,

00:43:37.770 --> 00:43:41.220
so you have to add the sprites
to the keyframe as well.

00:43:41.220 --> 00:43:45.800
So this is, in short,
how you would create a keyframe

00:43:45.800 --> 00:43:50.510
sample and add the images and the
actions and the sprites to that.

00:43:52.740 --> 00:43:56.730
So internally,
what we are doing behind the scenes,

00:43:56.790 --> 00:44:00.970
what we are doing is basically
handling all the QTAtoms calls

00:44:01.310 --> 00:44:06.700
for you and creating all these
container hierarchies for you,

00:44:06.700 --> 00:44:09.510
which will basically represent
these actions and sprites.

00:44:09.600 --> 00:44:12.700
Once you have done that,
you'll go on to create

00:44:12.700 --> 00:44:15.860
the override samples,
similar to the way you have

00:44:15.860 --> 00:44:17.100
created the keyframe samples.

00:44:17.620 --> 00:44:20.880
And then you will, again,
override the properties of the individual

00:44:20.940 --> 00:44:27.070
sprites that you want to animate or
want to have some action done on it.

00:44:27.160 --> 00:44:32.140
So, mind you, override frames just
override the properties.

00:44:32.140 --> 00:44:35.150
They don't contain any actions as such.

00:44:35.320 --> 00:44:37.170
Then finally,
you add the keyframe and the

00:44:37.270 --> 00:44:38.940
overhead samples to the media.

00:44:38.940 --> 00:44:44.090
So these are the samples that you
basically add to the media and that you

00:44:44.100 --> 00:44:49.720
do using the spriteTrack.insertMedia and
pass in the media to the spriteTrack.

00:44:49.870 --> 00:44:53.220
Another class that I talked
about is the sprite track atom,

00:44:53.220 --> 00:44:56.250
which you would use to set the
properties on the sprite track.

00:44:56.390 --> 00:44:59.410
Again,
you have the different set properties

00:44:59.440 --> 00:45:03.080
calls on the sprite track atoms,
which you can set the

00:45:03.080 --> 00:45:05.350
properties for the sprite track.

00:45:05.440 --> 00:45:09.360
You finally set the properties of
that sprite track on the media.

00:45:10.290 --> 00:45:12.240
Once you have done
doing all these things,

00:45:12.350 --> 00:45:14.900
you're ready to save it to a movie.

00:45:14.900 --> 00:45:17.980
You call the add movie resource
to the movie and save the movie.

00:45:17.980 --> 00:45:23.220
This is how you would basically
create a wire sprite movie.

00:45:24.960 --> 00:45:30.870
All right, so talking of all this,
one would wonder how much effort one

00:45:30.950 --> 00:45:33.090
has got to take while doing all this.

00:45:33.100 --> 00:45:37.760
I would say as compared to the
C QuickTime APIs for widespread movies,

00:45:37.760 --> 00:45:40.820
one would have to take very
minimal effort over here.

00:45:40.820 --> 00:45:42.820
Now,
this is what I'm going to demonstrate

00:45:42.820 --> 00:45:46.670
using this example that I have over here.

00:45:46.670 --> 00:45:51.460
The time that I've
invested in this example,

00:45:51.460 --> 00:45:55.030
which basically shows you
how to create a movie,

00:45:55.030 --> 00:45:58.500
a widespread movie,
and also modify that movie

00:45:58.620 --> 00:46:04.000
dynamically and save it back,
this all might seem to be very easy.

00:46:04.000 --> 00:46:07.130
But if you are a C programmer
and you've used a C API,

00:46:07.130 --> 00:46:10.790
you'll understand how much time and
effort it would take to create a movie.

00:46:10.820 --> 00:46:14.560
But using these classes,
it's going to simplify

00:46:15.040 --> 00:46:17.220
your life for the better.

00:46:17.220 --> 00:46:19.860
So let's see.

00:46:34.300 --> 00:46:39.060
So what I'm going to do is
basically create a widespread movie.

00:46:39.060 --> 00:46:40.830
So I'm going to save it.

00:46:45.490 --> 00:46:49.740
So what it has done is,
I have a bunch of images over here,

00:46:49.740 --> 00:46:53.840
and I've created two sprite atoms
over here with initial properties.

00:46:53.840 --> 00:46:57.240
And this is the keyframe that has been
displayed with the initial properties.

00:46:57.240 --> 00:47:00.990
Now, I've added some actions,
like on mouse center,

00:47:00.990 --> 00:47:04.900
I'm able to change the property
of the sprite and have some

00:47:04.900 --> 00:47:07.200
animating effect over here.

00:47:07.200 --> 00:47:10.990
And now, when I click on it,
it's basically targeted the other

00:47:11.480 --> 00:47:14.350
sprite and told to start animating it.

00:47:14.460 --> 00:47:16.580
So the override samples
come into picture.

00:47:16.580 --> 00:47:22.390
I set the movie rate to 1,
and it'll start animating the sprite.

00:47:22.520 --> 00:47:25.500
This is what a widespread
movie looks like.

00:47:25.540 --> 00:47:28.900
Now, while this is running,
I would want to-- if somebody

00:47:28.950 --> 00:47:32.720
has an existing widespread movie,
he can also basically

00:47:32.720 --> 00:47:35.490
pass that widespread movie

00:47:36.440 --> 00:47:37.670
Modify it.

00:47:37.670 --> 00:47:42.540
So this is the structure
of the sprite track.

00:47:42.540 --> 00:47:48.940
It basically has sprite track atoms,
which has the properties

00:47:48.940 --> 00:47:51.210
that you can see.

00:47:57.740 --> 00:47:59.540
You have the image container atom in it.

00:47:59.560 --> 00:48:03.390
You have two sprite atoms in
it with the initial properties.

00:48:04.080 --> 00:48:10.010
You see all these action events,
actions for the events that we have set.

00:48:13.200 --> 00:48:15.230
These are the initial
properties for the sprite,

00:48:15.260 --> 00:48:18.080
atom number two.

00:48:18.140 --> 00:48:21.390
And all this has been done using my APIs.

00:48:21.400 --> 00:48:25.400
It basically goes, you have these get
methods on these atoms,

00:48:25.440 --> 00:48:28.820
and you can get these properties easily.

00:48:28.820 --> 00:48:35.840
And now what I'm going to do is
basically just modify these properties.

00:48:35.840 --> 00:48:37.070
Say I want to

00:48:37.500 --> 00:48:51.790
location for that.

00:48:51.790 --> 00:48:51.790
I want to change the initial
image index for the sprite item 2,

00:48:51.790 --> 00:48:51.790
which is the sprite in the bottom.

00:48:51.790 --> 00:48:51.790
And I want to save it back.

00:48:51.790 --> 00:48:51.790
So, I'm going to save it back.

00:48:52.310 --> 00:48:52.630
That's it.

00:48:52.750 --> 00:48:54.070
So there you go.

00:48:54.190 --> 00:48:56.120
So this was the initial position.

00:48:56.120 --> 00:49:01.030
I have dynamically, using my object,
changed the sprite location and

00:49:01.060 --> 00:49:04.400
even changed the image index,
and the rest of the

00:49:04.780 --> 00:49:06.320
movie remains the same.

00:49:10.140 --> 00:49:12.480
So this is all done using
the QuickTime for Java API.

00:49:12.480 --> 00:49:19.050
And these can be used
on Windows and Mac OS X,

00:49:19.250 --> 00:49:20.900
respectively.

00:49:35.660 --> 00:49:41.220
Another issue that has often come
on the mailing list is regarding the

00:49:41.440 --> 00:49:44.160
QuickTime for Java installation process.

00:49:44.160 --> 00:49:48.080
We have been getting a lot
of questions regarding this,

00:49:48.200 --> 00:49:51.800
so we thought it would be
nice to address this issue.

00:49:55.220 --> 00:49:58.660
So the QuickTime for Java standard
installation procedure.

00:49:58.660 --> 00:49:59.880
Let's look at Mac OS X.

00:49:59.880 --> 00:50:03.510
Well, you don't need any installation
because it's already

00:50:03.510 --> 00:50:04.820
pre-installed on the machine.

00:50:04.820 --> 00:50:06.220
It's all there for you to use.

00:50:06.220 --> 00:50:08.460
So just go ahead and
use the Mac OS X system.

00:50:08.470 --> 00:50:12.060
You have QuickTime for Java installed
for you in the right place.

00:50:13.700 --> 00:50:18.840
On Mac OS 9,
to install QuickTime for Java,

00:50:18.840 --> 00:50:24.710
you need to use the QuickTime installer,
and you need to select

00:50:24.710 --> 00:50:28.620
the custom install,
and you do a select all,

00:50:28.620 --> 00:50:32.110
and that will install the
QuickTime for Java pieces in

00:50:32.220 --> 00:50:35.480
the write directory of MRJ.

00:50:36.440 --> 00:50:40.560
For Windows, well,
we have been having a lot of

00:50:40.640 --> 00:50:46.480
grief regarding this platform for
installation as all these varied

00:50:46.690 --> 00:50:52.480
VMs and all these registry entries
that we need to take care of.

00:50:52.620 --> 00:50:56.650
And that's where we have invested a
lot of time and a lot of efforts in

00:50:56.650 --> 00:51:01.180
making sure that the installation
for QuickTime for Java works fine.

00:51:01.180 --> 00:51:05.500
So the standard installation
on Windows basically would

00:51:05.500 --> 00:51:07.690
be to do it in certain steps.

00:51:07.800 --> 00:51:11.160
First,
you install the Sun-Java compatible VM.

00:51:11.160 --> 00:51:18.150
We don't support any other
VM which is not 100% Sun-compliant.

00:51:18.520 --> 00:51:23.930
Once you have installed the Java VM,
you have to install QuickTime and, again,

00:51:24.030 --> 00:51:26.690
do a custom install with
a select all option in it.

00:51:26.950 --> 00:51:33.420
So this sequence of installation is very
important over here because otherwise,

00:51:33.420 --> 00:51:37.630
if you don't have Java installed,
QuickTime wouldn't know where

00:51:37.640 --> 00:51:41.340
to install the QuickTime for
Java pieces so that your applets

00:51:41.340 --> 00:51:43.820
and application will run properly.

00:51:45.030 --> 00:51:48.100
So this is the proper
sequence of installation for

00:51:48.210 --> 00:51:50.240
QuickTime for Java on Windows.

00:51:50.320 --> 00:51:59.040
So we decided that besides this,
there are some other issues revolving

00:51:59.040 --> 00:52:05.790
around QuickTime for Java installation
if developers are releasing applications

00:52:05.790 --> 00:52:10.860
with their own private VMs and we have to
basically deal with those issues as well.

00:52:11.820 --> 00:52:17.010
So,
you can license the QuickTime installer

00:52:17.010 --> 00:52:21.220
itself by going to this

00:52:23.000 --> 00:52:38.200
[Transcript missing]

00:52:38.390 --> 00:52:41.980
So there are two ways of
writing a custom installer.

00:52:41.980 --> 00:52:45.200
Either you license the
individual pieces of QuickTime.

00:52:45.340 --> 00:52:49.490
So there are three pieces in QuickTime,
the DLLs-- sorry,

00:52:49.550 --> 00:52:53.270
the DLLs and the library.

00:52:53.640 --> 00:52:59.390
We have facilitated the developers or
the application writers to basically

00:52:59.390 --> 00:53:00.900
license the individual pieces.

00:53:00.900 --> 00:53:03.740
So what we do is we
give the pieces to you,

00:53:03.740 --> 00:53:08.670
and you can then basically take care of
installing the pieces wherever you want

00:53:08.670 --> 00:53:11.420
so your applications can run properly.

00:53:11.420 --> 00:53:15.150
In case of private Java VMs, as I said,
the standard installation for

00:53:15.230 --> 00:53:19.620
QuickTime for Java won't be able
to find the private Java VM that

00:53:19.620 --> 00:53:24.260
the application uses because we
basically look for registry entries,

00:53:24.260 --> 00:53:26.740
and private Java VMs don't
have registry entries.

00:53:26.760 --> 00:53:34.030
And that leads to problems of where
to put the QuickTime for Java pieces.

00:53:34.030 --> 00:53:37.660
Besides that,
you can also modify the .ini file for

00:53:37.660 --> 00:53:40.760
the standalone QuickTime installation.

00:53:41.420 --> 00:53:47.370
The .ini file is a quicktime installer in
which you set the QTJava = true variable,

00:53:47.380 --> 00:53:51.690
and that will basically tell
QuickTime installer that if you

00:53:51.690 --> 00:53:56.760
find this variable set to true,
just go ahead and install QuickTime for

00:53:56.760 --> 00:53:59.710
Java pieces in the right directory.

00:54:01.700 --> 00:54:04.370
All right, so that's for it that I have.

00:54:04.570 --> 00:54:09.940
This is the contact information we have
for developer support and information.

00:54:16.600 --> 00:54:17.760
This is the roadmap.

00:54:17.760 --> 00:54:21.130
We have the QuickTime feedback
forum going on right now,

00:54:21.130 --> 00:54:24.480
actually, in which they're discussing.

00:54:24.480 --> 00:54:28.530
And we have all these other sessions.
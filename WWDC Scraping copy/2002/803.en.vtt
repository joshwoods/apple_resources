WEBVTT

00:00:00.840 --> 00:00:02.200
Good morning.

00:00:02.270 --> 00:00:09.640
I'd like to welcome you to session 803,
the Mac OS X Networking Overview session.

00:00:09.640 --> 00:00:13.530
I have the privilege of
introducing this session.

00:00:13.550 --> 00:00:17.000
I'm pretty satisfied that the room
is filled pretty well out here.

00:00:17.570 --> 00:00:21.580
This session is one of the more
famous sessions during WWDC,

00:00:21.580 --> 00:00:24.500
at least over the past several years.

00:00:24.500 --> 00:00:27.500
We've had some great questions
come up in the session,

00:00:27.500 --> 00:00:29.680
and I'm sure today will
be no exception to that.

00:00:29.740 --> 00:00:35.270
So let me introduce Vincent Lubet,
who is the manager for CoreOS Networking.

00:00:35.270 --> 00:00:36.250
Thank you.

00:00:46.990 --> 00:00:49.570
So here's what we're going to go through.

00:00:49.570 --> 00:00:54.030
So the overall architecture
of the networking in Mac OS X.

00:00:54.030 --> 00:00:59.120
There's been quite a lot of new
things in the years since we

00:00:59.120 --> 00:01:02.190
introduced Mac OS X last March.

00:01:03.700 --> 00:01:08.900
And also we go through a good deal of
the session will be about the APIs.

00:01:08.900 --> 00:01:18.290
There's a large set of APIs you can use,
and some hints and tips.

00:01:18.300 --> 00:01:21.600
So here is the overall architecture.

00:01:21.600 --> 00:01:28.660
So the basis in the core ways of
the networking stack is in Darwin,

00:01:28.660 --> 00:01:33.670
and all of that can be
taken advantage by that.

00:01:33.680 --> 00:01:39.690
So the application environment
where they have higher level APIs.

00:01:40.140 --> 00:01:42.160
So it's the same.

00:01:42.730 --> 00:01:45.200
I mean, those are our ongoing goals.

00:01:45.200 --> 00:01:47.980
It hasn't changed since last year
when we did the presentation.

00:01:48.150 --> 00:01:51.100
So ease of use is very important.

00:01:51.220 --> 00:01:57.490
We'd like to have the networking
as transparent as possible.

00:01:57.590 --> 00:02:01.500
Performance is very important for us.

00:02:01.760 --> 00:02:06.430
Both in terms for end user experience,
but also because that's the same

00:02:06.440 --> 00:02:10.600
stack that is used by Mac OS X server.

00:02:10.600 --> 00:02:14.400
Extensibility, we'd like to extend the,
I mean, to allow to extend the

00:02:14.400 --> 00:02:19.630
function of the stacks,
and compliance with standards,

00:02:19.630 --> 00:02:29.210
going through new,
embracing new standards as they come up.

00:02:30.570 --> 00:02:35.640
So that's kind of summarized
what the features we have.

00:02:35.910 --> 00:02:41.150
So we have both TCP/IP and
Apple Protocol stack.

00:02:41.560 --> 00:02:46.660
For the link layers,
we support Ethernet and PPP,

00:02:46.660 --> 00:02:48.700
and also PPPoE.

00:02:48.700 --> 00:02:53.700
Mac OS X also comes up with
built-in firewall and NAT daemon.

00:02:53.700 --> 00:02:57.890
Also,
it allows for dynamic configuration,

00:02:57.890 --> 00:03:00.260
so it ties into the ease of use.

00:03:00.270 --> 00:03:05.500
You don't need to restart,
or we try to reconfigure the

00:03:05.500 --> 00:03:08.340
system as dynamically as possible.

00:03:08.340 --> 00:03:14.180
And also, we have new, this year in fact,
is the full set of zero-conf protocol

00:03:14.360 --> 00:03:18.270
that are supporting the support,
the basis for Rendezvous.

00:03:18.300 --> 00:03:23.240
So, the core networking,
which is mostly in the kernel,

00:03:23.240 --> 00:03:27.250
and also some BSD layers
at the library level.

00:03:27.630 --> 00:03:33.710
So it's based on FreeBSD.

00:03:33.900 --> 00:03:40.550
The API at this level that can be used
by applications is the Socket Level API,

00:03:40.550 --> 00:03:40.550
which

00:03:40.700 --> 00:03:44.400
is more or less equivalent to the
Open Transport APIs for Mac OS X.

00:03:44.400 --> 00:03:52.620
So the benefit of that is that it's
easy to port Unix applications.

00:03:52.620 --> 00:03:57.080
So it's not necessary that we encourage
new development of new applications

00:03:57.080 --> 00:04:03.150
to be based on the Socket API,
but it allows for easy

00:04:03.150 --> 00:04:06.080
port of applications.

00:04:07.880 --> 00:04:10.870
What's new in Jaguar?

00:04:11.030 --> 00:04:14.870
So we, since last year,
the networking stack was

00:04:14.930 --> 00:04:18.080
based on the FreeBSD 3.1.

00:04:18.100 --> 00:04:24.570
It was starting to show its edge,
and so we did a complete

00:04:24.650 --> 00:04:26.250
overhaul of the stack.

00:04:29.730 --> 00:04:34.330
brought in a number of bug fixes,
which are always welcome.

00:04:34.340 --> 00:04:36.700
We also updated the
firewall and NAT daemon.

00:04:36.700 --> 00:04:46.700
But the big pieces were the
inclusion of IPv6 and IPSec.

00:04:47.340 --> 00:04:51.300
They are based on the implementation
from the Kamei Consortium in Japan,

00:04:51.300 --> 00:04:54.200
where IPv6 is very important.

00:04:54.200 --> 00:04:59.350
And also something new in
Jaguar is the support for

00:04:59.350 --> 00:05:06.910
PPTP as a basis of a VPN client.

00:05:07.610 --> 00:05:07.650
So in addition to

00:05:08.370 --> 00:05:14.320
The networking stack in
Mac OS X is not exactly the

00:05:14.320 --> 00:05:15.840
same implementation as FreeBSD.

00:05:15.840 --> 00:05:22.600
We did some, I mean, the Darwin kernel is
multi-threaded and preemptive,

00:05:22.670 --> 00:05:27.920
which is so we have some
different ways of protecting,

00:05:27.920 --> 00:05:30.200
for example,
the critical section in the kernel.

00:05:30.200 --> 00:05:36.380
Also, the mBuff network buffers
are implementation.

00:05:36.900 --> 00:05:42.280
I mean, it's different from
FreeBSD and allows for...

00:05:43.500 --> 00:06:14.400
[Transcript missing]

00:06:14.820 --> 00:06:19.890
If some of you came to the
Darwin presentation yesterday,

00:06:19.900 --> 00:06:25.690
you have heard that we, I mean,
developing in a kernel comes

00:06:26.090 --> 00:06:29.930
with a lot of responsibility,
so we'll talk a little

00:06:29.930 --> 00:06:33.610
bit in this session,
in the session 8 or 9,

00:06:33.710 --> 00:06:36.180
about what are the constraints.

00:06:36.180 --> 00:06:41.700
But, I mean,
if you really need to write an NKE,

00:06:41.700 --> 00:06:46.280
we encourage you to work with us
because the current solution is,

00:06:46.280 --> 00:06:46.280
you know,

00:06:46.400 --> 00:06:49.360
I mean, the implementation certainly
will change of the kernel,

00:06:49.360 --> 00:06:52.970
and so we need to work with you
if you develop an NKE so that

00:06:52.970 --> 00:06:55.840
you can be ready for change.

00:06:57.800 --> 00:08:17.800
[Transcript missing]

00:08:18.100 --> 00:09:54.000
[Transcript missing]

00:09:54.520 --> 00:09:55.660
PPP also.

00:09:55.750 --> 00:09:59.630
So PPP is built in in Mac OS X.

00:09:59.660 --> 00:10:02.540
It's based on the PPPd,
which is the open source.

00:10:02.580 --> 00:10:06.000
I mean, one of the most popular open
source implementation of PPP.

00:10:06.100 --> 00:10:10.480
It's based on PPP, but again,
we've added a number of enhancements so

00:10:10.480 --> 00:10:13.240
that it's not the same implementation.

00:10:13.260 --> 00:10:18.240
You cannot just build your
own PPPd and just replace it.

00:10:18.770 --> 00:10:25.360
So, Apple Enhancement is our
implementation of PPPoE for DSL.

00:10:25.360 --> 00:10:29.870
It supports CCL script,
the same modem script that you used

00:10:29.870 --> 00:10:32.540
on Mac OS 9 are supported in Mac OS X.

00:10:34.140 --> 00:10:37.830
For an API,
currently the only public API to

00:10:37.940 --> 00:10:41.140
control PPP is in Open Transport.

00:10:41.160 --> 00:10:45.470
So, we support the OTPPP API set,
and in Jaguar we fixed

00:10:45.480 --> 00:10:48.660
a number of bugs too,
so that it's more useful.

00:10:48.660 --> 00:10:54.620
And the most important difference
between the standard PPPd is that it's

00:10:54.620 --> 00:11:01.770
integrated with the system configuration
that provides dynamic configuration.

00:11:01.780 --> 00:11:07.520
And so, a new injection... In Jaguar,
also the important new feature

00:11:07.610 --> 00:11:13.800
in Jaguar is the PPPd client that
provides VPN connectivity with Windows.

00:11:15.050 --> 00:11:20.000
So, those were the, I mean,
we did also a lot,

00:11:20.000 --> 00:11:22.710
we fixed a great number of bugs.

00:11:22.800 --> 00:11:27.300
The other day I looked at it,
I think it's in the order

00:11:27.350 --> 00:11:29.930
of 300 bugs were fixed.

00:11:29.990 --> 00:11:32.480
So, we improved performance.

00:11:32.480 --> 00:11:39.180
I think that now we can easily saturate
gigabit links with TCP traffic.

00:11:39.820 --> 00:11:45.230
We also provide for, in Jaguar,
we allow for detaching

00:11:45.350 --> 00:11:47.580
of network interfaces.

00:11:47.870 --> 00:11:55.510
That means that if you have, for example,
an Ethernet device in a USB port,

00:11:56.450 --> 00:12:00.710
I mean, an Ethernet USB device.

00:12:00.710 --> 00:12:05.300
Now you can, when you unplug it,
the stack will clean up all the

00:12:05.300 --> 00:12:11.160
reference to this device so that you
can effectively attach and detach it.

00:12:11.240 --> 00:12:14.180
And it was not possible up to Jaguar.

00:12:15.560 --> 00:12:19.090
Also, we've updated many,
many main pages,

00:12:19.170 --> 00:12:25.160
which is one of the primary source
of documentation for a lot of the

00:12:25.160 --> 00:12:27.470
APIs we have at the socket level.

00:12:27.480 --> 00:12:35.870
We also fixed the implementation
of the NDRV protocol family.

00:12:35.870 --> 00:12:42.920
NDRV is Network Driver.

00:12:42.920 --> 00:12:42.920
It's not the same as the...

00:12:43.080 --> 00:12:47.220
The NDRV graphics drivers.

00:12:47.310 --> 00:12:49.860
So it allows for to develop
a user and protocol stack.

00:12:49.900 --> 00:12:55.980
So for example, it's a way to, I mean,
you can take advantage of that instead

00:12:55.990 --> 00:12:58.680
of implementing a protocol as an NKE.

00:12:58.680 --> 00:13:04.340
If it's just for specific and
protocol specific for an application,

00:13:04.340 --> 00:13:07.170
you can use those socket types.

00:13:07.180 --> 00:13:11.560
And also new in Jaguar,
and it was also something that a lot

00:13:11.620 --> 00:13:15.780
of people asked Apple to provide,
is SNMP.

00:13:15.780 --> 00:13:19.920
So it's based on the NetSNMP open
source implementation.

00:13:19.920 --> 00:13:26.730
And it has both console and
agents implementation and

00:13:26.730 --> 00:13:34.390
supports the basic MIBs,
MIB2, and things like that.

00:13:35.480 --> 00:13:39.820
So network configuration,
so it's a cornerstone of the ease of

00:13:39.940 --> 00:13:44.990
use of the networking in Mac OS X.

00:13:45.200 --> 00:13:49.870
So certainly you know about the
network preference panel and

00:13:49.870 --> 00:13:54.280
where you can see a set of-- Oops.

00:13:55.400 --> 00:13:57.400
The Mac OS X is a set of services.

00:13:57.570 --> 00:14:04.180
Services provide the configuration
for a network interface,

00:14:04.180 --> 00:14:05.390
if you wish.

00:14:05.490 --> 00:14:09.690
So, for example, for Ethernet, PPP,
and others.

00:14:09.700 --> 00:14:13.860
So, more than one service
can be active at a time.

00:14:13.860 --> 00:14:19.930
So, that's why we support Mac OS X,
support multi-homing, and also new,

00:14:19.980 --> 00:14:24.690
I think in Jaguar, we support also the
configuration of one service.

00:14:25.430 --> 00:14:29.820
I mean, at least one network interface
can be configured to have

00:14:29.820 --> 00:14:31.800
more than one IP address.

00:14:31.800 --> 00:14:35.390
So, it's multi-link,
multi-homing that we support in Jaguar,

00:14:35.390 --> 00:14:39.960
right at the user interface level.

00:14:39.960 --> 00:14:43.270
So,
the configuration is dynamically updated.

00:14:43.270 --> 00:14:48.150
That means that there's a daemon that
watches for the status of the link.

00:14:48.150 --> 00:14:50.560
So, that's where that supports
the plugging and plugging,

00:14:50.560 --> 00:14:53.370
joining airport networks,
and things like that.

00:14:53.400 --> 00:14:58.400
And all this is managed by the
system configuration framework.

00:14:58.400 --> 00:15:02.760
So,
that has implementation of the mechanism,

00:15:02.760 --> 00:15:05.650
but also APIs that you can use.

00:15:05.700 --> 00:15:09.790
So, different set of APIs.

00:15:09.790 --> 00:15:15.600
So, one, so access to the configuration,
that means the stored information.

00:15:15.660 --> 00:15:19.390
So, something you can read and write.

00:15:21.400 --> 00:15:27.620
Which is, so the current state of the
configuration depends on the,

00:15:27.650 --> 00:15:34.880
for example, the status of the link,
and also if you have, for example,

00:15:34.920 --> 00:15:38.740
the IP address can be acquired
dynamically with DHCP.

00:15:38.740 --> 00:15:42.340
So, it's the second line,
the state of the network,

00:15:42.340 --> 00:15:44.830
you can have dynamic information.

00:15:46.490 --> 00:15:52.780
So also, something that has been, I mean,
also that a lot of application who wants

00:15:52.780 --> 00:15:59.040
to behave correctly before issuing,
opening a socket or

00:15:59.190 --> 00:16:04.510
network endpoint will,
to prevent automatic dialing of PPP,

00:16:04.640 --> 00:16:11.210
we recommend that those applications
first check for accessibility so

00:16:11.270 --> 00:16:14.890
that they prevent unwanted dialing.

00:16:14.900 --> 00:16:18.650
And there's a replacement
for the Open Transport,

00:16:18.650 --> 00:16:23.320
the Mac OS 9 TCP will dial,
and that's also part of the

00:16:23.390 --> 00:16:26.930
system configuration framework.

00:16:27.460 --> 00:16:31.830
We have also a notification mechanism
in system configuration so that you

00:16:31.930 --> 00:16:34.230
can be notified when something changes.

00:16:34.230 --> 00:16:37.890
And that's the basis also of the dynamic.

00:16:38.120 --> 00:16:42.240
The dynamicism of Mac OS X networking.

00:16:42.350 --> 00:16:51.310
So, all those APIs are available in,
have been available since Mac OS X 10.1.

00:16:51.450 --> 00:16:58.970
And DTS came up with a very good sample
code called MoreSCF that allows you

00:16:59.180 --> 00:17:03.020
to understand how to use those APIs.

00:17:03.140 --> 00:17:09.950
It's a rich set of API,
and that's a very good guide to them.

00:17:10.430 --> 00:17:13.490
Rendezvous is new in Jaguar.

00:17:13.490 --> 00:17:19.570
It's based on the ZeroConf IETF

00:17:19.800 --> 00:17:23.920
and the NRC, so it provides for, I mean,
it allows for networking,

00:17:23.920 --> 00:17:26.930
local networking that
always works a little bit,

00:17:26.930 --> 00:17:29.090
just like Apple Talk, in fact.

00:17:29.100 --> 00:17:32.900
So, but it's based on TCP IP standard.

00:17:32.900 --> 00:17:40.940
Most, I mean, it's as much as possible
rendezvous and zero-conf re-users,

00:17:41.410 --> 00:17:46.250
already established
standard like DNS and DHCP,

00:17:46.260 --> 00:17:49.140
with very small tweaks.

00:17:49.140 --> 00:17:51.410
So--

00:17:51.640 --> 00:17:56.910
So it makes really, that's the,
I lost for,

00:17:58.850 --> 00:18:01.760
Just plug and play networking.

00:18:01.800 --> 00:18:05.850
And there are certainly ways you
can maybe take advantage in your

00:18:05.850 --> 00:18:08.100
application if you provide the service.

00:18:08.110 --> 00:18:12.230
It's very easy to just register
your service and make it

00:18:12.230 --> 00:18:14.530
available on the network.

00:18:14.530 --> 00:18:20.900
And to know more about Rendezvous
and Zero Configuration networking,

00:18:21.000 --> 00:18:27.170
you should check session 811
where they go in deeper details.

00:18:28.780 --> 00:18:33.180
Okay, now in a year we've learned,
I mean in many years,

00:18:33.180 --> 00:18:38.550
we've learned a great deal about what
are the best practices and how to

00:18:38.550 --> 00:18:41.460
write for networking and also Mac OS X.

00:18:41.460 --> 00:18:45.150
So solutions that used to work well,
for example,

00:18:45.150 --> 00:18:50.610
with Open Transport on Mac OS X,
don't necessarily work well in Mac OS X.

00:18:51.530 --> 00:18:58.040
So for example, one of the big,
I mean the biggest problem and the thing

00:18:58.040 --> 00:19:06.400
that can affect the most performance
and also the user experience is polling.

00:19:06.400 --> 00:19:10.220
Polling uses,
so all the CPU and Mac OS X,

00:19:10.220 --> 00:19:17.190
which is a multitasking system, it hurts,
you know, other processes.

00:19:17.200 --> 00:19:24.330
So there are many system services that
are just... implemented in user land,

00:19:24.330 --> 00:19:25.150
not in the kernel.

00:19:25.160 --> 00:19:28.660
So they run barely at...

00:19:28.940 --> 00:19:32.830
Just the priorities of those
processes is not very much

00:19:32.870 --> 00:19:36.300
higher than a normal application.

00:19:36.390 --> 00:19:41.140
So, and there are many ways to,
many solutions.

00:19:41.140 --> 00:19:46.140
I mean, we have all the APIs out there
that allows you to either to block.

00:19:46.140 --> 00:19:48.460
I mean, that's the typical problem.

00:19:48.460 --> 00:19:53.540
A lot of Unix tools, that's what they do.

00:19:53.590 --> 00:19:58.590
They block or you be event-driven.

00:19:58.630 --> 00:20:14.980
And certainly what you can use is to use,
for example, at the socket layer,

00:20:14.980 --> 00:20:14.980
you can use the select system
code to wait in a thread,

00:20:14.980 --> 00:20:14.980
for example, and block for network,
wait for network activity.

00:20:14.980 --> 00:20:14.980
And it's not,

00:20:15.400 --> 00:20:35.100
[Transcript missing]

00:20:35.420 --> 00:20:40.400
The Open Transport stack
was more tolerant about what

00:20:40.400 --> 00:20:41.860
size of buffer you're using.

00:20:41.860 --> 00:20:48.740
So you have to find a good compromise
between two large and two small buffers.

00:20:48.750 --> 00:20:53.780
Because if it's too small,
you have a lot of context switches.

00:20:53.780 --> 00:20:58.760
So the pathological case is reading
or writing one byte at a time,

00:20:58.760 --> 00:21:00.060
for example.

00:21:01.020 --> 00:21:08.060
And if you also use two large buffers,
I mean, I've seen applications trying

00:21:08.220 --> 00:21:11.880
to use megabytes of buffers to
pass through the socket layer,

00:21:11.880 --> 00:21:12.680
read or write.

00:21:12.890 --> 00:21:17.600
That's not, I mean, it doesn't,
it just puts more overhead

00:21:17.830 --> 00:21:22.170
on the overall system,
but doesn't get any better

00:21:22.280 --> 00:21:24.670
throughput if you want.

00:21:24.800 --> 00:21:32.110
So you have to find, you know, I mean,
a good... So the question is,

00:21:32.110 --> 00:21:35.390
what is a good value, and that depends.

00:21:35.400 --> 00:21:43.210
But certainly something in the order of,
you know, a few, I don't know,

00:21:43.210 --> 00:21:49.500
something like 1010 to 40k, 60k,
is something that is good for TCP,

00:21:49.500 --> 00:21:50.500
for example.

00:21:50.580 --> 00:21:53.000
What you want to try to
achieve is streaming.

00:21:53.000 --> 00:21:57.400
And so something you have to watch for,
so two things you have to watch for

00:21:57.500 --> 00:21:59.760
is the size of your socket buffer.

00:22:00.100 --> 00:22:03.760
So by default,
I think they are in the range of 32k.

00:22:03.760 --> 00:22:05.350
And...

00:22:07.110 --> 00:22:13.930
And also the other parameter
is the size of the buffer you

00:22:13.930 --> 00:22:17.890
read in and out of the kernel.

00:22:17.980 --> 00:22:23.510
There is something also we've
seen some pathological case where

00:22:24.630 --> 00:22:31.450
In the BSD implementation of TCP/IP,
the socket buffer really corresponds

00:22:31.520 --> 00:22:33.700
to your received window size.

00:22:33.700 --> 00:22:36.220
So if your application
is not fast enough,

00:22:36.220 --> 00:22:40.420
for example,
and doesn't empty the socket buffer size,

00:22:40.420 --> 00:22:42.500
the advertised window will shrink.

00:22:42.760 --> 00:22:49.490
And that means that you will see
the hiccups in the stream of data.

00:22:49.500 --> 00:22:55.500
So that means that your
process should be responsive.

00:22:55.730 --> 00:23:03.600
And use, I mean, when it receives data,
doesn't try to receive data.

00:23:03.680 --> 00:23:06.300
For example, there's one flag you
can use in the socket,

00:23:06.310 --> 00:23:08.900
which is the message,
"Wait all." You shouldn't wait

00:23:08.900 --> 00:23:10.840
for all the data necessarily.

00:23:10.950 --> 00:23:14.900
You should,
as soon as you can read a few K,

00:23:14.900 --> 00:23:18.890
you should try to empty
the socket buffer.

00:23:18.950 --> 00:23:23.060
And we'll go into a little bit
more detail in session 809,

00:23:23.060 --> 00:23:25.100
which is Advanced Networking.

00:23:25.300 --> 00:23:29.740
Also, something that is very important
for applications is that,

00:23:29.750 --> 00:23:35.890
and let's say some of the Unix-like,
now it's more the Unix side

00:23:35.950 --> 00:23:40.040
of the network applications,
is that Mac OS X is a

00:23:40.040 --> 00:23:42.550
very dynamic system.

00:23:42.560 --> 00:23:48.340
We have portables, we have airport,
everything you can plug and unplug.

00:23:48.410 --> 00:23:53.350
So, applications should be aware that
there's not a single IP address,

00:23:53.540 --> 00:23:58.350
that the IP address changes over time.

00:23:59.030 --> 00:24:03.390
And for example, servers should, I mean,
there are very few cases where

00:24:03.390 --> 00:24:07.830
servers should know about
which IP address it binds to.

00:24:07.830 --> 00:24:12.220
So they should just use any IP address.

00:24:12.220 --> 00:24:14.520
And the same for clients.

00:24:14.520 --> 00:24:19.760
There's no real good reason to bind
to a specific address or port number.

00:24:19.760 --> 00:24:26.180
If you don't specify one,
the TCP stack will choose one for you,

00:24:26.240 --> 00:24:28.300
an ephemeral one.

00:24:31.300 --> 00:24:34.220
And also, you have

00:24:34.300 --> 00:26:41.800
[Transcript missing]

00:26:42.660 --> 00:26:45.790
Finally,
just a word about the Socket API.

00:26:45.850 --> 00:26:49.060
So that's the native API,
that's the lowest level API we have

00:26:49.100 --> 00:26:51.600
in the system for applications to use.

00:26:51.940 --> 00:26:57.580
There's a lot of open source code
available that you can learn about it.

00:26:57.600 --> 00:27:01.090
There's a very good book,
Unix Network Programming

00:27:01.100 --> 00:27:09.860
by Richard Stevens,
which is kind of the bible for us.

00:27:10.650 --> 00:27:14.900
Because we have the Socket APIs, I mean,
we really, really encourage all

00:27:14.900 --> 00:27:18.680
Carbon applications that still,
a lot of Carbon applications have,

00:27:18.770 --> 00:27:22.840
in fact, were ported maybe from
Unix or maybe Windows,

00:27:22.840 --> 00:27:27.290
and they have a layer,
an emulation layer of Socket,

00:27:27.340 --> 00:27:32.660
so that calls Open Transport,
and that was fine on Mac OS X,

00:27:32.660 --> 00:27:35.390
but if you run this
Carbon application on X,

00:27:35.400 --> 00:27:39.700
you have, so you have the pseudo-Socket
layer that calls Open Transport,

00:27:39.700 --> 00:27:44.910
which is itself called the Socket layer,
so you have two layers of

00:27:44.910 --> 00:27:49.100
emulations where you lose
performance and also correctness.

00:27:49.100 --> 00:27:54.520
And,
but the Socket-level APIs can be complex,

00:27:54.520 --> 00:27:59.980
and Mac OS X has a rich
set of higher-level APIs,

00:27:59.980 --> 00:28:03.710
a little bit provided
with more abstractions,

00:28:03.710 --> 00:28:05.700
and allows for...

00:28:06.900 --> 00:28:20.100
[Transcript missing]

00:28:28.350 --> 00:28:33.450
So Vincent asked me here today to talk
some about the APIs that are available

00:28:33.450 --> 00:28:36.220
to you above the operating system level.

00:28:36.340 --> 00:28:40.450
Hmm, I think I'm holding this wrong.

00:28:43.610 --> 00:28:48.600
So what I'm going to talk about
is what APIs are available to you,

00:28:48.610 --> 00:28:52.120
and then we're going to look at each API,
or at least the largest APIs in depth.

00:28:52.140 --> 00:28:55.400
And for each one, we're going to talk
about what that API does,

00:28:55.440 --> 00:29:00.600
what strengths it has as an API,
what its limitations are,

00:29:00.940 --> 00:29:05.700
when you should use it,
and what's new with them since 10.1.

00:29:07.340 --> 00:29:08.120
There they are.

00:29:08.230 --> 00:29:09.700
Nice long list.

00:29:09.820 --> 00:29:13.500
In Carbon,
we have URL access and Internet config.

00:29:13.590 --> 00:29:18.590
In Cocoa, NSURL and NSURL handle,
as well as the new NSNetService

00:29:18.740 --> 00:29:21.210
and NSNetService browser.

00:29:22.700 --> 00:29:27.350
At the core services level,
we have CF Network, Web Services Core,

00:29:27.460 --> 00:29:33.600
a number of pieces from Core Foundation,
that's CFURL, CF Socket, and CF Stream,

00:29:33.600 --> 00:29:36.260
and then finally Open Transport.

00:29:37.360 --> 00:29:39.690
So how does that all lay out?

00:29:39.810 --> 00:29:41.920
Looks more or less like that.

00:29:42.060 --> 00:29:43.540
You can see where each of the pieces are.

00:29:43.540 --> 00:29:46.690
The important thing to notice here is
that everything is built on the solid

00:29:46.690 --> 00:29:49.380
foundation provided by BSD Sockets.

00:29:49.490 --> 00:29:53.370
Everything I'm talking
about works through Sockets,

00:29:53.380 --> 00:29:56.140
works through TCP/IP by and large.

00:29:56.460 --> 00:29:59.430
The other important thing to notice
is that anything in the core services

00:29:59.480 --> 00:30:01.890
layer is available to any application.

00:30:01.920 --> 00:30:05.030
It's also available to most any daemon.

00:30:07.110 --> 00:30:09.480
So with that,
let's just start with the APIs.

00:30:09.520 --> 00:30:12.440
I'm going to go pretty much from the
top of the stack down to the bottom.

00:30:12.440 --> 00:30:15.980
So I'm starting the furthest
away from Sockets and moving

00:30:15.980 --> 00:30:17.810
down into the basement.

00:30:18.050 --> 00:30:20.830
So at the very top we have URL access.

00:30:21.020 --> 00:30:26.850
URL access provides basic
APIs for up and downloading URLs.

00:30:27.000 --> 00:30:30.220
It's basically intended as a
convenience API that's totally

00:30:30.220 --> 00:30:32.600
focused on just fetching the URL.

00:30:32.740 --> 00:30:35.770
You don't want to look at the URL,
you don't care about the

00:30:36.120 --> 00:30:38.630
network configuration,
just get me the data.

00:30:39.500 --> 00:30:41.990
As such,
it's going to automatically pick up any

00:30:41.990 --> 00:30:45.380
system settings that are on the computer.

00:30:45.970 --> 00:30:50.600
But it also provides relatively
few options based on the scheme.

00:30:50.600 --> 00:30:53.390
So if you need to do some
tricky piece of HTTP,

00:30:53.560 --> 00:30:56.670
this is probably too high level for you.

00:30:57.410 --> 00:31:02.970
Out of the box, it supports HTTP, HTTPS,
FTP, and file schemes.

00:31:02.970 --> 00:31:06.400
And it is part of the
Carbon APIs providing source level

00:31:06.490 --> 00:31:10.900
compatibility back to Mac OS 8.6.

00:31:12.590 --> 00:31:16.160
So its strengths are its simplicity,
really.

00:31:16.220 --> 00:31:19.960
You don't have to know much about
what's going on with the URL.

00:31:20.040 --> 00:31:22.290
Just go get it for me.

00:31:22.470 --> 00:31:26.050
It provides a number of
options for extra processing,

00:31:26.180 --> 00:31:28.780
including, for instance,
populating a file or directory.

00:31:28.780 --> 00:31:32.350
There are also flags for
things like UI display and

00:31:32.350 --> 00:31:34.810
for automatic decompression.

00:31:36.700 --> 00:31:38.780
And of course,
one of its big strengths is it provides

00:31:38.950 --> 00:31:42.200
source compatibility to Mac OS 9.

00:31:44.900 --> 00:31:47.600
Okay, so what are its limitations?

00:31:47.650 --> 00:31:50.970
First one is there's no way to
add any support for new schemes.

00:31:51.150 --> 00:31:53.740
If we don't provide it,
there's no plug-in model,

00:31:53.740 --> 00:31:55.500
there's no way you can supply it.

00:31:55.620 --> 00:31:57.490
Also, the API is beginning to age.

00:31:57.560 --> 00:31:59.490
It did start in the OS 9 days.

00:31:59.560 --> 00:32:02.450
As such, you will see some ties
that hook in directly to,

00:32:02.450 --> 00:32:04.080
for instance, the Thread Manager.

00:32:04.250 --> 00:32:08.450
Those are no longer really
meaningful in the Mac OS X world.

00:32:09.340 --> 00:32:13.740
In Jaguar and on Mac OS X,
there are some unimplemented features.

00:32:13.740 --> 00:32:17.480
The most notable I've called out here
so that you can know to avoid them.

00:32:18.450 --> 00:32:21.390
Progress Bar Display via
either URL upload or

00:32:21.390 --> 00:32:23.510
download is not implemented.

00:32:23.560 --> 00:32:27.060
Automatic Decompression,
also not implemented.

00:32:28.610 --> 00:32:32.510
Also, as one of the older APIs,
there are some issues around Pthreads

00:32:32.510 --> 00:32:34.530
and cooperative threads coexisting.

00:32:34.540 --> 00:32:38.340
It did start as a
cooperative-threaded API,

00:32:38.440 --> 00:32:41.490
so it still carries some of that legacy.

00:32:42.920 --> 00:32:44.120
So when should you use it?

00:32:44.290 --> 00:32:46.100
Well,
you should use it if you need a strategy

00:32:46.100 --> 00:32:49.710
that has to work on both OS 9 and OS X.

00:32:50.180 --> 00:32:56.450
You should use it if you need a scheme
agnostic strategy that's based in Carbon.

00:32:56.810 --> 00:32:58.930
And you should use it when
you want that simplicity,

00:32:58.940 --> 00:33:02.380
when you don't want to know
anything about the details.

00:33:04.240 --> 00:33:08.750
We have done a fair bit of work
with URL access since 10.1.

00:33:08.760 --> 00:33:11.710
There have been a lot of bug fixes.

00:33:11.790 --> 00:33:15.700
We've got progress display
working now from inside URL open.

00:33:15.700 --> 00:33:20.100
We do a better job of scrubbing
failed transfers off the disk.

00:33:20.330 --> 00:33:22.400
Redirection is working.

00:33:22.530 --> 00:33:24.820
There's better event handling
and notification throughout.

00:33:24.820 --> 00:33:26.840
In particular,
system events are coming through

00:33:26.840 --> 00:33:28.760
cleanly now to your callbacks.

00:33:28.760 --> 00:33:31.970
And there's better error
handling throughout.

00:33:34.300 --> 00:33:37.160
The other Carbon API I'm going to
talk about some is Internet Config.

00:33:37.160 --> 00:33:41.070
You probably all know
what Internet Config is.

00:33:41.130 --> 00:33:42.150
You've probably all used it.

00:33:42.400 --> 00:33:46.940
It holds basic networking
settings of a variety of kinds.

00:33:46.940 --> 00:33:51.240
So included in that are web proxies,
instructions on which helper

00:33:51.370 --> 00:33:55.200
apps should be used for
downloading which kinds of URLs.

00:33:55.200 --> 00:33:58.630
There's an elaborate type
database that maps MIME type

00:33:58.630 --> 00:34:00.820
to type creator into extension.

00:34:02.270 --> 00:34:06.870
Some people have used Internet Config to
store app specific preferences as well.

00:34:06.900 --> 00:34:09.880
And you will see a handful
of user preferences in the

00:34:09.960 --> 00:34:12.210
Internet Config database as well.

00:34:12.220 --> 00:34:18.710
It is primarily a legacy Carbon API that
was created on Mac OS 8 and 9,

00:34:18.710 --> 00:34:23.220
and that we have carried
forward as part of Carbon.

00:34:23.950 --> 00:34:27.400
Its strengths are precisely that
it is of such long standing,

00:34:27.400 --> 00:34:31.290
it's well known and well understood,
it's your only option on Mac OS 9,

00:34:31.300 --> 00:34:34.710
and it provides
compatibility with Mac OS 9.

00:34:35.150 --> 00:34:38.810
On the other hand,
on X it has a number of limitations.

00:34:39.060 --> 00:34:43.820
The implementation on Mac OS X is
not as efficient as it was on IX.

00:34:43.930 --> 00:34:47.700
You can mitigate this somewhat
by using ICBGN and ICN.

00:34:47.760 --> 00:34:52.490
There's an excellent tech note on
this if you want to look that up.

00:34:52.550 --> 00:34:56.760
If you just bracket your calls-- bracket
subsequent calls with ICBGN and ICN,

00:34:56.760 --> 00:34:59.800
you'll see a noticeable
performance increase.

00:35:00.200 --> 00:35:02.570
Some of the settings
inside Internet Config are

00:35:02.570 --> 00:35:05.460
dated and insufficient.

00:35:05.460 --> 00:35:07.720
There are, in many cases,
there's only a single setting provided,

00:35:07.820 --> 00:35:11.820
where in the modern world
you might expect several.

00:35:11.820 --> 00:35:14.690
Some settings are completely obsolete
and no longer meaningful at all.

00:35:14.800 --> 00:35:19.260
GetConfigFile and all of its
friends are a good example of that.

00:35:19.260 --> 00:35:21.320
And it's no longer the final authority.

00:35:21.320 --> 00:35:24.320
It's no longer the
repository for many settings.

00:35:24.320 --> 00:35:26.270
So when Internet Config fetches
some of those,

00:35:26.380 --> 00:35:28.620
it's going to have to go
through a translation layer,

00:35:28.620 --> 00:35:32.350
and there's a performance
hit with that translation.

00:35:32.820 --> 00:35:35.830
Also, for what it does,
it's going to force a higher level

00:35:35.830 --> 00:35:37.040
linkage that's really warranted.

00:35:37.040 --> 00:35:39.800
You're going to be linking at
the application services level,

00:35:39.990 --> 00:35:42.260
where all you're really doing
is fetching a bunch of data,

00:35:42.260 --> 00:35:44.970
and you might want that at a lower level,
like core services or

00:35:44.970 --> 00:35:46.030
possibly even the OS.

00:35:48.910 --> 00:35:50.800
So at this point,
we're recommending that you

00:35:50.800 --> 00:35:55.030
only use Internet Config if
there's truly no other choice.

00:35:55.120 --> 00:35:59.230
Look instead for other
frameworks to provide your needs.

00:35:59.610 --> 00:36:02.400
The two big ones to be aware
of are System Configuration,

00:36:02.400 --> 00:36:05.140
which provides all the information
about your proxies and about

00:36:05.230 --> 00:36:07.300
the current network setting.

00:36:07.390 --> 00:36:10.040
Or Launch Services,
which knows how to open files

00:36:10.040 --> 00:36:14.000
and URLs and is maintaining that
database for you of mapping types

00:36:14.360 --> 00:36:17.590
to type creator to application.

00:36:19.390 --> 00:36:24.250
If you have used Internet Config to
store your app-specific preferences,

00:36:24.360 --> 00:36:25.100
stop it.

00:36:25.240 --> 00:36:28.280
Internet Config is a shared
resource on the system.

00:36:28.340 --> 00:36:32.700
Every preference you put there is a
burden to every other Carbon application.

00:36:32.830 --> 00:36:34.400
Instead, use CFPreferences.

00:36:34.400 --> 00:36:37.600
Keep your preferences in their own space.

00:36:39.480 --> 00:36:42.660
So, nothing new here.

00:36:42.740 --> 00:36:45.300
We haven't done a thing with
Internet config since 10.1.

00:36:48.110 --> 00:36:51.600
With that,
I'm going to move on to the Cocoa APIs.

00:36:51.770 --> 00:36:54.610
I'm going to start with
NSURL and NSURL Handle.

00:36:54.730 --> 00:36:57.640
These are sort of the
Cocoa equivalents of URL access.

00:36:57.640 --> 00:36:59.160
This is the convenience API.

00:36:59.470 --> 00:37:00.320
Here's a URL.

00:37:00.370 --> 00:37:01.260
I don't know nothing about it.

00:37:01.260 --> 00:37:03.420
Just get me the data.

00:37:03.750 --> 00:37:09.870
Unlike URL access, NSURL and NSURL Handle
exist below the UI layer,

00:37:09.910 --> 00:37:13.550
so they do not have integration
with some of the higher UI elements.

00:37:13.610 --> 00:37:16.790
But that also means they don't
force you to link against a full

00:37:16.790 --> 00:37:18.800
application framework to get it.

00:37:20.080 --> 00:37:22.760
Two classes, NSURL and NSURL Handle.

00:37:22.830 --> 00:37:25.160
NSURL just represents the URL.

00:37:25.210 --> 00:37:28.000
It's bridged to CFURL,
which you've probably used.

00:37:28.000 --> 00:37:31.570
NSURL Handle, on the other hand,
is the piece that actually

00:37:31.570 --> 00:37:33.160
performs the download.

00:37:33.160 --> 00:37:35.760
It's the piece with
the state engine in it.

00:37:35.830 --> 00:37:39.710
It's the piece that actually knows
how to build the network connection.

00:37:40.050 --> 00:37:42.720
These two classes together
were designed primarily as an

00:37:42.790 --> 00:37:47.240
infrastructure for handling URLs,
much of the same as Java Net URL is

00:37:47.240 --> 00:37:49.400
and its associated classes.

00:37:49.620 --> 00:37:54.240
However, out of the box,
we do provide support for HTTP, HTTPS,

00:37:54.240 --> 00:37:57.110
FTP, and file.

00:37:59.290 --> 00:38:02.850
So NSURL handles strengths are
really its integration with

00:38:02.940 --> 00:38:04.040
the surrounding frameworks.

00:38:04.040 --> 00:38:06.700
In particular,
it's well integrated with the run loop,

00:38:06.820 --> 00:38:10.500
which means you're going to have an
asynchronous API which nonetheless is

00:38:10.500 --> 00:38:13.080
not spawning any additional threads.

00:38:13.410 --> 00:38:15.490
It's easily extensible via subclassing.

00:38:15.490 --> 00:38:18.470
It's designed to be
extended via subclassing.

00:38:18.630 --> 00:38:21.540
And it's well integrated
into all the Cocoa APIs.

00:38:21.660 --> 00:38:24.640
So, for instance, the NSImage class,
as I'm showing here,

00:38:24.640 --> 00:38:27.580
can be initialized from
the contents of a URL.

00:38:27.580 --> 00:38:30.670
Well, NSURL handle is what's
actually doing the work.

00:38:30.670 --> 00:38:35.170
So if you extend NSURL handle,
NSImage is automatically going to

00:38:35.180 --> 00:38:40.620
know how to initialize itself from the
new kind of URL you've implemented.

00:38:41.740 --> 00:38:45.450
We're also seeing extremely
good performance under

00:38:45.490 --> 00:38:47.400
load using NSURL handle.

00:38:47.400 --> 00:38:51.160
And as just one example,
the mail application on Jaguar

00:38:51.780 --> 00:38:55.160
downloads all of the HTML mail,
all of the HTML images

00:38:55.160 --> 00:38:58.580
using NSURL handle,
all on the main thread.

00:38:58.610 --> 00:39:02.820
And we're not seeing any kind of
a delay in processing user events.

00:39:06.250 --> 00:39:08.900
So what are its limitations?

00:39:09.020 --> 00:39:13.500
Many of the extras that you get
with URL access are missing.

00:39:13.600 --> 00:39:15.900
In particular, there's no UI integration.

00:39:15.990 --> 00:39:18.830
We live below the UI level.

00:39:19.090 --> 00:39:22.300
And there's no way to do things
like automatic decompression,

00:39:22.300 --> 00:39:25.060
content handling,
automatic population of files,

00:39:25.150 --> 00:39:27.190
all of that kind of thing.

00:39:28.110 --> 00:39:31.860
The documentation for NSURL and
NSURL Handle is not complete.

00:39:31.990 --> 00:39:34.930
There is some there and
it will get you started.

00:39:34.930 --> 00:39:38.230
There's also some good
examples on the CD.

00:39:38.800 --> 00:39:42.800
And many of the Cocoa APIs,
which all started as file-based APIs,

00:39:42.800 --> 00:39:47.400
have not made the full transition
to accept arbitrary URLs.

00:39:49.740 --> 00:39:52.200
So when should you use it?

00:39:52.200 --> 00:39:56.210
Use it when you want a simple download
abstraction and for whatever reason

00:39:56.210 --> 00:39:58.970
you don't want to use URL access.

00:39:59.550 --> 00:40:01.860
Keep in mind that although
this is a Cocoa technology,

00:40:01.860 --> 00:40:05.100
we've reached the point now where
it is not a large burden for a

00:40:05.100 --> 00:40:08.060
Carbon application to link in foundation.

00:40:08.200 --> 00:40:14.370
So as a Carbon application,
an NSURL handle is available to you.

00:40:14.630 --> 00:40:18.880
It's also the only API on the system
that will allow you to automatically

00:40:18.880 --> 00:40:24.590
extend and add your own handling
for particular kinds of URLs.

00:40:24.590 --> 00:40:28.530
You can add your own scheme handler,
it will automatically be

00:40:28.530 --> 00:40:30.590
picked up by the Cocoa APIs.

00:40:32.400 --> 00:40:37.320
We've made a lot of changes and
additions to NSURL handle since 10.1.

00:40:37.330 --> 00:40:39.340
We've added support for FTP.

00:40:39.420 --> 00:40:42.300
A lot of the bugs have been shaken out.

00:40:42.420 --> 00:40:48.940
We've moved to an asynchronous
domain name lookup,

00:40:49.050 --> 00:40:53.560
so you'll no longer block waiting
for us to get the answer to what

00:40:53.560 --> 00:40:56.100
the IP address is for a given host.

00:40:56.460 --> 00:41:00.770
And we have integration with system
configuration planned for Jaguar.

00:41:00.770 --> 00:41:03.180
That's not on your CD, though.

00:41:06.540 --> 00:41:08.840
Okay, I'm going to touch
briefly on NSNet Services.

00:41:08.840 --> 00:41:11.580
NSNet Services is brand new in Jaguar.

00:41:11.580 --> 00:41:15.220
This is Rendezvous, or ZeroConf.

00:41:15.290 --> 00:41:19.580
This is the Cocoa API that makes it
possible for you to register and discover

00:41:19.580 --> 00:41:21.380
other services out there on the net.

00:41:21.380 --> 00:41:25.240
Two classes,
NSNet Service and NSNet Service Browser.

00:41:25.240 --> 00:41:29.140
They're implemented on top of
CFNet Services inside CFNetwork,

00:41:29.140 --> 00:41:32.010
which I'm going to talk
about in a little bit.

00:41:32.240 --> 00:41:35.800
But I just did want to highlight that
this is a Cocoa API available to you.

00:41:38.670 --> 00:41:41.280
So that's it for Cocoa,
and now I'm going to descend into that

00:41:41.280 --> 00:41:46.090
green bar in the architecture diagram,
the core services bar.

00:41:46.190 --> 00:41:48.900
And I'm going to start with CF Network.

00:41:49.150 --> 00:41:53.640
CF Network was first introduced in 10.1,
and it provides a number of

00:41:53.650 --> 00:41:57.630
low-level abstractions for
some basic networking concepts.

00:41:57.740 --> 00:42:03.050
Now, CF Network is often confused for
being a library like URL Access or

00:42:03.120 --> 00:42:05.700
NSURL that's focused on URL download.

00:42:05.760 --> 00:42:06.600
That's not true.

00:42:06.600 --> 00:42:10.080
That's not the intention
behind CF Network.

00:42:10.560 --> 00:42:15.200
The CF network provides APIs to
allow you to directly access and

00:42:15.200 --> 00:42:19.170
manipulate SSL or TLS socket streams.

00:42:19.170 --> 00:42:24.140
You don't have to get involved
in the details of managing that.

00:42:24.250 --> 00:42:29.810
It also provides a full HTTP 1.1 engine,
and it provides the new

00:42:29.870 --> 00:42:34.370
Net Services APIs that provide
access to Zero Conf Rendezvous.

00:42:35.000 --> 00:42:40.280
The primary focus of CF Network as a
piece in that core services layer is on

00:42:40.280 --> 00:42:44.370
high performance but small footprint.

00:42:44.580 --> 00:42:46.890
And we use it throughout
the stack ourselves.

00:42:46.960 --> 00:42:51.200
It's used by NSURL Handle, Sherlock,
Software Update, iPhoto,

00:42:51.200 --> 00:42:53.100
Web Services Core.

00:42:53.220 --> 00:42:57.400
It's also used by iChat,
which you saw demoed in the keynote.

00:42:57.500 --> 00:43:00.170
We use it pretty heavily in-house.

00:43:02.200 --> 00:43:04.940
So what are CF Network's strengths?

00:43:04.950 --> 00:43:10.600
It provides complete exacting
control of the HTTP transaction.

00:43:10.700 --> 00:43:15.300
You can manipulate the request
directly in terms native to HTTP.

00:43:15.300 --> 00:43:18.960
If you understand the spec,
you can use CF Network very easily.

00:43:18.960 --> 00:43:24.600
It has full support for HTTP 1.1
that includes pipelined persistent

00:43:24.680 --> 00:43:28.120
connections and digest authentication.

00:43:28.120 --> 00:43:31.200
There's full integration
with the run loop,

00:43:31.610 --> 00:43:35.970
so you can use the HTTP engine
and the socket streams in

00:43:35.970 --> 00:43:41.190
an asynchronous fashion,
again, without having to fork threads.

00:43:41.800 --> 00:43:45.140
And it gives you the best
performance you can get from a

00:43:45.140 --> 00:43:50.170
networking API in the Mac OS X stack
without dropping into BSD sockets.

00:43:50.180 --> 00:43:55.580
And in fact, our measurements show
that as far as throughput,

00:43:55.580 --> 00:43:58.760
CF Network will give
you the same bandwidth,

00:43:58.760 --> 00:44:02.390
the same performance as raw sockets,
if you do so much as

00:44:02.390 --> 00:44:03.880
hit the network card.

00:44:03.880 --> 00:44:06.980
The only time we could see a
performance difference between

00:44:06.980 --> 00:44:10.500
CF Network and raw sockets was
in hitting the loopback address.

00:44:14.050 --> 00:44:14.910
Limitations.

00:44:15.080 --> 00:44:18.100
Well, the limitations are sort of
the flip side of the strengths.

00:44:18.270 --> 00:44:20.150
This is not a convenience API.

00:44:20.150 --> 00:44:25.710
It's not simple the way
URL access and NSURL are simple.

00:44:26.080 --> 00:44:29.820
No FTP support in CF Network,
and it's brand new,

00:44:29.820 --> 00:44:33.290
so the documentation is pretty scarce.

00:44:34.810 --> 00:44:37.360
So when should you use
CF Network in preference to some

00:44:37.360 --> 00:44:39.900
of these higher level frameworks?

00:44:39.980 --> 00:44:45.890
Use it if you know your transport
is HTTP and you want control.

00:44:46.300 --> 00:44:50.550
Use it if you want a simple SSL encrypted
socket and you don't want to get

00:44:50.590 --> 00:44:55.600
involved in the details of SSL,
don't want to figure out an SSL library.

00:44:56.230 --> 00:45:00.800
Use it any time you want more control
than the higher level APIs provide.

00:45:00.930 --> 00:45:03.970
As just one example,
the higher level APIs are going to

00:45:04.000 --> 00:45:06.220
dictate the threading model to you.

00:45:06.300 --> 00:45:09.500
NSURL requires run-loop integration.

00:45:09.500 --> 00:45:11.760
URL access requires spawning threads.

00:45:11.760 --> 00:45:14.880
If that doesn't fit with your model,
drop to CF Network.

00:45:14.880 --> 00:45:19.330
It will accommodate the
threading model you want to use.

00:45:19.600 --> 00:45:22.900
Use it anytime you want to avoid
linking with higher level frameworks.

00:45:22.900 --> 00:45:27.300
Maybe you have a piece of code that
needs to work with both Carbon and Cocoa.

00:45:27.400 --> 00:45:30.260
Maybe you have a piece of code
that is going to run in a high

00:45:30.260 --> 00:45:35.170
performance daemon and you don't
want the hit of linking high.

00:45:35.900 --> 00:45:39.820
and use it anytime you need features
that are only available in CF Network.

00:45:39.830 --> 00:45:42.200
The big example of this is Rendezvous.

00:45:42.240 --> 00:45:46.280
If you don't want to link in Objective-C,
CF Network is your option

00:45:46.290 --> 00:45:48.510
for accessing Rendezvous.

00:45:50.300 --> 00:45:52.860
So what's new since 10.1?

00:45:52.900 --> 00:45:57.990
Well, we've moved up to full persistent
connections in the HTTP engine.

00:45:58.100 --> 00:46:01.700
We've added the Net Services and
Service Discovery APIs.

00:46:01.730 --> 00:46:06.150
We've added support for SOCKS proxies,
that's v4 and v5.

00:46:06.390 --> 00:46:10.300
We've added digest authentication
to the HTTP engine,

00:46:10.300 --> 00:46:14.510
and we also have added an
asynchronous hostname lookup.

00:46:17.140 --> 00:46:20.060
Now I'm going to briefly
touch on Web Services Core.

00:46:20.200 --> 00:46:24.000
This is also a new API,
brand new with Jaguar.

00:46:24.150 --> 00:46:27.410
Web Services Core is a client
framework for accessing web

00:46:27.410 --> 00:46:30.070
services like SOAP or XMLRPC.

00:46:30.620 --> 00:46:36.240
Brand new in Jaguar, based on CF Network,
and as such, it exports new CF types,

00:46:36.350 --> 00:46:40.670
and it's friendly to run loops
and run loop integration.

00:46:41.120 --> 00:46:44.480
It does have support for
authentication options,

00:46:44.480 --> 00:46:50.400
but in Jaguar it's for HTTP,
HTTPS posts only.

00:46:53.000 --> 00:46:55.000
All right.

00:46:55.000 --> 00:46:57.500
I'm going to move on down even lower.

00:46:57.520 --> 00:46:59.240
Now we're going to look
at Core Foundation,

00:46:59.240 --> 00:47:03.960
which provides what the basis
that CF Network builds on itself.

00:47:04.000 --> 00:47:08.040
There are four interesting CF types
when you talk about networking

00:47:08.040 --> 00:47:10.000
support in Core Foundation.

00:47:10.110 --> 00:47:15.000
CFURL, you've probably used,
simply represents the URL string.

00:47:15.000 --> 00:47:17.710
Allows you to parse out
the different pieces,

00:47:17.710 --> 00:47:20.430
examine the URL,
but has no knowledge of how to

00:47:20.430 --> 00:47:22.500
actually fetch the URL built in.

00:47:23.020 --> 00:47:27.380
CF Socket allows you to take
a Berkeley socket and manage

00:47:27.410 --> 00:47:29.150
it directly on the run loop.

00:47:29.320 --> 00:47:33.540
That's where NSURL, CF Network,
NSURL Handle are all getting

00:47:33.540 --> 00:47:38.610
their basic support for receiving
socket data on the run loop.

00:47:38.790 --> 00:47:42.080
and CF Readstream and
WriteStream represent one-way

00:47:42.080 --> 00:47:45.890
byte streams to and from any of
a number of different sources.

00:47:46.040 --> 00:47:49.890
Files, sockets,
or memory are the three I list here.

00:47:50.530 --> 00:47:53.140
There are also some dirt
simple functions inside

00:47:53.280 --> 00:47:57.370
Core Foundation for fetching a URL,
but they are dirt simple.

00:47:57.750 --> 00:48:00.530
If you're doing anything
at all complicated,

00:48:00.550 --> 00:48:04.600
they're probably not what you want
and you need to link a little higher.

00:48:07.280 --> 00:48:13.320
So the strengths of what's
in Core Foundation are here.

00:48:13.360 --> 00:48:18.040
CFStream provides a simple single
abstraction that hides away the

00:48:18.040 --> 00:48:20.820
details of what the source is.

00:48:20.820 --> 00:48:23.670
When you work with a CFStream,
you do not need to know whether

00:48:23.670 --> 00:48:26.810
you're talking to a file,
talking out over the network,

00:48:26.810 --> 00:48:28.380
talking into memory.

00:48:28.420 --> 00:48:30.680
Provides very good,
strong run-loop integration.

00:48:30.680 --> 00:48:35.870
This is where all the frameworks above
it inherit the run-loop integration from.

00:48:37.400 --> 00:48:41.640
and it supports a variety
of threading models.

00:48:41.670 --> 00:48:45.950
CFSocket provides support for
arbitrary socket configurations.

00:48:46.030 --> 00:48:48.000
You can do a bunch of things
with CFSocket that you

00:48:48.000 --> 00:48:49.530
cannot do with CFStream.

00:48:49.540 --> 00:48:53.940
In particular, you can work with
UDP sockets as well as TCP,

00:48:53.970 --> 00:49:00.310
and you can set up server LISN sockets
as well as client sockets.

00:49:04.360 --> 00:49:06.940
On the other hand,
you are so close to the OS that at this

00:49:06.940 --> 00:49:11.720
point the API is very thin to guarantee
that there's no performance hit.

00:49:12.300 --> 00:49:14.500
You're going to be,
if you're working with CFSocket,

00:49:14.500 --> 00:49:19.100
you're going to be configuring
your socket using the BSD APIs.

00:49:19.240 --> 00:49:22.490
And you're going to need to go
to higher level APIs or descend

00:49:22.490 --> 00:49:27.170
to sockets to do any of the more
complex configuration you need to do.

00:49:28.660 --> 00:49:31.000
It's not extensible,
streams are not extensible,

00:49:31.040 --> 00:49:34.480
there's no way currently to
create new kinds of streams.

00:49:34.480 --> 00:49:36.750
And again,
because much of this is so very new,

00:49:36.830 --> 00:49:39.790
there's little documentation available.

00:49:41.180 --> 00:49:44.230
So when are you going
to use Core Foundation?

00:49:44.520 --> 00:49:47.560
Use it when you're perfectly
comfortable with BSD sockets and all

00:49:47.560 --> 00:49:49.050
you want is run-loop integration.

00:49:49.320 --> 00:49:51.950
You're perfectly content to
manage the socket yourself,

00:49:52.060 --> 00:49:54.920
you just want to know when
the bytes are arriving.

00:49:55.460 --> 00:49:59.270
Use it if you need some type that's
going to abstract away the source

00:49:59.360 --> 00:50:01.190
or the destination of the data.

00:50:01.280 --> 00:50:04.640
So you have some piece of parsing
code that really shouldn't care

00:50:04.640 --> 00:50:06.620
where the bytes are coming from.

00:50:06.620 --> 00:50:09.960
Or you have some code that's writing
out data that really shouldn't

00:50:10.070 --> 00:50:11.640
care where the bytes are going to.

00:50:11.680 --> 00:50:15.550
You can use a CFReader write
stream to represent that.

00:50:16.110 --> 00:50:19.940
and use it anytime you need to use
another API that's going to consume

00:50:19.940 --> 00:50:22.560
or produce a read or write stream.

00:50:24.930 --> 00:50:27.500
So what's new since X.1?

00:50:27.670 --> 00:50:30.740
We've added CF read and
write stream set property.

00:50:30.740 --> 00:50:36.290
This is the way you configure the
stream and change the way it behaves.

00:50:36.500 --> 00:50:39.240
CFSocket has callbacks for write now.

00:50:39.240 --> 00:50:42.270
It used to be that you would get your
callback only when data had arrived.

00:50:42.440 --> 00:50:45.760
Now you can also receive a
callback telling you that there's

00:50:45.760 --> 00:50:47.980
room to write in the buffer.

00:50:48.600 --> 00:50:51.020
There are some more options
controlling exactly when your

00:50:51.020 --> 00:50:54.000
CF socket callback is going to fire.

00:50:54.580 --> 00:50:56.500
Better event dispatching from CF Stream.

00:50:56.500 --> 00:50:59.460
The event model's been
cleaned up considerably.

00:50:59.540 --> 00:51:03.330
Asynchronous host name,
domain name lookup.

00:51:03.630 --> 00:51:06.310
This is where everybody
else is inheriting from

00:51:06.310 --> 00:51:08.230
to get this functionality.

00:51:09.900 --> 00:51:12.840
Socket streams are now
errored out properly as the

00:51:12.930 --> 00:51:15.340
network changes underneath it.

00:51:15.620 --> 00:51:19.050
And we suppress SIG pipe
on socket streams.

00:51:21.420 --> 00:51:25.970
So last in the core services
bucket is Open Transport.

00:51:26.160 --> 00:51:29.100
Vincent talked some about
Open Transport already.

00:51:29.190 --> 00:51:34.000
You know that it's a compatibility API,
back to Mac OS 8 and 9,

00:51:34.110 --> 00:51:38.800
and that it exists on X primarily
for easy migration up from code

00:51:39.150 --> 00:51:42.990
bases that were designed for 8 and 9.

00:51:43.160 --> 00:51:48.460
However, on Mac OS X it's going
through an emulation layer.

00:51:48.490 --> 00:51:53.910
And as such, there's a hit in a lot of
threads and context switches.

00:51:54.070 --> 00:52:00.240
There's no access in OT to
the IPv6 or the IPSec APIs.

00:52:00.380 --> 00:52:02.490
And at this point,
we're recommending that

00:52:02.490 --> 00:52:06.540
no new Mac OS X networking
code be written to OT.

00:52:06.880 --> 00:52:10.530
Use BSD sockets instead,
or use the higher level

00:52:10.530 --> 00:52:12.360
APIs when possible.

00:52:14.730 --> 00:52:17.380
All right, so that's it for the APIs.

00:52:17.520 --> 00:52:20.300
I want to just take a moment
to go over where we stand with

00:52:20.410 --> 00:52:21.960
IPv6 in these different APIs.

00:52:21.960 --> 00:52:27.200
At the bottom, CF Socket is IP agnostic.

00:52:27.200 --> 00:52:30.980
You're going to provide
CF Socket with a SOC adder.

00:52:30.980 --> 00:52:35.240
That can be an IPv6 adder,
it can be an IPv4 adder,

00:52:35.450 --> 00:52:38.220
but it's still up to you to
choose what flavor you want.

00:52:38.270 --> 00:52:45.600
On the other hand, all the upper pieces,
CF Stream, CF Network, NSURL Handle,

00:52:45.600 --> 00:52:49.500
URL Access, they're all working with
domain names or with URLs.

00:52:49.500 --> 00:52:54.360
So we will end up doing the IPv6 work
for you when you write to those APIs.

00:52:54.360 --> 00:52:57.640
I'm not going to tell you
all the work is done there,

00:52:57.640 --> 00:52:58.960
but a lot of it is.

00:52:58.960 --> 00:53:02.120
And on the CD you have,
you'll see a lot of the IPv6

00:53:02.200 --> 00:53:04.360
connectivity in place already.

00:53:05.870 --> 00:53:07.890
And then I just want
to highlight one thing.

00:53:07.950 --> 00:53:11.930
Some of you have noticed that
CFURL and NSURL have not yet

00:53:12.050 --> 00:53:18.790
adopted the IPv6 addressing string,
the one that looks like this.

00:53:18.800 --> 00:53:23.390
That's not in the CD you got,
but it is planned for Jaguar.

00:53:26.060 --> 00:53:28.120
And that's it,
and I'm going to ask Vincent to come

00:53:28.120 --> 00:53:31.180
back up to close out the session.

00:53:36.790 --> 00:53:39.400
Okay, so I'm just going to wrap up here.

00:53:39.400 --> 00:53:40.260
So what's next?

00:53:40.260 --> 00:53:43.940
Certainly it's for you to take
advantage of all those APIs,

00:53:43.940 --> 00:53:50.410
certainly move away from
Open Transport and learn

00:53:50.520 --> 00:53:53.720
the new APIs in Mac OS X.

00:53:53.820 --> 00:53:57.790
As always, we cannot make any product
announcements or tell what

00:53:57.790 --> 00:54:00.290
we are going to deliver when,
and we don't know,

00:54:00.300 --> 00:54:04.970
but that's kind of the list of
things we're going to work on.

00:54:04.980 --> 00:54:09.520
So, a lot more integration of IPv6.

00:54:09.520 --> 00:54:14.360
For example, IPv6 in Jaguar,
that's the first foundation we have,

00:54:14.360 --> 00:54:17.100
is just the layout of the protocols.

00:54:17.640 --> 00:54:21.590
We're going to bring up
more IPv6 features up to the

00:54:21.610 --> 00:54:26.880
stacks and many applications,
but a lot more things that

00:54:26.880 --> 00:54:29.810
we may end up working on.

00:54:29.850 --> 00:54:35.390
And also, provide a brief roadmap.

00:54:35.420 --> 00:54:39.320
So, yesterday there was already
the Darwin roadmap that shows,

00:54:39.470 --> 00:54:44.880
for example, what's the core networking,
where it fits in the story.

00:54:44.880 --> 00:54:47.620
So, 803 is this session.

00:54:47.620 --> 00:54:52.070
At the same time, there was,
in another room, 6th and 3rd,

00:54:52.070 --> 00:54:57.510
there was talk about Cocoa, what's new,
and a description of NSURL, handle,

00:54:57.510 --> 00:54:59.060
and the services.

00:55:02.170 --> 00:55:07.340
Just after this session,
a session about the new web services

00:55:07.460 --> 00:55:12.970
framework for SOAP support and XML.

00:55:14.400 --> 00:55:19.670
Introduction to
CF Network this afternoon.

00:55:19.810 --> 00:55:26.540
Tomorrow morning, so if you write NKs,
I encourage you to go to session 108.

00:55:30.770 --> 00:55:35.490
808 is for CF Run on Loop and CF Stream.

00:55:35.490 --> 00:55:41.170
Thursday morning, that's the
Advanced Mac OS X Networking session,

00:55:41.170 --> 00:55:46.250
where we're going to go through
the new protocols and talk a little

00:55:46.320 --> 00:55:49.930
bit more about NKs and performance.

00:55:49.940 --> 00:55:55.660
Thursday afternoon, section 811,
Zero Configuration Networking,

00:55:55.750 --> 00:55:58.420
including the CF Net Services API.

00:55:58.420 --> 00:56:00.490
Feedback Forum.

00:56:00.540 --> 00:56:04.340
So there are three.

00:56:04.400 --> 00:56:10.900
[Transcript missing]

00:56:11.080 --> 00:56:16.310
On Friday at 2:00 PM, the Core OS X,
it's really a general

00:56:16.310 --> 00:56:18.120
Mac OS X networking feedback.

00:56:18.240 --> 00:56:21.100
I mean, everything that is not covered
in other feedback forum,

00:56:21.100 --> 00:56:24.140
you can come and give
us your feedback there.

00:56:24.230 --> 00:56:31.960
And for the Cocoa APIs,
NSURL and NSURL Handle,

00:56:31.980 --> 00:56:35.310
the Cocoa Feedback
Forum is the place to go.

00:56:35.490 --> 00:56:41.370
And those are the primary
contact should be Tom Weier,

00:56:41.370 --> 00:56:44.880
who's the evangelist for
network and communications.

00:56:44.880 --> 00:56:47.800
But if you need to contact me,
here is my address.

00:56:50.060 --> 00:56:54.070
So we got a lot more documentation.

00:56:54.160 --> 00:56:55.750
A lot more documentation is available.

00:56:55.800 --> 00:56:59.410
So most of it is on the CD or on the web.

00:56:59.480 --> 00:57:04.740
And there's also the new
networking mailing list that

00:57:04.740 --> 00:57:07.510
certainly you know about.
WEBVTT

00:00:05.300 --> 00:00:08.320
Good morning and welcome to the
session on certificates in Mac OS X.

00:00:08.380 --> 00:00:09.260
I'm Craig Keithley.

00:00:09.260 --> 00:00:12.330
I'm Apple's security and
cryptography technology evangelist.

00:00:12.410 --> 00:00:14.740
Today we're going to talk about,
to some degree,

00:00:14.740 --> 00:00:18.870
our common data security architecture
with particular interest on what we're

00:00:18.920 --> 00:00:21.470
doing to improve access to certificates.

00:00:21.600 --> 00:00:23.710
There's a number of new
APIs that are coming in Jaguar

00:00:23.940 --> 00:00:25.000
that will make this easier.

00:00:25.000 --> 00:00:27.200
There's changes to Keychain.

00:00:27.250 --> 00:00:30.460
And as I said, we're going to improve the
certificate functionality.

00:00:30.460 --> 00:00:32.500
To start that off,
I'd like to bring out Ken McLeod,

00:00:32.500 --> 00:00:34.870
a senior software engineer
in the data security group.

00:00:35.050 --> 00:00:36.750
Thanks very much.

00:00:42.200 --> 00:00:44.760
Thanks, Craig.

00:00:44.760 --> 00:00:47.330
The session is a little bit badly named.

00:00:47.340 --> 00:00:50.830
It's not just about certificates,
like as Craig said.

00:00:50.900 --> 00:00:54.310
It's also going to talk a little
bit about keychain and where we are

00:00:54.310 --> 00:00:56.190
with that and how they tie together.

00:00:56.650 --> 00:01:00.930
And we'll talk a little bit
about things like access control

00:01:01.190 --> 00:01:06.220
on items in your keychain,
access control on keys, and trusting,

00:01:06.220 --> 00:01:08.370
being able to trust a certificate and
how you do certificate management.

00:01:09.310 --> 00:01:10.590
Oops.

00:01:10.700 --> 00:01:14.290
So I'm going to start off, first of all,
with an overview of CDSA.

00:01:14.290 --> 00:01:16.460
For those of you, hopefully,
who were in the last session,

00:01:16.460 --> 00:01:20.300
some of these things may
be familiar concepts.

00:01:20.440 --> 00:01:24.310
Then we'll spend some time talking
about the kind of functionality that's

00:01:24.310 --> 00:01:26.470
provided by the security framework.

00:01:26.670 --> 00:01:29.300
This is the open source
framework that's part of Darwin,

00:01:29.300 --> 00:01:32.300
where all these functions sort of live.

00:01:32.300 --> 00:01:36.450
And, of course,
we'll talk about certificates and

00:01:36.450 --> 00:01:41.300
how you use them to establish trust
and how you can store certificates

00:01:41.300 --> 00:01:46.540
in a keychain and the integration
between keychain and certificates.

00:01:49.050 --> 00:01:51.500
I do have to press this hard, don't I?

00:01:51.660 --> 00:01:56.050
So the common data-security
architecture is something that's

00:01:56.220 --> 00:01:58.150
been part of OS X since day one.

00:01:58.390 --> 00:02:03.300
It's the foundation on which all
of the security services are built.

00:02:03.460 --> 00:02:06.580
And it's a modular architecture,
which means that the functionality

00:02:06.580 --> 00:02:09.700
that's provided can be just
plugged into the backend of it.

00:02:09.700 --> 00:02:14.500
There are four basic types of
modules that plug into CDSA.

00:02:14.500 --> 00:02:18.570
A CSP, or cryptographic service provider,
provides all the

00:02:18.590 --> 00:02:21.120
encryption functionality,
so all the encryption

00:02:21.120 --> 00:02:22.400
algorithms live there.

00:02:22.480 --> 00:02:26.500
Data libraries give you all
the data storage functionality.

00:02:26.620 --> 00:02:29.600
They act as your database API.

00:02:29.640 --> 00:02:33.660
A certificate library is a
module that knows how to parse

00:02:33.660 --> 00:02:36.990
certificates and pull them apart.

00:02:37.100 --> 00:02:41.620
And a trust policy module is the
code that actually lets you make

00:02:41.620 --> 00:02:43.380
decisions involving certificates.

00:02:43.440 --> 00:02:46.770
For example,
would I trust this certificate to

00:02:47.290 --> 00:02:51.060
do-- SSL and make an SSL connection
versus would I use the

00:02:51.060 --> 00:02:54.340
certificate to encrypt something?

00:02:55.010 --> 00:03:01.660
So all of this functionality lives under
an umbrella set of APIs called CSSM,

00:03:01.710 --> 00:03:04.400
the Common Security Services Manager.

00:03:04.420 --> 00:03:10.020
And the neat thing about this API is
that once you've written code to it,

00:03:10.020 --> 00:03:12.800
you can replace any of
those modules underneath it

00:03:12.810 --> 00:03:14.000
without affecting your code.

00:03:14.050 --> 00:03:17.560
So you don't have to rewrite your
code in order to take advantage of,

00:03:17.560 --> 00:03:21.330
for example,
if a CSP is replaced and it provides

00:03:21.330 --> 00:03:25.400
a stronger encryption algorithm,
or if a DL is replaced and it

00:03:25.400 --> 00:03:29.660
suddenly gives you access to LDAP or,
for example,

00:03:29.660 --> 00:03:32.020
storing things on smart cards.

00:03:32.100 --> 00:03:38.990
So the API sort of transparently lets
those things happen under the hood.

00:03:41.530 --> 00:03:46.390
So the API is that bar that runs across
the second from the bottom layer,

00:03:46.560 --> 00:03:49.040
the CSSM bar.

00:03:49.060 --> 00:03:51.700
The plugins go underneath that.

00:03:51.940 --> 00:03:55.480
Above CSSM,
we've tried to provide some higher

00:03:55.480 --> 00:04:00.320
level layered services that make
these CSSM things easier to use.

00:04:00.480 --> 00:04:03.450
So, for example,
we have a certificate API that

00:04:03.450 --> 00:04:07.400
lets you deal with certificates
in a little bit easier fashion.

00:04:07.400 --> 00:04:11.770
In the earlier session,
Murph talked to you about the SSL API,

00:04:11.870 --> 00:04:15.390
secure transport,
that's also built into this.

00:04:15.400 --> 00:04:19.010
So, at the top level,
applications have their choice of

00:04:19.010 --> 00:04:23.620
whether they want to use some of
these higher level layered services or

00:04:23.920 --> 00:04:28.400
whether you want to drill down and get
into CDSA itself and use the CSSM APIs.

00:04:28.400 --> 00:04:30.400
You have your choice there.

00:04:30.910 --> 00:04:34.580
Disk copy, for example, uses--

00:04:34.700 --> 00:04:53.600
[Transcript missing]

00:04:54.930 --> 00:04:58.900
So why would you use CDSA at that level?

00:04:59.110 --> 00:05:02.270
Some of the things that are
provided there are basic

00:05:02.370 --> 00:05:04.560
building blocks of encryption.

00:05:04.670 --> 00:05:09.270
It allows you to generate keys,
both symmetric keys and a

00:05:09.270 --> 00:05:12.030
public/private key pair.

00:05:12.060 --> 00:05:15.820
If you need to do encryption,
the earlier session had an example of

00:05:15.820 --> 00:05:19.950
how you would use CDSA to encrypt data.

00:05:20.010 --> 00:05:23.200
CDSA provides a whole
bunch of algorithms,

00:05:23.200 --> 00:05:26.660
the Advanced Encryption
Standard and a number of others.

00:05:26.720 --> 00:05:28.560
There's far too many to list, actually.

00:05:28.590 --> 00:05:36.060
It lets you digest data or hash it
using the standard hash algorithms.

00:05:36.100 --> 00:05:42.210
It provides data storage and retrieval,
easy APIs to have a place

00:05:42.210 --> 00:05:45.090
to store and retrieve data.

00:05:45.230 --> 00:05:50.230
One really interesting area of
functionality in CDSA that Perry is

00:05:50.230 --> 00:05:53.960
going to talk to you about a little later
is the whole area of access control.

00:05:54.020 --> 00:05:59.810
You can specify when items
can be used and have a very

00:06:00.010 --> 00:06:02.570
fine level of control on that.

00:06:02.710 --> 00:06:07.740
The other area, of course,
is the ability to parse certificates.

00:06:07.770 --> 00:06:11.720
Apple provides a X.509
certificate parsing library,

00:06:11.800 --> 00:06:14.560
but it's by no means limited to that.

00:06:14.800 --> 00:06:18.760
Certainly the architecture allows
for any kind of certificate

00:06:19.000 --> 00:06:20.940
module to be plugged in.

00:06:21.010 --> 00:06:27.780
This is just, by the way,
a subset of the things that CDSA can do.

00:06:27.780 --> 00:06:27.780
Oops, skipped to him.

00:06:28.790 --> 00:06:31.710
So on Mac OS X,
all of CDSA is implemented in a

00:06:31.720 --> 00:06:34.770
framework called the Security Framework.

00:06:35.280 --> 00:06:39.950
It's the place where you would
go to find the CSSM APIs and

00:06:39.950 --> 00:06:42.170
all of those interfaces.

00:06:42.210 --> 00:06:46.750
And it also provides all of the new
higher level layered service APIs such

00:06:46.750 --> 00:06:51.740
as secure transport and any of the
functionality beginning with SEC,

00:06:51.760 --> 00:06:57.000
the SEC prefix APIs that I'm going to
talk about a little more in detail.

00:06:57.120 --> 00:07:00.570
At this point I have to give a caveat.

00:07:00.710 --> 00:07:03.880
Those APIs, I don't believe,
are on the CD that was

00:07:03.880 --> 00:07:05.480
handed out at the conference.

00:07:05.560 --> 00:07:08.100
I don't think they made
it in for that version.

00:07:08.290 --> 00:07:10.510
But if you look in the
security framework,

00:07:10.510 --> 00:07:14.000
you'll see the CDSA APIs and then
you'll see a security.h header

00:07:14.470 --> 00:07:19.100
which lists all of the other headers
that will be there very soon.

00:07:19.510 --> 00:07:23.210
The security framework is part
of Darwin and is open source,

00:07:23.230 --> 00:07:27.710
so you have the ability
to look at all this code.

00:07:28.150 --> 00:07:30.750
One of the things that
we got as feedback,

00:07:30.750 --> 00:07:33.770
certainly in previous
years that we've heard,

00:07:33.770 --> 00:07:39.740
is people want the ability to
have factored out user interface.

00:07:39.740 --> 00:07:45.410
So if their code, for example,
needs to be a faceless daemon or you

00:07:45.410 --> 00:07:50.400
don't want to link your application
with all of the UI frameworks

00:07:50.400 --> 00:07:55.100
and just keep it lean and mean,
we now provide the ability to do that.

00:07:57.120 --> 00:08:02.360
So what we're calling the Sec APIs,
security APIs with that prefix,

00:08:02.360 --> 00:08:06.460
are actually patterned after
the core foundation API.

00:08:06.460 --> 00:08:10.110
If it looks familiar that's
because this is the model.

00:08:10.300 --> 00:08:12.610
And in fact,
all of the objects that you deal

00:08:12.700 --> 00:08:16.680
with when you're dealing with
the security APIs are CF objects.

00:08:16.680 --> 00:08:20.620
So keychains, keychain items,
certificate wraps,

00:08:20.840 --> 00:08:25.450
all can be dealt with in
a core foundation way.

00:08:25.570 --> 00:08:28.840
You can use core foundation

00:08:30.040 --> 00:08:35.880
interfaces to retain them, release them,
you can store them in a

00:08:35.890 --> 00:08:38.920
CFArrays and so forth.

00:08:38.920 --> 00:08:42.780
Like Core Foundation,
if an API has copy in its name,

00:08:42.780 --> 00:08:47.940
you know that it's handing you back
an object that you need to release.

00:08:48.060 --> 00:08:51.510
So a copy, a sec copy,
whatever the object is,

00:08:51.510 --> 00:08:55.430
you'll have to call a CF release
on it when you're done.

00:08:55.590 --> 00:08:58.700
If it's a sec get some
kind of object API,

00:08:58.700 --> 00:09:01.800
then you don't need to release it.

00:09:02.640 --> 00:09:06.190
When you're searching for
security-related objects,

00:09:06.190 --> 00:09:08.000
the APIs will look familiar.

00:09:08.350 --> 00:09:12.590
They'll be Sec, whatever the object is,
Search Ref,

00:09:12.650 --> 00:09:20.450
and there'll be a Search API that
will give you back whatever that kind

00:09:20.450 --> 00:09:20.450
of object is you're searching for.

00:09:21.280 --> 00:09:26.240
The Sec APIs also provide the
ability to drill down below them

00:09:26.570 --> 00:09:31.070
to get at some of the underlying
CSSM or actually CDSA objects.

00:09:31.400 --> 00:09:35.710
One of the hardest parts of using
CDSA for most people is actually

00:09:36.200 --> 00:09:42.100
figuring out how do I get a handle to
the CSP or the certificate library.

00:09:42.110 --> 00:09:45.360
Those things are sometimes
a little bit difficult.

00:09:45.360 --> 00:09:48.980
There are convenience APIs at
the Sec layer to actually

00:09:48.980 --> 00:09:51.200
hand you back those objects.

00:09:55.780 --> 00:10:01.910
So the Keychain Manager in
Carbon provides a level of functionality

00:10:01.910 --> 00:10:08.320
that includes automatic user interface
and sort of high-level convenience

00:10:08.320 --> 00:10:10.940
calls wrapped up in one package.

00:10:11.010 --> 00:10:15.090
The SecKeychain APIs provide
the same level of functionality,

00:10:15.090 --> 00:10:16.860
but they've been factored differently.

00:10:16.960 --> 00:10:20.650
So you can call them and not
have to worry about linking,

00:10:20.660 --> 00:10:25.360
as I said before, with UI layers.

00:10:25.520 --> 00:10:29.360
There's also a sort of
expanded--it's a superset,

00:10:29.360 --> 00:10:34.730
actually, of what the Carbon Keychain
Manager calls "provided you."

00:10:35.500 --> 00:11:44.300
[Transcript missing]

00:11:45.200 --> 00:11:52.170
The SecKeychain APIs expand on the
Carbon Keychain Manager APIs and add

00:11:52.170 --> 00:11:59.940
more parameters so that you can specify
all the attributes of a keychain item.

00:12:00.520 --> 00:12:05.290
Also, they provide the ability to let
you specify the access control.

00:12:05.390 --> 00:12:10.080
So when you create an item
and store it in a keychain,

00:12:10.420 --> 00:12:13.560
you can specify a list of
trusted applications that

00:12:13.560 --> 00:12:15.880
have access to that item.

00:12:18.200 --> 00:13:12.400
[Transcript missing]

00:13:12.670 --> 00:13:15.780
In the X.509 world,
these certificates can form a chain,

00:13:15.780 --> 00:13:18.740
and at the end of the chain
you have a leaf certificate,

00:13:18.740 --> 00:13:24.800
which just certifies whoever's public
key that that certificate is issued to.

00:13:24.870 --> 00:13:27.320
At the other end of the
chain is the issuer,

00:13:27.320 --> 00:13:31.540
the final issuer, the root certificate,
which signs itself and

00:13:31.540 --> 00:13:33.400
sort of certifies itself.

00:13:33.490 --> 00:13:39.360
And then it can sign intermediate
certificates all the way down to

00:13:39.510 --> 00:13:42.990
the leaf that form a trusted chain.

00:13:43.300 --> 00:13:47.640
There can be self-signed certificates
which certify themselves.

00:13:47.640 --> 00:13:54.450
You can have a root certificate that,
for example, is a certificate authority.

00:13:54.590 --> 00:13:58.290
VeriSign, some of these other large
certificate authorities are familiar,

00:13:58.300 --> 00:14:04.540
but you can also set up a certificate
yourself that you have trust in.

00:14:05.050 --> 00:14:11.380
Generally, X.509 certificates are used
for things like making secure

00:14:11.380 --> 00:14:16.150
connections via SSL when you're doing,
for example, an e-commerce transaction.

00:14:16.160 --> 00:14:20.240
You connect to a server
that has an SSL certificate,

00:14:20.260 --> 00:14:23.860
and that forms the basis
of a secure connection.

00:14:23.890 --> 00:14:28.640
And they're also used for SMIME,
which is the standard for secure

00:14:28.640 --> 00:14:31.040
email and encrypting email.

00:14:31.900 --> 00:14:36.210
So with that, I'd like to introduce
Perry 'the Cynic' Kiehtreiber,

00:14:36.240 --> 00:14:39.400
who's going to get more in depth
and tell you what is available

00:14:39.400 --> 00:14:43.310
with certificates and trust.

00:14:43.310 --> 00:14:43.310
Perry.

00:14:48.820 --> 00:14:50.700
Somebody came after all.

00:14:50.710 --> 00:14:53.000
You look kind of empty there for a while.

00:14:53.000 --> 00:14:56.790
Oh yeah, certificates.

00:14:59.390 --> 00:15:03.380
Well, as Ken told you,
there are a number of

00:15:03.530 --> 00:15:07.870
different API objects in
the sec layer that we made.

00:15:07.990 --> 00:15:12.140
But certificates certainly are
sort of... those in keychains

00:15:12.140 --> 00:15:14.980
are the most important ones,
the ones that you're most

00:15:15.100 --> 00:15:17.210
likely to get in contact with.

00:15:17.730 --> 00:15:21.700
For now,
a sex certificate ref in the style

00:15:21.700 --> 00:15:26.180
of Core Foundation represents
an X.509 certificate.

00:15:26.220 --> 00:15:29.720
In the future,
it may also be able to represent others,

00:15:29.720 --> 00:15:32.310
but 509 is what we do right now.

00:15:33.380 --> 00:15:36.040
There's a couple of different
ways you can get one.

00:15:36.150 --> 00:15:42.000
If you happen to have a certificate
lying around as a data blob,

00:15:42.000 --> 00:15:42.000
you can just

00:15:42.570 --> 00:15:46.520
call a creation function to make
a sec certificate from that blob.

00:15:46.600 --> 00:15:51.640
I mean, certificates are flat,
unstructured data.

00:15:51.640 --> 00:15:55.140
You can search for
certificates in your keychains,

00:15:55.140 --> 00:15:55.860
in the user's keychains.

00:15:55.860 --> 00:15:59.000
In any keychain, you'll care to name,
but by default,

00:15:59.000 --> 00:16:01.260
in the ones that the user has set up.

00:16:01.260 --> 00:16:05.570
Certificates can be stored in
keychains just fine and searched by

00:16:05.570 --> 00:16:08.780
the various attributes that they have.

00:16:08.780 --> 00:16:13.560
And sometimes you use API functions that,
as sort of a side effect

00:16:13.690 --> 00:16:16.850
of their operation,
produce certificates that

00:16:16.850 --> 00:16:18.440
may be of interest to you.

00:16:18.440 --> 00:16:21.250
SecTrust is one of the examples
we'll look at a little bit later.

00:16:24.490 --> 00:16:28.640
So once you have a SEC certificate, Raph,
what do you do with them?

00:16:28.770 --> 00:16:33.560
You can use them in some
of the higher level APIs.

00:16:33.560 --> 00:16:38.430
Certainly secure transport is one
of the better examples since SSL is

00:16:38.540 --> 00:16:43.780
based on exchanging information during
handshake based on certificates.

00:16:43.920 --> 00:16:47.660
Sometimes you need to feed
certificates in and sometimes it

00:16:47.660 --> 00:16:53.490
can hand you back the certificates
that it got during its negotiations.

00:16:53.590 --> 00:16:58.970
SEC trust is another example
because one of the major things

00:16:58.970 --> 00:17:01.340
that you do with certificates,
arguably,

00:17:01.400 --> 00:17:05.460
essentially the only thing you do with
them is to use them to establish whether

00:17:05.470 --> 00:17:08.350
to trust someone to do something.

00:17:08.720 --> 00:17:13.550
And certificates are also part
of what we call identities.

00:17:13.650 --> 00:17:15.940
We'll talk about that a little bit later.

00:17:16.090 --> 00:17:20.680
Identities are essentially
the personalities that a user,

00:17:20.680 --> 00:17:23.630
or for that matter, a program has.

00:17:24.620 --> 00:17:25.500
What else can you do?

00:17:25.500 --> 00:17:28.030
As I said,
you can store them in keychains,

00:17:28.120 --> 00:17:31.950
in one keychain or in any number
of keychains if you prefer,

00:17:31.950 --> 00:17:36.210
and you can search for them based on,
you know, issue and other

00:17:36.210 --> 00:17:38.100
attributes that they have.

00:17:38.100 --> 00:17:42.670
Gee, there's SecTrust again.

00:17:42.890 --> 00:17:48.110
And we also have a set of
UI APIs that allow you to display

00:17:48.110 --> 00:17:53.150
certificate chains to the user,
either because you built them, they work,

00:17:53.250 --> 00:17:56.960
and you want to show the user and say,
"This is what you got," or because

00:17:56.960 --> 00:18:03.660
something went wrong and you want
to show the user the chain as

00:18:03.660 --> 00:18:03.660
best as it could be built and say,
"This is what's wrong."

00:18:05.200 --> 00:18:09.690
Oh yeah, certificates have absolutely
no access control.

00:18:09.690 --> 00:18:13.870
And that's okay,
because they are public things.

00:18:14.210 --> 00:18:18.500
They contain a public key,
and they contain some other attributes

00:18:18.500 --> 00:18:22.380
that are signed with a private key.

00:18:22.490 --> 00:18:26.510
The private key of the certificate
that certifies this one.

00:18:26.770 --> 00:18:32.260
And so they are in a fairly
interesting way self-verifying.

00:18:32.370 --> 00:18:34.480
In other words, you can hand them out.

00:18:34.620 --> 00:18:36.360
You don't have to worry
about protecting them.

00:18:36.360 --> 00:18:39.090
You don't have to worry about
keeping people from using them,

00:18:39.160 --> 00:18:45.730
because the only use for a
certificate is to verify something.

00:18:45.950 --> 00:18:49.920
Some operations, some relationship.

00:18:49.950 --> 00:18:54.470
And for that, they can't be faked if
you follow the rules.

00:18:55.950 --> 00:18:57.300
SecIdentity.

00:18:57.380 --> 00:19:00.340
Well, as I said,
identities are sort of the

00:19:00.650 --> 00:19:08.570
online representation of a user
identity in the public key sense.

00:19:09.490 --> 00:19:14.230
A SAC identity consists of three parts:
a public key, a private key,

00:19:14.370 --> 00:19:15.760
and a certificate.

00:19:15.820 --> 00:19:18.080
The public key and the private key,
of course, go together.

00:19:18.260 --> 00:19:20.130
They're an asymmetric key pair.

00:19:20.240 --> 00:19:25.200
And the certificate is a certificate
that certifies the public key.

00:19:25.340 --> 00:19:29.420
Now, these are not necessarily
stored in one blob somewhere.

00:19:29.650 --> 00:19:32.150
They are actually stored
separately in keychains.

00:19:32.160 --> 00:19:34.100
Now, typically,
they'll go into the same keychain,

00:19:34.100 --> 00:19:36.550
but that's not technically required.

00:19:36.650 --> 00:19:40.640
You can actually store, say,
the public key and the private

00:19:40.640 --> 00:19:43.900
key in different keychains,
which sometimes makes

00:19:44.140 --> 00:19:50.100
sense if you want harder,
better access control to the private key.

00:19:52.210 --> 00:19:56.140
Access control, I said,
certificates don't have it,

00:19:56.230 --> 00:20:00.190
public keys don't need it,
but of course the use of the private key,

00:20:00.200 --> 00:20:03.160
which you would use for
signing and decrypting,

00:20:03.300 --> 00:20:04.760
is controlled.

00:20:04.860 --> 00:20:09.050
And so, to the extent that there is
access control for a SEC identity,

00:20:09.050 --> 00:20:12.990
it is the access control of the
private key that's part of it.

00:20:13.720 --> 00:20:17.100
I can never avoid giving good advice.

00:20:17.130 --> 00:20:23.500
It's sometimes very tempting to do
your own security in your program,

00:20:23.500 --> 00:20:25.930
your own access control to these things.

00:20:26.010 --> 00:20:30.260
And I would really like
you to try not to do that.

00:20:30.340 --> 00:20:36.250
Because any mechanism you put
into your own program will

00:20:36.290 --> 00:20:39.870
only work in your own program.

00:20:39.870 --> 00:20:39.870
And if

00:20:40.550 --> 00:20:44.340
The private key, the identity,
it's actually stored in a keychain.

00:20:44.520 --> 00:20:49.010
All that a bad user has to do is use
a different program to get at it.

00:20:49.150 --> 00:20:52.930
If you're using the mechanisms
that are built into the CSSM stack

00:20:52.930 --> 00:20:56.260
and into these functions,
they will apply no matter how

00:20:56.260 --> 00:20:58.180
a user tries to get at these.

00:20:58.710 --> 00:21:00.900
which is a heck of a lot better.

00:21:01.020 --> 00:21:07.600
If you need interesting ways of
protecting access to your items,

00:21:07.720 --> 00:21:10.140
we'll talk about SEC access
a little bit later,

00:21:10.140 --> 00:21:12.440
which should give you more
than enough rope to hang

00:21:12.440 --> 00:21:15.620
yourself in really interesting,
twisted ways.

00:21:19.000 --> 00:21:20.980
Alright, SecTrust.

00:21:21.010 --> 00:21:25.390
What's that for?

00:21:25.390 --> 00:21:25.390
SecTrust is...

00:21:26.060 --> 00:21:29.650
A little bit unusual in that it
doesn't really represent a data

00:21:29.650 --> 00:21:33.290
object as much as an operation.

00:21:34.860 --> 00:21:38.890
The primary thing you do with
certificates in the X.509 world

00:21:38.900 --> 00:21:43.880
and for the most part all the
other worlds too is you are...

00:21:44.790 --> 00:21:49.760
Trying to find out whether a
certificate that somebody handed

00:21:49.760 --> 00:21:54.230
you really shows that you're
supposed to do something for him.

00:21:54.580 --> 00:21:59.400
And the way this typically works is
first you check to see whether you

00:21:59.400 --> 00:22:04.500
can actually build a certificate chain
from that certificate to an anchor,

00:22:04.500 --> 00:22:06.640
a root that you trust.

00:22:06.710 --> 00:22:11.150
And then you look up somewhere
in some database to see whether,

00:22:11.240 --> 00:22:14.490
well, now that you've convinced yourself
that that certificate is valid,

00:22:14.650 --> 00:22:18.880
whether this really means that you're
supposed to do what the guy asked for.

00:22:20.700 --> 00:22:23.170
So there you have the steps.

00:22:23.270 --> 00:22:24.840
You have to validate the certificate.

00:22:24.840 --> 00:22:30.940
If it's not cryptographically valid,
then obviously you can't trust it.

00:22:31.050 --> 00:22:34.730
And if you can convince
yourself that it is valid,

00:22:34.840 --> 00:22:39.740
then you look it up in a database
to see if the user actually said

00:22:39.740 --> 00:22:44.020
you should trust it for this
particular operation or not.

00:22:44.970 --> 00:22:47.040
That sounds pretty complicated.

00:22:47.150 --> 00:22:49.050
It is pretty complicated.

00:22:49.140 --> 00:22:54.680
So what we've tried to do with
the SecTrust object is to make it,

00:22:54.680 --> 00:22:57.140
well, as painless as possible
is what I like to say,

00:22:57.140 --> 00:23:01.210
but as little painful as
possible is probably fairer.

00:23:01.320 --> 00:23:06.110
Those of you who've tried to
actually write code to do this game,

00:23:06.570 --> 00:23:09.800
certificate chain validation
and trust management,

00:23:09.890 --> 00:23:11.510
know that it's not easy.

00:23:11.610 --> 00:23:14.180
And it gets really
complicated really fast.

00:23:14.270 --> 00:23:15.380
So keep that in mind.

00:23:15.660 --> 00:23:19.560
We're trying to make this
as easy as we can for you,

00:23:19.880 --> 00:23:22.010
given the complications.

00:23:22.200 --> 00:23:26.490
So, as I said,
SecTrust is a workflow object.

00:23:26.510 --> 00:23:29.480
So rather than representing
something on disk,

00:23:29.560 --> 00:23:32.990
it represents an operation in progress.

00:23:33.100 --> 00:23:37.290
You make a SecTrust object,
you stuff whatever parameters and

00:23:37.290 --> 00:23:41.060
arguments and options you need into it,
and you tell it to evaluate,

00:23:41.120 --> 00:23:44.370
and then you look at what it
can tell you about the result,

00:23:44.450 --> 00:23:47.820
about what happened when
it tried to evaluate.

00:23:50.000 --> 00:23:52.740
What can happen when you
evaluate a SEC trust?

00:23:52.740 --> 00:23:57.460
If you're lucky, it actually worked,
meaning the certificate could

00:23:57.600 --> 00:24:01.050
be validated as part of a
valid certificate chain.

00:24:01.140 --> 00:24:05.200
And we looked it up in the database and
we could find out that the user said,

00:24:05.200 --> 00:24:07.050
"Yeah, go ahead, do this."

00:24:07.510 --> 00:24:12.050
Or he could have said, "Oh, no,
don't do this." Or he could have said,

00:24:12.240 --> 00:24:14.190
"Um, ask me about this,
because I want to decide

00:24:14.320 --> 00:24:17.700
each time separately what
I want to do about this." Or,

00:24:17.700 --> 00:24:21.900
well, the user could just never have said
anything about this particular situation.

00:24:22.030 --> 00:24:25.510
So that's the four valid
user choice outcomes.

00:24:26.060 --> 00:24:27.770
But then again, maybe it didn't work.

00:24:27.910 --> 00:24:30.700
And if it didn't work,
we actually helped you

00:24:30.740 --> 00:24:34.850
distinguish between two different
major classes of failures.

00:24:35.060 --> 00:24:37.140
Sometimes it sort of almost worked.

00:24:37.210 --> 00:24:40.660
You can just almost feel that if
only this little thing here or

00:24:40.680 --> 00:24:42.990
there could have been changed,
then it would have worked.

00:24:43.130 --> 00:24:46.110
For example,
you can build a certificate chain,

00:24:46.110 --> 00:24:49.160
it works just fine,
but the root is not trusted,

00:24:49.160 --> 00:24:51.000
the root is not an anchor.

00:24:51.000 --> 00:24:52.860
Or you try to build
your certificate chain,

00:24:52.860 --> 00:24:55.000
and, well,
you're missing one in the middle.

00:24:55.000 --> 00:24:56.000
You just can't build the chain.

00:24:56.000 --> 00:24:58.830
But if only you could
find that certificate,

00:24:58.920 --> 00:25:00.980
then everything might be fine.

00:25:01.100 --> 00:25:03.000
We call those recoverable errors.

00:25:03.000 --> 00:25:07.100
So if SecTrust Evaluate tells you
that you had a recoverable error,

00:25:07.300 --> 00:25:09.000
then depending on what
kind of a user you have,

00:25:09.000 --> 00:25:12.000
you may either just say, "Well,
this didn't work," and go away,

00:25:12.000 --> 00:25:18.210
or you may want to bring up UI using
a UI function that we have provided

00:25:18.240 --> 00:25:21.000
for you that will essentially
present to the user a certificate.

00:25:21.100 --> 00:25:24.700
So you can compare the certificate
chain as it was built with little

00:25:24.700 --> 00:25:27.000
annotations telling him what's wrong.

00:25:27.040 --> 00:25:32.000
And you can give the user the
option to try to fix things.

00:25:32.000 --> 00:25:34.980
On the other hand, sometimes things just
don't work out at all,

00:25:34.990 --> 00:25:38.000
and we call those fatal errors,
basically.

00:25:38.000 --> 00:25:40.550
If the certificate is
corrupt on its face,

00:25:40.550 --> 00:25:44.000
then there isn't really
anything you can fix about it.

00:25:44.000 --> 00:25:45.800
It's just broken, you know.

00:25:45.800 --> 00:25:48.500
You hope that it was just
a bad download somewhere.

00:25:48.600 --> 00:25:50.530
You hope it's not an attacker
trying to fake you out.

00:25:50.650 --> 00:25:52.300
But in any case, it's broken.

00:25:52.300 --> 00:25:54.050
That's fatal.

00:25:55.440 --> 00:25:59.600
Whether you have success or failure,
there is a raftload of additional

00:25:59.600 --> 00:26:05.300
information you can get out of
SecTrust once it has evaluated.

00:26:05.300 --> 00:26:08.850
If you are interested in
this on the technical level,

00:26:08.860 --> 00:26:12.800
you can retrieve the certificate
chain as SecCertificates,

00:26:12.800 --> 00:26:12.800
of course.

00:26:12.800 --> 00:26:17.700
You can get information about
each certificate as to whether it

00:26:17.700 --> 00:26:20.450
was valid or why it wasn't valid.

00:26:20.460 --> 00:26:24.200
And you can get some other
sideband information.

00:26:24.200 --> 00:26:26.190
Whether you're actually
interested in this depends,

00:26:26.290 --> 00:26:28.420
again, on what you're planning on doing.

00:26:28.560 --> 00:26:33.490
If you are dealing with a naive user
and this isn't really your main job,

00:26:33.490 --> 00:26:35.230
you're just using this
for trust validation,

00:26:35.390 --> 00:26:38.190
you probably just want to
ignore that information,

00:26:38.250 --> 00:26:39.290
and that's fine.

00:26:39.480 --> 00:26:43.090
If you think you have an expert user
who wants to know about these things,

00:26:43.110 --> 00:26:45.920
call the UI function,
present the result to the user.

00:26:46.150 --> 00:26:48.640
That's probably the
easiest thing you can do.

00:26:48.730 --> 00:26:52.970
If you're writing a program whose main
job in life is to deal with certificates,

00:26:53.040 --> 00:26:56.340
then you may actually want to walk
through these results yourself and

00:26:56.340 --> 00:26:57.740
try to figure out what's going on.

00:26:57.800 --> 00:27:03.040
So, it depends on your purpose in life,
or your programs at least.

00:27:06.070 --> 00:27:10.380
After you make a SecTrust object,
what are the parameters you can stuff

00:27:10.480 --> 00:27:13.350
in there to change the way it works?

00:27:13.530 --> 00:27:17.660
The first and probably most
interesting thing is a policy.

00:27:17.750 --> 00:27:22.850
Policies are sets of rules
determining exactly when a certificate

00:27:22.850 --> 00:27:25.640
chain is considered to be valid.

00:27:25.690 --> 00:27:28.470
Different scenarios have different rules.

00:27:28.550 --> 00:27:32.380
For example,
SSL and SMIME have different rules

00:27:32.380 --> 00:27:35.770
on exactly what constitutes validity.

00:27:35.900 --> 00:27:39.160
They're not dramatically different,
but they're different enough that you

00:27:39.250 --> 00:27:43.790
have to tell the system the difference
and tell it exactly what you want.

00:27:44.840 --> 00:27:48.800
Some policies have policy
parameters that you have to pass in.

00:27:48.800 --> 00:27:52.230
For example,
SSL requires that you specify the

00:27:52.230 --> 00:27:56.630
URL of the server because it actually
needs to compare the URL embedded

00:27:56.630 --> 00:28:01.490
in the certificate against the one
that you actually connected to.

00:28:01.630 --> 00:28:04.130
And if those mismatch,
then technically your

00:28:04.130 --> 00:28:07.410
certificate is no good,
even though many browsers

00:28:07.410 --> 00:28:09.590
I could name just don't care.

00:28:10.260 --> 00:28:14.390
Another thing you can do if you
have additional certificates that

00:28:14.390 --> 00:28:18.110
could be useful to build the chain,
then pass them in.

00:28:18.360 --> 00:28:21.450
That's strictly for the use
of the system as it sees fit,

00:28:21.530 --> 00:28:27.500
so pass in lots of certificates
if you think they can be useful.

00:28:28.360 --> 00:28:33.080
In some situations, like SSL,
you actually get certificates

00:28:33.160 --> 00:28:36.600
out of the negotiation process
and you want to pass those in,

00:28:36.600 --> 00:28:37.570
obviously.

00:28:37.920 --> 00:28:42.260
You can also specify keychains to be
searched for additional certificates.

00:28:42.350 --> 00:28:45.920
Now, by default, you get the default
search list of the user,

00:28:46.040 --> 00:28:48.830
which is almost always the right thing.

00:28:49.040 --> 00:28:52.810
Basically, the user has a preference
of its keychains,

00:28:52.810 --> 00:28:56.460
his keychains, her keychains, whatever.

00:28:56.630 --> 00:28:58.960
Sometimes you want to change that.

00:28:58.960 --> 00:29:01.240
Sometimes you want to
just not search those,

00:29:01.240 --> 00:29:02.960
and so you pass an empty list in.

00:29:03.070 --> 00:29:06.420
Sometimes you want to add a
special keychain of yours that the

00:29:06.420 --> 00:29:07.970
user doesn't normally deal with.

00:29:08.090 --> 00:29:10.180
So you can do that.

00:29:10.500 --> 00:29:15.030
And while we provide a default
set of anchor certificates,

00:29:15.190 --> 00:29:20.670
trusted roots, if you have your own,
you can certainly add it and

00:29:20.670 --> 00:29:25.030
make it also be trusted as a
root of a certificate chain.

00:29:25.120 --> 00:29:27.810
You do that either because
you're a little bit of a

00:29:27.810 --> 00:29:31.800
hacker and you made your own,
or because you are part of

00:29:31.800 --> 00:29:36.600
an organization that has
its own certificate chains.

00:29:36.690 --> 00:29:42.130
And you want the corporate
certificates to be trusted,

00:29:42.130 --> 00:29:42.910
too.

00:29:46.540 --> 00:29:52.000
All right, so second step in this game,
as I said, after you've verified that

00:29:52.110 --> 00:29:57.000
the certificate chain works,
is you look up the certificate and

00:29:57.000 --> 00:29:59.600
the operation in some database.

00:29:59.650 --> 00:30:05.180
Well, we have a database for you,
and it's called the User Trust Database.

00:30:05.270 --> 00:30:07.600
It's actually stored
in the user's keychain,

00:30:07.600 --> 00:30:12.500
so it's a per-user kind of thing,
since obviously every user has a

00:30:12.500 --> 00:30:15.290
different idea of who you want to trust.

00:30:15.360 --> 00:30:19.160
And for the most part,
it tends to be handled pretty

00:30:19.160 --> 00:30:23.640
much automatically for you if
you're using the UI functions.

00:30:23.870 --> 00:30:25.660
Basically,

00:30:26.250 --> 00:30:29.700
You start a user with an empty slate,
nothing specified.

00:30:29.700 --> 00:30:33.260
So any SecTrust evaluation
comes out with "I don't know,

00:30:33.260 --> 00:30:36.880
user didn't say," which most
programs will map to "ask the

00:30:36.880 --> 00:30:40.100
user." So you ask the user.

00:30:40.200 --> 00:30:43.820
And the user, in addition to saying,
"Yeah, go ahead," or "No,

00:30:43.820 --> 00:30:48.130
don't do that," can, in that UI,
basically specify what he

00:30:48.260 --> 00:30:50.800
wants to happen the next time.

00:30:50.860 --> 00:30:53.870
I mean, this is the classical, "Well,
yeah, from now on,

00:30:53.870 --> 00:30:56.270
always," or "From now on,
never," or "Well,

00:30:56.270 --> 00:31:01.140
ask me again next time."
So in simple scenarios,

00:31:01.500 --> 00:31:03.990
you don't actually have to worry
about this particular slide,

00:31:04.070 --> 00:31:09.120
because the user will just be able
to fix his own database just fine.

00:31:09.290 --> 00:31:13.060
If, for some reason,
you actually need explicit access to it,

00:31:13.060 --> 00:31:16.500
you can, and that's called the
SecUserTrust functions.

00:31:16.500 --> 00:31:19.240
It's basically just a get
function and a set function.

00:31:19.290 --> 00:31:20.400
You specify a certificate.

00:31:20.400 --> 00:31:20.700
You specify a certificate.

00:31:20.700 --> 00:31:22.380
You specify an operation code.

00:31:22.480 --> 00:31:26.300
And that's all there is to it.

00:31:27.530 --> 00:31:31.140
The values associated with each
certificate and operation are of course,

00:31:31.270 --> 00:31:35.800
you know, yes, no, ask, or not specified,
the same ones that we've

00:31:35.800 --> 00:31:37.190
talked about before.

00:31:39.100 --> 00:31:40.910
The Apple CDSA framework
contains libraries that allow the

00:31:40.910 --> 00:31:43.530
interpretation of X.509 certificates
and provides examples of common ways

00:31:43.530 --> 00:31:45.880
to use these new APIs to provide
additional value to your customers.

00:31:45.880 --> 00:31:45.880
Ken McLeod, Perry 'the Cynic' Kiehtreiber

00:31:47.420 --> 00:31:52.580
Here's just an example they
slipped in for how the UI looks

00:31:52.580 --> 00:31:55.200
like for managing these.

00:31:55.260 --> 00:32:01.960
If you need to explicitly manage them,
but all you need to do is have the user

00:32:01.960 --> 00:32:08.390
edit the setting for a particular one,
you can actually call a function that

00:32:08.410 --> 00:32:10.370
just puts this up for you and asks the
user so you don't have to do your own UI.

00:32:15.500 --> 00:32:18.860
Enough about certificates.

00:32:18.940 --> 00:32:21.480
Access control is so much fun.

00:32:21.500 --> 00:32:27.650
It's basically about keeping
people from doing things.

00:32:27.650 --> 00:32:27.650
And you get paid for that, too.

00:32:27.990 --> 00:32:30.820
CFSM,
which in this session and the previous

00:32:30.820 --> 00:32:35.380
one everybody has been happy to tell you,
is a really complicated beast.

00:32:35.430 --> 00:32:39.210
It's got very,
very many functions that all have

00:32:39.220 --> 00:32:41.480
to be called in interesting ways.

00:32:41.600 --> 00:32:46.950
And so of course it's not surprising that
it also has an access control facility.

00:32:47.060 --> 00:32:50.460
That one is based on
access control lists,

00:32:50.510 --> 00:32:52.600
ACLs, as we all call them.

00:32:52.800 --> 00:32:59.800
[Transcript missing]

00:32:59.900 --> 00:33:14.900
[Transcript missing]

00:33:15.480 --> 00:33:18.830
This is pretty much the
minimum you need to know.

00:33:19.120 --> 00:33:21.280
So let's see.

00:33:23.360 --> 00:33:27.180
We're using, CSSM uses,
a lock-and-key approach.

00:33:27.490 --> 00:33:32.510
Basically, you set up a type of lock,
and the user has to provide a

00:33:32.510 --> 00:33:37.300
corresponding key to unlock,
and thereby permit an operation.

00:33:37.430 --> 00:33:42.220
The locks are called subjects,
that's just what they're called,

00:33:42.220 --> 00:33:44.930
and the keys are called samples.

00:33:46.480 --> 00:33:49.890
Access control lists are
attached to keychains,

00:33:50.060 --> 00:33:53.690
to keys, and to some items in keychains.

00:33:54.250 --> 00:33:56.500
It doesn't matter what
they're attached to.

00:33:56.500 --> 00:33:58.160
The mechanisms are all the same.

00:33:58.250 --> 00:34:03.040
So the rules for setting up ACLs,
evaluating ACLs, determining whether an

00:34:03.040 --> 00:34:06.050
operation is allowed or not,
doesn't depend on what kind

00:34:06.050 --> 00:34:07.650
of object is being protected.

00:34:07.930 --> 00:34:08.580
That's good.

00:34:08.600 --> 00:34:12.880
It means you don't have to
worry about details here.

00:34:13.620 --> 00:34:18.110
Each access control list
maps operations to subjects.

00:34:18.330 --> 00:34:24.160
Basically, for each operation,
you can specify the lock, the protection,

00:34:24.300 --> 00:34:28.390
that needs to be opened up in
order to perform this operation.

00:34:28.460 --> 00:34:32.460
So, for example,
you could theoretically say things like,

00:34:32.460 --> 00:34:35.700
"In order to encrypt with this key,
you need to provide this password.

00:34:35.700 --> 00:34:40.660
And in order to decrypt with this key,
put up a dialogue and ask the user." And,

00:34:40.790 --> 00:34:43.040
by the way,
this application over there is

00:34:43.050 --> 00:34:47.100
allowed to sign with this key
without having to do anything else.

00:34:47.260 --> 00:34:49.100
That would be one ACL configuration.

00:34:49.110 --> 00:34:52.150
A little bit strange,
but certainly possible.

00:34:52.520 --> 00:34:58.840
In addition to subjects and access
controls for each operation,

00:34:59.040 --> 00:35:03.280
there is one special
entry called the owner,

00:35:03.400 --> 00:35:07.160
which is the permission to
actually change the ACL itself.

00:35:07.270 --> 00:35:11.510
So access control lists are
protected by themselves,

00:35:11.510 --> 00:35:13.830
by the same ACL mechanism.

00:35:16.270 --> 00:35:21.990
There are theoretically an unlimited
number of different subject types

00:35:22.150 --> 00:35:25.100
because you can write your own.

00:35:25.100 --> 00:35:28.710
CSSM specifies about a dozen types,
of which I think we've

00:35:28.710 --> 00:35:32.220
implemented four or five,
plus three or four Apple-specific ones.

00:35:32.410 --> 00:35:37.690
But the most important ones that you
will come across are user confirmation,

00:35:37.690 --> 00:35:41.600
which is basically put up a dialogue
and ask the user whether it's okay.

00:35:41.670 --> 00:35:44.680
You have application identity,
which basically means if you

00:35:44.680 --> 00:35:48.170
happen to be that application,
you're allowed to do this.

00:35:48.370 --> 00:35:51.740
And simple passphrases,
which have nothing to do with

00:35:51.830 --> 00:35:53.870
the passphrases to keychains.

00:35:54.010 --> 00:35:59.780
They are extra passphrases you
can put onto items to guard them.

00:36:04.420 --> 00:36:08.450
Well,
how simple can we make this for you?

00:36:08.590 --> 00:36:11.130
We have SecAccessRef objects.

00:36:11.210 --> 00:36:15.860
A SecAccess object is all the
access controls on an item.

00:36:15.950 --> 00:36:19.540
It basically represents the
entire ACL complete with

00:36:19.680 --> 00:36:21.890
owner and all the trimmings.

00:36:22.530 --> 00:36:26.830
So, as long as you manipulate
SecAccess objects,

00:36:26.830 --> 00:36:29.590
at least you're not going to
drop half of the information

00:36:29.590 --> 00:36:31.600
somewhere along the wayside.

00:36:31.680 --> 00:36:36.690
SecAccess objects are not
tied to a particular item.

00:36:36.790 --> 00:36:41.060
They are valid on their own,
which means that you can derive them from

00:36:41.060 --> 00:36:44.820
one object and apply them to another,
or you can derive them from an object,

00:36:44.820 --> 00:36:47.970
change them,
and reapply them to make a change,

00:36:48.090 --> 00:36:51.290
or you can make them from
scratch and then apply them.

00:36:52.950 --> 00:36:58.250
The two major ways of making them are
either retrieving the current access

00:36:58.250 --> 00:37:01.700
control configuration from an item,
and again, it doesn't matter,

00:37:01.700 --> 00:37:06.610
it can be a keychain, a key,
a protected item in a keychain,

00:37:06.830 --> 00:37:11.580
or you can create it from scratch and
then populate it with your information.

00:37:13.050 --> 00:37:18.990
The uses are you can apply
a SecAccess to an item,

00:37:19.000 --> 00:37:22.920
which essentially changes its
access control configuration to

00:37:23.030 --> 00:37:25.300
be like the SecAccess specifies.

00:37:25.430 --> 00:37:29.620
Or you can pass it to an
item creation function,

00:37:29.740 --> 00:37:33.600
which will make the configuration
specified by the SecAccess to

00:37:33.600 --> 00:37:37.200
be the initial value of the
access control for the item.

00:37:37.310 --> 00:37:41.400
And by retrieving it from one item
and then applying it to another,

00:37:41.400 --> 00:37:43.000
you can copy access controls.

00:37:43.000 --> 00:37:46.360
So you can essentially say,
make this one protected just

00:37:46.360 --> 00:37:48.000
like that one over there.

00:37:51.500 --> 00:37:55.830
You need to know a little bit about
what's inside of a SAC access.

00:37:55.960 --> 00:38:02.780
Each SAC access contains
one or more SAC ACL objects.

00:38:02.900 --> 00:38:07.040
The name is probably not optimal,
but that's what they're called right now.

00:38:07.060 --> 00:38:13.760
So you have SAC ACL ref objects that
you can retrieve from a SAC access ref.

00:38:13.880 --> 00:38:18.640
And basically, each SAC ACL applies to
one particular operation.

00:38:18.720 --> 00:38:21.920
So you can have one for
encrypting and one for decrypting,

00:38:21.920 --> 00:38:24.160
or one for inserting
and one for deleting,

00:38:24.160 --> 00:38:26.910
or whatever your pleasure is.

00:38:28.620 --> 00:38:32.820
Up to this point, this represents the
full complexity of CSSM.

00:38:33.120 --> 00:38:36.400
You can have some
hacker made up a really,

00:38:36.400 --> 00:38:39.080
really complicated access
control list for an item.

00:38:39.290 --> 00:38:41.940
That works just fine because
the machinery that's actually

00:38:41.940 --> 00:38:46.100
implementing this stuff is completely
general and fully functional.

00:38:46.100 --> 00:38:49.690
The problem comes when you're
actually retrieving this from an

00:38:49.810 --> 00:38:53.900
item and you want to understand
what this access control list means.

00:38:54.490 --> 00:38:59.650
Because if it's really complicated,
you'd actually have to understand

00:38:59.650 --> 00:39:04.630
all of the CSSM ACL machinery,
which most of you probably want to avoid.

00:39:04.760 --> 00:39:09.680
So what we've given you is a small
subset that just happens to include

00:39:09.820 --> 00:39:13.940
all of the ACLs that are being
set up by default by our system.

00:39:14.030 --> 00:39:18.350
So as long as you don't have a hacker
doing really interesting things,

00:39:18.520 --> 00:39:23.060
the simple subset of access control
lists will work just fine for you.

00:39:23.180 --> 00:39:28.100
We call those simple,
and there is a function to take the

00:39:28.100 --> 00:39:31.340
simple contents out of a SAC ACL ref.

00:39:31.400 --> 00:39:33.110
And as an error,
you'll get back if the contents

00:39:33.110 --> 00:39:36.360
happen not to be simple,
in which case, depending on your purpose,

00:39:36.360 --> 00:39:40.440
you can either give up or you
can mark it as being complicated

00:39:40.440 --> 00:39:43.940
and not understandable.

00:39:44.030 --> 00:39:47.900
Or, well, whatever else you want to do.

00:39:48.260 --> 00:39:52.660
Simple XACLs,
simple access controls for an operation,

00:39:52.750 --> 00:39:58.200
simply consist of a list of applications
that are allowed to do the operation

00:39:58.260 --> 00:40:01.310
without any further restrictions.

00:40:02.670 --> 00:40:08.650
And if the requester happens to
be not one of those applications,

00:40:08.900 --> 00:40:10.840
then the user will be prompted.

00:40:10.940 --> 00:40:14.430
Now, most of you who have used
OS X have seen this happen.

00:40:14.530 --> 00:40:18.020
If you are trying to access
an item in a keychain,

00:40:18.310 --> 00:40:23.380
you tend to get this dialogue that says,
you know, typically what application

00:40:23.410 --> 00:40:27.580
so-and-so wants to do this and
that operation with item so-and-so.

00:40:27.660 --> 00:40:28.700
Do you want to allow it once?

00:40:28.700 --> 00:40:29.900
Do you want to allow it always?

00:40:29.900 --> 00:40:31.640
Or do you want to deny it?

00:40:31.760 --> 00:40:35.480
That's exactly what a simple ACL is.

00:40:35.580 --> 00:40:40.430
Basically, you get the dialogue if none
of the applications in the list

00:40:40.430 --> 00:40:44.390
happens to be the one that you're
running to make the request.

00:40:44.630 --> 00:40:49.290
So the options you have in terms of
information is you have the item name,

00:40:49.390 --> 00:40:52.800
which is actually stored
as part of the ACL.

00:40:52.900 --> 00:40:57.500
That is the name that guides the
item so-and-so in the dialog.

00:40:57.730 --> 00:41:01.500
And you have a couple of
options that's new for Jaguar.

00:41:01.500 --> 00:41:04.090
Specifically,
you're going to have an option

00:41:04.100 --> 00:41:07.660
in Jaguar to either just have a
dialog that lets the user say yes,

00:41:07.730 --> 00:41:12.480
no, always, or you can force the user to
re-enter the keychain passphrase.

00:41:12.500 --> 00:41:15.990
A lot of people have asked for that,
and so we've put it in.

00:41:16.170 --> 00:41:17.900
It's an option.

00:41:18.390 --> 00:41:21.800
Let me just emphasize that one more time.

00:41:21.800 --> 00:41:26.140
If you are running into a complex ACL,
which simply means a not simple one,

00:41:26.280 --> 00:41:27.260
try to leave it alone.

00:41:27.430 --> 00:41:29.890
Don't just go,
"I don't understand this," and replace

00:41:29.890 --> 00:41:31.760
it with something you understand.

00:41:31.880 --> 00:41:35.600
In particular,
you can copy complex ACLs from one

00:41:35.600 --> 00:41:39.790
item to another just fine by just
retrieving a sec access from one

00:41:39.790 --> 00:41:41.590
item and then applying it to another.

00:41:41.720 --> 00:41:42.600
That works.

00:41:42.600 --> 00:41:47.410
You just can't decompose it with the
simple API because they're not simple.

00:41:49.140 --> 00:41:52.120
Oh my, summary already.

00:41:52.560 --> 00:41:57.410
Okay, well,
most of these sec functions are new.

00:41:58.120 --> 00:42:04.710
They're all new for you because
they were private last time around.

00:42:05.650 --> 00:42:10.580
That means that they're
not there in 10.1.

00:42:10.580 --> 00:42:14.040
And if you want your code to
work in 10.1 and 10.2 together,

00:42:14.040 --> 00:42:16.470
unfortunately, you can't call them.

00:42:16.650 --> 00:42:19.300
Well, that's what happens with new APIs.

00:42:19.360 --> 00:42:22.710
You're pretty much stuck with
the KC layer if you want to write

00:42:22.930 --> 00:42:26.220
10.1 and 10.2 compatible code,
unless, of course,

00:42:26.280 --> 00:42:28.880
you want to have different code paths.

00:42:31.750 --> 00:42:36.940
They're sitting in
between the old KC layer,

00:42:36.940 --> 00:42:39.400
which is part of Carbon,
always part of Carbon,

00:42:39.530 --> 00:42:43.220
and the CSSM layer,
a little bit more towards

00:42:43.340 --> 00:42:44.590
the top than the bottom.

00:42:44.670 --> 00:42:46.970
And that's probably how
you should think of them.

00:42:47.140 --> 00:42:52.010
They are easier than CSSM and
more flexible than KC.

00:42:53.420 --> 00:42:58.300
We hope that for many of you it's just
about the right level of abstraction and

00:42:58.310 --> 00:43:00.780
just about the right level of simplicity.

00:43:00.780 --> 00:43:03.230
But let us know.

00:43:03.240 --> 00:43:08.400
We're certainly always interested
in finding out where you want to go.

00:43:09.710 --> 00:43:12.090
And nobody forces you to
actually use them all,

00:43:12.180 --> 00:43:12.510
really.

00:43:12.700 --> 00:43:16.040
I mean, there's no code in there that
checks to make sure you call

00:43:16.050 --> 00:43:17.700
each of them at least once.

00:43:17.840 --> 00:43:22.600
So, pick the one that sounds
like what you want,

00:43:22.610 --> 00:43:25.440
call it, ignore the rest, and, uh...

00:43:27.080 --> 00:43:30.900
If you know a little bit about CDSA,
whether that's because you like it

00:43:30.970 --> 00:43:34.720
or because somebody forced you to,
you are definitely

00:43:34.720 --> 00:43:37.100
welcome to mix and match.

00:43:37.240 --> 00:43:40.430
For example,
Ken talked about the bridge functions.

00:43:40.540 --> 00:43:44.190
Basically, for each abstract
API object in the sec layer,

00:43:44.190 --> 00:43:48.660
sec_keychain_refs, sec_item_refs,
sec_key_refs, sec_certificate_refs,

00:43:48.770 --> 00:43:54.000
there are functions that allow you
to retrieve associated CSSM objects.

00:43:54.740 --> 00:43:59.880
Often, if what you're trying to do isn't
quite covered by the Sec APIs,

00:43:59.880 --> 00:44:03.850
you can get away with 95%
Sec code and one of those bridge

00:44:03.950 --> 00:44:07.460
calls and one or two CSSM calls,
which is a heck of a lot easier

00:44:07.460 --> 00:44:08.830
than doing it all in CSSM.

00:44:08.860 --> 00:44:10.950
So don't think of this as all or nothing.

00:44:11.070 --> 00:44:15.500
Think of it as sort of a flexible
continuum that you can walk around in.

00:44:15.530 --> 00:44:21.550
Technically, you can call KC APIs,
use the resulting handles in Sec APIs,

00:44:21.620 --> 00:44:24.720
get a CSSM handle,
do a little bit of management down there,

00:44:24.740 --> 00:44:26.290
move back up, use Sec.

00:44:26.500 --> 00:44:29.250
That actually works.

00:44:30.060 --> 00:44:30.860
It's all for you.

00:44:31.120 --> 00:44:33.150
Try to use it.

00:44:33.260 --> 00:44:37.340
And, well, avoid micromanagement.

00:44:37.370 --> 00:44:41.580
I said this a few times already,
but let me say it one more time.

00:44:42.590 --> 00:44:48.150
We've put facilities in there,
access controls, certificate management,

00:44:48.150 --> 00:44:51.940
trust management,
that we think are about right as

00:44:52.030 --> 00:44:54.600
a shared facility in the system.

00:44:54.690 --> 00:44:57.690
Every time you go off and you
do your own in your program,

00:44:57.870 --> 00:45:02.590
your program becomes a little bit more
different from all the others around it.

00:45:02.710 --> 00:45:05.720
Maybe right now that doesn't matter
because you're the only application

00:45:05.720 --> 00:45:07.690
that's going to do this particular thing.

00:45:07.810 --> 00:45:10.260
But every time you go off
and do your own thing,

00:45:10.270 --> 00:45:13.700
rather than relying on trust management,
certificate management,

00:45:13.700 --> 00:45:19.320
identity management that we provide,
you'll get farther away from the

00:45:19.350 --> 00:45:22.910
shared system facilities that
make your program work well with

00:45:22.970 --> 00:45:24.900
other programs in the system.

00:45:24.980 --> 00:45:29.190
There are situations where you have to,
because what you do is just

00:45:29.260 --> 00:45:31.460
different or weird or special.

00:45:31.540 --> 00:45:34.600
But before you just go off and write
your own code to do this stuff,

00:45:34.600 --> 00:45:36.040
think about it a little bit.

00:45:36.220 --> 00:45:37.690
See if maybe what you want is
something that's more like a standard,

00:45:37.690 --> 00:45:37.700
but not something that's just a standard.

00:45:37.700 --> 00:45:41.490
Just a variant of the normal behavior.

00:45:41.560 --> 00:45:44.890
Your users will probably
thank you in the end.

00:45:48.540 --> 00:45:53.400
There's Craig again,
except his email is missing.

00:45:53.420 --> 00:46:01.000
But I suppose you're
supposed to send him email.

00:46:01.040 --> 00:46:02.470
Another slide.

00:46:02.600 --> 00:46:04.690
Ah, there he is.

00:46:09.980 --> 00:46:13.900
Well, we're one session
further down the roadmap.

00:46:13.900 --> 00:46:16.010
You've already missed
1.13 if you weren't there.

00:46:16.170 --> 00:46:17.900
That was before now.

00:46:17.990 --> 00:46:21.800
And you've suddenly missed authorization.

00:46:22.070 --> 00:46:29.000
CF Network is of interest to you if
you're doing things like web servers

00:46:29.000 --> 00:46:31.970
and stuff that does networking.

00:46:32.040 --> 00:46:35.900
Its only connection to security
really is if you're using SSL.

00:46:35.950 --> 00:46:40.940
CF Network, if you do HTTPS,
is using secure transport.

00:46:41.050 --> 00:46:46.750
Kerberos, if you're really interested in
ways of authenticating users,

00:46:46.750 --> 00:46:49.100
that might be of interest.

00:46:49.190 --> 00:46:51.630
And of course,
if you thought this presentation really,

00:46:51.630 --> 00:46:54.600
really, really stinks,
then go to the feedback

00:46:54.960 --> 00:46:57.190
forum and tell us about it.

00:46:58.930 --> 00:47:02.920
More stuff, I mean,
go to developer.apple.com and you

00:47:02.920 --> 00:47:04.750
can probably find most of this.

00:47:04.890 --> 00:47:07.610
And, yeah, this is all open source.

00:47:07.710 --> 00:47:08.680
Well, no.

00:47:09.040 --> 00:47:10.310
Not the UI stuff.

00:47:10.580 --> 00:47:15.000
But the UI stuff is, you know, Aqua,
liquidly, soft, and all that.

00:47:15.000 --> 00:47:16.390
That's OS X.

00:47:16.750 --> 00:47:20.260
But everything underneath is Darwin.

00:47:21.450 --> 00:47:24.160
So, go, take a look.

00:47:24.160 --> 00:47:28.460
If you're wondering how this all works,
take a printout to lunch.

00:47:28.540 --> 00:47:29.350
Have fun.
WEBVTT

00:00:04.290 --> 00:00:07.230
Hello, welcome everyone.

00:00:07.230 --> 00:00:09.640
Thank you very much for being here today.

00:00:09.640 --> 00:00:13.240
Hope you're enjoying WWDC this year
with all the really exciting things

00:00:13.240 --> 00:00:19.190
that Jaguar brings and possibilities
that Jaguar brings to you.

00:00:19.200 --> 00:00:23.260
We're particularly happy
today because right here,

00:00:23.260 --> 00:00:28.790
right now, is the first time,
first showing of Apple's implementation

00:00:28.790 --> 00:00:31.200
of hardware programmability.

00:00:31.490 --> 00:00:35.750
The OpenGL team has done a great
job in providing support for the

00:00:35.750 --> 00:00:40.250
mainstream programmable graphics
cards currently in the market,

00:00:40.250 --> 00:00:42.860
but they have done a lot more than that.

00:00:42.930 --> 00:00:47.370
What you see today is a set of
tools to allow you to preview,

00:00:47.370 --> 00:00:51.490
debug and optimize your
shader code in real time.

00:00:52.120 --> 00:00:57.430
These tools are available currently
right now on your Jaguar seating CD and

00:00:58.000 --> 00:01:03.110
we hope that this will become a staple
for you for hardware programming,

00:01:03.140 --> 00:01:07.000
certainly on the Apple platform,
even perhaps on any other platform

00:01:07.000 --> 00:01:09.000
you wish to deploy your application.

00:01:09.000 --> 00:01:13.770
We are very excited about
this first coming out and

00:01:13.770 --> 00:01:16.870
to welcome to the stage Mr.

00:01:16.870 --> 00:01:25.400
OpenGL Engineer Geoff Staahl.

00:01:29.740 --> 00:01:32.050
We're going to talk about graphics
programmability today across

00:01:32.050 --> 00:01:35.990
the spectrum from both vertex
programming and pixel programming.

00:01:36.130 --> 00:01:39.920
First, just an interesting show of hands,
who's actually written a vertex

00:01:40.050 --> 00:01:43.010
program or tried to even look at one?

00:01:44.100 --> 00:01:47.100
and more than I thought, maybe 20,
maybe 20 out of the audience.

00:01:47.160 --> 00:01:48.830
So what I'm going to try and
do is I'm going to try and

00:01:48.840 --> 00:01:51.620
give you a good introduction
to what vertex programming is,

00:01:51.980 --> 00:01:55.730
what pixel programming is,
so you can go out and use the tools and

00:01:55.830 --> 00:02:01.090
experiment and put these new features
into your applications and actually take

00:02:01.160 --> 00:02:03.870
advantage of the power that we have.

00:02:06.390 --> 00:02:07.340
So I'm Geoff Stahl.

00:02:07.370 --> 00:02:10.480
Myself and James McComb will
be doing the session today.

00:02:10.500 --> 00:02:14.380
I'll talk you through a little bit
about graphics programmability.

00:02:14.380 --> 00:02:17.810
Then James will take you through a
tutorial and I'll finish up at the end.

00:02:18.070 --> 00:02:20.220
What we're going to cover is,
first we're going to cover

00:02:20.270 --> 00:02:23.940
a little bit of evolution of
programmability in the graphics space.

00:02:24.000 --> 00:02:28.700
About 20 years ago,
Cook wrote a paper called Shade Trees.

00:02:28.760 --> 00:02:31.200
And that's kind of when everyone
started thinking about programmability.

00:02:31.240 --> 00:02:34.140
It followed on, and I'll go into details
in a few minutes,

00:02:34.220 --> 00:02:37.700
but we ended up where we are today
with commercial graphics processing

00:02:37.700 --> 00:02:41.370
units on your desktop that can handle
the programmability and do amazing

00:02:41.370 --> 00:02:43.400
things like we saw at the beginning.

00:02:43.550 --> 00:02:47.280
So, then we'll cover what is
graphics programmability.

00:02:47.330 --> 00:02:49.300
Then vertex programming.

00:02:49.400 --> 00:02:53.660
Finally, we'll go to James and the Shader
Builder tutorial and finish

00:02:53.660 --> 00:02:55.750
up with the fragment shading.

00:02:59.640 --> 00:03:02.340
So first,
let's talk about a little history here.

00:03:02.340 --> 00:03:05.000
1984,
and this is the same time frame when

00:03:05.000 --> 00:03:08.340
people were writing papers on how
to blend two objects on the screen.

00:03:08.340 --> 00:03:10.700
If you came from the
accelerated Windows Server,

00:03:10.930 --> 00:03:14.840
the same date,
same year as that paper about blending.

00:03:14.890 --> 00:03:18.080
Cook wrote the paper on shade trees,
which described a hierarchical

00:03:18.330 --> 00:03:23.340
shading language or a shading setup
that allowed you to put multiple

00:03:23.340 --> 00:03:27.960
programmable shaders onto different
objects and really set the groundwork

00:03:27.960 --> 00:03:31.040
in place for programs like RenderMan.

00:03:31.120 --> 00:03:33.040
Two years later,
Pixar brings out RenderMan,

00:03:33.040 --> 00:03:38.970
which still today is the kind of
benchmark by which all of their shaders

00:03:39.270 --> 00:03:41.630
or shading languages are measured.

00:03:41.740 --> 00:03:47.570
Moving on, 20 years later almost,
or 17 years later, Nvidia demonstrates,

00:03:47.820 --> 00:03:50.940
brings out the GeForce 3 and
demonstrates the Chameleon demo you saw.

00:03:51.010 --> 00:03:53.880
And more recently this year,
they demonstrated the Werewolf demo,

00:03:53.880 --> 00:04:00.160
which shows really desktop shading,
desktop programmability really

00:04:00.160 --> 00:04:03.020
that is fully programmable
and you can fully utilize.

00:04:03.110 --> 00:04:05.260
Up to this point we had
some configurability,

00:04:05.330 --> 00:04:06.640
but really didn't have
that programmability.

00:04:06.640 --> 00:04:11.530
So now it's on your desktop,
now you can buy a GeForce 4 Titanium,

00:04:11.530 --> 00:04:15.080
get an ATI Radeon 8500,
and you get that programmability

00:04:15.120 --> 00:04:16.970
onto your desktop.

00:04:17.140 --> 00:04:18.360
So where are we going from here?

00:04:18.400 --> 00:04:19.860
What's the future look like?

00:04:19.900 --> 00:04:22.340
Well, this project is like the
Stanford shader language.

00:04:22.370 --> 00:04:24.190
What that is,
is trying to take a render man type

00:04:24.250 --> 00:04:27.650
of language and bring it down to
the desktop being fully accelerated.

00:04:27.780 --> 00:04:30.580
Up to this point, when you,
companies that would implement

00:04:30.670 --> 00:04:33.090
things like render man,
what they would do is have a

00:04:33.160 --> 00:04:36.980
server farm out in the back that
would just churn away at frames.

00:04:37.280 --> 00:04:39.620
And so when, you know,
Pixar or film company,

00:04:39.690 --> 00:04:43.160
what they would do is they,
when you're not using your machine,

00:04:43.160 --> 00:04:45.990
they grab it and they use
it as a rendering engine.

00:04:46.290 --> 00:04:48.460
Well now, your desktop can be your
own rendering engine.

00:04:48.460 --> 00:04:51.330
You can do what you did 20
years ago that took a cray,

00:04:51.510 --> 00:04:53.820
days to do in real time on the desktop.

00:04:54.100 --> 00:04:56.110
I mentioned Doom 3 here also.

00:04:56.110 --> 00:04:57.090
Why Doom 3?

00:04:57.100 --> 00:04:59.560
I think you'll be surprised
in a few weeks when id shows

00:04:59.600 --> 00:05:04.100
it at E3 and then later in,
whenever they release that,

00:05:04.110 --> 00:05:09.030
that you'll see that it really requires
that programmable GPU on your desktop

00:05:09.100 --> 00:05:11.100
to get that good immersive performance.

00:05:11.100 --> 00:05:14.110
Up till now, games had, you know,
you can add on this feature,

00:05:14.110 --> 00:05:15.100
add on that feature.

00:05:15.100 --> 00:05:17.100
You need a little more fill rate.

00:05:17.110 --> 00:05:20.660
But this would be the first thing that
really requires mass market graphics

00:05:21.220 --> 00:05:23.030
programmability in the desktop to run it.

00:05:25.850 --> 00:05:28.100
So we saw the chameleon originally.

00:05:28.220 --> 00:05:30.640
Why is the chameleon important?

00:05:30.680 --> 00:05:33.430
Well that was one of the first
demos for the GeForce 3 and

00:05:33.440 --> 00:05:36.400
what it shows is a couple of
different areas of programmability.

00:05:36.440 --> 00:05:38.910
When you look at it at first
it looks cool and you think

00:05:38.910 --> 00:05:41.500
wow that's pretty neat,
look at those effects.

00:05:41.560 --> 00:05:43.340
What are they really doing there?

00:05:43.390 --> 00:05:45.900
One thing they're doing
is a skinned mesh.

00:05:45.960 --> 00:05:48.710
All the vertices for the chameleon
are passive static vertices.

00:05:48.800 --> 00:05:50.860
It has no movement per se.

00:05:50.910 --> 00:05:53.160
They're not manipulating a vertices
sending it to the graphics card.

00:05:53.220 --> 00:05:57.900
They're actually sending one
about 4 meg chunk of static data.

00:05:57.930 --> 00:06:01.720
Then they use a set of bones and
vertex programs to actually manipulate

00:06:01.720 --> 00:06:05.410
that static data and they use a
weighting structure to kind of stretch

00:06:05.410 --> 00:06:07.220
the vertices across the bones.

00:06:07.280 --> 00:06:10.340
And that's only available
through using a vertex program.

00:06:10.510 --> 00:06:12.260
It's also bump mapped as you saw.

00:06:12.300 --> 00:06:14.480
That bump mapping,
that per pixel bump mapping

00:06:14.480 --> 00:06:17.600
requires a combination of vertex
programs and pixel shaders.

00:06:17.650 --> 00:06:20.120
It has gloss mapping,
so you have multi pass.

00:06:20.170 --> 00:06:22.160
It has that shininess on it.

00:06:22.190 --> 00:06:23.510
Also it has a cubic environment map.

00:06:23.560 --> 00:06:25.260
You may have seen the reflective one.

00:06:25.300 --> 00:06:28.500
It uses a cubic environment
map and the chameleon itself to

00:06:28.500 --> 00:06:30.670
reflect the environment around it.

00:06:30.860 --> 00:06:34.280
Further, it has a glass version
that has glass in it.

00:06:34.320 --> 00:06:37.300
And if you also notice carefully,
and you look and see the leaf

00:06:37.390 --> 00:06:39.760
in the back of this picture,
you can see that the fogging,

00:06:39.770 --> 00:06:40.770
it's a very nice fogging.

00:06:40.780 --> 00:06:42.470
Things are fading out to the horizon.

00:06:42.470 --> 00:06:44.520
They're not just turning
a different color.

00:06:44.550 --> 00:06:49.380
That's done again through a vertex
program by manipulating the fog color.

00:06:49.380 --> 00:06:52.420
James will show you that later,
how you can actually manipulate the

00:06:52.420 --> 00:06:57.120
alpha value as a way of fogging objects.

00:06:57.670 --> 00:06:59.900
So for all those of you who have
never looked at a vertex program,

00:06:59.900 --> 00:07:01.160
what is programmability?

00:07:01.160 --> 00:07:05.410
What is the difference between a
traditional graphics pipeline and

00:07:05.490 --> 00:07:07.830
the programmable graphics pipeline?

00:07:08.560 --> 00:07:38.590
Transcription by Captioning &
Subtitling @Captioning.com.au So if

00:07:38.650 --> 00:07:41.400
you're writing a vertex program,
you need to understand that.

00:07:41.400 --> 00:07:44.460
You're taking world coordinates,
world information,

00:07:44.460 --> 00:07:47.840
and you're transforming that into
something that the rest of the pipeline,

00:07:47.850 --> 00:07:51.860
the rasterization step,
can then use to actually light

00:07:51.860 --> 00:07:54.400
or color and draw those pixels.

00:07:54.890 --> 00:07:56.580
Texture and Fragment Shader,
on the other hand,

00:07:56.640 --> 00:07:59.930
takes that information in,
has been clipped,

00:07:59.930 --> 00:08:03.980
has those pixels all stacked up there,
and then does both texture

00:08:03.990 --> 00:08:07.880
coordinate address generation,
which means where in the texture map that

00:08:07.880 --> 00:08:11.560
you've supplied is that pixel located,
and then also does the

00:08:11.560 --> 00:08:13.460
combination of multi-texturing.

00:08:13.550 --> 00:08:16.450
So as you saw, like for example,
the bump map gloss map,

00:08:16.540 --> 00:08:21.740
that is a function that requires multiple
textures to be combined onto each other

00:08:21.760 --> 00:08:25.420
to get the shininess in one texture,
the bumpiness from another texture,

00:08:25.450 --> 00:08:28.780
and the base color from
even a third texture.

00:08:29.710 --> 00:08:31.080
So where are we now?

00:08:31.150 --> 00:08:34.910
Mac OS X Jaguar,
the seed that you all have,

00:08:35.850 --> 00:08:38.920
The target is, let me back up,
Mac OS X Jaguar.

00:08:39.010 --> 00:08:41.790
The target for that
is our vertex program.

00:08:41.790 --> 00:08:45.560
It's a spec that takes both ATI,
NVIDIA and any other vendor's

00:08:45.600 --> 00:08:49.200
hardware into account and gives a one
unified spec that you can write to.

00:08:49.200 --> 00:08:51.200
You don't have to write
to something for ATI,

00:08:51.340 --> 00:08:53.380
something for NVIDIA,
something for Matrox and

00:08:53.480 --> 00:08:54.550
something for 3D Labs.

00:08:54.550 --> 00:08:57.630
This brings everything together
to give you one environment to

00:08:57.720 --> 00:08:59.410
write your vertex programs in.

00:08:59.850 --> 00:09:01.640
From the texture shader side,
we're not as lucky.

00:09:01.640 --> 00:09:06.130
Really, the hardware is still different
enough that there's not a unified

00:09:06.240 --> 00:09:07.600
specification for these things.

00:09:07.600 --> 00:09:09.540
So what we've done,
we've taken the best vendor

00:09:09.540 --> 00:09:12.780
specs on both sides and
implemented those in the Jaguar.

00:09:12.780 --> 00:09:14.220
And these are all in your seed.

00:09:14.220 --> 00:09:17.100
So we have texture shader 1, 2,
and 3 from NVIDIA, which is new.

00:09:17.100 --> 00:09:21.440
We still have register combiners 1 and 2,
which were there from the 10.1.

00:09:21.440 --> 00:09:26.240
And in ATI, we're looking to put
fragment shader into Jaguar.

00:09:26.240 --> 00:09:29.120
It is not in your seed currently,
but it looks like that's going

00:09:29.200 --> 00:09:32.200
to come along for Jaguar,
and that'll be there as a more

00:09:32.200 --> 00:09:35.900
unified for the ATI hardware
way to do fragment shading.

00:09:37.390 --> 00:09:39.000
So, what's the hardware support?

00:09:39.030 --> 00:09:41.560
What hardware do you need?

00:09:41.590 --> 00:09:43.540
Well, the bad news is,
to get the full hardware

00:09:43.550 --> 00:09:48.580
support you need a GeForce 3,
GeForce 4, or ATI-RADI-8500.

00:09:48.620 --> 00:09:49.430
We can expect that.

00:09:49.430 --> 00:09:52.400
That's when the shadings come along,
in the past year, year and a half.

00:09:52.440 --> 00:09:55.450
But the good news is,
is we have an optimized software

00:09:55.470 --> 00:09:56.940
solution for vertex programs.

00:09:57.010 --> 00:10:00.940
So all you guys out there with a laptop,
any laptop, don't care what it is,

00:10:00.960 --> 00:10:03.880
you can pop up the shader builder that
James is going to show you later and be

00:10:03.880 --> 00:10:07.570
sitting outside after the presentation,
not during the presentation,

00:10:07.570 --> 00:10:10.200
after the presentation,
and start building shaders.

00:10:10.330 --> 00:10:15.920
You don't need a GeForce 3, GeForce 4,
or ATI-RADI-8500 Radeon.

00:10:15.940 --> 00:10:17.520
You can just do it on
any machine you want,

00:10:17.520 --> 00:10:18.360
anytime you want.

00:10:18.360 --> 00:10:20.870
You can be on the plane flight
back home and fooling around

00:10:20.870 --> 00:10:24.470
with that vertex shader stuff,
experimenting and building cool

00:10:24.470 --> 00:10:26.380
shaders for your next project.

00:10:26.950 --> 00:10:30.260
So our vertex program,
this is new for Jaguar.

00:10:30.350 --> 00:10:31.860
As I said, it's a target for Jaguar.

00:10:32.150 --> 00:10:33.790
It's currently with
the arb working group,

00:10:33.800 --> 00:10:36.200
means it's not a finished spec.

00:10:36.340 --> 00:10:39.580
So what we did was for Jaguar,
we took a snapshot of that.

00:10:39.970 --> 00:10:42.940
And that's what you see actually
represented in Shader Builder.

00:10:43.180 --> 00:10:45.220
It's not quite what the
arb working spec will be,

00:10:45.220 --> 00:10:47.200
there are some syntactic differences.

00:10:47.290 --> 00:10:50.080
But the functionality
is almost 100% there.

00:10:50.260 --> 00:10:52.640
The reason we did this is we wanted
to get you something today that you

00:10:52.640 --> 00:10:56.540
could work with and then change the
commas and the spacing tomorrow.

00:10:56.630 --> 00:10:58.800
We'll be fully compliant with
the spec when it comes out.

00:10:59.000 --> 00:11:01.550
There are 84 issues currently
that were brought up.

00:11:01.990 --> 00:11:03.520
76 are completely resolved.

00:11:03.800 --> 00:11:04.600
There are 8 unresolved.

00:11:04.600 --> 00:11:08.130
We feel real confident that
in the next couple of weeks,

00:11:08.130 --> 00:11:09.680
those will be completely resolved.

00:11:09.770 --> 00:11:13.180
And you'll have a spec
that you can work with.

00:11:13.320 --> 00:11:15.590
If you're interested,
once the spec comes out,

00:11:15.670 --> 00:11:18.450
like all other specs,
it will be at the OpenGL.org and

00:11:18.450 --> 00:11:22.280
you can download it and see how
it's coming and track it there.

00:11:22.330 --> 00:11:25.020
And as I said,
Shader Builder will be updated

00:11:25.020 --> 00:11:26.280
in the final Jaguar edition.

00:11:26.310 --> 00:11:30.410
edition to be updated with
whatever the spec turns out to be.

00:11:30.700 --> 00:12:41.000
[Transcript missing]

00:12:42.320 --> 00:12:44.860
So why do you want to use vertex program?

00:12:44.930 --> 00:12:46.430
Why is it important to
you to learn about this?

00:12:46.530 --> 00:12:48.440
Why do you want to use it?

00:12:48.530 --> 00:12:51.650
Well first thing, as we've talked about,
one thing we're trying to do is

00:12:51.660 --> 00:12:56.930
transfer as much load from your programs
onto the graphics processing unit.

00:12:57.030 --> 00:13:00.680
GeForce 4 Titanium has
63 million transistors.

00:13:00.800 --> 00:13:04.200
The PowerPC has about
10 million transistors.

00:13:04.200 --> 00:13:07.620
There's a lot of effort,
a lot of specified hardware,

00:13:07.780 --> 00:13:12.140
specific hardware designed to do this
kind of operation in that graphics card.

00:13:12.230 --> 00:13:14.030
So why don't you let
it do that operation?

00:13:14.040 --> 00:13:17.040
Instead of trying to take the fixed
function pipeline and do a whole bunch

00:13:17.040 --> 00:13:20.480
of manipulations and kind of squeegee
your data around and do some strange

00:13:20.480 --> 00:13:24.100
things to actually make it fit in,
just write the vertex program that

00:13:24.100 --> 00:13:26.870
explicitly does and efficiently
does what you need it to do.

00:13:27.200 --> 00:13:28.970
That gets to the idea of efficiency.

00:13:29.100 --> 00:13:32.500
Some things it can do very well is
handle non-standard lighting models.

00:13:32.580 --> 00:13:33.440
Don't like gross shading.

00:13:33.440 --> 00:13:35.380
I want a phong shaded model.

00:13:35.490 --> 00:13:37.780
Well you can write a phong shaded model,
put it in your vertex

00:13:37.780 --> 00:13:38.840
program and there you go.

00:13:39.080 --> 00:13:41.960
Everything in your scene
will be phong shaded.

00:13:42.090 --> 00:13:45.540
Appropriate information down and
James will again show you something very

00:13:45.540 --> 00:13:48.990
similar to that in his demonstrations
and I think you'll be pretty impressed.

00:13:49.080 --> 00:13:50.440
It's also going to do skinning.

00:13:50.690 --> 00:13:51.910
We saw the skinning part of it.

00:13:52.170 --> 00:13:55.420
We saw that the chameleon used
skinning to manipulate the vertices.

00:13:55.720 --> 00:13:58.550
Passed static data down to
the GPU so it never had,

00:13:58.590 --> 00:14:03.420
every frame it's not sending down 40,
50,000 vertices.

00:14:03.420 --> 00:14:07.220
It passed it down once, put it in,
used a vertex array range and then

00:14:07.300 --> 00:14:11.930
uses the bone structure inside a vertex
program to manipulate that on the GPU.

00:14:12.020 --> 00:14:12.020
Very efficient.

00:14:12.020 --> 00:14:13.200
Okay.

00:14:13.750 --> 00:14:15.400
The last thing that we
can really do with it is,

00:14:15.400 --> 00:14:18.540
one of the things you can really do
with it is parametric vertex control.

00:14:18.630 --> 00:14:22.140
If I want to displace every vertex by
a certain amount from a certain point,

00:14:22.180 --> 00:14:25.170
I can pass that information into a
vertex program and it can do that.

00:14:25.270 --> 00:14:28.760
So I can do a standard transformation,
standard lighting,

00:14:28.800 --> 00:14:30.560
and then do some kind of
displacement based on some kind

00:14:30.560 --> 00:14:33.530
of action inside your application.

00:14:34.970 --> 00:14:37.030
Let's talk about the computation model.

00:14:37.060 --> 00:14:37.780
It's a vector engine.

00:14:38.000 --> 00:14:39.830
Every component of that
is a vector operation.

00:14:39.910 --> 00:14:43.110
There are four components, 32 bits each.

00:14:43.110 --> 00:14:44.900
It works on a single vertex.

00:14:44.900 --> 00:14:48.770
Think of it as a black box that
every single vertex that you pass

00:14:48.770 --> 00:14:50.890
to the GPU is passing through.

00:14:51.200 --> 00:14:53.660
No vertex prim- no- no
vertex generation is allowed.

00:14:53.660 --> 00:14:55.500
You can't take one
vertex and generate two.

00:14:55.570 --> 00:14:58.520
And you can't put in three
vertices or triangles or quads or

00:14:58.520 --> 00:14:59.890
whatever other primitives you want.

00:14:59.940 --> 00:15:01.700
It's a single vertex operation.

00:15:01.810 --> 00:15:03.130
It's also a state machine.

00:15:03.250 --> 00:15:06.140
Your application sets the inputs,
passes the vertex down,

00:15:06.140 --> 00:15:07.680
it operates on that vertex.

00:15:07.830 --> 00:15:08.740
There's no interdependence.

00:15:08.740 --> 00:15:12.410
I can't take the output of-
of the vertex program and feed

00:15:12.490 --> 00:15:14.000
it back into the next vertex.

00:15:14.090 --> 00:15:15.500
That has to be handled
by the application.

00:15:15.500 --> 00:15:18.220
Think about- if you want to
think about it in a simple way,

00:15:18.300 --> 00:15:21.180
think about it as every vertex
program works in parallel.

00:15:21.300 --> 00:15:24.230
If you think about it that way,
you realize that there's no way that one

00:15:24.230 --> 00:15:26.200
vertex program can affect the next one.

00:15:26.310 --> 00:15:27.340
There's no branching.

00:15:27.420 --> 00:15:29.100
It's a simple computational model.

00:15:29.180 --> 00:15:31.890
You can do an evaluate and select.

00:15:32.010 --> 00:15:35.700
The output data required by the current
rasterization model is required to

00:15:35.700 --> 00:15:37.530
be output by the vertex program.

00:15:37.620 --> 00:15:39.400
So if you have two texture
coordinates turned on- two

00:15:39.400 --> 00:15:43.890
texture- two texture units enabled,
you must pass that.

00:15:43.960 --> 00:15:46.520
You can pass texture coordinates
down for two texture units or you're

00:15:46.520 --> 00:15:47.990
going to have an undefined operation.

00:15:48.000 --> 00:15:51.100
The- the implementation is free to
generate random texture coordinates

00:15:51.100 --> 00:15:52.200
or use zeros or whatever.

00:15:52.200 --> 00:15:55.780
So understand what your state
is and understand what you need

00:15:55.870 --> 00:15:57.780
to actually pass out of that.

00:15:58.800 --> 00:16:01.160
So what's the input for vertex programs?

00:16:01.200 --> 00:16:02.840
Well first you have conventional input.

00:16:02.840 --> 00:16:05.900
The conventional input is things
you're used to seeing in OpenGL.

00:16:05.900 --> 00:16:10.260
Things like position, the normal,
color fog, and a vertex weight.

00:16:10.380 --> 00:16:11.590
Also you have texture coordinates.

00:16:11.590 --> 00:16:14.040
For all your texture units you
can pass down texture coordinates.

00:16:14.120 --> 00:16:15.760
And lastly you can pass
material properties.

00:16:15.950 --> 00:16:19.290
Not normally done in OpenGL as
a per vertex operation,

00:16:19.290 --> 00:16:24.640
but in the RVertex spec it does allow
you to do per vertex material properties.

00:16:24.760 --> 00:16:27.260
But you can think of it in a
totally different way if you like.

00:16:27.380 --> 00:16:29.770
You can think of those as just
a set of generic attributes.

00:16:29.870 --> 00:16:32.680
You can have a lookup table
of vertices and you pass an

00:16:32.750 --> 00:16:34.640
index in and pass a vertex out.

00:16:34.740 --> 00:16:36.140
If you wanted to do that you could.

00:16:36.140 --> 00:16:39.400
There's no limitation that you have
to conform to a standard OpenGL model.

00:16:39.400 --> 00:16:41.340
That's one of the beauties
of the vertex program.

00:16:41.410 --> 00:16:44.870
You can think kind of outside the
fixed pipeline or outside the box

00:16:44.870 --> 00:16:46.930
that defines and do whatever you want.

00:16:47.270 --> 00:16:50.250
As efficiently or as
inefficiently as you'd like.

00:16:50.570 --> 00:16:52.970
The maximum number of attributes,
because there's kind of a different

00:16:53.070 --> 00:16:55.700
combination of things you can do here,
are defined in the spec,

00:16:55.800 --> 00:16:59.300
max vertex attributes arb,
and the spec defines that

00:16:59.380 --> 00:17:02.040
there is 16 minimums,
so you're guaranteed that

00:17:02.040 --> 00:17:03.680
you have 16 attributes.

00:17:06.440 --> 00:17:09.700
and lastly, the read-only.

00:17:09.720 --> 00:17:13.560
Also, the other half of the input
is program parameters.

00:17:13.590 --> 00:17:15.860
These are kind of things that
would be outside of a begin end.

00:17:15.920 --> 00:17:19.500
So this is like parametric data that
you might define for an entire object,

00:17:19.580 --> 00:17:21.200
like a displacement.

00:17:21.230 --> 00:17:23.300
Or if you want to enlarge an object,
how much are you going

00:17:23.300 --> 00:17:24.240
to enlarge that object?

00:17:24.240 --> 00:17:27.600
Or a point to revolve the object around,
some kind of manipulation thing that

00:17:27.600 --> 00:17:30.760
you would do for an entire object,
not per vertex.

00:17:30.920 --> 00:17:32.770
They can either be OpenGL state,
as there's a lot of

00:17:32.870 --> 00:17:35.140
state defined for these,
or they can be user data.

00:17:35.160 --> 00:17:38.190
User data can either be local
to that program or it can work

00:17:38.190 --> 00:17:39.740
across a number of programs.

00:17:39.750 --> 00:17:43.180
And that's defined inside the
spec and when it comes out,

00:17:43.180 --> 00:17:44.940
I think you should look at it.

00:17:44.970 --> 00:17:47.610
They're very well defined
in how this works.

00:17:47.630 --> 00:17:48.550
In this case you have a lot of these.

00:17:48.650 --> 00:17:51.860
You have 96 minimum, the spec defines,
again it's queryable and

00:17:51.860 --> 00:17:53.910
implementation dependent.

00:17:54.260 --> 00:17:55.820
Again, inputs read only.

00:17:55.850 --> 00:17:57.970
You can't read and write the inputs,
you can't feed back into

00:17:58.030 --> 00:17:58.980
the next vertex program.

00:18:00.600 --> 00:18:02.450
Here's some examples
of what it looks like.

00:18:02.450 --> 00:18:05.340
I just wanted to put this up not
specifically to make any sense,

00:18:05.360 --> 00:18:06.930
but to give you a feel of
what it's going to look like.

00:18:07.050 --> 00:18:08.660
It's very assembly language looking.

00:18:08.770 --> 00:18:10.800
At the top you have a vertex position.

00:18:10.960 --> 00:18:11.500
Very simple.

00:18:11.500 --> 00:18:12.540
You have a normal.

00:18:12.610 --> 00:18:15.200
You have some shininess
or material properties.

00:18:15.290 --> 00:18:17.560
Some diffuse in the specular.

00:18:17.670 --> 00:18:19.270
Then the bottom part you
have some parameters.

00:18:19.550 --> 00:18:21.080
Things like the model view matrix.

00:18:21.210 --> 00:18:23.360
You're going to take the inverse
transpose of whatever the model

00:18:23.360 --> 00:18:26.570
view matrix was when you submitted
the vertex and you're going

00:18:26.570 --> 00:18:27.600
to have that in your program.

00:18:27.710 --> 00:18:29.600
Obviously this is real critical
for that transformation.

00:18:29.600 --> 00:18:33.750
You can't really transform things
from your world space to the

00:18:33.800 --> 00:18:37.090
viewport unless you're going
to have the model view matrix.

00:18:37.200 --> 00:18:41.110
Then also you can get the model
view projection matrix for example.

00:18:41.190 --> 00:18:43.100
That's without the inverse.

00:18:43.100 --> 00:18:44.740
You're just taking it directly.

00:18:44.890 --> 00:18:46.000
There's lighting state.

00:18:46.120 --> 00:18:48.740
And then there's program environment
variables down there just enumerated.

00:18:48.740 --> 00:18:51.170
So you can pass your parameters
just in program environment

00:18:51.170 --> 00:18:52.350
variables directly in.

00:18:52.640 --> 00:18:56.110
And lastly you can use
parameters for constants.

00:18:57.120 --> 00:19:00.700
So, now that you have the inputs,
what are you operating on when you're

00:19:00.700 --> 00:19:01.900
actually running your vertex program?

00:19:01.900 --> 00:19:04.580
They're program locals or temporaries.

00:19:04.580 --> 00:19:09.320
There are four components, 32 bits each,
very symmetrical across the

00:19:09.320 --> 00:19:11.530
whole vertex program engine.

00:19:11.530 --> 00:19:13.460
And you have to declare them explicitly.

00:19:13.460 --> 00:19:16.490
You see an example of
one at the bottom there?

00:19:17.210 --> 00:19:21.560
That's a normal temp,
a dot product maybe,

00:19:21.630 --> 00:19:22.850
or temporary color storage.

00:19:23.120 --> 00:19:25.020
They're both read and write,
so you can store-- they're a

00:19:25.150 --> 00:19:27.260
scratch space for you to work with.

00:19:27.390 --> 00:19:30.600
Defines as 12 minimum, and they're also
implementation dependent.

00:19:30.600 --> 00:19:33.990
If the implementation can support more,
they'll advertise how many

00:19:33.990 --> 00:19:35.530
they can support to you.

00:19:36.740 --> 00:19:37.940
Output is a lot simpler.

00:19:37.940 --> 00:19:41.500
We've seen like sixteen attributes,
ninety-six parameters,

00:19:41.650 --> 00:19:42.520
twelve local variables.

00:19:42.680 --> 00:19:44.540
Output is pretty defined.

00:19:44.580 --> 00:19:46.870
Output has the outputs I list there.

00:19:46.890 --> 00:19:49.360
Positioning clip coordinates,
required output.

00:19:49.390 --> 00:19:52.500
Doesn't make sense to spit a vertex out
unless you have a vertex to spit out.

00:19:52.500 --> 00:19:56.440
You have to put a vertex out there
with actual coordinates there.

00:19:56.500 --> 00:19:59.160
Color front, back, primary, secondary.

00:19:59.160 --> 00:20:01.290
So you can do the back secondary
color or the front primary color.

00:20:01.370 --> 00:20:03.310
You can output all four of those options.

00:20:03.500 --> 00:20:05.490
A fog coordinate.

00:20:05.800 --> 00:20:08.940
Point size and texture coordinates
for however many texture units

00:20:09.010 --> 00:20:11.980
you have or have enabled if you
want to think of it that way.

00:20:11.980 --> 00:20:14.790
Because if you haven't enabled it,
it makes no sense to output

00:20:14.800 --> 00:20:16.060
a texture coordinate.

00:20:18.270 --> 00:20:22.380
Again, this is why I stated before,
understand your rasterization model,

00:20:22.380 --> 00:20:24.170
understand the texture
coordinates enabled,

00:20:24.190 --> 00:20:25.500
understand what you're
doing with it later,

00:20:25.500 --> 00:20:27.740
whether you have fog
turned on or not turned on,

00:20:27.810 --> 00:20:31.320
and make sure you put out
all the outputs you need.

00:20:31.430 --> 00:20:32.400
These are write only.

00:20:32.480 --> 00:20:36.350
You write to them, they pass out,
and there you go.

00:20:36.500 --> 00:20:38.970
So an example of these
are result position,

00:20:38.970 --> 00:20:42.220
result color, color back secondary,
result fog.

00:20:42.510 --> 00:20:42.850
Pretty simple.

00:20:42.860 --> 00:20:44.860
I mean this is really
simple stuff to read.

00:20:44.860 --> 00:20:46.140
It's pretty readable.

00:20:46.220 --> 00:20:49.140
You can look through the vertex program
and since it is not a looping flow,

00:20:49.140 --> 00:20:51.380
it's not a branching flow,
everything is declared explicitly,

00:20:51.380 --> 00:20:54.480
you can read through it and
really tell what it's going to do.

00:20:55.510 --> 00:20:56.500
Let's look at the instruction set.

00:20:56.500 --> 00:20:58.830
The instruction set,
as you may have guessed with my

00:20:58.830 --> 00:21:01.240
inference to assembly language,
it is basically an assembly

00:21:01.240 --> 00:21:02.500
language instruction set.

00:21:02.500 --> 00:21:04.500
But it is graphically oriented.

00:21:04.500 --> 00:21:06.500
It's a limited subset of instructions.

00:21:06.500 --> 00:21:06.780
Not that many.

00:21:06.780 --> 00:21:07.500
It's not 100 instructions.

00:21:07.500 --> 00:21:09.430
It's more like 25 instructions.

00:21:09.500 --> 00:21:12.500
You also have special
properties you can do.

00:21:12.500 --> 00:21:14.500
You can do a source swizzle in the gate.

00:21:14.520 --> 00:21:16.680
So you can take four component vector.

00:21:16.910 --> 00:21:18.500
You can take x, y, z and w.

00:21:18.500 --> 00:21:21.500
And I want to use x,
y in the opposite order in my multiply.

00:21:21.500 --> 00:21:25.600
So I can do y.x, z, w.

00:21:25.600 --> 00:21:29.080
And when the multiply happens,
it will swap those two and use

00:21:29.170 --> 00:21:32.500
that in its final determination
of the result there.

00:21:32.530 --> 00:21:33.930
You also can do a write mass.

00:21:33.930 --> 00:21:36.480
You can say I only want
to write the w coordinate.

00:21:36.490 --> 00:21:38.500
For example, it's really good in fog.

00:21:38.500 --> 00:21:40.490
If you are, for alpha values.

00:21:40.500 --> 00:21:44.410
If you want to write your position with
one set of operations and then write

00:21:44.410 --> 00:21:47.500
your w or alpha value with another set,
you can mask off the w.

00:21:47.550 --> 00:21:48.500
And then you can write your w.

00:21:48.500 --> 00:21:50.600
you can just write to the w.

00:21:52.160 --> 00:21:56.470
Minimum defined in the spec
is going to be 128 operations.

00:21:56.510 --> 00:21:59.360
But implementations again are
free to implement more than this.

00:21:59.400 --> 00:22:01.340
You can query that.

00:22:01.460 --> 00:22:03.140
Most instructions are single operation.

00:22:03.260 --> 00:22:05.040
The spec does note that
some may be compound.

00:22:05.040 --> 00:22:08.000
For example,
the cross product instruction could be

00:22:08.400 --> 00:22:10.340
two instructions substituted in there.

00:22:10.380 --> 00:22:11.440
And that's noted in the spec.

00:22:11.440 --> 00:22:13.640
And again, when it comes out,
I think you should look clearly

00:22:13.640 --> 00:22:16.330
at that when you're implementing
your program if you're getting

00:22:16.380 --> 00:22:18.010
near that instruction limit.

00:22:19.000 --> 00:22:21.100
So let's look at the
instruction set a little bit.

00:22:21.100 --> 00:22:24.560
Just kind of looking through it,
you have an address register load,

00:22:24.670 --> 00:22:28.050
you have some arithmetic instructions.

00:22:28.370 --> 00:22:30.670
Things you see that are graphically
oriented are dot product,

00:22:30.670 --> 00:22:33.830
dot product 3,
dot product 4 and the cross product.

00:22:34.220 --> 00:22:35.560
You have some min/maxes.

00:22:35.650 --> 00:22:38.110
The set less than and set
greater than you can use for

00:22:38.210 --> 00:22:39.640
the branching and selection.

00:22:39.790 --> 00:22:42.360
And then there's a whole bunch
of math instructions at the end.

00:22:42.610 --> 00:22:44.740
So it's a graphically
oriented assembly language.

00:22:44.960 --> 00:22:45.550
This is it.

00:22:45.550 --> 00:22:48.950
This is all that's defined in
the current ARB spec as existing.

00:22:49.170 --> 00:22:51.500
So there's not a page and a
page of instructions to learn.

00:22:51.500 --> 00:22:53.450
It's pretty simple.

00:22:54.880 --> 00:22:57.560
So now I'm going to take you through
an arb-vertex program example,

00:22:57.560 --> 00:23:00.050
just to kind of look at it,
get some ideas of what it looks like,

00:23:00.130 --> 00:23:01.800
what you're going to
see when James comes up.

00:23:01.800 --> 00:23:03.800
I want to point out one thing here.

00:23:03.800 --> 00:23:05.800
Again,
with the Jaguar seed that you have,

00:23:05.800 --> 00:23:07.800
we have a fully
functional vertex program.

00:23:07.800 --> 00:23:11.050
The syntax is slightly different from
what you see here because it was evolving

00:23:11.050 --> 00:23:12.680
and we had to lock it down at some point.

00:23:12.950 --> 00:23:15.790
The syntax you see here or something,
or whatever the arb decides on,

00:23:15.840 --> 00:23:17.800
which will probably be almost
exactly what you see here,

00:23:17.800 --> 00:23:22.480
will be in the final arb spec
and our shader builder tool,

00:23:22.880 --> 00:23:26.690
which James will show you,
will be updated to reflect that.

00:23:26.800 --> 00:23:29.210
So if we look at this,
this declares a vertex

00:23:29.210 --> 00:23:32.830
program at the beginning,
normal in a position,

00:23:32.940 --> 00:23:35.800
grabs an inverse transform
in the model view matrix,

00:23:35.860 --> 00:23:39.070
grabs the model view projection matrix,
sets some program environment

00:23:39.070 --> 00:23:44.790
variables for some different stuff,
from lighting angles, the half angle.

00:23:44.860 --> 00:23:46.800
So obviously if you look at this and
you're familiar with lighting models,

00:23:46.830 --> 00:23:49.720
you can see this is basically going
to do a lighting model for you.

00:23:49.830 --> 00:23:53.120
There's a temporary declaration there,
and you can see it then declares

00:23:53.120 --> 00:23:56.750
the output color and output result,
explicitly declaring everything

00:23:56.800 --> 00:23:57.770
you need to operate on.

00:23:57.820 --> 00:24:01.800
So you can look at that and say, okay,
here's my working set of stuff.

00:24:01.800 --> 00:24:03.790
So here's what it does.

00:24:03.910 --> 00:24:05.280
The beginning of it is pretty simple.

00:24:05.280 --> 00:24:07.800
It's going to do a transform
and output the output positions.

00:24:07.800 --> 00:24:10.560
It does some of the
lighting calculations.

00:24:10.870 --> 00:24:13.190
And if you look at the end here,
you can see it finishes

00:24:13.540 --> 00:24:17.020
out with output color x,
y, z, putting out the x, y,

00:24:17.100 --> 00:24:19.650
and z parts of that output
color using the results of

00:24:19.650 --> 00:24:22.680
its lighting calculation here,
and then ends.

00:24:22.800 --> 00:24:25.600
So that's kind of what you're
looking at in vertex programs.

00:24:25.970 --> 00:24:29.890
They're fairly low level, but again,
it's an efficient way of doing a lot

00:24:29.890 --> 00:24:31.800
of the operations you want to do.

00:24:31.800 --> 00:24:35.800
You don't have to worry about
300 or 400 state variables,

00:24:35.800 --> 00:24:38.790
setting them up,
doing a whole bunch of work on the CPU.

00:24:38.800 --> 00:24:42.360
You can write a vertex program in these
instructions to do really whatever you

00:24:42.360 --> 00:24:44.800
want to do and ensure that you get the
most efficient operation out of it.

00:24:44.800 --> 00:24:46.670
operation out of it.

00:24:47.690 --> 00:24:50.470
What I haven't talked about and
I'll spend one slide on it is the

00:24:50.470 --> 00:24:52.400
OpenGL interface to all of this.

00:24:52.490 --> 00:24:54.260
Again, fairly simple.

00:24:54.360 --> 00:24:57.340
You're going to generate a program
just like a text for generation.

00:24:57.420 --> 00:24:59.760
You're going to bind to that
program to make it active.

00:24:59.830 --> 00:25:02.760
One thing I don't have in here
is you'll enable the program.

00:25:02.850 --> 00:25:06.000
The next thing you'll do is,
I want to read the program string.

00:25:06.100 --> 00:25:09.690
Programs are just strings that you
can read directly into it as in the

00:25:09.790 --> 00:25:12.800
program string arb function there.

00:25:12.860 --> 00:25:15.600
That takes the entire
program string and parses it.

00:25:15.670 --> 00:25:17.600
To set context parameters
that you may have seen,

00:25:17.600 --> 00:25:21.100
the environment parameters,
that would be a way of doing that.

00:25:21.230 --> 00:25:25.170
And then inside the begin end you
would do things like vertex attribute

00:25:25.170 --> 00:25:30.600
4f and set whatever that vector is for
the attribute and then set a vertex.

00:25:30.810 --> 00:25:33.920
Lastly, once you're done with the end,
let me back up a little bit.

00:25:34.220 --> 00:25:37.520
Once you call the vertex, that vertex 3f,
that actually invokes the program.

00:25:37.700 --> 00:25:41.600
That call is what says execute
this program on that vertex.

00:25:41.600 --> 00:25:43.600
So you can actually think about it,
as soon as you call that,

00:25:43.600 --> 00:25:45.880
whatever state you have at
that point is passing into

00:25:45.880 --> 00:25:49.600
the vertex program as needed,
and that's going to be executed on.

00:25:49.660 --> 00:25:51.600
Lastly,
when you're done with the programs,

00:25:51.600 --> 00:25:53.600
please delete them and
clean up after yourself.

00:25:53.600 --> 00:25:56.600
So, this brings us to Shader Builder.

00:25:56.600 --> 00:25:58.480
Shader Builder is new for Jaguar.

00:25:58.770 --> 00:26:00.600
It's a great tool.

00:26:00.600 --> 00:26:02.600
It's a tool that allows
you to interactively debug

00:26:02.650 --> 00:26:04.600
and build vertex programs.

00:26:04.600 --> 00:26:07.580
And James McComb is going to come on up,
and he's going to show you

00:26:07.580 --> 00:26:08.600
a demo of Shader Builder.

00:26:08.620 --> 00:26:10.600
Come on up, James.

00:26:10.600 --> 00:26:12.710
And he's going to take you through that.

00:26:19.690 --> 00:26:20.770
Hi.

00:26:20.770 --> 00:26:24.870
So, yes, today I'm going to tell you a
little bit about Shader Builder.

00:26:24.970 --> 00:26:28.770
Basically what we noticed at
Apple whenever I was working on the

00:26:29.130 --> 00:26:33.380
implementation of the vertex program
specification was a distinct lack

00:26:33.510 --> 00:26:36.370
of tools for writing these shaders.

00:26:36.600 --> 00:26:38.600
I mean, it's all very well.

00:26:38.600 --> 00:26:42.530
Fire up Emacs, start writing a program,
save it, and then of course you've got to

00:26:42.530 --> 00:26:44.980
make all the open-- you've got
to write like a GLAD application

00:26:45.070 --> 00:26:48.600
or something and make all the
OpenGL calls to load in the shader.

00:26:48.950 --> 00:26:51.600
And then enable it.

00:26:51.600 --> 00:26:52.600
And there's a whole lot of
other work you have to do.

00:26:52.600 --> 00:26:55.540
And this is just to like
test your shader once.

00:26:55.580 --> 00:26:58.600
Then you might have little typos in it,
syntax errors.

00:26:58.600 --> 00:27:01.980
Not to mention,
although there's a limited set of

00:27:02.060 --> 00:27:05.180
opcodes you can use in these things,
they're quite-- the logic is a

00:27:05.180 --> 00:27:06.600
little difficult to figure out.

00:27:06.600 --> 00:27:09.850
And we thought, hey,
wouldn't it be really great to have

00:27:10.120 --> 00:27:14.350
a system whereby we could just start
typing them and have things appear

00:27:14.350 --> 00:27:18.850
in real time and people wouldn't even
have to create an OpenGL application

00:27:18.850 --> 00:27:21.480
framework to start doing their stuff.

00:27:21.600 --> 00:27:26.040
So that was the sort of birth of
the idea of Shader Builder and it's

00:27:26.040 --> 00:27:28.590
been worked on now for some time.

00:27:28.610 --> 00:27:31.600
So we believe it's a world class tool.

00:27:31.600 --> 00:27:35.600
We don't think you'll see anything
like it on any other platform.

00:27:35.600 --> 00:27:37.600
At the moment.

00:27:37.660 --> 00:27:41.550
And we think it'll be very
helpful for you all to use.

00:27:41.660 --> 00:27:46.510
So now I'm going to start
here and show you some of the

00:27:46.550 --> 00:27:49.260
features of Shader Builder.

00:27:49.930 --> 00:27:50.550
Here it is.

00:27:50.790 --> 00:27:56.550
And I'll just identify the main
sort of areas in the user interface.

00:27:56.770 --> 00:28:00.750
Basically you can see, this is,
I'm selecting it,

00:28:01.060 --> 00:28:03.860
that is the vertex program right there.

00:28:04.030 --> 00:28:05.960
That's currently being ran.

00:28:06.460 --> 00:28:10.600
This is the OpenGL output rendering.

00:28:10.600 --> 00:28:15.110
This area here, which I'm circling,
is the controls to allow you

00:28:15.110 --> 00:28:18.760
to do interactive debugging
with Shader Builder.

00:28:18.760 --> 00:28:22.760
Basically, I'll talk about it later,
but it basically allows you to do

00:28:22.760 --> 00:28:25.600
step by step debugging using an
inbuilt software emulation we have.

00:28:25.600 --> 00:28:30.050
We can step through and you can watch
the state of the hardware registers

00:28:30.050 --> 00:28:34.600
and it's very useful for being able
to analyze the logic in your program.

00:28:34.600 --> 00:28:39.540
Also, over here on the right,
which I can slide in and out,

00:28:39.800 --> 00:28:44.200
we have a pop-out reference
with all the opcodes used in

00:28:44.200 --> 00:28:46.600
the arb vertex program spec.

00:28:46.600 --> 00:28:49.590
And as you select them,
you can see here the documentation.

00:28:49.600 --> 00:28:52.190
This is taken straight
out of the white paper,

00:28:52.190 --> 00:28:54.550
the documentation for all the opcodes.

00:28:54.650 --> 00:28:56.240
top codes.

00:28:56.410 --> 00:28:59.520
and of course I can double click any
of these and they will appear at the

00:28:59.600 --> 00:29:01.250
current cursor position in the text.

00:29:01.310 --> 00:29:06.410
Also here, if I just select that,
there's only one entry

00:29:06.410 --> 00:29:07.300
there at the moment.

00:29:07.330 --> 00:29:10.500
Arb Vertex Program.

00:29:10.650 --> 00:29:16.090
It is our hope further down the
line as new shader languages appear,

00:29:16.090 --> 00:29:20.300
like whenever the arb manages to
finalize fragment shader spec.

00:29:20.300 --> 00:29:22.760
We'd like to be able to include
that in Shader Builder so you

00:29:22.760 --> 00:29:26.370
could just literally go down here,
select arb fragment program,

00:29:26.370 --> 00:29:29.610
if that's what it's called,
and the parser that is used to parse your

00:29:29.610 --> 00:29:33.300
program will change to that and Shader
Builder's behavior will change somewhat

00:29:33.300 --> 00:29:35.300
so that you can write fragment programs.

00:29:35.310 --> 00:29:38.310
We just wanted to have a unified way
of being able to do this that was

00:29:38.350 --> 00:29:40.300
clean and would save you a lot of time.

00:29:40.300 --> 00:29:44.560
So now I'm going to explain
in a little more detail what

00:29:44.560 --> 00:29:47.300
actually is going on right now.

00:29:47.300 --> 00:29:50.300
You can see that there's like a
white circle being drawn here.

00:29:50.430 --> 00:29:53.680
What's actually going on is
Shader Builder is submitting

00:29:53.680 --> 00:29:57.760
a series of vertices to the
beginning of the OpenGL pipeline.

00:29:58.360 --> 00:30:04.560
They comprise a sphere and this program
is replacing the transformation,

00:30:04.560 --> 00:30:09.300
clipping,
and lighting part of the pipeline.

00:30:09.300 --> 00:30:13.030
It is being run once for every
vertex going through and then the

00:30:13.030 --> 00:30:17.300
rasterizer is picking up the output
vertices the program's emitting

00:30:17.300 --> 00:30:19.290
and it is rendering them up here.

00:30:19.300 --> 00:30:22.290
This is a very simple program.

00:30:22.300 --> 00:30:25.570
In fact, this is the simplest vertex
program really you can have that

00:30:25.610 --> 00:30:27.300
would be of any use to you at all.

00:30:27.300 --> 00:30:32.980
Basically, these three lines,
they declare three variables

00:30:32.990 --> 00:30:34.300
inside the program.

00:30:34.300 --> 00:30:39.240
They basically bind to attributes
of the incoming vertex,

00:30:39.290 --> 00:30:44.090
both the position, color,
and the incoming texture coordinate.

00:30:44.300 --> 00:30:48.220
This line here binds to the vertex.

00:30:48.300 --> 00:30:52.300
This line here binds to the model view
projection matrix inside of OpenGL.

00:30:52.300 --> 00:30:55.300
It's a fairly straightforward syntax.

00:30:55.300 --> 00:30:58.220
Remember, all the commodities are
four component vectors.

00:30:58.360 --> 00:31:01.380
That's why I've got a bracket
four just like the C array syntax,

00:31:01.710 --> 00:31:04.300
basically declaring a
four by four matrix.

00:31:04.410 --> 00:31:09.350
These three lines right here,
they declare three more

00:31:09.350 --> 00:31:13.300
variables which are bound to
the outgoing vertex structure.

00:31:13.360 --> 00:31:15.300
And that's what I'm trying to fill out.

00:31:15.300 --> 00:31:17.160
When I fill that out,
that is what the rasterizer will render.

00:31:17.650 --> 00:31:21.430
These four lines perform
four dot products,

00:31:21.610 --> 00:31:27.290
basically transforming the incoming
vertex position by the four rows inside

00:31:27.300 --> 00:31:28.300
the model view projection matrix.

00:31:28.300 --> 00:31:34.280
And they fill it out
into the output vertex.

00:31:34.300 --> 00:31:38.300
And this right there is
a simple move operation.

00:31:38.300 --> 00:31:42.300
I'm just moving the incoming vertex
color to the output and next line exactly

00:31:42.360 --> 00:31:44.280
the same with the texture coordinate.

00:31:44.370 --> 00:31:46.270
So it's simply, it's called pass through.

00:31:46.360 --> 00:31:48.090
It's just a simple pass through.

00:31:48.350 --> 00:31:52.300
If I select this button right here,
GL parameters,

00:31:52.570 --> 00:31:58.300
this allows me to change some of the
attributes of the incoming vertices.

00:31:58.300 --> 00:32:03.950
If I click on this color well right here,
basically of course there's a GL color 3F

00:32:04.000 --> 00:32:07.290
call being made to set the color of all
the vertices that are being submitted.

00:32:07.300 --> 00:32:10.300
By sliding this around,
of course I can change that.

00:32:10.300 --> 00:32:15.290
And since it's passing it through,
you can see the white circle changing.

00:32:15.300 --> 00:32:20.450
Of course also I have control over,
if I select this,

00:32:20.450 --> 00:32:25.300
it allows me individual control of the
texture units on the graphics card.

00:32:25.460 --> 00:32:30.300
And I can load textures and enable
and disable them individually.

00:32:30.300 --> 00:32:37.410
So the next little thing
I'd like to show you is,

00:32:37.410 --> 00:32:40.440
I'm going to start making some
changes to this program to make

00:32:40.540 --> 00:32:41.300
things a little more interesting.

00:32:41.300 --> 00:32:44.300
And also to show you one of
the really nicest things.

00:32:44.300 --> 00:32:47.060
One of the really nicest
features of this tool.

00:32:47.550 --> 00:32:50.210
What I'm going to do is,
I'm going to add another binding

00:32:50.290 --> 00:32:52.290
to an incoming vertex attribute.

00:32:52.300 --> 00:32:54.300
I'm going to bind to the
normal as it comes in.

00:32:54.300 --> 00:32:57.320
So you're going to notice
something as I start typing here.

00:32:58.250 --> 00:33:01.170
It's actually,
every time I press a character,

00:33:01.170 --> 00:33:03.400
there's a thread going in the
background which is just constantly,

00:33:03.400 --> 00:33:08.780
as I type, parsing the text and compiling
it and returning out the error

00:33:08.780 --> 00:33:10.720
information from the parser as I type.

00:33:10.860 --> 00:33:13.300
So you can see down at the bottom,
I'll just put the mouse on it,

00:33:13.350 --> 00:33:16.500
it's giving me exact information
of what it thinks is wrong.

00:33:16.570 --> 00:33:19.420
And it even gives you a hint
as to what the parser believes

00:33:19.420 --> 00:33:20.600
is the erroneous token.

00:33:20.970 --> 00:33:25.260
So I haven't finished typing,
so ATTR is highlighted in red.

00:33:25.350 --> 00:33:27.920
So I'll just continue to type here.

00:33:34.560 --> 00:33:39.500
I've created a binding to
the incoming vertex normal.

00:33:39.510 --> 00:33:44.490
Now I want to be able to see
the normals of all the vertices.

00:33:44.490 --> 00:33:50.500
I'm going to assign the incoming
vertex normal to the output color,

00:33:50.500 --> 00:33:52.430
which will produce an interesting effect.

00:33:52.500 --> 00:33:55.760
I'm going to go into the instruction
reference here on the right,

00:33:55.760 --> 00:33:58.250
pick out the appropriate opcode,
double click it.

00:33:58.430 --> 00:34:00.480
You can see it just
dropped it in there for me.

00:34:00.500 --> 00:34:04.500
There are placeholders for what
variable names to use as the operands.

00:34:04.500 --> 00:34:07.770
It's of course returning a
syntax error because those don't

00:34:07.770 --> 00:34:09.500
match what's in my program.

00:34:09.500 --> 00:34:12.700
I'm just going to fill
them out right now.

00:34:20.100 --> 00:34:22.100
Remove this line here.

00:34:22.100 --> 00:34:26.100
And as you can see,
it's updated just as I've been typing.

00:34:26.100 --> 00:34:32.100
Now you can see the normals for all the
vertices are being mapped to the color.

00:34:32.100 --> 00:34:34.100
So you can see this rainbow effect.

00:34:34.100 --> 00:34:36.900
And you can see that Shader Builder
actually draws the axes here for

00:34:36.900 --> 00:34:39.100
you so you can see what's going on.

00:34:39.100 --> 00:34:43.290
That's just a basic example,
just to let you see that this

00:34:43.580 --> 00:34:44.930
is occurring in real time.

00:34:45.100 --> 00:34:49.100
I'm going to show you more
interesting shaders than this later,

00:34:49.110 --> 00:34:52.060
but this is just sort of
an introduction to it.

00:34:52.190 --> 00:34:56.100
I'm not going to show you the
debugger inside this tool to

00:34:56.320 --> 00:34:58.100
allow you to analyze your logic.

00:34:58.100 --> 00:35:00.100
So I'm going to close down
this shader right here.

00:35:00.100 --> 00:35:04.100
And I'm going to bring up
the next one right here.

00:35:04.240 --> 00:35:08.100
This is not a very graphically
interesting shader.

00:35:08.180 --> 00:35:12.100
Indeed, so uninteresting that it draws
absolutely nothing in the output.

00:35:12.100 --> 00:35:16.100
Because it binds to none of
the outgoing vertex attributes

00:35:16.100 --> 00:35:19.530
and it writes no data in,
although all the vertices for

00:35:19.530 --> 00:35:24.030
the sphere are going into OpenGL,
well, none of them are -- they're getting

00:35:24.030 --> 00:35:26.100
stuck at the TCL part of the pipeline.

00:35:26.170 --> 00:35:28.100
They're not being filled out.

00:35:28.100 --> 00:35:31.100
But I have a different purpose
for showing you this shader.

00:35:31.100 --> 00:35:34.100
It does declare three local variables,
sort of three temporaries.

00:35:34.100 --> 00:35:38.620
I've named them A, B, and C.

00:35:39.100 --> 00:35:42.100
I can create new ones
if I just type in here.

00:35:42.150 --> 00:35:44.090
I just created a variable called hello.

00:35:44.120 --> 00:35:47.100
You'll notice as I've been typing,
if you look at the identifier list,

00:35:47.100 --> 00:35:51.100
over here on the right,
as I create new variables in real time,

00:35:51.100 --> 00:35:55.100
it's actually recording
them here on the right.

00:35:55.100 --> 00:35:58.870
The reason for this is for debugging.

00:35:59.120 --> 00:36:04.100
So over here,
you'll see that the variable B has got

00:36:04.100 --> 00:36:07.040
-- it's all four component vectors,
as I've told you.

00:36:07.100 --> 00:36:09.100
And it's got one, two, three, four in it.

00:36:09.100 --> 00:36:12.010
And C has just got two
in it on the X component.

00:36:12.140 --> 00:36:14.090
I can just double-click
here and I can redefine.

00:36:14.100 --> 00:36:15.770
I can change these.

00:36:16.100 --> 00:36:18.940
I can change these and put in new values.

00:36:19.100 --> 00:36:20.720
Just like that.

00:36:21.230 --> 00:36:24.090
Now I'm going to start the debugger.

00:36:24.140 --> 00:36:27.100
The controls are over here on the bottom.

00:36:27.100 --> 00:36:31.100
If I click on the step button,
you can see down here at the bottom,

00:36:31.100 --> 00:36:34.010
it's saying stepping through the program,
press reset to return to editing.

00:36:34.150 --> 00:36:37.100
The source code is read-only, of course,
while I'm debugging.

00:36:37.110 --> 00:36:39.100
And it grays it out.

00:36:39.100 --> 00:36:41.410
And you can see that it has
highlighted the opcode that

00:36:41.410 --> 00:36:42.100
it's about to execute in blue.

00:36:42.100 --> 00:36:45.100
If I click the step button,
pretty straightforward stuff.

00:36:45.100 --> 00:36:48.100
It's basically, as it said, move B to A.

00:36:48.100 --> 00:36:52.180
And if you look in the identifier list,
the emulator returns information as

00:36:52.210 --> 00:36:57.060
to what variables were touched upon
every cycle of the program counter.

00:36:57.240 --> 00:37:00.420
And I can see that A has
just been touched and it's

00:37:00.560 --> 00:37:01.950
highlighted in blue there.

00:37:02.130 --> 00:37:04.860
So you can very quickly get
an idea of what each line of

00:37:04.870 --> 00:37:07.030
code is touching and changing.

00:37:07.180 --> 00:37:09.100
So I'm just continuing to
step through the program here.

00:37:09.100 --> 00:37:12.100
You can see it all going through.

00:37:12.100 --> 00:37:14.100
I can reset the emulator.

00:37:14.100 --> 00:37:17.030
I can run it just all the way through
and see exactly what's going on.

00:37:17.170 --> 00:37:21.100
Even if, say, I'm debugging,
I'm halfway through the program,

00:37:21.110 --> 00:37:24.100
I can change the state of
any register at any time.

00:37:24.200 --> 00:37:27.100
You can see here it's about
to execute a move operation.

00:37:27.100 --> 00:37:32.090
I can change the value of A to
something else just as I'm debugging.

00:37:32.100 --> 00:37:34.860
I don't need to reset and
change them when I'm starting.

00:37:35.130 --> 00:37:37.100
I can do it in the middle of the program.

00:37:37.100 --> 00:37:38.100
No problem.

00:37:38.100 --> 00:37:40.840
So hopefully,
if you use your imaginations and you

00:37:40.840 --> 00:37:42.980
do try writing some of these shaders,
which I hope you will,

00:37:43.100 --> 00:37:46.940
I think you'll find yourself
using this quite regularly.

00:37:47.100 --> 00:37:54.650
So the next feature I'd like to
show you is the ability... Okay,

00:37:54.690 --> 00:37:57.100
you've written your shader.

00:37:57.100 --> 00:38:00.100
You basically have a text file
written now with your shader in it,

00:38:00.100 --> 00:38:02.750
and you want to be able to...

00:38:02.980 --> 00:38:06.430
You want to be able to take that and
have a framework to start writing a

00:38:06.500 --> 00:38:07.990
game with or doing something useful.

00:38:08.000 --> 00:38:10.020
I mean you've got a text file,
that's not a lot of use.

00:38:10.020 --> 00:38:13.600
You need some C files with all
the OpenGL entry points being

00:38:13.700 --> 00:38:17.120
called to load your program in
and set it up appropriately.

00:38:17.470 --> 00:38:20.360
Well, Shader Builder can help you
out substantially there to save

00:38:20.690 --> 00:38:22.300
you a lot of reading basically.

00:38:22.300 --> 00:38:25.500
I'm going to open up
another example right here.

00:38:25.500 --> 00:38:27.840
This one right here.

00:38:27.910 --> 00:38:31.300
It's basically a simple lighting model.

00:38:31.300 --> 00:38:33.080
I'll show you what's up.

00:38:33.280 --> 00:38:37.300
Let's just resize this so you can see
a little more clearly what's going on.

00:38:37.300 --> 00:38:39.300
Rotate this around a little.

00:38:39.300 --> 00:38:43.300
You can see it's a little car.

00:38:43.300 --> 00:38:48.190
The lighting model,
it's absolutely really simple.

00:38:48.450 --> 00:38:53.300
It's basically just doing a simple dot
product with all the vertex normals

00:38:53.300 --> 00:38:55.300
with the light direction vector.

00:38:55.600 --> 00:39:01.300
Then of course it's modulating the
incoming vertex color with that.

00:39:01.300 --> 00:39:04.920
Meaning that if I go here and
I start changing the vertex color,

00:39:05.030 --> 00:39:07.300
you can see it updates in real time.

00:39:09.500 --> 00:40:53.300
[Transcript missing]

00:41:00.080 --> 00:41:01.060
It doesn't seem to be working.

00:41:01.200 --> 00:41:02.000
Oh well.

00:41:02.000 --> 00:41:04.000
I don't know.

00:41:04.000 --> 00:41:05.900
Anyway, it would export a project.

00:41:05.900 --> 00:41:06.910
It would start a build process.

00:41:07.010 --> 00:41:11.440
It would basically watch the build
log and it would then run the program.

00:41:11.440 --> 00:41:13.870
It would hide Shader Builder
and run the program for you.

00:41:13.960 --> 00:41:16.180
And you'd be able to open up
Project Builder and start working on it.

00:41:16.180 --> 00:41:18.950
I'll look into that.

00:41:19.030 --> 00:41:21.000
Anyway, moving on.

00:41:21.200 --> 00:41:26.460
The next thing,
just to show you some slightly

00:41:26.460 --> 00:41:28.720
more interesting shaders,
just to show you what you can

00:41:28.720 --> 00:41:30.000
do with these vertex programs.

00:41:30.290 --> 00:41:32.540
That was a very basic
lighting model I showed you.

00:41:32.670 --> 00:41:34.600
Very similar to the one
implemented in OpenGL.

00:41:34.600 --> 00:41:36.250
It is really,
the standard OpenGL lighting

00:41:36.250 --> 00:41:37.000
model is pretty crude.

00:41:37.000 --> 00:41:44.760
Here's one that I actually
wrote a couple of weeks ago,

00:41:44.860 --> 00:41:47.870
which I'll open up.

00:41:47.870 --> 00:41:47.870
It's, where is it here?

00:41:47.870 --> 00:41:47.870
This one right here.

00:41:52.900 --> 00:44:14.000
[Transcript missing]

00:44:28.680 --> 00:44:32.840
Okay.

00:44:32.890 --> 00:44:34.400
Oh, there's a W component.

00:44:34.600 --> 00:44:35.560
Pardon me.

00:44:35.700 --> 00:44:37.490
And...

00:44:38.800 --> 00:45:08.600
[Transcript missing]

00:45:11.000 --> 00:45:13.410
Thanks.

00:45:13.410 --> 00:45:18.000
So, just any other things
I'd like to show here.

00:45:18.000 --> 00:45:24.000
I'll show one more shader and
then I'll be heading over again.

00:45:24.000 --> 00:45:28.250
This one is a, hang on a second.

00:45:32.170 --> 00:45:35.690
This is an implementation
of a cell shader.

00:45:35.690 --> 00:45:38.540
It makes use of texture
maps quite extensively.

00:45:38.570 --> 00:45:40.630
If I go in here,
you can see that texture unit

00:45:40.640 --> 00:45:43.890
one is being loaded up with
a one-dimensional texture,

00:45:43.890 --> 00:45:47.100
making up ramps of color.

00:45:47.100 --> 00:45:50.100
Actually, about four ramps of color.

00:45:50.100 --> 00:45:53.230
What's actually being done is
the vertex program is setting

00:45:53.230 --> 00:45:56.360
the texture coordinates to look
up within that texture to be

00:45:56.530 --> 00:45:58.100
able to create a ramped effect.

00:45:58.100 --> 00:46:00.900
There's another texture right here,
which is actually two pixels

00:46:00.900 --> 00:46:02.080
wide and one pixel tall.

00:46:02.120 --> 00:46:04.100
It's just a black pixel
and a white pixel.

00:46:04.100 --> 00:46:07.940
It's used for doing edge detection.

00:46:08.100 --> 00:46:11.030
It looks like someone's went around
the model with a black marker.

00:46:11.130 --> 00:46:15.100
I'll use the car, but I don't know if
you can really see it.

00:46:15.100 --> 00:46:17.300
On the sphere,
it actually looks like there's

00:46:17.380 --> 00:46:19.630
a black surround on it,
and it looks like it's got

00:46:19.720 --> 00:46:21.060
a quantized look on it.

00:46:21.130 --> 00:46:24.630
If I rotate the model of the car,
you can see the

00:46:24.630 --> 00:46:26.900
cell-sheeted effect it has.

00:46:27.100 --> 00:46:27.100
That's just being done in one vertex.

00:46:27.110 --> 00:46:29.540
There's no performance
hit for doing this,

00:46:29.580 --> 00:46:33.060
because it's all running on the hardware,
if you have the hardware.

00:46:33.160 --> 00:46:42.960
The important thing to note
here is that we do have a highly

00:46:42.960 --> 00:46:48.030
optimized emulator running inside
our standard OpenGL implementation.

00:46:48.100 --> 00:46:53.830
Even on your old measly
PowerBook with its Rage 1 to 8,

00:46:53.880 --> 00:46:56.100
you can still go ahead and you
can write these parameters.

00:46:56.100 --> 00:47:01.100
The performance will be a little slower,
but it's actually very usable.

00:47:01.100 --> 00:47:03.100
I write shaders all the
time on my PowerBook,

00:47:03.100 --> 00:47:04.100
and it's really no problem.

00:47:04.100 --> 00:47:11.100
ShaderBuilder is on the Jaguar Seed
CD that was given out to you guys.

00:47:11.100 --> 00:47:12.720
Take it home.

00:47:13.200 --> 00:47:16.930
The example programs that
I've been working with are

00:47:16.930 --> 00:47:21.480
on the sample code website,
which I believe there will be a

00:47:21.480 --> 00:47:25.100
reference given to that at the end
of the talk when I head back to Jeff.

00:47:25.100 --> 00:47:29.000
Go download the shaders,
play around with it.

00:47:29.000 --> 00:47:30.840
I guarantee you will not need
any prior knowledge of this

00:47:30.850 --> 00:47:32.050
stuff to actually figure it out.

00:47:32.100 --> 00:47:35.020
It's incredibly easy to learn.

00:47:35.160 --> 00:47:38.470
Go ahead, play around,
and get experimenting and start

00:47:38.550 --> 00:47:40.100
using these things in your games.

00:47:40.100 --> 00:47:49.100
I'm going to hand back over to
Jeff here to carry on the show.

00:47:49.100 --> 00:47:53.090
Thanks, guys.

00:47:57.930 --> 00:48:01.800
I think the folks here who have
used vertex shaders before and

00:48:01.800 --> 00:48:06.700
know the kind of write a text file,
write a C program, load it in,

00:48:06.780 --> 00:48:07.400
what do I get?

00:48:07.440 --> 00:48:07.770
Nothing.

00:48:07.900 --> 00:48:08.500
Go back.

00:48:08.500 --> 00:48:11.160
Edit the text file, load it in,
what do I get?

00:48:11.160 --> 00:48:11.890
Nothing.

00:48:11.890 --> 00:48:13.900
And go through this.

00:48:13.900 --> 00:48:15.970
When you're trying to
learn a new technology,

00:48:16.150 --> 00:48:17.900
this kind of tool is great.

00:48:17.900 --> 00:48:20.360
I mean, a small brain like me,
I can sit down and fool around

00:48:20.590 --> 00:48:22.900
with it and actually kind
of come up with something.

00:48:22.900 --> 00:48:26.440
You guys, I'm sure,
can experiment and really build great

00:48:26.950 --> 00:48:29.900
shaders that you can use in your
applications for real world things.

00:48:29.900 --> 00:48:32.770
You can really manipulate
the graphics pipeline in an

00:48:32.770 --> 00:48:34.900
interactive way for the first time.

00:48:34.900 --> 00:48:36.900
And this tool is not
available anywhere else.

00:48:36.920 --> 00:48:40.130
And as James mentioned,
one thing we're looking at is the

00:48:40.130 --> 00:48:42.900
instructions and the supported languages.

00:48:42.900 --> 00:48:44.800
Right now, our vertex program.

00:48:44.960 --> 00:48:47.690
We're looking to expand
that to the other ARB specs.

00:48:47.970 --> 00:48:48.900
And even non-ARB specs.

00:48:48.920 --> 00:48:51.900
We're looking to whatever we can put
in that we can put as a text language,

00:48:51.900 --> 00:48:54.870
as a parser,
and give you an interactive environment

00:48:54.960 --> 00:48:59.900
to debug and work with these things
to really multiply your productivity.

00:48:59.900 --> 00:49:02.340
So you're not spending days trying
to debug small things so you

00:49:02.340 --> 00:49:04.900
can step through and find that
small error in your math code.

00:49:04.900 --> 00:49:08.060
I'm sure we all wish we could go
back and spend more time in our

00:49:08.060 --> 00:49:11.900
math classes in college so we can,
you know, so you guys who are in college,

00:49:11.900 --> 00:49:13.900
listen to the math classes.

00:49:13.900 --> 00:49:16.020
But this stuff gets hard and when
you have a debugger like this,

00:49:16.050 --> 00:49:16.900
it really helps out.

00:49:16.900 --> 00:49:17.890
Let me go back to the software.

00:49:17.920 --> 00:49:18.750
slides.

00:49:23.830 --> 00:49:27.340
and we'll move on and talk a little
bit about texture and fragment shaders.

00:49:27.520 --> 00:49:29.540
What I want to do here is not
really cover in the in-depth that

00:49:29.650 --> 00:49:31.640
I covered in vertex shader and
texture and fragment shaders,

00:49:31.640 --> 00:49:35.540
but give you an idea of what they are,
what part of the pipeline they control,

00:49:35.680 --> 00:49:38.330
and how you can,
what effects they can do and how you

00:49:38.330 --> 00:49:41.300
can use them in your applications.

00:49:41.470 --> 00:49:44.260
First, that first bullet there
really explains what they are.

00:49:44.400 --> 00:49:47.210
It's a per fragment,
texture address lookup and

00:49:47.210 --> 00:49:48.330
multi-texture combined.

00:49:48.460 --> 00:49:49.440
So let's break that down.

00:49:49.440 --> 00:49:52.500
What that means is,
you take that texture coordinate in,

00:49:52.500 --> 00:49:55.540
and the simplest case of something
is to take the texture coordinate,

00:49:55.650 --> 00:49:58.240
use that to directly
index into a texture,

00:49:58.350 --> 00:50:02.240
take the value of the text at that point,
and output it directly

00:50:02.620 --> 00:50:03.820
as the fragment color.

00:50:03.960 --> 00:50:07.000
Well, that's okay,
I mean that's standard texturing,

00:50:07.000 --> 00:50:09.100
but there's a lot of
other things you can do.

00:50:09.200 --> 00:50:14.140
Bump mapping, you can do the shininess,
the specular reflections,

00:50:14.140 --> 00:50:18.230
all these are things you can do
in a texture and fragment program.

00:50:18.240 --> 00:50:21.600
What you do is you manipulate the way
you're looking up into textures and the

00:50:21.600 --> 00:50:23.210
way you're combining those together.

00:50:23.380 --> 00:50:26.040
So first you need to
determine a texture address.

00:50:26.200 --> 00:50:28.260
You need to go to the texture
and look up that value,

00:50:28.330 --> 00:50:32.430
and then you need to combine
those multi-texture lookups

00:50:32.640 --> 00:50:34.600
into a fragment color.

00:50:34.600 --> 00:50:37.800
Or use multiple texture lookups
that depend on one another.

00:50:37.800 --> 00:50:40.880
Look up a value out of one texture
that you're going to use to look up

00:50:40.880 --> 00:50:45.960
into another texture that allows you to
actually get some really cool effects.

00:50:46.070 --> 00:50:47.790
Simple thing here is what do you output?

00:50:47.900 --> 00:50:49.300
You output a fragment color.

00:50:49.380 --> 00:50:50.600
That's basically it.

00:50:50.680 --> 00:50:53.140
All this program,
whatever you want to do there,

00:50:53.260 --> 00:50:55.730
is outputting a fragment color.

00:50:56.800 --> 00:50:58.810
So this is basically
what I was talking about.

00:50:58.910 --> 00:51:01.400
You have texture coordinates
and vertex colors coming in.

00:51:01.400 --> 00:51:04.540
You do a texture lookup and
you get a color fragment out.

00:51:04.710 --> 00:51:07.630
That box is what you're going to
actually be programming when you

00:51:07.630 --> 00:51:09.490
look at texture and fragment shaders.

00:51:11.120 --> 00:51:13.840
So, why isn't this a single extension?

00:51:13.900 --> 00:51:16.530
Well, first thing is lower down
the pipeline and the hardware

00:51:16.900 --> 00:51:20.700
that the two main vendors,
ATI and NVIDIA have are significantly

00:51:20.700 --> 00:51:23.310
different in the kind of their
functionality and how they work.

00:51:23.310 --> 00:51:25.710
And they're progressing very rapidly,
even more rapidly than the

00:51:25.710 --> 00:51:27.000
vertex programming area.

00:51:27.100 --> 00:51:29.730
So we really haven't come to the
maturity that allows us to bring a

00:51:29.730 --> 00:51:33.160
single extension to encompass the
functionality in both sets of hardware.

00:51:33.310 --> 00:51:35.860
So what we have is,
NVIDIA's side we have texture

00:51:35.860 --> 00:51:38.610
shader and register combiners.

00:51:38.720 --> 00:51:42.870
On the texture shader side,
I need a drink of water, I need a shader.

00:51:44.740 --> 00:51:47.900
Textures Shader actually does the address
lookups and the register combiners,

00:51:47.900 --> 00:51:51.020
as you would think,
combines the various textures

00:51:51.280 --> 00:51:53.360
into the final fragment color.

00:51:53.410 --> 00:51:55.280
Fragment Shader encompasses all of this.

00:51:55.470 --> 00:51:59.440
It's a little bit newer of an
extension and will actually take

00:51:59.440 --> 00:52:03.600
this entire operation and put it
into one kind of unified command set.

00:52:03.710 --> 00:52:05.000
Let's look at all three of these.

00:52:05.170 --> 00:52:06.840
First,
Texture Shaders are new for Jaguar.

00:52:06.840 --> 00:52:08.070
We hadn't had them before.

00:52:08.310 --> 00:52:12.400
Texture Shader 1,
2 and 3 are supported in Jaguar.

00:52:12.500 --> 00:52:15.960
And they provide, again,
texture address lookup in a

00:52:15.960 --> 00:52:18.150
various set of shader stages.

00:52:18.260 --> 00:52:22.090
There are three extensions and
they provide 37 canned operations.

00:52:22.130 --> 00:52:25.010
You can combine these in a lot
of different ways and get a

00:52:25.180 --> 00:52:26.870
very powerful shader program.

00:52:27.030 --> 00:52:28.360
Some of the things you can do,
for example,

00:52:28.360 --> 00:52:30.100
they have conventional texture lookups.

00:52:30.120 --> 00:52:33.900
So the simplest shader may be a 2D
texture lookup that's exactly getting

00:52:33.900 --> 00:52:37.510
the textal at your texture coordinate
and returning that as the fragment

00:52:37.520 --> 00:52:41.400
color or using that into the combiner
stage to get the fragment color.

00:52:41.480 --> 00:52:42.200
But then you have special cases.

00:52:42.200 --> 00:52:45.570
You could do nothing or you
could just pass a value through.

00:52:45.570 --> 00:52:47.300
Or you could actually
color fragments and say,

00:52:47.300 --> 00:52:50.490
"Hey, we don't need to draw that fragment
for some conditional." Then you

00:52:50.490 --> 00:52:53.200
can do dependent texture reads,
which I talked about a little bit.

00:52:53.200 --> 00:52:56.120
And it's really critical for
things like the recolorization

00:52:56.200 --> 00:52:59.020
you saw in the keynote,
the background color removal.

00:52:59.250 --> 00:53:02.860
That's using a dependent texture
read to actually do a color

00:53:02.860 --> 00:53:07.000
correction there and remove that
color and change an alpha value.

00:53:07.200 --> 00:53:11.040
Then the last thing you do in a lot
of the reflection and bump mapping

00:53:11.350 --> 00:53:12.000
algorithms is to do a color correction.

00:53:12.010 --> 00:53:14.990
And you can do that with the dot
product dependent texture reads,

00:53:15.050 --> 00:53:19.430
which also put the dot product
into that kind of formula of how

00:53:19.430 --> 00:53:21.800
do you configure the shaders.

00:53:22.300 --> 00:53:24.430
Moving on to register combiners.

00:53:24.550 --> 00:53:28.990
Register combiners is really an
extremely configurable fragment coloring.

00:53:28.990 --> 00:53:31.030
It's not, again,
not a programming language,

00:53:31.060 --> 00:53:34.710
but it gives you a kind of a box that
you can configure in different ways

00:53:35.020 --> 00:53:40.610
to replace the texture environment
control like textureenvadd,

00:53:40.610 --> 00:53:45.610
textureenvcombine,
the fogging and the color sum operations.

00:53:45.840 --> 00:53:49.660
The key here is you go from a linear one,
if anyone's looked at doing

00:53:49.680 --> 00:53:52.120
some of the textureenv stuff,
you're pretty limited in

00:53:52.120 --> 00:53:53.960
a couple texture units.

00:53:54.020 --> 00:53:56.660
The output of one texture unit needs
to go into the other texture unit.

00:53:56.710 --> 00:53:58.830
Only the first texture unit
has access to the color.

00:53:59.130 --> 00:54:00.950
All those things are very limiting,
especially if you're trying to

00:54:00.960 --> 00:54:02.720
do special effects with this.

00:54:02.860 --> 00:54:05.940
So what this allows you to do
is having all texture units

00:54:05.940 --> 00:54:09.250
have access to the color,
non-linearly combining these

00:54:09.300 --> 00:54:11.220
texture units to get a final output.

00:54:11.310 --> 00:54:13.800
So it really helps in doing things
when you have to do multiple levels

00:54:13.800 --> 00:54:17.720
of combining and multiple levels of
coloring onto your texture units.

00:54:17.740 --> 00:54:19.720
The second extension,
there's two extensions.

00:54:19.720 --> 00:54:21.720
The second one adds additional color.

00:54:21.720 --> 00:54:23.990
Flexibility, for example,
if you're trying to solve the

00:54:24.120 --> 00:54:26.880
problem of doing planar textures,
red, green, and blue,

00:54:26.880 --> 00:54:29.530
in separate areas and you want
to combine those together,

00:54:29.540 --> 00:54:32.960
having that separate color is
really good because you can colorize

00:54:33.050 --> 00:54:35.480
each texture unit and then combine
them together in a final step.

00:54:35.480 --> 00:54:38.520
Both of these extensions,
or all five of these,

00:54:38.580 --> 00:54:41.850
register combiners two,
texture shaders three,

00:54:41.850 --> 00:54:43.480
are NVIDIA specific.

00:54:43.480 --> 00:54:45.480
ATI has brought along fragment shader.

00:54:45.480 --> 00:54:48.450
Fragment shader basically brings
a unified instruction set.

00:54:48.530 --> 00:54:51.430
It's still in development right now.

00:54:51.480 --> 00:54:51.480
We're targeting it for Jaguar.

00:54:51.580 --> 00:54:53.990
It controls both the texture
address lookup for texture

00:54:54.150 --> 00:54:57.410
shader and the color data,
which is the register combiner set,

00:54:57.670 --> 00:55:02.160
into one overarching extension here.

00:55:03.010 --> 00:55:05.060
is similar to our vertex
program in its layout.

00:55:05.060 --> 00:55:06.460
So I'll show you an example of it.

00:55:06.460 --> 00:55:09.180
Really, it's very preliminary,
but it gives you an idea that you'll be

00:55:09.180 --> 00:55:13.800
able to use a tool like Shader Builder
to edit a language very similar to

00:55:13.800 --> 00:55:17.100
what you've been working with with
a vertex program when this is complete.

00:55:17.280 --> 00:55:22.840
This is on ATI Radeon
8500 and later processors.

00:55:22.960 --> 00:55:25.340
So I'm not going to really go
through the functionality here,

00:55:25.360 --> 00:55:28.500
but I just wanted to give you kind of
a sneak peek at what it's looking like,

00:55:28.650 --> 00:55:30.240
what kind of things we can see here.

00:55:30.390 --> 00:55:32.900
This is a bumped cubic
environment map shader.

00:55:32.900 --> 00:55:36.740
So this is the operations you need
to do to do a cubic environment map

00:55:36.740 --> 00:55:39.360
that's also bump mapped on an object.

00:55:39.750 --> 00:55:43.400
First we're going to do some routing
instructions to basically tell which

00:55:43.400 --> 00:55:47.240
texture coordinate variables are
mapped to which texture coordinates.

00:55:47.240 --> 00:55:49.290
Pretty simple here.

00:55:50.170 --> 00:55:51.410
Then we're going to do
some color dot products.

00:55:51.520 --> 00:55:54.940
This is similar to what you saw with
a vertex program where you're going

00:55:54.940 --> 00:55:57.940
to do a dot product and you're going
to use the texture coordinates to,

00:55:57.950 --> 00:56:02.640
which source texture coordinates and
any kind of operations or swizzles or,

00:56:02.680 --> 00:56:06.570
you can see it says mod 2x down there,
any modifications to those texture

00:56:06.570 --> 00:56:09.340
units as they come in so you can
do those in a programmatic way.

00:56:09.430 --> 00:56:11.570
Then you're going to do some
of the i-spaced lookups.

00:56:11.710 --> 00:56:15.090
This is something you would,
it looks like a lighting calculation,

00:56:15.090 --> 00:56:17.290
a bump map calculation
that's very similar.

00:56:18.400 --> 00:56:21.200
Moving on, you have a dependent texture
read where you're reading out of

00:56:21.200 --> 00:56:24.620
a previous texture coordinate,
using a texture map,

00:56:24.620 --> 00:56:26.830
a texture coordinate,
reading into a texture map and pulling

00:56:26.830 --> 00:56:28.980
it back out and using it later.

00:56:29.100 --> 00:56:31.860
And then at the end,
you're going to see that the final

00:56:31.860 --> 00:56:36.670
step here is it moves the texture
coordinate zero into the result there.

00:56:36.900 --> 00:56:37.560
And that's the output.

00:56:37.560 --> 00:56:43.390
Again, these kind of pixel programs,
fragment shaders, what you will,

00:56:43.430 --> 00:56:44.680
have the color as the output.

00:56:44.800 --> 00:56:47.450
So in the end, what you're outputting
is that fragment color,

00:56:47.450 --> 00:56:48.630
pretty simple.

00:56:50.570 --> 00:56:52.800
So let me bring up one more demo.

00:56:52.920 --> 00:56:55.930
Let me bring up demo machine number two.

00:57:03.060 --> 00:57:07.060
This is NVIDIA's launch demo
for the GeForce 4 Titanium.

00:57:07.060 --> 00:57:11.160
It's an interesting demo in the
fact that it does a lot of things.

00:57:11.160 --> 00:57:13.660
You can see there's bump
mapping in the facial area.

00:57:13.810 --> 00:57:14.800
You have self-shadowing.

00:57:15.060 --> 00:57:18.300
You have the fur.

00:57:18.470 --> 00:57:20.690
You can see the bump mapping here.

00:57:22.900 --> 00:57:31.500
[Transcript missing]

00:57:36.160 --> 00:57:38.820
Extremely impressive demo
from NVIDIA showing the

00:57:38.970 --> 00:57:40.800
power of these shaders.

00:57:40.800 --> 00:57:42.100
How many shells are there, Geoff?

00:57:42.150 --> 00:57:44.500
There's eight.

00:57:44.550 --> 00:57:46.550
Why don't we leave the Wolfman
up over here and go back to

00:57:46.670 --> 00:57:48.790
slides on the right side,
please.

00:57:54.800 --> 00:57:56.270
The Wolfman demo,
I was going to go through a little

00:57:56.270 --> 00:57:59.990
bit about how it's built and
what it does in a minute or two.

00:58:00.280 --> 00:58:02.440
But instead what we
decided to do is give you,

00:58:02.450 --> 00:58:04.850
in our advanced 3D coming up,
we're going to take you through

00:58:05.180 --> 00:58:08.050
the actual how that was built,
how the shaders were used,

00:58:08.050 --> 00:58:09.270
what the technologies are.

00:58:09.560 --> 00:58:12.140
It might be a really good session
to go to because you really can

00:58:12.140 --> 00:58:16.400
see some of the advanced things
you can do with shadow volumes,

00:58:16.400 --> 00:58:20.480
with the fur rendering,
with the bones and how to do

00:58:20.560 --> 00:58:21.800
the bone structure on that.

00:58:21.930 --> 00:58:25.070
So I really recommend you go to
that and you'll see exactly how

00:58:25.070 --> 00:58:26.890
the Wolfman was put together.

00:58:27.870 --> 00:58:30.950
We've talked about a lot of stuff
here today and I don't really think

00:58:31.120 --> 00:58:33.940
that you can take away from this
session and actually get every

00:58:33.950 --> 00:58:37.800
nuance of vertex programming or
obviously of pixel or texture shaders.

00:58:37.800 --> 00:58:40.390
So what I recommend you do is when
the arb is complete with the spec,

00:58:40.550 --> 00:58:42.800
which should be very shortly,
you get the spec.

00:58:42.800 --> 00:58:46.870
It's a large body of work
but if you read through it,

00:58:46.870 --> 00:58:49.360
it's fairly straightforward and
you can use the information you

00:58:49.360 --> 00:58:52.730
have here today and you can look
through it and get the nuances of it.

00:58:52.810 --> 00:58:56.040
Take shader builder,
start working with shader builder,

00:58:56.330 --> 00:58:58.740
build some shaders,
understand what the vertex

00:58:58.740 --> 00:59:01.800
shaders can and can't do and
put those in your programs.

00:59:01.800 --> 00:59:05.660
And finally the ATI and NVIDIA websites
have a wealth of information on

00:59:05.660 --> 00:59:09.730
their extensions and on vertex and
pixel programmability in general.

00:59:09.890 --> 00:59:12.740
Some other online sources
are theopengl.org,

00:59:12.740 --> 00:59:14.800
always a good place for reference.

00:59:14.800 --> 00:59:17.920
Liz.apple.com,
if you're not on the Mac OpenGL list,

00:59:17.920 --> 00:59:19.800
I recommend you join that list.

00:59:19.800 --> 00:59:21.800
We're on that list, we pay attention.

00:59:21.800 --> 00:59:24.800
While we may not be able to
respond to every single question,

00:59:24.800 --> 00:59:28.690
we'll try and give you good
information that you may need.

00:59:28.800 --> 00:59:32.790
And lastly, developer.apple.com/opengl.

00:59:33.620 --> 00:59:36.350
So, we've talked about
programmability in general,

00:59:36.350 --> 00:59:37.830
talked about vertex programs.

00:59:37.830 --> 00:59:40.500
James gave you a great demo of the
shader builder which is on your seed CD.

00:59:40.500 --> 00:59:42.850
We're looking to continue
moving that forward.

00:59:42.920 --> 00:59:45.500
Any suggestions you have,
send them on in.

00:59:45.500 --> 00:59:48.280
We'll try and put those
into our products.

00:59:48.590 --> 00:59:51.930
And we finished up with
texture and fragment shaders.

00:59:53.590 --> 00:59:54.590
Let's talk a little
bit about the roadmap.

00:59:54.700 --> 00:59:57.950
We're at the third line down here,
so we're at the graphics programmability.

00:59:58.080 --> 01:00:00.300
Tomorrow morning,
Integrated Graphics 1 talks about

01:00:00.300 --> 01:00:04.310
integrating the OS and OpenGL together.

01:00:05.180 --> 01:00:07.340
Followed by Integrated Graphics 2,
which is like the

01:00:07.370 --> 01:00:09.040
supercharged version of that.

01:00:09.040 --> 01:00:12.500
What are some great optimizations,
some great things you can do

01:00:12.530 --> 01:00:18.100
combining the power of Mac OS X,
the Jaguar and OpenGL.

01:00:18.240 --> 01:00:19.700
Colors and Conditional Media.

01:00:19.700 --> 01:00:22.260
There's some game solutions which
some will incorporate OpenGL.

01:00:22.310 --> 01:00:24.800
Some will have some great solutions
to event handling and some other

01:00:24.900 --> 01:00:28.260
problems that everyone runs into
whether you're a game or not a game.

01:00:28.570 --> 01:00:32.420
Again, game solutions follows with
some network solutions.

01:00:32.640 --> 01:00:36.380
Followed by that,
Advanced 3D on Thursday at 3:30 and

01:00:36.380 --> 01:00:40.240
that's going to talk about how we built
Wolfman and some other surprise demos

01:00:40.240 --> 01:00:44.540
that we're going to show that show
some really advanced 3D techniques.

01:00:44.670 --> 01:00:47.330
Followed by OpenGL Performance and
Optimization.

01:00:47.400 --> 01:00:49.400
If you need to go,
if you're doing OpenGL,

01:00:49.400 --> 01:00:50.540
go to that session.

01:00:50.630 --> 01:00:52.440
It's a great,
talks about some more tools we have,

01:00:52.670 --> 01:00:55.060
talks about some great performance
optimization things and it really

01:00:55.060 --> 01:00:57.840
is a great session to go to,
great things coming out of it.

01:00:57.900 --> 01:01:02.920
Graphics tuning for graphics
in general and then followed at

01:01:03.020 --> 01:01:04.810
the end by the feedback forum.

01:01:06.030 --> 01:01:09.500
Contact Sergio's information,
sergio@apple.com.

01:01:09.530 --> 01:01:10.500
And let's move into Q&A.
WEBVTT

00:00:05.200 --> 00:00:08.390
Hi everybody.

00:00:08.390 --> 00:00:10.180
This is not a French lesson,
so you don't have to repeat

00:00:10.180 --> 00:00:12.520
every time I'm saying something.

00:00:14.510 --> 00:00:18.360
My name is Xavier Legros,
and I work in the Worldwide

00:00:18.360 --> 00:00:20.700
Developer Relations,
and my job is to evangelize our

00:00:20.700 --> 00:00:23.520
international and macro-standard
technologies in general.

00:00:23.540 --> 00:00:28.300
I'd like to welcome you to this session
about drawing UniCode text with ATSUI,

00:00:28.330 --> 00:00:31.790
ATSUI, which is Apple Type Services for
UniCode Imaging.

00:00:31.800 --> 00:00:33.740
If we can do a quick test,
how many of you,

00:00:33.740 --> 00:00:35.910
and you could raise your hand,
have been using or

00:00:35.910 --> 00:00:37.160
looking into using ATSUI?

00:00:38.280 --> 00:00:39.150
Excellent.

00:00:39.300 --> 00:00:42.990
So I guess I can just quit right now
and go directly to the new features.

00:00:44.690 --> 00:00:47.140
Anyway,
we still have a quick introduction about

00:00:47.140 --> 00:00:52.980
what ATSUI is and a set of the current
features and some of the concepts.

00:00:53.270 --> 00:00:55.820
A lot of people, a lot of developers have
been coming to us and saying,

00:00:55.820 --> 00:00:57.680
you know,
ATSUI does a lot of things for me,

00:00:57.680 --> 00:01:00.260
but there are a couple of
things I don't understand,

00:01:00.260 --> 00:01:03.460
which are because we're doing so
many things and the way ATSUI is

00:01:03.460 --> 00:01:06.180
handled and architecture is
very different than Quick Draw.

00:01:06.240 --> 00:01:08.830
I'm going to go quickly
today around these concepts,

00:01:09.150 --> 00:01:13.520
hopefully giving you a better idea
on how to make the best use of ATSUI.

00:01:15.090 --> 00:01:17.340
So what is ATSUI?

00:01:17.480 --> 00:01:21.900
ATSUI is at the heart of the
drawing system on Mac OS X.

00:01:22.020 --> 00:01:23.740
When you see the finder
drawing static text,

00:01:23.740 --> 00:01:29.140
the menu manager at one point or another,
it's ATSUI text being drawn.

00:01:29.570 --> 00:01:32.250
And that's very important to
understand because in order to make

00:01:32.320 --> 00:01:36.780
Mac OS X a truly international system,
we had to go through a Unicode.

00:01:36.850 --> 00:01:40.110
And the only way to display Unicode
on the system is to use ATSUI.

00:01:46.000 --> 00:01:49.920
The main feature is the
support for UniCode 3.2.

00:01:49.920 --> 00:01:53.030
And this support is for actually
what we call our layout technology,

00:01:53.130 --> 00:01:54.540
our layout engine.

00:01:54.660 --> 00:01:57.970
And the concept of layout is
actually pretty important if you

00:01:57.970 --> 00:02:02.200
want to support correctly languages,
international languages.

00:02:02.340 --> 00:02:06.260
So the nice thing with ATSUI is
that through one set of APIs,

00:02:06.460 --> 00:02:09.760
you're going to be able to
render virtually all languages.

00:02:09.880 --> 00:02:13.030
You heard in the keynote, for instance,
with Scott Forstall about

00:02:13.030 --> 00:02:15.960
all these new languages that
we're going to be supporting.

00:02:16.070 --> 00:02:20.700
All the Arabic, Hebrew, for Baidai,
all the Indic scripts, even Hawaiian.

00:02:20.720 --> 00:02:24.750
In order to support these languages,
you have to use UniCode.

00:02:24.860 --> 00:02:27.970
And on the Carbon application,
you will have to use

00:02:27.970 --> 00:02:29.920
directly or indirectly ATSUI.

00:02:30.500 --> 00:02:34.620
ATSUI is going to enable you to support
combining characters and complex scripts.

00:02:34.720 --> 00:02:38.990
And, best, it's going to enable you to
support languages that before

00:02:38.990 --> 00:02:41.520
on Mac OS 9 you couldn't access.

00:02:41.520 --> 00:02:44.280
Because of the limitation of
Word Script 1 and Word Script 2,

00:02:44.470 --> 00:02:48.640
and the way encodings work,
you never were able before

00:02:48.640 --> 00:02:50.900
to access the languages.

00:02:50.900 --> 00:02:53.920
Using ATSUI and UniCode is
the solution for this need.

00:02:53.920 --> 00:02:56.540
Another nice thing,
another nice feature that ATSUI offers

00:02:56.540 --> 00:02:59.470
is the font substitution support.

00:02:59.470 --> 00:03:04.560
ATSUI has this concept of fonts,
and ATSUI will know what font to display,

00:03:04.560 --> 00:03:07.120
what font to use to
display certain characters.

00:03:07.120 --> 00:03:09.880
And you can see this behavior,
for instance, when you use the

00:03:09.880 --> 00:03:11.740
Draw Theme Text Box APIs.

00:03:11.740 --> 00:03:14.680
Use a theme font ID,
which is kind of a conceptual font,

00:03:14.680 --> 00:03:17.360
and with the same font ID,
you're going to be able to

00:03:17.360 --> 00:03:20.920
actually display Japanese and
Roman text in the same color.

00:03:20.920 --> 00:03:22.420
That works because of two things.

00:03:22.570 --> 00:03:25.020
Because you're passing UniCode,
and the second part,

00:03:25.020 --> 00:03:29.400
It's because that's who he knows
about this concept of phone fallbacks.

00:03:32.960 --> 00:03:36.150
There is another point in ATSUI that
maybe not all of you are aware of,

00:03:36.150 --> 00:03:39.330
or maybe not all of you want to use,
but the second part is

00:03:39.330 --> 00:03:40.670
advanced typography.

00:03:40.870 --> 00:03:44.610
And ATSUI, with that regard, is very,
very powerful.

00:03:44.910 --> 00:03:48.040
ATSUI is going to enable you to
support things such as kerning,

00:03:48.060 --> 00:03:52.020
optical alignment, variation fonts,
ligature, leaf alternatives,

00:03:52.020 --> 00:03:57.610
which is a new feature that we're
actually adding in Mac OS X Jaguar,

00:03:57.630 --> 00:04:02.540
baseline adjustment, and there are many,
many other style attributes that are

00:04:02.710 --> 00:04:04.780
not supported in Quick Draw Text.

00:04:04.840 --> 00:04:07.060
Things like, for instance,
displaying a chemical equation.

00:04:07.060 --> 00:04:10.240
Now with ATSUI, it's a matter of setting
a style attribute.

00:04:10.240 --> 00:04:11.660
It's very easy and straightforward.

00:04:11.660 --> 00:04:14.260
I encourage you to look
at the documentation.

00:04:14.260 --> 00:04:18.760
Of course, one of the main features for
CGK users is vertical text.

00:04:18.880 --> 00:04:22.490
And here, ATSUI, once again,
supports very easily vertical

00:04:22.490 --> 00:04:24.370
text through two type attributes.

00:04:24.550 --> 00:04:26.330
One through the style,
where you're going to be able to

00:04:26.420 --> 00:04:29.620
set a style attribute to say that
the glyph has to be vertical.

00:04:29.760 --> 00:04:33.460
And the second one is by enabling
developers to do variation

00:04:33.460 --> 00:04:37.760
rotation of the layout to display
vertical text at an angle.

00:04:38.380 --> 00:04:43.200
Another set of features that come
with ATSUI APIs is a set of editing,

00:04:43.310 --> 00:04:45.100
what we call editing APIs.

00:04:45.180 --> 00:04:48.850
These APIs are here to
help you manage the cursor,

00:04:49.140 --> 00:04:52.690
manage click inside text,
do highlighting.

00:04:53.070 --> 00:04:56.500
And it gets very,
very important because cursor movement in

00:04:56.500 --> 00:04:59.680
a true multilingual environment is not,
you know,

00:04:59.740 --> 00:05:02.200
you don't move a cursor one byte,
one character.

00:05:02.300 --> 00:05:04.760
Because, for instance, with Chinese,
it's going to be different.

00:05:04.760 --> 00:05:06.260
With Arabic,
it's going to be completely different.

00:05:06.260 --> 00:05:09.000
Well, ATSUI,
through like one easy set of APIs,

00:05:09.200 --> 00:05:11.680
will enable you to manage
actually cursor movement for all

00:05:11.680 --> 00:05:14.200
the languages that we support.

00:05:14.700 --> 00:05:16.550
And of course,
the most visible thing that

00:05:16.670 --> 00:05:19.340
everybody at the beginning
wanted is the Quartz support,

00:05:19.340 --> 00:05:25.000
which is the main difference between
people using Quick Draw Text and ATSUI.

00:05:25.000 --> 00:05:29.300
The integration between Quartz,
our powerful 2D rendering engine,

00:05:29.300 --> 00:05:32.840
and ATSUI, our UniCode layout, is very,
very well done.

00:05:32.840 --> 00:05:36.830
And you can use both of the feature
sets together to get to some very

00:05:36.830 --> 00:05:40.940
amazing results and some very,
very amazing display of text.

00:05:40.940 --> 00:05:41.940
And I'll show you that in the demo.

00:05:41.940 --> 00:05:43.880
I think it will be better.

00:05:45.590 --> 00:05:48.940
So once again, quickly,
ATSUI and Quartz are fully integrated.

00:05:49.000 --> 00:05:52.740
The first thing you see, of course,
is the anti-aliasing.

00:05:52.800 --> 00:05:57.510
But the second part of that is
that by combining CG and ATSUI,

00:05:57.640 --> 00:06:00.720
you're going to be able to
access all the spatial effects,

00:06:00.780 --> 00:06:03.760
I would say,
that you can set in the CG context.

00:06:03.910 --> 00:06:07.470
So things such as color space,
where you're going to be able to pass

00:06:07.630 --> 00:06:09.420
a color space to your CG context.

00:06:09.510 --> 00:06:11.720
And ATSUI will respect that.

00:06:12.060 --> 00:06:13.720
Things like, for instance,
transformation of the

00:06:13.780 --> 00:06:15.820
matrix for rotation,
scaling, skewing,

00:06:15.820 --> 00:06:17.780
that you can do with a CG context.

00:06:17.830 --> 00:06:20.370
ATSUI will respect all these things.

00:06:20.950 --> 00:06:24.400
And the very nice thing is that you
get results there that were very,

00:06:24.400 --> 00:06:29.110
very difficult to achieve
before with Quick Draw Text.

00:06:31.460 --> 00:06:34.590
Here, for instance,
we have a nice example of a line of

00:06:34.700 --> 00:06:36.940
text that has different encodings.

00:06:36.940 --> 00:06:39.620
And with a simple call to ATSUI,
you're going to be able to

00:06:39.620 --> 00:06:40.940
actually display these scripts.

00:06:40.940 --> 00:06:42.600
And here we have Roman, UniCode.

00:06:42.680 --> 00:06:44.210
This is Japanese.

00:06:44.580 --> 00:06:47.720
I think we have Inuktitut and Georgian,
if I'm not mistaken, at the end.

00:06:52.300 --> 00:06:54.830
And here, the second example is like,
you know,

00:06:54.840 --> 00:06:56.640
the support for advanced typography.

00:06:56.680 --> 00:06:59.820
Here, we have the Zapfino font,
which is a very cursive font,

00:06:59.820 --> 00:07:04.660
and the only way to display
it correctly is to use ATSUI.

00:07:04.660 --> 00:07:07.420
You can see the ligatures
between the P and the F.

00:07:07.420 --> 00:07:11.360
Oops, sorry about that.

00:07:14.700 --> 00:07:17.850
So here we have some kind of a diagram
that shows you the architecture and

00:07:17.850 --> 00:07:21.540
where ATSUI resides in the system.

00:07:21.580 --> 00:07:25.300
ATSUI is part of the
application services framework.

00:07:25.350 --> 00:07:28.860
And at one point or another,
most of the toolbox is

00:07:28.860 --> 00:07:30.130
going to be coding in it.

00:07:30.330 --> 00:07:32.440
So the menu manager,
or it could be directly

00:07:32.440 --> 00:07:33.960
on a Carbon application.

00:07:34.060 --> 00:07:37.380
So let me take you quickly
through how you could use ATSUI.

00:07:37.550 --> 00:07:40.500
You have different levels, once again,
to use ATSUI.

00:07:40.530 --> 00:07:43.330
As a Carbon application,
you could actually link directly

00:07:43.840 --> 00:07:47.580
against the application services
and use all the ATSUI APIs.

00:07:47.620 --> 00:07:48.780
That's the solution.

00:07:48.820 --> 00:07:51.620
The second solution is
to use higher-level APIs,

00:07:51.620 --> 00:07:54.590
such as DrawThemeTextBox,
which has a set of APIs to

00:07:54.590 --> 00:07:56.720
measure and draw Unicode text.

00:07:56.760 --> 00:08:00.020
The DrawThemeTextBox APIs, for instance,
use ATSUI, or wrappers,

00:08:00.160 --> 00:08:01.380
or what ATSUI calls.

00:08:01.410 --> 00:08:04.540
The Finder, for instance,
uses the toolbox and ATSUI directly.

00:08:04.580 --> 00:08:07.390
If you're a Cocoa application,
it's important to understand that if

00:08:07.390 --> 00:08:10.460
you need fine control on the layout,
you have two solutions.

00:08:10.490 --> 00:08:12.830
You could use the Cocoa Text Engine,
which one point or the

00:08:12.830 --> 00:08:14.780
other will code into ATSUI,
will call into AdSuite,

00:08:14.780 --> 00:08:17.890
or you could use it directly
from your Cocoa app.

00:08:19.960 --> 00:08:21.970
Another thing that is important
to understand is that ATSUI has

00:08:21.970 --> 00:08:23.380
been around for a long time.

00:08:23.380 --> 00:08:25.630
On Mac OS X,
it really blossoms and it really

00:08:25.700 --> 00:08:29.420
takes advantage of all this
advanced architecture that we have.

00:08:29.420 --> 00:08:32.860
But you still have a choice of
using Quick Draw for rendering,

00:08:32.860 --> 00:08:34.220
if you wish.

00:08:34.260 --> 00:08:36.610
I would not encourage you to
do so because of such a nice

00:08:36.630 --> 00:08:39.280
integration between a quads
rendering or 2D rendering.

00:08:39.550 --> 00:08:41.940
And just because the fact is
that if you go for Quick Draw,

00:08:41.940 --> 00:08:45.120
you won't get as much
like such a nice NTSSing.

00:08:45.120 --> 00:08:46.930
And then the default,
and what we encourage you to use,

00:08:47.030 --> 00:08:49.180
of course,
is to use ATSUI and Core Graphics.

00:08:49.300 --> 00:08:52.450
And at the bottom, of course,
you have ATS, Apple Type Services,

00:08:52.570 --> 00:08:55.170
which has all the management for fonts.

00:08:55.280 --> 00:08:56.830
And we had a session this morning.

00:08:56.830 --> 00:08:58.610
Hopefully you went to see that.

00:09:02.020 --> 00:09:04.640
So, when should I use ATSUI directly?

00:09:04.730 --> 00:09:06.580
As a developer,
it's very important for you to

00:09:06.670 --> 00:09:10.440
understand what technology you
need to use in your application,

00:09:10.440 --> 00:09:12.530
what makes more sense.

00:09:12.990 --> 00:09:16.200
If you need fine control
on the glyph positioning,

00:09:16.500 --> 00:09:20.010
if you need to display specific features,
text at an angle or text on a path,

00:09:20.170 --> 00:09:23.070
for instance, if you want to do your
own line positioning,

00:09:23.070 --> 00:09:25.900
if you want to access
directly advanced typography,

00:09:25.940 --> 00:09:29.140
if you have very specific needs
for markets such as Chinese and

00:09:29.150 --> 00:09:32.780
Japanese and do vertical text,
you will have to use ATSUI directly.

00:09:32.900 --> 00:09:34.900
ATSUI would be the answer for you.

00:09:34.900 --> 00:09:39.150
The second point is if you need,
as I said, advanced typographic features

00:09:39.150 --> 00:09:42.850
for text positioning,
for instance, or ligatures, swashes,

00:09:42.850 --> 00:09:45.670
you will have to use
ATSUI directly as well.

00:09:46.020 --> 00:09:49.690
And of course, if you're writing your
own text engine and MLT,

00:09:49.690 --> 00:09:52.060
the multilingual text engine,
is not enough for you,

00:09:52.060 --> 00:09:54.920
you will have to use
ATSUI directly as well.

00:09:57.220 --> 00:10:01.900
I'm going to go through a couple
of concepts very quickly on how

00:10:01.900 --> 00:10:05.580
ATSUI works and what are the
main pieces you need to use.

00:10:06.910 --> 00:10:07.920
Let's see.

00:10:08.010 --> 00:10:10.620
So first, what we have most of the time
is that we have a flow of text.

00:10:10.740 --> 00:10:16.550
So we have a pointer on UniCode text,
or we could have a CFString with

00:10:16.550 --> 00:10:19.080
UTF-16 text inside.

00:10:19.820 --> 00:10:22.030
The first thing you
create is a text layout.

00:10:22.180 --> 00:10:26.060
An ATSUI text layout has to represent,
or should represent, I should say,

00:10:26.150 --> 00:10:27.340
a paragraph.

00:10:27.480 --> 00:10:28.840
Why a paragraph?

00:10:28.900 --> 00:10:32.680
A paragraph because in order to do,
for instance, buy-die reordering,

00:10:32.930 --> 00:10:34.900
we need to have this
concept of paragraph.

00:10:35.020 --> 00:10:39.290
If you display buy-die scripts,
for instance, such as Arabic and Hebrew,

00:10:39.390 --> 00:10:44.400
the text will not be displayed correctly
if you do the drawing style by style.

00:10:44.520 --> 00:10:48.630
So the concept of paragraph is
very important for you to remember.

00:10:48.660 --> 00:10:51.400
And here, for instance,
we have three different paragraphs.

00:10:51.450 --> 00:10:54.830
We created three different
ATSUI text layouts.

00:10:56.160 --> 00:10:59.570
The UniCode buffer, as I said,
you pass it to the layouts.

00:10:59.920 --> 00:11:01.340
Very, very important.

00:11:01.450 --> 00:11:03.340
You own the text buffer.

00:11:03.380 --> 00:11:06.730
The text buffer is UTF-16,
two byte UniCode,

00:11:06.850 --> 00:11:08.560
and ATSUI doesn't make a copy.

00:11:08.560 --> 00:11:13.500
It just keeps a pointer on, you know,
a part of the text.

00:11:14.380 --> 00:11:17.250
and then of course we have
three different styles.

00:11:17.350 --> 00:11:19.100
And here we have, you know,
you can see that the style

00:11:19.100 --> 00:11:21.260
has been reused between the
first and the second layout.

00:11:21.260 --> 00:11:24.700
And I'll go in more details
about these concepts.

00:11:24.800 --> 00:11:25.880
So what's an ATSUI style?

00:11:26.040 --> 00:11:28.660
An ATSUI style is an OPAC object
that represents a collection

00:11:28.660 --> 00:11:31.000
of stylistic attributes.

00:11:31.100 --> 00:11:35.380
And once again, remember, you can reuse,
if you wish, an ATSUI style.

00:11:35.490 --> 00:11:38.610
If, let's say,
you're using Geneva 9 Italic in

00:11:38.610 --> 00:11:40.920
different parts of your document,
you don't have to

00:11:40.920 --> 00:11:42.520
duplicate that ATSUI style,
okay?

00:11:42.820 --> 00:11:46.290
You can just reuse it
in different layouts.

00:11:49.590 --> 00:11:54.180
So, of course, in the style,
we store things such as the font,

00:11:54.250 --> 00:11:55.940
the size, the color.

00:11:55.940 --> 00:11:58.890
But then, as I said before,
ATSUI supports way many more

00:11:59.050 --> 00:12:02.250
features than what we used
to have in a quick draw text,

00:12:02.250 --> 00:12:03.220
for instance.

00:12:03.250 --> 00:12:04.640
So in there as well,
you could have things such

00:12:04.640 --> 00:12:09.360
as is the text vertical,
things such as kernel, optical alignment,

00:12:09.510 --> 00:12:12.950
hanging punctuation,
width and cross-stream shift,

00:12:13.110 --> 00:12:15.160
which are very specific to ATSUI.

00:12:15.160 --> 00:12:18.090
In the style as well -- I'm sorry
-- are stored font features.

00:12:18.100 --> 00:12:22.020
And once again, these font features
are stored in the font.

00:12:22.060 --> 00:12:26.320
So the style will say if, you know,
ligatures are on, if you want caps,

00:12:26.540 --> 00:12:29.500
if you want swashes,
if you want variant glyphs,

00:12:29.500 --> 00:12:32.300
and font variations,
which are another aspect of the

00:12:32.730 --> 00:12:34.910
advanced typography that ATSUI supports.

00:12:39.060 --> 00:12:41.680
That's sweet text layout.

00:12:41.720 --> 00:12:45.640
You have to understand that sweet text
layout is the heart of all your drawing.

00:12:45.740 --> 00:12:48.940
That sweet text layout is
going to combine your text

00:12:48.940 --> 00:12:50.540
pointer and your styles.

00:12:50.640 --> 00:12:55.000
And it's going to have a set of features
to cache information about the text.

00:12:55.100 --> 00:12:58.590
So, ATSUI is going to store in the layout
all the information it needs in

00:12:58.680 --> 00:13:00.840
order to display the text correctly.

00:13:01.010 --> 00:13:05.100
So, it's going to store a reference
to your pointer on the text,

00:13:05.190 --> 00:13:07.680
and then it's going to store as
well references to the styles.

00:13:07.860 --> 00:13:09.530
It's going to combine them together.

00:13:09.640 --> 00:13:13.700
It's going to track as well the soft
breaks and the tap stops for you.

00:13:13.800 --> 00:13:17.410
And there is another set of features
that are supported through the layout,

00:13:17.410 --> 00:13:19.500
which are layout and line controls.

00:13:19.600 --> 00:13:23.600
And I'm going to go into details
about what I mean by line controls.

00:13:23.860 --> 00:13:26.740
Line controls are
attributes such as width,

00:13:26.770 --> 00:13:31.090
rotation of the layout, justification,
flushness, baseline.

00:13:31.290 --> 00:13:34.990
And the important thing to understand
is that these attributes don't have

00:13:34.990 --> 00:13:37.290
to be assigned to the whole paragraph.

00:13:37.510 --> 00:13:39.460
They can be assigned to a line.

00:13:39.460 --> 00:13:42.650
It's very, very powerful and I encourage
you actually to look into the

00:13:42.880 --> 00:13:46.380
details of how all the attributes,
line controls, that ATSUI supports.

00:13:49.630 --> 00:13:53.630
But, it seems all of you already know
all the concepts around ATSUI and

00:13:53.630 --> 00:13:55.100
have been looking into that.

00:13:55.100 --> 00:13:56.850
Let me show you a quick demo.

00:13:56.850 --> 00:13:59.410
If we can switch to my PowerBook here.

00:14:02.030 --> 00:14:04.330
Okay, great.

00:14:04.520 --> 00:14:09.660
So, first thing,
main advantage in ATSUI is that

00:14:09.870 --> 00:14:11.970
it's UniCode layout and rendering.

00:14:12.090 --> 00:14:15.640
It gives you access to, for instance,
all the character sets we

00:14:15.760 --> 00:14:17.200
put in the Ragino font.

00:14:17.330 --> 00:14:18.650
22,000 glyphs.

00:14:18.770 --> 00:14:21.100
The only way to access
this is to do UniCode.

00:14:21.350 --> 00:14:23.820
If you're a common application,
you have to use ATSUI.

00:14:23.880 --> 00:14:26.610
If you're a Cocoa application,
you could use actually the already

00:14:26.610 --> 00:14:29.950
existing infrastructure that actually
will do the correct thing and use

00:14:29.950 --> 00:14:32.000
ATSUI at one point of your layout.

00:14:33.750 --> 00:14:35.540
Here you can see, for instance,
some of the characters

00:14:35.540 --> 00:14:39.610
are available only,
only through ATSUI.

00:14:40.900 --> 00:14:44.200
There is another thing that is very
important because we say it gives a great

00:14:44.250 --> 00:14:46.650
advantage if you have markets in CGK.

00:14:46.650 --> 00:14:48.420
If you're shipping an
application right now for Japan,

00:14:48.420 --> 00:14:52.430
China, and Korea, ATSUI will give you
definitely an advantage,

00:14:52.430 --> 00:14:54.040
an edge on the competition.

00:14:54.140 --> 00:14:55.810
Because you're going
to be able to access,

00:14:55.870 --> 00:14:57.740
of course,
all these glyphs that nobody else

00:14:57.740 --> 00:14:59.260
has been able to display before.

00:14:59.370 --> 00:15:02.620
And here we have a couple of examples
actually from names with variants

00:15:02.620 --> 00:15:06.260
in it that nobody else could use
before we introduced this technology.

00:15:06.390 --> 00:15:09.860
But what does that mean, for instance,
for a current font like a

00:15:09.860 --> 00:15:12.990
font like Chainscree that
all of us have been using?

00:15:13.810 --> 00:15:15.340
What does it mean to do UniCode layout?

00:15:15.340 --> 00:15:17.120
Well, here you can see I'm
going to start typing,

00:15:17.120 --> 00:15:18.450
and you probably all see this demo.

00:15:18.450 --> 00:15:20.200
I've been around for like years now.

00:15:20.310 --> 00:15:23.420
And here you can see the
combining of the L's.

00:15:27.380 --> 00:15:29.070
The next thing I can go is what I said.

00:15:29.400 --> 00:15:31.040
What does that mean, advanced typography?

00:15:31.150 --> 00:15:33.080
Well,
advanced typography means actually I can

00:15:33.120 --> 00:15:35.240
change the way the text is displayed.

00:15:35.380 --> 00:15:39.300
I don't change the back storage,
but I change it the way it's displayed.

00:15:39.300 --> 00:15:43.290
And here, I'm sorry,
but I don't really like English.

00:15:43.290 --> 00:15:43.290
I prefer French.

00:15:46.650 --> 00:15:48.410
So here I can change, for instance,
the graphism,

00:15:48.410 --> 00:15:49.560
which is like the design level.

00:15:49.560 --> 00:15:53.000
And here you can see I get the
nice wash between the L and the O.

00:15:53.000 --> 00:15:54.910
Oh, it looks very nice.

00:15:55.130 --> 00:15:58.150
Actually, if I go back here,
and for those of you that want to

00:15:58.150 --> 00:16:04.120
see what that means in Japanese,
I can put it in Japanese if you prefer.

00:16:07.480 --> 00:16:11.480
Unicode Support and Advanced Typography.

00:16:11.480 --> 00:16:14.100
I'm following a couple of mailing
lists and one of them is CarbonDev

00:16:14.100 --> 00:16:16.640
and if you're an ADC member
you're probably one of them.

00:16:16.740 --> 00:16:21.560
And I had this person,
his name is Nick Nalik,

00:16:21.560 --> 00:16:25.100
and wanted to write some kind
of Unicode applications and he

00:16:25.100 --> 00:16:26.760
wanted to find more about ATSUI.

00:16:26.860 --> 00:16:29.760
And he saw one of my demos and
he liked Vortex and he said,

00:16:29.760 --> 00:16:31.770
"Hey, you know what,
I'd like to do the same thing and

00:16:31.770 --> 00:16:36.750
really show how cool the integration
between Quartz and ATSUI is." So he

00:16:36.760 --> 00:16:39.520
wrote this application which is called

00:16:39.650 --> 00:16:40.700
Quartz Draw.

00:16:40.730 --> 00:16:42.740
I'm trying to get him to
change to be ATSUI Draw,

00:16:42.740 --> 00:16:46.600
but you know, marketing is not my forte.

00:16:46.740 --> 00:16:49.390
So here I can actually select my text.

00:16:51.240 --> 00:16:53.820
A nice thing, as I said,
is that ATSUI supports vertical text,

00:16:53.930 --> 00:16:56.510
and here with a quick flag,
I'm going to switch the vertical text.

00:16:56.600 --> 00:16:58.360
I'm going to copy that.

00:16:58.410 --> 00:16:59.650
I'm going to go in quarts here.

00:16:59.830 --> 00:17:01.700
I'm going to copy and paste.

00:17:01.850 --> 00:17:04.160
So here, in fact, it's using ATSUI.

00:17:04.270 --> 00:17:04.930
Here, what do I have?

00:17:05.130 --> 00:17:09.260
This is a Carbon application that is
using core graphics to do the rendering,

00:17:09.370 --> 00:17:13.240
and is using ATSUI to
do the text display.

00:17:13.330 --> 00:17:15.730
Well, the cool thing is that
through the CG context,

00:17:15.790 --> 00:17:17.160
I get support for many things.

00:17:17.290 --> 00:17:19.660
So I can actually switch
all the characters,

00:17:19.740 --> 00:17:21.260
and this is from my PowerBook.

00:17:21.260 --> 00:17:23.060
You know, I have 256 meg of RAM.

00:17:23.120 --> 00:17:24.900
I mean, it's pretty fast.

00:17:25.010 --> 00:17:28.260
Probably doesn't look right anymore for,
like, the pure linguist.

00:17:28.320 --> 00:17:28.820
I can scan.

00:17:28.980 --> 00:17:29.890
I can translate.

00:17:29.900 --> 00:17:31.160
I can rotate very easily.

00:17:31.160 --> 00:17:34.100
And here, for instance,
we're going to do 90 degrees.

00:17:34.190 --> 00:17:35.910
That should be enough.

00:17:36.020 --> 00:17:38.260
And here, very quickly, I have, like,
you know, vertical text support.

00:17:38.410 --> 00:17:39.670
Okay, that's cool.

00:17:39.770 --> 00:17:42.220
No big deal here.

00:17:42.350 --> 00:17:44.760
Well, the nice thing with core
graphics is that it supports PDF.

00:17:44.760 --> 00:17:47.160
So what about we put a PDF in there?

00:17:47.250 --> 00:17:48.470
Okay, so I'm going to put a PDF.

00:17:48.570 --> 00:17:49.590
This file is one megabyte.

00:17:49.700 --> 00:17:51.100
Bye, bye, bye.

00:17:51.930 --> 00:17:55.860
So I have one file, one megabyte, okay,
that's cool, no big deal.

00:17:55.880 --> 00:18:01.140
I'm going to scale that 50% just so we
can see the tour Eiffel and the text.

00:18:01.790 --> 00:18:05.220
Well, the nice thing is that here
we have a concept of layers

00:18:05.280 --> 00:18:06.630
and the text is drawn below.

00:18:06.730 --> 00:18:09.700
Let me bring it forward
if I'm not mistaken.

00:18:09.790 --> 00:18:11.660
And you can see that ATSUI is
still displayed on top.

00:18:11.750 --> 00:18:12.750
There is no prime.

00:18:12.970 --> 00:18:15.800
ATSUI supports all the
CG context attributes,

00:18:15.800 --> 00:18:17.200
so it's not going to do any arrays.

00:18:17.350 --> 00:18:22.450
ATSUI's business is to draw international
text as quickly and as best as possible.

00:18:22.710 --> 00:18:24.950
That means for that,
with a simple set of APIs,

00:18:25.020 --> 00:18:27.460
what we want is you guys to
be able to support all the

00:18:27.460 --> 00:18:31.200
languages that are on the planet,
as long as you have appropriate font.

00:18:31.200 --> 00:18:33.050
So here,
ATSUI is not in the business of erasing

00:18:33.050 --> 00:18:34.700
the background and stuff like that.

00:18:34.700 --> 00:18:37.200
It just wants to display the text.

00:18:38.510 --> 00:18:39.840
So I can do that.

00:18:39.840 --> 00:18:48.820
The nice thing is that I can go back
and copy a bunch of text if I wish.

00:18:55.300 --> 00:18:56.700
I can move back the text.

00:18:56.700 --> 00:18:58.980
And here, the important thing is
that it's the integration,

00:18:58.990 --> 00:19:02.560
to show you the integration between
the cross-rendering and ATSUI.

00:19:02.560 --> 00:19:03.400
It's seamless.

00:19:03.400 --> 00:19:05.800
I can do all the changes, rotation.

00:19:05.800 --> 00:19:08.730
I can sketch the text.

00:19:09.200 --> 00:19:11.240
It's just up to you to find
out what you want to do.

00:19:11.310 --> 00:19:13.420
And you know what's the
cool thing with that?

00:19:13.530 --> 00:19:17.580
The cool thing is that because ATSUI is
completely integrated with Core Graphics,

00:19:17.660 --> 00:19:21.420
I can actually just save
the text as a PDF file.

00:19:21.490 --> 00:19:24.260
I save the file, everything is going to
be embedded in a PDF,

00:19:24.370 --> 00:19:27.800
you can send it to the printer,
or you can send it to a Windows machine,

00:19:27.900 --> 00:19:30.840
the font is going to be embedded,
you're going to have high resolution PDF,

00:19:31.020 --> 00:19:34.820
everything is going to be vectorized,
and you don't have to change your code.

00:19:39.620 --> 00:19:42.370
There is one thing that people
actually always ask is like,

00:19:42.370 --> 00:19:43.440
how do you get all these drop shadows?

00:19:43.440 --> 00:19:45.640
Well, let me show you how you
get the drop shadows.

00:19:45.640 --> 00:19:47.850
I can actually put like,
I don't know if it's

00:19:47.850 --> 00:19:49.100
very easy here to see.

00:19:49.180 --> 00:19:51.750
I can change the height of the shadow.

00:19:54.020 --> 00:19:56.590
Can you see the text?

00:19:56.650 --> 00:20:00.490
I can change the way the text
is displayed on the shadow.

00:20:02.020 --> 00:20:03.900
So everything is happening in real time.

00:20:04.040 --> 00:20:09.300
And if you saw the demo on
Monday morning about quartz compositing,

00:20:09.450 --> 00:20:10.900
well, by default,
you're gonna get that for

00:20:11.030 --> 00:20:13.700
free because everything here
goes through the CG context.

00:20:13.700 --> 00:20:16.530
You're gonna get the support and the
hardware acceleration when you're

00:20:16.530 --> 00:20:18.100
gonna be drawing using CG context.

00:20:18.230 --> 00:20:20.560
And here are the cool things
that I can continue to type.

00:20:20.690 --> 00:20:23.760
Here I can type "Tokyo" and see
everything's happening very quickly.

00:20:23.760 --> 00:20:31.080
Okay,
if we could switch back to the slides.

00:20:35.400 --> 00:20:41.460
But we've got a lot of feedback on what
ATSUI does and how you guys are using it.

00:20:41.460 --> 00:20:45.630
And this year for Jaguar,
we've been doing a lot of progress

00:20:45.860 --> 00:20:49.350
and a lot of improvements,
not only on the feature point of view,

00:20:49.350 --> 00:20:51.460
but the way you guys are
going to be able to use,

00:20:51.470 --> 00:20:53.660
and I would say abuse, ATSUI.

00:20:53.660 --> 00:20:56.390
And to talk about the new features
we've been working on in Jaguar,

00:20:56.390 --> 00:20:58.980
I'd like to introduce Tom Madden,
who has been working actually on

00:20:58.980 --> 00:21:03.770
ATSUI and is going to be talking about
all these features we put in the system.

00:21:08.700 --> 00:21:10.680
As he said, my name is Tom Madden.

00:21:10.770 --> 00:21:13.970
I'm here mainly because there was this
rumor floating around that you could

00:21:13.970 --> 00:21:16.440
only demo ATSUI if you were French.

00:21:16.520 --> 00:21:20.250
But that turns out to be not true,
and I'm actually going to go

00:21:20.250 --> 00:21:24.590
through some of the new features
we have planned for Jaguar.

00:21:24.770 --> 00:21:28.770
So the new features list is:
we have new features

00:21:28.980 --> 00:21:31.900
for batch line breaking,
tab support.

00:21:31.960 --> 00:21:34.530
We have a new feature
called direct access,

00:21:34.610 --> 00:21:36.960
which I'll go into a little bit more.

00:21:37.040 --> 00:21:39.440
We have new style flattening options.

00:21:39.590 --> 00:21:42.350
We have a new option
to show variant glyphs.

00:21:42.470 --> 00:21:46.330
We have some new options
to specify font fallbacks.

00:21:46.550 --> 00:21:50.030
We have some more
information on thread safety,

00:21:50.050 --> 00:21:54.930
as well as some new text
measurement attributes.

00:21:56.060 --> 00:22:01.880
So the first new feature we have
is this batch line breaking.

00:22:01.880 --> 00:22:07.030
And this will allow you to use ATSUI in
a much more paragraph-based form as

00:22:07.060 --> 00:22:08.940
we've been telling you to use it.

00:22:09.050 --> 00:22:12.780
It can reduce the overall line
breaking time by up to 50 percent

00:22:13.230 --> 00:22:17.840
and you'll actually end up executing
less code than ATSU break line.

00:22:17.920 --> 00:22:21.430
It's a single API to do
all your line breaking.

00:22:23.490 --> 00:22:30.060
So, previously to using batch breakline,
we had this breakline loop.

00:22:30.080 --> 00:22:33.480
You basically looped on ATSU breakline
until you set all the breaklines,

00:22:33.480 --> 00:22:37.430
and then you could get the number of
breaklines you actually set at the

00:22:37.430 --> 00:22:40.530
end by calling @su.getsoft.breaklines.

00:22:40.750 --> 00:22:42.760
This works pretty well,
and you still need to

00:22:42.760 --> 00:22:45.470
do it in some cases.

00:22:46.630 --> 00:22:50.900
The new API is called
ATSU Batch Breaklines.

00:22:50.920 --> 00:22:52.010
There's no looping involved.

00:22:52.160 --> 00:22:55.940
We'll do the looping for you,
and this actually helps save some

00:22:55.940 --> 00:23:01.680
time because ATSUI can better optimize
itself for the text it's breaking.

00:23:01.890 --> 00:23:07.800
ATSU Batch Breaklines can only
be used if the maximum line break

00:23:07.800 --> 00:23:10.970
width for all the lines is the same.

00:23:10.970 --> 00:23:15.440
This is very handy for breaking
text into neat little rectangles or

00:23:15.440 --> 00:23:18.740
breaking it down alongside a window.

00:23:18.740 --> 00:23:23.070
But if you're doing something
a little bit more advanced,

00:23:23.080 --> 00:23:28.820
such as wrapping the text around an
object or doing odd-shaped lines,

00:23:28.820 --> 00:23:31.140
you'll still need to loop
around ATSUI Breakline.

00:23:34.560 --> 00:23:38.280
The next new feature
we have is tab support.

00:23:38.520 --> 00:23:41.380
Now this will simplify the
task of implementing a ruler

00:23:41.380 --> 00:23:43.360
in your ATSUI document.

00:23:43.360 --> 00:23:47.460
Tab stops can now be set in
an ATSUI text layout object,

00:23:47.550 --> 00:23:49.980
and we've provided two new
APIs to set and get those.

00:23:52.640 --> 00:23:55.940
The new data types for tab
support include the ATSUI tab,

00:23:56.070 --> 00:24:01.000
which basically specifies where the
tab is and what the tab type is.

00:24:01.120 --> 00:24:05.040
We're supporting left, right,
and center flush tabs.

00:24:08.010 --> 00:24:13.660
The next new feature we have to
support is called ATSUI Direct Access.

00:24:13.660 --> 00:24:17.900
ATSUI Direct Access is
a little bit different.

00:24:18.250 --> 00:24:21.370
Today I'm going to go
through exactly what it is,

00:24:21.490 --> 00:24:25.140
what it can be used for,
and how do I use it,

00:24:25.300 --> 00:24:28.900
as well as I'll have a little
bit of a demo showing some of

00:24:28.900 --> 00:24:31.060
the stuff you can do with it.

00:24:31.980 --> 00:24:33.600
What is Direct Access?

00:24:33.670 --> 00:24:37.840
Well, Direct Access is a new set of APIs.

00:24:37.890 --> 00:24:43.060
It will allow you to directly access the
glyph data during the layout process and

00:24:43.090 --> 00:24:47.720
will allow you control over the layout
process through the use of callbacks.

00:24:47.720 --> 00:24:53.120
You can totally override one
of ATSUI's layout operations

00:24:53.710 --> 00:24:56.790
or you can just let it go.

00:24:57.140 --> 00:24:59.310
So what can I use Direct Access for?

00:24:59.420 --> 00:25:02.880
Well, you can use it for finer
control over the layout metrics.

00:25:02.920 --> 00:25:07.740
You can tweak just about any sort
of glyph data you can imagine.

00:25:07.790 --> 00:25:11.800
You can use it to override ATSUI's
internal layout operations,

00:25:11.840 --> 00:25:16.510
and you can even use it to replace
glyphs during the layout process.

00:25:19.030 --> 00:25:24.760
So, how do I use Direct Access before
I introduce the API?

00:25:24.830 --> 00:25:27.790
To use Direct Access,
you would just install this callback

00:25:27.930 --> 00:25:29.760
on the operations you wish to override.

00:25:29.890 --> 00:25:33.580
You are allowed to install one
callback and you need to pick

00:25:33.580 --> 00:25:36.120
the operations that you want.

00:25:36.120 --> 00:25:41.550
We have a new operation override tag
that you use with the ATSU Set Layout

00:25:41.550 --> 00:25:46.370
Controls API and use that to set
the callback that you wish to use.

00:25:46.660 --> 00:25:50.950
Then you simply call ATSUI normally
to measure and draw and then your

00:25:51.000 --> 00:25:54.710
callback will be invoked every time
ATSUI needs to relay out that line.

00:25:56.810 --> 00:25:58.820
This is kind of like,
I don't know if you guys

00:25:58.980 --> 00:26:03.610
watch late night TV,
you know, Ronco, set it and forget it.

00:26:04.150 --> 00:26:11.910
So, ATSUI's layout operations include,
we have linguistic operations,

00:26:11.910 --> 00:26:18.230
and these are necessary for
proper display in many languages,

00:26:18.230 --> 00:26:20.890
as well as they provide some
nice features in English.

00:26:20.960 --> 00:26:25.870
These linguistic operations
include the bidirectional level

00:26:25.870 --> 00:26:30.070
calculation and the glyph morphing.

00:26:30.070 --> 00:26:33.160
This is to form ligatures and
contextual forms and whatnot.

00:26:33.160 --> 00:26:39.770
Beyond that, we also have kerning,
tracking, baselines, and justification.

00:26:39.770 --> 00:26:44.510
So, which one of those can
I override with direct access?

00:26:44.940 --> 00:26:50.760
You can override justification, morph,
kerning, baseline, tracking,

00:26:50.780 --> 00:26:55.200
and in addition we're allowing you to
override what's called the post layout.

00:26:55.320 --> 00:27:00.900
And that's going to allow you
to access the glyph data after

00:27:00.900 --> 00:27:03.040
ATSUI has done all its work.

00:27:03.040 --> 00:27:07.190
So you can tweak things
in the final process.

00:27:12.410 --> 00:27:16.420
Notably absent from this list is ByteEye.

00:27:16.710 --> 00:27:19.330
You can't override ByteEye.

00:27:20.810 --> 00:27:24.580
So the callback implementation
looks like this.

00:27:24.800 --> 00:27:28.630
You basically just have to implement
something that looks like this.

00:27:28.630 --> 00:27:32.900
And your task will be first
to determine the reason why

00:27:32.900 --> 00:27:34.310
that callback was triggered.

00:27:34.390 --> 00:27:38.900
And we have this parameter that's passed
into you called iCurrentOperation.

00:27:38.970 --> 00:27:42.690
That's simply a bit field and you just
and it with the various operations for

00:27:42.910 --> 00:27:45.520
which you've installed the callback.

00:27:45.520 --> 00:27:48.740
As I said before,
you only get one callback and it

00:27:48.750 --> 00:27:51.090
gets called for all these operations.

00:27:51.090 --> 00:27:53.960
So it's up to you to
determine why it was called.

00:27:54.010 --> 00:27:56.620
If you only installed
it for one operation,

00:27:56.620 --> 00:27:59.720
then you don't have to
pay attention to that.

00:27:59.770 --> 00:28:02.740
Then you can use this second
parameter called ilineref to

00:28:02.740 --> 00:28:04.470
actually get the glyph data.

00:28:04.600 --> 00:28:07.500
And I'll go into that next.

00:28:07.500 --> 00:28:11.460
There's an API that can be used to
get direct access to the glyph data.

00:28:11.520 --> 00:28:16.400
You can then tweak the glyph data
in whatever means you wish to do.

00:28:16.460 --> 00:28:19.980
And then you return it to the glyph data.

00:28:19.980 --> 00:28:22.630
And you can see that it's now in
the OCallbackStatus parameter.

00:28:22.690 --> 00:28:25.950
And there's two options
for status right now,

00:28:25.950 --> 00:28:30.890
which basically says continue to
process the data or do nothing.

00:28:31.030 --> 00:28:36.020
And that's just a key to Atsui
to tell it what to do next.

00:28:36.510 --> 00:28:39.100
So if you still wanted
ATSUI to run that operation,

00:28:39.100 --> 00:28:41.640
you can if you decide not
to handle it yourself.

00:28:44.140 --> 00:28:47.920
So, as I mentioned before,
you use that ilineref parameter.

00:28:47.920 --> 00:28:50.700
You can use that to get the
data from inside the callback.

00:28:50.740 --> 00:28:52.940
And we provided an API to do this.

00:28:52.980 --> 00:28:56.050
This is called
atsu-direct-get-layout-data-array-pointer

00:28:56.160 --> 00:28:58.010
-from-lineref.

00:28:58.590 --> 00:29:01.260
Pretty long.

00:29:01.260 --> 00:29:04.540
And it returns a direct
pointer to the data.

00:29:04.540 --> 00:29:08.620
So you can change it,
you can mess with that pointer,

00:29:08.620 --> 00:29:11.450
you can change any of the data in it,
and there's a couple different

00:29:11.550 --> 00:29:14.660
pointers you can get,
which I'll go into soon.

00:29:14.700 --> 00:29:17.790
Because it returns a
direct pointer to the data,

00:29:17.840 --> 00:29:18.880
it's pretty fast.

00:29:19.150 --> 00:29:22.040
I mean, most of the stuff will
return in constant time.

00:29:22.100 --> 00:29:25.370
There's a couple that will
return in order-end time.

00:29:26.090 --> 00:29:29.030
Based on the number of
glyphs in that line.

00:29:29.280 --> 00:29:32.730
But you must dispose of this data
pointer by calling this other API,

00:29:32.920 --> 00:29:37.130
@SUDIRECT_RELEASE_DATA_ARRAY_POINTER,
and that will serve not

00:29:37.130 --> 00:29:41.840
only to release any possibly
dynamically allocated memory,

00:29:41.930 --> 00:29:46.140
but will also serve as a key to @SUI
that you're done with this data,

00:29:46.140 --> 00:29:51.310
and if it needs to do any merge
operation to merge any changes

00:29:51.970 --> 00:29:54.280
you've done to the array.

00:29:56.070 --> 00:30:01.820
So, you might be wondering, okay,
I set up the callback and...

00:30:02.370 --> 00:30:05.830
I don't want to set up a callback,
but I still want to get the data.

00:30:05.970 --> 00:30:11.110
Well, we've provided another API called
@SUDIRECT_GIT_LAYOUT_DATA_ARRAY_POINTER_

00:30:11.290 --> 00:30:13.090
FROM_TEXT_LAYOUT.

00:30:13.090 --> 00:30:16.080
And this one will return
a copy of the data.

00:30:16.080 --> 00:30:19.170
It doesn't return a direct pointer,
but it will allow you to access

00:30:19.300 --> 00:30:21.460
that data outside of the callback.

00:30:21.910 --> 00:30:25.580
This means you can't change anything
when you're outside the callback.

00:30:25.580 --> 00:30:29.750
Just like the previous API,
you still need to dispose

00:30:29.750 --> 00:30:36.540
of it by calling the
@SUDIRECT_RELEASED_LAYOUT_DATA_ARRAY_PO

00:30:36.540 --> 00:30:37.750
INTER API.

00:30:39.700 --> 00:30:41.800
So, what data makes an ATSUI glyph?

00:30:41.990 --> 00:30:44.540
In other words, what can I tweak?

00:30:44.560 --> 00:30:48.130
Well,
ATSUI data is all based on a baseline,

00:30:48.130 --> 00:30:53.100
and well, general layout data is
all based on the baseline.

00:30:53.100 --> 00:30:55.380
And I have some glyphs up on the screen.

00:30:55.380 --> 00:30:58.910
And the first thing that,
or actually this is the final

00:30:58.910 --> 00:31:03.480
thing that makes up an ATSUI glyph,
and that's the real position.

00:31:03.480 --> 00:31:07.860
The real position is the actual
laid out position of the glyph.

00:31:07.860 --> 00:31:11.910
And this is actually calculated
during the layout stages,

00:31:12.210 --> 00:31:14.640
the late layout stages,
and why we provided the

00:31:14.760 --> 00:31:15.950
post layout callback.

00:31:16.370 --> 00:31:17.770
So you can tweak this real position.

00:31:19.150 --> 00:31:24.600
The other things that make up an
ATSUI glyph include this advanced delta.

00:31:24.600 --> 00:31:27.960
The advanced delta is set
by various processes such as

00:31:28.070 --> 00:31:31.230
justification and other things.

00:31:31.330 --> 00:31:37.690
And it's basically the difference
between the next glyph's real position

00:31:38.110 --> 00:31:41.390
and the previous glyph's advance.

00:31:42.650 --> 00:31:46.310
The final piece of data
is the baseline delta.

00:31:46.310 --> 00:31:52.000
The baseline delta is any adjustment
above or below the baseline.

00:31:52.060 --> 00:31:54.760
These are all signed values,
so you can actually set them

00:31:54.760 --> 00:31:57.960
negative if you want the glyphs to
collide or if you want them to hover

00:31:57.960 --> 00:32:00.640
below the baseline or whatever.

00:32:02.560 --> 00:32:06.800
So the actual data structures
that kind of make up the glyph

00:32:06.800 --> 00:32:10.940
are the ATS layout record,
and that's kind of like the core,

00:32:10.950 --> 00:32:14.680
the atom of what a glyph is.

00:32:15.080 --> 00:32:18.360
This includes the actual real position,
which, as I said,

00:32:18.450 --> 00:32:21.210
is calculated in the later layout stages.

00:32:21.310 --> 00:32:24.100
That's the position of
the final layout glyph,

00:32:24.100 --> 00:32:30.660
the glyph ref,
the actual glyph ID of the glyph,

00:32:30.780 --> 00:32:33.580
some various flags, which,
if you look through the headers,

00:32:33.690 --> 00:32:36.980
some of them are kind of interesting,
and I'll kind of show you one

00:32:36.980 --> 00:32:38.590
interesting use of them in the demo.

00:32:38.930 --> 00:32:43.930
And the original offset,
which is the offset in the Unicode array

00:32:43.930 --> 00:32:47.010
that originally spawned this glyph.

00:32:47.180 --> 00:32:51.170
Beyond that, we have the baseline delta,
which was introduced before,

00:32:51.170 --> 00:32:56.700
the advanced delta, the style index,
which is an index into

00:32:56.700 --> 00:33:00.260
another parallel array,
which will get you actually

00:33:00.390 --> 00:33:01.780
the style of that glyph.

00:33:01.780 --> 00:33:10.140
And a device delta,
which is kind of available for tweaking.

00:33:10.530 --> 00:33:16.400
The position after the layout is done
to fit it into device space and whatnot.

00:33:16.610 --> 00:33:19.440
So, I'd like to introduce--
I have a little bit of a demo,

00:33:19.440 --> 00:33:21.240
kind of showing you what you can do.

00:33:21.480 --> 00:33:24.350
So I wrote this little app.

00:33:24.590 --> 00:33:26.520
and I will be joined by Tom Madden,
Tom Madden, Aaron Haney, and David Keefe.

00:33:26.570 --> 00:33:26.980
The first thing we are going
to do is to go to the demo,

00:33:26.980 --> 00:33:27.540
which is obviously enough
called Direct Access Demo.

00:33:27.540 --> 00:33:33.380
Basically, you can take...you have
your ATSUI rendering this

00:33:33.380 --> 00:33:37.210
kind of plain string,
and so you can do kind

00:33:37.210 --> 00:33:38.530
of mundane things to it.

00:33:38.600 --> 00:33:47.170
Like, you can play with...you can
override the justification routine

00:33:47.170 --> 00:33:54.250
and change the advanced deltas
to stretch and to shrink the line.

00:33:55.320 --> 00:34:00.340
Or you can even do more advanced things
like you can use a combination of the

00:34:00.340 --> 00:34:03.440
call to do a simple whitespace replace.

00:34:03.560 --> 00:34:07.210
And this was actually very
difficult to do previously without

00:34:07.220 --> 00:34:08.790
upsetting the line metrics.

00:34:08.920 --> 00:34:16.060
This one actually just grabs
the glyph array and swaps glyph

00:34:16.210 --> 00:34:23.060
IDs with another layout that
just includes this dot character.

00:34:23.180 --> 00:34:25.160
And so you can change things.

00:34:26.800 --> 00:34:32.520
You can even say lay out things
on a sine wave if you override

00:34:32.540 --> 00:34:38.090
the apply baselines routine.

00:34:38.370 --> 00:34:44.090
and just change the baseline and
of course you can change the font,

00:34:44.090 --> 00:34:45.300
whatever.

00:34:45.300 --> 00:34:50.290
And all the standard ATSUI features work.

00:34:50.420 --> 00:34:53.460
For instance, you can rotate the text.

00:34:53.920 --> 00:34:56.760
and it's still shown as a sine wave.

00:34:56.850 --> 00:35:00.130
And you can type.

00:35:01.700 --> 00:35:04.210
It's kind of hypnotic.

00:35:04.210 --> 00:35:08.060
And you can also do
the whitespace replace.

00:35:08.060 --> 00:35:10.140
That's kind of hard to see.

00:35:11.370 --> 00:35:14.770
Yeah, so it just kind of works
with all the ATSUI features,

00:35:14.770 --> 00:35:17.380
including caret positions
and hit testing,

00:35:17.480 --> 00:35:22.660
because you're messing with
the actual ATSUI layout.

00:35:22.720 --> 00:35:25.370
All right, can you bring back the slides?

00:35:29.350 --> 00:35:34.310
Beyond direct access,
we have some new APIs to flatten style

00:35:34.310 --> 00:35:39.470
run data to stream and then go ahead
and reconstruct that data from a stream.

00:35:39.560 --> 00:35:44.460
This was kind of hard to do before,
and it was even harder if you tried to

00:35:44.620 --> 00:35:50.290
parse the pasteboard data coming out
of MLTE to stick in your own ATSUI app.

00:35:50.450 --> 00:35:53.300
So we've provided
APIs to do that for you,

00:35:53.490 --> 00:35:56.740
and they all work based on
the standard pasteboard format

00:35:56.740 --> 00:36:01.070
for UniCode-styled text,
which is called the USTL version 2.0.

00:36:01.300 --> 00:36:04.980
And this is used by MLTE,
and it's understood

00:36:05.140 --> 00:36:10.290
by Cocoa applications,
and it's totally defined publicly,

00:36:10.290 --> 00:36:13.950
which means if you don't think we're
doing a good enough job flattening

00:36:13.950 --> 00:36:17.300
these things and restoring them,
you can parse them yourself.

00:36:17.520 --> 00:36:19.300
You can actually store more data in
these USTL versions of the ATSUI API.

00:36:19.300 --> 00:36:19.500
So we've provided
APIs to do that for you,

00:36:19.520 --> 00:36:19.790
and they all work based on
the standard pasteboard format

00:36:19.790 --> 00:36:20.300
for UniCode-styled text,
which is called the USTL version 2.0.

00:36:20.300 --> 00:36:22.920
And so if you want to do
more USTL structures than

00:36:22.920 --> 00:36:26.020
ATSUI currently recognizes,
which you may want to do,

00:36:26.020 --> 00:36:28.300
you can store advanced layout data.

00:36:28.300 --> 00:36:30.300
You can store your line
breaks in there if you want.

00:36:30.300 --> 00:36:36.300
But ATSUI will only recognize the
style data portion of the structure.

00:36:37.500 --> 00:36:40.510
So to flatten the styles,
we have the new API,

00:36:40.700 --> 00:36:44.400
Flatten Style Runs to Stream,
and this is used to flatten multiple

00:36:44.400 --> 00:36:46.560
style runs into a stream of data.

00:36:46.620 --> 00:36:50.950
You just need to pass your
ATSUI style objects and an array of

00:36:50.950 --> 00:36:55.590
run links and an allocated buffer,
and you get back a filled

00:36:55.590 --> 00:37:01.460
allocated buffer that has these
styles and runs flattened to it.

00:37:03.050 --> 00:37:05.630
Once you're on the other end,
like if you're reading data

00:37:05.710 --> 00:37:10.780
from the pasteboard or whatnot,
we have another API to

00:37:10.780 --> 00:37:14.580
reconstruct those streams,
and that's the ATSUI unflattened

00:37:14.580 --> 00:37:15.960
style runs from stream.

00:37:15.960 --> 00:37:20.680
Now this returns the style objects and
run information into separate arrays.

00:37:20.970 --> 00:37:24.400
This will also create ATSUI style
objects on behalf of you.

00:37:24.400 --> 00:37:29.170
You'll be responsible for disposing
of any ATSUI style objects created

00:37:29.250 --> 00:37:32.060
by this call to avoid leaking memory.

00:37:32.060 --> 00:37:36.390
The caller is responsible also
for matching up the style runs

00:37:36.620 --> 00:37:38.750
to the associated Unicode text.

00:37:39.020 --> 00:37:42.770
ATSUI is not going to
create layouts for you.

00:37:42.820 --> 00:37:49.120
It's not going to actually
tag any text with these runs.

00:37:49.160 --> 00:37:50.830
You actually have to do that yourself.

00:37:51.250 --> 00:37:54.300
What this will return is where
the style objects and where to

00:37:54.300 --> 00:37:58.040
put them in that Unicode run,
in that Unicode buffer.

00:37:58.250 --> 00:38:01.220
So you can usually get
this off the pasteboard.

00:38:01.270 --> 00:38:05.620
The Unicode text, the raw Unicode text,
is usually exported as U-text data,

00:38:05.650 --> 00:38:10.020
and MLTE, for instance,
will export alongside of that a USTL,

00:38:10.060 --> 00:38:11.720
and they match up perfectly.

00:38:11.780 --> 00:38:18.220
The runs in the USTL match up to the
runs with the associated U-text data.

00:38:20.130 --> 00:38:26.100
The next feature that we have, or we,
the next feature that is proposed for

00:38:26.100 --> 00:38:29.540
Jaguar is for variant glyph access.

00:38:29.650 --> 00:38:31.240
This one's kind of
interesting in that it will,

00:38:31.240 --> 00:38:36.210
it lets you display glyphs that
do not have an explicit Unicode

00:38:36.710 --> 00:38:39.720
character to glyph mapping,
but are rather variants of a

00:38:39.860 --> 00:38:43.860
glyph that does have an explicit
Unicode to glyph mapping.

00:38:43.970 --> 00:38:47.820
This will allow you access to
characters in the fonts that

00:38:47.820 --> 00:38:50.270
otherwise would not be accessible.

00:38:51.370 --> 00:38:53.380
Here's one example of Variant Glyphs.

00:38:53.530 --> 00:38:59.000
We have some Japanese text,
and we have a single UniCode

00:38:59.100 --> 00:39:05.500
[Transcript missing]

00:39:06.270 --> 00:39:07.100
There are lots.

00:39:07.100 --> 00:39:12.240
Our Hiragino fonts have lots
of these variants in them.

00:39:13.130 --> 00:39:17.610
So to support variant glyphs,
we have a new style tag.

00:39:17.610 --> 00:39:20.530
You basically just apply the
style to the character that you

00:39:20.530 --> 00:39:27.090
want to have a variation on,
or the character which when converted

00:39:27.400 --> 00:39:29.990
to a glyph will be variented.

00:39:30.400 --> 00:39:34.180
And we have a new attribute structure.

00:39:35.000 --> 00:39:39.050
This attribute structure will let you
choose the variant glyph by either

00:39:39.050 --> 00:39:43.040
a font-specific glyph or even a CID.

00:39:43.510 --> 00:39:46.570
And you can get this information
from the input method via

00:39:46.570 --> 00:39:48.300
the Text Services Manager.

00:39:48.780 --> 00:39:54.070
And we have a new event parameter,
the event param text input glyph

00:39:54.120 --> 00:39:56.300
info array event parameter.

00:39:56.450 --> 00:40:03.710
And this is available to just about any
of the events that return UniCode text.

00:40:04.160 --> 00:40:08.040
You do have to kind of set up TSM,
your TSM document a little

00:40:08.040 --> 00:40:12.180
bit to tell it that you're
willing to get these characters.

00:40:12.250 --> 00:40:18.220
But that information is
available in the TSM header.

00:40:19.850 --> 00:40:23.440
The next new feature,
which is actually in 10.1,

00:40:23.440 --> 00:40:26.440
but we've never really been
able to present it until now,

00:40:26.490 --> 00:40:29.800
is the use of font fallbacks objects.

00:40:30.450 --> 00:40:33.200
Font fallbacks objects allow
you to specify a search

00:40:33.330 --> 00:40:35.300
order for font substitution.

00:40:35.350 --> 00:40:38.790
As Xavier said before,
ATSUI has this great feature of

00:40:38.810 --> 00:40:43.720
substituting a font if the current
font doesn't have the character

00:40:43.770 --> 00:40:45.710
that you're trying to display.

00:40:45.710 --> 00:40:50.920
This list is basically just a
reference to a list of ATSUI font IDs.

00:40:50.940 --> 00:40:55.540
And then you take this list and you
attach it to an ATSUI text layout object.

00:40:55.570 --> 00:40:58.860
This is safer than relying on
the global font fallbacks list.

00:40:58.880 --> 00:41:03.620
ATSUI always allowed you to
change this font fallbacks list,

00:41:03.640 --> 00:41:05.430
but it was always on a global basis.

00:41:05.640 --> 00:41:08.200
Global meaning application-wide.

00:41:08.220 --> 00:41:10.840
As more and more things
start to use ATSUI,

00:41:10.850 --> 00:41:14.270
they start to use their fallbacks list.

00:41:14.270 --> 00:41:19.060
This includes toolbox things and possibly
even other threads in your application.

00:41:19.100 --> 00:41:23.540
If you're always using this
global font fallbacks list,

00:41:23.580 --> 00:41:26.240
you'll run into unexpected results,
possibly,

00:41:26.240 --> 00:41:28.560
if it gets changed out from under you.

00:41:28.660 --> 00:41:34.230
Beyond that,
it will also cache information about

00:41:34.860 --> 00:41:37.530
what fonts can display what glyphs.

00:41:38.510 --> 00:41:42.820
We have new APIs to create, destroy,
and manage these objects.

00:41:42.820 --> 00:41:47.940
They're all up there: ATSUI Create,
ATSUI Create Font Fallbacks,

00:41:47.940 --> 00:41:50.680
ATSUI Dispose Font Fallbacks,
and a couple to set the

00:41:50.680 --> 00:41:52.840
Font Fallbacks in the object.

00:41:53.030 --> 00:41:56.190
And these Font Fallback objects
should be shared if possible.

00:41:56.640 --> 00:41:58.610
They're not tied to any specific layout.

00:41:58.910 --> 00:42:00.360
You can set them in all your layouts.

00:42:00.440 --> 00:42:02.160
You can set them in just one layout.

00:42:02.160 --> 00:42:04.970
But as I said before,
they do cache some information.

00:42:05.060 --> 00:42:10.350
So if you're continually
destroying and creating these,

00:42:10.750 --> 00:42:15.070
then you'll definitely have a
bit of a performance penalty.

00:42:16.940 --> 00:42:21.220
Now I'd kind of like to talk
about ATSUI's thread safety.

00:42:21.290 --> 00:42:25.090
Previously we've said that

00:42:25.750 --> 00:42:32.940
at suey style objects and at suey
font fallback objects are thread-safe

00:42:33.040 --> 00:42:35.750
and that the APIs are thread-safe.

00:42:35.850 --> 00:42:40.220
The only thing that wasn't thread-safe
was the text layout object.

00:42:40.270 --> 00:42:45.250
In Jaguar, all the at suey objects
are now thread-safe,

00:42:45.340 --> 00:42:49.960
but you still need to be careful with
the global font fallbacks list because,

00:42:49.960 --> 00:42:53.670
as I said before,
another thread can change it

00:42:53.670 --> 00:42:56.720
out from under you and may
cause unexpected results.

00:42:56.940 --> 00:42:59.000
It won't cause a crash or anything.

00:42:59.000 --> 00:43:02.130
It will just cause the text
to be rendered in fonts

00:43:02.310 --> 00:43:03.370
that maybe you didn't want.

00:43:06.220 --> 00:43:08.950
We also have some new
options for text measurement.

00:43:08.950 --> 00:43:13.180
And before I go into that,
a little bit of a review is in order,

00:43:13.270 --> 00:43:15.800
because we always get a lot
of questions about the various

00:43:16.100 --> 00:43:18.000
text measurement APIs in ATSUI.

00:43:18.100 --> 00:43:24.100
The first thing that I'd like to review
is typographic-first image bounds,

00:43:24.830 --> 00:43:32.100
because there's various APIs in
ATSUI that provide for this measurement.

00:43:32.100 --> 00:43:36.890
So, as you can see,
the image bounds is kind of

00:43:36.900 --> 00:43:41.840
the box around the area in
which ATSUI will draw the text.

00:43:42.100 --> 00:43:44.080
It doesn't have any slack for anything.

00:43:44.140 --> 00:43:48.090
It's just a solid box around the
text that's going to be drawn.

00:43:48.100 --> 00:43:51.030
The typographic bounds,
on the other hand,

00:43:51.030 --> 00:43:55.100
includes space for any possible
ascenders or descenders.

00:43:55.100 --> 00:43:59.370
As you can see from the top example,
the image bounds and the typographic

00:43:59.370 --> 00:44:01.100
bounds are pretty different.

00:44:01.100 --> 00:44:04.460
The typographic bounds
includes any space,

00:44:04.580 --> 00:44:08.100
because there's no
descenders on that line.

00:44:08.100 --> 00:44:12.090
It includes kind of a
little bit of a space there.

00:44:12.100 --> 00:44:18.180
Now, this space is actually specified
by the font and not picked

00:44:18.180 --> 00:44:20.100
out of the air by ATSUI.

00:44:20.100 --> 00:44:25.450
The bottom text, the image bounds,
begins to approach the typographic

00:44:25.450 --> 00:44:30.100
bounds as the descenders are applied,
in terms of the double P there.

00:44:30.100 --> 00:44:32.490
the double P there.

00:44:33.610 --> 00:44:37.020
The first text measurement API,
this isn't anything new,

00:44:37.020 --> 00:44:39.730
but we thought that we
should probably review this,

00:44:39.840 --> 00:44:41.900
is @SUGitGlyphBounds.

00:44:42.020 --> 00:44:46.530
This API returns the typographic
bounds of the final line.

00:44:46.640 --> 00:44:51.130
This will return the bounds
in terms of trapezoids,

00:44:51.130 --> 00:44:55.940
which is kind of scary in the beginning,
but it's not as nice as

00:44:55.960 --> 00:45:03.840
dealing with the boxes,
but you can calculate height

00:45:04.030 --> 00:45:09.340
pretty easily if you rely on
your high school geometry.

00:45:09.340 --> 00:45:11.790
This is useful for laying
out line after line of text.

00:45:11.940 --> 00:45:14.310
This is really useful if you're doing,
for instance,

00:45:14.390 --> 00:45:17.450
a text editor or a word processor,
where when you're typing,

00:45:17.450 --> 00:45:20.730
you don't want the text to
bounce up and down every time an

00:45:20.830 --> 00:45:23.000
ascender or a descender is added.

00:45:23.060 --> 00:45:27.080
This will,
because it's the typographic bounds,

00:45:27.080 --> 00:45:29.810
it leaves enough room for that.

00:45:30.460 --> 00:45:33.560
The next API we have is
ATSUI Measure Text Image,

00:45:33.560 --> 00:45:37.500
and this one simply returns the image
bounds of the final laid-out line.

00:45:37.550 --> 00:45:40.040
This returns the bounds
in terms of a rectangle,

00:45:40.100 --> 00:45:47.900
and it's aligned on integer boundaries
because it's designed for screen.

00:45:48.340 --> 00:45:52.100
It's useful for figuring out the
exact area in which ATSUI would draw,

00:45:52.100 --> 00:45:53.560
as I mentioned before.

00:45:54.760 --> 00:46:00.650
The third one is probably
the most abused and

00:46:01.370 --> 00:46:05.410
How should I say this nicely?

00:46:05.760 --> 00:46:10.910
This one is used a lot mainly because
people see that it returns an ascent

00:46:10.970 --> 00:46:13.440
and a descent in the parameters list.

00:46:13.470 --> 00:46:14.440
And so they get all excited.

00:46:14.440 --> 00:46:17.200
It's like, oh, it's an API that returns
the ascent and the descent.

00:46:17.200 --> 00:46:18.530
I don't have to do any math.

00:46:18.780 --> 00:46:22.450
The problem with that is this
API returns the typographic bounds

00:46:22.570 --> 00:46:27.240
of a line prior to final line layout,
which means that if ATSUI has

00:46:27.240 --> 00:46:29.760
already laid out the line,
for instance,

00:46:29.760 --> 00:46:32.730
if you've already done a draw
or another type of measurement

00:46:32.800 --> 00:46:37.410
operation on the line,
this guy will go ahead and remove that

00:46:37.410 --> 00:46:42.580
line and go ahead and lay it out again
without many of the features turned on.

00:46:42.580 --> 00:46:48.620
This is useful mainly if you want
to calculate your own line breaking.

00:46:48.620 --> 00:46:51.660
As I said before,
it'll ignore any previously set

00:46:51.660 --> 00:46:55.020
line attributes such as flushness,
justification,

00:46:55.280 --> 00:47:00.170
rotation and that's why it'll
force in an extra layout.

00:47:01.600 --> 00:47:08.500
The new options are we have an ascent
tag and a descent plus letting tag.

00:47:08.500 --> 00:47:15.560
And the ascent tag is the KATSU line
ascent tag and there's a descent tag too.

00:47:15.560 --> 00:47:20.060
And you simply use these with
the ATSU Git line control and

00:47:20.740 --> 00:47:27.780
ATSU Git layout control API to
get the ascent and descent.

00:47:27.780 --> 00:47:30.130
These were previously in ATSUI.

00:47:30.290 --> 00:47:33.440
It's just that now even
if you don't set them,

00:47:33.910 --> 00:47:35.690
they'll return the actual values.

00:47:35.690 --> 00:47:39.130
Before they would only return
values if you had set them.

00:47:39.490 --> 00:47:43.060
These will return the values that
ATSUI is using to lay out the line.

00:47:43.060 --> 00:47:47.590
There's also, it's not on the slide,
but supposed to be,

00:47:47.590 --> 00:47:53.390
or it's planned for Jaguar,
there's going to be a set of tags that

00:47:53.500 --> 00:47:57.160
are similar like this where you can
get the ascent and descent of a style.

00:47:57.160 --> 00:48:00.720
So you can actually query the
style to get that information,

00:48:00.900 --> 00:48:04.150
which means you don't even
have to have a layout.

00:48:07.560 --> 00:48:12.930
That kind of concludes the new features
for ATSUI that are planned for Jaguar.

00:48:12.930 --> 00:48:17.560
I'd like to bring up now Aaron Haney,
who's going to go through

00:48:17.810 --> 00:48:24.120
some tricks and tips on how to
better optimize your ATSUI code.

00:48:24.240 --> 00:48:26.890
Aaron?

00:48:28.870 --> 00:48:30.230
Thanks, Tom.

00:48:30.310 --> 00:48:32.310
In this part of the presentation,
we're just gonna give you a

00:48:32.310 --> 00:48:36.170
few little tips and tricks
to get the most out of ATSUI.

00:48:36.580 --> 00:48:42.000
Some of these are specific to certain
releases of Mac OS X or Mac OS 9.

00:48:42.110 --> 00:48:44.230
And when they are, I'll specify that.

00:48:44.380 --> 00:48:45.940
Otherwise,
you can assume that these apply

00:48:45.940 --> 00:48:48.140
everywhere on all releases.

00:48:48.300 --> 00:48:50.000
So diving right in.

00:48:50.000 --> 00:48:51.510
Come on.

00:48:56.000 --> 00:48:59.530
To start with,
don't create a layout for each word,

00:48:59.530 --> 00:49:01.020
style, run, or line.

00:49:01.380 --> 00:49:03.900
This is very common for people
who are moving their code over

00:49:03.900 --> 00:49:07.750
from Quick Draw Text where you
drew each style run individually.

00:49:07.770 --> 00:49:11.530
It's easy to just rip that code out and
put a layout for each one of those runs.

00:49:11.540 --> 00:49:14.330
Don't do that because you'll
get very poor efficiency.

00:49:14.360 --> 00:49:17.750
And also, Etsui will not be able to
do its own by die analysis,

00:49:17.760 --> 00:49:19.900
which you get for free,
which is really nice.

00:49:20.030 --> 00:49:23.010
What you want to do is create
a layout for each paragraph.

00:49:23.460 --> 00:49:27.440
Because then you get by die for free,
it will give you much better performance,

00:49:27.440 --> 00:49:29.460
and also it will make your life easier.

00:49:29.460 --> 00:49:31.900
Your code will be a lot shorter.

00:49:32.680 --> 00:49:37.490
Secondly, don't throw your layouts away
when you change the text.

00:49:37.670 --> 00:49:40.600
We provide some APIs for
changing the text within a

00:49:40.600 --> 00:49:42.300
layout without throwing it away.

00:49:42.410 --> 00:49:46.360
You can use TextInserted and TextDeleted
whenever a user types or deletes text.

00:49:46.520 --> 00:49:51.020
And if you want to completely
replace all the text in the layout,

00:49:51.020 --> 00:49:53.390
you still don't have to
throw the layout away.

00:49:53.390 --> 00:49:58.390
You can say setTextPointerLocation to
point to a totally different buffer.

00:50:00.200 --> 00:50:04.940
Also, don't use multiple layouts
to flow text around shapes.

00:50:05.020 --> 00:50:09.850
You can still use the single layout
per paragraph paradigm even when you're

00:50:09.860 --> 00:50:12.460
doing line wrapping around boxes.

00:50:12.590 --> 00:50:16.280
ATSUI has a built-in mechanism
for embedding graphics and text,

00:50:16.500 --> 00:50:19.100
but what it gives you is something
like the diagram there on the

00:50:19.100 --> 00:50:22.540
left where it's just a single
line wrapped around the graphic.

00:50:22.620 --> 00:50:25.000
If you want something like
the diagram on the right,

00:50:25.060 --> 00:50:27.200
you can use multiple
lines to achieve that.

00:50:27.340 --> 00:50:31.000
There's nothing that says lines have
to be over and under each other.

00:50:31.040 --> 00:50:34.100
They can actually be side to
side or anywhere you want.

00:50:34.170 --> 00:50:37.610
Because when you call ATSUI DrawText,
you give it a set of coordinates.

00:50:37.930 --> 00:50:40.100
So you can simply vary the line width.

00:50:40.140 --> 00:50:42.550
Depending on which side
of the box you're on,

00:50:42.550 --> 00:50:45.540
you can pass in a line width
to ATSUI break line that's

00:50:45.550 --> 00:50:48.090
appropriate for that little segment.

00:50:49.600 --> 00:50:53.500
When you're line breaking,
don't use ATSUI Breakline anymore.

00:50:53.500 --> 00:50:55.940
You want to use the new
Batch Breaklines call.

00:50:56.050 --> 00:50:59.670
As Tom mentioned,
this can cut the time that's necessary

00:50:59.790 --> 00:51:02.900
to break your text into lines in half.

00:51:03.110 --> 00:51:06.580
You'll get much greater efficiency
and it requires a lot less code.

00:51:07.330 --> 00:51:09.240
Now,
for situations like I just mentioned,

00:51:09.240 --> 00:51:11.770
wrapping text around a box,
sometimes you still have to

00:51:11.770 --> 00:51:15.180
use the ATSUI break line call,
and you have to loop over it.

00:51:15.200 --> 00:51:19.370
When you're doing that,
don't set the soft breaks manually.

00:51:19.390 --> 00:51:24.440
Do pass true as the Boolean flag to
ATSUI break line that tells it whether

00:51:24.440 --> 00:51:26.290
or not to set the line break for you.

00:51:26.400 --> 00:51:30.010
There is a small performance
penalty if you call ATSUI break

00:51:30.010 --> 00:51:34.480
line and then immediately manually
set the soft line break after that.

00:51:34.600 --> 00:51:38.200
Unless you're gonna set it to something
different than what it returns you,

00:51:38.200 --> 00:51:40.780
just go ahead and pass true
and let it set it for you.

00:51:43.440 --> 00:51:47.440
When using styles, don't recreate style
objects for each draw.

00:51:47.440 --> 00:51:51.760
Do create a single style and keep it
around as long as you're gonna need it.

00:51:51.860 --> 00:51:55.850
This is very common if you've got a
lot of UI text in your application

00:51:55.850 --> 00:51:58.220
that's all drawn in a common style.

00:51:58.500 --> 00:52:02.430
If you recreate the same style
every time and then you look at the

00:52:02.430 --> 00:52:05.880
performance of your app in Sampler,
you may find that you're

00:52:05.880 --> 00:52:08.840
actually spending most of your
time simply recreating that

00:52:08.840 --> 00:52:10.450
same style over and over again.

00:52:10.560 --> 00:52:13.090
So it's much better to just
create that style once once at

00:52:13.090 --> 00:52:15.590
the beginning and keep it around.

00:52:16.930 --> 00:52:21.130
When you're drawing through CG,
don't create and destroy the CG context

00:52:21.180 --> 00:52:23.370
around each ATSUI DrawText operation.

00:52:23.490 --> 00:52:26.340
You don't want to wrap that inside
the beginning and end CG context.

00:52:26.520 --> 00:52:29.690
What you want to do is
create the context once,

00:52:29.790 --> 00:52:33.400
do all your draws,
and then dispose of it when you're done.

00:52:33.400 --> 00:52:36.750
You can keep it around for the life
of the application if you need to.

00:52:36.850 --> 00:52:39.000
It's much, much better to do it that way.

00:52:39.000 --> 00:52:42.400
There is a large performance penalty if
you're constantly creating and destroying

00:52:42.400 --> 00:52:44.400
the CG context over and over again.

00:52:44.530 --> 00:52:47.370
Again, I encourage you to use Sampler to
take a look at how much time you're

00:52:47.550 --> 00:52:50.010
spending doing these operations.

00:52:50.530 --> 00:52:54.850
Also, when CG drawing,
there's an old call in Quickdraw.h

00:52:54.970 --> 00:52:57.740
called CreateCGContextReport.

00:52:57.750 --> 00:53:04.040
The preferred API actually now is
QDBeginCGContext and QDEndCGContext.

00:53:04.040 --> 00:53:07.770
These are available
starting in Mac OS 10.1.

00:53:07.810 --> 00:53:11.960
There's a block comment in the
header in Quickdraw.h right above

00:53:11.960 --> 00:53:16.490
QDBeginCGContext that explains in more
detail why these APIs are preferred.

00:53:16.500 --> 00:53:19.240
They support printing,
they can be nested and they

00:53:19.560 --> 00:53:22.200
actually do return a little faster.

00:53:23.470 --> 00:53:26.530
And as Tom mentioned,
when you're measuring text,

00:53:26.530 --> 00:53:28.920
if you just want to know
how to space out your lines,

00:53:28.920 --> 00:53:31.910
you just want to know how far do
I scoot down to draw the next line,

00:53:31.930 --> 00:53:33.990
don't use ATSUI MeasureText for that.

00:53:34.090 --> 00:53:37.200
Do use ATSUI GetGlyphBounds,
or if you're on Jaguar,

00:53:37.200 --> 00:53:40.540
you can use the Ascent and Descent
tags to get that information.

00:53:40.680 --> 00:53:44.200
ATSUI MeasureText can cause ATSUI,
in some cases,

00:53:44.200 --> 00:53:50.040
to perform an extra relay out internally,
and that incurs a performance penalty.

00:53:50.110 --> 00:53:53.630
Whereas GetGlyphBounds and
the Ascent and Descent tags

00:53:53.630 --> 00:53:56.910
return in constant time always,
as long as the layout has

00:53:56.930 --> 00:53:59.480
already been performed,
which, if you're going to draw,

00:53:59.680 --> 00:54:01.790
it has to be done anyway.

00:54:03.480 --> 00:54:07.010
Starting in 10.1, we've got these new
fontfallbacks objects,

00:54:07.040 --> 00:54:12.840
so you do not want to use the global
fontfallbacks mechanism anymore.

00:54:13.010 --> 00:54:15.380
You do want to use these
new fontfallback objects,

00:54:15.440 --> 00:54:18.220
which is kind of a misnomer for
me to say that it's per layout,

00:54:18.310 --> 00:54:21.560
because actually you can
set the same fontfallbacks

00:54:21.650 --> 00:54:24.230
objects in multiple layouts.

00:54:24.240 --> 00:54:25.560
They're just like styles.

00:54:25.560 --> 00:54:28.100
You can share them across
all your layouts if you want.

00:54:28.100 --> 00:54:33.620
And these fontfallbacks objects contain
caches that Itsui keeps a record of

00:54:33.620 --> 00:54:36.640
which characters appear in which fonts.

00:54:36.830 --> 00:54:40.340
And that gets built up gradually
over time as you're drawing text.

00:54:40.460 --> 00:54:44.540
So you want to keep those
fontfallback objects persistent.

00:54:44.550 --> 00:54:47.330
So don't throw them away.

00:54:47.520 --> 00:54:49.060
Keep them around as long as possible.

00:54:49.230 --> 00:54:52.500
The same thing applies to these
objects as with other Itsui objects.

00:54:52.500 --> 00:54:57.350
It's much more efficient to keep
them persistent as long as possible.

00:54:57.680 --> 00:54:59.030
Share them between layouts.

00:54:59.170 --> 00:55:02.340
Unless you have different settings,
just use a single fontfallback's objects

00:55:02.570 --> 00:55:05.670
every single one of your layouts.

00:55:08.030 --> 00:55:12.260
When it comes to object
sharing between threads,

00:55:12.360 --> 00:55:18.570
you don't want to share ATSUI Text Layout
objects between threads unless

00:55:18.570 --> 00:55:21.240
you're running on Jaguar.

00:55:21.330 --> 00:55:24.210
As Tom mentioned, starting in Jaguar,
ATSUI Text Layout objects are

00:55:24.210 --> 00:55:26.970
thread-safe and you can share them.

00:55:27.210 --> 00:55:29.840
On previous systems,
ATSUI Style and ATSUI Fallback

00:55:29.840 --> 00:55:33.260
objects are thread-safe,
so you can always share those.

00:55:33.260 --> 00:55:37.870
You don't have to worry about
thread safety when it comes to that.

00:55:37.970 --> 00:55:40.200
And now for the summary,
I'd like to bring Zabia back up on stage,

00:55:40.320 --> 00:55:41.500
and then we'll have the Q&A session.

00:55:53.400 --> 00:55:56.910
we're running a little bit short,
but there is one thing that I really

00:55:56.920 --> 00:56:00.040
want you guys to understand is like,
ADSui brings you not

00:56:00.040 --> 00:56:03.510
only advanced typography,
but it gives you as well access to

00:56:03.520 --> 00:56:06.630
all these languages that were before
very difficult and you had to deal

00:56:06.700 --> 00:56:08.930
with different encodings and scripts.

00:56:08.930 --> 00:56:11.700
It gives you the advanced
Unicode text drawing,

00:56:11.810 --> 00:56:15.980
the advanced typography,
and the support for new languages.

00:56:16.010 --> 00:56:19.970
But ADSui with these new features,
we didn't get there just by

00:56:19.970 --> 00:56:21.560
sitting around and saying,
hey,

00:56:21.560 --> 00:56:23.490
we're going to fix that for the Finder.

00:56:23.580 --> 00:56:27.890
We've been getting a lot of feedback
from you guys since we started in 10.0.

00:56:28.080 --> 00:56:30.470
And ADSui has been around since Mac OS 9.

00:56:30.630 --> 00:56:32.600
But you have to understand
that with Mac OS X,

00:56:32.600 --> 00:56:35.590
ADSui has been really shining
and that's thanks to you guys.

00:56:35.600 --> 00:56:37.740
And we've been getting a
lot of feedback on the APIs,

00:56:37.740 --> 00:56:40.540
features that you wanted,
things for instance

00:56:40.540 --> 00:56:42.160
like direct access APIs.

00:56:42.160 --> 00:56:45.180
That comes from developers that said,
you know, the current set of APIs,

00:56:45.200 --> 00:56:46.540
that's not good enough for me.

00:56:46.540 --> 00:56:49.640
I need way more control because
my application does this and that.

00:56:49.640 --> 00:56:52.840
And this is really important
for you to understand,

00:56:53.190 --> 00:56:56.390
which is that's kind of a synergy
here between you and our team,

00:56:56.390 --> 00:56:59.490
which is to make these things better,
we need your feedback.

00:56:59.760 --> 00:57:02.780
And you have all of you
have like now the Jaguar CD.

00:57:02.830 --> 00:57:05.440
You can put your hands
on these new features.

00:57:05.550 --> 00:57:06.690
Try the new break line APIs.

00:57:06.690 --> 00:57:09.060
I think you'll be very happy
with what you've been doing and

00:57:09.060 --> 00:57:10.690
you'll see great performance.

00:57:10.690 --> 00:57:14.600
Try the direct access APIs and
tell us how you feel about it.

00:57:15.870 --> 00:57:18.930
Quickly,
I'll go through the documentation.

00:57:19.140 --> 00:57:23.080
The new version for ATSUI 1.2 is
actually covering the tech pubs.

00:57:23.080 --> 00:57:25.800
If you go there on this URL,
you get information.

00:57:25.800 --> 00:57:29.130
The best thing is actually to
know that this summer we'll have

00:57:29.130 --> 00:57:30.800
the new ATSUI book coming out.

00:57:30.800 --> 00:57:34.870
And you can comment if you have
any questions about the content.

00:57:36.380 --> 00:57:38.200
Thank you.

00:57:38.200 --> 00:57:39.490
The roadmap.

00:57:39.580 --> 00:57:42.000
On Thursday in room A2 we'll have MLT.

00:57:42.190 --> 00:57:47.550
It's the multilingual Unicode text engine
which is actually built on top of ATSUI.

00:57:47.730 --> 00:57:50.730
If you need more information and you have
specific needs for like text editing,

00:57:50.730 --> 00:57:52.420
I encourage you to go to this session.

00:57:52.470 --> 00:57:55.590
We have like very cool new features,
once again, that have been driven

00:57:55.630 --> 00:57:57.300
last year from developers.

00:57:57.650 --> 00:58:01.100
There's a great session if you're
looking into international markets and

00:58:01.100 --> 00:58:02.800
you're not sure how to approach them.

00:58:02.800 --> 00:58:07.560
We'll be talking actually about going
international with Mac OS X on Friday.

00:58:07.650 --> 00:58:11.950
Tonight at 7:30 in room N,
if I'm not mistaken,

00:58:11.950 --> 00:58:13.190
there is the Birds of Fever.

00:58:13.190 --> 00:58:14.200
Fever?

00:58:14.450 --> 00:58:18.860
Anyway, it's a gathering of developers
and engineers from Apple.

00:58:19.120 --> 00:58:21.480
And if you want to know more about ATSUI,
if you have any problems,

00:58:21.510 --> 00:58:23.820
if you want to have questions
about how you should handle

00:58:23.820 --> 00:58:27.050
Japanese maybe or Chinese,
or if you want to do advanced typography,

00:58:27.370 --> 00:58:28.060
come by there.

00:58:28.120 --> 00:58:30.450
We'll be downstairs where the labs are.

00:58:30.760 --> 00:58:31.610
It's going to be very cool.

00:58:31.610 --> 00:58:33.640
You're going to be able to talk
about what problems you have

00:58:33.640 --> 00:58:34.740
or maybe give us some feedback.

00:58:36.950 --> 00:58:40.710
Should you have any
questions that could happen,

00:58:40.710 --> 00:58:43.450
or maybe an announcement request
you'd like us to consider,

00:58:43.450 --> 00:58:44.350
please send me an email.

00:58:44.600 --> 00:58:45.290
That's my job.

00:58:45.500 --> 00:58:49.790
I talk directly with the OSVIS team to
find out how we can improve and how we

00:58:49.790 --> 00:58:52.960
can make things better for ATSUI and
our international technologies.

00:58:53.050 --> 00:58:56.960
My email is xavier@apple.com
and I'll have some cards around

00:58:56.960 --> 00:58:56.960
if you guys want to come by.
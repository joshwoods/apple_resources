WEBVTT

00:00:01.080 --> 00:00:06.000
Ladies and gentlemen,
please welcome Manager Cocoa Frameworks,

00:00:06.000 --> 00:00:07.330
Ali Ozer.

00:00:16.900 --> 00:00:18.700
Good morning.

00:00:18.830 --> 00:00:23.550
Okay, this morning we're going to
talk about Cocoa API Techniques.

00:00:27.620 --> 00:00:30.650
So what I mean by that is we're
going to explore the techniques

00:00:30.650 --> 00:00:34.040
for Cocoa API design and
conventions used in the Cocoa APIs.

00:00:34.280 --> 00:00:37.010
And we're also going to cover a
lot of case studies to give you

00:00:37.010 --> 00:00:40.090
an idea of how these are used
and how you can make use of them.

00:00:40.210 --> 00:00:41.630
Our goals here are twofold.

00:00:41.800 --> 00:00:46.730
One, so that you can understand the
reasoning behind Cocoa APIs,

00:00:46.840 --> 00:00:49.260
the reasoning behind the
design of Cocoa APIs,

00:00:49.380 --> 00:00:51.610
and that way you can
leverage Cocoa better.

00:00:51.800 --> 00:00:54.270
And secondly,
that you can extend Cocoa objects

00:00:54.400 --> 00:00:58.910
and also use the same conventions and
techniques in your own APIs that you

00:00:58.910 --> 00:01:01.740
can build into your own frameworks,
so that there's a consistent set of

00:01:01.870 --> 00:01:05.380
APIs across frameworks moving forward.

00:01:06.000 --> 00:01:08.700
Here are the topics we're going to cover.

00:01:08.820 --> 00:01:11.790
First, a quick look at naming
and API conventions,

00:01:11.790 --> 00:01:15.400
then into object ownership,
then into mutability,

00:01:15.460 --> 00:01:18.540
and we're going to discuss why
you can't always change someone.

00:01:18.640 --> 00:01:27.080
Then we're going to look at subclassing
and the dark side of subclassing,

00:01:27.080 --> 00:01:27.080
and then look a bit at plug-in
design and performance of APIs.

00:01:28.230 --> 00:01:30.190
First, naming and API conventions.

00:01:30.290 --> 00:01:32.880
Now, these are things that if you've
looked at Cocoa APIs at all,

00:01:32.880 --> 00:01:35.430
you're probably familiar with,
but I just want to put it up

00:01:35.590 --> 00:01:38.720
on slides so it's explicitly
written down and you see it.

00:01:38.770 --> 00:01:41.390
Here are the kind of
names we use in Cocoa.

00:01:41.400 --> 00:01:45.470
Let me just explain some of the
conventions behind these namings.

00:01:49.150 --> 00:01:52.710
First thing you notice in Cocoa APIs is
we tend to use prefixes on class names,

00:01:52.750 --> 00:01:53.760
function names, etc.

00:01:53.760 --> 00:01:57.900
For instance, NSString, NSImage,
NSPreferencePane.

00:01:57.900 --> 00:02:01.980
Those are part of the core
Cocoa frameworks or extensions to them.

00:02:01.980 --> 00:02:05.460
And then we have prefixes like AB on
our new address book frameworks,

00:02:05.460 --> 00:02:08.610
ABPerson, ABRecord,
or DR for disk recording frameworks.

00:02:08.800 --> 00:02:10.020
The idea here is twofold.

00:02:10.120 --> 00:02:12.340
One,
we want to protect against collisions.

00:02:12.660 --> 00:02:15.510
Objective-C doesn't have namespaces,
so this obviously reduces

00:02:15.700 --> 00:02:16.880
the chance of collision.

00:02:16.880 --> 00:02:19.310
Secondly, we want to differentiate
functional areas.

00:02:19.350 --> 00:02:23.410
When you're looking at some source
code and you see an NSImage,

00:02:23.520 --> 00:02:26.170
you know NS, this must come from Cocoa.

00:02:26.180 --> 00:02:29.340
This is as opposed to just seeing
image where you might not know which

00:02:29.410 --> 00:02:31.170
functional area this belongs in.

00:02:31.220 --> 00:02:33.860
That is why even in our
Java APIs and Cocoa Java APIs,

00:02:33.860 --> 00:02:37.010
we tend to use prefixes,
although they have namespaces.

00:02:37.020 --> 00:02:38.760
One rule we want to keep in mind is that
we want to protect against collisions.

00:02:38.810 --> 00:02:41.560
Another rule we apply is it's
better to be clear than brief.

00:02:41.560 --> 00:02:43.190
Even that means you get long names.

00:02:43.320 --> 00:02:46.580
For instance,
here we use Objective-C's keywording

00:02:46.580 --> 00:02:49.140
facility to say insert object at index.

00:02:49.310 --> 00:02:51.140
We name each argument with a noun.

00:02:51.160 --> 00:02:54.630
That's instead of using insert at,
which is what's going on,

00:02:54.670 --> 00:02:57.110
or insert colon colon,
which is a perfectly

00:02:57.160 --> 00:03:00.410
valid Objective-C name,
but you lost something.

00:03:00.810 --> 00:03:02.980
Another example is
remove object at index.

00:03:02.980 --> 00:03:05.700
That makes it clear
you're passing an index.

00:03:05.700 --> 00:03:08.500
Remove object makes it sound
like you're passing an object.

00:03:08.920 --> 00:03:12.510
And remove colon by itself is, you know,
it's hard to tell what

00:03:12.510 --> 00:03:14.020
that's supposed to do.

00:03:14.560 --> 00:03:17.590
Here is, as a bonus slide,
the longest method name in Cocoa,

00:03:17.590 --> 00:03:18.880
at least in the public API.

00:03:18.880 --> 00:03:21.050
We've got some longer ones privately.

00:03:21.150 --> 00:03:24.470
And you know, you might think, my god,
having to type that all the

00:03:24.470 --> 00:03:27.990
time is just not going to work.

00:03:28.060 --> 00:03:30.000
And this is what it looks like in code.

00:03:30.080 --> 00:03:33.250
Now compare this to if you
didn't have the keywords.

00:03:33.900 --> 00:03:34.760
Okay?

00:03:34.840 --> 00:03:36.600
And if you were just looking at this
in your source code and you saw those

00:03:36.600 --> 00:03:39.440
32s and 4s and trues and falses,
I mean,

00:03:39.460 --> 00:03:43.330
you have to go open up the documentation,
because you have no idea what those mean.

00:03:43.620 --> 00:03:45.300
Back to naming conventions.

00:03:45.400 --> 00:03:47.200
Use consistent terminology.

00:03:47.300 --> 00:03:50.970
If you use remove in some subsystem,
it means remove or delete.

00:03:51.620 --> 00:03:52.980
Continue to use remove.

00:03:53.370 --> 00:03:54.720
Don't use delete suddenly.

00:03:54.880 --> 00:03:57.590
Or don't, under any circumstances,
use delete to mean

00:03:57.590 --> 00:03:58.980
something subtly different.

00:03:59.020 --> 00:04:03.260
Remove removes if it's there,
but delete removes it if it's not there.

00:04:03.330 --> 00:04:05.180
That just gets lost in the noise.

00:04:05.310 --> 00:04:09.760
And although it might be tempting,
don't open up the thesaurus

00:04:09.760 --> 00:04:11.590
and look for other words.

00:04:12.340 --> 00:04:15.240
Vaprize object and index is a great name,
but it might not quite fit

00:04:15.250 --> 00:04:17.990
with the rest of the API.

00:04:19.480 --> 00:04:21.900
Don't abbreviate names in the API.

00:04:22.030 --> 00:04:23.480
For instance, set floating point format.

00:04:23.610 --> 00:04:27.220
Maybe a bit long for what it does, but,
you know, it gets the point across.

00:04:27.330 --> 00:04:29.440
You might be tempted a bit to point.

00:04:29.570 --> 00:04:30.560
That's not a very interesting word.

00:04:30.560 --> 00:04:31.580
Let's just cut it down.

00:04:31.900 --> 00:04:34.480
But, you know,
somebody who's reading your

00:04:34.480 --> 00:04:37.720
API for the first time won't
know what PNT might mean.

00:04:37.720 --> 00:04:39.130
Is it a pint or a point?

00:04:39.130 --> 00:04:43.280
Or, you know, don't fall into the Unix
trap and forget your vowels.

00:04:43.280 --> 00:04:44.730
Set float put thumped.

00:04:44.760 --> 00:04:46.080
You know, that's just good, bad, ugly.

00:04:46.080 --> 00:04:46.080
You know, make it long.

00:04:46.990 --> 00:04:48.460
If you do abbreviate, be consistent.

00:04:48.460 --> 00:04:51.690
In Cocoa, we do use some abbreviations,
and we certainly use abbreviations

00:04:52.040 --> 00:04:53.420
where they're industry terms.

00:04:53.420 --> 00:04:57.460
It's OK to use them as long as
you're consistent and predictable.

00:04:57.460 --> 00:04:59.400
Avoid names that are ambiguous.

00:04:59.570 --> 00:05:00.000
Send port.

00:05:00.310 --> 00:05:02.970
Are you sending a port,
or is it the port used for sending?

00:05:03.060 --> 00:05:03.670
Display name.

00:05:03.670 --> 00:05:06.690
Are you displaying the name,
or is the name used for display?

00:05:06.810 --> 00:05:07.700
Center.

00:05:07.700 --> 00:05:09.620
You can verb anything.

00:05:09.620 --> 00:05:13.200
Is this the center point of something,
or is it centering the thing?

00:05:13.330 --> 00:05:15.820
For instance,
you can use human readable name,

00:05:15.820 --> 00:05:18.800
presentation name,
or you can say center window.

00:05:18.800 --> 00:05:21.840
Try to be a little clearer
when you have ambiguities.

00:05:22.500 --> 00:05:24.960
Use verbs for methods
which represent actions.

00:05:25.200 --> 00:05:27.000
Select cell, remove object at index.

00:05:27.000 --> 00:05:29.060
These do something so it's a verb.

00:05:29.190 --> 00:05:32.800
But if your methods return values,
even if they're computed values,

00:05:32.900 --> 00:05:35.600
stick to the attribute
or computed value name.

00:05:35.810 --> 00:05:38.400
Cell size, not calculate cell size.

00:05:38.400 --> 00:05:40.510
A value is being returned.

00:05:42.150 --> 00:05:45.350
And as you can tell, in Cocoa,
our setters use set,

00:05:45.370 --> 00:05:47.600
but our getters do not use get.

00:05:47.600 --> 00:05:48.870
So it's set color and color.

00:05:48.880 --> 00:05:49.840
Here we have a noun.

00:05:50.010 --> 00:05:51.330
Set color, color.

00:05:51.450 --> 00:05:53.680
With an adjective, set editable,
is editable.

00:05:53.680 --> 00:05:55.440
Again, you know, we use is there.

00:05:55.440 --> 00:05:59.150
And with a verb, set draws background,
draws background.

00:05:59.440 --> 00:06:02.790
We don't use get draws
background or get is editable.

00:06:03.610 --> 00:06:06.580
The one place we do use get is where
we have multiple return values.

00:06:06.650 --> 00:06:08.900
Like here we have row and
column being returned.

00:06:08.900 --> 00:06:09.450
They're related.

00:06:09.460 --> 00:06:12.730
It makes sense to combine them so you
can have a get method with two arguments.

00:06:12.730 --> 00:06:16.250
This is the exception where we
use get because here they're being

00:06:16.490 --> 00:06:18.500
gotten into those elements there.

00:06:18.510 --> 00:06:22.070
And note that in cases like this,
often the values are optional,

00:06:22.070 --> 00:06:25.700
meaning you can pass and null if
you don't want one or the other.

00:06:26.690 --> 00:06:32.360
Now let me just quickly talk about
some of the API conventions here.

00:06:32.360 --> 00:06:33.360
Be consistent again.

00:06:33.360 --> 00:06:36.360
For instance, in Cocoa we use floats
to represent coordinates.

00:06:36.360 --> 00:06:38.640
We don't use ints.

00:06:38.930 --> 00:06:42.150
Similarly, whenever we have actually
a coordinate in space,

00:06:42.150 --> 00:06:44.680
we use an NSPoint,
which is a struct of two points,

00:06:44.750 --> 00:06:46.620
or two floats, I'm sorry.

00:06:46.620 --> 00:06:48.340
We don't ever have X and Y in the API.

00:06:48.340 --> 00:06:50.220
We always have NSPoints.

00:06:50.290 --> 00:06:53.190
And another example is instead of
char star to represent strings,

00:06:53.190 --> 00:06:55.740
we use NSString objects.

00:06:55.740 --> 00:06:57.750
All this leads to, you know,
this consistency leads to

00:06:57.840 --> 00:06:59.180
higher impedance matching.

00:06:59.260 --> 00:07:01.760
If you have different
types and different APIs,

00:07:01.880 --> 00:07:04.160
for one thing,
you get performance issues.

00:07:04.160 --> 00:07:06.710
You know, converting between NSString and
char star is not cheap,

00:07:06.810 --> 00:07:07.560
back and forth.

00:07:07.560 --> 00:07:09.550
And in addition, you might get lossiness.

00:07:09.550 --> 00:07:12.210
If you are converting between
floats and ints every time you're

00:07:12.300 --> 00:07:14.550
calling some API or the other,
you know, your floats are going to

00:07:14.560 --> 00:07:18.000
be lossy down to ints.

00:07:18.000 --> 00:07:21.160
We usually treat nil not
as a valid object argument,

00:07:21.160 --> 00:07:23.460
although nil is a, you know, object.

00:07:23.460 --> 00:07:25.880
Object pointer meaning nothing.

00:07:25.990 --> 00:07:29.630
Methods like append string, set title,
and Cocoa APIs don't accept nil.

00:07:29.630 --> 00:07:33.240
It's because nil becomes ambiguous,
and we don't want to go down that path of

00:07:33.240 --> 00:07:35.420
always having to document what it means.

00:07:35.640 --> 00:07:38.190
Similarly, if you ask a view,
give me your subviews,

00:07:38.310 --> 00:07:39.640
and it returns an array.

00:07:39.640 --> 00:07:42.880
If it has no subviews,
you get back an empty array

00:07:43.340 --> 00:07:45.220
because it's no subviews.

00:07:45.220 --> 00:07:46.890
And similarly,
you can't put nil in arrays,

00:07:46.890 --> 00:07:48.420
dictionaries, et cetera.

00:07:48.570 --> 00:07:51.660
Now, nil can be used to indicate runtime
or other exceptional conditions.

00:07:51.670 --> 00:07:53.780
And, you know, for instance,
if you try to create an object and it's

00:07:53.910 --> 00:07:56.510
not there or there's no file behind it,
whatever, you know,

00:07:56.510 --> 00:07:58.400
you will get back nil.

00:07:58.400 --> 00:08:02.230
So those will usually be
documented as nil being returned.

00:08:02.320 --> 00:08:04.170
And finally, programming errors.

00:08:04.170 --> 00:08:06.700
Now here I'm talking
about programming errors.

00:08:06.700 --> 00:08:09.630
For instance, you know,
your array has eight elements and

00:08:09.630 --> 00:08:11.600
you try to index element million.

00:08:11.600 --> 00:08:15.590
Or, you know,
you pass an invalid nil arguments.

00:08:15.590 --> 00:08:19.890
These are usually noted with exceptions,
not by error codes.

00:08:19.890 --> 00:08:22.750
So in Cocoa, you know, programs,
you'll see these exceptions when

00:08:22.750 --> 00:08:24.220
you're doing something wrong.

00:08:24.220 --> 00:08:27.130
And the idea is that you should fix those
exceptions before you ship your app,

00:08:27.530 --> 00:08:30.620
rather than trying to catch those
exceptions and deal with them at runtime.

00:08:30.740 --> 00:08:34.500
Because they're programming errors, and,
you know, they will lead to

00:08:34.500 --> 00:08:36.000
something bad if they're

00:08:37.250 --> 00:08:40.940
The most important API convention
in Cocoa involves object ownership,

00:08:40.940 --> 00:08:44.500
and so I'm going to spend a
few minutes on that issue.

00:08:44.620 --> 00:08:45.190
Let's see.

00:08:45.250 --> 00:08:48.490
This API convention...

00:08:48.650 --> 00:08:53.780
is object ownership is not
transferred across calls.

00:08:54.170 --> 00:08:54.990
Let me explain that.

00:08:54.990 --> 00:08:57.070
But to explain it,
first let me give you a very quick

00:08:57.170 --> 00:08:58.430
refresher on memory management.

00:08:58.440 --> 00:09:00.090
If you were at the intro talk,
you got this.

00:09:00.220 --> 00:09:03.780
And clearly, if you read any Cocoa book,
you've probably seen this in early pages.

00:09:03.890 --> 00:09:06.260
Very quickly,
Cocoa objects are reference counted.

00:09:06.260 --> 00:09:08.090
Alloc a new create new objects.

00:09:08.180 --> 00:09:09.500
Copy copies an object.

00:09:09.500 --> 00:09:11.740
Those create reference count of one.

00:09:11.740 --> 00:09:14.720
Retain and release,
add and remove a reference count.

00:09:14.740 --> 00:09:17.700
Auto-release releases an object later.

00:09:17.700 --> 00:09:21.380
And finally, objects are deallocated when
their reference count is zero.

00:09:21.380 --> 00:09:24.080
So, you know,
as far as ref counting systems go,

00:09:24.080 --> 00:09:24.080
it's a lot of work.

00:09:24.100 --> 00:09:24.760
So, it makes sense.

00:09:24.760 --> 00:09:27.720
Let me give you an analogy,
not because you need one, maybe,

00:09:27.730 --> 00:09:30.580
but because I intend
to milk this analogy.

00:09:30.610 --> 00:09:33.870
So, let's say you go into a restaurant,
and there's a table.

00:09:34.090 --> 00:09:34.710
You sit down.

00:09:34.710 --> 00:09:36.080
You now have that table.

00:09:36.080 --> 00:09:37.310
You've allocated it.

00:09:37.310 --> 00:09:38.190
It's yours.

00:09:38.210 --> 00:09:40.550
If you get up and leave,
you've released the table,

00:09:40.590 --> 00:09:44.020
and the waiter can come and reclaim it,
clean it up for the next customer.

00:09:44.020 --> 00:09:46.330
When you're sitting there,
if a friend of yours comes in and

00:09:46.330 --> 00:09:49.580
you invite them to sit at the table,
now there's two references to that table.

00:09:49.580 --> 00:09:52.100
Even if you get up and leave,
the table is still owned,

00:09:52.240 --> 00:09:53.910
and the waiter won't clean it up.

00:09:54.140 --> 00:09:58.290
until your friend leaves as well,
the table is still allocated.

00:09:59.100 --> 00:10:02.510
The order release case
can be thought of as,

00:10:02.540 --> 00:10:04.730
as you're leaving, you give the waiter a
little tip and you say,

00:10:04.820 --> 00:10:07.000
hold that table for a while,
and then you leave.

00:10:07.130 --> 00:10:10.740
So the waiter sort of lingers around,
doesn't touch the table,

00:10:10.740 --> 00:10:12.120
and eventually cleans it up.

00:10:12.240 --> 00:10:14.070
But in the meantime,
if somebody else comes,

00:10:14.070 --> 00:10:15.910
a friend of yours comes
and sits at the table,

00:10:16.010 --> 00:10:17.300
the table hasn't gone away.

00:10:17.460 --> 00:10:20.560
So the order release just
delays that release a bit.

00:10:23.220 --> 00:10:25.020
With that in mind,
passing objects around.

00:10:25.370 --> 00:10:27.460
Object ownership is not
transferred across calls.

00:10:27.890 --> 00:10:31.060
When you pass someone an object,
either by returning it from a function

00:10:31.070 --> 00:10:34.000
or as an argument to a function,
they will retain it or copy it if

00:10:34.080 --> 00:10:38.050
they want and release it when done,
and you don't copy or retain it for them.

00:10:39.880 --> 00:10:42.560
Another way to say this is,
if you copy or retain something,

00:10:42.720 --> 00:10:43.480
you release it.

00:10:43.620 --> 00:10:45.400
So everybody is responsible
for their own thing.

00:10:45.480 --> 00:10:48.880
The balance of reference counts in
the universe must be maintained,

00:10:48.880 --> 00:10:51.190
and people are responsible
for doing that.

00:10:52.720 --> 00:10:55.140
And this leads to pretty
straightforward programming in Cocoa.

00:10:55.140 --> 00:10:57.280
Here's a quick example.

00:10:57.420 --> 00:10:59.830
First, we get the title of a document.

00:10:59.830 --> 00:11:02.200
Then we capitalize that string.

00:11:02.460 --> 00:11:04.260
You know, we fix it up.

00:11:04.360 --> 00:11:06.280
Now this, you know, here,
notice we're asking the string

00:11:06.280 --> 00:11:07.200
for a capitalized version.

00:11:07.200 --> 00:11:08.730
It returns a new string.

00:11:08.840 --> 00:11:11.830
And finally,
we set that back as the document's title.

00:11:11.950 --> 00:11:14.410
One thing you notice here is you
don't have to worry about allocations,

00:11:14.420 --> 00:11:15.850
retain, release, anything.

00:11:16.050 --> 00:11:17.500
The code just falls naturally.

00:11:17.500 --> 00:11:19.830
You don't care where
those objects are going,

00:11:19.840 --> 00:11:20.370
whatever.

00:11:20.510 --> 00:11:23.630
This is, you know, this is a good way to

00:11:23.930 --> 00:11:25.700
And you can also write this
as one line if you want.

00:11:25.820 --> 00:11:27.110
You don't have to worry
about error codes,

00:11:27.180 --> 00:11:27.570
allocation.

00:11:27.620 --> 00:11:29.160
Again, set the title.

00:11:29.160 --> 00:11:32.420
You get the title, you capitalize it,
and you set it back as the title.

00:11:32.580 --> 00:11:34.660
Just one straightforward line.

00:11:35.970 --> 00:11:39.360
Now, this brings us to the issue
of the set title method.

00:11:39.480 --> 00:11:40.810
What should that set title look like?

00:11:40.970 --> 00:11:44.590
I'm going to talk about this a bit
because there are many varieties

00:11:44.590 --> 00:11:47.310
of set methods and different
people do them differently.

00:11:47.490 --> 00:11:51.310
I just want to give you the one true way.

00:11:51.770 --> 00:11:53.700
actually maybe two true ways.

00:11:53.970 --> 00:11:55.610
This is a simple set
method you can write.

00:11:55.740 --> 00:11:59.950
Assuming title is your instance variable,
title is equal to new title.

00:12:00.230 --> 00:12:03.330
However, this assumes that the new title
object will stick around and might

00:12:03.330 --> 00:12:05.120
not be appropriate in all cases.

00:12:05.120 --> 00:12:07.520
Here's another way to do it
which fixes that problem.

00:12:07.520 --> 00:12:09.100
It copies the title.

00:12:09.180 --> 00:12:12.570
This one has the problem that
it leaks the previous title.

00:12:12.620 --> 00:12:16.010
It makes a copy of the incoming one
but never gets rid of the first one,

00:12:16.030 --> 00:12:17.200
the original title.

00:12:17.200 --> 00:12:19.610
So if you call it multiple times,
you will leak.

00:12:19.670 --> 00:12:20.620
Here's another version.

00:12:20.620 --> 00:12:24.000
It releases the previous one and it
makes a copy of the incoming one.

00:12:24.000 --> 00:12:26.450
This one almost works, almost works.

00:12:26.670 --> 00:12:29.770
But if title is equal to new
title because somebody called

00:12:29.850 --> 00:12:33.190
set title with the same title,
it will first release the title

00:12:33.470 --> 00:12:35.160
and it will try to make a copy.

00:12:35.160 --> 00:12:37.340
But in the meantime,
it has been released.

00:12:37.340 --> 00:12:38.820
So this is still not correct.

00:12:38.820 --> 00:12:41.060
You can fix that problem
with this version,

00:12:41.070 --> 00:12:42.080
which does work.

00:12:42.080 --> 00:12:45.540
If the title is not equal to new title,
it releases it, the old one,

00:12:45.540 --> 00:12:47.420
and makes a copy of the new one.

00:12:47.540 --> 00:12:48.460
So this one does work.

00:12:48.540 --> 00:12:50.840
So this is a good set method.

00:12:50.840 --> 00:12:53.220
Here's another good set method.

00:12:53.220 --> 00:12:55.860
Remember earlier we said auto-release?

00:12:55.860 --> 00:12:56.460
We can get rid of it.

00:12:56.580 --> 00:12:59.210
Leave the earlier title but say
get rid of it later and then you

00:12:59.210 --> 00:13:00.740
can make a copy of the new one.

00:13:00.750 --> 00:13:02.790
So even if the new one and
the old one are the same,

00:13:02.790 --> 00:13:05.020
this one works because the
old one is not released.

00:13:05.020 --> 00:13:07.810
So this is another good set method.

00:13:09.080 --> 00:13:12.590
So which one is best,
the release or auto-release?

00:13:12.700 --> 00:13:15.560
Imagine some WWF music here.

00:13:15.660 --> 00:13:17.760
Which one is better?

00:13:19.390 --> 00:13:23.300
Well, the answer depends on what the
get method looks like and what the

00:13:23.300 --> 00:13:25.240
usage pattern of the method is.

00:13:28.120 --> 00:13:29.830
Here's a simple get method.

00:13:29.930 --> 00:13:32.540
You can just return the title,
the instance variable.

00:13:32.690 --> 00:13:33.460
Simple.

00:13:33.550 --> 00:13:35.640
The question is, is it safe?

00:13:36.010 --> 00:13:36.900
Let me give you an example.

00:13:36.900 --> 00:13:39.870
Let's go back to our original
example from earlier,

00:13:39.890 --> 00:13:41.040
change it a bit.

00:13:41.180 --> 00:13:43.730
We get the document's title.

00:13:44.980 --> 00:13:47.140
And then for some reason
we save the document,

00:13:47.330 --> 00:13:51.570
assume that's a document object,
and then for some, another wacky reason,

00:13:51.680 --> 00:13:53.740
we record the string into a log file.

00:13:53.740 --> 00:13:56.400
We say, you know, we saved this file.

00:13:56.530 --> 00:14:00.230
So note that the string we get in
line one we're using in line three.

00:14:00.450 --> 00:14:00.900
That's fine.

00:14:00.900 --> 00:14:04.680
This should work from a client
of this API point of view.

00:14:04.890 --> 00:14:08.560
This is reasonable usage of stuff.

00:14:08.800 --> 00:14:10.210
So the assumption is
that the string is valid,

00:14:10.210 --> 00:14:12.230
but what if the save
operation changes the title?

00:14:12.270 --> 00:14:15.170
Let's say the document was untitled.

00:14:15.520 --> 00:14:19.360
As a result of save,
a save panel was put up and it

00:14:19.460 --> 00:14:21.360
changed the title of the document.

00:14:21.360 --> 00:14:25.510
What if that freed that string that
was returned to you in the first line?

00:14:26.280 --> 00:14:30.160
Here is the get method
and the set method.

00:14:30.160 --> 00:14:33.450
In this case, we just returned the
title and the get method.

00:14:33.670 --> 00:14:36.280
In the set method,
we released the old one.

00:14:36.360 --> 00:14:40.720
Clearly, these two violate the assumption
from that previous slide.

00:14:40.810 --> 00:14:43.610
That's because the string you
get back in that first line,

00:14:43.700 --> 00:14:46.330
the previous slide, will be released by
this title release here,

00:14:46.330 --> 00:14:48.260
if the document's title
happens to change.

00:14:48.360 --> 00:14:51.780
So these two are not a very
good combination of set and get.

00:14:51.800 --> 00:14:56.620
But if you change this first
line to retain auto-release,

00:14:56.700 --> 00:14:58.800
it becomes much safer.

00:14:58.830 --> 00:14:59.900
What's retain auto-release do?

00:14:59.900 --> 00:15:02.600
Well, it basically extends the
lifetime of the object.

00:15:02.600 --> 00:15:05.820
It still maintains balance of
reference counts in the universe,

00:15:05.860 --> 00:15:07.620
because there's plus one, minus one.

00:15:07.620 --> 00:15:09.580
It's just that the
lifetime is extended a bit.

00:15:09.640 --> 00:15:13.400
So if we go back to this slide,
the string you get back in the first

00:15:13.730 --> 00:15:17.200
line will be valid by the third line,
thanks to that.

00:15:17.200 --> 00:15:19.090
Okay, so this is one way to do it.

00:15:19.150 --> 00:15:20.520
Here's another way to do it.

00:15:20.540 --> 00:15:24.800
You can... use our alternate set
method and just return the title.

00:15:24.800 --> 00:15:27.210
This one is safe, too,
because the auto-release method

00:15:27.670 --> 00:15:30.640
in the set method extends
the lifetime of the title,

00:15:30.960 --> 00:15:33.360
and the one in the first
line just returns that one.

00:15:33.460 --> 00:15:34.600
So these two are also fine.

00:15:34.600 --> 00:15:36.630
So the question is, which one is better?

00:15:36.740 --> 00:15:39.640
Again,
we have now a complete get and set.

00:15:39.780 --> 00:15:42.350
Two ways which one is better.

00:15:42.580 --> 00:15:47.160
Well, I think this one is better
if the performance of your

00:15:47.160 --> 00:15:48.320
get methods is important.

00:15:48.570 --> 00:15:50.790
Because here, notice,
the get method just returns

00:15:50.790 --> 00:15:52.180
the instance variable.

00:15:52.250 --> 00:15:53.500
No work done.

00:15:53.560 --> 00:15:53.850
That's it.

00:15:53.950 --> 00:15:56.500
So this one is good if the
performance get is critical.

00:15:56.500 --> 00:15:59.000
This might be appropriate for
low-level objects and so on.

00:15:59.470 --> 00:16:02.890
However, in general,
this is probably the safer one to use.

00:16:02.890 --> 00:16:06.730
And in high-level objects, you know,
we try to use this, like app get objects.

00:16:06.810 --> 00:16:09.980
You know, if you're not getting things
thousands of times a second,

00:16:10.020 --> 00:16:12.480
if you're not setting them a lot,
you know, this is a good one.

00:16:12.500 --> 00:16:14.300
This is a good way to do it.

00:16:14.590 --> 00:16:16.750
One more note about this one
is that it is thread safe

00:16:17.050 --> 00:16:19.050
compared to the previous one.

00:16:19.180 --> 00:16:22.550
In this one,
the return value has a lifetime

00:16:22.830 --> 00:16:24.950
in the thread where it was called.

00:16:25.060 --> 00:16:27.260
Because the order release pool
it's released in isn't the

00:16:27.380 --> 00:16:28.500
thread that was calling it.

00:16:28.500 --> 00:16:31.170
While in the previous one,
you don't have that guarantee.

00:16:31.300 --> 00:16:35.140
So if you want, if you're concerned about
writing thread safe APIs,

00:16:35.140 --> 00:16:38.690
the get method,
this get method happens to be safer.

00:16:39.530 --> 00:16:41.210
Okay,
so we have one more question to answer.

00:16:41.280 --> 00:16:43.360
Do you copy or retain?

00:16:43.570 --> 00:16:46.850
You know,
we've been using copy on our strings.

00:16:46.850 --> 00:16:48.670
Why not retain?

00:16:49.550 --> 00:16:51.140
I mean, the answer might be obvious.

00:16:51.140 --> 00:16:54.700
Copy makes a brand new copy of
the object and retains increments

00:16:54.700 --> 00:16:56.300
reference count on the object.

00:16:56.300 --> 00:16:58.820
You walk into the restaurant,
you see a great table

00:16:58.820 --> 00:17:01.340
with lobsters and shrimp,
cocktail and everything.

00:17:01.510 --> 00:17:03.670
It's wonderful and
there are people there.

00:17:03.840 --> 00:17:04.690
You have two choices.

00:17:04.750 --> 00:17:07.340
You can either go sit at that table,
I mean I might be rude,

00:17:07.340 --> 00:17:08.520
but let's say you can.

00:17:08.640 --> 00:17:11.420
Or you can tell the waiter,
make me a table just like that.

00:17:11.680 --> 00:17:13.280
In the first one you're
referencing another table.

00:17:13.280 --> 00:17:15.010
In the second one you're
getting a brand new copy.

00:17:15.090 --> 00:17:17.660
So what depends on are you
interested in the actual value

00:17:17.670 --> 00:17:21.440
object or are you interested Are you
interested in the actual value?

00:17:21.440 --> 00:17:24.180
Are you interested in
the value of the object?

00:17:25.020 --> 00:17:28.400
And again, let's say you have a method,
the set title, which does a retain,

00:17:28.400 --> 00:17:30.100
like I'm showing here.

00:17:30.100 --> 00:17:31.540
And let's say you have
these five lines of code.

00:17:31.650 --> 00:17:33.040
You create a mutable string.

00:17:33.140 --> 00:17:36.820
You append something to it,
so now the string's value is hello.

00:17:36.920 --> 00:17:39.110
Then you make that the
title of document one.

00:17:39.230 --> 00:17:41.440
Then you append some more
stuff to that string.

00:17:41.540 --> 00:17:44.340
Note that the document retained
the string you gave it,

00:17:44.340 --> 00:17:47.420
so suddenly doc one's title
has changed to hello world,

00:17:47.440 --> 00:17:51.770
which is probably not something
you intended in this code snippet.

00:17:53.800 --> 00:17:57.650
So the right way to do this is to
use copy in something like set title,

00:17:57.650 --> 00:18:00.770
because when a title is
being given to an object,

00:18:00.960 --> 00:18:04.980
the object probably cares
about the value of the string,

00:18:05.090 --> 00:18:07.970
not about the actual string itself.

00:18:08.470 --> 00:18:10.660
Finally, neither copy or no retain.

00:18:10.660 --> 00:18:15.640
Is it OK for set objects to not copy,
you know, or retain, just hang onto it,

00:18:15.730 --> 00:18:16.540
just like this?

00:18:16.540 --> 00:18:18.420
We showed this in the first slide.

00:18:18.420 --> 00:18:22.470
And the answer is yes,
because there are certain relationships

00:18:24.270 --> 00:18:25.460
which don't imply ownership.

00:18:25.600 --> 00:18:26.930
There are examples in Cocoa.

00:18:27.160 --> 00:18:28.040
For instance, NSView.

00:18:28.270 --> 00:18:30.140
NSView has child views.

00:18:30.180 --> 00:18:32.580
NSView has a parent view.

00:18:33.310 --> 00:18:35.790
NSView owns its children
but does not own its parent.

00:18:35.930 --> 00:18:37.600
First of all,
that would cause a circularity.

00:18:37.770 --> 00:18:39.510
And secondly, I mean,
it doesn't make sense from a

00:18:39.510 --> 00:18:40.700
program design point of view.

00:18:40.890 --> 00:18:43.360
When you free a view,
you can imagine the children

00:18:43.360 --> 00:18:45.700
view is going away but not
the parent view going away.

00:18:45.900 --> 00:18:48.440
Similarly,
an NSControl's target is not owned,

00:18:48.440 --> 00:18:51.760
a table view's data source is not owned,
and the delegates of

00:18:51.890 --> 00:18:53.290
objects are not owned.

00:18:53.410 --> 00:18:56.360
These are all assumed to be
relationships between similar

00:18:56.360 --> 00:19:01.100
entity-level objects that,
you know, they don't own each other.

00:19:01.210 --> 00:19:03.800
So it's okay to hold onto an
object without retaining it,

00:19:03.910 --> 00:19:06.250
but you have to obviously take
care when releasing things.

00:19:06.480 --> 00:19:09.030
If you gave somebody a delegate
object and then you're going

00:19:09.030 --> 00:19:11.880
to free the delegate object,
you should tell that first object

00:19:11.880 --> 00:19:16.390
to set the delegate to nil so it
knows not to talk to it anymore.

00:19:24.020 --> 00:19:25.720
Okay,
so a little bit about mutability now,

00:19:25.720 --> 00:19:28.840
because we're talking about copy, retain,
and such.

00:19:28.950 --> 00:19:33.300
Mutability means,
mutable means editable or changeable.

00:19:33.630 --> 00:19:36.270
and some objects are
by nature only mutable.

00:19:36.540 --> 00:19:37.490
The window object.

00:19:37.490 --> 00:19:39.540
You know,
window object is changing all the time.

00:19:39.540 --> 00:19:42.640
It's moved around on the screen,
it's resized, its contents are changing.

00:19:42.640 --> 00:19:43.650
Table view, same way.

00:19:43.710 --> 00:19:48.500
Now other objects, like value objects,
can exist as immutable objects.

00:19:48.620 --> 00:19:50.570
You can imagine a string
which has been freeze-dried.

00:19:50.580 --> 00:19:53.090
You know, its value is hello
world and never changes.

00:19:53.090 --> 00:19:55.040
That's much like constant strings in C.

00:19:55.040 --> 00:19:56.020
Or a color object.

00:19:56.020 --> 00:19:58.550
You can imagine a color
which has certain RGB value,

00:19:58.550 --> 00:20:00.050
and it will never change.

00:20:00.050 --> 00:20:03.450
So it's possible to imagine
these as immutable objects.

00:20:04.560 --> 00:20:07.130
String and mutable
string are two classes,

00:20:07.220 --> 00:20:09.300
which-- immutable and mutable.

00:20:09.380 --> 00:20:11.750
When you're operating on a string,
you would use a method like

00:20:11.750 --> 00:20:13.190
string by appending string.

00:20:13.300 --> 00:20:14.060
Here's a usage.

00:20:14.350 --> 00:20:16.260
You basically append the
string to the first one,

00:20:16.290 --> 00:20:18.120
but you get back a new value,
because the original

00:20:18.200 --> 00:20:19.220
string hasn't changed.

00:20:19.350 --> 00:20:24.910
With a mutable string,
you have a method like append string,

00:20:24.910 --> 00:20:24.910
which actually modifies
the original string.

00:20:25.990 --> 00:20:27.330
Why have immutable objects?

00:20:27.450 --> 00:20:31.840
Seems like you can do everything with
mutable that you can do with immutable.

00:20:31.900 --> 00:20:34.410
Well, one reason is performance.

00:20:35.930 --> 00:20:39.800
Mutable implies that the object
is able to change itself.

00:20:39.890 --> 00:20:41.840
If you have an 18-character
mutable string,

00:20:41.910 --> 00:20:44.430
it has to be prepared to grow, shrink,
etc.

00:20:44.540 --> 00:20:47.530
While an immutable string
of 18 characters can have

00:20:47.530 --> 00:20:50.640
storage for 18 characters,
that's that.

00:20:50.780 --> 00:20:55.480
Another one with performance is
immutable objects can be shared better.

00:20:55.910 --> 00:20:57.760
If you send a copy to
an immutable object,

00:20:57.840 --> 00:21:01.940
it can actually choose to retain,
and you would never know the difference.

00:21:02.780 --> 00:21:04.000
Simpler implementation.

00:21:04.010 --> 00:21:06.420
Obviously, if an object is immutable,
it doesn't have to worry

00:21:06.420 --> 00:21:07.530
about changing itself.

00:21:07.610 --> 00:21:09.160
Its implementation is simpler.

00:21:09.240 --> 00:21:09.690
Thread safety.

00:21:09.700 --> 00:21:12.750
If an object cannot change,
it's thread safe.

00:21:12.750 --> 00:21:14.590
There's probably still
ways where it doesn't,

00:21:14.590 --> 00:21:15.930
but anyway, let's assume it is.

00:21:15.930 --> 00:21:17.340
I mean, it's usually the case.

00:21:17.340 --> 00:21:19.060
Thread safety is hard.

00:21:19.520 --> 00:21:22.010
And also,
easier analysis of program logic

00:21:22.010 --> 00:21:24.100
for somebody using your objects.

00:21:24.300 --> 00:21:27.700
If somebody has an immutable
string in this line,

00:21:27.890 --> 00:21:30.440
and ten lines later they
still have the same string,

00:21:30.660 --> 00:21:32.840
they know that its value
didn't change in the background

00:21:32.840 --> 00:21:34.210
because it couldn't change.

00:21:34.310 --> 00:21:35.380
That's an invariant, you know.

00:21:35.380 --> 00:21:38.090
Immutable strings do not change.

00:21:38.690 --> 00:21:40.520
So when would you use immutable?

00:21:40.580 --> 00:21:43.020
Well, across API boundaries,
like our document object

00:21:43.090 --> 00:21:44.400
had set title and title.

00:21:44.650 --> 00:21:47.310
The arguments are NSStrings,
not mutable strings.

00:21:47.480 --> 00:21:51.430
Similarly in implementations,
the set title method doesn't maintain

00:21:51.430 --> 00:21:53.600
a mutable string whose value changes.

00:21:53.600 --> 00:21:57.560
Instead, it auto releases the previous
title and it copies the new one.

00:21:57.680 --> 00:22:02.260
So there's no mutable strings here ever.

00:22:02.270 --> 00:22:03.110
The strings are just released
and new ones are created.

00:22:03.390 --> 00:22:05.000
When would you use mutable?

00:22:05.110 --> 00:22:08.770
Well, in APIs,
when it's important to expose mutability.

00:22:08.860 --> 00:22:12.380
And in all of Cocoa,
in all of the 250 or so classes

00:22:12.440 --> 00:22:15.380
and the thousands of methods,
there's only one API that

00:22:15.380 --> 00:22:18.860
returns the mutable string --
that returns a mutable string.

00:22:18.960 --> 00:22:20.900
And that one is the backing
store of the text system.

00:22:20.910 --> 00:22:22.840
Clearly,
the backing store of a text object

00:22:22.840 --> 00:22:26.460
can have millions of characters in it,
and you don't want to edit the text

00:22:26.460 --> 00:22:27.970
system by creating new strings.

00:22:27.970 --> 00:22:30.250
You know, here's a million character
string on append A,

00:22:30.250 --> 00:22:31.800
let's create a new string.

00:22:31.880 --> 00:22:33.400
So that's the one place
where it's appropriate,

00:22:33.400 --> 00:22:34.360
and there might be others.

00:22:35.710 --> 00:22:38.320
Mutables are strings or
mutable objects are also very

00:22:38.320 --> 00:22:39.740
appropriate to use in a block.

00:22:39.920 --> 00:22:41.320
You know,
let's say you want to build a string

00:22:41.320 --> 00:22:42.890
up by appending a bunch of stuff to it.

00:22:43.210 --> 00:22:46.060
Well, you don't want to use string by
appending string over and over,

00:22:46.060 --> 00:22:48.360
because you don't care about
those intermediate values.

00:22:48.430 --> 00:22:50.940
You can just use a mutable string,
build it up,

00:22:51.150 --> 00:22:54.790
then after that start treating
it as if it's immutable.

00:22:55.320 --> 00:22:58.760
So that's so much about mutability.

00:22:58.880 --> 00:23:01.180
Now we're going to talk a little
bit about subclassing and,

00:23:01.180 --> 00:23:04.920
as I said earlier,
the dark side of subclassing.

00:23:05.140 --> 00:23:06.800
Subclassing is very powerful.

00:23:06.980 --> 00:23:11.560
It's one of the cornerstones
of object-oriented programming.

00:23:13.990 --> 00:23:16.400
You use it to create ISA relationships.

00:23:16.510 --> 00:23:18.620
Now, in Cocoa,
it's used relatively sparingly.

00:23:18.620 --> 00:23:21.610
I'm not going to say-- I mean,
it's used maybe less than other

00:23:21.610 --> 00:23:23.780
frameworks is what I really mean here.

00:23:23.880 --> 00:23:26.180
In Cocoa,
some classes are meant to be subclassed,

00:23:26.270 --> 00:23:27.870
NSObject, NSView, NSCell.

00:23:27.990 --> 00:23:30.860
These are all abstract
classes that you subclass.

00:23:30.940 --> 00:23:33.140
And other classes can
certainly be subclassed.

00:23:33.350 --> 00:23:36.390
But often or usually,
things are not subclassed.

00:23:36.540 --> 00:23:39.570
For one thing,
when we have classes like NSObject,

00:23:39.570 --> 00:23:43.780
NSView, we've already given you a lot
of interesting subclasses.

00:23:44.190 --> 00:23:50.660
Another, there are other ways to achieve,
to extend Cocoa objects than subclassing,

00:23:50.710 --> 00:23:52.650
and I will talk about those.

00:23:52.750 --> 00:23:56.300
And finally, subclassing just sometimes
tends to be misused,

00:23:56.560 --> 00:23:58.300
abused, just used the wrong way.

00:23:58.310 --> 00:24:00.800
And let's look at examples of that.

00:24:01.000 --> 00:24:04.360
People confuse Hazza
or user relationships.

00:24:04.360 --> 00:24:05.510
Every person has a name.

00:24:05.510 --> 00:24:07.900
Names are represented by NSStrings.

00:24:07.950 --> 00:24:10.480
Why don't we just subclass
NSString to create a person object

00:24:10.480 --> 00:24:11.990
and add a bunch more variables?

00:24:11.990 --> 00:24:16.900
This is nifty because you can do a
person is equal to the string Joe.

00:24:16.900 --> 00:24:18.250
That looks like it would work.

00:24:18.960 --> 00:24:22.160
I mean, although this might be tempting,
this is just bad from an

00:24:22.160 --> 00:24:24.780
object-oriented design.

00:24:24.780 --> 00:24:27.040
And if you started using this
person object in your program,

00:24:27.040 --> 00:24:29.540
pretty soon you'd realize
some of the problems.

00:24:30.510 --> 00:24:32.020
You know, string has a length.

00:24:32.140 --> 00:24:33.610
It returns a number of characters.

00:24:33.920 --> 00:24:35.690
But what does length on person do?

00:24:35.800 --> 00:24:36.570
And I won't even go there.

00:24:36.580 --> 00:24:40.570
But, you know,
so it's... There are these ambiguities.

00:24:41.360 --> 00:24:43.580
Similarly, you can subclass animal
to create a person.

00:24:43.580 --> 00:24:46.900
This might be appropriate in the
context of a taxonomy program,

00:24:47.010 --> 00:24:49.430
but if you're creating a
database of people records,

00:24:49.440 --> 00:24:53.260
if you're creating an address book API,
person should not be subclass of animal.

00:24:53.260 --> 00:24:56.640
There are many things about animals
you won't care about in that context.

00:24:56.750 --> 00:24:58.780
Similarly,
you might think your roommate is a pig,

00:24:58.820 --> 00:25:02.420
but you wouldn't subclass pig
to create a roommate object.

00:25:02.510 --> 00:25:08.200
It's just not the right relationship.

00:25:08.200 --> 00:25:08.200
Sometimes

00:25:08.410 --> 00:25:11.080
People create subclasses where
you probably want attributes

00:25:11.170 --> 00:25:12.790
or parameters instead.

00:25:12.900 --> 00:25:14.830
For instance,
a text field you can type into.

00:25:15.040 --> 00:25:17.750
Often in program flows,
text fields can become editable,

00:25:18.000 --> 00:25:18.660
noneditable.

00:25:18.660 --> 00:25:20.030
I mean, good UIs do this.

00:25:20.030 --> 00:25:22.010
You know, sometimes a text field
should not be edited.

00:25:22.220 --> 00:25:23.520
Sometimes they should be.

00:25:23.610 --> 00:25:25.970
If you had two separate classes
to represent those widgets,

00:25:25.970 --> 00:25:27.980
editable text field,
noneditable text field,

00:25:28.270 --> 00:25:31.230
every time the text field changed status,
you'd have to deallocate

00:25:31.230 --> 00:25:34.890
the previous instance,
create a new instance, and, you know,

00:25:35.010 --> 00:25:36.340
it just gets a little messy.

00:25:36.430 --> 00:25:40.060
So something like this would be
managed better by setEditable

00:25:40.540 --> 00:25:42.320
on the text field object.

00:25:42.350 --> 00:25:44.230
Now let me give you an
example out of Cocoa itself.

00:25:44.230 --> 00:25:46.990
We have a string class,
as I already talked about,

00:25:47.100 --> 00:25:48.590
and we have an attributed string class.

00:25:48.630 --> 00:25:51.940
Many people,
when they first start looking at Cocoa,

00:25:51.950 --> 00:25:55.590
think attributed string
is a subclass of string.

00:25:55.840 --> 00:25:59.160
String is a sequence of characters,
characters and length.

00:25:59.400 --> 00:26:02.590
And an attributed string is
a sequence of characters,

00:26:02.590 --> 00:26:06.200
characters and length,
but also has attributes, text styles.

00:26:06.200 --> 00:26:08.960
And this is why people think
an attributed string is simply

00:26:08.960 --> 00:26:11.640
a string plus a little more.

00:26:11.640 --> 00:26:16.080
Let me give you an example where that
subclassing would just fall apart.

00:26:16.080 --> 00:26:19.150
You have a string,
you have an attributed string.

00:26:19.230 --> 00:26:21.580
Let's say the values are Joe,
and the attributed string

00:26:21.580 --> 00:26:23.760
also happens to be blue.

00:26:26.010 --> 00:26:28.640
If you ask the string,
are you equal to attributed string,

00:26:28.640 --> 00:26:32.740
it will say the characters are Joe,
the length is three, yes, we're equal.

00:26:32.810 --> 00:26:35.400
If you ask the attributed
string the same question,

00:26:35.480 --> 00:26:37.990
it will compare the characters,
the length, but then it will compare

00:26:38.040 --> 00:26:40.540
the color and it will say,
hey, the color of the other string,

00:26:40.540 --> 00:26:43.050
you know, it doesn't have it or
it's black or whatever,

00:26:43.050 --> 00:26:44.090
and it's not equal.

00:26:44.220 --> 00:26:45.970
So you have a situation
where A is equal to B,

00:26:46.250 --> 00:26:48.760
but B is not equal to A,
and that violates all sorts of

00:26:48.860 --> 00:26:52.760
laws of physics and mathematics,
so it's not a good thing to have.

00:26:52.890 --> 00:26:55.720
Another reason why subclassing
attributes from string would be bad is

00:26:55.720 --> 00:26:58.380
due to lack of multiple inheritance,
you know,

00:26:58.380 --> 00:27:00.700
the inheritance tree becomes messier.

00:27:00.720 --> 00:27:02.240
We have string, mutable string.

00:27:02.240 --> 00:27:04.840
We have attributed string and
this mutable attributed string.

00:27:04.840 --> 00:27:06.980
Which one do we subclass?

00:27:10.570 --> 00:27:13.060
Let me talk about some
alternatives to subclassing.

00:27:13.060 --> 00:27:14.990
Categories,
if you were in the intro talk,

00:27:14.990 --> 00:27:16.810
you already heard about this a bit.

00:27:16.860 --> 00:27:22.780
Categories allow additional methods
to be added to other classes.

00:27:23.170 --> 00:27:25.860
and all instances get these new methods.

00:27:25.960 --> 00:27:29.510
So it's not like subclassing where only
your subclass gets these new methods.

00:27:29.510 --> 00:27:33.370
This is a language feature and this
was actually added to Objective-C as a

00:27:33.370 --> 00:27:36.080
way to break apart large source files.

00:27:36.080 --> 00:27:40.300
Who wants to have nswindow.m
that's 100,000 lines long?

00:27:40.300 --> 00:27:43.220
You want to break it up
into multiple source files.

00:27:43.220 --> 00:27:45.850
But categories since then has
been used for more and more stuff

00:27:45.940 --> 00:27:47.540
and it's actually very useful.

00:27:47.610 --> 00:27:49.210
Here's an example of a category.

00:27:49.210 --> 00:27:51.850
As you know,
NSString sits in Foundation Kit,

00:27:51.850 --> 00:27:55.580
which doesn't have any
UI level functionality.

00:27:55.580 --> 00:27:57.590
But if your program
links against App Kit,

00:27:57.590 --> 00:28:00.970
NSString gets a few methods,
one of them for instance drawAtPoint.

00:28:01.080 --> 00:28:04.030
It's because the application
kit knows how to draw strings,

00:28:04.220 --> 00:28:06.640
so it adds this
functionality to NSString.

00:28:06.640 --> 00:28:09.900
And anybody using NSString,
to them it looks like string has

00:28:09.950 --> 00:28:11.780
this functionality out of the box.

00:28:11.900 --> 00:28:13.400
And similarly,
your programs can add other

00:28:13.400 --> 00:28:14.780
functionality to NSString as well.

00:28:14.900 --> 00:28:17.430
And everybody, all the strings in your
program will get this.

00:28:17.680 --> 00:28:21.210
Delegation is another
alternative to subclassing.

00:28:21.250 --> 00:28:23.470
It allows an object to
act on behalf of another.

00:28:23.530 --> 00:28:26.770
It's not a language feature, though,
unlike categories.

00:28:27.430 --> 00:28:30.410
With delegation,
classes explicitly support delegates.

00:28:30.520 --> 00:28:33.280
They have methods like
setDelegate and delegate.

00:28:33.420 --> 00:28:39.710
And this is basically the object that
this object will refer to in some cases.

00:28:42.200 --> 00:28:44.740
In AppKit, NSWindow, for instance,
has a delegate method,

00:28:44.850 --> 00:28:47.540
and it asks this delegate questions like,
window should close.

00:28:47.650 --> 00:28:50.830
When the user hits the close box,
the delegate is asked this question,

00:28:50.840 --> 00:28:53.540
and the delegate can return no
if the document is not saved,

00:28:53.540 --> 00:28:55.450
for instance,
if the delegate was a document.

00:28:55.450 --> 00:28:56.860
Or window will resize.

00:28:56.860 --> 00:29:00.990
Let's say you want window to resize
by increments of 10 or 20 because

00:29:00.990 --> 00:29:03.000
there's some grid in your window.

00:29:03.000 --> 00:29:06.320
The delegate would handle this
by getting the proposed size and

00:29:06.320 --> 00:29:08.420
returning a new size for the window.

00:29:08.420 --> 00:29:11.580
So you don't need the subclass,
you just implement a delegate.

00:29:15.610 --> 00:29:17.690
Notification is another alternative.

00:29:17.800 --> 00:29:21.320
This is sort of like delegation,
except it allows happenings.

00:29:21.360 --> 00:29:22.740
I'm using the word
happening rather than event,

00:29:22.740 --> 00:29:25.630
because I don't want to confuse event,
which is already overloaded.

00:29:25.740 --> 00:29:30.280
It allows happenings to be broadcast
to a set of unrelated observers.

00:29:30.660 --> 00:29:32.760
And there's more than one,
unlike delegates.

00:29:32.780 --> 00:29:36.280
So the observers observe,
but they don't interfere.

00:29:36.280 --> 00:29:37.870
This is also another language feature.

00:29:37.880 --> 00:29:39.800
This class called
NSNotificationCenter can be

00:29:39.800 --> 00:29:43.290
used to use notifications,
and classes declare what

00:29:43.580 --> 00:29:45.120
notifications they post.

00:29:45.430 --> 00:29:48.560
For instance,
NSWindow has a bunch of notifications.

00:29:48.560 --> 00:29:51.980
Two of them are windowDidResize
and windowWillClose.

00:29:51.980 --> 00:29:55.980
These would be sent when the
window is about to close or

00:29:55.980 --> 00:29:58.450
when the window just resized.

00:29:58.510 --> 00:30:02.910
are also usually sent to
the delegates as a courtesy.

00:30:03.880 --> 00:30:06.510
Now, if we were to go back to
our restaurant analogy,

00:30:06.650 --> 00:30:09.820
the waiter knows how to deal
with customers a great deal.

00:30:09.820 --> 00:30:12.850
But if something were to happen,
like the customer finds a fly in their

00:30:12.850 --> 00:30:16.290
soup or they just fall over and die,
the waiter probably wants to go find

00:30:16.460 --> 00:30:19.940
the manager of the restaurant and
let him handle these situations.

00:30:20.840 --> 00:30:23.560
But whenever a customer leaves a table,
the waiter probably

00:30:23.560 --> 00:30:25.650
just goes to the back,
to the busboys or whoever

00:30:25.650 --> 00:30:27.460
cleans the tables,
and says, "Hey,

00:30:27.560 --> 00:30:30.340
table 17 opened up." And that's
more like a notification,

00:30:30.670 --> 00:30:33.840
because one of the busboys will come and
clean it up and the waiter doesn't care.

00:30:33.840 --> 00:30:38.100
He just announced that
table 17 just cleared up.

00:30:38.920 --> 00:30:42.360
Okay, so instead of subclassing,
when you're looking at a Cocoa object,

00:30:42.360 --> 00:30:45.320
see if the class has the delegate
methods or notifications that

00:30:45.430 --> 00:30:47.240
you can use and use them instead.

00:30:47.390 --> 00:30:51.920
Or see if you can add a category method
on the class to achieve the same results.

00:30:52.030 --> 00:30:55.000
Now category methods, as I said,
will give the same functionality

00:30:55.000 --> 00:30:58.000
to all your objects,
and maybe that's not something you want.

00:30:58.180 --> 00:31:02.280
But anyway, often category methods will
actually get you what you want.

00:31:02.550 --> 00:31:05.550
And what do you do if you must subclass?

00:31:05.580 --> 00:31:09.310
Now let's talk about this situation.

00:31:11.460 --> 00:31:12.700
Well, the answer is simple.

00:31:12.760 --> 00:31:15.420
You just subclass.

00:31:15.480 --> 00:31:17.130
Unlike other languages,
which have the ability

00:31:17.200 --> 00:31:19.450
to prevent subclassing,
in Cocoa,

00:31:19.450 --> 00:31:24.050
there's no final keyword or anything,
and you can subclass any object.

00:31:24.170 --> 00:31:27.400
And sometimes people subclass
the weirdest objects that we

00:31:27.400 --> 00:31:30.930
never thought you would have to,
because there was a bug in it,

00:31:31.090 --> 00:31:33.040
in the implementation, whatever.

00:31:33.040 --> 00:31:34.240
So just subclass.

00:31:34.330 --> 00:31:36.800
Of course, when you're subclassing,

00:31:37.160 --> 00:31:39.350
You know, know what the primitives are,
know what the designated

00:31:39.360 --> 00:31:40.160
initializers are.

00:31:40.160 --> 00:31:42.220
Now, designated initializers,
I'm not going to talk about it,

00:31:42.320 --> 00:31:45.520
but it's basically the
primitives for creation.

00:31:45.620 --> 00:31:47.850
And the one more interesting thing
you need to know about is whether

00:31:47.920 --> 00:31:49.100
the class is a class cluster.

00:31:49.100 --> 00:31:51.390
And this is some,
this is an area which trips

00:31:51.390 --> 00:31:52.910
new Cocoa programmers up.

00:31:53.670 --> 00:31:55.400
So I'll talk about it.

00:31:57.350 --> 00:32:00.580
I'll talk about NSString and
how it looked a few years ago.

00:32:00.600 --> 00:32:03.050
Well, it didn't look like this.

00:32:03.050 --> 00:32:04.730
It actually looked like this.

00:32:06.690 --> 00:32:08.560
And of course,
this was a nightmare if we--

00:32:08.560 --> 00:32:10.290
this is what we revealed to you.

00:32:10.590 --> 00:32:14.340
This would be a nightmare both to you and
it would be a nightmare to our TechPubs

00:32:14.560 --> 00:32:16.330
folks who have to write about this.

00:32:16.400 --> 00:32:19.430
So suddenly they have to, you know,
document this many classes.

00:32:19.530 --> 00:32:21.720
These are all different implementation
classes that know how to deal

00:32:21.840 --> 00:32:23.190
with different kinds of strings.

00:32:23.620 --> 00:32:25.660
Luckily,
we decided to make most of this private.

00:32:25.770 --> 00:32:28.220
So all you saw was an
NSString and an NSMutableString.

00:32:28.220 --> 00:32:30.620
And it was a good thing too,
because recently we changed this

00:32:30.740 --> 00:32:31.810
hierarchy to look like that.

00:32:31.900 --> 00:32:33.870
Clearly if we had to
expose all those classes,

00:32:33.870 --> 00:32:37.220
we'd have to be schlepping them around in
the frameworks because there'd be people

00:32:37.220 --> 00:32:38.780
using them for some reason or another.

00:32:40.960 --> 00:32:43.140
The idea here is that
with class clusters,

00:32:43.140 --> 00:32:45.100
there's a collection of classes.

00:32:45.100 --> 00:32:47.640
These are implementation classes,
but they're hidden by

00:32:47.640 --> 00:32:50.170
an abstract superclass.

00:32:50.540 --> 00:32:52.070
And you don't see the
implementation classes,

00:32:52.070 --> 00:32:53.970
because abstract class
manages them for you.

00:32:53.980 --> 00:32:56.000
It returns the right subclass.

00:32:56.110 --> 00:32:59.180
One problem here is that
these implementation classes

00:32:59.180 --> 00:33:00.630
are not available to you.

00:33:00.630 --> 00:33:04.220
So if you want a subclass NSString,
you usually have to provide

00:33:04.220 --> 00:33:07.520
your own implementation,
because NSString is abstract.

00:33:07.520 --> 00:33:10.250
And the primitives need to be
clearly defined for you to do this,

00:33:10.250 --> 00:33:11.880
because there is no implementation.

00:33:11.930 --> 00:33:13.950
This is not like NSView or NSWindow,
you know,

00:33:13.950 --> 00:33:18.070
which is either semi-abstract or,
in the case of Window, fairly abstract,

00:33:18.070 --> 00:33:19.740
fairly concrete class.

00:33:21.100 --> 00:34:32.900
[Transcript missing]

00:34:33.790 --> 00:34:34.830
Okay.

00:34:34.850 --> 00:34:39.520
So, so much for subclassing
and class clusters,

00:34:39.520 --> 00:34:39.520
and, uh,

00:34:39.780 --> 00:34:43.400
Now I want to talk a little
bit about plug-in design.

00:34:43.520 --> 00:34:46.930
We were actually going to have a
whole talk about plug-in design,

00:34:46.970 --> 00:34:50.500
and then we decided that plug-in
design in Cocoa is way too easy,

00:34:50.500 --> 00:34:52.570
and a whole talk just wouldn't be right.

00:34:52.590 --> 00:34:55.560
So we decided just to
have a few slides on it.

00:35:01.190 --> 00:35:04.000
In Cocoa, when you're designing plug-ins,
you want to package your

00:35:04.000 --> 00:35:04.990
plug-in as a bundle.

00:35:04.990 --> 00:35:06.830
And you already probably
know what bundles are.

00:35:06.960 --> 00:35:12.220
They're those folders that look
like single files in Finder.

00:35:12.330 --> 00:35:15.430
And you would use the
NSBundle class to load it.

00:35:15.560 --> 00:35:17.890
And typically you'd put objects,
your own classes in there to

00:35:17.970 --> 00:35:21.140
do various interesting things,
and you would get the main

00:35:21.260 --> 00:35:24.940
class with principal class,
and you'd expose the entry

00:35:24.940 --> 00:35:26.830
points via this principal class.

00:35:26.990 --> 00:35:28.790
And that's all it really takes.

00:35:28.850 --> 00:35:32.900
And I'm going to try to show a
demo to see how easy this is.

00:35:35.660 --> 00:35:38.470
So exposing entry points,
there are two ways to do it.

00:35:38.520 --> 00:35:40.800
There are actually multiple ways,
but two, you know,

00:35:40.940 --> 00:35:42.160
two ways I'll talk about.

00:35:42.270 --> 00:35:44.480
One is you have a superclass
meant to be overridden.

00:35:44.480 --> 00:35:48.520
And in fact the various bundles,
the various plug-ins that we provide

00:35:48.600 --> 00:35:50.880
in the system use this technique.

00:35:50.880 --> 00:35:53.980
You would supply the superclass
implementation often in the framework.

00:35:54.160 --> 00:35:56.500
For instance,
the screensaver bundles for our

00:35:56.500 --> 00:36:01.280
screensaver engine are subclasses of
this object called screensaver view.

00:36:01.280 --> 00:36:04.950
You just subclass that and provide
your own custom screensaver.

00:36:04.980 --> 00:36:07.880
Preference panes are subclasses of
this object called NS preference pane.

00:36:07.880 --> 00:36:10.920
Again, you subclass that and do
custom preference panes.

00:36:10.920 --> 00:36:13.780
And these are available on the
system if you wish to create,

00:36:13.810 --> 00:36:15.560
you know, plug-ins for these.

00:36:15.560 --> 00:36:19.690
Another technique is to use the
object -- use an Objective-C protocol.

00:36:20.170 --> 00:36:23.520
Protocols gather methods together
with no implied class hierarchy.

00:36:23.590 --> 00:36:26.220
So there are a bunch of
methods and that's it.

00:36:26.270 --> 00:36:30.600
And a class which conforms to the
protocol must implement all the methods.

00:36:30.600 --> 00:36:32.280
And there's no base
implementation needed.

00:36:32.280 --> 00:36:36.370
So you can just say plug-ins, you know,
for my application should just implement

00:36:36.370 --> 00:36:37.680
these eight methods and that's it.

00:36:37.870 --> 00:36:39.610
And you don't care how they implement it.

00:36:39.660 --> 00:36:42.150
They can be subclass of an object,
they can be whatever.

00:36:42.280 --> 00:36:43.520
You don't care.

00:36:43.590 --> 00:36:46.640
Here's just a simple, you know,
sample plug-in.

00:36:46.640 --> 00:36:48.370
For instance,
you might have an image processing

00:36:48.370 --> 00:36:51.960
plug-in which has the three methods,
process image, can process image,

00:36:52.140 --> 00:36:53.510
and description.

00:36:53.510 --> 00:36:54.970
And that's that.

00:36:55.750 --> 00:36:57.800
Okay, at this point,
I have a little bit of time,

00:36:57.800 --> 00:37:00.260
so I will show you a
demo of how to do this.

00:37:00.270 --> 00:37:02.650
Just show you, do it on the,
on the fly here and

00:37:02.650 --> 00:37:03.670
let's see if it works.

00:37:03.760 --> 00:37:07.660
Can we switch to this demo machine,
please?

00:37:12.350 --> 00:37:13.750
Most of you probably know TextEdit.

00:37:13.950 --> 00:37:16.870
This is a pure Jaguar system here.

00:37:16.980 --> 00:37:18.890
And here's TextEdit.

00:37:23.180 --> 00:37:25.970
So what I'm going to do is I'm going
to add a plug-in model to TextEdit

00:37:26.140 --> 00:37:28.980
and write a plug-in for TextEdit.

00:37:39.220 --> 00:37:41.700
Here is TextEdit's controller.

00:37:41.820 --> 00:37:45.160
And I'm going to add the plug-in
model initialization here.

00:37:45.300 --> 00:37:48.720
Now, as I said,
one way you do plug-ins is to

00:37:48.840 --> 00:37:51.800
define a protocol that you expect
your plug-ins to implement.

00:37:51.940 --> 00:37:53.790
And I'm first going to do that piece.

00:37:53.910 --> 00:37:57.270
And I'm going to be using the demo
assistant to do my typing here.

00:38:01.590 --> 00:38:03.800
So there's the protocol
I want to implement.

00:38:03.920 --> 00:38:04.860
Notice it's very simple.

00:38:04.860 --> 00:38:06.820
All it has is prepare with menu.

00:38:06.940 --> 00:38:08.360
That's because I'm going
to tell my plug-in,

00:38:08.670 --> 00:38:11.000
here's the menu you should
insert your stuff into,

00:38:11.000 --> 00:38:12.070
and that's it.

00:38:12.070 --> 00:38:13.540
You're on your own.

00:38:13.660 --> 00:38:17.980
The next thing I'm going to do is
enumerate the plug-ins that I have.

00:38:18.090 --> 00:38:21.010
And to do that,
I'm going to write a new method here.

00:38:21.710 --> 00:38:23.700
load plug-ins.

00:38:23.780 --> 00:38:26.000
And this is really the
meat of the whole thing.

00:38:26.140 --> 00:38:27.600
First of all,
I'm going to have a plug-in menu,

00:38:27.600 --> 00:38:28.260
which is nil.

00:38:28.370 --> 00:38:31.930
Then I'm going to look
at my plug-ins folder,

00:38:32.230 --> 00:38:34.730
You can choose to load plug-ins
from any place you want.

00:38:34.810 --> 00:38:38.420
You can either load them from standard
places like libraries/texas plug-ins.

00:38:38.420 --> 00:38:39.880
You can load them from the system.

00:38:40.050 --> 00:38:43.290
In this case,
I'm going to load it from inside the app.

00:38:43.420 --> 00:38:49.090
is a developer of the Cloud Platform and
is the founder of the Cloud Platform.

00:38:49.090 --> 00:38:49.090
He is the

00:38:50.800 --> 00:38:54.560
I'm going to get an array back which
enumerates the contents of that folder.

00:38:54.590 --> 00:38:57.130
I'm going to look at the count of that.

00:38:59.800 --> 00:39:01.110
and I'm just going to start enumerating.

00:39:01.260 --> 00:39:03.300
Note that if there was
nothing in that folder,

00:39:03.540 --> 00:39:06.140
the count was zero,
this while loop just exits.

00:39:06.190 --> 00:39:07.270
I'm going to get the path.

00:39:07.510 --> 00:39:09.440
So now I'm going through all the bundles.

00:39:09.440 --> 00:39:12.650
I'm going to get the path to each one,
and I'm going to create a bundle with it.

00:39:12.650 --> 00:39:16.150
Note that this might fail,
in which case I don't do anything there.

00:39:16.270 --> 00:39:22.990
But this line here basically creates
an NSBundle object for that plug-in.

00:39:23.840 --> 00:39:27.800
If I did get a plug-in,
then I create an instance

00:39:27.800 --> 00:39:29.200
of the principal class.

00:39:29.300 --> 00:39:32.580
Note, this is the way,
this is how we're using the protocol.

00:39:32.620 --> 00:39:34.530
We're saying that this
is a class of any object,

00:39:34.610 --> 00:39:37.520
I don't care,
but it must implement the protocol.

00:39:37.650 --> 00:39:40.020
And we get the principal
class of the bundle,

00:39:40.020 --> 00:39:42.510
we alloc an instance,
and we initialize it.

00:39:42.670 --> 00:39:43.310
Pretty straightforward.

00:39:43.450 --> 00:39:45.420
Now one more thing we need to
do at this point is because

00:39:45.420 --> 00:39:50.150
we know we have a plug-in,
we should build our plug-in menu.

00:39:50.360 --> 00:39:53.740
If our plug-in menu was nil,
we create a menu and we

00:39:53.740 --> 00:39:55.600
add it to our application.

00:39:55.720 --> 00:39:57.040
And there are several ways to do this.

00:39:57.040 --> 00:39:58.640
You can choose to always
have a plug-in menu,

00:39:58.640 --> 00:40:00.570
which is empty,
or you can choose to create

00:40:00.660 --> 00:40:02.560
this in interface builder
and have an outlet to it,

00:40:02.560 --> 00:40:04.140
or you can choose to do it in code here.

00:40:04.270 --> 00:40:06.690
And just to show you the code here,
I did it here.

00:40:06.850 --> 00:40:09.420
This basically creates a plug-in menu,
adds it to the menu

00:40:09.420 --> 00:40:10.760
bar of the application.

00:40:10.900 --> 00:40:15.030
And the next thing we do is we tell
that object from this line here,

00:40:15.700 --> 00:40:19.670
is the first to prepare itself
with that plug-in menu we just did.

00:40:19.830 --> 00:40:24.080
And note that this will loop through
all the plug-ins in that directory,

00:40:24.200 --> 00:40:25.550
and that's really it.

00:40:25.790 --> 00:40:29.780
And the last thing I need to do is,
when the application is launched,

00:40:29.780 --> 00:40:31.450
go find all its plug-ins.

00:40:31.450 --> 00:40:33.710
So let me build and run this.

00:40:37.420 --> 00:40:38.460
So here's TextEdit.

00:40:38.540 --> 00:40:40.320
One thing you'll notice,
there's no plug-in menu.

00:40:40.500 --> 00:40:42.600
That's because we don't
have any plug-ins yet.

00:40:42.600 --> 00:40:43.700
Let me quit.

00:40:43.780 --> 00:40:45.340
And let me miniaturize this.

00:40:45.440 --> 00:40:48.690
So now to create a plug-in,

00:40:52.110 --> 00:40:54.420
And I'm going to create
a plug-in from scratch.

00:40:54.520 --> 00:40:58.700
You create a Cocoa bundle.

00:40:58.700 --> 00:41:01.370
And look, the name

00:41:02.120 --> 00:41:03.600
And I'm going to call it enlarge.

00:41:03.720 --> 00:41:07.600
Somehow I knew from some previous run.

00:41:07.900 --> 00:41:08.660
This is interesting.

00:41:08.660 --> 00:41:12.100
I will actually, because I want to start
this from scratch,

00:41:12.150 --> 00:41:15.130
let me quit PB and do this.

00:41:16.820 --> 00:41:24.540
Okay, new project, new Cocoa bundle,
and I'm going to put it onto the desktop.

00:41:24.540 --> 00:41:28.510
And I'm going to call it enlarge.

00:41:32.320 --> 00:41:37.440
And by default, plug-ins have just the
main.c and not much more.

00:41:37.460 --> 00:41:39.640
I'm going to create
two little files here,

00:41:39.640 --> 00:41:42.780
Objective-C, class, and the header file.

00:41:43.060 --> 00:41:45.350
I'm going to call it enlarge.

00:41:47.820 --> 00:41:52.050
Now the first thing is enlarge.h,
the interface file.

00:41:52.270 --> 00:41:54.970
Here what I want to do is I want
to basically tell this thing

00:41:55.030 --> 00:41:56.740
that it implements that protocol.

00:41:56.890 --> 00:42:00.920
So I'm going to import Cocoa.h,
because I want to use more of

00:42:00.920 --> 00:42:02.780
Cocoa than just foundation.

00:42:02.870 --> 00:42:05.820
Then I'm going to put the
protocol here as well.

00:42:06.110 --> 00:42:10.230
Typically in a real project you might
have the protocol in a shared header

00:42:10.230 --> 00:42:13.870
file as opposed to duplicating it here,
but for the sake of demo

00:42:14.000 --> 00:42:15.580
I'm going to do it here.

00:42:15.580 --> 00:42:16.400
And finally, you would go ahead

00:42:17.210 --> 00:42:19.400
and declare that the object
implements this protocol.

00:42:19.560 --> 00:42:20.970
So that's it for the header file.

00:42:21.140 --> 00:42:21.990
Let me save this.

00:42:22.100 --> 00:42:25.760
Let me switch to my interface file.

00:42:25.820 --> 00:42:27.860
And let me put,
to my implementation file,

00:42:27.860 --> 00:42:30.660
and let me put some
implementation for enlarge.

00:42:30.700 --> 00:42:33.290
This turns out to be fairly easy.

00:42:34.870 --> 00:42:36.380
We implement prepare with menu.

00:42:36.400 --> 00:42:37.660
That's all we have to do.

00:42:37.740 --> 00:42:41.240
And all we do is add to that menu
the menu item for this plug-in.

00:42:41.350 --> 00:42:44.490
In this case, the title is enlarge.

00:42:44.690 --> 00:42:45.790
We even localize it.

00:42:45.800 --> 00:42:50.140
The selector it calls is enlarge colon,
and there's no key colon,

00:42:50.140 --> 00:42:51.800
and this is the target.

00:42:51.800 --> 00:42:54.970
That's all we have to do
to implement our plug-in,

00:42:54.970 --> 00:42:57.510
and we return yes to say we succeeded.

00:42:57.640 --> 00:43:00.010
And then we implement enlarge.

00:43:00.540 --> 00:43:02.290
And that's all the code
required for Enlarge.

00:43:02.340 --> 00:43:04.700
Let me push that to
the top of the screen.

00:43:04.850 --> 00:43:07.820
The goal here is,
what Enlarge does here is it just looks

00:43:07.870 --> 00:43:12.280
at the main document in the app and
then it grows the font to 36 points.

00:43:12.430 --> 00:43:12.960
That's it.

00:43:13.120 --> 00:43:14.140
And this is the whole plug-in.

00:43:14.240 --> 00:43:15.290
No other code is needed.

00:43:15.640 --> 00:43:16.860
So let's save.

00:43:17.000 --> 00:43:18.700
Let's build.

00:43:20.840 --> 00:43:22.080
That's done.

00:43:22.150 --> 00:43:25.550
Let's hide this.

00:43:25.590 --> 00:43:27.790
So here's our text edit and
here's the bundle we just built.

00:43:27.800 --> 00:43:32.530
I'm going to open text edit,
package contents.

00:43:32.580 --> 00:43:35.280
I'm going to go into its contents
folder and I'm going to create a

00:43:35.320 --> 00:43:37.070
new folder here called plug-ins.

00:43:37.170 --> 00:43:40.360
This is the standard plug-ins
location for an application.

00:43:40.370 --> 00:43:42.670
And Finder also knows how to manage this,
by the way.

00:43:42.670 --> 00:43:44.530
There are menu items
in Finder to do this.

00:43:44.630 --> 00:43:47.830
I'm going to create my bundle into this.

00:43:47.830 --> 00:43:49.080
I'm going to copy my bundle in here.

00:43:50.750 --> 00:43:53.760
Okay, and let's run TextEdit again.

00:43:53.810 --> 00:43:54.300
There you go.

00:43:54.340 --> 00:43:57.090
It's got a menu item, so I can type.

00:43:59.800 --> 00:44:02.740
And if I go to my plug-in and use it,
it just enlarges.

00:44:02.890 --> 00:44:03.240
There you go.

00:44:03.240 --> 00:44:06.320
We've just added a
plug-in model to TechSend.

00:44:12.510 --> 00:44:16.260
And in case I want another plug-in,
let's see,

00:44:16.260 --> 00:44:18.960
here is one I had created earlier.

00:44:19.030 --> 00:44:21.860
This one is slightly more sophisticated.

00:44:21.920 --> 00:44:23.620
It allows you to go to any line you want.

00:44:23.640 --> 00:44:25.700
I'm going to copy that plug-in here.

00:44:25.710 --> 00:44:28.110
Let's run TextEdit again.

00:44:28.190 --> 00:44:28.950
There's go to line.

00:44:29.100 --> 00:44:33.330
So if I type some text, line one,
line two, line three, line four,

00:44:33.330 --> 00:44:36.910
let's take advantage
of our enlarge plug-in.

00:44:37.410 --> 00:44:39.110
Then let's say go to line.

00:44:39.110 --> 00:44:42.000
A go to line panel pops up,
which is part of this plug-in.

00:44:42.000 --> 00:44:44.620
I'm going to type three,
and it goes to line three.

00:44:44.820 --> 00:44:47.960
And again, the possibilities of
plug-ins are endless here.

00:44:48.070 --> 00:44:52.900
The go to line plug-in ends up
being not much more complicated.

00:44:52.900 --> 00:44:55.300
It again has a prepare with menu.

00:44:55.300 --> 00:44:59.870
But because it has a panel,
it connects it to show UI.

00:45:00.020 --> 00:45:03.730
Show UI simply loads a Nib file,
and it puts up a panel that

00:45:03.730 --> 00:45:05.700
comes from that Nib file.

00:45:05.700 --> 00:45:08.560
And the go to line
implementation is here.

00:45:08.760 --> 00:45:15.700
takes advantage of finding lines in the
string to simply go to the desired line.

00:45:15.790 --> 00:45:17.870
Okay, that's it for the demo.

00:45:17.870 --> 00:45:18.370
Thank you.

00:45:24.890 --> 00:45:27.900
One performance tip in plug-ins.

00:45:27.980 --> 00:45:31.410
What I did there was probably not very
good from a performance point of view,

00:45:31.550 --> 00:45:35.800
because we non-lazily
loaded all the plug-ins.

00:45:36.480 --> 00:45:38.790
You know, we went ahead,
we looked at all the plugins,

00:45:38.790 --> 00:45:41.930
we created instances of them,
we added them to the menu all at startup.

00:45:41.950 --> 00:45:44.640
If you had 30, 40 plugins,
it would seriously impact

00:45:44.640 --> 00:45:45.900
TechSense's launch time.

00:45:45.900 --> 00:45:48.500
So typically what you should do
is try to make it so that the

00:45:48.630 --> 00:45:51.000
plugins are not all loaded at once.

00:45:51.000 --> 00:45:54.470
One way to do that is to
provide the information for

00:45:54.580 --> 00:45:56.100
the plugin in its Info.plist.

00:45:56.130 --> 00:45:59.190
For instance, in this case,
all we really need to know about the

00:45:59.310 --> 00:46:00.870
plugin was what to put in the menu.

00:46:00.870 --> 00:46:03.120
So maybe that can be
put in your Info.plist.

00:46:03.120 --> 00:46:07.160
And only when that menu is tickled
would you go load the plugin.

00:46:07.160 --> 00:46:08.420
You can also put in some other file.

00:46:08.430 --> 00:46:10.720
If you have more initialization,
you might just want to put

00:46:10.720 --> 00:46:14.280
in another file in the bundle
rather than the Info.plist.

00:46:14.280 --> 00:46:17.030
This allows you to load the bundle
and execute the code lazily.

00:46:17.140 --> 00:46:18.610
And then, you know,
you can have hundreds of

00:46:18.610 --> 00:46:22.470
bundles and the launch time
will probably not be impacted.

00:46:23.340 --> 00:46:25.100
So talking about performance,
let's talk a bit about

00:46:25.220 --> 00:46:26.590
performance of APIs.

00:46:26.780 --> 00:46:29.440
Oh, my water is there.

00:46:30.890 --> 00:46:34.570
So, performance of APIs.

00:46:34.570 --> 00:46:39.560
Here is an earth-shattering fact:
as fast as possible, that's good.

00:46:41.570 --> 00:46:46.100
There happens to be many
conflicting constraints.

00:46:46.150 --> 00:46:48.000
Do you reduce memory usage?

00:46:48.080 --> 00:46:49.360
Do you optimize for CPU usage?

00:46:49.420 --> 00:46:50.930
Do you try to find a middle road?

00:46:51.030 --> 00:46:54.120
You know,
it's hard to optimize everything at once.

00:46:54.130 --> 00:46:58.100
So in APIs, it's interesting to indicate
what the performance

00:46:58.210 --> 00:47:01.180
characteristics of the APIs are.

00:47:01.180 --> 00:47:02.670
And there are, you know,
several ways to do this.

00:47:02.690 --> 00:47:04.450
Now,
one thing you can go ahead and say is,

00:47:04.450 --> 00:47:06.410
20 nanoseconds per probe.

00:47:06.410 --> 00:47:10.040
You know, I can do object at
index in 20 nanoseconds.

00:47:10.040 --> 00:47:14.010
Well, that's interesting,
but it doesn't give the whole story.

00:47:14.890 --> 00:47:19.410
Behavior over a range of input parameters
happens to be also interesting,

00:47:19.470 --> 00:47:22.360
and sometimes it's in
fact more interesting.

00:47:22.430 --> 00:47:25.700
Let me give you an example
back to our restaurant.

00:47:25.860 --> 00:47:29.390
You go into the restaurant, you sit down,
you order a pizza.

00:47:29.520 --> 00:47:31.320
It comes in 15 minutes.

00:47:31.520 --> 00:47:32.300
That's good.

00:47:32.390 --> 00:47:34.470
What if 20 people came
into the restaurant,

00:47:34.470 --> 00:47:36.900
sat at all the tables,
and they all ordered pizza?

00:47:36.990 --> 00:47:39.080
Well, the kitchen might have a
harder time dealing with that.

00:47:39.140 --> 00:47:41.560
Maybe they only have three
pizza chefs or whatever.

00:47:41.560 --> 00:47:44.670
So it might take longer than 15
minutes for people to get their pizza,

00:47:45.000 --> 00:47:46.910
as people are scrambling.

00:47:47.030 --> 00:47:48.020
And here's another case.

00:47:48.240 --> 00:47:51.370
You go into the restaurant,
and you want to play a prank

00:47:51.490 --> 00:47:55.120
on your fraternity buddies,
and you order 10,000 pizzas.

00:47:55.250 --> 00:47:57.920
Well, the kitchen is certainly
not prepared for that.

00:47:58.040 --> 00:48:01.220
And what's going to start happening
is people are scrambling back there.

00:48:01.220 --> 00:48:02.260
There are going to be pizzas everywhere.

00:48:02.260 --> 00:48:05.230
They're going to start swapping the
pizzas in and out of the sidewalk,

00:48:05.370 --> 00:48:07.250
bathrooms, wherever they can put them.

00:48:07.340 --> 00:48:09.860
The waiter is going to be
running in and out with pizzas.

00:48:09.950 --> 00:48:12.960
And as a result,
the waiter might turn into

00:48:12.960 --> 00:48:14.720
a big spinning pizza pie.

00:48:14.860 --> 00:48:17.830
And in fact,
that's where the weight cursor came from.

00:48:18.520 --> 00:48:22.790
Anyway,
the point here is that just because

00:48:22.910 --> 00:48:27.240
something takes a certain amount of
time under different stress conditions,

00:48:27.240 --> 00:48:31.000
it's not clear how long it will take.

00:48:31.340 --> 00:48:36.050
And this point here,
behavioral range of input parameters,

00:48:36.050 --> 00:48:38.700
is interesting for level of
objects such as NSArrays,

00:48:38.810 --> 00:48:41.620
NSStrings,
and the kind we provide in Foundation.

00:48:41.620 --> 00:48:44.240
Let me talk about
NSArray as a case study.

00:48:44.240 --> 00:48:49.170
The following APIs in an SRA,
for instance count, object at index,

00:48:49.170 --> 00:48:50.210
add object.

00:48:50.300 --> 00:48:54.370
We expect these APIs to
execute in constant time.

00:48:54.440 --> 00:48:58.120
We don't expect them to be dependent
on the number of objects in the array.

00:48:58.120 --> 00:49:00.860
When the array has ten
objects and you ask count,

00:49:00.930 --> 00:49:04.990
the time to return the results shouldn't
change over that ten million objects.

00:49:05.090 --> 00:49:08.360
And the same is true usually for
object at index and add object as well.

00:49:08.360 --> 00:49:12.250
Now, note that add object adds
object to the end of an array.

00:49:12.500 --> 00:49:14.840
Now, that's not true for
all methods in NSArray.

00:49:14.940 --> 00:49:17.480
If you were to insert an object
in the middle of an array,

00:49:17.530 --> 00:49:20.050
we often say that
that's going to be slow.

00:49:20.160 --> 00:49:22.940
Or it's going to not be necessarily slow,
but it's going to be depending on

00:49:22.940 --> 00:49:24.560
the number of objects in the array.

00:49:24.690 --> 00:49:27.920
Because if you had 10 million objects
and you insert an object in the middle,

00:49:27.920 --> 00:49:31.210
it might have to push, you know,
5 million objects this way

00:49:31.300 --> 00:49:32.670
or that way to make room.

00:49:34.810 --> 00:49:38.080
Now that's because we're telling
you that NSArray is not a linked

00:49:38.080 --> 00:49:40.660
list or it doesn't have some
other weird implementation.

00:49:40.720 --> 00:49:43.720
It's more like a C style array.

00:49:44.220 --> 00:49:48.260
And if you do create a linked list,
do not make it a subclass of array

00:49:48.260 --> 00:49:52.870
because it has different fundamental
performance considerations.

00:49:52.990 --> 00:49:55.100
Make it a linked list class
that's not related to an SRA.

00:49:55.100 --> 00:49:59.060
You can give it a similar API,
but don't call it an SRA.

00:49:59.130 --> 00:50:02.920
One question you might have here is
aren't you giving away implementation

00:50:02.920 --> 00:50:06.900
details here and isn't object-oriented
programming supposed to hide this?

00:50:07.110 --> 00:50:10.500
The answer is yes,
but in low-level APIs where

00:50:10.500 --> 00:50:13.630
performance is important and
clients will depend on you,

00:50:13.680 --> 00:50:15.830
clients will build subsystems
that use these a lot,

00:50:15.830 --> 00:50:19.300
the performance becomes even a
more important consideration.

00:50:19.320 --> 00:50:23.280
NSDictionary is another good case study.

00:50:23.450 --> 00:50:25.720
NSDictionary,
for those of you who don't know,

00:50:25.780 --> 00:50:27.100
it stores key value pairs.

00:50:27.100 --> 00:50:28.270
It hashes them.

00:50:28.300 --> 00:50:32.980
So it's like maps, for instance,
color to blue, font to Helvetica.

00:50:32.980 --> 00:50:34.290
There's a key and a value.

00:50:34.690 --> 00:50:37.730
And it uses hashing to store this.

00:50:38.130 --> 00:50:41.690
So what this means is in NSDictionary,
the following methods often

00:50:41.690 --> 00:50:43.470
execute in constant time.

00:50:43.670 --> 00:50:44.440
Object for key.

00:50:44.440 --> 00:50:46.300
No matter how many objects
you have in the dictionary,

00:50:46.300 --> 00:50:48.060
it will return in constant time.

00:50:48.210 --> 00:50:51.730
Similarly, set object for key,
or even remove object for key,

00:50:51.730 --> 00:50:54.800
are usually expected to
execute in constant time.

00:50:54.920 --> 00:50:58.180
However,
NSDictionary relies on the following

00:50:58.280 --> 00:51:00.900
NSObject methods to do its thing.

00:51:01.010 --> 00:51:05.830
It calls isEqual and it calls hash on
the objects that are in the dictionary.

00:51:06.520 --> 00:51:09.710
And these can be
overridden by subclasses.

00:51:09.730 --> 00:51:13.480
So depending on the overrides, you know,
NSDictionary's performance

00:51:13.540 --> 00:51:15.390
can change a great deal.

00:51:15.500 --> 00:51:18.730
Similarly, and the goodness of the hash
function also has a big impact

00:51:18.730 --> 00:51:20.400
on NSDictionary performance.

00:51:20.400 --> 00:51:22.660
In fact,
it has a much bigger impact than,

00:51:22.690 --> 00:51:25.400
you know, just the overall performance
of these methods.

00:51:25.400 --> 00:51:28.280
What I mean by goodness of the
hash function is the ability

00:51:28.280 --> 00:51:31.400
for the hash function to return
values that are spread out.

00:51:31.400 --> 00:51:33.890
If your hash function always
returns a single value,

00:51:33.890 --> 00:51:37.400
like 0 or 42 or, it doesn't matter how
interesting the number is,

00:51:37.400 --> 00:51:39.970
it's always a single value,
the dictionary will start getting

00:51:39.970 --> 00:51:43.340
a lot of conflicts in its hashing,
and as a result, its performance,

00:51:43.340 --> 00:51:47.440
the worst case performance, you know,
will be reduced to linear searches

00:51:47.440 --> 00:51:51.330
and insertions and it just,
you know, will start acting very bad.

00:51:51.400 --> 00:51:55.760
So typically when you use NSDictionary's,
one thing you should watch out for

00:51:55.800 --> 00:52:00.190
is whether the hash function you have
is appropriate for the data you have.

00:52:00.400 --> 00:52:00.400
And often, you know,
you have a lot of hash functions

00:52:00.400 --> 00:52:00.400
that are not as good as the
hash functions that you have.

00:52:00.400 --> 00:52:00.810
So typically when you use NSDictionary's,
one thing you should watch out for

00:52:00.810 --> 00:52:01.400
is whether the hash function you have
is appropriate for the data you have.

00:52:01.540 --> 00:52:02.040
that is the case.

00:52:02.040 --> 00:52:04.690
You know, like, strings have hash math
functions which work well,

00:52:04.690 --> 00:52:06.640
numbers have hash functions, so on.

00:52:06.640 --> 00:52:08.780
So often it will work,
but this is something

00:52:08.780 --> 00:52:10.270
to keep an eye out for.

00:52:12.330 --> 00:52:17.070
And here's one little tidbit.

00:52:17.130 --> 00:52:20.300
If you do implement is equal and hash,
one thing to keep in mind is for

00:52:20.300 --> 00:52:24.140
the purpose of this dictionary and
other Cocoa objects which do hashing,

00:52:24.190 --> 00:52:26.710
is equal implies that the
hashes are equal as well.

00:52:26.810 --> 00:52:29.240
If you break this variant,
your dictionaries will

00:52:29.280 --> 00:52:30.660
just start going south.

00:52:32.950 --> 00:52:35.300
The other case study is String,
and this is another

00:52:35.300 --> 00:52:37.240
interesting point here.

00:52:37.310 --> 00:52:39.830
As we talked about earlier,
it has the primitive

00:52:40.290 --> 00:52:42.370
method character at index.

00:52:43.710 --> 00:52:45.790
This simply returns a character
at a certain location.

00:52:45.840 --> 00:52:47.680
Now, this method often is very,
very fast.

00:52:47.740 --> 00:52:50.120
It just, you know, whatever,
two nanoseconds,

00:52:50.120 --> 00:52:52.520
whatever the numbers are,
but it's very fast.

00:52:52.520 --> 00:52:55.740
In fact, it's so fast that the
invocation overhead,

00:52:55.850 --> 00:52:58.000
the overhead of actually
calling the function,

00:52:58.060 --> 00:52:59.780
can be a significant overhead.

00:52:59.820 --> 00:53:02.680
You know,
the function call takes maybe more

00:53:02.680 --> 00:53:04.480
than just returning the character.

00:53:04.480 --> 00:53:07.380
So one thing that's usually a good
idea in NSString is to use the

00:53:07.380 --> 00:53:09.360
bulk method whenever possible.

00:53:09.400 --> 00:53:12.440
What I mean by that is it's this
method where you give it a range,

00:53:12.440 --> 00:53:16.040
and it returns to you, you know,
multiple characters.

00:53:16.040 --> 00:53:19.020
So -- and you give it a buffer
as big enough to hold that range,

00:53:19.120 --> 00:53:21.400
and you ask for multiple characters.

00:53:21.420 --> 00:53:22.680
It turns out if you're
asked for more than three,

00:53:22.680 --> 00:53:24.780
four characters,
it's usually a better idea to call

00:53:24.780 --> 00:53:26.880
this than to call character index many,
many times,

00:53:26.920 --> 00:53:29.680
because the overhead of that call is bad.

00:53:29.680 --> 00:53:32.240
And one more point here is that
if you do subclass NSString,

00:53:32.240 --> 00:53:34.940
it's often a good idea to
also override this method.

00:53:35.150 --> 00:53:37.830
Although this method is not a primitive,
for performance reasons,

00:53:37.830 --> 00:53:40.440
overriding this method will
make your string subclass.

00:53:40.440 --> 00:53:43.000
Subclasses work much better.

00:53:43.000 --> 00:53:44.580
And, you know,
this is sort of like going to Costco and

00:53:44.580 --> 00:53:47.990
buying the 100-pound bag of keto litter
as opposed to buying many small bags.

00:53:48.060 --> 00:53:51.830
You know, you -- the overhead
becomes lower because,

00:53:51.830 --> 00:53:53.470
you know, the cost is less and all that.

00:53:53.470 --> 00:53:54.430
It's very similar.

00:53:56.150 --> 00:54:01.280
Well, you know, that's as far as I want
to say about this.

00:54:01.290 --> 00:54:05.140
So my goal here was to, you know,
give you an idea of some of the

00:54:05.310 --> 00:54:09.280
Cocoa techniques and conventions
so you're familiar with them.

00:54:09.280 --> 00:54:11.650
And hopefully,
not only can you use these in your apps,

00:54:11.900 --> 00:54:15.120
but, you know, we'd really like you to
create your own frameworks,

00:54:15.120 --> 00:54:18.260
your objects that you can sell
or share with other developers.

00:54:18.450 --> 00:54:20.060
And if you, you know,
follow these guidelines,

00:54:20.060 --> 00:54:23.060
follow the other Cocoa guidelines,
you know, this is not all.

00:54:23.060 --> 00:54:26.480
If you follow them, you know,
hopefully your frameworks and

00:54:26.480 --> 00:54:28.450
your friends' frameworks and
developers across the country,

00:54:28.450 --> 00:54:30.580
their frameworks,
they'll all fit in like Lego pieces

00:54:30.580 --> 00:54:32.570
with high level of impedance matching.

00:54:32.600 --> 00:54:36.420
And, you know,
it will work very well together.

00:54:36.420 --> 00:54:38.500
One more thing I should note is,
you know,

00:54:38.500 --> 00:54:41.200
you look at these guidelines and
if you go look at the Cocoa APIs,

00:54:41.200 --> 00:54:44.980
you might find a few places where we
violate these guidelines ourselves.

00:54:44.980 --> 00:54:46.150
And that's natural to be expected.

00:54:46.270 --> 00:54:47.800
These guidelines have
been developed over,

00:54:47.800 --> 00:54:49.590
you know, the last ten years,
and Cocoa has been developed

00:54:49.590 --> 00:54:50.940
over the last ten years.

00:54:50.940 --> 00:54:50.940
And there are certain areas and certain
areas that we're not familiar with.

00:54:50.940 --> 00:54:50.940
And so, you know,
we're going to be looking at these

00:54:50.940 --> 00:54:50.950
guidelines and we're going to be looking
at these guidelines and we're going

00:54:50.950 --> 00:54:51.130
to be looking at these guidelines and
we're going to be looking at these

00:54:51.130 --> 00:54:52.580
guidelines and we're going to be looking
at these different areas in Cocoa which,

00:54:52.620 --> 00:54:54.710
you know, were developed before the
guideline was developed.

00:54:54.850 --> 00:54:57.130
You know, those bad method names I gave,
ambiguous ones,

00:54:57.130 --> 00:54:59.260
they all happen to be methods in Cocoa,
for instance,

00:54:59.270 --> 00:55:01.890
that we'd like to get rid of someday.

00:55:02.850 --> 00:55:06.340
Now, one hour talk isn't enough
to cover all the topics and

00:55:06.340 --> 00:55:11.240
all the API areas and so on,
but here is the Apple documentation.

00:55:11.560 --> 00:55:14.600
There are many programming topics
that are described conceptually,

00:55:14.600 --> 00:55:15.800
and that's very good.

00:55:16.070 --> 00:55:18.790
There are some good
other books out there.

00:55:19.050 --> 00:55:21.500
Clearly, learning Cocoa and building
Cocoa applications,

00:55:21.500 --> 00:55:23.720
if you're just diving into Cocoa,
those are good books.

00:55:23.760 --> 00:55:26.850
Aaron Hillegas' Cocoa Programming
for Mac OS X is also a very

00:55:26.920 --> 00:55:28.480
good book for beginners.

00:55:28.480 --> 00:55:29.460
I recommend it highly.

00:55:29.460 --> 00:55:33.580
If you're interested in API,
object-oriented design issues,

00:55:33.580 --> 00:55:36.850
etc., the book by Eric Gamma
and three other folks,

00:55:37.060 --> 00:55:38.850
Design Patterns, it's an excellent book.

00:55:38.860 --> 00:55:43.350
It actually is about five, six years old,
but it takes some of its examples from

00:55:43.630 --> 00:55:47.600
Next Step at the time and has many
other cases from other environments.

00:55:51.200 --> 00:55:53.700
In the roadmap, the intro and what's new,
you missed those,

00:55:53.700 --> 00:55:55.640
but you can catch them if you wish.

00:55:55.780 --> 00:55:57.880
Later today and tomorrow,
we have various talks that

00:55:57.880 --> 00:56:01.840
cover various areas of Cocoa,
scripting, controls and accessibility,

00:56:01.960 --> 00:56:07.650
drawing, the tech system, and finally,
the feedback tomorrow afternoon at 5.

00:56:07.650 --> 00:56:09.830
Okay, and that's it.

00:56:09.830 --> 00:56:11.000
Thank you.
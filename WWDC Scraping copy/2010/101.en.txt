---
Title:  What's New in Cocoa Touch
Year:   2010
Web:    https://nonstrict.eu/wwdcindex/wwdc2010/101/

[!] This transcript has potential transcription errors.
---

 Welcome to Session 101, What's New in Cocoa Touch. Good morning. My name is Chris Parker. I work on the UIKit Framework, and today I'll be talking about everything that we've been working on for the last year. So, in 2009, we introduced iPhone OS 3 and that had a bunch of new things for everyone to use, obviously. In April of 2010, we introduced iPhone OS 3.2.

We shipped the iPad and you guys did just an absolutely fantastic job of downloading the betas, getting your apps ready for the iPad, and sending us a lot of great bugs. So, thank you very much. And today, yesterday actually, you heard Steve talked about iOS 4 and all of the support that we've put in it for the hardware. We also have a lot of support for a number of new features. So, today I'm going to talk about everything that we've done since last year. We'll go over some of the stuff for 3.2 and then talk about some of the new things for 4.0.

So iPhone OS 3.2 supports the iPad and the pad's larger screen allows a lot of new ways for your users to be able to interact with their information. You'll be able to bring things several taps closer to your users. The way they'll navigate through your application probably has changed fairly significantly. We also really encourage you to write your application so that they rotate to all directions, right. I certainly caught myself using the iPad and suddenly discovering that the Home button wound up on top and I keep tapping on the bottom and I can't go Home.

So if you're finding that, that's actually a pretty good sign because it means that your users can use the iPad in any orientation. And we had introduced some non-full screen UI elements, right. We finally have something that's big enough that the full screen transitions that happen on the iPhone don't really translate very well to a screen the size of the iPad. And we also introduced document sharings. There are ways to not only share documents from your desktop to your iPad but also among the applications that are on your iPad.

iOS 4 introduces two really big features, multitasking and HiDPI and we've got support in UIKit for both of those things. There are some basic things you'll do to adopt those technologies and then if you want to make your app far more sophisticated about those things, you can do that as well. So let's talk about what's in iPhone OS 3.2. UIPopoverController is a non-full screen transient UI element.

It's designed to put things on the screen that the user may interact with briefly and then dismiss, right. So, you present these things, they come up with a view controller inside them. The user taps outside of them, they go away. Or they tap something inside the popover, they've made a selection and you go ahead and dismiss it. It is not itself a UIViewController subclass. It's its own controller class and you create one of these things just by calling initWithContentViewController. So, the UIPopoverController is going to host a view controller.

It has a bunch of different properties. If you change the content view controller while it's up, we'll go ahead and crossfade between the two. There's also a variant of this that you can do the change without animation. You can change the popover content size from outside the popover or actually from inside in your UIViewController subclass.

You can also set some things called passthroughViews. And passthroughViews are a way that you can have the popover up and then the user can interact with other UI elements while the popover is up. Normally, they tap outside, it would go away. You can also have interaction while the popover is up. And that's actually if you've used the Mail application on the iPad in portrait orientation.

When the popover is up and you start deleting three or four email messages, grab the messages behind it with two fingers and pull the messages out from underneath the popover. You can read the messages so that you can see, make sure that you are deleting the right things. So, that's actually how they do that in Mail.

So presentation and dismissal for UIPopover-- The Earth move for you guys too?

[ Laughter ]

Presentation and dismissal for UIPopoverController, you present these things from a rect inside a view, right. So you may have a large canvass the user taps, you'd like to be able to choose a rect inside a larger view that the popover is presented from. You'll call popover, presentPopoverFromRect, inView, permittedArrowDirections, animated.

One cagey note about this, the rect that you provide to this method should be in the coordinate system of the view. I've done it too. I went ahead and passed view frame to this thing and couldn't figure out why the popover was coming up in the wrong spot. You probably want the bounds of the view, right.

Otherwise you are tapping here and the popover is showing up someplace over here. The permittedArrowDirections allows you to tune where the algorithm chooses to lay your popover out. So, we actually try to figure out how to position the popover in such a way that it shows the maximum area on the screen. So, usually you'll pass UIPopoverArrowDirectionAny to this but you can pass up, down. You know, it's a bit field so you get to choose what directions you want.

So if you only want it to appear from the top or the bottom, you can do that. There's also specific API for presenting from UIToolBars, specifically Bar Button items in UIToolBars. So presentPopoverFromBarButtonItem is the API if you are going to drop something from a UIToolBar. And remember on OS 3.2 now you can have UIToolBars at the top of your views, right. We used to say you had them at the bottom, now you can have them at the top as well.

When you dismiss a UIPopover, if the user dismisses your popover you get some delegate callbacks. One of them says should dismiss popover. If you returned yes, it will go ahead and dismiss. If you return no, it won't dismiss at that time. If you call dismissPopoverAnimated, we're not going to call those delegate callbacks, right.

The delegate callbacks are specifically for the user action to dismiss the popover. dismissPopoverAnimated is your action and we assume that if you're calling this, you know it's going away. You probably don't need to-- you want it to go away. So we're not going to call the delegate methods for that.

There are some specific additions to support popovers on UIViewController itself. So, the content size for viewing popover property is how you tell UIPopoverController how big you want the popover to be for that particular view controller. So we'll go ahead and call that and figure out what size you'll be-- the popover view will be. There we go. And this is a read-write property, so typically, you'll set this probably and viewWillAppear.

That you can use this dynamically as well so if you have a view that changes size depending on its content, you'll be able to just say, you know, the height might be the height of the view that's contained in it. Also if you call this while the popover is up, we'll animate the resize for you, right. So, you don't need a back reference to the popover controller. If you're doing this stuff, you can just call contentSizeForViewInPopover as your view changes size. We'll go ahead and if it's in a popover we'll resize it. If it's not in a popover we'll ignore it.

There's also a setting for modality. One example of this is actually the AB people person-- person people. I can never remember the name of this thing. It's the thing that displays Address Book cards, right. And if you tap Edit that same view shifts into an edit mode. It doesn't push a new view to be the editor. And when you go into that edit mode it becomes modal. You can't tap outside it.

That's how they do this. It's with the isModalInPopover property or the modalInPopover property. So if you have state where you really don't want the user dismissing this until they finish something inside your popover, use this. For the most part, popovers aren't modal things. They are very transient things. So, things you are going to tap on, user interacts with and they go away.

UISplitViewController is the other big new UI element that supports the iPad. So, it's a full screen UI element. This is in fact a subclass of UIViewController. So, it goes through the same rotation, checks and everything else. It keeps track of two view controllers. It also manages a popover controller for you. And we'll see how that works in a minute.

Typically, you'll use these for master detail views. The Mail application uses one of these, right. Your Mail inbox is on the left. The message content is on the right. This is actually a version of the Core Data books example that we'll use in a minute. Typically you will create these things from NIBs, right.

When you drive one of these out in Interface Builder, it shows up, a nice big window comes up. It has a full layout for everything with all of the view controllers already set up, a navigation controller in one side, a view controller on the other. You can create them just by calling alloc init obviously.

It does have some new properties. One of them is an array of view controllers. Right now that's-- you get two. So the object at index 0 for this NSArray is the narrower sort of the master view and the one in object at index 1 is the detail view. And the delegate controls, you get notifications on the delegate depending on what events are happening as the user rotates the device. So there are three UIViewController delegate methods, SplitViewController, willHideViewController, withBarButtonItem, forPopoverController.

We do try to be descriptive in all of these methods. The SplitViewController obviously is what's doing the rotations. willHideViewController, this is the landscape to portrait transition, right. So we go from landscape to portrait. We're going to hide that master view controller. Right? We're going to give you a UIBarButtonItem. That BarButtonItem is the thing that you are going to put up in the Toolbar in what will be the only view visible in portrait.

And for popover controller we're actually also going to give you a reference to the popover controller in case you want to adjust its content size or something like that. The SplitView does own that popover controller so don't go doing something crazy like tweaking its delegate or anything like that. SplitViewController will show a view controller invalidating BarButtonItem. That's the other way. We're going from portrait to landscape.

We're going to show the master view controller and we're also telling you that BarButtonItem we gave you before, yeah, that's no good anymore. Get rid of that. So that's how you can govern what's happening in SplitViewController. And SplitViewController, PopoverController will present popover controller. This is-- will present view controller.

This is where the user is going to go ahead and tap on that button in portrait and we're going to tell you we're about to display so if you have any other actions you want to take like maybe setting its passthroughViews or something like that, this is your opportunity to do so.

I actually have a small demo about how to at least show you code about how to manage your BarButtonItems. And the Universal Core Data Books example is something that I'll be using later in the iPad Development Overview at 4:30 today. So if you're going to be coming to that you'll see a lot of this method. Let me run this in the simulator. This is a little small for the iPad, isn't it? Let's run it in the other simulator.

And actually I'm going to stop here for a second. If you are watching closely when I built that, this is the same simulator binary running in both the 3.2 simulator and the 4.0 simulator. We've recompiled the system frameworks for the iPhone OS with a new Objective-C runtime. So this means that you get full synthesized ivars in the simulator.

You'll be able to run your simulator binaries across both SDKs so you don't have to keep having to recompile everything and keep separate versions of everything. So this is actually really handy. So--

[ Applause ]

Some of you have done that then. Good. Let's take a look at this application here. This is the Universal Core Data Books application.

If I tap on a particular book it shows me a nice detailed view of the book. And as I rotate watch what happens in that button at the top here. I get this popover controller. The code for this all lives right now in book DetailViewController and here are the SplitViewController methods. There are three of them. This is the willHideViewController with BarButtonItem.

You will just grab your BarButtonItem, give it a nice title, call it Books. We'll go ahead and make a copy of that toolbar items array insert the object. Set the items, release the toolbar items because we don't want a leak and we'll grab a copy of the popover controller because there may be times, for instance, if you want to interact with something, you may want to just dismiss the popover controller.

So, you can tell it to dismiss. That's okay. Call it again, here the splitView:willShowViewController. Same thing-- I almost forgot same leak. Remove the item at the index and pull it out. We do recommend that you put the button that you are going to use at object at index 0 in your toolbar because that turns out to be the left most item in that toolbar and it will be closest to the view controller when it rotates back in. Oh, and this pop-- I just put an NSLog in here, the popover controller will present view controller but you can do anything you want in there within a reason. We've also introduced UIDocumentInteractionController.

And this is a-- basically how it we're managing the UI for doing document interchange on the iPad. So, when you are going to send somebody a document, you've seen this in Mail, right. You hold down your finger on a particular document, you get the little popover controller. It comes up, it's got an open end menu you probably have several options here. It is the UI for opening documents. It is the UI for previewing documents.

It uses universal type identifiers and the way you specify what documents you can open in your application is the same way you do it on the desktop. In fact, it's the same Launch Services key for expressing interest in document formats. So, you'll specify which UTIs your app opens. We figure out what's installed on the machine. We put your app in this list. So UIDocumentInteractionController, you can create these things from just by saying interactionControllerWithURL.

It will give us the URL, that URL is probably something that's in your applications documents directory or in your app wrapper. The properties are things like well, obviously, you can read the URL. We also do some introspection and figure out based on the file extension and things like that what the UTI, the document is. And then we'll check the name.

This is suitable for display to the user. The array of icons is just a bunch of UIImages in increasing size. So, if you've got a limited amount of space, probably is one of the earlier items in the array. If you've got a whole bunch of space you can use one of the later items in the array. And you can set your own annotations on these things as well.

There is an Options menu that's the open in menu, presentOptionsMenuFromRect, InView. That should look familiar because it's in a popover, it's the same kind of rules that go with the rect and the view that you're presenting there. And presentOptionsMenuFromBarButtonItems. Same thing. This works in both. There is a version for 3.2.

And there is also in iOS 4, a version that comes up as an action sheet and you can put your own UI for tapping on the document. dismissMenuAnimated, same kind of thing, when you tap in it you'll-- if you call this, you'll tell us that you want it to go away.

You can also present a preview, right. So, the user can preview the things that we know about, things like PDFs and Keynote documents and Numbers documents and things like that. You'll be able to present a preview from your application directly so if you don't want to launch another app or if the user doesn't want to launch another app, you can just put a preview up of what's been selected. And you can also dismiss the preview in an animated fashion as well.

One of the really difficult things that we found that we got feedback about was trying to track gestures, right. So, the user taps and you are trying to recognize a swipe and you have to keep track of a touch and where it went down and how long it was and whether it was perfectly horizontal or it started to drift, things like that.

UIGestureRecognizer introduced in 3.2 allows you to associate an action with a gesture, right. So, we have built-in gesture recognizers for swipes, rotation, long presses, pinches, taps, and pans. The rotation, right, is put two fingers down, rotate like this. Swipes obviously. These allow you to match all of our metrics for all of these gestures.

So if you use the built-in gesture recognizers you're getting the same metrics and trigger behavior that we use for photos and mail and all of our apps. They're really easy to create. You set it up with an initWithTarget action. So, you'll have a target object and an action which is a selector and the automatic ones you can just create right out of-- the built in ones rather, you can just create right off the headers. This is part of your subclasses. So you can write your own UIGestureRecognizers to recognize different kinds of interaction. They have a bunch of different properties.

It's a big state machine. There's a I've began recognizing state and there's a I'm still recognizing state. And there's oh, I recognized something and I fired state. So, you'll be able to find out a lot about the state there through the UIGesture, through the state property. There's a delegate. It has some delegate methods that we'll get to in a second. You can enable or disable them, right. So, if you don't want it to recognize under particular conditions you can turn it off entirely.

They get attached to a particular view. Once it's been attached you can call the view accessory to find out where it went. And cancelsTouchesInView there controls the behavior when the gesture recognizer no longer is able to recognize a particular gesture. On UIView you just attach these things, right. So, there's API on UIView that says once you've got a UIGestureRecognizer, add it to this view, and you can remove UIGestureRecognizer that's been put on to a view.

The delegate methods are pretty straightforward. Gesture recognizers should begin-- is your opportunity to say yes or no. Gesture recognizers should recognize simultaneously with gesture recognizer, another one of those descriptive delegate methods but it ties two delegates. It ties two gesture recognizers together. So you can decide how they act in concert.

So, you can set up relationships between gesture recognizers and say when this one is active, this one is not. Do not have these working together at the same time. And gesture recognizers should receive touch, right, another delegate method. As touches start to get added to the event sequence, this is your opportunity to decide whether or not the gesture recognizers are going to see it. This is a big topic. We actually have two talks on this.

Simplifying Touch Event Handling with Gesture Recognizers is in Pacific Heights tomorrow at, what's that, 3:15. And if you stay in your chairs for another hour you can get Advanced Gesture Recognizer, Advanced Gesture Recognition in the same room. So if you are doing a lot of gesture work, we're talking about that tomorrow. We now support multiple screens for iPhone OS 3.2 and in iPhone OS 4. Actually, much of what I'm talking about here applies to both operating systems.

The multiple screen support is basically how we're doing things like TV out for Keynote. Alright, so you can find out what screens are attached to the device. There are some notifications that tell you that screens are coming and going. And the screens had different modes. One of them is the availableModes array.

You get a list of all of the modes that are supported and this is very similar to what you see on the desktop with the projection business and you plug in a display and you get to choose which resolutions are available. The modes array here is an array, an NSArray of UIScreenMode object. Those objects all contain information about the current mode.

The currentMode is obviously whatever is being displayed there. The mode objects are pretty simple. They have two things in them. One is the width and height of the screen and the other is the aspect ratio or the pixel. It turns out it's awfully convenient to think of pixels as squares but there are a lot of things you can plug in to your devices that do not have square pixels. So, that is your opportunity also to decide whether or not you need to tune your drawing for particular screen.

So we now also have support for custom input views, custom keyboards and custom accessory views. This has been a big request. We have the Numbers screen shot here. This is the text inputAccessoryView. It shows up above the keyboard. It you create one of these and attach it to a UIResponder subclass.

As the keyboard comes and goes for that responder we bring that view up automatically as part of the same animation with the keyboard, right. So you don't have to try and synch up with us and get that view in place. You can just attach it to your UIResponder subclass. We'll go ahead and move it for you and it's the same thing for a custom keyboard itself. So, this is the standard keyboard. Numbers also supports a date and time keyboard, for instance.

So there are a bunch of different kinds of input that you can capture from the user just by providing a custom keyboard. And this is the, it looks like the money input. Yes, numbers, dollars, ratings, things like that. I actually have a really, oh. UIResponder input view. On the UIResponderView subclass itself, there are two properties, inputView and inputAccessoryView.

They're read only. So if you are writing your own responder subclass you'll override these and return your own inputView or you own inputAccessoryView that will come along with the keyboard as it comes in and out. But if you want to tinker around with it or if you are working with text views specifically, the text view has redeclared the property as read-write, okay. So let's stop looking at Universal Core Data Books here and go for the input view demo.

This is a very, very simple demo. That's just a straight UITextField. If I tap in it, hey look, the Home button is at the top, put that back. If I just tap in it, the keyboard comes up. I've got a simple accessory view here that has just three buttons in it. I can type in the view, that's fine, and then the three buttons just go ahead and change the background color.

The code though for these is really simple. It is a fairly tight relationship between the input views or the input accessory views and the view that's going to receive those events. So let me show you what the demo accessory view looks like. I just have an initWithFrame here and it's got three buttons.

I go ahead and put the buttons in too. I set their targets. I go ahead and set their titles, set their frames. So I have to do the layout and then I go and add the subviews and what I've done here is just added a background color. If I don't add that I wind up getting just this blank space here which is fine but in general, we probably want to put some chrome there to make sure that everybody understands that this is a paired view that goes along with the keyboard, so. And just in terms of setting, I have a controlled view property here.

In terms of setting the controlled view color we just set a background color. And just depending on which button got hit, we just send the appropriate message that says, hey set color to, you know, red, green or blue. That's the accessory view itself. In the input demo view controller here, all I did was create one of these demo accessory views with the right frame and attached it to the text field. So if all you're using are text fields in order to get custom input, you can just go ahead and attach them directly. If you are writing your own responder subclasses you should make sure that you override that method and return your view.

So we added some new things to UIMenuController. Remember what used to happen, right. You tap in a UIMenu. You tap in some text. You get the Select or Select All options and then you choose. From the selection you get Cut, Copy or Paste. You can now add your own items to UIMenuControllers. This includes you know, if you wanted to put something to trigger a search, to look up a word.

Anything you that you can do with the text you'll be able to add some actions to that text. So you can add your items. You add them by just creating a new UIMenuItem object. That UIMenuItem object has a title. That is what gets displayed in the menu controller.

It has an action selector as well and that gets sent up to responder chain the same way the cut, copy, paste ones do. So you will be able to govern what appears the same way you govern your behavior for cut, copy, and paste. There is also a new Delete item that got added. That is an automatic thing. So now you got copy, copy, paste, delete.

The Delete item just takes a selection and removes it without actually putting anything up on the pasteboard. It turns out that that is really handy so we've added that as well. In order to support the iPad's larger screen, we have introduced some new ways of doing modal presentation that don't take up the entire screen, right.

So having a big modal sheet that slides up all over everything turns out to be a little jarring. So NS-- UI-- NS, boy, you can take the guy out of foundation but you can't... UIModalPresentationCurrentContext says, when you present this view controller modally, these are all things that you pass to present modal. When you present this view controller modally, do it in the same context.

So if it is a full screen presentation, make it a full screen presentation. If it is in a popover, keep it in the popover, alright. If it is part of a form sheet, keep it as a form sheet. The page sheet and form sheet variants are what we're using in a couple of different applications. This is what a page sheet looks like, right. The page sheet controller is the width of the screen when it is in portrait orientation.

It is not quite full screen. The edges get dimmed out and if there is a keyboard, we'll just bring the keyboard up over the bottom of it and you'll be responsible for making sure that the area is still visible. But if you are to tap Send here, the top would go-- it would go off the top.

If you were to tap Cancel, it would go off the bottom. But page sheets are basically a way to be able to put a large modal item up on the screen without taking up the entire screen width. A form sheet is something much smaller and it is designed for things that you're going to fill in.

It is basically acquiring some small amount of information but it's not worth, again, eating the whole screen over. And we slide these up when you call present modal and this is actually the form sheet that we're using in the app store when you configure your account. I did scroll my account details off the top, sorry.

Foundation has actually been a little bit busy. They have added regular expressions in OS 3.2. And the regular expression searching for Foundation is pretty straightforward. There is a new StringCompareOption, NSRegularExpressionSearch and you will pass this to the rangeOfString APIs and where you would have passed a literal string for a range of string there, instead you can pass an ICU compatible regular expression. And that will return the range that matched in that string, right.

And if we peek ahead just a little bit to iPhone OS 4, they've actually gone ahead and put in a full NSRegularExpression subclass. So you can create regular expressions. When you create it, it is compiled at that time. You can reuse that regular expression multiple times. So you'll create a regular expression with pattern options. The options include thing like case insensitive comparison and going the full text and, you know, being greedy match. How greedy you want the match to be and the error just gets returned if you gave us a pattern instead of options that do not make any sense.

And you can enumerate the matches and the matches get enumerated by using something like enumerateMatchesInString, options, range, usingBlock. You will get repeated invocations of the block you gave us with NSTextCheckingResults that represent what got matched. So the advanced text handling talk for iPhone OS is in Nob Hill on Tuesday, later today at 4:30.

If you are doing any kind of text processing, there are a lot of great features that are now on iPhone OS 4, iOS 4 that you will be able to take advantage of. So they are talking about this. They are talking about Cortex. They are talking about data detection. It's all kinds of things that you should go see if you are doing text on the phone.

So, alright, let us talk about iOS 4. Multitasking is of course one of the big features of iOS 4 and basically, there are three classes of multitasking applications. There are audio applications. So you saw Steve demoing an audio application that kept playing in the background yesterday as he was browsing mail and looking at his threaded messages and everything like that. There are location applications. If you are a background location application, you have registered with Core Location to receive notifications about what we're calling geofences.

Basically, you can set up boundaries using coordinates and the user will be told as they move in and out of those areas, you know, you'll get a local notification that says, "Hey something happened." So you'll be able to set up location applications for the background and Voice over IP applications, VoIP applications.

You opt in to these by doing, using the UIBackgroundModes key in your info.plist. And that winds up being an NS-- an array of strings. Those are the strings. You can actually find them in the documentation as well. Actually, I think the string should all be lower case, so.

The multitasking application lifecycle is a little different, right. So remember what happened prior to iOS 4. You launched your app or the user would launch your app. They have used it for a while. They'd hit the Home button. You get told, hey you're going away. You got a few seconds to write some stuff out so that you can pick up where you left off and then we pretty much kill your app, yeah. And then when you come back up, you've got a-- you got a sort of unfreeze, dry all that state.

The application lifecycle changes under multitasking. You will basically go through three states. You will go through an active state, an inactive state and a background state. So when you launch you will get your usual application didFinishLaunchingWithOptions and then you will get an applicationDidbecomeactive message. These are messages that are sent to your app delegate, right. Then when you're going to background, you're going to go through the inactive state into the background state. So application will resign active. You've probably seen this message before occasionally and in certain circumstances. And then applicationDidEnterBackground.

So this is where we tell you actually you went into a background state. Some other application is in front of the user right now. You are no longer there. We do a bunch of things behind the scenes in order to do things like reduce drawing load so if you actually try to draw, those drawing methods go nowhere. We take care of a bunch of things in the background to try and minimize battery life while you're back there. And if you spend long enough on the background you don't get a whole lot of time. It is the same kind of thing.

You get a certain amount of time to do some cleanup work and then we will go ahead and suspend your task. We're not going to kill you outright. We'll just suspend you for a bit. So that when you come back you will be basically right where you left off. You, however, may get killed while you are suspended.

Because as the user uses the device maybe they do not come back to your app for a while and we need the memory for something else and since you don't have a 60-gig hard drive hooked up to swap to, we're just going to kill an application. So we'll find an app that hasn't been used in a while, we'll kill it.

That's why you can use, oh, and when you come back to the foreground, you will get applicationWillEnterForeground, DidBecomeActive. You can use this other API. beginBackgroundTaskWithExpirationHandler, endBackgroundTask. And this is your opportunity to tell us that when you are going to go in the background you need a little more time. I'm almost done, I haven't written out everything. I haven't sent my goodbye packets to my remote server. I haven't finished downloading this file, right.

So what you'll do is you'll bracket that work between these two calls: beginBackgroundTaskWithExpirationHandler endBackgroundTask. The expiration handler is a block that we copy and if you're really just taking too long, right. We're not going to give you all the time in the world here. We do actually need the task to suspend you. We will fire that handler, right. So if you are downloading a file and you get three quarters away through and you run out of time, there is an expiration limit on these things. We will fire that handler.

That is your opportunity to say, I pick up this download at 82 percent or wherever you've left off or, you know, whatever else you need to write out. That is your opportunity to do it, so. As part of multitasking, you'll also be able to send-- to register to send local notifications. So what you'll do is before you get suspended you can say, create one of these UILocalNotification classes. They are just model, they are basically model objects. They have got a fire date. They have repeat intervals. You can change the icon of your application.

There are all kinds of things you can do with this. It is in the UILocalNotification.h header. And this is very similar to the push notifications. Except, instead of push notifications coming from some remote server some place, these come from your application or on behalf of your application. User will get a little dialog and they can choose to launch your app at that point or not. There is a lot to do with multitasking so if you really want to be an incredible multitasking application, you're going want to go to the Adopting Multitasking on iPhone OS talks, Parts 1 and 2. One just before lunch in the Presidio.

It is not as convenient as the gesture recognizers talk. You'll actually have to get up and go some place else to get part 2. But part 2 is in the Mission Tuesday at 3:15, so later today. If you're going to be doing multitasking, if you are going to be taking advantage of background audio playing, if you are going to be doing location work, please go see these talks. They'll talk about everything you'll need to do in order to be a good multitasking application. And finally, let's talk about high resolution for iPhone OS 4.

I've stood up here. I have said things like this before. One point no longer equals 1 pixel. So on the iPhone 3GS your screen is 320 x 480 pixels. On the iPhone 4 your screen is 640 x 960 pixels which if you are keeping track, I think they said that was 326 DPI. The Apple LaserWriter that shipped with the original Apple Macintosh was 300 DPI. So you now have better than camera ready output in your pocket. It is amazing it fits in there with the rest of the internet, so.

[ Laughter ]

The catch here is this. UIKit thinks in points. It is actually not a catch, it is a big bonus for you guys. They are the same size and points. So an iPhone 3GS 320 x 480 points, an iPhone 4 320 x 480 points. All of your layout is the same because toolbars are 44 points tall, right.

All the buttons are the same number of points in both situations, right. So we had this idea of scale that we introduced in order to help out. So UIScreen, UIImage, all of these things for the sizes, balance, things like that, those are all in points. It means that your layout code runs on the iPhone 4 the same way, right. And you heard Steve talk about how for applications that are not native iOS 4 apps we go ahead and render all the text at full resolution so it looks really crisp.

It's actually really impressive. On UIScreen scale is a float, a float, and this is going to be 2.0 on an iPhone 4. It will be 1.0 on iPhone 3GS's. The scale for UIImage is always non-zero. You will be able to find out what scale the image is drawing at. You will be able to set the scale for your own images. You should never really hard code things like 640 x 480 or 320 x 480, any of those numbers.

If you are not actually asking for the size, asking for the scale and basing your computations on that, if you're hard wiring things that gets you into some trouble because if you think that the screen is always 320 x 480 or, you know, 1024 x 768 for the iPads, things like that, you can actually paint yourself into a bit of a corner. We're giving a talk called Future Proofing Your Application which is going to talk about ways that you can sort of code defensibly to make sure that a lot of these things do not happen.

You know, if you are going to ask for an image size, find out its actual size, that kind of thing. That is in Pacific Heights Tuesday at 2, I am sorry, Thursday at 2, Thursday at 2. And that will be a really good talk to go to in order to think ahead to, you know, programming for the pad, the phone, all the different variants of the phone that we are currently shipping. Images turn out to be a little interesting here and this has to do with resources and the resources that you put in your applications. So if I take, say, some text and I just blow it up.

This is just a PNG file that I have. I may just have decided that I need to use a font that isn't available or something like that. So I'm going to use a picture to do it. If I just blow that up, this may be a little hard to see here, but it's kind of blurry. It's not really as crisp as it could be. We do this on the iPhone 4 because the iPhone 4's resolution is twice in each dimension that of the 3GS.

It looks no worse than it does on the 3GS but it doesn't look as good as it could either, right. And we really want your applications to look great. So, this is a full, the guy over here is a full resolution version of that text and oh, you'll figure it out. What you can do is name your resources appropriately. So, if you have a picture called SplashText.png you can have another version of that image that says Splash Text@2x.png. And all of our APIs that go through and do resource searching know about this naming convention.

So on the appropriate device, we'll go ahead and load the right resource. So, yes you'll have to go back to your designers and you'll say please, I know you just did this for me, but I need 2x versions of everything, right. But if you name them properly you shouldn't have to do a whole lot of work in getting them incorporated in to your code.

And in order to support drawing in the graphics context, we have to add some information to UIGraphicsBeginImageContext. So we've got UIGraphicsBeginImageContextWithOptions and this takes into account a couple of things, scale and whether or not the drawing is opaque. So, the size you'll give us is in points, right? Excellent. You can tell us whether or not what you're drawing is going to be opaque, alright.

We have 4 times as many pixels to push on the iPhone 4 so this is your opportunity to say well, I'm drawing as opaque so you don't have to worry about compositing. This is an opportunity to tell us something about your drawing and you'll tell us what the scale is of what you're drawing, right.

So, you'll be able to do scale sensitive drawing here. One important thing is if you're doing work with both UIKit and Core Graphics, right, the CG calls. UIKit thinks in terms of points. CG is really a bitmap-oriented framework. It thinks in terms of pixels. So, if you're going to be doing things across the two frameworks you'll have to keep the scale in mind as you do specific things with Core Graphics, okay. And this is thread-safe in iOS 4.

[ Applause ]

So, we'll be able to do context drawing back on a background thread. I recall my office mate working on this and just running a multithreaded thing with a bunch of views in it and he left it running overnight and overnight and overnight. It was really impressive. So, you'll be able to draw back on threads. This doesn't mean that the rest of UIKit is thread-safe, right.

You can't call back into UIButton on a background thread or anything like that but you'll at least be able to do your background drawing there. We have a high resolution talk, Optimize Your iPhone App for the Retina Display. It's in the Presidio, on a really big screen, Thursday at 3:15. HiDPI is a huge part of a great iPhone OS-- iPhone 4 experience and if you're going to be doing anything that's going to involve drawing or making sure that your app is going to look great on that display, please go to this talk.

So, but wait, there's more, a little more at least. We have some new ways to be able to do some UIEvents stuff. If you, you know, you heard Steve talk about the controls that show up on the iPhone 4 or on the 3GS when you're running iOS 4. If you double tap the Home button and you get that interface that comes up, you swipe left and you get the audio controls.

These are wired to these UIEvents subtypes and these are also how you can get events off of the remote that comes with the iPhone, right. So, when the user double clicks on the remote, you'll get a play or a pause event, things like that. These go up the responder chain so you can choose to respond to these depending on what view controller is being presented, alright. So, you'll be able to switch your view controllers out and deal with remote events subtypes on your own.

We've also added some new API to support animations and using blocks in iOS 4. iOS 4 does include all the block stuff: animateWithDuration, delay, options, animations, completion. So, we've got a-- you know, you can specify duration. How long you wanted to wait before it starts. Options specifies whether or not something that you do here inherits from its containing animation context. The animations block is where you would have put something between UIView beginAnimations and UIView endAnimations. Just put your animations in this block.

We'll copy that block off the stack. When we're ready to execute it we'll go ahead and just run through that. And then the completion handler takes a Boolean when it gives invoked. You'll find out whether the animation is complete or not and you can take action based on that. animateWithDuration, animations, completion, the short version if you don't need delay or specific options.

And again, an even shorter version, animateWithDuration, animations. So, some really basic things to try and make the animation API a little bit more convenient for you. UIView, view transitions, you know it's very common to switch views in and out. These APIs are class method on UIView. transitionWithView, duration, options, animation, completion so you can set up your transitions and transitionFromView, toView allows you to just switch a view in and out and this takes care of doing things like removing the fromView from it's superview and putting the toView in automatically, right, so the whole setting the alphas and pulling this stuff out afterwards is made a lot easier with transitionFromView, toView, so. There are a lot of new APIs. I could spend a lot of time just going through and finding all of the stuff that is tagged as new in iPhone OS 4.

There are new things like in UIVideo in the image capture controller that you can-- on the iPhone 4 you'll be able to switch between both cameras. You'll be able to grab video right off of the video controller, things like that. Please go through the headers, they've been annotated with the OS X availability macros that tell you when things were introduced. A good way to search through all that is just grab through the stuff that says iPhone 4, alright.

There are a number of new frameworks. We have a lot of talks that go along with those new frameworks. UIAutomation, it's not really a framework, it's actually an instruments plug-in. You are able to write JavaScript-based scripts for your application to automate user testing. Things that the user would do by tapping along on buttons and running through scenarios, you can run in Instruments.

The great thing about this is because you can run it in Instruments, you can run it alongside all of the other performance tracking systems. So, you can run through user scenario and check for leaks and you can do that reproducibly, right. So, if somebody says hey, I've got this weird scenario where you tap on this on 19 things and rather than having to do it yourself all the time you can write up a script that does that and then run it against Shark. Run it against the MallocDebug instrument, run it against all these others to check for leaks.

So, you'll be able to do all of that. If you do a lot of this kind of testing, Automating User Interface Testing with Instruments in the Marina, Wednesday at 2. That's going to be a great talk especially if you're really into using Instruments, this is a big help.

The AssetsLibrary framework, Incorporating the Camera and Photo Library in Your Application in the Presidio, Thursday at 9. This is a way to be able to interact with the user's content. AV Foundation, you know you saw the iMovie for iPhone demo. If you'd like to be able to do a number of those kinds of things in your application this is the framework for you. So this is how you're going to be able to get full control over video playback frame by frame notifications.

Control over video recording, you have direct access to the video cameras through AV Foundations so you'll be able to capture right off the camera. You can put your own layers over the views that are drawing, right. So rather than putting up an MP media player controller and trying to get stuff in front of that, this is the supported way to be able to do video playback with your own drawing on top of it. Discovering AV Foundation in Presidio, Tuesday at 2.

This will all be a great talk if you do a lot of media handling in your frameworks. EventKit, you now have access to the calendars that are available on the device, right. So you'll be able to search for events in the user's calendars. You'll be able to get record change notifications about the fact that the user changed something. You can edit and create events.

You can set them up on the local calendars that are on the device or you can edit things that are on the user's server. So, for instance, if you've got a CalDAV calendar some place you'll be able to create CalDAV events. Calendar Integration with EventKit in the Mission. That's, I guess that's here. Thursday at 4:30. So, if you're doing anything that involves the calendar, we have talks for that.

iAds. Alright, you've heard Steve talk about the iAd advertising framework. This takes care of everything about loading and presenting the ads, responding to events inside the ads, the user interactions, what they've tapped on, how to test them, things like that. Integrating Ads with iAds in the Presidio Wednesday at 9. This is a great opportunity for you to get some fantastic advertising into your applications. Game Center, as a developer preview on iOS 4, there is a social networking gaming system on your betas.

It does things like achievements, tracking games over the network, finding who else to play with. There's an Introduction to Game Center talk in Pacific Heights, Tuesday at 2. So, if you're going to be working on a game that's going to involve some of these social gaming aspects, you probably want to go to that talk. CoreMotions, sensors on the device.

You heard Steve show you the gyroscope so, you know, if you wanted to come up with an application that's only visible from the southwest or something like that you can do that with the gyroscope. There is a talk about this. I think it's called Sensing Motion-- Sensing Device Motion. Please look it up in your schedules. It wasn't available to me when we put the slides together, so.

But if you are going to be taking advantage of the gyroscope or the accelerometer, you know the high level events that are in UIKit are pretty good for sort of general applications. This is what you'll go to if you want really fine grain control over the data coming off of all of those sensors. It's a great way to introduce new ways of interacting with your data so please take advantage of that.

CF and Foundation have actually been brought up to basically Snow Leopard levels in iOS 4. So that includes blocks, it includes the regular expression stuff. All of those API's that were introduced in Snow Leopard are now available on iOS 4. The Foundation team will be giving the What's New in Foundation for iOS 4 talk in Pacific Heights on Tuesday at 10:15.

They're also giving a couple of other talks for tips and tricks and things like that. Go see those. Foundation is a tremendously powerful framework that can save a lot of time and there are some really, really great things that are now available to you on the phone that were not available before. We have labs. Oh boy, do we have labs.

We have four Cocoa Touch Labs. We almost made it all the way around the alphabet soup here. In Application Frameworks Lab D, we've got Labs Tuesday at 2, Wednesday at 11:30, Thursday at 9:00, Friday at 9:00 and Wednesday at 9 we're doing a getting started with iPad development lab.

We're here, you heard Steve say there a thousand Apple Engineers here. We can probably answer your questions. Please come to the labs. Please bring code with you so that we can take a look at it. We're really excited to be able to help you guys out with everything that's happening--

WEBVTT

00:00:12.280 --> 00:00:14.120
Good afternoon.

00:00:14.120 --> 00:00:15.040
I'm Ralaiigh Ledet.

00:00:15.190 --> 00:00:18.500
I'm a Cocoa Software Engineer and
welcome to session 115,

00:00:18.500 --> 00:00:22.690
scrolling, swiping and dragging,
now with more animation.

00:00:24.900 --> 00:00:28.260
We've got a jam-packed
session for you today.

00:00:28.260 --> 00:00:32.050
So, first off I want to preface that
everything we're gonna be talking

00:00:32.050 --> 00:00:36.480
about is all new stuff in Lion,
and of course it's only gonna

00:00:36.480 --> 00:00:38.420
be appearing on the Mac OS.

00:00:38.440 --> 00:00:40.060
So we got a lot to cover for scrolling.

00:00:40.060 --> 00:00:42.370
We've got a new look to scrollers,
and we've got a new

00:00:42.410 --> 00:00:45.880
elastic scrolling behavior,
so we're gonna cover how you can

00:00:45.880 --> 00:00:49.020
integrate this into your application.

00:00:49.020 --> 00:00:52.270
We have a new method
for doing fluid swiping.

00:00:52.280 --> 00:00:54.610
You might have already seen
this in Safari when you go

00:00:54.610 --> 00:00:57.590
back and forward in pages,
you can track what the user's doing

00:00:57.710 --> 00:01:00.740
on the trackpad and make it real nice,
smooth animation.

00:01:00.740 --> 00:01:04.990
We also have multi-image dragging,
and no longer is dragging

00:01:04.990 --> 00:01:06.440
a static process.

00:01:06.460 --> 00:01:11.780
It's no longer a fire forget where
it's just this one single image,

00:01:11.780 --> 00:01:13.090
dragging is now a static

00:01:13.180 --> 00:01:15.870
More fluid and has,
you can change the image on the

00:01:15.870 --> 00:01:19.750
fly and it's really nice so we'll
show you the API for that as well.

00:01:20.280 --> 00:01:22.660
So let's get right down to it
and start off with scrolling and

00:01:22.660 --> 00:01:24.660
our new content focused redesign.

00:01:24.660 --> 00:01:27.940
And to talk about scrollers,
I'm going to bring up Troy Stephens.

00:01:31.570 --> 00:01:34.620
So as you've all probably have
the chance to notice by now,

00:01:34.790 --> 00:01:38.110
scrollers in Lion have been the recipient
of probably the biggest redesign in

00:01:38.120 --> 00:01:43.500
their look and feel in the history
of OS X since OS X 10.0 probably.

00:01:43.530 --> 00:01:46.980
For many releases of OS X now,
we grew accustomed to sort of

00:01:46.980 --> 00:01:48.940
the trademark Aqua scroller look.

00:01:48.940 --> 00:01:52.890
The scrollers were this liquid blue
capsule on the side of your windows,

00:01:52.920 --> 00:01:56.940
on the side of your scrollable areas
that really was very eye-catching

00:01:56.940 --> 00:01:58.440
and attention-getting design.

00:01:58.440 --> 00:02:01.000
Even if you run in graphite mode
and drain them of their color,

00:02:01.000 --> 00:02:04.340
they're still kind of a heavyweight
user interface element relative to

00:02:04.340 --> 00:02:08.080
some of the other stuff in Aqua,
especially now on Lion where everything

00:02:08.080 --> 00:02:11.330
is really toned down and subdued,
everything that surrounds and

00:02:11.420 --> 00:02:13.320
accessorizes your content.

00:02:13.350 --> 00:02:14.600
But what are scrollers really?

00:02:14.660 --> 00:02:17.700
They're kind of this invention that
we came up with in the computer

00:02:17.700 --> 00:02:21.700
industry to enable users who have
a mouse to position their content

00:02:21.700 --> 00:02:25.480
within a smaller visible content area.

00:02:25.510 --> 00:02:28.760
So fast forward to Lion,
and scrollers are really just that.

00:02:28.760 --> 00:02:31.460
They're accessories that are
just there when you need them.

00:02:31.480 --> 00:02:35.140
They're much more subtle and subdued,
certainly in color.

00:02:35.160 --> 00:02:36.300
They're more slender in size.

00:02:36.400 --> 00:02:38.160
They appear only when you're scrolling.

00:02:38.180 --> 00:02:41.750
And they disappear and get out of the
way and put the focus back on your

00:02:41.830 --> 00:02:44.200
content when you're done scrolling.

00:02:44.440 --> 00:02:47.150
So what is there to know about
scrollers that will affect

00:02:47.250 --> 00:02:48.300
your applications in Lion?

00:02:48.300 --> 00:02:50.440
Well,
one of the most important things to know,

00:02:50.440 --> 00:02:54.220
first off, is that we actually have two
new scroller styles in Lion.

00:02:54.290 --> 00:02:57.500
The first that we hope people will
be using in most cases are the

00:02:57.520 --> 00:03:00.870
ones we call overlay scrollers
that I was just talking about.

00:03:00.900 --> 00:03:03.680
And these are called overlay
scrollers because they're composited

00:03:03.870 --> 00:03:05.260
atop the user's content area.

00:03:05.260 --> 00:03:07.650
So within your scroll view,
the scrollers actually now

00:03:07.650 --> 00:03:08.920
go on top of the clip view.

00:03:08.920 --> 00:03:11.790
This gives the user more
potentially viewable content area,

00:03:11.790 --> 00:03:13.780
you know,
instead of having us shave off sides

00:03:13.780 --> 00:03:17.230
of the potential content area and
devoting those entirely to scrollers

00:03:17.230 --> 00:03:19.470
that you don't need all the time,
the scrollers are

00:03:19.610 --> 00:03:21.300
composited atop the content.

00:03:21.300 --> 00:03:23.670
Again, they fade out when the
user is not scrolling,

00:03:23.860 --> 00:03:27.070
so they're just there when you need them,
and then they're out of the way,

00:03:27.180 --> 00:03:29.130
enabling you to focus on your content.

00:03:29.140 --> 00:03:31.560
Now, the first time we presented...
So the first time we presented

00:03:31.560 --> 00:03:33.950
a scroll view to the user,
the first time its window is ordered

00:03:34.020 --> 00:03:36.500
in or it's added to the window,
the scroll view has a behavior

00:03:36.500 --> 00:03:38.540
of automatically pulsing
its scrollers to visible.

00:03:38.540 --> 00:03:40.240
This is very similar
to what's done on iOS.

00:03:40.240 --> 00:03:43.950
So this gives the user a cue that, oh,
there's more to see here in this

00:03:44.010 --> 00:03:47.760
viewport than I can see right now,
and I can potentially mouse in there

00:03:47.760 --> 00:03:50.060
and touch scroll to scroll that area.

00:03:50.060 --> 00:03:53.330
This is done automatically in most of
the cases where you'd want it to be done,

00:03:53.330 --> 00:03:56.620
but you're always free to send a flash
scrollers message to your scroll view,

00:03:56.620 --> 00:03:59.320
and that will trigger the
same behavior to happen again.

00:03:59.320 --> 00:04:00.880
You can send this as
many times as you want.

00:04:00.900 --> 00:04:03.620
And we'll batch those
up and just do a nice,

00:04:03.620 --> 00:04:05.760
smooth flash of the scrollers.

00:04:05.840 --> 00:04:08.760
Now, if I put my two fingers down on
the trackpad and begin scrolling,

00:04:08.910 --> 00:04:11.780
the scrollers show,
and they stay shown for

00:04:11.890 --> 00:04:14.600
as long as I'm scrolling,
and also as long as I keep that touch

00:04:14.750 --> 00:04:16.840
held on the trackpad or Magic Mouse.

00:04:16.840 --> 00:04:19.840
Only when I let up are the
scrollers free to hide.

00:04:19.840 --> 00:04:22.030
Now, if I begin scrolling again,
once I start moving the

00:04:22.320 --> 00:04:24.370
mouse in the content area,
I have all the time in the world

00:04:24.370 --> 00:04:27.530
to get down into the scroller,
and I can use all the familiar

00:04:27.530 --> 00:04:29.710
mouse-based scroller behaviors.

00:04:29.800 --> 00:04:30.800
So I can drag the thumb.

00:04:30.800 --> 00:04:32.980
I can even option drag to find scroll.

00:04:32.980 --> 00:04:35.600
As long as the mouse stays in the track,
both of the scrollers

00:04:35.750 --> 00:04:36.680
stay pinned to visible.

00:04:36.680 --> 00:04:38.970
Only when I mouse out are
they free to hide again.

00:04:39.090 --> 00:04:41.800
So on the Mac,
you sort of get iOS scrollers now,

00:04:41.800 --> 00:04:45.090
but it's the best of both worlds because
you also have the ability to manipulate

00:04:45.340 --> 00:04:49.670
the scrollers using the mouse if and
when that's more comfortable for you.

00:04:49.870 --> 00:04:51.940
Now,
in addition to the overlay scrollers,

00:04:51.990 --> 00:04:54.920
the second style that we have,
we call the legacy scroller style.

00:04:54.920 --> 00:04:57.860
This is really the 10.6
and earlier scrollers.

00:04:57.860 --> 00:05:00.740
Restyled for Lion, so again,
they're also more subtle

00:05:00.740 --> 00:05:03.600
and subdued looking,
no bright blue capsule in there.

00:05:03.600 --> 00:05:05.550
But other than that,
they're metrics compatible with

00:05:05.720 --> 00:05:08.370
the earlier scrollers and they
have all the same behaviors.

00:05:08.520 --> 00:05:12.680
So these are provided for out-of-the-box
compatibility with existing applications,

00:05:12.950 --> 00:05:15.550
and also to accommodate the
user's preferences and any

00:05:15.550 --> 00:05:17.840
accessibility needs they might have.

00:05:17.840 --> 00:05:20.640
Now,
users on Lion can always ask for their

00:05:20.640 --> 00:05:22.560
scrollers to be shown to them always.

00:05:22.650 --> 00:05:25.760
This can be done in system preferences
under the general category,

00:05:25.760 --> 00:05:27.590
used to be called appearance.

00:05:27.590 --> 00:05:30.830
If users ask for this,
we need to show them legacy

00:05:30.830 --> 00:05:32.740
scrollers everywhere.

00:05:32.770 --> 00:05:36.070
It's a preference that they've
expressed that we need to obey.

00:05:36.670 --> 00:05:39.500
We also -- you'll see these
used if you have an application

00:05:39.500 --> 00:05:42.880
that inserts accessory views
into the scroll views margins.

00:05:42.880 --> 00:05:45.520
This has been a very useful technique
for a long time now because if you've

00:05:45.650 --> 00:05:48.660
always got the scrollers there but you
don't need the full length of the space,

00:05:48.840 --> 00:05:52.140
you can kind of shim in an extra, say,
a Zoom pop-up like you might see

00:05:52.140 --> 00:05:55.800
in text edits wrapped to page mode
or other accessory views like that.

00:05:56.100 --> 00:05:59.360
If we detect these in there,
they interfere with the potential

00:05:59.360 --> 00:06:02.000
to use overlay scrollers,
so we'll fall back to legacy scrollers,

00:06:02.060 --> 00:06:04.390
but that's a really
easy problem to solve,

00:06:04.390 --> 00:06:06.200
and I'll show you how to do it.

00:06:06.200 --> 00:06:09.470
Also when we encounter subclassed
NSScroller instances that we

00:06:09.470 --> 00:06:13.200
aren't sure are compatible with
Lion's new scroller behaviors,

00:06:13.200 --> 00:06:17.100
we will fall back to be sure we're
compatible to the legacy look and

00:06:17.200 --> 00:06:20.330
behavior as the basis for those,
but it's real easy to show

00:06:20.450 --> 00:06:25.360
us -- to inform us that your
scrollers are Lion-compatible.

00:06:26.290 --> 00:06:28.180
So, given that we have these
two scroller styles,

00:06:28.300 --> 00:06:31.810
how do we determine which one -- which
style to use in a particular case?

00:06:32.000 --> 00:06:34.560
Well, as I said,
it all goes back to appearance --

00:06:34.560 --> 00:06:37.530
to the user's general preferences,
rather.

00:06:37.670 --> 00:06:40.580
The user has a choice
in the general settings.

00:06:40.590 --> 00:06:42.260
They can ask for their
scrollers to be shown always.

00:06:42.260 --> 00:06:45.170
And again, that means we give them
legacy scrollers everywhere.

00:06:45.170 --> 00:06:47.940
They can ask for scrollers to
be shown only when scrolling.

00:06:48.050 --> 00:06:50.810
So they are explicitly asking
for overlay scrollers wherever

00:06:50.810 --> 00:06:51.960
we can give them to them.

00:06:52.190 --> 00:06:55.420
We still have to fall back in those
two cases that I mentioned to legacy

00:06:55.420 --> 00:06:59.220
scrollers if we detect accessory views
in the way or subclass scrollers that

00:06:59.220 --> 00:07:00.960
we don't know are Lion compatible.

00:07:01.000 --> 00:07:03.940
But in all other cases,
we'll give them overlay scrollers.

00:07:03.980 --> 00:07:06.840
And then the last -- and
actually the first option here,

00:07:06.930 --> 00:07:10.220
automatically based on input device,
this is the default for

00:07:10.220 --> 00:07:11.980
new and existing users.

00:07:11.980 --> 00:07:14.290
And what it tells us is you decide.

00:07:14.290 --> 00:07:16.180
It leaves it up to the system

00:07:16.330 --> 00:07:17.640
We do pointing device detection.

00:07:17.640 --> 00:07:20.370
We look at all of the trackpads
and mice and tablets and

00:07:20.370 --> 00:07:22.140
whatnot connected to the system.

00:07:22.180 --> 00:07:25.770
We look at which ones have
gesture scroll capability.

00:07:26.150 --> 00:07:28.170
And if you have external
devices connected,

00:07:28.170 --> 00:07:32.310
we'll disregard an internal trackpad
in favor of looking at the most capable

00:07:32.510 --> 00:07:36.060
external device to see if we have at
least one external device that has

00:07:36.060 --> 00:07:40.040
gesture scroll capability enabled,
then we can use overlay scrollers.

00:07:40.170 --> 00:07:42.690
The full set of rules and
logic is somewhat complicated.

00:07:42.940 --> 00:07:44.990
If you're interested
in it for some reason,

00:07:45.120 --> 00:07:48.500
you can find it explained in the
application kit release notes.

00:07:48.670 --> 00:07:52.810
But mostly we try to make
this automatic and sensible.

00:07:52.990 --> 00:07:54.680
So because we have these
two scroller styles,

00:07:54.780 --> 00:07:57.180
because users can change
their preferences over time,

00:07:57.210 --> 00:08:00.350
and because they can connect and
disconnect devices over time,

00:08:00.540 --> 00:08:03.700
your applications need to be prepared
to work with both types of scrollers.

00:08:03.850 --> 00:08:06.550
Both at app launch time and over
the lifetime of your process,

00:08:06.580 --> 00:08:08.790
the preferred scroller style may change.

00:08:08.940 --> 00:08:10.570
So you need to be able to react to that.

00:08:10.780 --> 00:08:13.520
Fortunately, in most cases,
you don't have to do anything.

00:08:13.530 --> 00:08:15.740
AppKit keeps track of all
scroll views that are in use.

00:08:15.870 --> 00:08:17.370
So if you're using scroll
views in your apps,

00:08:17.370 --> 00:08:20.050
which you most likely are,
AppKit will automatically find

00:08:20.050 --> 00:08:23.840
every scroll view instance and
send setScrollerStyle to each of

00:08:23.840 --> 00:08:27.320
your scroll views when the style
changes with the new scroller style,

00:08:27.320 --> 00:08:28.510
either overlay or legacy.

00:08:28.660 --> 00:08:31.040
The scroll view knows to
automatically update itself,

00:08:31.040 --> 00:08:34.010
update its layout, redraw,
and present the new style

00:08:34.010 --> 00:08:36.240
of scrollers to the user.

00:08:36.290 --> 00:08:39.570
But just in case you have any other code
that wants to respond to these changes,

00:08:39.570 --> 00:08:43.710
maybe there are other aspects of your
UI layout that you want to change,

00:08:43.710 --> 00:08:46.360
there's a preferred scroller
style method on NSScroller.

00:08:46.360 --> 00:08:49.360
You can always ask it, what's the system
preferred scroller style?

00:08:49.390 --> 00:08:50.360
Either overlay or legacy.

00:08:50.360 --> 00:08:54.480
And there's a notification
that you can subscribe to to

00:08:54.480 --> 00:08:55.680
observe for when this changes.

00:08:57.630 --> 00:09:01.090
Within the overlay scroller style,
just as on iOS with iOS scrollers,

00:09:01.360 --> 00:09:02.810
we actually have three sub-styles.

00:09:02.890 --> 00:09:05.500
We have different knob styles
for use on different backgrounds.

00:09:05.500 --> 00:09:10.050
So the default style is really
designed to be visible on as wide

00:09:10.050 --> 00:09:13.490
a variety of backgrounds as our
graphic designers could manage.

00:09:13.510 --> 00:09:16.860
It's sort of a semi-transparent
black with a thin white halo around

00:09:16.860 --> 00:09:20.500
it that tries to optimize for better
visibility on darker backgrounds.

00:09:20.530 --> 00:09:23.770
But if you have a background that's
really pretty dark and you try

00:09:23.770 --> 00:09:26.980
to use that default knob style,
it may be hard for the user to

00:09:26.980 --> 00:09:28.500
make out on top of that background.

00:09:28.500 --> 00:09:31.090
So if you have knowledge about
the nature of your content

00:09:31.090 --> 00:09:33.940
and is it light or is it dark,
you could in this case opt for

00:09:33.940 --> 00:09:35.500
the light scroller knob style.

00:09:35.590 --> 00:09:37.390
So this is something you
would explicitly set.

00:09:37.480 --> 00:09:39.550
If you set it on the scroll view,
the scroll view will tell

00:09:39.550 --> 00:09:41.500
both of its scrollers,
if it has two of them,

00:09:41.500 --> 00:09:42.500
to update accordingly.

00:09:42.500 --> 00:09:46.430
So just set this on the scroll view and
let the scroll view manage its scrollers.

00:09:46.510 --> 00:09:50.460
And there's also a dark style that looks
pretty much like the default style.

00:09:50.500 --> 00:09:53.430
It's a little bit lighter,
except without that light halo around it.

00:09:53.540 --> 00:09:55.490
And you'll see this in
play in Safari online.

00:09:55.680 --> 00:09:57.500
They're actually taking
advantage of this.

00:09:57.500 --> 00:10:00.410
So most web pages tend
toward lighter content.

00:10:00.760 --> 00:10:03.360
They use the default
scroller style on those.

00:10:03.580 --> 00:10:06.680
But on darker pages, such as this,
they will tell us, "Hey,

00:10:06.680 --> 00:10:07.500
use the light scroller style.

00:10:07.500 --> 00:10:10.500
We figured out that the background color,
it's overall black,

00:10:10.500 --> 00:10:13.220
so we want to use the light
scroller style." And that helps

00:10:13.300 --> 00:10:16.500
users out a lot when you have the
knowledge to be able to do that.

00:10:16.500 --> 00:10:19.500
So how do you make your scroller
subclasses overlay scroller compatible?

00:10:19.500 --> 00:10:20.500
Well, that's a great question.

00:10:20.500 --> 00:10:21.500
Well, it's really pretty easy.

00:10:21.500 --> 00:10:23.830
You might imagine that there
would be a method such as,

00:10:23.910 --> 00:10:26.610
"Is compatible with overlay
scrollers?" that you'd override,

00:10:26.610 --> 00:10:27.480
and there is.

00:10:27.570 --> 00:10:29.500
And you could simply
override that to return yes,

00:10:29.500 --> 00:10:30.500
but if you want to be
a little more clever,

00:10:30.500 --> 00:10:33.620
you can use the technique shown here
to avoid speaking for any potential

00:10:33.710 --> 00:10:37.500
subclasses of your scroller subclass
in case you're developing a framework.

00:10:37.500 --> 00:10:40.530
And the contract that you're agreeing
to here is really very simple,

00:10:40.580 --> 00:10:41.440
and it should be easy.

00:10:41.510 --> 00:10:44.470
We hope to rearrange any
code you have to keep it.

00:10:44.540 --> 00:10:47.530
The most important thing is,
if you do any drawing

00:10:47.530 --> 00:10:51.540
customization for your scrollers,
you need to override the parts-based

00:10:51.540 --> 00:10:54.500
drawing methods rather than
overriding draw-rect wholesale

00:10:54.500 --> 00:10:56.360
to draw your entire scroller.

00:10:56.610 --> 00:11:01.130
And the reason for this is that we need
to be able to show and hide the scroll

00:11:01.130 --> 00:11:03.500
thumb and the scroller track separately.

00:11:03.500 --> 00:11:08.410
The scroll thumb is visible any
time the scrolling is in progress.

00:11:08.630 --> 00:11:11.400
That's the first part of
itself that a scroller shows.

00:11:11.570 --> 00:11:15.480
The track is only visible when the user
mouses into the scroller track area.

00:11:15.500 --> 00:11:18.500
So we need to be able to fade
those in and out separately.

00:11:18.500 --> 00:11:20.500
We need to be able to call
you to draw them separately.

00:11:20.500 --> 00:11:22.420
But as far as the
crossfade and the behavior,

00:11:22.520 --> 00:11:23.500
we take care of that
automatically for you.

00:11:23.530 --> 00:11:25.390
You just draw at full opacity.

00:11:25.500 --> 00:11:30.070
And then similarly for hit testing,
override the parts-based

00:11:30.070 --> 00:11:31.500
methods if you must.

00:11:32.150 --> 00:11:34.250
You need to be okay with
the fact that scrollers,

00:11:34.250 --> 00:11:37.940
both overlay and legacy,
no longer have arrows on Lion.

00:11:37.940 --> 00:11:39.980
So if you ask for the
rect for part for arrows,

00:11:40.140 --> 00:11:42.100
we're going to return
empty rectangles for those.

00:11:42.230 --> 00:11:45.630
And you need to be okay with the
possibility that overlay scrollers

00:11:45.680 --> 00:11:49.350
may have different widths and layout
metrics than legacy scrollers,

00:11:49.440 --> 00:11:52.520
which we've painstakingly tried
to make have the exact same

00:11:52.520 --> 00:11:54.140
metrics for compatibility.

00:11:54.220 --> 00:11:57.150
In practice on Lion,
we found that for compatibility,

00:11:57.150 --> 00:11:59.930
it was best to keep the metrics the same,
but in the future, the two might diverge.

00:12:01.140 --> 00:12:05.070
Accessory views,
the second leading cause of fallback

00:12:05.070 --> 00:12:10.080
to legacy scrollers besides user
preferences and custom classes.

00:12:10.170 --> 00:12:12.250
So what are the implications
for accessory views?

00:12:12.310 --> 00:12:13.660
Why do we care about these?

00:12:13.720 --> 00:12:16.730
Well, with overlay scrollers, again,
what we're trying to do is give space

00:12:16.730 --> 00:12:18.610
and attention back to the user's content.

00:12:18.770 --> 00:12:24.830
So we've got these scrollers now
that we composite them atop the

00:12:24.830 --> 00:12:26.370
content area instead of shaving
space off of that clip view.

00:12:27.200 --> 00:12:29.680
And we automatically hide
them when they're not in use,

00:12:29.740 --> 00:12:31.140
so they don't interfere
with the user's content.

00:12:31.140 --> 00:12:33.920
But what's going to happen with your
accessory views if we don't do anything

00:12:33.920 --> 00:12:37.940
about them is they'll end up laid out
atop an edge of the user's content area.

00:12:37.940 --> 00:12:41.040
Now, that could be unimportant margin,
or it could be important content

00:12:41.040 --> 00:12:43.660
that the user needs to be able
to click on to select or interact

00:12:43.660 --> 00:12:45.120
with something we don't know.

00:12:45.140 --> 00:12:48.120
So we probably need to do something
about it when we see them.

00:12:48.120 --> 00:12:51.700
We can't really leave them
obscuring the user's content

00:12:51.700 --> 00:12:53.720
for the reasons I just gave,
but at the same time,

00:12:53.720 --> 00:12:57.330
if we were to presume to automatically
hide them with the scrollers,

00:12:57.430 --> 00:12:59.010
well,
that could be problematic for users too,

00:12:59.150 --> 00:12:59.400
right?

00:12:59.460 --> 00:13:03.060
I don't want to have to touch scroll just
so that I can get my zoom pop-up to show

00:13:03.060 --> 00:13:04.940
so I can change the zoom on my document.

00:13:04.940 --> 00:13:06.570
That's not going to
be what I want either.

00:13:06.580 --> 00:13:09.240
So therefore,
when we see those accessory views

00:13:09.240 --> 00:13:12.880
just in the right-hand or bottom
scroller margins of a scroll view

00:13:12.880 --> 00:13:16.190
where we think the scroller should be,
we'll fall back just for that scroll view

00:13:16.190 --> 00:13:17.840
instance to the legacy scroller style.

00:13:17.840 --> 00:13:19.410
So you may see this happen
in your applications.

00:13:19.440 --> 00:13:22.380
It's really easy to solve by
just moving that UI elsewhere.

00:13:22.380 --> 00:13:24.240
As soon as we don't see
accessory views anymore,

00:13:24.240 --> 00:13:25.520
that scroll view is eligible.

00:13:25.540 --> 00:13:26.760
It's also possible to
use overlay scrollers.

00:13:26.760 --> 00:13:30.350
A few quick notes about
API changes related to this.

00:13:30.510 --> 00:13:32.840
First of all,
if you have ever tried to subclass in a

00:13:32.840 --> 00:13:36.200
scroller to provide a custom appearance,
you may be happy to know that

00:13:36.200 --> 00:13:39.700
AppKit now consistently consumes
our public rec-for-part API,

00:13:39.700 --> 00:13:43.520
so you can override that to change the
layout of elements of your scroller.

00:13:45.290 --> 00:13:47.680
The methods and constants for
dealing with arrows are of course

00:13:47.680 --> 00:13:48.990
they're soft deprecated now.

00:13:48.990 --> 00:13:51.660
You can still call them but
they don't really mean anything.

00:13:51.730 --> 00:13:54.230
And incidentally the control
tint we used to have this

00:13:54.340 --> 00:13:56.140
Aqua versus graphite control tint.

00:13:56.350 --> 00:14:02.280
That doesn't really affect
scrollers anymore for either style.

00:14:02.280 --> 00:14:02.280
They have the same appearance
for blue or graphite.

00:14:02.790 --> 00:14:05.490
There are some layout methods,
class methods on scroller and

00:14:05.630 --> 00:14:08.220
scroll view that have been useful
if you're creating your scrollers

00:14:08.280 --> 00:14:11.350
and scroll views programmatically,
and you want to pre-flight

00:14:11.350 --> 00:14:14.120
the layout and figure out how
much space am I going to need.

00:14:14.120 --> 00:14:16.150
For scroller,
there's a new replacement method,

00:14:16.150 --> 00:14:18.540
scroller width for control size,
scroller style,

00:14:18.540 --> 00:14:23.070
that lets you specify regular or small
scroller size and also which style,

00:14:23.070 --> 00:14:25.190
legacy or overlay,
because that may make a

00:14:25.190 --> 00:14:26.540
difference in the future.

00:14:26.540 --> 00:14:28.490
So the older methods,
you can still use them,

00:14:28.490 --> 00:14:31.350
but they assume regular control
size and whatever the system's

00:14:31.470 --> 00:14:33.400
preferred scroller style is.

00:14:33.400 --> 00:14:35.620
Likewise on scroll view,
frame size for content

00:14:35.680 --> 00:14:38.950
size and its counterpart,
content size for frame size, et cetera,

00:14:39.130 --> 00:14:41.860
new replacements that allow
for the possibility that

00:14:41.860 --> 00:14:45.510
scrollers are subclassed,
that you may be using regular or small

00:14:45.600 --> 00:14:49.820
control style for your scrollers,
and that the scroller style, again,

00:14:49.820 --> 00:14:51.260
may be legacy or overlay.

00:14:51.260 --> 00:14:54.700
The existing methods, still usable,
but they assume no subclassing,

00:14:54.860 --> 00:14:59.040
regular control size and the system's
current preferred scroller style.

00:14:59.040 --> 00:15:00.540
And that really is all there
is to know about scrollers.

00:15:00.540 --> 00:15:03.690
But there's a whole lot more
to know about enhancements to

00:15:03.820 --> 00:15:06.350
scrolling and swiping and dragging.

00:15:06.360 --> 00:15:08.370
And for that,
I'll return you to my colleague,

00:15:08.370 --> 00:15:09.130
Raleigh Lede.

00:15:09.180 --> 00:15:10.130
Thank you.

00:15:10.140 --> 00:15:10.140
Raleigh Lede: Thank you, Troy.

00:15:14.770 --> 00:15:18.530
So continuing with our
content-focused redesign of scrolling,

00:15:18.530 --> 00:15:23.900
we've brought over elastic scrolling,
also known as rubber banding from iOS.

00:15:24.010 --> 00:15:27.340
Since the scrollers aren't visible,
we need to provide some more feedback

00:15:27.340 --> 00:15:31.660
to the user on what is scrollable and
what directions that the user can scroll.

00:15:31.830 --> 00:15:35.600
And you can participate as
well in this as a developer.

00:15:35.600 --> 00:15:38.300
In a scroll view we have
a couple of new methods,

00:15:38.400 --> 00:15:41.480
horizontal scroll elasticity,
vertical scroll elasticity,

00:15:41.660 --> 00:15:43.430
and their associated set methods.

00:15:43.600 --> 00:15:48.180
And likewise, in Xcode 4,
right in the interface editor,

00:15:48.180 --> 00:15:51.420
you can select the scroll view and
change the settings right there

00:15:51.420 --> 00:15:52.840
with a couple of pop-up buttons.

00:15:53.040 --> 00:15:56.040
So what in a scroll
elasticity options do we have?

00:15:56.040 --> 00:15:59.680
Well, the default is in a scroll
elasticity automatic.

00:15:59.690 --> 00:16:02.020
We have some heuristics in
place that try and figure out

00:16:02.020 --> 00:16:03.630
the look at your document view.

00:16:03.650 --> 00:16:06.680
How big is it compared to
the size of the scroll view?

00:16:06.730 --> 00:16:10.650
And we err to the side
of vertical scrolling.

00:16:10.660 --> 00:16:13.480
Most things are going to be
vertically scrolling oriented.

00:16:13.490 --> 00:16:17.380
And we automatically figure out which
axis we should allow scrolling--scroll

00:16:17.400 --> 00:16:19.240
rubber banding to happen on.

00:16:19.250 --> 00:16:21.320
But this doesn't always
work in all cases.

00:16:21.330 --> 00:16:24.200
Particularly a good example
where our heuristics fall down

00:16:24.360 --> 00:16:27.740
is if your application has a
timeline and the timeline scrolls

00:16:28.030 --> 00:16:32.810
dominantly in the horizontal axis,
or possibly only in the horizontal axis.

00:16:32.830 --> 00:16:34.820
In that case,
you would want to set the vertical

00:16:34.820 --> 00:16:37.260
axis to NS scroll elasticity none.

00:16:37.260 --> 00:16:40.420
Now when the user attempts to
scroll in the vertical axis,

00:16:40.420 --> 00:16:44.110
you won't get any rubber banding on
that axis and the user knows that

00:16:44.350 --> 00:16:49.190
content will not continue to go
down in the vertical orientation,

00:16:49.190 --> 00:16:50.950
so they're not missing anything.

00:16:51.350 --> 00:16:55.170
But likewise you're going to want
to set NSScrollElasticityAloud

00:16:55.420 --> 00:16:57.590
on the horizontal axis.

00:16:57.660 --> 00:17:00.670
This way,
even if your content for the timeline,

00:17:00.670 --> 00:17:04.490
like when you create a new document,
it hasn't created enough content

00:17:04.570 --> 00:17:07.690
to exceed the bounds of the scroll
view on the horizontal axis yet.

00:17:07.820 --> 00:17:10.170
We will still rubber band
on the horizontal axis.

00:17:10.200 --> 00:17:13.880
And this gives feedback to the user
to let them know that in general for

00:17:13.980 --> 00:17:19.200
this document and this particular view
that there will be horizontal content

00:17:19.270 --> 00:17:22.080
that they will want to scroll to,
if not now, definitely in the future.

00:17:23.660 --> 00:17:25.140
That's the scroll elasticity settings.

00:17:25.140 --> 00:17:29.240
We also have another property here,
"Users' Predominant Axis Scrolling."

00:17:29.410 --> 00:17:31.360
And this is an interesting,
uh, property.

00:17:31.460 --> 00:17:34.160
If you look at a traditional
scroll wheel mouse,

00:17:34.160 --> 00:17:35.960
you can only scroll in
one direction at a time,

00:17:35.960 --> 00:17:38.780
typically vertically,
or if you know the appropriate modifier

00:17:38.780 --> 00:17:41.530
key to hold down while you scroll,
you can actually scroll

00:17:41.580 --> 00:17:43.100
in the horizontal axis.

00:17:43.320 --> 00:17:45.940
But you can only scroll
on one axis at a time.

00:17:46.140 --> 00:17:47.840
With the introduction
of the Mighty Mouse,

00:17:47.840 --> 00:17:51.930
for that matter, but also, in particular,
the Magic Trackpad and the Magic Mouse,

00:17:52.090 --> 00:17:55.250
we allow the user to scroll
on both axes at the same time.

00:17:55.440 --> 00:17:59.380
And this works really great for
certain types of applications,

00:17:59.450 --> 00:18:01.440
a drawing application,
a painting application,

00:18:01.440 --> 00:18:04.440
or perhaps you're showing a map
or some kind of large canvas area,

00:18:04.580 --> 00:18:07.390
and you get a nice panning
effect whenever the user scrolls.

00:18:07.440 --> 00:18:09.170
It works out really great.

00:18:09.360 --> 00:18:11.930
But in other applications,
this doesn't work so well.

00:18:12.080 --> 00:18:16.280
Perhaps some kind of text editing
document or just browsing the web,

00:18:16.500 --> 00:18:19.010
where generally what the user
wants to do there is scroll

00:18:19.260 --> 00:18:21.380
in one direction at a time.

00:18:21.500 --> 00:18:24.090
And the problem is,
the problem with the Magic Mouse and

00:18:24.090 --> 00:18:28.410
the Magic Trackpad is it's real hard as
a user to move your fingers perfectly

00:18:28.410 --> 00:18:30.430
vertically or perfectly horizontal.

00:18:30.550 --> 00:18:32.940
You're gonna have some
drift along the other axis.

00:18:33.000 --> 00:18:35.440
And this is gonna come
through a scroll wheel event,

00:18:35.660 --> 00:18:37.940
and a scroll view will
scroll in that direction.

00:18:37.940 --> 00:18:39.440
You'll see this drift.

00:18:39.440 --> 00:18:42.940
And if your content-- this isn't
the appropriate way to view it,

00:18:42.940 --> 00:18:45.920
this isn't what your user
is going to intend to do,

00:18:45.940 --> 00:18:50.940
you can set user's predominant axis
scrolling to "yes," and we will attempt

00:18:50.940 --> 00:18:51.940
to treat the devices more like this.

00:18:51.940 --> 00:18:54.440
So we'll make the user a
scrolling only in one axis,

00:18:54.440 --> 00:18:58.700
and whichever axis they're
dominantly scrolling at the time.

00:19:01.470 --> 00:19:03.400
Thank you.

00:19:03.540 --> 00:19:06.890
As I'm sure a lot of you that's
installed Line have already seen,

00:19:07.090 --> 00:19:09.540
when you move your fingers
up on the trackpad,

00:19:09.630 --> 00:19:10.760
your content scrolls up.

00:19:10.850 --> 00:19:14.120
We want to have the feeling that you're
-- the user's actually physically

00:19:14.220 --> 00:19:17.840
moving their content as opposed
to moving the thumb in a scroller.

00:19:17.840 --> 00:19:20.510
And likewise,
whenever you bring your fingers down,

00:19:20.600 --> 00:19:22.960
the content scrolls in
the other direction.

00:19:22.960 --> 00:19:25.760
This feels really great
and we really love it.

00:19:25.760 --> 00:19:29.160
But for some people, they really, really,
really want the traditional

00:19:29.160 --> 00:19:31.110
way that scrolling worked.

00:19:31.120 --> 00:19:33.660
So we have user preference in trackpad
and also in mouse that they can

00:19:33.740 --> 00:19:35.840
set this on content follows finger.

00:19:35.840 --> 00:19:38.740
And the way we actually perform
this is deep down in the system,

00:19:38.740 --> 00:19:41.690
we look at the user setting and
whatever the hardware is doing,

00:19:41.760 --> 00:19:44.220
because the hardware still
does what it did before,

00:19:44.220 --> 00:19:47.910
we invert the delta X and the delta
Y automatically for you and you

00:19:48.320 --> 00:19:50.680
automatically get the new behavior.

00:19:50.920 --> 00:19:53.280
Unfortunately,
this doesn't work in some cases

00:19:53.450 --> 00:19:56.760
where already you were looking at
the scrolling delta and figured

00:19:56.950 --> 00:19:59.160
out what the correct direction is.

00:19:59.290 --> 00:20:00.390
Perhaps you were doing
a volume controller,

00:20:00.390 --> 00:20:00.830
for example.

00:20:00.840 --> 00:20:03.590
And scrolling up always increased
the volume and scrolling

00:20:03.590 --> 00:20:05.060
down decreased the volume.

00:20:05.060 --> 00:20:06.660
And that made perfect sense.

00:20:06.660 --> 00:20:10.270
And now if the user has content
follows finger set to yes,

00:20:10.370 --> 00:20:13.540
this is completely inverted for you.

00:20:13.540 --> 00:20:15.780
In these rare cases,
when it's appropriate,

00:20:15.780 --> 00:20:20.000
you can look on the scroll wheel event
for is direction inverted from device

00:20:20.000 --> 00:20:23.870
and regardless of the user setting,
you can now re-invert the

00:20:23.870 --> 00:20:27.640
scrolling delta and up will
always be increase the volume,

00:20:27.880 --> 00:20:30.410
down will always be decrease the volume.

00:20:30.800 --> 00:20:32.780
Regardless of what the user setting is.

00:20:32.780 --> 00:20:35.630
In general, please though,
respect the user's preference unless

00:20:35.630 --> 00:20:39.180
it absolutely positively makes sense
for your application and in your

00:20:39.180 --> 00:20:41.590
specific situation in your application.

00:20:43.720 --> 00:20:47.100
We also have some new scrolling delta
X and scrolling delta Y properties

00:20:47.100 --> 00:20:49.570
on NSEvent for scroll wheel events.

00:20:49.610 --> 00:20:53.490
These supersede the traditional
delta X and delta Y because we

00:20:53.680 --> 00:20:56.590
hopefully--they will have more
precise scrolling information in them.

00:20:56.600 --> 00:20:58.600
And what do I mean there?

00:20:58.600 --> 00:21:03.600
Traditionally, every time you have a tick
of the scroll wheel happens,

00:21:03.600 --> 00:21:05.570
you want to move what
we call line height.

00:21:05.670 --> 00:21:07.590
You want to move one whole line.

00:21:07.600 --> 00:21:11.510
In this example, a line would be the one
row of the table here.

00:21:11.620 --> 00:21:15.600
If you had a tick of the scroll wheel,
you would move one line.

00:21:15.600 --> 00:21:18.600
Well, with the latest
Magic Mouse and Mighty Mouse,

00:21:18.600 --> 00:21:22.600
we have much more precise
information that we can give you,

00:21:22.600 --> 00:21:24.460
and we've been doing this for some time.

00:21:24.610 --> 00:21:28.600
And with these more precise information,
instead of scrolling a whole line,

00:21:28.600 --> 00:21:30.600
you scroll that number
of points in your view,

00:21:30.600 --> 00:21:34.600
and it's a much more fluid and better
feeling scrolling behavior to the user.

00:21:34.890 --> 00:21:39.600
And NSScrollView has automatically
taken advantage of this for some time,

00:21:39.600 --> 00:21:41.600
but it hasn't been public.

00:21:41.600 --> 00:21:43.760
So if you're not using an
NSScrollView for some reason and

00:21:43.760 --> 00:21:47.600
you're looking directly at the deltas,
we will now have a public way for you

00:21:47.600 --> 00:21:50.350
to get to this more precise information.

00:21:50.650 --> 00:21:53.990
But you can also check the has
precise scrolling deltas property.

00:21:54.100 --> 00:21:57.080
If this returns no,
then the scrolling delta x and

00:21:57.190 --> 00:22:00.900
scrolling delta y will contain line
scrolling deltas and you need to

00:22:00.990 --> 00:22:05.280
multiply by whatever your line height
is whenever you do your scrolling.

00:22:06.550 --> 00:22:10.050
We also have a couple of new,
an additional two properties

00:22:10.200 --> 00:22:14.910
on NSScrollWheelEvent which
is phase and momentum phase.

00:22:15.140 --> 00:22:17.240
And let's talk about
why you might use these.

00:22:17.360 --> 00:22:20.840
NSScrollView handles precise
scrolling deltas as I mentioned.

00:22:20.840 --> 00:22:28.870
It also handles the phase,
the momentum phase,

00:22:28.870 --> 00:22:30.610
and these are the couple events
properties that we rely on to do

00:22:30.610 --> 00:22:30.610
rubber-banding and elasticity.

00:22:30.790 --> 00:22:34.190
So if you're using it in a scroll view,
you don't even have to worry about them.

00:22:34.290 --> 00:22:38.740
But perhaps you have a volume controller
and when the user does a quick motion

00:22:38.740 --> 00:22:43.150
on the Magic Trackpad and this will
generally in a scroll view continue

00:22:43.150 --> 00:22:46.800
to scroll the content with momentum,
you don't want to do that

00:22:46.800 --> 00:22:48.380
in your volume controller.

00:22:48.380 --> 00:22:51.540
Would that really make a lot of
sense where the user moves their

00:22:51.540 --> 00:22:54.670
finger a little bit and this
extra momentum scroller slams the

00:22:54.670 --> 00:22:56.210
volume all the way up to high?

00:22:56.210 --> 00:22:58.160
It's probably not what the user wants.

00:22:58.160 --> 00:23:00.600
So by looking at the phase and
the momentum phase properties,

00:23:00.600 --> 00:23:04.680
you can determine which scroll events
you want to filter out from your --

00:23:04.680 --> 00:23:07.400
from interacting with your control.

00:23:07.420 --> 00:23:11.110
Likewise, perhaps you have,
let's say here,

00:23:11.110 --> 00:23:13.640
a time code in a cell or a view.

00:23:13.640 --> 00:23:15.990
And the user starts scrolling in
your time code and they can change

00:23:15.990 --> 00:23:19.520
between the hours and the minutes
and you automatically start updating

00:23:19.520 --> 00:23:23.220
the appropriate subpart of your
view and they go into a momentum

00:23:23.220 --> 00:23:25.480
scroll by flicking on the mouse.

00:23:26.090 --> 00:23:29.660
AppKit is going to lock those
scroll events to your view.

00:23:29.660 --> 00:23:32.400
So even if the user moves the
cursor outside of your view,

00:23:32.410 --> 00:23:35.450
you're going to continue to
get these scroll wheel events.

00:23:35.570 --> 00:23:40.340
Well, what part of your time code
should you update at that point?

00:23:40.380 --> 00:23:44.630
By looking at where the mouse was
when the momentum phase started,

00:23:44.630 --> 00:23:48.170
you can then lock it to the
appropriate part of your time

00:23:48.170 --> 00:23:52.400
code and continue to update just
that portion of your time code.

00:23:52.410 --> 00:23:55.500
So regardless of what the
user does with the mouse.

00:23:56.170 --> 00:23:59.600
A traditional scroll wheel
is completely relative.

00:23:59.770 --> 00:24:04.870
Every time there's a turn of the wheel,
we get a single scroll wheel event.

00:24:05.070 --> 00:24:06.900
We don't know when the user's
touching the scroll wheel.

00:24:06.900 --> 00:24:09.860
We don't know when they stop
touching the scroll wheel.

00:24:09.860 --> 00:24:11.760
We don't have any of that information.

00:24:11.850 --> 00:24:13.880
So every time the user does
a tick on the scroll wheel,

00:24:14.030 --> 00:24:16.390
the new phase,
the momentum phase properties

00:24:16.510 --> 00:24:18.390
are gonna be NSEventPhaseNone.

00:24:18.490 --> 00:24:21.620
And this is one interesting way
for you to determine by looking

00:24:21.680 --> 00:24:24.660
at any scroll wheel event,
did this event come from a

00:24:24.660 --> 00:24:27.670
gesture scrolling device,
or did it come from a

00:24:27.670 --> 00:24:30.080
scroll wheel type of mouse?

00:24:31.020 --> 00:24:33.530
On the other hand,
something like the Magic Mouse,

00:24:33.650 --> 00:24:35.960
we can tell exactly when
the user starts touching it,

00:24:36.220 --> 00:24:38.410
but no events get sent out at
this point because with one

00:24:38.590 --> 00:24:39.940
finger the user might click.

00:24:39.940 --> 00:24:41.820
We don't know what they're doing yet.

00:24:41.930 --> 00:24:43.470
But once they start moving
their finger a little bit,

00:24:43.610 --> 00:24:46.680
we latch on that, ah-ha,
the user is doing a scroll gesture.

00:24:46.710 --> 00:24:49.080
So scroll wheel event comes in,
and it's going to have a

00:24:49.110 --> 00:24:51.680
phase of NSEventPhaseBegan.

00:24:51.800 --> 00:24:55.250
And a quick way of looking at this
is phase represents the physical

00:24:55.250 --> 00:24:59.550
gesture that the user is performing,
and momentum phase is going to

00:24:59.550 --> 00:25:03.760
be the virtual gesture that the
device does on behalf of the user,

00:25:03.890 --> 00:25:07.730
depending on the velocity that they
ended the physical gesture with.

00:25:07.840 --> 00:25:09.740
So the user started a
physical gesture here.

00:25:09.740 --> 00:25:12.290
The first event has an NSEventPhaseBegan.

00:25:12.570 --> 00:25:16.640
This is the beginning of what
I call a gesture scroll sequence.

00:25:16.640 --> 00:25:19.740
The scroll sequence has a begin,
it has some change events,

00:25:19.890 --> 00:25:20.970
and it has an end.

00:25:20.980 --> 00:25:23.880
So as the user continues to
move their finger across,

00:25:24.020 --> 00:25:26.220
more scroll wheel events come in,
and they will have a phase

00:25:26.220 --> 00:25:27.860
of NSEventPhaseChanged.

00:25:27.860 --> 00:25:32.110
It's easy to tell that this is
still a gesture scrolling sequence

00:25:32.110 --> 00:25:38.160
tied to the very first NSEventBegan
event that we saw earlier.

00:25:38.310 --> 00:25:40.500
At some point,
the user is going to lift their finger,

00:25:40.590 --> 00:25:45.330
and we'll get another scroll wheel
event with a phase of NSEventPhaseEnded.

00:25:45.430 --> 00:25:47.840
And you'll also have a
scrolling delta of 00.

00:25:47.840 --> 00:25:50.950
If this is important to you,
you'll -- the scrolling deltas

00:25:51.100 --> 00:25:53.210
for NSEventPhaseEnded is 0.

00:25:53.280 --> 00:25:55.160
At this point,
the user has physically ended

00:25:55.160 --> 00:25:57.850
their gesture and life completed.

00:25:57.860 --> 00:25:59.410
continue.

00:25:59.770 --> 00:26:01.470
But that's not quite the
end of the story because,

00:26:01.620 --> 00:26:04.200
as I said earlier,
the user might have some velocity

00:26:04.200 --> 00:26:05.700
when they lift their finger.

00:26:05.840 --> 00:26:08.040
And when they do that,
you'll get that one

00:26:08.040 --> 00:26:11.550
NSEVENT_PHASE_ENDED event to
finish off the physical gesture.

00:26:11.870 --> 00:26:16.640
It will have its delta of . And then
that might be followed up with a scroll

00:26:16.720 --> 00:26:21.230
wheel event with a phase of none,
but a momentum phase of . And this

00:26:21.460 --> 00:26:23.700
follows the same gesture sequence.

00:26:23.700 --> 00:26:27.510
You get a . As the momentum dies down,
you get a series of

00:26:27.510 --> 00:26:31.430
NSEVENT_PHASE_CHANGED in
the momentum phase property.

00:26:31.700 --> 00:26:34.700
And then finally,
once the momentum has ended,

00:26:34.700 --> 00:26:36.860
you'll get a final scroll
wheel event with a momentum

00:26:36.930 --> 00:26:39.560
phase of NSEVENT_PHASE_ENDED.

00:26:41.330 --> 00:26:44.800
So that's the basics of what's
going on with scrolling.

00:26:44.860 --> 00:26:51.290
If you just use an NSScrollView,
a lot of it is handled for you.

00:26:51.290 --> 00:26:55.730
If you need to look at
the raw scroll events,

00:26:55.730 --> 00:26:57.830
you can determine when a
physical gesture is occurring,

00:26:57.830 --> 00:26:57.830
when a virtual gesture is occurring,
or if it's occurring just

00:26:57.830 --> 00:26:57.830
from a scroll wheel device.

00:26:58.330 --> 00:27:00.200
Let's move ahead to fluid swiping.

00:27:00.200 --> 00:27:03.760
This is something you've seen in Safari.

00:27:03.760 --> 00:27:06.600
We also have it in preview
and in iCal and Quick Look.

00:27:06.620 --> 00:27:12.540
It's a nice way of moving between pages
back and forward and it behaves similar

00:27:12.790 --> 00:27:18.740
to what you see on iOS where you get the
nice one bounce back and you're scrolling

00:27:18.740 --> 00:27:24.760
with two fingers on a Magic Trackpad and
you keep going a second time and you get

00:27:24.760 --> 00:27:25.070
a nice back and forward with the pages.

00:27:25.730 --> 00:27:28.100
And if you pay attention,
what you'll realize is fluid

00:27:28.230 --> 00:27:29.790
swiping is just scrolling.

00:27:29.990 --> 00:27:30.470
That's all it is.

00:27:30.470 --> 00:27:33.270
It's just a new way
of tracking scrolling.

00:27:35.680 --> 00:27:38.700
Anybody that's using an In-a-Scroll view,
this should look a very

00:27:38.700 --> 00:27:40.550
familiar responder chain to you.

00:27:40.790 --> 00:27:44.020
You start off with your Document View,
and a scroll wheel event is going to

00:27:44.020 --> 00:27:45.600
be hit tested to your Document View.

00:27:45.600 --> 00:27:47.600
That's when the cursor is over.

00:27:47.640 --> 00:27:50.540
And your Document View doesn't do
anything with the scroll wheel event.

00:27:50.700 --> 00:27:53.500
It just gets past the responder chain,
gets to the In-a-Scroll View,

00:27:53.600 --> 00:27:57.600
and the scroll view does scrolling,
it does rubber banding,

00:27:57.600 --> 00:28:00.600
it does everything it needs to do,
and it eats the event.

00:28:00.660 --> 00:28:05.600
Well, if fluid swiping is just a
new way of tracking scrolling,

00:28:05.600 --> 00:28:07.740
we need to get the scroll event
to your View Controller so

00:28:07.740 --> 00:28:09.600
that you can perform a swipe.

00:28:09.600 --> 00:28:14.600
And instead of changing properties
on the scroll view directly,

00:28:14.600 --> 00:28:16.450
in your View Controller,
you just override this

00:28:16.550 --> 00:28:19.230
new In-a-Responder method,
"Want scroll events for swipe

00:28:19.320 --> 00:28:22.590
tracking on axis?" And depending on
the axis and what you want to do,

00:28:22.700 --> 00:28:27.470
you return "Yes." And when you do that,
if we re-look at the sequence,

00:28:27.600 --> 00:28:29.550
the scroll event comes
to the Document View,

00:28:29.600 --> 00:28:32.520
comes up to the scroll view,
scroll view determines if it

00:28:32.580 --> 00:28:35.600
needs to do the single bounce,
or if you're already at the edge,

00:28:35.600 --> 00:28:38.600
what is the user preference,
it looks at all of that,

00:28:38.720 --> 00:28:42.600
then it might ask of the responder chain,
"Get into your View Controller,

00:28:42.600 --> 00:28:45.600
"Want scroll events for
swipe tracking on this axis,

00:28:45.670 --> 00:28:49.600
"horizontal or vertical?" And your
View Controller is going to say,

00:28:49.600 --> 00:28:52.700
"Yes, I want to track a swipe." And the
scroll view will then go ahead and

00:28:52.700 --> 00:28:55.600
forward that scroll wheel event
right to your View Controller,

00:28:55.600 --> 00:28:58.920
and you can go ahead and start
tracking it as a fluid swipe.

00:28:59.380 --> 00:29:01.530
But that's not quite
the end of the story.

00:29:01.840 --> 00:29:03.790
Turns out we have a user
preference for this.

00:29:03.820 --> 00:29:07.900
The user can actually turn this
off if they don't want to perform

00:29:07.900 --> 00:29:12.640
fluid swiping with scrolling to go
backwards and forwards in pages.

00:29:12.760 --> 00:29:15.300
Well, NSScrollView,
and it already looks at this

00:29:15.300 --> 00:29:18.400
user preference for you and it
respects this user preference,

00:29:18.400 --> 00:29:22.040
and it will not forward scroll
wheel events up the responder

00:29:22.040 --> 00:29:25.450
chain regardless if you want
to track it as a swipe or not.

00:29:25.700 --> 00:29:27.790
But that's not the only way
that your controller might

00:29:27.960 --> 00:29:29.210
get a scroll wheel event.

00:29:29.240 --> 00:29:31.880
If you're just,
if you're tracking this in just

00:29:32.020 --> 00:29:36.040
your generic window controller,
you, scroll wheel events might come from

00:29:36.040 --> 00:29:39.110
the sidebar if the user is over a
sidebar or a toolbar or somewhere

00:29:39.110 --> 00:29:41.640
else that there isn't a scroll view.

00:29:41.640 --> 00:29:45.880
And performing a swipe might
perfectly be acceptable while the

00:29:45.880 --> 00:29:48.320
user's cursor is over the sidebar.

00:29:48.450 --> 00:29:50.640
But in those conditions when your
scroll wheel event is called,

00:29:50.640 --> 00:29:52.640
you will need to check
to make sure that it is,

00:29:52.640 --> 00:29:55.400
it does have a phase that
is not equal to none,

00:29:55.410 --> 00:29:57.240
so that it is coming
from a gesture device.

00:29:57.240 --> 00:30:00.400
You don't know when a regular
scroll wheel begins and ends,

00:30:00.400 --> 00:30:02.400
so we can't track that as a fluid swipe.

00:30:02.410 --> 00:30:06.800
And also check the user's preference
with this new category method on NSEvent.

00:30:06.970 --> 00:30:10.970
Is swipe tracking from
scroll events enabled?

00:30:12.960 --> 00:30:18.140
So this is sort of a
scary block of code here.

00:30:18.140 --> 00:30:21.630
I want to point out that-- don't
panic-- that we have sample code that

00:30:21.630 --> 00:30:22.880
I'm going to show you in a little bit.

00:30:22.960 --> 00:30:24.850
So I'm just going to point
out key portions of this.

00:30:24.860 --> 00:30:29.100
And this is kind of some stripped
down coding and compressed.

00:30:29.110 --> 00:30:33.580
But when you get a scroll wheel
event in your view controller,

00:30:33.580 --> 00:30:37.460
what you want to do is, on that event,
call track_swipe_event_with_options

00:30:37.460 --> 00:30:40.920
dampen_amount_threshold_men_max
using handler.

00:30:40.940 --> 00:30:43.400
And then you pass it a block.

00:30:43.400 --> 00:30:45.540
And we return a bunch of properties.

00:30:45.560 --> 00:30:46.940
And this block is going
to get called back.

00:30:46.940 --> 00:30:48.380
And it's going to do all
the tracking for you.

00:30:48.440 --> 00:30:54.620
And it will have a consistent
way of tracking a fluid swipe

00:30:54.620 --> 00:30:56.640
across all applications,
as long as you do this.

00:30:56.770 --> 00:31:00.830
So you don't have to track it manually
and worry about the end of the phase of

00:31:00.830 --> 00:31:03.360
the event from the scroll wheel directly.

00:31:03.440 --> 00:31:05.940
Instead,
we get you this nice block that we

00:31:06.040 --> 00:31:09.790
call back as we continue to track
the scroll wheel events for you.

00:31:09.800 --> 00:31:12.990
And the first thing you see in
there is We have a gesture amount.

00:31:13.150 --> 00:31:16.120
So when you're tracking a fluid swipe,
you start off at zero and you're

00:31:16.120 --> 00:31:21.320
going to go to 100% or negative
100% depending on the direction.

00:31:21.320 --> 00:31:24.680
And we give this to you in
floating values between zero

00:31:24.680 --> 00:31:26.650
and one or over to negative one.

00:31:26.880 --> 00:31:33.250
And there are actually
cases where you can get,

00:31:33.250 --> 00:31:33.250
you can go past one.

00:31:33.250 --> 00:31:33.250
We'll get into that in a little bit.

00:31:33.800 --> 00:31:36.810
Generally all you have to do is just
move your overlay content appropriately.

00:31:36.820 --> 00:31:42.370
It's supposed to be 50% swipe,
you move your content over 50%

00:31:42.370 --> 00:31:44.570
of however wide your view is.

00:31:45.340 --> 00:31:49.340
We also have a phase value that's
passed into your block every

00:31:49.340 --> 00:31:50.960
time we go into this block.

00:31:51.170 --> 00:31:55.440
And just like a scroll wheel sequence,
you have a sequence here as well.

00:31:55.440 --> 00:32:03.110
You're guaranteed to get an
NSEventPhaseBegin to start things off.

00:32:03.110 --> 00:32:03.110
And at that point,
it's a great time for you to

00:32:03.110 --> 00:32:03.110
go ahead and show your overlay.

00:32:03.420 --> 00:32:07.320
If you get an NSEventPhase ended,
this is the physical end of the gesture.

00:32:07.360 --> 00:32:10.100
Go ahead--it means it
completed successfully,

00:32:10.100 --> 00:32:13.960
so go ahead and update your
model--your data model.

00:32:13.960 --> 00:32:18.040
If you get an NSEventPhase canceled,
this is another form that the user

00:32:18.040 --> 00:32:22.010
has physically ended the gesture,
but it didn't end successfully.

00:32:22.460 --> 00:32:24.740
Perhaps it didn't swipe
far enough or fast enough,

00:32:24.740 --> 00:32:27.250
or they started going in one
direction and started going

00:32:27.250 --> 00:32:29.390
back in the opposite direction.

00:32:29.510 --> 00:32:34.540
For a number of factors that we will
deal with in heuristics for you,

00:32:34.540 --> 00:32:36.280
it wasn't a successful swipe.

00:32:36.280 --> 00:32:37.470
It was a cancel.

00:32:37.520 --> 00:32:39.380
If it's a cancel,
you don't need to update your data model.

00:32:39.380 --> 00:32:41.240
You don't need to do much of anything.

00:32:41.240 --> 00:32:42.530
But again,
this isn't quite the end of the

00:32:42.530 --> 00:32:46.130
story because even though the
user's physically ended the gesture,

00:32:46.240 --> 00:32:48.870
we need to continue to call back
to your block with the appropriate

00:32:48.870 --> 00:32:52.130
animation curves in continuing to
modify the gesture amount to go

00:32:52.360 --> 00:32:58.200
to 1 or -1 if it was a success or
back to 0 if it was unsuccessful.

00:32:58.200 --> 00:33:00.000
So we will continue to
call back into your block,

00:33:00.000 --> 00:33:02.720
and the phase will be none,
and at some point,

00:33:02.720 --> 00:33:06.370
the isComplete property
will be set to yes.

00:33:06.380 --> 00:33:08.920
The isComplete parameter of
the block will be set to yes.

00:33:09.240 --> 00:33:11.520
This is the last time that
your block is getting called.

00:33:11.520 --> 00:33:13.940
After this, the block memory is going
to be released for you,

00:33:14.020 --> 00:33:18.240
so go ahead and hide any overlay
content that you have to go ahead--that

00:33:18.250 --> 00:33:21.220
is animating the fluid swipe.

00:33:21.220 --> 00:33:25.090
And with that,
let's get a quick look at the demo.

00:33:35.510 --> 00:33:38.100
So this is Picture Swiper.

00:33:38.100 --> 00:33:40.730
This demo should be already
attached to this session,

00:33:40.750 --> 00:33:44.260
so you can go ahead and
download the project.

00:33:44.560 --> 00:33:46.380
And I'm just using two fingers here.

00:33:46.380 --> 00:33:48.880
And you can even see I get a
nice little bounce effect going,

00:33:48.880 --> 00:33:52.530
and if I were to start at the beginning,
it automatically dampens the

00:33:52.530 --> 00:33:57.020
amount for me as I get to there
and I have no more content to go.

00:33:57.030 --> 00:33:59.290
I'm going to zoom in a little bit here.

00:33:59.480 --> 00:34:01.550
And you can see I can scroll around.

00:34:01.610 --> 00:34:03.990
I can get to the edge.

00:34:05.180 --> 00:34:07.870
Get to the edge and I get the
one bounce and then it goes

00:34:07.870 --> 00:34:10.340
ahead and continues to scroll.

00:34:10.460 --> 00:34:14.440
This is more of a photo style
that you might have seen on iOS.

00:34:14.530 --> 00:34:24.810
We also have this stack style that the
sample code shows you how to do which

00:34:24.810 --> 00:34:25.130
is more like Safari does as it goes
back and forward in pages in Safari.

00:34:29.500 --> 00:34:33.890
And here's the project.

00:34:33.970 --> 00:34:37.460
What I want to point out
in the project is-- oh,

00:34:38.150 --> 00:34:40.440
wrong project, sorry.

00:34:41.280 --> 00:34:42.850
Here it is.

00:34:42.950 --> 00:34:46.610
What I want to point out in the project
is we have a stack swipe controller

00:34:46.870 --> 00:34:49.700
and a slideshow swipe controller.

00:34:49.700 --> 00:34:54.540
And these are the two controllers that
do one style of animation or the other.

00:34:54.670 --> 00:34:59.500
And the other thing I want
to point out in here is

00:35:02.870 --> 00:35:08.280
You'll see in here we have this
concept of updating layers cache.

00:35:08.350 --> 00:35:12.240
It turns out that fluid swiping is very,
very performance sensitive.

00:35:12.240 --> 00:35:17.430
As soon as the user starts to perform a
fluid swipe they need to have immediate

00:35:17.430 --> 00:35:20.000
feedback visually on the screen.

00:35:20.000 --> 00:35:23.810
And if you spend time creating a view,
making it layer back,

00:35:23.810 --> 00:35:27.680
generating thumbnails or high
resolution images of whatever your

00:35:27.680 --> 00:35:31.850
content is and getting that across
to the video card and to the layers,

00:35:31.990 --> 00:35:36.650
this can severely impact that
initial showing of responding to

00:35:36.650 --> 00:35:40.730
the user and it can make for a
really bad feeling for the user if

00:35:40.800 --> 00:35:42.680
this is not immediately responsive.

00:35:42.860 --> 00:35:47.960
So this project shows you one way
of handling that by caching your

00:35:47.960 --> 00:35:50.330
layers and keeping them up in sync.

00:35:50.440 --> 00:35:55.000
And so as soon as swiping starts we can
have an immediate feedback for the user.

00:35:55.000 --> 00:35:58.340
So download the sample code,
check it out.

00:36:05.270 --> 00:36:07.900
So let's go ahead and move
on to multi-image dragging.

00:36:07.950 --> 00:36:12.040
You might have seen this in the
finder already as you drag around.

00:36:12.080 --> 00:36:19.140
We'll go ahead and animate to some
final destination and as you go

00:36:19.140 --> 00:36:25.990
across to a different destination we
can change the dragging contents so

00:36:25.990 --> 00:36:25.990
that it looks more like where it's
going to end at the final location.

00:36:26.210 --> 00:36:28.540
and this has three main benefits.

00:36:28.590 --> 00:36:32.890
One, as we have an image for each
individual item that you're dragging,

00:36:32.890 --> 00:36:35.520
we can animate them
independently of each other,

00:36:35.520 --> 00:36:38.260
and they can move slightly offset
from the cursor so we can see what's

00:36:38.340 --> 00:36:42.460
underneath the cursor in some cases,
if that makes sense.

00:36:42.830 --> 00:36:47.940
It provides great feedback to the user,
so they can see what's going to

00:36:47.940 --> 00:36:50.200
happen when I drop in this view.

00:36:50.270 --> 00:36:53.600
And third,
it provides a means for you as a

00:36:53.610 --> 00:36:57.430
developer to interact with the dragging,
both as the source-- it's not

00:36:57.430 --> 00:36:59.810
just a static image that you
started with-- as the source,

00:36:59.860 --> 00:37:01.140
you can change the dragging image.

00:37:01.140 --> 00:37:04.060
And even as a destination,
you can participate in the drag and

00:37:04.200 --> 00:37:07.480
change the dragging image as well to
give the user better feedback on what

00:37:07.480 --> 00:37:09.910
will happen when they drop in your view.

00:37:09.930 --> 00:37:13.740
And the way this works is we have a
new concept of an NS dragging item,

00:37:13.740 --> 00:37:16.180
and there's the source
and the destination,

00:37:16.180 --> 00:37:20.980
and we want to animate from
the source set of images to

00:37:20.980 --> 00:37:22.800
the destination set of images.

00:37:22.820 --> 00:37:24.420
And it's exactly that.

00:37:24.440 --> 00:37:27.860
It's a set of images,
and they're named in this case.

00:37:27.890 --> 00:37:30.550
And so we'll take the source
icon and animate that to

00:37:30.550 --> 00:37:32.850
the destination icon image,
and we'll take the source

00:37:32.850 --> 00:37:37.580
label image and animate that
to the destination label image.

00:37:37.590 --> 00:37:38.900
And the animation looks
a little something like

00:37:38.970 --> 00:37:41.100
this when it's slowed down.

00:37:43.480 --> 00:37:46.890
In Snow Leopard,
this is how you would start a drag.

00:37:47.030 --> 00:37:49.760
You would create a pasteboard,
you would clear its contents,

00:37:49.830 --> 00:37:52.420
and you would write your pasteboard
writers onto the pasteboard and

00:37:52.420 --> 00:37:53.900
you'd set the pasteboard all up.

00:37:54.190 --> 00:38:01.510
And then on some view you would
call drag image at location offset

00:38:01.510 --> 00:38:01.510
event pasteboard source slideback.

00:38:02.000 --> 00:38:07.280
In Lion, it looks a little bit like this.

00:38:07.860 --> 00:38:11.080
On your SumView, you say,
begin dragging session with items, event,

00:38:11.080 --> 00:38:11.900
source.

00:38:11.950 --> 00:38:15.530
And unlike Snow Leopard,
where a drag would start

00:38:15.690 --> 00:38:19.060
and it would run off,
and when the drag was completed,

00:38:19.140 --> 00:38:22.980
it would return to that portion of your
code and continue executing from there.

00:38:23.270 --> 00:38:26.180
Begin dragging session with items, event,
source returns immediately and

00:38:26.320 --> 00:38:27.800
it returns a dragging session.

00:38:27.980 --> 00:38:29.630
And at this point,
you can continue to modify the

00:38:29.750 --> 00:38:31.340
properties of the dragging session.

00:38:31.400 --> 00:38:34.230
In this case, animates to starting
position on cancel or fail,

00:38:34.290 --> 00:38:41.510
which is equivalent to the slide back
parameter of the method in Snow Leopard.

00:38:42.580 --> 00:38:45.580
The drag actually starts for you
and is handled asynchronously on

00:38:45.580 --> 00:38:48.250
the next turn of the run loop.

00:38:50.900 --> 00:38:54.610
So when BeginDraggingSessionWithItems
is called,

00:38:54.620 --> 00:38:57.510
you need to supply it a
set of dragging items.

00:38:57.520 --> 00:39:00.950
And an array of dragging items--
there's the NSDraggingItem that

00:39:01.220 --> 00:39:03.160
we covered briefly earlier.

00:39:03.160 --> 00:39:04.760
We're going to go into
a little more detail.

00:39:04.770 --> 00:39:07.120
And dragging items have to have an item.

00:39:07.170 --> 00:39:09.850
And the item can either
be an NSPaceboardWriter

00:39:10.020 --> 00:39:12.480
or an NSPaceboardReader,
depending on its context.

00:39:12.690 --> 00:39:14.220
In this case, we're creating it.

00:39:14.280 --> 00:39:16.210
So it needs to be an NSPaceboardWriter.

00:39:16.220 --> 00:39:18.840
And that means that it has to
be an object that conforms to

00:39:18.840 --> 00:39:20.020
the NSPaceboardWriting protocol.

00:39:20.120 --> 00:39:25.120
A lot of objects already
in the kit do this for you,

00:39:25.120 --> 00:39:28.430
such as NSString or NSURL.

00:39:30.010 --> 00:39:32.530
And then this dragging item has a frame.

00:39:32.530 --> 00:39:35.960
And the coordinate system of the
frame is dependent on its context

00:39:35.960 --> 00:39:37.900
and where the dragging item is used.

00:39:37.900 --> 00:39:42.890
And now you'll see some examples of that
as we go along and I'll point that out.

00:39:43.050 --> 00:39:45.590
And then it has an array
of image components,

00:39:45.590 --> 00:39:49.430
which is what I showed you earlier,
where these are the named images that

00:39:49.990 --> 00:39:52.290
make up the complete image for this drag.

00:39:52.370 --> 00:39:57.270
And now we can animate these items,
these individual items

00:39:57.270 --> 00:39:57.270
independently of each other.

00:39:58.360 --> 00:40:00.000
Image components can't be set directly.

00:40:00.000 --> 00:40:03.290
That's why there's the
little double asterisk there.

00:40:03.600 --> 00:40:07.280
You don't set them directly,
and I will show you how to set those,

00:40:07.690 --> 00:40:11.160
but they have a name
and they have a frame,

00:40:11.160 --> 00:40:14.470
along with their contents,
and their frame is in the coordinate

00:40:14.570 --> 00:40:16.550
system of the NSDRAGGING item itself.

00:40:16.660 --> 00:40:19.400
It's sort of like an
NSView parent-child relationship.

00:40:19.400 --> 00:40:23.790
So the coordinate system for the
image component frames is the bounds

00:40:23.790 --> 00:40:27.060
of the NSDRAGGING item itself,
and this turns out to be really

00:40:27.060 --> 00:40:30.500
easy to set it up and maintain it.

00:40:30.590 --> 00:40:34.000
And every NSDRAGGING item comes
with a limited lifetime guarantee.

00:40:34.080 --> 00:40:37.210
What I mean by that is I guarantee
that NSDRAGGING items have

00:40:37.210 --> 00:40:39.350
a very limited lifetime.

00:40:40.670 --> 00:40:44.500
You'll see this is a reoccurring theme
in the coming up slides and I will

00:40:44.500 --> 00:40:50.900
be sure to point out exactly where
this limited lifetime takes effect.

00:40:52.200 --> 00:40:55.700
So this is how you might go ahead and
create an NSDragging item in code.

00:40:55.990 --> 00:41:03.170
NSDragging item Alec,
a knit with pasteboard rider.

00:41:03.170 --> 00:41:03.170
The only way you can create an NSDragging
item is with a pasteboard rider.

00:41:03.780 --> 00:41:07.030
And then you go ahead and you
set the dragging frame and

00:41:07.030 --> 00:41:09.040
the contents of the image.

00:41:09.100 --> 00:41:11.770
This is actually a convenience method,
set dragging frame contents.

00:41:11.900 --> 00:41:14.710
What this does is it sets the
appropriate dragging frame and it

00:41:15.020 --> 00:41:20.040
sets one image component that contains
whatever content you supplied,

00:41:20.050 --> 00:41:24.680
whatever image,
and it maps directly to the dragging

00:41:24.680 --> 00:41:27.260
frame that you set in there.

00:41:27.260 --> 00:41:29.360
And it's automatically given the
name of icon for animation purposes.

00:41:30.300 --> 00:41:32.540
You really only want to do
this if you're dragging one

00:41:32.540 --> 00:41:36.640
item that contains one image,
maybe a handful, two, three items.

00:41:36.950 --> 00:41:38.400
Because when a user
starts to do the drag,

00:41:38.400 --> 00:41:41.300
you want to respond to that right away.

00:41:41.350 --> 00:41:44.160
If you have thousands of items and you're
trying to generate thousands of images,

00:41:44.160 --> 00:41:48.330
that's just going to be too slow and
have a lot of lag time for the user.

00:41:48.470 --> 00:41:52.890
The preferred method for setting up
the image components is to provide

00:41:53.180 --> 00:41:54.700
an image components provider.

00:41:54.880 --> 00:41:58.500
And this is a block that will be called
back at some later time during dragging.

00:41:58.620 --> 00:42:02.700
And it is at this point that
you build your components array.

00:42:02.840 --> 00:42:06.070
And you do that by simply calling
NSDraggingImage component,

00:42:06.070 --> 00:42:07.680
dragging image component with key.

00:42:07.730 --> 00:42:10.130
In this case,
the first one I'm creating is the icon.

00:42:10.210 --> 00:42:13.250
So I pass an NSDraggingImage
component icon key.

00:42:13.350 --> 00:42:16.500
We also define the NSDraggingImage
component label key.

00:42:16.500 --> 00:42:20.110
We think icon and label are going
to be the two most used names as

00:42:20.110 --> 00:42:22.390
you drag between applications.

00:42:22.500 --> 00:42:26.880
So we can animate from one item to
the other fluidly and seamlessly.

00:42:27.170 --> 00:42:27.580
You go ahead.

00:42:27.580 --> 00:42:30.030
And you set your frame.

00:42:30.790 --> 00:42:31.960
And then you set your contents.

00:42:31.970 --> 00:42:34.260
Even though you're doing this
in an image components provider,

00:42:34.260 --> 00:42:39.040
please update your contents here
as quickly as possible or use some

00:42:39.110 --> 00:42:42.340
cache image if you already have that.

00:42:42.450 --> 00:42:44.200
And then you add that to
your components array.

00:42:44.220 --> 00:42:47.470
And then you just continue to do
this for however many items that

00:42:47.470 --> 00:42:52.240
you want in your NSDragging item,
however many images that you want.

00:42:52.460 --> 00:42:53.960
The key is just an inner string.

00:42:53.980 --> 00:42:55.840
Like I said,
we've defined icon and label.

00:42:55.860 --> 00:42:58.340
You can put any string you want in there,
like perhaps background.

00:42:58.340 --> 00:43:01.100
And we have sample code that I'm
going to show you in a little bit.

00:43:01.100 --> 00:43:03.760
And that's exactly what I do is
I add a third image component

00:43:03.760 --> 00:43:05.810
that's named background.

00:43:06.050 --> 00:43:08.190
Once you have your array,
your components provider

00:43:08.200 --> 00:43:09.740
block will return that.

00:43:09.770 --> 00:43:13.340
Now one of the reasons
we're using a block is,

00:43:13.340 --> 00:43:16.170
say that the user is trying
to drag thousands of items,

00:43:16.240 --> 00:43:20.230
or even just hundreds of
items from your application.

00:43:20.490 --> 00:43:23.940
If we were to call in every single
image component provider for that,

00:43:23.940 --> 00:43:27.200
that would take a long time
to generate all these images.

00:43:27.230 --> 00:43:29.030
And they're not all going
to be probably shown on the

00:43:29.090 --> 00:43:30.310
screen at the same time anyway.

00:43:30.510 --> 00:43:34.770
So we look at a variety of heuristics,
and we determine which

00:43:34.850 --> 00:43:36.750
of the dragging items,
since you always return the

00:43:36.770 --> 00:43:39.520
dragging item frame that helps out,
are the ones we're going

00:43:39.520 --> 00:43:40.720
to display on screen.

00:43:40.720 --> 00:43:43.880
And given some other heuristics,
we only call in a subset of

00:43:43.880 --> 00:43:46.670
the image component provider
blocks that you've passed in.

00:43:46.700 --> 00:43:50.020
It's much cheaper and much faster for
you to provide 1,000 image component

00:43:50.020 --> 00:43:54.280
provider blocks than it is for you
to generate 1,000 times however many

00:43:54.290 --> 00:43:58.250
images in each dragging item you have.

00:43:58.380 --> 00:44:01.670
So we do this for performance.

00:44:03.090 --> 00:44:05.000
So back to our Begin Dragging
Session with Items.

00:44:05.000 --> 00:44:07.360
We've created our collection
of dragging items.

00:44:07.500 --> 00:44:11.090
One thing you might be wondering is from
the Snow Leopard example of the code,

00:44:11.090 --> 00:44:13.000
we started off by creating a pasteboard.

00:44:13.000 --> 00:44:15.500
In Lion,
we haven't created a pasteboard yet.

00:44:15.680 --> 00:44:18.500
And that's because when you
created these dragging items,

00:44:18.560 --> 00:44:20.600
you set the item as a pasteboard rider.

00:44:20.610 --> 00:44:24.210
Begin Dragging Session with Item will
go through these and automatically

00:44:24.210 --> 00:44:27.900
create the pasteboard for you and put
the items on the pasteboard right out of

00:44:27.900 --> 00:44:31.550
your dragging item since the pasteboard
rider is automatically for you.

00:44:31.550 --> 00:44:32.740
It works out great.

00:44:34.270 --> 00:44:36.990
But right after you call begin
dragging session with items and

00:44:36.990 --> 00:44:41.360
a dragging session is returned,
the effective lifetime for

00:44:41.410 --> 00:44:43.160
those dragging items is over.

00:44:43.190 --> 00:44:46.540
Don't bother accessing the dragging
items in the array anymore.

00:44:46.580 --> 00:44:47.760
There's still valid objects.

00:44:47.920 --> 00:44:50.750
They still have a retain here,
so you should probably

00:44:51.290 --> 00:44:53.300
release your array.

00:44:53.300 --> 00:44:55.900
Actually, that should be an auto-released
array based on that method name.

00:44:55.970 --> 00:45:00.100
And they'll be auto-released
when the pool is released.

00:45:00.160 --> 00:45:03.420
But if you modify them at this point,
they won't affect the drag.

00:45:03.680 --> 00:45:05.600
So effectively, their lifetime is over.

00:45:05.620 --> 00:45:07.790
Don't access them anymore.

00:45:10.530 --> 00:45:13.300
Anybody that's written a dragging source,
you've probably seen

00:45:13.300 --> 00:45:14.790
these category methods.

00:45:14.890 --> 00:45:17.200
They've been upgraded
to a formal protocol.

00:45:17.200 --> 00:45:18.640
These are all optional, of course.

00:45:18.730 --> 00:45:25.160
And we've added a dragging session
parameter where appropriate in the names.

00:45:25.330 --> 00:45:30.470
So when you get callback, for example,
began at point or moved to point,

00:45:30.470 --> 00:45:35.190
you have the dragging session and
you can modify properties of the

00:45:35.190 --> 00:45:36.630
dragging session or even enumerate
and modify the dragging images.

00:45:36.920 --> 00:45:39.170
Likewise as a destination,
these are the category

00:45:39.170 --> 00:45:40.240
methods we've had before.

00:45:40.240 --> 00:45:42.800
They've been upgraded to a protocol.

00:45:42.870 --> 00:45:49.080
And we've also declared that
the sender of these methods,

00:45:49.080 --> 00:45:53.460
they conform to a new protocol
called NSDraggingInfo so that

00:45:53.460 --> 00:45:58.550
you know definitely that sender
implements the NSDraggingInfo

00:45:58.550 --> 00:46:03.390
protocol and you can easily find
out and get auto-completion in Xcode

00:46:03.390 --> 00:46:03.390
on what methods sender implements.

00:46:04.050 --> 00:46:09.720
We did add one new method called
updateDraggingItemsForDrag,

00:46:09.720 --> 00:46:09.720
which is really important.

00:46:10.280 --> 00:46:11.900
And let's take a look at a typical drag.

00:46:11.950 --> 00:46:15.860
In this setup, we have, on the left,
an AcceptsDrag.

00:46:15.860 --> 00:46:16.750
On the right, excuse me.

00:46:16.880 --> 00:46:21.540
On the right,
an AcceptsDrag and a userDestination.

00:46:21.630 --> 00:46:24.110
Both of these views can accept this drag.

00:46:24.250 --> 00:46:26.080
But in this example,
the user's going to drop it

00:46:26.080 --> 00:46:28.270
on the userDestination view.

00:46:28.380 --> 00:46:30.760
So the user starts the drag,
it enters the AcceptsDrag.

00:46:30.780 --> 00:46:33.550
And that view is going to
get a dragging entered.

00:46:33.660 --> 00:46:36.090
And you might think, oh,
dragging entered this view,

00:46:36.110 --> 00:46:38.750
now would be a good time
to update these images.

00:46:38.760 --> 00:46:42.190
No, you don't want to update them here,
because the user's going to end

00:46:42.190 --> 00:46:44.180
up over the destination view.

00:46:44.200 --> 00:46:47.290
And if you change the image
here and change it as the user

00:46:47.290 --> 00:46:49.300
goes into the destination view,
you're going to have a lot

00:46:49.300 --> 00:46:50.880
of animations going on.

00:46:51.000 --> 00:46:52.880
And it can get distracting really fast.

00:46:52.910 --> 00:46:55.790
Think of dragging across a
couple of Finder windows.

00:46:55.800 --> 00:46:58.720
You're going to go across the desktop,
over the sidebar, over icon view,

00:46:58.720 --> 00:47:03.120
over the desktop again, another sidebar,
and maybe now into a list view.

00:47:03.230 --> 00:47:04.960
You're going to have a lot
of animations happening.

00:47:04.960 --> 00:47:06.900
And it's going to be very
distracting for the user.

00:47:06.980 --> 00:47:08.760
So now's not a dragging entered.

00:47:08.760 --> 00:47:10.390
So this isn't a good time to do that.

00:47:10.400 --> 00:47:12.420
You might think, well,
during dragging updated,

00:47:12.420 --> 00:47:16.140
I'll look at the mouse and figure
out how fast things are moving,

00:47:16.140 --> 00:47:18.000
and I'll try and decide something.

00:47:18.000 --> 00:47:18.770
You don't need to do that.

00:47:18.780 --> 00:47:19.900
We're going to take care of that for you.

00:47:19.990 --> 00:47:23.740
So in dragging updated, don't worry about
changing your images yet,

00:47:23.750 --> 00:47:27.060
because in this example,
the user has exited.

00:47:27.300 --> 00:47:28.800
and has immediately
entered the other view,

00:47:28.800 --> 00:47:31.500
and that view gets a dragging entered,
and as we've already discussed,

00:47:31.500 --> 00:47:32.920
we're not gonna do anything.

00:47:33.190 --> 00:47:36.120
You'll get some dragging updated,
and the dragging manager

00:47:36.120 --> 00:47:39.200
is doing heuristics,
uh, behind the scenes,

00:47:39.200 --> 00:47:42.780
and it just-- finally, at some point,
it's gonna determine that this view

00:47:42.780 --> 00:47:45.240
is a probable drop destination.

00:47:45.350 --> 00:47:48.200
At that point, you're gonna be called,
as a destination in this new method,

00:47:48.320 --> 00:47:51.810
"update dragging items for drag." It's
at this point that you wanna go ahead

00:47:52.050 --> 00:47:55.900
and enumerate all of the dragging items,
update their images,

00:47:56.000 --> 00:48:00.090
and we'll get a nice image
animation transition.

00:48:02.920 --> 00:48:07.660
And the way you do that is with
this method on NSDraggingInfo.

00:48:07.710 --> 00:48:10.630
Drag info, enumerate dragging items
with options for view,

00:48:10.630 --> 00:48:12.800
classes, search options using blocks.

00:48:12.860 --> 00:48:17.360
I also want to point out that
this exact same method also

00:48:17.360 --> 00:48:20.180
exists on NSDraggingSession.

00:48:20.180 --> 00:48:27.040
So if you're doing things as a dragging
source where you have a dragging session,

00:48:27.050 --> 00:48:27.430
you can also enumerate the items
and change their images there.

00:48:28.720 --> 00:48:32.240
Right away in this block,
you'll get called back on the

00:48:32.320 --> 00:48:34.420
block for each dragging item.

00:48:34.560 --> 00:48:39.350
You'll see that I'm just typecasting
the dragging item item as a URL.

00:48:39.480 --> 00:48:46.510
In this case, whenever you're
enumerating dragging items,

00:48:46.510 --> 00:48:46.510
this is a case where the item
is actually a pasteboard reader.

00:48:46.640 --> 00:48:49.790
What's going on here is you're
actually enumerating the pasteboard,

00:48:49.870 --> 00:48:53.800
not the original dragging items that
you began the dragging session with,

00:48:53.800 --> 00:48:57.620
because this might be a completely
different process as a destination.

00:48:57.880 --> 00:49:01.160
So you're actually enumerating the
items on the pasteboard and the

00:49:01.160 --> 00:49:04.090
data that is associated with it.

00:49:04.420 --> 00:49:08.240
We will go ahead and create a
dragging item on the fly and use

00:49:08.250 --> 00:49:10.060
it in the block right here for you.

00:49:10.060 --> 00:49:12.740
Now I can do this type cast
because when I wanted to

00:49:12.740 --> 00:49:16.060
enumerate these dragging items,
I said, well, these are the object

00:49:16.160 --> 00:49:17.680
classes that I accept.

00:49:17.700 --> 00:49:19.660
This is very similar to
what you're going to see in

00:49:19.660 --> 00:49:22.540
NSPasteboard for reading objects.

00:49:22.780 --> 00:49:26.200
You read objects for
classes with some options.

00:49:26.200 --> 00:49:29.100
And these are the exact same classes
and options that you get there.

00:49:29.200 --> 00:49:32.940
And in this case,
I just said what I accept

00:49:32.940 --> 00:49:34.210
is an NSURL class.

00:49:34.320 --> 00:49:35.950
It's the only thing I've accepted.

00:49:36.090 --> 00:49:38.530
So in my block,
I know that the dragging item

00:49:38.540 --> 00:49:40.340
item is going to be an NSURL.

00:49:40.480 --> 00:49:42.760
An NSURL is a pasteboard reader.

00:49:42.790 --> 00:49:45.280
I can go ahead and do this type cast.

00:49:46.210 --> 00:49:49.420
At this point,
create your dragging image or better yet,

00:49:49.620 --> 00:49:51.450
create an image components
provider block that's going to

00:49:51.450 --> 00:49:52.800
create the dragging image for you.

00:49:52.800 --> 00:49:53.670
Do it quickly.

00:49:53.790 --> 00:49:57.290
Even in the image component provider,
do it as quickly as possible.

00:49:57.290 --> 00:49:59.430
And determine what your new frame is.

00:49:59.450 --> 00:50:02.350
The dragging frame
I mentioned earlier was,

00:50:02.400 --> 00:50:06.200
its coordinate system was
dependent on where it's used.

00:50:06.200 --> 00:50:11.100
When you're creating a dragging item
and you call begin dragging session,

00:50:11.100 --> 00:50:13.810
at that point,
the view that you're calling

00:50:13.810 --> 00:50:13.810
begin dragging session on,

00:50:13.940 --> 00:50:17.010
The dragging items,
dragging frames are in that

00:50:17.010 --> 00:50:18.510
coordinate space of that view.

00:50:18.600 --> 00:50:21.200
In this case,
it's whatever view that you passed

00:50:21.200 --> 00:50:24.750
in for the enumerate dragging
items will automatically set up the

00:50:25.210 --> 00:50:29.190
dragging frame of the dragging item
inside that coordinate space for you.

00:50:29.280 --> 00:50:32.900
If you set nil, we'll just use the
screen coordinate space.

00:50:33.490 --> 00:50:37.400
Again, I'm for,
so everything fits on the slide.

00:50:37.400 --> 00:50:41.680
I went ahead and used the set dragging
frame contents convenience method,

00:50:41.680 --> 00:50:44.450
but in general,
try and use the image components

00:50:44.450 --> 00:50:47.450
providers where possible,
particularly if you're

00:50:47.450 --> 00:50:49.200
dragging lots of items.

00:50:50.970 --> 00:50:53.410
As I mentioned,
we create a dragging item on

00:50:53.410 --> 00:50:56.590
the fly as we're enumerating,
from the paste board and

00:50:56.620 --> 00:50:57.920
from the associated data.

00:50:57.920 --> 00:51:02.110
So this instance of the block,
each time it gets called,

00:51:02.110 --> 00:51:06.360
that is the effective lifetime
for that dragging item.

00:51:06.360 --> 00:51:09.700
You don't want to retain it and try
and use it outside of the block.

00:51:09.700 --> 00:51:11.910
And if you create a components provider,
you don't want to access

00:51:11.910 --> 00:51:14.630
the dragging item directly,
because that will cause a retain on it

00:51:14.630 --> 00:51:17.950
inside the components provider block,
which is going to get called

00:51:17.950 --> 00:51:21.340
outside of this enumeration block,
and at that point it's

00:51:21.440 --> 00:51:23.270
effectively no longer valid.

00:51:23.500 --> 00:51:26.800
So always pull the item,
the information that you need

00:51:26.800 --> 00:51:30.120
out of the dragging item first,
and then use the information

00:51:30.190 --> 00:51:32.880
you pulled out in your image
components provider block.

00:51:32.880 --> 00:51:36.870
So this is the effective lifetime,
limited lifetime for the

00:51:36.870 --> 00:51:39.410
dragging item when you enumerate.

00:51:41.090 --> 00:51:43.700
There's always been the
prepare for drag operation,

00:51:43.700 --> 00:51:47.590
perform drag operation,
and conclude drag operation methods

00:51:47.760 --> 00:51:50.700
have been there for when a drop occurs.

00:51:50.700 --> 00:51:52.080
And these always got called back.

00:51:52.190 --> 00:51:55.460
But now they have some new
meaning applied to them.

00:51:55.500 --> 00:52:01.020
We want to have a continuous
fluid drag and drop all the

00:52:01.020 --> 00:52:05.340
way to their final location of
whatever the user is dragging.

00:52:05.350 --> 00:52:09.870
And you can participate in this
during prepare for drag operation.

00:52:10.010 --> 00:52:14.370
What you do is you set animates
to destination equal to yes.

00:52:14.480 --> 00:52:18.140
And then when we call perform
drag operation on your view,

00:52:18.220 --> 00:52:22.090
you not only update your data model,
but we've set up an NSGraphics context

00:52:22.250 --> 00:52:26.470
for you with the appropriate duration,
and you want to animate making a gap.

00:52:26.610 --> 00:52:29.340
You also enumerate through the
dragging items one more time,

00:52:29.340 --> 00:52:31.600
and you set their final locations.

00:52:31.600 --> 00:52:36.880
You enumerate with your view
as the for view property,

00:52:37.010 --> 00:52:40.910
so you just determine where
their frame is inside your view,

00:52:40.930 --> 00:52:42.840
and you set that as the dragging frame.

00:52:42.840 --> 00:52:45.620
It's really as simple as that.

00:52:45.620 --> 00:52:49.120
And then when we get back
from perform drag operation,

00:52:49.120 --> 00:52:50.240
you've animated the gap.

00:52:50.240 --> 00:52:53.440
You've told us where
to drop the drag image,

00:52:53.440 --> 00:52:56.120
so we move the drag image into place,
and we call you back with

00:52:56.120 --> 00:52:57.520
conclude drag operation.

00:52:57.520 --> 00:53:00.780
At this point, the drag image is
actually still on screen,

00:53:00.780 --> 00:53:03.220
and you've actually
just drawn a blank spot.

00:53:03.220 --> 00:53:05.990
At this point,
you update your drawing model

00:53:06.120 --> 00:53:09.820
to start drawing the actual
data in the right place.

00:53:09.820 --> 00:53:11.320
And you set your view as dirty.

00:53:11.320 --> 00:53:13.530
When we return from this,
we're gonna drop the drag

00:53:13.530 --> 00:53:16.130
image from the screen,
and we'll refresh your view if

00:53:16.240 --> 00:53:19.060
it's marked as needing display.

00:53:19.060 --> 00:53:22.660
And if the drag image that
you gave us matched exactly

00:53:22.660 --> 00:53:25.340
what you draw in the view now,
it will be a completely

00:53:25.340 --> 00:53:26.160
smooth transition.

00:53:26.160 --> 00:53:28.860
The user won't see any flicker,
won't see anything happen.

00:53:28.860 --> 00:53:33.530
It looks like what they were dragging
just dropped right into place,

00:53:33.720 --> 00:53:35.640
seamless and very smooth.

00:53:35.680 --> 00:53:38.050
So let's give you a quick demo of that.

00:53:41.460 --> 00:53:47.460
So this is the multi-photo frame
demo that's attached to this session.

00:53:47.460 --> 00:53:49.800
I'm going to drag a
couple of images here.

00:53:49.940 --> 00:53:55.300
And you'll see they have automatically
updated the dragging image to what

00:53:55.300 --> 00:53:58.110
they're going to appear when I drop them,
and when I drop them,

00:53:58.240 --> 00:53:59.990
they animate right into place.

00:54:00.000 --> 00:54:02.910
I can even drag another image in here.

00:54:03.040 --> 00:54:07.920
And you see this one's going to
go into a landscape orientation.

00:54:07.920 --> 00:54:11.750
And my content's animated
as the dropped image,

00:54:12.130 --> 00:54:13.850
the dropped file was
animating into place.

00:54:13.990 --> 00:54:16.580
And everything was smooth and seamless.

00:54:16.580 --> 00:54:17.740
It works great.

00:54:17.760 --> 00:54:19.980
And even as a destination,
I might start dragging this

00:54:19.980 --> 00:54:25.220
item and as the source here,
as I leave the window,

00:54:25.220 --> 00:54:28.120
I change the dragging image
so it looks like a window.

00:54:28.200 --> 00:54:30.240
So when I drop, I get the window there.

00:54:30.240 --> 00:54:34.700
Or if I come back in here and let go,
it'll slide right back to

00:54:34.700 --> 00:54:36.220
where it was supposed to go.

00:54:36.290 --> 00:54:39.760
So these are a couple of things that the,
you know,

00:54:40.220 --> 00:54:42.100
Project shows you how to do.

00:54:42.100 --> 00:54:44.100
I'm running a little low on time.

00:54:44.100 --> 00:54:49.690
Close the picture swiper.

00:54:54.280 --> 00:55:00.020
So here, the source code's got lots
of comments in here for you.

00:55:05.110 --> 00:55:07.940
To move to point,
this is the case where as a dragging

00:55:07.940 --> 00:55:13.850
source I'm watching the mouse
and I get the point right out of,

00:55:14.270 --> 00:55:16.640
right from here and I convert
it from its screen location.

00:55:16.680 --> 00:55:24.360
And this is where I determine when
it goes in and out and I go ahead

00:55:24.360 --> 00:55:24.360
and enumerate the dragging items
and set up the window drag image.

00:55:26.700 --> 00:55:28.980
I just go ahead and call the
convenience method because

00:55:28.980 --> 00:55:30.600
I have the one image there.

00:55:30.630 --> 00:55:33.380
When you come back into the window I go
ahead and enumerate the dragging items

00:55:33.380 --> 00:55:43.720
again and I set back up their original
images and the dragging controller

00:55:44.400 --> 00:55:45.300
Here it is.

00:55:45.300 --> 00:55:47.600
The drag controller set up at the
image component providers will actually

00:55:47.990 --> 00:55:50.180
bring back the image component,
will actually generate the

00:55:50.360 --> 00:55:51.300
image components for me.

00:55:51.300 --> 00:55:54.220
And this is the interesting part
I wanted to show you real quick.

00:55:54.630 --> 00:55:59.390
Here's where I'm changing that animates
to starting position on cancel or fail,

00:55:59.920 --> 00:56:02.300
depending on if the cursor is
currently in the view or not.

00:56:02.300 --> 00:56:04.440
Dropping on the desktop
isn't a valid drop.

00:56:04.590 --> 00:56:08.250
I kind of faked that in this example
because I wanted to display a window.

00:56:08.350 --> 00:56:11.300
The finder isn't accepting the drop,
but I want to display the window,

00:56:11.300 --> 00:56:13.300
so it's always going to be a cancel.

00:56:13.300 --> 00:56:17.300
If it cancels on the desktop,
I don't want to slide back the animation.

00:56:17.410 --> 00:56:19.650
But if I'm in the view,
I want to go ahead and toggle

00:56:20.170 --> 00:56:24.510
the animates position on cancel
or fail back to yes so that it

00:56:24.510 --> 00:56:25.260
does slide back into position.

00:56:25.330 --> 00:56:29.080
So this is an example of how you
can modify the dragging session

00:56:29.390 --> 00:56:31.300
properties during the drag.

00:56:43.860 --> 00:56:48.760
So multi-image dragging,
there's a lot to it.

00:56:48.930 --> 00:56:54.340
And it turns out that we can do a
lot of this for you in some cases.

00:56:54.350 --> 00:56:57.880
And in this table view in
the delegate methods there,

00:56:57.880 --> 00:57:01.500
there are some APIs-- and particularly
in the view-based table view,

00:57:01.540 --> 00:57:04.910
if you wire things up
appropriately in your nib,

00:57:04.990 --> 00:57:07.700
it makes it real easy,
it makes it a breeze.

00:57:07.730 --> 00:57:10.640
Corbin's giving a talk on
view-based table views later,

00:57:10.660 --> 00:57:12.100
and I encourage you to come.

00:57:12.100 --> 00:57:15.000
He'll show you how easy it is to do
multi-image dragging in table views.

00:57:15.060 --> 00:57:18.850
Likewise, NSCollectionView also has a
similar set of delegate APIs as

00:57:18.850 --> 00:57:22.840
the view-based table view to make
doing multi-image dragging very,

00:57:22.840 --> 00:57:24.880
very easy for you to do.

00:57:25.910 --> 00:57:26.840
So that's the talk.

00:57:26.840 --> 00:57:30.300
We've covered the new
content-focused scrolling.

00:57:30.300 --> 00:57:33.470
We looked at the redesign of scrollers
and how you can participate in that,

00:57:33.550 --> 00:57:37.460
particularly if you have excess
reviews or if you are providing

00:57:37.460 --> 00:57:39.600
your own scroller subclasses.

00:57:39.860 --> 00:57:44.330
We've looked at fluid swiping,
which is just a new way of tracking

00:57:44.470 --> 00:57:46.800
gesture scroll wheel events.

00:57:46.840 --> 00:57:48.980
Please use the track swipe
method to do the tracking.

00:57:48.980 --> 00:57:53.140
That way, all applications will get
the same animation curves,

00:57:53.180 --> 00:57:57.620
will get the same heuristics applied
for determining if the user's

00:57:57.710 --> 00:58:01.060
gesture was a success or a failure.

00:58:01.080 --> 00:58:04.060
And we ended it off with the
new multi-image dragging,

00:58:04.060 --> 00:58:07.350
which is going to provide lots of
great feedback for the user and provide

00:58:07.350 --> 00:58:12.580
some great new capabilities for both
source and destinations of drags.

00:58:14.180 --> 00:58:17.900
We have full screen
and animation changes.

00:58:17.900 --> 00:58:18.880
There's another related session.

00:58:18.880 --> 00:58:19.930
This one has already occurred.

00:58:20.060 --> 00:58:23.730
So if you're watching this on the video,
you might want to check

00:58:23.730 --> 00:58:25.100
that session out as well.

00:58:25.140 --> 00:58:28.630
We have view-based in its table view,
basic to advanced that Corbin is giving.

00:58:28.640 --> 00:58:30.220
This is the one I alluded
to a little bit earlier.

00:58:30.220 --> 00:58:32.480
It's tomorrow at 10:15 AM.

00:58:32.480 --> 00:58:35.260
I highly recommend that
you check that one out.

00:58:35.300 --> 00:58:37.360
Bill Dudney's
Application Frameworks Evangelist.

00:58:37.420 --> 00:58:40.320
Please read the application
kit release notes.

00:58:40.320 --> 00:58:45.120
We've got information on the heuristics,
on automatically choosing

00:58:45.340 --> 00:58:49.400
which scroller style to use,
and also more information on fluid

00:58:49.540 --> 00:58:54.860
swiping and multi-image dragging and the
heuristics that are used there as well.

00:58:54.900 --> 00:58:57.700
And always check out the documentation.

00:58:57.720 --> 00:59:00.000
Thank you all,
and I hope to see you in the lab.
WEBVTT

00:00:10.940 --> 00:00:14.440
Welcome to What's New in Cocoa Touch.

00:00:14.440 --> 00:00:16.440
I'm glad to see everybody
here so bright and early.

00:00:16.440 --> 00:00:17.780
It was a little early for me too.

00:00:17.780 --> 00:00:19.310
This is session 100.

00:00:19.310 --> 00:00:23.260
I'm going to be spending the next roughly
an hour or so talking about some of the

00:00:23.260 --> 00:00:27.390
smaller things that we've added to UIKit,
some of the larger features that we're

00:00:27.390 --> 00:00:31.160
putting into UIKit to support your
applications and then some of the other

00:00:31.340 --> 00:00:35.230
APIs that have gone into other frameworks
or talk about some new frameworks that

00:00:35.240 --> 00:00:37.530
are going to appear on the system.

00:00:37.530 --> 00:00:39.660
So let's get started.

00:00:40.940 --> 00:00:43.560
We've added just a
little tiny new control.

00:00:43.560 --> 00:00:47.170
If you were getting numeric
input from your users before,

00:00:47.170 --> 00:00:50.840
you were probably doing something
like throwing up a UI text field

00:00:50.840 --> 00:00:54.600
and trying to validate that
input when the user typed in.

00:00:54.600 --> 00:00:58.290
You might have used a picker view
and the user scrolling through

00:00:58.290 --> 00:01:00.620
to find a number that they want.

00:01:00.620 --> 00:01:02.900
This is a new control UI stepper.

00:01:02.900 --> 00:01:08.450
It has a minimum and maximum value so you
can limit your users to a specific range.

00:01:08.450 --> 00:01:11.870
It has a step value so you can
choose how fast they move up

00:01:11.910 --> 00:01:14.720
through that range when they're
hitting the plus and minus buttons.

00:01:14.720 --> 00:01:16.690
You can obviously pull the value out.

00:01:16.710 --> 00:01:19.760
There are some properties here that
you can set for things like whether or

00:01:19.760 --> 00:01:26.190
not the control operates continuously,
whether it's auto-repeating.

00:01:27.050 --> 00:01:29.430
You don't have to do memory management
on this just for the values,

00:01:29.430 --> 00:01:29.620
really.

00:01:29.770 --> 00:01:32.310
That's not necessary.

00:01:32.720 --> 00:01:33.800
And whether or not it wraps.

00:01:33.960 --> 00:01:35.860
So if you hit the minimum
value on the way down,

00:01:35.860 --> 00:01:38.710
whether it pops back up
to the maximum value.

00:01:38.790 --> 00:01:41.330
This is also sized really
well to fit inside the default

00:01:41.370 --> 00:01:43.570
height for a UI table view cell.

00:01:43.640 --> 00:01:46.280
So if you're putting a number
of different places where your

00:01:46.280 --> 00:01:50.270
user's going to get numeric
input in one of those tables,

00:01:50.320 --> 00:01:53.560
this is a great control to use.

00:01:53.660 --> 00:01:56.560
Here's our old friend, UI Alert View.

00:01:57.740 --> 00:02:00.890
We've seen some pretty amazing
things that people have done in order

00:02:00.900 --> 00:02:03.970
to get input from UI Alert View.

00:02:06.090 --> 00:02:08.960
So we thought we'd make this
a little bit easier for you.

00:02:09.330 --> 00:02:13.350
In iOS 5.0,
this is now UI alert view style default.

00:02:13.380 --> 00:02:16.080
It's what you get when you
first create a UI alert view and

00:02:16.110 --> 00:02:19.500
you send the init with title,
cancel buttons, message,

00:02:19.530 --> 00:02:21.840
that whole long selector.

00:02:21.900 --> 00:02:26.090
We now also have UI alert
view style plain text input.

00:02:30.800 --> 00:02:33.150
So if you have to ask
your user something,

00:02:33.150 --> 00:02:34.900
this is a great way to do it.

00:02:34.920 --> 00:02:38.840
We've also given you
UI Alert View style secure text input.

00:02:38.930 --> 00:02:41.290
So if you'd like to get a password--

00:02:42.010 --> 00:02:43.690
This is how to do it.

00:02:43.970 --> 00:02:46.900
If you'd like to get login
and password information,

00:02:46.900 --> 00:02:49.510
we have a style for that too.

00:02:52.320 --> 00:02:54.880
So UIAlertViewStyle,
login and password input,

00:02:54.980 --> 00:02:57.420
and we even go ahead and put
a little placeholder text

00:02:57.420 --> 00:03:00.600
up there to guide your user.

00:03:00.600 --> 00:03:02.990
This is all defined in
the UIAlertViewHeader,

00:03:02.990 --> 00:03:06.340
UIAlertViewStyles,
there are four of them, the default,

00:03:06.430 --> 00:03:11.460
the secure text input, plain text input,
and login and password input.

00:03:11.460 --> 00:03:14.660
And you'll initialize a
UIAlertView and then send it

00:03:14.660 --> 00:03:17.880
the setAlertViewStyle message,
pick one of these,

00:03:17.880 --> 00:03:21.340
and when you go and present it,
it will come up with that style.

00:03:21.340 --> 00:03:24.940
The text fielded index method is
how you get at the text field that

00:03:24.980 --> 00:03:29.920
the user was typing into or the text
fields that the user was typing into.

00:03:30.060 --> 00:03:33.060
That's a--there's only one index,
index zero for the first two,

00:03:33.060 --> 00:03:35.460
secure text input and
plain text input styles,

00:03:35.460 --> 00:03:39.540
and then there's a zero and one
for login and password input.

00:03:39.540 --> 00:03:47.080
So UIAlertView has some easier
ways perhaps to get user input.

00:03:47.650 --> 00:03:50.680
In a previous version of iOS,
we introduced the ability to

00:03:50.830 --> 00:03:55.100
plug your device into a screen,
right, and get TV out and see that

00:03:55.200 --> 00:03:58.480
UI screen instance as an
external screen to the device.

00:03:58.620 --> 00:04:01.310
But if you're displaying
a bunch of content,

00:04:01.340 --> 00:04:05.190
right, you've got this great image that
you want to display or you've got

00:04:05.240 --> 00:04:08.620
a movie maybe that you're playing
out on that external screen,

00:04:09.750 --> 00:04:15.180
some televisions do this thing to
you called over scanning and it kind

00:04:15.180 --> 00:04:18.620
of crops out bits of the content,
right.

00:04:18.620 --> 00:04:20.620
And there are a couple of
different ways you can handle this.

00:04:20.620 --> 00:04:23.690
You can try to scale your content,
you can kind of guess at

00:04:23.790 --> 00:04:25.930
what's happening in the screen,
but it would be a lot easier if

00:04:25.930 --> 00:04:27.440
we actually helped you guys out.

00:04:27.660 --> 00:04:29.620
So, we're doing that.

00:04:29.620 --> 00:04:31.610
A quick refresher on UI screen though.

00:04:31.620 --> 00:04:35.600
UI screen has two really
important properties.

00:04:35.670 --> 00:04:39.620
There's the bounds of the UI screen
and there's the interface.

00:04:39.620 --> 00:04:42.490
So, for the main screen,
the bounds in the application

00:04:42.490 --> 00:04:45.170
frame are usually the same,
although we do inset it a

00:04:45.170 --> 00:04:48.620
little bit for things like the
status bar and stuff like that.

00:04:48.620 --> 00:04:51.990
We expect that you'll keep your
content in the application frame.

00:04:51.990 --> 00:04:54.530
That's actually the concept
to keep in mind here.

00:04:54.620 --> 00:04:57.010
So, we're going to go ahead and
inset that under certain

00:04:57.010 --> 00:04:58.610
circumstances when you plug in.

00:04:58.620 --> 00:05:05.100
So, for a 720p screen when you plug in,
if it's not doing any over scanning,

00:05:05.500 --> 00:05:09.950
The bounds and the application frame are
the same across all possible options.

00:05:10.000 --> 00:05:13.730
So you can either scale the content,
you'll be able to inset the

00:05:13.790 --> 00:05:17.000
bounds or inset the app frame
when a screen is over scanning.

00:05:17.230 --> 00:05:20.500
For a 720p over scanning screen,

00:05:20.940 --> 00:05:23.140
If you tell us to scale,
we'll go ahead and just

00:05:23.410 --> 00:05:25.870
throw the content up,
the bounds in the application

00:05:25.870 --> 00:05:27.400
frame will be the same.

00:05:27.510 --> 00:05:29.460
If you tell us to inset
the bounds of the screen,

00:05:29.460 --> 00:05:35.060
we're going to take that 0, 0,
1280 by 720 bounds for the screen

00:05:35.060 --> 00:05:39.030
and we'll inset it about 5,
between 5 and 10%, right?

00:05:39.130 --> 00:05:41.990
And if you've done a lot of
media work with movies and

00:05:42.080 --> 00:05:46.050
things like that on televisions,
this is the content safe area.

00:05:46.580 --> 00:05:48.800
Right, so when you overscan,
if it's going to stretch that content,

00:05:48.800 --> 00:05:50.100
it's going to stretch it off the screen.

00:05:50.100 --> 00:05:52.850
The content safe area is what's
going to stay on the screen.

00:05:53.820 --> 00:05:56.390
Right, you also have the option
to inset the app frame.

00:05:56.390 --> 00:05:58.060
So the bounds will stay the same.

00:05:58.060 --> 00:06:00.900
That may wind up going
outside the television itself

00:06:01.130 --> 00:06:03.990
as the screen overscans,
but the application frame is

00:06:03.990 --> 00:06:05.640
inset to the content safe area.

00:06:06.940 --> 00:06:09.300
And that's the overscan
compensation enum here.

00:06:09.300 --> 00:06:13.970
So UI overscan compensation scale,
I'm not going to read the prefix there.

00:06:14.870 --> 00:06:17.120
Inset bounds or inset application frame.

00:06:17.190 --> 00:06:19.160
So this is your opportunity
to make sure that,

00:06:19.160 --> 00:06:21.410
for instance,
if you have your own closed captioning

00:06:21.410 --> 00:06:24.900
track or your own content that
you're playing over a movie or

00:06:24.900 --> 00:06:28.390
over content on an external screen,
you can keep that in the application

00:06:28.390 --> 00:06:30.290
frame and in the content safe area.

00:06:30.970 --> 00:06:34.410
So there's a read write property,
I'm sorry, read only property on,

00:06:34.410 --> 00:06:36.200
it's a read write property on UI screen.

00:06:37.040 --> 00:06:41.090
You tell us what to do when we discover
that the screen is overscanning.

00:06:41.780 --> 00:06:41.980
Okay.

00:06:45.980 --> 00:06:51.890
Here we have a delightful iBook style
app that only reads Lorem Ipsum text.

00:06:51.940 --> 00:06:55.350
But that slider at the bottom now
can--you can hook that up to control

00:06:55.590 --> 00:06:58.690
the screen brightness of the device.

00:07:02.930 --> 00:07:06.210
So you may find also that once
you've messed around with the screen

00:07:06.210 --> 00:07:08.520
brightness and the user's taken it
all the way down as far as they can

00:07:08.520 --> 00:07:12.580
go without the backlight going off,
that it's still not quite dark

00:07:12.750 --> 00:07:15.020
enough for what you want to do.

00:07:15.020 --> 00:07:19.030
And we've also put in a software
dimming system for that.

00:07:19.150 --> 00:07:21.420
So there are two properties
now also on UIScreen.

00:07:21.420 --> 00:07:23.330
The brightness is a CG float.

00:07:23.340 --> 00:07:25.960
It runs from 0 to 1.

00:07:25.960 --> 00:07:29.040
You can run it down all
the way if you want.

00:07:29.600 --> 00:07:36.220
And the want software dimming flag here
is how we're going to go further than

00:07:36.220 --> 00:07:37.730
what the hardware backlight allows.

00:07:37.740 --> 00:07:39.740
So if you want to be able
to get a dimmer effect,

00:07:39.830 --> 00:07:41.650
kind of like the one
that we do in iBooks,

00:07:41.720 --> 00:07:45.220
you can set this flag,
and we'll go ahead and rescale.

00:07:45.220 --> 00:07:48.010
The brightness still goes from 0 to 1,
but when you get to a certain point

00:07:48.020 --> 00:07:52.050
and the backlight can't go any further,
UIKit will composite a view over

00:07:52.110 --> 00:07:55.980
your content and start tweaking
the alpha on that to make it look

00:07:56.030 --> 00:07:58.330
dimmer than the hardware will allow.

00:07:58.340 --> 00:07:59.560
And we'll scale.

00:07:59.580 --> 00:08:01.570
We'll scale this depending on
what the hardware is doing.

00:08:01.580 --> 00:08:03.700
So if the hardware can
actually go all the way down,

00:08:03.700 --> 00:08:06.580
you may not get this view.

00:08:06.580 --> 00:08:09.820
But the thing to bear in mind with
want software dimming is there's a

00:08:09.820 --> 00:08:11.580
very real performance hit for this.

00:08:11.700 --> 00:08:15.580
If you have lots of dynamic content
or if you have lots of animations,

00:08:15.580 --> 00:08:18.710
if you turn this on, we're compositing a
view over your content,

00:08:18.820 --> 00:08:20.580
so you may take a frame rate hit.

00:08:20.580 --> 00:08:22.490
So use this cautiously.

00:08:22.630 --> 00:08:27.660
If you use this for lots of static
input or static content behind things.

00:08:28.200 --> 00:08:33.770
So this is a UI scroll view and there
are a number of places where we go

00:08:33.770 --> 00:08:37.820
ahead and tell you where the scroll
view is going to land but if the

00:08:37.950 --> 00:08:40.580
user just goes ahead and scrolls,
well,

00:08:40.580 --> 00:08:50.490
it kind of landed wherever we decided
it was going to land which may not

00:08:50.490 --> 00:08:50.490
necessarily be quite where you wanted it.

00:08:51.410 --> 00:08:55.300
So you probably wanted it to land
exactly on a specific location,

00:08:55.700 --> 00:08:55.980
right?

00:08:55.980 --> 00:08:58.160
Your designer tells you to make
sure that you've only got five

00:08:58.160 --> 00:09:01.240
UI table view cells up there,
something like that.

00:09:01.300 --> 00:09:05.820
There is a new UI scroll
view delegate method

00:09:07.180 --> 00:09:07.550
Here it is.

00:09:07.770 --> 00:09:11.780
Scroll view will end dragging with
velocity and target content offset.

00:09:11.780 --> 00:09:15.770
This is where you can decide exactly
where the UI scroll view is going

00:09:15.770 --> 00:09:17.540
to land when the user flicks it.

00:09:17.590 --> 00:09:22.010
So when the user's finger comes up,
your delegate gets sent this message.

00:09:22.010 --> 00:09:27.150
The velocity is in points per second
and the target content offset comes

00:09:27.150 --> 00:09:31.610
in where we tell you this is where
we're going to put it and you can

00:09:31.750 --> 00:09:36.770
fill that in out pointer in with a new
CG point where you want it to land.

00:09:37.000 --> 00:09:42.000
So you'll be able to adjust the
resting point of a UI scroll view.

00:09:42.310 --> 00:09:45.330
This does change the
physics of a scroll view,

00:09:45.330 --> 00:09:46.040
right?

00:09:46.040 --> 00:09:49.070
So one of the things that's pretty
consistent across iOS and all the

00:09:49.070 --> 00:09:52.440
applications is if the user really
flicks one of these scroll views,

00:09:52.580 --> 00:09:55.440
it comes to rest at sort of a known pace,
right?

00:09:55.440 --> 00:10:00.440
So if you're going to use this,
use it to come within a couple of

00:10:00.490 --> 00:10:03.340
pixels of a resting destination.

00:10:03.340 --> 00:10:05.110
If you bring the scroll
view to a screeching halt,

00:10:05.110 --> 00:10:05.110
it's going to feel funny
in your application,

00:10:05.110 --> 00:10:05.110
right?

00:10:06.440 --> 00:10:14.900
So you saw Scott demo the text system
define mechanism that's now system wide.

00:10:15.010 --> 00:10:17.310
And the short answer with
this is if you can select it

00:10:17.310 --> 00:10:20.480
and we can find a definition,
we'll display it in the UI.

00:10:20.480 --> 00:10:22.340
So this is built into the text system.

00:10:22.340 --> 00:10:25.910
So if you're using UI text field,
if you're using UI text view,

00:10:26.000 --> 00:10:28.470
if you're using a web
view to display content,

00:10:28.840 --> 00:10:32.240
your users will be able to select
a word and get a definition

00:10:32.240 --> 00:10:33.960
anywhere in the system.

00:10:33.960 --> 00:10:36.920
There are a number of applications
we've seen that actually aren't using

00:10:37.020 --> 00:10:40.150
the text system directly or probably
striking your glyphs directly with

00:10:40.270 --> 00:10:41.780
core text and things like that.

00:10:41.780 --> 00:10:45.080
If you're doing that and you want
to be able to display definitions

00:10:45.080 --> 00:10:48.230
in your own applications,
we have the UI reference

00:10:48.360 --> 00:10:50.010
library view controller.

00:10:50.080 --> 00:10:53.260
It looks like this on the
phone and this on the iPad.

00:10:53.260 --> 00:10:55.230
It comes up in a popover.

00:10:55.230 --> 00:10:59.040
And the API for that is
pretty straightforward.

00:10:59.040 --> 00:11:00.760
It looks like this.

00:11:01.670 --> 00:11:06.570
You can init one of these with a
term and the view controller that

00:11:06.570 --> 00:11:11.120
you get back is suitable for pushing
on to a navigation controller.

00:11:11.120 --> 00:11:14.710
It's suitable for putting--
displaying modally.

00:11:14.800 --> 00:11:17.600
It's also got a dictionary
has definition for term.

00:11:17.960 --> 00:11:21.670
And this is your opportunity to decide
whether or not you're going to display

00:11:21.820 --> 00:11:24.440
UI for a particular definition.

00:11:24.620 --> 00:11:27.690
Or if we can find a
definition or if we can't,

00:11:27.930 --> 00:11:29.820
you can switch on this to figure
out whether or not you're going to

00:11:29.820 --> 00:11:34.780
enable a button or show the UI itself.

00:11:34.900 --> 00:11:38.740
So here's a split view controller.

00:11:40.780 --> 00:11:43.030
Speaking of crazy things that we've seen.

00:11:43.160 --> 00:11:47.400
If you rotated a split view controller,
you got this.

00:11:47.410 --> 00:11:51.000
What you might have wanted was this.

00:11:54.070 --> 00:11:56.200
And so we're doing that in iOS 5 also.

00:11:56.250 --> 00:11:59.880
There's a UI split view
controller delegate method.

00:11:59.880 --> 00:12:04.300
A split view controller should hide
view controller in orientation.

00:12:04.470 --> 00:12:07.100
When you rotate the device,
if you implement this delegate method,

00:12:07.100 --> 00:12:10.680
you'll get a ping back that tells you
which split view controller is involved,

00:12:10.720 --> 00:12:13.190
whether it should hide a
particular view controller,

00:12:13.190 --> 00:12:16.280
and in what orientation it
should hide the view controller.

00:12:16.340 --> 00:12:20.900
In 5.0, we're only calling this on that
left-hand view controller right now.

00:12:20.990 --> 00:12:23.500
But there may be a time in the
future when we wind up calling

00:12:23.500 --> 00:12:26.400
this on every view controller
in the split view controller.

00:12:26.400 --> 00:12:31.530
But now you can keep that split view
controller with both view controllers

00:12:31.530 --> 00:12:34.160
visible in portrait orientation.

00:12:39.520 --> 00:12:43.350
There are a lot of places in your
UI where you might want to be able to use

00:12:43.400 --> 00:12:47.550
an entire UI table view cell as a cut,
copy, paste target.

00:12:47.560 --> 00:12:52.500
So rather than go through and try
to work with the responder chain

00:12:52.500 --> 00:12:58.880
and use a text field or maybe a view
over the entire table view cell,

00:12:58.880 --> 00:13:04.450
we're adding API to be able to use
the entire cell as a menu target.

00:13:04.570 --> 00:13:08.430
So you'll be able to display menus
for specific table view cells.

00:13:08.950 --> 00:13:11.940
There are three new table
view delegate methods.

00:13:11.980 --> 00:13:16.530
Table view should show menu for row
at index path is where you decide

00:13:16.650 --> 00:13:19.320
whether or not the menu will appear.

00:13:19.320 --> 00:13:24.270
Table view can perform action for row at
index path is basically the same thing

00:13:24.410 --> 00:13:27.930
as the corresponding UI responder method,
right?

00:13:28.000 --> 00:13:31.650
This is your opportunity to decide
whether or not a particular action should

00:13:31.690 --> 00:13:33.800
be performed for that table view cell.

00:13:33.800 --> 00:13:36.330
So if you can't cut or copy,
you can return no from this.

00:13:36.340 --> 00:13:40.190
And finally,
Table view perform action for row at

00:13:40.190 --> 00:13:44.260
index is where you're told the table
view and what action is being performed

00:13:44.300 --> 00:13:46.430
and which cell it's being performed on.

00:13:46.520 --> 00:13:49.280
So this is where you're actually
going to go ahead and call,

00:13:49.370 --> 00:13:52.630
cut, copy, or paste on the particular
table view cell.

00:13:52.640 --> 00:13:58.320
So these are all basically delegate
methods that mirror the responder

00:13:58.320 --> 00:14:00.750
behavior but for UI table view cells.

00:14:00.840 --> 00:14:04.070
We're also allowing you now
to reuse cells with nibs,

00:14:04.070 --> 00:14:05.210
right?

00:14:10.040 --> 00:14:13.200
So if you have a table view cell
that you've painstakingly laid

00:14:13.230 --> 00:14:16.760
out in Interface Builder and
you'd like to be able to use that

00:14:16.760 --> 00:14:20.000
as with the table view itself,
you can register that nib for

00:14:20.050 --> 00:14:21.540
the cell reuse identifier.

00:14:21.540 --> 00:14:24.430
So remember when the delegate
gets called and says,

00:14:24.460 --> 00:14:26.000
okay,
I don't have a table view cell for this,

00:14:26.000 --> 00:14:26.620
go create one.

00:14:26.620 --> 00:14:29.010
Rather than getting the
call to go create one,

00:14:29.010 --> 00:14:33.050
we will go ahead and automatically start
creating table view cells out of that

00:14:33.050 --> 00:14:35.150
UI nib instance that you handed us.

00:14:35.160 --> 00:14:38.060
So this cuts back a little bit on some
of the code that you have to write

00:14:38.150 --> 00:14:39.720
in order to use table view cells.

00:14:39.900 --> 00:14:40.930
Amen.

00:14:41.450 --> 00:14:46.200
There is a UI Table View Changes
Tips and Tricks talk that's Thursday in

00:14:46.200 --> 00:14:50.790
Nob Hill at 2 o'clock where we'll
be talking about a number of other

00:14:50.800 --> 00:14:54.870
things like the ability to use
static content in a table view.

00:14:54.940 --> 00:15:00.300
So if you had just a list of
items to put into a table view,

00:15:00.300 --> 00:15:02.520
we've now written a bunch of
code so that you don't have to.

00:15:02.520 --> 00:15:05.050
You can just give us the list
and we'll generate the table

00:15:05.080 --> 00:15:06.440
view data source for that.

00:15:07.020 --> 00:15:11.790
And a number of other nifty APIs like
being able to move entire sections and

00:15:11.790 --> 00:15:13.760
cells at index paths and stuff like that.

00:15:13.870 --> 00:15:15.470
So if you're doing a
lot of table view work,

00:15:15.620 --> 00:15:17.020
this will be a great talk to go to.

00:15:19.730 --> 00:15:21.970
So you saw the new keyboard.

00:15:22.310 --> 00:15:25.360
This is the usual keyboard on the iPad,
right?

00:15:25.360 --> 00:15:27.090
When it comes up,
it's always pinned to the bottom.

00:15:27.130 --> 00:15:29.600
It always has the same height.

00:15:29.600 --> 00:15:34.300
But in iOS 5,
we've introduced this new split keyboard.

00:15:34.370 --> 00:15:37.070
And there are two really important
things about the split keyboard.

00:15:37.120 --> 00:15:41.000
The first is the user
can move it anywhere.

00:15:41.000 --> 00:15:45.830
And the second is you probably
want to avoid the keyboard now

00:15:45.830 --> 00:15:45.830
that it can show up in more places.

00:15:47.130 --> 00:15:48.960
So we have two new
notifications for this.

00:15:49.140 --> 00:15:52.920
They're in UI Window along
with the old ones.

00:15:53.120 --> 00:15:54.000
There we go.

00:15:54.000 --> 00:15:56.980
UI keyboard will change
frame notification and did

00:15:56.980 --> 00:15:58.880
change frame notification.

00:15:58.930 --> 00:16:01.470
These are now sent on
any keyboard change.

00:16:01.470 --> 00:16:05.450
So this includes pairing your
device with a Bluetooth keyboard.

00:16:05.450 --> 00:16:09.820
This includes when the user
undocks the keyboard and splits it.

00:16:09.870 --> 00:16:12.650
It also includes when the user
is moving the keyboard around.

00:16:12.790 --> 00:16:16.060
So you can find out where the
split keyboard is and actually

00:16:16.060 --> 00:16:19.530
change your content underneath
it in order to avoid it,

00:16:19.530 --> 00:16:20.620
right?

00:16:20.620 --> 00:16:22.200
These are in screen
coordinates by the way,

00:16:22.300 --> 00:16:24.540
so you'll probably have to do a
transform to figure out what direction

00:16:24.540 --> 00:16:25.690
you need to move your content.

00:16:29.230 --> 00:16:33.470
And we now have support in
UIKit for animated images.

00:16:33.530 --> 00:16:34.610
This is pretty straightforward.

00:16:34.700 --> 00:16:37.420
It matches some other
naming conventions we have.

00:16:37.450 --> 00:16:40.050
But animated image named and duration.

00:16:40.180 --> 00:16:43.680
So if you give us a name, like, say,
image,

00:16:43.680 --> 00:16:48.560
we start looking for an image named
image zero in all our supported formats,

00:16:48.560 --> 00:16:50.440
or image one in all
our supported formats.

00:16:50.440 --> 00:16:54.500
And then we'll run up the numbers
until we stop finding images.

00:16:54.530 --> 00:16:57.860
We'll take all of those images together
and put them into a single UI image

00:16:57.860 --> 00:17:01.160
that animates over a given duration.

00:17:01.180 --> 00:17:04.740
So it's just going to keep cycling
that animation all the way through.

00:17:04.740 --> 00:17:07.120
You can also, if you've been generating
your own images,

00:17:07.240 --> 00:17:12.120
you can use animated image with images,
provide us an NSArray of images,

00:17:12.160 --> 00:17:13.970
and we'll go ahead and
animate those also.

00:17:14.100 --> 00:17:17.360
So you may have generated a
bunch of UI images for your UI,

00:17:17.370 --> 00:17:20.250
or the user's done something,
you've collected all of those images,

00:17:20.250 --> 00:17:22.020
you're going to animate them over time.

00:17:22.020 --> 00:17:23.240
You can do that.

00:17:23.280 --> 00:17:26.850
There are two read-only properties,
NSArray images, and the duration,

00:17:26.850 --> 00:17:28.230
which is in this time interval.

00:17:28.370 --> 00:17:31.180
So if you do create one of these,
you don't get to sort of just wedge

00:17:31.180 --> 00:17:33.720
an image there in the middle and
have it show up in the animation.

00:17:33.720 --> 00:17:37.320
You'll have to recreate the
animated image to get that to work.

00:17:38.380 --> 00:17:43.130
We've also added some new API to
do stretching and tiling of images.

00:17:43.140 --> 00:17:44.740
So we had some other stuff.

00:17:44.810 --> 00:17:46.880
You can also use content
center and things like that.

00:17:47.080 --> 00:17:50.790
But we tried to make this as
simple as possible with one API.

00:17:51.060 --> 00:17:56.180
So resizable image with cap insets
allows you to specify a UI edge inset.

00:17:56.370 --> 00:18:00.440
And then we'll make some decisions
based on that as to how we will stretch

00:18:00.560 --> 00:18:02.580
or tile the images that you give us.

00:18:03.280 --> 00:18:03.730
All right.

00:18:03.730 --> 00:18:05.760
So you start with an existing image.

00:18:05.760 --> 00:18:09.000
You send that image,
resizable image with cap insets.

00:18:09.050 --> 00:18:13.820
If you were to specify for
this image a cap inset of 0101,

00:18:13.820 --> 00:18:20.190
remember that's top left, bottom right,
we would take that middle section and

00:18:20.300 --> 00:18:22.440
stretch that as the image gets wider,
right?

00:18:22.440 --> 00:18:26.810
So this basically allows you to
create a three-part stretchable image.

00:18:27.520 --> 00:18:31.130
If you were to do it for a larger image,
right,

00:18:31.130 --> 00:18:33.860
that inset now specifies a bigger block.

00:18:33.930 --> 00:18:37.160
It's not a one pixel slice,
it's a four pixel slice.

00:18:37.200 --> 00:18:41.820
If you were to resize this image now,
we would take that middle section and

00:18:41.980 --> 00:18:44.670
tile it across rather than stretch it.

00:18:45.020 --> 00:18:48.610
So if you've got images that your
designers handed you and you're

00:18:48.810 --> 00:18:52.570
going to stretch all this stuff out,
this is an easy way to do it.

00:18:52.570 --> 00:18:56.550
And we also allow you to create
nine part images doing this as well.

00:18:56.550 --> 00:19:00.460
So if you're to specify insets of 1111,
we'll take that.

00:19:00.500 --> 00:19:02.550
The corners will be a static size.

00:19:02.550 --> 00:19:07.120
As you resize this image horizontally,
the middle sections will get tiled.

00:19:07.120 --> 00:19:10.860
And if you resize it vertically,
those middle sections across the

00:19:11.050 --> 00:19:13.290
center horizontally will get tiled.

00:19:13.290 --> 00:19:18.030
So constructing images that do this
well is probably a good task for

00:19:18.030 --> 00:19:20.980
somebody who's really good at Photoshop.

00:19:20.990 --> 00:19:25.140
But this makes it really easy to be able
to do those kinds of tilings for you.

00:19:26.590 --> 00:19:29.740
And we also can do this with
animated images as well.

00:19:29.740 --> 00:19:32.700
So if you have a series of these,
you can do animated

00:19:32.700 --> 00:19:34.970
resizable image named,
cap insets,

00:19:34.970 --> 00:19:39.200
duration and then as you resize it,
we're going ahead and animating all

00:19:39.220 --> 00:19:41.380
of those images behind the scenes.

00:19:41.390 --> 00:19:44.810
Most of the places where you see
UIKit API that takes a UI image,

00:19:44.810 --> 00:19:48.220
you can pass it one of these
animated images as well,

00:19:48.490 --> 00:19:48.920
right?

00:19:48.920 --> 00:19:50.810
So that will work also.

00:19:54.730 --> 00:19:58.740
Here is some boilerplate code.

00:19:58.790 --> 00:20:00.460
How many of you have
written in code like this?

00:20:00.500 --> 00:20:00.940
Right?

00:20:01.010 --> 00:20:04.960
Oh, I hit a button and then I have to go
find out what navigation controller

00:20:04.960 --> 00:20:08.970
I was in and then I will create a new
UI view controller based on that and then

00:20:08.970 --> 00:20:13.710
I will push that UI view controller on
to the navigation controller and there's

00:20:13.710 --> 00:20:19.080
probably thousands of instances of this
in your own code right off the bat.

00:20:19.380 --> 00:20:22.530
It would be great if you could go
through and draw your application

00:20:22.530 --> 00:20:25.000
out and draw the workflow of your
application out without having

00:20:25.000 --> 00:20:26.190
to write a bunch of that code.

00:20:26.200 --> 00:20:30.500
And the DevTools guys probably
demoed this yesterday.

00:20:30.500 --> 00:20:32.040
I wasn't able to go to it unfortunately.

00:20:32.040 --> 00:20:34.610
They've developed a thing
called storyboarding,

00:20:34.610 --> 00:20:39.890
right, where you lay out your application
and the workflow of your application

00:20:39.890 --> 00:20:44.720
in Xcode and they'll drive the
events from within the storyboard.

00:20:44.720 --> 00:20:46.830
In this case,
we've got a navigation controller

00:20:46.830 --> 00:20:48.480
that's the root view controller.

00:20:49.050 --> 00:20:51.610
It has a table view, right,
one of those static content

00:20:51.610 --> 00:20:54.290
table views that you can learn
about in the UI table view talk.

00:20:54.700 --> 00:20:58.080
And that next icon there is a segue.

00:20:58.080 --> 00:21:01.680
It's a transition from one
view controller to another,

00:21:01.680 --> 00:21:02.340
right?

00:21:02.340 --> 00:21:04.090
So when you're participating
in a storyboard,

00:21:04.230 --> 00:21:06.230
the storyboard is kind of
a framework that drives the

00:21:06.230 --> 00:21:07.690
events of your application.

00:21:07.700 --> 00:21:11.330
You can find out what's happening
in your storyboards because

00:21:11.410 --> 00:21:13.120
we've given you API for that.

00:21:13.140 --> 00:21:16.720
There's a storyboard accessor
that's a read-only accessor that

00:21:16.810 --> 00:21:20.470
tells you what storyboard is
associated with your view controller,

00:21:20.470 --> 00:21:20.940
right?

00:21:21.020 --> 00:21:24.790
So when you fire up your storyboard-based
app and you want to know what's

00:21:24.790 --> 00:21:27.150
going on in the storyboard,
this is how you find out which

00:21:27.220 --> 00:21:28.780
storyboard you're associated with.

00:21:28.820 --> 00:21:31.990
There are also two methods
on UI view controller itself.

00:21:32.000 --> 00:21:36.620
Every segue in a storyboard
has a segue identifier.

00:21:36.620 --> 00:21:37.640
It's an NSString.

00:21:37.640 --> 00:21:40.230
So if you want to drive one
of these transitions yourself,

00:21:40.230 --> 00:21:41.100
you can do that.

00:21:41.220 --> 00:21:43.180
Perform segue with identifier sender.

00:21:43.180 --> 00:21:44.940
It's sort of a target action type thing.

00:21:44.940 --> 00:21:49.180
And then if a segue occurs,
your view controller will get

00:21:49.180 --> 00:21:52.170
notified of it on this prepare
for segue sender method.

00:21:52.180 --> 00:21:55.550
And this gives you the full
UI storyboard segue object.

00:21:55.710 --> 00:21:58.110
It's going to tell you all about
the context of what's happening,

00:21:58.140 --> 00:21:58.580
right?

00:21:58.590 --> 00:22:00.940
Is it a UI navigation controller push?

00:22:00.940 --> 00:22:02.200
Is it a modal presentation?

00:22:02.200 --> 00:22:03.550
All of those things.

00:22:03.690 --> 00:22:06.190
So storyboards give you a
really powerful way to be able

00:22:06.190 --> 00:22:08.710
to sketch out your application,
but they don't tie you

00:22:08.840 --> 00:22:09.910
into it completely.

00:22:09.940 --> 00:22:12.180
So you can hit a certain point in
the workflow and decide that you're

00:22:12.180 --> 00:22:14.740
going to take over in code from there.

00:22:14.760 --> 00:22:18.180
And then you can always get
back to the storyboard workflow.

00:22:18.180 --> 00:22:20.860
Maybe by using perform
segue with identifier,

00:22:20.860 --> 00:22:21.510
right?

00:22:21.620 --> 00:22:25.210
So there's a good flexible point
where you can use storyboards,

00:22:25.510 --> 00:22:27.150
but you're not completely
committed to storyboards.

00:22:27.160 --> 00:22:28.900
If the storyboard doesn't
do something for you,

00:22:28.910 --> 00:22:32.450
you can get in and participate
in that by writing code yourself.

00:22:33.860 --> 00:22:38.570
There is a storyboarding applica--talk
introducing interface builder

00:22:38.570 --> 00:22:42.520
storyboarding here Wednesday at 11:30.

00:22:42.520 --> 00:22:44.700
It's a really,
really slick technology and it will

00:22:44.700 --> 00:22:49.080
cut back on a bunch of that boilerplate
code that you guys have been writing.

00:22:49.080 --> 00:22:52.480
So if you're interested,
please go to that too.

00:22:53.490 --> 00:22:55.640
Here's UISlider.

00:22:55.760 --> 00:22:59.160
It's not the sexiest UI class we have.

00:22:59.280 --> 00:23:03.890
But we get a lot of requests
to be able to customize things.

00:23:04.740 --> 00:23:08.760
And customizing UIKit has not
necessarily been some of the

00:23:08.760 --> 00:23:10.940
easiest code anyone's written.

00:23:11.100 --> 00:23:15.940
So what we've done in 5.0 is pushed
a bunch of customization API all

00:23:15.940 --> 00:23:17.980
the way through all of our controls.

00:23:18.100 --> 00:23:21.600
So at the most basic,
we've gone through and used tint

00:23:21.600 --> 00:23:25.130
color on almost every single
control you can access in UIKit.

00:23:30.500 --> 00:23:34.100
So that's in Slider's case,
that's the tint color for both the

00:23:34.100 --> 00:23:36.270
minimum and maximum track and the thumb.

00:23:36.270 --> 00:23:41.120
For switches,
the section that has on in it, right,

00:23:41.120 --> 00:23:42.010
you can tint that.

00:23:42.050 --> 00:23:45.740
So you'll be able to push tint color
all the way through including things

00:23:45.740 --> 00:23:49.140
like your navigation bars and your
toolbars and the toolbar items and

00:23:49.220 --> 00:23:53.020
all of the back buttons and things
like that that are in your interface.

00:23:53.040 --> 00:23:54.480
So if your designers
come to you and says,

00:23:54.540 --> 00:23:56.890
hey, I've got this great color scheme,
I want you to push it all the

00:23:56.890 --> 00:23:59.300
way through your application,
you can now do that in UIKit.

00:23:59.300 --> 00:24:02.590
But we've gone further and
we've also allowed you to put

00:24:02.730 --> 00:24:04.720
images in all of this stuff.

00:24:04.720 --> 00:24:07.640
So you can specify your own track image,
your own thumb image,

00:24:07.670 --> 00:24:10.370
you can specify your own
images for UI navigation bars,

00:24:10.420 --> 00:24:12.620
you can specify your
own images for toolbars,

00:24:12.620 --> 00:24:16.980
you can specify your own images for
almost everything in UIKit itself.

00:24:16.980 --> 00:24:21.900
So there's a lot of new customization
API on the individual instances.

00:24:21.900 --> 00:24:24.170
So hopefully that will cut back
on some of the methods whistling

00:24:24.220 --> 00:24:26.270
we've been seeing in UIKit.

00:24:32.430 --> 00:24:36.170
So the way you would configure
an individual UI slider is

00:24:36.270 --> 00:24:38.580
by just sending it a message,
right?

00:24:38.580 --> 00:24:41.870
UI slider, a slider,
set minimum tracked in color, UI color,

00:24:41.870 --> 00:24:43.150
red color and that changes it to red.

00:24:45.170 --> 00:24:50.280
But if you wanted to do this for every
single UI slider in your application,

00:24:50.950 --> 00:24:54.130
You could write a bunch of boilerplate
code and wrap that up and make

00:24:54.130 --> 00:24:57.290
sure that you always call your
code in order to get a UI slider.

00:24:57.290 --> 00:24:59.470
It's kind of a drag.

00:24:59.860 --> 00:25:04.120
We've introduced an idea of an
appearance proxy into UIKit.

00:25:04.510 --> 00:25:08.500
So what you would do is send the
appearance message to the class.

00:25:12.810 --> 00:25:15.360
OK, you're a little early, but that's OK.

00:25:15.380 --> 00:25:17.460
You'd send the appearance
message to the class,

00:25:17.480 --> 00:25:21.060
and then you'd send the same API that
you would use to configure a single

00:25:21.060 --> 00:25:22.720
instance to the appearance proxy.

00:25:22.720 --> 00:25:27.260
Now every single UI slider you create
comes out with that red tint color.

00:25:27.280 --> 00:25:31.290
The appearance proxy is new for iOS 5.0.

00:25:32.320 --> 00:25:35.030
And it means that if you know
how to configure one instance,

00:25:35.030 --> 00:25:37.670
you know how to configure all of them.

00:25:38.530 --> 00:25:39.700
Really simple.

00:25:39.750 --> 00:25:43.380
This is one of two methods in the
entire UIAppearance.h header in

00:25:43.380 --> 00:25:47.040
the Appearance Proxy protocol.

00:25:47.040 --> 00:25:49.950
The other one you'll have to come
to our appearance talk later.

00:25:50.040 --> 00:25:54.230
We've gone through and also tagged all
of the selectors that participate in this

00:25:54.230 --> 00:25:57.760
system with the UIAppearanceSelector tag.

00:25:57.760 --> 00:26:02.070
So this is your indication that
you'll be able to send the Appearance

00:26:02.070 --> 00:26:07.500
Proxy for that particular class
that setter and get that to layout.

00:26:08.420 --> 00:26:11.780
We're talking about all of this
stuff tomorrow here in the Presidio

00:26:11.780 --> 00:26:13.830
at 2 o'clock right after lunch.

00:26:13.830 --> 00:26:17.410
So if you're here for
the--for Waves talk,

00:26:17.410 --> 00:26:19.880
just stay put, all right.

00:26:19.880 --> 00:26:22.650
You'll be able to learn more about
all the stuff that we've put into

00:26:22.650 --> 00:26:26.300
the individual customizations as
well as how to really fine tune the

00:26:26.530 --> 00:26:28.570
customization of your application.

00:26:28.570 --> 00:26:29.330
So.

00:26:31.770 --> 00:26:33.400
Here's iBooks.

00:26:33.680 --> 00:26:37.520
You guys have probably seen iBooks,
right?

00:26:37.520 --> 00:26:39.720
This is the Objective-C programming
language guide,

00:26:39.720 --> 00:26:43.770
the sending messages to nil section,
a little bit of language esoterica.

00:26:43.960 --> 00:26:46.310
That's actually not the
important part here.

00:26:46.310 --> 00:26:48.460
The important part is the page curl.

00:26:52.160 --> 00:26:56.520
We've actually introduced
UI page view controller to UIKit.

00:26:57.050 --> 00:26:58.080
And it does this.

00:26:58.080 --> 00:27:01.280
It turns out if you've ever written
this-- this is a lot of math,

00:27:01.280 --> 00:27:02.080
right?

00:27:03.940 --> 00:27:09.030
So page view controller is a new
class in UIKit and I have a demo

00:27:09.440 --> 00:27:11.550
of this that I'd like to show you.

00:27:11.720 --> 00:27:16.230
So let's cut over here
to the demo system.

00:27:16.370 --> 00:27:17.300
There we go.

00:27:17.300 --> 00:27:20.680
Andromeda Galaxy is alive and well.

00:27:20.680 --> 00:27:23.930
The really slick thing about this demo
actually is you guys all have it if

00:27:23.930 --> 00:27:30.270
you're installing the beta because the
demo is pretty much a new project and

00:27:30.270 --> 00:27:33.040
you ask for a page based application.

00:27:33.800 --> 00:27:36.060
And we'll call this pager demo.

00:27:36.060 --> 00:27:39.120
We'll make it universal.

00:27:39.430 --> 00:27:40.820
There's the use storyboard check mark.

00:27:40.860 --> 00:27:42.380
We're not going to use that today.

00:27:42.410 --> 00:27:46.750
But we'll throw this up on the desktop.

00:27:48.800 --> 00:27:51.520
And here it is.

00:27:51.660 --> 00:27:52.280
And you know what?

00:27:52.380 --> 00:27:55.800
I'm just going to run this
on the iPad simulator.

00:28:04.880 --> 00:28:11.300
In portrait mode, January, a good month,
but we're not in that.

00:28:11.300 --> 00:28:18.180
If I just run over to the side of
the simulator here and just click,

00:28:18.180 --> 00:28:21.970
you see that page effect.

00:28:22.060 --> 00:28:26.940
If I just start mousing
and dragging here--

00:28:31.900 --> 00:28:36.350
And you'll notice too,
this is actually putting,

00:28:36.350 --> 00:28:37.680
I don't know if you can
see that at the top,

00:28:37.750 --> 00:28:40.280
let me grab a different part here.

00:28:40.280 --> 00:28:44.790
If I start really bending it,
you'll see that May here shows

00:28:44.850 --> 00:28:46.380
up on the back of this page,
right?

00:28:46.380 --> 00:28:52.530
You can actually see the back of the
page put through on portrait mode.

00:28:52.530 --> 00:28:53.840
You can see that other part.

00:28:53.840 --> 00:28:57.590
If I rotate,
I can kick it into a two up mode.

00:28:57.630 --> 00:28:59.880
And so we've got May and June here.

00:28:59.880 --> 00:29:02.620
And instead of seeing the
back of the previous page,

00:29:02.620 --> 00:29:06.040
what you'll see is the next
view controller in sequence.

00:29:06.260 --> 00:29:09.120
There's July, right?

00:29:09.530 --> 00:29:11.790
Automatically.

00:29:16.000 --> 00:29:28.900
[Transcript missing]

00:29:29.990 --> 00:29:34.900
We're not in two up mode on the phone,
but does this.

00:29:34.980 --> 00:29:37.060
So there's some interesting
things about the pager demo.

00:29:37.060 --> 00:29:42.210
And again, this is the template that
you get for creating a page

00:29:42.280 --> 00:29:44.230
based application in Xcode.

00:29:44.320 --> 00:29:47.020
We've organized this in
a fairly specific way.

00:29:47.020 --> 00:29:49.120
There's both a delegate
and a data source.

00:29:49.190 --> 00:29:53.920
And the data source is just a
thing that feeds view controllers

00:29:53.960 --> 00:29:55.840
into the page view controller.

00:29:55.950 --> 00:30:00.520
So it works very similar
to the UI table view code.

00:30:00.620 --> 00:30:04.710
So let's kick back to the slides.

00:30:07.280 --> 00:30:09.080
as if by magic.

00:30:09.080 --> 00:30:12.900
You initialize one of these if you
haven't created it in the Xcode template,

00:30:12.960 --> 00:30:15.530
you can initialize one with--in
it with transition style

00:30:15.530 --> 00:30:17.260
navigation orientation options.

00:30:17.490 --> 00:30:19.490
The transition style right now,
there's one.

00:30:19.490 --> 00:30:23.440
It's this page view controller
with the pagey bendy pages.

00:30:23.440 --> 00:30:26.830
The navigation orientation is what
direction is the tear happening?

00:30:26.830 --> 00:30:28.380
Is it happening like a book?

00:30:28.380 --> 00:30:30.170
Is it happening like a calendar?

00:30:30.170 --> 00:30:30.820
Right?

00:30:30.820 --> 00:30:34.300
So you can go up and down as well
as left and right and the options,

00:30:34.300 --> 00:30:36.710
there's a dictionary there
that you can pass in.

00:30:36.710 --> 00:30:42.000
This is all in the UI table view--page
view controller dot h header.

00:30:42.000 --> 00:30:43.570
It has a delegate and a data source.

00:30:43.860 --> 00:30:46.700
There are two very different
things that these do.

00:30:46.700 --> 00:30:49.880
The delegate tells you things like,
did the page view

00:30:49.880 --> 00:30:52.930
controller finish animating,
what the previous view controllers

00:30:52.930 --> 00:30:57.690
were on the screen and whether
or not a transition completed.

00:30:57.840 --> 00:31:00.560
So this is whether or not they
actually made it all the way through

00:31:00.560 --> 00:31:05.460
the animation or whether it flipped
back to the old orientations.

00:31:05.460 --> 00:31:08.900
And on rotation,
you get a page view controller spine

00:31:09.040 --> 00:31:11.100
location for interface orientation.

00:31:11.100 --> 00:31:14.490
And this is a very descriptive API,
so I couldn't fit everything

00:31:14.490 --> 00:31:15.260
on the slide here.

00:31:15.260 --> 00:31:19.360
But spine location is where
does that split happen,

00:31:19.360 --> 00:31:20.170
right?

00:31:20.300 --> 00:31:23.170
Is the binding, you can think of it as
the binding of a book,

00:31:23.180 --> 00:31:23.700
right?

00:31:23.700 --> 00:31:26.740
Is the binding at the bottom,
in the middle or at the top

00:31:26.740 --> 00:31:31.020
horizontally or at the right,
middle or left edge vertically?

00:31:31.020 --> 00:31:34.430
So you can, this is how when you rotate,
you can switch into the one

00:31:34.430 --> 00:31:38.550
up mode or you can go two up,
even vertically and things like that.

00:31:38.600 --> 00:31:42.540
The data source is even simpler.

00:31:42.560 --> 00:31:43.930
Two methods.

00:31:44.020 --> 00:31:48.130
We need you to tell us the view
controller before a view controller,

00:31:48.370 --> 00:31:51.770
depending on which way they're going,
and the view controller

00:31:51.770 --> 00:31:53.100
after a view controller.

00:31:53.700 --> 00:31:57.550
So if you're in one up mode,
you'd get one call for this probably for,

00:31:57.550 --> 00:32:00.160
you know, view controller after the
one that's on the screen.

00:32:00.160 --> 00:32:02.650
If you're in two up mode,
you'll get two calls.

00:32:02.830 --> 00:32:06.070
One for the one that's after
the rightmost one and then

00:32:06.070 --> 00:32:07.910
the one that's after that.

00:32:08.080 --> 00:32:10.780
So that we can take those two,
lay them out and do the effect

00:32:10.900 --> 00:32:14.240
when you open the book or turn that
page to be able to put them up.

00:32:17.750 --> 00:32:20.650
We're also talking a lot
about view controllers.

00:32:21.120 --> 00:32:24.830
The page view controller is very slick,
but, um,

00:32:25.210 --> 00:32:28.260
When we first came out
with the iPhone SDK,

00:32:28.290 --> 00:32:30.180
all we had was the phone.

00:32:30.220 --> 00:32:33.260
And when you were creating
a UI view controller,

00:32:33.300 --> 00:32:36.700
we really encourage you to write
your view controllers to take

00:32:36.700 --> 00:32:40.970
over the entire screen and to
manage screenfuls of information.

00:32:42.270 --> 00:32:44.840
Well, that was great,
except that then we came out with

00:32:44.840 --> 00:32:47.460
this device with a bigger screen,
and the tendency was to want to

00:32:47.460 --> 00:32:54.190
manage sections of the screen with
individual UI view controllers.

00:32:55.370 --> 00:32:59.190
So this view hierarchy has two views.

00:32:59.270 --> 00:33:00.620
They're controlled by view controllers.

00:33:00.720 --> 00:33:03.590
The one on the index zero
for the split view controller

00:33:03.590 --> 00:33:05.360
is a navigation controller.

00:33:05.380 --> 00:33:07.580
It has in it a table view controller.

00:33:07.770 --> 00:33:10.980
The one on the left at index
one is a custom view controller.

00:33:10.980 --> 00:33:12.020
We wrote it.

00:33:12.060 --> 00:33:14.200
It shows need information.

00:33:14.260 --> 00:33:17.680
That hierarchy looks a
little bit like this.

00:33:17.680 --> 00:33:22.690
And in sort of all of our
previous UIKit development,

00:33:22.750 --> 00:33:27.220
the containers were mostly written by us,
right?

00:33:27.220 --> 00:33:31.760
So you had a split view controller that
managed two sections of the screen.

00:33:31.760 --> 00:33:34.810
You had a navigation controller
that would manage entire sections

00:33:34.810 --> 00:33:37.890
of the screen and it kept track
of its children and it sent the

00:33:37.940 --> 00:33:43.000
rotation callbacks and things like
that to the child view controllers.

00:33:43.220 --> 00:33:46.500
You guys mostly filled in the leaf nodes.

00:33:46.640 --> 00:33:50.840
Things like your custom view controllers,
the table view controller that you

00:33:50.840 --> 00:33:54.880
subclass in order to put your own
data into and things like that.

00:33:55.010 --> 00:33:58.550
In iOS 5.0,
we are opening up the API so that you can

00:33:58.550 --> 00:34:02.810
write your own container view classes,
view controller classes.

00:34:07.530 --> 00:34:11.040
So writing a container is
actually pretty straightforward.

00:34:11.040 --> 00:34:14.940
We've made public the parent-child
relationship between view controllers.

00:34:14.990 --> 00:34:19.680
So there's add child view controller
and remove from parent view controller.

00:34:19.710 --> 00:34:23.910
These are kind of special.

00:34:24.940 --> 00:34:27.500
You should treat these methods
effectively as sort of protected

00:34:27.500 --> 00:34:28.900
methods on UI view controller.

00:34:29.030 --> 00:34:34.940
Your subclass will call these directly
to be able to add the children in,

00:34:34.940 --> 00:34:35.590
right?

00:34:35.690 --> 00:34:39.200
So you might have, you know,
some split view replacement that you're

00:34:39.200 --> 00:34:43.470
writing or something like that and
you've got a set view controllers method.

00:34:43.510 --> 00:34:45.860
It takes an array of UI view controllers.

00:34:45.950 --> 00:34:51.070
That method would call these, right,
to add the view controllers in.

00:34:51.160 --> 00:34:53.390
Once you've added a
child view controller,

00:34:53.390 --> 00:34:57.080
we take care of automatically
forwarding the rotation callbacks

00:34:57.290 --> 00:35:00.700
and all of the view will appear and
view did appear and all of those

00:35:00.700 --> 00:35:02.380
callbacks to your children for you.

00:35:08.740 --> 00:35:12.180
So you can also get the array
of child view controllers.

00:35:12.410 --> 00:35:16.800
This is just an accessor so
you can manage that array.

00:35:16.800 --> 00:35:21.040
And there's also API now for doing better
transitions between view controllers,

00:35:21.040 --> 00:35:21.320
right?

00:35:21.320 --> 00:35:23.030
So transition from view
controller to view controller,

00:35:23.030 --> 00:35:24.600
duration, options, animations,
completion.

00:35:24.600 --> 00:35:28.280
You put your animations in there,
completion block.

00:35:28.280 --> 00:35:30.910
This is the new transition API.

00:35:30.910 --> 00:35:32.710
It's very easy to use.

00:35:32.710 --> 00:35:36.430
Well, it's a good thing we
have code completion,

00:35:37.360 --> 00:35:39.930
There is an implementing
UI view controller container

00:35:40.020 --> 00:35:42.780
containment talk today at 1015.

00:35:42.780 --> 00:35:44.490
It's in the marina right next door.

00:35:44.500 --> 00:35:47.380
So if you're writing view controller
containers or if you think you need

00:35:47.380 --> 00:35:50.460
to write view controller containers,
this is the talk to go to.

00:35:50.460 --> 00:35:53.840
We're going to go into incredible
detail on everything that you can

00:35:53.840 --> 00:35:57.210
do to really manage entire trees
of view controllers that are going

00:35:57.210 --> 00:35:59.210
to manage sections of the screen.

00:35:59.220 --> 00:36:01.890
The other thing they'll do
is show you a lot more about

00:36:01.890 --> 00:36:03.780
UI page view controller as well.

00:36:03.780 --> 00:36:05.450
So there are a lot of things
that you can do with it.

00:36:05.540 --> 00:36:08.460
It's a very powerful API that
you can use to get really great

00:36:08.460 --> 00:36:10.140
effects in your application.

00:36:10.140 --> 00:36:13.880
So go next door, 1015, to see that.

00:36:15.920 --> 00:36:18.080
Working with documents.

00:36:18.080 --> 00:36:21.160
You saw the iCloud demos.

00:36:21.160 --> 00:36:26.320
UI document,
if you've used NSDocument on the desktop,

00:36:26.440 --> 00:36:28.000
UI document is very similar.

00:36:28.000 --> 00:36:30.280
It uses the same more modern
approach that we've been

00:36:30.280 --> 00:36:31.440
introducing on the desktop.

00:36:31.970 --> 00:36:33.800
You can initialize one with the URL.

00:36:33.800 --> 00:36:37.650
You can get back the file URL and you can
return a localized name to your users.

00:36:37.750 --> 00:36:42.670
If you're managing undo yourself
in a UI document subclass,

00:36:42.670 --> 00:36:45.780
you can set your own NSUndo manager.

00:36:45.800 --> 00:36:46.200
for that.

00:36:49.390 --> 00:36:53.530
This is a great way just to manage
documents within your application.

00:36:53.540 --> 00:36:56.040
We do a lot of the heavy lifting for you.

00:36:56.040 --> 00:36:59.170
You'll probably override
these four methods.

00:36:59.400 --> 00:37:01.180
Open and close with completion handler.

00:37:01.180 --> 00:37:05.060
We're making a fairly strong
statement here about making sure

00:37:05.060 --> 00:37:08.940
that the user's interaction with
your application is never blocked.

00:37:09.040 --> 00:37:13.430
If you're going off and you're loading
something from the network or you're

00:37:13.760 --> 00:37:18.120
reading a huge document off of disk,
if you're doing that on a main thread,

00:37:18.120 --> 00:37:20.810
you've only got five seconds before
the watchdog comes along and says,

00:37:20.880 --> 00:37:21.220
no more.

00:37:21.280 --> 00:37:22.110
You're done.

00:37:22.160 --> 00:37:27.290
So the open and close will happen on
a background thread automatically.

00:37:27.400 --> 00:37:29.590
And when it's done,
you'll get a callback on

00:37:29.710 --> 00:37:31.120
the completion handler.

00:37:31.120 --> 00:37:36.280
Load from contents of type error and
contents for type are your opportunity

00:37:36.280 --> 00:37:38.640
to read and write your content.

00:37:38.640 --> 00:37:41.770
So load from contents of type
error is where you're handed

00:37:41.770 --> 00:37:44.210
an NSData or a file wrapper,
and that's your opportunity

00:37:44.210 --> 00:37:45.030
to create your document.

00:37:45.040 --> 00:37:46.620
Contents for type error.

00:37:46.730 --> 00:37:48.970
Is where the system is
asking you for your data,

00:37:49.150 --> 00:37:52.810
either an NSData or an NS file wrapper,
so that you can write that out to disk.

00:37:52.840 --> 00:37:57.460
It also has a number of different
ways of working with errors.

00:37:57.560 --> 00:38:01.120
On iOS, there are a couple of cases
where your user might be able

00:38:01.120 --> 00:38:04.170
to interact with the device,
and then suddenly they can't.

00:38:04.180 --> 00:38:06.090
They get a phone call,
they hit the home button,

00:38:06.090 --> 00:38:06.920
things like that.

00:38:06.980 --> 00:38:10.010
Handle error user interaction
permitted is where we tell you,

00:38:10.010 --> 00:38:11.600
hey, something went wrong.

00:38:11.620 --> 00:38:13.160
Here's the error.

00:38:13.160 --> 00:38:14.620
The error is localized.

00:38:14.620 --> 00:38:16.660
It has localized recovery
suggestions and things like that.

00:38:16.700 --> 00:38:19.980
It's the same NSError that you've
worked with from Foundation before.

00:38:19.980 --> 00:38:22.700
User interaction permitted.

00:38:22.700 --> 00:38:24.730
If this is yes,
that means that there's actually,

00:38:24.730 --> 00:38:27.540
your app is still running,
the user can still tap the screen,

00:38:27.540 --> 00:38:30.690
and you can get information from
them about what they might want to

00:38:30.690 --> 00:38:32.420
do with the error that happened.

00:38:32.420 --> 00:38:35.470
Finished handling error
recovered is your opportunity

00:38:35.550 --> 00:38:37.680
to tell the UI document system,
hey,

00:38:37.900 --> 00:38:40.970
that error you gave me a few minutes ago,
yeah, I handled that.

00:38:41.000 --> 00:38:41.300
It's good.

00:38:41.300 --> 00:38:41.970
I got this.

00:38:42.020 --> 00:38:44.900
If you weren't able to recover,
then we go back and go into

00:38:44.900 --> 00:38:46.230
the automatic fallback.

00:38:46.440 --> 00:38:48.940
That's the fallback behavior
for UI document itself.

00:38:49.230 --> 00:38:52.190
User interaction no longer
permitted for error.

00:38:52.240 --> 00:38:57.290
You may have gotten a handle error
user interaction permitted yes earlier.

00:38:57.750 --> 00:39:00.040
If the user gets a call,
if the user hit the home button

00:39:00.040 --> 00:39:04.680
while that error was happening,
if the user gets, you know,

00:39:04.770 --> 00:39:08.450
an alert--if an alert pops up,
they can't interact with

00:39:08.450 --> 00:39:09.840
your application anymore.

00:39:09.880 --> 00:39:14.420
This is your opportunity to squirrel
all that data away so that when the

00:39:14.420 --> 00:39:18.600
user does come back to your application,
you can try and recover

00:39:18.600 --> 00:39:20.460
with them at the same time.

00:39:20.460 --> 00:39:25.030
So that if they restart your app,
you've got something that means that

00:39:25.030 --> 00:39:25.920
the user hasn't lost their data.

00:39:27.910 --> 00:39:31.050
There are a bunch of different states
that UI document moves through.

00:39:31.250 --> 00:39:35.600
State normal, closed,
in conflict is interesting.

00:39:36.290 --> 00:39:38.200
I won't tell you why yet.

00:39:38.220 --> 00:39:41.150
Saving error and editing disabled.

00:39:41.200 --> 00:39:43.190
There are a bunch of different
states this moves through.

00:39:43.200 --> 00:39:46.290
The in conflict one is
there for iCloud storage.

00:39:46.450 --> 00:39:49.770
One of the big reasons that we've
published UI document is that if you're

00:39:49.770 --> 00:39:53.990
overriding those four methods and you
tell us that this is an iCloud document,

00:39:54.100 --> 00:39:57.290
we're going to take care of all
of the heavy lifting of handling,

00:39:57.290 --> 00:40:00.650
notifying the cloud storage system
that it's there and moving that

00:40:00.650 --> 00:40:04.460
document around from device to
device for your users automatically.

00:40:04.680 --> 00:40:07.630
So if you override those four
methods and kick this document

00:40:07.630 --> 00:40:10.500
into cloud storage mode,
you're done.

00:40:10.500 --> 00:40:12.950
Your app now supports iCloud storage.

00:40:14.530 --> 00:40:17.400
should be a great feature for your users.

00:40:17.410 --> 00:40:21.120
The Document State Accessor just is your
opportunity to go back when you get the

00:40:21.120 --> 00:40:24.830
UI Document State Change notification
and find out what happened.

00:40:25.580 --> 00:40:30.640
There is a storing documents
in iCloud using iOS 5 talk here

00:40:31.210 --> 00:40:36.030
Wednesday at 3:15 where we will go
over all of this stuff as well as

00:40:36.070 --> 00:40:37.540
some demos and things like that.

00:40:37.680 --> 00:40:38.800
So please come by.

00:40:38.800 --> 00:40:41.400
If you're going to be using iCloud
and you have documents that your

00:40:41.400 --> 00:40:44.200
users are going to want on every
single one of their devices,

00:40:44.200 --> 00:40:47.290
and the short answer is your users
probably want your documents on

00:40:47.380 --> 00:40:50.340
every single one of their devices,
you should come see this talk.

00:40:54.120 --> 00:41:01.140
The Assets Library now has
access for adding group albums.

00:41:01.270 --> 00:41:04.660
So if you're going to tack on
a new photo or create a new

00:41:04.910 --> 00:41:07.720
photo album for your users,
you can do that with the

00:41:07.830 --> 00:41:11.120
Add Assets Group Album with
Name API and the result block.

00:41:11.180 --> 00:41:14.480
And you can also now add assets
to an asset group yourself.

00:41:14.480 --> 00:41:18.510
Right, so if you've got a photo app or
something like that where you're

00:41:18.740 --> 00:41:21.370
working with the AL Asset Library,
you can now do some

00:41:21.370 --> 00:41:22.680
of these nifty things.

00:41:23.500 --> 00:41:25.870
Write modified image data
to saved photos album,

00:41:25.870 --> 00:41:27.550
metadata completion block.

00:41:27.740 --> 00:41:32.650
This is your opportunity to take an
existing AL asset and modify it somehow

00:41:32.650 --> 00:41:37.780
and put a modified copy of that asset
right into the saved photos album.

00:41:39.650 --> 00:41:42.000
And set image data
metadata completion block.

00:41:42.000 --> 00:41:48.600
You'll actually be able to
replace that data in the album.

00:41:48.600 --> 00:41:49.910
GameKit.

00:41:50.020 --> 00:41:52.420
Scott talked a little bit about
GameKit on stage yesterday.

00:41:52.850 --> 00:41:56.320
There's now default leaderboard
support in GameKit and for player

00:41:56.460 --> 00:41:59.800
photos as well so you can find
out who's been killing you online.

00:42:00.070 --> 00:42:03.120
And turn-based multiplayer games.

00:42:03.120 --> 00:42:05.550
The essential game technologies
for iOS part one is happening

00:42:05.550 --> 00:42:08.540
right now so if you're here,
you're not seeing that talk.

00:42:08.690 --> 00:42:10.950
But it is being repeated
later in the week so you'll be

00:42:10.950 --> 00:42:12.360
able to go see the part one.

00:42:12.360 --> 00:42:14.640
You should look on your
schedules for that.

00:42:14.640 --> 00:42:17.280
Part two is in the
mission Tuesday at 10:15.

00:42:17.350 --> 00:42:20.600
If you're doing anything with GameKit,
this will be a great session to go

00:42:20.600 --> 00:42:24.670
to to add turn-based multiplayer
games to your application.

00:42:26.260 --> 00:42:30.920
Core Data, there's a lot of new stuff in
Core Data both on the desktop and on iOS.

00:42:30.920 --> 00:42:33.760
There's compound index
support for entities,

00:42:33.760 --> 00:42:37.540
incremental stores,
store specific migrations and they are

00:42:37.540 --> 00:42:42.660
doing a lot of work also to support
iCloud storage on Core Data databases.

00:42:42.660 --> 00:42:44.600
So there's a lot of stuff here.

00:42:44.600 --> 00:42:47.270
If you're a Core Data client,
the iOS talk is in the

00:42:47.440 --> 00:42:49.290
mission Tuesday at 3.15.

00:42:49.310 --> 00:42:50.440
You can go see that.

00:42:50.470 --> 00:42:53.510
There's also,
if you're programming for the desktop,

00:42:53.510 --> 00:42:55.120
a desktop talk as well.

00:42:58.250 --> 00:42:59.070
Newsstand Kit.

00:42:59.100 --> 00:43:04.480
New framework in iOS 5 supports
newspaper and magazine subscriptions.

00:43:05.020 --> 00:43:07.230
This is some of the stuff
that Scott talked about

00:43:07.230 --> 00:43:08.520
on stage yesterday also.

00:43:08.520 --> 00:43:12.210
There is a newsstand
library per application.

00:43:12.210 --> 00:43:15.230
So if you manage magazines
or newspaper subscriptions,

00:43:15.230 --> 00:43:17.990
you get a library for your
application and this is the

00:43:17.990 --> 00:43:21.350
API that's going to allow you to
manage the issues in your application

00:43:21.350 --> 00:43:25.180
as well as downloading new issues,
including downloading content

00:43:25.180 --> 00:43:26.690
that has multiple parts.

00:43:26.920 --> 00:43:30.390
So you might have a big HTML document
and all of the assets that go

00:43:30.390 --> 00:43:32.520
along with that HTML document.

00:43:32.520 --> 00:43:36.150
And also all of the API that you need to
touch off your background downloading.

00:43:36.150 --> 00:43:39.670
So when the user goes to sleep and puts
their iPad down and they wake up the next

00:43:39.670 --> 00:43:42.820
morning and you want to get that content,
it's already there.

00:43:42.820 --> 00:43:45.380
All of the API to do
that is in Newsstand Kit.

00:43:45.380 --> 00:43:49.560
And there's a building newsstand
apps talk in the marina at 4.30.

00:43:49.560 --> 00:43:53.520
So that's a great talk to
go to for newsstand options.

00:43:53.540 --> 00:43:55.400
Twitter integration.

00:43:55.720 --> 00:43:59.080
There's a Twitter integration
talk here Thursday at 2.

00:43:59.240 --> 00:44:02.530
The big hitter here is we take care
of all the authorization for you.

00:44:02.580 --> 00:44:05.380
There's a new accounts framework
on iOS which works in conjunction

00:44:05.380 --> 00:44:06.600
with the Twitter framework.

00:44:06.600 --> 00:44:09.280
So you'll be able to do
Twitter integration into your

00:44:09.340 --> 00:44:11.090
application right off the bat.

00:44:11.120 --> 00:44:12.190
So you can come see that.

00:44:13.910 --> 00:44:16.500
Core Image on iOS.

00:44:16.550 --> 00:44:19.620
How many of you actually do image
effects in your application?

00:44:19.620 --> 00:44:23.230
If you've been doing that on the desktop,
this should be very familiar to you.

00:44:23.340 --> 00:44:27.070
All of the filters,
vectors and colors and things like that

00:44:27.210 --> 00:44:29.800
are all available to you in iOS now.

00:44:29.910 --> 00:44:31.240
Also, new detectors.

00:44:31.240 --> 00:44:34.040
For instance, the face detection
algorithm is built into iOS.

00:44:34.040 --> 00:44:35.210
You have access to that.

00:44:35.330 --> 00:44:38.660
The image orientation stuff,
so you can find all--what orientation

00:44:38.660 --> 00:44:42.380
the image might be in if you don't
have that information off the camera.

00:44:42.380 --> 00:44:44.710
Edge detection,
all that stuff now you can

00:44:44.860 --> 00:44:46.580
do right on the device.

00:44:46.830 --> 00:44:50.740
Using Core Image on iOS and
MacOSX in the mission Thursday at

00:44:50.880 --> 00:44:55.330
2:00 if you're doing any kind of
great effects with your application,

00:44:55.490 --> 00:44:56.370
this is where you want to be.

00:44:58.030 --> 00:45:01.300
And finally,
GLKit is a new framework on iOS 5.

00:45:01.400 --> 00:45:07.560
If you're doing OpenGL stuff,
our examples on the website and one of

00:45:07.560 --> 00:45:12.680
the templates just takes an OpenGL view
and puts it right into the window.

00:45:13.510 --> 00:45:17.310
OpenGL, the GL Kit guys have put together
an Objective-C framework that

00:45:17.310 --> 00:45:20.320
really lowers the barrier to
using OpenGL in your application.

00:45:20.320 --> 00:45:28.430
There are two big hitter classes in here,
GLKView and GLKViewController.

00:45:28.640 --> 00:45:31.050
The view controller is really
interesting because if you make that

00:45:31.120 --> 00:45:34.140
the root view controller of your
application and you rotate the device,

00:45:34.280 --> 00:45:37.740
it will go through and put the
appropriate OpenGL transform

00:45:37.810 --> 00:45:40.660
onto that GLK view and rotate
it for you automatically.

00:45:40.750 --> 00:45:45.060
So if you've ever been playing a game
and you got the game center sheet that

00:45:45.360 --> 00:45:51.950
came up upside down because the game was
handling its translations on its own,

00:45:51.950 --> 00:45:53.690
this can help out.

00:45:53.750 --> 00:45:58.170
So there's a lot of built-in logic
that helps OpenGL work with UIKit.

00:45:59.500 --> 00:46:04.920
Advances in OpenGL ES for iOS 5 in
the mission Wednesday at 2 o'clock.

00:46:04.920 --> 00:46:11.620
So if you're using OpenGL,
please take a look at this talk.

00:46:11.620 --> 00:46:14.360
There are also a couple of
related iOS sessions for UIKit.

00:46:14.810 --> 00:46:19.160
There's a talk on iOS printing if you're
doing printing in your application

00:46:19.160 --> 00:46:24.220
in Russian Hill Tuesday at 3:15 and
there's a polishing your app tips and

00:46:24.220 --> 00:46:28.310
tricks talk at--in mission Tuesday at 2.

00:46:28.400 --> 00:46:28.400
And there's a polishing your app tips and
tricks talk at--in mission Tuesday at 2.

00:46:28.400 --> 00:46:28.480
And there's a polishing your app tips and
tricks talk at--in mission Tuesday at 2.

00:46:28.480 --> 00:46:30.630
And there--there's a lot of
really great performance and

00:46:30.630 --> 00:46:33.480
responsiveness information in
that--in that second talk there.

00:46:33.480 --> 00:46:37.010
So if you're going to be--you're
really looking to make sure

00:46:37.010 --> 00:46:39.880
that your app functions really
well and is very responsive,

00:46:40.260 --> 00:46:40.990
please go to this talk.

00:46:41.090 --> 00:46:42.990
We'll talk about instruments
and everything else you

00:46:43.050 --> 00:46:45.420
can do to debug your stuff.

00:46:45.880 --> 00:46:48.300
More information, Bill Dudney,
Applications Frameworks

00:46:48.300 --> 00:46:49.560
Evangelist extraordinaire.

00:46:49.560 --> 00:46:50.940
You've probably seen him running around.

00:46:50.940 --> 00:46:54.500
He's also doing a graphics
and drawing talk this week.

00:46:54.510 --> 00:46:57.300
So if you're doing any graphics by hand,
you should go see that.

00:46:57.530 --> 00:47:00.160
Documentation of Dev Center and
the developer forums.

00:47:00.160 --> 00:47:01.450
Please come see us.

00:47:01.540 --> 00:47:02.780
We're here all week.

00:47:02.780 --> 00:47:04.790
So thank you very much for coming.

00:47:05.120 --> 00:47:06.790
Enjoy.
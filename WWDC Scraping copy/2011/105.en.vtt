WEBVTT

00:00:10.080 --> 00:00:15.110
Hi, I'm Ian Baird, Engineer in the iOS
Apps and Frameworks group,

00:00:15.120 --> 00:00:19.370
and I'm here today to talk to
you about polishing your app:

00:00:19.490 --> 00:00:22.880
Tips and Tricks to
Improve the Responsiveness and

00:00:22.980 --> 00:00:25.800
Performance of your Application.

00:00:27.450 --> 00:00:29.860
Today we're going to talk
about a bunch of things,

00:00:29.890 --> 00:00:33.390
so let's go through them in the agenda.

00:00:33.510 --> 00:00:36.510
First,
we're going to talk about first launch.

00:00:36.700 --> 00:00:39.420
It's that most critical
time of your application.

00:00:39.510 --> 00:00:43.490
It's your application's
first dance with your user.

00:00:43.630 --> 00:00:47.570
It's going to color her experience
with your application for the rest

00:00:47.660 --> 00:00:49.700
of the time that she uses your app.

00:00:49.950 --> 00:00:53.510
It's also going to affect
her estimation of your skills

00:00:53.900 --> 00:00:56.290
as an application developer.

00:00:57.070 --> 00:01:01.320
Next, we're going to talk about workflow.

00:01:01.430 --> 00:01:07.680
Workflow is what happens during
that 10 to 15 critical seconds

00:01:08.240 --> 00:01:12.320
where the user has removed the
device from his or her pocket,

00:01:12.430 --> 00:01:16.770
launched your app,
and begun to complete a task.

00:01:18.690 --> 00:01:23.780
From there, we're going to move into a
discussion about responsiveness.

00:01:23.880 --> 00:01:26.710
Applications,
especially on the iOS platform

00:01:26.710 --> 00:01:30.800
or any embedded platform,
need to stay responsive.

00:01:30.800 --> 00:01:34.160
It's critically important,
especially on a mobile

00:01:34.160 --> 00:01:36.270
device and especially on iOS.

00:01:36.970 --> 00:01:39.940
And finally,
we're going to discuss something

00:01:40.090 --> 00:01:44.230
which is often overlooked by people,
but you have to sweat the small stuff.

00:01:44.320 --> 00:01:46.480
You have to consider the details.

00:01:46.740 --> 00:01:50.200
The details are a
collection of principles,

00:01:50.200 --> 00:01:53.460
thoughts, and ideas that,
if correctly addressed by

00:01:53.460 --> 00:01:56.820
the application developer,
will take your application from

00:01:56.820 --> 00:02:00.330
being something that people merely
use to something that they love,

00:02:00.450 --> 00:02:03.380
something that they'll want
to tell their friends about,

00:02:03.550 --> 00:02:06.180
something that they'll
want to tweet about,

00:02:06.300 --> 00:02:12.090
something that they'll want to rate
with five stars on the App Store.

00:02:14.070 --> 00:02:15.510
So first launch.

00:02:15.720 --> 00:02:19.140
As I already said,
it's the most critical time.

00:02:19.300 --> 00:02:22.000
It's your first
interaction with your user.

00:02:22.000 --> 00:02:24.000
So you have to really make it count.

00:02:24.170 --> 00:02:27.210
And the first thing that the
user is going to see after your

00:02:27.220 --> 00:02:31.840
beautifully rendered application
icon is the launch image.

00:02:32.000 --> 00:02:35.180
You can see here on the left,
we have the launch image

00:02:35.200 --> 00:02:36.940
for the Maps application.

00:02:36.990 --> 00:02:41.000
You'll notice that there's a
segmented control at the bottom,

00:02:41.070 --> 00:02:41.990
as well as two buttons.

00:02:42.000 --> 00:02:44.530
What you won't see here
is you won't see text,

00:02:44.530 --> 00:02:46.980
because this resource is not localized.

00:02:47.010 --> 00:02:50.000
You won't see a splash screen.

00:02:50.000 --> 00:02:53.300
Even though it would be nice
to call attention out to

00:02:53.310 --> 00:02:56.570
your company or to yourself,
if you've done everything right

00:02:56.570 --> 00:02:59.470
and your application loads quickly,
the user is only going

00:02:59.470 --> 00:03:01.950
to see the splash screen,
or the launch image,

00:03:01.950 --> 00:03:04.850
for just mere seconds.

00:03:05.000 --> 00:03:07.870
What the launch screen is there for
is to provide something for us to

00:03:07.870 --> 00:03:10.000
progressively build your user experience.

00:03:10.000 --> 00:03:15.850
It keeps there from being a jarring
transition from that first launch and

00:03:15.850 --> 00:03:22.980
springboard to when your app is up,
running, responsive, and ready for input.

00:03:23.000 --> 00:03:25.000
So let's launch the Maps app.

00:03:25.000 --> 00:03:29.960
You can see how it built in
progressively into its user interface.

00:03:29.980 --> 00:03:33.000
It's up and it's ready to go.

00:03:34.860 --> 00:03:38.680
Next, once you've gotten
past the launch screen,

00:03:38.680 --> 00:03:41.280
you're going to want to
avoid one-star reviews.

00:03:41.420 --> 00:03:46.810
You're often now going to be in your
application delegates and in app did

00:03:46.810 --> 00:03:50.390
finish launching method implementation.

00:03:50.480 --> 00:03:51.840
And it's dangerous in here.

00:03:52.050 --> 00:03:56.260
If you take too long to become
responsive to user events,

00:03:56.330 --> 00:03:56.680
Mr.

00:03:56.680 --> 00:04:01.760
Watchdog here is going to kill your app,
leading the user to think that your

00:04:01.760 --> 00:04:04.170
application has crashed on launch.

00:04:04.650 --> 00:04:06.370
So, to reiterate, Mr.

00:04:06.370 --> 00:04:09.800
Watchdog is going to
kill unresponsive apps.

00:04:09.900 --> 00:04:13.770
You're going to see crash
logs with 8 bad food.

00:04:14.560 --> 00:04:17.940
And your user is going
to rate your application:

00:04:17.940 --> 00:04:21.310
one star, crashes on launch.

00:04:21.460 --> 00:04:23.940
Now what can cause some
of these hidden hangs?

00:04:24.240 --> 00:04:28.900
What can cause your app to become
unresponsive and crash on launch?

00:04:29.030 --> 00:04:30.430
Well, you'd be a little bit surprised.

00:04:30.530 --> 00:04:33.550
I know I was when
I started to dig into this.

00:04:34.270 --> 00:04:37.280
First thing, there's the BSD DNS API.

00:04:37.640 --> 00:04:42.260
It's generally made up of synchronous
calls such as "Get Host by Name,"

00:04:42.780 --> 00:04:45.470
Get Host By Address.

00:04:45.470 --> 00:04:50.240
These leave you at the mercy of
any misconfigured network that your

00:04:50.240 --> 00:04:51.860
user happens to be attached to.

00:04:52.020 --> 00:04:55.100
Or,
if they're on a slower cellular network,

00:04:55.160 --> 00:04:58.620
you're going to be at the
mercy of any sort of latency

00:04:58.630 --> 00:05:01.020
that's built into the system.

00:05:01.020 --> 00:05:05.860
If the latency is too great,
the watchdog is going to kill your app.

00:05:06.510 --> 00:05:14.400
The next hidden hang that people often
overlook is use of the reachability API.

00:05:14.490 --> 00:05:17.290
You should use the asynchronous
methods where possible.

00:05:17.390 --> 00:05:21.820
We do have synchronous methods, though,
and it can be oftentimes very subtle to

00:05:21.830 --> 00:05:25.100
figure out which methods are synchronous.

00:05:25.240 --> 00:05:27.920
So you'll want to look
at the documentation and

00:05:28.180 --> 00:05:30.300
understand how to use the API.

00:05:30.450 --> 00:05:31.490
And why is this important?

00:05:31.560 --> 00:05:34.500
You may say, "Well,
I don't use the BSD DNS API when

00:05:34.500 --> 00:05:39.700
my app finishes launching."
"I don't use reachability."

00:05:39.860 --> 00:05:44.400
In many analytics packages,
there are embedded calls to reachability.

00:05:44.560 --> 00:05:47.350
The analytics package has
scraped all sorts of metrics

00:05:47.440 --> 00:05:51.480
concerning your application,
and it wants to be able to upload

00:05:51.480 --> 00:05:53.640
all of these metrics to a server.

00:05:53.770 --> 00:05:58.680
So there is a call to reachability.

00:05:58.850 --> 00:06:02.640
If this call to reachability
hangs and your app crashes,

00:06:02.700 --> 00:06:04.800
your users are going to blame you.

00:06:04.800 --> 00:06:06.390
They don't know it's
your partner's fault,

00:06:06.560 --> 00:06:07.800
and they don't really care.

00:06:07.900 --> 00:06:09.800
So again, they're going to rate your app.

00:06:10.010 --> 00:06:13.390
One star, crashes on launch.

00:06:15.350 --> 00:06:20.770
So, you're up, you've initialized any
analytics packages you're using,

00:06:20.820 --> 00:06:25.200
and your app is going to start
building out its user interface.

00:06:25.340 --> 00:06:29.880
In this case, it's often easy,
and it's a mistake that many first-time

00:06:29.880 --> 00:06:36.190
developers to the platform make,
is to create this massive, giant nib.

00:06:36.200 --> 00:06:38.190
And you know why you do it?

00:06:38.430 --> 00:06:39.180
Because it's easy.

00:06:39.200 --> 00:06:40.120
It's easy to do.

00:06:40.120 --> 00:06:43.700
You throw all your view controllers,
your views, your buttons,

00:06:43.700 --> 00:06:46.200
you reference a bunch
of external resources,

00:06:46.200 --> 00:06:50.200
or internal to your app bundle,
such as images,

00:06:50.250 --> 00:06:56.200
and you jam all of this into one big nib,
wire it up, and off goes your app.

00:06:56.390 --> 00:06:58.910
The problem with this is it's slow.

00:06:59.970 --> 00:07:03.480
So, how do you avoid the giant nib?

00:07:03.660 --> 00:07:07.020
If you're targeting iOS 5,
I would urge you to

00:07:07.020 --> 00:07:08.730
consider using storyboards.

00:07:08.800 --> 00:07:11.690
If you build a storyboard,
Xcode is going to take that

00:07:11.690 --> 00:07:15.800
storyboard and factor it in
to discrete nibs for you.

00:07:15.800 --> 00:07:20.270
Or, if you're still targeting iOS 4,

00:07:20.670 --> 00:07:23.700
Break these nibs into discrete nibs.

00:07:23.750 --> 00:07:28.310
Good rule of thumb is about
one nib per view controller.

00:07:28.490 --> 00:07:32.110
But you can break down even
further from there if you want to.

00:07:33.470 --> 00:07:38.830
So, to illustrate this point,
I developed an application, my NibTester,

00:07:38.850 --> 00:07:42.100
and it uses one giant nib.

00:07:42.240 --> 00:07:44.240
Let's watch it launch.

00:07:46.410 --> 00:07:48.090
Wait, wait, it's coming.

00:07:48.310 --> 00:07:49.600
Oh, there it is.

00:07:49.740 --> 00:07:51.680
And finally it's responsive.

00:07:51.810 --> 00:07:53.400
You see, it took a while.

00:07:53.540 --> 00:07:57.200
It took a while to become
responsive and ready for user input.

00:07:57.330 --> 00:07:58.480
This isn't good.

00:07:58.560 --> 00:08:03.350
I have one giant nib in here with a
UI tab controller and three UI view

00:08:03.350 --> 00:08:05.940
controllers embedded into it.

00:08:06.080 --> 00:08:11.510
When I took this application
and refactored it into three

00:08:11.850 --> 00:08:16.810
When I first started
working with NIBS with their

00:08:16.810 --> 00:08:16.810
associated view controllers,
I was able to realize

00:08:17.190 --> 00:08:22.860
A 44% savings in CPU cycles
required to load my app.

00:08:22.960 --> 00:08:27.060
Now not only does this translate
into wall clock savings for you,

00:08:27.150 --> 00:08:30.800
it also translates into
energy savings for your user.

00:08:30.900 --> 00:08:34.060
And that's really important
on a device which is mobile,

00:08:34.160 --> 00:08:36.340
like the iPhone or the iPad.

00:08:36.440 --> 00:08:40.570
And when you consider it like this,
why should the user have to pay

00:08:40.970 --> 00:08:44.900
the energy cost and the time cost
to load your entire application,

00:08:45.020 --> 00:08:50.560
when they may only be using a small
slice of it to complete her workflow?

00:08:50.970 --> 00:08:53.700
So size does matter when
it comes to your NIBs.

00:08:53.700 --> 00:08:58.670
Next,
one thing that people have often done,

00:08:58.670 --> 00:09:03.300
and it seems to be correct,
and it's a naive approach, and it works,

00:09:03.340 --> 00:09:05.140
but it will slow down the
loading of your application,

00:09:05.140 --> 00:09:09.890
it will make it less responsive,
is to not lazy load UI resources.

00:09:09.950 --> 00:09:13.400
And by resources,
I'm not only talking about images,

00:09:13.450 --> 00:09:16.320
I'm talking about making
database requests,

00:09:16.510 --> 00:09:19.790
I'm talking about fetching model objects,
I'm talking about parsing

00:09:19.880 --> 00:09:23.150
and loading plists,
doing things like that.

00:09:23.880 --> 00:09:28.680
You'll see it in many times being done
in the View Controller's initializer.

00:09:28.800 --> 00:09:32.680
This is probably not a good idea,
because you're going to have

00:09:32.680 --> 00:09:35.500
to pay this cost right when
the View Controller is created.

00:09:35.560 --> 00:09:38.030
Even if the View is never
used in the user interface,

00:09:38.250 --> 00:09:43.790
you're still going to have to pay this
cost to reconstitute this massive image.

00:09:43.910 --> 00:09:52.000
So instead, if you're using NIBs,
you should consider using ViewDidLoad.

00:09:52.120 --> 00:09:55.140
This waits until we
actually touch your View,

00:09:55.260 --> 00:09:57.300
which is under management
by the View Controller.

00:09:57.400 --> 00:10:00.500
At this point, it's a great time to go
ahead and load images,

00:10:00.630 --> 00:10:03.900
to send out fetch requests,
to grab resources.

00:10:04.000 --> 00:10:07.800
Or if you're not using NIBs,
consider using LoadView,

00:10:07.930 --> 00:10:10.390
or overriding LoadView.

00:10:11.640 --> 00:10:18.420
So your app is up, you've loaded your UI,
and we're going to talk about workflow.

00:10:18.500 --> 00:10:23.860
Consider that most of your users
may be at the soccer field,

00:10:23.860 --> 00:10:26.400
watching their son or
daughter play soccer,

00:10:26.400 --> 00:10:29.810
and they might just have a couple
of minutes to pull out their

00:10:29.810 --> 00:10:34.400
phone and check their Twitter feed
before a big play happens.

00:10:34.400 --> 00:10:38.400
Or they're in the grocery line
and they're about to check out.

00:10:38.400 --> 00:10:43.060
They generally have between 10 to
15 seconds to accomplish whatever

00:10:43.060 --> 00:10:46.400
goal they set out to accomplish
when they started your app.

00:10:46.400 --> 00:10:51.080
So workflow and a consideration of
workflow is very important to creating

00:10:51.080 --> 00:10:53.400
a responsive and performant iOS app.

00:10:54.850 --> 00:10:57.400
The first thing you'll see a lot
of apps do after they load is

00:10:57.400 --> 00:10:59.980
they'll hit you with an alert.

00:11:01.070 --> 00:11:02.500
These are not good.

00:11:02.620 --> 00:11:04.800
They interrupt flow.

00:11:04.980 --> 00:11:09.250
They can only represent a
very small amount of text.

00:11:10.110 --> 00:11:13.290
Any inappropriate use of an
alert will annoy your user.

00:11:13.580 --> 00:11:16.390
It's my least favorite alert of all time.

00:11:23.550 --> 00:11:25.500
We can't really do much else.

00:11:25.550 --> 00:11:27.720
You have to rate the presentation.

00:11:27.790 --> 00:11:28.940
I can remind you later.

00:11:30.050 --> 00:11:33.100
You can tell me no thanks,
but if I don't serialize this anywhere,

00:11:33.100 --> 00:11:35.100
I'm going to ask you again.

00:11:35.210 --> 00:11:36.500
It's really annoying.

00:11:36.620 --> 00:11:38.490
And if you create a good app,
users are going to want to

00:11:38.490 --> 00:11:40.500
rate your application anyway
by going to the App Store.

00:11:40.500 --> 00:11:42.900
They're going to be incented
to tell their friends.

00:11:42.940 --> 00:11:46.520
You can come up with better
ways to incent them to go to the

00:11:46.520 --> 00:11:49.090
App Store and rate your awesome app.

00:11:50.160 --> 00:11:53.930
The next alert I'd like to talk
about are the error alerts.

00:11:53.930 --> 00:11:56.560
What the heck does this mean?

00:11:57.940 --> 00:12:01.000
And more importantly,
it begs the question,

00:12:01.060 --> 00:12:03.040
what state is the application in now?

00:12:03.100 --> 00:12:05.640
Am I actually going to be able
to accomplish a task that I set

00:12:05.640 --> 00:12:09.340
out to accomplish when I took
the device out of my pocket?

00:12:09.400 --> 00:12:10.650
I'm not sure.

00:12:10.750 --> 00:12:12.140
All I can do is dismiss it.

00:12:12.270 --> 00:12:14.840
Again,
they don't give you very much context.

00:12:15.020 --> 00:12:18.300
You can only represent a
small amount of text here,

00:12:18.300 --> 00:12:23.880
or a very, very discrete choice,
and you're not getting that with this.

00:12:25.330 --> 00:12:28.840
So, I'm participating in my
company's Bike to Work Challenge,

00:12:28.890 --> 00:12:30.240
at least I did in May.

00:12:30.380 --> 00:12:33.350
I have a team and I see some of
my teammates in the audience.

00:12:33.350 --> 00:12:35.560
And I'm sorry I didn't
register my points last week,

00:12:35.630 --> 00:12:37.190
I was busy working on this presentation.

00:12:37.200 --> 00:12:41.640
But with that notwithstanding,
the days where I'm being a good boy,

00:12:41.640 --> 00:12:46.180
I ride into work, I put up my bicycle,
and I grab my device out of my pocket.

00:12:46.200 --> 00:12:49.040
It's been tracking my
ride as I ride into work.

00:12:49.210 --> 00:12:51.810
We get points, and we get t-shirts,
and things like that

00:12:51.810 --> 00:12:54.200
for riding into work,
and register our points.

00:12:54.200 --> 00:12:57.160
I go to upload my ride to the server,
and I'm greeted with this:

00:12:57.260 --> 00:13:00.910
There are a few problems
with this interface.

00:13:01.280 --> 00:13:07.500
There's too much information, really,
and it's the wrong kind of information.

00:13:07.560 --> 00:13:10.330
I have an indeterminate
progress indicator spinning,

00:13:10.330 --> 00:13:12.200
so I know something's going on.

00:13:12.340 --> 00:13:15.640
And then I have a determinate
representation of progress in bytes,

00:13:15.760 --> 00:13:17.020
which is pretty good.

00:13:17.140 --> 00:13:19.130
Good thing that I'm a computer geek,
because I kind of

00:13:19.130 --> 00:13:20.440
understand what's going on.

00:13:20.440 --> 00:13:24.010
I know that they're probably
uploading GPS coordinates,

00:13:24.010 --> 00:13:27.360
my time, my avatar, etc.

00:13:27.530 --> 00:13:29.120
But there's something
fundamentally wrong with this.

00:13:29.170 --> 00:13:31.300
You're presenting the user
with the option to cancel,

00:13:31.320 --> 00:13:36.200
and you're not telling her what's going
to happen if she elects to cancel.

00:13:36.300 --> 00:13:41.030
Does her ride, does my ride,
go to the great bit bucket in the sky?

00:13:41.140 --> 00:13:46.460
Is it cached back and then uploaded again
later when we can talk to the server?

00:13:46.540 --> 00:13:47.670
Who knows?

00:13:47.870 --> 00:13:51.940
My options are to let
it spin or cancel it.

00:13:53.860 --> 00:13:57.870
So, that being said,
I'd like to show you what

00:13:57.870 --> 00:14:01.190
I would consider a good way to
deal with a transient error,

00:14:01.330 --> 00:14:03.200
an error that comes and goes.

00:14:03.260 --> 00:14:06.900
You can see my dialer application here,
and I have the phone number for the

00:14:06.900 --> 00:14:09.980
Yellow Cab company in Cupertino,
just in case you ever need a ride.

00:14:10.200 --> 00:14:12.970
But right now I've assigned
it to Johnny Appleseed.

00:14:13.100 --> 00:14:16.720
And we're having a hard
time reaching the server.

00:14:16.850 --> 00:14:18.750
So I'm going to show this.

00:14:19.150 --> 00:14:22.360
I'm just going to push in a
little view from the bottom,

00:14:22.360 --> 00:14:25.950
and I'm going to tell people that
we're unable to connect to the server,

00:14:25.950 --> 00:14:28.460
but I'm not going to
obstruct their workflow,

00:14:28.530 --> 00:14:29.980
because I don't need to.

00:14:30.040 --> 00:14:34.260
They can actually continue on,
they can continue using the Dialer app,

00:14:34.720 --> 00:14:38.000
So you might want to consider when
you're talking to the user and

00:14:38.000 --> 00:14:43.300
when you're presenting alerts,
do I really need to interrupt the flow?

00:14:44.290 --> 00:14:47.290
There are appropriate uses of alerts,
and I've alluded to

00:14:47.420 --> 00:14:49.380
that in the last slide.

00:14:49.590 --> 00:14:54.340
Only use an alert when you're going to
offer critical information and choices,

00:14:54.410 --> 00:14:56.920
essentially when the user gets to
a fork in the road and they have

00:14:57.150 --> 00:15:01.810
to make a decision before they can
proceed working with your application,

00:15:01.810 --> 00:15:05.540
accomplishing the task,
such as for a login.

00:15:05.650 --> 00:15:06.250
This is a big one.

00:15:06.510 --> 00:15:09.300
My wife reminded me of this when
I was preparing these slides.

00:15:09.400 --> 00:15:14.820
She said, "Remember that time that you
guys released an alert and you

00:15:14.820 --> 00:15:21.310
didn't spell check the text,
and then it showed up on the internet?"

00:15:21.590 --> 00:15:23.250
It was very embarrassing
to say the least.

00:15:23.430 --> 00:15:27.060
So alerts bring this to the forefront,
but you should always spell

00:15:27.220 --> 00:15:30.710
check any text resources that
you include with your app.

00:15:31.140 --> 00:15:36.690
Finally, I would urge you to refer to the
iOS Human Interface Guidelines.

00:15:36.770 --> 00:15:39.840
It's going to tell you what the
appropriate uses for alerts are,

00:15:39.840 --> 00:15:41.260
and it will even provide examples.

00:15:41.470 --> 00:15:42.020
It's great.

00:15:42.320 --> 00:15:46.700
Next, I'd like to talk a bit more about
workflow and really get back

00:15:46.810 --> 00:15:48.580
into the main groove of workflow.

00:15:48.670 --> 00:15:51.350
And we're going to talk
about minimizing taps.

00:15:51.970 --> 00:15:58.340
I'm going to stress that the user has 10
to 15 seconds to accomplish whatever task

00:15:58.380 --> 00:16:00.550
that he or she set out to accomplish.

00:16:00.730 --> 00:16:06.740
In this case, in this contrived example,
we have three Shakespearean plays,

00:16:06.790 --> 00:16:10.140
and we're going to ask the
user to rate the passages.

00:16:10.140 --> 00:16:13.090
You can see that the user
is able to tap on rows,

00:16:13.090 --> 00:16:15.380
and this exposes the ratings chrome.

00:16:15.710 --> 00:16:17.900
We're not pushing more view controllers.

00:16:17.970 --> 00:16:19.580
We're not showing modals.

00:16:19.580 --> 00:16:22.480
We're showing the ratings
interface right in line.

00:16:22.630 --> 00:16:23.540
We're saving taps.

00:16:23.770 --> 00:16:24.920
We're saving time.

00:16:24.950 --> 00:16:28.180
We're creating a concise
workflow for the user.

00:16:28.220 --> 00:16:32.520
So for more information about workflow,
especially with respect

00:16:32.520 --> 00:16:35.040
to user experience,
I would urge you to attend

00:16:35.040 --> 00:16:38.270
the Designing User Interfaces
for iOS and Mac OS X apps,

00:16:38.270 --> 00:16:42.620
which is going to be given in
Pacific Heights tomorrow at 9:00 a.m.

00:16:42.620 --> 00:16:44.720
Yes, it is going to be worth
getting out of bed for.

00:16:44.720 --> 00:16:47.060
I know I have trouble with 9:00 a.m.

00:16:47.060 --> 00:16:49.280
too, but it's going to be a great talk.

00:16:49.280 --> 00:16:50.390
Set your alarm.

00:16:52.180 --> 00:16:55.490
Moving on,
we're going to chat about responsiveness.

00:16:55.600 --> 00:16:57.620
It's difficult to maintain
a good workflow if your

00:16:57.630 --> 00:17:00.940
application is not responsive,
if it hangs,

00:17:01.100 --> 00:17:04.250
if it sort of judders when you scroll.

00:17:04.370 --> 00:17:06.940
These are all things
which you want to avoid.

00:17:06.940 --> 00:17:10.170
And the reason why you want to avoid
them is not only for the reason

00:17:10.440 --> 00:17:13.050
of being in service of workflow.

00:17:13.310 --> 00:17:16.570
You want to preserve the illusion
that goes with an iOS app.

00:17:16.710 --> 00:17:20.130
iOS apps have been,
and iOS itself and the iPhone,

00:17:20.190 --> 00:17:22.040
have been described,
and not just by Apple,

00:17:22.040 --> 00:17:23.660
as magical devices.

00:17:23.780 --> 00:17:28.060
And they're magical because there's
this illusion to the user that she

00:17:28.130 --> 00:17:31.660
is working directly with elements
inside of your application.

00:17:31.780 --> 00:17:35.180
She's not interfacing with software.

00:17:35.270 --> 00:17:37.970
She's not interfacing with a device.

00:17:38.170 --> 00:17:41.460
They're interfacing directly with items.

00:17:41.750 --> 00:17:45.890
And when your app is unresponsive,
when it doesn't load quickly,

00:17:45.890 --> 00:17:49.740
when it throws up an alert,
you degrade this illusion to the

00:17:49.940 --> 00:17:52.680
point that it may not exist anymore.

00:17:53.620 --> 00:17:58.790
So, regarding responsiveness,
there are a few key touch areas

00:17:59.070 --> 00:18:03.520
that I want to discuss today.

00:18:03.520 --> 00:18:07.890
Dealing with network resources,
image handling,

00:18:09.300 --> 00:18:10.360
and TableViews.

00:18:10.430 --> 00:18:15.650
NSREL Connection is really
the workhorse of any network

00:18:15.650 --> 00:18:19.530
resource activity in your iOS app.

00:18:19.630 --> 00:18:20.600
There are a couple of ways to use it.

00:18:20.620 --> 00:18:23.940
One,
you can create a synchronous request.

00:18:24.050 --> 00:18:27.050
And there are some problems
with synchronous requests,

00:18:27.090 --> 00:18:29.080
and I'll go through a few of them.

00:18:29.080 --> 00:18:31.950
You have no control, one,
over any of the redirect

00:18:31.950 --> 00:18:33.360
activity that occurs.

00:18:33.360 --> 00:18:36.880
It's just going to redirect to
whatever the server tells it to,

00:18:36.880 --> 00:18:37.290
wherever the server tells it to go.

00:18:37.970 --> 00:18:42.140
Two, you're going to get back a
big bag of bytes as an NSData.

00:18:42.260 --> 00:18:49.820
Unless you have a really good
handle on how large this big

00:18:49.890 --> 00:18:51.650
bag of bytes is going to be,
you may end up allocating

00:18:51.650 --> 00:18:51.650
too much memory,
running out of memory,

00:18:51.650 --> 00:18:51.650
and your app is going to be killed.

00:18:52.150 --> 00:18:55.390
Finally,
and I'd say almost most egregiously,

00:18:55.390 --> 00:18:57.760
there's no way to cancel this.

00:18:57.760 --> 00:19:02.240
So if you create a request and then
you no longer need that request,

00:19:02.360 --> 00:19:05.990
you don't have any way to turn
it off when it's in flight.

00:19:06.150 --> 00:19:09.500
So I'd urge you to use
the asynchronous API,

00:19:09.560 --> 00:19:12.820
like connection request or
connection with request,

00:19:12.920 --> 00:19:16.290
and passing usually your controller,
but some other object,

00:19:16.290 --> 00:19:20.240
which implements the
NSERL connection delegate protocol,

00:19:20.240 --> 00:19:21.690
as the delegate.

00:19:22.450 --> 00:19:23.400
Why is this important?

00:19:23.400 --> 00:19:26.200
Why is cancellation so important?

00:19:26.240 --> 00:19:30.100
Well, you can see here we have an app,
and it's going to be using

00:19:30.100 --> 00:19:31.610
an item from the cloud.

00:19:31.910 --> 00:19:34.500
We see we're in the
initial view controller,

00:19:34.560 --> 00:19:39.570
and we have a button to
navigate to the subsequent view,

00:19:39.570 --> 00:19:41.560
which is going to fetch an image.

00:19:41.630 --> 00:19:44.850
So we do that,
and our server is unresponsive.

00:19:44.900 --> 00:19:45.660
It's taking a while.

00:19:45.660 --> 00:19:51.880
So the user elects to go away from this
view and go back to the initial one.

00:19:52.030 --> 00:19:54.610
At this point,
we need to be able to kill the request

00:19:54.690 --> 00:19:56.900
because we no longer need the resource.

00:19:56.960 --> 00:20:01.000
If we keep the request going,
we're going to end up burning CPU.

00:20:01.060 --> 00:20:04.680
And more importantly,
we're going to end up using the radio,

00:20:04.910 --> 00:20:09.270
especially if the user is using 3G
or some other cellular data service.

00:20:09.370 --> 00:20:11.210
We're going to keep the radio on.

00:20:11.310 --> 00:20:14.960
And so the user is going to
pay a battery cost for this.

00:20:15.070 --> 00:20:17.780
And then if they don't have
an all-you-can-eat data plan,

00:20:17.980 --> 00:20:21.520
you're going to end
up costing them money,

00:20:21.520 --> 00:20:23.090
too, for a resource which
they elected not to view,

00:20:23.270 --> 00:20:23.990
which is bad.

00:20:24.360 --> 00:20:28.140
Any discussion of networking
resources would be incomplete

00:20:28.240 --> 00:20:31.010
without discussion of caching.

00:20:31.150 --> 00:20:35.290
In iOS 5.0, it's even more important.

00:20:35.720 --> 00:20:38.100
You should take a look at NSRL request.

00:20:38.340 --> 00:20:40.100
There are a whole bunch
of caching policies there.

00:20:40.100 --> 00:20:41.600
I'm not going to go through them today.

00:20:41.740 --> 00:20:44.600
And there are also some
server-side considerations.

00:20:44.600 --> 00:20:47.100
I would urge you to look at RFC 2616.

00:20:47.100 --> 00:20:49.600
It's kind of heavy reading,
but especially take a look at

00:20:49.600 --> 00:20:52.990
the last modified entity header
and the e-tag response header.

00:20:53.160 --> 00:20:56.450
These are going to help you define
how long cache items should live

00:20:56.910 --> 00:21:00.770
in the durable cache on iOS 5,
the cache that can live

00:21:00.770 --> 00:21:02.580
between application sessions.

00:21:03.020 --> 00:21:04.590
So...

00:21:04.900 --> 00:21:08.920
You've defined your
NSURL connection delegate,

00:21:08.950 --> 00:21:11.630
and you've started your
asynchronous request.

00:21:11.790 --> 00:21:13.700
How do you deal with the data?

00:21:13.810 --> 00:21:18.930
Well, one common pattern is
to create a big buffer,

00:21:19.050 --> 00:21:23.240
like an NSMutable data,
and as bits flow in off the wire,

00:21:23.410 --> 00:21:26.490
you tack them on the
end of the data buffer.

00:21:26.780 --> 00:21:31.290
Then when the request completes,
you process that buffer

00:21:31.290 --> 00:21:35.410
in one fell swoop,
a lot of times on the main queue.

00:21:35.510 --> 00:21:37.290
I would say this is pretty bad.

00:21:37.540 --> 00:21:41.320
Again, responsiveness will suffer if
you're processing a huge chunk

00:21:41.320 --> 00:21:42.890
of data on the main queue.

00:21:43.680 --> 00:21:45.690
And secondly,
you're really going to increase

00:21:45.800 --> 00:21:47.980
the amount of memory that
your application is using,

00:21:48.000 --> 00:21:50.190
and that's not good either.

00:21:50.620 --> 00:21:54.690
So, I decided to create an
example to illustrate this,

00:21:54.740 --> 00:21:58.340
of how you should endeavor
to process this data.

00:21:58.340 --> 00:22:01.650
If you can,
you should endeavor to process the

00:22:01.650 --> 00:22:06.500
records at a protocol or a data
boundary as they flow in off the wire.

00:22:06.500 --> 00:22:10.040
So you can see here,
you can see my face looking down on you,

00:22:10.180 --> 00:22:13.210
you can see my avatar is
surrounded by some metadata.

00:22:13.440 --> 00:22:15.330
It's got my name,
it's got a record number,

00:22:15.400 --> 00:22:16.500
it's got all this stuff.

00:22:16.500 --> 00:22:18.660
Now,
we could process all of these records,

00:22:18.660 --> 00:22:21.220
or save back all these records
and process them as I was

00:22:21.220 --> 00:22:25.450
saying in one fell swoop,
or, since we know the record boundaries,

00:22:25.450 --> 00:22:29.730
we can turn them immediately
into model objects.

00:22:30.080 --> 00:22:31.790
And then toss the data as we go.

00:22:32.010 --> 00:22:34.080
And then the next record flows in.

00:22:34.200 --> 00:22:36.760
You can see, say,
a picture of my boss here.

00:22:36.950 --> 00:22:39.340
He has a humongous brain.

00:22:40.980 --> 00:22:46.340
We're going to take this record,
process it into a model object,

00:22:46.490 --> 00:22:48.390
and then toss the data.

00:22:48.550 --> 00:22:50.540
And we can even do
really cool things here,

00:22:50.540 --> 00:22:54.050
like write the avatars out to disk,
so that we don't have to hold onto

00:22:54.070 --> 00:22:58.800
them in critically and possibly
limited system resources like memory.

00:22:58.980 --> 00:23:03.810
So I touched on images just a
little bit in the last slide,

00:23:04.130 --> 00:23:06.490
but I'd like to talk about it some more.

00:23:06.660 --> 00:23:12.290
It's critical that you understand how
to deal with images in your iOS app.

00:23:14.070 --> 00:23:17.980
The first lesson I'd like to share
with you is that JPEGs are expensive,

00:23:17.980 --> 00:23:19.150
and I learned this the hard way.

00:23:19.370 --> 00:23:23.110
I had a recipes app
before I came to Apple,

00:23:23.110 --> 00:23:26.380
and we had these beautiful
parchment backgrounds.

00:23:26.450 --> 00:23:31.310
And as the user swiped
back between the recipes,

00:23:31.460 --> 00:23:33.120
it would go back through time.

00:23:33.180 --> 00:23:36.570
And as the recipe went back in time,
the parchment would yellow with age.

00:23:36.810 --> 00:23:38.760
It would begin to show age spots.

00:23:38.920 --> 00:23:40.360
It was a gorgeous effect.

00:23:40.430 --> 00:23:43.800
But what it did was it swelled
our app bundle up to the size that

00:23:43.800 --> 00:23:47.740
we were dangerously close to the
over-the-air limit for downloading

00:23:47.840 --> 00:23:49.700
our application at the time.

00:23:49.830 --> 00:23:54.940
So my partner and I decided to recompress
all of our backgrounds into JPEGs.

00:23:55.000 --> 00:23:58.580
And this was awesome,
until we noticed that there was

00:23:58.580 --> 00:24:00.240
a humongous performance hit.

00:24:00.490 --> 00:24:03.870
And when I opened up instruments,
I saw that we were spending humongous

00:24:04.040 --> 00:24:10.350
gobs of time decompressing JPEGs every
time the user would page between recipes.

00:24:10.360 --> 00:24:14.300
And so we went back,
we ended up using some tiling techniques,

00:24:14.360 --> 00:24:18.570
and we converted these images into PNGs.

00:24:18.720 --> 00:24:23.260
Now, pings in your app bundle are going
to be optimized by Xcode for you

00:24:23.750 --> 00:24:25.660
as part of the build process.

00:24:25.970 --> 00:24:27.620
However,

00:24:27.980 --> 00:24:31.410
External pings are still going
to need to be optimized by you,

00:24:31.410 --> 00:24:35.490
and you can use the Ping Crush utility to
optimize them before you put them up on

00:24:35.490 --> 00:24:37.020
the server and refer to them in your app.

00:24:37.290 --> 00:24:40.580
Another interesting concept,
a concept that is often overlooked,

00:24:40.690 --> 00:24:45.020
is that you can take smaller images
and make them into bigger images.

00:24:45.050 --> 00:24:51.200
You don't have to use massive gradients
or other uniform images in the background

00:24:52.020 --> 00:24:55.390
of your buttons or table view cells.

00:24:55.500 --> 00:25:00.150
What you can do is you can simply
feed this 1x50 pixel strip in and

00:25:00.150 --> 00:25:05.830
tell the image view to stretch
it out into a gradient for you.

00:25:06.190 --> 00:25:09.810
This is going to save memory
and it's going to be faster.

00:25:11.660 --> 00:25:13.140
The same goes for tiling.

00:25:13.150 --> 00:25:15.760
You may have a regular pattern,
such as a pinstripe,

00:25:15.760 --> 00:25:17.100
which I'm going to use here.

00:25:17.320 --> 00:25:23.310
And what you might think is that
what you want to do is because it's

00:25:23.310 --> 00:25:23.310
a relatively complicated pattern.

00:25:23.380 --> 00:25:27.700
You'll want to make a huge
pinstripe background and drop

00:25:27.770 --> 00:25:29.300
it right behind your table.

00:25:29.450 --> 00:25:30.700
But you don't want to do this.

00:25:30.700 --> 00:25:35.180
You factor it in to a tileable image,
tile it out,

00:25:35.230 --> 00:25:37.300
and stretch it using the API.

00:25:37.340 --> 00:25:40.500
Again, that's going to be faster,
that's going to be more efficient.

00:25:40.560 --> 00:25:45.000
If you're rendering artwork,
if you're tinting artwork,

00:25:45.000 --> 00:25:49.010
adding shadows to it on the fly,
you'll want to consider caching

00:25:49.010 --> 00:25:52.100
some of it in order to maintain
the responsiveness of your app.

00:25:52.200 --> 00:25:55.210
You don't want to have to recreate
this every time it's called for,

00:25:55.500 --> 00:25:58.230
especially if you're using
multiple instances of it in

00:25:58.230 --> 00:25:59.740
something like a table view.

00:26:00.040 --> 00:26:04.050
The naive approach to this would be to
stick it all in an NSDictionary and key

00:26:04.050 --> 00:26:07.050
it maybe by tint color or something,
for example.

00:26:07.150 --> 00:26:09.570
I would urge you not to do this.

00:26:09.790 --> 00:26:11.940
You should consider using NS Cache.

00:26:12.080 --> 00:26:12.520
Why?

00:26:12.940 --> 00:26:15.070
Because you can avoid the
abandoned memory problem,

00:26:15.400 --> 00:26:19.040
where you create this cached item,
this piece of artwork,

00:26:19.170 --> 00:26:24.410
and you never refer to it again,
but yet it lives for the rest

00:26:24.410 --> 00:26:24.410
of the lifetime of your app.

00:26:25.490 --> 00:26:33.330
Also, NSCache is going to evict its
contents during memory pressure,

00:26:33.330 --> 00:26:33.330
making your app less likely to be killed.

00:26:34.590 --> 00:26:36.850
And again, as I talked about,
you avoid the abandoned

00:26:36.850 --> 00:26:38.420
memory problem fairly neatly.

00:26:38.590 --> 00:26:41.290
You can also evict cache
items programmatically.

00:26:41.380 --> 00:26:44.480
So you should take a
look at the NS Cache API.

00:26:46.170 --> 00:26:50.170
Finally, I'm going to talk a little
bit about table views.

00:26:50.330 --> 00:26:52.180
Table views and cells.

00:26:52.320 --> 00:26:56.490
Table views are really bedrock,
foundational,

00:26:56.980 --> 00:27:00.510
is a great example of how to
improve your app's performance.

00:27:00.600 --> 00:27:04.310
He's been working on a new app called
"Table Views" that will help you

00:27:04.340 --> 00:27:06.400
customize your app's look and feel.

00:27:06.400 --> 00:27:09.400
It's a great app to use to
improve your app's performance.

00:27:09.400 --> 00:27:12.400
It's a great app to use to
improve your app's look and feel.

00:27:12.400 --> 00:27:14.560
It's a great app to use to
improve your app's performance.

00:27:15.440 --> 00:27:19.900
You should use instruments to find these
performance hotspots and to fix them.

00:27:20.120 --> 00:27:23.940
And to that end,
I've prepared a very simple

00:27:24.320 --> 00:27:28.170
demo showing you how to fix the
performance of a customized table

00:27:28.580 --> 00:27:30.400
view and its table view cells.

00:27:30.640 --> 00:27:35.400
You can see here we have a gradient
background for every table view cell.

00:27:35.400 --> 00:27:37.400
It's tinted blue.

00:27:37.520 --> 00:27:39.400
We have a text label.

00:27:39.400 --> 00:27:43.560
And we have a bunch of app icons
which are being ramped up and down

00:27:43.560 --> 00:27:46.390
in opacity to create a fading effect.

00:27:46.400 --> 00:27:50.200
Now, you may think this is the
projector playing tricks on you,

00:27:50.440 --> 00:27:53.500
that it couldn't possibly look this bad,
but let me tell you,

00:27:53.620 --> 00:27:57.400
this is absolutely crushing my iPad 2.

00:27:57.400 --> 00:28:00.400
Let's try to scroll.

00:28:00.400 --> 00:28:02.950
Oh, this is even more awesome.

00:28:04.870 --> 00:28:06.800
When you're faced with
a problem like this,

00:28:06.800 --> 00:28:10.830
the first thing you should do is look
to the tools to guide your search to

00:28:10.830 --> 00:28:15.390
help you figure out how to fix the
performance and responsiveness issue,

00:28:15.400 --> 00:28:17.300
which is highlighted in your application.

00:28:17.460 --> 00:28:18.780
So let's do that.

00:28:18.870 --> 00:28:20.840
Let's go into Instruments.

00:28:20.930 --> 00:28:24.540
If you've used Xcode 4 before,
this will be old news to you,

00:28:24.620 --> 00:28:26.930
but if you haven't,
you can dive directly into Instruments

00:28:27.020 --> 00:28:32.510
by going to the product menu
and using the profile menu item.

00:28:34.050 --> 00:28:38.350
This will build your application,
run instruments, and run your application

00:28:38.350 --> 00:28:39.690
directly on the device.

00:28:39.980 --> 00:28:43.470
Going to use the core
animation trace template.

00:28:44.970 --> 00:28:48.000
And this doesn't quite
give me everything I want,

00:28:48.000 --> 00:28:51.100
so I'm going to pull open the library.

00:28:51.160 --> 00:28:53.920
And look here in System.

00:28:54.640 --> 00:28:57.790
And I'm going to pull in the
CPU monitor so we can see how

00:28:57.790 --> 00:29:00.350
much CPU we're using as well.

00:29:00.760 --> 00:29:02.700
Sort by CPU.

00:29:02.890 --> 00:29:05.760
And you can see we're
using about 90% of the CPU.

00:29:06.020 --> 00:29:06.900
This isn't good at all.

00:29:06.900 --> 00:29:10.320
This is a battery vampire of an app.

00:29:11.530 --> 00:29:15.070
You see we're getting about
four or five frames per second,

00:29:15.120 --> 00:29:18.180
and it really doesn't get
much better when we scroll.

00:29:18.870 --> 00:29:20.640
Let's go and see what
we're doing in the sampler.

00:29:20.640 --> 00:29:22.440
There's a lot of data here.

00:29:22.480 --> 00:29:25.260
We can hide some of these system
libraries and see that we're spending

00:29:25.730 --> 00:29:29.100
most of our time in DrawRect.

00:29:30.000 --> 00:29:32.440
Let me just zoom in so you can see this.

00:29:32.560 --> 00:29:34.640
See that we're spending a
lot of our time in DrawRect.

00:29:34.760 --> 00:29:40.300
And the way I hid the system libraries
was to use this check in the call tree.

00:29:41.780 --> 00:29:46.060
So, let's go take a look at our draw-rect
method and see what we're doing.

00:29:46.070 --> 00:29:51.000
Okay, we're rendering the background,
creating a tint, gradient,

00:29:51.030 --> 00:29:56.080
there's a label text here,
and then we're rendering the image.

00:29:56.360 --> 00:29:58.670
I'm going to go to the
controller and show you how

00:29:58.670 --> 00:30:00.500
we're accomplishing the effect.

00:30:00.500 --> 00:30:05.070
We're using an animation timer
which fires once every 60 seconds,

00:30:05.070 --> 00:30:07.800
and we're calling the
animateCells method,

00:30:07.800 --> 00:30:12.070
which is querying our table view
for a collection of visible cells,

00:30:12.070 --> 00:30:16.450
and it's asking them to perform
this selector animation step.

00:30:16.530 --> 00:30:19.980
You see we're changing the icon opacity,
and at the very end of it we're calling

00:30:20.040 --> 00:30:26.370
selfSetsNeedsDisplay on the cell,
which is causing it to be redrawn.

00:30:26.650 --> 00:30:29.200
I think I showed you that
this is highly inefficient.

00:30:29.200 --> 00:30:30.490
You should probably take me at my word.

00:30:30.520 --> 00:30:31.290
Is that correct?

00:30:31.290 --> 00:30:34.720
Is this pretty inefficient?

00:30:34.720 --> 00:30:34.720
Okay.

00:30:34.910 --> 00:30:36.300
So we can fix this.

00:30:36.360 --> 00:30:38.780
We're obviously misusing the API.

00:30:38.900 --> 00:30:42.730
So let's refactor the icon fade effect.

00:30:43.650 --> 00:30:46.430
I'm going to come over
here to Demo Monkey,

00:30:46.440 --> 00:30:48.400
grab my snippet.

00:30:48.550 --> 00:30:51.200
And you can see that when
we set the icon image now,

00:30:51.310 --> 00:30:53.400
we're going to go ahead
and add the shadow to it,

00:30:53.480 --> 00:30:55.750
but then here's the key bit.

00:30:55.950 --> 00:30:59.710
We're going to kick off
an animation using this.

00:30:59.860 --> 00:31:03.440
We're going to send the alpha
of the image view back to zero,

00:31:03.440 --> 00:31:05.640
which is going to fade
it all the way out.

00:31:05.840 --> 00:31:09.130
But also,
we're going to execute that using the

00:31:09.130 --> 00:31:12.200
animate with duration call to UI view.

00:31:12.410 --> 00:31:16.520
And you can see here, I'll show you,
I'm hitting option and clicking,

00:31:16.740 --> 00:31:20.110
that we're going to repeat
the animation indefinitely.

00:31:21.190 --> 00:31:25.090
And we're going to auto-reverse.

00:31:25.090 --> 00:31:27.860
So after the alpha is
set all the way to zero,

00:31:27.900 --> 00:31:29.530
we're going to climb
all the way back to one,

00:31:29.530 --> 00:31:32.490
and then back to zero, and so on.

00:31:33.540 --> 00:31:37.240
So I've written myself a couple of notes,
I've removed the timer,

00:31:37.240 --> 00:31:42.550
and we can now remove this code,
which was rendering the

00:31:42.550 --> 00:31:44.880
image from DrawRect.

00:31:45.000 --> 00:31:47.320
We're going to get rid of the timer.

00:31:48.530 --> 00:31:52.500
Get rid of the timer and get
rid of this animate cells call.

00:31:52.580 --> 00:31:54.640
We don't need it anymore.

00:31:54.780 --> 00:31:59.740
Now, when we build and run, there.

00:31:59.840 --> 00:32:02.730
Now it's actually smoother.

00:32:11.560 --> 00:32:14.200
But we're not done.

00:32:14.410 --> 00:32:16.540
You see as we scroll,
we can get a little bit

00:32:16.540 --> 00:32:20.330
ahead of the table view,
and the performance dies.

00:32:21.900 --> 00:32:25.520
This isn't good at all,
and what we can do to fix this is we can

00:32:25.520 --> 00:32:29.470
get rid of the draw-rect call entirely.

00:32:29.760 --> 00:32:32.830
The next thing we were doing in DrawRect,
or one of the last things,

00:32:32.910 --> 00:32:33.870
is to draw the text.

00:32:34.050 --> 00:32:37.890
Let's get rid of that and
use the built-in label.

00:32:47.500 --> 00:32:54.090
To init, insert this here,
styling the label properly.

00:32:55.180 --> 00:32:58.680
And finally,
we're going to add accessors using

00:32:58.680 --> 00:33:03.540
the embedded text label that comes
with every UI table view cell

00:33:03.540 --> 00:33:08.530
and setting the string of that
text label to our icon label text.

00:33:09.630 --> 00:33:13.580
Going back to DrawRect,
you can see that the next thing that

00:33:13.580 --> 00:33:16.000
we need to kill off is the gradient.

00:33:16.210 --> 00:33:20.120
So, we can do that.

00:33:21.080 --> 00:33:23.800
Actually,
let's just kill the whole thing.

00:33:23.970 --> 00:33:25.700
Gone.

00:33:25.840 --> 00:33:27.880
I love refactoring code
by using the delete key.

00:33:27.880 --> 00:33:29.510
How about you?

00:33:32.620 --> 00:33:36.340
"We pull this in and put him there.

00:33:36.340 --> 00:33:40.500
We've got all of our reminders now,
done all of those things.

00:33:40.500 --> 00:33:42.800
We can stop.

00:33:43.740 --> 00:33:45.140
And build and run.

00:33:45.220 --> 00:33:47.150
And you can see that it's smooth.

00:33:47.210 --> 00:33:49.590
It's much smoother than it was before.

00:33:49.760 --> 00:33:55.430
But I can still detect there
are momentary times where

00:33:55.820 --> 00:33:58.610
the table view can outrun it.

00:33:58.840 --> 00:34:00.290
I don't really know what's going on here.

00:34:00.330 --> 00:34:02.220
I've killed off DrawRect.

00:34:02.220 --> 00:34:03.200
And back to instruments.

00:34:03.200 --> 00:34:06.270
I'm hitting Command-I to
get directly back in.

00:34:06.370 --> 00:34:10.510
And this time, I'm going to use the
allocations trace template.

00:34:12.300 --> 00:34:19.110
And I'm going to look for allocations
concerning table view stuff.

00:34:19.480 --> 00:34:22.570
And you can look here
while I'm scrolling,

00:34:22.570 --> 00:34:25.280
and I'm going to zoom in
so that you can see it.

00:34:25.760 --> 00:34:29.070
That as we're scrolling,
we're allocating loads and

00:34:29.070 --> 00:34:31.390
loads of table view cells.

00:34:31.730 --> 00:34:32.840
And this isn't good.

00:34:32.990 --> 00:34:36.110
Any sort of memory allocation,
any sort of object build up

00:34:36.180 --> 00:34:38.600
and tear down is expensive.

00:34:38.600 --> 00:34:42.510
So, I'm obviously not
reusing TableView cells.

00:34:42.600 --> 00:34:45.030
Let's go fix that.

00:34:55.760 --> 00:34:59.060
Put in our cell reuse support,
and we're going to reset the effect.

00:34:59.150 --> 00:35:02.830
We're going to drop our
reference to our icon image.

00:35:03.710 --> 00:35:06.300
And we're going to go to our controller.

00:35:06.400 --> 00:35:12.030
And you can see here why
cell reuse is not working.

00:35:12.270 --> 00:35:16.590
I have not set up a table
view cell identifier.

00:35:18.540 --> 00:35:20.500
This is fixed.

00:35:20.500 --> 00:35:24.700
Let's build, run,
and go into instruments again.

00:35:25.730 --> 00:35:30.400
And I'm going to scroll the app,
and as I scroll, you should see how many

00:35:30.470 --> 00:35:31.980
transitory objects we're creating.

00:35:32.190 --> 00:35:33.400
Zero.

00:35:33.490 --> 00:35:38.310
And if I flip back over to the iPad,
you'll see that it's smooth.

00:35:38.460 --> 00:35:39.940
We scroll like butter.

00:35:40.010 --> 00:35:44.650
Whoops, hello Notification Center.

00:35:44.780 --> 00:35:46.940
I can't outrun it.

00:35:47.180 --> 00:35:49.020
And we're done.

00:35:53.130 --> 00:35:56.000
So that was the demo.

00:35:56.000 --> 00:36:01.100
We noticed in the demo that
some of the key points were:

00:36:01.100 --> 00:36:03.900
Do not fight the API.

00:36:03.900 --> 00:36:05.460
If you're spending a lot
of time doing something,

00:36:05.490 --> 00:36:10.100
especially with respect to graphics,
compositing, graphics handling,

00:36:10.220 --> 00:36:12.390
go back and read the documentation.

00:36:12.540 --> 00:36:14.340
Take a look at what
Core Animation provides.

00:36:14.540 --> 00:36:17.980
Take a look at what UIKit provides.

00:36:18.070 --> 00:36:20.490
And see if you can refactor
your code around that.

00:36:21.620 --> 00:36:25.640
Next, we used instruments to find the
hotspots in the application.

00:36:25.740 --> 00:36:29.740
We were able to see the
hotspot in DrawRect and fix it.

00:36:29.950 --> 00:36:33.500
And then we were also able to
see when we weren't reusing

00:36:33.500 --> 00:36:35.830
table view cells and fix that.

00:36:37.720 --> 00:36:41.440
And again, I can't stress enough,
we see it all the time,

00:36:41.540 --> 00:36:43.750
reuse table view cells.

00:36:43.850 --> 00:36:47.210
Building them up and tearing them
down as a table view is scrolling

00:36:47.590 --> 00:36:52.190
will hurt responsiveness and
hurt the performance of your app.

00:36:53.030 --> 00:36:55.240
This brings me to the details.

00:36:55.360 --> 00:36:58.980
Again, as I described earlier,
the details are a

00:36:58.980 --> 00:37:02.540
collection of items when,
if considered properly by

00:37:02.540 --> 00:37:06.590
the application developers,
will make your application an

00:37:06.590 --> 00:37:10.150
enjoyable experience for your end user.

00:37:10.260 --> 00:37:12.640
You won't have to pop a rating
snag asking them to rate

00:37:12.640 --> 00:37:14.040
your app on the App Store.

00:37:14.130 --> 00:37:15.460
They'll tweet about it.

00:37:15.600 --> 00:37:17.710
They'll actually make their
way back to the App Store and

00:37:17.710 --> 00:37:19.100
give you a five-star review.

00:37:19.230 --> 00:37:24.200
So, without further ado,
we're going to talk a

00:37:24.200 --> 00:37:26.200
little bit about appearance.

00:37:27.300 --> 00:37:29.340
Then we're going to have a
discussion about the correct

00:37:29.600 --> 00:37:32.700
and tasteful use of animation.

00:37:33.250 --> 00:37:38.030
And then finally, or next to finally,
I'm going to discuss an often

00:37:38.030 --> 00:37:42.100
overlooked feature of iOS,
the care and feeding and

00:37:42.100 --> 00:37:44.390
management of the status bar.

00:37:45.060 --> 00:37:48.840
And then, now finally,
we're going to discuss your

00:37:48.840 --> 00:37:52.200
application's last act,
right before it moves

00:37:52.340 --> 00:37:56.000
into the background:
state saving.

00:37:56.870 --> 00:38:04.120
So, you can see my application,
my boring nav bar, and my boring cell.

00:38:04.400 --> 00:38:06.380
I'm not going to do much
about my boring cell.

00:38:06.510 --> 00:38:08.400
We already had a talk about table views.

00:38:08.500 --> 00:38:08.900
But you know what?

00:38:09.090 --> 00:38:11.100
I can fix the nav bar.

00:38:11.250 --> 00:38:15.120
And I can do it without
subclass or category hacks

00:38:15.200 --> 00:38:18.030
or method swizzling in iOS 5.

00:38:19.550 --> 00:38:22.340
And to do that,
I would urge you to attend the

00:38:22.340 --> 00:38:27.460
Designing User Interfaces for
iOS and Mac OS X Apps session.

00:38:27.460 --> 00:38:31.210
Again, that's going to be held in
Pacific Heights Wednesday at 9:00 AM.

00:38:31.370 --> 00:38:35.630
and the Customizing the Appearance
of UI Kit Controls session,

00:38:35.630 --> 00:38:39.540
which is going to be held in the
Presidio Wednesday at 2:00 PM.

00:38:39.620 --> 00:38:41.280
Sorry, I had to tease it.

00:38:41.400 --> 00:38:45.440
For animation, I thought I would do a
simple A/B comparison.

00:38:45.720 --> 00:38:50.290
The A side, the left side,
is the version of my application

00:38:50.540 --> 00:38:52.800
with all animations turned off.

00:38:52.880 --> 00:38:57.070
And the right side uses the standard
traditional animations found in

00:38:57.170 --> 00:39:00.400
UIKit applications or in iOS apps.

00:39:00.760 --> 00:39:02.200
Let's see how this looks.

00:39:02.200 --> 00:39:05.750
The user is going to push into the
next view controller and immediately

00:39:05.750 --> 00:39:07.700
be popped back out when they hit back.

00:39:07.990 --> 00:39:09.700
This is confusing.

00:39:09.700 --> 00:39:12.820
I have no idea where I am in the context
of your view controller hierarchy,

00:39:12.820 --> 00:39:15.700
and thus I'm confused about
the state of my workflow.

00:39:15.700 --> 00:39:20.600
So, in UIKit,
we solve this by using a transitional

00:39:20.600 --> 00:39:25.690
animation as one view controller
pushes in over another one,

00:39:25.690 --> 00:39:30.880
or another view pops
out over the previous.

00:39:31.470 --> 00:39:35.550
This helps to tell the user where they
are in your view controller hierarchy,

00:39:35.680 --> 00:39:38.400
and consequently, they know where they
are in their workflow.

00:39:38.650 --> 00:39:40.740
They're not lost.

00:39:42.670 --> 00:39:47.500
This ties in to responsiveness,
and it's the scrolling bounce.

00:39:47.550 --> 00:39:52.580
And it's this idea that an
application or a user interface

00:39:52.580 --> 00:39:56.920
element which responds to touch
should always respond to touches,

00:39:57.070 --> 00:40:00.640
even when there is no
more data to be seen.

00:40:00.830 --> 00:40:04.570
So to illustrate this, I have our friend,
the table view.

00:40:04.570 --> 00:40:07.200
It's a group table view full of cells.

00:40:07.300 --> 00:40:10.040
We're going to scroll to the
bottom and see what it looks like

00:40:10.100 --> 00:40:12.530
when animations are turned off.

00:40:13.670 --> 00:40:14.900
Reach the bottom.

00:40:14.960 --> 00:40:18.100
You have no indication of
what the application is doing.

00:40:18.300 --> 00:40:20.410
You scroll back to the top.

00:40:20.520 --> 00:40:22.450
Has this application crashed?

00:40:22.550 --> 00:40:23.460
I don't know.

00:40:23.480 --> 00:40:25.300
Or did you simply run out of data?

00:40:25.300 --> 00:40:27.190
The user does not know.

00:40:27.390 --> 00:40:33.970
So, in iOS, when you scroll to the bottom
of a list of table view cells,

00:40:33.970 --> 00:40:35.150
we bounce.

00:40:35.330 --> 00:40:37.690
And when you scroll back to the top,
we also bounce.

00:40:37.810 --> 00:40:40.150
You're out of data,
but we haven't stopped

00:40:40.430 --> 00:40:43.740
responding to touches,
haven't stopped responding to gestures,

00:40:43.780 --> 00:40:46.870
and that's critical if you're designing
your own user interface elements,

00:40:46.920 --> 00:40:53.230
to consider that responsiveness,
that you consider responding

00:40:54.310 --> 00:40:54.390
to touch even when there's no
more data to show the user.

00:40:55.670 --> 00:40:59.160
I'd like to chat about the status bar.

00:40:59.190 --> 00:41:02.070
Again, it's easily overlooked,
but it's one of the most

00:41:02.180 --> 00:41:06.600
important user interface
elements that we surface in iOS,

00:41:06.620 --> 00:41:12.330
because it shows the user, A,
what time it is, B, if there's a network

00:41:12.470 --> 00:41:15.590
connection available,
and C, most critically,

00:41:15.800 --> 00:41:17.950
the expected battery life for the device.

00:41:18.230 --> 00:41:21.050
How much longer is this device
going to last before I'm going to

00:41:21.050 --> 00:41:22.760
have to plug it back into a wall?

00:41:22.760 --> 00:41:25.890
So you should have a really
darn good reason to hide it.

00:41:26.000 --> 00:41:29.330
And you should only hide it
if your application is a game

00:41:29.330 --> 00:41:31.100
or has full screen media.

00:41:31.250 --> 00:41:35.170
And then if you hide it,
all of your Chrome should be able

00:41:35.170 --> 00:41:37.710
to be retrieved by a single tap.

00:41:38.470 --> 00:41:42.000
Finally, you should display the network
status indicator when needed.

00:41:42.140 --> 00:41:44.530
When something's going on,
it's important for the user to

00:41:44.800 --> 00:41:47.200
know that you're sending bits
back and forth over the air.

00:41:47.220 --> 00:41:49.400
Maybe they're going to put
the device into airplane mode.

00:41:49.430 --> 00:41:50.870
Who knows?

00:41:51.950 --> 00:41:54.870
And on the iPhone,
especially if you're customizing

00:41:55.010 --> 00:41:59.040
the navigation bar or any other
user interface elements that

00:41:59.040 --> 00:42:02.480
are close to the status bar,
you may want to set an appropriate

00:42:02.790 --> 00:42:05.410
color to make sure that you
don't clash with the status bar.

00:42:05.460 --> 00:42:13.020
And finally,
I'd like to talk about the last act that

00:42:13.410 --> 00:42:14.170
your application is going to perform:
state saving.

00:42:14.510 --> 00:42:17.970
It's very important that as
your application transitions

00:42:17.970 --> 00:42:21.470
into the background,
you serialize a representation of

00:42:21.480 --> 00:42:24.040
where the user is in the application.

00:42:24.200 --> 00:42:26.690
That way,
if she switches to go to another

00:42:26.690 --> 00:42:30.660
app to accomplish this workflow,
a fairly complex workflow,

00:42:30.680 --> 00:42:32.780
such as Safari,
to fetch some information which will

00:42:32.780 --> 00:42:37.110
be pasted back into a text field,
that if your app is asked to quit,

00:42:37.190 --> 00:42:40.800
it starts back up in the same
place as the user left it.

00:42:40.930 --> 00:42:44.740
So you'll want to consider serializing
out your navigational state,

00:42:44.840 --> 00:42:47.600
where your user is in your
view controller hierarchy,

00:42:47.680 --> 00:42:50.550
what is visible on screen.

00:42:51.440 --> 00:42:55.600
And you may want to consider serializing
any partially filled text fields,

00:42:55.670 --> 00:42:59.090
which of course you're going to
wipe out before the multitasking

00:42:59.280 --> 00:43:04.090
architecture or machinery swings into
place and takes another launch image

00:43:04.300 --> 00:43:08.120
for your user because you don't want to
capture the contents of any text field.

00:43:08.180 --> 00:43:12.340
And I must stress that you don't want
to serialize anything that's secure.

00:43:12.550 --> 00:43:15.350
Any passwords, pin numbers,
anything like that, of course,

00:43:15.510 --> 00:43:19.040
you don't want to serialize
to unsecure storage.

00:43:19.760 --> 00:43:22.180
Finally, for extra marks,
you may even want to serialize

00:43:22.240 --> 00:43:23.880
out things like scroll position.

00:43:24.010 --> 00:43:26.520
Again,
it should be completely transparent to

00:43:26.520 --> 00:43:30.670
the user that the application was asked
to terminate in the background and it

00:43:30.670 --> 00:43:32.810
had to restore when they came back to it.

00:43:33.230 --> 00:43:38.100
So, we've gone over many, many,
many details today.

00:43:38.310 --> 00:43:40.170
And in summary,

00:43:40.740 --> 00:43:43.360
We talked about the first launch.

00:43:43.420 --> 00:43:47.850
This is that critical first dance that
your application has with the user.

00:43:47.970 --> 00:43:53.270
This is going to color their perspective
of your application and their perspective

00:43:53.270 --> 00:43:57.300
of you as a developer for the rest
of the time that they use your app.

00:43:57.430 --> 00:44:02.090
So it's important that
your app launches quickly,

00:44:02.190 --> 00:44:07.700
it shows the correct launch image,
and is responsive to touch

00:44:07.700 --> 00:44:07.700
as quickly as possible.

00:44:08.580 --> 00:44:10.380
Then we talked about workflow.

00:44:10.490 --> 00:44:14.890
What happens during that critical
10 to 15 seconds that the user

00:44:14.890 --> 00:44:18.910
has your application out and is
attempting to accomplish whatever

00:44:18.910 --> 00:44:21.100
task they originally set out to?

00:44:21.870 --> 00:44:26.700
And next we talked about responsiveness,
not just in service of workflow,

00:44:26.800 --> 00:44:32.150
but also in service of creating the
solution of direct interactivity

00:44:32.580 --> 00:44:36.390
with the elements shown and
provided by your application.

00:44:36.730 --> 00:44:39.100
And finally, we talked about details.

00:44:39.240 --> 00:44:42.460
That collection of items that
if you consider are going to

00:44:42.460 --> 00:44:45.110
make users love to use your app.

00:44:46.500 --> 00:44:47.820
For more information,
you're going to want

00:44:47.920 --> 00:44:52.470
to talk to Bill Dudney,
our Application Frameworks Evangelist.

00:44:52.580 --> 00:44:55.680
He's reachable at dudney@apple.com.

00:44:55.680 --> 00:45:02.890
I'd urge you to go and look
at the iOS Human Interface

00:45:02.890 --> 00:45:04.250
Guidelines at developer.apple.com,
and I'm not going to read

00:45:04.250 --> 00:45:04.250
the rest of that off.

00:45:04.980 --> 00:45:07.310
And then finally,
who here has been to the

00:45:07.310 --> 00:45:08.860
Apple Developer Forums?

00:45:08.970 --> 00:45:10.850
Let's see some hands.

00:45:11.320 --> 00:45:12.760
Great.

00:45:12.860 --> 00:45:14.620
Utilize this resource.

00:45:14.770 --> 00:45:19.900
You're going to be able to give
and get peer-to-peer support.

00:45:20.180 --> 00:45:23.800
Plus, Apple Engineers will drop
in from time to time,

00:45:23.870 --> 00:45:25.770
answer questions, give feedback.

00:45:25.990 --> 00:45:29.510
We can talk about radars and
all sorts of other things there,

00:45:29.510 --> 00:45:31.260
and help you with your app.

00:45:31.280 --> 00:45:35.680
It's a great resource.

00:45:35.680 --> 00:45:35.680
I urge you to utilize it.

00:45:36.460 --> 00:45:39.880
And here again are the sessions
which I've called out today.

00:45:40.170 --> 00:45:43.210
The first one is Designing
User Interfaces for

00:45:43.210 --> 00:45:44.340
iOS and Mac OS X Apps.

00:45:44.540 --> 00:45:47.600
That's going to be in Pacific Heights,
Wednesday at 9:00 AM.

00:45:47.850 --> 00:45:50.140
Customizing the Appearance
of UI Kit Controls,

00:45:50.140 --> 00:45:53.080
which is going to be in the Presidio,
Wednesday at 2:00 PM.

00:45:53.080 --> 00:45:56.290
That's going to show you how to
customize nav bars and things

00:45:56.290 --> 00:45:57.960
like that without hacking.

00:45:58.180 --> 00:46:01.050
And finally,
improving the stability of your apps,

00:46:01.130 --> 00:46:06.600
which is going to be in the Presidio,
Thursday at 11:30 a.m.

00:46:06.740 --> 00:46:08.460
Thank you.
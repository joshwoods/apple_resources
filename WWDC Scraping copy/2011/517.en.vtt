WEBVTT

00:00:15.250 --> 00:00:18.750
Hello, everybody.

00:00:18.770 --> 00:00:19.300
Thanks for coming.

00:00:19.300 --> 00:00:23.900
Welcome to session 517,
Using Local and Push Notifications

00:00:24.180 --> 00:00:27.420
on iOS and Mac OS X.

00:00:29.720 --> 00:00:30.910
My name is Darryl Bleau.

00:00:31.050 --> 00:00:35.800
I am the engineering manager for
the Apple Push Notification Service.

00:00:35.860 --> 00:00:39.000
And I'm here to talk to you
today about notifications.

00:00:41.510 --> 00:00:44.020
So here's some of the
topics we'll be covering.

00:00:44.140 --> 00:00:47.920
First, we'll be giving an introduction
to notifications in general.

00:00:48.480 --> 00:00:51.730
Then we'll be walking through
the push architecture,

00:00:51.880 --> 00:00:55.560
some of the protocols,
and generally how the service works.

00:00:56.510 --> 00:01:00.200
We'll then be talking to you about
local and push notifications on iOS,

00:01:00.390 --> 00:01:05.870
followed by a talk on
notifications for Mac OS X.

00:01:07.010 --> 00:01:09.710
After that, we'll follow through with
some best practices for using

00:01:10.150 --> 00:01:12.400
notifications in general.

00:01:13.760 --> 00:01:16.760
So, an introduction to notifications.

00:01:16.880 --> 00:01:20.250
First of all, what is a notification?

00:01:20.790 --> 00:01:26.190
Generally, a notification is user visible
information that reflects some event,

00:01:26.190 --> 00:01:30.810
such as a service center letting you know
that your vehicle is ready for pickup.

00:01:33.300 --> 00:01:37.520
Why should I use notifications?

00:01:37.520 --> 00:01:40.820
One good reason to use notifications
is to ensure time-sensitive delivery

00:01:41.140 --> 00:01:43.440
even when your app is not running.

00:01:43.440 --> 00:01:47.400
For example, I have a stock alert.

00:01:52.100 --> 00:01:55.820
How does using the push
service compare to,

00:01:55.860 --> 00:01:58.600
say, having your app poll?

00:01:58.600 --> 00:02:03.640
Well, push notifications are driven by
your server and are immediate,

00:02:03.760 --> 00:02:07.230
if possible,
whereas polls are driven by your

00:02:07.240 --> 00:02:09.720
app and are potentially latent.

00:02:12.030 --> 00:02:16.100
In the example app shown here,
if we have a doorbell application that

00:02:16.130 --> 00:02:20.050
lets you know someone's at your door,
you'd want to know that immediately,

00:02:20.050 --> 00:02:22.000
and not five or ten minutes later.

00:02:25.700 --> 00:02:29.700
Okay, so an overview of notifications,
specifically with push.

00:02:29.700 --> 00:02:35.000
Notifications are sent
directly to a target device.

00:02:35.830 --> 00:02:43.180
They are intended as
a tap on the shoulder.

00:02:43.180 --> 00:02:43.180
And by that we mean they should
reflect some server-side state.

00:02:46.450 --> 00:02:51.540
Also, push notifications feature a
store and forward mechanism.

00:02:51.640 --> 00:02:54.380
Which means that notifications which
are sent to devices that are not

00:02:54.490 --> 00:02:59.900
currently connected are stored and
delivered when the device reconnects.

00:03:02.220 --> 00:03:08.560
When a device reconnects,
it will receive the latest

00:03:08.560 --> 00:03:08.560
notification per application.

00:03:11.940 --> 00:03:15.800
Notifications can also be
sent with an expiry time.

00:03:15.950 --> 00:03:20.400
However, it is important to note that
the expiry only affects storage.

00:03:20.630 --> 00:03:25.690
Notifications which are sent to devices
that are online at the time are delivered

00:03:25.690 --> 00:03:28.240
regardless of any set expiry time.

00:03:32.800 --> 00:03:38.240
Let's take a look at the push
notification service architecture.

00:03:38.240 --> 00:03:42.540
The first component of the
push notification service

00:03:42.540 --> 00:03:46.760
is a device of some type,
followed by your server and

00:03:46.760 --> 00:03:49.240
the service in the middle.

00:03:51.770 --> 00:03:55.580
Each device has an identifying token.

00:03:55.640 --> 00:03:59.050
Your application will deliver
that token to your server.

00:03:59.310 --> 00:04:02.500
And when your server has
a payload ready to send,

00:04:02.510 --> 00:04:04.620
you'll combine those two
together in a notification

00:04:04.870 --> 00:04:09.100
and send that to the service.

00:04:09.120 --> 00:04:12.540
The push notification service
will then deliver to the device.

00:04:16.860 --> 00:04:20.360
Let's take a closer look at
that protocol between the push

00:04:20.360 --> 00:04:23.320
notification service and your server.

00:04:24.930 --> 00:04:29.160
The protocol used is a binary protocol,
and there are two different

00:04:29.220 --> 00:04:33.110
protocols that you can use
for sending a notification.

00:04:34.210 --> 00:04:37.720
The first protocol
involves the device token,

00:04:37.720 --> 00:04:41.200
the JSON payload,
and the command of zero.

00:04:41.200 --> 00:04:46.440
We also prefix the token
length and payload length.

00:04:46.440 --> 00:04:50.960
This makes up the entirety
of the first binary protocol.

00:04:52.160 --> 00:04:57.240
The second protocol that you can
use is composed of much of the same,

00:04:57.240 --> 00:05:02.080
except that we command as 1,
and we also insert.

00:05:03.960 --> 00:05:09.200
An identifier and a set expiry time.

00:05:09.240 --> 00:05:14.000
Using the set second protocol is how you
can set an expiry time for your message.

00:05:14.030 --> 00:05:17.720
Remember that again the
expiry affects the storage.

00:05:18.090 --> 00:05:24.010
If the device is online at the time,
notification will be sent

00:05:24.010 --> 00:05:24.010
regardless of any set expiry.

00:05:29.570 --> 00:05:34.500
All right,
so what makes up a message payload?

00:05:34.610 --> 00:05:40.500
Message payloads are
strict RFC 4627 JSON.

00:05:41.450 --> 00:05:45.040
An example is as depicted here.

00:05:45.190 --> 00:05:50.540
JSON is human readable,
it's relatively compact,

00:05:50.700 --> 00:05:53.710
and is easily mapped to an NSDictionary.

00:05:55.660 --> 00:05:58.540
When constructing your payloads, though,
it's important to remember that

00:05:58.910 --> 00:06:01.870
there is a 256-byte maximum.

00:06:06.590 --> 00:06:13.090
Also note that you can make use of keys
outside of the APS key for your own use.

00:06:19.960 --> 00:06:23.590
So some sizing considerations.

00:06:23.630 --> 00:06:27.380
If we have JSON as depicted here,
with new lines and spaces,

00:06:27.390 --> 00:06:30.920
much as you would type it
out to be human readable,

00:06:30.960 --> 00:06:35.130
this particular set of
JSON would be 150 bytes.

00:06:35.460 --> 00:06:38.430
However,
if we strip all that white space,

00:06:38.430 --> 00:06:42.400
we can get the same
notification down to 96 bytes.

00:06:42.400 --> 00:06:45.250
This is generally a good idea.

00:06:51.430 --> 00:06:54.600
All right, so we've spoken a little
bit about the server-side

00:06:54.720 --> 00:06:56.990
aspects of push notifications.

00:06:57.190 --> 00:07:01.080
We're now going to take a closer
look at the client side aspects,

00:07:01.080 --> 00:07:04.520
and for that, I'm going to invite up
onto stage my colleague,

00:07:04.760 --> 00:07:05.860
James Callender.

00:07:16.600 --> 00:07:18.090
My name is James Callender.

00:07:18.110 --> 00:07:19.900
I'm an iOS engineer.

00:07:19.930 --> 00:07:23.490
I want to talk to you today a
little bit about the push and

00:07:23.490 --> 00:07:27.410
local notification API for iOS.

00:07:29.570 --> 00:07:32.110
So I'm going to start
with push notifications,

00:07:32.190 --> 00:07:35.740
specifically how to register
to receive push notifications,

00:07:35.740 --> 00:07:39.520
how to construct a payload,
and how iOS acts on your behalf so your

00:07:39.520 --> 00:07:41.970
application doesn't have to be running.

00:07:45.130 --> 00:07:49.400
But first, why would you want to
use push notifications?

00:07:49.460 --> 00:07:53.180
Well, some examples would be
for social networking.

00:07:53.260 --> 00:07:57.320
Push is a great way to update your
friends about your current status

00:07:57.320 --> 00:07:59.970
or remind them of upcoming events.

00:08:01.300 --> 00:08:06.420
Second is for current events
like sports scores and news.

00:08:06.490 --> 00:08:09.150
Push is a great way of
sending information to users

00:08:09.610 --> 00:08:12.010
about events as they occur.

00:08:13.770 --> 00:08:16.750
Finally,
I've seen some great examples of push

00:08:16.750 --> 00:08:21.130
being used in games to alert players
when it's their turn to take a move.

00:08:21.250 --> 00:08:25.940
Now you notice this is sort of
the new banner style notification.

00:08:25.960 --> 00:08:31.350
I'll be presenting with both banner
and the old alert style notification.

00:08:33.960 --> 00:08:39.660
So when would you not want
to use push notifications?

00:08:39.660 --> 00:08:43.800
You don't want to use push to deliver any
kind of critical application information.

00:08:43.850 --> 00:08:45.800
What do I mean by that?

00:08:46.020 --> 00:08:51.200
Imagine that you're writing an app that
delivers some sort of content to a user,

00:08:51.200 --> 00:08:54.280
sort of like an email.

00:08:54.770 --> 00:08:57.890
You don't want to rely on push
to be your primary communication

00:08:57.890 --> 00:09:00.540
channel to your application.

00:09:00.540 --> 00:09:03.120
There's a number of reasons for this.

00:09:03.520 --> 00:09:06.180
Primarily, push may not be available.

00:09:06.300 --> 00:09:09.370
The user may be moving in
and out of service areas,

00:09:09.370 --> 00:09:13.320
or they could have disabled
push altogether for your app.

00:09:13.910 --> 00:09:17.690
They also may ignore the notification
and launch your app at some later point,

00:09:17.690 --> 00:09:20.770
and you'll never actually
receive the push payload.

00:09:21.700 --> 00:09:23.870
Because of this,
it's always a better idea to

00:09:24.070 --> 00:09:27.800
pull data from your server while
your application is running.

00:09:30.190 --> 00:09:34.120
So say that you have decided you want
to use push notifications in your app.

00:09:34.480 --> 00:09:36.470
How do you get started doing that?

00:09:36.630 --> 00:09:41.160
The first thing to do is to register
using the UI application API.

00:09:41.520 --> 00:09:45.120
A good time to do this is that the
application did finish launching

00:09:45.120 --> 00:09:47.280
with options delegate callback.

00:09:47.340 --> 00:09:49.540
You'll want to call the
register for remote notification

00:09:49.540 --> 00:09:53.130
types on the UI application
object and pass in the type of

00:09:53.130 --> 00:09:54.930
notifications you wish to receive.

00:09:55.080 --> 00:09:59.780
In this case, we're passing in sound
types and badge types.

00:10:02.050 --> 00:10:06.160
So once you've registered with
iOS to receive push notifications,

00:10:06.210 --> 00:10:10.580
one of two things will happen
depending on your app's current state.

00:10:10.760 --> 00:10:14.900
First -- oh, sorry.

00:10:15.190 --> 00:10:21.740
One of two things will happen when you
register depending on various things.

00:10:21.880 --> 00:10:26.500
So first, if you successfully register,
you'll get the delegate callback,

00:10:26.500 --> 00:10:31.000
application did register for remote
notifications with device token.

00:10:31.090 --> 00:10:34.260
You'll get an NSData object,
which you'll want to pass up to your

00:10:34.260 --> 00:10:40.930
server and associate that token with the
user's device and possibly an account.

00:10:41.710 --> 00:10:46.240
Alternatively, if you fail to register,
you'll get the application did

00:10:46.240 --> 00:10:49.300
fail to register for remote
notifications with error.

00:10:49.390 --> 00:10:51.000
At this point,
you might want to check your

00:10:51.000 --> 00:10:54.200
provisioning profile and make sure
you have the correct entitlements.

00:10:54.360 --> 00:10:57.700
Also note that push is not
supported in the simulator,

00:10:57.840 --> 00:11:01.100
but your application should be able to
handle this case gracefully in the event

00:11:01.100 --> 00:11:03.610
that you're testing in the simulator.

00:11:05.330 --> 00:11:10.540
So I want to talk just a little
bit about the device token.

00:11:10.540 --> 00:11:13.980
The device token is for uniquely
identifying a particular device.

00:11:14.320 --> 00:11:18.960
However, this is separate from the
UDID of that particular device.

00:11:19.040 --> 00:11:23.680
The main difference is that the
device token can actually change.

00:11:23.880 --> 00:11:26.240
Because of this,
it's always a good idea to call the

00:11:26.270 --> 00:11:29.180
registration API on every single launch.

00:11:29.260 --> 00:11:32.650
You don't want to depend on a
cached copy of the device token,

00:11:32.910 --> 00:11:36.970
either on the device or on the server.

00:11:39.410 --> 00:11:43.610
So now we're ready to begin
constructing our push notification.

00:11:43.790 --> 00:11:48.900
As Darryl said, a push notification is
composed of a JSON object,

00:11:49.140 --> 00:11:52.410
the heart of which is the APS dictionary.

00:11:52.600 --> 00:11:55.500
Here you'll be able to specify
the appearance of the notification

00:11:55.560 --> 00:11:58.400
by indicating an alert,
a badge, and a sound,

00:11:58.400 --> 00:12:02.600
as well as you'll be able to use the
rest of the payload for any kind of

00:12:02.830 --> 00:12:05.610
application-specific information.

00:12:10.020 --> 00:12:13.830
So the first style of
notification is a badge.

00:12:13.930 --> 00:12:17.540
To set a badge in your application,
you want to use the badge key

00:12:17.720 --> 00:12:21.220
and indicate a positive integer.

00:12:21.730 --> 00:12:25.830
Because badges are meant to reflect
the current state of your application,

00:12:25.840 --> 00:12:29.400
simply omitting the badge
key will clear the badge.

00:12:31.640 --> 00:12:35.000
The next one is the sound.

00:12:35.090 --> 00:12:37.700
To have a custom sound
for your notification,

00:12:37.820 --> 00:12:43.080
all you need to do is specify a name of
a sound file in your application bundle.

00:12:44.110 --> 00:12:46.660
Alternatively,
if you want to use the default

00:12:46.660 --> 00:12:50.640
sound for notifications,
you can use the string default.

00:12:50.660 --> 00:12:54.340
Note that vibration of the
device is handled automatically

00:12:54.410 --> 00:12:58.040
by the user's settings.

00:12:58.500 --> 00:13:03.040
Now, the simplest form of an
alert is just a basic string.

00:13:06.440 --> 00:13:10.850
However, you can customize an alert
using the dictionary form,

00:13:10.850 --> 00:13:17.680
which will let you use the
localizable.strings file to localize

00:13:17.680 --> 00:13:21.390
the alert into the user's set language.

00:13:21.740 --> 00:13:24.750
You want to use the--
for the low key arg,

00:13:24.750 --> 00:13:28.830
you want to use the key and the key value
pair in the localizable dot strings.

00:13:28.980 --> 00:13:34.300
And you can also specify a custom
localized action for the notification.

00:13:34.430 --> 00:13:38.090
Now,
this notification is the old style modal,

00:13:38.090 --> 00:13:42.000
which is still supported in
iOS 5 based on user settings.

00:13:42.180 --> 00:13:45.220
But if your notification
appears as a banner,

00:13:45.220 --> 00:13:50.330
the action button will appear when
you swipe while at the lock screen.

00:13:53.140 --> 00:13:58.420
So you've dispatched your
notification from your server,

00:13:58.420 --> 00:14:01.340
and you're ready to
receive it on the device.

00:14:01.410 --> 00:14:04.680
And one of two things will happen
depending on the state of your app.

00:14:05.180 --> 00:14:08.080
If your app's running,
you'll get the application did receive

00:14:08.150 --> 00:14:12.960
remote notification callback with the
user info dictionary that reflects

00:14:12.960 --> 00:14:15.220
the contents of the JSON object.

00:14:15.300 --> 00:14:18.100
However,
if your application is not running,

00:14:18.160 --> 00:14:22.340
but the user taps on the notification,
you'll get the application did finish

00:14:22.390 --> 00:14:26.960
launching with options delegate callback,
at which point you can extract

00:14:26.960 --> 00:14:30.500
the notification from the
launch options dictionary.

00:14:33.120 --> 00:14:35.300
So that's about it for
push notifications.

00:14:35.610 --> 00:14:38.620
The next thing I want to talk
about is local notifications.

00:14:38.690 --> 00:14:43.460
I want to talk about how they're similar,
how to construct a local notification,

00:14:43.530 --> 00:14:46.880
and again, how iOS acts on your behalf.

00:14:49.120 --> 00:14:54.600
So how are local notifications
and push notifications similar?

00:14:54.600 --> 00:14:57.600
Well, for one,
they appear the same to the user.

00:14:57.670 --> 00:15:00.720
They can have the same
combination of badges,

00:15:00.720 --> 00:15:02.340
alerts, and sounds.

00:15:04.150 --> 00:15:06.480
The other similarity
is that in both cases,

00:15:06.550 --> 00:15:09.520
iOS acts on your behalf,
so your application doesn't

00:15:09.520 --> 00:15:12.670
need to be running for the
user to get a notification.

00:15:15.110 --> 00:15:18.700
So how are they different?

00:15:18.760 --> 00:15:22.290
Well, push notifications
originate from a server.

00:15:22.480 --> 00:15:25.230
So the device needs to have
a network connection to

00:15:25.240 --> 00:15:27.600
actually get the notification.

00:15:27.640 --> 00:15:30.200
Local notifications
originate from the app.

00:15:30.270 --> 00:15:33.590
They're scheduled and dispatched
entirely on the device without

00:15:33.590 --> 00:15:35.580
the need for a network connection.

00:15:36.880 --> 00:15:40.160
Also, push notifications are single shot.

00:15:40.230 --> 00:15:42.960
You send them once with the server,
and if possible,

00:15:42.960 --> 00:15:46.590
will deliver that one notification
immediately to your device.

00:15:46.740 --> 00:15:50.120
On the other hand,
local notifications can be scheduled

00:15:50.120 --> 00:15:54.260
for some point in the future and
optionally marked as repeating.

00:15:54.450 --> 00:15:59.770
So, when would you want to
use local notifications?

00:16:01.160 --> 00:16:04.880
One example is an alarm clock for some
kind of alert that you want to have

00:16:04.880 --> 00:16:10.820
happen at the same time every day,
or a reminder for some kind of

00:16:10.820 --> 00:16:13.450
upcoming event like a vacation.

00:16:15.210 --> 00:16:18.680
Also, for users of our multitasking
and location-aware APIs,

00:16:18.680 --> 00:16:22.560
push notifications are a great
way of alerting the user about

00:16:22.670 --> 00:16:26.310
some kind of location-based event,
like a nearby friend,

00:16:26.590 --> 00:16:29.940
and give them the option of
bringing your app to the foreground.

00:16:32.190 --> 00:16:36.690
When don't you want to
use local notifications?

00:16:36.830 --> 00:16:41.250
For any kind of general alert and error
that you want to show to your users

00:16:41.360 --> 00:16:44.990
while your application is running,
it's better to use a more

00:16:44.990 --> 00:16:47.900
general use API like UILertView.

00:16:49.120 --> 00:16:53.760
Also, for calendar-based events,
consider using the Event Kit API.

00:16:53.840 --> 00:16:57.810
This will let you schedule an event
in the user's calendar and optionally

00:16:57.810 --> 00:17:01.090
attach some sort of alert to that event.

00:17:04.210 --> 00:17:06.820
So if you've decided to
use local notifications,

00:17:06.820 --> 00:17:09.560
you can begin constructing
the notification.

00:17:09.620 --> 00:17:13.880
To do that, we want to use the UI local
notification object.

00:17:14.600 --> 00:17:17.760
This includes properties
for setting a badge,

00:17:17.990 --> 00:17:21.280
an alert, and a sound.

00:17:22.070 --> 00:17:28.390
As well as those
properties for scheduling,

00:17:28.390 --> 00:17:28.390
optionally marking it as repeating,

00:17:28.830 --> 00:17:31.490
And again,
we have a user info dictionary to

00:17:31.530 --> 00:17:36.140
attach any kind of meta information
you want to use for your app.

00:17:36.220 --> 00:17:40.210
I'll start by talking about badges,
alerts, and sounds.

00:17:41.890 --> 00:17:45.280
To set a badge,
use the application icon badge number

00:17:45.280 --> 00:17:50.690
property on your UI local notification
object and set it to a positive integer.

00:17:51.880 --> 00:17:56.050
Note, however, that in this case,
setting this value to zero will

00:17:56.050 --> 00:17:57.540
not actually clear the badge.

00:17:57.850 --> 00:18:00.790
Instead,
you'll want to use the UI application

00:18:00.880 --> 00:18:05.620
property application icon badge number
while your application is running.

00:18:08.210 --> 00:18:10.880
The next is alerts.

00:18:10.890 --> 00:18:14.860
Again, the basic form of an
alert is just a string.

00:18:14.890 --> 00:18:18.560
You can use the alert body and
assign it to a basic NSString.

00:18:19.860 --> 00:18:22.960
Optionally,
you can set the alert action property

00:18:23.190 --> 00:18:29.540
and mark it as having a custom action by
setting the has action property to true.

00:18:29.720 --> 00:18:32.940
And again, you can localize your alerts.

00:18:33.550 --> 00:18:34.860
Use the same kind of mechanism.

00:18:34.860 --> 00:18:41.170
Use the key part of the key value
pair in the localizable.strings file.

00:18:45.960 --> 00:18:49.620
This will allow iOS to localize
your application at the time

00:18:49.620 --> 00:18:53.060
that the notification is
actually displayed to the user.

00:18:58.010 --> 00:19:03.930
So the other thing that you can do with
a local notification is actually set

00:19:03.930 --> 00:19:10.010
a custom launch image for your app.

00:19:10.050 --> 00:19:11.590
You might know that iOS lets you set
an image to be displayed to the user

00:19:11.590 --> 00:19:11.590
while your application is launching.

00:19:12.430 --> 00:19:19.970
So you can set the alert launch
image property to change this.

00:19:19.970 --> 00:19:19.970
So in this case,

00:19:20.190 --> 00:19:23.690
This app,
the default launch image is just a

00:19:23.690 --> 00:19:27.890
blank image that will eventually want to
populate with some kind of menu system.

00:19:28.030 --> 00:19:32.560
However,
by setting the alert launch image,

00:19:32.640 --> 00:19:35.770
when the user taps the action button,

00:19:36.110 --> 00:19:41.650
It'll display a custom image that might
better reflect the location in your app

00:19:42.030 --> 00:19:43.600
that the notification is bringing you.

00:19:43.650 --> 00:19:45.980
In this case,
we're saying that we're ready

00:19:45.980 --> 00:19:49.130
to watch a baseball game,
and the launch image

00:19:49.280 --> 00:19:51.740
is a baseball triangle.

00:19:53.730 --> 00:19:58.780
So the last property you can
set for the appearance of the

00:19:58.780 --> 00:20:02.140
notification is the sound.

00:20:02.350 --> 00:20:05.310
To set this,
you use the sound name property.

00:20:06.550 --> 00:20:09.900
Again, just as with push,
you can use the default sound name by

00:20:09.900 --> 00:20:15.710
setting the sound name property to the
UI local notification default sound name.

00:20:18.520 --> 00:20:21.310
So now that we've covered
how to customize the look and

00:20:21.440 --> 00:20:25.290
feel of your notification,
we'll talk about how to schedule

00:20:25.290 --> 00:20:27.290
it and mark it as repeating.

00:20:28.780 --> 00:20:31.700
But first, I want to talk about
different kinds of dates.

00:20:31.700 --> 00:20:34.170
Specifically,
I want to talk about this notion

00:20:34.170 --> 00:20:37.080
of universal time versus wall time.

00:20:38.400 --> 00:20:42.930
Universal time is the idea that
events occur at the same instant no

00:20:42.930 --> 00:20:44.940
matter where you are in the world.

00:20:45.080 --> 00:20:48.060
This is essentially just
a single NSDate object.

00:20:48.190 --> 00:20:51.280
This is good for things like a
conference call where some of the

00:20:51.310 --> 00:20:55.030
participants are in different time zones,
or the time at which

00:20:55.100 --> 00:20:56.920
a stock market closes.

00:20:59.160 --> 00:21:02.720
The other kind of time is wall time.

00:21:02.740 --> 00:21:07.370
This is basically time that occurs at
different relative points depending

00:21:07.950 --> 00:21:10.160
on where you are in the world.

00:21:10.280 --> 00:21:14.400
So essentially you're combining an
NSDate object with an NSTimeZone object.

00:21:14.510 --> 00:21:18.490
Examples of this is an alarm
clock that goes off at 9:00 a.m.

00:21:18.610 --> 00:21:23.190
or the time at which a network
broadcasts a television show.

00:21:24.910 --> 00:21:28.890
So once you've decided that your
notification is more of a universal

00:21:28.890 --> 00:21:33.630
time or wall time notification,
you're ready to actually schedule it.

00:21:33.790 --> 00:21:37.420
To do this, use the fire date and
time zone properties.

00:21:37.460 --> 00:21:43.170
Note here that we've specified a number
of seconds relative to the current time.

00:21:43.690 --> 00:21:48.380
This might be okay if what we want
is some sort of countdown timer.

00:21:48.380 --> 00:21:51.840
But if our intention was to
display the notification,

00:21:51.920 --> 00:21:56.790
say,
at the same hour as this time tomorrow,

00:21:56.920 --> 00:22:01.510
that might not work if tomorrow,
for instance, is the beginning or end

00:22:01.540 --> 00:22:03.520
of daylight savings time.

00:22:03.600 --> 00:22:07.570
Your notification will be delivered
either an hour early or an hour late.

00:22:07.710 --> 00:22:11.410
To get around this,
we can use the NSDateComponents

00:22:11.410 --> 00:22:15.640
object and set a custom day,
month, year, and hour,

00:22:15.640 --> 00:22:21.100
and have it do the work of calculating
the appropriate NSDate object.

00:22:23.300 --> 00:22:27.080
So the last thing you can do is
schedule a notification as repeating

00:22:27.080 --> 00:22:29.860
at some sort of regular interval.

00:22:29.980 --> 00:22:34.390
To do this, use the repeat interval and
repeat calendar properties.

00:22:35.630 --> 00:22:38.800
In this example,
we're using the NSDay calendar

00:22:39.260 --> 00:22:41.460
unit to have it repeat once a day.

00:22:41.680 --> 00:22:45.730
Alternatively, we could use another unit,
like NSWeek calendar unit,

00:22:45.870 --> 00:22:48.330
and have it repeat once a week.

00:22:48.540 --> 00:22:53.740
Note that I'm keeping the repeat calendar
at whatever default calendar is set,

00:22:53.900 --> 00:22:57.040
but you want to make note of this,
because not all users actually

00:22:57.040 --> 00:23:00.200
use the Gregorian calendar,
and your repeat interval might be

00:23:00.200 --> 00:23:03.200
different depending on the type
of calendar that's currently set.

00:23:03.290 --> 00:23:04.970
So you just want to take care
and make sure that you're

00:23:05.040 --> 00:23:05.940
taking that into consideration.

00:23:09.990 --> 00:23:14.400
So the last part of a local notification
is the user info dictionary.

00:23:14.470 --> 00:23:17.900
This is a great place to put
any kind of meta information

00:23:18.290 --> 00:23:21.940
for your local notification,
like maybe an identifier

00:23:21.940 --> 00:23:26.020
for that notification,
or instructions to your app on where

00:23:26.020 --> 00:23:29.350
to bring you once you've been launched.

00:23:31.130 --> 00:23:33.960
So now that you've
constructed your notification,

00:23:33.960 --> 00:23:36.240
you're ready to schedule it with iOS.

00:23:37.160 --> 00:23:39.850
To do this, we have a couple of methods.

00:23:39.910 --> 00:23:42.750
You'll want to use the
UI application methods,

00:23:42.780 --> 00:23:46.360
schedule local notification,
to schedule a notification

00:23:46.360 --> 00:23:47.700
you just created.

00:23:47.730 --> 00:23:51.290
Or if you want to cancel a notification
that you've already scheduled,

00:23:51.360 --> 00:23:54.050
you can use the cancel
local notification method.

00:23:55.360 --> 00:23:58.880
Also, for background apps,
we have the present

00:23:58.920 --> 00:24:03.250
local notification now,
which ignores the fire date property

00:24:03.250 --> 00:24:07.030
and displays the notification
immediately to the user and gives

00:24:07.030 --> 00:24:11.000
them the option of bringing your
application to the foreground.

00:24:13.680 --> 00:24:17.250
So again,
the notification has been dispatched,

00:24:17.250 --> 00:24:19.420
and we're ready to receive it.

00:24:20.750 --> 00:24:23.350
Just as with push,
if your application is running,

00:24:23.360 --> 00:24:26.640
you'll get the application did
receive local notification.

00:24:26.680 --> 00:24:29.700
The important thing to
remember is that in this case,

00:24:29.730 --> 00:24:32.890
iOS will not actually
perform any of the badging,

00:24:32.890 --> 00:24:34.380
sounds, or alerts.

00:24:34.430 --> 00:24:40.600
You'll want to take the appropriate
action that's specific for your

00:24:40.600 --> 00:24:40.600
app once you get the notification.

00:24:41.140 --> 00:24:45.490
And if your application is not running,
you'll get the application did finish

00:24:45.510 --> 00:24:48.400
launching with options callback.

00:24:48.400 --> 00:24:50.390
And again,
you can extract the notification

00:24:50.770 --> 00:24:53.280
from the launch options dictionary.

00:24:54.350 --> 00:25:00.080
That's actually all there is to
push and local notifications on iOS.

00:25:00.100 --> 00:25:04.480
Next, I'd like to call up my colleague,
Jason, to talk about push

00:25:04.480 --> 00:25:06.770
notifications on Mac OS X.

00:25:14.500 --> 00:25:16.740
All right, good afternoon, everybody.

00:25:16.740 --> 00:25:17.500
My name is Jason Thorpe.

00:25:17.500 --> 00:25:20.200
I'm an engineering manager for Mac OS X.

00:25:20.210 --> 00:25:24.090
And I'm going to tell you all about
how to implement push notifications

00:25:24.090 --> 00:25:26.140
for your applications on the Mac.

00:25:27.090 --> 00:25:31.490
So the first thing to be aware of is the
push notification support we've added

00:25:31.490 --> 00:25:37.630
to the Mac and Lion is very similar to
the push notification support you're

00:25:37.740 --> 00:25:40.110
probably all familiar with in iOS.

00:25:40.150 --> 00:25:47.770
So the AppKit API is as identical
to the UIKit API as is possible.

00:25:48.150 --> 00:25:52.390
And the notifications are delivered
to applications that are running via

00:25:52.390 --> 00:25:55.130
the NSApplicationDelegate object.

00:25:56.050 --> 00:25:58.720
And then finally,
if your application is not running,

00:25:58.720 --> 00:26:02.810
your icons will be badged in
the dock and in Launchpad.

00:26:03.640 --> 00:26:06.140
But there are a few differences.

00:26:06.340 --> 00:26:09.740
So first of all,
the Mac only supports badges,

00:26:09.740 --> 00:26:12.170
not alerts or sounds.

00:26:12.320 --> 00:26:17.090
And because of that, there's no alerts,
your application can't be launched

00:26:17.090 --> 00:26:19.780
in response to a push notification.

00:26:21.260 --> 00:26:25.330
Since we are only supporting badges,
which are potentially a lot

00:26:25.330 --> 00:26:28.540
less annoying than having your
phone beep at you and whatnot,

00:26:28.560 --> 00:26:33.350
there's no system-wide preferences
for push notifications on the Mac.

00:26:34.220 --> 00:26:38.480
And we don't have the iOS
style local notifications API.

00:26:38.480 --> 00:26:42.290
Local notifications on the
Mac are done with a different API.

00:26:43.910 --> 00:26:47.510
So there is some server-side impact.

00:26:47.510 --> 00:26:53.730
So because your application -- so
if you have an application for which

00:26:53.790 --> 00:26:57.530
you have an iOS and a Mac version,
they're going to have different

00:26:57.980 --> 00:27:00.430
application identifiers,
different bundle IDs.

00:27:00.680 --> 00:27:04.620
And because of this,
you're going to have two different

00:27:04.620 --> 00:27:06.390
push provider certificates.

00:27:06.400 --> 00:27:09.570
So when you register your
device token with your server,

00:27:09.570 --> 00:27:13.810
you're going to need to identify what
kind of client you're coming from.

00:27:13.820 --> 00:27:16.570
And the best or the easiest way to
do this is probably just to send

00:27:16.570 --> 00:27:19.850
either your application identifier
or your bundle identifier up to the

00:27:19.850 --> 00:27:22.190
server when you register your token.

00:27:23.310 --> 00:27:25.100
But that's really about it.

00:27:25.230 --> 00:27:31.960
Even though we don't support the
alert and sound notification types,

00:27:31.960 --> 00:27:34.950
you can construct your payload
once and send it to all the

00:27:34.950 --> 00:27:38.170
devices that are registered,
and the Mac will simply

00:27:38.170 --> 00:27:40.150
ignore the alert and sound.

00:27:42.230 --> 00:27:46.740
So some developer considerations
that are new to the Mac.

00:27:46.740 --> 00:27:53.200
So the push notifications require your
application to be correctly entitled.

00:27:53.280 --> 00:27:56.550
And to do that, you're going to need a
provisioning profile from the

00:27:56.560 --> 00:27:58.630
Apple Developer Certificate Utility.

00:27:58.740 --> 00:28:02.010
If you're already developing
applications for iOS,

00:28:02.150 --> 00:28:04.300
this should be familiar to you.

00:28:04.910 --> 00:28:09.120
And that provisioning profile will
need to be associated with your

00:28:09.120 --> 00:28:13.140
Xcode project and then installed on
any Macs that are going to run the

00:28:13.140 --> 00:28:15.740
development version of the application.

00:28:15.820 --> 00:28:19.070
And then next,
only applications that are distributed

00:28:19.070 --> 00:28:24.310
through the Mac App Store can use
the Apple Push Notification service.

00:28:27.000 --> 00:28:30.340
Okay, so let's get into the API details.

00:28:30.500 --> 00:28:35.990
So as on iOS, the best time to register
your token is when you get the

00:28:35.990 --> 00:28:42.340
application did finish launching
NS application delegate callback.

00:28:42.340 --> 00:28:46.900
You'll call the register for
remote notification types method

00:28:46.900 --> 00:28:52.300
in NS application and then
register in this case for badges.

00:28:54.710 --> 00:28:59.210
So when you register for notification,
just like on iOS, you'll get one of two

00:28:59.210 --> 00:28:59.990
different callbacks.

00:29:00.060 --> 00:29:04.290
The first one would be,
did register for remote

00:29:04.290 --> 00:29:07.100
notifications with device token?

00:29:07.150 --> 00:29:11.030
And this is when you'll send your
device token to the APNS -- sorry,

00:29:11.030 --> 00:29:12.200
to your server.

00:29:12.340 --> 00:29:17.060
And again,
make sure to distinguish between the iOS

00:29:17.060 --> 00:29:17.060
and the Mac version of your application.

00:29:17.710 --> 00:29:21.880
And then when you fail to register,
you would get, did fail to register for

00:29:21.880 --> 00:29:23.370
notifications with error.

00:29:23.550 --> 00:29:26.450
And in this case,
you'll want to check your

00:29:26.450 --> 00:29:29.820
provisioning profile to ensure
your app is correctly entitled.

00:29:32.350 --> 00:29:35.540
So getting the payload is
pretty straightforward.

00:29:35.540 --> 00:29:39.180
You'll get the did receive
remote notification callback

00:29:39.240 --> 00:29:40.890
on your application delegate.

00:29:40.960 --> 00:29:46.110
And again, I just want to point out that
you may get alert and sound

00:29:46.110 --> 00:29:50.870
keys within the APS dictionary,
but probably the best practice is for

00:29:50.870 --> 00:29:55.210
your application to simply ignore those,
since Doc won't display

00:29:55.210 --> 00:29:56.400
them on your behalf.

00:29:56.450 --> 00:29:56.840
And that's it.

00:29:56.920 --> 00:30:00.200
That's really the only differences
for push notifications for

00:30:00.250 --> 00:30:01.650
the Mac as compared to iOS.

00:30:01.750 --> 00:30:04.690
And to show you how this all works,
I'd like to invite Darrin Jewell

00:30:04.690 --> 00:30:07.550
up here to give you a quick demo.

00:30:07.550 --> 00:30:07.560
Darrin?

00:30:12.610 --> 00:30:13.360
Hi there.

00:30:13.510 --> 00:30:16.840
My name is Darrin,
and I'm going to bring you through

00:30:16.840 --> 00:30:21.400
an Xcode demo of how to add push
notifications to an application.

00:30:21.600 --> 00:30:24.400
So let me switch over to our

00:30:25.550 --> 00:30:26.500
Demo.

00:30:26.790 --> 00:30:29.740
Okay, so I'd like to introduce Cumulus.

00:30:29.740 --> 00:30:32.630
Cumulus is a simple file sharing
application for those of you

00:30:32.630 --> 00:30:34.420
who can't use AirDrop yet.

00:30:34.420 --> 00:30:35.430
And Cumulus is great.

00:30:35.430 --> 00:30:38.540
Your friends can send you files,
and you can see and browse the

00:30:38.640 --> 00:30:43.800
files that your friends have
sent you and share them that way.

00:30:43.870 --> 00:30:46.290
Unfortunately,
it has one significant problem,

00:30:46.290 --> 00:30:48.940
and that's that you have to
hit the refresh button to see

00:30:48.940 --> 00:30:50.310
what files are waiting for you.

00:30:50.330 --> 00:30:52.420
So you're sitting here pushing
the refresh button all day.

00:30:52.420 --> 00:30:55.200
We're going to show you
how you can add push,

00:30:55.200 --> 00:30:57.680
which we recently added to the Mac,
to this application.

00:30:57.790 --> 00:30:59.110
It's pretty easy.

00:30:59.110 --> 00:31:01.590
And we'll walk you through the code.

00:31:01.740 --> 00:31:05.260
We'll show you some pitfalls
you might find along the way.

00:31:05.320 --> 00:31:06.760
And we'll bring that up in Xcode.

00:31:06.760 --> 00:31:10.160
So let me clear out the file here.

00:31:10.350 --> 00:31:12.730
We'll exit our little program.

00:31:12.780 --> 00:31:16.890
And we'll bring up the application
delegate class in Xcode.

00:31:18.020 --> 00:31:21.320
So this is the NSApplicationDelegate
class for Cumulus,

00:31:21.320 --> 00:31:26.280
and we're going to show you you
need to add one new function

00:31:26.280 --> 00:31:32.490
call to your application,
and we're going to implement three

00:31:32.490 --> 00:31:32.490
methods that Jason just covered
that you need to handle push events

00:31:32.490 --> 00:31:32.490
as they arrive in your application.

00:31:32.970 --> 00:31:36.290
So the first one we're going to show
you is the application did finish

00:31:36.320 --> 00:31:37.830
launching method in your delegate.

00:31:38.000 --> 00:31:39.490
Your delegate probably already has this.

00:31:39.500 --> 00:31:44.150
In this case, we just create and open the
first window on the screen.

00:31:44.360 --> 00:31:47.530
So the call that we're going
to add to this delegate is the

00:31:47.540 --> 00:31:50.880
NSApplicationRegisterForRemoteNot
ificationTypes call.

00:31:50.890 --> 00:31:53.980
And we're going to give it the
NSRemoteNotificationTypeBadge constant

00:31:54.220 --> 00:31:57.840
to indicate that when we're not running,
we would like to be badged in the dock.

00:31:57.920 --> 00:32:01.840
So we'll just uncomment the call
that I've already put in here now.

00:32:01.840 --> 00:32:03.290
OK.

00:32:03.860 --> 00:32:06.310
So the next function, okay,
now we're going to cover the three

00:32:06.610 --> 00:32:10.480
methods that you'll want to implement
new to your application to handle

00:32:10.550 --> 00:32:12.960
push events in your application.

00:32:13.030 --> 00:32:16.540
First one,
application did register for remote

00:32:16.610 --> 00:32:19.400
notifications with device token.

00:32:19.450 --> 00:32:21.970
This method will be called
when your application

00:32:21.970 --> 00:32:23.950
successfully registers for push.

00:32:24.410 --> 00:32:28.140
You'll be handed an NSData object
with a device token.

00:32:28.290 --> 00:32:30.340
That device token represents
the unique instance of your

00:32:30.340 --> 00:32:33.400
application running on this Mac.

00:32:33.530 --> 00:32:36.940
You'll want to send that to your server,
in this case the Cumulus server.

00:32:36.940 --> 00:32:39.830
We send it up there with the
MyWindowControllerSendProvider

00:32:39.830 --> 00:32:40.640
device token.

00:32:40.640 --> 00:32:42.700
We'll let the window controller
handle sending it upstream

00:32:42.700 --> 00:32:44.330
to the Cumulus server.

00:32:44.460 --> 00:32:47.590
And we also log it here so
we can see what's going on.

00:32:49.370 --> 00:32:57.490
Okay, so now that's when your application
successfully registered for push,

00:32:57.490 --> 00:32:57.490
but when your application does not
successfully register for push,

00:32:57.730 --> 00:33:00.910
The application will call the
application did fail to register for

00:33:00.960 --> 00:33:03.610
remote notifications with error call.

00:33:03.750 --> 00:33:06.130
This indicates something went
wrong registering for push.

00:33:06.380 --> 00:33:08.900
Most likely, if you're under development
and you get this call,

00:33:08.900 --> 00:33:11.800
you want to check that your
application is properly entitled,

00:33:11.800 --> 00:33:14.400
because if you're not entitled,
this will be called with an error.

00:33:14.480 --> 00:33:16.000
And we'll show you how to
add entitlements to your

00:33:16.000 --> 00:33:19.020
application in a minute,
and what happens when they don't.

00:33:20.250 --> 00:33:25.960
And finally, in order to actually
handle incoming pushes,

00:33:25.960 --> 00:33:29.880
you'll want to implement application
did receive remote notification,

00:33:29.880 --> 00:33:32.760
and you'll be handed a dictionary,
an NSDictionary,

00:33:32.800 --> 00:33:38.050
which corresponds to the JSON payload
that was sent by your server

00:33:38.050 --> 00:33:38.050
through the Apple Push service.

00:33:39.390 --> 00:33:41.070
We log it here so you can see it.

00:33:41.340 --> 00:33:43.270
And in this case,
we just take the same action as

00:33:43.270 --> 00:33:46.780
if the user had hit the refresh
button every time we get a push.

00:33:48.110 --> 00:33:53.100
So let me show you now what happens
when you actually run the app.

00:33:53.130 --> 00:34:00.330
So now we'll compile,
launch our application here.

00:34:00.370 --> 00:34:05.250
We'll bring up the window full screen.

00:34:07.890 --> 00:34:10.280
So now you'll see that
because we weren't entitled,

00:34:10.410 --> 00:34:14.210
we didn't compile with a
provisioning profile yet,

00:34:14.210 --> 00:34:20.280
the application did fail to register for
remote notifications with error method.

00:34:20.310 --> 00:34:22.910
It's a mouthful,
but it gets called indicating that

00:34:22.940 --> 00:34:24.800
your application was not entitled.

00:34:24.970 --> 00:34:28.100
So we need to take the
provisioning profile here,

00:34:28.120 --> 00:34:31.800
which you downloaded from the
Mac Developer Certificate Utility,

00:34:31.810 --> 00:34:34.800
as Jason discussed,
and we'll add that into Xcode so that

00:34:34.800 --> 00:34:38.160
when you compile your application,
it's bundled in to your application

00:34:38.250 --> 00:34:41.210
for submission to the Mac App Store,
and your application is

00:34:41.210 --> 00:34:45.040
signed with the entitlements
contained inside this profile.

00:34:45.690 --> 00:34:48.790
In order to do that,
you open the Organizer panel in Xcode.

00:34:49.050 --> 00:34:50.990
Those of you who have worked
with iOS have probably gone

00:34:50.990 --> 00:34:52.180
through this process before.

00:34:52.340 --> 00:34:54.740
It's new to Mac developers.

00:34:54.780 --> 00:34:57.880
But we go to the Organizer
panel under Devices,

00:34:58.040 --> 00:34:59.860
Provisioning Profiles.

00:35:00.050 --> 00:35:02.390
You can either import it
with this import button here,

00:35:02.390 --> 00:35:06.300
or what we're going to do right
now is drag it into Xcode.

00:35:06.390 --> 00:35:11.440
So that's how you add the provisioning
profile for this application into Xcode.

00:35:11.470 --> 00:35:13.370
We'll close that window.

00:35:14.030 --> 00:35:16.140
So now we can recompile.

00:35:16.180 --> 00:35:18.140
First we'll stop the
one that's running here,

00:35:18.170 --> 00:35:19.400
so we're done with that one.

00:35:19.490 --> 00:35:22.280
And we'll recompile and
run the application again.

00:35:22.590 --> 00:35:25.140
This time the application's entitled.

00:35:25.220 --> 00:35:26.580
Now you'll notice that
when we try to run it,

00:35:26.660 --> 00:35:28.750
it drops immediately into the debugger.

00:35:28.990 --> 00:35:31.620
Now that your application is entitled,
it needs permission to run

00:35:31.620 --> 00:35:33.130
on this specific system.

00:35:33.240 --> 00:35:35.730
In order to do that,
any system that wants to run your

00:35:35.740 --> 00:35:38.850
development application has to have
the provisioning profile installed,

00:35:38.850 --> 00:35:41.960
or else it will be refused
to be allowed to run.

00:35:42.110 --> 00:35:45.460
So once you submit your app
to the Mac App Store and

00:35:45.470 --> 00:35:48.110
your users download the app,
they won't need to deal with the

00:35:48.200 --> 00:35:49.240
provisioning profile anymore.

00:35:49.240 --> 00:35:51.460
It'll just run because the
Mac App Store has signed it.

00:35:51.590 --> 00:35:53.800
But if you want your testers,
your fellow developers to be

00:35:53.800 --> 00:35:56.150
able to run the application,
they need to have a provisioning

00:35:56.230 --> 00:35:59.020
profile installed in their system,
and that provisioning profile has

00:35:59.090 --> 00:36:01.660
to match the hardware UUID of the
machine they're trying to run it on.

00:36:01.680 --> 00:36:03.880
So when you go to the
developer certificate utility,

00:36:03.880 --> 00:36:07.720
you'll have to specify what machines you
wish to run it on to get your profile.

00:36:08.790 --> 00:36:10.680
So we'll show you how to
add that to your system.

00:36:10.700 --> 00:36:13.360
So now if you double
click on the profile,

00:36:13.480 --> 00:36:16.440
which we have here on the desktop
in the upper right hand corner,

00:36:16.690 --> 00:36:18.630
It'll bring up your
system preferences window.

00:36:18.630 --> 00:36:21.200
We have a new profiles pane.

00:36:21.290 --> 00:36:23.600
And ask if you want to
install this profile.

00:36:23.600 --> 00:36:27.100
It shows you that the signature
of the profile is verified,

00:36:27.150 --> 00:36:29.000
and asks you if you're ready to install.

00:36:29.090 --> 00:36:30.580
So we'll say yes,
we'd like to install our

00:36:30.580 --> 00:36:32.000
provisioning profile.

00:36:32.060 --> 00:36:35.860
Since it's being installed system-wide,
it's asking us for your password.

00:36:37.310 --> 00:36:39.300
Okay,
now the provisioning profile for our

00:36:39.300 --> 00:36:41.700
Cumulus application is installed.

00:36:41.710 --> 00:36:44.360
You should be able to run on this Mac.

00:36:45.920 --> 00:36:47.400
Close that.

00:36:47.400 --> 00:36:49.200
We've already stopped the program.

00:36:49.200 --> 00:36:51.460
So now we'll relaunch.

00:36:52.720 --> 00:36:56.240
Okay, now you'll notice the program
successfully launched,

00:36:56.240 --> 00:36:58.980
and we got the application did
register for remote notifications

00:36:58.980 --> 00:37:00.090
with device token call.

00:37:00.260 --> 00:37:04.030
So this indicates that the application
successfully registered for push.

00:37:04.120 --> 00:37:05.970
It gave us the device token,
which we have to send

00:37:06.060 --> 00:37:08.400
to our cumulus server,
which contains the files

00:37:08.400 --> 00:37:09.700
we want to download.

00:37:09.820 --> 00:37:10.970
And so we've done that.

00:37:11.120 --> 00:37:14.700
And now when your friends send you files,
they show immediately

00:37:14.700 --> 00:37:15.860
in your application.

00:37:15.860 --> 00:37:18.810
You no longer have to
hit the refresh button.

00:37:19.790 --> 00:37:23.710
So you'll notice here that
the application did receive

00:37:23.710 --> 00:37:26.200
remote notification was called.

00:37:26.200 --> 00:37:27.700
And we got the payload here.

00:37:27.730 --> 00:37:31.620
Is it MS dictionary which we logged,
showing that the server has

00:37:31.640 --> 00:37:33.360
one file waiting for us.

00:37:33.400 --> 00:37:37.660
We also refreshed our contents of the
server so we could see the file in

00:37:37.660 --> 00:37:41.890
the file browser here that we have
ready waiting for us to download.

00:37:42.090 --> 00:37:46.960
So finally,
final feature of push on the Mac,

00:37:46.970 --> 00:37:49.160
we'll clear this out and exit it.

00:37:49.170 --> 00:37:52.290
When you quit your program,
and even when your

00:37:52.290 --> 00:37:55.820
program is not running,
notice it's no longer running,

00:37:55.850 --> 00:37:58.350
when your friend sends you files,

00:37:59.400 --> 00:38:02.290
You get a badge icon in the dock
indicating that you have files waiting

00:38:02.290 --> 00:38:05.010
for you on the server even though
the application is not running.

00:38:05.310 --> 00:38:07.300
The dock will badge on your behalf.

00:38:07.300 --> 00:38:09.160
Your users will know that they
need to launch the application.

00:38:09.440 --> 00:38:12.300
They can browse and see the
files that are waiting for them.

00:38:12.300 --> 00:38:17.300
So hopefully you'll find that adding push
notifications on the Mac is pretty easy.

00:38:17.300 --> 00:38:20.770
It's the same as iOS,
and we're looking forward to

00:38:20.880 --> 00:38:23.300
seeing what you will do with
push notifications on the Mac.

00:38:23.300 --> 00:38:27.340
So with that, I'll hand the presentation
back to Darryl,

00:38:27.350 --> 00:38:31.280
who will talk about some best practices
in implementing your push system.

00:38:31.300 --> 00:38:33.150
Thank you.

00:38:40.380 --> 00:38:41.930
All right,
let's talk about some of the best

00:38:41.980 --> 00:38:48.730
practices for using notifications.

00:38:48.790 --> 00:38:56.290
One thing to remember is that your
app should pull data from your

00:38:56.290 --> 00:38:56.290
server when your app is running.

00:38:57.060 --> 00:39:01.300
The reason for this is that the
push service may be turned off,

00:39:01.300 --> 00:39:06.400
as the user may have disabled
notification for your app or globally.

00:39:06.400 --> 00:39:09.360
However,
your app should continue to be fully

00:39:09.360 --> 00:39:12.800
functional even without the push service.

00:39:15.950 --> 00:39:20.970
Also remember to upload the
device token to your server often.

00:39:21.020 --> 00:39:25.540
You want to make sure that the token
that your server has matches the token of

00:39:25.540 --> 00:39:28.630
every particular user for their device.

00:39:31.690 --> 00:39:36.560
Finally,
don't annoy your users with alerts.

00:39:36.780 --> 00:39:41.710
You want to make sure that you're sending
notifications that your users care about.

00:39:42.500 --> 00:39:45.900
And if your application
doesn't need to send an alert,

00:39:45.920 --> 00:39:47.710
don't send them.

00:39:53.060 --> 00:39:54.000
Right on cue.

00:39:54.000 --> 00:39:59.910
All right,
let's talk a little bit about badges.

00:40:02.780 --> 00:40:08.040
Badges are the primary notification type.

00:40:08.040 --> 00:40:13.920
A badge represents some information
that the user can take action on.

00:40:13.920 --> 00:40:17.700
So you're sending a badge because
you want the user to click on

00:40:17.700 --> 00:40:20.100
the application and do something.

00:40:25.540 --> 00:40:30.000
So remember to keep a server-side count,
and this is what the

00:40:30.000 --> 00:40:31.980
badge should reflect.

00:40:31.980 --> 00:40:36.210
You'll want to test the logic that
you use for the server-side count.

00:40:36.560 --> 00:40:41.740
Remember that the count can
change while your app is inactive.

00:40:41.740 --> 00:40:44.900
Notifications can arrive
while your app is active.

00:40:44.970 --> 00:40:47.940
And in every scenario,
you want to ensure that the

00:40:47.940 --> 00:40:52.300
badge count that you're sending
represents accurate information.

00:40:58.260 --> 00:41:06.860
For more information on push in all
of the various frameworks and APIs,

00:41:07.010 --> 00:41:12.490
there are several options.

00:41:12.490 --> 00:41:12.490
We can go to our evangelist, Bill Dudney.

00:41:12.840 --> 00:41:16.400
You can definitely visit
the Apple Developer Forums.

00:41:16.400 --> 00:41:21.540
And for a sample application
representing notifications on the Mac,

00:41:21.540 --> 00:41:25.930
there is a sample app at the URL listed.

00:41:26.060 --> 00:41:29.260
I'm going to leave this up for a second,
if any of you want to

00:41:29.260 --> 00:41:30.790
write down these URLs.

00:41:30.880 --> 00:41:32.800
All right, that concludes our session.

00:41:32.850 --> 00:41:34.840
Thank you all for coming.
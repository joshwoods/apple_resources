WEBVTT

00:00:18.200 --> 00:00:19.330
Good afternoon.

00:00:19.430 --> 00:00:23.300
Welcome to the Developer Tools Kickoff.

00:00:23.390 --> 00:00:26.050
As you all know,
our iOS and Mac platforms

00:00:26.130 --> 00:00:27.990
are growing like crazy.

00:00:28.220 --> 00:00:31.560
Apple has now sold hundreds
of millions of iPhones,

00:00:31.560 --> 00:00:36.020
iPads, and Macs,
which all have access to the app stores.

00:00:36.090 --> 00:00:39.890
There's a lot of users out
there ready to buy your apps.

00:00:40.250 --> 00:00:44.370
And so our app stores continue to
grow beyond anybody's expectations.

00:00:44.430 --> 00:00:47.090
As you heard this morning,
users around the world have

00:00:47.160 --> 00:00:51.140
now downloaded more than
14 billion applications.

00:00:51.180 --> 00:00:53.890
And all of them are built
with one set of tools,

00:00:53.890 --> 00:00:55.750
and that's Xcode.

00:00:56.270 --> 00:00:58.600
Just a few months ago,
we shipped our most ambitious

00:00:58.690 --> 00:01:01.700
tools release to date,
Xcode 4.

00:01:01.900 --> 00:01:06.580
Xcode 4 has a user interface that
was redesigned from the ground up.

00:01:06.590 --> 00:01:09.700
Most of you are probably
familiar with it by now.

00:01:10.400 --> 00:01:15.090
The new Xcode is built around
a single window workflow.

00:01:15.130 --> 00:01:18.410
You can see several of its
highlights here on the screen.

00:01:18.660 --> 00:01:22.200
The integrated interface
builder right into the IDE.

00:01:22.260 --> 00:01:25.180
And our assistant editor split
the window to automatically

00:01:25.180 --> 00:01:29.100
bring up relevant related content
next to the file you're editing,

00:01:29.150 --> 00:01:30.710
so you can work on them side by side.

00:01:30.900 --> 00:01:33.950
For example,
when you're drawing a connection right

00:01:33.950 --> 00:01:36.090
from your GUI to your source code.

00:01:37.140 --> 00:01:39.970
Similarly,
the version editor allows you to

00:01:39.970 --> 00:01:43.620
browse the revision history of your
subversion and Git repositories,

00:01:43.620 --> 00:01:46.900
and view the changes you made
in the side-by-side div view.

00:01:46.920 --> 00:01:49.620
You can even use the timeline
in the middle to simply browse

00:01:49.620 --> 00:01:51.750
back in time on your project.

00:01:53.420 --> 00:01:56.980
The new user interface is the
most visible aspect of Xcode 4,

00:01:56.980 --> 00:02:01.490
but we also delivered major new
versions of our low-level tool chain,

00:02:01.540 --> 00:02:05.390
with the compiler, debugger,
and the performance tools.

00:02:05.960 --> 00:02:10.660
Version 2 of our LLVM compiler
added full support for C++.

00:02:10.710 --> 00:02:14.520
And in general, we integrated LLVM much
more tightly into the IDE,

00:02:14.660 --> 00:02:18.220
so that LLVM technology is now
the basis for many features,

00:02:18.270 --> 00:02:22.150
like automatically improved code
completion and syntax coloring.

00:02:23.300 --> 00:02:25.910
Integrating LLVM into the
IDE also allowed us to

00:02:25.910 --> 00:02:29.970
implement features like Fixit,
which uses LLVM to check for and

00:02:29.970 --> 00:02:34.710
automatically correct coding errors right
while you type in the source editor.

00:02:35.770 --> 00:02:39.380
And these are just eight of the
many features you find in Xcode 4.

00:02:39.440 --> 00:02:41.660
It's a very big release,
and it's really taking our

00:02:41.660 --> 00:02:43.890
tools to the next level.

00:02:45.160 --> 00:02:48.090
In addition to making it available
to you for download on the web,

00:02:48.210 --> 00:02:51.210
we are also offering Xcode
Now in the Mac App Store,

00:02:51.210 --> 00:02:54.380
which is the easiest way to
install the tools and to stay

00:02:54.380 --> 00:02:57.500
up to date on the latest SDKs.

00:02:57.500 --> 00:02:59.260
And we want to make this
App Store experience even

00:02:59.360 --> 00:03:00.600
better for you going forward.

00:03:00.600 --> 00:03:03.810
We are working on a number of
mechanisms to reduce the download

00:03:03.810 --> 00:03:07.810
size of the Xcode installer.

00:03:16.760 --> 00:03:19.370
We hear you.

00:03:19.860 --> 00:03:23.560
By breaking it up into multiple packages,
which you can download on demand

00:03:23.620 --> 00:03:25.480
only if you actually need them.

00:03:25.540 --> 00:03:28.920
And also, when Lion ships to end
users in just a few weeks,

00:03:29.080 --> 00:03:33.720
Xcode is going to be free for all
Lion users right from the App Store.

00:03:37.830 --> 00:03:39.910
Now in the near future,
we're going to ship two

00:03:39.910 --> 00:03:41.680
new tools releases to you.

00:03:41.680 --> 00:03:44.760
And we're going to time them with the
operating system launches Apple is

00:03:44.900 --> 00:03:47.530
planning next few weeks and months.

00:03:47.590 --> 00:03:51.020
Xcode 4.1 will coincide
with Mac OS X Lion,

00:03:51.060 --> 00:03:55.240
and later this year,
Xcode 4.2 will add support for iOS 5.

00:03:55.420 --> 00:03:58.990
Let's take a look at two of the
features of these new tools releases,

00:03:59.030 --> 00:04:01.470
starting with Xcode 4.1 for Lion.

00:04:02.650 --> 00:04:06.800
The first thing you will notice is that
we are making Xcode look great online.

00:04:06.800 --> 00:04:10.650
And take advantage of the many
improvements in the new look and feel.

00:04:10.850 --> 00:04:14.080
For example,
the new single window workflow in

00:04:14.080 --> 00:04:16.990
Xcode works fantastic in full screen.

00:04:18.490 --> 00:04:20.920
Another thing you will see us
doing more and more going forward

00:04:21.600 --> 00:04:25.530
is focus on keeping our platforms
consistent and very integrated,

00:04:25.530 --> 00:04:28.640
and avoiding any kind of
unnecessary fragmentation.

00:04:28.710 --> 00:04:33.120
And so it's critical that you take
advantage of our latest technologies,

00:04:33.220 --> 00:04:34.590
tools, and SDKs.

00:04:34.840 --> 00:04:37.350
And to help you with that,
we're introducing a new

00:04:37.350 --> 00:04:40.370
project modernization workflow,
which will offer to update your

00:04:40.490 --> 00:04:45.020
projects to the latest settings
that we consider the best practices.

00:04:46.380 --> 00:04:49.090
For the more performance-oriented
engineers among you,

00:04:49.090 --> 00:04:51.650
we are adding the ability to
view the compiler assembly and

00:04:51.740 --> 00:04:54.870
preprocessor output right in the IDE.

00:05:00.650 --> 00:05:03.920
But the majority of new features in
Xcode 4.1 will focus on supporting

00:05:03.920 --> 00:05:08.840
new line technologies and making the
Xcode UI even easier to navigate.

00:05:08.870 --> 00:05:11.300
We're going to add support
for the new Cocoa controls,

00:05:11.440 --> 00:05:14.250
like popovers and view-based table views,
an example of which you

00:05:14.340 --> 00:05:16.140
see here on the screen.

00:05:16.270 --> 00:05:19.380
We're going to allow configuring
Mac push notifications.

00:05:19.420 --> 00:05:22.980
And Xcode is going to get an
editor to manage entitlements

00:05:23.050 --> 00:05:24.760
for sandboxing your apps.

00:05:24.940 --> 00:05:28.140
We're also adding new
customizable behaviors to Xcode.

00:05:28.180 --> 00:05:31.100
But most importantly,
the integrated interface builder

00:05:31.100 --> 00:05:34.650
is going to gain support for the
new Cocoa order layout mechanism,

00:05:34.650 --> 00:05:37.210
which allows you to define the
resizing behavior of your windows

00:05:37.210 --> 00:05:41.040
in a much better way than springs
and struts allowed you to so far.

00:05:41.110 --> 00:05:43.700
To tell you more about that,
I'm going to head over to

00:05:43.700 --> 00:05:45.390
Max Drukman for a few minutes.

00:05:51.570 --> 00:05:53.100
Thank you, Andreas.

00:05:53.160 --> 00:05:57.060
Good afternoon, WWDC.

00:05:57.490 --> 00:06:01.780
So since Craig already gave my demo,
what do you want to talk about?

00:06:01.830 --> 00:06:08.470
Now, ever wish you had one of these?

00:06:09.430 --> 00:06:13.100
Yes, this is the mythical
"do what I mean" button.

00:06:13.170 --> 00:06:16.120
Right, we've wanted one of these
for years and years.

00:06:16.340 --> 00:06:19.710
Auto Layout is a little bit like
getting a "do what I mean" button

00:06:20.460 --> 00:06:22.780
that comes already pressed.

00:06:22.920 --> 00:06:24.590
Let me show you.

00:06:30.390 --> 00:06:32.660
So here's an image editing
app I'm working on.

00:06:32.700 --> 00:06:35.680
This is the intro screen where
my users can select folders

00:06:35.680 --> 00:06:38.220
of images for processing.

00:06:38.240 --> 00:06:40.660
I'm going to add one last button.

00:06:41.320 --> 00:06:46.310
I'm going to call it
"Choose Another Folder."

00:06:47.010 --> 00:06:52.660
and I'm going to place it right where the
handy Aqua guides tell me it should go.

00:06:52.700 --> 00:06:55.260
Now, I'll wire that up later,
but for now,

00:06:55.260 --> 00:07:00.370
I'm interested in seeing how my
interface responds to resizing.

00:07:00.500 --> 00:07:02.040
So I'm going to run it.

00:07:02.100 --> 00:07:06.380
Now, judging from the applause when
Craig mentioned this feature,

00:07:06.420 --> 00:07:08.710
I'm guessing some of you
know what's going to happen

00:07:09.060 --> 00:07:11.700
when I resize this window.

00:07:11.760 --> 00:07:13.700
Let's have a look.

00:07:13.780 --> 00:07:15.630
Yeah.

00:07:18.500 --> 00:07:20.510
That doesn't look right, does it?

00:07:20.620 --> 00:07:22.760
I have a couple problems here.

00:07:22.760 --> 00:07:25.950
One is that my whole interface
is pretty much left in the

00:07:25.950 --> 00:07:27.900
upper left corner of my window.

00:07:28.010 --> 00:07:32.690
And I'm even getting strings
truncating because I didn't allot

00:07:32.690 --> 00:07:36.120
for the number of digits I'm getting.

00:07:36.410 --> 00:07:39.420
I wish I had a do what I mean button.

00:07:39.640 --> 00:07:42.120
Let's see if Auto Layout can help.

00:07:42.130 --> 00:07:44.620
I'm going to start by simply enabling it.

00:07:44.630 --> 00:07:50.300
I'm going to go to the file inspector,
and click Use Auto Layout.

00:07:50.300 --> 00:07:51.400
No other changes.

00:07:51.400 --> 00:07:54.780
Let's run and see what happens.

00:07:54.780 --> 00:07:58.800
All right, any guesses now?

00:07:58.820 --> 00:08:01.860
Hey, how about that?

00:08:08.530 --> 00:08:12.740
Now, how does Auto Layout do what I mean?

00:08:12.770 --> 00:08:17.440
As Craig mentioned, thank you Craig,
what Auto Layout does is it

00:08:17.450 --> 00:08:23.530
starts by taking the Aqua Layout
guides and it makes them stick.

00:08:23.710 --> 00:08:27.700
So when I lay out a button in
the lower right-hand corner of

00:08:27.700 --> 00:08:31.920
my window along the Aqua guides,
it stays there.

00:08:31.960 --> 00:08:34.310
It also looks at the
contents of controls,

00:08:34.580 --> 00:08:38.250
for instance, the text in my labels,
and makes the controls big enough

00:08:38.380 --> 00:08:40.880
to accommodate the contents,
which is why I'm not

00:08:40.880 --> 00:08:42.530
getting truncation anymore.

00:08:43.280 --> 00:08:48.220
Now, there can be ambiguous cases,
and I think I've got one right here.

00:08:48.220 --> 00:08:54.140
Yep, there's another classic case where
I have controls that are overlapping.

00:08:54.140 --> 00:08:57.760
Now, for that,
I would need the Read My Mind button.

00:08:57.760 --> 00:09:01.970
Unfortunately, I can't comment on future
product directions.

00:09:05.800 --> 00:09:08.140
Auto Layout has me covered here too.

00:09:08.140 --> 00:09:10.560
Let's have a look in Xcode.

00:09:10.820 --> 00:09:13.570
Now when I select the cancel button,
you'll see that there are some

00:09:13.620 --> 00:09:16.230
blue guides that draw persistently.

00:09:16.380 --> 00:09:19.560
Those guides represent constraints.

00:09:19.610 --> 00:09:23.300
Constraints are objects that
Auto Layout creates to keep

00:09:23.300 --> 00:09:27.300
the components of my interface
aligned and sized properly.

00:09:27.390 --> 00:09:30.410
Constraints are objects you can
work with just like any other

00:09:30.500 --> 00:09:32.300
object in interface builder.

00:09:32.450 --> 00:09:36.300
You can set outlets on them,
even animate them at runtime.

00:09:36.300 --> 00:09:40.300
Now there are a couple of interesting
constraints going on here.

00:09:40.300 --> 00:09:44.220
The cancel button has a constraint
that keeps it the default awkward

00:09:44.350 --> 00:09:46.300
distance from the open button.

00:09:46.370 --> 00:09:50.300
It will always be there because
that constraint is there.

00:09:50.470 --> 00:09:54.230
It also has constraints keeping
the baseline of its text

00:09:54.420 --> 00:09:59.300
aligned with the baseline of the
text of the adjacent buttons.

00:09:59.300 --> 00:10:02.130
So those will always be
vertically aligned as well.

00:10:03.420 --> 00:10:07.540
Now,
the problem I had was the cancel button

00:10:07.670 --> 00:10:10.270
and the choose another folder button.

00:10:11.030 --> 00:10:14.000
were overlapping when
my window got too small.

00:10:14.040 --> 00:10:15.950
Now,
the old school way of fixing that would

00:10:15.950 --> 00:10:18.390
be just bump up the width of my window,
right?

00:10:18.430 --> 00:10:20.200
And I'm done.

00:10:20.220 --> 00:10:25.880
But I want my interfaces to look
great full screen on a 27-inch iMac,

00:10:25.920 --> 00:10:30.110
not taking up all of the pixels
on an 11-inch MacBook Air,

00:10:30.110 --> 00:10:31.810
and everything in between.

00:10:31.870 --> 00:10:36.110
So the right way to do this
is by adding a constraint.

00:10:36.270 --> 00:10:39.950
I'll do that using the editor menu,
and I'm going to add a

00:10:39.960 --> 00:10:42.640
horizontal spacing constraint.

00:10:42.690 --> 00:10:46.160
Constraints can be inspected
in the attributes inspector,

00:10:46.170 --> 00:10:49.910
and they can be set to be a
fixed value or to be flexible.

00:10:49.920 --> 00:10:51.570
And that's what I'm going to do here.

00:10:52.300 --> 00:10:57.580
So I'm going to set this constraint to
be greater than or equal to this value.

00:10:57.600 --> 00:11:00.490
And what that means is that
when my window gets bigger,

00:11:00.580 --> 00:11:03.460
the constraint will allow
the window to flex out.

00:11:03.550 --> 00:11:06.980
But when it hits that value, it'll stop.

00:11:09.270 --> 00:11:11.960
Let's see if I'm right.

00:11:12.020 --> 00:11:13.690
So now, here's my window.

00:11:13.870 --> 00:11:18.670
I set one constraint, and yep,
sure enough,

00:11:22.100 --> 00:11:24.500
Pretty cool.

00:11:24.510 --> 00:11:29.280
I now can't make this window small
enough to impact these controls.

00:11:29.320 --> 00:11:33.050
That's because the constraints are
working from the inside out to tell

00:11:33.050 --> 00:11:36.430
the window what size it needs to be.

00:11:37.340 --> 00:11:40.700
Let's look at a more complex case.

00:11:40.820 --> 00:11:43.450
Once my users have selected
an image to work on,

00:11:43.960 --> 00:11:47.440
they can use this interface
to perform color filtering.

00:11:47.540 --> 00:11:51.410
So above is a preview of my image,
and below are three boxes,

00:11:51.460 --> 00:11:53.920
each of which has some
filter controls in it.

00:11:53.960 --> 00:11:55.300
I've already set up some constraints.

00:11:55.360 --> 00:11:57.420
Let me show them to you.

00:11:58.420 --> 00:12:06.480
So when I select this label,
there's a horizontal-- sorry.

00:12:06.540 --> 00:12:08.420
I knew I was going to get this wrong.

00:12:08.500 --> 00:12:10.760
There is a horizontal
centering constraint.

00:12:10.830 --> 00:12:14.500
And what that does is it keeps the
label always centered in the box.

00:12:14.570 --> 00:12:17.800
There are also two constraints,
one on either side of the label,

00:12:17.850 --> 00:12:22.180
that work just like in my previous
example as flexible space.

00:12:22.240 --> 00:12:27.200
They allow the box to get bigger,
but only get small to a point.

00:12:27.290 --> 00:12:30.360
so it doesn't affect the label.

00:12:30.600 --> 00:12:33.440
Now, I also have,
all three of these boxes

00:12:33.530 --> 00:12:35.360
are set up the same way,
by the way.

00:12:35.380 --> 00:12:39.250
And I also have a constraint
between each of these boxes,

00:12:39.250 --> 00:12:42.840
and that is an equal widths constraint.

00:12:42.880 --> 00:12:46.960
What that does is it tells each
of these boxes that they always

00:12:46.960 --> 00:12:50.880
have to be the same width,
so that when my window resizes,

00:12:50.880 --> 00:12:54.520
all three of these boxes
will resize the same way.

00:12:54.940 --> 00:12:57.920
This kind of multi-column
layout used to be pretty hard

00:12:57.920 --> 00:12:59.850
to do and required custom code.

00:12:59.850 --> 00:13:03.630
Now, with Auto Layout,
you can do it right in IB, zero code.

00:13:05.050 --> 00:13:07.690
Now, why do it this way?

00:13:07.920 --> 00:13:12.230
Why are constraints a
better way to do this?

00:13:12.230 --> 00:13:12.230
Well,

00:13:12.530 --> 00:13:18.840
If you think globally, right,
when my app gets localized into German,

00:13:18.990 --> 00:13:20.700
it should still work.

00:13:20.850 --> 00:13:25.640
When it gets localized into Georgian,
it should still work.

00:13:25.780 --> 00:13:27.640
And keep working.

00:13:27.820 --> 00:13:32.270
Because constraints are always keeping
my interface doing the right thing.

00:13:32.270 --> 00:13:35.690
That's Auto Layout.

00:13:43.300 --> 00:13:45.200
Let's look at some code.

00:13:45.300 --> 00:13:49.190
Now, I don't know about you,
but I'm a little particular about how

00:13:49.190 --> 00:13:52.010
I want things to be when I'm doing code.

00:13:52.020 --> 00:13:56.120
So I'm going to do a
layout of a different kind.

00:13:56.120 --> 00:14:01.880
I'm going to layout Xcode
using full-screen assistant.

00:14:02.320 --> 00:14:06.130
Now, full-screen assistant isn't
a new feature in Xcode,

00:14:06.130 --> 00:14:10.590
but it takes advantage of an
enhanced feature in Xcode 4.1.

00:14:10.630 --> 00:14:16.900
We took the behaviors mechanism of Xcode,
and now we allow you to make your own.

00:14:16.900 --> 00:14:19.610
Let's have a look.

00:14:20.740 --> 00:14:25.070
Now, behaviors are a very powerful system
that Xcode uses to perform certain

00:14:25.070 --> 00:14:27.100
actions based on certain triggers.

00:14:27.260 --> 00:14:30.760
For instance, when my app builds,
I get a bezel alert that

00:14:30.910 --> 00:14:32.460
tells me that it succeeded.

00:14:32.840 --> 00:14:36.590
That's controlled by this behavior.

00:14:37.090 --> 00:14:40.460
As I said, in Xcode 4.1,
I can now make my own.

00:14:40.800 --> 00:14:43.650
I can even assign keyboard
shortcuts to them.

00:14:43.770 --> 00:14:48.710
Now, the full slate of actions are
available for custom behaviors,

00:14:48.820 --> 00:14:51.360
just as they are for the
behaviors that come with Xcode.

00:14:52.120 --> 00:14:55.810
So, in this case,
what I did was I told Xcode that

00:14:55.810 --> 00:14:58.660
I wanted to show a tab that I named.

00:14:58.660 --> 00:15:01.560
I want to hide the debugger,
the utilities, the navigator,

00:15:01.560 --> 00:15:04.710
if they were showing,
and enter full screen,

00:15:05.130 --> 00:15:09.700
where Xcode's single window plus
tabs interface really shines.

00:15:09.920 --> 00:15:13.220
Now I can even do things like
add custom scripts to do all

00:15:13.220 --> 00:15:15.400
kinds of interesting things.

00:15:15.440 --> 00:15:18.760
I could take over the world,
assuming I can write a

00:15:18.900 --> 00:15:20.610
script that does that.

00:15:21.330 --> 00:15:25.100
Now, there's one more kind of
layout I want to talk about,

00:15:25.190 --> 00:15:27.650
and that is the layout of my code.

00:15:27.660 --> 00:15:30.440
So now we're talking about the compiler.

00:15:30.440 --> 00:15:37.000
So another advancement we put
into Xcode 4.1 is the generated

00:15:37.890 --> 00:15:40.720
output category in the assistant.

00:15:41.280 --> 00:15:45.260
So now I can look at assembly
side by side with my code.

00:15:45.270 --> 00:15:47.500
It gets generated on the fly.

00:15:47.610 --> 00:15:50.320
If I want to,
I can navigate through my project and

00:15:50.320 --> 00:15:52.540
see the assembly of any file I land on.

00:15:52.540 --> 00:15:57.420
I can even add another assistant.

00:15:58.350 --> 00:16:01.270
And, heck,
look at the pre-processed output.

00:16:01.470 --> 00:16:03.200
Why not, right?

00:16:03.330 --> 00:16:13.200
So now, it's just my interface laid out,
Xcode laid out, my code laid out.

00:16:13.200 --> 00:16:17.080
It's my moment of zen.

00:16:17.080 --> 00:16:18.930
Back to you, Andreas.

00:16:25.820 --> 00:16:28.560
Thank you, Max.

00:16:28.660 --> 00:16:31.910
So that was an overview of the
Lion-focused features in Xcode 4.1.

00:16:32.140 --> 00:16:37.570
Let's now take a look at what we have in
store for you with iOS 5 and Xcode 4.2.

00:16:38.200 --> 00:16:39.890
First,
we're going to add a number of features

00:16:40.040 --> 00:16:44.200
that will help you test and analyze
what's going on in your applications.

00:16:44.290 --> 00:16:47.770
You can now sync data from your
applications back and forth between your

00:16:47.930 --> 00:16:50.380
test devices and your development Mac.

00:16:50.460 --> 00:16:52.980
And that behavior is even
integrated with unit tests,

00:16:53.030 --> 00:16:56.840
so that you can now configure unit tests
to run the specific data sets uploaded

00:16:56.910 --> 00:16:59.790
to your devices before your tests launch.

00:17:04.420 --> 00:17:06.960
Instruments also adds
amazing new capabilities.

00:17:06.960 --> 00:17:11.310
This includes system trace for iOS,
a very commonly requested feature.

00:17:11.410 --> 00:17:15.260
Vastly improved multi-core analysis,
so you can take better advantage

00:17:15.260 --> 00:17:17.360
of our dual-core processors.

00:17:17.460 --> 00:17:20.530
And a new network activity
instrumentation that helps you identify

00:17:20.530 --> 00:17:23.710
situations where you constantly
trigger data in and out of an app,

00:17:23.740 --> 00:17:27.750
which can burn through
battery life rather quickly.

00:17:27.870 --> 00:17:31.490
Next, you can now simulate locations.

00:17:37.500 --> 00:17:39.850
You can even record
paths of locations and,

00:17:39.950 --> 00:17:44.410
for example, simulate the user driving
around a specific street.

00:17:46.320 --> 00:17:50.760
or you can visit other countries
and international locations.

00:17:50.760 --> 00:17:52.800
And all of that, of course,
means that you can now make

00:17:52.980 --> 00:17:56.500
sure that your applications even
work in places that you would

00:17:56.500 --> 00:17:58.330
never want to visit in person.

00:18:09.100 --> 00:18:11.100
The next is a feature that
will help you design your

00:18:11.100 --> 00:18:14.280
applications in a whole new way.

00:18:14.280 --> 00:18:17.510
How many of you have ever started
designing an app on a napkin or a

00:18:17.510 --> 00:18:19.920
sketch pad like this shown here?

00:18:19.920 --> 00:18:23.340
So this is actually a great way
to get your thoughts out on paper.

00:18:23.390 --> 00:18:26.120
It's not always easy to
translate it to an app,

00:18:26.120 --> 00:18:29.890
and you can't put napkins
under source control.

00:18:31.350 --> 00:18:37.710
But this is really a great
way to-- this way of-- sorry.

00:18:38.060 --> 00:18:41.820
This approach of designing application
with multiple screens and transitions

00:18:41.860 --> 00:18:44.060
in between is actually very compelling.

00:18:44.140 --> 00:18:49.060
And we're going to realize it with a
new feature that we call storyboarding.

00:18:49.110 --> 00:18:50.940
Storyboards--

00:18:57.650 --> 00:19:00.530
So storyboards give you a view
of your entire application.

00:19:00.560 --> 00:19:03.120
They get you up and running very quickly.

00:19:03.130 --> 00:19:04.850
To tell you more about this,
I'm going to ask

00:19:05.020 --> 00:19:07.450
Jon Hess for a few minutes.

00:19:16.200 --> 00:19:18.200
Thanks, Andreas.

00:19:18.340 --> 00:19:21.240
Storyboards are all about letting
you build applications the way that

00:19:21.240 --> 00:19:23.200
you think about your applications.

00:19:23.200 --> 00:19:26.620
You get to see all of the screens that
make up your program in one place.

00:19:26.830 --> 00:19:28.980
And more importantly,
you get to see all of the

00:19:28.980 --> 00:19:32.270
paths that the user can take to
navigate between those screens,

00:19:32.270 --> 00:19:32.900
all in Xcode.

00:19:33.280 --> 00:19:36.100
We do this by introducing
two new simple concepts,

00:19:36.280 --> 00:19:37.400
scenes and segues.

00:19:37.400 --> 00:19:41.370
Scenes are the major visual
components of a storyboard.

00:19:41.370 --> 00:19:45.280
Each one is defined by a view
controller and its associated view.

00:19:45.280 --> 00:19:48.370
Now, everything you already know
about using Interface Builder,

00:19:48.500 --> 00:19:51.040
like using the inspectors,
actions and outlets,

00:19:51.230 --> 00:19:53.840
all of that applies to building
your scenes in your storyboard.

00:19:53.840 --> 00:19:57.460
And no matter how many scenes you
put into one of your storyboards,

00:19:57.460 --> 00:20:00.390
at build time,
we're going to process it and optimize

00:20:00.390 --> 00:20:04.230
it into a form where it can be loaded
one piece at a time at runtime.

00:20:04.240 --> 00:20:07.340
Now, this gives you great performance,
but it also means that you're

00:20:07.340 --> 00:20:07.360
going to be able to build a
lot of things in one place.

00:20:07.360 --> 00:20:10.300
And that means that each one of
the scenes in your storyboard is

00:20:10.300 --> 00:20:14.400
actually more like a recipe or a
template and can be instantiated

00:20:14.400 --> 00:20:16.200
independently multiple times.

00:20:16.200 --> 00:20:20.770
This opens up some really powerful
workflows and sophisticated applications.

00:20:21.520 --> 00:20:23.890
In addition to scenes,
we also have segues.

00:20:24.040 --> 00:20:27.200
Segues are the glue that
binds a storyboard together.

00:20:27.290 --> 00:20:30.260
Each segue defines how one
view controller instantiates

00:20:30.370 --> 00:20:32.200
and presents another.

00:20:32.350 --> 00:20:34.300
Creating a segue in
Interface Builder is easy.

00:20:34.370 --> 00:20:36.410
You just control drag
from any event source,

00:20:36.470 --> 00:20:40.020
like a button, table cell,
or even a gesture recognizer,

00:20:40.020 --> 00:20:41.200
to some other scene.

00:20:41.260 --> 00:20:43.660
And when you do this,
you get to define a transition

00:20:43.660 --> 00:20:45.600
style that accompanies the scene.

00:20:45.670 --> 00:20:48.630
We have support for all the
system transition styles built

00:20:48.630 --> 00:20:51.300
right into Interface Builder,
including popovers.

00:20:51.360 --> 00:20:54.870
You can even build
your own custom segues.

00:20:55.470 --> 00:20:57.700
Storyboards apply to all
sorts of applications,

00:20:57.750 --> 00:21:01.200
but today I'd like to demonstrate them
to you by building the introduction to

00:21:01.200 --> 00:21:04.160
the OpenGL game you see behind me here,
Touch Fighter 2.

00:21:04.220 --> 00:21:06.270
Let's go over to the demo machines.

00:21:15.500 --> 00:21:21.160
We're going to get started with a new
instance of the OpenGL game template.

00:21:21.160 --> 00:21:23.900
Our game will be Touch Fighter 2.

00:21:23.900 --> 00:21:26.540
We're going to target the iPhone,
and we're going to use storyboards.

00:21:26.660 --> 00:21:30.920
Storyboards are the default with all
of our project templates in Xcode 4.

00:21:33.940 --> 00:21:36.100
Now, Touch Fighter is going to
be a landscape-based game,

00:21:36.210 --> 00:21:40.700
so I'm going to opt out of portrait by
just toggling this portrait button here.

00:21:40.760 --> 00:21:42.940
And I have a little bit of
prepared content in the doc

00:21:43.100 --> 00:21:43.980
that we're going to use today.

00:21:44.020 --> 00:21:46.500
Let me just drag that into my project.

00:21:50.890 --> 00:21:53.220
So this is just a couple of
images that we're going to

00:21:53.220 --> 00:21:55.360
use in the storyboard today,
and one view controller to

00:21:55.540 --> 00:21:57.480
explicitly support landscape.

00:21:57.510 --> 00:21:59.740
With that,
I'm ready to focus on my storyboard.

00:21:59.750 --> 00:22:03.150
I've got a new behavior that I've
set up to jump straight into full

00:22:03.290 --> 00:22:07.860
screen and hide my navigator and
show my utilities in my library.

00:22:07.870 --> 00:22:10.680
Now, when I like to get
started with a storyboard,

00:22:10.680 --> 00:22:13.540
I like to think about the
application from the outside in.

00:22:13.560 --> 00:22:16.320
I like to think,
what are the major view controllers

00:22:16.320 --> 00:22:19.330
or scenes that the developer or
the user is going to interact

00:22:19.440 --> 00:22:20.400
with when they use my program?

00:22:20.400 --> 00:22:23.150
I'd like to put them all in first,
and then build them

00:22:23.160 --> 00:22:25.290
and link them together.

00:22:25.350 --> 00:22:27.980
I can get an overview of my storyboard
by just double-clicking anywhere in

00:22:27.980 --> 00:22:31.740
the background to get a zoomed-out,
high-level view.

00:22:31.820 --> 00:22:35.450
And from the object library here,
I'm going to search

00:22:35.540 --> 00:22:37.010
for "view controller."

00:22:38.150 --> 00:22:39.540
and create two new scenes.

00:22:39.580 --> 00:22:41.540
This will be our main intro screen.

00:22:41.570 --> 00:22:45.590
The user will be able to choose a
multiplayer level in one direction,

00:22:45.590 --> 00:22:50.060
or jump straight into the game for
either single player or multiplayer.

00:22:50.430 --> 00:22:53.560
I can double click to zoom back in,
and I'm ready to start

00:22:53.560 --> 00:22:54.990
building my scenes.

00:22:55.960 --> 00:22:58.570
In the media library,
I've got a couple of resources that I'd

00:22:58.580 --> 00:23:02.010
like to use with each one of my screens.

00:23:02.550 --> 00:23:04.980
Here's a backdrop for our intro.

00:23:06.560 --> 00:23:11.030
We've got a great star field for
the multiplayer level selection.

00:23:11.030 --> 00:23:16.200
And as easy as storyboarding is,
making an OpenGL game is

00:23:16.200 --> 00:23:18.330
still really rewarding.

00:23:18.430 --> 00:23:21.810
So I'm just going to use a
screenshot here from my OpenGL game,

00:23:21.810 --> 00:23:24.290
and we'll leave that to all of you later.

00:23:25.750 --> 00:23:27.610
We have our three scenes
basically laid out,

00:23:27.670 --> 00:23:30.450
and now we're ready to build
some segues here so the user

00:23:30.450 --> 00:23:31.810
can navigate between them.

00:23:31.990 --> 00:23:34.460
I need an event source.

00:23:34.950 --> 00:23:38.780
I'm going to start with a button and
drag it over into our intro screen.

00:23:38.830 --> 00:23:42.290
And this is going to be the single player
button to jump straight into the game.

00:23:42.420 --> 00:23:45.300
And I'll duplicate it
once for multiplayer.

00:23:45.300 --> 00:23:47.820
Now, I'd like to customize the
look of these buttons so they

00:23:47.820 --> 00:23:51.310
look great on my backdrop.

00:23:51.310 --> 00:23:55.740
I've got some custom images here.

00:23:55.740 --> 00:23:57.740
And I'll set some titles.

00:23:57.740 --> 00:23:57.740
So,

00:24:02.930 --> 00:24:05.090
Now,
I'd like that text to have high contrast,

00:24:05.290 --> 00:24:08.070
so over here in the inspector,
I'm going to choose a bright

00:24:08.070 --> 00:24:11.880
orange and bump the font
way up so it's easy to read.

00:24:12.100 --> 00:24:14.630
Okay,
creating our first segue is as easy as

00:24:14.770 --> 00:24:21.270
control-dragging from the single player
button to the other scene and letting go.

00:24:22.510 --> 00:24:24.040
So here's our segue.

00:24:24.110 --> 00:24:27.250
This is a modal segue that's going
to do the default transition.

00:24:27.330 --> 00:24:30.030
I'd actually like to be explicit
and choose cross dissolve.

00:24:30.090 --> 00:24:33.240
I think cross dissolve is a quick,
tasteful way to get the

00:24:33.240 --> 00:24:37.040
user quickly into the game.

00:24:37.090 --> 00:24:37.330
Okay.

00:24:37.430 --> 00:24:40.610
In our multiplayer screen,
we're going to have two buttons as well

00:24:40.610 --> 00:24:42.620
to pick between two different levels.

00:24:47.000 --> 00:24:49.730
I've also got some custom
resources here in the library to

00:24:49.730 --> 00:24:51.560
make those buttons look great.

00:24:51.570 --> 00:24:55.380
We have an Andromedan Assault
Level and Defend Earth.

00:24:56.790 --> 00:25:01.130
I'm going to make some room
and create two more segues from

00:25:01.140 --> 00:25:03.800
those buttons into the game.

00:25:07.420 --> 00:25:09.540
Now we're ready for our final segue.

00:25:09.620 --> 00:25:11.980
We'd like the user to be able to
click the multiplayer button here

00:25:11.980 --> 00:25:13.900
and jump to the multiplayer screen.

00:25:13.900 --> 00:25:16.580
But I'd like the user to be able
to back out of this transition.

00:25:16.710 --> 00:25:20.210
Should they choose that they want to
go back and play a single player game.

00:25:20.210 --> 00:25:23.420
And perhaps the most recognizable
way to do that in an iOS application

00:25:23.420 --> 00:25:25.300
is with the navigation controller.

00:25:25.300 --> 00:25:29.430
The navigation controller gives users the
ability to quickly move back and forward

00:25:29.430 --> 00:25:31.410
on a list or a tree in an application.

00:25:31.420 --> 00:25:34.270
I can create a navigation
controller in my storyboard by

00:25:34.270 --> 00:25:37.850
just selecting one of my scenes,
going to the editor menu and choosing

00:25:37.850 --> 00:25:39.820
embed in navigation controller.

00:25:39.820 --> 00:25:43.250
And interface will slide everything
down to make room and create a

00:25:43.250 --> 00:25:45.080
new navigation controller for me.

00:25:45.080 --> 00:25:48.770
I'm going to select my navigation bar.

00:25:49.470 --> 00:25:53.800
Change this tint color to this dark
brown that matches my screen better.

00:25:53.820 --> 00:25:57.060
And move my background
picture to accommodate for it.

00:25:57.100 --> 00:25:59.890
Now we're ready to
connect our last segue.

00:26:04.100 --> 00:26:06.040
Okay,
something interesting happened here.

00:26:06.050 --> 00:26:09.180
This brown navigation bar
propagated onto this new screen.

00:26:09.190 --> 00:26:12.300
And if I look at the segue,
it has a different icon than the others.

00:26:12.330 --> 00:26:15.100
This is a navigation push segue,
and it's going to do a transition

00:26:15.250 --> 00:26:17.000
that slides in from right to left.

00:26:17.030 --> 00:26:19.930
Interface Builder could tell from the
context of my storyboard with that

00:26:19.940 --> 00:26:22.270
navigation controller back there,
that that was the best

00:26:22.530 --> 00:26:24.200
transition to pick by default.

00:26:24.240 --> 00:26:26.500
You'll see if we scroll over
to the Touch Fighter game,

00:26:26.500 --> 00:26:28.300
it doesn't include the navigation bar.

00:26:28.340 --> 00:26:29.680
That's because these are modal segues.

00:26:29.780 --> 00:26:32.230
And the modal segues are
basically context-free,

00:26:32.230 --> 00:26:35.450
and they're not going to bring
that navigation bar with them.

00:26:36.070 --> 00:26:39.610
I'm going to adjust these
images to consider that bar,

00:26:39.670 --> 00:26:41.690
and I can set a title here.

00:26:45.280 --> 00:26:51.690
and I can zoom out to get an overview
and make sure that everything looks

00:26:51.940 --> 00:26:54.400
just the way I intended it to.

00:26:54.430 --> 00:26:57.350
I'm going to select all three
of these view controllers.

00:26:58.400 --> 00:27:01.970
and opt them into that custom
class I mentioned earlier

00:27:02.060 --> 00:27:04.110
that support landscape,
and we're ready to run

00:27:04.120 --> 00:27:06.230
on the iPhone simulator.

00:27:09.090 --> 00:27:10.600
Here's our Touch Fighter 2 game.

00:27:10.660 --> 00:27:13.720
The user can click multiplayer,
see the multiplayer levels.

00:27:13.850 --> 00:27:17.040
The navigation controllers
provided this helpful back button.

00:27:17.140 --> 00:27:19.190
And I can jump straight into the game.

00:27:19.300 --> 00:27:20.200
Thank you very much.

00:27:20.420 --> 00:27:22.240
Back to you, Andreas.

00:27:29.600 --> 00:27:31.620
Thank you, Jon.

00:27:31.720 --> 00:27:33.880
So since Jon already started
building a game for us,

00:27:33.880 --> 00:27:35.680
let's take a look at what we
can do to help you with the

00:27:35.680 --> 00:27:38.080
actual OpenGL part of it.

00:27:38.210 --> 00:27:41.060
There are more and more applications
that leverage the powerful GPUs in our

00:27:41.130 --> 00:27:44.820
hardware through the use of OpenGL APIs.

00:27:44.910 --> 00:27:48.110
One issue with running OpenGL code
is that it creates very different

00:27:48.170 --> 00:27:51.700
debugging needs in comparison
to running code on the CPU.

00:27:52.100 --> 00:27:55.440
Back in March with Xcode 4,
we started adding a number of

00:27:55.440 --> 00:27:59.990
tools that help you understand
and diagnose OpenGL applications.

00:28:00.350 --> 00:28:04.420
The first, very easy to use one,
is the OpenGL ES Performance Detective,

00:28:04.420 --> 00:28:06.590
which is essentially an assistant
that performs a number of

00:28:06.610 --> 00:28:10.290
experiments on your apps,
and then tells you which stages

00:28:10.380 --> 00:28:15.010
of the OpenGL pipeline are the top
suspects for performance bottlenecks.

00:28:15.720 --> 00:28:18.670
The Performance Detective can be
used as a standalone application,

00:28:18.670 --> 00:28:22.100
but it's also integrated with
Xcode exactly like Instruments is.

00:28:22.180 --> 00:28:26.310
So you can define profiling actions in
your project schemes that invoke the

00:28:26.310 --> 00:28:29.230
Performance Detective right out of Xcode.

00:28:31.540 --> 00:28:35.520
The other tool we added back in March is
the OpenGL ES Analyzer instrument,

00:28:35.520 --> 00:28:39.690
which data mines the OpenGL command
stream to collect per frame statistics,

00:28:39.780 --> 00:28:43.840
such as the number of
patterns and OpenGL commands.

00:28:43.890 --> 00:28:46.740
And you can then easily view
which commands account for

00:28:46.740 --> 00:28:50.190
the most processing time,
and get specific recommendations

00:28:50.310 --> 00:28:52.170
for how to optimize your code.

00:28:53.160 --> 00:28:56.730
Both the Performance Detective and
the Analyzer Instrument are invaluable

00:28:56.730 --> 00:29:00.770
tools to better understanding
and optimizing our OpenGL apps.

00:29:00.840 --> 00:29:05.000
With iOS 5, we're going to take it
a huge step further.

00:29:05.160 --> 00:29:08.800
We're going to add a fully-featured
OpenGL frame debugger,

00:29:08.800 --> 00:29:11.740
integrated into the IDE,
which allows you to visually debug your

00:29:11.740 --> 00:29:16.610
applications and quickly zero in on
drawing issues and rendering artifacts.

00:29:16.650 --> 00:29:20.260
To tell you more about this,
I'm going to hand over to Matt Firlik.

00:29:27.500 --> 00:29:29.800
Thank you, Andreas.

00:29:29.800 --> 00:29:33.300
When we first started designing
the OpenGL ES debugger for Xcode,

00:29:33.300 --> 00:29:35.600
we had two main goals.

00:29:35.600 --> 00:29:40.140
The first was to dramatically simplify
the debugging experience for OpenGL.

00:29:40.150 --> 00:29:43.180
We want the IDE to manage the
complexity for you and make it

00:29:43.210 --> 00:29:46.810
really easy for you to find and
fix issues in your OpenGL code.

00:29:46.840 --> 00:29:49.840
Our second goal was to design
a user experience for the

00:29:49.840 --> 00:29:53.550
debugger that was truly befitting
the underlying technology.

00:29:53.550 --> 00:29:57.490
OpenGL being inherently visual,
we wanted a dynamic and

00:29:57.630 --> 00:30:01.050
fluid workflow that was both
powerful and intuitive to use.

00:30:01.080 --> 00:30:04.980
I'm proud to say that's
exactly what we accomplished,

00:30:05.290 --> 00:30:08.650
because this is the new
OpenGL ES debugger in Xcode.

00:30:09.840 --> 00:30:12.760
The OpenGL ES debugger in Xcode
starts from the foundation

00:30:13.010 --> 00:30:16.180
of the performance detective,
the ability to capture a frame

00:30:16.180 --> 00:30:17.980
of your running application.

00:30:18.020 --> 00:30:20.380
We enhanced it with
information about your project,

00:30:20.400 --> 00:30:24.150
your resources, and your source code,
and then integrated it seamlessly

00:30:24.420 --> 00:30:27.140
into the Xcode debugging experience.

00:30:27.370 --> 00:30:30.330
The OpenGL ES debugger gives
you access to a fully rendered

00:30:30.470 --> 00:30:32.420
frame of your application.

00:30:32.530 --> 00:30:34.910
As part of that,
you have access to all the draw and

00:30:34.980 --> 00:30:38.040
state calls that make up your frame,
and all the resources

00:30:38.100 --> 00:30:39.090
that contribute to it.

00:30:39.210 --> 00:30:42.140
All the textures, the shaders,
and the programs.

00:30:42.250 --> 00:30:46.240
And you also have full stack backtraces,
so you can seamlessly move from

00:30:46.240 --> 00:30:50.010
the code you've written to what's
rendered on screen and back.

00:30:50.310 --> 00:30:55.800
and David We've added two
OpenGL ES extensions to allow you to

00:30:55.800 --> 00:30:59.240
take concepts from your application
and surface them directly

00:30:59.270 --> 00:31:01.200
in the debugging experience.

00:31:01.200 --> 00:31:05.020
The first is the ability to
label your OpenGL resources.

00:31:05.020 --> 00:31:07.090
So in addition to referring
to them by index number,

00:31:07.090 --> 00:31:11.760
you can also refer to them by a
meaningful name like moon surface.

00:31:11.940 --> 00:31:16.680
The second is the ability to annotate
the OpenGLS stream with markers.

00:31:16.790 --> 00:31:20.890
Now these markers give you the ability
to take a set of draw and state calls,

00:31:20.960 --> 00:31:24.760
and service them in the debugger by the
concept that they impart to your frame.

00:31:24.890 --> 00:31:30.610
So things like planet, enemy fighter,
explosion, or mother-in-law.

00:31:31.080 --> 00:31:35.280
So I'd love to give you a demonstration
now of the OpenGL ES debugger in Xcode,

00:31:35.280 --> 00:31:38.740
and show you how it can
maybe save the world.

00:31:41.180 --> 00:31:45.600
So we're going to transition over
here to the Touch Fighter application.

00:31:45.680 --> 00:31:48.660
What you'll be seeing on screen here is,
this is the Touch Fighter application

00:31:48.660 --> 00:31:50.770
Jon started on with his storyboard.

00:31:50.960 --> 00:31:54.160
I had the rewarding task of
implementing the OpenGL game.

00:31:54.250 --> 00:31:55.890
So you'll see that when
I click single player,

00:31:56.060 --> 00:31:57.900
we've now transitioned into our game.

00:31:57.900 --> 00:31:59.340
And it's running here on our iPad.

00:31:59.340 --> 00:32:02.100
I can fire some lasers here.

00:32:02.100 --> 00:32:04.860
Now this is your kind of standard
space-faring application.

00:32:04.940 --> 00:32:08.440
You are the last line of defense for
an unsuspecting planet kind of thing.

00:32:08.490 --> 00:32:11.220
And you can see that as we
look at the different elements,

00:32:11.220 --> 00:32:14.440
there's the planet in the foreground,
the mothership in the background,

00:32:14.450 --> 00:32:17.000
and then some enemy fighters in my ship.

00:32:17.050 --> 00:32:19.460
Now looking at the screen here,
we can actually see a problem

00:32:19.460 --> 00:32:22.010
right out of the gate,
which is the upper two wings

00:32:22.010 --> 00:32:23.980
for my ship are drawn in black.

00:32:24.020 --> 00:32:27.980
I'm actually expecting those to have
the same texture as the lower wing.

00:32:28.050 --> 00:32:30.760
So there's clearly a
problem for us to solve.

00:32:30.840 --> 00:32:34.800
Let's see how we can use Xcode
to find and fix this issue.

00:32:34.860 --> 00:32:38.400
So let's transition over to
looking at our Xcode project.

00:32:38.400 --> 00:32:42.490
And here we see the Xcode project
for the Touch Fighter application.

00:32:42.500 --> 00:32:45.250
I need to clarify that what
you're seeing here is a feature

00:32:45.250 --> 00:32:47.080
of modern projector technology.

00:32:47.080 --> 00:32:51.490
So this is the iPad projected
picture in picture on top of Xcode.

00:32:53.400 --> 00:32:56.210
Come on, it's going to get better.

00:32:56.280 --> 00:32:58.260
So here we are in our Xcode project.

00:32:58.260 --> 00:33:00.120
Now if I were going to
debug this normally,

00:33:00.120 --> 00:33:02.760
what I would probably do is seek
out the class for my spaceship,

00:33:02.760 --> 00:33:05.600
which I have here,
and then find the method that starts

00:33:05.600 --> 00:33:07.560
rendering it and just put a break point.

00:33:07.560 --> 00:33:09.500
So we'll do that here.

00:33:09.500 --> 00:33:12.680
And you'll see that Xcode seamlessly
transitions into the debugger.

00:33:12.680 --> 00:33:15.690
And now I'm seeing the stackback trace,
and I can use the standard debugging

00:33:15.690 --> 00:33:19.770
affordances to get information
about how my program is working.

00:33:19.860 --> 00:33:22.360
But for something like OpenGL,
I really want more context.

00:33:22.360 --> 00:33:24.530
I want the full view of what's going on.

00:33:24.580 --> 00:33:27.960
And looking at it as a single moment
in time isn't really very helpful.

00:33:28.010 --> 00:33:32.750
So let's transition into using
the full Xcode OpenGL ES debugger.

00:33:32.850 --> 00:33:35.090
I'm going to remove my
breakpoint and continue.

00:33:35.160 --> 00:33:37.100
And to start using the
OpenGL ES debugger,

00:33:37.100 --> 00:33:40.610
we first need to capture a frame
of our running application.

00:33:40.740 --> 00:33:42.940
To do that,
I'm going to use a new button that's down

00:33:42.950 --> 00:33:44.880
here in the debug bar to capture a frame.

00:33:45.180 --> 00:33:46.930
It's a little camera icon.

00:33:47.050 --> 00:33:49.360
And you'll see that I'm going
to click this button here,

00:33:49.410 --> 00:33:51.840
and Xcode's going to transition
into taking a capture,

00:33:51.920 --> 00:33:54.800
and then bring that content
directly into the debugger.

00:33:54.880 --> 00:33:55.360
So here we are.

00:33:55.540 --> 00:33:58.520
This is our OpenGL frame
inside of the debugger.

00:33:58.580 --> 00:34:02.050
Now, the debug navigator has switched to
showing us information about our frame.

00:34:02.160 --> 00:34:04.750
All of the state, draw, and marker calls.

00:34:04.760 --> 00:34:07.250
And the editor is now showing
us the rendered view of the

00:34:07.250 --> 00:34:09.420
frame at a moment in time.

00:34:09.420 --> 00:34:12.140
Now, it's showing me actually
the last view of my frame.

00:34:12.190 --> 00:34:15.660
But I can select any earlier
point in the debug navigator,

00:34:15.660 --> 00:34:19.780
like Skybox here,
and we'll transition to an earlier point.

00:34:19.780 --> 00:34:23.380
Now, I selected on Skybox over here,
and it's one of these yellow folders.

00:34:23.380 --> 00:34:25.980
That's one of the markers
I mentioned before.

00:34:25.980 --> 00:34:28.460
I've gone through and annotated
the TouchFighter application

00:34:28.460 --> 00:34:32.960
with markers to delineate all the
elements that contribute to my frame.

00:34:32.960 --> 00:34:35.550
Now, in addition to making it really
easy for me to select one,

00:34:35.560 --> 00:34:39.740
it actually shows me a high-level
overview of how my frame is constructed.

00:34:40.220 --> 00:34:43.430
If I select the next element, stars,
you'll see that we actually transition

00:34:43.430 --> 00:34:45.870
to showing the stars in the editor.

00:34:45.930 --> 00:34:48.680
Now, the green wireframe here is actually
highlighting the elements that are

00:34:48.680 --> 00:34:51.350
drawn just at this moment in time.

00:34:51.400 --> 00:34:54.700
I can use the context menu and
hide the wireframe if we wanted

00:34:54.700 --> 00:34:56.960
to see the direct details.

00:34:57.600 --> 00:35:00.010
Moving along,
if I take the planet section here in

00:35:00.050 --> 00:35:03.170
the debug navigator and expand it,
you'll see there are a number of elements

00:35:03.200 --> 00:35:05.740
that contribute to drawing the planet.

00:35:05.860 --> 00:35:07.940
The blue cubes are the state calls.

00:35:07.940 --> 00:35:10.260
These are the things that set
up when I'm about to draw.

00:35:10.260 --> 00:35:12.440
And the little spheres
are the actual draw calls,

00:35:12.510 --> 00:35:15.380
the ones that take the images
and actually put them on screen.

00:35:15.380 --> 00:35:19.230
If I select this first draw call here,
we'll see that the view

00:35:19.230 --> 00:35:21.370
updates to show us the planet.

00:35:21.870 --> 00:35:23.500
If I want to see more
information about the state,

00:35:23.570 --> 00:35:27.580
about what's going on before I draw,
I can do so by revealing the familiar

00:35:27.690 --> 00:35:30.180
affordance of the debug area.

00:35:30.480 --> 00:35:32.940
So the debug area here at the
bottom has transitioned from showing

00:35:33.130 --> 00:35:35.660
us information about variables
and registers to now showing us

00:35:35.770 --> 00:35:37.800
information about our OpenGL state.

00:35:37.910 --> 00:35:40.400
Both the global state of
the whole context and those

00:35:40.400 --> 00:35:41.950
for just the bound objects.

00:35:42.070 --> 00:35:45.180
Those are contributing just
to this moment in time.

00:35:45.280 --> 00:35:48.200
We use the familiar affordance
of highlighting elements

00:35:48.420 --> 00:35:49.700
in blue as they change.

00:35:49.820 --> 00:35:51.340
So for those of you who
are sitting close enough,

00:35:51.420 --> 00:35:54.290
you'll see as I start to move
through the debug navigator here,

00:35:54.560 --> 00:35:56.040
those items will highlight.

00:35:56.200 --> 00:35:59.200
Here we're turning off culling,
which we use to draw the planet.

00:35:59.200 --> 00:36:02.720
I've bound up a new texture for the
planet glow that we're going to draw.

00:36:02.870 --> 00:36:07.050
We're going to enable blending,
and we set up a particular

00:36:07.050 --> 00:36:08.730
function to do that.

00:36:08.730 --> 00:36:10.600
And then when I get all the
way down to the planet glow,

00:36:10.600 --> 00:36:10.600
it's going to draw on screen.

00:36:10.900 --> 00:36:12.640
So I can see exactly how that happened.

00:36:12.720 --> 00:36:15.680
I can also show the wireframe
so you can see exactly how the

00:36:15.680 --> 00:36:17.840
planet was drawn-- or the halo,
rather.

00:36:17.940 --> 00:36:21.480
Or I can switch back to the planet,
and you can see how that was drawn, too.

00:36:21.730 --> 00:36:23.770
If I want to go one
level of detail further,

00:36:23.910 --> 00:36:27.170
I can also just disclose the
item here in the Navigator and

00:36:27.170 --> 00:36:28.660
get the full stack backtrace.

00:36:28.700 --> 00:36:32.890
So I can jump right to the source
code that put this item on screen.

00:36:33.100 --> 00:36:36.310
So in one quick view that's very
familiar with the debugging experience,

00:36:36.370 --> 00:36:39.750
I've accessed a lot of
information about my GL frame.

00:36:40.780 --> 00:36:44.070
The flexibility of the Xcode workflow
allows me to change how I'm working

00:36:44.110 --> 00:36:46.140
depending on what I want to focus on.

00:36:46.290 --> 00:36:48.700
For example,
I can go up here in the toolbar and

00:36:48.700 --> 00:36:53.340
collapse the navigator completely if
I want to focus on the main view up top.

00:36:53.530 --> 00:36:56.590
Actually, the view up at the top is
showing me the buffer view.

00:36:56.820 --> 00:36:58.940
In this case,
it's showing me the color buffer.

00:36:58.940 --> 00:37:02.390
I can actually enable other buffers,
for example, seeing the depth view,

00:37:02.450 --> 00:37:05.140
or actually the stencil view, too,
if I was using it.

00:37:05.570 --> 00:37:08.160
Even in this layout,
I can use all the familiar Xcode

00:37:08.260 --> 00:37:10.400
affordances to move about my frame.

00:37:10.500 --> 00:37:12.380
For example, I'm going to grab up
here on the jump bar,

00:37:12.530 --> 00:37:15.160
and you see that it lists all the
different elements in my frame.

00:37:15.160 --> 00:37:18.160
And I could select, for example,
enemies and jump right to that section.

00:37:18.360 --> 00:37:21.080
Again, this is a value of the markers,
allowing me to pick exactly

00:37:21.180 --> 00:37:22.400
the thing I want to see.

00:37:22.400 --> 00:37:25.400
You'll see that when I select it,
we jump right to where the

00:37:25.400 --> 00:37:26.900
enemies are being drawn.

00:37:27.940 --> 00:37:31.140
Now, when I think about my OpenGL frame,
it's kind of like video,

00:37:31.140 --> 00:37:33.310
where you kind of want to
scrub through it to get to the

00:37:33.320 --> 00:37:34.520
exact point you're looking for.

00:37:34.520 --> 00:37:36.930
And we've included a
control exactly for that.

00:37:37.000 --> 00:37:40.430
There's a scrubbing control down
here in the debug bar with the rest

00:37:40.440 --> 00:37:43.550
of the controls that you'll see
as I grab it and move it about,

00:37:43.550 --> 00:37:47.730
that the frame will actually update to
show me each point in time that I'm at.

00:37:48.120 --> 00:37:50.700
And the green wireframe shows
me the highlight of what's being

00:37:50.700 --> 00:37:53.250
drawn at that point in time,
making it really easy for me to

00:37:53.250 --> 00:37:55.360
move all throughout my frame,
for example,

00:37:55.360 --> 00:37:57.920
as my fighter is being drawn here,
all the way to the end.

00:37:57.920 --> 00:38:01.510
So the scrubbing control makes it really
easy for me to move about my frame.

00:38:02.970 --> 00:38:04.990
Now, let's get back to the
problem at hand here.

00:38:05.060 --> 00:38:08.420
We see our spaceship here,
and the wings are still drawn black.

00:38:08.470 --> 00:38:11.750
Now, the wings are actually being drawn,
so I know I've done some things right.

00:38:11.870 --> 00:38:13.920
The first thing I'd want to
inspect is maybe I've not

00:38:14.000 --> 00:38:15.240
set up my texture correctly.

00:38:15.370 --> 00:38:18.220
I'm not using it to draw the upper wings.

00:38:18.320 --> 00:38:20.740
Now, to do that, I want to see more
information about my frame,

00:38:20.790 --> 00:38:23.760
and I'm going to leverage
the Xcode Assistant to do so.

00:38:23.820 --> 00:38:26.820
I'm going to focus back on
just the color buffer here.

00:38:26.870 --> 00:38:30.180
And you'll see as I enable the
Xcode Assistant in the toolbar,

00:38:30.240 --> 00:38:33.250
the editor splits and now shows
me information about the current

00:38:33.250 --> 00:38:34.760
frame and about the resources.

00:38:35.020 --> 00:38:37.750
In this case, the Assistant is showing
me the bound resources.

00:38:37.820 --> 00:38:40.970
Those are contributing
at this moment in time.

00:38:41.360 --> 00:38:43.860
I could change the Assistant to
show other content by

00:38:44.010 --> 00:38:45.250
selecting a different category.

00:38:45.440 --> 00:38:47.480
For example,
here's the All Objects category.

00:38:47.650 --> 00:38:51.140
So these are all the resources that
contribute anywhere throughout my frame,

00:38:51.330 --> 00:38:55.690
making it really easy for me to get a
high-level overview of what I'm using.

00:38:56.050 --> 00:38:58.560
I can double click on any
item to get more details.

00:38:58.620 --> 00:39:00.300
For example,
here's the texture that's being

00:39:00.390 --> 00:39:02.520
used to draw the space background.

00:39:02.520 --> 00:39:06.090
Here's the texture that's being used
to draw the planet that we see below.

00:39:06.300 --> 00:39:10.240
And I can even look at information
like shaders and programs to inspect

00:39:10.240 --> 00:39:12.630
how they're affecting my frame.

00:39:13.520 --> 00:39:15.860
If we go back here,
and we'll take a look at the texture

00:39:15.860 --> 00:39:17.830
that's being used to draw my spaceship.

00:39:18.110 --> 00:39:19.640
I've selected it here.

00:39:19.640 --> 00:39:22.040
I can actually use the controls down
at the bottom of the editor here

00:39:22.040 --> 00:39:23.840
to help me get a different view.

00:39:23.900 --> 00:39:25.840
We'll rotate this around a
little bit to see better.

00:39:25.840 --> 00:39:28.750
And if I had multiple
representations of this image,

00:39:28.810 --> 00:39:32.470
a technique called mipmaps,
I could pick the different level here,

00:39:32.470 --> 00:39:33.750
but I only have one.

00:39:33.790 --> 00:39:36.080
Now, this item up here,
this dark gray wing,

00:39:36.080 --> 00:39:37.780
is the one I expect to be drawn.

00:39:37.920 --> 00:39:41.410
So I at least know from here that
I've got my texture set up correctly.

00:39:41.520 --> 00:39:42.740
Maybe I've not bounded up correctly.

00:39:42.740 --> 00:39:48.010
So let's go back to the bound
objects category in the Assistant and

00:39:48.150 --> 00:39:50.330
see how this can help me.

00:39:50.990 --> 00:39:54.500
Because the Assistant Editor shows you
content that's related to what you're

00:39:54.500 --> 00:39:57.140
looking at in the primary editor,
and we know that this editor

00:39:57.140 --> 00:39:59.900
shows us moments in time,
you'll see that as I use the

00:40:00.000 --> 00:40:04.020
familiar controls to step backwards,
in this case, through my frame,

00:40:04.020 --> 00:40:08.000
that the bound objects actually update
to show me what I'm using at this time.

00:40:08.020 --> 00:40:10.640
Now you'll see the 60,
which is the frames per second.

00:40:10.640 --> 00:40:12.790
As I step back,
we now have the texture that's

00:40:12.800 --> 00:40:15.610
being used to draw the explosion,
the one that's being used

00:40:15.710 --> 00:40:17.800
to draw the afterburner,
and now I'm into the

00:40:17.900 --> 00:40:19.460
segment drawing the wing.

00:40:20.330 --> 00:40:22.640
So just like this,
I can actually get a really

00:40:22.640 --> 00:40:25.900
quick view of how my frame is
being set up and what I'm using.

00:40:26.100 --> 00:40:28.330
Now, as you see here,
as I click back through the

00:40:28.330 --> 00:40:31.140
parts that's drawing my wing,
we actually do see my texture

00:40:31.140 --> 00:40:32.700
bound correctly up here.

00:40:32.830 --> 00:40:36.080
So I have set it up correctly there,
but it's still not drawing.

00:40:36.190 --> 00:40:37.730
Something else is not going right.

00:40:37.770 --> 00:40:39.740
So I need to investigate further.

00:40:39.740 --> 00:40:43.980
The next thing I would probably check is,
am I using my texture correctly?

00:40:43.980 --> 00:40:46.070
So to look at that,
I'm going to expand the

00:40:46.200 --> 00:40:49.620
state view down here,
and look at the details for my texture.

00:40:49.620 --> 00:40:52.150
And I can actually see the problem.

00:40:52.660 --> 00:40:54.720
As I'm looking at the
details for my texture,

00:40:54.720 --> 00:40:57.690
I see that I've bound up a filter
that's expecting to use mipmaps,

00:40:57.690 --> 00:41:00.410
those multiple representations
I mentioned before.

00:41:00.420 --> 00:41:04.310
In this case, I know I'm not using those,
and my textures don't actually have them,

00:41:04.310 --> 00:41:06.130
so that's why it's drawing in black.

00:41:06.190 --> 00:41:09.020
So somewhere in source code,
I've not set this up correctly.

00:41:11.790 --> 00:41:14.170
The OpenGL ES debugger can
actually show us the line of source

00:41:14.210 --> 00:41:15.730
code that caused this problem.

00:41:15.820 --> 00:41:18.200
And to do so,
I'm going to add another assistant

00:41:18.200 --> 00:41:21.810
editor by clicking the check the
plus sign up here in the editor.

00:41:21.920 --> 00:41:24.100
And I'll make myself some more room.

00:41:24.190 --> 00:41:26.870
Now, in this case,
instead of looking at resources,

00:41:26.870 --> 00:41:29.170
I'm going to change
the category to stack.

00:41:29.370 --> 00:41:31.830
And now we see that right here,
this is the line of source code that

00:41:31.830 --> 00:41:34.020
actually drew the element on the screen.

00:41:34.100 --> 00:41:36.840
So in one full view,
we have what's on the screen,

00:41:36.880 --> 00:41:39.440
the resources being used,
the state that it's in,

00:41:39.570 --> 00:41:41.210
and the code that's causing it.

00:41:41.290 --> 00:41:43.810
And of course,
like you'd expect from a debugger,

00:41:43.810 --> 00:41:47.410
as I step through, it's showing me all of
these items in concert.

00:41:53.800 --> 00:41:55.780
So we can see when we get
to this moment in time,

00:41:55.810 --> 00:41:58.800
the filter is now blue,
which says that it's been changed.

00:41:58.870 --> 00:42:00.560
And sure enough,
here's the line of source

00:42:00.620 --> 00:42:02.000
code that caused the problem.

00:42:02.070 --> 00:42:04.010
This really should be GL linear.

00:42:04.110 --> 00:42:07.100
And once I save that,
that should fix my problem.

00:42:07.190 --> 00:42:09.560
So very quickly with
the Open GLS debugger,

00:42:09.580 --> 00:42:13.630
I was able to jump into my application,
find the spot I was looking for,

00:42:13.630 --> 00:42:16.620
investigate resources, state,
and source code,

00:42:16.620 --> 00:42:18.130
and find and fix my issue.

00:42:18.590 --> 00:42:20.700
It's just that simple.

00:42:22.280 --> 00:42:23.990
As an engineer,
it's really gratifying when you

00:42:23.990 --> 00:42:25.700
can find the source of your issue.

00:42:25.800 --> 00:42:27.340
As a manager,
you like to hold celebration

00:42:27.340 --> 00:42:28.840
until you're sure it works.

00:42:28.940 --> 00:42:31.960
So, what we're going to do here is
stop our running application,

00:42:31.960 --> 00:42:35.890
and let's relaunch it to make sure
that we actually fix the problem.

00:42:36.300 --> 00:42:40.170
Now, we worked really hard to make sure
that the OpenGL ES debugging experience

00:42:40.490 --> 00:42:42.250
just felt like the regular debugger.

00:42:42.350 --> 00:42:44.770
Like, there was no special magic.

00:42:45.110 --> 00:42:47.550
The first time I did a capture,
I clicked the Manulate

00:42:47.550 --> 00:42:49.040
button in the debug bar.

00:42:49.090 --> 00:42:51.310
What I want to show you is another
trick to allow you to get this

00:42:51.360 --> 00:42:52.910
capture a little bit easier.

00:42:52.980 --> 00:42:54.400
To do that,
I'm going to add the breakpoint

00:42:54.460 --> 00:42:56.180
back that I've created initially.

00:42:56.290 --> 00:42:58.350
And in this case, I'm going to edit it.

00:42:58.420 --> 00:43:00.580
I'll bring up the editor
with the context menu.

00:43:00.750 --> 00:43:03.050
And now this is the breakpoint editor.

00:43:03.210 --> 00:43:05.580
Now, this argument here,
time to this function,

00:43:05.580 --> 00:43:08.270
is actually the overall
time elapsed in the game.

00:43:08.340 --> 00:43:11.620
So I'm going to set a condition here
that says time is greater than four.

00:43:11.810 --> 00:43:14.800
So after four seconds,
this breakpoint is going to get hit.

00:43:14.860 --> 00:43:16.980
And when it does,
I want it to trigger an action.

00:43:17.040 --> 00:43:20.600
And in this case,
I want it to capture an OpenGL frame.

00:43:20.660 --> 00:43:24.830
So now you'll see that as I click the
single player button here on my iPad,

00:43:24.840 --> 00:43:25.860
that the game is going to play.

00:43:25.900 --> 00:43:29.280
And after four seconds,
I trust it enough to walk away,

00:43:29.550 --> 00:43:31.050
you'll see that the
capture is going to start.

00:43:31.300 --> 00:43:32.820
Xcode is going to capture a frame.

00:43:32.860 --> 00:43:35.910
And sure enough, we fixed our problem.

00:43:43.100 --> 00:43:45.090
So that's the
OpenGL ES Debugger in Xcode.

00:43:45.130 --> 00:43:46.510
I hope you guys enjoy using it.

00:43:46.690 --> 00:43:48.530
Back to you, Andreas.

00:43:53.090 --> 00:43:57.750
Thank you, Matt,
for showing us the OpenGL debugger.

00:43:57.830 --> 00:44:00.680
Let me now also give you an
overview of our CPU debuggers.

00:44:00.790 --> 00:44:04.180
Last year here at the conference,
we announced our new low-level debugger,

00:44:04.180 --> 00:44:05.370
LLDB.

00:44:05.450 --> 00:44:07.440
This is a brand new debugging
infrastructure that,

00:44:07.440 --> 00:44:10.950
just like our compiler, LLVM,
is designed with a strong focus

00:44:11.470 --> 00:44:15.780
on performance and the ability to
integrate it well into the IDE.

00:44:16.350 --> 00:44:19.360
In Xcode 4 in March,
we already made LLDB available as

00:44:19.440 --> 00:44:21.340
a debugger for Mac applications.

00:44:21.520 --> 00:44:23.970
In our next release of Xcode,
we're going to add

00:44:24.060 --> 00:44:25.450
support for iOS as well.

00:44:25.540 --> 00:44:28.470
So you can now debug
your iOS applications,

00:44:28.470 --> 00:44:33.320
whether you're running natively
on the device or in the simulator.

00:44:33.670 --> 00:44:36.640
LLDB is the future of
our debugging technology.

00:44:36.670 --> 00:44:39.460
It's going to replace GDB in
the not-too-distant future.

00:44:39.460 --> 00:44:42.260
And we'd actually love to hear
what your experience with it is.

00:44:44.520 --> 00:44:49.200
Now, LLDB is also an open source project
that we publish under the LLDM umbrella.

00:44:49.370 --> 00:44:52.330
And that finally brings
me to our compiler story.

00:44:52.540 --> 00:44:56.270
Until several years ago,
we relied on GCC as our compiler for

00:44:56.310 --> 00:44:58.400
both the Mac and the iOS platforms.

00:44:58.510 --> 00:45:01.900
But today, our compiler of choice is,
of course, LLVM.

00:45:01.930 --> 00:45:05.270
And with iOS 5, we're preparing the next
major release of it,

00:45:05.480 --> 00:45:08.200
our LLVM compiler version 3.

00:45:09.270 --> 00:45:14.380
LLVM is designed for speed, flexibility,
and modularity.

00:45:14.540 --> 00:45:18.000
It compiles code about
twice as fast as GCC.

00:45:18.050 --> 00:45:21.980
And at the same time,
it creates better and faster code.

00:45:22.550 --> 00:45:25.300
LLVM is also the compiler
that's integrated into the

00:45:25.300 --> 00:45:27.930
IDE for features like Fixit.

00:45:28.250 --> 00:45:31.760
and LLVM is the only compiler in
which we implement support for new

00:45:31.760 --> 00:45:35.560
language features we are developing,
like C++ or X.

00:45:35.560 --> 00:45:39.590
So LLVM

00:45:41.800 --> 00:45:43.800
and the rest of the team.

00:45:43.840 --> 00:45:45.800
And now, let's talk about the next step.

00:45:45.800 --> 00:45:47.800
LLVM is now a very mature
and proven compiler.

00:45:47.800 --> 00:45:51.800
We've actually switched all our internal
products over to building with LLVM.

00:45:51.800 --> 00:45:55.740
That includes the builds
of Mac OS X Lion and iOS 5.

00:45:55.800 --> 00:46:00.290
And so with that,
the time for GCC is coming to an end.

00:46:02.000 --> 00:46:05.040
Starting with Xcode 4.2,
we're not going to be including

00:46:05.040 --> 00:46:06.490
a version of GCC anymore.

00:46:06.610 --> 00:46:09.200
It's going to be entirely
replaced with LLVM,

00:46:09.200 --> 00:46:12.490
and our compiler
transition is now complete.

00:46:18.200 --> 00:46:20.450
When you switch compilers to LLVM,
you actually get the

00:46:20.560 --> 00:46:21.720
choice of two compilers.

00:46:21.730 --> 00:46:24.530
The recommended choice
is of course LLVM3.

00:46:24.640 --> 00:46:28.040
It's our fastest and most
standards-compliant compiler.

00:46:28.060 --> 00:46:31.130
But for compatibility reasons,
we are still including

00:46:31.130 --> 00:46:33.640
a version of LLVM GCC,
which shares the front end,

00:46:33.640 --> 00:46:36.440
so the parser of the compiler,
with the older GCC,

00:46:36.440 --> 00:46:39.720
and so it's fully source compatible,
even if it doesn't implement the

00:46:39.770 --> 00:46:41.550
latest language features anymore.

00:46:42.790 --> 00:46:45.190
So we're obviously putting
a lot of energy behind LLVM.

00:46:45.340 --> 00:46:48.450
And we've taken it from a research
project to a mature compiler

00:46:48.450 --> 00:46:50.160
product in just a few years.

00:46:50.220 --> 00:46:54.350
It has become the basis of many
fantastic features in our tools.

00:46:54.480 --> 00:46:57.800
And now we're going to use
it for our next big thing.

00:46:58.550 --> 00:47:01.730
So many of you have told us that
at the top of your wish list of

00:47:01.850 --> 00:47:06.810
things we could do for you is bring
a garbage collection to the iOS.

00:47:06.940 --> 00:47:10.590
And that's exactly what
we are not going to do.

00:47:15.480 --> 00:47:17.400
So instead,
we're going to do something much better.

00:47:17.400 --> 00:47:18.900
It's going to take a
few moments to explain.

00:47:19.130 --> 00:47:22.000
Let me start by comparing the
advantages and disadvantages of

00:47:22.060 --> 00:47:26.660
garbage collection to manual memory
management with retained release calls.

00:47:27.490 --> 00:47:29.570
So garbage collection makes
it more straightforward and

00:47:29.640 --> 00:47:30.900
easy to write your code.

00:47:31.010 --> 00:47:33.950
And it also tends to reside
in more stable applications,

00:47:33.990 --> 00:47:36.100
simply because you don't have
to deal with a whole category

00:47:36.260 --> 00:47:39.340
of pointer problems anymore,
like over-releasing objects,

00:47:39.460 --> 00:47:41.030
which can lead to crashes.

00:47:41.730 --> 00:47:43.540
But unfortunately,
garbage collection has an

00:47:43.540 --> 00:47:46.200
optimal impact on performance.

00:47:46.340 --> 00:47:48.750
Garbage can build up in your
applications and increase the high

00:47:48.750 --> 00:47:50.600
watermark of your memory usage.

00:47:50.700 --> 00:47:53.890
And the collector tends to kick
in at undeterministic times,

00:47:54.000 --> 00:47:58.600
which can lead to very high CPU usage
and stutters in the user experience.

00:47:58.780 --> 00:48:02.060
And that's why garbage collection
has not been acceptable to

00:48:02.060 --> 00:48:03.870
us on our mobile platforms.

00:48:04.870 --> 00:48:07.210
In comparison,
manual memory management with

00:48:07.210 --> 00:48:12.730
retainer release is harder to learn,
and quite frankly,

00:48:12.730 --> 00:48:12.730
it's a bit of a pain in the ass.

00:48:13.650 --> 00:48:18.020
But it produces better and
more predictable performance.

00:48:18.120 --> 00:48:21.300
And that's why we have chosen it as the
basis for our memory management strategy.

00:48:21.300 --> 00:48:24.300
Because out there in the real world,
high performance and

00:48:24.300 --> 00:48:28.600
stutter-free user experiences
are what matters to our users.

00:48:29.440 --> 00:48:32.220
But wouldn't it be nice if you
could somehow get the best of both

00:48:32.220 --> 00:48:35.440
worlds and come up with a single
strategy that combines all the

00:48:35.440 --> 00:48:38.300
advantages of these two approaches?

00:48:38.470 --> 00:48:41.300
And that's exactly what
we are going to do.

00:48:41.320 --> 00:48:44.270
With LVM3, we are going to introduce
automatic reference counting,

00:48:44.330 --> 00:48:46.300
or in short form, ARC.

00:48:46.360 --> 00:48:50.030
To tell you more about it,
I'm going to hand over to Chris Lattner.

00:48:57.310 --> 00:48:58.880
Thank you, Andreas.

00:48:58.980 --> 00:49:02.160
So Arc is based on a really simple idea.

00:49:02.210 --> 00:49:05.080
Let's take all the advantages of
retain and release programming

00:49:05.960 --> 00:49:08.880
without those little disadvantages,
like having to actually

00:49:08.880 --> 00:49:10.630
call retain and release.

00:49:11.320 --> 00:49:13.980
So to do this,
we're taking memory management

00:49:14.040 --> 00:49:16.200
and pulling it into Objective-C,
the language.

00:49:16.200 --> 00:49:18.200
Well, what does that mean?

00:49:18.200 --> 00:49:21.200
Well, that means primarily that retain
and release are just going away.

00:49:21.200 --> 00:49:27.190
You don't have to worry
about this anymore.

00:49:27.190 --> 00:49:27.190
Now,

00:49:27.340 --> 00:49:32.580
This means that the compiler is in
charge of the tedious and error-prone

00:49:32.580 --> 00:49:36.040
work of manually managing your memory,
so you don't have to do that anymore.

00:49:36.080 --> 00:49:39.000
The compiler is really
good at tedious things,

00:49:39.410 --> 00:49:39.440
right?

00:49:39.700 --> 00:49:43.870
But how does the compiler know where
your retains and releases need to go?

00:49:44.230 --> 00:49:47.050
As Craig helpfully
pointed out earlier on,

00:49:47.050 --> 00:49:49.850
for about two years now,
we have been developing this tool

00:49:49.890 --> 00:49:51.350
called the Xcode Static Analyzer.

00:49:51.360 --> 00:49:55.740
The analyzer is a fantastic tool
that uses deep compiler analysis

00:49:55.740 --> 00:49:59.080
to walk through paths in your
program and try to find bugs.

00:49:59.080 --> 00:50:01.060
It finds all kinds of bugs.

00:50:01.060 --> 00:50:02.840
It finds all kinds of crashers.

00:50:02.900 --> 00:50:04.980
You can dereference bad pointers.

00:50:04.980 --> 00:50:09.330
One of the most common kinds of
problems that the static analyzer

00:50:09.370 --> 00:50:11.840
finds is memory management bugs.

00:50:12.560 --> 00:50:16.220
So with Arc,
we're taking one gigantic leap

00:50:16.220 --> 00:50:19.450
beyond the static analyzer,
building this technology

00:50:19.450 --> 00:50:22.080
directly into the compiler,
and having the compiler

00:50:22.080 --> 00:50:24.770
automatically synthesize,
retain, and release for you.

00:50:24.860 --> 00:50:26.210
It's that simple.

00:50:26.260 --> 00:50:29.410
So let's talk about how the
analyzer looks at your example.

00:50:30.860 --> 00:50:34.400
So here we have some code,
has no retain or release in it, right?

00:50:34.560 --> 00:50:38.230
Well, it starts by saying, okay,
I see you're allocating a string,

00:50:38.230 --> 00:50:41.350
and a string alloc returns
ownership of an object.

00:50:41.730 --> 00:50:43.320
Well, then you pass it to init.

00:50:43.500 --> 00:50:45.430
And it just returns the object.

00:50:45.720 --> 00:50:46.840
You pass it down as log.

00:50:46.840 --> 00:50:48.750
And this log doesn't
really do anything to it.

00:50:48.860 --> 00:50:51.000
But wait,
you just return from your function,

00:50:51.020 --> 00:50:53.460
and you haven't deallocated that object,
right?

00:50:53.510 --> 00:50:54.710
There's nothing that points to it.

00:50:55.030 --> 00:50:56.470
There's an object that's been lost.

00:50:56.470 --> 00:50:59.160
And the analyzer says, hey, whoa,
you've got a bug.

00:50:59.160 --> 00:51:00.660
Why don't you go fix this?

00:51:01.510 --> 00:51:04.270
Well, now with Arc,
you just don't have to do that anymore.

00:51:04.270 --> 00:51:08.570
So what does it mean to build
memory management into the language?

00:51:08.570 --> 00:51:12.310
Well, retain, release, and auto-release,
those are going away.

00:51:12.310 --> 00:51:14.320
Don't worry about those, right?

00:51:14.320 --> 00:51:15.770
I hope you're not too sad.

00:51:15.770 --> 00:51:17.960
I mean, maybe you're attached to them.

00:51:17.960 --> 00:51:20.170
I can't really help you out with that.

00:51:20.230 --> 00:51:22.770
I mean, you can choose not to
use Arc if you want to,

00:51:22.770 --> 00:51:24.630
but you really should just use it.

00:51:24.700 --> 00:51:28.620
But what does that mean for a
good friend NS Auto-Release Pool?

00:51:28.680 --> 00:51:32.860
Well, I'm happy to say with Arc,
the number of times you have

00:51:32.860 --> 00:51:36.710
to use explicit auto-release
pools has been greatly reduced.

00:51:36.720 --> 00:51:37.780
Okay.

00:51:37.780 --> 00:51:40.530
Arc generally doesn't require you
to deal with this unless you're

00:51:40.550 --> 00:51:44.310
dealing with some frameworks that are
generating lots of auto-release garbage.

00:51:44.360 --> 00:51:48.000
In the case that you do want to use one,
we're pulling it directly into

00:51:48.000 --> 00:51:54.090
the language with a direct syntax
for defining a block statement

00:51:54.410 --> 00:51:56.510
for an auto-release pool.

00:52:02.700 --> 00:52:06.020
This is much easier, more natural,
and a lot faster than

00:52:06.020 --> 00:52:07.150
NSObd release pool was.

00:52:07.160 --> 00:52:11.860
Now, if you've gotten past the trouble of
actually calling retain and release,

00:52:12.190 --> 00:52:14.380
there is still one more problem
which you may have run into,

00:52:14.460 --> 00:52:15.820
and that's retain cycles.

00:52:15.840 --> 00:52:17.750
So let's talk about those next.

00:52:17.760 --> 00:52:21.620
And to explain what a retain cycle is,
let's just look at one really quickly.

00:52:21.620 --> 00:52:23.360
So here we have three objects.

00:52:23.460 --> 00:52:25.810
We have an application object,
we have a window object,

00:52:25.810 --> 00:52:27.810
we have a view object,
and they're all connected

00:52:27.880 --> 00:52:29.520
together with retain properties.

00:52:29.860 --> 00:52:33.300
So our app points to our window,
our window points to our view, and oops,

00:52:33.410 --> 00:52:35.480
our view is connected back to our window.

00:52:35.480 --> 00:52:38.710
Maybe we added an outlet to our
nib and just connected it up

00:52:38.710 --> 00:52:40.630
and didn't think about this.

00:52:40.760 --> 00:52:42.830
Well, what's the problem?

00:52:42.840 --> 00:52:44.970
Well,
each of these objects has a retain count,

00:52:45.000 --> 00:52:45.490
right?

00:52:45.610 --> 00:52:47.680
So that window has two
pointers pointing to it,

00:52:47.680 --> 00:52:49.080
and its retain count's two.

00:52:50.530 --> 00:52:53.540
Now, when I close the window
for my application,

00:52:53.570 --> 00:52:55.650
the app drops its
reference to that window,

00:52:55.650 --> 00:52:56.980
and its retain count drops to one.

00:52:57.020 --> 00:52:59.900
Now, you'd expect that all those
objects would go away,

00:52:59.900 --> 00:53:00.430
right?

00:53:00.610 --> 00:53:02.170
Well, unfortunately,
there's still a retain

00:53:02.170 --> 00:53:05.360
count on both of them,
so neither of them get deallocated,

00:53:05.360 --> 00:53:06.950
so we have a memory leak.

00:53:07.060 --> 00:53:08.870
Well, this is a pretty bad bug.

00:53:08.880 --> 00:53:09.790
You know, you're leaking memory.

00:53:09.820 --> 00:53:12.860
Oh, well, is it really that bad, though?

00:53:12.860 --> 00:53:14.700
I mean, you're leaking two objects.

00:53:14.700 --> 00:53:15.940
Is it that big of a deal?

00:53:16.560 --> 00:53:20.420
The big problem with retain cycles is
not these two objects you just leaked,

00:53:20.510 --> 00:53:22.950
but, you know,
these two objects may point

00:53:22.950 --> 00:53:24.480
to megabytes of other objects.

00:53:24.570 --> 00:53:27.030
It may point to your document,
and who knows what that points to, right?

00:53:27.220 --> 00:53:29.370
And all of those objects
are transitively leaked.

00:53:29.540 --> 00:53:33.310
Retain cycles can be one of the
nastiest causes and problems with

00:53:33.470 --> 00:53:35.880
memory leaks that you can have,
right?

00:53:35.880 --> 00:53:39.220
Well, I'm pleased to say that,
in addition to introducing Arc,

00:53:39.220 --> 00:53:42.260
we're tackling this problem
head-on with the introduction

00:53:42.260 --> 00:53:44.000
of zeroing weak references.

00:53:44.000 --> 00:53:45.580
And let me tell you about that.

00:53:48.500 --> 00:53:51.080
Zeroing weak references,
you can think of kind of

00:53:51.170 --> 00:53:54.040
like a non-retained IVAR.

00:53:54.150 --> 00:53:57.160
So they're very similar
to a non-retained IVAR,

00:53:57.160 --> 00:53:58.650
but a heck of a lot safer.

00:53:58.860 --> 00:54:00.240
And let me show you why.

00:54:00.330 --> 00:54:03.350
So just like a non-retained IVAR,
you can see that the weak pointer

00:54:03.360 --> 00:54:07.360
that I've replaced the back edge
of my graph with is not increasing

00:54:07.360 --> 00:54:09.340
the retain count in my window.

00:54:09.410 --> 00:54:13.800
And so when I close my window,
its retain count drops to zero.

00:54:14.060 --> 00:54:14.960
Wait a second.

00:54:14.990 --> 00:54:18.110
Automatically, transparently,
and completely safely,

00:54:18.420 --> 00:54:20.050
that weak reference just dropped to nil.

00:54:20.110 --> 00:54:21.980
I didn't have to do
anything with my code,

00:54:21.980 --> 00:54:24.630
it just dropped to nil,
making it impossible for me to

00:54:24.630 --> 00:54:26.480
dereference a dangling pointer.

00:54:26.480 --> 00:54:29.620
This takes the second major
cause of crashes from your

00:54:29.630 --> 00:54:31.820
applications and defines it away.

00:54:39.450 --> 00:54:41.740
Now, of course,
that window has a retain count of zero,

00:54:41.740 --> 00:54:43.560
so it gets deallocated.

00:54:43.560 --> 00:54:45.130
Your view gets deallocated.

00:54:45.300 --> 00:54:48.170
Your document and everything else that's
reachable from those things is now gone,

00:54:48.170 --> 00:54:48.580
right?

00:54:48.580 --> 00:54:50.180
And so we've solved our problem.

00:54:50.260 --> 00:54:53.960
So we think that between
Arc and zeroing weak references,

00:54:53.960 --> 00:54:57.430
we've taken some of the most
common classes of leaks and

00:54:57.430 --> 00:55:02.200
crashes from your application and
have completely defined them away.

00:55:02.250 --> 00:55:04.320
We think this is a fantastic result.

00:55:05.340 --> 00:55:08.200
Now, we're so excited about this,
we've actually converted all

00:55:08.200 --> 00:55:11.200
the new project templates in
Xcode 4.2 to default to Arc.

00:55:11.200 --> 00:55:13.970
That means that if you create a new app,
you've already got Arc.

00:55:13.970 --> 00:55:15.430
You don't have anything to do.

00:55:16.930 --> 00:55:20.180
But wait,
how many of you already have apps?

00:55:20.200 --> 00:55:21.800
Maybe one or two of you, right?

00:55:21.800 --> 00:55:23.420
Well, so what do you do?

00:55:23.540 --> 00:55:27.740
Well, I'm pleased to say you just start
over again and write a whole new app.

00:55:30.000 --> 00:55:33.990
You can use the fancy new
Xcode Arc Migration Tool,

00:55:33.990 --> 00:55:40.870
which is built right into Xcode 4.2.

00:55:44.620 --> 00:55:49.630
The Xcode Arc Migration Tool works
automatically to move your application

00:55:49.630 --> 00:55:51.460
to Arc through three steps.

00:55:51.650 --> 00:55:53.490
The first step is to scan your issues.

00:55:53.600 --> 00:55:56.730
Now, it's an automatic tool,
but it's not complete magic,

00:55:56.730 --> 00:55:59.570
and so it can handle almost everything,
but there are some tricky

00:55:59.650 --> 00:56:00.600
cases it can't handle.

00:56:00.600 --> 00:56:03.410
If there's a tricky case it can't handle,
it tells you about it and

00:56:03.410 --> 00:56:04.410
asks you to help it out.

00:56:04.600 --> 00:56:07.440
Assuming that's not a problem, then,
it goes through and actually

00:56:07.440 --> 00:56:08.600
rewrites all your code.

00:56:08.600 --> 00:56:12.150
So all those retains and releases,
a whole bunch of other cruft in your

00:56:12.150 --> 00:56:14.600
code that Arc doesn't need anymore,
gone.

00:56:15.550 --> 00:56:17.300
Third step is it gives you a diff.

00:56:17.390 --> 00:56:19.220
It says, hey, here's what I've done.

00:56:19.220 --> 00:56:20.310
This is really great.

00:56:20.390 --> 00:56:22.190
And when you hit Accept,
you now have a new shiny

00:56:22.190 --> 00:56:23.000
Arc app of your own.

00:56:23.100 --> 00:56:25.780
So instead of talking about
this and waving a slide,

00:56:25.850 --> 00:56:27.940
how about we actually see it in action?

00:56:34.870 --> 00:56:37.750
So here we have the code for
the Touch Fighter application,

00:56:37.750 --> 00:56:40.350
which is an iPhone app.

00:56:40.620 --> 00:56:42.770
Matthew has been working
on this for some time,

00:56:42.770 --> 00:56:44.240
and he's done a great job.

00:56:44.240 --> 00:56:46.700
He finally got his textures figured out.

00:56:46.830 --> 00:56:49.760
But he's not really up with the times,
and so he built this as a

00:56:49.760 --> 00:56:51.580
manually referenced kind of app.

00:56:51.610 --> 00:56:53.740
Let's see if we can help him out.

00:56:53.750 --> 00:56:58.740
To do this, we go to the Edit menu,
go to Refactor, and just down to Convert

00:56:58.740 --> 00:57:00.480
to Objective-C Arc.

00:57:00.970 --> 00:57:02.590
Now this is going to
scan through my code,

00:57:02.590 --> 00:57:05.860
and it looks like it found a problem
that it can't automatically handle.

00:57:05.860 --> 00:57:08.320
Let's see what it's talking about here.

00:57:09.170 --> 00:57:13.440
If we jump here, we can say, oh, look,
I have an NS Auto Release Pool going on.

00:57:13.480 --> 00:57:16.280
And it looks like this code is
doing something pretty crazy here.

00:57:16.280 --> 00:57:20.520
It looks like somebody's been
really clever and optimized this.

00:57:20.520 --> 00:57:24.310
So every fourth time through the loop,
it actually drains the pool

00:57:24.310 --> 00:57:26.270
and then reallocates a new one.

00:57:26.310 --> 00:57:26.800
Okay.

00:57:26.800 --> 00:57:29.600
So the migrator can't handle
anything that's this complicated,

00:57:29.600 --> 00:57:30.790
so we have to help it out.

00:57:31.670 --> 00:57:33.790
Well, I'm just going to take
the body of the loop,

00:57:33.860 --> 00:57:35.730
this is the actual meet, and cut it out.

00:57:35.820 --> 00:57:38.870
And this I'm just going to delete,
because whoever did that was

00:57:38.870 --> 00:57:42.290
being probably a little bit more
clever than they need to be.

00:57:42.290 --> 00:57:44.900
And use our new add auto
release pool statement,

00:57:44.900 --> 00:57:45.360
right?

00:57:45.390 --> 00:57:47.660
I can put the body of
the loop right back in,

00:57:47.720 --> 00:57:50.240
and now I don't need
this outer pool either.

00:57:52.800 --> 00:57:56.300
Okay, with that, I've fixed the problem.

00:57:56.300 --> 00:58:00.220
Let's try running the Migrator
again and see what happens.

00:58:00.360 --> 00:58:03.930
And this time it finishes up
its incremental scan and says,

00:58:03.960 --> 00:58:05.730
hey, well, everything looks good.

00:58:05.860 --> 00:58:06.660
I'd like to move you now.

00:58:06.680 --> 00:58:08.480
So we're going to hit Next.

00:58:08.480 --> 00:58:11.640
It's going to go through our entire
application and convert away.

00:58:11.640 --> 00:58:13.040
And here comes our diff.

00:58:13.140 --> 00:58:15.710
Now, the first thing,
which is pretty obvious,

00:58:15.710 --> 00:58:18.410
is that you can see that the
migrators touch just about

00:58:18.470 --> 00:58:20.330
every file in our application.

00:58:20.340 --> 00:58:23.400
Well, this isn't because a migrator
wants to touch all your code.

00:58:23.400 --> 00:58:26.610
This is because memory
management logic gets scattered

00:58:26.610 --> 00:58:28.580
throughout your application.

00:58:29.240 --> 00:58:30.610
This is just the way it is.

00:58:30.630 --> 00:58:34.320
This is why memory management in
a manual way can be so tricky,

00:58:34.320 --> 00:58:36.440
because everything has to
be spread across your app,

00:58:36.630 --> 00:58:37.630
and it all has to be perfect.

00:58:37.640 --> 00:58:40.050
So if we look at some of the
changes the migrators made,

00:58:40.050 --> 00:58:41.440
we'll start with explosions.

00:58:41.510 --> 00:58:43.780
Those are the most
important part of any game.

00:58:43.780 --> 00:58:45.510
You can see what you'd expect.

00:58:45.510 --> 00:58:48.300
You'd see a lot of releases
that just disappear.

00:58:48.300 --> 00:58:52.960
You look at this cube map, for example,
and again, there's a whole bunch of

00:58:52.960 --> 00:58:55.010
routines that are just gone.

00:58:55.020 --> 00:58:57.690
Well, here you see a very common pattern.

00:58:58.180 --> 00:59:00.400
So let's say you've written a
dialog that just does a release.

00:59:00.700 --> 00:59:04.500
Well, with Arc, the runtime and compiler
just do this for you,

00:59:04.500 --> 00:59:05.560
so you don't have to think about it.

00:59:05.560 --> 00:59:06.460
You don't have to worry about it.

00:59:06.530 --> 00:59:08.800
And so here, Arc's just deleting the
entire dialog method,

00:59:08.880 --> 00:59:09.930
because it's not needed.

00:59:09.980 --> 00:59:11.910
Right?

00:59:17.990 --> 00:59:20.770
As I said before,
the Migrator is actually pretty smart.

00:59:20.880 --> 00:59:24.090
So here's a case where I was
using NSAutoReleasePool in main.

00:59:24.530 --> 00:59:26.270
Maybe you have a main
that does one as well.

00:59:26.530 --> 00:59:28.750
And it just automatically,
transparently migrated

00:59:28.820 --> 00:59:31.910
to an atAutoReleasePool,
because it's well-structured.

00:59:31.980 --> 00:59:33.720
Now,
the Migrator has a whole bunch of tricks,

00:59:33.720 --> 00:59:35.020
and I'm not going to go through them all.

00:59:35.080 --> 00:59:38.190
One last one I want to show you
is that the Migrator even knows

00:59:38.240 --> 00:59:41.940
how to change assigned properties
and delegates and things like

00:59:42.080 --> 00:59:43.800
that to weak pointers for you.

00:59:43.850 --> 00:59:46.820
This means that the Migrator just
makes your application safer and

00:59:46.820 --> 00:59:51.090
less crashy just by going through it,
as well as defining away

00:59:51.090 --> 00:59:52.770
a lot of other problems.

00:59:53.060 --> 00:59:54.760
So this all looks good to me.

00:59:54.840 --> 00:59:56.400
I'm just going to accept the changes.

00:59:56.430 --> 00:59:59.430
And let's see what happens
when I try to run this app.

00:59:59.610 --> 01:00:00.640
So we're building it.

01:00:00.640 --> 01:00:02.790
Up comes the simulator.

01:00:02.900 --> 01:00:05.240
Go into single player here.

01:00:05.240 --> 01:00:07.600
And I'm not going to
try to defend the world,

01:00:07.650 --> 01:00:10.220
but you can see that here we're
running Touch Fighter with no

01:00:10.220 --> 01:00:11.740
retains and releases whatsoever.

01:00:11.910 --> 01:00:13.580
It's that simple.

01:00:22.240 --> 01:00:24.160
Now I want to show you another
application I've been working

01:00:24.160 --> 01:00:27.520
with and kind of playing with
and converting in my spare time.

01:00:27.610 --> 01:00:30.510
This is an application called Dashcode.

01:00:30.900 --> 01:00:34.430
Dashcode is a slightly
larger application.

01:00:34.540 --> 01:00:39.500
It's actually our premier developer
tool for building web applications.

01:00:39.800 --> 01:00:42.140
So I've converted dash code
in my spare time to Arc,

01:00:42.140 --> 01:00:44.300
and I've been fiddling around
with the template chooser,

01:00:44.300 --> 01:00:46.700
and I think I might have
introduced a problem.

01:00:46.800 --> 01:00:51.600
So let's see what happens when
I profile it and run it under leaks.

01:00:52.340 --> 01:00:57.370
Xcode is a big app, it has a little over
150,000 lines of code.

01:00:57.370 --> 01:00:59.200
So this is a real world app.

01:00:59.230 --> 01:01:01.850
Here comes Instruments in leaks mode.

01:01:01.850 --> 01:01:05.500
Here comes my template chooser
I've been playing with.

01:01:05.610 --> 01:01:09.100
And even just sitting here, I can see,
wait a second,

01:01:09.100 --> 01:01:13.540
Instruments is already telling
me that I'm leaking memory.

01:01:14.010 --> 01:01:16.070
This little red box is saying, hey,
there's something wrong.

01:01:16.110 --> 01:01:20.980
And so I can look through this,
and it looks like I have a problem.

01:01:20.980 --> 01:01:25.220
I am leaking NSCF strings,
I'm leaking mutable dictionaries,

01:01:25.360 --> 01:01:29.040
I'm leaking some malloc memory,
I'm leaking URLs.

01:01:29.040 --> 01:01:31.270
Clearly,
I'm not very good at this whole thing,

01:01:31.270 --> 01:01:31.700
right?

01:01:31.700 --> 01:01:33.230
I mean, what's going on here?

01:01:33.580 --> 01:01:37.740
Well, one of the great new features of
instruments in Xcode 4.2 is actually

01:01:37.780 --> 01:01:41.660
can search for retained cycles in the
heap and display them to you graphically

01:01:41.660 --> 01:01:43.560
just by going to the cycles view.

01:01:43.560 --> 01:01:46.920
So if I go here...

01:01:57.630 --> 01:02:00.180
I instantly see the problem, right?

01:02:00.330 --> 01:02:03.560
Clearly, I have several retain
cycles in my application,

01:02:03.560 --> 01:02:06.070
and I can see graphically
what's going on.

01:02:06.140 --> 01:02:08.720
I have a template library,
points to mutable dictionary,

01:02:08.720 --> 01:02:09.640
points to template.

01:02:09.640 --> 01:02:10.920
That all makes sense.

01:02:10.920 --> 01:02:14.430
But the template is retaining
the template library.

01:02:14.430 --> 01:02:16.220
That doesn't make sense.

01:02:17.000 --> 01:02:20.450
So Instruments is super powerful,
and it can just display

01:02:20.460 --> 01:02:22.070
this and find this for me.

01:02:22.070 --> 01:02:23.320
It's fantastic.

01:02:23.320 --> 01:02:25.320
So now that I know what
the problem here is,

01:02:25.320 --> 01:02:28.230
okay, my template should not be
owning my template library,

01:02:28.270 --> 01:02:28.990
what do I do?

01:02:29.210 --> 01:02:32.040
Well, I have to go back and find this in
my code and do something about it.

01:02:32.140 --> 01:02:35.690
One of the other great features
is because the compiler and

01:02:35.690 --> 01:02:39.760
Instruments are working together,
is I can now just double-click

01:02:39.760 --> 01:02:41.000
right on this edge.

01:02:41.060 --> 01:02:43.870
It takes me right to
the IVAR in question.

01:02:51.250 --> 01:02:54.640
Now, I could change this
to an unretained IVAR.

01:02:54.640 --> 01:02:56.640
I can make it a signed property,
all that kind of stuff.

01:02:56.640 --> 01:02:58.480
But that's not really
the right way to go.

01:02:58.590 --> 01:03:00.760
The correct, safe,
nice way to go is to just

01:03:00.760 --> 01:03:02.260
make this into a weak IVAR.

01:03:02.270 --> 01:03:03.680
It's that simple.

01:03:03.680 --> 01:03:06.840
Now let's run this again under
Instruments and see what happens.

01:03:06.840 --> 01:03:11.420
So here we go.

01:03:14.400 --> 01:03:19.000
And suddenly here comes Xcode
with my template browser.

01:03:19.010 --> 01:03:21.820
And already we can see
that there's no more leak.

01:03:21.820 --> 01:03:25.210
So all of those objects,
which was a substantial leak,

01:03:25.280 --> 01:03:29.030
has been dramatically fixed just
by switching to a weak IVAR.

01:03:29.050 --> 01:03:31.400
So that's Instruments.

01:03:40.520 --> 01:03:42.040
So we're really excited about Arc.

01:03:42.160 --> 01:03:44.340
We're really excited about
zeroing weak references.

01:03:44.370 --> 01:03:47.320
But you may be wondering, well,
what's the cost?

01:03:47.640 --> 01:03:50.850
What does it mean if I switch
my application to use this?

01:03:51.040 --> 01:03:52.710
So let's talk about performance.

01:03:52.960 --> 01:03:56.550
Now, in addition to implementing
Arc and zeroing weak references,

01:03:56.580 --> 01:04:02.320
we've actually put a lot of effort into
tuning up the Objective-C runtime itself.

01:04:02.380 --> 01:04:04.120
So what does that mean?

01:04:04.290 --> 01:04:06.880
For example,
the retain and release implementation

01:04:06.930 --> 01:04:13.860
on NSObject now takes as few as 40%
of the CPU cycles as it did before.

01:04:14.030 --> 01:04:16.400
This is a major speed-up.

01:04:21.100 --> 01:04:24.220
Also,
before I converted this NSA release pool,

01:04:24.220 --> 01:04:26.340
this hand-tuned case to
at-order release pool,

01:04:26.340 --> 01:04:28.080
is that going to cost me performance,
right?

01:04:28.080 --> 01:04:30.300
I mean, clearly somebody thought
that it was important,

01:04:30.300 --> 01:04:32.010
so they put a lot of
effort into doing this,

01:04:32.010 --> 01:04:35.380
or maybe they're a little bit more
clever than they really deserve to be.

01:04:35.380 --> 01:04:39.060
But in either case,
the new at-order release pool syntax

01:04:39.400 --> 01:04:42.120
is much faster than NSA release pool.

01:04:42.120 --> 01:04:45.140
It takes about 20% of the time,
20% of the CPU cycles,

01:04:45.140 --> 01:04:47.560
because it's not actually
allocating an object,

01:04:47.560 --> 01:04:48.240
right?

01:04:48.520 --> 01:04:51.110
And it's just implemented
in a much more optimal way.

01:04:51.120 --> 01:04:52.310
It's really great.

01:04:53.760 --> 01:04:56.250
Third thing I want to talk
about is that the compiler and

01:04:56.250 --> 01:04:58.220
runtime were co-designed for Arc.

01:04:58.240 --> 01:05:01.740
They're working really well
and really tightly together,

01:05:01.740 --> 01:05:05.670
which enables a number of really amazing
optimizations in the LLVM compiler.

01:05:05.680 --> 01:05:09.520
So one of these optimizations is
to take a really common pattern,

01:05:09.520 --> 01:05:11.160
auto-release getters.

01:05:11.160 --> 01:05:15.420
The standard Cocoa practice is to
return an object auto-released.

01:05:15.420 --> 01:05:19.300
But that means that it lives a long time,
and that means that it may not get

01:05:19.340 --> 01:05:23.200
deallocated for longer than you want,
maybe at the top of your event loop.

01:05:23.700 --> 01:05:26.740
Well, with Arc now,
we're doing two things.

01:05:26.740 --> 01:05:30.580
The first is that the runtime
and the compiler know when

01:05:30.580 --> 01:05:32.930
you're returning back to Arc.

01:05:32.940 --> 01:05:37.560
Second is, in that case,
the runtime actually avoids putting that

01:05:37.700 --> 01:05:40.460
object in an auto-release pool at all.

01:05:40.460 --> 01:05:42.400
This is a huge performance win.

01:05:42.460 --> 01:05:47.420
So the cost of doing these auto-release
getters when the optimization kicks in is

01:05:47.420 --> 01:05:50.210
now 5% in CPU cycles than it used to be.

01:05:50.220 --> 01:05:53.340
This is a major win.

01:05:58.520 --> 01:06:03.840
The second big win of this, of course,
is not a CPU performance optimization.

01:06:04.170 --> 01:06:06.620
It's the huge memory optimization,
because now these things aren't

01:06:06.700 --> 01:06:09.090
going into an auto-release pool,
and so that means they get

01:06:09.090 --> 01:06:11.500
deallocated as soon as the
last pointer of them goes away.

01:06:11.680 --> 01:06:15.140
And that's really the huge advantage
of Arc versus a garbage collector,

01:06:15.200 --> 01:06:19.170
is that your objects go away
right away when they're dead.

01:06:19.430 --> 01:06:23.760
and So this is pretty great.

01:06:23.890 --> 01:06:25.030
We're really excited about this.

01:06:25.220 --> 01:06:27.400
Where do you think that you can use Arc?

01:06:27.400 --> 01:06:30.390
Well, I'm pleased to say that Arc is
available on both of the premier

01:06:30.400 --> 01:06:35.390
platforms we announced earlier today,
iOS 5 and Mac OS Online.

01:06:41.800 --> 01:06:45.360
and going a little bit farther,
Arc is so great that the first

01:06:45.360 --> 01:06:47.400
application is already in the store.

01:06:47.400 --> 01:06:49.150
Maybe you've seen it.

01:06:49.580 --> 01:06:52.830
This is the WWDC attendee app.

01:06:53.200 --> 01:06:59.160
Now, switching to Arc actually saved this
app a substantial amount of memory.

01:06:59.300 --> 01:07:02.640
It also shrunk the code by about
5%, which is a huge maintenance win

01:07:02.640 --> 01:07:04.630
and has many other benefits as well.

01:07:04.680 --> 01:07:07.250
But you may be wondering,
how many of you all are

01:07:07.250 --> 01:07:09.190
running this on iOS 5 or Lion?

01:07:09.200 --> 01:07:10.390
I don't know.

01:07:10.610 --> 01:07:14.020
Well, that's-- you're not,
and that's because Arc also works all

01:07:14.020 --> 01:07:17.470
the way back to iOS 4 and Snowletter.

01:07:27.110 --> 01:07:29.420
So we're obviously
really excited about Arc.

01:07:29.460 --> 01:07:33.310
We think that this is a great
answer to many of the problems

01:07:33.320 --> 01:07:36.640
you've had with your applications'
memory use and memory management.

01:07:36.740 --> 01:07:40.380
And so we can't wait to see what
you do within your own applications.

01:07:40.420 --> 01:07:42.330
Back to you, Andreas.

01:07:49.380 --> 01:07:50.420
Thank you, Chris.

01:07:50.530 --> 01:07:52.910
So many of you have told us
that memory management is one of

01:07:52.920 --> 01:07:55.730
the biggest hurdles for quickly
developing apps on our platforms.

01:07:55.790 --> 01:07:58.570
And with Arc, we think we have the
right answer for you.

01:07:58.710 --> 01:08:01.460
It gives us the right
stutter-free performance.

01:08:01.520 --> 01:08:03.800
It makes your applications more robust.

01:08:03.870 --> 01:08:06.160
And it makes your code easier to write.

01:08:06.240 --> 01:08:08.150
So we think Arc is
going to be a big deal,

01:08:08.230 --> 01:08:10.990
and we think you're going
to be very happy with it.

01:08:12.560 --> 01:08:15.060
So for the last hour,
we've shown you a preview

01:08:15.060 --> 01:08:17.720
of several features that are
coming your way in the tools.

01:08:17.740 --> 01:08:19.460
And today,
we're going to make them available

01:08:19.530 --> 01:08:22.610
to you as several developer previews.

01:08:23.010 --> 01:08:26.060
If you want to get your applications
ready for Mac OS X Lion,

01:08:26.110 --> 01:08:30.840
go and download the Xcode 4.1 developer
preview from the WWDC attendee website.

01:08:30.840 --> 01:08:33.900
It contains everything you need
for Lion to get your applications

01:08:33.960 --> 01:08:35.140
ready for the Mac App Store.

01:08:36.570 --> 01:08:39.360
If you want to get your applications
ready for iOS 5 later this year,

01:08:39.370 --> 01:08:43.240
go and download the Xcode
4.2 developer preview today,

01:08:43.280 --> 01:08:47.950
which is available as a preview running
both on Snow Leopard and on Lion.

01:08:48.810 --> 01:08:51.080
So with that,
we come to an end of the session.

01:08:51.080 --> 01:08:53.000
Hope you enjoyed it,
and have a wonderful conference.
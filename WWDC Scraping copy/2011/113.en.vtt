WEBVTT

00:00:10.430 --> 00:00:14.660
Hello, and welcome to session 113,
Full Screen and Aqua Changes.

00:00:14.790 --> 00:00:15.900
My name is Troy Stephens.

00:00:16.000 --> 00:00:18.380
I'm a software engineer
on the AppKit team,

00:00:18.510 --> 00:00:20.910
and we have a variety of
interesting topics for you today.

00:00:21.160 --> 00:00:24.130
They are all about interface,
all about interface changes

00:00:24.330 --> 00:00:26.550
in Mac OS X 10.7 Lion.

00:00:26.620 --> 00:00:30.160
First up,
if you're eager to learn about Lion's new

00:00:30.160 --> 00:00:33.790
Full Screen mode and how you can enable
your own applications to participate

00:00:33.870 --> 00:00:36.600
in this powerful new system feature,
you are in the right room.

00:00:36.620 --> 00:00:39.600
We're gonna walk you through it,
show you just how easy that is to do.

00:00:39.830 --> 00:00:42.610
Next up, popovers,
a brand new standard user

00:00:42.610 --> 00:00:45.360
interface element on Lion.

00:00:45.500 --> 00:00:47.650
Very handy, couldn't be easier to use.

00:00:47.810 --> 00:00:50.590
From there,
we'll continue our tour of the new Aqua,

00:00:50.750 --> 00:00:53.860
talk about some of the changes to the
way standard controls are rendered,

00:00:53.860 --> 00:00:56.940
different rendering effects that
are applied to controls in Lion,

00:00:56.940 --> 00:00:59.770
things that differ from previous
system versions that you might want

00:00:59.860 --> 00:01:03.880
to adapt to in your own UI design
work and custom control work.

00:01:03.950 --> 00:01:06.940
And last but not least,
we've made some subtle but important

00:01:06.940 --> 00:01:11.030
improvements in our resolution
independence architecture for Lyon.

00:01:11.530 --> 00:01:15.020
The new model extends farther
down the stack all the way to

00:01:15.100 --> 00:01:16.240
the window and screen level.

00:01:16.240 --> 00:01:17.670
It is much more comprehensive.

00:01:17.910 --> 00:01:21.400
We believe it is better suited to
carry us all into the future together.

00:01:21.510 --> 00:01:23.310
So that's a lot of ground to cover.

00:01:23.450 --> 00:01:27.400
Let's start by diving right in and
immersing ourselves in Full Screen mode.

00:01:27.400 --> 00:01:30.350
As you saw in the keynote,
Full Screen mode in Lion is

00:01:30.350 --> 00:01:33.400
not a per app state,
but it is a per window state.

00:01:33.490 --> 00:01:35.890
You can take windows that are
capable of being taken full

00:01:35.890 --> 00:01:37.400
screen into Full Screen mode.

00:01:37.400 --> 00:01:40.400
The system moves that window
into its own new dedicated space.

00:01:40.430 --> 00:01:41.720
Clutter gets out of the way.

00:01:41.720 --> 00:01:44.360
You're focused in on your content,
but when you need your toolbar,

00:01:44.510 --> 00:01:46.400
your menu bars, they're available.

00:01:46.400 --> 00:01:48.400
You just flick the mouse
to the top of the screen.

00:01:48.400 --> 00:01:50.400
I have all of my menu
commands available to me.

00:01:50.400 --> 00:01:52.400
I can choose the magnifier tool.

00:01:52.400 --> 00:01:53.400
The menu bar gets out of the way.

00:01:53.400 --> 00:01:56.400
I'm back to focusing on my content.

00:01:56.400 --> 00:01:58.300
Now if I use a gesture
to swipe to the right,

00:01:58.380 --> 00:01:59.390
I'm back to my desktop.

00:01:59.430 --> 00:02:01.400
I leave that window in Full Screen mode.

00:02:01.400 --> 00:02:04.200
I can take another window Full Screen,
and that window gets its

00:02:04.200 --> 00:02:05.400
own Full Screen space.

00:02:05.400 --> 00:02:09.400
If I swipe left, I see my Lion is still
in Full Screen space.

00:02:09.410 --> 00:02:12.400
If I swipe to the right twice,
I'm back to my desktop.

00:02:12.400 --> 00:02:15.030
I can always run home to
Mission Control to get a top-level

00:02:15.030 --> 00:02:17.400
overview of all my spaces.

00:02:17.400 --> 00:02:20.350
Full Screen and not,
I can navigate among them at a

00:02:20.410 --> 00:02:22.380
click or a tap of the trackpad.

00:02:22.490 --> 00:02:26.720
We believe this degree of system-level
integration for Full Screen functionality

00:02:26.720 --> 00:02:28.400
is going to be a big boon to users.

00:02:28.400 --> 00:02:30.940
It will enable this kind of
Full Screen mode of operation

00:02:31.030 --> 00:02:33.910
to be accessible to more people
than ever before and provide

00:02:33.910 --> 00:02:35.400
interoperability among apps.

00:02:35.400 --> 00:02:38.390
So we're very excited about it.

00:02:38.460 --> 00:02:42.720
typically look for in full screen
capabilities in an application.

00:02:42.780 --> 00:02:44.350
Well,
there are different things that different

00:02:44.350 --> 00:02:47.390
users look for in different apps,
but it all boils down to a

00:02:47.390 --> 00:02:50.060
combination of two things,
typically.

00:02:50.240 --> 00:02:54.300
And the first of those is in the
distraction-prone world that we live in,

00:02:54.330 --> 00:02:58.490
the opportunity to sneak off to
a little secluded private office

00:02:58.620 --> 00:03:00.680
where there are no distractions,
clutter is out of the way,

00:03:00.730 --> 00:03:02.450
and you can focus in on a single task.

00:03:02.510 --> 00:03:04.560
I want to write my great screenplay.

00:03:04.560 --> 00:03:05.640
I want to do my digital painting.

00:03:05.640 --> 00:03:09.450
Whatever it is I want to do,
I don't want to be distracted by shiny

00:03:09.450 --> 00:03:11.900
things popping up in my Twitter feed.

00:03:11.900 --> 00:03:14.230
I don't want to have my email
on Red Count weighing on my

00:03:14.230 --> 00:03:15.660
conscience the whole time.

00:03:15.660 --> 00:03:16.580
I don't want to see that stuff.

00:03:16.630 --> 00:03:19.010
I want to get off to a
full-screen space and focus on

00:03:19.010 --> 00:03:20.750
just what I want to do right now.

00:03:20.850 --> 00:03:23.490
Full Screen mode enables you to do that,
of course.

00:03:23.580 --> 00:03:26.360
And in hand with that goes
the desire to make the most of

00:03:26.700 --> 00:03:30.430
available screen real estate,
to maximize the use of what you've got.

00:03:30.560 --> 00:03:33.320
This is useful even on a
30-inch cinema display,

00:03:33.350 --> 00:03:35.780
but users who have an
ultra-compact portable,

00:03:36.070 --> 00:03:39.340
for example, the 11-inch MacBook Air,
will especially love you for giving

00:03:39.340 --> 00:03:41.970
them a mode where they can operate,
where they can see as much

00:03:42.030 --> 00:03:46.010
of their content as possible,
interact with it with as little

00:03:46.010 --> 00:03:48.170
intermediary UI as possible.

00:03:48.420 --> 00:03:52.800
and it gives them a way to really
use that screen space to its fullest.

00:03:52.840 --> 00:03:55.840
These user benefits taken together are
so compelling that of course a lot of

00:03:55.840 --> 00:03:59.400
apps have gone ahead and implemented
their own notion of full screen mode.

00:03:59.490 --> 00:04:01.860
So what are the benefits to
our making this an integrated

00:04:01.920 --> 00:04:05.280
system feature and your adopting
our notion of full screen mode?

00:04:05.380 --> 00:04:08.430
Well, there are a couple of
things that it lets us do.

00:04:08.550 --> 00:04:11.310
First and foremost,
it lets us present a per window

00:04:11.310 --> 00:04:13.310
model for full screen mode,
where this is the state

00:04:13.310 --> 00:04:14.280
of an individual window.

00:04:14.400 --> 00:04:16.780
So you can have some of your
windows in full screen mode,

00:04:16.840 --> 00:04:18.960
some not,
and different windows across different

00:04:18.960 --> 00:04:22.510
applications in full screen mode or not,
and something that users can

00:04:22.630 --> 00:04:23.890
manage on a per window basis.

00:04:23.960 --> 00:04:27.350
This would be something that would be
a lot of work for individual developers

00:04:27.350 --> 00:04:29.030
to do in their own applications.

00:04:29.040 --> 00:04:32.180
And even if you did all of that work,
you wouldn't have the kind of cross

00:04:32.180 --> 00:04:36.490
app coexistence and integration that
we can provide at the system level.

00:04:36.890 --> 00:04:39.200
In addition, as with so many other
things on the Macintosh,

00:04:39.200 --> 00:04:43.640
there's the opportunity for us to provide
a consistent and uniform user experience.

00:04:43.640 --> 00:04:46.980
This enables users to learn a
feature once in one application

00:04:47.260 --> 00:04:50.400
and leverage that knowledge,
apply it to every application

00:04:50.430 --> 00:04:52.040
that supports that feature.

00:04:52.160 --> 00:04:54.740
So with Full Screen mode,
the relevant things are the

00:04:54.740 --> 00:04:57.960
ability to recognize which
windows can be taken full screen,

00:04:58.160 --> 00:05:00.650
standard user interface elements
so that the user knows how

00:05:00.650 --> 00:05:03.180
to take a window full screen,
how to get out of full screen,

00:05:03.320 --> 00:05:06.830
how to navigate, as I said, using spaces,
using mission control,

00:05:06.830 --> 00:05:09.950
using gestures in and out of those
full screen spaces so they feel

00:05:10.050 --> 00:05:13.400
like they're always in control
and they know where things are.

00:05:15.620 --> 00:05:17.260
So here we have a simple window.

00:05:17.260 --> 00:05:18.560
This is an Xcode window.

00:05:18.680 --> 00:05:21.190
And all you have to do is look in the
upper right corner of the window and

00:05:21.250 --> 00:05:22.710
see that Enter Full Screen widget.

00:05:22.800 --> 00:05:26.100
That tells you that that window is
capable of being taken full screen.

00:05:26.100 --> 00:05:28.320
I can click on that widget.

00:05:28.350 --> 00:05:31.440
My window gets taken into a new
space that's created just for

00:05:31.520 --> 00:05:33.730
it to be in full screen mode.

00:05:34.090 --> 00:05:36.810
And if I mouse up to get
my menu bar to come down,

00:05:36.810 --> 00:05:38.550
I can see in the upper right
corner of the menu bar,

00:05:38.550 --> 00:05:39.360
that's my escape hatch.

00:05:39.450 --> 00:05:41.670
I always have that exit full
screen widget available to me,

00:05:41.750 --> 00:05:42.760
so I know I can get out that way.

00:05:43.040 --> 00:05:45.570
And again,
I know I can navigate using gestures,

00:05:45.570 --> 00:05:48.200
spaces, and mission control.

00:05:49.290 --> 00:05:51.900
So how do you enable this
capability in your applications?

00:05:51.950 --> 00:05:52.630
Well, there really is.

00:05:52.720 --> 00:05:55.470
With so many things with Cocoa,
we try to make the simple things simple.

00:05:55.640 --> 00:05:57.780
The basics really are very simple.

00:05:57.800 --> 00:05:59.740
There is one fundamental
thing you need to do,

00:05:59.740 --> 00:06:03.410
and that's simply to tell AppKit which
of your windows should be capable

00:06:03.410 --> 00:06:04.790
of being taken full screen.

00:06:04.920 --> 00:06:06.740
Typically,
in a document-based application,

00:06:06.740 --> 00:06:07.970
these are your document windows.

00:06:08.080 --> 00:06:09.820
Or if you have a single
window application,

00:06:09.820 --> 00:06:10.870
it's your one main window.

00:06:10.960 --> 00:06:14.100
Just tell us which of your windows
should have this capability.

00:06:14.120 --> 00:06:15.970
In addition,
it's nice for you to provide an

00:06:16.040 --> 00:06:19.590
Enter Full Screen menu item for
users who like to discover or

00:06:19.770 --> 00:06:22.010
find functionality through menus.

00:06:22.100 --> 00:06:25.320
And that item is best placed in the
View menu if your application has one.

00:06:25.320 --> 00:06:28.420
If you don't, the Window menu is a
good fallback for that.

00:06:28.440 --> 00:06:30.820
And that really is all that
you fundamentally need to do.

00:06:30.820 --> 00:06:33.330
Of course, there's always the opportunity
to apply more polish,

00:06:33.330 --> 00:06:37.190
and there are some things you can do
to make your apps really stand out.

00:06:37.740 --> 00:06:40.620
One of the things you can do
is have your Windows toolbar,

00:06:40.620 --> 00:06:44.000
if your window has a toolbar,
automatically hidden and shown with

00:06:44.160 --> 00:06:45.650
the menu bar in the full screen space.

00:06:45.740 --> 00:06:46.520
That's real easy to do.

00:06:46.520 --> 00:06:48.380
I'll show you how.

00:06:48.810 --> 00:06:51.870
Another thing you might want to consider
doing is providing a custom size

00:06:52.100 --> 00:06:54.100
for your Windows Full Screen frame.

00:06:54.190 --> 00:06:55.830
By default,
the system will assume that you

00:06:55.830 --> 00:06:59.380
want to use the entire main screen,
which may be appropriate for some

00:06:59.380 --> 00:07:01.640
apps if I have my month view in iCal.

00:07:01.750 --> 00:07:04.760
I probably just want to stretch that
up so that the boxes are as big as

00:07:04.760 --> 00:07:09.350
possible and I can see as much of the
detail in each of them as possible.

00:07:09.460 --> 00:07:11.360
But sometimes you want
a different frame size.

00:07:11.360 --> 00:07:14.500
We'll see that's not all as
appropriate as in our demo app,

00:07:14.650 --> 00:07:17.050
and you can customize that easily.

00:07:17.430 --> 00:07:19.700
While you're doing that,
another thing you might want to consider

00:07:19.700 --> 00:07:23.300
doing is modifying or streamlining your
Windows content for Full Screen mode.

00:07:23.300 --> 00:07:26.300
If you think one of the things
that your users are looking for

00:07:26.310 --> 00:07:28.300
is a more streamlined UI that
gets clutter out of the way,

00:07:28.300 --> 00:07:31.720
that gets distractions out of the way,
and provides them only with what

00:07:31.720 --> 00:07:34.280
they need to operate in that mode,
this might be a good time to consider

00:07:34.400 --> 00:07:36.980
altering your Windows layout,
maybe temporarily removing some

00:07:36.980 --> 00:07:40.300
views or having things that
auto-hide or just take less space.

00:07:40.300 --> 00:07:44.300
And if you find yourself making
extensive customizations of that nature,

00:07:44.500 --> 00:07:47.490
you may find it useful for your
bookkeeping purposes to just

00:07:47.490 --> 00:07:50.300
create an entirely separate window
for use in Full Screen mode.

00:07:50.300 --> 00:07:53.300
That window will reference
the same content to the user.

00:07:53.300 --> 00:07:55.960
The illusion is that their
original window was just morphed

00:07:55.960 --> 00:07:58.440
into this Full Screen window,
but for your purposes,

00:07:58.440 --> 00:08:01.310
you can keep a separate window for that,
and we give you the hooks to

00:08:01.380 --> 00:08:05.300
substitute a different window of
your choosing when under Full Screen.

00:08:06.890 --> 00:08:09.400
Lastly,
the system provides a standard crossfade

00:08:09.400 --> 00:08:12.200
transition for taking the window
into or out of Full Screen mode,

00:08:12.210 --> 00:08:14.000
but you have the ability
to fully customize that,

00:08:14.160 --> 00:08:16.940
and we'll look at doing that in our demo,
too.

00:08:17.060 --> 00:08:19.020
But, you know,
there are five bullet points of

00:08:19.020 --> 00:08:21.830
customization potential there,
but really it all boils

00:08:21.830 --> 00:08:23.360
down to the basics.

00:08:23.620 --> 00:08:25.660
telling us which windows
can be made full screen.

00:08:25.660 --> 00:08:29.240
You can do this with zero lines of
code in Xcode's Interface Builder mode.

00:08:29.240 --> 00:08:31.740
This is part of a window's
collection behaviors,

00:08:31.740 --> 00:08:34.900
as usually pertains to spaces and so on.

00:08:34.900 --> 00:08:36.600
There's a new full screen item.

00:08:36.600 --> 00:08:40.620
Just change that from Unsupported to
Primary Window for your window class,

00:08:40.620 --> 00:08:43.580
for your window template in IB,
and you're good to go.

00:08:43.580 --> 00:08:45.320
If you really like writing code,
of course,

00:08:45.320 --> 00:08:48.160
there's a corresponding bit for this
in your window's collection behaviors.

00:08:48.160 --> 00:08:50.950
You can set it using
Set Collection Behavior.

00:08:51.220 --> 00:08:52.100
and Dan Schimpf.

00:08:52.100 --> 00:08:54.500
And again, adding that menu item
is a nice thing to do.

00:08:54.500 --> 00:08:57.190
Couldn't be easier because there's a
template for this in Interface Builder.

00:08:57.190 --> 00:08:59.020
You just drag out the
Full Screen menu item,

00:08:59.140 --> 00:09:01.320
drop it in your View menu
or your Window menu.

00:09:01.390 --> 00:09:04.340
It's already wired up to send the
toggle Full Screen message to your

00:09:04.730 --> 00:09:07.440
application's first responder,
so any window in the responder

00:09:07.440 --> 00:09:09.840
chain will pick that up,
validate against it if

00:09:09.840 --> 00:09:12.640
it can go Full Screen,
and respond to that message to toggle

00:09:12.640 --> 00:09:14.160
the window into or out of Full Screen.

00:09:14.160 --> 00:09:17.400
The menu item updates to say exit
Full Screen when you're in Full Screen,

00:09:17.500 --> 00:09:20.530
and usually actually it has
the recommended key equivalent

00:09:20.530 --> 00:09:23.690
of Command Control F wired
up for it already.

00:09:23.720 --> 00:09:25.250
And to show you just
how easy this is to do,

00:09:25.250 --> 00:09:28.070
we're going to take Sketch,
which is one of our standard

00:09:28.270 --> 00:09:32.510
document-based application examples,
and convert it to be a

00:09:32.510 --> 00:09:35.190
Full Screen capable app on Lion.

00:09:38.890 --> 00:09:40.680
So I'm going to open up
the Sketch project here.

00:09:40.680 --> 00:09:43.560
And this is Sketch just built as is.

00:09:43.680 --> 00:09:46.110
So by default,
the system doesn't assume that

00:09:46.110 --> 00:09:47.860
it can be taken full screen.

00:09:47.860 --> 00:09:50.860
We can maximize the window
using the Zoom button here,

00:09:50.860 --> 00:09:53.530
but that doesn't give us the same effect.

00:09:53.560 --> 00:09:55.100
We still have the menu bar in the way.

00:09:55.100 --> 00:09:57.360
We still have the dock,
and we're really just covering

00:09:57.360 --> 00:09:58.990
up other windows on the desktop.

00:09:59.040 --> 00:10:01.740
So this isn't really full
screen mode by any stretch.

00:10:01.740 --> 00:10:08.110
So let's open up the Sketch project.

00:10:10.540 --> 00:10:12.150
And again,
the basics of what you need to do,

00:10:12.160 --> 00:10:14.190
just tell us which windows
should be capable of this.

00:10:14.220 --> 00:10:15.210
That's the first thing you need to do.

00:10:15.300 --> 00:10:17.920
So we're going to go into the
DrawWindowNib file that holds

00:10:17.920 --> 00:10:19.810
Sketch's document window.

00:10:19.860 --> 00:10:22.640
And if I go in the
Properties Inspector here,

00:10:22.680 --> 00:10:25.890
here you see the windows collection
behaviors in these pop-ups.

00:10:25.920 --> 00:10:29.350
I'll just change Full Screen to
Primary Screen and Save.

00:10:29.530 --> 00:10:31.490
And we could be good to go now,
but let's add that menu

00:10:31.490 --> 00:10:33.130
item while we're at it.

00:10:33.180 --> 00:10:36.200
I'll go to the Windows menu,
since we don't have View menu.

00:10:36.200 --> 00:10:38.770
I'm going to type in
Full Screen in the search here,

00:10:38.860 --> 00:10:41.120
and we want to be in the Object Library.

00:10:41.130 --> 00:10:42.600
There we go.

00:10:42.620 --> 00:10:44.050
Boom, drop it right in.

00:10:44.090 --> 00:10:48.030
And if I inspect this item,
I can see it's wired up to send toggle

00:10:48.130 --> 00:10:51.310
Full Screen to the first responder.

00:10:51.340 --> 00:10:52.320
So great, we're good to go.

00:10:52.320 --> 00:10:55.670
Let's just try and build
and run just like this.

00:10:57.300 --> 00:11:01.190
All right, now we've got our
Enter Full Screen widget.

00:11:01.210 --> 00:11:05.000
And I can toggle Sketch into
and out of Full Screen mode.

00:11:06.020 --> 00:11:08.060
And I've got my menu bar
available when I want it.

00:11:08.060 --> 00:11:10.740
I can bring up my inspectors and so on.

00:11:10.770 --> 00:11:13.000
I can do my editing.

00:11:13.880 --> 00:11:15.760
Everything works.

00:11:15.830 --> 00:11:18.040
My dock is down here if I mouse
to the bottom of the screen,

00:11:18.040 --> 00:11:19.480
but it's out of the way most of the time.

00:11:19.480 --> 00:11:21.240
So we've got basic full
screen support in here.

00:11:21.240 --> 00:11:24.460
We're still not using-- we're
not really using the available

00:11:24.510 --> 00:11:25.740
screen space very well.

00:11:25.740 --> 00:11:28.060
We don't need that much
space to see our document.

00:11:28.110 --> 00:11:29.770
We've got all this
gray space on the side.

00:11:29.910 --> 00:11:31.810
So let's look at doing
something about that next.

00:11:31.820 --> 00:11:36.580
What we want to do here--

00:11:38.960 --> 00:11:41.170
is customize the
Windows Full Screen size,

00:11:41.300 --> 00:11:41.900
as I said.

00:11:41.940 --> 00:11:44.400
All of these kinds of customizations
that you might want to do next

00:11:44.400 --> 00:11:46.380
are done in the Windows delegate.

00:11:46.480 --> 00:11:48.240
So typically,
that's an NSWindowController.

00:11:48.240 --> 00:11:51.260
In Sketch's case,
it's an SKTWindowController.

00:11:51.380 --> 00:11:54.460
So we're going to go into
SKTWindowController and scroll

00:11:54.460 --> 00:11:57.520
down here to some code that I've
written ahead of time for us.

00:11:57.540 --> 00:11:59.010
And disabled.

00:11:59.050 --> 00:12:00.650
We'll enable that now.

00:12:00.770 --> 00:12:05.480
And the method to override is
windowWillUseFullScreenContentSize.

00:12:05.490 --> 00:12:08.380
AppKit passes you the window that
it's planning to take full screen,

00:12:08.380 --> 00:12:09.890
the proposed size for that window.

00:12:10.010 --> 00:12:11.820
Typically, this is the entire screen.

00:12:11.850 --> 00:12:14.610
You have the opportunity to
return whatever size you want,

00:12:14.780 --> 00:12:17.680
taking that proposed size into account.

00:12:18.890 --> 00:12:21.180
So what we're going to do here is
we're going to assume that we want

00:12:21.180 --> 00:12:24.440
to keep the same zoom factor for the
document and pretend that-- imagine

00:12:24.440 --> 00:12:26.220
that we have an infinitely large screen.

00:12:26.220 --> 00:12:29.250
What would be the ideal size that
we want this window to be so that

00:12:29.330 --> 00:12:33.710
the user doesn't have to scroll,
but they can see their entire content?

00:12:34.900 --> 00:12:36.660
And so what we'll do is
we'll take the graphic view,

00:12:36.660 --> 00:12:39.400
which is the document view in the window,
get its bounds,

00:12:39.510 --> 00:12:41.630
convert that up to the scroll view space.

00:12:41.840 --> 00:12:43.920
We'll consider that
our ideal content size.

00:12:43.920 --> 00:12:49.900
That's how much space we need to show
our content at its current zoom factor.

00:12:49.900 --> 00:12:53.080
We'll need to account for the possibility
of the scroll view having a border

00:12:53.340 --> 00:12:55.820
and maybe having legacy scrollers,
which take up space.

00:12:55.940 --> 00:12:58.560
So we might need to grow
that rectangle a little bit.

00:12:58.590 --> 00:13:01.710
That gives us our ideal window size here.

00:13:03.110 --> 00:13:05.500
And then we just need to
constrain that to reality,

00:13:05.500 --> 00:13:08.190
the proposed size, the actual screen size
that we have to work with.

00:13:08.210 --> 00:13:12.270
So we'll take the smaller on
each axis and return that value.

00:13:12.940 --> 00:13:14.700
And let's build and run.

00:13:14.800 --> 00:13:18.980
And now when we take Sketch Full Screen,
it just slides on over into space.

00:13:19.010 --> 00:13:22.180
And we've got this nice linen background
that the system provides for us.

00:13:22.300 --> 00:13:25.740
So we've got room to arrange our
inspectors and other things around it,

00:13:25.790 --> 00:13:26.770
which is nice.

00:13:26.780 --> 00:13:30.750
And if I exit Full Screen mode,

00:13:37.100 --> 00:13:39.140
and Mike Schuch there.

00:13:39.140 --> 00:13:42.330
Okay, now we're in Full Screen mode.

00:13:42.340 --> 00:13:43.170
Exit.

00:13:43.540 --> 00:13:45.100
and we're back.

00:13:45.150 --> 00:13:47.220
But the transition isn't
exactly what we would want.

00:13:47.230 --> 00:13:50.900
And especially we can see this if
we kind of try to exercise this a

00:13:50.900 --> 00:13:52.910
little in a more challenging way.

00:13:52.920 --> 00:13:57.000
Let's zoom in and suppose that we're
only seeing part of the document.

00:13:58.280 --> 00:13:59.430
We want to enter Full Screen mode.

00:13:59.450 --> 00:14:03.240
That's not really a great transition,
I think.

00:14:03.270 --> 00:14:06.320
We would sort of expect that the
existing content that we can see would

00:14:06.320 --> 00:14:08.560
just sort of slide on over into space,
because we're not

00:14:08.560 --> 00:14:10.640
changing the zoom factor,
and we would just reveal

00:14:10.640 --> 00:14:11.560
the other content.

00:14:11.670 --> 00:14:13.960
So maybe here the crossfade
isn't really a good idea,

00:14:13.960 --> 00:14:16.780
and we want to implement
our own custom transition.

00:14:16.910 --> 00:14:19.550
I will show you the hooks
that you need to do that.

00:14:19.570 --> 00:14:23.490
So there are six methods for this,
three for entering Full Screen and

00:14:23.590 --> 00:14:26.640
a parallel set of three methods
for exiting Full Screen mode.

00:14:26.640 --> 00:14:28.800
Four of those methods are
really trivial to implement,

00:14:28.800 --> 00:14:32.940
so really we've just got two
major methods to worry about.

00:14:33.040 --> 00:14:35.090
These are also methods
on the Windows delegate.

00:14:35.100 --> 00:14:38.080
The first thing you need to do to
tell AppKit that you want to provide

00:14:38.150 --> 00:14:41.500
a custom enter Full Screen transition
is override custom windows to

00:14:41.500 --> 00:14:42.970
enter Full Screen for window.

00:14:43.000 --> 00:14:45.910
You're given the window that
AppKit means to take Full Screen,

00:14:45.910 --> 00:14:49.100
and you're expected to return
an array of windows to be

00:14:49.100 --> 00:14:50.600
used in that Full Screen mode.

00:14:50.690 --> 00:14:52.180
Now why an array of windows?

00:14:52.320 --> 00:14:55.440
Well, you might want to specify
additional windows for any

00:14:55.440 --> 00:14:58.540
temporary animation effects that you
want to create in Full Screen mode.

00:14:58.540 --> 00:15:01.780
What you're returning is the set
of windows that are tagged as

00:15:01.950 --> 00:15:04.690
belonging to the Full Screen space
that's being created.

00:15:04.780 --> 00:15:07.780
So any windows that you want to have
appear in that Full Screen space

00:15:07.810 --> 00:15:10.920
and during the transition
should be included in this list.

00:15:11.170 --> 00:15:13.730
In this case,
we're just including our original window.

00:15:13.820 --> 00:15:16.970
If we wanted to substitute an alternative
window for Full Screen mode that's

00:15:16.970 --> 00:15:20.320
just dedicated to Full Screen mode,
we could specify that instead.

00:15:20.350 --> 00:15:23.210
Right now, we're just going to use the
window that we were given,

00:15:23.280 --> 00:15:25.070
but overriding this
method tells AppKit that,

00:15:25.080 --> 00:15:27.040
well,
we want subsequent methods to be invoked.

00:15:27.050 --> 00:15:29.590
We're doing a custom transition.

00:15:30.450 --> 00:15:33.520
The real method to think about is
Windows start custom animation to

00:15:33.520 --> 00:15:35.100
enter Full Screen with duration.

00:15:35.100 --> 00:15:38.000
You're passed in the duration in seconds
of the transition that the system

00:15:38.000 --> 00:15:40.210
is going to use for everything else,
including the menu bar,

00:15:40.230 --> 00:15:41.180
sliding spaces over.

00:15:41.340 --> 00:15:43.570
So you want to use the
same duration in seconds,

00:15:43.570 --> 00:15:47.290
but it's up to you to set the duration
of your animation to match that.

00:15:47.380 --> 00:15:50.000
And the first thing I'm going
to do is stash off to the side

00:15:50.000 --> 00:15:52.400
what our Windows frame was before
we went into Full Screen mode,

00:15:52.400 --> 00:15:54.930
because when we exit,
it'd be nice if we just know

00:15:54.930 --> 00:15:56.760
which frame to restore back to.

00:15:56.880 --> 00:16:00.100
We're going to persist this along with
the Windows other persistent state,

00:16:00.100 --> 00:16:03.000
because the fact that a window
is in Full Screen is a part of

00:16:03.110 --> 00:16:04.800
the Windows persistent state.

00:16:04.800 --> 00:16:07.410
If the user takes a Sketch window
Full Screen and then quits

00:16:07.540 --> 00:16:10.790
Sketch and relaunches Sketch,
not only will that document be reopened,

00:16:10.790 --> 00:16:13.090
but it will be reopened in
its own Full Screen space.

00:16:13.100 --> 00:16:14.400
So that state persists.

00:16:14.440 --> 00:16:18.000
We should persist the
previous frame along with it.

00:16:18.040 --> 00:16:20.710
Next thing I'm going to do,
I'm going to bump the window up

00:16:20.710 --> 00:16:24.410
above the menu bar level so that the
window during--while it's in flight,

00:16:24.500 --> 00:16:26.680
it can fly over the menu bar
instead of appearing on the screen.

00:16:26.700 --> 00:16:26.700
So that's the first step.

00:16:26.700 --> 00:16:26.700
The second step is to set the window
up above the menu bar level so that the

00:16:26.700 --> 00:16:26.700
window during--while it's in flight,
it can fly over the menu bar

00:16:26.700 --> 00:16:26.700
instead of appearing on the screen.

00:16:26.740 --> 00:16:27.200
So that's the first step.

00:16:27.200 --> 00:16:27.350
The second step is to set the window
up above the menu bar level so that the

00:16:27.370 --> 00:16:27.480
window during--while it's in flight,
it can fly over the menu bar

00:16:27.480 --> 00:16:27.700
instead of appearing on the screen.

00:16:27.700 --> 00:16:29.700
That just makes things
look a little nicer.

00:16:29.880 --> 00:16:33.400
And the next thing I'm going to do
here is set the Full Screen window

00:16:33.400 --> 00:16:35.660
mask bit in the Windows style mask.

00:16:35.770 --> 00:16:39.400
And this fundamentally is the thing that
marks the window as being in Full Screen.

00:16:39.400 --> 00:16:42.860
It also has the side effect of
hiding the Windows title bar.

00:16:43.020 --> 00:16:45.000
Now, AppKit would do this
automatically for us,

00:16:45.030 --> 00:16:47.910
but I want to do it at the start of
the animation so that I can start

00:16:47.910 --> 00:16:51.140
with just the remaining content
right to the window and smoothly

00:16:51.140 --> 00:16:53.940
interpolate that to my new target frame.

00:16:55.220 --> 00:16:58.100
Next thing we want to do is figure out
how much space we have to work with.

00:16:58.240 --> 00:17:00.900
On a multi-display system,
it's always the main screen,

00:17:00.900 --> 00:17:02.100
the screen with the menu bar.

00:17:02.100 --> 00:17:05.500
That's where windows are going to be
put when they're taken full screen.

00:17:05.500 --> 00:17:10.100
All the other displays are available for
inspectors and other auxiliary windows.

00:17:10.100 --> 00:17:11.860
So we're going to get
the size of that screen,

00:17:11.860 --> 00:17:14.100
and now we want to figure
out what window size we want.

00:17:14.100 --> 00:17:17.100
Well, we've already written a
delegate method for that,

00:17:17.110 --> 00:17:19.100
so we'll just invoke it right here.

00:17:19.150 --> 00:17:20.650
Use the code we've already written.

00:17:20.650 --> 00:17:22.520
We'll center that
rectangle on the screen,

00:17:22.600 --> 00:17:25.100
and now we just want to animate
to that new proposed frame.

00:17:25.100 --> 00:17:30.100
And I'm going to use a new,
minor new bit of API enhancement in Lion.

00:17:30.100 --> 00:17:32.100
Run animation group completion handler.

00:17:32.100 --> 00:17:35.560
This is a convenient way to
wrap a set of animated actions

00:17:35.560 --> 00:17:37.100
in a begin and end grouping.

00:17:37.100 --> 00:17:40.470
And at the same time,
specify a completion handler that will be

00:17:40.550 --> 00:17:42.900
executed after your animation completes.

00:17:43.140 --> 00:17:46.100
And it's kind of nice syntax that that
completion handler is specified later.

00:17:46.100 --> 00:17:48.100
This is the order that things happen in.

00:17:48.100 --> 00:17:50.100
So you specify the duration.

00:17:50.100 --> 00:17:53.100
We animate to the new frame
using the windows animator.

00:17:53.100 --> 00:17:56.070
And then when we're done,
we're going to clean up by restoring

00:17:56.070 --> 00:17:58.100
the windows previous window level.

00:17:58.270 --> 00:18:01.040
Last but not least,
there's a method that gets invoked if

00:18:01.040 --> 00:18:05.100
the system tries to take your window
full screen but can't for some reason.

00:18:05.100 --> 00:18:07.100
This can happen for reasons
beyond your control.

00:18:07.100 --> 00:18:10.020
Something else happens in the system
state that you have no control over.

00:18:10.210 --> 00:18:12.040
For example,
if somebody tries to take your

00:18:12.110 --> 00:18:15.100
window full screen and then
immediately switches to dashboard,

00:18:15.100 --> 00:18:17.100
that would cause this
kind of thing to happen.

00:18:17.100 --> 00:18:19.710
So you have any cleanup you need to do,
such as temporary animated

00:18:19.710 --> 00:18:21.030
windows or other resources.

00:18:21.030 --> 00:18:25.100
This would be where you do that cleanup
if you fail to enter full screen.

00:18:25.100 --> 00:18:27.100
We have nothing to do here.

00:18:27.100 --> 00:18:29.100
So I've left that empty.

00:18:29.100 --> 00:18:31.010
Now, for exiting full screen,
it's pretty much the parallel thing.

00:18:31.130 --> 00:18:32.090
Three methods.

00:18:32.090 --> 00:18:35.090
You specify which windows
you want us to use.

00:18:35.100 --> 00:18:39.800
Then there's the method that's invoked
to tell you to start your animation.

00:18:40.190 --> 00:18:41.810
And this is much simpler
than the Enter case,

00:18:41.810 --> 00:18:43.860
because I've saved the
frame I want to restore to.

00:18:44.180 --> 00:18:46.370
So I'm just going to go through.

00:18:47.450 --> 00:18:51.930
Set my windows level to be
above the main menu bar so

00:18:51.970 --> 00:18:53.560
that we can fly right over it.

00:18:53.640 --> 00:18:56.000
I'm going to set the style
mask at the beginning again.

00:18:56.000 --> 00:18:57.920
In this case,
I'm clearing the full screen window

00:18:57.920 --> 00:19:01.250
mask bit so that we can put the title
bar back right at the beginning and

00:19:01.400 --> 00:19:06.000
slide the window continuously from
that rectangle to its new rectangle.

00:19:06.000 --> 00:19:08.410
And we've saved the frame
we want to restore to,

00:19:08.410 --> 00:19:09.920
so we just animate to that.

00:19:10.090 --> 00:19:12.330
And then when we're done,
we'll restore the window's

00:19:12.330 --> 00:19:13.620
previous window level.

00:19:13.620 --> 00:19:16.300
There's one other trick in
here worth pointing out.

00:19:17.580 --> 00:19:20.200
Normally, a titled window,
when you try to set its frame,

00:19:20.200 --> 00:19:21.760
it constrains itself to the screen.

00:19:21.760 --> 00:19:24.800
And in particular,
the system prevents you from moving

00:19:24.800 --> 00:19:28.320
that top edge of the window above
the bottom edge of the menu bar

00:19:28.320 --> 00:19:30.050
or the top edge of the screen.

00:19:30.060 --> 00:19:33.470
We want to be able to defy those limits
during the course of an animation

00:19:33.480 --> 00:19:36.170
because when we're exiting full screen,
first thing we're going to do is

00:19:36.190 --> 00:19:38.370
pop that title bar back to visible,
but it's off screen,

00:19:38.370 --> 00:19:40.240
and the system's going to
try and push it back down.

00:19:40.240 --> 00:19:43.430
So we want to temporarily suspend that,
and I've done that with a

00:19:43.450 --> 00:19:44.700
simple window subclass here.

00:19:44.700 --> 00:19:46.040
I've added SKT window.

00:19:46.480 --> 00:19:49.680
That has a Boolean property we can
use to simply suspend that behavior

00:19:49.680 --> 00:19:51.490
and stop constraining to screen.

00:19:51.500 --> 00:19:54.300
And to make that work,
I'll need to make sure I go

00:19:54.300 --> 00:20:02.020
into my nib and set the
window's subclass to SKT window.

00:20:05.700 --> 00:20:10.020
Save, and Build and Run.

00:20:10.020 --> 00:20:12.670
And now we have our sketch again.

00:20:13.860 --> 00:20:15.420
Take it full screen.

00:20:15.420 --> 00:20:18.840
OK, that worked,
but that was the easy case before.

00:20:18.860 --> 00:20:20.580
Let's exit.

00:20:21.800 --> 00:20:25.980
Now let's zoom in and scroll around.

00:20:26.000 --> 00:20:27.280
Take it full screen.

00:20:27.300 --> 00:20:27.800
And there we go.

00:20:27.800 --> 00:20:30.000
We have a much smoother,
more continuous transition.

00:20:30.000 --> 00:20:33.060
So it's a little more pleasing,
puts a little more polish in the app.

00:20:33.190 --> 00:20:36.230
You can do really any kind of arbitrary
effect you can implement here.

00:20:36.240 --> 00:20:37.720
The hooks are very general.

00:20:37.800 --> 00:20:41.880
We give you the way to do whatever
kind of animation you want to do.

00:20:45.960 --> 00:20:48.120
So one of the things that we
saw there is that there's this

00:20:48.130 --> 00:20:51.600
Full Screen Window Mask that gets--
it's a bit that gets set on the window.

00:20:51.600 --> 00:20:54.010
When it's taken full screen,
that removes the title bar.

00:20:54.020 --> 00:20:57.070
This is the thing to check if you have
an NSWindow pointer and you want to say,

00:20:57.070 --> 00:20:59.100
hey, is this window in full screen mode?

00:20:59.100 --> 00:21:00.520
That's what you check for.

00:21:00.530 --> 00:21:03.450
You might also want to ask,
is the system currently showing a full

00:21:03.450 --> 00:21:05.680
screen space for any of my windows?

00:21:05.680 --> 00:21:08.380
And the way to do that is look
in the application's presentation

00:21:08.380 --> 00:21:10.520
options for this full screen flag.

00:21:10.520 --> 00:21:12.140
That'll answer that question.

00:21:12.140 --> 00:21:15.850
Lastly, auto hiding the toolbar--
really easy to do.

00:21:16.980 --> 00:21:19.050
There's an Auto Hide Toolbar
presentation option,

00:21:19.050 --> 00:21:21.730
and your chance to
provide this bit is in the

00:21:21.730 --> 00:21:24.910
Window Will Use Full Screen Presentation
Options delegate method.

00:21:25.150 --> 00:21:29.450
Just override this or that bit in with
whatever options AppKit is proposing to

00:21:29.450 --> 00:21:31.490
use for taking your window full screen.

00:21:31.510 --> 00:21:32.080
And there you go.

00:21:32.090 --> 00:21:33.960
Your toolbar will auto hide.

00:21:34.210 --> 00:21:38.400
Lastly, we provide the full complement
of Full Screen Will Enter,

00:21:38.400 --> 00:21:40.900
Did Enter, Will Exit,
Did Exit notifications

00:21:40.900 --> 00:21:43.490
that you might expect,
so that any part of your application

00:21:43.540 --> 00:21:46.880
can subscribe to these notifications
and find out when your application is

00:21:46.960 --> 00:21:50.400
transitioning into or out of full screen
mode and windows are changing state.

00:21:50.420 --> 00:21:54.890
And there are convenient window
delegate method equivalents for that.

00:21:54.950 --> 00:21:57.740
And really, that's it about full screen,
but there's a lot more to know

00:21:57.740 --> 00:22:00.400
about the new Aqua in Lion,
including popovers.

00:22:00.450 --> 00:22:02.680
And to tell you all about that,
I'm going to hand you over

00:22:02.710 --> 00:22:04.500
to my capable colleague,
Dan Schimpf.

00:22:04.540 --> 00:22:06.170
Thank you.

00:22:06.540 --> 00:22:08.180
Hi, my name is Dan Schimpf.

00:22:08.240 --> 00:22:11.040
I'm a framework engineer on
the application framework.

00:22:11.370 --> 00:22:14.440
And first thing I'm going to talk
to you today is about popovers.

00:22:14.440 --> 00:22:17.840
Now, popovers are something we've seen in
the system for a couple of releases now.

00:22:18.140 --> 00:22:20.800
There's a couple of examples here.

00:22:20.800 --> 00:22:22.910
Now,
the popovers you've seen on the Mac so

00:22:22.910 --> 00:22:24.660
far have been custom implementations.

00:22:24.660 --> 00:22:27.670
Each application you've seen
has had to do this themselves.

00:22:27.750 --> 00:22:35.710
Now, there's a standard control on the
iPad called UI Popover Controller.

00:22:36.050 --> 00:22:38.060
In Lion now, we have popovers.

00:22:38.160 --> 00:22:39.990
So what is a popover?

00:22:39.990 --> 00:22:43.260
A popover, well, loosely defined,
it's a small chunk of user

00:22:43.260 --> 00:22:44.900
interface that's on the screen.

00:22:45.010 --> 00:22:48.660
And it's actually strongly relevant
to a specific spot on screen.

00:22:48.660 --> 00:22:53.720
You click a button, it shows up,
and there's actually an arrow pointing

00:22:53.720 --> 00:22:55.960
to the point where it came from.

00:22:56.080 --> 00:22:57.940
So it's very contextual.

00:22:57.940 --> 00:23:02.000
It's a good place to have very
contextual information that

00:23:02.000 --> 00:23:02.390
the user can see right then,
because it animates.

00:23:02.710 --> 00:23:06.120
So the NS Popover is a new class
in line to allow you to do this

00:23:06.120 --> 00:23:07.920
in a standard way in your class.

00:23:07.920 --> 00:23:12.610
And again, loosely defined,
it hosts any content view

00:23:13.190 --> 00:23:16.870
relative to another view
that's already on the screen.

00:23:18.380 --> 00:23:20.170
So creating popovers is easy.

00:23:20.200 --> 00:23:23.340
A popover has an NSViewController inside.

00:23:23.380 --> 00:23:25.180
And if you haven't used
NSViewController before,

00:23:25.180 --> 00:23:27.760
it's a new class that was
in a few releases ago.

00:23:28.200 --> 00:23:31.720
And an NSViewController, well,
it controls a view.

00:23:31.740 --> 00:23:33.360
And it's a generic class.

00:23:33.360 --> 00:23:35.700
A view is usually meant to subclass.

00:23:35.710 --> 00:23:39.040
And it just encapsulates the logic
for controlling that view and

00:23:39.040 --> 00:23:40.820
whatever that view needs to do.

00:23:40.840 --> 00:23:44.820
And to help you out,
it can actually load a nib very easily,

00:23:44.840 --> 00:23:47.500
or you can programmatically
create the view.

00:23:47.530 --> 00:23:52.910
And it's just a great encapsulation for
dealing with views and modular views

00:23:52.980 --> 00:23:56.910
and all their lib-noding semantics.

00:23:56.960 --> 00:23:58.660
And it's a great class.

00:23:58.830 --> 00:24:03.480
So we've used it here to take
advantage of all those great things.

00:24:03.490 --> 00:24:06.700
And it's actually great because
you're going to want to use a new view

00:24:06.700 --> 00:24:09.000
controller for each popover that you use.

00:24:09.070 --> 00:24:11.000
So it's a great way to
use this encapsulation.

00:24:11.010 --> 00:24:13.360
And you don't have to reuse any state.

00:24:13.570 --> 00:24:16.700
So please just use a new view
controller for every popover.

00:24:16.700 --> 00:24:20.760
pop over, and that'll allow you to--

00:24:21.670 --> 00:24:25.600
and Dan Schimpf.

00:24:25.600 --> 00:24:25.600
Keep things fresh as you go along.

00:24:25.610 --> 00:24:28.330
So the popover appearances,
actually two popover appearances

00:24:28.330 --> 00:24:29.600
that are built into the kit.

00:24:29.600 --> 00:24:31.600
There's the minimal one that
you see on the screen here.

00:24:31.600 --> 00:24:33.600
That's sort of the default one
you'll see most often probably.

00:24:33.600 --> 00:24:38.810
And then there's also a HUD variant that
matches the HUD variant for Windows.

00:24:40.470 --> 00:24:42.810
Showing popovers,
there's one method to do this.

00:24:42.930 --> 00:24:45.620
Show relative to rect
of view preferred edge.

00:24:45.620 --> 00:24:48.700
Again, remember, popovers are relative
to a view on screen.

00:24:48.730 --> 00:24:50.860
So that's the view you pass in.

00:24:50.870 --> 00:24:53.780
That's the view that you
want the arrow to point to.

00:24:53.780 --> 00:24:56.440
And then you pass a
rectangle inside that view,

00:24:56.440 --> 00:24:59.140
and that's in the coordinate
space of the view.

00:24:59.170 --> 00:25:02.420
And that's just an area of that
view that we'll use to point to.

00:25:02.500 --> 00:25:05.070
So if you just have a regular
button and you just want it

00:25:05.200 --> 00:25:08.560
to come from that button,
you can pass the button's bounds in,

00:25:08.560 --> 00:25:11.240
and it'll just use the button itself.

00:25:11.270 --> 00:25:14.760
But if you have a larger view,
let's say like the iCal,

00:25:14.970 --> 00:25:28.880
and the last argument is a hint to us
to say where should the arrow come from?

00:25:28.980 --> 00:25:32.010
The top, bottom, left or right?

00:25:32.790 --> 00:25:35.200
Now, the popovers can also move.

00:25:35.200 --> 00:25:38.860
If you have an area inside of
a view and that area moves,

00:25:39.140 --> 00:25:41.290
the popover can move to match it.

00:25:41.360 --> 00:25:44.250
Now,
if it moves in a way that we can detect,

00:25:44.400 --> 00:25:47.640
say, for scrolling or the
window moving itself,

00:25:47.720 --> 00:25:52.410
we will automatically figure that
out and move the popover for you.

00:25:53.440 --> 00:25:55.930
As you can see here,
so the view is scrolling up,

00:25:55.930 --> 00:25:57.290
and the popover is moving automatically.

00:25:57.300 --> 00:25:59.100
You don't have to do anything for this.

00:25:59.170 --> 00:26:00.940
This happens automatically.

00:26:01.030 --> 00:26:03.120
But if it happens in a
way that we can't predict,

00:26:03.140 --> 00:26:07.030
let's say back in the iCal Week view,
if the user moves that

00:26:07.030 --> 00:26:09.850
event to another place,
well, we don't know that.

00:26:10.070 --> 00:26:13.390
So you have to use Set Positioning
Rect to update the original

00:26:13.390 --> 00:26:16.650
rectangle that you gave us,
and the app will move the

00:26:16.670 --> 00:26:18.610
popover to the new spot.

00:26:20.130 --> 00:26:22.900
Popovers also come with
animations on by default.

00:26:22.900 --> 00:26:25.620
It animates on screen and
animates the movement,

00:26:25.620 --> 00:26:28.030
as you saw in the last slide.

00:26:28.100 --> 00:26:31.060
So this, again, this is on by default.

00:26:31.060 --> 00:26:33.700
And that's what it looks like.

00:26:33.700 --> 00:26:35.950
So you only want to turn it off
if you have something to do that

00:26:36.050 --> 00:26:37.070
you don't want the user to see.

00:26:37.150 --> 00:26:40.650
So if you want to show the popover
before the window even comes on screen,

00:26:40.650 --> 00:26:43.120
you can turn off animations,
put the popover up,

00:26:43.120 --> 00:26:44.820
then you should turn them back on.

00:26:44.870 --> 00:26:47.930
So if you have to need to dismiss them,
the user can get the right animation.

00:26:47.980 --> 00:26:52.150
Dismissing popovers, by default,
you get the application

00:26:52.150 --> 00:26:53.180
defined behaviors.

00:26:53.200 --> 00:26:57.720
What that means is it acts like a
window that you're probably used to.

00:26:57.730 --> 00:27:02.070
You are responsible for
closing it in the default case.

00:27:02.290 --> 00:27:05.340
There's a close method,
or you can hook up a button to it.

00:27:05.340 --> 00:27:08.230
But there are also two other kinds
of behaviors that we think will

00:27:08.230 --> 00:27:10.120
solve the problem of most popovers.

00:27:10.120 --> 00:27:13.300
And you should check them out
and see if you can use them.

00:27:13.410 --> 00:27:18.560
Transient means that any click outside
of the popover will dismiss the popover.

00:27:18.620 --> 00:27:21.020
That's probably what you're used to.

00:27:21.060 --> 00:27:24.080
Any click outside of there,
the popover will go away,

00:27:24.080 --> 00:27:25.880
and it'll animate.

00:27:25.980 --> 00:27:29.430
Semi-transient is a little more sticky.

00:27:29.700 --> 00:27:32.360
There are some events
that it will let through,

00:27:32.390 --> 00:27:34.220
and it won't dismiss the popover.

00:27:34.300 --> 00:27:37.900
That's great for if you want to be
able to switch to another application

00:27:37.910 --> 00:27:43.290
or another window and be able to
refer to the contents of that popover.

00:27:43.900 --> 00:27:52.000
[Transcript missing]

00:27:53.600 --> 00:27:57.440
The one last nice thing that
Popover can do for you is detaching.

00:27:57.590 --> 00:28:00.960
So if your application allows it,
the user can drag the Popover,

00:28:01.010 --> 00:28:04.670
and it will create a standalone window
with the Popover's contents in it,

00:28:04.670 --> 00:28:06.470
which is great for inspectors.

00:28:06.500 --> 00:28:09.450
They want to have an inspector here,
and I want to drag it out and

00:28:09.700 --> 00:28:11.270
keep that inspector around.

00:28:11.350 --> 00:28:13.040
And so there's one call for that.

00:28:13.100 --> 00:28:17.030
The Popover delegate has to implement
detachable window for Popover.

00:28:17.140 --> 00:28:20.370
And what that is,
you will hand us a window with the

00:28:20.370 --> 00:28:23.280
Popover with a window for that Popover.

00:28:23.350 --> 00:28:26.240
And so you should create a new
instance of your ViewController

00:28:26.240 --> 00:28:28.440
to populate the window,
because you may need to configure it a

00:28:28.440 --> 00:28:31.040
little bit differently to stick around.

00:28:31.040 --> 00:28:32.220
So you hand us the window.

00:28:32.220 --> 00:28:33.130
Don't put it on screen.

00:28:33.170 --> 00:28:38.490
We'll put it on screen at the time
that the user has done dragging it,

00:28:38.490 --> 00:28:40.280
or at the right time.

00:28:40.470 --> 00:28:46.770
So now I'm going to do a quick demo of
how to put a popover in an application.

00:28:46.780 --> 00:28:47.760
OK.

00:28:47.870 --> 00:28:50.160
So we're actually going
to start from new project.

00:28:50.160 --> 00:28:57.770
Call it popover.

00:29:07.140 --> 00:29:10.600
So in my main menu,
I just have a standard window.

00:29:10.840 --> 00:29:11.880
Let's get up.

00:29:12.160 --> 00:29:16.320
And so what I'm going to do is
I'm going to drag out a button.

00:29:16.320 --> 00:29:17.820
And we'll call this the Info button.

00:29:17.820 --> 00:29:21.190
And this is just going to show
my fake little inspector here.

00:29:22.280 --> 00:29:24.880
The next thing I'm going to
do is search for popovers,

00:29:24.980 --> 00:29:28.590
and you'll see if I can spell popover.

00:29:29.690 --> 00:29:31.640
When I drag this out into
my top level objects,

00:29:31.740 --> 00:29:33.440
they actually create two objects.

00:29:33.440 --> 00:29:35.830
So we create the popover and
the popover view controller.

00:29:35.860 --> 00:29:38.600
So this already comes
configured out of the box,

00:29:38.790 --> 00:29:39.180
set up.

00:29:39.360 --> 00:29:47.830
So the popover-- and you can see that
the popover's connections-- I can

00:29:47.830 --> 00:29:47.830
just select one of them-- it's already
hooked up to the right view controller.

00:29:50.020 --> 00:29:52.200
And so now, I'm just going to do
everything in this nib.

00:29:52.200 --> 00:29:54.380
You'll probably find it
easier with View Controller to

00:29:54.380 --> 00:29:55.350
do it in a separate nib.

00:29:55.530 --> 00:29:59.480
But just for the purpose of this demo,
I'm going to drag out a

00:29:59.480 --> 00:30:02.380
view for the popover itself.

00:30:02.430 --> 00:30:03.400
View up.

00:30:03.400 --> 00:30:06.350
And so now this is going to be the
view that the popover is going to show.

00:30:06.360 --> 00:30:13.030
So we can see it, let's just toss some
radio buttons in there.

00:30:15.510 --> 00:30:20.960
OK, now I need to write a little bit
of code so I can show the popover.

00:30:21.010 --> 00:30:22.470
For that, up comes--

00:30:25.860 --> 00:30:27.080
So this is my application delegate.

00:30:27.080 --> 00:30:28.860
This is the class that's
gonna be controlling this.

00:30:28.860 --> 00:30:33.480
I'm gonna add an outlet for the popover,
and then we're gonna add one

00:30:33.480 --> 00:30:36.350
action to show the popover.

00:30:38.920 --> 00:30:41.340
And this is really, really simple.

00:30:41.350 --> 00:30:44.620
As you can see,
it just shows show relative to rect.

00:30:44.630 --> 00:30:47.410
And we're going to use the
bounds of the button again.

00:30:51.710 --> 00:30:54.800
Just make sure to pop that.

00:30:54.810 --> 00:30:56.040
We're going to use the
bottom of the button,

00:30:56.040 --> 00:30:58.410
and we're going to put the arrow on top.

00:30:59.400 --> 00:31:02.300
Okay, now I need to make sure to
remember to hook these up.

00:31:02.300 --> 00:31:05.790
We're gonna,
now I've hooked up the action.

00:31:09.800 --> 00:31:11.800
and I will hook up the outlet.

00:31:11.800 --> 00:31:15.960
Now,
if I remembered all my steps correctly,

00:31:15.960 --> 00:31:18.800
all of this is necessary
to show a popover.

00:31:18.990 --> 00:31:23.950
Now, by default,
this is in the application

00:31:24.100 --> 00:31:28.600
defined behavior,
so I can't -- if I'm

00:31:28.600 --> 00:31:28.800
clicking around here,
the popover stays up.

00:31:28.800 --> 00:31:28.800
So let's look at some
of the other behaviors.

00:31:30.140 --> 00:31:33.800
I'll go back to my inspector
here and change it to transient.

00:31:33.820 --> 00:31:35.790
Now, build and run.

00:31:36.890 --> 00:31:41.400
Now, if I just simply click out,
the popover closes automatically,

00:31:41.430 --> 00:31:45.680
and I can bring back
more of them as I needed.

00:31:45.740 --> 00:31:47.110
So you should experiment
with the other behaviors,

00:31:47.220 --> 00:31:49.210
see if they work for you.

00:31:51.340 --> 00:31:56.510
Certainly the users will
expect this standard behavior.

00:31:58.020 --> 00:32:00.140
and Dan Schimpf.

00:32:00.200 --> 00:32:02.300
So when do you use popovers?

00:32:02.390 --> 00:32:04.400
Popovers are great for
inline inspectors like that,

00:32:04.480 --> 00:32:06.000
although that's not a great example.

00:32:06.120 --> 00:32:08.910
They're great for little spots
on screen where you can show

00:32:08.910 --> 00:32:10.200
the properties of an object.

00:32:10.380 --> 00:32:16.890
It's great for a single metadata of UI,
let's say name or something like that.

00:32:16.940 --> 00:32:18.600
You know,
especially when something doesn't have

00:32:18.600 --> 00:32:21.200
enough space to fit in the main window,
you can just show a little bit

00:32:21.200 --> 00:32:24.070
of extra content in a popover.

00:32:25.000 --> 00:32:37.900
[Transcript missing]

00:32:38.830 --> 00:32:42.380
Inside the popover,
you'll see that there's a

00:32:42.380 --> 00:32:43.590
border all the way around it.

00:32:43.620 --> 00:32:45.760
There's a white content,
so you're not going to want

00:32:45.760 --> 00:32:49.160
to put a border around the
content inside of the popover.

00:32:49.160 --> 00:32:53.330
If you've got a scroll view or something,
don't put a border around the content.

00:32:53.340 --> 00:32:55.840
Let it go all the way to the edge.

00:32:55.920 --> 00:32:57.150
Again, keep it simple.

00:32:57.150 --> 00:32:59.990
One or two things inside are great,
especially for smaller

00:32:59.990 --> 00:33:01.180
popovers like that.

00:33:01.180 --> 00:33:03.540
You could have a larger popover,
like say instruments,

00:33:03.630 --> 00:33:05.240
and that would make more sense too.

00:33:05.800 --> 00:33:08.250
And don't put a close button in
there unless you absolutely need it.

00:33:08.340 --> 00:33:11.280
If you have a transient popover,
you don't really need a close button.

00:33:11.280 --> 00:33:14.030
But if you have an
application-defined popover,

00:33:14.140 --> 00:33:17.090
you can put a close button in
there and wire it up so the

00:33:17.380 --> 00:33:18.990
user will know how to get out.

00:33:20.370 --> 00:33:23.400
One last tip to give you,
popovers and toolbars.

00:33:23.640 --> 00:33:27.300
Popovers, if you remember,
require a rectangle and a view to show.

00:33:27.460 --> 00:33:30.110
NS Toolbar and the
action method for that,

00:33:30.230 --> 00:33:32.100
you have neither of those.

00:33:32.100 --> 00:33:36.590
The solution here is to use a custom
toolbar item with an NS button inside

00:33:36.640 --> 00:33:40.470
that looks like a toolbar item,
and then you get a button with a

00:33:40.470 --> 00:33:45.070
view and you can get a rectangle,
and so you can show a popover from that.

00:33:45.070 --> 00:33:47.430
If you want to show a
popover from a toolbar item,

00:33:47.430 --> 00:33:47.430
that's the solution to do.

00:33:47.920 --> 00:33:49.340
So that's popovers.

00:33:49.660 --> 00:33:54.700
Now I want to talk a little bit about the
changes you've no doubt noticed in Lion.

00:33:56.070 --> 00:33:58.110
So Aqua, what is Aqua?

00:33:58.180 --> 00:34:01.480
Aqua is the look and feel of Mac OS X.

00:34:01.680 --> 00:34:06.650
It covers both the appearance and the
behavior of the user interface controls.

00:34:06.660 --> 00:34:09.280
You've probably heard this in
a couple of different talks,

00:34:09.410 --> 00:34:10.550
like the term Aqua.

00:34:10.800 --> 00:34:13.890
And if you've been
around to the platform,

00:34:14.480 --> 00:34:19.090
and a while, you'll remember what
Aqua used to look like.

00:34:19.150 --> 00:34:21.140
It used to evoke more Aquaness.

00:34:21.260 --> 00:34:24.480
There used to be more blue,
there's more pills.

00:34:24.480 --> 00:34:28.730
There was a lot more Aqua-y things.

00:34:28.800 --> 00:34:29.680
and Dan Schimpf.

00:34:29.750 --> 00:34:32.700
But here we are now in 10.7,
and things are a little bit different.

00:34:32.700 --> 00:34:37.060
They're more gray, they're more subtle,
they're a lot flatter,

00:34:37.060 --> 00:34:39.060
there's more soft features.

00:34:40.090 --> 00:34:41.700
And Aqua is no different.

00:34:41.700 --> 00:34:43.760
There are more changes in line.

00:34:43.760 --> 00:34:46.510
What we've done is we've
refreshed many of the controls.

00:34:46.640 --> 00:34:50.020
So some things that have been
around for several releases now

00:34:50.050 --> 00:34:52.760
without any changes are different.

00:34:52.760 --> 00:34:55.040
If you're a developer,
you'll notice that some controls

00:34:55.040 --> 00:34:56.660
have more transparency than before.

00:34:56.660 --> 00:34:58.710
Now,
the user won't necessarily notice this,

00:34:58.870 --> 00:35:00.700
but if you're trying
to use custom controls,

00:35:00.700 --> 00:35:03.300
you probably will if you haven't already.

00:35:03.350 --> 00:35:06.890
And there's more context-specific
appearances these controls can get into.

00:35:06.970 --> 00:35:10.550
And what I mean by that is that,
on the big matrix of states

00:35:10.700 --> 00:35:15.390
that a button can get into,
more of those spots have a specific,

00:35:15.390 --> 00:35:17.060
unique appearance.

00:35:17.340 --> 00:35:20.630
So inactive, pressed,
all these things have more specific,

00:35:20.630 --> 00:35:23.170
unique appearances that you may
need to be aware of when you're

00:35:23.280 --> 00:35:27.140
implementing a custom control,
just so it matches the built-in ones.

00:35:27.180 --> 00:35:31.080
Again, these changes were meant to
focus the user attention on

00:35:31.080 --> 00:35:33.090
the active window content.

00:35:33.300 --> 00:35:35.640
So background windows fade out.

00:35:35.730 --> 00:35:39.400
They get a lot lighter and more subtle.

00:35:39.400 --> 00:35:42.080
And even the surrounding
content of your active window,

00:35:42.080 --> 00:35:46.200
like the toolbar and your sidebar things,
a lot of the color was taken out of

00:35:46.200 --> 00:35:50.540
that to focus on the active window,
the content of your active window,

00:35:50.620 --> 00:35:52.640
so where you're actually doing your work.

00:35:52.640 --> 00:35:55.640
And so everything else
is not as distracting.

00:35:56.440 --> 00:35:57.300
Textured controls.

00:35:57.300 --> 00:36:00.340
I mentioned that some controls
have more transparency,

00:36:00.340 --> 00:36:02.640
and this is where you'll probably see it.

00:36:02.710 --> 00:36:05.600
So some controls have
so-called textured appearances,

00:36:05.600 --> 00:36:06.720
buttons and such.

00:36:06.880 --> 00:36:11.050
And these were intended for
use on a textured background.

00:36:11.110 --> 00:36:15.050
Textured used to mean metal,
if you remember back in the day,

00:36:15.050 --> 00:36:17.590
when textured windows
were first introduced.

00:36:17.610 --> 00:36:20.520
You might say, well,
that's a funny way to say metal,

00:36:20.520 --> 00:36:21.900
because they look metal.

00:36:21.900 --> 00:36:24.450
But what we really meant
is that these controls,

00:36:25.040 --> 00:36:27.530
the textured controls are meant to
be used on a textured background,

00:36:27.680 --> 00:36:30.060
and they just happen to
be metal at the time.

00:36:30.060 --> 00:36:35.370
So now they happen to be transparent,
because that's what shows the background

00:36:35.500 --> 00:36:37.970
of the new textured windows the best.

00:36:42.400 --> 00:36:45.500
So if you're using, let's say,
a round textured button in sort of a

00:36:45.510 --> 00:36:48.860
background where you're going to see a
big bright color or something other than,

00:36:48.960 --> 00:36:52.580
again, the window background,
you may get something like this now.

00:36:52.580 --> 00:36:54.480
And that's probably not
what you want to be seeing.

00:36:54.570 --> 00:36:56.750
Because again,
these buttons are best for use

00:36:56.820 --> 00:36:59.420
in the toolbar or against any
sort of other window Chrome.

00:36:59.420 --> 00:37:00.220
And that's where they look better.

00:37:00.220 --> 00:37:02.810
They don't actually look
transparent in that case.

00:37:02.910 --> 00:37:05.310
So you might want to use a
different kind of button instead.

00:37:05.320 --> 00:37:09.700
Maybe the round back button works
great in table views and those places

00:37:09.720 --> 00:37:11.930
like that where you may be using them.

00:37:13.560 --> 00:37:16.310
Inactive controls, another area where we
see a lot of change.

00:37:16.420 --> 00:37:21.550
So again, many controls now have unique
appearances for their inactive states

00:37:21.560 --> 00:37:24.500
that you may not have seen before.

00:37:24.500 --> 00:37:27.400
And so if you have a custom control,
you probably want to match this.

00:37:27.400 --> 00:37:31.510
And a good way to know if your window is
inactive is just to check if it's key,

00:37:31.510 --> 00:37:35.780
because that also works for if the
application itself is inactive.

00:37:35.780 --> 00:37:38.770
But it's important to know that
although the buttons look different,

00:37:38.770 --> 00:37:41.020
they're still usable in the background.

00:37:41.020 --> 00:37:42.820
There's not an actual
usability change here.

00:37:42.820 --> 00:37:44.580
This is just an appearance change.

00:37:44.630 --> 00:37:49.380
So buttons are still-- if the
buttons could be used on first click,

00:37:49.380 --> 00:37:50.810
that is still the case now.

00:37:50.820 --> 00:37:51.620
That hasn't changed.

00:37:51.740 --> 00:37:54.820
So it's just an appearance change.

00:37:54.920 --> 00:37:58.120
So how do we indicate that a button
can be used in the background?

00:37:58.180 --> 00:38:01.330
Well, we're using rollovers a
lot in toolbars for this.

00:38:01.530 --> 00:38:04.100
You'll see this is a
movie of the mail toolbar.

00:38:04.160 --> 00:38:07.820
And you can see when you're rolling
over the toolbar items that the

00:38:07.820 --> 00:38:10.900
button glyph itself highlights.

00:38:11.470 --> 00:38:22.350
and the best thing about this session is
that it's a little bit more intuitive.

00:38:22.350 --> 00:38:26.750
The bezel itself is only
indicating the window state.

00:38:26.750 --> 00:38:26.750
And the glyph itself is
indicating the button state.

00:38:26.750 --> 00:38:26.750
And again, this is just so

00:38:27.030 --> 00:38:30.420
You have to be careful with rollovers
because you don't want users to

00:38:30.420 --> 00:38:33.220
be rolling their mouse across the
screen and seeing just a ton of

00:38:33.220 --> 00:38:35.620
stuff changing in their mouse,
just like a carnival,

00:38:35.620 --> 00:38:36.960
like a sparkly mouse.

00:38:37.060 --> 00:38:41.610
Unless you want a sparkly mouse,
but not all users want sparkly mice.

00:38:41.620 --> 00:38:45.290
So rollovers, again,
just indicate when the mouse is overhead,

00:38:45.370 --> 00:38:48.060
and it gives a soft,
subtle effect to say, hey,

00:38:48.130 --> 00:38:49.710
if you click here,
something's going to happen.

00:38:49.720 --> 00:38:52.720
And so if you've got a custom control,
the best way to do this

00:38:52.720 --> 00:38:54.180
is with NSTrackingArea.

00:38:55.020 --> 00:38:57.910
It was introduced a couple releases ago,
and it's a great way to

00:38:58.000 --> 00:39:01.490
find out in simple mouse
entering or exiting messages.

00:39:04.980 --> 00:39:08.290
So on that last screen,
you saw the glyph highlight.

00:39:08.310 --> 00:39:10.300
Well, did we have two different
images for that?

00:39:10.300 --> 00:39:10.770
Well, no.

00:39:10.900 --> 00:39:12.650
Actually, we just had one image.

00:39:12.760 --> 00:39:14.200
It's called an image template.

00:39:14.200 --> 00:39:19.490
And AppKit is processing the
image into different states.

00:39:20.400 --> 00:39:22.600
for-- that's appropriate for the context.

00:39:22.600 --> 00:39:26.310
So this is the image template for,
let's say, a lock icon.

00:39:26.460 --> 00:39:28.880
And so you can see it's
just a black image.

00:39:28.920 --> 00:39:32.440
And App can see-- App replaces the
black areas or other areas like

00:39:32.440 --> 00:39:35.650
that just with a softer color,
or you'll see there's more

00:39:35.650 --> 00:39:37.500
effects that we can do with that.

00:39:37.650 --> 00:39:40.500
And if you're already using this because
this is not something that's new,

00:39:40.500 --> 00:39:42.640
if you're already using these,
you get updated to the

00:39:42.640 --> 00:39:43.920
new effects automatically.

00:39:43.990 --> 00:39:45.500
So how do you make your image template?

00:39:45.500 --> 00:39:47.860
Well, grayscale images are best.

00:39:47.870 --> 00:39:51.800
And PDS,
we recommend PDS for scaling purposes.

00:39:51.800 --> 00:39:55.280
So you get high resolution-- you
get high DPI support for free with

00:39:55.280 --> 00:39:58.310
PDS because they'll scale infinitely.

00:39:58.790 --> 00:40:01.700
So when you're designing your image,
if you say you have a color icon and you

00:40:01.700 --> 00:40:05.640
want to make an image template out of it,
think about the shadow it

00:40:05.640 --> 00:40:09.310
would cast and use that.

00:40:09.710 --> 00:40:11.520
You don't want to just invert it.

00:40:11.600 --> 00:40:13.670
You want to just drain
all the color out of it,

00:40:13.680 --> 00:40:15.990
but think about how it would look.

00:40:16.230 --> 00:40:19.870
Especially, look how-- because sometimes,
we'll need to invert that icon,

00:40:19.870 --> 00:40:21.840
make it all white on certain backgrounds.

00:40:21.840 --> 00:40:24.570
Let's say,
after something's been selected,

00:40:24.660 --> 00:40:25.240
it'll be all white.

00:40:25.320 --> 00:40:28.060
So think about the different
states it's going to be in,

00:40:28.130 --> 00:40:30.540
and try it out.

00:40:30.590 --> 00:40:34.400
And also consider, new in line,
the user can select different

00:40:34.940 --> 00:40:37.600
source list styles or icon sizes.

00:40:37.630 --> 00:40:41.910
So if you've got an icon,
make sure you know how it scales.

00:40:42.520 --> 00:40:45.580
So to set these templates,
the best way to set the templates,

00:40:45.670 --> 00:40:49.770
if you're loading it from a file,
the file has template at the end of it.

00:40:49.780 --> 00:40:53.680
So let's say like lock
template dot tiff or dot PDF.

00:40:53.740 --> 00:40:55.130
We'll notice that,
and it'll automatically

00:40:55.140 --> 00:40:56.590
mark it as a template.

00:40:56.870 --> 00:40:58.730
The other way you can do it if
you already have something loaded

00:40:58.730 --> 00:41:03.070
is call image set template,
and that will mark it as a template.

00:41:03.800 --> 00:41:09.370
So drawing templates, again,
we need more context about your situation

00:41:09.440 --> 00:41:11.500
versus just regular image drawing.

00:41:11.680 --> 00:41:15.030
So button cell and image
cell give us this context,

00:41:15.030 --> 00:41:17.950
because button cell knows
if it's being pressed,

00:41:18.030 --> 00:41:19.740
that sort of thing.

00:41:19.780 --> 00:41:22.810
And you give it a view that
we can tell whether or not

00:41:22.850 --> 00:41:24.500
the window is active or not.

00:41:24.660 --> 00:41:26.190
So use button cell for
interactive elements,

00:41:26.290 --> 00:41:29.060
buttons that can be pressed, obviously,
and image cell for static

00:41:29.060 --> 00:41:31.090
elements like icons and such.

00:41:31.210 --> 00:41:33.950
And remember to set the background
style on the cell before you draw it.

00:41:33.960 --> 00:41:37.090
And we'll talk about background
styles more in a second.

00:41:37.440 --> 00:41:40.930
So here's just a quick example
of the same image template,

00:41:40.930 --> 00:41:44.630
that lock icon,
in a number of different states, active,

00:41:44.630 --> 00:41:46.350
inactive.

00:41:46.480 --> 00:41:48.850
As you can see, just one image gets you
all of these images,

00:41:48.850 --> 00:41:50.820
other images for free.

00:41:50.890 --> 00:41:54.890
And you get updated to new
appearances as the system changes.

00:41:55.730 --> 00:41:57.010
So background styles.

00:41:57.160 --> 00:41:58.540
What are the background styles?

00:41:58.650 --> 00:42:03.790
Well, background style is a
hint to us and to you

00:42:04.030 --> 00:42:05.480
How your custom content should be drawn.

00:42:05.570 --> 00:42:10.550
So it sort of describes the background
that you're drawing your content onto.

00:42:11.230 --> 00:42:14.560
And then you can take appropriate
steps to change what you need to do.

00:42:14.630 --> 00:42:18.470
And this includes
drawing images and text.

00:42:18.600 --> 00:42:21.740
And again, if you're using them already,
existing clients are

00:42:21.740 --> 00:42:23.320
updated automatically.

00:42:24.380 --> 00:42:27.250
So here's a couple of-- there's four
different background styles-- raised,

00:42:27.250 --> 00:42:28.880
lowered, light, and dark.

00:42:29.030 --> 00:42:31.330
And here's some example context
in which they can be used,

00:42:31.440 --> 00:42:33.600
but this is not exhaustive.

00:42:33.630 --> 00:42:35.450
It, again, is meant to be more general.

00:42:35.590 --> 00:42:42.180
So it just happens to be that raised
happens to be appropriate here.

00:42:42.180 --> 00:42:47.790
So raised means my glyph is--
the background is raised relative

00:42:47.790 --> 00:42:49.560
to the glyph that it's drawing.

00:42:49.730 --> 00:42:52.710
So you get sort of an engraved effect.

00:42:53.200 --> 00:43:08.200
[Transcript missing]

00:43:10.900 --> 00:43:16.230
So in GraveText, new in Lion,
you can do the same thing for text now.

00:43:16.320 --> 00:43:20.890
And if you're using a text field or text
field cell to draw your control text,

00:43:20.910 --> 00:43:23.490
you get the new behavior,
the new look for text

00:43:23.600 --> 00:43:26.080
in an inactive window,
for example.

00:43:26.080 --> 00:43:28.120
And again, if you're using text
field cell to do this,

00:43:28.120 --> 00:43:30.040
you get updated automatically.

00:43:30.080 --> 00:43:34.320
But you may need to be aware of-- you
may want to be able to redraw your view

00:43:34.320 --> 00:43:39.030
when the window goes inactive so the
view can update and draw the correct

00:43:39.100 --> 00:43:41.900
appearance when the window goes inactive.

00:43:42.780 --> 00:43:45.240
So again, here's just an example
of some engraved text.

00:43:45.240 --> 00:43:47.740
That's an example on
Snow Leopard and Lion.

00:43:47.740 --> 00:43:51.310
It may be a little bit hard to pick out,
but there's actually a gradient

00:43:51.350 --> 00:43:54.790
in the background of that text.

00:43:57.600 --> 00:43:59.740
So I'm going to do a quick demo here.

00:43:59.760 --> 00:44:05.860
I'm going to open this application,
which it's a bad example of a

00:44:05.860 --> 00:44:07.760
Snow Leopard error application.

00:44:07.760 --> 00:44:08.980
We've got a sidebar here.

00:44:08.980 --> 00:44:10.060
We've got a toolbar item.

00:44:10.060 --> 00:44:11.820
We've got some status text down here.

00:44:11.840 --> 00:44:13.940
Now, your applications look
a lot better than this,

00:44:13.940 --> 00:44:14.500
trust me.

00:44:14.520 --> 00:44:18.930
But this will just be an example
of how we can make it better.

00:44:20.130 --> 00:44:23.340
So let's look at this
status text down here,

00:44:23.380 --> 00:44:26.010
and I'll see if we can make that better.

00:44:27.290 --> 00:44:31.030
We're going to update to use
the new engraved text in Lion.

00:44:31.130 --> 00:44:35.510
So we're going to replace this indicator
string and image with cell drawing.

00:44:40.930 --> 00:44:42.900
So I'm going to take out the points.

00:44:42.900 --> 00:44:46.140
I'm going to initialize it
and replace that with cells.

00:44:47.220 --> 00:44:51.150
And notice that I'm setting the
background style here to raised to match

00:44:51.290 --> 00:44:54.710
the context in which it's being drawn.

00:45:00.400 --> 00:45:01.690
and I'm going to change the drawing code.

00:45:01.710 --> 00:45:04.990
This will actually get shorter
because the cells will do a lot

00:45:04.990 --> 00:45:07.430
of the work that I'm doing here.

00:45:10.900 --> 00:45:14.240
So now you can see that we've
got the template drawing

00:45:15.150 --> 00:45:19.370
for the image and the text.

00:45:19.380 --> 00:45:21.780
Let's see if we can-- we cannot.

00:45:21.980 --> 00:45:23.040
We cannot zoom up on that.

00:45:23.040 --> 00:45:26.350
But there's the correct template
drawing on the text as well.

00:45:27.770 --> 00:45:31.530
Now I notice if I click over here, well,
we've got these round textured buttons,

00:45:31.530 --> 00:45:35.290
and this could be better.

00:45:35.370 --> 00:45:37.170
So let's look at the cell.

00:45:39.400 --> 00:45:42.910
I'm going to switch this, the icon,
the image drawing on the left

00:45:43.110 --> 00:45:45.540
over to be an image cell.

00:45:48.460 --> 00:45:49.690
I'll jump down here.

00:45:49.700 --> 00:45:50.480
It's being drawn.

00:45:50.500 --> 00:45:53.380
This is a regular NS image.

00:45:53.380 --> 00:45:55.630
Let me grab an image cell.

00:46:08.110 --> 00:46:09.400
So now I've got an image cell.

00:46:09.480 --> 00:46:12.960
I'm setting the background
style to whatever my style is,

00:46:13.010 --> 00:46:14.950
because this is an NSCell subclass.

00:46:15.070 --> 00:46:18.400
So the table view is going to set the
appropriate background style on me,

00:46:18.400 --> 00:46:23.400
and then I can pass that along
to the cells that I'm drawing.

00:46:23.480 --> 00:46:24.000
So now we build.

00:46:24.000 --> 00:46:26.750
We see that when I click on--

00:46:28.600 --> 00:46:32.470
and Awesome.

00:46:32.590 --> 00:46:34.990
Oh, you know what I forgot?

00:46:35.000 --> 00:46:37.760
Cell copy.

00:46:37.760 --> 00:46:42.030
Always remember to update
your copy with zone for NSLs.

00:46:43.560 --> 00:46:46.750
OK, now when I click on it,
you'll see that the icon inverts to

00:46:46.750 --> 00:46:50.180
indicate that the row has been selected,
and it's a better appearance

00:46:50.180 --> 00:46:51.350
against the darker background.

00:46:51.490 --> 00:46:53.590
But I've still got this
round textured button.

00:46:53.880 --> 00:46:56.930
So let's go back and just change
it to a round rect button.

00:46:59.820 --> 00:47:02.630
Textured Rounded to Round Direct.

00:47:02.710 --> 00:47:06.140
And now I've got a button
that doesn't become unreadable

00:47:06.140 --> 00:47:08.210
when the user selects it.

00:47:08.470 --> 00:47:10.020
So one last thing,
I'm going to look at this.

00:47:10.160 --> 00:47:14.590
This is a toolbar item with
just a regular image in it.

00:47:14.630 --> 00:47:18.830
But what I can do-- let's go here.

00:47:23.100 --> 00:47:23.940
Let's look at this.

00:47:23.940 --> 00:47:27.610
I actually have a template
version of this icon.

00:47:27.620 --> 00:47:31.360
In IB, it goes all black,
but when I run it,

00:47:31.380 --> 00:47:34.380
now we get the nice engraved
appearance for the toolbar that

00:47:34.380 --> 00:47:38.200
also works when I go inactive.

00:47:38.800 --> 00:47:41.370
So just a few simple things that
you can do to your application

00:47:41.980 --> 00:47:45.560
to make it fit in better with
the standard controls on Lion.

00:47:45.580 --> 00:47:47.000
Okay, that's all from me.

00:47:47.000 --> 00:47:49.230
Now I'm going to turn it over to
my colleague Patrick to talk about

00:47:49.230 --> 00:47:50.640
resolution independence on Lion.

00:47:53.400 --> 00:47:56.950
Good morning.

00:47:57.410 --> 00:48:00.480
My name is Patrick Heynen,
and I'm here to talk about the pixel.

00:48:00.480 --> 00:48:05.600
So, over the last decade,
LCD display technology has become

00:48:05.600 --> 00:48:08.160
quite pervasive and is the predominant
way in which computer graphic

00:48:08.190 --> 00:48:09.490
content is presented to users.

00:48:09.540 --> 00:48:12.640
Along the way,
because of the way it's manufactured,

00:48:12.640 --> 00:48:16.130
Moore's Law has enabled us to make
it just as easy to pack a whole

00:48:16.130 --> 00:48:19.990
bunch more pixels onto the same
piece of glass as less pixels.

00:48:20.720 --> 00:48:23.240
So, there's general agreement
that in the course of time,

00:48:23.240 --> 00:48:24.900
the future of the pixel is small.

00:48:24.900 --> 00:48:28.200
Now, this, of course,
presents tremendous challenges

00:48:28.200 --> 00:48:31.520
for software compatibility,
because if we were to

00:48:31.520 --> 00:48:34.960
just proceed as usual,
we would end up with really tiny user

00:48:34.960 --> 00:48:38.980
interface elements that our eyes,
which are not conforming to Moore's Law,

00:48:38.980 --> 00:48:41.790
would not be able to
really perceive very well.

00:48:41.800 --> 00:48:43.090
So, what do we do?

00:48:43.210 --> 00:48:45.310
Well, our colleagues over in
iOS have had too much fun,

00:48:45.310 --> 00:48:47.610
and we'd like to take some of
that stuff back to the Mac.

00:48:47.840 --> 00:48:51.410
So, I'm here to talk about some
exciting updates to our

00:48:51.590 --> 00:48:55.780
architecture for resolution
independence for Mac OS X line.

00:48:56.010 --> 00:48:58.640
First and foremost,
what we're basically going to do

00:48:58.640 --> 00:49:01.950
is take the device-independent
drawing model that we have already,

00:49:01.950 --> 00:49:04.720
the Core Graphics API that
you may have seen,

00:49:04.720 --> 00:49:08.270
and extend it down to the levels
of the screens themselves.

00:49:08.280 --> 00:49:11.500
What this means is that no matter
what the size of the screen

00:49:11.500 --> 00:49:14.950
and how many pixels it has,
the sizing of that screen is going

00:49:14.950 --> 00:49:17.450
to be now expressed in points,
not pixels.

00:49:17.460 --> 00:49:20.400
And the content will
be scaled accordingly.

00:49:21.200 --> 00:49:24.200
Now,
one important consequence of this is that

00:49:24.300 --> 00:49:29.140
units that used to be measured in pixels,
such as event, window global coordinates,

00:49:29.250 --> 00:49:31.690
or window frame coordinates,
event coordinates, mouse coordinates,

00:49:31.690 --> 00:49:33.760
are now all going to
be expressed in points,

00:49:33.760 --> 00:49:36.790
not pixels,
independent of the characteristics

00:49:36.790 --> 00:49:38.900
of the screen that they're on.

00:49:40.920 --> 00:49:43.610
So how are we going to
expose this in the system?

00:49:43.620 --> 00:49:46.220
Well,
we're introducing the concept of these

00:49:46.270 --> 00:49:50.120
new high resolution display modes,
which a display might have.

00:49:50.300 --> 00:49:54.000
And you will notice it's described in
a way that the sizing of that display

00:49:54.000 --> 00:49:56.620
is now not expressed in pixels,
but it's merely expressed in

00:49:56.620 --> 00:49:57.910
a sort of standard point size.

00:49:58.000 --> 00:50:00.100
But it may have a higher
resolution backing,

00:50:00.100 --> 00:50:05.260
which we indicate currently
with this sort of high DPI tag.

00:50:05.260 --> 00:50:08.800
Another, and perhaps the most
significant update we have,

00:50:08.800 --> 00:50:12.660
is that we're focusing on
integral scaling per screen.

00:50:12.660 --> 00:50:16.740
And these high DPI display modes
are actually configured with a

00:50:16.840 --> 00:50:19.000
two to one pixel per point ratio.

00:50:19.290 --> 00:50:23.440
which makes the software
compatibility a lot better.

00:50:23.600 --> 00:50:25.640
Okay, so what does this mean for
user interface scaling?

00:50:25.640 --> 00:50:29.500
Well, the best part about it is that
for most Cocoa applications,

00:50:29.600 --> 00:50:31.560
the user interface scaling
is absolutely automatic,

00:50:31.560 --> 00:50:33.140
and you don't have to do a thing.

00:50:33.260 --> 00:50:33.930
What does this mean?

00:50:34.030 --> 00:50:35.200
How does this work?

00:50:35.330 --> 00:50:38.060
Well, first and foremost,
Windows automatically gain

00:50:38.060 --> 00:50:42.680
high-resolution backing stores,
which results in twice as much pixel

00:50:42.680 --> 00:50:46.770
density and twice as much-- well,
twice is kind of four times, I guess,

00:50:46.770 --> 00:50:50.940
technically, mathematically-- higher
detail for both regular quartz

00:50:50.940 --> 00:50:53.780
drawing and text rendering,
of course, which, of course,

00:50:53.900 --> 00:50:55.340
is the killer feature
for high-resolution,

00:50:55.340 --> 00:50:59.710
is that super sharp, crisp,
absolutely beautiful text.

00:51:00.070 --> 00:51:02.950
And the new Aqua, which my colleague
Dan was describing to you,

00:51:02.950 --> 00:51:05.760
has actually been engineered to take
advantage of all available pixels,

00:51:05.760 --> 00:51:08.390
should they be present,
and provide a much higher

00:51:08.390 --> 00:51:10.300
quality rendering if possible.

00:51:10.340 --> 00:51:13.380
So here we go,
and we'll see an example here going

00:51:13.380 --> 00:51:18.050
from low resolution 1x to absolutely
beautiful high resolution 2x.

00:51:18.120 --> 00:51:19.180
I can look at this all day.

00:51:19.460 --> 00:51:23.660
And you'll notice that the template
drawing that my colleague Dan was

00:51:23.710 --> 00:51:26.460
describing automatically provides
a higher quality rendering,

00:51:26.460 --> 00:51:29.050
much nicer interglows and
shadows and all that stuff,

00:51:29.250 --> 00:51:30.360
perfectly automatically for you.

00:51:30.360 --> 00:51:32.340
You don't have to do a thing.

00:51:33.000 --> 00:51:35.800
Okay,
so what does this really mean for Cocoa?

00:51:35.800 --> 00:51:39.970
What does the world look like for
Cocoa applications running in this mode?

00:51:39.980 --> 00:51:42.370
Well,
for things that are not court-strong,

00:51:42.370 --> 00:51:46.390
like, say, bitmap image resources,
they're automatically interpolated to

00:51:46.470 --> 00:51:50.490
the appropriate user presentation size,
which means that they may be fuzzy,

00:51:50.490 --> 00:51:53.170
but they will be correct,
which is important.

00:51:53.180 --> 00:51:56.180
And view frame coordinates
and layout remain absolutely

00:51:56.610 --> 00:52:00.200
consistent with the 1x operation,
so absolutely nothing really changes

00:52:00.200 --> 00:52:03.300
from the view of your software when
thinking about the coordinate system,

00:52:03.300 --> 00:52:05.580
the user local coordinate system,
and the view coordinate system.

00:52:05.580 --> 00:52:10.880
OpenGL frame buffer content is also
kept consistent with 1x operation.

00:52:10.880 --> 00:52:13.060
Low resolution content is maintained.

00:52:13.060 --> 00:52:17.710
Your OpenGL code sees the
same kind of backing context,

00:52:17.820 --> 00:52:21.720
and the resulting content is magnified
automatically to the display at the

00:52:21.720 --> 00:52:23.190
appropriate user presentation size.

00:52:23.200 --> 00:52:25.480
An important change,
very good and important for

00:52:25.580 --> 00:52:27.800
compatibility of existing applications.

00:52:28.850 --> 00:52:32.630
Now, we have kept one of our most
popular features of our previous

00:52:32.690 --> 00:52:35.910
editions of resolution independence,
which is the magnified mode.

00:52:35.940 --> 00:52:37.560
What is magnified mode?

00:52:37.560 --> 00:52:41.090
Well, in magnified mode,
window buffers can stay,

00:52:41.180 --> 00:52:45.020
get created at low resolution sizes
and don't change from what they would

00:52:45.020 --> 00:52:48.470
be on normal low resolution displays,
and the window contents themselves,

00:52:48.520 --> 00:52:51.100
after they're drawn,
are scaled to the right

00:52:51.240 --> 00:52:52.550
size on the display.

00:52:52.560 --> 00:52:56.170
This is an important backstop
for applications that,

00:52:56.250 --> 00:52:58.510
due to bugs or bad
assumptions about the display,

00:52:58.520 --> 00:52:58.720
are not able to be
created at the right size.

00:52:58.740 --> 00:53:01.980
So, the users that are out there
drawing environment are unable

00:53:01.980 --> 00:53:05.300
to provide a good user experience
with the default scaling mode,

00:53:05.300 --> 00:53:07.850
and so we kick them into
this magnified mode.

00:53:07.860 --> 00:53:10.570
The important thing is that this
provides perfect compatibility

00:53:10.570 --> 00:53:12.160
for a large class of applications.

00:53:12.160 --> 00:53:15.450
Now,
how do you actually optimize and provide

00:53:15.450 --> 00:53:21.040
the best possible user experience
for this high-resolution environment?

00:53:21.040 --> 00:53:23.470
Well,
the most important thing you can do,

00:53:23.480 --> 00:53:26.040
and we recommend you do,
is provide high-resolution

00:53:26.040 --> 00:53:28.520
image resources for any static
bitmap content you may have,

00:53:28.580 --> 00:53:30.390
and your user interface
or user-facing content.

00:53:30.400 --> 00:53:35.230
To facilitate this process,
we're taking a page off the ILS book

00:53:35.300 --> 00:53:39.030
and adopting the sort of naming
convention for image resources of

00:53:39.090 --> 00:53:42.080
at2x and foo.ping and foo.at2x.ping.

00:53:42.080 --> 00:53:47.260
We're going one minor step further
and added a special feature to

00:53:47.260 --> 00:53:50.520
Xcode to actually automatically
combine these image resources

00:53:50.520 --> 00:53:54.050
into a single multi-page TIFF for
optimal runtime deployment usage,

00:53:54.060 --> 00:53:56.390
so we don't have all these files
laying around on disk and so things

00:53:56.390 --> 00:53:57.620
are a little more manageable.

00:53:58.420 --> 00:54:00.610
In addition,

00:54:00.860 --> 00:54:02.940
PDF templates,
as my colleague Dan mentioned,

00:54:02.940 --> 00:54:08.070
are a great way to automatically achieve,
you know, rasterization independence,

00:54:08.150 --> 00:54:09.960
resolution independence for button icons.

00:54:09.960 --> 00:54:13.750
And lastly,
one area that you'll need to focus

00:54:13.750 --> 00:54:17.390
on is adapting any OpenGL and
Core Animation code for this

00:54:17.390 --> 00:54:18.740
high-resolution environment.

00:54:18.740 --> 00:54:21.570
Now, let's talk about OpenGL and
Core Animation for a little bit,

00:54:21.570 --> 00:54:23.420
because they're a little bit special.

00:54:24.420 --> 00:54:27.080
OpenGL and, to a lesser extent,
Core Animation are inherently

00:54:27.080 --> 00:54:30.770
pixel-based technologies and provide
abstractions upon a very thin level of

00:54:30.770 --> 00:54:32.610
abstraction upon a raw frame buffer.

00:54:32.620 --> 00:54:35.510
So they're really kind of hard to
virtualize in the same way that,

00:54:35.510 --> 00:54:36.870
say, the Quartz model is.

00:54:36.940 --> 00:54:41.020
Because of this, just like on iOS,
applications are going to need to

00:54:41.020 --> 00:54:45.680
request high-resolution backing surfaces,
because typical OpenGL code isn't

00:54:45.680 --> 00:54:49.080
going to be surprised if they
suddenly find four times as many

00:54:49.080 --> 00:54:51.820
pixels as they're drawing into,
given the nature of the OpenGL APIs.

00:54:51.820 --> 00:54:53.850
To do this, we've introduced a new API.

00:54:54.400 --> 00:54:56.810
NSU set wants best
resolution OpenGL surface.

00:54:56.890 --> 00:54:57.220
Yes.

00:54:57.380 --> 00:54:59.860
If you say yes,
on a particular-- you can do

00:54:59.860 --> 00:55:02.000
this on a view-by-view basis,
so you can, you know,

00:55:02.000 --> 00:55:03.810
you can make the choice
on a per-view basis.

00:55:03.860 --> 00:55:05.840
It'll get-- when the
view gets constructed,

00:55:05.850 --> 00:55:08.350
when the surface gets constructed,
it'll get constructed

00:55:08.410 --> 00:55:10.780
with twice as many pixels,
four times as many pixels.

00:55:10.780 --> 00:55:15.760
And your OpenGL viewport and
Model-V transform code can get-- can

00:55:15.760 --> 00:55:19.170
need to be modified accordingly to
provide the appropriate rendering.

00:55:19.180 --> 00:55:22.250
Custom Core Animation layers,
just like on iOS,

00:55:22.250 --> 00:55:24.360
need to have an explicit scale factor.

00:55:24.360 --> 00:55:26.850
So, if you're using a layer set
for any custom content that

00:55:26.850 --> 00:55:29.000
you might be storing on them,
that these-- that's the

00:55:29.000 --> 00:55:30.060
content scale property.

00:55:30.080 --> 00:55:33.570
But of course, if you're using
AppKit layer-backed NS views,

00:55:33.570 --> 00:55:36.560
we do all this housekeeping
and management for you,

00:55:36.570 --> 00:55:37.800
so you don't have to worry about it.

00:55:37.800 --> 00:55:41.110
So, we encourage you to use
those when necessary,

00:55:41.110 --> 00:55:46.230
and only go to the custom CA layers and
layer scale management if you need to.

00:55:46.520 --> 00:55:50.600
OK, so what are some of the problems that
you sometimes do need to-- that exist

00:55:50.720 --> 00:55:53.750
that where you might really need to
be aware of the pixels going on in

00:55:53.760 --> 00:55:57.720
your-- that you're drawing into and
punch through this virtual world?

00:55:57.820 --> 00:56:00.820
Well, there are a couple of key cases.

00:56:00.880 --> 00:56:04.330
One is sort of you want to draw
in a nice device-aligned way,

00:56:04.440 --> 00:56:06.180
so you don't spill over
the edge of a pixel,

00:56:06.180 --> 00:56:10.070
have a nice crisp, sharp line,
or align things perfectly.

00:56:10.200 --> 00:56:13.250
And other cases are like you're trying
to allocate an off-screen bitmap context

00:56:13.390 --> 00:56:18.090
to draw the contents of a particular
view-- of a user view size into.

00:56:18.190 --> 00:56:20.530
In that case, you need to know how many
pixels are back in this.

00:56:20.650 --> 00:56:24.100
Well, we provided a set of tools for
you in the form of some APIs,

00:56:24.100 --> 00:56:26.310
some old, some new.

00:56:26.380 --> 00:56:29.940
The most important which is the-- for
aligning drawing to the device pixel

00:56:30.020 --> 00:56:33.320
boundaries is good old Center Scan,
right, which has been around

00:56:33.400 --> 00:56:37.210
for decades it seems,
but has been updated to actually

00:56:37.210 --> 00:56:41.590
work in this high-resolution backing
environment and device align any

00:56:41.590 --> 00:56:45.440
rectangle that you-- from given in
a local view-- So you can see the

00:56:45.440 --> 00:56:47.440
coordinates into device alignment.

00:56:47.440 --> 00:56:50.600
If you need-- if you're doing a more
complex layout operation and you

00:56:50.720 --> 00:56:54.710
need more control over the rounding
operations of-- of the rounding behavior,

00:56:54.800 --> 00:56:57.890
we've provided new advanced API in
line for-- for controlling the

00:56:58.120 --> 00:57:01.840
individual rounding behavior of each
of the edges of a given rectangle.

00:57:01.840 --> 00:57:04.360
This API is, of course,
available in its view and its

00:57:04.360 --> 00:57:07.440
window and in a screen because
each of them may have independently

00:57:07.560 --> 00:57:09.400
varying back in coordinate spaces.

00:57:09.400 --> 00:57:12.250
Now, for coordinate system conversion
like the bitmap context case

00:57:12.330 --> 00:57:15.220
I was alluding to before,
we have these coordinate system-- new

00:57:15.270 --> 00:57:19.680
coordinate system conversion APIs for
converting RECs from and to backing.

00:57:19.680 --> 00:57:22.230
Now, I just say REC here on the slide,
but we have all the

00:57:22.230 --> 00:57:23.880
geometric types available.

00:57:23.880 --> 00:57:26.220
And these are available again on NSView,
NSWindow,

00:57:26.220 --> 00:57:29.360
and NSScreen to handle all those
three different coordinate spaces.

00:57:29.360 --> 00:57:31.730
So in the bitmap context case,
if I want-- had a particular view

00:57:31.770 --> 00:57:33.850
I wanted to create an off-screen for,
I take that-- the view's bounds,

00:57:33.850 --> 00:57:34.070
I'd say convert REC to backing,
get this-- and that would

00:57:34.100 --> 00:57:34.280
convert it into pixels.

00:57:34.300 --> 00:57:34.860
So in the bitmap context case,
if I want-- had a particular view

00:57:34.860 --> 00:57:35.360
I wanted to create an off-screen for,
I take that-- the view's bounds,

00:57:35.360 --> 00:57:35.360
I'd say convert REC to backing,
get this-- and that would

00:57:35.360 --> 00:57:35.360
convert it into pixels.

00:57:35.410 --> 00:57:38.550
I'd say convert REC to backing,
get this-- and that would

00:57:38.660 --> 00:57:41.160
convert it into pixel geometry,
get the size from that,

00:57:41.160 --> 00:57:44.100
allocate my memory that's
appropriate to that,

00:57:44.160 --> 00:57:48.570
create the CG bitmap context,
apply the scale to it, I'm good to go.

00:57:49.290 --> 00:57:52.940
So, a few tips and tricks,
realities of living

00:57:52.940 --> 00:57:54.880
in this virtual world,
things that are a little bit different.

00:57:54.880 --> 00:57:57.070
First and foremost,
be prepared for fractional mouse

00:57:57.080 --> 00:57:58.650
locations and view coordinates.

00:57:58.660 --> 00:58:01.690
Something that actually aligns
perfectly nicely on a nice pixel

00:58:01.800 --> 00:58:04.260
boundary on the screen might actually,
in your code,

00:58:04.350 --> 00:58:06.960
end up on a 0.5 boundary now
due to this virtualization.

00:58:07.020 --> 00:58:09.280
It's not a bad thing,
not a horrible thing,

00:58:09.280 --> 00:58:12.740
just be careful to rid your code
of any assumptions about things

00:58:13.020 --> 00:58:15.810
being integral into point space
having anything to do with pixels.

00:58:18.220 --> 00:58:21.940
And keep in mind that NSView, NSWindow,
and NSScreen,

00:58:21.940 --> 00:58:24.180
especially with this funniness
with the OpenGL surfaces,

00:58:24.180 --> 00:58:26.920
can all have independently
varying backing resolutions,

00:58:26.920 --> 00:58:30.050
so don't make any assumptions,
and make sure you use the right

00:58:30.050 --> 00:58:33.220
coordinate transformation API to do
your work in the right space and make

00:58:33.220 --> 00:58:34.480
your decisions in the right space.

00:58:34.500 --> 00:58:38.660
Secondly, or, well, fourthly, I guess,
NSImageSize,

00:58:38.660 --> 00:58:43.120
because it's an AppKit object,
its size is expressed in points,

00:58:43.250 --> 00:58:45.980
but CG images are always
expressed in pixels,

00:58:45.990 --> 00:58:47.800
so be careful that you
don't make any mistakes.

00:58:47.800 --> 00:58:47.800
And keep in mind that NSView, NSWindow,
and NSScreen,

00:58:47.800 --> 00:58:49.930
especially with this funniness with these
layout assumptions based on CG image

00:58:49.930 --> 00:58:51.670
geometry in your local view space.

00:58:51.740 --> 00:58:52.740
This is a common pitfall.

00:58:52.740 --> 00:58:55.580
And lastly, most of the time,
calling center scanner is really

00:58:55.580 --> 00:58:58.110
all you really have to do to make
sure things sort of snap into

00:58:58.110 --> 00:58:59.580
place in a high-resolution screen.

00:58:59.580 --> 00:59:03.020
And with that,
I'd like to hand it over to my

00:59:03.130 --> 00:59:06.620
esteemed colleague and... Thank you,
Patrick.

00:59:06.620 --> 00:59:07.240
...do a little bit of wrapping.

00:59:07.240 --> 00:59:09.320
So this may be the end
of our session today.

00:59:09.320 --> 00:59:10.190
Thank you very much.

00:59:11.600 --> 00:59:14.340
and David I can see more pixels already.

00:59:14.420 --> 00:59:17.110
This may be the end of our
programming here at this talk,

00:59:17.280 --> 00:59:19.940
but this is just the beginning
of your adventures on Lion.

00:59:19.940 --> 00:59:22.980
You can always email Bill Dudney,
our Application Frameworks Evangelist,

00:59:22.990 --> 00:59:24.040
dudney@apple.com.

00:59:24.040 --> 00:59:26.470
He will be happy to steer
you in the right direction.

00:59:26.580 --> 00:59:29.240
We have fantastic documentation,
chock full of information.

00:59:29.240 --> 00:59:32.510
I'd like to point out in particular,
we have brand new resolution independence

00:59:32.510 --> 00:59:35.790
guidelines that relate directly
to what Patrick just talked about.

00:59:35.910 --> 00:59:38.180
Look for those on developer.apple.com.

00:59:38.180 --> 00:59:41.750
Also, the application kit release notes
are written by the app kit engineers

00:59:41.750 --> 00:59:43.500
who work on the framework code.

00:59:43.620 --> 00:59:45.310
This is knowledge
imparted directly to you,

00:59:45.310 --> 00:59:47.830
and it often contains lots of
late-breaking stuff that hasn't

00:59:47.830 --> 00:59:49.420
made it into the documentation yet.

00:59:49.510 --> 00:59:53.070
I highly recommend you look at
those and scour them for information

00:59:53.070 --> 00:59:54.940
about features you're working with.

00:59:55.030 --> 00:59:57.530
We have Apple Developer Forms
where you can ask questions.

00:59:57.620 --> 00:59:58.810
Some great sessions coming up.

00:59:58.810 --> 01:00:00.130
Don't miss these.

01:00:00.210 --> 01:00:03.140
Today at 3:15 in this room, scrolling,
swiping and dragging.

01:00:03.140 --> 01:00:04.350
Now with more animation.

01:00:04.440 --> 01:00:06.880
We have an entire talk on view-based
table views tomorrow morning.

01:00:06.880 --> 01:00:10.240
You'll see the fantastic things that
you can do now that you can put views in

01:00:10.240 --> 01:00:12.520
table views and do automatic animations.

01:00:12.620 --> 01:00:13.530
Thank you very much for coming.

01:00:13.530 --> 01:00:14.980
We hope you enjoy the
rest of the conference.
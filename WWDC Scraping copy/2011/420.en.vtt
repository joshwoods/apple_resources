WEBVTT

00:00:15.490 --> 00:00:17.160
Good morning.

00:00:17.520 --> 00:00:19.010
How's the commerce been
for everyone so far?

00:00:19.240 --> 00:00:20.580
Good?

00:00:23.390 --> 00:00:27.700
Today we're going to talk about
advances in OpenGL for Mac OS X Lion.

00:00:27.700 --> 00:00:28.790
Hopefully you're all in the right place.

00:00:28.860 --> 00:00:31.720
If not, I won't take it personally if you
leave and go to your correct session.

00:00:34.990 --> 00:00:36.900
So I assume most of you
are familiar with OpenGL,

00:00:36.900 --> 00:00:38.830
but let's go over and review a bit.

00:00:38.940 --> 00:00:42.820
OpenGL is the high-performance
rendering API that we offer in Mac OS X.

00:00:42.820 --> 00:00:44.880
It's direct access to the GPU.

00:00:44.880 --> 00:00:48.170
The GPU are very powerful
processors primed for graphics

00:00:48.210 --> 00:00:49.440
that sit in all your machines.

00:00:49.460 --> 00:00:51.920
And if you need direct,
high-performance access,

00:00:51.920 --> 00:00:53.150
OpenGL is the way to go.

00:00:53.280 --> 00:00:56.620
It's broadly used throughout the
industry for things like games,

00:00:56.620 --> 00:00:59.960
visualization, medical,
all sorts of things, entertainment.

00:00:59.960 --> 00:01:04.540
And it's also the foundation of all the
great visual technologies in Mac OS X.

00:01:04.900 --> 00:01:06.740
So if you're used to
things like core image,

00:01:06.910 --> 00:01:10.270
core animation, even Quartz Extreme,
the Windows server itself,

00:01:10.330 --> 00:01:12.320
is built on the foundation of OpenGL.

00:01:12.320 --> 00:01:15.260
So this is a way to give you
the power of the GPU and let you

00:01:15.260 --> 00:01:17.360
harness it for your applications.

00:01:20.590 --> 00:01:22.040
So let's start off with an introduction.

00:01:22.040 --> 00:01:26.050
And you might be wondering where we're at
in Lion and what the state of OpenGL is,

00:01:26.050 --> 00:01:27.420
what it looks like.

00:01:27.520 --> 00:01:28.920
So what's new?

00:01:28.960 --> 00:01:31.700
The big new thing is
the OpenGL Core Profile.

00:01:31.740 --> 00:01:34.940
And this provides you with new
rendering features and new support

00:01:35.450 --> 00:01:38.760
features and all kinds of new things
you can use in Lion to help your

00:01:38.780 --> 00:01:42.360
application look and run great.

00:01:42.540 --> 00:01:44.300
Spoiler alert.

00:01:45.860 --> 00:01:47.660
So the OpenGL Core Profile.

00:01:47.720 --> 00:01:51.800
All the new features we're providing in
Lion require you to use the Core Profile.

00:01:51.820 --> 00:01:53.840
And this is a little different
than what you might be used to,

00:01:53.840 --> 00:01:58.270
which is what we're
calling the Legacy Profile.

00:01:58.270 --> 00:01:58.270
Legacy Profile

00:01:58.570 --> 00:02:00.500
is fixed function and programmable.

00:02:00.630 --> 00:02:03.220
You create the profile,
you can use the fixed function pipeline,

00:02:03.300 --> 00:02:05.550
or you can write your own
shaders and use that pipeline.

00:02:05.830 --> 00:02:09.500
In the Core Profile,
everything is fully programmable.

00:02:10.150 --> 00:02:12.900
The Legacy Profile is completely
binary compatible with all the

00:02:12.900 --> 00:02:15.200
apps you've already written,
so everything that you've written before

00:02:15.200 --> 00:02:19.150
will continue to run just as great,
maybe even a little better online.

00:02:19.240 --> 00:02:23.560
The Core Profile is all new, efficient,
and modern.

00:02:23.900 --> 00:02:27.110
The legacy profile is default,
so when you create a new OpenGL app,

00:02:27.110 --> 00:02:30.080
you'll still get the profile
that you've always gotten before.

00:02:30.130 --> 00:02:33.020
If you want to use the new features,
you must opt in to the Core Profile.

00:02:33.100 --> 00:02:34.620
This is a choice you can do.

00:02:34.730 --> 00:02:38.710
Just put a few lines of code in,
and you'll get all the new features.

00:02:39.980 --> 00:02:42.220
So new Core Profile features.

00:02:42.570 --> 00:02:44.840
The big one is GLSL 150.

00:02:45.020 --> 00:02:47.920
GLSL is the OpenGL shading language.

00:02:47.990 --> 00:02:51.010
And we're introducing version 150
to you guys so you can use it,

00:02:51.040 --> 00:02:54.050
which comes with a whole
slew of great new features.

00:02:54.130 --> 00:02:56.360
Another new feature is
uniform buffer objects.

00:02:56.400 --> 00:03:00.180
If you're familiar with other APIs,
this is quite analogous to the C buffer.

00:03:00.240 --> 00:03:02.800
And it allows you to use a
buffer object as the backing for

00:03:02.910 --> 00:03:04.880
the uniforms in your shaders.

00:03:05.020 --> 00:03:07.180
Similarly,
there's texture buffer objects,

00:03:07.300 --> 00:03:09.960
which is a texture backed
by a buffer object.

00:03:10.010 --> 00:03:13.300
It can take advantage of texture
caching and other things.

00:03:13.450 --> 00:03:15.940
A new way to do instancing,
which allows you to draw a whole

00:03:15.940 --> 00:03:17.710
bunch of batches with one draw call.

00:03:17.720 --> 00:03:19.500
And this is shader instancing.

00:03:19.500 --> 00:03:21.100
We'll go through that in a second.

00:03:21.100 --> 00:03:23.040
Snorm textures.

00:03:23.040 --> 00:03:25.120
An Snorm texture is a normalized texture.

00:03:25.120 --> 00:03:29.290
Normally a value in a texture can
go from 0 to whatever you'd like.

00:03:29.360 --> 00:03:33.740
An Snorm texture goes from
0 to 1 or negative 1 to 1.

00:03:33.740 --> 00:03:35.140
So Snorm is signed normalized.

00:03:35.140 --> 00:03:36.640
It's also unsigned normalized.

00:03:36.640 --> 00:03:41.940
So this allows you to use the full
range of bits in your texture to

00:03:41.940 --> 00:03:45.010
just express the 0 to 1 range.

00:03:45.430 --> 00:03:48.880
Multisample textures is a way to
do multisample render targets.

00:03:48.920 --> 00:03:52.220
These are multisample textures to
allow you to do anti-aliasing as

00:03:52.220 --> 00:03:53.680
you're rendering to off-screen buffers.

00:03:53.700 --> 00:03:56.320
And last but not least, timer query.

00:03:56.320 --> 00:03:59.410
Timer query allows you to
query GPU state and do some

00:03:59.590 --> 00:04:02.330
high-performance performance counting,
stuff like that.

00:04:04.490 --> 00:04:07.700
Float and integer rendering.

00:04:07.700 --> 00:04:10.640
We have RG and multi-sample,
like I mentioned before.

00:04:10.730 --> 00:04:14.940
Texture arrays, which are texture arrays
similar to 3D textures,

00:04:14.990 --> 00:04:19.150
except that you don't
blend between the Z axis.

00:04:19.320 --> 00:04:20.990
Conditional rendering,
which allows you to render

00:04:20.990 --> 00:04:24.220
things conditionally based on
the output of an occlusion query.

00:04:24.300 --> 00:04:28.590
And transform feedback,
which allows you to output rendering

00:04:28.680 --> 00:04:30.890
things into buffer objects.

00:04:32.420 --> 00:04:33.560
Other new features we're providing.

00:04:33.560 --> 00:04:34.680
IOSurface.

00:04:34.730 --> 00:04:37.780
IOSurface is a method to
share data between processes,

00:04:37.780 --> 00:04:39.640
so you can share texture
data and surface data.

00:04:39.640 --> 00:04:41.790
And automatic graphics switching.

00:04:41.790 --> 00:04:43.550
If you've bought a
laptop in the last year,

00:04:43.660 --> 00:04:45.500
year and a half,
you know you have two GPUs.

00:04:45.500 --> 00:04:48.760
There's one that uses less power,
and then there's a super powerful one.

00:04:48.760 --> 00:04:51.240
And from then until now,
you've always been

00:04:51.240 --> 00:04:52.780
forced to write your app.

00:04:52.780 --> 00:04:56.490
You create an OpenGL app,
and it has to run on the high-power GPU.

00:04:56.490 --> 00:05:00.230
Well, now we're allowing you to use
the integrated GPU to make your

00:05:00.290 --> 00:05:02.290
app have better battery life.

00:05:04.480 --> 00:05:06.480
So let's jump right into
using the Core Profile.

00:05:06.540 --> 00:05:07.560
What is the Core Profile?

00:05:07.560 --> 00:05:08.280
How do I use it?

00:05:08.440 --> 00:05:10.280
What does it give me?

00:05:12.150 --> 00:05:16.800
Concept of the Core Profile,
new features and cleaner API.

00:05:16.850 --> 00:05:18.760
You know,
this API has been around a long time,

00:05:18.760 --> 00:05:21.150
and we've cut out some of the cruft.

00:05:21.280 --> 00:05:24.480
It's more aligned to the hardware,
what the hardware actually does.

00:05:24.570 --> 00:05:26.400
So a cleaner expression of the GPU power.

00:05:26.400 --> 00:05:28.720
We want to really have you--
when you call an API call,

00:05:28.720 --> 00:05:32.520
we want it to correspond to
something the GPU is actually doing.

00:05:32.750 --> 00:05:35.950
And if you're familiar with iOS apps,
this is really similar to the

00:05:35.950 --> 00:05:38.500
jump between ES 1.1 and ES 2.0.

00:05:38.540 --> 00:05:40.850
The same sort of leaving
the fixed function behind,

00:05:41.130 --> 00:05:44.300
going to fully programmable shaders,
and really giving you the power of

00:05:44.300 --> 00:05:46.360
the GPU and putting it in your hands.

00:05:46.460 --> 00:05:48.890
So very similar to ES 2.

00:05:50.770 --> 00:05:51.960
So why change?

00:05:52.010 --> 00:05:54.500
Like I said,
there's a lot of cruft in this API.

00:05:54.520 --> 00:05:56.060
There has been in the past.

00:05:56.070 --> 00:05:59.310
OpenGL was designed in 1992
for machines that look way

00:05:59.310 --> 00:06:01.120
different than what we've got now.

00:06:01.190 --> 00:06:03.810
So those Irix GL machines--

00:06:34.080 --> 00:06:34.080
Hi, everyone.

00:06:34.080 --> 00:06:34.080
I'm Matt Collins.

00:06:34.080 --> 00:06:34.080
I'm the founder of OpenGL.

00:06:34.080 --> 00:06:34.080
And I'm going to talk to you about
some of the things that we've

00:06:34.080 --> 00:06:34.080
been doing to improve the GPU.

00:06:34.080 --> 00:06:34.080
The first thing is that we've been
using the GPU for a long time.

00:06:34.080 --> 00:06:34.080
So the GPU is really,
really different than the GPU that's

00:06:34.080 --> 00:06:34.080
sitting in your machine right now.

00:06:34.080 --> 00:06:34.080
They really look nothing alike.

00:06:34.080 --> 00:06:34.080
So we really want to express what the
modern GPU looks like in this API.

00:06:34.080 --> 00:06:34.080
We don't want to be stuck
back on something that came

00:06:34.080 --> 00:06:34.080
out almost 20 years ago.

00:06:34.080 --> 00:06:34.080
And this is because
these GPUs are really,

00:06:34.080 --> 00:06:34.080
really powerful,
and they're really hungry for work.

00:06:34.080 --> 00:06:34.080
And most of the time,
the GPU is going to be sitting

00:06:34.080 --> 00:06:34.080
idle as you're using it.

00:06:34.080 --> 00:06:34.080
And we want to keep it fed.

00:06:34.080 --> 00:06:34.080
We want to send it lots and lots of
work so it's always doing something,

00:06:34.080 --> 00:06:34.100
just stream all this data down
so it can crunch those numbers.

00:06:37.160 --> 00:06:38.900
So let's go over what
we're gonna talk about.

00:06:39.050 --> 00:06:41.930
First I'll go over getting started,
how to get started with the core profile,

00:06:42.070 --> 00:06:43.700
what you need to do.

00:06:43.710 --> 00:06:46.600
The differences from the legacy profile,
you know, what looks the same,

00:06:46.600 --> 00:06:47.600
what looks different?

00:06:47.630 --> 00:06:49.660
How do you wrap your head around this?

00:06:49.730 --> 00:06:51.190
How do you send data to the GPU?

00:06:51.360 --> 00:06:52.940
'Cause like I said,
we wanna keep it busy,

00:06:52.970 --> 00:06:55.390
so we can keep it busy by
sending it tons of data at

00:06:55.420 --> 00:06:57.480
once so it has something to do.

00:06:57.520 --> 00:07:01.160
We'll go over shader development,
GLSL 150, what it means for you,

00:07:01.230 --> 00:07:04.060
how it looks different from
the shaders you're writing now,

00:07:04.080 --> 00:07:05.780
and how it looks different
from the shaders you might

00:07:05.780 --> 00:07:07.580
have written for ES 2.0.

00:07:07.600 --> 00:07:10.310
We'll also talk about API changes,
some differences in

00:07:10.310 --> 00:07:13.300
flushing data to the GPU,
syncing data to the GPU,

00:07:13.330 --> 00:07:16.470
and syncing different
threads in your program,

00:07:16.650 --> 00:07:19.940
different execution to make sure
that the GPU has actually finished

00:07:19.940 --> 00:07:21.280
what you think it's finished.

00:07:21.290 --> 00:07:23.450
Then I'll go over a couple
tips and tricks and some

00:07:23.450 --> 00:07:25.480
other things to watch out for.

00:07:26.210 --> 00:07:28.060
So let's get started.

00:07:28.110 --> 00:07:30.450
Requesting an OpenGL 3.2 context.

00:07:30.540 --> 00:07:31.690
It's actually really easy.

00:07:31.970 --> 00:07:35.330
If you look at this,
you see you need to add two things,

00:07:35.460 --> 00:07:39.460
the OpenGL profile key and the
OpenGL profile version key.

00:07:39.460 --> 00:07:44.330
So when you create your context,
you just have to add these two new

00:07:44.900 --> 00:07:48.170
attributes and you'll get a Core Profile.

00:07:48.170 --> 00:07:48.170
Core Profile is OpenGL 3.2 compliant.

00:07:48.510 --> 00:07:50.900
And I'd like to call out that
if you use Interface Builder

00:07:50.900 --> 00:07:53.990
to create your OpenGL apps,
you will actually need to

00:07:54.040 --> 00:07:55.680
programmably create your context.

00:07:55.730 --> 00:07:59.260
Interface Builder will not let
you create an OpenGL 3.2 context.

00:07:59.330 --> 00:08:01.850
And we did this because we
want you to be sure you really

00:08:01.850 --> 00:08:04.500
want the Core Profile context,
because the Core Profile

00:08:04.500 --> 00:08:07.330
will not be compatible with
your previous OpenGL code.

00:08:08.200 --> 00:08:10.840
So you create your attribute list,
and you pass it,

00:08:10.840 --> 00:08:14.620
create a pixel format as usual,
pass that pixel format,

00:08:14.630 --> 00:08:18.150
and create a context with it,
and now you have a context that

00:08:18.150 --> 00:08:20.010
is the OpenGL Core Profile.

00:08:22.040 --> 00:08:24.000
Now the differences from legacy profile.

00:08:24.020 --> 00:08:27.620
Like I mentioned before,
everything is programmable.

00:08:27.670 --> 00:08:28.720
There's no more fixed function.

00:08:28.910 --> 00:08:32.830
And this is actually really cool because
you get a lot more flexibility and power.

00:08:33.050 --> 00:08:34.760
And the GPU works this way.

00:08:34.820 --> 00:08:38.540
Your modern GPU actually does not
have a fixed function pipeline in it.

00:08:38.670 --> 00:08:42.820
When you're running old OpenGL apps,
the driver itself will create

00:08:42.890 --> 00:08:46.540
shaders behind your back and sort of
emulate the fixed function pipeline.

00:08:46.610 --> 00:08:50.920
So this is giving that power to you so
you know exactly what the GPU is doing.

00:08:51.040 --> 00:08:53.600
The other main difference is
everything is now a batch draw

00:08:53.600 --> 00:08:54.980
instead of immediate mode.

00:08:55.240 --> 00:08:57.300
You might have been familiar
with calling GL begin,

00:08:57.370 --> 00:09:02.160
GL end, passing it vertex by
vertex by vertex by vertex.

00:09:02.300 --> 00:09:03.680
And we really want to get away from this.

00:09:03.790 --> 00:09:07.430
We want to hook up the hose and feed
it millions of points at once so it

00:09:07.510 --> 00:09:09.000
can have all this data to crunch.

00:09:09.100 --> 00:09:10.210
It's much more efficient.

00:09:10.370 --> 00:09:12.690
Because actually,
you can imagine sending vertex

00:09:12.690 --> 00:09:15.840
by vertex over the bus is going
to be much less efficient than

00:09:15.840 --> 00:09:18.830
sending 100K of data all at once.

00:09:21.310 --> 00:09:23.680
So using the Core Profile,
how do we actually send

00:09:23.680 --> 00:09:26.140
this data to the GPU?

00:09:26.240 --> 00:09:28.500
Well, you're going to use a vertex
buffer for everything.

00:09:28.640 --> 00:09:31.200
Many of you have probably
used VBOs in your code.

00:09:31.350 --> 00:09:34.620
And now we're going to tell
you that this is the de facto

00:09:34.720 --> 00:09:36.680
way to draw and upload data.

00:09:36.820 --> 00:09:40.330
So you want to send data
once to the GPU and reuse.

00:09:40.430 --> 00:09:45.340
You may ask, what happens if I have
data that I want to modify?

00:09:45.340 --> 00:09:48.330
Well, you can still use a vertex buffer
object and update it as needed.

00:09:48.890 --> 00:09:51.800
So everything you should send once
and reuse as much as possible.

00:09:51.800 --> 00:09:56.650
You're also going to supply data to your
shader via a generic vertex attribute.

00:09:56.660 --> 00:09:59.340
This is also something that's
been available for a while,

00:09:59.340 --> 00:10:03.350
but now this is the de facto way
to supply data to your shader.

00:10:03.360 --> 00:10:05.470
Everything is a generic vertex attribute.

00:10:05.480 --> 00:10:09.100
You supply this with
vertex attribute array.

00:10:09.100 --> 00:10:12.460
There's no more vertex pointer,
no more GL normal pointer,

00:10:12.460 --> 00:10:13.170
anything like that.

00:10:13.640 --> 00:10:16.760
Everything is a generic vertex attribute
and completely controlled by you.

00:10:16.760 --> 00:10:19.890
You can interpret the data coming
into your shader however you'd like.

00:10:19.980 --> 00:10:22.970
This gives you much more flexibility
because now you can just use

00:10:23.250 --> 00:10:24.260
whatever you want in your shader.

00:10:24.260 --> 00:10:26.750
You can have three attributes,
you can have two normals,

00:10:26.750 --> 00:10:28.350
you can have eight colors,
whatever you want.

00:10:30.170 --> 00:10:32.600
And this is all helped-- you
help manage this with what's

00:10:32.650 --> 00:10:34.520
called a vertex array object.

00:10:34.570 --> 00:10:37.400
This is something Apple introduced
to GL several years ago,

00:10:37.560 --> 00:10:39.700
but it helps you manage
your buffers and enables.

00:10:39.770 --> 00:10:43.270
So a vertex array object
coalesces all the enabled buffers,

00:10:43.340 --> 00:10:44.760
all the bound pointers.

00:10:44.970 --> 00:10:49.500
So you don't have to
continue to call bind buffer,

00:10:49.500 --> 00:10:54.160
GL vertex attribute array,
GL enable vertex attribute array

00:10:54.160 --> 00:10:54.160
over and over and over again.

00:10:54.160 --> 00:10:54.160
Now you just call--

00:10:54.380 --> 00:10:58.060
GL bind vertex array,
and it will bind all that

00:10:58.180 --> 00:11:00.570
for you automatically.

00:11:01.730 --> 00:11:04.100
So let's take a look at
what this looks like.

00:11:04.150 --> 00:11:06.800
I'm going to talk about
uploading positions.

00:11:06.800 --> 00:11:08.340
That's the most important
thing in graphics.

00:11:08.400 --> 00:11:10.290
We want a bunch of vertex positions.

00:11:10.410 --> 00:11:13.020
So I say,
pound define attribute position.

00:11:13.180 --> 00:11:19.320
And I'm going to say this is
generic vertex attribute 0,

00:11:19.320 --> 00:11:19.320
because we'll start at the beginning.

00:11:19.600 --> 00:11:23.450
So first, I'm going to create my VAO,
my vertex array.

00:11:23.600 --> 00:11:26.000
And I'll create it as normal
like you create everything else.

00:11:26.140 --> 00:11:28.450
One of them passing the pointer.

00:11:30.460 --> 00:11:34.280
Then I'll bind the vertex array so that
everything else I bind will be associated

00:11:34.280 --> 00:11:36.480
with the currently bound vertex array.

00:11:36.480 --> 00:11:41.010
Then I will bind my array buffer as
normal to whatever VBO I'd like to use.

00:11:41.080 --> 00:11:45.170
And then instead of calling
glVertexPointer or glNormalPointer,

00:11:45.170 --> 00:11:48.220
etc., I'll call glVertexAttribPointer.

00:11:48.220 --> 00:11:50.730
And I've already decided I want
to use attribute 0 for this.

00:11:50.730 --> 00:11:51.900
These are my positions.

00:11:51.900 --> 00:11:54.840
So the first thing I put
into the argument list is my

00:11:54.970 --> 00:11:57.520
pound-defined attribute position,
0.

00:11:58.670 --> 00:12:00.760
Then,
similarly to the other pointer calls,

00:12:00.830 --> 00:12:02.760
I say the number of
elements I have in this,

00:12:02.760 --> 00:12:03.440
so 3.

00:12:03.440 --> 00:12:05.820
I say floating point numbers.

00:12:05.820 --> 00:12:08.680
The glFalse allows you to specify
whether you want this data

00:12:08.680 --> 00:12:10.650
automatically normalized for you.

00:12:10.880 --> 00:12:13.010
Since they're positions,
I probably don't want it normalized,

00:12:13.010 --> 00:12:13.960
so I'm going to say no.

00:12:13.960 --> 00:12:17.180
Then, as usual, I have the stride,
and then I have the offset

00:12:17.180 --> 00:12:18.580
into my buffer object.

00:12:18.580 --> 00:12:22.340
And then, lastly,
I have to remember that I want to enable.

00:12:23.900 --> 00:12:39.600
[Transcript missing]

00:12:40.820 --> 00:12:42.740
So you have 16 vertex attributes.

00:12:42.820 --> 00:12:44.200
You may have more.

00:12:44.200 --> 00:12:47.300
So you can query the limit to be sure if
you want to see if you have 32 or more.

00:12:47.300 --> 00:12:50.320
But we guarantee you at least
16 across all renderers.

00:12:50.340 --> 00:12:52.980
Like I mentioned,
enables and pointers are saved.

00:12:53.070 --> 00:12:54.030
So this is great.

00:12:54.210 --> 00:12:55.430
You only need to bind once.

00:12:55.500 --> 00:12:59.520
Instead of having multiple bind calls,
you can bind your vertex array once.

00:13:01.020 --> 00:13:02.920
and that's all you need.

00:13:02.930 --> 00:13:05.250
Array buffer is not saved.

00:13:05.530 --> 00:13:07.430
So when you say GL bind
buffer array buffer,

00:13:07.530 --> 00:13:09.340
that's never actually used for rendering.

00:13:09.460 --> 00:13:13.760
It's only used for GL map buffer,
GL buffer data, et cetera.

00:13:13.790 --> 00:13:21.460
And the actual thing that binds a
specific vertex buffer object to

00:13:21.460 --> 00:13:23.390
the attribute is the pointer call.

00:13:23.390 --> 00:13:23.390
So that's what actually does the binding.

00:13:25.930 --> 00:13:27.740
Other things you might want
to supply to your shader.

00:13:27.770 --> 00:13:29.320
Well,
the big thing everyone asks about is,

00:13:29.390 --> 00:13:32.100
how do I send a matrix down to my shader?

00:13:32.900 --> 00:13:33.500
Well, it's quite simple.

00:13:33.500 --> 00:13:35.690
You just use GL uniform matrix.

00:13:35.810 --> 00:13:38.500
Now, there's no more matrix mode and
there's no more matrix stack.

00:13:38.650 --> 00:13:39.870
And a lot of people say, "Oh, that sucks.

00:13:39.940 --> 00:13:44.120
I really like the matrix stack." Well,
this is actually better.

00:13:44.290 --> 00:13:46.530
gives you better program
control over what you're doing.

00:13:46.540 --> 00:13:48.310
You no longer have to manage the stack.

00:13:48.430 --> 00:13:50.920
Instead, in your render tree,
you could just associate a

00:13:50.920 --> 00:13:52.340
transform with an object.

00:13:52.350 --> 00:13:54.260
And when it comes time
to render that object,

00:13:54.270 --> 00:13:57.180
you can upload it with
GL uniform matrix 4fv,

00:13:57.290 --> 00:13:58.650
send it all up at once.

00:13:58.920 --> 00:14:01.360
One thing to remember with
that function call is the count

00:14:01.360 --> 00:14:03.890
is the number of matrices,
not the number of components

00:14:03.890 --> 00:14:04.990
or the number of vectors.

00:14:05.160 --> 00:14:07.160
So if you're going to
upload four matrices,

00:14:07.170 --> 00:14:09.200
you would pass it a pointer
and you would say four,

00:14:09.220 --> 00:14:13.700
not 16 or however many
components are going to be there.

00:14:14.650 --> 00:14:16.320
Now,
I said you get better programmer control.

00:14:16.450 --> 00:14:18.840
And this goes back to when
I said we want to express what

00:14:18.910 --> 00:14:21.580
the GPU is actually doing here.

00:14:21.650 --> 00:14:24.920
glMultMatrix and glRotateF,
all those functions,

00:14:24.950 --> 00:14:26.790
were actually CPU side work.

00:14:26.820 --> 00:14:28.870
When you did that,
the CPU would calculate these

00:14:28.870 --> 00:14:30.340
matrices and upload it for you.

00:14:30.480 --> 00:14:31.580
And you really don't want that.

00:14:31.700 --> 00:14:35.660
As a programmer, you want to know exactly
what the API is doing.

00:14:35.690 --> 00:14:37.560
You don't want it to do
some stuff on the CPU,

00:14:37.630 --> 00:14:38.840
some stuff on the GPU.

00:14:38.870 --> 00:14:40.960
You want to be sure,
I know exactly that this is

00:14:40.960 --> 00:14:42.320
going to happen on the GPU.

00:14:42.460 --> 00:14:45.180
This is going to happen on the CPU.

00:14:45.310 --> 00:14:47.510
So you can associate your
transforms with your objects.

00:14:47.670 --> 00:14:50.360
You can know that I did this
transformation myself in my code,

00:14:50.440 --> 00:14:53.300
or I'm uploading it,
and I'm going to let the GPU do

00:14:53.450 --> 00:14:55.940
this transformation in my shader.

00:14:56.530 --> 00:14:59.110
And while you're thinking about that,
keep in mind that a single matrix

00:14:59.160 --> 00:15:03.900
multiply is always going to be
faster than 10,000 matrix multiplies.

00:15:04.000 --> 00:15:06.930
So if you have a vertex shader that's
going to multiply the projection

00:15:06.970 --> 00:15:10.650
times the model view matrix,
that may occur 10,000 times,

00:15:10.650 --> 00:15:12.540
or however many vertices you have.

00:15:12.730 --> 00:15:14.990
If you do that multiply
yourself in your code,

00:15:15.300 --> 00:15:17.500
that will happen once,
and you can upload that

00:15:17.500 --> 00:15:19.640
pre-multiplied matrix to your shader.

00:15:19.760 --> 00:15:20.790
That's going to be more efficient.

00:15:20.790 --> 00:15:24.220
So keep in mind, we call it hoisting
things up the pipeline.

00:15:24.370 --> 00:15:26.700
So usually,
the fragment stage will run more

00:15:26.700 --> 00:15:29.660
often than the vertex stage,
and the vertex stage will, of course,

00:15:29.690 --> 00:15:31.830
run more often than whatever
you're doing in your code.

00:15:31.980 --> 00:15:35.260
So if stuff can be moved up,
you should definitely consider doing it.

00:15:35.310 --> 00:15:37.990
It'll make things quite
a bit more efficient.

00:15:40.030 --> 00:15:42.240
So what does a shader look like?

00:15:42.280 --> 00:15:44.600
This is a pretty big shader,
so don't get overwhelmed when you see it.

00:15:44.600 --> 00:15:45.870
I'll go over the interesting things.

00:15:45.870 --> 00:15:49.100
Some of it may look familiar,
some of it may look a little different,

00:15:49.210 --> 00:15:50.940
but we'll talk about each in detail.

00:15:52.800 --> 00:15:54.420
So here's a vertex shader.

00:15:54.440 --> 00:15:56.460
Looks pretty normal, a regular transform.

00:15:56.460 --> 00:15:58.290
You know,
we have the normals being transformed,

00:15:58.290 --> 00:16:02.690
normalized, a little matrix multiply,
some color that we're

00:16:02.690 --> 00:16:03.580
passing down the pipeline.

00:16:03.580 --> 00:16:07.260
And lastly, we output the position with
the model view projection.

00:16:07.260 --> 00:16:08.540
Pretty straightforward.

00:16:08.540 --> 00:16:10.700
A couple things look a little different.

00:16:10.700 --> 00:16:13.030
You might be saying, well,
what are those?

00:16:13.030 --> 00:16:14.190
So let's go through it.

00:16:18.290 --> 00:16:23.080
So the first thing that you'll notice
is at the very top we have a new pragma,

00:16:23.120 --> 00:16:24.880
#Version150.

00:16:24.910 --> 00:16:29.900
This indicates to the compiler what
the GLSL version that we're using is.

00:16:31.760 --> 00:16:34.130
lets the runtime know that, hey,
this is the new stuff.

00:16:34.380 --> 00:16:36.760
Be prepared.

00:16:36.870 --> 00:16:40.300
The next thing is
specifying shader inputs.

00:16:40.430 --> 00:16:43.170
Now,
if you used vertex attributes before,

00:16:43.310 --> 00:16:45.200
you might have been used
to saying attribute,

00:16:45.200 --> 00:16:46.840
vec3, whatever.

00:16:46.950 --> 00:16:48.760
Well,
now we've changed that a little simpler.

00:16:48.760 --> 00:16:50.730
Now you just say in.

00:16:51.020 --> 00:16:53.980
Designate this as an input to the shader,
and then you get to specify

00:16:54.010 --> 00:16:55.200
whatever you want to call it.

00:16:55.270 --> 00:16:57.630
So you hook them up to your
generic vertex attributes

00:16:57.630 --> 00:16:59.120
that you already specified.

00:16:59.120 --> 00:17:00.710
And there's two ways to do this.

00:17:00.710 --> 00:17:03.850
You can bind the name position,
in this case,

00:17:03.850 --> 00:17:06.190
to a specific vertex attribute.

00:17:06.190 --> 00:17:09.360
So I had decided I wanted
to use zero before.

00:17:09.360 --> 00:17:12.810
So you just say, bind attribute location.

00:17:12.810 --> 00:17:13.720
You call this.

00:17:13.830 --> 00:17:15.710
Make sure you call it before you link.

00:17:15.710 --> 00:17:18.830
Call it for each of your attributes,
and you can decide which

00:17:18.830 --> 00:17:20.820
vertex array you want to use.

00:17:20.960 --> 00:17:22.940
So you can decide which generic vertex
attribute you want to source it from.

00:17:22.940 --> 00:17:27.670
Alternatively, you can call get attribute
location after your link.

00:17:27.720 --> 00:17:31.150
This will let the compiler decide
which generic vertex attribute it's

00:17:31.150 --> 00:17:33.200
going to associate all the inputs with.

00:17:33.440 --> 00:17:37.050
If you decide to do it this way,
one thing to keep in mind is

00:17:37.310 --> 00:17:42.260
there's no guarantee as to order or
anything that may not be consistent.

00:17:42.260 --> 00:17:46.500
So here I've heard them
position normal color.

00:17:46.500 --> 00:17:49.080
So you might think, oh,
that would automatically get zero, one,

00:17:49.080 --> 00:17:49.890
and two, right?

00:17:49.900 --> 00:17:50.800
Well, maybe.

00:17:50.900 --> 00:17:51.690
Maybe not.

00:17:51.950 --> 00:17:53.400
Maybe a compiler changes.

00:17:53.400 --> 00:17:55.400
Maybe it's different per GPU.

00:17:55.400 --> 00:17:58.890
So don't guess that things are
always going to happen the same way.

00:17:58.900 --> 00:18:02.780
And be sure to code a little defensively
to make sure that you're always

00:18:02.840 --> 00:18:08.080
checking which generic attribute
corresponds to which name in your shader.

00:18:08.120 --> 00:18:13.500
So in replaces the attribute keyword
that you may be familiar with.

00:18:15.930 --> 00:18:17.300
Next, we have outs.

00:18:17.300 --> 00:18:20.800
Outs specify what goes to the
next stage in the pipeline.

00:18:20.800 --> 00:18:24.300
So this was similar to putting
varying before something before,

00:18:24.300 --> 00:18:28.430
except that now it's explicitly saying,
"Yeah, this is an output." And that makes

00:18:28.440 --> 00:18:31.800
more sense because varying-- yeah,
if you understand how the GPU works,

00:18:31.800 --> 00:18:33.800
this is something that varies
across the entire primitive,

00:18:33.800 --> 00:18:35.690
but output's a little
more straightforward.

00:18:35.910 --> 00:18:38.990
Yeah, this is output of this stage,
and we'll go into the

00:18:39.040 --> 00:18:40.630
input of the next stage.

00:18:42.690 --> 00:18:44.910
So let's look at a fragment shader.

00:18:45.040 --> 00:18:47.330
This is a little shorter,
but should be pretty similar

00:18:47.330 --> 00:18:49.580
to things that you're used to.

00:18:49.700 --> 00:18:52.430
Again, we have some inputs and uniforms.

00:18:52.500 --> 00:18:53.240
Yeah, that looks normal.

00:18:53.240 --> 00:18:55.280
Output, final color, huh?

00:18:55.280 --> 00:18:57.150
But I thought we had color built-ins.

00:18:57.150 --> 00:18:59.200
Well, we'll talk about that in a second.

00:18:59.200 --> 00:19:02.110
And the shader itself is a
pretty simple lighting deal.

00:19:02.200 --> 00:19:04.810
So let's talk about how this is a
little different from what you might

00:19:04.820 --> 00:19:07.470
be used to with the fragment shader.

00:19:08.700 --> 00:19:11.010
Again, we start off with the pragma,
pound version 150.

00:19:11.100 --> 00:19:13.920
This is the new stuff,
so don't forget to put this

00:19:13.970 --> 00:19:15.700
at the top of your shaders.

00:19:17.980 --> 00:19:19.260
inputs.

00:19:19.260 --> 00:19:21.500
Now, as you can imagine,
the output of the previous stage

00:19:21.720 --> 00:19:24.740
becomes the input of this stage.

00:19:25.190 --> 00:19:27.510
So whatever was labeled
out in your vertex stage,

00:19:27.510 --> 00:19:30.010
or if you're using a geometry shader,
the geometry stage,

00:19:30.200 --> 00:19:32.420
becomes the input of the fragment stage.

00:19:32.440 --> 00:19:37.000
They have to be named the same thing to
make sure that you're passing through.

00:19:37.400 --> 00:19:40.990
So in replaces varying
in the fragment stage.

00:19:41.420 --> 00:19:44.880
And last but not least, the outputs.

00:19:45.010 --> 00:19:48.200
Now there's no more
GLFragColor and GLFragData.

00:19:48.310 --> 00:19:51.610
That's replaced by a
variable of your name,

00:19:51.650 --> 00:19:54.020
and you can call it whatever you'd like.

00:19:54.230 --> 00:19:55.480
and you label those as outputs.

00:19:55.590 --> 00:19:58.100
So here I have out vec4 final color.

00:19:58.250 --> 00:20:01.600
And similarly to how we bound
the vertex attributes going in,

00:20:02.060 --> 00:20:05.100
we also bind the fragment
colors going out.

00:20:05.640 --> 00:20:10.350
So I can say GL bind frag data location,
and I can bind it to a specific number

00:20:10.350 --> 00:20:16.250
which corresponds to whatever color
attachment I've attached to my output.

00:20:17.340 --> 00:20:19.960
And you would do this before
link similarly to how it

00:20:19.960 --> 00:20:23.530
works in the vertex stage.

00:20:23.960 --> 00:20:26.910
Also, you can do it after link
and let the compiler decide,

00:20:27.180 --> 00:20:28.760
similarly to how the vertex state works.

00:20:28.760 --> 00:20:30.680
And the same caveats apply here.

00:20:30.680 --> 00:20:33.520
You can't guarantee that they'll
always be in the same order,

00:20:33.520 --> 00:20:35.140
that they'll always
go to the same output.

00:20:35.140 --> 00:20:38.670
So make sure you code defensively,
like I said before,

00:20:38.730 --> 00:20:41.630
and make sure that you're binding
or you're getting the frag

00:20:41.630 --> 00:20:44.430
data locations so your outputs
are going to where you expect.

00:20:44.520 --> 00:20:48.780
So out replaces geo frag data,
geo frag color.

00:20:50.450 --> 00:20:52.780
There's a limit on the
number of outputs you can do.

00:20:52.890 --> 00:20:57.400
Check that limit to make sure
you're not trying to use too many.

00:21:00.510 --> 00:21:03.140
So let's talk about these
API differences from the legacy

00:21:03.260 --> 00:21:05.080
to the core as we move along.

00:21:05.200 --> 00:21:08.940
So GeoVertexPointer, GeoNormalPointer,
GeoColorPointer,

00:21:08.990 --> 00:21:11.760
that all becomes GeoVertexAttribPointer.

00:21:11.950 --> 00:21:12.970
Pretty simple.

00:21:13.030 --> 00:21:16.520
You can use each vertex attribute
for whatever you'd like.

00:21:17.210 --> 00:21:20.020
Now,
when you were enabling things before,

00:21:20.020 --> 00:21:22.140
you would say enable client state.

00:21:22.310 --> 00:21:25.100
That's been completely subsumed
by enable vertex attribute array.

00:21:25.100 --> 00:21:29.830
You just need to enable each
array numerically as you'd like.

00:21:29.810 --> 00:21:33.980
As for rendering, GL begin and end,
completely gone, which is good because

00:21:33.980 --> 00:21:35.230
they were slow anyway.

00:21:35.400 --> 00:21:38.920
And now we're going to GL draw arrays,
GL draw elements.

00:21:39.020 --> 00:21:42.280
And the next thing I'd like to call out,
and I'll talk about this a little later,

00:21:42.340 --> 00:21:45.100
is GL get string with GL extensions.

00:21:45.100 --> 00:21:47.480
Now before,
you wanted to query your extensions,

00:21:47.510 --> 00:21:51.690
use get string, and it just gave you this
massive string full of GL arb,

00:21:51.720 --> 00:21:53.350
gobbledygook.

00:21:53.830 --> 00:21:55.040
That's a little different now.

00:21:55.220 --> 00:21:58.870
Instead of getting a giant string
that's like 100 lines long,

00:21:59.360 --> 00:22:01.400
you query each extension individually.

00:22:01.460 --> 00:22:04.840
So you would say, GL get string i,
and you give it an index.

00:22:05.050 --> 00:22:08.080
And each extension is indexed,
and you get each extension

00:22:08.080 --> 00:22:09.470
string individually.

00:22:09.840 --> 00:22:12.950
I'll go over that in a bit,
why that is and how it works,

00:22:12.950 --> 00:22:15.680
so don't worry too much
about it right now.

00:22:16.980 --> 00:22:18.400
Shader differences.

00:22:18.400 --> 00:22:23.040
Like I said before,
all the built-ins from the

00:22:23.040 --> 00:22:23.040
fixed function are gone.

00:22:23.200 --> 00:22:28.110
So GL model view is now some uniform
that you're passing some matte for.

00:22:28.230 --> 00:22:31.080
GL normal is something you
have to pass down yourself,

00:22:31.080 --> 00:22:33.990
because you can use the attributes
for whatever you'd like.

00:22:34.260 --> 00:22:36.530
In your vertex shader,
what you were labeling as

00:22:36.530 --> 00:22:40.050
attributes before are now inputs,
and what you were labeling

00:22:40.140 --> 00:22:41.640
as varings are now outputs.

00:22:41.760 --> 00:22:45.080
Similarly, in the fragment shader,
varings from the previous stage

00:22:45.090 --> 00:22:49.360
become the inputs of this stage,
and GL frag color becomes a variable

00:22:49.360 --> 00:22:51.450
that you're deciding yourself.

00:22:51.720 --> 00:22:54.970
So some differences subtle,
some not so subtle, but in the end,

00:22:54.970 --> 00:22:57.640
it's for the best,
gives you much better control,

00:22:57.640 --> 00:23:00.880
and helps you wrangle all these
ideas in your head because you can

00:23:00.880 --> 00:23:02.780
call anything whatever you'd like.

00:23:06.400 --> 00:23:09.250
So some other changes as we move
from the legacy to the core.

00:23:09.390 --> 00:23:10.540
Mapping and flushing.

00:23:10.540 --> 00:23:12.180
I think some of you guys are
probably familiar with the

00:23:12.180 --> 00:23:14.380
Apple Flush Buffer Range extension.

00:23:14.520 --> 00:23:15.730
We've had this for a while.

00:23:15.920 --> 00:23:18.900
This has actually come
into the core of OpenGL.

00:23:19.210 --> 00:23:22.080
And now not only can you
flush a range of a buffer,

00:23:22.330 --> 00:23:25.300
you can actually map a range of a buffer.

00:23:25.800 --> 00:23:29.290
So map buffer range will allow you to
map maybe a small portion of the buffer,

00:23:29.440 --> 00:23:33.200
10%. You have 100k buffer,
you can map 1k of it.

00:23:33.230 --> 00:23:36.200
And you can give it a couple flags,
map invalidate buffer,

00:23:36.300 --> 00:23:39.760
which will tell the runtime that you
want to invalidate this entire buffer.

00:23:39.760 --> 00:23:41.400
You're going to replace the entire thing.

00:23:41.420 --> 00:23:42.530
All the data in it's stale.

00:23:42.630 --> 00:23:44.000
Don't worry about it.

00:23:44.090 --> 00:23:46.560
You can also invalidate only a range.

00:23:46.560 --> 00:23:49.300
Like I said before,
I want to map this 1k range.

00:23:49.300 --> 00:23:51.580
I'm going to mark that
1k range as invalid,

00:23:51.580 --> 00:23:52.340
stale data.

00:23:52.360 --> 00:23:55.650
The rest of it's good,
but this stuff I'm going to update.

00:23:56.570 --> 00:23:59.300
There's also the map unsynchronized bit.

00:23:59.430 --> 00:24:03.520
And this is important if you want to edit
something that you're currently using.

00:24:03.660 --> 00:24:06.530
This will tell the GL runtime
not to synchronize on

00:24:06.530 --> 00:24:08.620
previous uses of this buffer.

00:24:08.660 --> 00:24:10.820
So this will also allow you to
stomp the memory you're using.

00:24:10.820 --> 00:24:13.780
So be very careful when you give
it this flag that you're not

00:24:13.890 --> 00:24:16.910
actually writing over something
you're currently drawing with.

00:24:17.340 --> 00:24:20.200
And lastly,
we have the flush explicit bit.

00:24:20.270 --> 00:24:24.280
This will tell GL not to actually flush
this data up until you tell it to.

00:24:24.480 --> 00:24:27.890
So you must use flush map
buffer range in order for this

00:24:28.070 --> 00:24:30.440
data to get up to your GPU.

00:24:30.530 --> 00:24:31.500
So what does this look like?

00:24:31.730 --> 00:24:33.690
Oh, sorry.

00:24:33.830 --> 00:24:35.820
In order to use this,

00:24:36.140 --> 00:24:38.960
You need to have some
synchronization primitives.

00:24:39.110 --> 00:24:41.970
So if you've used Apple Fence
or something similar,

00:24:42.100 --> 00:24:44.310
now we call them sync objects.

00:24:44.440 --> 00:24:48.090
So to insert one of these sync objects,
a fence, into the command stream,

00:24:48.090 --> 00:24:49.980
you would call glFenceSync.

00:24:50.270 --> 00:24:54.250
And this puts a token into the command
and allows you to query it to see if

00:24:54.310 --> 00:24:57.170
all the GPU commands before have run.

00:24:57.860 --> 00:25:01.070
You can query it and tell it to
do a wait on the client side,

00:25:01.310 --> 00:25:04.730
which means your CPU will wait
until the commands have done.

00:25:04.870 --> 00:25:09.000
Or you can do a wait on the service side,
which means the GPU will wait.

00:25:09.030 --> 00:25:12.730
And this allows you to do
interesting synchronization ideas,

00:25:12.730 --> 00:25:15.660
like issue a bunch of
commands and put in a fence.

00:25:15.670 --> 00:25:18.770
Then on another thread,
you can wait on that fence,

00:25:18.770 --> 00:25:21.960
put a GPU wait,
then issue a bunch of other commands.

00:25:21.990 --> 00:25:25.370
And this will guarantee that
the first thread's commands

00:25:25.370 --> 00:25:25.890
have executed before the second.

00:25:26.660 --> 00:25:29.560
So you can queue up commands
based on earlier operations and

00:25:29.560 --> 00:25:31.600
guarantee they will happen in order.

00:25:31.610 --> 00:25:34.770
Now, make sure you flush appropriately.

00:25:35.030 --> 00:25:39.450
So the way the GL works is a command
buffer fills up with commands,

00:25:39.610 --> 00:25:42.710
and when it gets to the end,
spits them out to the GPU and

00:25:42.710 --> 00:25:44.240
they do a bunch of work.

00:25:44.240 --> 00:25:46.060
Now, you can imagine if you
have this big buffer,

00:25:46.400 --> 00:25:50.340
and you fill it up halfway,
and then you put your fence here,

00:25:50.350 --> 00:25:53.780
you could be sitting there for a
long time because nothing's going to

00:25:53.790 --> 00:25:58.170
be sent to the GPU and it fills up,
unless you tell it to flush.

00:25:58.270 --> 00:26:01.570
So if you want to make sure everything
keeps going normally at a good rate,

00:26:01.570 --> 00:26:03.360
then make sure you flush appropriately.

00:26:03.540 --> 00:26:06.200
Now, this is a fine balancing act,
because you don't want to flush too

00:26:06.200 --> 00:26:09.820
much-- that's going to be slow-- and
you don't want to flush too little.

00:26:09.900 --> 00:26:13.160
So take a look at your app and
try to figure out what the precise

00:26:13.160 --> 00:26:15.670
amount of flushing is right for you.

00:26:18.680 --> 00:26:21.200
So here's what a fence sync looks like.

00:26:21.210 --> 00:26:23.170
You insert a fence into
the command stream.

00:26:23.430 --> 00:26:25.340
Pretty simple, fence sync.

00:26:25.390 --> 00:26:29.360
GPU, wait for-- you know, sync commands.

00:26:29.390 --> 00:26:31.920
And that's the only token
you can give this right now.

00:26:31.950 --> 00:26:34.480
Maybe more will be added,
but that's what we've got.

00:26:34.500 --> 00:26:36.580
Map your buffer range.

00:26:37.670 --> 00:26:43.110
And then I can wait, and it'll tell me if
my commands are done.

00:26:43.180 --> 00:26:44.700
Pretty simple.

00:26:46.850 --> 00:26:52.340
Now, I can use this to actually do stuff
in the background while I'm waiting.

00:26:52.370 --> 00:26:54.820
As I map this buffer range,

00:26:55.360 --> 00:26:57.870
I can wait, and on my fence,
I can test to see if all my

00:26:57.990 --> 00:26:59.600
previous commands are done.

00:26:59.660 --> 00:27:03.990
If they are done,
I can modify this buffer and do things,

00:27:03.990 --> 00:27:05.040
you know, to update it.

00:27:05.100 --> 00:27:07.350
If they're not done,
I might want to do some other work so

00:27:07.350 --> 00:27:09.240
I'm not stomping the memory I'm using.

00:27:09.400 --> 00:27:14.140
So this is a way to synchronize
your use of buffer objects with

00:27:14.800 --> 00:27:17.430
your application and updates.

00:27:17.690 --> 00:27:19.520
And then when I'm done
updating my buffer,

00:27:19.550 --> 00:27:20.850
I say flush map buffer range.

00:27:21.080 --> 00:27:23.320
Then I'm going to want
to delete my fence,

00:27:23.330 --> 00:27:25.790
and I'm going to want
to un-map my buffer.

00:27:26.330 --> 00:27:29.300
So if you're actually using
the unsynchronized bit,

00:27:29.300 --> 00:27:31.800
these fences, these sinks,
are a great way to make sure you're

00:27:31.800 --> 00:27:33.390
not actually stomping your memory.

00:27:33.570 --> 00:27:36.080
Because you can insert a
fence after your draws,

00:27:36.210 --> 00:27:38.200
and then you can be sure
that all your draws are done,

00:27:38.200 --> 00:27:42.320
and you're not going to be modifying
the data that those draws were using.

00:27:44.820 --> 00:27:47.300
The next thing we'll talk
about is off-screen rendering.

00:27:47.350 --> 00:27:50.040
Now, we've been pushing
FBO for several years now,

00:27:50.090 --> 00:27:52.340
and now we're finally giving
you the last push to move to it,

00:27:52.400 --> 00:27:55.750
because in the core profile,
there is no more pBuffer.

00:27:55.880 --> 00:27:58.480
FBOs are what you're going to
use for rendering off-screen.

00:27:58.480 --> 00:28:00.890
This is actually good,
because I think FBOs are a whole

00:28:00.900 --> 00:28:02.590
lot easier to use than pBuffers.

00:28:02.900 --> 00:28:05.710
Much more efficient,
the API is much cleaner,

00:28:05.860 --> 00:28:09.580
and the error checking is more strict,
which will help you find bugs,

00:28:09.580 --> 00:28:11.630
because you never know,
when you port something over and

00:28:11.630 --> 00:28:14.340
you start getting these errors,
it turns out that, oh, wait,

00:28:14.340 --> 00:28:15.340
I did that wrong.

00:28:15.340 --> 00:28:18.410
So stricter error checking is
actually really good to catch,

00:28:18.540 --> 00:28:21.940
you know,
sort of small issues in your code.

00:28:23.790 --> 00:28:25.730
Now,
all this might look a little familiar

00:28:25.730 --> 00:28:28.460
to you if you've been using ES 2.0.

00:28:28.610 --> 00:28:31.380
You know,
going straight from the fixed function,

00:28:31.480 --> 00:28:34.780
fully programmable, using generic vertex
attributes for everything,

00:28:34.990 --> 00:28:37.010
no more matrix stack,
managing the matrices yourself.

00:28:37.190 --> 00:28:42.960
So I'll do a little quick comparison
between ES 2.0 and the GL Core Profile.

00:28:43.450 --> 00:28:48.230
had a lot of the same reasonings
behind them to make these changes.

00:28:48.590 --> 00:28:52.600
So ES 2.0 uses generic vertex attributes,
but you'll use the

00:28:52.600 --> 00:28:53.900
attribute keyword there.

00:28:53.920 --> 00:28:58.670
And here, similarly to the legacy profile
compared to the core profile,

00:28:58.670 --> 00:29:00.000
you'll use in.

00:29:00.030 --> 00:29:03.960
And again, there's varying in ES 2.0,
which becomes out.

00:29:03.970 --> 00:29:07.040
Varyings in the fragment
stage becomes in.

00:29:07.100 --> 00:29:10.940
And geofragcolor is still in ES 2.0,
but like I mentioned before,

00:29:11.100 --> 00:29:12.710
now you have your own variable name.

00:29:12.730 --> 00:29:14.880
It can be called whatever you'd like.

00:29:15.700 --> 00:29:19.060
The more interesting differences
are in Cocoa and how you set

00:29:19.150 --> 00:29:21.670
up your ES 2.0 rendering.

00:29:22.300 --> 00:29:27.000
On the iPhone or on the iPad in iOS,
you'll have the Eagle layer.

00:29:27.160 --> 00:29:31.480
You'll grab the EAGL layer,
and you'll start rendering into that.

00:29:31.600 --> 00:29:34.200
Well, you don't have to do that in Lion.

00:29:34.470 --> 00:29:37.940
We have the NSOpenGL view,
which is a standalone object,

00:29:38.020 --> 00:29:41.840
and it allows you to
render right into it.

00:29:42.100 --> 00:29:46.810
And similarly,
how you have an Eagle context in iOS,

00:29:47.140 --> 00:29:49.780
there's an NSOpenGL context.

00:29:50.790 --> 00:29:52.500
on the desktop.

00:29:52.620 --> 00:29:55.670
And lastly, when you're presenting your
rendering to the screen in iOS,

00:29:55.780 --> 00:29:58.310
you're going to use
present render buffer.

00:29:58.700 --> 00:30:02.680
Instead of doing that here,
you're actually going to draw into FBO0.

00:30:02.830 --> 00:30:04.940
FBO0 is the back buffer on the system.

00:30:04.940 --> 00:30:08.280
So if you have a window,
if you have a drawable, you have FBO0.

00:30:08.280 --> 00:30:10.200
Make sure you do have a drawable, though.

00:30:10.200 --> 00:30:13.090
If you don't have a window on the
screen and you create a context,

00:30:13.140 --> 00:30:15.610
your drawing will go nowhere
and there'll be an error.

00:30:15.690 --> 00:30:18.080
So make sure you actually
have a system drawable.

00:30:18.080 --> 00:30:21.320
And to present this information to
the user to send this to the screen,

00:30:21.320 --> 00:30:23.260
you're going to use flush buffer.

00:30:24.700 --> 00:30:25.620
So a quick recap.

00:30:25.880 --> 00:30:27.720
And this OpenGL view
is a standalone object.

00:30:27.810 --> 00:30:30.070
You create the view and
you attach it to a window.

00:30:30.130 --> 00:30:31.800
You can do this in Interface Builder.

00:30:32.050 --> 00:30:33.360
You don't need to grab the GL layer.

00:30:33.420 --> 00:30:35.180
You don't need to use Core Animation.

00:30:35.220 --> 00:30:39.100
And you must use the flush buffer
method of the context in order

00:30:39.100 --> 00:30:41.970
to get that information onto the
screen so that the user can see

00:30:41.980 --> 00:30:44.180
whatever great graphics you've done.

00:30:46.590 --> 00:30:47.900
So quick summary.

00:30:47.940 --> 00:30:48.930
Use the Core Profile.

00:30:49.070 --> 00:30:49.970
It's great.

00:30:50.030 --> 00:30:53.000
A lot of modern features, better API.

00:30:53.040 --> 00:30:56.350
Use the VAOs to group the buffers
that you've got to help you manage

00:30:56.350 --> 00:30:57.950
your enables and all your state.

00:30:58.100 --> 00:31:02.070
Use your generic vertex
attributes to supply data,

00:31:02.130 --> 00:31:04.710
as much data as you'd like.

00:31:04.930 --> 00:31:09.930
And use OpenGL 1.5 for your shaders.

00:31:10.090 --> 00:31:13.500
And that's about it for the Core Profile.

00:31:14.520 --> 00:31:15.600
Now tips.

00:31:15.610 --> 00:31:17.850
I mentioned talking about
querying extension before,

00:31:17.910 --> 00:31:21.120
so I'll give you a quick
hint how to do that.

00:31:21.200 --> 00:31:25.690
GL get string,
GL extensions with an index.

00:31:25.980 --> 00:31:29.600
That's indexed from zero to
the value of GLNUM extensions.

00:31:29.730 --> 00:31:32.340
And individual extension
strings are given to you by this

00:31:32.550 --> 00:31:34.080
result instead of one long one.

00:31:34.100 --> 00:31:37.840
Now, like everything else,
you cannot guarantee what order these

00:31:37.840 --> 00:31:39.650
extension strings will come out in.

00:31:39.660 --> 00:31:42.950
Certain renderers may be
reverse alphabetical order.

00:31:42.950 --> 00:31:45.500
Another renderer may be
in alphabetical order.

00:31:45.500 --> 00:31:47.840
A third renderer may be
in some random order.

00:31:47.840 --> 00:31:50.090
So you're going to have to go
through all of them to make

00:31:50.090 --> 00:31:51.560
sure that they're all enabled.

00:31:51.940 --> 00:31:55.910
So query the GL extensions,
the number of extensions

00:31:56.090 --> 00:31:57.060
with get integer.

00:31:57.060 --> 00:32:01.420
And then you can loop over like I have
here and just test each extension string

00:32:01.420 --> 00:32:03.290
to see which ones are available for you.

00:32:07.480 --> 00:32:09.180
Don't forget to include GL3.h.

00:32:09.280 --> 00:32:14.170
This is OpenGL 3.2,
so there's GL3.h and GL3x.h

00:32:14.210 --> 00:32:15.360
if you're using extensions.

00:32:15.360 --> 00:32:18.400
Calling deprecated API will error.

00:32:18.400 --> 00:32:21.290
It'll give you invalid operations,
so you can't call vertex

00:32:21.290 --> 00:32:22.870
pointer or anything like that.

00:32:23.190 --> 00:32:24.010
That's not valid.

00:32:24.880 --> 00:32:28.680
And the other thing to keep in mind is
there is no vertex array object zero.

00:32:28.680 --> 00:32:31.260
So if you start binding
things without creating a VAO,

00:32:31.260 --> 00:32:32.980
nothing will get to your shader.

00:32:32.980 --> 00:32:36.400
You must create a VAO and you
must bind it before you start

00:32:36.400 --> 00:32:38.420
binding vertex attributes.

00:32:40.170 --> 00:32:42.420
And like I mentioned before,
there must be a drawable

00:32:42.420 --> 00:32:43.500
attached to FBO0.

00:32:43.500 --> 00:32:45.280
So if you don't have a
window on the screen,

00:32:45.280 --> 00:32:47.930
you don't have a drawable,
you can't actually draw anything,

00:32:47.930 --> 00:32:50.950
which seems a little straightforward,
but it's worth repeating.

00:32:54.300 --> 00:32:55.420
All right, let's get into the cool stuff.

00:32:55.530 --> 00:32:56.480
New rendering features.

00:32:56.480 --> 00:32:58.910
Uniform buffer objects.

00:32:58.980 --> 00:33:00.900
This is something people have
requested for a long time,

00:33:00.900 --> 00:33:02.000
and they're really cool.

00:33:02.000 --> 00:33:05.620
They allow you to upload and store
uniform data as a buffer object and

00:33:05.990 --> 00:33:07.920
upload it in massive chunks at once.

00:33:07.920 --> 00:33:10.820
So you use a buffer object for storage,
similar to how you use

00:33:10.820 --> 00:33:11.840
it for vertex data.

00:33:11.840 --> 00:33:13.720
Now you can use it for uniform data.

00:33:13.720 --> 00:33:15.960
And this is faster than
calls to GL uniform.

00:33:16.060 --> 00:33:18.720
So instead of updating
each uniform at once,

00:33:18.720 --> 00:33:22.990
you know, GL uniform, GL uniform,
GL uniform, you can now put it into a

00:33:22.990 --> 00:33:24.180
UBO and upload this all at once.

00:33:24.200 --> 00:33:26.390
all in one chunk.

00:33:27.840 --> 00:33:29.410
So what does this look like?

00:33:29.600 --> 00:33:31.520
Well, it kind of looks like a C struct.

00:33:31.650 --> 00:33:36.400
See, we have the layout which specifies
that this is going to go in order.

00:33:36.680 --> 00:33:38.760
So here I have a whole bunch of matrices.

00:33:38.840 --> 00:33:41.770
This is just going to be matrix, matrix,
matrix, tightly packed.

00:33:41.970 --> 00:33:44.190
There may be some padding
to make sure we're aligned,

00:33:44.260 --> 00:33:45.580
so keep that in mind.

00:33:45.770 --> 00:33:49.650
And so you specify it by
specifying the layout uniform UBO,

00:33:49.650 --> 00:33:55.260
which is going to be the external name
in your code that you reference this by.

00:33:55.320 --> 00:33:57.240
Then you declare it like a C struct.

00:33:57.290 --> 00:33:59.290
I just have a bunch of matrices here.

00:33:59.420 --> 00:34:00.930
And then I'm calling it block.

00:34:01.010 --> 00:34:05.520
So later on in my shader,
I'm going to refer to it as block.mv.

00:34:05.840 --> 00:34:07.640
This is going to be the first matrix.

00:34:07.730 --> 00:34:11.630
Quick, simple shader to give you guys
an idea of how this works.

00:34:11.750 --> 00:34:14.020
So pretty straightforward.

00:34:14.060 --> 00:34:16.600
Now you just have to figure out, well,
how do I hook this up to the

00:34:16.600 --> 00:34:18.770
data that's in my program?

00:34:19.590 --> 00:34:21.900
Well, it's pretty simple.

00:34:21.970 --> 00:34:24.470
Again, you need a binding point
that you define yourself.

00:34:24.510 --> 00:34:25.800
I'm going to call it block binding here.

00:34:25.800 --> 00:34:30.320
And I need to get the index
of my UBO from my shader.

00:34:30.320 --> 00:34:33.710
So I do that with GL get
uniform block index.

00:34:33.760 --> 00:34:37.610
And like I said, in my shader,
I had called it UBO.

00:34:37.670 --> 00:34:42.080
And now I grab it with this function,
the, oops, UBO.

00:34:42.720 --> 00:35:07.930
will now show you how to
bind a buffer to your shader.

00:35:09.090 --> 00:35:09.090
In this example, I'm going to use the
actual UBO from my shader.

00:35:09.090 --> 00:35:09.090
Uniform block binding specifies my UBO is
now going to be binding point zero.

00:35:09.090 --> 00:35:09.090
This is so when I bind a
buffer at the very end,

00:35:09.090 --> 00:35:09.090
I can specify that I want this
bound to buffer the UBO zero.

00:35:09.090 --> 00:35:09.090
So here I'm using bind buffer
range to bind a buffer to my UBO,

00:35:09.090 --> 00:35:09.090
but you can also use bind buffer base.

00:35:09.090 --> 00:35:09.090
So pretty straightforward, not too bad.

00:35:10.510 --> 00:35:12.870
So, hooking it all up,
get the UBL block index,

00:35:12.870 --> 00:35:15.460
which is similar to
the attribute location.

00:35:15.460 --> 00:35:20.170
Set the block binding index,
which you get to specify yourself,

00:35:20.390 --> 00:35:24.580
and then bind your buffer object to that
block binding index that you specified.

00:35:24.580 --> 00:35:28.140
You can use bind buffer
range or bind buffer base,

00:35:28.140 --> 00:35:32.000
and specify buffer some
existing uniform buffer.

00:35:36.190 --> 00:35:38.980
Remember,
you want to check your size limits.

00:35:39.020 --> 00:35:43.030
UBOs cannot be infinitely big,
so query the limits to make

00:35:43.030 --> 00:35:46.770
sure that you're using a
UBO that's not too enormous.

00:35:47.090 --> 00:35:51.590
Just like VBOs, you cannot modify a
UBO that's being used to draw.

00:35:51.730 --> 00:35:54.360
So you can get around this
by orphaning your buffer,

00:35:54.520 --> 00:35:57.700
which you can do by calling
buffer data with null.

00:35:57.740 --> 00:36:00.440
And that will tell the driver,
keep using this buffer,

00:36:00.480 --> 00:36:02.470
and then get rid of it
when you're done with it.

00:36:02.480 --> 00:36:04.370
But right now, I need a new one.

00:36:04.700 --> 00:36:07.520
Or there's the old standby of
double buffering your data,

00:36:07.520 --> 00:36:11.310
which is probably the most
straightforward and easiest way to do it.

00:36:11.910 --> 00:36:17.550
Split frequently used and modified
UBOs into separate objects.

00:36:18.030 --> 00:36:22.390
If you have a UBO that's going
to be updated once a frame,

00:36:22.390 --> 00:36:25.820
and you have a UBO that's going
to be updated once a draw,

00:36:25.850 --> 00:36:27.470
these should be completely
separate objects.

00:36:27.490 --> 00:36:30.860
You shouldn't put them into
the same uniform buffer object.

00:36:31.330 --> 00:36:33.600
and don't update more than you need to.

00:36:33.670 --> 00:36:35.300
Pretty self-explanatory.

00:36:35.310 --> 00:36:37.760
If you can update something once a frame,
you should.

00:36:37.880 --> 00:36:40.640
If you have to update it once a draw,
well, then you have to.

00:36:40.680 --> 00:36:46.590
But if you don't have to, don't do it.

00:36:46.590 --> 00:36:46.590
Because the less data
you send up to the GPU,

00:36:46.590 --> 00:36:46.590
the better overall.

00:36:48.230 --> 00:36:51.260
Now, similar to a UBO,
we have a texture buffer object, a TBO.

00:36:51.260 --> 00:36:54.380
This is a new texture target,
GL texture buffer,

00:36:54.380 --> 00:36:56.720
and a new sampler type,
which is sampler buffer.

00:36:56.720 --> 00:37:00.660
This is quite similar to a UBO,
except that it's a giant 1D texture.

00:37:00.660 --> 00:37:04.250
And this allows you to do fast uploads,
but it also takes advantage

00:37:04.260 --> 00:37:05.230
of texture caching.

00:37:05.240 --> 00:37:08.280
All of your texture units have
a cache associated with them,

00:37:08.280 --> 00:37:11.480
and this will allow you to do
fetches that could be uniform data,

00:37:11.480 --> 00:37:13.020
also backed with that cache.

00:37:13.740 --> 00:37:16.010
And similarly to a UBO,
you have to check your

00:37:16.010 --> 00:37:19.250
texture size limits,
because there are limits to the amount

00:37:19.290 --> 00:37:21.240
of data that can be used with a TBO.

00:37:23.390 --> 00:37:25.320
So how to do this really quickly?

00:37:25.410 --> 00:37:28.570
You generate a texture as normal,
and then you bind a texture

00:37:28.570 --> 00:37:30.400
to the texture buffer target.

00:37:30.730 --> 00:37:33.020
And then you use this text buffer call.

00:37:33.030 --> 00:37:36.980
Now, a texture buffer is backed by a
previously existing buffer object.

00:37:37.040 --> 00:37:40.540
So this does not actually allocate
brand new memory from nowhere.

00:37:40.550 --> 00:37:43.080
You must already have a buffer
object with this data in it.

00:37:43.210 --> 00:37:48.290
So keep that in mind when
you're binding your TBO.

00:37:49.900 --> 00:37:52.330
Shader layout is pretty simple.

00:37:52.420 --> 00:37:54.980
Just declare a sampler buffer.

00:37:55.300 --> 00:38:15.600
[Transcript missing]

00:38:17.700 --> 00:38:19.010
Instancing.

00:38:19.390 --> 00:38:23.000
You might have heard me talk last year
when I talked about divisor instancing.

00:38:23.000 --> 00:38:25.090
Now we have shader instancing.

00:38:25.280 --> 00:38:28.400
Now this is a new built in to
your shader called instance ID.

00:38:28.400 --> 00:38:31.520
And this will increase monotonically
depending on the number of

00:38:31.520 --> 00:38:33.230
instances you're rendering.

00:38:33.250 --> 00:38:37.110
So the first instance, this will be zero,
the second, it will be one and so on.

00:38:37.320 --> 00:38:39.760
And you can use this to index
uniform or texture data,

00:38:39.760 --> 00:38:42.490
something like a skinning
matrix survey would be great.

00:38:42.590 --> 00:38:46.480
If you want to draw 100 skin guys,
you upload a ton of matrices and then you

00:38:46.480 --> 00:38:51.730
draw an instance so that guy zero gets
the bones for instance zero and so on.

00:38:51.740 --> 00:38:59.990
Let's take a quick look at the shader.

00:39:00.020 --> 00:39:05.030
Looks pretty simple.

00:39:05.060 --> 00:39:07.130
So I have a UBO here.

00:39:10.560 --> 00:39:14.110
And when I access it,
I access it with the instance ID.

00:39:14.200 --> 00:39:17.060
So here,
whatever model new matrix I'm using

00:39:17.060 --> 00:39:22.020
for this instance is just indexed into
this giant array of matrices I have.

00:39:22.020 --> 00:39:25.980
Easy way to do instancing,
pretty straightforward.

00:39:27.740 --> 00:39:29.240
Next, we have multi-sample textures.

00:39:29.340 --> 00:39:33.800
These are multi-sample render targets,
another new texture target.

00:39:33.980 --> 00:39:36.310
To create a multi-sample texture,
you need to decide how many

00:39:36.320 --> 00:39:39.450
samples you'd like and whether
they're a fixed sample size.

00:39:39.560 --> 00:39:43.580
Now, the fixed sample size means each
sample in the texture will be the

00:39:43.580 --> 00:39:48.280
same size and in the same place,
proportionally.

00:39:48.480 --> 00:39:52.340
You can decide what's right for
your rendering or what you'd like.

00:39:52.410 --> 00:39:56.400
Then you use Tech Image 2D Multi-Sample,
and quite similar to

00:39:56.540 --> 00:39:59.050
the regular Tech Image,
but now you want to supply

00:39:59.050 --> 00:40:03.080
your sample count and whether
sample location is fixed or not.

00:40:04.890 --> 00:40:07.210
So you could use this for
something like deferred rendering.

00:40:07.360 --> 00:40:10.910
Deferred rendering does not typically
handle multi-sampling very well,

00:40:10.910 --> 00:40:13.840
but if you multi-sample
each slice of the G buffer,

00:40:13.940 --> 00:40:17.100
you can actually get some cool
anti-aliasing out of here.

00:40:17.130 --> 00:40:20.070
So in this case,
I have a multi-sample texture

00:40:20.120 --> 00:40:22.200
for my positions on the left.

00:40:22.550 --> 00:40:25.860
I have a multi-sample texture for my
normals in the middle and a multi-sample

00:40:25.860 --> 00:40:28.130
texture for the albedo on the right.

00:40:28.330 --> 00:40:31.550
And these then feed into
the final composited image,

00:40:31.550 --> 00:40:35.130
and I get an anti-alias teapot
with deferred rendering.

00:40:35.250 --> 00:40:37.680
Now keep in mind,
this will take a little bit more

00:40:37.680 --> 00:40:41.410
RAM than a regular deferred renderer,
but you'll actually get the

00:40:41.490 --> 00:40:43.420
benefits of anti-aliasing this way.

00:40:45.420 --> 00:40:48.330
So to access this in the shader,
here's a quick shader for

00:40:48.330 --> 00:40:49.850
my deferred rendering.

00:40:50.110 --> 00:40:53.420
I declare a multi-sample texture sampler.

00:40:54.640 --> 00:40:59.300
And then I actually need to loop
over all my samples to decide

00:40:59.300 --> 00:41:01.220
how I'm going to resolve this,
because these are not

00:41:01.220 --> 00:41:02.340
resolved automatically.

00:41:02.420 --> 00:41:04.260
You have to do the resolve yourself.

00:41:04.350 --> 00:41:08.570
So like I mentioned before,
TexelFetch uses integer coordinates.

00:41:09.450 --> 00:41:14.330
So you need to actually calculate
your normalized coordinates and

00:41:14.330 --> 00:41:16.770
make them into integer coordinates,
unless you're specifying

00:41:17.170 --> 00:41:18.670
integer coordinates yourself.

00:41:18.770 --> 00:41:20.900
You can do this with the
texture size built in.

00:41:21.110 --> 00:41:22.780
You use texture size and
you give it a sampler,

00:41:22.780 --> 00:41:26.100
and it will give you the width
and the height of that texture.

00:41:26.300 --> 00:41:29.340
So here I'm just multiplying
my normalized coordinates by

00:41:29.340 --> 00:41:32.320
the width and the height to
get the integer coordinates.

00:41:32.410 --> 00:41:34.700
And I'm using Texel Fetch.

00:41:36.300 --> 00:41:37.090
to resolve these.

00:41:37.310 --> 00:41:38.370
So I loop over samples.

00:41:38.520 --> 00:41:41.530
So maybe I have four samples
in my multi-sample texture.

00:41:41.800 --> 00:41:47.460
I loop over and resolve it sample by
sample and accumulate this into my color.

00:41:48.530 --> 00:41:50.940
So pretty straightforward
and quite simple,

00:41:51.010 --> 00:41:54.540
but an interesting technique nonetheless.

00:41:58.630 --> 00:42:00.640
Some other quick tips and tricks.

00:42:00.700 --> 00:42:04.220
If you're using the legacy context,
keep in mind that texture2d.lod,

00:42:04.220 --> 00:42:05.750
which is something
I see in a lot of games,

00:42:05.760 --> 00:42:07.080
is actually an extension.

00:42:07.080 --> 00:42:08.460
This is not a built-in.

00:42:08.460 --> 00:42:12.340
If you want to use this functionality,
you need to use the pound extension

00:42:12.720 --> 00:42:16.770
pragma and require it so the shader
compiler knows that you want to use this.

00:42:18.380 --> 00:42:21.380
Another thing I want to bring up is that
TBO and PBO are actually separate things.

00:42:21.450 --> 00:42:24.110
Now, we're introducing TBO,
which sounds similar to PBO,

00:42:24.110 --> 00:42:26.300
the pixel buffer object,
but these actually are

00:42:26.300 --> 00:42:27.650
not the same thing at all.

00:42:27.930 --> 00:42:30.940
Texture buffer object is a
texture-backed buffer storage.

00:42:30.950 --> 00:42:34.780
Pixel buffer object is more used
for asynchronous texture upload.

00:42:34.780 --> 00:42:36.930
So keep that in mind when you're
thinking about the two of them

00:42:37.020 --> 00:42:38.330
and when you're writing your app.

00:42:38.460 --> 00:42:41.160
Make sure you pick the right
one for whatever job is at hand.

00:42:44.010 --> 00:42:46.770
So let's quickly go over some
other new features that we're

00:42:46.870 --> 00:42:48.290
bringing forward in Lion.

00:42:48.410 --> 00:42:51.240
The first one that I'm really excited
about is automatic graphics switching,

00:42:51.260 --> 00:42:53.200
and we really want you
to save the battery.

00:42:53.340 --> 00:42:55.240
So what is automatic switching?

00:42:55.330 --> 00:42:57.880
Well, like I said,
if you bought a laptop in the last year,

00:42:57.880 --> 00:43:00.590
year and a half,
you know you have two GPUs in there.

00:43:00.700 --> 00:43:03.930
You have one GPU that's integrated,
doesn't use much power,

00:43:04.130 --> 00:43:06.780
has great battery life,
and you have one that's discrete,

00:43:06.890 --> 00:43:09.050
which is really powerful.

00:43:09.410 --> 00:43:11.150
Now,
we're giving you the power to use the

00:43:11.190 --> 00:43:15.530
integrated GPU so that your apps and your
users can have really good battery life.

00:43:15.620 --> 00:43:18.300
In order to do this,
the first thing you have to do is create

00:43:18.300 --> 00:43:21.540
a pixel format that tracks multiple GPUs.

00:43:21.680 --> 00:43:25.100
And this is the Allow Offline
Renderer pixel format.

00:43:25.930 --> 00:43:30.600
So put that into your declaration
when you create your context.

00:43:30.660 --> 00:43:33.280
Now,
to actually support the integrated GPU,

00:43:33.490 --> 00:43:35.990
you just have to add an
attribute to your plist,

00:43:36.010 --> 00:43:38.520
which is this
NSSupportsAutomaticGraphicSwitching.

00:43:38.650 --> 00:43:39.770
This is a Boolean attribute.

00:43:39.870 --> 00:43:41.160
You just set it to yes.

00:43:41.210 --> 00:43:45.120
That tells the system, hey,
I want to run on the integrated GPU.

00:43:45.400 --> 00:43:47.980
If you want more information
about doing this,

00:43:48.020 --> 00:43:50.180
more information about
supporting multiple GPUs,

00:43:50.340 --> 00:43:54.780
you can see session 310,
which is from WWDC 2009.

00:43:54.980 --> 00:43:58.230
Now, if you're going to do this,
I can't stress enough,

00:43:58.400 --> 00:44:00.970
test on actual hardware.

00:44:01.510 --> 00:44:03.780
The driver for the integrated
parts is different than the

00:44:03.780 --> 00:44:05.630
driver for the discrete parts.

00:44:05.630 --> 00:44:07.970
They may have different characteristics.

00:44:07.970 --> 00:44:10.940
So you want to make sure your app
runs well on the integrated driver

00:44:10.940 --> 00:44:14.400
that you get the performance you want
and there are no rendering errors.

00:44:14.400 --> 00:44:17.650
You also want to make sure that your
app survives switching between the two.

00:44:17.650 --> 00:44:20.740
So let's say you have an application
that's running on the integrated

00:44:20.740 --> 00:44:23.790
part and then the system decides,
hey, I need the discrete part,

00:44:23.790 --> 00:44:24.830
so I'm going to kick it up.

00:44:24.970 --> 00:44:26.520
All the applications will move over.

00:44:26.520 --> 00:44:29.090
And you want to make sure
your app moves over cleanly,

00:44:29.090 --> 00:44:31.860
smoothly, without any flickering or
any texture corruption.

00:44:31.920 --> 00:44:36.040
So you can do that by starting up your
app and then opening another GL app,

00:44:36.480 --> 00:44:40.050
maybe even something as simple as chess,
to make sure you survive the

00:44:40.050 --> 00:44:43.320
transition without any weird artifacts.

00:44:43.380 --> 00:44:46.200
Also, make sure the reverse is true.

00:44:46.200 --> 00:44:49.860
So when everything is running on discrete
and you close down all the applications

00:44:49.860 --> 00:44:52.930
that require the high-power GPU,
you want to make sure your app

00:44:53.140 --> 00:44:56.360
switches back to the integrated
GPU gracefully as well.

00:44:56.470 --> 00:44:59.320
So make sure you test on actual
hardware if you're doing this.

00:44:59.320 --> 00:45:01.810
A lot of latent bugs will
show up as weird flickering,

00:45:01.810 --> 00:45:04.130
slight texture corruption
for a split second,

00:45:04.220 --> 00:45:05.510
something like that.

00:45:05.590 --> 00:45:08.180
And that usually means that there's
some issue with the way you're

00:45:08.180 --> 00:45:11.840
uploading textures or you're not
doing something completely safely.

00:45:11.840 --> 00:45:15.200
And if you do this and you figure, like,
man, I'm doing everything right,

00:45:15.200 --> 00:45:17.490
as always, feel free to file a bug.

00:45:19.310 --> 00:45:20.020
Some other cool stuff.

00:45:20.150 --> 00:45:21.750
I hope you all went to the OpenCL talks.

00:45:21.810 --> 00:45:24.920
If not, I highly encourage you
to go check them out.

00:45:25.010 --> 00:45:29.200
Talked about a lot of cool stuff that
we're bringing forward in Lion in OpenCL.

00:45:29.200 --> 00:45:31.080
IOSurface.

00:45:31.080 --> 00:45:34.140
IOSurface will let you share
things between contexts and apps.

00:45:34.260 --> 00:45:36.900
Now,
you cannot share between an OpenGL legacy

00:45:36.900 --> 00:45:39.000
context and an OpenGL core context.

00:45:39.080 --> 00:45:40.290
One thing to keep in mind.

00:45:40.290 --> 00:45:41.880
You absolutely must share data.

00:45:41.880 --> 00:45:42.980
You can try IOSurface.

00:45:42.980 --> 00:45:45.840
And lastly, OpenGL Profiler.

00:45:47.340 --> 00:45:50.290
OpenGL Profiler is our awesome
profiler tool that lets you

00:45:50.290 --> 00:45:52.110
profile your app and debug it.

00:45:52.210 --> 00:45:55.120
Now we've added a great new feature,
which is remote profiling.

00:45:55.120 --> 00:45:58.150
So you can control profiler from
one machine and run the app on

00:45:58.150 --> 00:46:00.730
another machine and actually
control it over the network,

00:46:00.770 --> 00:46:03.040
which is great,
especially for full screen apps.

00:46:06.310 --> 00:46:08.690
So full screen modes,
speaking of full screen.

00:46:08.810 --> 00:46:11.400
If you want full screen,
the best way to do this is something

00:46:11.400 --> 00:46:14.180
we've been saying for a couple years,
is just create a covering window.

00:46:14.180 --> 00:46:16.820
Cover the entire screen and draw to it.

00:46:16.870 --> 00:46:19.950
This gives you all the benefits of
full screen and none of the drawbacks.

00:46:20.040 --> 00:46:25.450
It also will give you a slight
performance benefit as we

00:46:25.560 --> 00:46:29.810
automatically switch you into the
high performance rendering path in

00:46:29.810 --> 00:46:29.810
terms of compositing to the screen.

00:46:30.000 --> 00:46:32.540
This also has the benefit,
if there's a notification

00:46:32.540 --> 00:46:34.960
that needs to pop up,
the user actually will get

00:46:35.040 --> 00:46:37.870
the notifications without
anything blocking the way.

00:46:37.980 --> 00:46:39.760
Because before,
if you had captured the fullscreen,

00:46:39.800 --> 00:46:43.360
they could have 10 or 15 windows
behind there that they'd never seen.

00:46:43.370 --> 00:46:46.760
If you absolutely must switch modes,
check the QAs that we've

00:46:46.760 --> 00:46:48.380
got on the developer site.

00:46:48.380 --> 00:46:50.760
There's a couple of
things that you can use,

00:46:50.820 --> 00:46:54.280
but again, we'd like to encourage you
to actually just create the

00:46:54.350 --> 00:46:56.240
fullscreen covering window.

00:46:56.260 --> 00:46:59.560
Now, I know some apps will use
the CG display base address,

00:46:59.580 --> 00:47:01.580
which used to give you
the frame buffer pointer.

00:47:01.580 --> 00:47:03.200
This returns null now.

00:47:03.200 --> 00:47:04.920
You can no longer grab it.

00:47:05.080 --> 00:47:06.360
So keep that in mind.

00:47:06.370 --> 00:47:07.300
Don't use it.

00:47:07.300 --> 00:47:11.170
You'll get null, and then you'll crash,
which is undesirable, to say the least.

00:47:11.260 --> 00:47:14.980
If you're interested in video capture
and capturing things for the screen,

00:47:14.980 --> 00:47:16.690
there's been a couple of
great AV Foundation talks.

00:47:16.750 --> 00:47:20.710
I'll go over what they were at the end,
and you can go check those out if you're

00:47:20.840 --> 00:47:22.790
wondering how to capture from the screen.

00:47:26.110 --> 00:47:27.360
So a quick wrap up.

00:47:27.650 --> 00:47:30.120
We have lots of great
new features in Lion.

00:47:30.370 --> 00:47:32.650
Want to take advantage
of the Core Profile.

00:47:32.860 --> 00:47:34.180
Create that context.

00:47:34.310 --> 00:47:35.550
Create a couple of VAOs.

00:47:35.750 --> 00:47:37.880
Use your generic vertex attributes.

00:47:37.920 --> 00:47:39.700
And use GLSL 150.

00:47:39.890 --> 00:47:40.900
And try out the new features.

00:47:41.070 --> 00:47:42.170
Try out instancing.

00:47:42.270 --> 00:47:43.060
Use UBOs.

00:47:43.180 --> 00:47:44.040
Use TBOs.

00:47:44.370 --> 00:47:45.540
Use multi-sample textures.

00:47:45.620 --> 00:47:48.140
These are all really cool,
powerful features you can use to

00:47:48.310 --> 00:47:50.210
make your applications look great.

00:47:50.310 --> 00:47:50.910
So try them out.

00:47:51.070 --> 00:47:52.200
Integrate them into your apps.

00:47:52.220 --> 00:47:55.040
Let us know what you like about them,
what you don't like about them.

00:47:55.040 --> 00:47:58.340
We're always listening.

00:47:58.350 --> 00:48:00.620
And now I'm going to
show you a quick demo,

00:48:00.640 --> 00:48:02.790
demoing instancing.

00:48:11.230 --> 00:48:18.770
So here we've got a galaxy
and staying on that theme.

00:48:19.860 --> 00:48:21.340
So I want to draw this planet.

00:48:21.340 --> 00:48:22.260
Looks pretty cool.

00:48:22.260 --> 00:48:24.740
It's got some asteroids floating around.

00:48:24.740 --> 00:48:28.280
And as you can see,
I'm making 10,000 draw calls.

00:48:28.320 --> 00:48:30.430
And I have-- or sorry, 1,000 draw calls.

00:48:30.440 --> 00:48:34.020
And I have 1,000 objects,
which is about 70,000 vertices.

00:48:34.230 --> 00:48:36.350
And I'd really like more.

00:48:36.620 --> 00:48:37.400
I'm really into more.

00:48:37.550 --> 00:48:40.790
So let's say 2,000.

00:48:41.840 --> 00:48:47.170
You can see things are getting a little
slow as I draw all these asteroids.

00:48:47.790 --> 00:48:50.980
So I can draw about
7,000 of them with 60,

00:48:51.000 --> 00:48:54.480
but I really like-- this
doesn't look very realistic.

00:48:54.480 --> 00:48:56.080
I want more density.

00:48:57.910 --> 00:48:58.900
I want 50,000.

00:48:58.900 --> 00:48:59.730
That looks okay.

00:48:59.730 --> 00:49:03.080
We're starting to get there,
but really I'd like, you know, like 100.

00:49:03.080 --> 00:49:04.200
That'd be great.

00:49:05.630 --> 00:49:08.300
So yeah, so now I have my 100,000.

00:49:08.390 --> 00:49:12.850
I'm running at 4/5,
and this isn't really acceptable.

00:49:13.190 --> 00:49:15.670
But if I have instancing--

00:49:18.300 --> 00:49:19.540
I'm now running at 100 fips.

00:49:19.540 --> 00:49:20.070
This is great.

00:49:20.070 --> 00:49:21.460
So I can even put in more.

00:49:21.460 --> 00:49:24.310
Oh, man, 130, 140, 150.

00:49:27.190 --> 00:49:28.100
Oh, let's do more.

00:49:28.100 --> 00:49:30.100
Let's see.

00:49:30.190 --> 00:49:32.100
170.

00:49:32.180 --> 00:49:34.090
Yeah, so we'll top out about 180,000.

00:49:34.100 --> 00:49:36.000
That looks much more
like an actual planet.

00:49:36.100 --> 00:49:38.100
And you can see I have
a nice little shadow,

00:49:38.130 --> 00:49:42.100
and the asteroids are slightly colored,
because we're thinking, like, Saturn has,

00:49:42.100 --> 00:49:44.580
you know, slightly colored rings.

00:49:44.790 --> 00:49:47.080
Now we're in the dark of the planet.

00:49:47.180 --> 00:49:50.990
So you can see here that with a UBO,
I actually can draw all

00:49:50.990 --> 00:49:54.730
this with 176 draw calls,
which is way better than

00:49:54.790 --> 00:49:56.320
the 180,000 draw calls.

00:49:56.400 --> 00:50:00.200
Now, let's see how slow-- if
I go back to non-instanced,

00:50:00.200 --> 00:50:01.010
yeah.

00:50:01.680 --> 00:50:03.130
So that's 180,000 draws.

00:50:03.130 --> 00:50:05.140
That's 176.

00:50:05.140 --> 00:50:08.400
Now, I have to do 176 because,
as I said before,

00:50:08.400 --> 00:50:09.980
there's a limit to the size of the UBO.

00:50:09.980 --> 00:50:13.100
However, the TBO limit is much greater.

00:50:13.100 --> 00:50:16.480
So I can actually do this
with one draw call with a TBO.

00:50:16.480 --> 00:50:20.550
This is 12 million vertices,
12.6 million vertices

00:50:20.550 --> 00:50:22.220
with a single draw call.

00:50:22.220 --> 00:50:27.760
And I get 60 frames a second,
one draw call, runs super fast.

00:50:27.780 --> 00:50:29.520
So instancing is really cool.

00:50:29.920 --> 00:50:32.610
You can use, I mean,
you can instance whatever you like.

00:50:32.630 --> 00:50:34.970
It doesn't have to be asteroids,
what we've got here.

00:50:34.980 --> 00:50:37.650
I mean, you can see that each asteroid
is slightly spinning and it's

00:50:37.650 --> 00:50:39.000
rotating around the planet.

00:50:39.000 --> 00:50:41.020
So you can actually have them
be doing things completely

00:50:41.020 --> 00:50:42.910
independent of each other,
even though you're only

00:50:42.910 --> 00:50:43.840
using one draw call.

00:50:45.920 --> 00:50:49.920
So that's a quick instancing demo,
just to give you an idea of what you

00:50:49.920 --> 00:50:51.680
can accomplish with this technique.

00:50:51.680 --> 00:50:53.410
It's pretty cool.

00:51:01.960 --> 00:51:05.080
Now, if you need more information,
Alan Schafer is our graphic and

00:51:05.160 --> 00:51:06.690
games technologies evangelist.

00:51:06.800 --> 00:51:08.160
Drop him an email.

00:51:08.450 --> 00:51:10.360
He's always waiting to hear from you.

00:51:10.420 --> 00:51:12.620
And if you want to
hear more about OpenGL,

00:51:12.810 --> 00:51:14.910
check out the OpenGL programming guide.

00:51:15.140 --> 00:51:17.240
Now, right now,
it's still in pre-release because

00:51:17.240 --> 00:51:18.850
Lion has not made it out to the public.

00:51:18.960 --> 00:51:22.250
But you guys can check it
out on developer.apple.com.

00:51:22.960 --> 00:51:24.310
Couple of more pieces of information.

00:51:24.440 --> 00:51:28.200
We have technical
QAs about screen capture,

00:51:28.200 --> 00:51:30.680
an image snapshot,
and using the integrated GPU.

00:51:30.910 --> 00:51:33.050
And if you're curious
which QA numbers they are,

00:51:33.050 --> 00:51:34.100
they're in the link here.

00:51:34.100 --> 00:51:38.440
But 1740 is capturing
screen activity to a movie.

00:51:38.580 --> 00:51:41.610
1741 is how to take an image snapshot.

00:51:41.920 --> 00:51:45.560
Using the integrated GPU is 1734.

00:51:45.750 --> 00:51:47.940
And another tech note on
supporting multiple GPUs,

00:51:48.000 --> 00:51:49.990
because if you do want to
use the integrated GPU,

00:51:50.230 --> 00:51:52.300
that is equivalent to
supporting multiple GPUs,

00:51:52.300 --> 00:51:53.790
because you will actually have two.

00:51:53.830 --> 00:51:55.910
There's the integrated
one and the discrete one.

00:51:56.020 --> 00:51:59.790
So make sure you check those out if
you're interested in any of those topics.

00:52:00.850 --> 00:52:01.860
These are the related sessions.

00:52:01.860 --> 00:52:04.860
Unfortunately, they've already passed,
but you can go check out the videos.

00:52:04.910 --> 00:52:07.040
So there's the best
practices for OpenGL ES.

00:52:07.090 --> 00:52:10.640
A lot of those apply to the desktop
as well because ES 2.0 and the

00:52:10.650 --> 00:52:12.600
Core Profile are quite similar.

00:52:12.600 --> 00:52:15.140
Of course, you have a little bit
more power on the desktop.

00:52:15.140 --> 00:52:18.700
And then there's introducing
AV Foundation Capture,

00:52:18.730 --> 00:52:22.380
which we'll go over stuff about
capturing stuff from the display

00:52:22.900 --> 00:52:24.980
if you're interested in that.

00:52:24.980 --> 00:52:26.050
And that's it.

00:52:26.050 --> 00:52:27.890
Thanks for coming to hear me talk,
and I hope to see you at the lab.
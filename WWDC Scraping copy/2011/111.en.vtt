WEBVTT

00:00:09.160 --> 00:00:11.730
Good morning, everyone,
and welcome to this

00:00:11.740 --> 00:00:16.580
presentation on Visualizing
Information Geographically with Map Kit.

00:00:17.460 --> 00:00:20.760
I'd like to start by showing you
some of the things that developers

00:00:20.950 --> 00:00:22.900
have done with the Map Kit API.

00:00:26.270 --> 00:00:30.730
So we've seen applications
that show local content,

00:00:30.730 --> 00:00:34.460
such as restaurants and bars,
to help users find what

00:00:34.500 --> 00:00:36.010
they're looking for.

00:00:36.570 --> 00:00:41.020
We've also seen new and interesting
ways to visualize information,

00:00:41.030 --> 00:00:45.220
such as how light is cast at different
angles depending on where you are

00:00:45.220 --> 00:00:47.890
in the world and what time it is.

00:00:49.060 --> 00:00:53.320
We've also seen ways to track
jogging information and track

00:00:53.420 --> 00:00:56.610
overall fitness of users over time.

00:00:58.120 --> 00:01:01.060
And these are just some of the
creative and useful ways to use the

00:01:01.150 --> 00:01:03.750
Map Kit framework in your applications.

00:01:04.120 --> 00:01:07.130
And all of these applications
were written by developers,

00:01:07.130 --> 00:01:12.310
and they all use the same basic
functionality exposed by the Map Kit API.

00:01:15.160 --> 00:01:20.940
The ability to pan and zoom
to different areas of the map.

00:01:21.100 --> 00:01:26.440
The ability to annotate
specific locations on the map.

00:01:26.590 --> 00:01:30.290
The ability to locate
the user on the map.

00:01:32.540 --> 00:01:38.200
and the ability to overlay
data on top of the map.

00:01:38.250 --> 00:01:41.580
With that, I'd like to move into
the agenda for the day.

00:01:44.500 --> 00:01:46.890
So I want to begin by talking
about one of the fundamental

00:01:47.000 --> 00:01:50.670
parts of the Map Kit API,
which is the map view.

00:01:51.690 --> 00:01:55.290
Then we'll talk about using
annotations to show things on the map

00:01:55.400 --> 00:01:57.740
and to personalize your application.

00:01:59.200 --> 00:02:02.930
Afterwards, we'll talk about using user
location to provide context to

00:02:02.930 --> 00:02:05.700
what the user is looking at.

00:02:05.840 --> 00:02:09.820
And then we'll cover the new tracking
modes that have been added in iOS 5.

00:02:11.770 --> 00:02:17.300
Then we'll talk about using overlays
to put your own data on top of the map.

00:02:17.410 --> 00:02:21.490
And lastly, we'll talk about the
geocoding changes in iOS 5.

00:02:23.500 --> 00:02:25.980
So as I mentioned,
one of the fundamental parts of

00:02:25.980 --> 00:02:28.900
the Map Kit API is the map view.

00:02:30.800 --> 00:02:34.000
This allows you to embed a map
in your application and let

00:02:34.000 --> 00:02:37.390
your users explore the world.

00:02:37.480 --> 00:02:41.570
And the specific class you'll
be interested in is mkMapView.

00:02:44.270 --> 00:02:48.900
MKMapView is a UIView subclass which
you can stick in your view hierarchy.

00:02:48.970 --> 00:02:51.170
You can also add it to your nib.

00:02:51.710 --> 00:02:53.950
It's very easy to use.

00:02:54.380 --> 00:02:58.870
It handles panning and zooming gestures
for you and it loads tiles automatically.

00:02:58.870 --> 00:03:02.590
And it's written to
achieve high performance.

00:03:03.350 --> 00:03:07.550
Now, I just mentioned that
MKMapView is a UI view.

00:03:07.550 --> 00:03:10.610
And one of the nice things about this
is that you can add gesture recognizers

00:03:10.680 --> 00:03:13.470
to it to override touch handling.

00:03:14.130 --> 00:03:16.420
In the past,
we've seen some people try to

00:03:16.560 --> 00:03:19.830
subclass MKMapView in order
to override touch handling,

00:03:19.830 --> 00:03:23.000
but using gesture recognizers
is the right way to do this.

00:03:23.000 --> 00:03:29.480
MKMapView also lets you show
different types of maps.

00:03:32.160 --> 00:03:36.460
There are the regular maps,
which show clear labels to help users

00:03:36.460 --> 00:03:38.880
orient themselves and the world.

00:03:39.690 --> 00:03:42.390
There are these satellite maps
which are helpful for seeing

00:03:42.400 --> 00:03:45.290
landmarks and geographical features.

00:03:45.560 --> 00:03:48.440
and there are the hybrid maps
which overlay the labels on

00:03:48.440 --> 00:03:50.900
top of the satellite imagery.

00:03:52.810 --> 00:03:56.050
Now, once you have a map view
embedded in your application,

00:03:56.100 --> 00:03:59.900
you're going to want your application
logic to cooperate with the map view.

00:04:00.030 --> 00:04:03.320
And to do that,
you'll need an MKMapView delegate.

00:04:05.260 --> 00:04:08.260
Once you have this delegate
object in your application,

00:04:08.260 --> 00:04:13.000
the MapView will be able to communicate
certain events to your application.

00:04:15.220 --> 00:04:19.860
And one of the most important events
that the MapView can communicate to

00:04:19.900 --> 00:04:24.630
your application is what region of the
world the user is currently looking at.

00:04:26.100 --> 00:04:28.240
Before I talk about how
the MapView communicates

00:04:28.350 --> 00:04:30.790
that to your application,
I'd like to first talk about

00:04:31.210 --> 00:04:34.690
how the MapView describes
different areas of the world,

00:04:34.860 --> 00:04:37.260
starting with map regions.

00:04:39.230 --> 00:04:42.700
So a map region consists
of a center coordinate,

00:04:42.740 --> 00:04:44.920
a latitude and longitude,

00:04:45.470 --> 00:04:51.640
As well as a span consisting of a
latitudinal and longitudinal delta.

00:04:51.700 --> 00:04:56.840
And together this makes
MK coordinate region.

00:04:56.940 --> 00:05:00.750
And you can use these regions to
change the position of the map.

00:05:02.680 --> 00:05:05.620
So if you set the region property,
you'll be able to change

00:05:05.620 --> 00:05:08.240
the map position and scale.

00:05:08.240 --> 00:05:10.270
So here we've just zoomed in.

00:05:11.190 --> 00:05:14.900
And you should be aware that what
you set on the region property may

00:05:14.900 --> 00:05:17.840
not be what the map view actually
uses because it needs to choose an

00:05:17.840 --> 00:05:21.090
optimal display for your device.

00:05:21.190 --> 00:05:23.740
And as you just saw,
you can animate transitions

00:05:23.740 --> 00:05:25.490
between different regions.

00:05:26.430 --> 00:05:30.900
Now, there are also cases where you may
want to change the position of the

00:05:30.900 --> 00:05:33.540
map without changing the scale.

00:05:33.700 --> 00:05:36.980
And to do that,
you can use the center coordinate.

00:05:38.800 --> 00:05:42.460
So you can use the center coordinate
to change the position of the

00:05:42.460 --> 00:05:44.460
map without changing the scale.

00:05:44.480 --> 00:05:48.600
And as you see here,
we can pan across the map.

00:05:48.620 --> 00:05:51.880
And once again,
you can animate these transitions.

00:05:53.600 --> 00:05:56.190
So you can use the center coordinate
to change the map position

00:05:56.210 --> 00:05:59.450
without changing the scale,
and you can use the region property to

00:05:59.460 --> 00:06:02.200
change the map position and the scale.

00:06:03.300 --> 00:06:06.920
Using the region property
can result in some pitfalls.

00:06:06.920 --> 00:06:09.150
I'd like to cover some of those.

00:06:11.450 --> 00:06:14.050
So let's imagine we're creating
an application that tracks

00:06:14.520 --> 00:06:16.640
flights across the world.

00:06:16.930 --> 00:06:19.030
And in particular,
we're going to focus on a flight that

00:06:19.230 --> 00:06:22.330
starts in Cameroon and goes to France.

00:06:23.240 --> 00:06:26.220
And we've decided that in order
to maintain the same perspective,

00:06:26.260 --> 00:06:29.880
we're going to maintain a 30
degree latitudinal delta and a

00:06:29.880 --> 00:06:32.440
20 degree longitudinal delta.

00:06:33.990 --> 00:06:38.360
So we start up our application
and we begin following our flight.

00:06:38.380 --> 00:06:41.700
We start over Cameroon and we head north.

00:06:41.900 --> 00:06:45.570
We move over Algeria and the
perspective stays the same,

00:06:45.570 --> 00:06:47.440
so everything looks fine.

00:06:47.570 --> 00:06:50.980
But then when we move
further north over France,

00:06:50.980 --> 00:06:53.730
all of a sudden the map scales out.

00:06:53.890 --> 00:06:55.670
So what just happened?

00:06:56.670 --> 00:06:58.440
Why did we zoom out?

00:06:58.510 --> 00:07:02.940
I thought we fixed a constant
map region as we moved.

00:07:03.040 --> 00:07:06.900
So let's take a look at this map
region as we move throughout the world.

00:07:08.630 --> 00:07:13.580
So we started over Cameroon and we
had our 30 degree latitudinal delta.

00:07:13.660 --> 00:07:19.060
And then we moved north over Algeria with
the same 30 degree latitudinal delta.

00:07:19.130 --> 00:07:23.850
But as you see here,
the map region has been stretched a bit.

00:07:24.940 --> 00:07:28.870
And then as we move
further north over France,

00:07:28.940 --> 00:07:31.800
the region's been stretched to the
point that the map view needs to scale

00:07:32.040 --> 00:07:34.710
out in order to show the full region.

00:07:36.130 --> 00:07:38.890
Why does this happen?

00:07:38.990 --> 00:07:42.880
This happens because the map view
uses the Mercator projection.

00:07:44.440 --> 00:07:47.710
The Mercator projection is a standard
method for taking the globe and

00:07:47.790 --> 00:07:50.670
projecting that onto a 2D surface.

00:07:51.500 --> 00:07:54.090
and one of the intrinsic properties
of the Mercator projection is that

00:07:54.310 --> 00:07:58.880
areas that are further from the
equator get distorted and stretched.

00:07:59.240 --> 00:08:02.190
So this area on the globe,
which looks like a square,

00:08:02.190 --> 00:08:04.270
when projected using
the Mercator projection,

00:08:04.270 --> 00:08:09.210
will end up looking like a
rectangle over northern Europe.

00:08:10.730 --> 00:08:15.980
So how do we get around these distortions
that the Mercator projection introduces?

00:08:16.090 --> 00:08:20.680
And the way that MapKit lets you
do that is by using MKMapPoint.

00:08:22.840 --> 00:08:26.500
MKMapPoint is a coordinate in
projected space which lets you

00:08:26.500 --> 00:08:29.260
represent any point on the globe.

00:08:29.890 --> 00:08:32.770
is linearly proportional
to screen points,

00:08:32.770 --> 00:08:36.260
and you can use MKMapPoint for
coordinate to convert from latitudes

00:08:36.700 --> 00:08:38.370
and longitudes to map points.

00:08:39.460 --> 00:08:42.060
And now that we have these
projected coordinates,

00:08:42.060 --> 00:08:44.500
we can form rectangles out of them.

00:08:44.690 --> 00:08:47.710
And Map Kit calls these map rects.

00:08:49.360 --> 00:08:58.040
So a map rect consists of an origin
as well as a width and a height.

00:08:58.170 --> 00:09:01.290
And together this makes MKMapRect.

00:09:03.250 --> 00:09:05.800
And the advantage of using
MapRacks is that no matter

00:09:05.800 --> 00:09:09.400
where you put them in the world,
they don't change size.

00:09:11.000 --> 00:09:13.820
So here we have our
map rect over Cameroon,

00:09:13.820 --> 00:09:17.360
and when we move it over Algeria,
it maintains the same size.

00:09:17.410 --> 00:09:21.230
And when we move it over France,
it again maintains the same size.

00:09:21.350 --> 00:09:24.300
So it's not subject to the distortions.

00:09:24.420 --> 00:09:28.690
So if we rewrote our flight
tracking application using MapRex,

00:09:29.130 --> 00:09:32.300
Then we'd be able to follow our flight,
maintaining the same

00:09:32.300 --> 00:09:34.280
perspective throughout.

00:09:36.250 --> 00:09:38.700
So how do you change the position
of the map using MapRects?

00:09:38.700 --> 00:09:45.080
Well, there is a visible MapRect
property that you can set.

00:09:45.080 --> 00:09:48.350
And this will be able to change
the map position and scale.

00:09:49.590 --> 00:09:51.300
And once again,
what you set on the Visible

00:09:51.300 --> 00:09:54.500
Map Rec property may not be what the
map view uses because it needs to choose

00:09:54.590 --> 00:09:57.240
an optimal display for your device.

00:09:58.140 --> 00:09:59.840
Once again,
you can animate the transitions

00:09:59.840 --> 00:10:02.000
between different map recs.

00:10:02.190 --> 00:10:07.000
And you can also supply edge paddings to
center content in the middle of your map.

00:10:07.000 --> 00:10:09.680
And this is useful for preventing
things on the edge of the

00:10:09.820 --> 00:10:11.630
map from getting clicked.

00:10:13.630 --> 00:10:16.940
So now we know how to get a map view
into our application and how to get it

00:10:17.030 --> 00:10:19.000
to look at different areas of the world.

00:10:19.080 --> 00:10:21.460
But you should also be aware that
users can interact with their map

00:10:21.460 --> 00:10:23.640
view and explore for themselves.

00:10:23.730 --> 00:10:26.970
And your application is going
to want to react to those region

00:10:27.090 --> 00:10:29.050
changes by user interaction.

00:10:30.520 --> 00:10:33.660
And the way that you'll do this
is using your delegate object,

00:10:33.660 --> 00:10:36.100
mkmapview_delegate.

00:10:36.150 --> 00:10:38.900
So right before the user
starts panning around,

00:10:38.950 --> 00:10:42.810
you'll get a region will
change animated callback.

00:10:43.370 --> 00:10:47.600
And then the user will pan around,
and at the end, you'll get a region did

00:10:47.610 --> 00:10:49.890
change animated callback.

00:10:50.770 --> 00:10:53.900
And at this point,
you can use the region property

00:10:53.900 --> 00:10:57.550
or the visible map property
to detect what region of the

00:10:57.550 --> 00:10:59.120
world the user is looking at.

00:10:59.180 --> 00:11:01.380
And your application
can react accordingly,

00:11:01.430 --> 00:11:04.770
perhaps by loading content
specific to that region.

00:11:06.550 --> 00:11:09.240
So now we know how to get a
map view in our application,

00:11:09.240 --> 00:11:13.080
and we can let the user explore
different parts of the world.

00:11:13.140 --> 00:11:16.660
So let's try taking things
and putting them on the map.

00:11:16.770 --> 00:11:20.190
And to do that, we'll use annotations.

00:11:22.450 --> 00:11:24.700
So what is an annotation?

00:11:24.850 --> 00:11:28.600
An annotation describes a
specific location in the world.

00:11:28.690 --> 00:11:33.480
So here we have an annotation
for the Moscone West Center.

00:11:33.540 --> 00:11:36.690
And how does Map Kit represent
an annotation?

00:11:38.310 --> 00:11:43.440
In Map Kit, an annotation consists
of a model and a view.

00:11:43.560 --> 00:11:46.770
The model is described by
the MK annotation protocol,

00:11:46.880 --> 00:11:48.970
and your model objects will
need to conform to this

00:11:49.260 --> 00:11:51.940
by providing a coordinate.

00:11:52.100 --> 00:11:55.860
And this will tell the map view where
to put your annotation in the world.

00:11:57.580 --> 00:12:00.780
You can also provide a view for your
annotation to tell the map view what

00:12:00.780 --> 00:12:02.530
your annotation should look like.

00:12:02.620 --> 00:12:05.750
And this will be done
using MK annotation view.

00:12:06.530 --> 00:12:08.640
This is a UIView subclass.

00:12:08.670 --> 00:12:11.240
You can create your own
custom annotation views,

00:12:11.280 --> 00:12:14.060
or you can use some of the built-in
annotation views in Map Kit,

00:12:14.080 --> 00:12:16.630
such as the pin annotation view.

00:12:18.700 --> 00:12:23.300
So now we know what an annotation
is and how MapKit represents them.

00:12:23.500 --> 00:12:26.720
So let's look at the flow for how
annotations are added to the map.

00:12:29.610 --> 00:12:33.500
It begins with your application
creating a model object.

00:12:33.620 --> 00:12:35.500
Here we have a coordinate.

00:12:35.620 --> 00:12:38.010
And then this is added to the map.

00:12:39.610 --> 00:12:42.420
And at this point,
the MapView will request a

00:12:42.420 --> 00:12:45.230
view for this annotation.

00:12:45.270 --> 00:12:49.350
And this will be done using
the viewForAnnotation method.

00:12:50.480 --> 00:12:53.420
If you do not implement this
method or do not provide an

00:12:53.420 --> 00:12:56.860
annotation view for this annotation,
then a default pin view

00:12:56.860 --> 00:12:58.520
will be created for you.

00:12:58.960 --> 00:13:01.940
Otherwise,
you can create your annotation view

00:13:01.950 --> 00:13:04.290
here and return that to the map.

00:13:06.730 --> 00:13:10.980
Then the map view will take
your annotation and position

00:13:10.980 --> 00:13:13.090
it in the world space.

00:13:15.060 --> 00:13:18.320
And once it's added to the map,
your delegate object will get a

00:13:18.760 --> 00:13:21.330
"Did add annotation views" callback.

00:13:22.940 --> 00:13:25.120
And at this point,
you're free to animate your

00:13:25.120 --> 00:13:26.740
annotations into place.

00:13:27.140 --> 00:13:30.600
For example, the pin drop animation.

00:13:33.180 --> 00:13:37.600
So now we understand the flow of how
annotations are added to the map.

00:13:37.610 --> 00:13:41.500
And we've seen an example of how
to animate annotations into place.

00:13:41.530 --> 00:13:44.210
But let's look at another example
of how to animate annotations

00:13:44.210 --> 00:13:46.790
into place along with some code.

00:13:48.910 --> 00:13:54.110
So here we have an implementation of our
data at annotation views delegate method.

00:13:54.420 --> 00:13:57.070
And in it,
we're going to take all of our annotation

00:13:57.070 --> 00:14:01.050
views and take their target frame and
animate from a single point at the

00:14:01.050 --> 00:14:03.890
base of the frame into the full frame.

00:14:04.400 --> 00:14:07.540
And in the end we'll get
something that looks like this.

00:14:07.540 --> 00:14:10.950
So our green cone grows into the map.

00:14:12.560 --> 00:14:14.880
And now that we have our
annotations on the map,

00:14:14.910 --> 00:14:17.370
users are going to be curious about them,
and they're going to want to interact

00:14:17.630 --> 00:14:20.160
with them and find out more about them.

00:14:20.240 --> 00:14:22.800
And that's where
selection comes into play.

00:14:24.240 --> 00:14:28.660
So when a user taps on an annotation,
your delegate will get a "did

00:14:28.810 --> 00:14:31.360
select annotation" view callback.

00:14:31.950 --> 00:14:34.280
And when they tap away to
look at something else,

00:14:34.280 --> 00:14:37.750
you'll get a "Did Deselect
Annotation View" callback.

00:14:38.680 --> 00:14:42.000
And if your application wants to draw
attention to a particular annotation

00:14:42.150 --> 00:14:45.310
without the user interaction,
then you can use the select

00:14:45.310 --> 00:14:50.370
annotation and deselect annotation
methods on the map view.

00:14:52.260 --> 00:14:55.040
And now that the user has
selected an annotation,

00:14:55.040 --> 00:14:58.160
they're going to want to find
out more about that annotation.

00:14:58.250 --> 00:15:01.980
And one of the best ways to do
this is by showing a callout.

00:15:04.600 --> 00:15:07.670
So Map Kit provides support
for default callouts.

00:15:07.670 --> 00:15:10.910
And the way that you can access this
is by setting the can show callout

00:15:11.060 --> 00:15:15.340
property on your annotation view,
at which point your model object

00:15:15.440 --> 00:15:17.610
will need to provide a title.

00:15:17.640 --> 00:15:22.250
And once you do,
you'll be able to show a callout like so,

00:15:22.250 --> 00:15:23.690
Moscone West.

00:15:24.630 --> 00:15:28.000
You can also optionally
provide a subtitle.

00:15:28.150 --> 00:15:30.500
And that will pop in right underneath.

00:15:30.500 --> 00:15:32.490
Attending WWDC.

00:15:33.610 --> 00:15:36.830
And you can also add callout accessories.

00:15:36.950 --> 00:15:40.730
For example,
here we have a details disclosure button.

00:15:42.640 --> 00:15:44.520
So I've just described some
of the default selection

00:15:44.520 --> 00:15:47.100
behavior that you can opt into,
but you can also implement

00:15:47.100 --> 00:15:49.570
your own custom selection UI.

00:15:51.350 --> 00:15:54.300
And you can do this by
subclassing empty annotation

00:15:54.300 --> 00:15:58.470
view and overriding setSelected,
or by taking the delegate methods

00:15:58.660 --> 00:16:02.410
didSelectAnnotationView and
didDeselectAnnotationView and kicking

00:16:02.410 --> 00:16:04.350
off your animations from there.

00:16:05.190 --> 00:16:09.320
And here we have an example where
when I select this green cone,

00:16:09.320 --> 00:16:10.410
it grows.

00:16:10.540 --> 00:16:13.550
But selection is only one
of the ways that users can

00:16:13.700 --> 00:16:15.890
interact with your annotations.

00:16:16.140 --> 00:16:18.710
There's also support
for Jaguar annotations,

00:16:18.710 --> 00:16:20.710
which we added in iOS 4.

00:16:23.010 --> 00:16:25.380
And the way that you can support
draggable annotations is by

00:16:25.380 --> 00:16:29.080
setting the draggable property
on your annotation view,

00:16:29.080 --> 00:16:32.570
at which point your model object will
need to implement set coordinates so

00:16:32.570 --> 00:16:35.460
they can change locations on the map.

00:16:35.490 --> 00:16:38.530
And once you do so,
here we have a purple pin,

00:16:38.590 --> 00:16:42.400
and the user can pick it up
and move it across the map.

00:16:44.320 --> 00:16:48.900
And you can also provide your own
custom animations for dragging.

00:16:48.900 --> 00:16:51.830
And the way that you can do this
is by subclassing mkAnnotationView

00:16:52.540 --> 00:16:55.050
and overriding setDragState.

00:16:55.260 --> 00:16:58.100
And here we have an example where
we have our green cone again,

00:16:58.100 --> 00:17:02.360
and when I pick it up, it'll grow,
and when I drop it, it'll shrink back.

00:17:06.590 --> 00:17:10.630
So I've just shown you a number of ways
that you can personalize annotations

00:17:10.640 --> 00:17:13.340
in your application and animate them.

00:17:13.340 --> 00:17:16.680
But there are a couple of ways
that you can animate annotations

00:17:16.680 --> 00:17:19.290
that I want to call to attention.

00:17:21.600 --> 00:17:25.560
So Map Kit uses key value observation
on your annotations to detect

00:17:25.560 --> 00:17:28.280
changes to certain properties.

00:17:28.450 --> 00:17:32.570
So if your model object, for example,
has a key value observable

00:17:32.570 --> 00:17:36.600
coordinate and you change this
coordinate in an animation block,

00:17:36.600 --> 00:17:41.000
then the map view will be able
to slide your pin across the map.

00:17:42.290 --> 00:17:46.700
You can also animate changes
to title and subtitle.

00:17:46.720 --> 00:17:50.510
And you can also animate
changes to call out accessories.

00:17:51.590 --> 00:17:53.420
To learn more about
key value observation,

00:17:53.420 --> 00:17:55.600
you can look at the documentation online.

00:17:55.650 --> 00:17:58.690
And I should also mention that
if you use the synthesized

00:17:58.710 --> 00:18:02.890
syntax on your properties,
you can get KVO by default.

00:18:04.160 --> 00:18:08.230
So now we know how to get annotations
in our application and how to

00:18:08.230 --> 00:18:10.400
customize and personalize them.

00:18:10.400 --> 00:18:12.090
And we'd like to showcase
some of the things that you've

00:18:12.110 --> 00:18:15.080
seen so far with a demo.

00:18:15.080 --> 00:18:18.690
And for this demo, I'd like to call up
Matt Jarjoura to the stage.

00:18:22.740 --> 00:18:24.590
Okay,
I just want to let everyone know that

00:18:24.590 --> 00:18:27.680
you can go ahead and download the sample
that I'm going to walk you through today.

00:18:27.900 --> 00:18:30.630
It should be available right now.

00:18:30.650 --> 00:18:35.420
And I'm going to be walking you through
a sample of how to take annotations,

00:18:35.420 --> 00:18:38.580
or take a collection of photos that
have GPS data in them and place

00:18:38.580 --> 00:18:42.750
them on the map at the coordinates
that the photos were taken.

00:18:42.940 --> 00:18:47.170
So the first thing you want to do is

00:18:48.140 --> 00:18:50.300
Load all the photos that you have.

00:18:50.300 --> 00:18:53.020
And in this sample,
I just placed them inside

00:18:53.020 --> 00:18:55.100
of the application bundle.

00:18:55.310 --> 00:18:59.900
And I'm going to spin off a dispatch
queue here to load the photos.

00:18:59.920 --> 00:19:04.230
And I'm doing this on a secondary
thread so that it doesn't stop the

00:19:04.230 --> 00:19:06.940
map from being able to interact.

00:19:07.020 --> 00:19:09.220
And to load the photos,
it's pretty simple.

00:19:09.220 --> 00:19:15.520
You simply load the photo and then I can
ask for the latitude and longitude and

00:19:15.520 --> 00:19:19.550
store this in a CL location coordinate.

00:19:20.020 --> 00:19:23.230
and then place this into
a photo annotation object.

00:19:23.230 --> 00:19:26.760
Now just like Stephan showed you,
a photo annotation object

00:19:27.100 --> 00:19:29.810
is a simple NS object.

00:19:30.430 --> 00:19:34.050
Uh, that we just follow the
MCAnnotation protocol.

00:19:34.150 --> 00:19:36.630
And then here's a coordinate.

00:19:42.220 --> 00:19:45.810
So then,
now I build up my array of photos,

00:19:45.810 --> 00:19:50.920
and I simply, after I'm done,
I place those into the map view,

00:19:50.930 --> 00:19:52.740
add annotations.

00:19:52.820 --> 00:19:55.410
So when I run my application,

00:19:58.440 --> 00:20:02.140
I now have annotations
on here with the photo.

00:20:02.140 --> 00:20:08.230
And I did set the title of the callout
to the actual file name of the image.

00:20:08.300 --> 00:20:10.230
As you can see here.

00:20:11.810 --> 00:20:13.740
But it's not very interesting,
and I think we can do

00:20:13.740 --> 00:20:15.200
some more things here.

00:20:15.200 --> 00:20:18.830
So I want to go ahead and add the
ability to view the photo that

00:20:18.990 --> 00:20:20.820
this annotation is referencing.

00:20:20.960 --> 00:20:24.460
And I'm just going to need
to implement some delegates.

00:20:24.460 --> 00:20:28.660
The first of them is view for annotation.

00:20:28.720 --> 00:20:33.440
Now what I want to have in my application
is a way to bring the call out up

00:20:33.440 --> 00:20:37.810
and tap on the accessory button.

00:20:38.350 --> 00:20:41.040
And here to do that,
I'm going to use our standard

00:20:41.040 --> 00:20:42.260
MKPin annotation view.

00:20:42.260 --> 00:20:45.380
Now this is actually in Map Kit,
so you can use this.

00:20:45.500 --> 00:20:48.220
It's what we saw earlier.

00:20:48.250 --> 00:20:51.390
But you'll notice here I had to
explicitly say can show call out.

00:20:51.480 --> 00:20:54.770
If you want to use a view
for annotation and actually

00:20:54.770 --> 00:20:57.660
implement the annotation yourself,
you're going to have to

00:20:57.750 --> 00:21:00.840
specify can show call out.

00:21:00.840 --> 00:21:04.320
We do it by -- we do it for
you if you don't specify it,

00:21:04.320 --> 00:21:06.850
but you're going to need to in this case.

00:21:06.920 --> 00:21:08.860
And then simple enough,
we're going to use a standard

00:21:08.860 --> 00:21:12.690
UI button with type UI button
type detailed disclosure.

00:21:14.290 --> 00:21:16.630
And then we're going to set
our right callout accessory

00:21:16.630 --> 00:21:19.570
view to that disclosure button.

00:21:22.450 --> 00:21:27.790
And then, now, I want to,
whenever the user taps

00:21:27.900 --> 00:21:30.900
on that accessory button,
I want to bring up this

00:21:31.110 --> 00:21:33.160
Photos View Controller.

00:21:33.160 --> 00:21:34.500
This is in the sample application.

00:21:34.500 --> 00:21:36.160
I'm not going to go over that today.

00:21:36.160 --> 00:21:38.360
It's sort of outside the scope
of this example and for time,

00:21:38.360 --> 00:21:38.900
too.

00:21:38.900 --> 00:21:43.900
But it will bring up a new controller
to show you the actual photo.

00:21:43.900 --> 00:21:46.270
I'm going to go ahead and run this again.

00:21:49.870 --> 00:21:52.480
And now when I tap on
any of these annotations,

00:21:52.480 --> 00:21:54.840
I have my new accessory here.

00:21:54.840 --> 00:21:58.310
I can tap on it and actually see
the photo that it's referencing.

00:22:06.010 --> 00:22:08.400
So now let's give a little bit
more of a real world example.

00:22:08.460 --> 00:22:14.660
Close this out of the way.

00:22:17.600 --> 00:22:22.100
To do that, I'm going to change my photos
loading here to large photo sets.

00:22:22.100 --> 00:22:27.000
Run it again.

00:22:27.380 --> 00:22:30.490
And now we have hundreds of photos.

00:22:30.640 --> 00:22:33.940
So this is the simulator,
so you're not going to necessarily

00:22:33.940 --> 00:22:36.890
see the performance degradation here,
but if you did run it on a device,

00:22:36.890 --> 00:22:39.940
you would notice a lot of
frames dropping in this case.

00:22:39.960 --> 00:22:42.190
Each one of these is a UI view.

00:22:42.270 --> 00:22:45.710
But also, aside from performance, too,
this is no longer usable.

00:22:45.950 --> 00:22:48.360
It's almost impossible for your
user to try to get at the pen

00:22:48.360 --> 00:22:50.400
that they're talking about.

00:22:51.170 --> 00:22:55.700
So if you're familiar
with the Photos app today,

00:22:55.700 --> 00:22:58.160
what they do is clustering.

00:22:58.160 --> 00:23:02.520
They take all of the annotations and
they split them up into a grid and say,

00:23:02.520 --> 00:23:07.510
OK, what is a size that we think also
helps performance and also helps

00:23:07.510 --> 00:23:12.740
your user be able to locate the
annotation that they want to?

00:23:12.900 --> 00:23:17.010
So I'm going to show you how you can
do that now with your application.

00:23:18.300 --> 00:23:20.300
Sorry.

00:23:20.310 --> 00:23:24.180
So I've created this
update visible annotations.

00:23:24.750 --> 00:23:30.610
And this gets called any time
I move the region changed on the

00:23:31.000 --> 00:23:34.000
map or when I add annotations to it.

00:23:34.150 --> 00:23:37.340
So what I want to do is set up a
grid and figure out the perfect

00:23:37.380 --> 00:23:44.240
space that I can basically narrow
or cluster my annotations down to.

00:23:47.620 --> 00:23:48.830
Sorry.

00:23:48.950 --> 00:23:56.680
So here,
I'm going to use about 60 by 60 pixels,

00:23:56.680 --> 00:23:56.680
and then

00:23:57.700 --> 00:24:05.280
I'm going to go through each of the grid
squares and pull out my annotations and

00:24:05.730 --> 00:24:09.280
then coalesce them into one annotation.

00:24:10.140 --> 00:24:14.310
So in order to do this,
in a real-world case,

00:24:14.310 --> 00:24:17.160
you probably want to set up a
quadtri so that you can take the

00:24:17.250 --> 00:24:22.350
annotations and put them into that
and then pull them out from there.

00:24:22.500 --> 00:24:24.290
But I think in a simple
example like today,

00:24:24.290 --> 00:24:26.190
and if your application
is relatively simple,

00:24:26.310 --> 00:24:28.550
I'm going to show you a
little trick that you can use.

00:24:28.640 --> 00:24:32.960
And that's to place all of
the on-screen annotations

00:24:32.960 --> 00:24:35.840
into this off-screen map view.

00:24:36.020 --> 00:24:40.780
So here we have add annotations.

00:24:42.850 --> 00:24:48.180
I'm going to use this
all annotations map view,

00:24:48.530 --> 00:24:54.380
which when I create it and viewDidLoad,

00:24:57.170 --> 00:24:59.860
You'll notice here that
it's of a rec size zero,

00:24:59.950 --> 00:25:02.670
so it shouldn't, and we're not going to
actually put it on screen,

00:25:02.830 --> 00:25:07.650
so it shouldn't have any impact
with your view hierarchy.

00:25:08.690 --> 00:25:10.320
So that way now,
we're going to add all of our

00:25:10.320 --> 00:25:14.160
annotations to this off-screen one,
and we can ask a new

00:25:14.160 --> 00:25:18.160
API that was added in 4.2,
annotations in MapRect.

00:25:18.270 --> 00:25:22.720
So now I can get all the
annotations in my grid MapRect

00:25:22.740 --> 00:25:26.800
in this off-screen map view,
and then I'm going to call

00:25:26.800 --> 00:25:30.990
this method annotationInGrid,
which I'm going to show you right here.

00:25:36.410 --> 00:25:41.960
And what I'm going to do is handing
all the annotations that I have on

00:25:41.960 --> 00:25:45.100
screen already on my on-screen map view,
and if I do have an

00:25:45.100 --> 00:25:48.540
annotation in that grid,
I'm going to return that.

00:25:48.640 --> 00:25:52.000
If I don't, then I'm going to go to this
new off-screen map view,

00:25:52.010 --> 00:25:56.640
and I'm going to find the
center-most annotation that I have.

00:25:56.750 --> 00:26:00.940
And then I'm going to return that one.

00:26:01.030 --> 00:26:03.170
And then once I have that,

00:26:08.760 --> 00:26:12.000
I'm going to go ahead and
add that to my map view,

00:26:12.090 --> 00:26:15.120
my on-screen map view here, you can see.

00:26:15.190 --> 00:26:17.490
And then if my on-screen map
view had any other annotation

00:26:17.500 --> 00:26:21.880
that was in that grid space,
I'm going to go ahead and remove it.

00:26:21.970 --> 00:26:25.140
So now let me go ahead and
show you the application.

00:26:31.600 --> 00:26:34.800
And in my Photos View Controller,
I added the ability to

00:26:34.830 --> 00:26:37.230
show multiple photos.

00:26:40.140 --> 00:26:43.940
So then if I zoom out,
you'll see they go away.

00:26:43.940 --> 00:26:50.720
Or if I zoom in, it updates and adds the
new ones on the screen.

00:26:52.010 --> 00:26:54.940
Okay, so if you've used the Photos app,
you'll also notice that

00:26:54.980 --> 00:26:58.290
they do a nice animation,
and that's to give it a

00:26:58.290 --> 00:26:59.940
little bit more polish,
I think,

00:27:00.070 --> 00:27:04.060
and to not be so visually jarring
for your users so they can understand

00:27:04.140 --> 00:27:09.140
what they're looking at when they
zoom at different levels here.

00:27:09.270 --> 00:27:12.120
So I'm going to add
some simple animation.

00:27:12.280 --> 00:27:16.530
First one is I'm going to use
another map view delegate.

00:27:19.890 --> 00:27:24.440
Here, so it's going to say if this,
if this annotation at the current

00:27:24.440 --> 00:27:28.500
level or the previous level had,
was in a cluster,

00:27:28.730 --> 00:27:32.260
Then I'm going to take its clustered
annotation location and animate it

00:27:32.340 --> 00:27:38.900
to its new location with a simple
UI view animate with duration.

00:27:41.690 --> 00:27:46.020
And then back up here where
I'm removing the annotation,

00:27:46.020 --> 00:27:47.670
the same thing.

00:27:51.190 --> 00:27:55.180
If I go up a level,
then I'm going to do the same thing.

00:27:55.220 --> 00:27:57.950
If it's going to move into
a clustered annotation,

00:27:58.010 --> 00:28:01.700
I'm going to remove it from its old
location and animate it to its new

00:28:01.740 --> 00:28:05.260
location with a UIView annotation.

00:28:05.260 --> 00:28:07.260
This mouse is not working.

00:28:07.260 --> 00:28:19.130
So now when I zoom out, they animate out.

00:28:27.000 --> 00:28:38.100
[Transcript missing]

00:28:41.580 --> 00:28:46.580
So we've just seen that we can show
a lot of information on the map.

00:28:46.580 --> 00:28:51.500
And sometimes it helps to provide
context to what the user is looking at.

00:28:51.600 --> 00:28:57.410
And one of the nice ways you can do this
is by showing user location on the map.

00:28:57.480 --> 00:29:00.460
So how do you get user
location on your map?

00:29:00.560 --> 00:29:02.290
It's very simple.

00:29:03.460 --> 00:29:07.520
There is a shows user location
property on the map view.

00:29:07.560 --> 00:29:11.080
And once you set this,
this will require location

00:29:11.080 --> 00:29:12.940
services authorization.

00:29:13.070 --> 00:29:17.290
So a location services alert will pop up
to ask the user whether this application

00:29:17.370 --> 00:29:19.900
is allowed to use their current location.

00:29:20.440 --> 00:29:23.690
And if they accept,
then we'll be able to show

00:29:23.700 --> 00:29:27.580
the user location on the map,
and your delegate will get a "did

00:29:27.580 --> 00:29:29.990
update user location" callback.

00:29:31.500 --> 00:29:35.480
And if for some reason they were to deny
access to their current location or we

00:29:35.480 --> 00:29:40.080
were unable to get a quick location fix,
then you'll get a "did fail to

00:29:40.080 --> 00:29:43.020
locate user with error" callback.

00:29:43.170 --> 00:29:46.920
So it's really easy to add
user location to your map.

00:29:47.260 --> 00:29:50.340
But there are a couple other things
you should know about user location.

00:29:51.690 --> 00:29:55.250
For instance,
user location is an annotation,

00:29:55.330 --> 00:29:58.480
and you can access it using
the user location property.

00:29:58.580 --> 00:30:02.220
And you can actually provide your
own custom annotation views for it.

00:30:02.810 --> 00:30:06.200
And if the user pans away
to look at something else,

00:30:06.200 --> 00:30:10.350
you can use the read-only user location
visible property to detect whether

00:30:10.350 --> 00:30:12.740
the user's location is on screen.

00:30:14.170 --> 00:30:16.900
Now, in the past,
we've seen that it sometimes takes a

00:30:16.900 --> 00:30:20.340
lot of boilerplate work to keep the
user's location on screen and keep

00:30:20.410 --> 00:30:22.460
information relevant to where they are.

00:30:22.560 --> 00:30:26.850
So in iOS 5,
we've added support for tracking modes.

00:30:26.930 --> 00:30:29.890
So how do you get tracking modes
working in your application?

00:30:31.010 --> 00:30:33.050
Once again, it's very easy.

00:30:33.150 --> 00:30:36.590
There is a user tracking mode
property on the map view.

00:30:36.700 --> 00:30:40.440
This requires the same location services
authorization that user location does.

00:30:40.560 --> 00:30:43.590
So an alert will pop up to ask
the user whether this application

00:30:43.700 --> 00:30:45.540
can use their current location.

00:30:45.640 --> 00:30:48.900
And we've also added the tracking
bar button item that you've

00:30:48.910 --> 00:30:50.800
seen in the Maps application.

00:30:51.430 --> 00:30:55.770
And this is useful for showing the
user which tracking mode they're in,

00:30:55.790 --> 00:30:58.910
as well as letting them transition
to different tracking modes.

00:31:00.160 --> 00:31:03.440
So if the user permits use
of their current location,

00:31:04.160 --> 00:31:06.690
then you'll be able to
enter tracking mode.

00:31:07.880 --> 00:31:10.200
and follow their location.

00:31:10.270 --> 00:31:14.900
So here we're smoothly transitioning,
following along 280 going north.

00:31:17.000 --> 00:31:21.150
And we also support tracking, location,
and heading.

00:31:21.320 --> 00:31:24.700
And this is a nice way to provide
perspective to what the user is looking

00:31:24.730 --> 00:31:27.330
at and to show user-centric data.

00:31:28.940 --> 00:31:30.970
But up until now,
we've been talking about how to

00:31:30.970 --> 00:31:33.760
describe single points on the map.

00:31:33.770 --> 00:31:37.520
But not everything can be
described by single points.

00:31:37.710 --> 00:31:41.050
And that's why Map Kit provides
support for overlays.

00:31:42.890 --> 00:31:44.070
So what is an overlay?

00:31:44.300 --> 00:31:47.850
It's spatial data that you can
put on top of the base map.

00:31:48.750 --> 00:31:51.800
And how does Map Kit represent overlays?

00:31:51.950 --> 00:31:55.890
Similar to annotations,
it consists of a model and a view.

00:31:56.810 --> 00:32:00.260
The model is described by
the MK overlay protocol,

00:32:00.370 --> 00:32:04.050
and your model objects will need to
conform to this by providing a bounding

00:32:04.050 --> 00:32:06.680
map rect and a center coordinate.

00:32:07.660 --> 00:32:12.600
And this center coordinate is useful
if you want to annotate your overlay.

00:32:12.640 --> 00:32:14.570
And the reason that this center
coordinate is not derived

00:32:14.660 --> 00:32:18.220
from the bounding map rect
is best illustrated by example.

00:32:19.520 --> 00:32:23.400
So here we have a triangle
overlaid on top of California,

00:32:23.400 --> 00:32:27.240
and we have a pin representing the
center of the bounding map rect,

00:32:27.310 --> 00:32:30.400
and it's along one of the
edges of the triangle.

00:32:30.550 --> 00:32:34.970
Whereas the true center of our
triangle is actually offset from

00:32:35.090 --> 00:32:37.760
that center of the bounding map rect.

00:32:37.960 --> 00:32:41.390
And that's why we let you specify
the center coordinate independent

00:32:41.390 --> 00:32:42.880
of the bounding map rect.

00:32:44.600 --> 00:32:47.740
You'll also need to provide
a view for your overlay.

00:32:47.800 --> 00:32:50.260
Unlike annotations,
you are required to provide

00:32:50.460 --> 00:32:52.530
a view for your overlay.

00:32:52.530 --> 00:32:55.310
And you'll do this using mkOverlayView.

00:32:55.770 --> 00:32:59.320
And the important method that you'll
need to implement is draw map rect,

00:32:59.480 --> 00:33:01.660
zoom scale, and context.

00:33:01.790 --> 00:33:04.500
And this will tell the map view
how to draw your overlay in

00:33:04.500 --> 00:33:06.570
certain regions of the world.

00:33:08.340 --> 00:33:14.300
Now, Map Kit also provides support for
a number of built-in overlays.

00:33:14.320 --> 00:33:17.060
There is MK Circle.

00:33:17.740 --> 00:33:22.370
MKPolyline and MKPolygon.

00:33:22.370 --> 00:33:26.480
And each of these overlays has
a corresponding overlay view.

00:33:26.650 --> 00:33:29.530
So let's look at some code for
how to add these to the map.

00:33:32.060 --> 00:33:34.820
So here we have our viewDidLoad method.

00:33:34.820 --> 00:33:38.680
And in it, we're going to take a center
coordinate and then create an

00:33:38.680 --> 00:33:43.040
MK circle with a radius of 200
meters around that center coordinate.

00:33:43.060 --> 00:33:45.180
And then we'll add this to the map.

00:33:46.270 --> 00:33:47.840
And at that point,
the map view is going to

00:33:47.970 --> 00:33:50.310
request a view for this overlay.

00:33:50.370 --> 00:33:53.870
And this will be done using the
viewForOverlay delegate method.

00:33:54.890 --> 00:33:57.800
And as I mentioned before,
you're required to provide

00:33:57.800 --> 00:33:59.420
a view for your overlay.

00:33:59.570 --> 00:34:02.210
So we're going to create
an MK Circle view.

00:34:02.300 --> 00:34:04.480
We'll set a stroke and a fill color.

00:34:04.550 --> 00:34:07.400
And then we'll return this to the map.

00:34:07.460 --> 00:34:10.280
And in the end,
we'll get something that looks like this.

00:34:11.170 --> 00:34:14.480
So it's a circle around the
center coordinate we specified

00:34:14.940 --> 00:34:17.140
with the radius we specified.

00:34:17.520 --> 00:34:20.410
There's a detailed talk from
last year which covers overlays

00:34:20.440 --> 00:34:22.630
in more comprehensive detail.

00:34:22.650 --> 00:34:24.100
If you'd like to learn
more about overlays,

00:34:24.100 --> 00:34:27.040
I'd encourage you to download
those videos from iTunes U and

00:34:27.040 --> 00:34:29.860
the Apple Developer Connection.

00:34:29.980 --> 00:34:34.100
But now I'd like to talk about
the geocoding changes in iOS 5.

00:34:35.450 --> 00:34:38.780
So first of all, what is geocoding?

00:34:38.790 --> 00:34:41.500
Well,
there's actually two types of geocoding.

00:34:41.510 --> 00:34:45.140
There is forward geocoding
and reverse geocoding.

00:34:45.260 --> 00:34:47.490
So what's forward geocoding?

00:34:48.960 --> 00:34:55.360
Forward Geocoding takes an address
and then turns that into a coordinate.

00:34:56.630 --> 00:34:59.800
And an example of that would be
when you go to address book and

00:34:59.800 --> 00:35:03.790
you tap on an address and it
shows you that address on the map.

00:35:04.570 --> 00:35:07.400
That's an example of a forward geocode.

00:35:07.550 --> 00:35:09.810
So what's reverse geocoding?

00:35:10.080 --> 00:35:11.340
Well, it's just the opposite.

00:35:11.360 --> 00:35:14.960
You take a coordinate and you
turn that into an address.

00:35:15.020 --> 00:35:19.020
And an example of that would be when
you drop a pin and it shows you the

00:35:19.020 --> 00:35:21.710
address information for that location.

00:35:23.620 --> 00:35:27.130
Map Kit has provided support for
reverse geocoding through the

00:35:27.220 --> 00:35:30.510
MK Reverse Geocoder class since iOS 3.

00:35:31.480 --> 00:35:35.400
and developers have been asking for
forward geocoding for some time.

00:35:35.400 --> 00:35:40.400
We've listened to these requests
and we've decided to act on it.

00:35:40.510 --> 00:35:43.220
And we're pleased to
tell you that in iOS 5,

00:35:43.220 --> 00:35:47.390
MK Reverse Geocoder is deprecated.

00:35:52.350 --> 00:35:56.620
But that's OK, because in iOS 5,
there's a new geocoding API.

00:35:56.620 --> 00:35:58.200
And it's in core location.

00:35:58.210 --> 00:36:01.740
And it's called CLGeocoder.

00:36:01.740 --> 00:36:05.800
And it provides support for both
forward and reverse geocoding.

00:36:10.220 --> 00:36:13.870
So how do we use this new geocoding API?

00:36:14.120 --> 00:36:16.580
Well, for forward geocoding,
there's two methods.

00:36:16.660 --> 00:36:21.190
There is geocodeAddressString
and geocodeAddressDictionary.

00:36:21.290 --> 00:36:25.330
And for reverse geocoding,
there is reverseGeocodeLocation.

00:36:25.680 --> 00:36:28.890
Each one of these methods
takes a completion handler.

00:36:29.010 --> 00:36:31.550
What is a completion handler?

00:36:32.700 --> 00:36:36.220
Well, a completion handler is simply a
block to tell the geocoder what

00:36:36.350 --> 00:36:38.990
to do once the geocode completes.

00:36:39.830 --> 00:36:43.360
So on success,
you'll get an array of CL placemarks,

00:36:43.380 --> 00:36:46.210
and these placemarks will be sorted
with the most confident results

00:36:46.340 --> 00:36:48.940
at the beginning of the array.

00:36:49.010 --> 00:36:53.580
And if the geocode should fail,
then you'll get an NSError back.

00:36:54.980 --> 00:36:58.350
So I just mentioned that you'll
get an array of CL placemarks back.

00:36:58.350 --> 00:37:00.400
So what do those look like?

00:37:01.910 --> 00:37:05.570
A CL placemark has a location as well
as a number of address properties

00:37:05.720 --> 00:37:07.850
that describe that location.

00:37:09.400 --> 00:37:13.190
Now, some of you have been using the
MapKit API in the past will remember that

00:37:13.460 --> 00:37:18.300
there was an MK PlaySmart class which
represented reverse geocode responses.

00:37:18.440 --> 00:37:20.300
So what happens to that?

00:37:21.570 --> 00:37:26.300
Well, in iOS 5, MKPlacemark is now a
subclass of CLPlacemark.

00:37:26.340 --> 00:37:29.200
That means it supports all
of the existing properties,

00:37:29.260 --> 00:37:32.310
as well as the new ones on CLPlacemark.

00:37:33.520 --> 00:37:36.520
You can also create
MK placemarks from CL placemarks,

00:37:36.530 --> 00:37:39.790
and you can do that using
the initWithPlasemark method.

00:37:40.340 --> 00:37:44.610
MK placemarks are annotations,
so you can add them to the map.

00:37:44.610 --> 00:37:48.550
And you can also still use the dictionary
representation with address book.

00:37:49.960 --> 00:37:52.670
So now we know more about
the new geocoding API,

00:37:52.900 --> 00:37:55.330
so let's look at some
code for how to use it,

00:37:55.860 --> 00:37:58.340
starting with reverse geocoding.

00:38:00.130 --> 00:38:01.280
So it's very simple.

00:38:01.310 --> 00:38:05.500
We create a location object
using a latitude and longitude.

00:38:05.890 --> 00:38:09.290
We then allocated Geocoder,
and then we reversed Geocode

00:38:09.320 --> 00:38:11.300
the location we created.

00:38:11.620 --> 00:38:16.640
And then we provide a completion handler,
which will inspect the

00:38:16.760 --> 00:38:18.540
placemarks that we get back.

00:38:18.550 --> 00:38:22.600
And it will take the most confident
placemark at the beginning of the array.

00:38:22.980 --> 00:38:28.490
And then it'll create an MK placemark
from that and then add that to the map.

00:38:28.640 --> 00:38:32.490
So it's very simple to use
the new reverse geocoding API.

00:38:33.990 --> 00:38:35.660
Now what about forward geocoding?

00:38:35.780 --> 00:38:37.900
CL Geocoder also supports that.

00:38:38.040 --> 00:38:40.010
And as I mentioned before,
it supports geocoding address

00:38:40.040 --> 00:38:44.390
strings and address dictionaries.

00:38:44.520 --> 00:38:48.800
So let's start with an example of how
to forward geocode address strings.

00:38:50.410 --> 00:38:55.100
So first we create our address string,
one infinite loop, Cupertino, CA.

00:38:55.170 --> 00:38:56.900
And then we allocate our geocoder.

00:38:56.960 --> 00:38:59.440
And then once again,
we geocode the address string

00:38:59.440 --> 00:39:02.170
and provide a completion handler,
which will take the most

00:39:02.330 --> 00:39:05.280
confident placemark,
create an MK placemark from it,

00:39:05.340 --> 00:39:07.310
and then add that to the map.

00:39:08.760 --> 00:39:12.360
So once again, it's very easy to use.

00:39:12.400 --> 00:39:14.400
Now what about address dictionaries?

00:39:14.450 --> 00:39:16.200
Well, it's very similar.

00:39:16.250 --> 00:39:19.690
We allocate an address dictionary,
which is a more structured

00:39:19.780 --> 00:39:21.550
definition of an address.

00:39:21.640 --> 00:39:24.420
So here we have one infinite
loop for the street,

00:39:24.530 --> 00:39:26.770
Cupertino for the city,
and the abbreviation for

00:39:26.860 --> 00:39:29.200
California for the state.

00:39:29.620 --> 00:39:33.370
And then we allocate our geocoder,
we geocode the address dictionary,

00:39:33.370 --> 00:39:36.810
and once again we provide a completion
handler which takes the most confident

00:39:37.000 --> 00:39:40.410
result and creates an mkplace
mark and adds that to the map.

00:39:41.510 --> 00:39:43.240
So again, very easy.

00:39:43.280 --> 00:39:48.120
And one of the reasons you may want
to use an address dictionary for

00:39:48.120 --> 00:39:52.050
your forward geocodes is that this
more structured definition of an

00:39:52.050 --> 00:39:55.280
address allows the server to make
more assumptions about the data and

00:39:55.280 --> 00:39:57.560
may return more accurate results.

00:39:57.630 --> 00:40:01.200
So now that you know how to
use the new CL Geocoder API,

00:40:01.220 --> 00:40:06.120
let's revisit the application we
created earlier and add geocoding to it.

00:40:06.200 --> 00:40:09.550
And I'd like to call Matt Jarjoura
back up to the stage for this demo.

00:40:10.500 --> 00:40:15.710
Okay, so we're going to go this time
back to our photo annotation.

00:40:15.710 --> 00:40:19.390
And because we have our
coordinate coming in already,

00:40:19.540 --> 00:40:23.020
stored in this annotation,
I'm going to use that coordinate to

00:40:23.020 --> 00:40:26.910
reverse geocode its actual location.

00:40:29.590 --> 00:40:31.500
To do that,
I'm going to pass the coordinate

00:40:31.500 --> 00:40:35.580
into a CL location object,
and then I'm going to

00:40:35.580 --> 00:40:39.640
create a new CL geocoder,
and then pass that location

00:40:39.640 --> 00:40:42.740
into reverse geocode location.

00:40:42.830 --> 00:40:47.280
Then once I have the location,
I'm going to get a string,

00:40:47.360 --> 00:40:50.100
just a simple helper method here.

00:40:51.600 --> 00:40:55.660
And all this helper method does
is take the city and state and

00:40:55.770 --> 00:40:59.470
places them together with a comma.

00:41:00.760 --> 00:41:09.590
And then set the subtitle of my current
callout to that updated location.

00:41:10.500 --> 00:41:13.160
There's only one other
piece to make this work.

00:41:13.180 --> 00:41:16.350
I need to implement another delegate.

00:41:19.880 --> 00:41:24.520
did select annotation view so that
when I tap on the annotation callout,

00:41:24.520 --> 00:41:29.000
it will begin the reverse
geocoding process.

00:41:29.080 --> 00:41:37.390
So now when I run the application,
when I tap on a callout,

00:41:43.000 --> 00:41:46.250
You should see how it sets the
subtitle here of the callout.

00:41:46.250 --> 00:41:50.450
I also added this into the
photo viewer as well so that

00:41:50.560 --> 00:41:53.300
it reverse geocodes the photo.

00:42:05.860 --> 00:42:06.800
There you go.

00:42:06.800 --> 00:42:07.800
Thank you.

00:42:07.800 --> 00:42:14.440
Thank you, Matt.

00:42:14.590 --> 00:42:16.440
So you see,
it's really easy to get started

00:42:16.440 --> 00:42:19.170
using the new geocoding API.

00:42:20.280 --> 00:42:23.120
And now I've talked about all the
topics I wanted to talk about today.

00:42:23.170 --> 00:42:25.340
So let's summarize what we've covered.

00:42:25.400 --> 00:42:30.180
Map Kit lets you show rich annotated maps
with powerful contextual information.

00:42:30.640 --> 00:42:34.710
You can use the new tracking modes in iOS
5 to give perspective to what the user

00:42:34.780 --> 00:42:38.250
is looking at and show user-centric data.

00:42:38.280 --> 00:42:42.180
You can use overlays to put your
own spatial data on top of the map.

00:42:42.720 --> 00:42:45.490
and you should adopt the new
geocoding APIs in iOS 5 to

00:42:45.500 --> 00:42:47.870
get a better user experience.

00:42:48.800 --> 00:42:51.700
There are a couple other sessions
you may be interested in.

00:42:51.760 --> 00:42:53.790
There is the What's New in
Core Location session,

00:42:53.790 --> 00:42:54.850
which took place yesterday.

00:42:55.060 --> 00:42:57.850
You'll be able to download
videos of that later on.

00:42:58.080 --> 00:43:01.320
There is the Testing Your Locationware
Application Without Leaving Your Chair

00:43:01.320 --> 00:43:03.880
session,
which takes place on Friday.

00:43:04.210 --> 00:43:07.300
If you have any other questions,
please contact Bill Dudney,

00:43:07.300 --> 00:43:09.920
our Application Frameworks Evangelist.

00:43:10.130 --> 00:43:14.840
You can also consult the Map Kit and
Core Location Framework documentation.

00:43:14.910 --> 00:43:17.500
And if you have any other questions,
you can ask them on the

00:43:17.500 --> 00:43:19.840
Apple Developer Forums.

00:43:19.970 --> 00:43:21.240
That concludes the presentation.

00:43:21.390 --> 00:43:23.180
Thank you for your time.
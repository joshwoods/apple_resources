WEBVTT

00:00:13.090 --> 00:00:14.000
Good afternoon, everyone.

00:00:14.000 --> 00:00:16.850
I'm Doug Davidson,
and I'm here to talk to

00:00:16.850 --> 00:00:18.980
you about text processing.

00:00:18.980 --> 00:00:22.740
We've worked hard to bring you an
extensive toolkit for analyzing text

00:00:23.170 --> 00:00:29.090
because we know that all our devices
now have lots of text on them,

00:00:29.090 --> 00:00:36.090
and we think that your applications
can give a better user experience if

00:00:36.090 --> 00:00:36.160
they understand a little something
about the content of that text.

00:00:36.960 --> 00:00:40.060
So what we're going to do is first
go through how text is represented

00:00:40.120 --> 00:00:43.740
and its structure and some of the
basic APIs for iterating through it.

00:00:43.830 --> 00:00:46.370
And then we're going to talk
about the pieces of this toolkit,

00:00:46.460 --> 00:00:49.480
things like regular expressions,
data detectors, linguistic APIs,

00:00:49.520 --> 00:00:50.400
text checking.

00:00:50.600 --> 00:00:55.970
And then we'll have some demos and
sample code to put it all together.

00:00:57.810 --> 00:01:02.340
Now, I remember when I started out in
this business a long time ago,

00:01:02.340 --> 00:01:05.500
string handling looked a
little something like this.

00:01:05.610 --> 00:01:08.530
Everything was ASCII C strings.

00:01:08.620 --> 00:01:10.640
Well, those days are long gone.

00:01:10.640 --> 00:01:12.700
Our text is Unicode now.

00:01:12.700 --> 00:01:16.500
And no matter what system
and platform you're using,

00:01:16.500 --> 00:01:20.380
chances are that there is an
API that deals with strings

00:01:20.380 --> 00:01:22.650
as sequences of UTF-16.

00:01:22.650 --> 00:01:25.300
And NSString is no exception.

00:01:25.300 --> 00:01:29.680
Conceptually, an NSString is a
sequence of UTF-16 units,

00:01:29.700 --> 00:01:31.700
what we call unicars.

00:01:31.700 --> 00:01:35.720
So there's a great temptation
to think that these are really

00:01:35.720 --> 00:01:39.420
just like the old C strings,
except that the character

00:01:39.450 --> 00:01:40.700
is a little wider.

00:01:40.700 --> 00:01:42.640
And that the right thing to do is to use
the same string to do the same thing.

00:01:42.710 --> 00:01:45.690
And that's why we used to go and
iterate through character by character.

00:01:45.690 --> 00:01:49.700
But really,
that is not the way that Unicode works.

00:01:49.700 --> 00:01:52.700
Let me show you.

00:01:52.700 --> 00:01:56.510
Let's take a look at some
text to start off with.

00:01:59.490 --> 00:02:02.390
So here's a simple piece of text.

00:02:02.420 --> 00:02:05.960
And as we look at it,
we notice that it has some structure.

00:02:05.960 --> 00:02:10.140
So this text is composed of
a sequence of paragraphs.

00:02:10.210 --> 00:02:14.680
And each paragraph is
composed of sentences.

00:02:14.680 --> 00:02:17.030
And then the sentences in
turn are composed of words.

00:02:17.080 --> 00:02:21.210
And then the words in turn are
composed of what I'm going to

00:02:21.210 --> 00:02:22.760
call user visible characters.

00:02:23.700 --> 00:02:27.000
And none of these things,
not even the user visible characters,

00:02:27.000 --> 00:02:30.020
can be directly identified
with the individual unicars.

00:02:30.100 --> 00:02:35.300
They're all ranges of
unicars in the text.

00:02:36.360 --> 00:02:39.540
Let me go back to the slides
and say why that's so.

00:02:39.830 --> 00:02:42.780
So these user visible
characters are actually,

00:02:42.780 --> 00:02:45.300
in general, character clusters.

00:02:45.440 --> 00:02:48.300
The official Unicode term for
this is a graphene cluster.

00:02:48.300 --> 00:02:52.680
Sometimes in API we refer to this
as composed character sequences.

00:02:52.860 --> 00:02:56.010
This is a very characteristic
feature of Unicode,

00:02:56.010 --> 00:02:59.740
and that is that multiple Unicars
can go to making up what is a

00:02:59.740 --> 00:03:01.970
single user visible character.

00:03:02.130 --> 00:03:05.770
So I don't know if you noticed in
that example text that I had there,

00:03:05.770 --> 00:03:09.760
but in the word San Jose,
there's an accented E.

00:03:09.810 --> 00:03:13.660
And that is actually not one Unicare,
it's two,

00:03:13.670 --> 00:03:16.560
an E with a combining accent mark.

00:03:16.690 --> 00:03:20.680
And that is just the very
simplest example of sequences of

00:03:20.780 --> 00:03:25.000
characters that combine to form
a single user visible character.

00:03:25.140 --> 00:03:26.460
There are much more complicated examples.

00:03:26.460 --> 00:03:28.870
I show one in Korean.

00:03:28.910 --> 00:03:30.050
However, it happens all the time.

00:03:30.210 --> 00:03:32.030
In Vietnamese.

00:03:32.170 --> 00:03:35.820
There are very complicated
sequences where you have multiple

00:03:35.820 --> 00:03:40.040
Unicars that combine to form
a single user visible character.

00:03:40.110 --> 00:03:45.040
And in addition to this,
we have surrogate pairs.

00:03:45.450 --> 00:03:50.800
Anything in Unicode that goes
beyond the basic multilingual plane,

00:03:50.960 --> 00:03:55.170
that is beyond the first 64K characters,
is going to be represented

00:03:55.270 --> 00:03:58.030
not by a single UTF-16 unit,
but by two.

00:03:58.040 --> 00:04:00.160
It's called the surrogate pair.

00:04:00.640 --> 00:04:03.740
And... This is not just
some abstract thing.

00:04:03.870 --> 00:04:05.760
This is a very practical issue.

00:04:05.950 --> 00:04:10.470
And the characters beyond the
first 64K include things like

00:04:10.530 --> 00:04:13.750
cuneiform and hieroglyphics,
but it's not limited to that.

00:04:13.860 --> 00:04:17.590
If you're dealing with Chinese text,
you'll often see characters

00:04:17.590 --> 00:04:19.760
that require surrogate pairs.

00:04:19.760 --> 00:04:22.700
We now have emoji
available for everybody.

00:04:22.760 --> 00:04:26.910
And most of the emoji characters are also
beyond the basic multilingual plane and

00:04:26.950 --> 00:04:28.760
are going to require surrogate pairs.

00:04:29.240 --> 00:04:31.480
So in all these cases,
we have more than one character.

00:04:31.480 --> 00:04:36.480
We have more than one Unicare that goes
to make a single user visible character.

00:04:36.480 --> 00:04:39.450
And you can't split these up
when you're processing them.

00:04:39.780 --> 00:04:41.480
They have to stay together.

00:04:41.480 --> 00:04:44.450
You don't want to divide
the E from its accent.

00:04:44.480 --> 00:04:48.410
You definitely can't divide the
two halves with surrogate pairs.

00:04:48.480 --> 00:04:52.720
So when we go through these,
we can't deal with the

00:04:52.990 --> 00:04:54.360
individual Unicars.

00:04:54.550 --> 00:04:58.460
We have to deal in general
with ranges of Unicars.

00:04:58.480 --> 00:05:01.200
So if we can't use that simple for loop,
how do we do that?

00:05:01.200 --> 00:05:03.200
How can we iterate through the text?

00:05:03.200 --> 00:05:10.290
Well, we have a device that seems as if
it was made for text processing,

00:05:10.290 --> 00:05:11.190
and that is blocks.

00:05:11.200 --> 00:05:17.190
So what we provide is a block
iteration API on NSString.

00:05:17.200 --> 00:05:21.200
Enumerate substrings in range.

00:05:21.200 --> 00:05:25.200
And we specify how it is
that we want to enumerate.

00:05:25.200 --> 00:05:27.370
In this case,
we're choosing to enumerate by

00:05:27.500 --> 00:05:29.510
composed character sequences,
that is,

00:05:29.520 --> 00:05:30.920
by these user visible characters.

00:05:30.920 --> 00:05:32.550
characters.

00:05:33.080 --> 00:05:36.590
And what this API does
is to call your block,

00:05:36.590 --> 00:05:41.910
the block that you provide here,
once for each of these in the range

00:05:41.910 --> 00:05:44.520
of the string that you asked for.

00:05:44.620 --> 00:05:47.140
And then you can do
whatever it is you want.

00:05:47.230 --> 00:05:49.940
The block -- your block gets
passed in the range that

00:05:49.940 --> 00:05:52.760
it's supposed to deal with,
and you can do whatever you want with it.

00:05:52.760 --> 00:05:57.550
This example code was taken
directly from the app that I showed,

00:05:57.720 --> 00:06:01.700
and all it's doing is to add a
color to that piece of the text.

00:06:01.880 --> 00:06:06.080
and I chose to do alternating
colors to make it evident.

00:06:07.140 --> 00:06:11.560
So, for example, in this string,
your block, if you call this,

00:06:11.640 --> 00:06:13.880
would be called once
for the first character,

00:06:13.880 --> 00:06:18.560
then the next, and so on, and so on,
and so on, and so on, and so forth,

00:06:18.560 --> 00:06:21.620
until you get to this one that
is not a single unit character,

00:06:21.620 --> 00:06:24.980
but two, and it would be passed in the
range for that one as well.

00:06:26.020 --> 00:06:28.330
We can do the same thing with words.

00:06:28.470 --> 00:06:32.960
And words are an appropriate processing
unit for many different tasks,

00:06:33.030 --> 00:06:38.000
things like uppercasing,
recognition of words, spellchecking,

00:06:38.000 --> 00:06:39.000
and correction.

00:06:39.030 --> 00:06:42.530
One thing to keep in mind with
words is that not all languages

00:06:42.530 --> 00:06:44.990
separate their words by whitespace.

00:06:44.990 --> 00:06:49.920
So you can't rely on whitespace as
an indicator of word boundaries.

00:06:50.130 --> 00:06:53.840
So we have, again,
an API that will deal with this.

00:06:54.030 --> 00:06:58.350
Also in these cases, for example,
it's the same API with

00:06:58.350 --> 00:07:01.980
a different constant,
enumeration by words.

00:07:02.060 --> 00:07:06.000
So if you call this enumeration with
an enumeration by words constant,

00:07:06.000 --> 00:07:10.380
then your block, again,
will be called once for each word in the

00:07:10.380 --> 00:07:12.990
range of the string that you asked for.

00:07:13.100 --> 00:07:16.980
For example, in this string,
it would call for the first word,

00:07:16.980 --> 00:07:19.000
second word, so on and so on.

00:07:19.000 --> 00:07:22.770
And in each case,
it will be passed in the range

00:07:22.960 --> 00:07:25.000
of that word in the text.

00:07:25.000 --> 00:07:28.200
And you can do with it whatever you want.

00:07:29.310 --> 00:07:32.380
Same thing for other units
like sentences and paragraphs.

00:07:32.470 --> 00:07:36.920
Paragraphs are important because
they're in some sense the maximal

00:07:37.050 --> 00:07:39.000
unit for Unicode processing.

00:07:39.200 --> 00:07:43.160
None of the Unicode algorithms
require you to go beyond

00:07:43.160 --> 00:07:45.260
the bounds of a paragraph.

00:07:45.390 --> 00:07:48.280
In some cases they might have
effect on the whole paragraph,

00:07:48.350 --> 00:07:51.330
for example, for bi-die processing.

00:07:51.420 --> 00:07:56.200
Some features in bi-die processing
affect the whole paragraph.

00:07:57.090 --> 00:08:00.510
So again, it will be just the same
API that you can call to iterate

00:08:00.580 --> 00:08:03.080
through paragraph by paragraph.

00:08:03.120 --> 00:08:05.900
And your block in this case will
be called once for each paragraph

00:08:05.980 --> 00:08:07.590
with the range of the paragraph.

00:08:07.760 --> 00:08:12.000
And one useful pattern is to nest these.

00:08:12.030 --> 00:08:15.150
So you could go through your
text first by paragraphs and

00:08:15.150 --> 00:08:19.590
then within the paragraph by
some smaller unit as necessary.

00:08:20.950 --> 00:08:23.220
Now, of course,
block iteration is wonderful,

00:08:23.220 --> 00:08:26.180
but it's not the only thing
that you want to do with text.

00:08:26.340 --> 00:08:28.970
So there are many other APIs on NSString.

00:08:29.280 --> 00:08:32.900
For example,
the range of string APIs are the

00:08:33.000 --> 00:08:39.040
Unicode-savvy way for finding an instance
of a string within a piece of text.

00:08:39.190 --> 00:08:42.880
In this case,
I've chosen to look for a string resume,

00:08:42.930 --> 00:08:46.480
or maybe the string that
I'm matching is resume,

00:08:46.480 --> 00:08:53.660
because I've chosen as options to
include not only case-insensitive search,

00:08:53.740 --> 00:08:55.790
but also diacritic-insensitive search.

00:08:55.960 --> 00:09:01.080
So this search will find that string,
whether it has diacritics on it or not.

00:09:01.210 --> 00:09:06.450
And this is a very powerful API that
can be used for many kinds of locating

00:09:06.450 --> 00:09:09.000
of substrings within a string.

00:09:09.920 --> 00:09:15.400
If I add one additional
parameter to the options,

00:09:15.460 --> 00:09:18.550
I can, instead of looking for
that string in the text,

00:09:18.680 --> 00:09:23.400
I can choose to decide whether I have
matched it at a particular location.

00:09:23.520 --> 00:09:25.330
That's the anchored search option.

00:09:25.420 --> 00:09:27.000
And that doesn't go looking
through the entire string.

00:09:27.000 --> 00:09:30.180
It just looks at the start of the
range that I specify and says,

00:09:30.200 --> 00:09:31.840
is that string there or not?

00:09:31.960 --> 00:09:35.520
And this will match it in a
fully Unicode-savvy way with all

00:09:35.650 --> 00:09:40.270
the options that I specified,
so it will ignore differences of case,

00:09:40.350 --> 00:09:41.540
differences of diacritics.

00:09:41.630 --> 00:09:43.780
In this case,
I've chosen also to ignore the

00:09:43.780 --> 00:09:47.170
difference between the half-width
and full-width characters.

00:09:48.320 --> 00:09:51.890
And if what I want is not
just to see does it match,

00:09:51.890 --> 00:09:54.940
but also to see is it
a comparison result,

00:09:54.940 --> 00:10:01.380
is it before or after in a sort order,
I use the compare API on a string.

00:10:01.670 --> 00:10:06.150
And that returns a comparison
result with all the same options.

00:10:07.900 --> 00:10:12.520
And there are many other APIs on
NSString for deciding whether

00:10:12.520 --> 00:10:16.010
a word has a -- a string has
a given prefix or suffix.

00:10:16.100 --> 00:10:19.250
If you want to look for
characters from a character set

00:10:19.300 --> 00:10:22.250
instead of a specific string,
you can do that.

00:10:22.330 --> 00:10:28.310
And none of these APIs, you'll notice,
mention individual unicars.

00:10:28.420 --> 00:10:31.840
They're all Unicode savvy,
so they deal with ranges

00:10:32.100 --> 00:10:34.300
of text in the string.

00:10:34.370 --> 00:10:38.980
And they find it in a
Unicode conformant way.

00:10:39.210 --> 00:10:42.660
One other set of methods I want
to mention is our powerful

00:10:42.780 --> 00:10:46.240
search and replace methods,
where you can find all instances

00:10:46.400 --> 00:10:48.470
of a specific string and replace
them with something else.

00:10:48.520 --> 00:10:50.110
And we have two variants of that.

00:10:50.220 --> 00:10:54.030
One that if you have an immutable
string that will change it

00:10:54.030 --> 00:10:56.030
and return a modified copy.

00:10:56.150 --> 00:11:01.490
And another one that will take a
mutable string and change it in place.

00:11:04.440 --> 00:11:12.350
Okay, so that's a very simple set
of text processing operations.

00:11:12.450 --> 00:11:15.040
But maybe we wanted to do something
a little more sophisticated.

00:11:15.070 --> 00:11:18.590
Maybe instead of finding
all words in the text,

00:11:18.590 --> 00:11:22.950
I wanted to find, say,
all words that begin with "th."

00:11:24.100 --> 00:11:29.760
Or maybe I wanted to find all
the URLs in this piece of text.

00:11:29.830 --> 00:11:33.310
Or perhaps what I wanted to
do was to find all of the

00:11:33.310 --> 00:11:36.300
nouns in this piece of text.

00:11:36.370 --> 00:11:42.600
Or maybe all the adjectives.

00:11:42.640 --> 00:11:46.910
Or maybe what I wanted to do was to find
all the names in this piece of text.

00:11:55.900 --> 00:12:58.000
[Transcript missing]

00:12:58.170 --> 00:13:02.060
We make this available via a
class called NSRegularExpression.

00:13:02.100 --> 00:13:09.910
This is available in Mac OS X with
Lion on iOS starting with iOS 4.

00:13:10.030 --> 00:13:15.100
And NSRegularExpression represents
a compiled regular expression.

00:13:15.100 --> 00:13:19.020
You create one,
a regular expression object,

00:13:19.210 --> 00:13:22.940
by passing in a regular
expression pattern.

00:13:22.940 --> 00:13:28.700
So here's a contrived little example
of a regular expression pattern.

00:13:28.700 --> 00:13:31.220
It finds -- first of all,
there's a backslash B,

00:13:31.340 --> 00:13:33.090
which finds a word boundary.

00:13:33.120 --> 00:13:35.230
Of course,
the backslash has to be escaped

00:13:35.300 --> 00:13:39.100
with another backslash because
it appears in a string constant.

00:13:39.100 --> 00:13:42.180
Then there's a
parenthesized subexpression,

00:13:42.180 --> 00:13:44.100
which locates an I or an O.

00:13:44.100 --> 00:13:45.100
Another parenthesized subexpression,
which locates an I or an O.

00:13:45.100 --> 00:13:47.250
Another parenthesized
subexpression finds an F or an N,

00:13:47.250 --> 00:13:49.100
and then another slash
B for a word boundary.

00:13:49.100 --> 00:13:53.190
So what this does is to locate
two-letter words that start

00:13:53.190 --> 00:13:55.440
with I or O and end with F or N.

00:13:55.630 --> 00:13:59.020
The option I've chosen to use here
is the case insensitive option.

00:13:59.040 --> 00:14:02.530
So this will find these two-letter words,
whether they're lowercase or

00:14:02.530 --> 00:14:04.500
uppercase or any combination.

00:14:04.650 --> 00:14:06.140
Pretty simple.

00:14:06.280 --> 00:14:09.360
So what are we going to do
with this regular expression

00:14:09.820 --> 00:14:11.410
object once we've created it?

00:14:11.520 --> 00:14:16.540
Well, naturally, the thing to do is to
get a block iteration.

00:14:16.670 --> 00:14:20.290
And that is the basic API on
this regular expression.

00:14:20.310 --> 00:14:24.440
Enumerate matches in string goes
through and calls the block that

00:14:24.570 --> 00:14:29.320
you supply for each match of that
regular expression in the range of

00:14:29.320 --> 00:14:32.360
the string that you're targeting.

00:14:32.440 --> 00:14:36.660
And then, again, once -- in your block,
you can do whatever it is you

00:14:36.660 --> 00:14:40.180
need to do with that match
of the regular expression.

00:14:40.310 --> 00:14:43.390
So, for example, for this string,
it would be called once

00:14:43.650 --> 00:14:46.170
for the first match,
the second match, the third.

00:14:46.180 --> 00:14:48.680
and so on and so on.

00:14:49.700 --> 00:15:51.400
[Transcript missing]

00:15:53.740 --> 00:15:56.960
So, for example,
that particular regular expression

00:15:56.960 --> 00:16:00.590
I demonstrated has two capture groups.

00:16:00.700 --> 00:16:03.910
So what we could do is in our
block when it gets called,

00:16:03.910 --> 00:16:07.790
we can find, first of all,
the overall range of the match.

00:16:08.010 --> 00:16:10.440
And then the range of
the first capture group,

00:16:10.440 --> 00:16:13.960
that's that first sub-expression,
which is just the first

00:16:13.960 --> 00:16:15.460
letter in this case.

00:16:15.580 --> 00:16:18.460
And then the range of
the second capture group,

00:16:18.460 --> 00:16:19.990
in this case just the second letter.

00:16:20.160 --> 00:16:22.820
And then once we have that,
we have everything that there

00:16:22.820 --> 00:16:25.740
is to know about the match
of that regular expression.

00:16:25.840 --> 00:16:29.010
And we can do whatever
it is we want to with it.

00:16:30.140 --> 00:16:34.260
Now, again, as I say,
block iterations are wonderful,

00:16:34.260 --> 00:16:35.520
but they're not the only thing.

00:16:35.520 --> 00:16:38.500
We have convenience methods
if what you want to do is,

00:16:38.560 --> 00:16:42.740
let us say, find all the matches of your
regular expression as an array,

00:16:42.790 --> 00:16:45.410
or just count them,
or just find the first one,

00:16:45.410 --> 00:16:48.320
or maybe all you need is
the range of the first one.

00:16:48.420 --> 00:16:52.340
So if you just want to find the
range of the first match of the

00:16:52.360 --> 00:16:56.880
regular expression in the string,
one line of code, you get it,

00:16:56.880 --> 00:16:59.790
and you've found where
the first match is.

00:17:01.030 --> 00:17:05.300
We also have a very common
operation with regular expressions,

00:17:05.310 --> 00:17:07.500
that is find and replace.

00:17:07.560 --> 00:17:12.400
And again, just like with NSString,
we have one method for immutable

00:17:12.400 --> 00:17:16.300
strings that will take it
and return a modified copy,

00:17:16.330 --> 00:17:21.840
and one method for mutable strings
that will modify it in place.

00:17:21.870 --> 00:17:27.310
Now, the thing that we're replacing
with for a regular expression case,

00:17:27.450 --> 00:17:30.510
it could be a literal string,
but in general,

00:17:30.510 --> 00:17:36.020
it is a template that can include
these meta variables like $0,

00:17:36.120 --> 00:17:43.620
$1, $2, where $0 represents the overall
match of the regular expression.

00:17:43.660 --> 00:17:46.660
$1 is match for the first capture group.

00:17:46.850 --> 00:17:49.560
$2, second capture group.

00:17:49.580 --> 00:17:54.010
This is very typical for regular
expression find and replace.

00:17:54.230 --> 00:17:57.960
So here I chose to do $2, $1,
that is the second capture group,

00:17:58.020 --> 00:17:58.950
followed by the first.

00:17:58.960 --> 00:18:01.190
So if you're familiar
with regular expressions,

00:18:01.190 --> 00:18:04.460
you probably know what this
is going to do to this string.

00:18:04.460 --> 00:18:08.520
It's just going to change the
order of the letters in each

00:18:08.520 --> 00:18:10.750
of these two-letter words.

00:18:13.520 --> 00:18:17.380
Now,
if you're going to use it more than once,

00:18:17.380 --> 00:18:22.080
it's more efficient to
create an NSRegularExpression

00:18:22.080 --> 00:18:24.500
object and hold onto it.

00:18:24.500 --> 00:18:28.500
They're convenient, they're fast,
they're thread safe.

00:18:28.520 --> 00:18:30.820
But if all you want to
do is one operation,

00:18:30.820 --> 00:18:33.490
we have some convenience
methods on NSString.

00:18:33.550 --> 00:18:37.470
You don't have to create a regular
expression object yourself.

00:18:37.530 --> 00:18:40.390
But this is not new API.

00:18:40.460 --> 00:18:45.270
It's just the same old API range
of string with a new option,

00:18:45.370 --> 00:18:49.940
NSRegularExpressionSearch,
that causes the thing you're looking for

00:18:49.940 --> 00:18:54.870
to be treated as a regular expression
pattern instead of a literal string.

00:18:56.780 --> 00:19:02.200
And likewise, you can use the basic
string search and replace.

00:19:02.600 --> 00:19:07.510
and the NIS regular
expression search option,

00:19:07.570 --> 00:19:13.480
which tells it to treat the thing you're
looking for as a regular expression

00:19:13.480 --> 00:19:17.950
pattern and the thing you're replacing
with as a regular expression template.

00:19:20.380 --> 00:19:21.150
All right.

00:19:21.150 --> 00:19:25.460
Suppose we want to go a little further
and look not for a regular expression,

00:19:25.460 --> 00:19:30.860
but suppose we're looking for
something like a URL or a phone number.

00:19:30.860 --> 00:19:33.180
Now,
people sometimes do try to use regular

00:19:33.180 --> 00:19:36.650
expressions for this sort of thing,
which is maybe okay if you're

00:19:36.680 --> 00:19:41.200
just looking for a single pattern,
say a single pattern of phone numbers.

00:19:41.200 --> 00:19:44.080
But once you try to
look for multiple ones,

00:19:44.080 --> 00:19:47.790
it starts to get complicated
and expensive quickly.

00:19:47.860 --> 00:19:51.870
Fortunately, we have something better,
and that is Apple technology

00:19:51.870 --> 00:19:55.280
called data detectors,
which locates interesting

00:19:55.280 --> 00:19:59.160
things like URLs,
phone numbers, dates,

00:19:59.160 --> 00:20:04.200
addresses in a large,
large variety of international formats.

00:20:04.200 --> 00:20:07.500
And it does so very efficiently,
much more efficiently than

00:20:07.580 --> 00:20:09.560
regular expressions could do it.

00:20:09.560 --> 00:20:13.930
And so you may be familiar with
this from the UI context where

00:20:13.930 --> 00:20:17.860
data detectors locates things
in the text you're looking at.

00:20:17.960 --> 00:20:20.640
And, you know,
provides a way to do something

00:20:20.880 --> 00:20:24.600
useful quickly with them,
like show a location on a map.

00:20:24.830 --> 00:20:28.580
But what we're talking about
here is the API version of this,

00:20:28.580 --> 00:20:34.620
low-level API, foundation-level API,
which we expose by a class that's

00:20:34.620 --> 00:20:39.050
just a subclass of NS regular
expression called NSData detector,

00:20:39.120 --> 00:20:42.280
again, available on --

00:20:42.450 --> 00:20:47.990
Mac OS X Lion, and on iOS,
starting with iOS 4.

00:20:48.400 --> 00:20:52.440
So NSDataDetector is a subclass,
as I said, of NSRegularExpression.

00:20:52.480 --> 00:20:56.340
And you create an NSDataDetector,
but not with a regular

00:20:56.340 --> 00:20:57.760
expression pattern.

00:20:57.930 --> 00:21:02.780
You create it instead by specifying
which kinds of data detector types

00:21:02.830 --> 00:21:05.080
you want this detector to find.

00:21:05.260 --> 00:21:08.730
In this case, I've chosen the link type,
which finds URLs,

00:21:08.820 --> 00:21:10.480
and the phone number type,
which finds phone numbers.

00:21:10.580 --> 00:21:12.210
There are a bunch of different types.

00:21:12.350 --> 00:21:17.020
You can look for any or all of dates,
addresses, URLs, phone numbers,

00:21:17.020 --> 00:21:17.990
et cetera.

00:21:18.680 --> 00:21:21.910
And since this is subclass
of NS regular expression,

00:21:22.020 --> 00:21:25.700
the basic API, again,
is a block iterator.

00:21:26.340 --> 00:21:29.830
For example, on this text,
your block would be called first

00:21:29.880 --> 00:21:32.200
with the first thing it finds,
a phone number here,

00:21:32.390 --> 00:21:35.540
second with the second thing it finds,
a URL.

00:21:36.260 --> 00:21:39.140
Now,
this is the point at which we get very

00:21:39.150 --> 00:21:44.540
glad that we used a match object in our
regular expression API because now this

00:21:44.540 --> 00:21:48.740
match object can carry all sorts of other
interesting properties that are useful

00:21:48.830 --> 00:21:50.880
when you find a data detector type.

00:21:50.990 --> 00:21:55.190
For example, if what you found is a date,
there's a date property that can

00:21:55.190 --> 00:21:57.910
get that date as a parsed date.

00:21:58.010 --> 00:21:59.980
If it's an address,
there's a components property

00:21:59.990 --> 00:22:02.320
that gets all the different
components of the address.

00:22:02.460 --> 00:22:04.960
If it's a URL, you can get it as a URL.

00:22:05.060 --> 00:22:08.450
Phone number,
there's a phone number property.

00:22:09.060 --> 00:22:13.900
And here's where we use the result
type for our NSText checking type

00:22:13.950 --> 00:22:16.300
object that expresses the match.

00:22:16.410 --> 00:22:20.170
And that will tell us what
type it is that was found.

00:22:20.340 --> 00:22:24.610
So, for example,
this -- the data detector that I created

00:22:24.610 --> 00:22:26.960
here finds two different types of things.

00:22:27.030 --> 00:22:31.120
And so we need to distinguish,
did we find -- was it a link type?

00:22:31.230 --> 00:22:32.580
That is, was it a URL that's found?

00:22:32.600 --> 00:22:36.770
If so, we can get the URL from
that match object.

00:22:36.880 --> 00:22:38.370
or maybe it was a phone
number that was found,

00:22:38.370 --> 00:22:41.420
in which case we can get the phone
number from the object and then do

00:22:41.510 --> 00:22:43.900
with it whatever we need to do with it.

00:22:44.440 --> 00:22:47.830
Again, there are convenience methods
if you don't want to iterate

00:22:47.830 --> 00:22:51.080
through all the matches,
if you just want to get them all as an

00:22:51.080 --> 00:22:55.080
array or count them or find the first
one or the range of the first one.

00:22:55.170 --> 00:22:57.760
If you just want to find
the range of the first one,

00:22:57.760 --> 00:22:59.880
it's a single line of code like this.

00:23:02.360 --> 00:23:04.740
Okay, so that's data detectors.

00:23:04.800 --> 00:23:10.360
Now, suppose we want to go
a little deeper and,

00:23:10.360 --> 00:23:10.360
um,

00:23:10.990 --> 00:23:15.260
We want to find out something
linguistic about our text.

00:23:15.260 --> 00:23:21.080
So we have a new API for that,
which is new in Mac OS X Lion and iOS 5,

00:23:21.250 --> 00:23:24.000
called linguistic tagging.

00:23:24.110 --> 00:23:28.420
And so the basic premise of
linguistic tagging is that we take

00:23:28.420 --> 00:23:34.400
a piece of text and we divide it
up into pieces that we call tokens.

00:23:34.490 --> 00:23:39.040
And then there are various layers of
linguistic information that we might

00:23:39.040 --> 00:23:41.290
want to find out about this text.

00:23:41.440 --> 00:23:47.140
So the most basic and trivial
is what kind of token is this?

00:23:47.140 --> 00:23:48.050
Is this a word?

00:23:48.050 --> 00:23:48.980
Is this white space?

00:23:48.980 --> 00:23:50.490
Is it punctuation?

00:23:50.540 --> 00:23:53.620
Okay, that's pretty obvious.

00:23:53.710 --> 00:23:54.920
But there are many others.

00:23:54.920 --> 00:23:58.260
For example, we might want to find out
what language is this text in?

00:23:58.280 --> 00:24:02.960
And we have a statistical model
that will tell us as best it can

00:24:03.060 --> 00:24:07.300
what language this text is in,
not currently at the

00:24:07.300 --> 00:24:10.450
individual word level,
but definitely the paragraph level,

00:24:10.450 --> 00:24:12.720
and we'll return that.

00:24:13.480 --> 00:24:17.770
And going a little deeper,
we might want to find out what

00:24:17.850 --> 00:24:20.310
part of speech these words are.

00:24:20.420 --> 00:24:23.280
And again, we have a statistical language
model that will tell us,

00:24:23.380 --> 00:24:31.310
to the best of its ability,
what part of speech is of the word

00:24:31.310 --> 00:24:31.310
as it is used in this context.

00:24:32.590 --> 00:24:35.160
So there are a number of
these different layers.

00:24:35.160 --> 00:24:39.860
We refer to these -- the
layers as tag schemes,

00:24:39.860 --> 00:24:43.800
and the individual pieces of
information they return are called tags.

00:24:43.800 --> 00:24:47.160
So the simplest ones are the basic type,
that is,

00:24:47.250 --> 00:24:50.900
word or white space or punctuation,
et cetera.

00:24:50.900 --> 00:24:57.820
The language, that's returned as a
standard language tag,

00:24:57.820 --> 00:25:00.950
like EN or FR or DE, so forth.

00:25:01.040 --> 00:25:03.550
What script is the text in?

00:25:03.600 --> 00:25:07.660
Latin script, Cyrillic, Arabic, Chinese,
what have you.

00:25:07.660 --> 00:25:12.450
All of these things are available
for many different languages and

00:25:12.450 --> 00:25:14.990
scripts on both Mac OS X and iOS.

00:25:15.160 --> 00:25:24.760
The more sophisticated tag schemes are,
first of all, parts of speech,

00:25:24.760 --> 00:25:24.760
what we call in technical
terms lexical class,

00:25:25.030 --> 00:25:29.510
Is this word as used in context,
is it a noun or verb or

00:25:29.510 --> 00:25:32.190
adjective or what have you?

00:25:32.690 --> 00:25:38.120
Then we have named entity recognition,
which finds out whether a piece

00:25:38.440 --> 00:25:43.330
of text looks like it's you
being used in context as a name,

00:25:43.330 --> 00:25:47.270
and moreover,
does it look like it's a personal name

00:25:47.270 --> 00:25:50.000
or a place name or an organization name?

00:25:50.230 --> 00:25:53.390
And also we have what we call the lemma.

00:25:53.540 --> 00:25:57.910
That is, if we know this word,
we can give you the root form of the

00:25:58.100 --> 00:26:03.440
word without any inflectional suffixes,
so forth, if that's available.

00:26:03.760 --> 00:26:08.360
Now, these are more sophisticated,
and they're not available

00:26:08.360 --> 00:26:10.500
for all languages on Lion.

00:26:10.500 --> 00:26:13.240
We have lexical class
and lemmas for English,

00:26:13.340 --> 00:26:14.690
French, and German.

00:26:14.900 --> 00:26:17.280
We have named entity
recognition for English.

00:26:17.320 --> 00:26:21.740
On the version of iOS 5 you have now,
currently, all these things are

00:26:21.740 --> 00:26:23.570
available only for English.

00:26:25.810 --> 00:26:26.860
So how does this work?

00:26:26.970 --> 00:26:30.210
So we have the class NSLinguisticTagger.

00:26:30.210 --> 00:26:32.060
That is the interface for all of this.

00:26:32.210 --> 00:26:36.000
And you create an
NSLinguisticTagger object.

00:26:36.310 --> 00:26:39.960
By specifying a set of schemes.

00:26:40.080 --> 00:26:44.300
And so in this case,
I've chosen that I want to be able to

00:26:44.300 --> 00:26:46.470
get out the basic token type scheme.

00:26:46.600 --> 00:26:49.990
I want the lexical class scheme
that gives me parts of speech.

00:26:50.150 --> 00:26:53.600
And I want the name type
scheme that gives me names.

00:26:54.820 --> 00:26:58.120
Once you have your tagger,
then you take the string that

00:26:58.120 --> 00:27:02.770
you want to analyze and you
attach that string to the tagger.

00:27:02.930 --> 00:27:07.840
This is important because the linguistic
tagger keeps a bunch of state about

00:27:07.840 --> 00:27:12.480
that string so that it only has to
analyze a particular piece of it once,

00:27:12.490 --> 00:27:14.980
no matter how many times you ask.

00:27:16.810 --> 00:27:19.730
And then, of course,
I think you can guess what

00:27:19.730 --> 00:27:21.040
the basic API is for it.

00:27:21.040 --> 00:27:23.700
It's a block iteration.

00:27:23.820 --> 00:27:27.960
Enumerate tags in range.

00:27:27.960 --> 00:27:27.960
You tell the tagger,

00:27:28.370 --> 00:27:35.900
Go through this range of my string and
tell me for each token in the string what

00:27:36.210 --> 00:27:39.600
the tag is for in the particular scheme.

00:27:39.600 --> 00:27:42.500
So in this case,
I'm using the lexical class scheme,

00:27:42.500 --> 00:27:46.020
so it will tell me the parts of
speech for each of these tokens.

00:27:46.420 --> 00:27:53.520
And it passes in that tag and the
range of the token and also the range

00:27:53.840 --> 00:27:57.620
of the sentence within which it lives.

00:27:58.360 --> 00:28:01.720
And then I can take a look at it and
do whatever it is I need to do with it.

00:28:01.800 --> 00:28:04.380
For example, if it's a noun,
do something with it.

00:28:04.440 --> 00:28:08.600
This code is taken directly
from that app that I showed.

00:28:11.370 --> 00:28:15.530
Again, block iteration is not the only
thing you might want to do,

00:28:15.540 --> 00:28:20.570
so we have some additional
methods if you just want to find

00:28:20.690 --> 00:28:25.560
the tag for a particular token,
or if you want to get the tags

00:28:25.560 --> 00:28:28.270
for a set of tokens as an array.

00:28:28.340 --> 00:28:30.900
We also have methods for that.

00:28:31.030 --> 00:28:35.340
So if you just want to find out
what is the part of speech for this

00:28:35.400 --> 00:28:40.030
particular word here at this index,
you call this method and

00:28:40.030 --> 00:28:41.890
it gets back that tag.

00:28:44.990 --> 00:28:46.960
Now, we use this for a number
of different things.

00:28:47.040 --> 00:28:50.020
We use it to assist with
auto-correction for dictionary

00:28:50.080 --> 00:28:51.640
lookup and things like that.

00:28:51.880 --> 00:28:55.750
If you're concerned about performance,
one thing I might mention

00:28:55.760 --> 00:28:58.740
is currently on Lion,
we're doing this essentially

00:28:58.830 --> 00:29:04.500
full-time for the text you
type to help in correcting it.

00:29:04.580 --> 00:29:08.690
But I'm sure that there are plenty of
other potential applications for this

00:29:08.810 --> 00:29:12.400
that we haven't thought up yet and
that you may be able to come up with.

00:29:12.460 --> 00:29:15.640
But right now,
I'd like to bring up my colleague

00:29:15.730 --> 00:29:22.740
Jennifer Moore to show one
particular demo application.

00:29:24.080 --> 00:29:24.570
Hi.

00:29:28.390 --> 00:29:32.140
This demo is a sample application
of how we can use these

00:29:32.140 --> 00:29:36.320
linguistic APIs to provide a more
visually compelling experience

00:29:36.390 --> 00:29:42.120
of the text in our application.

00:29:42.890 --> 00:29:46.740
I have a set of biographies
of some of the top trending

00:29:46.820 --> 00:29:48.900
artists on iTunes right now.

00:29:48.940 --> 00:29:52.910
And what I want to do is...

00:29:55.160 --> 00:29:57.630
What I want to do is use the
linguistic tagger to extract the

00:29:57.630 --> 00:30:02.580
most frequent words out of these
texts and send it to the user in

00:30:02.580 --> 00:30:05.100
the form of a nice big word cloud.

00:30:05.120 --> 00:30:08.630
So we get a nice visual look
at the content of our data.

00:30:08.740 --> 00:30:12.760
So to do that, it's very simple.

00:30:12.760 --> 00:30:12.760
We're going to start...

00:30:13.170 --> 00:30:17.900
First, we start by initializing
our linguistic tagger,

00:30:17.920 --> 00:30:21.340
as you showed before,
with a set of tag schemes.

00:30:21.350 --> 00:30:22.750
And for now,
we're going to start off with

00:30:22.750 --> 00:30:28.100
a lexical class tag scheme and
also the name type tag scheme.

00:30:28.100 --> 00:30:30.100
And then for each one of our biographies,
it's very simple.

00:30:30.100 --> 00:30:34.090
This is the core of our work here.

00:30:34.150 --> 00:30:36.430
For each of our texts,
we're going to associate that

00:30:36.430 --> 00:30:39.100
text with our NSLinguisticTagger,
with set string.

00:30:39.100 --> 00:30:42.340
And then we're going to use
our block API to iterate over

00:30:42.360 --> 00:30:44.100
all the words in our text.

00:30:44.100 --> 00:30:46.910
So we call enumerate tags in
range with our text range.

00:30:47.100 --> 00:30:50.230
And for our purposes,
we're going to use a lexical class

00:30:50.230 --> 00:30:53.570
tag scheme because for our word cloud,
we don't really want

00:30:53.570 --> 00:30:54.840
words like of and the.

00:30:55.060 --> 00:30:56.100
These are kind of boring words.

00:30:56.100 --> 00:30:58.620
What we really want are
all the nouns of the text.

00:30:58.620 --> 00:31:02.100
These are the words that convey
the most information in our text.

00:31:02.120 --> 00:31:04.950
So what we're going to do is if
the word type is of the type noun,

00:31:05.100 --> 00:31:08.100
we're going to extract that word from
our text and add it to our set of tags.

00:31:08.100 --> 00:31:08.100
And then we're going to use
our block API to iterate over

00:31:08.100 --> 00:31:08.100
all the words in our text.

00:31:08.110 --> 00:31:12.060
And add it to our set of words
with the corresponding count.

00:31:12.110 --> 00:31:14.100
Keeping track of the count.

00:31:14.100 --> 00:31:17.890
And the rest of it is just getting
the most frequent words out of our

00:31:18.040 --> 00:31:21.100
set and displaying it in the view,
which I'm not going to show here,

00:31:21.100 --> 00:31:23.100
but it's pretty straightforward.

00:31:23.120 --> 00:31:27.210
So all we just do now is build and run.

00:31:27.540 --> 00:31:30.470
and now we have a nice word
cloud of these are all the most

00:31:30.470 --> 00:31:31.880
frequent words of our text.

00:31:31.880 --> 00:31:34.020
And you see the words
that kind of pop out.

00:31:34.080 --> 00:31:40.500
Music, pop is kind of the genre of music
that's most popular right now.

00:31:40.610 --> 00:31:43.080
But, you know,
if we're looking at biographies,

00:31:43.080 --> 00:31:46.160
these are biographies of people,
and actually it wouldn't be interesting

00:31:46.160 --> 00:31:50.220
if we could look at all the names
across our text and maybe capture

00:31:50.220 --> 00:31:53.660
some of the relationships of artists
who are influenced by other artists,

00:31:53.740 --> 00:31:54.820
maybe.

00:31:55.000 --> 00:31:57.250
So we can do that.

00:31:58.000 --> 00:31:59.020
And the change is very simple.

00:31:59.020 --> 00:32:01.520
We go back to our code here.

00:32:01.520 --> 00:32:05.130
Instead of
NSLinguisticTagSchemeLexicalClass,

00:32:05.360 --> 00:32:09.090
let's just do name type.

00:32:09.450 --> 00:32:13.250
And if we're looking at names,
sometimes names can have multiple

00:32:13.250 --> 00:32:14.900
tokens as part of the name.

00:32:14.980 --> 00:32:16.010
So we have an option for that.

00:32:16.050 --> 00:32:20.200
It would be nice to have one
range for the entire name.

00:32:20.370 --> 00:32:23.600
So we can use this option here.

00:32:26.060 --> 00:32:29.610
and his linguistic tagger join names.

00:32:29.630 --> 00:32:35.240
And then instead of nouns here,
we're going to look for, let's say,

00:32:35.260 --> 00:32:37.000
all the personal names.

00:32:37.070 --> 00:32:37.370
And that's it.

00:32:37.440 --> 00:32:40.220
That's all the change
that we have to make.

00:32:40.330 --> 00:32:41.800
So we run this again.

00:32:42.760 --> 00:32:46.290
And now these are all the names
across all of our biographies.

00:32:46.290 --> 00:32:49.660
And you see Alanis Morissette was not
one of the biographies we're looking at,

00:32:49.750 --> 00:32:53.460
but she influenced a lot of musicians.

00:32:53.460 --> 00:32:56.450
So that's our word cloud.

00:33:00.990 --> 00:33:04.960
Now, I think we said earlier that
these APIs are cross-platform,

00:33:04.960 --> 00:33:08.360
so I just want to show that to you now.

00:33:08.680 --> 00:33:11.070
Almost the exact same code.

00:33:15.810 --> 00:33:23.820
Although not quite as flashy,
but... So we have all the words,

00:33:23.860 --> 00:33:27.030
all the nouns in our text,
and we can also get all

00:33:27.090 --> 00:33:28.790
of the names in our text.

00:33:29.670 --> 00:33:34.910
and that's linguistic
tagging on iOS and Mac OS X.

00:33:43.300 --> 00:35:19.000
[Transcript missing]

00:35:20.120 --> 00:35:25.500
So now what I want to do is to go
on to the piece of this that is

00:35:25.520 --> 00:35:30.120
-- has available similar APIs on
iOS and Mac OS X but not identical

00:35:30.120 --> 00:35:35.690
because these APIs are at the
UI level in AppKit or UIKit.

00:35:35.820 --> 00:35:41.170
And this is text checking,
which is represented by a spell

00:35:41.170 --> 00:35:47.230
checker on Mac OS X in AppKit and
UI text checker in UIKit on iOS.

00:35:47.290 --> 00:35:49.180
And this does a number
of different things,

00:35:49.260 --> 00:35:53.850
but the most significant and important
thing is it does spell checking.

00:35:54.310 --> 00:35:59.490
and the various UI text editing
widgets on both platforms all

00:35:59.500 --> 00:36:03.860
use it already by default,
but we also make it available

00:36:03.860 --> 00:36:07.600
to you as an API so you can
use it wherever you need it.

00:36:07.760 --> 00:36:10.570
So NSSpellChecker.

00:36:11.110 --> 00:36:14.600
NSSpellChecker in AppKit,
the way this is organized is that

00:36:14.600 --> 00:36:18.470
there's a single shared spellchecker
object for the whole application,

00:36:18.470 --> 00:36:20.040
and you can just get it.

00:36:20.110 --> 00:36:25.660
And then you can ask it to do
some checking of a piece of text.

00:36:25.770 --> 00:36:29.430
And actually NSSpellChecker will check
for a number of different things.

00:36:29.600 --> 00:36:32.280
It can look for misspelled words.

00:36:32.350 --> 00:36:34.790
It can look for potential
grammar mistakes.

00:36:34.800 --> 00:36:38.730
It can find corrections to the text.

00:36:38.870 --> 00:36:45.900
It can do smart quotes, smart dashes,
and it also does the text replacement,

00:36:45.900 --> 00:36:48.130
which is a sort of shortcut type
feature where you type a piece of

00:36:48.190 --> 00:36:49.790
text and it gets replaced by something
else that they don't know about.

00:36:49.800 --> 00:36:52.540
And it's a very simple process
that the user has specified.

00:36:52.610 --> 00:36:56.930
And the way that it works,
unfortunately we don't yet have a

00:36:56.930 --> 00:36:59.790
neat block iteration API for this.

00:36:59.870 --> 00:37:06.700
You call it and you get back an array of,
again, NSTextCheckingResult objects.

00:37:06.780 --> 00:37:11.190
You specify what kinds of types
of things you want it to look for.

00:37:11.310 --> 00:37:16.810
And then you get this array back
of results and you can go through

00:37:16.810 --> 00:37:22.240
the results and for each one,
again, you can look at the result type,

00:37:22.320 --> 00:37:25.810
the result range,
and see what kind of thing it is that

00:37:25.810 --> 00:37:31.180
it found and what the range is and
possibly other attributes to tell you

00:37:31.210 --> 00:37:33.840
what you might want to do with it.

00:37:33.840 --> 00:37:35.500
There is also a separate API.

00:37:35.500 --> 00:37:36.680
This is a synchronous API.

00:37:36.680 --> 00:37:39.940
There's also a separate asynchronous
API where you can call and get

00:37:39.950 --> 00:37:41.200
results back at some later point.

00:37:41.200 --> 00:37:44.220
point when they might be available.

00:37:45.080 --> 00:37:47.550
So, for example,
if you were looking for misspelled

00:37:47.550 --> 00:37:51.370
words in this piece of text,
you would get back two different results,

00:37:51.460 --> 00:37:55.430
and you would go through them one by one,
and it would tell you what the

00:37:55.470 --> 00:37:56.940
range of each is in the text.

00:37:57.140 --> 00:37:59.660
As I say,
there are different kinds of things

00:37:59.660 --> 00:38:03.330
that a spellchecker will check for:
spelling errors,

00:38:03.360 --> 00:38:06.940
possible grammar mistakes,
straight quotes that might be

00:38:06.950 --> 00:38:12.440
substituted smartly by curly quotes,
same thing for dashes,

00:38:12.440 --> 00:38:17.770
the text replacements,
and potential corrections.

00:38:17.910 --> 00:38:20.100
That is not the only
API on a spellchecker.

00:38:20.100 --> 00:38:24.730
There are also specific methods for
doing things like spellchecking.

00:38:24.900 --> 00:38:29.570
If you want to go through and find the
first misspelled word in a range of text,

00:38:29.570 --> 00:38:31.060
this call will do it.

00:38:31.170 --> 00:38:33.690
If you have a misspelled word
and you want to find out what

00:38:33.790 --> 00:38:37.980
the spellchecker wants to suggest
as possible alternatives for it,

00:38:38.080 --> 00:38:40.180
you can get several different
alternatives by calling

00:38:40.220 --> 00:38:42.910
calling guesses for word range.

00:38:43.920 --> 00:38:47.160
If you want to find the
single proposed correction,

00:38:47.180 --> 00:38:51.790
if any,
you can call a correction for word range.

00:38:54.200 --> 00:38:59.670
And there is also, as I mentioned,
the UI text editing objects

00:38:59.670 --> 00:39:06.460
like NSTextView and WebView will
automatically use NSSpellChecker to do

00:39:06.460 --> 00:39:09.730
spellchecking and correction and so on.

00:39:09.820 --> 00:39:14.080
And they all have some API that
allow you to turn on and off all

00:39:14.760 --> 00:39:19.640
these different facilities on
a specific view-by-view basis.

00:39:19.800 --> 00:39:21.860
The user can also turn them on and off.

00:39:21.970 --> 00:39:27.500
So there are user preferences
available for these things as well.

00:39:27.540 --> 00:39:31.690
And in addition, at NSTextView level,
you can customize all this

00:39:31.690 --> 00:39:36.500
by overriding the methods
NSTextView has to call NSSpellChecker

00:39:36.500 --> 00:39:38.290
and to get the results back.

00:39:38.370 --> 00:39:41.900
So you can customize
it in any way you want.

00:39:44.270 --> 00:39:51.120
Something that you may have seen on
Mac OS X Lion is that we have a new

00:39:51.120 --> 00:39:56.840
UI for autocorrection that is very
similar to the iOS autocorrection UI.

00:39:56.840 --> 00:40:04.610
This is something new that we provide,
and it is implemented both,

00:40:04.610 --> 00:40:08.120
and as TextView and WebView will
automatically use this if

00:40:08.170 --> 00:40:10.210
autocorrection is turned on.

00:40:11.100 --> 00:40:13.550
But as I say,
it can be turned on and off per view,

00:40:13.610 --> 00:40:16.680
or the user can decide whether
or not to use it globally.

00:40:16.680 --> 00:40:22.490
But if you have your own TextView,
we also have APIs that allow

00:40:22.490 --> 00:40:28.360
you to bring up these correction
indicators as well if you need to.

00:40:28.360 --> 00:40:32.410
So there's an API to show one
of the correction indicators,

00:40:32.460 --> 00:40:37.250
also one to dismiss it,
and also there's the record response

00:40:37.250 --> 00:40:41.990
API where you tell the spellchecker,
"Did the user accept this correction,

00:40:41.990 --> 00:40:45.490
or did they refuse it,
or did they go back and edit it and

00:40:45.490 --> 00:40:50.070
revert it?" So that the spellchecker
can learn from the user's behavior

00:40:50.070 --> 00:40:55.870
and customize its autocorrections and
not do the ones the user doesn't want.

00:40:58.320 --> 00:41:01.280
On the iOS side,
there is UI Text Checker,

00:41:01.280 --> 00:41:03.880
which provides spellchecking.

00:41:03.880 --> 00:41:10.290
It doesn't yet do a number of the
other things that a spellchecker does.

00:41:10.320 --> 00:41:12.690
It uses a slightly different model.

00:41:12.800 --> 00:41:16.990
So for UI Text Checker,
you don't use a single shared instance.

00:41:17.000 --> 00:41:21.810
You create a new instance for each
document that you want to check.

00:41:21.960 --> 00:41:23.540
Create one.

00:41:23.540 --> 00:41:28.930
Then UI Text Checker has the basic sort
of API where you go through a piece of

00:41:28.930 --> 00:41:31.220
text and find the first misspelled word.

00:41:31.410 --> 00:41:35.300
And you call it again to go through
and find the next misspelled word.

00:41:35.310 --> 00:41:39.060
And again,
once you have found a misspelled word,

00:41:39.060 --> 00:41:44.340
then you can ask what are the possible
correction alternatives that you

00:41:44.340 --> 00:41:46.260
might want to suggest to the user.

00:41:46.270 --> 00:41:50.140
These are the sorts of things
you would see if you tap on

00:41:50.140 --> 00:41:51.950
a misspelled word in iOS.

00:41:52.160 --> 00:41:54.600
You get some alternatives
to correct it to.

00:41:54.600 --> 00:41:59.080
And those are the sorts of things
that this API would provide.

00:42:01.500 --> 00:42:12.100
[Transcript missing]

00:42:13.640 --> 00:42:17.550
This demo is perhaps not
quite as flashy as Jennifer's,

00:42:17.640 --> 00:42:21.960
but I chose it because it provides a
good example of how to use all these

00:42:21.960 --> 00:42:24.730
different pieces in the toolkit together.

00:42:24.840 --> 00:42:30.610
And so what this application does is
it takes a piece of text and it does a

00:42:30.610 --> 00:42:35.620
specific kind of capitalization on it,
the sort of capitalization you

00:42:35.620 --> 00:42:38.660
would expect if you're going
to show something as a title.

00:42:38.860 --> 00:42:41.720
Sometimes it's called headline style.

00:42:43.400 --> 00:42:46.840
So I enter the text in
the old capitalization,

00:42:46.840 --> 00:42:50.900
and it comes out with
certain words capitalized.

00:42:50.930 --> 00:42:55.940
Now, the rules for headline style,
if you look in the style manuals,

00:42:55.970 --> 00:42:59.290
they're kind of complicated and fussy.

00:42:59.370 --> 00:43:02.150
And in some cases --
even just for English.

00:43:02.150 --> 00:43:07.280
I'm doing this only for
English here as a demo.

00:43:07.410 --> 00:43:13.210
They generally depend on not just
what word it is or how long it is,

00:43:13.210 --> 00:43:17.690
but also what part of speech the
word is and even how it's being used,

00:43:17.690 --> 00:43:20.300
what part of speech it's
being used as in the text.

00:43:20.300 --> 00:43:24.260
So, for example,
most of the long words get capitalized.

00:43:24.310 --> 00:43:26.230
Some of the short words
don't get capitalized,

00:43:26.360 --> 00:43:29.300
but usually it's just things like
the articles and prepositions.

00:43:29.310 --> 00:43:34.690
The verbs like "is" will be
capitalized even though they're short.

00:43:36.850 --> 00:43:41.600
And there are a number of
other twists and turns.

00:43:41.740 --> 00:43:44.040
So let's see.

00:43:44.040 --> 00:43:46.000
This has a few other features.

00:43:46.020 --> 00:43:49.140
So, for example,
this particular app knows how to

00:43:49.140 --> 00:43:52.440
capitalize things like iPhone and iCloud.

00:43:53.450 --> 00:43:58.900
So you notice that the first word
of a title is always capitalized,

00:43:58.900 --> 00:44:01.190
even if it would otherwise not be.

00:44:01.310 --> 00:44:04.730
So "on" is capitalized as the first word,
even though it's not when it

00:44:04.820 --> 00:44:06.760
appears in the middle of the text.

00:44:06.950 --> 00:44:14.480
But if I were going to do something
like make this a parenthesized,

00:44:14.720 --> 00:44:17.880
and the other folks at Microsoft.

00:44:17.970 --> 00:44:23.710
I'm going to show you how to analyze
text in a wide range of ways.

00:44:24.240 --> 00:44:27.850
and you notice I have also
done some nice smart quoting,

00:44:27.870 --> 00:44:30.980
so I convert the straight
quotes into curly quotes.

00:44:32.480 --> 00:44:38.670
and one last thing to show is I have
a little quote from Shakespeare here.

00:44:39.350 --> 00:44:45.110
And you'll notice that the word
"on" in this quote is capitalized.

00:44:45.330 --> 00:44:49.760
It was not capitalized in these previous

00:44:51.300 --> 00:45:09.400
[Transcript missing]

00:45:09.940 --> 00:45:15.140
and you could combine them in other
ways if you had different sets of rules.

00:45:15.360 --> 00:45:19.400
So this Titleizer is going to
make use of a linguistic tagger.

00:45:19.530 --> 00:45:24.300
So the first thing I do when I create it
is I create myself a linguistic tagger.

00:45:24.420 --> 00:45:29.440
And the tag scheme I've chosen to use is
our -- one I haven't mentioned before.

00:45:29.440 --> 00:45:31.850
This is our top-level tag scheme.

00:45:31.950 --> 00:45:33.700
Name, type, or lexical class.

00:45:33.730 --> 00:45:37.860
So this will tell you -- if it's a name,
it'll tell you what kind of name it is.

00:45:37.860 --> 00:45:41.950
If it's not,
it'll tell you what part of speech it is.

00:45:43.050 --> 00:45:48.500
And I'm also going to use a data
detector for finding URLs because,

00:45:48.500 --> 00:45:52.260
you know, I don't want to go and change
in capitalization of URLs.

00:45:52.380 --> 00:45:53.860
That doesn't really make sense.

00:45:53.980 --> 00:45:55.740
So I'll find the URLs in it.

00:45:55.820 --> 00:46:00.660
And I'm going to use a
mutable index set with that,

00:46:00.660 --> 00:46:04.330
and I'll show you that in a minute.

00:46:06.400 --> 00:46:10.460
This is the external API for this, title,
string for string.

00:46:10.460 --> 00:46:13.840
And so basically the first thing
I'm going to do is associate my

00:46:13.840 --> 00:46:17.200
string with my tagger so I can
get tagging results for it.

00:46:17.300 --> 00:46:20.030
And as I said,
I'm going to do this just for English,

00:46:20.060 --> 00:46:24.760
so I'm going to tell the linguistic
tagger to treat the text as English.

00:46:24.760 --> 00:46:27.700
If I don't do this,
the tagger will try to identify

00:46:27.700 --> 00:46:30.170
the language of the text,
but here I want to

00:46:30.190 --> 00:46:31.760
treat it all as English.

00:46:32.230 --> 00:46:34.640
And then I'm going to
find URLs in the text,

00:46:34.640 --> 00:46:38.950
and what I'm going to do is determine
where the URLs are and use my

00:46:38.950 --> 00:46:43.250
mutable index set to record all
the indexes of URLs in the string

00:46:43.250 --> 00:46:45.700
and just leave all those alone.

00:46:45.880 --> 00:46:51.850
So I just use the enumerate matches
in string API for my data detector.

00:46:52.050 --> 00:46:54.520
Whenever I get a result,
I add those indexes to

00:46:54.520 --> 00:46:55.880
my mutable index set.

00:46:56.060 --> 00:47:00.380
So now I know where all
the URLs are in this text.

00:47:00.620 --> 00:47:03.660
Now I'm going to go through
the text word by word.

00:47:03.780 --> 00:47:11.180
This is the numerate substrings and range
API that I mentioned before going through

00:47:12.480 --> 00:47:13.820
by words.

00:47:13.820 --> 00:47:20.240
Now, as I mentioned,
and as you saw in Jennifer's example,

00:47:20.240 --> 00:47:23.500
the linguistic tagger will
also iterate through text.

00:47:23.500 --> 00:47:27.000
But one thing to keep in mind
is that the linguistic tagger

00:47:27.000 --> 00:47:29.650
analyzes text on a linguistic basis.

00:47:29.650 --> 00:47:33.720
So in particular,
for words like in English like "can't"

00:47:33.720 --> 00:47:38.060
and "won't" and "should have" that are
actually two words smashed together,

00:47:38.060 --> 00:47:40.280
the linguistic tagger
will separate those.

00:47:40.400 --> 00:47:43.600
But for casing operations,
what I want to do work with is

00:47:43.600 --> 00:47:48.920
the actual words and go word by
word as they are in the text.

00:47:48.920 --> 00:47:52.740
So I'm going to enumerate by word
and then I'm going to ask the tagger

00:47:52.740 --> 00:47:58.590
individually what it thinks the
part of speech is for those words.

00:47:58.590 --> 00:48:02.020
And another thing I can find out from
the tagger is the range of sentences in

00:48:02.020 --> 00:48:06.420
the text because I want to capitalize,
in this case, the first and last words

00:48:06.420 --> 00:48:08.050
of any whole sentence.

00:48:08.060 --> 00:48:09.550
I'm sorry.

00:48:11.240 --> 00:48:14.440
Another thing to keep in mind is
that in addition to the words,

00:48:14.640 --> 00:48:17.960
there's also space stuff
in between the words,

00:48:17.960 --> 00:48:21.450
which might be white space, punctuation,
et cetera.

00:48:21.530 --> 00:48:25.990
And I want to do something with that,
too.

00:48:26.080 --> 00:48:32.080
Now, one thing to keep in mind about this
enumerate substrings and range API is

00:48:32.080 --> 00:48:35.150
that it actually passes in two ranges.

00:48:35.250 --> 00:48:37.340
One is the substring range,
that's the range of the

00:48:37.340 --> 00:48:38.240
thing you're looking at.

00:48:38.320 --> 00:48:43.210
And there's also the enclosing range,
which includes all the other parts

00:48:43.210 --> 00:48:47.180
of the text between -- in this case,
between the words.

00:48:47.330 --> 00:48:51.970
And it's designed so that the
enclosing ranges will completely

00:48:52.070 --> 00:48:55.120
partition the text with no overlap.

00:48:55.250 --> 00:48:59.430
So the enclosing range will include
for the first word all the text

00:48:59.550 --> 00:49:02.950
before the first word and the
text after it to the next word.

00:49:02.960 --> 00:49:06.410
And then for subsequent words,
it will include all the text

00:49:06.510 --> 00:49:08.150
after the words as well.

00:49:08.810 --> 00:49:14.490
So first I'm going to take a look at
and analyze the text before the word,

00:49:14.510 --> 00:49:17.680
if there is any,
and the text after the word.

00:49:17.770 --> 00:49:20.480
And I'll go through
that in just a moment.

00:49:20.550 --> 00:49:23.970
And that will help me -- so
one thing I'm going to do

00:49:24.010 --> 00:49:27.570
there is do these smart quotes,
for example.

00:49:28.450 --> 00:49:34.490
And then I'd take a look at
the text before the word.

00:49:34.490 --> 00:49:41.220
And so if this word is the
first word of the text,

00:49:42.500 --> 00:49:48.350
Or if it's the last word of the text,
or if it's the last word of the sentence,

00:49:48.950 --> 00:49:53.370
Or if the non-word text before
it had something like an opening

00:49:53.370 --> 00:49:57.950
parenthesis or an opening quote,
or if the text after it had

00:49:58.110 --> 00:50:00.850
something like a closing parenthesis,
a closing quote,

00:50:00.850 --> 00:50:03.810
then I definitely want to capitalize it.

00:50:04.300 --> 00:50:07.300
No matter what part of speech it is.

00:50:07.300 --> 00:50:11.840
And then I call this string
for word range method that

00:50:11.840 --> 00:50:15.100
does the actual cuts of it.

00:50:15.150 --> 00:50:17.290
So let's take a look at that.

00:50:18.910 --> 00:50:23.370
So the main thing I do
here is I ask the tagger,

00:50:23.470 --> 00:50:25.580
what part of speech is this word?

00:50:26.660 --> 00:50:30.680
I'm also going to ask the spellchecker,
do you have a correction for this word?

00:50:30.770 --> 00:50:34.100
Now, we're not going to try to
correct all spelling errors here.

00:50:34.370 --> 00:50:41.310
We're just going to try to correct
those that are case errors,

00:50:41.310 --> 00:50:41.310
like not capitalizing P in iPhone.

00:50:42.750 --> 00:50:47.070
So I want to decide whether
this word should be capitalized.

00:50:47.160 --> 00:50:50.400
If it was the first or
last word of a sentence,

00:50:50.450 --> 00:50:54.120
et cetera, as determined before, yes,
I want to capitalize it.

00:50:54.170 --> 00:51:01.450
Otherwise, if it's a conjunction,
like and, or, or a preposition,

00:51:01.470 --> 00:51:05.240
like of and to,
then my style manual said that

00:51:05.310 --> 00:51:07.990
those should be capitalized
only if they're long,

00:51:08.060 --> 00:51:10.690
only if they're greater
than four characters.

00:51:11.170 --> 00:51:15.020
If it's a determiner or particle,
like an article,

00:51:15.020 --> 00:51:18.770
"A," "A" or "The," it should
be capitalized unless it is

00:51:18.770 --> 00:51:23.000
one of these specific words,
"A" and "The" or "To."

00:51:23.080 --> 00:51:24.940
Those are my style rules.

00:51:25.020 --> 00:51:28.820
If your style rules are different,
you could express them in

00:51:28.820 --> 00:51:31.040
similar ways with these tools.

00:51:31.130 --> 00:51:34.200
Otherwise, we want to capitalize it.

00:51:34.420 --> 00:51:35.990
Now we know where we
want to capitalize it,

00:51:36.060 --> 00:51:39.540
but we still need to check,
is it part of a URL?

00:51:39.750 --> 00:51:43.500
If it's part of a URL,
just leave it alone.

00:51:43.620 --> 00:51:46.800
If we had a case correction
for it from the spellchecker,

00:51:46.910 --> 00:51:50.840
that is, if the spellchecker's
correction is the same as our

00:51:50.840 --> 00:51:54.460
original word except for case,
that's this case-insensitive compare,

00:51:54.460 --> 00:51:58.280
then I use the spellchecker's version
for things like iPhone and iPad.

00:52:00.420 --> 00:52:03.340
Otherwise, if I think it should be
capitalized and it's not,

00:52:03.430 --> 00:52:04.460
capitalize it.

00:52:04.510 --> 00:52:07.300
Otherwise, if I don't think it should
be capitalized and it is,

00:52:07.300 --> 00:52:08.130
lowercase it.

00:52:09.570 --> 00:52:12.500
And then one more thing.

00:52:12.500 --> 00:52:15.380
Remember I mentioned the string by
replacing occurrences of string method.

00:52:15.460 --> 00:52:19.830
I'm going to take any apostrophes that
happen to lie in the middle of this word

00:52:19.830 --> 00:52:22.600
and replace them with curly apostrophes.

00:52:22.680 --> 00:52:26.070
And that gives me my result for the word.

00:52:27.640 --> 00:52:32.590
And now let me take a look at what
happened with those interword ranges.

00:52:32.710 --> 00:52:36.630
So the text in between the words,
here I'm going to use the tagger

00:52:37.100 --> 00:52:39.100
and use the tagger's enumeration.

00:52:39.120 --> 00:52:42.360
You might have some white space and some
punctuation and some more white space,

00:52:42.360 --> 00:52:42.920
say.

00:52:43.220 --> 00:52:45.800
And I'm going to go through
these piece by piece.

00:52:45.810 --> 00:52:49.860
Remember that the tagger stores
the information about the text.

00:52:49.900 --> 00:52:53.730
And so no matter how many times I ask,
it's only going to evaluate

00:52:53.810 --> 00:52:55.690
that piece of text once.

00:52:56.830 --> 00:53:01.620
So I go through and find
out what that token is.

00:53:01.620 --> 00:53:05.900
And if it is a single quote,
the tagger will tell me whether it's

00:53:05.900 --> 00:53:07.600
an open quote or a closed quote.

00:53:07.660 --> 00:53:10.060
If it's an open quote,
I'm going to replace it

00:53:10.060 --> 00:53:13.400
with a curly open quote,
otherwise a curly closed quote.

00:53:14.690 --> 00:53:17.820
Likewise for a double quote,
it will tell me whether it thinks

00:53:17.820 --> 00:53:20.800
it's an open quote or a closed quote.

00:53:21.300 --> 00:53:26.280
And I replace it with a curly
open or closed quote accordingly.

00:53:26.300 --> 00:53:28.960
If the tagger tells me
this is white space,

00:53:28.960 --> 00:53:30.940
what I've chosen to do here
is replace all the white

00:53:30.940 --> 00:53:32.350
space with just single space.

00:53:32.380 --> 00:53:34.640
I'm going to condense
down all the white space.

00:53:34.760 --> 00:53:39.310
Otherwise, I just pass it through
and leave it alone.

00:53:40.940 --> 00:53:49.930
And so that puts together all of
these different techniques for

00:53:49.930 --> 00:53:54.070
analyzing text and shows them
working together in a single example.

00:53:54.270 --> 00:53:57.760
Now, this example is a bit complicated,
so I think what we're going

00:53:57.760 --> 00:54:00.160
to try to do is make this
available as a developer example.

00:54:00.160 --> 00:54:01.600
It's not up yet.

00:54:01.650 --> 00:54:06.620
But we'll try to make this available as
a developer example so you can review it.

00:54:08.910 --> 00:54:12.100
You should keep in mind, though,
that this is not to be considered

00:54:12.100 --> 00:54:14.330
as a be-all and end-all of
rules for capitalization.

00:54:14.360 --> 00:54:16.560
This is one specific
set of style manuals.

00:54:16.670 --> 00:54:20.140
Different style manuals have
slightly different notions of

00:54:20.200 --> 00:54:22.080
what should be capitalized.

00:54:28.940 --> 00:54:32.490
So let me summarize.

00:54:32.580 --> 00:54:38.200
The way we want to encourage you to
analyze text is by looking for ranges

00:54:38.200 --> 00:54:43.970
within the text that are of interest and
to deal with the text range by range.

00:54:44.050 --> 00:54:48.630
And the primary method that we make
available for this is block iteration,

00:54:48.870 --> 00:54:54.040
iterating over blocks that
specify ranges of a specific type.

00:54:54.170 --> 00:54:57.590
And we have different types
of block iteration for

00:54:57.590 --> 00:54:59.760
different kinds of analysis.

00:54:59.970 --> 00:55:05.260
The basic analysis provided by NSString,
more sophisticated types provided by

00:55:05.360 --> 00:55:09.470
regular expressions or data detectors,
and the linguistic analysis

00:55:09.470 --> 00:55:15.300
provided by NSLinguisticTagger,
plus text checking at the UI level for

00:55:15.370 --> 00:55:19.610
things like spell checking and so forth.

00:55:21.110 --> 00:55:24.270
And that concludes our
discussion of text analysis.

00:55:24.400 --> 00:55:27.790
For more information,
you can contact our evangelist,

00:55:27.850 --> 00:55:28.440
Bill Dudney.

00:55:28.640 --> 00:55:32.140
There's documentation, developer.avl.com.

00:55:32.210 --> 00:55:35.740
Not all of this probably
has documentation yet.

00:55:36.010 --> 00:55:39.310
Specifically in this linguistic tagger,
I know the documentation

00:55:39.310 --> 00:55:42.000
is under development,
may not be there quite yet.

00:55:42.000 --> 00:55:45.990
You can look at -- I've been
informed that the latest foundation

00:55:45.990 --> 00:55:50.000
release notes have been released
and should be available to you.

00:55:50.000 --> 00:55:57.000
And those include some more
information on all of these APIs.

00:55:59.800 --> 00:56:00.700
and other people.

00:56:00.700 --> 00:56:03.890
Related sessions,
you may have gone to the What's New in

00:56:03.890 --> 00:56:09.230
Cocoa and What's New in Cocoa Touch where
they review things like some of the

00:56:09.230 --> 00:56:11.910
UI implications of some of these things.

00:56:12.090 --> 00:56:16.030
Tomorrow,
there's an internationalization talk

00:56:16.030 --> 00:56:22.190
on making your application ready for
international markets tomorrow at

00:56:22.190 --> 00:56:24.400
10:15 that I encourage you to go to.

00:56:24.400 --> 00:56:24.400
And that concludes the presentation.
WEBVTT

00:00:10.260 --> 00:00:12.900
Well, hello,
and welcome to Advanced HTML5

00:00:12.900 --> 00:00:16.300
Media Controllers for
Safari on iOS and Mac OS X.

00:00:16.300 --> 00:00:18.020
My name is Jer Noble.

00:00:18.020 --> 00:00:20.060
I am a Safari and WebKit engineer.

00:00:20.060 --> 00:00:23.490
And today, we're going to talk about
how to make awesome,

00:00:23.490 --> 00:00:26.780
accessible controls for
your HTML5 media content.

00:00:28.910 --> 00:00:38.010
But first, last year at WWDC,
there were a couple sessions which

00:00:38.010 --> 00:00:38.010
covered the basics of JavaScript controls
for HTML5 video and audio.

00:00:38.520 --> 00:00:42.330
The video for these sessions is
available on Apple's Developer site.

00:00:42.330 --> 00:00:46.130
So if you go to
developer.apple.com/videos,

00:00:46.130 --> 00:00:52.100
clicking on the link to WWDC 2010
session videos will get you this page.

00:00:52.220 --> 00:00:57.770
And the ones you're interested in
are Delivering Audio and Video with

00:00:57.880 --> 00:01:00.570
Web Standards Parts 1 and 2.

00:01:00.720 --> 00:01:03.230
These are great presentations,
if I say so myself.

00:01:03.230 --> 00:01:03.230
I highly recommend checking them out.

00:01:04.490 --> 00:01:09.160
So last year at WWDC was
all about baby steps.

00:01:09.160 --> 00:01:12.900
Everything was very new and very
exciting and just a little bit blurry.

00:01:12.910 --> 00:01:14.760
And a lot of things have
changed in the last year.

00:01:14.900 --> 00:01:17.320
We've added a bunch of new
capabilities to Safari,

00:01:17.320 --> 00:01:20.300
and a lot of things have
changed in the HTML5 standard.

00:01:20.320 --> 00:01:23.150
And we're going to tell
you all about them today.

00:01:23.980 --> 00:01:26.640
But since last year,
we've seen a lot of sites

00:01:26.640 --> 00:01:32.020
adopting HTML5 for delivering
video content to their users,

00:01:32.020 --> 00:01:32.020
which is fantastic.

00:01:32.690 --> 00:01:35.800
But we've also seen a lot of
those same sites only delivering

00:01:35.800 --> 00:01:40.070
HTML5 video to browsers reporting
that they are iPads and iPhones.

00:01:40.080 --> 00:01:43.940
So this has led people to go to
extreme measures to convince websites

00:01:43.940 --> 00:01:46.130
to deliver HTML5 video to them.

00:01:46.140 --> 00:01:48.580
In fact,
so far as to say that there's one

00:01:48.580 --> 00:01:53.550
popular technology blogger who posted a
multi-page recipe about how to do this,

00:01:53.680 --> 00:01:56.080
how to convince websites that
you're browsing from an iPad when

00:01:56.150 --> 00:01:57.690
you're on Safari on the desktop.

00:01:57.700 --> 00:02:00.110
Needless to say,
we don't think user agent

00:02:00.110 --> 00:02:02.060
sniffing is the best of ideas.

00:02:02.280 --> 00:02:03.140
It's fragile.

00:02:03.140 --> 00:02:05.230
Whenever there's a new device,
you have to change all of your

00:02:05.280 --> 00:02:06.720
scripts to parse user agent strings.

00:02:06.720 --> 00:02:08.780
And it doesn't really
detect capabilities.

00:02:08.780 --> 00:02:10.640
It only detects devices.

00:02:10.660 --> 00:02:14.560
So we're going to show you
a better way to do this.

00:02:14.580 --> 00:02:15.680
But why is this happening?

00:02:15.720 --> 00:02:20.560
Well, page authors want controls
that match the look and feel

00:02:20.560 --> 00:02:23.060
of the rest of their website.

00:02:23.080 --> 00:02:27.600
They want controls to work on all
browsers and across all platforms.

00:02:27.600 --> 00:02:31.800
They want controls to do things that the
default controls can't because otherwise,

00:02:32.010 --> 00:02:33.840
You know, why bother?

00:02:34.060 --> 00:02:37.000
And somewhere along the way,
a lot of authors got the idea that this

00:02:37.000 --> 00:02:42.200
is just something you can't do with HTML.

00:02:42.250 --> 00:02:48.390
But today,
we're going to show you how all

00:02:48.390 --> 00:02:48.390
of this and more is possible with
HTML5 and standard web technologies.

00:02:49.010 --> 00:02:51.400
So, what did you learn today?

00:02:51.450 --> 00:02:54.660
We're first going to cover how
to create simple custom controls

00:02:54.780 --> 00:02:57.980
with JavaScript and CSS and HTML5.

00:02:58.540 --> 00:03:06.490
How to make sure those
controls work for everyone,

00:03:06.490 --> 00:03:06.490
no matter what device they're using
or what assistive technologies

00:03:06.490 --> 00:03:06.490
they're using to view your site.

00:03:06.970 --> 00:03:08.240
And finally,
we're going to cover a little

00:03:08.410 --> 00:03:12.400
special effects you can add to your
video elements and your controls.

00:03:13.320 --> 00:03:18.360
But first, getting started,
if you'd seen last year's sessions,

00:03:18.360 --> 00:03:22.660
and you will recognize these when you
go back and watch the video later,

00:03:22.660 --> 00:03:27.050
this is the basic set of API you'll
need to implement a play,

00:03:27.050 --> 00:03:31.180
pause button,
and timeline slider for HTML video.

00:03:31.200 --> 00:03:34.570
So getting started,
every media element has

00:03:34.570 --> 00:03:37.170
a play and a pause event,
somewhat self-explanatory.

00:03:37.260 --> 00:03:42.300
You can also query for a
media element's current time,

00:03:42.450 --> 00:03:44.610
ask for its duration.

00:03:46.270 --> 00:03:47.500
Ask for its duration.

00:03:47.630 --> 00:03:50.130
And then while the
media is changing time,

00:03:50.130 --> 00:03:53.330
it will emit events occasionally,
such as play when the

00:03:53.510 --> 00:03:56.300
user plays your video,
pause when they pause.

00:03:56.540 --> 00:04:02.900
And as the movie is playing
or as the user is scrubbing,

00:04:02.940 --> 00:04:06.160
it'll emit these time update events.

00:04:06.160 --> 00:04:06.160
So how might you use this to make, say,
a general play/pause button?

00:04:06.900 --> 00:04:09.170
If you have a button
and has a click handler,

00:04:09.170 --> 00:04:12.960
all you need to do is check to see if
the movie is paused or if it's ended,

00:04:13.030 --> 00:04:14.080
and if so, play it.

00:04:14.260 --> 00:04:15.330
If not, pause it.

00:04:15.380 --> 00:04:18.810
That's it.

00:04:18.810 --> 00:04:20.110
Just, what is that?

00:04:20.110 --> 00:04:20.110
Five lines of code, including braces.

00:04:21.030 --> 00:04:23.280
And in addition,
if you want to react to the fact that the

00:04:23.280 --> 00:04:26.050
movie is now playing instead of paused,

00:04:26.320 --> 00:04:28.360
Three event listeners for the play,
pause,

00:04:28.360 --> 00:04:37.040
and ended events is all you'll need
to update your button to say something

00:04:37.390 --> 00:04:37.390
different when the user plays the movie,
or when the movie gets to the end of its

00:04:37.390 --> 00:04:37.390
timeline and stops playing on its own.

00:04:38.820 --> 00:04:42.020
Okay, the next thing you might want
to add is a timeline scrubber.

00:04:42.020 --> 00:04:45.180
This is like a slider element that you
can drag back and forth to allow quick,

00:04:45.290 --> 00:04:47.180
rapid access to any point in the video.

00:04:47.180 --> 00:04:51.180
And last year, this was kind of like a
hard problem to solve.

00:04:51.230 --> 00:04:54.340
You had to implement your own slider
to make it work on all browsers.

00:04:54.340 --> 00:05:00.640
However, HTML5 and now Safari on iOS
have this input type of range,

00:05:00.690 --> 00:05:04.430
which will be represented as a slider.

00:05:04.970 --> 00:05:08.480
It's also fully stylable in CSS,
both the thumb and the track.

00:05:08.540 --> 00:05:11.700
So anything you could do before
with your own custom slider,

00:05:11.700 --> 00:05:13.830
you should also be able
to do with this one.

00:05:13.840 --> 00:05:18.040
It has the added benefit of handling
touch events where you might have to

00:05:18.040 --> 00:05:21.300
write custom code to do that if you were
implementing your own timeline slider.

00:05:21.300 --> 00:05:25.680
And it emits just one event
that you'll need to worry about,

00:05:25.680 --> 00:05:27.460
the onChange event.

00:05:27.500 --> 00:05:30.860
And when the timeline slider changes,
because the user's dragging it around,

00:05:30.860 --> 00:05:32.860
set the video's current time.

00:05:33.720 --> 00:05:36.970
And then you can add the slider
to the start time plus-- wait,

00:05:36.970 --> 00:05:37.720
what did I say?

00:05:37.720 --> 00:05:38.020
Yes.

00:05:38.100 --> 00:05:40.440
The value of the slider
times the duration.

00:05:40.680 --> 00:05:43.360
Anyway,
this is actually kind of unnecessary.

00:05:43.440 --> 00:05:47.940
Set the max value to the duration and
set the min value to the start time,

00:05:47.940 --> 00:05:50.390
and all you have to do is pass that
value across to the current time.

00:05:50.900 --> 00:05:52.780
Easy as that.

00:05:54.040 --> 00:05:58.640
And same thing, as the movie's playing,
you're going to want to react to the

00:05:58.940 --> 00:06:03.470
time changing and update your slider,
and listen for the time update event,

00:06:03.520 --> 00:06:06.300
and change the value
of the slider to match.

00:06:06.330 --> 00:06:08.900
And again,
if you set the min and the max to

00:06:08.900 --> 00:06:12.650
the duration and the start time,
it's as easy as just passing

00:06:12.700 --> 00:06:16.180
the movie's current time
into the value of the slider.

00:06:16.180 --> 00:06:17.130
And that's it.

00:06:17.130 --> 00:06:17.130
You have a timeline slider
that works to change the value

00:06:17.130 --> 00:06:17.130
of the time in your movie.

00:06:17.130 --> 00:06:17.130
Easy peasy.

00:06:17.480 --> 00:06:20.530
And like I said earlier,
this range element is now

00:06:20.530 --> 00:06:22.800
supported on mobile Safari on iOS.

00:06:22.800 --> 00:06:23.170
OK.

00:06:23.170 --> 00:06:25.090
Now you've got a play button.

00:06:25.090 --> 00:06:26.900
You have a timeline slider.

00:06:27.100 --> 00:06:29.780
The next thing you might
want to control is volume.

00:06:29.910 --> 00:06:38.390
You have an input range element,
which would easily work for

00:06:38.390 --> 00:06:38.390
a volume slider as well.

00:06:38.390 --> 00:06:38.390
There is a caveat, however.

00:06:38.990 --> 00:06:43.980
On iOS, there is only one volume setting,
and that's the system volume setting.

00:06:43.990 --> 00:06:47.730
And the system volume can't
be changed from JavaScript.

00:06:47.830 --> 00:06:55.420
You probably don't want it to be changed
from JavaScript to have some website

00:06:55.420 --> 00:06:56.810
change your volume to min or max,
and you miss phone calls,

00:06:56.810 --> 00:06:56.810
or you're waking up in
the middle of the night.

00:06:56.810 --> 00:06:56.810
Either way, bad idea.

00:06:57.810 --> 00:07:02.770
So, after I just told you that user agent
sniffing isn't something we endorse,

00:07:02.820 --> 00:07:06.920
now we're back to looking at user agent
strings to not change the volume for iOS.

00:07:06.920 --> 00:07:08.750
I have a better idea.

00:07:10.700 --> 00:07:13.500
So here's your input range element,
just like the last example.

00:07:13.800 --> 00:07:22.750
It has a min and a max,
and as you scrub it, it calls set volume.

00:07:22.750 --> 00:07:22.750
But in this case,
we're going to set the style

00:07:22.750 --> 00:07:22.750
by default to display none.

00:07:23.350 --> 00:07:25.760
And we set up our functions
for changing the volume.

00:07:25.760 --> 00:07:26.880
We add our event listeners.

00:07:26.880 --> 00:07:29.710
And after we're done,
we're going to change the

00:07:29.710 --> 00:07:31.700
video's volume to 0.5.

00:07:31.770 --> 00:07:34.270
On iOS, nothing will happen.

00:07:34.310 --> 00:07:35.970
On the desktop,

00:07:36.180 --> 00:07:38.660
This will actually result
in a volume changed event,

00:07:38.690 --> 00:07:41.540
which at that point will remove
that display none property.

00:07:41.540 --> 00:07:43.250
The volume slider shows up.

00:07:43.380 --> 00:07:44.440
Bob's your uncle.

00:07:44.440 --> 00:07:47.170
You have a slider that does not
appear on iOS where it won't work and

00:07:47.190 --> 00:07:48.770
appears on desktops where it will.

00:07:48.780 --> 00:07:50.520
No need for user agent sniffing.

00:07:50.520 --> 00:07:54.210
So volume slider, timeline slider,
play button.

00:07:54.240 --> 00:08:00.170
You have the basics of a set
of JavaScript video controls.

00:08:00.200 --> 00:08:03.880
But the next thing you might
want is to go into full screen.

00:08:03.960 --> 00:08:05.380
You have some great content.

00:08:05.500 --> 00:08:07.580
You'd love to display it on
the entire screen at once.

00:08:07.580 --> 00:08:09.800
We covered this a little bit last year.

00:08:09.800 --> 00:08:13.900
There are two functions you should
know about for the HTML media element,

00:08:13.920 --> 00:08:16.970
WebKit enter full screen
and WebKit exit full screen.

00:08:16.980 --> 00:08:19.830
We'll take the video into
and out of full screen.

00:08:19.840 --> 00:08:23.260
And when these functions are called,
they'll emit WebKit begin

00:08:23.280 --> 00:08:24.940
full screen and WebKit end.

00:08:24.940 --> 00:08:27.150
So you can react to changes
in the full screen state.

00:08:27.230 --> 00:08:31.500
This works on Safari on iOS,
Safari on the Mac, Safari on Windows.

00:08:31.560 --> 00:08:35.320
And on all these platforms,
we provide great default.

00:08:35.320 --> 00:08:35.480
Connections.

00:08:35.500 --> 00:08:37.080
You can use the default controls
appropriate to the platform.

00:08:37.080 --> 00:08:39.400
On iOS, they're touch sensitive.

00:08:39.400 --> 00:08:41.740
On the desktop, they're just gorgeous.

00:08:41.760 --> 00:08:46.350
And videos on the iPhone will always
play in this full screen mode.

00:08:46.380 --> 00:08:48.260
So, so far.

00:08:49.800 --> 00:08:54.110
It's a great ability to take your
video into fullscreen and show off your

00:08:54.110 --> 00:08:57.610
content on these great monitors we have.

00:08:57.610 --> 00:09:02.770
However, we got a lot of feedback
after last year's session.

00:09:02.790 --> 00:09:07.900
People kept wanting to know,
how do I get these custom controls

00:09:08.010 --> 00:09:10.850
you're talking about into fullscreen?

00:09:10.850 --> 00:09:10.850
And we would say, sorry,
we only take the video into fullscreen.

00:09:10.850 --> 00:09:10.850
We don't take anything else.

00:09:11.320 --> 00:09:16.640
But I'm pleased to announce
that in Safari Online,

00:09:16.640 --> 00:09:23.310
you can now take any
element into fullscreen,

00:09:23.310 --> 00:09:26.170
which will bring that element
and all of its children,

00:09:26.170 --> 00:09:26.170
all of their style, all of their display,
into fullscreen mode.

00:09:28.030 --> 00:09:30.590
And when you're in fullscreen mode,
you have complete DOM access just

00:09:30.670 --> 00:09:32.140
like you did in the in-page mode.

00:09:32.140 --> 00:09:35.650
So you can add children, move children,
change styles, react to events.

00:09:35.650 --> 00:09:38.330
Users can click buttons, slide things.

00:09:38.780 --> 00:09:47.760
All of these controls that you
will have built to make your video

00:09:47.770 --> 00:09:47.800
have a great experience will also
be present in fullscreen mode.

00:09:49.410 --> 00:09:52.430
Now,
the basis of this support in Safari is

00:09:52.430 --> 00:09:54.730
a proposed specification from Mozilla.

00:09:54.790 --> 00:09:58.190
So if you want to read more
about this fullscreen mode

00:09:58.190 --> 00:10:02.740
and the development of it,
check out Mozilla's wiki, the URL here.

00:10:02.940 --> 00:10:08.430
Okay, so every element has a method
called WebKitRequestFullscreen,

00:10:08.570 --> 00:10:12.720
which tells the document, hey,
I want this element to

00:10:12.720 --> 00:10:14.130
go into fullscreen mode.

00:10:14.130 --> 00:10:14.130
This element, all of its children,
all that stuff.

00:10:16.860 --> 00:10:18.950
And the document has a
host of new APIs as well.

00:10:19.080 --> 00:10:22.080
You can check to see what the
current fullscreen element is.

00:10:22.200 --> 00:10:25.360
You can ask whether or not the
document is in fullscreen mode.

00:10:25.430 --> 00:10:28.240
And when you're in fullscreen mode,
you can ask to see whether or

00:10:28.240 --> 00:10:29.800
not keyboard input is allowed.

00:10:29.830 --> 00:10:36.750
And as the web page transitions
into and out of fullscreen state,

00:10:36.760 --> 00:10:38.300
it'll emit this fullscreen change event,
which you can listen to

00:10:38.300 --> 00:10:38.300
to update your controls.

00:10:38.760 --> 00:10:41.140
And at any point,
you can request the document

00:10:41.140 --> 00:10:42.640
cancel out of fullscreen.

00:10:42.700 --> 00:10:45.110
On user press, end of a movie, whatever.

00:10:45.310 --> 00:10:49.050
There are also a couple
of CSS pseudo-classes

00:10:49.060 --> 00:10:51.100
you'll need to know about.

00:10:51.130 --> 00:10:54.800
The first one applies to the element
that is currently fullscreen.

00:10:54.890 --> 00:10:58.120
So you could style it completely
differently when it's in

00:10:58.130 --> 00:11:00.130
fullscreen mode versus not.

00:11:01.590 --> 00:11:09.560
This next pseudo class applies
to the document which contains

00:11:09.640 --> 00:11:13.200
the fullscreen element.

00:11:13.200 --> 00:11:14.610
And between these two things,
you should be able to apply a

00:11:14.610 --> 00:11:14.610
completely separate set of style rules
for your page when in fullscreen mode.

00:11:16.690 --> 00:11:18.550
There are, however,
a couple of requirements

00:11:18.680 --> 00:11:20.380
to using this API.

00:11:20.380 --> 00:11:27.130
The first and biggest is that going into
fullscreen must begin with a user action,

00:11:27.130 --> 00:11:32.470
either a mouse press or a key click,
or key click or mouse press.

00:11:32.850 --> 00:11:39.030
The other requirement is that an iframe,
if it has content that it wants

00:11:39.030 --> 00:11:41.430
to take into fullscreen mode,
must have a WebKitAllowFullscreen

00:11:41.430 --> 00:11:41.430
attribute set.

00:11:42.190 --> 00:11:44.740
But between those two things,
those are the requirements for taking

00:11:44.740 --> 00:11:47.150
something into fullscreen mode.

00:11:47.790 --> 00:11:48.580
So how might this work?

00:11:48.750 --> 00:11:49.620
Well, you have a button.

00:11:49.620 --> 00:11:50.520
It has an event handler.

00:11:50.520 --> 00:11:54.590
First thing you'll do is check to see
if the current fullscreen element is

00:11:54.710 --> 00:11:56.820
the element you want to take fullscreen.

00:11:56.820 --> 00:12:01.050
In that case, cancel out.

00:12:01.180 --> 00:12:06.890
Otherwise, request that element goes in.

00:12:06.890 --> 00:12:06.890
And that's it.

00:12:06.890 --> 00:12:06.890
That's a fullscreen
button in one snippet.

00:12:07.230 --> 00:12:08.870
And additionally,
if you want to react to the

00:12:08.870 --> 00:12:11.920
fact that the user has gone
into and out of fullscreen mode,

00:12:11.990 --> 00:12:15.600
just listen for the WebKit fullscreen
change event and check to see what

00:12:15.610 --> 00:12:17.700
happened and react accordingly.

00:12:19.990 --> 00:12:23.650
However, this is available right
now only on Safari Online.

00:12:23.650 --> 00:12:27.100
So you'll want to fall back to
a different fullscreen mode,

00:12:27.160 --> 00:12:30.770
perhaps, on platforms that don't
support this new API.

00:12:30.810 --> 00:12:34.760
So to do so is as easy as
checking to see if your element

00:12:34.760 --> 00:12:37.380
has a WebKit fullscreen method.

00:12:37.380 --> 00:12:40.180
And if so, use the new API.

00:12:40.180 --> 00:12:43.660
If not, fall back to a different
browser-specific fullscreen mode,

00:12:43.660 --> 00:12:45.850
or perhaps an in-window,
full-window mode.

00:12:45.900 --> 00:12:48.670
There are some caveats, however,
like there always are.

00:12:49.720 --> 00:12:51.260
This spec is an act of development.

00:12:51.260 --> 00:12:54.710
It is just a proposal,
and though we've implemented

00:12:54.720 --> 00:12:58.310
it here in Safari,
it's likely to change in the future.

00:12:58.320 --> 00:13:00.250
So you should keep this in mind.

00:13:00.260 --> 00:13:04.700
Also, when entering into fullscreen mode,
we disable most keyboard input.

00:13:04.720 --> 00:13:07.420
For security reasons,
we don't allow the users

00:13:07.420 --> 00:13:10.870
to press alphanumeric keys
when they're in fullscreen.

00:13:10.880 --> 00:13:15.600
You still have command keys, arrow keys,
spacebar, other things you might need to

00:13:15.600 --> 00:13:19.540
implement some kind of run-and-shoot
video game in fullscreen mode.

00:13:19.540 --> 00:13:23.000
but alphanumeric keys are disallowed.

00:13:23.880 --> 00:13:31.230
And also, if for some reason your
fullscreen request is rejected,

00:13:31.410 --> 00:13:37.220
there is no error or event
that is thrown in response.

00:13:37.220 --> 00:13:39.470
But with the information
we've given you here today,

00:13:39.470 --> 00:13:39.470
you should be able to accurately
know when your fullscreen request

00:13:39.470 --> 00:13:39.470
will be acted on or denied.

00:13:40.610 --> 00:13:43.940
So, to demo this and everything
we've talked about so far,

00:13:43.940 --> 00:13:48.140
I'd like to invite Eric up to show
you how this works in practice.

00:13:48.140 --> 00:13:56.270
So, what we have here is a basic video
player using exactly the code

00:13:56.400 --> 00:13:59.500
that Jer just walked you through.

00:13:59.500 --> 00:13:59.500
You press the play button,
it begins to play.

00:14:00.380 --> 00:14:05.410
We don't have any volume,
but I guess we don't need it right now.

00:14:05.880 --> 00:14:08.210
You can drag the slider.

00:14:08.430 --> 00:14:15.010
Again, this is an input type of range,
as you can probably see,

00:14:15.010 --> 00:14:17.770
because we didn't change
the style very much.

00:14:17.910 --> 00:14:20.900
There's a simple button
to mute and unmute.

00:14:21.390 --> 00:14:29.670
You can see the volume change
events are being fired there.

00:14:29.670 --> 00:14:38.810
So here we have a basic-- well,
actually not a basic controller,

00:14:38.810 --> 00:14:46.700
a full-featured controller using just a
little bit of code that Jer showed you.

00:14:46.700 --> 00:14:46.700
OK.

00:14:47.990 --> 00:14:52.070
The next thing you'll want to worry
about after you've made your own

00:14:52.110 --> 00:14:55.060
custom controls is accessibility.

00:14:56.450 --> 00:14:58.580
So why?

00:14:58.890 --> 00:15:03.110
First things first,
you'll want to maximize your audience.

00:15:03.180 --> 00:15:08.160
And this is something that actually
I heard during a Google I/O presentation,

00:15:08.160 --> 00:15:12.120
that the number of internet users
in the United States using an

00:15:12.120 --> 00:15:16.540
assistive browsing device when
browsing the web is a larger number,

00:15:16.540 --> 00:15:19.370
larger in population,
than the entire online

00:15:19.600 --> 00:15:21.410
population of Canada.

00:15:21.500 --> 00:15:24.430
So the number of people out
there who need to be able to

00:15:24.430 --> 00:15:28.340
have an accessible experience
with browsing your site is huge.

00:15:28.450 --> 00:15:29.960
So it's something to keep in mind.

00:15:30.020 --> 00:15:34.590
Also, you may be under some kind of legal
requirement to have your site be

00:15:34.590 --> 00:15:37.350
accessible for a variety of reasons.

00:15:37.770 --> 00:15:40.780
But finally,
it's just the right thing to do.

00:15:40.780 --> 00:15:44.180
Denying a large group of
people access to your site,

00:15:44.180 --> 00:15:47.420
you want to let as many
people in as possible.

00:15:48.880 --> 00:15:52.010
So, first thing to consider,
we're going to briefly cover this,

00:15:52.010 --> 00:15:52.820
touch events.

00:15:52.820 --> 00:15:55.250
There's a lot of people
here with iPads and iPhones,

00:15:55.330 --> 00:15:58.000
and none of those iPads
and iPhones has a mouse.

00:15:58.000 --> 00:16:02.510
So, anytime you're developing a
custom JavaScript controller,

00:16:02.510 --> 00:16:05.240
you need to worry about touch events.

00:16:05.240 --> 00:16:10.400
So, generally mapping, touch start,
mouse down, touch end, mouse up.

00:16:10.460 --> 00:16:12.520
Touch move, mouse move,
and there's really no

00:16:12.520 --> 00:16:15.190
corollary to touch cancel,
but if something interrupts your

00:16:15.190 --> 00:16:18.350
user in the middle of a gesture,
you want to handle that one as well.

00:16:18.800 --> 00:16:24.660
And if you're doing super advanced things
with gestures in your video player,

00:16:24.660 --> 00:16:27.300
you might want to use gesture start,
change, and end,

00:16:27.300 --> 00:16:30.760
which are fired when the user uses
more than one finger in a gesture.

00:16:30.760 --> 00:16:33.920
So, if you want to have a volume knob
that the user actually rotates,

00:16:33.920 --> 00:16:35.580
this is what you're looking for.

00:16:35.580 --> 00:16:38.010
Okay, put that out of the way.

00:16:39.570 --> 00:16:42.110
There's another thing
you'll want to know about,

00:16:42.380 --> 00:16:49.110
and that's VoiceOver.

00:16:49.110 --> 00:16:50.950
Now, VoiceOver is a screen reader that's
built into both iOS and Mac OS X.

00:16:51.450 --> 00:16:54.860
And support for VoiceOver is
also built into Safari.

00:16:54.900 --> 00:16:58.990
And this support is based on the
Accessible Rich Internet Applications,

00:16:58.990 --> 00:17:01.030
or ARIA, specification.

00:17:01.140 --> 00:17:02.320
So what does this look like?

00:17:02.320 --> 00:17:05.540
Well, first,
here's a non-accessible set of controls.

00:17:05.600 --> 00:17:07.890
You have a div here that
when the user clicks on it,

00:17:08.010 --> 00:17:09.150
plays and pauses the movie.

00:17:09.340 --> 00:17:11.920
Maybe it even changes state and
says pause when it's playing

00:17:11.920 --> 00:17:13.920
and playing when it's paused.

00:17:14.030 --> 00:17:18.100
You also have a div which represents the
progress through the video as a width.

00:17:18.200 --> 00:17:22.060
So, so far, great,
except when VoiceOver sees this content,

00:17:22.120 --> 00:17:25.440
it has no way to know that this
is a play and pause button.

00:17:25.710 --> 00:17:30.010
It has no way to know that this
is a progress meter underneath it.

00:17:30.140 --> 00:17:36.080
So how do we let assistive devices like
VoiceOver know more about our controls?

00:17:36.390 --> 00:17:39.140
Turns out it's really easy.

00:17:39.670 --> 00:17:44.060
For the button, you would add something
called a role attribute and

00:17:44.230 --> 00:17:47.300
set the attribute to button.

00:17:47.300 --> 00:17:53.980
And after that, as the screen reader is
browsing through your DOM,

00:17:54.210 --> 00:17:55.720
it sees that.

00:17:55.720 --> 00:17:57.070
Notice it's the button.

00:17:57.070 --> 00:17:57.070
And now it can allow the user to
navigate through your controls,

00:17:57.070 --> 00:17:57.070
interact with them without using a mouse.

00:17:57.720 --> 00:18:00.580
Again, with the progress meter,
set the role to progress bar,

00:18:00.660 --> 00:18:03.640
and it knows that is a progress
bar and can relay that information

00:18:03.640 --> 00:18:05.560
back to the user through voiceover.

00:18:08.370 --> 00:18:11.520
More roles are available,
such as application and slider.

00:18:11.600 --> 00:18:15.130
And for all of these roles and the
values that are attached to them,

00:18:15.130 --> 00:18:17.790
please take a look at the
ARIA specification found

00:18:17.790 --> 00:18:19.430
at the W3C's website.

00:18:22.600 --> 00:18:26.310
So, to demonstrate the accessibility
features of Safari and how you would

00:18:26.360 --> 00:18:29.160
build it into your custom controller,
I'm going to ask Eric to come

00:18:29.160 --> 00:18:30.490
up and give you a short demo.

00:18:30.870 --> 00:18:35.930
What we have here is your
same basic controller.

00:18:36.030 --> 00:18:38.320
We can see we can start it.

00:18:38.390 --> 00:18:39.920
We can stop it.

00:18:39.950 --> 00:18:41.430
We can scrub.

00:18:41.430 --> 00:18:46.030
But let's see what a user of
VoiceOver experiences when they

00:18:46.030 --> 00:18:48.500
interact with the same page.

00:18:48.500 --> 00:18:51.540
VoiceOver on Safari, custom controller.

00:18:51.540 --> 00:18:54.180
So we'll turn on VoiceOver.

00:18:54.180 --> 00:18:56.540
Let me turn it down a little bit.

00:18:56.560 --> 00:18:58.540
And we'll navigate down into the page.

00:18:58.540 --> 00:19:02.580
And VoiceOver sees that
we have an element here.

00:19:02.740 --> 00:19:04.140
It knows it's called play.

00:19:04.140 --> 00:19:07.040
You are currently on a text
element inside of HTML content.

00:19:07.120 --> 00:19:08.830
But it sees it as a text element.

00:19:08.900 --> 00:19:10.730
So it knows that it's an element.

00:19:10.750 --> 00:19:15.130
It knows it has -- well,
it says that it's a play element.

00:19:15.160 --> 00:19:20.900
But when we try to interact with it with
the VoiceOver keyboard gesture -- Slider,

00:19:20.960 --> 00:19:21.240
Fs.

00:19:21.320 --> 00:19:25.340
It doesn't know anything about it.

00:19:25.370 --> 00:19:27.950
We'll go back to it.

00:19:30.380 --> 00:19:38.820
So a user who's using VoiceOver doesn't
have any way to interact with it.

00:19:38.820 --> 00:19:46.420
Here it sees that we have a slider,
and we can interact with it.

00:19:46.420 --> 00:19:53.390
But again, VoiceOver doesn't know
how it's being used.

00:19:53.730 --> 00:20:03.700
So while the user can interact with it,
if they can't see the screen,

00:20:03.700 --> 00:20:07.740
they aren't actually able
to do anything with it.

00:20:07.740 --> 00:20:11.700
So let's go in here.

00:20:13.180 --> 00:20:15.960
And fix this up.

00:20:16.010 --> 00:20:18.920
As Jer said,
telling VoiceOver that these things

00:20:18.920 --> 00:20:24.160
are buttons is as easy as adding
role equals button to the div.

00:20:24.160 --> 00:20:26.860
So let's save it.

00:20:26.930 --> 00:20:28.710
We'll go back.

00:20:29.870 --> 00:20:32.280
Reload our page.

00:20:32.340 --> 00:20:33.530
Turn VoiceOver back on.

00:20:33.540 --> 00:20:35.000
VoiceOver on Safari.

00:20:35.000 --> 00:20:36.540
Interact with HTML content.

00:20:36.540 --> 00:20:37.200
Interact with button.

00:20:37.200 --> 00:20:38.670
Now, it sees that it's a button.

00:20:38.680 --> 00:20:40.060
Press button.

00:20:40.060 --> 00:20:44.940
And, in fact, from the keyboard,
I can turn it on and off.

00:20:44.960 --> 00:20:45.960
Press button.

00:20:45.960 --> 00:20:58.360
But you can see that while
we're changing the title,

00:20:59.340 --> 00:21:08.170
when VoiceOver pushes the button,
VoiceOver isn't announcing it,

00:21:08.420 --> 00:21:09.880
because now it's a button.

00:21:09.880 --> 00:21:12.690
And so it's not reading the...

00:21:14.460 --> 00:21:20.260
"It's not reading the content,
but luckily that's also easy to fix.

00:21:20.650 --> 00:21:22.170
We'll just give it a title."

00:21:24.130 --> 00:21:34.270
So we can say title equals play.

00:21:34.270 --> 00:21:34.270
Let's give all our elements titles.

00:21:34.520 --> 00:21:35.600
Timeline.

00:21:35.600 --> 00:21:39.520
All right, so let's turn on voiceover
and see if it actually works.

00:21:41.000 --> 00:21:45.370
VoiceOver on Safari, Custom Controller,
and Play button.

00:21:48.480 --> 00:21:48.480
Okay, let's interact with the page.

00:21:48.480 --> 00:21:48.480
Okay,
now it sees that it's a play button.

00:21:49.300 --> 00:22:26.200
[Transcript missing]

00:22:26.560 --> 00:22:32.810
We changed that state by,
in the JavaScript,

00:22:32.900 --> 00:22:40.270
when we get a playing event,
we change the class name,

00:22:40.300 --> 00:22:45.160
which makes CSS change its title.

00:22:45.230 --> 00:22:49.700
So we'll do the same thing here.

00:22:49.700 --> 00:22:55.490
When we get the play and pause,
load it again.

00:22:57.290 --> 00:22:59.980
Turn on voiceover.

00:22:59.980 --> 00:23:00.760
Voice over on.

00:23:00.760 --> 00:23:01.630
Interact with HTML.

00:23:01.640 --> 00:23:02.140
So now.

00:23:02.190 --> 00:23:03.880
Interact with press play button.

00:23:03.890 --> 00:23:06.540
So when we go off it.

00:23:06.780 --> 00:23:10.460
timeline slide pause button now it sees
it's a play button it sees it's play

00:23:10.460 --> 00:23:16.280
button press pause button so that works
well press play button timeline slide

00:23:16.920 --> 00:23:23.840
interact with slider we while we can we
can control it again voiceover doesn't

00:23:23.840 --> 00:23:30.460
know stop pause press pause button
play button voiceover off so there's

00:23:30.460 --> 00:23:37.430
one more thing that we should do and
we will add an aria attribute to the

00:23:39.200 --> 00:23:57.430
Slider.

00:23:57.430 --> 00:23:57.430
Whenever the time changes,
set the ARIA value as text to

00:23:57.430 --> 00:23:57.430
the current time as a string,
which, again, lets ARIA know more

00:23:57.430 --> 00:23:57.430
information about that slider.

00:23:57.430 --> 00:23:57.430
Reload our page.

00:24:00.800 --> 00:24:01.800
VoiceOver Back On.

00:24:01.800 --> 00:24:04.180
VoiceOver On Safari, play button.

00:24:04.180 --> 00:24:05.800
Press play button.

00:24:05.840 --> 00:24:06.800
And now.

00:24:06.800 --> 00:24:08.800
0.6 seconds, timeline slider.

00:24:08.890 --> 00:24:09.790
Interact with slider.

00:24:09.790 --> 00:24:10.800
4.6 seconds.

00:24:10.800 --> 00:24:11.800
So now.

00:24:11.800 --> 00:24:13.800
6.0 seconds, pause button.

00:24:13.800 --> 00:24:14.800
Press pause button.

00:24:14.810 --> 00:24:18.540
So with just a little
bit of extra markup,

00:24:19.080 --> 00:24:22.720
we've -- You are currently on the
button inside of HTML content.

00:24:23.020 --> 00:24:23.800
VoiceOver Off.

00:24:23.810 --> 00:24:27.800
Thank you, VoiceOver.

00:24:27.800 --> 00:24:27.800
So, you know, I mean,

00:24:27.860 --> 00:24:31.240
It's sort of a laugh for
us because we can see it,

00:24:31.240 --> 00:24:36.020
but somebody that is trying to
interact with your media content,

00:24:36.020 --> 00:24:38.120
they can get a lot out of it.

00:24:38.240 --> 00:24:42.680
By implementing a custom controller,
you lose all of the accessibility

00:24:42.680 --> 00:24:47.180
that's built into the default controls,
which are fully accessible.

00:24:48.550 --> 00:24:51.940
And so you can see that just by adding a
little bit of extra markup and a little

00:24:51.940 --> 00:24:57.560
bit of extra logic to your JavaScript,
you're able to restore the full

00:24:58.050 --> 00:25:02.400
functionality of your media controller.

00:25:03.320 --> 00:25:10.190
There are similar ARIA attributes
that you can and should add to the

00:25:10.190 --> 00:25:17.400
rest of your page to make the other
custom UI and markup accessible.

00:25:18.500 --> 00:25:20.590
Thank you.

00:25:21.500 --> 00:25:23.850
Okay, back to slides.

00:25:25.010 --> 00:25:37.180
Okay, so now you have a fully accessible
custom set of controls for

00:25:37.180 --> 00:25:38.560
your HTML5 media content.

00:25:38.560 --> 00:25:38.560
But there's something else you can add,
and that's subtitles.

00:25:41.110 --> 00:25:45.600
So this is an area of active work
within the World Wide Web Consortium.

00:25:45.730 --> 00:25:49.140
And on this front today,
we have good news.

00:25:49.140 --> 00:25:54.240
And that news is what working
group has decided on a file format.

00:25:55.140 --> 00:25:55.990
There you go.

00:25:56.080 --> 00:25:56.620
Okay.

00:25:56.620 --> 00:25:59.860
The file format they are
proposing is called WebVTT.

00:25:59.860 --> 00:26:09.950
It's based on the SRT file format,
and for detailed instructions

00:26:09.950 --> 00:26:11.700
about the format they've chosen,
check out the What Working Groups

00:26:11.700 --> 00:26:11.700
website at whatwg.org.

00:26:11.860 --> 00:26:15.590
Concurrently,
the W3C has been working on the rendering

00:26:15.640 --> 00:26:19.090
of text tracks into your video content.

00:26:19.470 --> 00:26:22.220
And one works really well with the other.

00:26:22.300 --> 00:26:27.590
You have WebVTT to load subtitles
into your video element.

00:26:28.250 --> 00:26:29.240
Here's the catch.

00:26:29.500 --> 00:26:33.440
No browser yet supports WebVTT in
specific and time text in general.

00:26:33.770 --> 00:26:37.240
There's a lot of work in
WebKit to enable this,

00:26:37.240 --> 00:26:40.610
but no shipping browser supports it.

00:26:42.300 --> 00:27:45.800
[Transcript missing]

00:27:46.050 --> 00:27:47.320
You add some track elements.

00:27:47.320 --> 00:27:49.920
In this case,
we're going to add two track elements,

00:27:49.920 --> 00:27:53.050
an English and a Spanish subtitle track.

00:27:53.320 --> 00:27:58.080
They have a kind, a source,
just like a source on a video element,

00:27:58.080 --> 00:28:01.700
a source language,
and a user visible label.

00:28:02.440 --> 00:28:02.880
And that's it.

00:28:02.980 --> 00:28:06.160
That's what you need to get your
subtitles overlaid on your video.

00:28:06.160 --> 00:28:09.030
So what does the API look like, though,
if you're doing this from code?

00:28:09.040 --> 00:28:11.020
Well,
a given text track will have a kind.

00:28:11.080 --> 00:28:14.970
And that kind can be,
according to the spec, subtitles,

00:28:15.140 --> 00:28:19.060
captions,
descriptions for descriptive audio,

00:28:19.150 --> 00:28:24.000
chapters for chapter-based navigation,
and a generic one called metadata,

00:28:24.000 --> 00:28:26.580
which is not meant to be displayed,
but is very useful if you're

00:28:26.580 --> 00:28:29.300
writing your own custom scripts.

00:28:29.660 --> 00:28:32.960
There's a user-visible label
for things like chapter one,

00:28:32.960 --> 00:28:36.020
the language of the track,
perhaps the kind, in this case,

00:28:36.020 --> 00:28:37.420
director's commentary.

00:28:37.420 --> 00:28:45.520
There's a language string,
which is some ISO code that can be

00:28:45.520 --> 00:28:50.230
anywhere from an EN to the type of
German spoken Austria to the type

00:28:50.230 --> 00:28:50.230
of Spanish spoken in Latin America.

00:28:50.710 --> 00:28:53.550
The track will have a ready state,
which lets you know whether or not

00:28:53.550 --> 00:28:56.500
the resources backing that track
have been completely loaded yet.

00:28:58.550 --> 00:29:03.560
and a mode so you can switch these tracks
on and off at will from JavaScript.

00:29:03.560 --> 00:29:05.990
Additionally,
they have two sets of arrays,

00:29:05.990 --> 00:29:09.710
one set of cues that is all
the cues that are in the track,

00:29:09.780 --> 00:29:13.960
and a second array of those
cues which are currently active,

00:29:13.960 --> 00:29:20.290
meaning their start times and end times
enclose the current time of the movie.

00:29:20.450 --> 00:29:23.710
And when this list of
active cues changes,

00:29:23.960 --> 00:29:27.560
the track element will emit a cue
change event you can listen to for

00:29:27.560 --> 00:29:30.050
doing your own custom scripting.

00:29:31.960 --> 00:29:34.940
Okay, like I said,
there are a couple of arrays of queues,

00:29:34.960 --> 00:29:36.740
and those queues have an
API of their very own.

00:29:36.760 --> 00:29:40.180
First, they all have a back pointer
to the track which owns them.

00:29:40.180 --> 00:29:43.900
They have a unique ID that lets
you target each queue individually,

00:29:43.900 --> 00:29:44.860
if you so desire.

00:29:44.860 --> 00:29:48.080
It has a start time, like I said,
and an end time,

00:29:48.080 --> 00:29:52.560
which defines those areas,
which those areas of the timeline

00:29:52.560 --> 00:29:53.980
in which that track will be active.

00:29:53.980 --> 00:29:57.300
There's also a property
called pauseOnExit.

00:29:57.300 --> 00:30:00.370
So if a queue has
pauseOnExit set to true,

00:30:00.880 --> 00:30:04.610
and the movie, while it's playing back,
hits the end time of that track,

00:30:04.670 --> 00:30:05.560
the movie will pause.

00:30:05.560 --> 00:30:08.760
And the reason for this
is so you can do accurate,

00:30:08.760 --> 00:30:12.700
very accurate pausing at
certain times of your movie.

00:30:12.720 --> 00:30:15.280
So if you need, for some reason,
the movie to stop at

00:30:15.340 --> 00:30:17.980
a very specific time,
this is what you'd use it for.

00:30:19.410 --> 00:30:25.150
As they become active and inactive,
they will emit a enter and exit event.

00:30:25.870 --> 00:30:30.730
And you can always ask a queue for its
raw source with get queue as source,

00:30:30.820 --> 00:30:36.990
or you can get a document fragment back
of parsed HTML from get queue as HTML.

00:30:37.970 --> 00:30:40.750
Finally,
if you want to implement your own parser,

00:30:40.750 --> 00:30:43.930
if you don't like the web VTT format,
you have a lot of things

00:30:43.960 --> 00:30:47.660
that are in time text,
you can make these tracks up from scratch

00:30:47.730 --> 00:30:52.020
with a mutable text track by adding cues
in one at a time that you've made from

00:30:52.020 --> 00:30:54.430
parsing out a file of your very own.

00:30:54.440 --> 00:30:57.260
Okay, but we talked a lot about captions.

00:30:57.260 --> 00:31:00.180
This is the header of my first slide.

00:31:00.340 --> 00:31:02.240
But this isn't all about captions,
of course.

00:31:02.240 --> 00:31:04.250
It's about time text in general.

00:31:04.880 --> 00:31:07.250
And in specific,
it's about any text that has

00:31:07.290 --> 00:31:08.950
to occur at a specific time.

00:31:08.960 --> 00:31:13.330
Also, video is not easily searchable.

00:31:13.340 --> 00:31:16.760
When Google spiders your website,
it's not going to look through and

00:31:16.760 --> 00:31:19.790
do a speech-to-text transform on
all the tracks in your movie to

00:31:19.790 --> 00:31:23.570
get backlinks and allow people who
are searching for a specific phrase

00:31:23.570 --> 00:31:25.170
to go be directed to your website.

00:31:25.580 --> 00:31:27.880
However,
they will spider your text tracks.

00:31:29.420 --> 00:31:37.870
And so if you want to pull
people into your website,

00:31:37.870 --> 00:31:37.870
this is a great way to do it.

00:31:37.870 --> 00:31:37.870
Add subtitles to all of your videos.

00:31:38.180 --> 00:31:46.030
Also, translating your videos in
different languages is pretty hard.

00:31:46.030 --> 00:31:48.590
You have to find a voice actor,
and we know how hard it is

00:31:48.590 --> 00:31:48.590
to work with those guys.

00:31:49.000 --> 00:31:50.670
I have some voice actor friends.

00:31:50.670 --> 00:31:53.250
They'll get the joke when
they listen to this later.

00:31:53.260 --> 00:31:53.760
Anyway.

00:31:53.770 --> 00:31:56.710
But text tracks are inherently
machine translatable.

00:31:56.710 --> 00:32:00.770
You can just drop one into Google,
and it'll spit one out in

00:32:00.770 --> 00:32:03.090
whatever language you ask for.

00:32:03.150 --> 00:32:07.030
And so you can broaden your
audience to speakers of many,

00:32:07.310 --> 00:32:11.740
many other languages just by adding
a few text tracks to your video,

00:32:11.760 --> 00:32:14.270
and then translating them with
Google or any other translation

00:32:14.270 --> 00:32:14.270
tool into a plethora of languages.

00:32:15.070 --> 00:32:18.430
And finally,
text tracks are all about timing.

00:32:18.570 --> 00:32:22.660
If you want an event to happen
at a specific time in a movie,

00:32:22.660 --> 00:32:25.300
text tracks are what you'll need.

00:32:27.660 --> 00:32:32.490
And to demo the use of text tracks and
subtitles with this polyfill library,

00:32:32.490 --> 00:32:34.570
Eric's going to give you a short demo.

00:32:34.750 --> 00:32:39.100
What we have here is an
extremely boring demo.

00:32:39.100 --> 00:32:41.090
It's a video element.

00:32:41.090 --> 00:32:45.000
Actually, let's look at the source first.

00:32:47.010 --> 00:32:52.500
"Let's make this bigger
so people can see it."

00:32:54.150 --> 00:32:57.810
So we've got a very plain page.

00:32:57.900 --> 00:33:00.100
We've got a video element.

00:33:00.180 --> 00:33:05.480
Just like in the slide,
a pair of source elements pointing

00:33:05.480 --> 00:33:11.030
to two alternate video encodings
and a single track element.

00:33:11.360 --> 00:33:19.180
Again, we have captions in this,
so we have kind equals,

00:33:19.340 --> 00:33:20.290
"Kind equals captions.

00:33:20.340 --> 00:33:21.960
We point to the VTT file.

00:33:22.010 --> 00:33:25.810
It's in English,
so we label it as English.

00:33:26.040 --> 00:33:37.460
And then we also include,
because this version of Safari doesn't

00:33:37.940 --> 00:33:40.160
support the track element natively,
we include a reference to the

00:33:40.640 --> 00:33:46.700
Captionator, JavaScript Library.

00:33:46.700 --> 00:33:46.700
And then when the body loads, we...

00:33:47.440 --> 00:33:54.400
"And what we end up with is captions.

00:33:54.400 --> 00:34:01.400
And suddenly we have all of the benefits
that Jer was just talking about.

00:34:01.400 --> 00:34:07.310
Something that he didn't talk about
and that we're not going to do here

00:34:07.380 --> 00:34:11.950
because it would be a bit to set
up is we could also mark up this

00:34:12.060 --> 00:34:16.060
page so that VoiceOver automatically
reads out the captions.

00:34:16.060 --> 00:34:21.660
Now, it obviously wouldn't make
sense for a page playing in

00:34:21.660 --> 00:34:23.750
English with English captions

00:34:24.160 --> 00:34:27.680
Captions to be read out,
but if they were in a different

00:34:27.680 --> 00:34:31.440
language or if they were a
different type of text track,

00:34:31.440 --> 00:34:35.870
we could easily hook it up so that
VoiceOver would read those out.

00:34:36.160 --> 00:34:38.520
And we didn't have to do anything.

00:34:38.520 --> 00:34:43.840
We're using HTML5 standard markup.

00:34:43.900 --> 00:34:46.780
It's not supported in
this version of Safari.

00:34:46.800 --> 00:34:50.070
In fact, it's not supported in
any shipping browser,

00:34:50.180 --> 00:34:52.210
but you can begin to use it now.

00:34:52.220 --> 00:34:58.360
And this JavaScript library is
written in such a way that when this

00:34:58.360 --> 00:35:03.260
same page gets loaded in a browser
that does have native support,

00:35:03.260 --> 00:35:08.660
it will just back out of the way and
let the native support take over.

00:35:08.660 --> 00:35:12.160
So you can start to use
this really exciting,

00:35:12.160 --> 00:35:17.330
I think, new HTML5 feature in
currently shipping browsers.

00:35:19.690 --> 00:35:27.070
-Jer, I have a couple of demos
to show you myself.

00:35:27.150 --> 00:35:32.330
So I promised you a
couple of flashy things,

00:35:32.330 --> 00:35:32.330
and so we're going to make some of
these demos you'd seen previously

00:35:32.330 --> 00:35:32.330
a little bit more flashy.

00:35:32.330 --> 00:35:32.330
First of all,

00:35:32.760 --> 00:35:36.750
So these controls are very similar
to the controls in the first demo.

00:35:36.750 --> 00:35:40.440
But one thing we've done was
replaced all the buttons with SVG.

00:35:40.650 --> 00:35:43.980
And so as we zoom in,
the element looks just as

00:35:43.980 --> 00:35:48.110
good at this zoom level as
it does in the original one.

00:35:48.110 --> 00:35:52.800
And so using SVG for things like
icons is a great way to make sure

00:35:52.800 --> 00:35:57.750
that your controls look great on
every platform and whatever zoom

00:35:57.750 --> 00:36:00.630
level your user is currently using.

00:36:00.630 --> 00:36:00.690
So that's one thing.

00:36:00.950 --> 00:36:04.070
I just wanted to demonstrate
that the sliders are incredibly

00:36:04.070 --> 00:36:05.980
easily stylable in CSS.

00:36:06.110 --> 00:36:09.760
So we've replaced the circular
thumb with a square one that

00:36:09.760 --> 00:36:11.900
changes colors as you drag it.

00:36:11.900 --> 00:36:14.870
One more thing you can add to
spice up your video controls.

00:36:14.900 --> 00:36:18.820
So here's your mute button
and your volume slider,

00:36:18.990 --> 00:36:21.890
and when I reload the page,

00:36:22.400 --> 00:37:10.100
[Transcript missing]

00:37:12.750 --> 00:37:14.980
And finally,
that's what it should look like.

00:37:15.130 --> 00:37:18.320
So here we have, in fullscreen mode,
we have our own custom

00:37:18.320 --> 00:37:20.250
controls along the bottom.

00:37:20.420 --> 00:37:22.740
That we can bring into
fullscreen mode with us.

00:37:22.750 --> 00:37:27.520
OK, so that's the fancy controls demo.

00:37:27.610 --> 00:37:31.040
But we said a lot of
things about text tracks.

00:37:31.120 --> 00:37:34.510
And one of the key features of
text tracks is chapter support.

00:37:34.600 --> 00:37:37.760
So if we have a video here and you want
to easily navigate between chapters,

00:37:37.760 --> 00:37:41.140
it's as easy as adding a select
element with a bunch of options in it.

00:37:41.250 --> 00:37:44.420
You pull from the chapter file.

00:37:45.300 --> 00:37:48.010
To let your users easily
navigate around your video.

00:37:48.020 --> 00:37:52.240
And the best part is,
does this machine have a simulator?

00:37:52.240 --> 00:37:56.000
Yes, it does.

00:37:59.150 --> 00:38:06.200
So if your user is using a-- oop--
spinning beach ball of death,

00:38:06.200 --> 00:38:06.200
then--

00:38:07.240 --> 00:38:12.580
Let's change this to an iPad,
and we'll rotate it so we

00:38:12.580 --> 00:38:15.080
get more screen real estate.

00:38:15.170 --> 00:38:16.910
Drop this guy on it.

00:38:20.970 --> 00:38:24.420
And when you use this tool
to do chapter navigation,

00:38:24.420 --> 00:38:29.380
you get platform-specific interface
to pick and choose chapters without

00:38:29.380 --> 00:38:31.710
you having to do any extra work.

00:38:33.130 --> 00:38:33.430
OK.

00:38:33.540 --> 00:38:35.860
So that's that demo.

00:38:35.910 --> 00:38:36.580
What more can we add?

00:38:36.670 --> 00:38:37.940
Well, we have chapters.

00:38:38.000 --> 00:38:40.240
Let's add some subtitles and show
you how to switch between them.

00:38:40.260 --> 00:38:43.560
So here's that same demo,
except now we also are able to switch

00:38:44.050 --> 00:38:47.310
between different subtitle formats.

00:38:47.560 --> 00:38:51.750
Because it's just normal HTML content,
we're able to completely style

00:38:51.780 --> 00:38:54.670
differently the representation
of those subtitles.

00:38:54.690 --> 00:38:57.050
In this case,
we gave it a bit of a drop shadow and

00:38:57.050 --> 00:39:00.280
a background color that didn't take
up the whole width of the screen.

00:39:00.280 --> 00:39:04.080
It's hard to see how something so simple,
so thin, so fly-- And we can switch

00:39:04.140 --> 00:39:06.310
between them on the fly.

00:39:06.370 --> 00:39:09.680
And because it's just HTML content,
it supports all the UTF character

00:39:09.700 --> 00:39:11.600
sets that normal HTML content would.

00:39:11.600 --> 00:39:15.070
--we learned so much from it and
developed so many amazing technologies

00:39:15.070 --> 00:39:17.590
and all the applications-- Go back.

00:39:19.000 --> 00:39:24.010
So finally, this is the real flashy demo.

00:39:24.270 --> 00:39:28.280
We talked about how you can choose
between subtitles and chapters and

00:39:28.280 --> 00:39:32.490
captions and audio descriptions
and something called metadata.

00:39:32.580 --> 00:39:35.660
So metadata is anything that isn't
covered by those top ones and anything

00:39:35.660 --> 00:39:37.000
you'd want to use in your script.

00:39:37.170 --> 00:39:43.920
So what we did is we took a file
and filled it with Base64-encoded

00:39:43.920 --> 00:39:45.760
keyframes from this movie.

00:39:45.870 --> 00:39:48.810
And now that we have that file,
just in the same way that subtitles

00:39:48.880 --> 00:39:52.360
will pop up and disappear as
you navigate through the movie,

00:39:52.420 --> 00:39:56.960
we can implement a timeline slider
that shows you where in the movie

00:39:56.960 --> 00:39:58.610
you will be as you scrub around.

00:39:58.830 --> 00:40:02.100
And so if you have a really long movie,
one that probably takes

00:40:02.110 --> 00:40:03.430
a long time to load,

00:40:05.870 --> 00:40:12.290
This is a great way to indicate to your
users where they'll be when they let go.

00:40:12.390 --> 00:40:15.130
So without having to load
the movie in the foreground,

00:40:15.130 --> 00:40:17.970
you can let them scrub to a
specific time they want and not

00:40:17.970 --> 00:40:21.200
spend a bunch of time trying to
load that piece of the media in.

00:40:21.200 --> 00:40:24.760
And the best part is, of course,
just like all the rest of this stuff,

00:40:24.760 --> 00:40:27.430
it just works in fullscreen
mode like anything else.

00:40:27.550 --> 00:40:29.730
And with just a couple
simple lines of CSS,

00:40:29.740 --> 00:40:33.300
we can completely restyle the way our
controls work and even maybe add a

00:40:33.310 --> 00:40:34.270
couple extra more features in here.

00:40:37.640 --> 00:40:38.160
Well, I'm sorry.

00:40:38.160 --> 00:40:40.490
Add a couple more
graphical features in here.

00:40:40.600 --> 00:40:44.340
So, like, maybe a cool-looking gradient
on the controls and perhaps,

00:40:44.340 --> 00:40:46.250
like, some shadows on things.

00:40:46.760 --> 00:40:49.370
Whatever you can do in CSS,
you can do in page,

00:40:49.390 --> 00:40:50.660
you can do in fullscreen mode as well.

00:40:50.660 --> 00:40:54.540
So, for more information about all
the things we talked about today,

00:40:54.540 --> 00:40:57.440
please talk to Vicki Murley.

00:40:57.440 --> 00:40:59.680
She's our Safari Technologies Evangelist.

00:40:59.720 --> 00:41:01.790
And also,
there's a whole lot of information

00:41:01.790 --> 00:41:04.980
up on the Safari Dev Center on
the developer page at apple.com.

00:41:05.340 --> 00:41:07.330
And the Apple Developer Forums,
which I'm sure you guys

00:41:07.330 --> 00:41:09.790
already know about,
are a great resource for figuring

00:41:09.790 --> 00:41:11.320
out how things work as well.

00:41:14.750 --> 00:41:17.940
There's going to be a session
on HTTP live streaming.

00:41:17.940 --> 00:41:21.600
If you're interested in doing
that with your video coming up,

00:41:21.600 --> 00:41:24.060
let's see, what, at 4:30 today.

00:41:24.380 --> 00:41:26.540
There's going to be another session
on understanding and optimizing

00:41:26.540 --> 00:41:28.150
web graphics on Wednesday.

00:41:28.230 --> 00:41:31.840
And finally, all the things you found
out about accessibility,

00:41:31.840 --> 00:41:34.680
you can get more in-depth
information for accessibility

00:41:34.680 --> 00:41:37.990
and automation on iOS on Friday.

00:41:38.240 --> 00:41:42.380
There's a lab directly after the session
downstairs on HTML5 audio and video.

00:41:42.380 --> 00:41:45.350
There's going to be a live
streaming lab on Wednesday,

00:41:45.460 --> 00:41:48.300
and Wednesday is also full
of open labs for Safari.

00:41:48.300 --> 00:41:51.080
So come on by and ask any questions
you didn't get answered today.

00:41:52.640 --> 00:41:55.950
But in summary,
I hope that this allows you guys to

00:41:55.950 --> 00:42:06.320
come up with some really fantastic
looking controls for all of your content.

00:42:06.320 --> 00:42:06.320
And I also hope that the fullscreen
feature is really exciting,

00:42:06.320 --> 00:42:06.320
as exciting to you as it is to me.

00:42:06.570 --> 00:42:09.510
And the subtitles and text tracks,
I really hope you start

00:42:09.510 --> 00:42:11.100
adopting those right now.

00:42:11.100 --> 00:42:13.680
It's possible with these
JavaScript polyfill libraries,

00:42:13.740 --> 00:42:16.610
and it will only get better in the
future as browsers take over more

00:42:16.610 --> 00:42:18.200
of the work from the JavaScript.

00:42:18.340 --> 00:42:26.990
And finally, making your video
accessible to everybody.

00:42:26.990 --> 00:42:27.100
I hope that we've shown you how
and shown you how important it is.
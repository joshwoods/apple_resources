WEBVTT

00:00:10.100 --> 00:00:11.360
Good morning, everybody.

00:00:11.400 --> 00:00:14.670
Welcome to Understanding UIKit Rendering.

00:00:14.980 --> 00:00:17.250
My name is Josh,
and I will be joined in a little

00:00:17.250 --> 00:00:20.110
while by Mathieu and Andy,
who are going to do

00:00:20.180 --> 00:00:21.700
some demos for you guys.

00:00:21.700 --> 00:00:26.700
We're going to talk this morning about
rendering and compositing with UIKit.

00:00:26.960 --> 00:00:31.820
So, throughout the course of the session,
we're going to be building this app.

00:00:32.070 --> 00:00:34.550
Actually, we're going to look at
the way that it's built.

00:00:34.850 --> 00:00:37.390
There's a few interesting things in this.

00:00:37.530 --> 00:00:41.550
We've got rotated layers,
so the edges of these will need

00:00:41.550 --> 00:00:46.700
to be anti-aliased so that they
don't end up looking really jagged.

00:00:46.880 --> 00:00:49.640
We have shadows around all these photos.

00:00:49.640 --> 00:00:52.760
There's nice drop shadows
to give them some depth,

00:00:52.760 --> 00:00:54.680
and we've got this label in
the middle that has a number

00:00:54.680 --> 00:00:56.190
of interesting things about it.

00:00:56.200 --> 00:00:59.520
It has rounded corners,
there's shadows on the text,

00:00:59.660 --> 00:01:01.520
there's a reflection there.

00:01:01.540 --> 00:01:04.180
So there's a lot of interesting
visual effects that we've built here,

00:01:04.220 --> 00:01:08.570
and this has all been done using
UIKit with a few bits of CA,

00:01:08.570 --> 00:01:11.460
Core Animation, thrown in.

00:01:11.460 --> 00:01:15.950
But I've done it in what may be the most
obvious way to generate these effects,

00:01:16.310 --> 00:01:19.980
which might not necessarily
always be the best performing.

00:01:19.980 --> 00:01:23.940
So we're going to take a look at how
we've done this and why I did it wrong,

00:01:24.150 --> 00:01:27.290
and Mathieu and Andy will
show you how to do it right,

00:01:27.290 --> 00:01:29.670
since they're less lazy than I am.

00:01:30.720 --> 00:01:32.940
So the things that we're
going to cover today,

00:01:32.940 --> 00:01:35.840
we'll start out by talking
about some of the foundations

00:01:35.840 --> 00:01:39.470
of rendering with UIKit and how
that relates to Core Animation.

00:01:39.630 --> 00:01:43.370
So we'll talk about UIView and CALayer,
how they fit together,

00:01:43.370 --> 00:01:46.320
what their relationship is,
how you decide where

00:01:46.330 --> 00:01:49.710
they show up on screen,
where their content comes from,

00:01:49.710 --> 00:01:53.680
all the basics of rendering
with UIKit and Core Animation.

00:01:53.740 --> 00:01:57.500
Once we know where things are positioned
and how we get content into it,

00:01:57.560 --> 00:01:59.800
we're going to talk about
when things get rendered.

00:01:59.870 --> 00:02:02.390
And for the purposes of
what we'll be discussing,

00:02:02.510 --> 00:02:07.140
that is CA transaction and how
CA transactions determine when the

00:02:07.180 --> 00:02:11.120
changes you make to your application
by setting properties on UIView end

00:02:11.120 --> 00:02:13.220
up getting rendered to the screen.

00:02:13.270 --> 00:02:15.980
And then we'll end by
looking at that sample app,

00:02:16.030 --> 00:02:19.860
and we'll see four main
topics about that app:

00:02:19.920 --> 00:02:24.900
clipping and masking, edge anti-aliasing,
group opacity, and shadows.

00:02:24.990 --> 00:02:27.600
So if some of those aren't
necessarily clear right now

00:02:27.600 --> 00:02:31.070
what exactly I mean by that,
probably group opacity.

00:02:31.220 --> 00:02:33.790
Don't worry,
we've got explanations in here.

00:02:33.920 --> 00:02:34.540
Hopefully good.

00:02:34.540 --> 00:02:35.580
We'll see how that goes.

00:02:35.670 --> 00:02:38.480
And we'll get it all explained.

00:02:38.620 --> 00:02:41.700
So to start out,
let's talk about the relationship

00:02:41.700 --> 00:02:43.870
between UIViews and CALayers.

00:02:44.200 --> 00:02:48.000
So if you thought about this initially,
the first thing that you might try and

00:02:48.000 --> 00:02:52.500
do when figuring out how UIView and
CALayer relate to each other is to think

00:02:52.550 --> 00:02:57.540
that they're actually a class hierarchy
where UIView would subclass CALayer.

00:02:57.610 --> 00:03:00.550
And I want to start out just
to be clear right off the bat,

00:03:00.550 --> 00:03:01.860
that is not the case.

00:03:01.910 --> 00:03:03.580
But let's look at why.

00:03:03.710 --> 00:03:07.170
So if CALayer were the base class
and UIView inherited from that,

00:03:07.370 --> 00:03:08.440
that would be fine.

00:03:08.520 --> 00:03:10.220
There would be no problem there.

00:03:10.280 --> 00:03:13.200
But then if we wanted a UIScrollView,
we would have to

00:03:13.200 --> 00:03:14.910
subclass off that UIView.

00:03:15.040 --> 00:03:18.600
So now CALayer is directly
in our class hierarchy as a

00:03:18.600 --> 00:03:21.600
superclass of UIScrollView.

00:03:21.840 --> 00:03:23.900
But what if we wanted to use
a different kind of layer,

00:03:24.100 --> 00:03:26.320
for example, a CA-tiled layer?

00:03:26.390 --> 00:03:29.040
There would be no way to get
that into our ScrollView because

00:03:29.040 --> 00:03:32.150
the ScrollView is actually
inheriting from CALayer directly.

00:03:32.370 --> 00:03:36.680
So this really wouldn't work because
we would be really limited in how we

00:03:36.680 --> 00:03:39.520
could combine UIView and Core Animation.

00:03:39.620 --> 00:03:42.140
So instead of that,
what we actually have is two

00:03:42.200 --> 00:03:44.000
parallel class hierarchies.

00:03:44.040 --> 00:03:46.800
UIView is a separate class
hierarchy and CALayer is its

00:03:46.800 --> 00:03:48.420
own separate class hierarchy.

00:03:48.470 --> 00:03:51.020
And every UIView has a CA layer.

00:03:51.080 --> 00:03:53.460
So by default,
when you just create a UIView,

00:03:53.470 --> 00:03:57.180
you get a UIView that
has a regular CA layer.

00:03:57.400 --> 00:03:59.400
The same would be the case if
you created a UI scroll view.

00:03:59.400 --> 00:04:02.140
By default, it would have a CA layer.

00:04:02.220 --> 00:04:09.010
But if you wanted to make your UI scroll
view have a CA tiled layer instead,

00:04:09.010 --> 00:04:09.010
you can change that, although...

00:04:09.140 --> 00:04:12.140
I just realized, talking about this now,
that's not actually what you would do.

00:04:12.140 --> 00:04:15.080
You would want to put that CA tiled layer
in a subview of your UI scroll view,

00:04:15.080 --> 00:04:18.220
so only listen to parts of
what I'm saying right now,

00:04:18.220 --> 00:04:19.100
not everything.

00:04:19.110 --> 00:04:26.910
But you could do that if you wanted,
just don't.

00:04:27.950 --> 00:04:32.290
So that's basically what
the relationship is.

00:04:32.310 --> 00:04:36.350
So now let's talk about how you use
UIView and CALayer to actually determine

00:04:36.350 --> 00:04:38.460
where content will show up on screen.

00:04:38.580 --> 00:04:42.490
And to be able to really talk about this,
we should start out at the base

00:04:42.790 --> 00:04:47.670
and talk about screen geometry
and what the geometry is of an

00:04:47.680 --> 00:04:50.120
iPhone or iOS device screen.

00:04:50.250 --> 00:04:52.440
So let's take iPhone 4, for example.

00:04:52.620 --> 00:04:54.920
The top left is the origin,
starting at 00,

00:04:55.070 --> 00:04:58.260
when you're holding it in portrait,
and X increases to the

00:04:58.270 --> 00:05:00.360
right and Y increases down.

00:05:00.520 --> 00:05:05.320
So the native size of iPhone 4,
iPhone 3GS, iPod Touch,

00:05:05.450 --> 00:05:09.400
all of the smaller iOS
devices is exactly the same,

00:05:09.670 --> 00:05:13.320
top left, origin,
and the size is 320 by 480.

00:05:13.530 --> 00:05:17.520
Now that's true even for the iPhone 4,
which has a high resolution display.

00:05:17.630 --> 00:05:20.120
Because UIKit always
talks in UIKit points.

00:05:20.120 --> 00:05:24.730
Which are equivalent to one
pixel on the original iPhone.

00:05:24.780 --> 00:05:27.120
So 320 by 480.

00:05:27.120 --> 00:05:30.020
Now that's really easy and really
nice because you know it's going

00:05:30.020 --> 00:05:33.100
to be consistent across every one
of the devices that you look at.

00:05:33.120 --> 00:05:36.260
Now things get a little more
complicated if you start asking

00:05:36.260 --> 00:05:39.890
CoreAnimation for screen geometry,
because CoreAnimation doesn't

00:05:39.930 --> 00:05:41.980
actually deal in these UIKit points.

00:05:42.120 --> 00:05:46.310
So if you were to ask CoreAnimation
what the size of the screen is,

00:05:46.310 --> 00:05:49.120
it would actually report a larger size.

00:05:49.120 --> 00:05:50.120
So we'll see that in just a moment.

00:05:50.120 --> 00:05:53.880
But one important thing to note about
the screen geometry is that it does

00:05:53.880 --> 00:05:56.030
not change when you rotate the device.

00:05:56.120 --> 00:06:00.120
So if you use your UI view
controller to do auto rotation,

00:06:00.120 --> 00:06:03.120
the screen geometry,
even when you're in landscape,

00:06:03.120 --> 00:06:04.120
remains the same.

00:06:04.120 --> 00:06:09.520
With 00 being top left in portrait,
X increasing up then and

00:06:09.520 --> 00:06:11.990
Y increasing to the right.

00:06:12.180 --> 00:06:17.100
So, yeah,
native orientation is always portrait,

00:06:17.100 --> 00:06:19.340
even when you're in landscape.

00:06:19.340 --> 00:06:21.540
And if you start looking
at Core Animation,

00:06:21.540 --> 00:06:24.330
you might have to start dealing
with different display sizes

00:06:24.440 --> 00:06:27.470
if you ask Core Animation to
convert to screen coordinates.

00:06:27.610 --> 00:06:31.940
So really the best advice I can give
you about screen coordinates is just

00:06:31.980 --> 00:06:35.170
always use UIKit when you convert
to and from screen coordinates,

00:06:35.190 --> 00:06:37.670
and we'll make sure that you always
see a consistent view of the world

00:06:37.700 --> 00:06:40.490
no matter what device you're on,
as opposed to when you

00:06:40.490 --> 00:06:43.340
start using Core Animation,
you have to know the specifics of

00:06:43.340 --> 00:06:48.360
the display size and know that you
either have 320x480 or 640x960,

00:06:48.360 --> 00:06:49.490
depending on which iPhone you're on.

00:06:49.500 --> 00:06:51.680
But of course,
this actually gets a little

00:06:51.690 --> 00:06:54.500
bit more complicated when
we start looking at iPad.

00:06:54.500 --> 00:06:57.500
Now from UIKit, still really easy.

00:06:57.500 --> 00:07:03.250
Portrait orientation, top left is 00,
768x2024 is the size.

00:07:03.580 --> 00:07:06.500
This is consistent no matter
what orientation the iPad is in.

00:07:06.500 --> 00:07:08.500
That is always the orientation.

00:07:08.500 --> 00:07:11.050
So you can see the screen
coordinates on iPad 1,

00:07:11.050 --> 00:07:12.240
iPad 2, all the same.

00:07:12.760 --> 00:07:17.100
Now Core Animation,
it's a little bit less obvious,

00:07:17.260 --> 00:07:18.500
let's say.

00:07:18.500 --> 00:07:21.410
That's the screen coordinate
system for an iPad,

00:07:21.480 --> 00:07:24.500
actually an iPad 2,
if you ask Core Animation.

00:07:24.500 --> 00:07:26.490
So bottom left is the origin.

00:07:26.520 --> 00:07:29.500
It would actually be landscape native,
basically.

00:07:29.500 --> 00:07:32.190
And on the original iPad,
it's actually the top

00:07:32.190 --> 00:07:34.930
right is the origin,
with x increasing down and

00:07:34.960 --> 00:07:36.490
y increasing to the left.

00:07:36.600 --> 00:07:39.530
So you probably don't want to ask
Core Animation to convert to and from

00:07:39.530 --> 00:07:42.930
screen coordinates on an iPad especially,
because the results you get,

00:07:43.230 --> 00:07:46.470
while they'll be consistent,
they may not be exactly what you expect.

00:07:46.500 --> 00:07:49.500
So if you stick with UIKit,
it's the same on all the devices.

00:07:49.500 --> 00:07:53.850
Hold portrait orientation
and top left is 00.

00:07:54.030 --> 00:07:55.750
All right,
so now that we know how to talk

00:07:55.760 --> 00:07:58.330
about positioning things on screen,
we can start talking

00:07:58.330 --> 00:07:59.680
about positioning views.

00:07:59.780 --> 00:08:02.100
So let's create one
large UIView to start,

00:08:02.100 --> 00:08:05.480
with its origin at the top left again,
since that's our native orientation,

00:08:05.540 --> 00:08:10.720
and we'll fill the screen with it,
so its entire size is 768 by 1024.

00:08:10.770 --> 00:08:13.260
Now, let's add some subview.

00:08:13.310 --> 00:08:16.170
How do we talk about the position
and size of this subview in its

00:08:16.230 --> 00:08:17.870
superview's coordinate space?

00:08:17.980 --> 00:08:21.960
Because we always talk about views
in terms of coordinate spaces.

00:08:22.020 --> 00:08:23.900
When we talk about
positioning and sizing them,

00:08:23.900 --> 00:08:27.380
we're often discussing it in the
coordinate space of the superview.

00:08:27.520 --> 00:08:29.190
Sometimes when you talk
about sizes of views,

00:08:29.200 --> 00:08:32.680
you may talk about it in the
view's own coordinate system.

00:08:32.740 --> 00:08:34.990
But most of the time,
the first thing you'll learn,

00:08:34.990 --> 00:08:38.150
or the first thing that you'll deal with,
is the position and size of a view

00:08:38.150 --> 00:08:40.080
in its superview's coordinate system.

00:08:40.140 --> 00:08:42.580
And that's called,
in UIKit and Core Animation,

00:08:42.630 --> 00:08:44.280
the frame of that view.

00:08:44.310 --> 00:08:47.720
Now, the frame is a rect, again,
in the superview's coordinate system,

00:08:47.780 --> 00:08:50.260
and it's the rectangle that
is the smallest rectangle

00:08:50.530 --> 00:08:52.590
that fully encloses that view.

00:08:52.790 --> 00:08:57.000
Now, when it's rectilinear like this,
you've got non-90 degree

00:08:57.000 --> 00:08:59.020
angle rotations on anything.

00:08:59.060 --> 00:09:00.860
That's really easy to understand.

00:09:00.920 --> 00:09:04.520
The origin of your frame is the distance
from the top left of the superview,

00:09:04.580 --> 00:09:08.600
and the size is the size of
that view in its superview.

00:09:08.680 --> 00:09:11.100
So in this case,
we're about 100 points from the left,

00:09:11.170 --> 00:09:13.910
200 points down,
and we're about 200 points

00:09:13.910 --> 00:09:15.340
across and 200 points tall.

00:09:15.580 --> 00:09:19.750
So our frame is then 100, 200, 200, 200.

00:09:20.360 --> 00:09:23.690
Now, frame, and this is actually a
very important point here,

00:09:23.700 --> 00:09:27.060
is not a stored property.

00:09:27.060 --> 00:09:30.140
When you set the frame of a layer,
it doesn't actually get

00:09:30.140 --> 00:09:31.900
saved as the frame anywhere.

00:09:31.900 --> 00:09:35.320
Setting the frame actually changes
a couple of other properties.

00:09:35.320 --> 00:09:37.140
And in fact,
there's even more properties that

00:09:37.200 --> 00:09:39.870
are used to compute the frame,
although setting the frame will

00:09:39.870 --> 00:09:41.460
only ever change the first two.

00:09:41.460 --> 00:09:44.570
So let's look at those first
two that actually do get

00:09:44.570 --> 00:09:46.780
changed when you call set frame.

00:09:46.780 --> 00:09:48.940
So the first is the center.

00:09:48.940 --> 00:09:51.900
Now center is a point in the
superview's coordinate system

00:09:51.960 --> 00:09:55.580
that defines the location of
your view within its superview.

00:09:55.580 --> 00:09:59.100
And because it's called center,
it defines the center of that view.

00:09:59.100 --> 00:10:04.140
So in this case, our center is about 200,
300, well, not about, exactly,

00:10:04.190 --> 00:10:07.130
because it's right in
the middle of that view,

00:10:07.310 --> 00:10:10.730
and it's defining the
location in our superview.

00:10:11.420 --> 00:10:14.280
So that defines the location,
but what defines the size?

00:10:14.520 --> 00:10:16.290
Well, that's where bounds comes in.

00:10:16.390 --> 00:10:18.520
And in fact, bounds is a rect.

00:10:18.640 --> 00:10:21.060
It's a CG rect.

00:10:21.060 --> 00:10:22.960
So it has both an origin and a size.

00:10:23.230 --> 00:10:26.560
But for the purpose of computing frame,
the only thing that matters

00:10:26.560 --> 00:10:27.980
is the size of the bounds.

00:10:28.070 --> 00:10:33.540
So we'll look at that first and leave
bounds origin for a little later.

00:10:33.560 --> 00:10:37.380
So the bounds size -- well, actually,
the bounds entirely is a rect in

00:10:37.380 --> 00:10:39.440
the view's own coordinate space.

00:10:39.460 --> 00:10:41.460
So I mentioned that we would
talk about two coordinate spaces,

00:10:41.460 --> 00:10:44.340
super view coordinate space
and the view coordinate space.

00:10:44.390 --> 00:10:46.940
The bounds is in the view's
own coordinate space.

00:10:47.020 --> 00:10:50.130
So it defines the size of the view
in its own coordinate space before

00:10:50.130 --> 00:10:53.170
taking into account transforms
that may be applied to the view.

00:10:53.500 --> 00:10:55.260
Again, we'll see that in a second.

00:10:55.310 --> 00:10:58.020
So in this case,
our bound size is 200 by 200 and

00:10:58.290 --> 00:11:01.820
exactly matches the frame size because
we have no transform on this view.

00:11:02.100 --> 00:11:03.460
There's a one-to-one mapping.

00:11:03.490 --> 00:11:05.460
So we're going to do a
little bit of mapping.

00:11:05.460 --> 00:11:06.820
So we're going to do a
little bit of mapping.

00:11:06.900 --> 00:11:09.580
So our bounds is 00, 200, 200.

00:11:09.610 --> 00:11:14.640
And that translates into a frame of 100,
200, 200, 200.

00:11:14.840 --> 00:11:15.040
Okay.

00:11:15.160 --> 00:11:17.680
So now what happens if we
actually do apply a transform,

00:11:17.680 --> 00:11:19.300
which we were just mentioning?

00:11:19.330 --> 00:11:21.940
And in this case,
let's apply a 50% scale.

00:11:21.990 --> 00:11:24.560
So now keep in mind,
we're not going to change the center and

00:11:24.560 --> 00:11:26.380
we're not going to change the bounds.

00:11:26.410 --> 00:11:28.660
But nevertheless,
when we apply a transform,

00:11:28.670 --> 00:11:32.140
we will be changing the frame because
frame is not a stored property.

00:11:32.300 --> 00:11:33.380
It's computed.

00:11:33.380 --> 00:11:36.600
And the first two things it gets
computed from are bounds and

00:11:36.690 --> 00:11:38.740
center and transform is the third.

00:11:38.800 --> 00:11:42.120
So if we set a 50% scale, that will,
as you would expect,

00:11:42.160 --> 00:11:46.140
shrink the size of our view and has
actually reduced our frame size.

00:11:46.180 --> 00:11:49.030
So our frame is now -- that
was our original frame there

00:11:49.030 --> 00:11:51.020
before we applied the transform.

00:11:51.030 --> 00:11:55.260
Our frame now is 150, 250, 100, 100.

00:11:55.260 --> 00:11:57.270
Now, in this example,
we actually scaled down

00:11:57.270 --> 00:11:58.700
around the center of the view.

00:11:58.700 --> 00:12:01.460
We sort of scaled right down
in place and remained centered.

00:12:01.470 --> 00:12:03.300
That's not just for the slides and
it's not just sort of the view.

00:12:03.300 --> 00:12:04.300
That's sort of a convenience.

00:12:04.320 --> 00:12:08.980
That is actually what would happen
because when you apply a transform,

00:12:08.980 --> 00:12:13.580
it will always be applied about
the center point of the view.

00:12:13.580 --> 00:12:17.260
So we've scaled down 50%
around that center point.

00:12:17.260 --> 00:12:18.860
And again, this changed our frame.

00:12:18.860 --> 00:12:20.520
Now, that frame is pretty easy.

00:12:20.560 --> 00:12:23.590
You could kind of visualize what
would happen and in your mind see,

00:12:23.590 --> 00:12:25.820
yeah, okay, I've applied a 50% scale.

00:12:25.820 --> 00:12:28.800
I probably halved the size of
the frame in each dimension.

00:12:28.820 --> 00:12:33.220
So you could think about it and say,
yeah, I went from 200, 200 to 100, 100.

00:12:33.220 --> 00:12:34.340
And you could guess that.

00:12:34.340 --> 00:12:36.350
But what happens if
you applied a rotation?

00:12:36.550 --> 00:12:41.570
And let's say we rotated 45 degrees
instead of some 90-degree angle.

00:12:41.800 --> 00:12:45.470
and David Now this one's a little
bit more difficult to think about

00:12:45.640 --> 00:12:47.820
and really keep in your mind.

00:12:47.820 --> 00:12:49.710
Because the frame,
as I mentioned earlier,

00:12:49.810 --> 00:12:52.510
is the smallest rectangle that
fully encloses that view in its

00:12:52.510 --> 00:12:54.340
superview's coordinate system.

00:12:54.340 --> 00:12:57.290
And because we're now rotated,
the smallest frame that encloses

00:12:57.310 --> 00:13:00.710
that whole thing no longer has an
obvious relationship to the side.

00:13:01.000 --> 00:13:03.490
I mean, it's still, I guess, obvious,
depending on how mathematically

00:13:03.550 --> 00:13:04.260
inclined you are.

00:13:04.320 --> 00:13:07.420
It's the diagonal across
the box in this case.

00:13:07.420 --> 00:13:11.330
But it's no longer a one-to-one
mapping from bounds to frame size.

00:13:11.450 --> 00:13:15.540
So our frame is now 59, 59, 282, 282.

00:13:15.870 --> 00:13:17.670
The diagonal across that box is the size.

00:13:17.670 --> 00:13:19.270
But our bounds hasn't changed.

00:13:19.270 --> 00:13:21.420
It's still 00, 200, 200.

00:13:22.860 --> 00:13:25.530
All right,
so let's just take a quick review of

00:13:25.530 --> 00:13:27.740
the components that make up frame.

00:13:27.840 --> 00:13:29.680
These are the things used
to compute the frame.

00:13:29.860 --> 00:13:33.000
We talked about the
three that UIKit exposes.

00:13:33.030 --> 00:13:36.360
There are actually a couple
others exposed by CALayer.

00:13:36.460 --> 00:13:39.300
So we'll look at all of them,
see which coordinate space they're in,

00:13:39.300 --> 00:13:41.610
and just make sure we all are on
the same page about what we're

00:13:41.610 --> 00:13:43.960
talking about with all of them,
because it could be a

00:13:43.960 --> 00:13:45.240
little bit confusing.

00:13:45.320 --> 00:13:47.200
So first off, we have the bound size.

00:13:47.240 --> 00:13:49.810
As we mentioned,
this determines the size of the layer.

00:13:50.000 --> 00:13:53.300
Now, the bounds is a property
on both UIView and CALayer.

00:13:53.330 --> 00:13:54.310
They're the exact same thing.

00:13:54.320 --> 00:13:57.700
When you tell a view to set its bounds,
all the view does is tell

00:13:57.830 --> 00:13:59.420
the layer to set its bounds.

00:13:59.580 --> 00:14:03.700
So regardless of what you ask,
you'll get the same value back.

00:14:03.730 --> 00:14:06.960
And this is in the coordinate
space of the view itself.

00:14:06.990 --> 00:14:08.110
Next, we have center.

00:14:08.380 --> 00:14:10.740
Center is the property on UIView.

00:14:11.020 --> 00:14:13.350
If you were to ask for
the property on CALayer,

00:14:13.400 --> 00:14:15.920
you would find that CALayer
does not have a center property.

00:14:16.070 --> 00:14:18.150
In fact, it has a position property.

00:14:18.380 --> 00:14:19.660
Those are the same thing.

00:14:19.710 --> 00:14:22.120
When you set the center
property on the UIView,

00:14:22.170 --> 00:14:25.260
it sets the position
property on the CALayer.

00:14:25.260 --> 00:14:27.560
We'll see in just a second why
they're named something different,

00:14:27.600 --> 00:14:29.700
but they are actually
the exact same thing.

00:14:29.740 --> 00:14:33.260
And that's a CG point in the
superview's coordinate system.

00:14:33.330 --> 00:14:37.040
Now, next, we have transform.

00:14:37.180 --> 00:14:39.730
Transform is a property on UIView.

00:14:39.880 --> 00:14:43.530
That property does exist on CALayer,
but is not the same.

00:14:43.660 --> 00:14:47.420
So on CALayer,
it's actually affine transform.

00:14:47.730 --> 00:14:49.360
Transform and affine
transform are the same thing.

00:14:49.360 --> 00:14:54.290
They are a CG affine transform
that defines a rotation,

00:14:54.460 --> 00:14:59.000
scale, skew, translation,
any kind of affine transform in

00:14:59.010 --> 00:15:01.060
the superview's coordinate space.

00:15:01.060 --> 00:15:04.280
Now, that's it for UIView,
but there are two more on CALayer.

00:15:04.360 --> 00:15:07.360
So the first is transform.

00:15:07.360 --> 00:15:09.350
This is a CA transform 3D.

00:15:09.360 --> 00:15:12.360
So it actually,
instead of in two dimensions,

00:15:12.360 --> 00:15:15.080
it allows you to translate your
view in three dimensions on the X,

00:15:15.080 --> 00:15:16.340
Y, and Z axes.

00:15:16.360 --> 00:15:19.040
You can do rotations, transforms, scales.

00:15:19.400 --> 00:15:21.930
There's a whole variety
of different convenience

00:15:21.930 --> 00:15:23.850
functions for dealing with them.

00:15:24.130 --> 00:15:27.030
But they're just matrix multiplication,
basically.

00:15:27.200 --> 00:15:31.970
So transform is just on CALayer,
not exposed through UIView.

00:15:32.090 --> 00:15:35.060
And it's, again,
in the superlayer's coordinate system.

00:15:35.190 --> 00:15:38.200
Now, the final property is a little
bit more difficult to explain,

00:15:38.260 --> 00:15:41.890
but actually does get to the
difference between center and position.

00:15:42.120 --> 00:15:44.060
And that is anchor point.

00:15:44.060 --> 00:15:46.990
Now, again, this only exists on CALayer,
not exposed through UIView.

00:15:47.160 --> 00:15:48.780
It's a point in the layer's own view.

00:15:48.960 --> 00:15:51.850
It's a point in the layer's
own coordinate space,

00:15:51.860 --> 00:15:55.860
except defined in unit coordinates,
not in layer coordinates,

00:15:55.930 --> 00:16:00.540
that determines the point in the
view that will get anchored to the

00:16:00.540 --> 00:16:02.860
superview at that view's position.

00:16:02.860 --> 00:16:04.860
Now, if that doesn't make
a whole lot of sense,

00:16:04.860 --> 00:16:07.700
that's because I'm not going
to get into it too much.

00:16:07.870 --> 00:16:10.820
There's great documentation
online for core animation.

00:16:10.890 --> 00:16:13.780
Most of the time when you're using UIKit,
you're probably not going

00:16:13.840 --> 00:16:14.860
to be changing this.

00:16:14.860 --> 00:16:16.660
So I wouldn't worry too much about it.

00:16:16.660 --> 00:16:18.660
If you really start to think
you need to work with this,

00:16:18.660 --> 00:16:21.890
or if you find code that's doing it,
go read the core animation

00:16:21.890 --> 00:16:25.660
documentation to get a better
understanding of what it does exactly.

00:16:25.660 --> 00:16:29.590
But it will change how the other
properties are interpreted a bit.

00:16:29.760 --> 00:16:31.420
Yeah.

00:16:31.740 --> 00:16:35.660
Well, not going to try and explain it
much more than that right now.

00:16:35.660 --> 00:16:36.660
Okay.

00:16:36.660 --> 00:16:39.660
So those are the five properties
that contribute to frame.

00:16:39.660 --> 00:16:42.730
These are used to calculate the frame.

00:16:43.600 --> 00:18:02.800
[Transcript missing]

00:18:03.140 --> 00:18:07.480
This is going to help us understand what
happens when we change the bounds origin.

00:18:07.600 --> 00:18:11.930
Thinking about it mathematically,
you can consider changing the bounds

00:18:11.970 --> 00:18:16.120
origin as applying a translation
to this coordinate system.

00:18:16.300 --> 00:18:23.790
If we set a positive value for both the
X and Y position on the bounds origin,

00:18:23.880 --> 00:18:26.080
that would actually shift the
coordinate system within the

00:18:26.080 --> 00:18:27.560
visible frame of that view.

00:18:27.720 --> 00:18:30.570
Making it positive,
we then shift that coordinate

00:18:30.570 --> 00:18:32.200
system up and to the left.

00:18:32.350 --> 00:18:34.800
Put another way,
this changes the point that's

00:18:34.800 --> 00:18:37.960
in the view's own coordinate
system that's visible at the

00:18:38.110 --> 00:18:39.800
top left of the view's frame.

00:18:39.800 --> 00:18:42.740
So now the thing that's visible at
the top left of the view's frame is

00:18:42.760 --> 00:18:46.490
actually the point in our content
that's at the bounds origin point.

00:18:46.790 --> 00:18:50.210
So if we said this was 100, 200,
the first thing you would see at

00:18:50.210 --> 00:18:54.290
the top left of your view would
be the subview positioned at 100,

00:18:54.290 --> 00:18:55.240
200.

00:18:55.240 --> 00:18:58.350
So it's effectively a window into
your view's coordinate system.

00:18:58.360 --> 00:19:01.400
The bounds defines which part of the
view's coordinate system is visible,

00:19:01.400 --> 00:19:05.710
is visible in the view's
frame at any given time.

00:19:06.100 --> 00:19:08.090
All right, so that was sort of the
mathematical explanation.

00:19:08.330 --> 00:19:11.100
Maybe let's look at it a little
bit more practically in terms

00:19:11.100 --> 00:19:14.900
of actually putting this into
practice on a UIView on a screen.

00:19:15.020 --> 00:19:17.100
So again, let's add that subview.

00:19:17.190 --> 00:19:19.200
Now,
those of you who have tried this before

00:19:19.200 --> 00:19:22.910
have probably noticed that by default,
if you just add a subview to a UIView,

00:19:23.190 --> 00:19:26.060
it will actually spill outside
of the size of that UIView.

00:19:26.130 --> 00:19:28.680
This may have bitten you for
hit testing purposes if you

00:19:28.800 --> 00:19:30.160
were doing touch handling.

00:19:30.280 --> 00:19:33.720
So let's just turn on clips to
bounds on that UIView to make

00:19:33.810 --> 00:19:35.550
it clearer what's happening.

00:19:35.940 --> 00:19:38.950
That will actually make sure that
anything outside of the bounds of

00:19:38.950 --> 00:19:40.530
the view does not get rendered.

00:19:40.630 --> 00:19:43.540
So turning on clips to bounds will
mask out all the parts that are

00:19:43.540 --> 00:19:45.670
outside of the frame of the view.

00:19:45.800 --> 00:19:49.270
So now this is set up with our
default bounds with the origin of 00.

00:19:49.390 --> 00:19:52.580
So if we then apply a positive
value to the bounds origin,

00:19:52.650 --> 00:19:54.950
we're effectively shifting which
part of that view's content

00:19:54.970 --> 00:19:57.080
is visible within its frame.

00:19:57.140 --> 00:20:02.100
Again, we're not actually changing the
frame by changing the bounds origin,

00:20:02.100 --> 00:20:06.240
so we're just shifting that part there up
and to the left to change the part of the

00:20:06.240 --> 00:20:08.650
view's coordinate system that's visible.

00:20:09.830 --> 00:20:12.860
All right, so now we know where views
are positioned on screen,

00:20:12.890 --> 00:20:14.450
and we know how they're sized.

00:20:14.580 --> 00:20:17.940
So how do we get content into them
now that we're positioning them?

00:20:18.100 --> 00:20:20.900
Well,
there's really one fundamental thing

00:20:20.900 --> 00:20:26.420
that is the underlying mechanism for
everything else that draws on iOS,

00:20:26.580 --> 00:20:31.520
and that is setting a view's
layer's contents property.

00:20:31.600 --> 00:22:54.700
[Transcript missing]

00:22:54.960 --> 00:23:00.140
So, just a couple of examples of taking a
look at how your performance of your

00:23:00.150 --> 00:23:03.980
app will vary based on whether you
use UIImageView or DrawRect for some

00:23:04.070 --> 00:23:07.490
simple things that UIImageView supports
right out of the box.

00:23:07.610 --> 00:23:10.640
So the first is,
let's say we've got this view here,

00:23:10.700 --> 00:23:13.610
or sorry, this image,
and we want to stretch it out

00:23:13.610 --> 00:23:15.940
into a larger 320 by 200 area.

00:23:16.260 --> 00:23:18.280
Well,
we'd actually have to break that into

00:23:18.280 --> 00:23:20.930
three slices to stretch it properly,
because we'd need to

00:23:21.040 --> 00:23:22.520
stretch the left part,
the middle part,

00:23:22.530 --> 00:23:25.680
and the right part independently.

00:23:25.880 --> 00:23:29.580
Because we don't want that arrow in the
middle to get stretched out horizontally.

00:23:29.780 --> 00:23:32.620
But if we wrote our own drawing
code and did it in DrawRect,

00:23:32.620 --> 00:23:34.270
we could definitely do that.

00:23:34.370 --> 00:23:36.990
We could use UIImage,
it has DrawRect and a

00:23:37.080 --> 00:23:40.540
variety of methods like that,
that will let you draw this in

00:23:40.540 --> 00:23:42.480
any way you like in your DrawRect.

00:23:42.540 --> 00:23:44.610
And if you did that,
you'd actually find that

00:23:44.610 --> 00:23:46.040
you ended up getting this.

00:23:46.120 --> 00:23:51.530
So let's say we're going to use a 3GS,
and that is at a 320 by 200 view

00:23:51.800 --> 00:23:57.440
going to be 250 additional kilobytes
of dynamic memory on an iPhone 3GS.

00:23:57.560 --> 00:24:00.470
On an iPhone 4,
it's actually a megabyte of extra

00:24:00.470 --> 00:24:04.700
memory that is being allocated and
filled with pixels just so that you can

00:24:04.700 --> 00:24:09.350
stretch out this image that you already
had in a smaller form to begin with.

00:24:10.000 --> 00:26:37.600
[Transcript missing]

00:26:37.660 --> 00:26:41.230
All right, so now we've got content
positioned on screen,

00:26:41.350 --> 00:26:44.680
we've got content into our view,
so how do we determine when that

00:26:44.680 --> 00:26:48.700
content is going to appear on screen,
when will it actually get rendered?

00:26:48.770 --> 00:26:52.280
And the specific reason that you might
be asking yourself this is because maybe

00:26:52.280 --> 00:26:54.250
you're making two changes to a view.

00:26:54.530 --> 00:26:57.950
You're changing its frame and then
you're changing its transform.

00:26:58.160 --> 00:27:01.530
But you want to make sure that you
don't end up seeing something on screen

00:27:01.530 --> 00:27:03.450
that only has half of those changes.

00:27:03.590 --> 00:27:06.560
You want to be sure that they
both render at the same time.

00:27:06.630 --> 00:27:10.620
Well, the good news is if you do nothing,
that's guaranteed to happen

00:27:10.620 --> 00:27:13.200
as long as you do it in the
same turn of the run loop.

00:27:13.380 --> 00:27:16.580
So let's take a look at what
will happen when we actually

00:27:16.730 --> 00:27:18.900
call setFrame and setTransform.

00:27:18.960 --> 00:27:22.900
Now, we're not actually having to
do anything with CA transaction

00:27:22.910 --> 00:27:26.190
ourselves to make this happen,
because Core Animation and

00:27:26.280 --> 00:27:29.600
UIKit will make sure that when
you set properties on your layers,

00:27:29.660 --> 00:27:33.760
it handles creating and committing
CA transactions on your behalf.

00:27:33.830 --> 00:27:36.060
So you've been doing this all
along and didn't even know it,

00:27:36.140 --> 00:27:36.450
maybe.

00:27:36.560 --> 00:27:40.560
So let's say we first start out
by calling setFrame on our view to

00:27:40.560 --> 00:27:43.260
move that view from the top left
into the center of the screen.

00:27:43.260 --> 00:27:45.520
Now,
Core Animation will create an implicit

00:27:45.650 --> 00:27:49.100
transaction on your behalf the first
time that you set one of these layer

00:27:49.100 --> 00:27:51.770
properties in one turn of the run loop.

00:27:52.120 --> 00:27:55.380
So now that implicit transaction is open,
and any other changes we make

00:27:55.550 --> 00:27:59.660
will be grouped up with that first
change and committed as a group.

00:27:59.810 --> 00:28:03.250
So if we then call setTransform,
that will be scaling that,

00:28:03.370 --> 00:28:06.360
let's say we're scaling that view down,
we haven't rendered anything yet.

00:28:06.430 --> 00:28:09.460
We've got that dotted outline there
of where we will be rendering it,

00:28:09.530 --> 00:28:11.130
but it hasn't appeared on screen.

00:28:11.280 --> 00:28:14.800
So the setTransform is in that
same implicit transaction.

00:28:15.100 --> 00:28:17.830
Now, let's say that we're done,
this is maybe in our

00:28:17.830 --> 00:28:20.180
button action method,
and we return from that

00:28:20.180 --> 00:28:21.620
UI button action method.

00:28:21.700 --> 00:28:25.860
That's going to cause Core Animation to
commit this implicit transaction once

00:28:25.860 --> 00:28:27.700
we go back to the turn of the run loop.

00:28:27.750 --> 00:28:30.760
And that will actually cause
that content to render on screen.

00:28:30.820 --> 00:28:33.380
Now, this may have bitten
some of you in the past,

00:28:33.380 --> 00:28:35.920
actually,
if you didn't know it was happening.

00:28:35.980 --> 00:28:38.880
Because let's say you have a
button action method and you

00:28:39.160 --> 00:28:40.880
want to start a progress spinner.

00:28:40.880 --> 00:28:45.860
So you create a UI progress indicator
and tell it to start animating the spin.

00:28:45.920 --> 00:28:49.400
And then you go off and start a
while loop on your main thread

00:28:49.400 --> 00:28:51.220
for the next five minutes.

00:28:51.260 --> 00:28:53.080
First of all, don't do that, please.

00:28:53.270 --> 00:28:55.410
But if you did,
you would find that your progress

00:28:55.540 --> 00:28:57.180
spinner actually never started.

00:28:57.330 --> 00:28:59.770
And that's because the starting
of that progress indicator was set

00:28:59.770 --> 00:29:01.140
up in this implicit transaction.

00:29:01.240 --> 00:29:03.240
You never went back to
the turn of the run loop.

00:29:03.240 --> 00:29:07.240
So Core Animation never committed
that implicit transaction.

00:29:07.240 --> 00:29:09.650
And it's sitting there waiting
for you to make the rest of your

00:29:09.650 --> 00:29:11.240
changes before it draws anything.

00:29:11.240 --> 00:29:17.240
So implicit transactions are definitely
your friend 99.9% of the time.

00:29:17.240 --> 00:29:19.670
If you're doing the wrong thing
and blocking your main thread

00:29:19.670 --> 00:29:22.850
for a long period of time,
we might be hurting you a little bit.

00:29:22.870 --> 00:29:25.830
But the answer to that is
not fix CA transaction.

00:29:25.880 --> 00:29:28.740
It's stop blocking the main thread,
please.

00:29:28.970 --> 00:29:30.710
So there's also explicit transactions.

00:29:30.900 --> 00:29:32.860
But I'm not going to talk
about that this morning.

00:29:33.100 --> 00:29:35.860
Because when you're
creating UIKit applications,

00:29:35.860 --> 00:29:39.850
there's really very little reason
to use an explicit transaction.

00:29:39.890 --> 00:29:44.020
The main purpose of explicit
transactions in Core Animation is

00:29:44.020 --> 00:29:47.120
to allow you to change properties
on the implicit animations that

00:29:47.250 --> 00:29:48.850
Core Animation would create for you.

00:29:48.860 --> 00:29:52.480
But if you're using UIKit,
we take care of that for you.

00:29:52.480 --> 00:29:55.540
And there's UIKit APIs to
change animation durations,

00:29:55.540 --> 00:30:00.480
animation curves, animation delays,
animation completion callbacks.

00:30:00.480 --> 00:30:04.340
All of the things that you normally
would use an explicit transaction

00:30:04.340 --> 00:30:09.860
for in a Core Animation only app,
there's alternatives available

00:30:09.860 --> 00:30:12.470
in UIKit that are easier to use.

00:30:12.480 --> 00:30:15.610
The reason I discourage you from
using the explicit transactions in

00:30:15.610 --> 00:30:18.360
Core Animation is because they can
actually change that commit timing

00:30:18.500 --> 00:30:20.100
depending on when you create it.

00:30:20.100 --> 00:30:22.100
So you can actually create and
commit your explicit transactions.

00:30:22.100 --> 00:30:24.100
I'm not going to get too much
into the details of that.

00:30:24.100 --> 00:30:26.810
But just to make sure that you
understand what I'm saying,

00:30:27.230 --> 00:30:30.490
If you're working with UIKit,
I would strongly encourage you to stick

00:30:30.610 --> 00:30:35.100
just with the implicit transaction
and not create your own explicit ones.

00:30:35.100 --> 00:30:37.370
All right,
so now let's get into the exciting

00:30:37.600 --> 00:30:39.100
cool rendering technique stuff.

00:30:39.100 --> 00:30:43.090
And we're going to look at it from
the perspective of performance because

00:30:43.100 --> 00:30:47.100
this sample app that we have written,
well, it looks really cool,

00:30:47.100 --> 00:30:49.820
but while you're scrolling,
especially on an original iPad,

00:30:49.930 --> 00:30:51.100
it's incredibly choppy.

00:30:51.100 --> 00:30:52.960
The performance is terrible.

00:30:53.020 --> 00:30:56.090
So let's take a look at what we've got.

00:30:56.360 --> 00:30:59.610
The most important thing that we're going
to cover while we talk about this app,

00:30:59.610 --> 00:31:02.300
and the biggest thing that
is making it perform poorly,

00:31:02.360 --> 00:31:04.400
is off-screen rendering.

00:31:04.490 --> 00:31:07.930
And the best thing you can do,
and the most common thing that you

00:31:07.940 --> 00:31:11.480
can do in your UIKit application
to find places that your rendering

00:31:11.560 --> 00:31:15.130
performance is poor and improve them,
is to find places where you're

00:31:15.130 --> 00:31:17.610
rendering off-screen and avoid that.

00:31:17.700 --> 00:31:19.600
So what do I mean by
off-screen rendering?

00:31:19.720 --> 00:31:23.420
Well, let's say we've got this view
hierarchy that we're trying to draw.

00:31:23.620 --> 00:31:24.360
We've got four views.

00:31:24.450 --> 00:31:27.020
That outer super view is gray.

00:31:27.300 --> 00:31:29.450
We've got a subview of
that that is orange,

00:31:29.550 --> 00:31:32.060
and two subviews of that
that are both green.

00:31:32.060 --> 00:31:35.300
So before we talk about exactly
what the off-screen pass means,

00:31:35.300 --> 00:31:38.840
let's just look at what happens
if there is no off-screen pass.

00:31:38.840 --> 00:31:41.160
Now,
this all happens so fast that you would

00:31:41.160 --> 00:31:44.260
never see these intermediate parts,
but we're breaking it down

00:31:44.360 --> 00:31:47.570
one step at a time just for
the conceptual purposes here.

00:31:47.580 --> 00:31:49.860
So Core Animation would first
render the deepest view.

00:31:49.860 --> 00:31:52.710
Well, actually, the shallowest view,
I guess, depending on which way

00:31:52.710 --> 00:31:53.660
you're looking at it.

00:31:53.870 --> 00:31:56.500
It would render that
gray view in the back.

00:31:56.570 --> 00:32:00.400
It would then be able to lay down the
pixels for that orange view on top of it.

00:32:00.450 --> 00:32:02.890
It would then be able to lay
down the pixels for those two

00:32:02.930 --> 00:32:04.360
green views on top of that.

00:32:04.420 --> 00:32:05.420
Now, this would be the ideal.

00:32:05.550 --> 00:32:07.040
No off-screen rendering.

00:32:07.130 --> 00:32:09.920
Core Animation can just blit
each of those backing stores,

00:32:09.920 --> 00:32:11.990
one after the other,
into the frame buffer

00:32:11.990 --> 00:32:13.270
on top of each other.

00:32:13.490 --> 00:32:16.200
Now, if we do something to that
orange view that causes it to

00:32:16.300 --> 00:32:19.390
require off screen rendering,
and we'll see in just a couple minutes

00:32:19.470 --> 00:32:22.380
a few of the things that that might be,
what will actually happen when

00:32:22.380 --> 00:32:25.380
CoreAnimation has to render that
frame is that first it will be able

00:32:25.380 --> 00:32:29.180
to again render that backing gray
view right to the frame buffer,

00:32:29.240 --> 00:32:33.160
but then it's going to require an
off screen pass for this orange view.

00:32:33.160 --> 00:32:37.600
And what that means is it can't render it
right on top of that gray backing store.

00:32:37.600 --> 00:32:39.700
It has to tear down
its rendering context,

00:32:39.770 --> 00:32:42.740
point the graphics processor to
a piece of off screen memory,

00:32:43.040 --> 00:32:46.220
allocate that off screen memory,
and then start drawing there.

00:32:46.220 --> 00:32:48.860
So it will first render that
orange view into this off screen

00:32:48.860 --> 00:32:50.460
buffer that it just allocated.

00:32:50.460 --> 00:32:52.610
Then it's going to render
those two sub views,

00:32:52.610 --> 00:32:56.420
the entire subtree actually,
the green view and the other green view,

00:32:56.450 --> 00:32:59.080
on top of it into this off screen buffer.

00:32:59.120 --> 00:33:01.960
Once it's done rendering that,
it tears down that graphics context,

00:33:02.130 --> 00:33:04.480
points the hardware
back to the main screen,

00:33:04.630 --> 00:33:07.370
and then using what it
just rendered off screen,

00:33:07.370 --> 00:33:11.520
it can draw that on top
of the main frame buffer.

00:33:11.520 --> 00:33:15.490
So there's this whole extra overhead
of additional allocation of memory,

00:33:15.500 --> 00:33:18.550
additional time spent pointing
the graphics processor

00:33:18.550 --> 00:33:19.940
from one buffer to another.

00:33:19.940 --> 00:33:23.270
It has to flush all the
pipelines for the graphics.

00:33:23.370 --> 00:33:27.580
It's really expensive to do this switch
between on screen and off screen buffers.

00:33:27.580 --> 00:33:32.760
So requiring that CoreAnimation do this
at every frame gets really expensive.

00:33:32.760 --> 00:33:35.040
And if you have something that
requires off screen rendering,

00:33:35.200 --> 00:33:38.380
that's going to happen once
every time the screen updates.

00:33:38.380 --> 00:33:41.180
So if you're trying to drag
something in a scroll view.

00:33:41.180 --> 00:33:43.240
Sometimes it's rendering a
frame while you're dragging.

00:33:43.240 --> 00:33:45.490
It'll draw some views on screen,
draw some off,

00:33:45.490 --> 00:33:47.000
then draw some back on again.

00:33:47.000 --> 00:33:50.420
And it gets really expensive really fast.

00:33:50.450 --> 00:33:54.520
So avoiding those off screen passes is
a great way to improve your performance.

00:33:54.520 --> 00:33:58.040
Now there is one trick you can use
which can minimize this impact.

00:33:58.040 --> 00:34:00.260
And that is called layer rasterization.

00:34:00.260 --> 00:34:03.530
And the idea with layer rasterization
is that you give CoreAnimation a

00:34:03.740 --> 00:34:06.840
hint that you both expect it to
render your view off screen and

00:34:07.000 --> 00:34:10.820
that it's safe for it to cache that
off screen rendering across frames.

00:34:10.840 --> 00:34:13.670
And reuse the same off screen
rendering for the next frame

00:34:13.870 --> 00:34:16.660
that it used for the first frame.

00:34:16.660 --> 00:34:19.780
So in that case, it would basically draw
that background view.

00:34:19.780 --> 00:34:22.470
And assuming it had already
just drawn that frame we saw,

00:34:22.530 --> 00:34:25.140
it would have kept around
that off screen rendering.

00:34:25.140 --> 00:34:26.720
So it wouldn't have to do it again.

00:34:26.720 --> 00:34:28.930
So those views on the left,
it doesn't even have

00:34:28.930 --> 00:34:30.120
to render again at all.

00:34:30.170 --> 00:34:32.850
Once it does that, it can just say, oh,
here, I have this buffer and

00:34:32.850 --> 00:34:34.940
draw that right on screen.

00:34:34.940 --> 00:34:37.890
So if you're rasterizing that layer
that required off screen rendering,

00:34:37.960 --> 00:34:39.920
it's now much faster because
we don't have to switch

00:34:40.020 --> 00:34:40.500
between the on and off screen.

00:34:40.500 --> 00:34:43.630
Now, of course,
the catch with this is that

00:34:43.630 --> 00:34:48.510
CoreAnimation will actually never do
incorrect rendering as a result of

00:34:48.520 --> 00:34:50.880
you telling it to rasterize something.

00:34:50.880 --> 00:34:53.660
So this means that if you were
doing something in that view,

00:34:53.720 --> 00:34:57.950
say, animating those sub views around by
rotating them and sliding them down,

00:34:58.150 --> 00:35:01.440
you would not be able to reuse that
cached off screen version for the

00:35:01.440 --> 00:35:05.660
next frame because the next frame
looks different than the last frame.

00:35:05.660 --> 00:35:08.260
So in that case,
it would actually have to throw away

00:35:08.420 --> 00:35:11.720
that off screen rendering anyway,
and you would be back to just as

00:35:11.720 --> 00:35:13.460
bad as you were to begin with.

00:35:13.460 --> 00:35:16.200
And if you had told CoreAnimation
to rasterize something that didn't

00:35:16.200 --> 00:35:19.540
require off screen rendering before,
you could actually be even worse

00:35:19.540 --> 00:35:22.860
because you weren't going to
require off screen rendering.

00:35:22.860 --> 00:35:25.540
You just told it to render off
screen by saying should rasterize,

00:35:25.690 --> 00:35:27.660
but it can't reuse the off screen cache.

00:35:27.660 --> 00:35:31.160
So now it's doing the off screen
and on screen at every frame again.

00:35:31.160 --> 00:35:34.180
So we'll talk about a few
places that you can use should

00:35:34.180 --> 00:35:37.680
rasterize to improve performance,
but the important thing that I really

00:35:38.000 --> 00:35:41.000
want to just keep stressing here is,
you know, is should rasterize is not

00:35:41.050 --> 00:35:44.130
some magic bullet that you can
just set on everything and say,

00:35:44.140 --> 00:35:46.540
oh, should rasterize is the fast flag.

00:35:46.650 --> 00:35:50.140
That's not what that means.

00:35:50.140 --> 00:35:53.140
It's great and really useful and
can help in a lot of situations,

00:35:53.240 --> 00:35:56.730
but be sure that you understand what
it's doing because it can also hurt

00:35:56.790 --> 00:35:58.990
your performance in other situations.

00:35:59.230 --> 00:36:00.840
All right, so let's look at our app.

00:36:00.950 --> 00:36:03.970
The first thing I want to focus on
is this text label in the middle.

00:36:04.080 --> 00:36:06.230
Now, there's a number of interesting
things going on in this,

00:36:06.380 --> 00:36:08.480
but the first one that we're going
to look at is the clipping and

00:36:08.480 --> 00:36:10.220
masking that we have happening.

00:36:10.340 --> 00:36:12.470
Now, we've got those rounded
corners around the edges,

00:36:12.470 --> 00:36:15.100
which look really nice,
but I've done it in the easiest

00:36:15.100 --> 00:36:18.060
way that I could think of,
which is to set the cornerRadius

00:36:18.060 --> 00:36:21.620
property on the underlying
CALayer behind the UIView.

00:36:21.760 --> 00:36:26.700
CornerRadius just lets us define that
the corners of a layer should be rounded.

00:36:26.700 --> 00:36:27.690
So it's really easy.

00:36:27.700 --> 00:36:28.340
It's one property.

00:36:28.340 --> 00:36:29.100
It's one value.

00:36:29.100 --> 00:36:31.940
You just set the radius,
and it just happens.

00:36:32.030 --> 00:36:35.910
But it's also quite slow because it can
require an off-screen rendering pass,

00:36:35.910 --> 00:36:40.760
and it will in this case because this
view actually has a bunch of subviews.

00:36:41.010 --> 00:36:43.710
The other thing that we have
masked here is that reflection,

00:36:43.930 --> 00:36:46.910
and the reason that's masked is because
the way I've implemented this reflection

00:36:47.230 --> 00:36:51.300
is by having two copies of that same
view hierarchy with the little rounded

00:36:51.300 --> 00:36:54.780
pill-shaped thing with the text,
the one at the top that's rendered,

00:36:54.780 --> 00:36:58.480
you know, full and clear,
and then there's another actually below

00:36:58.790 --> 00:37:03.090
it flipped on its Y axis and masked
with a gradient to make it look like it

00:37:03.230 --> 00:37:05.830
fades out and seem like a reflection.

00:37:06.130 --> 00:37:09.710
But that gradient mask is really
expensive because it requires that the

00:37:09.710 --> 00:37:13.720
entire view for that -- or the entire
view hierarchy for the bottom part

00:37:13.730 --> 00:37:17.020
of that label be rendered off-screen,
then the final off-screen

00:37:17.360 --> 00:37:21.180
image gets composited to the
frame buffer through a mask.

00:37:21.290 --> 00:37:25.120
So it's really expensive,
and it happens at every frame.

00:37:25.410 --> 00:37:26.140
So we've done this using the mask.

00:37:26.140 --> 00:37:27.980
We've done this using the
masks to bounds property.

00:37:28.010 --> 00:37:30.820
If you just set corner radius
or just set layer masks,

00:37:30.850 --> 00:37:34.730
you would actually find that your
drawing would not change in most cases

00:37:35.250 --> 00:37:42.830
because by default masks to bounds
-- I can't say masks -- is turned off.

00:37:43.120 --> 00:37:45.860
Actually, it may be masks to bounds if
you're asking the CA layer,

00:37:45.860 --> 00:37:47.980
but if you ask the UIView,
it's actually clips to bounds.

00:37:48.020 --> 00:37:50.420
We like to change names just
to confuse you a little bit,

00:37:50.440 --> 00:37:52.690
but they're actually
the exact same thing.

00:37:52.990 --> 00:37:58.560
We've done that with Corner Radius,
and CALayer masks, and Clips to Bounds,

00:37:58.560 --> 00:37:59.900
or Masks to Bounds.

00:37:59.930 --> 00:38:04.860
This is a really convenient
way to get these appearances,

00:38:04.860 --> 00:38:07.850
but they're pretty slow,
so we can do better.

00:38:08.110 --> 00:38:10.820
What techniques can we use to fix this?

00:38:10.900 --> 00:38:12.890
Well, there's a couple tricks
we can use to fake it.

00:38:12.900 --> 00:38:15.660
First, we can use contents-rect.

00:38:15.990 --> 00:38:17.900
Although actually we can't
in this particular example,

00:38:17.900 --> 00:38:18.890
but in some cases we could.

00:38:18.900 --> 00:38:25.900
Contents-rect defines which part of a
view's content actually gets rendered.

00:38:25.960 --> 00:38:30.170
So if you have a large image,
say you were maybe using some

00:38:30.170 --> 00:38:32.900
game development techniques
of having a very large image

00:38:32.900 --> 00:38:36.090
that contains all your sprites,
you can pick one of them out

00:38:36.090 --> 00:38:38.950
of it by using contents-rect to
define the part of your content

00:38:38.950 --> 00:38:40.710
image that actually gets rendered.

00:38:40.900 --> 00:38:44.590
So it's great and really helpful
if you're trying to clip out a

00:38:44.600 --> 00:38:46.900
rectangular part of the content.

00:38:46.900 --> 00:38:49.410
I'm not going to get too much into
that because it's actually not going

00:38:49.410 --> 00:38:51.870
to help us in this particular example.

00:38:51.920 --> 00:38:55.040
But if you have cases where you need to
clip out rectangular parts of content,

00:38:55.180 --> 00:38:57.900
go check out the documentation
on contents-rect.

00:38:57.900 --> 00:39:00.090
That may be able to help you out.

00:39:00.310 --> 00:39:02.770
What we're actually going to
do is use DrawRect to improve

00:39:02.770 --> 00:39:04.040
the performance of this.

00:39:04.320 --> 00:39:06.580
The idea will be that we want
to actually render all those

00:39:06.580 --> 00:39:10.190
expensive things up front to avoid
having to do them at every frame.

00:39:10.470 --> 00:39:13.840
And the other option that you could use,
which we again won't do here,

00:39:13.900 --> 00:39:16.990
is a transparent or opaque overlay,
drawing some additional content

00:39:17.000 --> 00:39:20.230
on top of views to mask out parts
that you don't want to be visible

00:39:20.530 --> 00:39:22.620
without requiring off-screen passes.

00:39:22.780 --> 00:39:25.480
For this example,
we could maybe use black corners

00:39:25.480 --> 00:39:28.860
around the edges that were rounded
pieces of content and drop them

00:39:28.900 --> 00:39:32.710
over top of our view just to obscure
the parts and make it look rounded.

00:39:32.770 --> 00:39:34.760
But of course,
in the actual app that we have,

00:39:34.780 --> 00:39:36.400
we can see through
this to the background,

00:39:36.400 --> 00:39:38.840
so that wouldn't really work for us.

00:39:38.920 --> 00:39:41.640
The other issue that we
have is group opacity here.

00:39:41.710 --> 00:39:44.080
Now, what do I mean by group opacity?

00:39:44.120 --> 00:39:47.520
Well, let's use this UI slider in order
to really explain what it means.

00:39:47.590 --> 00:39:52.310
And I'm going to set the alpha value on
these sliders to 50%. With the top one,

00:39:52.310 --> 00:39:54.980
I will have group opacity enabled,
and with the bottom one,

00:39:54.980 --> 00:39:56.600
I will have group opacity disabled.

00:39:56.900 --> 00:40:00.340
So when I set alpha with group opacity,
it fades out exactly

00:40:00.350 --> 00:40:03.120
like you'd expect to see,
and everything looks right.

00:40:03.120 --> 00:40:05.370
If I set alpha without
group opacity enabled,

00:40:05.630 --> 00:40:09.190
you see through the
knob to the track below.

00:40:09.510 --> 00:40:14.400
And the reason for that is UIkit
actually cheats a little bit by default.

00:40:14.400 --> 00:40:17.110
Because group opacity requires
an offscreen rendering pass,

00:40:17.200 --> 00:40:18.340
we don't do it normally.

00:40:18.340 --> 00:40:20.680
So if you set alpha on a
view that has sub views,

00:40:20.900 --> 00:40:23.650
all we do is multiply that alpha
down through all the sub views

00:40:23.920 --> 00:40:27.210
so they all render at 50% alpha,
which means that they actually end

00:40:27.210 --> 00:40:30.610
up transparent with respect to their
super view even though they should

00:40:30.620 --> 00:40:32.880
really be opaque like that top one.

00:40:32.880 --> 00:40:35.990
So there's a couple ways we can fix this.

00:40:36.070 --> 00:40:39.300
First we could re-enable group
opacity for all of UIkit.

00:40:39.350 --> 00:40:44.670
That would be setting the UI view group
opacity key in your Info.plist to yes.

00:40:44.720 --> 00:40:47.180
But this, of course,
turns back on that offscreen

00:40:47.290 --> 00:40:49.100
pass and makes things slow again.

00:40:49.100 --> 00:40:52.800
We could also pre-render our
view in draw rect and pay that

00:40:52.860 --> 00:40:57.180
cost once up front rather than
having to do it at every frame.

00:40:57.180 --> 00:41:00.030
The other option, if our content in the
view isn't changing,

00:41:00.090 --> 00:41:02.660
is to actually turn on
that should rasterize bit.

00:41:02.730 --> 00:41:05.760
This will cache offscreen our
entire view and make it much

00:41:05.780 --> 00:41:08.140
faster to render at every frame.

00:41:08.220 --> 00:41:09.200
Because it will just be copying
an image from that view.

00:41:09.200 --> 00:41:11.410
that off screen cache.

00:41:11.700 --> 00:41:13.840
So there's a couple
ways we could fix that.

00:41:13.880 --> 00:41:18.360
The other thing that we have going
wrong in this label is these shadows.

00:41:18.410 --> 00:41:20.480
And it's probably a little
bit difficult to see,

00:41:20.530 --> 00:41:23.400
but there's a very subtle shadow
behind the text in this label.

00:41:23.510 --> 00:41:24.610
It's pretty faint.

00:41:24.830 --> 00:41:30.250
I've done that using the shadow
properties on the CA layer.

00:41:30.380 --> 00:41:33.040
There's a shadow offset and shadow color.

00:41:33.110 --> 00:41:35.810
And they're really convenient,
but they're also really expensive.

00:41:35.980 --> 00:41:40.240
So we could do better than that with
a couple other techniques that Mathieu

00:41:40.290 --> 00:41:42.310
is going to come up and show you.

00:41:42.530 --> 00:41:46.390
So before we get started with the code,
I would like to show you some tools

00:41:46.400 --> 00:41:49.560
we can use to identify those issues.

00:41:49.730 --> 00:41:54.110
So the first thing you want
to do is launch Instruments.

00:41:56.320 --> 00:42:01.620
And attach a Core Animation template
to your iPad or iPhone.

00:42:01.670 --> 00:42:05.960
And you want to check the-- there it is.

00:42:06.410 --> 00:42:08.140
There's the off-screen rendering.

00:42:08.140 --> 00:42:12.530
That's going to put a wash on your views
where you actually draw off-screen.

00:42:12.640 --> 00:42:15.890
So let's check that on.

00:42:17.110 --> 00:42:17.620
There we go.

00:42:17.770 --> 00:42:21.780
So you see all our
views mostly are yellow.

00:42:21.780 --> 00:42:23.910
Turn it off.

00:42:24.080 --> 00:42:26.500
So that's really the first thing you
should do when you have a problem

00:42:26.500 --> 00:42:31.780
with performance and rendering issues,
is use Instrument and this template.

00:42:32.110 --> 00:42:34.980
So as Josh mentioned,
we're going to try to use DrawWrite

00:42:35.050 --> 00:42:38.260
to do most of what he was doing
before with Core Animation.

00:42:38.290 --> 00:42:43.570
And I'm going to show you what we
were using in Core Animation and

00:42:43.580 --> 00:42:45.420
what we use now in CG.

00:42:45.690 --> 00:42:50.020
So the first thing we're going to take
care of is the rounded corner background.

00:42:50.140 --> 00:42:53.400
So Josh used the radius corner,
but it's very expensive.

00:42:53.530 --> 00:42:55.900
But really what it is,
it's a Bezier pass with

00:42:55.940 --> 00:42:59.990
rounded corner that we render,
and we can draw directly as

00:42:59.990 --> 00:43:01.890
a background of our view.

00:43:04.000 --> 00:43:09.080
So the first thing we do here,
we have the background color.

00:43:09.590 --> 00:43:13.460
We do the background color,
and a bit later we

00:43:13.460 --> 00:43:18.740
have the radius corner,
and then we set setNiceToBounds.

00:43:18.860 --> 00:43:22.040
So what we do is create a
UI Bezier pass with rounded corner.

00:43:22.040 --> 00:43:25.000
We have those very nice convenience
methods to do that for you.

00:43:25.000 --> 00:43:27.730
You don't have to build a Bezier pass.

00:43:27.850 --> 00:43:31.320
And then we just choose the
same color and we fill it.

00:43:31.580 --> 00:43:40.750
So that take care of the,
we can remove the corner radius here,

00:43:40.750 --> 00:43:44.230
and we already win one off-screen pass.

00:43:44.480 --> 00:43:47.690
So next thing we want to do,
I'm going to show you is to draw

00:43:47.690 --> 00:43:51.000
the shadow and the text label.

00:43:51.020 --> 00:43:54.610
So before, as Josh mentioned,
we were using the shadow color,

00:43:54.620 --> 00:43:56.530
the shadow offset.

00:43:56.550 --> 00:44:01.670
That's very expensive to draw,
because Core Animation needs

00:44:01.730 --> 00:44:02.380
to render the,
needs to draw the shadow

00:44:02.380 --> 00:44:04.640
while it's rendering the text.

00:44:04.820 --> 00:44:06.630
So what we do,

00:44:06.860 --> 00:44:10.600
It's like we set a shadow
with the same property here

00:44:10.830 --> 00:44:12.440
that we were putting before.

00:44:12.510 --> 00:44:16.460
The same offset, the same blur,
and the same color.

00:44:16.780 --> 00:44:19.010
There's one thing, though,
that you should be careful

00:44:19.100 --> 00:44:20.270
before you do that.

00:44:20.490 --> 00:44:24.290
Core graphics draw as soon
as you ask it to draw.

00:44:24.450 --> 00:44:26.880
Core animation,
you can set a property and it's

00:44:26.880 --> 00:44:31.540
going to be rendered after the
transaction gets committed.

00:44:31.700 --> 00:44:33.810
Here, as soon as you say draw, it draws.

00:44:33.910 --> 00:44:38.420
So you need to set your shadow properties
before you start drawing anything,

00:44:38.510 --> 00:44:41.330
in this case the text.

00:44:42.460 --> 00:44:48.500
So you have the shadow property now,
and the shadow color.

00:44:48.500 --> 00:44:52.400
You draw the text, and you have this,
pretty much the same effect.

00:44:52.410 --> 00:44:56.310
So with that,
we're going to see that we already start

00:44:56.310 --> 00:44:59.400
rendering some of our label on screen.

00:44:59.400 --> 00:45:02.380
You see the top of the
label is perfectly rendered.

00:45:02.400 --> 00:45:06.390
You still have the nice shadow,
you still have the rounded corners.

00:45:06.390 --> 00:45:10.400
Maybe it's not very clear,
but we also have an alpha on our view,

00:45:10.400 --> 00:45:14.370
so you can see a little
bit of the line in behind.

00:45:14.390 --> 00:45:20.710
But we still have the reflection
that's still rendered off screen,

00:45:20.760 --> 00:45:25.270
and we want to take care of that.

00:45:26.140 --> 00:45:30.250
You're going to see in the
sample code that here we create

00:45:30.250 --> 00:45:32.520
an image with a gradient on it.

00:45:32.580 --> 00:45:36.800
We put that image on the layer,
and we set that layer as

00:45:36.800 --> 00:45:39.100
a mask layer on our view.

00:45:39.100 --> 00:45:41.100
And that's very expensive, too.

00:45:41.130 --> 00:45:45.100
But really,
we could do it also in DrawRect.

00:45:45.100 --> 00:45:50.100
So on the left side, on your left side,
you have what we used to do before.

00:45:50.100 --> 00:45:54.090
So we create an image with the gradient.

00:45:54.160 --> 00:45:57.300
We set that image on the layer,
and then we set that layer

00:45:57.390 --> 00:45:59.100
as a mask layer on our view.

00:45:59.330 --> 00:46:02.470
But really,
we can reuse a lot of the code we

00:46:02.520 --> 00:46:08.100
are using to create the gradient
in our DrawRect method directly.

00:46:08.100 --> 00:46:10.100
So here my view is reflected.

00:46:10.100 --> 00:46:13.100
So we create the same image,
the same gradient.

00:46:13.100 --> 00:46:14.960
You see the code is very similar.

00:46:15.100 --> 00:46:19.650
We just like switch the -- the
only thing that really changes the

00:46:19.670 --> 00:46:22.100
location because Core Animation and
CG have a different code in a space.

00:46:22.100 --> 00:46:25.100
But we have the same code.

00:46:25.100 --> 00:46:30.100
I mean, the complexity of doing
the gradient is the same.

00:46:30.940 --> 00:46:32.500
So we create an image.

00:46:32.620 --> 00:46:37.070
So you need a new context,
and you create this image.

00:46:38.090 --> 00:46:42.020
And then for the same reason that
we were setting up the shadow

00:46:42.020 --> 00:46:47.990
property before we draw the label,
you have to set that mask on the context

00:46:48.000 --> 00:46:51.600
before you actually draw anything
because it gets worn as soon as you ask.

00:46:51.640 --> 00:46:56.420
The only thing we did here in this all,
to try to optimize this,

00:46:56.420 --> 00:47:01.810
was moving some code around in the
drawRack method because drawRack

00:47:01.810 --> 00:47:06.450
is going to get called only once
before the animation and that's it.

00:47:06.580 --> 00:47:10.520
And that's something also very important,
that's because your frame size

00:47:10.520 --> 00:47:12.630
doesn't change during the animation.

00:47:12.640 --> 00:47:16.510
If your frame was changing,
you would have to use some other

00:47:16.870 --> 00:47:19.200
techniques to fix those issues here.

00:47:19.330 --> 00:47:22.820
So let's see,
now we have... We moved most of the

00:47:22.820 --> 00:47:27.520
drawing code out of the initializing
code to the drawRack method.

00:47:27.670 --> 00:47:32.630
So now if I go back to my Frog app,
you can see that all the drawing

00:47:33.020 --> 00:47:34.640
now is rendered on screen.

00:47:34.700 --> 00:47:36.440
And it's pretty fast.

00:47:36.480 --> 00:47:41.720
You want to avoid those yellow
wash on your UI as much as you can.

00:47:41.720 --> 00:47:45.350
Sometimes it's not possible,
but in this case it's possible and your

00:47:45.790 --> 00:47:49.640
animation is going to get faster or you
can do more things during your animation.

00:47:49.640 --> 00:47:51.580
Hope it was useful.

00:47:51.650 --> 00:47:53.390
Thank you very much.

00:47:55.500 --> 00:50:00.500
[Transcript missing]

00:50:00.800 --> 00:50:03.990
The problem is it's expensive,
because what Core Animation has to

00:50:04.140 --> 00:50:07.900
do is it has to go to the render
buffer behind your layer and sample

00:50:07.900 --> 00:50:11.340
the pixels from that in addition
to the pixels from your layer and

00:50:11.400 --> 00:50:12.700
smooth those against each other.

00:50:12.700 --> 00:50:16.470
Now we already know that if you
just have an image with a line

00:50:16.470 --> 00:50:20.700
in it and you rotate that image,
the line isn't really jaggy.

00:50:20.700 --> 00:50:24.930
The reason for that is that
Core Animation can sample just the

00:50:24.930 --> 00:50:29.600
pixels in the image of the layer
itself when rotating and figuring out

00:50:29.650 --> 00:50:31.700
the color value of that rotated pixel.

00:50:31.790 --> 00:50:35.130
So we're going to draw a transparent
border around our image so that

00:50:35.140 --> 00:50:37.400
when we sample at the edge,
we get some of that transparent

00:50:37.460 --> 00:50:41.700
border without having to go
all the way to the background.

00:50:41.750 --> 00:50:46.390
So this is our main view controller.

00:50:47.550 --> 00:50:50.600
And here's where we
create our image views.

00:50:50.630 --> 00:50:53.060
This is both the top image view,
the large one,

00:50:53.060 --> 00:50:55.300
and the bottom ones in the scroll view.

00:50:55.370 --> 00:50:59.590
So I'm just going to drag
a little code in here.

00:51:03.000 --> 00:51:08.760
We're creating a new UI image on
the fly using the froggy image,

00:51:08.760 --> 00:51:11.130
but putting a one-pixel
transparent border around it.

00:51:11.150 --> 00:51:15.430
We do that with the UIGraphics functions
that you may not have seen before,

00:51:15.460 --> 00:51:19.520
but which Mathieu used for
the mask in the last demo.

00:51:19.780 --> 00:51:24.860
UIGraphicsBeginImageContext creates
a new Core Graphics bitmap context.

00:51:24.860 --> 00:51:27.710
All it takes in this
particular form is a size,

00:51:27.890 --> 00:51:32.510
which is the original image size with
two pixels extra in each dimension.

00:51:32.570 --> 00:51:34.980
This is effectively what
UIKit is doing for you,

00:51:34.980 --> 00:51:37.070
and I think it's important
to remember this.

00:51:37.240 --> 00:51:40.700
When you implement DrawRect,
we're just going to set

00:51:40.740 --> 00:51:42.980
up a context for you,
call DrawRect,

00:51:43.050 --> 00:51:46.390
take the image out of that context,
and set it as the contents of the layer.

00:51:46.530 --> 00:51:50.270
Here we're sort of doing it up front,
and we're going to let UIImageView take

00:51:50.290 --> 00:51:53.390
care of the actual rendering
of that image from here on out.

00:51:53.620 --> 00:51:57.740
So we draw our froggy
into our larger image.

00:51:57.810 --> 00:52:00.470
We get the image out of the context.

00:52:00.600 --> 00:52:51.200
[Transcript missing]

00:52:51.500 --> 00:52:55.950
So now I'm going to go ahead
and launch my Froggy app again.

00:52:56.130 --> 00:53:01.160
And I'm proud to show you-- oh, well,
there's still a lot of yellow.

00:53:01.230 --> 00:53:05.000
There's still an off-screen rendering
pass being used on all those images.

00:53:05.090 --> 00:53:08.460
And I'm going to tell you about
why that isn't just a moment.

00:53:08.460 --> 00:53:12.510
There's one more thing that we
could do for this edge antelias-ing.

00:53:12.770 --> 00:53:14.590
Because we're running
a little low on time,

00:53:14.660 --> 00:53:16.720
I'm going to leave as an
exercise to the reader.

00:53:16.720 --> 00:53:19.340
But I'm just going to talk
you through it really quick.

00:53:19.340 --> 00:53:23.100
You may have noticed that before we
were just using UIImageImageNamed

00:53:23.100 --> 00:53:24.660
to refer to these froggies.

00:53:24.770 --> 00:53:27.880
And so the image being used on
the bottom and the image being

00:53:27.950 --> 00:53:29.700
used on the top was the same data.

00:53:29.740 --> 00:53:33.780
And you might ask, well,
why are we creating this new larger

00:53:33.820 --> 00:53:37.070
image with the transparent border twice?

00:53:37.270 --> 00:53:38.840
Now we're using double the pixel data.

00:53:38.840 --> 00:53:39.640
And you'd be right.

00:53:39.640 --> 00:53:43.680
So you could share that
data between the two images.

00:53:43.740 --> 00:53:45.910
But there's an issue with doing that too.

00:53:45.990 --> 00:53:48.420
If you look at the
froggies on the bottom,

00:53:48.460 --> 00:53:51.300
you'll note that--
they have jagged edges.

00:53:51.340 --> 00:53:55.040
And I just promised you that this
method would give you sort of smooth

00:53:55.040 --> 00:53:57.120
edges without performance costs.

00:53:57.120 --> 00:53:58.900
So why do they have jaggy edges?

00:53:58.980 --> 00:54:01.160
Well, it's the same image data.

00:54:01.200 --> 00:54:03.220
You have a really big frog image.

00:54:03.220 --> 00:54:04.880
Maybe it's 500 pixels wide.

00:54:04.960 --> 00:54:07.400
And you've drawn a one
pixel border around it.

00:54:07.540 --> 00:54:10.080
And then you've asked Core Animation to
scale that image down.

00:54:10.150 --> 00:54:12.200
Well, it's also going to
scale down your border.

00:54:12.250 --> 00:54:14.970
So now your one pixel transparent
border is maybe like a tenth

00:54:14.970 --> 00:54:16.740
of a pixel transparent border.

00:54:16.830 --> 00:54:19.690
And when you go to smooth,
you don't have so much of that extra

00:54:19.690 --> 00:54:21.780
fudge data to work with anymore.

00:54:21.780 --> 00:54:25.840
And so as an exercise for you all,
if you want to use this in your app,

00:54:25.840 --> 00:54:30.050
you have to be careful about using that
transparent border at the actual size of

00:54:30.070 --> 00:54:32.940
the contents you're going to care about.

00:54:33.070 --> 00:54:36.620
So let's get rid of the
last bit of wash here.

00:54:36.620 --> 00:54:39.000
And that last bit of wash
comes from the shadows.

00:54:39.000 --> 00:54:40.890
And Josh was telling you that
the shadows are really expensive.

00:54:40.940 --> 00:54:43.100
They have to do an extra
off-screen rendering pass.

00:54:43.100 --> 00:54:46.100
And that's just because if
there was a hole in the image,

00:54:46.120 --> 00:54:49.300
we wouldn't want to draw a
shadow filling that entire hole.

00:54:49.340 --> 00:54:51.720
We would just want to draw shadows
under the edge of the hole,

00:54:51.720 --> 00:54:53.340
very artfully and gracefully.

00:54:53.340 --> 00:54:54.170
And that's expensive.

00:54:54.260 --> 00:54:57.430
That requires an off-screen
rendering pass for Core Animation to

00:54:57.430 --> 00:54:59.480
figure out where the holes are.

00:54:59.480 --> 00:55:03.480
But it's often really helpful in
optimization of your apps to tell

00:55:03.900 --> 00:55:08.650
the system about the assumptions and
constraints of your application that

00:55:08.770 --> 00:55:11.360
it doesn't necessarily know about.

00:55:11.360 --> 00:55:14.900
In this case,
our frog images are all rectilinear,

00:55:14.900 --> 00:55:16.400
and they're all opaque.

00:55:16.400 --> 00:55:18.770
And the system doesn't know that.

00:55:18.830 --> 00:55:21.410
but we can tell it about
that assumption and get some

00:55:21.430 --> 00:55:23.590
improvement in our performance.

00:55:24.010 --> 00:55:27.030
One thing to keep in mind is you
may have noticed that the top frog

00:55:27.030 --> 00:55:29.780
image changed size when we rotated.

00:55:29.860 --> 00:55:34.330
And so we don't have a
constant size shadow.

00:55:34.430 --> 00:55:37.780
Our shadow is going to be one size in
portrait and another size in landscape.

00:55:37.840 --> 00:55:42.120
And so we can't do it, this optimization,
when we create the image view.

00:55:42.120 --> 00:55:44.480
We have to do it when we
lay the image view out.

00:55:44.560 --> 00:55:46.840
This is a method that gets
called both when we create the

00:55:46.840 --> 00:55:49.060
image views and when we rotate.

00:55:49.180 --> 00:55:52.950
And I'm just going to drop
some more magic code in here.

00:55:54.290 --> 00:55:57.270
And there's two parts to it.

00:55:57.450 --> 00:55:59.940
Let me address this first.

00:56:00.020 --> 00:56:03.150
We're going to use this shadow
path property of ca_layer.

00:56:03.240 --> 00:56:05.970
And with that property,
we can tell Core Animation,

00:56:06.070 --> 00:56:09.670
very specifically,
this is the shape of the contents.

00:56:09.820 --> 00:56:11.700
This is where I want
you to draw the shadow,

00:56:11.790 --> 00:56:12.840
and it's very fast.

00:56:12.840 --> 00:56:14.550
We do that with just a Bezier path.

00:56:14.700 --> 00:56:16.750
Our content is rectilinear,
and so we create a

00:56:16.880 --> 00:56:18.640
rectangular Bezier path.

00:56:18.750 --> 00:56:20.930
We could use this for
more complicated content,

00:56:20.930 --> 00:56:21.300
too.

00:56:21.300 --> 00:56:24.660
You may notice the popovers
in iOS are really fast,

00:56:24.730 --> 00:56:26.520
and they still have shadows.

00:56:26.660 --> 00:56:29.790
Part of the only reason they are
really fast is that we were able to

00:56:29.790 --> 00:56:33.570
create a UI Bezier path which describes
the shape of the popovers outline.

00:56:33.670 --> 00:56:38.570
You know, it's a rounded rect that is
unioned with the little arrow

00:56:38.570 --> 00:56:40.180
for the popovers pointer.

00:56:40.260 --> 00:56:42.850
And so you aren't limited
to really simple shapes.

00:56:42.880 --> 00:56:44.710
You can get kind of complex.

00:56:44.810 --> 00:56:49.200
The one other thing I want to draw your
attention to-- we're running out of time,

00:56:49.200 --> 00:56:51.270
so I may have to explain this a
little faster than I would like.

00:56:51.370 --> 00:56:54.160
is the fact that

00:56:54.520 --> 00:56:57.360
ShadowPath is a property
on Core Animation layers,

00:56:57.360 --> 00:56:59.340
and UIKit doesn't know about it.

00:56:59.340 --> 00:57:04.360
UIKit normally does a fair amount of
work to help you with implicit animations

00:57:04.360 --> 00:57:06.760
using this Begin Animations API.

00:57:06.760 --> 00:57:09.760
Those details are not really
necessary for you to understand,

00:57:09.760 --> 00:57:12.850
but one thing that you should
understand is that if you go changing

00:57:12.850 --> 00:57:16.020
properties in Core Animation which
don't have equivalents in UIKit,

00:57:16.230 --> 00:57:18.710
you're not going to get the
lovely automatic animation

00:57:18.710 --> 00:57:21.400
behavior that you're used to.

00:57:21.400 --> 00:57:23.320
Here we have to do it ourselves.

00:57:23.330 --> 00:57:23.900
It's not so hard.

00:57:23.900 --> 00:57:26.120
We just use this
CA Basic Animation class,

00:57:26.120 --> 00:57:30.220
and we tell it what we're changing,
where we're changing it from,

00:57:30.220 --> 00:57:34.020
and what we're setting it to,
and we give it a duration to animate.

00:57:34.020 --> 00:57:37.900
We're going to use the same
duration which is passed to us here,

00:57:37.900 --> 00:57:41.580
which was being used for the
rotation that's causing the

00:57:41.610 --> 00:57:43.000
size change in the first place.

00:57:43.040 --> 00:57:45.740
And it's important that we animate
this because when we change

00:57:45.830 --> 00:57:48.360
from portrait to landscape,
we want our shadow to

00:57:48.360 --> 00:57:51.480
animate size as well,
just as it was doing before.

00:57:51.480 --> 00:57:55.270
And we need it to animate at the
same speed so that the image doesn't

00:57:55.270 --> 00:57:58.840
change size faster than the shadow,
which would look very strange.

00:57:58.840 --> 00:58:01.420
So once we've created
this CA Basic Animation,

00:58:01.420 --> 00:58:03.040
we just add it to our layer.

00:58:03.040 --> 00:58:06.300
And then you'll see if we switch
back to this app one last time,

00:58:06.300 --> 00:58:08.530
hooray, hurrah,
all of the yellow is gone.

00:58:08.530 --> 00:58:10.470
And look how fast that rotation is.

00:58:10.470 --> 00:58:11.430
All right.

00:58:11.590 --> 00:58:12.660
Thanks, Andy.

00:58:12.740 --> 00:58:15.810
Sorry for the quick
run-through there at the end.

00:58:15.810 --> 00:58:19.520
If you have more information,
Bill Dudney is our evangelist.

00:58:19.520 --> 00:58:22.110
There's another session right after this,
Core Animation Essentials,

00:58:22.110 --> 00:58:24.200
to talk more about Core Animation.

00:58:24.200 --> 00:58:27.020
Bill will be giving the practical
drawing in iOS later today.
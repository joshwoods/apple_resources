WEBVTT

00:00:09.890 --> 00:00:11.580
All right, good morning, everybody.

00:00:11.670 --> 00:00:14.380
My name's Josh Shaffer,
and I will be joined in

00:00:14.380 --> 00:00:16.430
a little while by Eliza,
who's going to do some

00:00:16.430 --> 00:00:17.260
demos for us today.

00:00:17.260 --> 00:00:20.480
And today we're here to talk
about advanced techniques

00:00:20.480 --> 00:00:22.240
for use with UI ScrollView.

00:00:22.240 --> 00:00:24.810
So if you've seen our
UI ScrollView sessions in

00:00:24.810 --> 00:00:27.560
the previous couple of years,
we've talked about a

00:00:27.630 --> 00:00:31.060
variety of different things,
from tiling to zooming and

00:00:31.180 --> 00:00:32.920
all this kind of stuff.

00:00:33.220 --> 00:00:35.150
Today we're going to
focus on four specific,

00:00:35.220 --> 00:00:38.460
interesting, advanced techniques for
using UI ScrollView.

00:00:38.920 --> 00:00:41.380
So the first technique
will be infinite scrolling.

00:00:41.380 --> 00:00:44.790
This is the case where you have
some content and you want to keep

00:00:44.790 --> 00:00:48.270
scrolling in one direction or
the other direction forever and

00:00:48.270 --> 00:00:49.840
never hit the edge of the content.

00:00:49.840 --> 00:00:52.260
Maybe you've got some photos
and you want to wrap through

00:00:52.260 --> 00:00:53.760
them and never get to the edge.

00:00:53.760 --> 00:00:56.220
So we'll talk about how you can
do that using UI ScrollView.

00:00:56.220 --> 00:00:59.300
Second,
we'll talk about stationary views.

00:00:59.300 --> 00:01:01.520
Now,
there's a number of different reasons

00:01:01.520 --> 00:01:03.620
you might want to use stationary views.

00:01:03.660 --> 00:01:06.490
The kind of things we're
talking about here are views

00:01:06.490 --> 00:01:08.680
that remain pinned in place.

00:01:08.840 --> 00:01:11.370
So you can't just scroll in one
orientation but scroll with the

00:01:11.450 --> 00:01:14.300
scrolling content in the other,
sorry, not orientation but

00:01:14.330 --> 00:01:15.840
dimension or direction.

00:01:15.840 --> 00:01:20.080
So we'll get into that and look at
a couple techniques for doing that.

00:01:20.260 --> 00:01:23.260
Third, we're going to talk about
customizing touch handling.

00:01:23.260 --> 00:01:27.110
We've talked about this in the past,
so if you saw the ScrollView session two

00:01:27.110 --> 00:01:31.020
years ago or have looked at it on iTunes,
you may have seen some talk about using

00:01:31.020 --> 00:01:33.260
multi-touch in subviews of UI ScrollView.

00:01:33.260 --> 00:01:38.520
But with the introduction of UI Gesture
Recognizer in iOS 3.2 and 4.0,

00:01:38.520 --> 00:01:38.750
we've been able to do a lot of things.

00:01:38.850 --> 00:01:41.520
This has become much easier
and much more powerful.

00:01:41.620 --> 00:01:43.720
So we'll look at a couple
different examples of things

00:01:43.720 --> 00:01:46.620
you can do to customize touch
handling in your UI ScrollViews.

00:01:46.620 --> 00:01:49.610
And then finally,
we'll talk about redrawing after zooming.

00:01:49.620 --> 00:01:52.490
And this is, as a general concept,
is something we've

00:01:52.490 --> 00:01:53.620
talked about in the past.

00:01:53.620 --> 00:01:57.620
But we're going to look at one specific
technique today that is really useful

00:01:57.620 --> 00:02:02.080
when you have small bits of content
that you want to redraw at a higher

00:02:02.080 --> 00:02:03.610
resolution after you're done zooming.

00:02:03.620 --> 00:02:07.590
So we'll get through to all of
these things over the next hour.

00:02:07.750 --> 00:02:09.820
But just to get started,
and make sure that we're all on

00:02:09.840 --> 00:02:12.290
the same page in case there's
anyone here who hasn't done

00:02:12.290 --> 00:02:15.430
much with UI ScrollView before,
I just want to do a really quick

00:02:15.490 --> 00:02:18.940
five-minute review of the basics
of UI ScrollView and how you get

00:02:19.020 --> 00:02:22.490
it configured and get started
using scrolling and zooming.

00:02:22.680 --> 00:02:25.610
So right off the bat,
if you have some content,

00:02:25.670 --> 00:02:28.320
there's only one thing that you
have to do in order to begin

00:02:28.320 --> 00:02:29.680
scrolling it with a UI ScrollView.

00:02:29.680 --> 00:02:32.560
And that is to set your content offset.

00:02:32.800 --> 00:02:35.980
So this just tells the ScrollView how
much content you have and how

00:02:35.980 --> 00:02:38.600
much it needs to be able to
scroll in the X and Y dimensions.

00:02:38.600 --> 00:02:41.720
So in this case,
we've got our collection of photos,

00:02:41.720 --> 00:02:44.600
and we've just defined our content size,
the width and height,

00:02:44.600 --> 00:02:46.410
to be the size of the scrollable content.

00:02:46.600 --> 00:02:49.000
And with that done,
you can already allow your

00:02:49.000 --> 00:02:50.520
users to scroll up and down.

00:02:50.650 --> 00:02:53.600
So it's really,
really easy to get started.

00:02:53.760 --> 00:02:57.220
From there, you may sometimes,
while you're using your

00:02:57.220 --> 00:03:00.690
application -- or rather,
within your application while writing it,

00:03:00.700 --> 00:03:03.110
want to be able to find out
programmatically which part of

00:03:03.110 --> 00:03:04.550
the content is currently visible.

00:03:04.680 --> 00:03:06.600
And that's also really easy to do.

00:03:06.600 --> 00:03:08.520
The way we refer to that in
the -- in the Google Docs,

00:03:08.520 --> 00:03:09.250
is we refer to it as a "content
size." And that's what we're trying

00:03:09.420 --> 00:03:12.490
to do in the world of UI ScrollView,
is as the content offset.

00:03:12.520 --> 00:03:16.890
So content offset is the point in your
content that's currently visible at

00:03:16.940 --> 00:03:19.520
the top left of the ScrollView's frame.

00:03:19.520 --> 00:03:22.490
So in this case, we have no content to
scroll horizontally.

00:03:22.520 --> 00:03:24.520
We can only scroll vertically.

00:03:24.520 --> 00:03:26.370
So content offset X is always zero.

00:03:26.520 --> 00:03:29.110
And our content offset Y,
with the point we're

00:03:29.110 --> 00:03:31.990
scrolled to right now,
is the point in that content visible

00:03:31.990 --> 00:03:33.520
at the top left of the ScrollView.

00:03:33.520 --> 00:03:38.050
So it's just that distance there on
the left from the top of our content.

00:03:38.300 --> 00:05:23.400
[Transcript missing]

00:05:23.610 --> 00:05:26.190
So we can do that really easily,
actually,

00:05:26.250 --> 00:05:29.500
and with a content size that isn't
significantly larger than what's

00:05:29.590 --> 00:05:31.420
actually visible at any one time.

00:05:31.530 --> 00:05:34.420
So if we call that gray
box there our content size,

00:05:34.450 --> 00:05:37.110
you can see that we've only
made it maybe twice the size

00:05:37.130 --> 00:05:39.390
of what's visible on screen.

00:05:39.640 --> 00:05:42.750
And once we've done that,
then the idea will be that the

00:05:42.750 --> 00:05:45.640
user puts their finger down and
scrolls the content to the side.

00:05:45.790 --> 00:05:47.860
We swap out the photos,
so the one that went off screen

00:05:47.860 --> 00:05:50.720
we remove from our scroll view,
and we bring a new one in.

00:05:50.810 --> 00:05:52.890
If that technique's not
real familiar to you,

00:05:52.890 --> 00:05:55.530
there's a whole session from
last year about how you can

00:05:55.680 --> 00:05:57.110
do paging through photos.

00:05:57.250 --> 00:06:00.030
I would recommend looking at
it on iTunes U and downloading

00:06:00.030 --> 00:06:01.580
the PhotoScroller sample.

00:06:01.650 --> 00:06:04.910
We won't get too much into the specifics
of how you do that tiling bit today.

00:06:05.120 --> 00:06:08.260
But the interesting part is that now
we're at the edge of our content again.

00:06:08.500 --> 00:06:10.500
So if we did nothing else,
our user now would start

00:06:10.500 --> 00:06:14.020
bouncing against the edge,
which is absolutely not what we want.

00:06:14.260 --> 00:06:16.880
So we can fix this by doing
just two small things.

00:06:17.020 --> 00:06:19.910
The first is we can adjust our
content offset so that we get

00:06:20.050 --> 00:06:22.490
centered back in the scrollable area.

00:06:22.650 --> 00:06:25.230
So we'll do that,
and that'll shift our content size

00:06:25.370 --> 00:06:29.030
back to be centered in that scroll
view so that we can again scroll either

00:06:29.030 --> 00:06:30.940
left or right and not hit an edge.

00:06:31.020 --> 00:06:33.860
But as you can see, if we just did that,
our content would actually be back off

00:06:34.040 --> 00:06:36.130
screen again and not in the right spot.

00:06:36.220 --> 00:06:38.360
So once we've adjusted
the content offset,

00:06:38.500 --> 00:06:42.090
we also have to then adjust the
frames of our subviews by the exact

00:06:42.150 --> 00:06:46.580
same amount so that they end up
back centered in that content area.

00:06:46.640 --> 00:06:50.540
Now, I did this in two steps here just
to illustrate that there's two steps

00:06:50.540 --> 00:06:51.840
that you have to take to do this.

00:06:51.920 --> 00:06:55.160
But if you do them one after the other
in the same turn of your run loop,

00:06:55.300 --> 00:06:57.410
it will be completely
transparent to your users.

00:06:57.510 --> 00:07:00.390
There will be no indication
that you've done any of this.

00:07:00.450 --> 00:07:02.830
It will just happen all
at the same time and,

00:07:02.860 --> 00:07:04.990
you know, completely flawlessly.

00:07:05.120 --> 00:07:08.540
So again, user puts their finger down,
they scroll to the edge,

00:07:08.640 --> 00:07:11.940
we'll recenter our content offset
and shift those subviews back so that

00:07:11.940 --> 00:07:14.210
they're centered on screen again.

00:07:15.220 --> 00:07:16.700
So that's what we want to do.

00:07:16.840 --> 00:07:19.500
Where do we do this,
and how can we implement it?

00:07:19.500 --> 00:07:23.700
Well, the basic idea that we're going for
here is to relay out those subviews

00:07:23.700 --> 00:07:25.660
every time that the user scrolls.

00:07:25.660 --> 00:07:29.880
So a very natural place to implement
this is in the layoutSubviews method.

00:07:30.080 --> 00:07:34.150
LayoutSubviews is, as you know,
a method on UIView that you can override.

00:07:34.150 --> 00:07:36.440
So in order to do that,
we actually have to

00:07:36.440 --> 00:07:37.940
subclass UIScrollView.

00:07:37.940 --> 00:07:41.170
You could also do some of the
same stuff by implementing the

00:07:41.170 --> 00:07:43.780
scrollViewDidScrollDelegate method.

00:07:44.300 --> 00:07:47.960
But we'll get to some other
things later in the session that,

00:07:48.260 --> 00:07:50.460
for various reasons,
it's interesting to have

00:07:50.460 --> 00:07:52.100
subclassed layoutSubviews.

00:07:52.100 --> 00:07:55.410
So we'll use layoutSubviews in this case.

00:07:55.660 --> 00:07:59.010
Once we've done that,
there's just two methods that we can call

00:07:59.010 --> 00:08:00.800
in order to do those adjustments we saw.

00:08:01.060 --> 00:08:04.240
First, we'll use setContentOffset
to shift that content back,

00:08:04.300 --> 00:08:06.940
and we'll just shift it over
so we're centered again.

00:08:07.010 --> 00:08:11.480
And then we'll use either setFrame
or setCenter to adjust the offsets

00:08:11.510 --> 00:08:15.690
of those subviews so that they end up
back where we want them in the center.

00:08:15.820 --> 00:08:17.030
So really not very much to it.

00:08:17.080 --> 00:08:19.900
It's a very simple concept, really.

00:08:19.940 --> 00:08:22.520
And to give us a demo of how that's
all going to work and fit together,

00:08:22.520 --> 00:08:25.290
let's have Eliza come
up and show it to us.

00:08:30.200 --> 00:10:00.800
[Transcript missing]

00:10:01.060 --> 00:10:04.590
I'm also going to set the
scroll indicator style to white,

00:10:04.590 --> 00:10:07.470
because I think that's going to show
up best against a dark background,

00:10:07.500 --> 00:10:11.510
so that you'll be able to see the
scroll indicators jump to the center.

00:10:12.010 --> 00:10:14.480
All right,
so now we need to go down here to

00:10:14.480 --> 00:10:18.220
our layout section and write the
method that's going to do this

00:10:18.220 --> 00:10:20.480
recentering trick that Josh described.

00:10:20.630 --> 00:10:23.240
So I'm going to write a method
called recenterIfNecessary,

00:10:23.240 --> 00:10:27.350
and in it, I'm going to compute whether
it's time to recenter.

00:10:27.430 --> 00:10:33.000
And I'm going to do that by first finding
out what our current content offset is.

00:10:33.200 --> 00:10:36.820
And I also want to calculate what
the content offset that would

00:10:36.940 --> 00:10:39.590
be perfectly centered in the
middle of our content would be.

00:10:39.770 --> 00:10:44.500
So I'm going to find out
what our content width is.

00:10:44.580 --> 00:10:48.540
And then I'm going to compute
what would be that center offset

00:10:48.650 --> 00:10:52.040
x that would leave the exact same
amount of content on both sides.

00:10:52.140 --> 00:10:56.290
And I use the bounds property of
the scroll view to compute that.

00:10:58.510 --> 00:11:01.980
The distance from the center is
the absolute value of where we

00:11:01.990 --> 00:11:04.920
are now minus where we want to be.

00:11:06.180 --> 00:11:10.370
And if that distance gets big enough,
so if we've scrolled far enough

00:11:10.460 --> 00:11:13.110
away from that center point,
we're going to pick ourselves

00:11:13.200 --> 00:11:14.180
up and recenter ourselves.

00:11:14.200 --> 00:11:17.420
So there's a decision to be made
about how much counts as far

00:11:17.420 --> 00:11:20.200
enough away from the center so
that we should do this trick.

00:11:20.200 --> 00:11:22.330
We don't want to do it at every frame,
just because that would

00:11:22.330 --> 00:11:24.700
be an awful lot of work,
so we want to allow for some

00:11:24.700 --> 00:11:28.200
scrolling to happen before we do it.

00:11:28.200 --> 00:11:32.760
Again, pretty arbitrarily,
I'm choosing to allow you to get about

00:11:32.760 --> 00:11:36.940
a quarter of the content width away
from the center before we'll pick you

00:11:36.940 --> 00:11:38.200
up and put you back in the middle.

00:11:38.200 --> 00:11:40.180
You could experiment
with different values.

00:11:40.180 --> 00:11:42.200
It shouldn't matter too much.

00:11:42.200 --> 00:11:45.350
So if we've gotten far
enough away from the center,

00:11:45.350 --> 00:11:48.650
we are going to change our
content offset by using the

00:11:48.820 --> 00:11:53.170
center offset that we calculated,
but we're going to leave

00:11:53.170 --> 00:11:55.160
the y offset the same.

00:11:55.210 --> 00:11:57.200
There's my mouse.

00:11:57.200 --> 00:11:58.190
Because we're only doing this trick now.

00:11:58.280 --> 00:12:00.200
We're only doing this trick
in the horizontal direction,

00:12:00.200 --> 00:12:02.150
and we want to leave the
vertical scrolling alone.

00:12:02.200 --> 00:12:05.920
You could do this exact same thing
to get infinite scrolling in the

00:12:05.920 --> 00:12:09.940
vertical direction by adjusting
your center point relative to the

00:12:09.950 --> 00:12:12.190
height of your scroll view as well.

00:12:13.230 --> 00:12:15.670
All right, and the last step -- oh,
sorry, one more step.

00:12:16.000 --> 00:12:19.680
So Josh mentioned that we need
to change our content offset,

00:12:19.820 --> 00:12:23.550
and we also need to move any subviews
of our ScrollView back over so that

00:12:23.550 --> 00:12:25.900
they don't appear to change position.

00:12:26.180 --> 00:12:29.720
We don't have any content yet,
so I'm just going to write a comment

00:12:29.720 --> 00:12:32.610
that when we add some content,
we need to remember to

00:12:32.610 --> 00:12:34.100
move it at this point.

00:12:34.290 --> 00:12:37.860
And then we're going to call
this "recenterIfNecessary"

00:12:37.860 --> 00:12:40.100
method from layout subviews.

00:12:40.100 --> 00:12:43.170
Layout subviews is called at
every frame of zooming and

00:12:43.230 --> 00:12:45.100
at every frame of scrolling.

00:12:45.100 --> 00:12:50.100
So every time that the content
that our ScrollViews bounds change,

00:12:50.100 --> 00:12:52.900
we're going to hit this,
which will give us the

00:12:52.900 --> 00:12:55.010
opportunity to recenter.

00:12:55.750 --> 00:13:01.450
and I will be talking about how to
change the resolution of the image.

00:13:06.110 --> 00:13:08.670
All right,
so you just see an empty blue view.

00:13:08.670 --> 00:13:11.340
But as I start scrolling,
I hope that the content,

00:13:11.340 --> 00:13:14.100
that the scroll indicators are visible.

00:13:14.100 --> 00:13:15.050
I hope they are.

00:13:15.100 --> 00:13:18.120
So if you look at that bottom one,
as I scroll,

00:13:18.120 --> 00:13:21.900
if I get close enough to the edge,
it jumps to the center.

00:13:22.100 --> 00:13:23.380
Can everyone see that?

00:13:23.590 --> 00:13:23.750
Yeah?

00:13:23.840 --> 00:13:24.500
All right, cool.

00:13:24.610 --> 00:13:27.900
So it jumps to the center because
it hit that far enough away from

00:13:27.900 --> 00:13:30.960
the center thing that we added,
and I can do it in the other direction,

00:13:30.960 --> 00:13:31.380
too.

00:13:31.470 --> 00:13:33.130
It will jump to the center.

00:13:33.490 --> 00:13:36.460
And so, of course, the scroll indicator
gives away the trick,

00:13:36.470 --> 00:13:38.300
so we don't actually
want that to be there,

00:13:38.300 --> 00:13:41.230
but this is just to illustrate
what's going on with the technique.

00:13:41.400 --> 00:13:45.960
So next, let's add some content to this.

00:13:46.080 --> 00:13:49.240
I was thinking when I was preparing
this demo about what kind of content

00:13:49.240 --> 00:13:52.910
you would want to scroll infinitely,
and I was also trying to figure out

00:13:53.010 --> 00:13:57.640
what you could do if you have no
artistic skills in order to add that.

00:13:57.730 --> 00:14:01.800
So I made this little -- here,
I'll add this drawer.

00:14:01.800 --> 00:14:05.340
So I made this little subclass
of UIView called a BuildingView,

00:14:05.340 --> 00:14:08.030
and what it does is it
produces a random building,

00:14:08.030 --> 00:14:11.940
which is a different color and with
different style windows and stuff.

00:14:12.110 --> 00:14:15.050
And so I figured we could make this
-- we can scroll infinitely down

00:14:15.050 --> 00:14:17.260
a street where we'll keep putting
more and more buildings there

00:14:17.260 --> 00:14:20.510
to fill the space as you scroll.

00:14:20.800 --> 00:14:24.540
So we're going to use that here to
add some content that we're going to

00:14:24.620 --> 00:14:26.510
tile as we do this infinite scrolling.

00:14:26.590 --> 00:14:30.560
So I'm going to import
that building header.

00:14:31.000 --> 00:14:38.210
I'm also going to add a class
continuation to infinite scroll view

00:14:38.350 --> 00:14:39.880
subclass so that we can add some --

00:14:40.360 --> 00:14:42.180
Ivar's that we're going to need.

00:14:42.260 --> 00:14:46.010
So the idea is going to be that
we're going to tile these buildings.

00:14:46.010 --> 00:14:50.550
And if you've seen our previous sessions,
you'll see that we've almost always,

00:14:50.550 --> 00:14:52.800
it almost always comes down to tiling.

00:14:52.800 --> 00:14:56.860
So we're going to keep an array of
buildings that are visible right now.

00:14:56.860 --> 00:14:58.920
So we're going to need this.

00:14:59.620 --> 00:15:02.800
We're going to add a new
building to a container view

00:15:02.800 --> 00:15:05.120
that contains all the buildings.

00:15:05.120 --> 00:15:09.080
The reason for doing that rather
than adding them directly as

00:15:09.080 --> 00:15:13.080
subviews of the ScrollView is
that later when we add zooming,

00:15:13.080 --> 00:15:17.400
it will be convenient to have a super
view that we can return from the

00:15:17.400 --> 00:15:20.420
ViewForZoomingInScrollView method.

00:15:20.640 --> 00:15:25.430
So let's go ahead and create these here.

00:15:25.690 --> 00:15:27.600
Scroll down.

00:15:27.680 --> 00:15:29.600
So we're going to create this
array of visible buildings,

00:15:29.600 --> 00:15:34.870
and we're going to create
our building container view.

00:15:35.280 --> 00:15:38.520
and we'll add it as a
subview of the ScrollView.

00:15:38.640 --> 00:15:42.200
I'm using the content size to determine
the size of the building container view,

00:15:42.200 --> 00:15:44.800
so it will just be the same size
as the ScrollView's content,

00:15:44.930 --> 00:15:46.740
although it won't in fact
be full of buildings.

00:15:46.740 --> 00:15:50.810
We're going to tile them so that only
the visible ones appear at a time.

00:15:51.050 --> 00:15:55.880
All right, so now in layout subviews,
let's create these buildings.

00:15:55.910 --> 00:15:59.340
So the idea is going to be-- oh, sorry,
I forgot one other thing

00:15:59.340 --> 00:16:00.190
that I wanted to do.

00:16:00.230 --> 00:16:02.580
I want to change this content height.

00:16:02.880 --> 00:16:05.170
So instead of 500,
which I picked arbitrarily,

00:16:05.170 --> 00:16:07.710
we'll make it the height of
the tallest possible building,

00:16:07.710 --> 00:16:10.140
which my little building
view subclass can tell us.

00:16:10.290 --> 00:16:13.400
And we also want to get rid of these
scroll indicators while we're at it.

00:16:13.400 --> 00:16:16.260
We don't want to see that
horizontal scroll indicator,

00:16:16.260 --> 00:16:19.060
because it indicates that we're
jumping back to the center,

00:16:19.060 --> 00:16:20.300
which we're trying to hide.

00:16:20.400 --> 00:16:24.940
So I'm going to say don't show a
horizontal scroll indicator at all.

00:16:25.160 --> 00:16:29.290
Okay, so in LayoutSubviews,
we need to calculate what are the visible

00:16:29.290 --> 00:16:33.400
bounds of our ScrollView right now,
so that we can fill that

00:16:33.400 --> 00:16:36.350
visible width with buildings.

00:16:36.630 --> 00:16:40.030
So we get the bounds of the ScrollView,
and we can then use those to

00:16:40.030 --> 00:16:45.500
compute the minimum and maximum
visible X values of the ScrollView.

00:16:45.660 --> 00:16:48.010
And at this point,
we can now fill that visible

00:16:48.010 --> 00:16:49.490
region with buildings.

00:16:49.490 --> 00:16:51.650
And I'm going to take a
bit of a shortcut here,

00:16:51.650 --> 00:16:55.610
because we've gone through tiling in
detail in a couple other sessions,

00:16:55.640 --> 00:16:57.500
and it's all in the sample code.

00:16:57.500 --> 00:17:03.500
So I'm going to make a little helper
method that does the tiling for us.

00:17:03.500 --> 00:17:06.500
You can check out how this is
implemented in the sample code.

00:17:06.500 --> 00:17:10.610
I'm going to call it from layoutSubviews.

00:17:10.800 --> 00:17:13.780
What it does is it takes the
minimum x and the maximum x,

00:17:13.840 --> 00:17:16.490
and it makes sure that there are
buildings in that entire area.

00:17:16.750 --> 00:17:19.210
It also makes sure that the
buildings that are outside of

00:17:19.220 --> 00:17:22.120
that area have been removed,
so that we're not having an

00:17:22.120 --> 00:17:24.900
incremental growth in memory usage.

00:17:25.040 --> 00:17:30.720
I'm going to paste the actual
work there that gets done.

00:17:31.140 --> 00:17:32.560
Don't worry too much about this.

00:17:32.560 --> 00:17:34.870
You can see it's not
actually that much code.

00:17:35.000 --> 00:17:36.450
All right.

00:17:37.020 --> 00:17:39.680
So once we've done that,
and we've got our

00:17:39.690 --> 00:17:42.510
buildings tiling the area,
all we need to do is remember to come

00:17:42.510 --> 00:17:48.410
back here and move the content by the
amount that we adjusted the content

00:17:48.770 --> 00:17:50.890
offset so that it appears to stay still.

00:17:51.000 --> 00:17:57.000
So we'll do that by iterating through the
buildings in our visible buildings array.

00:17:57.000 --> 00:17:58.860
We'll find each building center.

00:17:59.100 --> 00:18:02.000
We'll adjust it by the amount that
our content offset just changed.

00:18:02.000 --> 00:18:03.830
And then we'll reset it
as the building center.

00:18:03.830 --> 00:18:04.990
And we should be good to go.

00:18:05.000 --> 00:18:08.960
So I'm going to go ahead and run this.

00:18:12.280 --> 00:18:14.960
So here's some buildings.

00:18:14.990 --> 00:18:18.320
And as I scroll, new ones come in.

00:18:18.320 --> 00:18:21.800
I can scroll back the other way,
and we see new ones appear that way.

00:18:21.870 --> 00:18:24.800
And I can just keep doing
this for as long as I want,

00:18:24.800 --> 00:18:26.570
and we never get to the edge.

00:18:26.580 --> 00:18:31.080
So indefinitely many infinite buildings.

00:18:31.090 --> 00:18:33.700
All right, so that's--

00:18:37.630 --> 00:18:40.790
So that's an infinite scroll view,
and I'm gonna turn it back over to Josh.

00:18:40.800 --> 00:18:45.440
- All right, thanks Eliza.

00:18:45.440 --> 00:18:47.190
So, infinite scroll views.

00:18:47.380 --> 00:18:51.640
Next up, we have stationary, header,
footer, and other random views that you

00:18:51.640 --> 00:18:52.910
might like to keep in place.

00:18:52.920 --> 00:18:56.420
So, what are we trying to do here?

00:18:56.450 --> 00:18:58.630
Well,
let's say that we've got some large piece

00:18:58.630 --> 00:19:02.020
of content that we wanna zoom in on,
but we wanna have a piece

00:19:02.100 --> 00:19:04.790
of a header view up at the
top that remains stationary,

00:19:04.850 --> 00:19:06.920
it will not zoom with the content.

00:19:06.970 --> 00:19:09.940
So, when the user zooms in on
that large image there,

00:19:09.980 --> 00:19:12.080
the header will not zoom in.

00:19:12.100 --> 00:19:14.540
As the user scrolls
that image horizontally,

00:19:14.570 --> 00:19:17.190
that header will remain pinned in place.

00:19:17.290 --> 00:19:20.680
But as the user scrolls vertically,
we want this header to scroll off to make

00:19:20.680 --> 00:19:25.400
sure that we have the maximum available
area to actually view that photo.

00:19:25.580 --> 00:19:28.010
So we really want that header view
to be part of the scroll view,

00:19:28.010 --> 00:19:29.940
because we want it to scroll vertically.

00:19:30.000 --> 00:19:32.990
We just want to prevent it from
zooming or scrolling horizontally.

00:19:33.140 --> 00:19:35.890
And then when the user zooms back down,
we just want it to slide

00:19:35.890 --> 00:19:37.520
back in with that content.

00:19:37.680 --> 00:19:40.340
So this is pretty easy to do, too.

00:19:40.750 --> 00:19:44.440
Let's take a look at where we
might configure our views in order

00:19:44.440 --> 00:19:45.610
to get this kind of behavior.

00:19:46.100 --> 00:19:48.300
Because if you've used zooming
in UIScrollView before,

00:19:48.300 --> 00:19:52.100
you know that normally you'll just
have one subview of the UIScrollView,

00:19:52.180 --> 00:19:54.580
and you always use that as
the view that's zooming.

00:19:54.770 --> 00:19:57.840
So it's a little bit unusual
to actually have a second view

00:19:57.840 --> 00:19:59.010
in your zooming scroll view.

00:19:59.250 --> 00:20:01.090
But it does actually work,
and you can do it.

00:20:01.110 --> 00:20:02.860
We just have a couple things
that we have to do to make

00:20:02.910 --> 00:20:04.100
sure it works the way we want.

00:20:04.100 --> 00:20:07.560
So we'll have this large external
UIScrollView that's going

00:20:07.560 --> 00:20:08.520
to take up our full screen.

00:20:08.600 --> 00:20:10.970
And then we're going to
add two subviews to it.

00:20:11.290 --> 00:20:13.100
The first will be that header view.

00:20:13.100 --> 00:20:15.190
And again,
this will not be the view that's zooming,

00:20:15.190 --> 00:20:17.600
and it will not be a subview
of the view that's zooming.

00:20:17.610 --> 00:20:20.600
It's just going to be a direct
subview of the scroll view.

00:20:20.680 --> 00:20:23.670
We'll then add another
UIImageView subview of this scroll view,

00:20:24.110 --> 00:20:27.500
which we actually will return from
the ViewForZoomingInScrollViewDelegate

00:20:27.500 --> 00:20:27.960
method.

00:20:28.160 --> 00:20:31.790
So we now have two direct
subviews of that UIScrollView.

00:20:32.700 --> 00:20:36.350
So let's see what would happen if we
just did that and did nothing else and

00:20:36.360 --> 00:20:38.280
allowed the user to try and zoom in.

00:20:38.470 --> 00:20:42.100
They would put their fingers down,
they'd pinch them apart, and well,

00:20:42.100 --> 00:20:44.180
it almost did what we want,
but there's still a couple

00:20:44.220 --> 00:20:45.100
things that are wrong.

00:20:45.230 --> 00:20:47.760
First of all, that header view actually
shifted off screen,

00:20:47.760 --> 00:20:50.360
which is exactly what we
didn't want to have happen.

00:20:50.430 --> 00:20:52.940
And it also,
you can't really tell from this,

00:20:53.090 --> 00:20:56.800
but believe me when I tell you that
our content size is now incorrect,

00:20:56.880 --> 00:20:59.430
and we would not be able to
scroll all the way to the

00:20:59.430 --> 00:21:01.200
bottom of our image anymore.

00:21:01.440 --> 00:21:04.390
But at least we are partway there in
that the header view did not zoom,

00:21:04.470 --> 00:21:06.100
so we've got that going.

00:21:06.140 --> 00:21:09.260
So first let's fix the
header positioning.

00:21:09.390 --> 00:21:13.040
As we said earlier,
the position of the scroll view,

00:21:13.040 --> 00:21:16.880
or the part of the scroll view that's
currently visible is the content offset.

00:21:16.910 --> 00:21:18.730
And in this case,
we only care about the content

00:21:18.730 --> 00:21:22.880
offset.x because we wanna keep that
header view stationary horizontally.

00:21:22.940 --> 00:21:25.580
So in our layoutSubviews method,
now that we already have

00:21:25.730 --> 00:21:28.830
our scroll view subclassed,
we can just override that

00:21:28.830 --> 00:21:34.880
layoutSubviews and make sure that
our subviews frames origin x always

00:21:34.880 --> 00:21:37.040
matches the content offset.x.

00:21:37.070 --> 00:21:39.790
Because as we scroll,
the content offset.x is always

00:21:39.790 --> 00:21:43.360
the portion of the content visible
at the left of the scroll view.

00:21:43.390 --> 00:21:45.920
So if we make our subviews
frame always match that,

00:21:45.950 --> 00:21:48.720
it will just appear to
remain stuck in place,

00:21:48.720 --> 00:21:51.380
a pin to that left side
of the scroll view.

00:21:51.930 --> 00:21:54.400
But now I did mention that
there's this one other problem,

00:21:54.400 --> 00:21:55.660
and that's our content size.

00:21:55.820 --> 00:21:58.960
So I've highlighted that gray box,
which indicates our content size,

00:21:58.960 --> 00:22:00.080
so it's a little easier to see.

00:22:00.080 --> 00:22:03.050
And the reason this happens
is that ScrollView zooming,

00:22:03.050 --> 00:22:05.760
when you return a view
for zooming in ScrollView,

00:22:05.760 --> 00:22:08.120
the ScrollView automatically,
while zooming,

00:22:08.120 --> 00:22:12.440
sets its own content size to match
the frame size of that zoom view.

00:22:13.090 --> 00:22:16.620
So while you're pinching in,
or while you programmatically zoom in,

00:22:16.730 --> 00:22:19.640
at every new content size,
or every new zoom scale, rather,

00:22:19.870 --> 00:22:23.070
the ScrollView has adjusted its
own content size to match the new

00:22:23.070 --> 00:22:24.620
zoomed size of your zoom view.

00:22:24.620 --> 00:22:27.380
But in this case,
we have a bit of extra content that's

00:22:27.380 --> 00:22:29.200
not included in that zoom view.

00:22:29.200 --> 00:22:31.460
We've got that header on top,
and the ScrollView doesn't

00:22:31.460 --> 00:22:32.310
know about that.

00:22:32.430 --> 00:22:35.640
So we actually need to include
that extra height ourselves.

00:22:35.640 --> 00:22:39.560
And we can do that because
UIScrollView adjusts its own content

00:22:39.680 --> 00:22:42.270
size by calling selfSetContentSize.

00:22:43.080 --> 00:22:47.390
So in our subclass,
we can override setContentSize and

00:22:47.390 --> 00:22:50.130
add in that extra header height that
the ScrollView didn't know about.

00:22:50.140 --> 00:22:53.250
So we can just add that additional
height from the top to calculate

00:22:53.310 --> 00:22:56.920
the appropriate larger content size,
and then call superSetContentSize

00:22:56.920 --> 00:22:58.350
to actually apply that.

00:22:58.450 --> 00:23:01.130
And once we've done that,
that will increase the available

00:23:01.130 --> 00:23:04.720
content size to just grab the extra
space we were missing from that header.

00:23:04.720 --> 00:23:07.610
Now, Eliza's going to come back up
and do another demo for us,

00:23:07.690 --> 00:23:10.940
but she's actually going to just
show something slightly different

00:23:10.940 --> 00:23:13.060
that you can do with stationary zoom.

00:23:13.080 --> 00:23:21.140
So we're going to have Eliza come
back up and show us how to do that.

00:23:22.710 --> 00:23:23.370
Hi.

00:23:23.740 --> 00:23:26.580
So I decided to add a
stationary view to this.

00:23:26.650 --> 00:23:29.650
We don't really have anything
that a header would be useful

00:23:29.650 --> 00:23:31.260
for in this little demo app.

00:23:31.390 --> 00:23:33.330
So I'm going to add a moon to the app.

00:23:33.590 --> 00:23:36.600
And the idea is going to be
that the moon will scroll with

00:23:36.790 --> 00:23:40.070
the scroll view vertically,
so you can scroll it offscreen

00:23:40.220 --> 00:23:41.760
if you scroll vertically.

00:23:41.760 --> 00:23:44.880
But the moon will stay fixed in
position horizontally so that

00:23:44.880 --> 00:23:47.830
as you scroll the buildings by,
the moon stays put horizontally.

00:23:47.840 --> 00:23:51.030
So we'll use that as an
example of a stationary view.

00:23:51.040 --> 00:23:51.890
There we go.

00:23:51.890 --> 00:23:52.380
Okay.

00:23:52.510 --> 00:23:56.420
So we'll need to add,
we'll need to declare this moon view.

00:23:56.420 --> 00:23:57.590
We'll make it an image view.

00:23:57.590 --> 00:24:01.820
And I've drawn a little picture of a
moon that I've loaded in as an image.

00:24:02.130 --> 00:24:05.790
We can create the moon here
after creating our building

00:24:05.790 --> 00:24:10.740
container view just by allocating
a new image view with that image.

00:24:10.990 --> 00:24:14.450
And I'm going to insert the moon
view as a subview of the scroll view

00:24:14.700 --> 00:24:16.490
directly as a subview of the scroll
view itself rather than the image view.

00:24:16.530 --> 00:24:17.990
And I'm going to insert the moon view
as a subview of the scroll view itself

00:24:18.010 --> 00:24:21.560
rather than as a subview of the building
container view because we want the moon

00:24:21.560 --> 00:24:24.540
to not zoom when the buildings do zoom.

00:24:24.540 --> 00:24:29.530
So I'm going to insert it below the
building container view because it seems

00:24:29.560 --> 00:24:35.000
like the buildings should pass in front
of the moon if they happen to overlap it.

00:24:35.000 --> 00:24:35.870
So all right.

00:24:35.870 --> 00:24:37.340
Now we've got this moon.

00:24:37.340 --> 00:24:40.540
We just need to determine
what its position should be.

00:24:40.540 --> 00:24:44.300
And I've chosen some good
values for its center as insets

00:24:44.300 --> 00:24:47.820
relative to the top and right,
right edge.

00:24:47.830 --> 00:24:52.400
So I just picked these values by trial
and error because they looked good.

00:24:52.400 --> 00:24:57.020
And in layout, when we layout subviews,
what we'll do is after doing the tiling,

00:24:57.020 --> 00:24:58.800
we'll make sure to position the moon.

00:24:58.800 --> 00:25:05.090
And that way we can make its
X position dependent on what piece of

00:25:05.170 --> 00:25:07.360
the scroll view is currently visible.

00:25:07.410 --> 00:25:13.150
So the center of the -- the moon's
X center will be relative to the

00:25:13.150 --> 00:25:14.000
maximum visible X of the scroll view.

00:25:14.000 --> 00:25:15.560
And we're going to put that
in the center of the moon.

00:25:15.560 --> 00:25:15.560
And then we're going to put
that in the center of the moon.

00:25:15.560 --> 00:25:19.270
And we'll just subtract the
right inset off of that so

00:25:19.270 --> 00:25:21.660
that it's slightly on screen.

00:25:21.660 --> 00:25:24.110
And the effect of that
will be that as we scroll,

00:25:24.110 --> 00:25:27.450
its position will change because
the maximum visible X will change,

00:25:27.450 --> 00:25:30.720
and which will sort of paradoxically have
the effect that it will appear not to

00:25:30.820 --> 00:25:33.560
be changing because as you're scrolling,
it will actually stay

00:25:33.580 --> 00:25:36.900
fixed on the right side.

00:25:37.050 --> 00:25:41.200
And then the Y center is going to
be an absolute value that's just

00:25:41.200 --> 00:25:43.540
relative to the top of the scroll view,
and that will have the effect

00:25:43.640 --> 00:25:47.400
that the moon does scroll
in the vertical direction.

00:25:47.450 --> 00:25:51.710
So we'll just set the moon center,
and go ahead and run that.

00:25:54.130 --> 00:25:54.970
There it is.

00:25:55.090 --> 00:25:58.000
If I scroll vertically,
it scrolls right off.

00:25:58.000 --> 00:26:02.160
But as I scroll horizontally,
it stays fixed and the buildings pass

00:26:02.390 --> 00:26:04.860
right in front of it as we wanted.

00:26:12.800 --> 00:26:14.320
All right, thanks again, Eliza.

00:26:14.330 --> 00:26:16.960
So just to keep you all on your toes,
we've got two more back and

00:26:16.960 --> 00:26:18.560
forths between slides and demos.

00:26:18.560 --> 00:26:20.940
So don't get too bored yet.

00:26:20.940 --> 00:26:24.900
The next thing we want to talk about
is customizing touch event handling.

00:26:24.930 --> 00:26:30.140
So what we're talking about here is
adding custom multi-touch handlers

00:26:30.170 --> 00:26:32.480
to subviews of your UI ScrollView.

00:26:32.490 --> 00:26:35.140
So if you've seen the
UI ScrollView sessions before,

00:26:35.140 --> 00:26:37.200
as I said earlier,
we talked about how you

00:26:37.200 --> 00:26:39.920
could do this using regular
multi-touch-- touches began,

00:26:39.920 --> 00:26:41.660
moved, ended, and canceled.

00:26:41.660 --> 00:26:44.760
There's a variety of methods on
UI ScrollView that let you control

00:26:44.760 --> 00:26:47.580
how those touches get delivered
to subviews of the ScrollView.

00:26:47.760 --> 00:26:51.110
But it's all quite actually
fairly complicated.

00:26:51.120 --> 00:26:54.740
With the introduction of
UI Gesture Recognizer and iOS 3.2,

00:26:54.740 --> 00:26:58.860
this has become much, much easier,
and in fact, much more powerful.

00:26:58.860 --> 00:27:02.730
So there's a lot of ways that you can
very easily add custom interactions to

00:27:02.730 --> 00:27:05.040
UI ScrollView using gesture recognizers.

00:27:05.040 --> 00:27:06.780
So let's look at one of them.

00:27:06.780 --> 00:27:09.040
Let's say that we've got
this large amount of content,

00:27:09.040 --> 00:27:10.520
and we can scroll around in it.

00:27:10.680 --> 00:27:14.090
But we want to add the ability to
swipe in from the left or the right,

00:27:14.200 --> 00:27:17.550
or swipe up from the bottom
or down to the bottom.

00:27:17.560 --> 00:27:22.070
You've seen this yesterday in the keynote
with the new mail interface in Portrait.

00:27:22.080 --> 00:27:24.860
You can swipe in anywhere
in the message content area.

00:27:24.880 --> 00:27:27.600
And even though that area is scrollable,
when you do a fast swipe,

00:27:27.720 --> 00:27:29.940
you actually bring in the mailbox list.

00:27:29.990 --> 00:27:32.400
So we can do the same
thing using UI ScrollView.

00:27:32.440 --> 00:27:36.370
And it's actually been made even
easier to do more complicated

00:27:36.370 --> 00:27:39.630
interactions in iOS 5,
which we'll see in just a second.

00:27:41.440 --> 00:27:44.940
So the idea here normally is when a
touch comes down in a scroll view,

00:27:45.070 --> 00:27:48.270
as the user moves that finger around,
the default behavior is going

00:27:48.270 --> 00:27:49.800
to be to scroll the content.

00:27:49.870 --> 00:27:53.260
But we really want to add the
ability to swipe in from the bottom

00:27:53.260 --> 00:27:57.140
without moving the content and
animate some other view into place.

00:27:57.190 --> 00:28:00.900
We could then swipe down in that same
area and animate that view back out.

00:28:00.950 --> 00:28:03.060
But the actual scroll view
hasn't scrolled at all.

00:28:03.060 --> 00:28:06.700
We haven't moved our
scrolling content in any way.

00:28:07.250 --> 00:28:08.600
So how would we do that?

00:28:08.880 --> 00:28:14.780
Well, it's, as I said,
now actually possible in iOS 5 to even

00:28:14.780 --> 00:28:18.650
more greatly customize the interactions
of your gesture recognizers with the

00:28:18.650 --> 00:28:19.980
ScrollView's gesture recognizers.

00:28:19.980 --> 00:28:23.420
Because UI ScrollView actually
uses UIPanGestureRecognizer and

00:28:23.420 --> 00:28:27.340
UIPinchGestureRecognizer to implement
its own panning and zooming.

00:28:27.340 --> 00:28:33.230
And you can now add interactions that are
dependent on those gesture recognizers.

00:28:34.110 --> 00:28:38.380
So the new properties in iOS
5 are PanGestureRecognizer,

00:28:38.420 --> 00:28:41.120
which gives you back the
ScrollView's UIPanGestureRecognizer,

00:28:41.130 --> 00:28:43.820
the one it's actually using to
track the touches for scrolling.

00:28:43.820 --> 00:28:46.100
And PinchGestureRecognizer,
which gives you the

00:28:46.110 --> 00:28:49.410
UIPinchGestureRecognizer that it's
going to be using for zooming.

00:28:50.990 --> 00:28:54.550
So with those properties,
we can now set up more complicated

00:28:54.570 --> 00:28:58.380
interactions between our own UI gesture
recognizers and the scroll views,

00:28:58.410 --> 00:29:01.830
which gives us a lot more power to
customize the way our views will

00:29:01.830 --> 00:29:03.630
interact with the scroll view.

00:29:03.820 --> 00:29:06.140
So for the example we
were just looking at,

00:29:06.170 --> 00:29:08.580
let's take a look at how
we can make use of that.

00:29:08.630 --> 00:29:11.590
So first, we'll assume that we're in a
place in our code where we're

00:29:11.590 --> 00:29:13.630
actually configuring our UI view.

00:29:13.780 --> 00:29:16.720
So a common place where you
would do this kind of logic

00:29:16.870 --> 00:29:20.260
is in your view controller's
viewDidLoad or in your load view,

00:29:20.340 --> 00:29:22.960
where you're creating and
configuring your views.

00:29:23.100 --> 00:29:26.120
So let's say we have access to
our UI scroll view in this place.

00:29:26.350 --> 00:29:28.360
I've got a method here
called selfScrollView,

00:29:28.420 --> 00:29:31.480
which returns the scroll
view we want to customize.

00:29:31.550 --> 00:29:34.330
Then we just want to create
our new gesture recognizer.

00:29:34.470 --> 00:29:37.610
So we'll allocate and init a
new UI swipe gesture recognizer

00:29:37.920 --> 00:29:40.080
using initWithTargetAction.

00:29:40.100 --> 00:29:42.990
And we're going to try and create
that swipe up recognizer that

00:29:42.990 --> 00:29:46.210
allows us to bring in an extra
view from the bottom of the screen.

00:29:46.430 --> 00:29:48.980
So as you know,
with UI swipe gesture recognizer,

00:29:48.980 --> 00:29:50.920
we just have to set its direct
view and set its direction.

00:29:50.920 --> 00:29:53.710
So we'll pick
UISwipeGestureRecognizer direction up,

00:29:53.750 --> 00:29:55.560
which gives us that swipe up.

00:29:55.560 --> 00:29:58.060
And then we just add
it to our UIScrollView.

00:29:58.060 --> 00:30:00.900
Now, this would almost be
everything we have to do,

00:30:00.900 --> 00:30:02.760
but if you tried it,
you'd actually find out

00:30:02.760 --> 00:30:03.760
that it didn't work.

00:30:03.760 --> 00:30:09.020
And the reason for that is because
UIPanGestureRecognizer actually

00:30:09.020 --> 00:30:13.460
requires less movement to recognize
a pan than UISwipeGestureRecognizer

00:30:13.520 --> 00:30:15.520
requires to recognize a swipe.

00:30:15.520 --> 00:30:18.310
So you have to move your
finger farther to recognize a

00:30:18.320 --> 00:30:18.970
swipe than to recognize a pan.

00:30:18.980 --> 00:30:24.030
But the problem is we have both a
swipe and a pan on this scroll view,

00:30:24.030 --> 00:30:27.680
so the pan will always recognize
first and will always win.

00:30:27.740 --> 00:30:30.520
So if we just put this swipe
gesture recognizer on here,

00:30:30.550 --> 00:30:32.100
it would actually have no effect.

00:30:32.130 --> 00:30:35.160
But with one extra line of code,
we can fix that,

00:30:35.170 --> 00:30:38.570
thanks to these new properties in
iOS 5 that give us access to the

00:30:38.680 --> 00:30:40.640
scroll view's gesture recognizers.

00:30:40.650 --> 00:30:43.540
So we can call
scrollView.PanGestureRecognizer,

00:30:43.550 --> 00:30:47.240
which will give us back that pan gesture
recognizer the scroll view will be using.

00:30:47.260 --> 00:30:50.500
And we can just tell it that it should
require our swipe gesture recognizer

00:30:50.500 --> 00:30:53.150
to fail before it's allowed to succeed.

00:30:53.380 --> 00:30:56.600
And with that one line of code,
even though our pan would normally

00:30:56.630 --> 00:30:59.690
be trying to recognize earlier,
it's going to wait until after

00:30:59.800 --> 00:31:03.580
it's sure that the user isn't
swiping before it begins to pan,

00:31:03.600 --> 00:31:06.540
which will cause your scroll
view to not pan until it's

00:31:06.540 --> 00:31:08.460
sure that there's no swipe.

00:31:08.460 --> 00:31:10.940
So that's the exact behavior
that we're looking for in this

00:31:10.940 --> 00:31:13.100
little sample we were looking at.

00:31:13.110 --> 00:31:15.500
Now, of course,
there's one small problem with this,

00:31:15.540 --> 00:31:20.600
which is that we've now created this
large area over the entire scroll view,

00:31:20.600 --> 00:31:23.490
which recognizes swipes up.

00:31:23.540 --> 00:31:26.540
Of course, the problem with that is that
now we've actually interfered

00:31:26.540 --> 00:31:29.170
with scrolling behavior in a
large part of this scroll view.

00:31:29.220 --> 00:31:34.040
We probably don't want to require
this delay every time the user's

00:31:34.330 --> 00:31:37.400
moving their finger up before
we allow scrolling to begin,

00:31:37.830 --> 00:31:40.020
especially not if it's really
far away from the edge we're

00:31:40.020 --> 00:31:41.160
trying to swipe in from.

00:31:41.320 --> 00:31:44.560
So we really want to just target
the area that the swipe is

00:31:44.560 --> 00:31:47.050
active in to that bottom area
of the scroll view down there.

00:31:47.060 --> 00:31:52.020
And we can do that with just one small
modification to what we already created.

00:31:52.160 --> 00:31:56.870
And we'll just use the gesture recognizer
should receive touch delegate method to

00:31:56.870 --> 00:32:01.700
limit the area that the swipe gesture
recognizer will receive touches from.

00:32:01.700 --> 00:32:05.590
So we'll get our scroll view again
because we need to figure out which

00:32:05.590 --> 00:32:10.330
part of the scroll view is visible so we
know which area to allow touches from.

00:32:10.440 --> 00:32:12.860
We'll get the scroll view's bounds,
which is the visible

00:32:12.860 --> 00:32:14.900
part of the scroll view,
and then we'll get the

00:32:15.160 --> 00:32:17.170
touch's location in this area,
which is the visible

00:32:17.230 --> 00:32:18.420
part of the scroll view.

00:32:18.420 --> 00:32:21.680
So we'll just do a little bit of
modification in the scroll view so that

00:32:21.770 --> 00:32:24.530
we can compare it to the visible bounds
and just make sure we limit it to

00:32:24.530 --> 00:32:26.420
the bottom part of the visible bounds.

00:32:26.420 --> 00:32:30.440
Then it's just a really simple if
statement to check to see if our touch

00:32:30.440 --> 00:32:32.430
point Y is within that bottom portion.

00:32:32.450 --> 00:32:36.440
In this case, I've said 75 points from
the bottom of the screen,

00:32:36.440 --> 00:32:38.440
but, you know,
you might pick something different

00:32:38.440 --> 00:32:40.440
depending on your situation.

00:32:40.440 --> 00:32:42.440
And if it is in that -- if
it's not in that bottom area,

00:32:42.440 --> 00:32:45.000
we're going to return no to say that
our swipe gesture recognizer should

00:32:45.060 --> 00:32:46.420
not receive touches in that area.

00:32:46.420 --> 00:32:50.420
It should be in the upper, you know,
two-thirds, three-quarters of the screen.

00:32:50.420 --> 00:32:52.740
Otherwise, we'll return yes,
which will allow our swipe to be

00:32:52.740 --> 00:32:56.420
recognized when touches begin in
the bottom portion of the screen.

00:32:56.420 --> 00:32:58.670
So again,
just to continue to emphasize that

00:32:58.670 --> 00:33:01.700
there's a variety of different
ways that you can use these

00:33:01.700 --> 00:33:04.440
techniques to do different things,
Eliza's going to come back and show

00:33:04.440 --> 00:33:08.670
us how we can do something else using
gesture recognizers in UI scroll views.

00:33:11.020 --> 00:33:14.600
All right, so I'm going to add a gesture
recognizer that's going to allow

00:33:14.960 --> 00:33:17.440
us to press down on the moon,
pick it up,

00:33:17.590 --> 00:33:19.370
and move it to another location.

00:33:19.690 --> 00:33:22.350
So this is going to be-- it
actually is going to be surprisingly

00:33:22.350 --> 00:33:24.160
easy with UI gesture recognizer.

00:33:24.220 --> 00:33:28.960
If any of you were here two years ago
and saw our ScrollView session then,

00:33:28.960 --> 00:33:32.680
you may recall that we did a bunch
of touch handling with dragging

00:33:32.680 --> 00:33:33.740
views around in a ScrollView.

00:33:33.740 --> 00:33:36.400
But we had to do an enormous amount
of work to make it so that the

00:33:36.450 --> 00:33:40.520
ScrollView would interpret those touches
as intended to move one of the subviews,

00:33:40.580 --> 00:33:43.420
rather than as intended
to pan the ScrollView.

00:33:43.420 --> 00:33:45.950
With gesture recognizers,
it becomes incredibly easy.

00:33:46.070 --> 00:33:50.090
We're just going to create a
long press gesture recognizer,

00:33:50.190 --> 00:33:53.360
which will recognize when
you hold your finger still.

00:33:53.530 --> 00:33:57.830
And because holding your finger
still on the ScrollView doesn't

00:33:57.850 --> 00:34:01.740
even compete with panning,
there isn't even going to be any need

00:34:01.790 --> 00:34:05.630
to set up an interaction explicitly
between the ScrollView's pan gesture

00:34:05.740 --> 00:34:08.040
recognizer and our press recognizer.

00:34:08.320 --> 00:34:10.030
It will just happen automatically.

00:34:10.140 --> 00:34:14.320
The correct touches will go to
the long press gesture recognizer.

00:34:14.610 --> 00:34:17.970
It will recognize,
and then it can be used to track movement

00:34:17.970 --> 00:34:20.360
of the view that we've picked up.

00:34:20.540 --> 00:34:26.110
So here in my initWithCoder method,
I'm going to create a long

00:34:26.110 --> 00:34:28.610
press gesture recognizer.

00:34:28.880 --> 00:34:32.000
Whoa, that wrapped in a surprising way.

00:34:32.000 --> 00:34:35.480
Let's just get that visible.

00:34:35.670 --> 00:34:38.810
And we're going to use
ourself as the target,

00:34:38.900 --> 00:34:39.560
and we'll write this.

00:34:39.560 --> 00:34:43.470
write this handleMoonPress
method in just a minute.

00:34:43.980 --> 00:34:47.980
I'm going to add that gesture
recognizer to the moon view.

00:34:47.980 --> 00:34:50.770
There's two more things I have
to do which are slightly

00:34:50.770 --> 00:34:52.860
irritating to get this to work.

00:34:52.950 --> 00:34:55.850
One of them is it's all well
and good to add a gesture

00:34:55.850 --> 00:34:58.790
recognizer to this moon view,
but if the moon view

00:34:58.800 --> 00:35:01.550
isn't accepting touches,
then the gesture recognizer

00:35:01.550 --> 00:35:02.890
will never see any touches.

00:35:02.990 --> 00:35:06.020
And in this case,
since the moon view is a UI image view,

00:35:06.020 --> 00:35:09.010
which is the only subclass of
UI view that by default has

00:35:09.080 --> 00:35:12.550
user interaction disabled,
we need to make sure to turn

00:35:12.550 --> 00:35:15.740
user interaction on for the moon
view or else we're not going

00:35:15.740 --> 00:35:16.900
to see any of these presses.

00:35:16.900 --> 00:35:20.890
So we set user interaction
enabled on the moon view.

00:35:21.020 --> 00:35:24.880
The other problem is that the moon view
is behind our building container view,

00:35:24.890 --> 00:35:28.900
and the building container view takes up
the entire content of the scroll view.

00:35:28.900 --> 00:35:31.890
And it does have user interaction enabled
by default because it's a regular view.

00:35:31.900 --> 00:35:31.900
So we're going to have to
make sure that we're not going

00:35:31.900 --> 00:35:31.900
to see any of these presses.

00:35:31.900 --> 00:35:31.900
So we set user interaction
enabled on the moon view.

00:35:31.900 --> 00:35:32.300
The other problem is that the moon view
is behind our building container view,

00:35:32.300 --> 00:35:32.900
and the building container view takes up
the entire content of the scroll view.

00:35:32.900 --> 00:35:33.510
UI view.

00:35:33.530 --> 00:35:37.860
It's going to block all the touches
from getting to our moon view.

00:35:37.860 --> 00:35:39.910
We can fix that in a
bunch of different ways.

00:35:40.000 --> 00:35:42.900
The simplest one is just to
turn user interaction off on

00:35:42.900 --> 00:35:44.570
the building container view.

00:35:44.570 --> 00:35:47.260
So we'll do that so that
the moon can get touches.

00:35:47.260 --> 00:35:48.080
All right.

00:35:48.230 --> 00:35:52.200
So now that we've done those things,
we can go ahead and implement

00:35:52.200 --> 00:35:54.470
this handle moon press method.

00:35:54.470 --> 00:35:58.280
And the idea here is going to
be we're going to find out what

00:35:58.280 --> 00:36:01.560
state the recognizer is in,
and we're going to do different things

00:36:01.560 --> 00:36:03.020
depending on which state it's in.

00:36:03.020 --> 00:36:07.540
So this is going to be a
giant switch statement.

00:36:09.290 --> 00:36:11.630
Oops, sorry.

00:36:11.720 --> 00:36:12.880
Get that all on screen.

00:36:12.940 --> 00:36:15.560
Okay, so we care about three or
four different states that the

00:36:15.580 --> 00:36:16.880
gesture recognizer might be in.

00:36:16.880 --> 00:36:17.900
We care when it begins.

00:36:17.900 --> 00:36:20.900
That's after you've pressed for
long enough that the gesture you're

00:36:20.900 --> 00:36:22.700
doing now counts as a long press.

00:36:22.700 --> 00:36:24.690
We care if it changes.

00:36:24.820 --> 00:36:27.230
It changes when,
after recognizing you move your finger,

00:36:27.230 --> 00:36:30.560
and at that point we're going to want
to change the location of the moon view.

00:36:31.520 --> 00:36:33.630
And we care when the
gesture ends or is canceled,

00:36:33.630 --> 00:36:36.360
because we want to, at that point,
drop the moon view and leave

00:36:36.360 --> 00:36:37.590
it in its new position.

00:36:37.600 --> 00:36:42.470
So, as a springboard engineer,
I decided to make the moon view look like

00:36:42.530 --> 00:36:48.080
it gets picked up in the same way that we
make an icon look like it gets picked up.

00:36:48.140 --> 00:36:50.200
And that way is, we do three things.

00:36:50.200 --> 00:36:53.100
We pull the icon to the front so that
as it moves it passes over all of the

00:36:53.100 --> 00:36:54.700
other views that are on the screen.

00:36:54.700 --> 00:36:58.760
And we change the transform on an icon.

00:36:58.760 --> 00:37:01.040
We make it slightly bigger
so that it kind of looks like

00:37:01.040 --> 00:37:01.500
it came towards the moon.

00:37:01.500 --> 00:37:05.260
And then we also change its transparency
to make it slightly transparent so it

00:37:05.260 --> 00:37:07.310
has this kind of grabbed appearance.

00:37:07.320 --> 00:37:09.200
So we'll do the same
exact thing to the moon.

00:37:09.200 --> 00:37:12.310
Pull it to the front of our sub view,
so it's now going to pass

00:37:12.340 --> 00:37:13.940
in front of the buildings.

00:37:13.940 --> 00:37:16.830
And with a little animation,
we'll set its transform

00:37:16.830 --> 00:37:19.610
to be slightly larger,
a scale transform that just

00:37:19.610 --> 00:37:23.170
makes it grow a little,
and we'll reduce its alpha slightly.

00:37:23.180 --> 00:37:25.400
So now the moon will look grabbed.

00:37:25.440 --> 00:37:28.900
When the gesture changes because
you've moved your finger,

00:37:28.900 --> 00:37:31.500
we're going to just reposition the moon.

00:37:31.500 --> 00:37:35.750
So we can do that by setting its
center to the new location of

00:37:35.750 --> 00:37:38.220
your touch in the scroll view.

00:37:38.770 --> 00:37:42.640
And finally, when the gesture ends,
we'll undo the things that we did

00:37:42.640 --> 00:37:44.700
when it began with an animation.

00:37:44.720 --> 00:37:48.870
With the same duration animation,
we'll set its transform back to identity,

00:37:49.090 --> 00:37:51.960
set its alpha back to 1,
and when that finishes,

00:37:51.960 --> 00:37:56.430
we'll send the moon view back to the
back of our subviews so that buildings

00:37:56.470 --> 00:37:58.700
once again pass in front of it.

00:37:58.760 --> 00:38:02.560
Alright, so with that in place,
we can go ahead and try this out.

00:38:07.040 --> 00:38:08.150
All right, so here's the moon.

00:38:08.390 --> 00:38:10.140
I'm going to grab it.

00:38:10.210 --> 00:38:12.050
It zooms up like we wanted.

00:38:12.360 --> 00:38:13.220
And then I start moving it.

00:38:13.220 --> 00:38:15.900
And I don't know if you noticed,
but there's a bit of a glitch here.

00:38:15.900 --> 00:38:18.260
As I grab it and as
soon as I start moving,

00:38:18.270 --> 00:38:19.110
it jumps up.

00:38:19.210 --> 00:38:20.200
So we're going to want to fix that.

00:38:20.230 --> 00:38:22.730
There's another really big problem,
which is that if I pull the

00:38:22.730 --> 00:38:25.580
moon over here and let go,
it jumps right back to where it started.

00:38:25.580 --> 00:38:28.040
So let's go back to the code,
and I'll try to explain why

00:38:28.180 --> 00:38:29.720
both of those things went wrong.

00:38:30.480 --> 00:38:32.310
So the first problem is that jump.

00:38:32.770 --> 00:38:36.980
And the culprit here is that
when the gesture changes,

00:38:36.980 --> 00:38:41.390
we adjust the moon's center point to
be the new location in the ScrollView.

00:38:41.390 --> 00:38:45.090
But you might not have grabbed
the moon from its center point.

00:38:45.130 --> 00:38:46.310
You might have grabbed it from the edge.

00:38:46.320 --> 00:38:48.880
And so when we start,
we immediately set its center to

00:38:48.880 --> 00:38:52.150
be the location of your finger,
which causes the moon to jump from the

00:38:52.340 --> 00:38:55.940
point of it being under your finger to
the center of it being under your finger,

00:38:55.940 --> 00:38:58.330
which has that kind of unpleasant effect.

00:38:58.340 --> 00:39:00.270
So there's a really easy way to fix that.

00:39:00.480 --> 00:39:02.480
So the first thing we want
to do is to add an IVAR,

00:39:02.480 --> 00:39:04.580
which is to remember when
the touch comes down,

00:39:04.580 --> 00:39:16.530
we want to remember how far away the
touch was from the center of the moon.

00:39:17.290 --> 00:39:21.610
To remember the touch offset from center,
and then when the touch starts

00:39:21.700 --> 00:39:26.600
in our gesture recognizer began,
we can just record what that offset is.

00:39:26.650 --> 00:39:31.620
It's the center of the moon
minus the location in view for

00:39:31.630 --> 00:39:34.150
each of the X and Y components.

00:39:34.360 --> 00:39:37.940
And then finally,
when we set the moon center,

00:39:37.940 --> 00:39:40.100
we don't want to just blindly
set it to the current location.

00:39:40.100 --> 00:39:43.770
We want to set it to the
location offset by that amount.

00:39:44.340 --> 00:39:46.880
All right,
so that will fix that jumping problem.

00:39:46.970 --> 00:39:49.580
The other problem was that
when I dropped the moon,

00:39:49.580 --> 00:39:53.080
it jumped right back to the upper right
corner where we had initially placed it.

00:39:53.190 --> 00:39:59.350
And the reason that that's happening
is that in layout subviews,

00:39:59.360 --> 00:40:01.600
we're telling the moon
to be located there.

00:40:01.680 --> 00:40:06.010
And it turns out that layout subviews
gets called for a whole lot of reasons.

00:40:06.310 --> 00:40:10.180
And so we're hitting our layout subviews,
and that's as soon as I drop the moon,

00:40:10.180 --> 00:40:12.250
and it's pulling it back up
to the upper right corner.

00:40:12.330 --> 00:40:15.810
So we can fix that by making
sure that in layout subviews,

00:40:15.820 --> 00:40:18.070
instead of setting the
moon to a fixed position,

00:40:18.300 --> 00:40:20.920
we remember its current
position and we set it to that.

00:40:21.090 --> 00:40:25.920
So instead of using these pound
defines to place the moon,

00:40:25.920 --> 00:40:31.260
I'm going to add two new IVARs,
a top inset and a right inset.

00:40:31.520 --> 00:40:36.020
In init, I'll set their values to be the
same values we were using before.

00:40:36.080 --> 00:40:41.000
So the moon will start off
in the upper right corner.

00:40:41.810 --> 00:40:45.120
The end,
the touch end part of our gesture

00:40:45.120 --> 00:40:48.770
recognizer code will adjust

00:40:49.000 --> 00:40:53.170
and Ivar,
will make the right inset dependent on

00:40:53.310 --> 00:41:00.100
the current bounds of the scroll view,
so that we still keep it relative to the

00:41:00.100 --> 00:41:04.060
current visible area of the scroll view.

00:41:04.230 --> 00:41:08.080
And finally, in LayoutSubviews,
we can use those new variables

00:41:08.200 --> 00:41:14.610
instead of using the pound defines.

00:41:14.700 --> 00:41:17.800
So I'll go ahead and run.

00:41:17.820 --> 00:41:20.900
That and these problems
ought to be fixed now.

00:41:24.280 --> 00:41:25.400
So no more jumping.

00:41:25.400 --> 00:41:27.960
I grab it and it nicely
starts moving smoothly.

00:41:27.960 --> 00:41:29.690
And if I drop it over there,
it stays there and I can

00:41:29.730 --> 00:41:31.120
continue scrolling.

00:41:31.170 --> 00:41:33.990
So that's gesture
recognizers with ScrollViews.

00:41:36.890 --> 00:41:38.600
All right, thanks one more time, Eliza.

00:41:38.850 --> 00:41:43.800
Okay, our last section now is adding
zooming into our UI ScrollView.

00:41:43.880 --> 00:41:48.060
And the specific thing that we want to
talk about now is once you've zoomed in,

00:41:48.060 --> 00:41:50.040
and I'm sure you've seen this
if you've used zooming in

00:41:50.070 --> 00:41:52.790
your ScrollViews yourself,
your content starts to get blurry,

00:41:52.790 --> 00:41:55.870
and you really want to redraw it at a
higher resolution so it looks really

00:41:55.920 --> 00:41:57.800
crisp and nice at the higher zoom scale.

00:41:57.800 --> 00:42:00.170
So, you know,
that looks basically like the

00:42:00.170 --> 00:42:03.800
user puts their finger down,
zooms in on your ScrollView,

00:42:03.850 --> 00:42:07.800
and you can see that that content that
we just zoomed in and made really nice

00:42:07.800 --> 00:42:11.700
is actually pixelated and blurry now,
or hopefully you can see on there.

00:42:11.840 --> 00:42:16.660
What we'd really like to do is redraw
that and be much more crisp and high

00:42:16.660 --> 00:42:19.670
resolution at this higher zoom scale.

00:42:19.890 --> 00:42:22.560
So as I mentioned earlier,
we're not going to talk specifically

00:42:22.560 --> 00:42:25.370
about how to do that on the
main part of your content today.

00:42:25.520 --> 00:42:28.860
We have two previous sessions
that you can see on iTunes,

00:42:28.910 --> 00:42:32.320
where we've talked about using tiling,
using CATiledLayer,

00:42:32.380 --> 00:42:38.610
and just using your own custom tiling
with UIViews that are from previous

00:42:38.710 --> 00:42:41.150
sessions of WWDC in previous years.

00:42:41.390 --> 00:42:44.000
And there's actually sample code from
both of those sessions that's still

00:42:44.020 --> 00:42:46.200
available on developer.apple.com.

00:42:46.260 --> 00:42:49.690
One of them is the ScrollView Suite,
and the other one is the

00:42:49.690 --> 00:42:51.080
PhotoScroller sample.

00:42:51.160 --> 00:42:54.040
So if you want to see how to do
this for your main content area,

00:42:54.070 --> 00:42:55.220
I would go check those things out.

00:42:55.350 --> 00:42:56.980
They're great resources for that.

00:42:57.020 --> 00:43:00.300
What we want to talk about today is
smaller pieces of content that are

00:43:00.300 --> 00:43:02.140
maybe incidental to your main image.

00:43:02.330 --> 00:43:05.520
In this case,
we have this extra label at the bottom,

00:43:05.570 --> 00:43:07.760
and we have the exact same
problem with the label.

00:43:07.810 --> 00:43:10.030
When we zoom in on that,
you can see that our text

00:43:10.030 --> 00:43:12.420
has gotten very pixelated,
and it's blurry.

00:43:12.420 --> 00:43:13.960
It just doesn't look very nice.

00:43:14.020 --> 00:43:17.440
We'd really like to redraw it and
have it be really crisp and higher

00:43:17.440 --> 00:43:20.080
resolution once we've zoomed in.

00:43:20.950 --> 00:43:26.510
So there's a really nice little trick
that you can use to redraw this content,

00:43:26.510 --> 00:43:29.250
as long as you're keeping
it to fairly small content.

00:43:29.270 --> 00:43:32.150
I would strongly encourage you to
not use this for anything that's very

00:43:32.250 --> 00:43:37.460
much larger than a part of the screen
when you're zoomed all the way in.

00:43:37.460 --> 00:43:42.010
If you're doing something that's
maybe 20 times the size of the screen,

00:43:42.060 --> 00:43:44.340
not only is it a bad idea,
but your app will probably

00:43:44.340 --> 00:43:45.890
run out of memory and crash.

00:43:45.920 --> 00:43:49.100
So keep it to small pieces of content.

00:43:49.130 --> 00:43:53.070
But in that case where you can use
it for small pieces of content,

00:43:53.250 --> 00:43:54.940
it's really convenient.

00:43:54.990 --> 00:43:59.240
So the place where we would want to
do this is in ScrollViewDidEndZooming

00:43:59.550 --> 00:44:03.170
with View at Scale,
because we don't want to try and

00:44:03.180 --> 00:44:05.580
redraw our content while we're zooming.

00:44:05.600 --> 00:44:08.060
Redrawing content is a
very expensive operation,

00:44:08.060 --> 00:44:10.700
so we only want to do it when
the user is actually done zooming

00:44:10.700 --> 00:44:14.140
and has lifted their fingers,
and we know the new scale we're at.

00:44:14.150 --> 00:44:17.210
So ScrollViewDidEndZooming
with View at Scale will tell

00:44:17.210 --> 00:44:20.480
us exactly when that happens,
and conveniently also tells us the

00:44:20.480 --> 00:44:23.860
scale that we've stopped zooming at,
so we know what scale to

00:44:23.860 --> 00:44:25.530
redraw our content at.

00:44:26.080 --> 00:44:30.090
So we can actually fix this
problem with just one line of code,

00:44:30.090 --> 00:44:33.000
again provided we have a fairly small
amount of content we're trying to redraw.

00:44:33.000 --> 00:44:38.460
And that line of code would just be
the setContentScaleFactor method,

00:44:38.460 --> 00:44:40.840
passing in the scale that
we told that we were at.

00:44:41.000 --> 00:44:44.150
Now,
the content scale factor of a view is

00:44:44.150 --> 00:44:48.110
basically just a multiplier applied
to the bound size of your view,

00:44:48.110 --> 00:44:52.010
used to determine how big the
backing store should be for actually

00:44:52.010 --> 00:44:54.890
backing your draw rect on that view.

00:44:55.000 --> 00:44:59.000
So if you have a 100x100 view
and a content scale factor of 1,

00:44:59.000 --> 00:45:02.000
your backing store is 100x100 pixels.

00:45:02.000 --> 00:45:05.890
If you had that same 100x100 view
with a content scale factor of 2,

00:45:05.980 --> 00:45:08.710
the backing store that you're
actually drawing and filling

00:45:08.710 --> 00:45:11.000
with pixels is 200x200 pixels.

00:45:11.000 --> 00:45:14.910
So you just always multiply the bound
size times the content scale factor,

00:45:15.220 --> 00:45:19.990
which will tell you how many pixels will
be allocated to fill your content with.

00:45:20.330 --> 00:45:24.000
This is actually exactly how retina
display devices create content.

00:45:24.000 --> 00:45:27.320
So you can create higher resolution
backing stores without you having

00:45:27.320 --> 00:45:30.380
to change any of your drawing codes,
so that you can deploy the same

00:45:30.380 --> 00:45:35.200
application to both iPhone 3GS and
iPhone 4 without having to write

00:45:35.200 --> 00:45:36.990
separate code in your draw rect.

00:45:37.080 --> 00:45:38.980
And on iPhone 4,
everything just looks crisper.

00:45:39.000 --> 00:45:42.070
That's because all your views
get a content scale factor

00:45:42.190 --> 00:45:44.000
of 2 set on them by default.

00:45:44.680 --> 00:45:46.110
Now, of course,
because they have this extra

00:45:46.110 --> 00:45:48.720
scale factor by default,
we actually need to take that

00:45:48.720 --> 00:45:50.840
into account when setting
our content scale factor,

00:45:50.840 --> 00:45:52.100
in this case as well.

00:45:52.250 --> 00:45:55.150
Because if we didn't,
we would lose that initial 2x scale on

00:45:55.150 --> 00:45:57.980
high resolution retina display devices.

00:45:58.140 --> 00:46:00.250
So we want to actually
do one last thing here,

00:46:00.310 --> 00:46:03.380
which is also multiply in
that screen scale factor.

00:46:03.510 --> 00:46:07.920
So we just get our UI ScrollViews window,
get that window screen,

00:46:07.970 --> 00:46:11.300
and get that screen scale,
and then multiply that in before

00:46:11.300 --> 00:46:13.750
we set our content scale factor.

00:46:13.910 --> 00:46:17.550
This makes sure that on those high
resolution retina display devices,

00:46:17.550 --> 00:46:20.220
we're rendering at the correct
resolution and don't still

00:46:20.220 --> 00:46:22.700
end up with some pixelation,
even when we thought we

00:46:22.750 --> 00:46:24.150
were fixing the problem.

00:46:24.180 --> 00:46:25.380
So that's really all there is to it.

00:46:25.510 --> 00:46:29.570
And to give us a last demo of how we
can use that in our Buildings app,

00:46:29.570 --> 00:46:31.180
Eliza will come back.

00:46:33.540 --> 00:46:35.400
Hi one last time.

00:46:35.400 --> 00:46:36.890
Switch over.

00:46:37.200 --> 00:46:40.100
Okay, so let's add zooming to this.

00:46:40.180 --> 00:46:43.400
It's going to be a bit of a trick to
get the zooming working with the tiling,

00:46:43.400 --> 00:46:45.790
so I'm just going to
show you how that works.

00:46:45.800 --> 00:46:49.740
So the first thing we need to do
is implement the view for zooming

00:46:49.740 --> 00:46:52.000
in ScrollView delegate method.

00:46:52.000 --> 00:46:54.610
So we need our ScrollView to
have a delegate.

00:46:54.710 --> 00:46:57.990
Because all of my logic here is in
this infinite ScrollView subclass,

00:46:57.990 --> 00:47:00.300
I'm just going to make
it be its own delegate.

00:47:00.300 --> 00:47:03.990
So in the header, oops.

00:47:07.480 --> 00:47:12.520
I'm going to indicate that
this class implements the

00:47:12.520 --> 00:47:14.560
UI ScrollView delegate protocol.

00:47:14.660 --> 00:47:19.400
And then switching back to the
implementation file in init,

00:47:19.400 --> 00:47:25.290
I'm going to set myself as my delegate,
and I'm going to set the minimum and

00:47:25.290 --> 00:47:29.360
maximum zoom scale properties to some
values that will allow for zooming.

00:47:29.420 --> 00:47:32.070
I'm actually picking a pretty
large maximum zoom scale so that

00:47:32.110 --> 00:47:34.820
we'll really see the pixelation
of the buildings as we zoom in,

00:47:34.820 --> 00:47:36.400
and then we can see it crisp up.

00:47:36.400 --> 00:47:39.400
Eight times is maybe a little
more than you'd really need.

00:47:39.550 --> 00:47:43.830
All right, so now that we've done that,
we just need to implement the

00:47:44.010 --> 00:47:46.400
UI ScrollView delegate protocol.

00:47:46.400 --> 00:47:49.540
And in particular,
we need the single method view

00:47:49.540 --> 00:47:52.420
for zooming in ScrollView,
and we're going to return our

00:47:52.430 --> 00:47:54.850
building container view to cause
that view to be the one that

00:47:54.850 --> 00:47:56.400
gets the transform applied to it.

00:47:56.520 --> 00:47:59.380
So we can run this as is.

00:48:02.700 --> 00:50:27.200
[Transcript missing]

00:50:30.620 --> 00:50:32.240
All right, so we've got some buildings.

00:50:32.310 --> 00:50:34.130
Let me find a nice
tall one to zoom in on.

00:50:34.310 --> 00:50:40.600
So here we'll take this purple one
with circle-- oops-- and we'll zoom in.

00:50:40.630 --> 00:50:45.000
And as you can see, as I zoom in,
it gets really pixelated.

00:50:45.000 --> 00:50:46.860
And when I drop it,
it stays really pixelated.

00:50:46.860 --> 00:50:50.640
I hope it's visible that that got
incredibly blurry as I finished zooming.

00:50:50.890 --> 00:50:54.820
So we can use the technique that
Josh just described to really easily

00:50:54.820 --> 00:50:59.480
change the content scale factor of
these buildings when the zooming ends.

00:50:59.500 --> 00:51:02.230
And that will cause them to
be redrawn with a much larger

00:51:02.270 --> 00:51:03.640
backing store allocated.

00:51:03.640 --> 00:51:08.330
And the reason that this works is that
most drawing that you would be doing

00:51:08.330 --> 00:51:10.140
in your draw rect is vector-based.

00:51:10.150 --> 00:51:13.260
And so when a larger backing
store is allocated for it,

00:51:13.260 --> 00:51:15.640
that very same drawing code
that I don't have to adjust

00:51:15.770 --> 00:51:20.150
at all will simply draw crisp,
larger shapes.

00:51:20.450 --> 00:51:23.260
And this works for text as well,
as Josh mentioned.

00:51:23.370 --> 00:51:29.210
So I'm going to implement another
ScrollViewDelegate method.

00:51:29.280 --> 00:51:32.360
And I'm going to use the same
method to take advantage of this.

00:51:32.360 --> 00:51:35.600
ScrollView did end zooming
with view at scale.

00:51:35.600 --> 00:51:38.820
And in that method,
I'll calculate the scale

00:51:38.820 --> 00:51:42.980
factor that we want,
which is my Windows screen scale times

00:51:43.280 --> 00:51:46.240
the new scale that we just landed at.

00:51:46.440 --> 00:51:50.910
And I'm just going to iterate
through all my buildings in the

00:51:51.260 --> 00:51:54.250
visible buildings array and just
set each building's content scale

00:51:54.250 --> 00:51:55.880
factor to be that new value.

00:51:55.980 --> 00:52:00.150
And you might think that a shortcut
here would be to set the content scale

00:52:00.150 --> 00:52:04.140
factor on the building container view,
since that contains all the buildings.

00:52:04.160 --> 00:52:06.850
But that would not work,
because we need the drawing code to be

00:52:06.850 --> 00:52:10.110
rerun at the higher content scale factor.

00:52:10.180 --> 00:52:13.160
And the building views themselves
are what's doing the drawing.

00:52:13.160 --> 00:52:17.160
Setting the content scale factor on the
container would have no effect at all.

00:52:17.160 --> 00:52:22.150
So there's one-- well,
let's see how that works.

00:52:23.310 --> 00:52:25.110
I'll show you one further
thing we need to do.

00:52:25.280 --> 00:52:29.360
So as I zoom in on this building,
it gets really pixelated.

00:52:29.400 --> 00:52:33.520
But then when I let go,
it crisps up with no further work than

00:52:33.520 --> 00:52:35.600
just that one content scale factor trick.

00:52:35.750 --> 00:52:40.580
So the one problem here
is that as I finish,

00:52:40.590 --> 00:52:41.420
oops.

00:52:41.470 --> 00:52:45.460
So if I zoom in,
we get this nice crisping up effect.

00:52:45.510 --> 00:52:48.740
But then as I continue to scroll
and new buildings come in,

00:52:48.770 --> 00:52:51.360
the new buildings are really pixelated.

00:52:51.440 --> 00:52:54.020
And that's because we're not
adjusting the content scale factor

00:52:54.300 --> 00:52:57.920
of buildings that weren't already on
screen when we finished the zooming.

00:52:57.920 --> 00:53:01.560
So we need to add one further thing,
which is when we add a new building,

00:53:01.560 --> 00:53:05.120
which is down here in
my secret tiling code,

00:53:05.120 --> 00:53:08.510
I have this method that's the
funnel point for adding a building.

00:53:08.810 --> 00:53:13.340
So we also want to add those same
lines of code to that method so that

00:53:13.350 --> 00:53:16.130
every time a building is created,
it's created with the appropriate

00:53:16.200 --> 00:53:19.310
content scale factor to cause it
to draw at the right resolution.

00:53:19.510 --> 00:53:24.040
And so that will allow us
to really scroll up and have

00:53:24.200 --> 00:53:25.600
nicely zoomed in buildings.

00:53:25.600 --> 00:53:30.240
So I'll start by zooming in.

00:53:30.530 --> 00:53:32.200
Nice, crisp drawing.

00:53:32.240 --> 00:53:34.520
And then as I continue to scroll,
the new buildings that

00:53:34.580 --> 00:53:36.380
come in are crisp as well.

00:53:36.420 --> 00:53:39.390
So that's the redrawing after zooming.

00:53:46.090 --> 00:53:50.440
All right, so the one thing that Eliza
left out of that is that those

00:53:50.440 --> 00:53:52.100
buildings are actually pretty large,
right?

00:53:52.170 --> 00:53:54.400
Some of them took up
almost the entire screen,

00:53:54.420 --> 00:53:56.970
and she zoomed them in eight times.

00:53:57.100 --> 00:54:00.570
So if you had a view that was
taking up most of the screen and

00:54:00.570 --> 00:54:05.090
you zoomed it in almost eight times,
some of those buildings were taking up

00:54:05.090 --> 00:54:09.000
upwards of eight megabytes of RAM just
to draw that backing story for that.

00:54:09.000 --> 00:54:13.000
So, probably don't want to do it
with really big buildings.

00:54:13.000 --> 00:54:15.450
You would only be able to have a few
before you'd all of a sudden be out of

00:54:15.450 --> 00:54:16.970
memory and couldn't do anything else.

00:54:17.110 --> 00:54:19.510
So it's really good for
small stuff like text labels,

00:54:19.510 --> 00:54:22.000
not great for really big
things like buildings.

00:54:22.000 --> 00:54:24.000
So there's more information available.

00:54:24.000 --> 00:54:26.000
Bill Dudney is our
Application Frameworks Evangelist.

00:54:26.000 --> 00:54:30.000
Of course, the ScrollView Programming
Guide for iOS is available online,

00:54:30.000 --> 00:54:32.000
and the dev forums are a great resource.

00:54:32.000 --> 00:54:37.000
There's a TableView Changes, Tips,
and Tricks session later this week.

00:54:37.000 --> 00:54:38.000
If I could read that.

00:54:38.000 --> 00:54:39.000
read that.

00:54:39.000 --> 00:54:40.390
Knob Hill, Thursday at 2 o'clock.

00:54:40.590 --> 00:54:41.070
Thanks.
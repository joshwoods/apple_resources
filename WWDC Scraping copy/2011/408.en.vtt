WEBVTT

00:00:11.610 --> 00:00:12.480
Thank you.

00:00:12.660 --> 00:00:17.180
That helps.

00:00:17.200 --> 00:00:22.380
So I'm here to update you on what's
been going on with HTTP live streaming.

00:00:22.380 --> 00:00:23.490
I'm Roger Pantoos.

00:00:23.490 --> 00:00:24.740
I'm a core media engineer.

00:00:24.740 --> 00:00:28.140
I was also responsible
for writing the draft.

00:00:28.140 --> 00:00:30.600
So you may have read some of my prose.

00:00:32.260 --> 00:00:35.870
What I'm going to do today is I'm going
to talk about three different things.

00:00:35.870 --> 00:00:39.180
Some of you may be new to the
idea of HTTP live streaming,

00:00:39.180 --> 00:00:42.850
and so I'm going to take a really
short period of time to explain

00:00:42.850 --> 00:00:44.780
how that technology works.

00:00:44.780 --> 00:00:49.080
Next, I'm going to discuss some of the
new features they were adding

00:00:49.160 --> 00:00:51.450
to HTTP live streaming in iOS 5.

00:00:51.500 --> 00:00:56.850
And finally, I'm going to spend some time
discussing some techniques that you

00:00:56.850 --> 00:01:02.120
can use in your streams and in your
applications in order to perform well.

00:01:02.300 --> 00:01:04.120
on our platforms.

00:01:04.140 --> 00:01:05.510
So,

00:01:05.990 --> 00:01:08.140
HTTP Live Streaming.

00:01:08.210 --> 00:01:14.380
Essentially, it's a way that you can use
standard HTTP servers and the

00:01:14.400 --> 00:01:18.650
default web infrastructure,
CDNs like Akamai and things like that,

00:01:18.730 --> 00:01:23.880
to host live and on-demand audio
and video content to iOS devices

00:01:23.880 --> 00:01:26.820
and now to other devices as well.

00:01:26.870 --> 00:01:28.000
How does it work?

00:01:28.060 --> 00:01:30.040
Well, here's the really short version.

00:01:30.160 --> 00:01:33.760
What you do is you take your media
presentation and you divide it

00:01:33.760 --> 00:01:37.670
up into these little segments,
maybe 10 seconds each

00:01:37.980 --> 00:01:42.380
You make a URL for each of the
segments and you make a playlist file.

00:01:42.410 --> 00:01:46.580
And you put the URL to each segment
into the playlist file and then toss

00:01:46.580 --> 00:01:49.800
all of that up onto an HTTP server.

00:01:49.870 --> 00:01:52.500
For an on-demand content, you're done.

00:01:52.620 --> 00:01:56.580
If a client wants to play that,
what he does is he

00:01:56.580 --> 00:02:00.200
downloads the playlist file,
and then he downloads and plays

00:02:00.200 --> 00:02:02.320
each media URL in sequence.

00:02:02.400 --> 00:02:05.540
That's all you need to do
for an on-demand content.

00:02:05.540 --> 00:02:08.140
If it's live,
then what's happening is content

00:02:08.460 --> 00:02:12.200
is being added to the playlist
file as it's being generated,

00:02:12.200 --> 00:02:16.720
and the client will typically reload
the playlist file about every 10

00:02:16.720 --> 00:02:19.350
seconds to discover those new segments.

00:02:19.910 --> 00:02:22.690
Graphically, it looks like this.

00:02:22.890 --> 00:02:25.940
We've got our segment files,
we've got our playlist.

00:02:25.960 --> 00:02:28.400
We create URLs for each
of the segment files,

00:02:28.550 --> 00:02:30.860
stick them into the playlist.

00:02:31.230 --> 00:02:32.790
That's it if it's on-demand.

00:02:32.910 --> 00:02:35.260
If it's live,
then periodically we're creating

00:02:35.260 --> 00:02:37.560
new segments and adding them to
the end of the playlist file.

00:02:39.140 --> 00:02:42.000
What do these playlists files look like?

00:02:42.060 --> 00:02:44.750
Well,
we use the M3U playlist file format.

00:02:44.750 --> 00:02:46.380
It's an extremely simple format.

00:02:46.430 --> 00:02:49.730
It's basically just a text file
with a list of URLs and some

00:02:50.280 --> 00:02:52.210
informational tags attached to them.

00:02:52.300 --> 00:02:55.160
So in this example here
for an on-demand playlist,

00:02:55.160 --> 00:02:58.050
what we have at the top is
some tags which refer to some

00:02:58.080 --> 00:03:01.500
general aspects of the playlist,
such as its version and the

00:03:01.680 --> 00:03:03.460
target duration of the media.

00:03:04.080 --> 00:03:08.040
The main body of the playlist
is this list of URLs that

00:03:08.040 --> 00:03:10.090
have tags attached to it.

00:03:10.170 --> 00:03:14.230
And in this example,
you can see that the URLs have Xinf tags,

00:03:14.350 --> 00:03:18.140
and what these do is they
supply the duration of the

00:03:18.170 --> 00:03:19.650
file sequence of the segments.

00:03:19.680 --> 00:03:21.720
And so in this case,
file sequence A has a

00:03:21.770 --> 00:03:25.860
duration of 9.7 seconds,
file sequence B is 9.2 seconds, etc.

00:03:28.120 --> 00:03:31.850
At the end of this playlist file is
an endless tag and that just indicates

00:03:32.110 --> 00:03:33.870
that it's an on-demand playlist.

00:03:34.020 --> 00:03:37.700
We don't expect any new segments to
unexpectedly appear at the end of it.

00:03:37.740 --> 00:03:40.860
So you could keep refreshing it forever
and this would be all you would see.

00:03:42.560 --> 00:03:48.490
So this covers the simple case of
presenting content at a single bit rate.

00:03:48.510 --> 00:03:53.850
But there are some refinements that make
HTTP streaming work particularly well.

00:03:53.850 --> 00:03:58.590
The first is that you can actually encode
your content at multiple bit rates.

00:03:58.590 --> 00:04:02.950
So multiple qualities of
different network sizes.

00:04:03.720 --> 00:04:06.550
And when you do that,
you put each encoding quality

00:04:06.550 --> 00:04:08.200
into its own playlist file.

00:04:08.200 --> 00:04:10.770
And when you ask us to
play your presentation,

00:04:10.770 --> 00:04:13.840
you present all those
playlist files to us at once.

00:04:13.840 --> 00:04:17.560
When you do it that way,
our client will adaptively choose

00:04:17.560 --> 00:04:21.450
the best bit rate to match the
connection speed of the network

00:04:21.450 --> 00:04:23.580
the user is currently using.

00:04:23.600 --> 00:04:28.290
This makes it work well across a
wide range of connected devices with

00:04:28.290 --> 00:04:31.020
all kinds of different throughput.

00:04:31.020 --> 00:04:33.600
And it's particularly important.

00:04:33.720 --> 00:04:39.230
In the mobile space where the available
bandwidth varies tremendously.

00:04:39.720 --> 00:04:42.680
So doing it is actually
pretty straightforward.

00:04:42.690 --> 00:04:44.870
As I said,
you've got these playlist files,

00:04:44.870 --> 00:04:45.870
each at a different bit rate.

00:04:46.080 --> 00:04:48.890
You take each playlist file
and you put it into a master

00:04:48.900 --> 00:04:50.930
playlist or a variant playlist.

00:04:50.930 --> 00:04:53.050
And it's the same playlist format.

00:04:53.260 --> 00:04:54.200
It's M3U.

00:04:54.200 --> 00:04:57.650
The difference is in this case,
the URLs actually refer to

00:04:57.750 --> 00:04:59.540
those individual playlists.

00:04:59.540 --> 00:05:03.060
And the tags are stream
info tags that describe the

00:05:03.070 --> 00:05:05.420
streams in the playlist files.

00:05:05.420 --> 00:05:08.860
So for example,
what we have here is the first URL is

00:05:08.990 --> 00:05:14.310
a playlist to the stream that's
encoded at 150 kilobits per second.

00:05:14.310 --> 00:05:18.760
The second example is the same content
that's been encoded at a higher

00:05:18.860 --> 00:05:21.830
quality of 640 kilobits per second.

00:05:21.850 --> 00:05:24.670
So you produce this playlist file.

00:05:24.670 --> 00:05:29.900
If you hand it to us to play,
we'll play your content adaptively.

00:05:30.480 --> 00:05:33.130
The next variant,
or the next refinement I'd like to

00:05:33.130 --> 00:05:38.360
discuss is that your content doesn't
have to be a single uninterrupted movie.

00:05:38.420 --> 00:05:41.560
It can be a little bit of this,
and then a little bit of that,

00:05:41.620 --> 00:05:42.960
and then back to your movie.

00:05:42.960 --> 00:05:46.710
And this is often used
for ad-supported content.

00:05:46.710 --> 00:05:48.780
We sometimes also see it
on program boundaries.

00:05:49.600 --> 00:05:52.850
So putting discontinuities
into your playlist is simple

00:05:52.880 --> 00:05:54.340
in HTTP Live Streaming.

00:05:54.340 --> 00:05:58.040
All you need to do is find the first
media segment of the new content

00:05:58.040 --> 00:06:00.340
and stick a discontinuity tag on it.

00:06:00.440 --> 00:06:03.230
Finally, you can encrypt your content.

00:06:03.230 --> 00:06:06.770
And you would do this to
control who has access to it.

00:06:06.840 --> 00:06:10.530
To do so,
you encrypt the content first of all,

00:06:10.640 --> 00:06:16.830
and then you tag the encrypted media
segments in the playlist with a key tag.

00:06:16.880 --> 00:06:19.400
And the key tag contains a URL.

00:06:19.600 --> 00:06:20.960
And then you add a key tag
to the URL that allows us,

00:06:20.990 --> 00:06:23.490
the player,
to load the key and decrypt the

00:06:23.490 --> 00:06:25.460
content if we're authorized.

00:06:25.600 --> 00:06:30.160
So multiple encoding
contents or qualities,

00:06:30.210 --> 00:06:32.460
discontinuities, encrypted media.

00:06:32.500 --> 00:06:35.050
Those are the major features
of HTTP Live Streaming that

00:06:35.050 --> 00:06:37.020
make them work really well.

00:06:39.340 --> 00:06:42.450
When it comes time to
actually play the streams,

00:06:42.450 --> 00:06:44.030
we have a choice of APIs for you.

00:06:44.030 --> 00:06:47.720
At the highest level,
you can simply stick the URL to

00:06:47.720 --> 00:06:52.180
your master playlist into an
HTML5 video element and let

00:06:52.290 --> 00:06:57.190
UI WebView control the rest of the
presentation and control of playback,

00:06:57.280 --> 00:06:59.900
whether in Safari or in a UI WebView.

00:07:01.240 --> 00:07:04.280
Programmatically,
you can also use the MPMoviePlayer

00:07:04.280 --> 00:07:06.740
object from the MediaPlayer framework.

00:07:06.820 --> 00:07:11.620
And this is really convenient because
it will handle putting up a UI for you.

00:07:11.620 --> 00:07:12.880
It will handle all the user interaction.

00:07:12.890 --> 00:07:16.620
It's a really easy way to have your
application play a live stream.

00:07:16.620 --> 00:07:20.010
Finally,
you can use the AVPlayerItem object

00:07:20.010 --> 00:07:22.630
in the AVFoundation framework.

00:07:22.720 --> 00:07:26.770
And you would do this to get
the highest degree of control

00:07:26.770 --> 00:07:29.690
possible when playing your stream.

00:07:29.700 --> 00:07:30.250
Including if you want
to play a live stream,

00:07:30.250 --> 00:07:31.220
you can use the AVPlayerItem object
in the AVFoundation framework.

00:07:31.220 --> 00:07:51.870
And you can also use the AVPlayerItem
object in the AVFoundation framework.

00:07:52.150 --> 00:07:54.700
What you can do with HTTP streaming,
how it looks on the server,

00:07:54.860 --> 00:07:58.280
how you play it on the client,
that's it in a nutshell.

00:07:58.380 --> 00:08:02.170
So now, kind of the fun part,
we get to talk about some of the new

00:08:02.190 --> 00:08:06.900
features that we've added to HTTP live
streaming since last year's conference.

00:08:06.930 --> 00:08:11.130
And the first thing I'd like to
discuss is alternative audio.

00:08:11.350 --> 00:08:12.690
So what is that?

00:08:12.810 --> 00:08:18.760
Well, it's not uncommon for a video
presentation to have a choice

00:08:18.760 --> 00:08:21.970
of different audio that can
be listened to along with it.

00:08:22.010 --> 00:08:25.270
Some examples of this are you might
have a movie that has been dubbed

00:08:25.540 --> 00:08:28.480
in several different languages,
or you might have the audio

00:08:28.480 --> 00:08:30.260
from a director's commentary.

00:08:30.260 --> 00:08:34.060
If you're watching a live baseball game,
it's not uncommon for there

00:08:34.260 --> 00:08:37.330
to be two audio broadcasts
accompanying the same video,

00:08:37.330 --> 00:08:40.550
one that's directed at the
home team audience and one that

00:08:40.550 --> 00:08:42.440
is directed at the away team.

00:08:42.500 --> 00:08:44.660
So alternative audio is pretty useful.

00:08:44.660 --> 00:08:47.800
You can add some compelling
value to your applications.

00:08:47.800 --> 00:08:51.390
But for a network playback stack,
there are some challenges

00:08:51.390 --> 00:08:53.420
with doing alternative audio.

00:08:53.420 --> 00:08:55.160
And it starts with how you approach it.

00:08:55.160 --> 00:08:56.680
There are a few different ways.

00:08:56.680 --> 00:09:00.050
One approach you can take is
you can simply take all the

00:09:00.090 --> 00:09:02.850
different... audio choices,
all the languages, all the different,

00:09:02.860 --> 00:09:06.260
you know, variants,
and you can put them into the same

00:09:06.260 --> 00:09:10.390
media file and download the media file
and just play what you want out of it.

00:09:10.460 --> 00:09:14.050
The problem with doing it this way
is that now you're downloading all

00:09:14.070 --> 00:09:17.620
the languages and all the audio
you're never going to listen to,

00:09:17.620 --> 00:09:19.960
but you're still paying
for it with your precious,

00:09:19.970 --> 00:09:21.470
precious network bandwidth.

00:09:21.480 --> 00:09:23.880
And so it's not efficient.

00:09:23.900 --> 00:09:27.550
Another approach you can take,
and in fact you can do this in iOS 4,

00:09:27.700 --> 00:09:30.140
is you can simply take your presentation.

00:09:30.260 --> 00:09:31.520
Let's say it's authored in English.

00:09:31.520 --> 00:09:35.380
And you can duplicate the entire thing,
replacing the English audio

00:09:35.380 --> 00:09:38.910
with the Spanish audio or the
Italian audio or what have you.

00:09:38.920 --> 00:09:41.210
This has its own problem.

00:09:41.220 --> 00:09:43.400
It's expensive from a
storage point of view.

00:09:43.400 --> 00:09:46.510
And to illustrate that,
I'd like to show you an example.

00:09:46.520 --> 00:09:49.750
So what I'm showing you
here is the baseline cost of

00:09:49.750 --> 00:09:51.860
storing an HTTP live stream.

00:09:51.880 --> 00:09:55.380
When you encode your stream,
we recommend that you start with

00:09:55.380 --> 00:10:00.100
an audio-only encoding and that you
additionally have several different VDs.

00:10:00.260 --> 00:10:03.610
And you can also use video encodings
at different bit rates so that clients

00:10:03.640 --> 00:10:06.780
in different network conditions
can still get a good experience.

00:10:08.270 --> 00:10:10.860
When you follow our
recommended encoding levels,

00:10:10.920 --> 00:10:15.910
this ends up being about 1.6 gigabytes
of data for every hour of content.

00:10:15.920 --> 00:10:17.840
So it's a fair bit.

00:10:17.880 --> 00:10:21.790
But now imagine that what you'd
like to do is take this movie,

00:10:21.790 --> 00:10:24.610
let's say,
and you'd like to offer it in Spanish and

00:10:24.610 --> 00:10:26.320
a few other languages as well.

00:10:26.320 --> 00:10:29.890
If you were to simply take the
whole thing and duplicate it,

00:10:29.950 --> 00:10:32.740
well, you've just multiplied it by four.

00:10:33.300 --> 00:10:37.710
And so now you've got six and
a half gigabytes of storage

00:10:37.770 --> 00:10:40.070
for every hour of content.

00:10:40.080 --> 00:10:42.230
It's a lot of storage.

00:10:42.240 --> 00:10:45.440
And more to the point,
if you happen to be paying a CDN like

00:10:45.440 --> 00:10:49.990
Akamai on a per megabyte basis to store
this content on their origin server,

00:10:49.990 --> 00:10:52.190
it gets expensive pretty quickly as well.

00:10:52.200 --> 00:10:54.410
And it's not like Akamai loves it.

00:10:54.640 --> 00:10:56.950
Because remember,
what they've got to do is they've

00:10:57.040 --> 00:10:59.880
got to puff all this content
out to their edge servers.

00:10:59.880 --> 00:11:02.340
And in this case,
what can happen is that they can

00:11:02.340 --> 00:11:05.920
pull... They can pull a bunch of
video content that has English audio

00:11:06.010 --> 00:11:07.620
embedded into it out to an edge.

00:11:07.620 --> 00:11:10.600
And then the next person it connects
wants to see the Spanish content.

00:11:10.710 --> 00:11:12.980
And so now they've got to
eject the English content.

00:11:13.100 --> 00:11:15.800
They've got to pull in the
Spanish content even though 90%

00:11:15.800 --> 00:11:17.570
of it is actually duplicate video.

00:11:17.580 --> 00:11:20.930
So it really doesn't work that well.

00:11:20.960 --> 00:11:24.360
And we decided to address it in iOS 5.

00:11:24.400 --> 00:11:25.680
How?

00:11:25.840 --> 00:11:31.960
What we do is we allow you to specify
that the audio and video be pulled

00:11:32.070 --> 00:11:32.880
from separate locations of the system.

00:11:32.900 --> 00:11:35.620
So if you're using iOS 5,
you can pull in the Spanish content from

00:11:35.700 --> 00:11:38.220
separate locations on your web server.

00:11:38.240 --> 00:11:40.790
And we've taught the player
to download both the audio

00:11:40.950 --> 00:11:42.640
and video streams in parallel.

00:11:42.820 --> 00:11:47.180
What this allows you to do is
offer multiple audio renditions

00:11:47.180 --> 00:11:51.440
of your content simultaneously
with a minimal storage overhead.

00:11:51.610 --> 00:11:57.980
And as an additional bonus,
this allows us to allow you to

00:11:58.000 --> 00:12:01.470
change the audio on the fly.

00:12:02.260 --> 00:12:06.160
Thank you.

00:12:06.160 --> 00:12:07.960
So what does that do
to our storage picture?

00:12:08.140 --> 00:12:10.240
Well, let's go back.

00:12:10.240 --> 00:12:12.250
Rather than having this kind
of thing where you've got

00:12:12.250 --> 00:12:14.640
six and a half gigabytes,
you're duplicating all your video.

00:12:14.640 --> 00:12:17.830
All you need to do is create
an audio-only playlist,

00:12:17.830 --> 00:12:21.920
and this is compatible with your
existing audio-only playlists,

00:12:21.920 --> 00:12:24.580
for each of the different languages.

00:12:24.580 --> 00:12:26.000
These guys are all really small.

00:12:26.000 --> 00:12:29.430
And then have them accompany
video-only playlists for all

00:12:29.430 --> 00:12:31.200
of your different variants.

00:12:32.530 --> 00:12:35.780
What we have here now
is all four languages,

00:12:35.780 --> 00:12:41.310
audio-only, plus all six video variants,
and the storage cost is

00:12:41.310 --> 00:12:46.330
actually less than it would be
for English-only under iOS 4,

00:12:46.330 --> 00:12:51.280
because we're no longer duplicating
the audio in each video segment.

00:12:51.800 --> 00:12:59.600
This is a much better approach from
the point of view of storage cost.

00:12:59.800 --> 00:13:01.820
So if you'd like to set
up your streams this way,

00:13:01.920 --> 00:13:03.420
there's a little bit
more you need to tell us.

00:13:03.420 --> 00:13:06.530
You need to tell us
principally where the audio is.

00:13:06.620 --> 00:13:10.600
And to do that,
we have defined a new tag in

00:13:10.600 --> 00:13:12.470
the master variant playlist.

00:13:12.570 --> 00:13:14.140
It's the media tag.

00:13:14.280 --> 00:13:17.750
And what the media tag does
is essentially it tells us

00:13:17.910 --> 00:13:22.090
that here's a place where we
can find some optional media.

00:13:22.250 --> 00:13:25.640
and it allows you to group the media.

00:13:25.660 --> 00:13:28.610
And so in this case,
each both of these media

00:13:28.610 --> 00:13:29.920
tags has the same group ID.

00:13:29.930 --> 00:13:32.140
This indicates that they're
part of the same group.

00:13:32.260 --> 00:13:34.420
In this case, it's an audio group.

00:13:34.450 --> 00:13:37.000
And the first member of the
group is the English audio.

00:13:37.030 --> 00:13:40.370
The second member is the Spanish audio.

00:13:41.040 --> 00:13:44.690
Now where you use this is down
below in the stream info tag.

00:13:44.690 --> 00:13:48.320
The stream info tag gets a new attribute,
the audio attribute.

00:13:48.320 --> 00:13:50.370
It's set to the value of the group.

00:13:50.440 --> 00:13:54.080
And what this indicates to us is
although we may be pulling the

00:13:54.080 --> 00:13:58.080
video from the main URL down there,
we're going to pull the audio from

00:13:58.450 --> 00:14:00.610
one or another member of the group.

00:14:00.720 --> 00:14:04.920
Of course, your video may still be
encoded at multiple qualities.

00:14:04.920 --> 00:14:07.670
And if it is,
you simply have more stream info

00:14:07.670 --> 00:14:11.700
tags and you use the same audio
attribute to indicate that they're

00:14:11.700 --> 00:14:14.420
all pulling audio from the same group.

00:14:16.520 --> 00:14:21.930
So, the next step is actually choosing
which audio you'd like to listen to.

00:14:21.930 --> 00:14:26.880
And to do that, we have a new API in iOS
called the Media Selection API.

00:14:26.880 --> 00:14:30.870
What this API allows you to do
is to look at an AV asset and

00:14:30.870 --> 00:14:36.060
discover that you actually have
optional media attributes in it.

00:14:36.120 --> 00:14:39.520
And to select the one you'd
like to use for playback.

00:14:39.520 --> 00:14:44.800
And the way it works is you start by
getting a reference to your AV asset,

00:14:44.800 --> 00:14:48.810
and then you load the available
media characteristics with

00:14:48.810 --> 00:14:50.100
media selection options.

00:14:50.100 --> 00:14:54.920
Or the AMCWMSO, as we like to call it.

00:14:56.640 --> 00:15:00.300
It's a long name because it
has a bunch of stuff in it.

00:15:00.380 --> 00:15:02.060
It doesn't just have
all the optional audio,

00:15:02.060 --> 00:15:05.260
but it can have optional video or a
bunch of other different things as well.

00:15:05.350 --> 00:15:09.000
The next step is to call one of
the selection APIs that says,

00:15:09.210 --> 00:15:11.670
out of the universe of
media options you've got,

00:15:11.670 --> 00:15:14.250
filter out what's audible.

00:15:14.250 --> 00:15:15.840
Filter out my audio options.

00:15:15.840 --> 00:15:18.970
That produces a selection group.

00:15:19.200 --> 00:15:21.590
And then the next stage is to
walk through the entries in

00:15:21.610 --> 00:15:24.170
the selection group and choose
which one you'd like to use.

00:15:24.240 --> 00:15:26.190
And you can do this by
inspecting each one,

00:15:26.190 --> 00:15:29.990
looking at its language tag or its name,
throwing up a UI, different things.

00:15:29.990 --> 00:15:33.610
Or you can just be lazy like me and
you can just pick the first one,

00:15:33.610 --> 00:15:35.300
object or at index zero.

00:15:36.710 --> 00:15:40.320
So you get a media option,
you get one of the

00:15:40.320 --> 00:15:43.180
optional audio selections.

00:15:43.180 --> 00:15:47.760
And then you take your asset and you
create an AV player item with it.

00:15:47.860 --> 00:15:51.440
And then you tell the player item
to select the media option you've

00:15:51.440 --> 00:15:53.370
chosen in the media selection group.

00:15:53.460 --> 00:15:56.990
And as I described earlier,
you can either do this once prior to

00:15:57.090 --> 00:16:00.200
starting playback of the player item,
or you can do it at

00:16:00.200 --> 00:16:03.290
runtime while it's playing,
and that will cause us

00:16:03.400 --> 00:16:04.870
to switch the audio.

00:16:06.010 --> 00:16:07.750
And I'd like to show you that now.

00:16:07.760 --> 00:16:10.140
And so to do that,
I'd like to bring up my

00:16:10.530 --> 00:16:13.180
colleague and co-authors back,
Bill May.

00:16:13.220 --> 00:16:14.350
Thank you.

00:16:19.940 --> 00:16:25.430
Okay, so what Bill's gonna do is
we have a little demo app we

00:16:25.430 --> 00:16:28.310
wrote called Foreign Cinema,
and so Bill's gonna

00:16:28.310 --> 00:16:29.490
launch that application.

00:16:30.180 --> 00:16:32.220
and the first thing he's
going to do is load a movie.

00:16:32.260 --> 00:16:34.480
So let's choose the Phil and John show.

00:16:34.500 --> 00:16:35.980
I love that one.

00:16:36.190 --> 00:16:38.320
So here's our buddy, Johnny Ive.

00:16:38.370 --> 00:16:40.780
And what we're going to do next
is we're going to tap the language

00:16:40.850 --> 00:16:45.200
button to discover what kind
of audio we have in this movie.

00:16:45.220 --> 00:16:50.540
And what we've done here is we've gotten
a list of media selection options,

00:16:50.540 --> 00:16:55.620
and we've iterated through them,
and we've thrown up a UI with the name

00:16:55.740 --> 00:16:57.720
that's embedded in each media tag.

00:16:57.940 --> 00:17:01.090
And so to start with,
Bill's going to pick English.

00:17:01.310 --> 00:17:04.170
And now we're going to play that.

00:17:04.200 --> 00:17:06.780
And now we have Johnny speaking English.

00:17:06.800 --> 00:17:08.480
He probably does a better job than I do.

00:17:08.540 --> 00:17:09.330
So let's handicap him.

00:17:09.420 --> 00:17:11.930
Let's push him over to French.

00:17:12.620 --> 00:17:18.760
In fact, let's listen to the
director's commentary.

00:17:18.760 --> 00:17:19.260
What the heck?

00:17:19.320 --> 00:17:21.990
Avoid getting moisture into openings.

00:17:22.000 --> 00:17:25.880
Don't use window cleaners,
household cleaners, aerosol sprays,

00:17:25.880 --> 00:17:26.400
solvents.

00:17:26.400 --> 00:17:26.940
All right.

00:17:27.040 --> 00:17:28.440
That's riveting, Bill.

00:17:28.440 --> 00:17:29.560
Thanks very much.

00:17:29.560 --> 00:17:31.540
So that was alternative audio.

00:17:33.780 --> 00:17:39.690
The next feature I'd like to discuss
is byte range support for segments.

00:17:39.800 --> 00:17:43.730
Now traditionally, HTTP live streaming,
you have your playlist file

00:17:43.890 --> 00:17:47.490
and you have a bunch of
URLs indicating media segments.

00:17:47.610 --> 00:17:50.470
And traditionally,
each media segment has been

00:17:50.470 --> 00:17:52.140
the entire content of a URL.

00:17:52.160 --> 00:17:55.940
And what this means is that if you
have 700 media segments in your movie,

00:17:55.940 --> 00:17:59.280
you actually have 700 little
files up on your web server.

00:17:59.430 --> 00:18:03.800
In iOS 5, we're adding the ability to
specify a media segment as

00:18:03.860 --> 00:18:06.260
a sub-range of a larger URL.

00:18:06.260 --> 00:18:11.480
And what this allows you to do is to
consolidate your media segments into

00:18:11.480 --> 00:18:13.900
larger files or a single large file.

00:18:13.900 --> 00:18:18.370
The primary benefit of this is that
when a client is playing your media,

00:18:18.370 --> 00:18:21.450
rather than sort of downloading
a segment from over here,

00:18:21.450 --> 00:18:23.520
then downloading the second file,
then downloading this one,

00:18:23.520 --> 00:18:26.570
then downloading this one,
it's actually walking through

00:18:26.570 --> 00:18:28.100
a larger file in sequence.

00:18:28.140 --> 00:18:31.020
And this allows servers like proxy
caching to be able to do that.

00:18:31.070 --> 00:18:32.600
So,
if you're using a lot of other servers,

00:18:32.600 --> 00:18:34.420
like proxy caching servers,
such as Akamai,

00:18:34.420 --> 00:18:38.410
to get a much better idea of what
it needs to prefetch in order

00:18:38.420 --> 00:18:41.830
to ensure that the next segment
you're going to want is in the

00:18:41.900 --> 00:18:43.780
cache at the time that you want it.

00:18:43.780 --> 00:18:46.700
As a kind of a side bonus,
it also means that you end up

00:18:46.700 --> 00:18:48.740
with far fewer files to manage.

00:18:48.740 --> 00:18:51.450
If you have many video
variants and a long movie,

00:18:51.480 --> 00:18:56.120
you could have thousands of individual
segment files using byte range support,

00:18:56.120 --> 00:18:57.480
you only get a few.

00:18:57.480 --> 00:19:00.080
Graphically, it looks like this, old way.

00:19:00.250 --> 00:19:02.680
You have individual segment files.

00:19:02.680 --> 00:19:03.970
Each one has a URL.

00:19:03.970 --> 00:19:05.400
It's in a playlist.

00:19:05.400 --> 00:19:07.800
Using byte range support,
we can consolidate all the

00:19:08.220 --> 00:19:09.650
segments into a single file.

00:19:09.650 --> 00:19:12.510
I'm calling it media.ts.

00:19:12.510 --> 00:19:15.290
And you still have playlist entries,
but now the playlist entries,

00:19:15.290 --> 00:19:18.880
in addition to the URL,
have the byte range specifier that say

00:19:18.880 --> 00:19:21.150
it's actually this sub-range of the

00:19:21.780 --> 00:19:27.210
Now, there is one caveat I'd like
to mention with byte ranges and

00:19:27.210 --> 00:19:28.930
it has to do with live content.

00:19:29.160 --> 00:19:30.330
And it's this.

00:19:30.330 --> 00:19:33.070
When your application is
watching a live stream,

00:19:33.070 --> 00:19:36.520
it's making media file requests
over the big wide internet.

00:19:36.520 --> 00:19:40.060
And it may be making them through
a number of different servers.

00:19:40.060 --> 00:19:44.110
Caching servers like Akamai,
corporate proxy servers, what have you.

00:19:44.800 --> 00:19:49.350
And all of these servers do a great job
at caching entire resource requests.

00:19:49.350 --> 00:19:52.990
And some of them do a pretty
good job at caching byte ranges.

00:19:52.990 --> 00:19:57.010
And some of them kind of have
a sense of how to handle files

00:19:57.020 --> 00:19:59.690
that grow dynamically over time.

00:19:59.720 --> 00:20:03.650
But when you put all this stuff together,
you're kind of asking for trouble.

00:20:03.760 --> 00:20:07.520
It becomes somewhat unreliable to make
these requests over the internet because

00:20:07.790 --> 00:20:10.640
even if your web server can handle it,
your intermediary

00:20:10.640 --> 00:20:12.210
caching servers may not.

00:20:12.220 --> 00:20:14.450
And for that reason,
we recommend that you do a great

00:20:14.450 --> 00:20:14.780
job at caching byte ranges.

00:20:17.840 --> 00:20:20.440
And of course, there's always static
for on-demand content.

00:20:20.580 --> 00:20:22.770
We recommend that they be
static for live as well.

00:20:22.790 --> 00:20:26.230
So it doesn't matter if they're
really small or really large,

00:20:26.230 --> 00:20:29.970
just as long as you don't append
to them after you start playing.

00:20:30.920 --> 00:20:33.770
So that being said,
here's how you specify

00:20:33.770 --> 00:20:35.760
byte range media segments.

00:20:35.850 --> 00:20:36.820
We have a new tag.

00:20:36.820 --> 00:20:38.280
We called it byte range.

00:20:38.280 --> 00:20:41.440
And it specifies the length of the range.

00:20:41.460 --> 00:20:42.860
It may also specify the offset.

00:20:43.700 --> 00:20:43.740
And it may also specify the offset.

00:20:43.740 --> 00:20:44.780
Unless the byte range adds up,
it's not going to be a good idea.

00:20:45.280 --> 00:20:48.040
It actually follows immediately
from the previous byte range,

00:20:48.120 --> 00:20:50.270
in which case the offset
can be optimized away.

00:20:50.530 --> 00:20:52.040
Here's an example of a playlist file.

00:20:52.040 --> 00:20:55.480
On the left, we have the old way where
we've got three segments.

00:20:55.500 --> 00:20:56.960
Each one is its own URL.

00:20:56.960 --> 00:21:00.260
It's a relative URL in this case.

00:21:00.260 --> 00:21:03.280
On the right, we have the new way.

00:21:03.280 --> 00:21:07.640
We still have three segments,
but now they're ranges into a single URL,

00:21:07.640 --> 00:21:12.070
media.ts, and we have the range tag that
specifies the byte ranges that

00:21:12.070 --> 00:21:14.200
they're actually occupying.

00:21:14.960 --> 00:21:19.050
So it's a pretty easy syntax,
and we actually found it to

00:21:19.050 --> 00:21:23.320
be quite handy for the next
feature I'd like to talk about,

00:21:23.320 --> 00:21:26.030
and that is Fast Forward Rewind.

00:21:26.080 --> 00:21:29.820
What we wanted to do with
Fast Forward Rewind is enable the

00:21:29.830 --> 00:21:34.130
use case where a user is looking
for a scene in your presentation,

00:21:34.130 --> 00:21:37.250
your movie, your TV show, what have you.

00:21:37.260 --> 00:21:38.560
They know it's in there somewhere.

00:21:38.590 --> 00:21:40.430
They don't quite remember
where in the movie it is,

00:21:40.430 --> 00:21:42.410
and so they'd like to scan
rapidly backward and forward

00:21:42.410 --> 00:21:44.810
through the movie looking for
the scene they'd like to play.

00:21:44.990 --> 00:21:46.390
play.

00:21:46.730 --> 00:21:51.220
We wanted to support the
most popular scanning speeds,

00:21:51.220 --> 00:21:56.840
so 16 times, 32 times, 64 times,
the reverse equivalence of those.

00:21:56.910 --> 00:21:59.970
And of course, being HTTP live streaming,
we wanted to work with

00:21:59.970 --> 00:22:01.570
live content as well.

00:22:01.880 --> 00:22:05.140
But again,
being as we're a network player,

00:22:05.190 --> 00:22:08.120
there are some challenges with this,
and the foremost challenge being,

00:22:08.160 --> 00:22:10.980
let's say I want to play your
content at 32 times real time.

00:22:10.980 --> 00:22:15.420
There's no way that I can download
all of your content 32 times faster

00:22:15.450 --> 00:22:17.780
than I'd like to play it normally.

00:22:17.780 --> 00:22:20.430
You might, with a fast network,
get four or five times.

00:22:20.460 --> 00:22:21.810
There's no way you're going to get 32.

00:22:25.080 --> 00:22:30.160
Fortunately, it isn't actually necessary
to download all the content.

00:22:30.190 --> 00:22:33.150
For instance, if you're watching all
the content at 32 times,

00:22:33.260 --> 00:22:34.850
that's over 1,000 frames a second.

00:22:34.850 --> 00:22:36.720
And believe me, it's just a blur.

00:22:36.770 --> 00:22:37.780
It's not useful.

00:22:37.780 --> 00:22:43.690
What you really want to do is you
want to display a carefully sort of

00:22:43.860 --> 00:22:49.360
a well-chosen selection of frames
at about 5 to 10 frames a second.

00:22:49.470 --> 00:22:52.850
And perceptually,
this allows users to orient

00:22:53.250 --> 00:22:57.310
where they are in the stream
and to stop when they want to.

00:22:57.570 --> 00:23:02.800
So the solution we have for
Fast Forward Rewind does exactly that.

00:23:02.800 --> 00:23:05.160
It's called iframe-only playback.

00:23:05.220 --> 00:23:09.370
Now, I'd like to spend a little bit of
time describing iframe-only playback,

00:23:09.370 --> 00:23:11.840
and to do that,
I have to make a brief detour into

00:23:11.840 --> 00:23:13.130
the mysteries of video encoding.

00:23:13.290 --> 00:23:16.310
So I hope you'll bear
with me for a moment.

00:23:16.600 --> 00:23:19.700
When video is encoded,
what you're doing is you're taking

00:23:19.700 --> 00:23:22.710
individual frames and you're
turning them into compressed frames.

00:23:22.710 --> 00:23:25.440
And every compressed
frame gets a frame type,

00:23:25.510 --> 00:23:26.380
their IP or B.

00:23:26.380 --> 00:23:30.370
Now, the only thing you really need to
take away from this is P and B frames,

00:23:30.530 --> 00:23:33.500
although they comprise most
of the frames in the movie,

00:23:33.500 --> 00:23:35.540
are a pain in the butt to deal with.

00:23:35.540 --> 00:23:38.670
And the reason for this is
that to decode a P or B frame,

00:23:38.690 --> 00:23:43.340
you also have to have a bunch of earlier
frames from previously in the movie.

00:23:44.180 --> 00:23:47.420
iFrames, on the other hand,
don't have this problem.

00:23:47.420 --> 00:23:48.560
They are independent.

00:23:48.560 --> 00:23:49.480
They stand alone.

00:23:49.500 --> 00:23:52.290
So in order to turn an
iFrame into a picture,

00:23:52.310 --> 00:23:56.770
all you have to do is load the part
of the file that contains the iFrame,

00:23:56.950 --> 00:24:04.500
its byte range,
and then run that through the

00:24:04.500 --> 00:24:11.850
decoder and you get a picture.

00:24:12.110 --> 00:24:19.440
One of the advantages of this approach
is that your content already has iframes.

00:24:19.440 --> 00:24:22.890
And so you don't need to produce
special purpose content for

00:24:22.890 --> 00:24:25.380
supporting fast forward and rewind.

00:24:25.380 --> 00:24:29.000
All you need to do is tell
us where your iframes are.

00:24:29.000 --> 00:24:32.440
And so to do that,
we have a new kind of playlist,

00:24:32.460 --> 00:24:35.000
and it's an iframe only playlist.

00:24:35.000 --> 00:24:39.960
Now -- Mom, is that you?

00:24:42.400 --> 00:24:49.800
So an iframe-only playlist is actually
almost identical to a regular playlist.

00:24:49.800 --> 00:24:51.700
Its job is to tell us
where the iframes are.

00:24:51.700 --> 00:24:55.530
And so what we have here is an example
where we have a couple of iframes in

00:24:55.530 --> 00:24:58.340
segment1.ts and a few more in segment2.

00:24:58.340 --> 00:25:02.460
And so we have our familiar
pattern here where we have a

00:25:02.460 --> 00:25:05.200
URL that has a bunch of tags on it.

00:25:05.220 --> 00:25:07.740
In the case of this one,
the tags are simply saying

00:25:07.740 --> 00:25:11.120
that I've got an iframe in
segment1.ts at this byte range.

00:25:12.580 --> 00:25:16.060
The only difference between
iframe-only playlists and regular

00:25:16.060 --> 00:25:19.970
playlists is that iframes do
not have an intrinsic duration.

00:25:19.970 --> 00:25:22.630
They're just sort of an instant in time.

00:25:22.660 --> 00:25:27.940
And so in an iframe-only playlist,
the ex-inf duration actually refers to

00:25:28.090 --> 00:25:30.730
what we call the span of the iframe.

00:25:31.400 --> 00:25:34.040
Or in other words,
the length of time between that

00:25:34.180 --> 00:25:38.060
current iframe and the next iframe
appearing in the playlist file.

00:25:38.060 --> 00:25:41.420
And so what this is saying here is
that segment one has two iframes.

00:25:41.420 --> 00:25:43.380
The first is at the beginning.

00:25:43.380 --> 00:25:45.920
The next is 4.12 seconds later.

00:25:46.000 --> 00:25:50.150
The third, which is in segment one,
is in 3.56 seconds and

00:25:50.160 --> 00:25:51.520
so on and so forth.

00:25:53.220 --> 00:25:56.930
So when you do this and when you
tell us where your iframes are in the

00:25:56.930 --> 00:26:01.330
content and you ask us to play a 32X,
what we're going to do is we're going

00:26:01.380 --> 00:26:02.800
to go through the iframe playlist.

00:26:02.800 --> 00:26:03.930
We're going to pull out all the iframes.

00:26:03.930 --> 00:26:05.150
We're going to play
them as fast as we can.

00:26:05.180 --> 00:26:06.430
How fast is that?

00:26:06.430 --> 00:26:07.730
Well, it depends.

00:26:09.340 --> 00:26:14.460
If it's relatively low bitrate content,
if it's 200, 300 kilobits and you've

00:26:14.460 --> 00:26:17.460
got an Ethernet connection,
you've got Wi-Fi,

00:26:17.460 --> 00:26:19.000
we're going to download them really fast.

00:26:19.000 --> 00:26:21.430
If you're over 3G and
these are HDI frames,

00:26:21.430 --> 00:26:23.520
it's going to take a little longer.

00:26:24.880 --> 00:26:26.500
What do we do about that, Dr.

00:26:26.630 --> 00:26:27.220
Science?

00:26:27.220 --> 00:26:28.490
I'm glad you asked.

00:26:28.490 --> 00:26:35.240
Just as HTTP Live Streaming can
play your content at 1x adaptively,

00:26:35.240 --> 00:26:38.290
we can do the same thing
with iframe-only playback.

00:26:38.290 --> 00:26:41.070
You can supply us with
multiple iframe playlists,

00:26:41.070 --> 00:26:44.640
one for each of the video variants
that you're offering to us.

00:26:44.640 --> 00:26:48.770
And that way, when we play it,
we have the flexibility to choose the

00:26:48.770 --> 00:26:52.830
bitrate of the iframes that we wish
to download so that we can create a

00:26:53.110 --> 00:26:57.220
good match between the frame rate we'd
like to achieve and the quality of

00:26:57.220 --> 00:26:59.980
the iframes that we'd like to display.

00:26:59.980 --> 00:27:02.830
And so, it's pretty easy to set up.

00:27:02.830 --> 00:27:08.470
Once you've got it set up this way,
then that's pretty much all you need on

00:27:08.470 --> 00:27:11.830
server side to do fast forward rewind.

00:27:11.860 --> 00:27:14.330
On the client side, it's even easier.

00:27:16.000 --> 00:27:18.140
All you need to do to do fast
forward rewind on a client

00:27:18.140 --> 00:27:19.140
is set the right property.

00:27:19.140 --> 00:27:22.860
There's a slight caveat
for HTTP live streaming,

00:27:22.860 --> 00:27:23.950
which is this.

00:27:24.110 --> 00:27:26.440
Because we don't always
have iframe playlists,

00:27:26.440 --> 00:27:29.560
because they're sort of an
optional feature of the stream,

00:27:29.560 --> 00:27:33.200
a given stream may not be capable
of doing fast forward rewind

00:27:33.200 --> 00:27:35.330
if there's no iframe playlists.

00:27:35.560 --> 00:27:39.410
And so we recommend that unless you
know you're playing your own streams

00:27:39.420 --> 00:27:43.200
and you know it has iframe playlists,
that you check the value of the can

00:27:43.330 --> 00:27:47.200
play fast forward and can play fast
reverse properties of the player item

00:27:47.200 --> 00:27:49.400
before you attempt to set the rate.

00:27:49.470 --> 00:27:51.050
In fact, it's probably a good
idea to do it anyway.

00:27:52.440 --> 00:27:59.620
Roger Pantoz: And so once you do that,
you'll get fast, high-quality,

00:27:59.620 --> 00:27:59.840
fast forward reverse.

00:27:59.910 --> 00:28:02.830
And I'd actually like to demo that,
if that's okay.

00:28:02.870 --> 00:28:05.390
And so let's bring Bill back up.

00:28:05.680 --> 00:28:09.640
We're going to switch back to the iPad
and run our Foreign Cinema app again,

00:28:09.680 --> 00:28:10.900
bring it back up.

00:28:10.940 --> 00:28:13.280
Now we're going to
choose a different movie.

00:28:13.280 --> 00:28:15.000
Let's choose Vacation Video.

00:28:15.040 --> 00:28:16.720
And so let's start playing it.

00:28:16.720 --> 00:28:19.600
And so we've got some
folks in the field here.

00:28:19.820 --> 00:28:22.840
Now, I know that there's a
scene later on this movie,

00:28:22.840 --> 00:28:25.200
which is a footy game
that I'd like to watch.

00:28:25.270 --> 00:28:26.400
And so let's go to fast forward.

00:28:26.400 --> 00:28:28.280
So we're going to start at eight times.

00:28:28.280 --> 00:28:29.030
It's a little bit further.

00:28:29.180 --> 00:28:30.160
Let's go to 64 times.

00:28:30.160 --> 00:28:32.920
And so now we're playing 64 times.

00:28:32.940 --> 00:28:34.230
And let's see.

00:28:34.230 --> 00:28:37.160
Okay, now we're in Amsterdam.

00:28:37.160 --> 00:28:38.650
And okay, pause that there.

00:28:38.650 --> 00:28:40.800
Yeah, okay, that's what I want.

00:28:40.800 --> 00:28:42.450
I think we went a little too far.

00:28:42.450 --> 00:28:43.960
Let's go backward a little bit.

00:28:44.270 --> 00:28:45.320
Yeah, okay.

00:28:45.320 --> 00:28:47.950
Yeah, now let's play that.

00:28:50.000 --> 00:28:53.000
We're still working on the transition
a little bit as to where we

00:28:53.000 --> 00:28:55.760
transition from the operating button.

00:28:55.760 --> 00:28:59.230
So what we've just done is we started
at the beginning of the presentation,

00:28:59.230 --> 00:29:02.290
we scanned forward rapidly
to find the part we want,

00:29:02.290 --> 00:29:05.760
we've zeroed in on it and we
started playing to--we started

00:29:05.790 --> 00:29:07.560
to see what we wanted to see.

00:29:07.560 --> 00:29:09.140
So, thanks Bill.

00:29:09.200 --> 00:29:09.970
Great.

00:29:09.970 --> 00:29:13.600
So, thank you.

00:29:13.600 --> 00:29:14.510
Thank

00:29:17.750 --> 00:29:19.900
So next I'd like to talk about
a couple of features we actually

00:29:19.900 --> 00:29:22.650
slipped into earlier iOS releases
but perhaps didn't do as great

00:29:22.710 --> 00:29:23.570
a job of telling you all about.

00:29:23.600 --> 00:29:25.930
The first is closed captions.

00:29:26.000 --> 00:29:28.800
As most of you know,
closed captions is a way to embed

00:29:29.100 --> 00:29:31.740
accessibility text into a video signal.

00:29:31.760 --> 00:29:36.170
And the format for the closed
captions has been defined by a

00:29:36.170 --> 00:29:39.730
well-known standard called CEA 608.

00:29:39.780 --> 00:29:45.340
And the good folks at ATSC have further
specified how to embed 608 closed

00:29:45.340 --> 00:29:48.790
captions into an NMPG-2 transport stream.

00:29:48.820 --> 00:29:53.590
And so in iOS 4.2 and onward,
if your streams,

00:29:53.610 --> 00:29:59.700
if your transport streams
contain 608 captions in the video

00:29:59.700 --> 00:30:03.240
and the user has selected it,
usually via the preference,

00:30:03.260 --> 00:30:07.050
then we will display those closed
captions while the video is playing.

00:30:07.060 --> 00:30:08.600
So that's pretty cool.

00:30:09.400 --> 00:30:14.770
Next I'd like to talk about
playback statistics at runtime.

00:30:14.880 --> 00:30:19.060
We delivered this in 4.2 and
what we did was we gave you a way

00:30:19.150 --> 00:30:22.540
to kind of peek into the player
while something was playing to

00:30:22.540 --> 00:30:24.570
get a sense of what was going on.

00:30:24.620 --> 00:30:27.260
We adopted the Apache model,
which is to say that we

00:30:27.340 --> 00:30:29.040
give you two different logs.

00:30:29.100 --> 00:30:31.020
One's an access log,
which generally tells you

00:30:31.100 --> 00:30:32.340
what's going on normally.

00:30:32.340 --> 00:30:34.840
And there's also an error log that
tells you about sort of exceptional

00:30:34.840 --> 00:30:36.180
conditions that have occurred.

00:30:36.180 --> 00:30:40.670
So in the access log, for instance,
we currently record a log entry every

00:30:40.790 --> 00:30:44.670
time we switch to a different variant,
a different bit rate.

00:30:44.750 --> 00:30:48.350
And amongst the things we record are
when the variant started to play,

00:30:48.410 --> 00:30:51.880
how much time we downloaded,
how much time was actually watched,

00:30:51.920 --> 00:30:54.530
the URL we pulled it from,
the server IP address,

00:30:54.730 --> 00:30:57.530
because sometimes you need to
debug a bad caching server,

00:30:57.630 --> 00:31:00.310
the number of times it changed,
and a bunch of kind of

00:31:00.550 --> 00:31:04.790
performance-related information about
the stream and how it was playing.

00:31:04.800 --> 00:31:07.620
Another thing that we
have is a playback GUID,

00:31:07.620 --> 00:31:10.970
which is essentially a string,
a pretty long string,

00:31:10.970 --> 00:31:13.780
that is unique to every single playback.

00:31:14.780 --> 00:31:18.180
And the interesting thing about
the GUID is it's actually supplied

00:31:18.330 --> 00:31:20.300
as part of the HTTP GET request.

00:31:20.300 --> 00:31:21.320
It's one of the headers.

00:31:21.320 --> 00:31:25.110
And so if you can combine statistics
that you've recorded on your

00:31:25.110 --> 00:31:28.740
app at runtime with server logs,
you can actually get a really

00:31:28.810 --> 00:31:32.360
good idea of what happened
to that particular playback.

00:31:33.870 --> 00:31:35.250
Getting the logs is really easy.

00:31:35.250 --> 00:31:40.520
You can get them from either an AVPlayer
item or an MPMoviePlayer controller.

00:31:40.520 --> 00:31:41.900
It's essentially the same API.

00:31:41.900 --> 00:31:44.710
You just ask for the access
log or the error log.

00:31:44.750 --> 00:31:48.370
And both logs are basically
an array of log entries.

00:31:48.370 --> 00:31:50.320
And so you can step through that array.

00:31:50.320 --> 00:31:52.440
You can examine each
individual log entry,

00:31:52.440 --> 00:31:53.960
see what stuff it's got in it.

00:31:54.740 --> 00:32:00.340
And we also provide a convenience API,
which is that extended log data guy.

00:32:00.440 --> 00:32:05.740
And what he does is he takes the entire
log and he formats it into a file format

00:32:05.910 --> 00:32:11.800
that makes it really convenient to post
to sort of an external logging server.

00:32:13.210 --> 00:32:17.130
The file format we've chosen
for our statistics is the

00:32:17.310 --> 00:32:19.800
W3C extended log file format.

00:32:19.800 --> 00:32:22.830
This is a long name for a
very simple file format.

00:32:23.340 --> 00:32:28.870
Again, it's just a text file with a bunch
of header fields at the beginning

00:32:28.870 --> 00:32:34.100
and then every log entry is a line
of text in tab-delimited format.

00:32:34.100 --> 00:32:39.600
This is the access log.

00:32:40.030 --> 00:32:41.160
The error logs are pretty similar.

00:32:41.160 --> 00:32:43.830
We found just internally that looking
at these logs when we're bringing up a

00:32:43.830 --> 00:32:47.100
stream can give us a tremendous amount
of information about what's going on.

00:32:47.100 --> 00:32:51.010
Even after you've deployed your stream,
if you can collect this kind

00:32:51.020 --> 00:32:54.540
of information from your users,
it can give you a really good

00:32:54.540 --> 00:32:58.100
insight as to whether you've made
a good choice when you've selected

00:32:58.100 --> 00:33:00.100
your different encoding bit rates.

00:33:00.100 --> 00:33:02.850
You can kind of find out how many
of your users are hanging out on

00:33:02.850 --> 00:33:04.100
the high bit rate streams or not.

00:33:04.100 --> 00:33:05.280
You can find out how many of
your users are hanging out

00:33:05.310 --> 00:33:06.100
on the low bit rate streams,
versus the low bit rate streams, etc.

00:33:06.100 --> 00:33:08.080
Maybe you need to add a few
more in there at some point.

00:33:08.360 --> 00:33:12.100
So, statistics are really useful.

00:33:12.100 --> 00:33:13.930
I'd recommend that you
kind of get to know them.

00:33:14.100 --> 00:33:17.830
And that is it for features this year.

00:33:18.110 --> 00:33:22.730
So, we've got a couple little ones.

00:33:22.980 --> 00:33:26.740
What I'd like to do now is spend some
time talking about best practices.

00:33:26.740 --> 00:33:32.500
And these are essentially areas where
when we've worked with you folks,

00:33:32.500 --> 00:33:35.450
we've seen you run into
some issues and problems.

00:33:35.460 --> 00:33:38.220
Maybe you need to make
slightly different choices.

00:33:38.220 --> 00:33:39.360
And so let's talk about that.

00:33:39.420 --> 00:33:41.540
The first thing I'd like to
talk about is the tricky,

00:33:41.570 --> 00:33:43.650
tricky area of delivering
encrypted content.

00:33:43.660 --> 00:33:48.060
So you encrypt your content in
order to control access to it.

00:33:48.060 --> 00:33:52.860
And that starts with encrypting each
of the media segments in AES-128.

00:33:52.860 --> 00:33:56.110
And once you've done that,
we recommend that you distribute the

00:33:56.120 --> 00:33:58.640
media itself over plain vanilla HTTP.

00:33:58.640 --> 00:34:02.980
It's fast, it's cheap,
it's just as safe as anything else,

00:34:03.110 --> 00:34:05.480
so long as you control
access to the keys.

00:34:05.480 --> 00:34:08.880
And that is really the
thing you wanna focus on,

00:34:08.880 --> 00:34:11.630
is protecting the access to the keys.

00:34:11.880 --> 00:34:19.380
So recall that the keys themselves
are specified as URLs in the key tag.

00:34:19.380 --> 00:34:23.310
And so when the player needs
a key in order to encrypt the

00:34:23.410 --> 00:34:26.100
media file they'd like to play,
it's going to try to load

00:34:26.190 --> 00:34:27.640
the contents of that URL.

00:34:27.680 --> 00:34:32.100
There are a few different approaches to
this that can help keep the key secure.

00:34:32.110 --> 00:34:34.160
And I'm gonna talk
about a couple of them.

00:34:34.290 --> 00:34:38.810
The first and perhaps the most
obvious is that you can deliver the

00:34:38.810 --> 00:34:42.320
keys over the network using HTTPS.

00:34:42.340 --> 00:34:47.390
And HTTPS is a good start because
it means that no one sort of in the

00:34:47.400 --> 00:34:51.180
middle can snoop your packets and
discover the content of the keys.

00:34:51.200 --> 00:34:52.780
It's not enough, however.

00:34:52.890 --> 00:34:55.780
Because you also have to protect
against someone using someone else

00:34:55.910 --> 00:34:59.820
using our APIs to get your keys,
someone who's gonna make requests,

00:34:59.860 --> 00:35:02.540
who's gonna have our player
make requests on their behalf.

00:35:02.760 --> 00:35:06.730
So it's also necessary
that prior to playback,

00:35:06.780 --> 00:35:11.370
that you authenticate yourself
with your HTTPS server.

00:35:11.570 --> 00:35:14.390
So there are a couple of approaches here.

00:35:14.400 --> 00:35:18.780
One is that prior to playback,
you can connect to your HTTPS server

00:35:18.780 --> 00:35:21.330
yourself in your application,
and you can perform whatever

00:35:21.330 --> 00:35:24.700
authentication you feel is kind
of interesting or necessary to

00:35:24.760 --> 00:35:28.100
get your server to trust the fact
that it's you on the other end.

00:35:28.110 --> 00:35:33.020
Once it's done that,
your server can issue a cookie

00:35:33.110 --> 00:35:36.550
that will expire soon after
that session is complete,

00:35:36.550 --> 00:35:39.300
and a cookie that is unique per session.

00:35:39.300 --> 00:35:43.370
What the server can then do is trust
that anyone in possession of that session

00:35:43.370 --> 00:35:45.600
cookie is authorized to have the key.

00:35:45.650 --> 00:35:49.770
Now, when the cookie is sent back,
our web subsystem will cache

00:35:49.770 --> 00:35:53.490
that cookie so that when the
player has to go ask me for keys,

00:35:53.500 --> 00:35:59.170
the cookie request will appear to the
HTTPS server and it should hand it over.

00:35:59.490 --> 00:36:03.100
We actually, when we see a playlist,
we sort of aggressively try to

00:36:03.100 --> 00:36:06.590
download all the keys we can find
in it in a short period of time.

00:36:06.600 --> 00:36:10.290
And so you can actually have your
session cookie expire relatively

00:36:10.290 --> 00:36:12.400
rapidly and things will still work.

00:36:12.480 --> 00:36:17.850
A similar approach you can take is that
you can use the realms feature of HTTP.

00:36:17.920 --> 00:36:23.270
And this is, what this is, is realms,
if you try to download a resource from

00:36:23.390 --> 00:36:29.000
an HTTP server in a particular location,
then it's going to challenge you.

00:36:29.160 --> 00:36:31.170
It's going to ask you for some
credentials in order to prove

00:36:31.170 --> 00:36:32.130
that you are who you are.

00:36:32.170 --> 00:36:35.690
And to get this to work, of course,
the trick is that you have to get

00:36:35.760 --> 00:36:37.600
the credentials to our player.

00:36:37.620 --> 00:36:41.100
So there's a simple way to do that.

00:36:41.220 --> 00:36:45.230
And that is, again, prior playback,
use NSURL connection to try to download

00:36:45.230 --> 00:36:47.390
something out of the realm yourself.

00:36:47.650 --> 00:36:51.140
And that will cause kind of a
challenge response action to

00:36:51.240 --> 00:36:53.500
occur with your NSURL delegate.

00:36:53.500 --> 00:36:58.800
And so once the authentication
happens successfully,

00:36:58.920 --> 00:37:03.720
again, our web subsystem will cache the
credential so that our player can reuse

00:37:03.720 --> 00:37:05.060
it when we need to obtain the keys.

00:37:07.220 --> 00:37:09.430
So that's a pretty safe
way to deliver keys.

00:37:09.430 --> 00:37:13.310
It does require a certain amount of
server infrastructure to be built.

00:37:13.360 --> 00:37:18.390
And so if that's intimidating or if
you already have a very similar but not

00:37:18.390 --> 00:37:23.460
quite the same server infrastructure,
there's another approach.

00:37:24.020 --> 00:37:27.720
And that is that your application
can actually provide the keys to

00:37:27.720 --> 00:37:29.560
us directly when we need them.

00:37:29.610 --> 00:37:32.630
And there may be a bit of, you know,
and the way you do this is

00:37:32.630 --> 00:37:34.680
using application-defined URLs.

00:37:34.680 --> 00:37:37.940
And there may be a bit of a,
sort of amongst some people,

00:37:38.110 --> 00:37:41.720
it's kind of a Scooby-Doo moment,
application-defined URLs,

00:37:41.850 --> 00:37:43.090
what's up with that?

00:37:43.150 --> 00:37:45.150
So let me talk about that for a moment.

00:37:46.960 --> 00:37:49.540
The way application-defined URLs work is,
first of all,

00:37:49.540 --> 00:37:53.880
you decide that in your world,
URLs should be, for instance,

00:37:53.880 --> 00:37:55.980
ABCD colon blah, blah, blah, blah, blah,
blah, blah.

00:37:55.980 --> 00:37:57.390
Fantastic.

00:37:57.400 --> 00:37:57.770
Well done.

00:37:57.800 --> 00:38:01.140
But where they really get
interesting is where you actually

00:38:01.140 --> 00:38:02.740
let the system in on this.

00:38:02.740 --> 00:38:06.180
And the way you do that is by
subclassing the NSURL protocol

00:38:06.180 --> 00:38:09.760
class and by registering your
subclass with the system.

00:38:09.880 --> 00:38:13.360
What you're doing when you do
this is essentially you're telling

00:38:13.610 --> 00:38:17.070
the system that you're signing up
to handle loading all ABCD colon

00:38:17.070 --> 00:38:19.260
slash slash URLs that come its way.

00:38:19.280 --> 00:38:23.930
So once you do that,
the next step is to describe your keys

00:38:24.120 --> 00:38:30.140
in the HTTP Live Streaming playlist
file as ABCD colon slash slash URLs.

00:38:30.140 --> 00:38:32.770
And so now when the player
needs to load the keys,

00:38:32.770 --> 00:38:35.860
it's going to call back into
your application and say,

00:38:35.860 --> 00:38:38.530
I need ABCD colon slash slash
key number one or whatever.

00:38:38.590 --> 00:38:39.850
However you define whatever.

00:38:39.880 --> 00:38:42.980
And at that point,
your application can either hand over

00:38:42.980 --> 00:38:48.360
the key data directly or if it wishes,
it can make up an actual HTTP URL on

00:38:48.440 --> 00:38:52.330
the spot and hand that to us
and we will redirect the request

00:38:52.430 --> 00:38:53.690
and go fetch it off the web.

00:38:53.860 --> 00:38:57.560
So since we're talking about keys,
it's important to note that

00:38:57.560 --> 00:39:01.350
when you implement and register
an NSURL protocol subclass,

00:39:01.350 --> 00:39:03.810
it is private to your application.

00:39:03.820 --> 00:39:07.780
Your competitor application
cannot simply load an ABCD URL and

00:39:07.780 --> 00:39:09.820
get your keys and get access.

00:39:09.820 --> 00:39:10.660
It's your content.

00:39:10.660 --> 00:39:15.420
And so this means that NSURL protocol
is a really secure and efficient way to

00:39:15.510 --> 00:39:18.280
deliver the keys to us when we need them.

00:39:19.660 --> 00:39:21.900
Now you may wonder, "Hmm,
this sounds pretty cool.

00:39:21.900 --> 00:39:25.920
Is there anything else I can use
these application URLs for?" Well,

00:39:25.920 --> 00:39:26.640
you can actually.

00:39:26.640 --> 00:39:30.660
You can use them for playlist files,
and I'm going to get to that in a second.

00:39:30.810 --> 00:39:33.820
One thing you can't do, however,
is you can't use them for media files.

00:39:33.900 --> 00:39:40.350
We do require that the player load
the media files themselves directly,

00:39:40.350 --> 00:39:43.320
and the reason for this is that
this is the information we use to

00:39:43.320 --> 00:39:46.480
understand the quality of the network,
and it allows us to make the

00:39:46.480 --> 00:39:49.370
right decisions in terms of
which bitrate we'd like to play.

00:39:49.490 --> 00:39:56.880
And so media files must
always be HTTP or HTTPS URLs.

00:39:57.170 --> 00:39:59.970
The keys and playlists on the other hand
are really short and so it's fine to

00:40:00.000 --> 00:40:02.900
use application defined URLs for those.

00:40:02.920 --> 00:40:08.640
And in fact if you do or if you use the
HTTPS methods that I described earlier,

00:40:08.640 --> 00:40:13.100
there's a nice bonus waiting for
you in iOS 5 and that is AirPlay.

00:40:13.100 --> 00:40:15.140
When we rolled out AirPlay,
we didn't have any support

00:40:15.140 --> 00:40:16.490
for encrypted video streams.

00:40:16.530 --> 00:40:18.500
In iOS 5, we do.

00:40:18.500 --> 00:40:21.200
And this is an example
of one of those things,

00:40:21.210 --> 00:40:24.690
one of those new features in OS that
should just work if you followed our

00:40:24.690 --> 00:40:26.820
recommended practices for doing stuff.

00:40:28.420 --> 00:40:34.120
Now, the flip side of this is that when
you build your application for iOS 5,

00:40:34.120 --> 00:40:37.140
it actually gets opted
into AirPlay by default.

00:40:37.290 --> 00:40:38.940
And so if you wish,
the flip side of this is it'll

00:40:38.940 --> 00:40:41.500
just work if your application
is followed the best practices.

00:40:41.500 --> 00:40:44.900
And this is good news for most people,
I would say.

00:40:44.900 --> 00:40:47.230
For some people,
it's actually not so great news

00:40:47.230 --> 00:40:50.110
because for reasons normally
contractual or what have you,

00:40:50.170 --> 00:40:53.360
you don't want your content
playing on some big TV somewhere.

00:40:53.820 --> 00:40:57.060
And so if you're in that boat,
then there is an entire section of

00:40:57.180 --> 00:41:01.280
the AirPlay overview document waiting
for you that discusses how to opt out.

00:41:01.280 --> 00:41:03.590
And I believe that's
up on our website now.

00:41:03.590 --> 00:41:05.340
It's called AirPlay Overview.

00:41:05.340 --> 00:41:07.330
So download it and check it out.

00:41:09.270 --> 00:41:11.780
The next thing I'd like to talk
about is ad-supported playback

00:41:11.780 --> 00:41:14.990
and specifically what works well,
what doesn't work so well.

00:41:15.450 --> 00:41:20.610
There's a technique that we've seen some
folks try to use called chaining players.

00:41:20.640 --> 00:41:24.870
And this is kind of a clever technique
where when you want to display sort of

00:41:24.870 --> 00:41:28.580
an ad at the beginning of your content
or maybe an ad in the middle somewhere,

00:41:28.580 --> 00:41:30.320
you actually create two players.

00:41:30.340 --> 00:41:31.900
And one player is
responsible for playing,

00:41:32.010 --> 00:41:34.300
let's say, your television show,
and one player is responsible

00:41:34.300 --> 00:41:35.130
for playing the ads.

00:41:35.770 --> 00:41:37.800
And what you try to do is
juggle these two things.

00:41:37.800 --> 00:41:40.510
And so you're playing your TV show along,
and then you say it

00:41:40.510 --> 00:41:41.740
comes time to run an ad.

00:41:41.740 --> 00:41:43.460
And so you kind of hide
the TV show player,

00:41:43.540 --> 00:41:45.830
and you show the ad player,
and you play your ad.

00:41:45.840 --> 00:41:49.880
The problem with this technique is that
there are several different reasons why

00:41:49.880 --> 00:41:52.070
it's poorly suited to network players.

00:41:52.100 --> 00:41:56.350
One of them is that network
playback essentially has a buffering

00:41:56.590 --> 00:42:00.280
stage where prior to playback,
we've got to download stuff as

00:42:00.280 --> 00:42:01.900
fast as we can from the network.

00:42:01.900 --> 00:42:05.080
So we have a buffer that allows
us to play through uninterrupted.

00:42:05.660 --> 00:42:08.750
When you have independent players,
they're actually competing for bandwidth.

00:42:08.760 --> 00:42:12.380
And due to the way TCP works,
how the competition is going to turn

00:42:12.420 --> 00:42:14.970
out is actually pretty unpredictable.

00:42:14.980 --> 00:42:18.210
And so, for instance,
you might have a case where your

00:42:18.210 --> 00:42:22.140
user is watching just the last little
bit of a TV show prior to an ad,

00:42:22.140 --> 00:42:24.790
and you decide you want
to queue up the ad.

00:42:24.860 --> 00:42:28.530
It's possible that pre-buffering that
ad will actually starve the player,

00:42:28.530 --> 00:42:31.740
and you could actually stop
playback before you got to the ad.

00:42:31.760 --> 00:42:35.280
You might decide alternately that, okay,
I'm not going to do that.

00:42:35.380 --> 00:42:38.700
I'm going to just wait
until the TV show stops,

00:42:38.700 --> 00:42:40.930
and then I'll queue up the ad.

00:42:40.980 --> 00:42:43.970
Well, the experience then is
I'm watching my TV show,

00:42:43.970 --> 00:42:46.420
and suddenly it cuts
to a commercial break,

00:42:46.470 --> 00:42:48.960
and I'm sitting there watching
a little spinning thing.

00:42:48.960 --> 00:42:50.920
And there's nothing as a user
I like better than watching a

00:42:50.980 --> 00:42:53.200
little spinning thing so that
I can watch an advertisement.

00:42:53.240 --> 00:42:54.270
It's fantastic.

00:42:54.330 --> 00:42:58.110
And another problem that is
specific to adaptive streaming

00:42:58.110 --> 00:43:02.840
is when a player is active,
it's constantly monitoring the network

00:43:02.950 --> 00:43:05.270
and selecting the best bit rate.

00:43:05.320 --> 00:43:07.000
For the current connection speed.

00:43:07.000 --> 00:43:08.770
When a player is inactive, it's not.

00:43:08.830 --> 00:43:12.330
And that means when you stop playing one
player and you start playing another,

00:43:12.380 --> 00:43:14.930
the new player is not going to
have a good sense of what the

00:43:14.930 --> 00:43:16.650
correct bit rate is going to be.

00:43:16.660 --> 00:43:20.620
So an example of how this can
manifest is you might start playing

00:43:20.620 --> 00:43:22.800
your TV show with a commercial.

00:43:22.800 --> 00:43:26.390
And so it starts with the ad,
and in a few seconds it switches up,

00:43:26.390 --> 00:43:30.760
and suddenly you've got fantastic
quality in your Colgate commercial.

00:43:30.760 --> 00:43:31.680
It's like, ding!

00:43:31.680 --> 00:43:32.320
Kind of thing.

00:43:32.460 --> 00:43:34.600
And so then the commercial ends.

00:43:34.980 --> 00:43:36.640
And the show, which is what the user
actually wants to see,

00:43:36.640 --> 00:43:37.010
starts.

00:43:37.070 --> 00:43:42.300
And suddenly we're back to Captain Blocky
because we're starting at a low bit rate.

00:43:42.510 --> 00:43:44.980
And finally,
when you're trying to separate your ad

00:43:45.090 --> 00:43:48.510
playback from your main content playback,
you end up with all these

00:43:48.590 --> 00:43:50.900
different little islands
of sort of program content,

00:43:50.900 --> 00:43:52.760
ad content, program ad content, etc.

00:43:52.760 --> 00:43:56.420
And what that does is it makes it very
difficult to implement seeking because

00:43:56.420 --> 00:44:00.200
now you're seeking across all these
different little islands of content.

00:44:00.200 --> 00:44:04.120
And it's very difficult to implement
something like fast forward rewind.

00:44:04.900 --> 00:44:10.640
So chaining players is not going
to work well for ad playback.

00:44:10.640 --> 00:44:12.300
So what do you do instead?

00:44:12.300 --> 00:44:15.820
Well, we actually have a technique
that works really well.

00:44:15.840 --> 00:44:19.170
And that is to use a single playlist
and put all your program and all

00:44:19.170 --> 00:44:21.090
your ads in that single playlist.

00:44:21.130 --> 00:44:24.510
And if you've used some of the
popular TV applications on the iPad,

00:44:24.510 --> 00:44:27.360
you've actually seen this
technique in practice.

00:44:27.360 --> 00:44:30.580
The way it works is you
have a single playlist.

00:44:30.600 --> 00:44:32.740
You put all your ad content in.

00:44:32.740 --> 00:44:34.500
You put all your program content in.

00:44:34.910 --> 00:44:38.760
You separate the ad content from your
program content with discontinuity

00:44:38.760 --> 00:44:40.730
tags in between the different ads.

00:44:40.820 --> 00:44:43.140
You use floating point X-inf durations.

00:44:43.140 --> 00:44:46.840
And this is very important because it
allows us to be accurate when the user

00:44:46.950 --> 00:44:48.920
seeks to somewhere else in the stream.

00:44:48.920 --> 00:44:51.810
And a lot of people use the
position in the stream to know

00:44:51.810 --> 00:44:53.800
when they're playing ad content.

00:44:53.800 --> 00:44:56.310
And so because they want to
control the transport bar,

00:44:56.400 --> 00:44:59.580
they want to disable seeking or
something while an ad is playing.

00:44:59.580 --> 00:45:04.350
And so it's very important that the
playback time report is accurate.

00:45:05.850 --> 00:45:08.280
Once you've got your floating
point exit durations,

00:45:08.280 --> 00:45:12.360
the next thing you can do is use the
boundary time observer of AVPlayer.

00:45:12.370 --> 00:45:16.090
And what this will do is call it
back into your application when we

00:45:16.200 --> 00:45:18.070
cross a particular boundary time,
i.e.

00:45:18.100 --> 00:45:22.300
when you've crossed from the main program
content into an ad content or vice versa.

00:45:22.300 --> 00:45:25.570
And so this allows you to
control your transport bar.

00:45:26.220 --> 00:45:32.120
Now, it's actually a fairly common
request that ads not be kind

00:45:32.120 --> 00:45:35.780
of burned in for all time,
but that they be rotated based

00:45:36.100 --> 00:45:37.940
on time of day or other factors.

00:45:37.960 --> 00:45:40.680
And so even though you may go
back and watch the same episode,

00:45:40.680 --> 00:45:42.000
you may get different ads.

00:45:42.080 --> 00:45:45.560
And fortunately,
the M3 playlist file is so simple

00:45:45.560 --> 00:45:50.040
that it's really easy to take
multiple fragments of playlist files

00:45:50.040 --> 00:45:53.280
and kind of stitch them together and
get a single usable playlist file.

00:45:53.280 --> 00:45:56.620
So all you really need to
do is break up your program,

00:45:56.620 --> 00:46:00.660
your television show, for instance,
into the little islands

00:46:00.660 --> 00:46:03.070
that are between the ads,
and then dynamically

00:46:03.330 --> 00:46:05.510
choose the ads you want,
pull in those media segments,

00:46:05.510 --> 00:46:06.760
and stitch them together.

00:46:06.760 --> 00:46:09.680
There are a couple of different
places you can do this.

00:46:09.700 --> 00:46:12.300
One place, obviously,
is you can do it on-demand on the server.

00:46:12.300 --> 00:46:15.730
When a client says, hey, I'd like to play
House MD episode 128 or whatever,

00:46:15.820 --> 00:46:18.400
it can say, well, okay,
it's about 9 p.m., so I think

00:46:18.400 --> 00:46:21.280
I'll put in a Budweiser ad or
however they decide these things.

00:46:23.280 --> 00:46:24.760
And that works pretty well.

00:46:24.760 --> 00:46:27.940
It does require a certain amount
of state to be kept on the server.

00:46:27.940 --> 00:46:31.190
But for one reason or another,
it's also fairly popular to

00:46:31.270 --> 00:46:34.530
want to be able to choose the
ads that are played back in the

00:46:34.530 --> 00:46:37.040
application itself at playback time.

00:46:38.500 --> 00:46:41.540
Fortunately,
you do have a way to do that,

00:46:41.540 --> 00:46:44.160
and that's using
application-defined URLs.

00:46:44.160 --> 00:46:45.800
I discussed them earlier.

00:46:45.850 --> 00:46:49.210
The way it works is when you
ask us to play back a URL,

00:46:49.220 --> 00:46:52.280
you give us back an ABCD or
what have you URL instead.

00:46:52.280 --> 00:46:55.470
And so when we need to load the
playlist file or the master variant or

00:46:55.510 --> 00:46:58.340
the individual variant playlist file,
we'll go and we'll ask

00:46:58.490 --> 00:46:59.500
your application instead.

00:46:59.500 --> 00:47:02.110
And at that point,
your application can go off

00:47:02.360 --> 00:47:03.460
and look at things like,
well,

00:47:03.500 --> 00:47:05.420
has the user seen this particular ad?

00:47:05.420 --> 00:47:09.800
Or maybe they've told me where your
location is and I wanna put up a

00:47:09.800 --> 00:47:13.040
locale-specific ad or market-specific
ad or something like that.

00:47:13.170 --> 00:47:19.040
But using application-defined URLs gives
you an opportunity to do this.

00:47:19.040 --> 00:47:23.810
And if you set everything up this way,
then you'll get a single buffering stage.

00:47:23.830 --> 00:47:28.240
You will rapidly hit the
optimal playback bit rate.

00:47:28.260 --> 00:47:29.950
Fast forward rewind will work great.

00:47:29.970 --> 00:47:31.360
Seeking will work great.

00:47:31.360 --> 00:47:33.020
It's a much better experience.

00:47:33.030 --> 00:47:35.360
So if you're trying to do ad-based
playback or anything like it,

00:47:35.470 --> 00:47:37.170
this is really the
technique we recommend.

00:47:37.180 --> 00:47:43.740
Next, I'd like to talk about a
quick performance note.

00:47:44.650 --> 00:47:49.260
Pretty much all modern web servers
have the ability on a per-mime

00:47:49.370 --> 00:47:53.610
type basis to compress a resource
that's being asked for with gzip.

00:47:53.640 --> 00:47:58.870
And so if someone asks for a
particular file and they ask for it

00:47:58.930 --> 00:48:03.340
and they say it's okay to gzip it,
the server will do this on-demand.

00:48:03.340 --> 00:48:05.900
If you haven't got your web
server set up to do this,

00:48:05.900 --> 00:48:07.520
we really recommend you do.

00:48:07.520 --> 00:48:10.560
Because, again, the playlist,
it's just a text file.

00:48:10.560 --> 00:48:11.360
It's really simple.

00:48:11.360 --> 00:48:13.020
It compresses fantastically.

00:48:13.360 --> 00:48:15.160
10x compression is actually typical.

00:48:15.160 --> 00:48:16.580
It's simple to do.

00:48:16.580 --> 00:48:19.100
I've got the
Apache configuration right here.

00:48:19.100 --> 00:48:21.540
You can just slam this into
your httpd.conf file or whatever

00:48:21.550 --> 00:48:22.700
they call it these days.

00:48:22.700 --> 00:48:29.060
And that will tell it any time you hand
out an M3U8 file with this mime type,

00:48:29.120 --> 00:48:33.720
if the client asks for it, and we will,
then simply compress it on the fly.

00:48:33.740 --> 00:48:37.090
Now, it's not required.

00:48:37.180 --> 00:48:38.250
It's optional.

00:48:38.280 --> 00:48:43.280
But if you're playing content over
3G or you're playing live event.

00:48:43.430 --> 00:48:47.180
Content where you're continuously
reloading these large playlist files,

00:48:47.180 --> 00:48:50.740
then downloading playlist file
10 times faster can actually make

00:48:50.740 --> 00:48:54.660
a perceptible difference in the
responsiveness of the user experience.

00:48:54.850 --> 00:48:56.770
And so it's easy to do.

00:48:56.850 --> 00:48:57.840
It's cheap.

00:48:58.140 --> 00:49:01.000
Most of the major CDNs support it.

00:49:01.100 --> 00:49:03.050
And so ask them for it.

00:49:05.570 --> 00:49:08.940
Speaking of optional things
that can make a difference,

00:49:08.940 --> 00:49:11.510
there are a number of things you
can do with your playlist file that

00:49:11.510 --> 00:49:14.670
give us additional information about
what's going on in your content.

00:49:14.680 --> 00:49:19.200
And one of these is the codex
attribute of the stream info tag.

00:49:19.280 --> 00:49:22.100
What the codex attribute does is
it provides a complete list of

00:49:22.130 --> 00:49:25.300
all the codex that are necessary
to decode a particular stream.

00:49:25.300 --> 00:49:29.500
So in this case,
AVC is H.264 MP4A.40.blah, blah, blah,

00:49:29.600 --> 00:49:30.160
is AAC.

00:49:30.160 --> 00:49:33.800
And so looking at that, we know that, oh,
I need an H.264 codec and AAC.

00:49:33.800 --> 00:49:34.060
Great.

00:49:35.080 --> 00:49:38.500
What it also allows us to do, however,
is it allows us to distinguish

00:49:38.500 --> 00:49:41.830
between the variants you have
that are audio only and those

00:49:41.830 --> 00:49:43.460
that have audio and video in them.

00:49:43.500 --> 00:49:46.150
And there are certain times
when we can make use of this

00:49:46.230 --> 00:49:49.990
information and provide a better
user experience when we're switching.

00:49:50.000 --> 00:49:52.840
A similar attribute is
the resolution attribute.

00:49:52.840 --> 00:49:55.020
The resolution attribute is
another stream info attribute.

00:49:55.020 --> 00:49:58.890
And what it does is it provides
the approximate horizontal vertical

00:49:58.900 --> 00:50:01.220
dimensions of the video in a stream.

00:50:02.720 --> 00:50:05.510
Again, it's optional,
but if you do provide it,

00:50:05.510 --> 00:50:08.520
then it can prevent us from
making some boneheaded mistakes,

00:50:08.540 --> 00:50:11.810
like deciding that we're gonna
start downloading your 1080p video

00:50:11.810 --> 00:50:15.370
stream and playing it into a little
web window that looks like this,

00:50:15.440 --> 00:50:17.940
just because we happen to
have the network for it.

00:50:17.970 --> 00:50:21.150
So you guys pay for the bandwidth and
the user gets no additional benefit

00:50:21.160 --> 00:50:23.680
because we're downscaling it to 320,
240 anyway.

00:50:23.700 --> 00:50:28.780
We can do that,
but we can only do that if you tell

00:50:28.780 --> 00:50:29.960
us what the resolution is in advance.

00:50:30.750 --> 00:50:32.950
I've already mentioned
floating point durations.

00:50:33.040 --> 00:50:36.260
It's really important to use floating
point durations so that we know

00:50:36.260 --> 00:50:41.130
where we are on an accurate basis
when you seek around in the stream.

00:50:41.370 --> 00:50:46.490
And finally, we ship a tool called the
MediaStream Validator.

00:50:46.490 --> 00:50:48.860
And this is a tool you
point at your stream,

00:50:48.860 --> 00:50:50.730
it'll download the stream,
it'll check it for

00:50:50.730 --> 00:50:53.940
syntactical correctness,
it'll check for some best practice stuff,

00:50:53.940 --> 00:50:55.480
some self-consistency things.

00:50:55.480 --> 00:50:59.410
It produces a lot of output,
and some of it's a little hard to read.

00:50:59.410 --> 00:51:01.450
It produces some warnings,
it produces some errors.

00:51:01.450 --> 00:51:05.890
I encourage you to become familiar with
the output of MediaStream Validator,

00:51:05.890 --> 00:51:11.180
even the warnings, because they often can
point out subtle errors.

00:51:11.200 --> 00:51:14.440
In your streams,
errors that may not appear

00:51:14.440 --> 00:51:17.640
to you automatically,
when you're doing your testing,

00:51:17.650 --> 00:51:19.960
but may show up for some
percentage of your users,

00:51:19.980 --> 00:51:23.370
or they may cause your streams
to stop playing when we do a

00:51:23.370 --> 00:51:26.520
subsequent update and we tweak
how the player works a little bit.

00:51:26.630 --> 00:51:29.620
So get to know the
MediaStream Validator output,

00:51:29.620 --> 00:51:30.440
pay attention to it.

00:51:30.610 --> 00:51:32.260
You don't necessarily
have to react to it,

00:51:32.260 --> 00:51:34.850
but you should understand what
it's saying and you should say,

00:51:34.850 --> 00:51:37.000
yeah, okay, I know about that,
that's okay.

00:51:38.230 --> 00:51:41.180
Next, I'd like to talk about TLS.

00:51:41.180 --> 00:51:43.580
What's TLS?

00:51:43.580 --> 00:51:48.910
TLS is basically SSL, secure SOC Slayer,
after the IETF got through with it.

00:51:48.910 --> 00:51:50.870
It's the official IETF version of SSL.

00:51:50.900 --> 00:51:55.190
The news in iOS 5 is that we
have upgraded from TLS 1.0,

00:51:55.270 --> 00:51:59.310
which was used in previous releases,
to TLS 1.2.

00:51:59.310 --> 00:52:02.830
And along with this upgrade,
a number of new cipher suites

00:52:02.850 --> 00:52:06.580
are presented when we issue
the SSL client hello message.

00:52:07.530 --> 00:52:09.990
So, TLS 1.2 is a good thing.

00:52:09.990 --> 00:52:16.000
It fixes a couple of pretty significant
security holes that are present in 1.0.

00:52:16.010 --> 00:52:17.600
It's generally more stable.

00:52:17.600 --> 00:52:21.250
However, in doing testing,
we have discovered a

00:52:21.610 --> 00:52:25.390
number of 30-party apps,
not a lot, but a good few,

00:52:25.410 --> 00:52:29.630
that are incompatible
with TLS 1.2 on iOS 5.

00:52:29.640 --> 00:52:32.610
Now, we've looked into this,
and sometimes we'll find that it's

00:52:32.680 --> 00:52:34.660
actually a bug in our TLS implementation.

00:52:34.690 --> 00:52:35.620
We can fix that.

00:52:36.770 --> 00:52:38.930
But, most of the time,
it appears to be sometimes

00:52:38.930 --> 00:52:40.250
a bug in the application.

00:52:40.340 --> 00:52:42.900
More often,
it's a bug in the HTTPS server

00:52:42.900 --> 00:52:45.310
that the application is talking to.

00:52:45.420 --> 00:52:49.120
So, if your application uses HTTPS,
if it uses SSL,

00:52:49.190 --> 00:52:54.510
I highly encourage you to install the
iOS 5 seed you received this week.

00:52:54.620 --> 00:52:56.160
Try out your application.

00:52:56.210 --> 00:52:59.040
If your application has
problems connecting,

00:52:59.150 --> 00:53:03.210
check your servers,
make sure they're TLS 1.2 compatible.

00:53:03.200 --> 00:54:39.100
[Transcript missing]

00:54:39.680 --> 00:54:41.900
So those are kind of the trade-offs
you need to consider when you're

00:54:41.900 --> 00:54:42.920
selecting your target duration.

00:54:42.920 --> 00:54:44.460
10 seconds is a pretty good default.

00:54:44.460 --> 00:54:46.220
It works well for a
lot of different cases.

00:54:46.220 --> 00:54:51.710
Another point I'd like to make, however,
is that if your stream is

00:54:51.720 --> 00:54:55.060
not starting up quickly,
it's not because you've picked a

00:54:55.060 --> 00:54:57.380
target duration that's too large.

00:54:57.380 --> 00:55:02.070
If your stream's not starting up quickly,
it's because the bitrate of the

00:55:02.070 --> 00:55:06.530
stream combined with the speed of the
network requires us to spend longer

00:55:06.850 --> 00:55:08.930
buffering before we can start up.

00:55:09.050 --> 00:55:12.330
Working around target duration is not
going to help you start up faster.

00:55:12.340 --> 00:55:17.650
If you're having startup problems,
then the recommendation is to add or

00:55:17.940 --> 00:55:23.130
to have a lower bitrate stream and
use that as the initial variant in the

00:55:23.140 --> 00:55:27.350
playlist file so that on a slow network,
we can start quickly

00:55:27.470 --> 00:55:30.290
at the lower quality,
and on a fast network,

00:55:30.350 --> 00:55:33.000
we'll start very quickly at the
low quality and then quickly switch

00:55:33.000 --> 00:55:34.210
up to the appropriate quality.

00:55:36.110 --> 00:55:38.840
Finally,
I'd like to spend a little bit of time

00:55:38.840 --> 00:55:44.120
addressing the folks who are actually
writing their own transport streams.

00:55:44.160 --> 00:55:48.930
Not everyone does this, but when you do,
it's really important to get it right.

00:55:49.080 --> 00:55:50.000
So a couple of points.

00:55:50.000 --> 00:55:55.440
When we create these media segment files,
they're really designed

00:55:55.440 --> 00:55:58.580
to be continuations of the
previous media segment file.

00:55:58.580 --> 00:56:02.560
You should be able to catenate all the
media segment files together and play

00:56:02.590 --> 00:56:04.700
the stream in an uninterrupted way.

00:56:05.570 --> 00:56:08.630
When we load the first bytes
of the second segment file,

00:56:08.650 --> 00:56:11.530
we expect to carry on right
where we left off with the last

00:56:11.640 --> 00:56:13.880
bytes of the first segment file,
from the point of view of parsing,

00:56:13.880 --> 00:56:14.990
from the point of view of encoding.

00:56:15.000 --> 00:56:17.960
This means the format has to be the same.

00:56:17.960 --> 00:56:19.950
The track count can't change.

00:56:19.960 --> 00:56:23.650
The transport stream continuity
counter has to continue uninterrupted.

00:56:23.760 --> 00:56:25.170
We have to be where we
were in GOP structure,

00:56:25.170 --> 00:56:26.500
et cetera, et cetera, et cetera.

00:56:26.500 --> 00:56:27.380
Everything must be continuous.

00:56:27.450 --> 00:56:31.070
The only exception to this
is if the media segment

00:56:31.250 --> 00:56:34.710
follows a discontinuity tag,
and if it does,

00:56:34.880 --> 00:56:37.730
we'll throw everything away,
and we'll start from scratch,

00:56:37.780 --> 00:56:41.140
and we'll start displaying at the next
IDR frame we find in the segment file.

00:56:41.180 --> 00:56:45.170
So segment files,
even though they're independent files,

00:56:45.170 --> 00:56:46.450
need to be continuous encodings.

00:56:46.580 --> 00:56:47.770
Second,

00:56:49.450 --> 00:56:51.550
MPEG-2 transport streams
have these structures called

00:56:51.560 --> 00:56:53.680
the Program Access Table and
the Program Map Table.

00:56:53.680 --> 00:56:58.380
We don't impose a buffering model on you,
but we do require that you have

00:56:58.380 --> 00:57:01.230
at least one of these at the
beginning of every segment.

00:57:01.240 --> 00:57:04.870
And third,
there are some formats out there that

00:57:05.250 --> 00:57:07.930
have very coarse sample time scales.

00:57:07.940 --> 00:57:11.420
This means that when they put
the media into the format,

00:57:11.420 --> 00:57:15.380
they lost a lot of accuracy by rounding
everything to one millisecond timestamps.

00:57:15.380 --> 00:57:18.180
If you have to transcode,
if you have the unlucky job of

00:57:18.270 --> 00:57:21.130
transcoding back into MPEG-2 time scales,
you can't just multiply

00:57:21.250 --> 00:57:22.760
the timestamps by 90,000.

00:57:22.760 --> 00:57:24.820
You're just propagating
the accuracy loss.

00:57:24.820 --> 00:57:27.230
You need to look at, like,
the audio samples and

00:57:27.370 --> 00:57:29.700
look at the sample rate,
count up all the audio samples,

00:57:29.700 --> 00:57:33.240
and reinstate that accuracy.

00:57:33.240 --> 00:57:36.510
I'm sorry, it's a pain,
but if you don't do it, your streams,

00:57:36.610 --> 00:57:38.260
the samples won't add up,
they won't play right.

00:57:38.300 --> 00:57:41.290
So, have we dived in deep enough?

00:57:41.460 --> 00:57:42.190
I think so.

00:57:42.260 --> 00:57:42.990
Let's pull out.

00:57:44.390 --> 00:57:48.500
The thing you need to take away
is that we continue to add new

00:57:48.500 --> 00:57:52.610
features to HTTP live streaming
and to support new use cases.

00:57:53.300 --> 00:57:56.080
There are a bunch more related sessions
this week for folks doing media.

00:57:56.080 --> 00:57:58.220
A couple of them already happened.

00:57:58.220 --> 00:57:59.590
Check out the video replays.

00:57:59.590 --> 00:58:02.720
There are a couple more tomorrow,
mainly involving editing and

00:58:02.720 --> 00:58:04.200
capture in both Lion and iOS.

00:58:04.200 --> 00:58:05.170
Check those out.

00:58:05.500 --> 00:58:07.760
And so that's it for this week.

00:58:07.760 --> 00:58:10.240
Thank you for coming today.
WEBVTT

00:00:15.410 --> 00:00:17.240
Good morning everyone.

00:00:17.290 --> 00:00:20.280
Thank you for coming
out early on a Friday,

00:00:20.280 --> 00:00:23.400
especially after all the
partying and so on last night.

00:00:23.400 --> 00:00:25.100
I'm Jon Callas.

00:00:25.230 --> 00:00:30.130
I'm a security privateer in CoreOS and
I'm going to be talking about the next

00:00:30.170 --> 00:00:32.930
generation cryptographic services.

00:00:34.710 --> 00:00:38.500
What we're going to be talking about
is the exciting changes that we've

00:00:38.500 --> 00:00:40.450
made to our cryptographic architecture.

00:00:40.580 --> 00:00:44.510
This is the first time that
we have reworked cryptography

00:00:44.900 --> 00:00:47.450
in a decade on Mac OS.

00:00:47.470 --> 00:00:52.360
And the first time that we've
done a lot of work on iOS as well.

00:00:53.420 --> 00:00:56.370
We're going to be talking
about the changes that we've

00:00:56.530 --> 00:00:58.260
made to the existing APIs.

00:00:58.320 --> 00:01:02.920
We're going to be spending a lot of time
talking about our new transform API.

00:01:03.580 --> 00:01:07.210
We're going to talk about our
transform library and how to

00:01:07.210 --> 00:01:11.920
create your own custom transforms
to build on top of that yourself.

00:01:12.270 --> 00:01:16.710
So I want to get started off
right away talking about CDSA,

00:01:16.710 --> 00:01:19.810
which is the current
cryptographic system.

00:01:19.970 --> 00:01:24.380
It is the common data
security architecture.

00:01:24.470 --> 00:01:28.450
We are deprecating in Lion CDSA.

00:01:33.130 --> 00:01:35.200
There are a number of
reasons that we're doing it.

00:01:35.210 --> 00:01:36.950
It's an open group standard.

00:01:37.080 --> 00:01:40.030
It dates in its architecture
to the late 1990s.

00:01:40.120 --> 00:01:44.880
It appeared with Mac OS X and
was developed through the

00:01:44.880 --> 00:01:47.490
first couple of releases.

00:01:47.930 --> 00:01:51.640
Being what it is,
it comes from an era in which

00:01:51.800 --> 00:01:58.240
there was exportable crypto,
pluggable this, tunable that.

00:01:58.240 --> 00:02:01.280
It had lots of features
that nobody ever used.

00:02:01.280 --> 00:02:03.570
Also,
one of the reasons why it's good to have

00:02:03.570 --> 00:02:05.810
standards is that everybody uses them.

00:02:05.820 --> 00:02:08.840
And we were one of the very few
people who actually used CDSA.

00:02:08.840 --> 00:02:12.420
So that meant that we had to support
all of the baggage of a standard

00:02:12.420 --> 00:02:16.130
without having the advantage that
lots of people were using it.

00:02:17.800 --> 00:02:20.760
Also, it only ever appeared on Mac OS.

00:02:20.760 --> 00:02:22.510
It was not brought to iOS.

00:02:22.880 --> 00:02:26.770
And a lot of the reasons why
it wasn't brought to iOS were

00:02:26.770 --> 00:02:28.960
pretty much the same thing.

00:02:28.960 --> 00:02:29.910
It was big.

00:02:29.910 --> 00:02:31.780
It wasn't used very well.

00:02:31.920 --> 00:02:34.390
So we are deprecating it.

00:02:35.340 --> 00:02:38.440
Now, deprecated doesn't mean
that it's cancelled.

00:02:38.560 --> 00:02:39.800
It's still there.

00:02:39.920 --> 00:02:43.910
It'll still be around
for a release or so.

00:02:44.100 --> 00:02:46.140
Start migrating away from
it if you're using it.

00:02:46.230 --> 00:02:48.700
If you're doing any new projects,

00:02:48.810 --> 00:02:51.580
Take a serious look at
what we're doing now.

00:02:51.920 --> 00:02:56.300
There are also a few parts of
the security framework that had

00:02:56.520 --> 00:02:58.940
strict dependencies on CDSA.

00:02:58.940 --> 00:03:02.490
We have deprecated those APIs as well.

00:03:02.640 --> 00:03:05.140
If you get a deprecation warning on it,
go to the H file.

00:03:05.140 --> 00:03:09.980
We have put in the H files hints
on what you should be using.

00:03:09.980 --> 00:03:15.640
There will be a number of places as well
that merely recompiling will fix things

00:03:15.650 --> 00:03:20.650
for you because we changed the types
around and the new type and the new

00:03:20.860 --> 00:03:23.890
call itself will all match up correctly.

00:03:26.000 --> 00:03:32.060
When we set about working for a new API,
we sat down and we came

00:03:32.060 --> 00:03:33.310
up with requirements.

00:03:33.350 --> 00:03:34.770
What did we want it to be?

00:03:34.780 --> 00:03:39.980
Because we want to have a crypto API that
is designed for the decades ahead.

00:03:40.050 --> 00:03:45.840
We want this to be something
that will be less code.

00:03:45.840 --> 00:03:48.250
We want it to be faster.

00:03:48.340 --> 00:03:51.680
We want it to be faster not
only in its operation but in

00:03:51.680 --> 00:03:53.780
your using it as a programmer.

00:03:53.820 --> 00:03:58.280
We want it to be able to do concurrency.

00:03:59.370 --> 00:04:03.840
While crypto is not really a major
problem in any sort of algorithm

00:04:03.870 --> 00:04:07.960
anymore because CPUs are fast enough,
concurrency is a real issue.

00:04:07.960 --> 00:04:10.720
We're getting more CPUs all the time.

00:04:10.720 --> 00:04:14.430
There's hardly anything left that
we have that has a single CPU in it.

00:04:14.520 --> 00:04:18.370
And, you know, right now there are
laptops with eight CPUs,

00:04:18.520 --> 00:04:20.310
four cores but eight CPUs.

00:04:20.320 --> 00:04:23.200
So concurrency is a really big issue.

00:04:23.200 --> 00:04:26.080
Also,
when you start looking at what crypto is,

00:04:26.160 --> 00:04:29.180
it's not just a few
mathematical algorithms.

00:04:29.300 --> 00:04:32.820
You know, yeah, it's your ciphers,
it's your hash functions,

00:04:32.890 --> 00:04:35.560
but then you find yourself
doing compression as well.

00:04:35.560 --> 00:04:39.560
You start storing certificates
in LDAP databases.

00:04:39.560 --> 00:04:43.430
You start doing rest
calls across the network.

00:04:43.560 --> 00:04:47.970
You code things up in XML or JSON and
pretty soon crypto starts looking

00:04:47.990 --> 00:04:49.560
an awful lot like everything else.

00:04:49.570 --> 00:04:54.680
So we wanted to have a way that you could
do secure programming and all of what

00:04:54.780 --> 00:04:57.790
you need to do no matter what it is.

00:04:58.560 --> 00:05:03.100
The result of that is our
new architecture here.

00:05:03.230 --> 00:05:06.330
It has common crypto,
our new transform API,

00:05:06.680 --> 00:05:09.250
and the security framework at the top.

00:05:11.810 --> 00:05:17.320
Starting with them,
Common Crypto is our low-level API.

00:05:17.330 --> 00:05:19.520
It's basic core algorithms.

00:05:19.520 --> 00:05:23.310
It's really what you would
think of as a crypto toolkit.

00:05:23.640 --> 00:05:25.890
Its documentation is man pages.

00:05:25.960 --> 00:05:27.940
It's pretty serious C programming.

00:05:27.940 --> 00:05:31.610
It's also the foundation that
we're going to be doing for our

00:05:31.610 --> 00:05:34.500
FIPS 140 validations from here on.

00:05:35.500 --> 00:05:39.170
Our idea is that if
you code common crypto,

00:05:39.180 --> 00:05:42.890
and that includes our own code
that codes to common crypto,

00:05:42.890 --> 00:05:45.730
then you get to inherit our validations.

00:05:45.830 --> 00:05:49.550
So we want it to be small,
we want it to be tight,

00:05:49.550 --> 00:05:55.260
we want it to be the real foundation and
framework of the rest of the building

00:05:55.340 --> 00:05:59.690
in an architectural metaphorical sense.

00:06:02.510 --> 00:06:06.010
It may not be new to you,
Common Crypto existed in Snow Leopard.

00:06:06.010 --> 00:06:10.630
When we looked at what we
wanted for a very low-level API,

00:06:10.780 --> 00:06:13.510
Common Crypto was sufficiently
close to what it was going to have

00:06:13.510 --> 00:06:17.860
to be no matter what that we said,
hey, let's just start working from there.

00:06:17.880 --> 00:06:23.800
In Lion, we recoded the internals and we
took that recoded Lion Common Crypto

00:06:23.800 --> 00:06:28.010
and moved it to iOS and did
more work on it from there.

00:06:29.000 --> 00:06:33.430
I'll also note that just this Tuesday,
we got all of the NIST algorithm

00:06:33.620 --> 00:06:37.840
certificates for all of the
algorithms in Common Crypto for iOS.

00:06:37.840 --> 00:06:40.800
So that's not just, oh yes,
we want to do FIPS on it.

00:06:40.800 --> 00:06:43.070
No, really, we're doing FIPS on it.

00:06:45.000 --> 00:06:49.170
One of the major advantages you have in
using Common Crypto is that you can say,

00:06:49.360 --> 00:06:50.640
oh, I want to do AES.

00:06:50.640 --> 00:06:55.420
And Common Crypto knows what hardware
you're on and it picks the right AES.

00:06:55.420 --> 00:06:59.660
If you happen to be on one of the new i5,
i7 Intel machines,

00:06:59.660 --> 00:07:02.240
it will use the AES NI instructions.

00:07:02.240 --> 00:07:09.400
If you're on an older computer,
it will use a vector optimized system.

00:07:09.400 --> 00:07:12.620
On iOS, we also have vector
optimized implementations of

00:07:12.650 --> 00:07:14.330
several of the algorithms.

00:07:15.060 --> 00:07:19.310
The idea is that code here for your raw
stuff and we're going to pick the best

00:07:19.310 --> 00:07:23.560
way for that to run and you don't have
to think about it because that's one of

00:07:23.770 --> 00:07:28.140
the big problems with crypto is how many
fiddly bits there are and we're going

00:07:28.140 --> 00:07:30.870
to select the right fiddly bits for you.

00:07:34.090 --> 00:07:37.140
At the very top,
we have the security framework.

00:07:37.180 --> 00:07:41.420
It is a core foundation based API.

00:07:41.700 --> 00:07:44.130
As I said before,
we've deprecated the parts

00:07:44.340 --> 00:07:46.160
that were dependent upon CDSA.

00:07:46.350 --> 00:07:51.320
There are corresponding ones that
have been replaced what's there or we

00:07:51.370 --> 00:07:54.590
migrated the data types directly for you.

00:07:54.750 --> 00:08:00.170
And that has keychains, trust models,
certificate processing, things like that.

00:08:00.360 --> 00:08:02.690
It also has some
relatively high-level APIs,

00:08:02.700 --> 00:08:05.570
which I'll show you a
little bit more about later.

00:08:06.490 --> 00:08:10.000
Now in the middle,
there's transforms and they're

00:08:10.000 --> 00:08:13.730
brand new and they're built
on Grand Central Dispatch.

00:08:13.730 --> 00:08:16.240
Grand Central Dispatch is incredible.

00:08:16.390 --> 00:08:18.390
If you haven't been using it,
you need to.

00:08:18.390 --> 00:08:23.120
Just about everything that we're doing
going forward revolves around blocks,

00:08:23.120 --> 00:08:25.540
revolves around Grand Central Dispatch.

00:08:26.970 --> 00:08:30.630
Grand Central Dispatch makes it so that
when you are writing threaded code,

00:08:30.650 --> 00:08:32.770
you don't have to think
about the threads.

00:08:32.770 --> 00:08:35.280
You think about work units,
you think about queues,

00:08:35.390 --> 00:08:37.090
and that's all you have to do.

00:08:37.930 --> 00:08:41.400
What we did with transforms was that
we took Grand Central Dispatch and

00:08:41.400 --> 00:08:43.860
turned it into a data flow architecture.

00:08:43.860 --> 00:08:49.530
So when you use transforms,
you think about...

00:08:50.000 --> 00:08:56.660
Parts of the data and steps that it goes
through to go through whatever you want.

00:08:56.660 --> 00:09:02.940
The advantage of this is that it
looks a lot like a generic function

00:09:02.940 --> 00:09:07.700
because you can have an encrypt
transform that does the right sorts of

00:09:07.700 --> 00:09:12.650
encryption based upon the parameters
and whatever the parameters are,

00:09:12.870 --> 00:09:15.010
it just does the right thing.

00:09:15.010 --> 00:09:17.330
I have an example that will make
that a little more clear later.

00:09:17.780 --> 00:09:20.900
It's also a general purpose
concurrency mechanism.

00:09:21.300 --> 00:09:24.670
Anything that you have that has
work that can be broken up into

00:09:24.670 --> 00:09:27.190
small things works with transforms.

00:09:28.910 --> 00:09:32.410
Now to get to the gotchas on this,
Transforms are only Lion,

00:09:32.530 --> 00:09:34.200
they are not yet iOS.

00:09:34.300 --> 00:09:37.800
Common Crypto is in both Lion and iOS,
and as I said,

00:09:37.800 --> 00:09:42.670
the iOS version is in fact a
successor to the Lion version.

00:09:43.110 --> 00:09:47.550
Normally when we give new APIs,
we like to have the full thing in place

00:09:47.550 --> 00:09:49.800
when we do deprecation of an old one.

00:09:49.800 --> 00:09:51.310
We didn't do that this time.

00:09:51.340 --> 00:09:53.360
And the reason that we didn't
do that is we're really

00:09:53.360 --> 00:09:54.820
pleased with what we've done.

00:09:54.820 --> 00:09:58.590
We want you to have it and work
with it and tell us what you need

00:09:58.590 --> 00:10:02.700
before we have everything in place
because it really is very nice

00:10:02.700 --> 00:10:05.080
and the other one was kind of old.

00:10:06.100 --> 00:10:10.130
So the major parts that
are really missing are some

00:10:10.130 --> 00:10:11.550
certificate handling details.

00:10:11.590 --> 00:10:14.010
There are other rough edges.

00:10:14.220 --> 00:10:16.990
Please tell us on bugreporter.apple.com.

00:10:17.140 --> 00:10:18.410
You're going to hear me say that a lot.

00:10:18.460 --> 00:10:20.230
Tell us what you need.

00:10:20.280 --> 00:10:25.880
We schedule everything that we do
based upon what's in Bug Reporter.

00:10:27.040 --> 00:10:29.460
And if you tell us what's there,
even if it's a duplicate of

00:10:29.570 --> 00:10:31.640
what other people have told,
so don't think, oh,

00:10:31.640 --> 00:10:33.360
somebody else has probably said this.

00:10:33.880 --> 00:10:36.330
If five people tell us this,
and three people tell us that,

00:10:36.450 --> 00:10:41.340
it gives us more support in figuring out
what gets done before something else.

00:10:44.910 --> 00:10:47.000
So let me go on and talk
more about transforms.

00:10:47.000 --> 00:10:53.700
Transforms are all about taking small
changes and putting them together.

00:10:53.700 --> 00:10:55.600
It's not just for crypto.

00:10:55.600 --> 00:10:58.850
It's for any sort of
sequential processing.

00:10:58.900 --> 00:11:02.600
You could, for example,
use transforms to take two

00:11:02.940 --> 00:11:06.390
different RSS feeds and combine
them together into a mashup.

00:11:06.400 --> 00:11:09.400
You could do something else
like code optimization.

00:11:09.400 --> 00:11:13.340
You know, code optimizers work by having
little things that each know a few

00:11:13.340 --> 00:11:16.900
things all stream through a code,
modifying as it goes on.

00:11:16.900 --> 00:11:20.730
These are all the sorts of workflows
that work well for transforms.

00:11:22.020 --> 00:11:25.830
To give you a quick non-crypto example,
let's imagine that we

00:11:25.830 --> 00:11:26.600
want to do a mashup.

00:11:26.680 --> 00:11:29.530
And we want to do a mashup where
we want to take cat videos and we

00:11:29.590 --> 00:11:32.380
want to take earthquake videos and
we want to mash them up together.

00:11:32.380 --> 00:11:35.130
You're going to have a transform
that goes out and finds cats.

00:11:35.140 --> 00:11:38.400
You're going to have a transform
that goes out and finds earthquakes.

00:11:38.400 --> 00:11:39.860
They each run in parallel.

00:11:39.860 --> 00:11:42.650
And then a third transform
that combines them together

00:11:42.650 --> 00:11:44.300
and there you have your mashup.

00:11:44.750 --> 00:11:48.760
And that's the sort of idea that we
have of things run in parallel and

00:11:48.760 --> 00:11:52.820
things run in small changes where you
don't have to think about the entire

00:11:52.970 --> 00:11:55.210
thing in the part that you have.

00:11:58.540 --> 00:12:01.020
I'll give you a few analogies on this.

00:12:01.100 --> 00:12:05.230
My usual one and favorite one is
these are like Unix pipelines.

00:12:05.290 --> 00:12:07.620
If you've ever done any
sort of shell programming,

00:12:07.620 --> 00:12:12.210
you know, you sort, you grep, you TR,
you awk, you do these things and

00:12:12.210 --> 00:12:14.180
you pipe them all together.

00:12:14.180 --> 00:12:16.460
Transforms are really a lot like that.

00:12:16.520 --> 00:12:19.720
They're small units that work
together to give you a bigger whole.

00:12:20.280 --> 00:12:23.920
The major differences are that
they revolve around data chunks,

00:12:24.140 --> 00:12:25.820
core foundation, not bytes.

00:12:25.820 --> 00:12:28.280
You know, Unix programming is,
it's all bytes.

00:12:28.280 --> 00:12:32.090
These things are all routines
rather than processes.

00:12:32.110 --> 00:12:35.890
Okay, really they're blocks,
but you know, blocks are just routines

00:12:35.890 --> 00:12:37.730
with frosting and sprinkles.

00:12:38.150 --> 00:12:42.260
And when you do transforms,
it's really easy to have multiple

00:12:42.260 --> 00:12:44.420
gazintas and multiple gozaudas.

00:12:44.420 --> 00:12:48.700
You can connect transforms
together with a digraph.

00:12:48.700 --> 00:12:52.340
And as long as that digraph makes sense,
it'll all work correctly.

00:12:52.340 --> 00:12:55.180
Shell programming really
ends up being limited.

00:12:55.180 --> 00:12:56.420
There are a few exceptions.

00:12:56.420 --> 00:12:58.880
You know, there's the T command.

00:12:58.900 --> 00:13:01.300
But other than that,
you're really only doing things linearly.

00:13:01.300 --> 00:13:05.290
You can do some really nice,
very complex things with transforms.

00:13:05.540 --> 00:13:07.130
They're also a lot like audio units.

00:13:07.280 --> 00:13:10.670
If you've ever used audio units,
used GarageBand, put things together,

00:13:10.930 --> 00:13:14.040
they also work on a sequence of changes.

00:13:14.240 --> 00:13:18.150
They're audio focused rather than
being a general purpose system

00:13:18.580 --> 00:13:22.920
and their main focus is to be
isochronous because it's audio.

00:13:22.920 --> 00:13:25.410
We're not isochronous,
we're not real time,

00:13:25.480 --> 00:13:27.070
but we are concurrent.

00:13:28.790 --> 00:13:31.560
And they're also kind
of like Quartz Composer,

00:13:31.670 --> 00:13:36.830
where you have an image,
you want to do a sequence of changes

00:13:36.890 --> 00:13:39.830
to the image to get something else.

00:13:40.120 --> 00:13:44.560
Again, transforms are a general purpose
mechanism and they don't have a visual

00:13:44.560 --> 00:13:48.080
programming model like Quartz Composer,
but it's like that.

00:13:48.110 --> 00:13:52.720
That gets you the idea of
what we're doing with this.

00:13:52.720 --> 00:13:55.290
So it's data-driven.

00:13:55.290 --> 00:13:56.930
That's one of the really cool things.

00:13:56.940 --> 00:13:59.450
It's really easy to think
about data-driven programming.

00:13:59.460 --> 00:14:03.120
It all revolves around core foundation.

00:14:03.120 --> 00:14:07.380
If we didn't have core foundation,
we'd have to create something like it.

00:14:07.480 --> 00:14:13.590
We need to have the sorts of arrays,
dictionaries, descriptor-based data,

00:14:13.760 --> 00:14:15.460
so on and so forth.

00:14:15.520 --> 00:14:19.310
And by using core foundation,
not only do we not have to do the work,

00:14:19.310 --> 00:14:21.840
but you get toll-free bridging to Cocoa.

00:14:21.840 --> 00:14:24.680
So anything that I talk
about where I'll say,

00:14:24.680 --> 00:14:28.200
you know, CFData, CFError,
you can translate that

00:14:28.620 --> 00:14:30.280
in your head into NS.

00:14:30.280 --> 00:14:34.200
And as a matter of fact,
I sometimes pronounce CF NS myself.

00:14:34.220 --> 00:14:37.190
Lastly, this isn't a kernel interface.

00:14:37.420 --> 00:14:38.560
So, sorry.

00:14:38.560 --> 00:14:42.260
Now let me give you an
example of how they work.

00:14:42.340 --> 00:14:43.450
So let's say you have a kernel.

00:14:44.900 --> 00:14:47.400
The transform is an object.

00:14:47.630 --> 00:14:52.720
And like an object,
it is its own self-contained thing.

00:14:52.720 --> 00:14:55.900
You talk to the transforms
with what we call attributes.

00:14:56.010 --> 00:14:57.960
And attributes are just named slots.

00:14:58.040 --> 00:14:59.380
They're named with a string.

00:14:59.430 --> 00:15:01.140
They're like a dictionary.

00:15:01.140 --> 00:15:04.480
As a matter of fact, underneath,
they are a dictionary.

00:15:05.210 --> 00:15:08.200
You can have your attributes
be whatever makes sense.

00:15:08.200 --> 00:15:11.650
So for crypto,
key might be an obvious attribute

00:15:11.740 --> 00:15:17.190
that you would give this transform its
key through an attribute named key.

00:15:17.400 --> 00:15:20.800
If you were doing RSS,
you might have one called Article.

00:15:20.800 --> 00:15:25.460
If you were doing audio or video,
you might do it with media.

00:15:25.610 --> 00:15:31.100
Now in a generic sense and thinking
of it kind of like the Unix pipelines,

00:15:31.230 --> 00:15:34.140
you have input and output and
those are your equivalent of

00:15:34.140 --> 00:15:36.410
standard in and standard out.

00:15:36.550 --> 00:15:41.830
The data input comes in on the input one,
it goes out through output and

00:15:42.190 --> 00:15:46.990
goes on from there to the next
transform and on down the line.

00:15:49.400 --> 00:15:53.880
To give you an example,
we start with some data and we send the

00:15:54.060 --> 00:15:59.230
data through the input attribute to the
first transform where it does its work,

00:15:59.490 --> 00:16:03.030
sends it on its output and its
output is connected to the input

00:16:03.030 --> 00:16:06.400
of the next one and it does work
and sends them on down the line.

00:16:06.400 --> 00:16:09.400
And all of these things
can be running in parallel.

00:16:09.400 --> 00:16:13.390
And as a matter of fact,
they will be running in parallel usually.

00:16:17.520 --> 00:16:20.940
What goes on inside of them.

00:16:20.940 --> 00:16:24.020
One of the fun things that we've
done with this is that you can

00:16:24.070 --> 00:16:28.430
take a transform set that you use,
you set it up, you can save it,

00:16:28.540 --> 00:16:31.620
you can externalize it,
and you can then bring it back in.

00:16:31.720 --> 00:16:35.010
So if you have gone to the
trouble of doing some complex

00:16:35.340 --> 00:16:39.560
transform set to do your work,
you can save it off, bring it in,

00:16:39.560 --> 00:16:40.870
and use it again.

00:16:44.100 --> 00:16:48.480
Also,
because we're using core foundation,

00:16:48.500 --> 00:16:52.480
it works equally well
with C or Objective C.

00:16:53.040 --> 00:16:58.590
NS objects are easily castable
through toll-free bridging to CF ones.

00:16:58.590 --> 00:17:00.290
And again, it's all blocks.

00:17:00.300 --> 00:17:01.270
Blocks, blocks, blocks.

00:17:04.520 --> 00:17:10.300
The attributes that we have get connected
with connections to make the pipes.

00:17:10.360 --> 00:17:14.020
And they're like Unix pipes,
they're I/O flows.

00:17:14.410 --> 00:17:18.160
And when you write to an attribute
that's connected to somewhere else,

00:17:18.160 --> 00:17:20.550
it automatically flows
from one to another.

00:17:20.550 --> 00:17:25.630
And this allows transforms to be able
to focus their attention on exactly

00:17:25.630 --> 00:17:29.610
what they do and have everything
work in a larger system together.

00:17:34.160 --> 00:17:36.400
I've probably been
thinking ahead and said,

00:17:36.520 --> 00:17:41.850
"Hmm, if you're going to have concurrent
things doing lots of stuff in parallel,

00:17:41.990 --> 00:17:46.890
that means that you're going to have
some issues with what happens when one

00:17:46.890 --> 00:17:51.380
of them outproduces what its consumer is,
and so how do I keep from having

00:17:51.380 --> 00:17:56.340
maximal data explosion and so on?" Well,
we've got flow control in two ways.

00:17:56.340 --> 00:17:59.600
There's implicit flow control
and explicit flow control.

00:17:59.780 --> 00:18:03.100
The implicit flow control
is really just like I/O.

00:18:03.130 --> 00:18:08.970
Every attribute has an input queue,
and if that input queue gets overflowed,

00:18:09.110 --> 00:18:11.270
too many things get written to it,
the writer stalls.

00:18:11.340 --> 00:18:14.690
It's just like when you write
to a file or you write to a pipe

00:18:14.800 --> 00:18:18.510
and nobody's read from it yet,
you block until it finishes.

00:18:18.640 --> 00:18:22.200
So that's a really nice
programming model because you

00:18:22.280 --> 00:18:24.500
don't have to change your head.

00:18:24.640 --> 00:18:27.050
It works just like a pipe.

00:18:27.140 --> 00:18:30.130
It works just like a file.

00:18:30.800 --> 00:18:35.340
Explicit flow control is done through
something that we call pushback.

00:18:35.340 --> 00:18:38.710
On any given attribute,
you can push back one

00:18:38.710 --> 00:18:40.490
CF object on top of it.

00:18:40.560 --> 00:18:45.190
And that permits you to say,
I'm not ready yet.

00:18:45.310 --> 00:18:48.520
So if I take my example where
I'm doing cats and earthquakes,

00:18:48.680 --> 00:18:51.600
if I've got cats coming in
because there are lots of cats

00:18:51.690 --> 00:18:54.840
and not as many earthquakes,
I can push back the cats until

00:18:54.840 --> 00:18:58.570
I get an earthquake come in and
then combine the two and go on.

00:19:03.310 --> 00:19:07.430
Attributes are asynchronous,
they can fire at any time,

00:19:07.630 --> 00:19:12.550
but there is a serialized queue
inside of every transform that within

00:19:12.660 --> 00:19:15.210
a transform it acts like a process.

00:19:16.080 --> 00:19:20.000
This is an important thing to do
because if we don't have that,

00:19:20.000 --> 00:19:23.460
if everything is truly asynchronous,
then you have to worry about

00:19:23.460 --> 00:19:25.280
concurrency issues with yourself.

00:19:25.340 --> 00:19:29.520
Inside of a transform,
it behaves like a process does.

00:19:29.580 --> 00:19:32.020
And that's what that
serialization queue does,

00:19:32.020 --> 00:19:35.310
so that you don't have to worry about,
"I'm reading from this attribute

00:19:35.390 --> 00:19:39.100
when another one comes in." It's not
going to come in until you're done.

00:19:43.900 --> 00:19:47.210
There are five special
attributes that we have.

00:19:47.340 --> 00:19:49.800
I've already told you
about input and output.

00:19:49.950 --> 00:19:54.030
They're the equivalent of
standard in and standard out.

00:19:54.570 --> 00:19:57.340
All the transforms have to have names.

00:19:57.410 --> 00:20:02.600
That's necessary for when we let
you save them and restore them.

00:20:02.700 --> 00:20:04.500
We name them with something random.

00:20:04.570 --> 00:20:08.380
You can set to the label attribute if
you want to name a transform yourself.

00:20:08.400 --> 00:20:11.960
There's no real reason to,
but it's there.

00:20:13.250 --> 00:20:18.640
If you write to the abort attribute of
any transform from inside or outside,

00:20:18.640 --> 00:20:20.500
that signals an error.

00:20:20.570 --> 00:20:24.390
That's pulling the emergency
stop cord on the train.

00:20:24.520 --> 00:20:26.350
It all comes to a halt after that.

00:20:26.350 --> 00:20:31.520
The debug attribute is there
for logging information.

00:20:36.160 --> 00:20:42.810
The data that we deal with in transforms
is most strictly all a CF type ref,

00:20:43.190 --> 00:20:45.610
which is a CF anything.

00:20:45.730 --> 00:20:50.170
You can write any
CF thing to any attribute.

00:20:50.410 --> 00:20:52.090
You can type sniff it.

00:20:52.150 --> 00:20:55.730
You can do whatever you want for all
sorts of really interesting calculations.

00:20:56.400 --> 00:21:00.310
Realistically, almost everything you're
going to do is CFData.

00:21:00.500 --> 00:21:04.740
Particularly for our
implementation right now,

00:21:04.740 --> 00:21:07.980
we revolve around CFData because we
did in fact start building this as

00:21:08.040 --> 00:21:12.180
being a data processing system and
a crypto data processing system.

00:21:13.370 --> 00:21:17.670
CFData are the most first
class of all things,

00:21:17.670 --> 00:21:21.800
but any CF object can be put onto things.

00:21:22.510 --> 00:21:26.670
Also, attributes can have multiple
outgoing connections.

00:21:26.800 --> 00:21:30.430
This is really useful not only for
the times when you need to have

00:21:30.430 --> 00:21:33.740
output data going to two places,
but it means that you can have

00:21:33.900 --> 00:21:37.320
debugging monitors connected to
an attribute so that you could see

00:21:37.320 --> 00:21:41.540
what's coming out of anything if you
are having to do your own debugging.

00:21:41.950 --> 00:21:45.790
It also means that you could feed these
things into progress bars or other

00:21:45.790 --> 00:21:51.740
UI elements where you want to have a tap
on what's going on on the system itself.

00:21:52.200 --> 00:21:54.280
It's a really nice little
feature that you can have that.

00:21:54.350 --> 00:21:57.800
So that's just one thing
to remember as well.

00:21:57.920 --> 00:22:01.120
So I'm going to run through some code.

00:22:01.950 --> 00:22:04.060
And I'm going to do a
really simple one first.

00:22:04.070 --> 00:22:06.860
I mean, because if you think about
something that you might do,

00:22:06.900 --> 00:22:12.100
you might say, read from a file,
compress it, encrypt it,

00:22:12.120 --> 00:22:14.620
and then base 64 it.

00:22:14.930 --> 00:22:18.220
And you'd base it 60 for it because,
like it or not,

00:22:18.430 --> 00:22:22.680
the internet in most cases wants
its data to be 7-bit clean.

00:22:22.680 --> 00:22:26.900
And there are just all sorts of
places that unrestricted binary data

00:22:27.010 --> 00:22:28.460
will give somebody a heart attack.

00:22:28.610 --> 00:22:33.560
So there are lots and lots of web
programming cases where you need to take

00:22:33.570 --> 00:22:36.590
your binary data and base 60 for it.

00:22:37.360 --> 00:22:41.060
So here's a code sample of how
to do this with a transform.

00:22:41.150 --> 00:22:44.080
My first line is a CFData.

00:22:44.160 --> 00:22:46.050
It's my input.

00:22:46.130 --> 00:22:49.710
It's where I, you know,
it's what I'm supposed to encode.

00:22:50.000 --> 00:22:52.340
I also have a CFError.

00:22:52.340 --> 00:22:55.140
We do all of our error
reporting through CFErrors.

00:22:55.160 --> 00:23:00.950
And again, if you're used to NSErrors,
CFErrors and NSErrors are close cousins.

00:23:01.060 --> 00:23:05.640
We do them slightly differently than
some people who do NSErrors because

00:23:05.640 --> 00:23:10.870
we have you set the error ref
to null and we return back

00:23:10.870 --> 00:23:12.740
something if there is an error.

00:23:12.800 --> 00:23:15.900
If that error variable
ever goes non-null,

00:23:15.900 --> 00:23:18.060
it means you have an error.

00:23:18.120 --> 00:23:21.150
So anyway,
we're creating a transform here.

00:23:21.260 --> 00:23:23.500
And this is an encode transform.

00:23:23.600 --> 00:23:28.020
You can see that we have a
constant for base64 encoding.

00:23:28.080 --> 00:23:29.400
There are other encodings as well.

00:23:29.580 --> 00:23:32.330
For example, there's zlib encoding.

00:23:33.210 --> 00:23:36.360
And we get our coding transform.

00:23:36.560 --> 00:23:40.810
And in this line,
you can see that there is a long constant

00:23:41.040 --> 00:23:44.530
for the string input in all caps.

00:23:44.820 --> 00:23:48.100
Much better to use the constant,
but that's really all that it is.

00:23:48.210 --> 00:23:54.090
And we're writing the data
onto the input attribute.

00:23:54.500 --> 00:23:58.460
To tell that transform,
here's what we want you to operate on.

00:23:58.710 --> 00:24:02.060
And then we call sec transform execute.

00:24:02.210 --> 00:24:04.890
And that takes the transform,
it would return an

00:24:05.400 --> 00:24:09.410
error in the CFErrorRef,
and a CFData will come back to us that

00:24:09.470 --> 00:24:12.290
is a CFData of the resulting data.

00:24:12.300 --> 00:24:12.920
That's it.

00:24:13.050 --> 00:24:14.820
I mean, that's all you have to do now.

00:24:17.970 --> 00:24:19.960
So let's go one more.

00:24:20.010 --> 00:24:21.480
Let's do two transforms.

00:24:21.600 --> 00:24:25.130
We're going to do encrypt and base64.

00:24:26.210 --> 00:24:29.200
First parameter that we
have here is a SecKeyRef.

00:24:29.250 --> 00:24:34.030
That's a key coming from
the security framework.

00:24:34.490 --> 00:24:38.540
This also is where this works
a lot like a generic function.

00:24:38.710 --> 00:24:41.170
It also is something
of a universal context.

00:24:41.280 --> 00:24:45.870
If you are used to CDSA,
you know that CDSA has all sorts of

00:24:45.970 --> 00:24:48.240
things you've got to keep hold of.

00:24:48.410 --> 00:24:50.450
And we've reduced that tremendously.

00:24:50.530 --> 00:24:52.660
There's not that many
things to keep hold of here.

00:24:54.000 --> 00:24:55.300
That key can be an AES key.

00:24:55.300 --> 00:24:56.420
It could be an RSA key.

00:24:56.460 --> 00:24:58.120
It could be an elliptic curve key.

00:24:58.120 --> 00:24:59.330
It could have padding.

00:24:59.330 --> 00:25:01.050
It could have other things.

00:25:01.050 --> 00:25:03.060
I don't need to know and I don't care.

00:25:03.200 --> 00:25:05.970
I just know that it is a key
that somebody set up for me.

00:25:08.480 --> 00:25:12.840
Like before, we have the data that
we're going to work on.

00:25:12.980 --> 00:25:17.730
And note here, we create a transform that
is our encryption transform.

00:25:17.840 --> 00:25:21.170
An error would come back
if there was a problem.

00:25:21.260 --> 00:25:27.340
Like before,
I'm going to have the encoding transform.

00:25:27.600 --> 00:25:31.550
Now in this new little thing,
we're creating a transform group.

00:25:31.700 --> 00:25:34.330
And a transform group is the handle.

00:25:34.340 --> 00:25:36.590
When you have a chain of them,
you've got to have a handle.

00:25:36.740 --> 00:25:39.890
Think of it as it's the
six pack container that you

00:25:40.040 --> 00:25:41.210
put all the transforms in.

00:25:41.250 --> 00:25:47.480
It exists to have a place
where we know what's going on,

00:25:47.630 --> 00:25:50.660
where all of the references
to everything will be held,

00:25:50.660 --> 00:25:53.090
where we know where the graph of them is.

00:25:53.090 --> 00:25:56.170
And it's, you know, it's just the holder.

00:25:57.780 --> 00:26:01.600
This line is where all the magic happens.

00:26:01.740 --> 00:26:04.670
To go through it quickly,

00:26:05.180 --> 00:26:10.560
I have the encryption transform and its
output attribute and I have the encoding

00:26:10.560 --> 00:26:12.800
transform and its input attribute.

00:26:12.800 --> 00:26:18.320
And so I'm kind of drawing a line just
like I did on the little graph from

00:26:18.320 --> 00:26:24.150
output to the input of the next one and
I'm telling it what group I want them

00:26:24.150 --> 00:26:27.210
in and where to bring back any errors.

00:26:29.910 --> 00:26:35.680
Like before, I take the start data,
I put it onto the input of the first one,

00:26:36.110 --> 00:26:40.480
And in this particular case,
I'm going to do an async call.

00:26:40.590 --> 00:26:46.490
The async call has the group and
it also has this little abbreviated

00:26:46.490 --> 00:26:50.450
bit of code that I apologize for,
but I wanted it to fit

00:26:50.450 --> 00:26:51.740
on only one screen.

00:26:51.740 --> 00:26:53.940
That's a block that's
going to get called.

00:26:54.690 --> 00:26:57.540
And that block is going
to have three parameters,

00:26:57.630 --> 00:27:00.200
one of which is going to
be a CFDataRef that holds

00:27:00.540 --> 00:27:02.360
the intermediate result.

00:27:02.420 --> 00:27:04.820
Well, sorry, the partial result.

00:27:04.880 --> 00:27:09.200
A CFError in case there was an
error that happened in the middle.

00:27:10.180 --> 00:27:14.160
And a Boolean flag for whether
or not this is the last one.

00:27:14.160 --> 00:27:18.870
And that block will get called
every time there's a chunk go by.

00:27:20.150 --> 00:27:23.940
It's entirely possible that you
could get that called only once.

00:27:24.460 --> 00:27:27.200
It could be called one
time for every byte.

00:27:27.720 --> 00:27:29.870
Now, you know,
in this particular example,

00:27:29.870 --> 00:27:32.070
it's probably only going
to get called once.

00:27:32.100 --> 00:27:35.460
But, you know, if you look at this,
you can think how you would do it

00:27:35.460 --> 00:27:42.140
if you wanted to compress and then
encrypt and then base 64 or read a file,

00:27:42.140 --> 00:27:43.660
compress.

00:27:44.160 --> 00:27:47.450
You just create a couple more transforms,
connect them together,

00:27:47.450 --> 00:27:49.970
and particularly in the
case of reading from a file,

00:27:49.970 --> 00:27:52.090
you would have little chunks going on.

00:27:55.600 --> 00:27:59.360
The transform library that we've
created for you for Lion has a

00:27:59.360 --> 00:28:01.040
bunch of basic cryptography in it.

00:28:01.330 --> 00:28:04.300
It's got encryption and decryption.

00:28:04.420 --> 00:28:08.490
It's got digital signatures,
sign and verify.

00:28:09.560 --> 00:28:13.910
It's got hashes in HMACS,
it's got key wrapping,

00:28:13.940 --> 00:28:18.350
and it's also got string to key,
which will take like a password and

00:28:18.390 --> 00:28:21.240
produce a key out of that password.

00:28:21.410 --> 00:28:25.330
It's also got three flavors of encoding.

00:28:26.990 --> 00:28:29.610
Base 32, Base 64, and Zlib.

00:28:29.660 --> 00:28:32.650
And you can use any of them, all of them.

00:28:33.120 --> 00:28:36.290
It's also got some miscellaneous
things like file reading.

00:28:36.300 --> 00:28:42.340
So you can take a file or a stream and
put it into a transform pipeline and have

00:28:42.570 --> 00:28:48.310
it work on that entire file or stream
in the background for you and just let

00:28:48.400 --> 00:28:51.680
you know when something new comes in.

00:28:55.230 --> 00:28:57.540
So next I want to talk
about custom transforms,

00:28:57.540 --> 00:29:00.310
which is how to create ones of your own.

00:29:02.910 --> 00:29:06.560
We have sample code
for you in the headers.

00:29:06.640 --> 00:29:13.030
If you go to seccustomtransform.h,
there is a complete annotated

00:29:13.130 --> 00:29:15.000
example for the Caesar cipher.

00:29:15.000 --> 00:29:19.380
That's the root end cipher where,
you know, it just adds end to every byte.

00:29:19.450 --> 00:29:23.180
But the whole transform is there in the
comments and you can take a look at it.

00:29:23.280 --> 00:29:25.890
You'll see all of the things
that I'll be talking about

00:29:25.890 --> 00:29:27.500
in there and how we did them.

00:29:27.560 --> 00:29:31.440
And it's a nice example for knowing
how to do a lot of basic transform.

00:29:31.440 --> 00:29:33.790
You know,
we ourselves have essentially cut

00:29:33.900 --> 00:29:35.770
and paste from that as you go along.

00:29:38.970 --> 00:29:42.450
When transforms run,
they have a bunch of blocks that

00:29:42.560 --> 00:29:46.080
correspond to their own lifecycle events.

00:29:46.080 --> 00:29:49.930
And when the transform
has an event occur,

00:29:50.060 --> 00:29:52.230
that block executes.

00:29:53.570 --> 00:29:57.400
When you make your own transform,
you start with the null transform,

00:29:57.400 --> 00:30:01.730
which you can think of as being
kind of like cat or like T since

00:30:01.740 --> 00:30:06.610
it's got multiple outputs,
that would just pass data through.

00:30:07.220 --> 00:30:11.480
And you customize that one by
adding your own blocks to whatever

00:30:11.480 --> 00:30:15.100
transform events you want to override.

00:30:15.100 --> 00:30:21.240
And so when that event occurs,
your block will execute.

00:30:22.120 --> 00:30:25.910
Now one of the really cool
things about this is that these

00:30:26.000 --> 00:30:27.920
overrides are not just once.

00:30:27.920 --> 00:30:29.510
You can re-override at any time.

00:30:29.520 --> 00:30:34.130
So that means that you can start
off with a reasonably generic

00:30:34.130 --> 00:30:38.000
implementation and you can say,
aha, I know now that I could use my

00:30:38.000 --> 00:30:41.370
optimized implementation and just
put the optimized block in place

00:30:41.450 --> 00:30:43.240
and everything keeps running.

00:30:44.530 --> 00:30:49.230
You can also do something rather complex
like a state machine by doing your state

00:30:49.230 --> 00:30:54.200
transitions by having every state put
the new state block into the right place.

00:30:57.380 --> 00:31:01.800
The advantage of this is you can
do a lot of really complex high

00:31:01.800 --> 00:31:07.730
level things where you can make
this look like a easy to use,

00:31:07.950 --> 00:31:12.090
fun object oriented system and still
have extraordinarily high performance

00:31:12.100 --> 00:31:16.480
because blocks really are just
routines and it really is little more

00:31:16.480 --> 00:31:19.760
than a function call to get to them.

00:31:23.200 --> 00:31:26.250
Now the main thing,
there are two things that you do mostly.

00:31:26.340 --> 00:31:29.980
The first one is the attribute
set notification event.

00:31:29.990 --> 00:31:32.620
And this is when somebody
writes to an attribute,

00:31:32.620 --> 00:31:33.970
this block will fire.

00:31:34.080 --> 00:31:35.440
There are two ways that you can do it.

00:31:35.520 --> 00:31:38.280
You can either give a named attribute,
like for example,

00:31:38.440 --> 00:31:41.640
key is a perfectly fine named
attribute that you would want

00:31:41.700 --> 00:31:43.550
to catch that one in specific.

00:31:43.550 --> 00:31:46.970
Or you can have a catch all
handler that hits anything.

00:31:47.910 --> 00:31:51.690
If you have both, you know,
if I have both key and the catchall

00:31:51.870 --> 00:31:56.510
and somebody sets my key attribute,
only the key will execute,

00:31:56.510 --> 00:31:58.290
not the generic.

00:31:58.620 --> 00:32:02.800
But the generic one lets you do something
so that if you want to know any time

00:32:02.950 --> 00:32:07.670
any attribute is done or a protocol
that you would have that would have

00:32:08.010 --> 00:32:12.250
names that you wouldn't know in advance,
you can handle that with

00:32:12.250 --> 00:32:14.110
the generic handler.

00:32:15.970 --> 00:32:20.060
The other main one that
everybody does is process data.

00:32:20.110 --> 00:32:25.300
And this is a shortcut
for a handler on input

00:32:25.600 --> 00:32:31.240
The nice thing about processed data is
that it pre-vets everything for you.

00:32:31.290 --> 00:32:35.800
You know that what has
come in is a CFData.

00:32:36.580 --> 00:32:41.500
Also, when you return from
the process data block,

00:32:41.500 --> 00:32:45.080
whatever you return gets
passed on down the line.

00:32:45.160 --> 00:32:47.010
So you don't have to
figure any of that out.

00:32:47.120 --> 00:32:51.120
We do in the transform machinery
that bookkeeping for you.

00:32:51.200 --> 00:32:53.850
So it means that you can
write the process data

00:32:53.860 --> 00:32:57.020
routine as I get an input in,
I return an output out.

00:32:57.080 --> 00:33:00.960
And that's all I have to do is
that small little juggling act.

00:33:02.980 --> 00:33:06.960
A null gets sent to you as
the equivalent of end of file.

00:33:08.170 --> 00:33:11.400
And if you return null,
that's passing an end to file

00:33:11.400 --> 00:33:14.050
on down the line as well.

00:33:17.340 --> 00:33:20.230
There are two other main
lifecycle functions.

00:33:20.340 --> 00:33:25.190
Execute starting, which gets called right
before everything goes.

00:33:25.190 --> 00:33:29.470
And this would be the place where
you would allocate buffers if you

00:33:29.470 --> 00:33:31.180
need to open files or do anything.

00:33:31.180 --> 00:33:33.020
State that you need to do something.

00:33:33.020 --> 00:33:35.240
You start that up and execute starting.

00:33:35.240 --> 00:33:37.770
And that's also one of the
advantages of it that you

00:33:37.770 --> 00:33:39.440
don't have to test every time.

00:33:39.460 --> 00:33:42.490
You know that this is
essentially we're starting now,

00:33:42.490 --> 00:33:43.540
so I need to prep.

00:33:44.440 --> 00:33:46.620
There's also finalize,
which is the corresponding

00:33:46.620 --> 00:33:48.080
one that everything is done.

00:33:48.160 --> 00:33:51.080
You're about to be released,
so you get rid of all of your extra

00:33:51.080 --> 00:33:52.850
things that you might have had.

00:34:01.300 --> 00:34:04.780
That's pretty much all you
have to do to write one.

00:34:04.780 --> 00:34:08.500
And I'm going to give an example
now of code size comparison.

00:34:08.560 --> 00:34:12.950
On this I'm going to have on the
left a program that we wrote using

00:34:12.950 --> 00:34:16.540
CDSA and on the right we're going
to have the equivalent program

00:34:16.540 --> 00:34:18.540
that we wrote using transforms.

00:34:18.540 --> 00:34:25.570
This is a workload that we
created that combined reading,

00:34:25.870 --> 00:34:29.960
coding, encryption, and so on.

00:34:30.050 --> 00:34:36.870
And here's the source code of each one.

00:34:36.870 --> 00:34:36.880
You can see them going by.

00:34:40.600 --> 00:34:45.600
And you can also see that we
met one of our main goals.

00:34:45.870 --> 00:34:49.300
112 lines for the transforms whereas

00:34:49.510 --> 00:34:52.960
1100 for CDSA, 112 for the transforms.

00:34:52.990 --> 00:34:57.910
That's a huge improvement in size,
a huge improvement in just the

00:34:57.920 --> 00:35:00.910
simplicity of writing that.

00:35:06.070 --> 00:35:09.900
We've got a speed
comparison movie as well.

00:35:09.900 --> 00:35:13.880
In this, on the right,
you'll see Activity Monitor.

00:35:13.880 --> 00:35:16.800
We ran this on a four core Mac Pro.

00:35:16.800 --> 00:35:23.790
So it's eight CPUs, four core Mac Pro,
and when we start running that program,

00:35:24.400 --> 00:35:25.740
You'll see it go.

00:35:25.900 --> 00:35:29.620
Note that it runs kind of like
what you would expect from

00:35:29.690 --> 00:35:33.190
a late 1990s architecture.

00:35:33.330 --> 00:35:37.700
It's not really terribly
efficiently using the CPUs.

00:35:37.700 --> 00:35:42.860
It's only using the A-side
of every hyperthreaded pair.

00:35:45.440 --> 00:35:50.510
And that read a whole big file
and did our workload on it.

00:35:50.870 --> 00:35:53.200
Now here is the transform
version of that,

00:35:53.320 --> 00:35:55.450
the 112 line version of it.

00:35:55.560 --> 00:35:58.500
Now when I run this, don't blink.

00:35:58.500 --> 00:36:03.100
So there it goes.

00:36:03.150 --> 00:36:05.000
If you look at that.

00:36:10.020 --> 00:36:10.940
That's GCD.

00:36:11.090 --> 00:36:14.200
I mean, GCD is what gives us
all eight CPUs using,

00:36:14.200 --> 00:36:16.440
all eight CPUs being filled to capacity.

00:36:16.440 --> 00:36:19.480
I'm going to do that again
because always when I do this,

00:36:19.480 --> 00:36:20.660
somebody blinks.

00:36:26.600 --> 00:36:37.400
[Transcript missing]

00:36:39.700 --> 00:36:47.760
10.1% of the code and over seven
times performance improvement.

00:36:51.100 --> 00:36:54.160
Arthur Clarke said that any
sufficiently advanced technology

00:36:54.160 --> 00:36:57.260
is indistinguishable from magic.

00:36:57.350 --> 00:37:00.100
And my favorite magicians
are Penn and Teller.

00:37:00.100 --> 00:37:03.040
So in that vein,
I'm going to tell you how we did this.

00:37:03.040 --> 00:37:06.640
There are two things that we did
to make this be a better demo.

00:37:06.640 --> 00:37:10.510
One of which was that we
picked an 8 CPU system.

00:37:10.530 --> 00:37:14.840
If we'd done this on a two-core system,
it would have run twice as fast.

00:37:14.840 --> 00:37:19.340
I mean, you know,
it's rather obvious actually.

00:37:19.660 --> 00:37:21.550
But we picked 8 CPUs.

00:37:21.740 --> 00:37:26.140
And if we'd picked 24 CPUs,
it might have run up

00:37:26.310 --> 00:37:28.340
to 8 or a little more.

00:37:28.500 --> 00:37:31.120
But it wouldn't have run a
whole lot faster than that

00:37:31.120 --> 00:37:33.240
because there wasn't enough work.

00:37:33.340 --> 00:37:36.080
And that's the other thing that we
did was that we picked a workload

00:37:36.080 --> 00:37:39.860
that would fill an 8 CPU system.

00:37:41.250 --> 00:37:45.880
The really impressive thing
about this is that most times

00:37:45.950 --> 00:37:49.290
when you get a new programming
system that is more high level,

00:37:49.290 --> 00:37:54.060
more easy to use,
you end up with bottlenecks and

00:37:54.140 --> 00:37:56.320
slowdowns at execution time.

00:37:56.380 --> 00:38:01.070
One of the great things about transforms
is that the more work you throw at it,

00:38:01.210 --> 00:38:05.580
the better you take your workload and
break it up into small components,

00:38:05.580 --> 00:38:09.920
the better that GCD can figure out
how to schedule it in parallel.

00:38:11.400 --> 00:38:15.230
And that's a huge change from what
we're used to before is that when you

00:38:15.390 --> 00:38:19.040
think about breaking your problem apart,
it's better to break it up into small

00:38:19.040 --> 00:38:20.600
pieces rather than large pieces.

00:38:20.600 --> 00:38:24.640
Because every one of those small
pieces can be running somewhere.

00:38:24.640 --> 00:38:27.050
Assuming, of course,
you've got enough CPUs.

00:38:33.800 --> 00:38:38.150
To summarize transforms,
we started off with a

00:38:38.160 --> 00:38:39.740
way to speed up crypto.

00:38:39.780 --> 00:38:42.210
We needed to have a

00:38:42.420 --> 00:38:44.920
A better crypto system.

00:38:44.920 --> 00:38:48.400
And what we produced for crypto
really is a general purpose

00:38:48.400 --> 00:38:49.740
concurrent programming system.

00:38:49.740 --> 00:38:52.300
You can use this for just about anything.

00:38:52.450 --> 00:38:56.300
We built it on the shoulders of
the giants who went before us.

00:38:56.300 --> 00:39:02.630
The masterful work that went in
Core Foundation and GCD is really

00:39:02.630 --> 00:39:05.910
what lets us be able to do this.

00:39:06.170 --> 00:39:10.930
It also gives abstractions that
let you reduce code size of the

00:39:11.240 --> 00:39:15.570
problems that you're solving and
also mean that you can get order of

00:39:15.620 --> 00:39:18.740
magnitude improvements in the speed,
assuming of course you have

00:39:18.740 --> 00:39:19.680
the right workload for it.

00:39:19.990 --> 00:39:25.420
But it's fast and it's small
and what's not to like there?

00:39:30.260 --> 00:39:34.170
Last thing to talk about
that I have is OpenSSL.

00:39:34.320 --> 00:39:38.120
This is probably not news to
people because if you've been using

00:39:38.170 --> 00:39:41.760
any of the developer previews,
you've probably seen this.

00:39:41.890 --> 00:39:45.100
We're deprecating the OpenSSL dialyps.

00:39:45.120 --> 00:39:46.790
And I want to repeat that again.

00:39:46.790 --> 00:39:51.000
We're deprecating the OpenSSL dialyps.

00:39:52.040 --> 00:39:55.870
There are two major reasons
why we're doing this.

00:39:55.950 --> 00:40:02.460
One of them is that OpenSSL does not have
a stable application binary interface.

00:40:02.460 --> 00:40:05.920
They didn't design it
to be used in dial-ins.

00:40:06.060 --> 00:40:11.620
The data structures change in
between extremely minor releases.

00:40:11.620 --> 00:40:17.780
As an example, when we upgraded
OpenSSL from 0.98q to 0.98r,

00:40:17.780 --> 00:40:23.100
there were a number of people who
had their programs break because

00:40:23.100 --> 00:40:29.620
OpenSSL had changed some internal data
structures and things flipped around.

00:40:29.740 --> 00:40:32.090
It just isn't designed for that.

00:40:32.780 --> 00:40:38.410
Also, we need a FIPS 140 platform that
is stable and under our control.

00:40:38.470 --> 00:40:42.420
You need to have dialybs to be able to do

00:40:43.200 --> 00:40:47.280
A FIPS 140 validation,
you can't just do it on static libraries.

00:40:47.330 --> 00:40:52.350
And we need to have something that
we're using ourselves for that.

00:40:54.350 --> 00:40:57.180
So maybe you'll want to migrate.

00:40:57.240 --> 00:40:59.400
You know, maybe you won't.

00:40:59.430 --> 00:41:03.740
If you are using our stuff,
if you're primarily a

00:41:03.740 --> 00:41:06.010
Mac OS or iOS programmer,

00:41:07.180 --> 00:41:09.500
Migrating might be a good thing to do.

00:41:09.590 --> 00:41:12.470
There's a lot of
advantages that we've got.

00:41:12.600 --> 00:41:25.800
[Transcript missing]

00:41:26.060 --> 00:41:29.080
A special instruction said, "Oh,
what version of vector

00:41:29.080 --> 00:41:30.680
registers do I happen to have?

00:41:30.680 --> 00:41:33.820
We'll do that for you and
we'll give you the right one."

00:41:34.380 --> 00:41:37.140
We give you the small code size,
we give you the concurrency,

00:41:37.140 --> 00:41:38.800
we give you the easy programming.

00:41:39.040 --> 00:41:42.680
There's also,
you want to inherit our evaluations.

00:41:43.400 --> 00:41:47.400
If you're calling into our code,
it's essentially validated

00:41:47.400 --> 00:41:51.620
because you're calling our
validated module as they call it.

00:41:51.800 --> 00:41:53.350
This is what we're doing ourselves.

00:41:53.490 --> 00:41:58.220
We're migrating everything
in Mac OS and iOS away from

00:41:58.220 --> 00:42:01.380
OpenSSL towards our architecture.

00:42:01.890 --> 00:42:08.050
And if you want to do this and we
have not given you yet what you need,

00:42:08.400 --> 00:42:08.870
tell us.

00:42:09.130 --> 00:42:11.210
Bugreporter.apple.com, tell us.

00:42:11.280 --> 00:42:13.100
This is how we know,
this is how we prioritize.

00:42:17.180 --> 00:42:21.610
If you're going to do this,
the most closely related thing

00:42:21.610 --> 00:42:25.320
to OpenSSL crypto programming
we have is common crypto.

00:42:25.320 --> 00:42:28.180
It's low-level C things.

00:42:28.180 --> 00:42:30.620
If you're going to go
a little high level,

00:42:30.680 --> 00:42:34.500
then security framework and
transforms are where you might go,

00:42:34.530 --> 00:42:37.560
but usually people who are
using OpenSSL are using a

00:42:37.560 --> 00:42:39.810
common crypto-like API anyway.

00:42:51.770 --> 00:42:51.780
Now, if you're using SSL/TLS as
a secure transport,

00:42:51.780 --> 00:42:51.780
our secure transport library is

00:42:52.200 --> 00:42:55.240
My opinion,
the best SSL library that's out there,

00:42:55.280 --> 00:42:58.970
it's held up to abuse better
than any of the others.

00:42:59.090 --> 00:43:03.900
If you're using CF networking,
if you're using NSURL anything,

00:43:03.970 --> 00:43:04.820
you're already doing it.

00:43:04.930 --> 00:43:10.460
So if you are already using
NSURL and opening up an HTTPS,

00:43:10.870 --> 00:43:13.040
"You're using secure transport.

00:43:13.040 --> 00:43:14.400
You didn't have to do anything.

00:43:14.400 --> 00:43:18.540
And similarly, if you go to CF network
and do SSL over that,

00:43:18.640 --> 00:43:19.920
you're using our secure transport.

00:43:19.920 --> 00:43:21.360
You don't have to do anything.

00:43:21.400 --> 00:43:23.470
You already have."

00:43:25.930 --> 00:43:30.220
There's a lot of people though that this
is not a good answer and we know that.

00:43:30.270 --> 00:43:35.020
If you're writing a Unix application,
if you are doing something

00:43:35.020 --> 00:43:40.600
that is going to be running
not on just our OSs but Linux,

00:43:40.690 --> 00:43:42.850
OpenBSD, you name it.

00:43:43.660 --> 00:43:46.040
Our APIs are not an option for you.

00:43:46.080 --> 00:43:48.580
You might also already be using OpenSSL.

00:43:48.710 --> 00:43:50.080
It might be the devil you know.

00:43:50.100 --> 00:43:52.480
You know, yeah, okay, fine,
it's got a lot of problems, but,

00:43:52.480 --> 00:43:55.080
you know, I've been dealing with them
for the last 10 years anyway.

00:43:55.210 --> 00:43:58.190
Then, you know, stay where you are.

00:43:59.180 --> 00:44:02.720
What you should do is go to macports.org.

00:44:02.790 --> 00:44:06.950
That's where the most
recent version always is.

00:44:07.080 --> 00:44:10.320
1.0.0d is already there.

00:44:10.480 --> 00:44:11.800
I checked it.

00:44:11.840 --> 00:44:14.650
Statically link the libraries.

00:44:15.330 --> 00:44:19.670
That's what they want you to do anyway.

00:44:19.870 --> 00:44:23.630
They say that when they do an update,
you should be recompiling

00:44:23.630 --> 00:44:25.200
from source anyway.

00:44:25.200 --> 00:44:29.100
If you need the command line tools
or other bits of OpenSSL that

00:44:29.100 --> 00:44:32.860
aren't the libraries themselves,
include them in your bundle.

00:44:32.890 --> 00:44:34.970
It's the correct thing to do.

00:44:35.440 --> 00:44:38.200
It's what they recommend,
it's what we recommend now as

00:44:38.200 --> 00:44:43.570
well because we don't like dialy
version skew anymore than you do.

00:44:47.260 --> 00:44:49.800
So let me wrap up.

00:44:50.040 --> 00:44:52.540
We are deprecating CDSA.

00:44:52.640 --> 00:44:56.060
We are deprecating the
dialybs of OpenSSL.

00:44:56.180 --> 00:44:59.360
We know that we do not
have complete replacements.

00:44:59.530 --> 00:45:01.930
Please help us do what you need.

00:45:02.350 --> 00:45:03.820
Bugreporter.apple.com.

00:45:03.820 --> 00:45:05.050
I'll say that one last time.

00:45:06.460 --> 00:45:09.520
Common Crypto is our low-level interface.

00:45:09.570 --> 00:45:12.740
It's for bare-to-the-metal C programmers.

00:45:12.870 --> 00:45:19.060
Transforms are our core foundation API.

00:45:20.180 --> 00:45:23.540
They started off as being
a way to get fast crypto.

00:45:23.630 --> 00:45:29.490
They build on GCD and core foundation
to give you order of magnitude

00:45:29.490 --> 00:45:32.380
improvements in code size and speed.

00:45:35.720 --> 00:45:39.730
For related sessions,
well there was a really good

00:45:39.730 --> 00:45:41.930
security overview on Tuesday.

00:45:42.130 --> 00:45:45.550
If you're watching this on video,
if you haven't seen that yet,

00:45:45.550 --> 00:45:46.360
go watch it.

00:45:46.360 --> 00:45:48.160
It's a good session.

00:45:48.160 --> 00:45:50.180
And thank you very much.
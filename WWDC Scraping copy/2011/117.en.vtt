WEBVTT

00:00:10.110 --> 00:00:12.750
Good afternoon and
welcome to this session,

00:00:12.870 --> 00:00:15.000
Performing Calendar Calculations.

00:00:15.140 --> 00:00:16.300
My name is Chris Kane.

00:00:16.490 --> 00:00:20.360
I'm a software engineer with Apple.

00:00:20.610 --> 00:00:23.180
So what are we going to
talk about in this session?

00:00:23.240 --> 00:00:27.460
Well, first I'm going to begin by
reviewing what calendars are and

00:00:27.460 --> 00:00:30.100
what calendrical calculations are.

00:00:30.100 --> 00:00:35.400
Now I'm going to have to assume that you
more or less know what a calendar is,

00:00:35.400 --> 00:00:38.390
what a time zone is,
what time is and what

00:00:38.390 --> 00:00:40.040
dates are and so on.

00:00:40.340 --> 00:00:44.580
But I'm going to give a brief review
in order to introduce some of the

00:00:44.580 --> 00:00:49.610
concepts from a point of view which
will be interesting later in the talk.

00:00:50.670 --> 00:00:55.930
Then I'm going to introduce very
briefly the Cocoa APIs which are related

00:00:55.930 --> 00:00:58.740
to calendars and dates and times.

00:00:58.740 --> 00:01:02.740
But the bulk of the talk is going
to be spent discussing troublesome

00:01:02.740 --> 00:01:08.840
calendrical calculation issues that,
well, one can run into and also examples

00:01:08.840 --> 00:01:11.570
that we've seen people run into.

00:01:12.140 --> 00:01:14.000
So let's begin.

00:01:14.000 --> 00:01:22.230
Well, when we talk about time, of course,
we have this thing which is a continuum.

00:01:22.290 --> 00:01:25.490
One second precedes the
next or follows the next,

00:01:25.490 --> 00:01:26.400
I should say.

00:01:26.400 --> 00:01:31.260
And there's this continuum going
backwards and forwards in time.

00:01:31.300 --> 00:01:33.780
But people need to describe times.

00:01:33.780 --> 00:01:38.360
They need to describe when things
happen and how long things take.

00:01:38.360 --> 00:01:41.460
And so what could people do?

00:01:41.460 --> 00:01:46.100
Well, one thing we could do is observe
some sort of natural cycle,

00:01:46.100 --> 00:01:47.180
like the day.

00:01:47.180 --> 00:01:51.580
You know, the sun rises, the sun sets,
the sun rises again.

00:01:51.580 --> 00:01:56.020
We could see that and we could call
that a day and then count the days

00:01:56.150 --> 00:01:59.160
from some starting point in the past.

00:01:59.210 --> 00:02:06.850
And under such a scheme,
today could be day number 410,957.

00:02:06.850 --> 00:02:11.160
Well, that kind of number is
fine for a computer.

00:02:11.560 --> 00:02:16.580
But for people,
big numbers really are not our forte.

00:02:16.580 --> 00:02:20.920
That would be really cumbersome
for us to use that kind of scheme.

00:02:20.920 --> 00:02:24.130
So what do we end up with?

00:02:24.240 --> 00:02:25.900
Calendar components.

00:02:25.900 --> 00:02:32.340
These are human inventions to describe
event times in a more human-friendly way.

00:02:32.340 --> 00:02:37.380
Well, one thing we do, of course,
is count recurrences of natural cycles,

00:02:37.380 --> 00:02:39.350
like the day and the year.

00:02:40.040 --> 00:02:45.610
And then what we do is we group
and we decompose them into smaller,

00:02:45.720 --> 00:02:48.200
more human-tractable quantities.

00:02:48.220 --> 00:02:52.460
And in this talk,
I'm going to be calling these

00:02:52.460 --> 00:02:54.220
either units or components.

00:02:54.240 --> 00:02:55.780
So what are examples?

00:02:55.780 --> 00:03:00.050
Well, of course, years, months, days,
hours, minutes, and seconds.

00:03:00.060 --> 00:03:03.140
The unit of the day is too granular.

00:03:03.140 --> 00:03:08.340
That is,
it's too long of a period of time

00:03:08.840 --> 00:03:10.620
for us to find really useful.

00:03:10.670 --> 00:03:13.620
So we decompose that, of course,
into smaller units,

00:03:13.620 --> 00:03:15.620
hours and minutes and seconds.

00:03:15.620 --> 00:03:20.420
But the day is also, on the other hand,
too fine-grained for us to

00:03:20.510 --> 00:03:23.610
work with very conveniently.

00:03:23.620 --> 00:03:27.620
So, of course,
we group days into months and years.

00:03:27.620 --> 00:03:33.590
And so we end up talking about things
as humans in terms like the 8th of June,

00:03:33.690 --> 00:03:37.620
2011, rather than day number 412.

00:03:37.640 --> 00:03:38.120
Right?

00:03:38.120 --> 00:03:42.200
410,957.

00:03:43.090 --> 00:03:46.790
Well, of course, over the millennia,
humans have come up with and

00:03:46.790 --> 00:03:48.840
invented many different calendars.

00:03:48.840 --> 00:03:53.380
There's the Gregorian calendar,
the Hebrew calendar, the Indian calendar,

00:03:53.380 --> 00:03:54.190
and so on.

00:03:54.200 --> 00:04:00.410
For those of you who may not be aware,
the Gregorian calendar is the name of

00:04:00.410 --> 00:04:05.800
the calendar which is largely used in
Europe and North and South America and

00:04:05.800 --> 00:04:07.990
many other parts of the world.

00:04:08.000 --> 00:04:10.320
Sometimes it's called
the Western calendar.

00:04:11.170 --> 00:04:14.780
This is also the calendar that I'm
going to be using throughout the

00:04:14.780 --> 00:04:16.740
examples in the rest of my talk.

00:04:19.220 --> 00:04:23.010
What makes each calendar unique is
that they have their own different

00:04:23.020 --> 00:04:27.380
ways of counting and grouping
and describing the various years,

00:04:27.610 --> 00:04:32.280
eras, months, and days components.

00:04:33.210 --> 00:04:36.000
So what are calendrical
calculations then?

00:04:36.040 --> 00:04:41.250
Well these are arithmetic-like
operations on calendar components.

00:04:41.390 --> 00:04:47.100
So for example, I could ask the question,
what day is 90 days from today?

00:04:47.560 --> 00:04:49.060
And this sounds like addition.

00:04:49.060 --> 00:04:52.050
That is,
I know when today is and I want to

00:04:52.050 --> 00:04:58.990
add a component that is 90 days and
compute a result date out of that.

00:04:59.000 --> 00:05:03.400
Another kind of question I might have is,
how many weeks is it

00:05:03.630 --> 00:05:05.490
until my next birthday?

00:05:05.500 --> 00:05:10.490
So here I know when today is,
I know when my next birthday is,

00:05:10.490 --> 00:05:14.370
and so then I'm asking a question, well,
how many weeks is it

00:05:14.370 --> 00:05:16.000
between those two dates?

00:05:16.000 --> 00:05:19.490
And so that's a
subtraction-like operation.

00:05:20.850 --> 00:05:24.000
Calendrical calculations
are also involved in doing

00:05:24.090 --> 00:05:26.560
conversions between the calendars.

00:05:26.560 --> 00:05:30.200
You know, just as I had mentioned,
there are many different human calendars,

00:05:30.230 --> 00:05:33.500
and often it's useful to be
able to convert between them.

00:05:33.500 --> 00:05:39.200
And so the calendrical calculation
operations come into play there as well.

00:05:39.200 --> 00:05:42.820
Now,
the most significant point of the talk,

00:05:42.820 --> 00:05:48.340
perhaps, here today, is that calendrical
calculations are subtle.

00:05:48.340 --> 00:05:50.490
Let me give an example.

00:05:50.870 --> 00:05:57.600
So suppose we have a date like
January 9th and we want to add one month.

00:05:57.650 --> 00:06:02.060
Well,
the result is going to be February 9th.

00:06:02.480 --> 00:06:06.630
That is, if you notice,
the month has changed

00:06:06.630 --> 00:06:12.350
because I'm adding one month,
but the day has not changed.

00:06:12.480 --> 00:06:17.580
The day has been preserved,
and so very naturally we get February 9th

00:06:17.590 --> 00:06:21.110
when adding one month to January 9th.

00:06:21.260 --> 00:06:26.280
But if instead I start with the
30th of January and I add one month,

00:06:26.440 --> 00:06:29.780
well there is no 30th of February.

00:06:29.890 --> 00:06:31.070
So what can we do?

00:06:31.130 --> 00:06:39.620
Well, the most natural result for most
people is to return the best

00:06:39.700 --> 00:06:41.560
answer that we can in February.

00:06:41.740 --> 00:06:46.870
And so we return the closest number,
the 28th of February from

00:06:46.870 --> 00:06:48.970
this kind of operation.

00:06:49.220 --> 00:06:52.360
Well, if I then add another month
to the 28th of February,

00:06:52.490 --> 00:06:53.640
I get the 28th of March.

00:06:53.730 --> 00:06:57.480
That is, the 28 gets preserved.

00:06:58.700 --> 00:07:04.540
But if I instead start with the
30th of January and I add two months

00:07:04.620 --> 00:07:08.290
in a single calendrical operation,
I end up with a result

00:07:08.290 --> 00:07:09.640
of the 30th of March.

00:07:09.640 --> 00:07:11.720
So what have we seen here?

00:07:11.720 --> 00:07:15.450
When I started with the 30th of
January and I added one month

00:07:15.450 --> 00:07:19.180
and then I added another month,
that is, did two operations,

00:07:19.180 --> 00:07:21.660
I ended up with the 28th of March.

00:07:22.380 --> 00:07:25.290
But if instead I add two
months in one operation,

00:07:25.290 --> 00:07:27.620
I end up with the 30th of March.

00:07:27.620 --> 00:07:34.070
So the calendrical arithmetic
here is not symmetric or it's not

00:07:34.300 --> 00:07:36.590
just like ordinary arithmetic.

00:07:36.650 --> 00:07:40.300
There are subtleties introduced
by the nature and the

00:07:40.380 --> 00:07:42.630
definition of each calendar.

00:07:44.330 --> 00:07:51.030
So generally, as I said,
smaller components, that is,

00:07:51.100 --> 00:07:54.430
components smaller than the
ones I'm changing or adding,

00:07:54.450 --> 00:07:56.430
for example, in this case, are preserved.

00:07:56.550 --> 00:08:02.880
So the day was preserved whenever
possible when I was adding a month.

00:08:04.060 --> 00:08:09.190
Now, the other main point that I want to
hammer home at this point is try not to

00:08:09.260 --> 00:08:11.480
do calendrical calculations yourself.

00:08:11.480 --> 00:08:15.640
Leave them to the system
whenever possible.

00:08:15.820 --> 00:08:20.270
If you find yourself doing
arithmetic on a clinical component,

00:08:20.270 --> 00:08:26.120
that is for example computing a week
number from some date and adding

00:08:26.290 --> 00:08:32.700
say three weeks to that with you
know plus three in your source code,

00:08:33.580 --> 00:08:35.410
you might be doing something wrong.

00:08:35.410 --> 00:08:40.250
So anytime you find yourself doing that,
take a step back and think

00:08:40.250 --> 00:08:41.900
about what you're doing.

00:08:41.900 --> 00:08:50.200
But not only should you rely
on the system to perform the

00:08:50.250 --> 00:08:56.240
calendrical calculations yourself,
how you go about doing those calculations

00:08:56.670 --> 00:09:02.940
is also important and we'll see that
in examples later on in this talk.

00:09:04.270 --> 00:09:08.360
So let me review,
for those of you who may not be

00:09:08.360 --> 00:09:15.080
intimately familiar with all of them,
some of the Cocoa Calendar and Time APIs.

00:09:15.280 --> 00:09:18.590
Here's the list that
I'm going to go through.

00:09:19.100 --> 00:09:24.800
So what we do in Cocoa when we defined
our APIs is we started by defining

00:09:24.800 --> 00:09:28.000
a calendar independent time scale.

00:09:28.000 --> 00:09:31.100
So what we did there was
we picked a reference date,

00:09:31.220 --> 00:09:36.150
a moment in time, and then we said, well,
we're going to count the number of

00:09:36.150 --> 00:09:38.200
seconds from that reference date.

00:09:38.240 --> 00:09:42.810
So a date into the future relative
to that reference date is going to

00:09:42.860 --> 00:09:46.750
be a positive number of seconds,
and a date in the past relative

00:09:46.750 --> 00:09:50.290
to that reference date is going to
be a negative number of seconds.

00:09:50.300 --> 00:09:53.040
And we call this an NSTimeInterval.

00:09:53.300 --> 00:09:58.210
Sometimes this is also referred to,
particularly in the NSDate class,

00:09:58.310 --> 00:10:01.810
as a time interval since
the reference date.

00:10:02.410 --> 00:10:06.820
All this is is a floating point
number of seconds after the reference

00:10:07.280 --> 00:10:12.300
date in the reference time zone,
which I'm going to interchangeably

00:10:12.300 --> 00:10:14.540
call either GMT or UTC.

00:10:14.540 --> 00:10:19.110
The value of the current
NS time interval,

00:10:19.110 --> 00:10:27.240
as I'm talking right now,
is about positive 329 million seconds.

00:10:27.240 --> 00:10:33.330
Again, this is a kind of thing,
this time scale,

00:10:33.660 --> 00:10:37.260
which is something a computer
can work with easily,

00:10:37.410 --> 00:10:41.680
but not something that humans would
normally directly work with because

00:10:41.680 --> 00:10:44.230
these numbers are just way too large.

00:10:44.240 --> 00:10:47.740
Well, when is this reference date
that I'm talking about?

00:10:48.180 --> 00:10:52.930
Well, as it happens,
our reference date is the first of

00:10:52.930 --> 00:10:57.240
January in the year 2001 at midnight.

00:10:57.360 --> 00:11:00.240
So, this is the second day of
the Gregorian calendar.

00:11:00.240 --> 00:11:03.010
But of course,
this moment in time exists in

00:11:03.010 --> 00:11:05.240
all of the different calendars.

00:11:05.240 --> 00:11:08.380
And so, for example,
in the Hebrew calendar,

00:11:08.380 --> 00:11:13.750
the reference date happens to be the
sixth day of Tevit in the year 5761,

00:11:13.750 --> 00:11:15.240
also at midnight.

00:11:15.240 --> 00:11:18.830
Well,
sometimes you want an object wrapper that

00:11:18.910 --> 00:11:24.200
is an object form of an NS time interval,
and so that's what NSDate is.

00:11:24.240 --> 00:11:25.410
All an NSDate is,
is the number of seconds that

00:11:25.410 --> 00:11:26.240
you're going to do in the year.

00:11:26.240 --> 00:11:26.240
All right.

00:11:26.240 --> 00:11:26.240
So, this is a floating
point number of seconds.

00:11:26.240 --> 00:11:26.240
The reference date happens to be the
sixth day of Tevit in the year 5761,

00:11:26.240 --> 00:11:26.240
also at midnight.

00:11:26.240 --> 00:11:26.240
Well,
sometimes you want an object wrapper that

00:11:26.240 --> 00:11:26.240
is an object form of an NS time interval,
and so that's what NSDate is.

00:11:26.240 --> 00:11:26.240
All an NSDate is,
is the number of seconds that

00:11:26.240 --> 00:11:26.240
you're going to do in the year.

00:11:26.240 --> 00:11:30.740
is the number of seconds, uh, a holder,
an object holder,

00:11:30.740 --> 00:11:34.280
for an ns time interval, which again,
is the number of seconds

00:11:34.730 --> 00:11:38.930
after the reference date
in the reference time zone,

00:11:38.930 --> 00:11:39.700
GMT.

00:11:40.070 --> 00:11:45.740
NSDate as an object is not a date
associated with any particular calendar.

00:11:45.820 --> 00:11:49.570
It's associated with our
calendar independent time scale,

00:11:49.590 --> 00:11:51.610
NSTimeInterval.

00:11:52.190 --> 00:11:56.080
NSDates are also not associated
with any particular time zone.

00:11:56.250 --> 00:12:00.350
That is,
the NSDate is representing a time in

00:12:00.820 --> 00:12:04.570
the reference time zone for the world,
GMT.

00:12:06.080 --> 00:12:08.880
Then we have the class NS Calendar.

00:12:08.880 --> 00:12:11.800
And of course, as you might expect,
this is the class that

00:12:11.800 --> 00:12:14.190
represents calendars.

00:12:14.480 --> 00:12:18.590
and his calendars is the object
which knows about the arithmetic

00:12:18.710 --> 00:12:19.940
properties of calendars.

00:12:19.950 --> 00:12:22.900
For example,
how many months are there in a year?

00:12:22.950 --> 00:12:25.300
How many days are there in each month?

00:12:25.390 --> 00:12:28.540
How many hours are there in a day?

00:12:28.540 --> 00:12:28.540
And so on.

00:12:28.760 --> 00:12:34.130
: NSCalendar is also the object that
knows how to convert an NSTimeInterval,

00:12:34.220 --> 00:12:38.380
that is a value in this
calendar independent time scale,

00:12:38.420 --> 00:12:43.160
to and from dates within
that particular calendar.

00:12:43.260 --> 00:12:46.140
And so to convert between two calendars,
for example,

00:12:46.140 --> 00:12:49.400
normally one would take a date
in that original calendar,

00:12:49.510 --> 00:12:53.190
convert it to an NSTimeInterval,
and then convert that NSTimeInterval

00:12:53.190 --> 00:12:56.280
into the target calendar.

00:12:56.960 --> 00:13:01.400
The NS Calendar class also is the
object that knows how to do the

00:13:01.400 --> 00:13:04.030
kind of calendrical calculations
I was just talking about,

00:13:04.100 --> 00:13:07.380
like, you know,
what is the day 90 days from today?

00:13:07.400 --> 00:13:09.900
Then we have the NSDate Components class.

00:13:09.900 --> 00:13:14.960
NSDate Components is simply an object,
a very simple plain object,

00:13:14.960 --> 00:13:17.940
which represents a set
of calendar components.

00:13:18.790 --> 00:13:22.900
For example,
you could have an NSDate Components

00:13:22.900 --> 00:13:27.250
object with a value of,
say, June for the month and

00:13:27.250 --> 00:13:29.380
the 8th for the day.

00:13:29.480 --> 00:13:34.380
And that might be, you know,
all there is to any particular

00:13:34.380 --> 00:13:36.890
NSDate Components object.

00:13:37.170 --> 00:13:39.810
The component values
within an NSDate components

00:13:39.810 --> 00:13:43.930
object are signed integers,
and this comes into play when

00:13:43.930 --> 00:13:46.460
you use one in a relative sense.

00:13:46.460 --> 00:13:52.280
Well, an NSDate components object can
be used in either of two ways.

00:13:52.280 --> 00:13:58.200
When you have what I call an
absolute NSDate components object,

00:13:58.230 --> 00:14:06.440
what you have is various components
like June and 8 and 4.30 p.m.

00:14:07.080 --> 00:14:11.610
In that NSDate components object,
which are representing exact values.

00:14:11.620 --> 00:14:16.810
But NSDate components as a
class is also used to represent

00:14:16.820 --> 00:14:19.060
relative amounts of time.

00:14:19.060 --> 00:14:21.380
For example,

00:14:21.850 --> 00:14:25.110
As I give here,
if a date component's object

00:14:25.360 --> 00:14:30.860
has a value of 4 for the hour
and 15 for the minute component,

00:14:30.990 --> 00:14:35.560
it could be representing either
4:15 in the morning or it could be

00:14:35.560 --> 00:14:42.400
representing 4 hours and 15 minutes
worth of time in the relative sense.

00:14:42.860 --> 00:14:44.800
Then we have Ennis time zone.

00:14:45.120 --> 00:14:48.330
Well, the Ennis time zone
represents a time zone.

00:14:48.370 --> 00:14:50.000
No surprise there.

00:14:50.090 --> 00:14:55.940
Time zone is a geopolitical region which
defines a set of rules for how the local

00:14:55.940 --> 00:15:03.300
time in that region of the Earth is
calculated from the reference time zone,

00:15:03.300 --> 00:15:04.940
GMT or UTC.

00:15:05.680 --> 00:15:09.160
Usually this comes in the
form of some number of hours

00:15:09.160 --> 00:15:11.550
and minutes offset from GMT.

00:15:11.620 --> 00:15:16.590
That is,
you take GMT and you subtract or add

00:15:16.610 --> 00:15:21.590
some number of hours and minutes in order
to compute the local time in an area.

00:15:22.190 --> 00:15:27.100
NS time zone is also the object that
knows when things like daylight saving

00:15:27.100 --> 00:15:29.900
time or summertime transitions occur.

00:15:29.910 --> 00:15:35.240
So some countries change what the
offset is for their local time

00:15:35.550 --> 00:15:37.620
at various times of the year.

00:15:37.740 --> 00:15:40.510
And these are usually
for the reasons of like,

00:15:40.580 --> 00:15:44.550
you know,
extend the number of hours of daylight

00:15:44.650 --> 00:15:49.610
in the evening during the summer,
for example.

00:15:49.800 --> 00:15:55.110
But all these things are are a
transition from one offset from

00:15:55.110 --> 00:15:57.200
GMT to a different offset from GMT.

00:15:57.200 --> 00:16:04.140
The interesting thing about time zones
is also that governments control and they

00:16:04.210 --> 00:16:09.150
change the rules of their time zones that
affect their countries from time to time.

00:16:09.150 --> 00:16:12.510
So something that you get as a result,
say in one year,

00:16:12.510 --> 00:16:16.890
you might get a different result
for the same input information

00:16:16.890 --> 00:16:22.500
in another year because maybe the
government that affects the time zone,

00:16:22.500 --> 00:16:25.910
controls the time zone,
affected by your calculation.

00:16:25.910 --> 00:16:28.900
Maybe the government has changed
the rules in the meantime.

00:16:31.220 --> 00:16:36.200
So let's go on to
Calendrical Calculations.

00:16:36.200 --> 00:16:39.270
Well,
there are basically four most common

00:16:39.270 --> 00:16:43.690
NS Calendar operations that are
these Calendrical Calculations.

00:16:43.820 --> 00:16:46.630
The first is Components from Date.

00:16:46.820 --> 00:16:51.700
This is a method where you give
it a date and you give it the

00:16:51.700 --> 00:16:56.940
components that you want to extract,
say hours and minutes and seconds or

00:16:57.290 --> 00:16:59.200
days and months or whatever it is.

00:16:59.200 --> 00:17:04.190
And it will extract those
for that particular calendar.

00:17:04.210 --> 00:17:11.200
So basically this is the way you convert
an NSDate to a given set of components,

00:17:11.200 --> 00:17:14.200
a representation of that
date in a given calendar.

00:17:14.200 --> 00:17:17.200
The inverse operation
is Date from Components.

00:17:17.200 --> 00:17:22.530
So given a set of components,
assume those components refer

00:17:22.530 --> 00:17:28.130
to values in the given calendar
and give me an NSDate for that.

00:17:28.200 --> 00:17:28.200
So this is a very simple way to
convert a NSDate from a given calendar.

00:17:28.200 --> 00:17:28.200
The inverse operation
is Date from Components.

00:17:28.200 --> 00:17:28.200
So given a set of components,
assume those components refer

00:17:28.200 --> 00:17:28.200
to values in the given calendar
and give me an NSDate for that.

00:17:28.200 --> 00:17:28.450
The inverse operation
is Date from Components.

00:17:28.450 --> 00:17:28.750
So given a set of components,
assume those components refer

00:17:28.750 --> 00:17:29.200
to values in the given calendar
and give me an NSDate for that.

00:17:30.050 --> 00:17:34.600
Then we have date by adding
components to date options.

00:17:34.740 --> 00:17:38.240
This is the kind of method you would
use to answer the question I had

00:17:38.240 --> 00:17:40.760
near the beginning of the talk.

00:17:40.930 --> 00:17:43.160
What is the day 90 days from today?

00:17:43.350 --> 00:17:46.800
So given an original date
and a set of components,

00:17:46.800 --> 00:17:52.270
which in this case would just be 90 days,
what is the resulting date?

00:17:53.720 --> 00:17:59.200
Then we have finally the components
from date to date options method.

00:17:59.310 --> 00:18:03.640
So this is the calculation I would
use in order to compute the question,

00:18:03.880 --> 00:18:06.090
how many weeks is it
until my next birthday?

00:18:06.670 --> 00:18:12.870
So given the two date parameters here and
the component or components of interest,

00:18:12.870 --> 00:18:18.620
tell me how many of those components
exist between those two dates.

00:18:18.620 --> 00:18:21.760
And of course,
NS Calendar also has several

00:18:21.850 --> 00:18:23.580
other kinds of operations,
but I'm not going to go into that.

00:18:23.600 --> 00:18:27.830
not going to be going into
those in this talk today.

00:18:28.440 --> 00:18:32.210
Now,
there are basically two general classes

00:18:32.420 --> 00:18:37.800
of trouble that people can run into
when doing calendrical calculations.

00:18:37.800 --> 00:18:41.440
The first is that
calendars are irregular.

00:18:41.440 --> 00:18:44.580
They're human constructs
that evolved over,

00:18:44.580 --> 00:18:47.120
you know, millennia.

00:18:47.120 --> 00:18:50.600
And so, you know,
in doing the calculations,

00:18:50.600 --> 00:18:54.460
you can run into issues involving
the various irregularities.

00:18:54.460 --> 00:18:58.410
And I'll be getting to
examples of these in a minute.

00:18:58.920 --> 00:19:05.040
The other class of trouble is that a
set of components can be ambiguous.

00:19:05.160 --> 00:19:08.490
And there are two
sub-varieties of ambiguities.

00:19:08.620 --> 00:19:12.900
One is that a set of components
can specify non-existent dates,

00:19:13.060 --> 00:19:19.290
and the other is that a set of components
can specify potentially multiple dates.

00:19:19.410 --> 00:19:24.520
That is,
it's ambiguous which of many possible

00:19:24.570 --> 00:19:26.700
dates a set of components refers to.

00:19:27.350 --> 00:19:32.200
So let's go into looking at
some examples of irregularities.

00:19:32.730 --> 00:19:36.560
Well, the leap day in the Gregorian
calendar is a good example,

00:19:36.560 --> 00:19:40.010
very simple example of an irregularity.

00:19:40.130 --> 00:19:44.740
The leap day in the Gregorian calendar
is the 29th of February and it's

00:19:44.880 --> 00:19:47.000
inserted about every four years.

00:19:47.100 --> 00:19:51.630
In years which aren't leap years,
there is no 29th of February,

00:19:51.630 --> 00:19:54.240
but sometimes there
is a 29th of February,

00:19:54.240 --> 00:19:57.470
so this is a kind of irregularity.

00:19:58.510 --> 00:20:03.440
Time zone transitions are also
a rich source of irregularities.

00:20:03.440 --> 00:20:08.400
When you have what are often
called forward transitions,

00:20:08.620 --> 00:20:13.730
that is a shift in the offset
from the reference time zone,

00:20:13.810 --> 00:20:17.090
GMT, that occurs,
that causes time to jump forward

00:20:17.090 --> 00:20:22.620
suddenly in a particular locale,
then you have a forward transition.

00:20:22.620 --> 00:20:27.890
And that causes an hour or
potentially more hours to be skipped.

00:20:28.150 --> 00:20:30.300
Usually it's just an hour.

00:20:30.890 --> 00:20:33.640
You can also have the reverse,
which is a backward transition.

00:20:33.640 --> 00:20:37.800
That is, time can appear to
suddenly fall backwards,

00:20:37.800 --> 00:20:43.640
and what that causes is an
hour or hours to be repeated,

00:20:43.670 --> 00:20:46.090
to occur twice.

00:20:47.340 --> 00:20:50.280
You can also have something
which is much more rare but

00:20:50.390 --> 00:20:55.090
also still a little interesting,
which is a dateline transition.

00:20:55.250 --> 00:20:58.000
The reason I mention this in this
particular talk is that one of these

00:20:58.000 --> 00:21:00.200
is occurring at the end of this year.

00:21:00.200 --> 00:21:05.000
What's going to happen is that Samoa
is moving itself from one side of the

00:21:05.000 --> 00:21:08.190
international dateline to the other side.

00:21:08.190 --> 00:21:13.200
Now all it's doing is
changing its time zone rules.

00:21:13.440 --> 00:21:18.200
But the net effect is that it's going to
be moving from sort of seeing the end of

00:21:18.330 --> 00:21:23.670
the day to seeing the beginning of the
day because it will be on the western

00:21:23.710 --> 00:21:26.200
side of the international dateline.

00:21:26.400 --> 00:21:31.420
The net effect of this change is
that basically 24 hours are going

00:21:31.420 --> 00:21:37.200
to be skipped in Samoa and so there
will be no 30th of December in Samoa.

00:21:37.200 --> 00:21:42.200
The 29th of December will end and
suddenly it will be the 31st of December.

00:21:44.860 --> 00:21:48.680
The Hebrew calendar is another
good source of irregularities.

00:21:48.800 --> 00:21:50.780
Not to pick on it, of course.

00:21:51.440 --> 00:21:56.470
Some months in the Hebrew calendar
have 29 days in some years,

00:21:56.820 --> 00:21:58.800
and in other years they have 30 days.

00:21:58.800 --> 00:22:02.970
And of course there are rules
that determine which is which,

00:22:02.980 --> 00:22:06.420
but some of the months have
different number of days

00:22:06.520 --> 00:22:08.790
depending on what year it is.

00:22:09.430 --> 00:22:15.440
In the Hebrew calendar,
the year has either 12 or 13 months.

00:22:15.520 --> 00:22:18.300
In a year with 13 months,
that's a leap year.

00:22:18.480 --> 00:22:24.080
That is, they insert a leap month
rather than simply a leap day.

00:22:24.470 --> 00:22:27.230
So in the Hebrew calendar,
the months are numbered

00:22:27.400 --> 00:22:30.280
from 1 through 13.

00:22:30.280 --> 00:22:33.540
And in a leap year,
that is a 13-month year,

00:22:33.540 --> 00:22:37.880
I think that's sometimes
called a gravid year.

00:22:37.880 --> 00:22:38.560
I'm not sure.

00:22:38.560 --> 00:22:43.410
But you have months
numbered 1 through 13.

00:22:43.410 --> 00:22:49.120
But in the 12-year month,
you don't have a month 7.

00:22:49.120 --> 00:22:52.290
That is,
that middle month in the year is missing.

00:22:52.300 --> 00:22:55.720
And the months go from
month 6 suddenly to month 8,

00:22:55.720 --> 00:22:59.700
at least from the point of view of when
you're doing calendrical calculations.

00:22:59.700 --> 00:23:03.820
The Japanese imperial calendar
is also an interesting case.

00:23:03.820 --> 00:23:07.820
This is a calendar which is the
same as the Gregorian calendar.

00:23:07.820 --> 00:23:10.970
That it has, you know,
12 months and has January and

00:23:10.970 --> 00:23:12.220
February and so on.

00:23:12.220 --> 00:23:15.420
Of course, you know,
they call it different things in Japan.

00:23:15.500 --> 00:23:19.380
But the year numbering
is what's different.

00:23:19.480 --> 00:23:24.460
When, basically the year numbering
follows the reign of an emperor.

00:23:24.640 --> 00:23:27.750
When a new emperor ascends the throne,

00:23:28.120 --> 00:23:33.500
That becomes year number one,
and then year two follows that and so on.

00:23:33.600 --> 00:23:37.260
And then when the next
emperor ascends the throne,

00:23:37.260 --> 00:23:40.930
that resets the numbering and it
becomes year number one again.

00:23:41.030 --> 00:23:46.080
In each of these periods of an
emperor's reign is what's called an

00:23:46.120 --> 00:23:49.490
era in the Japanese imperial calendar.

00:23:50.560 --> 00:23:56.570
So what happened, for example, back at,
well in this case, the end of 1988,

00:23:56.570 --> 00:24:01.620
is that we had the 31st of
December in the era Shoah,

00:24:01.620 --> 00:24:04.570
the 63rd year.

00:24:05.450 --> 00:24:07.450
That was followed by
the first of January,

00:24:07.560 --> 00:24:11.000
the New Year's Day, in Showa 64.

00:24:11.210 --> 00:24:14.500
Of course, you know,
I'm writing Showa in English so

00:24:14.500 --> 00:24:18.400
I can remember to read it properly
here when I'm giving the talk,

00:24:18.400 --> 00:24:21.750
but of course it's written
differently in Japanese.

00:24:21.880 --> 00:24:26.020
So what you see here is the year changed,
that is, began a new year,

00:24:26.020 --> 00:24:31.300
and the number went from 63 to 64,
just as in the Gregorian calendar.

00:24:31.410 --> 00:24:34.000
Well, time passed.

00:24:34.440 --> 00:24:39.400
And we arrive at the 7th
of January in Shoa 64.

00:24:39.400 --> 00:24:42.910
And something sad happened.

00:24:43.080 --> 00:24:46.640
And the next day,
there was a new emperor.

00:24:46.680 --> 00:24:50.610
A new emperor had to ascend the throne,
and so,

00:24:51.240 --> 00:24:55.190
The 8th of January was
in the year Heisei I.

00:24:55.200 --> 00:24:59.030
That is, a new era began because
there was a new emperor.

00:24:59.090 --> 00:25:00.540
And it was, again, year one.

00:25:00.570 --> 00:25:06.200
So what this is showing here is
that not only do the year numbers

00:25:06.200 --> 00:25:11.320
change in the Japanese imperial
calendar at the beginning of the year,

00:25:11.320 --> 00:25:15.650
January 1st,
they can also change at any time during

00:25:15.650 --> 00:25:19.960
the year if a new emperor is needed,
so to speak.

00:25:21.140 --> 00:25:26.790
And so, obviously, in this kind of case,
you can't assume that the

00:25:27.050 --> 00:25:30.510
number of a year is only going
to change on January 1st,

00:25:30.510 --> 00:25:32.220
at the beginning of the year.

00:25:32.220 --> 00:25:35.650
It can change at any time,
and of course that's

00:25:35.650 --> 00:25:40.500
unpredictable in the future,
when that's going to happen.

00:25:41.400 --> 00:25:44.920
So, well, enough of the examples and
some of the abstractions.

00:25:44.920 --> 00:25:48.420
Let's look at a more concrete
case and get into some code.

00:25:48.430 --> 00:25:51.240
So what I'm going to do
is throughout this talk,

00:25:51.330 --> 00:25:54.980
I'm going to have this running
example of advancing by days.

00:26:11.820 --> 00:26:11.820
So, given a starting date,
I'm going to have a loop,

00:26:11.820 --> 00:26:11.820
and while some condition remains true,
I'm going to perform some

00:26:11.820 --> 00:26:11.820
operation on my date,
my starting date,

00:26:11.820 --> 00:26:11.820
and then I want to advance
that date to the next day and

00:26:12.110 --> 00:26:15.440
Perform the operation
again and so on in a loop.

00:26:15.540 --> 00:26:20.240
And I want my date to
remain at the same time,

00:26:20.280 --> 00:26:22.710
time of,
whatever its original time of day is,

00:26:22.760 --> 00:26:28.190
I want it to remain at that time as
I advance from day to day to day.

00:26:28.880 --> 00:26:29.820
So what does this look like?

00:26:29.900 --> 00:26:31.640
Well, this is fairly straightforward.

00:26:31.760 --> 00:26:34.040
I, you know, start with my starting date.

00:26:34.040 --> 00:26:38.230
In this case, I'm using the date with
string method to parse a date.

00:26:38.330 --> 00:26:39.910
Nothing fancy about that.

00:26:40.020 --> 00:26:42.990
And you see I'm starting
with January 1st,

00:26:42.990 --> 00:26:45.110
2011 at midnight.

00:26:45.340 --> 00:26:49.780
So the loop, you know,
performs its operation

00:26:49.780 --> 00:26:51.500
while the condition is true.

00:26:51.610 --> 00:26:54.290
And at the bottom of the loop,
I need to advance the

00:26:54.600 --> 00:26:56.460
date to the next day.

00:26:56.830 --> 00:26:58.330
So how do we do this?

00:26:58.430 --> 00:27:03.410
Well, when somebody who is unfamiliar
with calendrical calculations,

00:27:03.410 --> 00:27:06.610
so we say,
usually goes to do something like this,

00:27:06.680 --> 00:27:10.320
what happens is that this number
appears in their source code,

00:27:10.350 --> 00:27:11.940
or a number very much like it.

00:27:12.170 --> 00:27:16.790
86,400 is the number of seconds in a day.

00:27:17.510 --> 00:27:19.560
So what are they doing with this number?

00:27:19.560 --> 00:27:23.420
Well, they're probably calling
date by adding time interval.

00:27:23.420 --> 00:27:27.200
And what that does is it takes a
number of seconds and an original date,

00:27:27.200 --> 00:27:31.680
of course, the receiving expression here,
date, and it returns the new date,

00:27:31.680 --> 00:27:35.760
which is 86,400 seconds in the future.

00:27:36.210 --> 00:27:39.100
Well,
what happens when they run the code?

00:27:39.290 --> 00:27:46.460
Well, the first of January at midnight
plus 86,400 seconds becomes the

00:27:46.460 --> 00:27:48.260
second of January at midnight.

00:27:48.390 --> 00:27:51.370
And the second of January becomes
the third of January and so on.

00:27:51.380 --> 00:27:55.570
But eventually,
at least here in the U.S., in those

00:27:55.570 --> 00:28:01.030
parts of the country that recognize
and implement time zone transition,

00:28:01.030 --> 00:28:04.420
we hit the forward time zone transition.

00:28:04.440 --> 00:28:07.590
And so at the bottom of
one iteration of the loop,

00:28:07.590 --> 00:28:13.340
we have the 13th of March at midnight
and we add our 86,400 seconds.

00:28:13.340 --> 00:28:17.870
And we end up getting the
14th of March at 1 a.m.

00:28:17.880 --> 00:28:20.440
And then, of course, the loop continues.

00:28:21.360 --> 00:28:25.600
And we update that time
by adding 86,400 seconds.

00:28:25.600 --> 00:28:28.970
And the next iteration of
the loop operates on the

00:28:29.020 --> 00:28:31.720
time 15th of March at 1 a.m.

00:28:34.040 --> 00:28:36.380
Well, what happened here?

00:28:36.470 --> 00:28:43.230
Well, on the 13th of March,
there were actually only 23 hours in

00:28:43.230 --> 00:28:48.130
that day because there was a forward time
zone transition and in the United States,

00:28:48.200 --> 00:28:49.100
the 2:00 a.m.

00:28:49.100 --> 00:28:51.170
hour was skipped.

00:28:51.420 --> 00:28:56.350
So by adding 86,400 seconds, of course,
we added too much and we overshot

00:28:56.580 --> 00:28:59.590
and we have fallen off of midnight.

00:28:59.850 --> 00:29:04.080
Well instead, what we should do is what
we're really wanting,

00:29:04.150 --> 00:29:05.780
you know, we should say what we mean.

00:29:05.940 --> 00:29:07.780
We should really just add one day.

00:29:07.950 --> 00:29:10.700
Use the Calendrical
Calculation operations.

00:29:10.700 --> 00:29:15.240
So, I get a calendar from somewhere
and I need a temporary

00:29:15.240 --> 00:29:19.840
NSDate components object
initialized with the value one day.

00:29:19.930 --> 00:29:24.700
And so what I do is I create a temporary
one and I set its day property to one.

00:29:24.700 --> 00:29:27.480
So, this now represents one day.

00:29:27.680 --> 00:29:31.820
It's a relative kind of
NSDate components object.

00:29:31.920 --> 00:29:34.920
So I have my original date from
somewhere and I have my loop and

00:29:34.920 --> 00:29:37.550
it's performing its operation.

00:29:37.750 --> 00:29:40.650
And at the bottom of the loop,
I call this method date

00:29:40.760 --> 00:29:42.590
by adding components.

00:29:42.610 --> 00:29:48.170
I'm adding that date components object,
which represents one day, to my date,

00:29:48.280 --> 00:29:52.300
and I'm getting the date for
the next iteration of the loop.

00:29:52.450 --> 00:29:55.100
Well, what happens when we run this?

00:29:55.280 --> 00:29:58.140
Well, things begin as before.

00:29:58.860 --> 00:30:03.660
January 1st is followed by January 2nd
as far as the loop is concerned.

00:30:03.660 --> 00:30:07.710
January 2nd plus a day is
followed by January 3rd and so on.

00:30:08.060 --> 00:30:10.730
And we get to that troublesome date,
the 13th of March.

00:30:10.730 --> 00:30:14.920
Well, we add one day to that and
because the smaller components,

00:30:15.010 --> 00:30:18.970
smaller than a day, are preserved,
we end up with the result of

00:30:18.970 --> 00:30:22.610
the 14th of March at midnight,
which is exactly what

00:30:22.630 --> 00:30:24.490
we're looking for here.

00:30:24.490 --> 00:30:28.380
And then of course the 14th of
March at midnight plus a day,

00:30:28.380 --> 00:30:31.010
becomes the 15th of
March at midnight and so on.

00:30:31.210 --> 00:30:35.270
So, well, the issue seems to be fixed.

00:30:36.080 --> 00:30:42.190
Well, let's go back to that
second category of trouble,

00:30:42.260 --> 00:30:46.870
the ambiguities within a
given set of components.

00:30:47.840 --> 00:30:53.070
So a given set of
components can be ambiguous,

00:30:53.370 --> 00:30:58.030
A date cannot,
a date with a given specification,

00:30:58.030 --> 00:31:01.860
if you will, may not actually exist.

00:31:01.930 --> 00:31:05.480
So in the Gregorian calendar,
for example, I could say, well,

00:31:05.550 --> 00:31:07.430
37th of June.

00:31:07.530 --> 00:31:13.840
Well, June never has 37 days or more
in the Gregorian calendar,

00:31:13.900 --> 00:31:17.740
so obviously this is a trivial
example of a date which doesn't exist.

00:31:18.120 --> 00:31:22.680
29th of February, as I mentioned earlier,
does not exist in most years.

00:31:22.710 --> 00:31:26.800
And so these are fairly simple
and straightforward examples.

00:31:27.400 --> 00:31:31.700
The other subcategory of trouble,
ambiguity here,

00:31:31.730 --> 00:31:33.740
is that multiple dates may exist.

00:31:33.820 --> 00:31:37.420
So I could have an NSDateComponents
object which represents

00:31:37.740 --> 00:31:41.950
Tuesday at 4:00 in the afternoon,

00:31:42.430 --> 00:31:46.160
Well, of course, every day has a,
or every Tuesday has a

00:31:46.340 --> 00:31:49.510
four in the afternoon,
and there are many of those, so this is,

00:31:49.580 --> 00:31:51.100
again, ambiguous.

00:31:51.100 --> 00:31:53.910
You don't know which particular
Tuesday at four in the

00:31:53.910 --> 00:31:55.860
afternoon you're talking about.

00:31:57.000 --> 00:32:00.670
During a summertime to
standard time transition,

00:32:00.700 --> 00:32:03.760
such as occurs in the fall
here in the United States,

00:32:03.760 --> 00:32:07.100
the hour is repeated
in the early morning.

00:32:07.100 --> 00:32:10.930
So when we fall back from 2:59 a.m.

00:32:10.940 --> 00:32:12.270
back to 2:00 a.m.

00:32:12.390 --> 00:32:17.600
in order to repeat the second hour, well,
that means there's two

00:32:17.600 --> 00:32:21.330
2:15 a.m.s on that day.

00:32:21.400 --> 00:32:27.220
And so if you have a date components
object which specifies 2:15 a.m.

00:32:27.220 --> 00:32:31.860
on that day of a, you know,
reverse time zone transition, well,

00:32:31.860 --> 00:32:35.740
you know, it's ambiguous which
one you're referring to.

00:32:35.740 --> 00:32:39.280
Are you referring to the
first instance of 2:15 a.m.

00:32:39.280 --> 00:32:40.900
or the second instance?

00:32:42.260 --> 00:32:47.640
So let's look a little bit more at
this case of non-existent dates.

00:32:47.790 --> 00:32:55.600
So the nominal or best result of calendar
arithmetic may not actually exist.

00:32:55.900 --> 00:32:59.390
In the case of daylight saving
time forward transition,

00:32:59.400 --> 00:33:01.910
where time appears to
jump forward suddenly,

00:33:01.910 --> 00:33:09.560
at least in the United States,
1:59:59 becomes, one second later,

00:33:09.690 --> 00:33:10.300
3:00 a.m.

00:33:10.300 --> 00:33:11.040
suddenly.

00:33:11.080 --> 00:33:12.800
There is no 2:00 a.m.

00:33:12.830 --> 00:33:18.800
So it really doesn't make sense to
talk about times like 2:20 in the

00:33:18.800 --> 00:33:21.800
morning on the day of the transition.

00:33:21.800 --> 00:33:26.800
So if we do some calendar arithmetic,
as in that code I was just looking at,

00:33:26.800 --> 00:33:31.770
we have a date, which is the day before
the transition at 2:20 a.m.

00:33:31.870 --> 00:33:36.630
We add one day to that.

00:33:36.630 --> 00:33:36.630
Well, we're going to get a result.

00:33:36.940 --> 00:33:41.800
The result which is on the day of
the transition at some mystery hour.

00:33:41.800 --> 00:33:48.730
There is no 2:20 for the result to be at,
but we're going to get something.

00:33:48.870 --> 00:33:52.520
Now I'm not going to explain what
we're going to get exactly because

00:33:52.600 --> 00:33:54.720
it's not really pertinent to my talk.

00:33:54.720 --> 00:34:00.280
The important thing is that you get
some sort of undefined mystery result.

00:34:01.300 --> 00:34:05.490
Well, let's return to the
advancing by days example.

00:34:05.490 --> 00:34:10.780
And at this point you might think, uh-oh,
well, what's going on?

00:34:10.780 --> 00:34:13.660
I thought we had solved that problem.

00:34:13.780 --> 00:34:18.800
Well, it turns out that in Brazil,
as at least one case in point,

00:34:18.800 --> 00:34:22.200
time zone transitions occur at midnight.

00:34:22.200 --> 00:34:28.260
So 11.59 and 59 seconds at the
end of one day becomes 1 a.m.

00:34:28.360 --> 00:34:31.170
the next day then, once a day.

00:34:31.200 --> 00:34:32.460
a second later.

00:34:32.490 --> 00:34:34.790
And so there is no midnight.

00:34:35.460 --> 00:34:39.350
So for our loop,
which is trying to loop and

00:34:39.390 --> 00:34:44.070
keep the time component of
that NSDate object at midnight,

00:34:44.080 --> 00:34:45.390
there's going to be trouble.

00:34:45.420 --> 00:34:48.410
At some point,
the loop is going to experience

00:34:48.410 --> 00:34:53.400
the case where it has a date of
the day before the transition.

00:34:53.400 --> 00:34:57.120
It's going to add one day to that,
and it's going to get a day

00:34:57.120 --> 00:35:02.660
of the transition at the
mystery hour as a result.

00:35:02.990 --> 00:35:06.200
Well, the loop is going to continue,
and here's where the

00:35:06.200 --> 00:35:08.520
trouble really comes in.

00:35:09.200 --> 00:35:13.730
The day of the transition at the
mystery hour is going to have one

00:35:13.730 --> 00:35:17.600
day added to it and that is going
to result in a time which is the

00:35:17.600 --> 00:35:22.670
day of the day after the transition,
sorry, but also at the mystery hour.

00:35:22.780 --> 00:35:24.860
That is the hour,
the mystery hour has been

00:35:24.860 --> 00:35:30.460
preserved and now our loop
again has fallen off midnight.

00:35:30.540 --> 00:35:34.080
Well, if you notice,
this is just like what happened when

00:35:34.080 --> 00:35:38.510
we added one month to the 30th of
January at the beginning of the talk

00:35:38.540 --> 00:35:40.480
and then we added another month.

00:35:40.700 --> 00:35:46.160
That is the day fell off of the 30th
of the month and became the 28th of the

00:35:46.160 --> 00:35:49.030
month and we ended up with March 28th.

00:35:49.540 --> 00:35:53.050
So what can we do about
this kind of case?

00:35:53.240 --> 00:35:55.400
What if no midnight exists?

00:35:55.580 --> 00:35:59.800
Well, in our previous code, as I said,
we were adding one day to our

00:35:59.800 --> 00:36:02.730
current working date within
the loop to get the next date.

00:36:02.780 --> 00:36:06.200
But instead,
we can add an increasing number

00:36:06.200 --> 00:36:11.020
of days to the original date and
not change the original date.

00:36:11.030 --> 00:36:14.400
We can just keep adding an
increasing number of days in

00:36:14.400 --> 00:36:18.500
order to compute our working date
for each iteration of the loop.

00:36:20.210 --> 00:36:21.430
So what does this look like?

00:36:21.710 --> 00:36:26.590
Well, we get a calendar from somewhere,
we have an original date from somewhere,

00:36:26.610 --> 00:36:30.460
we still need a temporary
NSDateComponents object.

00:36:30.640 --> 00:36:35.940
I introduce a new variable, an integer,
the number of days.

00:36:35.940 --> 00:36:37.300
I initialize it to zero.

00:36:37.300 --> 00:36:43.710
I begin by initializing my
working date to the original date

00:36:43.710 --> 00:36:46.060
and my loop does its operation.

00:36:46.060 --> 00:36:50.400
Then what I do is I increment
the number of days and then I set

00:36:50.490 --> 00:36:54.720
this increased number of days
into the date components object.

00:36:54.720 --> 00:36:58.400
On each iteration of the loop,
I'm modifying the date

00:36:58.460 --> 00:37:00.560
components operation,
having an increased number of days.

00:37:00.680 --> 00:37:09.150
On each iteration of the loop,
I'm modifying the date

00:37:09.150 --> 00:37:19.300
components operation,
having an increased number of days.

00:37:19.300 --> 00:37:19.300
On each iteration of the loop,
I'm modifying the date

00:37:19.300 --> 00:37:19.300
components operation,
having an increased number of days.

00:37:21.160 --> 00:37:23.590
Well, now what happens in Brazil?

00:37:23.690 --> 00:37:25.700
Well,
eventually we get to the point where

00:37:25.700 --> 00:37:28.950
we're adding some number of days,
and I call that N,

00:37:28.990 --> 00:37:33.440
where now our working date
in the loop is the day before

00:37:33.440 --> 00:37:36.260
the transition at midnight.

00:37:36.520 --> 00:37:39.200
Well, then we add n plus 1 days
in the next iteration,

00:37:39.220 --> 00:37:44.410
and we get a result which is the day
of the transition at the mystery hour.

00:37:44.420 --> 00:37:47.160
But then in the next
iteration of the loop,

00:37:47.240 --> 00:37:51.450
when we add n plus 2 days, we get,
instead of the day after the

00:37:51.450 --> 00:37:54.250
transition at the mystery hour,
we get the day after the

00:37:54.310 --> 00:37:55.650
transition at midnight.

00:37:55.680 --> 00:38:01.020
That is, we have not fallen permanently,
at least as far as the loop is concerned,

00:38:01.020 --> 00:38:02.770
fallen off of midnight.

00:38:02.780 --> 00:38:07.410
We still have that issue where
one of the iterations of the loop

00:38:07.520 --> 00:38:11.920
has to have some sort of mystery
result because there is no midnight,

00:38:11.920 --> 00:38:15.810
but the rest of the loop is not ruined.

00:38:15.820 --> 00:38:19.780
And this is just like when we
added 2 months to the 30th of

00:38:19.780 --> 00:38:24.390
January and got March 30th.

00:38:25.550 --> 00:38:32.570
Well, let me go into a brief sidebar here
and give some another kind of advice,

00:38:32.660 --> 00:38:36.890
and that is to avoid stressing
boundary conditions whenever possible.

00:38:37.000 --> 00:38:39.690
Well, we've seen a few kinds of
boundary conditions here.

00:38:39.700 --> 00:38:46.380
Midnight in Brazil for this particular
example was a boundary condition.

00:38:46.380 --> 00:38:49.050
The end of the year is
a boundary condition.

00:38:49.200 --> 00:38:53.780
And of course, the year one is another
kind of boundary condition.

00:38:54.130 --> 00:38:58.600
So what was problematic in our previous
code example is that the Brazilian time

00:38:58.600 --> 00:39:00.990
zone transition occurred at midnight.

00:39:01.100 --> 00:39:06.400
And so at least one iteration of the
loop could not have a result where it

00:39:06.400 --> 00:39:09.290
was working with the date at midnight.

00:39:09.420 --> 00:39:14.540
Well, other countries,
it's a little more convenient

00:39:14.630 --> 00:39:19.720
for us in that they generally,
other countries transition

00:39:19.720 --> 00:39:20.840
at either 1 a.m.

00:39:20.840 --> 00:39:21.600
or 2 a.m.

00:39:21.600 --> 00:39:24.910
and so they don't, you know,
skip the midnight hour and so that

00:39:24.910 --> 00:39:27.260
would have been more convenient for us.

00:39:27.260 --> 00:39:31.920
But unless you're a Brazilian voter,
you have no chance at all of

00:39:31.920 --> 00:39:36.730
changing what Brazil is doing to
implement its time zone rules.

00:39:36.730 --> 00:39:38.980
And so you have to deal with it.

00:39:39.440 --> 00:39:45.160
And so one better approach is
to use noon instead of midnight.

00:39:45.270 --> 00:39:53.830
Most countries are relatively
sensible and they do not implement

00:39:54.360 --> 00:40:05.370
their time zone changes to
occur in the middle of the day,

00:40:05.450 --> 00:40:08.590
like at noon.

00:40:08.590 --> 00:40:08.590
So instead of trying to stay at
midnight as we advance through our loop,

00:40:08.590 --> 00:40:08.590
if you try to stay at noon and
remain fixed to noon as your,

00:40:08.590 --> 00:40:08.590
you know, don't care time, say,
that would be better.

00:40:09.680 --> 00:40:15.000
The Samoan time zone change of not
skipping the 31st of December is

00:40:15.100 --> 00:40:17.590
also probably a good idea.

00:40:17.730 --> 00:40:20.600
It might seem natural that, well,
they should skip the

00:40:20.600 --> 00:40:21.470
last day of the year.

00:40:21.470 --> 00:40:24.060
If they're going to skip a day,
why not the last day of the year?

00:40:24.060 --> 00:40:27.370
And so December 30th would
be followed by January 1st.

00:40:27.370 --> 00:40:31.550
Well, who knows what problems
that might introduce.

00:40:33.440 --> 00:40:38.500
So instead, they're going to skip
the 30th of January.

00:40:38.500 --> 00:40:43.920
Now, as an aside, I would say, well,
for also a tourism-related

00:40:43.920 --> 00:40:48.310
country like Samoa,
it probably makes sense for them

00:40:48.310 --> 00:40:53.430
not to skip a big party day of
the year like New Year's Eve.

00:40:53.440 --> 00:40:58.810
And so that's probably why they actually
are not skipping the 31st of December.

00:40:59.150 --> 00:41:04.630
Another example that we see
that's problematic is using date

00:41:04.900 --> 00:41:07.000
objects to represent just a time.

00:41:07.000 --> 00:41:10.140
I occasionally have
developers come to me and say,

00:41:10.140 --> 00:41:13.990
"I want to use a date object,
but I just want it to represent a time.

00:41:14.000 --> 00:41:17.630
I want it to represent, say,
4:15 in the morning,

00:41:17.770 --> 00:41:20.000
and I don't care what the date is.

00:41:20.000 --> 00:41:23.430
I just want, for some reason,
to use an end of state,

00:41:23.430 --> 00:41:28.010
but I just want the time in there
to be interesting." So what they

00:41:28.050 --> 00:41:33.150
do is they use the year one,
the month one, and the day one,

00:41:33.150 --> 00:41:35.000
plus their desired time.

00:41:35.000 --> 00:41:44.430
So the year 1-1-1, or the date 1-1-1,
is their "don't care" time.

00:41:44.980 --> 00:41:48.780
Well, a better approach is, well,
first you could use

00:41:48.780 --> 00:41:54.200
NSDate components instead of NSDate,
but another better approach is to

00:41:54.200 --> 00:41:58.620
use the date of the time interval
zero in whatever calendar you're

00:41:58.620 --> 00:42:00.430
working with plus the time.

00:42:00.450 --> 00:42:04.940
So rather than using 111,
use the Calendrical Calculation

00:42:04.940 --> 00:42:10.650
operations to figure out what the date
of the time interval zero is and then,

00:42:10.650 --> 00:42:13.570
you know, add your time to that.

00:42:14.180 --> 00:42:18.320
So let's get back to
Calendrical Calculations.

00:42:18.500 --> 00:42:22.620
So let me talk a bit about
week-based calendars.

00:42:22.710 --> 00:42:25.630
A week, of course,
is a cyclic period of seven days,

00:42:25.630 --> 00:42:28.990
which are called the weekdays,
and one week follows the next.

00:42:29.000 --> 00:42:33.990
Well, any calendar can be interpreted
in a week-based fashion.

00:42:34.000 --> 00:42:39.180
And this can be convenient when doing
calculations involving weeks or weekdays.

00:42:39.190 --> 00:42:42.000
Like if you're doing calculations
involving Wednesdays,

00:42:42.000 --> 00:42:48.990
it can be convenient to think of a
calendar in a week-based interpretation.

00:42:48.990 --> 00:42:53.980
Well, so why is it that it is convenient?

00:42:54.070 --> 00:42:57.000
Well, how can you specify any given day?

00:42:57.000 --> 00:43:03.240
Well, you can specify the year and then
a day number within the year.

00:43:03.470 --> 00:43:08.780
And so today might be
the 159th day of 2011.

00:43:09.970 --> 00:43:12.180
More typically what people
do is they specify the year

00:43:12.180 --> 00:43:13.580
and the month of the day.

00:43:13.580 --> 00:43:18.790
And so today is the eighth day
of the sixth month of 2011.

00:43:19.260 --> 00:43:22.600
But you can also use a
week-based interpretation.

00:43:22.620 --> 00:43:27.240
That is,
you can use what is the week-based year,

00:43:27.240 --> 00:43:30.290
the week number within a year,
and the weekday.

00:43:30.300 --> 00:43:36.690
So today is Wednesday in
the 23rd week of 2011.

00:43:37.330 --> 00:43:42.460
This is convenient because normally then
what is changing is that week number,

00:43:42.460 --> 00:43:48.010
23, but the Wednesday component
of that triplet generally is

00:43:48.070 --> 00:43:53.090
remaining constant if you're doing
usually week-based calculations.

00:43:54.730 --> 00:43:57.450
So what is a week-based calendar?

00:43:57.590 --> 00:43:58.840
How are they really defined?

00:43:58.840 --> 00:44:03.380
Well, a week-based calendar always
has an integral number of weeks.

00:44:03.500 --> 00:44:05.720
Now the regular calendar, of course,
does not have an

00:44:05.720 --> 00:44:07.430
integral number of weeks.

00:44:07.430 --> 00:44:11.900
So obviously the week-based calendar
is not going to be quite the same

00:44:11.900 --> 00:44:15.960
somehow as the regular calendar,
the ordinary calendar.

00:44:16.260 --> 00:44:19.750
Well, two properties define
a week-based calendar.

00:44:19.780 --> 00:44:23.810
An NS calendar, the class,
has two properties on it that you can

00:44:23.810 --> 00:44:28.830
change to affect both of these if you
want to use it in a week-based fashion.

00:44:28.830 --> 00:44:34.270
The first property is what weekday
is the beginning of the week.

00:44:34.470 --> 00:44:37.000
And of course,
since a week-based calendar

00:44:37.000 --> 00:44:41.000
interpretation always has
an integral number of weeks,

00:44:41.000 --> 00:44:44.040
it turns out then that of
course that the year always will

00:44:44.040 --> 00:44:45.980
begin on that weekday as well.

00:44:46.050 --> 00:44:50.780
So for example, we might say Monday is
the first day of the week.

00:44:50.950 --> 00:44:53.550
The second property is
a little more complex.

00:44:53.610 --> 00:44:57.120
This determines when the
first week of the year is.

00:44:57.270 --> 00:45:02.930
So, as we will see in a second,
you can have, at the end of the year,

00:45:02.940 --> 00:45:07.220
normally you would have a week
which is straddling both part in the

00:45:07.220 --> 00:45:09.900
old year and part in the new year.

00:45:09.930 --> 00:45:14.870
And so you have to decide, well,
which year is that week going to be in?

00:45:15.280 --> 00:45:19.400
And the second property of the minimum
number of days that the week has to

00:45:19.400 --> 00:45:24.490
have in the new year to be considered
in the new year is determined,

00:45:24.490 --> 00:45:26.780
makes that decision for you.

00:45:26.780 --> 00:45:33.270
The ISO 8601 calendar defines one
example of a week-based calendar.

00:45:33.350 --> 00:45:35.240
So this isn't just theoretical.

00:45:35.270 --> 00:45:40.770
There's an international standard which
uses and defines a week-based calendar.

00:45:40.780 --> 00:45:45.060
Well, what happened,
what was an example of this?

00:45:45.110 --> 00:45:48.010
It's a little easier to
see in graphical form.

00:45:48.120 --> 00:45:51.500
At the end of last year,
what we had was the days,

00:45:51.510 --> 00:45:53.420
something like this.

00:45:53.420 --> 00:45:57.900
And I've drawn the chart
here starting on Saturday.

00:45:58.270 --> 00:46:01.840
So, suppose our first day
of the week is Monday.

00:46:01.940 --> 00:46:07.330
That means December 20th began a week,
and that went through December 26th.

00:46:07.340 --> 00:46:10.700
Well,
there's no particular controversy here.

00:46:11.090 --> 00:46:14.480
This is a week within the year 2010.

00:46:14.790 --> 00:46:19.260
But this week, the next week,
straddles both years.

00:46:19.300 --> 00:46:24.860
And so which year is this
week going to be numbered as?

00:46:24.960 --> 00:46:30.300
All the days in this week have
to be either considered in 2010

00:46:30.710 --> 00:46:34.810
or in 2011 under a week-based
calendar interpretation.

00:46:35.240 --> 00:46:38.560
Well,
let's suppose that our minimum number

00:46:38.560 --> 00:46:43.860
of days that the week has to have
within the new year property is four.

00:46:43.860 --> 00:46:48.060
Well, this week has two days
within the new year,

00:46:48.060 --> 00:46:52.390
which is less than four,
and so this week wouldn't be

00:46:52.570 --> 00:46:59.520
considered within the new year,
2011, so this week is 2010.

00:46:59.520 --> 00:47:06.340
And the result is then that January 1st
and January 2nd are... numbered,

00:47:06.540 --> 00:47:12.680
or have a year number of 2010
under a week-based calendar

00:47:12.680 --> 00:47:14.210
interpretation of the calendar.

00:47:14.240 --> 00:47:17.360
Well,
then the next week begins on January,

00:47:17.360 --> 00:47:21.240
Monday, January 3rd, and of course,
there's no particular controversy here.

00:47:21.240 --> 00:47:26.970
This week entirely falls within 2011,
and so these days are numbered

00:47:26.970 --> 00:47:29.180
with a year number of 2011.

00:47:29.240 --> 00:47:31.240
Now,
if we go back here to this middle week,

00:47:31.240 --> 00:47:35.240
suppose I said the minimum
number of days in the first

00:47:35.240 --> 00:47:35.240
year of the calendar is a year.

00:47:35.770 --> 00:47:38.730
The first week was one.

00:47:39.190 --> 00:47:43.530
So this week has two
days in the new year,

00:47:43.630 --> 00:47:45.520
and so that's bigger than one.

00:47:45.610 --> 00:47:49.100
And so under that kind of rule,
this week would be entirely

00:47:49.100 --> 00:47:52.440
assigned to the year 2011.

00:47:52.550 --> 00:47:58.630
And so the week-based calendar year
2011 would be beginning Monday,

00:47:58.630 --> 00:48:00.470
December 27th.

00:48:02.330 --> 00:48:04.430
Well,
where do people get into trouble when

00:48:04.430 --> 00:48:06.700
dealing with week-based calendars?

00:48:07.030 --> 00:48:12.580
Well, as I've just been talking about,
the year number for days in a week-based

00:48:12.710 --> 00:48:18.210
calendar interpretation may not be the
same year number as those days under

00:48:18.210 --> 00:48:20.700
the ordinary calendar interpretation.

00:48:20.700 --> 00:48:25.310
It might be different
for some number of weeks,

00:48:25.310 --> 00:48:29.100
a few days on either
side of the new year,

00:48:29.400 --> 00:48:31.380
those two numbers.

00:48:31.380 --> 00:48:31.380
Sorry.

00:48:32.240 --> 00:48:36.980
So you must not mix the ordinary
year number in with your week-based

00:48:36.980 --> 00:48:40.410
calculation or week-based components.

00:48:40.420 --> 00:48:43.540
And similarly,
you must not mix the week-based year

00:48:43.540 --> 00:48:47.390
number in with your ordinary components.

00:48:47.590 --> 00:48:50.600
And this can also cause ambiguity.

00:48:50.720 --> 00:48:56.280
For example,
there is no 2nd of January in 2011,

00:48:56.380 --> 00:49:02.140
where 2011 here is the
week-based calendar year number,

00:49:02.270 --> 00:49:04.330
as in ISO 8601.

00:49:04.340 --> 00:49:10.130
For example, in the ordinary calendar,
the 2nd of January 2011 is

00:49:10.130 --> 00:49:16.440
actually the 7th day of the 52nd
week of 2010 in the ISO calendar.

00:49:18.320 --> 00:49:23.490
If instead I was saying 2011 trying
to mean the week-based calendar year,

00:49:24.080 --> 00:49:26.430
well, there is no such day.

00:49:26.510 --> 00:49:32.370
That particular day that I'm trying
to specify is actually the first day

00:49:32.590 --> 00:49:36.200
of the first week of the year 2012.

00:49:36.200 --> 00:49:40.740
And so in 2011 in the ISO calendar,
there is no second of January.

00:49:40.740 --> 00:49:42.370
So it doesn't make sense.

00:49:42.370 --> 00:49:44.060
That's why it's in quotes.

00:49:44.380 --> 00:49:52.110
There is no second of January 2011 where
the 2011 is a week-based calendar year.

00:49:52.650 --> 00:49:55.640
Well,
to help with week-based calculations,

00:49:55.680 --> 00:50:05.590
we've added some new API in ISO 5, IOS 5,
and Mac OS X 10.7.

00:50:05.670 --> 00:50:08.840
We've added some new
calendar component constants.

00:50:09.010 --> 00:50:11.400
Well,
the existing calendar component constant,

00:50:11.420 --> 00:50:15.080
NSYearCalendarUnit,
always specifies now the

00:50:15.080 --> 00:50:17.170
ordinary calendar year.

00:50:17.280 --> 00:50:19.210
and we've added some new constants.

00:50:19.370 --> 00:50:22.170
The first is the week
of year calendar unit.

00:50:22.230 --> 00:50:27.200
So now you can talk explicitly in terms
of what is the week number of the year.

00:50:27.440 --> 00:50:31.960
And similarly, we've added a week of
month calendar unit.

00:50:32.080 --> 00:50:34.900
Generally,
in many calculations I should say,

00:50:34.900 --> 00:50:38.200
not generally, but in many calculations
these are actually the same.

00:50:38.430 --> 00:50:44.630
There's no particular difference,
but sometimes the, which one you specify

00:50:44.630 --> 00:50:46.700
is actually crucial.

00:50:47.670 --> 00:50:50.950
But most importantly,
we added then an NSYear for

00:50:50.950 --> 00:50:54.870
Week of Year calendar unit,
and this allows you to get and

00:50:54.870 --> 00:50:59.690
work with the week of year year.

00:51:00.250 --> 00:51:07.400
So there's an existing constant,
the NSWeek calendar unit,

00:51:07.490 --> 00:51:10.260
and we discourage that to some extent.

00:51:10.270 --> 00:51:13.790
That is,
it seems preferable to us for you to use

00:51:13.850 --> 00:51:18.860
one of the two new constants when you
can because you are saying what you mean.

00:51:19.100 --> 00:51:21.140
But of course,
if you have to run on older

00:51:21.140 --> 00:51:24.680
versions of the operating system,
then 10.7 or 5.0,

00:51:24.830 --> 00:51:26.000
then you can't use that.

00:51:26.000 --> 00:51:28.320
So we haven't actually deprecated this.

00:51:28.320 --> 00:51:32.220
We just encourage you to say more
explicitly what you mean by using one

00:51:32.220 --> 00:51:34.360
of the new constants when you can.

00:51:36.030 --> 00:51:38.990
So let me go on to date
formatting and parsing.

00:51:38.990 --> 00:51:42.660
There are a couple issues
here that I want to bring up.

00:51:42.750 --> 00:51:47.660
So an NSDate formatter is an object
which knows how to convert dates to

00:51:47.660 --> 00:51:50.140
strings and strings back to dates.

00:51:50.140 --> 00:51:56.180
Usually this is used to do it
in a locale sensitive fashion.

00:51:56.180 --> 00:51:59.140
That is, when you want to present
a date to the user,

00:51:59.300 --> 00:52:03.780
you usually use an NSDate formatter so
that you're presenting something that

00:52:03.880 --> 00:52:05.880
the user will most naturally understand.

00:52:05.900 --> 00:52:07.380
understand.

00:52:07.750 --> 00:52:11.240
Well, the first issue that arises
goes something like this.

00:52:11.370 --> 00:52:14.550
Suppose that the developer writes
this particular code up here

00:52:14.840 --> 00:52:18.400
sometime in the middle of year 2010.

00:52:18.520 --> 00:52:21.400
And so what they've done is they've
created a date formatter and they

00:52:21.400 --> 00:52:23.060
did a bunch of configuration on it.

00:52:23.190 --> 00:52:29.960
Then they set its date format
specification pattern to this YYYMMDD,

00:52:30.060 --> 00:52:35.820
and what they want are strings like year,
month number, and day number.

00:52:37.010 --> 00:52:40.100
Well, this code appears to
work when they run it.

00:52:40.220 --> 00:52:44.380
So, you know,
everything seems happy and the app ships.

00:52:44.960 --> 00:52:50.420
But then time passes and somebody
runs the app on January 1st of

00:52:50.450 --> 00:52:57.670
2011 and the app is now showing,
for some reason, 2010-01-01.

00:52:57.860 --> 00:52:58.900
What's going on?

00:52:58.900 --> 00:53:01.420
There's an off-by-one
problem here because,

00:53:01.500 --> 00:53:05.020
well, obviously 2010 is not
the correct year number,

00:53:05.020 --> 00:53:06.110
2011.

00:53:06.120 --> 00:53:12.570
Well, what's actually going on here
is that all capital YYYY is

00:53:12.580 --> 00:53:15.640
the week-based calendar year.

00:53:15.750 --> 00:53:19.760
So the developer has asked the system
to put the week-based calendar year,

00:53:19.760 --> 00:53:22.970
which can be different from
the ordinary calendar year that

00:53:23.390 --> 00:53:26.880
most users might be expecting,
into their strings.

00:53:26.880 --> 00:53:29.490
And so that's why they
got the 2010 result.

00:53:29.510 --> 00:53:32.730
What the developer wanted to do instead,
and this is, of course,

00:53:32.730 --> 00:53:36.080
admittedly very subtle,
is to use lowercase.

00:53:36.100 --> 00:53:40.730
YYYY and that gives you
the ordinary calendar year.

00:53:41.030 --> 00:53:45.730
The second gotcha I want to
cover today is exemplified here.

00:53:45.890 --> 00:53:50.400
So here the developer is setting
the date format specification

00:53:50.400 --> 00:53:55.340
pattern to have years,
months, and days, and then hours,

00:53:55.340 --> 00:53:58.920
minutes, and seconds in the resulting
string when they format a date.

00:53:59.260 --> 00:54:02.760
That capital HH there in the
middle means that the developer

00:54:02.760 --> 00:54:04.930
wants to get a 24-hour clock.

00:54:05.060 --> 00:54:10.100
They want the string to have any
number from 00 to 23 in the hour

00:54:10.100 --> 00:54:12.980
position when dates are formatted.

00:54:13.000 --> 00:54:17.080
Well, what happens then when the
developer runs their program,

00:54:17.080 --> 00:54:21.940
and it doesn't have to be January 1st,
I just picked on January 1st again,

00:54:21.940 --> 00:54:24.680
is that they run the
code and for some users,

00:54:24.680 --> 00:54:28.770
they see this, which is exactly what
the developer wanted.

00:54:28.780 --> 00:54:28.860
Okay.

00:54:29.460 --> 00:54:32.500
But other users, mysteriously, see this.

00:54:32.500 --> 00:54:34.150
They see 2:00 p.m.

00:54:34.290 --> 00:54:36.360
instead of 1400 hours.

00:54:36.730 --> 00:54:39.200
Well, what's going on here?

00:54:39.580 --> 00:54:41.790
Oh, well,
and another point is that if you're

00:54:41.800 --> 00:54:45.860
going in the reverse direction,
that is parsing strings back into dates,

00:54:45.950 --> 00:54:49.390
one of these strings is going to
work with this date formatter,

00:54:49.450 --> 00:54:53.890
and the other one is not,
depending on the user.

00:54:54.550 --> 00:54:57.610
Well,
what's going on is that date formatters

00:54:57.610 --> 00:55:03.770
start with the current user locale object
when they're created and initialized.

00:55:03.790 --> 00:55:09.350
And the current user locale object is an
object which has various user settings

00:55:09.350 --> 00:55:12.720
in it as well and user preferences,
whatever you want to call them,

00:55:12.790 --> 00:55:15.270
as well as various other
bits of locale data.

00:55:15.270 --> 00:55:21.100
And some of those user preferences
override even a specifically set format

00:55:21.400 --> 00:55:24.190
pattern on a date formatter object.

00:55:24.510 --> 00:55:28.340
So even though the developer
asked for 24-hour clock,

00:55:28.460 --> 00:55:33.390
because they're using a date formatter
with the current user locale in it,

00:55:33.460 --> 00:55:36.620
they might get, you know, something else.

00:55:36.620 --> 00:55:40.380
And in particular,
the 24-hour time setting

00:55:40.390 --> 00:55:45.220
that one can find in iOS,
like as I'm showing here in the iPhone,

00:55:45.220 --> 00:55:50.170
is one of these settings that can
override even what the developer

00:55:50.170 --> 00:55:52.420
is explicitly asking for.

00:55:52.450 --> 00:55:54.380
So the result is that the developer
has asked for 24-hour clock.

00:55:54.380 --> 00:55:58.520
can be either 1400 or 2:00 PM.

00:55:58.660 --> 00:56:00.840
Well, what's the fix here?

00:56:00.880 --> 00:56:06.950
Well, this is a case where the developer
wants to get a specific result,

00:56:07.020 --> 00:56:10.900
and so the current user locale
object should not be used.

00:56:11.010 --> 00:56:16.900
The locale object needs to be set to
something else on the date formatter.

00:56:17.630 --> 00:56:24.790
For Internet-type date strings,
the locale named enusposix

00:56:24.790 --> 00:56:24.790
often works well.

00:56:24.980 --> 00:56:29.890
And so, very simple to use this,
or to create one of these.

00:56:29.980 --> 00:56:34.380
You simply call init with locale
identifier with enus posix,

00:56:34.510 --> 00:56:39.020
and you set that locale object
into your date formatter,

00:56:39.020 --> 00:56:42.480
thus erasing its initial state of
the current user locale object.

00:56:42.520 --> 00:56:45.900
And then, of course,
I have to release my locale

00:56:45.900 --> 00:56:48.190
object here just to clean up.

00:56:48.400 --> 00:56:54.930
And so what that will do is use
the so-called ENUS POSIX locale

00:56:54.930 --> 00:56:59.440
in order to format dates that
are given to the date formatter.

00:56:59.460 --> 00:57:02.310
Well, okay,
so that's been a lot of information,

00:57:02.370 --> 00:57:05.780
but I see I'm running out of time,
so I need to wrap up.

00:57:05.860 --> 00:57:10.940
So our Application Frameworks
Evangelist is Bill Dudney,

00:57:10.940 --> 00:57:12.630
and here's his email address.

00:57:12.640 --> 00:57:15.890
For more documentation on
the classes that you've seen

00:57:15.890 --> 00:57:21.130
me talk about here today,
go refer to the Cocoa documentation,

00:57:21.270 --> 00:57:24.550
either from Mac OS X or iOS Foundation.

00:57:24.580 --> 00:57:29.020
Here's an example of one of
the links to get to that.

00:57:29.020 --> 00:57:32.790
And, of course,
many people who know about dates and

00:57:32.870 --> 00:57:38.750
times and calendrical calculations,
and myself included, when I have time,

00:57:38.980 --> 00:57:41.720
lurk on the Apple Developer Forums.

00:57:41.720 --> 00:57:47.120
So what are the takeaway
points that I've given here?

00:57:47.990 --> 00:57:51.850
Well, use the system calculation
algorithms whenever possible.

00:57:51.860 --> 00:57:53.290
Don't try to write them yourself.

00:57:53.400 --> 00:57:54.330
They're complex.

00:57:54.360 --> 00:57:58.840
Even we get them wrong once in a while,
and we apologize for that in advance.

00:57:59.640 --> 00:58:05.040
But still,
care must be taken in how you use them,

00:58:05.040 --> 00:58:10.130
as I showed with that loop, which,
you know, naturally one would think

00:58:10.300 --> 00:58:14.280
of advancing by days,
but in the special case of Brazil and

00:58:14.280 --> 00:58:18.270
potentially other time zones,
which transitioned at midnight, you know,

00:58:18.350 --> 00:58:21.830
there were still issues with
that particular solution,

00:58:21.840 --> 00:58:25.000
so we had to come up with
yet another solution.

00:58:25.370 --> 00:58:28.400
Try to avoid boundary conditions,
stressing boundary

00:58:28.490 --> 00:58:31.120
conditions whenever possible.

00:58:31.120 --> 00:58:36.010
But also, when you're writing your app,
try to imagine what the interesting

00:58:36.020 --> 00:58:38.290
boundary cases are for testing.

00:58:38.300 --> 00:58:42.090
So, for example,
if you advance the date on your device,

00:58:42.240 --> 00:58:45.620
say iOS device,
to near the end of the year,

00:58:45.930 --> 00:58:50.990
you might turn up an issue like that
date formatter problem where the

00:58:51.020 --> 00:58:54.110
wrong year was showing up in the UI.

00:58:54.140 --> 00:58:58.200
Well, and with that,
thank you for your time.
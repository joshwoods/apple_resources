WEBVTT

00:00:10.100 --> 00:00:11.870
Hi.

00:00:11.940 --> 00:00:14.440
Welcome to our session this afternoon.

00:00:14.540 --> 00:00:18.100
So my name is Dean Reece and
I manage the I/O Kit team.

00:00:18.100 --> 00:00:21.040
And today I'm going to be
talking to you a little bit

00:00:21.040 --> 00:00:23.050
about UserLand Device Access.

00:00:25.280 --> 00:00:27.910
Our talk is going to be broken
into three sections today.

00:00:28.020 --> 00:00:31.300
I'll be talking for about
the first half of the hour.

00:00:31.300 --> 00:00:36.460
And I'll be giving you sort of a general
survey of how all the user space device

00:00:36.510 --> 00:00:39.420
access works from a very general level.

00:00:39.500 --> 00:00:43.840
And then we'll be walking through a
pretty wide variety of API types that

00:00:43.840 --> 00:00:46.260
are available for this use on the system.

00:00:46.300 --> 00:00:50.250
And then Thane Norton will come up
and walk through a much more detailed

00:00:50.250 --> 00:00:53.520
example of user space HID device driver.

00:00:53.580 --> 00:00:56.760
And then after Thane is finished,
Ethan Bold is going to come up and

00:00:56.760 --> 00:01:01.520
present the user space sleep/wake
APIs and some new sleep behaviors

00:01:01.530 --> 00:01:03.910
that you'll be seeing with Lion.

00:01:05.150 --> 00:01:07.140
So what you're going
to learn from my talk,

00:01:07.140 --> 00:01:10.920
hopefully, is a little bit about the
Mac App Store and how that

00:01:10.920 --> 00:01:13.200
relates to device drivers.

00:01:13.200 --> 00:01:16.670
And we'll talk a bit about
the benefits and challenges

00:01:16.670 --> 00:01:18.980
of user-space device software.

00:01:19.520 --> 00:01:23.310
Getting into the APIs a little bit,
we'll look at device matching

00:01:23.510 --> 00:01:27.440
and how to run a process when
a piece of hardware is present,

00:01:27.440 --> 00:01:30.460
and then how that software
goes about finding the devices

00:01:30.460 --> 00:01:31.750
and talking to them and so on.

00:01:31.750 --> 00:01:36.160
And as I said, then we'll walk through a
variety of APIs for this.

00:01:36.160 --> 00:01:41.070
So, the Mac App Store is this
great new feature that we have.

00:01:41.180 --> 00:01:43.270
And of course,
as developers you want to be

00:01:43.270 --> 00:01:46.560
able to deliver your content
through the App Store.

00:01:46.560 --> 00:01:48.650
It's a great opportunity for you.

00:01:48.780 --> 00:01:51.950
But there are some limitations
with respect to device software

00:01:52.070 --> 00:01:54.120
that you need to be aware of.

00:01:54.240 --> 00:01:56.650
First and foremost,
we do not allow you to ship kernel

00:01:56.650 --> 00:02:00.130
extensions through the Mac App Store,
nor do we allow you to ship an app that

00:02:00.270 --> 00:02:02.420
attempts to install the kernel extension.

00:02:02.490 --> 00:02:05.680
So,
that obviously limits you to user space

00:02:05.680 --> 00:02:09.050
only APIs right there out of the gate.

00:02:09.120 --> 00:02:12.430
You also don't,
you're not allowed to have your app

00:02:12.540 --> 00:02:16.340
run with privileged execution and
the app needs to be self-contained.

00:02:16.340 --> 00:02:19.100
It has to stay within its app bundle.

00:02:19.150 --> 00:02:21.190
So,
you don't have the opportunity to install

00:02:21.320 --> 00:02:24.260
plug-ins into other parts of the system.

00:02:25.360 --> 00:02:28.620
Also, not a hard restriction,
but something to be aware of is

00:02:28.620 --> 00:02:32.900
App Store apps aren't allowed to
operate in the background without

00:02:32.900 --> 00:02:34.490
express consent from the user.

00:02:34.590 --> 00:02:38.070
So you can't have the app
automatically launch when the user

00:02:38.130 --> 00:02:42.020
logs in or continue running after
the user dismisses it unless the

00:02:42.020 --> 00:02:44.520
user has agreed to that explicitly.

00:02:45.600 --> 00:04:05.700
[Transcript missing]

00:04:06.630 --> 00:04:10.910
There's this session that we
had yesterday on the App Sandbox

00:04:11.120 --> 00:04:15.640
and the Mac App Store that you
would be interested in going

00:04:15.640 --> 00:04:19.550
and checking out on iTunes if
you think this is a distribution

00:04:19.630 --> 00:04:22.340
vehicle you're interested in.

00:04:25.270 --> 00:04:29.030
Now, developing software for user space
has some distinct advantages over

00:04:29.430 --> 00:04:33.340
kernel-side software development,
not the least of which that you have

00:04:33.340 --> 00:04:37.240
a much broader set of APIs available
to you because you've got a whole

00:04:37.380 --> 00:04:39.430
collection of frameworks available,
whereas in the kernel,

00:04:39.430 --> 00:04:41.930
you only have the kernel.framework.

00:04:42.100 --> 00:04:44.000
You have much better
debugging options available.

00:04:44.000 --> 00:04:49.300
You get to debug from within the
GUI Xcode debugging environment,

00:04:49.380 --> 00:04:52.480
and there's a richer set of
performance tools available for

00:04:52.560 --> 00:04:54.630
you to help optimize your software.

00:04:55.630 --> 00:04:59.420
From the customer's perspective,
there's some advantages as well.

00:04:59.470 --> 00:05:02.690
A fault in your software
won't crash the system.

00:05:02.790 --> 00:05:05.130
Obviously,
a critical resource going wrong can cause

00:05:05.450 --> 00:05:09.230
issues that the user would experience,
but it won't necessarily cause

00:05:09.230 --> 00:05:12.650
their system to panic and
immediately require a restart.

00:05:13.420 --> 00:05:15.280
And depending on exactly
what you're doing,

00:05:15.380 --> 00:05:19.700
you may or may not even require
administrative credentials to be

00:05:19.700 --> 00:05:23.610
able to install or use the APIs,
whereas kernel extensions require

00:05:23.630 --> 00:05:27.760
that for just installing the
software in the first place.

00:05:28.300 --> 00:05:30.490
And as I said earlier,
since you can't deliver a kernel

00:05:30.490 --> 00:05:35.330
extension through the App Store,
well, user space development is pretty

00:05:35.340 --> 00:05:39.620
much the only way to go and still be
compatible with the App Store at all.

00:05:40.710 --> 00:05:42.560
Now that being said,
there are of course some

00:05:42.560 --> 00:05:46.660
challenges that are different
from kernel extension development.

00:05:46.730 --> 00:05:49.290
First off,
not all device types are available

00:05:49.290 --> 00:05:51.490
from outside of the kernel.

00:05:51.690 --> 00:05:55.110
Specifically,
devices that generate DMA cycles and

00:05:55.110 --> 00:06:00.490
field direct interrupts generally are
not available outside of the kernel.

00:06:00.500 --> 00:06:05.700
So PCI devices and Thunderbolt devices
in particular still will need to be

00:06:05.920 --> 00:06:09.200
supported through kernel extensions.

00:06:09.280 --> 00:06:15.130
But a very wide variety of devices like
USB and Bluetooth are available outside.

00:06:15.190 --> 00:06:20.500
Now, we also have to think about being
able to publish devices from outside

00:06:20.630 --> 00:06:23.220
the kernel because that's one of
the things that device drivers

00:06:23.290 --> 00:06:24.690
typically want to be able to do.

00:06:24.780 --> 00:06:26.360
They want to be able to
publish a new service.

00:06:26.360 --> 00:06:28.140
And depending on exactly
what you're trying to do,

00:06:28.140 --> 00:06:30.990
you may or may not be able
to do that from user space.

00:06:31.110 --> 00:06:34.520
So we'll get into some more
details about that later.

00:06:35.910 --> 00:06:39.230
And again, one of the advantages for user
space development was that you had

00:06:39.230 --> 00:06:43.420
a wide variety of APIs available,
but it can also be a bit more

00:06:43.420 --> 00:06:46.480
work because you've got more
API spaces to learn and use.

00:06:46.480 --> 00:06:48.500
And depending on what
you're trying to do,

00:06:48.500 --> 00:06:52.340
you may be bridging multiple API spaces,
which generally you don't have as

00:06:52.400 --> 00:06:54.500
much effort to do inside the kernel.

00:06:54.500 --> 00:06:58.620
And there is no out-of-kernel
driver stacking model like we have

00:06:58.620 --> 00:07:00.820
with I/O Kit inside the kernel.

00:07:01.590 --> 00:07:04.020
Inside the kernel,
you can stack kernel extensions in a

00:07:04.020 --> 00:07:07.430
way that allows you to create a string
of drivers that talk to each other in

00:07:07.430 --> 00:07:09.220
a very discoverable and manageable way.

00:07:09.220 --> 00:07:12.820
And when you step outside the kernel,
you no longer have that mechanism.

00:07:15.600 --> 00:08:42.700
[Transcript missing]

00:08:46.120 --> 00:08:50.420
So even though we're not going to be
talking about kernel side development,

00:08:50.450 --> 00:08:53.040
you do need to be aware
of the IO registry.

00:08:53.150 --> 00:08:56.890
IO registry is a collection
of live driver objects that

00:08:56.890 --> 00:09:00.500
are running in the kernel,
but even though it's kernel resident,

00:09:00.500 --> 00:09:02.100
it's browsable from user space.

00:09:02.100 --> 00:09:06.090
And this is very important because
you use this for discovery of devices.

00:09:06.090 --> 00:09:08.100
Nearly all the devices we're
going to talk about today,

00:09:08.100 --> 00:09:10.090
you will use the registry to get at.

00:09:10.100 --> 00:09:12.670
And on the right hand
side of my slide here,

00:09:12.670 --> 00:09:16.030
you'll see I've got a dump
of one node of the registry.

00:09:16.100 --> 00:09:21.100
This happens to be a USB iSight camera
that's built into a current iMac.

00:09:21.100 --> 00:09:24.510
And in particular,
I want to draw your attention to the

00:09:24.510 --> 00:09:27.100
top line there where it says the class.

00:09:27.100 --> 00:09:32.060
Every node in the registry represents
a C++ object inside the kernel,

00:09:32.270 --> 00:09:36.170
and its class is your first
identification as to what

00:09:36.170 --> 00:09:40.100
that object represents,
what other properties may be present,

00:09:40.100 --> 00:09:46.000
what you can do to talk to it or
not talk to it as the case may be.

00:09:48.280 --> 00:09:51.280
So in this particular
class as a USB device,

00:09:51.280 --> 00:09:53.700
you'll see we've got a
variety of properties here.

00:09:53.700 --> 00:09:56.280
And two of them in particular
that you'll be interested in

00:09:56.280 --> 00:09:58.870
are the vendor and device ID.

00:09:58.890 --> 00:10:01.630
No surprise there,
these identify a very particular device.

00:10:01.650 --> 00:10:05.280
In this case,
it's our internal EyeSight camera.

00:10:07.620 --> 00:10:12.680
Now, if you haven't already seen this,
I recommend you run ioreg-l or run the

00:10:12.690 --> 00:10:18.950
ioregistry explorer application that's
available on our developer tools.

00:10:19.270 --> 00:10:22.260
The properties you see here are
all visible to any user space app.

00:10:22.360 --> 00:10:25.300
There's no administrative
permissions required,

00:10:25.340 --> 00:10:29.430
and you can very easily explore
all the devices on your system.

00:10:30.270 --> 00:10:32.990
So how do we do this programmatically?

00:10:32.990 --> 00:10:38.340
Well, if you want to be able to have your
software identify and talk to a device,

00:10:38.340 --> 00:10:40.700
obviously it's not going to
be browsing the registry.

00:10:40.700 --> 00:10:43.180
You're going to have to create
something that allows it to

00:10:43.180 --> 00:10:44.420
be searched programmatically.

00:10:44.450 --> 00:10:46.580
And we're going to start with
a matching dictionary for that.

00:10:46.600 --> 00:10:50.120
A matching dictionary literally
is a dictionary that describes

00:10:50.140 --> 00:10:52.740
an object you're interested in.

00:10:52.800 --> 00:10:57.130
And much like the previous slide,
we're going to start by

00:10:57.130 --> 00:10:59.030
looking at the class.

00:10:59.090 --> 00:11:02.740
And that narrows it down to a small
subset of the objects in the registry

00:11:02.890 --> 00:11:06.940
that could potentially match the
dictionary you're putting together.

00:11:06.940 --> 00:11:11.720
And within class,
the vendor and product ID specify exactly

00:11:11.800 --> 00:11:15.240
what type of devices you're looking for.

00:11:15.240 --> 00:11:18.180
And there may be a zero
of these on your system,

00:11:18.180 --> 00:11:19.420
or one, or there may be 50.

00:11:19.420 --> 00:11:20.840
It depends on what you're looking for.

00:11:20.840 --> 00:11:24.420
But this matching dictionary is only
going to find this type of device.

00:11:24.420 --> 00:11:27.800
So how do we go about using
this matching dictionary?

00:11:30.120 --> 00:11:34.490
Let's say you've got a utility software,
could be a driver, could be an app.

00:11:34.600 --> 00:11:39.470
You want it to launch as soon as this
device becomes present on a system.

00:11:39.850 --> 00:11:43.910
Well, we have a new capability in
Lion that uses LaunchD to launch

00:11:43.910 --> 00:11:45.960
when hardware is available.

00:11:45.960 --> 00:11:47.660
And it's very straightforward.

00:11:47.970 --> 00:11:51.420
Basically, you will start off
with this new property.

00:11:51.420 --> 00:11:54.660
It's this new LaunchD property
called I/O Kit matching.

00:11:54.660 --> 00:11:56.930
And within that,
you're going to specify the

00:11:57.010 --> 00:12:00.060
matching dictionary I just
showed you how to construct.

00:12:05.270 --> 00:12:12.810
Well, we have a new capability in
Lion that uses LaunchD to launch

00:12:13.140 --> 00:12:16.380
when hardware is available.

00:12:16.380 --> 00:12:21.580
And within that,
you're going to specify the

00:12:21.670 --> 00:12:28.590
matching dictionary I just
showed you how to construct.

00:12:31.320 --> 00:12:33.630
Now there's some more information,
of course, on LaunchD.

00:12:33.630 --> 00:12:36.740
If you look in the man
page for launchd.plist,

00:12:36.770 --> 00:12:40.600
I've been told that the new
I/O Kit matching capability has not

00:12:40.600 --> 00:12:45.040
yet been added to the man page there,
but as you can see from my slide here,

00:12:45.040 --> 00:12:45.930
there's not much to it.

00:12:46.020 --> 00:12:49.560
So I recommend that you start
with the LaunchD man page,

00:12:49.560 --> 00:12:53.270
and then you can go back and
view my slides from iTunes if you

00:12:53.280 --> 00:12:55.570
need more info on the matching.

00:12:56.590 --> 00:13:00.580
Okay, so now you have constructed
a matching dictionary.

00:13:00.630 --> 00:13:02.370
You've created a launchd job.

00:13:02.370 --> 00:13:04.180
It's launched your application.

00:13:04.330 --> 00:13:04.740
What do you do?

00:13:04.740 --> 00:13:06.040
How do you talk to the hardware?

00:13:06.180 --> 00:13:08.730
Well,
your app is going to have to discover it.

00:13:08.890 --> 00:13:11.040
So we're going to go back
to that matching dictionary.

00:13:11.040 --> 00:13:14.000
And you're going to
pass that to IO Service,

00:13:14.000 --> 00:13:15.790
get matching services.

00:13:15.790 --> 00:13:18.950
This is going to give you a
list of devices on the system

00:13:18.960 --> 00:13:20.870
that match your dictionary.

00:13:20.870 --> 00:13:22.890
You're going to iterate
through those results.

00:13:22.890 --> 00:13:24.560
Like I say, it could be zero or more.

00:13:24.560 --> 00:13:27.530
And once you've Okay.

00:13:27.900 --> 00:13:30.550
Identify the one you want,
then we'll talk about how

00:13:30.550 --> 00:13:31.730
to open it in just a second.

00:13:31.850 --> 00:13:34.770
But you can also become aware
of new devices that appear.

00:13:34.800 --> 00:13:38.600
Let's say you had zero matches when
you launched or the device that

00:13:38.600 --> 00:13:40.030
you were interested in went away.

00:13:40.100 --> 00:13:44.060
You can become aware that new
devices that match your dictionary

00:13:44.150 --> 00:13:48.370
have been attached to the system by
registering for this callback using

00:13:48.370 --> 00:13:51.030
IO Service Add Matching Notifications.

00:13:53.040 --> 00:13:55.160
All right,
so now you've either been notified or

00:13:55.160 --> 00:14:00.990
you have discovered at launch time the
objects you're interested in talking to.

00:14:01.190 --> 00:14:04.300
We're going to go ahead and call
IOCreatePlugInterfaceForService,

00:14:04.340 --> 00:14:06.100
which literally does what it says.

00:14:06.100 --> 00:14:10.100
It creates a plugin interface for the
service object that you've asked about.

00:14:10.190 --> 00:14:14.360
And that will load into your
program a plugin that allows

00:14:14.360 --> 00:14:19.700
you to communicate through
device-specific APIs to that device.

00:14:19.790 --> 00:14:25.290
Not every node in the registry
will be able to do this.

00:14:25.320 --> 00:14:29.200
The nodes in the registry that you can
talk to will return an object here,

00:14:29.200 --> 00:14:32.700
otherwise this call will fail
if the node does not have a

00:14:32.700 --> 00:14:35.400
user client available for it.

00:14:37.510 --> 00:14:40.800
Okay, so that was a very general
walkthrough of the procedure for

00:14:40.800 --> 00:14:42.400
discovering and talking to devices.

00:14:42.400 --> 00:14:47.090
I'm now going to go through a variety
of technology areas and kind of give

00:14:47.200 --> 00:14:49.520
you a very quick jumping off point.

00:14:49.520 --> 00:14:51.080
If you're interested
in one of these areas,

00:14:51.110 --> 00:14:53.580
you're going to have to dig
deeper than my presentation today.

00:14:53.580 --> 00:14:55.850
So I'm going to go through
them fairly quickly,

00:14:55.850 --> 00:14:59.550
and you can use the notes in these
slides as just sort of a starting point.

00:14:59.550 --> 00:15:03.420
We're going to go first through the
bus level communication protocols,

00:15:03.430 --> 00:15:06.480
and then we'll look at the
higher level service APIs.

00:15:08.590 --> 00:15:14.570
So USB is probably the most
common way to expand a Mac.

00:15:14.740 --> 00:15:19.410
It's also one of the richest APIs that
we have for user space device access.

00:15:19.590 --> 00:15:22.250
There are two classes that
you can locate in the registry

00:15:22.350 --> 00:15:24.000
and talk to from user space.

00:15:24.000 --> 00:15:28.290
A USB device, which represents an entire
physical USB object.

00:15:28.350 --> 00:15:31.370
And then I/O USB interface,
which represents a

00:15:31.370 --> 00:15:34.080
fraction of a USB device,
typically.

00:15:34.520 --> 00:15:39.840
We do allow access to USB devices
through the sandbox if you have

00:15:39.840 --> 00:15:43.240
this device.usb entitlement.

00:15:43.240 --> 00:15:45.910
So you'll have to ask for
that if your app needs to

00:15:45.910 --> 00:15:47.900
talk directly to USB hardware.

00:15:48.400 --> 00:15:53.350
And once a USB device is in use,
you're not going to be able to

00:15:53.380 --> 00:15:57.080
necessarily steal it from the
software that's already got it in use.

00:15:57.080 --> 00:16:02.060
So one of the particular workarounds
for this is to create a codeless KEXT.

00:16:02.060 --> 00:16:05.160
This is not necessarily a great solution,
but it does work,

00:16:05.160 --> 00:16:07.640
and it's the recommended
practice right now,

00:16:07.640 --> 00:16:10.800
where you'll install a kernel extension
that has the matching dictionary,

00:16:10.800 --> 00:16:13.460
which will basically hold
off in kernel drivers,

00:16:13.460 --> 00:16:16.280
thinking that your codeless
KEXT is going to be the right

00:16:16.290 --> 00:16:18.280
driver for this piece of software.

00:16:18.300 --> 00:16:20.300
Or excuse me, for this hardware.

00:16:20.300 --> 00:16:23.490
But in fact,
it doesn't have any code in it,

00:16:23.520 --> 00:16:26.380
so no driver comes along to
take over the device in kernel.

00:16:26.380 --> 00:16:30.460
And that gives your application time to
then run and take over from user space.

00:16:30.460 --> 00:16:34.230
Okay, so Bluetooth is also a great
way to expand to Macintosh.

00:16:34.320 --> 00:16:38.500
There's a variety of classes available,
but you don't go through the

00:16:38.500 --> 00:16:40.860
registry as I described earlier.

00:16:40.860 --> 00:16:45.230
You've got a whole Bluetooth framework
just for talking to Bluetooth devices.

00:16:45.240 --> 00:16:48.060
And it allows you to
discover the devices.

00:16:48.300 --> 00:16:51.170
Most of the time talking to
Bluetooth is done through services,

00:16:51.170 --> 00:16:51.740
though.

00:16:51.740 --> 00:16:53.540
You generally don't talk to the device.

00:16:53.540 --> 00:16:55.690
You talk to a service
that the device vends.

00:16:55.700 --> 00:17:02.630
And so the SDP service record is sort
of the key coin there of exchange for

00:17:02.660 --> 00:17:06.570
discovering and talking to devices.

00:17:07.090 --> 00:17:09.130
One thing to note,
if you're doing Bluetooth development,

00:17:09.180 --> 00:17:11.840
you want to stick to the
Objective-C APIs and shy

00:17:11.840 --> 00:17:13.240
away from the C APIs.

00:17:13.240 --> 00:17:16.750
Those are the old-style APIs we're
not encouraging for new development,

00:17:16.820 --> 00:17:19.990
so go to look at the Objective-C APIs.

00:17:20.050 --> 00:17:24.930
We currently do not have any entitlements
that would allow application access

00:17:25.010 --> 00:17:27.990
to Bluetooth devices through Sandbox.

00:17:28.390 --> 00:17:32.740
But apps can publish
new Bluetooth services,

00:17:32.740 --> 00:17:33.640
which is kind of interesting.

00:17:33.640 --> 00:17:36.060
It's a little different
than you might expect.

00:17:36.140 --> 00:17:39.190
The Macintosh itself can
actually vend a Bluetooth service

00:17:39.190 --> 00:17:40.640
to other Bluetooth clients.

00:17:40.640 --> 00:17:43.120
So you could do Mac to
Mac Bluetooth services

00:17:43.120 --> 00:17:44.610
if you're interested.

00:17:44.870 --> 00:17:46.960
And in fact,
that service will even launch

00:17:46.960 --> 00:17:50.190
your app when a remote client
tries to gain access to it.

00:17:50.310 --> 00:17:53.110
So it's kind of a neat feature.

00:17:53.780 --> 00:17:57.070
And also Bluetooth services can
often be shared by multiple apps.

00:17:57.110 --> 00:18:02.400
The details are device specific,
but it's not purely mutual exclusion.

00:18:03.300 --> 00:18:08.160
Firewire is also a fantastic bus for
doing lots of different things on a Mac.

00:18:08.190 --> 00:18:10.440
There are a variety of classes available.

00:18:10.440 --> 00:18:14.300
You do wind up going through
the registry to locate them.

00:18:14.300 --> 00:18:17.820
And we've got some very base level
classes for Firewire Unit and

00:18:17.820 --> 00:18:20.830
Firewire Device for talking
kind of right at the metal.

00:18:20.860 --> 00:18:23.850
And then we've got some higher
level classes that you probably

00:18:23.850 --> 00:18:27.280
wouldn't use because they'll tend to
be abstracted by other services in

00:18:27.280 --> 00:18:33.040
the system like SPP2 will generally
be abstracted for you by SCSI tasks.

00:18:33.200 --> 00:18:35.200
So you can use the same thing for
the same user client or stuck.

00:18:35.200 --> 00:18:41.140
And then AV is usually handled
at a higher level as well.

00:18:41.140 --> 00:18:45.240
And we do not have any sandbox
entitlements that will allow you to

00:18:45.240 --> 00:18:45.240
get to Firewire devices directly.

00:18:45.960 --> 00:18:49.290
And SCSI is one of those things
that kind of brings to mind giant

00:18:49.290 --> 00:18:53.080
connectors that look like harmonicas,
but SCSI is alive and well in a

00:18:53.090 --> 00:18:55.200
modern Macintosh in protocol form.

00:18:55.200 --> 00:18:58.070
The SCSI protocol is still
very much alive and well,

00:18:58.070 --> 00:19:03.950
and is used like for optical drives
and a few other devices as well.

00:19:03.960 --> 00:19:07.980
So you can discover these devices using,
as I said previously,

00:19:07.980 --> 00:19:12.220
the SCSI task user client,
and you would find them in the registry.

00:19:12.440 --> 00:19:17.010
You can talk to them by
requesting the plug-in,

00:19:17.020 --> 00:19:21.540
as I described earlier,
but we don't have any sandbox access.

00:19:21.700 --> 00:19:25.980
As far as mutual exclusion goes,
you generally can't talk to a

00:19:25.980 --> 00:19:30.960
SCSI protocol device that's in use,
with the exception of authoring devices.

00:19:30.980 --> 00:19:34.800
If you've got an optical drive
that has the ability to burn,

00:19:34.880 --> 00:19:38.760
then you can often open sort of
an around connection that will

00:19:38.760 --> 00:19:40.970
allow you to author to the device,
even if there's a blocked

00:19:40.970 --> 00:19:43.800
storage driver attached above it.

00:19:44.410 --> 00:19:46.700
Serial, this is another protocol
that's alive and well.

00:19:46.700 --> 00:19:50.460
Again, we're not really talking RS-232,
though it can certainly be.

00:19:50.460 --> 00:19:55.320
Serial is used for a lot of Bluetooth and
USB devices as an underlying protocol.

00:19:55.320 --> 00:19:59.480
If you have a device that presents
as a serial device in the system,

00:19:59.480 --> 00:20:03.200
you will find the device in the registry,
as I described earlier.

00:20:03.200 --> 00:20:07.600
But you won't use the registry
as the communication protocol.

00:20:07.600 --> 00:20:11.190
Instead, you're going to use our
POSIX TTY interface to

00:20:11.320 --> 00:20:13.300
actually talk to the device.

00:20:13.300 --> 00:20:14.870
So we have device nodes.

00:20:14.880 --> 00:20:19.700
The TTY generally, as Unix tradition,
is for inbound connections.

00:20:19.700 --> 00:20:25.760
And the CU or call-up or call-Unix
ports would be for outbound connections.

00:20:25.760 --> 00:20:28.720
This is very old-school serial stuff,
but this is the way it's done.

00:20:28.720 --> 00:20:34.000
There is currently no sandbox
access for serial devices.

00:20:34.000 --> 00:20:37.790
And apps cannot use an
in-use serial device.

00:20:37.800 --> 00:20:39.900
Once the device has been opened,
it's opened.

00:20:39.900 --> 00:20:43.260
So if you're going to have a piece
of software talking to serial,

00:20:43.300 --> 00:20:47.540
you should make sure you get an open it
first or make sure that all the clients

00:20:47.540 --> 00:20:50.580
make sure and close it when they're
done so it can be shared as needed.

00:20:51.910 --> 00:20:56.160
Now audio, audio is a really fantastic
example of what you can do

00:20:56.160 --> 00:20:58.130
from user space on Mac OS X.

00:20:58.220 --> 00:21:02.980
The core audio APIs are very rich and
pretty much put you on an equal footing

00:21:02.980 --> 00:21:04.100
with what you can do in the kernel.

00:21:05.100 --> 00:21:08.950
So, everything is done through,
all device access is done through HAL,

00:21:08.990 --> 00:21:10.900
the hardware abstraction layer.

00:21:10.900 --> 00:21:15.600
And there's the audio output unit,
which is a plug-in that you can load

00:21:15.600 --> 00:21:19.100
into your software and do audio in,
audio out.

00:21:19.100 --> 00:21:21.100
You can create new interfaces.

00:21:21.100 --> 00:21:23.100
It's a very rich API space.

00:21:23.100 --> 00:21:27.510
And you use the audio component
APIs to actually load audio

00:21:27.550 --> 00:21:29.810
units into your software.

00:21:30.650 --> 00:21:34.780
We do have some limited audio
access for sandboxed apps.

00:21:34.840 --> 00:21:37.920
All the apps can play
to the system speaker.

00:21:37.920 --> 00:21:40.620
But if you have this entitlement,
you can also gain access

00:21:40.620 --> 00:21:41.980
to the microphone.

00:21:43.240 --> 00:21:46.220
Now again,
going back to the core audio APIs,

00:21:46.270 --> 00:21:48.310
you can publish a new
audio driver plugin,

00:21:48.310 --> 00:21:52.750
which essentially means that you've
created a user space driver for audio.

00:21:52.760 --> 00:21:55.300
It does require admin
privileges to install,

00:21:55.390 --> 00:21:58.010
but once you've done that,
the plugin is available to all

00:21:58.010 --> 00:21:59.400
the other apps of core audio.

00:21:59.400 --> 00:22:01.690
And again,
it's pretty much on an equal footing

00:22:01.690 --> 00:22:03.500
to a kernel driver at that point.

00:22:04.270 --> 00:22:10.360
And all audio interfaces are
shareable by all clients.

00:22:10.360 --> 00:22:13.960
Everybody can record from
the same input stream or play

00:22:13.960 --> 00:22:15.100
into the same audio stream.

00:22:15.100 --> 00:22:18.020
So there's no mutual exclusion there.

00:22:18.180 --> 00:22:21.590
Now for video, we have a new framework
in Lion called Core Media.

00:22:21.590 --> 00:22:23.300
And this is a fantastic framework.

00:22:23.300 --> 00:22:26.780
It's modeled largely on Core Audio,
which has been very successful.

00:22:26.780 --> 00:22:30.130
And it uses a device
abstraction layer called a DAO,

00:22:30.130 --> 00:22:32.980
much in the same way
that audio uses a HAL.

00:22:33.860 --> 00:22:37.680
We have an entitlement there,
which basically mirrors the

00:22:37.680 --> 00:22:41.700
microphone entitlement for
gaining access to the camera.

00:22:41.860 --> 00:22:45.510
And as before,
you can publish new video interfaces

00:22:45.510 --> 00:22:47.820
if you install it as an admin.

00:22:47.820 --> 00:22:50.940
And once it's installed,
it's visible to all

00:22:50.940 --> 00:22:52.780
clients of Core Media.

00:22:54.330 --> 00:22:59.310
Storage, like serial, is kind of a split
personality technology.

00:22:59.320 --> 00:23:01.690
There's two ways to go about it.

00:23:01.700 --> 00:23:05.400
We have one set of APIs for discovering
and managing the devices and a separate

00:23:05.400 --> 00:23:08.920
set of APIs for actually talking
and passing data through the device.

00:23:11.850 --> 00:23:16.170
Storage, like serial, is kind of a split
personality technology.

00:23:16.170 --> 00:23:18.320
There's two ways to go about it.

00:23:18.320 --> 00:23:23.380
We have one set of APIs for discovering
and managing the devices and a separate

00:23:23.380 --> 00:23:28.500
set of APIs for actually talking
and passing data through the device.

00:23:28.880 --> 00:23:31.510
Now, if you're not interested in
managing the actual process and

00:23:31.510 --> 00:23:34.650
you simply just want to be aware
of what volumes are in the system,

00:23:34.750 --> 00:23:39.290
you can search in the IO registry
to discover IO media objects.

00:23:39.600 --> 00:23:41.500
Once you've found the device
you're interested in talking to,

00:23:41.500 --> 00:23:44.900
though,
you get the BSD device node name for it

00:23:45.030 --> 00:23:49.800
and talk to it through usual BSD APIs.

00:23:50.140 --> 00:23:52.720
And the access semantics for that
are a little bit more complicated

00:23:52.720 --> 00:23:56.140
than just mutual exclusion,
so I won't go into them here.

00:23:56.730 --> 00:24:00.720
We also do not have any sandbox
APIs that would allow you to get

00:24:00.720 --> 00:24:02.680
directly to a storage device.

00:24:02.770 --> 00:24:03.940
But in general, you wouldn't need to.

00:24:03.940 --> 00:24:07.590
You would go strictly
through the file system.

00:24:07.750 --> 00:24:10.960
I'll only talk briefly about HID because
Thane is going to come up in just a few

00:24:10.960 --> 00:24:13.440
minutes and walk us through a HID driver.

00:24:13.490 --> 00:24:17.820
But it's relatively straightforward
to use the HID APIs to locate

00:24:17.820 --> 00:24:22.440
devices on your system,
to open them, to communicate with them.

00:24:22.510 --> 00:24:27.450
And then once you've done that,
you can also post events back to

00:24:27.450 --> 00:24:30.390
the system using Core Graphics APIs.

00:24:30.490 --> 00:24:34.650
So there's actually a very rich
set of things that you can do from

00:24:34.650 --> 00:24:37.010
user space with respect to HID.

00:24:37.200 --> 00:24:42.000
Apps can even seize input devices
like joysticks for exclusive use,

00:24:42.000 --> 00:24:44.960
with the exception of keyboards,
which we don't want to because we

00:24:44.960 --> 00:24:47.720
want to prevent password snooping.

00:24:48.040 --> 00:24:50.570
And I'll talk very briefly
about image capture.

00:24:50.670 --> 00:24:54.130
It's a new framework that's in line now.

00:24:54.130 --> 00:24:56.870
And it allows you to discover
printers and scanners,

00:24:56.880 --> 00:25:00.840
excuse me,
cameras and scanners that would be

00:25:01.060 --> 00:25:03.860
typical file-based image devices.

00:25:03.940 --> 00:25:08.310
So you can use IC Device Browser to
find the devices that are on your system

00:25:08.420 --> 00:25:12.710
and then you can request that they
download their files so that you can

00:25:12.710 --> 00:25:15.410
process the images that they contain.

00:25:15.880 --> 00:25:20.340
ImageKit allows image capture devices
to be accessed directly from UI classes,

00:25:20.340 --> 00:25:23.290
so it's a very high-level
integration for GUI apps.

00:25:23.310 --> 00:25:28.660
So ImageKit is a great set of APIs for
doing high-level image capture access.

00:25:28.890 --> 00:25:34.300
We currently do not allow access to image
capture devices from within Sandbox.

00:25:34.580 --> 00:25:37.560
But apps can publish new
image capture devices,

00:25:37.560 --> 00:25:40.210
and once they're published,
they appear as a new service of the

00:25:40.210 --> 00:25:44.220
Mac that are visible to any client
of the image capture framework.

00:25:45.320 --> 00:25:47.640
And last, we have printing.

00:25:47.710 --> 00:25:49.880
We use core printing to
actually talk to printers.

00:25:49.880 --> 00:25:52.400
If you just want to print
to an existing printer,

00:25:52.550 --> 00:25:54.200
core printing is a great API for that.

00:25:54.200 --> 00:25:55.900
It's very straightforward.

00:25:55.900 --> 00:26:00.350
And with this security.print entitlement,
your App Store app can print.

00:26:00.360 --> 00:26:03.680
If you want to publish a new
printing service on the system,

00:26:03.740 --> 00:26:07.460
you're going to use the CUPS APIs to
create a back-end driver.

00:26:07.470 --> 00:26:09.400
And once you've done that,
it would appear as a new

00:26:09.400 --> 00:26:12.690
printer on your system,
visible to anybody on the system,

00:26:12.700 --> 00:26:14.700
and in fact,
can even be shared to other Macs.

00:26:14.700 --> 00:26:18.620
So, of course,
it requires an admin privilege to install

00:26:18.620 --> 00:26:23.530
a new printing device on your Mac,
so not available to App Store apps.

00:26:24.020 --> 00:26:25.820
And with that,
I would like to turn the microphone over

00:26:25.820 --> 00:26:28.180
to Thane Norton to talk to us about HID.

00:26:28.180 --> 00:26:30.490
Thank you.

00:26:34.460 --> 00:26:35.330
Thanks, Dean.

00:26:35.360 --> 00:26:36.300
Can you guys hear me all right?

00:26:36.300 --> 00:26:37.440
OK.

00:26:37.590 --> 00:26:39.730
So my name's Thane Norton.

00:26:39.930 --> 00:26:42.020
I'm the IOHID team lead.

00:26:42.050 --> 00:26:43.000
Little bit of a misnomer.

00:26:43.000 --> 00:26:45.540
I am the IOHID team.

00:26:45.950 --> 00:26:49.260
And I'm going to be talking to you
about how to write a userland driver,

00:26:49.260 --> 00:26:52.140
an application that acts as a driver.

00:26:52.270 --> 00:26:56.460
So I'm going to show you how
to find and access HID devices.

00:26:56.490 --> 00:26:59.000
And then once you've got
events from a HID device,

00:26:59.050 --> 00:27:03.750
how to inject those events back into the
system as key presses and mouse movement.

00:27:04.390 --> 00:27:06.640
So I picked up this
new piece of hardware.

00:27:06.800 --> 00:27:08.300
It looked really cool.

00:27:08.390 --> 00:27:10.760
Said it had Mac drivers.

00:27:10.900 --> 00:27:12.040
I was pretty happy with it.

00:27:12.080 --> 00:27:14.400
It's got lots of buttons,
flashing lights, and everything.

00:27:14.400 --> 00:27:15.960
But the drivers didn't work for me.

00:27:16.150 --> 00:27:20.170
I haven't run a 32-bit system in a while,
so the 32-bit kernel extension

00:27:20.170 --> 00:27:21.890
didn't work on my system.

00:27:22.880 --> 00:27:24.680
And I looked at it and I said,
this would make a nice

00:27:24.680 --> 00:27:25.660
example of a HID device.

00:27:25.740 --> 00:27:27.810
I mean, it's got lots of buttons.

00:27:27.930 --> 00:27:29.690
It's got a joystick.

00:27:30.050 --> 00:27:33.110
There's these LEDs that
you can toggle on and off.

00:27:33.180 --> 00:27:35.530
Love blinking lights.

00:27:35.600 --> 00:27:37.770
It's got a full color backlight.

00:27:37.900 --> 00:27:41.420
And it even has an LCD that
you can put data out to.

00:27:42.010 --> 00:27:44.720
So what's the first step?

00:27:44.830 --> 00:27:47.480
Well, the first step,
since it's a HID device,

00:27:47.500 --> 00:27:50.190
is you fire up USB Prober,
and that will parse the

00:27:50.280 --> 00:27:54.220
HID descriptor for you and show
you what the device looks like.

00:27:54.230 --> 00:27:57.480
Now, USB Prober dumps out
a lot of information.

00:27:57.490 --> 00:27:59.940
We don't care about most of it here.

00:28:00.590 --> 00:28:02.220
As Dean showed you,
you want the vendor and

00:28:02.300 --> 00:28:04.630
product ID of the device.

00:28:04.910 --> 00:28:09.760
Any Logitech G13 will have exactly this
vendor ID and exactly this product ID.

00:28:09.860 --> 00:28:13.100
Any Logitech device will
have this vendor ID.

00:28:14.160 --> 00:28:17.000
Then we look at the report descriptor.

00:28:17.000 --> 00:28:19.000
Unfortunately,
this device does not break out

00:28:19.000 --> 00:28:22.030
the buttons and the joystick and
everything into their own little pieces.

00:28:22.190 --> 00:28:24.620
It's one seven-byte packet.

00:28:24.960 --> 00:28:28.500
So the next step is,
what do we do with that packet?

00:28:28.500 --> 00:28:30.620
Well, if you're lucky,
you can get some developer

00:28:30.620 --> 00:28:34.890
documentation and it'll break down,
this is what this bit means and

00:28:35.000 --> 00:28:36.100
this is what that bit means.

00:28:36.100 --> 00:28:37.780
But I didn't have that.

00:28:37.780 --> 00:28:39.800
I was able to find some
open source drivers.

00:28:39.830 --> 00:28:41.700
They reverse engineered
the packet formats,

00:28:41.710 --> 00:28:44.150
both for reading from the device
and writing to the device.

00:28:44.310 --> 00:28:47.960
And so that's where I got
my information from.

00:28:47.960 --> 00:28:51.200
Now, if it's an input device,
you can pretty much just connect

00:28:51.200 --> 00:28:52.860
to it and start playing with it.

00:28:52.860 --> 00:28:55.860
And you'll see what data
comes into the system.

00:28:55.900 --> 00:28:59.650
And you can figure out from that
which buttons you're pressing.

00:29:01.030 --> 00:29:04.400
Lastly, if you have a device that you
can't do any of those things with,

00:29:04.460 --> 00:29:08.390
you can put a packet sniffer on the bus
between a system that has a real driver,

00:29:08.540 --> 00:29:10.960
a functioning driver,
and your device and see

00:29:10.960 --> 00:29:12.990
what the packet format is.

00:29:12.990 --> 00:29:16.770
Not for the faint of heart,
but it is an option.

00:29:18.870 --> 00:29:20.680
So I decided to try and
write a sample project.

00:29:20.680 --> 00:29:23.520
It hasn't really hit
Apple sample project stage,

00:29:23.560 --> 00:29:25.910
but if you come talk to me afterwards,
I can give you a copy.

00:29:26.270 --> 00:29:29.580
So the first thing I want to emphasize
is whenever you're writing a driver,

00:29:29.590 --> 00:29:34.460
it's hard enough without a
consistent error handling idiom.

00:29:34.470 --> 00:29:39.780
Make sure that you handle errors the same
way so that people don't get surprised.

00:29:40.100 --> 00:29:42.540
Personally,
I like to use the assert macros.

00:29:42.560 --> 00:29:44.400
They have some nice
flow control features,

00:29:44.420 --> 00:29:47.780
and they're easy to compile
out if you don't want them.

00:29:48.240 --> 00:29:50.720
And I strongly recommend
you take a look at ASL.

00:29:50.950 --> 00:29:52.520
ASL is the Apple System Logger.

00:29:52.760 --> 00:29:56.280
It's a one-stop shop
for having a log file,

00:29:56.470 --> 00:29:59.150
putting things out to the system log,
and putting things out to

00:29:59.150 --> 00:30:01.830
standard error with a single call.

00:30:02.000 --> 00:30:04.310
In my application,
I even have it set up so

00:30:04.400 --> 00:30:07.460
that in the debug build,
it goes out to standard error,

00:30:07.500 --> 00:30:11.170
but in a release build,
it only goes out to the system log.

00:30:12.970 --> 00:30:16.990
So your first step is you
have to find the device.

00:30:17.040 --> 00:30:20.000
You get an IOHitManager instance.

00:30:20.420 --> 00:30:22.260
Create your matching dictionary.

00:30:22.260 --> 00:30:24.820
You can see here that I'm using
the toll-free bridging between

00:30:24.920 --> 00:30:27.140
MS dictionary and CFDictionary.

00:30:27.210 --> 00:30:32.450
This is the vendor ID and the product
ID that we found using USB Prober.

00:30:33.520 --> 00:30:37.240
We tell the HID manager that these are
the kinds of devices we're looking for,

00:30:37.240 --> 00:30:40.200
that is to say, the specific device.

00:30:40.330 --> 00:30:42.550
We register our callback.

00:30:43.010 --> 00:30:45.890
Schedule the HID Manager with a run loop.

00:30:46.160 --> 00:30:48.360
The HID Manager can only be
scheduled with one run loop,

00:30:48.400 --> 00:30:51.150
but you can pick whichever one you want.

00:30:52.190 --> 00:30:53.850
And then you open the HID Manager.

00:30:53.910 --> 00:30:56.780
And lastly, check your error.

00:30:56.850 --> 00:30:58.890
If anything goes wrong
and the HID Manager can't

00:30:58.960 --> 00:31:03.980
open or it can't schedule,
that will come out during that open call.

00:31:04.030 --> 00:31:07.730
And so if you don't at
least check the error,

00:31:07.800 --> 00:31:09.890
you won't know what went wrong.

00:31:11.790 --> 00:31:13.810
So your callback gets called.

00:31:13.830 --> 00:31:15.870
The first thing you do,
the very first thing,

00:31:16.000 --> 00:31:18.220
is you register for a removal callback.

00:31:18.230 --> 00:31:21.440
I'll explain a little bit more why later,
but if you do not do this,

00:31:21.440 --> 00:31:22.700
you will crash.

00:31:24.310 --> 00:31:25.800
Then you open the device.

00:31:26.010 --> 00:31:28.950
In this case,
since I don't want to share the device,

00:31:29.050 --> 00:31:30.330
I'm seizing it.

00:31:30.460 --> 00:31:33.730
You can see the IOHit
option type Seize Device.

00:31:34.020 --> 00:31:37.530
If you're talking to a keyboard or
device that you might want to share,

00:31:37.720 --> 00:31:40.490
you just supply zero,
and it won't try and seize the device,

00:31:40.600 --> 00:31:42.850
and anybody can look at the data.

00:31:43.480 --> 00:31:46.470
Again, check your error state,
especially if you're

00:31:46.470 --> 00:31:48.890
trying to seize the device.

00:31:48.990 --> 00:31:51.390
Register your value callback.

00:31:53.600 --> 00:32:07.100
[Transcript missing]

00:32:08.860 --> 00:32:12.270
Now, the device reference does not
have to be retained by you because

00:32:12.270 --> 00:32:14.510
it's retained by the manager.

00:32:14.630 --> 00:32:18.840
What that means is it's only valid
between the time it gets supplied

00:32:18.840 --> 00:32:25.630
to you in your device callback and
when your removal callback returns.

00:32:25.880 --> 00:32:28.830
If you don't have a removal callback,
that device reference can be pulled

00:32:28.840 --> 00:32:31.630
out from underneath you at any time.

00:32:31.720 --> 00:32:35.870
So please register for your callback
and watch for device removal.

00:32:37.720 --> 00:32:39.520
We got data from the device.

00:32:39.540 --> 00:32:41.260
What do we do now?

00:32:41.330 --> 00:32:42.880
So we're going to want
to generate events.

00:32:42.970 --> 00:32:46.650
First step, create your CG event source.

00:32:47.120 --> 00:32:49.880
Once you've got your event source,
if you're going to be doing

00:32:49.880 --> 00:32:53.190
any kind of keyboard events,
you want to set your keyboard type.

00:32:53.240 --> 00:32:56.950
As anybody who's from a
foreign country knows,

00:32:57.200 --> 00:33:02.160
developers here in the States,
they've got their ANSI QWERTY keyboards.

00:33:02.160 --> 00:33:04.120
All of them work the same.

00:33:04.120 --> 00:33:07.150
As soon as you go to France,
you end up with an ISO AZERTY keyboard,

00:33:07.240 --> 00:33:09.420
and the keystrokes
aren't working properly.

00:33:09.420 --> 00:33:11.950
This is what prevents you
from having that problem.

00:33:11.960 --> 00:33:15.220
Now, where did that 46 come from?

00:33:15.220 --> 00:33:18.530
I went in the registry,
and I looked at the HID subinterface

00:33:18.600 --> 00:33:20.400
ID for the device I was using.

00:33:20.460 --> 00:33:25.090
If you're recording devices from a user,
you can use CGEvent GetSourceKeyboardType

00:33:25.270 --> 00:33:28.790
to get the keyboard type that
you need to supply to recreate

00:33:28.790 --> 00:33:30.750
the event that you recorded.

00:33:33.730 --> 00:33:36.580
So the first two bytes are the joystick.

00:33:36.650 --> 00:33:38.590
We're going to turn those
into mouse movement.

00:33:38.600 --> 00:33:40.930
So the first thing you need to
do to generate mouse movement

00:33:41.290 --> 00:33:43.760
is to create your position.

00:33:43.880 --> 00:33:45.860
Now the position is
in global coordinates.

00:33:45.930 --> 00:33:49.640
It's kind of a pain,
but it's the way the system works.

00:33:49.780 --> 00:33:52.200
So you need to have your current x and y.

00:33:52.250 --> 00:33:56.310
I get those by creating an event
tap and tracking all of the mouse

00:33:56.400 --> 00:33:58.090
events that come through the system.

00:33:58.190 --> 00:34:02.880
There's other ways to do it,
but that's the one that works for me.

00:34:03.100 --> 00:34:05.440
Then we create our mouse event.

00:34:07.310 --> 00:34:11.040
We posted to the system
and released the event.

00:34:11.130 --> 00:34:12.960
If you don't release it,
you're going to eventually

00:34:12.960 --> 00:34:13.660
run out of memory.

00:34:13.660 --> 00:34:17.320
So that should be fairly obvious.

00:34:17.470 --> 00:34:19.100
Now,
the only errors that you can check here

00:34:19.100 --> 00:34:21.230
is whether or not the event was created.

00:34:21.350 --> 00:34:25.040
If you try and post a null pointer,
you're going to crash.

00:34:25.200 --> 00:34:28.570
So please check to make
sure the event got created.

00:34:28.770 --> 00:34:30.740
If you want to do something more
interesting than just moving

00:34:30.740 --> 00:34:33.860
the cursor around the screen,
you're going to have a little

00:34:33.870 --> 00:34:35.550
bit more state to manage.

00:34:35.770 --> 00:34:39.290
When the button goes down,
you'll do a left mouse down.

00:34:39.300 --> 00:34:42.580
There's a similar one
for a right mouse down.

00:34:43.210 --> 00:34:46.280
All the movement after
that is a left mouse drag,

00:34:46.310 --> 00:34:48.280
and then when the user
releases the button,

00:34:48.390 --> 00:34:50.510
you get a left mouse up.

00:34:50.670 --> 00:34:54.540
Very similar for write buttons
and other mouse buttons are

00:34:54.540 --> 00:34:56.990
a little more complicated,
but it's fairly straightforward.

00:34:57.000 --> 00:34:59.240
You can figure it out if you want.

00:34:59.380 --> 00:35:03.590
So now, the buttons, the parts everybody
wanted to know how to use.

00:35:04.010 --> 00:35:06.520
We're going to turn those
into keyboard events.

00:35:06.670 --> 00:35:11.070
First thing to do for a
normal keyboard button is we

00:35:11.220 --> 00:35:13.810
just create a keyboard event.

00:35:14.460 --> 00:35:19.930
You want to supply true when the button's
going down and false when it's coming up.

00:35:20.800 --> 00:35:23.940
Now, you have to supply this
magical virtual key code.

00:35:23.960 --> 00:35:27.220
Where does that virtual
key code come from?

00:35:27.580 --> 00:35:31.510
It has to do with the way the
keyboard's laid out and everything,

00:35:31.510 --> 00:35:31.510
but--

00:35:31.890 --> 00:35:34.680
You really want to gather
the data from real keyboards.

00:35:34.750 --> 00:35:38.980
Events.h,
you can figure out what a lot of

00:35:38.980 --> 00:35:42.440
those virtual key codes will be,
but your best bet is to sit down

00:35:42.440 --> 00:35:46.880
with a real keyboard and just record
the events and see what you get.

00:35:46.880 --> 00:35:50.090
As part of my sample,
I actually have a command line utility

00:35:50.350 --> 00:35:55.230
that you can hit buttons and it will
generate dictionary entries that you

00:35:55.280 --> 00:36:00.910
would put in the preference file to be
able to generate those keyboard events.

00:36:01.960 --> 00:36:04.460
We checked to make sure
the event got created,

00:36:04.520 --> 00:36:06.900
post and release.

00:36:06.950 --> 00:36:11.200
Now, if you want to do modifier keys,
those are a little more complicated.

00:36:11.320 --> 00:36:14.560
You create a blank event.

00:36:14.640 --> 00:36:19.620
Then you set its type to
a flags changed event.

00:36:20.130 --> 00:36:22.790
Then you have to take the
global modifier state,

00:36:22.930 --> 00:36:28.880
set the flag that you are changing,
set the virtual key code,

00:36:29.010 --> 00:36:30.840
post and release.

00:36:30.990 --> 00:36:34.010
Not that hard,
but a little more complicated.

00:36:34.400 --> 00:36:35.750
So we've got some other keys on here.

00:36:35.980 --> 00:36:37.960
We're not going to use
those to generate events,

00:36:38.020 --> 00:36:40.300
but we're going to use them
to do internal state change.

00:36:40.300 --> 00:36:43.720
So you can change the keyboard layout
or what the screen's displaying.

00:36:43.780 --> 00:36:47.030
And so we want to reflect
that state back to the system.

00:36:48.670 --> 00:36:52.770
The first thing I'm going to show
you how to do is the backlight color.

00:36:53.080 --> 00:36:53.710
Very simple.

00:36:53.830 --> 00:36:57.500
You roll the magical
backlight color packet,

00:36:57.550 --> 00:37:00.620
and then call setReport to
send it out to the device.

00:37:00.700 --> 00:37:02.280
How did I find out this format?

00:37:02.310 --> 00:37:04.660
I looked at the open source drivers.

00:37:05.360 --> 00:37:07.580
Same thing for the LEDs.

00:37:07.760 --> 00:37:12.080
You roll the mystical LED packet,
send it out to the device.

00:37:12.590 --> 00:37:14.540
It's really straightforward.

00:37:14.660 --> 00:37:19.340
So when the device gets detached,
your callback gets called.

00:37:19.670 --> 00:37:21.240
You want to close the device.

00:37:21.390 --> 00:37:22.430
It's already gone.

00:37:22.690 --> 00:37:23.640
The user's unplugged it.

00:37:23.730 --> 00:37:24.870
The system went to sleep.

00:37:25.020 --> 00:37:26.460
The hub got disconnected.

00:37:26.460 --> 00:37:27.490
It doesn't make any difference.

00:37:27.620 --> 00:37:29.240
You don't have access
to the device anymore,

00:37:29.400 --> 00:37:31.060
so don't try to talk to it.

00:37:31.270 --> 00:37:33.230
It won't do you any good.

00:37:33.750 --> 00:37:35.380
You don't need to unregister anything.

00:37:35.440 --> 00:37:37.330
That's all taken care of by the close.

00:37:37.360 --> 00:37:39.710
No more callbacks will get called.

00:37:39.830 --> 00:37:42.140
Nothing will happen on the run loop.

00:37:43.280 --> 00:37:47.940
When the driver quits,
you want to call IOHit Manager Close,

00:37:48.000 --> 00:37:49.700
release the manager reference.

00:37:49.700 --> 00:37:51.540
Technically,
you probably don't have to do those,

00:37:51.710 --> 00:37:54.360
but it's good form.

00:37:54.420 --> 00:37:55.840
And that's it.

00:37:55.890 --> 00:37:58.680
It's really straightforward.

00:37:58.990 --> 00:38:04.910
In summary,
use an IOHit manager to track devices.

00:38:05.260 --> 00:38:10.400
use the IOHID device references
to get data from the devices,

00:38:10.570 --> 00:38:16.610
send data to the devices,
and monitor device state.

00:38:17.210 --> 00:38:19.620
Now, one thing you want to keep in
mind is that one physical device

00:38:19.880 --> 00:38:22.100
can publish multiple HID devices.

00:38:22.130 --> 00:38:25.900
So if you've got a joystick throttle,
it may have two HID devices,

00:38:25.900 --> 00:38:27.700
one for the joystick,
one for the throttle,

00:38:27.900 --> 00:38:30.100
or a keyboard and mouse combo.

00:38:30.100 --> 00:38:33.160
If you want to control the whole device,
you'll have to figure out all

00:38:33.270 --> 00:38:35.270
the devices that it publishes.

00:38:35.420 --> 00:38:38.420
Lastly, check your errors.

00:38:38.440 --> 00:38:41.920
I've encountered a lot of problems with
people who write drivers and have a

00:38:42.120 --> 00:38:46.970
problem and I just put in logging code to
see what errors they're getting and say,

00:38:46.970 --> 00:38:49.170
"Well, you're not opening the device.

00:38:49.170 --> 00:38:51.140
Of course it's not going to work."

00:38:52.290 --> 00:38:55.070
Writing a HID device driver is easy.

00:38:55.160 --> 00:38:57.790
If you've got a keyboard
sitting on your desk that has

00:38:57.890 --> 00:39:00.320
buttons that don't do anything,

00:39:00.870 --> 00:39:05.060
You should just go home and attach to it
and see what event you're getting back.

00:39:05.170 --> 00:39:08.940
You might actually be able to do
something useful with those buttons.

00:39:09.000 --> 00:39:11.800
And with that,
I'm going to hand it off to Ethan.

00:39:17.100 --> 00:39:18.600
Hi, everybody.

00:39:18.600 --> 00:39:20.500
My name is Ethan Bold.

00:39:20.500 --> 00:39:24.270
I work on the I/O Kit team
with Dean and Thane,

00:39:24.270 --> 00:39:27.100
and I'm going to talk
about sleep and wake today,

00:39:27.220 --> 00:39:31.710
specifically how you can get
involved in sleep/wake from user

00:39:31.710 --> 00:39:34.500
space and how you can influence it.

00:39:35.110 --> 00:39:41.500
So the first thing we're going to talk
about is two APIs that you can use to

00:39:41.500 --> 00:39:45.100
listen for sleep-wake notifications
and to influence sleep-wake behavior.

00:39:45.100 --> 00:39:48.900
And then we're going to talk
about two new types of sleep

00:39:48.910 --> 00:39:50.890
in Lion and on new hardware.

00:39:50.900 --> 00:39:55.830
So let's start by making sure
we're all on the same page.

00:39:56.400 --> 00:39:58.940
When I say go to sleep,
I mean what happens when

00:39:59.070 --> 00:40:03.100
you close the lid on your
MacBook and when you open the lid,

00:40:03.100 --> 00:40:04.090
you're waking it up.

00:40:04.100 --> 00:40:09.100
And when we go to sleep,
we do that in a very specific order.

00:40:09.220 --> 00:40:14.300
We start out by telling applications
that we're going to sleep and

00:40:14.300 --> 00:40:16.100
waiting for them to respond.

00:40:16.100 --> 00:40:20.100
Then we tell your kernel device
drivers that we're going to sleep,

00:40:20.100 --> 00:40:24.650
where they prepare
hardware to be turned off.

00:40:24.860 --> 00:40:31.310
Then the OS does some platform work
and maybe writes a hibernation image.

00:40:31.670 --> 00:40:36.830
And finally,
the hardware turns off the CPU and

00:40:37.120 --> 00:40:39.710
turns off power to the system.

00:40:39.890 --> 00:40:43.530
When we're waking up,
we do that in the opposite order.

00:40:43.610 --> 00:40:47.190
We start by turning on
the CPU and the hardware.

00:40:47.270 --> 00:40:50.400
Then the OS does some
platform-level work,

00:40:50.440 --> 00:40:53.670
maybe restores from a Hibernate image.

00:40:53.740 --> 00:40:59.620
Then we're going to power on
your kernel-level device drivers.

00:40:59.700 --> 00:41:02.470
And finally,
we're going to tell your applications.

00:41:02.580 --> 00:41:06.680
So the first thing I want to talk
about is API that lets you run

00:41:06.680 --> 00:41:09.800
code at that application stage.

00:41:10.770 --> 00:41:16.140
And that API is called
IO Register for System Power.

00:41:16.150 --> 00:41:20.660
You might want to run code at sleep
to close down open network connections

00:41:21.170 --> 00:41:27.030
or close down connections to your
device or save any open files.

00:41:27.090 --> 00:41:31.490
And you might want to reopen those
connections on wake from sleep.

00:41:33.270 --> 00:41:38.230
The OS does wait for you to
acknowledge this sleep notification,

00:41:38.230 --> 00:41:44.620
so you have to acknowledge by calling
IO Allow Power Change after you've

00:41:44.620 --> 00:41:47.400
handled your sleep notifications.

00:41:48.050 --> 00:41:50.860
So,
let's look at a couple of code samples.

00:41:51.000 --> 00:41:55.600
Here's how you can register
for sleep/wake notifications.

00:41:55.730 --> 00:41:58.860
You just call ioregister
for system power.

00:41:59.000 --> 00:42:03.090
That's going to populate an
IO notification port for you.

00:42:03.200 --> 00:42:07.860
You can turn that IO notification
port into a CFRUN loop source,

00:42:07.990 --> 00:42:10.930
and you can add that to your CFRUN loop.

00:42:11.410 --> 00:42:14.270
When you're done handling
sleep/wake notifications,

00:42:14.340 --> 00:42:17.810
you should call
IOD Register for system power.

00:42:19.780 --> 00:42:25.180
Now you can also get your
notifications on a dispatch queue.

00:42:25.310 --> 00:42:28.200
This code looks much like the last slide.

00:42:28.200 --> 00:42:31.020
You call ioregister for system power.

00:42:31.110 --> 00:42:35.040
You call ionotificationport
create dispatch source,

00:42:35.150 --> 00:42:38.090
and then you add that
source to a dispatch queue.

00:42:38.190 --> 00:42:40.600
And when you're done,
you call iodregister

00:42:40.600 --> 00:42:42.930
for system power again.

00:42:43.340 --> 00:42:48.960
That's how you would sign up
and release those notifications.

00:42:49.110 --> 00:42:52.960
Here's what your code might look
like handling those notifications.

00:42:53.180 --> 00:42:57.210
There are three messages
that we'll send you.

00:42:57.560 --> 00:42:58.740
for sleep and wake.

00:42:58.810 --> 00:43:03.830
The first one here is KIO message
system has powered on.

00:43:04.130 --> 00:43:07.100
That's a--that's the message
we're going to send you on wake up

00:43:07.130 --> 00:43:11.650
after we've turned on the hardware
and turned on all the devices.

00:43:11.650 --> 00:43:15.540
You will get to run code at
system has powered on time.

00:43:15.640 --> 00:43:20.660
Note that you do not need
to acknowledge this message.

00:43:20.860 --> 00:43:24.040
The next message you
do have to acknowledge,

00:43:24.040 --> 00:43:26.670
that's KIO message, system will sleep.

00:43:26.710 --> 00:43:31.570
You're going to get this message
sent out before system sleep.

00:43:31.810 --> 00:43:35.470
Like I said, you have a chance to save
files or close connections.

00:43:35.470 --> 00:43:40.400
So you can do all that here,
but you must call IO allow power

00:43:40.400 --> 00:43:46.350
change ASIP so that OS X can continue
putting your machine to sleep.

00:43:47.180 --> 00:43:50.580
And the longer you wait to call it,
the more awkward the user

00:43:50.580 --> 00:43:52.190
experience is for the user.

00:43:55.600 --> 00:43:59.130
And finally, there's a third message
you need to listen to.

00:43:59.240 --> 00:44:02.680
It is KIO message can system sleep.

00:44:02.800 --> 00:44:06.500
Historically,
this was the API that you would use to

00:44:06.500 --> 00:44:09.490
prevent a machine from idle sleeping.

00:44:09.600 --> 00:44:13.940
But we have a better API that
we're going to talk about

00:44:13.940 --> 00:44:18.490
next called Power Assertions
for preventing system sleep.

00:44:18.620 --> 00:44:23.620
So you still need to listen for this
can system sleep message and acknowledge

00:44:23.900 --> 00:44:26.380
it with I/O Allow Power Change.

00:44:26.610 --> 00:44:30.310
There's really no
reason to run code here.

00:44:32.410 --> 00:44:37.000
So let's talk about that better
alternative for preventing idle sleep.

00:44:37.120 --> 00:44:39.100
These are power assertions.

00:44:39.200 --> 00:44:47.720
They're a way for you to inform
OS X of what your intentions are.

00:44:47.890 --> 00:44:50.390
and when you need the
system to stay awake.

00:44:50.490 --> 00:44:53.920
There are two types of
assertions you can create.

00:44:54.050 --> 00:44:59.510
They are KIOPM assertion type,
prevent user idle sleep.

00:44:59.670 --> 00:45:05.630
When you're holding that assertion,
OS X will try its best not to idle sleep.

00:45:05.750 --> 00:45:08.090
And you might hold this assertion
if you're doing a long-running

00:45:08.090 --> 00:45:13.870
calculation or a build or a
firmware update or a big download.

00:45:15.660 --> 00:45:22.090
The other assertion that you can take is
called Prevent User Idle Display Sleep.

00:45:22.290 --> 00:45:28.100
This lets you keep the
display powered on and lit up,

00:45:28.100 --> 00:45:34.590
so you might hold this assertion if
you're showing content to the user or if

00:45:34.740 --> 00:45:40.300
you need some video feedback to the user.

00:45:40.510 --> 00:45:46.030
So you take either of these
assertions by calling IOPM assertion,

00:45:46.040 --> 00:45:47.690
create with name.

00:45:47.920 --> 00:45:52.410
And like I said,
these replace existing API,

00:45:52.410 --> 00:45:56.640
but one of the best reasons for them,
we like them better,

00:45:56.640 --> 00:45:58.400
is that they're more accountable.

00:45:58.400 --> 00:46:02.660
If you take an assertion in your code,
I can go into terminal and

00:46:02.660 --> 00:46:07.930
type pmset -g assertions and
see who's holding assertions.

00:46:08.060 --> 00:46:12.880
So it's much easier to see who's
keeping your machine awake at any time.

00:46:15.050 --> 00:46:17.240
So, quick sample code.

00:46:17.240 --> 00:46:20.510
Here's how you might create
and hold an assertion while

00:46:20.510 --> 00:46:22.510
you're doing important work.

00:46:23.810 --> 00:46:27.160
We're calling IOPM assertion
create with name,

00:46:27.210 --> 00:46:32.920
and we're passing in three
arguments-- the assertion type,

00:46:32.940 --> 00:46:36.400
prevent user idle sleep,
the initial assertion level,

00:46:36.530 --> 00:46:43.460
kIOPM assertion level on,
and a string identifying our app.

00:46:43.510 --> 00:46:45.900
And we get back a new assertion.

00:46:46.320 --> 00:46:49.130
So we're going to hold that
assertion while we do work,

00:46:49.130 --> 00:46:52.300
and when we're done,
we will release it by calling

00:46:52.400 --> 00:46:54.830
IOPM assertion release.

00:46:56.990 --> 00:47:02.270
So I mentioned that assertions are cool
because we can always see who's holding

00:47:02.270 --> 00:47:06.540
one by calling pmset -g assertions.

00:47:06.580 --> 00:47:12.260
I also want to call out a couple
of newish command line tools.

00:47:12.340 --> 00:47:14.710
Caffeinate is a front end for assertions.

00:47:14.710 --> 00:47:18.530
You can call -- you can just run
caffeinate at the command line and it

00:47:18.530 --> 00:47:23.520
will hold a power assertion for you,
either to prevent idle sleep

00:47:23.640 --> 00:47:26.650
or prevent idle display sleep.

00:47:27.340 --> 00:47:33.330
Like I said,
PMSET-G assertions gives you the current

00:47:33.700 --> 00:47:36.350
state of assertions on the system.

00:47:36.490 --> 00:47:39.800
It's a quick way to see
who's keeping the machine up.

00:47:40.390 --> 00:47:49.370
and third, PMSet-G-Log has been
around since Snow Leopard.

00:47:50.100 --> 00:47:56.710
It'll show you a history of all of the
sleeps and wakes that your system did,

00:47:56.710 --> 00:47:56.710
as well as

00:47:57.890 --> 00:48:03.430
As well as log any sleep
notification delays that went on.

00:48:03.620 --> 00:48:08.760
So if your app isn't handling IO register
for system power messages properly,

00:48:08.760 --> 00:48:11.600
you would see that in PMset-glog.

00:48:11.860 --> 00:48:16.420
You'd see a lot of tardy
responses for your app.

00:48:16.780 --> 00:48:23.070
One last thing about assertions I need to
mention is that they are a hint to OS X,

00:48:23.120 --> 00:48:25.340
and we can't always honor them.

00:48:25.460 --> 00:48:28.320
And there's always going to be
a case where the system needs to

00:48:28.320 --> 00:48:30.230
go to sleep and we can't stop it.

00:48:30.330 --> 00:48:33.380
Maybe when you close the
lid on your laptop or if

00:48:33.380 --> 00:48:35.660
you're just out of batteries.

00:48:35.830 --> 00:48:39.800
So we try to honor the assertions,
but we can't always.

00:48:42.320 --> 00:48:46.190
So those were the two
APIs I wanted to talk about.

00:48:46.280 --> 00:48:51.980
And next, I'm going to tell you about
two new types of sleep in

00:48:52.540 --> 00:48:56.700
in Lion and on new hardware--
are standby and dark-wake.

00:48:56.920 --> 00:49:00.870
Standby is about power saving
and extending your battery life

00:49:01.210 --> 00:49:03.040
while your machine's asleep.

00:49:03.170 --> 00:49:07.740
Dark-wake is about running code
and having your computer on,

00:49:07.860 --> 00:49:11.490
but keeping the screen off
so it appears not to be on.

00:49:11.660 --> 00:49:14.740
So, first, let's talk about standby.

00:49:14.820 --> 00:49:18.100
I have to define two
terms for you real quick,

00:49:18.230 --> 00:49:20.840
and those are sleep and hibernate.

00:49:20.960 --> 00:49:25.040
When I say sleep,
I generally mean suspend to RAM,

00:49:25.160 --> 00:49:27.800
and that means that when you
close the lid on your laptop,

00:49:27.910 --> 00:49:33.200
we're gonna keep your RAM powered,
and--and so that when you wake up,

00:49:33.330 --> 00:49:35.730
you can come right back
alive where you were.

00:49:35.840 --> 00:49:40.180
That's--that's fast,
but it's also expensive for battery

00:49:40.210 --> 00:49:44.950
life because we have to keep--keep
powering that RAM while you're asleep.

00:49:45.070 --> 00:49:49.280
When I say hibernate,
I mean suspend to disk,

00:49:49.290 --> 00:49:52.060
and that is-- when you close
the lid on your laptop,

00:49:52.130 --> 00:49:55.410
we're gonna take the contents
of your RAM and write it to a

00:49:55.410 --> 00:49:58.190
file on your storage device.

00:49:59.060 --> 00:50:05.490
And that is much better
for battery life because...

00:50:06.370 --> 00:50:09.300
Much better for battery life
because we don't need to keep your

00:50:09.300 --> 00:50:12.840
RAM powered while you're asleep,
but it's also really slow to get

00:50:12.840 --> 00:50:17.360
into writing all those megabytes,
and it's also really slow to get out

00:50:17.420 --> 00:50:21.560
of sleep because you might have to
read in two or four or eight gigabytes

00:50:21.880 --> 00:50:25.280
to restore your system memory state.

00:50:25.290 --> 00:50:29.270
So, Standby tries to combine those

00:50:29.930 --> 00:50:35.030
combine those modes by sleeping at
first when you close your laptop,

00:50:35.030 --> 00:50:38.920
and then after about an hour,
it quietly wakes up into a dark

00:50:39.030 --> 00:50:45.050
wake and transfers the contents
of RAM into a file on disk.

00:50:45.100 --> 00:50:50.350
So you're incurring--it costs
more battery life for that

00:50:50.460 --> 00:50:53.090
first hour to stay asleep,
but after that,

00:50:53.090 --> 00:50:56.100
we can extend your sleep time by weeks.

00:50:56.100 --> 00:51:00.100
This is only supported on the
latest MacBook Air models,

00:51:00.100 --> 00:51:06.230
the ones we released in late 2010,
and it's--you'll see it on

00:51:06.370 --> 00:51:10.100
10.6.7 today and in Lion.

00:51:10.100 --> 00:51:12.390
So that's standby.

00:51:12.910 --> 00:51:15.640
Next, let's talk about DarkWake.

00:51:15.800 --> 00:51:17.920
DarkWake is a new feature.

00:51:18.120 --> 00:51:23.530
It applies to all of our hardware,
all of our Lion-supported hardware.

00:51:23.680 --> 00:51:28.130
DarkWake is just like being awake,
except that the screen is off

00:51:28.250 --> 00:51:33.210
and the audio is suppressed,
so the audio won't come on.

00:51:33.420 --> 00:51:36.800
But the network is on,
the hard disk is up,

00:51:37.050 --> 00:51:39.120
processes are running.

00:51:40.260 --> 00:51:46.200
So right now we're using
DarkWake to do a few things.

00:51:46.200 --> 00:51:50.200
First is to handle the attaching
and detaching of external devices.

00:51:50.200 --> 00:51:53.700
When you plug in a
USB mouse to your system,

00:51:53.700 --> 00:51:58.330
it doesn't really need to light up the
display and wake up to a full wake.

00:51:58.400 --> 00:52:03.310
So we're using DarkWake to just quietly
wake up and quietly return to sleep

00:52:03.430 --> 00:52:06.260
without necessarily alerting the user.

00:52:07.280 --> 00:52:11.680
We're also using DarkWake to keep
your network connection live with

00:52:11.690 --> 00:52:13.840
the outside world when you're asleep.

00:52:15.630 --> 00:52:20.920
We wake up every couple of hours
to renew your DHCP lease with your

00:52:20.920 --> 00:52:27.200
DHCP server and to call out to
Back to My Mac on Apple servers.

00:52:27.200 --> 00:52:34.410
Because Back to My Mac announces your
computer's presence to the internet,

00:52:34.850 --> 00:52:40.170
but you have to check into that every
couple of hours to refresh your state.

00:52:40.200 --> 00:52:45.200
And finally, we're using DarkWake for
all kinds of sharing,

00:52:45.200 --> 00:52:48.920
file sharing and printer
sharing and iTunes streaming.

00:52:49.580 --> 00:52:53.960
There's no reason that your iMac
screen has to light up when you're

00:52:53.960 --> 00:53:00.010
trying to access it as a printer
share or file share from another room.

00:53:00.160 --> 00:53:03.260
or if you're trying to stream
content from it to your

00:53:03.260 --> 00:53:06.780
Apple TV in your living room,
there's no reason that the iMac

00:53:06.870 --> 00:53:10.040
in your bedroom needs to light up.

00:53:10.040 --> 00:53:11.520
So that is DarkWake.

00:53:13.960 --> 00:53:21.590
We aren't exposing DarkWake or
Standby in public API in Lion.

00:53:21.660 --> 00:53:24.940
In fact,
if you are a sleep/wake notification

00:53:24.940 --> 00:53:30.670
client of IORegister for system power,
you won't even get notified when

00:53:30.670 --> 00:53:34.860
we wake up into a DarkWake or
when we wake up into a Standby.

00:53:34.970 --> 00:53:37.100
So you should have to do nothing at all.

00:53:37.100 --> 00:53:42.820
You shouldn't have to handle DarkWake
or Standby in any special way.

00:53:45.100 --> 00:53:48.290
So that's all I have.

00:53:48.820 --> 00:53:52.850
Please remember those two APIs,
I/O Register for System Power and

00:53:52.850 --> 00:53:55.860
I/O PM Assertion Create with Name.

00:53:55.990 --> 00:53:59.780
And check out both of
those in Technical Q&A,

00:53:59.780 --> 00:54:03.740
QA 1340, for some code samples.

00:54:03.860 --> 00:54:05.410
Thank you.
WEBVTT

00:00:10.290 --> 00:00:11.500
Good morning.

00:00:11.570 --> 00:00:12.790
My name is Blaine Garst.

00:00:12.880 --> 00:00:17.360
Thank you for coming to the
Objective-C Advancements In-Deepth talk.

00:00:18.880 --> 00:00:21.280
Today's talk is in two parts.

00:00:21.280 --> 00:00:23.190
In the first part,
I'm going to be talking about

00:00:23.190 --> 00:00:28.440
Objective-C language extensions,
extensions that work anytime, anywhere,

00:00:28.440 --> 00:00:32.740
and then a fair amount of detail on
extensions that only apply under Arc.

00:00:32.800 --> 00:00:36.500
And in the second half of the talk,
given by Greg Parker,

00:00:36.500 --> 00:00:40.950
he'll talk about Arc internals,
implementation details you may or may

00:00:40.950 --> 00:00:44.790
not need to be aware of that could
well be very interesting anyway,

00:00:44.820 --> 00:00:46.760
some performance slides,
and some other things.

00:00:47.420 --> 00:00:52.130
So everything we talk about
today is available via the

00:00:52.130 --> 00:00:55.980
LLVM Compiler 3 found in Xcode 4.2.

00:00:56.150 --> 00:01:00.500
So you have to be using that compiler
to see all of these features.

00:01:00.540 --> 00:01:04.880
So let's just get started with the
extensions that work everywhere.

00:01:04.900 --> 00:01:07.060
So the first one you've
already seen a little bit.

00:01:07.060 --> 00:01:09.220
You've seen addAutoReleasePool.

00:01:09.300 --> 00:01:15.230
In the example code you see there,
you've typed this again and again, maybe.

00:01:15.420 --> 00:01:17.180
I don't know,
maybe some of you have never had

00:01:17.180 --> 00:01:19.440
to code up an AutoReleasePool,
but if you have,

00:01:19.490 --> 00:01:22.800
due to some performance concerns,
this is what you have to do.

00:01:23.070 --> 00:01:25.260
Now,
the thing about an AutoReleasePool is,

00:01:25.260 --> 00:01:27.990
even though it's an object,
you alloc and init it,

00:01:27.990 --> 00:01:30.650
it's not really much of an object.

00:01:30.810 --> 00:01:36.290
You can't really, well, for example,
have you ever tried to retain a pool?

00:01:36.370 --> 00:01:39.900
Have you ever tried to stick it as a
global variable or an instance variable?

00:01:39.900 --> 00:01:44.370
It just doesn't really work as an
object because really it fronts for

00:01:44.470 --> 00:01:49.990
a background service that sits and
works on every thread's behalf to hold

00:01:49.990 --> 00:01:52.150
onto intermediate temporary objects.

00:01:52.290 --> 00:01:55.490
And so the object part is just
a thin veneer on top of that,

00:01:55.490 --> 00:01:59.420
and what we've done in the compiler
is we've added syntax for it.

00:01:59.570 --> 00:02:03.800
We have an addAutoReleasePool construct
that gives you exactly the scope

00:02:03.850 --> 00:02:08.100
for where you want that collection
of temporary results to happen.

00:02:08.220 --> 00:02:12.450
Because of the fact that we're no
longer pretending that it's an object,

00:02:12.450 --> 00:02:15.610
it's a lot faster,
we've done lots of optimizations,

00:02:15.760 --> 00:02:20.390
and this is the construct that you
should use everywhere all the time.

00:02:20.450 --> 00:02:21.920
Let's take a look at another feature.

00:02:22.200 --> 00:02:23.580
here.

00:02:24.900 --> 00:02:28.200
Let's talk about instance
variable declarations.

00:02:28.230 --> 00:02:33.000
Instance variables are, as you know,
declared in the Add Interface section.

00:02:33.050 --> 00:02:35.550
Well, shoot,
how often are your instance variables

00:02:35.620 --> 00:02:37.190
really part of your interface?

00:02:37.220 --> 00:02:39.600
Your interface is the methods you expose.

00:02:39.600 --> 00:02:42.400
You don't really expose
public instance variables,

00:02:42.460 --> 00:02:44.800
so instance variables aren't
really part of your interface,

00:02:44.820 --> 00:02:50.740
but we require you to declare them there,
and that's not really very

00:02:50.740 --> 00:02:52.200
good information hiding.

00:02:52.200 --> 00:02:56.740
So I'm glad to say there's
been some movement on this.

00:02:56.740 --> 00:03:04.650
So on iOS and on Mac OS X 64, 64-bit,
we have some new opportunities for you.

00:03:04.720 --> 00:03:11.000
You can now declare instance
variables in a class extension or

00:03:16.040 --> 00:03:18.900
or directly in your add
implementation file.

00:03:18.900 --> 00:03:25.390
Okay, I can tell.

00:03:25.470 --> 00:03:28.900
I don't need to say any more about this,
but in fact I'm going to anyway.

00:03:28.900 --> 00:03:30.730
I'm going to give you an example.

00:03:30.850 --> 00:03:35.240
So let's say you have a wonderful class,
an elegant class,

00:03:35.240 --> 00:03:36.950
and it hides all these messy details.

00:03:37.030 --> 00:03:38.840
That's what you want
to write a class for,

00:03:38.840 --> 00:03:39.420
right?

00:03:39.520 --> 00:03:44.460
But you have to expose all those
messy details in your header file.

00:03:44.550 --> 00:03:45.900
So let's take one example.

00:03:45.900 --> 00:03:49.000
Let's say you've got a single
file implementation of this.

00:03:49.040 --> 00:03:54.080
What you really want to do is
take those messy details and

00:03:54.080 --> 00:03:58.380
just move them straight down into
your add implementation section.

00:03:58.560 --> 00:04:02.830
You end up with a clean public header
and the details where it's important,

00:04:02.840 --> 00:04:05.240
where you can actually use them.

00:04:05.400 --> 00:04:09.900
Let's take the same case,
the same messy public header file,

00:04:09.900 --> 00:04:12.180
but let's say you've got
multiple implementation

00:04:12.270 --> 00:04:13.380
files that need that header.

00:04:13.380 --> 00:04:15.820
Well,
that's where you use the class extension.

00:04:15.820 --> 00:04:19.010
You move your details
into the class extension,

00:04:19.090 --> 00:04:21.860
leaving you with the same clean header.

00:04:21.860 --> 00:04:27.450
You put the class extension in a shared
private header that is then imported and

00:04:27.700 --> 00:04:31.950
used by all of your implementation files,
and you've solved it

00:04:31.960 --> 00:04:33.810
for that case as well.

00:04:34.410 --> 00:04:38.360
Now, for those of you who aren't so
familiar with a class extension,

00:04:38.500 --> 00:04:43.080
the syntax is very much like a category
only without the category name.

00:04:43.080 --> 00:04:46.530
So I have a funny feeling that
class extensions are going to

00:04:46.530 --> 00:04:48.390
get a lot more use nowadays.

00:04:48.400 --> 00:04:52.400
Let's go on for a,
take a look at another feature.

00:04:53.670 --> 00:04:56.880
So every great app
starts with a great idea.

00:04:57.000 --> 00:05:00.460
So let's say you've got a great idea,
and in this case,

00:05:00.460 --> 00:05:03.100
let's say you want to ship it on iOS 5.

00:05:03.220 --> 00:05:03.850
That's great.

00:05:04.010 --> 00:05:06.460
But you don't want to
limit your app to iOS 5.

00:05:06.460 --> 00:05:10.220
You want it to deploy down
to earlier releases as well,

00:05:10.220 --> 00:05:11.690
iOS 4, iOS 3.

00:05:11.690 --> 00:05:12.980
So that's fine.

00:05:12.980 --> 00:05:13.850
We know how to do this.

00:05:13.880 --> 00:05:17.640
You start with the iOS 5 SDK,
and you just set the

00:05:17.640 --> 00:05:20.710
deployment target down to 3.1.

00:05:21.570 --> 00:05:22.560
Okay, that's fine.

00:05:22.560 --> 00:05:24.400
Code along for a while.

00:05:24.400 --> 00:05:29.460
Then you come across a really
neat new feature that's in iOS 5.

00:05:29.460 --> 00:05:31.940
You go, hey, I know where I can use
that some of the time.

00:05:31.940 --> 00:05:33.800
How do I do that?

00:05:33.880 --> 00:05:37.560
In this case, I'm talking about a
JSON serialization class,

00:05:37.560 --> 00:05:38.560
for example.

00:05:38.560 --> 00:05:44.890
And so the way we ask you to do it
today is to look that class up at

00:05:45.020 --> 00:05:49.020
runtime dynamically by string name.

00:05:49.180 --> 00:05:50.140
Okay.

00:05:50.240 --> 00:05:53.280
So you put it into a variable
that represents the class,

00:05:53.280 --> 00:05:55.160
and then you message the class.

00:05:55.340 --> 00:05:56.250
And so this works.

00:05:56.250 --> 00:05:59.790
There can be some issues if you
forget how to spell the new thing.

00:05:59.980 --> 00:06:03.390
There can be some issues if you
forget how to spell the methods

00:06:03.390 --> 00:06:05.700
that you're supposed to use with it.

00:06:05.800 --> 00:06:09.540
And so I'm happy to tell you that
there's another way to do this.

00:06:09.640 --> 00:06:11.910
It's called weak linking for classes.

00:06:11.910 --> 00:06:15.890
And you just use the class more or
less the way you would otherwise.

00:06:15.890 --> 00:06:19.380
You simply test to see whether
it yields a non-nil result.

00:06:19.490 --> 00:06:19.660
Okay.

00:06:20.050 --> 00:06:24.120
Because on earlier releases
where that class doesn't exist,

00:06:24.120 --> 00:06:27.380
that reference,
that NS JSON serialization

00:06:27.380 --> 00:06:29.480
string yields a nil value.

00:06:29.570 --> 00:06:32.360
Now,
the other important advantage of this

00:06:32.360 --> 00:06:36.640
is that we don't have any mechanism
prior to this that would allow you

00:06:36.640 --> 00:06:39.160
to subclass one of these new things.

00:06:39.160 --> 00:06:42.710
Now, JSON serialization is not really
a class you're going to subclass,

00:06:42.710 --> 00:06:45.350
but there are plenty of
classes that you might want to,

00:06:45.450 --> 00:06:48.340
and you now can do that using
the weak linking facility.

00:06:48.340 --> 00:06:49.000
Okay.

00:06:49.000 --> 00:06:54.960
So it deploys down to iOS 3.1,
and the most recent Mac was 10, 10.6.8.

00:06:55.040 --> 00:06:56.640
There's a slight caveat.

00:06:56.790 --> 00:06:59.720
If the entire package
doesn't exist on 3.1,

00:06:59.870 --> 00:07:01.290
then this doesn't work.

00:07:01.390 --> 00:07:04.890
So it's really for classes in
new classes in packages that

00:07:04.890 --> 00:07:06.810
exist on earlier platforms.

00:07:06.810 --> 00:07:09.120
But this is a much better way to do it.

00:07:09.120 --> 00:07:12.960
You get static type checking,
everything you want.

00:07:13.060 --> 00:07:14.100
Okay.

00:07:14.420 --> 00:07:15.800
Let's go on to another one.

00:07:15.860 --> 00:07:18.140
Stronger type checking.

00:07:18.140 --> 00:07:23.250
How many people have declared a variable
to be one type and then goofed up and

00:07:23.250 --> 00:07:25.700
initialized it with something else?

00:07:25.720 --> 00:07:26.380
I see hands.

00:07:26.540 --> 00:07:29.530
Well, I've done this, okay,
and I have to find out about

00:07:29.530 --> 00:07:31.660
it at runtime quite often,
right?

00:07:31.660 --> 00:07:33.200
Well, no longer.

00:07:33.220 --> 00:07:38.440
So, compiler has been taught that the
init method is the initializer for

00:07:38.440 --> 00:07:45.100
classes and that it returns an instance
of the class that it's sent to.

00:07:45.100 --> 00:07:49.280
So, the compiler knows that it returns
an instance of that type and that

00:07:49.290 --> 00:07:53.100
an instance of a mutable set is
not appropriate to be assigned

00:07:53.100 --> 00:07:56.300
into a variable that's supposed
to be holding a mutable array.

00:07:56.300 --> 00:08:00.770
And so,
we get a nice compiler warning at this,

00:08:00.820 --> 00:08:02.100
from this.

00:08:02.100 --> 00:08:03.100
And so, you should always do that.

00:08:03.100 --> 00:08:06.500
Always look through your warnings
because sometimes they can

00:08:06.500 --> 00:08:08.300
save your app from crashing.

00:08:13.320 --> 00:08:15.690
Now with that,
that's actually an interesting

00:08:15.860 --> 00:08:19.220
prelude because by teaching the
compiler about the init method,

00:08:19.220 --> 00:08:22.490
that's a lot of what
we're doing with Arc.

00:08:22.560 --> 00:08:24.820
So let's talk about Arc.

00:08:24.920 --> 00:08:27.780
So if you've gone to the preview talks,
which I hope you have,

00:08:27.950 --> 00:08:32.020
you'll know that Automatic Reference
Counting automates your retain,

00:08:32.020 --> 00:08:33.610
release, and auto-releases.

00:08:33.700 --> 00:08:36.660
It works for Objective-C objects only,
doesn't try to deal

00:08:36.660 --> 00:08:39.660
with malloc and freeze,
and it doesn't work -- it doesn't

00:08:39.710 --> 00:08:45.850
automate your use of core foundation or
core graphics or some of these non-NS

00:08:45.860 --> 00:08:48.500
object-based objects on our system.

00:08:48.570 --> 00:08:52.550
And of course,
it interoperates with existing retain,

00:08:52.660 --> 00:08:54.880
release frameworks and code.

00:08:55.020 --> 00:08:57.440
So the question is,
how does the compiler get

00:08:57.440 --> 00:08:58.840
it right all the time?

00:08:58.940 --> 00:09:00.700
And the answer is two things.

00:09:00.740 --> 00:09:03.660
We've taught the compiler
about Cocoa conventions.

00:09:03.850 --> 00:09:07.750
And we've taught the compiler about
ownership rules for variables.

00:09:07.910 --> 00:09:11.090
So let's talk about each
of these in more detail.

00:09:11.500 --> 00:09:12.930
COCA conventions.

00:09:13.160 --> 00:09:15.740
The language,
the Objective-C language itself

00:09:15.740 --> 00:09:21.010
does not specify allocation,
initialization, or destruction.

00:09:21.180 --> 00:09:23.360
Cocoa does this.

00:09:23.360 --> 00:09:25.210
We changed this 18 years ago.

00:09:25.220 --> 00:09:28.030
It used to be there was new and free,
and we introduced

00:09:28.030 --> 00:09:31.110
ALEC and NIT and whatever,
this Cocoa family of methods.

00:09:32.370 --> 00:09:36.410
And you all, you know,
have been asked to learn these

00:09:36.540 --> 00:09:43.000
in order to program properly
and carefully on Apple products.

00:09:43.040 --> 00:09:47.000
Well, after 18 years,
it's time we put these into the language,

00:09:47.010 --> 00:09:48.150
don't you think?

00:09:48.230 --> 00:09:50.420
So that's what we've done with Arc.

00:09:50.440 --> 00:09:54.140
So let's talk about these in more detail.

00:09:54.180 --> 00:09:58.670
So methods beginning with ALEC and NIT,
new and copy yield,

00:09:58.760 --> 00:10:01.040
what we call plus one retained items.

00:10:01.460 --> 00:10:05.640
You have had to know to have
a plan to get rid of that

00:10:05.670 --> 00:10:07.090
object or else it would leak.

00:10:07.160 --> 00:10:09.860
So this works great.

00:10:10.030 --> 00:10:11.520
The compiler makes this happen.

00:10:11.540 --> 00:10:17.260
So for example, if you have, say,
a singleton or maybe an

00:10:17.400 --> 00:10:21.650
immutable value object,
you know, the copy is just returned self.

00:10:21.740 --> 00:10:25.820
And so what Arc does is make
sure that you return a plus one.

00:10:25.820 --> 00:10:27.560
You don't have to think
about that anymore.

00:10:27.560 --> 00:10:29.030
Good.

00:10:29.180 --> 00:10:29.480
It works.

00:10:29.550 --> 00:10:29.980
It's fine.

00:10:30.040 --> 00:10:31.910
It's very neat.

00:10:32.190 --> 00:10:36.740
But what about names that
don't follow conventions?

00:10:36.770 --> 00:10:37.540
Hmm.

00:10:37.630 --> 00:10:38.330
Okay.

00:10:38.370 --> 00:10:39.340
Let's think about it.

00:10:39.390 --> 00:10:41.700
Let's say you've got some
unconventional names.

00:10:41.730 --> 00:10:45.300
Let's say you've got a copyright
notice and a copy left license,

00:10:45.300 --> 00:10:50.050
or you like to create objects
with a make new thing primitive.

00:10:50.070 --> 00:10:52.620
Well, hmm.

00:10:52.620 --> 00:10:56.860
We're not really copying a right
notice or copying a left license.

00:10:56.860 --> 00:10:58.660
You know, that's just -- you know,
we humans can read

00:10:58.660 --> 00:11:01.730
this and understand it,
but the compiler can't.

00:11:01.840 --> 00:11:03.730
So, hmm, is this going to be an issue?

00:11:03.990 --> 00:11:06.700
Well, let's take a look at one of them.

00:11:06.760 --> 00:11:11.360
Let's say you've got a license
implementation that returns a license,

00:11:11.360 --> 00:11:13.880
and you've got a client
of that somewhere else,

00:11:14.010 --> 00:11:16.770
the copy left license client.

00:11:16.850 --> 00:11:21.180
If you compile both of
these files under Arc,

00:11:22.010 --> 00:11:25.800
Compiler introduces a
retain where you create one,

00:11:25.800 --> 00:11:29.500
and it introduces a
release where you use it.

00:11:29.530 --> 00:11:31.660
Even though it may not
be what you intended,

00:11:31.660 --> 00:11:33.130
it just works.

00:11:33.150 --> 00:11:36.770
So if everything you code
up is compiled under Arc,

00:11:36.870 --> 00:11:41.440
it just works and you probably
don't have to worry about it.

00:11:41.470 --> 00:11:44.460
Let's take a look at a
couple other scenarios.

00:11:44.510 --> 00:11:50.690
Let's say you have some code
that's compiled not with Arc,

00:11:50.690 --> 00:11:53.310
and you're trying to use
it from Arc compiled code.

00:11:53.330 --> 00:11:56.120
Well, obviously,
the compiler doesn't know this,

00:11:56.160 --> 00:11:59.860
and so in the Arc compiled code,
we're going to do a release

00:11:59.980 --> 00:12:01.520
that's really unbalanced.

00:12:01.550 --> 00:12:04.570
And so you're going to
over-release this object and not

00:12:04.570 --> 00:12:06.600
good things are going to happen.

00:12:06.680 --> 00:12:11.800
Conversely, if you compile the copyleft
license code under Arc,

00:12:11.830 --> 00:12:14.730
it's going to do that extra retain,
but the client isn't

00:12:14.760 --> 00:12:17.210
going to know about that,
and so you're going to leak.

00:12:17.300 --> 00:12:18.560
So what can you do about it?

00:12:18.690 --> 00:12:21.780
Well, we have two answers for you.

00:12:21.840 --> 00:12:25.030
First of all,
you can rename your methods.

00:12:25.160 --> 00:12:31.760
So we could take your unconventional.h
file and make it conventional.h.

00:12:31.790 --> 00:12:35.910
The compiler does name matching
based on what we call camel case,

00:12:35.950 --> 00:12:37.730
which I hope you all know about.

00:12:37.810 --> 00:12:39.520
So to fix this, what do you do?

00:12:39.540 --> 00:12:41.510
You remove the hump.

00:12:42.110 --> 00:12:44.560
So that you know what's
really going on there,

00:12:44.560 --> 00:12:49.670
or you just adopt the new family
of naming conventions for that.

00:12:49.860 --> 00:12:53.160
Well, I all know that you generally
have managers and stuff,

00:12:53.180 --> 00:12:57.800
and changing names is often something
that invites some controversy.

00:12:57.910 --> 00:13:03.110
So if you can't change the names,
we have remedy number two.

00:13:03.210 --> 00:13:07.760
And that is we have ownership
transfer annotations.

00:13:07.760 --> 00:13:10.480
And these have been around for a while,
in fact.

00:13:10.500 --> 00:13:15.140
You just apply an NSReturns
not retained to methods that

00:13:15.140 --> 00:13:17.800
aren't actually creating things.

00:13:17.860 --> 00:13:20.910
And conversely,
you use NSReturns retained

00:13:21.000 --> 00:13:22.520
for those that are.

00:13:22.580 --> 00:13:26.010
So annotate your header file,
and then it won't matter which

00:13:26.010 --> 00:13:28.830
part of it is ARC-compiled
and which part of it isn't.

00:13:28.870 --> 00:13:32.000
Let's talk about those
ownership type qualifiers.

00:13:32.040 --> 00:13:35.110
We've introduced four type
qualifiers to the language,

00:13:35.110 --> 00:13:37.470
and I want to talk
about each one in turn.

00:13:37.960 --> 00:13:39.290
First one is strong.

00:13:39.460 --> 00:13:42.610
Strong variables retain their value.

00:13:42.680 --> 00:13:43.650
It's the default.

00:13:43.800 --> 00:13:46.410
You almost never have to type it.

00:13:46.750 --> 00:13:49.520
Stack local variables,
including parameters,

00:13:49.680 --> 00:13:51.710
are strong by default.

00:13:51.820 --> 00:13:55.940
What this means is they never
hold a dangling reference.

00:13:55.990 --> 00:13:58.750
They're either nil or
point to a valid object.

00:13:58.990 --> 00:14:05.250
So that solves an amazing number of bugs.

00:14:05.720 --> 00:14:11.870
The values are released sometime
after the last use of that variable.

00:14:12.340 --> 00:14:18.280
And so from the intro talk,
this is the stack example of POP.

00:14:18.500 --> 00:14:23.580
When the ARC compiler sees this,
what it does is it translates

00:14:23.590 --> 00:14:26.990
that and adds a retain and
an auto-release on there.

00:14:27.050 --> 00:14:30.870
So if that array was the
sole owner of that object,

00:14:30.870 --> 00:14:34.520
that last object,
then we have retained it.

00:14:34.590 --> 00:14:37.450
We've gotten rid of the
element from the array,

00:14:37.450 --> 00:14:40.660
but it's still valid
because we have that retain.

00:14:40.660 --> 00:14:44.490
And when we return it out,
we auto-release it so that you're

00:14:44.490 --> 00:14:49.090
returning a valid object even if
it's now the only reference to it.

00:14:50.270 --> 00:14:54.040
Weak variables, by contrast,
don't retain their values.

00:14:54.100 --> 00:14:56.690
They're great for breaking cycles,
as you've seen.

00:14:56.850 --> 00:15:02.610
They safely yield nil when read as
soon as the object starts deallocating.

00:15:03.330 --> 00:15:08.260
and Stack Local Week variables
also work this way.

00:15:08.300 --> 00:15:10.530
So let's take a look at this.

00:15:10.560 --> 00:15:14.270
Let's take a look at this
example of fact in more detail.

00:15:14.400 --> 00:15:18.080
So let's say you have a
routine called Test Week.

00:15:18.280 --> 00:15:22.740
You create a new object and assign
it into the new object variable,

00:15:22.740 --> 00:15:25.700
so it's holding the only
reference to that object.

00:15:25.770 --> 00:15:27.700
And then you create a
weak reference to it.

00:15:27.700 --> 00:15:30.530
As you've seen,
we use kind of dot dot dot for that.

00:15:30.630 --> 00:15:33.040
What you haven't seen up to now
is that there's actually some

00:15:33.040 --> 00:15:37.470
bookkeeping that goes on on the
side to help make this stuff work.

00:15:37.580 --> 00:15:40.320
And so when you do a
new object equals nil,

00:15:40.320 --> 00:15:43.670
the compiler of course
releases the old value,

00:15:43.700 --> 00:15:46.740
so now there's no
references to that object.

00:15:46.810 --> 00:15:48.720
And so that object starts to go away.

00:15:48.870 --> 00:15:53.380
As part of going away,
it notifies the weak system,

00:15:53.380 --> 00:15:56.240
and the weak system says, "Hmm, yeah,
how about that?

00:15:56.240 --> 00:15:59.240
We have a reference to this,
a weak reference to that.

00:15:59.290 --> 00:16:02.060
Let's clear out that weak
reference before we clean up our

00:16:02.070 --> 00:16:04.530
bookkeeping data." And so it does.

00:16:04.710 --> 00:16:10.410
The variable on the stack goes to nil,
and the bookkeeping data goes away.

00:16:10.510 --> 00:16:11.080
It works.

00:16:11.170 --> 00:16:13.040
It's really neat.

00:16:18.600 --> 00:16:22.360
Well,
let me beat this horse a little bit more.

00:16:22.400 --> 00:16:27.010
Let's say you create an object and
just stuff it into that weak value.

00:16:27.130 --> 00:16:28.600
Well, what's going to happen here?

00:16:28.600 --> 00:16:31.560
Well, let's take a look at what the
compiler does underneath you.

00:16:31.560 --> 00:16:36.020
The compiler inserts a temporary,
holds that brand new object,

00:16:36.160 --> 00:16:40.500
stores weak using the primitive,
and then releases that temp because

00:16:40.500 --> 00:16:42.590
that's the last use of that variable.

00:16:42.600 --> 00:16:45.760
Well, if you think about it,
this is exactly the same pattern

00:16:45.760 --> 00:16:47.400
I just illustrated before.

00:16:47.410 --> 00:16:49.800
You're releasing the only
reference to that object,

00:16:49.800 --> 00:16:52.590
and of course,
this one's going to go to nil also.

00:16:52.740 --> 00:16:57.380
So don't ever count on weak
references hanging on your values.

00:16:58.700 --> 00:17:01.110
So, there are a couple things
to bear in mind about WEEK,

00:17:01.110 --> 00:17:01.600
though.

00:17:01.700 --> 00:17:06.840
It's only available on
Mac OS X.7 and on iOS 5.

00:17:07.070 --> 00:17:12.640
The reason for that is that we've had to
tweak the retain-release implementations

00:17:12.640 --> 00:17:14.790
of pretty much everywhere.

00:17:14.810 --> 00:17:18.090
And so we can't do that
on earlier releases.

00:17:18.090 --> 00:17:22.240
We can do that on iOS 5,
we can do that on 10.7,

00:17:22.240 --> 00:17:24.900
but we can't do that in the past.

00:17:24.960 --> 00:17:27.560
So when we've gone through at
Apple and looked at all these custom

00:17:27.670 --> 00:17:30.800
retain-release implementations,
we found out that, wow,

00:17:30.800 --> 00:17:33.950
we've sped up retain-release so much,
and Greg's going to talk

00:17:34.030 --> 00:17:36.860
about that in the second half,
that you really don't need custom

00:17:36.860 --> 00:17:38.080
retain-release implementations.

00:17:38.140 --> 00:17:40.300
So we've deleted quite a few of them.

00:17:40.300 --> 00:17:42.830
And if you're just doing
it for performance,

00:17:42.830 --> 00:17:45.880
you should delete them as well,
in all likelihood.

00:17:46.020 --> 00:17:51.080
So some classes that are very
old have had a little trouble

00:17:51.080 --> 00:17:53.800
adopting the WEEK system.

00:17:53.800 --> 00:17:54.800
And so, you know,
we've had to do a lot of work on that.

00:17:54.800 --> 00:17:54.800
So, when we've gone through at
Apple and looked at all these custom

00:17:54.800 --> 00:17:54.800
retain-release implementations,
we found out that, wow,

00:17:54.800 --> 00:17:54.800
we've sped up retain-release so much,
and Greg's going to talk

00:17:54.800 --> 00:17:54.800
about that in the second half,
that you really don't need custom

00:17:54.800 --> 00:17:54.800
retain-release implementations.

00:17:54.800 --> 00:17:57.550
So an NSWindow, an NSViewController,
for example,

00:17:57.660 --> 00:17:59.890
are two classes you might run into.

00:17:59.910 --> 00:18:02.980
You can't really form a
weak reference to them.

00:18:03.230 --> 00:18:07.900
and you'll get a hard
crash if you try to.

00:18:07.920 --> 00:18:10.850
So if you're going to use weeks,
make sure you test that code and

00:18:11.120 --> 00:18:13.100
make sure that you can do that.

00:18:13.210 --> 00:18:16.600
So another issue is if you're
using third-party libraries,

00:18:16.600 --> 00:18:20.100
you should look to them,
especially if you're compiling them,

00:18:20.100 --> 00:18:23.100
whether they have custom-retained
release implementations

00:18:23.100 --> 00:18:25.100
and just be aware of that.

00:18:25.100 --> 00:18:29.040
And if you have a case where you
need to have a weak reference

00:18:29.040 --> 00:18:34.030
of some kind and you can't use
under-under-weak for some reason,

00:18:34.080 --> 00:18:37.090
you'll need to use unsafe-unretained
as the alternative.

00:18:37.090 --> 00:18:39.570
So let's talk about that.

00:18:41.310 --> 00:18:43.740
So it's an old concept.

00:18:44.160 --> 00:18:47.900
We've been using unsafe,
unretained variables forever.

00:18:48.080 --> 00:18:49.520
That's what delegates are.

00:18:49.620 --> 00:18:54.830
That's what @property_assign
is doing for you.

00:18:55.650 --> 00:19:02.960
You use them among cooperating objects
to hold safe unretained references.

00:19:02.960 --> 00:19:06.620
You make it safe by telling
all the clients of you,

00:19:06.700 --> 00:19:11.260
by knowing and telling all the clients
of your object that hold these things

00:19:11.260 --> 00:19:13.500
to clear them out when you go away.

00:19:15.430 --> 00:19:19.300
Because the compiler does
nothing to help out with unsafe,

00:19:19.300 --> 00:19:21.790
unretained items,
you can actually use them in structs.

00:19:21.830 --> 00:19:23.840
That's kind of a side benefit.

00:19:23.950 --> 00:19:27.710
Let's talk about that
cooperation thing a little bit.

00:19:27.830 --> 00:19:34.660
I call it the "dialog dance."
So here's a contrived example.

00:19:34.760 --> 00:19:37.640
Let's say you've got a
custom delegate controller.

00:19:37.740 --> 00:19:42.330
It's got pointers to table view
and a do it button set up in

00:19:42.380 --> 00:19:45.160
IB or maybe programmatically.

00:19:45.160 --> 00:19:49.320
And in the dialog method,
you have to remember to clear them out.

00:19:49.430 --> 00:19:52.700
And so you do this.

00:19:52.700 --> 00:19:56.040
When the last reference
to your object goes away,

00:19:56.140 --> 00:19:59.840
dialog is called, and when you run the
setDelegateNil methods,

00:19:59.840 --> 00:20:02.820
those red,
those unsafe references get cleared out,

00:20:02.820 --> 00:20:06.360
and then the runtime takes
care of removing the references

00:20:06.360 --> 00:20:09.990
from your object back up,
and everything goes away

00:20:09.990 --> 00:20:11.480
and things are fine.

00:20:11.480 --> 00:20:14.920
Now obviously,
if you forget to write a dialog method,

00:20:15.820 --> 00:20:19.090
or forget to do these set delegate nils,
you end up with dangling

00:20:19.090 --> 00:20:22.910
references in these objects,
and that's not really,

00:20:23.020 --> 00:20:24.940
that's not what you want to do.

00:20:25.030 --> 00:20:28.750
So it requires more careful programming.

00:20:29.440 --> 00:20:32.280
Auto-releasing is the last
attribute I want to talk about,

00:20:32.380 --> 00:20:38.320
and that is -- and that's used primarily
for the Cocoa convention of not

00:20:38.320 --> 00:20:41.720
transferring ownership across parameters.

00:20:41.880 --> 00:20:46.180
Indirect pointer parameters are
treated this way by default,

00:20:46.320 --> 00:20:50.500
and the basic idea is you just
slam a new value on it without

00:20:50.500 --> 00:20:53.420
worrying about the previous value.

00:20:53.770 --> 00:20:59.580
So when the compiler sees, say,
a KIP method that returns an NSError **,

00:20:59.670 --> 00:21:04.470
it really treats it as if
it was an auto-releasing.

00:21:04.700 --> 00:21:12.770
is the founder of LLVM.

00:21:13.220 --> 00:21:17.050
He's been working on the
LLVM system for a long time.

00:21:17.050 --> 00:21:17.050
He's been

00:21:17.220 --> 00:21:20.490
Your code, however,
might not follow Cocoa convention here.

00:21:20.610 --> 00:21:26.300
Sometimes, we are told, we've seen code,
you return ownership through a method.

00:21:26.400 --> 00:21:32.700
So if you've got a method that returns
or creates an object indirectly,

00:21:32.780 --> 00:21:35.980
you have to annotate it with
the strong directive to say,

00:21:36.040 --> 00:21:38.130
"Hey,
I really want to retain value on the

00:21:38.130 --> 00:21:43.190
other side of that when I do that."
And so you can do that by explicitly

00:21:43.570 --> 00:21:47.170
declaring it with the strong directive.

00:21:48.840 --> 00:21:54.050
So the three primary ones, strong, weak,
and unsafe unretained,

00:21:54.060 --> 00:21:57.580
now have new attribute
names for add properties.

00:21:57.670 --> 00:22:00.450
So we'd like you to think
about your object graph in

00:22:00.560 --> 00:22:05.770
terms of strong and weak links,
and if you need to, unsafe unretained.

00:22:05.840 --> 00:22:09.020
So strong is really just
a synonym for retain.

00:22:09.050 --> 00:22:11.300
Unsafe unretained is
a synonym for assign.

00:22:11.300 --> 00:22:13.620
They both still work and
still mean the same thing,

00:22:13.620 --> 00:22:18.100
but we prefer you to just use strong,
weak, and unsafe unretained for this.

00:22:18.170 --> 00:22:20.680
Let's talk about the copy convention.

00:22:20.800 --> 00:22:25.490
So copy with zone is the
primitive for creating a copy.

00:22:25.590 --> 00:22:26.140
And what do you do?

00:22:26.140 --> 00:22:29.270
You call super to get an
empty shell for the new thing,

00:22:29.280 --> 00:22:31.470
and for every instance
variable of interest,

00:22:31.480 --> 00:22:33.530
you copy the value over.

00:22:33.590 --> 00:22:37.320
Under arc, you don't have to do retains,
you still have to do

00:22:37.320 --> 00:22:41.690
copies if you need to,
and it just works.

00:22:41.800 --> 00:22:46.750
There are maybe ten people in this room,
though, who have had to think

00:22:46.750 --> 00:22:49.660
about subclassing NSCell.

00:22:49.660 --> 00:22:55.850
And NSCell can sometimes be a little
odd because it uses an NSCopy object.

00:22:55.990 --> 00:22:58.660
Well, we fixed that under arc as well.

00:22:58.660 --> 00:23:02.610
So this works with NSCell
subclasses as well.

00:23:04.600 --> 00:23:09.400
Hmm, maybe more than 10 of you.

00:23:09.510 --> 00:23:11.130
Exceptions.

00:23:11.150 --> 00:23:14.650
So the Cocoa Convention for
exceptions is they're really bad.

00:23:14.700 --> 00:23:17.900
If you throw an exception,
something really bad happens.

00:23:18.060 --> 00:23:22.760
In fact,
your app is probably going to go down.

00:23:22.890 --> 00:23:24.630
For recoverable errors,
you're supposed to use the

00:23:24.630 --> 00:23:27.560
convention like NSError **.

00:23:27.660 --> 00:23:30.070
If you throw an exception,

00:23:30.540 --> 00:23:33.440
You're often going to leak an object.

00:23:33.560 --> 00:23:35.890
You can have a retained object,
and unless you have a

00:23:35.950 --> 00:23:38.700
try-catch handler around it,
an exception gets thrown,

00:23:38.700 --> 00:23:43.190
that object gets leaked,
and that's also true under Arc.

00:23:43.300 --> 00:23:47.860
This is a convention we don't want to
try to fix because it's expensive to fix.

00:23:47.920 --> 00:23:50.970
So don't use exceptions.

00:23:52.000 --> 00:23:54.840
On the other hand,
as you saw with the weak system,

00:23:55.110 --> 00:23:58.680
you know, we actually keep pointers to
stack local variables around,

00:23:58.800 --> 00:24:01.540
and so we really,
even though if you do catch exceptions,

00:24:01.560 --> 00:24:04.540
we don't want you to crash because
the weak system goofed you up.

00:24:04.670 --> 00:24:10.150
So we make sure that the weak system
gets cleaned up under exceptions,

00:24:10.170 --> 00:24:13.240
so you don't have to worry about that.

00:24:13.470 --> 00:24:16.470
Let's talk about blocks.

00:24:18.260 --> 00:24:22.580
Blocks start out on the stack,
and they have to be copied

00:24:22.580 --> 00:24:24.960
when they're stored into
anything that's more permanent,

00:24:24.960 --> 00:24:29.310
like an instance variable or a global,
and when they're returned

00:24:29.310 --> 00:24:31.000
or indirectly assigned.

00:24:31.000 --> 00:24:33.650
You have to remember to
copy them to the heap,

00:24:33.730 --> 00:24:37.460
or you have had to remember
to do this up till now.

00:24:37.530 --> 00:24:42.140
So Arc automates this so that
instead of having to remember to

00:24:42.140 --> 00:24:46.120
do copy-auto-release or copies,
you just write the

00:24:46.590 --> 00:24:48.160
code you want to write.

00:24:48.160 --> 00:24:51.600
just assign it into an instance variable.

00:24:52.550 --> 00:24:55.710
are global or returner,
and it just works.

00:24:55.850 --> 00:25:00.240
The bottom line is that
blocks work best under Arc,

00:25:00.270 --> 00:25:02.480
and that's really true.

00:25:04.100 --> 00:26:45.500
[Transcript missing]

00:26:45.710 --> 00:26:49.740
You form a strong reference
to it by just reading it.

00:26:49.910 --> 00:26:51.800
Strong self equals weak self.

00:26:51.800 --> 00:26:55.000
And if strong self exists,
then you can safely dereference

00:26:55.000 --> 00:26:56.530
it and tell my view to blank.

00:26:56.600 --> 00:26:59.800
If you try just doing
weak self arrow my view,

00:26:59.800 --> 00:27:04.280
well, that read of weak self might
have lost a race with another

00:27:04.280 --> 00:27:06.730
thread that just got rid of that.

00:27:06.800 --> 00:27:10.780
And it might have yielded nil,
and so you might have a crash there.

00:27:10.810 --> 00:27:16.970
So be careful to always pull and
read and use -- don't use arrow

00:27:16.970 --> 00:27:19.790
messaging with weak variables.

00:27:19.800 --> 00:27:23.700
So with all that said,
with weak references in place,

00:27:23.700 --> 00:27:26.800
when the last reference
to self goes away,

00:27:26.800 --> 00:27:30.410
then of course the whole
thing recovers just nicely,

00:27:30.660 --> 00:27:31.800
blinking or not.

00:27:31.800 --> 00:27:36.800
Under-under-block variables have an
interesting behavior change under arc.

00:27:37.180 --> 00:27:41.180
Block objects, like all other forms
of storage durations,

00:27:41.270 --> 00:27:44.800
whatever,
are strong by default under arc.

00:27:45.020 --> 00:27:49.570
Under non-arc, though,
the default is essentially unsafe,

00:27:49.570 --> 00:27:50.800
unretained.

00:27:50.930 --> 00:27:52.800
And people have taken advantage of this.

00:27:52.820 --> 00:27:56.790
I saw this in the lab,
I've seen that inside Apple as well.

00:27:56.840 --> 00:28:02.400
So some people have used an unretained
self block variable to do that same

00:28:02.400 --> 00:28:05.790
trick that I showed you with weak before.

00:28:05.800 --> 00:28:06.780
So under arc, you have a block object,
and you have a block object.

00:28:06.860 --> 00:28:10.220
Under arc, with a behavior change,
this unretained reference now

00:28:10.220 --> 00:28:14.800
becomes a retained reference,
and it's likely to cause a cycle.

00:28:14.800 --> 00:28:16.800
So what do you do about that?

00:28:16.850 --> 00:28:19.390
Well,
if the migrator hasn't fixed this for

00:28:19.390 --> 00:28:23.590
you -- and it does in many cases --
you should try to -- you should convert

00:28:23.800 --> 00:28:25.800
to using a weak variable instead.

00:28:25.940 --> 00:28:29.800
And if you can't use weak because
you're shipping to an earlier platform,

00:28:29.800 --> 00:28:35.800
then you can reintroduce that unsafe,
unretained behavior.

00:28:36.050 --> 00:28:39.510
and it will work just
the way it did before.

00:28:40.920 --> 00:28:45.300
One last topic, Objective-C++ under Arc.

00:28:45.750 --> 00:28:48.440
Not much to say, it just works.

00:28:48.510 --> 00:28:54.590
So you can use ownership
attributes in your classes.

00:28:54.850 --> 00:28:59.470
What happens is the compiler
generates initializers that

00:28:59.470 --> 00:29:03.560
initialize the values to nil,
that do the retain and the release,

00:29:03.560 --> 00:29:07.040
or do the strong interactions,
and as such,

00:29:07.180 --> 00:29:10.820
these become non-pod classes,
non-plain old data classes,

00:29:10.820 --> 00:29:17.710
non-trivial destructors
and constructors and stuff.

00:29:18.230 --> 00:29:19.390
Everything works.

00:29:19.470 --> 00:29:24.430
Templates work, iterators work,
the collections work with

00:29:24.430 --> 00:29:26.600
the C++ standard library.

00:29:26.660 --> 00:29:30.020
And the only kind of funny thing is
that you have to use the attributes

00:29:30.100 --> 00:29:34.090
in some places when using containers.

00:29:34.300 --> 00:29:36.690
And with that,
it's time for Greg to come up

00:29:36.840 --> 00:29:39.310
and talk about Arc Internals.

00:29:45.300 --> 00:29:46.560
Thank you, Blaine.

00:29:46.600 --> 00:29:50.920
I'd like to talk about some details
of the Arc runtime and Arc compiler

00:29:50.920 --> 00:29:53.200
and what it's doing internally.

00:29:53.340 --> 00:29:54.530
Arc from the inside.

00:29:54.820 --> 00:29:56.120
So what is Arc?

00:29:56.260 --> 00:29:58.320
You've heard an awful lot
of descriptions of Arc.

00:29:58.500 --> 00:30:00.600
Here's the best description of Arc.

00:30:00.740 --> 00:30:03.960
The compiler adds retainer
release calls to your code.

00:30:04.070 --> 00:30:06.900
The compiler optimizer
removes some of them.

00:30:07.040 --> 00:30:08.170
That's really it.

00:30:08.170 --> 00:30:09.320
That's Arc.

00:30:09.790 --> 00:30:11.430
So let's go into a little more detail.

00:30:11.470 --> 00:30:14.780
This is the last session
of the conference,

00:30:14.850 --> 00:30:18.260
so if you're not tired already,
let's make you tired.

00:30:18.340 --> 00:30:20.340
Here's an example of some
strong variable code.

00:30:20.340 --> 00:30:24.220
You have a method that takes an
IVAR and swaps the old value with the

00:30:24.220 --> 00:30:25.740
new value and retains the old one.

00:30:25.990 --> 00:30:28.270
So the Arc version of
the code looks like this:

00:30:28.270 --> 00:30:29.860
no retains, no releases.

00:30:29.900 --> 00:30:31.900
What does the compiler do?

00:30:32.320 --> 00:30:34.660
compiler adds, retains, and releases.

00:30:34.850 --> 00:30:38.290
It retains your parameter,
it retains the old value and

00:30:38.290 --> 00:30:41.640
auto-releases it on the way out,
and it retains the new value

00:30:41.640 --> 00:30:44.670
as it stores it into the IVAR.

00:30:44.950 --> 00:30:47.800
What the compiler really
adds are C functions.

00:30:47.940 --> 00:30:49.990
It doesn't actually call the methods.

00:30:50.080 --> 00:30:53.060
So it calls new
C functions in the runtime,

00:30:53.130 --> 00:30:55.400
but these C functions today
just call the methods,

00:30:55.400 --> 00:30:57.470
so there's nothing
interesting going on there.

00:30:57.630 --> 00:31:01.980
So this is what your code looks like
after the compiler frontend is done.

00:31:02.650 --> 00:31:04.320
Now the optimizer goes to work.

00:31:04.360 --> 00:31:07.600
It looks at these retains and says,
"Some of these are duplicates.

00:31:07.620 --> 00:31:10.030
We retained a value and
immediately released it." Well,

00:31:10.180 --> 00:31:10.910
that's dumb.

00:31:11.040 --> 00:31:12.420
Don't do that.

00:31:12.470 --> 00:31:16.840
Compiler optimizes your code,
removes some of the retains and releases,

00:31:16.890 --> 00:31:18.880
so your code ends up like this.

00:31:18.920 --> 00:31:21.920
Retains the new value on the way in,
does the work,

00:31:21.960 --> 00:31:25.530
auto-releases the one going out,
which is what you would have

00:31:25.530 --> 00:31:27.290
written without Arc anyway.

00:31:27.410 --> 00:31:30.420
Let's take a look at what the
compiler does with weak variables.

00:31:30.480 --> 00:31:32.960
Here we have a delegate
that we've marked weak,

00:31:33.160 --> 00:31:35.860
and a setter method and
a getter method for it.

00:31:35.940 --> 00:31:40.150
Again, the compiler adds retains and
releases for the parameters,

00:31:40.150 --> 00:31:43.050
adds a retain auto-release
for a return value,

00:31:43.220 --> 00:31:48.620
and it uses runtime functions to
read and write the weak variable.

00:31:48.650 --> 00:31:52.890
This coordinates with the weak reference
system so that you don't read a dangling

00:31:52.890 --> 00:31:56.800
pointer or write a pointer to an object
that's already dying and will become

00:31:56.800 --> 00:31:57.260
dangling and not be able to read it.

00:31:57.260 --> 00:31:57.260
This coordinates with the weak reference
system so that you don't read a dangling

00:31:57.260 --> 00:31:57.260
pointer or write a pointer to an object
that's already dying and will become

00:31:57.260 --> 00:31:57.260
dangling and not be able to read it.

00:31:57.260 --> 00:31:57.260
This coordinates with the weak
reference system so that you don't read

00:31:57.260 --> 00:31:57.260
a dangling pointer or write a pointer
to an object that's already dying

00:31:57.260 --> 00:31:57.660
and will become dangling in a minute.

00:31:59.200 --> 00:32:01.380
Of course,
when the optimizer goes to work,

00:32:01.380 --> 00:32:03.260
extra retain-release goes away.

00:32:03.260 --> 00:32:07.470
The compiler knows that load-week already
returns a retain-auto-release value,

00:32:07.510 --> 00:32:10.200
so it doesn't need to
retain auto-release again.

00:32:10.260 --> 00:32:13.640
Optimizer's smart, and your code looks
really simple like this.

00:32:13.820 --> 00:32:17.060
So this is the code you would see
if you looked at the generated code,

00:32:17.190 --> 00:32:19.020
if you traced through
your code in the debugger.

00:32:19.090 --> 00:32:21.490
These are the functions
you'd end up with.

00:32:21.890 --> 00:32:22.800
One final case.

00:32:22.890 --> 00:32:25.160
Let's look at NSError.

00:32:25.300 --> 00:32:30.560
NSError, we have a method returning an
NSError value to an ARC caller.

00:32:30.660 --> 00:32:32.960
What does the compiler do with this code?

00:32:33.080 --> 00:32:34.760
Well, remember what Blaine just said.

00:32:34.810 --> 00:32:38.160
NSError variables are
implicitly auto-releasing.

00:32:38.390 --> 00:32:40.830
Stack variables are implicitly strong.

00:32:40.980 --> 00:32:44.560
We release the strong value
when the method is done.

00:32:44.650 --> 00:32:48.600
And if this was all the compiler did,
you would crash.

00:32:48.720 --> 00:32:50.840
You have the auto-released error value.

00:32:50.890 --> 00:32:53.840
The compiler decided it also
needed to release it again.

00:32:53.920 --> 00:32:55.550
And that's an over-release.

00:32:55.560 --> 00:32:56.780
It doesn't work.

00:32:56.930 --> 00:32:58.980
Luckily, the compiler does not do this.

00:32:59.090 --> 00:33:01.790
The compiler adds that.

00:33:01.850 --> 00:33:06.790
It adds a temporary auto-releasing
variable to catch the value

00:33:06.790 --> 00:33:08.640
coming out of the method.

00:33:08.690 --> 00:33:12.900
Then it stores that value
into the strong stack variable

00:33:13.250 --> 00:33:15.490
and retains and releases it.

00:33:16.090 --> 00:33:18.240
So the upshot is,
even though there's a mismatch

00:33:18.390 --> 00:33:21.130
between auto-releasing and strong,
the compiler is smart

00:33:21.130 --> 00:33:23.870
enough to paper over it,
patch up the problem with

00:33:23.870 --> 00:33:26.300
a temporary variable,
and you don't have to think about it.

00:33:26.370 --> 00:33:28.320
You just write this code, it works.

00:33:28.570 --> 00:33:29.170
Fine.

00:33:29.170 --> 00:33:30.970
NSERA works great.

00:33:31.480 --> 00:33:34.400
If you want to be extra
double special clever,

00:33:34.400 --> 00:33:36.440
you can write this.

00:33:36.440 --> 00:33:39.900
You can explicitly mark your
stack variable auto-releasing.

00:33:39.900 --> 00:33:43.300
Now the compiler doesn't
need a strong temporary,

00:33:43.300 --> 00:33:45.840
doesn't need the extra
retain and release.

00:33:45.840 --> 00:33:48.660
So if you are having a little
bit of performance trouble,

00:33:48.660 --> 00:33:53.080
which you almost certainly won't,
you can add this sort of cue

00:33:53.340 --> 00:33:57.760
to the compiler to help it know
exactly what you want to do.

00:33:59.060 --> 00:34:01.800
So,
we've added a lot of runtime functions

00:34:01.800 --> 00:34:04.560
that the compiler will add to your code.

00:34:04.760 --> 00:34:07.460
You'll see these in your disassembly,
you may see these in

00:34:07.580 --> 00:34:09.940
backtraces or while debugging.

00:34:10.030 --> 00:34:13.900
The basic memory management calls,
of course, retain, release, auto-release.

00:34:14.120 --> 00:34:16.110
They just call the methods.

00:34:16.290 --> 00:34:19.990
The Week Reference System:
Load Week and Store Week to

00:34:20.270 --> 00:34:22.270
read and write week variables.

00:34:23.100 --> 00:34:24.580
Some other calls you might see.

00:34:24.740 --> 00:34:29.490
The NSObject implementation now
lives in the Objective-C runtime.

00:34:29.640 --> 00:34:32.480
So the implementations of
basic NSObject methods,

00:34:32.620 --> 00:34:36.370
basic root class methods,
which is why it's called root alloc,

00:34:36.460 --> 00:34:42.340
root retain, and a half dozen others,
will now show up in backtraces

00:34:42.580 --> 00:34:44.980
and in instruments traces.

00:34:45.100 --> 00:34:49.220
The AutoreleasePool implementation is
also now in the Objective-C runtime

00:34:49.550 --> 00:34:52.600
with the AutoreleasePool
push and pop functions.

00:34:52.650 --> 00:34:56.210
When you write @autoreleasepool,
that's what it looks like.

00:34:57.110 --> 00:35:01.370
And finally, there's a set of functions
much longer than this list,

00:35:01.370 --> 00:35:05.750
which are optimized versions or combined
versions of some of the functions,

00:35:05.970 --> 00:35:08.500
some of the basic operations.

00:35:08.510 --> 00:35:11.500
There's an optimization for
auto-released return values,

00:35:11.500 --> 00:35:13.000
which I'll be talking about later.

00:35:13.000 --> 00:35:16.650
And it uses functions like
auto-release return value and retain

00:35:16.650 --> 00:35:18.840
auto-release said return value.

00:35:18.860 --> 00:35:23.650
And there are other optimizations for
doing a retain and a store or a retain

00:35:23.660 --> 00:35:26.590
without releasing the previous value,
things like that.

00:35:26.620 --> 00:35:28.710
There are lots of these things.

00:35:28.830 --> 00:35:30.080
We'll be adding more in the future.

00:35:30.240 --> 00:35:33.960
Don't freak out when the
compiler adds them to your code.

00:35:34.930 --> 00:35:38.980
Of course, most of these functions
are not for public use.

00:35:39.020 --> 00:35:41.090
They're for the compiler to use.

00:35:41.180 --> 00:35:43.300
They're not declared API.

00:35:43.300 --> 00:35:45.720
So some of these functions
you can use directly.

00:35:45.840 --> 00:35:47.800
The others, don't call them.

00:35:47.880 --> 00:35:50.560
If you do,
the compiler may transform them.

00:35:50.650 --> 00:35:53.380
Because the compiler thinks it
knows what's going on and thinks

00:35:53.380 --> 00:35:54.800
that it called them itself.

00:35:54.800 --> 00:35:56.300
So be careful about that.

00:35:56.300 --> 00:35:57.440
Use the public API.

00:35:57.660 --> 00:36:01.800
Don't use the stuff that you see in
the open source runtime directly.

00:36:02.450 --> 00:36:05.920
Arc modifies the destruction of objects.

00:36:06.000 --> 00:36:09.200
So let's look at what
happens when an object dies.

00:36:09.200 --> 00:36:13.350
Of course, Arc releases your IVRs and
properties automatically for you,

00:36:13.350 --> 00:36:16.630
and it also erases weak
variables automatically.

00:36:16.640 --> 00:36:20.280
So it's modifying the
deallocation process.

00:36:20.320 --> 00:36:24.130
Let's look at everything that
happens to an object as it dies.

00:36:24.440 --> 00:36:28.320
We see the timeline of what happens
during the death of an object.

00:36:28.470 --> 00:36:29.990
Let's look at these in detail.

00:36:30.160 --> 00:36:33.420
The first thing that happens
is release is called,

00:36:33.420 --> 00:36:36.520
and the retain count goes to
zero for the very last time.

00:36:36.550 --> 00:36:38.680
The object is now deallocating.

00:36:38.810 --> 00:36:40.990
It will die.

00:36:41.320 --> 00:36:43.790
Since the object is deallocating,
we don't want to create

00:36:44.170 --> 00:36:47.000
weak pointers to it anymore,
because you'd end up with a

00:36:47.000 --> 00:36:48.830
dangling pointer when you're done.

00:36:48.920 --> 00:36:51.870
So the release method tells
the weak reference system,

00:36:51.880 --> 00:36:53.010
"This object is dying.

00:36:53.300 --> 00:36:56.870
Don't do any weak references
anymore." And then the release

00:36:56.870 --> 00:37:00.140
method calls self-dealloc,
the normal thing.

00:37:00.630 --> 00:37:05.090
Self-dialog starts the dialog chain,
starting with the subclass dialog.

00:37:05.190 --> 00:37:09.340
If you wrote a dialog method,
this is where your code gets called.

00:37:09.400 --> 00:37:13.790
If this is a non-ARC subclass,
this is where their dialog method

00:37:13.790 --> 00:37:19.040
would be calling release methods and
delegate clears and things like that.

00:37:19.110 --> 00:37:23.080
Each subclass calls superdialog,
we walk up the superclass chain,

00:37:23.240 --> 00:37:26.160
and we eventually get to NSObjectDialog.

00:37:26.200 --> 00:37:29.500
NSObjectDialog simply calls
the Objective-C runtime to

00:37:29.690 --> 00:37:31.400
tell that the object is dead.

00:37:31.460 --> 00:37:35.290
It goes through actually a couple
of different function calls here,

00:37:35.290 --> 00:37:37.320
but you end up in ObjectDispose.

00:37:37.390 --> 00:37:41.240
ObjectDispose does the rest
of the destruction work.

00:37:41.240 --> 00:37:45.620
C++ IVARs are destructed,
Arc calls its release method here,

00:37:45.620 --> 00:37:50.930
and associated references and weak
references to this object are cleared.

00:37:51.380 --> 00:37:56.170
The point to note on the ordering is:
The destructors and the

00:37:56.280 --> 00:38:00.560
Arc release are called after
your subclass dialog is called.

00:38:00.640 --> 00:38:04.600
So in your dialog methods,
you can still use your C++ IVARs,

00:38:04.650 --> 00:38:08.270
you can still use your Arc IVARs,
because they aren't dead yet.

00:38:08.400 --> 00:38:11.960
They only die when the
dialog methods are all done,

00:38:11.960 --> 00:38:15.690
and NSObjectDialog calls
the runtime to kill it.

00:38:15.900 --> 00:38:18.560
Finally, Object Dispose calls us free.

00:38:18.560 --> 00:38:21.160
And I hope you all know what free does.

00:38:21.440 --> 00:38:24.040
But this is the final process
to destroy the object,

00:38:24.090 --> 00:38:25.440
reclaim the memory.

00:38:25.450 --> 00:38:27.630
It's gone for good now.

00:38:28.730 --> 00:38:30.600
Let's talk about Arc adoption.

00:38:30.600 --> 00:38:32.880
You've seen in some of the intro talks,
some of the other talks,

00:38:33.010 --> 00:38:36.360
about what your code must
do to adopt Arc code.

00:38:36.680 --> 00:38:40.950
You might have to modify how
the migrator can help you do it.

00:38:41.470 --> 00:38:46.710
There are some low-level tasks that some
of you writing core foundation code,

00:38:46.720 --> 00:38:50.690
for example, also need to modify,
and the migrator does not

00:38:50.700 --> 00:38:52.480
generally help you here.

00:38:52.640 --> 00:38:58.220
So low-level tasks include core
foundation usage may need to be modified.

00:38:58.420 --> 00:39:01.590
If you have a custom
retain-release implementation or

00:39:01.670 --> 00:39:06.250
a custom weak reference system,
those also may need to be adapted or

00:39:06.250 --> 00:39:08.910
removed in order to work with Arc.

00:39:09.450 --> 00:39:11.700
Let's look at core foundation.

00:39:11.700 --> 00:39:14.300
Arc automates Objective-C.

00:39:14.320 --> 00:39:17.620
It does not know about
core foundation code,

00:39:17.620 --> 00:39:19.770
does not understand
core foundation types,

00:39:19.890 --> 00:39:23.940
does not understand core foundation
memory management conventions.

00:39:24.080 --> 00:39:28.190
So if you use core foundation
code or core foundation-like

00:39:28.190 --> 00:39:34.300
objects like the address book
framework or core graphics objects,

00:39:34.460 --> 00:39:38.150
you need to help Arc understand the
memory management that's going on so

00:39:38.150 --> 00:39:43.920
it correctly manages the memory of
these sorts of objects as you use them.

00:39:44.540 --> 00:39:48.480
Let's look at an example of what goes
wrong if you take unmodified core

00:39:48.520 --> 00:39:51.400
foundation code and try and use Arc.

00:39:51.550 --> 00:39:56.320
Here's a simple example we're calling
an address book function that returns

00:39:56.480 --> 00:39:59.400
a retained core foundation string.

00:39:59.530 --> 00:40:00.890
It has "copy" in the name.

00:40:00.940 --> 00:40:05.680
That's core foundation "e" for "returns a
retained object." We are casting it to an

00:40:05.750 --> 00:40:08.400
NSString and assigning it into an IVAR.

00:40:08.400 --> 00:40:11.390
So, looks okay for Arc.

00:40:11.390 --> 00:40:13.400
You know, we should get automatic
memory management.

00:40:13.710 --> 00:40:17.180
Except that Arc doesn't
know what that copy does.

00:40:17.480 --> 00:40:23.400
So, Arc adds a retain and release because
the NSString variable is strong.

00:40:23.400 --> 00:40:26.390
But it didn't know that
there was a copy call.

00:40:26.390 --> 00:40:29.270
It doesn't know there's
another retain in play.

00:40:29.400 --> 00:40:34.400
So, we end up with two retains,
one release, and a leak.

00:40:36.540 --> 00:40:40.410
So,
unmodified core foundation code may leak,

00:40:40.590 --> 00:40:42.180
like that example.

00:40:42.310 --> 00:40:44.770
Or, other code, it'll actually crash.

00:40:45.100 --> 00:40:48.640
Or, if you're very lucky,
it may run correctly.

00:40:48.780 --> 00:40:51.110
Now,
it would be really hard to go through

00:40:51.110 --> 00:40:55.260
your code and find every single place
where you're using core foundation,

00:40:55.350 --> 00:40:59.180
like trying to find
that cast to NSString.

00:40:59.500 --> 00:41:00.640
That would be hard.

00:41:00.750 --> 00:41:02.210
So the compiler helps you out.

00:41:02.250 --> 00:41:04.630
The compiler helps you
out with compile errors,

00:41:04.720 --> 00:41:06.880
because the compiler's good at that.

00:41:07.280 --> 00:41:12.730
Any toll-free bridge cast from a core
foundation type to an Objective-C type

00:41:13.090 --> 00:41:15.680
is an error with the ARC compiler.

00:41:15.720 --> 00:41:16.390
It is disallowed.

00:41:16.620 --> 00:41:17.040
Can't do it.

00:41:17.360 --> 00:41:18.740
Well, most.

00:41:18.840 --> 00:41:20.140
There's one exception
which I'll show you.

00:41:20.250 --> 00:41:23.160
But most of the time, it disallows them.

00:41:23.340 --> 00:41:26.780
So this is your cue at the
points of these errors.

00:41:26.840 --> 00:41:29.110
There's Arc code with
core foundation usage.

00:41:29.540 --> 00:41:32.340
You need to go through
and modify the code,

00:41:32.370 --> 00:41:35.610
modify the cast to tell
Arc what is going on.

00:41:35.960 --> 00:41:39.270
So there are three cases,
three different recipes for how

00:41:39.270 --> 00:41:43.390
to modify your code depending what
you're doing with the CF object.

00:41:43.530 --> 00:41:46.270
First case,
we have a method that returns a core

00:41:46.390 --> 00:41:51.360
foundation object and you didn't use any
other core foundation memory management.

00:41:51.610 --> 00:41:55.330
You just method return an object to you,
you use it, you're done.

00:41:56.980 --> 00:41:59.010
Second case is similar.

00:41:59.160 --> 00:42:05.000
Again, no CF retains or CF releases or
creates or copies in your code,

00:42:05.040 --> 00:42:08.770
but the value came from something
other than a method return,

00:42:08.770 --> 00:42:11.430
like the address book
function we just saw.

00:42:11.530 --> 00:42:15.800
The final case is where you are
calling CF memory management.

00:42:15.980 --> 00:42:20.290
You created a CF object yourself,
you released it, something like that.

00:42:20.390 --> 00:42:21.510
So those are the three cases.

00:42:21.580 --> 00:42:23.800
Let's look at the first one.

00:42:23.990 --> 00:42:28.460
Core Foundation values
returned by methods.

00:42:28.460 --> 00:42:32.340
This is an iOS example
of the UIImage class,

00:42:32.340 --> 00:42:36.150
which has a method that returns
a Core Foundation CGImageRef.

00:42:36.470 --> 00:42:38.160
Okay, fine.

00:42:38.450 --> 00:42:42.400
We call it, we cast it to ID because we
want to store it into an array.

00:42:42.540 --> 00:42:46.200
So this is a case where we have Arc code,
Core Foundation code.

00:42:46.270 --> 00:42:47.400
How does it work?

00:42:47.580 --> 00:42:52.400
The good answer is, in this case,
it works unchanged.

00:42:52.510 --> 00:42:56.400
Arc knows that this was
returned by a method.

00:42:56.680 --> 00:42:59.630
Methods have Cocoa naming conventions,
with Arc knows everything

00:42:59.630 --> 00:43:01.370
about Cocoa naming conventions.

00:43:01.400 --> 00:43:05.400
So it knows that this
Core Foundation object was returned,

00:43:05.630 --> 00:43:08.400
auto-released in this case,
or copied in other cases,

00:43:08.400 --> 00:43:13.840
and so it knows what memory management
to apply to the toll-free bridge flavor

00:43:13.870 --> 00:43:16.400
of the CF object that we just had.

00:43:16.400 --> 00:43:17.330
So this case is a little bit different.

00:43:17.430 --> 00:43:18.400
case works.

00:43:18.400 --> 00:43:19.240
Don't have to think about it.

00:43:19.260 --> 00:43:21.370
No compile error.

00:43:22.830 --> 00:43:26.900
So, simple cast if you got a value
from a method and you aren't

00:43:26.900 --> 00:43:29.700
using other CF memory management.

00:43:29.880 --> 00:43:32.820
Second case,
we have a core foundation value

00:43:32.820 --> 00:43:37.320
they got from something other
than a method returning a CF type.

00:43:37.490 --> 00:43:41.540
Here we have two different flavors
of read an object from array,

00:43:41.670 --> 00:43:45.230
convert it to the other
toll-free bridged flavor,

00:43:45.230 --> 00:43:47.000
and use it as is.

00:43:47.060 --> 00:43:50.740
No memory management,
but no Cocoa convention

00:43:50.740 --> 00:43:53.200
method returning a CF type.

00:43:53.310 --> 00:43:57.000
So here,
the compiler tells you you have CF code.

00:43:57.050 --> 00:43:59.360
You may need to modify this
memory management behavior,

00:43:59.360 --> 00:44:03.850
so it will give you a compile
error for these two casts.

00:44:04.420 --> 00:44:05.620
You don't want any memory management.

00:44:05.730 --> 00:44:07.600
You just want to use the object as is.

00:44:07.870 --> 00:44:09.260
Somebody else is retaining it.

00:44:09.320 --> 00:44:10.100
Just do it.

00:44:10.470 --> 00:44:13.850
The way to say just do it to
the compiler is to tell it,

00:44:14.060 --> 00:44:18.380
"I'm doing a cast which is
bridged." This is a bridge cast

00:44:18.590 --> 00:44:24.580
from core foundation type to
Objective-C type or vice versa.

00:44:25.760 --> 00:44:30.180
So, again, no CF memory management
involved when you use Bridged.

00:44:30.190 --> 00:44:33.990
Of course,
Arc may retain and release the NSString,

00:44:33.990 --> 00:44:35.400
but you don't care whether it does that.

00:44:35.430 --> 00:44:36.940
That's Arc's problem.

00:44:36.940 --> 00:44:40.290
That's not memory management
you need to worry about.

00:44:40.640 --> 00:44:42.260
So that's the second case.

00:44:42.260 --> 00:44:46.360
If you have no CF memory management,
then either it works out of the box,

00:44:46.360 --> 00:44:50.540
or you need to modify your
cast to say it's bridged.

00:44:51.300 --> 00:44:56.700
The final case where your code
wrote CF memory management stuff.

00:44:56.830 --> 00:44:59.680
For example,
that address book function again,

00:44:59.750 --> 00:45:02.520
which is a copy function.

00:45:02.660 --> 00:45:04.500
This is the old code, pre-ARC.

00:45:04.750 --> 00:45:09.270
You copied it as a CF value,
moved it across the toll-free bridge,

00:45:09.450 --> 00:45:11.360
and auto-released it.

00:45:11.480 --> 00:45:12.560
Well, of course, this is ARC.

00:45:12.820 --> 00:45:15.570
We don't have auto-releases
anymore in your code.

00:45:15.720 --> 00:45:18.600
So now we have an unbalanced copy.

00:45:18.640 --> 00:45:22.320
ARC doesn't know it's there
because it doesn't know about core

00:45:22.320 --> 00:45:24.800
foundations memory conventions.

00:45:24.810 --> 00:45:26.180
So how do you modify your code?

00:45:26.300 --> 00:45:27.670
Well, you have a copy.

00:45:27.890 --> 00:45:30.400
You should balance it with a release,
right?

00:45:30.500 --> 00:45:31.600
Right.

00:45:31.740 --> 00:45:34.180
you use a CF bridging release.

00:45:35.800 --> 00:45:38.780
CF Bridging Release is a CF release.

00:45:38.820 --> 00:45:46.900
It balances a previous CF retain
or copy or create CF function.

00:45:46.940 --> 00:45:51.210
And it also safely
transfers the value to Arc.

00:45:51.250 --> 00:45:54.380
So Arc will, of course,
retain or release the

00:45:54.380 --> 00:45:56.020
value as it sees fit.

00:45:56.080 --> 00:46:00.890
And the CF Bridging Release balances
the core foundation copy operation.

00:46:01.100 --> 00:46:02.540
So it's really easy.

00:46:02.820 --> 00:46:05.980
You just write code where
retains and releases balance.

00:46:06.230 --> 00:46:07.920
Copy and release is fine.

00:46:07.940 --> 00:46:12.370
And use the Bridging Release to hand
the value to Arc when you're done.

00:46:13.060 --> 00:46:17.400
Going the other direction,
where we have a copy method,

00:46:17.440 --> 00:46:21.340
we converted it to a CFString,
and then we CF released it.

00:46:21.390 --> 00:46:26.450
Again, Arc knows about the copy method,
but it doesn't know about the CF release,

00:46:26.760 --> 00:46:30.700
so we need to balance the
CF release with another retain.

00:46:30.750 --> 00:46:33.360
And that looks like a CF bridging retain.

00:46:33.620 --> 00:46:37.760
It's just the opposite
of a CF bridging release.

00:46:37.980 --> 00:46:43.450
CF Bridging Retain is balanced by
an explicit CF release in your code,

00:46:43.450 --> 00:46:45.080
like this one here.

00:46:45.090 --> 00:46:46.140
That one up there.

00:46:46.140 --> 00:46:48.040
Whichever screen you're looking at.

00:46:48.060 --> 00:46:52.240
It also safely accepts
the value from Arc,

00:46:52.300 --> 00:46:57.850
so it makes sure that Arc doesn't delete
that copied value before we've got it

00:46:57.850 --> 00:47:00.460
handed over to CF's responsibility.

00:47:00.540 --> 00:47:05.280
So this is the ownership transfer
that you need to use going in and out

00:47:05.300 --> 00:47:10.100
of toll-free bridge code if you have
Core Foundation Memory Management.

00:47:10.210 --> 00:47:11.440
So that's the third case.

00:47:11.460 --> 00:47:16.950
If you have Memory Management and
you're moving code in and out of Arc,

00:47:16.950 --> 00:47:21.210
then use a CF Bridging Retain or a
CF Bridging Release to match the other

00:47:21.470 --> 00:47:23.960
Core Foundation Memory Management you
already have.

00:47:23.990 --> 00:47:30.180
There's one slight caveat to everything
that I just said about Core Foundation.

00:47:30.290 --> 00:47:35.800
The WWCC compiler does not
implement any of what I just said.

00:47:35.830 --> 00:47:41.040
It still has the cast
as an error feature,

00:47:41.040 --> 00:47:45.770
but it uses a different set of functions
for handling memory management transfers

00:47:45.870 --> 00:47:48.510
and telling Arc what is going on.

00:47:48.670 --> 00:47:52.010
So if you go to the
Apple developer website,

00:47:52.270 --> 00:47:54.890
look up the Programming
with Arc Release Notes,

00:47:54.890 --> 00:47:59.220
it will have two sections on
how to manage CF objects and

00:47:59.220 --> 00:48:04.800
how to manage CF objects with
the WWDC compilers and tools.

00:48:04.860 --> 00:48:08.100
In the future, in the next seed release,
some future release,

00:48:08.250 --> 00:48:11.140
you will get what I just said,
and you can go back and watch

00:48:11.210 --> 00:48:14.860
the video again and convert all
your code to use that instead.

00:48:17.160 --> 00:48:20.130
Other low-level things
you may need to modify.

00:48:20.390 --> 00:48:23.460
If you have custom retain
and release methods,

00:48:23.460 --> 00:48:25.600
they must be adapted for Arc.

00:48:25.670 --> 00:48:31.010
The problem is the release method and the
weak reference system need to coordinate

00:48:31.790 --> 00:48:35.490
in order to avoid race conditions
when an object is being destroyed

00:48:35.770 --> 00:48:39.340
and you're trying to read a weak
reference pointer to the same object.

00:48:39.400 --> 00:48:43.160
The release and the weak reference
system need to have multi-thread

00:48:43.160 --> 00:48:47.060
synchronization to make sure
that weak system works correctly.

00:48:47.130 --> 00:48:50.220
If you have custom retain
and release implementations,

00:48:50.270 --> 00:48:53.700
they therefore must evolve or die.

00:48:54.620 --> 00:48:59.110
So if you wanted to evolve your
custom weak reference system,

00:48:59.260 --> 00:49:01.260
there are two new
methods you need to add.

00:49:01.300 --> 00:49:03.940
You need to change most of
the rest of the methods.

00:49:04.220 --> 00:49:05.420
There are subtle race conditions.

00:49:05.500 --> 00:49:08.320
It's actually very difficult
to do any of this correctly.

00:49:08.390 --> 00:49:10.870
Depending what your custom
retain and release do,

00:49:11.020 --> 00:49:12.260
there's no simple recipe.

00:49:12.260 --> 00:49:15.170
It depends if you're using a
local IVAR or if you're using it

00:49:15.170 --> 00:49:18.420
to do teardown or if you're using
it to do special singletons.

00:49:18.560 --> 00:49:21.520
Short answer is we don't recommend it.

00:49:21.690 --> 00:49:24.980
It's possible to modify
a custom reference system

00:49:25.130 --> 00:49:26.700
until it works with weak.

00:49:26.730 --> 00:49:27.380
We don't recommend it.

00:49:27.540 --> 00:49:28.660
It's hard.

00:49:28.690 --> 00:49:31.000
We did it a bunch of times
wrong inside Apple before we

00:49:31.000 --> 00:49:31.800
figured out how to do it right.

00:49:31.880 --> 00:49:35.520
We're pretty sure it's right now.

00:49:36.600 --> 00:49:37.830
We recommend something else.

00:49:37.960 --> 00:49:40.260
We have two other recommendations.

00:49:40.390 --> 00:49:45.130
First recommendation, delete your custom
retain-release implementation.

00:49:45.720 --> 00:49:48.150
NSObject's retainer
release is much faster.

00:49:48.270 --> 00:49:51.590
If yours existed for performance,
you may not need the extra

00:49:51.620 --> 00:49:56.360
performance anymore with faster
machines and faster NSObject code.

00:49:56.440 --> 00:49:59.950
If you had custom teardown logic,
you were releasing stuff when your

00:50:00.120 --> 00:50:04.190
retain count dropped to three,
for example, real code does this.

00:50:04.330 --> 00:50:05.190
Don't do that anymore.

00:50:05.190 --> 00:50:10.360
Use weak variables in Arc to do the
teardown logic you need instead.

00:50:10.480 --> 00:50:14.340
If you have a singleton pattern
using custom retainer release,

00:50:14.410 --> 00:50:18.630
use a simpler singleton pattern that
doesn't have retainer release anymore.

00:50:18.700 --> 00:50:21.350
So, recommendation one, delete it.

00:50:21.450 --> 00:50:24.660
There's one other benefit to deleting
your custom retainer release,

00:50:24.740 --> 00:50:29.300
is that future improvements to retainer
release performance are likely only

00:50:29.300 --> 00:50:34.550
to apply to default retainer release,
not custom retainer release.

00:50:34.670 --> 00:50:37.040
So we may make it faster
and leave you behind.

00:50:37.280 --> 00:50:39.230
So, delete it.

00:50:39.520 --> 00:50:43.900
Recommendation number two,
if you really do need your custom

00:50:43.900 --> 00:50:47.330
retain-release system still,
you can disallow weak

00:50:47.480 --> 00:50:49.270
references to your class.

00:50:49.410 --> 00:50:53.600
You can write this method,
allows weak reference return, no.

00:50:53.800 --> 00:50:59.360
In this case, if somebody tries to form a
weak reference to your object,

00:50:59.470 --> 00:51:01.890
you'll get a crash instead.

00:51:02.340 --> 00:51:04.930
So,
a much simpler transformation if you do

00:51:04.930 --> 00:51:10.140
need your retained release system and
you don't need to use weak references.

00:51:10.330 --> 00:51:12.730
If you want to keep both,
it's really hard and I'm not

00:51:12.730 --> 00:51:14.170
going to explain it here today.

00:51:14.570 --> 00:51:19.720
The last advanced thing you may need to
modify are custom weak reference systems.

00:51:20.060 --> 00:51:22.440
We know several of these
things exist in the wild.

00:51:22.570 --> 00:51:26.080
We found, I forget how many,
in Apple's own frameworks

00:51:26.080 --> 00:51:28.910
of weak reference systems,
some of which were

00:51:28.960 --> 00:51:30.500
actually mostly correct.

00:51:30.500 --> 00:51:33.400
Mostly thread safe,
mostly didn't crash if dalloc

00:51:33.400 --> 00:51:36.540
called retain and release again,
that sort of thing.

00:51:36.770 --> 00:51:43.330
So, one way to adapt your weak reference
system is to replace it with Arc.

00:51:43.640 --> 00:51:47.370
Use Arc weak variables instead
of your weak reference system.

00:51:47.650 --> 00:51:50.320
Well, that's easy, that's good.

00:51:50.490 --> 00:51:53.290
If you like your weak reference system,
if you have a bunch of code

00:51:53.290 --> 00:51:57.910
using whatever your API is,
you can always rewrite it.

00:51:58.010 --> 00:52:03.410
Modify the internal implementation
of your weak system to use our API,

00:52:03.560 --> 00:52:06.450
the load weak and store weak
functions that I mentioned earlier.

00:52:06.650 --> 00:52:10.570
These are public API that
you can use to interface with

00:52:10.980 --> 00:52:13.160
Arc's weak reference system.

00:52:13.250 --> 00:52:15.560
In non-Arc code, I should say.

00:52:15.560 --> 00:52:18.950
If you have Arc code that tries
to say "load weak," compiler

00:52:18.950 --> 00:52:20.790
will not like you very much.

00:52:20.970 --> 00:52:26.600
So here's an example if you were going
to modify your weak reference system.

00:52:26.650 --> 00:52:30.210
Here we have a getter and a
setter and a dealloc method for

00:52:30.210 --> 00:52:33.630
a weak IVAR in non-ARC code.

00:52:34.170 --> 00:52:36.960
We can use the loadWeek
function to read it,

00:52:37.080 --> 00:52:41.890
the storeWeek function to write it,
and this is very, very important,

00:52:42.020 --> 00:52:45.450
the storeWeek function writing
nil when the variable goes out of

00:52:45.450 --> 00:52:49.430
scope to clear the weak reference
machinery and make sure the weak

00:52:49.540 --> 00:52:53.600
reference system doesn't write a
nil to that address sometime later.

00:52:53.740 --> 00:52:58.900
So this is how you would modify a
weak reference system or some weak

00:52:58.980 --> 00:53:02.300
variable if you outside your ARC code.

00:53:04.390 --> 00:53:05.320
Let's look at performance.

00:53:05.470 --> 00:53:08.540
Performance is, of course,
really important for everyone.

00:53:08.690 --> 00:53:11.870
And it's also important for
Arc because for some code,

00:53:11.870 --> 00:53:16.610
we're adding more retains and more
releases than the same manual coded

00:53:16.860 --> 00:53:19.860
code might have had previously.

00:53:19.950 --> 00:53:22.360
So we've improved performance
with a lot of the primitives.

00:53:22.450 --> 00:53:23.950
Retain and release.

00:53:24.090 --> 00:53:25.110
Arc uses retain and release.

00:53:25.290 --> 00:53:26.690
Everybody else uses retain and release.

00:53:27.000 --> 00:53:27.880
We made it faster.

00:53:28.150 --> 00:53:34.120
We made it a lot faster
in Lion and iOS 5.

00:53:35.750 --> 00:53:37.660
Autorelease pool.

00:53:37.770 --> 00:53:40.940
Autorelease pools get used quite a bit.

00:53:41.200 --> 00:53:43.440
There are a lot of loops and code,
things like that,

00:53:43.540 --> 00:53:46.740
that try and go out of their way
to use a few autorelease pools

00:53:46.910 --> 00:53:49.180
instead of one every iteration.

00:53:49.250 --> 00:53:50.300
Well, we didn't like that.

00:53:50.380 --> 00:53:53.740
We said, first of all,
we can make NSAutoreleasePool faster,

00:53:53.920 --> 00:53:55.140
and we did that.

00:53:55.330 --> 00:53:59.300
And then we said, at AutoreleasePool,
we can make it way faster.

00:53:59.360 --> 00:54:03.060
It's way faster because it doesn't
need an AutoreleasePool fake object.

00:54:03.250 --> 00:54:07.700
It doesn't need obcmsend
alloc init drain.

00:54:07.790 --> 00:54:12.710
So the @AutoreleasePool construct is
about six times faster than the old

00:54:12.760 --> 00:54:16.080
NSAutoreleasePool alloc init was.

00:54:19.110 --> 00:54:23.100
So the moral of this slide,
if you have a loop that's, you know,

00:54:23.100 --> 00:54:24.960
you're trying not to
use auto-release pools,

00:54:25.080 --> 00:54:25.680
just throw them in.

00:54:25.760 --> 00:54:26.280
It's cheap.

00:54:26.350 --> 00:54:29.040
It's like as fast as a function call now.

00:54:30.670 --> 00:54:32.880
Last example I want to
show you for performance is

00:54:32.990 --> 00:54:34.920
auto-release return values.

00:54:35.160 --> 00:54:36.380
We've made this faster.

00:54:36.630 --> 00:54:38.600
Let me explain what I mean.

00:54:38.770 --> 00:54:43.150
This code has a getter method that
returns an auto-release result,

00:54:43.360 --> 00:54:46.760
and we have a caller which is
calling the getter method and

00:54:46.760 --> 00:54:49.100
retaining the value it got back.

00:54:49.160 --> 00:54:52.900
Well, we have this auto-release which
immediately gets retained again.

00:54:53.040 --> 00:54:54.130
This is just extra work.

00:54:54.290 --> 00:54:57.670
This is just trying to get
the interface so it's clean.

00:54:57.670 --> 00:54:59.590
We don't have to think
about memory management.

00:54:59.690 --> 00:55:01.940
But the auto-release
and retain are wasted,

00:55:02.120 --> 00:55:04.790
and the object lives longer
than it might have to because

00:55:04.790 --> 00:55:06.440
it's in the auto-release pool.

00:55:06.470 --> 00:55:08.630
And on iOS,
we tell people don't auto-release

00:55:08.630 --> 00:55:11.340
if you don't have to because
there's that extra cost.

00:55:11.370 --> 00:55:14.250
We can do better,
and we have done better.

00:55:14.370 --> 00:55:18.850
The Arc compiler will
write this code this way.

00:55:19.280 --> 00:55:24.680
Two Objective-C runtime functions:
auto-releasing a return value

00:55:24.680 --> 00:55:27.030
is a specialized function,
and retaining a return value

00:55:27.030 --> 00:55:29.440
that you got auto-released.

00:55:29.620 --> 00:55:34.130
Two separate operations that
coordinate to optimize it.

00:55:34.250 --> 00:55:36.230
The actual implementation is really cool.

00:55:36.230 --> 00:55:39.140
It's really clever and
I wish I had thought of it,

00:55:39.140 --> 00:55:39.970
but I didn't.

00:55:40.270 --> 00:55:43.440
These two functions,
the function in the getter method

00:55:43.630 --> 00:55:48.430
looks up the call stack to see
what the caller is about to do with

00:55:48.470 --> 00:55:50.650
the value that it just retained.

00:55:54.730 --> 00:55:58.240
If these two functions see
each other on the call stack,

00:55:58.280 --> 00:55:59.660
then we optimize it.

00:55:59.660 --> 00:56:04.250
The return value is saved in thread local
storage for the other function to see,

00:56:04.250 --> 00:56:06.630
and we don't auto-release
and we don't retain.

00:56:06.770 --> 00:56:09.040
That's a really good optimization.

00:56:09.080 --> 00:56:11.780
What if you have mixed code
where only some of it is

00:56:11.780 --> 00:56:13.700
built with the ARC compiler?

00:56:13.740 --> 00:56:15.240
You might have this.

00:56:15.260 --> 00:56:18.840
The getter method has
the optimized function,

00:56:18.860 --> 00:56:21.740
but the caller is just calling
retain because it's not ARC.

00:56:21.760 --> 00:56:23.340
What happens then?

00:56:23.350 --> 00:56:26.150
The two sides look for each other,
and the caller says,

00:56:26.250 --> 00:56:29.740
the getter method says, "Whoops,
this guy doesn't know what I'm doing.

00:56:29.740 --> 00:56:30.660
He's not smart.

00:56:30.730 --> 00:56:31.950
He's not optimized.

00:56:32.140 --> 00:56:34.920
So I'll do the old
thing." No optimization,

00:56:34.920 --> 00:56:38.470
just call, auto-release,
and retain as usual.

00:56:39.060 --> 00:56:44.660
So if we have the caller and the callee
are both arc or they're both properties,

00:56:44.660 --> 00:56:47.080
then the optimization will kick in.

00:56:47.190 --> 00:56:48.240
And what happens?

00:56:48.300 --> 00:56:50.900
It gets something like this much faster.

00:56:51.010 --> 00:56:54.000
The first chart --

00:56:54.770 --> 00:56:55.970
It's great.

00:56:56.070 --> 00:57:02.300
The first chart is the expense of the
extra auto-release and the extra retain.

00:57:02.300 --> 00:57:05.590
And of course, the optimized code,
just looking at the memory in the stack,

00:57:05.710 --> 00:57:08.200
stuffing in thread local storage,
that's really fast.

00:57:08.200 --> 00:57:12.340
So in the optimized case,
the extra overhead of

00:57:12.340 --> 00:57:15.500
auto-release retain is just gone.

00:57:15.570 --> 00:57:18.230
So as more people adopt Arc,
the optimization will

00:57:18.310 --> 00:57:19.590
kick in in more places.

00:57:19.760 --> 00:57:21.010
So we're really looking forward to that.

00:57:21.740 --> 00:57:25.090
And that's Arc in Objective-C,
Automated Reference Counting with

00:57:25.460 --> 00:57:29.180
ownership qualifiers so you think
about your object-graph's relationships

00:57:29.180 --> 00:57:30.990
rather than retain-release.

00:57:30.990 --> 00:57:34.380
If you have low-level memory
management like Core Foundation,

00:57:34.380 --> 00:57:35.630
you may need to adapt.

00:57:35.740 --> 00:57:39.550
And Arc has costs for some code,
but we have performance improvements

00:57:39.550 --> 00:57:41.350
to balance some of the costs.

00:57:43.300 --> 00:57:46.450
For more information,
definitely visit the Programming

00:57:46.450 --> 00:57:49.380
with Arc release notes
on the developer website.

00:57:49.440 --> 00:57:52.640
If you have questions,
we don't have time for QA today,

00:57:52.820 --> 00:57:56.360
but you can find me on the
Apple Dev Forums under the

00:57:56.360 --> 00:57:59.990
Developer Tools sections,
or you can contact the

00:58:00.060 --> 00:58:02.870
DevTools evangelist,
Mike Jurowicz,

00:58:02.870 --> 00:58:05.080
at the email address shown.

00:58:05.910 --> 00:58:08.720
Related sessions and the
videos you may want to watch,

00:58:08.880 --> 00:58:12.500
the Arc intro session, of course,
more details about Blocks and

00:58:12.500 --> 00:58:17.290
Grand Central Dispatch in practice,
and, of course, Arc is LLVM only,

00:58:17.490 --> 00:58:21.040
so move to the LLVM compiler,
visit the session there.

00:58:21.150 --> 00:58:22.690
Thank you.
WEBVTT

00:00:10.200 --> 00:00:11.780
Good afternoon.

00:00:11.780 --> 00:00:13.850
Welcome to the talk on
multitasking this year.

00:00:14.020 --> 00:00:15.060
I'm Dave Myszewski.

00:00:15.140 --> 00:00:19.020
I manage an iOS performance team
and I'll be joined by my colleague,

00:00:19.080 --> 00:00:21.420
Charles Srisuwananukorn.

00:00:22.520 --> 00:00:25.950
So today we're going to
tell you about multitasking.

00:00:25.960 --> 00:00:31.080
So, and in particular, so multitasking,
as you know,

00:00:31.080 --> 00:00:35.170
provides a lot of great services to
enable your application to run in the

00:00:35.170 --> 00:00:38.880
background when it needs to and to
ensure that applications don't run in

00:00:39.020 --> 00:00:40.790
the background when they don't need to.

00:00:40.800 --> 00:00:43.320
So when your application
goes to the background,

00:00:43.320 --> 00:00:46.760
they're suspended and not running,
which means that we have really

00:00:46.760 --> 00:00:49.590
great performance because you don't
have a lot of things going on in

00:00:49.590 --> 00:00:51.660
the background that are using,
you know,

00:00:51.660 --> 00:00:54.720
you don't have 50 things using 1% of
the CPU and a bad user experience.

00:00:54.720 --> 00:00:57.270
And it's also been really
terrific for battery life.

00:00:57.380 --> 00:01:01.700
So applications run when they need to
and don't run when they don't need to.

00:01:03.490 --> 00:01:07.120
Multitasking is supported
on all iOS devices today.

00:01:07.120 --> 00:01:10.640
So the iPad, iPad 2,
all versions of the iPhone

00:01:10.640 --> 00:01:13.610
that iOS 5 supports,
and the iPod Touch as well.

00:01:13.890 --> 00:01:16.680
So in 4.2, everything supports it.

00:01:16.930 --> 00:01:20.740
And today we're not going to tell you
a whole lot about particular APIs.

00:01:20.740 --> 00:01:24.000
We're going to focus our
session today on how to make a

00:01:24.000 --> 00:01:26.180
really great multitasking app.

00:01:26.860 --> 00:01:29.380
So we had a couple of talks
last year that if you want to

00:01:29.380 --> 00:01:32.360
review on iTunes after the show,
you can do that.

00:01:32.590 --> 00:01:35.640
But today we're going to focus
on how you make your application

00:01:35.640 --> 00:01:37.640
really optimized for multitasking.

00:01:37.700 --> 00:01:40.840
And we have a few different ways
in which we'll talk about making

00:01:40.840 --> 00:01:42.720
your application really great.

00:01:42.830 --> 00:01:45.550
So to start out,
we'll review the application lifecycle,

00:01:45.660 --> 00:01:49.780
and then talk about making that great
application that's in the background.

00:01:49.900 --> 00:01:53.380
And then talk a little bit
about the multitasking services,

00:01:53.380 --> 00:01:55.870
including the new services in iOS 5.

00:01:56.160 --> 00:02:00.040
So we'll start out with
the application lifecycle.

00:02:00.200 --> 00:02:02.900
Things work by and large
like they did with iOS 4,

00:02:02.900 --> 00:02:04.740
except with one change that
we'll get to in a moment.

00:02:04.910 --> 00:02:08.550
But when you're sitting here on the home
screen and your user launches the app,

00:02:08.550 --> 00:02:11.500
of course the application isn't running.

00:02:11.500 --> 00:02:14.360
You will get, when the application
comes to the foreground,

00:02:14.390 --> 00:02:17.640
an application did finish
launching with options delegate,

00:02:17.670 --> 00:02:20.890
and then the application becomes active.

00:02:21.010 --> 00:02:26.080
So that's the lifecycle that you're all
used to and has been the same since 2.0.

00:02:26.080 --> 00:02:27.910
Then when you have some
sort of interruption,

00:02:27.910 --> 00:02:30.470
which will become a lot less
common in iOS 5 because of

00:02:30.470 --> 00:02:34.260
our new notification center,
but it still happens in, say,

00:02:34.340 --> 00:02:37.110
the multitasking UI,
your application will get the

00:02:37.210 --> 00:02:39.820
application will resign active callback.

00:02:39.820 --> 00:02:42.660
So something's interrupting
your application,

00:02:42.660 --> 00:02:45.600
and your application knows to
maybe stop playing that game

00:02:45.600 --> 00:02:47.120
or to perhaps change its UI.

00:02:48.740 --> 00:02:51.540
And then when you change
from your application,

00:02:51.540 --> 00:02:54.080
you'll start out as the active app.

00:02:54.080 --> 00:02:57.660
Your application goes into the background
because you hit the home button.

00:02:57.660 --> 00:03:00.510
To get there, the application,
you'll get an application

00:03:00.510 --> 00:03:02.180
did resign active callback.

00:03:02.200 --> 00:03:04.150
And then your application
goes into the background and

00:03:04.150 --> 00:03:05.420
runs for some amount of time.

00:03:05.640 --> 00:03:09.510
So this is when you will want to do
things like save your state and clean

00:03:09.570 --> 00:03:13.750
up things in your application to
prepare it to go into the background.

00:03:13.870 --> 00:03:17.170
So you'll get an application
did enter background callback.

00:03:17.190 --> 00:03:22.560
And then once you're done with that,
Springboard will suspend the application.

00:03:22.570 --> 00:03:25.720
Now, you don't get a notification
that tells you you're suspended.

00:03:25.720 --> 00:03:29.270
Just presume that when you finish with
the application did enter background

00:03:29.270 --> 00:03:31.780
that your application is finished
doing everything that it needs to

00:03:31.780 --> 00:03:34.420
do when it goes into the background.

00:03:34.470 --> 00:03:37.020
So there's no notification here.

00:03:37.030 --> 00:03:39.270
Then switching to an
app is very symmetric.

00:03:39.270 --> 00:03:43.170
When you're suspended,
the user launches your app either through

00:03:43.180 --> 00:03:45.300
the app switcher or the home screen.

00:03:45.300 --> 00:03:48.700
You'll get the app--again,
no notification that you started running.

00:03:48.700 --> 00:03:51.320
And the moment you start running,
you'll get an application will

00:03:51.320 --> 00:03:53.510
enter foreground delegate callback.

00:03:53.510 --> 00:03:56.900
And then, of course,
your application will become active.

00:03:57.030 --> 00:04:00.030
So that's the same basic
lifecycle for an application.

00:04:00.150 --> 00:04:04.370
And that's the same as
what it was in iOS 4.

00:04:04.930 --> 00:04:08.260
Now in iOS 5, we're doing one thing a
little bit differently,

00:04:08.280 --> 00:04:11.560
and that's we're handling
the device lock differently.

00:04:11.560 --> 00:04:15.630
So what we found with iOS 4 is
that if you lock over the device,

00:04:15.780 --> 00:04:19.500
the application continued running
while the device is locked.

00:04:19.630 --> 00:04:22.410
Now iOS, you know,
even when the screen is off,

00:04:22.540 --> 00:04:24.500
is a fairly dynamic system.

00:04:24.500 --> 00:04:27.610
It will wake up periodically
to handle things like push

00:04:27.610 --> 00:04:32.500
notifications that happen,
or if you have a region monitoring with,

00:04:32.580 --> 00:04:36.600
say, the new Reminders UI that allows
you to do location-based reminders,

00:04:36.600 --> 00:04:39.390
or some other third-party application
that does a similar thing,

00:04:39.680 --> 00:04:42.500
then the application--then the device
will wake up and do some amount

00:04:42.500 --> 00:04:44.220
of work with the screen is off.

00:04:44.380 --> 00:04:47.830
And as an application,
you don't necessarily know how

00:04:47.830 --> 00:04:52.400
to distinguish that lock screen
where in the past you would get

00:04:52.400 --> 00:04:58.120
an application did resign active,
or application will resign active,

00:04:58.120 --> 00:05:00.720
from your application really being idle.

00:05:00.920 --> 00:05:06.080
So what we had is that some
application might talk to the network

00:05:06.090 --> 00:05:10.470
inadvertently or enable the GPS,
and things like that had

00:05:10.560 --> 00:05:11.950
an impact on battery life.

00:05:12.110 --> 00:05:14.990
So what we did now is when you
touch that lock screen button,

00:05:15.100 --> 00:05:17.970
you'll get the application
will resign active like before,

00:05:18.070 --> 00:05:21.000
but now your application
will enter the background.

00:05:21.000 --> 00:05:23.460
And then when the user
hits the home button,

00:05:23.460 --> 00:05:26.000
the application will say suspended.

00:05:26.000 --> 00:05:29.800
So we won't change from that suspended
state until the user unlocks the

00:05:29.800 --> 00:05:32.000
device and goes to your application.

00:05:32.000 --> 00:05:33.900
So that's one thing
that's different in iOS 5.

00:05:33.900 --> 00:05:38.550
iOS 5 than iOS 4,
and it helps improve our battery life.

00:05:39.680 --> 00:05:42.360
Now of course for all of these
app lifecycle notifications,

00:05:42.360 --> 00:05:46.100
or delegate callbacks rather,
there's a corresponding notification.

00:05:46.240 --> 00:05:48.130
These are all unchanged from iOS 5.

00:05:48.220 --> 00:05:52.330
So for your application
did enter background,

00:05:52.420 --> 00:05:54.650
for example,
you may have some cache that's

00:05:54.650 --> 00:05:57.670
very well divorced from your
UI application delegate.

00:05:57.960 --> 00:06:00.900
And for something like that
where you want to clear a cache,

00:06:00.900 --> 00:06:04.120
you can use the UI application
did enter background notification.

00:06:04.290 --> 00:06:06.740
And there's a few other ways that
you can handle caches that we'll get

00:06:06.740 --> 00:06:08.130
to a little bit later in the talk.

00:06:08.200 --> 00:06:11.710
Now that covers the case where
you go into the background and

00:06:11.710 --> 00:06:13.200
you don't continue running.

00:06:13.200 --> 00:06:17.120
But of course we provide various
facilities for you to continue

00:06:17.120 --> 00:06:19.200
running into the background.

00:06:19.200 --> 00:06:22.960
So you can finish the current
task that you're in the middle of.

00:06:22.960 --> 00:06:27.480
You can finish playing audio,
for example, until the user pauses you.

00:06:27.480 --> 00:06:29.930
We provide some external
triggers for you to run on.

00:06:30.030 --> 00:06:34.380
So things like location notifications
and newsstand is another one that will

00:06:34.380 --> 00:06:38.100
allow you to download some content in
the background if you're a magazine user.

00:06:38.100 --> 00:06:40.960
So you can run in the background if
you're a magazine developer or newspaper.

00:06:40.960 --> 00:06:44.280
And we have in VoIP apps some
targeted networking events

00:06:44.280 --> 00:06:46.080
that wake up the devices.

00:06:46.160 --> 00:06:51.040
So that's kind of three general ways
in which you run in the background.

00:06:51.040 --> 00:06:54.480
The most common one, though,
is what we call task completion.

00:06:54.480 --> 00:06:57.100
And that merely lets you finish
doing whatever it was that the

00:06:57.170 --> 00:06:58.760
user was doing in the foreground.

00:06:58.760 --> 00:07:02.420
So you might finish uploading photos,
for example.

00:07:02.420 --> 00:07:04.280
So when the user is switched
away from their app,

00:07:04.280 --> 00:07:05.470
they press the home button.

00:07:05.470 --> 00:07:07.430
Then you're in that
background running state.

00:07:07.430 --> 00:07:12.640
But rather than being suspended,
you continue finishing those photos.

00:07:12.640 --> 00:07:16.020
And then once you've uploaded the photos,
then your upload is completed.

00:07:16.020 --> 00:07:17.840
You declare that you're done.

00:07:17.840 --> 00:07:19.930
And then your application is suspended.

00:07:23.090 --> 00:07:26.740
And background audio works very
much the same way in that the user

00:07:26.740 --> 00:07:30.960
is playing audio in the foreground,
then the user presses the home button,

00:07:30.960 --> 00:07:33.910
and you continue playing audio
until the user declares that

00:07:33.910 --> 00:07:37.080
they're done by pausing the music,
or maybe you get an interruption,

00:07:37.080 --> 00:07:38.680
like a phone call.

00:07:38.760 --> 00:07:40.710
And then the application is suspended.

00:07:40.860 --> 00:07:44.550
So all of our multitasking modes,
whether it's audio or

00:07:44.650 --> 00:07:48.320
location or task completion,
provide mechanisms like this that let

00:07:48.320 --> 00:07:51.950
you keep doing what you were doing
until you're done with the task at hand,

00:07:51.950 --> 00:07:53.780
or until the user declares
that they're done,

00:07:53.780 --> 00:07:56.340
like they're done playing audio.

00:07:56.700 --> 00:08:59.900
[Transcript missing]

00:09:00.330 --> 00:09:04.570
So first I'm going to start with
system resources and talk about how

00:09:04.570 --> 00:09:08.790
iOS manages system resources and tries
to mediate access to these resources.

00:09:08.920 --> 00:09:12.060
Some of the APIs that you may not
be familiar with that would help

00:09:12.140 --> 00:09:15.810
you manage these resources and
some other things that your app

00:09:15.810 --> 00:09:18.260
can do to help manage resources.

00:09:18.310 --> 00:09:23.490
And in particular I'm going to focus on
a couple of particularly tricky areas,

00:09:23.490 --> 00:09:26.970
and specifically memory and OpenGL.

00:09:27.220 --> 00:09:29.730
And then after that Dave's going
to come back and tell us more about

00:09:29.730 --> 00:09:31.880
gracefully resuming from the background.

00:09:31.950 --> 00:09:33.830
So let's talk about system resources.

00:09:34.100 --> 00:09:37.620
The way to think about system resources
is that all the system resources on a

00:09:37.620 --> 00:09:40.010
device are shared by all applications.

00:09:40.170 --> 00:09:43.470
Like foreground applications and
background applications all share

00:09:43.470 --> 00:09:45.120
these really limited resources.

00:09:45.310 --> 00:09:47.720
And so the more resources you use,
the fewer resources are

00:09:47.720 --> 00:09:48.640
left for other people.

00:09:48.640 --> 00:09:51.340
So just as if you're sharing
a birthday cake or something,

00:09:51.340 --> 00:09:54.760
the more birthday cake you have,
the less there is for everybody else.

00:09:54.900 --> 00:09:56.900
And so to keep everybody happy,
you want to make sure

00:09:56.900 --> 00:09:57.140
everybody has a birthday cake.

00:09:57.140 --> 00:10:04.700
And so the last thing you want to be
is that kid who eats all the cake and

00:10:04.700 --> 00:10:06.550
doesn't leave anything for anybody else.

00:10:06.660 --> 00:10:09.720
So again, all applications on the device,
foreground, background,

00:10:09.720 --> 00:10:12.100
system applications,
share system resources.

00:10:12.100 --> 00:10:16.540
And this includes resources that
you may already be familiar with,

00:10:16.540 --> 00:10:17.820
like CPU and IO.

00:10:17.820 --> 00:10:20.660
There's a limited amount
of bandwidth to flash.

00:10:20.680 --> 00:10:24.810
And so you have to share that bandwidth
among the different applications.

00:10:24.940 --> 00:10:26.140
And memory.

00:10:26.280 --> 00:10:27.120
But it also includes some
of the other things that you

00:10:27.120 --> 00:10:27.120
might want to be aware of.

00:10:27.120 --> 00:10:28.890
So again, there's some resources that
you may not have thought of,

00:10:29.020 --> 00:10:31.910
like the GPU and network.

00:10:32.230 --> 00:10:35.310
So again, especially on these devices
over the cellular network,

00:10:35.390 --> 00:10:37.800
there's a very limited amount of
bandwidth that needs to be shared

00:10:37.800 --> 00:10:40.290
among different applications.

00:10:42.210 --> 00:10:46.340
Now, iOS will prioritize some of these
resources for the foreground app.

00:10:46.590 --> 00:10:48.790
So when your application
is in the foreground and,

00:10:48.790 --> 00:10:52.700
say, it wants some time on the CPU,
at the same time that a background

00:10:52.700 --> 00:10:56.470
application wants some time on the CPU,
iOS will actually prioritize

00:10:56.590 --> 00:11:01.090
your application higher and
give your app time on the CPU.

00:11:01.500 --> 00:11:04.900
Similarly, with I/O,
if your app wants to do I/O while a

00:11:04.900 --> 00:11:08.760
background application wants to do I/O,
the foreground application wins.

00:11:08.880 --> 00:11:13.040
Now, there are also some resources that
are just really difficult to manage,

00:11:13.070 --> 00:11:15.040
and so they're just completely
off limits while your

00:11:15.040 --> 00:11:18.640
application is in the background,
and in particular, the GPU.

00:11:18.740 --> 00:11:21.800
So if your application tries
to use OpenGL while it's

00:11:21.800 --> 00:11:24.830
running in the background,
the system can't efficiently

00:11:24.830 --> 00:11:27.640
manage that between the foreground
and background applications,

00:11:27.750 --> 00:11:29.340
and so it'll terminate your application.

00:11:29.340 --> 00:11:30.960
So this is something to keep in mind.

00:11:31.050 --> 00:11:36.300
And other resources, specifically memory,
the system does try to

00:11:36.300 --> 00:11:40.170
manage as best as it can,
but there's a lot that your application

00:11:40.170 --> 00:11:42.980
can do to help the system manage memory.

00:11:43.040 --> 00:11:45.750
Some APIs that it could use,
and also just freeing up memory

00:11:45.750 --> 00:11:48.400
so that when your application
is suspended in the background,

00:11:48.530 --> 00:11:53.010
there's more memory for other
apps on the system to use.

00:11:53.700 --> 00:11:56.140
And so that brings us now to memory,
and I want to talk more

00:11:56.260 --> 00:11:58.240
about this in detail.

00:11:58.340 --> 00:12:00.140
So again,
apps share a very limited amount

00:12:00.140 --> 00:12:01.440
of memory on these devices.

00:12:01.640 --> 00:12:06.040
So iOS 5 supports everything from an
iPod Touch to an iPhone to an iPad,

00:12:06.040 --> 00:12:07.740
and they all have different
amounts of memory,

00:12:07.850 --> 00:12:10.860
and some of them have a very
limited amount of memory.

00:12:10.950 --> 00:12:13.960
And so you have to keep this in mind
when you're developing your application.

00:12:14.080 --> 00:12:19.900
And iOS will ensure that the device
has the memory it needs to function.

00:12:19.900 --> 00:12:23.790
So even though there's this limited
amount of memory on the device,

00:12:23.950 --> 00:12:26.840
it will try to make sure that
the foreground application

00:12:26.840 --> 00:12:29.290
or a system processor,
whatever that needs memory,

00:12:29.340 --> 00:12:31.700
can get that memory when it needs it.

00:12:31.820 --> 00:12:33.840
And to do that, you know,
it does a couple of things.

00:12:33.890 --> 00:12:36.640
It first sends running
apps memory warnings,

00:12:36.670 --> 00:12:38.990
asking them to free up memory.

00:12:39.250 --> 00:12:43.430
And if it still needs to reclaim
memory when it's under memory pressure,

00:12:43.590 --> 00:12:47.670
then it starts terminating applications
one by one until it has enough

00:12:47.670 --> 00:12:51.500
memory for the foreground app or
the system process to proceed.

00:12:51.500 --> 00:12:54.000
And so you kind of want to
avoid it being terminated,

00:12:54.000 --> 00:12:55.790
if possible,
because then your application

00:12:55.800 --> 00:12:59.640
has to relaunch completely when
it comes back to the foreground.

00:12:59.990 --> 00:13:02.200
So I want to talk a little bit
more about memory warnings.

00:13:02.200 --> 00:13:05.740
If you haven't encountered
memory warnings before,

00:13:05.860 --> 00:13:08.580
quite simply,
iOS sends running applications

00:13:08.730 --> 00:13:12.540
a notification saying,
"Hey, memory is tight right now.

00:13:12.540 --> 00:13:16.040
"Please free up some memory." And so
this is the first thing it does

00:13:16.040 --> 00:13:18.790
to try and free up some memory.

00:13:18.930 --> 00:13:23.700
And we did a lot of work in iOS
5 with the memory warning system,

00:13:23.810 --> 00:13:26.830
and your application should now
only get memory warnings when it's

00:13:26.960 --> 00:13:29.640
absolutely crucial to free memory.

00:13:29.740 --> 00:13:33.070
So when you get that warning, you know,
do please free up as much memory

00:13:33.070 --> 00:13:37.180
as you can because you may not get
another chance to free up memory.

00:13:37.340 --> 00:13:40.100
Now,
I want to revisit that first point a bit.

00:13:40.150 --> 00:13:44.090
I said iOS sends notifications to
running applications to free memory.

00:13:44.420 --> 00:13:46.700
And as Dave said earlier,
when your application is

00:13:46.700 --> 00:13:49.290
sitting in the background,
it's suspended,

00:13:49.510 --> 00:13:51.740
so it's not actually running on the CPU.

00:13:51.890 --> 00:13:55.010
And this is a bit of a subtle point
because if you're using a whole bunch

00:13:55.010 --> 00:13:58.300
of memory when your application goes
in the background and is suspended,

00:13:58.410 --> 00:14:00.980
it'll be sitting there in the
background using that memory,

00:14:00.980 --> 00:14:04.410
and it won't get a chance to
actually free that memory.

00:14:05.170 --> 00:14:07.650
So when should you actually
free up your memory?

00:14:07.780 --> 00:14:11.490
Well, when your app goes into the
background before it's suspended.

00:14:11.560 --> 00:14:13.430
So at that point,
you should just free up as

00:14:13.430 --> 00:14:15.050
much of your memory as you can.

00:14:15.310 --> 00:14:19.000
But there's this big tradeoff
that you should keep in mind.

00:14:19.140 --> 00:14:23.440
To help your--to help your
application free up memory,

00:14:23.580 --> 00:14:27.730
iOS itself and some of the frameworks
in iOS will actually help--will

00:14:27.730 --> 00:14:33.080
free up some memory on your behalf,
and we'll talk a little bit about

00:14:33.980 --> 00:14:37.020
And what's more,
applications that end up using less

00:14:37.170 --> 00:14:40.640
than 16 megabytes of dirty memory
while sitting in the background will

00:14:40.640 --> 00:14:43.660
actually have their dirty memory
written out to disk and will have

00:14:43.660 --> 00:14:48.030
almost no memory footprint at all when
they're sitting in the background.

00:14:48.140 --> 00:14:50.600
And that number is subject to change.

00:14:50.950 --> 00:14:55.210
And here's that tradeoff that I alluded
to earlier and didn't talk much about,

00:14:55.330 --> 00:14:59.880
but when you're freeing up memory,
you should always balance the

00:14:59.890 --> 00:15:03.700
memory footprint in the background
with the speed to resume.

00:15:03.830 --> 00:15:06.280
Because if you end up freeing so
much memory when your application

00:15:06.280 --> 00:15:08.720
goes to the background,
that it takes just as long

00:15:08.720 --> 00:15:12.790
to resume your application as
to relaunch it from scratch,

00:15:12.980 --> 00:15:14.740
then we haven't really gained much.

00:15:14.880 --> 00:15:19.010
So now I want to talk a little bit more
about what iOS and the system does for

00:15:19.030 --> 00:15:22.610
you and for your application as your
application goes in the background so

00:15:22.620 --> 00:15:26.530
you can take better advantage of iOS.

00:15:26.550 --> 00:15:29.980
So first I want to talk
about view backing stores.

00:15:30.110 --> 00:15:35.410
So imagine that this multitasking icon
that we have here is a custom drawn view.

00:15:35.680 --> 00:15:37.450
So it's a subclass of UIView.

00:15:37.600 --> 00:15:41.210
It overrides DrawRect and it uses
core graphics to draw the graphics

00:15:41.210 --> 00:15:43.280
that you see here on the screen.

00:15:43.280 --> 00:15:44.630
So let's break this up
into its constituent parts.

00:15:44.740 --> 00:15:45.020
hearts.

00:15:46.710 --> 00:15:50.730
There's that UI view,
which again is that subclass custom view.

00:15:50.860 --> 00:15:55.790
And then there's the bitmap image data
that's actually displayed to the screen.

00:15:55.940 --> 00:16:01.100
So that multitasking icon,
the blue icon now is that image data.

00:16:01.100 --> 00:16:03.330
And it turns out that in
addition to these two pieces,

00:16:03.330 --> 00:16:05.010
there's also a CA layer.

00:16:05.060 --> 00:16:08.710
So UI view has a CA layer,
and the CA layer actually has

00:16:08.740 --> 00:16:12.510
the big bitmap backing store.

00:16:14.540 --> 00:16:18.530
And it turns out that every UI view
on the system has a CA layer.

00:16:18.550 --> 00:16:23.750
And then these custom views that override
DrawRect and draw their own contents

00:16:23.810 --> 00:16:28.730
have what we call this backing store,
this bitmap backing store.

00:16:29.710 --> 00:16:34.470
And the Bitmap Backing
Store is actually managed by

00:16:34.470 --> 00:16:37.260
Windows Server and Core Animation.

00:16:37.360 --> 00:16:40.540
And when your application
goes into the background,

00:16:40.600 --> 00:16:43.750
it can actually mark that backing
store as something that can be

00:16:43.750 --> 00:16:49.040
reclaimed by iOS while your application
is suspended if it needs it.

00:16:49.070 --> 00:16:52.430
So even if your application is suspended,
there's this big chunk of memory in

00:16:52.560 --> 00:16:56.390
your application space that iOS can
actually reclaim if it needs to.

00:16:56.520 --> 00:17:00.100
And it turns out that this
backing store can be pretty big.

00:17:00.300 --> 00:17:02.880
And of the three pieces here,
the UI view, the CA layer,

00:17:02.880 --> 00:17:06.440
and the backing store,
the backing store usually ends up

00:17:06.440 --> 00:17:08.620
being the biggest part of this.

00:17:08.710 --> 00:17:11.980
And so you can imagine that this
is--this can free up quite a bit of

00:17:11.980 --> 00:17:15.160
memory or make quite a bit of memory
available to the system when your

00:17:15.230 --> 00:17:16.920
application is in the background.

00:17:17.050 --> 00:17:20.630
If the contents or the backing store was
reclaimed and used for something else

00:17:20.680 --> 00:17:23.740
while your app was in the background,
when your application

00:17:23.900 --> 00:17:26.240
resumes to the foreground,
iOS will call the draw

00:17:26.300 --> 00:17:27.320
rect again to get it back.

00:17:27.390 --> 00:17:30.580
to get the image data to
display to the screen.

00:17:32.340 --> 00:17:39.060
So another thing that iOS will do for
you is related to the UI image cache.

00:17:39.060 --> 00:17:42.480
Some of you may know that
UIKit will actually cache images

00:17:42.490 --> 00:17:44.830
loaded with UI image image named.

00:17:45.090 --> 00:17:49.970
Now, images can be really big and
take up a lot of memory on iOS.

00:17:49.970 --> 00:17:54.950
In fact, they'll take up about four bytes
per pixel is a good rule of thumb.

00:17:55.100 --> 00:17:58.310
But in addition,
they take a long time to load.

00:17:58.310 --> 00:18:02.880
They take a long time to decompress
and load and display on the screen.

00:18:03.040 --> 00:18:06.190
So UIKit will actually cache
these images in memory that

00:18:06.200 --> 00:18:08.170
you load with this image named.

00:18:08.280 --> 00:18:11.780
So as you load images one by one,
they just keep piling up in memory.

00:18:11.850 --> 00:18:15.280
And you can--as you can imagine,
it piles up pretty quickly and

00:18:15.310 --> 00:18:17.180
grows pretty--pretty quickly.

00:18:17.330 --> 00:18:19.710
But when your application
goes into the background,

00:18:19.710 --> 00:18:23.140
UIKit will actually purge the
cache completely and reclaim

00:18:23.200 --> 00:18:25.670
all of that memory for you.

00:18:27.280 --> 00:18:30.960
And in a similar vein,
several frameworks in iOS will

00:18:30.960 --> 00:18:35.800
actually cache data and memory
to avoid going to the flash,

00:18:35.800 --> 00:18:39.400
or going to the network,
or doing an expensive recalculation.

00:18:39.510 --> 00:18:43.590
And so these are frameworks like
SQLite and Core Data and NSCache,

00:18:43.590 --> 00:18:47.540
which we'll talk about later,
and a bunch of other frameworks.

00:18:47.670 --> 00:18:50.340
And when your application
goes into the background,

00:18:50.450 --> 00:18:53.500
those frameworks will just
empty those caches for you.

00:18:55.580 --> 00:18:59.080
So those are a few things that iOS
will actually do for you when your

00:18:59.080 --> 00:19:02.610
application enters the background to
try and reduce your memory footprint.

00:19:02.910 --> 00:19:06.250
But now I want to talk about a
few things that your app can do to

00:19:06.270 --> 00:19:08.690
free up some memory and make that
memory available to other apps

00:19:09.250 --> 00:19:10.790
while your app's in the background.

00:19:10.890 --> 00:19:13.790
And first I want to talk
about UI image views.

00:19:14.510 --> 00:19:19.240
So as we talked about earlier,
images can take up a lot of memory.

00:19:19.590 --> 00:19:23.350
And UI image views, like all UI views,
have a CA layer.

00:19:23.350 --> 00:19:26.600
But in this case,
instead of having a back-end store

00:19:26.600 --> 00:19:30.120
that's managed by Core Animation,
the CA layer will use the contents

00:19:30.230 --> 00:19:36.090
of the image or the image data
directly to display to the screen.

00:19:36.290 --> 00:19:39.400
What this means is that these images
are not reclaimed automatically when

00:19:39.400 --> 00:19:41.150
your app goes to the background.

00:19:41.170 --> 00:19:44.420
So if you're displaying this
big 8 megapixel image in your

00:19:44.420 --> 00:19:48.180
view hierarchy somewhere,
you're going to be using that much

00:19:48.180 --> 00:19:52.900
memory to keep that image in memory
even when you're in the background.

00:19:53.840 --> 00:19:57.540
So you should detach large images
from your view hierarchy right before

00:19:57.540 --> 00:20:02.780
your application suspends and free
up that memory and free up the image.

00:20:02.970 --> 00:20:06.410
And especially if those
UI images are off screen,

00:20:06.410 --> 00:20:09.940
because if it's deep in a
navigation controller or in a tab

00:20:09.940 --> 00:20:14.440
controller on an unselected tab,
when your application resumes,

00:20:14.440 --> 00:20:18.990
you don't even need that
image to actually resume.

00:20:20.110 --> 00:20:24.160
But again, these images take a long
time to decompress and load,

00:20:24.240 --> 00:20:26.020
so you should keep that in mind.

00:20:26.020 --> 00:20:30.250
If you are showing a really big
UI image view when your application

00:20:30.250 --> 00:20:33.170
suspends and you get rid of it,
when your application comes

00:20:33.220 --> 00:20:35.980
back to the foreground,
then you have to pay the cost

00:20:35.980 --> 00:20:39.630
of decompressing the image
before you can display it.

00:20:39.820 --> 00:20:41.880
So again, that's part of that tradeoff
that you have to keep in mind.

00:20:41.880 --> 00:20:46.870
Like, the more you release,
the more time you will need to resume.

00:20:47.070 --> 00:20:50.150
You may want to make sure that your
images are properly scaled before

00:20:50.220 --> 00:20:52.910
putting them into the UI image views,
which could save you both the

00:20:53.000 --> 00:20:55.760
memory and the time to decompress.

00:20:58.530 --> 00:21:01.590
So your application,
similar to how some of iOS's

00:21:01.590 --> 00:21:04.020
frameworks caches data,
might actually cache some

00:21:04.020 --> 00:21:05.310
data for the same reasons.

00:21:05.420 --> 00:21:08.070
To avoid hitting the flash,
to avoid going to the network,

00:21:08.170 --> 00:21:10.240
to avoid some expensive calculations.

00:21:10.350 --> 00:21:12.270
And these caches can also build up.

00:21:12.510 --> 00:21:15.860
And so one of the other things
your application can do to help

00:21:16.050 --> 00:21:19.500
the system manage memory is to
flush your application caches

00:21:19.500 --> 00:21:21.310
as you go to the background.

00:21:21.530 --> 00:21:25.030
But again, not if resuming will take just
as long as relaunching because

00:21:25.070 --> 00:21:27.940
of flushing all these caches.

00:21:28.090 --> 00:21:34.510
An interesting compromise though is
to use NSCache with NSPurchableData.

00:21:37.610 --> 00:21:40.350
So NSCache caches objects in memory.

00:21:40.500 --> 00:21:42.740
You know, not much of a surprise there.

00:21:42.740 --> 00:21:47.070
But it also manages and evicts
these objects as necessary.

00:21:47.330 --> 00:21:51.500
So as it hits some limits or
determines that it's a good time

00:21:51.500 --> 00:21:53.950
to evict some of these objects,
it will actually automatically

00:21:53.950 --> 00:21:55.260
evict them for you and manage that.

00:21:55.260 --> 00:22:00.090
And there are different ways of
configuring its eviction policy.

00:22:00.530 --> 00:22:04.600
And when you go into the background,
it'll actually evict all the

00:22:04.600 --> 00:22:08.130
objects in your NS cache for you,
so you're not paying the

00:22:08.130 --> 00:22:10.700
memory cost for all of that.

00:22:11.840 --> 00:22:13.820
Now where NS Cache really
shines is if you end up using

00:22:13.820 --> 00:22:15.390
it with NS purgeable data.

00:22:15.540 --> 00:22:19.300
So with NS purgeable data objects,
you specify when you're using

00:22:19.430 --> 00:22:22.530
the data in the NS purgeable data
and when you're done with it.

00:22:22.640 --> 00:22:25.040
And when you're done with
the NS purgeable data object,

00:22:25.180 --> 00:22:30.460
the memory for that NS purgeable
data object becomes reclaimable,

00:22:30.570 --> 00:22:35.010
very much like the backing stores for
those custom views that we saw earlier.

00:22:35.210 --> 00:22:39.450
And so iOS can actually take the memory
associated with those NS purgeable

00:22:39.450 --> 00:22:42.190
data objects if memory is tight.

00:22:42.200 --> 00:22:46.200
And so if you put an NS purgeable
data object into an NS cache,

00:22:46.250 --> 00:22:50.120
then it will actually stick around
in the cache because it can actually

00:22:50.120 --> 00:22:54.070
be reclaimed by the OS even when
your application is suspended.

00:22:54.200 --> 00:22:57.990
And so this has the benefit of
if your applica-- if the user is

00:22:57.990 --> 00:23:01.200
switching quickly between your
application and another application,

00:23:01.200 --> 00:23:06.200
as long as memory doesn't become tight or
there's no memory pressure between them,

00:23:06.200 --> 00:23:09.200
when your application comes back
to the front end or the foreground,

00:23:09.200 --> 00:23:11.200
much of this memory may
actually still be there.

00:23:11.200 --> 00:23:15.200
So again, you specify when you want to
use this NS purgeable data

00:23:15.200 --> 00:23:16.200
and when you're done with it.

00:23:16.200 --> 00:23:18.200
And when you're done with
the NS purgeable data,

00:23:18.200 --> 00:23:21.200
they become reclaimable by the OS.

00:23:23.840 --> 00:23:26.860
So another API or set of
APIs that you may want to consider

00:23:26.860 --> 00:23:30.090
using are memory map files.

00:23:30.260 --> 00:23:33.540
So let's say you want to read
a bunch of data from a file

00:23:33.540 --> 00:23:35.980
like this JPEG over here.

00:23:36.200 --> 00:23:40.090
Well, one option is to malloc a really
big buffer or alloc init and

00:23:40.090 --> 00:23:44.040
NSData and just read it all
from disk into this big buffer.

00:23:44.280 --> 00:23:48.770
But the problem is that this big
buffer is memory that the OS can't

00:23:48.960 --> 00:23:55.340
touch because it's part of your
application's virtual memory.

00:23:55.340 --> 00:24:00.900
If you instead memory map the file,
what happens is that the OS will

00:24:01.360 --> 00:24:06.070
reserve some space in your virtual
memory address space for that file.

00:24:06.070 --> 00:24:10.610
But it doesn't actually assign any
physical memory for the file yet.

00:24:10.610 --> 00:24:14.760
It's only when you start touching
the pages and using the pages

00:24:15.150 --> 00:24:18.590
for that file that it actually
brings in the data from the file

00:24:18.590 --> 00:24:21.710
and make it resident into memory.

00:24:22.150 --> 00:24:25.900
And what's really cool is that
when there's memory pressure

00:24:25.900 --> 00:24:30.240
and the OS needs some memory
to use for some other purpose,

00:24:30.330 --> 00:24:35.210
if this file is mapped read only,
then it can just go ahead and take

00:24:35.310 --> 00:24:40.040
one of these pages and throw it away
and use that page for something else,

00:24:40.130 --> 00:24:42.730
because the next time your
application touches that page,

00:24:42.850 --> 00:24:45.030
it can just bring it
back in from the file.

00:24:45.160 --> 00:24:46.870
So it can do this even
if your application is

00:24:46.960 --> 00:24:48.840
suspended in the background.

00:24:48.840 --> 00:24:53.870
So these memory map files are kind of a
nicer way of reading in data from files

00:24:54.160 --> 00:24:56.940
when your application is suspended.

00:24:58.400 --> 00:25:01.340
So consider mapping files into
memory instead of reading them

00:25:01.340 --> 00:25:03.440
into in-memory buffers if possible.

00:25:03.500 --> 00:25:06.440
And to do so, you can use any number
of the APIs we have,

00:25:06.480 --> 00:25:10.130
like NSData,
data with contents of map file.

00:25:10.530 --> 00:25:14.440
And the real benefit is that
iOS can reclaim these pages

00:25:14.440 --> 00:25:18.710
from map files automatically,
even if your application is suspended.

00:25:19.950 --> 00:25:23.630
So to summarize our best
practices around memory,

00:25:23.890 --> 00:25:26.890
free up memory when you
receive a memory warning.

00:25:26.920 --> 00:25:29.040
You may not get another
chance to free up memory,

00:25:29.170 --> 00:25:33.000
so please do respond
to the memory warnings.

00:25:33.400 --> 00:25:36.290
Free up memory when your application
goes into the background as well,

00:25:36.420 --> 00:25:38.280
right before suspending.

00:25:38.470 --> 00:25:41.390
Remove UI image views from
the view hierarchy unless the

00:25:41.390 --> 00:25:45.600
decompression will be a problem
when your application resumes.

00:25:45.700 --> 00:25:50.560
And consider using NSCache and memory
map files and other memory-friendly

00:25:50.560 --> 00:25:52.520
APIs that we have in iOS.

00:25:52.640 --> 00:25:56.100
But always throughout all of this,
remember the tradeoff to balance

00:25:56.420 --> 00:25:59.790
the memory footprint that you have
in the background with how long it

00:25:59.790 --> 00:26:02.550
takes to resume your application.

00:26:03.340 --> 00:26:06.840
So with that,
I want to show now a short demo of

00:26:06.840 --> 00:26:12.120
some of the things we were talking
about using the VM Tracker instrument.

00:26:12.320 --> 00:26:18.230
So I'm going to switch over to the iPad.

00:26:18.760 --> 00:26:21.360
And I wrote a couple of really
simple applications here,

00:26:21.360 --> 00:26:24.100
and they're somewhat contrived,
but they show the things that

00:26:24.100 --> 00:26:26.040
I wanted to talk about here.

00:26:26.110 --> 00:26:29.570
So the first one is this
custom view application.

00:26:29.990 --> 00:26:36.120
So you can't quite tell,
but this custom view here that I have

00:26:36.600 --> 00:26:41.720
is a custom subclass of UIView,
but it's really, really big.

00:26:41.720 --> 00:26:44.700
It's 8,000 by 8,000 pixels.

00:26:44.800 --> 00:26:47.360
So you would never
create a view this big.

00:26:47.410 --> 00:26:52.180
But the backing store for this
view takes up 8,000 by 8,000

00:26:52.240 --> 00:26:58.000
pixels times four bytes per pixel,
so about 256 megs.

00:26:58.080 --> 00:27:01.550
And so then it just,
it overrides drawRect and it draws

00:27:01.560 --> 00:27:05.290
that little apple using core graphics.

00:27:05.570 --> 00:27:09.460
So let's take a look at what this looks
like in VM Tracker in Instruments.

00:27:09.580 --> 00:27:11.770
So I have Instruments here.

00:27:12.030 --> 00:27:16.200
And I'm going to select a blank document,
launch the library,

00:27:16.200 --> 00:27:18.230
and find the VM Tracker instrument.

00:27:18.350 --> 00:27:22.070
And I'm just going to go ahead
and drag that into Instruments.

00:27:23.910 --> 00:27:29.410
And I'm going to attach to
this custom view process here,

00:27:29.480 --> 00:27:33.050
so I can inspect its
virtual memory space,

00:27:33.050 --> 00:27:34.870
and click record.

00:27:36.700 --> 00:27:40.400
So one thing to note about VM Tracker,
and let me see if I can

00:27:40.670 --> 00:27:42.870
zoom in here for you.

00:27:43.300 --> 00:27:44.250
Oh, I can't.

00:27:44.400 --> 00:27:50.430
Is that it will snapshot the virtual
memory space of the application at

00:27:50.470 --> 00:27:53.820
a regular interval if you set this,
if you set an interval here.

00:27:53.820 --> 00:27:57.600
So see, so here I have it set to
snapshot every three seconds.

00:27:57.620 --> 00:27:59.940
And then it'll present
to you some summary,

00:27:59.940 --> 00:28:04.520
some summary statistics of all the
memory used by your application.

00:28:04.520 --> 00:28:09.500
So in this case,
the summary statistics show that

00:28:09.500 --> 00:28:13.650
I have 245 megabytes of dirty memory.

00:28:13.660 --> 00:28:18.090
And dirty memory in general is
memory that iOS can't touch and

00:28:18.090 --> 00:28:19.980
can't reclaim automatically.

00:28:21.620 --> 00:28:25.560
And I'm going to switch
here to the regions map,

00:28:25.640 --> 00:28:29.450
which will show each of the
individual regions in the virtual

00:28:29.460 --> 00:28:34.200
memory space for this application,
and then sort by dirty size.

00:28:34.330 --> 00:28:37.600
And at the top here,
I have a region of type core

00:28:37.600 --> 00:28:41.340
animation that's 244 megabytes large.

00:28:41.340 --> 00:28:47.990
So this is the backing store for
that view that we saw earlier.

00:28:48.700 --> 00:28:51.400
So now I'm on the iPad and
I'm going to go ahead and send

00:28:51.400 --> 00:28:53.200
that back to the background.

00:28:53.250 --> 00:28:55.780
And you can see when I did that,
that this little flag up here

00:28:55.780 --> 00:28:57.700
showed up in Instruments.

00:28:57.750 --> 00:29:00.830
And if I click on that flag,
it says that my application

00:29:00.870 --> 00:29:03.160
was background task suspended.

00:29:03.270 --> 00:29:06.770
So it went to the background
and it's now suspended.

00:29:06.970 --> 00:29:10.990
If I look back down
here in the regions map,

00:29:11.100 --> 00:29:15.230
you'll see that I actually still have
that big 244 megabyte region sitting

00:29:15.230 --> 00:29:18.430
around while my application is suspended.

00:29:18.540 --> 00:29:20.210
Now,
this isn't really a big problem because,

00:29:20.230 --> 00:29:22.140
again,
we've marked that as reclaimable while

00:29:22.140 --> 00:29:23.890
the application is in the background.

00:29:23.890 --> 00:29:26.210
So I'm going to switch back
to the iPad and show you the

00:29:26.210 --> 00:29:28.170
other application that I wrote.

00:29:28.180 --> 00:29:31.170
So I'm going to launch now
this Photo Viewer application,

00:29:31.170 --> 00:29:33.630
and it's just this tab
controller with two tabs.

00:29:33.630 --> 00:29:38.840
And I'm going to tap the second tab,
which will show a 21 megapixel photo.

00:29:38.940 --> 00:29:41.780
And so, again, this will take up a
huge amount of memory,

00:29:41.780 --> 00:29:44.490
about 80 megabytes of memory
to show 21 megapixels.

00:29:44.490 --> 00:29:47.250
But I'm doing this to show you
what happens when there's a bit

00:29:47.250 --> 00:29:49.180
of memory pressure on the system.

00:29:49.280 --> 00:29:53.460
And you saw also how long it
took to actually load that.

00:29:53.510 --> 00:29:56.560
So let's switch back to instruments.

00:29:57.240 --> 00:30:01.700
and look into the region map,
and you'll see that,

00:30:01.700 --> 00:30:05.580
if you could read it,
the big 250 megabyte core

00:30:05.580 --> 00:30:07.970
animation region is gone.

00:30:08.200 --> 00:30:13.120
And if I switch back to the summary,
you'll see that my dirty size for my

00:30:13.120 --> 00:30:17.340
entire application is now 1.72 megabytes.

00:30:17.440 --> 00:30:20.260
So even though my application
was suspended and never actually

00:30:20.300 --> 00:30:23.850
came back to the foreground,
we were able to reclaim all that dirty

00:30:23.850 --> 00:30:28.040
memory and now it's just sitting in the
background with very little dirty memory.

00:30:28.130 --> 00:30:31.050
So this is the number you
want to optimize for when your

00:30:31.050 --> 00:30:34.900
application is in the background.

00:30:34.950 --> 00:30:38.490
So I'm going to stop this trace and
start Let's start a new trace now.

00:30:39.240 --> 00:30:42.600
and do the same thing loading
the VM Tracker instrument

00:30:42.670 --> 00:30:46.060
into my workspace here.

00:30:46.280 --> 00:30:50.670
This time I'm going to attach
to the photo viewer process that

00:30:50.670 --> 00:30:53.470
we just saw and start recording.

00:30:55.510 --> 00:30:58.160
And so now you see this
application has a dirty size,

00:30:58.250 --> 00:31:03.670
a total dirty size of about 85 megabytes,
which is also really big.

00:31:03.770 --> 00:31:08.900
And so I'm going to switch over to the
regions map and then sort by dirty again.

00:31:09.030 --> 00:31:13.900
And you see there's this one region
here that's 80 megabytes large.

00:31:14.180 --> 00:31:16.940
And the type is memory tag 70.

00:31:17.150 --> 00:31:21.490
And memory tag 70 turns out to be the,
to be image memory.

00:31:21.490 --> 00:31:26.650
This is memory that iOS has allocated
to decompress an image into.

00:31:26.750 --> 00:31:29.220
And so that's,
that's the actual image data,

00:31:29.220 --> 00:31:33.120
the bitmap data for the image,
the 21 megapixel image that was

00:31:33.120 --> 00:31:36.180
being displayed on the screen.

00:31:36.230 --> 00:31:38.790
So I'm going to send this
to the background now.

00:31:40.740 --> 00:31:43.630
And so you can see again that flag
showed up and said my application's

00:31:43.740 --> 00:31:47.640
background task suspended.

00:31:47.730 --> 00:31:51.320
And then now I'm going to
launch that custom view again.

00:31:53.350 --> 00:31:56.040
And you're going to have to trust
me that I actually launched it,

00:31:56.040 --> 00:31:59.330
because you can see that this
memory tag 70 with 80 megabytes

00:31:59.500 --> 00:32:01.760
dirty is still sitting around.

00:32:01.890 --> 00:32:05.870
So this is an example of those UI image
views not being reclaimed as your

00:32:05.870 --> 00:32:08.260
application is sitting in the background.

00:32:08.260 --> 00:32:11.110
So this is something else you
need to keep in mind when you're

00:32:11.210 --> 00:32:12.690
developing your application.

00:32:12.790 --> 00:32:17.630
And now I want to talk about
another tricky resource,

00:32:17.790 --> 00:32:19.600
the GPU in OpenGL.

00:32:20.200 --> 00:32:23.740
So as I said earlier, you know,
the GPU is a really difficult

00:32:24.210 --> 00:32:27.630
resource for iOS to manage,
so it terminates applications in the

00:32:27.630 --> 00:32:32.570
background if they try to use the GPU,
if they try to use OpenGL.

00:32:33.140 --> 00:32:37.840
So it's really important if you're
developing a game or using OpenGL,

00:32:37.840 --> 00:32:39.440
you probably have some
kind of animation timer.

00:32:39.440 --> 00:32:42.170
It's really important to stop
that animation timer as your

00:32:42.170 --> 00:32:44.900
application goes into the background.

00:32:44.930 --> 00:32:46.830
Because if you don't stop
that animation timer,

00:32:46.830 --> 00:32:50.720
then you'll get a crash log
that looks something like this.

00:32:51.220 --> 00:32:53.830
So in this case,
this application ended up

00:32:54.100 --> 00:32:58.780
calling glFinish while it was
running in the background.

00:32:58.840 --> 00:33:02.530
Then after a bunch of calls,
eventually it hit

00:33:02.530 --> 00:33:07.780
glrReturnNotPermittedKillClient,
which is an indication that

00:33:07.880 --> 00:33:12.130
your application tried to use
gl when it wasn't supposed to.

00:33:12.130 --> 00:33:14.970
And so the application is terminated.

00:33:15.350 --> 00:33:18.250
So this is a pretty
tricky thing to get right,

00:33:18.300 --> 00:33:20.930
so I'm going to actually walk
through a code sample for

00:33:20.930 --> 00:33:25.800
pausing the animation while your
application is in the background.

00:33:25.800 --> 00:33:30.040
So most of this code is from
the GL template in Xcode.

00:33:30.040 --> 00:33:32.480
So you can go and check out the
GL template if you want to pull out

00:33:32.540 --> 00:33:34.890
some of this code to use in your app.

00:33:35.020 --> 00:33:40.860
But this is from a view that uses
OpenGL to draw to the screen.

00:33:41.000 --> 00:33:45.100
And it has this method, startAnimation,
on the view.

00:33:45.200 --> 00:33:49.100
And this method sets up the
animation timer that will

00:33:49.100 --> 00:33:50.800
end up drawing to the screen.

00:33:50.980 --> 00:33:53.600
And to do so,
it creates this display link.

00:33:53.650 --> 00:33:58.300
And a display link is very much like an
NS timer in that you give it a selector,

00:33:58.300 --> 00:34:00.990
and then the display link just calls
back that selector whenever it's

00:34:01.110 --> 00:34:02.670
advantageous to draw to the screen.

00:34:02.800 --> 00:34:05.700
And so in that selector,
this view will just do

00:34:05.700 --> 00:34:07.800
all of its GL drawing.

00:34:08.020 --> 00:34:11.400
Then it configures the timer,
the display link,

00:34:11.400 --> 00:34:12.900
and then adds it to the run loop.

00:34:12.900 --> 00:34:16.680
So once it's added it to the run loop,
then the timer starts calling that

00:34:16.680 --> 00:34:20.340
selector back to draw to the screen.

00:34:21.180 --> 00:34:24.890
And then similarly it has
the stop animation method.

00:34:24.890 --> 00:34:29.190
And the stop animation method
just invalidates the timer

00:34:29.190 --> 00:34:30.830
and then sets it to no.

00:34:30.870 --> 00:34:32.240
It releases it.

00:34:33.880 --> 00:34:36.460
So now that we have a way
to start and stop animation,

00:34:36.500 --> 00:34:38.360
we want to do so at
the appropriate times.

00:34:38.590 --> 00:34:43.290
And this particular code is going to
use the multitasking notifications that

00:34:43.520 --> 00:34:47.850
we saw earlier and not the explicit
callbacks on the UI application delegate.

00:34:48.160 --> 00:34:51.280
So in this view,
when this view wakes up from its nib,

00:34:51.420 --> 00:34:55.320
the first thing it does,
or one of the first things it does

00:34:55.320 --> 00:35:00.260
is it registers for the application
will resign active notification.

00:35:00.330 --> 00:35:03.370
So you'll get this notification any
time we'll call the application will

00:35:03.370 --> 00:35:08.110
resign active callback on the delegate,
which is whenever the application

00:35:08.110 --> 00:35:11.460
goes into the background,
when the user brings

00:35:11.460 --> 00:35:15.350
up the multitasking UI,
whenever an alert style notification

00:35:15.440 --> 00:35:17.540
pops up over your application.

00:35:17.620 --> 00:35:21.220
All these cases,
you'll get this callback and you

00:35:21.370 --> 00:35:23.840
really want to stop and pause your

00:35:24.380 --> 00:35:28.800
So in the method that
observes this notification,

00:35:28.820 --> 00:35:32.100
all this view does is
calls stop animation,

00:35:32.100 --> 00:35:33.770
if appropriate.

00:35:35.100 --> 00:35:38.820
So now that the animation's paused,
we probably want to resume it

00:35:38.840 --> 00:35:40.620
when it's appropriate to do so.

00:35:40.620 --> 00:35:43.330
So to do that,
we're going to call the UI application

00:35:43.410 --> 00:35:45.120
to become active notification.

00:35:45.180 --> 00:35:48.600
And you get this when your application
comes back to the foreground,

00:35:48.600 --> 00:35:51.300
when the user dismisses
the multitasking UI,

00:35:51.300 --> 00:35:54.310
if the user had brought
up the multitasking UI,

00:35:54.360 --> 00:36:00.960
or when the user dismisses an alert style
notification as we talked about earlier.

00:36:00.960 --> 00:36:06.350
And then simply in the observer,
it calls startAnimation.

00:36:07.770 --> 00:36:10.640
Now,
one other case that your application,

00:36:10.640 --> 00:36:15.310
your GL game,
has to handle properly is termination.

00:36:15.410 --> 00:36:18.060
When your application terminates,
you actually don't get that

00:36:18.060 --> 00:36:20.260
will resign active callback.

00:36:20.320 --> 00:36:23.340
But your application runs in
the background for a short

00:36:23.340 --> 00:36:25.100
period of time to clean up.

00:36:25.140 --> 00:36:30.600
And if your application uses GL at any
time when it's running in the background,

00:36:30.650 --> 00:36:32.240
it'll get terminated.

00:36:32.370 --> 00:36:35.550
So this view will also register
for the UI application will

00:36:35.630 --> 00:36:37.600
terminate notification.

00:36:37.690 --> 00:36:42.590
And then, not a big surprise,
in the observer, it calls stop animation.

00:36:42.720 --> 00:36:45.800
And so this prevents your application
from being terminated ungracefully

00:36:46.110 --> 00:36:49.510
when it is about to be terminated.

00:36:51.100 --> 00:39:50.700
[Transcript missing]

00:39:52.410 --> 00:39:55.200
Now games, they're kind of divided
into two categories.

00:39:55.200 --> 00:39:56.800
One is the turn-by-turn games.

00:39:56.900 --> 00:39:58.830
These are, I think,
the easiest to preserve

00:39:58.960 --> 00:40:02.140
state in that you moved your
checkerboard or your chess piece,

00:40:02.210 --> 00:40:07.080
or maybe you got past one
little state in the level,

00:40:07.080 --> 00:40:09.940
and you kind of save your
state after each turn.

00:40:09.940 --> 00:40:12.650
So once something changes,
maybe it's a game where

00:40:12.770 --> 00:40:17.040
people think a lot about,
like a Scrabble-type game,

00:40:17.330 --> 00:40:20.670
people expect that when
they return to your app,

00:40:20.750 --> 00:40:23.600
if after they finish the turn,
that they return to

00:40:23.600 --> 00:40:24.520
exactly where they were.

00:40:24.600 --> 00:40:27.300
So it's a good idea for
those sorts of games just to

00:40:27.300 --> 00:40:29.180
save when something changes.

00:40:29.270 --> 00:40:33.260
But for some sorts of games, like, say,
a first-person shooter or some

00:40:33.260 --> 00:40:36.230
other very heavy-duty OpenGL games,
you have things that are

00:40:36.230 --> 00:40:37.940
changing at 60 frames per second.

00:40:38.070 --> 00:40:41.480
And for those types of games,
you really want to be able to do all your

00:40:41.480 --> 00:40:46.920
graphics work during that 1/16th of a
second that you have to generate a frame.

00:40:47.030 --> 00:40:49.740
And you don't want to be
saving your state all the time.

00:40:49.920 --> 00:40:52.810
So for those sorts of games,
it's best to save at really

00:40:53.290 --> 00:40:54.660
important transitions.

00:40:54.780 --> 00:40:57.660
So some of those may be you change
from one level to the other,

00:40:57.750 --> 00:41:00.980
or maybe you accomplish some
sort of goal or achievement,

00:41:00.980 --> 00:41:03.990
or in between levels
is another good place.

00:41:04.310 --> 00:41:05.790
And of course,
you always want to save state

00:41:05.790 --> 00:41:08.420
in the background so that when
the user returns to the app,

00:41:08.530 --> 00:41:10.960
they'll get to right at that
point where they left off.

00:41:11.090 --> 00:41:14.980
So that's a few tips for games.

00:41:15.460 --> 00:41:18.110
Beyond state preservation,
there are some things that you

00:41:18.110 --> 00:41:20.970
want to do to make sure that
your app is fully functional and

00:41:20.970 --> 00:41:23.260
works properly when it resumes.

00:41:23.260 --> 00:41:26.380
So, when you go into the background,
maybe you had some networking socket

00:41:26.450 --> 00:41:29.760
that was open downloading some data,
those may be disconnected

00:41:29.760 --> 00:41:31.230
while you are suspended.

00:41:31.230 --> 00:41:33.780
If you have a phone,
you're constantly--you

00:41:33.780 --> 00:41:36.210
may drive down this road,
you may go through a tunnel,

00:41:36.210 --> 00:41:39.070
lots of things can happen
while you're in the background.

00:41:39.070 --> 00:41:41.080
And so,
you need to assume that that socket

00:41:41.080 --> 00:41:45.110
may disconnect at some point while
you're suspended and you may have to

00:41:45.110 --> 00:41:51.260
candle some error conditions on resume
or maybe reissue that networking query.

00:41:51.260 --> 00:41:53.920
And it's also important for any
application that does a lot of

00:41:53.920 --> 00:41:58.710
networking that listens to things on
the other end that suspended apps,

00:41:58.720 --> 00:42:01.230
because they're suspended,
won't be able to accept

00:42:01.230 --> 00:42:02.580
incoming connections.

00:42:02.590 --> 00:42:04.300
So, if you have some sort
of listening socket,

00:42:04.520 --> 00:42:07.680
make sure that you close that on
suspend so that clients don't think

00:42:07.880 --> 00:42:10.880
that somebody is available to talk to.

00:42:11.150 --> 00:42:13.210
and then of course
reopen those on resume.

00:42:13.480 --> 00:42:16.900
And this is much the same
as a Bonjour connections.

00:42:16.900 --> 00:42:21.540
If you have a Bonjour connection,
or a Bonjour operation that's going,

00:42:21.540 --> 00:42:23.650
you need to assume that
they'll be canceled when the

00:42:23.650 --> 00:42:25.040
application is suspended.

00:42:25.040 --> 00:42:27.530
So you have two people
talking to each other,

00:42:27.530 --> 00:42:30.380
you don't want your
application to go silent.

00:42:30.380 --> 00:42:34.370
So you want to kind of cleanly tear
down the Bonjour connection or service

00:42:34.580 --> 00:42:36.850
and then restart them on resume.

00:42:36.860 --> 00:42:40.510
There's a lot of detail that was covered
in the Bonjour talk about this that

00:42:40.510 --> 00:42:46.510
I'd suggest checking out if you have
an app that makes heavy use of Bonjour.

00:42:47.980 --> 00:42:50.460
And then of course there's
system notifications.

00:42:50.460 --> 00:42:53.800
So lots of things can
happen in the background.

00:42:53.800 --> 00:42:57.410
User may--the most common one is they
may go to your--our settings app,

00:42:57.420 --> 00:43:00.490
change some setting in the
application--in the settings

00:43:00.590 --> 00:43:02.100
app and then return to your app.

00:43:02.350 --> 00:43:05.380
Or, you know, the user may change their
language and there are a bunch

00:43:05.460 --> 00:43:08.910
of other things that can happen
while you're in the background,

00:43:08.910 --> 00:43:12.890
but we don't want to have all
background apps do a lot of work every

00:43:12.890 --> 00:43:14.780
time that we have a notification.

00:43:14.780 --> 00:43:17.820
So rather than sending
all these notifications,

00:43:17.860 --> 00:43:21.390
either while you're in the background
or trying to replay all of them

00:43:21.390 --> 00:43:24.610
when you enter the foreground,
we instead coalesce and

00:43:24.870 --> 00:43:26.700
queue up the notifications.

00:43:26.850 --> 00:43:30.960
So if you change your setting, you know,
if the user changes your setting five

00:43:30.960 --> 00:43:35.800
different times or changes the language
five different times or take some other

00:43:35.850 --> 00:43:40.030
action that triggers a notification,
then we will take all of those,

00:43:40.030 --> 00:43:43.760
we'll queue them up and then on
resume we'll deliver them to you.

00:43:43.770 --> 00:43:47.430
So that means that you won't get this
giant replay of a ton of notifications,

00:43:47.430 --> 00:43:50.100
but still get them when you resume.

00:43:51.600 --> 00:43:54.040
So just a couple of common ones.

00:43:54.200 --> 00:43:58.640
I think the most common one is the
NSUserDefaultsDidChangeNotification,

00:43:58.640 --> 00:44:03.020
which you'll get when the user goes
into the Settings app and changes

00:44:03.020 --> 00:44:04.250
a setting for your application.

00:44:04.490 --> 00:44:06.630
And there's also language
or locale changes.

00:44:06.850 --> 00:44:09.240
And a much,
much longer list of notification that's

00:44:09.240 --> 00:44:12.250
in the documentation of all sorts of
various things that can change while

00:44:12.300 --> 00:44:14.160
your application is in the background.

00:44:14.160 --> 00:44:18.950
So if you listen to those anywhere,
then you'll get them on resume.

00:44:20.050 --> 00:44:25.640
Now last we want to cover a couple
of little tidbits about several

00:44:25.640 --> 00:44:28.410
of the multitasking services.

00:44:28.420 --> 00:44:30.570
So the first one is task completion.

00:44:30.780 --> 00:44:35.520
So it's the second most
important multitasking scenario,

00:44:35.520 --> 00:44:37.820
the first being fast app switching.

00:44:37.820 --> 00:44:40.400
And one of the great things is
we have so many apps adopting

00:44:40.400 --> 00:44:42.040
it that users now expect it.

00:44:42.040 --> 00:44:44.920
So if you're an app that
downloads something,

00:44:44.920 --> 00:44:48.120
like something, say a 30 meg file,
maybe it's a book,

00:44:48.120 --> 00:44:51.180
maybe it's something else,
then users really expect that if

00:44:51.180 --> 00:44:53.730
they start the operation while
your app is in the foreground,

00:44:53.730 --> 00:44:56.060
it will continue in the background.

00:44:56.060 --> 00:44:58.130
And so task completion
isn't just a good idea now.

00:44:58.130 --> 00:45:00.280
It's actually a fairly
strong requirement for users.

00:45:00.380 --> 00:45:03.840
You know, it's worked out really well
for a lot of applications.

00:45:03.840 --> 00:45:08.210
And so users will expect all applications
to handle it--to handle this very,

00:45:08.210 --> 00:45:11.720
very gracefully and just finish
whatever you're downloading.

00:45:11.720 --> 00:45:13.950
But of course,
we only do this for the tasks

00:45:14.110 --> 00:45:16.820
where you really need to-- to
continue the downloading and try

00:45:16.820 --> 00:45:18.440
to finish as quickly as possible.

00:45:18.440 --> 00:45:21.110
So don't download a bunch of extra data.

00:45:21.120 --> 00:45:23.600
Just download what you need.

00:45:23.600 --> 00:45:26.300
And if you can't finish in time,
if for some reason the user goes into

00:45:26.300 --> 00:45:30.080
a networking environment that wasn't as
good as when they started or--and you

00:45:30.080 --> 00:45:34.330
realize that you can't finish in time,
then you will get an expiration

00:45:34.340 --> 00:45:38.220
handler that fires a few seconds
before your application is suspended.

00:45:38.360 --> 00:45:41.350
And at that point,
you want to end the background

00:45:41.350 --> 00:45:45.220
task and store off where you
were so that you can resume.

00:45:45.250 --> 00:45:46.620
When the application resumes.

00:45:46.620 --> 00:45:49.040
And ideally,
you would store whatever you downloaded

00:45:49.040 --> 00:45:54.140
and just download the remaining bits when
the user goes back to your application.

00:45:54.180 --> 00:45:55.820
Now, background audio.

00:45:55.820 --> 00:46:00.660
So we provide all these great services
to prioritize audio so that the

00:46:00.660 --> 00:46:04.640
user experience is really sane when
you have all these different audio

00:46:04.640 --> 00:46:09.070
bits going on around the system
like phone calls and music and alerts,

00:46:09.070 --> 00:46:09.720
et cetera.

00:46:09.990 --> 00:46:14.040
We provide all sorts of services for
mixing and ducking and integration

00:46:14.040 --> 00:46:17.240
with headsets and external speakers.

00:46:17.240 --> 00:46:22.680
One thing that we're adding to
iOS 5 is the ability to--you know,

00:46:23.720 --> 00:46:26.120
To use what we call the display remote.

00:46:26.510 --> 00:46:32.630
So accessories have the ability to
display album artwork and say the

00:46:32.630 --> 00:46:34.770
name of the track and some other data.

00:46:34.770 --> 00:46:38.390
And applications also get this too
through the media player framework.

00:46:38.430 --> 00:46:40.420
So if you're a background
audio application,

00:46:40.420 --> 00:46:43.840
you can present the same kinds of
information that we do for the iPod app.

00:46:43.840 --> 00:46:46.700
And we think this will
work out really great.

00:46:47.260 --> 00:46:50.400
For audio applications,
one important thing for users is to

00:46:50.560 --> 00:46:52.580
handle audio interruptions correctly.

00:46:52.850 --> 00:46:56.090
So during an interruption,
such as a phone call,

00:46:56.140 --> 00:46:59.780
the audio system will silence
an interupted application,

00:46:59.790 --> 00:47:03.160
and you'll want to update your
UI appropriately and potentially

00:47:03.160 --> 00:47:06.040
resume after the interruption.

00:47:06.040 --> 00:47:09.440
So for example,
if you are an application that plays

00:47:09.440 --> 00:47:13.620
audio persistently in the background
and the user gets a phone call,

00:47:13.620 --> 00:47:17.310
we want you to resume that when the
user is done with the phone call and

00:47:17.640 --> 00:47:19.740
continue right where you were left off.

00:47:19.740 --> 00:47:23.350
But if you were an application that was
interrupted because the user went to,

00:47:23.350 --> 00:47:26.500
say, the iPod application,
then when the user is done with the iPod,

00:47:26.510 --> 00:47:28.980
we don't want to begin
the old audio application.

00:47:28.980 --> 00:47:33.220
So sometimes we want you to begin
playing after the interruption.

00:47:33.220 --> 00:47:34.760
Other times we don't.

00:47:34.760 --> 00:47:37.160
So in that beginner interruption,
you might, say,

00:47:37.160 --> 00:47:40.850
stop your downloading stream,
update various aspects of your UI,

00:47:40.850 --> 00:47:44.300
and stop the visualizations
like Charles mentioned,

00:47:44.300 --> 00:47:45.560
stop the OpenGL.

00:47:46.530 --> 00:47:51.260
And then when you get the
N interruption with flags method,

00:47:51.290 --> 00:47:53.800
you either resume or not,
whether or not this

00:47:53.930 --> 00:47:56.840
audio session property,
AV audio session interruption

00:47:56.930 --> 00:47:58.350
flag should resume is set.

00:47:58.570 --> 00:48:00.980
So we tell you whether
or not you should resume.

00:48:00.980 --> 00:48:02.680
All you need to do is
make sure that you do.

00:48:03.000 --> 00:48:06.160
So for phone calls, as I mentioned,
the audio should resume,

00:48:06.240 --> 00:48:10.050
but if the iPod interrupts,
then the audio shouldn't resume.

00:48:10.740 --> 00:48:13.260
So that's audio.

00:48:13.260 --> 00:48:15.770
Location tracking has
a few different modes.

00:48:15.840 --> 00:48:17.820
There's, of course,
the one that we're familiar

00:48:17.820 --> 00:48:21.410
with with GPS apps where you
can continually updating GPS.

00:48:21.410 --> 00:48:26.410
But I think two of the really interesting
ones beyond that for location are

00:48:26.460 --> 00:48:32.080
the ability to get notified when
significant location changes happen.

00:48:32.080 --> 00:48:36.530
So this is a cellular granular
notification that you get.

00:48:36.760 --> 00:48:39.960
And then region monitoring,
which is geofencing.

00:48:39.960 --> 00:48:45.670
It allows you to get a notification
when you enter or exit specific regions.

00:48:45.670 --> 00:48:50.600
And we'll give you a brief idea of
what kind of they mean in pictures.

00:48:50.600 --> 00:48:55.420
So for significant location changes,
let's say that you are interested in

00:48:55.420 --> 00:48:59.400
whether or not the user got to this
red dot that's halfway across--or

00:48:59.400 --> 00:49:01.150
all the way across the city.

00:49:01.240 --> 00:49:04.890
The way that this will work is, you know,
as the eye fall on the moon,

00:49:04.890 --> 00:49:05.290
as the eye falls on the moon,
you're going to get a notification.

00:49:05.290 --> 00:49:07.030
And then,
as the iPhone moves from cell tower

00:49:07.100 --> 00:49:10.280
to cell tower throughout the city,
you'll get these location change

00:49:10.340 --> 00:49:12.360
events while you're in the background.

00:49:13.960 --> 00:49:17.740
So it's great in that you get
updated when important things happen,

00:49:17.740 --> 00:49:22.730
and then you can figure out whether or
not you're within that particular region.

00:49:22.960 --> 00:49:28.840
So you can figure out whether or not
you're in that particular region.

00:49:28.840 --> 00:49:32.440
But what you might really want,
rather than something like this,

00:49:32.470 --> 00:49:35.600
is the ability to say,
don't tell me about all these

00:49:35.600 --> 00:49:39.090
intermediate states where I'm moving
from cell tower to cell tower.

00:49:39.150 --> 00:49:42.710
Just tell me when I'm entering
this last region of interest.

00:49:42.830 --> 00:49:45.200
And that's what region
monitoring allows you to do.

00:49:45.200 --> 00:49:49.610
So region monitoring says, well,
you may have moved from the cell tower,

00:49:49.610 --> 00:49:52.900
but we're paying attention to that and
we're keeping track of where you are.

00:49:52.900 --> 00:49:55.220
And then when you finally
hit this last location,

00:49:55.310 --> 00:49:58.660
the one that you were interested in,
then you'll get the notification

00:49:58.960 --> 00:50:00.610
that you have entered the region.

00:50:00.610 --> 00:50:05.000
So this one is a lot better for battery
life for this type of application.

00:50:05.210 --> 00:50:08.260
And in fact,
it's the API that we use in the reminders

00:50:08.260 --> 00:50:10.510
application for location-based reminders.

00:50:10.580 --> 00:50:13.520
It's been available to
third parties since iOS 4.

00:50:13.520 --> 00:50:17.640
Now, the key point about that one
is that region monitoring is

00:50:17.640 --> 00:50:19.900
only available on iPhone 4.

00:50:19.900 --> 00:50:23.860
It's not available on the iPhone 3GS
because we do a lot of clever work with

00:50:24.020 --> 00:50:27.520
our baseband to make all of this work.

00:50:27.520 --> 00:50:31.220
But all of them will use a lot
less power than GPS applications

00:50:31.220 --> 00:50:33.900
that require persistent updates.

00:50:33.900 --> 00:50:36.230
Both of them will resume
your suspended applications.

00:50:36.320 --> 00:50:38.960
The region monitoring will
just do it less often and

00:50:38.960 --> 00:50:40.740
only when you really need it.

00:50:40.740 --> 00:50:43.480
And if your application has
been terminated at some point,

00:50:43.500 --> 00:50:46.940
then we will relaunch the application
so that you get those notifications.

00:50:46.940 --> 00:50:50.340
So it's basically everything that
you would want to be able to see when

00:50:50.340 --> 00:50:55.690
significant changes happen or when
you enter and exit specific regions.

00:50:56.970 --> 00:51:01.380
Another service new to iOS
5 is the Newsstand service.

00:51:01.380 --> 00:51:06.110
So this one you can declare by adding
a newsstand-content to UI background

00:51:06.110 --> 00:51:10.970
modes and add the UI newsstand
app key to your Info.plist.

00:51:11.290 --> 00:51:14.790
And this provides you the ability
to get about once per day content

00:51:14.970 --> 00:51:17.130
downloads via push notifications.

00:51:17.150 --> 00:51:19.960
So you send a push
notification and to say that,

00:51:20.090 --> 00:51:23.460
hey, content is available,
and then we will launch the

00:51:23.460 --> 00:51:27.460
app or wake up your application
and deliver it some payload.

00:51:27.460 --> 00:51:30.740
And then your application can schedule
downloads to download the latest issue,

00:51:30.830 --> 00:51:35.030
and there's a lot of great
integration to update the icon and

00:51:35.030 --> 00:51:38.270
present it in the new newsstand UI.

00:51:38.940 --> 00:51:42.630
A few things that you need to be careful
about for news-standard applications.

00:51:42.760 --> 00:51:46.420
The first one is you kind of
want to minimize your resource

00:51:46.530 --> 00:51:50.060
downloads and make sure that they
go into the caches directory.

00:51:50.060 --> 00:51:55.550
So we will hand you a URL for your
download when the download is complete.

00:51:55.550 --> 00:51:58.860
And if you need to
decompress that download,

00:51:58.860 --> 00:52:04.080
then you want to make sure that that
ends up in your caches directory.

00:52:04.740 --> 00:52:08.400
And the reason is that users
tend to fill up their device.

00:52:08.510 --> 00:52:11.170
They buy the device that they need
for whatever capacity that they need.

00:52:11.490 --> 00:52:14.220
They fill it up somewhat
close to the limit.

00:52:14.220 --> 00:52:18.800
And all of the applications
are vying for whatever is left.

00:52:18.920 --> 00:52:21.920
So if you have a bunch of
applications that are using,

00:52:22.050 --> 00:52:24.920
say,
300 megabytes to store their content,

00:52:24.920 --> 00:52:28.440
then they'll be fighting with
each other to some extent.

00:52:28.440 --> 00:52:32.240
Because if the device gets full,
we need to try to find some place for

00:52:32.240 --> 00:52:34.460
the new content that's coming down.

00:52:34.460 --> 00:52:37.360
We want to update the latest content.

00:52:37.470 --> 00:52:41.270
And so we'll evict some
news-stand content and other

00:52:41.530 --> 00:52:43.660
things as space is needed.

00:52:43.660 --> 00:52:47.020
So if your download is smaller,
then there's a greater chance

00:52:47.020 --> 00:52:50.450
that the user will return to
your application just as it was.

00:52:50.460 --> 00:52:53.300
And of course,
this will reduce battery life

00:52:53.300 --> 00:52:56.800
and increase the speed at
which you get the content.

00:52:56.800 --> 00:52:59.940
And you'll also want to minimize
the number of downloads.

00:52:59.940 --> 00:53:04.180
So we will often tell people to
have one or two different downloads.

00:53:04.180 --> 00:53:12.080
So we'll also tell people to have
one or two different downloads.

00:53:13.480 --> 00:53:16.780
So to summarize,
multitasking in iOS provides a

00:53:16.780 --> 00:53:20.010
lot of different services that
do a lot of work on your behalf.

00:53:20.190 --> 00:53:23.860
If you want to go through the details
of each of the multitasking services,

00:53:23.860 --> 00:53:25.790
the two talks from last
year are a great resource,

00:53:25.800 --> 00:53:28.640
and the developer documentation
has a lot of data as well.

00:53:29.820 --> 00:53:33.850
Whenever you are in the foreground,
you want to respond to memory

00:53:33.910 --> 00:53:37.590
warnings to be a good citizen,
and minimize your background

00:53:37.590 --> 00:53:41.160
memory usage so that more
applications can fit in the system,

00:53:41.160 --> 00:53:44.680
and the users will return to your
application and all of the applications

00:53:44.700 --> 00:53:45.780
on the system a lot more quickly.

00:53:45.780 --> 00:53:48.970
You always want to make sure that
you return exactly to where you were

00:53:48.970 --> 00:53:52.040
when you were suspended to provide
that idea to the user to not have

00:53:52.040 --> 00:53:55.770
to think about whether or not the
application was resumed or relaunched,

00:53:55.780 --> 00:53:59.300
and provide that kind of
transparent application lifecycle.

00:53:59.460 --> 00:54:02.380
And of course,
when you do go into the background

00:54:02.380 --> 00:54:05.810
and free up your memory usage,
make sure that you balance

00:54:05.820 --> 00:54:07.680
that with speed to resume.

00:54:07.680 --> 00:54:09.840
So you want to use a
small amount of memory,

00:54:09.840 --> 00:54:11.660
but also resume really quickly.

00:54:11.660 --> 00:54:14.960
And with all of those things,
and by using all these services,

00:54:15.110 --> 00:54:18.960
we think we can give a really great
multitasking experience to users.

00:54:20.960 --> 00:54:24.280
So for more information,
you can contact Michael Jurowicz,

00:54:24.280 --> 00:54:29.760
and there's a lot of detailed resources
in our developer documentation.

00:54:29.760 --> 00:54:33.200
And the couple of sessions
that are worth checking out,

00:54:33.200 --> 00:54:36.720
there was a newsstand one earlier today,
and there have been a couple of iOS

00:54:36.840 --> 00:54:39.720
performance sessions to also check out.

00:54:39.720 --> 00:54:41.440
In particular,
if you want to find out even

00:54:41.440 --> 00:54:44.920
more about memory usage,
they cover a lot of details there.

00:54:44.920 --> 00:54:50.220
So thanks for coming today,
and enjoy your time at the party tonight.
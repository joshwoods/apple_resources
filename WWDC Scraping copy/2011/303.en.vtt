WEBVTT

00:00:10.070 --> 00:00:11.050
Good afternoon to you all.

00:00:11.050 --> 00:00:14.600
Welcome to What's
New in Core Data on iOS.

00:00:14.620 --> 00:00:17.220
I'm Adam Swift,
a senior software engineer

00:00:17.220 --> 00:00:18.700
on the Core Data team.

00:00:20.060 --> 00:00:22.670
So we got a lot of great
stuff to cover today.

00:00:22.890 --> 00:00:28.560
Going to talk to you about concurrency,
data protection, ordered relationships,

00:00:28.720 --> 00:00:34.300
UI managed document, iCloud,
incremental stores,

00:00:34.500 --> 00:00:37.790
and we'll wrap up with developer tools.

00:00:39.410 --> 00:00:43.800
So let's get started
talking about concurrency.

00:00:43.870 --> 00:00:46.950
The managed object context
is really the focal point of

00:00:46.950 --> 00:00:50.260
Core Data's concurrency policy.

00:00:50.350 --> 00:00:55.240
And in iOS 5, we've introduced some
new concurrency types,

00:00:55.350 --> 00:00:59.840
some block-based methods,
and support for nested contexts.

00:01:01.700 --> 00:01:04.780
So before we get into those things,
I want to talk about where we were.

00:01:04.810 --> 00:01:10.870
And up until iOS 5, since Core Data was
first introduced on iOS,

00:01:10.980 --> 00:01:13.880
we've used the model
of thread confinement.

00:01:14.470 --> 00:01:19.500
Thread confinement means that each
context is associated with a thread.

00:01:19.640 --> 00:01:24.180
And the objects that are owned by that
context can only be accessed on the

00:01:24.180 --> 00:01:26.800
thread that the context was created on.

00:01:26.920 --> 00:01:30.300
And in terms of communicating between
threads that are between contexts

00:01:30.400 --> 00:01:33.550
that are on different threads,
you use managed object IDs,

00:01:33.620 --> 00:01:36.220
which are a safe immutable data type.

00:01:38.120 --> 00:01:41.590
So this has some benefits,
and it's an easy model to understand,

00:01:41.590 --> 00:01:44.600
and it provides a safe,
efficient way to perform

00:01:44.680 --> 00:01:49.900
transactions at the context level.

00:01:50.750 --> 00:01:53.260
The implementation of this,
to do this correctly,

00:01:53.260 --> 00:01:56.240
is left as an exercise to you,
the developer.

00:01:56.240 --> 00:01:59.750
And so you would need to make sure
that you only accessed an object on the

00:01:59.750 --> 00:02:02.860
thread that its context was created on.

00:02:02.860 --> 00:02:07.400
And passing changes between
contexts could be a challenge.

00:02:08.490 --> 00:02:11.450
So we tried to figure out what
could we do at the Core Data level

00:02:11.740 --> 00:02:14.150
to make this job easier for you.

00:02:15.340 --> 00:02:17.750
So we came up with some
formal concurrency policies

00:02:17.880 --> 00:02:19.540
to try and simplify this.

00:02:19.570 --> 00:02:24.240
And these are available through Manage
Object Context concurrency types.

00:02:24.240 --> 00:02:26.240
And you use them with
this new initializer,

00:02:26.240 --> 00:02:28.480
init with concurrency type.

00:02:28.490 --> 00:02:34.080
And the three values you can pass in
are the confinement concurrency type,

00:02:34.140 --> 00:02:39.320
private queue concurrency type,
and main queue concurrency type.

00:02:39.360 --> 00:02:41.060
So let's take a look at these.

00:02:41.070 --> 00:02:44.260
The first one,
NSConfinement concurrency type,

00:02:44.260 --> 00:02:47.150
is actually the same thing you've
been using in Core Data since

00:02:47.150 --> 00:02:49.300
it was first introduced on iOS.

00:02:49.300 --> 00:02:53.940
It's the model of thread confinement
just formalized as a concurrency type.

00:02:53.940 --> 00:02:57.490
So in this same way,
context can only be accessed by the

00:02:57.490 --> 00:03:00.280
thread or queue that created them.

00:03:00.280 --> 00:03:02.900
And this is also,
if you simply alloc init

00:03:02.970 --> 00:03:05.450
a Manage Object Context,
this is the default

00:03:05.520 --> 00:03:07.450
behavior you will get.

00:03:09.470 --> 00:03:14.640
So this first new concurrency type is
the Private Queue concurrency type.

00:03:14.680 --> 00:03:17.780
This is new to iOS 5 and online.

00:03:18.090 --> 00:03:23.880
And in this concurrency type,
the context can only be accessed

00:03:23.880 --> 00:03:25.920
on its own private queue.

00:03:25.920 --> 00:03:28.520
And because it is a private queue,
it's not exposed,

00:03:28.520 --> 00:03:34.090
you need to use a new method on
the context called perform block

00:03:34.090 --> 00:03:40.570
to perform any interactions with
the context APIs through that

00:03:40.680 --> 00:03:43.400
block that you pass to the context.

00:03:44.870 --> 00:03:47.800
The main queue concurrency
type is very similar.

00:03:47.800 --> 00:03:49.680
It's the same idea,
but instead of it working

00:03:49.680 --> 00:03:53.130
with a private queue,
the context is connected

00:03:53.190 --> 00:03:54.980
to the main queue.

00:03:55.070 --> 00:04:01.350
And this is a great way to work with user
interface controllers or other things

00:04:01.350 --> 00:04:04.300
that are running on the main thread,
because they can message

00:04:04.430 --> 00:04:07.040
that context directly,
because they are running

00:04:07.040 --> 00:04:07.990
on the main queue.

00:04:08.060 --> 00:04:12.320
Other threads need to use the
perform block API so that the

00:04:12.320 --> 00:04:16.790
access to the context APIs is
executed on the main queue.

00:04:17.330 --> 00:04:21.300
And this is a great way to configure
context that you want to use to

00:04:21.300 --> 00:04:24.180
receive results from background
processing or something like that,

00:04:24.210 --> 00:04:26.980
and then turn around and
present those results to your

00:04:26.980 --> 00:04:29.290
users through a user interface.

00:04:30.570 --> 00:04:35.770
So those last two really represent the
queue-based concurrency changes we've

00:04:35.770 --> 00:04:38.460
introduced on the managed object context.

00:04:38.670 --> 00:04:43.100
And that's the main queue concurrency
type and private queue concurrency type.

00:04:43.500 --> 00:05:43.800
[Transcript missing]

00:05:44.150 --> 00:05:46.880
And important to note,
it is illegal to throw an

00:05:46.880 --> 00:05:50.710
exception out of the block
you pass in to perform block.

00:05:52.930 --> 00:05:56.500
Perform Block and Wait,
on the other hand,

00:05:56.550 --> 00:05:58.690
executes its block of code synchronously.

00:05:58.700 --> 00:06:00.960
It does it right in line.

00:06:01.210 --> 00:06:03.900
And because it's executed immediately,
we don't consider it to

00:06:03.900 --> 00:06:05.840
be a separate user event.

00:06:06.000 --> 00:06:09.160
We also don't wrap it
in an auto-release pool.

00:06:09.500 --> 00:06:13.090
Also, perform block and wait,
if you call it within a block

00:06:13.180 --> 00:06:16.730
executing and perform block and wait,
will execute immediately,

00:06:16.860 --> 00:06:18.930
so it is reentrant.

00:06:19.850 --> 00:06:24.810
But again, it is illegal to throw an
exception out of your block.

00:06:26.920 --> 00:06:32.190
So I mentioned Core Data treats
the code executing in the

00:06:32.290 --> 00:06:34.090
perform block as a user event.

00:06:34.100 --> 00:06:36.890
So what do I mean by a user event?

00:06:36.970 --> 00:06:41.210
A user event is normally what happens
every time you cycle through the

00:06:41.210 --> 00:06:43.630
main event loop in an application.

00:06:44.050 --> 00:06:46.540
And what it means is a user
has performed some action,

00:06:46.540 --> 00:06:50.480
and at the end of that event processing,
Core Data takes that time

00:06:50.690 --> 00:06:53.720
to do change coalescing,
delete propagation,

00:06:53.770 --> 00:06:57.070
take an undo snapshot,
and post any notifications that

00:06:57.170 --> 00:07:00.800
need to be posted around the
runtime to inform other parts

00:07:00.800 --> 00:07:02.230
of your application of changes.

00:07:21.330 --> 00:07:21.330
Well, when you're doing a perform block,
we treat that as a user event,

00:07:21.330 --> 00:07:21.330
and so we're going to do all of these
things to wrap up the work that was

00:07:21.330 --> 00:07:21.330
performed asynchronously and post a
sort of terminating wrapper on a user

00:07:21.330 --> 00:07:21.330
event to trigger all of these actions.

00:07:21.550 --> 00:07:25.130
Another way to think about a user
event is that it is the time between

00:07:25.130 --> 00:07:28.240
calls to process pending changes.

00:07:30.610 --> 00:07:34.890
So let's look a little more deeply at
the private queue concurrency type.

00:07:34.970 --> 00:07:39.060
And when you configure a context
with this concurrency type,

00:07:39.110 --> 00:07:41.850
that queue owned by the
context is really private.

00:07:41.950 --> 00:07:46.690
We don't expose it to you,
and we don't want you to use

00:07:46.800 --> 00:07:49.750
dispatch get current queue.

00:07:49.750 --> 00:07:49.760
Excuse me.

00:07:50.290 --> 00:07:52.950
Working with the queue directly
is going to cause problems.

00:07:53.180 --> 00:07:54.240
Things are going to break.

00:07:54.380 --> 00:08:00.540
So if you want to interface with the
dispatch APIs or NSOperation APIs,

00:08:00.620 --> 00:08:04.210
the way to do that is to embed the
references to your private queue

00:08:04.540 --> 00:08:10.230
within the block you pass to perform
block or perform block and wait.

00:08:12.580 --> 00:08:16.610
So what if you're in the situation
where you want to perform a couple of

00:08:16.620 --> 00:08:21.720
different tasks on background queues with
private queues between multiple contexts,

00:08:21.760 --> 00:08:23.870
and then you want to coordinate
the results of that work?

00:08:23.960 --> 00:08:28.920
Well, this is a time where you can use
a dispatch group to coordinate

00:08:28.920 --> 00:08:33.790
that work between multiple
blocks running in the background.

00:08:34.500 --> 00:08:37.160
And the way you do that is
you create the dispatch group,

00:08:37.160 --> 00:08:42.200
and then as you're going to initiate
the work to be performed asynchronously,

00:08:42.420 --> 00:08:46.290
you call dispatch group enter,
passing in the group.

00:08:46.570 --> 00:08:50.380
And then at the end of the worker block
that you've passed to perform block,

00:08:50.460 --> 00:08:52.090
you call dispatch group leave.

00:08:52.330 --> 00:08:56.700
And when you balanced out
all the enters and leaves,

00:08:56.760 --> 00:08:59.740
the dispatch group will be completed.

00:08:59.800 --> 00:09:02.720
And you can use dispatch group
wait or dispatch group notify on

00:09:02.720 --> 00:09:07.170
another block running on another
queue to monitor that change.

00:09:09.090 --> 00:09:14.210
So I've talked about how we've
introduced some new mechanisms for

00:09:14.210 --> 00:09:17.690
working with context concurrently.

00:09:17.700 --> 00:09:21.650
And what I haven't touched on yet
is what about sharing data between

00:09:21.650 --> 00:09:26.040
those contexts where they're
running in different queues?

00:09:26.040 --> 00:09:29.760
And this is where nested context
really helped solve that.

00:09:29.760 --> 00:09:35.430
So to use a nested context,
you simply use one new piece of API,

00:09:35.550 --> 00:09:39.720
set parent context,
and you assign a parent

00:09:39.720 --> 00:09:41.890
to a child context.

00:09:43.280 --> 00:09:44.190
So what does that give you?

00:09:44.200 --> 00:09:47.200
What do you get out of
using nested contexts?

00:09:47.310 --> 00:09:51.200
Well, it gives you an easy way to
implement asynchronous saving,

00:09:51.330 --> 00:09:55.300
sharing unsaved changes between contexts,
and also an easy way to

00:09:55.300 --> 00:09:57.180
implement background fetching.

00:09:59.010 --> 00:10:02.480
So let's take a look at
how that actually works.

00:10:02.670 --> 00:10:07.340
To implement asynchronous
saving with nested context,

00:10:07.810 --> 00:10:13.460
You create a parent and a child context,
assign the parent to the child,

00:10:13.600 --> 00:10:15.610
and then you save changes on the child.

00:10:15.650 --> 00:10:19.960
And what happens is those changes
just get pushed up to the parent.

00:10:20.080 --> 00:10:22.640
So there's no actual
I/O happening at that time.

00:10:22.730 --> 00:10:28.230
Then you use a perform block
to execute the save on the

00:10:28.230 --> 00:10:33.440
parent context asynchronously,
and so those changes are

00:10:33.710 --> 00:10:37.260
written out without holding up
the thread that called that.

00:10:37.920 --> 00:10:41.640
And we'll take another look at this when
we get to the Manage Documents section.

00:10:41.720 --> 00:10:44.900
We'll see how that's
working for us there.

00:10:45.190 --> 00:10:51.200
In terms of the code that's involved,
this is a little code snippet for you.

00:10:51.200 --> 00:10:53.810
You can see I'm initializing
the parent context with the

00:10:53.810 --> 00:10:56.230
private queue concurrency type.

00:10:56.420 --> 00:10:58.860
And then the child gets
the parent context,

00:10:58.920 --> 00:11:05.370
the child sets its parent context,
and then the child saves synchronously,

00:11:05.370 --> 00:11:10.540
and then the parent, we use perform block
and pass in the parent,

00:11:10.570 --> 00:11:14.210
the block that tells the
parent to save its changes.

00:11:16.830 --> 00:11:21.700
So what about sharing unsaved
changes with nested contexts?

00:11:21.760 --> 00:11:25.340
Well, this is actually a really nice,
elegant solution for this.

00:11:25.390 --> 00:11:30.080
You create a pair of child contexts
and have them share a common parent.

00:11:30.180 --> 00:11:32.460
Then when you save
changes from one child,

00:11:32.460 --> 00:11:36.380
they're pushed up to the parent,
and then the other child can pull down

00:11:36.380 --> 00:11:41.010
those changes by simply accessing the
properties on the managed objects.

00:11:43.280 --> 00:11:47.990
This is one way you can
implement support for inheriting

00:11:47.990 --> 00:11:50.160
changes in a detail inspector.

00:11:50.160 --> 00:11:54.360
So create a child context,
save pushes the changes to the parent,

00:11:54.360 --> 00:11:58.720
and then a fetch from the detail
inspector will incorporate those changes

00:11:58.750 --> 00:12:01.400
that are present in the parent context.

00:12:01.400 --> 00:12:03.770
And if you go to make further
changes in the child context and

00:12:03.770 --> 00:12:07.410
decide you don't want to keep them,
you can simply toss that child

00:12:07.900 --> 00:12:10.070
context and wipe out those changes.

00:12:11.640 --> 00:12:15.140
Some things to keep in mind when
you're working with nested contexts.

00:12:15.200 --> 00:12:18.850
Saving only pushes up to the next level,
so to the parent of the

00:12:19.130 --> 00:12:21.850
context you call save on.

00:12:21.940 --> 00:12:25.480
Fetching will pull data
down through all levels.

00:12:26.230 --> 00:12:29.410
Using Object with ID pulls
as few levels as necessary,

00:12:29.410 --> 00:12:33.050
and that's how you can implement
the background fetching effectively,

00:12:33.050 --> 00:12:36.110
by using a parent context
to fetch all that data,

00:12:36.110 --> 00:12:40.370
and then the child context can use
Object with ID to just pick objects

00:12:40.850 --> 00:12:44.860
for Objects IDs that it wants the data.

00:12:44.930 --> 00:12:50.000
And also, very important,
a parent context must adopt a queue

00:12:50.780 --> 00:12:54.190
type to be settable as a parent context.

00:12:56.010 --> 00:13:00.150
So now I'd like to shift gears a
little bit and talk about your data,

00:13:00.480 --> 00:13:03.060
specifically data protection.

00:13:04.420 --> 00:13:11.640
Data protection is a feature of iOS that
allows you to encrypt your user's data.

00:13:11.640 --> 00:13:16.430
It's a file-level protection,
so you're encrypting whole files,

00:13:16.570 --> 00:13:19.750
and that encryption is tied
to the user's passcode.

00:13:21.290 --> 00:13:24.750
In iOS 4,
data protection was first introduced

00:13:25.460 --> 00:13:29.380
through NS File Manager with
the keys file protection none

00:13:30.160 --> 00:13:32.360
and file protection complete.

00:13:32.470 --> 00:13:36.520
And what these protection classes mean,
file protection none actually means

00:13:36.810 --> 00:13:39.040
you're not getting any data protection.

00:13:39.140 --> 00:13:43.760
But file protection complete means
that any time the device is locked,

00:13:43.840 --> 00:13:48.520
the file cannot be opened, created, read,
or written.

00:13:49.930 --> 00:13:54.210
New in iOS 5, we've got two new data
protection classes,

00:13:54.210 --> 00:13:56.200
and these are a little bit more nuanced.

00:13:56.250 --> 00:13:59.440
There's file protection
complete unless open,

00:13:59.440 --> 00:14:04.170
and file protection complete
until first user authentication.

00:14:05.070 --> 00:14:09.240
So let's take a closer look
and put these in context.

00:14:09.240 --> 00:14:14.670
When you first boot up the device,
if the user has set a passcode and

00:14:14.670 --> 00:14:21.000
you're using file protection complete
until first user authentication,

00:14:21.000 --> 00:14:23.490
the file is completely inaccessible.

00:14:23.610 --> 00:14:28.990
It's completely protected because
the user hasn't authenticated yet.

00:14:29.940 --> 00:14:32.300
File protection complete unless open.

00:14:32.350 --> 00:14:36.430
Well, the file is protected
against being opened,

00:14:36.430 --> 00:14:39.510
but you can create a new file
and you can read and write a

00:14:39.510 --> 00:14:41.380
new file if you've created it.

00:14:42.320 --> 00:14:45.770
Then later on,
once the user is authenticated and

00:14:45.770 --> 00:14:49.630
once again the device is locked,
file protection complete until

00:14:49.750 --> 00:14:53.820
first user authentication is now
no longer protecting that file.

00:14:54.130 --> 00:14:58.600
You've gotten past the first user
authentication and now appears to

00:14:58.600 --> 00:15:00.940
be a usable file to your process.

00:15:01.090 --> 00:15:04.970
File protection complete unless
open still has the same behavior

00:15:04.970 --> 00:15:06.640
it did on the first boot.

00:15:06.740 --> 00:15:09.270
You can't open new files,
you can't open files,

00:15:09.360 --> 00:15:13.870
but you can create new files or read and
write those files that you've created.

00:15:15.720 --> 00:15:17.700
So how can you use this with Core Data?

00:15:17.820 --> 00:15:23.540
Well, we've added support for marking
persistent stores with data protection.

00:15:23.630 --> 00:15:28.780
And you do that through a new key,
a new option on the persistent store

00:15:29.000 --> 00:15:32.400
called persistent store
file protection key.

00:15:32.480 --> 00:15:36.210
So you pass that in when you're opening
your store as one of the options,

00:15:36.210 --> 00:15:39.180
and you use the file manager
values to set the protection

00:15:39.290 --> 00:15:41.050
class for your store file.

00:15:42.690 --> 00:15:47.400
The default behavior if you compile
your application against iOS 5 is

00:15:47.400 --> 00:15:52.390
you'll get file protection complete
until first user authentication.

00:15:52.730 --> 00:15:57.300
So once the user unlocks
the device the first time,

00:15:57.620 --> 00:16:00.270
you can access your store file normally.

00:16:02.500 --> 00:16:06.450
Some things to keep in mind when
working with data protection

00:16:06.610 --> 00:16:08.230
and persistent stores.

00:16:08.350 --> 00:16:14.760
If you opt into file protection complete,
the strongest data protection class,

00:16:14.810 --> 00:16:18.330
then when the device is locked,
your background process,

00:16:18.340 --> 00:16:22.250
if you have a background task running,
it won't be able to access the store.

00:16:22.250 --> 00:16:24.990
It won't be able to read, write, or open.

00:16:25.550 --> 00:16:28.400
If you use file protection
complete unless open,

00:16:28.440 --> 00:16:31.740
then a background task won't be
able to open up your store file,

00:16:31.740 --> 00:16:35.800
but it will be able to work with
a store file that's already open.

00:16:36.760 --> 00:16:41.600
And even with file protection complete
until first user authentication,

00:16:41.800 --> 00:16:45.140
normally when you first boot up a device,
your application won't be launched

00:16:45.140 --> 00:16:46.730
until the user authenticates.

00:16:46.860 --> 00:16:49.000
So it makes sense for most applications.

00:16:49.170 --> 00:16:52.800
However, if you're taking advantage of
core location region monitoring,

00:16:52.920 --> 00:16:56.250
it could actually trigger access
to your application before the

00:16:56.250 --> 00:16:58.420
user has unlocked the device.

00:17:00.490 --> 00:17:05.520
So now let's take a look at
a new feature in data models,

00:17:05.560 --> 00:17:07.880
ordered relationships.

00:17:08.810 --> 00:17:11.120
So while I'm talking about
ordered relationships,

00:17:11.150 --> 00:17:14.580
I want to distinguish between
sorting versus ordering.

00:17:14.580 --> 00:17:17.620
And this is just in the context
of ordered relationships.

00:17:17.620 --> 00:17:22.720
When I talk about sorting,
I'm talking about sorting by a value,

00:17:22.720 --> 00:17:24.790
a property of the data
that you're working with.

00:17:24.800 --> 00:17:27.570
It's a derived way to organize your data.

00:17:27.580 --> 00:17:31.550
So if I've got a table of items,
I can sort them by name,

00:17:31.550 --> 00:17:34.850
or I can change my view
to sort them by price.

00:17:36.020 --> 00:17:40.310
That's what I mean when I'm talking
about sorting in this context.

00:17:40.540 --> 00:17:43.300
Ordering,
I'm talking about arbitrary ordering,

00:17:43.300 --> 00:17:47.100
where you've got a list of items,
and you want to provide flexible control

00:17:47.100 --> 00:17:49.730
for the positioning of those items.

00:17:49.940 --> 00:17:52.970
The ordering shouldn't be tied to
any intrinsic value of the data.

00:17:53.300 --> 00:17:55.730
It's simply how you are
choosing to put them.

00:17:55.860 --> 00:17:58.960
So if I want eggs to show up
before cheese in my shopping list,

00:17:59.110 --> 00:18:03.430
that's my choice.

00:18:04.790 --> 00:18:11.130
Ordered relationships are basically just
like the regular too many relationships,

00:18:11.220 --> 00:18:15.060
except now you can assign the
positions to the objects that

00:18:15.160 --> 00:18:16.940
appear in the relationship.

00:18:17.220 --> 00:18:21.140
And when you're actually fetching
the value of an ordered relationship,

00:18:21.200 --> 00:18:24.580
you'll get back a new class,
NSOrderedSet,

00:18:24.670 --> 00:18:28.370
which keeps track of the position
of the objects in the relationship.

00:18:28.640 --> 00:18:32.030
And an ordered set is a new class,
as I said,

00:18:32.370 --> 00:18:35.140
and it's more like an array than a set.

00:18:35.140 --> 00:18:38.460
It's an ordered collection first.

00:18:38.480 --> 00:18:40.490
But technically,
it's a subclass of neither.

00:18:40.710 --> 00:18:45.080
So if you have APIs that are expecting
a set or an API that expects an array,

00:18:45.420 --> 00:18:49.260
you need to convert the contents of
the ordered set and put it into an

00:18:49.260 --> 00:18:51.700
array or set to pass it to those APIs.

00:18:52.970 --> 00:18:56.910
Another important thing to keep in
mind when working with ordered sets

00:18:56.910 --> 00:19:01.220
is that there's a performance impact
from doing both the ordering and the

00:19:01.220 --> 00:19:03.950
unicking work that the ordered set does.

00:19:05.420 --> 00:19:08.250
So how can you turn a
regular relationship into

00:19:08.250 --> 00:19:09.630
an ordered relationship?

00:19:09.760 --> 00:19:14.710
Well,
you use Xcode for the data modeling tool.

00:19:15.330 --> 00:19:19.050
And in the relationship inspector,

00:19:20.580 --> 00:19:22.900
Set the arrangement to ordered,
and that's it.

00:19:22.900 --> 00:19:25.350
You've opted into ordered
relationships now.

00:19:25.360 --> 00:19:29.010
Thank you.

00:19:30.910 --> 00:19:34.260
I'm pretty excited about them too.

00:19:34.260 --> 00:19:37.260
So in terms of working with
ordered relationships and code,

00:19:37.300 --> 00:19:40.060
if you're creating custom
classes for your entities,

00:19:40.060 --> 00:19:48.070
you can generate the accessors using
Xcode 4 and put those in your class,

00:19:48.070 --> 00:19:52.650
or you can choose to use the generic
mutator for ordered relationships,

00:19:52.650 --> 00:19:52.650
which is mutable ordered
set value for key.

00:19:53.470 --> 00:19:57.160
At this time, we don't have support for
automatic KVC accessors,

00:19:57.220 --> 00:20:03.050
so you can't just call insert events
at indexes on a NSManage object

00:20:03.340 --> 00:20:07.410
unless you've created a custom
class and implemented that method.

00:20:09.270 --> 00:20:11.560
In terms of observing
changes on relationships,

00:20:11.560 --> 00:20:16.080
it works like it does with
non-ordered relationships,

00:20:16.170 --> 00:20:19.510
but the kind of notifications
you get are different.

00:20:19.620 --> 00:20:21.960
You get a different set of change kinds.

00:20:22.030 --> 00:20:26.840
These are the ordered collection key
value observing changes that you get.

00:20:27.170 --> 00:20:32.230
Insertion, removal,
key value change replacement.

00:20:34.400 --> 00:20:38.220
Another thing that gets kind of hairy
is if you've got a situation where

00:20:38.320 --> 00:20:43.150
you've got a context that has one
state of the ordered relationship

00:20:43.200 --> 00:20:47.460
and a store that has another state
of the ordered relationship and the

00:20:47.590 --> 00:20:52.160
coordinator has yet one other state,
when you merge all those together,

00:20:52.160 --> 00:20:53.420
it can get hairy.

00:20:53.480 --> 00:20:55.220
So that...

00:20:56.380 --> 00:20:59.340
We try to preserve the relative ordering,
but there really is no single

00:20:59.340 --> 00:21:02.940
right answer for what the
ultimate ordering should be.

00:21:03.070 --> 00:21:07.180
And the performance is significantly
slower than non-ordered relationships,

00:21:07.250 --> 00:21:10.820
because we're merging both the existence
of objects in the relationship as well

00:21:10.820 --> 00:21:13.570
as the positions of those objects.

00:21:14.470 --> 00:21:17.770
Migration works just great
with ordered relationships.

00:21:17.870 --> 00:21:21.700
You can migrate a non-ordered
relationship to ordered and back.

00:21:21.760 --> 00:21:24.610
If you use lightweight migration,
we're going to give you an arbitrary

00:21:24.610 --> 00:21:28.460
ordering when you convert a
non-ordered to an ordered relationship.

00:21:28.580 --> 00:21:31.860
So you can use a post-processing
step after your migration to

00:21:31.860 --> 00:21:35.710
impose an initial ordering if
that ordering is important to you.

00:21:37.610 --> 00:21:41.090
And just to kind of sum up the
ordered relationship story,

00:21:41.110 --> 00:21:45.530
these are really designed to give
you an easy way to implement an

00:21:45.530 --> 00:21:48.290
ordered collection in your data model.

00:21:48.300 --> 00:21:53.510
If performance is your chief concern,
however, you're going to be able to tune

00:21:53.680 --> 00:21:58.000
performance a lot better with a
non-ordered relationship and then

00:21:58.000 --> 00:22:01.700
using a property and sort descriptors
to order those results when you fetch.

00:22:04.920 --> 00:22:09.880
So now I want to introduce
UI Managed Document.

00:22:12.520 --> 00:22:17.500
UI Managed Document is based on
the Documents on iOS architecture.

00:22:17.620 --> 00:22:22.530
This is a new integrated document
architecture based around UI document

00:22:22.830 --> 00:22:26.990
that gives you auto-saving,
iCloud integration,

00:22:26.990 --> 00:22:29.700
and asynchronous I/O support.

00:22:29.820 --> 00:22:33.170
And I strongly encourage you,
if you're interested in documents,

00:22:33.280 --> 00:22:36.300
to check out the session
tomorrow in Presidio at 3:15,

00:22:36.450 --> 00:22:40.620
Storing Documents in iCloud Using iOS 5.

00:22:41.730 --> 00:22:44.460
So let's turn our attention
to UI Managed Document.

00:22:44.720 --> 00:22:48.500
It's UI document based,
but it adds all the Core Data features

00:22:48.600 --> 00:22:50.710
on top of that for managing your data.

00:22:50.880 --> 00:22:55.250
You can scale the large data sets,
you get undo/redo support built in,

00:22:55.470 --> 00:22:58.120
all the graph management,
searching and sorting,

00:22:58.230 --> 00:23:02.650
as well as some great
conflict resolution solutions.

00:23:03.810 --> 00:23:07.460
In terms of working
with managed documents,

00:23:07.550 --> 00:23:12.410
the UIManagedDocument class is a
concrete subclass of UIDocument.

00:23:12.540 --> 00:23:17.550
So you can just go and instantiate
one in your application,

00:23:17.670 --> 00:23:20.640
configure some store options
or a model configuration,

00:23:20.760 --> 00:23:24.220
and then it will work with whatever
data model it finds in your app bundle.

00:23:24.480 --> 00:23:27.900
And that's just the default behavior
out of the box if you don't want

00:23:27.900 --> 00:23:29.870
to create a custom subclass.

00:23:30.850 --> 00:23:33.630
I mentioned that UIDocument
gives you a synchronous I/O.

00:23:33.640 --> 00:23:36.430
And why is that?

00:23:36.900 --> 00:23:40.340
UI Document wants to keep your document
saved all the time so that whenever

00:23:40.340 --> 00:23:44.260
the user hits the home button or
your process needs to be suspended,

00:23:44.260 --> 00:23:46.850
the data is persistent on disk.

00:23:46.900 --> 00:23:49.140
But you don't want your
user being interrupted while

00:23:49.140 --> 00:23:51.490
they're doing their work,
while they're interacting

00:23:51.490 --> 00:23:52.760
with your application.

00:23:52.760 --> 00:23:58.120
So UI Document gives you a great model
for performing a synchronous I.O.

00:23:58.120 --> 00:24:01.950
to keep the main thread free
to interact with your user.

00:24:01.960 --> 00:24:08.080
And the way that works is the caller
initiates an open or a read or a save,

00:24:08.080 --> 00:24:12.470
and then the save takes a snapshot
of the state synchronously.

00:24:12.500 --> 00:24:14.400
But it doesn't write it out to disk.

00:24:14.520 --> 00:24:17.620
What it does is when you
call that open read or save,

00:24:17.620 --> 00:24:22.450
you pass in a completion handler block,
and then UI Document hands

00:24:22.450 --> 00:24:27.560
that snapshot of state to a
background queue that it owns,

00:24:27.600 --> 00:24:29.580
and it performs the I.O.

00:24:30.300 --> 00:24:31.260
asynchronously.

00:24:32.110 --> 00:24:35.490
When that work is complete,
it then calls your completion handler

00:24:35.490 --> 00:24:37.590
block back on the main thread again.

00:24:38.120 --> 00:24:41.280
So how does that work
with UI Managed Document?

00:24:41.320 --> 00:24:44.780
Well, let's take a look at how
an asynchronous load works.

00:24:45.010 --> 00:24:49.030
Well, to be perfectly honest,
it's a Core Data application,

00:24:49.080 --> 00:24:51.730
so at load time, we're really not doing
all that much work.

00:24:51.800 --> 00:24:54.420
We simply add the store when you open it.

00:24:54.520 --> 00:25:00.240
We generally don't do any reading of the
data until you request specific data.

00:25:00.240 --> 00:25:03.510
That's the whole idea of working
with just the data you're using.

00:25:03.560 --> 00:25:06.920
But one of the benefits of this
is because we are adding the

00:25:06.920 --> 00:25:10.970
store in the background queue,
if you have to do a migration,

00:25:11.030 --> 00:25:14.170
that migration occurs in the
background and won't freeze up your

00:25:14.170 --> 00:25:16.510
main thread or your user interface.

00:25:18.220 --> 00:25:22.300
And we can take a look at how this works,
nice graphical format.

00:25:22.560 --> 00:25:25.940
You call open on the main
queue on the document.

00:25:26.020 --> 00:25:29.770
And then it calls its load method,
which calls add persistence

00:25:29.800 --> 00:25:31.980
store on a background queue.

00:25:32.720 --> 00:25:35.040
If a migration occurs,
a migration occurs.

00:25:35.170 --> 00:25:40.130
But when that work is done,
we then pass the completion block back

00:25:40.660 --> 00:25:44.820
on the main queue so you can let your
user know the document's ready for

00:25:44.880 --> 00:25:46.990
viewing or simply present it to them.

00:25:47.560 --> 00:25:50.640
On the writing side,
the way asynchronous writes work with

00:25:50.640 --> 00:25:56.060
UIManagedDocument is this is where we
get the value of those nested contexts.

00:25:56.140 --> 00:26:00.800
The document works with a main
context that runs on the main queue.

00:26:00.920 --> 00:26:03.950
And so when you request
to save on the document,

00:26:04.080 --> 00:26:09.250
on the managed document,
that child context takes a snapshot and

00:26:09.250 --> 00:26:13.290
then saves the changes to the parent
which is running on a background queue.

00:26:13.660 --> 00:26:17.220
The parent context will save those
changes to disk on a background

00:26:17.610 --> 00:26:20.300
queue and not hold up your UI thread.

00:26:20.420 --> 00:26:22.200
And we'll take a look at how
this is actually working.

00:26:22.200 --> 00:26:28.050
You call save on the main queue,
and then the UIManagedDocument calls

00:26:28.050 --> 00:26:30.900
save on the document's context.

00:26:31.320 --> 00:26:34.940
Then on the background queue,
we call write,

00:26:34.940 --> 00:26:38.540
and the parent context then saves,
writes the changes to

00:26:38.700 --> 00:26:40.570
disk in the background.

00:26:40.950 --> 00:26:43.550
Finally, when that work is done,
the completion block

00:26:43.630 --> 00:26:46.280
executes on the main queue,
and you can let your user know

00:26:46.400 --> 00:26:49.780
that the document is saved if
that's something you want to do.

00:26:49.800 --> 00:26:53.420
UI Managed Document also adds
support for unmodeled data.

00:26:53.440 --> 00:26:57.380
And the idea here is,
as we always are saying in Core Data,

00:26:57.400 --> 00:27:02.060
large files should live outside
of the database whenever possible,

00:27:02.140 --> 00:27:04.900
something like movies or large pictures.

00:27:04.910 --> 00:27:07.820
And we wanted to give you
a way to handle additional

00:27:07.910 --> 00:27:09.930
content in UI Managed Document.

00:27:10.170 --> 00:27:13.440
So when UI Managed
Document saves its data to disk,

00:27:13.510 --> 00:27:15.860
it's actually saving
inside a file package.

00:27:15.860 --> 00:27:17.660
It's not just a single file.

00:27:17.660 --> 00:27:20.140
It's a folder that can
contain many files.

00:27:20.170 --> 00:27:24.590
And so we've added some optional
API that you can choose to override in

00:27:24.590 --> 00:27:28.050
a subclass to add your own additional
content into that file package

00:27:28.460 --> 00:27:31.390
whenever the document is asked to save.

00:27:32.120 --> 00:27:35.060
And the API for supporting
that looks like this.

00:27:35.060 --> 00:27:39.180
When you want to read
additional content -- I'm sorry.

00:27:39.180 --> 00:27:42.850
When the document is
asked to read from a file,

00:27:42.970 --> 00:27:48.500
we will call read additional
content from URL on your subclass.

00:27:48.500 --> 00:27:52.640
And when the document is asked to save,
we will call additional content

00:27:52.650 --> 00:27:54.760
for URL on your subclass.

00:27:54.760 --> 00:27:57.270
And that method is called synchronously.

00:27:57.270 --> 00:28:00.960
And the idea is you package up a
snapshot of what you want to write out,

00:28:01.090 --> 00:28:04.250
and then we'll call write additional
content on the background queue

00:28:04.580 --> 00:28:10.070
and you can write out that data
to disk taking as long as it needs.

00:28:10.560 --> 00:28:14.110
So the summary is we've built
UI Managed Document on top of

00:28:14.130 --> 00:28:16.400
the UI Document architecture.

00:28:16.400 --> 00:28:19.980
It's a powerful architecture
that's well supported in iOS.

00:28:19.980 --> 00:28:23.580
You get to take advantage
of the power of Core Data.

00:28:23.580 --> 00:28:28.500
And you also get support for adding
any unmodeled content to your document.

00:28:28.500 --> 00:28:32.310
Additionally,
UI Managed Document gives you the best

00:28:32.310 --> 00:28:37.740
of the document support for iCloud
and Core Data support for iCloud.

00:28:37.740 --> 00:28:46.810
And now I'd like to introduce
Nick Gillett to talk to you about iCloud.

00:28:51.390 --> 00:28:52.320
So I'm Nick Gillett.

00:28:52.320 --> 00:28:55.100
I'm a software engineer
on the Core Data team.

00:28:55.100 --> 00:28:59.020
And I'm going to start off today
by talking to you about iCloud.

00:28:59.050 --> 00:29:02.340
So I'm sure many of you by now
have heard about iCloud and its

00:29:02.470 --> 00:29:06.800
persistent storage features for data
that it pushes up into the cloud.

00:29:06.810 --> 00:29:09.370
But at Core Data,
we thought that there were some

00:29:09.380 --> 00:29:13.120
features that we could provide to
you that would be useful as well.

00:29:14.710 --> 00:29:18.700
With iOS 5 and
Mac OS X Lion using Core Data,

00:29:18.780 --> 00:29:25.730
you can sync data between your devices
and your computers using Core Data.

00:29:26.510 --> 00:29:29.320
We wanted this integration
to be as easy as possible.

00:29:29.390 --> 00:29:33.100
So today, I'll show you the new API that
we're introducing that you'll

00:29:33.330 --> 00:29:35.300
pick up to integrate with it.

00:29:35.580 --> 00:29:38.000
And finally,
we thought that we could do the hard

00:29:38.000 --> 00:29:43.350
work of merging conflicts when they
occur into your data store automatically.

00:29:45.370 --> 00:29:47.960
So what do you get?

00:29:47.980 --> 00:29:51.240
We're going to work on top
of all your existing stores.

00:29:51.240 --> 00:29:55.480
And we do per record conflict resolution.

00:29:55.490 --> 00:29:58.890
Also, because we have knowledge of
your application's object graph,

00:29:59.040 --> 00:30:02.270
we can ensure that only the
deltas are synced across the wire,

00:30:02.550 --> 00:30:06.090
reducing your user's overall
bandwidth requirements.

00:30:07.030 --> 00:30:10.570
will import these changes asynchronously
into your data store so that

00:30:10.570 --> 00:30:13.040
your user doesn't notice a thing.

00:30:13.470 --> 00:30:16.980
And when conflicts do happen,
we'll use a three-way merge to make

00:30:17.290 --> 00:30:20.590
sure that the correct values are
propagated through to the final result.

00:30:22.650 --> 00:30:24.300
How does that work?

00:30:24.370 --> 00:30:27.000
Well, imagine that you're editing
a record in your store.

00:30:27.060 --> 00:30:32.020
The user is perhaps using an application
that stores address book content.

00:30:32.070 --> 00:30:35.940
And they make a change to
the first name of the person.

00:30:35.990 --> 00:30:39.940
Later, on the same device,
they change the last name.

00:30:40.400 --> 00:30:43.380
In the meantime, perhaps they got
interrupted by a phone call,

00:30:43.380 --> 00:30:46.320
and someone at their house used
their computer to change the same

00:30:46.320 --> 00:30:48.990
record and update the email address.

00:30:49.090 --> 00:30:52.640
We'll take a look at all of these changes
when we pick them up out of the cloud

00:30:53.090 --> 00:30:56.300
and merge them into a single record,
picking up the relevant

00:30:56.300 --> 00:30:57.500
changes from each.

00:30:57.820 --> 00:31:01.480
Thank you.

00:31:03.540 --> 00:31:06.660
What this hopefully means for you is
that there's a lot less code that you

00:31:06.660 --> 00:31:09.140
have to write to integrate with iCloud.

00:31:09.200 --> 00:31:11.720
You'll use a couple of options
when adding your persistent

00:31:11.850 --> 00:31:13.460
store to the coordinator.

00:31:13.520 --> 00:31:16.790
And you'll have to respond to a
notification that we imported data

00:31:16.940 --> 00:31:19.490
from the cloud into your store.

00:31:20.490 --> 00:31:22.870
For our part,
we'll take responsibility for

00:31:22.930 --> 00:31:25.320
handling all the integration,
including integrating

00:31:25.320 --> 00:31:28.080
with NS File Coordinator,
File Presenter,

00:31:28.100 --> 00:31:32.540
and NS Metadata Query to know that
changes are available in the cloud.

00:31:32.580 --> 00:31:37.060
We'll also monitor your stores and
export the changes for you automatically.

00:31:37.080 --> 00:31:41.260
And when they're available in the cloud,
we'll import them for you.

00:31:42.110 --> 00:31:44.060
And how does this work?

00:31:44.130 --> 00:31:45.640
This is a typical user scenario.

00:31:45.850 --> 00:31:50.120
Maybe there's a mobile device,
and they have a home computer as well.

00:31:50.420 --> 00:31:54.570
When a change is made or a
document is created on the device,

00:31:54.600 --> 00:31:58.610
calling NSManageObjectContextSave will
push that document or

00:31:58.610 --> 00:32:00.900
object into the cloud.

00:32:00.990 --> 00:32:04.240
The running application on the
Mac will notice that a new change

00:32:04.240 --> 00:32:07.600
is available from one of the
peer devices and automatically

00:32:07.600 --> 00:32:09.880
import it to the persistent store.

00:32:10.070 --> 00:32:13.900
When changes are made on the Mac,
they'll also be automatically

00:32:13.900 --> 00:32:18.360
exported into the cloud when
NSManageObjectContextSave is called.

00:32:18.420 --> 00:32:23.750
And we'll import those into the device
when the application is running.

00:32:26.070 --> 00:32:28.840
There's some new API that
we're introducing today.

00:32:28.860 --> 00:32:31.450
You can use two new persistent
store options to configure

00:32:31.590 --> 00:32:33.060
your iCloud settings.

00:32:33.080 --> 00:32:35.430
There are
NSPersistentStoreUbiquitousContentName

00:32:35.440 --> 00:32:39.500
key and
NSPersistentStoreUbiquitousContentURL key

00:32:39.500 --> 00:32:40.610
.

00:32:40.820 --> 00:32:44.250
There's also a new notification
that we'll post called NS Persistent

00:32:44.250 --> 00:32:48.690
Store Did Import Ubiquitous
Content Changes Notification.

00:32:53.210 --> 00:32:56.390
I had a lot of fun trying
to fit that on a slide.

00:32:56.400 --> 00:32:58.150
Don't worry if you didn't
get to write it down.

00:32:58.160 --> 00:33:01.200
We'll get back to it later.

00:33:01.240 --> 00:33:04.900
The NS Persistence
Store Ubiquitous Content Name Key

00:33:05.770 --> 00:33:08.510
is a helper for us.

00:33:08.610 --> 00:33:11.550
Some applications talk to
multiple persistence stores,

00:33:11.550 --> 00:33:14.850
and we found it difficult to keep
track of them across all of your

00:33:14.850 --> 00:33:17.600
devices running multiple applications.

00:33:17.600 --> 00:33:20.770
So we need you to give us some
help and provide us with a

00:33:20.790 --> 00:33:25.220
file system friendly string,
so no slashes, exclamation points,

00:33:25.340 --> 00:33:28.920
or @ symbols please,
that we can use to identify a given

00:33:29.010 --> 00:33:34.590
persistence store on any device running
any application on any platform.

00:33:34.600 --> 00:33:36.790
It has to be the same everywhere.

00:33:39.350 --> 00:33:41.800
NS Persistent Store Ubiquitous
Content URL Key,

00:33:41.800 --> 00:33:43.410
however, is optional.

00:33:43.600 --> 00:33:45.240
You don't have to provide it.

00:33:45.310 --> 00:33:47.700
We will generate one for you.

00:33:47.760 --> 00:33:50.600
This key is designed so that we
know where on the file system you

00:33:50.600 --> 00:33:54.570
would like us to stick the metadata
that we keep about your stores.

00:33:54.640 --> 00:33:57.370
It's an opaque package,
so you shouldn't attempt to

00:33:57.370 --> 00:34:00.930
modify it or inspect it or
generally do anything with it.

00:34:01.200 --> 00:34:02.240
Just leave it to us.

00:34:02.290 --> 00:34:04.230
And there are some scenarios
where you're going to want

00:34:04.240 --> 00:34:05.640
to provide this on your own.

00:34:05.690 --> 00:34:10.010
If you are sharing data between
applications running on Mac OS X and iOS,

00:34:10.050 --> 00:34:12.680
for example,
you will want to provide your own,

00:34:12.760 --> 00:34:17.200
because it is highly unlikely that
your Ubiquiti container ID will be

00:34:17.390 --> 00:34:20.000
the same as your bundle identifier.

00:34:20.880 --> 00:34:24.260
If you want to know how we're going
to generate this default for you,

00:34:24.260 --> 00:34:25.930
this is the code that we use.

00:34:26.070 --> 00:34:28.760
We take your bundle ID from
the running application,

00:34:28.770 --> 00:34:33.460
and we call NSFileManager
URL for Ubiquiti container ID.

00:34:33.500 --> 00:34:37.040
This is the standard method that's
used to fetch out the container

00:34:37.040 --> 00:34:39.090
URL for a given application.

00:34:39.220 --> 00:34:42.650
The reason why this has to be different
if you're sharing data is because

00:34:42.920 --> 00:34:47.110
applications running on Mac OS X will
often have a different bundle

00:34:47.110 --> 00:34:49.340
identifier than they will on iOS.

00:34:51.150 --> 00:34:53.380
Finally, the notification.

00:34:53.580 --> 00:34:58.320
NS Persistent Store did import
Ubiquitous Content Changes notification.

00:34:58.390 --> 00:35:02.930
It's posted once for each persistent
store coordinator whose persistent

00:35:02.930 --> 00:35:05.320
store has been modified by the import.

00:35:05.380 --> 00:35:08.920
If for some reason your application uses
multiple persistent store coordinators

00:35:09.060 --> 00:35:12.790
to talk to the same persistent store,
you will receive one

00:35:12.790 --> 00:35:14.640
notification for each.

00:35:14.710 --> 00:35:17.900
And the user info dictionary is very
similar to Manage Object Context

00:35:18.000 --> 00:35:21.490
did save user info dictionary,
except that it contains

00:35:21.570 --> 00:35:26.440
a collection of Manage
Object IDs instead of Manage Objects.

00:35:26.530 --> 00:35:29.530
This is because we're doing
imports asynchronously,

00:35:29.630 --> 00:35:33.050
and we cannot guarantee that your
notification will be posted on the same

00:35:33.050 --> 00:35:35.790
thread as the objects were modified.

00:35:36.660 --> 00:35:39.580
When you respond to an import,
you can treat it like

00:35:39.580 --> 00:35:40.900
a save notification.

00:35:41.110 --> 00:35:43.780
You should refresh objects
in your local context.

00:35:43.920 --> 00:35:46.520
And if you've changed any
objects in your context,

00:35:46.770 --> 00:35:50.640
you should merge them using
an appropriate merge policy.

00:35:51.810 --> 00:35:53.820
If you're using a
document syncing paradigm,

00:35:53.970 --> 00:35:56.420
there are a couple
considerations you should make.

00:35:56.550 --> 00:35:59.650
The first is that atomic
stores can be synced wholesale.

00:35:59.950 --> 00:36:02.180
That is, you can sync their entire file.

00:36:02.310 --> 00:36:06.660
But you won't get conflict resolution,
and the last writer will win.

00:36:06.800 --> 00:36:10.890
SQLite should not be
synced as a wholesale file.

00:36:12.320 --> 00:36:16.600
You can also use the UIDocument conflict
resolution APIs if you're creating

00:36:16.600 --> 00:36:21.150
a subclass of UIDocument to use with
your store as a way of attempting to

00:36:21.150 --> 00:36:23.940
do conflict resolution on your own.

00:36:25.800 --> 00:36:27.700
A few tips and tricks.

00:36:27.730 --> 00:36:30.440
You should, of course,
respond to the import notification.

00:36:30.490 --> 00:36:34.350
This is our only way of notifying you
that changes have been made to the

00:36:34.350 --> 00:36:37.210
store underneath your application.

00:36:37.630 --> 00:36:40.180
When I say use an
appropriate merge policy,

00:36:40.250 --> 00:36:43.610
I mean that
NSMergeByPropertyStoreTrumpMergePolicy

00:36:43.930 --> 00:36:47.130
and
NSMergeByPropertyObjectTrumpMergePolicy

00:36:47.290 --> 00:36:50.610
are two alternatives
to the default NSErrorMergePolicy

00:36:50.880 --> 00:36:52.380
that provide some useful behavior.

00:36:52.380 --> 00:36:56.320
And be sure to anticipate
bandwidth considerations.

00:36:56.960 --> 00:37:00.390
If your saves normally
generate large deltas,

00:37:00.620 --> 00:37:03.280
that is, that there's a large amount
of data that's being generated

00:37:03.740 --> 00:37:06.880
from one save to the next,
consider that that data will have

00:37:06.970 --> 00:37:10.540
to be pushed over the wire to the
cloud and then downloaded by all

00:37:10.550 --> 00:37:12.240
of your devices and computers.

00:37:12.240 --> 00:37:15.100
Your users might not think
that that's such a good idea.

00:37:15.100 --> 00:37:18.090
You should also use .nosync.

00:37:18.120 --> 00:37:21.790
This tells the iCloud integration
that you don't want to sync

00:37:21.790 --> 00:37:23.880
certain pieces of data across.

00:37:24.410 --> 00:37:27.370
And it's a good way to make sure that
things that don't need to be synced,

00:37:27.560 --> 00:37:32.210
like the persistent store file itself,
aren't pushed up into the cloud.

00:37:32.920 --> 00:37:35.640
While we're on the subject
of persistent storage,

00:37:35.720 --> 00:37:39.000
I'd like to introduce incremental stores.

00:37:39.920 --> 00:37:42.570
For years,
developers have wondered why we

00:37:42.580 --> 00:37:46.510
only support these four types of
persistence stores when there are so

00:37:46.510 --> 00:37:50.900
many other persistence technologies
and database technologies out there.

00:37:50.920 --> 00:37:55.280
And I'm happy to tell you that today,
using NSIncremental Store,

00:37:55.300 --> 00:38:00.470
you can write your own.

00:38:03.090 --> 00:38:05.950
With an incremental store,
you can talk to your data in

00:38:05.950 --> 00:38:08.240
whatever language you want.

00:38:09.430 --> 00:38:12.390
And you get all the great
features of Core Data,

00:38:12.390 --> 00:38:16.400
like only loading the data you
need when you actually need it.

00:38:16.670 --> 00:38:19.820
We also support faulting so
that you don't have to load

00:38:19.910 --> 00:38:22.610
completed objects into memory.

00:38:24.960 --> 00:38:25.400
It's OK.

00:38:25.400 --> 00:38:27.560
Keep it coming.

00:38:27.800 --> 00:38:31.740
And you can flush unused data
when you're done with it.

00:38:32.810 --> 00:38:34.940
So how does this work?

00:38:34.990 --> 00:38:38.540
Well, the idea is that you'll create
a persistent store coordinator.

00:38:38.590 --> 00:38:42.280
And calling addPersistentStoreOfType,
you'll try to load

00:38:42.280 --> 00:38:43.880
your incremental store.

00:38:43.920 --> 00:38:47.650
We'll call loadMetadata on it to
determine if the metadata is compatible

00:38:47.650 --> 00:38:51.800
with the managed object model that
you're attempting to use to open it.

00:38:51.940 --> 00:38:54.460
If it is,
eventually your application will

00:38:54.460 --> 00:38:56.440
create a managed object context.

00:38:56.470 --> 00:39:01.420
And a fetch request will be sent
down to your store to get some data.

00:39:01.470 --> 00:39:06.370
We'll call a new API method called
executeRequestWithContextError on your

00:39:06.370 --> 00:39:09.780
store with an instance of NSFetchRequest.

00:39:09.840 --> 00:39:12.630
And you'll return some objects.

00:39:13.290 --> 00:39:17.440
These objects will be pushed
up into the context for you.

00:39:17.460 --> 00:39:22.120
And when value for key is invoked,
we'll call another method,

00:39:22.140 --> 00:39:25.500
new values for object with
ID with context error,

00:39:25.500 --> 00:39:28.300
to get the values for that property.

00:39:28.330 --> 00:39:31.390
If a relationship is called for,
then we'll call new values

00:39:31.480 --> 00:39:35.220
for relationship for object
with ID with context.

00:39:35.240 --> 00:39:39.790
This is important because it's often more
expensive to load values for relationship

00:39:40.060 --> 00:39:42.510
than it is for a normal attribute.

00:39:43.830 --> 00:39:47.420
Finally,
when an object tries to save or the user

00:39:47.470 --> 00:39:51.970
tries to save changes from their context,
we'll call obtain permanent

00:39:51.980 --> 00:39:53.460
IDs for objects error.

00:39:53.520 --> 00:39:57.070
And we'll expect that you'll
give us back a complete set of

00:39:57.160 --> 00:40:00.510
permanent managed object IDs that
we can work with throughout

00:40:00.510 --> 00:40:02.700
the lifecycle of those objects.

00:40:03.480 --> 00:40:05.880
Finally,
Walkout will call execute request

00:40:06.040 --> 00:40:11.390
with context error again with an
instance of NSSaveChangesRequest.

00:40:13.400 --> 00:40:16.280
Occasionally,
we'll also need to communicate with your

00:40:16.280 --> 00:40:18.620
data in a format that we can understand.

00:40:18.660 --> 00:40:22.130
And this is where
NSIncrementalStoreNode comes in.

00:40:22.380 --> 00:40:26.900
We'll initialize it with a knit
with object ID with values version.

00:40:26.910 --> 00:40:30.400
And after that,
it's an opaque container to you.

00:40:30.410 --> 00:40:33.380
You can get the object ID for
the incremental store node in

00:40:33.380 --> 00:40:38.680
question and values from it using
value for property description.

00:40:38.990 --> 00:40:42.900
When we talk to your incremental store,
we'll use an instance of

00:40:42.900 --> 00:40:46.560
NSPersistentStoreRequest and
its two concrete subclasses,

00:40:46.780 --> 00:40:50.200
NSSaveChangesRequest and NSFetchRequest.

00:40:50.460 --> 00:40:54.780
But you'll have to do the switching
in your execute request with

00:40:54.780 --> 00:40:57.390
context error method on your own.

00:40:58.970 --> 00:41:02.880
There will be flags on a fetch request
that will affect both the performance and

00:41:02.880 --> 00:41:05.580
the result set that you pass back to us.

00:41:05.580 --> 00:41:08.340
You should obey those if you can,
but if you can't,

00:41:08.340 --> 00:41:10.170
you must degrade gracefully.

00:41:10.180 --> 00:41:13.130
You cannot fail because
certain flags are set.

00:41:15.460 --> 00:41:18.600
We will provide you with all the
object ID mapping APIs you need

00:41:19.040 --> 00:41:21.670
to create object IDs and use them.

00:41:22.250 --> 00:41:27.410
And you can use get managed objects
from context using object with ID.

00:41:28.830 --> 00:41:32.180
But we will not provide
you our SQL generator.

00:41:32.180 --> 00:41:35.940
We recommend that you use canned queries
instead to keep your implementations

00:41:35.940 --> 00:41:42.860
as simple as possible to translate a
fixed set of NS predicates into a fetch

00:41:42.860 --> 00:41:46.960
request or into the request that you
actually make back from your store.

00:41:46.960 --> 00:41:50.310
There's also a JSON provider
in Foundation if your

00:41:50.380 --> 00:41:52.630
persistence model uses that.

00:41:57.600 --> 00:41:59.950
Finally,
we recommend that you design your

00:42:00.030 --> 00:42:04.370
store to fulfill a specific use case,
that is, design it to a specific

00:42:04.370 --> 00:42:06.200
application schema.

00:42:06.290 --> 00:42:09.400
and that you try to balance
your I/O requirements and

00:42:09.400 --> 00:42:11.100
your memory requirements.

00:42:11.160 --> 00:42:13.750
We don't provide you any
kind of caching APIs,

00:42:13.750 --> 00:42:15.990
but we do heavily recommend it.

00:42:16.660 --> 00:42:19.030
This is also the best way
to talk to web services.

00:42:19.340 --> 00:42:23.020
If you're using something like
a REST API or even a SOAP API,

00:42:23.230 --> 00:42:26.510
this is the best way to get
your data into Core Data.

00:42:27.920 --> 00:42:33.140
Now I'd like to give you a tour of
our changes to the developer tools.

00:42:33.210 --> 00:42:35.790
As you know,
Xcode 4 changes a lot of things about

00:42:35.810 --> 00:42:38.100
how you work with your applications.

00:42:38.190 --> 00:42:40.010
Most notably, there's a new UI.

00:42:40.330 --> 00:42:42.670
But at Core Data,
we're also introducing new optimized

00:42:42.760 --> 00:42:47.510
managed object models that load
faster and require less memory.

00:42:49.600 --> 00:42:53.920
We're also introducing readable
diffable models that you can use

00:42:53.970 --> 00:42:56.280
with your favorite diff tool.

00:43:00.230 --> 00:43:04.010
and faster scalar accessors
for primitive property types.

00:43:04.080 --> 00:43:10.630
I know, readable models,
it's hard to beat that one.

00:43:11.010 --> 00:43:12.820
We have a new UI.

00:43:12.840 --> 00:43:15.180
In the upper left,
you'll find your entities.

00:43:15.400 --> 00:43:18.650
And if you're using a table view,
you'll see a list of attributes,

00:43:18.650 --> 00:43:21.040
relationships, and fetch properties.

00:43:21.050 --> 00:43:24.590
You'll also see your fetch
requests on the left-hand side.

00:43:24.770 --> 00:43:27.700
In the bottom left,
you can switch between a tree style

00:43:27.980 --> 00:43:30.710
and an outline style for the viewer.

00:43:31.000 --> 00:43:33.280
You can also add fetch requests.

00:43:33.280 --> 00:43:36.360
And at the bottom right,
you can switch between our classic

00:43:36.360 --> 00:43:41.110
diagram layout and the table layout,
as well as add attributes.

00:43:41.370 --> 00:43:44.790
On the upper right-hand side,
using the Core Data Inspector,

00:43:44.790 --> 00:43:49.540
looks kind of like a database tab,
you'll be able to see the inspector

00:43:49.540 --> 00:43:53.840
for either the entity you've selected,
the fetch request, the attribute,

00:43:53.960 --> 00:43:58.640
the property, or the relationship that
you've chosen to highlight.

00:44:00.140 --> 00:44:05.780
This is our classic diagram view,
which hasn't changed very much.

00:44:05.820 --> 00:44:08.090
The optimized model format.

00:44:08.260 --> 00:44:10.740
It's much faster than before.

00:44:10.790 --> 00:44:14.320
And it's an automatic
transition with Xcode 4.

00:44:14.380 --> 00:44:16.780
It also lives in parallel
with regular models,

00:44:16.850 --> 00:44:19.270
so there's no switching necessary.

00:44:20.490 --> 00:44:24.980
Our user-readable models are also
an automatic upgrade in Xcode 4.

00:44:25.100 --> 00:44:27.810
As far as you know,
it should be transparent.

00:44:27.990 --> 00:44:30.090
They're based on XML,
and they should work with

00:44:30.090 --> 00:44:32.300
your favorite diff tools.

00:44:35.860 --> 00:44:38.770
In order to get a readable model,
you need to use a minimum

00:44:38.770 --> 00:44:42.860
supported version,
4.1 or higher, for Xcode.

00:44:42.890 --> 00:44:48.080
But if that's set, you should be upgraded
automatically to the XML models.

00:44:49.130 --> 00:44:52.900
Our scalar accessors avoid the
overhead of traditional value object

00:44:52.970 --> 00:44:55.090
construction for primitive types.

00:44:55.330 --> 00:44:58.760
And they're a checkbox during creation.

00:44:59.330 --> 00:45:02.360
We're also integrated with
Arc now to make the memory

00:45:02.360 --> 00:45:04.540
management a lot easier for you.

00:45:04.610 --> 00:45:08.260
And there's no need to implement or call,
retain, or release when using an

00:45:08.260 --> 00:45:10.650
Arc-compiled application.

00:45:10.780 --> 00:45:14.300
It's an opt-in per project,
but if you have files that

00:45:14.300 --> 00:45:17.960
require specific retain and
release memory management,

00:45:17.970 --> 00:45:20.890
you can do that on a file-by-file basis.

00:45:21.170 --> 00:45:25.030
You should definitely see this
session or watch it on iTunes.

00:45:26.690 --> 00:45:32.990
We're also introducing a new
feature called External Binary Data.

00:45:35.090 --> 00:45:39.800
We've noticed that you really like
using Core Data to store your images.

00:45:39.840 --> 00:45:41.040
And that's fine.

00:45:41.090 --> 00:45:45.070
But it puts some interesting load
characteristics on the SQLite store.

00:45:45.150 --> 00:45:49.990
So now, by checking this box,
we'll put the file outside

00:45:49.990 --> 00:45:52.660
the SQLite store for you.

00:46:00.450 --> 00:46:04.050
We're also introducing
compound indexes in SQLite,

00:46:04.050 --> 00:46:07.580
which means that by
filling out this table,

00:46:07.600 --> 00:46:10.950
you can index on as many
properties as you'd like.

00:46:18.470 --> 00:46:21.680
Finally, what did we talk about today?

00:46:21.700 --> 00:46:24.170
Well, at Core Data,
we have some amazing new features

00:46:24.260 --> 00:46:27.840
for you in iOS 5 and Mac OS X Lion.

00:46:27.860 --> 00:46:30.680
We're integrated with iCloud,
giving you the easiest way to

00:46:30.680 --> 00:46:33.920
get your applications up and
running on top of the service.

00:46:33.920 --> 00:46:38.000
And we've introduced several
new documents types for you.

00:46:38.030 --> 00:46:41.540
There's also new data protection
APIs to help keep your data safe,

00:46:41.610 --> 00:46:45.100
and an incremental store to
allow you to talk to any data

00:46:45.100 --> 00:46:47.800
persistence API you wish.

00:46:47.810 --> 00:46:51.600
As well, ordered relationships to
help you keep the data in the

00:46:51.600 --> 00:46:55.710
order that your user wants,
not that your sort descriptor wants.

00:46:55.900 --> 00:46:58.340
Finally,
you should get back to us on the forums

00:46:58.820 --> 00:47:03.280
or file bug reports and enhancement
requests at bugreport.apple.com.

00:47:03.400 --> 00:47:07.440
Thank you.

00:47:11.810 --> 00:47:14.460
For more information,
please contact Michael Jurowicz,

00:47:14.500 --> 00:47:17.790
our Developer Tools Evangelist,
or check us out on the web

00:47:17.800 --> 00:47:19.200
at developer.apple.com.

00:47:25.470 --> 00:47:30.400
And there's also some related
sessions that we think are important.

00:47:30.400 --> 00:47:33.680
But feel free to check
those out here or on iTunes.

00:47:33.730 --> 00:47:35.190
Thank you.
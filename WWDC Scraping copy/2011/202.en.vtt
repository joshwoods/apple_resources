WEBVTT

00:00:11.500 --> 00:01:17.100
[Transcript missing]

00:01:18.820 --> 00:01:20.060
So what are we securing?

00:01:20.110 --> 00:01:25.540
One of the big things is data,
information, things like credentials,

00:01:25.590 --> 00:01:30.700
usernames and passwords to websites
or other applications or assets

00:01:30.700 --> 00:01:33.090
on an internal network somewhere.

00:01:33.420 --> 00:01:34.800
Also privacy.

00:01:34.880 --> 00:01:38.010
Personal information is very
important to keep confidential.

00:01:38.180 --> 00:01:43.600
Things like real names, email addresses,
or geographical location.

00:01:43.900 --> 00:01:47.090
It's also important to
protect financial information,

00:01:47.090 --> 00:01:50.790
which is very attractive to an attacker,
as well as business information

00:01:50.790 --> 00:01:52.920
that might belong to a user.

00:01:52.920 --> 00:01:57.070
Now, the second category of assets
refers to things that are

00:01:57.180 --> 00:01:59.800
intrinsic to a device or a system.

00:01:59.800 --> 00:02:00.830
The resources.

00:02:00.830 --> 00:02:03.020
Things like its network access.

00:02:03.020 --> 00:02:05.510
The bandwidth that a machine has.

00:02:05.540 --> 00:02:07.540
Or its unique IP address.

00:02:08.410 --> 00:02:12.560
And these are things that are
valuable for botnet activities such

00:02:12.640 --> 00:02:14.640
as click fraud or sending spam.

00:02:15.740 --> 00:02:20.860
Now, attackers are also interested in new
devices and their new capabilities.

00:02:21.120 --> 00:02:23.780
In the '90s when everybody
had dial-up modems,

00:02:24.060 --> 00:02:25.840
you had auto dialers.

00:02:25.960 --> 00:02:30.170
And as you might have seen in the news,
they might be making a comeback

00:02:30.190 --> 00:02:32.230
on some insecure platforms.

00:02:33.430 --> 00:02:37.380
Next, attackers might be interested
in very large scale attacks,

00:02:37.540 --> 00:02:41.280
harnessing the computational
ability of millions of machines

00:02:41.280 --> 00:02:44.370
or their storage potential.

00:02:45.740 --> 00:02:47.720
So how do attackers work?

00:02:47.820 --> 00:02:49.910
How do they get into systems?

00:02:50.050 --> 00:02:53.720
Throughout this presentation,
I've categorized the different attack

00:02:54.230 --> 00:02:56.600
vectors into four different parts.

00:02:56.660 --> 00:02:59.840
And for each of these,
I'll describe the vulnerabilities and the

00:02:59.840 --> 00:03:03.180
defenses that you can take advantage of.

00:03:03.180 --> 00:03:05.300
The first is the user interface.

00:03:05.300 --> 00:03:09.060
What are the paradigms and what
are the symbols that users are

00:03:09.060 --> 00:03:12.690
used to that an attacker can use
to trick a user into performing an

00:03:12.700 --> 00:03:15.480
action against their own interest?

00:03:17.040 --> 00:03:21.420
What programming errors
exist in an application?

00:03:21.520 --> 00:03:24.760
From the fine print of the
CPU instruction set to the high

00:03:24.830 --> 00:03:27.360
level design of the application.

00:03:27.400 --> 00:03:32.090
What errors allow an attacker
to take advantage of a program

00:03:32.150 --> 00:03:34.790
to compromise a user's assets?

00:03:35.370 --> 00:03:38.540
How is information stored on a system?

00:03:38.590 --> 00:03:42.050
What happens to this information
if that portable device is

00:03:42.100 --> 00:03:44.890
lost or stolen or resold?

00:03:45.590 --> 00:03:51.960
And how is information transmitted by
your application across the internet?

00:03:54.440 --> 00:03:58.420
Now, just as there are many ways to
write a program and there are many

00:03:58.440 --> 00:04:02.670
ways to make a program secure,
there are very many ways to make errors.

00:04:02.670 --> 00:04:06.390
And some of these errors
translate to security flaws.

00:04:08.570 --> 00:04:10.060
Here are some examples.

00:04:10.250 --> 00:04:13.910
These are vulnerabilities that
are not specific to a particular

00:04:13.910 --> 00:04:15.760
application or a platform.

00:04:16.070 --> 00:04:20.000
These are generic attacks that we
see across the software industry.

00:04:20.060 --> 00:04:23.980
The user interface level.

00:04:23.980 --> 00:04:23.980
You have things like Trojan horses.

00:04:24.280 --> 00:04:26.730
from the mythology of the Trojan War.

00:04:26.810 --> 00:04:28.640
But in this case,
it might be a file that seems

00:04:28.640 --> 00:04:33.200
innocent but might actually try
to compromise a user's system.

00:04:33.240 --> 00:04:37.870
Things like phishing attacks
on email and spoofing attacks

00:04:37.920 --> 00:04:41.200
where legitimate applications
and websites are impersonated.

00:04:41.280 --> 00:04:43.710
And the user interface
should be friendly,

00:04:43.710 --> 00:04:47.940
but it should also be secure to
defend against these kinds of attacks.

00:04:48.780 --> 00:04:52.080
For code,
you have things like logic flaws,

00:04:52.330 --> 00:04:55.250
input sanitization errors,
and memory mismanagement errors,

00:04:55.300 --> 00:04:59.680
such as buffer overflows,
or calling a function

00:04:59.680 --> 00:05:02.130
pointer on a stale object.

00:05:03.820 --> 00:05:10.870
For storage security vulnerabilities,
the physical loss of a device

00:05:10.870 --> 00:05:16.300
could represent the complete
loss of all that information.

00:05:16.630 --> 00:05:21.020
So what can technology do to make sure
that that information is still safe

00:05:21.230 --> 00:05:26.160
even when their user is no longer in the
physical possession of their information?

00:05:27.740 --> 00:05:32.480
For transport, how is information being
transmitted securely?

00:05:32.510 --> 00:05:35.940
You might be using encryption,
but is it secure?

00:05:35.980 --> 00:05:38.500
Who are you encrypting your data to?

00:05:38.560 --> 00:05:39.380
Who is receiving it?

00:05:39.460 --> 00:05:46.650
So let's start talking about some of the
defenses that I'm going to cover today.

00:05:51.300 --> 00:05:55.700
So for the user interface, on Mac OS,
you might already be

00:05:55.700 --> 00:05:57.950
familiar with quarantine.

00:05:58.500 --> 00:06:00.400
I'll describe that.

00:06:00.400 --> 00:06:03.600
And also talk a little bit about
authorization and some of the

00:06:03.600 --> 00:06:05.820
improvements we've made there.

00:06:06.150 --> 00:06:08.000
The code level.

00:06:08.000 --> 00:06:13.780
We're doing all kinds of things to make
exploitation much more difficult as

00:06:13.840 --> 00:06:21.180
well as improving our tools to remove
low hanging fruit where possible.

00:06:21.180 --> 00:06:25.130
We also provide sandboxing
for damage control.

00:06:26.510 --> 00:06:31.760
For storage,
we have strong Unix file permissions.

00:06:31.820 --> 00:06:34.820
And we also have technologies
such as key chain,

00:06:34.890 --> 00:06:38.860
file vault, and data protection to solve
some of the most difficult

00:06:39.250 --> 00:06:41.560
problems with secure data storage.

00:06:43.540 --> 00:06:46.210
And last,
I'll talk about some of the great

00:06:46.210 --> 00:06:48.890
new things that we're doing for
transport security and some of the

00:06:48.890 --> 00:06:53.140
great innovations that have made
their way into Lion and iOS 5.

00:06:56.400 --> 00:07:00.480
To put things into context for you,
I have two mockups of some applications,

00:07:00.480 --> 00:07:03.910
an RSS reader and a
financial application.

00:07:03.940 --> 00:07:08.090
The RSS reader will be used to
demonstrate some of the flaws

00:07:08.090 --> 00:07:12.440
at the UI level and the code
category of vulnerabilities.

00:07:12.440 --> 00:07:17.540
Whereas the financial application has
some different security needs that lend

00:07:17.540 --> 00:07:20.360
well to storage and transport security.

00:07:23.090 --> 00:07:24.840
So consider an RSS reader.

00:07:24.880 --> 00:07:26.760
It seems pretty harmless.

00:07:26.790 --> 00:07:28.500
Doesn't have any passwords.

00:07:28.540 --> 00:07:32.210
Doesn't necessarily deal with
any personal information.

00:07:32.350 --> 00:07:34.300
In an ideal world,
it wouldn't have any security

00:07:34.300 --> 00:07:38.050
vulnerabilities because it
is not a secure application.

00:07:38.600 --> 00:07:40.290
doesn't offer security.

00:07:40.290 --> 00:07:42.960
That's not the case at all.

00:07:43.000 --> 00:07:48.070
An RSS reader actually presents a very
rich attack surface because it has

00:07:48.070 --> 00:07:53.180
support for things like HTML5 and all
the rich media that comes along with it.

00:07:53.210 --> 00:07:57.710
Movie files and movie decoders and
audio decoders and image parsers and

00:07:57.910 --> 00:08:02.370
all kinds of technologies that are
now within reach and triggerable.

00:08:02.580 --> 00:08:06.240
And it's network enabled,
so it's receiving untrusted

00:08:06.310 --> 00:08:09.090
input from unknown sites.

00:08:11.670 --> 00:08:16.060
So this is how an attacker might
actually see the RSS reader.

00:08:16.140 --> 00:08:18.300
They're going to look
at the entry points.

00:08:18.360 --> 00:08:22.600
They're going to look at the application
itself and the technologies it builds on.

00:08:22.720 --> 00:08:26.040
And attackers are going to look
for vulnerabilities in the complex

00:08:26.120 --> 00:08:28.360
interactions between these systems.

00:08:30.120 --> 00:08:34.010
So,
Atom feeds have support for enclosures.

00:08:34.250 --> 00:08:39.980
And enclosures are part of
the specification and they

00:08:39.980 --> 00:08:42.760
provide for downloading media.

00:08:42.760 --> 00:08:46.700
Arbitrary files that are
stored to a file system.

00:08:47.500 --> 00:08:52.450
So files are especially important
when considering user interface

00:08:52.450 --> 00:08:55.830
and a secure user interface.

00:08:55.910 --> 00:08:57.340
What kind of files can come in?

00:08:57.390 --> 00:09:00.360
Are there on-site file types?

00:09:01.640 --> 00:09:07.700
The RSS reader also has a URI handler
so that when a user clicks a link,

00:09:07.730 --> 00:09:10.600
they can immediately bring up this
application and it's convenient.

00:09:10.680 --> 00:09:15.360
But it introduces additional surface
for URI parsing vulnerabilities.

00:09:15.530 --> 00:09:19.560
As well as the feeds themselves,
which likely come over HTTP.

00:09:19.910 --> 00:09:22.640
So any attacker on the network
could inject data there.

00:09:22.900 --> 00:09:27.030
But in addition, RSS feeds aggregate data
from many different places.

00:09:27.160 --> 00:09:30.590
So the HTML code in there is untrusted.

00:09:32.690 --> 00:09:35.910
So let's talk a little about
user interface attacks.

00:09:36.040 --> 00:09:38.100
The Trojan horse.

00:09:40.090 --> 00:09:42.640
What do we do to prevent
Trojan horse attacks?

00:09:42.840 --> 00:09:47.660
There are two technologies,
or there are many technologies,

00:09:47.670 --> 00:09:52.670
but two of them that I'll talk about
today are quarantine and authorization.

00:09:53.570 --> 00:09:57.520
And consider an enclosure
that delivers a PDF file.

00:09:57.660 --> 00:09:59.510
It looks like this.

00:09:59.980 --> 00:10:03.010
Many of you have beautiful icons,
but this attacker wasn't very

00:10:03.010 --> 00:10:08.960
creative and they decided to just
reuse the icon for PDF files.

00:10:09.340 --> 00:10:11.480
But it's actually not a PDF.

00:10:11.530 --> 00:10:17.400
It's a .app.

00:10:17.490 --> 00:10:17.490
The extension is not shown.

00:10:17.490 --> 00:10:17.490
So when a user clicks on

00:10:17.860 --> 00:10:18.920
on this file.

00:10:19.290 --> 00:10:23.870
They expect preview to open
up and display their contents.

00:10:24.660 --> 00:10:26.620
- But it could actually
be a Trojan horse.

00:10:26.670 --> 00:10:31.380
And quarantine solves this
problem by displaying an alert.

00:10:32.140 --> 00:10:37.790
It shows the exact information for where
that file came from and at what time.

00:10:38.700 --> 00:10:42.100
Quarantine is easy to take advantage of.

00:10:42.100 --> 00:10:49.300
All you need to do is enable the setting
in your Info.plist and automatically

00:10:49.850 --> 00:10:51.980
you will get some attributes.

00:10:51.980 --> 00:10:55.940
Your application's name and the
bundle ID as well as the time.

00:10:57.470 --> 00:11:01.890
And then manually you
can set this information.

00:11:01.950 --> 00:11:07.280
The exact data URL that it came from
and the site that it originated from.

00:11:07.350 --> 00:11:09.810
As well as the type of file it is.

00:11:10.090 --> 00:11:12.160
Launch services will
take care of the rest.

00:11:12.160 --> 00:11:17.510
When an unsafe file type such as a
.app or shell script is downloaded,

00:11:17.920 --> 00:11:21.190
quarantine will block
these kinds of attacks.

00:11:22.780 --> 00:11:25.800
Next we have authorization prompts.

00:11:25.860 --> 00:11:28.350
And this might be a little
confusing to you at first because

00:11:28.730 --> 00:11:32.510
what is the difference between
an administrator user and an

00:11:32.510 --> 00:11:35.370
application running as an admin user?

00:11:37.750 --> 00:11:42.230
To the system,
we have a root user that has

00:11:42.230 --> 00:11:45.760
full control over the system.

00:11:45.820 --> 00:11:48.840
And in many places where a
core system change is made,

00:11:48.890 --> 00:11:55.070
such as editing a firewall rule or
installing new system-wide applications

00:11:55.070 --> 00:11:57.970
or services or a kernel driver.

00:11:58.420 --> 00:12:01.890
The operating system prompts
the user for administrator

00:12:01.900 --> 00:12:03.830
authorization with a password.

00:12:05.700 --> 00:12:08.760
And in Lion, we've improved these.

00:12:08.820 --> 00:12:12.310
We've eliminated many of them
where they were unnecessary.

00:12:12.900 --> 00:12:15.860
This is to prevent users from
getting too used to typing in

00:12:15.860 --> 00:12:17.800
their password unnecessarily.

00:12:17.800 --> 00:12:23.800
And we've also simplified them
and clarified their purpose.

00:12:24.010 --> 00:12:24.610
All right.

00:12:24.660 --> 00:12:28.790
So now let's shift gears and
talk about code vulnerabilities.

00:12:31.750 --> 00:12:37.890
So the URI handler and the feeds
actually represent a very wide attack

00:12:37.930 --> 00:12:41.560
surface and they can trigger many
components and many technologies

00:12:41.560 --> 00:12:47.080
where they can look for parsing errors
and all sorts of vulnerabilities.

00:12:47.910 --> 00:12:51.800
They can look for input
validation problems.

00:12:51.800 --> 00:12:55.920
Such as taking a file name
from the URI handler and taking

00:12:55.920 --> 00:13:00.400
that URI and passing it on
the command line and securely.

00:13:00.430 --> 00:13:05.160
An attacker might try to inject
shell meta characters to start

00:13:05.160 --> 00:13:07.850
executing arbitrary commands.

00:13:07.890 --> 00:13:07.890
This could be triggered from

00:13:09.180 --> 00:13:11.760
An arbitrary website.

00:13:11.760 --> 00:13:15.040
Or they might look for
memory mismanagement errors.

00:13:15.040 --> 00:13:17.490
For example,
one of the image decoders that can

00:13:17.490 --> 00:13:22.040
be triggered from HTML might have a
buffer overflow vulnerability in it.

00:13:22.080 --> 00:13:24.300
Also going to look for logic flaws.

00:13:24.450 --> 00:13:28.870
How does the RSS reader interact
with the operating system and

00:13:28.870 --> 00:13:31.300
with things like spotlight?

00:13:32.030 --> 00:13:36.280
And what oversights did the programmer
make or the development team make

00:13:36.290 --> 00:13:38.780
when building their application?

00:13:40.300 --> 00:13:43.560
So here's a simple vulnerability.

00:13:43.650 --> 00:13:45.550
This is a format string flaw.

00:13:45.660 --> 00:13:51.960
Suppose that the URI handler is
taking this information and passing it

00:13:51.960 --> 00:13:54.250
directly to the NS log API function.

00:13:54.790 --> 00:13:56.840
This is directly exploitable.

00:13:56.840 --> 00:14:01.830
An attacker can take advantage of this by
giving their own format string specifier.

00:14:04.630 --> 00:14:08.740
And luckily this problem is easy to fix.

00:14:08.760 --> 00:14:13.290
You just add your own format string
and don't allow untrusted input

00:14:13.290 --> 00:14:16.040
as the format string specifier.

00:14:16.050 --> 00:14:19.190
So an attacker could use the
format string vulnerability

00:14:19.230 --> 00:14:20.910
to disclose arbitrary memory.

00:14:21.890 --> 00:14:24.000
or gain direct code execution.

00:14:24.000 --> 00:14:29.730
But not all bugs are this easy
to fix or that easy to find.

00:14:30.330 --> 00:14:35.290
So what I'll be talking about today are
some asymmetric solutions to the problem.

00:14:35.390 --> 00:14:39.080
You don't have to match
your attackers step by step.

00:14:39.300 --> 00:14:41.450
You don't have to find every
vulnerability they might find.

00:14:41.500 --> 00:14:45.660
You can take advantage of the
code hardening mechanisms we have,

00:14:45.660 --> 00:14:48.610
the exploit mitigation
technology we have.

00:14:48.610 --> 00:14:51.340
That makes exploitation
much more difficult.

00:14:51.340 --> 00:14:57.880
You can take advantage of the sandboxing
features we have for damage control.

00:15:00.310 --> 00:15:03.270
Let's talk about the
Clang static analyzer.

00:15:03.310 --> 00:15:06.060
There are other sessions this week.

00:15:06.120 --> 00:15:10.240
What you see with Xcode 4
is even better integration.

00:15:10.300 --> 00:15:13.770
The Clang static analyzer will
automatically find many memory

00:15:13.770 --> 00:15:16.440
mismanagement errors for you.

00:15:16.610 --> 00:15:20.390
Thereby also eliminating a good
portion of security errors.

00:15:24.170 --> 00:15:28.220
Our compiler takes advantage of the
open source Fortify source patch.

00:15:28.310 --> 00:15:34.440
And Fortify source removes really low
hanging fruit that is too easy to find.

00:15:34.570 --> 00:15:40.670
Things like insecure
calls to string copy.

00:15:40.670 --> 00:15:40.670
That does not do bound checking.

00:15:41.600 --> 00:15:45.900
The way Fortify Source works
is that during compilation,

00:15:45.950 --> 00:15:49.110
I just replaced with
more secure alternatives.

00:15:49.450 --> 00:15:56.780
The compiler can do this automatically
where it's easy to do so.

00:15:58.070 --> 00:16:00.240
Next, we have stack protectors.

00:16:00.240 --> 00:16:04.570
And stack protectors are also
inserted by the compiler through

00:16:04.730 --> 00:16:06.410
a transformation pass in LLVM.

00:16:06.430 --> 00:16:11.200
And the stack protectors make
exploiting buffer overflows more

00:16:11.270 --> 00:16:15.850
difficult by inserting a secret
value on the stack that protects the

00:16:15.900 --> 00:16:20.740
return address and the save frame
pointer from being overwritten.

00:16:24.160 --> 00:16:28.390
Next, we have a number of new exploit
mitigation technologies.

00:16:31.060 --> 00:16:35.250
So sometimes code injection
can be really easy.

00:16:35.440 --> 00:16:38.680
All an attacker has to do is
figure out a way to get their data

00:16:38.680 --> 00:16:41.300
somewhere in executable memory.

00:16:44.190 --> 00:16:47.030
For a long time we've had
a non-executable stack,

00:16:47.030 --> 00:16:53.260
but on 32-bit processes in Snow Leopard,
we've had an executable heap

00:16:53.640 --> 00:16:56.450
and an executable data section.

00:16:56.960 --> 00:17:01.380
This made it easy for an attacker
to exploit 32-bit applications.

00:17:01.380 --> 00:17:09.560
Whereas on 64-bit applications on Mac OS,
these were non-executable.

00:17:09.560 --> 00:17:09.570
So an attacker could not
easily inject code here.

00:17:10.580 --> 00:17:14.180
As well on iOS, the code signing policy.

00:17:14.180 --> 00:17:17.260
Make sure that that is not executable.

00:17:17.320 --> 00:17:20.290
So it's also more
difficult for an attacker.

00:17:20.810 --> 00:17:23.670
And in Lion, we've made this better.

00:17:23.900 --> 00:17:27.700
Now data in the heap are
no longer executable.

00:17:27.790 --> 00:17:30.610
So an attacker cannot inject code easily.

00:17:31.170 --> 00:17:36.380
Not every security solution is
perfect and this can still be bypassed

00:17:36.390 --> 00:17:39.290
with return oriented programming.

00:17:40.010 --> 00:17:43.720
Return oriented programming is all
about reusing existing code that's

00:17:43.750 --> 00:17:49.340
already in the address space of the
program for performing arbitrary actions.

00:17:49.340 --> 00:17:52.930
And return oriented programming
specifically refers to reusing

00:17:53.050 --> 00:17:56.620
the epilogues of functions to
perform arbitrary computations.

00:17:56.680 --> 00:18:03.140
But you could also just reuse existing
libraries and existing API calls.

00:18:03.570 --> 00:18:07.800
Here you have an example of one of
the first iPhone exploits that took

00:18:07.800 --> 00:18:11.720
advantage of vulnerability in TIFF that
was discovered by Tyvus Ormandy.

00:18:14.260 --> 00:18:17.280
And although you had
no way to inject code,

00:18:17.320 --> 00:18:21.520
you could just build up stack
frames that reuse the existing

00:18:21.520 --> 00:18:24.690
API calls to perform actions.

00:18:26.000 --> 00:18:30.770
One way to mitigate this is
address based layout randomization.

00:18:30.800 --> 00:18:34.620
What you will see across our
platforms is that we have address

00:18:34.620 --> 00:18:36.600
based layout randomization.

00:18:36.620 --> 00:18:38.760
This was introduced in iOS 4.3.

00:18:38.760 --> 00:18:40.140
It is in line.

00:18:40.140 --> 00:18:44.330
This makes remote exploitation
more difficult for an attacker.

00:18:44.330 --> 00:18:49.750
They don't know where
the data structures are.

00:18:50.030 --> 00:18:51.430
They don't know where their input is.

00:18:51.460 --> 00:18:54.760
They don't know which functions to call.

00:18:55.900 --> 00:18:59.170
without an information leak.

00:19:02.060 --> 00:19:08.760
So to get these features on,
all you have to do is build online.

00:19:08.870 --> 00:19:11.030
It's not an SDK setting.

00:19:11.130 --> 00:19:14.800
It doesn't matter which
APIs you're building for.

00:19:14.860 --> 00:19:18.440
Just the toolkits that are online,
I mean the tool chain,

00:19:18.440 --> 00:19:20.130
will take care of this.

00:19:20.140 --> 00:19:26.310
The linker adds headers to the
Mac OS header in the binary.

00:19:26.540 --> 00:19:28.160
That sets these settings.

00:19:28.220 --> 00:19:31.030
So now when you build online,
32-bit applications by default will

00:19:31.030 --> 00:19:34.040
be built as position-independent
executables so they can get

00:19:34.110 --> 00:19:35.840
address-based layout randomization.

00:19:35.840 --> 00:19:38.220
It's also true for non-executable data.

00:19:38.220 --> 00:19:42.520
You also get some additional heap
hardening and the stack protectors.

00:19:44.750 --> 00:19:48.360
And if you want, you can enable stack
protectors for all functions,

00:19:48.370 --> 00:19:51.700
not just character buffers,
functions with character buffers,

00:19:51.900 --> 00:19:55.450
by passing the fstackprotector all flag.

00:19:57.980 --> 00:20:00.840
So if you want to check to see if you're
not sure if you're getting this feature,

00:20:00.840 --> 00:20:02.920
you can do so using O tool.

00:20:02.920 --> 00:20:05.820
And you can check the macro
header using this and you

00:20:05.820 --> 00:20:07.590
want to look for the pie flag.

00:20:07.650 --> 00:20:08.620
And that's it.

00:20:08.620 --> 00:20:11.640
You have address-based
layout randomization.

00:20:15.180 --> 00:20:17.210
So let's talk about sandboxing.

00:20:17.240 --> 00:20:21.750
So sandboxing is a very powerful
construct for damage control.

00:20:22.100 --> 00:20:25.950
So if an attacker is able to
find an exploit and get code

00:20:25.960 --> 00:20:29.780
running in an application,
you can provide damage control so

00:20:29.780 --> 00:20:34.990
that they can't break out into other
applications or get users' data.

00:20:35.560 --> 00:20:39.490
And you see this on iOS,
where a compromise on an application

00:20:39.490 --> 00:20:44.390
doesn't necessarily compromise all the
user's data and other applications.

00:20:44.800 --> 00:20:48.020
And you saw this on
Leopard with Seatbelt.

00:20:48.070 --> 00:20:51.290
And we have a number of
built-in profiles there.

00:20:51.710 --> 00:20:55.560
So you could put your application
in a sandbox and remove its

00:20:55.920 --> 00:20:57.820
ability to access the Internet.

00:20:57.820 --> 00:21:00.390
So you could run code
from arbitrary places,

00:21:00.390 --> 00:21:03.040
not worry about its
ability to connect out.

00:21:03.040 --> 00:21:05.840
Or you could use the
pure computation sandbox,

00:21:05.840 --> 00:21:07.360
which is really tight.

00:21:07.360 --> 00:21:10.550
So an application in the sandbox
can't touch the user's files,

00:21:10.620 --> 00:21:14.950
can't talk to the network,
can't talk to IOCAD or other resources.

00:21:16.580 --> 00:21:19.260
But we made this even better.

00:21:19.300 --> 00:21:23.470
And in Lion,
we're introducing the App Sandbox.

00:21:24.040 --> 00:21:26.760
The app's sandbox is
designed for security,

00:21:26.760 --> 00:21:29.590
but it's also easy to take advantage of.

00:21:29.700 --> 00:21:35.350
It's also been designed to really work
with users to give them a clear idea of

00:21:35.580 --> 00:21:40.730
how their data is flowing through the
system and going in between applications.

00:21:41.180 --> 00:21:46.280
So that they can feel safer
when using your applications.

00:21:47.470 --> 00:21:50.720
In addition,
we provide fine-grained access

00:21:50.770 --> 00:21:54.480
control with entitlements that
allow you to specify exactly what

00:21:54.480 --> 00:21:57.890
resources your application should have.

00:22:01.290 --> 00:22:03.800
There are two sessions
today in this room.

00:22:04.050 --> 00:22:08.200
This is a two-part session
actually and it's at 2:00 p.m.

00:22:08.200 --> 00:22:12.390
The first part will be the
introduction to the app sandbox.

00:22:12.680 --> 00:22:17.710
The second part will be about the
app sandbox and the Mac App Store.

00:22:17.970 --> 00:22:23.150
You can learn about the new
requirements for your applications.

00:22:23.310 --> 00:22:26.790
So let me tell you a little
bit more about sandboxing.

00:22:28.280 --> 00:22:34.600
The concept is that if an attack comes
in and compromises your application,

00:22:34.600 --> 00:22:38.520
not all of the resources that that
application could have access to

00:22:38.540 --> 00:22:41.570
previously are immediately compromised.

00:22:42.010 --> 00:22:46.060
You can isolate your application from
the system to prevent the compromise

00:22:46.180 --> 00:22:50.340
of all these other components,
the user's files, network access,

00:22:50.770 --> 00:22:53.290
communication with drivers.

00:22:54.650 --> 00:22:57.300
You can even take this a step further.

00:22:57.350 --> 00:23:01.890
You can build your application in such
a way that has privilege separation and

00:23:01.890 --> 00:23:05.650
the more security critical components,
the ones that deal with

00:23:05.740 --> 00:23:09.950
users' data and users' files,
are isolated from the more vulnerable

00:23:09.950 --> 00:23:14.330
components that have to do a lot of
file parsing and a lot of data parsing

00:23:14.330 --> 00:23:17.280
and work with a lot of untrusted input.

00:23:17.300 --> 00:23:20.640
And you can even isolate these
from the network components.

00:23:23.010 --> 00:23:29.500
So the app sandbox provides great
damage control by limiting the effect

00:23:29.500 --> 00:23:32.560
of an attack on the user system.

00:23:34.340 --> 00:23:38.150
We also have entitlements.

00:23:38.250 --> 00:23:43.030
And entitlements,
if you're familiar with them from iOS,

00:23:43.920 --> 00:23:45.950
Are things that you add
to your application.

00:23:47.280 --> 00:23:49.110
Online?

00:23:49.320 --> 00:23:51.100
There's a new spin on them.

00:23:51.120 --> 00:23:54.190
So all these capabilities that
your application should have are

00:23:54.190 --> 00:23:58.800
off by default and default deny
is a great concept in security.

00:23:58.890 --> 00:24:01.710
You want to give your application
the minimal set of privileges

00:24:01.710 --> 00:24:03.310
that it needs to get its job done.

00:24:03.310 --> 00:24:07.350
So if there's a compromise,
all the potential resources that it

00:24:07.350 --> 00:24:10.180
could compromise are not also accessible.

00:24:14.760 --> 00:24:18.100
So you opt in and you pick the
capabilities that you want.

00:24:18.110 --> 00:24:20.710
And here are just some examples of

00:24:21.250 --> 00:24:23.820
The types of entitlements
that are out there.

00:24:23.950 --> 00:24:27.170
Things like making a
connection to another machine

00:24:27.800 --> 00:24:32.330
Writing to users download folder
where they might store a lot of

00:24:32.390 --> 00:24:34.090
their new files and new data.

00:24:35.780 --> 00:24:37.940
Things like a user-initiated read.

00:24:37.980 --> 00:24:41.620
So when a user decides to
give your application a file,

00:24:41.640 --> 00:24:43.520
they can just use the file dialogs.

00:24:43.520 --> 00:24:46.920
You don't necessarily have to
give your application full access

00:24:47.330 --> 00:24:49.680
to all of the user's files.

00:24:49.720 --> 00:24:54.640
Just the files that they want to
give your application at that time.

00:24:55.310 --> 00:25:00.510
Things like accessing the
camera or accessing printers.

00:25:04.650 --> 00:25:08.860
All right, now let's shift gears and talk
about the financial application,

00:25:08.900 --> 00:25:12.790
which has a very
different set of problems.

00:25:14.510 --> 00:25:17.780
Financial application has
credentials for a bank account

00:25:17.780 --> 00:25:20.640
somewhere or some sort of server.

00:25:20.640 --> 00:25:24.780
And also deals with very
sensitive information that needs

00:25:24.780 --> 00:25:27.000
to transfer and store securely.

00:25:28.900 --> 00:25:31.180
So let's talk about some
storage vulnerabilities.

00:25:31.200 --> 00:25:33.950
Again, things like physical theft.

00:25:34.360 --> 00:25:38.450
If a device is misplaced, lost,
or stolen, that user might be anxious

00:25:38.890 --> 00:25:42.610
about what happened to all that
stuff that they had on there.

00:25:45.330 --> 00:25:50.510
On the desktop,
things like file permissions.

00:25:51.680 --> 00:25:56.480
Is the user's data being protected
from other users on the system

00:25:56.480 --> 00:26:01.830
if it's a shared portable,
for example?

00:26:05.200 --> 00:26:08.660
Back to the financial application.

00:26:08.660 --> 00:26:12.460
The attacker is going to be
interested in things like user

00:26:12.460 --> 00:26:15.100
names and passwords to that bank
account or those bank statements.

00:26:15.100 --> 00:26:17.420
Any information they can
get about the person.

00:26:17.530 --> 00:26:22.630
The attacker is not going to go around
hunting for users of your application.

00:26:22.630 --> 00:26:22.630
But

00:26:23.250 --> 00:26:28.320
They're going to be looking for this
kind of information on a device they get.

00:26:28.470 --> 00:26:30.300
So what do we have?

00:26:32.780 --> 00:26:37.540
So we have strong Unix file permissions.

00:26:37.610 --> 00:26:39.500
I'll talk about that a little bit later.

00:26:39.500 --> 00:26:45.620
And we have technologies like Keychain,
FileVault, and Data Protection.

00:26:47.260 --> 00:26:52.940
Keychain solves a lot of problems
with password management.

00:26:53.030 --> 00:26:56.270
How should passwords be
migrated across an install?

00:26:56.380 --> 00:26:59.580
On the desktop, Keychain can protect
a user's login items,

00:26:59.580 --> 00:27:03.660
their user names, their emails,
their passwords with one password.

00:27:03.800 --> 00:27:08.320
It makes it easier for a user to manage
all of their different credentials.

00:27:08.320 --> 00:27:12.310
Keychain is also available on iOS.

00:27:13.670 --> 00:27:20.100
In Panther, we introduced FileVault which
allowed users to encrypt their

00:27:20.100 --> 00:27:21.340
data in an encrypted volume.

00:27:21.610 --> 00:27:24.500
This only applied to
their home directory.

00:27:24.500 --> 00:27:27.030
So in Lion,
we have the all new file vault

00:27:27.530 --> 00:27:30.060
which provides full disk encryption.

00:27:30.060 --> 00:27:33.010
So the full volume is encrypted.

00:27:33.150 --> 00:27:38.840
So other things like system messages
and global configuration settings or

00:27:39.010 --> 00:27:43.530
the applications they have installed
can now also be secured by a user's

00:27:44.250 --> 00:27:46.980
password in case their portable is lost.

00:27:49.900 --> 00:27:53.540
On iOS we have data protection.

00:27:53.540 --> 00:28:01.660
So data protection mitigates other
vulnerabilities on the passcode lock.

00:28:01.690 --> 00:28:04.680
So if a device is stolen and
the user has a passcode set,

00:28:04.680 --> 00:28:06.350
that protects their data.

00:28:06.350 --> 00:28:10.350
But in case there's a vulnerability
that can compromise that,

00:28:10.420 --> 00:28:15.020
data protection takes everything a
step further and protects the files on

00:28:15.050 --> 00:28:19.820
that device using the user's passcode
and the lock state of that device.

00:28:19.900 --> 00:28:23.560
And there are a few
different protection classes.

00:28:23.560 --> 00:28:26.660
And data protection was
introduced in iOS 4.

00:28:26.660 --> 00:28:33.540
We made some improvements there.

00:28:33.540 --> 00:28:33.540
So by default, there's nothing.

00:28:33.540 --> 00:28:33.540
And you should avoid this.

00:28:34.710 --> 00:28:39.820
In the first protection class
is NS file protection complete.

00:28:39.820 --> 00:28:43.690
And you want to always use this when
you're dealing with personal information.

00:28:43.740 --> 00:28:48.450
The way it works is that whenever
a device is passcode locked,

00:28:48.660 --> 00:28:52.490
data in this protection
class is not accessible.

00:28:53.430 --> 00:28:57.180
as well as keychain entries that
are in this data protection class.

00:28:57.210 --> 00:29:00.820
They're only accessible when the
user enters their passcode and

00:29:00.820 --> 00:29:03.310
they're actively using their device.

00:29:04.840 --> 00:29:08.090
This alludes to some new stuff.

00:29:08.150 --> 00:29:10.110
We'll get to it in a second.

00:29:10.350 --> 00:29:13.020
And then we have this data protection
class that was available for

00:29:13.020 --> 00:29:15.830
the keychain after first unlock.

00:29:16.570 --> 00:29:20.200
Many of the vulnerabilities that
are out there for a passcode bypass

00:29:20.500 --> 00:29:25.480
rely on rebooting the device.

00:29:25.480 --> 00:29:25.480
So this protection class,

00:29:26.670 --> 00:29:31.060
Is a solution for applications that might
need to function even out of passcode

00:29:31.600 --> 00:29:36.580
lock but still need data protection.

00:29:37.800 --> 00:29:40.600
After the first time a
user enters their passcode,

00:29:40.610 --> 00:29:44.740
data in this protection
class will be available.

00:29:44.750 --> 00:29:46.690
But not until then.

00:29:47.930 --> 00:29:50.860
Here are some use cases
for data protection.

00:29:50.860 --> 00:29:53.010
You should be using this
anywhere where a user might

00:29:53.170 --> 00:29:54.770
put their personal information.

00:29:54.900 --> 00:29:56.690
Anywhere where you might
have a scratch pad,

00:29:56.690 --> 00:29:58.530
where a user might decide
to store a password,

00:29:58.530 --> 00:29:59.500
even temporarily.

00:29:59.500 --> 00:30:01.560
It should be in this protection class.

00:30:01.560 --> 00:30:06.190
To prevent any information leaks,
as well as information from

00:30:06.190 --> 00:30:08.630
social networking websites.

00:30:09.510 --> 00:30:17.640
In addition, you should be taking
advantage of key chain.

00:30:17.640 --> 00:30:19.860
Anywhere where you're
working with credentials,

00:30:20.150 --> 00:30:23.540
user names and passwords
and e-mail addresses.

00:30:23.540 --> 00:30:27.510
You should be putting them in the
tightest protection class you can.

00:30:33.820 --> 00:30:37.180
We have two new protection
classes available in iOS 5.

00:30:37.180 --> 00:30:43.230
These are meant to solve
some of the trickier points

00:30:43.440 --> 00:30:45.320
with background applications.

00:30:45.320 --> 00:30:49.280
The first of these is
complete unless open.

00:30:50.200 --> 00:30:55.100
The way it works is you put your
file in this protection class

00:30:55.140 --> 00:30:59.480
and you will be able to access it
until you close the file handle.

00:30:59.580 --> 00:31:03.610
This is useful if you need to
complete a large transaction

00:31:03.610 --> 00:31:06.030
such as a large mail download.

00:31:07.300 --> 00:31:11.700
And when you close the file handle,
this will get moved into the

00:31:11.750 --> 00:31:14.080
NSProtectionComplete class.

00:31:14.850 --> 00:31:20.800
The next one we have is after
first unlock as well for files.

00:31:20.800 --> 00:31:27.750
And this is useful for streaming
services and notifications.

00:31:30.120 --> 00:31:32.000
These are really the use cases.

00:31:32.000 --> 00:31:36.120
They're intended for
background applications.

00:31:36.120 --> 00:31:40.110
And for the most part,
you should be using protection complete.

00:31:43.950 --> 00:31:46.270
Next, let's talk about file permissions.

00:31:46.270 --> 00:31:53.240
So, temporary directories are especially
tricky on a multiuser system.

00:31:53.440 --> 00:31:57.770
You have to be very careful and watch
out for things like race conditions.

00:31:57.980 --> 00:32:04.270
Opening a file, doing a stat,
or doing a stat and then

00:32:04.380 --> 00:32:08.110
opening a file is not secure.

00:32:08.110 --> 00:32:08.110
In between that stat and that open,
an attacker could have

00:32:08.110 --> 00:32:08.110
switched something out.

00:32:09.280 --> 00:32:13.530
In addition, you have to be very careful
with file permissions.

00:32:13.660 --> 00:32:17.200
When you leave global
configuration settings on a system,

00:32:17.290 --> 00:32:21.990
you want to make sure that
they're not world writable and

00:32:21.990 --> 00:32:21.990
that they're in the appropriate

00:32:23.200 --> 00:32:30.100
[Transcript missing]

00:32:30.580 --> 00:32:33.130
So another thing that you'll
notice in Lion is that we've

00:32:33.210 --> 00:32:35.870
tied in file system permissions.

00:32:36.080 --> 00:32:41.420
So /, /applications/utilities,
and /library are no longer

00:32:41.420 --> 00:32:44.380
writable by the group admin.

00:32:45.230 --> 00:32:51.820
This was done to tighten some potential
vulnerabilities that were being created

00:32:52.070 --> 00:32:56.190
by some third party installers where
global configuration settings or

00:32:56.190 --> 00:33:01.900
system daemons were being installed
into these places and then running

00:33:01.900 --> 00:33:04.650
with full root system privileges.

00:33:05.660 --> 00:33:09.240
And this created the potential
for privilege escalation from

00:33:09.240 --> 00:33:12.160
the admin group ID to root.

00:33:12.160 --> 00:33:15.510
And there are some exceptions.

00:33:16.350 --> 00:33:23.080
Any role directories that are already
there remain the same as well as caches.

00:33:26.030 --> 00:33:31.460
So let's talk about the other side
of this financial application.

00:33:32.120 --> 00:33:33.040
Transport.

00:33:33.040 --> 00:33:36.960
It needs to securely transmit
information to a server and

00:33:36.960 --> 00:33:39.580
securely retrieve information.

00:33:41.390 --> 00:33:44.300
Here are some of the goals
of transport security.

00:33:44.520 --> 00:33:49.300
You want to make sure that that data
cannot be observed by a passive attacker.

00:33:49.590 --> 00:33:54.800
You don't want to send plain text
credentials as well as any personal

00:33:54.840 --> 00:33:57.290
information playing over the wire.

00:33:58.510 --> 00:34:01.790
You also want to make sure
that your protocol is resistant

00:34:02.020 --> 00:34:06.530
against more active attacks,
such as man-in-the-middle attacks,

00:34:06.530 --> 00:34:10.540
where somebody might be impersonating
the server that your client thinks

00:34:10.540 --> 00:34:12.220
is talking to or vice versa.

00:34:13.710 --> 00:34:16.560
and protocols have all
kinds of nuances on them.

00:34:16.570 --> 00:34:19.450
Additional things such as replay attacks.

00:34:23.540 --> 00:34:27.160
Many of these problems are
solved for you by many of the

00:34:27.160 --> 00:34:29.380
APIs available in security framework.

00:34:29.380 --> 00:34:32.200
And on Mac OS X secure transport.

00:34:33.700 --> 00:34:42.430
These are integrated in
the core system APIs.

00:34:42.430 --> 00:34:42.430
So CF Network supports
HTTPS as well as NSURL open.

00:34:46.930 --> 00:34:55.070
In Mac OS X and Lion we have some
great innovations here with transforms.

00:34:55.160 --> 00:34:59.850
So transforms are a new way of
doing data flow programming.

00:35:00.890 --> 00:35:08.540
And these were created as a result of
improvements to our crypto APIs on Lion.

00:35:10.060 --> 00:35:14.950
There's been a convergence between iOS
and Mac OS X and some of the common

00:35:14.950 --> 00:35:17.040
crypto subsystems are now available.

00:35:17.040 --> 00:35:22.920
And the APIs to access them
take advantage of transforms.

00:35:24.100 --> 00:35:38.050
And it makes it easier, faster,
and with less code to do

00:35:38.050 --> 00:35:38.050
secure cryptography and
secure transport correctly.

00:35:38.050 --> 00:35:38.050
In addition,
some data structures have been affected.

00:35:41.840 --> 00:35:45.350
In iOS 5,
we've introduced secure transport,

00:35:45.350 --> 00:35:48.770
which was previously only
available on Mac OS X.

00:35:49.210 --> 00:35:54.410
So before it was difficult
to do secure transport with

00:35:54.640 --> 00:35:59.280
transports layer security with TLS over
an arbitrary protocol that wasn't HTTP.

00:36:00.400 --> 00:36:06.300
So you had to rely on things like
CF network and NSUR open to use HTTPS.

00:36:06.440 --> 00:36:09.120
But in some ways that was limited.

00:36:10.540 --> 00:36:14.430
Now you can take advantage of
secure transport on iOS 5 and

00:36:14.560 --> 00:36:24.220
it has full support for TLS 1.1,
TLS 1.2, and DTLS for diagrams, for UDP.

00:36:27.320 --> 00:36:31.740
So for user interface security,
make sure you take advantage

00:36:31.760 --> 00:36:35.080
of quarantine on the desktop.

00:36:35.080 --> 00:36:38.110
Because user interface attacks
are in some ways the easiest

00:36:38.110 --> 00:36:40.980
and lowest bar for an attacker,
but they're also some of the

00:36:40.980 --> 00:36:42.300
most complex problems to solve.

00:36:42.380 --> 00:36:45.750
But you can make it difficult
for an attacker to take advantage

00:36:45.750 --> 00:36:47.800
of these things with quarantine.

00:36:49.040 --> 00:36:53.780
We have a number of code hardening
mechanisms as well as exploit mitigation

00:36:53.870 --> 00:36:59.680
technologies built in now into Lion and
iOS that you can take advantage of.

00:37:02.300 --> 00:37:03.500
Sandbox.

00:37:03.500 --> 00:37:09.020
The app provides excellent solutions
to some of the hardest computer

00:37:09.020 --> 00:37:11.660
security problems we solve.

00:37:11.660 --> 00:37:16.670
Of giving a user full control over how
their data interacts with different

00:37:16.670 --> 00:37:19.060
applications on their system.

00:37:19.440 --> 00:37:26.180
and providing an easy way to
build security under the hood.

00:37:28.660 --> 00:37:34.680
In addition, we have good technology that
solves some very difficult storage

00:37:34.680 --> 00:37:39.820
problems such as what happens to
information in the case of data loss,

00:37:40.060 --> 00:37:43.470
physical theft,
as well as API such as keychain.

00:37:43.480 --> 00:37:45.520
And users can take
advantage of file vault.

00:37:45.590 --> 00:37:49.170
So they don't have to worry
about their information on their

00:37:49.170 --> 00:37:51.570
portable if they lose their laptop.

00:37:51.770 --> 00:37:57.770
We have data protection for
protecting files on portable devices.

00:37:59.770 --> 00:38:02.090
And for transport security,
we have some great new

00:38:02.090 --> 00:38:06.730
APIs available online,
as well as iOS 5 now.

00:38:06.970 --> 00:38:11.130
So you can do secure communication
without compromising users' information.

00:38:13.950 --> 00:38:18.700
Here are some references that
you can check out the website.

00:38:18.720 --> 00:38:23.490
You have a secure coding
overview and introduction.

00:38:23.710 --> 00:38:29.420
Secure coding practices as well as
references for working with quarantine.

00:38:31.110 --> 00:38:33.720
And here are the sessions that
you should really see for some

00:38:33.720 --> 00:38:39.400
of the in-depth topics on the
things I've mentioned today.

00:38:39.420 --> 00:38:44.390
The app sandbox sessions will tell you
in great detail how the sandbox works

00:38:44.420 --> 00:38:45.910
and how you can take advantage of it.

00:38:45.980 --> 00:38:48.320
Thank you.
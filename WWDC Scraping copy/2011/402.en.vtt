WEBVTT

00:00:10.210 --> 00:00:11.390
Good morning.

00:00:11.470 --> 00:00:12.500
I'm Nate Begemann.

00:00:12.740 --> 00:00:17.160
I'm here to talk to you today
about iOS game technologies

00:00:17.780 --> 00:00:21.840
and some of the fantastic new
things we have for you in iOS 5.

00:00:21.860 --> 00:00:26.040
It is a fantastic time to make games,
and I'm thrilled to see so many

00:00:26.130 --> 00:00:28.280
people here in the room today.

00:00:28.280 --> 00:00:35.180
We have seen you guys have such
success already writing games for iOS,

00:00:35.180 --> 00:00:39.120
and we have some wonderful new
things to share with you here today.

00:00:40.090 --> 00:00:43.590
And we're excited to see you guys adopt
the things that we'll be unveiling

00:00:43.590 --> 00:00:46.390
and write even awesomer games.

00:00:46.420 --> 00:00:50.480
Today in Part 1,
we'll be talking about four technologies.

00:00:52.350 --> 00:00:55.000
First is Game Center.

00:00:55.020 --> 00:01:00.670
Game Center lets your games connect
with your customers and helps them

00:01:01.030 --> 00:01:06.140
play with their friends and make
gaming an awesome social experience.

00:01:06.160 --> 00:01:09.550
The second thing we're going to
talk today about is the cloud

00:01:10.000 --> 00:01:15.100
and how cloud storage is like the
most amazing thing for games ever.

00:01:15.150 --> 00:01:18.190
And I'm super excited to show
some examples of how we're

00:01:18.190 --> 00:01:19.800
going to use that today.

00:01:19.860 --> 00:01:24.370
The third thing we're going to talk about
is GL Kit and how we're bringing the

00:01:24.380 --> 00:01:31.200
power of OpenGL ES 2.0 to your games,
even if you're not an OpenGL ES expert.

00:01:31.240 --> 00:01:33.200
And God knows I'm not.

00:01:33.310 --> 00:01:37.600
And the last thing we're going to
talk today about is AirPlay and

00:01:37.650 --> 00:01:42.790
how we can get your game on more
displays and in front of more people.

00:01:43.900 --> 00:01:48.760
In part two, the session after this,
we're going to talk about game design,

00:01:48.760 --> 00:01:52.310
and some of the things you
need to think about up front

00:01:52.310 --> 00:01:54.800
going into writing your game.

00:01:54.800 --> 00:01:58.340
We believe that everyone has a
great idea for a game in their head,

00:01:58.440 --> 00:02:01.530
so even those of you who don't
have a game on the store yet,

00:02:01.690 --> 00:02:05.180
you'll definitely want
to stick around for that.

00:02:05.180 --> 00:02:08.650
And you'll learn about great
audio design in your games,

00:02:08.870 --> 00:02:13.490
how to handle game design for iOS
devices in such a way that the input

00:02:13.490 --> 00:02:18.620
is natural and easy for people to use,
the things you need to think about

00:02:18.620 --> 00:02:21.260
writing a quality game for iOS,
and all the little

00:02:21.260 --> 00:02:24.700
details that go into that,
and lots of other cool things that

00:02:24.700 --> 00:02:26.700
Graham will share with you then.

00:02:28.450 --> 00:02:31.180
So let's talk about Game Center.

00:02:31.240 --> 00:02:33.980
As I mentioned,
Game Center is like the hub of the

00:02:34.090 --> 00:02:36.650
social experience for games on iOS.

00:02:36.940 --> 00:02:40.320
And in iOS 5,
we have a few cool new features that

00:02:40.320 --> 00:02:41.820
we've added directly to Game Center.

00:02:42.460 --> 00:02:44.350
The first is profile photos.

00:02:44.350 --> 00:02:48.890
And profile photos is actually, you know,
it doesn't sound super exciting,

00:02:48.890 --> 00:02:52.030
but it's really cool because when
you get that list of your friends

00:02:52.030 --> 00:02:55.310
up there and you see their photo,
you immediately connect

00:02:55.310 --> 00:02:59.780
with that person and say,
like, whoa, that's my friend Matt.

00:02:59.920 --> 00:03:00.680
He's right there.

00:03:00.680 --> 00:03:02.220
I'm going to play a game with him.

00:03:02.640 --> 00:03:05.210
Rather than dealing
with everything through,

00:03:05.210 --> 00:03:07.850
like, gamer tags or that kind of thing.

00:03:08.180 --> 00:03:10.990
As you saw yesterday,
we've built game recommendations

00:03:11.360 --> 00:03:13.570
right into Game Center.

00:03:13.800 --> 00:03:19.030
So now more people can find the awesome
games that you've written right in

00:03:19.070 --> 00:03:22.940
Game Center after they've played
whatever game they're playing now.

00:03:22.980 --> 00:03:26.670
And we think that this is a great way
to keep people coming back to games in

00:03:26.750 --> 00:03:31.300
Game Center and help them keep finding
new great games that you're writing.

00:03:31.360 --> 00:03:34.640
And the final thing we've added
is friend recommendations.

00:03:34.720 --> 00:03:38.040
You may not know that your
friends are on Game Center.

00:03:38.210 --> 00:03:40.420
There's 50 million people, as you heard.

00:03:40.480 --> 00:03:45.660
And so we'll help you find players
to match up with your customers.

00:03:46.230 --> 00:03:49.690
So that they can keep having
great experiences in your games.

00:03:49.920 --> 00:03:54.440
I know one of my favorite things
about gaming is that it's competitive.

00:03:54.540 --> 00:03:58.160
And so I spend a lot of time
looking at leaderboards in

00:03:58.160 --> 00:04:01.480
Game Center and trying to,
you know, beat my friend's time in

00:04:01.480 --> 00:04:03.440
Tiny Wings and that kind of thing.

00:04:03.500 --> 00:04:07.120
And so we've added some great
things to keep people interested

00:04:07.310 --> 00:04:09.240
in leaderboards in iOS 5.

00:04:09.300 --> 00:04:11.860
You can see the people in leaderboards.

00:04:12.010 --> 00:04:14.890
You can add them as a friend directly.

00:04:15.200 --> 00:04:16.530
You can rate games.

00:04:16.610 --> 00:04:20.100
I know one of the things that
you guys are super interested in

00:04:20.100 --> 00:04:23.660
is getting that awesome feedback
for your games that you so,

00:04:23.760 --> 00:04:25.550
you know, excellently deserve.

00:04:25.850 --> 00:04:28.500
And so now users can rate your
game right in Game Center.

00:04:28.500 --> 00:04:31.400
You don't need to pop up alerts saying,
please rate my game.

00:04:31.400 --> 00:04:34.820
And so, you know, that's there.

00:04:34.820 --> 00:04:37.540
And finally,
we've added custom category icons

00:04:37.540 --> 00:04:39.600
to the leaderboards themselves.

00:04:39.670 --> 00:04:43.960
And this is a way to let you just
sort of distinguish the categories

00:04:44.260 --> 00:04:48.440
for your app rather than use the
defaults that every app uses.

00:04:49.200 --> 00:07:23.700
[Transcript missing]

00:07:24.070 --> 00:07:26.760
So we're really excited to
see what you guys are going

00:07:26.760 --> 00:07:28.750
to do with turn-based gaming.

00:07:28.820 --> 00:07:32.930
But just to sort of refresh your memory,
we're going to walk through word for word

00:07:32.930 --> 00:07:35.700
and show you how turn-based gaming works.

00:07:37.530 --> 00:07:43.920
So here you can see we've got our iPad
up and we've got the Match interface.

00:07:44.470 --> 00:07:47.080
And, you know,
this is sort of the standard

00:07:47.080 --> 00:07:49.450
Game Center interface you can see.

00:07:49.930 --> 00:07:53.600
Here you can see right at the top,
your game gets to specify

00:07:53.600 --> 00:07:56.320
how many players you want
to support for the match.

00:07:56.380 --> 00:07:59.200
Word for word supports
two to four players.

00:07:59.310 --> 00:08:02.930
In the seed build you got,
you support up to four players,

00:08:03.130 --> 00:08:06.150
but in the final iOS 5,
we'll support up to 16

00:08:06.150 --> 00:08:08.080
players in turn-based gaming.

00:08:08.200 --> 00:08:10.390
So you can really go nuts with this.

00:08:10.520 --> 00:08:13.620
And so down here,
you can see we can either auto-match a

00:08:13.620 --> 00:08:16.100
player or you can invite some friends.

00:08:16.270 --> 00:08:18.590
So let's click that button.

00:08:19.360 --> 00:08:21.830
And here you can see, you know,
we've got a list of our friends

00:08:21.940 --> 00:08:23.290
with their profile photos.

00:08:23.350 --> 00:08:25.200
You can see, like, awesome.

00:08:25.200 --> 00:08:28.360
I want to invite those people
because they look great.

00:08:28.380 --> 00:08:32.430
And so we'll click two of
them and add them to our game.

00:08:32.540 --> 00:08:34.690
And then we'll hit the next button.

00:08:34.720 --> 00:08:37.990
And so here you can see they've
popped right up in our little

00:08:37.990 --> 00:08:40.040
match that we're about to start.

00:08:40.080 --> 00:08:44.740
And if someone wanted to,
they could rate your game right here.

00:08:44.890 --> 00:08:47.960
So we'll go ahead and get started.

00:08:48.040 --> 00:08:51.810
So as you saw yesterday, you know,
you've got your familiar game

00:08:51.810 --> 00:08:55.360
paradigm of letter tiles on a board.

00:08:55.410 --> 00:08:59.760
And we're going to place them down and,
you know, score some points.

00:08:59.850 --> 00:09:03.030
This is where the tiles came from.

00:09:03.830 --> 00:09:04.620
There's the word.

00:09:04.670 --> 00:09:07.360
And we're going to hit
our next button here.

00:09:07.390 --> 00:09:10.650
And we spelled Ruby for
a bunch of points,

00:09:10.650 --> 00:09:11.550
which is awesome.

00:09:13.960 --> 00:09:16.670
And so then, when I hit that next button,
it's going to send a

00:09:16.670 --> 00:09:19.670
notification to someone else,
and it's going to appear at the

00:09:19.850 --> 00:09:23.190
top of the screen with the new
notification user interface,

00:09:23.190 --> 00:09:26.200
and of course, they're going to accept.

00:09:26.270 --> 00:09:28.550
And so then it's going
to bring up Game Center,

00:09:28.550 --> 00:09:31.170
and it's going to say, hey,
someone is trying to

00:09:31.170 --> 00:09:32.670
invite you to a game.

00:09:32.750 --> 00:09:37.000
And so all the pending matches that
they have are going to show up here.

00:09:37.000 --> 00:09:40.620
And they're going to click it,
and then they're going to

00:09:40.710 --> 00:09:42.400
play a word and hit next.

00:09:42.400 --> 00:09:45.020
And their word was worth
fewer points than our word,

00:09:45.020 --> 00:09:46.980
which is awesome.

00:09:47.300 --> 00:09:50.960
And so then the notification
passes to the third player.

00:09:51.050 --> 00:09:53.690
So as you'll notice,
the notification only shows up

00:09:53.810 --> 00:09:56.080
on the player whose turn it is.

00:09:56.210 --> 00:10:00.210
You do not get a notification
when transfer controls between

00:10:00.290 --> 00:10:02.340
two players who are not you.

00:10:02.340 --> 00:10:06.980
So your apps can poll for that if you
want to show some kind of notification

00:10:07.070 --> 00:10:11.250
as to whose turn it is currently,
but you won't get a notification

00:10:11.250 --> 00:10:13.230
from Game Center for that.

00:10:14.000 --> 00:10:17.780
So the third player is going to
take their turn and hit next.

00:10:17.780 --> 00:10:21.270
And now you can see instead of
getting a game invite notification,

00:10:21.300 --> 00:10:25.620
we actually get that turn notification
from Game Center a little differently,

00:10:25.680 --> 00:10:27.440
but that's what it looks like.

00:10:30.170 --> 00:10:33.900
So now that you've, you know,
had word for word

00:10:33.900 --> 00:10:37.370
refreshed in your memory,
let's look at some code and, like,

00:10:37.550 --> 00:10:42.510
you know, the basics of turn-based gaming
and what that looks like.

00:10:43.110 --> 00:10:46.260
Well,
Game Center and turn-based gaming is all

00:10:46.260 --> 00:10:49.240
based on this turn-based match object.

00:10:49.240 --> 00:10:54.900
So you get a GK turn-based match,
and just like any regular Cocoa object,

00:10:54.900 --> 00:10:59.490
you're going to, you know,
alloc and init that, nothing special.

00:10:59.490 --> 00:11:03.340
And most of the interaction
through your app is based on

00:11:03.340 --> 00:11:06.160
this turn-based event handler.

00:11:06.220 --> 00:11:09.070
And so wherever you want to put
the game logic for your app,

00:11:09.070 --> 00:11:12.660
you just have to, you know,
find that class and set it as the

00:11:12.660 --> 00:11:15.300
delegate of the turn-based event handler.

00:11:15.300 --> 00:11:17.780
And then you'll handle
three kinds of events.

00:11:17.820 --> 00:11:19.700
You're going to handle
invites from other people.

00:11:19.700 --> 00:11:23.780
You're going to handle turns,
so making it become your turn.

00:11:23.780 --> 00:11:26.280
And you're going to handle
the end of the match.

00:11:26.280 --> 00:11:29.840
So if the other person decided that,
you know, they were scared because you

00:11:29.840 --> 00:11:32.700
had an awesome score and just
declined your invitation,

00:11:32.700 --> 00:11:35.400
or if, you know, you won or they won,
you would get an

00:11:35.400 --> 00:11:37.120
end-of-turn notification.

00:11:37.150 --> 00:11:39.960
So in order to transfer
control to somebody,

00:11:39.960 --> 00:11:43.280
let's look at the basic
steps you have to do.

00:11:43.280 --> 00:11:46.760
First, you have to decide whose
turn it's going to be next.

00:11:46.860 --> 00:11:49.790
And so, for instance,
like the golf example I mentioned,

00:11:50.010 --> 00:11:52.270
you know,
control would transfer to whoever's

00:11:52.270 --> 00:11:54.610
ball was farthest from the pin.

00:11:54.690 --> 00:11:58.500
And so you'd call some code to figure
that out and get their player index,

00:11:58.500 --> 00:12:01.490
you know, zero-based,
zero to however many

00:12:01.560 --> 00:12:03.630
players there are minus one.

00:12:03.640 --> 00:12:06.040
In the word-for-word
example we just threw up,

00:12:06.100 --> 00:12:07.830
you know, we're going to just, you know,
we're going to just rotate

00:12:07.970 --> 00:12:09.060
through the players.

00:12:09.060 --> 00:12:12.180
So, you know, that's, like, super easy.

00:12:12.180 --> 00:12:16.390
And then you're going to take that index
and you're going to ask Game Center for

00:12:16.540 --> 00:12:20.620
the Game Center participant,
the GK turn-based participant,

00:12:20.620 --> 00:12:25.150
who is at that index in the
array of players in the match.

00:12:25.180 --> 00:12:28.760
And that object is what you'll use to
communicate with Game Center to say,

00:12:28.840 --> 00:12:31.360
hey, I want control to go to this person.

00:12:31.410 --> 00:12:33.160
And let's see what that looks like.

00:12:33.160 --> 00:12:34.350
So in our game where we had that arrow
that transferred control to the player,

00:12:34.350 --> 00:12:35.100
you're going to ask the Game Center for
the Game Center participant,

00:12:35.100 --> 00:12:35.900
the GK turn-based participant,
who is at that index in the

00:12:35.900 --> 00:12:36.640
array of players in the match.

00:12:36.640 --> 00:12:36.680
And then you're going to
ask Game Center for the

00:12:36.680 --> 00:12:37.300
Game Center participant,
the GK turn-based participant,

00:12:37.300 --> 00:12:38.640
who is at that index in the
array of players in the match.

00:12:38.640 --> 00:12:38.640
And let's see what that looks like.

00:12:38.640 --> 00:12:38.830
So, you know,
we're going to ask Game Center for

00:12:38.830 --> 00:12:39.430
the Game Center participant,
the GK turn-based participant,

00:12:39.430 --> 00:12:40.130
who is at that index in the
array of players in the match.

00:12:40.130 --> 00:12:40.640
And let's see what that looks like.

00:12:40.640 --> 00:12:41.040
So, you know,
we're going to ask Game Center for

00:12:41.040 --> 00:12:41.610
the Game Center participant,
the GK turn-based

00:12:43.000 --> 00:13:57.400
[Transcript missing]

00:13:57.600 --> 00:14:01.060
So now that we have this data,
this NSData blob, it's 4K or less,

00:14:01.920 --> 00:14:07.440
basically what we're going to do is
call that GKTurn-based match object that

00:14:07.440 --> 00:14:12.280
we've stored in our game class and say,
end turn with next participant,

00:14:12.280 --> 00:14:15.340
and we're going to hand it that
participant that we generated,

00:14:15.510 --> 00:14:17.120
the person whose turn it is next.

00:14:17.200 --> 00:14:20.030
We're going to hand it our
game data that we calculated,

00:14:20.030 --> 00:14:23.220
and we're going to give it a
block for a completion handler.

00:14:23.860 --> 00:14:26.350
And just the important thing
to recognize here is that this

00:14:26.660 --> 00:14:30.670
block runs asynchronously,
and so you won't necessarily

00:14:30.850 --> 00:14:34.710
have this block run microseconds
after you make this call.

00:14:34.860 --> 00:14:37.060
It may come back at some
later point and say,

00:14:37.180 --> 00:14:39.890
hey, there was an error,
I couldn't deliver this.

00:14:40.140 --> 00:14:42.920
Hey, there was an error,
the other person actually

00:14:43.050 --> 00:14:46.250
resigned earlier on their turn,
and you're just figuring this out now.

00:14:46.520 --> 00:14:52.340
Or there might be no error,
in which case everything's cool.

00:14:52.610 --> 00:14:56.300
You remember when we registered
our game class as the delegate?

00:14:56.300 --> 00:15:00.620
This is one of those functions in that
protocol that you need to implement.

00:15:00.840 --> 00:15:05.200
So when it's your turn,
this function will get called.

00:15:05.240 --> 00:15:06.740
And again,
you're just going to do whatever

00:15:06.740 --> 00:15:10.750
you need to unpack that turn data,
and then update your game

00:15:10.860 --> 00:15:13.620
state to take that turn,
and refresh your UI,

00:15:13.620 --> 00:15:16.260
showing that that turn has been taken.

00:15:16.320 --> 00:15:17.060
It's really simple.

00:15:17.060 --> 00:15:19.000
I mean,
there's no sort of standard code in here.

00:15:19.000 --> 00:15:21.100
You know,
it's going to vary based on your app.

00:15:21.190 --> 00:15:24.740
But it's really a pretty simple action.

00:15:25.780 --> 00:15:30.740
So, like I said, you can send up to four
kilobytes of turn data.

00:15:30.790 --> 00:15:35.940
And that doesn't sound like a lot,
but it actually works for a lot of games.

00:15:35.940 --> 00:15:40.440
If it really can't work for your game,
each match does have a unique ID.

00:15:40.510 --> 00:15:44.340
You can use it to index into some
database or use it as a key for cloud

00:15:44.340 --> 00:15:46.680
storage or whatever you want to do.

00:15:46.680 --> 00:15:52.530
And again, you only get notifications
when it is becoming your turn

00:15:52.530 --> 00:15:54.820
or someone is inviting you.

00:15:54.820 --> 00:15:58.740
So it will become your turn
when you accept the match.

00:15:58.740 --> 00:16:02.600
You have to poll Game Center if you want
to find out that transfer has controlled

00:16:02.640 --> 00:16:04.380
between two players who aren't you.

00:16:04.380 --> 00:16:08.290
So if all this sounds like something
that you can't wait to put in your app,

00:16:08.300 --> 00:16:12.080
we have four sessions coming up later
in the week on Game Center and all the

00:16:12.160 --> 00:16:16.440
ways that you can incorporate it into
your app and use turn-based gaming.

00:16:16.440 --> 00:16:20.560
We hope that you will go to those
sessions because we think that

00:16:20.560 --> 00:16:23.480
Game Center is actually pretty amazing.

00:16:23.940 --> 00:16:27.090
And not only makes your apps better,
but I as a game player love

00:16:27.090 --> 00:16:28.610
playing Game Center games.

00:16:28.710 --> 00:16:30.940
It keeps me interested longer.

00:16:31.120 --> 00:16:34.470
So, you know, again,
Game Center -- gaming is

00:16:34.470 --> 00:16:37.990
about not just playing games,
but about playing games

00:16:37.990 --> 00:16:39.220
with your friends.

00:16:39.520 --> 00:16:42.680
And so Game Center really
helps with that.

00:16:42.750 --> 00:16:46.010
You've seen the new
leaderboard features because,

00:16:46.110 --> 00:16:48.190
you know, competitive gaming,

00:16:48.500 --> 00:16:50.800
keeps people interested.

00:16:50.830 --> 00:16:56.770
Achievements help people get through
and find all the content that you've

00:16:56.770 --> 00:16:59.580
spent so long putting in your game.

00:16:59.640 --> 00:17:02.600
And so by adopting achievements,
you can make sure that they're

00:17:02.600 --> 00:17:06.120
driven to go find it and keep playing
your game as long as possible.

00:17:06.120 --> 00:17:10.430
And you can see with turn-based match,
we've added an interesting new way to

00:17:10.430 --> 00:17:15.600
add multiplayer experiences to gaming
in a way that works for casual gaming

00:17:15.600 --> 00:17:19.690
and that I can just pick up my device,
play a turn and put it down

00:17:20.090 --> 00:17:24.210
and not have to be -- you know,
carve out time in my schedule to, like,

00:17:24.550 --> 00:17:26.560
have a match with somebody.

00:17:26.640 --> 00:17:30.090
And so, again,
we are super excited to see what you guys

00:17:30.090 --> 00:17:32.870
are going to do with turn-based gaming.

00:17:34.140 --> 00:17:38.480
My favorite part of this presentation
is actually iCloud because it

00:17:38.650 --> 00:17:44.050
solves so many problems that are
actually fairly specific to gaming.

00:17:44.050 --> 00:17:47.680
And, you know, I'd like to run through
a few of those with you.

00:17:48.140 --> 00:17:50.400
But first, you know,
just sort of an overview of iCloud.

00:17:50.400 --> 00:17:52.860
It does automatic syncing.

00:17:52.860 --> 00:17:56.150
You don't have to tell it,
please push my data up to the cloud

00:17:56.260 --> 00:17:58.220
now or please go get some data.

00:17:58.220 --> 00:18:06.810
The storage is per user.

00:18:07.500 --> 00:18:07.530
So you saw the turn-based
match data was 4 kilobytes,

00:18:07.530 --> 00:18:07.530
and that was between users.

00:18:07.690 --> 00:18:14.080
Cloud Storage is for one user,
but it can span multiple domains.

00:18:14.090 --> 00:18:18.030
And so you wouldn't use
Cloud Storage to say,

00:18:18.190 --> 00:18:21.800
I want to send, you know,
my friend some data,

00:18:21.800 --> 00:18:26.760
but you'll see why this is
perfect for gaming in a second.

00:18:26.760 --> 00:18:29.900
You can store data between devices.

00:18:29.900 --> 00:18:34.530
So, for instance, if I have -- if I'm
playing a game and I just,

00:18:34.530 --> 00:18:39.220
you know, got to a new point in the game,
passed some hard boss

00:18:39.220 --> 00:18:42.710
on my iPhone on the bus,
and I'm like, awesome,

00:18:42.710 --> 00:18:46.680
and I put that down,
and I go to work and I pick up my iPad,

00:18:46.680 --> 00:18:51.010
and I'm like, oh, man,
I would have to play that all over again.

00:18:51.410 --> 00:18:55.010
Well, with the cloud,
your game state can just be automatically

00:18:55.010 --> 00:18:59.060
updated between all your devices,
so you can move from device to device

00:18:59.570 --> 00:19:01.840
and never lose your place in a game.

00:19:01.840 --> 00:19:06.360
You can also store data between
different versions of the same app or

00:19:06.360 --> 00:19:09.440
even between two wholly separate apps.

00:19:09.580 --> 00:19:13.770
So, for instance,
if you have a free version of an app,

00:19:13.770 --> 00:19:14.410
you can

00:19:14.530 --> 00:19:40.090
And you -- and someone
buys a paid version,

00:19:40.090 --> 00:19:40.090
all their data can go with them
because you can use the same cloud

00:19:40.090 --> 00:19:40.090
storage identifiers for those two apps.

00:19:40.090 --> 00:19:40.090
And so, you know,
this is something I think

00:19:40.090 --> 00:19:40.090
users will really love.

00:19:40.090 --> 00:19:40.090
So when they buy an app or maybe you
have a collection of games where you

00:19:40.090 --> 00:19:40.090
all want to share some shared state,
cloud storage will allow you to do that.

00:19:40.760 --> 00:19:42.930
And it works between platforms.

00:19:42.930 --> 00:19:47.690
So the focus of this talk, you know,
is primarily on iOS technologies.

00:19:47.690 --> 00:19:49.680
But this works on Lion, too.

00:19:49.680 --> 00:19:53.040
And so you'll see how these
classes can be adopted.

00:19:53.040 --> 00:19:58.180
You know, for instance, if you had some,
you know, role-playing game on an iOS

00:19:58.310 --> 00:20:01.080
device and you wanted to write a,
you know,

00:20:01.080 --> 00:20:05.020
my backpack organizer app for the Mac,
and they could go in and

00:20:05.160 --> 00:20:09.250
arrange their items and buy
potions and stuff like that.

00:20:09.500 --> 00:20:11.850
And then when they picked
up their iPad again,

00:20:11.850 --> 00:20:13.320
it could all just be there.

00:20:13.750 --> 00:20:16.950
And so, you know,
really much like turn-based gaming,

00:20:17.330 --> 00:20:21.300
the only limit is your imagination
on using this kind of stuff.

00:20:21.380 --> 00:20:27.800
So let's look at some code and just,
like, how super simple this is to use.

00:20:28.500 --> 00:20:31.190
Well, the first thing you're going
to do is get a connection.

00:20:31.330 --> 00:20:34.460
And thank God for Xcode
4's auto-complete,

00:20:34.530 --> 00:20:36.700
because this class is kind of long.

00:20:36.700 --> 00:20:42.060
You've got NS ubiquitous key value
store-- and just wait until you see the

00:20:42.670 --> 00:20:45.310
notification name-- and so basically,
you're just going to ask

00:20:45.500 --> 00:20:48.360
for the default store,
and you'll get a connection to the cloud.

00:20:48.670 --> 00:20:53.020
And you'll keep using this object
to refer to your cloud connection

00:20:53.410 --> 00:20:55.480
throughout the lifetime of your app.

00:20:55.560 --> 00:21:02.150
And so just sort of the most basic thing,
the easiest way to use the cloud,

00:21:02.160 --> 00:21:04.460
are key value pairs.

00:21:04.460 --> 00:21:06.870
Yesterday,
you saw a lot of cool examples about

00:21:06.870 --> 00:21:09.350
document-based use of the cloud.

00:21:09.680 --> 00:21:13.560
But I think key value pairs
are really easy to use.

00:21:13.610 --> 00:21:17.440
And so if you just wanted to
set some flag in your app,

00:21:17.490 --> 00:21:21.070
you could say, hey,
the player has set true

00:21:21.070 --> 00:21:25.480
for my awesome bool key,
or whatever you want that to represent.

00:21:25.790 --> 00:21:29.000
You know, it's a really simple API.

00:21:29.990 --> 00:21:33.660
So let's talk about specifically
how it might apply to games

00:21:33.700 --> 00:21:35.620
in the Game State example.

00:21:35.620 --> 00:21:39.200
Here you can see we're using NSKeyed
Archiver to pack up Game State.

00:21:39.250 --> 00:21:42.870
And we'll talk about that in just
a sec and why it's awesome and why

00:21:42.870 --> 00:21:47.660
you should adopt that probably for
structured data like Game State.

00:21:47.660 --> 00:21:50.940
But here you can see we're
just generating an NSData,

00:21:51.000 --> 00:21:52.850
so just some blob of bytes.

00:21:52.900 --> 00:21:58.660
And unlike turn-based gaming, you know,
there's no 4K limit here.

00:21:58.660 --> 00:22:01.770
You know, the user has some amount of
free storage on the cloud,

00:22:01.910 --> 00:22:06.660
but, you know, really just take whatever
space you need to upload that.

00:22:06.660 --> 00:22:09.660
And again, you just got a key value
pair mechanism here.

00:22:09.660 --> 00:22:15.010
We're going to set that data for my red
Game State and away to the cloud it goes.

00:22:15.540 --> 00:22:19.500
So I mentioned, you know,
this NSK archiver thing.

00:22:19.500 --> 00:22:22.700
Some of you may not be
familiar with Cocoa.

00:22:22.700 --> 00:22:28.170
And so this is something that's
come across from AppKit on Mac OS X.

00:22:28.510 --> 00:22:34.530
And basically it's a way for you to
add a platform-agnostic data encoding

00:22:34.530 --> 00:22:38.150
scheme to basically any class you want.

00:22:38.480 --> 00:22:44.160
And so whether you're transferring
data between a 32 and 64-bit device,

00:22:44.240 --> 00:22:49.000
between an iOS device and Lion,
it's not even Lion specific,

00:22:49.000 --> 00:22:52.530
but it is just really easy to use.

00:22:52.670 --> 00:22:55.080
Basically, your class,
your Game State class,

00:22:55.190 --> 00:22:57.820
is going to subscribe to
the NSCoding protocol,

00:22:57.820 --> 00:22:59.910
and you're going to
implement two functions,

00:22:59.910 --> 00:23:03.280
encodeWithCoder and initWithCoder.

00:23:03.700 --> 00:23:07.270
And basically,
this is a way to turn your class

00:23:07.270 --> 00:23:12.310
into an NSData object and then
inflate an NSData object back into...

00:23:12.390 --> 00:23:14.100
your game state.

00:23:14.100 --> 00:23:15.940
So what does this look like?

00:23:15.940 --> 00:23:20.640
Well, encode with coder is going to
be called anytime someone calls,

00:23:20.640 --> 00:23:22.340
you know, archive data.

00:23:22.380 --> 00:23:26.630
And so you get an
NSCoder object passed to you,

00:23:26.780 --> 00:23:32.580
and you can just basically enumerate
down the member variables in

00:23:32.580 --> 00:23:37.540
your class using whatever the
appropriate encode routine is,

00:23:37.540 --> 00:23:43.610
encode integer for a standard, you know,
like C int type, encode data for NSData,

00:23:43.620 --> 00:23:49.000
encode dictionary for, you know,
key value dictionary, that kind of thing.

00:23:49.000 --> 00:23:51.230
And you reference, you know,
your member variable and then the

00:23:51.230 --> 00:23:53.770
key you want it looked up under.

00:23:53.780 --> 00:23:56.560
And you know, the same, as you'll see,
we're going to unarchive one of

00:23:56.560 --> 00:23:59.700
these things in a second when
we come back from the cloud.

00:23:59.700 --> 00:24:02.500
Enit with coder is going to be called.

00:24:02.500 --> 00:24:04.990
Remember to initialize your
super class and then go ahead

00:24:04.990 --> 00:24:06.180
and get your values back.

00:24:06.280 --> 00:24:07.500
It's just really easy to use.

00:24:07.540 --> 00:24:09.000
use.

00:24:10.000 --> 00:24:14.630
So let's register for this cloud
notification so that when I'm

00:24:14.630 --> 00:24:18.660
playing a game on my iPad and my
iPhone is still awake or whatever,

00:24:18.660 --> 00:24:20.760
we can be told that, hey,
the data changed and

00:24:20.850 --> 00:24:23.400
you should go update it.

00:24:23.400 --> 00:24:26.660
We're going to get our
default notification center,

00:24:26.660 --> 00:24:30.150
which is just the standard
Cocoa Touch way of

00:24:30.530 --> 00:24:33.100
registering for notifications.

00:24:33.150 --> 00:24:38.500
My app class is whatever app class
you want to handle that notification.

00:24:39.200 --> 00:24:43.140
Handle sync data changed is the
function we're going to use to

00:24:43.140 --> 00:24:47.940
respond to the notification,
and we'll see that in a second.

00:24:47.980 --> 00:24:50.720
And here's that great notification name.

00:24:50.880 --> 00:24:55.700
The NS ubiquitous key value store
did change externally notification.

00:24:55.760 --> 00:24:59.300
So it's only 56 characters.

00:24:59.340 --> 00:25:02.080
And then we're going to pass
that Cloud Store object to it in

00:25:02.080 --> 00:25:05.400
case we wanted to refer to it.

00:25:05.640 --> 00:25:07.800
later when we're handling
the notification.

00:25:07.800 --> 00:25:11.180
So this is what's going to get called.

00:25:11.180 --> 00:25:15.930
And you can see, again, you know,
this NSNotification, you can pull that

00:25:15.930 --> 00:25:19.900
CloudStore object out of it,
and then use it to go pull

00:25:19.900 --> 00:25:24.480
out the blob of data that was
encoding my rad game state.

00:25:24.570 --> 00:25:27.800
And so that's going to pull
down that data out of the

00:25:27.950 --> 00:25:30.280
Cloud object that got synced.

00:25:30.280 --> 00:25:34.100
And then you're going to
call NSKeyedUnarchiver,

00:25:34.190 --> 00:25:39.540
unarchive object with data,
and that's going to call initWithCoder

00:25:39.540 --> 00:25:44.200
with that data and basically it will
inflate back to your game state.

00:25:44.240 --> 00:25:49.430
And we think that this is just a
really easy way for you to use the

00:25:49.500 --> 00:25:54.150
Cloud to solve a basic problem that
a lot of people have with gaming.

00:25:54.460 --> 00:25:58.490
And it will make sort of the casual
gaming experience across multiple

00:25:58.490 --> 00:26:00.300
iOS devices or multiple apps,
you know, a lot of people have.

00:26:00.300 --> 00:26:01.760
So this is just a really
easy way to do that.

00:26:01.810 --> 00:26:03.400
And it's going to be
really helpful to you.

00:26:03.480 --> 00:26:04.420
And I think that's a really
good way to go about this.

00:26:04.420 --> 00:26:07.150
And I think this is going to be a
really good way to go about this.

00:26:07.150 --> 00:26:08.570
So if you're interested in doing this,
I'm sure you've seen a lot of these apps.

00:26:08.570 --> 00:26:08.750
So much better.

00:26:08.770 --> 00:26:09.530
So you're probably
interested in adopting this.

00:26:09.530 --> 00:26:10.920
And so there are three
sessions later in the week.

00:26:10.920 --> 00:26:11.440
Two later today.

00:26:11.440 --> 00:26:12.200
And one on Wednesday.

00:26:12.200 --> 00:26:13.690
So hope to see you there.

00:26:13.930 --> 00:26:18.040
And again, you know, I covered, you know,
the basic game state life

00:26:18.180 --> 00:26:19.370
cycle with the Cloud.

00:26:19.450 --> 00:26:22.620
But just like turn-based gaming,
there are so many more

00:26:22.620 --> 00:26:24.250
ways that you can use this.

00:26:24.440 --> 00:26:28.710
If you have app preferences, for example,
you know, people have set some kind

00:26:28.710 --> 00:26:30.050
of gamma in your app.

00:26:30.390 --> 00:26:34.020
Or they want the Y axis inverted
in some flight simulator.

00:26:34.020 --> 00:26:39.100
You can transfer those preferences
through the Cloud to all the devices.

00:26:39.160 --> 00:26:41.710
You can handle app statistics.

00:26:41.710 --> 00:26:44.780
And, you know,
we hear stories all the time

00:26:44.780 --> 00:26:48.630
of how statistics keep people
super interested in games.

00:26:49.140 --> 00:26:51.410
And it's a little different
than achievements.

00:26:51.410 --> 00:26:53.410
But, you know, you can record anything.

00:26:53.440 --> 00:26:58.230
Like the number of times I have died
in Minesweeper on the fourth mine.

00:26:58.230 --> 00:27:01.780
Or, you know,
the number of times I have played poker.

00:27:01.780 --> 00:27:04.200
Or, you know,
anything that may not actually be

00:27:04.200 --> 00:27:06.000
an achievement or a leaderboard.

00:27:06.070 --> 00:27:08.210
But, you know,
you can make sure that those

00:27:08.340 --> 00:27:10.300
statistics get across to all devices.

00:27:10.300 --> 00:27:12.030
People love that kind of stuff.

00:27:12.170 --> 00:27:15.670
It makes that human connection
between them and your game.

00:27:15.890 --> 00:27:20.120
You can even do, like,
some cool personalization stuff.

00:27:20.120 --> 00:27:23.270
So you could imagine, for instance,
that you have some kind

00:27:23.270 --> 00:27:26.800
of doodling app or,
you know, paint app on your iPhone.

00:27:26.800 --> 00:27:29.860
And you want to paint up some cool logo
for a car and sync that to the cloud.

00:27:29.970 --> 00:27:33.120
And you can go play your
racing game on an iPad.

00:27:33.120 --> 00:27:37.180
That decal has already
been applied to the car.

00:27:37.180 --> 00:27:41.220
And you can see the art that you drew
right on the hood as you're racing.

00:27:41.220 --> 00:27:44.180
And, you know, so you can do so many
cool things with this.

00:27:44.300 --> 00:27:48.570
And we're excited to see what
you end up coming up with.

00:27:49.610 --> 00:27:56.460
The third thing I'm going to talk today
about is GL Kit and how OpenGL ES 2.0

00:27:56.610 --> 00:27:58.900
can now be made super simple.

00:27:59.020 --> 00:28:01.800
For those of you who are
already writing amazing shaders,

00:28:01.920 --> 00:28:02.460
that's great.

00:28:02.710 --> 00:28:03.740
Please keep doing that.

00:28:03.770 --> 00:28:04.390
We love it.

00:28:04.590 --> 00:28:05.880
It makes your games look awesome.

00:28:05.880 --> 00:28:11.070
But this is a way that a lot of you
will finally be able to access the power

00:28:11.070 --> 00:28:14.020
of OpenGL ES without being experts.

00:28:14.080 --> 00:28:16.630
So it does a number of things.

00:28:17.680 --> 00:28:19.580
There's UI Kit integration.

00:28:19.900 --> 00:28:26.180
So rather than needing to set up
OpenGL content as an OpenGL layer

00:28:26.180 --> 00:28:31.400
in a core animation layer tree,
there's now just a standard GL Kit view.

00:28:31.400 --> 00:28:35.090
You can throw in a view hierarchy
like any other Cocoa Touch view,

00:28:35.120 --> 00:28:38.320
and it'll just take care of
presenting the frame buffer,

00:28:38.320 --> 00:28:42.430
making sure that the performance is good,
running the animation loop,

00:28:42.430 --> 00:28:43.930
all that great stuff.

00:28:44.020 --> 00:28:46.200
There's a fast math library.

00:28:46.870 --> 00:28:51.240
I know we've been asking you for a couple
of years now to get off OpenGL ES 1.1

00:28:51.240 --> 00:28:55.900
and transition to OpenGL ES 2.0 so
that you can untap the full power of

00:28:56.010 --> 00:28:58.460
the iPad 2 and other modern devices.

00:28:58.620 --> 00:29:03.940
One of the downsides of that is that
OpenGL ES 1.1 actually had a lot of

00:29:03.940 --> 00:29:07.500
nice sort of matrix math built in,
a lot of state that you

00:29:07.630 --> 00:29:08.850
didn't have to think about.

00:29:08.940 --> 00:29:14.170
Well, we've recreated that in GL Kit so
that you can just easily transition

00:29:14.170 --> 00:29:16.560
off OpenGL ES 1.1 to 2.0.

00:29:16.870 --> 00:29:20.350
Without having to worry, like,
how do I write matrix multiplication

00:29:20.350 --> 00:29:22.960
that will actually perform
well on an ARM processor?

00:29:23.090 --> 00:29:24.400
No, you don't need to know.

00:29:24.520 --> 00:29:25.410
We'll just take care of that.

00:29:27.000 --> 00:30:39.600
[Transcript missing]

00:30:40.040 --> 00:30:43.450
It seemed hard to do at the time,
and so I went back to

00:30:43.530 --> 00:30:48.020
this example and thought,
how would I look at this code and do

00:30:48.070 --> 00:30:52.810
some of those same things using GLKit,
just so you can kind of see where

00:30:52.810 --> 00:30:55.570
we're going over the last couple years.

00:30:56.470 --> 00:31:01.190
Well, the first thing I wanted to look
at was texture loading and how that

00:31:01.190 --> 00:31:04.860
was actually not that easy to do.

00:31:04.860 --> 00:31:07.800
So we didn't have compressed
textures in this app.

00:31:07.910 --> 00:31:11.550
We just had, you know,
some little colored

00:31:11.590 --> 00:31:14.740
rectangles and a ball,
you know, a PNG of the ball.

00:31:14.740 --> 00:31:17.190
Or maybe, you know,
a PNG of the earth you

00:31:17.320 --> 00:31:20.080
could use as the ball,
that kind of thing.

00:31:20.080 --> 00:31:25.160
And so OpenGL doesn't really
know anything about UIKit or

00:31:25.160 --> 00:31:27.580
the rest of Cocoa Touch.

00:31:27.660 --> 00:31:30.690
And so let's walk through
what you had to do to get that

00:31:30.960 --> 00:31:32.840
image into an OpenGL texture.

00:31:32.840 --> 00:31:35.450
Well, first you had to go dig
it out of your bundle.

00:31:35.570 --> 00:31:39.460
So you had to say, "Hey, UI image,
go find this resource," and then

00:31:39.510 --> 00:31:43.470
turn it into a CG image because we're
going to need to get the bytes out.

00:31:43.690 --> 00:31:48.360
And so then we asked Core Graphics, "Hey,
how big is this thing?"

00:31:48.940 --> 00:31:52.700
If I succeeded in getting it,
we need to create some storage for it,

00:31:52.730 --> 00:31:57.160
because OpenGL sucks in all its
texture data through arrays of bytes.

00:31:57.240 --> 00:32:01.440
So we're going to allocate some storage,
knowing, of course,

00:32:01.440 --> 00:32:04.750
that the pixel values are
one byte per component and

00:32:04.940 --> 00:32:06.000
that there are four of them.

00:32:06.000 --> 00:32:09.440
Then we're going to create
a CG bitmap context,

00:32:09.440 --> 00:32:14.470
which tells Core Graphics how to
reason about this data as a texture.

00:32:15.350 --> 00:32:17.500
We're going to draw
that CG image into it,

00:32:17.500 --> 00:32:19.500
hopefully doing the right thing.

00:32:19.500 --> 00:32:23.000
And then we're going to
get into OpenGL and say,

00:32:23.000 --> 00:32:26.640
"Hey, generate me a texture name,
bind it to this texture,

00:32:26.640 --> 00:32:30.180
and then render these bytes
into that texture." This doesn't

00:32:30.180 --> 00:32:31.500
sound like a lot of fun.

00:32:31.500 --> 00:32:32.660
I didn't like doing it.

00:32:32.660 --> 00:32:38.900
And so this is one of the primary
things that can be made really easy.

00:32:39.130 --> 00:32:44.750
So this is the entirety of the
GL kit doing the same thing.

00:32:45.260 --> 00:32:48.960
Basically, we're going to ask NSURL for
that bundle resource.

00:32:49.040 --> 00:32:51.620
So you can say, hey, where is it?

00:32:51.880 --> 00:32:54.960
We're going to ask GL Kit,
which has this texture

00:32:54.960 --> 00:32:59.140
loader helper class,
to say, "Hey, given this URL,

00:32:59.140 --> 00:33:03.220
give me a texture info object."
And that texture info object

00:33:03.410 --> 00:33:07.110
contains all sorts of stuff,
but one of the things it contains

00:33:07.110 --> 00:33:11.770
is the OpenGL texture ID,
referenced by the texture name accessor,

00:33:11.770 --> 00:33:15.430
so that it took care of
generating that texture ID,

00:33:15.430 --> 00:33:19.100
binding the texture to it,
getting your data into it,

00:33:19.100 --> 00:33:20.920
and you can just use that.

00:33:20.920 --> 00:33:22.830
Other things in there
would be like the width,

00:33:22.830 --> 00:33:25.920
the height, the color channel ordering,
that kind of thing.

00:33:25.940 --> 00:33:29.660
You can query this texture info
object for any one of those things.

00:33:29.660 --> 00:33:32.730
So here's sort of our
one line of code example,

00:33:32.730 --> 00:33:34.980
space for readability.

00:33:34.980 --> 00:33:37.260
But you can see it's really
actually pretty easy.

00:33:37.370 --> 00:33:40.800
So you don't need to write your own
helper class that knows how to do all

00:33:40.800 --> 00:33:43.240
this stuff and handle error cases.

00:33:43.240 --> 00:33:45.380
GL Kit will just do it for you.

00:33:45.380 --> 00:33:47.880
And one of the things I'd like
to encourage you guys to do,

00:33:48.010 --> 00:33:50.960
here you can see in this example that
we've been working with PingFile.

00:33:51.000 --> 00:33:56.440
But GL Kit actually supports
loading PVR to compress textures

00:33:56.440 --> 00:33:58.920
directly from a bundle resource.

00:33:58.920 --> 00:34:01.080
So if you have the means to
go generate those textures,

00:34:01.080 --> 00:34:05.170
please do, because they will make the
GPU perform better by using less

00:34:05.170 --> 00:34:11.160
memory bandwidth than a one byte
per component texture like Ping.

00:34:11.160 --> 00:34:15.260
So the other thing you saw that
we did was we had that nice kind

00:34:15.260 --> 00:34:17.600
of spotlight around the ball.

00:34:17.720 --> 00:34:20.900
This was actually, you know, I mean,
it was a little bit of a

00:34:20.900 --> 00:34:21.540
challenge to get the ball to work.

00:34:21.540 --> 00:34:30.340
But we had to load this
background texture of bumps.

00:34:30.340 --> 00:34:34.720
And we had to set that as the input to
the sampler so that we could actually,

00:34:34.720 --> 00:34:38.200
you know, lighten up a portion of
it where the ball was.

00:34:38.200 --> 00:34:42.010
We had to tell GL to use the
light program that we'd written,

00:34:42.010 --> 00:34:46.160
which comprised a vertex
and fragment shader.

00:34:46.780 --> 00:34:50.940
We had to set some
variables in that program,

00:34:50.990 --> 00:34:54.000
for instance,
for the position of the ball,

00:34:54.000 --> 00:34:59.400
what texture the sampler is referring to,
the sampler being the OpenGL way

00:34:59.450 --> 00:35:01.840
that you sort of index into an image.

00:35:01.840 --> 00:35:05.430
And then we had to make the GL call
to draw arrays to take that vertex

00:35:05.590 --> 00:35:09.100
data and run the program on it
and do our per-pixel lighting.

00:35:09.490 --> 00:35:12.230
So here's this lighting
program that we wrote,

00:35:12.430 --> 00:35:15.670
which is so obviously drawing a,
you know,

00:35:15.800 --> 00:35:18.500
20-pixel light spotlight under a ball.

00:35:18.500 --> 00:35:22.180
And so, you know,
I can walk you through this,

00:35:22.270 --> 00:35:27.650
but basically all we're doing is
figuring out how far any pixel is from

00:35:27.650 --> 00:35:33.370
the center of the ball and attenuating
a spotlight and then blending in

00:35:33.370 --> 00:35:35.780
that light color with the background.

00:35:35.800 --> 00:35:39.060
And so this is great.

00:35:39.120 --> 00:35:42.160
If you want to do this stuff,
you can do really powerful

00:35:42.160 --> 00:35:45.820
things that GLKit is not going to
provide for you out of the box.

00:35:46.040 --> 00:35:49.000
But for something
simple like a spotlight,

00:35:49.000 --> 00:35:51.140
we do have a solution for you.

00:35:51.140 --> 00:35:55.030
And so basically all our
GLKit effects are referenced

00:35:55.240 --> 00:35:57.720
through this GLK base effect class.

00:35:58.560 --> 00:36:05.070
And what you can do is each GLK base
effect can reference a couple

00:36:05.070 --> 00:36:07.910
textures and a couple of lights.

00:36:08.390 --> 00:36:12.750
And so we're going to say
we want per-pixel lighting.

00:36:12.750 --> 00:36:16.440
The default would be per-vertex lighting.

00:36:16.440 --> 00:36:19.650
But we want a nice spot on one texture.

00:36:19.690 --> 00:36:23.840
So we're going to set some
light properties here.

00:36:23.840 --> 00:36:27.140
We're going to turn on the first light.

00:36:27.140 --> 00:36:33.410
We're going to position that light
over where we want the ball to be.

00:36:33.420 --> 00:36:41.300
And we're going to say, hey,
we want the cutoff to be 20 degrees.

00:36:41.300 --> 00:36:45.580
By default, the cutoff is 180 degrees,
so you get sort of this

00:36:45.580 --> 00:36:47.440
general directional light.

00:36:47.510 --> 00:36:51.430
And here we're just sort of
narrowing that down a little bit.

00:36:52.360 --> 00:36:55.660
And so basically then we're going to
put in our texture that we want lit.

00:36:56.950 --> 00:37:00.040
We're going to call prepareToDraw,
which sets up all the shader

00:37:00.040 --> 00:37:03.200
variables inside the GLKitBaseEffect.

00:37:03.250 --> 00:37:05.360
And then we call our
drawArrays call again.

00:37:05.400 --> 00:37:08.300
And here you can see it's, you know,
a much more friendly -- you know,

00:37:08.320 --> 00:37:10.860
it's not any more powerful
than what we did before,

00:37:10.920 --> 00:37:16.780
but it's just sort of much more friendly,
cocoa-y way of getting the power

00:37:16.780 --> 00:37:22.260
of OpenGL ES 2.0 into your app for
doing interesting drawing effects.

00:37:22.300 --> 00:37:28.200
The final thing I'd like to cover
in GLKit is this render loop.

00:37:29.000 --> 00:37:33.870
So as any of you who've tried
to implement an OpenGL ES app

00:37:34.060 --> 00:37:38.620
before have probably noticed,
the first thing you do

00:37:38.620 --> 00:37:43.340
is go to Xcode and say,
I want the OpenGL ES 2.0 template.

00:37:43.360 --> 00:37:49.390
And what you get is a bunch of files
with four or five pages of code that you

00:37:49.390 --> 00:37:54.160
are generally scared to touch because
it looks like it does magical things.

00:37:54.190 --> 00:37:58.580
And so, for instance,
it defines a core animation layer

00:37:58.640 --> 00:38:04.990
that implements some class that says,
I am really a geo layer.

00:38:05.280 --> 00:38:10.010
It knows how to unpack your
view hierarchy out of the nib,

00:38:10.170 --> 00:38:13.420
but you have to say, "Hey,
I really want this GL layer to be

00:38:13.420 --> 00:38:17.260
opaque so that you're not spending
GPU resources blending that with

00:38:17.360 --> 00:38:21.750
whatever's behind it." You have to say,
"Hey, I want this stuff to be

00:38:21.880 --> 00:38:23.770
a certain pixel format.

00:38:23.940 --> 00:38:28.110
I want it to have the
pixels in this order."

00:38:28.960 --> 00:38:34.520
I want to use the
OpenGL ES2 API instead of 1.

00:38:34.520 --> 00:38:40.240
And then you have to set up a timer to
tell the core animation display link,

00:38:40.320 --> 00:38:43.300
hey, I want to animate at this rate.

00:38:43.350 --> 00:38:46.170
And you can pick from a
number of different ways,

00:38:46.170 --> 00:38:48.800
but maybe you don't
know which one is best.

00:38:49.710 --> 00:38:52.480
And not only that,
so once you've set all that up,

00:38:52.660 --> 00:38:57.880
you haven't even started drawing,
then you have to implement this draw

00:38:57.880 --> 00:39:02.720
view call where you run your game logic,
and then you have to screw around

00:39:02.720 --> 00:39:05.800
with OpenGL frame buffers and make
sure you get a new frame buffer,

00:39:05.800 --> 00:39:09.580
you get your content into it,
you present it,

00:39:09.580 --> 00:39:16.520
and then you tear it down so that
OpenGL can discard that frame buffer data

00:39:16.520 --> 00:39:19.150
and not have to actually page it off.

00:39:19.160 --> 00:39:21.660
Or do other expensive things with it.

00:39:21.660 --> 00:39:25.670
You have to do all this stuff just
to do a basic OpenGL ES 2.0 app.

00:39:26.100 --> 00:39:28.150
And while you only have
to get it right once,

00:39:28.150 --> 00:39:30.680
we thought that there was
probably a better way to do this.

00:39:30.870 --> 00:39:34.500
So in GL Kit,
we now have this class called GLK View,

00:39:34.500 --> 00:39:38.610
and you can just add one of
these to your view hierarchy,

00:39:38.690 --> 00:39:43.070
write an interface builder,
and subclass it as you would any

00:39:43.070 --> 00:39:46.230
other view that you want to control.

00:39:47.120 --> 00:39:51.700
So when your app is done launching,
basically, you're just going to say, hey,

00:39:51.760 --> 00:39:57.620
I want to set the delegate for this
GLK view to whatever my game class is.

00:39:58.830 --> 00:40:04.940
And I'm going to basically set then
the frame rate that I want to target,

00:40:04.960 --> 00:40:10.510
and GLK view will take care of running
the animation at that frame rate.

00:40:10.720 --> 00:40:15.860
And there's basically two functions
that as a delegate of the GLK view,

00:40:15.950 --> 00:40:18.210
you have to handle.

00:40:18.210 --> 00:40:22.380
There's controller update,
and so that's going to get

00:40:22.380 --> 00:40:25.480
called whenever your game
logic needs to be updated.

00:40:25.650 --> 00:40:29.230
So in our little pong example,
we'd move the paddles up and

00:40:29.230 --> 00:40:32.860
down and hit detect the bricks
and all that kind of stuff.

00:40:32.870 --> 00:40:35.860
And that's nicely separated
from the drawing call,

00:40:35.890 --> 00:40:40.210
which is just where we would
implement any of our custom drawing,

00:40:40.310 --> 00:40:44.360
just like we would in
the previous example.

00:40:44.900 --> 00:40:48.540
We've really made this much
easier to reason about,

00:40:48.540 --> 00:40:52.320
and now OpenGL isn't a special case.

00:40:52.360 --> 00:40:55.920
It's just a first-class citizen
in the UIKit view hierarchy,

00:40:55.920 --> 00:40:57.040
just like anyone else.

00:40:57.040 --> 00:41:01.940
So you've seen how
OpenGLKit lets you adopt ES 2.0,

00:41:01.940 --> 00:41:05.600
even if you're not familiar with OpenGL.

00:41:05.600 --> 00:41:10.850
And the reason why it's important to
do that is we are building awesome

00:41:10.850 --> 00:41:13.400
GPUs into recent iOS devices.

00:41:14.120 --> 00:41:17.760
The iPad 2 GPU is fantastically powerful.

00:41:17.760 --> 00:41:20.240
As you've seen in some
of the demos already,

00:41:20.320 --> 00:41:23.710
you can run complicated shaders
at full-screen resolution

00:41:23.710 --> 00:41:25.680
at 60 frames a second.

00:41:25.790 --> 00:41:30.170
And you know,
you can use GLKit to get some of those

00:41:30.170 --> 00:41:32.880
effects into your app pretty easily.

00:41:33.000 --> 00:41:36.190
And so that way,
you can get the power of that hardware

00:41:36.400 --> 00:41:41.260
that's in all your customers' devices
without having to be an OpenGL ES expert.

00:41:41.400 --> 00:41:46.940
And there is tons of other functionality
in GLKit that I haven't covered today.

00:41:47.440 --> 00:41:52.060
And just like the previous two sections,
we have sessions for you to go to

00:41:52.120 --> 00:41:54.160
where you can find out more about that.

00:41:54.280 --> 00:41:59.500
So, Advances in OpenGL ES for iOS
5 is the main GL Kit session.

00:41:59.530 --> 00:42:03.330
That's tomorrow at 2:00 in this room.

00:42:03.430 --> 00:42:05.850
If you are interested in some of
the GL Tools stuff that you might

00:42:05.850 --> 00:42:09.590
have seen in State of the Union,
those sessions are coming up

00:42:09.590 --> 00:42:11.650
later on Wednesday as well.

00:42:13.090 --> 00:42:17.130
The final thing I'd like to
talk about today is AirPlay.

00:42:17.130 --> 00:42:21.960
And this is actually really
amazing in that how many

00:42:21.960 --> 00:42:24.580
people out there own an HDTV?

00:42:25.600 --> 00:42:31.810
See, these are the people that you can
target with AirPlay because everyone

00:42:31.810 --> 00:42:36.680
has a television and now we're
giving you a way to get content,

00:42:36.780 --> 00:42:39.380
your game content, on it.

00:42:40.280 --> 00:42:44.590
This is iPad 2 specific,
but you can mirror your game content

00:42:45.020 --> 00:42:50.640
if you just want to share the same
screen that's on the iPad on the TV.

00:42:50.700 --> 00:42:55.250
But the example we'll walk through today
is using your TV as a second display,

00:42:55.250 --> 00:42:59.780
because we think that this enables
some really cool use cases for games.

00:43:00.500 --> 00:43:05.500
So I have prepared for you some
excellent slideware of an example

00:43:05.500 --> 00:43:10.620
that we thought up and thought,
man, we really hope someone writes this.

00:43:10.620 --> 00:43:15.120
So here you can see we have an iPad,
and it's connected to an Apple TV,

00:43:15.270 --> 00:43:18.620
and it's asking me to draw an iPad.

00:43:18.620 --> 00:43:20.580
You may be familiar with this
game from your childhood.

00:43:20.580 --> 00:43:23.410
And so it gives you an area to doodle on,
and you doodle,

00:43:23.410 --> 00:43:26.450
and it appears on the television,
and people have to wonder

00:43:26.500 --> 00:43:28.110
what it is you're drawing.

00:43:29.540 --> 00:43:35.340
So you can see how AirPlay lets
you get game content.

00:43:35.480 --> 00:43:39.240
in front of a group of people, and again,
we're going for that social game

00:43:39.240 --> 00:43:44.210
experience where multiple people in
a room can all be playing your game

00:43:44.210 --> 00:43:46.400
together and having a great time.

00:43:46.530 --> 00:43:48.660
So let's look at AirPlay code examples.

00:43:48.860 --> 00:43:52.660
There are some really easy ways
that you can get content on there.

00:43:53.030 --> 00:43:56.580
UIKit has a new UI screen class.

00:43:57.050 --> 00:44:02.240
So if you want to detect the second
display when your app is launched,

00:44:02.280 --> 00:44:06.840
you can just say, "Hey, UIScreen,
how many screens are there?" And the

00:44:06.840 --> 00:44:08.630
answer is going to be one or two.

00:44:08.760 --> 00:44:12.110
So you can say,
"If there's more than one,

00:44:12.140 --> 00:44:17.930
I'm going to go ahead and get that
last screen object and do whatever

00:44:17.930 --> 00:44:21.060
I need to do to get my content on it."

00:44:22.410 --> 00:44:25.690
If you wanted to detect a hot plug,
for instance, someone putting that

00:44:25.850 --> 00:44:32.470
HDMI connection into an iPad 2 or
an Apple TV coming online and...

00:44:32.630 --> 00:44:36.100
Becoming ready to accept second display.

00:44:36.100 --> 00:44:39.660
You can register for a much
shorter notification this time.

00:44:39.660 --> 00:44:42.560
The UI screen did connect notification.

00:44:42.600 --> 00:44:45.170
And so again,
we're going to go get our default

00:44:45.170 --> 00:44:49.150
notification center and just say,
hey, we want to get a call to screen did

00:44:49.370 --> 00:44:51.760
connect whenever a screen shows up.

00:44:51.790 --> 00:44:58.450
And then again, we're going to go to this
prepare screen function.

00:44:58.450 --> 00:44:59.410
And what does prepare screen look like?

00:44:59.730 --> 00:45:04.000
Well, we need to get a reference to
the second screen so that we

00:45:04.000 --> 00:45:05.840
can create some content on it.

00:45:05.840 --> 00:45:09.260
The first thing we're going to do is we
want to create a window on that screen,

00:45:09.390 --> 00:45:11.530
and to create a window,
we have to know how

00:45:11.530 --> 00:45:12.540
big to make the window.

00:45:12.680 --> 00:45:15.700
So we ask the screen for its bounds,
and as you'll see,

00:45:15.700 --> 00:45:17.020
this isn't a fixed thing.

00:45:17.020 --> 00:45:20.970
We can actually change the
resolution a little bit later.

00:45:21.770 --> 00:45:27.350
When we create a UI window
with that size and

00:45:27.980 --> 00:45:32.700
So, when we set the screen
property of that UI window,

00:45:32.730 --> 00:45:38.890
we switch from being mirrored
display to being a secondary display.

00:45:39.030 --> 00:45:43.160
So, the important thing to recognize
here is whenever you create a

00:45:43.160 --> 00:45:45.140
window on that second display,

00:45:45.390 --> 00:45:49.700
That is what tells the system, "Hey,
this guy is actually trying to use

00:45:49.810 --> 00:45:51.860
this to display additional content.

00:45:51.900 --> 00:45:54.840
I'll switch out of mirroring
and into second display."

00:45:54.870 --> 00:45:58.860
When that last window goes away,
you drop back to mirroring.

00:45:59.500 --> 00:46:01.960
So now that we have this window,
we need to get a view in

00:46:01.960 --> 00:46:03.700
it and get some content.

00:46:03.830 --> 00:46:07.620
So you're just going to create whatever
view controller object you have for the

00:46:07.620 --> 00:46:10.210
content that you want to put in there.

00:46:10.440 --> 00:46:14.090
You're going to set that
Windows root controller as the

00:46:14.140 --> 00:46:16.820
view controller you just created.

00:46:17.100 --> 00:46:19.520
And you're going to set that
window's hidden property,

00:46:19.670 --> 00:46:23.080
which defaults to true, or yes, to no.

00:46:23.080 --> 00:46:26.630
And then that window will
appear and your glorious content

00:46:26.630 --> 00:46:28.440
will fill that television.

00:46:28.500 --> 00:46:32.350
But say, you know,
maybe you have some relatively, you know,

00:46:32.350 --> 00:46:35.590
expensive content to produce
on a per-pixel basis.

00:46:35.700 --> 00:46:40.950
UI Screen provides you a way to get
access to the supported resolution

00:46:40.950 --> 00:46:44.010
list and then change the resolution.

00:46:44.850 --> 00:46:51.210
So many HD televisions support 1080i,
720p, 480p, you know,

00:46:51.230 --> 00:46:53.570
maybe you'll get 1024 by 768.

00:46:53.800 --> 00:46:57.170
So if you would rather
be in one of those modes,

00:46:57.260 --> 00:47:02.170
you can get the list of available
modes and use a UI screen method

00:47:02.430 --> 00:47:04.930
to go switch into that mode.

00:47:05.240 --> 00:47:09.110
UI screen also provides you with
access to the preferred mode,

00:47:09.160 --> 00:47:13.030
which is going to be whatever
our best guess of what looks

00:47:13.030 --> 00:47:15.000
best on that screen is.

00:47:15.130 --> 00:47:18.270
And so, for instance,
the 720p television,

00:47:18.360 --> 00:47:21.290
the preferred mode is going to be 720p.

00:47:21.520 --> 00:47:24.580
You can also do some pretty
cool other little things here.

00:47:24.730 --> 00:47:27.690
One of the properties I thought
was neat in playing around with

00:47:27.690 --> 00:47:29.290
this was the screen brightness.

00:47:29.400 --> 00:47:33.460
So, for instance, if I'm doing something,
if I'm bringing the player's

00:47:33.460 --> 00:47:37.690
attention back to the iPad,
I can dim that exterior screen while

00:47:37.690 --> 00:47:39.400
I'm doing something iPad-centric.

00:47:39.440 --> 00:47:41.400
And when I'm done doing it,
I can bring the screen

00:47:41.400 --> 00:47:42.400
brightness back up.

00:47:42.430 --> 00:47:45.360
There are a few other properties,
but I encourage you to check

00:47:45.450 --> 00:47:52.400
out uiscreen.h and go to the
AirPlay session later today at 3:15.

00:47:52.400 --> 00:47:55.200
You'll see a whole bunch of
ways that you can use this,

00:47:55.370 --> 00:47:57.400
some of which are not game-specific.

00:47:57.400 --> 00:48:00.400
So, in summary, we've talked today
about four technologies.

00:48:00.510 --> 00:48:05.630
You've seen how Game Center can keep
players interested in your game and

00:48:05.630 --> 00:48:11.400
make gaming an awesome social experience
that is rewarding for your players.

00:48:11.400 --> 00:48:15.210
For both your players
and you as developers.

00:48:15.400 --> 00:48:21.070
You've seen how Cloud Storage can
solve basic problems in gaming

00:48:21.730 --> 00:48:26.110
that a lot of people have now and
will enable really cool new uses

00:48:26.320 --> 00:48:29.400
of multiple devices in your games.

00:48:29.400 --> 00:48:34.560
You've seen how GL Kit can solve
a lot of the basic problems of

00:48:34.560 --> 00:48:40.400
adopting OpenGL ES 2.0 in your app
and making the power of OpenGL and

00:48:40.400 --> 00:48:44.390
our GPUs accessible to those of
you who are not OpenGL ES experts.

00:48:46.520 --> 00:48:52.880
And you've seen how Air Display is
really easy to use and can

00:48:52.950 --> 00:48:57.470
really provide some interesting
collaborative game experiences,

00:48:57.470 --> 00:49:03.150
or just get your game on the HDTV that
almost everybody already owns.

00:49:03.270 --> 00:49:06.620
If you have questions
about any of this stuff,

00:49:06.810 --> 00:49:09.500
And you can't, for whatever reason,
make it to one of the sessions

00:49:09.500 --> 00:49:11.260
that I showed you earlier.

00:49:11.580 --> 00:49:13.320
You can contact Alan Schafer.

00:49:13.570 --> 00:49:16.700
He's our Game Technologies Evangelist
in Developer Relations.

00:49:16.700 --> 00:49:21.470
You can find us up here at
the stage between sessions.

00:49:21.700 --> 00:49:26.170
So part two will be starting about 15
minutes from now in the same convenient

00:49:26.250 --> 00:49:28.700
location you are already sitting.

00:49:28.700 --> 00:49:30.570
So we hope to see all of you back here.

00:49:30.960 --> 00:49:36.700
Graham will talk about the awesome
fundamentals of game design on iOS.

00:49:36.700 --> 00:49:38.700
Thank you for spending
your morning with me.

00:49:38.700 --> 00:49:40.530
It was wonderful to see you.

00:49:40.740 --> 00:49:43.700
I hope you go get some tea
and coffee and danishes.

00:49:43.700 --> 00:49:46.650
So thank you very much.
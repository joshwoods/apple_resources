WEBVTT

00:00:10.790 --> 00:00:13.500
Well, welcome to this session of
Core Animation Essentials.

00:00:13.510 --> 00:00:14.620
My name is Michael Levy.

00:00:14.620 --> 00:00:15.700
This is Tim Oriol.

00:00:15.700 --> 00:00:17.560
We'll be doing this
presentation together.

00:00:17.560 --> 00:00:20.020
I've really enjoyed
coming to these sessions.

00:00:20.090 --> 00:00:22.840
I've just been amazed by some
of the stuff I've already

00:00:22.840 --> 00:00:24.580
seen that you guys have done.

00:00:24.580 --> 00:00:29.080
And I hope that the session we give you
will help you punch it up even more or,

00:00:29.080 --> 00:00:32.140
if you're new,
help you get those same incredible apps

00:00:32.490 --> 00:00:35.000
on both the Mac OS X platform and on iOS.

00:00:35.720 --> 00:00:39.300
And before we even get into this talk,
I'm going to hand over to

00:00:39.300 --> 00:00:40.800
Tim for our first demo.

00:00:42.290 --> 00:00:45.440
All right, so for the first demo,
the whole point was just to give you

00:00:45.440 --> 00:00:50.130
a taste of what kind of things you can
expect Core Animation to give you or

00:00:50.130 --> 00:00:54.300
add to the current things you can do
with UIKit for your user interface.

00:00:54.350 --> 00:00:58.860
What we have here is an app that
allows the user to select an item.

00:00:58.890 --> 00:01:00.250
Here we have photos.

00:01:00.340 --> 00:01:02.920
And of course,
we want to give good visual feedback

00:01:03.050 --> 00:01:04.660
to show which item is selected.

00:01:04.790 --> 00:01:09.300
So if we tap on one of the items,
you can see that the photo is enlarged.

00:01:09.340 --> 00:01:11.840
And if you're only doing this,
you can do it and you probably

00:01:11.840 --> 00:01:13.440
should be doing it with UIKit.

00:01:13.580 --> 00:01:15.820
You change the bounds and
UIKit behind the scenes is

00:01:15.820 --> 00:01:18.590
going to use Core Animation to
get this smooth animation.

00:01:18.670 --> 00:01:22.000
So if you go to another photo,
the old one will animate down and

00:01:22.000 --> 00:01:24.260
the new one will animate larger.

00:01:24.330 --> 00:01:27.550
If we move to effect number two,
now when we tap a photo,

00:01:27.550 --> 00:01:30.850
it's going to pulsate,
so it's going to shrink and grow.

00:01:31.180 --> 00:01:33.560
And this you could do with UIKit,
but you're going to have

00:01:33.660 --> 00:01:34.670
to mess around with timers.

00:01:34.710 --> 00:01:38.670
And if you want to do this,
we're going to talk about the

00:01:38.670 --> 00:01:42.860
CA media timing protocol later on,
which you can leverage to create

00:01:42.950 --> 00:01:46.750
repeating animations to add to
your layers for a specific repeat

00:01:46.850 --> 00:01:48.930
count or to repeat forever.

00:01:49.010 --> 00:01:52.800
If we move to effect three,
now this is something you really

00:01:52.800 --> 00:01:55.060
want to use Core Animation for.

00:01:55.060 --> 00:01:59.360
One of the great things about
Core Animation is it gives you border

00:01:59.460 --> 00:02:04.690
width and border color properties for
any layer that you have on the screen.

00:02:04.690 --> 00:02:05.340
And as with most
Core Animation properties,

00:02:05.440 --> 00:02:06.510
these can all be animated.

00:02:06.780 --> 00:02:09.500
So we apply a repeating animation
and we're going to make the

00:02:09.500 --> 00:02:13.670
border color light yellow,
dark yellow, light yellow, dark yellow,

00:02:13.670 --> 00:02:16.440
and to sort of highlight
which one is selected there.

00:02:16.470 --> 00:02:19.470
And now let's move to effect number four.

00:02:19.690 --> 00:02:21.740
For 4, we get a card flip animation.

00:02:21.740 --> 00:02:25.070
The layer is going to twist around in
3D space and we're going to bring it

00:02:25.120 --> 00:02:27.300
up center and close to the user's eye.

00:02:27.330 --> 00:02:32.310
This is using what we like to call
the 2.5D perspective transform that

00:02:32.310 --> 00:02:33.550
you can set up in Core Animation.

00:02:33.590 --> 00:02:34.810
It takes a little bit
of work to get set up,

00:02:34.910 --> 00:02:38.670
but after that it's pretty intuitive
to position your layers on the screen.

00:02:38.780 --> 00:02:40.870
Let's move to effect five.

00:02:41.020 --> 00:02:43.650
Now when we tap on something,
you can see we have this sparkly

00:02:43.660 --> 00:02:46.040
blue aura around the selected photo.

00:02:46.160 --> 00:02:48.570
This is something you can
also do with Core Animation,

00:02:48.570 --> 00:02:52.160
and I'm going to talk a little bit more
about that at the end of the talk today.

00:02:52.210 --> 00:02:52.430
Thank you.

00:02:52.580 --> 00:02:54.310
Back to Michael.

00:02:54.890 --> 00:02:55.800
Okay, thank you, Tim.

00:02:55.800 --> 00:02:58.720
So what are we going to cover today?

00:02:58.720 --> 00:03:00.460
There's quite a lot to cover.

00:03:00.460 --> 00:03:03.210
We thought we would go from really
from the beginning right through

00:03:03.370 --> 00:03:04.860
to some more advanced topics.

00:03:04.860 --> 00:03:05.930
So we've got a lot to cover.

00:03:06.020 --> 00:03:07.290
We're going to try and pack it up.

00:03:07.430 --> 00:03:10.490
So whatever your level of experience is,
hopefully there'll be something

00:03:10.490 --> 00:03:11.660
for you in this session.

00:03:11.940 --> 00:03:14.030
We'll start with fundamental concepts.

00:03:14.030 --> 00:03:15.660
We have three parts to the talk.

00:03:15.730 --> 00:03:18.510
At the very heart of it is
layers and layer properties.

00:03:18.510 --> 00:03:20.360
We'll talk quite a bit about them.

00:03:20.360 --> 00:03:23.440
And then, of course,
how you animate layer properties,

00:03:23.960 --> 00:03:26.090
including a section
about what animation is.

00:03:26.100 --> 00:03:28.770
We will then cover
topics in Core Animation,

00:03:28.770 --> 00:03:33.640
including layers, 3D transforms,
and perspective, the presentation layer

00:03:33.640 --> 00:03:36.800
versus the model layer,
notifications and timing,

00:03:36.800 --> 00:03:39.240
and a little bit about performance.

00:03:39.240 --> 00:03:41.900
And we'll end that section
talking about the core animation.

00:03:41.940 --> 00:03:43.310
We'll talk about masks and shadows.

00:03:43.310 --> 00:03:45.870
There are, of course, other topics,
and I urge you to look at previous

00:03:45.870 --> 00:03:47.460
presentations for more information.

00:03:47.550 --> 00:03:50.280
We just didn't have time
to get everything in.

00:03:50.280 --> 00:03:52.890
And we'll end with a little
bit extra that's quite fun at

00:03:52.890 --> 00:03:54.450
the end of the presentation.

00:03:54.460 --> 00:03:58.700
So let's just start with the
architectural overview so you get

00:03:58.700 --> 00:04:03.120
some sense of what core animation
really is and where it fits into

00:04:03.120 --> 00:04:05.920
both the iOS and Mac OS X frameworks.

00:04:05.920 --> 00:04:08.210
So, you know,
it's common to use this kind

00:04:08.210 --> 00:04:11.900
of block diagram with UIKit or
AppKit at the top and the graphics.

00:04:11.900 --> 00:04:14.850
And you can see that the graphics
hardware at the bottom and the

00:04:15.060 --> 00:04:18.320
core animation is a framework,
and it fits in between there.

00:04:18.320 --> 00:04:19.520
It uses core graphics.

00:04:19.590 --> 00:04:23.660
It uses OpenGL, either ES or OpenGL,
depending on the platform.

00:04:23.660 --> 00:04:25.980
And they, in turn,
talk to the graphics hardware.

00:04:25.980 --> 00:04:29.730
But one of the great things
about developing for the iOS and

00:04:29.730 --> 00:04:33.980
Mac OS X platforms is that your app
can always reach down from the top

00:04:33.980 --> 00:04:36.440
level as far down as it needs to go.

00:04:36.440 --> 00:04:39.690
Now, hopefully, the higher up you are
in this block diagram,

00:04:39.690 --> 00:04:41.880
the more that's taken care of for you.

00:04:41.880 --> 00:04:46.880
So you can get great effects
very concisely just using UIKit.

00:04:46.940 --> 00:04:50.590
If you want to then punch it up again,
you can then drill down a little

00:04:50.650 --> 00:04:52.700
bit into core animation and so on.

00:04:52.720 --> 00:04:56.100
And the design philosophy of
core animation is to take all

00:04:56.100 --> 00:04:59.390
those common and tricky tasks,
such as, for example,

00:04:59.410 --> 00:05:03.280
doing the mathematical computation
of interpolation points and

00:05:03.280 --> 00:05:05.660
making that all automatic for you.

00:05:05.660 --> 00:05:08.870
How to do transformations
that do these great effects,

00:05:08.870 --> 00:05:11.860
like the flip effect
that you saw on the card.

00:05:11.860 --> 00:05:15.010
The details of that are all
taken care of for you inside

00:05:15.010 --> 00:05:17.020
the core animation framework.

00:05:18.760 --> 00:05:21.640
I won't talk about this slide a lot,
but just give you some sense of

00:05:21.710 --> 00:05:23.350
what's happening behind the scenes.

00:05:23.380 --> 00:05:25.380
It's what's called compositing.

00:05:25.380 --> 00:05:30.080
That is, you have a bunch of layers
that the user will see,

00:05:30.080 --> 00:05:33.310
but before each frame gets rendered,
there are a bunch of steps

00:05:33.430 --> 00:05:34.920
that have to go through.

00:05:34.920 --> 00:05:36.850
So, firstly,
there's a kind of sorting that

00:05:36.850 --> 00:05:39.640
has to go on because layers
typically go on top of each other.

00:05:39.640 --> 00:05:42.220
And as we'll see,
you can affect that positioning.

00:05:42.220 --> 00:05:46.030
You have to merge the layer background
with the layer content and then

00:05:46.030 --> 00:05:48.080
apply borders and shadows and so on.

00:05:48.080 --> 00:05:50.900
And eventually,
the visual thing that you want to

00:05:50.900 --> 00:05:53.200
show your user shows up on the screen.

00:05:53.200 --> 00:05:57.950
And these steps may have to occur for
the production of every single frame.

00:05:57.960 --> 00:06:01.040
And especially when you're worried
about getting good performance,

00:06:01.040 --> 00:06:06.510
it's helpful to have this picture in
your mind while you do the design.

00:06:06.520 --> 00:06:10.320
But let's just step back a bit
and go to the real basics of this.

00:06:10.340 --> 00:06:12.180
And that is just what is animation.

00:06:12.250 --> 00:06:15.790
Now, I'm going to use here what I'm now
calling the hello world of animation,

00:06:15.800 --> 00:06:18.000
which is we're going to have a layer.

00:06:18.000 --> 00:06:21.090
It looks like a ball,
and we wanted to do something like

00:06:21.090 --> 00:06:23.170
drop to the bottom of the screen.

00:06:23.180 --> 00:06:26.220
So, in core animation,
you achieve that in a very simple way.

00:06:26.220 --> 00:06:29.870
You just change the position property
of the layer to a new position,

00:06:29.930 --> 00:06:34.690
P, and that animation occurs,
and you get this nice, smooth animation.

00:06:34.730 --> 00:06:37.630
Now, behind the scenes,
there are two important things that

00:06:37.630 --> 00:06:39.530
have to be computed by core animation.

00:06:39.580 --> 00:06:42.290
The one is the points,
the interpolated points,

00:06:42.310 --> 00:06:44.160
and the second is the timing.

00:06:44.160 --> 00:06:47.960
Now, by timing, I mean a kind of timing
function that controls,

00:06:48.080 --> 00:06:49.920
how the animation appears to you.

00:06:49.920 --> 00:06:53.080
Is it very jerky,
sort of infinite speed and then stop?

00:06:53.160 --> 00:06:56.800
Or does it start going faster,
reach its maximum speed, slow down?

00:06:56.800 --> 00:06:59.730
Well, you can control that with
timing function properties.

00:06:59.740 --> 00:07:03.380
So, those,
and the defaults set for all of those.

00:07:03.470 --> 00:07:05.360
So, normally speaking,
you don't have to worry about it.

00:07:05.440 --> 00:07:08.320
You'll get good default behavior,
which will make your app look great.

00:07:08.360 --> 00:07:10.510
But you can override it if you need to.

00:07:10.520 --> 00:07:13.250
And then, of course,
once those things are known, then,

00:07:13.310 --> 00:07:14.740
of course, what is animation?

00:07:14.830 --> 00:07:16.760
Well,
it's just a matter of core animation,

00:07:16.780 --> 00:07:17.800
producing all the intermediates.

00:07:18.080 --> 00:07:20.230
So, you can do that by taking
the intermediate frames and

00:07:20.550 --> 00:07:23.150
rendering them onto the device,
hopefully at a good frame rate,

00:07:23.200 --> 00:07:24.710
like 60 frames per second.

00:07:25.670 --> 00:07:27.100
So how do we do all this?

00:07:27.100 --> 00:07:28.560
Well, let's start off with layers.

00:07:28.700 --> 00:07:30.300
They're really at the heart of it.

00:07:30.300 --> 00:07:34.200
And the layers in iOS come for free,
as it were.

00:07:34.200 --> 00:07:37.290
Behind every UIView object is a layer.

00:07:37.660 --> 00:07:41.440
And you can reach it by using
the layer property of the view.

00:07:41.440 --> 00:07:45.390
And if you're just doing a standard
UIKit application and you have a draw

00:07:45.400 --> 00:07:48.990
rect method for providing content,
then the draw rect is actually

00:07:49.100 --> 00:07:53.150
rendering behind the scenes into
the layer that backs your UIView.

00:07:53.380 --> 00:07:56.810
In Mac OS X, it's slightly different.

00:07:56.880 --> 00:07:59.630
There you have to tell the
NSView explicitly that you want to

00:07:59.630 --> 00:08:02.510
use a backing layer and you have to
tell it which layer you want to use.

00:08:02.510 --> 00:08:06.580
After that, everything works identically,
both on Mac OS X and iOS,

00:08:06.580 --> 00:08:09.760
with some minor exceptions
that I won't go into,

00:08:09.760 --> 00:08:11.580
but are well documented.

00:08:11.660 --> 00:08:14.530
So the CA layer hierarchy
looks like this.

00:08:14.630 --> 00:08:17.880
I've left out some of the
subclasses that exist.

00:08:17.890 --> 00:08:20.980
We'll talk about some
of these subclasses.

00:08:21.020 --> 00:08:22.690
At the top is CA layer itself.

00:08:23.160 --> 00:08:25.160
And that is not an abstract class.

00:08:25.160 --> 00:08:26.950
You can instantiate CA layers.

00:08:27.010 --> 00:08:30.390
And in fact, in many cases,
that's all you ever need to instantiate.

00:08:30.480 --> 00:08:34.870
So in demo one, for example,
all we did is make nine, was it nine,

00:08:34.880 --> 00:08:38.520
12 instances of CA layer,
populated them with content,

00:08:38.520 --> 00:08:39.620
and that was it.

00:08:39.740 --> 00:08:42.480
There was no need to write
any explicit drawing code.

00:08:42.480 --> 00:08:45.750
And I'll talk about why that
happens and the advantage of that

00:08:45.750 --> 00:08:47.560
in a couple of slides from now.

00:08:47.560 --> 00:08:51.260
There are a couple of interesting
subclasses for specialized purposes,

00:08:51.330 --> 00:08:52.520
like CA shape layer.

00:08:53.040 --> 00:08:55.930
There's a lot of other things that you
can do with CA text layer and so on,

00:08:56.000 --> 00:08:59.940
and we'll talk about some of
them during the presentation.

00:09:00.000 --> 00:09:02.940
So let's move on to the next demo.

00:09:02.940 --> 00:09:05.700
And the purpose of this demo,
very simple-minded one,

00:09:05.700 --> 00:09:08.860
but just to start you thinking
about CA layers and how you might

00:09:08.930 --> 00:09:10.940
use them in your applications.

00:09:10.940 --> 00:09:14.290
I used a playing card because
I'm assuming that almost everyone

00:09:14.290 --> 00:09:17.500
on the planet has seen playing
cards at one time or other,

00:09:17.500 --> 00:09:22.720
so I don't have to explain too much.

00:09:22.720 --> 00:09:23.720
So let's start with the first one.

00:09:23.720 --> 00:09:29.880
So let's start with the first one.

00:09:30.900 --> 00:11:09.200
[Transcript missing]

00:11:09.500 --> 00:11:13.460
The layer and sublayering model is very
similar to UIView with the only exception

00:11:13.510 --> 00:11:15.090
being that it's a lot more lightweight.

00:11:15.180 --> 00:11:17.150
So it doesn't come with
gesture recognizers,

00:11:17.250 --> 00:11:18.280
for example.

00:11:18.400 --> 00:11:21.290
But otherwise it has a whole bunch
of very similar methods like the

00:11:21.290 --> 00:11:24.640
ability to add sublayers so you
can have an arbitrarily nested

00:11:24.730 --> 00:11:26.600
tree structure of sublayers.

00:11:26.700 --> 00:11:29.140
You can insert sublayers
in different positions.

00:11:29.260 --> 00:11:31.970
The default is to put them
one on top of each other as

00:11:31.970 --> 00:11:33.720
the name layering would imply.

00:11:33.810 --> 00:11:38.110
And then there are methods like
set needs layout which allows

00:11:38.110 --> 00:11:40.170
you to reshuffle your layers.

00:11:40.550 --> 00:11:45.310
Layout set needs display if
you want to force a refresh.

00:11:45.330 --> 00:11:47.400
Very often that's handled
for you automatically.

00:11:47.440 --> 00:11:50.970
But on occasion you'll make a
change that you have to explicitly

00:11:50.970 --> 00:11:52.880
notify needs to be refreshed.

00:11:52.960 --> 00:11:57.090
And if you subclass CA layer you
can implement a draw in context

00:11:57.090 --> 00:12:02.680
method to provide explicit
context using Core Graphics.

00:12:02.920 --> 00:12:05.720
A more common way to do it though
is to set the delegate property

00:12:06.080 --> 00:12:09.720
in which case the delegate object
can if it wants to implement the

00:12:09.720 --> 00:12:11.800
draw layer in context method.

00:12:11.810 --> 00:12:15.500
And it can then provide
content for one or more layers.

00:12:15.630 --> 00:12:19.540
The transform property is a very
important one and the transform

00:12:19.540 --> 00:12:23.480
unlike Core Graphics is a three
dimensional transform matrix.

00:12:23.600 --> 00:12:26.260
So there's three coordinates x, y, and z.

00:12:26.500 --> 00:12:32.120
And in the part two of the talk we'll
talk about what we call the 2.5D model.

00:12:32.140 --> 00:12:33.810
Um...

00:12:34.300 --> 00:15:40.600
[Transcript missing]

00:15:41.050 --> 00:15:43.730
We apply that,
we set the transform property

00:15:43.830 --> 00:15:46.600
to be that composed transform,
set the position, of course,

00:15:46.670 --> 00:15:49.800
near the bottom right,
and there's the heart pip.

00:15:49.850 --> 00:15:54.770
And I leave as an exercise for you to
figure out how you would do the others,

00:15:54.890 --> 00:15:58.150
pretty straightforward,
once you get the concepts

00:15:58.260 --> 00:16:00.190
to do the rest of the card.

00:16:00.730 --> 00:16:03.710
The layer geometry is
very straightforward,

00:16:03.720 --> 00:16:04.840
important to understand.

00:16:04.840 --> 00:16:06.390
Luckily, there's not too much to it.

00:16:06.480 --> 00:16:08.520
The important concepts
are obviously the bounds,

00:16:08.520 --> 00:16:12.060
which tell you the size,
the height and width of the layer,

00:16:12.060 --> 00:16:16.980
the position, which is a point in the
superlayer's coordinate space,

00:16:16.980 --> 00:16:19.370
the anchor point,
which I'm going to talk a

00:16:19.370 --> 00:16:22.990
bit more about in a second,
and of course, this three-dimensional

00:16:23.030 --> 00:16:24.480
transform property.

00:16:25.180 --> 00:16:29.960
So, the anchor point, sorry,
let me just go back to the slide.

00:16:29.960 --> 00:16:33.850
The anchor point is a point whose values,
whose X and Y values

00:16:33.860 --> 00:16:35.460
range between 0 and 1.

00:16:35.460 --> 00:16:38.640
And in the coordinate space
I'm showing above here,

00:16:38.640 --> 00:16:43.850
which is the iOS 1, the default is 0.5,
0.5, which says place this in

00:16:43.850 --> 00:16:45.660
the middle of the layer.

00:16:45.660 --> 00:16:49.670
If you use, for example, 0, 0,
it would be in the top left-hand corner,

00:16:49.670 --> 00:16:50.870
the 0, X, 0, Y.

00:16:50.870 --> 00:16:54.340
If you use 1, 1,
it would be in the bottom right corner.

00:16:55.040 --> 00:16:59.310
And where you set the anchor point
affects positioning in superlayers

00:16:59.310 --> 00:17:01.620
and some of the property changes.

00:17:01.620 --> 00:17:04.950
So, for example,
if we rotate around the center

00:17:04.950 --> 00:17:08.280
with the default position,
you'd get what you expect

00:17:08.680 --> 00:17:11.280
rotation around the center point.

00:17:11.320 --> 00:17:14.990
But if the anchor point had been
set to the lower left-hand corner,

00:17:14.990 --> 00:17:17.550
which you would do by
setting it to a point 0,

00:17:17.550 --> 00:17:20.470
1, then we get a different
rotational effect.

00:17:20.590 --> 00:17:23.110
We rotate, in that case,
with the same transform

00:17:23.110 --> 00:17:24.900
around the bottom left corner.

00:17:24.900 --> 00:17:24.900
So, if you use 1, 1, X, 0, Y,
which says place this in

00:17:24.900 --> 00:17:24.920
the bottom left corner,
the 0, X, 0, Y.

00:17:24.920 --> 00:17:29.170
of the screen, in this case a transform
around the z-axis again.

00:17:30.410 --> 00:17:32.790
So that's my very quick
introduction to CA Layers.

00:17:32.870 --> 00:17:34.990
Let's get on to the neat stuff,
the animation.

00:17:35.050 --> 00:17:36.590
How do you do that?

00:17:36.680 --> 00:17:38.580
So just to go back to
basics a little bit,

00:17:38.610 --> 00:17:41.120
I've already showed that
frame-by-frame thing.

00:17:41.120 --> 00:17:45.730
So if you stop and think about it a bit,
you'll realize that animation is

00:17:45.730 --> 00:17:50.160
really the interpolation of a bunch of
points starting at an initial point,

00:17:50.160 --> 00:17:53.830
going through some interpolated points,
and ending at a destination.

00:17:53.830 --> 00:18:01.000
And we explicitly use the key
names from value and to value.

00:18:01.000 --> 00:18:04.660
You'll see them crop up later on when
we talk about explicit animations.

00:18:04.660 --> 00:18:10.330
There are in fact two styles of animation
in the Core Animation framework,

00:18:10.330 --> 00:18:14.160
implicit animations and
explicit animations.

00:18:14.160 --> 00:18:16.260
And we'll start with implicit animations.

00:18:16.260 --> 00:18:21.470
Now supposing we have a picture here
and we wish to just... fade it away,

00:18:21.630 --> 00:18:23.780
then we just do that.

00:18:23.960 --> 00:18:27.960
It's declarative, you do that,
and the picture fades away.

00:18:27.960 --> 00:18:30.480
Now notice it didn't disappear, it faded.

00:18:30.640 --> 00:18:34.120
Maybe that was too quick for
you to see because it used the

00:18:34.120 --> 00:18:37.750
default animation duration,
which is one second.

00:18:37.760 --> 00:18:44.640
There is a class called CA Transaction
which lets you override those defaults.

00:18:44.810 --> 00:18:47.270
And I'll use two of them now
because I'll do a slightly more

00:18:47.370 --> 00:18:50.120
complicated implicit animation.

00:18:50.120 --> 00:18:51.620
In fact, two implicit animations.

00:18:51.620 --> 00:18:55.710
I'm going to move the image to the
bottom of the view and fade it out,

00:18:55.860 --> 00:18:57.020
but with different timing.

00:18:57.020 --> 00:18:59.520
I'm going to make the fade
last longer than the move.

00:18:59.620 --> 00:19:02.110
So, and I do that like this.

00:19:02.210 --> 00:19:03.110
Let's see if it works.

00:19:03.120 --> 00:19:05.360
So notice,
I don't know if you could notice the

00:19:05.360 --> 00:19:09.020
opacity going away as it was moving down,
but the idea is to move it in

00:19:09.020 --> 00:19:11.420
two seconds and fade it in five.

00:19:11.420 --> 00:19:14.620
And this is the code that
I would use to achieve that.

00:19:14.620 --> 00:19:18.180
I chose this example to point
out an important little gotcha,

00:19:18.180 --> 00:19:21.060
which is you can use CA Transaction,
to set properties,

00:19:21.100 --> 00:19:24.100
and we'll talk about more of them,
the media timing properties.

00:19:24.110 --> 00:19:27.100
One that you'll use very
often is animation duration,

00:19:27.220 --> 00:19:31.840
but you have to remember that the
value that's in effect dynamically

00:19:31.930 --> 00:19:36.100
at the time that your property change
is made is the one that will be used.

00:19:36.100 --> 00:19:41.100
So if you took the myLayer.position
statement and put it one line above,

00:19:41.230 --> 00:19:43.500
then it would use the
default one second value,

00:19:43.630 --> 00:19:45.100
not the two second value.

00:19:45.240 --> 00:19:46.930
And of course,
the advantage of that is you can

00:19:46.930 --> 00:19:53.210
apply implicit animations using
different CA transactions values.

00:19:53.800 --> 00:19:55.460
So what sorts of things can be animated?

00:19:55.460 --> 00:19:59.150
I'll come back and talk about
CA Transaction a bit more as we proceed.

00:19:59.160 --> 00:20:01.380
What are the sorts of
things that can be animated?

00:20:01.380 --> 00:20:05.170
Now, I've used position a lot because,
as I said, it's the kind of hollow

00:20:05.180 --> 00:20:06.620
world of programming.

00:20:06.620 --> 00:20:10.280
But how many of you have ever shipped
in your application factorial?

00:20:10.280 --> 00:20:11.730
I'm sure none.

00:20:11.740 --> 00:20:14.340
But that's just the hollow world.

00:20:14.380 --> 00:20:17.560
Now, of course, you will be repositioning
objects in your applications.

00:20:17.560 --> 00:20:20.220
But remember that many other
sorts of things can be animated.

00:20:20.680 --> 00:20:23.920
And I've just put together a composite
of a few of these to give you an idea.

00:20:23.920 --> 00:20:26.480
So, for example, opacity,
which we've seen.

00:20:26.480 --> 00:20:30.840
You can change size, position,
which we've talked about.

00:20:30.840 --> 00:20:31.680
Nice one.

00:20:31.680 --> 00:20:33.280
There's a nice rotational flip.

00:20:33.440 --> 00:20:37.280
Shape is a fun one that you can
animate and even color change.

00:20:37.300 --> 00:20:40.300
And if you look at the
documentation on a CA layer,

00:20:40.300 --> 00:20:44.390
you'll see listed next to the various
properties the term animatable.

00:20:44.400 --> 00:20:48.790
And that's your clue that that
particular property has interpolated

00:20:48.790 --> 00:20:50.650
points that can be computed for you.

00:20:50.660 --> 00:20:56.270
All the implicit animations that
you apply are done together in the

00:20:56.270 --> 00:20:59.220
next invocation of the run loop.

00:20:59.340 --> 00:21:01.370
So after your method's called,
it goes back to the run loop.

00:21:01.460 --> 00:21:03.540
They're all applied as
a single transaction.

00:21:03.540 --> 00:21:06.620
The CA transaction class
will let you control not just

00:21:06.730 --> 00:21:08.960
duration but the timing function.

00:21:08.960 --> 00:21:11.440
That is the type of
animation you want to do.

00:21:11.440 --> 00:21:14.890
And a few more which we'll get
to in part two of the talk.

00:21:14.970 --> 00:21:18.120
And as I've said,
the CA transaction properties

00:21:18.120 --> 00:21:19.800
are applied at the time.

00:21:19.920 --> 00:21:20.660
The implicit animation.

00:21:20.660 --> 00:21:23.180
The implicit animation is created.

00:21:23.540 --> 00:21:26.380
Sometimes you don't want an animation.

00:21:26.380 --> 00:21:29.280
So for example,
if you have a gesture recognizer

00:21:29.280 --> 00:21:32.830
that's -- and the user is moving
an object around the screen,

00:21:33.140 --> 00:21:35.370
you don't want to lag while
the animation animates.

00:21:35.380 --> 00:21:38.250
The point, you want that to be applied
as fast as possible.

00:21:38.340 --> 00:21:42.990
So the way you do that is by calling
the CA transaction class method called

00:21:42.990 --> 00:21:46.060
setDisableActions with the parameter yes.

00:21:46.210 --> 00:21:49.280
And a little gotcha -- or it's
got me anyway -- is there's also

00:21:49.280 --> 00:21:50.580
a method called disableActions.

00:21:50.580 --> 00:21:52.980
And that's not a verb.

00:21:52.980 --> 00:21:56.900
That will just tell you what the
current value of that property is.

00:21:56.900 --> 00:22:00.380
So just remember you have to
say setDisable to yes or no.

00:22:00.630 --> 00:22:04.290
Now, when you set that,
it only applies for the next run loop.

00:22:04.430 --> 00:22:07.340
So if you want to have that
sort of in effect all the time,

00:22:07.340 --> 00:22:10.010
you have to call it again
when you do it again.

00:22:10.570 --> 00:22:13.500
So to understand implicit animation,
I thought I'd go inside

00:22:13.500 --> 00:22:15.000
the mind of Core Animation.

00:22:15.000 --> 00:22:16.800
Remember I showed that
little blobby brain there.

00:22:16.800 --> 00:22:18.560
So we're looking inside
this brain a little bit.

00:22:18.620 --> 00:22:20.700
What's happening behind the scene now?

00:22:20.750 --> 00:22:23.150
This is something that you're
very unlikely to have to

00:22:23.150 --> 00:22:25.800
do in your applications,
but it's helpful to understand

00:22:25.800 --> 00:22:28.840
what's happening when you do an
implicit animation because it can

00:22:28.940 --> 00:22:31.780
help you solve other problems,
which I hope to demonstrate

00:22:31.780 --> 00:22:33.300
in the next couple of slides.

00:22:33.350 --> 00:22:36.400
So there's a protocol
called CA Action Protocol,

00:22:36.410 --> 00:22:42.500
and it deals with actions which are
objects that can respond to events.

00:22:42.510 --> 00:22:46.600
And typically,
a typical kind of action is CA Animation,

00:22:46.600 --> 00:22:48.710
which implements the action protocol.

00:22:48.940 --> 00:22:51.790
And the basic method of
CA Action Protocol is

00:22:51.930 --> 00:22:54.330
to execute an action.

00:22:54.810 --> 00:22:58.200
And if an action is found when you
do an implicit property change,

00:22:58.310 --> 00:23:03.660
then it's added to that layer behind
the scenes using add animation for key.

00:23:03.660 --> 00:23:04.890
So let's go through this a bit.

00:23:04.900 --> 00:23:07.670
So imagine you have a layer
and some property gets set.

00:23:07.760 --> 00:23:11.500
Well, what the setter code,
the default implementation of the setter

00:23:11.620 --> 00:23:15.980
code will do is send action for key to
a delegate if that layer has a delegate.

00:23:15.980 --> 00:23:18.220
And that may or may not return an action.

00:23:18.220 --> 00:23:23.170
If there's no delegate or it returns nil,
then the setter will then look

00:23:23.170 --> 00:23:27.240
up in the action dictionary,
which is a property of CA layer.

00:23:27.410 --> 00:23:29.880
And again, that may return nil.

00:23:29.880 --> 00:23:33.360
A couple more steps and finally
it'll call the CA layer's

00:23:33.360 --> 00:23:35.060
default action for key.

00:23:35.060 --> 00:23:38.300
And these are, of course,
implemented in the framework for

00:23:38.490 --> 00:23:40.510
all the animatable properties.

00:23:40.520 --> 00:23:45.420
And when that action is returned,
it's then added to the layer.

00:23:47.090 --> 00:23:52.160
as an animation where the key that's used
is a key value that corresponds to the

00:23:52.160 --> 00:23:53.890
particular property that you've changed.

00:23:55.430 --> 00:23:58.390
And we'll come back to this
slide in a few seconds.

00:23:58.400 --> 00:24:01.650
You'll see how useful it is to understand
that little sequence of events.

00:24:01.650 --> 00:24:04.090
But I just want to
reiterate that in your code,

00:24:04.130 --> 00:24:06.740
you're unlikely to have to worry
about the CA Action Protocol.

00:24:06.740 --> 00:24:10.280
Okay, so let's move on now
to explicit animation.

00:24:10.370 --> 00:24:15.220
It's a more complex class hierarchy here.

00:24:15.220 --> 00:24:18.080
In this case,
CA Animation is an abstract class.

00:24:18.080 --> 00:24:21.400
In practice, you instantiate one of
the three leaves here.

00:24:21.400 --> 00:24:25.580
The CA Animation Group,
CA Basic Animation,

00:24:25.750 --> 00:24:28.450
or CA Keyframe Animation.

00:24:28.580 --> 00:24:32.510
And I'm going to go back to my
Hello World example to illustrate

00:24:32.510 --> 00:24:34.440
how you do this in practice.

00:24:34.540 --> 00:24:38.710
Now, I just want to point out again that
I've already showed you how to drop

00:24:38.780 --> 00:24:42.700
a ball using implicit animation,
and that was one line of code.

00:24:42.740 --> 00:24:45.320
It's maybe two if you want
to change the duration.

00:24:45.370 --> 00:24:48.780
So, you know, generally,
why write five lines of code when

00:24:48.790 --> 00:24:50.790
you can write one line of code?

00:24:50.920 --> 00:24:53.820
So, in practice,
you probably wouldn't do this particular

00:24:53.880 --> 00:24:55.600
action with a basic animation.

00:24:55.670 --> 00:24:58.370
But pedagogically, that is,
when I try and explain it,

00:24:58.430 --> 00:25:00.780
it's a nice example because
it's easy to understand.

00:25:00.930 --> 00:25:03.280
So,
that's the effect that I want to achieve.

00:25:03.560 --> 00:25:05.300
Not implicitly, this time explicitly.

00:25:05.400 --> 00:25:09.700
So, what I do is make an instance
of the CA Basic Animation class,

00:25:09.960 --> 00:25:14.630
and I set the position.y as my key path.

00:25:14.790 --> 00:25:17.500
So,
that's a key path that corresponds to the

00:25:17.500 --> 00:25:20.020
y coordinate of the position property.

00:25:20.200 --> 00:25:23.680
of the layer to be animated.

00:25:23.980 --> 00:25:26.800
Of course, you can apply the same
animation to several layers.

00:25:26.800 --> 00:25:30.920
And remember I said that an
animation has a from value,

00:25:31.010 --> 00:25:32.860
a to value, and interpolated points.

00:25:32.980 --> 00:25:35.620
Now with basic animation,
all you do is set the from

00:25:35.750 --> 00:25:38.600
value and the to value,
and the framework will work

00:25:38.600 --> 00:25:40.460
out the interpolated points.

00:25:40.540 --> 00:25:44.380
And now instead of using CA transaction
for the animation duration,

00:25:44.380 --> 00:25:47.150
we explicitly say that we
want the duration of this

00:25:47.150 --> 00:25:49.060
animation to be five seconds.

00:25:50.230 --> 00:25:56.060
We add that drop animation to
the layer and the key property

00:25:56.060 --> 00:25:58.960
I don't need to fill in,
so I'll set that to nil.

00:25:58.960 --> 00:26:03.160
And we'll see how we can make
different use of that later on.

00:26:03.160 --> 00:26:06.230
Now, so that example will
achieve what you want,

00:26:06.240 --> 00:26:08.820
except that in reality,
if you took exactly that bit of

00:26:08.820 --> 00:26:11.980
code and stuck it into your project,
what you'd actually see is that.

00:26:11.980 --> 00:26:15.240
And not quite probably what you expected.

00:26:15.240 --> 00:26:16.880
Now, why did that happen?

00:26:16.880 --> 00:26:20.120
Well, it happened because,
and this is important.

00:26:20.120 --> 00:26:25.620
Explicit animations do not affect the
model values of your layer hierarchy.

00:26:25.620 --> 00:26:29.360
They create animations,
but they leave your model unchanged.

00:26:29.420 --> 00:26:31.850
And I'll come back to
this point a few times.

00:26:31.900 --> 00:26:35.290
Now, this is great because it means you
can do all sorts of flying things,

00:26:35.290 --> 00:26:37.830
it was around the screen and move
and follow gestures and so on.

00:26:37.840 --> 00:26:39.550
And at the end of the day,
you haven't changed

00:26:39.650 --> 00:26:41.990
anything in your model,
which is most often what you want.

00:26:42.040 --> 00:26:45.140
But it can be irritating when you
hit this little effect and say,

00:26:45.140 --> 00:26:46.640
what the heck's going on?

00:26:46.640 --> 00:26:49.380
So we want to change the model value.

00:26:49.380 --> 00:26:50.120
So we do that.

00:26:50.120 --> 00:26:53.470
We do that by setting the position
to a new value at the bottom of

00:26:53.470 --> 00:26:55.460
the screen as highlighted there.

00:26:55.460 --> 00:26:58.300
And then as before,
we create the drop animation.

00:26:58.340 --> 00:27:01.770
But we now are armed with the knowledge
from a couple of slides back of

00:27:01.850 --> 00:27:03.940
what's happening behind the scenes.

00:27:03.940 --> 00:27:07.410
And if you remember what I said is that
when you set a property implicitly,

00:27:07.780 --> 00:27:10.120
there's a little bit of work
to go and retrieve an action

00:27:10.120 --> 00:27:11.840
and then add it to the layer.

00:27:11.840 --> 00:27:14.290
And furthermore,
it's added using a key that corresponds

00:27:14.290 --> 00:27:15.980
to the property that you've changed.

00:27:15.980 --> 00:27:17.380
In this case, position.

00:27:17.650 --> 00:27:18.440
So.

00:27:18.440 --> 00:27:20.120
By using the key parameter.

00:27:20.120 --> 00:27:22.070
And by using the key parameter,
we can now change the animation.

00:27:22.180 --> 00:27:24.230
And in the last call,
we effectively cancel the

00:27:24.230 --> 00:27:27.120
animation that was scheduled
by the implicit model change.

00:27:27.120 --> 00:27:30.100
And doing those two steps together
will mean that the ball will drop

00:27:30.100 --> 00:27:31.640
and the model will be changed.

00:27:33.470 --> 00:27:38.080
Now, if you don't want just these
default interpolated points,

00:27:38.160 --> 00:27:39.980
a linear interpolation
from start to finish,

00:27:40.090 --> 00:27:42.730
then you use keyframe animations.

00:27:42.850 --> 00:27:45.250
And so here the picture
is a bit more complicated.

00:27:45.450 --> 00:27:48.350
So the keyframes are a bunch of
points that you can set in two

00:27:48.350 --> 00:27:50.400
ways that I'll explain in a second.

00:27:50.490 --> 00:27:55.020
And you leave it up to the framework to
compute the interpolated points using

00:27:55.030 --> 00:27:58.190
basically three different techniques.

00:27:59.270 --> 00:28:01.040
So how do you set up keyframe animations?

00:28:01.140 --> 00:28:05.320
Well, a keyframe animation class uses
either a path or a value of path.

00:28:05.420 --> 00:28:06.320
There's a CG path.

00:28:06.390 --> 00:28:09.510
And if you use the path property,
then the control points of the

00:28:09.610 --> 00:28:11.270
path will be used as the keyframes.

00:28:11.270 --> 00:28:14.430
Or you can explicitly set
a whole bunch of values.

00:28:14.430 --> 00:28:18.220
And there's an optional flag, key times,
which lets you override

00:28:18.220 --> 00:28:19.640
the default timing.

00:28:19.640 --> 00:28:21.390
The default timing, I think, is linear.

00:28:21.390 --> 00:28:23.140
So this will let you change the timing.

00:28:23.140 --> 00:28:26.450
So you can have a long delay before
going to the first keyframe and

00:28:26.450 --> 00:28:28.320
then very short to the next one.

00:28:28.320 --> 00:28:32.000
And these are numbers that go from
zero to one fraction of the total

00:28:32.010 --> 00:28:33.740
time for each keyframe segment.

00:28:33.740 --> 00:28:36.990
And the interpolation is
either long values or the path.

00:28:37.020 --> 00:28:40.230
And as I said,
three different interpolations.

00:28:40.330 --> 00:28:42.960
Linear, which is what you think,
a straight line interpretation.

00:28:42.960 --> 00:28:44.650
Discrete means no interpolation.

00:28:44.650 --> 00:28:46.380
Just go from keyframe to keyframe.

00:28:46.380 --> 00:28:50.550
And cubic fits a nice,
busier path to the keyframes.

00:28:51.300 --> 00:28:53.580
And then finally,
the last part of that class

00:28:53.580 --> 00:28:56.520
hierarchy was group animations,
which is a collection of

00:28:56.520 --> 00:28:58.490
animations applied simultaneously.

00:28:58.590 --> 00:29:02.370
And the timing is clipped
to the group timing.

00:29:02.380 --> 00:29:05.080
So however long the animations
within the group are,

00:29:05.080 --> 00:29:07.600
the overall animation will
just last as long as the

00:29:07.600 --> 00:29:09.360
duration property of the group.

00:29:09.420 --> 00:29:11.500
Very easy to do.

00:29:11.500 --> 00:29:14.610
You create a whole bunch of animations.

00:29:14.700 --> 00:29:18.150
You then instantiate a group animation.

00:29:18.290 --> 00:29:22.340
And you set its animations properties
to be an array of your animations.

00:29:22.340 --> 00:29:25.760
And then when you add them,
you set some duration for the group.

00:29:25.890 --> 00:29:29.160
When you add that to the class,
all the animations will be applied

00:29:29.160 --> 00:29:30.800
at the same time in the group.

00:29:33.240 --> 00:29:38.210
Tim, so we have a demo that try to put
all these concepts together for you.

00:29:53.030 --> 00:29:53.720
Thanks, Tim.

00:29:53.730 --> 00:30:03.750
I just want to apologize for
implanting that little sound meme,

00:30:03.750 --> 00:30:05.800
because you'll be humming
that for the rest of the day,

00:30:05.800 --> 00:30:06.970
and my apologies for that.

00:30:07.090 --> 00:30:08.780
But we chose that example.

00:30:08.780 --> 00:30:11.390
It's somewhat bogus and made up,
but we chose it because what

00:30:11.450 --> 00:30:14.280
I want to do is just walk through
some of the code snippets that

00:30:14.280 --> 00:30:16.960
we used to put that together,
just to see how to put these three

00:30:17.110 --> 00:30:19.120
types of explicit animations together.

00:30:20.830 --> 00:30:24.620
So, now,
I made the song using GarageBand.

00:30:24.620 --> 00:30:28.660
I used some synthesizers and some MIDI,
so pretty straightforward.

00:30:28.660 --> 00:30:33.120
And the nice thing about using GarageBand
is I could set the tempo explicitly,

00:30:33.120 --> 00:30:36.250
so I set it to 150
quarter notes per minute.

00:30:36.270 --> 00:30:37.520
It's in 4-4 time.

00:30:37.520 --> 00:30:41.090
I'm not much of a musician,
but I knew enough to be able to do that.

00:30:41.200 --> 00:30:48.980
And so the bouncing ball itself,
we just did with a position animation.

00:30:50.560 --> 00:30:53.050
And, as I have to confess, now,
you could compute these,

00:30:53.050 --> 00:30:54.530
and that would be the right way to do it.

00:30:54.840 --> 00:30:57.440
For the purpose of this demo, we just,
you know,

00:30:57.440 --> 00:31:01.120
touch points and just recorded them
and then stored that all in an array,

00:31:01.120 --> 00:31:02.400
so a bit of a cheat to do that.

00:31:02.550 --> 00:31:06.130
In general, if you have arbitrary music,
of course, you have to do some font

00:31:06.190 --> 00:31:09.200
metrics and figure out where
all the beats are and so on.

00:31:09.200 --> 00:31:10.190
It's a bit more complicated.

00:31:10.200 --> 00:31:14.280
And then we set the duration to be the
number of notes divided by the tempo,

00:31:14.280 --> 00:31:17.690
convert that into second,
because the tempo's in minutes.

00:31:17.800 --> 00:31:20.340
And, oh, yeah, this is lying a bit.

00:31:20.340 --> 00:31:23.460
We started with cubic spline,
but you couldn't really see the

00:31:23.460 --> 00:31:26.100
bounce points very well because
it was rounding all the corners.

00:31:26.100 --> 00:31:29.460
So in the demo, I actually changed it
to linear interpolation,

00:31:29.470 --> 00:31:33.020
so you get a more pointy appearance,
and it's more clear when

00:31:33.020 --> 00:31:34.630
the ball hits the words.

00:31:37.120 --> 00:31:40.580
And then for the opacity animation,
this was a bit more complicated.

00:31:40.580 --> 00:31:42.500
In this case,
what we want to do is when the ball,

00:31:42.500 --> 00:31:44.590
I don't know if you saw this,
but when the ball got

00:31:44.590 --> 00:31:47.050
to the end of the line,
it sort of faded away and then moved

00:31:47.050 --> 00:31:48.660
to the left and then reappeared.

00:31:48.880 --> 00:31:54.220
So we had to set an animation that
went from one to zero and back again.

00:31:54.220 --> 00:31:57.910
And so we did that with
an opacity animation.

00:31:57.920 --> 00:32:00.890
And there's a little bit more
complication to work out.

00:32:00.890 --> 00:32:05.210
We knew that each line had, I don't know,
four beats, two measures, I think.

00:32:05.270 --> 00:32:07.080
Anyway, all the calculation done.

00:32:07.100 --> 00:32:11.370
And once that's done, we used,
in this case,

00:32:11.400 --> 00:32:16.540
used the values array for when
the opacity change would occur,

00:32:16.540 --> 00:32:19.480
but the key times to
control the timing of that.

00:32:21.210 --> 00:32:23.400
And then finally,
just to illustrate that,

00:32:23.460 --> 00:32:24.290
I stick them in a group.

00:32:24.360 --> 00:32:25.940
Now, we didn't have to do this.

00:32:26.150 --> 00:32:27.800
We created a group.

00:32:28.000 --> 00:32:31.520
We set the animations of the
groups to be bounce and opacity.

00:32:31.590 --> 00:32:35.090
We set the duration to be the same as
the bounce duration because it used

00:32:35.170 --> 00:32:39.120
the tempo and the number of notes to
compute the length of the whole song.

00:32:39.260 --> 00:32:40.300
And then added it.

00:32:40.300 --> 00:32:42.430
This is really more of a convenience.

00:32:42.430 --> 00:32:45.480
We could have explicitly just
added those two animations,

00:32:45.480 --> 00:32:48.330
but sometimes it's handy to
have them all in a group.

00:32:48.470 --> 00:32:50.640
So, for example,
if you want to cancel all your

00:32:50.640 --> 00:32:54.030
animations and you have them in a group,
it's very easy to do that.

00:32:55.540 --> 00:32:58.860
Okay,
so that's what happened with that demo.

00:32:58.960 --> 00:33:00.280
So let me just summarize this.

00:33:00.350 --> 00:33:03.400
This is the end of part one, if you like,
introduction to Core Animation.

00:33:03.510 --> 00:33:06.420
Let me just summarize what we've covered.

00:33:06.420 --> 00:33:10.500
So we use CA layers for content
with a declarative style.

00:33:10.500 --> 00:33:12.590
That means that when you
change layer property,

00:33:12.590 --> 00:33:15.140
a whole bunch of work will
happen in the background for you,

00:33:15.140 --> 00:33:18.330
almost always giving you exactly
the beautiful effect that you want.

00:33:18.390 --> 00:33:22.160
If you want to start modifying
the default properties,

00:33:22.160 --> 00:33:24.890
you can using the CA transaction class.

00:33:25.500 --> 00:33:29.660
If you want to get even more fancy,
then you use explicit animations

00:33:29.660 --> 00:33:33.550
of which there are three types:
CA Basic Animation,

00:33:33.770 --> 00:33:38.500
CA Keyframe Animation,
and CA Group Animation.

00:33:39.420 --> 00:33:40.940
All right, so now talk number two.

00:33:40.940 --> 00:33:44.410
Now what I'm going to do here,
it may feel a little bit spotty,

00:33:44.410 --> 00:33:46.760
I apologize for that,
but we try to pick topics that we

00:33:46.760 --> 00:33:49.930
think will really give you a good
sort of overview of the more advanced

00:33:49.930 --> 00:33:51.870
stuff that you might have to deal with.

00:33:51.960 --> 00:33:55.130
There's more and I'd love to
have been able to cover it,

00:33:55.180 --> 00:33:58.660
but it's just impossible in the
hour that we had to do this.

00:33:58.780 --> 00:34:02.900
So we try to pick topics that we
thought were the essential topics,

00:34:02.900 --> 00:34:08.040
and the first one of which
will be shown in the demo,

00:34:08.040 --> 00:34:09.480
which is Perspective Transform.

00:34:09.480 --> 00:34:12.460
And now Tim's going to do
a whole bunch of things,

00:34:12.460 --> 00:34:16.000
and I'll just sort of give
some narrative as he do this.

00:34:16.080 --> 00:34:19.680
So here we have five layers
with background colors

00:34:19.680 --> 00:34:23.780
and some numbers in them,
and we move closer to them.

00:34:23.780 --> 00:34:25.850
But now notice what happens.

00:34:25.930 --> 00:34:28.680
Now when we rotate around,
we can see that there's perspective.

00:34:28.910 --> 00:34:29.940
Perspective has been applied.

00:34:29.940 --> 00:34:33.420
So the number one, for example,
is tapering off to infinity,

00:34:33.510 --> 00:34:36.080
and number two is
expanding out towards you,

00:34:36.160 --> 00:34:37.900
so it gives the user a sense of depth.

00:34:39.300 --> 00:34:40.890
Now, in fact,
I said there were five layers.

00:34:40.990 --> 00:34:44.350
There's actually a sixth
layer which we can expose,

00:34:44.350 --> 00:34:48.980
and we do that by changing something I'll
talk about a bit called the Z position.

00:34:48.980 --> 00:34:51.990
And to show you the sorts
of things you can achieve,

00:34:52.090 --> 00:34:56.410
I assume that's what Tim's about to do,
we just close this little box.

00:34:56.420 --> 00:35:00.510
Now, it turned out to be relatively
simple to achieve that.

00:35:00.600 --> 00:35:05.160
The key was making sure the anchor
points of the layers that were going

00:35:05.160 --> 00:35:09.200
to take part in closing the box,
you know, the back one just sits there,

00:35:09.200 --> 00:35:12.000
but the ones on the sides and the
ones on the top move up and down.

00:35:12.000 --> 00:35:16.380
And the key idea there was to put the
anchor points on the axes of rotation

00:35:16.380 --> 00:35:21.160
that we were going to use and then
do a rotation around those axes.

00:35:21.160 --> 00:35:22.920
And that really was all.

00:35:22.920 --> 00:35:25.860
The lid, number five, that was simple.

00:35:25.860 --> 00:35:28.550
That was just a matter of moving
it into the right Z position.

00:35:28.620 --> 00:35:30.990
All these layers are identical size.

00:35:32.970 --> 00:35:34.260
And we can open the box.

00:35:34.460 --> 00:35:36.630
So again,
just the anchor point on number five

00:35:36.700 --> 00:35:39.640
and do that rotation by pi by two.

00:35:39.640 --> 00:35:43.960
But the nice thing about this is you can
see that you're getting another important

00:35:44.020 --> 00:35:49.520
part of three-dimensional effect,
which is that the bits of the layers

00:35:50.190 --> 00:35:54.550
that should be occluded from vision are.

00:35:54.560 --> 00:35:59.600
So you can only see part of number six
unless Tim happened to rotate around.

00:36:00.940 --> 00:36:02.860
And there you can see all of six.

00:36:03.100 --> 00:36:05.890
So now this is all achieved.

00:36:05.950 --> 00:36:07.800
Why is it called a two and a half D?

00:36:07.800 --> 00:36:13.700
It's called that because this is all
achieved just using these a Z position,

00:36:13.700 --> 00:36:16.800
which we'll get into plus a
certain perspective transform.

00:36:16.800 --> 00:36:19.430
But the objects themselves,
the layer CIL objects

00:36:19.500 --> 00:36:21.270
are not full 3D objects.

00:36:21.280 --> 00:36:22.890
So unlike OpenGL.

00:36:23.170 --> 00:36:25.150
So that's why it's called
a two and a half D model.

00:36:25.160 --> 00:36:26.770
Do you have more to show us?

00:36:26.960 --> 00:36:28.480
Okay.

00:36:28.480 --> 00:36:30.320
So putting the back box back in order.

00:36:38.400 --> 00:36:40.840
Okay, so let me just go into this
a little bit more detail.

00:36:40.840 --> 00:36:42.850
So let's suppose we're
going to add three layers.

00:36:42.960 --> 00:36:47.120
So I'll add a blue layer, a green layer,
and a gray layer.

00:36:47.120 --> 00:36:50.210
Now, if I change these,
so there's this Z position,

00:36:50.310 --> 00:36:54.360
which we've mentioned the default
value for the Z position is zero.

00:36:54.360 --> 00:36:57.320
And if you're doing a
just straightforward 2D

00:36:57.430 --> 00:37:00.700
application of Core Animation,
you won't ever worry

00:37:00.700 --> 00:37:02.270
about the Z position.

00:37:02.300 --> 00:37:03.050
We can change it.

00:37:03.100 --> 00:37:04.560
So here I've set it to 500.

00:37:04.560 --> 00:37:07.940
Remember, the Z axis comes directly
towards the viewer.

00:37:08.420 --> 00:37:10.460
And therefore, that layer,
which was in between

00:37:10.460 --> 00:37:12.350
the blue and the gray,
pops to the front.

00:37:12.400 --> 00:37:15.370
But notice that it
didn't change its size.

00:37:15.370 --> 00:37:19.060
And that's because in that demo,
I have not yet applied

00:37:19.060 --> 00:37:20.680
any perspective transform.

00:37:20.680 --> 00:37:25.430
So merely changing the Z position
will not give you any perspective.

00:37:25.500 --> 00:37:29.360
How you get the perspective is
by using a property called the

00:37:29.360 --> 00:37:31.640
sublayer transform property.

00:37:31.640 --> 00:37:34.480
And you apply it to the parent layer.

00:37:34.480 --> 00:37:38.280
So all the sublayers of that parent,
which has a sublayer transform property,

00:37:38.280 --> 00:37:38.280
will be applied to the parent layer.

00:37:38.280 --> 00:37:41.170
And then the sublayer transform
property set will have an appropriate

00:37:41.300 --> 00:37:43.340
perspective transform applied to them.

00:37:43.340 --> 00:37:47.400
The type of transform used is called
a homogeneous perspective transform.

00:37:47.400 --> 00:37:50.240
And obviously, I'm not going to give you
a math lesson right now,

00:37:50.240 --> 00:37:53.320
but if you enter that as a
search term in any search engine,

00:37:53.320 --> 00:37:55.020
you'll get lots of good
references on that.

00:37:55.020 --> 00:37:56.300
It's very commonly used.

00:37:56.380 --> 00:38:02.860
All you have to do as an app developer
is really this next line over here,

00:38:02.860 --> 00:38:08.060
which is you want to set the distance
of the viewer's eye or the camera,

00:38:08.300 --> 00:38:10.870
if you like,
at some distance from the origin of

00:38:10.870 --> 00:38:12.700
the Z coordinate along the Z axis.

00:38:12.700 --> 00:38:13.980
And you do it with that statement.

00:38:14.110 --> 00:38:18.870
So the thing IZ that you see there,
that's just a constant

00:38:18.940 --> 00:38:20.010
that you've set somewhere.

00:38:20.040 --> 00:38:21.430
So it's just a floating point number.

00:38:21.460 --> 00:38:26.350
And it represents the distance of the
viewer's eye from the origin of the Z.

00:38:26.360 --> 00:38:28.630
So if you set it at zero,
your face would be right

00:38:28.630 --> 00:38:29.970
on the device like that.

00:38:30.060 --> 00:38:34.160
And as it increases, the device,
you know, the apparent view of the object

00:38:34.620 --> 00:38:35.880
gets further and further away.

00:38:35.880 --> 00:38:40.500
And of course, that transform,
can be composed with other transforms

00:38:40.500 --> 00:38:43.460
so you can get the sorts of rotational
effects that you're looking at

00:38:43.590 --> 00:38:45.120
simply by doing a composition.

00:38:45.120 --> 00:38:47.340
In this case,
just doing a straightforward perspective.

00:38:47.340 --> 00:38:51.020
And now let's see what effect
that has on the same example,

00:38:51.020 --> 00:38:55.640
except that we'll now use the Z position,
assuming that that sublayer

00:38:55.790 --> 00:38:57.530
transform's already been set.

00:38:57.680 --> 00:39:00.400
So firstly, I'll add the blue sublayer.

00:39:00.400 --> 00:39:02.410
It looks like nothing's happened.

00:39:02.420 --> 00:39:03.420
You can't tell yet.

00:39:03.540 --> 00:39:05.760
But notice when I add the
green layer where I haven't

00:39:05.760 --> 00:39:09.220
explicitly set the Z position,
it looks bigger.

00:39:09.220 --> 00:39:11.880
And that's because this
perspective's been applied.

00:39:12.180 --> 00:39:16.640
And similarly, if I set the Z position
of the gray layer to 100,

00:39:16.640 --> 00:39:18.780
it will appear to be in front.

00:39:18.780 --> 00:39:21.900
And now it starts to,
you can see why this is starting

00:39:21.900 --> 00:39:25.120
to look like a sort of cover
flow or Time Machine has this,

00:39:25.350 --> 00:39:27.120
exactly this kind of
perspective transform.

00:39:27.120 --> 00:39:29.740
Of course, they're also,
the viewing perspective is

00:39:30.170 --> 00:39:32.180
changed a little bit because
you're slightly to the left.

00:39:32.270 --> 00:39:34.280
Otherwise, you just see the gray layer.

00:39:34.400 --> 00:39:38.200
So that's why I say you can
compose these transforms.

00:39:38.200 --> 00:39:39.670
poems.

00:39:40.940 --> 00:39:42.590
What happens if layers overlap?

00:39:42.720 --> 00:39:45.520
Well, it's supported,
but there are some gotchas.

00:39:45.520 --> 00:39:48.240
It's a lot of extra
work for the renderer.

00:39:48.440 --> 00:39:49.750
They're rendered more than once.

00:39:49.750 --> 00:39:51.860
Now,
it works by using a depth sorting and

00:39:52.130 --> 00:39:56.520
using the layer bounds and position to
determine what's occluded and what's not.

00:39:56.570 --> 00:40:01.170
And if some of your sublayers don't
fit within the bounds of their parents,

00:40:01.170 --> 00:40:03.880
it won't always get the rendering right.

00:40:03.960 --> 00:40:05.620
So use with care.

00:40:05.620 --> 00:40:07.760
As I said, it's not a full 3D model.

00:40:07.760 --> 00:40:10.780
It's a 2.5D model,
but I hope the cube example that

00:40:10.780 --> 00:40:10.780
you're seeing here is a 2.5D model.

00:40:10.850 --> 00:40:11.980
At least it's convinced you that.

00:40:12.350 --> 00:40:13.900
Nevertheless, there's lots you can do.

00:40:13.900 --> 00:40:16.390
Okay, another topic,
which is an interesting one,

00:40:16.390 --> 00:40:17.820
notifications and timing.

00:40:17.820 --> 00:40:20.350
So how long do animations last?

00:40:20.350 --> 00:40:23.080
How do you get a whole bunch
of animations to work in

00:40:23.080 --> 00:40:24.960
coordination with each other?

00:40:24.960 --> 00:40:27.210
What happens when they stop and so on?

00:40:27.300 --> 00:40:29.240
So I'm just going to cover
those in a couple of slides.

00:40:31.530 --> 00:40:33.940
And they all use the
CA Media Timing Protocol,

00:40:33.940 --> 00:40:37.200
which is adopted both by
CA Animation and CA Layer.

00:40:37.200 --> 00:40:40.980
And the typical properties,
I'll talk about begin time in a second,

00:40:40.980 --> 00:40:42.840
repeat count, repeat duration.

00:40:42.840 --> 00:40:45.720
Now, you use one or the other.

00:40:45.720 --> 00:40:48.680
If you use overall duration
and repeat duration,

00:40:48.680 --> 00:40:52.450
then it'll figure out how
many repeats there are.

00:40:52.460 --> 00:40:54.300
But the idea of repeat count is,
for example,

00:40:54.300 --> 00:40:56.640
with the bouncing ball example,
the moving the ball,

00:40:56.640 --> 00:41:00.520
if I added a repeat count of 10,
then it would go up and down 10 times.

00:41:01.400 --> 00:41:03.490
There's a duration,
which is how long it lasts,

00:41:03.580 --> 00:41:05.800
and an auto-reverse,
which is handy if you're doing

00:41:05.800 --> 00:41:09.500
some complex keyframe animation,
or a flip transform, for example,

00:41:09.500 --> 00:41:12.740
because it'll reverse along
exactly the same path that got

00:41:12.830 --> 00:41:14.690
it there in the first place.

00:41:14.700 --> 00:41:19.130
And finally, fill mode,
which I will explain when I go through

00:41:19.250 --> 00:41:21.610
another example a bit later on.

00:41:21.620 --> 00:41:25.400
Now, in terms of notifications,
there are two mechanisms you use.

00:41:25.420 --> 00:41:30.500
If you've created explicit animations
and the animation has a... You've

00:41:30.560 --> 00:41:35.050
set the delegate of the animation,
then the delegate can implement animation

00:41:35.050 --> 00:41:37.580
did start and animation did stop.

00:41:37.680 --> 00:41:39.550
And they'll do exactly what you think.

00:41:39.620 --> 00:41:42.360
When the animation starts,
the first one will be called.

00:41:42.360 --> 00:41:45.160
And when animation did stop,
the second one will get called.

00:41:45.160 --> 00:41:49.760
The finished flag will tell you
if the animation came to a safe,

00:41:49.900 --> 00:41:52.720
normal end of life or was
somehow violently disrupted

00:41:52.820 --> 00:41:55.350
for completing because,
for example, it was removed or

00:41:55.350 --> 00:41:56.800
canceled for some reason.

00:41:56.800 --> 00:41:58.900
So you can use that
flag for that purpose.

00:42:00.360 --> 00:42:03.440
If you're using implicit animations,
you can use completion block,

00:42:03.540 --> 00:42:05.360
which were introduced in iOS 4.

00:42:05.360 --> 00:42:09.390
Of course, I think they've been on
OS X a bit longer than that.

00:42:09.460 --> 00:42:13.040
So here's an example where I'm
doing two implicit animations,

00:42:13.040 --> 00:42:15.380
setting the opacity to
zero and the position,

00:42:15.380 --> 00:42:19.840
and I'm setting a completion block,
and in this case, it's disabling actions

00:42:19.840 --> 00:42:22.580
and removing the layers,
doing some cleanup work.

00:42:22.640 --> 00:42:24.450
Now, remember the important point.

00:42:24.820 --> 00:42:29.520
You must call that before you change the
implicit properties because otherwise

00:42:29.580 --> 00:42:32.350
the default block handler will be called,
and the default block

00:42:32.350 --> 00:42:33.230
handler does nothing.

00:42:33.240 --> 00:42:35.380
So remember to do that code first.

00:42:35.460 --> 00:42:38.580
Now, I've just got a general principle.

00:42:38.580 --> 00:42:41.150
It's tempting, and in fact,
when I started with this, I thought, oh,

00:42:41.150 --> 00:42:42.100
animation did stop.

00:42:42.180 --> 00:42:44.000
That's a very nice way
to chain things together.

00:42:44.000 --> 00:42:46.740
In fact, it's not the best way to do it.

00:42:46.740 --> 00:42:49.990
And in fact, best use of notification
is probably for setup and

00:42:50.110 --> 00:42:51.930
teardown if you need to do them.

00:42:51.940 --> 00:42:54.660
For timing, you can get much better
control using the CA.

00:42:54.740 --> 00:42:57.580
It's called the Media Timing Protocol,
and I want to illustrate

00:42:57.690 --> 00:42:58.580
that with this example.

00:42:58.580 --> 00:43:02.020
So I have three balloons in my
little Carnival application,

00:43:02.020 --> 00:43:05.740
and what I want to do is I want the
balloons to go up and down one by one.

00:43:05.740 --> 00:43:08.140
So this is the effect
that I want to achieve.

00:43:08.140 --> 00:43:10.670
So as the balloon drops,
the next one goes up,

00:43:10.670 --> 00:43:12.450
and I could have many of these.

00:43:12.500 --> 00:43:16.060
Now, I could do this by saying
animation did stop,

00:43:16.060 --> 00:43:18.620
but the trouble with that is
it happens during the run loop.

00:43:18.710 --> 00:43:21.420
It's not necessarily going
to happen immediately.

00:43:21.420 --> 00:43:23.970
There may be other code going on,
and it's also architecturally

00:43:24.020 --> 00:43:24.660
in my opinion.

00:43:24.660 --> 00:43:26.530
And I think it's a very
nice way to do things.

00:43:26.660 --> 00:43:28.660
So here's a much nicer way to do it.

00:43:28.660 --> 00:43:31.510
Now, there's a bit more to understand,
so this is also a good

00:43:31.510 --> 00:43:32.650
time to introduce that.

00:43:32.690 --> 00:43:34.610
So let's start with time.

00:43:34.800 --> 00:43:36.700
Now,
it turns out that every layer and every

00:43:36.700 --> 00:43:38.610
animation also has a time coordinate.

00:43:38.740 --> 00:43:41.660
So it's really a four-dimensional space,
if you like.

00:43:41.660 --> 00:43:45.270
So the first thing you have
to do is make sure that your

00:43:45.270 --> 00:43:47.630
layer is running in local time.

00:43:47.690 --> 00:43:50.560
And there's the statement
that does the conversion.

00:43:50.660 --> 00:43:54.510
I use a helper function
called CA current media time.

00:43:54.590 --> 00:43:57.580
To give me the, if you like,
the machine's clock time.

00:43:57.580 --> 00:44:00.140
I convert it using nil,
say globally convert

00:44:00.140 --> 00:44:01.430
it to this layer time.

00:44:01.760 --> 00:44:05.580
Now, I won't go into why there are
these different time coordinates.

00:44:05.580 --> 00:44:08.730
But just to say that you can,
part of your layer hierarchy can

00:44:08.830 --> 00:44:10.580
have different time parameters.

00:44:10.580 --> 00:44:13.070
So for example,
a subtree could be running twice

00:44:13.200 --> 00:44:14.580
as fast as everything else.

00:44:14.590 --> 00:44:16.550
And you can get some very
nice effects doing that.

00:44:16.590 --> 00:44:18.580
But I don't have time
to go into all of that.

00:44:18.580 --> 00:44:20.580
However, it is important to get
the right time zone,

00:44:20.580 --> 00:44:24.500
especially if you don't know for sure
what's happening above your layer.

00:44:24.500 --> 00:44:26.500
In the layer hierarchy.

00:44:26.500 --> 00:44:29.940
And then what I did with these
balloons is I'm going to animate the

00:44:29.940 --> 00:44:31.500
position using a basic animation.

00:44:31.500 --> 00:44:33.350
I'll make it auto-reverse.

00:44:33.550 --> 00:44:35.500
I'll do it for five seconds.

00:44:35.500 --> 00:44:38.450
And then I use the begin time property,
which I just glossed over

00:44:38.450 --> 00:44:39.460
a couple of slides back.

00:44:39.580 --> 00:44:42.360
And I'll set it to local media time, i.e.

00:44:42.560 --> 00:44:47.500
now, plus k, where k starts at zero but
increments by five seconds.

00:44:47.500 --> 00:44:53.600
For every occurrence of a
balloon in my array of balloons.

00:44:53.890 --> 00:44:56.480
Okay, on that, we'll achieve that effect.

00:44:56.550 --> 00:44:58.120
Now, there's one gotcha with begin time.

00:44:58.120 --> 00:45:00.480
The default value is zero,
but that doesn't mean

00:45:00.480 --> 00:45:01.960
that time starts at zero.

00:45:01.960 --> 00:45:06.000
It means that the begin time will
be ignored if you set that to zero.

00:45:06.000 --> 00:45:09.970
If you set it to anything else,
then begin time really reflects

00:45:10.110 --> 00:45:13.980
the local time of that layer,
which may be machine time.

00:45:15.820 --> 00:45:18.260
Here's another example which
has come up in practice.

00:45:18.360 --> 00:45:21.050
Say you've got a scroller in your
application and while scrolling is

00:45:21.050 --> 00:45:22.700
happening you have a heads-up display.

00:45:22.700 --> 00:45:27.700
And when scrolling finally ends,
you want to fade that HUD away,

00:45:27.700 --> 00:45:30.590
but you want to do it after, say,
a two-second delay.

00:45:30.700 --> 00:45:33.670
So, sort of a real-world example.

00:45:33.840 --> 00:45:36.360
So, firstly,
we set the opacity of the HUD to

00:45:36.360 --> 00:45:41.380
zero because we do want the model to
be changed after this is completed.

00:45:41.700 --> 00:45:44.680
I do the time conversion,
which I've already discussed,

00:45:44.880 --> 00:45:46.700
and our animation will call fade out.

00:45:46.700 --> 00:45:51.590
Its from value is 0.5, say,
and its to value is zero.

00:45:51.790 --> 00:45:54.700
We want to make the
fade last five seconds.

00:45:54.700 --> 00:45:58.670
And here's the key thing is we'll
set the begin time to now plus two.

00:45:58.690 --> 00:46:01.700
So,
this animation begins after two seconds.

00:46:01.700 --> 00:46:05.700
Now, there's a slight snag, though,
that's solved by the next statement.

00:46:05.700 --> 00:46:08.680
It gives me a good opportunity
to explain fill mode.

00:46:08.790 --> 00:46:09.700
And the snag is this.

00:46:09.700 --> 00:46:13.640
If I didn't have this next statement,
and I just ran that code,

00:46:13.660 --> 00:46:16.700
then there would be a two-second
delay before the animation kicked in.

00:46:16.700 --> 00:46:20.250
Well, during that two seconds,
the HUD model has an

00:46:20.440 --> 00:46:22.700
opacity value which is zero.

00:46:22.700 --> 00:46:24.350
So,
when that's being rendered by the GPU,

00:46:24.350 --> 00:46:26.980
it says, "What's the opacity?" "Oh,
it's zero.

00:46:26.980 --> 00:46:30.210
Okay, go away, HUD." So,
the visual effect of that will

00:46:30.290 --> 00:46:33.120
be that the HUD will disappear,
and then two seconds later it will

00:46:33.120 --> 00:46:34.650
come back and start fading away.

00:46:34.700 --> 00:46:36.680
Not an effect that you want.

00:46:36.840 --> 00:46:39.700
So, that's solved by using
the fill mode property.

00:46:39.700 --> 00:46:41.700
And you can just think
of fill as a function.

00:46:41.730 --> 00:46:46.700
It's expanding your animation at each end
so that the from value or the to value

00:46:46.700 --> 00:46:52.700
can be dragged out to fill the complete
duration of your overall animation.

00:46:52.700 --> 00:46:54.660
So, in this case,
I'm just filling backwards

00:46:54.750 --> 00:46:57.100
because once I'm done,
I don't care anymore because

00:46:57.100 --> 00:46:58.680
I've changed the model value.

00:46:58.740 --> 00:47:03.690
But there's also fill mode forwards
and fill mode both and fill mode none,

00:47:03.700 --> 00:47:05.650
giving you, obviously,
coverage in all cases.

00:47:05.720 --> 00:47:09.490
And then I just add
the opacity animation.

00:47:10.000 --> 00:49:05.600
[Transcript missing]

00:49:07.700 --> 00:49:10.830
There's a performance,
there's an instruments tool you

00:49:10.830 --> 00:49:14.370
can use called Core Animation and
I'm going to skip this example

00:49:14.450 --> 00:49:16.190
because I want to get on to Tim.

00:49:16.200 --> 00:49:18.540
So, let's just move on to this one.

00:49:18.540 --> 00:49:23.020
So, what we're seeing here is instruments
running on an actual device using

00:49:23.330 --> 00:49:27.080
the Core Animation plug-in for
instruments and I've highlighted

00:49:27.080 --> 00:49:30.950
a field called Color Blended
Layer and when I do that check mark,

00:49:30.950 --> 00:49:34.660
the instruments will set
coloring where the red is bad.

00:49:34.660 --> 00:49:37.580
So, red is showing me that I am
coloring the instrument.

00:49:37.600 --> 00:49:39.840
So, I'm doing some color blending.

00:49:39.840 --> 00:49:41.600
In other words,
I have a non-opaque field.

00:49:41.600 --> 00:49:45.340
Now, this one's strange as a
developer because in fact the

00:49:45.340 --> 00:49:47.740
two layers were almost identical.

00:49:47.790 --> 00:49:51.290
They had the same content,
they had borders and yet one

00:49:51.290 --> 00:49:53.350
is showing up with a red flag.

00:49:53.350 --> 00:49:55.510
And if you look very closely,
you might notice the

00:49:55.510 --> 00:49:57.140
difference between two of them.

00:49:57.140 --> 00:49:58.800
I don't know if you can see that,
but the difference is

00:49:58.800 --> 00:49:59.770
there's a corner radius.

00:49:59.790 --> 00:50:03.650
And even though I set the layer
property opaque to be yes in both cases,

00:50:03.760 --> 00:50:06.510
obviously as soon as
you set a corner radius,

00:50:06.510 --> 00:50:09.850
you want whatever's behind that,
the outside part of the

00:50:09.880 --> 00:50:10.740
corner to show through.

00:50:10.740 --> 00:50:12.620
And instruments is telling me that.

00:50:12.990 --> 00:50:17.760
And then as a developer,
I can make the decision of whether

00:50:17.760 --> 00:50:20.610
it's really worth it depending
on where the performance is being

00:50:21.030 --> 00:50:23.450
ruined or not to use corners.

00:50:23.450 --> 00:50:25.530
And that's a judgment call I can make.

00:50:25.620 --> 00:50:29.290
Now, I had an extra slide
on masks and shadows.

00:50:29.290 --> 00:50:32.740
I just don't have the
time to go through them,

00:50:32.740 --> 00:50:35.590
so a little unorthodox,
but let me whip through

00:50:36.130 --> 00:50:37.560
these just to show you both.

00:50:37.560 --> 00:50:40.810
Shadows and masks and hopefully
later you can review the slides

00:50:40.810 --> 00:50:42.740
and get a little bit out of this.

00:50:42.780 --> 00:50:45.740
And the reason I'm doing this is because
what I really want to do is hand over

00:50:45.740 --> 00:50:51.320
to Tim now to show you some very,
very cool demos that he -- and I have

00:50:51.370 --> 00:50:53.480
prepared bitmap caching as well.

00:50:53.480 --> 00:50:55.220
Sad, but we'll move in.

00:50:55.220 --> 00:50:56.220
So, Tim, I'm handing over to you.

00:50:56.220 --> 00:50:58.890
Thank you.

00:51:00.330 --> 00:51:01.300
Thank you, Michael.

00:51:01.300 --> 00:51:05.400
I want to talk about two of the more
advanced subclasses of CA Layer.

00:51:05.400 --> 00:51:08.540
Before we said most of the time
you're going to use CA Layer.

00:51:08.540 --> 00:51:11.510
These ones won't be used nearly as much,
but they offer a unique set

00:51:11.510 --> 00:51:14.630
of features and powerful
stuff you can do for your app.

00:51:15.240 --> 00:51:18.210
So the first one I want to
talk about is replicators.

00:51:18.240 --> 00:51:22.090
We have a CA Replicator Layer which
offers the unique feature that it

00:51:22.090 --> 00:51:25.430
will automatically create copies
of any sublayer that you add to it.

00:51:25.530 --> 00:51:26.470
And this is the full hierarchy.

00:51:26.560 --> 00:51:28.690
So any sublayer you add
to Replicator Layer,

00:51:28.690 --> 00:51:30.860
it will automatically make copies of it.

00:51:30.960 --> 00:51:33.410
So how do I control how many
copies it's going to make?

00:51:33.500 --> 00:51:36.730
You want to look at the
property instance count.

00:51:36.790 --> 00:51:41.700
Instance count is inclusive the total
number of copies of each sublayer.

00:51:41.700 --> 00:51:45.220
So if I set instance count to one,
it's not going to make any copies.

00:51:45.220 --> 00:51:49.670
So if I set it to three right now,
I'm going to get two additional copies

00:51:49.690 --> 00:51:52.190
of any sublayer that I would add to it.

00:51:52.190 --> 00:51:55.790
So I'm going to take this circle
layer and I'll add that as a

00:51:56.130 --> 00:51:58.150
child of the Replicator Layer.

00:51:58.160 --> 00:52:01.740
And so what the Replicator Layer is
going to go off and do is it will go and

00:52:01.740 --> 00:52:03.770
make a total of three of these layers.

00:52:03.770 --> 00:52:06.280
Now if you do exactly what
I just showed you here,

00:52:06.280 --> 00:52:09.080
you'll see absolutely no
difference in your app.

00:52:09.180 --> 00:52:12.010
Because by default, all these layers are
the exact same shape,

00:52:12.010 --> 00:52:14.050
the exact same size,
and they're placed right

00:52:14.050 --> 00:52:15.220
on top of each other.

00:52:15.220 --> 00:52:17.880
So the whole idea is to
change them a little bit.

00:52:17.970 --> 00:52:21.340
So the Replicator Layer offers
a number of offsets that you can

00:52:21.340 --> 00:52:23.580
have applied to each of the copies.

00:52:23.580 --> 00:52:27.360
The one that I'm going to
do first is a transform.

00:52:27.480 --> 00:52:33.370
And so I'm going to create a transform
that basically just shifts the Y position

00:52:33.830 --> 00:52:36.440
down by 50 pixels for each copy.

00:52:36.640 --> 00:52:39.750
So what's going to happen is
the first -- the original layer

00:52:39.750 --> 00:52:42.700
will remain at its position,
and then the second one

00:52:42.770 --> 00:52:44.570
will be 50 pixels down.

00:52:44.580 --> 00:52:48.580
And then the third one will be
an additional 50 pixels down.

00:52:48.580 --> 00:52:50.560
So it's cumulative.

00:52:50.970 --> 00:52:53.960
There's a number of other
offsets that you can set.

00:52:54.150 --> 00:52:56.340
You can take a look at the
headers for all the options.

00:52:56.360 --> 00:52:58.500
I'm going to show the
color offsets as well.

00:52:58.500 --> 00:52:59.860
There's a green, red, and blue.

00:52:59.860 --> 00:53:03.120
Here I have a layer that's
mostly blue and green,

00:53:03.130 --> 00:53:07.200
and so I'm going to set a
green offset of minus 0.5.

00:53:07.200 --> 00:53:12.130
So we're going to knock out 0.5 green
for the first copy that was made,

00:53:12.130 --> 00:53:14.830
and then for the final
copy that was made,

00:53:14.830 --> 00:53:18.430
all of the green is gone,
so it's a pure blue layer.

00:53:20.380 --> 00:53:21.950
Where can you use these in their apps?

00:53:21.950 --> 00:53:23.060
How are they useful?

00:53:23.080 --> 00:53:26.980
A really good use for replicators is
for people that want to do reflections.

00:53:26.980 --> 00:53:30.340
So you can see we can have a replicator
layer that has an instance count of two,

00:53:30.340 --> 00:53:32.890
so we're going to make one copy,
and then you can have that

00:53:32.890 --> 00:53:35.720
shifted down and faded out,
and we'll flip it in the Y.

00:53:35.720 --> 00:53:37.870
So that way,
if you're playing movies in your layer,

00:53:37.870 --> 00:53:41.190
if you add or remove other sublayers,
it'll dynamically update your reflection,

00:53:41.250 --> 00:53:43.570
so you get this really nice
reflection once you set it up.

00:53:43.580 --> 00:53:44.900
It's kind of for free.

00:53:47.040 --> 00:53:50.060
The second one I want to
talk about is particles.

00:53:50.060 --> 00:53:53.520
Particles you can use to create
complex effects like water,

00:53:53.570 --> 00:53:55.950
smoke, fire, stuff like that.

00:53:56.410 --> 00:53:59.140
And we introduced these
on the desktop before,

00:53:59.140 --> 00:54:01.320
but now we're bringing them to iOS.

00:54:01.420 --> 00:54:04.690
With iOS 5, you can now use particles.

00:54:08.140 --> 00:54:10.340
I'm going to go over the basic
construction of how you'd

00:54:10.460 --> 00:54:12.290
set up particles in your app.

00:54:12.300 --> 00:54:14.490
The layer you want to use
is the CA Emitter layer.

00:54:14.580 --> 00:54:16.780
This is the origin of your particles.

00:54:16.780 --> 00:54:20.440
This controls where they are
going to be generated from.

00:54:20.440 --> 00:54:24.290
So the properties you want to
look at are emitter position,

00:54:24.290 --> 00:54:25.700
mode, and shape.

00:54:25.700 --> 00:54:29.430
So the shape,
we have a number of supported

00:54:29.430 --> 00:54:33.850
options such as line,
rectangle, sphere, cube.

00:54:34.210 --> 00:54:37.030
So you pick one of those shapes
and then the emitter position is

00:54:37.030 --> 00:54:39.080
where that shape will be located.

00:54:39.080 --> 00:54:41.600
So that will be the middle of that shape.

00:54:41.600 --> 00:54:45.100
And for emitter mode,
specifies where on or within that shape

00:54:45.100 --> 00:54:47.540
we're going to generate the particles at.

00:54:47.540 --> 00:54:49.590
So we have an outline mode
that if you have a rectangle,

00:54:49.590 --> 00:54:52.640
it's going to be only generated
on the outline of the rectangle.

00:54:52.640 --> 00:54:55.590
Or there's ones like area,
so we'll have it generated

00:54:55.590 --> 00:54:57.600
anywhere inside the rectangle.

00:54:57.600 --> 00:55:00.290
Or for 3D shapes like spheres,
we can do volume,

00:55:00.290 --> 00:55:03.700
generate anywhere within
the volume of the sphere.

00:55:04.480 --> 00:55:08.400
Those specify where the particles
are going to be generated at.

00:55:08.400 --> 00:55:10.000
And then there's the
emitter cells property,

00:55:10.000 --> 00:55:13.130
which is an array of CA emitter cells,
which you'll use to define

00:55:13.140 --> 00:55:15.990
each of the types of particles,
how they'll look, how they'll behave.

00:55:16.060 --> 00:55:20.830
And so for each of these emitter cells,
we have properties like velocity,

00:55:20.930 --> 00:55:22.880
birth rate, spin, scale.

00:55:22.880 --> 00:55:25.280
There's way more than this
you can take a look at.

00:55:25.470 --> 00:55:27.680
But basically we want to tweak
these to create the unique

00:55:27.690 --> 00:55:29.120
effect that you're going for.

00:55:29.120 --> 00:55:31.970
The key ones, birth rate,
is how many particles per second

00:55:31.980 --> 00:55:33.480
are going to be generated.

00:55:34.280 --> 00:55:37.980
And contents you can
set to a CG image ref.

00:55:37.980 --> 00:55:41.110
Usually you want to use a grayscale
image because that allows you to

00:55:41.190 --> 00:55:45.730
take advantage of the color offsets,
the color properties to animate the

00:55:45.730 --> 00:55:47.980
different colors of the particles.

00:55:48.280 --> 00:55:51.670
And in addition to that,
each one of these CAE emitter cells

00:55:52.050 --> 00:55:54.400
has an emitter cells property itself.

00:55:54.460 --> 00:55:57.930
So what this means is that we can
have particles that emit particles

00:55:58.440 --> 00:56:02.240
that emit particles for however
complex effects you want to go for.

00:56:02.240 --> 00:56:04.800
And each of these are
their own unique particle.

00:56:04.800 --> 00:56:06.540
You can set different
properties on all of them.

00:56:06.540 --> 00:56:10.800
And you can use this to
create really complex effects.

00:56:10.850 --> 00:56:12.800
And I'd like to show
you a couple of those.

00:56:13.640 --> 00:56:18.520
The first one I've got set
up on here is a flame demo.

00:56:18.520 --> 00:56:20.720
We've got fire running here.

00:56:20.720 --> 00:56:24.360
And we have a particle that's
being drawn with not full opacity,

00:56:24.360 --> 00:56:27.490
so we have this sort of buildup
of opacity as we have particles

00:56:27.490 --> 00:56:28.620
go on top of each other.

00:56:28.620 --> 00:56:31.760
And I've set it up so that
if we increase the slider,

00:56:31.760 --> 00:56:36.060
we're going to be animating
the properties of these layers.

00:56:36.060 --> 00:56:38.160
So we're going to animate the birth rate,
so we're going to get more

00:56:38.230 --> 00:56:39.490
particles per second coming out.

00:56:39.550 --> 00:56:42.060
I'm going to change the emitter
shape so it's going to be

00:56:42.060 --> 00:56:43.620
generated over a wider area.

00:56:43.620 --> 00:56:45.360
At the bottom to create a larger flame.

00:56:45.360 --> 00:56:47.480
And obviously the lifetime
is going to be longer,

00:56:47.500 --> 00:56:48.740
so we get a higher flame.

00:56:48.740 --> 00:56:52.440
And as we start to increase it,
you'll notice a second type of particle

00:56:52.440 --> 00:56:54.540
that I also have added for the smoke.

00:56:54.580 --> 00:56:56.070
And this is a larger particle.

00:56:56.070 --> 00:56:57.850
And you can see the spin we've added.

00:56:57.960 --> 00:57:01.070
So it sort of looks like it's sort
of twisting around as it goes up.

00:57:01.220 --> 00:57:05.230
So we have two types of particles here
being emitted from one emitter layer.

00:57:05.240 --> 00:57:09.080
I want to move to the second demo now.

00:57:09.290 --> 00:57:11.780
We'll go out with a bang.

00:57:16.190 --> 00:57:19.600
This is a great example
of the nested particles.

00:57:19.620 --> 00:57:22.660
So we have a single emitter at the
bottom here and it's emitting the first

00:57:22.780 --> 00:57:24.670
type of particle is actually invisible.

00:57:24.670 --> 00:57:26.450
There's no contents for it.

00:57:26.480 --> 00:57:27.100
It has no color.

00:57:27.100 --> 00:57:30.200
And this just follows the
arc of the firework going up.

00:57:30.250 --> 00:57:34.040
And the reason you can tell it's
there is because it emits three

00:57:34.050 --> 00:57:36.280
types of particles from itself.

00:57:36.420 --> 00:57:38.510
So the first one is
that flare off the back.

00:57:38.570 --> 00:57:43.090
And the second type of particles
is the actual explosion at the end.

00:57:43.090 --> 00:57:46.070
And so we want a lot of particles
in a really short amount of time.

00:57:46.180 --> 00:57:51.060
So we've used the CA media timing
protocol to make the duration

00:57:51.450 --> 00:57:54.040
of that layer only .1 seconds.

00:57:54.040 --> 00:57:56.300
And then we're going to use the
begin time to make it only occur

00:57:56.300 --> 00:57:57.640
after a certain amount of time.

00:57:57.640 --> 00:57:59.550
So after it's reached
the appropriate height,

00:57:59.550 --> 00:58:01.960
then we're going to have like a
tenth of a second of generating

00:58:01.960 --> 00:58:03.900
20,000 particles a second.

00:58:03.900 --> 00:58:06.860
And we get a huge explosion there.

00:58:06.860 --> 00:58:07.780
And then they'll fade out.

00:58:07.940 --> 00:58:09.480
And then if you notice,
there's a final type

00:58:09.490 --> 00:58:10.460
of particle at the end.

00:58:10.460 --> 00:58:13.140
There's sort of a little flicker
after the explosion finishes.

00:58:13.140 --> 00:58:17.290
And I talked earlier about the
different types of shapes that you

00:58:17.290 --> 00:58:18.980
could use to emit these particles.

00:58:19.090 --> 00:58:22.060
And I mentioned that
they're not all just 2D.

00:58:22.060 --> 00:58:24.000
We can do all this in 3D as well.

00:58:24.290 --> 00:58:26.760
So if you touch and drag on the screen,
you can see that we're

00:58:26.760 --> 00:58:30.140
doing this all in 3D.

00:58:34.900 --> 00:58:36.900
And so I'm going to hand
off this to you guys.

00:58:36.950 --> 00:58:38.860
You can do this on all
of your new iPad apps,

00:58:38.860 --> 00:58:40.740
and I'm sure you'll have
a lot of fun with it.

00:58:40.750 --> 00:58:41.440
Thank you.

00:58:41.440 --> 00:58:42.900
MICHAEL LEWIS: OK, so that is it.

00:58:42.900 --> 00:58:46.070
The related session is the one that
some of you have just seen on UIKit,

00:58:46.070 --> 00:58:49.180
which you can catch later
when you review the slides.

00:58:49.180 --> 00:58:52.300
More information,
there are the contacts for you.

00:58:52.300 --> 00:58:55.180
And I want to thank you for
your lively participation.

00:58:55.180 --> 00:58:58.190
We both had a lot of
fun doing this for you.
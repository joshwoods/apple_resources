WEBVTT

00:00:13.750 --> 00:00:14.940
Hello.

00:00:14.960 --> 00:00:19.180
Welcome to ViewBase NSTableView from
Basic to Advanced online.

00:00:19.220 --> 00:00:20.070
My name is Corbin Dunn.

00:00:20.210 --> 00:00:22.590
I'm a Cocoa software engineer.

00:00:23.740 --> 00:00:25.300
So what are we going to talk about today?

00:00:25.320 --> 00:00:29.340
Well, new on Lion,
NSTableView now supports NSView.

00:00:29.380 --> 00:00:30.990
You don't have to use NSCell.

00:00:31.120 --> 00:00:35.030
So it's much easier,
you don't have to do any subclassing

00:00:35.260 --> 00:00:38.480
NSCell to do hit testing,
drawing, whatever.

00:00:39.400 --> 00:00:40.400
Now, why is this great?

00:00:40.610 --> 00:00:44.260
Well, you can do easy design time layout
inside of Interface Builder and

00:00:44.260 --> 00:00:48.830
just do it all by adding one view,
another view, another subview.

00:00:49.000 --> 00:00:52.640
You can animate stuff because we
can move views around really easily.

00:00:52.690 --> 00:00:56.080
You can customize drawing by just
subclassing NSView and adding

00:00:56.080 --> 00:00:57.410
other things that you need.

00:00:57.560 --> 00:00:59.850
You can do other animations
inside of the cell,

00:00:59.920 --> 00:01:01.920
which were difficult to do before.

00:01:02.230 --> 00:01:03.940
So what are we going to talk about?

00:01:03.950 --> 00:01:07.150
We're going to talk about layout,
which is general NSTableView and

00:01:07.160 --> 00:01:10.060
how the new NSViews fit into it.

00:01:10.330 --> 00:01:13.760
Talk about construction,
which is how to go ahead and actually

00:01:14.020 --> 00:01:16.200
create a View-based TableView.

00:01:16.200 --> 00:01:18.780
I'm going to talk about bindings,
so how to use bindings

00:01:18.780 --> 00:01:20.200
with this new technology.

00:01:20.200 --> 00:01:23.600
I'm going to discuss some customizing,
so how to do subclassing and add

00:01:23.600 --> 00:01:25.200
some cool new features to it.

00:01:25.200 --> 00:01:27.410
I'm going to talk about drag
and drop and doing some new

00:01:27.410 --> 00:01:29.200
multi-image dragging with the tables.

00:01:29.380 --> 00:01:32.720
And then finally,
we'll talk a little bit about animating.

00:01:33.640 --> 00:01:36.600
Now, when I say the word Cell,
I'm just going to mean

00:01:36.670 --> 00:01:38.140
a particular row column.

00:01:38.280 --> 00:01:40.800
If I mean NSCell,
I'll go ahead and say NSCell.

00:01:41.080 --> 00:01:44.240
So I just want to set that
out there so you understand.

00:01:44.710 --> 00:01:47.940
So let's just jump right
into it and do a demo.

00:01:48.020 --> 00:01:51.300
And this is called the
TableView Playground Demo.

00:01:51.410 --> 00:01:54.550
You can go ahead and download
it on developer.apple.com

00:01:54.690 --> 00:01:56.330
and play around with it.

00:01:56.610 --> 00:01:59.770
And I'm going to show a few of the
features of the View-based TableView.

00:01:59.850 --> 00:02:03.880
So right here, this window is a
Basic View-based TableView.

00:02:03.920 --> 00:02:08.060
It just creates the other windows for
the application to show pieces of the UI.

00:02:08.130 --> 00:02:12.160
And it's completed -- or
created complete with bindings.

00:02:12.160 --> 00:02:15.760
There's actually no code
really to do any of this.

00:02:15.850 --> 00:02:18.140
So I'm going to go ahead
and hide that window.

00:02:18.150 --> 00:02:20.060
So here's a basic View-based TableView.

00:02:20.250 --> 00:02:22.680
It looks like any other
NSTableView that you have.

00:02:22.900 --> 00:02:24.280
It has an image and cell.

00:02:24.280 --> 00:02:25.940
It does typical selection.

00:02:25.950 --> 00:02:28.200
And it's really easy to create.

00:02:28.330 --> 00:02:32.180
The basics here is that it
looks just like any other table.

00:02:32.270 --> 00:02:35.680
So let's take a look at a
more advanced TableView.

00:02:35.720 --> 00:02:39.320
This is the complex
TableView example inside the demo.

00:02:39.580 --> 00:02:42.160
And what you see here
is as things scroll in,

00:02:42.590 --> 00:02:46.340
views animate in,
which was difficult to do before.

00:02:46.350 --> 00:02:49.440
Up at the top,
the headers can flow over content,

00:02:49.460 --> 00:02:51.640
something really easy to do now.

00:02:51.660 --> 00:02:52.800
We can do animations.

00:02:52.800 --> 00:02:56.040
So I can go ahead and
select a row and delete it.

00:02:56.070 --> 00:02:59.020
We can do insertions.

00:02:59.020 --> 00:03:00.440
We can do moves.

00:03:00.450 --> 00:03:02.220
So I can move from one row to another.

00:03:02.290 --> 00:03:05.240
A real easy API to do this.

00:03:05.280 --> 00:03:08.680
We can do things like
animating the row height.

00:03:08.700 --> 00:03:12.160
And while the row height is animating,
we can animate the views inside of it.

00:03:12.160 --> 00:03:14.390
It's really easy to do.

00:03:15.080 --> 00:03:18.040
NSOutlineView is a
subclass of NSTableView.

00:03:18.440 --> 00:03:20.310
It has all these features too.

00:03:20.560 --> 00:03:25.090
It does a cool animation throughout
the OS when things open and collapse.

00:03:25.250 --> 00:03:30.200
A neat thing about this table view is
we can do some cool insert animations.

00:03:30.200 --> 00:03:34.660
I create drag images and as I let go,
the little gap opens up and the

00:03:34.660 --> 00:03:36.760
rows just slide on into place.

00:03:36.810 --> 00:03:45.000
I also show how to do reordering
inside of it in an animated fashion.

00:03:45.000 --> 00:03:45.010
So those are a few of the things I'm
going to highlight and talk about.

00:03:50.110 --> 00:03:52.880
So let's go ahead and talk about layout.

00:03:52.980 --> 00:03:54.370
Now NSTableView layout.

00:03:54.390 --> 00:03:58.120
So here's a table in
that sample application.

00:03:58.650 --> 00:04:00.890
Typical layout:
we have an NSScrollView at the top,

00:04:00.890 --> 00:04:03.400
and the scroll view is the thing
that lets you do the scrolling.

00:04:03.470 --> 00:04:07.660
The next layer of the subview
hierarchy is an NSClipView,

00:04:07.670 --> 00:04:10.300
and this is what actually
clips the content.

00:04:10.370 --> 00:04:12.400
Then inside of there,
you have your NSTableView,

00:04:12.400 --> 00:04:15.100
which actually might be a lot
bigger than what you see there.

00:04:15.140 --> 00:04:17.300
And the ClipView is what
actually does the clipping.

00:04:17.340 --> 00:04:19.800
Now all of that's pretty much
the same for what we already had

00:04:19.800 --> 00:04:21.400
with the NSCell-based TableView.

00:04:21.400 --> 00:04:24.100
So let's take a look at
what's actually new here.

00:04:24.120 --> 00:04:28.200
And the next level of a subview
that's new is an NSTableRowView.

00:04:28.200 --> 00:04:30.100
So let's take a look at
NS Table Row View and

00:04:30.120 --> 00:04:32.260
see what it does for you.

00:04:32.950 --> 00:04:36.080
So the row view is responsible
for drawing selection.

00:04:36.110 --> 00:04:39.120
And the table has a few selection styles,
and the row view has some

00:04:39.260 --> 00:04:42.040
properties so you can access
and see that selection style.

00:04:42.070 --> 00:04:44.930
So here's NSTableView Selection
Highlight Style Regular.

00:04:45.060 --> 00:04:48.120
And of course we have a
Source List Highlight Style,

00:04:48.160 --> 00:04:51.580
so NSTableView Selection
Highlight Style Source List.

00:04:52.390 --> 00:04:55.580
The rowView is also responsible
for drawing the background color.

00:04:55.760 --> 00:04:59.460
So you could set the
rowView.backgroundColor to be a red

00:04:59.460 --> 00:05:01.730
color and that row will draw red.

00:05:01.730 --> 00:05:03.160
Or whatever color you want.

00:05:03.190 --> 00:05:06.300
Of course the red looks kind of ugly,
but this is just an example.

00:05:06.300 --> 00:05:08.830
It can make it green or
whatever else you want.

00:05:08.890 --> 00:05:10.280
It's really easy to do.

00:05:11.210 --> 00:05:15.340
The row view is also responsible for
drawing the group row background.

00:05:15.420 --> 00:05:18.800
So the group row background we
saw in that outline view demo,

00:05:18.860 --> 00:05:23.190
there's a whole row with the little
gray to kind of separate a group.

00:05:23.430 --> 00:05:27.310
This is done by you implementing the
delegate method TableViewIsGroupRow,

00:05:27.350 --> 00:05:31.030
or the equivalent OutlineView version,
and saying yes for which

00:05:31.030 --> 00:05:32.520
rows are group rows.

00:05:32.560 --> 00:05:35.150
These give you that group row style,
and if that's set,

00:05:35.290 --> 00:05:38.880
group row style will be yes,
and it can draw differently.

00:05:39.110 --> 00:05:42.680
In addition, there's a new property on
TableView called FloatsGroupRows,

00:05:42.740 --> 00:05:46.600
so all those group rows can automatically
float over content optionally.

00:05:46.670 --> 00:05:48.750
And if that's set,
the row view has a floating

00:05:48.750 --> 00:05:50.600
property which would be set to Yes.

00:05:50.640 --> 00:05:53.780
And then you as a subclasser
could look at that property and

00:05:53.780 --> 00:05:55.630
draw differently if you want.

00:05:56.720 --> 00:06:00.930
The row view also draws the separators
between one row and another.

00:06:01.130 --> 00:06:05.800
The reason it does this is it
allows the separator to move around

00:06:05.800 --> 00:06:08.260
with the row when it animates.

00:06:08.380 --> 00:06:12.540
The separator is specified by the
grid-style mask on the TableView.

00:06:12.690 --> 00:06:14.130
There are a couple of options.

00:06:14.350 --> 00:06:17.600
There is the NSTableView Solid Horizontal
Gridline Mask.

00:06:17.660 --> 00:06:20.110
It's really hard to see
it in this screenshot.

00:06:20.390 --> 00:06:23.520
There's also a new one in
Lion that's a dashed option.

00:06:23.750 --> 00:06:27.210
Again, it's really hard to see the dash,
but you can look closer in the

00:06:27.220 --> 00:06:28.790
demo app and you can see it.

00:06:29.640 --> 00:06:33.000
The row view is also responsible
for drawing drag and drop feedback.

00:06:33.160 --> 00:06:36.200
So when you drag over that row,
you want the whole row to show

00:06:36.200 --> 00:06:38.840
some type of feedback to the user.

00:06:38.920 --> 00:06:42.730
And so there is dragging
destination styles that the

00:06:42.730 --> 00:06:44.810
TableView has and draws for you.

00:06:44.980 --> 00:06:48.210
There's NSTableView dragging
destination feedback style regular,

00:06:48.210 --> 00:06:50.520
which is just the regular feedback style.

00:06:50.590 --> 00:06:53.600
And there's also a source list
style that has a different look for

00:06:53.600 --> 00:06:57.370
source lists or sidebars or whatnot.

00:06:58.390 --> 00:07:02.800
The row view computes a few properties,
and one of them is the

00:07:02.800 --> 00:07:04.800
interior background style.

00:07:04.850 --> 00:07:06.840
So why is this important?

00:07:06.900 --> 00:07:09.520
Well, depending on what properties
the table set on the row view,

00:07:09.520 --> 00:07:12.920
like if it's selected or whatnot,
the row view will calculate

00:07:13.150 --> 00:07:15.020
what its background should be.

00:07:15.060 --> 00:07:17.110
So in this case,
the interior background style

00:07:17.160 --> 00:07:19.680
is set to NSBackgroundStyleDark.

00:07:19.780 --> 00:07:23.980
So that lets you know that, hey,
all my content should probably be light

00:07:23.980 --> 00:07:26.900
text because I'm on a dark background.

00:07:26.940 --> 00:07:29.540
And then, of course,
there's NSBackgroundStyleLight if

00:07:29.540 --> 00:07:32.470
it's actually a light background,
and you should probably have dark

00:07:32.470 --> 00:07:33.940
text to stand out against it.

00:07:33.970 --> 00:07:38.000
There are a few more NSBackgroundStyle
options that I encourage you to look at,

00:07:38.000 --> 00:07:39.170
which might be set.

00:07:39.240 --> 00:07:42.900
These are the two basic ones that
are really important to know.

00:07:43.520 --> 00:07:46.570
Now, that was the one thing that
the TableRowView computed.

00:07:46.920 --> 00:07:49.620
It doesn't compute all
the other properties,

00:07:49.850 --> 00:07:51.640
the selection and whatnot.

00:07:51.710 --> 00:07:53.780
They are set by the TableView.

00:07:53.950 --> 00:07:56.320
You as a developer could
use the new delegate method.

00:07:56.430 --> 00:08:00.760
TableView did add RowView for row
to go ahead and override these

00:08:00.830 --> 00:08:03.620
properties to be whatever you want.

00:08:05.040 --> 00:08:10.320
Let's take a look at NSTableColumn
and how it works with NSTableRowView.

00:08:10.360 --> 00:08:17.040
The row view stores a number of
columns and there is a view per column.

00:08:17.100 --> 00:08:20.340
If we look at this table here,
the outline view example,

00:08:20.340 --> 00:08:21.820
you can see there are three columns.

00:08:22.140 --> 00:08:25.240
There's one, two, three.

00:08:25.290 --> 00:08:28.300
If we take a look at
one individual row view,

00:08:28.300 --> 00:08:32.880
it has all three columns inside of it,
so it stores its number of columns.

00:08:32.940 --> 00:08:35.610
If we zoom up and look at
it a little bit closer,

00:08:35.750 --> 00:08:38.310
you can see it has one view per column.

00:08:38.400 --> 00:08:42.350
It stores that and that view
there could be any NSView.

00:08:42.730 --> 00:08:47.570
This first one is just a regular
NSView with regular subviews,

00:08:47.700 --> 00:08:50.500
an image and an NSTextField.

00:08:50.980 --> 00:08:51.960
You can put whatever you want.

00:08:52.020 --> 00:08:54.780
It doesn't have to be a
special subclass of anything.

00:08:54.820 --> 00:08:58.770
And so this is just a
regular NSTextField.

00:08:59.800 --> 00:09:04.690
This third one is a custom
NSView subview that does custom drawing,

00:09:04.690 --> 00:09:07.820
and then another regular NSTextField.

00:09:09.200 --> 00:09:12.580
Now, you could use any view you want,
but we highly encourage

00:09:12.580 --> 00:09:14.340
you to use NSTableCellView.

00:09:14.390 --> 00:09:18.280
It's optional, but it gives you some real
cool and easy things to do.

00:09:18.300 --> 00:09:20.320
Specifically,
it gives you a couple of outlets.

00:09:20.420 --> 00:09:23.020
It gives you a text field
and image view outlet.

00:09:23.060 --> 00:09:26.780
So you as a developer could set this
text field outlet to your text field,

00:09:26.800 --> 00:09:29.830
and the image view outlet
to your image view.

00:09:30.400 --> 00:09:33.280
These are easy to access in code,
but they also do a couple

00:09:33.320 --> 00:09:35.500
things for you automatically.

00:09:35.570 --> 00:09:37.700
They're hints for accessibility, for one.

00:09:37.750 --> 00:09:42.120
So when a user is using
VoiceOver and goes to your TableView,

00:09:42.120 --> 00:09:45.460
the text field property will
automatically be read off to the user

00:09:45.900 --> 00:09:47.540
without you having to do any work.

00:09:47.650 --> 00:09:50.840
It kind of specifies the
main text for that row.

00:09:51.970 --> 00:09:53.540
Now how many views do you have?

00:09:53.550 --> 00:09:57.790
So you have a View-based TableView,
and if you have 20,000 rows or something,

00:09:57.800 --> 00:10:02.340
does that mean you're going to have
20,000 row views and subviews within it?

00:10:02.390 --> 00:10:03.940
Well, no you won't.

00:10:03.990 --> 00:10:08.340
What you'll have is just
a view for each visible,

00:10:08.370 --> 00:10:10.760
or a view in the visible rect,
and that is it.

00:10:10.810 --> 00:10:13.840
There are no extra views
outside of that visible rect.

00:10:13.910 --> 00:10:16.060
Now there are actually
some caveats to this.

00:10:16.360 --> 00:10:19.020
For instance,
if the first responder is scrolled off,

00:10:19.020 --> 00:10:21.340
the table actually will
keep track of that.

00:10:21.650 --> 00:10:24.100
Or,
what if you had views animating around?

00:10:24.310 --> 00:10:26.350
The table will actually
keep track of those views,

00:10:26.420 --> 00:10:29.040
so that you can update them
dynamically if you need to.

00:10:29.160 --> 00:10:31.890
And I'll show you how to
do that in a short bit.

00:10:32.390 --> 00:10:33.700
So what happens when you scroll?

00:10:33.700 --> 00:10:36.620
So you scroll up,
there are no views there,

00:10:36.720 --> 00:10:40.420
and so the TableView is going to
just go ahead and pull those couple

00:10:40.420 --> 00:10:44.630
of views that are no longer visible
and toss them into a reuse queue.

00:10:44.780 --> 00:10:48.360
Now, you might have something else
already in this reuse queue,

00:10:48.440 --> 00:10:51.650
and you can just go ahead and
pull those other views out of

00:10:51.650 --> 00:10:53.860
the reuse queue and reuse them.

00:10:53.910 --> 00:10:57.700
So it's good for performance to just
reuse the views again and again.

00:10:59.010 --> 00:11:01.840
So that's basic TableView layout.

00:11:01.930 --> 00:11:05.320
Let's move on and talk a little bit
about construction to figure out

00:11:05.330 --> 00:11:07.600
how you make a View-based TableView.

00:11:08.510 --> 00:11:11.080
So the basic data source
methods haven't changed.

00:11:11.100 --> 00:11:14.400
You still have to implement
number of rows in TableView.

00:11:14.410 --> 00:11:17.380
And the caveat to this
is if you use bindings.

00:11:17.400 --> 00:11:19.990
So what you'll do is you'll
just return your model count

00:11:20.080 --> 00:11:23.470
for the number of rows you want.

00:11:23.830 --> 00:11:27.540
An optional method is TableView object
value for table column row.

00:11:27.680 --> 00:11:29.860
Previously this was
required with the NSL based,

00:11:30.060 --> 00:11:32.800
because it was set to the NSL value.

00:11:32.880 --> 00:11:36.490
But now it's optional and I'll explain
how you can use it in a little bit.

00:11:37.310 --> 00:11:42.470
So, now what can you do in your delegate
is the thing that actually tells the

00:11:42.560 --> 00:11:44.900
table it's a View-based TableView.

00:11:44.900 --> 00:11:49.100
You need to implement TableView,
ViewForTableColumnRow.

00:11:49.210 --> 00:11:52.180
And here's one of the most
basic implementations.

00:11:52.180 --> 00:11:55.860
You would alloc init your view,
in this case a simple text field.

00:11:55.860 --> 00:11:59.110
Now, in this case I'm not showing
a frame that you alloc with,

00:11:59.110 --> 00:12:00.830
and the frame really doesn't matter.

00:12:00.840 --> 00:12:02.830
The table controls the frame.

00:12:02.830 --> 00:12:04.730
You don't need to specify it.

00:12:04.760 --> 00:12:08.780
It will use the frame for whatever
that cell is supposed to be.

00:12:09.160 --> 00:12:12.290
So you knit your view,
set the string value or whatever

00:12:12.420 --> 00:12:15.890
properties you want to it that are
specific to that particular row,

00:12:15.890 --> 00:12:18.500
and then you can just go ahead
and return an auto-release view.

00:12:18.510 --> 00:12:21.250
So it's really quite simple to do.

00:12:21.750 --> 00:12:24.880
All this is optional if you use bindings,
and I'll talk about how to

00:12:24.880 --> 00:12:27.390
do that in a little bit.

00:12:28.500 --> 00:12:52.800
[Transcript missing]

00:12:52.900 --> 00:13:00.700
[Transcript missing]

00:13:01.900 --> 00:13:02.930
So how do we do this?

00:13:03.100 --> 00:13:05.560
Well,
NSView now has an identifier property

00:13:05.810 --> 00:13:08.770
to uniquely identify that type of view.

00:13:09.330 --> 00:13:10.090
Here's how we do it.

00:13:10.270 --> 00:13:13.360
There's a new protocol,
NSUserInterfaceItemIdentification,

00:13:13.480 --> 00:13:16.000
which gives an identifier property.

00:13:16.100 --> 00:13:20.040
NSView implements this protocol,
and now you have an identifier

00:13:20.240 --> 00:13:22.190
that can be set or read.

00:13:23.440 --> 00:13:27.940
Here's a more typical implementation
of a View-based TableView.

00:13:27.990 --> 00:13:30.370
If you've done any iOS
programming with UI TableView,

00:13:30.450 --> 00:13:31.960
it's quite similar to that.

00:13:32.000 --> 00:13:35.060
You're going to call a new table method,
makeViewWithIdentifier,

00:13:35.060 --> 00:13:38.360
passing in the type of identifier
that you want to create,

00:13:38.360 --> 00:13:40.480
and an owner of yourself.

00:13:41.080 --> 00:13:43.770
Now, if it didn't have one
from the reuse queue,

00:13:43.820 --> 00:13:47.120
which is what that method would do,
you're going to get back nil.

00:13:47.170 --> 00:13:51.520
And so you'll have to allocate a new view
that you want to create for that cell,

00:13:51.520 --> 00:13:54.990
set the identifier,
then go ahead and set up your string

00:13:54.990 --> 00:13:58.240
value and other properties on it,
and return that result.

00:13:58.880 --> 00:14:01.880
So this is a very typical
manual implementation.

00:14:02.050 --> 00:14:04.010
But we thought about
some more and thought,

00:14:04.010 --> 00:14:05.880
hey, we can make this even easier.

00:14:05.880 --> 00:14:08.870
So this is an even more typical
delegate implementation.

00:14:08.880 --> 00:14:12.870
Inside of it, you're just going to call
makeViewWithIdentifier,

00:14:13.080 --> 00:14:15.660
and it's going to always
return a result for you.

00:14:16.020 --> 00:14:17.860
And I'll show how in just a second.

00:14:17.860 --> 00:14:21.250
Of course, you still have to set up
your initial properties here,

00:14:21.300 --> 00:14:23.870
like the string value
for that particular row.

00:14:25.460 --> 00:14:27.500
So before I talk about
how that method works,

00:14:27.600 --> 00:14:32.300
let's talk a little bit about
NSNibLoading and how that works.

00:14:32.360 --> 00:14:37.000
NSNib has a method,
InstantiateNibWithOwnerTopLevelObjects.

00:14:37.080 --> 00:14:40.020
Now what's important about
here is the owner property.

00:14:40.110 --> 00:14:43.880
So this is just a screenshot of
Interface Builder inside of Xcode.

00:14:43.930 --> 00:14:47.210
And the owner property there
is that files owner that

00:14:47.210 --> 00:14:49.340
you go ahead and specify.

00:14:49.450 --> 00:14:53.300
The files owner is important because
that's what you can set your target

00:14:53.300 --> 00:14:56.840
action to or your outlets from.

00:14:56.840 --> 00:14:58.880
So keep that in mind.

00:14:58.910 --> 00:15:04.720
Here's a screenshot of how we do design
time layout of the ViewBase TableView.

00:15:04.720 --> 00:15:06.460
There are three columns.

00:15:06.470 --> 00:15:09.950
Now what you can think of is each
of these design time cells are

00:15:10.100 --> 00:15:15.140
effectively a little NSNib that the
TableView will encode within itself.

00:15:15.140 --> 00:15:19.260
So we have this first one,
which has an identifier of main cell.

00:15:19.280 --> 00:15:20.890
Next one is the date cell.

00:15:21.140 --> 00:15:23.400
Third one would be that color cell.

00:15:23.420 --> 00:15:25.340
And the final one would
be the group cell.

00:15:25.380 --> 00:15:28.340
So each of those will just
be encoded into the NSNib

00:15:28.340 --> 00:15:30.140
automatically within the table.

00:15:30.170 --> 00:15:32.470
So the table has them
and knows about them,

00:15:32.470 --> 00:15:36.690
can replicate everything about that view,
including the bindings.

00:15:38.210 --> 00:15:42.260
So how does
MakeViewWithIdentifierOwner work?

00:15:42.330 --> 00:15:45.700
So you need a view with an
identifier called MainCell.

00:15:45.770 --> 00:15:51.090
So you as a developer are going to
call MakeViewWithIdentifierOwnerSelf.

00:15:51.900 --> 00:15:55.400
is that cell with that identifier
already in the reuse queue?

00:15:55.450 --> 00:15:57.770
Well, if it is,
it's going to go ahead and return

00:15:57.860 --> 00:16:02.280
that old cell with that existing
identifier that it already found.

00:16:02.310 --> 00:16:04.310
If it didn't,
and here's the new part that's

00:16:04.340 --> 00:16:07.570
a little different from iOS,
we see if there's a design

00:16:07.630 --> 00:16:09.620
time view with that identifier.

00:16:09.680 --> 00:16:12.380
If there is,
the table automatically calls

00:16:12.470 --> 00:16:16.260
instantiate_nib_with_owner,
finds that view with that identifier,

00:16:16.290 --> 00:16:20.210
and goes ahead and returns you
that new instance of that view.

00:16:20.350 --> 00:16:22.420
If there isn't,
you're kind of out of luck,

00:16:22.420 --> 00:16:24.480
and at this point it does return nil.

00:16:24.530 --> 00:16:26.890
But that's how that method works.

00:16:27.670 --> 00:16:30.140
Updating ViewState for a Cell.

00:16:30.220 --> 00:16:34.210
If you set some properties,
like the font to be bold

00:16:34.220 --> 00:16:37.920
or something specific,
you as the developer will probably

00:16:37.920 --> 00:16:39.740
have to initialize it in this method.

00:16:39.830 --> 00:16:41.970
Otherwise,
if you got one out of the reuse queue,

00:16:42.010 --> 00:16:44.940
it might have whatever properties
were previously set on it.

00:16:45.080 --> 00:16:48.330
It's just an important thing
to note that you have to reset

00:16:48.410 --> 00:16:50.210
all things like the font.

00:16:51.410 --> 00:16:55.600
So let's take a look at another demo and
just see how basic TableView construction

00:16:55.600 --> 00:16:58.560
is done at design time.

00:17:02.620 --> 00:17:05.800
This is a really basic
view-based TableView.

00:17:05.810 --> 00:17:08.200
I want to show how you
would add a new CellView.

00:17:08.420 --> 00:17:10.870
Inside the object library,
you could just search

00:17:10.870 --> 00:17:12.380
for NSTableCellView.

00:17:12.480 --> 00:17:16.860
You could drag an image and text cell
that's already predefined and set up.

00:17:17.210 --> 00:17:21.540
The new important part is the
user interface IAM identifier.

00:17:21.630 --> 00:17:24.670
You could call it MyCell
or whatever you want.

00:17:26.830 --> 00:17:30.140
So I'm going to undo that and just look
at one that I already dropped down here.

00:17:30.200 --> 00:17:33.280
If I select the CellView,
I can see that this one has

00:17:33.300 --> 00:17:35.020
an identifier of main cell.

00:17:35.030 --> 00:17:38.180
All right,
so that's how it's actually set up.

00:17:38.200 --> 00:17:40.750
Some other interesting things about it.

00:17:41.190 --> 00:17:44.800
You'll recall previously I said that it
had two outlets from NSTableCellView.

00:17:44.880 --> 00:17:47.650
It has an ImageView and
a TextFieldOutlet.

00:17:48.010 --> 00:17:50.940
So I'll show you how those
come into play in a second.

00:17:51.310 --> 00:17:53.880
In addition,
you can drop down other views,

00:17:53.960 --> 00:17:59.210
like a button inside of it,
and you could actually have the buttons

00:18:01.000 --> 00:18:06.850
will be covering the latest
and most recent applications

00:18:06.850 --> 00:18:11.340
using the new function,
which is called the

00:18:11.340 --> 00:18:14.370
"Bottom Clicked Action".

00:18:15.820 --> 00:18:18.130
So in a basic implementation,
you would go ahead and

00:18:18.130 --> 00:18:19.680
create your model object.

00:18:19.770 --> 00:18:22.510
Here it's just an array of images.

00:18:23.550 --> 00:18:28.280
Number of rows in TableView, of course,
is just going to return the array count.

00:18:28.360 --> 00:18:31.720
Then the interesting new part,
View for Table Column is implemented.

00:18:31.810 --> 00:18:34.160
And as I showed you before,
at design time there is a cell

00:18:34.320 --> 00:18:36.160
with an identifier called MainCell.

00:18:36.200 --> 00:18:39.680
So MakeViewWithIdentifier will always
get a result back created from you,

00:18:39.730 --> 00:18:43.600
either from the reuse queue or a
new one that it just instantiated.

00:18:43.640 --> 00:18:46.970
It's going to go ahead and grab the model
object and then set up properties on it,

00:18:46.970 --> 00:18:48.380
accessing those outlets.

00:18:48.630 --> 00:18:52.620
So it accesses the text field,
set string value, and accesses the image

00:18:52.900 --> 00:18:56.040
and sets image value,
and then returns the result.

00:18:56.080 --> 00:18:59.050
So that's the most basic implementation
of a View-based TableView.

00:18:59.200 --> 00:19:01.400
It's really easy to do.

00:19:01.440 --> 00:19:03.360
Now how do you respond to an action?

00:19:03.390 --> 00:19:07.590
So if you click on that button, well,
this is my delegate and

00:19:07.670 --> 00:19:09.360
there are a bunch of rows.

00:19:09.450 --> 00:19:13.080
How do I know which row that
action should be applied on?

00:19:13.140 --> 00:19:16.300
Well, the TableView has a
method called RowForView.

00:19:16.480 --> 00:19:19.640
So you can just find out what
row that view is actually on.

00:19:19.660 --> 00:19:22.760
In this case, we're going to find out
which one the sender was on.

00:19:22.770 --> 00:19:24.400
And the sender was the button.

00:19:24.420 --> 00:19:27.400
So we know which row was actually
clicked on and we can do some

00:19:27.400 --> 00:19:28.710
action based on that row.

00:19:29.100 --> 00:19:32.000
So that's also pretty easy to do.

00:19:37.810 --> 00:19:38.720
So how do you do editing?

00:19:38.830 --> 00:19:41.160
That's the next question
that people will usually ask.

00:19:41.170 --> 00:19:43.200
Well, with NSCell,
you would use TableView set

00:19:43.240 --> 00:19:45.480
object value for table column row.

00:19:45.500 --> 00:19:48.080
Now, if you have a View-based TableView,
what if you have more than

00:19:48.080 --> 00:19:49.720
one text field in that cell?

00:19:49.720 --> 00:19:52.480
It's kind of ambiguous
how you would actually,

00:19:52.480 --> 00:19:54.040
or what the table should
do with this method,

00:19:54.050 --> 00:19:56.320
because we don't know
which one you want to edit.

00:19:56.340 --> 00:19:58.480
And actually,
we don't have to do anything special.

00:19:58.480 --> 00:19:59.880
It's just a text field.

00:19:59.910 --> 00:20:02.700
You can just use normal
target action-based editing or

00:20:02.710 --> 00:20:05.910
notifications on that text field
to find out when text changes.

00:20:05.920 --> 00:20:09.790
And so that's what you're going to do,
and it's really easy to do.

00:20:10.750 --> 00:20:12.640
How do you manually begin editing?

00:20:12.670 --> 00:20:16.590
Well, with NSCells, you would use
EditColumnRowWithEventSelect,

00:20:16.600 --> 00:20:18.640
and that would go ahead
and edit that cell.

00:20:18.680 --> 00:20:21.920
But again, it's ambiguous if you have
more than one text field.

00:20:21.940 --> 00:20:24.040
And in fact,
editing is really just making

00:20:24.100 --> 00:20:25.440
it the first responder.

00:20:25.460 --> 00:20:29.410
So in a View-based TableView,
you'll just call MakeFirstResponder,

00:20:29.610 --> 00:20:31.200
and then it begins editing.

00:20:31.220 --> 00:20:33.470
So that's really easy, too.

00:20:33.820 --> 00:20:39.080
But how do we control editing
to make it behave like a table?

00:20:39.100 --> 00:20:41.510
Normally in Finder,
if you click on a row,

00:20:41.650 --> 00:20:43.520
it doesn't start editing right away.

00:20:43.530 --> 00:20:46.430
In fact,
you can only edit a row in Finder if you

00:20:46.480 --> 00:20:49.940
click on text in an already selected row.

00:20:49.950 --> 00:20:51.920
And it actually happens
in a slight delay,

00:20:51.920 --> 00:20:55.480
so you can actually do a double click and
have a double click action take effect,

00:20:55.530 --> 00:20:57.920
or a single click
action to begin editing.

00:20:58.200 --> 00:21:00.240
So how does the table make that work?

00:21:00.260 --> 00:21:05.540
The table overrides hitTest and
doesn't let the hitTest go to the view,

00:21:05.540 --> 00:21:07.360
if certain conditions are met.

00:21:07.380 --> 00:21:12.030
And the way it does it is it calls
a new responder method on itself,

00:21:12.030 --> 00:21:15.520
validateProposedFirstResponder for event.

00:21:15.520 --> 00:21:19.940
So it takes that view that you clicked on
and calls it with that as the responder,

00:21:20.010 --> 00:21:22.780
passes the event that was coming in,
and the table then

00:21:22.870 --> 00:21:26.920
implements this and says,
"Okay, is this something with text

00:21:26.920 --> 00:21:30.230
that needs to be editing?" Yes,
it is.

00:21:30.240 --> 00:21:34.520
Well, I'm going to save off what would be
the first responder and just wait

00:21:34.520 --> 00:21:36.640
until the double click interval passes.

00:21:36.970 --> 00:21:40.770
After the double click interval passes,
the table just calls makeFirstResponder

00:21:40.770 --> 00:21:42.820
on it and it starts to edit.

00:21:42.970 --> 00:21:47.780
This way, a double click action could
fire and it will stop that.

00:21:48.330 --> 00:21:49.210
Now why is this important?

00:21:49.320 --> 00:21:53.760
We use a developer could subclass and
override this and add your own behavior.

00:21:53.800 --> 00:21:57.690
Or you could have a control which is in
a table that might want to do something

00:21:57.860 --> 00:21:59.850
only if the table says it can do it.

00:22:00.070 --> 00:22:04.130
So you inside your control could call
validate proposed first responder up

00:22:04.160 --> 00:22:07.460
the responder chain and the table,
if it's there,

00:22:07.470 --> 00:22:11.860
could do certain things that
prevent editing or prevent like

00:22:11.870 --> 00:22:14.090
the IBM cursor from showing up.

00:22:16.090 --> 00:22:20.000
Alright, so that's basic construction
of a View-based TableView.

00:22:20.040 --> 00:22:24.120
Let's move on and talk a little bit
about bindings and how they work.

00:22:24.170 --> 00:22:27.100
So how do you bind content
for a particular cell?

00:22:27.150 --> 00:22:30.670
You can still use an NSArrayController,
except you will use the

00:22:30.670 --> 00:22:33.940
NSArrayController only to bind
the content of the TableView.

00:22:34.000 --> 00:22:37.270
You will not use an NSTableColumn
and set up properties on that,

00:22:37.360 --> 00:22:41.140
because that only applies to
the NSCell in the TableColumn.

00:22:41.390 --> 00:22:44.350
Now here is where you could
implement that TableView object

00:22:44.350 --> 00:22:48.520
value for TableColumnRow method
and actually return something.

00:22:48.580 --> 00:22:51.860
So if you don't want to use an
array controller for your object,

00:22:51.920 --> 00:22:55.430
but you still want to use bindings,
you implement this delegate

00:22:55.900 --> 00:22:58.800
method and you can return
your model object from here.

00:22:58.860 --> 00:23:02.610
So let's see if you do that,
how it would actually work.

00:23:03.260 --> 00:23:08.040
Simple Object Value Type of
View This is our view which we

00:23:08.040 --> 00:23:10.240
gave an identifier of DateCell.

00:23:10.330 --> 00:23:14.560
It's just a basic NSTextField.

00:23:15.340 --> 00:23:18.000
NSTextField implements SetObjectValue.

00:23:18.030 --> 00:23:21.720
The table says, "Hey, view there,
do you respond to

00:23:21.720 --> 00:23:23.750
SetObjectValue?" You do?

00:23:24.260 --> 00:23:24.260
OK.

00:23:24.300 --> 00:23:28.620
I'll take whatever object value I have,
either from the delegate

00:23:28.660 --> 00:23:32.800
method or the array controller,
and call SetObjectValue on you.

00:23:32.840 --> 00:23:37.520
Now, this is pretty much what regular
NSCell-based TableViews were

00:23:37.530 --> 00:23:39.240
doing for the longest time.

00:23:39.410 --> 00:23:42.110
Nothing really special about here.

00:23:42.160 --> 00:23:47.030
So let's take a look at a
complex object value example.

00:23:47.190 --> 00:23:50.100
So this cell here,
which we would call the main cell,

00:23:50.270 --> 00:23:54.100
it has more than one property
that we want to bind to.

00:23:54.110 --> 00:23:57.340
Before it was difficult to do more
than one binding inside of a cell.

00:23:57.630 --> 00:23:59.890
So how are we going to solve that?

00:24:00.790 --> 00:24:04.960
The answer is to use
NSTableCellView as your whole cell.

00:24:04.960 --> 00:24:08.700
NSTableCellView also has
an object value property.

00:24:08.780 --> 00:24:11.670
And so again the table is going
to see that it has it there,

00:24:11.780 --> 00:24:13.700
call it, and set the object value.

00:24:13.860 --> 00:24:18.700
So that means the whole cell has
this object value inside of it.

00:24:18.920 --> 00:24:23.700
What you can do with that is you can
do a binding from that particular view,

00:24:23.700 --> 00:24:27.700
like the image,
to the cell view's object value,

00:24:27.700 --> 00:24:29.670
and then any model object
properties you have,

00:24:29.740 --> 00:24:30.700
like the image.

00:24:30.700 --> 00:24:32.700
Or your text field.

00:24:32.700 --> 00:24:34.700
You could do cellview
object value dot title.

00:24:34.700 --> 00:24:38.700
So that's how you can really
easily do bindings inside of it.

00:24:38.700 --> 00:24:41.660
So let's take a look at how you
set them up inside of Xcode 4.

00:24:41.710 --> 00:24:47.700
So this has got the text field selected
inside of the design time environment.

00:24:47.780 --> 00:24:50.500
And the things to point out here
is that there's a new binding

00:24:50.520 --> 00:24:51.700
target that you can select.

00:24:51.700 --> 00:24:54.690
You can select the cell that
that actual view lives in.

00:24:54.700 --> 00:24:56.120
Zen.

00:24:56.590 --> 00:24:58.920
If you're binding to that,
there's always going to be

00:24:59.020 --> 00:25:00.370
an object value property.

00:25:00.370 --> 00:25:03.780
So you can bind to the object
value of that title in this case.

00:25:03.910 --> 00:25:06.930
So that's pretty easy to set up and do.

00:25:08.500 --> 00:25:23.000
[Transcript missing]

00:25:23.460 --> 00:25:27.290
"And we can just automatically use
that same identifier to find a view

00:25:27.290 --> 00:25:29.300
that you designed at design time.

00:25:29.300 --> 00:25:31.960
So again in the
TableView Playground demo here,

00:25:32.040 --> 00:25:34.380
if I go ahead and
select the table column,

00:25:34.380 --> 00:25:38.340
the thing that's interesting to point
out is that the identifier is set

00:25:38.340 --> 00:25:40.740
to sample window cell in this case.

00:25:41.010 --> 00:25:45.120
Now if I select that cell, and again,
you could have multiple columns,

00:25:45.120 --> 00:25:47.160
or you could have multiple cells.

00:25:47.170 --> 00:25:49.500
In this case it's just a
one column and one cell.

00:25:49.580 --> 00:25:53.210
But the interesting thing here is
that that cell's identifier exactly

00:25:53.300 --> 00:25:55.450
matches the table column's identifier.

00:25:55.740 --> 00:25:58.270
And if it matches,
the TableView will go ahead and

00:25:58.270 --> 00:26:02.160
automatically use that cell from the Nib,
and you don't have to implement

00:26:02.240 --> 00:26:03.840
that delegate method at all.

00:26:04.530 --> 00:26:07.000
Now, you're probably thinking, "Oh, well,
it might suck to keep

00:26:07.250 --> 00:26:10.310
those two things in sync,
because now I have to rename it in

00:26:10.310 --> 00:26:13.160
one spot and rename it in another
spot and do a bunch of work.

00:26:13.310 --> 00:26:17.040
And if one's not set,
you might get no views showing." Well,

00:26:17.040 --> 00:26:20.660
we have a solution Xcode for,
and it's called Automatic Identifiers.

00:26:20.770 --> 00:26:25.530
So what you can do is when you
select the table column or the cell,

00:26:25.680 --> 00:26:28.490
you just set the user interface
identifier to Automatic,

00:26:28.610 --> 00:26:30.120
which is the default value.

00:26:30.240 --> 00:26:33.450
And what's going to happen here
is we will automatically create

00:26:33.510 --> 00:26:36.730
an identifier for you and keep
the two for the table column and

00:26:36.730 --> 00:26:38.760
the cell in sync automatically.

00:26:38.820 --> 00:26:41.130
So it makes it easy to do.

00:26:42.290 --> 00:26:47.310
So let's move on and talk about
customizing a View-based TableView.

00:26:51.840 --> 00:26:55.840
I'm going to show another demo
application called the Hover Table Demo.

00:26:55.960 --> 00:26:58.730
Again, you can download this on
the developer site and play

00:26:58.810 --> 00:27:00.500
around with the source code.

00:27:00.570 --> 00:27:04.210
Some interesting things here is
when I hover over a particular row,

00:27:04.300 --> 00:27:05.940
it does a cool hover animation.

00:27:05.960 --> 00:27:08.000
I'm going to show how to do that.

00:27:08.040 --> 00:27:10.400
When I select a row,
a couple things happen.

00:27:10.620 --> 00:27:15.410
It draws custom selection and
the text field's text turns bold.

00:27:15.480 --> 00:27:17.520
I'm going to show how to do that.

00:27:17.610 --> 00:27:19.500
Another thing it's doing,
which is a little more subtle,

00:27:19.560 --> 00:27:24.620
is the horizontal separators
are actually a subtle little

00:27:24.740 --> 00:27:26.860
gradient to give it this cool look.

00:27:26.910 --> 00:27:29.680
I'm going to show how to do that too.

00:27:37.240 --> 00:27:39.640
How do you do custom row selection now?

00:27:39.670 --> 00:27:43.040
You can subclass NSTableRowView to do it.

00:27:43.070 --> 00:27:46.900
NSTableRowView has a bunch of
hooks to customize drawing.

00:27:47.040 --> 00:27:50.800
You can override DrawSelection and Rect,
and I'm not going to go over the code,

00:27:50.850 --> 00:27:54.530
but all it's going to do in this
particular case is create a Bezier

00:27:54.530 --> 00:27:59.260
path and fill it with a light grey
color and a darker grey stroke.

00:27:59.260 --> 00:28:02.280
It's really easy to customize selection.

00:28:02.480 --> 00:28:05.920
Now, what was hard before to
customize selection with is,

00:28:05.970 --> 00:28:10.900
how do you know if that table should
draw in the active or inactive state?

00:28:10.930 --> 00:28:14.330
So when the table is first responder,
it would usually have a blue highlight,

00:28:14.330 --> 00:28:16.270
and when it's not,
like in a background window

00:28:16.290 --> 00:28:20.060
or not the first responder,
it would draw a selection with a gray.

00:28:20.090 --> 00:28:22.210
And the way that you can do
that is you can look at the

00:28:22.330 --> 00:28:23.960
rowView property emphasized.

00:28:23.980 --> 00:28:28.060
If emphasized is set to yes,
it should draw in the active state,

00:28:28.060 --> 00:28:30.810
and if it's no, the inactive.

00:28:31.580 --> 00:28:34.770
Now how do you do that
bold selected text?

00:28:34.880 --> 00:28:38.370
And so when the selection changes,
you get the typical delegate method,

00:28:38.370 --> 00:28:40.500
TableViewSelectionDidChange.

00:28:40.560 --> 00:28:44.250
Now what's new here is you as a
developer want to enumerate all

00:28:44.250 --> 00:28:46.070
the views the table knows about.

00:28:46.200 --> 00:28:49.930
You could try and get all the views
in the visible rect and work on those,

00:28:49.930 --> 00:28:52.640
but I said before,
well there might be some extra views

00:28:52.670 --> 00:28:55.700
floating around with animations,
or a view might be the first

00:28:55.710 --> 00:28:59.040
responder and scrolled away from
the visible rect but still around.

00:28:59.150 --> 00:29:02.260
So you want to enumerate
everything the table knows about.

00:29:02.300 --> 00:29:05.810
So you're going to call
enumerateAvailableRowViews using block,

00:29:05.840 --> 00:29:10.510
and you're going to pass a block
which takes the row view and the row

00:29:10.600 --> 00:29:13.990
that the table has and knows about.

00:29:15.220 --> 00:29:17.900
So you have the row view,
and the row view stores these views.

00:29:17.900 --> 00:29:21.020
So you can use a View at
Column to find that particular

00:29:21.060 --> 00:29:23.000
view for the first column.

00:29:23.420 --> 00:29:25.450
Before we saw the view
had a text field outlet,

00:29:25.600 --> 00:29:27.980
so we can go ahead and
grab the text field outlet.

00:29:28.070 --> 00:29:29.800
We can access some
properties on the row view,

00:29:29.800 --> 00:29:31.800
like if it's selected or not.

00:29:31.910 --> 00:29:35.660
And then based on that, well,
if it's selected, let's use a bold font.

00:29:35.870 --> 00:29:39.400
If it's not selected,
let's use just a regular system font.

00:29:39.490 --> 00:29:43.340
So it's pretty darn easy to
enumerate all the row views and

00:29:43.340 --> 00:29:46.740
all the views and update one
particular property that you want.

00:29:46.820 --> 00:29:49.470
It's also quite efficient and fast to do.

00:29:50.990 --> 00:29:53.670
So how do you do this hover effect
when you mouse over and it does

00:29:53.670 --> 00:29:55.410
this kind of cool little gradient?

00:29:55.500 --> 00:29:57.490
Let me show how to do that.

00:30:00.730 --> 00:30:03.700
What you're going to do is just
use the typical NSView method,

00:30:03.720 --> 00:30:06.470
update tracking areas,
to go ahead and update

00:30:06.470 --> 00:30:08.170
some tracking areas.

00:30:08.260 --> 00:30:11.020
In this case,
it's going to allocate a tracking area

00:30:11.020 --> 00:30:13.580
and store it in an INVAR of the row view.

00:30:13.630 --> 00:30:16.190
If that's not in our
tracking areas array,

00:30:16.200 --> 00:30:21.110
it'll call add tracking area on itself,
and it has the tracking area set up.

00:30:21.660 --> 00:30:25.460
The tracking area will then give the row
view a mouse entered and mouse exited

00:30:25.460 --> 00:30:27.680
event when the mouse comes in and goes.

00:30:27.740 --> 00:30:31.700
And so all we're going to do is
set a bit under our mouse inside

00:30:31.990 --> 00:30:36.060
to know when the mouse is inside
of us and let us redisplay.

00:30:36.100 --> 00:30:39.390
And of course, mouse exited,
it'll undo that.

00:30:39.780 --> 00:30:41.740
So then in our drawing method,
again there are lots

00:30:41.740 --> 00:30:42.800
of great drawing hooks.

00:30:42.920 --> 00:30:45.630
You can subclass and override,
draw background and erect.

00:30:45.860 --> 00:30:50.380
You can fill with that background
color that I talked about way long ago.

00:30:50.660 --> 00:30:53.220
You can check your bit to see
if the mouse is inside of you.

00:30:53.450 --> 00:30:58.100
And if it is, you can allocate a gradient
and just fill with a gradient.

00:30:58.200 --> 00:31:02.090
And that's how you can do that
hover effect really easily.

00:31:03.640 --> 00:31:05.530
How do you do the custom separators?

00:31:05.540 --> 00:31:07.730
It's kind of hard to see
that separator again,

00:31:07.730 --> 00:31:10.600
but it's a nice little cool gradient.

00:31:10.630 --> 00:31:14.540
And what you can do is you can
override draw separator in Rect.

00:31:14.690 --> 00:31:16.550
For the row view,
you are responsible for drawing

00:31:16.600 --> 00:31:20.480
the bottom of the separator,
or the bottom separator.

00:31:20.500 --> 00:31:24.040
The previous rows will draw
the top separator above you.

00:31:24.080 --> 00:31:26.080
So you're going to grab your bounds.

00:31:26.170 --> 00:31:28.480
You want to draw at the bottom,
so you're going to get the

00:31:28.510 --> 00:31:31.240
maxY of your separator,
or maxY of your bounds.

00:31:31.270 --> 00:31:33.040
Set the height to 1.

00:31:33.060 --> 00:31:36.060
And then the interesting thing is you're
going to probably use a common method

00:31:36.400 --> 00:31:40.580
called DrawSeparatorInRect to do the
fill of the separator however you want.

00:31:40.600 --> 00:31:43.390
Now I'm going to show
why in just a second.

00:31:44.400 --> 00:31:49.340
So the row view draws its own separator
so that it can move around with the row

00:31:49.340 --> 00:31:51.980
view itself when an animation happens.

00:31:52.100 --> 00:31:56.090
But how do you deal with these
empty separators that are at the

00:31:56.090 --> 00:32:00.270
bottom of the table view when
you have more content to show?

00:32:01.120 --> 00:32:04.690
Well, the TableView already has a method
to customize the grid drawing,

00:32:04.690 --> 00:32:06.430
called DrawGridAndClipRect.

00:32:06.690 --> 00:32:11.100
So here you can override that and
do some custom separator drawing.

00:32:11.360 --> 00:32:14.530
The code is a little bit more complex,
but what you want to do is you don't

00:32:14.590 --> 00:32:18.300
need to draw those separators for
the spots where all the rows are at.

00:32:18.320 --> 00:32:21.700
So you grab the maxY of the last row.

00:32:21.750 --> 00:32:25.570
You're going to go past it because that
last row drew it separate at the bottom.

00:32:25.680 --> 00:32:29.090
And now the code is going to
scroll up to the next page.

00:32:29.220 --> 00:32:31.550
You're going to do what you did before,
basically,

00:32:31.550 --> 00:32:33.660
which is you're going to figure
out the bounds for the separator

00:32:33.660 --> 00:32:35.100
that you want to draw in.

00:32:35.140 --> 00:32:39.100
You're going to enumerate until you're
actually at the bottom of your view.

00:32:39.100 --> 00:32:42.090
And you're just going to
call that same method before,

00:32:42.090 --> 00:32:44.900
drawSeparatorInRect,
to go ahead and draw a separator.

00:32:45.100 --> 00:32:48.100
So it's pretty easy to do that too.

00:32:48.860 --> 00:32:50.400
So you have this custom row view.

00:32:50.460 --> 00:32:53.480
How are you going to actually
tell the table about the row view?

00:32:53.540 --> 00:32:57.010
Well, there's a new delegate method,
TableViewRowViewForRow,

00:32:57.010 --> 00:32:59.860
which allows you to go ahead
and allocate a row view,

00:32:59.920 --> 00:33:03.030
your custom one,
set any custom properties you want,

00:33:03.160 --> 00:33:04.800
and return the result.

00:33:04.870 --> 00:33:08.630
Now, another thing to note here, again,
the frame isn't really important.

00:33:08.700 --> 00:33:13.260
You could use the row height if you want,
but the table will control the frame,

00:33:13.380 --> 00:33:16.570
and so you can kind of specify
whatever you want there.

00:33:17.900 --> 00:33:35.500
[Transcript missing]

00:33:36.090 --> 00:33:39.800
But even that's optional,
so you don't even have to do that,

00:33:39.800 --> 00:33:41.970
and you can do it all at design time.

00:33:42.100 --> 00:33:45.480
So here's how you can specify a
rowview at design time without

00:33:45.490 --> 00:33:47.640
having to write any code at all.

00:33:47.670 --> 00:33:51.260
I have the row view selected here,
and the thing that is unique

00:33:51.690 --> 00:33:55.320
and must be pointed out is that
there's a special user interface

00:33:55.360 --> 00:33:57.100
item identifier that is set.

00:33:57.440 --> 00:34:00.060
NSTableViewRowViewKey.

00:34:00.170 --> 00:34:03.420
If you use this special identifier,
which is in the header,

00:34:03.510 --> 00:34:07.510
then the table automatically
search for and find that row

00:34:07.510 --> 00:34:09.470
view and use it for all the rows.

00:34:09.610 --> 00:34:13.060
And then you don't have
to write a delegate method

00:34:13.060 --> 00:34:15.120
or any code to specify it.

00:34:15.190 --> 00:34:20.110
So let's do another demo of drag
and drop in TableView Playground.

00:34:27.700 --> 00:34:33.120
So if I go ahead and show the
complex outline view example,

00:34:33.140 --> 00:34:37.230
I want to show some drag and drop
features and talk about them again.

00:34:38.550 --> 00:34:41.460
So one thing that's important
to note when I start dragging,

00:34:41.460 --> 00:34:44.240
there is two separate
rows that were dragged,

00:34:44.240 --> 00:34:47.100
and I want to show how to
create two separate rows.

00:34:47.180 --> 00:34:50.700
When I let go, it's subtle,
but what happens is the

00:34:50.770 --> 00:34:54.570
table opened up a gap,
and then the drag image actually animated

00:34:54.730 --> 00:35:01.400
from where you had the drag image all
the way to that gap's ending location.

00:35:01.500 --> 00:35:04.090
So I want to show how to do that.

00:35:09.740 --> 00:35:11.210
Multi-image dragging.

00:35:11.320 --> 00:35:14.230
Previously, you would have one huge
drag image for the table.

00:35:14.440 --> 00:35:17.900
Now,
you can have multiple NSDraggingItems.

00:35:17.940 --> 00:35:20.610
If we take a look at NSDraggingItem,
hopefully you went to

00:35:20.610 --> 00:35:21.760
Raleigh's talk yesterday.

00:35:21.910 --> 00:35:25.800
If you didn't, I'm going to do a quick
review on NSDraggingItem.

00:35:25.870 --> 00:35:29.820
The dragging item has an item,
which is the pasteboard reader or writer

00:35:29.820 --> 00:35:32.140
that specifies the pasteboard data.

00:35:32.200 --> 00:35:35.130
It has a whole frame for
that particular item,

00:35:35.360 --> 00:35:38.980
because inside of it you're
going to have an image component.

00:35:39.040 --> 00:35:43.290
Or really, you might have more than
one image component.

00:35:43.290 --> 00:35:43.290
In this case, there's two.

00:35:43.500 --> 00:35:46.560
So that's what an
NSDraggingItem is composed of.

00:35:46.580 --> 00:35:49.960
The API for it, to create one when you
put it on the pasteboard,

00:35:49.970 --> 00:35:52.080
is using initWithPasteboardWriter.

00:35:52.080 --> 00:35:55.720
So you provide your pasteboard
data for the dragging item,

00:35:55.740 --> 00:35:59.360
and then you're going to provide
an ImageComponentsProvider.

00:35:59.380 --> 00:36:02.120
This provides all those image components.

00:36:02.140 --> 00:36:05.880
Now, it's an array of
NSDraggingImageComponents,

00:36:05.890 --> 00:36:10.150
and it's a block because you don't want
to provide all the components all at

00:36:10.150 --> 00:36:12.720
once because they all may not be visible.

00:36:12.730 --> 00:36:16.440
You don't want to drag 20,000
rows and create 20,000 images.

00:36:16.440 --> 00:36:20.580
The dragging system will call you back
and create them only when they're needed.

00:36:21.690 --> 00:36:23.600
So how do you put an
item on the pasteboard?

00:36:23.680 --> 00:36:27.250
There's a new TableView method,
PasteboardWriterForRow.

00:36:27.250 --> 00:36:29.750
And what you're going to do
here is for that particular row,

00:36:29.910 --> 00:36:33.480
you're just going to return something
that implements NSPasteboardWriting.

00:36:33.790 --> 00:36:35.790
So typically,
you might just make your model

00:36:35.790 --> 00:36:37.840
object implement NSPasteboardWriting.

00:36:37.960 --> 00:36:41.240
In this case, in the demo,
it's an ATDesktop entity

00:36:41.240 --> 00:36:42.760
that implements it.

00:36:43.980 --> 00:36:46.100
What's going to happen is
the table will automatically

00:36:46.770 --> 00:36:51.240
take that pasteboard writer,
create an NSDragging item for you,

00:36:51.260 --> 00:36:54.200
and use that to start the drag with.

00:36:55.240 --> 00:36:57.890
If you don't want that row to be dragged,
you can just return nil and

00:36:57.970 --> 00:37:01.020
that particular row will be
excluded from that dragging.

00:37:01.410 --> 00:37:03.300
So how do you implement
NSPaceboard Writer?

00:37:03.550 --> 00:37:04.870
Well, it's pretty easy.

00:37:05.010 --> 00:37:07.810
You will just implement the protocol,
and I'll show you in a

00:37:07.870 --> 00:37:09.060
second what you'll do.

00:37:09.160 --> 00:37:12.660
But for this particular example,
we have a file URL that is the main

00:37:12.670 --> 00:37:15.100
thing that we're dragging around.

00:37:15.560 --> 00:37:18.620
Our implementation will implement
the two required methods:

00:37:18.620 --> 00:37:22.480
writable types for pasteboard and
pasteboard property list for type.

00:37:22.600 --> 00:37:25.990
We have that file URL,
and its URL implements

00:37:26.020 --> 00:37:28.620
NSPasteboardWriter,
so we're just going to delegate those

00:37:28.670 --> 00:37:30.930
methods directly to our file URL.

00:37:31.060 --> 00:37:34.150
That's how we can easily
add drag and drop support,

00:37:34.170 --> 00:37:36.930
or drag source support, from the table.

00:37:37.960 --> 00:37:40.020
Now how do you provide those drag images?

00:37:40.070 --> 00:37:43.670
Because that NSDraggingItem has
those image components provider to

00:37:43.710 --> 00:37:45.710
provide a couple image components.

00:37:45.710 --> 00:37:48.710
So like the image and text
is being dragged around.

00:37:51.340 --> 00:37:54.960
Each of those is an
NSDraggingImage component.

00:37:55.050 --> 00:37:59.600
They have a key to
identify what type it is,

00:37:59.600 --> 00:38:01.890
in this case it would be an icon,
and a contents, which is the actual image

00:38:01.890 --> 00:38:03.670
that's being dragged around.

00:38:05.710 --> 00:38:08.100
Drag around two images.

00:38:08.100 --> 00:38:16.700
One with a key of
NSDraggingImageComponentIconKey.

00:38:16.700 --> 00:38:16.700
This is the main icon the
dragging system will know about.

00:38:16.790 --> 00:38:21.610
The other one is a label key
to specify the label portion.

00:38:22.010 --> 00:38:25.660
That way the dragging system can
animate the label portion from one

00:38:25.660 --> 00:38:30.590
view to the label portion of another
view and move it around as necessary.

00:38:31.050 --> 00:38:33.900
Now, these can be automatically
provided by you,

00:38:34.140 --> 00:38:36.410
or for you, by NSTableCellView.

00:38:36.570 --> 00:38:40.880
There's a dragging image components
method on NSTableCellView,

00:38:40.880 --> 00:38:44.980
and what that does is it goes ahead and
uses your two properties that you set up.

00:38:45.070 --> 00:38:48.040
Again, the outlets from the text
field and image view.

00:38:48.040 --> 00:38:51.660
If you as a developer set those up,
then the dragging image components

00:38:51.660 --> 00:38:55.590
will automatically provide those for
you without having to do any work.

00:38:56.770 --> 00:39:00.000
Then the question is, well,
what if you have another one that

00:39:00.000 --> 00:39:03.790
you want to provide an image for,
like the color or something?

00:39:04.450 --> 00:39:06.590
Let's show how you would do that.

00:39:06.590 --> 00:39:10.450
You can subclass NSTableCellView,
override dragging image components,

00:39:10.560 --> 00:39:12.220
call super,
which is going to give you those

00:39:12.220 --> 00:39:14.520
components for the image and text.

00:39:14.580 --> 00:39:16.910
They're going to have to create
an NSDraggingImage component

00:39:17.200 --> 00:39:18.320
with your key that you want.

00:39:18.500 --> 00:39:21.240
In this case, we could call it color.

00:39:21.300 --> 00:39:24.660
You're going to set the contents
to be an image that represents

00:39:24.660 --> 00:39:26.150
your view being dragged.

00:39:26.280 --> 00:39:29.240
It's pretty easy to do,
and inside of the sample application,

00:39:29.240 --> 00:39:31.000
I show how to do it.

00:39:31.060 --> 00:39:34.960
You're going to set the frame with
respect to the cell view's bounds,

00:39:35.010 --> 00:39:39.290
so it does a convert rect of the
color view's bounds from the color

00:39:39.290 --> 00:39:41.560
view into our own coordinate system.

00:39:41.690 --> 00:39:44.200
Then you just add it to
the result and return it.

00:39:44.310 --> 00:39:48.870
That's how you get that extra drag
image to be dragged from your cell view.

00:39:49.590 --> 00:39:51.300
How do you change a drag image?

00:39:51.300 --> 00:39:54.610
In Finder, if you have a big icon view
with a big image and text,

00:39:54.610 --> 00:39:59.070
when you drag it over the TableView,
you want to go ahead and morph into

00:39:59.070 --> 00:40:01.170
something that the table knows about.

00:40:01.260 --> 00:40:04.980
You want the image to shrink and
the text to move over to the right.

00:40:05.050 --> 00:40:07.060
How do you do that?

00:40:07.120 --> 00:40:09.420
You want to be a dragging destination.

00:40:09.480 --> 00:40:12.410
What you can implement is
a new Lion method called

00:40:12.410 --> 00:40:15.220
OutlineView UpdateDraggingItemsForDrag.

00:40:16.300 --> 00:40:18.130
Inside of this,
you're going to want to take that

00:40:18.130 --> 00:40:22.270
pasteboard data that's being dragged
over you and create a view and

00:40:22.400 --> 00:40:26.280
create dragging image components
for it to automatically animate from

00:40:26.400 --> 00:40:30.480
what was dragged over you to what,
or from the source to what's going to be

00:40:30.580 --> 00:40:32.960
you and your particular representation.

00:40:33.830 --> 00:40:37.580
You create an NSTable CellView with
MakeViewWithIdentifier.

00:40:37.800 --> 00:40:41.360
You're going to use that
to stamp out the images.

00:40:41.420 --> 00:40:44.870
You also set up a cell frame
for your particular row,

00:40:44.870 --> 00:40:47.750
just setting up your width and height.

00:40:49.200 --> 00:40:59.000
[Transcript missing]

00:40:59.380 --> 00:41:03.150
And then you're going to call a
new method on NSDraggingInfo called

00:41:03.170 --> 00:41:06.710
EnumerateDraggingItemsWithOptions
for View,

00:41:06.710 --> 00:41:09.920
Classes, Search Options, Using Block.

00:41:10.070 --> 00:41:13.240
I'm going to highlight some of
the important parts about it,

00:41:13.240 --> 00:41:17.060
but you get this block callback
for every instance of the model

00:41:17.060 --> 00:41:19.720
object that could be created.

00:41:19.880 --> 00:41:22.520
We're going to look at the dragging
item and kind of ignore the index

00:41:22.520 --> 00:41:26.640
and stop parameters because we aren't
going to do anything special with him.

00:41:27.300 --> 00:41:45.300
[Transcript missing]

00:41:45.580 --> 00:41:50.240
What you do inside of here is
you have your sample cell view,

00:41:50.300 --> 00:41:54.380
you set the dragging item
to it as your object value.

00:41:54.440 --> 00:41:57.420
Now this dragging item,
that was automatically created

00:41:57.420 --> 00:41:58.750
from the classes there.

00:41:58.950 --> 00:42:02.790
So the classes, which you have specified
as your model objects,

00:42:02.990 --> 00:42:05.440
are how that gets into the item.

00:42:05.480 --> 00:42:10.350
So the dragging info created an
AT Desktop entity for us with the

00:42:10.350 --> 00:42:13.910
Pasteboard reader automatically.

00:42:14.040 --> 00:42:19.290
Set the object value, bindings,
and what not to display things.

00:42:19.510 --> 00:42:20.490
Set up the frame.

00:42:20.750 --> 00:42:23.960
And again, the CellView has the
dragging image components.

00:42:24.210 --> 00:42:27.100
We'll use that to return the
dragging image components.

00:42:27.280 --> 00:42:29.150
And it gets whatever
stuff we added to it,

00:42:29.170 --> 00:42:33.310
or whatever stuff the table
implements automatically for us.

00:42:34.910 --> 00:42:39.840
So how do we accept a drop and do
that animation I was talking about?

00:42:39.870 --> 00:42:45.360
So we want the table to open up the gap,
and wherever the drag image is located,

00:42:45.390 --> 00:42:49.020
drag from that location
right to our final location.

00:42:49.040 --> 00:42:51.790
So let's see how to go ahead and do that.

00:42:52.800 --> 00:42:55.940
So first, you have to tell the
dragging system that,

00:42:56.060 --> 00:42:59.200
well, you accept the drop,
and you want to do an animation.

00:42:59.300 --> 00:43:03.810
OutlineView validateDrop proposed
child index is a very old

00:43:03.810 --> 00:43:06.340
delegate method to accept a drop.

00:43:06.670 --> 00:43:09.000
So you'll do your typical
pasteboard validation,

00:43:09.050 --> 00:43:12.600
and you can look at the demo
application to see how we do it.

00:43:13.170 --> 00:43:17.370
We're going to set a new parameter
on Lion called AnimatesToDestination

00:43:17.370 --> 00:43:18.800
on the dragging info.

00:43:18.860 --> 00:43:20.870
That's telling the drag subsystem that,
hey,

00:43:21.020 --> 00:43:24.810
you do want to animate and you're going
to do an animation from that source

00:43:24.860 --> 00:43:28.740
location of the drag image to your
final location of where your row is.

00:43:28.790 --> 00:43:31.080
So that's important to set.

00:43:32.520 --> 00:43:35.360
Now, how do you actually accept the drop?

00:43:35.450 --> 00:43:39.780
You implement the old delegate method,
OutlineView acceptDrop, item,

00:43:39.780 --> 00:43:43.210
child index,
and TableView has a similar one.

00:43:44.240 --> 00:43:47.140
What you do inside of here is
what you would do when you were

00:43:47.150 --> 00:43:50.800
updating the dragging images,
except you want to actually accept the

00:43:50.800 --> 00:43:53.320
drop and put things into your model.

00:43:53.380 --> 00:43:57.610
So you're going to create another
array with your model objects of like

00:43:57.820 --> 00:43:59.860
ATDesktop entity in this example.

00:43:59.890 --> 00:44:04.890
And you're going to call enumerate
dragging items with options for view

00:44:04.940 --> 00:44:07.940
classes search options using block again.

00:44:08.410 --> 00:44:12.580
Let's take a look at your implementation
of what this block would look like.

00:44:12.700 --> 00:44:18.000
So again, that dragging item to item was
automatically created from the

00:44:18.150 --> 00:44:20.540
array that we passed to this method.

00:44:20.640 --> 00:44:24.540
So it used NSPaceboardReader to
automatically create your model object.

00:44:24.630 --> 00:44:28.330
So we grab our model object
and store it in a little local.

00:44:28.770 --> 00:44:33.160
We take that model object
and insert it into our array

00:44:33.380 --> 00:44:35.260
that we have for our model.

00:44:35.310 --> 00:44:38.010
In this OutlineView example,
it's just putting it directly

00:44:38.010 --> 00:44:39.380
into the children array.

00:44:40.610 --> 00:44:43.460
So that updated our model,
now we have to update the view.

00:44:43.480 --> 00:44:47.320
So the OutlineView has a new method,
insertItemsAtIndexes in

00:44:47.320 --> 00:44:49.280
parent with an animation.

00:44:49.290 --> 00:44:52.680
I'm gonna talk a little bit more
about animations in a second.

00:44:52.760 --> 00:44:55.320
And now what this does is
you pass an animation of an

00:44:55.430 --> 00:44:59.150
NSTableViewAnimationEffectGap,
and that's gonna tell the table, hey,

00:44:59.180 --> 00:45:02.820
open up a gap, 'cause we're gonna do
an animation into it.

00:45:02.830 --> 00:45:05.390
As soon as you call that method,

00:45:05.870 --> 00:45:10.360
At this point, the table can be thought
of in its final state.

00:45:10.390 --> 00:45:14.690
So you did an insert into the table,
the table knows that you did that.

00:45:14.910 --> 00:45:17.870
You can call methods on it,
like find out the row for that

00:45:17.870 --> 00:45:20.490
particular item you just inserted.

00:45:20.990 --> 00:45:25.170
You now have the row and you can
find the actual frame of that item

00:45:25.180 --> 00:45:30.140
using the typical table methods
like frame of cell at column row.

00:45:30.200 --> 00:45:33.140
And what you can do here is you'll
just update the dragging frame.

00:45:33.170 --> 00:45:36.080
So what this does is it's
telling that dragging item,

00:45:36.080 --> 00:45:42.140
hey, drag from wherever you are to this
final row location and animate it.

00:45:43.110 --> 00:45:47.600
So that was how you would do
drag and drop and accept it.

00:45:47.620 --> 00:45:51.310
Let's move on and talk a
little bit about animating.

00:45:52.820 --> 00:45:56.860
So there are three basic
methods to do an animation,

00:45:56.890 --> 00:45:59.900
and they are very similar
to NSMutableArray.

00:45:59.940 --> 00:46:04.180
What we have is insert rows
at indexes with animation,

00:46:04.200 --> 00:46:09.320
remove rows at indexes with animation,
and move row at index to index.

00:46:09.380 --> 00:46:11.280
These are the TableView methods.

00:46:11.310 --> 00:46:14.040
There are also equivalent
OutlineView ones,

00:46:14.040 --> 00:46:18.020
like I was previously showing a use of,
that insert into a particular

00:46:18.230 --> 00:46:21.560
outline item and the children
of that outline item.

00:46:21.620 --> 00:46:25.370
They work in a very similar way,
but I'm not going to cover them.

00:46:26.750 --> 00:46:28.800
How does this work?

00:46:28.840 --> 00:46:32.470
Insert rows at indexes
takes an index set.

00:46:32.680 --> 00:46:35.750
This is kind of pseudo code,
but let's say I pass an index

00:46:36.380 --> 00:46:40.760
set with indexes of 1 and 3
and see how it would work.

00:46:40.780 --> 00:46:45.320
What would happen is a hole
would open up for row 1 and

00:46:45.320 --> 00:46:47.750
that item would be inserted.

00:46:48.100 --> 00:46:52.300
A hole would open up for row 3,
and then that item would be inserted.

00:46:52.320 --> 00:46:57.020
So two new items that we pass in
would automatically be inserted.

00:46:57.600 --> 00:47:01.180
The cool thing to note here is
that by using these methods,

00:47:01.220 --> 00:47:03.660
the selection is automatically updated.

00:47:03.710 --> 00:47:08.400
So you don't have to worry about the
selection being stuck at the wrong row.

00:47:08.450 --> 00:47:11.960
This is much easier than using
something like ReloadData.

00:47:14.270 --> 00:47:16.460
Now what if you want to batch updates?

00:47:16.510 --> 00:47:20.160
So what if you have a bunch of
changes that you are going to do?

00:47:20.230 --> 00:47:24.160
You're going to insert a ton of rows,
remove a ton of rows.

00:47:24.210 --> 00:47:26.440
Well,
it's better for performance to batch

00:47:26.440 --> 00:47:31.080
them together inside of a begin updates
and end updates TableView block.

00:47:31.140 --> 00:47:33.850
The reason that you want to do this is,
let's say you go ahead

00:47:33.850 --> 00:47:36.330
and insert 100 rows,
and you call insert rows of

00:47:36.330 --> 00:47:39.920
indexes with 100 of them,
and then you delete those 100 rows,

00:47:39.980 --> 00:47:42.870
or you insert another 10 or 20.

00:47:43.210 --> 00:47:45.600
Any time you call that method,
the table will go ahead and

00:47:45.790 --> 00:47:48.290
create views and do an animation.

00:47:48.470 --> 00:47:52.200
Well, you don't want it to animate
those hundred rows which might

00:47:52.200 --> 00:47:56.220
not be on screen at the end of
your particular set of operations,

00:47:56.220 --> 00:47:58.980
because you might be inserting
and removing them right away.

00:47:59.170 --> 00:48:01.820
So if you batch them all together,
the table is smart enough to

00:48:01.910 --> 00:48:06.010
optimize it and do only what
the user would end up seeing.

00:48:06.320 --> 00:48:08.630
So for performance,
you want to call begin

00:48:08.630 --> 00:48:10.230
updates and end updates.

00:48:11.720 --> 00:48:13.590
Now how does this work?

00:48:13.600 --> 00:48:17.100
Now it's important to realize this is
actually a little bit different than the

00:48:17.100 --> 00:48:20.440
similar methods on iOS and UITableView.

00:48:20.560 --> 00:48:24.580
In that case, with UITableView,
it would sort of freeze the

00:48:24.630 --> 00:48:28.640
table's contents and you
could kind of modify each row.

00:48:28.760 --> 00:48:33.730
The one for NSTableView works much
more similar to NSMutableArray.

00:48:34.040 --> 00:48:36.600
So here's an example
of what I mean by that.

00:48:36.970 --> 00:48:39.880
You call begin updates,
do insert row at index

00:48:39.880 --> 00:48:42.520
with an index of 2,
opens up a slot,

00:48:42.610 --> 00:48:44.660
you get that new first row.

00:48:44.730 --> 00:48:48.400
You call it again, opens up a slot,
you get that new row.

00:48:48.470 --> 00:48:52.200
Now this isn't really too complex,
it's really just the way an array works.

00:48:52.200 --> 00:48:54.560
You're inserting it again and again.

00:48:54.660 --> 00:48:57.400
But this is different than iOS,
and if you tried to insert

00:48:57.400 --> 00:49:00.190
the row twice in iOS,
it might throw an exception.

00:49:00.350 --> 00:49:03.180
So I just want to point
out that difference there.

00:49:05.330 --> 00:49:07.770
Now how do you do row height animations?

00:49:07.910 --> 00:49:09.930
So one of the other
things I showed before,

00:49:09.980 --> 00:49:12.800
and this is a little video,
is how do you animate the

00:49:12.800 --> 00:49:14.500
row heights for the table?

00:49:14.620 --> 00:49:17.260
In addition,
the table is animating the row heights,

00:49:17.560 --> 00:49:20.320
but you own that cell view,
and inside that cell view some

00:49:20.330 --> 00:49:21.600
other things are happening.

00:49:21.660 --> 00:49:25.440
A couple views are fading away,
and the actual contents of

00:49:25.570 --> 00:49:27.140
the image are shrinking.

00:49:27.440 --> 00:49:30.220
So how do you go ahead and do that?

00:49:32.780 --> 00:49:37.020
What you're going to do is use note
height of rows with indexes changed.

00:49:37.320 --> 00:49:40.140
So this assumes you're using
variable row heights and using the

00:49:40.210 --> 00:49:42.120
variable row height delegate methods.

00:49:42.300 --> 00:49:45.170
You create your index set,
call this method,

00:49:45.180 --> 00:49:48.240
and now this method will
just always animate.

00:49:48.280 --> 00:49:51.700
So it always goes ahead
and animates for you.

00:49:51.700 --> 00:49:54.010
For every ViewBase TableView.

00:49:55.930 --> 00:50:01.260
So how do you take your views and
sync them with that animation?

00:50:01.300 --> 00:50:04.330
Well, the way you're going to do it
is use an animation context

00:50:04.780 --> 00:50:08.960
and do a begin grouping and end
grouping to group it all together.

00:50:09.000 --> 00:50:12.140
So inside of that,
you could do things like change

00:50:12.180 --> 00:50:14.200
the duration of the animation.

00:50:14.400 --> 00:50:18.380
You can update your views,
say do an animation to hide a view

00:50:18.520 --> 00:50:22.870
or change the size of the image view.

00:50:23.380 --> 00:50:26.460
Then you can go ahead and tell the table
to do its animation by calling note

00:50:26.570 --> 00:50:28.630
height of rows with indexes changed.

00:50:28.740 --> 00:50:29.890
It will animate.

00:50:30.090 --> 00:50:31.900
And then you end your grouping.

00:50:31.950 --> 00:50:34.540
They will all animate then together.

00:50:34.580 --> 00:50:38.290
Then that begs the question, well,
what if I don't want

00:50:38.290 --> 00:50:40.100
that method to animate?

00:50:40.170 --> 00:50:42.420
The way you can make any of
those methods to animate,

00:50:42.590 --> 00:50:46.670
such as the insert, remove,
and move methods,

00:50:46.670 --> 00:50:50.540
is you can create an animation
grouping and set the duration to zero.

00:50:50.560 --> 00:50:54.330
So if you set the duration to zero,
it will tell the table, hey,

00:50:54.390 --> 00:50:56.890
I really don't want
to animate this thing,

00:50:56.890 --> 00:50:58.170
so don't do that.

00:51:02.570 --> 00:51:06.870
Now, it would be really cool if all
these methods work within a cell.

00:51:07.130 --> 00:51:11.350
And in fact, all these methods will work
within an NSCell-based TableView.

00:51:11.560 --> 00:51:15.270
The insert, the remove, the move,
the height of rows with

00:51:15.270 --> 00:51:17.470
indexes changed will all work.

00:51:18.120 --> 00:51:20.170
But you have to do one thing.

00:51:20.170 --> 00:51:22.370
To make them work with
the NSL-based TableView,

00:51:22.570 --> 00:51:26.180
you have to call begin
updates and end updates.

00:51:26.340 --> 00:51:29.570
When you call begin updates,
what the TableView will do,

00:51:29.730 --> 00:51:34.830
it's going to draw all of your NSCells
into a temporary image and swap them

00:51:34.830 --> 00:51:39.510
out with a View-based TableView with
exactly what you were seeing there.

00:51:39.730 --> 00:51:43.730
You can then have an initial
state to do an animation from.

00:51:43.880 --> 00:51:47.600
So you can call insertRowsAtImages,
removeRowsAtIndexes or whatnot,

00:51:47.660 --> 00:51:50.190
and the animations will happen and work.

00:51:50.340 --> 00:51:54.120
This is actually how all the
animations work inside a Lion for

00:51:54.120 --> 00:51:58.350
outline views which were not
moved to a View-based TableView.

00:51:59.960 --> 00:52:03.490
And if you want to see an example,
the drag-and-drop OutlineView demo

00:52:03.490 --> 00:52:05.100
application was updated.

00:52:05.120 --> 00:52:08.470
You can go find it on the developer
site and see how it's done.

00:52:09.990 --> 00:52:14.680
So in summary, I talked about layout,
how tables are actually constructed,

00:52:14.780 --> 00:52:19.690
how a row view comes into play,
and how it all fits together.

00:52:19.850 --> 00:52:29.850
Construction, Data Source Methods,
and Design Time Layout.

00:52:29.850 --> 00:52:38.710
Bindings, Bind Content,
and Customizing TableViews.

00:52:38.820 --> 00:52:41.530
Download the Hover Table demo,
check it out,

00:52:41.530 --> 00:52:43.400
play around with the source.

00:52:43.410 --> 00:52:46.940
Talked about drag and drop,
creating dragging image components,

00:52:46.940 --> 00:52:50.800
and dragging multiple rows instead
of a big single drag image.

00:52:51.020 --> 00:52:55.760
And then finally I talked about animating
and how to do some cool animations.

00:52:56.690 --> 00:52:59.430
For more information,
contact Bill Dedeny,

00:52:59.430 --> 00:53:01.400
our Frameworks Evangelist.

00:53:01.420 --> 00:53:04.800
Our documentation has been updated
for the View-based TableView.

00:53:04.890 --> 00:53:06.420
We have the developer forums.

00:53:06.420 --> 00:53:10.350
I frequently browse around there
and answer table questions.

00:53:11.730 --> 00:53:14.070
We have related sessions.

00:53:14.070 --> 00:53:16.480
James Dempsey is giving our
Design Patterns to Simplify

00:53:16.480 --> 00:53:19.420
Mac Accessibility at 3:15 today.

00:53:19.600 --> 00:53:21.360
It's also the Song Talk.

00:53:21.420 --> 00:53:23.130
So I highly encourage you to go to that.

00:53:23.290 --> 00:53:26.580
He's going to talk about how to add
accessibility to View-based TableViews,

00:53:26.760 --> 00:53:28.690
which is really easy to do now.

00:53:28.820 --> 00:53:31.960
Before it was difficult to
add accessibility to NSCells.

00:53:32.050 --> 00:53:34.060
Now it's pretty easy
to make it with a view.
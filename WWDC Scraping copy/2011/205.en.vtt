WEBVTT

00:00:08.310 --> 00:00:10.490
Welcome to Networking In-Debt session.

00:00:10.700 --> 00:00:12.220
My name is Anil Vempati.

00:00:12.220 --> 00:00:15.720
I'm the manager of
CoreOS networking team.

00:00:16.480 --> 00:00:20.060
So in this session we will be covering
a few networking topics in depth.

00:00:20.060 --> 00:00:22.130
The first of the topics is IPv6.

00:00:22.420 --> 00:00:27.570
So you'll get to hear IPv6 in a nutshell
and the things you need to know as

00:00:27.680 --> 00:00:33.410
developers and what is happening
with IPv6 and also some of the recent

00:00:33.410 --> 00:00:36.490
improvements in iOS 5 and OS X Lion.

00:00:37.240 --> 00:00:39.420
Then we'll go over some
changes under the hood.

00:00:39.420 --> 00:00:43.200
And by this we mean is that networking
APIs themselves haven't changed,

00:00:43.370 --> 00:00:45.460
but a lot of underlying
functionality has.

00:00:45.610 --> 00:00:50.300
So we want to give you a preview of
what to expect with iOS 5 and Lion.

00:00:50.300 --> 00:00:53.930
So if you see any different behavior,
you can understand it

00:00:53.930 --> 00:00:55.590
and deal with it better.

00:00:55.720 --> 00:00:59.300
Also, iOS 4 introduced multitasking.

00:00:59.380 --> 00:01:03.290
What that means is if your app
has a network connection open and

00:01:03.290 --> 00:01:06.670
the user switches to another app,
then what happens to the

00:01:06.730 --> 00:01:08.000
connection that was open?

00:01:08.260 --> 00:01:11.380
What are the things you may need
to do after your app gets resumed?

00:01:11.540 --> 00:01:15.940
These topics will be covered in the
backgrounded connections section,

00:01:15.940 --> 00:01:16.900
a part of it.

00:01:17.280 --> 00:01:19.300
Then we have a couple
of interesting tools,

00:01:19.450 --> 00:01:23.540
one for simulating more realistic
network conditions so you can test

00:01:23.610 --> 00:01:27.910
your apps in realistic conditions
before they're ready for prime time.

00:01:28.010 --> 00:01:31.520
And then we have a second app,
a second tool for troubleshooting

00:01:31.530 --> 00:01:33.020
network connections.

00:01:33.110 --> 00:01:35.550
So these are the topics that
will be covered in this session.

00:01:35.640 --> 00:01:39.340
So to get started,
I'm going to hand it over to my colleague

00:01:39.340 --> 00:01:42.470
James Woodyatt to take you through IPv6.

00:01:46.610 --> 00:01:47.610
Thank you.

00:01:47.660 --> 00:01:48.500
Thank you.

00:01:48.560 --> 00:01:49.410
My name is James Woodyatt.

00:01:49.520 --> 00:01:53.480
I'm an internet protocol
droid in CoreOS Networking.

00:01:53.480 --> 00:01:55.120
And I'm here to talk about IPv6.

00:01:55.120 --> 00:01:58.800
And when I'm done in about 15 minutes,
hopefully,

00:01:58.800 --> 00:02:02.040
you will all know why there has never
been a better time than right now

00:02:02.040 --> 00:02:05.250
to get your apps to be IPv6 ready.

00:02:05.370 --> 00:02:08.300
I'm also going to,
in case you haven't been paying

00:02:08.350 --> 00:02:12.230
attention to IPv6 until it was
clear that it was time to move,

00:02:12.230 --> 00:02:16.390
I'm going to give you the basic
outline of what IPv6 is so that

00:02:16.440 --> 00:02:18.740
you're ready to get started.

00:02:18.840 --> 00:02:21.550
And finally I'm going to wrap up
by telling you what's in iOS 5 and

00:02:21.550 --> 00:02:27.140
Mac OS X Lion to make it so that when
you transition to IPv6 it will all

00:02:27.140 --> 00:02:31.410
be very seamless and ordinary users
will never need to know about it.

00:02:34.370 --> 00:02:38.130
I imagine most of you, for most of you,
the only thing you really know

00:02:38.130 --> 00:02:41.980
about IPv6 is that it doesn't
have 32-bit addresses like IPv4.

00:02:42.310 --> 00:02:44.410
But there's a lot more than that.

00:02:44.690 --> 00:02:48.640
And the reason we have to
move to IPv6 is that when we

00:02:48.640 --> 00:02:51.380
first built out the internet,
we didn't think it was going to last

00:02:51.500 --> 00:02:55.430
until 2011 with 32-bit addresses.

00:02:55.540 --> 00:02:59.700
Anybody here ever tried to light
up IPv6 on their home network?

00:03:00.250 --> 00:03:02.420
Wow, look at all those hands.

00:03:02.490 --> 00:03:04.440
Worked great, didn't it?

00:03:04.580 --> 00:03:06.960
You got to see the dancing turtle,
and then after that you went,

00:03:07.000 --> 00:03:11.140
"Is that it?"

00:03:13.120 --> 00:03:14.760
Things are happening now.

00:03:14.760 --> 00:03:20.480
As you may have noticed,
today is IPv6 day.

00:03:20.480 --> 00:03:20.480
And what that means

00:03:22.740 --> 00:03:25.300
Oh come on, I didn't work that hard.

00:03:25.390 --> 00:03:28.580
What that means is that all the
major content providers that you know

00:03:28.580 --> 00:03:33.050
like Google and Bing and Facebook,
Yahoo, CNN,

00:03:33.050 --> 00:03:37.280
a whole bunch of them all turned up
production ready IPv6 service on their

00:03:37.280 --> 00:03:40.300
front pages for 24 straight hours.

00:03:40.420 --> 00:03:44.180
Now why would they do this?

00:03:44.430 --> 00:03:48.170
The reason they need to do this is that

00:03:50.060 --> 00:03:55.230
They need to figure out how to get
their services over IPv6 instead

00:03:55.230 --> 00:04:00.240
of what the service providers,
many of them who are resisting IPv6,

00:04:00.310 --> 00:04:04.960
would rather they do,
which is cope with the fact that service

00:04:05.080 --> 00:04:08.610
providers are going to start aggregating
subscribers behind carrier grade

00:04:08.610 --> 00:04:13.710
NAT and then telling content providers,
perhaps you should think about locating

00:04:13.940 --> 00:04:16.150
your plex inside our address realm.

00:04:16.160 --> 00:04:20.310
And they're saying, well,
we'd rather actually get to IPv6 first.

00:04:20.340 --> 00:04:24.300
This is making the service
providers in turn have to move to

00:04:24.300 --> 00:04:26.720
bring up dual stack IPv6 service.

00:04:26.720 --> 00:04:30.510
So if you've been following the news,
you may have noticed that

00:04:30.510 --> 00:04:34.480
Comcast is trialing IPv6 dual
stack networks in Colorado.

00:04:34.480 --> 00:04:38.910
And earlier this week they announced
that they were going to be expanding

00:04:38.910 --> 00:04:43.330
their trial to San Francisco,
Philadelphia, Chicago, and Miramar,

00:04:43.330 --> 00:04:44.220
Florida.

00:04:44.220 --> 00:04:51.070
And also you may have noticed that
Verizon today will happily sell you a

00:04:51.070 --> 00:04:53.540
3G wireless card for your MacBook Pro.

00:04:53.560 --> 00:04:58.710
And then you can get IPv6 native
service directly over that on Mac.

00:04:58.710 --> 00:05:01.720
That's a useful addition.

00:05:01.720 --> 00:05:07.750
And as I have seen when I've been
participating with Apple in various

00:05:07.760 --> 00:05:13.360
interoperability events with the airport
base station and seeing the various home

00:05:13.360 --> 00:05:19.020
gateways come through to these tests,
I can see that...

00:05:19.200 --> 00:05:23.230
All of the major equipment vendors
are adopting IPv6 capabilities

00:05:23.270 --> 00:05:25.600
so that they will be ready too.

00:05:25.700 --> 00:05:28.750
So with the service providers being
pulled by the content providers and

00:05:28.770 --> 00:05:33.780
being pushed by the equipment vendors,
IPv6 is happening now and it's

00:05:33.810 --> 00:05:35.990
time to get your apps ready.

00:05:37.010 --> 00:05:39.830
So if you need to know about
IPv6 because you've been waiting

00:05:39.830 --> 00:05:42.790
for everybody else to move,
and now they have,

00:05:42.920 --> 00:05:46.620
let me give you a brief introduction
so that when you're looking at

00:05:46.620 --> 00:05:50.420
making your apps IPv6 ready,
you will know what you need to know

00:05:50.420 --> 00:05:53.090
about the protocol to make it happen.

00:05:53.400 --> 00:05:58.680
So IPv6 is a lot like the
original internet protocol.

00:05:58.680 --> 00:06:03.410
It still has the same
basic BSD sockets API.

00:06:03.560 --> 00:06:09.770
You still open sockets, bind, listen,
connect, send, receive, shut down.

00:06:09.780 --> 00:06:12.360
All of those are the same,
but the socket address structures

00:06:12.360 --> 00:06:15.510
are a little different because
they have bigger addresses in them.

00:06:15.520 --> 00:06:19.260
And the socket options that
you use for controlling fields

00:06:19.260 --> 00:06:22.990
that are in the headers,
they all change a little bit too.

00:06:23.320 --> 00:06:26.620
But there are some important new things.

00:06:26.820 --> 00:06:29.370
Remember in IPv4 there was
these addresses that looked like

00:06:29.370 --> 00:06:33.680
10.0.foo.bar.desk and 192.168.

00:06:33.680 --> 00:06:35.500
Well,
there's no equivalent of that in IPv6.

00:06:35.500 --> 00:06:37.290
The addresses are much larger.

00:06:37.430 --> 00:06:39.800
There's a universal routing realm.

00:06:40.060 --> 00:06:44.170
This means that if you have a
routable address on your host,

00:06:44.170 --> 00:06:47.450
that routable address is globally unique.

00:06:47.560 --> 00:06:50.910
You don't have to ask the network
what address somebody else on

00:06:50.910 --> 00:06:52.820
the network should send to you.

00:06:52.820 --> 00:06:54.970
It's attached to your interfaces.

00:06:54.980 --> 00:06:58.290
And this has a couple of
interesting follow-on consequences

00:06:58.290 --> 00:06:59.850
that I'll get into later.

00:06:59.860 --> 00:07:04.500
Also, there's an all-new internet
control message protocol that

00:07:04.500 --> 00:07:07.460
replaces the one that's in IPv4.

00:07:07.460 --> 00:07:10.040
And there's a bunch of features
to that that I'll also talk about.

00:07:10.040 --> 00:07:12.160
I don't know if you saw
that on another slide.

00:07:12.220 --> 00:07:17.130
But first I want to go back and talk
about the address structures because,

00:07:17.130 --> 00:07:21.150
let's face it,
the new addresses are kind of confusing.

00:07:21.290 --> 00:07:25.310
So they're a lot easier to understand
if you know a few basic things.

00:07:25.450 --> 00:07:28.640
There's a hierarchical allocation model.

00:07:29.850 --> 00:07:32.220
And the scopes are well defined.

00:07:32.220 --> 00:07:39.910
So in IPv4 the number space is sort
of allocated by the IANA and then

00:07:39.910 --> 00:07:43.820
the regional registries and you get
a subnet and you can split it up

00:07:43.820 --> 00:07:47.230
any way you want and when you're
looking at an IPv4 address it's hard

00:07:47.330 --> 00:07:48.950
to tell which parts of it are what.

00:07:49.150 --> 00:07:51.930
Well with IPv6 that's a
lot more standardized.

00:07:52.010 --> 00:07:56.680
And also part of that standardization
is that the scopes are really

00:07:56.680 --> 00:07:57.980
well defined by the standard.

00:07:57.980 --> 00:08:01.860
So there's,
and I'll talk about that in a little bit.

00:08:02.200 --> 00:08:05.330
But first I want to tell you about
the hierarchical allocation model.

00:08:05.400 --> 00:08:06.860
Here's an IPv4 address.

00:08:06.860 --> 00:08:07.640
It's 32 bits.

00:08:07.720 --> 00:08:08.720
It's pretty flat.

00:08:08.870 --> 00:08:11.000
There's not much you
know about what's in it.

00:08:11.140 --> 00:08:16.770
But an IPv6 address is A, a lot larger,
and B, it's really split into two parts.

00:08:16.900 --> 00:08:18.980
And this is important to know.

00:08:19.070 --> 00:08:23.310
On the most significant bits
are the network identifier,

00:08:23.310 --> 00:08:29.300
and the least significant bits, 64 bits,
are reserved for your subnet mask.

00:08:29.370 --> 00:08:34.560
And hosts usually pick these addresses
by any of several mechanisms.

00:08:34.890 --> 00:08:36.880
They can be derived
from your Mac address.

00:08:37.010 --> 00:08:38.680
They can be manually configured.

00:08:38.780 --> 00:08:40.620
They can be assigned by a DHCP server.

00:08:40.820 --> 00:08:43.310
They can be randomly generated.

00:08:43.670 --> 00:08:49.640
But the network IDs are allocated
by the Internet Number Authority.

00:08:49.820 --> 00:08:52.210
Smaller blocks are carved
out by the registries.

00:08:52.340 --> 00:08:55.700
Registries gives even smaller
blocks to service providers.

00:08:55.760 --> 00:09:00.100
And then service providers give
every subscriber a prefix that

00:09:00.460 --> 00:09:04.700
allows them to select usually
some large number of subnets.

00:09:04.880 --> 00:09:08.680
And then each subnet
has 64 bits of host ID.

00:09:08.750 --> 00:09:11.300
So if you're looking at one of
these big scary IPv6 addresses

00:09:11.340 --> 00:09:15.580
that's made out of hexadecimal
numbers and separated with colons,

00:09:15.630 --> 00:09:17.270
it's easy to figure out
what's going on here.

00:09:17.320 --> 00:09:21.020
There's a prefix that comes
from your service provider,

00:09:21.020 --> 00:09:22.860
or you get it directly from the registry.

00:09:22.920 --> 00:09:26.570
Here's your subnet ID that as a
subscriber you got to pick that.

00:09:26.580 --> 00:09:28.970
And then the rest of this,
the number that I'm showing you here

00:09:29.010 --> 00:09:33.140
is a randomly generated one that I took
off my desktop machine in Cupertino.

00:09:33.140 --> 00:09:35.500
And it's easy to figure out.

00:09:37.150 --> 00:09:40.120
Going on further to talking
about well-defined scopes,

00:09:40.170 --> 00:09:45.490
IPv6 has two scopes of unicast addresses.

00:09:45.580 --> 00:09:46.900
It's got link local scopes.

00:09:47.080 --> 00:09:59.710
In IPv4 those are 169.254.16,
but in IPv6 they are the FE80 prefix.

00:09:59.710 --> 00:09:59.710
And what I'm showing you here is,

00:09:59.870 --> 00:10:03.740
A way that a TCP server that's
listening on an IPv6 socket might

00:10:03.740 --> 00:10:06.750
initialize its socket address
structure before it calls bind.

00:10:06.800 --> 00:10:10.990
You can see that there's the SYN6
adder field where you put in your

00:10:10.990 --> 00:10:13.800
host address if you're going to bind
to a specific interface address.

00:10:13.800 --> 00:10:15.800
There's your port number.

00:10:15.800 --> 00:10:17.800
And then there's this third field
in the socket address structure.

00:10:17.800 --> 00:10:20.610
This is important for
link local addresses.

00:10:20.870 --> 00:10:23.040
This is where you tell
the socket address,

00:10:23.040 --> 00:10:29.410
"This address is for this interface."
Because the scope of a link local address

00:10:29.410 --> 00:10:32.800
is just the link that it's connected to.

00:10:32.800 --> 00:10:34.940
Routable addresses, on the other hand,
do come in a number of

00:10:35.000 --> 00:10:37.790
interesting flavors and it's
worth knowing what they are.

00:10:38.030 --> 00:10:41.800
First there's the
publicly routed addresses.

00:10:41.950 --> 00:10:43.930
And then there's the
unique local addresses,

00:10:43.930 --> 00:10:48.030
which are still global in scope,
but they're not routed over the

00:10:48.160 --> 00:10:50.800
default free zone in the internet.

00:10:50.800 --> 00:10:53.800
They can be routed over
bilateral agreements.

00:10:53.800 --> 00:10:56.800
And you'll also sometimes see them
in Back to My Mac tunnel interfaces.

00:10:56.870 --> 00:10:59.990
Because Back to My Mac uses
IPv6 inside the tunnel,

00:10:59.990 --> 00:11:04.530
and we use unique local addresses
to address every host that's part

00:11:04.600 --> 00:11:06.790
of a Back to My Mac routing domain.

00:11:06.880 --> 00:11:10.090
And lastly, you may also see some global
scope addresses that are

00:11:10.090 --> 00:11:14.800
associated with the transition
from IPv4 to dual stack IPv4/IPv6.

00:11:14.800 --> 00:11:20.800
And these include things like NAT64,
protocol translation

00:11:20.800 --> 00:11:22.720
between the two protocols,
v4 mapped addresses,

00:11:22.720 --> 00:11:26.800
which appear only on hosts,
and the 6-to-4 and Teredo addresses.

00:11:26.800 --> 00:11:32.890
Lastly, there's a whole can of worms
associated with multicast,

00:11:32.980 --> 00:11:34.800
but it's not really that bad.

00:11:34.800 --> 00:11:36.570
And I'm going to have to ask
you to look that up on your own

00:11:36.670 --> 00:11:39.670
time and consider it homework,
but it's worth knowing about.

00:11:39.920 --> 00:11:43.790
Multicast is much more
well-defined in IPv6.

00:11:44.120 --> 00:11:46.800
The new control message protocol.

00:11:47.840 --> 00:11:53.540
In IPv4, you have the address resolution
protocol and a whole different protocol

00:11:53.540 --> 00:11:57.690
that you use over PPP links for
configuring hosts with their addresses.

00:11:57.810 --> 00:12:03.700
But in IPv6, this all gets unified on the
ICMPv6 protocol in a profile

00:12:03.710 --> 00:12:06.380
called Neighbor Discovery.

00:12:08.010 --> 00:12:14.330
On routed interfaces,
IPv6 addresses can be assigned by hosts

00:12:14.330 --> 00:12:19.410
themselves using router discovery,
but DHCP is an option.

00:12:19.600 --> 00:12:22.880
Some networks will require
DHCP for every host.

00:12:23.060 --> 00:12:25.820
Some networks won't offer DHCP at all.

00:12:25.920 --> 00:12:31.400
And some networks will offer DHCP in
certain scale or stateless varieties

00:12:31.400 --> 00:12:36.130
or stateful for only those hosts that
require individual configuration.

00:12:36.260 --> 00:12:38.740
But every host can usually
find out about its,

00:12:38.740 --> 00:12:42.200
well, every host has to be able to
find out about its routers

00:12:42.200 --> 00:12:43.970
through router discovery.

00:12:44.050 --> 00:12:47.060
And finally,
IPv6 has another interesting feature

00:12:47.060 --> 00:12:51.630
which is that IPv4 fragments packets
at routers before they get forwarded,

00:12:51.660 --> 00:12:55.500
but IPv6 routers are not
allowed to fragment packets.

00:12:55.610 --> 00:12:59.550
If a router gets a packet that
it can't forward because the

00:12:59.550 --> 00:13:03.420
next link has a smaller MTU,
it has to send back an ICMPv6

00:13:03.520 --> 00:13:06.130
error message that says,
"This packet is too big."

00:13:06.140 --> 00:13:09.590
Fragment at the host.

00:13:09.750 --> 00:13:14.820
And that means that firewalls have
to honor these ICMPv6 error messages,

00:13:14.820 --> 00:13:18.640
but the good news is that hosts
get path MTU discovery for all

00:13:18.640 --> 00:13:21.860
of the transport layer protocols,
not just TCP.

00:13:21.930 --> 00:13:22.760
And it's standard.

00:13:22.760 --> 00:13:23.800
You can rely on it.

00:13:23.800 --> 00:13:27.490
It needs to be there or IPv6 is broken.

00:13:28.670 --> 00:13:33.250
So developers have a few things that
they need to be aware of about IPv6 that

00:13:33.430 --> 00:13:36.790
make it a little different from IPv4.

00:13:37.820 --> 00:13:41.530
Because there's a
universal routing realm,

00:13:41.590 --> 00:13:45.270
the network address translator from
IPv4 that might be hiding your address

00:13:45.300 --> 00:13:48.680
and giving you a certain amount
of privacy because your address

00:13:48.680 --> 00:13:51.770
is obscured from the global internet,
well, your address is now global.

00:13:51.780 --> 00:13:54.080
And there's a different
mechanism for protecting your

00:13:54.080 --> 00:13:56.660
privacy based on your address,
and that means that your hosts

00:13:56.690 --> 00:13:58.130
may get renumbered more often.

00:13:59.440 --> 00:14:02.670
This has much better support
for automatic renumbering,

00:14:02.670 --> 00:14:07.430
but just be aware that your application
may be sitting on a host that gets its

00:14:07.590 --> 00:14:09.300
addresses renumbered more frequently.

00:14:09.300 --> 00:14:12.990
Also,
it's pretty normal for an IPv6 host to

00:14:12.990 --> 00:14:20.740
have multiple addresses per interface,
and even multiple addresses per prefix.

00:14:20.740 --> 00:14:23.410
Routers might advertise
more than one prefix,

00:14:23.420 --> 00:14:27.020
and your host may have more than
one address for each prefix.

00:14:27.020 --> 00:14:30.280
So if you've got an app that
iterates... ...through the

00:14:30.280 --> 00:14:32.270
list of interface addresses,
be aware you're going to

00:14:32.270 --> 00:14:34.470
see a lot of addresses,
and they'll be of different types.

00:14:34.470 --> 00:14:36.440
I'll go into that in a
little more detail later.

00:14:36.440 --> 00:14:39.650
And lastly, with IPv4,
you kind of have to deal

00:14:39.670 --> 00:14:43.900
with NAT traversal a lot,
and you might think that with IPv6 you

00:14:43.900 --> 00:14:46.880
don't have to deal with NAT traversal.

00:14:46.880 --> 00:14:48.760
But sadly, that's not quite true.

00:14:48.760 --> 00:14:51.360
As long as we've still got
IPv4 in the real world,

00:14:51.360 --> 00:14:53.590
and we're going to have
that for a long time,

00:14:53.590 --> 00:14:57.070
there are going to be these
NAT64 protocol translators.

00:14:57.080 --> 00:14:59.420
And also, we've got proxies.

00:14:59.440 --> 00:15:02.410
And firewalls,
and all of the usual things that

00:15:02.690 --> 00:15:07.040
can interfere with reachability by
filtering the content of the network,

00:15:07.090 --> 00:15:11.170
even if they don't do protocol
translation just to route.

00:15:14.270 --> 00:15:19.240
put this slide here in my
presentation because I wanted to

00:15:19.330 --> 00:15:23.410
take a brief break to recognize that

00:15:24.120 --> 00:15:26.860
In order to maintain this
illusion that the internet is

00:15:26.860 --> 00:15:29.580
magic and that it just works,
we have to really concentrate

00:15:29.610 --> 00:15:33.440
on the technology without really
thinking too hard about all of the

00:15:33.470 --> 00:15:35.740
public relations associated with it.

00:15:35.860 --> 00:15:41.460
So it's important to not get
distracted by what you might

00:15:41.460 --> 00:15:44.360
read in the press about IPv6.

00:15:44.600 --> 00:15:49.410
Remember that the transition is
really happening and the people

00:15:49.520 --> 00:15:54.100
inside this room right now are the
ones that need to know about it.

00:15:54.100 --> 00:15:56.050
So keep an eye out for that.

00:15:56.220 --> 00:15:58.100
And if you want to go into
more detail about IPv6,

00:15:58.100 --> 00:15:58.100
I'm going to go into a little
bit more detail about it.

00:15:58.100 --> 00:16:01.770
Everybody else outside this room is
probably going to be better off if they

00:16:01.770 --> 00:16:04.090
never know that IPv6 is happening at all.

00:16:04.100 --> 00:16:08.540
So keep an eye on -- your job is to
pay attention to the reality and the

00:16:08.540 --> 00:16:14.640
engineering problems of getting the
transition to happen smoothly so that

00:16:14.640 --> 00:16:20.670
people outside who are just using your
app don't have to care about whether

00:16:20.670 --> 00:16:20.670
they're using IPv4 or IPv6 or whatever.

00:16:21.990 --> 00:16:26.520
So now I'm going to tell you
about what we've got in iOS and in

00:16:26.520 --> 00:16:32.260
Mac OS X to make it possible for you
to do it so that it looks like magic.

00:16:32.950 --> 00:16:37.150
First I'm going to start by telling
you a bit about where IPv6 has been.

00:16:37.520 --> 00:16:41.600
It showed up in iOS in 3.2
when the iPad launched,

00:16:41.640 --> 00:16:44.380
but it's been in
Mac OS X since the beginning.

00:16:44.520 --> 00:16:49.270
In iOS,
IPv6 is just not visible in settings.

00:16:50.040 --> 00:16:53.000
That doesn't mean it isn't there though.

00:16:53.180 --> 00:16:57.750
iOS devices will happily get
addresses and use the IPv6 internet.

00:16:57.880 --> 00:17:00.690
There's IPv6 on the
conference network here today.

00:17:00.800 --> 00:17:05.240
Your phones can surf to IPv6 websites.

00:17:05.390 --> 00:17:08.540
Try out ipv6.me if you don't believe me.

00:17:08.640 --> 00:17:11.860
But the settings don't show you
anything about your IPv6 addresses.

00:17:11.860 --> 00:17:14.960
If you'd like to find that information,
there's probably great third

00:17:14.960 --> 00:17:17.990
party apps in the app store
that should do that for you.

00:17:18.330 --> 00:17:25.230
In iOS 4.1 we improved it a bit so that
you can get your DNS server addresses.

00:17:25.400 --> 00:17:28.800
Over the router
advertisements using RFC 5006,

00:17:28.840 --> 00:17:33.650
we also added a stateless DHPv6
client for networks that might

00:17:33.980 --> 00:17:36.690
be operating in a v6 only mode.

00:17:37.310 --> 00:17:43.960
iOS 4.3 added support for a stateful
DHCPv6 client and temporary addresses.

00:17:43.960 --> 00:17:48.750
The temporary addresses are the way
you get a certain amount of privacy

00:17:48.750 --> 00:17:52.800
in IPv6 that NAT provides you in IPv4.

00:17:52.800 --> 00:17:56.780
We randomly generate the host ID part
of your address and add it to the

00:17:56.860 --> 00:17:59.400
network prefix that you're attached to.

00:17:59.540 --> 00:18:05.700
And we rotate those once a day and stop
using them after a week so that when

00:18:05.700 --> 00:18:10.310
you move from one network to another,
you'll have an address that isn't

00:18:10.310 --> 00:18:15.530
based on your hardware ID and you can't
be tracked from hotspot to hotspot.

00:18:16.130 --> 00:18:20.280
Now, in iOS 5 and 10.7 we have
some improvements that I'd

00:18:20.490 --> 00:18:22.000
like to tell you about.

00:18:22.000 --> 00:18:26.740
First,
we are routinely testing development

00:18:26.740 --> 00:18:30.340
builds of the operating system
against the Tahi conformance suite,

00:18:30.340 --> 00:18:33.800
which is used for the IPv6
ready logo certification.

00:18:33.800 --> 00:18:38.180
And we've also taken great pains
to make sure that all the apps

00:18:38.250 --> 00:18:43.040
that ship with iOS 5 and with
Lion are as IPv6 ready as possible,

00:18:43.040 --> 00:18:44.400
so we're tracking all of that.

00:18:44.400 --> 00:18:48.950
We also run them on networks that
are v6 only with a NAT64 translator.

00:18:49.210 --> 00:18:52.140
We've also improved the way
the system chooses destination

00:18:52.140 --> 00:18:56.400
addresses and source addresses
for when they make a connection.

00:18:56.510 --> 00:19:04.560
We use the RFC 3484 default policy table
as amended by recent internet drafts.

00:19:04.650 --> 00:19:08.150
And this helps if you're using,
if you're coding directly to the

00:19:08.450 --> 00:19:11.100
POSIX API and using get adder info.

00:19:11.190 --> 00:19:15.380
This will definitely help make
the transition more seamless.

00:19:15.690 --> 00:19:18.560
My colleague Josh Graessley is going
to come after me and tell you about

00:19:18.780 --> 00:19:23.580
the great new feature that is in the
core foundation layers in CF socket

00:19:23.580 --> 00:19:27.190
stream where we will actually
make concurrent TCP connections

00:19:27.340 --> 00:19:31.460
after making concurrent DNS lookups
and we use the best connection

00:19:31.460 --> 00:19:33.280
available as quickly as possible.

00:19:33.280 --> 00:19:37.290
So no more waiting for IPv6
to fail or IPv4 to fail before

00:19:37.290 --> 00:19:39.980
falling back to the other protocol.

00:19:40.520 --> 00:19:47.830
And we improved the sockets API to
conform to the latest RFC from the IETF,

00:19:47.850 --> 00:19:49.260
RFC 3542.

00:19:49.260 --> 00:19:53.130
And I'll have some more
detail about that in a minute.

00:19:53.330 --> 00:19:57.090
and the temporary addresses
that I told you about in iOS 5,

00:19:57.140 --> 00:20:01.130
they're coming to Lion,
so look for them there.

00:20:02.130 --> 00:20:04.680
The new Sockets API has a
couple of interesting things

00:20:04.680 --> 00:20:07.200
that you need to know about.

00:20:07.200 --> 00:20:09.960
It's not source code
compatible with the older one.

00:20:10.080 --> 00:20:13.520
So if you've got an app that
actually wants to use the special

00:20:13.610 --> 00:20:18.310
socket options that allow you to
control the contents of the IPv6

00:20:18.310 --> 00:20:22.530
headers and the extension headers,
some of those options have

00:20:22.530 --> 00:20:24.480
semantics that are different.

00:20:24.670 --> 00:20:28.000
They have the same names,
but they work differently.

00:20:28.160 --> 00:20:32.100
Which means you may have to decorate
your source code with pound-defined

00:20:32.100 --> 00:20:36.000
messages that say which one of
these two APIs you're going to use.

00:20:36.000 --> 00:20:40.000
Because the kernel supports both,
it's got binary compatibility for this.

00:20:40.000 --> 00:20:44.000
So you have to choose in your source
code which one you're really using.

00:20:44.000 --> 00:20:46.800
And if you don't,
then the compiler will probably

00:20:46.800 --> 00:20:49.000
complain about undefined symbols.

00:20:49.000 --> 00:20:51.830
If you still want to use the older API,
same thing,

00:20:51.830 --> 00:20:54.000
you've got to put in the decoration.

00:20:55.220 --> 00:20:59.390
Also, with these privacy addresses,
you might be thinking to yourself,

00:20:59.520 --> 00:21:02.600
but I actually want to
make an outbound flow,

00:21:02.620 --> 00:21:05.360
an outbound connection,
using my persistent address

00:21:05.380 --> 00:21:07.080
rather than my temporary address.

00:21:07.140 --> 00:21:07.800
How do I do that?

00:21:07.800 --> 00:21:11.300
Well,
there's a non-standard socket option we

00:21:11.720 --> 00:21:17.130
introduced that allows you to override
for each socket when you do the bind,

00:21:17.400 --> 00:21:21.590
saying, I would like to prefer
the persistent address.

00:21:22.920 --> 00:21:26.560
It's also important to note
that if you're iterating the

00:21:26.560 --> 00:21:30.970
list of interface addresses,
that there's a flags field in the

00:21:30.970 --> 00:21:33.140
structures returned by that function.

00:21:33.240 --> 00:21:36.140
And on IPv6 addresses,
those flags are actually going

00:21:36.140 --> 00:21:37.290
to tell you useful things.

00:21:37.300 --> 00:21:39.770
You'll know which ones are
your temporary addresses.

00:21:39.870 --> 00:21:43.140
You'll also be able to tell which
ones are tentative or deprecated,

00:21:43.150 --> 00:21:47.120
which are flags that come up when
automatic renumbering happens

00:21:47.440 --> 00:21:49.800
and duplicate address detection.

00:21:50.800 --> 00:21:56.290
So, if there is two things I want you
to do after you leave here today,

00:21:56.300 --> 00:21:59.780
one of them is really go try to
light up your home network with IPv6.

00:21:59.780 --> 00:22:02.660
It's good for developers to be early
adopters of this stuff and one of

00:22:02.750 --> 00:22:05.960
the best ways to do that is get an
airport base station or a time capsule

00:22:05.960 --> 00:22:11.130
and go get yourself a free account
with tunnelbroker.net or 6access.net

00:22:11.130 --> 00:22:15.930
and configure your base station to
terminate an IPv6 over IPv4 tunnel

00:22:15.930 --> 00:22:18.280
and get yourself up and running.

00:22:18.480 --> 00:22:22.590
And the next thing I want you to do
is if you've got any IPv4 only apps

00:22:22.590 --> 00:22:27.180
or apps that do networking and you
haven't tested them on a v6 network,

00:22:27.180 --> 00:22:29.070
please get ready for IPv6.

00:22:29.150 --> 00:22:32.930
It's coming to a network
near you and if you don't,

00:22:32.980 --> 00:22:34.980
your competitors will.

00:22:35.920 --> 00:22:39.990
Three things I want you to remember,
transition is happening.

00:22:40.140 --> 00:22:45.350
Please understand that most of your
users don't care about IPv6 versus IPv4,

00:22:45.350 --> 00:22:48.280
they don't want to know,
don't let them know.

00:22:48.480 --> 00:22:51.750
And if you can use the high level
APIs that we provided that sort all

00:22:51.800 --> 00:22:55.060
of this out for you automatically,
then absolutely do so.

00:22:55.130 --> 00:22:58.060
And for that I want to hand
over the clicker to my colleague

00:22:58.280 --> 00:23:01.620
Josh Grassley who will tell you all
about what's coming in those higher

00:23:01.620 --> 00:23:08.110
level APIs that are so great.

00:23:08.110 --> 00:23:08.110
Thanks.

00:23:11.110 --> 00:23:12.000
Good morning.

00:23:12.000 --> 00:23:13.540
My name is Josh Graessley,
and I'm going to tell you about some of

00:23:13.540 --> 00:23:16.620
the really cool things we've been doing
under the covers to make networking

00:23:16.670 --> 00:23:20.080
work a lot better in iOS 5 and in Lion.

00:23:20.520 --> 00:23:24.290
So most of this work is all done
down at the Unix-y Darwin Foundation.

00:23:24.640 --> 00:23:26.980
You don't have to make any
changes if you're currently

00:23:26.980 --> 00:23:30.200
programming to the CF Networking
Layer APIs or the Foundation APIs.

00:23:30.240 --> 00:23:33.390
You'll get to take advantage
of all of this for free.

00:23:34.700 --> 00:23:36.300
So we've got a number of changes.

00:23:36.320 --> 00:23:38.060
We've changed the way that
we do address selection,

00:23:38.090 --> 00:23:41.890
both source address selection and
destination address selection.

00:23:42.080 --> 00:23:43.980
We've changed the way that
we handle Connect by Name.

00:23:44.120 --> 00:23:46.820
We've made it a lot more advanced
in the event that we're using an

00:23:46.820 --> 00:23:49.290
API that lets you connect by name.

00:23:49.500 --> 00:23:53.340
We've added statistics for the network
so we can get a better idea about how

00:23:53.340 --> 00:23:55.840
the network is performing and we can
make better decisions about whether

00:23:55.840 --> 00:23:59.060
we should be using IPv4 or IPv6.

00:23:59.700 --> 00:24:02.150
With iCloud we have a lot
of extra background traffic

00:24:02.180 --> 00:24:03.400
that might be going on.

00:24:03.460 --> 00:24:05.500
So we've done a lot of work
to introduce some throttling

00:24:05.500 --> 00:24:08.100
to make sure that whatever may
be going on in the background,

00:24:08.100 --> 00:24:12.320
whether it's your application while it's
in the background or iCloud traffic,

00:24:12.640 --> 00:24:16.640
that stuff is throttled so the foreground
application remains responsive.

00:24:16.750 --> 00:24:19.370
We've also added some
new TCP buffer sizing,

00:24:19.440 --> 00:24:23.790
which has some implications if
you're working at the sockets layer.

00:24:24.910 --> 00:24:27.180
Most of these changes were made
to handle the dynamic environment

00:24:27.260 --> 00:24:28.920
that we find our devices in.

00:24:28.940 --> 00:24:32.350
We have devices that may be on multiple
very different networks at the same time,

00:24:32.460 --> 00:24:33.530
cellular and Wi-Fi.

00:24:33.660 --> 00:24:38.040
We have a bunch of different kinds
of networks that we can run into.

00:24:38.040 --> 00:24:42.580
We've got networks that have very
fast and very good IPv4 connectivity,

00:24:42.610 --> 00:24:45.800
and networks that may not have
such great IPv6 connectivity.

00:24:46.050 --> 00:24:49.480
For example, they may have IPv6,
but it may be provided by a tunnel,

00:24:49.490 --> 00:24:52.440
and so v6 may be a little bit slower.

00:24:52.470 --> 00:24:55.160
There are other edge cases
that we find that we run into.

00:24:55.430 --> 00:24:58.460
Sometimes there are networks that
have a device on the network that say,

00:24:58.460 --> 00:24:59.940
"Hey, I've got v6 connectivity.

00:24:59.940 --> 00:25:00.610
"Here's a prefix.

00:25:00.760 --> 00:25:01.600
"I'm the router.

00:25:01.600 --> 00:25:04.680
"Go ahead and send me traffic."
And they don't actually have any way

00:25:04.680 --> 00:25:06.900
to get that traffic anywhere else,
and they don't even let you know, "Hey,

00:25:06.900 --> 00:25:10.010
by the way, I wasn't able to deliver
that." So you're just stuck

00:25:10.010 --> 00:25:12.060
waiting for things to time out.

00:25:12.220 --> 00:25:15.220
Another thing that we've
seen problems with is DNS,

00:25:15.220 --> 00:25:18.100
where we send out a query,
which is the way of looking up

00:25:18.100 --> 00:25:21.100
an IPv6 record for a host name,
and we never get an answer back.

00:25:21.100 --> 00:25:24.700
So we end up waiting for a timeout,
which is a waste of time.

00:25:25.330 --> 00:25:28.800
Eventually we'll probably
have very fast IPv6 networks,

00:25:28.860 --> 00:25:32.280
and maybe v6 only networks,
and v4 is only around as a legacy.

00:25:32.510 --> 00:25:34.780
But in the meantime we're going
to have to handle moving between

00:25:34.780 --> 00:25:38.580
different networks where v6 may
be better or v4 may be better,

00:25:38.740 --> 00:25:43.060
and communicating with hosts
where a host may be on v4 and v6,

00:25:43.060 --> 00:25:46.550
but we don't know whether
it's better to communicate

00:25:46.550 --> 00:25:48.910
with that host using v4 or v6.

00:25:48.910 --> 00:25:52.590
So we've done a lot of work to
try and dynamically adjust to

00:25:52.590 --> 00:25:52.590
whatever environment we're in.

00:25:53.330 --> 00:25:56.600
The first step was
improving address selection.

00:25:56.600 --> 00:25:58.420
So we used the same
API at the lower layer,

00:25:58.460 --> 00:25:59.340
get_enter_info.

00:25:59.340 --> 00:26:04.480
Get_enter_info takes a host name,
so an application can tell the system,

00:26:04.480 --> 00:26:07.640
hey, I want to know what all the
addresses are for this host name.

00:26:07.640 --> 00:26:11.000
And get_enter_info will do a DNS query
for the v4 addresses and a separate

00:26:11.150 --> 00:26:12.780
DNS query for the v6 addresses.

00:26:12.830 --> 00:26:16.310
And when those queries come back,
get_enter_info will then sort

00:26:16.320 --> 00:26:19.160
all of the addresses and try and
put the best address to use at

00:26:19.160 --> 00:26:20.510
the very beginning of that list.

00:26:20.700 --> 00:26:22.260
And it will return that
to the application.

00:26:22.260 --> 00:26:26.150
And the application will usually pick one
of those addresses and try and connect.

00:26:26.300 --> 00:26:29.050
The problem is if the first
address returned by get_enter_info

00:26:29.050 --> 00:26:32.020
really isn't the best address,
then it may take up to a minute for

00:26:32.020 --> 00:26:33.990
that connection attempt to time out.

00:26:33.990 --> 00:26:36.710
And most users won't
wait around for a minute.

00:26:36.910 --> 00:26:39.300
So we've changed the rules
on how we do the sorting.

00:26:39.350 --> 00:26:41.790
Now we look into the routing
statistics and we try and figure

00:26:42.040 --> 00:26:45.040
out about how long the round
trip time is to each destination.

00:26:45.120 --> 00:26:48.920
And we'll go with the destination that
has the lowest round trip time estimate.

00:26:48.960 --> 00:26:50.920
In the event that we
don't have any statistics,

00:26:50.980 --> 00:26:54.020
we'll fall back to a very
sophisticated policy table,

00:26:54.070 --> 00:26:58.230
which is based on an IETF draft,
RFC 3484.

00:27:00.320 --> 00:27:02.800
Most applications don't really
want to connect to an address.

00:27:02.980 --> 00:27:05.100
What they want to
connect to is a service,

00:27:05.130 --> 00:27:08.390
and they identify the service by
specifying the host name of the

00:27:08.390 --> 00:27:12.650
host that the service is running on,
as well as the port.

00:27:12.960 --> 00:27:14.570
And they have to do this
in two different steps.

00:27:14.670 --> 00:27:17.130
The first step involves
telling the operating system,

00:27:17.420 --> 00:27:20.220
here's a host name,
please give me a list of addresses.

00:27:20.250 --> 00:27:23.130
But it doesn't tell the operating
system what the application's

00:27:23.130 --> 00:27:25.280
going to do with those addresses.

00:27:25.290 --> 00:27:26.660
And the next step is a bit arduous.

00:27:26.660 --> 00:27:28.940
It has to create a socket
of the right address family,

00:27:28.990 --> 00:27:31.800
has to set options,
and then it has to do the connect.

00:27:31.970 --> 00:27:33.860
And at those steps it
just tells the system,

00:27:33.880 --> 00:27:36.340
I'm trying to connect to this address,
but it doesn't tell the system

00:27:36.340 --> 00:27:39.770
what I'm really trying to do
is get connected to this host.

00:27:40.410 --> 00:27:41.780
So we've got a better way.

00:27:41.900 --> 00:27:45.180
Fortunately,
we have an API already on the system,

00:27:45.310 --> 00:27:49.580
CF socket stream, that lets you specify
a host name and a port.

00:27:49.740 --> 00:27:51.500
So it tells the system,
I want to connect to this

00:27:51.610 --> 00:27:53.760
host name on this port,
and now the system can do

00:27:53.850 --> 00:27:56.170
some very intelligent things.

00:27:57.210 --> 00:28:00.790
So it's the same API as before,
CFSocketStream, and everything built on

00:28:00.790 --> 00:28:02.360
top of CFSocketStream.

00:28:02.360 --> 00:28:06.470
Almost every CF network API or
foundation layer networking API is

00:28:06.660 --> 00:28:09.510
based on top of CFSocketStream.

00:28:10.190 --> 00:28:11.900
there's some very new behavior.

00:28:12.030 --> 00:28:15.660
So in the past we would use getAdderInfo
and it would do the v4 and the v6 queries

00:28:15.790 --> 00:28:18.670
and it would wait until those came back
before it would give us any results.

00:28:18.800 --> 00:28:23.350
Now we perform the separate v4
and v6 queries and as soon as we

00:28:23.350 --> 00:28:26.380
get one of those answers back,
we'll take all the addresses in that

00:28:26.380 --> 00:28:29.940
answer and we'll sort them and then we'll
pick the best destination from that.

00:28:29.940 --> 00:28:31.270
And we'll start a connection.

00:28:31.420 --> 00:28:34.360
And at the same time that we start
a connection to that best address,

00:28:34.430 --> 00:28:37.170
we'll also look it up in the routing
statistics and figure out about

00:28:37.170 --> 00:28:38.740
what the round trip time should be.

00:28:38.850 --> 00:28:41.360
So we have an idea of how long
we should expect that connection

00:28:41.410 --> 00:28:43.140
to take and we'll set up a timer.

00:28:43.260 --> 00:28:46.140
So if that timer fires and the
connection hasn't been established,

00:28:46.340 --> 00:28:49.380
we'll pick the next best address and
we'll start a connection to that as well.

00:28:49.470 --> 00:28:52.220
So we'll have a bunch of concurrent
TCP connections potentially

00:28:52.220 --> 00:28:54.000
going on at the same time.

00:28:54.790 --> 00:28:57.070
We'll keep doing this until we
run out of addresses or we end up

00:28:57.070 --> 00:29:00.220
with an established connection.

00:29:00.230 --> 00:29:02.780
So to look at how this solves some
of the problems that we've run into,

00:29:02.780 --> 00:29:06.460
we have a diagram up here.

00:29:06.460 --> 00:29:09.700
Prior to Lion, in an environment where
we had broken v6 DNS,

00:29:10.010 --> 00:29:12.680
where the DNS server wouldn't
respond to quad A queries,

00:29:12.790 --> 00:29:16.080
we would have sent those v4 and v6
queries and we'd get the v4 answer back.

00:29:16.120 --> 00:29:19.070
And then we'd wait around because
we didn't have the v6 answer yet.

00:29:19.070 --> 00:29:22.350
And after some time out, we'd go, okay,
we didn't get a v6 answer,

00:29:22.420 --> 00:29:23.660
let's go ahead and connect.

00:29:23.820 --> 00:29:25.340
But now we've wasted a lot of time.

00:29:25.340 --> 00:29:28.330
The user doesn't care if
they connect over v4 or v6.

00:29:28.470 --> 00:29:32.500
So waiting around for that v6
answer really doesn't benefit them.

00:29:32.500 --> 00:29:37.310
On Lion, we send the v4 and the
v6 answer -- the queries.

00:29:37.370 --> 00:29:39.680
We get the v6 -- sorry, the

00:29:40.100 --> 00:29:42.600
We connect to the v4 and we're done.

00:29:42.680 --> 00:29:45.560
The user's experience is much improved.

00:29:45.880 --> 00:29:48.700
It's even more dramatic when
we have a broken IPv6 network.

00:29:48.730 --> 00:29:50.840
There are some networks out there,
like I said earlier,

00:29:50.880 --> 00:29:53.560
where some device on the network says,
"I have v6 connectivity,

00:29:53.690 --> 00:29:58.270
please use this prefix "and send all
the traffic to me." In that scenario,

00:29:58.450 --> 00:30:01.760
prior to Lion, we would send the v4
and the v6 DNS queries.

00:30:01.770 --> 00:30:04.880
We'd get the v4 and v6 DNS queries back,
and then we'd sort them.

00:30:05.020 --> 00:30:09.060
We'd decide, okay,
let's connect to the IPv6 address.

00:30:09.360 --> 00:30:14.220
So we send a send packet over IPv6,
and we don't get any answer back.

00:30:14.390 --> 00:30:15.420
So we wait for a little time.

00:30:15.580 --> 00:30:17.120
We send another send.

00:30:17.130 --> 00:30:19.540
We wait a little bit longer,
send another send,

00:30:19.550 --> 00:30:20.920
and we keep doing this.

00:30:21.040 --> 00:30:23.940
So a minute later,
we might finally get a timeout that says,

00:30:23.940 --> 00:30:26.050
"Okay, this isn't working out for us."

00:30:26.740 --> 00:30:29.890
Then we fall back to the V4 address,
we send this in, we get the SYN act back,

00:30:30.010 --> 00:30:31.730
we've got a connection,
we're ready to go.

00:30:31.900 --> 00:30:33.320
But we've just wasted a whole minute.

00:30:33.350 --> 00:30:35.560
And I don't know about you,
but I won't wait around for a minute.

00:30:35.560 --> 00:30:38.310
And when you're loading web pages,
this is even worse because there

00:30:38.310 --> 00:30:39.640
are multiple connections involved.

00:30:39.730 --> 00:30:42.540
So that you have to wait a minute
for each one of those connections.

00:30:42.540 --> 00:30:45.780
On Lion, we have much better behavior.

00:30:46.020 --> 00:30:48.750
Send the V4 and V6 queries,
we get the answers back,

00:30:48.880 --> 00:30:52.750
we sort the destinations, we decide,
okay, we're gonna try IPv6 first.

00:30:52.880 --> 00:30:55.790
So we send the SYN,
we also set up a timer.

00:30:55.900 --> 00:30:59.460
We send another SYN 'cause we
haven't got an answer back yet.

00:30:59.510 --> 00:31:01.540
The timer fires,
indicating we expected that we

00:31:01.540 --> 00:31:02.790
would have connected by now.

00:31:02.910 --> 00:31:05.680
So we start a V4 connection as well,
while that V6 connection

00:31:05.790 --> 00:31:06.530
is still going on.

00:31:06.710 --> 00:31:09.910
We get our V4 answer back,
we've got a connection, we're all set.

00:31:10.180 --> 00:31:12.860
The user doesn't even notice that
there's anything wrong on their network.

00:31:12.920 --> 00:31:15.760
The application on their
phone or Mac responds,

00:31:15.800 --> 00:31:17.580
works very quickly.

00:31:17.680 --> 00:31:19.900
It's a much better user experience.

00:31:19.990 --> 00:31:22.430
So to take advantage of this,
all you have to do is use an

00:31:22.550 --> 00:31:25.010
API that lets you connect by name.

00:31:25.040 --> 00:31:27.460
The other advantage of this too,
is because you're dealing with

00:31:27.580 --> 00:31:29.890
host names instead of addresses,
you don't have to worry about

00:31:29.970 --> 00:31:34.090
the difference between IPv4
addresses and IPv6 addresses.

00:31:35.410 --> 00:31:39.470
The APIs available to you are CFSocket
Stream and anything built on top of that.

00:31:39.660 --> 00:31:45.790
So there's WebKit, NSURL connection,
CFHTTP stream, and a lot of other APIs.

00:31:46.110 --> 00:31:48.200
When you're trying to
pick which API to use,

00:31:48.200 --> 00:31:52.660
it's really important to try and
pick the highest layer API available.

00:31:52.660 --> 00:31:55.670
The higher the level of the API,
the more information your application

00:31:55.670 --> 00:31:58.880
gets to convey to the operating system
about what it's really trying to do.

00:31:58.920 --> 00:32:01.240
For example,
if you were trying to load some

00:32:01.240 --> 00:32:05.070
HTTP URL and you decided to
do that with CFSocket stream,

00:32:05.140 --> 00:32:08.310
you tell it, I want to connect to this
host name and port 80.

00:32:08.310 --> 00:32:11.560
And then it would be up to you to
put together all of the HTTP headers

00:32:11.560 --> 00:32:16.720
and parse all the responses and deal
with proxies and everything else.

00:32:16.720 --> 00:32:21.000
If you move up to CFHTTP stream,
that would handle all of the

00:32:21.000 --> 00:32:24.470
HTTP headers for you so you don't
have to do the parsing of that.

00:32:24.470 --> 00:32:26.790
But it doesn't provide the
automatic proxy support.

00:32:26.840 --> 00:32:30.120
So if you move up to an
even higher level API,

00:32:30.120 --> 00:32:33.210
you can take advantage of the proxy
support built into the operating system

00:32:33.210 --> 00:32:35.270
and it will handle everything for you.

00:32:38.630 --> 00:32:40.770
In order to support
all these new features,

00:32:40.770 --> 00:32:44.700
we've started collecting a lot more
statistics inside of the kernel.

00:32:44.770 --> 00:32:47.320
So we keep track of
performance of TCP sockets,

00:32:47.320 --> 00:32:50.750
of UDP sockets, as well as routes.

00:32:51.020 --> 00:32:54.120
Currently the only clients for
this information are the Connect by

00:32:54.120 --> 00:32:57.300
Name API and a new command
line tool online called NetTop.

00:32:57.360 --> 00:33:01.370
NetTop actually started out as a debug
tool for us to diagnose what kind of

00:33:01.620 --> 00:33:06.570
statistics we were collecting and making
sure that our statistics looked correct.

00:33:07.780 --> 00:33:12.240
So I'm going to give you a quick
demo of NetTop running on Lion.

00:33:12.260 --> 00:33:15.050
We found it was pretty useful,
so we ended up shipping

00:33:15.230 --> 00:33:17.420
this tool with Lion.

00:33:19.660 --> 00:33:21.240
So I'm going to run nettop-m.

00:33:21.260 --> 00:33:22.080
There's a man page.

00:33:22.100 --> 00:33:23.520
I know it's going to be
a little bit hard to see.

00:33:23.560 --> 00:33:25.440
Unfortunately,
it takes up the whole screen.

00:33:25.490 --> 00:33:27.790
But we can see--

00:33:27.940 --> 00:33:32.520
and I will be talking about the process
and each of the sockets underneath it.

00:33:32.520 --> 00:33:34.800
We have various
information like the state,

00:33:34.860 --> 00:33:41.170
the packets, round trip times,
lots of great information for figuring

00:33:41.170 --> 00:33:47.310
out what's going on in your network.

00:33:47.310 --> 00:33:47.310
We can collapse it.

00:33:47.310 --> 00:33:47.310
Scroll down to the end,
switch to delta mode and I can bring up

00:33:47.370 --> 00:33:48.660
and Safari.

00:33:48.660 --> 00:33:52.400
We can see all of this
loads in real time.

00:33:52.400 --> 00:33:55.700
So here's our web process and all of
the connections we've got established.

00:33:55.700 --> 00:33:58.500
You can see we actually connected
over V6 some of the time.

00:33:58.500 --> 00:34:03.610
And then we can zoom in on San Francisco,
maybe?

00:34:03.610 --> 00:34:03.610
Yeah.

00:34:04.990 --> 00:34:07.000
and San Francisco.

00:34:07.010 --> 00:34:11.130
And we can see that on various
sockets we're loading data as

00:34:11.230 --> 00:34:13.600
we scroll around and zoom in.

00:34:13.630 --> 00:34:16.340
So that's NetTop looking at sockets.

00:34:16.390 --> 00:34:19.640
We also have a routing
mode where we can download

00:34:20.850 --> 00:34:24.890
We can look at the whole running
table and all the statistics we've

00:34:24.890 --> 00:34:27.080
been collecting on all the hosts.

00:34:27.230 --> 00:34:28.920
So we can see here we've got,

00:34:29.590 --> 00:34:31.800
and the default route,
along with all the different hosts we've

00:34:31.800 --> 00:34:34.470
connected to over the default route,
we have information about all the

00:34:34.560 --> 00:34:38.540
packets we've sent and bytes and we
have things like the round trip times,

00:34:38.630 --> 00:34:47.010
we have statistics on how the default
route itself is performing as well as

00:34:47.030 --> 00:34:51.720
some of the hosts that we're talking to.

00:34:51.760 --> 00:34:52.530
So that's NetTop.

00:34:52.530 --> 00:34:52.530
I encourage you to go check that out.

00:34:52.530 --> 00:34:52.530
Oops.

00:35:02.000 --> 00:35:04.440
So in addition to all
this network statistics,

00:35:04.440 --> 00:35:05.780
we've added network throttling.

00:35:05.810 --> 00:35:10.540
iOS 5 has a lot of cool features
like all the iCloud stuff.

00:35:10.560 --> 00:35:12.780
But that can put a big
load on the network.

00:35:12.850 --> 00:35:15.470
And we're very concerned that when
your networking application is running

00:35:15.600 --> 00:35:17.930
in the foreground on the phone,
we want it to be as

00:35:18.010 --> 00:35:19.750
responsive as possible.

00:35:20.300 --> 00:35:23.010
So in the event that you do have
a networking application and

00:35:23.010 --> 00:35:25.750
it's running in the foreground,
we'll go ahead and throttle all of

00:35:25.750 --> 00:35:29.220
the background traffic so that your
application will remain responsive and

00:35:29.220 --> 00:35:31.590
the users will have a good experience.

00:35:32.390 --> 00:35:34.640
We also needed to make sure that
we didn't actually slow down the

00:35:34.640 --> 00:35:37.230
background traffic too much because
if we cause the background traffic

00:35:37.310 --> 00:35:40.700
to take a longer period of time,
then we have to keep the interfaces

00:35:40.700 --> 00:35:45.500
powered up in a high power mode which
costs us electricity and the battery

00:35:45.500 --> 00:35:48.170
runs down faster and that's not good.

00:35:48.980 --> 00:35:52.460
So there are a few conditions under
which you will experience throttling.

00:35:52.560 --> 00:35:56.700
First, it's only going to happen to
background applications and sockets,

00:35:56.740 --> 00:36:02.500
as well as sockets for iOS services
that weren't initiated by the user.

00:36:02.530 --> 00:36:06.140
And then it will only ever be
throttled if there is also a networking

00:36:06.140 --> 00:36:09.500
application in the foreground on iOS.

00:36:10.280 --> 00:36:13.460
So we used two different techniques
to handle this throttling.

00:36:13.540 --> 00:36:15.790
For the transmit side,
we changed the way that we

00:36:15.790 --> 00:36:17.700
adjust the congestion window.

00:36:17.770 --> 00:36:20.750
Under normal operation,
the congestion window starts out small.

00:36:20.850 --> 00:36:23.380
The congestion window controls
how quickly TCP sends.

00:36:23.430 --> 00:36:25.360
TCP will start out with a
small congestion window,

00:36:25.360 --> 00:36:28.220
which means send slowly,
and it'll slowly grow it.

00:36:28.300 --> 00:36:31.240
So it'll basically send faster
and faster and faster until

00:36:31.240 --> 00:36:33.200
there's some packet loss,
and then it'll back off,

00:36:33.210 --> 00:36:34.570
and then it'll start
sending faster again.

00:36:34.700 --> 00:36:37.090
And it does this to try and
find the best throughput given

00:36:37.200 --> 00:36:39.380
the current network conditions.

00:36:40.310 --> 00:36:43.280
In the event that we're throttling,
we'll do what we would normally

00:36:43.280 --> 00:36:45.980
do where we grow the congestion
with it slowly so we start sending

00:36:45.980 --> 00:36:47.200
faster and faster and faster.

00:36:47.270 --> 00:36:50.040
But we're also going to watch the
round trip times because the round trip

00:36:50.040 --> 00:36:54.520
times have the biggest effect on the
perceived responsiveness of the network.

00:36:54.610 --> 00:36:56.860
So if those round trip
times start to go up,

00:36:56.930 --> 00:36:59.480
we'll go ahead and slow down
even before we hit packet loss.

00:36:59.550 --> 00:37:01.680
If we hit packet loss,
we'll also slow down.

00:37:01.750 --> 00:37:04.800
But this should leave the network
with pretty low round trip times

00:37:04.980 --> 00:37:08.740
so the foreground application will
have a very responsive experience.

00:37:09.740 --> 00:37:12.880
On the receive side,
we adjust the receive window that

00:37:12.920 --> 00:37:15.140
we advertise to the remote sender.

00:37:15.140 --> 00:37:19.360
Normally the receive window is based
on the receive socket buffer size.

00:37:19.360 --> 00:37:21.990
In the throttled case,
we will actually measure the inter-packet

00:37:21.990 --> 00:37:25.530
delay variation and we will come up with
an estimate of the round trip time and

00:37:25.530 --> 00:37:29.190
if the round trip time starts going up,
we will advertise a smaller

00:37:29.190 --> 00:37:32.730
receive window so that the remote
side will have to send slower.

00:37:35.200 --> 00:37:37.910
So if you have a background process,
you're going to go through

00:37:37.910 --> 00:37:39.840
a few different phases.

00:37:39.840 --> 00:37:42.630
When your process is first
switched out of the foreground and

00:37:42.630 --> 00:37:45.750
goes into the background on iOS,
for a short period of time,

00:37:45.750 --> 00:37:50.460
your application will be allowed
to perform some operations.

00:37:50.460 --> 00:37:53.060
You get a chance to finish up your work.

00:37:53.060 --> 00:37:54.680
Normally you'll be going full bore.

00:37:54.680 --> 00:37:57.500
But if there is another application
that comes into the foreground and

00:37:57.730 --> 00:38:01.610
that's a networking application,
then your sockets will become throttled.

00:38:01.610 --> 00:38:04.530
So you may see slightly
diminished performance.

00:38:06.200 --> 00:38:09.100
After that short period of time where
you're allowed to finish up your work,

00:38:09.100 --> 00:38:11.200
your application may be suspended.

00:38:11.200 --> 00:38:14.860
When it's suspended,
the sockets will be shut down and the

00:38:14.860 --> 00:38:17.200
Bonjour records may be unregistered.

00:38:17.200 --> 00:38:20.260
What this means is when your
application resumes again,

00:38:20.260 --> 00:38:22.450
it's really important to
handle all the errors that

00:38:22.450 --> 00:38:24.200
you might get on your sockets.

00:38:24.200 --> 00:38:26.980
If you try and perform any operation
on one of these shut down sockets,

00:38:26.980 --> 00:38:28.140
you get a bunch of errors.

00:38:28.200 --> 00:38:33.200
You have to close the socket,
create a new socket, and connect again.

00:38:33.200 --> 00:38:36.200
You may also need to
re-register Bonjour records.

00:38:36.200 --> 00:38:40.200
There's a Bonjour session tomorrow that
will cover that in much more detail.

00:38:41.490 --> 00:38:44.160
The last new feature in iOS 5
that we're going to go over is

00:38:44.280 --> 00:38:47.220
TCP automatic socket buffer sizing.

00:38:47.710 --> 00:38:50.260
So a TCP socket has two socket buffers.

00:38:50.340 --> 00:38:52.160
There's a receive buffer
and a send buffer.

00:38:52.380 --> 00:38:55.560
And normally these are set
to fairly hard-coded values.

00:38:55.610 --> 00:39:00.450
But the buffers need to be large
enough to handle a network that has

00:39:00.450 --> 00:39:04.110
high latency but very high throughput,
but we don't want to make them

00:39:04.110 --> 00:39:07.580
too large or we end up potentially
wasting a lot of kernel resources.

00:39:07.780 --> 00:39:11.900
So we've added code in iOS 5 to
automatically resize the buffer based

00:39:11.900 --> 00:39:16.080
on the current round trip times and the
current throughput that we're seeing.

00:39:16.110 --> 00:39:19.400
This does require TCP timestamps
in order to work properly.

00:39:19.500 --> 00:39:23.270
So if you're running a server that
your application talks to please make

00:39:23.270 --> 00:39:25.800
sure that TCP timestamps are turned on.

00:39:25.840 --> 00:39:30.780
Also, if you're interacting at the socket
layer with the socket and you're

00:39:30.780 --> 00:39:34.760
currently setting the SO send buff
or SO receive buff socket options,

00:39:34.800 --> 00:39:38.130
those socket options tell the system,
my send buffer or my receive

00:39:38.140 --> 00:39:39.660
buffer should be this size.

00:39:39.850 --> 00:39:42.480
And if you tell the system
to use a specific size,

00:39:42.500 --> 00:39:45.800
the system will honor that request,
but it means the system can't

00:39:45.800 --> 00:39:49.930
dynamically scale to whatever will
perform best on the current network.

00:39:51.310 --> 00:39:55.630
So to wrap up, if you can,
use the highest level core foundation

00:39:55.640 --> 00:39:58.600
or foundation networking API possible.

00:39:58.670 --> 00:40:01.980
Convey as much information as
possible to the networking stack.

00:40:02.010 --> 00:40:06.040
If you're already using these APIs,
chances are your application

00:40:06.040 --> 00:40:07.900
already works with IPv6.

00:40:08.490 --> 00:40:11.050
If you have a networking
application on iOS,

00:40:11.160 --> 00:40:14.560
it's really important to remember
to add the UI requires persistent

00:40:14.660 --> 00:40:17.000
Wi-Fi property in your info P list.

00:40:17.060 --> 00:40:20.610
This tells the system don't disassociate
Wi-Fi after some period of time.

00:40:20.880 --> 00:40:24.130
It also tells the system when your
application is in the foreground,

00:40:24.200 --> 00:40:26.560
the background traffic
should be throttled.

00:40:26.630 --> 00:40:32.780
There is a power cost to this, though,
so if you don't have a

00:40:32.780 --> 00:40:32.780
networking application,
please don't set this.

00:40:33.720 --> 00:40:34.600
Handle errors.

00:40:34.600 --> 00:40:37.640
You're going to run into errors when
your application suspends and is resumed.

00:40:37.880 --> 00:40:41.520
You're going to run into errors as
your application is running on a device

00:40:41.520 --> 00:40:44.930
that moves from cellular Wi-Fi or Mac,
or MacBook that moves

00:40:45.010 --> 00:40:46.610
from Ethernet to Wi-Fi.

00:40:46.770 --> 00:40:50.720
Or even staying on the same network,
you can have an IPv6 network renumbering

00:40:50.720 --> 00:40:52.600
event that can generate errors.

00:40:52.600 --> 00:40:58.030
It's really important to handle
these errors in the best way possible

00:40:58.030 --> 00:41:00.410
without getting the user involved
for a very seamless experience.

00:41:01.280 --> 00:41:04.730
Finally, let the system pick the
socket buffer sizes.

00:41:04.970 --> 00:41:06.800
The system will do a great job.

00:41:06.850 --> 00:41:08.900
It knows more about what's
going on on the network than

00:41:08.900 --> 00:41:10.580
your application's likely to.

00:41:10.700 --> 00:41:14.890
So unless you absolutely need to,
please don't use those socket options.

00:41:15.930 --> 00:41:18.290
And while I've got your attention,
I just wanted to remind you it's

00:41:18.400 --> 00:41:23.000
really important not to do any blocking
network operations on the main thread.

00:41:23.140 --> 00:41:26.170
The main thread is really important
for responding to the user quickly.

00:41:26.350 --> 00:41:30.140
If you have some blocking operation and
it takes a while and the user is trying

00:41:30.140 --> 00:41:34.680
to scroll or do anything else in the UI,
the UI is going to be unresponsive and

00:41:34.680 --> 00:41:37.170
that's really not a good experience.

00:41:38.300 --> 00:41:41.530
So to show you some of the tools
available to help diagnose problems,

00:41:41.530 --> 00:41:44.270
I'd like to invite up Vincent Lubet.

00:41:49.230 --> 00:41:50.380
Good morning.

00:41:50.500 --> 00:41:53.620
So I'm going to present
a couple of tools,

00:41:53.620 --> 00:41:58.110
as Anil said, that were developed by the
CoreOS Networking team,

00:41:58.110 --> 00:42:00.500
and I hope you'll find them useful.

00:42:00.500 --> 00:42:03.460
The first one is the
Network Link Conditioner.

00:42:03.460 --> 00:42:07.570
So as its name implies,
it's a tool that you can

00:42:07.570 --> 00:42:12.780
use on your Mac to emulate
some networking conditions.

00:42:12.780 --> 00:42:17.460
So the idea is that when you
start developing your app,

00:42:17.460 --> 00:42:20.630
you can, you know,
often you develop in the

00:42:20.630 --> 00:42:21.720
comfort of your office.

00:42:21.730 --> 00:42:25.410
Maybe you have a server on the
same LAN with gigabit connection.

00:42:25.410 --> 00:42:26.800
Everything is fine.

00:42:26.800 --> 00:42:33.760
So over gigabit link, you know,
it's very easy to do whatever.

00:42:33.760 --> 00:42:36.880
And also it's very easy to make
mistakes that you're going to pay

00:42:36.980 --> 00:42:42.760
when you bring your application and,
you know, get over Wi-Fi.

00:42:42.780 --> 00:42:45.280
Or even 3G networks and things like that.

00:42:45.340 --> 00:42:50.270
So we developed that tool so
that very early on when you

00:42:50.400 --> 00:42:54.230
start to develop your code,
you can test, you know,

00:42:54.230 --> 00:42:56.130
into various network conditions.

00:42:56.140 --> 00:42:59.140
So that's the goal.

00:42:59.140 --> 00:43:06.020
And so NLC, or Network Link Conditioner,
works for all application and, in fact,

00:43:06.020 --> 00:43:07.920
services on the Mac.

00:43:08.020 --> 00:43:11.470
And that also includes the simulator.

00:43:11.560 --> 00:43:17.710
So it's also for... for you
iOS developers when you can...

00:43:17.760 --> 00:43:20.960
Before you test your application
on the actual device,

00:43:20.960 --> 00:43:25.360
which is very, very important,
this tool is not a substitute

00:43:25.440 --> 00:43:30.370
to actual real-world testing,
but it's just a facility.

00:43:30.800 --> 00:43:33.800
So what NLC can do?

00:43:33.800 --> 00:43:38.540
So it acts on all the traffic that
comes in and out of your system,

00:43:38.540 --> 00:43:39.660
the APV4 traffic.

00:43:39.690 --> 00:43:45.890
It limits bandwidth,
so based on the actual throughput,

00:43:46.060 --> 00:43:50.600
so it's going to, you can just set,
you know, I want 10 kilobits per second.

00:43:51.360 --> 00:43:56.580
It can add delays to test with this
latency that's really a limiting

00:43:56.580 --> 00:43:59.360
factor for most applications.

00:43:59.360 --> 00:44:02.320
You can add packet loss.

00:44:02.320 --> 00:44:04.900
Sometimes it's interesting,
we found interesting to

00:44:04.930 --> 00:44:06.140
add some delays to DNS.

00:44:06.140 --> 00:44:10.590
And there are some side effects
with that that may come.

00:44:10.590 --> 00:44:15.790
And you can specify different
settings for uplink and downlink.

00:44:15.790 --> 00:44:21.160
You can simulate asynchronous
links like DSL or things like that.

00:44:21.450 --> 00:44:25.990
And you can create your own
configuration and that's something

00:44:25.990 --> 00:44:28.470
I'm going to show you in a while.

00:44:28.620 --> 00:44:32.940
So the networking conditioner sits,
you know, somewhere.

00:44:32.940 --> 00:44:36.650
It's a filter at the IP level
in the networking stack.

00:44:36.690 --> 00:44:40.480
And it really affects all the
traffic that goes in and out

00:44:40.480 --> 00:44:42.950
of your networking interface.

00:44:43.020 --> 00:44:50.200
So to use that, we have a preference
panel that you set up.

00:44:50.200 --> 00:44:51.200
You turn it on.

00:44:51.260 --> 00:44:53.220
And you can change some settings.

00:44:53.320 --> 00:44:57.690
And so when you turn it on,
it's going to affect all the application,

00:44:57.690 --> 00:45:01.250
all the traffic going in and
out of the apps of your system.

00:45:01.670 --> 00:45:05.980
And that's what I'm going to show you.

00:45:06.230 --> 00:45:10.050
I'm going to switch to the demo machine.

00:45:10.170 --> 00:45:17.050
So to demonstrate that,
I'm going to-- we wrote--

00:45:17.170 --> 00:45:19.090
A little Cocoa application.

00:45:19.150 --> 00:45:24.500
So please,
this is just a demo application.

00:45:24.510 --> 00:45:26.570
We are not UI.

00:45:26.710 --> 00:45:27.880
We are not Cocoa developers.

00:45:27.950 --> 00:45:30.530
We are more network guys.

00:45:30.540 --> 00:45:34.600
So this didn't go through any review.

00:45:34.600 --> 00:45:40.900
But it's just to show you
what can happen in some case.

00:45:41.010 --> 00:45:43.240
So we have a little text field.

00:45:43.240 --> 00:45:46.790
And I'm running locally a web server.

00:45:47.120 --> 00:45:55.600
I can show you in the sharing panel.

00:45:55.630 --> 00:45:55.630
I'm running just a web sharing here.

00:45:55.930 --> 00:46:02.000
So, and it's this demo,
it's going to download that JPEG,

00:46:02.000 --> 00:46:05.640
it's a 3 megabit, or 3 megabyte file,
sorry.

00:46:05.640 --> 00:46:09.510
And when you load it, it's very fast.

00:46:09.540 --> 00:46:12.790
And here, maybe you see at the bottom,
the tab,

00:46:12.790 --> 00:46:16.970
it's making a blocking operation,
but it's very fast, you know.

00:46:16.980 --> 00:46:21.330
We're doing the blocking, download,
and SEL connection on the main thread,

00:46:21.770 --> 00:46:23.450
something that you shouldn't do.

00:46:24.080 --> 00:46:27.930
But, you know, on a fast network,
it works pretty well.

00:46:27.940 --> 00:46:32.210
Now,
if I bring the Network Link Conditioner,

00:46:32.260 --> 00:46:38.650
And just enter my password.

00:46:39.110 --> 00:46:46.090
We have this little panel and that
has some settings called profile.

00:46:46.140 --> 00:46:50.240
So we have a number,
as you can see on the

00:46:50.910 --> 00:46:57.510
On your left,
a number of preset profiles with some

00:46:58.230 --> 00:47:01.250
This is something that is kind
of average representation of

00:47:01.440 --> 00:47:06.290
different conditions for 3G,
Wi-Fi, DSL, Edge.

00:47:06.460 --> 00:47:12.130
And here at the bottom
I created a custom one,

00:47:12.130 --> 00:47:13.700
a custom that just adds delay.

00:47:13.730 --> 00:47:16.070
And it's going to add
delay to all the traffic,

00:47:16.070 --> 00:47:20.240
whether it's on the loopback
interface or Ethernet or anything.

00:47:20.320 --> 00:47:24.960
So I'm just adding 100 milliseconds
delay for each direction.

00:47:25.000 --> 00:47:28.610
But because the packets, you know,
it's going to travel, you know,

00:47:28.620 --> 00:47:34.820
a request response is going to
take 400 milliseconds total time.

00:47:34.870 --> 00:47:38.020
Because it's going in, out, and back.

00:47:38.100 --> 00:47:46.730
So now if I go back, clear the --

00:47:46.990 --> 00:47:51.070
The screen,
I have a little toggle button here that

00:47:51.180 --> 00:47:54.090
can show that the UI is responsive.

00:47:54.090 --> 00:47:58.180
And now when I have
just adding that delay,

00:47:58.350 --> 00:48:01.740
a local connection is going
to take a lot of time.

00:48:01.870 --> 00:48:03.740
And the UI is not responsive.

00:48:03.770 --> 00:48:04.520
I cannot type.

00:48:04.890 --> 00:48:09.870
And I just have to wait about 10
seconds for the download to complete.

00:48:10.040 --> 00:48:13.480
If it's a non-blocking case,
we have the other tab.

00:48:13.480 --> 00:48:21.770
I can do the same with the same
400 milliseconds round trip time.

00:48:21.920 --> 00:48:25.400
It's going to take about the same time,
but while I'm here,

00:48:25.400 --> 00:48:27.050
the UI is still responsive.

00:48:27.120 --> 00:48:31.140
I can bring in the keyboard.

00:48:31.170 --> 00:48:32.690
The UI is still responsive.

00:48:32.720 --> 00:48:36.120
So that's kind of really
the point that Josh made.

00:48:36.130 --> 00:48:39.800
Never, never make blocking
operation in the main thread.

00:48:39.800 --> 00:48:45.380
Because latency that you just
added is going to kill performance.

00:48:45.630 --> 00:48:50.360
So with that,
the summary for Networking Conditioner,

00:48:50.360 --> 00:48:54.790
it's a tool, it's just a facility to
help you really develop your

00:48:54.790 --> 00:48:59.100
application and your networking,
the logic of your network from the start.

00:48:59.180 --> 00:49:03.340
This is not a substitute
for real-life testing,

00:49:03.340 --> 00:49:08.930
so also go out and test your
application in various conditions.

00:49:08.970 --> 00:49:15.980
But also, the idea also is that we like
to encourage you to be mindful

00:49:15.980 --> 00:49:17.660
of best networking practice.

00:49:17.660 --> 00:49:23.830
Do not block on the main thread.

00:49:24.330 --> 00:49:26.980
Large I/O,
so if you're doing bulk data transfer,

00:49:26.980 --> 00:49:30.180
do not read and write
bytes one at a time.

00:49:30.180 --> 00:49:34.010
Even if it's sometimes it's
easier to parse some traffic,

00:49:34.020 --> 00:49:38.770
do please use several K, 20,
30 K usually is good

00:49:38.880 --> 00:49:41.380
for bulk data transfer.

00:49:41.380 --> 00:49:44.980
And something that's very,
very important, if you have a request

00:49:44.980 --> 00:49:50.720
response kind of protocol,
try as much as you can to overlap

00:49:51.230 --> 00:49:52.880
the request and the response.

00:49:53.140 --> 00:49:58.690
Do not wait for a reply to come
before sending the next request.

00:49:58.760 --> 00:50:00.340
Thanks.

00:50:00.340 --> 00:50:05.260
So because the latency is
going to add up and really,

00:50:05.260 --> 00:50:07.260
really bring a lot of delays.

00:50:07.280 --> 00:50:10.420
And it's always better
to try to fill the pipe.

00:50:10.430 --> 00:50:16.660
TCP is going to behave much better
if data is flowing than if it needs

00:50:16.660 --> 00:50:19.580
to restart for this transaction.

00:50:21.980 --> 00:50:24.500
So that was the networking condition now.

00:50:24.690 --> 00:50:28.740
So now I'm going to present
something called the,

00:50:28.740 --> 00:50:30.340
thank you.

00:50:32.840 --> 00:50:37.040
Another tool which we
more for iOS developers.

00:50:37.070 --> 00:50:42.040
So it's new in iOS 5 and also
it comes with the iOS 5 SDK.

00:50:42.040 --> 00:50:48.680
And it's simply a tool to,
that enables you to capture traffic

00:50:48.680 --> 00:50:52.600
that go in and out of your iOS device.

00:50:52.600 --> 00:50:59.760
It's not possible to run something like
TCP or Wireshark on an iPhone or an iPad,

00:50:59.760 --> 00:51:08.170
but with the help of a Mac you can now,
you can with iOS 5, you can see what's

00:51:08.170 --> 00:51:09.580
going on on your device.

00:51:09.580 --> 00:51:13.440
And sometimes it's very useful to
try to debug or diagnose what's

00:51:13.480 --> 00:51:15.080
going on with your application.

00:51:15.690 --> 00:51:23.500
And how it works is that it creates,
there's a little tool that you run

00:51:23.500 --> 00:51:29.100
on your Mac that's going to create a
network interface to represent your

00:51:29.230 --> 00:51:32.000
iOS device that's attached by USB.

00:51:32.270 --> 00:51:35.120
And with that,
because it's a networking interface,

00:51:35.120 --> 00:51:39.160
it will work with anything that
uses BPF or lead pickup on your Mac.

00:51:39.180 --> 00:51:42.190
So you can run TCP dump,
Wireshark or any other

00:51:42.430 --> 00:51:47.860
tools that uses BPF.

00:51:47.860 --> 00:51:51.720
So what you need,
so you need an iOS device,

00:51:51.730 --> 00:51:55.690
you have a Mac and a Mac and also
USB cable that you need to plug.

00:51:55.740 --> 00:51:59.770
I didn't have time to show the plug,
but the USB cable should be plugged

00:51:59.890 --> 00:52:01.950
to the iOS device and the Mac.

00:52:01.960 --> 00:52:07.770
And with that, I'm going to...

00:52:08.020 --> 00:52:12.780
Before going, it's relatively simple.

00:52:12.780 --> 00:52:14.400
There's a few steps to go through.

00:52:14.550 --> 00:52:18.500
We have a command and tool on the
Mac that's called RVI control.

00:52:18.500 --> 00:52:21.260
RVI stands for Remote Virtual Interface.

00:52:21.260 --> 00:52:25.790
And you can start and you pass the
UDID of your iOS device that you can get,

00:52:25.890 --> 00:52:28.600
for example, in the Xcode organizer.

00:52:28.600 --> 00:52:34.840
And then after you can look what's,
you know, the network,

00:52:34.840 --> 00:52:39.700
this virtual network interface that
has been created with IFconfig.

00:52:39.740 --> 00:52:43.450
So you type IFconfig,
you will see something called RVI,

00:52:43.450 --> 00:52:45.400
you know, and the number.

00:52:45.400 --> 00:52:48.970
You can attach more than one iOS device.

00:52:49.040 --> 00:52:52.130
That's why the name is not fixed.

00:52:52.200 --> 00:52:55.690
And after you can run
TCP dump or Wireshark.

00:52:55.700 --> 00:52:57.750
I'm going to show TCP dump.

00:52:57.800 --> 00:52:58.580
So you can run TCP dump.

00:52:58.580 --> 00:53:01.180
That's something we ship.

00:53:01.180 --> 00:53:03.340
And you pass the name of that interface.

00:53:03.610 --> 00:53:07.150
When you're done,
you can simply pass the minus

00:53:07.200 --> 00:53:13.110
X option to RVI control and it's
going to remove the virtual interface.

00:53:13.770 --> 00:53:18.690
and call back Anil to give
a summary of the session.

00:53:20.100 --> 00:53:24.510
To summarize the session then,
you heard about IPv6,

00:53:24.630 --> 00:53:26.520
that IPv6 transition is underway.

00:53:26.630 --> 00:53:30.340
So please test your apps with IPv6
if you're not doing it already.

00:53:30.340 --> 00:53:34.090
There's a good chance they will
be used in an IPv6-only network or

00:53:34.090 --> 00:53:36.440
with IPv4 and v6 on the network.

00:53:36.440 --> 00:53:38.920
So you want your apps to work
great in that environment.

00:53:39.900 --> 00:53:41.000
Changes under the hood.

00:53:41.000 --> 00:53:42.910
You saw the connect
by name functionality.

00:53:42.910 --> 00:53:43.580
It's great.

00:53:43.590 --> 00:53:48.060
Take advantage of it by writing to the
highest layer API possible so we can get

00:53:48.060 --> 00:53:52.970
as much information as possible and use
it to give great experience for your app.

00:53:53.040 --> 00:53:55.130
NetTop is a great tool that's online.

00:53:55.220 --> 00:53:58.410
It can give you a preview of
what the networking stack sees.

00:53:58.560 --> 00:54:00.700
So again, take advantage of that.

00:54:00.730 --> 00:54:04.220
And background connections,
now you know how they work.

00:54:04.240 --> 00:54:06.970
So be prepared to clean
up and reestablish your

00:54:06.970 --> 00:54:08.900
connections after resuming.

00:54:09.900 --> 00:54:12.020
And also the socket buffer resizing.

00:54:12.020 --> 00:54:16.450
The system tries to do the smartest thing
possible for the network environment.

00:54:16.550 --> 00:54:18.220
So that's a great takeaway.

00:54:18.240 --> 00:54:21.840
Don't set the socket buffer sizes
unless you really have to and you think

00:54:21.840 --> 00:54:24.030
that's the right thing for that network.

00:54:25.540 --> 00:54:28.780
And the two tools that you heard about,
Network Link Conditioner,

00:54:29.140 --> 00:54:31.510
please use it early and often
during development cycle.

00:54:31.650 --> 00:54:35.010
Not a substitute for real-world testing,
but before your app is

00:54:35.010 --> 00:54:38.160
ready for the real spin,
taking it for a real spin,

00:54:38.300 --> 00:54:42.300
you can see how it might perform
in a lossy Wi-Fi environment

00:54:42.320 --> 00:54:45.850
or a 3G DSL and so forth,
which is where your apps

00:54:45.970 --> 00:54:47.880
will be run by the users.

00:54:47.880 --> 00:54:53.780
So this is an early development tool
for simulating realistic conditions.

00:54:53.780 --> 00:54:57.570
And then Remote Packet Capture,
as you just saw,

00:54:57.570 --> 00:55:01.330
it can give you an idea of what
the packets that are flowing

00:55:01.330 --> 00:55:02.770
in and out of the iOS device.

00:55:02.780 --> 00:55:07.960
Here's more information
about networking in general.

00:55:08.130 --> 00:55:10.060
These slides will be available shortly,
so you don't have to

00:55:10.120 --> 00:55:11.020
write any of this down.

00:55:11.020 --> 00:55:13.770
But this information is there.

00:55:13.780 --> 00:55:17.300
The related sessions,
there was one yesterday which went

00:55:17.300 --> 00:55:19.780
over the networking key principles.

00:55:19.780 --> 00:55:22.750
There's another one tomorrow on Bonjour,
same place, same room.

00:55:22.860 --> 00:55:28.630
And with that,
thank you very much for your time.
WEBVTT

00:00:18.080 --> 00:00:20.000
Good morning, everyone.

00:00:20.030 --> 00:00:28.400
It's a wonderful Friday,
very early morning for us all.

00:00:28.470 --> 00:00:30.160
But we're here to talk about Arc.

00:00:30.310 --> 00:00:32.590
So let's dive in.

00:00:33.730 --> 00:00:35.840
In a nutshell, what is Arc all about?

00:00:35.880 --> 00:00:38.340
Arc is about simplifying
retain and release.

00:00:38.360 --> 00:00:40.730
I mean,
everybody loves retain and release,

00:00:40.730 --> 00:00:42.660
I'm sure,
but we think it could be better,

00:00:42.730 --> 00:00:45.840
it could be easier, it's more productive,
easier to maintain,

00:00:45.840 --> 00:00:48.550
we can make Objective-C a
higher level language.

00:00:48.720 --> 00:00:50.660
That's really the idea of Arc.

00:00:50.660 --> 00:00:54.060
We think we've got something
really amazing here.

00:00:54.060 --> 00:00:57.020
So if there's one thing that
you take away from this session,

00:00:57.020 --> 00:01:03.520
it's that when Xcode 4.2 ships for real,
you should move your applications to Arc.

00:01:03.570 --> 00:01:07.110
Arc is great technology and it's
really the future of Objective-C.

00:01:07.300 --> 00:01:09.920
So we're really excited about this.

00:01:09.920 --> 00:01:12.250
Let's talk about why you're
actually probably here,

00:01:12.250 --> 00:01:13.000
though.

00:01:13.050 --> 00:01:16.930
It's because we have a small
issue with applications crashing,

00:01:17.010 --> 00:01:17.560
right?

00:01:17.670 --> 00:01:21.000
Now, I know that your apps
never have these problems,

00:01:21.120 --> 00:01:25.870
of course, but some other people's apps
occasionally have some minor issues,

00:01:25.920 --> 00:01:26.380
right?

00:01:26.500 --> 00:01:30.390
And this can be everything from,
you know, getting bad reviews because

00:01:30.390 --> 00:01:33.830
an application ships and
people are complaining,

00:01:33.940 --> 00:01:35.850
but only in weird cases, right?

00:01:36.070 --> 00:01:39.940
It's only when that dangling
pointer in the app happens to

00:01:39.940 --> 00:01:44.880
manifest in a really nasty way that
crashes on some weird configuration.

00:01:44.880 --> 00:01:49.100
These problems are really nasty,
and some of them can lead to bad reviews,

00:01:49.100 --> 00:01:51.620
they can lead to your app
being rejected from the store,

00:01:51.620 --> 00:01:54.440
I mean, there's all kinds of problems
that can lead to crashes.

00:01:54.440 --> 00:01:58.860
And so we think that crashes are one of
the major problems that we want to fix.

00:01:59.000 --> 00:02:03.740
And crashes are the premier reason why
applications get rejected from the store,

00:02:03.740 --> 00:02:05.850
so if we can fix this,
it makes life better both for

00:02:05.970 --> 00:02:08.260
the end user but also for you
when you're submitting your app.

00:02:08.320 --> 00:02:12.190
It means you're much more likely to get
through the approval process smoothly.

00:02:14.200 --> 00:02:18.430
So we started looking at this and what
became really obvious is that memory

00:02:18.430 --> 00:02:20.280
management is actually really hard,
right?

00:02:20.340 --> 00:02:21.100
Everybody has to do this.

00:02:21.220 --> 00:02:22.800
We've done it for a long time.

00:02:23.090 --> 00:02:24.540
All programmers have to do this.

00:02:24.760 --> 00:02:26.940
But if you look at the
number of tools that we ship,

00:02:27.020 --> 00:02:29.600
everything from instruments,
which has a suite of really great

00:02:29.720 --> 00:02:32.670
tools for debugging memory problems,
all the way down to VM map and

00:02:32.670 --> 00:02:36.520
other really low-level tools,
it's really obvious that while

00:02:36.520 --> 00:02:40.900
everybody understands memory,
it's actually pretty hard.

00:02:40.950 --> 00:02:42.900
And when you start getting
into the details of,

00:02:42.900 --> 00:02:45.060
okay, well,
somebody made one little mistake

00:02:45.130 --> 00:02:48.250
somewhere in the application,
tracking it back to the root cause

00:02:48.250 --> 00:02:49.800
is a lot of pain and suffering.

00:02:49.840 --> 00:02:53.500
Now, you get really good at that,
but wouldn't it be better to be spending

00:02:53.500 --> 00:02:57.090
that brain power building new features,
right?

00:02:57.300 --> 00:03:01.510
So we think that memory management
is a really important problem and

00:03:01.530 --> 00:03:02.860
something we really want to tackle.

00:03:03.060 --> 00:03:05.600
Now, ARC doesn't solve all these
problems automatically,

00:03:05.600 --> 00:03:08.440
but it defines away a large
number of the problems that are

00:03:08.440 --> 00:03:10.610
the root cause of these things.

00:03:10.900 --> 00:03:14.340
So if you look at how Objective-C has
been moving over time,

00:03:14.340 --> 00:03:16.450
Objective-C is actually a
really interesting language.

00:03:16.480 --> 00:03:19.710
It's based, as Craig said on Monday,
on pragmatism.

00:03:19.890 --> 00:03:23.130
The pragmatic start of Objective-C was C.

00:03:23.240 --> 00:03:25.060
C is a fantastic language.

00:03:25.120 --> 00:03:31.400
C is the performance base that has made
the iPhone possible to be efficient

00:03:31.400 --> 00:03:34.870
and have good battery life and all of
these wonderful things that we like.

00:03:35.740 --> 00:03:37.100
And then you look at Objective-C.

00:03:37.100 --> 00:03:40.120
Well, Objective-C,
the first major step was

00:03:40.120 --> 00:03:42.660
to make C object-oriented.

00:03:42.700 --> 00:05:18.700
[Transcript missing]

00:05:19.320 --> 00:05:23.300
So, as we go forward, we talk about,
well, okay,

00:05:23.300 --> 00:05:26.200
Objective-C is an amazing language,
and it's been using retain-release.

00:05:26.340 --> 00:05:30.040
Retain-release is clearly good
enough to ship amazing products with,

00:05:30.070 --> 00:05:30.630
right?

00:05:30.640 --> 00:05:33.200
You guys have done this with your apps,
Apple's done it with

00:05:33.200 --> 00:05:34.200
its operating systems.

00:05:34.200 --> 00:05:37.050
The problem with Objective-C, though,
or with retain-release,

00:05:37.050 --> 00:05:39.030
is that you're swimming in details,
right?

00:05:39.210 --> 00:05:42.100
And you're forced to know things
like the Cocoa naming conventions.

00:05:42.100 --> 00:05:45.040
Well, if you have a new method,
that returns a plus one.

00:05:45.040 --> 00:05:46.840
If you have a copy method,
that returns a plus one.

00:05:46.840 --> 00:05:48.820
If you have a get method, it doesn't,
right?

00:05:49.200 --> 00:05:50.400
You have auto-release pools.

00:05:50.400 --> 00:05:51.790
You have things like block copy.

00:05:51.800 --> 00:05:55.200
These things, experts, all of us,
can handle.

00:05:55.200 --> 00:05:58.200
But particularly when you're
new coming to the platform,

00:05:58.200 --> 00:06:01.280
and you haven't been
dealing with this before,

00:06:01.280 --> 00:06:04.260
trying to wrap your brain around
what an auto-release pool really is,

00:06:04.280 --> 00:06:08.350
when does that object get deallocated,
not so straightforward, right?

00:06:08.360 --> 00:06:10.700
And so while you can
certainly learn this,

00:06:10.700 --> 00:06:13.680
it's something that really is challenging
when you come to the platform.

00:06:13.680 --> 00:06:16.410
Beyond that, when you're an experienced
programmer now,

00:06:16.410 --> 00:06:18.200
you have many decisions you can make.

00:06:18.520 --> 00:06:19.020
Should you use?

00:06:19.240 --> 00:06:21.280
Should you use auto-releasing
creation methods?

00:06:21.280 --> 00:06:22.240
Or should you use allocant?

00:06:22.240 --> 00:06:25.090
Well,
they both sort of do the same thing.

00:06:25.100 --> 00:06:28.140
But the first one's easier,
and you might want to

00:06:28.210 --> 00:06:29.540
use it all the time.

00:06:29.540 --> 00:06:30.840
But on the other hand,
you start feeling a

00:06:30.840 --> 00:06:33.470
little bit guilty because,
you know, that's increasing your high

00:06:33.470 --> 00:06:35.500
watermark through auto-release pools.

00:06:35.520 --> 00:06:39.260
Well, this is certainly workable.

00:06:39.260 --> 00:06:41.560
But, you know,
having to think about these details

00:06:41.560 --> 00:06:44.520
is really distracting from the
real problem of writing apps.

00:06:46.160 --> 00:06:49.250
So overall,
my personal problem with retain and

00:06:49.320 --> 00:06:52.740
release is that it forces you to
think about so many details all the

00:06:52.780 --> 00:06:56.000
time when you're writing your code,
that's actually not contributing

00:06:56.000 --> 00:06:57.210
to the value of your app.

00:06:57.340 --> 00:07:01.900
Memory management is a necessary
thing that everybody has to do,

00:07:02.220 --> 00:07:07.820
but it's really just the side thing that
gets in your way of building a great app.

00:07:08.140 --> 00:07:10.920
So the bigger problem though,
and where we started with this,

00:07:10.920 --> 00:07:12.670
is crashes.

00:07:12.800 --> 00:07:15.800
So one of the major problems
with manual memory management is

00:07:15.800 --> 00:07:20.030
that it gives you the opportunity
to occasionally make a mistake.

00:07:20.150 --> 00:07:21.540
And a bug creeps in.

00:07:21.690 --> 00:07:25.490
And this means that if you
aren't perfect all the time,

00:07:25.490 --> 00:07:27.720
which is something that
humans are not great at,

00:07:27.790 --> 00:07:30.120
then, oh, well,
your app crashes in an obscure case.

00:07:30.120 --> 00:07:31.700
You dereference a dangling pointer.

00:07:31.700 --> 00:07:33.900
You have a memory leak.

00:07:33.970 --> 00:07:36.770
These things aren't super common,
but particularly if you don't

00:07:36.770 --> 00:07:40.780
have 100% knowledge of the
Cocoa Memory Management rules,

00:07:40.860 --> 00:07:44.230
this can lead to major
problems in an application.

00:07:44.310 --> 00:07:48.290
And so what this really means is
that we all end up being really

00:07:48.360 --> 00:07:52.790
good at debugging problems,
and using these tools and understanding

00:07:52.980 --> 00:07:56.080
what the application is doing,
what it's not supposed to be doing.

00:07:56.130 --> 00:07:59.030
And I mean,
you guys are all smart people.

00:07:59.330 --> 00:08:02.780
Wouldn't you rather not be
spending your time doing this?

00:08:03.060 --> 00:08:07.630
So the idea, and based on all this
kind of information,

00:08:07.630 --> 00:08:09.560
we said, hey, well,
let's see if we can make this better,

00:08:09.730 --> 00:08:09.900
right?

00:08:09.900 --> 00:08:13.140
Memory management,
clearly something we can make better.

00:08:13.140 --> 00:08:14.200
What can we do?

00:08:14.250 --> 00:08:18.440
The first step in Xcode was
the Xcode Stack Analyzer.

00:08:18.460 --> 00:08:24.580
The analyzer uses an exponential
algorithm to walk through your

00:08:24.600 --> 00:08:26.190
code and find all kinds of bugs.

00:08:26.240 --> 00:08:28.280
And it's really powerful.

00:08:28.280 --> 00:08:30.650
It can find many different kinds of bugs,
right?

00:08:30.760 --> 00:08:32.080
It has limitations, though.

00:08:32.920 --> 00:08:35.060
One of the great things
about the analyzer,

00:08:35.060 --> 00:08:38.320
in hindsight,
is that we learned a lot from it.

00:08:38.410 --> 00:08:41.140
We learned a lot about Objective-C,
and we realized that a lot of

00:08:41.140 --> 00:08:45.460
the things that we thought we
knew about Objective-C were true,

00:08:45.460 --> 00:08:46.840
and some were false, right?

00:08:46.840 --> 00:08:49.740
We actually, it's a good way to
verify some assumptions.

00:08:49.740 --> 00:08:53.630
One thing we learned, in particular,
is that some applications

00:08:53.630 --> 00:08:55.780
have leaks everywhere,
right?

00:08:55.780 --> 00:08:59.190
This is usually because somebody,
the person who wrote the application,

00:08:59.360 --> 00:09:01.550
doesn't know the
Cocoa Memory Management Guides,

00:09:01.560 --> 00:09:02.090
right?

00:09:02.460 --> 00:09:04.210
And so we know this because
they end up filing a bug saying,

00:09:04.250 --> 00:09:05.620
hey, the analyzer is completely broken.

00:09:05.620 --> 00:09:06.620
It's saying I'm leaking everywhere.

00:09:06.620 --> 00:09:07.320
What's going on?

00:09:07.320 --> 00:09:11.420
And we look at the code, and it's like,
well, actually, sorry, but you are.

00:09:11.420 --> 00:09:16.050
And so the reality that
people are leaking memory,

00:09:16.050 --> 00:09:22.880
some people are leaking memory all
over the place in their applications,

00:09:22.880 --> 00:09:26.300
really drove home the value of
automating memory management,

00:09:26.300 --> 00:09:26.880
right?

00:09:26.880 --> 00:09:28.840
People should not have to deal with this.

00:09:28.840 --> 00:09:32.260
Another thing we learned is that
Cocoa has really strong patterns.

00:09:32.340 --> 00:09:34.470
Again,
things like the naming conventions,

00:09:34.470 --> 00:09:37.620
which we believe to be strong,
we believe that they were reliable,

00:09:37.620 --> 00:09:38.480
actually are.

00:09:38.480 --> 00:09:41.120
And so they're good enough
that we can automate them and

00:09:41.280 --> 00:09:42.700
base new tools on top of them.

00:09:42.720 --> 00:09:45.250
And then the third thing we
learned is that the analyzer

00:09:45.250 --> 00:09:46.700
does have false positives.

00:09:46.720 --> 00:09:48.620
It gets confused, okay?

00:09:48.620 --> 00:09:51.820
It could tell you, hey,
you have a memory leak, you have a bug,

00:09:51.870 --> 00:09:54.740
when you actually don't,
because the conditions that it

00:09:54.750 --> 00:09:56.800
thought could happen actually can't.

00:09:56.820 --> 00:10:01.240
Now, in the context of an analyzer,
that's fine, right?

00:10:01.240 --> 00:10:02.360
It says, hey, you might have a bug.

00:10:02.360 --> 00:10:06.880
And then you think about it,
and then you say, no, leave me alone.

00:10:06.920 --> 00:10:10.350
In the context of Arc,
this is completely unacceptable,

00:10:10.390 --> 00:10:13.970
because that means that instead
of telling you you have a bug,

00:10:14.070 --> 00:10:16.940
it actually goes through
and adds a release.

00:10:18.900 --> 00:10:22.470
when it should not be released and
now your application is crashing,

00:10:22.520 --> 00:10:23.100
right?

00:10:23.110 --> 00:10:26.310
And so learning the limitations
of the static analyzer is actually

00:10:26.310 --> 00:10:30.300
really important and critical
to making Arc 100% reliable.

00:10:30.300 --> 00:10:32.400
Because if the compiler
is not bulletproof,

00:10:32.400 --> 00:10:33.460
you can't trust it.

00:10:33.460 --> 00:10:37.600
If you can't trust it,
you really should not use it.

00:10:37.600 --> 00:10:40.800
So the end result of all
of this is that we said,

00:10:40.800 --> 00:10:43.200
hey, we want to automate this.

00:10:43.200 --> 00:10:45.040
This is a worthwhile problem.

00:10:45.040 --> 00:10:48.070
Instead of increasing the
complexity of Objective-C,

00:10:48.070 --> 00:10:51.490
we're just going to define away a whole
bunch of stuff you had to deal with,

00:10:51.590 --> 00:10:52.040
right?

00:10:52.040 --> 00:10:53.660
Of course, there are problems.

00:10:53.660 --> 00:10:54.700
We have to make it perfect.

00:10:54.700 --> 00:10:58.140
We have to fix some performance
problems in the analyzer.

00:10:58.140 --> 00:11:00.610
And that led to a different
implementation approach

00:11:00.610 --> 00:11:01.800
for the Arc compiler.

00:11:01.800 --> 00:11:08.240
But we really transferred the
interesting ideas from the analyzer.

00:11:08.240 --> 00:11:10.800
And so we said, OK,
we really want to do this.

00:11:10.800 --> 00:11:15.020
So today we're going to
talk about three things.

00:11:15.140 --> 00:11:16.120
First, I'll tell you about Arc.

00:11:16.120 --> 00:11:17.160
I'll tell you what the model is.

00:11:17.160 --> 00:11:19.040
I'll tell you about what
programming it's like,

00:11:19.040 --> 00:11:20.950
what the issues are that
you have to be aware of.

00:11:21.210 --> 00:11:24.040
After that, John McCall will tell you,
how does the compiler work?

00:11:24.040 --> 00:11:25.860
How does it reason about your code?

00:11:25.860 --> 00:11:28.500
How does it decide where to
put a retain and release?

00:11:28.500 --> 00:11:30.500
Now this is something you
shouldn't have to think about.

00:11:30.590 --> 00:11:32.170
And you don't have to think about.

00:11:32.370 --> 00:11:35.960
But hopefully it will be reassuring to
know that the compiler is based on really

00:11:36.020 --> 00:11:38.760
simple rules and they can't go wrong.

00:11:38.760 --> 00:11:41.480
And hopefully that will help with trust.

00:11:41.480 --> 00:11:43.330
And at the end,
Patrick will come up and he'll show you

00:11:43.330 --> 00:11:45.010
how to actually convert your application.

00:11:45.070 --> 00:11:47.500
And what some common
problems you might see are.

00:11:47.500 --> 00:11:49.760
And some things to be aware of with Arc.

00:11:49.760 --> 00:11:51.880
So let's dive right in.

00:11:51.880 --> 00:11:53.390
So Arc.

00:11:53.460 --> 00:11:56.560
If you haven't heard yet,
it's all about automating objects

00:11:56.560 --> 00:12:00.060
and the memory management for
objects in your application.

00:12:00.060 --> 00:12:01.760
So the idea is really simple.

00:12:01.760 --> 00:12:05.340
The compiler is going to insert
retain and release calls for you.

00:12:05.340 --> 00:12:09.450
This means it's just retain and
release code like it always has been.

00:12:09.500 --> 00:12:10.970
But you don't have to do
the memory management.

00:12:10.980 --> 00:12:13.240
The compiler is going to do it for you.

00:12:13.250 --> 00:12:14.240
A major feature of this.

00:12:14.240 --> 00:12:16.410
This means that because it's
just retain and release,

00:12:16.410 --> 00:12:19.740
it completely is interoperable with
existing retain and release code.

00:12:19.740 --> 00:12:22.160
This means that your
application can be Arc even if

00:12:22.160 --> 00:12:23.860
a system framework is not Arc.

00:12:23.860 --> 00:12:27.100
This means that if you have a
.a file in your application,

00:12:27.100 --> 00:12:29.100
it doesn't have to be converted.

00:12:29.100 --> 00:12:32.560
You can convert your application
and not all the code in it.

00:12:32.560 --> 00:12:36.010
So this interoperability
is a major feature of Arc.

00:12:36.290 --> 00:12:39.270
In addition to the compiler features,
we've actually substantially

00:12:39.270 --> 00:12:41.240
improved the runtime in many ways.

00:12:41.450 --> 00:12:43.440
Performance, for example.

00:12:43.520 --> 00:12:46.500
Adding zeroing weak pointers,
which we'll talk about in a few minutes.

00:12:46.580 --> 00:12:51.290
And also making it compatible with
Snow Leopard and iOS 4 was no easy feat,

00:12:51.290 --> 00:12:53.220
but it's really important.

00:12:53.350 --> 00:12:57.370
And so Arc in a nutshell is a combination
of compiler and runtime features

00:12:57.370 --> 00:13:01.430
that work really well together,
enable a really simple model so that

00:13:01.490 --> 00:13:03.970
you just don't have to worry about this.

00:13:04.470 --> 00:13:08.130
So to understand ARC,
I think one of the really important

00:13:08.130 --> 00:13:11.130
things to realize is what ARC is not,
right?

00:13:11.190 --> 00:13:15.080
Because this sets expectations
and also kind of tells you why

00:13:15.170 --> 00:13:17.660
ARC works as well as it does.

00:13:17.780 --> 00:13:20.990
So ARC is just automated
retain and release,

00:13:21.260 --> 00:13:21.430
right?

00:13:21.820 --> 00:13:23.060
Because it's automated
retain and release,

00:13:23.160 --> 00:13:24.420
it's not a new memory model.

00:13:24.420 --> 00:13:27.660
There's not some new thing
that's pervasively happening

00:13:27.660 --> 00:13:29.130
in your application.

00:13:29.480 --> 00:13:33.800
ARC is also, again, automating objects,
not malloc and free.

00:13:33.830 --> 00:13:36.240
Well, this doesn't mean that you
can't use malloc and free.

00:13:36.240 --> 00:13:37.160
You're welcome to call malloc.

00:13:37.290 --> 00:13:40.080
You're welcome to open file
descriptors or whatever you want.

00:13:40.080 --> 00:13:42.390
But if you call malloc,
you have to call free.

00:13:42.500 --> 00:13:44.370
And so ARC will take care of,
for example,

00:13:44.420 --> 00:13:47.400
deallocating all your IVARs and
your dealloc method for you,

00:13:47.420 --> 00:13:49.440
or releasing all your IVARs and dealloc.

00:13:49.480 --> 00:13:52.550
But if you have a file descriptor,
you still have to write a dealloc to

00:13:52.630 --> 00:13:55.350
close it when your object goes away.

00:13:55.530 --> 00:13:59.100
And so ARC is taking care
of your objects for you,

00:13:59.130 --> 00:14:01.650
but it's not getting in your way
if you want to do other stuff.

00:14:01.920 --> 00:14:04.340
And finally,
one of the major differences of ARC and

00:14:04.440 --> 00:14:09.950
other approaches is that this is a
compile-time memory management model.

00:14:09.960 --> 00:14:12.140
This is not a runtime
memory management model.

00:14:12.140 --> 00:14:14.880
If you look at memory management,
there's really three different

00:14:14.880 --> 00:14:16.580
places you can conceivably do it.

00:14:16.600 --> 00:14:19.380
One is you force a programmer
to do it completely manually.

00:14:19.480 --> 00:14:21.660
That's what retain-release is.

00:14:21.660 --> 00:14:24.640
One is you do it completely at
runtime with the garbage collector.

00:14:24.640 --> 00:14:27.570
So now you're trading off runtime
performance to scan the heap

00:14:27.570 --> 00:14:31.420
and pause the application while
you're deallocating objects.

00:14:31.440 --> 00:14:35.140
Well, that's a nice model in some ways,
but now you're trading off major

00:14:35.240 --> 00:14:36.600
performance and predictability.

00:14:36.600 --> 00:14:39.860
And now your objects get deallocated
whenever the collector kicks in,

00:14:39.880 --> 00:14:43.640
not at a deterministic time when
the last reference goes away.

00:14:43.650 --> 00:14:47.300
ARC is an amazing solution
that's right in the middle.

00:14:47.490 --> 00:14:49.430
Instead of throwing away
runtime performance,

00:14:49.530 --> 00:14:51.180
we're going to have the compiler do it.

00:14:51.180 --> 00:14:55.280
This gives you the convenience of
not having to worry about memory

00:14:55.280 --> 00:14:58.500
management without the performance
hit of doing it at runtime.

00:14:58.500 --> 00:15:04.310
So we think it's a really amazing,
great answer for Objective-C.

00:15:04.910 --> 00:15:06.530
So how does this work?

00:15:06.640 --> 00:15:09.800
Well, basically you just
write Objective-C code.

00:15:09.800 --> 00:15:11.160
You never call retain or release.

00:15:11.410 --> 00:15:12.100
You just don't worry about it.

00:15:12.100 --> 00:15:16.800
You just write the code the natural,
clean way that you should be writing it.

00:15:16.830 --> 00:15:18.300
So here I have a method.

00:15:18.300 --> 00:15:21.800
This method concatenates a first name and
a last name and it returns a full name.

00:15:21.800 --> 00:15:26.120
Well, in manual reference counted code,
this would be a leak because

00:15:26.240 --> 00:15:30.040
I'm allocating an object and
I'm returning it and full name

00:15:30.040 --> 00:15:32.800
is not a +1 name for a method.

00:15:32.800 --> 00:15:36.140
Well, in ARC, it says, "Okay, well,
you're returning an object here

00:15:36.140 --> 00:15:40.710
that's +1 and so it will do the
auto-release for you." It's that easy.

00:15:40.810 --> 00:15:43.210
If you write this a different
way and you use string with

00:15:43.210 --> 00:15:46.090
format instead of allocating it,
then the compiler says, "Hey, well,

00:15:46.090 --> 00:15:47.880
I don't need to auto-release
it because it's already,

00:15:47.880 --> 00:15:51.800
you know, neutral +0,
right?" And it just does the right thing.

00:15:51.800 --> 00:15:54.940
So you write the code the natural way
that you want and then ARC takes care

00:15:54.940 --> 00:15:56.800
of the memory management for you.

00:15:56.970 --> 00:15:59.320
It's really that easy.

00:15:59.940 --> 00:16:02.330
So, one of the things that,
talking to people,

00:16:02.470 --> 00:16:05.100
I've struggled with is that people say,
"Okay, well,

00:16:05.280 --> 00:16:07.630
where does it insert the retain?

00:16:07.810 --> 00:16:09.500
"How do I know that it's
going to be retained?

00:16:09.520 --> 00:16:13.130
"How do I know that it's going
to do the right thing?" Well,

00:16:13.230 --> 00:16:15.870
just don't do that, right?

00:16:16.050 --> 00:16:18.020
First of all,
it's really hard because we have some

00:16:18.020 --> 00:16:20.390
really advanced compiler optimizations
that move retains and releases

00:16:20.400 --> 00:16:23.180
around and get rid of redundant
ones and all that kind of stuff,

00:16:23.240 --> 00:16:26.100
but also because you
don't need to do that.

00:16:26.470 --> 00:16:28.530
Just think about it
as you have an object,

00:16:28.530 --> 00:16:30.880
as long as you have a
pointer to that object,

00:16:30.920 --> 00:16:32.440
it's alive.

00:16:32.480 --> 00:16:35.200
When the last reference
of that object goes away,

00:16:35.270 --> 00:16:37.400
so does the object.

00:16:37.510 --> 00:16:38.990
It's that easy.

00:16:40.370 --> 00:16:45.100
So, that means that you start thinking
about pointers in your application.

00:16:45.150 --> 00:16:46.230
Think about your object graph.

00:16:46.380 --> 00:16:48.800
Think about if you have
a pointer to an object,

00:16:48.850 --> 00:16:51.080
that pointer is keeping it alive.

00:16:51.120 --> 00:16:53.790
That means it's owning
that in some sense,

00:16:53.790 --> 00:16:54.420
right?

00:16:54.470 --> 00:16:56.920
And so now you start thinking
about what that means,

00:16:56.940 --> 00:16:59.010
and the one thing you have
to keep in mind is the

00:16:59.170 --> 00:17:01.480
possibility of a retain cycle.

00:17:03.240 --> 00:17:06.930
and I are here to help you.

00:17:07.020 --> 00:17:14.790
So, overall,
just forget about retain and release.

00:17:14.790 --> 00:17:15.130
Hopefully, you're okay with that.

00:17:15.130 --> 00:17:15.130
I don't want to take away
your best friend or anything.

00:17:15.130 --> 00:17:15.130
But you can just leave it behind.

00:17:15.490 --> 00:17:17.790
So what does this do when you
move an application to ARC?

00:17:17.980 --> 00:17:21.440
I mean, the primary thing that
you may be wondering is,

00:17:21.520 --> 00:17:22.380
OK, I moved my app to ARC.

00:17:22.470 --> 00:17:23.020
What happens?

00:17:23.100 --> 00:17:26.020
Well,
the most obvious common thing is that

00:17:26.070 --> 00:17:27.940
your dialog methods just disappear.

00:17:28.220 --> 00:17:30.100
Tons of code dissolves.

00:17:30.200 --> 00:17:33.180
All those calls to retain
and release go away.

00:17:33.240 --> 00:17:35.680
Your code becomes much simpler.

00:17:36.110 --> 00:17:39.340
Now, there are some cases where
ARC requires new code.

00:17:39.510 --> 00:17:42.760
But these actually are
really great things,

00:17:42.760 --> 00:17:45.750
because if you look at some of the
places where ARC requires this,

00:17:45.910 --> 00:17:48.400
you can see that it's making
your code easier to understand.

00:17:48.610 --> 00:17:52.920
Now, here's a class, an example,
and in Manual Reference Counting,

00:17:52.920 --> 00:17:57.430
I look at this IVAR A and say, "Hey,
is this a retained IVAR or not?"

00:17:57.580 --> 00:18:01.380
And so to find that out,
I go look through the implementation,

00:18:01.380 --> 00:18:05.580
I look for all the uses of A, and I say,
okay, well, it's not being retained,

00:18:05.580 --> 00:18:07.330
so therefore it's an unretained IVR.

00:18:07.340 --> 00:18:09.240
And because I don't want to
have to do the search again,

00:18:09.240 --> 00:18:09.930
I add a comment.

00:18:09.950 --> 00:18:11.500
It says, hey, this is unretained.

00:18:11.520 --> 00:18:15.710
Well, this is a really fragile thing,
because looking at the interface,

00:18:15.710 --> 00:18:19.340
if you didn't add this comment,
you don't know.

00:18:19.340 --> 00:18:22.260
It's really easy to make a mistake
and actually retain it when assigning,

00:18:22.260 --> 00:18:23.990
and this is why properties came along.

00:18:24.000 --> 00:18:27.560
This is kind of solving the
problem through the language.

00:18:27.680 --> 00:18:32.410
ARC takes the same problem and solves
it a slightly different way by adding

00:18:32.410 --> 00:18:34.800
an annotation right onto the IVR.

00:18:34.820 --> 00:18:37.780
And so we're building it right
into the language where you say,

00:18:37.820 --> 00:18:41.420
hey, this defaults to a retained IVR,
but if you want to have a weak IVR or

00:18:41.420 --> 00:18:44.660
a non-retained IVR of some other sort,
you add it right to the code.

00:18:44.810 --> 00:18:47.800
This means that looking at the code,
it's really obvious how

00:18:48.050 --> 00:18:50.230
your IVRs are being used,
and you can't mess it up,

00:18:50.300 --> 00:18:52.200
because the compiler
takes care of it for you.

00:18:53.300 --> 00:18:55.510
So we think that these
additions are really great.

00:18:55.650 --> 00:18:59.120
It makes your code much more obvious,
and it makes it easier to understand

00:18:59.120 --> 00:19:02.080
when somebody else comes to your code
and needs to fix a bug or add a feature.

00:19:02.080 --> 00:19:04.640
This is the right thing to do.

00:19:06.440 --> 00:19:09.490
So how do we make Arc compatible
with existing code?

00:19:09.570 --> 00:19:11.640
So before the conference,
you're happily writing

00:19:11.640 --> 00:19:14.300
retain-release code,
and we can't just say, "Hey, well,

00:19:14.300 --> 00:19:17.060
your code doesn't
compile anymore." Right?

00:19:17.200 --> 00:19:19.590
You probably would not appreciate that.

00:19:19.710 --> 00:19:22.490
So to do that, we add a new flag.

00:19:22.560 --> 00:19:27.500
Arc is a new mode in the compiler
that's enabled by passing fobjc_arc,

00:19:27.630 --> 00:19:30.310
and that means that if
you're not passing this flag,

00:19:30.310 --> 00:19:32.670
which you haven't been,
then your application still

00:19:32.760 --> 00:19:34.860
builds the same way it was,
and you know what?

00:19:34.980 --> 00:19:37.000
Retain-release will always be supported.

00:19:37.030 --> 00:19:38.450
There's no problem with that, right?

00:19:38.540 --> 00:19:40.690
If you like manually
doing retain-release,

00:19:40.690 --> 00:19:42.900
you can continue to do that.

00:19:42.910 --> 00:19:47.450
So Arc only is kicked in when you
have an Arc application or when,

00:19:47.450 --> 00:19:49.520
you know, the flag is being passed.

00:19:49.740 --> 00:19:54.290
Now, part of this is that in Xcode 4.2,
all the new projects default to Arc.

00:19:54.380 --> 00:19:58.140
So if you start a new app,
it will automatically be Arc.

00:19:58.310 --> 00:20:00.760
If you have an existing app,
then you go through a process

00:20:01.030 --> 00:20:04.800
called migration to get to Arc,
And we'll show you how

00:20:04.800 --> 00:20:06.130
that works in a bit.

00:20:06.530 --> 00:20:09.340
So I talked before about the
static analyzer and how the

00:20:09.340 --> 00:20:11.660
static analyzer is a great tool,
but it gets confused.

00:20:11.660 --> 00:20:14.150
This is completely
unacceptable for the compiler.

00:20:14.160 --> 00:20:16.540
The compiler must be 100% reliable.

00:20:16.620 --> 00:20:20.300
Now to do this,
we have to make an engineering

00:20:20.300 --> 00:20:24.150
trade-off on how do we make it so
the compiler can reason about the

00:20:24.310 --> 00:20:26.230
code 100% of the time correctly.

00:20:26.240 --> 00:20:29.300
So the solution to this is that
we're actually adding a few new

00:20:29.320 --> 00:20:33.320
rules that you have to follow in
ARC mode that make it 100% reliable.

00:20:33.840 --> 00:20:36.460
And at the end of the day,
it formalizes best practices

00:20:36.460 --> 00:20:37.780
Objective-C anyways.

00:20:37.780 --> 00:20:41.110
And so there's four new rules,
and let's walk through those.

00:20:41.160 --> 00:20:43.650
The first rule is that the
compiler is going to be doing

00:20:43.650 --> 00:20:45.280
the retains and release for you.

00:20:45.340 --> 00:20:49.060
That means you are not allowed
to call retain and release.

00:20:49.160 --> 00:20:52.220
If you try, the compiler will tell
you you can't do that.

00:20:52.280 --> 00:20:55.260
Now I'm sorry,
I hope you're not sad about this.

00:20:55.260 --> 00:20:58.180
I mean, it means that wonderful things
like this where you're looping over

00:20:58.260 --> 00:21:00.570
the retain count calling release,
you can't do that anymore.

00:21:00.600 --> 00:21:02.340
I know you're disappointed, right?

00:21:03.600 --> 00:21:05.150
But the great thing is you don't have to,
right?

00:21:05.190 --> 00:21:07.980
This is a sign that something
has gone tragically wrong.

00:21:07.980 --> 00:21:09.930
This isn't a feature, right?

00:21:09.940 --> 00:21:13.260
And so, in fact, not calling retain and
release is a huge feature.

00:21:13.260 --> 00:21:16.290
Now, one other aspect of this is
it means you can't implement

00:21:16.470 --> 00:21:17.930
retain and release yourself.

00:21:17.960 --> 00:21:21.030
And there have been a few
patterns that have needed this.

00:21:21.040 --> 00:21:24.210
And so to solve that,
we've actually added other

00:21:24.210 --> 00:21:26.300
answers for those patterns.

00:21:26.320 --> 00:21:28.620
So singletons, for example,
one common way to implement

00:21:28.620 --> 00:21:31.300
a singleton was to implement
retain and release for yourself.

00:21:31.450 --> 00:21:33.300
Well,
you just don't have to do that in ARC.

00:21:33.360 --> 00:21:36.720
One common reason was for
performance because NSObjects

00:21:37.010 --> 00:21:39.860
retain and release implementation
wasn't as fast as it could be.

00:21:40.030 --> 00:21:43.920
So we heavily optimized NSObjects
retain and release performance.

00:21:43.940 --> 00:21:45.580
So now you don't have to do that, right?

00:21:45.800 --> 00:21:48.030
And so instead of giving
you a way to do this,

00:21:48.030 --> 00:21:51.120
we've tried to define a way
the reasons you wanted to.

00:21:52.510 --> 00:21:56.720
The second rule is that you're
not allowed to use a retained

00:21:57.270 --> 00:22:00.900
pointer to an object in a C struct.

00:22:01.080 --> 00:22:04.640
Now this is a pretty nasty one
because it seems like the compiler

00:22:04.640 --> 00:22:07.130
should be able to make it work.

00:22:07.320 --> 00:22:11.380
The problem here is that the compiler
needs to know when an IVAR or a reference

00:22:11.500 --> 00:22:13.510
to an object comes and when it goes.

00:22:13.570 --> 00:22:15.400
C structs are completely freeform.

00:22:15.400 --> 00:22:18.040
You can allocate them with malloc
and they're filled with garbage.

00:22:18.100 --> 00:22:19.920
You can pass them off to free
and they get deallocated.

00:22:19.920 --> 00:22:23.680
You can pass them through several levels
of function call and then they get freed.

00:22:23.720 --> 00:22:26.110
Well, the problem with this is
that when you do that free,

00:22:26.230 --> 00:22:28.840
the compiler needs to
know to release that IVAR.

00:22:28.860 --> 00:22:30.820
And okay, well,
you have a pointer to a struct.

00:22:31.070 --> 00:22:32.500
Is it a pointer to one struct?

00:22:32.590 --> 00:22:34.880
Is it a pointer to an array?

00:22:34.890 --> 00:22:36.440
The compiler doesn't know.

00:22:36.440 --> 00:22:41.000
And so instead of guessing and
trying to make it sometimes work,

00:22:41.020 --> 00:22:44.640
we said we need it to be reliable
and so just don't do this.

00:22:44.640 --> 00:22:46.810
Now, this again is not a huge problem.

00:22:46.980 --> 00:22:49.500
You shouldn't be using
C structs anyways generally.

00:22:49.750 --> 00:22:51.280
You should use objects.

00:22:51.330 --> 00:22:54.840
So best practice in Objective-C is
and always has been to use objects.

00:22:54.870 --> 00:22:57.810
And so if you're using
these kinds of things,

00:22:57.850 --> 00:22:59.190
objects are a good answer.

00:22:59.230 --> 00:23:01.280
If this doesn't work for you
because you have like some dense

00:23:01.290 --> 00:23:04.640
hash table or something like that,
you can use void star.

00:23:04.720 --> 00:23:08.140
So this is an example of the
kinds of tradeoffs we've made so

00:23:08.210 --> 00:23:12.400
that it makes your code easier
to reason about for the compiler.

00:23:12.440 --> 00:23:15.920
It makes it really clear what's
happening in your application.

00:23:16.140 --> 00:23:19.400
So another issue is casting.

00:23:19.570 --> 00:23:20.710
So we do not automate objects.

00:23:20.810 --> 00:23:24.520
We do not automate file
descriptors or core foundation

00:23:24.520 --> 00:23:27.350
or anything other than objects.

00:23:27.440 --> 00:23:31.690
So if you do a cast,
the compiler has to know if you're

00:23:31.700 --> 00:23:36.160
casting to a CFRF or a void star,
is it retained or not, right?

00:23:36.250 --> 00:23:39.880
And so if you try to do a bear cast like
one of these guys where you're casting

00:23:39.880 --> 00:23:44.760
between a CFRF and an object pointer,
then the compiler will tell you, hey,

00:23:44.760 --> 00:23:46.440
you can't do that.

00:23:46.500 --> 00:23:47.640
Well, what's the solution?

00:23:47.790 --> 00:23:50.310
The solution is to tell the
compiler what it needs to know.

00:23:50.350 --> 00:23:53.560
And so we're adding a few
new modifiers to these casts.

00:23:53.560 --> 00:23:55.920
So you say, hey,
this is a transferring cast.

00:23:55.920 --> 00:24:02.160
This gives the retain count from the
CF object to the-- to arc to manage.

00:24:02.200 --> 00:24:03.560
And I'm not going to go
into these in detail,

00:24:03.560 --> 00:24:04.780
but it's very straightforward.

00:24:04.790 --> 00:24:06.730
We're also adding new CF API.

00:24:06.790 --> 00:24:09.590
So you can say,
I want to do a CF bridging retain,

00:24:09.870 --> 00:24:10.780
things like that.

00:24:10.870 --> 00:24:13.720
And so this gives you new
patterns so you can use.

00:24:13.720 --> 00:24:15.750
And the idea here, again,
is that we don't want to be

00:24:15.780 --> 00:24:18.270
super intrusive in the code,
but the compiler has to

00:24:18.270 --> 00:24:19.120
know what's going on.

00:24:19.120 --> 00:24:22.120
Otherwise, you get a fragile model
that's not reliable.

00:24:22.120 --> 00:24:24.880
And the compiler has to be reliable.

00:24:24.880 --> 00:24:27.680
So the fourth thing is, again,
a really minor thing.

00:24:27.680 --> 00:24:30.100
You can't use the
NSAutoReleasePool class.

00:24:30.100 --> 00:24:32.880
Well, NSAutoReleasePool is this
interesting class where it's never

00:24:32.880 --> 00:24:34.420
really been an object anyways.

00:24:34.420 --> 00:24:36.640
I mean,
you allocate it with alloc and it,

00:24:36.670 --> 00:24:38.000
but you can't actually retain it.

00:24:38.000 --> 00:24:40.780
If you retain it, it throws an exception.

00:24:40.820 --> 00:24:44.020
So the problem with NSAutoReleasePool
from the compiler's perspective is

00:24:44.020 --> 00:24:45.920
it's not necessarily properly scoped.

00:24:46.080 --> 00:24:47.560
It's not necessarily properly balanced.

00:24:47.560 --> 00:24:48.920
You can do all kinds of weird things.

00:24:48.920 --> 00:24:51.040
You can do an alloc and then
sometime later do an init,

00:24:51.040 --> 00:24:51.800
for example.

00:24:52.030 --> 00:24:56.860
And the compiler has to reason about
references that live across that pool.

00:24:56.890 --> 00:24:59.760
Well, to do this, we build it directly
right into the language.

00:24:59.770 --> 00:25:01.800
There's a new @AutoReleasePool statement.

00:25:01.830 --> 00:25:05.390
It works just like @Synchronize,
where on entry it pushes

00:25:05.570 --> 00:25:07.500
and on exit it pops.

00:25:07.530 --> 00:25:11.820
Really straightforward, syntactically,
also much more elegant.

00:25:11.980 --> 00:25:16.840
And this defines away the problem
and makes the model 100% reliable.

00:25:16.870 --> 00:25:21.180
Now, through these four simple rules,
we get a really great model where

00:25:21.430 --> 00:25:26.460
we think that Objective-C code is
easier to read and the compiler

00:25:26.460 --> 00:25:28.880
will always do the right thing.

00:25:28.890 --> 00:25:31.930
And that's really the power of ARC.

00:25:32.080 --> 00:25:36.490
So let's talk about one more minor issue,
which ARC-- also,

00:25:36.490 --> 00:25:38.920
@AutoReleasePool works everywhere,
not just in ARC.

00:25:39.170 --> 00:25:42.940
So one more minor issue,
which is retain cycles.

00:25:42.960 --> 00:25:45.460
Now, ARC is just automating
retain and release.

00:25:45.480 --> 00:25:47.640
So the compiler is doing
retain and release for you.

00:25:47.850 --> 00:25:48.520
Now, unfortunately,
the compiler is not doing that.

00:25:48.570 --> 00:25:51.930
The compiler does not know the
bigger picture of how the objects

00:25:51.930 --> 00:25:54.020
in your application work together.

00:25:54.020 --> 00:25:56.760
So because of this and because
it's just retain and release,

00:25:56.760 --> 00:25:59.360
retain cycles,
which have always-- the possibility

00:25:59.370 --> 00:26:02.920
of retain cycles always existed,
can still happen in ARC.

00:26:02.950 --> 00:26:05.840
So to give you an example of this,
say you have some objects.

00:26:05.840 --> 00:26:07.420
Each of these objects get a retain count.

00:26:07.600 --> 00:26:08.790
So there's three
pointers-- the first one,

00:26:08.860 --> 00:26:11.260
two pointers, the second one, et cetera.

00:26:11.260 --> 00:26:15.080
Now, if you drop a reference
to an object in a cycle,

00:26:15.080 --> 00:26:18.320
the retain count drops,
but it doesn't drop to zero.

00:26:18.930 --> 00:26:19.800
Thank you.

00:26:49.790 --> 00:26:49.800
Thank you.

00:26:49.800 --> 00:26:51.410
So, we're going to talk about
the source of crashes,

00:26:51.460 --> 00:26:51.800
right?

00:26:51.840 --> 00:26:53.790
Because an assigned property
or non-retained IVAR is,

00:26:53.790 --> 00:26:56.770
you know, a potentially dangling pointer.

00:26:56.850 --> 00:27:00.070
It's pointing to an object,
the object gets deallocated, you know,

00:27:00.070 --> 00:27:02.790
you have a pointer to that old object,
and if you dereference it, well,

00:27:02.920 --> 00:27:05.610
it won't crash for you,
it'll crash for your customers instead,

00:27:05.610 --> 00:27:05.950
right?

00:27:06.090 --> 00:27:10.720
This is the insidious kinds of problems
that memory management bugs lead to.

00:27:10.780 --> 00:27:12.440
And so we want to solve this as well.

00:27:12.440 --> 00:27:14.760
So in addition to automating
memory management,

00:27:14.760 --> 00:27:18.790
we're introducing a new kind of
pointer called a zeroing weak pointer.

00:27:20.100 --> 00:29:38.000
[Transcript missing]

00:29:38.750 --> 00:29:41.890
So, we're not going to go in
depth into blocks here,

00:29:41.900 --> 00:29:44.540
but if you're interested,
there was a talk earlier this week,

00:29:44.540 --> 00:29:47.600
and the Objective-C advancements
in-depth talk later today,

00:29:47.600 --> 00:29:48.940
we'll talk about this in more detail.

00:29:48.940 --> 00:29:54.780
So, ARC now is, I think,
a really fantastic model for Objective-C.

00:29:54.800 --> 00:29:57.710
You may be wondering, can you use it?

00:29:57.840 --> 00:30:01.520
Well, the first thing to keep in mind
is that there is no runtime that's

00:30:01.520 --> 00:30:04.980
kicking in and stopping your
application to collect memory.

00:30:05.040 --> 00:30:07.390
So, first of all,
you don't have any of those kinds of

00:30:07.450 --> 00:30:10.680
problems that cause your application
to stutter in unpredictable ways

00:30:10.680 --> 00:30:12.000
because the collector kicks in.

00:30:12.020 --> 00:30:13.760
So, ARC doesn't require that.

00:30:13.880 --> 00:30:16.080
What about performance elsewhere?

00:30:16.080 --> 00:30:18.710
Well, we really wanted to take away
any fear that ARC was going

00:30:18.710 --> 00:30:19.990
to cost you performance.

00:30:20.000 --> 00:30:23.000
So, we went through and optimized
three different subsystems of the

00:30:23.020 --> 00:30:25.040
Objective-C runtime and the frameworks.

00:30:25.060 --> 00:30:28.460
One is the retain-release
implementation in NSObject,

00:30:28.460 --> 00:30:32.560
one is the new auto-release pool syntax,
and one is Objective-C message

00:30:32.560 --> 00:30:33.340
send itself.

00:30:34.340 --> 00:30:40.340
And so, in iOS 5 and in Lion, now,
you'll see the NSObject is much faster,

00:30:40.490 --> 00:30:42.460
two and a half times
faster than it was before.

00:30:42.500 --> 00:30:45.760
This is a major performance win,
and this defines away many

00:30:45.760 --> 00:30:49.070
reasons for wanting to implement
your own custom retain-release.

00:30:49.100 --> 00:30:53.570
Also, the new auto-release pool syntax,
it doesn't have to allocate an object,

00:30:53.570 --> 00:30:54.880
it's just bumping a pointer.

00:30:54.880 --> 00:30:57.760
It's much faster than
NS auto-release pool used to be.

00:30:57.880 --> 00:30:59.600
So, it's six times faster.

00:30:59.680 --> 00:31:01.580
This means if you did crazy
things where you're saying,

00:31:01.580 --> 00:31:03.080
"Okay, well, in my loop,
only drain it some time,"

00:31:03.080 --> 00:31:07.240
you can just use auto-release
pool and not worry about it.

00:31:07.240 --> 00:31:09.640
It's much simpler,
you shouldn't have to worry

00:31:09.640 --> 00:31:11.270
about this kind of stuff,
right?

00:31:11.510 --> 00:31:14.300
We've even sped up
Objective-C message send.

00:31:14.310 --> 00:31:17.280
Now, I admit,
this is not a huge speed up.

00:31:17.280 --> 00:31:19.490
We shaved three cycles off it.

00:31:19.570 --> 00:31:23.860
It turns out Objective-C message send
is already highly performance optimized,

00:31:23.890 --> 00:31:27.230
but it's really core part of Objective-C,
and it turns out three cycles

00:31:27.460 --> 00:31:30.930
on something that's not 12
cycles is a huge speed up,

00:31:31.150 --> 00:31:31.760
right?

00:31:31.870 --> 00:31:32.100
And so, we think that these substantial
changes in the performance

00:31:32.100 --> 00:31:34.410
of the object-c message send,
will really help with performance

00:31:34.650 --> 00:31:38.980
of the system overall and
with Rcaps in particular.

00:31:39.530 --> 00:31:42.020
So, a final optimization,
which we'll describe again in

00:31:42.020 --> 00:31:46.120
more detail in the in-depth talk,
is that the compiler and runtime

00:31:46.120 --> 00:31:49.280
were co-designed so they could do
really impressive optimizations.

00:31:49.280 --> 00:31:52.700
One example of this is with
auto-release return values.

00:31:52.820 --> 00:31:56.900
So, in many cases,
when an ARC method calls some other

00:31:57.150 --> 00:32:02.100
code which ends up doing an auto-release
and returning an auto-release object,

00:32:02.100 --> 00:32:04.960
that object never gets put
in an auto-release pool.

00:32:04.980 --> 00:32:09.280
It gets magically warped back to ARC,
and it can just use it directly,

00:32:09.280 --> 00:32:11.420
which saves a retain,
it saves an auto-release,

00:32:11.420 --> 00:32:14.370
that object doesn't get put in
the auto-release pool at all,

00:32:14.630 --> 00:32:17.650
making this dramatically faster,
up to 20 times faster.

00:32:17.680 --> 00:32:20.730
This means atomic properties,
common getters,

00:32:20.730 --> 00:32:24.910
a lot of things are much faster,
which doesn't work in non-ARC mode,

00:32:24.910 --> 00:32:28.240
but this is one of the major
advantages of co-designing

00:32:28.240 --> 00:32:30.500
the language with the runtime.

00:32:30.500 --> 00:32:31.740
It's fantastic.

00:32:31.780 --> 00:32:34.730
So, we'll explain more about how
this works in other talks.

00:32:34.980 --> 00:32:39.480
But this gives you a really high-level
idea of what ARC's all about.

00:32:39.670 --> 00:32:43.290
It's about synthesizing retain-release,
so the compiler does it,

00:32:43.290 --> 00:32:44.270
and you don't have to.

00:32:44.280 --> 00:32:47.530
We add a few new runtime things,
like zero-week pointers,

00:32:47.890 --> 00:32:51.430
which help define away a common
cause of crashes in applications.

00:32:51.600 --> 00:32:55.500
And to make it reliable,
there's new rules that you can follow.

00:32:55.500 --> 00:32:56.390
They're not onerous.

00:32:56.580 --> 00:32:57.260
They're very simple.

00:32:57.260 --> 00:33:00.460
And the result of this is that
you get a great model where your

00:33:00.700 --> 00:33:02.860
applications generally just work.

00:33:02.860 --> 00:33:04.720
You don't have to worry
about retain-release.

00:33:04.980 --> 00:33:07.380
In many cases, they're even faster
than they were before.

00:33:07.380 --> 00:33:09.630
And, you know,
it's just a better place to be.

00:33:09.650 --> 00:33:12.820
So, to give you an idea of
how this actually works,

00:33:12.820 --> 00:33:16.030
details that the compiler thinks about
and you don't have to worry about,

00:33:16.030 --> 00:33:19.770
I'd like to invite John McCall up to tell
you about what goes into the compiler and

00:33:19.770 --> 00:33:21.950
how the compiler thinks about your code.

00:33:21.960 --> 00:33:23.460
John?

00:33:26.780 --> 00:33:27.700
Thanks, Chris.

00:33:27.700 --> 00:33:31.320
Thanks, Chris.

00:33:31.320 --> 00:33:32.200
My name is John McCall.

00:33:32.200 --> 00:33:35.640
I work on the compiler
team on the LLVM compiler,

00:33:35.650 --> 00:33:39.620
most recently on automated
reference counting.

00:33:39.680 --> 00:33:43.320
I want to give you an idea
of how ARC does all of this,

00:33:43.320 --> 00:33:47.240
mostly so that you can have a lot
more confidence in the compiler,

00:33:47.240 --> 00:33:52.270
but also so that when you understand
how you might need to make -- if you

00:33:52.270 --> 00:33:56.450
need to make -- if you still -- if
you can't convert completely over

00:33:56.450 --> 00:33:59.970
to Automated Reference Counting,
if you need to have some

00:33:59.970 --> 00:34:03.130
of your stuff still manual,
retain, and release,

00:34:03.130 --> 00:34:06.970
then you kind of need to know this
so that you understand how that

00:34:06.970 --> 00:34:09.350
code needs to interoperate with ARC.

00:34:09.720 --> 00:34:11.290
So, memory management is hard.

00:34:11.440 --> 00:34:12.680
Chris covered this great.

00:34:12.850 --> 00:34:14.530
I don't want to belabor this.

00:34:14.670 --> 00:34:16.480
But there's a lot of
rules and conventions,

00:34:16.480 --> 00:34:18.510
some of which I'm going to go over today.

00:34:18.600 --> 00:34:22.600
It's a lot of -- it's a huge
hurdle for coming to our platform.

00:34:22.600 --> 00:34:25.570
It requires constant attention
for existing developers,

00:34:25.660 --> 00:34:27.600
and it really requires perfection.

00:34:27.600 --> 00:34:30.660
And to really bring that home,
I want to work through an example

00:34:30.830 --> 00:34:34.600
of what I consider to be a great
application as a compiler writer,

00:34:34.600 --> 00:34:36.590
which is a stack.

00:34:36.600 --> 00:34:39.590
Now, this is a very simple stack.

00:34:39.690 --> 00:34:43.600
We've got a -- it's backed
by an NSMutable array.

00:34:43.600 --> 00:34:45.600
We allocate that in the init.

00:34:45.600 --> 00:34:46.600
We push it.

00:34:46.600 --> 00:34:49.100
When we want to push
something onto the stack,

00:34:49.240 --> 00:34:50.600
we just add it to the end.

00:34:50.600 --> 00:34:51.590
When we want to pop
something from the stack,

00:34:51.640 --> 00:34:57.150
we just pull it off and then
actually remove that last thing.

00:34:57.530 --> 00:35:00.900
This is a very natural way of coding,
and it makes sense to

00:35:00.900 --> 00:35:02.200
write code like this.

00:35:02.280 --> 00:35:06.050
But if you're an experienced
Objective-C developer,

00:35:06.070 --> 00:35:10.520
you're already looking at this and
probably identifying three or four

00:35:10.610 --> 00:35:14.100
different major memory problems in this,
right?

00:35:14.250 --> 00:35:19.790
So the first one of those is
that this array is auto-released.

00:35:20.460 --> 00:35:25.460
So when we're storing it in,
if this stack needs to persist

00:35:25.460 --> 00:35:30.190
across popping an auto-release pool,
like between UI events,

00:35:30.240 --> 00:35:34.130
this array is just going to become
magically a dangling reference.

00:35:34.260 --> 00:35:38.070
All of this is when you're compiling
in manual retain and release mode,

00:35:38.100 --> 00:35:38.900
of course.

00:35:38.990 --> 00:35:41.380
So in order to fix that in
manual retain and release,

00:35:41.490 --> 00:35:44.310
we have to actually insert this retain.

00:35:44.420 --> 00:35:47.920
That causes a problem because
now that retain is not being

00:35:47.920 --> 00:35:50.280
balanced out by this code anywhere.

00:35:50.390 --> 00:35:54.980
So we end up needing to add this
totally new method that we didn't,

00:35:54.980 --> 00:35:57.820
you know,
think that we needed to write before,

00:35:57.830 --> 00:36:00.880
called Dialog,
which will actually release that thing.

00:36:00.920 --> 00:36:03.660
And as part of doing that,
you have to also remember

00:36:03.660 --> 00:36:04.800
to call superDialog.

00:36:04.800 --> 00:36:07.790
And of course,
none of you would ever make this mistake,

00:36:07.790 --> 00:36:09.000
but it does happen.

00:36:10.200 --> 00:36:14.260
That fixes the problem with this IVAR,
but then we have this other

00:36:14.330 --> 00:36:20.330
problem with the pop method,
where we pull something out of the array,

00:36:20.330 --> 00:36:24.140
and then we remove the
array's reference to it.

00:36:24.210 --> 00:36:26.380
And if that was the
last reference to that,

00:36:26.380 --> 00:36:29.290
if that was the last
retained count of that,

00:36:29.710 --> 00:36:32.340
This is going to be a dangling
reference immediately,

00:36:32.340 --> 00:36:35.600
and we're going to end up returning
that and probably crashing our caller.

00:36:35.600 --> 00:36:40.600
And the really frustrating thing about
that is that sometimes it'll work,

00:36:40.740 --> 00:36:45.600
because sometimes the objects that I've
stored in here are retained elsewhere,

00:36:45.600 --> 00:36:50.600
and sometimes it'll work because I'm
accessing a reference that's gone away,

00:36:50.600 --> 00:36:55.750
but maybe nothing else is
allocated at that same address,

00:36:55.750 --> 00:36:57.590
and it still kind of works.

00:36:57.600 --> 00:37:01.770
And sometimes it'll look like it
works for even more elaborate reasons,

00:37:01.770 --> 00:37:03.600
and it's frustrating.

00:37:03.600 --> 00:37:08.600
So the way that you have to fix that,
again, in manual mode,

00:37:08.600 --> 00:37:11.700
is that you actually
have to do a retain here,

00:37:11.730 --> 00:37:14.150
but that's a problem,
because that's going to

00:37:14.150 --> 00:37:18.060
end up giving us a leak,
because our callers aren't going to

00:37:18.060 --> 00:37:22.180
expect to have to do a release here,
so instead we have to do an

00:37:22.380 --> 00:37:24.890
auto-release at the last second.

00:37:25.120 --> 00:37:28.390
This is a very small,
kind of contrived example,

00:37:28.450 --> 00:37:32.540
but it's the sort of thing that you have
to think about all the time when you're

00:37:32.540 --> 00:37:34.440
doing manual retain and release code.

00:37:34.620 --> 00:37:35.440
Right?

00:37:35.440 --> 00:37:38.040
You shouldn't need to write about that.

00:37:38.160 --> 00:37:39.470
You shouldn't need to worry about that.

00:37:39.480 --> 00:37:41.200
It should just work.

00:37:41.340 --> 00:37:42.900
ARC makes this just work.

00:37:42.900 --> 00:37:45.040
I'll go ahead and blow my punchline.

00:37:45.040 --> 00:37:51.660
This is a -- that code that you
just saw works perfectly in ARC.

00:37:51.800 --> 00:37:57.660
It works exactly the same way that we had
to write -- that we wrote out manually.

00:37:57.680 --> 00:37:58.420
Right?

00:37:58.500 --> 00:38:02.460
So the idea here is that in ARC,
you can just write code naturally

00:38:02.460 --> 00:38:04.260
the way that you want to do.

00:38:04.480 --> 00:38:05.060
Right?

00:38:05.100 --> 00:38:06.890
You don't have to worry
about retains and releases.

00:38:06.900 --> 00:38:08.750
The compiler just does it for you.

00:38:08.830 --> 00:38:11.380
All you need to worry about
is breaking cycles when

00:38:11.380 --> 00:38:13.260
necessary in your object graph.

00:38:13.560 --> 00:38:17.540
Otherwise, you can focus on the things
that are important to you.

00:38:18.760 --> 00:38:20.920
So, how does Arc actually do this?

00:38:21.070 --> 00:38:24.440
Well, mostly it's just automating
existing practice.

00:38:24.510 --> 00:38:30.380
It's automating what you would have had
to do in manual retain and release mode.

00:38:30.400 --> 00:38:33.310
It does that by applying
very local rules.

00:38:33.320 --> 00:38:37.810
So,
on the scope of an individual operation,

00:38:37.920 --> 00:38:41.380
it's always balancing
out retains and releases.

00:38:41.630 --> 00:38:46.150
Individual stores or
calls or things like that.

00:38:47.350 --> 00:38:49.370
It's trying to guarantee
local correctness,

00:38:49.370 --> 00:38:52.310
which then ends up creating a
whole lot of work for itself,

00:38:52.310 --> 00:38:56.130
and then we have an extremely
powerful optimizer to clean that

00:38:56.130 --> 00:38:59.130
up and make it as fast as possible.

00:38:59.790 --> 00:39:01.600
But that's the high-level
view of how Arc works.

00:39:01.640 --> 00:39:03.900
Now I said it applies local rules.

00:39:03.960 --> 00:39:05.880
There are really two
classes of rules here.

00:39:05.930 --> 00:39:14.320
The first class is the rules for having
a pointer to something in memory,

00:39:14.320 --> 00:39:14.320
right?

00:39:14.360 --> 00:39:15.700
What I'm going to call a variable.

00:39:15.880 --> 00:39:19.600
Like this is any sort of -- but this
is really any sort of place where

00:39:19.600 --> 00:39:20.870
we're storing a pointer in memory.

00:39:20.880 --> 00:39:25.700
Like a global variable or an instance
variable or something like that.

00:39:25.730 --> 00:39:30.590
Anything -- any sort of variable like
this that's an Objective-C pointer

00:39:30.660 --> 00:39:35.090
type or a block pointer type
ends up being managed by Arc.

00:39:35.540 --> 00:39:38.730
We looked at all the code
that's out there right now

00:39:38.890 --> 00:39:42.670
when we were designing Arc,
and we identified three different

00:39:42.670 --> 00:39:47.500
common patterns for three different
ways in which we could automate how

00:39:48.260 --> 00:39:53.920
people keep references in memory.

00:39:54.280 --> 00:40:00.800
The most important one of those
by far is strong references.

00:40:00.800 --> 00:40:04.560
So this is what a strong reference is,
is it maintains the invariant

00:40:04.560 --> 00:40:10.960
that whatever it's holding onto
is retained by that variable.

00:40:10.960 --> 00:40:13.000
In Arc, this is the default variable.

00:40:13.000 --> 00:40:16.160
So when you write something
like NSString name here,

00:40:16.180 --> 00:40:19.870
you're actually going to get
what the compiler interprets

00:40:19.960 --> 00:40:22.100
this as is strong NSString name.

00:40:22.100 --> 00:40:25.440
And it really works a lot
like a retained property.

00:40:25.440 --> 00:40:26.430
What do I mean by that?

00:40:26.440 --> 00:40:30.800
Well, when we're creating a variable,
and this is any sort of variable.

00:40:30.800 --> 00:40:33.040
Like even a local variable on the stack.

00:40:33.040 --> 00:40:36.920
The first thing that we always do
is we always initialize it to nil.

00:40:36.920 --> 00:40:39.340
This is important for the code
that we're going to generate,

00:40:39.340 --> 00:40:41.880
but it's also really,
really crucial for the

00:40:41.880 --> 00:40:43.740
safety of your code.

00:40:43.740 --> 00:40:49.460
This by itself is going to save you a
huge amount of annoying debugging effort.

00:40:49.460 --> 00:40:54.350
Because you don't have to worry about
random little bits of code that you

00:40:54.350 --> 00:40:58.940
forgot to initialize and therefore get
filled with total trash from the stack,

00:40:58.940 --> 00:41:00.800
and then your program
has all sorts of errors.

00:41:00.800 --> 00:41:05.800
All sorts of crazy errors
in it that only turn up far

00:41:05.800 --> 00:41:09.320
downstream of the original bug.

00:41:09.320 --> 00:41:11.530
So it's a lot safer.

00:41:11.610 --> 00:41:16.000
This is a huge -- this by itself
is a huge improvement in your

00:41:16.000 --> 00:41:19.020
life as an Objective-C programmer.

00:41:19.020 --> 00:41:23.060
The second important thing is
when you're destroying a variable.

00:41:23.150 --> 00:41:26.700
Like for a local variable,
that means when it goes out of scope.

00:41:26.700 --> 00:41:30.800
For an instance variable,
that means when it's being deallocated.

00:41:30.800 --> 00:41:33.390
When you're destroying
a strong reference,

00:41:33.390 --> 00:41:36.660
you just take the current
value in it and you release it.

00:41:37.160 --> 00:41:37.800
Right?

00:41:37.800 --> 00:41:38.800
Maintaining the invariant that --

00:41:40.330 --> 00:41:43.400
You know, you have this invariant that
whatever is in there is retained.

00:41:43.520 --> 00:41:45.890
When the variable goes away,
you have to release it.

00:41:45.930 --> 00:41:47.890
This happens for everything.

00:41:48.010 --> 00:41:52.870
Because we do this even for IVARs,
that's the most common reason

00:41:53.060 --> 00:41:54.810
for you to need a dialog.

00:41:55.040 --> 00:41:59.780
Usually, you will almost never need
to write a dialog anymore.

00:42:01.130 --> 00:42:04.030
The last two rules for dealing
with a variable like this are when

00:42:04.030 --> 00:42:05.870
you're reading or writing from it.

00:42:05.890 --> 00:42:08.660
Now, when you're reading,
there's nothing special going on at all.

00:42:08.780 --> 00:42:11.970
For writes, again,
we're maintaining that invariant.

00:42:12.060 --> 00:42:18.010
So that means you take the new value
that you're doing the assignment,

00:42:18.120 --> 00:42:20.130
you retain that,

00:42:21.260 --> 00:42:24.700
Remember the old value, do the store,
and then release the

00:42:24.700 --> 00:42:26.100
old value afterwards.

00:42:26.360 --> 00:42:27.100
Right?

00:42:27.100 --> 00:42:28.500
Again, maintaining that invariant.

00:42:28.610 --> 00:42:29.590
And that's it.

00:42:29.960 --> 00:42:34.090
That is most of how Arc actually
keeps things working.

00:42:34.250 --> 00:42:34.940
Right?

00:42:35.100 --> 00:42:37.530
Just applying those simple
rules methodically over and

00:42:37.530 --> 00:42:40.490
over again throughout your code.

00:42:41.730 --> 00:42:48.410
So the second set of semantics
that we found for local variables,

00:42:48.490 --> 00:42:52.460
variables in general,
are auto-releasing references.

00:42:52.560 --> 00:42:57.120
This is really just solidifying
the behavior of out parameters.

00:42:57.160 --> 00:43:00.790
So this is just describing what these do.

00:43:00.940 --> 00:43:04.060
It's not really useful for general use,
so I'm going to gloss over this.

00:43:04.210 --> 00:43:07.460
Basically, it just means you retain an
auto-release when you write into it.

00:43:07.570 --> 00:43:10.380
And otherwise,
it doesn't have any extra rules.

00:43:10.700 --> 00:43:12.700
The third kind--

00:43:12.840 --> 00:43:14.500
is unsafe references.

00:43:14.560 --> 00:43:16.640
So this is a lot,
the behavior a lot like an

00:43:16.730 --> 00:43:17.900
assigned property today.

00:43:18.010 --> 00:43:20.370
In fact,
it's exactly like an assigned property.

00:43:20.520 --> 00:43:22.800
So when you're loading from it,
it's just a load.

00:43:22.800 --> 00:43:26.460
When you're storing from it,
it's just a store.

00:43:26.480 --> 00:43:29.580
Totally unmanaged by the compiler.

00:43:29.600 --> 00:43:31.460
That means there's no extra logic for it.

00:43:31.550 --> 00:43:33.040
It also means there's no restrictions.

00:43:33.040 --> 00:43:35.880
So you can put it in a stack
or on a stack like that.

00:43:35.910 --> 00:43:37.720
Or in a struct.

00:43:37.920 --> 00:43:41.300
You can have one of these in a struct.

00:43:42.070 --> 00:43:47.800
Now, because there's no extra logic here,
they really are unsafe, right?

00:43:47.920 --> 00:43:51.430
You can end up, these can easily become
dangling references.

00:43:51.550 --> 00:43:54.340
So we said, "All right,
well those are the three kinds "of

00:43:54.650 --> 00:43:59.990
variables that we see in code today,
"but this one is really bad, right?

00:44:00.080 --> 00:44:03.800
"This is not how you should be,
you know..." Chris mentioned that there's

00:44:03.800 --> 00:44:06.820
all these potential problems with it.

00:44:07.020 --> 00:44:07.950
We think we can do better.

00:44:07.960 --> 00:44:11.140
We can give you a better tool
for breaking routine cycles than

00:44:11.140 --> 00:44:12.980
just these unsafe references.

00:44:13.120 --> 00:44:18.220
So instead we added
weak references to Arc,

00:44:18.220 --> 00:44:18.220
right?

00:44:18.710 --> 00:44:21.830
They behave exactly like
assigned references,

00:44:21.910 --> 00:44:25.260
except for this magical thing
where they become nil as soon as

00:44:25.260 --> 00:44:29.140
the objects that they're pointing
to starts to be deallocated.

00:44:29.300 --> 00:44:35.620
Now, the way that works is that the
compiler inserts all these crazy

00:44:35.900 --> 00:44:39.220
and I have a few crazy calls whenever
you're manipulating one of them.

00:44:39.300 --> 00:44:41.290
If you really want to know
a lot more about these,

00:44:41.520 --> 00:44:43.290
feel free to come to
the Objective-C talk.

00:44:43.300 --> 00:44:44.640
I encourage you to.

00:44:44.640 --> 00:44:47.630
That's 11:30 today.

00:44:47.850 --> 00:44:51.850
But for the most part,
you don't need to worry

00:44:51.860 --> 00:44:54.760
about how it's actually done.

00:44:54.760 --> 00:44:59.820
Just think about it as
behaving like a weak reference.

00:44:59.820 --> 00:45:01.910
It just drops down to nil magically
when the object goes away.

00:45:02.100 --> 00:45:06.250
So the second set of rules are
for transfers in and out of the

00:45:06.350 --> 00:45:08.940
control of the local function.

00:45:09.100 --> 00:45:11.280
For the most part,
that means a return value.

00:45:11.350 --> 00:45:18.190
Is a return value transferring ownership
of a retained count to ARC or not?

00:45:20.090 --> 00:45:23.840
That's really going to be
decided in Cocoa by the kind

00:45:23.840 --> 00:45:27.100
of call that you're doing,
the name of the call.

00:45:27.400 --> 00:45:30.480
So we have this concept
called a method family.

00:45:30.480 --> 00:45:33.280
This is really just the existing
Cocoa naming convention.

00:45:33.280 --> 00:45:38.750
So if you have a method whose,
and the first word in that selector,

00:45:38.780 --> 00:45:42.920
and the selector for that method
starts with one of these magic words,

00:45:43.010 --> 00:45:47.790
then it just,
then it returns a plus one object

00:45:47.790 --> 00:45:49.980
that Arc has to balance out.

00:45:50.030 --> 00:45:50.970
Everything else doesn't.

00:45:51.060 --> 00:45:53.740
Any sort of C function
called the default behavior,

00:45:53.740 --> 00:45:59.350
it's just going to return an unmanaged,
you know, a plus zero.

00:45:59.360 --> 00:46:02.240
We have to do retains
and releases ourselves.

00:46:05.750 --> 00:46:09.750
So how does that -- how do those
rules end up translating into code

00:46:09.760 --> 00:46:11.380
that the compiler does for you?

00:46:11.520 --> 00:46:15.240
Well, a normal return where
there's no transfer,

00:46:15.240 --> 00:46:19.220
you just -- at the point of return,
you retain immediately,

00:46:19.300 --> 00:46:23.380
pop out through all the scopes of
the local variables that you're in,

00:46:23.570 --> 00:46:25.780
and then auto-release
at the very last moment.

00:46:25.900 --> 00:46:27.860
And Chris mentioned that
that auto-release is often

00:46:27.860 --> 00:46:28.920
going to be optimized.

00:46:28.920 --> 00:46:33.480
It will just turn into, you know,
it'll be a transfer of that retain

00:46:33.490 --> 00:46:36.700
count directly to the caller.

00:46:36.900 --> 00:46:44.230
For a retained return, like a method,
same method, just called new instead,

00:46:44.310 --> 00:46:45.870
that's going to pass back ownership.

00:46:45.980 --> 00:46:48.220
So it basically works
exactly the same way,

00:46:48.290 --> 00:46:50.170
except without the
auto-release at the end.

00:46:50.270 --> 00:46:55.420
And then on the other side of that,
where we're accepting it,

00:46:56.180 --> 00:47:00.170
We just take the value back,
use it however we're going to use it,

00:47:00.170 --> 00:47:04.350
and then release it sometime later at
the end of the statement when we're

00:47:04.360 --> 00:47:06.210
sure we're not using it anymore.

00:47:07.730 --> 00:47:08.740
So that's it.

00:47:08.970 --> 00:47:14.800
These are the rules that
Arc uses to make your code safer.

00:47:14.910 --> 00:47:17.390
So let's go back to our example.

00:47:19.050 --> 00:47:21.240
Here we have this init method.

00:47:21.250 --> 00:47:23.780
The important thing to look at
here is that we've got an IVAR.

00:47:23.780 --> 00:47:27.100
We have a strong IVAR now.

00:47:27.100 --> 00:47:29.360
And we have this assignment to it.

00:47:29.530 --> 00:47:32.610
So when we expand out that assignment,
again, like I mentioned before,

00:47:32.630 --> 00:47:36.680
we're going to retain the new value,
release the old value.

00:47:36.690 --> 00:47:39.540
And then since we have a strong IVAR,
we're automatically

00:47:39.590 --> 00:47:41.360
synthesizing this dialog.

00:47:41.360 --> 00:47:43.380
No complexity here.

00:47:43.460 --> 00:47:46.700
Just straightforward making it work.

00:47:47.600 --> 00:47:51.250
For this pop method,
there's two interesting things going on.

00:47:51.370 --> 00:47:53.740
The first is that we
have this local variable,

00:47:53.850 --> 00:47:57.990
which we have this assignment to,
and then it goes out of scope.

00:47:58.130 --> 00:48:00.640
And the second thing is
that we've got a return.

00:48:00.770 --> 00:48:03.330
So let's expand that return first.

00:48:03.430 --> 00:48:06.590
Like I said,
you do a return by retaining,

00:48:06.620 --> 00:48:10.110
popping out through all the
scopes that you're inside,

00:48:10.110 --> 00:48:11.300
and auto-releasing.

00:48:11.440 --> 00:48:17.510
So we pop out through all the scopes.

00:48:17.510 --> 00:48:17.510
So let's expand the behavior
for this local variable.

00:48:17.790 --> 00:48:20.760
We do a retain as part
of initializing it,

00:48:20.760 --> 00:48:22.690
and then when it goes out of scope,
we release.

00:48:23.140 --> 00:48:25.690
Now you can see already

00:48:26.240 --> 00:48:29.340
That there's this totally
unnecessary retain and release pair.

00:48:29.500 --> 00:48:31.890
This is the most trivial sort
of thing that our optimizer

00:48:31.950 --> 00:48:33.100
is capable of deleting.

00:48:33.100 --> 00:48:37.160
It's much more sophisticated,
but it can certainly zap this case.

00:48:37.340 --> 00:48:41.090
And we end up with exactly the code
that we would have written manually.

00:48:42.230 --> 00:48:45.020
It's the local rules that make this work,
right?

00:48:45.250 --> 00:48:49.100
You have local rules making
individual operations safe,

00:48:49.150 --> 00:48:54.510
and then you have a global
optimizer that's making sure that

00:48:54.510 --> 00:48:57.840
doesn't cause you any extra effort.

00:49:00.890 --> 00:49:03.800
The point is that you can
just write code like this.

00:49:03.870 --> 00:49:07.050
That natural code that we
had in the original example,

00:49:07.050 --> 00:49:12.700
it just works under Arc because of
this steady application of local rules.

00:49:14.890 --> 00:49:21.220
So to put it together for you,
ARC is there to follow the conventions.

00:49:21.280 --> 00:49:23.300
Compilers are great at
following conventions.

00:49:23.300 --> 00:49:25.520
We have to follow
conventions for everything,

00:49:25.620 --> 00:49:26.150
right?

00:49:26.220 --> 00:49:31.110
I get up in the morning to make
the compiler follow conventions.

00:49:37.130 --> 00:49:40.060
Let me do that, right?

00:49:40.100 --> 00:49:45.480
I can make the compiler follow the
rules much more precisely than you can,

00:49:45.570 --> 00:49:45.970
right?

00:49:46.160 --> 00:49:49.510
It's really simple to
just take these rules,

00:49:49.520 --> 00:49:54.500
apply it over and over again,
and end up with code that just works.

00:49:54.770 --> 00:49:57.740
What I can't do is make your apps great.

00:49:57.990 --> 00:50:00.820
I can't make your customers happy.

00:50:00.930 --> 00:50:05.950
So what I can do is let you do that
so that you don't have to think

00:50:06.000 --> 00:50:08.200
about retains and releases anymore.

00:50:08.280 --> 00:50:10.940
And that's the value of Arc.

00:50:11.010 --> 00:50:15.550
So I want to call up Patrick Beard
to talk about how you can convert all

00:50:15.550 --> 00:50:20.910
of your existing code over to Arc and
therefore take advantage of all this

00:50:20.950 --> 00:50:23.370
stuff for what you're already doing.

00:50:30.310 --> 00:50:32.580
Thanks, John.

00:50:33.140 --> 00:50:36.800
So as John said, lots of rules.

00:50:36.800 --> 00:50:40.980
The compiler is going to think about
them real hard so you don't have to.

00:50:42.530 --> 00:50:45.380
So I'm going to talk about
how you migrate your code,

00:50:45.380 --> 00:50:48.910
what you're going to see
while you're migrating,

00:50:49.070 --> 00:50:53.690
how you actually make this stuff work,
how you put it on the

00:50:53.880 --> 00:50:55.340
on our operating systems.

00:50:55.350 --> 00:50:59.620
And then I'll do a quick
demo about some real code.

00:50:59.930 --> 00:51:00.800
So the steps.

00:51:00.800 --> 00:51:04.200
Well, first, to get into this,
you have to use our compiler,

00:51:04.220 --> 00:51:07.150
LLVM version 3.

00:51:08.610 --> 00:51:12.650
You'll use a command in Xcode
which will change your code,

00:51:12.720 --> 00:51:15.140
it'll analyze your code.

00:51:15.220 --> 00:51:18.800
When it's satisfied and you have
made all the changes that it has

00:51:18.890 --> 00:51:23.980
identified that you need to make,
then it will modify the code in place,

00:51:24.090 --> 00:51:27.760
present you with the diffs,
and away you go.

00:51:29.410 --> 00:51:31.120
So here's what it looks like in Xcode.

00:51:31.280 --> 00:51:33.980
It's a refactoring.

00:51:34.030 --> 00:51:35.370
This is what it does.

00:51:35.390 --> 00:51:39.630
It goes through all your code,
finds all the problems, removes, retains,

00:51:39.630 --> 00:51:42.740
release, auto-release,
gets rid of auto-release pools,

00:51:42.740 --> 00:51:44.970
uses our new language construct.

00:51:45.320 --> 00:51:48.300
and it will replace your
assigned properties wherever

00:51:48.300 --> 00:51:50.310
possible with weak properties.

00:51:52.280 --> 00:51:54.040
So this runs in two phases.

00:51:54.040 --> 00:52:00.550
Analysis, where you find the problems,
treat them as compilers, fix them,

00:52:00.640 --> 00:52:02.750
and then analyze again.

00:52:03.160 --> 00:52:04.500
Then there's conversion.

00:52:04.580 --> 00:52:06.590
Changes the code.

00:52:06.670 --> 00:52:08.970
If you're happy with
the changes it makes,

00:52:09.090 --> 00:52:13.060
compiles it, turns on the option,
opts in,

00:52:13.200 --> 00:52:17.880
and your code now works and runs in Arc,
hopefully.

00:52:18.980 --> 00:52:23.300
So here's some of the problems
you might find when doing this.

00:52:23.370 --> 00:52:26.880
Here's a case where you
might have this in your code.

00:52:26.960 --> 00:52:30.990
You're calling a method that
the compiler has no idea

00:52:31.400 --> 00:52:47.700
[Transcript missing]

00:52:49.570 --> 00:52:53.540
Another issue would be fancy
uses of auto-release pools,

00:52:53.540 --> 00:52:56.380
where you want to go through a loop,
but you don't want to

00:52:56.380 --> 00:52:57.470
drain the pool every time.

00:52:57.620 --> 00:53:00.160
Well, that's not going to work anymore.

00:53:00.360 --> 00:53:04.430
For this code to migrate,
it has to become block-structured.

00:53:04.700 --> 00:53:07.700
So that's what this compile
error is telling us,

00:53:07.720 --> 00:53:10.550
that you can't use this class anymore,
but I don't know how to fix it.

00:53:10.710 --> 00:53:13.790
Please fix it for me.

00:53:13.910 --> 00:53:16.690
So, a simple way to fix it,
just go ahead and use the

00:53:16.860 --> 00:53:18.800
addAutoReleasePool construct.

00:53:21.720 --> 00:53:24.100
And auto-release pools are
about six times faster.

00:53:24.120 --> 00:53:26.800
So the empty case,
where there's nothing in the pool,

00:53:26.800 --> 00:53:28.400
is just really fast.

00:53:28.400 --> 00:53:32.030
We don't allocate any objects,
we just bump some pointers.

00:53:34.170 --> 00:53:37.320
Another issue if you've
done any C++ programming,

00:53:37.320 --> 00:53:41.060
this is going to be old news to you,
if you declare a variable

00:53:41.170 --> 00:53:45.360
in a case statement,
cases that follow that

00:53:45.830 --> 00:53:47.300
are going to generate this error.

00:53:47.300 --> 00:53:51.550
It just basically means add a curly.

00:53:53.880 --> 00:53:57.560
Very simple.

00:53:57.570 --> 00:53:59.880
Now let's talk about singletons.

00:54:00.230 --> 00:54:04.750
There's actually quite a number of
recommended recipes people write

00:54:04.750 --> 00:54:08.600
about online in various places,
various forums,

00:54:08.620 --> 00:54:15.680
maybe even some of our own,
that suggest ways of writing

00:54:15.730 --> 00:54:16.960
singletons that are just not
necessary anymore under Arc.

00:54:17.370 --> 00:54:20.530
You might have found examples
like this where you override,

00:54:20.530 --> 00:54:24.940
retain, and release just to more or less
prevent errors where you're using

00:54:24.940 --> 00:54:28.060
a singleton and you don't want
to accidentally over-release it

00:54:28.190 --> 00:54:29.850
and have the singleton go away.

00:54:29.910 --> 00:54:33.900
When you're writing code in Arc,
Arc takes care of this for you.

00:54:33.950 --> 00:54:36.110
This won't even compile.

00:54:39.280 --> 00:54:41.430
So you don't need to do this anymore.

00:54:41.500 --> 00:54:45.960
Trust us.

00:54:45.960 --> 00:54:49.580
Another method that people override
sometimes is allocWithZone.

00:54:49.580 --> 00:54:54.200
Purpose here being to ensure there's only
one true instance that rules them all.

00:54:54.200 --> 00:54:56.480
Well, you don't need to do that either.

00:54:56.480 --> 00:55:00.240
And there's actually a subtle bug
that can occur if you do this.

00:55:00.240 --> 00:55:03.470
If people call allocInit on
your class and they don't use

00:55:03.610 --> 00:55:07.210
your singleton accessor method,
the init method can get called

00:55:07.210 --> 00:55:09.460
multiple times on the singleton object.

00:55:09.460 --> 00:55:15.100
So you have to be really careful about
writing an init method that handles that.

00:55:15.100 --> 00:55:17.680
So just don't do it.

00:55:17.680 --> 00:55:22.200
Writing singletons,
just use simple accessor methods.

00:55:24.180 --> 00:55:27.940
If you want your singleton
allocation to be thread safe so that,

00:55:27.960 --> 00:55:30.360
I don't know,
you get actually a correctly

00:55:30.540 --> 00:55:33.320
allocated object if you're
using it for multiple threads,

00:55:33.490 --> 00:55:34.910
use dispatch once.

00:55:34.970 --> 00:55:38.880
That just solves the problem very neatly.

00:55:40.540 --> 00:55:43.600
One other thing, class objects,
well they're objects.

00:55:43.660 --> 00:55:44.890
They are singletons.

00:55:45.030 --> 00:55:49.390
So if possible, in this example,
we could just use a

00:55:49.670 --> 00:55:51.690
static global variable.

00:55:51.920 --> 00:55:54.670
and write class methods to
do the exact same thing.

00:55:54.820 --> 00:55:58.200
We don't even need to access
or allocate an instance.

00:55:58.270 --> 00:56:01.140
So consider this pattern.

00:56:03.870 --> 00:56:09.040
As we've said, assigned properties,
which are commonly used for delegates,

00:56:09.120 --> 00:56:11.090
they're going to become weak.

00:56:11.380 --> 00:56:12.630
Enough said about that topic.

00:56:12.780 --> 00:56:13.580
It's very simple.

00:56:13.610 --> 00:56:16.610
The migration tool will do
that for you automatically.

00:56:16.990 --> 00:56:18.260
All right, now where can we use this?

00:56:18.310 --> 00:56:22.080
Well, we're introducing this
with Lion and iOS 5.

00:56:24.260 --> 00:56:27.540
But we provide a compatibility
library so you can actually deploy

00:56:27.700 --> 00:56:30.430
your code and you don't have to
make the decision about using ARC.

00:56:30.670 --> 00:56:35.390
You can just use it and it will
work on Snow Leopard and iOS 4.

00:56:40.270 --> 00:56:41.040
So how does it work?

00:56:41.080 --> 00:56:43.340
Well, you use the deployment target.

00:56:43.400 --> 00:56:47.580
A very natural way of telling the
compiler this is what you're doing.

00:56:47.740 --> 00:56:52.740
Choose an earlier deployment target:
10.6, iOS 4.

00:56:53.190 --> 00:56:57.440
The linker will automatically be
given a library that is linked into

00:56:57.450 --> 00:57:05.330
your program that runs at full speed
if you're running on iOS 5 or 10.7,

00:57:05.340 --> 00:57:08.080
and it goes into a compatibility
mode if it finds itself on

00:57:08.160 --> 00:57:10.140
an earlier operating system.

00:57:10.260 --> 00:57:12.810
So your code is compatible.

00:57:13.970 --> 00:57:16.740
We give you something,
we've got to take something away though.

00:57:16.810 --> 00:57:21.060
The classes that we have in our
frameworks and our runtime system are

00:57:21.340 --> 00:57:24.070
where weak references are supported.

00:57:24.270 --> 00:57:27.880
So on these earlier systems,
weak references are not available.

00:57:27.900 --> 00:57:30.260
So you have to use this
unsafe and retained.

00:57:30.400 --> 00:57:33.310
The migration tool will actually
do this for you as well.

00:57:33.510 --> 00:57:37.000
And the compiler won't let you
accidentally use a weak reference if

00:57:37.100 --> 00:57:38.950
you're deploying to earlier systems.

00:57:39.160 --> 00:57:40.780
It'll just become a compiler.

00:57:40.850 --> 00:57:41.850
So it's convenient.

00:57:41.930 --> 00:57:44.100
You'll always know what you're doing.

00:57:44.100 --> 00:57:47.690
So let's do a demo.

00:57:55.170 --> 00:57:56.720
So this is an open source application.

00:57:56.720 --> 00:57:58.230
It's called WikiHow.

00:57:58.320 --> 00:58:00.920
It's a front end to a website.

00:58:01.380 --> 00:58:04.500
I've prepared this so
it should fire right up.

00:58:04.620 --> 00:58:06.300
It's pre-built, not for Arc.

00:58:06.300 --> 00:58:15.310
So let's see how this converts.

00:58:21.210 --> 00:58:23.960
So right away,
it shows us that our main routine has

00:58:23.960 --> 00:58:26.530
a problem with its auto-release pool.

00:58:27.770 --> 00:58:33.330
This is actually an instance of that use
of an unstructured auto-release pool.

00:58:35.600 --> 00:58:40.690
So we have to hoist this
variable declaration before it.

00:58:40.910 --> 00:58:43.970
A way to think about this is think of
auto-release pulls as curly braces,

00:58:43.990 --> 00:58:45.260
as scopes.

00:58:45.500 --> 00:58:48.970
So by moving this now,
this variable is correctly scoped and

00:58:48.970 --> 00:58:52.200
we'll be able to write our code this way.

00:58:53.310 --> 00:58:58.960
Another issue is this undeclared
initWithIdentifier method.

00:58:59.030 --> 00:59:01.770
We can use our indexer to find it.

00:59:04.400 --> 00:59:12.270
copy it and add it to
our class declaration,

00:59:12.270 --> 00:59:12.270
which is missing.

00:59:17.380 --> 00:59:20.430
And as I said, case statements,
we're declaring variables here,

00:59:20.430 --> 00:59:24.330
so fix that by adding a curly.

00:59:28.380 --> 00:59:32.840
Oh yeah, somebody was getting fancy
with their singletons.

00:59:32.860 --> 00:59:35.090
So we just tossed that out.

00:59:35.210 --> 00:59:40.580
So mostly I've made a few small edits.

00:59:41.640 --> 00:59:44.320
So we hit convert again.

00:59:44.420 --> 00:59:47.340
Crossing fingers, and it comes up,
it's happy.

00:59:47.460 --> 00:59:49.750
So we hit the next button.

00:59:51.220 --> 00:59:56.530
Now what it's doing is generating a
snapshot so it can show us a diff.

00:59:56.660 --> 00:59:59.800
And here's our diff viewer.

01:00:01.240 --> 01:00:03.700
shows us all the changes it's made.

01:00:03.770 --> 01:00:08.650
Take a look at main, simplified it,
a lot easier to read.

01:00:10.520 --> 01:00:17.690
Here's a case where we have automatically
turned assigned properties into weak.

01:00:19.700 --> 01:00:23.120
And just for fun,
at the bottom of this we see a

01:00:23.160 --> 01:00:25.900
dialog method just got nuked.

01:00:26.450 --> 01:00:27.240
Kind of nice.

01:00:27.270 --> 01:00:29.800
So you'll see a lot of that
when you look through this code.

01:00:29.840 --> 01:00:31.940
And a proof of the pudding, does it run?

01:00:32.100 --> 01:00:33.370
It ran before.

01:00:33.380 --> 01:00:42.910
There it is, running with Arc.

01:00:50.000 --> 01:00:52.760
and if you want to learn how to arc weld,
you can use this tool for that.

01:00:52.760 --> 01:00:55.310
So, thanks a lot.

01:01:05.100 --> 01:01:06.100
Thanks, Patrick.

01:01:06.100 --> 01:01:10.780
So we tried to really define a great set
of tools that work really well together

01:01:10.780 --> 01:01:13.860
to make ARC real and get you to ARC.

01:01:14.400 --> 01:01:16.690
So let's come back to the
evolution of Objective-C.

01:01:16.810 --> 01:01:18.620
We talked about automation.

01:01:18.680 --> 01:01:22.070
We're really raising the bar for
Objective-C and making it easier and more

01:01:22.070 --> 01:01:24.570
natural to write code that just works.

01:01:24.700 --> 01:01:28.820
We think that Arc is the latest
great step towards that goal.

01:01:29.390 --> 01:01:31.780
So if you want more details
about ARC and about other

01:01:31.780 --> 01:01:33.970
improvements to Objective-C that
have nothing to do with ARC,

01:01:33.970 --> 01:01:36.570
we really encourage you to come
to the Objective-C Advancements

01:01:36.670 --> 01:01:38.220
talk later today.

01:01:38.230 --> 01:01:40.190
And there are a lot
of other improvements.

01:01:40.290 --> 01:01:42.640
We'll talk more about how
ARC the runtime works,

01:01:42.730 --> 01:01:46.720
talk about performance optimizations,
and also have some Q&A about

01:01:46.720 --> 01:01:48.540
ARC and Objective-C.

01:01:48.680 --> 01:01:51.040
So now if you'd like more
information about ARC and the

01:01:51.040 --> 01:01:55.050
improvements that are coming out,
please contact Michael Jurowicz,

01:01:55.050 --> 01:01:58.370
our Developer Tools Evangelist,
and we have a really fantastic

01:01:58.560 --> 01:02:02.400
Programming with ARC release note
on the attendee portal for WWDC.

01:02:02.410 --> 01:02:06.160
This document describes more details than
you could ever want to know about ARC,

01:02:06.160 --> 01:02:08.400
I think,
including some of the enhancements

01:02:08.400 --> 01:02:11.090
we're making that will be
coming out in the next seed.

01:02:11.390 --> 01:02:13.260
If you have questions,
feel free to contact us at

01:02:13.260 --> 01:02:15.300
the Apple Developer Forum.

01:02:15.400 --> 01:02:17.170
So,
there are a couple of related sessions.

01:02:17.320 --> 01:02:20.980
Earlier this week,
there are several compiler sessions

01:02:20.980 --> 01:02:23.680
about the LLVM compiler and how
to move to the LLVM compiler.

01:02:23.680 --> 01:02:27.460
If you're already using GCC,
or if you are currently using GCC,

01:02:27.460 --> 01:02:30.000
we strongly recommend you move forward.

01:02:30.000 --> 01:02:33.190
ARC is only available in
the Apple LLVM Compiler 3.

01:02:33.200 --> 01:02:35.480
So with that,
I'd like to thank you for coming.

01:02:35.480 --> 01:02:36.810
Have a great afternoon.
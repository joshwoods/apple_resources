WEBVTT

00:00:14.050 --> 00:00:15.760
My name is Luke the Hiesterman.

00:00:15.800 --> 00:00:21.440
I'm here to talk to you today about
storing documents in iCloud using iOS 5.

00:00:21.470 --> 00:00:24.140
This is going to be an
introduction to the new API that

00:00:24.140 --> 00:00:28.910
we're introducing in iOS 5,
UI Document and UI Kit.

00:00:30.090 --> 00:00:33.870
So I'm going to start by telling you
about what we're going to cover today.

00:00:33.900 --> 00:00:36.260
There's going to be four
sections to this talk.

00:00:36.380 --> 00:00:42.280
Number one is figuring out what is the
problem space that we want to solve.

00:00:42.800 --> 00:02:12.800
[Transcript missing]

00:02:13.160 --> 00:02:18.400
Document-based applications are things
that you might find in the iWorks suite,

00:02:18.400 --> 00:02:21.460
applications like Pages
and Keynote and Numbers.

00:02:21.540 --> 00:02:26.200
These are documents that--or these are
applications that present data to the

00:02:26.200 --> 00:02:29.270
user in a format that they can open it,
make changes,

00:02:29.360 --> 00:02:32.920
and persist those changes to disk,
things that you might think

00:02:33.080 --> 00:02:34.770
of as files on Mac OS X.

00:02:34.860 --> 00:02:38.170
Of course, we don't really present
files to the user on iOS,

00:02:38.170 --> 00:02:39.910
but it's that same concept.

00:02:40.660 --> 00:02:46.460
Now, some of you maybe have never built a
document-based application for iOS.

00:02:46.460 --> 00:02:48.500
And if you're thinking about
building your first one,

00:02:48.500 --> 00:02:51.170
there are some challenges that
are inherent to building any

00:02:51.170 --> 00:02:52.740
document-based application.

00:02:52.820 --> 00:02:55.340
Let's talk about what some of those are.

00:02:56.580 --> 00:02:59.010
First and foremost,
any document-based application

00:02:59.100 --> 00:03:01.620
has to figure out how it's
going to do saving and opening,

00:03:01.660 --> 00:03:03.370
how it's going to read
and write its data.

00:03:03.380 --> 00:03:07.820
There are two basic answers to this
question that any application can have.

00:03:07.920 --> 00:03:12.330
Number one is doing reading
and writing on the main thread.

00:03:12.340 --> 00:03:16.290
This has the advantage of
giving you pretty simple code.

00:03:16.300 --> 00:03:18.360
You'll probably be able
to write it quickly.

00:03:18.360 --> 00:03:21.660
You'll be able to easily
understand what it does.

00:03:21.740 --> 00:03:23.880
And you'll be able to maintain it easily.

00:03:24.850 --> 00:03:28.470
The unfortunate side effect of this
approach is that if reading or writing

00:03:28.470 --> 00:03:32.700
takes a non-trivial amount of time,
then your application is going

00:03:32.700 --> 00:03:34.800
to block user interaction.

00:03:34.800 --> 00:03:38.630
While the main thread is hung
writing or reading to or from disk,

00:03:38.760 --> 00:03:41.000
then the user can't
interact with the phone.

00:03:41.000 --> 00:03:47.060
They may be trying to push buttons or
interact with your content in some way,

00:03:47.060 --> 00:03:50.280
but they can't do that because your
application is busy on the main

00:03:50.380 --> 00:03:52.140
thread writing or reading data.

00:03:53.140 --> 00:03:56.200
So the solution to this,
answer number two to how to

00:03:56.210 --> 00:03:59.490
handle saving and opening,
is using concurrency.

00:04:00.840 --> 00:04:04.220
If your application does reading
or writing in the background using

00:04:04.220 --> 00:04:07.390
concurrent threads or queues,
then it frees up the main thread

00:04:07.400 --> 00:04:10.520
so that the user can get the
experience that they really want,

00:04:10.520 --> 00:04:13.720
which is to be able to continue
to interact with their phone.

00:04:13.720 --> 00:04:15.420
I mean, that's very important on iOS.

00:04:15.420 --> 00:04:17.710
We don't ever want a phone
where the user can be pushing

00:04:17.710 --> 00:04:19.250
buttons and nothing happens.

00:04:20.280 --> 00:04:23.450
So dealing with concurrency
allows you to solve this problem,

00:04:23.450 --> 00:04:27.710
but it has the unfortunate side effect
of now your code is more complex.

00:04:27.710 --> 00:04:30.270
It's probably going to
take you longer to write,

00:04:30.350 --> 00:04:33.920
it won't be as easy to understand,
and it'll be more error-prone.

00:04:33.980 --> 00:04:37.340
But once you've solved these
problems or figured out what

00:04:37.460 --> 00:04:40.750
your answer is going to be,
you still have to figure out,

00:04:40.850 --> 00:04:42.090
when should I save?

00:04:42.090 --> 00:04:46.170
This is an interesting question on
iOS because we like to have what

00:04:46.170 --> 00:04:48.220
we call a saveless user model.

00:04:48.240 --> 00:04:49.970
That is to say,
we don't like to have a user model

00:04:49.980 --> 00:04:50.260
that's not going to be able to save.

00:04:50.260 --> 00:04:52.430
We like to have save buttons on iOS.

00:04:52.830 --> 00:04:55.850
Rather, the user simply interacts
with their content,

00:04:55.850 --> 00:04:59.790
and as they make changes to the data,
we just give them the illusion

00:04:59.790 --> 00:05:03.450
that it's always persisted to disk,
and they don't have to think

00:05:03.880 --> 00:05:05.440
about when they should save.

00:05:05.440 --> 00:05:07.100
It's always saved.

00:05:08.360 --> 00:05:14.420
So some of you maybe have actually
already given answers to these questions.

00:05:14.420 --> 00:05:17.490
You've written applications
that have solved these problems,

00:05:17.490 --> 00:05:19.170
and you're here wondering,

00:05:19.550 --> 00:05:22.630
should I adopt UI Document in iOS 5?

00:05:22.670 --> 00:05:24.940
I think the answer to that
question is going to be yes.

00:05:24.970 --> 00:05:27.740
That hinges largely on the
fact that we have this cool

00:05:27.960 --> 00:05:32.720
little new feature in iOS 5,
and we call that iCloud.

00:05:32.740 --> 00:05:35.460
And more than that,
we actually have this really

00:05:35.460 --> 00:05:40.580
big new feature in iOS 5,
and we call that iCloud.

00:05:45.450 --> 00:05:52.550
UI Document is built to make your
applications have documents that

00:05:52.550 --> 00:05:55.030
seamlessly integrate with iCloud.

00:05:55.140 --> 00:05:57.100
If you already have a
Document application,

00:05:57.100 --> 00:06:01.290
you're going to want to bring it
over to use UI Document so that you

00:06:01.290 --> 00:06:07.350
can take advantage of our built-in
integration to iCloud that doesn't

00:06:07.350 --> 00:06:07.350
require any special code on your part.

00:06:07.540 --> 00:06:11.810
Now, iCloud introduces some new
challenges that didn't exist before

00:06:11.810 --> 00:06:13.430
in document-based application.

00:06:13.470 --> 00:06:15.630
We'll talk about three
of those right now.

00:06:15.690 --> 00:06:19.080
Number one is any document-based
application needs to be able to respond

00:06:19.130 --> 00:06:21.270
to updates that come from the cloud.

00:06:21.340 --> 00:06:24.520
At any time,
iCloud may sync some new change that

00:06:24.530 --> 00:06:26.580
your document didn't previously have.

00:06:26.630 --> 00:06:29.950
And if your document is open,
the user interface needs to be

00:06:29.950 --> 00:06:33.370
immediately updated so that the user
sees the new state of the document

00:06:33.710 --> 00:06:36.680
that just came down from the cloud.

00:06:37.420 --> 00:06:41.050
Number two,
your document-based application needs

00:06:41.140 --> 00:06:45.210
to do reading and writing in a way
that is safe relative to the cloud.

00:06:45.220 --> 00:06:48.720
Because updates can come
from the cloud at any time,

00:06:48.720 --> 00:06:52.160
and likewise,
we can take your data that is on disk

00:06:52.260 --> 00:06:56.420
and sync it to the cloud at any time,
we have an iCloud syncing daemon that

00:06:56.420 --> 00:07:01.760
needs to have access to the file that
your document represents at any time,

00:07:01.760 --> 00:07:04.380
and likewise, your application needs to
have access to that file.

00:07:04.380 --> 00:07:07.800
And so,
we need to mediate the iCloud syncing

00:07:07.800 --> 00:07:13.150
daemon and your application's access
to the file in a way that is safe.

00:07:14.780 --> 00:07:18.980
And thirdly,
applications in iCloud need to

00:07:19.010 --> 00:07:22.370
figure out how to discover conflicts.

00:07:22.950 --> 00:07:26.500
Conflicts can come at any time because
we always have the possibility that

00:07:26.500 --> 00:07:31.620
somebody makes simultaneous changes
or we have a device that goes offline,

00:07:31.690 --> 00:07:33.620
makes some conflicting
changes come back online.

00:07:33.620 --> 00:07:36.940
Applications need to be able
to discover conflicts so that

00:07:36.940 --> 00:07:40.930
they can begin the process of
conflict recovery and resolution.

00:07:42.800 --> 00:07:46.250
So we're going to spend the next
50 minutes or so talking about our

00:07:46.290 --> 00:07:50.580
solution to all of these problems,
which is UI Document.

00:07:50.600 --> 00:07:54.130
And the really great news is
UI Document solves all of these

00:07:54.130 --> 00:07:55.920
problems that we've just talked about.

00:07:55.940 --> 00:08:00.290
UI Document handles concurrent
reading and writing for you in a way

00:08:00.290 --> 00:08:02.750
that doesn't make your code complex.

00:08:02.770 --> 00:08:06.610
It has a built-in autosaving
engine that allows you to get a

00:08:06.730 --> 00:08:08.600
save this user model for free.

00:08:08.630 --> 00:08:12.000
And it has, of course,
built-in iCloud integration.

00:08:12.690 --> 00:08:14.510
So let's jump into
section two of our talk,

00:08:14.530 --> 00:08:18.290
which is the basics of UI document.

00:08:18.450 --> 00:08:23.160
I'd like first to introduce you to
what it is that UI Document provides.

00:08:23.160 --> 00:08:28.970
UI Document is, at its heart,
a model base class that represents

00:08:28.970 --> 00:08:31.320
a document in your application.

00:08:31.590 --> 00:08:35.770
Now that means you're not
going to instantiate direct

00:08:35.770 --> 00:08:37.630
instances of UI document.

00:08:37.880 --> 00:08:40.780
Rather, you're going to be
subclassing from UI document,

00:08:40.780 --> 00:08:45.570
and you will be creating instances
of your document subclasses.

00:08:45.810 --> 00:08:49.970
So what the base class, UIDocument,
brings along with it is a few

00:08:50.340 --> 00:08:52.520
key document handling features.

00:08:52.530 --> 00:08:56.150
Among those three are number one,
concurrent background

00:08:56.280 --> 00:08:57.630
reading and writing.

00:08:57.630 --> 00:08:59.300
I mentioned this before.

00:08:59.300 --> 00:09:03.300
This is very nice that we take all
of the work of reading and writing

00:09:03.300 --> 00:09:06.360
concurrency out of your hands,
doing it for you,

00:09:06.360 --> 00:09:10.870
so that you get to have the simple code
that only works on the main thread.

00:09:10.880 --> 00:09:14.790
You don't ever have to deal
with concurrency yourself.

00:09:14.800 --> 00:09:17.700
But you get the best user
interaction scenario,

00:09:17.700 --> 00:09:20.040
because the main thread
will never be blocked,

00:09:20.270 --> 00:09:23.650
making it so that the user
can't deal with their content.

00:09:23.930 --> 00:09:27.000
Number two,
we have a saveless user model.

00:09:27.050 --> 00:09:30.100
So we will run the
autosaving engine for you.

00:09:30.100 --> 00:09:32.800
All we're gonna ask is that you
tell us when the user makes changes,

00:09:32.800 --> 00:09:36.330
and we'll do everything for you
in terms of ensuring that those

00:09:36.330 --> 00:09:41.070
changes are saved at the important
times when they need to be saved.

00:09:41.470 --> 00:09:46.510
And finally, as I mentioned before,
we have iCloud integration.

00:09:46.700 --> 00:09:50.200
Let's look at UIManagedDocument
for just a second.

00:09:50.200 --> 00:09:55.900
This is the one concrete subclass
that we provide of UIDocument.

00:09:55.900 --> 00:09:59.880
This is something provided
with CoreData in mind,

00:09:59.960 --> 00:10:03.320
and it has a few nice features if
you want a concrete subclass of

00:10:03.320 --> 00:10:05.700
UIDocument to get started right away.

00:10:05.700 --> 00:10:08.700
Number one, it has CoreData integration.

00:10:08.700 --> 00:10:10.700
So if you have a CoreData stack
in your application already,

00:10:10.700 --> 00:10:14.700
or you're considering representing
your model with CoreData,

00:10:14.700 --> 00:10:18.400
that works great if you
have large amounts of data.

00:10:18.700 --> 00:10:22.010
I encourage that,
and that's integrated directly

00:10:22.020 --> 00:10:23.940
into UIManagedDocument.

00:10:24.250 --> 00:10:27.980
UIManaged Document is
optimized for iCloud syncing.

00:10:28.020 --> 00:10:32.250
This is particularly why it's good
to think about adopting UIManaged

00:10:32.250 --> 00:10:35.680
Document in Core Data if you
have large amounts of data that

00:10:35.680 --> 00:10:37.550
your document is dealing with.

00:10:37.640 --> 00:10:41.040
And finally,
UIManaged Document has automatic

00:10:41.040 --> 00:10:43.410
conflict resolution built in.

00:10:43.420 --> 00:10:46.500
We're going to be talking
later more about dealing with

00:10:46.880 --> 00:10:50.440
conflicts and conflict resolution,
and it'll start to become apparent

00:10:50.440 --> 00:10:54.080
why it's actually really nice to have
somebody do conflict resolution for you.

00:10:54.100 --> 00:10:57.370
and UI Managed Document does that.

00:10:58.130 --> 00:11:02.600
So I'd like to take a second to
look at the architecture that your

00:11:02.600 --> 00:11:06.800
Document application is going to
have if you're using UI Document.

00:11:06.870 --> 00:11:10.790
So you're probably all familiar with
the Model-View-Controller paradigm.

00:11:11.010 --> 00:11:12.840
It's going to be the same thing here.

00:11:12.840 --> 00:11:16.110
Your application is probably
going to have a UIView controller

00:11:16.110 --> 00:11:20.220
that will represent the
controller of your application.

00:11:20.220 --> 00:11:24.040
And then it's going to have a UIView
that that view controller will own.

00:11:24.090 --> 00:11:27.500
And that view is going to
display your data to the user.

00:11:27.500 --> 00:11:28.700
And then you're also
going to have a model.

00:11:28.700 --> 00:11:31.540
And that model is going to
be your UIDocument subclass.

00:11:31.560 --> 00:11:36.440
We actually refer to this as a
model controller because it's

00:11:36.510 --> 00:11:42.810
going to encapsulate the model
that your document represents.

00:11:42.880 --> 00:11:46.550
And so we're going to be focusing
on that UIDocument subclass,

00:11:46.550 --> 00:11:49.820
building that model controller today.

00:11:49.820 --> 00:11:54.300
So let's jump into reading and writing,
what that is.

00:11:54.310 --> 00:11:55.740
I want to hit one more time.

00:11:55.740 --> 00:11:58.940
We've talked about that all reading
and writing happens on a background

00:11:59.160 --> 00:12:02.080
queue managed by UIDocument for you.

00:12:02.320 --> 00:12:06.870
Reading is triggered by an open
operation or by a revert operation,

00:12:06.870 --> 00:12:10.000
which can happen when a change
comes in from the cloud.

00:12:10.250 --> 00:12:11.890
Writing is triggered when we save.

00:12:11.960 --> 00:12:15.970
Saving most of the time will
be initiated by UIDocument as a

00:12:15.970 --> 00:12:18.900
part of our autosaving mechanism.

00:12:20.190 --> 00:12:23.930
And both of these operations,
reading and writing,

00:12:24.150 --> 00:12:26.960
have automatic handling for a
couple of built-in data types.

00:12:26.980 --> 00:12:30.050
Those data types are
NSData and NSFileWrapper.

00:12:30.060 --> 00:12:37.550
These correspond respectively to
having a flat file or a file package.

00:12:37.680 --> 00:12:40.340
NSData will be used if your
file is represented in the

00:12:40.340 --> 00:12:41.900
file system as a flat file.

00:12:41.900 --> 00:12:44.720
But if you have a file package,
we'll use NSFileWrapper.

00:12:44.740 --> 00:12:47.740
A file package,
for those of you who don't know,

00:12:47.740 --> 00:12:51.460
is a directory that
contains several files,

00:12:51.480 --> 00:12:53.710
but that is treated,
from the user's perspective,

00:12:53.710 --> 00:12:54.600
as a single file.

00:12:54.600 --> 00:12:57.320
And we wrap that all up in NSFileWrapper.

00:12:57.320 --> 00:12:59.800
It's just a moment of an aside.

00:13:01.400 --> 00:13:05.460
If you haven't thought about using
file packages in NSFileWrapper before,

00:13:05.580 --> 00:13:09.440
I will encourage you to look into
them and consider adopting them,

00:13:09.440 --> 00:13:13.190
especially if you have an
application that stores a lot

00:13:13.190 --> 00:13:14.750
of data as part of its document.

00:13:14.760 --> 00:13:19.380
They have optimizations such as faster
writing if you're only writing one or

00:13:19.380 --> 00:13:22.540
a couple of files in the FileWrapper,
and likewise,

00:13:22.540 --> 00:13:25.740
more efficient syncing to iCloud
if you're only modifying certain

00:13:25.740 --> 00:13:27.480
files within the FileWrapper.

00:13:27.480 --> 00:13:30.840
So with that,
let's take a closer look at reading.

00:13:31.300 --> 00:13:32.500
Thank you.

00:13:33.200 --> 00:13:35.240
We have two queues as
part of our reading.

00:13:35.400 --> 00:13:40.190
The one that the reading is initiated on,
and the background queue

00:13:40.190 --> 00:13:41.260
that's managed by UIKit.

00:13:41.410 --> 00:13:45.240
Probably the only one you're going
to care about is the main queue,

00:13:45.240 --> 00:13:47.770
the queue that you'll be calling us on.

00:13:47.800 --> 00:13:51.480
And reading begins by you
asking us to open the document.

00:13:51.580 --> 00:13:54.750
Often this will be immediately after
you've initialized the document,

00:13:54.750 --> 00:13:56.030
you'll ask us to open it.

00:13:56.130 --> 00:13:58.880
And that's done by calling
open with completion handler.

00:13:58.880 --> 00:14:01.860
It takes a block parameter
that is the completion handler.

00:14:01.860 --> 00:14:05.260
we'll invoke at the end
of the open operation.

00:14:05.710 --> 00:14:09.900
When you ask us to open a document,
we will go immediately into

00:14:09.930 --> 00:14:12.330
the background queue and
begin the reading operation.

00:14:12.340 --> 00:14:14.380
You see that reading sort
of takes a long time,

00:14:14.470 --> 00:14:17.340
potentially, and that's why we do it
in the background queue,

00:14:17.340 --> 00:14:20.370
so that we're not blocking the main
thread while this is happening.

00:14:20.380 --> 00:14:24.070
At some point,
the read operation will complete,

00:14:24.110 --> 00:14:27.940
and we will come back to the queue
that you called us on and ask

00:14:28.100 --> 00:14:31.770
you to load the contents that we
just read into your data model.

00:14:32.840 --> 00:14:36.420
This is where we provide the one
override point that you will need to

00:14:36.420 --> 00:14:40.230
facilitate reading in your application,
and that override point is load

00:14:40.230 --> 00:14:44.220
from contents of type with an
error return by indirection.

00:14:45.760 --> 00:14:49.130
As I said, this is your one override
point that you will want to

00:14:49.130 --> 00:14:51.240
implement to make reading happen.

00:14:51.450 --> 00:14:54.670
And the contents that we
send you is an id parameter.

00:14:54.790 --> 00:14:57.820
And that will be either
an NSData instance or an

00:14:57.820 --> 00:14:59.130
NSFile wrapper instance.

00:14:59.140 --> 00:15:02.080
If your file is represented
on disk as a flat file,

00:15:02.080 --> 00:15:04.350
we will send you NSData.

00:15:04.430 --> 00:15:06.630
If it is represented on
disk as a file package,

00:15:06.680 --> 00:15:10.270
we wrap that up in an NSFile
wrapper instance and send you that.

00:15:10.280 --> 00:15:12.600
Whatever your contents is,
you can load that into your data

00:15:12.600 --> 00:15:18.140
model at that time and likely
update what the user sees as well.

00:15:18.570 --> 00:15:21.870
After you're done loading
the contents and you return,

00:15:22.010 --> 00:15:25.490
we will invoke the completion
handler that was passed into the

00:15:25.490 --> 00:15:31.290
open with completion handler method,
and that finishes the reading operation.

00:15:31.480 --> 00:15:35.800
So writing is pretty much the same thing,
kind of in reverse.

00:15:35.800 --> 00:15:38.280
Again,
we're dealing with the same two queues,

00:15:38.280 --> 00:15:41.750
the one that the writing
operation is initiated on,

00:15:41.750 --> 00:15:46.750
and the queue managed by UIKit to
do the actual writing to disk.

00:15:47.490 --> 00:15:53.200
Writing begins with a save operation,
and that's the method

00:15:53.340 --> 00:15:56.630
saveToURL for saveOperation,
and that also takes a

00:15:56.630 --> 00:15:58.470
block completion handler.

00:15:58.690 --> 00:16:01.780
Most often,
you're just going to let this get called

00:16:01.950 --> 00:16:07.360
for you because UIDocument will call
this as part of our autosaving engine.

00:16:07.360 --> 00:16:09.280
And you've simply told
us about the changes,

00:16:09.330 --> 00:16:10.600
and we'll do autosaving.

00:16:10.600 --> 00:16:12.810
But you will call this if
you're creating a new file.

00:16:14.640 --> 00:16:19.130
So once save is called,
we will immediately turn back to you now

00:16:19.140 --> 00:16:25.400
on the same queue that save is invoked
and ask you to snapshot your data model.

00:16:25.570 --> 00:16:30.240
So what this means is we need
a representation of what your

00:16:30.240 --> 00:16:34.560
model is right now that we're
going to go write to disk.

00:16:35.360 --> 00:16:41.230
And this is your one override point to
facilitate writing in your application.

00:16:41.230 --> 00:16:46.170
And that override point is contents for
type with an error return by indirection.

00:16:46.820 --> 00:16:50.310
Now, this has an id return value.

00:16:50.380 --> 00:16:54.220
And again,
if you deal in the built-in supported

00:16:54.360 --> 00:17:00.520
types of NSData or NSFileWrapper,
then you're done if you return

00:17:00.520 --> 00:17:02.990
us an NSData or an NSFileWrapper,
because we know how to

00:17:03.000 --> 00:17:04.690
write those types to disk.

00:17:04.770 --> 00:17:06.560
And we'll just go do it.

00:17:06.560 --> 00:17:09.190
If you want to return a custom--

00:17:30.090 --> 00:17:30.090
So,
in order to use the new UIDocument class,

00:17:30.090 --> 00:17:30.090
you have to use the new UIDocument class.

00:17:30.560 --> 00:17:33.380
And then when we're done,
we'll invoke the completion handler that

00:17:33.380 --> 00:17:38.940
was passed to savedURL back on the queue
on which that operation was initiated.

00:17:39.040 --> 00:17:40.730
And that's writing.

00:17:41.210 --> 00:17:43.930
So reading and writing,
the big key here is each one

00:17:44.010 --> 00:17:46.100
just has a single override point.

00:17:46.100 --> 00:17:50.020
One for reading,
which is load from contents of type,

00:17:50.020 --> 00:17:55.170
and one for writing,
which is contents for type.

00:17:56.500 --> 00:17:59.860
Just by implementing these two methods,
you will have reading and writing based

00:17:59.860 --> 00:18:03.240
on UI Document in your application,
and it will all happen in the background,

00:18:03.250 --> 00:18:05.830
so you'll get the best user experience.

00:18:05.940 --> 00:18:12.170
After that, all we need to do to make our
application feel full-fledged

00:18:12.180 --> 00:18:14.940
is make autosaving happen.

00:18:15.040 --> 00:18:20.430
And autosaving is all about you telling
us about the document's changes.

00:18:20.500 --> 00:18:22.960
When the user makes
edits to the document,

00:18:22.960 --> 00:18:27.080
you want to tell us about them so we can
figure out when to schedule autosaving

00:18:27.080 --> 00:18:29.440
and make that happen at the right time.

00:18:29.590 --> 00:18:33.880
So there are two ways that you
can tell us about--two easy ways

00:18:33.880 --> 00:18:36.520
that the user has made changes.

00:18:38.140 --> 00:18:41.000
Number one is simply
to take that user edit,

00:18:41.170 --> 00:18:44.080
turn around and call a
method on UIDocument,

00:18:44.080 --> 00:18:44.930
updateChangeCount.

00:18:44.940 --> 00:18:47.690
This tells us that, hey,
a change has been made.

00:18:47.700 --> 00:18:50.640
We can go schedule autosaving
at an appropriate time.

00:18:50.660 --> 00:18:56.840
Alternatively, if you are supporting undo
in your document application,

00:18:56.840 --> 00:19:00.620
then you can simply register
your change with the undo manager

00:19:00.630 --> 00:19:02.720
that is built into UIDocument.

00:19:02.720 --> 00:19:05.120
There's a property on
UIDocument called undoManager,

00:19:05.120 --> 00:19:07.840
and you can register your
change with that undo manager,

00:19:08.000 --> 00:19:12.560
and if you do so, we will notice that you
registered that change,

00:19:12.560 --> 00:19:16.790
and we will call
updateChangeCount on your behalf.

00:19:16.900 --> 00:19:19.910
So it's the same amount of
code that you have to write if

00:19:19.910 --> 00:19:21.860
you're going to support undo.

00:19:21.860 --> 00:19:24.680
Simply register your change
with the undo manager,

00:19:24.680 --> 00:19:28.270
and that also tells us that you've
made a change to the document.

00:19:28.280 --> 00:19:31.380
Either way, now we're good,
and our autosaving engine can

00:19:31.380 --> 00:19:34.780
take over from there and ensure
that the user's data is persistent

00:19:34.930 --> 00:19:36.780
to disk at the appropriate time.

00:19:38.410 --> 00:19:42.620
So that's pretty much it as far as
what you need to know to go write a

00:19:42.620 --> 00:19:48.670
document application that can open,
save, and in fact autosave

00:19:48.840 --> 00:19:50.680
just with a few APIs.

00:19:50.820 --> 00:19:54.140
And so I'd like to show you just how
little code and just how easy it is

00:19:54.140 --> 00:19:59.780
to go get started right now building
an application based on UI Document.

00:20:00.850 --> 00:20:04.100
So the application that I'm
going to show you today is

00:20:04.200 --> 00:20:09.700
something that I call Cloud Notes,
a very simple text document-based

00:20:09.700 --> 00:20:14.140
application that actually gives
the user the opportunity to sync

00:20:14.440 --> 00:20:17.210
their documents into iCloud.

00:20:17.640 --> 00:20:23.320
And this is my UIDocument subclass we
see in front of us called NoteDocument.

00:20:23.690 --> 00:20:30.060
And you see I just have two
methods here that I'm overriding.

00:20:30.210 --> 00:20:34.800
Load from contents to do my reading
and contents for type to do my writing.

00:20:34.810 --> 00:20:37.510
And with a little simple code in there,
that will be all I need

00:20:37.660 --> 00:20:40.240
for my document subclass.

00:20:40.260 --> 00:20:42.990
So I'll start with load from contents.

00:20:44.560 --> 00:20:48.830
I'm past the contents parameter,
which in my case is going to be

00:20:48.910 --> 00:20:53.140
an NSData instance representing
the contents of my flat text file,

00:20:53.140 --> 00:20:56.970
since I'm just dealing
with text note files.

00:20:58.840 --> 00:21:01.700
When I get that,
I'm just going to literally

00:21:01.700 --> 00:21:03.090
load that into my data model.

00:21:03.100 --> 00:21:07.930
My data model is simply a
string Ivar represented by

00:21:07.930 --> 00:21:10.470
the document text property.

00:21:10.870 --> 00:21:17.000
So I'll take that
contents as an NSData and

00:21:18.360 --> 00:21:23.700
Go ahead and set that to
my document text model,

00:21:23.710 --> 00:21:27.190
locking in a string
with that data contents.

00:21:28.270 --> 00:21:35.260
And I'll deal also with the other
possible case that I have an empty file,

00:21:35.260 --> 00:21:37.080
so I got empty contents from that.

00:21:37.150 --> 00:21:40.010
And if that's the case,
I'll set my model to

00:21:40.010 --> 00:21:41.760
be an empty NSString.

00:21:42.620 --> 00:21:46.260
After I've loaded my model,
one thing that I want to do is let

00:21:46.260 --> 00:21:50.500
my view controller know that my
model has been updated because,

00:21:50.720 --> 00:21:52.800
well,
I'm going to want to update the view

00:21:52.800 --> 00:21:54.570
in response to updating my model.

00:21:54.580 --> 00:21:58.730
So for this document class,
I actually created a delegate method that

00:21:58.790 --> 00:22:03.500
allows me to inform the view controller
that my contents have been updated.

00:22:03.500 --> 00:22:05.990
And I'll just go ahead and call that.

00:22:06.170 --> 00:22:11.020
I call noteDocumentContentsUpdated
so my view controller knows,

00:22:11.120 --> 00:22:13.700
"Hey, my contents have changed.

00:22:13.740 --> 00:22:17.860
You should take the new model and
update the view." And with that,

00:22:17.860 --> 00:22:22.560
I'm done with load from contents,
and I can just return that, yes, I have,

00:22:22.560 --> 00:22:24.840
in fact, loaded from contents.

00:22:24.840 --> 00:22:28.700
And turn my attention
to contents for type.

00:22:29.300 --> 00:22:31.800
In Contents for Type,
I'm just going to do effectively

00:22:31.800 --> 00:22:34.170
the reverse of what I just
did in Load from Contents.

00:22:34.280 --> 00:22:39.240
I'm going to take my model,
which is just a string in this case,

00:22:39.360 --> 00:22:42.960
and wrap it up in an NSData and
return it to the document.

00:22:44.560 --> 00:22:48.360
So a little operation that I'm
going to do before that is handle

00:22:48.360 --> 00:22:54.380
the case that I have an empty model
right now that my text is zero,

00:22:54.410 --> 00:22:55.180
has a zero length.

00:22:55.220 --> 00:22:58.280
And in that case,
I'm going to put some base data

00:22:58.280 --> 00:23:02.350
in my document because I don't
like to save empty documents.

00:23:02.380 --> 00:23:04.630
I like to have some base data in there.

00:23:04.640 --> 00:23:08.370
And so I'm just going to put
the new note text into my model.

00:23:08.380 --> 00:23:13.020
Now, that done, I just take my model,
which is my document text,

00:23:13.020 --> 00:23:16.060
and wrap it up in an
NSData using data with bytes

00:23:16.120 --> 00:23:18.320
and return that to the document.

00:23:18.320 --> 00:23:21.860
It will take my data instance
and handle writing it to disk.

00:23:22.020 --> 00:23:23.610
And everything is done.

00:23:25.850 --> 00:23:28.950
In this one screen,
you see all the code I'm going to

00:23:28.950 --> 00:23:33.300
write for my Document subclass,
minus some comments at the

00:23:33.380 --> 00:23:35.910
top that say "created by me."

00:23:36.660 --> 00:23:39.440
So I'm going to turn my
attention for the last bit to

00:23:39.440 --> 00:23:42.480
the view controller that I have.

00:23:42.610 --> 00:23:46.840
I'm going to implement just a couple of
methods here that are delegate methods.

00:23:46.840 --> 00:23:50.750
One is the method that I just sent
from my document saying that the

00:23:50.750 --> 00:23:54.040
document contents are updated,
note document contents updated.

00:23:54.040 --> 00:23:58.490
We use this as an opportunity
to update my document's view.

00:23:58.500 --> 00:24:01.520
So that's simply a matter
of taking the model data,

00:24:01.590 --> 00:24:04.660
which is a string,
and putting it into my view.

00:24:04.660 --> 00:24:07.560
My view is a UI text view,
so I can just take the

00:24:07.560 --> 00:24:10.550
string from my model,
put it in the text view,

00:24:10.550 --> 00:24:12.570
and that will be all I need.

00:24:12.600 --> 00:24:15.940
for no document contents updated.

00:24:16.470 --> 00:24:19.740
And the other method,
the last method I want to implement,

00:24:19.740 --> 00:24:22.330
is a delegate method for the UI TextView.

00:24:22.380 --> 00:24:23.370
TextView did change.

00:24:23.380 --> 00:24:25.980
And this is my opportunity
to do the reverse operation

00:24:25.990 --> 00:24:27.800
here from the ViewController2.

00:24:27.850 --> 00:24:30.730
That is, when the user makes an
edit to the TextView,

00:24:30.880 --> 00:24:32.400
I will get this message.

00:24:32.480 --> 00:24:36.610
And I want to update my model,
and then also tell the document

00:24:36.620 --> 00:24:38.180
that I have updated my model.

00:24:38.330 --> 00:24:42.570
So a couple lines of code
here to make that happen.

00:24:42.760 --> 00:24:45.700
I update the model by setting
the document text to the

00:24:45.700 --> 00:24:48.040
new text of the text view.

00:24:48.040 --> 00:24:50.450
And then the last thing I need
to do is just tell the document

00:24:50.560 --> 00:24:52.500
that I have updated the model.

00:24:52.500 --> 00:24:55.970
This is the key to facilitating
autosaving so that we know

00:24:55.970 --> 00:24:57.580
a change has been done.

00:24:57.580 --> 00:25:02.080
And I just call update
change count on the document.

00:25:02.080 --> 00:25:06.220
Now I probably could use
an undo manager here.

00:25:06.220 --> 00:25:09.420
My users probably wish
I used an undo manager.

00:25:09.420 --> 00:25:13.220
That will be version
1.1 of my application.

00:25:13.220 --> 00:25:14.910
And that would call update
change count for me.

00:25:14.950 --> 00:25:19.100
But for now,
I've done update change count.

00:25:19.100 --> 00:25:21.460
So that's all the code
I'm going to write.

00:25:29.910 --> 00:25:29.910
So, to show you this app in action,
this application is--

00:25:30.500 --> 00:25:35.960
just a text-based application that
will give us a list of documents that

00:25:35.960 --> 00:25:40.680
are text documents that we can read,
make changes to,

00:25:40.680 --> 00:25:43.740
and enjoy their auto-saving.

00:25:43.740 --> 00:25:47.220
My application should be
launching in just a second here.

00:25:47.220 --> 00:25:48.760
Xcode says it's running.

00:25:48.800 --> 00:25:49.970
OK.

00:25:50.070 --> 00:25:52.240
So here's my list of documents.

00:25:52.240 --> 00:25:56.540
I've only got two in this particular app.

00:25:56.800 --> 00:26:00.180
And they're just text documents,
but I can make changes to them.

00:26:00.180 --> 00:26:02.420
And this is just a list of
books that I want to read.

00:26:02.560 --> 00:26:05.740
Say maybe I want to
read Huck Finn as well.

00:26:05.740 --> 00:26:08.250
I'll go ahead and make that change.

00:26:08.540 --> 00:26:09.650
add that to my list.

00:26:09.860 --> 00:26:11.320
I can go look at my other document.

00:26:11.340 --> 00:26:15.640
Remember, oh, I definitely need to get
bacon when I go home.

00:26:15.700 --> 00:26:17.680
And I switch back to my other document.

00:26:17.680 --> 00:26:22.180
And my content is still there because,
well, I told the document that I made a

00:26:22.220 --> 00:26:23.690
change and it auto-saved it for me.

00:26:23.810 --> 00:26:25.580
So I didn't have to do anything.

00:26:25.580 --> 00:26:29.140
When I reopened the document,
my content is there for me.

00:26:29.140 --> 00:26:31.280
It was auto-saved.

00:26:31.330 --> 00:26:33.380
And that's great.

00:26:33.420 --> 00:26:38.520
There's one other little nicety
to this application that I didn't

00:26:38.520 --> 00:26:41.730
even have to write any code for
that I'd like to show you now.

00:26:41.800 --> 00:26:46.770
And that's that I have another instance
of this application on my phone.

00:26:46.850 --> 00:26:49.640
And maybe I want to
make a change to that.

00:26:49.640 --> 00:26:54.790
Maybe I want to remember that I want to
read the book at home when I get home.

00:26:54.870 --> 00:26:57.920
So I'm going to make
that change on my phone.

00:26:57.920 --> 00:26:59.630
And--

00:27:15.000 --> 00:27:15.000
It's going to auto save on
my phone after it saves.

00:27:15.000 --> 00:27:15.000
It's going to sync up to iCloud.

00:27:15.000 --> 00:27:15.000
iCloud is going to sync
it down to my iPad.

00:27:15.000 --> 00:27:15.000
And when that happens,
you'll see that my iPad just updates.

00:27:18.670 --> 00:27:21.050
And you know what my
favorite part of that is?

00:27:21.070 --> 00:27:23.840
I didn't write any code to do that.

00:27:24.960 --> 00:27:26.880
UI Document did that for me.

00:27:26.950 --> 00:27:29.540
All I did was implement
the reading method,

00:27:29.540 --> 00:27:33.330
and Document knew when I had
to reread the document because

00:27:33.330 --> 00:27:36.110
it was updated in iCloud,
and I'm done.

00:27:37.400 --> 00:27:42.160
So that's really just how easy it
is to get started writing document

00:27:42.160 --> 00:27:48.100
applications and even having them
be ready to integrate with iCloud.

00:27:48.330 --> 00:27:50.860
I should mention--

00:27:51.330 --> 00:27:55.900
that you do need to individually set,
in the real world,

00:27:55.950 --> 00:28:02.270
documents to sync to iCloud
via NS File Manager APIs.

00:28:02.310 --> 00:28:08.260
So you set individually the document
to be ubiquitous and to sync to iCloud.

00:28:08.260 --> 00:28:10.990
In this case,
I had done that beforehand in this demo,

00:28:11.100 --> 00:28:13.290
so full disclosure,
I had said these documents

00:28:13.320 --> 00:28:14.360
should be syncing.

00:28:14.510 --> 00:28:18.770
But once you do that, once you use the
NS File Manager APIs to say these

00:28:19.190 --> 00:28:23.850
documents should sync to iCloud,
then UIDoctument is fully ready

00:28:23.850 --> 00:28:29.760
to do the right thing for you and
make your application syncable.

00:28:29.760 --> 00:28:32.820
So that's how easy it is.

00:28:32.800 --> 00:28:37.720
Let's move to section three of our talk,
which is handling conflicts

00:28:37.720 --> 00:28:40.470
and errors in UI Document.

00:28:40.700 --> 00:28:43.590
Unfortunately,
with any document-based application,

00:28:43.610 --> 00:28:46.220
there's always the possibility
of things going wrong.

00:28:46.220 --> 00:28:49.250
We can't just guarantee that
life is going to be peaches

00:28:49.250 --> 00:28:51.640
and roses all the time,
because, well, hey,

00:28:51.640 --> 00:28:53.550
maybe your disk is full
and you can't write.

00:28:53.600 --> 00:28:57.080
Or maybe a conflict occurs in the cloud.

00:28:57.080 --> 00:29:01.420
And we can't just guarantee
that these things won't happen.

00:29:01.420 --> 00:29:06.710
But what we can do is try to give our
users the most graceful experience when

00:29:06.910 --> 00:29:09.290
those unfortunate things do happen.

00:29:09.520 --> 00:29:12.390
So that's what we're
going to talk about now.

00:29:12.590 --> 00:29:17.850
Now, what UIDocument provides for you to
help make this a little easier is a

00:29:17.990 --> 00:29:23.710
property called DocumentState that you
can observe to know when the documents

00:29:23.800 --> 00:29:31.180
in various states that tell you about
when the user's changes are being safely

00:29:32.310 --> 00:29:37.120
So the document state tells you
about that information of how safe

00:29:37.210 --> 00:29:40.210
it is to let the user make changes.

00:29:40.270 --> 00:29:44.680
And we'll be observing this
property through a notification,

00:29:44.690 --> 00:29:48.100
which is
UIDocumentStateChangedNotification.

00:29:48.100 --> 00:29:51.650
And you'll probably register for this
notification in your view controller.

00:29:51.700 --> 00:29:56.090
This is because responding to
DocumentStateChanges is all about

00:29:56.250 --> 00:29:58.510
giving feedback to the user.

00:29:58.520 --> 00:30:03.180
The user is going to want to know
if we're having a problem saving,

00:30:03.180 --> 00:30:06.750
for example,
and their data isn't being persisted

00:30:06.760 --> 00:30:09.960
to disk as their normal illusion of,
"Hey,

00:30:09.960 --> 00:30:13.890
I just make changes and they're persisted
for me." So we want to let them know

00:30:13.890 --> 00:30:16.420
when we're in those interesting states.

00:30:20.080 --> 00:30:22.200
Let's talk about what
those document states are.

00:30:22.260 --> 00:30:23.830
Most of the time,
your document is just going to

00:30:23.830 --> 00:30:25.500
be in UIDocumentStateNormal.

00:30:25.520 --> 00:30:28.150
And this means, well, everything's fine.

00:30:28.270 --> 00:30:32.760
User changes are being persisted
to disk as they would expect.

00:30:32.770 --> 00:30:33.830
Everything's hunky dory.

00:30:33.840 --> 00:30:34.440
They make changes.

00:30:34.510 --> 00:30:35.380
We save them.

00:30:35.500 --> 00:30:37.270
Life is good.

00:30:37.670 --> 00:30:40.810
There are four other states
that the document may be in,

00:30:40.810 --> 00:30:43.500
and we'll talk about those
and what they mean right now.

00:30:43.800 --> 00:30:46.500
Number one is state closed.

00:30:46.500 --> 00:30:50.500
This is the initial state of the
document when--after you initialize it.

00:30:50.500 --> 00:30:54.730
It will remain in this state until
you successfully open the document or

00:30:54.780 --> 00:30:58.290
you save if you're creating a file.

00:30:58.720 --> 00:31:00.560
And obviously,
the user probably isn't making

00:31:00.560 --> 00:31:03.400
changes when the document is closed.

00:31:03.400 --> 00:31:05.910
But we're certainly not
autosaving or anything like that,

00:31:05.910 --> 00:31:08.010
it's a closed document.

00:31:08.060 --> 00:31:11.370
The second state we can be
in is the conflict state.

00:31:11.830 --> 00:31:14.830
This state is set when we
discover a conflict in iCloud,

00:31:14.970 --> 00:31:18.580
and this gives you the opportunity
to let the user know that,

00:31:18.800 --> 00:31:22.000
hey, there is a conflict,
and you may want to resolve it.

00:31:22.160 --> 00:31:25.900
We'll talk about initiating the conflict
resolution process in a little bit.

00:31:26.580 --> 00:31:29.790
Number three is saving error.

00:31:29.800 --> 00:31:31.850
This means...

00:31:32.370 --> 00:31:34.700
The last time we tried
to save the document,

00:31:34.720 --> 00:31:37.060
it wasn't successful for some reason.

00:31:37.060 --> 00:31:38.040
There was an error.

00:31:38.130 --> 00:31:42.300
We want to let the user know that, hey,
your data actually isn't being persisted

00:31:42.300 --> 00:31:45.460
to disk in a safe fashion right now.

00:31:45.460 --> 00:31:47.560
And they're probably going
to want to know about that.

00:31:47.560 --> 00:31:50.800
Number four is editing state disabled.

00:31:50.800 --> 00:31:55.230
This is the only one of the states
that is explicitly disallowed to

00:31:55.400 --> 00:31:59.140
let the user make changes to the
document while we're in this state.

00:31:59.140 --> 00:32:02.470
If we're in a saving error
state or a conflict state,

00:32:02.470 --> 00:32:05.390
for example,
you might let the user continue

00:32:05.390 --> 00:32:09.120
to interact with the document,
especially in a conflict state.

00:32:09.120 --> 00:32:12.170
They may choose to continue
to make changes and deal

00:32:12.290 --> 00:32:14.060
with that conflict later.

00:32:14.060 --> 00:32:17.680
But in an editing state disabled
or state editing disabled,

00:32:17.770 --> 00:32:20.780
we're telling you that it is
actually not safe right now

00:32:20.780 --> 00:32:22.380
to let the user make changes.

00:32:22.380 --> 00:32:25.380
An example might be when
we revert the document.

00:32:25.380 --> 00:32:27.840
While we're in the middle
of a revert operation,

00:32:27.840 --> 00:32:30.840
we know that any changes at the moment
are just going to be thrown out as

00:32:31.000 --> 00:32:33.120
soon as we complete this revert.

00:32:33.120 --> 00:32:35.500
So it just doesn't make sense
to allow them to make changes.

00:32:37.300 --> 00:32:41.350
So let's revisit the document
application architecture

00:32:41.420 --> 00:32:43.460
that we saw at the beginning.

00:32:43.540 --> 00:32:48.310
And we focused mostly on the UI document
and building our model controller so far.

00:32:48.360 --> 00:32:52.460
We're going to take a moment
to focus on the view controller

00:32:53.120 --> 00:32:55.610
for this portion of the talk,
because as I said before,

00:32:55.610 --> 00:32:58.950
this is all about providing
feedback to the user.

00:32:58.960 --> 00:33:03.670
So some user interface that says, hey,
the document's in an abnormal state.

00:33:03.750 --> 00:33:05.520
That's what this is all about.

00:33:05.630 --> 00:33:10.090
So let's walk through what we might
do to respond to a saving error.

00:33:10.440 --> 00:33:15.240
You start by registering for the
document state change notification.

00:33:15.320 --> 00:33:18.600
You'll do that on your view controller,
because your view controller is going

00:33:18.600 --> 00:33:20.310
to want to provide UI in response.

00:33:20.440 --> 00:33:27.510
We'll call this with the saving
error state set if an error occurs.

00:33:27.720 --> 00:33:30.740
And your response to that is
going to want to be to show

00:33:31.470 --> 00:33:36.130
some non-modal UI to the user,
indicating that they're in this state.

00:33:36.160 --> 00:33:40.690
The key here really is non-modal,
because what we don't want is just

00:33:40.970 --> 00:33:43.810
popping modal alerts in the user's face.

00:33:44.070 --> 00:33:46.520
Particularly considering
autosaving and things,

00:33:46.520 --> 00:33:48.960
we could have repeated errors,
and we don't want UI alert

00:33:49.000 --> 00:33:55.160
views popping up repeatedly,
yelling at the user, telling them, hey,

00:33:55.370 --> 00:33:57.000
there is an error.

00:33:57.050 --> 00:33:58.090
We get it.

00:33:58.120 --> 00:34:02.100
We want to communicate this to the user,
but we don't want to yell it at them.

00:34:02.340 --> 00:34:03.900
So non-modal UI is the key.

00:34:03.900 --> 00:34:07.000
And we'll show you an example,
maybe some food for thought,

00:34:07.000 --> 00:34:09.220
of what this means in just a little bit.

00:34:09.350 --> 00:34:12.480
I'd like to talk about
conflict resolution.

00:34:12.540 --> 00:34:17.000
Conflict resolution, of course,
is a little bit new for iOS 5.

00:34:17.210 --> 00:34:20.390
But it's this world we are now
going to live in with iCloud where,

00:34:20.510 --> 00:34:24.430
hey, we've got multiple devices
around that all may be making

00:34:24.430 --> 00:34:29.360
changes relative to each other,
and those could sink to the

00:34:29.360 --> 00:34:31.460
cloud and cause conflicts.

00:34:31.630 --> 00:34:37.420
So there's always the possibility that
I took my iPad on the plane with me,

00:34:37.430 --> 00:34:40.650
and while I was there I decided, eh,
I want to add something

00:34:40.650 --> 00:34:41.520
to my grocery list.

00:34:41.520 --> 00:34:44.540
I want to make sure we get mustard.

00:34:44.590 --> 00:34:48.470
But at the same time that I've done that,
my aunt Edna, who's coming to pick

00:34:48.470 --> 00:34:52.070
me up from the airport,
added ketchup to the grocery list.

00:34:52.080 --> 00:34:53.570
She thought we needed ketchup.

00:34:53.640 --> 00:34:56.920
And then when I get off the
plane and get internet again,

00:34:56.940 --> 00:35:00.000
our changes both try to
sink up to the cloud,

00:35:00.050 --> 00:35:02.580
and we have these conflicting changes.

00:35:02.600 --> 00:35:04.000
We have mustard and ketchup.

00:35:04.030 --> 00:35:06.210
Well, which one should it be?

00:35:06.280 --> 00:35:07.240
I don't know.

00:35:07.260 --> 00:35:08.450
We have to solve this in some way.

00:35:08.460 --> 00:35:13.540
But the key to this story is you can't
make your users not go on planes,

00:35:13.540 --> 00:35:14.480
not go offline.

00:35:14.480 --> 00:35:17.480
And thus potentially
make conflicting changes,

00:35:17.480 --> 00:35:22.480
or even just make changes simultaneously
on two devices if they're like that.

00:35:22.550 --> 00:35:27.310
So what I want you to be thinking
right now is if you're wondering

00:35:27.310 --> 00:35:32.770
whether your application needs to
have a conflict resolution strategy,

00:35:32.770 --> 00:35:37.180
the answer to this is if you are
going to integrate to iCloud,

00:35:37.490 --> 00:35:41.600
yes, you must have a conflict
resolution strategy,

00:35:41.740 --> 00:35:46.440
because it can happen,
and if your users have multiple devices,

00:35:46.440 --> 00:35:50.060
odds are maybe at some
point it probably will.

00:35:50.060 --> 00:35:55.240
So we're going to talk a little bit in
a bit about how you're going to do that,

00:35:55.240 --> 00:35:58.430
but first of all,
finding out that there is a conflict

00:35:58.430 --> 00:36:02.040
is pretty similar to finding
out that there's a saving error.

00:36:02.040 --> 00:36:06.160
You're going to get that notified via
the document state change notification,

00:36:06.250 --> 00:36:10.050
and in this case we'll have
the state in conflict set.

00:36:10.660 --> 00:36:13.710
Once that happens,
you'll turn around and you can

00:36:13.730 --> 00:36:19.100
look at the conflict versions
that exist via NSFileVersion APIs.

00:36:19.140 --> 00:36:24.360
And after you execute some sort
of conflict resolution strategy,

00:36:24.400 --> 00:36:28.280
you will then potentially revert
the contents of the document

00:36:28.830 --> 00:36:33.190
if you've changed the on-disk
representation of the file.

00:36:33.280 --> 00:36:35.630
For example,
if you've done a merge or you've

00:36:35.630 --> 00:36:38.840
copied some other version into
being the current version,

00:36:38.840 --> 00:36:43.560
then you'll need to revert the
document so that we get what we see on

00:36:43.560 --> 00:36:47.590
screen equal to what you put on desk.

00:36:48.550 --> 00:36:53.100
So let's talk about how we can actually
think about resolving some conflict.

00:36:53.100 --> 00:36:56.490
What are some strategies
that we can employ?

00:36:56.530 --> 00:36:57.980
And there are a few of them.

00:36:57.980 --> 00:37:00.940
Number one, this is my personal favorite,
if you can do it.

00:37:00.940 --> 00:37:02.900
And that's automatic merging.

00:37:02.980 --> 00:37:06.340
And that is taking the changes
that the user made in different

00:37:06.380 --> 00:37:10.610
places and bringing them together
in a way that makes sense for

00:37:10.770 --> 00:37:13.100
your document without having to--

00:37:13.880 --> 00:37:16.300
Bring in any user interaction.

00:37:16.310 --> 00:37:19.750
You just figure out what
makes sense and do it.

00:37:21.000 --> 00:37:26.540
In the case of the ketchup mustard
incident that I showed to you before,

00:37:26.720 --> 00:37:28.790
what the application probably
should have done is said,

00:37:28.960 --> 00:37:31.950
hey, one person wants ketchup,
one person wants mustard.

00:37:32.040 --> 00:37:34.500
You know,
our final version of the document should

00:37:34.530 --> 00:37:36.540
just have ketchup and mustard both in it.

00:37:36.740 --> 00:37:40.420
It doesn't make sense for all documents,
but for some it certainly does,

00:37:40.420 --> 00:37:41.940
and if you can do it, do it.

00:37:41.990 --> 00:37:45.910
Another solution not so good is
just take the latest version.

00:37:46.050 --> 00:37:48.940
Maybe this makes sense for your document.

00:37:49.060 --> 00:37:53.430
What that is is when
iCloud picks a winner,

00:37:53.430 --> 00:37:55.600
a conflict winner,
and makes that the current version,

00:37:55.600 --> 00:37:59.980
you can just say, okay, yeah,
I like that,

00:37:59.980 --> 00:38:04.080
and turn around and say all of the
conflict loser versions that exist

00:38:04.080 --> 00:38:06.310
out there are--I don't need them.

00:38:06.430 --> 00:38:07.930
Just mark them as resolved.

00:38:07.980 --> 00:38:09.780
That's part of the NSFile version API.

00:38:09.780 --> 00:38:13.630
You can just say, hey,
this version is resolved.

00:38:13.990 --> 00:38:15.520
and just be done with that.

00:38:15.590 --> 00:38:19.710
It has a downside of potentially
appearing to the user as a data loss,

00:38:19.760 --> 00:38:25.150
because if my mustard version,
for example, was declared by iCloud as

00:38:25.290 --> 00:38:28.320
the loser and you just go,
mark it resolved and don't tell

00:38:28.360 --> 00:38:30.120
me about it and it goes away,
well,

00:38:30.120 --> 00:38:32.820
I don't know what happened to my mustard.

00:38:32.940 --> 00:38:36.990
But at least it's better than nothing,
because if you don't at least

00:38:36.990 --> 00:38:40.770
mark conflict versions as resolved
and have some sort of conflict

00:38:40.840 --> 00:38:45.000
resolution strategy that way,
you effectively introduce a leak,

00:38:45.000 --> 00:38:48.800
a data leak, into the user's iCloud
account and onto their device,

00:38:48.800 --> 00:38:53.940
because the conflict loser version stick
around until they're marked as resolved.

00:38:54.080 --> 00:38:57.490
So that's why it's really
bad to just do nothing.

00:38:57.510 --> 00:39:00.390
You don't want these conflict
versions sitting around forever.

00:39:00.450 --> 00:39:02.510
We've got to do something.

00:39:02.600 --> 00:39:05.020
Another naive approach is, well,
just prompt the user.

00:39:05.090 --> 00:39:07.620
Maybe you don't know how
to merge the changes.

00:39:07.620 --> 00:39:08.300
That can be OK.

00:39:08.300 --> 00:39:10.000
That makes sense sometimes.

00:39:10.000 --> 00:39:14.640
And if you don't know, you just say, hey,
user, I've got a conflict.

00:39:14.670 --> 00:39:17.140
Sorry that happened,
but can you let me know

00:39:17.140 --> 00:39:18.380
what I should do about this?

00:39:18.380 --> 00:39:22.950
And you provide some UI that allows
the user to do manual merging or pick

00:39:22.950 --> 00:39:24.960
a version that they want to keep.

00:39:24.960 --> 00:39:28.970
Whatever it is,
give the user a chance to do that.

00:39:29.500 --> 00:39:32.350
The last solution I have in
mind today is a nice easy one,

00:39:32.420 --> 00:39:34.240
and I mentioned it earlier.

00:39:34.240 --> 00:39:36.300
Let's just use UIManagedDocument.

00:39:36.300 --> 00:39:41.460
UIManagedDocument, as I said before,
has built-in conflict resolution for you.

00:39:41.480 --> 00:39:45.610
So if you just adopt CoreData and
use the UIManagedDocument class,

00:39:45.710 --> 00:39:47.920
this is done for you.

00:39:47.940 --> 00:39:49.100
Nice, easy day.

00:39:49.100 --> 00:39:50.940
Conflict resolution is not your problem.

00:39:50.960 --> 00:39:54.730
So consider using that if it makes sense,
and you can learn more about that

00:39:55.140 --> 00:39:59.200
in What's New in CoreData on iOS,
which was talked about yesterday.

00:39:59.200 --> 00:40:02.990
If you missed that,
we post videos online for a reason.

00:40:03.000 --> 00:40:06.170
So to give you an example
of this kind of thing,

00:40:06.180 --> 00:40:10.570
I'd like to talk about what we can
do to the Cloud Notes application

00:40:10.620 --> 00:40:14.130
that I already showed you to
employ some of these ideas.

00:40:14.140 --> 00:40:20.050
So what we want to do is add some
UI to express the state of the

00:40:20.210 --> 00:40:23.230
document to the user in Cloud Notes.

00:40:23.300 --> 00:40:27.050
So what I am adding
here is a little light.

00:40:27.460 --> 00:40:31.550
In my application above my content,
in this case it's a green

00:40:31.550 --> 00:40:34.140
light that tells the user,
hey, green light,

00:40:34.140 --> 00:40:36.140
your document is in the normal state.

00:40:36.140 --> 00:40:38.440
This is reflective of your
document's state normal.

00:40:38.440 --> 00:40:40.630
And whatever you're doing,
making changes,

00:40:40.640 --> 00:40:42.640
they'll be automatically saved to disk.

00:40:42.780 --> 00:40:43.620
Everything is A-OK.

00:40:43.620 --> 00:40:45.210
Good times for the user.

00:40:47.760 --> 00:40:48.100
Okay.

00:40:48.100 --> 00:40:52.580
So, if I encounter a saving error,
I can non-modally just turn my light

00:40:52.580 --> 00:40:58.270
to a red light and add the text,
"Saving error," or unsaved, yeah,

00:40:58.270 --> 00:40:59.400
unsaved.

00:40:59.400 --> 00:41:02.220
And that tells my document, "Hey,
this document isn't

00:41:02.220 --> 00:41:05.340
saved." That's not normal,
because I normally just expect my data

00:41:05.440 --> 00:41:08.120
always to be saved and always persisted.

00:41:08.120 --> 00:41:12.140
But it's certainly good to know that,
hey, I'm in this state, and, you know,

00:41:12.140 --> 00:41:15.220
maybe it's interactive for you,
maybe the user can tap on that

00:41:15.220 --> 00:41:16.910
and get some more information.

00:41:16.970 --> 00:41:20.770
But the real key here is that I didn't
pop up a modal alert in the user's face.

00:41:20.820 --> 00:41:23.640
I just gave them some kind
of non-modal feedback that,

00:41:23.640 --> 00:41:27.820
hey, we're in a state where we actually
aren't persisting to disk.

00:41:27.820 --> 00:41:30.520
Another case would be we
discovered that a conflict,

00:41:30.520 --> 00:41:34.890
the conflict--the in-conflict
state was set on our document.

00:41:34.900 --> 00:41:38.550
And what I do here is just turn
this to a yellow light and put a

00:41:38.550 --> 00:41:41.020
"Resolve conflicts" button on there.

00:41:41.020 --> 00:41:46.740
I've decided to employ the prompt the
user approach for this application.

00:41:46.740 --> 00:41:51.640
And so I'm letting the user know that,
hey, we're in a conflict state.

00:41:51.700 --> 00:41:53.710
You can actually continue
to make changes if you want.

00:41:53.810 --> 00:41:58.390
Just continue to interact
with the document.

00:41:58.630 --> 00:42:01.790
When you decide, "Hey,
I want to resolve those conflicts,"

00:42:01.810 --> 00:42:03.340
they can tap the button.

00:42:03.360 --> 00:42:07.470
I'll show them some UI that
allows them to manually merge

00:42:07.470 --> 00:42:10.710
the conflicts or pick a version,
whatever they think the

00:42:10.710 --> 00:42:11.950
final version should be.

00:42:12.000 --> 00:42:18.910
I will then make sure that's saved and
revert the contents of the document.

00:42:20.380 --> 00:42:27.120
So that's the polish that we would
want to add to our application to

00:42:27.120 --> 00:42:31.540
get it to that level where it's
ready to ship to the App Store.

00:42:31.540 --> 00:42:35.960
We've not only done opening and saving
and we've enabled the auto-saving

00:42:35.960 --> 00:42:40.250
engine by telling the document
about the changes we've made,

00:42:40.250 --> 00:42:45.460
but we've also added support to our
document to handle when things might

00:42:45.460 --> 00:42:50.350
go wrong and make sure that the user
is protected and is going to have

00:42:50.350 --> 00:42:54.790
a relatively graceful experience no
matter what happens with our document.

00:42:55.300 --> 00:43:00.680
So we have some time now to
delve into the advanced concepts

00:43:00.840 --> 00:43:03.020
that exist in UI Document.

00:43:03.080 --> 00:43:09.660
This is going to be a relatively brief
overview to give you an idea of what's

00:43:09.660 --> 00:43:14.400
out there to gain more fine control,
more fine-grained control

00:43:14.400 --> 00:43:18.920
over UI Document and really
affect how it behaves.

00:43:18.920 --> 00:43:22.240
What I want to reiterate before
we get into this is that we've

00:43:22.480 --> 00:43:27.060
provided some really simple API for
you that is what we've discussed

00:43:27.060 --> 00:43:31.550
up to this point in the talk that
really just should be everything you

00:43:31.550 --> 00:43:34.170
need to go ship your application.

00:43:34.180 --> 00:43:39.780
And I only encourage you to go looking
at these fine-grained hooks that

00:43:39.960 --> 00:43:44.820
we're giving you if you find that your
application really has some specialized

00:43:44.820 --> 00:43:49.740
need that just isn't fulfilled by
the API that we've shown thus far.

00:43:49.740 --> 00:43:52.540
And if that's the case, okay.

00:43:52.540 --> 00:43:54.120
I will send you to the docs.

00:43:54.130 --> 00:43:56.090
That's after this talk because
we don't have much time to

00:43:56.090 --> 00:44:00.280
talk about advanced things,
but we'll do what we can.

00:44:00.520 --> 00:44:03.680
So let's revisit the
queue model that we had.

00:44:03.770 --> 00:44:05.650
For reading, it looked like this.

00:44:05.780 --> 00:44:08.200
We initiated opening
on the calling queue.

00:44:08.200 --> 00:44:12.780
We went and did reading on a
UIKit managed background queue,

00:44:12.810 --> 00:44:15.620
and then loaded the contents
and executed the completion

00:44:15.620 --> 00:44:17.670
handler on the calling queue.

00:44:17.830 --> 00:44:19.290
Writing similar.

00:44:19.330 --> 00:44:23.020
We're doing snapshotting on
the main queue after saving,

00:44:23.020 --> 00:44:26.180
writing that in the background,
and executing a completion

00:44:26.180 --> 00:44:27.760
handler on the main queue.

00:44:29.930 --> 00:44:36.010
We're going to focus for the next
few minutes on things that exist

00:44:36.330 --> 00:44:40.550
in the UIKit background queue,
and what you can do to

00:44:40.550 --> 00:44:45.600
call into that queue,
to initiate specialized operations,

00:44:45.600 --> 00:44:50.720
or to override methods that get
executed in that background queue.

00:44:50.720 --> 00:44:54.800
So there are a couple of considerations
that you'll want to keep in mind

00:44:54.850 --> 00:44:56.530
if you're delving into this area.

00:44:57.220 --> 00:45:00.680
One is, if you're overriding
any of these methods,

00:45:00.680 --> 00:45:03.780
you need to be aware that, hey,
I'm dealing with something

00:45:03.780 --> 00:45:07.910
on a concurrent queue,
and so my code that I'm writing in one of

00:45:07.910 --> 00:45:09.910
these overrides needs to be thread safe.

00:45:10.060 --> 00:45:11.760
That's the simple thing.

00:45:12.060 --> 00:45:14.650
It gets actually more complex
when we're talking about calling

00:45:14.650 --> 00:45:15.880
into one of these methods.

00:45:16.010 --> 00:45:18.870
There are a couple of things you need
to do if you call into one of our

00:45:18.900 --> 00:45:20.960
background reading or writing methods.

00:45:21.150 --> 00:45:24.600
Number one, you need to take whatever
it is you're doing,

00:45:24.640 --> 00:45:28.470
whether it's a read from URL operation,
or whatever, or whatever.

00:45:28.710 --> 00:45:32.130
and wrap it into a block that
you pass to perform asynchronous

00:45:32.260 --> 00:45:34.520
file access using block.

00:45:34.530 --> 00:45:39.690
This is a method on UI document that
allows us to schedule your operation on

00:45:39.690 --> 00:45:43.580
our background reading and writing queue,
which is where all reading

00:45:43.900 --> 00:45:45.680
and writing needs to happen.

00:45:46.130 --> 00:45:51.990
Additionally, you will need to use the
NSFileCoordinator API if you are doing

00:45:51.990 --> 00:45:55.570
reads and writes initiated yourself,
rather than calling

00:45:55.900 --> 00:45:58.860
our high-level methods,
open with completion

00:45:58.860 --> 00:46:01.080
handler and save to URL.

00:46:01.080 --> 00:46:04.550
Those methods do file
coordination for you,

00:46:04.550 --> 00:46:08.480
which is necessary to have
safe reading and writing

00:46:08.480 --> 00:46:11.150
relative to the iCloud daemon.

00:46:11.710 --> 00:46:13.600
But if you're doing
these things yourself,

00:46:13.750 --> 00:46:17.230
you need to use the
NSFileCoordination API,

00:46:17.270 --> 00:46:19.640
which is also new in iOS 5.

00:46:19.640 --> 00:46:23.640
And there was a talk on that,
taking advantage of file coordination,

00:46:23.810 --> 00:46:25.640
also yesterday.

00:46:25.640 --> 00:46:27.640
The video will be posted online.

00:46:27.640 --> 00:46:31.810
I really encourage you to watch
that video if you at all are

00:46:31.810 --> 00:46:36.550
in the situation where you're
needing to do file coordination.

00:46:36.830 --> 00:46:41.340
So one of the things you can do
if you are in this world where you

00:46:41.340 --> 00:46:44.340
need the fine-grained control and
you're going into this background

00:46:44.340 --> 00:46:45.760
queue is incremental reading.

00:46:45.760 --> 00:46:51.060
So if this is our diagram of how
the reading queue model works,

00:46:51.060 --> 00:46:54.880
we're going to focus now finally
on that background queue and

00:46:54.880 --> 00:46:59.320
give you your override point
for doing incremental reading.

00:46:59.320 --> 00:47:02.110
This is actually a method that
you will call and override,

00:47:02.110 --> 00:47:05.020
more than likely,
if you're doing incremental reading.

00:47:05.500 --> 00:47:08.420
Read from URL with an error
returned by indirection.

00:47:08.420 --> 00:47:12.180
The reason you will probably do both
is you'll want to override it so that

00:47:12.180 --> 00:47:16.960
when OpenWithCompletionHandler executes,
we invoke your implementation

00:47:16.960 --> 00:47:19.850
of read from URL,
your incremental implementation.

00:47:19.860 --> 00:47:22.890
But then also, likely,
when you get to the point where

00:47:22.890 --> 00:47:26.100
you want to do some more reads,
you're going to want to call

00:47:26.100 --> 00:47:28.980
in directly to read from URL,
so you'll both override

00:47:28.980 --> 00:47:30.300
it and invoke it yourself.

00:47:32.540 --> 00:47:36.080
On the writing side,
you might want to have your

00:47:36.080 --> 00:47:37.770
own definition of safe writing.

00:47:37.930 --> 00:47:40.990
Well,
safe writing is something that UIKit,

00:47:41.000 --> 00:47:46.090
UIDocument does on your behalf
any time we do a normal save.

00:47:46.160 --> 00:47:50.170
Safe writing means, for us,
we write your data into an ancillary

00:47:50.290 --> 00:47:55.200
file on the side of the actual file
URL that your document represents.

00:47:55.200 --> 00:47:58.830
And when we've written all that data out,
we atomically copy it into place.

00:47:58.930 --> 00:48:01.690
That's what safe writing means
by default for your iDocument.

00:48:03.430 --> 00:48:07.530
But maybe this doesn't make
sense for your application,

00:48:07.770 --> 00:48:11.680
and you want your own
definition of safe writing.

00:48:11.980 --> 00:48:14.510
Or maybe you don't want to
participate in SafeWriting.

00:48:14.540 --> 00:48:17.420
If that's the case,
the override point that we're

00:48:17.420 --> 00:48:22.580
giving you is write contents
and attributes safely to URL.

00:48:22.580 --> 00:48:27.900
And here you can do what makes sense for
your application in terms of SafeWriting,

00:48:27.900 --> 00:48:30.780
if it's something other than
writing to an ancillary file,

00:48:30.790 --> 00:48:34.260
or just skip SafeWriting
entirely and write directly

00:48:34.450 --> 00:48:36.540
to the file in this method.

00:48:36.600 --> 00:48:39.380
Something else that you might
be interested in is writing a

00:48:39.380 --> 00:48:42.170
custom snapshot of your data.

00:48:42.220 --> 00:48:44.940
If you want to do that,
you can leave write contents and

00:48:44.940 --> 00:48:50.840
attributes safely to URL alone,
and let our default implementation

00:48:50.840 --> 00:48:55.120
of that call another write method,
also on the background queue,

00:48:55.130 --> 00:48:58.640
where you can have your override
point for writing a custom snapshot.

00:48:58.640 --> 00:49:03.360
That override point is-- well,
the text is wrong here,

00:49:03.360 --> 00:49:05.420
and I apologize for that.

00:49:05.420 --> 00:49:07.660
That's the same method you saw before.

00:49:07.790 --> 00:49:11.820
The actual method is just
write contents to URL.

00:49:11.820 --> 00:49:16.670
I think it takes a save operation
parameter and an error by indirection,

00:49:16.670 --> 00:49:19.480
and also the original file contents URL.

00:49:19.480 --> 00:49:22.960
So you can look that method
up in the UI document header.

00:49:22.960 --> 00:49:26.200
It's the one that doesn't
have safely in the name.

00:49:27.350 --> 00:49:34.550
And that's your opportunity to
actually do the actual writing to disk.

00:49:34.750 --> 00:49:40.000
If you return us something other than
an NSData type or an NSFileWrapper

00:49:40.060 --> 00:49:43.810
type from contents for type,
then you're actually required

00:49:43.810 --> 00:49:47.300
to override here so that you
can write that data to disk,

00:49:47.300 --> 00:49:51.170
since we only know how to
do NSData and NSFileWrapper.

00:49:52.510 --> 00:49:55.040
So one last thing I have in mind
that you might be interested

00:49:55.040 --> 00:49:57.220
in is changing the file's type.

00:49:57.310 --> 00:49:59.720
Some applications might
want to do this dynamically.

00:49:59.720 --> 00:50:05.290
Their document class can actually
represent more than one type of file,

00:50:05.290 --> 00:50:10.660
and that type could actually change
through the document's lifetime.

00:50:10.770 --> 00:50:13.720
And we do have some overrides
to allow you to do that.

00:50:13.760 --> 00:50:17.870
Example might be,
maybe you have a flat RTF file,

00:50:17.900 --> 00:50:20.940
but then the user can
add an attachment to it,

00:50:20.950 --> 00:50:25.350
and it becomes an RTFD file,
and then you need to dynamically

00:50:25.370 --> 00:50:27.990
change the type of that document.

00:50:28.180 --> 00:50:33.550
And so override that we're providing
for you there is saving file type.

00:50:33.750 --> 00:50:37.910
We will call this at the beginning
of a save operation to determine what

00:50:38.070 --> 00:50:41.730
type we should use for that save,
and you return us a uniform type

00:50:41.840 --> 00:50:45.340
identifier as an NSString that
we'll use for that save.

00:50:45.340 --> 00:50:48.470
We'll take that uniform type identifier,
turn around,

00:50:48.470 --> 00:50:51.660
and call file name extension for type,
All right.

00:50:52.700 --> 00:51:13.200
So that's what I wanted to talk to
you about with UI Document today.

00:51:13.200 --> 00:51:15.010
Like to reiterate a few things.

00:51:15.110 --> 00:51:18.110
Number one,
if there's anything I want you

00:51:18.110 --> 00:51:21.940
to have in your head as you walk
out of here and go write your

00:51:21.940 --> 00:51:26.600
first document-based applications,
it's really be simple.

00:51:26.600 --> 00:51:31.070
Remember the demonstration that
we had where I was able to only

00:51:31.690 --> 00:51:36.080
override two methods on UI Document,
load from contents and contents for type.

00:51:37.340 --> 00:51:42.190
UI document is designed to
encourage you to use the simplest

00:51:42.190 --> 00:51:44.680
parts of its API that you can.

00:51:44.680 --> 00:51:48.310
And we have fine grained
controls for applications that

00:51:48.690 --> 00:51:50.700
need to do specialized things.

00:51:50.710 --> 00:51:55.150
But I really like you to look at doing
the simple things and using the simple

00:51:55.340 --> 00:52:00.540
APIs first and only move to the advanced
ones if you find some specialized need

00:52:00.540 --> 00:52:02.820
that you can't fill with the easy API.

00:52:02.820 --> 00:52:04.240
It'll make your life easier.

00:52:04.240 --> 00:52:07.180
It'll make your applications
developed more quickly.

00:52:07.180 --> 00:52:09.740
And if you ever pass them
on to another developer,

00:52:09.750 --> 00:52:11.600
they'll be able to
understand your code better.

00:52:11.740 --> 00:52:15.100
So great advantages to keeping it simple.

00:52:15.100 --> 00:52:18.780
Number two is don't forget to register
your changes with the document.

00:52:18.790 --> 00:52:19.960
We love autosaving.

00:52:19.960 --> 00:52:21.670
We love the saveless user model.

00:52:21.680 --> 00:52:24.760
That's all driven by you
very simply telling us about

00:52:24.810 --> 00:52:26.110
the changes that are made.

00:52:26.170 --> 00:52:28.980
It's very easy to do this,
either calling our update change

00:52:28.980 --> 00:52:32.540
count method or registering your
changes with the undo manager.

00:52:32.540 --> 00:52:34.220
And after that, we're off and running.

00:52:34.220 --> 00:52:37.100
and auto saving happens for you.

00:52:37.900 --> 00:52:41.950
Finally, since this is what
UI Document is all about,

00:52:42.080 --> 00:52:45.480
I want you to use iCloud.

00:52:45.530 --> 00:52:47.180
UI Document was built for iCloud.

00:52:47.280 --> 00:52:50.220
Users are going to love using iCloud.

00:52:50.300 --> 00:52:53.920
And the premier applications on the
App Store are going to be ones that

00:52:53.920 --> 00:52:58.120
allow the user to seamlessly have
their data across all of their devices.

00:52:58.120 --> 00:53:01.770
So if you're building
Document applications in iOS 5,

00:53:01.800 --> 00:53:03.480
you really should use iCloud.

00:53:03.480 --> 00:53:06.760
And thankfully,
UI Document makes that incredibly easy.

00:53:06.920 --> 00:53:11.710
Not really any specialized code
to handle UI document syncing.

00:53:11.910 --> 00:53:15.550
But the one thing also to
remember when you are saying,

00:53:15.550 --> 00:53:19.830
yes, I am going to integrate with iCloud,
is also, yes,

00:53:19.850 --> 00:53:24.140
I need a conflict resolution strategy.

00:53:24.150 --> 00:53:27.500
That may be using UI Manage Document.

00:53:27.500 --> 00:53:29.540
That may be doing automatic merging.

00:53:29.540 --> 00:53:32.120
God bless you if you do so.

00:53:32.160 --> 00:53:35.940
Or it may be presenting things
to the user and letting them

00:53:36.330 --> 00:53:38.040
figure it out for themselves.

00:53:38.040 --> 00:53:40.160
But whatever it is, don't do nothing.

00:53:40.160 --> 00:53:45.590
You don't want to leak data into
the user's iCloud storage account.

00:53:45.610 --> 00:53:50.160
And you certainly don't want them to
have the appearance of a data loss

00:53:50.160 --> 00:53:55.890
because they can't access versions that
have been conflicted away from them.

00:53:56.570 --> 00:54:00.420
So that's UIDocument that's
storing documents in iCloud.

00:54:00.420 --> 00:54:03.540
If you're interested
in some other sessions,

00:54:03.540 --> 00:54:07.320
I mentioned a few,
taking advantage of file coordination,

00:54:07.340 --> 00:54:11.420
what's new in Core Data on iOS,
and also there's an

00:54:11.420 --> 00:54:13.100
iCloud Storage overview.

00:54:13.100 --> 00:54:19.260
All of these sessions already happened,
so I apologize for that.

00:54:19.260 --> 00:54:21.630
I will next time ask to be first.

00:54:21.650 --> 00:54:25.000
And I really look forward to seeing the
great document-based applications you

00:54:25.000 --> 00:54:26.650
all are going to be writing in iOS 5.

00:54:26.770 --> 00:54:27.960
Thank you very much.
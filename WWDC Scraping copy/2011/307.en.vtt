WEBVTT

00:00:10.800 --> 00:00:15.390
Good morning, I'm Bob Wilson,
I'm the manager of the LLVM core team.

00:00:15.410 --> 00:00:19.990
Thank you for coming today to find
out about moving to the LLVM compiler.

00:00:20.140 --> 00:00:22.280
So let's get started.

00:00:23.470 --> 00:00:26.370
One of the big announcements we
made on Monday is that Apple has

00:00:26.420 --> 00:00:28.200
moved to the LLVM compiler.

00:00:28.260 --> 00:00:35.080
We're building both Mac OS X Lion and
iOS 5 with LLVM-based compilers.

00:00:35.150 --> 00:00:39.590
And we're here today to ask
you to do the same thing.

00:00:40.400 --> 00:00:43.280
So if you're new here,
or even if you're not,

00:00:43.510 --> 00:00:46.280
you may be wondering, what is LLVM?

00:00:46.320 --> 00:00:49.310
Or what other compiler would I use?

00:00:49.600 --> 00:00:53.520
So before we go into LLVM,
I want to give you a little history

00:00:54.120 --> 00:00:56.420
lesson on compilers at Apple.

00:00:56.760 --> 00:00:59.500
So for quite a long time now,
Apple has been using

00:00:59.500 --> 00:01:02.390
the GNU GCC compiler.

00:01:02.560 --> 00:01:05.030
A lot of you are familiar with that.

00:01:05.030 --> 00:01:06.320
And that's one of its advantages.

00:01:06.380 --> 00:01:10.810
It's portable, it's familiar,
people have been using it.

00:01:11.000 --> 00:01:13.200
It has pretty good performance.

00:01:13.330 --> 00:01:15.990
We've built a lot of
great software products.

00:01:16.180 --> 00:01:20.780
You have built a lot of great
apps using the GCC compiler.

00:01:20.910 --> 00:01:22.720
And it works, so that's great.

00:01:22.720 --> 00:01:26.890
But it's had some downsides too.

00:01:28.170 --> 00:01:31.960
One of those is that the error
messages that you get from GCC are not

00:01:31.960 --> 00:01:34.220
always as helpful as they could be.

00:01:34.350 --> 00:01:36.950
Sometimes they're downright confusing.

00:01:37.310 --> 00:01:40.950
One of the big problems for us is
that we would really like to integrate

00:01:41.040 --> 00:01:43.780
the compiler into other tools.

00:01:44.190 --> 00:01:49.190
Now, GCC has a 25-year-old
monolithic architecture.

00:01:49.360 --> 00:01:52.720
It is a compiler,
and that's all that it is.

00:01:52.930 --> 00:01:57.480
You take in source code,
and it puts out object code.

00:01:58.140 --> 00:02:00.340
So we'd like to do better than that.

00:02:00.400 --> 00:02:03.300
It's also been hard to improve GCC.

00:02:03.300 --> 00:02:05.740
I said the performance
has been pretty good,

00:02:05.780 --> 00:02:10.040
and it has, but we really want to take
performance up to the next level.

00:02:10.130 --> 00:02:15.100
And GCC has been stifling
innovation for us in the compiler.

00:02:15.100 --> 00:02:18.090
So we need a better compiler.

00:02:18.090 --> 00:02:22.090
And that is LLVM.

00:02:25.230 --> 00:02:28.200
That's our LLVM dragon logo up there.

00:02:28.210 --> 00:02:31.760
So the architecture of LLVM is
really one of the key things

00:02:31.780 --> 00:02:34.120
that makes it work for us.

00:02:34.140 --> 00:02:38.820
LLVM is architected as a set of
reusable compiler components.

00:02:38.840 --> 00:02:43.600
We can hook them up in different ways,
we can integrate them in different tools.

00:02:43.690 --> 00:02:47.750
Some examples of components:
The Clang front end,

00:02:47.750 --> 00:02:52.540
which is a unified C, C++,
and Objective-C parser.

00:02:52.540 --> 00:02:53.950
It's designed to be really fast.

00:02:54.080 --> 00:02:57.320
It's designed to give
good error messages.

00:02:59.620 --> 00:03:00.490
Optimizations.

00:03:00.600 --> 00:03:04.610
We have a great set of sophisticated
transformations that we can apply

00:03:04.710 --> 00:03:07.270
to make your apps run faster.

00:03:09.010 --> 00:03:12.210
We have machine code generators
for a variety of targets,

00:03:12.210 --> 00:03:17.210
including the Intel and ARM processors
that we use in Apple products.

00:03:18.400 --> 00:03:21.020
and we have a set of various
low-level tools such as

00:03:21.020 --> 00:03:23.610
assemblers and disassemblers.

00:03:23.880 --> 00:03:27.260
So just as an example,
consider the LLDB debugger you

00:03:27.260 --> 00:03:29.380
may have heard about this week.

00:03:29.410 --> 00:03:33.410
We want to use the Clang front
end in the debugger when you say

00:03:33.410 --> 00:03:35.980
print the value of this expression.

00:03:36.060 --> 00:03:39.480
We want to allow you to have any
arbitrary expression from the language,

00:03:39.480 --> 00:03:43.080
and so we need to have a parser
that can understand that language.

00:03:43.100 --> 00:03:46.350
So it makes a lot of sense
to take that front end,

00:03:46.350 --> 00:03:48.180
put it in the debugger.

00:03:48.510 --> 00:03:50.320
We also want to be able
to set breakpoints,

00:03:50.450 --> 00:03:52.980
step through code, disassemble.

00:03:52.990 --> 00:03:57.530
So we can take those components
from the LLVM components,

00:03:57.530 --> 00:04:03.180
put them into LLDB,
and really integrate everything together.

00:04:04.980 --> 00:04:07.050
LLVM is an open source project.

00:04:07.230 --> 00:04:10.680
We invite you to visit
us online at LLVM.org.

00:04:10.690 --> 00:04:12.010
You can learn more about the project.

00:04:12.130 --> 00:04:16.090
You can even get involved and help
out in the development if you want to.

00:04:17.110 --> 00:04:22.640
So this is just some background on
LLVM and where we're coming from.

00:04:22.640 --> 00:04:26.760
Let's get into the compilers in Xcode.

00:04:27.300 --> 00:04:30.000
If you've been using Xcode for a while,
you may have seen we have two

00:04:30.090 --> 00:04:32.400
different compilers with LLVM.

00:04:32.510 --> 00:04:38.460
The first one is LLVM-GCC,
which takes this high-tech LLVM backend,

00:04:38.530 --> 00:04:41.020
symbolized by this race car,

00:04:41.790 --> 00:04:48.290
combines that with the
same old GCC front end.

00:04:49.060 --> 00:04:51.820
We basically just bolt them together.

00:04:51.890 --> 00:04:56.190
It's a little bit awkward,
but it has one big advantage,

00:04:56.190 --> 00:04:59.220
and this is why we call
this our legacy compiler.

00:04:59.300 --> 00:05:04.240
The GCC front end will accept all the
same code as the GCC compiler did,

00:05:04.320 --> 00:05:06.910
because it's the same compiler.

00:05:07.810 --> 00:05:12.120
So this has played a useful role
for us and continues to do that,

00:05:12.170 --> 00:05:14.260
but it still has the same problems.

00:05:14.470 --> 00:05:18.740
You still get the same confusing
error messages from GCC.

00:05:18.810 --> 00:05:21.860
You still have the same
monolithic architecture that

00:05:21.860 --> 00:05:23.800
keeps us from integrating it.

00:05:24.010 --> 00:05:26.640
So it's time to retire that GNU.

00:05:26.640 --> 00:05:30.060
We're going to send it out to Pasteur.

00:05:30.380 --> 00:05:33.470
and replace that with
the Clang front end,

00:05:33.470 --> 00:05:35.900
symbolized by this racehorse.

00:05:35.970 --> 00:05:39.320
Now we have all new
LLVM based technology.

00:05:39.370 --> 00:05:41.400
They work together really well.

00:05:41.450 --> 00:05:44.760
And this is where we're
putting all of our focus for

00:05:44.760 --> 00:05:47.000
new features in the compiler.

00:05:47.630 --> 00:05:51.280
So in this next part of the talk,
we're going to talk a bit

00:05:51.290 --> 00:05:53.830
about some of those features.

00:05:56.680 --> 00:05:59.390
One of those that we think
is really helpful that you

00:05:59.460 --> 00:06:01.940
will enjoy is diagnostics.

00:06:01.980 --> 00:06:05.760
We spend a lot of time trying
to give you error messages that

00:06:06.440 --> 00:06:10.740
make it as clear as possible
what the problem in your code is.

00:06:11.800 --> 00:06:15.530
We're going to talk about how
LLVM is integrated in Xcode,

00:06:15.530 --> 00:06:19.880
so you get the great benefits of the
LLVM compiler without having to leave

00:06:20.220 --> 00:06:23.760
the great Xcode IDE environment.

00:06:24.960 --> 00:06:26.590
We have a static analyzer.

00:06:26.670 --> 00:06:30.500
It deeply analyzes your program
to help find problems before

00:06:30.500 --> 00:06:34.100
you even realize they're there.

00:06:34.200 --> 00:06:38.080
We've got some new C++ language
features to talk about.

00:06:39.330 --> 00:06:41.820
and we've got great performance.

00:06:41.820 --> 00:06:44.370
So I want to clarify that
some of these features here

00:06:44.470 --> 00:06:46.400
have been in LLVM for a while.

00:06:46.430 --> 00:06:50.180
Some of them are brand new in
version 3 of the LLVM compiler.

00:06:50.200 --> 00:06:52.860
So we're going to go
through some of these today,

00:06:52.870 --> 00:06:56.980
and I'd like to introduce Doug Gregor,
who is our Clang technical lead,

00:06:57.110 --> 00:06:58.750
who's going to start us off.

00:07:04.240 --> 00:07:05.450
Thank you, Bob.

00:07:05.560 --> 00:07:08.470
So we're going to take a look at some of
the features of the Apple LLVM compiler

00:07:08.910 --> 00:07:10.470
powered by the Clang front end.

00:07:10.570 --> 00:07:13.800
And first we're going to look at
the user interface of the compiler,

00:07:13.850 --> 00:07:15.900
since at Apple we're all
about user interfaces.

00:07:16.030 --> 00:07:21.330
And so here's our great 1970s command
line technology for using compiler.

00:07:22.120 --> 00:07:22.500
Wow.

00:07:23.400 --> 00:07:25.520
Run the compiler,
you give it a C source file,

00:07:25.520 --> 00:07:27.240
it builds an executable.

00:07:27.260 --> 00:07:29.000
This is really boring and uninteresting.

00:07:29.000 --> 00:07:33.640
The only important part about this side
of the user interface is that we accept

00:07:33.640 --> 00:07:37.660
the same command line options as GCC.

00:07:37.820 --> 00:07:40.580
So we're backward compatible with GCC,
and this means if you

00:07:40.580 --> 00:07:44.320
have a make file project,
if you have scripts that build code

00:07:44.400 --> 00:07:48.360
just by calling the compiler directly,
just replace GCC and G++

00:07:48.360 --> 00:07:50.160
with Clang and Clang++.

00:07:50.240 --> 00:07:53.280
Command line options are the same,
we support GNU extensions,

00:07:53.290 --> 00:07:55.280
so it's drop-in compatibility.

00:07:55.390 --> 00:07:58.150
It's very easy to move from
one compiler to the other.

00:07:58.540 --> 00:08:01.000
A lot of you probably don't even
use this because you use Xcode,

00:08:01.010 --> 00:08:02.340
and that's fine.

00:08:02.420 --> 00:08:06.300
The other side of the user interface
are the compiler's diagnostics.

00:08:06.380 --> 00:08:08.530
So these you probably see every day,
right?

00:08:08.620 --> 00:08:12.570
These are the warnings and the errors
that the compiler generates when it finds

00:08:12.720 --> 00:08:14.470
some kind of problem in your source code.

00:08:14.620 --> 00:08:14.770
Right?

00:08:14.870 --> 00:08:17.490
Maybe you're not conformant
with the standard,

00:08:17.490 --> 00:08:19.860
or maybe it just found something
fishy in your source code

00:08:19.860 --> 00:08:21.180
it wants to tell you about.

00:08:21.430 --> 00:08:24.060
When it finds the problem,
it's going to try to diagnose the problem

00:08:24.060 --> 00:08:28.940
internally and explain the problem to you
in simple terms so you can understand how

00:08:28.940 --> 00:08:31.770
to fix the problem quickly and move on.

00:08:31.950 --> 00:08:36.620
Most important thing of
compiler diagnostics is clarity.

00:08:37.000 --> 00:08:41.840
Here's an example where GCC utterly
and completely fails the clarity test.

00:08:41.910 --> 00:08:43.100
It's a great error message.

00:08:43.100 --> 00:08:47.340
It tells you the parser state at the
point where something went wrong.

00:08:47.430 --> 00:08:48.820
Does that help you?

00:08:48.830 --> 00:08:49.340
I hope not.

00:08:49.420 --> 00:08:50.440
It doesn't help me either.

00:08:50.590 --> 00:08:53.350
There's only one important information,
there's only one bit of

00:08:53.420 --> 00:08:54.860
useful information here.

00:08:54.890 --> 00:08:58.780
And that is the file and the
line where the error happened.

00:08:58.810 --> 00:09:00.740
And you can go look at the
source code and figure out

00:09:00.740 --> 00:09:01.980
what the actual problem is.

00:09:02.120 --> 00:09:05.810
With the Apple LLVM compiler,
we want to do a lot better.

00:09:05.900 --> 00:09:07.420
So here we give a clear diagnostic.

00:09:07.420 --> 00:09:08.830
It says what the problem is.

00:09:09.070 --> 00:09:11.020
This webframe view type
you thought existed,

00:09:11.090 --> 00:09:11.970
it doesn't exist.

00:09:12.040 --> 00:09:14.540
There's no type by that name,
maybe because you forgot

00:09:14.540 --> 00:09:15.530
to include a header.

00:09:15.670 --> 00:09:18.860
We also show the line of source
code where the problem happens,

00:09:18.970 --> 00:09:22.060
and the little green caret points
exactly to the line and column

00:09:22.140 --> 00:09:23.500
where this problem occurred.

00:09:23.580 --> 00:09:27.180
So you look at the right part of
your source code to fix the problem.

00:09:27.230 --> 00:09:29.880
The last thing we do,
if you're actually using the terminal,

00:09:29.880 --> 00:09:34.070
you will see this coloration here,
just to try to bring your eye to the

00:09:34.180 --> 00:09:35.740
part that matters of the source code.

00:09:35.740 --> 00:09:39.430
So you can find the errors quickly,
sort through the diagnostic that you get,

00:09:39.440 --> 00:09:40.230
and fix the problem.

00:09:40.300 --> 00:09:44.890
There are a number of innovations
in the way the Apple LLVM compiler

00:09:45.050 --> 00:09:49.800
presents diagnostics to really help you
understand the problem and fix it fast.

00:09:49.910 --> 00:09:52.220
One of those is diagnostic ranges.

00:09:52.220 --> 00:09:57.820
So here we have an example where we have
some problem with the binary expression.

00:09:57.820 --> 00:10:01.820
So the subtraction operation doesn't
work because the types are wrong.

00:10:01.820 --> 00:10:04.260
So we have a text description
that shows what the problem,

00:10:04.280 --> 00:10:07.340
describes what the problem is,
but we also show you with the caret

00:10:07.470 --> 00:10:09.570
exactly which operation failed.

00:10:09.580 --> 00:10:11.180
Right, where's the problem?

00:10:11.180 --> 00:10:15.820
And it's going to highlight with
the little underlines the left and

00:10:15.820 --> 00:10:18.760
right hand sides of that operation,
so that on busy lines where

00:10:18.760 --> 00:10:21.820
you have a lot of operators,
you have a lot of operands going on,

00:10:21.820 --> 00:10:25.810
you can see exactly what the
compiler is talking about.

00:10:26.050 --> 00:10:29.250
With some diagnostics,
this is absolutely critical,

00:10:29.260 --> 00:10:32.760
because here we have a whole
ton of equal signs on the line.

00:10:32.820 --> 00:10:33.850
We don't think there's assignment.

00:10:33.930 --> 00:10:35.760
There wasn't meant to be assignment.

00:10:35.830 --> 00:10:36.330
Here it is.

00:10:36.400 --> 00:10:39.180
The compiler is going to point out,
this is the place where

00:10:39.510 --> 00:10:40.400
you made a mistake.

00:10:40.420 --> 00:10:43.160
In this case,
you used assignment instead of equality.

00:10:43.190 --> 00:10:46.230
And with that diagnostic range
information with the caret,

00:10:46.330 --> 00:10:48.970
you can find that problem very quickly.

00:10:50.450 --> 00:10:54.490
Something we introduced last
year was spell checking.

00:10:54.660 --> 00:10:56.700
So a lot of the mistakes
we make as programmers are

00:10:56.700 --> 00:10:59.600
we just mistype something,
we miscapitalize it.

00:10:59.640 --> 00:11:02.500
So here I have this little mistake
where I was a little bit lazy on

00:11:02.500 --> 00:11:05.660
the shift key when I was typing,
and I capitalized the

00:11:05.660 --> 00:11:07.390
U in NSMutableArray.

00:11:07.500 --> 00:11:11.200
The compiler could say,
"I don't know what the NSMutableArray

00:11:11.270 --> 00:11:14.670
identifier means," and leave you at that,
and you'll stare at it for a while

00:11:14.720 --> 00:11:19.240
before you realize the height of the
bars and the U is a little bit too high.

00:11:19.300 --> 00:11:21.950
Instead what it does is it
realizes you tried to name

00:11:21.950 --> 00:11:24.640
something that doesn't exist,
so it's going to look at all the names

00:11:24.640 --> 00:11:28.140
that would have made sense at that
particular point in your program.

00:11:28.190 --> 00:11:31.590
And if it finds something close,
it will suggest that something close

00:11:32.010 --> 00:11:34.680
with a spell checking diagnostic.

00:11:38.020 --> 00:11:40.310
So this year,
we've taken this a little bit

00:11:40.310 --> 00:11:42.120
further and tried to make it better.

00:11:42.120 --> 00:11:45.140
So it recognizes more
names in more places,

00:11:45.140 --> 00:11:49.220
it provides better corrections,
recovers from those corrections better,

00:11:49.260 --> 00:11:53.050
and it actually can get to the point
now where we can correct for mistyped

00:11:53.050 --> 00:11:57.550
keywords to really deal with any of the
problems that you show up in your source

00:11:57.550 --> 00:11:59.910
code that are simple typing mistakes.

00:12:00.650 --> 00:12:03.340
Now spell checking is an interesting,
different kind of

00:12:03.420 --> 00:12:05.060
diagnostic from the others.

00:12:05.180 --> 00:12:08.680
So with the previous diagnostics we saw,
the compiler told you

00:12:08.730 --> 00:12:11.550
there was a problem,
but it didn't necessarily know

00:12:11.550 --> 00:12:13.380
what kind of fix to apply here.

00:12:13.520 --> 00:12:16.940
With spell checking it says,
this is the problem and

00:12:16.940 --> 00:12:18.900
here is the solution.

00:12:19.070 --> 00:12:22.570
Fix it to take that one step further
and actually show you how the solution

00:12:22.570 --> 00:12:24.740
would look in your source code.

00:12:24.740 --> 00:12:28.450
So what we're doing here is the same
NSMutableArray example we saw earlier,

00:12:28.450 --> 00:12:30.830
where we suggest a correction.

00:12:31.250 --> 00:12:35.120
Now here in the output,
we've underlined the mistyped NSMutable

00:12:35.120 --> 00:12:39.400
array with the wrong capital U to tell
you this is the part of the code you

00:12:39.400 --> 00:12:41.100
need to change to fix the problem.

00:12:41.170 --> 00:12:45.040
And underneath in green,
we're saying this is the fix to apply.

00:12:45.160 --> 00:12:48.720
Here's the text you put up there
in replacing the underlying

00:12:49.400 --> 00:12:51.200
text to solve the problem.

00:12:51.320 --> 00:12:55.360
So fixits are really, really great,
because they find the little

00:12:55.360 --> 00:12:59.340
syntactic annoyances like dropped
open square brackets on message

00:12:59.340 --> 00:13:02.810
sends for nested message sends,
or missing semicolons at the end

00:13:02.810 --> 00:13:06.210
of an expression that you actually
wanted to turn into a statement.

00:13:06.280 --> 00:13:09.150
And fixits can really,
really help solve these little

00:13:09.150 --> 00:13:12.300
problems quickly that add up
to wasting your developer time,

00:13:12.360 --> 00:13:15.830
just to get you to the point where you
can actually build your app and test it,

00:13:16.050 --> 00:13:18.610
do the interesting part of development.

00:13:21.680 --> 00:13:23.480
So let's talk about something new.

00:13:23.560 --> 00:13:27.360
We've introduced a bunch of new
warnings into the Apple LLVM compiler,

00:13:27.400 --> 00:13:30.210
and one of the big new classes
of warnings are warnings

00:13:30.210 --> 00:13:32.330
on uninitialized variables.

00:13:32.640 --> 00:13:35.980
So here in this example,
we have some variable delta,

00:13:36.030 --> 00:13:41.240
and we have a call to transform that uses
a block that happens to refer to delta.

00:13:41.940 --> 00:13:45.060
The Apple LLVM compiler wouldn't
give any warnings on this previously.

00:13:45.110 --> 00:13:47.700
Now we can produce a warning
that describes exactly

00:13:47.700 --> 00:13:49.060
what's going wrong here.

00:13:49.090 --> 00:13:54.440
So here we have not initialized delta,
and yet we've captured in a block.

00:13:54.530 --> 00:13:58.210
So the Apple LLVM compiler will tell you
this through a warning that says delta

00:13:58.210 --> 00:14:02.570
is uninitialized at the point of capture,
and refer back to the variable

00:14:02.570 --> 00:14:04.410
delta through this extra note.

00:14:04.410 --> 00:14:06.260
We'll see these a little bit more later.

00:14:06.260 --> 00:14:09.210
Through this extra note that
points out what variable of delta

00:14:09.320 --> 00:14:12.230
is actually being referred to,
because what may have happened here is

00:14:12.230 --> 00:14:15.300
you're referring to the wrong variable,
not that it's actually an

00:14:15.360 --> 00:14:16.900
uninitialized variable.

00:14:17.600 --> 00:14:22.150
Now, with uninitialized warnings,
these were available in GCC and LLVM GCC,

00:14:22.150 --> 00:14:24.180
and have been for a long time.

00:14:24.220 --> 00:14:26.700
There's one really
annoying aspect of them,

00:14:26.720 --> 00:14:30.650
which is that they depended
on how the optimizer ran.

00:14:30.780 --> 00:14:34.860
So this means that as the optimizer found
different ways to optimize your code,

00:14:34.900 --> 00:14:36.590
you would get different
warnings out of this,

00:14:36.630 --> 00:14:38.620
which is infuriating.

00:14:38.650 --> 00:14:41.310
And more importantly,
when you did this with GCC,

00:14:41.310 --> 00:14:44.510
you wouldn't get warnings if
the optimizer wasn't turned on.

00:14:44.820 --> 00:14:47.230
So your debug builds,
the most important place

00:14:47.230 --> 00:14:49.760
to see these warnings,
you would never actually get

00:14:49.760 --> 00:14:51.050
any benefits of this warning.

00:14:51.270 --> 00:14:54.060
In the Apple LLVM compiler,
we wanted to do better,

00:14:54.110 --> 00:14:57.700
and the way we did this is to implement
these warnings in the front end,

00:14:57.700 --> 00:15:00.540
so that you get the exact
same behavior in debug mode,

00:15:00.600 --> 00:15:03.410
in release mode,
it doesn't depend on any of the

00:15:03.410 --> 00:15:05.370
back end optimization stuff.

00:15:05.620 --> 00:15:09.170
So we realize,
so with uninitialized warnings,

00:15:09.180 --> 00:15:12.470
we also realized that the
optimizer in GCC didn't always

00:15:12.590 --> 00:15:13.600
produce useful warnings.

00:15:13.620 --> 00:15:17.130
And so with the Apple LLVM compiler,
we decided to be a bit more conservative

00:15:17.130 --> 00:15:18.800
with the introduction of this.

00:15:18.800 --> 00:15:20.740
We want everyone to be able to use it.

00:15:20.880 --> 00:15:22.410
However, we didn't turn it on by default.

00:15:22.480 --> 00:15:24.750
If you want these warnings,
and we suggest that you

00:15:24.860 --> 00:15:28.280
really do want these warnings,
you can use "-w uninitialized",

00:15:28.320 --> 00:15:32.360
or "-w all", to bring in these
uninitialized variable warnings.

00:15:33.260 --> 00:15:36.920
We've also been conservative in that
we only want to diagnose warnings,

00:15:36.940 --> 00:15:40.710
diagnose unused variables,
initialized variables,

00:15:40.790 --> 00:15:44.060
in cases where the compiler
is certain there's a problem.

00:15:44.060 --> 00:15:47.500
And so, you've probably been looking at
this example for a couple seconds,

00:15:47.500 --> 00:15:51.890
is this an uninitialized variable use,
or is it not?

00:15:52.360 --> 00:15:54.870
Well, we've initialized under
this if statement.

00:15:55.000 --> 00:15:59.540
So if we should transform,
then we set delta.

00:15:59.620 --> 00:16:01.510
And then later on in the code we check,
well,

00:16:01.550 --> 00:16:04.630
should we transform and then use delta?

00:16:04.710 --> 00:16:07.100
So clearly from the
programmer's standpoint,

00:16:07.100 --> 00:16:08.030
this code is good.

00:16:08.210 --> 00:16:12.120
Should transform is going to return
the same thing twice in a row,

00:16:12.130 --> 00:16:13.010
of course.

00:16:14.360 --> 00:16:17.910
Right, so this is some kind of global
program invariant that you

00:16:18.050 --> 00:16:20.540
are thinking of in your head,
and the compiler has no idea

00:16:20.540 --> 00:16:23.060
whether this invariant holds or not.

00:16:23.160 --> 00:16:26.240
And so our way to deal with
this at this point is to say,

00:16:26.470 --> 00:16:28.800
we're not going to
diagnose this as a warning,

00:16:28.850 --> 00:16:30.960
because it's probably going
to lead to what you would

00:16:30.960 --> 00:16:33.940
consider as false positives,
something that clearly

00:16:34.140 --> 00:16:35.510
the compiler is wrong.

00:16:35.680 --> 00:16:39.400
The way we tackle this is we
added another flag called -w

00:16:39.400 --> 00:16:41.540
conditional uninitialized.

00:16:41.610 --> 00:16:44.660
And this is for people that really
want to make sure that they don't

00:16:44.670 --> 00:16:46.240
have uninitialized variables.

00:16:46.290 --> 00:16:48.890
And they want to have warnings
about this sort of case,

00:16:49.050 --> 00:16:52.610
where the compiler can't
reason about program invariants

00:16:52.620 --> 00:16:55.360
or large-scale invariants,
and they want to see that,

00:16:55.440 --> 00:16:56.530
and they're willing
to rewrite their code.

00:16:56.590 --> 00:16:59.230
So this is the more aggressive
version for people that want to

00:16:59.230 --> 00:17:00.840
deal with all of these problems.

00:17:00.890 --> 00:17:04.370
-w uninitialized should
be good for anyone at all,

00:17:04.370 --> 00:17:07.800
and we highly recommend
that you turn it on.

00:17:08.320 --> 00:17:11.100
Let's look at something
specifically for Objective-C called

00:17:11.100 --> 00:17:13.140
the InferredResultType.

00:17:13.190 --> 00:17:15.650
Take a look at this little bit of code.

00:17:16.460 --> 00:17:18.190
There's a bug here.

00:17:18.250 --> 00:17:19.620
I'm sure you've all found it by now.

00:17:19.740 --> 00:17:21.440
Yes, I hope.

00:17:22.190 --> 00:17:24.950
No compiler that we've ever shipped
has been able to diagnose this,

00:17:24.950 --> 00:17:29.450
because it doesn't understand how
these functions actually work.

00:17:29.690 --> 00:17:33.450
What we've done with the
Apple LLVM compiler version 3 is

00:17:34.320 --> 00:17:38.600
we've added some type inferencing
that allows us to detect this problem.

00:17:38.690 --> 00:17:39.310
Now this is great.

00:17:39.420 --> 00:17:43.040
You allocate an NSArray on
the right hand side.

00:17:43.040 --> 00:17:44.600
You initialize that array.

00:17:44.750 --> 00:17:47.780
Compiler now knows that that returns
an NSArray and can warn you that

00:17:48.030 --> 00:17:51.650
you just assigned it over to a
variable that thinks it's an NS set,

00:17:51.700 --> 00:17:53.600
which is a completely different class.

00:17:53.730 --> 00:17:56.600
This is a ticking time bomb in
your source code if you're allowed.

00:17:56.600 --> 00:17:58.600
Now we can actually diagnose this.

00:17:58.600 --> 00:18:01.600
The way we do it is through inference.

00:18:01.600 --> 00:18:05.810
We actually understand Cocoa conventions,
Cocoa naming conventions,

00:18:05.810 --> 00:18:09.240
within the compiler to
understand that when you send

00:18:09.240 --> 00:18:13.600
a message to alloc and init,
you get back an instance of that type.

00:18:13.600 --> 00:18:15.600
We think this will be really great.

00:18:15.600 --> 00:18:18.750
It detects a huge number of
subtle bugs that have been around

00:18:18.830 --> 00:18:20.600
for a very long time in code.

00:18:20.600 --> 00:18:23.350
We think you're going to like it.

00:18:24.420 --> 00:18:26.580
Now this is just one
advancement to Objective-C.

00:18:26.660 --> 00:18:28.360
Of course, you've also heard of Arc.

00:18:28.400 --> 00:18:30.860
And we have another session
later on this week called

00:18:30.970 --> 00:18:34.370
Objective-C Advancements in Depth,
where you can go to learn about other

00:18:34.430 --> 00:18:38.600
advances to the Objective-C language.

00:18:39.680 --> 00:18:42.390
With that,
let's move on to Xcode integration.

00:18:42.470 --> 00:18:45.750
So one of the great things about
building your compiler as a modular

00:18:45.750 --> 00:18:48.640
system is you can take some of
the components in that modular

00:18:48.660 --> 00:18:50.540
system and put them into new places.

00:18:50.640 --> 00:18:54.940
Like here we take the Clang parser
and front end and move it into Xcode

00:18:54.980 --> 00:18:57.380
to give a better user experience.

00:18:57.500 --> 00:19:02.380
First place you'll tend to see this
is in the live warnings and errors.

00:19:02.610 --> 00:19:06.150
Essentially what's happening here
is as you're typing in your editor,

00:19:06.170 --> 00:19:08.510
you're introducing new code,
and of course you're

00:19:08.520 --> 00:19:09.800
introducing new bugs.

00:19:09.800 --> 00:19:12.820
So what the compiler is going to
do is it's going to run behind the

00:19:12.820 --> 00:19:16.760
scenes to check your source code to
see if you've introduced a problem.

00:19:16.760 --> 00:19:20.400
If you have introduced a problem,
you'll get a little pop-up here.

00:19:20.400 --> 00:19:25.000
So you get the underlying under
the issue in this particular code,

00:19:25.000 --> 00:19:28.060
underlying the string literal,
and you get a little badge in the

00:19:28.060 --> 00:19:31.940
left-hand side that indicates that
the compiler has found a problem here.

00:19:31.940 --> 00:19:35.080
If you want to go solve it,
you can go click on the badge to get some

00:19:35.080 --> 00:19:38.440
information about what the problem is,
fix the problem.

00:19:38.440 --> 00:19:43.040
As soon as you fix that problem,
the warning goes away from your editor.

00:19:43.500 --> 00:19:45.980
This is actually somewhat
of a change in the workflow.

00:19:45.980 --> 00:19:48.980
We tend to write a bunch of code and then
build and see what the compiler does,

00:19:48.990 --> 00:19:51.160
and then build and see what
the compiler does again.

00:19:51.290 --> 00:19:54.120
Instead,
you can interact with the compiler here.

00:19:54.230 --> 00:19:57.670
And once you've dealt with all of
the issues that it's diagnosed,

00:19:57.690 --> 00:20:00.680
well at that point,
the file's going to compile cleanly.

00:20:00.830 --> 00:20:04.000
And you can just build and
start testing your app.

00:20:05.010 --> 00:20:07.730
So when you get one of these
live warnings or errors,

00:20:07.730 --> 00:20:10.240
you can go click on the
badge on the left hand side,

00:20:10.240 --> 00:20:12.920
and it's going to pop up
to something like this.

00:20:12.980 --> 00:20:14.800
So it'll show you what the problem is.

00:20:14.830 --> 00:20:18.050
The problem in this case is that
we have incompatible pointer types.

00:20:18.150 --> 00:20:21.870
We tried to pass a character array,
this is string literal,

00:20:21.870 --> 00:20:24.640
to something that expected an NSString.

00:20:25.110 --> 00:20:27.080
Clearly that's not going to work.

00:20:27.140 --> 00:20:29.800
Of course, this is one of those cases
that Objective-C programmers

00:20:30.260 --> 00:20:31.720
tend to make this mistake.

00:20:31.800 --> 00:20:35.230
And so the compiler actually
recognizes that this is the

00:20:35.230 --> 00:20:37.600
problem and suggests to fix it.

00:20:37.710 --> 00:20:41.950
So now you see how we've taken the fix
it feature from the compiler and surfaced

00:20:41.960 --> 00:20:44.450
it in Xcode via this little pop-up.

00:20:44.550 --> 00:20:48.590
What the pop-up suggests is the
simple correct fix to this problem,

00:20:48.590 --> 00:20:52.440
which is introduce the @ sign to
turn this C string literal into

00:20:52.440 --> 00:20:54.590
an Objective-C string literal.

00:20:54.800 --> 00:20:58.100
You just accept the fix
it by clicking on that.

00:20:58.310 --> 00:21:01.920
Your source code is updated
and the warning goes away.

00:21:05.080 --> 00:21:07.920
Fixits can solve a number of problems.

00:21:07.980 --> 00:21:10.990
So in this case, we fixed that problem,
but it turns out I introduced a bunch of

00:21:11.140 --> 00:21:14.080
bugs in my one simple logging statement.

00:21:14.120 --> 00:21:17.760
And here,
I used the wrong conversion specifier.

00:21:17.850 --> 00:21:21.560
I used %d, that's for integers,
not %f for doubles,

00:21:21.630 --> 00:21:22.920
but I had given a double.

00:21:23.070 --> 00:21:26.280
Compiler, of course, can detect this,
reports it,

00:21:26.330 --> 00:21:29.240
but it goes one step further and
actually suggests the replacement

00:21:29.420 --> 00:21:32.520
that fixes your string literal
in place so you have the right

00:21:32.590 --> 00:21:35.780
conversion specifier for using NSLog.

00:21:36.410 --> 00:21:40.310
This is way better than going and
hunting through the NSLog documentation

00:21:40.360 --> 00:21:44.280
to figure out what is the conversion
specifier I need in this particular case.

00:21:44.360 --> 00:21:46.270
Compiler knows what it is,
it can check it,

00:21:46.370 --> 00:21:50.120
it can tell you exactly how to fix
your code without doing anything else.

00:21:50.150 --> 00:21:54.080
The fixits we've seen so far, however,
have been fairly simple.

00:21:54.090 --> 00:21:59.320
When there's been a fixit to suggest,
it's been obvious what the answer was.

00:21:59.320 --> 00:22:02.800
Introduce the @ sign,
introduce a missing semicolon, whatever.

00:22:02.830 --> 00:22:05.450
Sometimes fixits aren't that simple.

00:22:05.480 --> 00:22:09.840
So here we have a case where we're
doing a test with bitwise and,

00:22:09.900 --> 00:22:14.280
and then we're doing an equality
comparison against zero.

00:22:15.440 --> 00:22:19.550
This is suspicious,
because the precedence rules for

00:22:19.550 --> 00:22:22.840
these operators in C are actually
a little bit weird and not usually

00:22:22.840 --> 00:22:25.170
up with programmers' expectations.

00:22:25.230 --> 00:22:28.420
And so in this case,
the compiler is going to warn about

00:22:28.640 --> 00:22:32.240
it and suggest two different options.

00:22:32.260 --> 00:22:37.660
Now the first option in this case
is "silence the compiler". This is

00:22:37.730 --> 00:22:41.520
the "I know what I'm doing",
this is what I meant to write,

00:22:41.520 --> 00:22:44.000
and what it's going to do is it's
going to introduce parentheses

00:22:44.450 --> 00:22:48.040
around the equality expression,
because that's what's

00:22:48.040 --> 00:22:50.760
evaluated first in this case,
I'm sure you all knew that.

00:22:50.760 --> 00:22:53.940
It's going to introduce those parentheses
to tell the compiler "this is what

00:22:54.020 --> 00:22:55.960
I meant", which silences the warning.

00:22:55.960 --> 00:22:59.280
Of course, it also tells future
programmers that look at this,

00:22:59.280 --> 00:23:02.730
"yes, this is actually what I meant,
there's no bug here". Of course,

00:23:02.760 --> 00:23:06.000
in this case,
we're trying to do a bitwise test here,

00:23:06.000 --> 00:23:08.560
and we look at the second option.

00:23:08.560 --> 00:23:11.590
The second option is going to
insert the parentheses in the other

00:23:11.700 --> 00:23:16.150
place around the first expression,
the bitwise "and", to evaluate that

00:23:16.150 --> 00:23:18.680
first and test the result against zero.

00:23:18.680 --> 00:23:22.200
This option changes the
semantics of the source code,

00:23:22.200 --> 00:23:24.840
but in this case,
it actually fixes the bug in the source

00:23:25.140 --> 00:23:27.710
code that was found by the compiler.

00:23:28.360 --> 00:23:31.750
So when you see these fix it pop up,
look through the options,

00:23:31.750 --> 00:23:34.460
decide what is the best option for you.

00:23:34.530 --> 00:23:36.740
Either way,
we will silence the compiler and

00:23:36.740 --> 00:23:41.130
move along so you can get back
to a clean editor with no issues,

00:23:41.130 --> 00:23:44.490
and your file will compile
then with no errors.

00:23:47.990 --> 00:23:52.640
So another place where we've surfaced
more information from the compiler

00:23:52.740 --> 00:23:55.660
in Xcode is the notes feature.

00:23:55.770 --> 00:23:59.320
So in previous examples,
there are a couple examples where

00:23:59.320 --> 00:24:02.540
we had some sort of warning or
error that came out of the compiler,

00:24:02.630 --> 00:24:06.750
and then there was a note that provided
additional information to tell you

00:24:06.930 --> 00:24:10.620
that that warning or that error is
actually related to something else

00:24:10.680 --> 00:24:13.300
in this other part of your source code.

00:24:13.300 --> 00:24:33.900
[Transcript missing]

00:24:34.760 --> 00:24:37.840
If you look in the issue navigator,
there's going to be this little

00:24:37.840 --> 00:24:43.080
disclosure triangle next to the
incomplete implementation issue.

00:24:43.560 --> 00:24:46.310
Select that triangle,
and now you get all the extra

00:24:46.330 --> 00:24:48.860
information the compiler is giving you.

00:24:48.900 --> 00:24:52.560
So in this case it's telling
you these three methods need

00:24:52.560 --> 00:24:55.530
to be defined somewhere.

00:24:55.890 --> 00:24:59.300
and David It's essentially a little
to-do list of what you actually

00:24:59.300 --> 00:25:00.530
need to do to fix the problem.

00:25:01.740 --> 00:25:05.300
Now if you were to go in and click
on one of those method definitions,

00:25:05.380 --> 00:25:07.900
it's going to jump to the
declaration of that method,

00:25:07.910 --> 00:25:10.730
which shows you the method that
hasn't been implemented yet,

00:25:10.840 --> 00:25:13.290
and you get the choice of either
jumping back to the implementation

00:25:13.520 --> 00:25:15.490
to go implement that method,
or realizing, hey,

00:25:15.490 --> 00:25:18.310
I don't need this method anymore,
delete it at this point.

00:25:18.540 --> 00:25:21.300
Either way, the note's going to go away,
and once you've resolved all

00:25:21.300 --> 00:25:24.030
the problems in the note,
the warning is going to go away.

00:25:24.040 --> 00:25:28.030
The last feature I want to talk
about in Xcode is code completion.

00:25:28.900 --> 00:25:33.310
So the idea here is that Xcode has
always had a code completion engine,

00:25:33.310 --> 00:25:37.370
but the compiler is really the tool
that understands your code better than

00:25:37.490 --> 00:25:39.760
any other tool on the system ever can.

00:25:41.350 --> 00:25:46.610
The compiler has to know everything about
the language that it has to compile.

00:25:46.730 --> 00:25:50.340
And so it can actually give you more
accurate completions based on its deep

00:25:50.430 --> 00:25:56.480
semantic knowledge of how the program
works and what's available at that point.

00:25:56.500 --> 00:25:59.800
So in this case,
we're doing a simple completion in a

00:25:59.800 --> 00:26:04.820
C++ or Objective C++ program that asks
for all of the entities that start

00:26:04.820 --> 00:26:07.460
with M in the standard namespace.

00:26:07.510 --> 00:26:10.680
Something we unfortunately couldn't do
with the previous code completion engine,

00:26:10.800 --> 00:26:14.090
we can do now that we use the compiler,
because the compiler

00:26:14.090 --> 00:26:15.100
understands everything.

00:26:15.130 --> 00:26:17.840
It understands class templates,
and so it can give you the map

00:26:17.840 --> 00:26:21.010
class template with placeholders
for all the template arguments.

00:26:21.120 --> 00:26:25.440
It understands function templates
like max and make tuple and so on,

00:26:25.490 --> 00:26:27.800
along with typedefs and everything else.

00:26:27.870 --> 00:26:31.870
And so you can get more
completions out of this using all

00:26:31.870 --> 00:26:34.570
of the features of the language.

00:26:35.320 --> 00:26:38.630
Now, it can even reason about
complicated things.

00:26:38.830 --> 00:26:41.700
So, this particular code looks really,
really simple.

00:26:41.700 --> 00:26:45.360
All we have is some variable i,
we apply the arrow operator,

00:26:45.450 --> 00:26:48.700
and ask for everything
starting with f there.

00:26:49.540 --> 00:26:52.330
Behind the scenes, this is not so simple.

00:26:52.520 --> 00:26:57.100
So I is actually an iterator into
one of the data structures that

00:26:57.110 --> 00:26:59.700
comes out of the standard library.

00:27:00.080 --> 00:27:01.000
What's an iterator?

00:27:01.100 --> 00:27:02.470
Well, it's a custom class.

00:27:02.570 --> 00:27:05.290
In this case, it's actually a class
template of some sort.

00:27:05.400 --> 00:27:07.710
So behind the scenes,
what the code completion engine

00:27:07.710 --> 00:27:10.520
is doing is it's understanding
all of C++ templates,

00:27:10.580 --> 00:27:13.090
understanding all of
template instantiation,

00:27:13.090 --> 00:27:14.200
how that happens.

00:27:14.260 --> 00:27:15.280
Then it gets back to a class.

00:27:15.420 --> 00:27:18.200
However, then it has to look
at the arrow operator,

00:27:18.260 --> 00:27:21.160
and it introduces the notions
of operator overloading.

00:27:21.200 --> 00:27:23.820
It understands operator overloading,
so it can see exactly

00:27:23.820 --> 00:27:26.680
through that arrow operator,
it's overloaded,

00:27:26.770 --> 00:27:29.950
and down to what the compiler would
actually see to give you the same

00:27:29.950 --> 00:27:32.560
results the compiler would see.

00:27:32.610 --> 00:27:35.800
This gives us more accurate completions,
and we can adjust the priority of

00:27:35.860 --> 00:27:40.070
completions based on information such as,
well, what's the type that you actually

00:27:40.070 --> 00:27:42.110
want to use at this particular point?

00:27:45.470 --> 00:27:46.600
With that,
we're going to look at something

00:27:46.600 --> 00:27:51.600
that's also based on the Clang
front end and integrated in Xcode.

00:27:51.600 --> 00:27:54.550
It's called the Xcode Static Analyzer.

00:27:54.750 --> 00:27:58.770
The Xcode Static Analyzer is a
really great tool that uses deep

00:27:58.770 --> 00:28:03.220
compiler analysis techniques to
find bugs in your source code.

00:28:03.290 --> 00:28:05.630
Now the Static Analyzer is interesting.

00:28:05.750 --> 00:28:10.200
So the way it works is to actually
look at all of the various paths

00:28:10.450 --> 00:28:15.290
through your program to find what
conditions would trigger a bug.

00:28:15.460 --> 00:28:18.290
So you can imagine that in
the normal path of your code,

00:28:18.290 --> 00:28:19.620
you have no problems.

00:28:19.670 --> 00:28:22.980
However,
it could be the case that if you take

00:28:23.110 --> 00:28:27.440
the if branch up here in your program,
and then a couple lines

00:28:27.550 --> 00:28:30.420
down in the function,
well, you take this else branch down

00:28:30.510 --> 00:28:34.320
here for some unrelated condition,
along just that one path,

00:28:34.430 --> 00:28:35.470
you have some sort of bug.

00:28:35.590 --> 00:28:37.860
You have a null pointer to reference.

00:28:37.890 --> 00:28:39.860
Some kind of problem.

00:28:39.900 --> 00:28:41.890
This is the kind of thing
that's hard to find in testing,

00:28:41.930 --> 00:28:44.320
because you have to have those
conditions exactly right to

00:28:44.350 --> 00:28:46.850
follow that path to hit the issue.

00:28:47.090 --> 00:28:49.540
The Static Analyzer is going
to reason about all of the

00:28:49.540 --> 00:28:49.580
problems that you have to solve.

00:28:49.580 --> 00:28:52.820
All of your paths at the same
time to see if there are problems

00:28:52.940 --> 00:28:56.760
along any of those paths,
and report those as issues.

00:28:57.390 --> 00:28:58.700
The kinds of problems it can find?

00:28:58.700 --> 00:29:00.780
Well, it can find these logic errors,
right?

00:29:00.850 --> 00:29:03.940
Null dereference problems,
where you forgot to check whether

00:29:03.940 --> 00:29:07.460
something was null before you
actually went and accessed it.

00:29:07.470 --> 00:29:09.220
It'll produce an issue for that.

00:29:09.260 --> 00:29:12.120
The static analyzer understands the APIs.

00:29:12.240 --> 00:29:17.300
It understands how core foundation works,
and the underlining Unix APIs,

00:29:17.330 --> 00:29:20.970
so it can tell you when
you're misusing those APIs.

00:29:21.330 --> 00:29:23.430
It also knows Cocoa memory conventions.

00:29:23.650 --> 00:29:26.960
It understands when things
are returned retained,

00:29:26.960 --> 00:29:28.440
when things are released.

00:29:28.470 --> 00:29:34.120
So it can detect memory leaks in your
program in a path sensitive manner.

00:29:34.860 --> 00:29:37.500
and it's better just
to see how this works.

00:29:37.500 --> 00:29:42.890
So here's an example of finding leaks
in a program using core foundation.

00:29:43.120 --> 00:29:47.200
The example here, we're creating a
CFDate with CFDate create.

00:29:47.260 --> 00:29:48.450
We do that in the first case.

00:29:48.590 --> 00:29:52.890
And then when X is not zero,
we release that date.

00:29:53.120 --> 00:29:56.980
The very end of the function,
we return this CFDate,

00:29:57.060 --> 00:29:58.830
we return something.

00:29:59.320 --> 00:30:04.520
So at this point, if you were testing it,
perhaps in all of your testing,

00:30:04.560 --> 00:30:05.390
X is non-zero.

00:30:05.450 --> 00:30:08.780
Maybe it varies widely,
but X never gets to be the value zero.

00:30:08.920 --> 00:30:11.710
You'll never see a leak in your testing.

00:30:11.780 --> 00:30:14.240
With the static analyzer,
it checks all of your paths.

00:30:14.240 --> 00:30:17.880
It realizes, well, when X is zero,

00:30:18.760 --> 00:30:21.770
We're not going to call this release,
and therefore this object

00:30:21.770 --> 00:30:23.340
is going to be leaked.

00:30:23.390 --> 00:30:26.020
And it actually shows you
this within the Xcode editor.

00:30:26.040 --> 00:30:29.420
You can see the arrows flowing from
one point of your program to another.

00:30:29.430 --> 00:30:31.910
That's describing the path
that it's taken through your

00:30:31.910 --> 00:30:33.340
program to find this bug.

00:30:33.360 --> 00:30:35.430
So it went to the CFD create.

00:30:35.500 --> 00:30:39.020
It skipped over the if statement
and went directly to the return.

00:30:39.020 --> 00:30:42.220
And this is exactly the case
under which this code leaks.

00:30:42.220 --> 00:30:46.300
The Xcode static analyzer
can also reason about loops.

00:30:46.300 --> 00:30:48.180
So in this case, we have two loops.

00:30:48.200 --> 00:30:51.730
One that initializes an array,
and another one that both reads

00:30:51.740 --> 00:30:53.960
and writes back to the array.

00:30:54.500 --> 00:30:58.050
The static analyzer here is complaining
that you're reading a garbage

00:30:58.050 --> 00:31:00.280
value when you read from the array.

00:31:00.400 --> 00:31:03.590
Well these loops, they look the same.

00:31:03.590 --> 00:31:05.400
It looks like there's no bug here.

00:31:05.570 --> 00:31:09.530
But the static analyzer has actually
realized that because you're looping

00:31:09.530 --> 00:31:11.550
over different constraints here,

00:31:12.290 --> 00:31:14.920
In the first case, we only initialize the
first three elements.

00:31:14.940 --> 00:31:17.510
In the second case,
we're reading all four of the elements.

00:31:17.680 --> 00:31:18.800
So there's a bug here.

00:31:18.890 --> 00:31:22.180
The static analyzer will describe it
to you by showing you the paths it took

00:31:22.250 --> 00:31:27.040
through the program under which you'll
actually find this bug manifesting.

00:31:28.640 --> 00:31:31.140
Static Analyzer is really a great tool.

00:31:31.210 --> 00:31:34.480
And you can use this directly
from Xcode by going to the product

00:31:34.840 --> 00:31:37.520
menu and selecting Analyze.

00:31:37.680 --> 00:31:42.640
Analyze is essentially a special
kind of build of your program.

00:31:42.660 --> 00:31:44.770
So it's essentially going
to run your entire program

00:31:45.130 --> 00:31:48.870
through the compiler again,
but this time it's going to do some

00:31:48.870 --> 00:31:53.240
detailed analysis of how your program
works and its use of the Cocoa APIs,

00:31:53.240 --> 00:31:55.360
looking for leaks,
looking for API abuses,

00:31:55.360 --> 00:31:57.000
looking for null dereferences.

00:31:57.060 --> 00:32:00.440
Now this takes more time than
just a simple build does.

00:32:00.520 --> 00:32:01.900
So there's a trade-off here.

00:32:01.980 --> 00:32:04.470
On the other hand,
it does find real bugs in your

00:32:04.490 --> 00:32:08.250
software that you want to fix
before they get into testing.

00:32:09.610 --> 00:32:12.030
When it finds those problems,
it's going to report them the

00:32:12.030 --> 00:32:13.900
same way that a compiler would.

00:32:14.000 --> 00:32:16.700
So we have warnings and errors
reported from the compiler.

00:32:16.760 --> 00:32:20.550
We also have static analyzer issues,
and these are reported both in your

00:32:20.550 --> 00:32:22.500
editor and in the issue navigator.

00:32:22.500 --> 00:32:25.500
So you can explore them,
find out what problems it

00:32:25.500 --> 00:32:27.290
found in your source code.

00:32:27.860 --> 00:32:31.080
Now if you love the static analyzer,
and I hope you all do,

00:32:31.080 --> 00:32:34.090
you can actually turn it on
every time you do a build.

00:32:34.260 --> 00:32:37.220
So you find the problems as
you introduce them before it

00:32:37.250 --> 00:32:39.400
crashes your app in testing.

00:32:39.490 --> 00:32:43.040
And here you can go into the
build settings for your project.

00:32:43.040 --> 00:32:46.150
Under the build option setting
there's run static analyzer.

00:32:46.220 --> 00:32:49.370
Just turn that on to yes,
and every time you hit build you

00:32:49.430 --> 00:32:53.710
will also get static analysis results
along with the normal warnings.

00:32:55.180 --> 00:33:01.920
Now, Static Analyzer has one new feature
this year inside Xcode for controlling

00:33:02.340 --> 00:33:04.160
specifically what checks to do.

00:33:04.270 --> 00:33:07.520
So we realized that Static Analyzer
has a bunch of different checks.

00:33:07.820 --> 00:33:10.150
Not all checks are
interesting to all people.

00:33:10.300 --> 00:33:13.810
So here you can again go into
your build settings and decide

00:33:14.230 --> 00:33:17.080
what checks are important to you,
what checks find real

00:33:17.090 --> 00:33:19.540
problems in your code,
turn just those on,

00:33:19.600 --> 00:33:22.740
and you don't have to use other
checkers that you don't like.

00:33:23.880 --> 00:33:27.190
We've done a lot of work on the
Xcode Static Analyzer this year,

00:33:27.380 --> 00:33:32.830
and one big new feature is we
have full support for analyzing

00:33:32.900 --> 00:33:36.910
C++ and Objective C++ programs.

00:33:40.260 --> 00:33:44.890
Now C++ programmers can get all the same
benefits as Objective-C programmers,

00:33:44.910 --> 00:33:46.080
and it's a good thing.

00:33:46.190 --> 00:33:52.360
So you can see here the static analyzer
running on a very large C++ application,

00:33:52.410 --> 00:33:55.840
which happens to be the
Apple LLVM compiler itself,

00:33:56.050 --> 00:33:58.310
and finding a real bug.

00:33:58.600 --> 00:34:00.850
So what's happening here is
a little bit interesting.

00:34:00.860 --> 00:34:03.300
This is the dead stores checker.

00:34:03.440 --> 00:34:07.300
And the error that the static analyzer
is giving here is that the value

00:34:07.300 --> 00:34:10.590
that you stored to S is never read.

00:34:11.170 --> 00:34:13.540
Now this is actually a
symptom of the real problem.

00:34:13.550 --> 00:34:17.100
The real problem is that we
forgot to put break in here.

00:34:17.160 --> 00:34:18.380
And that's allowed by the language.

00:34:18.380 --> 00:34:20.210
Sometimes you do want to fall through.

00:34:20.340 --> 00:34:22.780
So what the static analyzer is
doing is it's reasoning about

00:34:22.860 --> 00:34:23.940
the paths in your program.

00:34:24.010 --> 00:34:27.750
And what it realizes is that when
we jump into this case statement,

00:34:27.840 --> 00:34:31.180
we allocate a new object
and assign it over to S.

00:34:31.260 --> 00:34:32.200
That's fine.

00:34:32.360 --> 00:34:35.800
We then fall through to the next case,
which seems to be fine from

00:34:35.800 --> 00:34:37.740
the C language perspective.

00:34:37.810 --> 00:34:40.340
We allocate a new object
and assign it to S,

00:34:40.390 --> 00:34:42.900
which completely clobbers
the previous value of S.

00:34:42.900 --> 00:34:46.180
And that object that was
previously assigned to S goes away.

00:34:46.210 --> 00:34:50.090
This is almost always an indication of
something weird going on in your program.

00:34:50.260 --> 00:34:52.740
And in this case,
we found the problem introduced

00:34:52.740 --> 00:34:53.940
the additional break.

00:34:54.110 --> 00:34:56.660
So we fixed the bug.

00:34:57.110 --> 00:35:01.740
Since we're on the subject of C++, well,
let's talk about C++ a little bit more.

00:35:02.040 --> 00:35:04.690
There's a whole lot of buzz
in the C++ community about

00:35:04.780 --> 00:35:07.880
this thing we call C++ OX.

00:35:08.010 --> 00:35:12.700
So C++ OX is an upcoming
revision to the C++ standard.

00:35:12.700 --> 00:35:14.840
It's been in the C++ community
for about eight years.

00:35:14.840 --> 00:35:18.740
They've been working on it,
and they've introduced major changes to

00:35:18.740 --> 00:35:23.790
both the language side of C++ and the
standard libraries that come with it.

00:35:24.030 --> 00:35:27.080
There's a whole pile of new language
features that are great to use,

00:35:27.120 --> 00:35:30.710
and the C++ standard library has
been improved to pick up and use

00:35:30.760 --> 00:35:33.570
those language features to give
you a better library experience,

00:35:33.670 --> 00:35:36.380
and expanded with new
great functionality.

00:35:36.430 --> 00:35:40.520
Now all of this is designed to
provide great backward compatibility

00:35:40.520 --> 00:35:42.870
with your existing C++ applications.

00:35:43.320 --> 00:35:47.170
So I'm thrilled to tell you here today
that we are providing C++ OX support

00:35:47.490 --> 00:35:49.960
in the Apple LLVM compiler version 3.

00:35:50.110 --> 00:35:51.930
Yay!

00:35:54.890 --> 00:35:58.290
To get this support, again,
just go into your build settings,

00:35:58.290 --> 00:36:00.770
and we have the C++
language dialect option.

00:36:00.950 --> 00:36:05.320
You can now pick C++ OX to get
these great new C++ OX features.

00:36:05.400 --> 00:36:08.250
If you also want to
rely on GNU extensions,

00:36:08.250 --> 00:36:11.950
there's GNU++ OX,
which is all the C++ OX features,

00:36:11.950 --> 00:36:16.810
plus the GNU extensions you're probably
accustomed to using within C++.

00:36:18.020 --> 00:36:22.180
So nobody has managed to implement
all of the C++ OX language.

00:36:22.180 --> 00:36:25.620
It's actually a huge set of new features.

00:36:25.780 --> 00:36:28.050
We've done pretty well,
so we've tackled all of these

00:36:28.090 --> 00:36:30.700
features in the last year or so,
but we're not going to go into any

00:36:30.700 --> 00:36:32.740
detail in this talk about those features.

00:36:32.740 --> 00:36:35.360
If you're interested in seeing
how some of these features work,

00:36:35.360 --> 00:36:38.960
how they can be used to improve your app,
I recommend you come to the

00:36:38.960 --> 00:36:42.550
LLVM technologies in-depth
session tomorrow afternoon,

00:36:42.720 --> 00:36:46.670
where we'll tell you a bit more about
how these features actually work.

00:36:47.800 --> 00:36:51.520
Now I said that C++/OX was
both a language thing,

00:36:51.570 --> 00:36:53.490
which is covered by the
Apple LLVM compiler.

00:36:53.750 --> 00:36:57.270
It's also enhancements to
the C++ standard library.

00:36:57.560 --> 00:37:02.220
For this, we introduce completely new
LLVM C++ standard library,

00:37:02.220 --> 00:37:04.340
which we call libc++.

00:37:04.410 --> 00:37:07.300
Now this is a great new implementation
of the C++ standard library.

00:37:07.360 --> 00:37:11.710
It's been re-engineered from the
ground up with the idea of building

00:37:11.730 --> 00:37:15.490
the best library we can for C++/OX.

00:37:15.580 --> 00:37:20.750
So we use these new C++/OX features
throughout to give a better performing,

00:37:20.970 --> 00:37:25.620
easier to use standard library that
supports the entire C++/OX standard.

00:37:25.650 --> 00:37:29.540
Now since we had this opportunity to
re-engineer our C++ standard library,

00:37:29.540 --> 00:37:33.770
we could actually put to use all of
the things that we've learned from

00:37:33.780 --> 00:37:36.820
maintaining the old C++ standard library.

00:37:36.850 --> 00:37:39.560
So this new standard library
has better data structures that

00:37:39.630 --> 00:37:41.020
take less memory and are faster.

00:37:41.260 --> 00:37:44.660
It has better algorithms
that produce faster code.

00:37:44.680 --> 00:37:48.740
So that your uses of the C++
standard library will just go faster.

00:37:48.810 --> 00:37:52.180
It also introduces new functionalities
such as regular expressions,

00:37:52.200 --> 00:37:55.220
smart pointers, hash tables, threading.

00:37:55.310 --> 00:37:58.900
All of these new libraries that
came into the C++/OX standard

00:37:59.000 --> 00:38:03.660
as part of the standard library,
these are provided as part of libc++.

00:38:03.950 --> 00:38:08.470
libc++ is part of the LLVM project
and as such it's fully open source.

00:38:08.820 --> 00:38:12.740
You can go learn more information
about it at libcxx.llvm.org.

00:38:12.740 --> 00:38:12.740
And if you happen to love working on C++,
you can go to libcxx.llvm.org.

00:38:12.740 --> 00:38:12.740
And if you happen to love working on C++,
you can go learn more information

00:38:12.740 --> 00:38:12.740
about it at libcxx.llvm.org.

00:38:12.740 --> 00:38:12.770
And if you happen to love working on C++,
you can go learn more information

00:38:12.770 --> 00:38:12.870
about it at libcxx.llvm.org.

00:38:12.980 --> 00:38:15.770
And if you happen to love working
on C++ template libraries,

00:38:15.770 --> 00:38:18.100
you can even come join us.

00:38:18.100 --> 00:38:18.770
No takers?

00:38:18.980 --> 00:38:19.950
Okay.

00:38:22.870 --> 00:38:25.960
So we have better data
structures and algorithms.

00:38:26.020 --> 00:38:30.080
I want to show you one of the
coolest algorithms in libc++.

00:38:30.100 --> 00:38:32.590
And this is the sort algorithm.

00:38:33.290 --> 00:38:36.620
So here we have the sort algorithm,
and we're comparing our

00:38:36.620 --> 00:38:41.100
existing C++ standard library,
which is lib_standard_c++.

00:38:41.100 --> 00:38:42.920
You've been using it from GNU.

00:38:43.020 --> 00:38:44.640
And lib_c++.

00:38:44.850 --> 00:38:47.720
And so this performance
chart is based on time,

00:38:47.720 --> 00:38:49.240
so smaller is better.

00:38:49.360 --> 00:38:52.020
And we're showing the
variation in performance of the

00:38:52.100 --> 00:38:57.830
lib_standard_c++ sorting algorithm,
depending on how the input looks.

00:38:57.920 --> 00:38:59.940
and of course the algorithm is
going to vary because different

00:38:59.940 --> 00:39:03.790
algorithms are better for
different distributions of data.

00:39:03.900 --> 00:39:08.250
Now the libc++ approach to solving
this problem is it actually recognizes

00:39:08.370 --> 00:39:10.740
these different kinds of patterns.

00:39:10.810 --> 00:39:14.180
When the whole sequence or when
some sub-sequence of the sorted

00:39:14.250 --> 00:39:18.590
sequence fits into one of these cases,
it can use a specialized algorithm that

00:39:18.640 --> 00:39:20.840
does a better job at sorting faster.

00:39:20.880 --> 00:39:26.030
And doing so we get huge wins
in many of the common cases,

00:39:26.110 --> 00:39:29.200
many times faster than the
previous sorting algorithm.

00:39:29.250 --> 00:39:32.180
Now you notice there's one
case where we weren't faster,

00:39:32.230 --> 00:39:33.970
and that's in the random case.

00:39:34.040 --> 00:39:36.600
If there's truly random data,
there is some cost to

00:39:36.640 --> 00:39:40.080
this pattern recognition,
and we end up being a little bit slower.

00:39:40.120 --> 00:39:42.970
This is a perfectly acceptable
engineering trade-off since data

00:39:42.970 --> 00:39:45.610
that you actually get to be sorted,
it's never random.

00:39:45.720 --> 00:39:47.570
It has these substructures.

00:39:47.780 --> 00:39:50.100
We can zoom in on those,
provide a better algorithm,

00:39:50.150 --> 00:39:55.240
and give you better overall sorting
performance out of this library than

00:39:55.300 --> 00:39:57.500
we could in the previous library.

00:39:57.580 --> 00:40:02.970
So libc++ is now available in Xcode 4.2,
the same Xcode that has the new

00:40:03.060 --> 00:40:06.500
Apple LLVM compiler with C++ OX features.

00:40:06.760 --> 00:40:11.700
If you build your app against libc++,
you can deploy it to both Lion and iOS 5.

00:40:11.960 --> 00:40:16.060
Selecting the C++ standard library is now
available in the Xcode build settings.

00:40:16.130 --> 00:40:19.340
Right next to the C++ language dialect,
you can choose to use libc++.

00:40:19.390 --> 00:40:24.490
And together,
C++ OX support in the compiler

00:40:25.080 --> 00:40:29.660
and C++ OX support in the new
libc++ standard library gives an

00:40:29.690 --> 00:40:34.820
absolutely wonderful C++ OX experience
for developing applications.

00:40:35.140 --> 00:40:38.280
We're going to talk a little bit
more about libc++ in tomorrow's

00:40:38.320 --> 00:40:43.390
LLVM technologies in-depth session
in Pacific Heights in the afternoon.

00:40:45.010 --> 00:40:47.320
With that,
I'm going to turn it back over to Bob,

00:40:47.320 --> 00:40:49.200
who's going to talk about
compiler performance.

00:40:49.220 --> 00:40:50.880
Thank you very much.

00:40:55.840 --> 00:40:57.560
Thank you, Doug.

00:40:57.620 --> 00:40:59.590
So compilers are all about performance.

00:40:59.700 --> 00:41:02.980
We spend a lot of our time trying
to make sure we get two different

00:41:03.050 --> 00:41:04.100
kinds of performance for you.

00:41:04.170 --> 00:41:05.900
One, build time.

00:41:06.170 --> 00:41:11.220
We want your apps to build really fast
so you don't have to sit and wait.

00:41:11.950 --> 00:41:15.600
The second kind of performance
is the code quality.

00:41:15.730 --> 00:41:20.420
We want to optimize your apps so
that your users don't have to wait.

00:41:20.640 --> 00:41:24.720
So let's start looking at build time.

00:41:24.860 --> 00:41:33.040
This is a graph showing the build
speed in debug mode for a Mac OS app,

00:41:33.340 --> 00:41:35.990
particularly the Sketch example app.

00:41:36.130 --> 00:41:41.880
We're going to compare the build speed
with GCC against the Apple LLVM compiler.

00:41:42.020 --> 00:41:46.880
So we've defined here the
build speed of GCC is 1.

00:41:47.010 --> 00:41:49.110
Bigger bars are better.

00:41:49.680 --> 00:41:55.540
The Apple LLVM compiler builds
this app more than twice as fast.

00:41:55.630 --> 00:41:58.040
Sketch is a small example,
so you may be wondering,

00:41:58.070 --> 00:42:03.800
does this same kind of win carry
over to a really big application?

00:42:03.830 --> 00:42:07.210
I suspect most of you are
familiar with the Preview app,

00:42:07.310 --> 00:42:09.180
so let's look at that.

00:42:10.700 --> 00:42:16.600
And you see that the Apple LLVM compiler
is about twice as fast building preview.

00:42:16.750 --> 00:42:20.360
And to put that into perspective,
on my machine it takes about a minute

00:42:20.760 --> 00:42:23.000
to build preview in debug mode.

00:42:23.190 --> 00:42:29.620
So that twice as fast build time
cuts that time that I have to

00:42:29.620 --> 00:42:32.200
wait down to about 30 seconds.

00:42:32.500 --> 00:42:34.900
Instead of waiting for a minute,
I only have to wait for 30 seconds.

00:42:35.040 --> 00:42:38.500
That's a huge win and will
save you a lot of time.

00:42:39.860 --> 00:42:41.070
So that's for debug builds.

00:42:41.150 --> 00:42:42.330
What about release builds?

00:42:42.450 --> 00:42:45.260
If you're tuning performance,
you may need to be building in

00:42:45.260 --> 00:42:47.960
release mode with full optimizations.

00:42:48.190 --> 00:42:50.290
So let's look at that.

00:42:50.900 --> 00:42:54.420
This graph is going to show
build time in release mode,

00:42:54.500 --> 00:42:56.240
this time for iOS.

00:42:56.450 --> 00:43:00.590
We've taken five industry
standard spec benchmarks,

00:43:00.770 --> 00:43:03.420
Again,
we're comparing build speed against GCC.

00:43:03.450 --> 00:43:06.770
So GCC has a build speed of 1.

00:43:07.630 --> 00:43:11.490
Bigger bars are better,
and the Apple LLVM compiler is faster

00:43:11.650 --> 00:43:14.190
across the board on these apps.

00:43:15.080 --> 00:43:19.650
And in fact, it's typical to get build
speeds two to three times faster

00:43:19.960 --> 00:43:21.940
with the Apple LLVM compiler.

00:43:21.940 --> 00:43:26.000
Again, saving you time while
you're building your app.

00:43:26.870 --> 00:43:30.900
So the other kind of performance
that I mentioned is not build time,

00:43:30.900 --> 00:43:33.160
but the quality of the
code that we generate,

00:43:33.160 --> 00:43:35.690
so that your apps will run fast.

00:43:37.830 --> 00:43:41.770
Looking at those same
five standard benchmarks,

00:43:41.770 --> 00:43:46.150
again running on iOS,
comparing against GCC,

00:43:46.150 --> 00:43:51.280
we're getting speed ups from
11% all the way up to 26% on

00:43:51.280 --> 00:43:54.150
these same five applications.

00:43:54.280 --> 00:43:56.190
This is huge.

00:43:56.590 --> 00:44:00.410
This is free performance for your apps,
if they're anything

00:44:00.510 --> 00:44:01.700
like these benchmarks.

00:44:01.830 --> 00:44:05.460
And all you need to do to get
this performance is to switch your

00:44:05.550 --> 00:44:08.380
compiler to the Apple LLVM compiler.

00:44:08.500 --> 00:44:11.770
So I want to zoom in for
a minute on one area where

00:44:11.830 --> 00:44:17.210
performance really matters a lot,
and that is media applications.

00:44:17.550 --> 00:44:20.910
In most cases,
if you have some sort of high

00:44:20.910 --> 00:44:24.700
performance media computation,
it's best to use one of

00:44:24.740 --> 00:44:26.500
the standard frameworks.

00:44:26.620 --> 00:44:29.340
Sometimes you need more custom code.

00:44:29.400 --> 00:44:32.920
You need to do something that
isn't supported directly.

00:44:33.310 --> 00:44:37.300
One option that's available to you
now with the Apple LLVM compiler

00:44:37.420 --> 00:44:39.600
is to vectorize your code.

00:44:39.680 --> 00:44:43.200
I have an example up here
to show how we can do this.

00:44:43.390 --> 00:44:48.960
This is just a toy example I made
up where we're going to iterate

00:44:48.960 --> 00:44:51.310
through two arrays of vectors.

00:44:52.050 --> 00:44:56.100
and multiply them and then
accumulate the result.

00:44:56.170 --> 00:44:59.850
So the syntax that we're using here,
if you're familiar with OpenCL,

00:44:59.850 --> 00:45:03.480
it should look familiar because
this is the same syntax used for

00:45:03.590 --> 00:45:05.820
vector programming with OpenCL.

00:45:05.860 --> 00:45:08.580
There's a set of predefined types.

00:45:08.600 --> 00:45:15.320
Int32 by 4, for example,
is a vector of four 32-bit integers.

00:45:15.350 --> 00:45:19.320
You can initialize those
directly in your code.

00:45:20.210 --> 00:45:26.370
And you can apply standard
C operators to those vector types.

00:45:27.500 --> 00:45:31.890
So the neon vector unit in
ARM processors has a very powerful

00:45:31.950 --> 00:45:38.340
set of instructions that can do much
more than these standard C operators.

00:45:38.450 --> 00:45:43.010
What if you want to access some
of those more esoteric functions?

00:45:43.470 --> 00:45:46.640
We have a solution for that as well.

00:45:46.660 --> 00:45:51.220
There's a standard set of intrinsics
defined by ARM to be used for

00:45:51.220 --> 00:45:53.570
programming the neon vector unit.

00:45:53.870 --> 00:45:57.530
This example here I've taken
from an IDCT transform.

00:45:57.710 --> 00:45:59.160
This is real code.

00:45:59.260 --> 00:46:02.880
This is something that would be
used when displaying a JPEG image.

00:46:02.950 --> 00:46:06.950
I'm not going to go into all of it,
but that first function call

00:46:07.000 --> 00:46:10.880
there is doing a saturating,
rounding, doubling, multiply,

00:46:10.890 --> 00:46:13.530
returning the high half
of each vector element.

00:46:13.690 --> 00:46:15.750
You just can't write that in C very well.

00:46:16.000 --> 00:46:17.780
So you write it as a function call.

00:46:17.860 --> 00:46:20.750
The compiler is smart enough to
recognize this is an intrinsic,

00:46:20.900 --> 00:46:25.740
and it's going to compile that down to
a single instruction in your program.

00:46:25.770 --> 00:46:28.410
So you can get great performance.

00:46:29.720 --> 00:46:31.540
Obviously,
if you're going to go to the effort

00:46:31.760 --> 00:46:35.280
of rewriting your code like this,
you want to make sure that it's

00:46:35.280 --> 00:46:37.700
worthwhile and that it really pays off.

00:46:37.700 --> 00:46:39.440
So let's look at what we get.

00:46:39.690 --> 00:46:44.600
This graph is again going to
compare performance of GCC against

00:46:44.600 --> 00:46:46.700
the Apple LLVM compiler.

00:46:46.700 --> 00:46:50.700
I want to point out the
scale here is not percentage.

00:46:50.700 --> 00:46:53.690
This is how many times faster.

00:46:54.180 --> 00:46:58.560
The first benchmark, Galaxy,
is simulating the gravitational

00:46:58.680 --> 00:47:01.900
fields within a galaxy of stars.

00:47:02.030 --> 00:47:07.220
GCC is defined by a rate of one.

00:47:07.250 --> 00:47:13.040
And the Apple LLVM compiler is about
four times faster running this app.

00:47:13.060 --> 00:47:17.980
IDCT, this is the same transformation
I mentioned in the example

00:47:17.980 --> 00:47:19.590
from the previous slide.

00:47:20.950 --> 00:47:24.150
Here we see the Apple LLVM compiler
generates code that

00:47:24.240 --> 00:47:27.360
runs seven times faster.

00:47:28.460 --> 00:47:29.530
BigMult.

00:47:29.530 --> 00:47:33.450
This is doing multiplication of very,
very large integers.

00:47:33.600 --> 00:47:37.890
This is typically used in
public key cryptography.

00:47:40.020 --> 00:47:45.330
The LLVM compiler generates code
that is about 21 times faster.

00:47:50.560 --> 00:47:54.720
So we're pleased to announce we
have all this great support for

00:47:54.720 --> 00:47:57.980
vector programming on iOS now.

00:48:00.900 --> 00:48:05.350
So I hope we've convinced you,
looking at some of these features,

00:48:05.660 --> 00:48:10.240
that the LLVM compiler would be
a great option for you to use.

00:48:10.290 --> 00:48:13.550
And if you're thinking
about switching to use it,

00:48:13.660 --> 00:48:17.150
what do you have to do in
your code to make use of it?

00:48:17.600 --> 00:48:20.800
The good news is,
usually you don't have to do anything.

00:48:20.800 --> 00:48:22.710
It just works.

00:48:23.000 --> 00:48:24.900
But it is a different compiler.

00:48:25.100 --> 00:48:28.400
There's a few cases that you
may run into occasionally.

00:48:28.460 --> 00:48:30.780
So we're going to take a little
bit of time today to go through

00:48:30.790 --> 00:48:33.330
some of the more common cases.

00:48:34.820 --> 00:48:38.690
Doug talked about the great warnings
that we get in the LLVM compiler.

00:48:38.850 --> 00:48:42.180
Generally, that's a good thing,
but if you're like me,

00:48:42.230 --> 00:48:46.380
you like to get your project
to build with no warnings.

00:48:46.410 --> 00:48:49.580
And so you're getting new
warnings you didn't get before.

00:48:49.620 --> 00:48:51.620
How do you turn them off?

00:48:51.670 --> 00:48:53.520
Here's an example.

00:48:53.610 --> 00:48:55.680
This is a simple function I made up.

00:48:55.790 --> 00:48:57.510
It's got an unused argument.

00:48:57.660 --> 00:48:59.310
Typically,
this happens when you've got some

00:48:59.410 --> 00:49:04.120
conditional code that's turned off,
and the compiler is warning about it.

00:49:04.380 --> 00:49:09.240
So the programmer has gone in
here and added a dummy use of the

00:49:09.240 --> 00:49:12.840
argument to tell the compiler,
"I know it's unused.

00:49:12.970 --> 00:49:16.460
Don't warn me about it." And with GCC,
that works.

00:49:16.470 --> 00:49:20.140
It will not warn because now it says,
"Ah, this argument is used."

00:49:20.150 --> 00:49:23.790
The Apple LLVM compiler
doesn't fall for that trick.

00:49:24.180 --> 00:49:27.910
It says, well, the argument is used,
but that expression you put in,

00:49:28.120 --> 00:49:30.040
that's not used.

00:49:30.910 --> 00:49:35.760
So the first solution in any kind of
thing like this is to fix your code.

00:49:35.780 --> 00:49:39.360
And in this case,
we can just insert a void

00:49:39.360 --> 00:49:43.190
cast to tell the compiler,
yeah, I know, I really meant it,

00:49:43.190 --> 00:49:44.680
it's not used.

00:49:45.830 --> 00:49:49.800
Another option, if you notice at the end
of that warning message,

00:49:49.800 --> 00:49:56.670
it's showing you the exact warning
option that controls the message.

00:49:58.210 --> 00:50:01.490
And so what you can do is
to disable that warning,

00:50:01.640 --> 00:50:04.910
either in Xcode or on the command line.

00:50:04.920 --> 00:50:11.760
You can insert a no in there and make w
no unused value and just turn that off.

00:50:11.810 --> 00:50:15.340
And we tell you exactly which
option you need to turn off.

00:50:15.770 --> 00:50:18.820
What if you find this
to be a useful warning,

00:50:18.820 --> 00:50:21.910
but there's some piece of code,
maybe it's from a third party,

00:50:21.920 --> 00:50:27.790
or something you don't want to change,
but you still want the warning?

00:50:28.820 --> 00:50:30.940
And we have a solution for that as well.

00:50:31.090 --> 00:50:33.770
You can put pragmas around this code.

00:50:33.790 --> 00:50:35.450
This is the same example.

00:50:35.570 --> 00:50:37.940
You see the warning from Xcode.

00:50:38.030 --> 00:50:43.290
If you put a diagnostic push pragma
at the beginning of a region,

00:50:43.290 --> 00:50:46.130
and then a pop diagnostic
at the end of the region,

00:50:46.130 --> 00:50:49.600
within that region you can change
the settings for diagnostics.

00:50:49.600 --> 00:50:54.610
In particular here,
we add this diagnostic ignored pragma

00:50:54.920 --> 00:50:58.390
to say ignore the unused value warning.

00:51:01.810 --> 00:51:06.630
Another difference between the
LLVM compiler and GCC is in

00:51:06.640 --> 00:51:08.840
terms of the default language.

00:51:08.870 --> 00:51:13.700
GCC defaults to the
C89 language standard.

00:51:13.820 --> 00:51:19.970
The Apple LLVM compiler defaults to C99,
so now we're only one decade behind.

00:51:21.410 --> 00:51:24.090
And in particular,
this shows up often with

00:51:24.090 --> 00:51:26.070
inline function semantics.

00:51:26.210 --> 00:51:32.300
GCC, I'm sorry, C89 does not define a
feature for inline functions.

00:51:32.480 --> 00:51:36.500
But there is an extension
in GCC to do that.

00:51:36.680 --> 00:51:41.880
And unfortunately,
that extension from GCC conflicts with

00:51:42.080 --> 00:51:45.680
the way C99 defines inline functions.

00:51:46.200 --> 00:51:47.000
Here's an example.

00:51:47.000 --> 00:51:52.330
It's a simple minimum function
where if you compile this with GCC,

00:51:52.400 --> 00:51:53.330
it may work fine.

00:51:53.540 --> 00:51:56.680
You switch to the LLVM compiler,
and you get this scary-looking

00:51:56.690 --> 00:51:58.180
warning from the linker.

00:51:58.220 --> 00:52:04.800
And the issue here is that sometimes an
inline function in C99 is not actually

00:52:04.820 --> 00:52:09.580
emitted out into the object file,
so the linker can't find a definition.

00:52:10.740 --> 00:52:14.730
And the best solution for you in
cases like this is to switch your

00:52:15.060 --> 00:52:17.640
code to use static inline functions.

00:52:17.960 --> 00:52:22.140
The good thing about static inline is
that it behaves exactly the same between

00:52:22.140 --> 00:52:29.040
GCC and the LLVM compiler and C99,
so you'll also get more portable code.

00:52:30.860 --> 00:52:34.780
Here's another GCC extension
that may cause problems for you.

00:52:34.820 --> 00:52:39.060
C, the language,
has a feature of variable length arrays.

00:52:39.280 --> 00:52:41.300
C++ does not.

00:52:41.830 --> 00:52:44.900
But GCC lets you do it anyways.

00:52:45.180 --> 00:52:50.320
So what we do with the LLVM compiler
is to allow you to use variable

00:52:50.320 --> 00:52:56.360
length arrays in C++ as long as those
are arrays of plain old data types,

00:52:56.500 --> 00:52:57.650
pod types.

00:52:57.800 --> 00:53:00.630
If you're not familiar with those,
a plain old data type is

00:53:00.630 --> 00:53:02.180
something like an integer.

00:53:02.230 --> 00:53:08.770
Anything with a complicated constructor
or destructor would not be a pod type.

00:53:11.300 --> 00:53:16.690
So if you see an error message
like this from the LLVM compiler,

00:53:16.700 --> 00:53:22.000
the best thing to do is to change your
code to use a standard C++ container,

00:53:22.000 --> 00:53:25.470
like a vector,
instead of the variable length array.

00:53:26.980 --> 00:53:31.700
Another C++ issue relates
to name lookup semantics.

00:53:31.740 --> 00:53:33.100
Here's an example.

00:53:33.220 --> 00:53:36.830
It's a template class for a stack.

00:53:36.830 --> 00:53:40.970
And then we then instantiate the
stack with integer types using a

00:53:40.970 --> 00:53:43.100
standard vector to implement that.

00:53:43.210 --> 00:53:46.090
And with GCC, this would work fine.

00:53:46.420 --> 00:53:49.310
With the LLVM compiler, you get an error.

00:53:49.500 --> 00:53:50.440
What's going on?

00:53:50.560 --> 00:53:54.110
The issue here is that GCC does
not correctly implement

00:53:54.380 --> 00:53:55.900
the C++ language standard.

00:53:56.240 --> 00:54:01.590
And it's complaining because that
pushback identifier is undeclared.

00:54:01.900 --> 00:54:06.370
The problem is that at the point
where the template is defined,

00:54:06.400 --> 00:54:10.210
the language standard says
you can't see that identifier.

00:54:10.300 --> 00:54:12.100
I'm not going to go into
all the details on that,

00:54:12.240 --> 00:54:15.840
but the important point is that
the LLVM compiler shows you

00:54:15.840 --> 00:54:20.120
exactly where the problem is,
and it shows you how to fix it.

00:54:20.210 --> 00:54:28.290
If you insert that "this" reference,
where it tells you, the error goes away.

00:54:29.020 --> 00:54:32.640
If you run into that,
just apply the fixits and

00:54:32.670 --> 00:54:34.940
you'll have more portable code.

00:54:34.940 --> 00:54:38.020
Besides moving to the LLVM compiler,
you may also want to move to

00:54:38.030 --> 00:54:39.480
automatic reference counting.

00:54:39.590 --> 00:54:42.400
You've heard a lot about
that at the conference.

00:54:42.400 --> 00:54:46.300
What we're going to recommend
as a first step for that is that

00:54:46.300 --> 00:54:50.320
you switch to the LLVM compiler
and clean up all your warnings.

00:54:50.320 --> 00:54:56.260
And the reason for that is that
warnings in non-ARC mode often

00:54:56.260 --> 00:54:59.840
become errors in ARC mode.

00:54:59.870 --> 00:55:03.260
In order to implement ARC,
we formalized a lot of best

00:55:03.440 --> 00:55:05.880
practices in Objective-C code.

00:55:05.940 --> 00:55:08.740
If you'd like to learn more about that,
I'll give another reference to

00:55:08.740 --> 00:55:12.560
the Objective-C Advancements
in-depth talk on Friday morning.

00:55:16.160 --> 00:55:20.630
So those are some tips for transitioning
your code to the LLVM compiler.

00:55:20.630 --> 00:55:23.460
And hopefully you're all
eager to go out and try it.

00:55:23.620 --> 00:55:25.950
And you're wondering,
what do you need to do?

00:55:28.610 --> 00:55:33.760
You need to get Xcode 4.1 or 4.2.

00:55:33.840 --> 00:55:35.580
We recommend using those versions.

00:55:35.760 --> 00:55:40.120
And here in the build settings,
you can select your compiler.

00:55:40.120 --> 00:55:43.970
If you go to the build settings,
you can search for compiler.

00:55:44.130 --> 00:55:48.600
You'll find this compiler setting and
switch to the Apple LLVM compiler.

00:55:48.600 --> 00:55:53.170
You'll see here, it's showing in the
screenshot version 2.1.

00:55:53.340 --> 00:55:54.040
What's up with that?

00:55:54.130 --> 00:55:56.420
We were talking about version 3.

00:55:56.440 --> 00:56:02.980
Xcode 4.1 is shipping with version
2.1 of the Apple LLVM compiler.

00:56:03.000 --> 00:56:06.450
This is basically a bug fix
release of the compiler.

00:56:06.640 --> 00:56:09.120
We've added the W uninitialized option.

00:56:09.140 --> 00:56:12.380
There's better C++ standard conformance.

00:56:12.420 --> 00:56:16.300
But otherwise, this is not where we're
putting the new features.

00:56:16.400 --> 00:56:18.770
To get all the new features,

00:56:19.120 --> 00:56:23.030
You'll want to move to Xcode 4.2,
where we have version

00:56:23.210 --> 00:56:25.990
3 of the LLVM compiler,
with support for automatic

00:56:25.990 --> 00:56:27.000
reference counting.

00:56:27.070 --> 00:56:32.060
One feature we didn't mention here today
is that this version of the compiler

00:56:32.070 --> 00:56:34.800
will support GCOV code coverage testing.

00:56:39.700 --> 00:56:42.640
We've got all the new
C++/OX features that Doug described,

00:56:42.670 --> 00:56:44.910
and also better code generation.

00:56:44.990 --> 00:56:48.200
If you'd like to learn more
about the better code generation,

00:56:48.200 --> 00:56:52.360
come to the LLVM Technologies in-depth
talk tomorrow afternoon.

00:56:52.360 --> 00:56:55.000
We'll have a lot of
good information there.

00:56:55.000 --> 00:56:57.760
So to summarize,
we've got two releases coming up.

00:56:57.760 --> 00:57:00.720
As shown by the highlights here,
in Xcode 4.1,

00:57:00.720 --> 00:57:03.220
the default compiler is LLVM GCC.

00:57:03.220 --> 00:57:06.840
In Xcode 4.2,
the default becomes the LLVM compiler.

00:57:08.240 --> 00:57:10.380
And there's one more change.

00:57:11.050 --> 00:57:13.170
In 4.2, GCC is going away.

00:57:13.170 --> 00:57:16.950
So what this means for you is
that if you're still using GCC,

00:57:16.950 --> 00:57:20.430
this is the time to try out
one of the other compilers.

00:57:20.430 --> 00:57:22.820
Let us know if there's any problems.

00:57:22.920 --> 00:57:25.140
We'll be in the lab this afternoon.

00:57:25.240 --> 00:57:26.590
Come by, try it out.

00:57:26.670 --> 00:57:30.390
And if you find anything that
you really can't get to work,

00:57:30.580 --> 00:57:31.590
please file bugs.

00:57:31.670 --> 00:57:34.050
Let us know about your issues.

00:57:34.840 --> 00:57:38.290
So the Apple LLVM compiler is the
future for Apple in compilers.

00:57:38.290 --> 00:57:41.160
We're putting all of our
development work there.

00:57:41.160 --> 00:57:44.810
It helps you find bugs in your
code with good diagnostics,

00:57:44.810 --> 00:57:46.370
the static analyzer.

00:57:46.370 --> 00:57:47.870
It gives you great performance.

00:57:47.930 --> 00:57:52.510
And we ask that you switch your
apps today or as soon as you can.

00:57:54.300 --> 00:57:56.710
If you'd like more
information or pointers,

00:57:56.780 --> 00:58:00.900
I refer you to Michael Jurowicz,
our developer tools evangelist.

00:58:01.080 --> 00:58:04.400
You can also visit the
LLVM project online.

00:58:04.490 --> 00:58:08.730
And if you do find issues
related to moving away from GCC,

00:58:08.730 --> 00:58:12.300
file bugs:
developer.apple.com/bugreporter.

00:58:12.410 --> 00:58:15.920
And I suspect you'll find some
good tips on transitioning in

00:58:15.920 --> 00:58:17.870
the Apple Developer Forums.

00:58:18.830 --> 00:58:22.720
There's two related sessions:
LLVM Technologies in Depth,

00:58:22.760 --> 00:58:24.500
tomorrow afternoon at 2:00.

00:58:24.630 --> 00:58:28.550
Objective C Advancements in Depth,
Friday morning.
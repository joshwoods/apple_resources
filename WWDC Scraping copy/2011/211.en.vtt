WEBVTT

00:00:22.330 --> 00:00:25.190
Welcome to WWDC.

00:00:25.400 --> 00:00:27.850
Before I start,
let me ask for a show of hands.

00:00:27.930 --> 00:00:31.680
How many people are here
in a Bonjour networking

00:00:31.680 --> 00:00:34.100
presentation for the first time?

00:00:35.550 --> 00:00:38.500
Wow, that's two-thirds of the room.

00:00:38.500 --> 00:00:39.900
It's amazing.

00:00:39.900 --> 00:00:42.980
It's great to see all the new faces here.

00:00:44.310 --> 00:00:48.040
What we're going to talk about today,
I'm going to cover some of the

00:00:48.040 --> 00:00:49.600
history of how we got to here.

00:00:49.600 --> 00:00:54.410
This is the 10th year we've been doing
a Bonjour networking presentation

00:00:54.420 --> 00:00:55.640
at the Apple Developer Conference.

00:00:55.660 --> 00:00:58.790
For those of you who are new,
I'm going to give some

00:00:58.790 --> 00:01:02.400
background about what Bonjour is,
what it does for you,

00:01:02.400 --> 00:01:05.930
the platforms that are
available for you to use it on,

00:01:05.930 --> 00:01:12.060
and the basic APIs it provides that
you can use in your applications.

00:01:12.940 --> 00:01:15.910
And then we'll dive into more
detail about the specifics of

00:01:15.910 --> 00:01:17.660
those APIs and how to use them.

00:01:22.030 --> 00:01:28.740
So this is how we get to be here today
at the 10th WWDC Bonjour presentation.

00:01:28.740 --> 00:01:35.780
Back in the 1970s, we had TCP/IP,
and in the '80s,

00:01:35.910 --> 00:01:39.300
we had AppleTalk and NetWare, IPX, and

00:01:39.570 --> 00:01:42.440
NetBIOS on DOS and Windows machines.

00:01:42.550 --> 00:01:45.700
There were lots of different
protocols all competing.

00:01:45.840 --> 00:01:50.520
But by the late '90s,
it was clear that TCP/IP had won,

00:01:50.520 --> 00:01:54.990
and all of the other protocols
were fading into obscurity.

00:01:55.020 --> 00:01:58.700
But protocols like AppleTalk had
good ease-of-use properties that

00:01:58.780 --> 00:02:00.800
IP really didn't have at the time.

00:02:00.930 --> 00:02:04.380
And towards the end of the '90s,
there were some discussions on some

00:02:04.390 --> 00:02:08.790
mailing lists about transplanting
some of the good features of

00:02:08.900 --> 00:02:11.100
things like AppleTalk onto IP.

00:02:11.100 --> 00:02:16.160
In 1999, the IETF formed the
Zero Configuration Working Group,

00:02:16.430 --> 00:02:20.140
and a couple of years later,
Apple announced that we would

00:02:20.140 --> 00:02:24.640
be building products using these
zero-configuration technologies.

00:02:25.220 --> 00:02:29.400
Very shortly after that,
the first Bonjour printers started

00:02:29.410 --> 00:02:33.400
shipping because the printer
makers had acutely felt the

00:02:33.400 --> 00:02:36.200
difficulties with ease of use on IP.

00:02:36.200 --> 00:02:40.680
Desktop publishing in the 80s and
early 90s was one of Apple's strengths,

00:02:40.680 --> 00:02:44.260
and everybody knew you just plug
a laser writer into the network,

00:02:44.340 --> 00:02:46.230
and you look in the chooser,
and there it is, and you pick it,

00:02:46.230 --> 00:02:46.830
and you print.

00:02:48.400 --> 00:02:50.900
But IP printers were
much harder to set up.

00:02:50.950 --> 00:02:53.440
I know some people at a
Silicon Valley startup.

00:02:53.440 --> 00:02:57.480
These were smart people with
masters and PhDs in computer science

00:02:57.570 --> 00:03:00.990
doing a Silicon Valley startup,
and they bought this fancy,

00:03:00.990 --> 00:03:05.400
top-of-the-line HP printer, double-sided,
staple-in-the-corner, collating,

00:03:05.400 --> 00:03:07.260
thing the size of a refrigerator.

00:03:07.320 --> 00:03:08.880
Plug it into the network.

00:03:08.880 --> 00:03:11.200
The Mac users just
pick it in the chooser,

00:03:11.200 --> 00:03:12.680
and they're printing.

00:03:13.120 --> 00:03:16.890
After three days of struggling,
they put it back in the box and returned

00:03:16.960 --> 00:03:21.780
it to Fry's because they couldn't get it
to print from Windows or Linux over IP.

00:03:21.780 --> 00:03:24.300
Something was messed
up with the settings.

00:03:24.300 --> 00:03:26.970
They pressed the reset button,
which was supposed to turn

00:03:26.990 --> 00:03:28.410
it back to factory defaults.

00:03:28.410 --> 00:03:30.780
It didn't for some reason,
and they just gave up.

00:03:30.850 --> 00:03:33.100
And I told this story
to some HP executives,

00:03:33.100 --> 00:03:35.260
and they kind of hung
their heads and said,

00:03:35.260 --> 00:03:36.180
yes, we know.

00:03:38.920 --> 00:03:42.200
So,
the printer makers were really acutely

00:03:42.200 --> 00:03:46.640
aware that they were going to be killed
with product returns and support costs

00:03:46.640 --> 00:03:50.310
if they couldn't make IP networking
as easy to use as AppleTalk was.

00:03:52.670 --> 00:03:57.640
Moving forwards in time,
in 2005 we added Wide Area Bonjour to the

00:03:57.640 --> 00:04:00.910
Link Local Bonjour we had before that.

00:04:01.140 --> 00:04:06.860
When the iPhone launched, it had the same
Bonjour APIs that Mac OS X did.

00:04:06.860 --> 00:04:10.950
In Mac OS 10.6,
we added the Bonjour sleep proxy,

00:04:11.070 --> 00:04:12.650
which I will tell you a
little bit more about.

00:04:12.690 --> 00:04:17.460
And that brings us to today,
our 10th presentation.

00:04:19.910 --> 00:04:23.560
So this is what the world
looked like in 1990.

00:04:23.600 --> 00:04:25.920
At the physical layer,
there were lots of different

00:04:25.920 --> 00:04:28.860
ways you could physically connect
your computer to other devices.

00:04:28.860 --> 00:04:32.110
There were serial ports,
there were parallel ports,

00:04:32.240 --> 00:04:36.400
there were networking protocols
like Ethernet and Token Ring.

00:04:36.400 --> 00:04:39.470
So there was a lot of confusion.

00:04:39.480 --> 00:04:42.030
If you were making a product,
it really wasn't clear what to use,

00:04:42.030 --> 00:04:44.480
or maybe you had to do all of them,
but that was expensive.

00:04:44.500 --> 00:04:50.060
And at the software and protocol level,
there were all these different protocols.

00:04:50.320 --> 00:04:54.990
Well, today,
we all know the way things have gone.

00:04:56.440 --> 00:04:59.820
TCP/IP is really the only credible
networking protocol that you

00:04:59.820 --> 00:05:01.340
would think of using today.

00:05:01.340 --> 00:05:04.680
And if you're building
a device like a laptop,

00:05:04.790 --> 00:05:08.390
it's pretty clear that what you put
on it is Ethernet or Wi-Fi or both,

00:05:08.440 --> 00:05:11.250
but you're not going to put
a token ring interface on.

00:05:11.270 --> 00:05:14.360
And this is good for all of us because
now when you show up in a hotel room,

00:05:14.360 --> 00:05:16.680
you know they're going
to have an Ethernet jack,

00:05:16.680 --> 00:05:19.300
not a token ring jack in the hotel room.

00:05:19.300 --> 00:05:23.680
So standardization frees us from those
silly standards battles and lets us get

00:05:23.760 --> 00:05:25.690
on with making really great products.

00:05:28.740 --> 00:05:33.490
So let's dive down a bit
deeper into how TCP/IP works.

00:05:33.580 --> 00:05:36.320
We've got different physical
layers at the bottom.

00:05:36.460 --> 00:05:41.440
We've got the IP protocol layer,
which is the waste of the hourglass.

00:05:41.440 --> 00:05:45.600
On top of that, we have transport
protocols like TCP and UDP.

00:05:45.600 --> 00:05:48.730
And then running on top of TCP,
we have connection-based

00:05:48.890 --> 00:05:51.360
protocols like web browsing,
email, SSH.

00:05:51.360 --> 00:05:54.680
And on UDP,
we have more real-time applications

00:05:54.680 --> 00:05:59.890
and packet-oriented communications
like Skype and FaceTime.

00:06:01.780 --> 00:06:06.020
An essential part of
the IP stack is DHCP,

00:06:06.120 --> 00:06:13.320
which is what auto-configures your
device with its IP address here at WWDC.

00:06:13.380 --> 00:06:15.760
That is also built on top of UDP.

00:06:15.840 --> 00:06:20.410
We have the domain name system
for looking up addresses,

00:06:20.410 --> 00:06:23.180
translating names to addresses.

00:06:23.470 --> 00:06:26.010
That's also built on UDP.

00:06:26.250 --> 00:06:29.180
Well, this is great,
and this is the state of the world

00:06:29.180 --> 00:06:31.500
as it was maybe about 10 years ago.

00:06:31.500 --> 00:06:36.950
And if you plugged your laptop
computer into a well-managed network,

00:06:36.970 --> 00:06:39.340
it would auto-configure
and you'd get an address,

00:06:39.340 --> 00:06:40.340
and that's great.

00:06:40.420 --> 00:06:43.770
But with AppleTalk,
you didn't need the administrator

00:06:43.800 --> 00:06:45.720
to set up the network for you.

00:06:45.720 --> 00:06:49.510
You could literally take two Macs and
an Ethernet wire and plug them together,

00:06:49.510 --> 00:06:51.520
and you had a functioning network.

00:06:52.400 --> 00:06:57.240
So we wanted that same
bulletproof reliability on IP.

00:06:57.240 --> 00:07:04.640
So what we added in addition to DHCP was
self-assigned link local addresses.

00:07:04.640 --> 00:07:09.650
And the way that works is that
if your Mac or iPhone or iPad

00:07:09.750 --> 00:07:13.250
doesn't find a DHCP server,
then instead of just

00:07:13.250 --> 00:07:17.260
giving up and failing,
then it picks a random address in the

00:07:17.260 --> 00:07:22.170
range 169.254 and sends an ARP request.

00:07:22.200 --> 00:07:25.360
And if some other device answers,
then you pick a different

00:07:25.360 --> 00:07:26.770
address and try again.

00:07:26.800 --> 00:07:29.550
Very simple,
just like what AppleTalk did.

00:07:31.710 --> 00:07:35.320
So, not really rocket science,
not inventing anything new,

00:07:35.330 --> 00:07:36.800
but it brings that capability to IP.

00:07:36.910 --> 00:07:39.500
This has been around for a long time now.

00:07:39.500 --> 00:07:43.470
It was even in Mac OS 9 and Windows 98,
so by now everybody should

00:07:43.470 --> 00:07:44.550
be familiar with that.

00:07:44.580 --> 00:07:46.630
And of course,
IPv6 also has self-assigned

00:07:46.630 --> 00:07:48.180
link local addressing,
too.

00:07:49.780 --> 00:07:53.190
In the naming world, if you don't want to
be typing IP addresses,

00:07:53.190 --> 00:07:56.500
you particularly don't want
to be typing IPv6 addresses,

00:07:56.620 --> 00:07:58.200
you need to be able to look up names.

00:07:58.200 --> 00:08:00.800
And a similar situation applies.

00:08:00.820 --> 00:08:07.800
DNS is great if you have a
DNS server set up and run properly.

00:08:07.800 --> 00:08:11.720
But for most home users,
that's more hassle than they want.

00:08:11.740 --> 00:08:14.080
So we added multicast DNS.

00:08:16.190 --> 00:08:18.980
And just like LinkLocal is
not competing with DHCP,

00:08:18.980 --> 00:08:21.190
this is not competing
with conventional DNS.

00:08:21.260 --> 00:08:23.160
Conventional DNS is still invaluable.

00:08:23.160 --> 00:08:26.760
But for communications
on the same local link,

00:08:26.780 --> 00:08:30.560
when you don't have DNS,
this gives you a way to use

00:08:30.560 --> 00:08:34.770
DNS names in your applications,
in your user interface,

00:08:34.770 --> 00:08:37.350
in the normal way that the user expects.

00:08:37.360 --> 00:08:41.350
Except instead of sending the
queries to a specific server,

00:08:41.450 --> 00:08:45.580
they're multicast on the network
to all of your local peers.

00:08:45.620 --> 00:08:48.610
And every device on the network
runs a little piece of software

00:08:48.730 --> 00:08:50.640
called the multicast DNS responder.

00:08:50.640 --> 00:08:53.350
And when it sees a
query for its own name,

00:08:53.350 --> 00:08:58.090
then it says, hey, that's me,
and it sends back a standard DNS format

00:08:58.090 --> 00:09:03.180
reply using the standard syntax,
standard packet format, standard names,

00:09:03.180 --> 00:09:04.500
and record types.

00:09:04.500 --> 00:09:07.330
Except the query came in over multicast.

00:09:07.360 --> 00:09:09.290
Now this is great.

00:09:09.380 --> 00:09:13.300
When we add these two things to IP,
we've got ourselves to feature

00:09:13.300 --> 00:09:15.360
parity with traditional IPs.

00:09:15.620 --> 00:09:19.490
And what I mean by that is if you
know what name to type and you type it

00:09:19.620 --> 00:09:23.070
correctly and you don't make a mistake,
then it will work.

00:09:23.240 --> 00:09:26.210
But if it doesn't work,
you don't really know why

00:09:26.210 --> 00:09:27.700
or what to do about it.

00:09:27.780 --> 00:09:31.590
And Apple talk didn't make you
type in the name of the printer.

00:09:31.600 --> 00:09:33.740
It let you pick it from
a list in the chooser.

00:09:33.740 --> 00:09:36.000
So we wanted the same thing for IP.

00:09:36.000 --> 00:09:41.480
And that is DNS-based service discovery,
which is a way of using

00:09:41.480 --> 00:09:45.280
standard DNS records,
types PTR, SRV.

00:09:45.660 --> 00:09:46.170
And TXT.

00:09:46.310 --> 00:09:51.500
And structuring those records in a
way to facilitate service discovery.

00:09:51.500 --> 00:09:56.660
And that runs on top of the
DNS infrastructure below.

00:09:56.660 --> 00:10:00.940
And by that I mean it can run on
multicast DNS on the local link,

00:10:01.060 --> 00:10:05.300
or it can run using standard
wide area unicast DNS queries.

00:10:05.300 --> 00:10:07.480
And that's what gives
us wide area Bonjour.

00:10:07.480 --> 00:10:08.670
Thank you.

00:10:11.190 --> 00:10:13.620
So here's the summary.

00:10:13.620 --> 00:10:18.220
These are the three legs of
zero-configuration networking that you

00:10:18.220 --> 00:10:21.700
will want to build into your products
if you're making a hardware product.

00:10:21.850 --> 00:10:25.090
You want link-local addressing,
so you're not dependent on

00:10:25.090 --> 00:10:26.700
an external DHCP server.

00:10:26.880 --> 00:10:30.090
You want multicast DNS for name lookup,
so you're not dependent

00:10:30.090 --> 00:10:31.660
on an external DNS server.

00:10:31.750 --> 00:10:36.170
And you want DNS service discovery,
so that the user can discover your device

00:10:36.280 --> 00:10:38.610
instead of having to type the name in.

00:10:38.860 --> 00:10:43.180
This is all available as open
source from Apple and from other

00:10:43.180 --> 00:10:47.370
independent implementations as well,
so there's plenty to pick from here.

00:10:48.950 --> 00:10:50.360
So what does that give us today?

00:10:50.370 --> 00:10:55.480
Well, lots of devices running Bonjour.

00:10:55.480 --> 00:10:58.120
You can discover printers and scanners.

00:10:58.120 --> 00:11:03.780
You can discover Apple devices like
the Apple TV for AirPlay streaming

00:11:03.780 --> 00:11:07.990
or your AirPort Base Station for
setting it up with AirPort Utility.

00:11:08.080 --> 00:11:12.080
You can discover network cameras.

00:11:12.080 --> 00:11:13.660
TiVos use Bonjour.

00:11:13.660 --> 00:11:17.850
If any of you in the room have
a TiVo and you haven't got the

00:11:17.850 --> 00:11:21.020
TiVo remote app for the iPad,
download it now.

00:11:21.020 --> 00:11:24.260
It is an absolutely wonderful
way of managing your TiVo.

00:11:24.260 --> 00:11:26.240
It's much,
much better than doing it with the

00:11:26.240 --> 00:11:28.380
standard remote on the television screen.

00:11:28.380 --> 00:11:31.850
It uses the power of the
multi-touch interface on the iPad

00:11:31.850 --> 00:11:35.770
and having a big touchscreen right
in your lap to give you a much,

00:11:35.770 --> 00:11:37.920
much better user experience.

00:11:37.920 --> 00:11:42.080
it's done the normal up, down, left,
right on a remote control.

00:11:43.060 --> 00:11:46.480
And of course,
Macs and iPads and iPhones are also

00:11:46.540 --> 00:11:49.460
devices you can discover using Bonjour.

00:11:51.190 --> 00:11:54.840
For you as developers,
what platforms are supported?

00:11:54.870 --> 00:11:59.780
Well, obviously,
Mac OS X machines have the Bonjour APIs,

00:11:59.870 --> 00:12:04.420
and Linux and Windows have
the same Bonjour APIs.

00:12:04.540 --> 00:12:09.650
If you use Apple's open-source
cross-platform MNNS responder code,

00:12:09.650 --> 00:12:13.960
there are also third-party
implementations.

00:12:14.020 --> 00:12:17.560
And of course,
mobile devices like iPhones and iPads

00:12:17.560 --> 00:12:20.600
and Android phones also support Bonjour.

00:12:23.050 --> 00:12:28.180
Here are some of the ways that we
have used Bonjour in Apple products.

00:12:28.360 --> 00:12:30.360
When I go to IETF meetings
three times a year,

00:12:30.440 --> 00:12:34.280
they normally have a printer set up
in the terminal room in case people

00:12:34.280 --> 00:12:36.560
need to print out things on paper.

00:12:36.560 --> 00:12:39.930
And next to the printer is
a stack of printouts with

00:12:39.930 --> 00:12:44.740
instructions how to configure
your Windows machine for printing.

00:12:45.370 --> 00:12:47.660
And next to that is a
single sheet of paper.

00:12:47.660 --> 00:12:48.770
They don't bother printing a stack.

00:12:48.840 --> 00:12:49.700
They just have one there.

00:12:49.710 --> 00:12:51.700
How to configure your Mac for printing?

00:12:51.700 --> 00:12:54.680
And the answer is,
select Print on the File menu,

00:12:54.690 --> 00:12:58.240
and the ITF printer will already
be there in the dialog box,

00:12:58.240 --> 00:13:00.530
and you select it, and you print.

00:13:00.600 --> 00:13:03.210
There is no step two.

00:13:06.190 --> 00:13:12.500
In the Finder in Lion,
we have two things that use Bonjour.

00:13:12.500 --> 00:13:17.850
We have finding local AFP servers
on the network around you,

00:13:17.860 --> 00:13:21.080
which you already have
seen in 10.5 and 10.6.

00:13:21.080 --> 00:13:26.130
Also new in Lion is AirDrop.

00:13:28.210 --> 00:13:32.430
In iTunes,
iTunes uses Bonjour to discover shared

00:13:32.720 --> 00:13:37.890
music around you on the network,
and it also uses Bonjour to

00:13:37.930 --> 00:13:42.980
discover AirPlay devices that
you can play your media to.

00:13:44.780 --> 00:13:49.340
In Safari, there's the Bonjour menu
in the bookmarks list,

00:13:49.460 --> 00:13:53.620
which shows you a list of what it
discovers on the network around you.

00:13:53.620 --> 00:13:57.690
If you have a network printer,
they almost all have a web

00:13:57.690 --> 00:14:01.520
page for checking the ink
levels and managing them,

00:14:01.520 --> 00:14:04.880
and you don't need to
know the name to type in.

00:14:04.960 --> 00:14:07.660
You can discover that in Safari.

00:14:09.790 --> 00:14:14.750
Safari also supports wide-area Bonjour,
so it can discover things that are

00:14:14.750 --> 00:14:18.990
being advertised through conventional
DNS that aren't on the local network.

00:14:19.060 --> 00:14:23.650
So if you haven't looked at this already,
take a look in Safari and

00:14:23.650 --> 00:14:27.870
look in Bonjour,
and you should see the WWDC developer

00:14:27.870 --> 00:14:30.780
information page appearing there.

00:14:30.820 --> 00:14:32.750
So if you forget the URL,
it doesn't matter,

00:14:32.750 --> 00:14:35.270
because you can just find it
in Bonjour and click on it.

00:14:38.640 --> 00:14:42.940
Bonjour in iChat is great
for events like this.

00:14:42.980 --> 00:14:46.290
There may be people around you in
the room that you know by reputation.

00:14:46.290 --> 00:14:49.740
You've seen their
postings on mailing lists,

00:14:49.740 --> 00:14:52.000
but you've never met them in person.

00:14:52.000 --> 00:14:53.880
They're not friends who
are in your buddy list.

00:14:53.920 --> 00:14:57.200
Well, in the Bonjour buddy list,
it shows you people who are

00:14:57.200 --> 00:15:00.390
around you on the same network,
and it can be a great way to bump

00:15:00.760 --> 00:15:03.900
into people at conferences like
this and chat with them and say

00:15:03.900 --> 00:15:05.770
hello and arrange to get lunch.

00:15:08.060 --> 00:15:12.930
Time Machine, of course,
uses Bonjour to find the Time Capsule,

00:15:13.370 --> 00:15:17.310
probably the easiest remote network
backup system I've ever seen.

00:15:17.390 --> 00:15:20.990
It takes a couple of clicks and
you're backing up over the network.

00:15:21.760 --> 00:15:26.080
And this is one of my favorites
for a kind of perverse reason.

00:15:26.080 --> 00:15:30.800
The terminal, if you think about it,
is emulating one of those old 110-board

00:15:30.800 --> 00:15:36.100
data dynamics teletypes from the 1960s,
the things with the big roll of paper

00:15:36.100 --> 00:15:38.910
spilling out over the back as it prints.

00:15:39.270 --> 00:15:41.500
And the terminal is emulating that.

00:15:41.580 --> 00:15:45.640
In a sense, it's the oldest DNA in OS X.

00:15:45.680 --> 00:15:49.580
And when the terminal engineers
added Bonjour browsing to it,

00:15:49.690 --> 00:15:54.610
it really took me by surprise that even
something so ancient can benefit from

00:15:54.740 --> 00:16:00.040
using Bonjour Service Discovery to find
the SSH and Telnet and other services

00:16:00.040 --> 00:16:03.450
that are available on your local network.

00:16:06.180 --> 00:16:08.020
So all of that is about ease of use.

00:16:08.020 --> 00:16:13.380
In 10.6,
there was a new big feature of Bonjour,

00:16:13.380 --> 00:16:15.040
and that was the sleep proxy.

00:16:15.040 --> 00:16:19.920
Because we have all these
new products that we offer.

00:16:19.920 --> 00:16:22.680
We offer BacksMyMac that lets
you get to your machine at

00:16:22.680 --> 00:16:25.440
home and do screen sharing,
but not if it's asleep.

00:16:25.560 --> 00:16:30.050
We have USB printer sharing that lets
you share your printer from your iMac,

00:16:30.050 --> 00:16:31.570
but not if it's asleep.

00:16:31.630 --> 00:16:37.020
We have Apple TV accessing your
content off your iTunes music library,

00:16:37.020 --> 00:16:38.880
but not if it's asleep.

00:16:38.940 --> 00:16:41.040
So on the one hand,
people want to put their

00:16:41.130 --> 00:16:42.840
machines to sleep to save power.

00:16:42.840 --> 00:16:45.360
On the other hand,
we're offering all these great

00:16:45.360 --> 00:16:49.110
network services that encourage you
to not put your machine to sleep.

00:16:49.160 --> 00:16:53.790
And we recognize the tension in this,
so we produced the Bonjour sleep proxy.

00:16:54.830 --> 00:16:57.230
And the way that works is when
your machine goes to sleep,

00:16:57.320 --> 00:17:01.950
it finds a proxy on the network,
transfers its Bonjour records

00:17:02.020 --> 00:17:04.760
to that proxy,
because those records are a really

00:17:04.760 --> 00:17:08.020
nice compact description of the
machine's role on the network.

00:17:08.040 --> 00:17:12.000
They give its name, its address,
what ports it's listening on,

00:17:12.000 --> 00:17:16.520
what services it's offering,
and it can ship that across the network.

00:17:16.540 --> 00:17:19.660
The proxy then will then
answer Bonjour queries on

00:17:19.840 --> 00:17:24.290
behalf of the sleeping machine,
and when somebody tries to connect to it,

00:17:24.540 --> 00:17:28.080
the proxy will wake the
machine up on demand.

00:17:28.680 --> 00:17:30.830
One of the things that's
sometimes a little disappointing

00:17:30.840 --> 00:17:34.640
working in networking is
that when you do the job right,

00:17:34.690 --> 00:17:36.210
no one notices.

00:17:37.220 --> 00:17:40.700
When things are broken,
they're quick to complain about it.

00:17:40.700 --> 00:17:42.890
But when it's working right,
it's completely invisible

00:17:43.000 --> 00:17:43.990
if you do a good job.

00:17:44.030 --> 00:17:45.570
And this is one of those.

00:17:45.600 --> 00:17:48.370
After this shipped,
several of my friends asked me,

00:17:48.460 --> 00:17:49.430
what did you do in the last year?

00:17:49.580 --> 00:17:50.740
And I said, I did the sleep proxy.

00:17:50.740 --> 00:17:51.630
And they said, what?

00:17:51.660 --> 00:17:52.560
And I described it.

00:17:52.590 --> 00:17:54.090
And they said, that's really cool.

00:17:54.160 --> 00:17:54.910
How can I get it?

00:17:54.910 --> 00:17:56.720
And I said, well, you've already got it.

00:17:56.800 --> 00:17:59.540
And they didn't even notice.

00:17:59.560 --> 00:18:03.390
I notice because I developed
this software originally

00:18:03.390 --> 00:18:05.460
on my old Quad G5 at home.

00:18:05.460 --> 00:18:08.640
My Mac Mini was the proxy and
the Quad G5 was the client.

00:18:08.640 --> 00:18:12.110
And that thing takes so much power
that when it wakes up from sleep,

00:18:12.110 --> 00:18:13.820
it makes the lights flicker.

00:18:13.840 --> 00:18:18.670
If I left that on 24 hours a day,
it would cost me $1,000 a year in

00:18:18.670 --> 00:18:20.970
electricity to power that beast.

00:18:22.710 --> 00:18:26.600
So when I'm sitting on the
sofa on my laptop and I print

00:18:26.630 --> 00:18:29.720
something and I hit enter,
as I hit enter,

00:18:29.720 --> 00:18:32.920
I hear the relays click on
the G5 and the lights flicker.

00:18:32.930 --> 00:18:35.390
And every time it does that, I think, oh,
that's cool.

00:18:35.390 --> 00:18:36.160
I invented that.

00:18:39.110 --> 00:18:42.330
But for most of you,
the iMac doesn't make any sound,

00:18:42.330 --> 00:18:45.750
its screen doesn't light up,
it just wakes up, prints the job,

00:18:45.810 --> 00:18:46.670
and goes back to sleep.

00:18:46.740 --> 00:18:49.250
And you go and pick up your
printout off the printer,

00:18:49.250 --> 00:18:51.780
and you give no thought to
the minor miracle that just

00:18:51.780 --> 00:18:53.640
happened to make that possible.

00:19:02.100 --> 00:19:05.310
And of course,
we make wide use of Bonjour in

00:19:05.330 --> 00:19:06.980
iOS devices as well.

00:19:07.150 --> 00:19:12.720
We have it for AirPrint.

00:19:12.720 --> 00:19:15.500
We have it for AirPlay.

00:19:15.540 --> 00:19:19.920
We use Bonjour for home
sharing to access your music.

00:19:20.020 --> 00:19:23.960
And the Apple TV remote control
app uses Bonjour to discover

00:19:24.380 --> 00:19:26.940
the Apple TVs it's controlling.

00:19:26.940 --> 00:19:29.900
So that's great for Apple, but

00:19:30.410 --> 00:19:33.310
You guys are here because
you make apps as well.

00:19:33.610 --> 00:19:35.930
So what about your app?

00:19:35.930 --> 00:19:35.930
Well,

00:19:36.810 --> 00:19:39.740
We're giving this presentation
today because we don't want you

00:19:39.740 --> 00:19:44.140
to make apps that look like this,
typing in addresses and port numbers

00:19:44.140 --> 00:19:47.000
and lots of manual configuration.

00:19:49.400 --> 00:19:52.290
So, let's get down to the details.

00:19:52.450 --> 00:19:57.420
What do you do to add
Bonjour to your application?

00:19:58.020 --> 00:20:00.660
The link local addressing is automatic.

00:20:00.710 --> 00:20:01.730
That's handled by the OS.

00:20:01.760 --> 00:20:04.600
Unless you're building a hardware device,
you don't need to worry about that.

00:20:04.710 --> 00:20:06.290
The multicast DNS is automatic.

00:20:06.300 --> 00:20:07.330
That's handled by the OS.

00:20:07.400 --> 00:20:12.130
The area where Bonjour interacts
with your apps is through the three

00:20:12.370 --> 00:20:17.710
APIs that we provide for the three
basic Bonjour operations—Register,

00:20:17.710 --> 00:20:19.630
Browse, and Resolve.

00:20:21.110 --> 00:20:25.480
Registering is when you have a device
that's offering a service on the network,

00:20:25.480 --> 00:20:29.920
say Apple TV, which is offering AirPlay.

00:20:29.920 --> 00:20:34.320
When you power that on,
it advertises its service on the network,

00:20:34.350 --> 00:20:38.860
and it sends out a couple of announcement
packets just in case somebody was

00:20:38.860 --> 00:20:41.550
waiting for that Apple TV to come online.

00:20:42.340 --> 00:20:45.910
A common misperception is that
Bonjour works by continually

00:20:45.910 --> 00:20:49.180
broadcasting packets on the network,
and it doesn't at all.

00:20:49.180 --> 00:20:51.640
We put a lot of work into
making it very efficient.

00:20:51.640 --> 00:20:53.860
So on power on,
the device will send a few

00:20:54.160 --> 00:20:57.300
packets to announce its presence,
but after that it shuts up

00:20:57.390 --> 00:20:59.260
and it doesn't send any more.

00:20:59.260 --> 00:21:03.360
Now let's suppose you come
into my house with your iPad,

00:21:03.360 --> 00:21:06.420
and you want to show me some pictures.

00:21:06.420 --> 00:21:10.160
So you want to browse to
discover what AirPlay services

00:21:10.340 --> 00:21:12.260
are available in my house.

00:21:12.340 --> 00:21:13.670
House.

00:21:13.880 --> 00:21:17.120
The iPad sends out a
multicast query saying,

00:21:17.150 --> 00:21:21.580
"Who supports AirPlay?" And the
Apple TV sees that and says,

00:21:21.620 --> 00:21:24.160
"Oh,
I should answer that question." And each

00:21:24.160 --> 00:21:29.460
device on the network that can answer
that question sends back its replies.

00:21:29.510 --> 00:21:32.670
And the iPad collects those replies,
and you see a list of

00:21:32.670 --> 00:21:34.790
AirPlay services on the network.

00:21:35.230 --> 00:21:38.940
Notice in the browsing operation,
there were no IP addresses.

00:21:39.060 --> 00:21:41.810
It is just getting a list of names.

00:21:41.940 --> 00:21:45.030
And that's very intentional
that we've made service

00:21:45.110 --> 00:21:48.270
discovery a two-step process,
and Rory will talk more later

00:21:48.270 --> 00:21:49.470
about why that's important.

00:21:49.470 --> 00:21:52.500
The browsing is very lightweight,
it just gets a list of names.

00:21:52.500 --> 00:21:56.560
When the user picks a device
they want to use and taps on it,

00:21:56.560 --> 00:22:00.210
the second step happens,
which is the iPad sends out

00:22:00.220 --> 00:22:04.270
another multicast query and says,
okay, that's nice,

00:22:04.360 --> 00:22:08.220
I want to use your service now,
tell me how to connect to it.

00:22:08.740 --> 00:22:12.370
And the result of the resolve
call is the IP address,

00:22:12.370 --> 00:22:16.170
the port number,
additional text record information

00:22:16.180 --> 00:22:18.170
that some services need.

00:22:19.800 --> 00:22:21.860
And this is done at time of use.

00:22:21.900 --> 00:22:24.370
And that's very important,
because in a dynamic world of

00:22:24.480 --> 00:22:27.760
DHCP and linked local addresses,
IP addresses can change.

00:22:27.760 --> 00:22:31.690
Names are the stable identifiers,
but IP addresses are not.

00:22:31.880 --> 00:22:35.500
So you save the resolve
until connection time.

00:22:37.250 --> 00:22:40.260
For those of you who are
interested in the lower-level

00:22:40.260 --> 00:22:43.310
details of what's going on,
I will explain how this is

00:22:43.320 --> 00:22:44.660
done with multicast DNS.

00:22:44.660 --> 00:22:49.660
And these are standard DNS queries that
you can—you can do these to unicast

00:22:49.800 --> 00:22:54.350
DNS servers just using the DIG or the
NSLOOKUP command on the command line.

00:22:54.460 --> 00:22:58.460
The first query in this example—let's
suppose we're looking for things

00:22:58.460 --> 00:23:02.180
that implement IPP internet printing.

00:23:02.640 --> 00:23:08.790
We send out a PTR query saying,
"Who supports this service type,

00:23:08.790 --> 00:23:12.600
IPP.TCP?" And we get
back a list of answers.

00:23:12.860 --> 00:23:16.730
And the first label of those
answers is the rich text name

00:23:16.730 --> 00:23:18.980
that you display to the user.

00:23:20.110 --> 00:23:23.190
DNS names traditionally have
been all lowercase digits,

00:23:23.190 --> 00:23:24.960
no punctuation, no spaces.

00:23:24.960 --> 00:23:28.350
And these are stored in the DNS,
but they're not host names.

00:23:28.440 --> 00:23:29.590
They're not typed by users.

00:23:29.590 --> 00:23:33.570
So you're free to use
whatever rich text you want,

00:23:33.570 --> 00:23:38.720
punctuation, spaces,
even UTF-8 non-Roman characters.

00:23:41.460 --> 00:23:44.790
Looking at that name,
it's worth investigating a bit more.

00:23:44.820 --> 00:23:45.850
It's a structured name.

00:23:45.900 --> 00:23:47.340
It contains three parts.

00:23:47.570 --> 00:23:51.400
It contains the user-visible name,
it contains the service type,

00:23:51.400 --> 00:23:54.920
which is a unique identifier for the
type of operation that's being performed,

00:23:54.920 --> 00:23:58.210
and it contains the domain,
which in this case is local,

00:23:58.210 --> 00:23:59.960
meaning use multicast DNS.

00:23:59.960 --> 00:24:04.810
But it could be anything else,
like apple.com,

00:24:04.810 --> 00:24:07.760
which would mean use wide-area
Bonjour and standard DNS queries.

00:24:09.410 --> 00:24:13.150
When you developers produce
applications that offer

00:24:13.150 --> 00:24:17.440
services or browse for services,
choosing the service type

00:24:17.570 --> 00:24:22.290
is an important decision,
so I want to go over that a little bit.

00:24:23.430 --> 00:24:25.700
A service type identifies two things.

00:24:25.700 --> 00:24:30.500
It identifies what the service does,
for example printing, but it also has to

00:24:30.500 --> 00:24:31.830
identify how it does it.

00:24:32.480 --> 00:24:37.970
Because for a client to use a service,
two things have got to match.

00:24:37.970 --> 00:24:39.780
The service has got to
do what the client wants,

00:24:39.880 --> 00:24:41.740
but it's also got to do it
with a protocol that the

00:24:41.740 --> 00:24:43.060
client knows how to speak.

00:24:45.270 --> 00:24:48.460
If I discover an IPP printer,
but I only have an LPR client,

00:24:48.610 --> 00:24:50.780
that's not helpful at the software level.

00:24:50.780 --> 00:24:54.150
It may be helpful at a human level to
say there's a printer there I can't use,

00:24:54.270 --> 00:24:57.180
but from the software perspective,
the software wants to find

00:24:57.180 --> 00:24:58.700
the services it can talk to.

00:24:59.260 --> 00:25:01.350
So I'll give a couple of examples.

00:25:01.360 --> 00:25:07.170
iTunes music sharing
is basically HTTP GET.

00:25:07.900 --> 00:25:09.760
But that doesn't mean it's a web browser.

00:25:09.760 --> 00:25:14.480
So if iTunes was browsing for HTTP,
it would discover the configuration

00:25:14.560 --> 00:25:17.160
page for your printer,
which is not very helpful.

00:25:17.160 --> 00:25:20.340
And Safari would discover
your iTunes music collection,

00:25:20.460 --> 00:25:24.260
which is not very helpful because
they're not web pages it can view.

00:25:26.320 --> 00:25:30.430
So the service type for
music sharing is DAAP,

00:25:30.510 --> 00:25:32.280
Digital Audio Access Protocol.

00:25:32.280 --> 00:25:36.350
So even though it is syntactically
looks like HTTP on the wire,

00:25:36.490 --> 00:25:40.160
it's semantically being used
for a different purpose.

00:25:40.160 --> 00:25:43.880
So when you pick a service type name,
bear that in mind.

00:25:45.080 --> 00:25:48.420
And for development,
you can use whatever string you like,

00:25:48.450 --> 00:25:52.430
but before you ship your product,
please register it because that's how

00:25:52.430 --> 00:25:54.560
you ensure there are no conflicts.

00:25:55.700 --> 00:25:58.420
So imagine some Android developer
who knows nothing about iTunes

00:25:58.530 --> 00:26:01.290
picks DAAP for their game.

00:26:01.290 --> 00:26:05.650
Well, now they're going to accidentally
discover iTunes services on the network,

00:26:05.650 --> 00:26:06.980
which is not helpful.

00:26:06.980 --> 00:26:08.660
So it doesn't cost anything.

00:26:08.660 --> 00:26:13.070
It's very easy just to send in an email
and register your unique service types.

00:26:15.000 --> 00:26:19.630
And then the final step,
what happens when we found those list

00:26:19.630 --> 00:26:21.120
of names when we want to connect?

00:26:21.270 --> 00:26:23.080
Well, those are two more DNS queries.

00:26:23.080 --> 00:26:26.320
There's an SRV query and a text query.

00:26:26.320 --> 00:26:29.390
And the SRV query gives
us the port number,

00:26:29.470 --> 00:26:36.220
in this case, IPP services on port 631,
and the host name is myprinter.local.

00:26:36.220 --> 00:26:38.800
The text record gives us
additional key value pairs.

00:26:38.800 --> 00:26:41.170
In this case,
it tells us that the printer supports

00:26:41.190 --> 00:26:43.450
the PostScript page description language.

00:26:44.830 --> 00:26:48.530
And through the magic of DNS,
the server included an

00:26:48.530 --> 00:26:51.060
additional record in the reply.

00:26:51.060 --> 00:26:53.940
We didn't ask for the
address of myprinter.local,

00:26:54.020 --> 00:26:56.980
but it knows that we're probably
going to need that next.

00:26:56.980 --> 00:26:59.170
So rather than make us do
another round trip to fetch it,

00:26:59.170 --> 00:27:00.740
it adds that additional record in.

00:27:03.900 --> 00:27:10.420
So that's how you can use Bonjour,
and I want to show you a product

00:27:10.420 --> 00:27:17.410
that does it so you can see how
this improves the ease of use.

00:27:19.380 --> 00:27:22.960
This is a network camera made by Axis.

00:27:23.110 --> 00:27:26.080
They're one of the biggest
sellers of network cameras,

00:27:26.080 --> 00:27:27.930
and they're not cheap,
so I guess that means people

00:27:27.930 --> 00:27:29.330
are willing to pay for quality.

00:27:29.330 --> 00:27:31.940
And of course, it supports Bonjour.

00:27:35.670 --> 00:27:39.830
If you guys have ever tried
setting up network cameras at home,

00:27:39.900 --> 00:27:44.790
you know that it can be—you better budget
a Saturday afternoon for struggling with

00:27:44.790 --> 00:27:46.270
this thing to get it on the network.

00:27:46.340 --> 00:27:49.160
Well, with Bonjour,
I'm going to run an app

00:27:49.200 --> 00:27:53.820
here called ZeroConf Spy,
which will browse for Bonjour services.

00:27:57.200 --> 00:28:03.790
And we've discovered the camera,
and it is telling Safari to open it.

00:28:05.400 --> 00:28:11.800
[Transcript missing]

00:28:12.760 --> 00:28:15.100
And if you've tried setting
up a network camera yourself,

00:28:15.210 --> 00:28:17.810
you'll know it normally
takes longer than that.

00:28:25.570 --> 00:28:27.670
Some of you will have seen
the Axis camera before.

00:28:27.750 --> 00:28:30.540
I have a new thing to show you this year.

00:28:30.540 --> 00:28:32.900
We don't have time to do a
demo with this one as well,

00:28:32.900 --> 00:28:36.610
but I'm glad to see that there
are more Bonjour-enabled network

00:28:36.610 --> 00:28:38.660
cameras coming onto the market.

00:28:38.660 --> 00:28:41.240
This is from a company called Stem.

00:28:41.240 --> 00:28:45.930
They have a nice little
iPhone and iPad app,

00:28:45.930 --> 00:28:50.410
so it becomes sort of an IP baby monitor.

00:28:50.740 --> 00:28:53.560
And that should be in the shops soon.

00:28:53.560 --> 00:28:55.300
I don't think they've
announced the release date yet,

00:28:55.320 --> 00:28:56.490
but very soon.

00:28:56.490 --> 00:29:00.080
And with that,
I would like to ask my colleague,

00:29:00.080 --> 00:29:03.240
Roary McGuire,
to come up on stage and tell you more

00:29:03.250 --> 00:29:05.670
of some of the programming details.

00:29:11.940 --> 00:29:14.480
Thank you, Stuart.

00:29:14.480 --> 00:29:17.130
So what are you all here for?

00:29:17.270 --> 00:29:20.160
You're all here to learn about
all these cool APIs and how you

00:29:20.170 --> 00:29:22.750
can make your applications better,
right?

00:29:22.850 --> 00:29:24.200
So that's what I'm going to go into.

00:29:24.200 --> 00:29:26.480
I'm going to go into the
nitty-gritty details of what

00:29:26.480 --> 00:29:29.700
are the application programming
interfaces that you guys can use.

00:29:29.700 --> 00:29:31.560
What are the layers of the API?

00:29:31.560 --> 00:29:33.600
What are the actual calls that you make?

00:29:33.700 --> 00:29:35.110
And how do you actually get this to work?

00:29:35.400 --> 00:29:41.160
Now, in years past, we've actually only
covered the Bonjour APIs.

00:29:41.310 --> 00:29:43.210
But this year,
we're actually going to cover some of

00:29:43.210 --> 00:29:46.950
the socket APIs and things that you also
need to use to actually get you up and

00:29:46.950 --> 00:29:49.230
running all the way from stem to start.

00:29:49.720 --> 00:29:52.280
So first thing, Bonjour API architecture.

00:29:52.460 --> 00:29:55.000
There are five layers to the Bonjour API.

00:29:55.000 --> 00:29:59.100
The top two layers are your
foundation and your CF layers,

00:29:59.180 --> 00:30:02.310
and these are the things that
actually have the Bonjour calls in it:

00:30:02.310 --> 00:30:05.440
to register your services and
advertise them on the network,

00:30:05.440 --> 00:30:12.310
to browse for services on the network
that other devices are providing,

00:30:12.310 --> 00:30:13.400
and to resolve those services so that
you can actually connect to them.

00:30:13.680 --> 00:30:18.390
The DNSSD layer is the low
Darwin Foundation layer.

00:30:18.460 --> 00:30:23.350
It's actually a C-layer API if you
want to get down even closer to

00:30:23.560 --> 00:30:28.570
the underlying layers of Bonjour to
do things in even more detail.

00:30:28.580 --> 00:30:30.780
Now, most of you will probably
not need to go that low.

00:30:30.790 --> 00:30:33.720
Most of you will be just fine using
the NSNet services and CFNet services,

00:30:33.720 --> 00:30:35.580
and that's what I'm going to go over.

00:30:36.140 --> 00:30:37.500
Again, like Stuart said,
a lot of the stuff you don't

00:30:37.570 --> 00:30:38.640
have to worry about yourself.

00:30:38.640 --> 00:30:41.440
Link local addressing and host
names and things like that,

00:30:41.440 --> 00:30:43.050
you won't have to worry about.

00:30:43.140 --> 00:30:46.390
That's taken care of by MDNS Responder
and the kernel layer beneath.

00:30:48.490 --> 00:30:50.720
So again, like I said,
this year we're actually also going to

00:30:50.720 --> 00:30:54.660
go over how to do it from stem to stern,
including all the sockets and things.

00:30:54.660 --> 00:30:59.740
So the two layers on top are
the foundation and the CF layers

00:30:59.740 --> 00:31:03.230
that are going to enable
you to actually use sockets,

00:31:03.230 --> 00:31:04.010
right?

00:31:04.060 --> 00:31:07.110
How do you actually get information
from one device to the other after

00:31:07.110 --> 00:31:08.790
you've connected to the service?

00:31:08.800 --> 00:31:13.040
The Darwin Foundation layer for socket,
bind, and listen is some of the stuff

00:31:13.040 --> 00:31:15.870
I'm going to go over so that
you can actually implement a

00:31:15.870 --> 00:31:17.740
listening service on your device.

00:31:17.740 --> 00:31:21.150
So instead of having just a Mac or
something else that we don't

00:31:21.180 --> 00:31:24.000
really go into detail about,
you have this listening service

00:31:24.000 --> 00:31:26.710
over here and you connect to it,
this year we're actually going to

00:31:26.710 --> 00:31:29.400
go over how to create one of those,
how to bind to a socket,

00:31:29.400 --> 00:31:32.140
how to listen on it,
and how to register it with Bonjour so

00:31:32.160 --> 00:31:33.450
that your client can connect to it.

00:31:33.520 --> 00:31:35.360
And again,
the kernel's down beneath there,

00:31:35.360 --> 00:31:37.020
but you won't have to worry about that.

00:31:37.060 --> 00:31:42.220
So what do you do on the server side?

00:31:44.220 --> 00:31:46.770
First thing you have to do
is get yourself a socket.

00:31:46.820 --> 00:31:48.860
Ask the kernel,
"I need to file the script or to

00:31:48.860 --> 00:31:51.980
do some networking stuff." You're
going to bind that socket to a

00:31:52.060 --> 00:31:56.050
particular address and a port,
and you're actually going to ask

00:31:56.050 --> 00:31:58.480
the kernel for an arbitrary port.

00:31:58.490 --> 00:32:01.950
Since Bonjour does the discovery of
ports and host names and IP addresses,

00:32:02.030 --> 00:32:06.020
it doesn't really matter what port
number you use for your service.

00:32:06.020 --> 00:32:09.680
So you can actually ask the kernel, say,
"I don't care what port number I get.

00:32:09.680 --> 00:32:13.300
Just give me a listening port."
And then once you get it,

00:32:13.300 --> 00:32:16.820
you actually tell the kernel,
"I want to listen on that port."

00:32:16.820 --> 00:32:19.640
And then to make it even easier,
once you've done all that kind

00:32:19.720 --> 00:32:22.920
of low-layer BSD socket stuff,
I'm actually going to go over how

00:32:22.920 --> 00:32:26.020
to wrap it in a CF socket so that
it's a lot easier to integrate

00:32:26.030 --> 00:32:29.600
with your run loops and your
NS application main and all that stuff.

00:32:30.350 --> 00:32:35.310
Then the object that you're going to use
for that wrapping is a CF socket ref.

00:32:39.500 --> 00:32:44.160
Now, what are you going to do to actually
advertise it on the network?

00:32:44.160 --> 00:32:45.600
This is the actual Bonjour call.

00:32:45.600 --> 00:32:48.490
The Bonjour API is NSNet service.

00:32:48.600 --> 00:32:53.040
Once you get the port number from the
kernel that your service is listening on,

00:32:53.120 --> 00:32:55.040
you're going to pass
that to NSNet service,

00:32:55.040 --> 00:32:58.810
and you're going to say,
"Here's the name of my service,

00:32:58.810 --> 00:33:03.850
the type of my service,
and the port number that you're

00:33:03.850 --> 00:33:09.030
actually listening on." I'll go over
this in a little bit more detail.

00:33:09.750 --> 00:33:12.250
Then you actually tell it to publish,
right?

00:33:12.260 --> 00:33:16.090
And that's actually going to advertise it
on the network for your clients to see.

00:33:17.280 --> 00:33:18.940
What about the client?

00:33:18.940 --> 00:33:22.630
So, over here on the client side,
you're going to want to

00:33:22.630 --> 00:33:26.060
search for those services,
the services of the type that you're

00:33:26.060 --> 00:33:28.740
using in development and then,
as Stuart said,

00:33:28.740 --> 00:33:31.190
have registered once you ship, right?

00:33:31.190 --> 00:33:33.520
And you're going to search for those
services that you can actually find.

00:33:33.520 --> 00:33:37.670
And this is the browse call.

00:33:37.670 --> 00:33:37.670
This is what you're actually
going to use to do the browse.

00:33:38.200 --> 00:33:41.270
Now, the browse call has a delegate,
and the delegate method that's going

00:33:41.270 --> 00:33:43.820
to get called is did find service.

00:33:43.820 --> 00:33:46.700
When it finds your services
out on the network,

00:33:46.700 --> 00:33:47.940
it's going to call you
back with this thing.

00:33:47.940 --> 00:33:49.960
Now, keep in mind,
it's going to call you back multiple

00:33:50.050 --> 00:33:52.540
times for each one of the clients
that it sees on the network—or,

00:33:52.540 --> 00:33:54.980
sorry, each one of the servers
that it sees on the network.

00:33:55.000 --> 00:33:58.960
If it sees only one service,
you'll only get one of these callbacks.

00:33:59.010 --> 00:34:02.500
If it sees multiple of them,
you'll actually get several of them back.

00:34:02.540 --> 00:34:05.830
Now, the important part here that
Stuart talked about a little bit is

00:34:05.870 --> 00:34:09.890
that you want your user to decide
which one they want to connect to.

00:34:10.160 --> 00:34:12.970
Don't go connecting to every
single service that comes back

00:34:12.970 --> 00:34:16.300
in did find service because it's
very inefficient on the network.

00:34:17.000 --> 00:36:00.000
[Transcript missing]

00:36:00.970 --> 00:36:04.180
And now your client and
your server are connected.

00:36:04.280 --> 00:36:07.190
Bytes that you write to the output
stream on the client get sent to

00:36:07.260 --> 00:36:11.230
the input stream on the server,
and from the output stream on the server

00:36:11.230 --> 00:36:13.370
to the input stream on the client.

00:36:14.240 --> 00:36:16.400
So what does this look like?

00:36:16.660 --> 00:36:18.310
Okay, back over here to the server side.

00:36:20.620 --> 00:36:21.900
You're going to want to create a socket.

00:36:21.900 --> 00:36:23.730
That's the first line up there.

00:36:23.870 --> 00:36:26.940
AFInet means IPv4.

00:36:26.940 --> 00:36:28.900
Sockstream means you want TCP.

00:36:29.030 --> 00:36:31.870
And then you're going to create
this socket adder object,

00:36:31.980 --> 00:36:36.700
and you're going to tell the kernel,
"I want port number zero." Now,

00:36:36.700 --> 00:36:38.100
there isn't really a port number zero.

00:36:38.100 --> 00:36:39.810
This is the way you tell the kernel,
"I don't care what port

00:36:39.950 --> 00:36:40.590
number you give me.

00:36:40.600 --> 00:36:43.660
Just give me a port,
and I'm going to use Bonjour to let the

00:36:43.770 --> 00:36:45.970
client figure out what the port is."

00:36:46.380 --> 00:36:50.170
Then you'll call bind and get sock name,
right?

00:36:50.240 --> 00:36:53.620
Get sock name is actually the call
that you make to figure out what

00:36:53.620 --> 00:36:56.920
port it was that the kernel gave you.

00:36:58.390 --> 00:37:02.410
And you'll get it back
out of the syn.syn_port.

00:37:02.420 --> 00:37:04.620
And then at the end you call listen,
which actually tells the kernel,

00:37:04.780 --> 00:37:09.940
go ahead and start accepting
TCP connections on this port.

00:37:10.660 --> 00:37:13.400
So, you'll also want to do this for IPv6.

00:37:13.470 --> 00:37:16.480
Now, as many of you probably know,
yesterday was World IPv6 Day.

00:37:16.740 --> 00:37:19.320
It went extraordinarily well.

00:37:19.330 --> 00:37:24.400
I think developer.facebook.com
left IPv6 up.

00:37:24.400 --> 00:37:26.600
It went so well that there's
not even news about it.

00:37:26.600 --> 00:37:29.150
It's not like the power grids
went down and all Y2K stuff,

00:37:29.150 --> 00:37:29.670
right?

00:37:30.400 --> 00:37:34.450
So, you're going to want to do the
same kind of thing on IPv6,

00:37:34.450 --> 00:37:36.440
but there's a gotcha here.

00:37:36.440 --> 00:37:39.880
You want to make sure that you use
the port number that you got for v4.

00:37:39.880 --> 00:37:44.870
Bonjour does not make the distinction,
really, between v4 and v6 because there's

00:37:44.870 --> 00:37:49.220
really only one host name for the
device that's providing the service.

00:37:49.220 --> 00:37:51.380
So,
when your client resolves that service,

00:37:51.390 --> 00:37:54.550
they may get a v6 address back,
they may get a v4 address back.

00:37:54.550 --> 00:37:57.670
So, you need to make sure you're
listening on the same port number,

00:37:57.970 --> 00:38:00.340
otherwise your client
may not actually connect.

00:38:00.400 --> 00:38:03.950
So, the part here that's important
is that when you set the port

00:38:03.960 --> 00:38:07.680
number on the sock adder 6,
you need to make sure that you set it to

00:38:07.680 --> 00:38:12.560
the port number that you got back from
the kernel when you called get sock name.

00:38:16.580 --> 00:38:21.840
So, now here is the glue to
wrap this up in a CF socket.

00:38:21.840 --> 00:38:24.560
It's this thing called
CF socket create with native.

00:38:24.560 --> 00:38:27.340
The kernel, the BSD layer APIs give
you back a file descriptor,

00:38:27.420 --> 00:38:28.260
essentially just an integer.

00:38:28.260 --> 00:38:30.950
You can take that,
wrap it in a CF socket object,

00:38:30.950 --> 00:38:34.600
create a run loop source,
and put that source on your run loop.

00:38:34.670 --> 00:38:39.490
Now, notice that we have specified
this listening socket callback,

00:38:39.490 --> 00:38:43.020
and I will go over that in
a couple of slides here.

00:38:43.020 --> 00:38:45.230
That's actually the thing that
will get called back when you

00:38:45.230 --> 00:38:48.170
get an incoming connection,
and I'll go over how to actually

00:38:48.640 --> 00:38:53.290
wrap the connection in some
NS input stream and output stream.

00:38:53.840 --> 00:38:57.640
So, this is hooking up the V4 socket.

00:38:57.660 --> 00:39:00.000
You have to do this
twice—once for your V4 socket,

00:39:00.000 --> 00:39:03.100
once for your V6 socket,
or you won't actually get your call

00:39:03.130 --> 00:39:05.510
back when somebody connects over V6.

00:39:05.790 --> 00:39:10.290
So make sure you also call
this with your v6 socket.

00:39:10.380 --> 00:39:12.690
Now, for the slides,
this is like copy-pasted code.

00:39:12.690 --> 00:39:15.090
It's probably a better idea to
functionalize this and just pass in

00:39:15.090 --> 00:39:18.880
the file descriptor for v4 and then
pass in the file descriptor for v6.

00:39:20.180 --> 00:39:23.400
So, now to get to the actual Bonjour API.

00:39:23.400 --> 00:39:26.120
What do you do here to
actually register this service?

00:39:26.200 --> 00:39:30.150
You have this thing from the kernel,
and you've wrapped it in a CF socket,

00:39:30.150 --> 00:39:32.420
and it's listening and it's
waiting for your client to connect.

00:39:32.500 --> 00:39:34.370
How do you actually
advertise it over Bonjour?

00:39:34.380 --> 00:39:38.760
We can go all the way back
up to the Cocoa Layer APIs,

00:39:38.830 --> 00:39:42.530
the Foundation Layer APIs,
and you're going to create an

00:39:42.580 --> 00:39:46.720
NSNet service object and init it,
and then schedule it in the run loop,

00:39:46.790 --> 00:39:51.230
set delegates so you can get callbacks,
and then publish it.

00:39:51.830 --> 00:39:55.050
So, the things to note here are, first,
the domain.

00:39:55.160 --> 00:39:58.250
In Bonjour, right,
we support local Bonjour on

00:39:58.250 --> 00:40:01.100
the link local network,
and we also support wide area

00:40:01.110 --> 00:40:04.000
Bonjour over things like Back to My Mac.

00:40:04.040 --> 00:40:08.450
If you pass the empty string domain,
MDNS Responder, the system service that

00:40:08.450 --> 00:40:11.160
takes care of Bonjour,
will just pick all of

00:40:11.190 --> 00:40:13.000
the domains that it can,
right?

00:40:13.000 --> 00:40:15.430
It will actually register
them in all the domains,

00:40:15.510 --> 00:40:17.650
whether they're link
local or Back to My Mac,

00:40:17.650 --> 00:40:19.600
if you have it, say, on your Mac.

00:40:20.160 --> 00:40:21.100
Then the type.

00:40:21.100 --> 00:40:24.200
This is the service type that
Stuart was speaking about.

00:40:24.220 --> 00:40:28.560
This is the type that you've registered,
and this is how your clients will

00:40:28.560 --> 00:40:30.780
find your service on the network.

00:40:31.260 --> 00:40:32.360
The name is also interesting.

00:40:32.360 --> 00:40:35.610
If you pass in the empty string for name,
it will actually,

00:40:35.610 --> 00:40:39.140
just like when the kernel picked
an arbitrary port number for you,

00:40:39.220 --> 00:40:42.970
this one will automatically pick
the pretty name of the device

00:40:42.970 --> 00:40:45.560
that you're running this on.

00:40:45.760 --> 00:40:48.010
For iOS devices,
this is the name that you

00:40:48.010 --> 00:40:49.810
assign the device in iTunes.

00:40:49.970 --> 00:40:53.400
For Macs, this is the name that's
in the sharing pref pane.

00:40:54.190 --> 00:40:55.900
And of course you pass in the port.

00:40:56.010 --> 00:40:58.750
Now notice that we've
wrapped this in end-to-HS,

00:40:58.780 --> 00:41:05.170
which is some low-level networking
stuff because this API takes...

00:41:05.410 --> 00:41:07.620
Host order, host byte order.

00:41:07.620 --> 00:41:13.670
But the stuff that you get back in the
SOC adder is actually network byte order.

00:41:13.680 --> 00:41:17.270
So if you don't do this and you can't
figure out why you can't connect,

00:41:17.350 --> 00:41:18.420
it's probably because
you weren't doing this.

00:41:19.920 --> 00:41:23.680
And you schedule in the run loop,
set your delegate, and call publish.

00:41:23.680 --> 00:41:24.350
What about the callback?

00:41:24.430 --> 00:41:27.360
Well,
in order to figure out what the name

00:41:27.360 --> 00:41:31.980
was that MDNS Responder picked for you,
you just call—sorry,

00:41:31.980 --> 00:41:37.640
you will get this callback
for "did publish," and then

00:41:37.640 --> 00:41:42.640
you can get the name back out,
and you can log it,

00:41:42.640 --> 00:41:42.640
you can display it in your UI,
however you want to deal with that.

00:41:42.990 --> 00:41:44.140
So this is the accept callback.

00:41:44.220 --> 00:41:48.880
This is the glue that when the
CF socket stuff calls you back,

00:41:49.050 --> 00:41:53.590
this is how to wrap it in NS input
stream and NS output stream.

00:41:53.720 --> 00:41:57.440
These slides are going to be
available after the conference,

00:41:57.610 --> 00:42:01.060
and also there's a new sample
coming out called Remote Currency.

00:42:01.230 --> 00:42:03.740
Didn't quite have time to get it done,
but it's coming out soon,

00:42:03.740 --> 00:42:05.610
and it's going to have a
lot of this stuff in it,

00:42:05.610 --> 00:42:11.500
and it'll be a lot better than just
these slides can go into detail with.

00:42:12.690 --> 00:42:14.000
So, what about the client side?

00:42:14.030 --> 00:42:18.740
Right, on the client side, we have to...

00:42:18.980 --> 00:42:20.100
Browse for services.

00:42:20.100 --> 00:42:20.800
Right, so how do you do that?

00:42:20.800 --> 00:42:23.740
Well, again,
you use the NSNet Service Browser—sorry,

00:42:23.750 --> 00:42:24.150
not again.

00:42:24.290 --> 00:42:29.340
You use the NSNet Server Browser object,
you init it, you set your delegate on it,

00:42:29.460 --> 00:42:31.730
and then you search for
services of the type.

00:42:31.950 --> 00:42:33.980
Right, again,
this is your registered type.

00:42:34.080 --> 00:42:38.330
And here, when you pass in the domain,
again, it's going to try to search in

00:42:38.330 --> 00:42:40.210
all the domains that it can.

00:42:41.370 --> 00:42:42.700
And here's the browse callback.

00:42:42.700 --> 00:42:45.050
It's going to do this
"Did find service." Now,

00:42:45.050 --> 00:42:48.220
there's an interesting parameter
in this callback that's going

00:42:48.240 --> 00:42:50.600
to be important for UI reasons.

00:42:50.710 --> 00:42:54.830
It's called "more coming."
More coming is actually a hint

00:42:54.920 --> 00:42:58.940
that the underlying system daemon,
MDNS responder,

00:42:58.940 --> 00:43:01.650
actually has more events for you.

00:43:01.780 --> 00:43:05.760
So you don't necessarily want to
update your UI when this flag is set,

00:43:05.760 --> 00:43:09.180
because you'll be spending a
lot of time updating your UI.

00:43:09.180 --> 00:43:11.300
It's going to kind of
flash in front of the user.

00:43:11.340 --> 00:43:12.570
Who wants bad user experience?

00:43:12.760 --> 00:43:14.300
Nobody.

00:43:14.300 --> 00:43:17.060
Use this as a hint to
just change your model,

00:43:17.060 --> 00:43:20.970
and then when you get one of
these back without the flag set,

00:43:20.970 --> 00:43:22.240
update your UI.

00:43:23.610 --> 00:43:28.760
So, another callback that might
happen is did remove service.

00:43:28.760 --> 00:43:34.640
If the application providing the
service stops registering that service,

00:43:34.700 --> 00:43:37.790
MDS Responder will give you back
one of these did remove services

00:43:38.000 --> 00:43:40.040
because Bonjour is dynamic.

00:43:40.040 --> 00:43:43.300
It knows when things come and
go as long as the device has

00:43:43.310 --> 00:43:46.770
had enough time to say goodbye,
I'm not here anymore, right?

00:43:46.920 --> 00:43:50.890
Now, if you crash or if your device
falls off the Wi-Fi network,

00:43:50.890 --> 00:43:52.900
it won't have time to do that.

00:43:53.860 --> 00:43:58.890
But you will get did remove service
callbacks when it has time to do that,

00:43:58.890 --> 00:44:01.640
and later on, things actually time out,
right?

00:44:01.640 --> 00:44:03.450
In Bonjour,
things will actually time out if

00:44:03.450 --> 00:44:06.150
it hasn't been seen in a while,
and then you'll get some more.

00:44:06.150 --> 00:44:07.300
You'll get a remove call.

00:44:07.300 --> 00:44:08.920
So, what about resolving?

00:44:08.920 --> 00:44:12.130
Again, if you're using the NS Layer APIs,
you don't have to

00:44:12.240 --> 00:44:13.680
explicitly call resolve.

00:44:13.680 --> 00:44:17.090
All you have to do is get the
input stream and the output stream,

00:44:17.090 --> 00:44:19.970
schedule them in your run loop,
and call open.

00:44:20.790 --> 00:44:24.080
Once you've done that, asynchronously,
it will resolve the service,

00:44:24.100 --> 00:44:26.420
it'll connect to it over TCP,
and it'll give you a

00:44:26.570 --> 00:44:27.800
callback when it's done.

00:44:30.760 --> 00:44:33.300
Again, the important thing here to
make sure it's asynchronous is

00:44:33.300 --> 00:44:34.940
to schedule it in a run loop.

00:44:35.030 --> 00:44:37.490
If you call open before you
schedule it in a run loop,

00:44:37.600 --> 00:44:39.370
you're going to block,
you're going to get

00:44:39.370 --> 00:44:41.850
bitten by the watchdog,
things are going to go bad.

00:44:42.030 --> 00:44:45.990
Okay,
so those are the APIs from stem to stern.

00:44:46.470 --> 00:44:47.780
What about multitasking?

00:44:47.810 --> 00:44:52.300
So in iOS 4, we introduced multitasking.

00:44:52.300 --> 00:44:56.330
What does that mean for Bonjour services
and networking in general?

00:44:56.430 --> 00:44:58.750
Well,
let's go through a little timeline here.

00:45:02.230 --> 00:45:05.780
Your application is going to get
"application did enter background."

00:45:05.800 --> 00:45:09.020
It's going to tell you that the
operating system is telling you,

00:45:09.100 --> 00:45:11.220
"Hey,
the user switched off and you're now

00:45:11.220 --> 00:45:17.100
in the background." At this point,
you should stop listening on your sockets

00:45:17.290 --> 00:45:23.020
and you should actually stop advertising,
stop the register for Bonjour,

00:45:23.020 --> 00:45:26.750
because while your application
is in the background,

00:45:26.750 --> 00:45:31.300
you won't necessarily be able to
accept new incoming connections.

00:45:31.440 --> 00:45:34.300
Now, there are a lot of reasons that
we did that the operating system

00:45:34.500 --> 00:45:38.070
actually behaves this way,
but the biggest reason is power, right?

00:45:38.130 --> 00:45:41.440
If you're constantly listening and
constantly doing network stuff,

00:45:41.440 --> 00:45:44.200
even when the user can't
interact in this application,

00:45:44.200 --> 00:45:46.360
then it's just going to
be bad for battery life,

00:45:46.490 --> 00:45:46.890
right?

00:45:46.970 --> 00:45:49.100
So battery performance reasons,
stuff like that.

00:45:49.230 --> 00:45:54.300
So notice that sometime after
"application did enter background,"

00:45:54.300 --> 00:45:58.100
not necessarily immediately after you
return from that delegate callback,

00:45:58.100 --> 00:46:00.500
your code will stop running.

00:46:00.500 --> 00:46:05.010
You can't really tell when that is
because your code is not running.

00:46:05.790 --> 00:46:09.590
Now, you can request a task completion,
and there's some good technical

00:46:09.620 --> 00:46:13.720
publications up that talk about different
ways to do things in the background.

00:46:13.910 --> 00:46:15.360
You can request a task
completion if you're,

00:46:15.360 --> 00:46:16.700
say, downloading something small.

00:46:16.700 --> 00:46:18.340
You can say, "Okay, well,
I need to run just a little

00:46:18.340 --> 00:46:20.380
bit longer," and it'll extend
you out just a little bit.

00:46:20.530 --> 00:46:23.100
But again, it's not going to be forever,
right?

00:46:23.100 --> 00:46:26.560
You're going to, at some point,
stop running.

00:46:26.910 --> 00:46:30.560
Now here's the interesting part here.

00:46:30.560 --> 00:46:33.260
After your code stops running—and again,
you can't tell this is happening

00:46:33.270 --> 00:46:38.680
because your code is not running—your
Bonjour operations may get canceled.

00:46:38.680 --> 00:46:42.470
The inter-process communication from
your application down to the system

00:46:42.480 --> 00:46:47.300
service is going to get severed
for battery-in performance reasons.

00:46:47.300 --> 00:46:51.080
The other thing that might happen is that
your connections are going to get closed.

00:46:51.080 --> 00:46:54.000
That's different than socket close,
right?

00:46:54.000 --> 00:46:57.710
When your code is not running,
you did not call close on the socket.

00:46:57.800 --> 00:47:02.420
But the kernel is going to
send TCP fins to your peers.

00:47:02.420 --> 00:47:07.570
Your listening ports will stop listening,
and the kernel will reclaim the resources

00:47:07.580 --> 00:47:09.920
that go along with your sockets.

00:47:09.920 --> 00:47:13.190
So when your code actually
starts running again,

00:47:13.190 --> 00:47:18.240
you need to make sure to deal
with the aftermath of that stuff.

00:47:18.240 --> 00:47:21.780
Now, if your user has actually just
gone to another application

00:47:21.780 --> 00:47:25.560
and come back really quick,
this may not have happened.

00:47:25.560 --> 00:47:29.590
So you don't necessarily want to stop
your Bonjour browsers and stop your

00:47:29.650 --> 00:47:33.640
outbound connections when you get
application did in the background.

00:47:33.640 --> 00:47:35.780
You are going to want to do
it for listening sockets,

00:47:35.780 --> 00:47:39.500
and I have a note on Tech Note that's
really greatly written,

00:47:39.500 --> 00:47:43.400
and we'll give you a lot of
details on that information.

00:47:43.500 --> 00:49:10.000
[Transcript missing]

00:49:10.690 --> 00:49:13.880
So, what will actually
happen in the aftermath?

00:49:13.890 --> 00:49:14.310
Right?

00:49:14.310 --> 00:49:16.600
This is the browser
callback that will happen.

00:49:16.600 --> 00:49:17.840
Did not search.

00:49:17.880 --> 00:49:20.460
Now, this callback also happens
if there was an error when

00:49:20.460 --> 00:49:23.370
you first started to browse,
but when you come out of the background,

00:49:23.370 --> 00:49:24.440
this is what you're going to get.

00:49:24.590 --> 00:49:27.100
This is when you're going to have to say,
"Okay, let me make sure.

00:49:27.100 --> 00:49:29.180
Does the user really
want to browse again?

00:49:29.350 --> 00:49:33.060
If so, let's restart the browse
and update the UI."

00:49:33.750 --> 00:49:35.920
Keep in mind,
you will not get remove events

00:49:35.920 --> 00:49:39.400
for all of the stuff that you had
previously gotten add events for.

00:49:39.400 --> 00:49:41.680
This thing tells you,
flush your cache of the

00:49:41.680 --> 00:49:43.050
events that you had gotten.

00:49:43.310 --> 00:49:44.520
They're gone.

00:49:44.580 --> 00:49:47.060
If you start again,
you will get add events for all

00:49:47.060 --> 00:49:50.240
the stuff that's on the network,
just as if you started again,

00:49:50.240 --> 00:49:51.930
because you did start again.

00:49:52.320 --> 00:49:55.080
So two years ago we
introduced Bonjour peer to

00:49:55.090 --> 00:49:58.140
peer over Bluetooth in iOS.

00:49:58.140 --> 00:50:02.740
And we have now in iOS 5 made it opt in.

00:50:02.780 --> 00:50:07.540
There were some performance
things and some networking

00:50:07.540 --> 00:50:10.200
things that now made this opt in.

00:50:10.200 --> 00:50:13.640
This is only if you link
against the iOS 5 SDK.

00:50:13.640 --> 00:50:15.970
If you link against
something earlier than that,

00:50:16.050 --> 00:50:17.620
you're still going to
get the old behavior.

00:50:17.660 --> 00:50:19.740
So it's not like if your
users update to iOS 5,

00:50:19.740 --> 00:50:21.480
they're going to get some new behavior.

00:50:21.480 --> 00:50:24.310
If they update to iOS 5 and
still have your old app that was

00:50:24.310 --> 00:50:28.440
built against something before 5,
then they'll still get the old behavior.

00:50:28.440 --> 00:50:31.720
And the flag is exposed
in the DNS layer API,

00:50:31.720 --> 00:50:33.790
DNS SD layer API.

00:50:34.270 --> 00:50:38.240
Okay, so now let's take a step back
and go to tips and reminders.

00:50:38.270 --> 00:50:40.200
Again, I cannot stress this one enough.

00:50:40.270 --> 00:50:43.000
Use asynchronous calls.

00:50:43.000 --> 00:50:45.620
For example,
the DNS timeout is 30 seconds.

00:50:45.620 --> 00:50:49.700
DNS has been around a long time,
and the 30-second timeout has

00:50:49.700 --> 00:50:51.870
worked really well in practice.

00:50:51.870 --> 00:50:56.590
iPhones have not been around as long,
but we've determined that the watchdog

00:50:56.750 --> 00:51:00.930
timer for pulling events off of the
event manager in your main thread,

00:51:00.950 --> 00:51:02.650
about 20 seconds.

00:51:03.240 --> 00:51:07.000
So, if you make a blocking DNS call on
the main thread and your DNS server

00:51:07.000 --> 00:51:11.190
just doesn't respond to you,
you're going to get ejected.

00:51:11.390 --> 00:51:11.860
Right?

00:51:11.930 --> 00:51:14.240
The watchdog is going to bite you.

00:51:14.240 --> 00:51:16.810
And your app dies,
and your user has no idea why.

00:51:16.810 --> 00:51:19.240
It looks like you crashed,
but you didn't.

00:51:19.240 --> 00:51:25.240
So, use the NS layer APIs, NS operation,
and stuff like Grand Central Dispatch.

00:51:25.240 --> 00:51:28.240
There were some great sessions on
Grand Central Dispatch this year.

00:51:28.300 --> 00:51:29.740
Unfortunately,
they're all before this one.

00:51:29.740 --> 00:51:32.280
As a matter of fact,
right before this one in this room.

00:51:32.280 --> 00:51:35.260
So,
go back in time and go watch that one.

00:51:35.300 --> 00:51:37.270
So, browse call.

00:51:37.430 --> 00:51:40.180
The right way to do the browse call.

00:51:40.490 --> 00:51:42.730
Don't have a refresh button.

00:51:42.750 --> 00:51:44.160
Bonjour is dynamic.

00:51:44.160 --> 00:51:46.120
You will get add events,
you will get remove events.

00:51:46.130 --> 00:51:48.400
There's no reason for you to refresh.

00:51:48.400 --> 00:51:52.620
MD&S Responder will
handle that stuff for you.

00:51:52.890 --> 00:51:54.760
Don't do open-ended browsing.

00:51:55.030 --> 00:51:58.860
If you're not displaying
a browse UI to your users,

00:51:58.860 --> 00:52:02.070
they probably don't care about browsing,
and you're going to be using

00:52:02.070 --> 00:52:04.980
network resources that you don't
have to be using because your user

00:52:04.980 --> 00:52:06.620
doesn't care about it right now.

00:52:07.230 --> 00:52:12.960
Also, stop browsing when you're not
displaying that UI anymore.

00:52:13.040 --> 00:52:15.820
Don't start browsing when you first
display the UI and then keep the

00:52:15.820 --> 00:52:19.570
browse going forever and ever and ever,
particularly because when you go into

00:52:19.570 --> 00:52:22.900
the background and come back out,
that browse may be dead.

00:52:23.800 --> 00:52:28.920
So for your Mac developers,
a little suggestion here: use Windows,

00:52:28.920 --> 00:52:30.790
not pull-down menus.

00:52:30.810 --> 00:52:30.810
Right?

00:52:30.820 --> 00:52:34.060
If you're mousing over a menu and all of
a sudden it changes out from underneath

00:52:34.150 --> 00:52:38.100
you kind of right before you click,
bad user experience.

00:52:38.130 --> 00:52:41.700
Users are generally more
comfortable with menus being static.

00:52:41.910 --> 00:52:47.690
Now, the next thing is also very
important for networking in general.

00:52:48.230 --> 00:52:54.210
Resolve and connect only when your
user has selected the service.

00:52:54.330 --> 00:52:57.830
Don't connect to every single
thing that you find in the browse.

00:52:57.830 --> 00:53:02.040
It uses the network unduly.

00:53:02.040 --> 00:53:05.000
So here's a little graphic
that we put together.

00:53:05.000 --> 00:53:08.270
So as Stuart said before,
when you browse, you get a little bit of

00:53:08.270 --> 00:53:09.610
information about every service.

00:53:09.620 --> 00:53:13.760
You get the name of all the services
of the type that you're looking for.

00:53:14.580 --> 00:53:17.080
When you resolve,
you get a lot of information

00:53:17.080 --> 00:53:18.400
about one service.

00:53:18.400 --> 00:53:19.780
Right?

00:53:19.780 --> 00:53:24.120
Do not go fill out the entire table.

00:53:24.120 --> 00:53:28.100
It's bad for the network and
bad for your user experience.

00:53:32.060 --> 00:53:33.910
So, saving services you find.

00:53:33.920 --> 00:53:37.440
Bad ideas for saving the information
that you get back from resolving.

00:53:37.460 --> 00:53:39.620
Don't just save the IP address.

00:53:39.850 --> 00:53:42.620
IP addresses change,
particularly link local

00:53:42.620 --> 00:53:45.200
addresses and addresses in IPv6.

00:53:45.200 --> 00:53:49.000
In Lion, we have temporary
private addresses for v6,

00:53:49.000 --> 00:53:52.600
and those things may change—or those
things will change—about every 24 hours.

00:53:52.640 --> 00:53:55.320
If your device goes off the
network and comes back on,

00:53:55.320 --> 00:53:58.360
it might have changed its address
just because the DHCP server

00:53:58.360 --> 00:53:59.460
decided to give it a new one.

00:53:59.670 --> 00:54:01.540
Don't save just the IP address.

00:54:01.740 --> 00:54:03.940
Also, don't save the port number.

00:54:03.970 --> 00:54:08.610
If you follow the direction here and
you ask the kernel for port number zero,

00:54:08.710 --> 00:54:10.500
the next time you ask the
kernel for port number zero,

00:54:10.500 --> 00:54:12.340
you're probably going to
get a different port number.

00:54:12.440 --> 00:54:14.590
So, on the client side,
don't save the port number because you

00:54:14.590 --> 00:54:16.200
probably won't be able to connect to it.

00:54:16.280 --> 00:54:18.100
As a matter of fact,
don't even save the host name.

00:54:18.180 --> 00:54:19.700
The host name can actually change.

00:54:19.700 --> 00:54:23.860
If the user goes and, say, you know,
changes the name of their machine,

00:54:23.860 --> 00:54:26.680
that's not necessarily
what you want to save.

00:54:26.860 --> 00:54:31.400
The right way to do it is late binding,
right?

00:54:31.400 --> 00:54:31.400
The service is defined
by the tuple of name,

00:54:31.400 --> 00:54:34.780
type, type in domain,
that's what you want to save.

00:54:36.030 --> 00:54:38.860
Again, service naming and registering.

00:54:38.860 --> 00:54:41.580
There's a unique identifier
for each service type,

00:54:41.600 --> 00:54:45.660
15 characters maximum, letters, digits,
and hyphens are allowed.

00:54:45.840 --> 00:54:47.900
Go to this URL and register your type.

00:54:47.900 --> 00:54:50.040
It's real easy.

00:54:50.040 --> 00:54:50.040
It's free.

00:54:50.670 --> 00:54:51.600
More information.

00:54:51.600 --> 00:54:54.890
We've got some great evangelists that
help us out with the Bonjour stuff,

00:54:54.890 --> 00:54:57.040
and we have some great
documentation and sample code.

00:54:57.040 --> 00:55:00.210
Again, there's a new sample coming out in
a couple of weeks called "Remote

00:55:00.210 --> 00:55:02.060
Currency" that you should all look at.

00:55:02.160 --> 00:55:04.830
There's the book written
by my colleague Stuart,

00:55:04.910 --> 00:55:07.400
and of course the Apple Developer Forum.

00:55:07.400 --> 00:55:10.450
So for the third of you that
have been to Bonjour before,

00:55:10.450 --> 00:55:14.160
the Bonjour stuff before,
and know a little bit more about Bonjour,

00:55:14.190 --> 00:55:17.630
you can help out those that are
new and that don't know as much.

00:55:17.630 --> 00:55:18.880
Some related sessions
that are all in the past.

00:55:19.180 --> 00:55:21.550
If you don't take anything else,
these are the things

00:55:21.550 --> 00:55:22.940
that you should remember.

00:55:23.030 --> 00:55:25.200
Bonjour makes networking
easy and reliable.

00:55:25.200 --> 00:55:29.780
It makes things really easy to do,
and Apple uses it all over the system,

00:55:29.940 --> 00:55:33.360
and we make these APIs public,
and you guys can use it as well.

00:55:33.440 --> 00:55:37.100
It's also public for things
like Linux and Windows,

00:55:37.500 --> 00:55:41.780
Android phones, that kind of stuff,
so it's cross-platform.

00:55:41.870 --> 00:55:44.900
Use asynchronous calls
across all of networking,

00:55:44.900 --> 00:55:46.010
not just Bonjour.

00:55:46.190 --> 00:55:48.610
Do not get bitten by the watchdog.

00:55:48.760 --> 00:55:51.750
Let the user decide when
they've waited long enough.

00:55:51.910 --> 00:55:53.600
Don't just say, "Well,
I haven't been able to

00:55:53.600 --> 00:55:54.740
connect for 10 seconds.

00:55:54.740 --> 00:55:58.280
I'm going to stop." Ten seconds
might be great for one network

00:55:58.280 --> 00:55:59.810
and horrible for another network.

00:56:00.030 --> 00:56:03.750
Let the user decide when
they're done waiting for stuff.

00:56:03.870 --> 00:56:04.890
Use late binding.

00:56:04.900 --> 00:56:10.300
If you're going to resolve a service once
and then connect to it multiple times,

00:56:10.300 --> 00:56:13.620
say, like, when you choose a printer,
you want to keep the

00:56:13.620 --> 00:56:16.980
name type in the domain,
not the port number, not the IP address,

00:56:16.980 --> 00:56:18.300
not even the host name.

00:56:18.300 --> 00:56:21.690
the service name, the service type,
and the domain in which

00:56:21.690 --> 00:56:23.030
it was discovered.

00:56:23.220 --> 00:56:25.580
Handle errors when you get
back out of the background,

00:56:25.580 --> 00:56:29.380
because you may encounter them
depending on when the kernel

00:56:29.380 --> 00:56:31.440
needed to reclaim resources.

00:56:31.440 --> 00:56:33.740
And register your service types.

00:56:33.920 --> 00:56:35.610
Thank you very much.
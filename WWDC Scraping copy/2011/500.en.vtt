WEBVTT

00:00:11.300 --> 00:00:12.300
I haven't said anything yet.

00:00:12.300 --> 00:00:15.070
It's all right.

00:00:15.260 --> 00:00:17.780
Thanks for joining us this morning,
starting off your conference,

00:00:17.780 --> 00:00:19.220
second session of the day.

00:00:19.260 --> 00:00:22.090
I'm really excited to be here
this morning to talk to you about

00:00:22.550 --> 00:00:24.180
what's new in Core Location.

00:00:24.280 --> 00:00:27.060
We've got a lot of stuff
to talk about today,

00:00:27.220 --> 00:00:29.210
so let's dive right in.

00:00:29.710 --> 00:00:32.630
But before I get started on content,
I want to take a few minutes

00:00:32.730 --> 00:00:35.520
to ask why you're here today.

00:00:35.580 --> 00:00:39.000
And I suspect there's probably
a few reasons for that.

00:00:39.070 --> 00:00:44.190
I suspect we've probably got a few people
in the crowd who are location experts.

00:00:44.230 --> 00:00:47.040
Maybe you've built some
applications that use location.

00:00:47.040 --> 00:00:52.120
You've seen the potential that it has to
improve the experience for your users.

00:00:52.280 --> 00:00:54.910
And then, on the other hand,
I imagine there are also some people

00:00:54.910 --> 00:00:57.640
here today for whom this is new to them.

00:00:57.830 --> 00:01:00.680
Maybe you're looking to develop
your first location-aware app.

00:01:00.750 --> 00:01:04.630
You're not quite sure what it entails,
what's involved.

00:01:04.820 --> 00:01:08.540
So I'm really hoping that today is
valuable for both groups of people.

00:01:08.630 --> 00:01:13.040
So whether you're here because you've
done this before and you're hoping

00:01:13.040 --> 00:01:17.640
that we've added new things that make
it even easier to incorporate location

00:01:17.640 --> 00:01:21.550
to your application and really expand
the possibilities for your users,

00:01:21.700 --> 00:01:24.300
or whether you're brand new and
you want to get started on your

00:01:24.300 --> 00:01:27.660
first location-aware application,
we're really excited

00:01:27.660 --> 00:01:30.460
that you're here today,
and we think we've got a lot

00:01:30.460 --> 00:01:33.090
of great stuff to show you.

00:01:33.690 --> 00:01:34.690
Why?

00:01:34.850 --> 00:01:37.140
I know that we do this every year,
but I think it's really important

00:01:37.140 --> 00:01:40.790
to just think about what can
location do for your application?

00:01:40.790 --> 00:01:42.730
Why is it powerful?

00:01:42.730 --> 00:01:46.300
And the answer is that location
is really powerful because it

00:01:46.360 --> 00:01:48.600
provides context about your user.

00:01:48.600 --> 00:01:54.240
iOS devices, it's really this whole new
platform that is inherently mobile.

00:01:54.510 --> 00:02:00.590
Whether it's an iPhone, an iPod Touch,
or an iPad, users just expect to be able

00:02:00.740 --> 00:02:04.820
to put these in their pocket,
put them in a bag, and take them out in

00:02:04.820 --> 00:02:07.070
completely new surroundings.

00:02:07.220 --> 00:02:11.350
So it's not a safe assumption to just
assume that the way things are now is

00:02:11.350 --> 00:02:13.370
the way that things always will be.

00:02:13.380 --> 00:02:16.520
So using location,
you can make it so that your

00:02:16.520 --> 00:02:20.480
applications already are in
tune with where the user is,

00:02:20.480 --> 00:02:21.990
with the environment that they're in.

00:02:22.420 --> 00:02:25.560
Whether they're just moving across
town or moving to a new country.

00:02:25.560 --> 00:02:29.100
Using location services,
your application can be aware and it

00:02:29.100 --> 00:02:33.560
can immediately bring the user into a
context with which they're familiar.

00:02:34.260 --> 00:02:37.170
It really breaks down that barrier
between what they're trying to

00:02:37.380 --> 00:02:39.230
do and getting them to doing it.

00:02:39.320 --> 00:02:43.870
But not only does it just make
your applications more intuitive,

00:02:43.870 --> 00:02:47.920
we're starting to see brand
new use cases for location.

00:02:47.920 --> 00:02:50.410
Five years ago,
the notion that we would have

00:02:50.470 --> 00:02:53.970
devices in our pocket that allow
us to share what we're doing,

00:02:53.970 --> 00:02:57.500
where we are,
and even bring our friends in the action,

00:02:57.500 --> 00:02:59.690
social location, would be unheard of.

00:03:01.100 --> 00:03:05.140
And if you look at iOS 5 alone,
we as Apple are really starting

00:03:05.140 --> 00:03:10.150
to bring location into new
scenarios in the system.

00:03:10.380 --> 00:03:12.980
With the new
Twitter integration in iOS 5,

00:03:12.980 --> 00:03:17.300
we allow users to geotag their
location from any application.

00:03:17.300 --> 00:03:20.540
They just hit a button,
and they're already tweeting.

00:03:20.620 --> 00:03:23.820
We think location-based
reminders are going to be huge,

00:03:23.880 --> 00:03:27.150
so that users can ask to be
reminded when they leave a certain

00:03:27.150 --> 00:03:29.280
location or go to a new location.

00:03:29.630 --> 00:03:32.400
And location-aware weather
just allows you to,

00:03:32.420 --> 00:03:35.940
at a glance,
see the current conditions where you are,

00:03:36.000 --> 00:03:39.490
no matter how far you've moved
since the last time that you

00:03:39.490 --> 00:03:41.640
set the cities and weather app.

00:03:41.740 --> 00:03:46.070
So that's us,
but it's really just the beginning.

00:03:46.510 --> 00:03:50.680
Because what we're really excited
about are the possibilities that

00:03:50.680 --> 00:03:54.680
we can continue to see realized,
and the applications that are

00:03:54.680 --> 00:03:56.740
created by our developers.

00:03:56.780 --> 00:03:58.790
And these are some of the big examples.

00:03:59.020 --> 00:04:03.070
We have Yelp and Foursquare,
and we have fitness apps,

00:04:03.210 --> 00:04:04.560
things like that.

00:04:04.650 --> 00:04:07.490
But what we're really excited
about are the applications that

00:04:07.590 --> 00:04:10.200
we haven't even thought of yet,
the applications that

00:04:10.200 --> 00:04:13.280
are just in your heads,
that are just possibilities.

00:04:13.330 --> 00:04:17.610
And it's our goal to make it possible
for you to build those applications,

00:04:17.720 --> 00:04:23.540
to make it easy for you to just
take the location part as a given,

00:04:23.580 --> 00:04:26.990
so that you can take that and
then move on to building the

00:04:26.990 --> 00:04:29.400
really great user experience.

00:04:30.440 --> 00:04:33.070
So, given all that,
hopefully I've convinced you that

00:04:33.070 --> 00:04:35.560
we're really excited about this,
and we're really excited to see

00:04:35.910 --> 00:04:37.000
what you're going to do with it.

00:04:37.140 --> 00:04:39.300
What are we going to learn about today?

00:04:39.360 --> 00:04:43.580
I'm going to start off by talking about
how to use the Core Location services.

00:04:43.700 --> 00:04:45.820
We provide three different services.

00:04:45.880 --> 00:04:51.160
I'm going to talk about each of them,
how to use them, and when to use them.

00:04:51.460 --> 00:04:54.110
After that,
I'm going to talk about authorization,

00:04:54.110 --> 00:04:58.420
about this notion of putting the user in
control of their location information.

00:04:58.420 --> 00:05:01.160
Users are more likely to use
your applications if they feel

00:05:01.160 --> 00:05:05.380
like they have the final say in
how their information is used.

00:05:05.610 --> 00:05:08.900
And we've gone to a lot of effort
to make it possible for your

00:05:08.900 --> 00:05:12.190
application to be aware of their
decisions and respond to it.

00:05:12.920 --> 00:05:14.850
And then finally,
we're going to talk about some new

00:05:14.960 --> 00:05:16.920
APIs we've added in Core Location.

00:05:16.920 --> 00:05:20.970
And the way that I think of this is that
it really adds a new layer of meaning,

00:05:20.970 --> 00:05:23.290
of context to location information.

00:05:23.300 --> 00:05:32.190
It goes beyond coordinates and
moves location into the realm

00:05:32.190 --> 00:05:32.190
of the way users perceive it.

00:05:32.190 --> 00:05:32.190
So get ready for that.

00:05:33.800 --> 00:05:36.630
So we have these APIs that
allow you to get your location.

00:05:36.780 --> 00:05:37.480
How do you use them?

00:05:37.480 --> 00:05:38.300
What are they?

00:05:38.310 --> 00:05:40.280
When should you use them?

00:05:40.310 --> 00:05:42.540
What I really want to emphasize
through all of this is that it's

00:05:42.540 --> 00:05:46.640
really important to choose the
right service for your use case.

00:05:46.660 --> 00:05:50.480
Applications use location in a
wide variety of different ways,

00:05:50.480 --> 00:05:54.170
whether it's the user looking at
their device and looking at a map,

00:05:54.210 --> 00:05:56.920
using location in a social way,
checking in,

00:05:57.010 --> 00:06:01.140
or really just wanting to be able
to use location in the background.

00:06:01.160 --> 00:06:03.680
These applications have
different location needs.

00:06:03.680 --> 00:06:06.550
There are different trade-offs
that are acceptable to the user and

00:06:06.550 --> 00:06:08.520
they have different costs as well.

00:06:08.520 --> 00:06:11.260
So as we go through these,
try and think about where your

00:06:11.260 --> 00:06:16.450
application fits in terms of these
services and what the best one to use is.

00:06:17.780 --> 00:06:21.940
We have three different positioning
methods that underlie these services.

00:06:21.940 --> 00:06:25.300
The first one is cell positioning,
and the way that this works is

00:06:25.300 --> 00:06:29.240
that devices with cellular radio,
so our iPhone devices as

00:06:29.240 --> 00:06:33.140
well as our 3G-enabled iPads,
are connected to a cellular network.

00:06:33.310 --> 00:06:36.680
And we can get the unique identifier
of the cell tower that the

00:06:36.920 --> 00:06:40.500
device is currently connected to,
and then based on that information,

00:06:40.500 --> 00:06:43.700
if we go to a database and we
know where that cell tower is,

00:06:43.900 --> 00:06:46.170
we can locate the device.

00:06:46.510 --> 00:06:49.690
Now, because the device stays
camped on the cell network,

00:06:49.690 --> 00:06:53.320
this is a really, really inexpensive form
of positioning to do,

00:06:53.420 --> 00:06:54.400
and it's fast.

00:06:54.460 --> 00:06:56.510
We immediately know which
cell network the device is on,

00:06:56.520 --> 00:06:59.320
and so we just need to
do this database lookup.

00:06:59.880 --> 00:07:05.020
Now, because cell towers tend
to cover a large region,

00:07:05.020 --> 00:07:08.200
anywhere between 500 meters
up to several kilometers,

00:07:08.200 --> 00:07:11.500
or in some cases even more than that,
this isn't the most accurate

00:07:11.500 --> 00:07:12.880
method of positioning.

00:07:12.980 --> 00:07:17.780
But it is the quickest,
and it does have the lowest

00:07:17.780 --> 00:07:17.780
cost in terms of power.

00:07:18.420 --> 00:07:21.460
The second type of positioning
we have is WiFi positioning.

00:07:21.610 --> 00:07:24.000
And this works in a similar
way to cell positioning,

00:07:24.070 --> 00:07:26.860
but what the device does is it
actually does a scan to see which

00:07:26.910 --> 00:07:30.290
access points are near the device,
in the same way that the

00:07:30.290 --> 00:07:32.900
AutoJoint scans work,
scanning to see if any known

00:07:32.900 --> 00:07:36.780
networks are around so your device
can automatically associate.

00:07:36.880 --> 00:07:39.940
And we can pull the MAC address,
and again, a unique identifier

00:07:40.350 --> 00:07:43.340
from each access point,
and then by cross-referencing

00:07:43.340 --> 00:07:45.760
from a database,
we know where those access points are,

00:07:45.840 --> 00:07:47.720
and we thus know where the device is.

00:07:47.810 --> 00:07:49.920
This is also relatively quick.

00:07:50.030 --> 00:07:54.620
It's a bit more power intensive,
because it requires the device

00:07:54.620 --> 00:07:56.610
to actually go and do a scan.

00:07:56.880 --> 00:07:59.060
But it's still relatively quick,
because again,

00:07:59.060 --> 00:08:01.500
it's just a lookup in a database.

00:08:01.580 --> 00:08:05.390
And because the range associated
with WiFi access points

00:08:05.460 --> 00:08:10.900
tends to be somewhat smaller,
this is also more accurate as well.

00:08:11.310 --> 00:08:14.490
And then the third notion of
positioning is the one that you're

00:08:14.640 --> 00:08:17.330
probably most familiar with,
and that is GPS.

00:08:17.450 --> 00:08:20.050
And at a very high level,
GPS works by having a receiver

00:08:20.050 --> 00:08:23.630
listening for signals from satellites
that are orbiting the Earth.

00:08:23.760 --> 00:08:29.310
And if it can get signals
from enough satellites,

00:08:29.310 --> 00:08:29.310
it can triangulate to determine
the device's position.

00:08:29.720 --> 00:08:33.670
So why mention this one last,
because it's the most familiar one?

00:08:33.850 --> 00:08:37.080
I really want to emphasize that
these technologies are complementary.

00:08:37.120 --> 00:08:39.100
There's not one that's
better than the other.

00:08:39.160 --> 00:08:42.880
It's not like GPS is always
the one that we want to use.

00:08:42.890 --> 00:08:47.060
While it does have the best accuracy,
it doesn't get a fix quite as quickly

00:08:47.180 --> 00:08:48.980
as cell or WiFi positioning does.

00:08:48.980 --> 00:08:52.970
It can take a number of seconds
in order to detect satellites,

00:08:53.130 --> 00:08:56.600
particularly in challenging
positioning environments.

00:08:56.650 --> 00:08:59.450
And there are some environments
that are really difficult for GPS,

00:08:59.620 --> 00:09:03.040
like an underground parking
garage or a subway system.

00:09:03.090 --> 00:09:06.660
If it doesn't have at least
an indirect path to the sky,

00:09:06.790 --> 00:09:09.080
GPS isn't going to work.

00:09:09.450 --> 00:09:12.600
And finally, not all of our devices
have GPS receivers.

00:09:12.620 --> 00:09:16.260
We've shipped a GPS with
the iPhone 3G and onward,

00:09:16.410 --> 00:09:19.300
as well as with our 3G-enabled iPads.

00:09:19.480 --> 00:09:24.410
But your users who use iPod
Touch devices and WiFi-only iPads,

00:09:24.530 --> 00:09:28.300
or who use your applications in kind
of these non-traditional environments

00:09:28.300 --> 00:09:32.170
where a GPS signal may not be available,
want to use your application too.

00:09:32.300 --> 00:09:35.300
So it's really important to look at
these technologies as complementary,

00:09:35.300 --> 00:09:39.100
and to look at them as a big
picture in terms of how they can

00:09:39.100 --> 00:09:42.100
help your application use location.

00:09:44.510 --> 00:09:47.590
So we have three different services
provided by the Core Location framework

00:09:48.020 --> 00:09:51.420
that make use of each of these
technologies in different ways to

00:09:51.420 --> 00:09:53.860
provide services to your application.

00:09:54.090 --> 00:09:57.400
So you can think of the
technologies as the nuts and bolts,

00:09:57.530 --> 00:10:00.480
the implementation details of
how the device positions you.

00:10:00.560 --> 00:10:03.350
But the services are what
your application cares about.

00:10:03.420 --> 00:10:05.480
They're your entry to
the location service.

00:10:05.550 --> 00:10:07.970
They're what you use to
position your application.

00:10:08.100 --> 00:10:11.480
So these are really the
decisions that you make.

00:10:11.550 --> 00:10:15.540
We abstract away the
technologies into these services.

00:10:15.590 --> 00:10:19.200
The three services are the
standard location service,

00:10:19.250 --> 00:10:21.740
which is essentially a service aimed
at getting your application to the

00:10:21.740 --> 00:10:24.520
best position as quickly as possible.

00:10:24.590 --> 00:10:27.260
We have the significant
location change service.

00:10:27.320 --> 00:10:30.230
And the purpose of that service is
to allow your device to get regular

00:10:30.230 --> 00:10:33.600
updates when the user changes
their position significantly,

00:10:33.670 --> 00:10:35.930
even when your device
is in the background.

00:10:36.060 --> 00:10:39.360
And then finally,
we have the region monitoring service.

00:10:39.420 --> 00:10:44.280
And this is a service that allows your
application to specify locations and

00:10:44.280 --> 00:10:48.620
regions of interest that it cares about
and get notified by the Core Location

00:10:48.620 --> 00:10:55.500
framework when the user enters or exits
those locations or regions of interest.

00:10:56.200 --> 00:10:59.060
So I'm going to start off by talking
about the standard location service.

00:10:59.130 --> 00:11:00.480
Again, this is the most conventional.

00:11:00.480 --> 00:11:04.540
It's probably the first one that you
look at when you think of location.

00:11:04.590 --> 00:11:10.650
And its goal is to get your application
a location quickly and accurately.

00:11:10.840 --> 00:11:12.340
So you see this in use in Maps.

00:11:12.650 --> 00:11:16.130
Turn-by-turn navigation
applications often use this.

00:11:17.030 --> 00:11:23.010
So taking a look at the high
level of how this works,

00:11:23.270 --> 00:11:30.910
if you view your application as a whole,
this is really just one part of it.

00:11:30.910 --> 00:11:30.910
But the Core Location framework is
your entry to the location service.

00:11:30.910 --> 00:11:30.910
It is a set of APIs that
you call to use location.

00:11:31.150 --> 00:11:34.600
And then inside your application,
you will provide a delegate object.

00:11:34.680 --> 00:11:37.580
We call it a delegate object
because you'll need to implement the

00:11:37.580 --> 00:11:40.940
CL Location Manager delegate protocol.

00:11:40.990 --> 00:11:44.430
This is essentially a set of methods
that your delegate object implements

00:11:44.790 --> 00:11:49.010
in order to handle locations that are
received from the location service.

00:11:49.660 --> 00:11:53.160
Now, inside the Core Location framework,
there are a few components

00:11:53.230 --> 00:11:54.100
that you'll use.

00:11:54.230 --> 00:11:55.930
The first is the CL Location Manager.

00:11:55.980 --> 00:12:04.700
This is the central object that
you will use to request locations,

00:12:04.700 --> 00:12:04.700
as well as determining the
authorization state of the device.

00:12:05.490 --> 00:12:09.960
Now, when a location is received,
that comes back to your delegate

00:12:09.960 --> 00:12:14.620
object in the form of a CL location
object that is essentially a data

00:12:14.620 --> 00:12:17.900
object that contains all of the
information about the location.

00:12:18.190 --> 00:12:26.390
The coordinates, the accuracy, altitude,
timestamp, speed, course,

00:12:26.390 --> 00:12:26.390
all that information.

00:12:26.930 --> 00:12:29.100
So how do you receive locations?

00:12:29.140 --> 00:12:32.030
Well, it's as easy as creating
the Core Location Manager,

00:12:32.030 --> 00:12:35.810
the CL Location Manager object,
and then calling StartUpdatingLocation.

00:12:36.030 --> 00:12:40.480
You call that API, and then in return,
when the service determines a position,

00:12:40.540 --> 00:12:44.860
it will call you back with the
LocationManager didUpdateToLocation,

00:12:44.950 --> 00:12:47.220
FromLocation, they'll get callback.

00:12:47.250 --> 00:12:49.720
And that provides you these
locations that you use.

00:12:49.790 --> 00:12:52.000
So at a basic level,
it's all very straightforward.

00:12:52.030 --> 00:12:54.660
You ask for a location,
you get a location back.

00:12:54.740 --> 00:12:56.490
Couldn't be easier.

00:12:56.970 --> 00:13:01.110
However, we find that applications often
want to customize the types of

00:13:01.110 --> 00:13:02.960
locations that they get back.

00:13:02.960 --> 00:13:07.920
And so we have a few ways of doing that,
ways of configuring the location manager.

00:13:08.000 --> 00:13:10.500
The first thing you can
specify is a desired accuracy.

00:13:10.590 --> 00:13:16.350
And this is essentially a way of saying,
how accurate a position do I really need?

00:13:16.600 --> 00:13:18.970
For example,
if you have an application that

00:13:18.980 --> 00:13:22.370
just needs to know what city the
user is in or the general vicinity,

00:13:22.370 --> 00:13:25.680
you don't necessarily need the
best accurate position possible.

00:13:26.150 --> 00:13:29.780
And in fact, waiting for that position
might be a mistake,

00:13:30.000 --> 00:13:33.780
because it's more important for
your user to get-- for you to

00:13:33.780 --> 00:13:38.140
get a location quickly so you can
display something to the user than

00:13:38.140 --> 00:13:40.540
to get the most accurate position.

00:13:40.540 --> 00:13:43.180
So desired accuracy is your
way of specifying how good

00:13:43.180 --> 00:13:43.180
of a position that you need.

00:13:43.360 --> 00:13:46.100
And under the hood,
Core Location then determines

00:13:46.100 --> 00:13:48.960
which technologies to use
based on this accuracy.

00:13:48.960 --> 00:13:52.680
So there could be a significant
power savings by specifying a higher

00:13:52.680 --> 00:13:56.530
location accuracy if your use case
doesn't require the best possible.

00:13:56.910 --> 00:13:59.870
In turn, better user experience.

00:14:00.180 --> 00:14:02.450
The other property is
the distance filter.

00:14:02.690 --> 00:14:06.040
And this is really aimed at simplifying
the logic for applications who don't

00:14:06.040 --> 00:14:10.920
necessarily need to know every time
the user moves a tiny little bit.

00:14:11.020 --> 00:14:13.340
For example,
if your application just cares

00:14:13.340 --> 00:14:15.630
if the user changes cities,
or changes neighborhoods,

00:14:15.710 --> 00:14:19.600
or walks some number of blocks,
but you don't necessarily care that

00:14:19.600 --> 00:14:23.860
they moved a few meters down the street,
you can specify a distance filter.

00:14:23.950 --> 00:14:27.900
And this is essentially how far
does the user need to move before

00:14:27.900 --> 00:14:30.300
you get another location callback.

00:14:30.480 --> 00:14:34.760
And in fact,
if you set this large enough, you know,

00:14:34.760 --> 00:14:39.530
to kilometers or more,
the location service can actually

00:14:39.530 --> 00:14:44.990
optimize by turning off certain
technologies and then restarting

00:14:45.020 --> 00:14:48.630
them again when it's possible for
the user to have moved that distance.

00:14:48.630 --> 00:14:48.630
If you say notify me every 10 kilometers,
the user is unlikely to

00:14:48.630 --> 00:14:48.630
move that far in a minute,
for example.

00:14:48.930 --> 00:14:50.210
Don't worry, though.

00:14:50.370 --> 00:14:54.230
If a better accuracy
position becomes available,

00:14:54.250 --> 00:14:59.410
so let's say there was a
1,000-meter accurate position,

00:14:59.410 --> 00:15:04.700
and then all of a sudden a 100-meter
accurate position comes in,

00:15:04.700 --> 00:15:08.290
I bet we get a better position,
your application will still

00:15:08.290 --> 00:15:08.290
get notified about that.

00:15:08.290 --> 00:15:08.290
So you get the best accuracy
position without having to get

00:15:08.290 --> 00:15:08.290
all these callbacks repeatedly.

00:15:08.810 --> 00:15:17.120
One other thing that you'll want to
notice about CL Location Manager,

00:15:17.480 --> 00:15:21.370
which I'll come back to later,
is the authorization status,

00:15:21.370 --> 00:15:21.370
which indicates the choice that the
user has made about your application

00:15:21.370 --> 00:15:21.370
with regards to location services.

00:15:22.520 --> 00:15:27.300
Now, one note about what we call
continuous location applications.

00:15:27.470 --> 00:15:35.580
These are applications where
the user expects the same

00:15:35.580 --> 00:15:35.580
experience from the application,
whether it's in the foreground or

00:15:35.580 --> 00:15:35.580
whether it's in the background.

00:15:35.810 --> 00:15:39.220
So examples of this are turn by
turn navigation applications.

00:15:39.300 --> 00:15:41.480
The user wants to go
and check their email,

00:15:41.730 --> 00:15:44.550
but they still need to know
when they need to turn right

00:15:44.940 --> 00:15:46.450
at the next intersection.

00:15:46.760 --> 00:15:49.610
Or fitness applications,
they still want to track their distance,

00:15:49.610 --> 00:15:54.380
even if they switch over to the iPod app
to change what song they're listening to.

00:15:54.450 --> 00:15:57.990
If your application's one where the
user expects that same experience,

00:15:58.100 --> 00:16:00.770
that same accuracy,
expects the location to continue running,

00:16:00.820 --> 00:16:03.220
even when the application's
in the background,

00:16:03.310 --> 00:16:05.200
we have a way for you to do that.

00:16:05.340 --> 00:16:08.440
So what you do is you add a
particular plist key to your

00:16:08.440 --> 00:16:10.760
application's Info.plist.

00:16:10.850 --> 00:16:14.170
And then once that key is set,
as long as the application

00:16:14.170 --> 00:16:16.980
is using location,
it continues to run in the background

00:16:17.340 --> 00:16:20.100
and receive location information.

00:16:20.160 --> 00:16:24.070
Now, as with any of our services,
there is a cost to doing this.

00:16:24.170 --> 00:16:27.420
Obviously, if the GPS is running,
that's going to have an effect

00:16:27.420 --> 00:16:29.790
on the user's battery life,
as well as the CPU cost of

00:16:29.790 --> 00:16:31.600
keeping location running.

00:16:31.770 --> 00:16:37.380
So we really expect that this will really
only be of use for these use cases.

00:16:37.590 --> 00:16:40.460
But if you need it, here's how to do it.

00:16:40.840 --> 00:16:43.170
So that's a standard location service.

00:16:43.320 --> 00:16:45.870
And it's great if you're really
in this environment where you

00:16:45.870 --> 00:16:50.040
need the user's position as
accurately as possible right now.

00:16:50.260 --> 00:16:55.130
But what if you're in an environment
where what you really care about is

00:16:55.130 --> 00:16:56.900
when the user moves significantly?

00:16:56.960 --> 00:16:59.790
It'd be kind of wasteful to
run the GPS the whole time if

00:16:59.790 --> 00:17:03.720
all you want to do is detect,
all right, well, the user's moved, say,

00:17:03.720 --> 00:17:05.580
300, 500 meters.

00:17:05.700 --> 00:17:07.850
So I want my application
to check and see,

00:17:07.880 --> 00:17:11.370
you know, maybe if another user is
nearby that they care about,

00:17:11.370 --> 00:17:13.760
or maybe I want to
transmit that location.

00:17:13.760 --> 00:17:16.680
Maybe it's a social network,
something like that.

00:17:16.680 --> 00:17:19.980
It'd be really wasteful to
run the GPS the whole time.

00:17:20.150 --> 00:17:24.560
And if you take a high level picture of
what happens to a device when it moves,

00:17:24.640 --> 00:17:26.770
a variety of things change.

00:17:26.880 --> 00:17:31.120
For example, the cell tower that the
device is camped on changes.

00:17:31.130 --> 00:17:33.860
It may do scans for AutoJoin and
find different access points,

00:17:33.970 --> 00:17:37.920
or it may camp on different
access points if the device moves.

00:17:38.050 --> 00:17:41.600
And so we can actually
use that information,

00:17:41.810 --> 00:17:45.640
these new cell towers or seeing
different Wi-Fi access points,

00:17:45.680 --> 00:17:49.640
as a trigger to say, hey,
the user's probably moved.

00:17:49.810 --> 00:17:54.140
And if we know that, then at that point,
we can do a position calculation and

00:17:54.140 --> 00:17:59.160
notify your application if the user has,
in fact, moved a significant distance.

00:17:59.220 --> 00:18:03.170
So we call this the Significant
Location Change API.

00:18:04.120 --> 00:18:05.550
As I said,
it calculates the location when

00:18:05.550 --> 00:18:06.940
the device moves significantly.

00:18:06.940 --> 00:18:10.860
And the key advantage to this
API that you don't get with the

00:18:11.000 --> 00:18:15.120
standard location service is that your
application does not have to be running

00:18:15.490 --> 00:18:17.850
in order to receive these updates.

00:18:17.870 --> 00:18:20.620
And by not running,
I mean either it can be in

00:18:20.620 --> 00:18:24.000
the background suspended,
not receiving CPU time,

00:18:24.000 --> 00:18:26.930
or it can actually be
completely terminated,

00:18:26.930 --> 00:18:29.230
not in memory at all, not running.

00:18:29.240 --> 00:18:32.190
And it can still be notified in the
background when these events occur.

00:18:32.990 --> 00:18:36.050
And in iOS 5,
we've done a lot of work to improve

00:18:36.120 --> 00:18:38.460
the performance of this API.

00:18:38.510 --> 00:18:41.400
Whereas previously it functioned
exclusively based on cell towers,

00:18:41.400 --> 00:18:45.200
we've added a number of these triggers
that we talked about to make this

00:18:45.230 --> 00:18:49.460
API more accurate and ensure that you get
the notifications when the users move,

00:18:49.460 --> 00:18:52.290
even if it's not a huge distance,
even if in some cases it's not

00:18:52.370 --> 00:18:54.220
enough for them to move cell towers.

00:18:54.220 --> 00:18:58.480
So we think this is a great way to
keep your application location aware,

00:18:58.480 --> 00:19:02.900
aware of the user's context in those
situations where it's required.

00:19:03.370 --> 00:19:04.930
So how do you use it?

00:19:05.070 --> 00:19:09.500
So this is kind of the graphic I put up
for the standard location service before.

00:19:09.500 --> 00:19:11.900
And the reason that I put it up
here is because it's very similar.

00:19:12.020 --> 00:19:14.380
But instead of calling
startUpdatingLocation,

00:19:14.480 --> 00:19:20.410
we have a new API called
startMonitoringSignificantLocationChanges

00:19:20.410 --> 00:19:20.410
.

00:19:20.690 --> 00:19:23.840
And you call this API on
the CL Location Manager,

00:19:23.840 --> 00:19:25.400
and then you get the
same delegate callback.

00:19:25.490 --> 00:19:28.780
You get the same Location Manager,
did update to location,

00:19:29.040 --> 00:19:30.740
from location delegate callback.

00:19:30.920 --> 00:19:35.090
So you start in a different way,
but you get the locations from

00:19:35.090 --> 00:19:37.490
the same delegate callback.

00:19:38.560 --> 00:19:43.100
So that's the significant
location change API.

00:19:43.140 --> 00:19:43.820
And that's great.

00:19:43.820 --> 00:19:46.970
It keeps your applications kind
of in tune with where the user is

00:19:46.970 --> 00:19:50.800
without the costs of having your
application running all the time.

00:19:50.820 --> 00:19:55.230
But we found that there are classes
of applications that don't necessarily

00:19:55.550 --> 00:19:57.740
need to know every time the user moves.

00:19:57.740 --> 00:19:59.980
Rather,
what they care about is when the user

00:20:00.120 --> 00:20:02.240
goes to some locations of interest.

00:20:02.300 --> 00:20:04.360
So this is very similar to before.

00:20:04.370 --> 00:20:06.210
We have all these same
environmental signals.

00:20:06.300 --> 00:20:09.060
But rather than notifying
you just when the user moves,

00:20:09.060 --> 00:20:12.940
we can notify you when they get
to some area that you care about.

00:20:12.940 --> 00:20:14.600
In this case,
there's a coffee house here that

00:20:14.600 --> 00:20:20.070
maybe the user wanted to get
reminded of when they got near.

00:20:20.090 --> 00:20:22.650
And so we have the region monitoring API.

00:20:23.740 --> 00:20:28.010
And so what this does is it allows your
application to register locations of

00:20:28.070 --> 00:20:35.790
information in a surrounding region,
so that when the user

00:20:35.790 --> 00:20:35.790
enters or exits that region,
your application can be notified.

00:20:36.800 --> 00:20:38.890
And like the significant
Location Change API,

00:20:38.890 --> 00:20:43.410
your application can get launched in
the background even if it's not running.

00:20:43.820 --> 00:20:47.460
Now, we've had this API since iOS 4,
and at the time,

00:20:47.680 --> 00:20:50.080
it was based on cell positioning.

00:20:50.080 --> 00:20:54.820
We've made a lot of improvements
in iOS 5 to improve accuracy.

00:20:54.890 --> 00:20:58.140
Again, we're using these triggers
that we've defined.

00:20:58.240 --> 00:21:01.740
So for example,
if the user camps on a new Wi-Fi network,

00:21:01.740 --> 00:21:06.090
they associate or they disassociate,
or they turn the screen on their device,

00:21:06.200 --> 00:21:09.060
we use that as kind of
a trigger to know that,

00:21:09.200 --> 00:21:11.160
hey, the user's environment
has probably changed,

00:21:11.220 --> 00:21:14.420
to check to see whether they've moved.

00:21:14.700 --> 00:21:17.400
This is the same technology
that you'll see in the new

00:21:17.400 --> 00:21:20.200
Reminders application in iOS 5.

00:21:20.260 --> 00:21:23.410
So we think we've made a lot of
great strides towards building

00:21:23.410 --> 00:21:27.370
a really robust service that
your application can depend on.

00:21:28.920 --> 00:21:30.760
So, starting region monitoring.

00:21:30.790 --> 00:21:33.350
This is a little different in
that rather than just saying,

00:21:33.360 --> 00:21:36.960
"Go,
I want to start updating location," you

00:21:37.050 --> 00:21:39.560
specify the regions that you care about.

00:21:39.640 --> 00:21:44.240
And there are a few items of interest
that make up kind of these regions.

00:21:44.300 --> 00:21:47.360
There's a coordinate,
so a latitude and longitude.

00:21:47.410 --> 00:21:49.610
There's a radius,
which you can think of that as a

00:21:50.090 --> 00:21:53.000
boundary at which you want to get
these entry and exit notifications.

00:21:53.040 --> 00:21:56.160
When the user crosses that boundary,
you'll get notified.

00:21:56.240 --> 00:22:00.990
And then an identifier so that you
can refer to these regions later.

00:22:01.310 --> 00:22:05.700
You call the Start Monitoring for
Region API on CL Location Manager.

00:22:05.950 --> 00:22:10.160
And then when an event occurs,
you get the Location Manager did

00:22:10.190 --> 00:22:15.020
enter region or Location
Manager did exit region callbacks.

00:22:16.410 --> 00:22:18.510
All right.

00:22:18.610 --> 00:22:19.240
I already mentioned this.

00:22:19.340 --> 00:22:23.600
One other note is that we also make
use of every type of position now.

00:22:23.600 --> 00:22:25.890
In our iOS 4 API,
it was exclusively based

00:22:25.960 --> 00:22:27.240
on cell positioning.

00:22:27.330 --> 00:22:35.560
But if for some reason something on the
system happens to be using location,

00:22:35.560 --> 00:22:35.790
we'll use that as well.

00:22:35.790 --> 00:22:35.790
So that's one other improvement that
we've made to region monitoring.

00:22:37.300 --> 00:22:38.600
So those are the services.

00:22:38.730 --> 00:22:39.660
Those are how you use them.

00:22:39.660 --> 00:22:40.860
That's what they can do.

00:22:40.900 --> 00:22:43.240
And there's a lot of power there.

00:22:43.240 --> 00:22:46.060
We think that there's a lot of
potential here to enable great new

00:22:46.060 --> 00:22:48.760
use cases for your applications.

00:22:48.820 --> 00:22:52.260
But with all these great new use cases,
it becomes really important to make

00:22:52.260 --> 00:22:57.280
sure that the user stays in control of
how their location information is used.

00:22:58.390 --> 00:23:01.920
The reason for that is that
the more confident they are,

00:23:01.960 --> 00:23:05.360
the more likely they are to
use your new applications.

00:23:05.740 --> 00:23:09.780
And the reality is that no
matter how cool your use case is,

00:23:10.060 --> 00:23:15.240
no matter how amazing it is,
even if they paid money for your app

00:23:15.240 --> 00:23:21.760
and they downloaded it and they're
totally on board to use your application,

00:23:21.770 --> 00:23:22.230
not all users will have location
services enabled for your application.

00:23:23.290 --> 00:23:23.820
It's just a fact.

00:23:23.990 --> 00:23:25.180
It's a reality.

00:23:25.300 --> 00:23:29.240
And so what's really important to do
and what will really make your users

00:23:29.240 --> 00:23:34.440
be more confident in your application
is if you detect that and you provide

00:23:34.440 --> 00:23:41.350
context to the user that allows them
to understand the implications of their

00:23:41.700 --> 00:23:45.210
decision and lets them know what features
will and will not be available based

00:23:45.210 --> 00:23:45.210
on the availability of location services.

00:23:45.380 --> 00:23:48.850
So let's walk through some of the ways
in which users are allowed to make

00:23:48.930 --> 00:23:51.520
decisions regarding location services.

00:23:51.650 --> 00:23:54.120
The first thing is the
permission dialogue.

00:23:54.280 --> 00:23:57.650
This is presented once per application,
and it's the user's opportunity

00:23:57.810 --> 00:23:59.260
to make an additional decision.

00:23:59.490 --> 00:24:01.520
They can say allow or don't allow.

00:24:01.520 --> 00:24:05.970
And it's important to have a plan for
what happens if they say don't allow,

00:24:05.970 --> 00:24:08.180
even if that's not what you expect.

00:24:08.180 --> 00:24:12.790
We have a purpose property that allows
you to tell the user why your application

00:24:12.990 --> 00:24:15.050
needs to use location services.

00:24:15.310 --> 00:24:18.780
Now, you may not think this is necessary,
but there are a lot of applications

00:24:18.780 --> 00:24:22.140
where location is really,
really useful,

00:24:22.240 --> 00:24:25.880
but it's not necessarily immediately
apparent why it's needed.

00:24:25.940 --> 00:24:28.520
A good example is the
built-in camera app.

00:24:28.620 --> 00:24:31.310
It geotags photos so that the
users can later go into iPhoto,

00:24:31.310 --> 00:24:33.530
for example,
and see where they took their pictures,

00:24:33.580 --> 00:24:37.420
and even make those great
location-based slideshows.

00:24:37.650 --> 00:24:41.520
But it's not immediately apparent to
the user when they open the camera app

00:24:41.600 --> 00:24:43.760
why they would need to use location.

00:24:44.090 --> 00:24:46.370
So the purpose property is
your way of telling the user

00:24:46.380 --> 00:24:48.920
why location is important.

00:24:49.290 --> 00:24:51.300
There's the status bar icon.

00:24:51.340 --> 00:24:53.890
This is the user's indication
that an application in the system

00:24:54.190 --> 00:24:56.480
is using location services.

00:24:56.520 --> 00:24:58.850
And it's important to note that
this icon will stay present

00:24:59.170 --> 00:25:03.180
whenever your application has
access to the user's location.

00:25:03.270 --> 00:25:06.160
So this is straightforward
for the standard service.

00:25:06.160 --> 00:25:09.840
It'll be there whenever you've called
Start Updating Location and haven't

00:25:09.900 --> 00:25:12.620
called Stop Updating Location yet.

00:25:12.650 --> 00:25:16.100
But for the significant change
in region monitoring services,

00:25:16.120 --> 00:25:20.190
your application effectively has access
to the user's location the entire

00:25:20.190 --> 00:25:22.500
time that those services are active.

00:25:22.550 --> 00:25:26.080
Because by virtue of getting
notifications every time the user moves,

00:25:26.110 --> 00:25:28.700
when you don't get a notification,
you know the user hasn't moved,

00:25:28.790 --> 00:25:30.100
for example.

00:25:30.140 --> 00:25:32.680
As a result,
that icon will be present whenever

00:25:32.680 --> 00:25:34.500
any of the services are in use.

00:25:34.610 --> 00:25:36.790
So just be aware of that.

00:25:38.050 --> 00:25:41.100
If Location Services is
turned off on the device,

00:25:41.260 --> 00:25:44.700
the system will present prompts
a limited number of times,

00:25:44.870 --> 00:25:47.740
letting the user know that they
have disabled Location Services,

00:25:47.900 --> 00:25:50.540
and inviting the user to
change their decision.

00:25:50.680 --> 00:25:54.210
This won't always be shown to
avoid essentially pestering the

00:25:54.550 --> 00:25:57.680
user into turning on Location,
but it's a good hint that will show

00:25:57.720 --> 00:26:04.330
up a few times to let them know why
applications cannot use their Location.

00:26:05.040 --> 00:26:07.380
So that's what happens
in the application.

00:26:07.390 --> 00:26:10.980
However, the user also has the ability to
change their decision and to adjust

00:26:10.980 --> 00:26:14.920
their preferences in settings,
as well as to see which applications

00:26:14.920 --> 00:26:17.300
have used the location recently.

00:26:17.360 --> 00:26:19.380
So there's the Master Location
Services switch,

00:26:19.380 --> 00:26:22.780
which controls location
for all applications.

00:26:22.930 --> 00:26:25.820
There are the list of applications
that have used Location.

00:26:25.970 --> 00:26:29.560
Now, bear in mind that your application
will not show up in this list until the

00:26:29.590 --> 00:26:31.800
first time it uses Location Services.

00:26:31.800 --> 00:26:33.780
So just including the
framework isn't enough.

00:26:33.840 --> 00:26:35.580
The first time you request
a Location Service,

00:26:35.740 --> 00:26:36.810
you'll get an entry in this list.

00:26:36.850 --> 00:26:38.990
Your application will.

00:26:39.210 --> 00:26:42.190
There's a location arrow,
which is the user's guide to

00:26:42.270 --> 00:26:45.100
which applications have been
using their location recently.

00:26:45.160 --> 00:26:48.000
And it'll be displayed if
the application has used the

00:26:48.010 --> 00:26:50.120
location in the past 24 hours.

00:26:50.210 --> 00:26:52.210
And then finally,
there's the approval switch.

00:26:52.370 --> 00:26:56.440
And we have methods on-- we have class
methods on CL Location Manager that

00:26:56.440 --> 00:27:01.110
allow you to query this value
and respond appropriately to it.

00:27:01.860 --> 00:27:05.590
And the way that you do that is with
the CL Authorization Status enum

00:27:05.590 --> 00:27:11.540
and the Authorization Status class
method on CL Location Manager.

00:27:11.540 --> 00:27:14.620
This is new in iOS 4.2, actually.

00:27:14.620 --> 00:27:17.350
And I wanted to take some time to
guide you through kind of the different

00:27:17.630 --> 00:27:22.360
states that your application can be in
with regards to location authorization.

00:27:22.400 --> 00:27:24.160
There are actually four of them.

00:27:24.160 --> 00:27:26.720
The first one is that it's
just not determined yet.

00:27:26.720 --> 00:27:31.140
You haven't used a location API,
so the user hasn't been prompted yet.

00:27:31.200 --> 00:27:33.280
They haven't made a choice.

00:27:33.600 --> 00:27:36.300
There's the authorization state,
which is probably what you want,

00:27:36.300 --> 00:27:40.070
saying that you're okay,
you're good to go, you can use location.

00:27:40.210 --> 00:27:42.600
There's the denied state,
which means that the user has disabled

00:27:42.600 --> 00:27:46.050
either location services system-wide,
or just for your application,

00:27:46.250 --> 00:27:48.270
your application's individual switch.

00:27:48.640 --> 00:27:51.680
And then there's this fourth state,
which is a little bit subtle.

00:27:51.790 --> 00:27:53.810
It's the restricted state.

00:27:53.910 --> 00:27:58.100
And it's similar to the denied state
in that the user cannot use location

00:27:58.100 --> 00:28:00.150
services for your application.

00:28:00.370 --> 00:28:03.860
But unlike the denied state,
the user cannot authorize

00:28:03.860 --> 00:28:05.440
your application.

00:28:05.530 --> 00:28:08.850
And the way that they could get
into the state is if parental

00:28:08.950 --> 00:28:11.240
controls are enabled onto the device.

00:28:11.320 --> 00:28:16.280
We allow, through parental controls,
the ability to restrict changes

00:28:16.370 --> 00:28:18.980
in location authorization
for your application.

00:28:19.190 --> 00:28:21.920
So if it's either denied,
don't allow is hit,

00:28:21.970 --> 00:28:24.190
or your application hasn't
yet been authorized,

00:28:24.340 --> 00:28:28.820
the dialogue hasn't been presented,
you'll end up in this state

00:28:28.820 --> 00:28:30.300
if restrictions are enabled.

00:28:30.300 --> 00:28:32.550
But unlike the denied state,
the user really can't

00:28:32.610 --> 00:28:33.590
change the decision.

00:28:33.740 --> 00:28:36.150
So keep that in mind.

00:28:37.530 --> 00:28:39.260
Phew, that's a lot of stuff.

00:28:39.260 --> 00:28:42.050
There's really a lot to
learn about Core Location,

00:28:42.060 --> 00:28:44.880
how to use it,
and we're just adding more.

00:28:44.910 --> 00:28:48.670
And I'm really excited with this section
because it goes beyond coordinates,

00:28:48.700 --> 00:28:53.320
and latitudes, and longitudes, and speed,
and course, and it gets into things

00:28:53.320 --> 00:28:57.040
that users care about,
the way that users think about location.

00:28:57.040 --> 00:29:02.330
Because coordinates are
really only part of the story.

00:29:03.000 --> 00:29:06.450
We have this CL Location Manager,
and you call Startup Dating Location,

00:29:06.450 --> 00:29:08.980
and you get locations back,
and they come to your API.

00:29:08.980 --> 00:29:10.770
But they're just numbers.

00:29:10.950 --> 00:29:11.630
They're just these digits.

00:29:11.730 --> 00:29:15.500
And while you know what they mean,
your users don't.

00:29:15.530 --> 00:29:17.900
Users don't think in
latitude and longitude.

00:29:17.900 --> 00:29:21.580
They think in terms of descriptions,
in terms of addresses.

00:29:21.580 --> 00:29:27.730
When they think of the Moscone Center,
they think of places like,

00:29:27.880 --> 00:29:30.500
they think of addresses.

00:29:31.080 --> 00:29:33.620
And so, to this point,
it's been difficult to

00:29:33.620 --> 00:29:34.980
really do this conversion.

00:29:34.980 --> 00:29:37.270
The user tells you a location
that they care about,

00:29:37.280 --> 00:29:40.720
and you need to display it on a map,
or you need to convert that to

00:29:40.880 --> 00:29:42.240
coordinates for some other reason.

00:29:42.240 --> 00:29:45.570
Or you get a location back
from the location service,

00:29:45.710 --> 00:29:48.330
and you want to describe
that to the user.

00:29:48.470 --> 00:29:52.300
So in iOS 5, we are adding geo-coding
APIs to make this easier.

00:29:52.960 --> 00:29:55.300
Thank you.

00:29:55.310 --> 00:29:57.030
Pretty exciting.

00:29:58.000 --> 00:30:01.280
And we're adding both two
different types of geocoding.

00:30:01.310 --> 00:30:04.340
We're adding reverse geocoding,
which is the process of

00:30:04.470 --> 00:30:07.580
taking a coordinate and
turning it into an address.

00:30:07.620 --> 00:30:10.210
And then we're also adding,
and this is brand new in iOS,

00:30:10.340 --> 00:30:14.020
forward geocoding, which allows you to go
in the other direction,

00:30:14.020 --> 00:30:18.570
taking an address and
converting it to a lat-long.

00:30:19.180 --> 00:30:20.130
So why is this useful?

00:30:20.290 --> 00:30:23.080
Well, I've already given you the
high-level spiel about,

00:30:23.100 --> 00:30:25.140
you know, makes it meaningful.

00:30:25.150 --> 00:30:27.670
What are some concrete use cases?

00:30:28.020 --> 00:30:30.240
For one,
it allows you to describe a location.

00:30:30.240 --> 00:30:32.140
This is the basic,
you get a location back,

00:30:32.140 --> 00:30:33.900
and you want to display it on screen.

00:30:33.950 --> 00:30:35.400
You can do that.

00:30:35.570 --> 00:30:38.530
You can also do things like
locate an address book contact.

00:30:38.670 --> 00:30:42.410
You can present UI to allow the user
to select one of their contacts,

00:30:42.620 --> 00:30:46.840
and then immediately know what
that means in terms of coordinates.

00:30:47.040 --> 00:30:49.630
You can imagine applications
like tagging notes with the

00:30:49.740 --> 00:30:52.700
city where they were written.

00:30:52.700 --> 00:30:58.410
If you actually,
if you have the developer's installed

00:30:58.410 --> 00:31:02.000
and you go to the Compass application,
you can actually tap the bottom bar,

00:31:02.000 --> 00:31:02.000
and it'll give you a description
of where the user is right now.

00:31:02.000 --> 00:31:02.000
So that's a concrete example in iOS.

00:31:03.970 --> 00:31:05.710
The way that you do this
is with a new class we're

00:31:05.710 --> 00:31:07.830
introducing called CL Geocoder.

00:31:08.060 --> 00:31:11.660
And this is your way of doing both
forward and reverse geocoding.

00:31:11.910 --> 00:31:15.460
Again, forward is address to lat/long.

00:31:15.460 --> 00:31:17.610
Reverse is lat/long to address.

00:31:17.780 --> 00:31:18.630
Try and keep those in mind.

00:31:18.680 --> 00:31:21.100
It's not the most intuitive.

00:31:21.300 --> 00:31:23.460
This is a fully asynchronous API.

00:31:23.460 --> 00:31:26.220
Just like CL Location Manager,
you're not going to get

00:31:26.220 --> 00:31:27.590
results back immediately.

00:31:27.930 --> 00:31:32.290
So you basically make a request,
you get a result back when it's ready.

00:31:32.610 --> 00:31:35.410
You create one CL Geocoder per
request you're going to make.

00:31:35.620 --> 00:31:38.410
If you need to make multiple
requests at the same time,

00:31:38.510 --> 00:31:40.080
create multiple geocoders.

00:31:40.340 --> 00:31:42.460
So that's your entry point to geocoding.

00:31:42.530 --> 00:31:46.900
What you get back is this class
that is called CL Placemark.

00:31:46.970 --> 00:31:50.880
And this is returned as a result
from all geocoding requests,

00:31:50.880 --> 00:31:52.820
both forward and reverse.

00:31:52.890 --> 00:31:57.300
It contains a normalized location,
which is the location essentially

00:31:57.300 --> 00:31:59.810
associated with the broader
result that was returned.

00:31:59.860 --> 00:32:00.700
So for example,
if you provide a coordinate,

00:32:00.700 --> 00:32:04.580
and then you get back, you know,
a particular address,

00:32:04.580 --> 00:32:07.510
it will be the coordinate
associated with that address.

00:32:07.710 --> 00:32:10.450
It'll give you back a region if
the result that was returned is

00:32:10.450 --> 00:32:13.250
actually for some larger landmark,
like maybe you just got

00:32:13.250 --> 00:32:15.380
a neighborhood back,
or you got a university

00:32:15.380 --> 00:32:17.120
campus or something like that.

00:32:17.200 --> 00:32:20.240
You'll get back what we
call an address dictionary,

00:32:20.240 --> 00:32:24.090
which is an NSDictionary object
that contains keys and values in a

00:32:24.090 --> 00:32:28.320
normalized format that integrates
with the address book framework.

00:32:28.320 --> 00:32:31.590
And then finally, you'll get back some
descriptive properties.

00:32:32.330 --> 00:32:35.400
These are things like, for example,
if I were to geocode one

00:32:35.400 --> 00:32:37.520
infinite loop Cupertino,
California,

00:32:37.600 --> 00:32:39.590
you'll get back that that's Apple.

00:32:39.600 --> 00:32:44.120
Or if you geocode an ocean
or an inland body of water,

00:32:44.120 --> 00:32:47.510
you can actually get descriptions
back that give you kind of more

00:32:47.510 --> 00:32:51.840
detailed information about what
that geocoded location actually is.

00:32:51.840 --> 00:32:54.070
As I said earlier,
this all integrates really well

00:32:54.070 --> 00:32:55.720
with the address book framework.

00:32:55.720 --> 00:32:59.730
So you can take the store of information
you already have about essentially

00:32:59.730 --> 00:33:04.190
locations the users are interested in,
and really easily integrate

00:33:04.190 --> 00:33:06.790
that into your application.

00:33:08.540 --> 00:33:10.340
Using CL Geocoder.

00:33:10.540 --> 00:33:13.520
So CL Geocoder is a blocks-based API.

00:33:13.520 --> 00:33:17.660
Because it's asynchronous,
we actually need you to tell us what

00:33:17.660 --> 00:33:19.520
to do when we get the results back.

00:33:19.640 --> 00:33:22.320
In CL Location Manager,
we do that via delegate callbacks.

00:33:22.440 --> 00:33:26.720
You specify an object and basically say,
hey, when you're done, call this method,

00:33:26.920 --> 00:33:28.000
tell me what happened.

00:33:28.000 --> 00:33:30.030
On CL Geocoder, it's a little different.

00:33:30.110 --> 00:33:33.080
You provide a block,
which is essentially a piece of code that

00:33:33.080 --> 00:33:35.370
gets executed when the request completes.

00:33:35.430 --> 00:33:37.880
And we call that the completion handler.

00:33:38.400 --> 00:33:40.900
A completion handler takes
a couple of arguments.

00:33:41.020 --> 00:33:42.840
It takes an array of placemarks.

00:33:42.880 --> 00:33:45.300
The reason it's an array is essentially
there may be more than one result.

00:33:45.400 --> 00:33:48.660
You know, if the user just entered a
string that's a little ambiguous,

00:33:48.670 --> 00:33:50.630
we may not be exactly
sure what they meant,

00:33:50.630 --> 00:33:52.210
so we'll return multiple results.

00:33:52.400 --> 00:33:56.190
And then if an error occurred,
we'll pass you an error instead,

00:33:56.190 --> 00:33:58.310
letting you know what happened.

00:33:59.600 --> 00:34:00.820
So why might a geocode fail?

00:34:00.820 --> 00:34:03.040
Why might there be an error?

00:34:03.170 --> 00:34:05.200
The most common is a network error.

00:34:05.200 --> 00:34:08.860
This is a server-based API,
and so a data connection is necessary.

00:34:08.880 --> 00:34:11.000
On devices that have an
always active connection,

00:34:11.000 --> 00:34:12.420
this isn't such a big deal.

00:34:12.560 --> 00:34:15.740
But if you're on, say, an iPod Touch,
and it's not connected to WiFi,

00:34:16.120 --> 00:34:18.400
you'll get a network error back.

00:34:18.440 --> 00:34:20.870
We may not have any results.

00:34:20.900 --> 00:34:22.460
I think we've done a great job,
and you'll hear more about

00:34:22.490 --> 00:34:24.740
this later about our coverage.

00:34:24.780 --> 00:34:27.500
But particularly if just the
query we got was nonsensical,

00:34:27.500 --> 00:34:28.920
we can't make sense of it.

00:34:29.100 --> 00:34:31.690
we may not have any results for you.

00:34:31.920 --> 00:34:35.520
If you're doing a reverse geocode, again,
coordinates to an address,

00:34:35.570 --> 00:34:39.220
and we don't have a network connection,
we can actually do what's called

00:34:39.260 --> 00:34:41.090
a partial result device side.

00:34:41.100 --> 00:34:46.750
We can tell you what country,
at the very least, that coordinate is in,

00:34:46.750 --> 00:34:49.400
just based on a device side database.

00:34:49.520 --> 00:34:52.060
And then finally, you can cancel requests
once they're in flight,

00:34:52.250 --> 00:34:54.100
and if you do that,
you'll get a canceled callback.

00:34:54.230 --> 00:34:56.690
So those are the reasons
why they might fail.

00:34:57.860 --> 00:35:01.600
So I mentioned a little bit about the
address book and how they work together.

00:35:01.660 --> 00:35:03.220
But there's a variety of
things that you can do.

00:35:03.220 --> 00:35:06.450
The first thing is you can use
the people picker to turn the

00:35:06.450 --> 00:35:08.070
contact's address into a location.

00:35:08.140 --> 00:35:14.300
And I'll go through exactly
how to do that later.

00:35:14.760 --> 00:35:17.760
You can store a returned
address that you got,

00:35:17.760 --> 00:35:17.760
say, from a geocode,
into the user's address book.

00:35:18.120 --> 00:35:19.550
And then finally,
you can also use the address

00:35:19.670 --> 00:35:23.100
book to format a return address
in a way that's appropriate for

00:35:23.100 --> 00:35:24.900
the device's current locale.

00:35:25.490 --> 00:35:26.480
So that's a lot of stuff.

00:35:26.480 --> 00:35:29.360
I'd like to invite Richard Heard,
who works on our frameworks team,

00:35:29.360 --> 00:35:31.740
who's going to give you a
demo of how all this works.

00:35:31.870 --> 00:35:33.710
Take it away, Richard.

00:35:37.320 --> 00:35:38.100
Thanks, Morgan.

00:35:38.160 --> 00:35:42.320
So today, I'm going to demonstrate to you
a simple geocoding application

00:35:42.850 --> 00:35:46.440
that uses the geocoding operations

00:35:49.420 --> 00:35:52.500
So first up,
let's have a look at forward geocoding.

00:35:52.620 --> 00:35:55.470
Forward geocoding is
where we take an address,

00:35:55.550 --> 00:35:59.730
either a string or a dictionary,
and convert it into a set of coordinates.

00:35:59.910 --> 00:36:04.520
So for this example,
I'm going to use Castro Street,

00:36:04.520 --> 00:36:05.810
San Francisco.

00:36:10.530 --> 00:36:12.380
I'm going to leave the region hint unset.

00:36:12.380 --> 00:36:16.530
This implies the device's
current location.

00:36:16.610 --> 00:36:18.460
And now let's perform the geocode.

00:36:18.530 --> 00:36:22.660
So again, we returned an array of
CL placemark objects.

00:36:22.710 --> 00:36:25.530
So let's have a look at the
properties on the placemark.

00:36:27.090 --> 00:36:29.000
Okay, that looks like Castro Street.

00:36:29.120 --> 00:36:33.680
So first up, we have our location object,
which is a seal location.

00:36:33.810 --> 00:36:38.320
And the important property here
is actually the coordinate.

00:36:39.240 --> 00:36:42.860
Next up, we have a region,
which in this case is not set.

00:36:42.890 --> 00:36:48.780
This is only set, again, if it's a large
geographic region or area.

00:36:48.920 --> 00:36:52.380
And finally, we have the normalized
address dictionary.

00:36:52.510 --> 00:36:58.220
In this case, we can see Castro Street,
San Francisco, Noe Valley, California,

00:36:58.330 --> 00:36:59.740
and the postcode.

00:36:59.920 --> 00:37:02.130
So that's string geocoding.

00:37:04.730 --> 00:37:08.960
So now, let's have a look at
dictionary geocoding.

00:37:09.240 --> 00:37:12.060
For this example,
I'm going to select a contact

00:37:12.060 --> 00:37:13.680
from the address book.

00:37:16.280 --> 00:37:24.870
You'll note that the address here,
John's work address,

00:37:24.870 --> 00:37:27.330
does not actually have a postcode.

00:37:27.330 --> 00:37:27.330
However, this isn't a problem
for the Geocoding API,

00:37:27.330 --> 00:37:27.330
even when you're using
the address dictionary.

00:37:29.780 --> 00:37:33.380
So let's perform the geocode.

00:37:33.730 --> 00:37:36.800
Again, an array of CL placemarks.

00:37:37.070 --> 00:37:39.750
And there we go, 333 Bush.

00:37:39.880 --> 00:37:42.040
So we have our location.

00:37:42.110 --> 00:37:45.210
We have a region,
which in this case is not set.

00:37:45.400 --> 00:37:48.250
And we have a fully
formatted address dictionary.

00:37:48.450 --> 00:37:52.760
You'll note that we've actually been
returned the postcode or the zip code.

00:37:52.860 --> 00:37:56.530
So this is a really cool way of
cleaning up an address that you're

00:37:56.530 --> 00:37:59.060
pulling from the address book.

00:37:59.170 --> 00:38:00.530
So that's forward geocoding.

00:38:00.680 --> 00:38:03.490
So now let's have a look
at reverse geocoding.

00:38:04.790 --> 00:38:08.550
In this case, for this example,
I'm going to use the

00:38:08.550 --> 00:38:11.260
device's current location.

00:38:11.270 --> 00:38:15.090
So there's our standard location alert.

00:38:15.120 --> 00:38:16.740
Cool.

00:38:16.740 --> 00:38:19.610
Now let's perform the reverse geocode.

00:38:21.020 --> 00:38:23.430
And again,
we returned an array of CL placemarks,

00:38:23.510 --> 00:38:25.880
in this case, one.

00:38:25.980 --> 00:38:28.390
And here's our address dictionary.

00:38:28.390 --> 00:38:31.240
So it looks like we're on Fourth Street.

00:38:31.280 --> 00:38:34.080
I think that's probably
the Moscone Center.

00:38:34.800 --> 00:38:40.610
So here's our region, again, not set,
and finally, a normalized location.

00:38:40.840 --> 00:38:43.590
So that's reversed geocoding.

00:38:44.940 --> 00:38:49.240
So now I've got a demo of
a semi-real-world example,

00:38:49.290 --> 00:38:49.690
at least.

00:38:49.720 --> 00:38:53.260
I was talking to a friend last night,
and he's in town for the

00:38:53.260 --> 00:38:54.270
conference at the moment.

00:38:54.280 --> 00:38:58.750
And we were trying to work out how far
it is from Melbourne to San Francisco.

00:38:58.800 --> 00:39:01.820
We guessed it was about
12,000 kilometers.

00:39:01.820 --> 00:39:05.320
But using this example,
we now can calculate it exactly.

00:39:05.320 --> 00:39:08.300
So I'm going to search for Melbourne.

00:39:08.300 --> 00:39:12.820
Okay.

00:39:14.440 --> 00:39:17.310
and let's select San Francisco.

00:39:22.930 --> 00:39:24.390
Okay.

00:39:24.540 --> 00:39:25.360
There we go.

00:39:25.420 --> 00:39:28.540
12,698 kilometers.

00:39:28.760 --> 00:39:29.800
So that's geocoding.

00:39:29.900 --> 00:39:37.570
And this is actually-- this sample
application should be available to

00:39:37.570 --> 00:39:41.470
you today on the session website.

00:39:41.470 --> 00:39:43.180
So with that,
I'd like to hand back over to Morgan,

00:39:43.180 --> 00:39:43.180
who will go over a little
bit more about geocoding.

00:39:46.420 --> 00:39:48.460
Thanks, Richard.

00:39:48.690 --> 00:39:52.310
So hopefully that demo gives you
just a bit of an idea of what you

00:39:52.310 --> 00:39:54.310
can accomplish with geocoding.

00:39:54.450 --> 00:39:57.260
Now, I'm going to give you just a little
bit of an idea of how the API works.

00:39:57.380 --> 00:39:59.680
I'm going to skip part of this
because we're running short on time,

00:39:59.680 --> 00:40:04.280
and I want to make sure we get to some of
the cool other stuff we have to show you.

00:40:04.370 --> 00:40:07.860
The basics are that you
create a CL Geocoder object.

00:40:08.090 --> 00:40:09.950
It's just a straight alloc init.

00:40:10.050 --> 00:40:11.700
In this case,
we're doing reverse geocoding,

00:40:11.840 --> 00:40:13.640
so we want to create a location.

00:40:13.850 --> 00:40:17.660
So you pass in a CL Location
coordinate corresponding to,

00:40:17.660 --> 00:40:20.150
in this case, I believe this is Apple.

00:40:20.540 --> 00:40:24.880
And then what you do is you tell the
geocoder to reverse geocode the location.

00:40:25.030 --> 00:40:29.290
So you pass in the CLLocation object,
and then the other thing you

00:40:29.300 --> 00:40:33.160
pass in is this thing that
we call a completion handler.

00:40:33.220 --> 00:40:36.510
And again,
this essentially defines what you

00:40:36.510 --> 00:40:39.080
want to do when the request finishes.

00:40:39.460 --> 00:40:41.690
Now, in this case,
I'm just kind of iterating through

00:40:41.770 --> 00:40:44.290
the placemarks and logging them,
but you probably want to do

00:40:44.290 --> 00:40:46.980
something like update your UI,
pass the placemarks off

00:40:47.110 --> 00:40:48.400
to something like that.

00:40:48.400 --> 00:40:52.400
The demo that Richard showed you has
more concrete examples of how to do that.

00:40:52.400 --> 00:40:54.400
But at a basic level, it's really easy.

00:40:54.400 --> 00:40:57.590
You just have the location that you need,
you pass it in, say,

00:40:57.590 --> 00:41:00.400
reverse geocode this, and when it's done,
here's what I want to do.

00:41:00.400 --> 00:41:03.620
It really keeps the notion
of I want to geocode,

00:41:03.620 --> 00:41:07.430
and what do I do when it's
done really close together.

00:41:08.960 --> 00:41:12.480
Now, for forward geocoding,
there are two options, as Richard showed.

00:41:12.550 --> 00:41:16.000
The first one is to
use an address string.

00:41:16.250 --> 00:41:19.290
And this is essentially just a
string maybe taken from a user,

00:41:19.290 --> 00:41:23.470
from a text field, something like that,
that describes the dictionary-- or sorry,

00:41:23.590 --> 00:41:24.700
that describes the address.

00:41:24.770 --> 00:41:27.900
So in this case,
we just have one infinite loop,

00:41:27.900 --> 00:41:29.080
Cupertino.

00:41:29.110 --> 00:41:32.300
But once you have that, the process is,
again, very similar.

00:41:32.320 --> 00:41:35.220
You tell your geocode to
geocode this address string.

00:41:35.450 --> 00:41:37.000
You pass in the string.

00:41:37.050 --> 00:41:39.520
And then again, you define the completion
handler that says,

00:41:39.600 --> 00:41:41.000
here's what I want to do when it's done.

00:41:41.040 --> 00:41:43.200
And that's code that you would provide.

00:41:45.210 --> 00:41:49.500
The last thing that you can do
is to use an address dictionary.

00:41:49.580 --> 00:41:53.140
And the way that you do this
is-- the most common way that you

00:41:53.140 --> 00:41:57.200
would get an address dictionary
is from the Address Book API.

00:41:57.270 --> 00:42:01.430
But just for clarity here,
I'm going to build one myself.

00:42:01.540 --> 00:42:05.550
So in this case,
I've got my street as one infinite loop,

00:42:05.780 --> 00:42:09.380
my city as Cupertino,
and my state as California.

00:42:09.380 --> 00:42:11.430
And I want to geocode that.

00:42:11.430 --> 00:42:12.680
So I have this dictionary
that I've created.

00:42:12.750 --> 00:42:15.850
I pass into the geocoder,
I pass the NSDictionary object,

00:42:15.860 --> 00:42:17.940
and again,
I define my completion handler.

00:42:18.020 --> 00:42:21.740
So you just have your data, you say,
"Geocode it." When it's done,

00:42:21.790 --> 00:42:22.930
here's what I do.

00:42:23.080 --> 00:42:24.980
It's pretty straightforward.

00:42:26.250 --> 00:42:31.340
Now,
how do you actually get an address from

00:42:31.340 --> 00:42:34.240
the address book into the geocoder?

00:42:34.560 --> 00:42:36.650
So there are actually
four different steps.

00:42:36.830 --> 00:42:39.640
I'm not going to go through the code,
but just to give you an idea.

00:42:39.680 --> 00:42:41.960
The first thing is to
present the people picker.

00:42:41.960 --> 00:42:46.550
This is a standard view controller that's
provided by the address book UI class.

00:42:46.770 --> 00:42:49.220
From there,
you allow the user to navigate

00:42:49.220 --> 00:42:51.520
to retrieve the selected address.

00:42:51.520 --> 00:42:54.420
You could then geocode it,
and then format it

00:42:54.420 --> 00:42:56.200
however you would like.

00:42:56.700 --> 00:43:00.080
So presenting the people picker,
you basically create this

00:43:00.120 --> 00:43:02.790
navigation controller,
and this is the UI that you get.

00:43:02.840 --> 00:43:07.640
It's the standard UI,
very similar to the Contacts application.

00:43:07.640 --> 00:43:10.520
And it provides you with a list.

00:43:10.520 --> 00:43:13.320
And then from there,
you present the view controller.

00:43:13.320 --> 00:43:16.460
But once you get there,
the user will present-- will

00:43:16.520 --> 00:43:19.950
essentially select an address
on a particular contact card.

00:43:20.270 --> 00:43:24.340
And then once they select that,
you essentially get that address

00:43:24.360 --> 00:43:27.780
back via a delegate callback
from the address UI framework,

00:43:27.780 --> 00:43:29.400
address book UI framework.

00:43:29.460 --> 00:43:31.990
Once you have that,
it's very similar to before.

00:43:32.200 --> 00:43:35.810
You just create your geocoder,
tell it to geocode that

00:43:35.810 --> 00:43:39.830
address dictionary,
and then do whatever you

00:43:39.830 --> 00:43:41.200
want in response to it.

00:43:41.260 --> 00:43:44.200
And then obviously at the end,
you need to dismiss your view controller.

00:43:44.280 --> 00:43:49.190
Again, the sample code shows you
how to do this in detail.

00:43:50.950 --> 00:43:55.300
So that's a lot about the service and
kind of how to use it from our side,

00:43:55.300 --> 00:43:58.780
but there's a lot of data
backing the service as well.

00:43:58.990 --> 00:44:06.280
So at this point, I'd like to invite up
Pierre-Luc Beaudoin,

00:44:06.280 --> 00:44:10.250
who is one of our iOS server engineers,
to discuss the data backing this service.

00:44:10.250 --> 00:44:10.250
PIERRE-LUC BEAUDOIN: Thank you.

00:44:11.510 --> 00:44:13.060
Hi.

00:44:13.380 --> 00:44:15.000
So I am Pierre-Luc Beaudoin.

00:44:15.000 --> 00:44:17.700
I work on the iOS server team.

00:44:18.190 --> 00:44:23.210
By now you are probably very
excited about this new service,

00:44:23.210 --> 00:44:23.210
and...

00:44:23.340 --> 00:44:25.760
I can see questions that you might have,
such as,

00:44:25.760 --> 00:44:28.010
who's going to be able to use this?

00:44:28.010 --> 00:44:30.640
And is this going to be limited at first?

00:44:30.760 --> 00:44:33.900
Well, we are actually very happy
to announce that we are

00:44:33.900 --> 00:44:37.440
launching with global coverage.

00:44:38.860 --> 00:44:42.270
We have-- thank you.

00:44:42.330 --> 00:44:47.540
We have extensive coverage for all the
major international iPhone markets.

00:44:47.590 --> 00:44:51.790
We also spent a great deal
of time localizing this data.

00:44:52.160 --> 00:44:57.020
And you should be able to
search for any significant city,

00:44:57.280 --> 00:45:02.650
state,
or country in any of these 30 languages.

00:45:04.620 --> 00:45:06.470
And let's have an example
of what that means.

00:45:06.500 --> 00:45:13.320
For any point in the world,
the user should be able to read the

00:45:13.320 --> 00:45:16.400
returned address in their language.

00:45:17.280 --> 00:45:20.870
We also support local languages
down to the street level.

00:45:21.150 --> 00:45:23.560
And let's have an example
of what that means.

00:45:23.610 --> 00:45:26.920
Let's suppose you're
a tourist in Brussels,

00:45:26.990 --> 00:45:29.140
in Europe,
and you would like to taste some

00:45:29.140 --> 00:45:31.640
of the very good local beers.

00:45:32.770 --> 00:45:34.940
That's you.

00:45:34.950 --> 00:45:39.470
Now, you look into your guide
and your American guidebook.

00:45:39.740 --> 00:45:42.170
It sends you to this address.

00:45:42.880 --> 00:45:48.550
This is the address of a very well-known
cafe where you can taste a lot of beers.

00:45:48.810 --> 00:45:52.950
And by the way,
you don't have to be that much

00:45:52.950 --> 00:45:57.140
specific when you enter an address,
but for the sake of this example,

00:45:57.200 --> 00:45:59.000
let's keep the country in.

00:45:59.760 --> 00:46:02.980
Now, suppose you're a French speaker
living in Brussels.

00:46:03.030 --> 00:46:05.640
How would this address look like?

00:46:05.710 --> 00:46:08.020
It would-- oh, French.

00:46:08.380 --> 00:46:10.510
It would look like this.

00:46:10.920 --> 00:46:13.000
Notice how different it is.

00:46:13.180 --> 00:46:14.730
The ordering has changed.

00:46:15.000 --> 00:46:17.120
Both the country and
city name have changed.

00:46:17.120 --> 00:46:23.910
Now, how would it look if you're a
Dutch speaker living in Brussels?

00:46:24.710 --> 00:46:27.540
It would actually look like this.

00:46:27.580 --> 00:46:31.880
Again, a completely different address.

00:46:31.920 --> 00:46:34.000
Let's compare them.

00:46:35.630 --> 00:46:40.410
This happens because every street
in Brussels have both a French name

00:46:40.540 --> 00:46:42.920
and an official Dutch name.

00:46:44.150 --> 00:46:47.260
But let me reassure you,
this is something your application

00:46:47.260 --> 00:46:52.320
doesn't have to care for,
because all happens on the API side.

00:46:52.360 --> 00:46:56.640
Your application needs to
ask the user for an address,

00:46:56.950 --> 00:47:00.890
And then the user will use
their natural language.

00:47:00.890 --> 00:47:06.360
And our API will return a longitude and a
latitude for your application to consume.

00:47:06.400 --> 00:47:09.950
And there's really nothing
else required from your site.

00:47:11.970 --> 00:47:15.100
Now,
let's have a reverse geocoding example.

00:47:15.160 --> 00:47:20.420
Let's say you are reverse geocoding a
point on the San Francisco City Hall,

00:47:20.620 --> 00:47:23.080
and your device is set to English.

00:47:23.160 --> 00:47:26.680
Here's the address it would be given.

00:47:27.400 --> 00:47:31.490
Now you can see we are returning multiple
levels of geographic containment,

00:47:31.490 --> 00:47:36.100
and from locality and down,
those will be localized.

00:47:36.250 --> 00:47:40.730
So let's see what happens when
your device is set to Polish.

00:47:42.700 --> 00:47:46.730
In that case,
the state and the country name changed,

00:47:46.760 --> 00:47:50.110
because it happens that
San Francisco is the same in Polish.

00:47:50.300 --> 00:47:54.500
But if your device is set to Russian,
it would look like this.

00:47:54.960 --> 00:48:01.130
Again, from locality and down,
it is localized so the users can read it.

00:48:02.220 --> 00:48:03.700
So let's recap.

00:48:03.730 --> 00:48:09.680
We are launching a global service
with support for multiple languages,

00:48:09.720 --> 00:48:14.220
and the result will automatically
match the device's locale.

00:48:14.240 --> 00:48:15.730
Thank you.

00:48:18.960 --> 00:48:21.240
Thanks, Pierre-Luc.

00:48:21.410 --> 00:48:24.970
So this is pretty exciting.

00:48:25.120 --> 00:48:27.360
As he mentioned,
we've got this brand new service

00:48:27.840 --> 00:48:32.300
that does both forward and
reverse geocoding that we're

00:48:32.300 --> 00:48:33.960
launching with global coverage.

00:48:33.980 --> 00:48:36.930
It's fully localized,
and your application doesn't need

00:48:37.030 --> 00:48:38.420
to care about any of the details.

00:48:38.450 --> 00:48:40.760
It'll just work for you.

00:48:40.800 --> 00:48:42.990
You may have some questions.

00:48:43.340 --> 00:48:48.350
We already have a reverse geocoding
API in MapKit called MK Reverse Geocoder,

00:48:48.420 --> 00:48:50.240
and we've had it for a while.

00:48:50.320 --> 00:48:54.440
So you may be wondering,
how does this relate to CL Geocoder?

00:48:54.560 --> 00:48:57.590
And the answer is that CL Geocoder
has a number of advantages

00:48:57.710 --> 00:49:00.440
over the MK Reverse Geocoder.

00:49:00.560 --> 00:49:03.440
The first one, the most obvious one,
is that we do both forward

00:49:03.440 --> 00:49:05.110
and reverse geocoding.

00:49:05.200 --> 00:49:07.260
The MapKit team, I'm sure,
can tell you that they've gotten many,

00:49:07.260 --> 00:49:10.800
many requests over the
years for forward geocoding.

00:49:10.940 --> 00:49:13.720
So we think this is a
really great step forward.

00:49:13.890 --> 00:49:18.360
The other condition that you may
be aware of surrounding MK Reverse

00:49:18.480 --> 00:49:23.300
Geocoder is that it requires that
locations be displayed on a map.

00:49:23.300 --> 00:49:25.640
That's why the API is in MapKit.

00:49:25.640 --> 00:49:29.040
You are geocoding locations for the
purposes of showing them on a map.

00:49:29.160 --> 00:49:32.160
In CL Geocoder,
we've dropped that requirement.

00:49:32.160 --> 00:49:35.690
You can do forward,
you can do reverse geocoding,

00:49:36.020 --> 00:49:38.740
and you can present those results
however you would like to in

00:49:38.800 --> 00:49:40.550
the context of your application.

00:49:41.010 --> 00:49:47.830
As a result, going forward,
we are deprecating the MapKit geocoder.

00:49:47.830 --> 00:49:52.990
We're really excited about CL Geocoder,
and we're really looking

00:49:52.990 --> 00:49:52.990
that moving forward,
applications will move to CL Geocoder.

00:49:53.300 --> 00:49:54.240
But don't worry.

00:49:54.240 --> 00:49:58.920
We're well aware that a lot of use
cases for geocoding are map-based.

00:49:58.940 --> 00:50:02.370
And we've worked really closely
with the MapKit team to ensure that

00:50:02.390 --> 00:50:05.990
CL Geocoder integrates well with MapKit.

00:50:06.220 --> 00:50:09.480
So if you'd like more
information on what that means,

00:50:09.640 --> 00:50:14.070
transitioning your MapKit-based
application to use CL Geocoder,

00:50:14.170 --> 00:50:17.390
and essentially how the
two APIs work together,

00:50:17.390 --> 00:50:21.950
I'd highly recommend going to the
MapKit session tomorrow morning,

00:50:21.950 --> 00:50:25.900
bright and early, in Russian Hill,
that talks about-- the

00:50:25.900 --> 00:50:30.220
title is Visualizing
Information Geographically with MapKit.

00:50:30.300 --> 00:50:31.370
They are talking about how to integrate
this new geocoding service into the API.

00:50:32.250 --> 00:50:35.310
So, wrapping up,
we covered a lot of stuff.

00:50:35.320 --> 00:50:38.640
Use Location to improve
your users' experience.

00:50:38.640 --> 00:50:41.420
There's a lot of potential.

00:50:41.540 --> 00:50:42.600
We're just starting to see the beginning.

00:50:42.600 --> 00:50:44.950
Make sure to choose the right service.

00:50:45.080 --> 00:50:47.810
We have the standard service,
the significant change service,

00:50:47.840 --> 00:50:49.470
and the region monitoring service.

00:50:49.470 --> 00:50:50.980
They're designed for different things.

00:50:50.980 --> 00:50:52.130
They have different trade-offs.

00:50:53.160 --> 00:50:55.260
And lastly,
we're really looking forward to

00:50:55.350 --> 00:50:58.830
seeing how you use this new geocoding
service to make location data even

00:50:58.830 --> 00:51:00.570
more meaningful for your users.

00:51:00.640 --> 00:51:03.200
No matter where they're from,
where they're traveling to,

00:51:03.200 --> 00:51:05.620
what language they speak,
your application can

00:51:05.720 --> 00:51:09.100
provide that experience,
and it can get it for free

00:51:09.100 --> 00:51:11.300
from our new Geocoder API.

00:51:11.780 --> 00:51:13.570
If you need more information
on any of these new APIs,

00:51:13.570 --> 00:51:15.330
I'd really encourage you
to contact Vicky Murley,

00:51:15.470 --> 00:51:16.310
who's our evangelist.

00:51:16.380 --> 00:51:18.140
Her contact information is there.

00:51:18.210 --> 00:51:20.090
Or consult the documentation.

00:51:20.100 --> 00:51:23.580
We've updated both the framework
reference as well as the location

00:51:23.580 --> 00:51:27.490
awareness programming guide,
with information about geocoding and

00:51:27.570 --> 00:51:29.980
how all of the services fit together.

00:51:30.050 --> 00:51:31.860
And of course,
there's always your good friend,

00:51:31.970 --> 00:51:34.030
the developer forums,
that allow you to get help

00:51:34.030 --> 00:51:35.250
from other developers.

00:51:35.350 --> 00:51:39.150
With that, oh yes,
there are also some more sessions.

00:51:39.240 --> 00:51:42.220
So I also mentioned the MapKit session,
which is tomorrow.

00:51:42.230 --> 00:51:44.210
And the other thing that
we're really excited about,

00:51:44.210 --> 00:51:46.100
and that you probably heard
a bit about yesterday,

00:51:46.100 --> 00:51:50.190
is that in iOS 5, for the first time,
we're adding ways to test your

00:51:50.190 --> 00:51:52.930
location of your application
without getting in a car.

00:51:52.960 --> 00:51:55.740
We're adding simulator support,
and we're adding a bunch of great new

00:51:55.770 --> 00:51:58.480
developer tools to make that easy.

00:51:59.990 --> 00:52:02.340
And we're so excited about that,
there just wasn't room

00:52:02.410 --> 00:52:03.090
for that in the session.

00:52:03.100 --> 00:52:06.700
So we're having a special
session on Friday at 9:00.

00:52:06.700 --> 00:52:08.210
I'll be there giving that talk.

00:52:08.340 --> 00:52:15.160
And I hope you'll join me to find
out all of the ways that you can

00:52:15.160 --> 00:52:18.520
build really robust location-aware
applications that your users will love.

00:52:18.520 --> 00:52:18.520
Thank you very much.

00:52:18.520 --> 00:52:18.520
Thanks for listening.
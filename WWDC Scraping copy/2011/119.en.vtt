WEBVTT

00:00:10.830 --> 00:00:13.950
Welcome to session 119,
Resume and Automatic

00:00:14.060 --> 00:00:16.490
Termination in Mac OS X Lion.

00:00:16.630 --> 00:00:18.090
My name's Peter Ammon.

00:00:18.380 --> 00:00:21.300
I'm an engineer on the
Cocoa Frameworks team.

00:00:21.410 --> 00:00:25.090
We're talking about Resume
and Automatic Termination.

00:00:26.890 --> 00:00:31.330
So Lion is about bringing features
from iOS forward to the Mac.

00:00:31.530 --> 00:00:34.630
And one of the features that
users love on iOS is how apps

00:00:34.630 --> 00:00:36.750
pick up where they left off.

00:00:36.750 --> 00:00:40.800
When you switch to an app,
it restores its state.

00:00:40.800 --> 00:00:43.500
And the app may or may
not have terminated.

00:00:43.680 --> 00:00:46.850
The underlying Unix process may
or may not have exited in the

00:00:46.860 --> 00:00:50.200
time between you switching away
and switching back to the app.

00:00:50.480 --> 00:00:53.020
Users don't know and they don't care.

00:00:53.130 --> 00:00:56.130
This is a much simpler application
model than we have on Snow Leopard

00:00:56.580 --> 00:01:00.520
where users must manually quit
and relaunch applications.

00:01:00.640 --> 00:01:04.170
So Mac OS X Lion is moving
in that same direction.

00:01:04.250 --> 00:01:08.630
And two ways in which we're
doing that are called Resume

00:01:08.730 --> 00:01:10.890
and Automatic Termination.

00:01:12.590 --> 00:01:14.780
So I'll start by talking about Resume.

00:01:14.890 --> 00:01:16.480
We'll go over the API.

00:01:16.520 --> 00:01:18.140
We'll see a bunch of demos.

00:01:18.200 --> 00:01:21.500
And then in the second portion,
I'll bring out my colleague, David Smith,

00:01:21.580 --> 00:01:25.490
who will talk about Automatic
Termination and show you a demo of that.

00:01:27.970 --> 00:01:31.510
So, Resume.

00:01:31.510 --> 00:01:34.090
As you may have guessed,
the point of Resume is that apps

00:01:34.270 --> 00:01:36.790
simply resume where they left off.

00:01:36.890 --> 00:01:41.340
and they do this after quit,
logout or a crash.

00:01:41.420 --> 00:01:45.110
And I'm going to show you a
demo of that last one right now.

00:01:52.900 --> 00:01:55.120
This is a Mac OS X Lion.

00:01:55.340 --> 00:01:58.500
I'll start by launching
a few applications.

00:01:58.510 --> 00:02:01.960
There's a text-edited app
with a few documents open.

00:02:02.040 --> 00:02:05.840
We'll open a picture of a lion.

00:02:05.930 --> 00:02:06.300
Put that there.

00:02:06.300 --> 00:02:07.780
I'll open Safari.

00:02:07.780 --> 00:02:10.800
Maybe a few Finder windows.

00:02:10.800 --> 00:02:14.780
Let me make this a little smaller.

00:02:19.370 --> 00:02:22.590
So what I'm going to do is
send sigkill to login window.

00:02:22.590 --> 00:02:25.520
And that's going to effectively
crash login window and by extension

00:02:25.520 --> 00:02:29.290
all the applications including
finder text that you see here.

00:02:29.310 --> 00:02:31.650
And if all goes well,
what you will see is that the screen

00:02:31.650 --> 00:02:34.550
will go a little wonky for a few
seconds and then all the applications

00:02:34.610 --> 00:02:36.300
will come back as if I had never left.

00:02:36.300 --> 00:02:38.880
So let's give it a try.

00:02:43.930 --> 00:02:48.800
Isn't that cool?

00:02:48.800 --> 00:02:50.190
So let's be clear about
what just happened.

00:02:50.200 --> 00:02:51.290
All the processes died.

00:02:51.350 --> 00:02:53.420
They all restored their state
when they were relaunched,

00:02:53.450 --> 00:02:56.120
and they did it just using the
APIs that I'll show you today.

00:02:56.180 --> 00:03:00.980
And to prove that, I'm going to turn on
private browsing in Safari.

00:03:01.030 --> 00:03:05.110
Now, when private browsing is on,
of course, the application doesn't--

00:03:05.320 --> 00:03:07.560
The windows are not written to disk.

00:03:07.560 --> 00:03:09.640
No state about them is recorded,
not in the bookmarks or

00:03:09.660 --> 00:03:12.300
history or any of that,
including in Resume.

00:03:12.300 --> 00:03:14.880
So when I repeat this exercise,
notice by the way it remembered

00:03:14.880 --> 00:03:17.300
the last command I did,
which was kill all.

00:03:17.300 --> 00:03:20.390
When I repeat this,
I expect to see every window

00:03:20.390 --> 00:03:22.300
come back except Safari.

00:03:22.680 --> 00:03:27.570
And there it is.

00:03:31.100 --> 00:03:34.900
Back to slides.

00:03:34.900 --> 00:03:36.940
And by the way,
that's not an SSD machine or anything.

00:03:36.940 --> 00:03:39.800
That's a normal spinning hard drive.

00:03:42.460 --> 00:03:43.300
Why Resume?

00:03:43.300 --> 00:03:44.300
Why are we doing this?

00:03:44.300 --> 00:03:49.970
As I said before, it's about simplifying
the application model.

00:03:51.060 --> 00:03:54.120
Users are going to come to expect
that applications don't lose their

00:03:54.500 --> 00:03:57.930
state when they quit or when the
applications crash or when they restart.

00:03:58.310 --> 00:04:02.070
And eventually we'd like to get to the
point where your Mac will be able to

00:04:02.070 --> 00:04:06.580
silently install an update overnight
when you're asleep and then reboot and

00:04:06.780 --> 00:04:13.940
all the state will be restored exactly
as it was and the user won't even know

00:04:13.940 --> 00:04:14.380
that the update has been installed
aside from all the nice bug fixes.

00:04:16.090 --> 00:04:17.830
So you might be thinking, "Well,
that's pretty nice,

00:04:17.830 --> 00:04:19.330
but I can do this on my own.

00:04:19.340 --> 00:04:22.840
Why should I use the
Cocoa APIs to do this?"

00:04:23.040 --> 00:04:24.560
Well, one answer is,
if you think about it,

00:04:24.560 --> 00:04:27.070
there's an awful lot of state to restore.

00:04:27.140 --> 00:04:30.160
A window has a window frame
on a particular display,

00:04:30.180 --> 00:04:33.000
on a particular space,
and maybe the window's minimized,

00:04:33.190 --> 00:04:34.240
maybe it's full screen.

00:04:34.440 --> 00:04:36.910
It's a lot of state to keep in mind.

00:04:37.910 --> 00:04:39.950
And also by using Resume,
you integrate with the

00:04:39.960 --> 00:04:41.000
rest of the system.

00:04:41.080 --> 00:04:43.150
For example,
the inter-application Z-order

00:04:43.510 --> 00:04:47.400
was preserved for these
windows after the crash.

00:04:47.510 --> 00:04:50.700
Another example of that is if
you hold down the Shift key

00:04:50.700 --> 00:04:52.990
when you launch an application,
it will not restore state.

00:04:53.070 --> 00:04:54.690
That's a power user feature.

00:04:54.810 --> 00:04:58.100
And by using Resume,
you pick those up automatically.

00:04:58.210 --> 00:05:01.000
And lastly, it's really easy.

00:05:01.140 --> 00:05:03.950
Incremental adoption is very possible,
meaning you don't have

00:05:03.950 --> 00:05:05.000
to throw a big switch.

00:05:05.110 --> 00:05:08.800
You can make more and more
of your windows restorable.

00:05:08.950 --> 00:05:11.290
And it complements existing
persistence mechanisms.

00:05:11.300 --> 00:05:14.090
So maybe you already know
how to restore state.

00:05:14.250 --> 00:05:14.700
That's great.

00:05:14.700 --> 00:05:15.800
You have a huge head start.

00:05:15.910 --> 00:05:17.450
You don't have to throw any of that away.

00:05:17.590 --> 00:05:24.100
You can integrate your existing
restoration into Resume.

00:05:24.210 --> 00:05:27.070
So let's give an overview of the API.

00:05:30.710 --> 00:05:34.040
This feature is inspired by iOS,
but the Mac has many challenges

00:05:34.040 --> 00:05:35.840
that are not present on iOS.

00:05:35.990 --> 00:05:38.600
For example, Mac applications often
have multiple windows,

00:05:38.600 --> 00:05:40.440
and those windows can
reference documents,

00:05:40.510 --> 00:05:44.600
which may be on a network share
or an external hard drive.

00:05:44.640 --> 00:05:46.770
In general,
there's just a lot more states

00:05:46.770 --> 00:05:48.530
that applications can get into.

00:05:48.610 --> 00:05:52.600
In fact, there's additional state
from plugins and frameworks.

00:05:52.600 --> 00:05:56.590
For example,
the font panel has its own state.

00:05:56.620 --> 00:05:59.590
So here's how we're
meeting those challenges.

00:06:01.290 --> 00:06:04.040
So this is the lifecycle
of a window under Resume.

00:06:04.230 --> 00:06:06.380
Initially,
some restorable window is open,

00:06:06.500 --> 00:06:08.960
in this case a Pages document.

00:06:09.000 --> 00:06:12.040
Cocoa will notice that this
window is open and it will ask

00:06:12.040 --> 00:06:14.310
the window to encode its state.

00:06:16.210 --> 00:06:19.290
When the user quits or logs out,
or crashes of course,

00:06:19.570 --> 00:06:22.500
and then relaunches the app,
Cocoa will notice, "Hey,

00:06:22.630 --> 00:06:26.360
this application had a window that
had a restorable state that was

00:06:26.360 --> 00:06:30.510
open on the last time the app was
run." And it's going to ask the

00:06:30.510 --> 00:06:34.910
component responsible for that
window to provide that window again.

00:06:36.240 --> 00:06:39.010
So the component will provide the window,
possibly creating it or possibly

00:06:39.010 --> 00:06:41.100
returning an existing window.

00:06:41.210 --> 00:06:44.830
Cocoa will then take that window
and apply the state that was saved

00:06:44.850 --> 00:06:46.640
on the last run to the window.

00:06:46.760 --> 00:06:50.000
So you see the window goes from
blank to being filled with content.

00:06:50.060 --> 00:06:51.440
And once again,
we're back where we started.

00:06:51.440 --> 00:06:54.500
We have a restorable window that's open.

00:06:56.360 --> 00:07:00.200
So as you can see, the Resume API is
centered around Windows,

00:07:00.200 --> 00:07:03.750
although there is support for
state attached to NS application

00:07:03.750 --> 00:07:05.600
as well for global state.

00:07:05.760 --> 00:07:08.700
And every component can take
responsibility for its own Windows.

00:07:08.800 --> 00:07:12.760
So AppKit can take responsibility for
restoring the font panel or color panel.

00:07:12.900 --> 00:07:15.300
Your application can restore
the Windows it knows about.

00:07:15.330 --> 00:07:19.970
If your application has plugins,
they can restore their own Windows, etc.

00:07:21.600 --> 00:07:22.920
As we saw, there's two phases.

00:07:23.040 --> 00:07:25.470
There's recreating the
windows that were open,

00:07:25.500 --> 00:07:29.370
and then there's restoring the
view state within those windows.

00:07:30.910 --> 00:07:32.060
So here's phase one.

00:07:32.060 --> 00:07:34.460
Here's the API for recreating windows.

00:07:34.520 --> 00:07:38.040
To mark a window as this is a
window that I would like to restore,

00:07:38.070 --> 00:07:40.230
you just simply call setRestorableYes.

00:07:40.370 --> 00:07:43.960
In fact, this is on by default for any
window which has a title bar,

00:07:44.000 --> 00:07:46.790
a titled window,
and it's off for windows that don't,

00:07:46.790 --> 00:07:48.140
borderless windows.

00:07:49.080 --> 00:07:50.770
Next, you set the Restoration class.

00:07:50.870 --> 00:07:54.190
This is the class that's responsible
for recreating the window when

00:07:54.310 --> 00:07:55.750
the application is next launched.

00:07:55.820 --> 00:08:00.670
This is what I meant by each component
can take responsibility by component

00:08:00.670 --> 00:08:03.070
as reflected as a class in the API.

00:08:03.700 --> 00:08:06.250
And lastly,
the class implements the Restore method.

00:08:06.370 --> 00:08:09.600
This is the method that gets called
when the application is relaunched

00:08:09.600 --> 00:08:13.580
and Cocoa wants to restore one
of the windows that was open.

00:08:14.700 --> 00:08:17.240
So let's zoom in on this method.

00:08:17.300 --> 00:08:20.580
The responsibility of the class is
to invoke the completion handler,

00:08:20.600 --> 00:08:25.600
that third parameter that takes
an NSWindow and an NSError.

00:08:25.720 --> 00:08:28.620
It's going to invoke that
with the corresponding window.

00:08:28.670 --> 00:08:30.880
Now,
the identifier parameter is just a way

00:08:30.880 --> 00:08:32.760
to distinguish between several windows.

00:08:32.860 --> 00:08:36.270
For example, if your class restores a
few well-known windows,

00:08:36.350 --> 00:08:39.950
it can distinguish them by setting
an identifier on the window to

00:08:40.300 --> 00:08:42.870
determine which window to restore.

00:08:43.170 --> 00:08:45.810
And this is set up, by the way,
in Interface Builder,

00:08:45.810 --> 00:08:48.400
the Interface Builder part of Xcode.

00:08:48.940 --> 00:08:51.660
The state parameter can be used
to track even more information,

00:08:51.710 --> 00:08:55.070
for example a document URL.

00:08:55.140 --> 00:08:56.380
We'll see more of that in a bit.

00:08:58.250 --> 00:09:02.090
Now, so for example,
here's how AppKit restores

00:09:02.180 --> 00:09:02.780
the font panel.

00:09:02.960 --> 00:09:05.600
It starts by just marking
the font panel as Restorable.

00:09:05.600 --> 00:09:10.630
It sets a Restoration class
to the FontPanel class itself.

00:09:10.630 --> 00:09:10.640
Why not?

00:09:11.070 --> 00:09:13.790
and it implements this
restoreWindowWithIdentifier method

00:09:13.990 --> 00:09:16.760
and all it does is immediately
invoke the completion callback

00:09:17.070 --> 00:09:18.780
with self-shared font panel.

00:09:19.000 --> 00:09:21.960
Now note this window may
have already been created.

00:09:22.090 --> 00:09:25.500
It's perfectly fine to pass a
window that's already been created

00:09:25.500 --> 00:09:26.990
to the completion callback.

00:09:29.140 --> 00:09:36.360
will also be possible to copy
the completion handler and invoke

00:09:36.420 --> 00:09:36.420
it at some point in the future.

00:09:36.620 --> 00:09:39.680
If you have an
NSDocument-based application,

00:09:39.790 --> 00:09:42.600
there's some extra integration
that goes on with NSDocument.

00:09:42.600 --> 00:09:50.160
NSDocumentController will set the
restoration class of all your document

00:09:50.160 --> 00:09:50.160
windows to the DocumentController itself.

00:09:50.830 --> 00:09:53.470
and then it will reopen the
windows by first reopening the

00:09:53.470 --> 00:09:56.730
documents and then attempting to
derive the windows associated with

00:09:56.770 --> 00:09:59.500
the documents from the document.

00:09:59.730 --> 00:10:01.600
This is a very customizable process.

00:10:01.780 --> 00:10:04.130
One way to customize it
is to simply override the

00:10:04.130 --> 00:10:06.940
method I illustrated earlier,
restoreWindowWithIdentifier

00:10:07.280 --> 00:10:08.600
on the document controller.

00:10:08.710 --> 00:10:12.080
So this would be invoked when
it's time to reopen a window

00:10:12.160 --> 00:10:13.990
associated with a document.

00:10:14.510 --> 00:10:16.530
Or if you don't want to
take responsibility for

00:10:16.530 --> 00:10:18.990
reopening the document,
but you do want to control

00:10:18.990 --> 00:10:22.170
how windows are derived,
you can override Restore

00:10:22.170 --> 00:10:24.400
Document Window with Identifier.

00:10:24.610 --> 00:10:28.150
And I'm going to give you a
demo of this entire process now.

00:10:34.100 --> 00:10:36.490
Let's get rid of all this.

00:10:36.530 --> 00:10:37.600
Oops.

00:10:37.640 --> 00:10:39.730
Command-option-Q there.

00:10:46.110 --> 00:10:48.850
So I'm going to start with base Sketch.

00:10:48.960 --> 00:10:51.340
This is Sketch as it's
shipped in Snow Leopard,

00:10:51.340 --> 00:10:56.690
and we'll see how to make its
windows restorable progressively.

00:10:56.860 --> 00:10:59.180
So if I just run Sketch--

00:11:00.320 --> 00:11:05.800
If I run Sketch,
it's going to open an untitled document.

00:11:05.800 --> 00:11:09.300
And I can, of course, add some shapes,
drawing to it.

00:11:09.420 --> 00:11:12.760
And then when I quit,
it's going to ask me if I want

00:11:12.850 --> 00:11:17.380
to save it or not because
Sketch has not adopted autosave.

00:11:17.380 --> 00:11:17.380
So if I don't save it,

00:11:17.640 --> 00:11:19.040
And then I relaunch Sketch.

00:11:19.270 --> 00:11:22.340
It doesn't come back because
the document wasn't saved.

00:11:22.400 --> 00:11:26.190
I repeat the process,
but this time I'm going to

00:11:26.340 --> 00:11:29.400
choose to save it when I quit.

00:11:32.000 --> 00:11:34.000
My Sketch document.

00:11:34.000 --> 00:11:37.000
And then I relaunch it.

00:11:37.000 --> 00:11:38.330
It will restore the document.

00:11:38.490 --> 00:11:40.340
So Sketch hasn't done anything to adopt.

00:11:40.350 --> 00:11:43.610
The reason the document's coming
back is because of the NSDocument

00:11:44.140 --> 00:11:46.590
integration that I talked about earlier.

00:11:46.920 --> 00:11:50.700
And by the way, any time you want to
test Resume from Xcode,

00:11:50.820 --> 00:11:53.800
you have to be sure that it's enabled.

00:11:53.800 --> 00:11:58.820
If you go to edit your scheme and you
go to the options of the run step,

00:11:58.910 --> 00:12:01.800
you'll see a disable state
restoration checkbox.

00:12:01.800 --> 00:12:03.280
That's a reference to Resume.

00:12:03.400 --> 00:12:05.760
You want to make sure it's unchecked
and then you can test Resume.

00:12:05.760 --> 00:12:07.910
I think it's unchecked by default.

00:12:10.530 --> 00:12:14.160
I'm going to quit Sketch.

00:12:14.260 --> 00:12:18.440
So let's go to a version of Sketch in
which I've enabled autosave.

00:12:18.460 --> 00:12:19.400
And this is all I've done.

00:12:19.400 --> 00:12:22.980
All I've done is override autosaves
in place on the Sketch document.

00:12:23.010 --> 00:12:28.230
Hopefully you saw the autosave
inversion session earlier.

00:12:28.280 --> 00:12:31.170
When I run Sketch with this--

00:12:32.340 --> 00:12:36.260
You can see it brings back the document,
and this time if I make an untitled

00:12:36.360 --> 00:12:41.510
document and I'll add a shape to it,
I'll minimize this one for fun.

00:12:42.300 --> 00:12:45.890
Now when I quit, it brings back,
you can see, the minimized document but

00:12:45.890 --> 00:12:47.170
also my untitled document.

00:12:47.250 --> 00:12:49.080
So previously it would have warned me.

00:12:49.190 --> 00:12:50.600
Now it just brings it back.

00:12:50.640 --> 00:12:56.640
That illustrates how autosave makes
for a much better user experience,

00:12:56.730 --> 00:12:58.440
especially with Resume.

00:12:58.650 --> 00:13:04.590
So let's say I open the Inspector window
and the Grid Options window.

00:13:05.320 --> 00:13:08.300
And I quit Sketch and I run it again.

00:13:08.400 --> 00:13:13.580
These windows aren't brought back,
so let's make these windows restorable.

00:13:22.370 --> 00:13:30.170
So, these windows, of course,
are set to be set by default

00:13:30.190 --> 00:13:32.740
because they are titled windows.

00:13:32.870 --> 00:13:35.140
So we have to set a restoration class.

00:13:35.240 --> 00:13:38.740
And you'll see the restoration
class for each of these

00:13:38.740 --> 00:13:43.410
windows is just the self class,
that's the SKT app delegate class.

00:13:44.010 --> 00:13:46.020
Now, in the RestoreWindowWithIdentifier
method,

00:13:46.080 --> 00:13:49.070
which I've implemented,
we start by getting the actual

00:13:49.070 --> 00:13:52.210
application delegate because
this is a class method.

00:13:52.650 --> 00:13:54.780
And because we only have
these two global windows,

00:13:54.830 --> 00:13:56.600
we can distinguish them
using the identifier.

00:13:56.780 --> 00:14:00.100
So we're going to say if the
identifier is equal to Inspector,

00:14:00.390 --> 00:14:03.620
then we're going to get the Graphics
Inspector and get its window.

00:14:03.920 --> 00:14:07.350
Otherwise, if it's equal to Grid,
we can get the window.

00:14:07.530 --> 00:14:09.260
Otherwise,
it's a window we don't know about,

00:14:09.330 --> 00:14:13.230
but we want to make sure that we still
invoke the completion handler with nil.

00:14:13.550 --> 00:14:16.980
This would come about, for example,
if I ran an earlier version

00:14:16.980 --> 00:14:19.820
of Sketch with save state
from a future version.

00:14:20.060 --> 00:14:26.130
And by the way, these identifiers here,
I simply set in the, here's the window.

00:14:26.210 --> 00:14:29.900
You can see in the class properties,
or the object properties,

00:14:29.900 --> 00:14:33.880
that there's an identifier field
and that's where that grid and

00:14:33.890 --> 00:14:36.210
inspector identifier came from.

00:14:36.520 --> 00:14:38.960
So that wasn't a whole lot of work.

00:14:39.020 --> 00:14:44.550
Now when I run Sketch and I show
the inspector and I show the grid

00:14:44.960 --> 00:14:51.300
options and I quit and I run it again,
these come back.

00:14:52.570 --> 00:14:55.290
And if they were on another, you know,
their frame is restored,

00:14:55.300 --> 00:14:57.420
if they're minimized, et cetera,
that would all be,

00:14:57.420 --> 00:15:00.490
that state would all get restored
automatically by NSWindow.

00:15:03.180 --> 00:15:04.210
So there's a feature of Sketch.

00:15:04.270 --> 00:15:08.210
If I hold down Option,
I can make a new window for a document.

00:15:09.910 --> 00:15:12.640
And you can see that the two
windows reflect the same data.

00:15:12.740 --> 00:15:15.140
If I edit one, it appears in the other.

00:15:15.270 --> 00:15:17.220
But if I quit,

00:15:17.820 --> 00:15:19.000
and I relaunch.

00:15:19.060 --> 00:15:20.760
Only one window is brought back.

00:15:20.940 --> 00:15:24.150
This is of course because NSDocument
doesn't know how to create multiple

00:15:24.150 --> 00:15:27.730
windows and the document by
default only creates the one.

00:15:28.700 --> 00:15:31.390
So this is an excellent candidate for
one of the methods I talked about,

00:15:31.470 --> 00:15:33.600
the restore document window.

00:15:33.760 --> 00:15:37.080
This is called when the document
has already been reopened,

00:15:37.170 --> 00:15:40.500
but you want to derive a window from it.

00:15:45.820 --> 00:15:50.060
So here's all I've done here is
restored-- I've implemented a restored

00:15:50.060 --> 00:15:54.950
document window with identifier state
completion handler on the SKT document.

00:15:55.600 --> 00:15:57.600
If I wanted to,
I could call through to Super,

00:15:57.640 --> 00:15:59.420
but in this case,
I'm just going to create

00:15:59.420 --> 00:16:01.670
a window controller,
add the window controller,

00:16:01.880 --> 00:16:04.320
invoke the completion handler,
and release the window controller.

00:16:04.340 --> 00:16:07.650
This is essentially the same thing
that happens when you choose new

00:16:07.650 --> 00:16:10.310
document window from the menu,
except, of course,

00:16:10.310 --> 00:16:11.640
for the completion handler.

00:16:11.640 --> 00:16:15.590
So, with this method implemented,

00:16:17.540 --> 00:16:20.660
I can create a new window.

00:16:20.750 --> 00:16:22.400
And I quit.

00:16:22.640 --> 00:16:24.100
And I relaunch it.

00:16:24.240 --> 00:16:26.220
And it opens both the windows.

00:16:26.500 --> 00:16:29.570
So you can see how we've sort
of incrementally adding Resume

00:16:29.580 --> 00:16:32.310
functionality to Sketch.

00:16:42.240 --> 00:16:45.440
So we took windows that were not
restorable and made them restorable.

00:16:45.450 --> 00:16:47.790
But which windows should be restorable?

00:16:48.020 --> 00:16:50.800
Well, most windows should be,
but there are some exceptions.

00:16:50.980 --> 00:16:53.290
For example,
if your window is very transient,

00:16:53.290 --> 00:16:55.600
like it's a tool tip or
it's a shielding window,

00:16:55.900 --> 00:16:59.000
those don't need to be restorable,
like a menu or a pop-up,

00:16:59.000 --> 00:17:00.200
something like that.

00:17:00.200 --> 00:17:04.200
If the user does not want to restore
the window and they've indicated that,

00:17:04.200 --> 00:17:05.790
of course then it should
not be restorable either.

00:17:05.800 --> 00:17:09.710
We saw that with the private
browsing example in the first demo.

00:17:10.480 --> 00:17:14.700
If the window's job is done in some way,
for example,

00:17:14.700 --> 00:17:18.550
when you install an application and
you get a sort of window which just

00:17:18.550 --> 00:17:22.570
says "Install Complete," that window
doesn't need to be restorable because

00:17:22.570 --> 00:17:24.600
it's no longer very interesting.

00:17:25.110 --> 00:17:28.230
And if your app cannot restore a window,
it's good practice to mark the

00:17:28.230 --> 00:17:32.890
window as not restorable just
so that there's no confusion.

00:17:33.130 --> 00:17:35.940
Hopefully you can make those
restorable in the future.

00:17:37.780 --> 00:17:39.610
So now that we've got our
windows back on screen,

00:17:39.610 --> 00:17:42.880
how do we restore state
within those windows?

00:17:45.360 --> 00:17:49.200
So every component within the window
has its own private store of state,

00:17:49.200 --> 00:17:50.320
which is an NSCoder.

00:17:50.640 --> 00:17:52.870
And by component,
I mean every view within the window,

00:17:52.920 --> 00:17:56.710
the window itself, its window controller,
and the document associated

00:17:56.720 --> 00:17:58.290
with the window controller.

00:17:58.410 --> 00:18:00.290
And that's true for NSApplication.

00:18:00.360 --> 00:18:02.960
It also has some state
that it can restore.

00:18:03.610 --> 00:18:09.500
Now, when the state gets dirty,
it invalidates its state by invoking

00:18:09.560 --> 00:18:12.070
self-invalidateRestorableState.

00:18:12.070 --> 00:18:14.910
This is sort of like setNeedsDisplayYes.

00:18:15.010 --> 00:18:19.790
It indicates I need to have my state
written to disk to be recorded.

00:18:20.450 --> 00:18:22.900
And this is a very inexpensive call.

00:18:22.990 --> 00:18:25.930
It's very fast because it doesn't
actually do any work initially.

00:18:26.040 --> 00:18:30.000
It just marks that particular
component as being dirty.

00:18:30.110 --> 00:18:33.620
Now, at some point in the future, though,
that component, the view, for example,

00:18:33.890 --> 00:18:36.780
will be asked to encode its state.

00:18:37.630 --> 00:18:40.500
This is a method
encodeRestorableStateWithCoder

00:18:40.500 --> 00:18:45.810
will be invoked.

00:18:45.810 --> 00:18:45.810
This is a method you would override
to associate state with a view.

00:18:45.860 --> 00:18:50.240
This typically happens when the app
is deactivated or on a timer after the

00:18:50.420 --> 00:18:52.690
last call of invalidateRestorableState.

00:18:52.690 --> 00:18:55.300
And then when the
application is relaunched,

00:18:55.330 --> 00:18:59.120
each component will be passed
its state from the last run via

00:18:59.300 --> 00:19:02.040
the method restoreStateWithCoder.

00:19:02.040 --> 00:19:07.810
So the state that was encoded
in encodeRestorableState is now

00:19:07.890 --> 00:19:11.200
available in decodeStateWithCoder,
or excuse me, restoreStateWithCoder.

00:19:11.650 --> 00:19:13.790
There's two useful delegate
methods on NSWindow.

00:19:13.990 --> 00:19:16.660
If all you want to do is just
associate a little bit of state with

00:19:16.660 --> 00:19:19.440
a window without-- but you don't
want to make an entire subclass,

00:19:19.590 --> 00:19:21.360
you can implement the delegate method.

00:19:21.400 --> 00:19:25.360
Window will encode RestorableState,
and Window did decode RestorableState.

00:19:25.360 --> 00:19:27.720
And as a delegate,
you can encode your own RestorableState

00:19:27.910 --> 00:19:31.430
into that-- into the Windows NSCoder.

00:19:32.000 --> 00:19:33.900
and furthermore,
if you have some properties

00:19:33.900 --> 00:19:37.940
which are KVO compliant,
you can override the class method,

00:19:38.070 --> 00:19:39.900
Restorable State Key Paths.

00:19:40.070 --> 00:19:43.240
What this will do is Cocoa will
observe all these key paths

00:19:43.240 --> 00:19:44.630
and notice when they change.

00:19:44.720 --> 00:19:47.410
When they change,
it will encode the new value to

00:19:47.410 --> 00:19:52.520
disk and when the app is restored,
it will automatically use KVC to set

00:19:52.520 --> 00:19:55.760
those properties back on each component.

00:19:55.960 --> 00:20:01.210
This is a really easy one-line way to
get some state persistent and restorable.

00:20:02.530 --> 00:20:06.610
So this is a very general mechanism,
but what state is appropriate

00:20:06.620 --> 00:20:08.230
for this mechanism?

00:20:08.380 --> 00:20:12.400
Here's a text edit window, for example,
and you want to think about this state

00:20:12.400 --> 00:20:17.640
as being associated with the view and
controller layers of the MVC model.

00:20:17.640 --> 00:20:20.060
So for example,
restoring the selected range or the

00:20:20.410 --> 00:20:22.160
scroll position of the text document.

00:20:22.160 --> 00:20:25.500
And by the way,
NSTextView will do both of those for you.

00:20:25.890 --> 00:20:27.740
But you would not want to restore,
for example,

00:20:27.840 --> 00:20:29.300
the actual text of the document.

00:20:29.300 --> 00:20:32.770
That's part of the model state,
and that should come from

00:20:32.830 --> 00:20:37.700
typically a file on disk,
for example, or whatever your model is.

00:20:39.000 --> 00:20:43.250
This can cause an interesting
challenge because the view and

00:20:43.250 --> 00:20:45.340
model state may get out of sync.

00:20:45.720 --> 00:20:51.130
For example, if while text edit is quit,
I go into an Emacs and I change the file,

00:20:51.240 --> 00:20:53.800
when I restore the window,
it's going to have a different

00:20:53.900 --> 00:20:55.050
text than it had before.

00:20:55.320 --> 00:20:58.930
And if you're not careful,
it can cause a problem.

00:20:59.210 --> 00:21:03.970
For example, at one point early in Lion,
the selected range would get restored,

00:21:03.980 --> 00:21:06.180
and if it happened to
be beyond the new text,

00:21:06.320 --> 00:21:09.520
it would throw an exception
because we tried to restore

00:21:09.590 --> 00:21:11.320
a range that was too long.

00:21:12.930 --> 00:21:15.560
So you need to be sure
to validate your state.

00:21:15.560 --> 00:21:19.450
All right,
I'm going to give a demo of how we can

00:21:19.640 --> 00:21:23.560
make sketches window state-restorable.

00:21:23.560 --> 00:21:34.490
So I need to switch to this thing.

00:21:43.970 --> 00:21:48.250
So you'll notice here if
I zoom in on this document,

00:21:48.280 --> 00:21:52.600
the 200, and maybe I'll scroll a bit,
and I quit,

00:21:52.930 --> 00:21:54.660
Can I relaunch?

00:21:54.710 --> 00:22:01.890
It's taking me back to 100,
so the zoom is not restored properly.

00:22:01.940 --> 00:22:05.440
So this would be a --
let's see how we do that.

00:22:10.460 --> 00:22:14.610
Now, the Resume property,
turns out this is a KVO and KVC compliant

00:22:14.610 --> 00:22:16.600
property with a keypath factor.

00:22:17.000 --> 00:22:20.350
So to make this restorable,
all I need to do is override

00:22:20.350 --> 00:22:23.060
RestorableStateKeypaths,
invoke super.

00:22:23.250 --> 00:22:26.400
This is on the scroll view itself,
by the way.

00:22:26.400 --> 00:22:30.170
Each view can take
responsibility for its own state.

00:22:30.640 --> 00:22:34.790
I invoke super-restorable-state keypaths,
and I just add the object,

00:22:34.800 --> 00:22:36.180
my keypath for the zoom.

00:22:36.250 --> 00:22:37.720
That's all I have to do.

00:22:37.880 --> 00:22:40.450
Now when I run Sketch,

00:22:41.750 --> 00:22:47.760
I zoom in and I'll
scroll a bit and I quit.

00:22:47.770 --> 00:22:51.190
So now that zoom is saved
in my persistent state.

00:22:51.450 --> 00:22:54.750
When I relaunch,
it's now zoomed to 200% and

00:22:54.890 --> 00:22:58.600
you'll notice also that the
scroll position was restored.

00:22:58.760 --> 00:23:03.610
That's in a scroll view encoding and
restoring its own scroll position state.

00:23:03.930 --> 00:23:07.110
So that was a really easy way if
you have a KVO or KVC compliant

00:23:07.110 --> 00:23:08.900
property to make that restorable.

00:23:14.760 --> 00:23:20.770
Now if I select a few of
these figures here and I quit,

00:23:21.300 --> 00:23:22.160
And I relaunch.

00:23:22.310 --> 00:23:23.820
You'll notice that the
selection isn't restored.

00:23:24.140 --> 00:23:28.680
So let's make this sketch save
and restore its selection.

00:23:35.530 --> 00:23:38.510
So because the selection is
a little more complicated,

00:23:38.640 --> 00:23:41.420
we're going to use the
EncodeRestorableState

00:23:41.580 --> 00:23:45.240
and Decode-- excuse me,
RestoreStateWithCoder method

00:23:45.350 --> 00:23:48.900
to persist this state.

00:23:51.290 --> 00:23:53.700
On the SKT graphic view,
which is the view that draws the

00:23:53.700 --> 00:23:56.990
graphics and tracks the selection,
I'm going to override

00:23:57.100 --> 00:23:59.020
EncodeRestorableStateWithCoder.

00:23:59.200 --> 00:24:03.900
I start by invoking super in case a super
class has any state it wants to restore.

00:24:04.000 --> 00:24:07.200
And then I just call
selfEncodeObject SelectionIndexes.

00:24:07.280 --> 00:24:10.510
This is an NSIndexSet of the
graphics that are selected,

00:24:10.530 --> 00:24:12.730
and I pass it the key SelectionIndexes.

00:24:12.840 --> 00:24:15.070
I can use any key I please.

00:24:15.570 --> 00:24:19.120
Now in the restoreStateWithCoder method,
I'm going to first call super

00:24:19.180 --> 00:24:23.100
restoreStateWithCoder so that the
superclass can restore its own state.

00:24:23.100 --> 00:24:25.850
I'm going to decode
the selection indexes,

00:24:25.860 --> 00:24:28.290
and if I have them-- now,
I might not have them if I ran

00:24:28.290 --> 00:24:32.090
an earlier version of Sketch,
so I want to validate it.

00:24:32.130 --> 00:24:32.890
I check it.

00:24:32.980 --> 00:24:34.050
It's not nil.

00:24:34.310 --> 00:24:37.500
Now I need to make sure that the index
set is not out of bounds because,

00:24:37.500 --> 00:24:40.250
as I mentioned,
the document contents may have changed

00:24:40.430 --> 00:24:43.410
independently from the Restorable State.

00:24:44.220 --> 00:24:48.290
So here's a way of just validating
that every index is no larger than

00:24:48.290 --> 00:24:50.750
the number of graphics I have.

00:24:51.440 --> 00:24:53.770
Once I've done that,
I simply call self-change

00:24:53.770 --> 00:24:56.960
selection indexes with the
validated selection indexes.

00:24:57.050 --> 00:25:02.790
This is the funnel point that all
graphic selection changes go through.

00:25:03.520 --> 00:25:06.060
And the third piece of the puzzle
is whenever that gets called,

00:25:06.060 --> 00:25:11.520
whenever the user changes the selection,
I need to

00:25:12.360 --> 00:25:14.430
Invalidate the Restorable State.

00:25:14.430 --> 00:25:15.060
So here we are.

00:25:15.070 --> 00:25:18.410
In Change Selection Indexes,
all I'm going to do is add a line,

00:25:18.410 --> 00:25:22.160
Self-Invalidate Restorable State,
which will ensure that my

00:25:22.260 --> 00:25:26.310
state for this view is encoded
before the application quits.

00:25:27.390 --> 00:25:32.440
So now if I run and I'll
select a few figures here,

00:25:32.440 --> 00:25:39.630
and I quit, and I run it again,
if I get this out of the way,

00:25:39.750 --> 00:25:42.270
we'll see that it restored the selection.

00:25:47.300 --> 00:25:51.300
Switch back to slides.

00:25:51.300 --> 00:25:53.300
And again,
this is a very incremental process.

00:25:53.300 --> 00:25:57.600
We just keep adding more and
more state that gets restored.

00:25:59.370 --> 00:26:01.260
So Sketch is a simple application.

00:26:01.420 --> 00:26:04.300
What if your app is more complicated?

00:26:04.380 --> 00:26:07.370
For example,
if your application wants to restore

00:26:07.460 --> 00:26:11.250
a window associated with a document,
it may need to know the document's

00:26:11.250 --> 00:26:14.140
URL before it can even create the window.

00:26:15.610 --> 00:26:18.940
So this brings me back to that state
parameter in the first part of my talk,

00:26:18.940 --> 00:26:20.630
Restore Window with Identifier.

00:26:20.850 --> 00:26:24.870
That state parameter is a collection,
it's a union of the Restorable

00:26:24.870 --> 00:26:29.380
State of the window,
the window controller, and the document.

00:26:32.190 --> 00:26:33.670
It's a combination of all of them.

00:26:33.940 --> 00:26:37.640
So this allows you to get access
to the Windows private state before

00:26:37.640 --> 00:26:39.770
the Windows has even been created.

00:26:40.380 --> 00:26:43.370
Now if you, in reading this state,
discover that maybe the

00:26:43.370 --> 00:26:46.670
document's been deleted,
you want to be sure to invoke the

00:26:46.680 --> 00:26:49.320
completion handler anyway with nil.

00:26:49.680 --> 00:26:51.500
If you don't invoke
the completion handler,

00:26:51.500 --> 00:26:53.920
the app will appear
unresponsive until you do.

00:26:53.920 --> 00:26:57.140
So always invoke it.

00:26:59.580 --> 00:27:04.050
So let's go over some more advanced
topics and best practices for an

00:27:04.050 --> 00:27:07.430
app living in a Lion Resume world.

00:27:08.510 --> 00:27:10.860
So here's how NSWindow
encodes its first responder,

00:27:10.960 --> 00:27:13.400
which is the view that
has the keyboard focus.

00:27:13.410 --> 00:27:13.870
It just does it.

00:27:13.910 --> 00:27:17.400
It calls encodeFirstResponder
for some key.

00:27:17.420 --> 00:27:19.400
Now this may seem dangerous, right?

00:27:19.400 --> 00:27:22.400
Is this going to archive
an entire view hierarchy?

00:27:22.400 --> 00:27:23.400
Well, in fact, it doesn't.

00:27:23.400 --> 00:27:27.810
Encoding an NSResponder
just does not call,

00:27:27.840 --> 00:27:30.380
um, not actually archive that responder.

00:27:30.430 --> 00:27:32.270
Instead, it archives a reference to it.

00:27:32.400 --> 00:27:36.730
And when you decode it,
it's going to return a responder

00:27:36.730 --> 00:27:39.310
that's already in the window.

00:27:39.310 --> 00:27:39.310
So when you encode your first responder,

00:27:39.570 --> 00:27:42.860
Then you decode it,
you're going to get the view that

00:27:42.870 --> 00:27:47.690
represents whatever view had the
keyboard focus in the previous run.

00:27:48.200 --> 00:27:51.040
and in fact references
can even cross windows.

00:27:51.100 --> 00:27:54.200
For example, the color and font panel,
they encode their target which is

00:27:54.200 --> 00:27:55.850
typically in another window entirely.

00:27:56.170 --> 00:27:59.520
When the state is restored,
they can decode their

00:27:59.780 --> 00:28:01.640
target and that just works.

00:28:03.150 --> 00:28:04.580
Sandboxed apps.

00:28:04.580 --> 00:28:07.610
So you may be worried, "Hey,
my application has a file open.

00:28:07.790 --> 00:28:10.720
If I relaunch my application,
how am I going to be able to get

00:28:10.720 --> 00:28:13.110
permission to reopen this file?"

00:28:15.490 --> 00:28:19.820
The secret here is to encode a URL to
the file in the restorable state and

00:28:19.820 --> 00:28:22.900
any NS code in the restorable state,
so in the view or in a window

00:28:22.900 --> 00:28:25.890
or in NS application itself.

00:28:26.680 --> 00:28:30.440
URL is special in that it will
automatically give you permission

00:28:30.640 --> 00:28:33.600
to reopen this file when your
application is next launched.

00:28:33.600 --> 00:28:36.690
This is true even if the file
has been moved or renamed because

00:28:36.690 --> 00:28:38.600
URL encoding uses bookmarks.

00:28:38.780 --> 00:28:41.010
You have to encode the NSURL itself.

00:28:41.120 --> 00:28:44.800
You can't create your own bookmark
as an NSData and encode that

00:28:45.180 --> 00:28:48.800
because it will not be recognized
as an NSURL and you will not get

00:28:48.880 --> 00:28:51.300
permission to reopen that file.

00:28:51.780 --> 00:28:56.090
or of course if you're NS Document based,
NS Document will take care of this for

00:28:56.090 --> 00:28:58.800
you without you having to do any work.

00:29:00.930 --> 00:29:04.200
So I alluded earlier to the
fact that if you already have a

00:29:04.200 --> 00:29:08.260
mechanism for restoring your state,
it's very easy to integrate with Resume.

00:29:08.380 --> 00:29:10.680
And I'd like to share how
we did that with Mail.

00:29:10.720 --> 00:29:13.630
Mail, of course,
has an NSUserDefaults state

00:29:13.890 --> 00:29:15.560
restoration mechanism.

00:29:15.560 --> 00:29:18.520
It writes its window
state to user defaults.

00:29:20.210 --> 00:29:23.090
and integrating Resume was
only about 60 lines of code.

00:29:23.090 --> 00:29:25.340
It was not difficult at all.

00:29:25.640 --> 00:29:28.990
So here's the basic
idea of how it was done.

00:29:29.530 --> 00:29:32.980
We give each window a unique ID,
for example, a UUID or just an

00:29:33.070 --> 00:29:35.670
auto-incrementing integer.

00:29:35.750 --> 00:29:40.990
And we record that UID in both the
Restorable State and NSUser defaults,

00:29:40.990 --> 00:29:43.990
its existing persistent state mechanism.

00:29:44.290 --> 00:29:48.660
Then when the application is relaunched,
Mail restores its windows via NSUser

00:29:48.660 --> 00:29:51.200
defaults like it's always done.

00:29:51.450 --> 00:29:56.770
And then it goes through each of the
Resume callbacks that it got and decodes

00:29:56.770 --> 00:30:00.200
that UID from the Restorable State.

00:30:00.200 --> 00:30:04.110
It locates a window that's already
recreated and then invokes the

00:30:04.180 --> 00:30:08.130
completion handler with that window
or nil if it couldn't find it.

00:30:08.320 --> 00:30:13.940
So the UUID acts as kind of glue between
the Restorable State mechanism and its

00:30:14.050 --> 00:30:17.790
existing NSUser defaults restoration.

00:30:21.530 --> 00:30:23.400
Here are some best practices.

00:30:23.570 --> 00:30:25.770
When your app is launched,
don't assume that the user is

00:30:25.770 --> 00:30:26.970
going to use it right away.

00:30:27.360 --> 00:30:30.300
For example, in my crash demo,
you saw that all these

00:30:30.310 --> 00:30:32.370
applications were relaunched.

00:30:32.460 --> 00:30:35.490
And if they started opening new
windows or throwing up dialogues,

00:30:35.490 --> 00:30:37.880
it would have been a bad user experience.

00:30:37.990 --> 00:30:40.510
Your app can be relaunched
in the background,

00:30:40.510 --> 00:30:42.220
so keep splash screens, etc.

00:30:42.470 --> 00:30:46.100
They'll be perceived as annoying,
so keep those to a minimum.

00:30:48.850 --> 00:30:51.820
Don't create windows an
application did finish launching.

00:30:51.820 --> 00:30:54.690
Your app may already have
windows that have been restored.

00:30:54.700 --> 00:30:57.560
If you do create a window here,
it can lead to what we

00:30:57.650 --> 00:30:59.750
call the N+1 effect,
where you launch an application,

00:30:59.830 --> 00:31:02.700
it creates a window, you quit,
you relaunch it,

00:31:02.700 --> 00:31:06.100
it restores the first window,
creates a new one, so now you have two,

00:31:06.100 --> 00:31:07.680
three, four, etc.

00:31:07.920 --> 00:31:08.520
That's not good.

00:31:08.610 --> 00:31:13.200
So what you want to do instead is
prefer application open untitled file,

00:31:13.200 --> 00:31:14.700
the delegate method.

00:31:14.700 --> 00:31:17.970
This is called at the right time when
either the app is launched in the

00:31:17.970 --> 00:31:22.100
foreground and there's no windows
or the user clicks on the dock,

00:31:22.100 --> 00:31:22.690
etc.

00:31:22.810 --> 00:31:25.340
Now the exception to this is if
your app doesn't even make sense

00:31:25.540 --> 00:31:30.680
without a particular window,
like iPhoto, iPhoto has just one window,

00:31:30.890 --> 00:31:35.030
you can always create that
window anytime you like.

00:31:36.930 --> 00:31:39.650
Be prepared for unexpected changes.

00:31:39.810 --> 00:31:42.510
So when your app is relaunched,
things may-- state may have

00:31:42.510 --> 00:31:45.900
changed between when it was run
before and how it's running now.

00:31:45.900 --> 00:31:47.340
The screen size may have changed.

00:31:47.400 --> 00:31:48.430
The user may have toggled.

00:31:48.520 --> 00:31:51.820
The scroll bar preferences-- the
file contents may have changed

00:31:52.110 --> 00:31:53.950
because of iCloud or other reasons.

00:31:53.960 --> 00:31:57.950
So you always want to validate that
your saved state still makes sense.

00:31:58.060 --> 00:32:01.670
And don't forget versioning,
so you maybe have saved state from

00:32:01.780 --> 00:32:06.400
a previous or future version of
your application that you want to

00:32:06.400 --> 00:32:07.610
be able to version that correctly.

00:32:10.910 --> 00:32:13.860
and partial state restoration is okay.

00:32:13.950 --> 00:32:15.600
Though higher fidelity
is obviously better.

00:32:15.660 --> 00:32:19.180
As you saw with Sketch,
we incrementally added more and

00:32:19.300 --> 00:32:22.540
more Resume capability to the app,
but there's still more we can do.

00:32:22.540 --> 00:32:29.990
We're never going to be able
to restore everything exactly,

00:32:29.990 --> 00:32:29.990
so it's okay to do a very good job.

00:32:30.520 --> 00:32:34.000
But the more you use Cocoa,
the less work it's going to take.

00:32:34.020 --> 00:32:37.040
For example,
if your application uses Fullscreen,

00:32:37.040 --> 00:32:40.460
if you use the Fullscreen
APIs we're introducing in Lion,

00:32:40.500 --> 00:32:43.240
it will be automatically restored
to Fullscreen when the user

00:32:43.450 --> 00:32:45.000
quits and relaunches the app.

00:32:45.010 --> 00:32:51.330
But if you roll your own
Fullscreen implementation,

00:32:51.330 --> 00:32:51.870
which you can do,
you'll have to do your own

00:32:51.870 --> 00:32:51.870
work to integrate with Resume.

00:32:54.500 --> 00:32:56.480
So here's a summary of Resume.

00:32:56.590 --> 00:32:59.900
Resume is, of course,
about restoring state.

00:33:00.790 --> 00:33:03.870
Cocoa tracks the windows that
are open and asks those windows

00:33:03.990 --> 00:33:08.310
to encode their restorable state
and then writes that to disk.

00:33:08.990 --> 00:33:12.050
Each component can take
responsibility for the windows

00:33:12.050 --> 00:33:14.090
it knows about and can create.

00:33:14.090 --> 00:33:16.700
And each NSResponder,
each view for example,

00:33:16.720 --> 00:33:20.480
also can take responsibility
for its own state.

00:33:22.080 --> 00:33:24.560
So with that, I'm going to bring up my
colleague David Smith,

00:33:24.640 --> 00:33:28.070
who will tell you about
Automatic Termination in Lion.

00:33:31.330 --> 00:33:32.060
Thank you, Peter.

00:33:32.130 --> 00:33:34.460
Good morning, everyone.

00:33:34.460 --> 00:33:35.200
I'm David Smith.

00:33:35.250 --> 00:33:37.780
Like Peter, I'm an engineer on the
Cocoa Frameworks team.

00:33:37.870 --> 00:33:40.760
And I'm here to talk to you
about automatic termination.

00:33:40.820 --> 00:33:45.120
This is part of the triad of features,
autosave, resume,

00:33:45.440 --> 00:33:48.000
and automatic termination,
that all go together to simplify

00:33:48.000 --> 00:33:49.350
the application model in Lion.

00:33:49.420 --> 00:33:50.700
It's a new technology.

00:33:50.830 --> 00:33:53.470
So first, I'm going to talk about
what exactly it's doing,

00:33:53.480 --> 00:33:55.080
give you a brief overview of it.

00:33:55.350 --> 00:33:57.750
Then I'm going to talk about some
benefits that it brings and why you

00:33:57.750 --> 00:33:59.940
might want to adopt it in your app.

00:33:59.990 --> 00:34:03.580
I'm going to give you an overview of the
API and how you can adopt it in your app.

00:34:03.630 --> 00:34:06.090
And then I'll talk briefly about
some future directions that

00:34:06.090 --> 00:34:07.440
we might take this feature.

00:34:07.500 --> 00:34:10.300
So what is automatic termination?

00:34:10.360 --> 00:34:12.490
First and foremost--

00:34:13.230 --> 00:34:14.970
It's a new user model.

00:34:15.290 --> 00:34:18.740
It lets users focus on using
apps instead of managing them.

00:34:18.970 --> 00:34:22.780
So instead of having to quit
applications and relaunch them,

00:34:22.780 --> 00:34:24.520
instead of having to
manage memory themselves,

00:34:24.520 --> 00:34:27.050
when they run out of memory,
quit an app to free it, et cetera,

00:34:27.050 --> 00:34:29.490
they can just focus on
getting their work done.

00:34:29.600 --> 00:34:32.840
It does this by decoupling the
concept of apps and processes.

00:34:33.000 --> 00:34:36.830
In pretty much every historical system,
an app has always had a

00:34:36.830 --> 00:34:40.840
process associated with it,
and a user process has always

00:34:40.910 --> 00:34:41.960
had an app associated with it.

00:34:41.960 --> 00:34:45.000
Neither of these is true, necessarily,
in Lion.

00:34:45.010 --> 00:34:47.520
I'll go into more detail
about how both of those happen

00:34:48.070 --> 00:34:50.730
later on in this presentation.

00:34:52.170 --> 00:34:55.410
So this is the application
lifecycle in the Stone Age,

00:34:55.420 --> 00:34:58.910
AKA Snow Leopard.

00:34:59.150 --> 00:35:01.330
Users have to spend time
quitting applications,

00:35:01.420 --> 00:35:02.370
launching applications.

00:35:02.450 --> 00:35:06.170
They have to keep track of
what's open and what's not open.

00:35:07.200 --> 00:35:09.910
We'd like to change that,
focus on just using it and letting the

00:35:10.000 --> 00:35:13.900
system manage these sort of extra duties.

00:35:13.990 --> 00:35:17.720
You can think of it as sort of like
garbage collection for processes.

00:35:18.900 --> 00:35:21.360
So, there are a couple of side
benefits that we get by doing this.

00:35:21.570 --> 00:35:24.800
We also get to bring iOS-style
memory reclamation to the Mac.

00:35:24.800 --> 00:35:28.490
When the system's running out of RAM,
it can terminate unneeded

00:35:28.580 --> 00:35:29.800
processes to free them up.

00:35:29.800 --> 00:35:31.580
And on the flip side,
if it doesn't need to

00:35:31.730 --> 00:35:33.790
terminate processes,
it can keep them around

00:35:33.890 --> 00:35:37.610
after the users quit them,
which gives you effectively

00:35:37.610 --> 00:35:38.890
instant relaunch.

00:35:40.700 --> 00:35:44.110
So I'm going to go into a little bit more
detail about why you would want automatic

00:35:44.240 --> 00:35:45.850
termination for your application.

00:35:46.070 --> 00:35:48.530
What's in it for me, basically.

00:35:48.910 --> 00:35:51.600
First and foremost,
it's about playing well with others.

00:35:51.670 --> 00:35:54.340
If your application is a
good citizen on the system,

00:35:54.420 --> 00:35:58.000
then all the other applications on
the system are going to perform well.

00:35:58.080 --> 00:36:00.420
And on the flip side,
if all the other applications

00:36:00.480 --> 00:36:02.080
are good citizens,
then your application is

00:36:02.080 --> 00:36:02.820
going to perform well.

00:36:02.840 --> 00:36:06.440
So it's in everybody's best
interest to play well with others.

00:36:06.610 --> 00:36:09.670
It's also going to meet the user
expectations for new applications.

00:36:09.840 --> 00:36:11.250
We're pushing this pretty heavily.

00:36:11.400 --> 00:36:13.560
We'd like it to be the
new way things work.

00:36:13.630 --> 00:36:17.850
And applications that don't do it
are going to start looking old.

00:36:20.390 --> 00:36:24.120
Instant Relaunch is another side benefit.

00:36:24.300 --> 00:36:26.820
It doesn't happen in all
that many situations in Lion,

00:36:26.950 --> 00:36:28.870
but it could happen more in the future.

00:36:28.960 --> 00:36:31.820
And even in the situations
it does happen in Lion,

00:36:31.820 --> 00:36:32.900
it's very nice.

00:36:33.780 --> 00:36:36.440
And finally, as I've alluded to,
this gets you ready for

00:36:36.440 --> 00:36:39.510
possible future plans,
which I'll talk about near

00:36:39.630 --> 00:36:41.310
the end of this presentation.

00:36:42.870 --> 00:36:45.300
So at this point,
hopefully I've sold you on the basic

00:36:45.320 --> 00:36:46.430
concept of automatic termination.

00:36:46.510 --> 00:36:50.210
So we're going to look into a little
bit more depth of how it works and

00:36:50.330 --> 00:36:52.550
how to adopt it in your application.

00:36:53.910 --> 00:36:54.890
The API is very simple.

00:36:54.990 --> 00:36:57.030
We modeled it after the Sudden
Termination API that was

00:36:57.080 --> 00:36:59.590
introduced in Snow Leopard,
which brings me to a

00:36:59.590 --> 00:37:00.710
very important aside.

00:37:00.930 --> 00:37:03.570
Sudden Termination and Automatic
Termination are not the same thing.

00:37:03.770 --> 00:37:05.800
Pretty much every time I've
mentioned this to somebody,

00:37:05.800 --> 00:37:09.090
they're like, "Oh,
I think I remember that." No, you don't.

00:37:09.150 --> 00:37:10.440
This is new.

00:37:10.580 --> 00:37:14.340
Sudden Termination is about quitting
very quickly without doing a lot

00:37:14.420 --> 00:37:16.170
of work or touching much memory.

00:37:16.480 --> 00:37:20.540
Automatic Termination is the new
UI model and the new process model.

00:37:20.640 --> 00:37:22.430
We would, of course,
like you to participate in both.

00:37:22.590 --> 00:37:25.310
That makes it so that when the
system terminates your application,

00:37:25.390 --> 00:37:29.470
it can do things like terminate it
without touching a lot of memory pages,

00:37:29.470 --> 00:37:31.680
which might induce more paging activity.

00:37:31.810 --> 00:37:34.980
It can also terminate it very quickly
without getting in the user's way

00:37:35.160 --> 00:37:36.880
or slowing down the foreground app.

00:37:37.070 --> 00:37:38.980
But if for some reason
you can't adopt both,

00:37:39.220 --> 00:37:42.120
you can do one or the other or neither.

00:37:42.190 --> 00:37:44.290
They're completely independent.

00:37:45.830 --> 00:37:50.520
So the first thing you need to do
is turn Automatic Termination on.

00:37:50.520 --> 00:37:52.340
You can do this in one of two ways.

00:37:52.340 --> 00:37:55.800
You can set a property list
key in your Info.plist,

00:37:55.800 --> 00:37:58.790
and it supports Automatic Termination.

00:37:58.800 --> 00:38:01.510
And that's a Boolean property,
so you just set it to true,

00:38:01.660 --> 00:38:02.800
and we'll take it from there.

00:38:02.800 --> 00:38:05.780
Alternatively,
if for some reason you can't do that,

00:38:05.780 --> 00:38:09.800
you can use the NSProcessInfo API,
set Automatic Termination enabled,

00:38:09.800 --> 00:38:11.760
and just pass yes to that.

00:38:11.920 --> 00:38:13.800
If you pass no, it won't do anything.

00:38:13.800 --> 00:38:14.800
Don't do that.

00:38:15.800 --> 00:38:19.650
Once you've done that,
this is where it gets

00:38:22.670 --> 00:38:23.620
There we go.

00:38:24.030 --> 00:38:26.100
This is where it gets very
slightly more complicated.

00:38:26.310 --> 00:38:31.230
You need to identify each place in your
app where you're doing an activity.

00:38:31.430 --> 00:38:33.100
And I realize that's
a somewhat fuzzy term,

00:38:33.100 --> 00:38:36.140
but basically the way to
think about it is this.

00:38:36.240 --> 00:38:39.720
If your application
were to quit right now,

00:38:39.720 --> 00:38:43.760
would that break something
the user was doing?

00:38:43.920 --> 00:38:46.980
So, for example, in iChat's case,

00:38:47.380 --> 00:38:50.610
If there's an open
connection to the IM server,

00:38:50.620 --> 00:38:51.340
you don't want to quit.

00:38:51.530 --> 00:38:52.760
That would terminate your connection.

00:38:52.760 --> 00:38:54.370
You'd appear as offline to people.

00:38:54.620 --> 00:38:56.130
That's not very good.

00:38:56.260 --> 00:38:58.920
In, say, Photoshop's case,
if you have an extremely

00:38:58.920 --> 00:39:01.910
long-running filter going,
you don't want to terminate

00:39:01.920 --> 00:39:03.170
in the middle of that.

00:39:03.720 --> 00:39:07.320
In general, any application that has
a long task running on the

00:39:07.320 --> 00:39:08.950
user's behalf should do this.

00:39:09.030 --> 00:39:11.760
And what you do is
just before doing that,

00:39:11.880 --> 00:39:16.800
you call disableAutomaticTermination
on NSProcessInfo.

00:39:16.960 --> 00:39:19.790
And you can pass a reason argument here,
which is a string.

00:39:19.890 --> 00:39:21.600
That doesn't actually do anything.

00:39:21.600 --> 00:39:25.960
It's just a hook for possible
debugging tools like DTrace,

00:39:25.960 --> 00:39:30.820
which will help you match up your
calls to disableAutomaticTermination

00:39:30.900 --> 00:39:33.110
with future calls to
enableAutomaticTermination to make

00:39:33.170 --> 00:39:34.800
sure you don't get those unbalanced.

00:39:34.910 --> 00:39:38.310
Because the next thing you need to
do is once you've finished doing

00:39:38.420 --> 00:39:41.610
your work on behalf of the user,
you return control to the system by

00:39:41.670 --> 00:39:46.730
calling enableAutomaticTermination,
again on NSProcessInfo.

00:39:47.380 --> 00:39:51.800
So I mentioned before that there are
two types of automatic termination.

00:39:52.320 --> 00:39:55.310
You can have processes with no
application associated with them,

00:39:55.330 --> 00:39:59.200
and you can also have applications
with no process associated with them.

00:40:00.020 --> 00:40:04.940
These happen in related but
slightly different situations.

00:40:05.080 --> 00:40:08.660
If your application has open
windows that are not visible,

00:40:08.800 --> 00:40:10.290
all those open windows are restorable.

00:40:10.540 --> 00:40:11.890
Peter just showed you how to do that.

00:40:11.900 --> 00:40:14.900
You're not the active application.

00:40:14.900 --> 00:40:17.890
You haven't disabled
Automatic Termination.

00:40:18.020 --> 00:40:19.890
And the system is running
out of available memory.

00:40:19.900 --> 00:40:23.620
Then the system is free to terminate
your process while leaving your

00:40:23.620 --> 00:40:25.750
application appearing to still run.

00:40:25.900 --> 00:40:28.560
If blue dots are on in the dock,
it will still show up

00:40:28.560 --> 00:40:29.890
with a blue dot there.

00:40:29.990 --> 00:40:31.720
If your application
isn't pinned to the dock,

00:40:31.720 --> 00:40:32.840
it'll still show up there.

00:40:32.920 --> 00:40:33.820
It'll appear in Command Tab.

00:40:33.900 --> 00:40:36.880
As far as the user can tell,
it's still running normally.

00:40:36.900 --> 00:40:40.090
When they click on it
or switch back to it,

00:40:40.350 --> 00:40:50.730
and David Smith will be here to help you.

00:40:50.730 --> 00:40:50.730
The system will relaunch it transparently
and all they will see is a slight

00:40:50.730 --> 00:40:50.730
lag as it comes back which is much,
much better than the system going into

00:40:50.730 --> 00:40:50.730
VM paging and everything slowing down.

00:40:50.990 --> 00:40:53.090
On the flip side,
you can have processes with

00:40:53.090 --> 00:40:54.200
no running application.

00:40:54.310 --> 00:40:57.100
This is where the new UI comes in.

00:40:57.560 --> 00:41:00.780
If your application has no open windows,
if the user has closed

00:41:00.780 --> 00:41:04.200
all of their documents,
it's not the active application,

00:41:04.270 --> 00:41:07.280
you haven't disabled
automatic termination,

00:41:07.280 --> 00:41:10.640
and at least one window
has ever been open,

00:41:10.670 --> 00:41:13.880
then your application
will appear to quit.

00:41:14.690 --> 00:41:16.100
This might seem a little bit unexpected.

00:41:16.100 --> 00:41:18.640
This is a new usability
model that we're pushing.

00:41:18.760 --> 00:41:21.640
We've seen a ton of people
switching from other systems,

00:41:21.700 --> 00:41:24.110
including iOS,
that expect applications to

00:41:24.110 --> 00:41:26.510
not require an explicit quit.

00:41:26.640 --> 00:41:29.970
You may have seen people with
every single app in their dock

00:41:29.970 --> 00:41:33.920
open and no windows and wondering
why they're running out of RAM.

00:41:34.640 --> 00:41:37.350
At this point,
the kernel will go through the

00:41:37.350 --> 00:41:41.100
list of processes and look for ones
that are using a lot of RAM and

00:41:41.100 --> 00:41:45.150
send them a message asking them
to terminate themselves quietly.

00:41:47.360 --> 00:41:50.280
Sorry, that happens if the system
runs out of memory after the

00:41:50.280 --> 00:41:52.000
application has appeared to quit.

00:41:52.160 --> 00:41:56.520
If the system doesn't run out of memory,
then the process will continue sitting

00:41:56.520 --> 00:42:00.950
in the background quietly using no CPU,

00:42:01.830 --> 00:42:04.680
and if the user relaunches it,
then it will just come

00:42:04.680 --> 00:42:07.040
back instantaneously,
which is pretty cool.

00:42:07.040 --> 00:42:12.440
So I'm going to give you a brief
demo where I convert Sketch over

00:42:12.440 --> 00:42:15.680
to Automatic Termination.

00:42:19.430 --> 00:42:21.980
My starting point here is
the Resume-enabled version

00:42:21.980 --> 00:42:24.900
of Sketch that Peter left me.

00:42:34.080 --> 00:42:38.740
I'm going to open Sketch,
close its documents.

00:42:38.740 --> 00:42:46.750
That one's actually already
Automatic Termination enabled.

00:42:46.790 --> 00:42:46.790
Well,

00:42:49.860 --> 00:42:54.420
So what you just saw there was
automatic termination in action.

00:42:54.450 --> 00:42:56.440
I wasn't actually expecting
that to happen quite yet,

00:42:56.440 --> 00:42:59.380
but that's fine.

00:42:59.870 --> 00:43:03.420
So if I go to Activity Monitor,
you can see that Sketch is

00:43:03.420 --> 00:43:04.900
actually still running.

00:43:05.560 --> 00:43:10.640
And if I open Sketch now,
it's going to come back instantly.

00:43:15.020 --> 00:43:18.760
If I actually hit Command-Q,
that's going to quit Sketch.

00:43:18.800 --> 00:43:20.540
But if I close the last
window and switch away,

00:43:20.670 --> 00:43:22.190
that will leave it running.

00:43:22.490 --> 00:43:25.680
Until I ask the system to reclaim memory.

00:43:25.870 --> 00:43:29.140
So I'm going to do that by
using a debugging tool that

00:43:29.140 --> 00:43:30.900
we have called TalAgent.

00:43:30.950 --> 00:43:33.170
That name may seem eerily
familiar to those of you who

00:43:33.250 --> 00:43:34.600
have been here in decades past.

00:43:34.600 --> 00:43:37.560
It's unrelated to the previous one.

00:43:37.880 --> 00:43:41.640
And I pass the -memory_pressure
argument to that.

00:43:41.840 --> 00:43:42.990
This is wrapping on a new line.

00:43:42.990 --> 00:43:44.950
Let me make that wider.

00:43:46.930 --> 00:43:48.870
You can see that the
Sketch process is still running,

00:43:48.960 --> 00:43:52.000
and when I trigger
system memory pressure,

00:43:52.100 --> 00:43:54.370
Sketch disappears
completely transparently.

00:43:54.450 --> 00:43:59.200
It freed all of its memory,
and whatever process triggered the memory

00:43:59.200 --> 00:44:01.170
pressure is now free to use more memory.

00:44:01.290 --> 00:44:11.690
So I'm going to add the Info.plist key,
and it supports automatic termination.

00:44:15.200 --> 00:44:20.310
And that's a Boolean.

00:44:20.310 --> 00:44:20.310
So Boolean.

00:44:21.710 --> 00:44:23.540
and David Gass.

00:44:23.580 --> 00:44:32.960
That's literally all it took to adopt
basic automatic termination in Sketch.

00:44:32.960 --> 00:44:32.960
However, I've added

00:44:34.960 --> 00:44:45.320
and David Smith.

00:44:46.440 --> 00:44:46.480
We will assume the user doesn't
want their important work

00:44:46.480 --> 00:44:46.480
going away when I switch away.

00:44:48.460 --> 00:44:55.590
So what I'm going to need to
do here is go to the file with

00:44:55.590 --> 00:44:59.880
my important work function,
which is SKT AppDelegate.

00:45:05.390 --> 00:45:08.360
Find my doBackgroundOperation
method that I added here,

00:45:08.360 --> 00:45:11.180
which is just showing a progress panel.

00:45:11.300 --> 00:45:16.760
And around that,
I'm going to add a call to NSProcessInfo.

00:45:18.210 --> 00:45:20.740
Disable Automatic Termination.

00:45:20.800 --> 00:45:23.410
And for the reason I'm going to put,

00:45:24.180 --> 00:45:26.040
doing important work.

00:45:26.070 --> 00:45:27.990
As I said before,
the reason argument is really

00:45:28.000 --> 00:45:29.500
not important for functionality.

00:45:29.500 --> 00:45:31.700
You just want it to be descriptive
so when you're debugging,

00:45:31.700 --> 00:45:34.080
you can tell what the heck is going on.

00:45:36.600 --> 00:45:40.680
And that needs to go where
we are starting to do work.

00:45:40.680 --> 00:45:45.980
And then when we're done doing work,
I just add a call to re-enable

00:45:45.980 --> 00:45:47.600
Automatic Termination.

00:45:47.600 --> 00:45:55.760
And you want the reason argument
that you passed to match.

00:46:02.520 --> 00:46:11.180
So now if I build this and run
Sketch and start doing background work,

00:46:11.260 --> 00:46:14.780
switch away,
Sketch now still appears to be running.

00:46:15.130 --> 00:46:18.740
That is exactly what the user
would expect in this case.

00:46:19.020 --> 00:46:21.690
Their important work was not lost.

00:46:22.140 --> 00:46:26.310
and if I then stop doing
background work and switch away,

00:46:26.310 --> 00:46:27.590
Sketch disappears from the doc.

00:46:27.590 --> 00:46:30.930
So the key things that
we've learned here,

00:46:30.930 --> 00:46:34.030
I'm going to switch back to the slides.

00:46:36.370 --> 00:46:39.860
Opt-in:
Enable automatic termination using the

00:46:40.050 --> 00:46:43.080
NSSupportsAutomaticTermination key.

00:46:43.080 --> 00:46:46.170
Then disable automatic
termination around important work.

00:46:46.400 --> 00:46:49.140
And finally, test with the TalAgent tool.

00:46:49.140 --> 00:46:51.790
You can find that in
System Library Core Services and you

00:46:51.900 --> 00:46:53.740
pass the -memory_pressure argument.

00:46:53.950 --> 00:46:56.300
I believe there's a man
page for it if you forget.

00:46:56.300 --> 00:46:58.510
We really only want you
to use this for testing.

00:46:58.650 --> 00:47:01.650
I realize it's tempting to stick
a utility out there for $10 that

00:47:01.650 --> 00:47:04.780
triggers system memory pressure
as a cleanup tool or something.

00:47:05.060 --> 00:47:07.300
That really,
really won't do anything and we

00:47:07.310 --> 00:47:10.440
don't guarantee that this tool is
even going to exist in the future.

00:47:10.590 --> 00:47:12.800
It's just a debugging tool.

00:47:12.980 --> 00:47:15.660
But definitely test your
application because you don't

00:47:15.660 --> 00:47:17.700
want it doing anything unexpected.

00:47:25.530 --> 00:47:30.290
So to recap,
enable automatic termination,

00:47:30.290 --> 00:47:35.060
disable and then enable around activity,
test with Tal Agent.

00:47:35.910 --> 00:47:39.790
So I'm going to finish up here by
doing a bit of blue sky talking.

00:47:39.800 --> 00:47:41.800
I realize we don't
normally do that at WWDC,

00:47:41.860 --> 00:47:45.910
but I think there's some really exciting
things that could be done with this.

00:47:46.340 --> 00:47:49.640
So I want to do a little
thought experiment.

00:47:49.680 --> 00:47:52.790
I want you to imagine a world
where there literally isn't a way

00:47:53.090 --> 00:47:55.600
for users to quit applications.

00:47:57.690 --> 00:48:01.240
where applications go away entirely on
their own when the user's done with them,

00:48:01.240 --> 00:48:03.930
and users don't really
need to manage them.

00:48:03.960 --> 00:48:06.930
And as an extension of that,
where there's no way to tell

00:48:06.930 --> 00:48:08.570
if an application is running.

00:48:08.580 --> 00:48:12.520
And that would also mean that a
user has no reason to need to know

00:48:12.520 --> 00:48:13.740
that an application is running.

00:48:13.740 --> 00:48:16.320
All they need to know is,
does this application

00:48:16.380 --> 00:48:17.690
have open documents?

00:48:17.700 --> 00:48:20.180
Is this application
doing work on my behalf?

00:48:20.220 --> 00:48:22.390
And that's a completely
separate concept from,

00:48:22.400 --> 00:48:23.210
is it running?

00:48:24.100 --> 00:48:27.480
We can just eliminate this concept
from the user's vocabulary and

00:48:27.480 --> 00:48:29.400
simplify the system in the process.

00:48:29.400 --> 00:48:32.250
And finally,
I'd like you to imagine a world in which

00:48:32.280 --> 00:48:36.330
your parents never call you and say,
my computer's slow, fix it.

00:48:40.040 --> 00:48:41.600
I think we can do something like this.

00:48:41.660 --> 00:48:44.410
Lion is a big step in that direction.

00:48:44.410 --> 00:48:47.310
And if all of your applications are
on board with Automatic Termination,

00:48:47.450 --> 00:48:50.940
then I think we can keep pressing
forward in this direction.

00:48:51.660 --> 00:48:55.060
Thank you for coming to our talk on
Resume and Automatic Termination,

00:48:55.100 --> 00:48:58.670
and hopefully you will adopt
it in your applications.

00:48:58.890 --> 00:49:00.560
You can get more information
from Bill Dudney.

00:49:00.670 --> 00:49:03.880
He's our Applications
Frameworks Evangelist.

00:49:03.940 --> 00:49:07.310
We have documentation on everything
that we've talked about here on

00:49:07.310 --> 00:49:10.520
the developer.apple.com site.

00:49:10.590 --> 00:49:14.140
And you can come to our developer forums
where we are indeed reading your posts

00:49:14.190 --> 00:49:16.750
and most of the time replying to them.

00:49:17.990 --> 00:49:20.000
There's two related sessions
which have already happened,

00:49:20.000 --> 00:49:21.400
so hopefully you went to those.

00:49:21.540 --> 00:49:24.060
There's What's New in Cocoa,
where we discussed a number of

00:49:24.060 --> 00:49:26.290
things that are new in Cocoa,
as well as Automatic

00:49:26.290 --> 00:49:27.620
Termination and Resume.

00:49:27.620 --> 00:49:31.570
And there's Autosave and Versions,
which tie very closely into this.

00:49:31.670 --> 00:49:37.760
You noticed that Autosave allowed the
Resume demo earlier to work automatically

00:49:37.850 --> 00:49:40.310
for documents that have titles.
WEBVTT

00:00:10.660 --> 00:00:12.700
Hello, everybody.

00:00:12.770 --> 00:00:13.700
Thank you so much for coming.

00:00:13.860 --> 00:00:16.880
This is Auto Save and
Versions in Mac OS X Lion.

00:00:16.960 --> 00:00:19.050
My name is Tony Parker,
and I'm an engineer on the

00:00:19.050 --> 00:00:20.660
Cocoa Frameworks team at Apple.

00:00:22.690 --> 00:00:25.080
So today we're going to talk about
three of the great new features

00:00:25.080 --> 00:00:26.960
you've been hearing about in Lion.

00:00:27.020 --> 00:00:30.730
Auto Save, where we free the user from
having to worry about manually

00:00:30.730 --> 00:00:32.360
saving their document.

00:00:32.450 --> 00:00:34.880
Versions,
which allows the user to go back

00:00:34.880 --> 00:00:38.430
further in time than just the last
version that they've saved on disk.

00:00:38.550 --> 00:00:41.200
And finally,
we'll talk about iCloud integration.

00:00:41.280 --> 00:00:43.600
And we'll talk about how you
can adopt each of these features

00:00:43.710 --> 00:00:48.190
in your application and really
become a first class Lion citizen.

00:00:48.820 --> 00:00:52.120
So all of these features are
integrated into your application in

00:00:52.200 --> 00:00:55.040
Cocoa via the NSDocument architecture.

00:00:55.140 --> 00:00:58.690
So first, I'm going to talk a little bit
about the basics of NSDocument,

00:00:58.730 --> 00:01:01.750
and then we'll move on to
those three new features.

00:01:03.600 --> 00:01:06.380
So here are three examples of
a document-based application.

00:01:06.440 --> 00:01:08.630
There's Numbers, Pages, and Keynote,
of course.

00:01:08.700 --> 00:01:11.220
And in these applications,
and in applications like them,

00:01:11.520 --> 00:01:13.770
the user will open up a document,
make changes,

00:01:13.930 --> 00:01:16.860
perhaps share them with other people,
save those changes,

00:01:16.970 --> 00:01:18.980
and print them and do other things.

00:01:19.100 --> 00:01:22.050
So a counter example to a
document-based application would

00:01:22.150 --> 00:01:26.560
be something like iPhoto or iTunes,
where we call those shoebox applications.

00:01:26.740 --> 00:01:30.800
Maybe the user has thousands of
files on disk that are managed

00:01:30.800 --> 00:01:32.550
through a single window interface.

00:01:34.190 --> 00:01:36.530
So if you're not using NSDoctument yet,
let me show you a few of the

00:01:36.540 --> 00:01:40.440
features that you get for free
when you adopt NSDoctument.

00:01:40.510 --> 00:01:42.740
There is everything in this file menu.

00:01:42.800 --> 00:01:44.740
We, of course,
let you create new documents,

00:01:44.780 --> 00:01:47.460
open existing documents,
and NSDoctument integrates

00:01:47.580 --> 00:01:50.160
with the Open and Save panel.

00:01:50.400 --> 00:01:53.630
We manage the Open Recent menu for you,
and that includes integrating with

00:01:53.750 --> 00:01:56.750
system preferences and respecting
the user's preferences for how many

00:01:56.750 --> 00:01:58.770
documents they want to display there.

00:01:58.850 --> 00:02:00.340
You can, of course, close documents.

00:02:00.400 --> 00:02:04.130
And for Auto Save applications,
we now have Save a Version, Duplicate,

00:02:04.150 --> 00:02:07.160
and Revert to Saved will
open up the version's UI.

00:02:07.490 --> 00:02:10.710
NSDocument also provides
support for printing.

00:02:12.080 --> 00:02:14.660
Every document, of course,
is going to have at least one window.

00:02:14.720 --> 00:02:16.230
And here you see one example.

00:02:16.310 --> 00:02:19.000
And the window is integrated
with the Save panel as well.

00:02:19.000 --> 00:02:21.680
And in this example,
I am saving this document

00:02:21.710 --> 00:02:23.340
to my Documents folder.

00:02:23.530 --> 00:02:27.060
And to manage those windows,
NSDocument works with NSWindow and

00:02:27.060 --> 00:02:31.380
NSWindowController to allow the
user to manage the windows in terms

00:02:31.480 --> 00:02:35.420
of what order they are on screen
and minimizing and zooming them.

00:02:36.330 --> 00:02:39.380
Under the hood, NSDocument provides a
lot more features too.

00:02:39.430 --> 00:02:42.260
There's integration with Undo
Manager and tracking of the

00:02:42.330 --> 00:02:43.380
edited state of the document.

00:02:43.380 --> 00:02:46.080
In Auto Save applications,
that will show up as the

00:02:46.080 --> 00:02:48.560
new edited indication near
the title of the document.

00:02:48.560 --> 00:02:51.840
And for non-Auto Save applications,
that includes the dirty

00:02:51.840 --> 00:02:53.360
dot in the close button.

00:02:53.360 --> 00:02:56.030
NSDocument also does Safe Save for you.

00:02:56.030 --> 00:02:59.950
That is where we atomically save the
document by writing it to the side

00:02:59.950 --> 00:03:03.620
and then swapping it in as a last
step so that the user's data is safe

00:03:03.630 --> 00:03:06.180
even if a failure occurs during save.

00:03:06.300 --> 00:03:09.300
And NSDoctument will present
errors to the user in the form

00:03:09.300 --> 00:03:13.160
of sheets and take care of that
kind of presentation for you.

00:03:14.200 --> 00:03:17.880
Now, new in Lion, we've added a ton of
features to NSDocument.

00:03:17.880 --> 00:03:21.500
That includes support for sandboxing,
support for file coordination,

00:03:21.500 --> 00:03:24.970
which is a new technology we have
in Lion for serializing access

00:03:24.970 --> 00:03:28.500
to files between applications,
support for duplicating documents,

00:03:28.500 --> 00:03:31.910
of course, Auto Save and Versions and
Cloud Document Storage,

00:03:32.140 --> 00:03:36.690
including using the versions UI to
resolve conflicts that may occur.

00:03:38.720 --> 00:03:42.010
The basic architecture of
NSDocument has three main classes:

00:03:42.140 --> 00:03:45.700
NSDocumentController, NSWindowController,
and NSDocument.

00:03:45.790 --> 00:03:48.690
So let's look at each of these classes
briefly and some of their key methods.

00:03:48.700 --> 00:03:51.640
NSDocumentController's job is to create,
open, track,

00:03:51.700 --> 00:03:55.700
and manage all of the documents
that an application has open.

00:03:55.700 --> 00:03:59.780
It is typically not subclassed
and is a singleton object,

00:03:59.780 --> 00:04:01.700
so you get one using the
sharedDocumentController

00:04:01.700 --> 00:04:03.700
method on the class there.

00:04:03.760 --> 00:04:06.080
And because it manages
the list of documents,

00:04:06.190 --> 00:04:09.090
you can ask it for a list of
all documents that are open.

00:04:09.760 --> 00:04:12.250
and his document controller is
also responsible for starting the

00:04:12.250 --> 00:04:16.900
job of creating a new document
using this new document method,

00:04:16.930 --> 00:04:20.660
that's a message that's sent when the
user chooses New from the File menu,

00:04:20.700 --> 00:04:23.870
and also for handling the process
of starting opening documents

00:04:24.030 --> 00:04:26.650
using methods like this one,
which is New in Lion and allows

00:04:26.840 --> 00:04:30.490
a completion handler to be
called when the open is finished.

00:04:32.290 --> 00:04:35.530
NSWindowController's job is to manage
one window associated with a document.

00:04:35.540 --> 00:04:39.060
In contrast to NSDocumentController,
it is typically

00:04:39.060 --> 00:04:40.520
customized by subclassing.

00:04:40.540 --> 00:04:44.100
There are two interesting methods,
initWithWindowNibNameOwner,

00:04:44.100 --> 00:04:47.900
that lets you specify the nib file
that contains the user interface that

00:04:47.910 --> 00:04:50.960
you want to display for your document,
and the document that's associated

00:04:50.960 --> 00:04:52.430
with the WindowController.

00:04:55.090 --> 00:04:57.300
and finally we have NSDocument itself.

00:04:57.360 --> 00:05:00.500
Its job is to represent,
store and load persistent data.

00:05:00.560 --> 00:05:03.000
And really it's about where
you put your logic to make your

00:05:03.000 --> 00:05:05.000
document-based application unique.

00:05:05.000 --> 00:05:09.170
Now in contrast to some of the other
classes in the Cocoa frameworks,

00:05:09.320 --> 00:05:11.990
it is customized by subclassing,
not by delegation.

00:05:11.990 --> 00:05:16.000
And you always subclass it
to add your functionality.

00:05:16.100 --> 00:05:19.170
When you subclass NSDocument,
you have your choice of methods

00:05:19.240 --> 00:05:21.000
to override to put that logic.

00:05:21.000 --> 00:05:23.000
And here are two examples.

00:05:23.000 --> 00:05:26.000
Read from data of type error
and data of type error.

00:05:26.140 --> 00:05:27.950
The first one,
you were given an NSData object

00:05:28.080 --> 00:05:30.990
that contains the state of your
document as it existed on disk.

00:05:31.090 --> 00:05:34.570
And your job in your implementation is
to take that data and make your in-memory

00:05:34.570 --> 00:05:35.960
representation of your document.

00:05:36.000 --> 00:05:38.640
Data of type error is
the opposite of that,

00:05:38.760 --> 00:05:42.940
where you create the data from
the in-memory representation.

00:05:43.010 --> 00:05:45.990
And we'll take that data and
serialize it to disk for you.

00:05:46.000 --> 00:05:46.990
Thank you.

00:05:48.070 --> 00:05:50.240
and his document is
also a controller class.

00:05:50.240 --> 00:05:52.800
So when the user chooses
Save from the File menu,

00:05:52.800 --> 00:05:56.600
then it receives this
Save Document message.

00:05:56.670 --> 00:06:00.070
And we also keep track of properties
of the document using methods like

00:06:00.080 --> 00:06:03.190
File URL and IsDocumentEdited.

00:06:04.980 --> 00:06:07.360
So let's look at a graph to
see how this fits together.

00:06:07.360 --> 00:06:09.910
And as Document Controller,
our Singleton instance

00:06:10.020 --> 00:06:11.400
is there at the top.

00:06:11.460 --> 00:06:14.280
This application has two
document subclasses and two

00:06:14.280 --> 00:06:15.220
documents that are open.

00:06:15.400 --> 00:06:18.910
There's an RTF document
and a plain text document.

00:06:19.170 --> 00:06:22.860
and each of these document subclasses
has their own window controllers,

00:06:22.860 --> 00:06:25.300
and of course the window
controllers manage the windows.

00:06:25.340 --> 00:06:27.710
And you can see that it's perfectly
acceptable for a document to have

00:06:27.710 --> 00:06:31.890
more than one window open that
points to the same document contents.

00:06:33.330 --> 00:06:36.990
Another way to understand how
NSDoctument works is looking at the

00:06:36.990 --> 00:06:40.330
message flow that occurs between
these three key classes when you

00:06:40.330 --> 00:06:42.040
perform certain kinds of activities.

00:06:42.170 --> 00:06:45.610
So first, let's look at what happens
when you open a document.

00:06:46.110 --> 00:06:48.810
So in the NSDocumentController,
it's going to receive the

00:06:48.810 --> 00:06:52.450
Open Document message because the
user has chosen the Open menu item.

00:06:52.460 --> 00:06:54.520
Oh, and here we're going to go
through some of the key methods,

00:06:54.520 --> 00:06:56.300
not every method involved,
just the key ones.

00:06:56.300 --> 00:07:00.000
So once the user has chosen
one or more documents,

00:07:00.000 --> 00:07:02.990
because of course you can open many
documents from that Open panel,

00:07:03.000 --> 00:07:07.060
we get the list of URLs they chose by
calling URLs from running Open panel.

00:07:07.060 --> 00:07:09.810
And for each of those documents,
we will open them,

00:07:10.210 --> 00:07:13.200
starting with Open Document with
contents of URL display error.

00:07:13.900 --> 00:07:18.300
Now, these documents can be of any of the
types that your application supports,

00:07:18.380 --> 00:07:21.360
so we need to find out what kind
of NSDocument subclass to use.

00:07:21.360 --> 00:07:24.980
We figure that out and type
for contents of URL error.

00:07:24.980 --> 00:07:31.080
And then finally,
we call make document with contents of

00:07:31.080 --> 00:07:35.640
URL of type error to begin the process
of creating the NSDocument subclass.

00:07:35.700 --> 00:07:38.460
So here it's a MyRTF document.

00:07:38.460 --> 00:07:42.100
Now, in that class,
we're going to initialize it, of course,

00:07:42.340 --> 00:07:43.880
using init with contents of URL.

00:07:43.900 --> 00:07:44.800
And then we're going to call
read from URL of type error.

00:07:44.800 --> 00:07:47.390
And that will begin the process
of reading the document.

00:07:47.400 --> 00:07:49.980
That starts with read
from URL of type error,

00:07:49.980 --> 00:07:52.480
which we'll call read from
file wrapper of type error,

00:07:52.480 --> 00:07:55.560
or read from data of type error,
depending on which of those two methods

00:07:55.610 --> 00:07:57.080
you've overridden in your subclass.

00:07:57.080 --> 00:07:59.220
Next,
we add the document to the list that

00:07:59.220 --> 00:08:03.840
the NSDocument controller is managing,
make the window controllers,

00:08:03.840 --> 00:08:06.480
including calling init
with window nibname owner,

00:08:06.480 --> 00:08:08.710
and then finally,
show the windows associated

00:08:08.820 --> 00:08:09.920
with the document.

00:08:09.920 --> 00:08:11.110
All right.

00:08:12.570 --> 00:08:17.140
Let's look at a second example that is
what happens when you save a document.

00:08:17.190 --> 00:08:19.950
So here, let's assume that the document
has been named by the user,

00:08:19.950 --> 00:08:22.540
and they've chosen
Save from the File menu.

00:08:22.580 --> 00:08:26.200
And this document will receive
the Save Document message.

00:08:26.240 --> 00:08:28.680
That, in turn,
will call Saved URL of type for

00:08:28.710 --> 00:08:30.600
Save Operation Completion Handler.

00:08:30.750 --> 00:08:33.800
The URL we already know because
the document has been named.

00:08:33.840 --> 00:08:36.660
The type we already know because
of the kind of document it is.

00:08:36.690 --> 00:08:40.170
The Save Operation parameter can be Save,
Save As, Auto Save.

00:08:40.240 --> 00:08:41.960
There's a few different options there.

00:08:41.990 --> 00:08:45.710
and that completion handler again will
be called when the save is finished.

00:08:45.870 --> 00:08:48.400
The first step of saving is
calling WriteSafelyToURLofType

00:08:48.400 --> 00:08:51.060
for SaveOperationError,
and this is where NSDoctument

00:08:51.160 --> 00:08:54.880
implements the safe save logic
that we give you for free.

00:08:54.960 --> 00:08:58.010
Part of WritingSafely
is WriteToURLofType for

00:08:58.010 --> 00:09:03.250
SaveOperationOriginalContentsURLError,
which will then call

00:09:03.250 --> 00:09:07.340
WriteToURLofTypeError,
which calls DataOfTypeError

00:09:07.410 --> 00:09:10.360
or FileWrapperOfTypeError,
depending again on which

00:09:10.360 --> 00:09:11.780
one you've overwritten.

00:09:12.380 --> 00:09:14.780
So the key point here is that, of course,
you, again,

00:09:14.780 --> 00:09:16.930
you customize NSDocument by subclassing.

00:09:16.980 --> 00:09:20.200
And when you subclass,
you can override at any point along this

00:09:20.200 --> 00:09:23.700
list of save methods or write methods,
and in a similar fashion

00:09:23.700 --> 00:09:25.380
when you open documents.

00:09:25.460 --> 00:09:29.480
Now, when you override at the
beginning of this list,

00:09:29.480 --> 00:09:32.480
at the top,
you can put more custom behavior

00:09:32.530 --> 00:09:36.150
into the NSDocument architecture
because you're cutting off a lot

00:09:36.240 --> 00:09:37.510
of the functionality below it.

00:09:38.490 --> 00:09:41.430
The flip side of that, of course,
is that the more, the lower the method on

00:09:41.570 --> 00:09:45.210
this list you override is,
the more functionality you get for free.

00:09:45.410 --> 00:09:47.940
And when we add document
features to NSDocument,

00:09:47.940 --> 00:09:50.790
like Auto Save, Versions,
and iCloud integration,

00:09:50.840 --> 00:09:54.440
the lower you are in this list,
the easier it is for your application

00:09:54.500 --> 00:09:56.040
to adopt those new features.

00:09:56.040 --> 00:10:00.000
So we recommend that when
subclassing NSDocument,

00:10:00.000 --> 00:10:02.790
you start at the bottom and only
work your way up if you find

00:10:02.790 --> 00:10:05.610
that you need something only
available at the previous level.

00:10:08.600 --> 00:10:10.900
Okay, with the basics out of the way,
let's talk about the

00:10:10.900 --> 00:10:14.000
first major new feature,
and that's Auto Save.

00:10:14.160 --> 00:10:17.110
So here you see an example of
an Auto Saving application.

00:10:17.300 --> 00:10:23.130
The edited menu in the middle there
allows the user additional options

00:10:23.130 --> 00:10:25.290
that they didn't have before.

00:10:25.760 --> 00:10:30.810
And really, Auto Save is about saving
automatically at key times.

00:10:31.100 --> 00:10:54.300
[Transcript missing]

00:10:56.420 --> 00:10:59.330
We wanted to make Auto Save as
easy to enable in your application

00:10:59.340 --> 00:11:01.440
as it is for users to use it.

00:11:01.580 --> 00:11:04.620
So to turn it on and get
a ton of functionality,

00:11:04.650 --> 00:11:07.420
you only need to override
one method in NSDocument,

00:11:07.440 --> 00:11:11.680
and that's Auto Saves in Place,
Return Yes.

00:11:12.400 --> 00:11:14.800
And when you turn this on,
just try it out.

00:11:14.800 --> 00:11:16.510
If you take one thing
away from this talk,

00:11:16.570 --> 00:11:20.250
I want you to put this method in
your NSDocuments subclass and see how

00:11:20.250 --> 00:11:22.300
much functionality you get for free.

00:11:22.480 --> 00:11:25.300
This enables Auto Save,
this enables versions,

00:11:25.420 --> 00:11:28.800
it adds a whole host of behaviors
that we're going to talk about soon.

00:11:28.800 --> 00:11:30.800
So it's really simple,
just that one method.

00:11:30.800 --> 00:11:32.760
And of course,
you should try it out in your

00:11:32.830 --> 00:11:34.300
application and see what happens.

00:11:34.310 --> 00:11:36.300
And to show us what
happens in an example app,

00:11:36.300 --> 00:11:40.330
I'd like to invite my colleague
Kevin Perry up to give us a quick demo.

00:11:45.110 --> 00:11:47.970
Good afternoon, I'm Kevin Perry,
another engineer on the

00:11:48.050 --> 00:11:50.280
Cocoa Frameworks team.

00:11:50.390 --> 00:11:56.040
And here we have the
classic sample app sketch.

00:11:56.130 --> 00:12:00.120
And this is before we've done
any modifications for Lion.

00:12:00.230 --> 00:12:02.910
And so when I edit a document,

00:12:04.040 --> 00:12:06.970
The contents that you see
of the document on screen,

00:12:06.970 --> 00:12:12.700
we typically think of that as being
different than the document on disk.

00:12:13.160 --> 00:12:17.940
and David are going to talk about how to
use the Dirty Dot in the Closed button.

00:12:17.940 --> 00:12:22.940
We indicate this state to the
user with the Dirty Dot that's

00:12:22.940 --> 00:12:26.810
up here in the Closed button.

00:12:26.810 --> 00:12:31.260
And again, when you close the document,
we ask you, do you want to save this

00:12:31.400 --> 00:12:33.300
before you close the document?

00:12:33.300 --> 00:12:38.760
All this happens because we put the
responsibility of saving on the user.

00:12:38.760 --> 00:12:43.160
So let me show you how we can give
responsibility for saving instead to the

00:12:43.450 --> 00:12:47.080
framework and free that from the user.

00:12:48.810 --> 00:12:51.940
So like Tony said,
all we need to do here in our

00:12:51.940 --> 00:12:57.500
NSDocument subclass is override
Auto Saves in place and return yes.

00:12:57.540 --> 00:13:01.430
So let me just enable that and we'll run.

00:13:02.720 --> 00:13:05.740
So now when I edit a document,
you can start to think about

00:13:05.740 --> 00:13:10.340
what's on screen being the same
as what's on disk at all times.

00:13:10.830 --> 00:13:14.750
We indicate this state to the
user in a different way in Lion,

00:13:14.750 --> 00:13:20.270
specifically this edited
indication in the title bar.

00:13:21.030 --> 00:13:24.730
This is helpful not only to know
when you've edited your document,

00:13:24.730 --> 00:13:27.140
but in case you make
an accidental change,

00:13:27.140 --> 00:13:32.320
you can notice that and either undo your
changes or revert to a previous version.

00:13:33.630 --> 00:13:40.340
Also,
now when we close a changed document,

00:13:40.340 --> 00:13:40.340
an edited document,

00:13:40.770 --> 00:13:42.130
You're not warned about saving.

00:13:42.350 --> 00:13:46.230
The framework has either already
done it or does it when we close

00:13:46.230 --> 00:13:49.740
the document so the user doesn't
even have to think about it.

00:13:51.040 --> 00:13:54.720
Like Tony showed you before,
there are also some changes to

00:13:54.720 --> 00:13:59.060
the File menu to adapt to this
new mental model of saving.

00:13:59.300 --> 00:14:01.970
Instead of Save, we have Save a Version.

00:14:02.100 --> 00:14:04.660
Instead of Save As, we have Duplicate.

00:14:04.840 --> 00:14:07.880
Instead of Save a Copy As,
we have Export.

00:14:07.970 --> 00:14:12.640
And Revert to Saved
brings you into Versions,

00:14:12.720 --> 00:14:17.560
where you're able to browse
previous versions of your document,

00:14:17.740 --> 00:14:21.570
You can even select and copy
something from a previous version

00:14:21.570 --> 00:14:25.370
and paste it in the current one.

00:14:26.000 --> 00:14:31.400
or you can choose to completely replace
the current version with a previous one.

00:14:32.100 --> 00:14:35.040
So this is a lot of great functionality
you can get with very little

00:14:35.180 --> 00:14:36.820
code in your document subclass.

00:14:36.820 --> 00:14:39.880
And again, as Tony said,
we encourage you just to go try

00:14:39.880 --> 00:14:41.470
it out and see how it works.

00:14:41.600 --> 00:14:45.290
I'll show you a little bit later
how a little bit more code can

00:14:45.300 --> 00:14:47.640
get you even more great features.

00:14:47.640 --> 00:14:49.110
Now back to Tony.

00:14:55.190 --> 00:14:56.860
Thanks, Kevin.

00:14:56.950 --> 00:14:59.940
So you can see just that one
method and all that functionality

00:14:59.940 --> 00:15:03.100
completely for free in Sketch.

00:15:03.250 --> 00:15:08.260
Now, as easy as it is to turn on,
there are still a few things you can

00:15:08.260 --> 00:15:13.100
do to really polish the Auto Save user
experience once you've enabled it.

00:15:13.100 --> 00:15:16.100
We're going to talk about being
smart about when you save,

00:15:16.100 --> 00:15:19.100
allowing the user to cancel
certain kinds of saves,

00:15:19.100 --> 00:15:22.400
and a major new feature in
NSDocument in Lion to allow

00:15:22.400 --> 00:15:24.600
saving on background threads.

00:15:25.530 --> 00:15:28.450
So first, being smart about when to save.

00:15:28.630 --> 00:15:31.850
So as we mentioned,
NSDoctument will save at key times

00:15:31.910 --> 00:15:34.880
and trigger an Auto Save when
the application quits,

00:15:34.930 --> 00:15:36.080
when the document is closed.

00:15:36.080 --> 00:15:37.850
Of course,
we need to make sure the contents are

00:15:37.850 --> 00:15:40.750
safe before the application goes away.

00:15:40.910 --> 00:15:44.280
We also Auto Save when the user
switches away from your application,

00:15:44.280 --> 00:15:47.480
and that's because it seems like a
good time to avoid interrupting the

00:15:47.480 --> 00:15:50.700
user and making sure the document
is consistent with what's on disk.

00:15:50.700 --> 00:15:53.290
In Lion,
we still have the Auto Save timer

00:15:53.300 --> 00:15:55.760
that you're familiar with
from Snow Leopard and earlier.

00:15:55.830 --> 00:15:57.300
However, we've improved it.

00:15:57.410 --> 00:16:01.190
So now it automatically readjusts
itself based on user activity.

00:16:01.460 --> 00:16:04.940
So the idea is that the timer
will not fire while the user is

00:16:04.940 --> 00:16:07.570
actively editing their document.

00:16:08.690 --> 00:16:11.660
We also save before the user reverts,
and the reason is because we need

00:16:11.660 --> 00:16:14.570
to keep the current contents in
case they change their mind about

00:16:14.580 --> 00:16:16.660
the revert they've just done.

00:16:17.130 --> 00:16:20.160
And a key point here,
your application can also

00:16:20.200 --> 00:16:21.000
trigger an auto save.

00:16:21.000 --> 00:16:25.500
You just call the save methods
with that auto save operation type.

00:16:25.640 --> 00:16:27.010
Now, you know your application best.

00:16:27.170 --> 00:16:29.160
We've done some key points here.

00:16:29.540 --> 00:16:31.910
But if you know of a place in
your application or a time in your

00:16:31.910 --> 00:16:35.400
application where you can save
without interrupting the user,

00:16:35.530 --> 00:16:38.820
then go ahead and do it yourself too.

00:16:39.570 --> 00:16:44.000
So part of being smart about when you
save is adoption of file coordination.

00:16:44.170 --> 00:16:46.400
Now as I mentioned,
file coordination is a new technology

00:16:46.400 --> 00:16:50.920
in Lion that serializes access
to files between applications.

00:16:50.970 --> 00:16:53.120
And if you use NSDocument,
you're in luck.

00:16:53.150 --> 00:16:54.940
We implemented it all for you.

00:16:54.990 --> 00:16:57.400
That means that we will
Auto Save automatically when a read

00:16:57.470 --> 00:17:02.260
is requested and notify you and reread
the contents when a write is completed.

00:17:02.400 --> 00:17:05.420
So an example of the former
is if you mail a document,

00:17:05.450 --> 00:17:09.650
then mail may ask your application to
please save right now so that we can have

00:17:09.650 --> 00:17:11.900
a consistent version of the document.

00:17:11.940 --> 00:17:15.930
And another example of the latter
there is if iCloud has synced a

00:17:15.930 --> 00:17:19.280
new version of your document down,
we need to make sure the user sees

00:17:19.370 --> 00:17:22.370
on screen what exists on disk.

00:17:22.570 --> 00:17:25.560
File coordination is such a
key technology to Auto Save,

00:17:25.770 --> 00:17:29.760
Versions, and iCloud support that we have
an entire talk devoted to it.

00:17:29.840 --> 00:17:31.880
It's called Taking Advantage
of File Coordination.

00:17:32.080 --> 00:17:35.040
It's in this room right after this talk.

00:17:36.890 --> 00:17:39.210
So the second method of polishing
the Auto Save user experience

00:17:39.540 --> 00:17:41.380
is to spend less time saving.

00:17:41.520 --> 00:17:44.040
So with Auto Save enabled, of course,
we are going to save much more

00:17:44.040 --> 00:17:46.250
frequently than in the past.

00:17:46.450 --> 00:17:49.480
And the key point is to
avoid interrupting the user.

00:17:49.540 --> 00:17:53.250
The last thing we want is for users
to use Auto Save enabled applications

00:17:53.660 --> 00:17:57.280
and feel like their entire time
they're spent staring at a beach ball.

00:17:57.470 --> 00:18:00.800
So one way you can do that is
to only save what's changed.

00:18:00.910 --> 00:18:05.120
And one way you can only save what's
changed is to use NSFileWrapper.

00:18:05.150 --> 00:18:08.610
NSFileWrapper stores the resources
in their most natural format,

00:18:08.610 --> 00:18:10.360
and it allows quick copies.

00:18:10.400 --> 00:18:12.820
That's because the user
is probably editing,

00:18:13.010 --> 00:18:16.220
say, the text component of your
document and not the movie,

00:18:16.250 --> 00:18:18.530
audio, or picture file.

00:18:18.810 --> 00:18:22.660
So we can change only the text part,
and the other resources can be used

00:18:22.660 --> 00:18:26.000
-- we can use hard links to make sure
that they're not copied unnecessarily.

00:18:26.040 --> 00:18:28.160
If you have a monolithic
flat file format,

00:18:28.160 --> 00:18:30.780
then the whole thing has
to be written every time.

00:18:30.800 --> 00:18:33.560
NSFileWrapper helps
you with that problem.

00:18:36.380 --> 00:18:39.180
So there's another method to
avoid interrupting the user,

00:18:39.180 --> 00:18:41.800
and that's what we call
a cancelable Auto Save.

00:18:42.030 --> 00:18:44.300
So to explain what it is,
first let me tell you what

00:18:44.300 --> 00:18:45.400
a normal Auto Save is.

00:18:45.400 --> 00:18:49.070
That happens when the application quits
or when the document closes or if it's

00:18:49.140 --> 00:18:51.060
been too long since the last save.

00:18:51.060 --> 00:18:54.420
And the reason for that last one
is because we want to make sure the

00:18:54.780 --> 00:18:57.930
user doesn't starve our readjusting
timer and avoid -- prevent

00:18:57.940 --> 00:18:59.860
the document from being saved.

00:18:59.950 --> 00:19:01.860
But the other kind of save then,
Auto Save,

00:19:01.940 --> 00:19:03.920
is an implicitly cancelable Auto Save.

00:19:03.920 --> 00:19:06.180
And right now in Lion,
we trigger those only based

00:19:06.180 --> 00:19:07.490
on the Auto Save timer.

00:19:07.600 --> 00:19:11.570
So the idea here is that, you know,
because the timer readjusts itself,

00:19:11.640 --> 00:19:15.800
we can try to put off saving while the
user is interacting with their document.

00:19:15.810 --> 00:19:17.780
But clearly we can't see the future.

00:19:17.780 --> 00:19:20.900
So if the user edits the
document and then waits,

00:19:20.900 --> 00:19:23.960
then the timer fires,
and then they decide to

00:19:23.960 --> 00:19:26.650
interact with the document,
we want to avoid interrupting

00:19:26.650 --> 00:19:27.920
them in that case,
too.

00:19:27.920 --> 00:19:30.380
So we can do that via this new technique.

00:19:30.380 --> 00:19:32.960
So here's an example of
how you might use it.

00:19:32.960 --> 00:19:35.750
In my write to URL of time,
I'm going to type error implementation.

00:19:35.770 --> 00:19:39.920
While I'm saving, I'm going to do some
work related to the save.

00:19:39.920 --> 00:19:44.040
And then every so often check to see if
auto saving is implicitly cancelable.

00:19:44.100 --> 00:19:46.810
If it is, then we should also
check for user activity.

00:19:46.850 --> 00:19:49.150
And the implementation of
that function is going to be

00:19:49.520 --> 00:19:51.250
highly application dependent.

00:19:51.320 --> 00:19:55.200
One example of what you might do could
include running the main run loop,

00:19:55.200 --> 00:19:57.420
looking for user events,
and then if you see one,

00:19:57.420 --> 00:19:59.930
decide that now might be
a good time to cancel.

00:19:59.930 --> 00:20:03.160
Once you've decided that
it's appropriate to cancel,

00:20:03.160 --> 00:20:03.900
you should abort the save.

00:20:03.900 --> 00:20:03.900
And then you can go back
to the main run loop,

00:20:03.900 --> 00:20:06.560
look for user events,
by creating a new error, NSError,

00:20:06.560 --> 00:20:08.920
excuse me, error with domain,
Cocoa error domain,

00:20:08.920 --> 00:20:11.680
ns Cocoa error domain,
and the ns user canceled error,

00:20:11.680 --> 00:20:13.880
and then return no from this method.

00:20:13.880 --> 00:20:18.160
It's important to use the Cocoa error
domain and the user canceled error,

00:20:18.160 --> 00:20:22.190
because what happens is that when you
return no and you use that kind of error,

00:20:22.200 --> 00:20:26.240
ns document will unwind the
save and avoid presenting the

00:20:26.240 --> 00:20:28.820
user with an error that says,
hey, you just canceled a save.

00:20:28.860 --> 00:20:30.790
The whole point was to do it silently.

00:20:31.410 --> 00:20:35.650
So use this particular
error domain and code.

00:20:37.450 --> 00:20:40.880
So next we have this major
new feature in NSDocument,

00:20:40.880 --> 00:20:42.540
which is support for asynchronous saving.

00:20:42.540 --> 00:20:46.370
And we've tried to make it as easy
to enable as Auto Saving itself.

00:20:46.380 --> 00:20:51.150
You can see here you override, again,
one method in your NSDocument subclass.

00:20:51.150 --> 00:20:54.800
It's called can asynchronously
write to URL of type for save

00:20:54.800 --> 00:20:56.950
operation and then return yes.

00:20:56.950 --> 00:20:59.510
And of course,
because there's some parameters there,

00:20:59.510 --> 00:21:02.170
you have a choice about what kind
of save operations or type of

00:21:02.240 --> 00:21:04.240
documents you want to support saving.

00:21:04.240 --> 00:21:06.500
We recommend you support
as many as possible.

00:21:08.370 --> 00:21:11.280
So to show you why it's important
to use asynchronous auto saving,

00:21:11.300 --> 00:21:13.640
let's look at what happens
during a synchronous auto save.

00:21:13.720 --> 00:21:17.760
The user edits the document,
and that timer will start,

00:21:17.780 --> 00:21:20.520
because the document is now
dirty and needs to be saved.

00:21:20.560 --> 00:21:25.190
And at some point, the timer will fire,
and the user must wait.

00:21:25.600 --> 00:21:39.500
[Transcript missing]

00:21:39.600 --> 00:22:10.200
[Transcript missing]

00:22:11.330 --> 00:22:12.980
Here are the methods involved.

00:22:13.070 --> 00:22:16.090
The save operation will start on the
main thread using saved URL of type

00:22:16.110 --> 00:22:18.040
for save operation completion handler.

00:22:18.040 --> 00:22:20.050
At that time, the main thread will block.

00:22:20.100 --> 00:22:23.530
The saving will be started on
the background thread starting

00:22:23.530 --> 00:22:26.920
with write safely to URL of
type for save operation error.

00:22:26.920 --> 00:22:31.290
And then after the background thread has
snapshotted the contents of the document,

00:22:31.290 --> 00:22:35.520
it should allow the main thread to
continue using unblock user interaction.

00:22:35.530 --> 00:22:37.950
And the background thread
will finish saving.

00:22:37.950 --> 00:22:41.180
And that write and finish step can
take a long time on NSDocument.

00:22:43.360 --> 00:22:50.540
So,
we can have a huge win by adopting this.

00:22:50.970 --> 00:22:53.360
When we introduce
asynchrony into Auto Saving,

00:22:53.360 --> 00:22:54.980
there are a couple of concerns.

00:22:54.980 --> 00:22:57.530
The first is that there are
two categories of resources

00:22:57.530 --> 00:22:59.980
that need to be serialized.

00:23:00.040 --> 00:23:01.820
The first is the user.

00:23:01.820 --> 00:23:06.250
Anything that may present UI to
the user must be serialized.

00:23:06.430 --> 00:23:09.800
That includes saving, reverting,
duplicating, printing,

00:23:09.800 --> 00:23:11.900
or any other activities
that your application does.

00:23:11.900 --> 00:23:14.260
The second category is file access.

00:23:15.080 --> 00:23:17.200
And things in that
category include the URL,

00:23:17.200 --> 00:23:21.020
the modification date of the file,
the on-disk contents of the file,

00:23:21.020 --> 00:23:24.440
and the edited state of the document,
because the edited state compares,

00:23:24.440 --> 00:23:27.380
in a way, the on-disk contents to
the in-memory contents.

00:23:29.790 --> 00:23:34.300
So we have a way for you to coordinate
between threads when you're doing saves

00:23:34.300 --> 00:23:35.440
and using these kinds of activities.

00:23:35.440 --> 00:23:38.480
The first is if the main thread needs
to present something to the user,

00:23:38.480 --> 00:23:40.680
and only the main thread may
present anything to the user,

00:23:40.680 --> 00:23:41.260
of course.

00:23:41.260 --> 00:23:43.900
You should surround that work
with perform activity with

00:23:43.900 --> 00:23:45.650
synchronous waiting using block.

00:23:45.680 --> 00:23:47.860
The first parameter is
a hint to the app kit.

00:23:48.060 --> 00:23:50.930
Tell us whether or not this method
should return or not before that

00:23:50.930 --> 00:23:52.980
block parameter is executed.

00:23:52.980 --> 00:23:57.220
If you're up on your block syntax,
you can see that the block parameter

00:23:57.220 --> 00:23:59.180
takes a block parameter of its own.

00:23:59.590 --> 00:24:01.220
That's called the activity
completion handler.

00:24:01.220 --> 00:24:03.910
In your block,
you put the work that you need to be

00:24:03.910 --> 00:24:07.360
done that may present UI to the user,
and before you leave that block,

00:24:07.460 --> 00:24:09.560
you should call the
activity completion handler.

00:24:11.450 --> 00:24:15.140
If any thread, main or otherwise,
needs access to the document file on disk

00:24:15.300 --> 00:24:19.610
or any of the properties of that file,
you should do that work

00:24:19.710 --> 00:24:21.500
within one of these methods.

00:24:21.700 --> 00:24:24.800
Perform synchronous file access
using block and perform asynchronous

00:24:24.800 --> 00:24:26.080
file access using block.

00:24:26.140 --> 00:24:29.020
And you see the second one also
takes a completion handler block.

00:24:32.360 --> 00:24:35.380
and David . Let's see
how you might use those.

00:24:35.380 --> 00:24:37.230
Here is an example of
asynchronous file access.

00:24:37.340 --> 00:24:39.400
Let's say your application
has a requirement that as

00:24:39.400 --> 00:24:42.240
soon as the save is finished,
we have to compress the contents of

00:24:42.240 --> 00:24:46.510
that document and then copy it to
another place on the file system.

00:24:46.670 --> 00:24:49.170
That is clearly work that doesn't need
to block the user from interacting with

00:24:49.170 --> 00:24:53.320
the document and it could take a while,
so it seems like a great candidate

00:24:53.320 --> 00:24:55.060
to do on a background thread.

00:24:55.060 --> 00:24:55.980
So let's do that.

00:24:56.090 --> 00:24:58.990
We will start a background operation
and on that background thread,

00:24:58.990 --> 00:25:02.770
we will start asynchronous file
access using those methods.

00:25:02.780 --> 00:25:05.060
Inside the block,
we are going to perform that background

00:25:05.060 --> 00:25:08.460
work and then we are going to call
the completion handler and make sure

00:25:08.460 --> 00:25:10.700
that we end asynchronous file access.

00:25:10.790 --> 00:25:13.580
And in this way,
we ensure that the main thread

00:25:13.840 --> 00:25:18.820
does not touch the file at the same
time as the background thread is.

00:25:20.420 --> 00:25:24.050
Another potential thing to be concerned
about when you're using asynchronous

00:25:24.060 --> 00:25:27.240
saving is the potential of deadlock
since we have these serialized resources.

00:25:27.240 --> 00:25:30.350
And we need to make sure that
we coordinate access between

00:25:30.350 --> 00:25:32.340
user activities and file access.

00:25:32.340 --> 00:25:36.240
So what I mean is that you should
use these NSDoctument methods.

00:25:36.280 --> 00:25:40.010
The first is called continue asynchronous
work on main thread using block.

00:25:40.080 --> 00:25:42.130
This is for file access work.

00:25:42.200 --> 00:25:45.140
And the second is called
continue activity using block,

00:25:45.140 --> 00:25:47.480
and that's for user
activity kind of work.

00:25:48.320 --> 00:25:50.500
So I'll explain by way
of another example.

00:25:50.500 --> 00:25:54.180
So let's say that after saving,
we're going to calculate the file

00:25:54.190 --> 00:25:56.590
size of the newly saved document.

00:25:56.600 --> 00:25:59.420
And we're going to do that work
on a background thread too.

00:25:59.420 --> 00:26:02.320
And once we're done,
we're going to display that value

00:26:02.400 --> 00:26:04.370
to the user in an inspector panel.

00:26:04.380 --> 00:26:07.120
And of course, that's main thread work
because it's displaying UI.

00:26:07.120 --> 00:26:08.940
So let's take a first stab.

00:26:08.940 --> 00:26:13.740
In my background operation,
I'll start asynchronous file access.

00:26:13.740 --> 00:26:17.300
And inside that block,
I calculate the file size.

00:26:17.740 --> 00:26:19.360
But before it's done,
the user decides to go ahead

00:26:19.360 --> 00:26:20.540
and duplicate the document.

00:26:20.540 --> 00:26:24.050
Well, duplicating a document requires
file access as well because we

00:26:24.050 --> 00:26:27.000
need to make sure that we have the
current contents of the document.

00:26:27.000 --> 00:26:30.920
So we start asynchronous file
access on the main thread.

00:26:30.920 --> 00:26:34.710
And then the background thread says,
okay, I'm going to run this stuff on the

00:26:34.710 --> 00:26:38.760
main thread using perform selector
on thread or NSOperation main queue

00:26:38.760 --> 00:26:40.160
or any kind of technology like that.

00:26:40.250 --> 00:26:42.990
And at this point,
we've wound up in a state of deadlock.

00:26:43.180 --> 00:26:47.410
And the reason is because the background
thread is waiting on the main thread.

00:26:47.460 --> 00:26:48.510
To do the UI work.

00:26:48.520 --> 00:26:50.850
And the main thread is waiting
on the background thread to give

00:26:50.850 --> 00:26:52.280
up its asynchronous file access.

00:26:52.280 --> 00:26:53.990
So don't do this.

00:26:54.000 --> 00:26:58.510
Instead, use those NS document
methods I just talked about.

00:26:58.550 --> 00:27:01.270
We're going to use continue
asynchronous work on main thread.

00:27:01.280 --> 00:27:05.840
And this document is smart enough
to figure out that that work must be

00:27:05.840 --> 00:27:08.680
allowed to continue to avoid a deadlock.

00:27:08.760 --> 00:27:12.380
So the update user interface that the
background thread wanted will complete.

00:27:12.380 --> 00:27:17.220
And the background thread is allowed
to end its asynchronous file access.

00:27:17.300 --> 00:27:19.540
Which, of course,
will allow the main thread to

00:27:19.540 --> 00:27:22.660
finish its duplicate work and
end the synchronous file access.

00:27:22.660 --> 00:27:24.700
So we avoided the deadlock scenario.

00:27:27.700 --> 00:27:28.480
Okay.

00:27:28.600 --> 00:27:31.040
Oh, yes, do that with the check mark.

00:27:31.160 --> 00:27:34.750
So, to give us a demo of how
you can adopt some of these

00:27:34.870 --> 00:27:38.980
Auto Save polishing techniques,
I'd like to invite back Kevin.

00:27:43.890 --> 00:27:49.380
Let's go back to Sketch and
enable asynchronous saving.

00:27:49.570 --> 00:27:54.350
Sketch implements the data of
type error method that Tony talked

00:27:54.380 --> 00:27:57.950
about earlier in such a way that,
you know, it's thread safe.

00:27:58.140 --> 00:28:02.220
So all we need to do to enable
asynchronous saving is...

00:28:02.980 --> 00:28:07.260
and David Override can asynchronously
write to URL of type for save

00:28:07.260 --> 00:28:10.190
operation and return yes.

00:28:12.050 --> 00:28:15.840
This causes the data of type error method
to be invoked on a background thread.

00:28:15.840 --> 00:28:22.780
However, NSData doesn't know,
NSDocument doesn't know implicitly

00:28:22.830 --> 00:28:26.580
that our implementation of
this method is thread safe.

00:28:26.610 --> 00:28:30.420
And so, as Tony mentioned before,
we have to block the main thread

00:28:30.420 --> 00:28:33.140
until this method returns,
because this is the

00:28:33.930 --> 00:28:35.870
prepare step of the save.

00:28:36.780 --> 00:28:37.930
Normally this won't be a problem.

00:28:37.940 --> 00:28:41.020
If you just have a few graphics
in your Sketch document,

00:28:41.080 --> 00:28:46.420
the serialization into NNS data and
the writing to a relatively fast

00:28:46.840 --> 00:28:50.830
file system won't take a noticeable
amount of time to the user.

00:28:51.050 --> 00:28:54.600
However, if you have many graphics
in your document,

00:28:54.660 --> 00:28:58.890
this won't scale so well because
the user will start to notice that

00:28:58.890 --> 00:29:02.680
it's taking a long time to serialize
all these graphics into NNS data and

00:29:02.680 --> 00:29:05.060
they may encounter the wait cursor.

00:29:05.130 --> 00:29:07.410
Let's simulate this.

00:29:08.080 --> 00:29:12.700
by inserting a good old sleep
at the end of this method.

00:29:12.790 --> 00:29:17.880
So we've enabled asynchronous saving
and our data of type error method

00:29:17.880 --> 00:29:20.790
is going to take a long time to run.

00:29:21.190 --> 00:29:25.100
So now when we make a change to
this document and force a save,

00:29:25.120 --> 00:29:27.840
you notice we're having to wait.

00:29:27.860 --> 00:29:30.900
And boom, wait cursor.

00:29:30.940 --> 00:29:33.620
Not a great experience.

00:29:33.670 --> 00:29:36.390
However,
we can do a lot better than this by

00:29:36.390 --> 00:29:42.660
using unblock user interaction to
make the prepare step a lot shorter.

00:29:43.540 --> 00:29:46.350
In order to call unblock
user interaction,

00:29:46.350 --> 00:29:49.160
we need to make sure that what
we're doing on this background

00:29:49.160 --> 00:29:53.570
thread won't conflict with what's
potentially happening on the main

00:29:53.680 --> 00:29:58.080
thread while the user is continuing
to interact with the document.

00:29:58.790 --> 00:30:02.620
The data that we need to
generate the NSData object is

00:30:02.770 --> 00:30:05.200
this graphics array right here.

00:30:05.400 --> 00:30:11.430
However, this array is not only mutable,
but its contents are mutable as well.

00:30:12.120 --> 00:30:17.560
or we can snapshot this document
state by making a deep copy,

00:30:18.530 --> 00:30:20.160
like so.

00:30:21.910 --> 00:30:25.470
Now that we have this document snapshot,
we know that this array and its contents

00:30:25.530 --> 00:30:29.200
are not going to change even while
the user is continuing to interact

00:30:29.400 --> 00:30:31.400
with the document on the main thread.

00:30:31.610 --> 00:30:38.110
So let's go ahead and use this
array everywhere it was used before.

00:30:42.290 --> 00:30:47.620
So now that we have this snapshot,
we can call self-unblock

00:30:47.960 --> 00:30:51.640
user interaction,
which will unblock the main

00:30:51.760 --> 00:30:55.540
thread immediately and allow
the user to continue interacting

00:30:55.590 --> 00:30:57.680
with the document much sooner.

00:31:00.710 --> 00:31:04.970
So now when I make a change and save,
you see I'm still able to

00:31:04.970 --> 00:31:09.000
interact with the application,
even make edits and so forth.

00:31:09.040 --> 00:31:13.920
And then sometime in the background,
after that five second sleep completes,

00:31:13.920 --> 00:31:17.810
the save is done and the
user didn't even notice it.

00:31:20.630 --> 00:31:23.500
Thank you.

00:31:23.500 --> 00:31:28.280
So let's go ahead and now
add a new feature to Sketch.

00:31:28.280 --> 00:31:29.420
Tony mentioned it.

00:31:29.580 --> 00:31:33.730
A file size field here in the inspector.

00:31:33.920 --> 00:31:35.330
You see I've added.

00:31:35.370 --> 00:31:41.100
And every time a save completes,
we want to update this with the

00:31:41.100 --> 00:31:41.100
current size of the document's file.

00:31:42.360 --> 00:31:49.030
and we want to do this in a way that is,
we don't want to block the main thread

00:31:49.040 --> 00:31:54.040
as we're accessing the file system,
since that is proper behavior.

00:31:54.120 --> 00:31:58.090
And we also want to avoid the
potential deadlock that can happen

00:31:58.100 --> 00:32:00.080
that Tony talked about before.

00:32:02.430 --> 00:32:07.600
So, first thing we need is to
know when saving completes.

00:32:07.600 --> 00:32:12.300
And we can do that by overriding
save to URL of type for save

00:32:12.650 --> 00:32:15.350
operation completion handler.

00:32:16.840 --> 00:32:21.920
And if we call super,
we'll pass in all the same arguments,

00:32:21.920 --> 00:32:25.240
but we have a special
completion handler of our own.

00:32:25.280 --> 00:32:28.530
After we call the normal
completion handler,

00:32:28.720 --> 00:32:31.880
We're going to want to go onto a
different thread so that we can perform

00:32:31.880 --> 00:32:35.100
our file access in a way that won't
block the main thread potentially.

00:32:35.110 --> 00:32:39.920
We can use that using NSOperationQueue,
add operation with block.

00:32:41.590 --> 00:32:44.500
We also need to make sure that we're
the only ones accessing the file at

00:32:44.500 --> 00:32:47.340
this particular time so that the answer,
the file size,

00:32:47.340 --> 00:32:50.600
doesn't change unexpectedly
out from under us.

00:32:50.750 --> 00:32:55.060
So we can use perform asynchronous
file access using block.

00:32:56.110 --> 00:32:58.950
Once we're inside this block,
we have that exclusive

00:32:58.950 --> 00:33:00.800
access to the file.

00:33:01.040 --> 00:33:03.740
So now we're safe to

00:33:04.080 --> 00:33:06.480
access the file system
and get the file size.

00:33:06.590 --> 00:33:10.210
We do that using NSURLs,
get resource value with the

00:33:10.210 --> 00:33:11.910
NSURL total file size key.

00:33:11.920 --> 00:33:14.440
In this case, we just have a single file.

00:33:14.440 --> 00:33:18.390
So we don't need to
do any more than this.

00:33:19.380 --> 00:33:23.120
Now that we have the new file size,
let's update the UI.

00:33:23.200 --> 00:33:25.830
We can't do it on this thread
because we can only update

00:33:25.850 --> 00:33:27.810
the UI from the main thread.

00:33:28.030 --> 00:33:30.490
So how do we get back to the main thread?

00:33:30.620 --> 00:33:34.890
Well, you might think NSOperationQueue
or PerformSelectorOnThread

00:33:34.970 --> 00:33:36.820
or something like that.

00:33:36.860 --> 00:33:39.160
But like Tony mentioned before,
we're still holding on

00:33:39.210 --> 00:33:41.240
to this file access.

00:33:41.260 --> 00:33:44.430
And if something on the main thread
in the meantime has attempted

00:33:44.480 --> 00:33:48.180
to get that file access and is
waiting for us to relinquish it,

00:33:48.230 --> 00:33:51.580
and we just call something
on the main thread,

00:33:51.630 --> 00:33:53.570
we're going to end up with a deadlock.

00:33:53.860 --> 00:33:56.570
In this case,
you may argue that this is simple enough

00:33:56.650 --> 00:34:02.730
that we could just relinquish file access
before calling onto the main thread,

00:34:02.960 --> 00:34:04.850
and you might be right.

00:34:05.240 --> 00:34:06.670
But in some cases,
you're not gonna be able to do that.

00:34:06.750 --> 00:34:10.110
You're gonna need to hold on to exclusive
file access until you're done with all

00:34:10.110 --> 00:34:12.430
your work on the main thread as well.

00:34:12.660 --> 00:34:15.500
So let's work under that assumption now.

00:34:16.090 --> 00:34:20.230
In order to avoid the deadlock,
instead of using Dispatch

00:34:20.230 --> 00:34:24.440
Async or NSOperation Queue
or any of those technologies,

00:34:24.440 --> 00:34:27.620
we're going to use NSDocument's
continue asynchronous work

00:34:27.620 --> 00:34:29.000
on main thread using block.

00:34:29.000 --> 00:34:31.890
Like Tony showed you,
this is able to resolve the

00:34:31.890 --> 00:34:35.430
deadlock and have this block
invoked on the main thread,

00:34:35.430 --> 00:34:41.340
even if something else is waiting
on the main thread for file access.

00:34:42.300 --> 00:34:46.940
Now that we're safely on the main thread,
we can update the UI by

00:34:47.710 --> 00:34:51.470
updating our IVAR and sending
the proper KVO notifications.

00:34:51.500 --> 00:34:56.080
I've set up bindings between
the inspector and the document.

00:34:57.890 --> 00:35:01.450
Last but not least,
we need to make sure that we call

00:35:01.530 --> 00:35:05.410
the file access completion handler,
or else something else that comes in

00:35:05.470 --> 00:35:09.550
in the meantime and tries to get file
access will end up waiting forever.

00:35:09.560 --> 00:35:13.670
So now let me show you this.

00:35:15.840 --> 00:35:20.130
I'll make another change to the document,
force a save,

00:35:20.130 --> 00:35:21.810
and after our five seconds of wait time,

00:35:22.790 --> 00:35:26.380
We see that the file size
is updated here in the UI.

00:35:26.630 --> 00:35:31.270
Remember, we did this in a way that
prevents accessing the file

00:35:31.270 --> 00:35:36.040
system from the main thread,
which could cause unexpected,

00:35:36.210 --> 00:35:38.140
unpredictable blocking.

00:35:38.220 --> 00:35:42.180
And we also prevented,
avoided the deadlock that can happen when

00:35:42.250 --> 00:35:44.970
continuing that work on the main thread.

00:35:46.970 --> 00:35:51.830
So let's move back to the
topic of asynchronous saving.

00:35:51.830 --> 00:35:55.400
And I made some measurements
to show you just how beneficial

00:35:55.440 --> 00:35:58.630
asynchronous saving can be.

00:35:59.290 --> 00:36:03.930
I created on my machine
a 10,000 graphic sketch.

00:36:03.930 --> 00:36:08.730
And with synchronous saving,
this took about .676 seconds.

00:36:08.850 --> 00:36:13.240
Not too long, but, you know,
as you add more graphics,

00:36:13.240 --> 00:36:14.810
this will get even larger.

00:36:15.580 --> 00:36:18.360
Just by turning on asynchronous saving,
I was able to reduce

00:36:18.460 --> 00:36:20.660
this to 0.649 seconds.

00:36:20.700 --> 00:36:23.160
Now, that doesn't seem like
a huge improvement.

00:36:23.230 --> 00:36:26.560
However,
I was on a very fast file system,

00:36:26.560 --> 00:36:27.820
my local hard drive.

00:36:27.900 --> 00:36:31.960
If I was working on something
like a network-mounted volume,

00:36:32.010 --> 00:36:36.200
this could take arbitrarily
longer to complete the save.

00:36:36.230 --> 00:36:39.740
And in the synchronous case,
the user would have to wait

00:36:39.740 --> 00:36:41.350
for the entire duration.

00:36:41.800 --> 00:36:47.460
With the asynchronous case,
since we're just waiting until the

00:36:47.530 --> 00:36:49.180
datative type error method returns,

00:36:49.760 --> 00:36:52.590
The amount of time doesn't change at all.

00:36:52.710 --> 00:36:56.930
So the potential gains from using
asynchronous saving are much greater.

00:36:57.680 --> 00:37:00.190
However,
by snapshotting the document state and

00:37:00.210 --> 00:37:04.220
calling unblock use interaction early,
we're actually able to reduce the

00:37:04.220 --> 00:37:10.520
amount of time that the user had
to wait to a dramatic .011 seconds.

00:37:11.400 --> 00:37:13.400
Thank you.

00:37:13.400 --> 00:37:18.200
So I hope this is a good example
of how valuable it is to not

00:37:18.200 --> 00:37:21.790
only turn on asynchronous saving,
but go the extra mile and snapshot

00:37:22.140 --> 00:37:26.150
your document state so that you can
unblock the user as soon as possible.

00:37:26.280 --> 00:37:31.690
So that when an Auto Save happens
while the user is in the middle

00:37:31.690 --> 00:37:36.420
of interacting with the document,
they don't have to wait suddenly

00:37:36.420 --> 00:37:36.420
for that Auto Save to complete.

00:37:37.260 --> 00:37:38.530
All right,
we're going to go back to Tony now,

00:37:38.530 --> 00:37:40.280
who's going to talk to us
about some more cool features.

00:37:40.280 --> 00:37:41.960
Thanks, Kevin.

00:37:45.210 --> 00:37:46.920
Okay, let's move on to versions.

00:37:46.920 --> 00:37:51.620
So, again, here is the UI that you've
seen many times by now.

00:37:51.620 --> 00:37:57.090
Of course, there's a two-up interface,
one current document, one old document,

00:37:57.090 --> 00:37:59.070
and many old documents behind it.

00:37:59.220 --> 00:38:02.290
We have our done and restore
buttons along the bottom and

00:38:02.290 --> 00:38:04.180
the timeline along the right.

00:38:04.640 --> 00:38:07.720
So, this interface and versions in
general is designed to expand

00:38:07.720 --> 00:38:10.960
the number of options the user
has for reverting their document.

00:38:10.960 --> 00:38:14.260
They can go way further back in
time than was previously possible,

00:38:14.360 --> 00:38:16.740
and they can also do a
kind of selective revert,

00:38:16.740 --> 00:38:19.680
as you've seen in a few demos already,
including Kevin's,

00:38:19.750 --> 00:38:22.950
where you can copy something from
the old document because it's a

00:38:23.280 --> 00:38:26.720
fully live document file and then
paste it into the current document.

00:38:28.800 --> 00:38:30.200
Furthermore,
the versions browser protects

00:38:30.270 --> 00:38:31.830
against unintentional change.

00:38:31.970 --> 00:38:34.580
So if you open up a file
and make some changes to it,

00:38:34.630 --> 00:38:36.780
and then change your mind,
you can always get back to

00:38:36.780 --> 00:38:41.110
the state as you left it by
using the versions browser.

00:38:41.320 --> 00:38:43.630
Under the hood,
version uses compressed storage.

00:38:43.630 --> 00:38:45.960
So if your file changes
by just a few bytes,

00:38:45.960 --> 00:38:49.900
we're not going to store an
entirely new copy of the file.

00:38:50.080 --> 00:38:54.490
And NSDocument will automatically
manage the list of versions for you.

00:38:54.590 --> 00:38:59.060
So by that I mean that NSDocument
may create a version for an hour ago,

00:38:59.320 --> 00:39:03.380
two hours ago, or three hours ago,
but it will also automatically

00:39:03.380 --> 00:39:04.790
purge old versions.

00:39:04.960 --> 00:39:07.400
So a year ago plus an hour, two,
and three hours,

00:39:07.500 --> 00:39:09.970
we probably don't need to
keep all four of those,

00:39:09.980 --> 00:39:11.950
so we can reduce that down to one.

00:39:11.960 --> 00:39:16.490
So that kind of logic NSDocument
does automatically for you.

00:39:17.000 --> 00:39:19.240
And furthermore,
the Versions Browser is the first

00:39:19.240 --> 00:39:22.830
way for your Cocoa application to
be integrated with Time Machine.

00:39:22.940 --> 00:39:25.880
So if we run out of versions that
are stored on the local disk,

00:39:25.920 --> 00:39:28.460
we're going to go ahead and
look on backup disks as well for

00:39:28.460 --> 00:39:30.080
older versions of that document.

00:39:30.150 --> 00:39:32.770
And if we find them,
they're displayed right in

00:39:32.770 --> 00:39:36.090
line in the UI as just another
version of the document.

00:39:38.270 --> 00:39:42.000
So, Versions is on by default when
you enable Auto Saving in place,

00:39:42.020 --> 00:39:44.790
but like Auto Save,
there are a couple things you can do to

00:39:44.790 --> 00:39:47.440
polish the version's user experience.

00:39:47.440 --> 00:39:49.780
The first is to adopt
asynchronous document opening,

00:39:49.780 --> 00:39:51.400
or concurrent document opening.

00:39:51.400 --> 00:39:53.240
This is a feature that
we added in Snow Leopard,

00:39:53.240 --> 00:39:55.800
and I'm not going to go into a
lot of detail about it today,

00:39:55.810 --> 00:39:58.580
but we are opening many
copies of the document,

00:39:58.580 --> 00:40:01.100
so if we can open them at the
same time instead of serially,

00:40:01.100 --> 00:40:04.100
that's a big win for
browsing in Versions.

00:40:04.100 --> 00:40:07.840
You can also show only the relevant
controls in the Versions browser.

00:40:07.840 --> 00:40:10.820
We allow you a mechanism to resize
the windows in the Versions browser

00:40:10.820 --> 00:40:14.150
to their best viewing dimensions,
and we have a new technique

00:40:14.150 --> 00:40:16.830
for allowing what we call
"discardable changes." So first,

00:40:16.940 --> 00:40:19.140
let's talk about showing
a different interface.

00:40:19.150 --> 00:40:21.300
So as you can tell,
the Versions UI is about

00:40:21.300 --> 00:40:24.520
providing a focused interface,
and that means that we want to

00:40:24.640 --> 00:40:27.640
allow the user to see as much
of their document as possible,

00:40:27.690 --> 00:40:30.890
not necessarily edit as much
of their document as possible.

00:40:30.920 --> 00:40:33.960
So you can participate in this
and improve the experience of

00:40:33.960 --> 00:40:37.480
your app in Versions by hiding
things like toolbars or inspectors.

00:40:37.480 --> 00:40:40.260
You can also add a new interface
that may not be fully relevant to the

00:40:40.280 --> 00:40:42.080
experience of looking at the content.

00:40:42.080 --> 00:40:44.480
You can do that in a few ways.

00:40:44.480 --> 00:40:45.830
Here's one.

00:40:45.840 --> 00:40:47.800
Listen for these notifications
that are posted when the Versions

00:40:47.840 --> 00:40:48.770
browser enters and exits.

00:40:48.780 --> 00:40:52.620
We have NSWindow will enter a
Versions browser notification

00:40:52.620 --> 00:40:54.270
and a similar did exit.

00:40:55.660 --> 00:40:58.400
You can also find out if
certain kinds of controls should

00:40:58.400 --> 00:41:01.350
be just flat out disabled.

00:41:01.360 --> 00:41:03.360
If you're looking at the
document on the right here,

00:41:03.360 --> 00:41:05.520
it is in what we call viewing mode.

00:41:05.520 --> 00:41:07.800
Viewing mode documents are
not allowed to be edited.

00:41:07.800 --> 00:41:10.110
So if you have something
which is purely for editing,

00:41:10.110 --> 00:41:12.700
you can find out if your document
is in that mode and just go

00:41:12.700 --> 00:41:14.990
ahead and disable it right away.

00:41:17.010 --> 00:41:20.040
To participate in resizing the
windows for that interface,

00:41:20.050 --> 00:41:21.980
you can use this
NSWindow delegate method.

00:41:22.190 --> 00:41:25.160
Window will resize for version
browser with Mac's preferred size,

00:41:25.220 --> 00:41:26.600
Mac's allowed size.

00:41:26.600 --> 00:41:29.760
So, you know,
versions has this two-up user interface.

00:41:29.820 --> 00:41:32.880
And to show two documents at a time,
we would show two documents

00:41:32.880 --> 00:41:34.030
at the Mac's preferred size.

00:41:34.080 --> 00:41:39.550
And we also have a Mac's allowed size,
which is the maximum size until we,

00:41:39.560 --> 00:41:41.930
let me say that a different way.

00:41:41.940 --> 00:41:44.730
The screen size is not
the maximum allowed size.

00:41:44.740 --> 00:41:46.560
We need to leave room
for the user interface.

00:41:46.900 --> 00:41:50.640
So, the Mac's allowed size is the maximum
size of one NSDocument window.

00:41:50.640 --> 00:41:53.850
And if your document is larger
than the preferred size and

00:41:53.850 --> 00:41:57.030
less than the allowed size,
we scale it in the user interface so

00:41:57.030 --> 00:41:58.860
that it fits in the two-up interface.

00:41:58.860 --> 00:42:01.240
And then when the user begins
to interact with that window,

00:42:01.240 --> 00:42:04.340
we scale it back up again so
they can see it at full size.

00:42:04.340 --> 00:42:06.860
So, this method lets you participate
in deciding what the size

00:42:06.860 --> 00:42:08.050
of your window should be.

00:42:11.480 --> 00:42:15.030
New in Lion, we also have a way to allow
changes to certain kinds of

00:42:15.070 --> 00:42:16.800
changes to viewing mode documents.

00:42:16.930 --> 00:42:19.380
The reason you need it is because
changes to viewing mode documents

00:42:19.470 --> 00:42:22.400
are automatically undone if
the change is discardable.

00:42:22.410 --> 00:42:25.400
The reason is we don't want to allow
the user to attempt to edit the past.

00:42:25.400 --> 00:42:28.550
That's not something that's possible.

00:42:28.990 --> 00:42:33.040
If you need to allow the change,
then the change must be discardable.

00:42:33.100 --> 00:42:35.240
Discardable changes are
normally auto saved,

00:42:35.310 --> 00:42:39.450
but on locked or viewing mode documents,
they may be discarded without warning.

00:42:39.610 --> 00:42:44.000
So another example, in Keynote,
the currently selected slide,

00:42:44.060 --> 00:42:47.190
as well as the hidden or shown
state of a group of slides,

00:42:47.240 --> 00:42:51.300
is something that is both undoable
and preserved in the document file.

00:42:51.520 --> 00:42:54.240
Now clearly, in viewing mode,
you would need to allow

00:42:54.240 --> 00:42:56.160
Keynote to choose,
the user to choose

00:42:56.160 --> 00:42:57.510
different slides to view.

00:42:57.780 --> 00:42:59.750
We can't just automatically undo that.

00:42:59.890 --> 00:43:03.000
So that action of changing the
slide or expanding groups of

00:43:03.050 --> 00:43:07.350
slides is something that is a great
candidate to be a discardable change.

00:43:07.430 --> 00:43:09.360
And a bonus of that is that
if the document is locked,

00:43:09.360 --> 00:43:12.390
then the user doesn't have to unlock
the document just to change the slide.

00:43:12.460 --> 00:43:13.980
We allow that too.

00:43:14.370 --> 00:43:17.950
Another example in a similar kind
of thing is the currently displayed

00:43:18.080 --> 00:43:20.090
chart in the Numbers application.

00:43:22.010 --> 00:43:25.000
To use discardable changes,
in the same place that you would set

00:43:25.000 --> 00:43:29.740
the group name for your undo group,
like undo typing, change slide,

00:43:29.740 --> 00:43:33.540
or move shape in Sketch,
you can now set action is discardable,

00:43:33.550 --> 00:43:36.240
yes, and NSDocument takes care
of all the rest for you.

00:43:36.280 --> 00:43:38.980
If it's not an undoable change,
you can use NSDocument's

00:43:38.980 --> 00:43:40.720
update change count mechanism.

00:43:40.720 --> 00:43:43.920
You just bitwise or the change
you normally would have done,

00:43:43.920 --> 00:43:46.980
usually NSChange done,
with NSChangeDiscardable.

00:43:50.190 --> 00:43:51.820
So one more note about versions.

00:43:51.840 --> 00:43:53.760
If you don't want to use
the versions browser,

00:43:53.770 --> 00:43:57.080
which is integrated into NSDocument,
we have foundation level access

00:43:57.220 --> 00:43:59.540
to the list of versions as well.

00:43:59.590 --> 00:44:02.110
And that's via a class
called NSFileVersion.

00:44:02.220 --> 00:44:04.780
When you use NSFileVersion,
it's important to remember that you

00:44:04.780 --> 00:44:09.220
as the caller are responsible for file
coordination and version management.

00:44:09.260 --> 00:44:11.700
Let's take a quick look
at some of the API.

00:44:11.780 --> 00:44:14.460
To get an array of NSFileVersion
instances for a file,

00:44:14.510 --> 00:44:16.740
you call other versions of item at URL.

00:44:16.910 --> 00:44:19.540
This is in contrast to
the current version.

00:44:19.580 --> 00:44:22.140
You can add a new version of a
file to versions using this method,

00:44:22.140 --> 00:44:25.030
add version of item at
URL with contents of URL,

00:44:25.080 --> 00:44:27.090
options, error.

00:44:27.880 --> 00:44:31.500
You can revert to an old version of a
file using an NSFileVersion instance by

00:44:31.510 --> 00:44:33.500
using replace item at URL options error.

00:44:33.500 --> 00:44:37.540
And NSFileVersion instances have plenty
of properties about the document,

00:44:37.540 --> 00:44:40.880
including the name and modification date,
which can, of course, change over time.

00:44:43.190 --> 00:44:47.540
So to show us another demo of how you
can use versions in your application,

00:44:47.540 --> 00:44:49.680
I'd like to invite back Kevin.

00:44:52.770 --> 00:44:53.540
Thank you.

00:44:53.540 --> 00:44:55.300
So, Sketch again.

00:44:55.390 --> 00:44:59.460
I showed you earlier how just by
turning on Auto Saving in place,

00:44:59.460 --> 00:45:02.700
we gain basic version support for Sketch.

00:45:03.110 --> 00:45:06.890
However, there's a couple of things we
can do to improve the experience.

00:45:07.580 --> 00:45:09.840
First of all,
notice that when I go into versions,

00:45:09.900 --> 00:45:13.540
the tool inspector gets pushed
off the side of the screen.

00:45:13.590 --> 00:45:18.370
This provides a clutter-free environment
for the user to browse versions.

00:45:18.590 --> 00:45:21.270
However, currently,
AppKit doesn't bring that inspector

00:45:21.380 --> 00:45:23.620
back when we come out of versions.

00:45:23.840 --> 00:45:26.080
Now,
this may change in the future in AppKit,

00:45:26.100 --> 00:45:28.930
but in the meantime,
we want to do the right thing.

00:45:30.120 --> 00:45:32.470
Another thing is the window size.

00:45:32.750 --> 00:45:37.630
If I happen to resize the window to
something like this for whatever reason,

00:45:37.630 --> 00:45:42.840
and the versions doesn't know that
the window size isn't optimal.

00:45:42.840 --> 00:45:46.510
And so we end up with the
canvas partially clipped and

00:45:46.630 --> 00:45:48.880
a bunch of extra wasted space.

00:45:48.880 --> 00:45:52.400
So let's solve these two problems
using the APIs Tony talked about.

00:45:52.400 --> 00:45:55.570
Here we are in the
SKT window controller class,

00:45:55.700 --> 00:45:58.180
which is also our Windows delegate.

00:45:59.220 --> 00:46:02.570
And we can use window delegate APIs.

00:46:03.010 --> 00:46:07.410
to know when Version Browser enters,
will enter, or did exit.

00:46:07.580 --> 00:46:12.140
In the window will enter
Version Browser delegate method,

00:46:12.190 --> 00:46:15.760
we'll check to see if the
palette is currently visible.

00:46:15.960 --> 00:46:21.260
and when we exit the version browser,
if it was visible, then we show it again.

00:46:21.360 --> 00:46:22.870
Pretty simple.

00:46:25.120 --> 00:46:29.180
For the window sizing problem,
we implement the delegate method

00:46:29.180 --> 00:46:32.740
window will resize for version
browser with Mac's preferred size,

00:46:32.740 --> 00:46:34.880
Mac's allowed size.

00:46:35.390 --> 00:46:39.210
and the size that we return from this
method is the size that versions will

00:46:39.210 --> 00:46:41.840
resize the window to before entering.

00:46:41.920 --> 00:46:45.510
And here we use NSView,
NSScrollView and NSWindow

00:46:45.510 --> 00:46:50.790
APIs to determine the proper
optimal size for our document.

00:46:50.880 --> 00:46:53.280
So let me show you how these work.

00:46:55.470 --> 00:47:02.200
And we see the window resize so that
it fits to the content very nicely.

00:47:02.200 --> 00:47:04.910
And when we exit versions,
the tool inspector is brought

00:47:04.910 --> 00:47:06.400
back as we would expect.

00:47:06.400 --> 00:47:09.570
So these are just some very
simple ways to use these APIs.

00:47:09.670 --> 00:47:13.670
There is a lot of potential here for
your own applications to improve the

00:47:13.670 --> 00:47:19.050
user experience in versions such as
doing things like hiding user interface

00:47:19.130 --> 00:47:23.380
elements that aren't needed like
tool bars or sidebars and so forth.

00:47:23.400 --> 00:47:25.320
So that's all for versions.

00:47:25.470 --> 00:47:29.120
Now we'll hear about iCloud from Tony.

00:47:30.800 --> 00:47:33.280
Kevin, thanks.

00:47:33.620 --> 00:47:34.800
Thank you.

00:47:34.890 --> 00:47:37.510
So on to iCloud.

00:47:37.830 --> 00:47:42.940
and his document is integrated with the
new Cloud Storage feature in many ways.

00:47:42.970 --> 00:47:46.100
NSDocument will use the versions
browser to resolve conflicts,

00:47:46.100 --> 00:47:47.360
as I mentioned earlier.

00:47:47.460 --> 00:47:51.430
And NSDocument's adoption of file
coordination is going to update

00:47:51.430 --> 00:47:55.100
the contents of your document
on demand when new things are

00:47:55.100 --> 00:47:57.000
synced down from the Cloud.

00:47:57.030 --> 00:48:00.380
We're going to briefly cover the
API to move a document to the Cloud and

00:48:00.510 --> 00:48:02.880
finding documents in the Cloud.

00:48:03.690 --> 00:48:06.590
So to move a document to the cloud,
the APA is not on NSDocument

00:48:06.600 --> 00:48:08.310
but on NSFileManager.

00:48:08.430 --> 00:48:11.780
There you need to first
find your container.

00:48:11.780 --> 00:48:15.040
Each application has their
own Ubiquiti container.

00:48:15.080 --> 00:48:18.270
And here it is,
URL for Ubiquiti container identifier.

00:48:18.350 --> 00:48:20.280
And once you have it,
you can make a document ubiquitous

00:48:20.470 --> 00:48:24.520
simply by calling setUbiquitous
itemAtURL destinationURL.

00:48:24.540 --> 00:48:27.220
The itemAtURL parameter will
be the document you're moving,

00:48:27.260 --> 00:48:32.260
and the destinationURL should be
someplace in your Ubiquiti container.

00:48:33.180 --> 00:48:36.010
Next, to find iCloud documents,
the API is on NSMetadataQuery,

00:48:36.080 --> 00:48:38.890
which is our class for integrating
with Spotlight as well.

00:48:38.900 --> 00:48:42.830
So there we have a new search scope,
NSMetadataQuery Ubiquitous

00:48:42.930 --> 00:48:43.580
Document Scope.

00:48:43.820 --> 00:48:47.240
And also you will find some
API and NSURL that's helpful,

00:48:47.240 --> 00:48:49.890
including finding out if an
item is ubiquitous or not,

00:48:49.920 --> 00:48:53.020
looking at if it's downloaded,
if it's downloading,

00:48:53.020 --> 00:48:56.520
the percent that it's downloaded,
and similar keys for uploading.

00:48:56.520 --> 00:49:00.480
So to show you another example
of how that works in Sketch,

00:49:00.480 --> 00:49:02.170
I'd like to invite up
one last time Kevin.

00:49:07.420 --> 00:49:08.620
Thank you again.

00:49:08.840 --> 00:49:12.710
So here is another version of Sketch,
which I've modified to

00:49:12.720 --> 00:49:15.070
provide cloud integration.

00:49:15.560 --> 00:49:19.320
Here in the File menu,
you see there's two new menu items,

00:49:19.320 --> 00:49:22.450
Open Cloud Document and Move to Cloud.

00:49:22.500 --> 00:49:26.890
So let's go ahead and move the
currently open document to the cloud.

00:49:27.590 --> 00:49:34.340
and I'll make another change here that
we will be able to see on the cloud.

00:49:37.190 --> 00:49:40.180
and David . Welcome to WWDC.

00:49:40.180 --> 00:49:43.960
So now let me switch to another machine.

00:49:44.060 --> 00:49:44.510
Okay.

00:49:44.520 --> 00:49:44.980
Not really.

00:49:44.980 --> 00:49:49.160
But we're really
exercising the APIs here.

00:49:49.160 --> 00:49:52.120
And we have the same version
of Sketch running here.

00:49:52.120 --> 00:49:57.390
So we'll go to File, Open Cloud Document,
and we can open the document that

00:49:57.530 --> 00:49:59.880
we just saved on the other machine.

00:50:00.640 --> 00:50:08.400
and let's be daring here and even
make a change on this machine at 2011.

00:50:09.220 --> 00:50:10.610
I'll switch back.

00:50:11.850 --> 00:50:16.620
And there we see the change is synced
to the original machine as well.

00:50:20.030 --> 00:50:26.240
So let's see these APIs that
Tony talked about in action.

00:50:26.290 --> 00:50:30.150
In our document subclass,
we override validate menu item

00:50:30.350 --> 00:50:36.860
because we want to change what the
move to cloud file menu item says,

00:50:36.940 --> 00:50:40.810
depending on whether or not the item
is actually in the cloud already.

00:50:41.140 --> 00:50:45.560
We can detect this using
isUbiquitousItemAtURL on NSFileManager.

00:50:45.600 --> 00:50:51.900
And if it is ubiquitous,
then we change the title to Remove from

00:50:51.900 --> 00:50:53.980
Cloud instead of Move to Cloud.

00:50:54.220 --> 00:50:56.820
And we also set some state on the
menu item so that when it's selected,

00:50:56.820 --> 00:51:00.490
we know what operation
we're actually performing.

00:51:01.310 --> 00:51:04.960
This is implemented in
move to or from cloud.

00:51:05.080 --> 00:51:13.660
The key method here is right here.

00:51:13.670 --> 00:51:13.670
And as file manager,
set ubiquitous item URL,

00:51:13.670 --> 00:51:13.670
destination URL error, as Tony mentioned.

00:51:13.860 --> 00:51:17.320
When we're making an item ubiquitous,
or moving it to the cloud,

00:51:17.360 --> 00:51:22.140
then we build the destination
URL by using File Manager's URL for

00:51:22.140 --> 00:51:25.900
Ubiquity Container Identifier,
passing in the identifier that

00:51:26.070 --> 00:51:30.420
belongs to our applications,
in this case, com.apple.sketch.

00:51:30.470 --> 00:51:34.070
And documents generally live
in a document subdirectory

00:51:34.080 --> 00:51:37.860
inside of the container,
so we append that here.

00:51:37.890 --> 00:51:41.380
After making sure that
the directory exists,

00:51:41.420 --> 00:51:44.450
we append to that URL the file's name.

00:51:45.780 --> 00:51:48.740
Down here,
before we call setUbiquitousItem at URL,

00:51:48.740 --> 00:51:51.460
you notice we have some
file coordinator code.

00:51:51.460 --> 00:51:57.150
And in the future,
you won't have to do a lot of this code,

00:51:57.160 --> 00:51:59.260
but for now,
it's required to make this work.

00:51:59.330 --> 00:52:01.400
So I won't cover it in great depth.

00:52:01.400 --> 00:52:05.730
But the key thing here
is this method again.

00:52:08.530 --> 00:52:16.160
The menu item for finding ubiquitous
documents in the cloud is here

00:52:16.160 --> 00:52:19.490
in our skt-appdelicate class.

00:52:19.690 --> 00:52:22.100
When the application finishes launching,
we're going to call

00:52:22.260 --> 00:52:27.750
startUpdatingCloudDocumentMenu,
which creates an NSMetadata query using

00:52:27.750 --> 00:52:30.890
the new ubiquitous document scope.

00:52:32.590 --> 00:52:35.370
This causes NS Metadata again
to search the cloud instead of

00:52:35.380 --> 00:52:38.630
your local file system for files.

00:52:38.800 --> 00:52:45.100
[Transcript missing]

00:52:46.300 --> 00:52:50.320
Then we set up observers for
when the results array of

00:52:50.320 --> 00:52:52.400
the metadata query changes.

00:52:52.400 --> 00:52:57.310
And when we get those notifications,
we will update the Cloud Documents

00:52:57.370 --> 00:53:01.380
menu by adding a menu item for
each document that we find,

00:53:01.420 --> 00:53:05.480
which in turn, when it's selected,
will open that document.

00:53:05.480 --> 00:53:07.960
And that's really all there is to it.

00:53:08.030 --> 00:53:11.700
These are the most important
APIs that I've shown you on

00:53:11.700 --> 00:53:15.760
NSFileManager and NSMetadataQuery,
but there are the others that

00:53:15.760 --> 00:53:19.820
Tony showed you as well for seeing
progress of uploads and downloads

00:53:19.880 --> 00:53:26.920
and even purging the document on the
local hard drive without removing

00:53:26.920 --> 00:53:28.480
it from the cloud and so forth.

00:53:28.520 --> 00:53:31.710
So now let's go back to Tony,
who's going to wrap up for us.

00:53:37.900 --> 00:53:39.270
Okay, thanks, Kevin.

00:53:39.300 --> 00:53:39.930
That's pretty cool, right?

00:53:39.940 --> 00:53:41.940
I mean, it wasn't that difficult,
just a few lines of code,

00:53:41.940 --> 00:53:44.810
and we got something
synced across the cloud.

00:53:46.080 --> 00:53:49.760
So let's do a quick recap of
what we talked about today.

00:53:49.800 --> 00:53:52.640
We really want to help you make
your document-based application

00:53:52.680 --> 00:53:54.560
a first-class Lion citizen.

00:53:54.610 --> 00:53:55.880
That means adopting Auto Save.

00:53:55.920 --> 00:53:59.200
And again, here's the one method you need
to take away from this talk.

00:53:59.260 --> 00:54:01.620
Auto Save's in place, return yes.

00:54:01.810 --> 00:54:04.400
Try it out, test your app,
and come talk to us in the labs

00:54:04.400 --> 00:54:06.160
and tell us how it went for you.

00:54:06.190 --> 00:54:08.720
After it's enabled,
you can polish Auto Save by saving

00:54:08.720 --> 00:54:11.800
fast and adopting asynchronous saving.

00:54:11.850 --> 00:54:14.730
We also talked about versions,
and remember, it's on by default when

00:54:14.730 --> 00:54:17.130
you enable Auto Saving,
but you can polish it too by

00:54:17.130 --> 00:54:21.300
streamlining the interface in browsing
mode and allowing discardable changes.

00:54:21.460 --> 00:54:24.330
And then finally, we looked at iCloud,
and we talked about how to

00:54:24.330 --> 00:54:26.530
move documents to the cloud,
how to find documents in the

00:54:26.600 --> 00:54:29.680
cloud using NSMetadataQuery,
and then we looked at how you could

00:54:29.780 --> 00:54:32.910
find document properties using NSURL.

00:54:33.660 --> 00:54:35.360
So for more information,
there's of course Bill Dundee,

00:54:35.360 --> 00:54:36.910
our App Frameworks Evangelist.

00:54:37.030 --> 00:54:39.840
The documentation and developer
forums are great resources.

00:54:39.920 --> 00:54:41.700
And if you've ever
looked at NSDocument.h,

00:54:41.760 --> 00:54:43.240
you know that it's a lot of comments.

00:54:43.310 --> 00:54:44.430
We measured.

00:54:44.510 --> 00:54:47.550
There's 87% comments in that file.

00:54:48.120 --> 00:54:50.940
They're designed to tell you everything
about every method in there and

00:54:50.980 --> 00:54:51.980
how it works with everything else.

00:54:52.080 --> 00:54:55.690
So the documentation, the header files,
our release notes are all great

00:54:55.690 --> 00:54:57.970
resources to find out more
information about all the great

00:54:57.970 --> 00:54:59.390
new features we've added in Lion.

00:54:59.400 --> 00:55:01.480
We have a couple of related sessions.

00:55:01.480 --> 00:55:03.600
The first one I already mentioned,
taking advantage of file

00:55:03.600 --> 00:55:05.010
coordination in this room right now.

00:55:05.060 --> 00:55:08.500
Then also resume and
automatic termination in Lion.

00:55:08.500 --> 00:55:10.700
That's Marina, Thursday at 9 a.m.

00:55:10.700 --> 00:55:13.260
Those features go with these
like peanut butter and jelly.

00:55:13.260 --> 00:55:16.680
So they all work great together
or taste great together in Lion.

00:55:17.320 --> 00:55:20.400
So with that, I want to thank you so much
for coming to this talk.

00:55:20.490 --> 00:55:22.990
And I'm really looking forward to
seeing what you guys do with Auto Save,

00:55:22.990 --> 00:55:24.020
Versions, and iCloud.
WEBVTT

00:00:10.200 --> 00:00:13.740
Welcome to Advances in
OpenGL ES for iOS 5 session.

00:00:13.890 --> 00:00:16.710
My name is Gohkan Avkarogullari and
Eric Sunalp will join me on the stage

00:00:16.830 --> 00:00:18.200
to talk about some new cool features.

00:00:18.240 --> 00:00:23.230
Every year we release a new version
of iOS and with that new release we

00:00:23.310 --> 00:00:25.340
basically make new features available.

00:00:25.340 --> 00:00:28.740
Two years ago we made
OpenGL ES available on iOS platform.

00:00:29.120 --> 00:00:32.860
Last year we did it with MSAA, Discard,
DevTextures, and such.

00:00:32.860 --> 00:00:36.890
But sometimes releasing new
hardware makes things possible

00:00:36.890 --> 00:00:39.360
and this year we released iPad 2.

00:00:39.360 --> 00:00:42.550
And with iPad 2 you get a
lot more graphics horsepower,

00:00:42.550 --> 00:00:47.100
you get a lot of CPU horsepower,
and you get a lot of memory bandwidth.

00:00:47.100 --> 00:00:55.020
Which enables you to do new things or
do all things in a new and improved way.

00:00:55.150 --> 00:00:58.330
I'm going to talk about an application
on App Store that took advantage

00:00:58.330 --> 00:01:00.500
of iPad 2's processing power.

00:01:00.520 --> 00:01:03.670
And they basically changed their
pipeline to do something specific on

00:01:03.670 --> 00:01:10.650
iPad 2 that makes it look much nicer
relative to iPad 1 and other devices.

00:01:10.890 --> 00:01:13.560
That's Real Racing 2 HD from Fireman.

00:01:13.710 --> 00:01:17.750
And I'm going to walk over a few
examples of what they did on iPad 2.

00:01:18.020 --> 00:01:20.480
The dashboard in this scene,
as you can see,

00:01:20.480 --> 00:01:23.650
is almost one-third of the screen space.

00:01:23.650 --> 00:01:26.020
And it's very visible to the player.

00:01:26.230 --> 00:01:28.420
And what they did on the dashboard,
they basically used normal

00:01:28.420 --> 00:01:30.140
maps and per-pixel lighting.

00:01:30.280 --> 00:01:35.300
That takes advantage of the compute power
of iPad 2 and memory bandwidth as well.

00:01:35.790 --> 00:01:38.790
And on the asphalt,
they basically use multiple textures,

00:01:38.930 --> 00:01:42.180
light maps, gloss maps, specular maps.

00:01:42.180 --> 00:01:45.500
And basically,
they took advantage of iPad 2's

00:01:45.560 --> 00:01:47.850
very large memory bandwidth.

00:01:48.200 --> 00:01:50.770
They implemented dynamic shadows
on the dashboard depending on

00:01:50.770 --> 00:01:56.480
where the sun is and the car is.

00:01:57.040 --> 00:02:15.770
MSAA.

00:02:15.770 --> 00:02:15.770
MSAA, if you can't change anything
on iPad 2 but only one thing,

00:02:15.770 --> 00:02:15.770
you probably should enable
MSAA and see how it works.

00:02:15.770 --> 00:02:15.770
It should probably just work fine and you
get instant image quality enhancement.

00:02:15.770 --> 00:02:15.770
But you should do more.

00:02:15.770 --> 00:02:15.770
If you can do only one, do MSAA.

00:02:16.670 --> 00:02:18.700
And finally,
with iPad 2's processing power,

00:02:18.750 --> 00:02:22.490
they were able to push a lot
more polygons into the device.

00:02:22.520 --> 00:02:27.150
They have much higher poly models
they're using in the games.

00:02:27.440 --> 00:02:30.200
OK,
so that was what the hardware gives you.

00:02:30.260 --> 00:02:32.760
But we also added some software features.

00:02:32.860 --> 00:02:34.920
I'm going to talk about-- we're
going to talk about GL Kit,

00:02:35.140 --> 00:02:38.060
a new framework that we
are introducing with iOS 5,

00:02:38.070 --> 00:02:41.650
and the new features that we
enabled through OpenGL extensions,

00:02:41.650 --> 00:02:43.570
OpenGL ES extensions.

00:02:43.720 --> 00:02:45.890
So let's start with GL Kit.

00:02:46.360 --> 00:02:50.000
Before I start with GL Kit,
I want to talk about using

00:02:50.000 --> 00:02:52.180
OpenGL ES 2 in your games.

00:02:52.290 --> 00:02:54.510
And I want to talk about
an example again here.

00:02:54.640 --> 00:02:58.250
Brad Larson has an application called
Molecles App that has been on the

00:02:58.250 --> 00:03:03.260
App Store for some time and was using
ES 1.1 as its rendering backend.

00:03:03.360 --> 00:03:06.740
And this was the kind of rendering
he was getting using ES 1.1.

00:03:06.810 --> 00:03:09.280
And when he actually
set out to improve it,

00:03:09.280 --> 00:03:13.910
he decided to use OpenGL ES 2.0 and
the power that the programmability

00:03:14.010 --> 00:03:16.300
of OpenGL ES 2.0 gives it.

00:03:16.480 --> 00:03:18.970
And the end result,
as you can see on the right side,

00:03:19.050 --> 00:03:23.220
is basically a much better looking model,
in this case a molecule visualization.

00:03:23.310 --> 00:03:25.580
So visualization is very
important for this application.

00:03:25.770 --> 00:03:28.160
And he uses techniques of
multiple passes and true

00:03:28.530 --> 00:03:32.770
programmability of ambient occlusion,
per pixel lighting, great specular,

00:03:32.810 --> 00:03:33.820
as you can see.

00:03:33.820 --> 00:03:36.770
So these are the kind of things
you can do with OpenGL ES 2.0.

00:03:36.770 --> 00:03:40.010
And when we set out to do GL Kit,
that was one of our goals,

00:03:40.010 --> 00:03:42.170
to make these kind of things possible.

00:03:42.300 --> 00:03:44.440
So we had two primary goals.

00:03:44.580 --> 00:03:47.580
The first one is basically
making life easier for you,

00:03:47.610 --> 00:03:48.700
the developers.

00:03:48.760 --> 00:03:51.620
And the best way to do it is
basically find problems that are

00:03:51.620 --> 00:03:54.920
common to every one of you and
then provide solutions for those.

00:03:55.030 --> 00:03:59.460
The second goal we had was to
basically encourage a unique look

00:03:59.460 --> 00:04:01.910
for each graphics application.

00:04:02.120 --> 00:04:06.170
The ES 1.1 fixed function pipeline
is basically very powerful,

00:04:06.270 --> 00:04:09.580
but it's limited in the ways
of how it can do rendering.

00:04:09.680 --> 00:04:12.810
It does BlinFong shading, for example,
and textures and such.

00:04:12.880 --> 00:04:14.460
You can differentiate through textures.

00:04:14.500 --> 00:04:16.890
But it kind of limits
you what you can do.

00:04:17.250 --> 00:04:23.260
So the idea is that to allow
you to basically use shaders,

00:04:23.340 --> 00:04:27.670
but we also understand that you
have a lot of investment in ES 1.1.

00:04:28.080 --> 00:04:31.380
and we wanted to help you with
porting your ES1 applications

00:04:31.390 --> 00:04:32.910
in 2.0 and make it easier.

00:04:33.000 --> 00:04:34.990
So these are two goals of the GL Kit.

00:04:35.210 --> 00:04:38.950
Basically making life easier through
common solutions and allowing you to

00:04:38.950 --> 00:04:42.240
easily port your games from ES1 to 2.0.

00:04:42.370 --> 00:04:44.500
And it has four sub-parts.

00:04:44.590 --> 00:04:46.830
I'm going to talk first
about the texture loader,

00:04:46.890 --> 00:04:47.760
just briefly.

00:04:47.870 --> 00:04:50.590
So basically the idea of texture
loader is you give us a reference

00:04:50.700 --> 00:04:53.660
whether it's on the network,
on the file system, and you get an

00:04:53.660 --> 00:04:55.440
OpenGL ES texture object back.

00:04:55.520 --> 00:04:59.670
So you don't need to deal with image IO,
libping, libpng, and such.

00:05:00.610 --> 00:05:05.160
The second subpart is the
view and view controller.

00:05:05.270 --> 00:05:08.400
So we looked at our template and
there's hundreds of lines of code to

00:05:08.420 --> 00:05:12.900
set up FBOs for multisending and not,
and set up the display links and such.

00:05:13.040 --> 00:05:16.880
And we thought that we can make it much
simpler by giving you this UIKit style

00:05:16.970 --> 00:05:22.000
view and view controller that also works
really well with the UIKit hierarchy.

00:05:22.330 --> 00:05:27.640
And the third part is basically
a 3D graphics math library.

00:05:27.780 --> 00:05:33.080
OpenGL ES 2.0 lacks the transform API,
the matrix stack API of ES 1.1.

00:05:33.220 --> 00:05:36.040
And also we've seen that a lot
of people implementing vector

00:05:36.040 --> 00:05:37.640
and math libraries themselves.

00:05:37.770 --> 00:05:40.760
And basically the
GLK library gives you that,

00:05:40.760 --> 00:05:44.840
all the functionality of
the OpenGL ES 1.1 that you

00:05:44.840 --> 00:05:49.010
can reuse on OpenGL ES 2.0,
and also adds vector and

00:05:49.010 --> 00:05:50.990
matrix stacks to that.

00:05:51.760 --> 00:05:53.600
And finally, the GLK effects.

00:05:53.600 --> 00:05:56.790
Basic GLK effects are fixed
function pipeline features

00:05:57.230 --> 00:05:59.440
implemented in ES 2.0 context.

00:05:59.440 --> 00:06:03.960
I'm going to have Eric come over
here and talk about some of these.

00:06:03.960 --> 00:06:06.080
Thank you.

00:06:06.090 --> 00:06:07.910
Thanks, Gohkhan.

00:06:08.290 --> 00:06:08.860
All right.

00:06:08.860 --> 00:06:09.800
Hi, everyone.

00:06:09.930 --> 00:06:13.090
So we're going to start
with the GLK Texture Loader.

00:06:13.210 --> 00:06:15.320
So like Gohkan said,
we want to make texture

00:06:15.320 --> 00:06:16.690
loading as simple as possible.

00:06:16.900 --> 00:06:20.770
You know, you give us a file reference,
we decode the image, we load it,

00:06:20.840 --> 00:06:23.900
create a GL texture out of it,
and there's pretty much just, you know,

00:06:23.900 --> 00:06:27.630
one API call to get this thing loaded,
so you don't have to worry about

00:06:27.770 --> 00:06:28.660
setting all your OpenGL states.

00:06:28.750 --> 00:06:30.800
We're going to make this
as simple as possible.

00:06:30.800 --> 00:06:33.600
And like he said, there's a number of
common formats we support,

00:06:33.640 --> 00:06:36.290
PNG, JPEG, TIFF.

00:06:36.810 --> 00:06:42.000
Pretty much almost every
format that Image.io supports.

00:06:42.160 --> 00:06:44.890
So, yeah,
no longer do you have to load a CG image,

00:06:45.040 --> 00:06:48.500
decode that,
blit it into a CG image context,

00:06:48.530 --> 00:06:50.290
get that data back.

00:06:50.330 --> 00:06:54.300
Pretty much just one
API call now to do that.

00:06:54.320 --> 00:06:56.500
One of the biggest problems
developers have had is dealing

00:06:56.500 --> 00:06:59.500
with non-premultiplied data.

00:06:59.540 --> 00:07:02.860
Now when you, you know,
using our library,

00:07:02.880 --> 00:07:05.900
you can guarantee the image
won't be premultiplied,

00:07:05.900 --> 00:07:08.460
which is a huge thing.

00:07:08.490 --> 00:07:11.100
So we have texture 2D support,
QMap support,

00:07:11.100 --> 00:07:14.940
and a number of convenient loading
options when you're loading your images.

00:07:15.000 --> 00:07:17.970
If you want to force premultiplication,
that's an option you can set.

00:07:17.980 --> 00:07:19.530
We'll Y-flip the image
for you if you want,

00:07:19.680 --> 00:07:23.970
put it in a native GL orientation,
and you can turn mid-map

00:07:23.970 --> 00:07:25.910
generation on or off.

00:07:26.830 --> 00:07:28.980
So basic usage, really simple.

00:07:29.250 --> 00:07:32.040
You set your Eagle context current.

00:07:32.040 --> 00:07:35.830
You make our single call
to the class loading,

00:07:36.000 --> 00:07:38.380
to the class,
one of the variant loading methods.

00:07:38.420 --> 00:07:41.560
And you get back this object,
this GLK texture info object,

00:07:41.670 --> 00:07:44.900
which has all the pertinent information
you need to do your rendering.

00:07:44.900 --> 00:07:48.340
So you get the most important
texture name that you can bind with,

00:07:48.340 --> 00:07:52.280
the width and height of the image,
alpha if it was pre-multiplied,

00:07:52.280 --> 00:07:55.000
or if there was no alpha
pre-multiplied or not.

00:07:55.240 --> 00:07:59.300
The original origin of the image
and if we map it for you or not.

00:08:00.950 --> 00:08:03.240
So let's run through
a little code example.

00:08:03.300 --> 00:08:05.240
So as you can see,
just a couple lines of code here.

00:08:05.240 --> 00:08:09.780
We're going to set the context current,
load a path, you know,

00:08:09.810 --> 00:08:12.540
pretty canonical way
of loading your image.

00:08:12.540 --> 00:08:17.240
Here I'm just setting one
option entering the dictionary,

00:08:17.240 --> 00:08:19.520
which is generate_mid_maps,
probably pretty common.

00:08:19.520 --> 00:08:24.240
And we're going to make our single class
method call to load the 2D texture.

00:08:24.240 --> 00:08:26.460
And you can see-- so basically,
if that call fails,

00:08:26.460 --> 00:08:27.280
you may want to do some error checking.

00:08:27.280 --> 00:08:28.520
That will return nil.

00:08:28.520 --> 00:08:30.990
Otherwise,
you can check-- so if it returns nil,

00:08:31.040 --> 00:08:33.340
basically, you have error there, too,
to check to see if you want

00:08:33.340 --> 00:08:34.680
to see what went wrong.

00:08:34.680 --> 00:08:36.580
Then we assume you do some work,
and then there you go.

00:08:36.580 --> 00:08:37.990
There's a texture name to bind with.

00:08:38.040 --> 00:08:41.660
And that's pretty much all
it takes to load a texture.

00:08:42.380 --> 00:08:43.820
So in addition to a
synchronous usage case,

00:08:43.900 --> 00:08:46.430
we have an asynchronous usage case.

00:08:46.430 --> 00:08:50.540
Take advantage of iPad
2 multi-core devices.

00:08:50.540 --> 00:08:53.890
Very similar usage pattern,
but in this case, instead of using one

00:08:53.890 --> 00:08:55.460
of the class methods,
you're going to actually allocate

00:08:56.010 --> 00:09:00.740
a GLK texture letter object and
give us your contact share group.

00:09:00.740 --> 00:09:03.940
And in this case,
you're going to call one of the

00:09:03.940 --> 00:09:08.600
instance methods and provide us
with a GCDQ and a completion block.

00:09:08.770 --> 00:09:11.360
So the GCDQ is basically
where that completion block

00:09:11.360 --> 00:09:12.710
is going to be called on.

00:09:12.800 --> 00:09:15.780
And through that completion block,
you'll get back a GLK texture,

00:09:15.780 --> 00:09:18.470
just like you did with the
synchronous case and an error

00:09:18.720 --> 00:09:20.470
if there was one loading.

00:09:20.520 --> 00:09:24.720
So the code example for that case,
same thing, load the path.

00:09:25.020 --> 00:09:27.980
And here we're going to get the
share group for your context.

00:09:27.980 --> 00:09:30.740
Give that to us when you create
the GLK texture loader object.

00:09:30.750 --> 00:09:32.740
And there it is.

00:09:32.740 --> 00:09:33.740
Just make a single call.

00:09:33.950 --> 00:09:36.680
Give us the path and whatever
your completion block handler is.

00:09:36.740 --> 00:09:39.830
And here I just kind of, in this example,
kind of doing a simple wrapping on,

00:09:39.910 --> 00:09:42.200
you know, just informing my app that,
hey, you know,

00:09:42.200 --> 00:09:45.740
this thing is completed and here's the
texture info that I'm going to need.

00:09:45.970 --> 00:09:48.210
So really simple.

00:09:48.560 --> 00:09:52.180
So the next thing we're really proud of
is the GLK View and GLK View Controller.

00:09:52.200 --> 00:09:56.100
Like Gohkan said, this thing was,
you know, you saw it on our template,

00:09:56.130 --> 00:09:57.300
probably a pain to deal with.

00:09:57.400 --> 00:09:58.260
Hundreds of lines of code.

00:09:58.260 --> 00:10:00.660
I don't think MSA was there by default.

00:10:00.660 --> 00:10:04.160
You know, something you had to code for,
among other things.

00:10:04.180 --> 00:10:07.620
So it's pretty much everything you need
to get OpenGL ES into view and on screen.

00:10:07.620 --> 00:10:12.000
Again, like Gohkan said,
it's a part of UIKit,

00:10:12.010 --> 00:10:17.370
so it's not part of UIKit,
but it's a UIView subclass.

00:10:17.460 --> 00:10:19.890
So it fits into the
UIKit model really well.

00:10:20.410 --> 00:10:23.620
Responds to set needs
display if you want it to.

00:10:23.620 --> 00:10:26.460
So it behaves, you know,
pretty much like a UIView in

00:10:26.600 --> 00:10:28.360
all of its associated methods.

00:10:28.460 --> 00:10:30.460
Except ours is a little bit different.

00:10:30.570 --> 00:10:34.140
You can set a delegate or you can
subclass the class for drawing.

00:10:34.140 --> 00:10:39.220
And here's a number of things
it automatically handles,

00:10:39.220 --> 00:10:43.540
which was normally done,
partially done in the template for you,

00:10:43.540 --> 00:10:45.370
but now done automatically.

00:10:45.810 --> 00:10:47.690
Basically creation and
deletion for color,

00:10:47.690 --> 00:10:49.850
depth, stencil, turning on MSA or not.

00:10:50.000 --> 00:10:51.820
And that's performance win.

00:10:51.820 --> 00:10:55.100
We'll do the discard
for you automatically.

00:10:55.100 --> 00:10:59.390
And then pretty much, you know,
every time you draw, before you draw,

00:10:59.390 --> 00:11:03.130
you're always going to set your
context and your FBO current and

00:11:03.130 --> 00:11:05.340
then present that drawing afterwards.

00:11:05.360 --> 00:11:06.300
So we also do that for you.

00:11:06.390 --> 00:11:08.820
So this is kind of even more
similar to UIView in that,

00:11:08.900 --> 00:11:10.390
you know,
if you're going to subclass this thing,

00:11:10.390 --> 00:11:14.100
you implement draw rect,
setting the context,

00:11:14.120 --> 00:11:17.110
setting the FBO current,
and then presenting afterwards,

00:11:17.140 --> 00:11:18.540
just like, you know,
something you don't have

00:11:18.610 --> 00:11:19.340
to think about in UIView.

00:11:19.340 --> 00:11:21.340
And here it's all done for you.

00:11:21.340 --> 00:11:24.620
And then additionally we have a
snapshot support that returns a UI image

00:11:24.690 --> 00:11:26.290
for you if you want to use that.

00:11:26.340 --> 00:11:27.240
All right.

00:11:27.330 --> 00:11:29.630
So the next thing is
the GLK view controller,

00:11:29.800 --> 00:11:32.420
subclass of UI view controller,
so it fits into the view

00:11:32.460 --> 00:11:34.060
controller model nicely.

00:11:34.060 --> 00:11:37.220
And the main thing here is that it's
coupled very tightly with the GLK view

00:11:37.220 --> 00:11:39.150
and it handles the redrawing of the view.

00:11:39.250 --> 00:11:43.060
So kind of the main value you'd
probably be setting most often,

00:11:43.060 --> 00:11:46.040
unless you want the default,
is the preferred frames per second.

00:11:46.120 --> 00:11:49.280
And the preferred frames
per second specifies,

00:11:49.280 --> 00:11:53.520
you know, maybe 30 or 60,
a value that we'll try to get as

00:11:53.520 --> 00:11:57.770
close to as possible on the device or
the display that your view currently

00:11:58.260 --> 00:12:04.020
resides without going over the display's
refresh rate or your preferred value.

00:12:04.020 --> 00:12:07.660
And then additionally you pause
and resume any time you like,

00:12:07.660 --> 00:12:11.020
and automatically when your
app goes in the background,

00:12:11.020 --> 00:12:13.060
we'll pause for you,
and when it comes in the foreground,

00:12:13.060 --> 00:12:14.050
we'll resume for you.

00:12:14.220 --> 00:12:16.130
And that can be disabled
if you want to do,

00:12:16.190 --> 00:12:18.050
you know, your own custom work.

00:12:18.150 --> 00:12:21.790
And then also to kind of help
separate your scene logic

00:12:21.790 --> 00:12:24.850
or maybe your physics logic,
we provide an update method

00:12:24.860 --> 00:12:29.560
that stays in sync with draw,
so you can kind of keep

00:12:29.740 --> 00:12:33.970
those two things separated.

00:12:34.160 --> 00:12:37.690
And then we provide a number of
statistics that you can query for,

00:12:37.750 --> 00:12:40.010
such as number of frames displayed.

00:12:40.020 --> 00:12:42.020
All right, so here's a code example.

00:12:42.020 --> 00:12:45.950
This is the simplest case of
just using the delegate example.

00:12:46.060 --> 00:12:49.020
Here I've got a view controller that
I assume I loaded from XIB file.

00:12:49.020 --> 00:12:52.020
And here I'm going to query
for the GLK view out of that.

00:12:52.020 --> 00:12:54.260
If one wasn't set up in the XIB file,
this will be automatically

00:12:54.260 --> 00:12:57.020
created for you,
just like all other view controllers.

00:12:57.070 --> 00:12:59.390
So you get back the GLK view,
and here I have this

00:12:59.630 --> 00:13:03.110
third class called game,
which I'm assuming does all my, you know,

00:13:03.110 --> 00:13:03.940
my scenes.

00:13:03.940 --> 00:13:05.980
My rendering.

00:13:05.980 --> 00:13:09.260
And I just need to basically assign
it to GLK view as a delegate and

00:13:09.260 --> 00:13:10.870
give the GLK view my context.

00:13:10.980 --> 00:13:14.270
And then basically here I have
a number of drawable formats

00:13:14.270 --> 00:13:15.720
I'm setting as an example.

00:13:16.030 --> 00:13:19.260
RGB 888 is just basically default,
so if you didn't want depth and

00:13:19.430 --> 00:13:21.420
you didn't want multi-sample,
you really wouldn't have

00:13:21.420 --> 00:13:21.980
to set any of these things.

00:13:21.980 --> 00:13:23.920
You would just have to set
your delegate in context.

00:13:23.920 --> 00:13:26.990
Next I set the same delegate
for my game because I want to

00:13:26.990 --> 00:13:28.980
make use of the update method.

00:13:28.980 --> 00:13:31.640
And I set a preferred frames per second,
which is 30,

00:13:31.640 --> 00:13:33.260
which again is also the default.

00:13:34.200 --> 00:13:36.560
Okay, so here,
this would be like the game class.

00:13:36.670 --> 00:13:38.570
Pretty much all I would have
to implement in that game class

00:13:38.620 --> 00:13:43.430
would be GLK view controller
update and GLK view draw and rect.

00:13:43.500 --> 00:13:47.710
And next we'll look at the subclass
and actually really quickly.

00:13:48.030 --> 00:13:50.160
Yeah, so basically when you get,
you know, draw and rect,

00:13:50.200 --> 00:13:51.750
and it's actually true
for the subclass case,

00:13:51.890 --> 00:13:57.610
the rect will be in points, not pixels,
so you can use your content

00:13:57.610 --> 00:13:59.600
scale factor to figure that out.

00:14:00.540 --> 00:14:03.200
So the subclassing case,
this common method you're used to,

00:14:03.280 --> 00:14:06.290
drawRect,
just subclass that and basically even

00:14:06.290 --> 00:14:09.100
if you set this thing as a delegate,
you would get this one called

00:14:09.580 --> 00:14:12.750
and then for the view controller
update is what you'd implement.

00:14:13.690 --> 00:14:15.600
All right, next is GLK Math.

00:14:15.660 --> 00:14:19.190
So this is a 3D graphics math library.

00:14:19.230 --> 00:14:22.850
We have over 175 functions that
you don't have to implement.

00:14:23.030 --> 00:14:26.170
We have a number of common types, 4x4,
3x3 matrix,

00:14:26.170 --> 00:14:30.560
4 and 3 and 2 component vector types,
and even a quaternion type.

00:14:30.630 --> 00:14:35.100
And the idea is you don't
have to write this for ES2,

00:14:35.110 --> 00:14:37.090
but we also wanted to,
when we were looking at what would you

00:14:37.090 --> 00:14:41.100
guys have to do to port from ES1 to 2.0,
you know, you have a lot of this list

00:14:41.100 --> 00:14:44.000
code that already deals with
ES1-1 matrix stacks and such.

00:14:44.040 --> 00:14:48.140
So we also additionally added a matrix
stack functionality so that your port

00:14:48.320 --> 00:14:53.900
would almost be one-to-one with all
the equivalent ES1-1 math functions.

00:14:53.900 --> 00:14:55.970
And we try to make it as
high performance as possible,

00:14:56.100 --> 00:14:58.000
so, you know,
functions are in line where possible,

00:14:58.000 --> 00:15:02.800
and we make use of all the
great hardware in our devices.

00:15:03.030 --> 00:15:08.200
So here's kind of to impress upon you
the number of functions that we have.

00:15:08.260 --> 00:15:09.500
Should really help out.

00:15:09.520 --> 00:15:11.510
It's kind of hard to see.

00:15:11.790 --> 00:15:15.160
So here's our one example.

00:15:15.170 --> 00:15:18.750
This would be basically maybe
some simple 1-1 code you'd have,

00:15:18.920 --> 00:15:20.760
and this is what it would
look like in GL Kit.

00:15:20.780 --> 00:15:22.820
These are core foundation types.

00:15:22.910 --> 00:15:25.370
I'm creating a projection
stack and a model view stack.

00:15:25.440 --> 00:15:30.580
And I'm basically actually
using a GLK matrix 4 type

00:15:30.750 --> 00:15:35.330
to create a frustum matrix,
and then I'm loading that onto

00:15:35.330 --> 00:15:37.070
my projection matrix stack.

00:15:37.500 --> 00:15:39.400
And then I'm going to,
based on my model view stack,

00:15:39.400 --> 00:15:43.570
load an identity and do a number
of equivalent ES 1.1 transforms,

00:15:43.600 --> 00:15:44.680
translate, rotate, and scale.

00:15:44.680 --> 00:15:47.220
And yeah, pretty simple.

00:15:47.220 --> 00:15:51.680
And that's it for the math,
and I'll handle it over to Gohkan

00:15:51.680 --> 00:15:53.130
now to talk about GLK effects.

00:15:53.200 --> 00:15:53.780
Thanks.

00:15:53.780 --> 00:15:55.100
Thank you.

00:15:59.740 --> 00:16:00.890
Thanks, Eric.

00:16:01.020 --> 00:16:05.250
So GLK effects, as I said before,
is basically re-implementation of

00:16:05.340 --> 00:16:08.630
fixed function pipeline features
within the ES 2.0 context.

00:16:08.630 --> 00:16:12.100
So you get great visual
effects with minimal effort.

00:16:12.100 --> 00:16:13.890
You don't have to write
shaders for those.

00:16:13.900 --> 00:16:16.860
You don't have to basically create
probably hundreds of different

00:16:16.860 --> 00:16:18.550
shaders depending on your state.

00:16:19.620 --> 00:16:22.620
It's a great way to go from 1.1 to 2.0.

00:16:22.620 --> 00:16:29.160
And the main goal of it is interoperable
with custom OpenGL ES 2.0 shaders.

00:16:29.170 --> 00:16:33.070
So you can basically do part of
your rendering with GLK effects.

00:16:33.160 --> 00:16:36.900
And if you have something that's
specific to your application that

00:16:36.930 --> 00:16:39.880
uses a special kind of shader,
like a particle effect

00:16:39.980 --> 00:16:43.170
or GPU skin object,
you can do still ES 2.0 shaders

00:16:43.170 --> 00:16:45.490
and basically mix and match them.

00:16:45.500 --> 00:16:49.120
So we come up with three effect classes,
named effect classes.

00:16:49.240 --> 00:16:52.450
We have base effect,
reflection map effect, and skybox effect.

00:16:52.490 --> 00:16:54.590
And I'll talk about each
one of them in a second.

00:16:54.600 --> 00:16:59.480
So the general architecture
and usage of it is very simple.

00:16:59.480 --> 00:17:01.720
You need to configure your vertex state.

00:17:01.720 --> 00:17:06.410
This is basically standard
OpenGL ES 2.0 vertex state setup.

00:17:06.420 --> 00:17:11.350
The only thing in here is that you use a
predefined GLK effects vertex attribute

00:17:11.350 --> 00:17:15.740
name so that we can basically find
out which vertices you specified and

00:17:15.850 --> 00:17:18.570
what they correspond to in our shaders.

00:17:18.860 --> 00:17:22.100
And then you all look in at
your GLK effect class instance,

00:17:22.100 --> 00:17:24.030
either the base effect,
reflection map effect.

00:17:24.220 --> 00:17:26.500
And then configure the effect parameters.

00:17:26.550 --> 00:17:29.670
You can basically enable
things or set some parameters.

00:17:29.740 --> 00:17:32.530
And then once you're done
with configuring your effect,

00:17:32.530 --> 00:17:34.780
you basically call prepare to draw.

00:17:34.840 --> 00:17:36.800
In this case,
what we're doing is we're not

00:17:36.800 --> 00:17:39.700
generating internal shaders
every time you change a state.

00:17:39.770 --> 00:17:41.730
We basically want all
your state to be set up,

00:17:41.840 --> 00:17:43.230
all your finalization to be done.

00:17:43.340 --> 00:17:45.430
And at that point,
we'll set the GL state.

00:17:45.600 --> 00:17:48.070
We'll generate or reuse
the necessary shaders.

00:17:48.560 --> 00:17:51.120
And then we're ready to
go for your rendering.

00:17:51.240 --> 00:17:54.420
And you would bind your
VAO as the best practice.

00:17:54.420 --> 00:17:55.610
You should be using VAOs.

00:17:55.720 --> 00:17:59.710
And then you'll make a draw call for
either draw arrays and draw elements.

00:18:01.270 --> 00:18:01.960
So this is how it works.

00:18:01.960 --> 00:18:03.200
It's very simple.

00:18:03.200 --> 00:18:04.450
Let's talk about the base effect.

00:18:04.630 --> 00:18:08.600
Base effect basically captures
most of the ES 1.1 functionality.

00:18:08.640 --> 00:18:13.340
It does things like lighting,
multiple lights, material properties you

00:18:13.340 --> 00:18:16.440
can set for each light,
and light properties you can set,

00:18:16.440 --> 00:18:21.330
multi-texturing, and fog, constant color,
the transformations that

00:18:21.330 --> 00:18:22.820
you can do on your objects.

00:18:22.900 --> 00:18:25.350
The things it doesn't cover
is basically texture combiners

00:18:25.350 --> 00:18:28.010
and clip planes from ES 1.1.

00:18:28.510 --> 00:18:29.360
And here's an example.

00:18:29.570 --> 00:18:32.270
This part is basically how
you set up your vertex state.

00:18:32.390 --> 00:18:37.470
It's no different than any
other ES2 vertex state setup.

00:18:37.570 --> 00:18:41.630
In this case, you're basically generating
a VAO and then your VBOs and

00:18:41.830 --> 00:18:43.500
putting data into your VBOs.

00:18:43.610 --> 00:18:47.820
The only point in here is basically when
you pass a vertex attribute pointer,

00:18:47.950 --> 00:18:50.600
basically use names that
are specific to GLK.

00:18:50.600 --> 00:18:53.500
In this case,
GLK vertex attribute position and

00:18:53.500 --> 00:18:58.090
GLK vertex attribute normal when you
set your position and normal raise.

00:18:58.790 --> 00:19:03.110
So the second part is basically
allocating and initializing your effect.

00:19:03.270 --> 00:19:05.720
So you get a base effect in here,
and then you start

00:19:05.840 --> 00:19:06.760
setting your parameters.

00:19:06.840 --> 00:19:09.710
In this example, actually,
we went a little further

00:19:09.800 --> 00:19:10.830
than what ES 1.1 did.

00:19:10.880 --> 00:19:13.340
We support also the per-pixel lighting.

00:19:13.380 --> 00:19:17.950
And so you basically set up the lighting
time to per-pixel and enable a light.

00:19:18.160 --> 00:19:21.480
So you enable those things
based on -- basically,

00:19:21.480 --> 00:19:24.330
we try to keep as close
as possible to ES 1.1.

00:19:24.450 --> 00:19:28.430
So all our light parameters,
all our material parameters

00:19:28.430 --> 00:19:30.000
are very similar to ES 1.1.

00:19:30.000 --> 00:19:32.460
And so are the default
values for those parameters.

00:19:32.490 --> 00:19:34.900
So if you don't set anything,
you get basically the default

00:19:34.900 --> 00:19:36.670
ES 1.1 state kind of parameters.

00:19:36.780 --> 00:19:38.620
But if you're going to change it,
this is the place to change.

00:19:38.650 --> 00:19:40.640
You set your material properties.

00:19:40.750 --> 00:19:42.180
Here in this case, we enabled the light.

00:19:42.250 --> 00:19:43.720
We set a diffuse color.

00:19:43.760 --> 00:19:45.020
We set a shininess.

00:19:45.100 --> 00:19:46.960
And then we're ready to draw.

00:19:47.050 --> 00:19:49.420
So we basically let the effect
note that we're ready to draw,

00:19:49.420 --> 00:19:50.980
and we call the prepare to draw API.

00:19:50.980 --> 00:19:52.920
At this point, all the state is settled.

00:19:52.940 --> 00:19:54.640
All the necessary shaders are generated.

00:19:54.710 --> 00:19:57.760
We try to generate basically
the optimum shader.

00:19:57.760 --> 00:20:00.360
So if the things are not enabled,
there's no shader code

00:20:00.380 --> 00:20:02.500
to run non-enabled stuff.

00:20:02.500 --> 00:20:05.200
And you bind your
VAO and make a draw call,

00:20:05.200 --> 00:20:09.140
and you get something drawn
like on the right side here,

00:20:09.140 --> 00:20:10.840
per-pixel light.

00:20:10.940 --> 00:20:13.000
Skybox effect is a little different.

00:20:13.000 --> 00:20:16.380
It provides a scene skybox
for your application.

00:20:16.380 --> 00:20:20.680
If you can think of it as a
360-degree background image.

00:20:20.680 --> 00:20:22.280
And it has very few parameters.

00:20:22.280 --> 00:20:26.280
You can center it, change the center of
your skybox or resize it.

00:20:26.710 --> 00:20:29.010
Since it's a skybox,
there's no actual vertex

00:20:29.010 --> 00:20:30.600
array state initialization.

00:20:30.640 --> 00:20:32.860
There's no requirement for that.

00:20:32.880 --> 00:20:34.540
Here's a code example for that.

00:20:34.570 --> 00:20:37.200
We allocate and initialize our skybox.

00:20:37.240 --> 00:20:40.480
Basically, we need to give it a -- our
skybox is going to be a cube map.

00:20:40.660 --> 00:20:42.380
Here we're basically
assigning a cube map,

00:20:42.380 --> 00:20:45.920
and we're actually using texture
loader to load the cube map.

00:20:45.980 --> 00:20:48.020
So that's just one line of code.

00:20:48.040 --> 00:20:49.620
And then we set the prepare to draw.

00:20:49.690 --> 00:20:51.380
So our skybox is ready to be rendered.

00:20:51.380 --> 00:20:52.710
And then we can call the draw API.

00:20:52.750 --> 00:20:56.160
The second difference is basically you
can see the skybox has its own draw API,

00:20:56.200 --> 00:20:58.120
because we didn't set the vertex state.

00:20:58.240 --> 00:21:01.190
So you have to call the
draw API on the skybox.

00:21:02.180 --> 00:21:05.100
Reflection map effect
builds on the base effect.

00:21:05.100 --> 00:21:08.120
So we added reflections
to the base effect.

00:21:08.120 --> 00:21:09.910
So everything that you
had for base effect,

00:21:10.010 --> 00:21:14.280
like lighting, materials, and textures,
multi-texturing,

00:21:14.300 --> 00:21:15.360
are still available to you.

00:21:15.360 --> 00:21:17.260
It's a basic subclass of the base effect.

00:21:17.410 --> 00:21:19.700
You can set them as you did before.

00:21:20.700 --> 00:21:23.770
And on top of that,
it adds reflection mapping,

00:21:23.770 --> 00:21:26.460
a cube map type environmental mapping.

00:21:26.520 --> 00:21:31.350
And we basically use the specification
of the desktop specification OpenGL 2.1.

00:21:31.370 --> 00:21:34.700
So we try to stay as close
as possible to that one.

00:21:34.950 --> 00:21:38.060
And we use a cube map
for reflection samples.

00:21:38.510 --> 00:21:42.640
So initialization of vertex array object
is no different than the base effect.

00:21:42.640 --> 00:21:44.800
So in this example,
we're not actually covering it.

00:21:44.840 --> 00:21:46.720
And we create our effect.

00:21:46.720 --> 00:21:49.050
So the difference here, for example,
from the base effect,

00:21:49.050 --> 00:21:50.820
when we set the parameters,
you can set the same

00:21:50.820 --> 00:21:52.540
parameters over here,
but you need to assign a

00:21:52.600 --> 00:21:54.150
kubemap texture for reflections.

00:21:55.120 --> 00:21:57.720
Now,
when you have a reflection on an object,

00:21:57.720 --> 00:22:00.860
it is independent of the
position of the viewer.

00:22:00.860 --> 00:22:04.400
So if you pass only the model view
matrix to the reflection effect,

00:22:04.400 --> 00:22:07.190
it won't be able to figure out
how to create the reflections.

00:22:07.200 --> 00:22:09.790
If you think about like a
shiny car next to another car,

00:22:09.790 --> 00:22:12.880
it doesn't really matter where
you're looking at the shiny car.

00:22:12.980 --> 00:22:15.840
The reflections are always
at the same place on the car.

00:22:15.840 --> 00:22:19.370
So therefore, and when you construct
your model view matrix,

00:22:19.370 --> 00:22:23.610
you need to basically decompose it
into the model part and the view part.

00:22:24.080 --> 00:22:27.070
And for the base effect part,
you basically pass the model view

00:22:27.160 --> 00:22:31.550
part entirely to the base effect
implementation of the reflection map.

00:22:31.600 --> 00:22:35.460
But you also pass the transpose of
the model matrix to the reflection

00:22:35.640 --> 00:22:40.180
map effect so that it can actually
calculate the reflections correctly.

00:22:41.620 --> 00:22:43.910
As a base effect,
all you need to do is once you set

00:22:44.040 --> 00:22:47.740
the parameters and pass the cube map
and give the transfer of the model

00:22:47.740 --> 00:22:50.640
view matrix to the reflection map,
you set the prepare to draw.

00:22:50.640 --> 00:22:51.680
Everything is ready to go.

00:22:51.680 --> 00:22:55.670
And you set bind your VAO and then
call the drawways or draw elements.

00:22:55.750 --> 00:22:58.370
And you get basically
your rendering of them.

00:22:59.120 --> 00:23:01.120
So we have a technical demo for this.

00:23:01.120 --> 00:23:05.160
I say technical because there's not much
artistic stuff in here as you can see.

00:23:05.280 --> 00:23:08.020
So we have a background image,
background color really,

00:23:08.140 --> 00:23:10.900
and a sphere that doesn't look like a
sphere because it's not lighted here.

00:23:10.900 --> 00:23:16.670
So we got this skybox from Emil Persson,
also known as Humus.

00:23:16.740 --> 00:23:22.770
So you can see it's 360-degree background
image if you can think of it that way.

00:23:23.040 --> 00:23:27.060
And this is basically the skybox is
loaded by the texture loader in here

00:23:27.060 --> 00:23:30.200
and it's rendered by the skybox effect.

00:23:30.220 --> 00:23:32.200
So on our object in the front,
it's a sphere,

00:23:32.200 --> 00:23:33.660
we can basically texture it.

00:23:33.720 --> 00:23:36.480
And you can see that it is a
sphere when it has a texture,

00:23:36.480 --> 00:23:37.700
it just shows it more.

00:23:37.700 --> 00:23:40.060
And you can do per vertex lighting.

00:23:40.060 --> 00:23:41.470
This is basically a base effect.

00:23:41.520 --> 00:23:46.520
All you do is set the light position and
light parameter and then just say enable

00:23:46.530 --> 00:23:48.500
that and then prepare to draw and draw.

00:23:49.930 --> 00:23:53.980
Last thing,
or we can use a reflection map

00:23:54.000 --> 00:23:56.240
effect and add reflections to it.

00:23:56.270 --> 00:24:00.160
So you can see that it is reflecting
the skybox that is around the sphere.

00:24:00.160 --> 00:24:04.670
And you can see basically
it's just two lines of code.

00:24:04.680 --> 00:24:09.390
It really is setting up the same
skybox cube map as the cube map

00:24:09.410 --> 00:24:11.840
for the reflection map effect.

00:24:11.840 --> 00:24:15.710
And then setting the transpose of
the model matrix on the reflection

00:24:15.730 --> 00:24:17.760
map and then just go from there.

00:24:17.780 --> 00:24:19.500
And one final thing.

00:24:19.700 --> 00:24:23.840
Both the reflection map and the base
effect support per pixel lighting.

00:24:23.840 --> 00:24:25.840
So we can enable per pixel lighting.

00:24:25.840 --> 00:24:29.570
And it's very hard to see in this one
because there's not strong speculars,

00:24:29.700 --> 00:24:31.400
but you would get per pixel lighting.

00:24:31.400 --> 00:24:36.000
Okay, so that's for our demo.

00:24:37.300 --> 00:26:20.500
[Transcript missing]

00:26:21.040 --> 00:26:22.490
Three categories.

00:26:22.510 --> 00:26:26.490
The first one is we basically got a lot
of requests in terms of enhancing the

00:26:26.490 --> 00:26:28.960
OpenGL ES and AV foundation interaction.

00:26:29.090 --> 00:26:33.790
So we tried to solve that problem,
the issues with that use model.

00:26:34.130 --> 00:26:37.180
The second set of extensions are
basically to help you enhance image

00:26:37.280 --> 00:26:39.700
quality on your graphics applications.

00:26:39.730 --> 00:26:43.940
And the third category is the
extensions and the new features that

00:26:43.940 --> 00:26:48.450
help you improve the performance
of your graphics application.

00:26:49.160 --> 00:26:53.140
So let's start with enhancing the
OpenGL AV foundation interaction.

00:26:53.220 --> 00:26:57.850
So what we set out to do was
basically create a direct path from

00:26:58.070 --> 00:27:03.150
video subset of the system to the
graphics and the opposite as well,

00:27:03.150 --> 00:27:05.520
from graphics to the video.

00:27:05.520 --> 00:27:08.120
And what I mean by direct path is
basically it's better understood

00:27:08.140 --> 00:27:10.520
when it's contrasted with iOS 4.

00:27:10.520 --> 00:27:15.350
In iOS 4, if you were to get your video
captured data into OpenGL,

00:27:15.350 --> 00:27:18.960
and in this example,
I'm assuming that you are trying to

00:27:18.960 --> 00:27:24.220
convert them to ARGB and get into OpenGL,
you will have your capture session with

00:27:24.220 --> 00:27:27.040
this AV foundation created buffer pools.

00:27:27.040 --> 00:27:28.460
You will capture your data into that.

00:27:28.910 --> 00:27:32.420
You will be using image buffers
and then you will be transformed

00:27:32.440 --> 00:27:34.680
from YUV space to ARGB space.

00:27:34.680 --> 00:27:37.970
And then to pass your data,
you will call GL tech image and we would

00:27:37.970 --> 00:27:43.980
copy your data at that point from your
storage to our storage in the OpenGL API.

00:27:43.980 --> 00:27:50.740
And basically you would have this extra
copy happening on the OpenGL side.

00:27:50.740 --> 00:27:54.080
So this is basically -- the
same applies for YUV data.

00:27:54.080 --> 00:27:56.390
You could basically use two
different planes and create a

00:27:56.390 --> 00:27:59.220
texture from each one of them,
but at the end of the day,

00:27:59.220 --> 00:28:02.050
both of those textures
have to be copied over.

00:28:02.300 --> 00:30:39.700
[Transcript missing]

00:30:40.640 --> 00:30:43.340
So I have a small demo
about this as well.

00:30:43.400 --> 00:30:46.940
So this is basically the texture
cache of the GL text image.

00:30:47.260 --> 00:30:50.890
So when I move the camera,
it's a little choppy because

00:30:50.900 --> 00:30:51.760
it's not running yet.

00:30:51.760 --> 00:30:54.200
It's trying to run at 60,
but it's running at 48 because

00:30:54.200 --> 00:30:55.980
there's a lot of copies going on.

00:30:56.000 --> 00:31:02.760
And when we turn the texture cache on,
it's much smoother and it says 60.

00:31:02.780 --> 00:31:08.620
And basically,
this is video data texture put

00:31:08.620 --> 00:31:10.160
on a highly tessellated quad.

00:31:10.260 --> 00:31:13.260
And so basically,
there's a ripple effect that's

00:31:13.300 --> 00:31:16.710
changing the vertex positions
to create the ripple effect.

00:31:16.770 --> 00:31:21.280
So I'm sure you guys are going to use
it for something much more interesting,

00:31:21.280 --> 00:31:26.980
like things like augmented reality maybe,
or doing barcode scanning,

00:31:27.010 --> 00:31:34.190
or getting your OpenGL images out
and encoding on a video encoder.

00:31:34.700 --> 00:31:40.480
Okay, that was a Averil
Foundation OpenGL ES interaction.

00:31:45.370 --> 00:31:48.480
So the second category we identified
that we wanted to work on was

00:31:48.480 --> 00:31:50.580
enhancing the image quality.

00:31:50.880 --> 00:31:58.770
And we have basically implemented
the infrastructure for high

00:31:58.770 --> 00:32:01.290
dynamic range rendering.

00:32:01.300 --> 00:34:08.200
[Transcript missing]

00:34:08.920 --> 00:34:10.330
I have a demo for this one.

00:34:10.540 --> 00:34:15.900
So here we have basically a
skybox that is high dynamic range,

00:34:15.900 --> 00:34:18.460
a 60-bit float skybox.

00:34:18.500 --> 00:34:24.170
And so the first effect I talked
about was how you go from indoors

00:34:24.170 --> 00:34:27.680
to outdoors and come back,
and then when you go out,

00:34:27.680 --> 00:34:31.770
the exposure changes significantly,
and your eyes have to adjust to it.

00:34:31.900 --> 00:34:35.650
So here's an example of that one.

00:34:36.340 --> 00:34:38.740
As you can see,
this is possible to implement

00:34:38.740 --> 00:34:41.320
with high dynamic range targets.

00:34:41.670 --> 00:34:43.460
Going back.

00:34:45.060 --> 00:34:48.840
I hope it's visible to you as much
as it's visible to me over here.

00:34:49.010 --> 00:34:54.270
So the other thing we talked about was

00:34:54.540 --> 00:34:56.330
Basically, let me change the exposure.

00:34:56.340 --> 00:35:01.920
So you can see you can actually set
your target exposure point to anywhere.

00:35:02.170 --> 00:35:06.620
and you would get whatever part of
the exposure you want to capture.

00:35:06.620 --> 00:35:11.850
And this image in the back is
actually a very high exposure range.

00:35:11.920 --> 00:35:14.230
It's, I think,
nine different exposure levels

00:35:14.350 --> 00:35:16.310
that the image was taken with.

00:35:16.350 --> 00:35:17.620
Okay.

00:35:17.650 --> 00:35:19.230
The other thing I talked
about is basically you can

00:35:19.260 --> 00:35:21.800
change the bloom in the scene.

00:35:21.800 --> 00:35:25.770
You can see if I turn off the bloom,
the light doesn't really interact

00:35:25.900 --> 00:35:30.660
with our semi-transparent bunny,
which reflects and reflects light,

00:35:30.710 --> 00:35:32.110
but there's no bloom around it.

00:35:32.340 --> 00:35:36.580
In real life,
when you have an object that is in

00:35:36.620 --> 00:35:39.710
strong light behind that object,
you have this light

00:35:39.750 --> 00:35:42.710
coming around that object,
surrounding that object.

00:35:42.760 --> 00:35:45.500
So you can capture those kind of
effects with high dynamic range.

00:35:45.500 --> 00:35:47.720
You can go crazy with it if you want.

00:35:47.780 --> 00:35:48.540
You can see.

00:35:48.540 --> 00:35:50.940
Let's put it into some scene point.

00:35:50.970 --> 00:35:52.500
And I talked about tone mapping.

00:35:52.640 --> 00:35:55.680
So tone mapping takes a 16-bit
value and maps it into an

00:35:55.680 --> 00:35:57.960
8-bit value in a smart way.

00:35:57.980 --> 00:36:02.270
And another smart way of doing it is
basically just mapping and clamping it,

00:36:02.340 --> 00:36:06.020
just mapping the lower
dynamic range and clamping it.

00:36:06.040 --> 00:36:07.900
And if I turn off the
tone mapping in here,

00:36:07.900 --> 00:36:11.230
you can see our tone mapping
is just basically clamping

00:36:11.260 --> 00:36:13.370
the values to 0 to 1 range.

00:36:13.570 --> 00:36:17.340
So the overexposed parts are not
even -- you cannot tell the detail.

00:36:17.590 --> 00:36:20.450
But if you go to
underexposed parts -- sorry,

00:36:20.500 --> 00:36:24.640
if you go to the darker part,
without tone mapping,

00:36:24.670 --> 00:36:27.000
just this part shows up,
but the overexposed parts don't.

00:36:27.040 --> 00:36:29.200
Those do not show up.

00:36:29.210 --> 00:36:33.520
But with tone mapping, basically,
within the same render target,

00:36:33.520 --> 00:36:38.160
you can capture both
kind of exposure levels.

00:36:38.900 --> 00:36:48.000
[Transcript missing]

00:36:50.590 --> 00:36:53.920
Okay,
another image quality enhancement we

00:36:53.920 --> 00:36:57.750
added to iOS 5 is improving the quality
of the shadows that you can have,

00:36:57.810 --> 00:37:00.670
dynamic shadows you
can have in your games.

00:37:01.550 --> 00:37:03.640
So here's a real life example.

00:37:03.680 --> 00:37:07.160
There's a big window
and then the sunlight,

00:37:07.260 --> 00:37:10.990
which is a planar light in this case,
is being occluded by the big

00:37:10.990 --> 00:37:12.790
columns within the window.

00:37:13.150 --> 00:37:15.680
And you can see the
light and the shadows.

00:37:15.750 --> 00:37:19.190
And there's a part that doesn't
get any light at all except

00:37:19.190 --> 00:37:21.120
for the global ambient light.

00:37:21.190 --> 00:37:22.540
And it's called Umbra.

00:37:22.640 --> 00:37:26.870
Basically, the column entirely blocks
the sunlight for that part.

00:37:27.210 --> 00:37:30.530
So that's easy to capture with the
shadow mapping technique in your games.

00:37:30.540 --> 00:37:36.920
But there's this part where
part of the sunlight is blocked,

00:37:37.420 --> 00:37:40.920
but since it's not an exact point light,
some other parts of the light

00:37:41.020 --> 00:37:43.740
is leaking in and creating
the soft edge on the shadow.

00:37:43.740 --> 00:37:49.740
So this new extension that we have
called Apple Shadow Samplers enables

00:37:50.080 --> 00:37:54.940
us and you to simulate that kind
of softer edges on the shadows.

00:37:55.030 --> 00:37:58.620
It uses a technique called
percentage closer filtering.

00:37:58.620 --> 00:38:03.430
So what it does is,
if you think about the shadow mapping,

00:38:03.830 --> 00:38:08.470
shadow mapping is capturing the
scene from the perspective of light.

00:38:08.470 --> 00:38:12.070
And then when you're rendering it
from the perspective of the viewer,

00:38:12.370 --> 00:38:17.460
projecting that to the view and
comparing the depths and finding out if

00:38:17.580 --> 00:38:21.930
that pixel on the screen is seeing any
contribution from that light or not.

00:38:22.060 --> 00:38:25.170
But it is a binary test when you're
doing it on a per pixel basis.

00:38:25.180 --> 00:38:29.580
A percentage closer filtering basically
moves it from a binary test to a four

00:38:29.580 --> 00:38:33.800
sample test that will allow you to
generate any range between zero to one.

00:38:33.820 --> 00:38:37.590
And basically you do four depth
texture tests and compare and

00:38:37.590 --> 00:38:39.180
return a weighted average.

00:38:39.300 --> 00:38:44.360
And that tells you how much light
contribution you get from that light,

00:38:44.410 --> 00:38:47.770
which also tells you how
much shadow that pixel gets.

00:38:47.850 --> 00:38:51.180
And again, it's a feature that's
only available on iPad 2.

00:38:51.180 --> 00:38:54.540
So here's an example of the shadow map.

00:38:54.700 --> 00:39:00.560
The depth texture from shadow map is
mapped onto the depth values of the

00:39:00.720 --> 00:39:03.820
viewer and from the viewer's perspective.

00:39:03.820 --> 00:39:07.660
And you can see on the right side,
basically there's no confusion.

00:39:07.660 --> 00:39:12.680
There's no light leaking in from
that light for that particular pixel.

00:39:12.820 --> 00:39:15.800
And the blue one over here is a
pixel that is getting actually

00:39:15.930 --> 00:39:19.630
when on a projected shadow map
is basically corresponding to

00:39:19.790 --> 00:39:21.180
four values from that shadow map.

00:39:21.180 --> 00:39:24.130
And you can see that it is
partially getting light and

00:39:24.130 --> 00:39:25.500
partially not getting light.

00:39:25.500 --> 00:39:27.770
So the light will be
attenuated in this case.

00:39:27.920 --> 00:39:28.230
Okay.

00:39:28.440 --> 00:39:32.580
So we added new GLSL define
called GLApple shadow samplers.

00:39:32.580 --> 00:39:35.340
New sampler type, sampler 2D shadow.

00:39:35.340 --> 00:39:38.890
And two new GLSL functions,
shadow 2D apple and shadow

00:39:38.930 --> 00:39:40.110
2D apple projection.

00:39:40.110 --> 00:39:43.030
Projection apple.

00:39:43.220 --> 00:39:46.100
And here's a fragment shader example.

00:39:46.230 --> 00:39:51.320
So what we're doing here is basically
our sample 2D shadow is getting the depth

00:39:51.570 --> 00:39:54.100
texture from the perspective of light.

00:39:54.310 --> 00:39:59.100
And we're also passing an attenuation
factor from our vertex shader.

00:39:59.100 --> 00:40:02.530
And in the first line,
we're basically comparing

00:40:03.300 --> 00:40:08.400
using the coordinates of light,
light texture, how much of it is passing

00:40:08.400 --> 00:40:10.100
these comparisons.

00:40:10.110 --> 00:40:13.060
And these four samples are taken.

00:40:13.100 --> 00:40:15.570
And then using that value,
we're finding out how much light

00:40:15.700 --> 00:40:17.100
contribution we're getting.

00:40:17.340 --> 00:40:21.760
And the final fragment color is based
on the original color and the light

00:40:21.760 --> 00:40:24.100
contribution multiplied with that color.

00:40:24.310 --> 00:40:27.100
Now, this gives you software shadows.

00:40:27.100 --> 00:40:30.090
And if you have significant
compute bandwidth available to you,

00:40:30.100 --> 00:40:33.810
if you're not doing anything else,
you can actually run -- you can jitter

00:40:33.850 --> 00:40:37.460
the texture coordinates of the light map,
and you can do multiple tests

00:40:37.460 --> 00:40:39.040
and get a larger coverage area.

00:40:39.100 --> 00:40:39.130
Amen.

00:40:41.700 --> 00:40:43.210
Okay,
we have a demo for this one as well.

00:40:43.340 --> 00:40:47.860
So let's start with no shadows.

00:40:48.000 --> 00:40:49.860
So this is an interesting demo.

00:40:49.860 --> 00:40:53.040
It basically uses a technique
known as light prepass,

00:40:53.040 --> 00:40:54.540
a deferred lighting technique.

00:40:54.660 --> 00:40:58.460
It's doing four passes, one shadow pass,
and three rendering passes to

00:40:58.460 --> 00:41:04.050
end up with 64 point lights and
one sunlight and this huge model,

00:41:04.060 --> 00:41:06.940
normal maps,
per-pixel lighting everywhere.

00:41:06.940 --> 00:41:08.580
So it's very interesting,
and I think we're going to

00:41:08.590 --> 00:41:12.100
talk about this as well at
the session when we have it,

00:41:12.100 --> 00:41:16.620
I think, at 4:30 on best practices.

00:41:16.660 --> 00:41:20.120
So I want to show you first the
shadow map that I talked about,

00:41:20.120 --> 00:41:22.340
the depth values from
the perspective of light.

00:41:22.360 --> 00:41:26.860
And you can compare it to the
depth values on the right here

00:41:27.010 --> 00:41:28.480
from the perspective of viewer.

00:41:28.550 --> 00:41:34.700
So these are mapped onto the one on the
right to basically do the comparisons.

00:41:34.700 --> 00:41:38.400
And without shadows,
our scene looks really nice.

00:41:38.850 --> 00:41:40.280
But it doesn't look realistic.

00:41:40.280 --> 00:41:44.540
When you add hard shadows,
it becomes more realistic.

00:41:44.580 --> 00:41:48.940
But you can see on the edges of the
columns that the shadows are per-pixel,

00:41:48.940 --> 00:41:50.900
and they show up being as per-pixel.

00:41:50.900 --> 00:41:54.580
And when it actually moves,
it's more visible because the per-pixel,

00:41:54.580 --> 00:41:57.020
the operation moves up
and down Chris Jitters.

00:41:57.050 --> 00:42:01.360
And with percentage closer filtering,
it is much softer.

00:42:01.360 --> 00:42:03.900
And we're doing just
four samples in here.

00:42:03.900 --> 00:42:08.070
So you can turn it on and off a little
a few times so you can see the details.

00:42:08.130 --> 00:42:08.700
Let me animate it.

00:42:08.780 --> 00:42:13.630
So this is all real-time lighting
of both point lights and sunlight

00:42:13.700 --> 00:42:16.610
and with real-time shadows.

00:42:17.700 --> 00:42:21.140
and Sun is gone now,
so we don't have any shadows.

00:42:21.140 --> 00:42:22.100
When they come up?

00:42:22.220 --> 00:42:25.290
Just in a few seconds, I think.

00:42:27.360 --> 00:42:32.300
Then we can basically go
to hard and soft shadows.

00:42:32.350 --> 00:42:33.540
Okay.

00:42:33.690 --> 00:42:38.510
So these are the things that you can do
by taking advantage of our new extension.

00:42:38.680 --> 00:42:40.090
Okay.

00:42:40.800 --> 00:42:48.100
So the third category we had is basically
enhancing the performance of your games.

00:42:48.700 --> 00:42:52.620
And we'll start with the separate
shader objects extension.

00:42:52.710 --> 00:42:56.710
Separate shader objects extension
is trying to solve the problem

00:42:56.710 --> 00:42:58.860
of the multiple stdof shaders.

00:42:58.890 --> 00:43:01.400
In many games,
you would have this case like

00:43:01.540 --> 00:43:05.190
you would have multiple vertex
shaders that are run with multiple

00:43:05.190 --> 00:43:07.020
fragment shaders and paired.

00:43:07.040 --> 00:43:10.780
If you have n vertex shaders that can
be paired with n fragment shaders,

00:43:10.780 --> 00:43:12.710
you would have the cross
pairing of all of them.

00:43:12.890 --> 00:43:16.990
Like an example would be if you have a
vertex shader that just does transforms

00:43:17.360 --> 00:43:21.820
and another vertex shader that does
transforms plus skeletal animation.

00:43:21.830 --> 00:43:25.500
And you have a fragment shader,
one of them doing just texturing,

00:43:25.500 --> 00:43:28.850
another one doing texturing plus light,
and third one doing texturing

00:43:29.000 --> 00:43:30.140
plus light plus fog.

00:43:30.170 --> 00:43:33.560
You might, depending on the object type,
you might use either the first vertex

00:43:33.560 --> 00:43:35.450
shader with the second fragment shader.

00:43:35.580 --> 00:43:37.020
All six combinations of them are perfect.

00:43:37.060 --> 00:43:39.020
And you can do the same thing
with the second vertex shader.

00:43:39.020 --> 00:43:40.150
So you would have a set of five
vertex shaders that are being

00:43:40.270 --> 00:43:41.020
paired with ten fragment shaders.

00:43:41.020 --> 00:43:44.620
So in that case,
you would basically end up compiling

00:43:44.620 --> 00:43:49.370
your vertex shader 50 times,
your fragment shader 50 times,

00:43:49.440 --> 00:43:52.250
and linking them together 50 times.

00:43:52.670 --> 00:43:57.540
So Apple Separate Shader Objects
tries to fix this problem,

00:43:57.750 --> 00:43:59.700
or help with this problem.

00:43:59.700 --> 00:44:03.370
So it creates a new object type
called Program Pipeline Object,

00:44:03.370 --> 00:44:05.330
and it gives you a mix
and match strategy,

00:44:05.330 --> 00:44:07.190
possibility of a mix and match strategy.

00:44:07.360 --> 00:44:10.120
So what it does is instead
of having a vertex shader,

00:44:10.120 --> 00:44:12.250
you basically have a vertex program.

00:44:12.250 --> 00:44:15.140
So every stage of the pipeline,
and we have two stages,

00:44:15.140 --> 00:44:18.860
vertex stage and the fragment stage,
every stage of the pipeline,

00:44:18.860 --> 00:44:22.670
you create a program for that stage,
and then you pair them later.

00:44:22.680 --> 00:44:26.320
So if you have five vertex
shaders and ten fragment shaders,

00:44:26.320 --> 00:44:29.460
it means that you need to
create five vertex programs

00:44:29.510 --> 00:44:32.410
and ten fragment programs,
and then you can pair

00:44:32.410 --> 00:44:34.120
them as much as you want.

00:44:34.170 --> 00:44:37.340
So instead of 50
compilations on vertex side.

00:44:37.490 --> 00:44:41.120
50 compilations on fragment side,
and 50 times linking,

00:44:41.190 --> 00:44:43.500
you basically do a lot
less work on the CPU side.

00:44:45.330 --> 00:44:49.120
Which means that you end up with
shorter compilation and linking times.

00:44:49.230 --> 00:44:52.480
So you can basically take advantage
of it in two different ways.

00:44:52.500 --> 00:44:55.710
You can have, basically,
if you were keeping the number of

00:44:55.730 --> 00:45:00.060
shaders fewer than you would normally
because you were thinking that your

00:45:00.120 --> 00:45:04.270
boot time or level load time was long,
you can add those shaders back and

00:45:04.270 --> 00:45:08.190
keep the same amount of time on your
level loading and have more variety

00:45:08.290 --> 00:45:09.960
of shaders and better effects.

00:45:09.970 --> 00:45:11.570
Or alternatively,
you can just take advantage of

00:45:11.640 --> 00:45:15.160
it and have faster boot up times
or faster level load times.

00:45:15.170 --> 00:45:22.800
One disadvantage of this extension
is when the compiler can see both

00:45:22.900 --> 00:45:27.370
the vertex stage and fragment stage,
it can do some set of optimizations.

00:45:27.390 --> 00:45:29.520
It can do some set of
dead code elimination.

00:45:29.520 --> 00:45:34.080
It can do, basically,
elimination of unused variances.

00:45:34.160 --> 00:45:37.470
It doesn't go and interplay the
variances that are not used.

00:45:37.550 --> 00:45:42.570
So if your shader performance
strictly depends on the kind of

00:45:42.570 --> 00:45:46.810
optimizations that the compiler
does and it can see both of them,

00:45:46.810 --> 00:45:49.700
you probably either change your
shaders or think how much gain

00:45:49.700 --> 00:45:51.640
you're getting from this one.

00:45:51.640 --> 00:45:54.960
But that is very rare that you
would end up with this kind of

00:45:54.960 --> 00:45:58.080
benefits from the compiler normally.

00:45:58.160 --> 00:46:01.960
So that's something to know about.

00:46:02.000 --> 00:46:03.280
So here's an example.

00:46:03.290 --> 00:46:05.390
In our vertex program, basically,
we have a vertex shader

00:46:05.440 --> 00:46:07.600
just like you had on IS4.

00:46:07.600 --> 00:46:10.400
And you would basically compile
and link that vertex shader

00:46:10.400 --> 00:46:11.930
and create a vertex program.

00:46:12.160 --> 00:46:15.080
You would do the same for
your fragment shaders.

00:46:15.110 --> 00:46:18.470
You would create fragment
programs out of those as well.

00:46:18.730 --> 00:46:22.270
And when it's time to use them,
you can basically say, "Hey,

00:46:22.270 --> 00:46:26.400
I want to use for this stage this
program and the second stage this other

00:46:26.530 --> 00:46:30.630
program." And there's no relinking
or recompiling happening in here,

00:46:30.670 --> 00:46:32.310
so it's really fast.

00:46:32.410 --> 00:46:36.940
And you can basically pair your first
vertex program with the second fragment

00:46:36.940 --> 00:46:41.510
program in here without causing
any new compilations and linkings.

00:46:41.610 --> 00:46:42.020
Same here.

00:46:42.150 --> 00:46:45.040
You can pair them up in any way you want.

00:46:46.380 --> 00:46:48.230
So it has actually two usage models.

00:46:48.480 --> 00:46:51.100
It can create program pipeline
objects for each combination.

00:46:51.160 --> 00:46:55.950
So you basically can create your vertex
programs and fragment programs and pair

00:46:55.950 --> 00:47:00.260
them together at the very beginning
instead of attaching and detaching them,

00:47:00.270 --> 00:47:04.400
which would be faster at runtime
but slower at boot time a little.

00:47:04.420 --> 00:47:07.080
And then -- or you can use the
same program pipeline object,

00:47:07.100 --> 00:47:10.000
just like in my example,
and attach and detach

00:47:10.000 --> 00:47:13.440
program stages on the fly,
which would be a little slower on

00:47:13.450 --> 00:47:17.000
runtime because you have to basically
attach and detach them when there's some

00:47:17.000 --> 00:47:20.860
work going on on the OpenGL ES side,
but you will have faster boot time.

00:47:20.860 --> 00:47:23.760
So you can use either model
depending on what your needs are.

00:47:23.760 --> 00:47:26.950
It is -- if you're familiar with
the ARP Separate Shader Objects

00:47:26.950 --> 00:47:31.020
extension and ARP Explicit Attribute
Location extension from the desktop,

00:47:31.020 --> 00:47:33.950
you already know how this thing
works because we basically took

00:47:33.950 --> 00:47:37.570
those two and then removed some
of the things that are -- the

00:47:37.570 --> 00:47:41.640
ES constraints are not allowed us to do,
like remove geometry stage, for example,

00:47:41.640 --> 00:47:44.510
or tessellation stage from that,
and came up with this

00:47:44.560 --> 00:47:48.690
Apple Separate Shader Objects,
and we just used the same extension.

00:47:48.700 --> 00:47:51.080
Okay, that's Separate Shader Objects.

00:47:51.080 --> 00:47:55.290
The final performance optimization
extension is Occlusion Query extension.

00:47:55.300 --> 00:47:59.320
So in your games,
you probably have some visibility

00:47:59.400 --> 00:48:03.560
determination system to find
out what needs to be drawn and

00:48:03.570 --> 00:48:05.960
what not needs to be drawn.

00:48:05.960 --> 00:48:07.480
Frostrum calling is an example,
and you might have

00:48:07.480 --> 00:48:08.480
something more complicated.

00:48:08.480 --> 00:48:11.720
But there are times you would have
an object that's within your Frostrum

00:48:11.720 --> 00:48:16.060
but might be occluded entirely
by another object in front of it.

00:48:16.060 --> 00:48:21.720
And so this extension,
Apple Occlusion Query Boolean,

00:48:21.870 --> 00:48:25.090
Basically,
it allows you to do a binary test to

00:48:25.090 --> 00:48:30.200
find out if any of the samples from
this object that might be occluded

00:48:30.240 --> 00:48:32.150
is reaching to your render target.

00:48:32.160 --> 00:48:38.160
So, the advantage is basically if your
object has 10,000s of vertices,

00:48:38.190 --> 00:48:43.860
you use a bonding box inside and you
basically draw it without affecting

00:48:43.860 --> 00:48:44.960
the color and depth buffers.

00:48:45.640 --> 00:48:49.850
And then the next frame,
you go and check if it were actually

00:48:49.980 --> 00:48:54.590
drawn with any of the samples that
are made to the render target.

00:48:54.600 --> 00:48:57.220
If it did,
it means that your object is now

00:48:57.220 --> 00:48:59.280
visible and you can render it.

00:48:59.420 --> 00:49:01.250
If it didn't,
it means that it were actually

00:49:01.250 --> 00:49:05.380
entirely occluded by another object,
so you actually didn't have to push that

00:49:05.380 --> 00:49:07.670
many data into the rendering system.

00:49:07.780 --> 00:49:11.260
And you basically repeat the same
query over and over every frame.

00:49:12.010 --> 00:49:16.260
The only minor disadvantage is
that your object might end up

00:49:16.330 --> 00:49:18.210
on the screen one frame later.

00:49:18.480 --> 00:49:22.920
Again, it's an iPad 2-only feature due
to the hardware requirements.

00:49:23.100 --> 00:49:28.150
So the benefit of it is it enhances the
performance by avoiding large draw calls.

00:49:28.370 --> 00:49:32.300
So our GPUs are tile-based
deferred renderers,

00:49:32.350 --> 00:49:34.200
so they basically don't
have much overdraw.

00:49:34.290 --> 00:49:37.760
But if you're pushing 10,000
vertices and none of them are

00:49:37.760 --> 00:49:41.490
ending up on your render target,
we are still running the vertex

00:49:41.490 --> 00:49:45.070
program on all of those vertices,
and we're pushing data in and

00:49:45.100 --> 00:49:46.610
out for all of those vertices.

00:49:46.630 --> 00:49:48.300
So you don't have to
do vertex processing.

00:49:48.300 --> 00:49:51.220
You gain not doing that.

00:49:51.260 --> 00:49:52.760
A code example here.

00:49:52.960 --> 00:49:54.490
The frame end is our current frame.

00:49:54.570 --> 00:49:57.380
We set a query by calling GL begin query.

00:49:57.430 --> 00:50:01.180
And basically,
we put here the bonding box.

00:50:01.390 --> 00:50:05.300
Like if you have a car,
you probably have two rectangles that

00:50:05.390 --> 00:50:07.380
will cover the car as your bonding box.

00:50:07.410 --> 00:50:10.550
And you're passing eight vertices
instead of all the details of your

00:50:10.630 --> 00:50:13.940
car into the scene to find out if
any of the samples from the car

00:50:13.940 --> 00:50:16.500
is making to the render target.

00:50:16.540 --> 00:50:19.330
And in the next frame,
you basically check the

00:50:19.330 --> 00:50:20.740
results of your test.

00:50:20.780 --> 00:50:23.360
If the result is positive,
it means that some of

00:50:23.450 --> 00:50:25.690
the pixels from your car,
some of the samples from your

00:50:25.760 --> 00:50:29.930
car is showing up on the screen,
so it's time to draw it.

00:50:30.300 --> 00:54:05.300
[Transcript missing]
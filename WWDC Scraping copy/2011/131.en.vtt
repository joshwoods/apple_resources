WEBVTT

00:00:11.210 --> 00:00:12.100
Good morning.

00:00:12.100 --> 00:00:15.100
It's great to see you all here
on a Friday post-Beer Bash.

00:00:15.210 --> 00:00:18.830
My name is Brent Ramerth and
I work on natural language

00:00:18.880 --> 00:00:21.310
processing and internationalization.

00:00:21.310 --> 00:00:26.010
And today I'd like to talk to you about
how to make a great international app.

00:00:27.650 --> 00:00:30.670
So you're all here at
WWDC because you want to make

00:00:30.670 --> 00:00:33.610
great apps for iOS and Mac OS X.

00:00:33.730 --> 00:00:37.680
Well, part of making a great app is
making an app that is accessible

00:00:37.680 --> 00:00:39.900
to as many people as possible.

00:00:39.990 --> 00:00:44.900
And there's no greater audience
for your app out there than

00:00:44.900 --> 00:00:44.900
the international market.

00:00:45.100 --> 00:00:48.650
There is a wealth of potential
customers for your app in

00:00:48.650 --> 00:00:53.170
countries like China and Japan,
in regions like Europe and

00:00:53.170 --> 00:00:54.500
the Middle East.

00:00:54.600 --> 00:00:56.940
And in order to take
advantage of these markets,

00:00:57.020 --> 00:01:00.940
we want you to be familiar with the
basic concepts of internationalization.

00:01:01.060 --> 00:01:03.490
So that's what we're
going to talk about today.

00:01:03.760 --> 00:01:07.590
Now, if you've never made an app for
a country outside of your own,

00:01:07.590 --> 00:01:10.220
this talk is definitely for you.

00:01:10.220 --> 00:01:14.310
We're going to cover the fundamental
concepts of internationalization,

00:01:14.310 --> 00:01:18.490
the APIs that you'll use when
making an international app,

00:01:18.490 --> 00:01:21.160
and we're going to get you started.

00:01:21.160 --> 00:01:23.450
So if you've already got
some experience in this,

00:01:23.520 --> 00:01:25.860
we're also going to have
stuff for you today.

00:01:25.910 --> 00:01:27.750
If you've already done some
internationalization or you've

00:01:27.750 --> 00:01:29.490
already done localization,
that's great.

00:01:29.570 --> 00:01:35.600
We're going to talk today about some
common mistakes or pitfalls in using

00:01:35.600 --> 00:01:40.580
the APIs and how you can avoid those,
as well as look at some new APIs and

00:01:40.580 --> 00:01:43.240
features for internationalization.

00:01:43.240 --> 00:01:45.360
So let's get started.

00:01:45.880 --> 00:01:50.830
Now, for the last six quarters,
the majority of Apple's revenue has

00:01:50.830 --> 00:01:53.370
come from international sources.

00:01:53.420 --> 00:01:57.750
In Q2 of 2011 alone,
59% of revenue originated from

00:01:57.760 --> 00:01:59.610
outside the United States.

00:01:59.860 --> 00:02:02.860
And, so,
there is a lot of potential market

00:02:02.860 --> 00:02:05.230
for your app in these countries.

00:02:05.300 --> 00:02:10.270
The fastest growing market for
Apple products is not the United States.

00:02:10.370 --> 00:02:11.770
It's China.

00:02:11.930 --> 00:02:16.100
So just to give you an idea of all
the different countries out there,

00:02:16.250 --> 00:02:19.070
there's a lot of different countries
you can be shipping your app in.

00:02:19.140 --> 00:02:22.550
And most of these,
outside of the United States,

00:02:22.630 --> 00:02:25.560
most of these customers are
not native English speakers.

00:02:25.730 --> 00:02:29.030
They use different writing systems,
different date and time formats,

00:02:29.390 --> 00:02:32.640
different calendars, just to name a few.

00:02:35.020 --> 00:02:39.600
So here we see a map of all the
countries that are currently

00:02:39.600 --> 00:02:42.960
shipping iPhone as of May.

00:02:43.860 --> 00:02:48.200
As you can see, there's a lot of
coverage in the Americas,

00:02:48.260 --> 00:02:49.060
great coverage of Europe.

00:02:49.100 --> 00:02:51.630
Asia and Africa are covered.

00:02:51.690 --> 00:02:55.350
And a lot of coverage in
the Middle East and the

00:02:55.350 --> 00:02:59.460
largest markets in the world,
China and India.

00:03:00.520 --> 00:03:04.730
So the point here is that as a developer,
you don't have to be constrained to

00:03:04.820 --> 00:03:07.300
shipping your app in your own country.

00:03:07.300 --> 00:03:10.420
You can ship your app in China if
you're an American developer.

00:03:10.420 --> 00:03:13.230
If you're a Chinese developer,
you can make your app

00:03:13.250 --> 00:03:15.570
for the United States,
Russia or Brazil,

00:03:15.570 --> 00:03:17.450
just to give you some examples.

00:03:20.470 --> 00:03:25.670
As far as localization goes, on iOS,
you can make a localized app

00:03:25.670 --> 00:03:28.070
for any of these languages.

00:03:28.080 --> 00:03:31.160
These are the system UI languages.

00:03:31.260 --> 00:03:34.930
And on Mac OS X,
you're not constrained to this list.

00:03:34.930 --> 00:03:38.390
You can make your app
localized in any language.

00:03:38.390 --> 00:03:44.140
Now, localization is not going to be the
primary focus for today's presentation,

00:03:44.140 --> 00:03:47.880
but I just want to give you
an idea of the potential scope

00:03:47.910 --> 00:03:48.680
for the languages of your app.

00:03:51.340 --> 00:03:54.320
Now, before we get too far,
let's clarify what is

00:03:54.320 --> 00:03:58.240
the difference between
internationalization and localization.

00:03:58.330 --> 00:04:00.900
These concepts are sometimes confused.

00:04:00.900 --> 00:04:04.710
Now, internationalization, simply put,
is designing your app for

00:04:04.710 --> 00:04:06.890
international compatibility.

00:04:06.890 --> 00:04:08.650
This includes text content.

00:04:08.910 --> 00:04:12.050
We want your apps to be
able to handle input,

00:04:12.050 --> 00:04:16.730
output and to be able to process text
in any language and in any script.

00:04:16.730 --> 00:04:19.310
Furthermore,
your apps should be able to handle

00:04:19.390 --> 00:04:23.540
different date and time formats,
different number formats and

00:04:23.610 --> 00:04:28.090
calendars and time zones which
give us no end of trouble.

00:04:28.310 --> 00:04:32.940
Now, internationalization is something
that you as a developer have to do.

00:04:32.940 --> 00:04:37.020
You have to adopt the APIs,
make the code changes.

00:04:37.190 --> 00:04:41.060
Localization, on the other hand,
another piece of this puzzle is

00:04:41.060 --> 00:04:46.570
something that you can ship out
and get experts to help you with.

00:04:46.660 --> 00:04:51.180
Localization is translation of your
app's user interface and resources.

00:04:51.320 --> 00:04:55.940
So once you have extracted the strings
from your app and the resources,

00:04:55.940 --> 00:05:00.110
then you can ship them off
to a language expert and they

00:05:00.110 --> 00:05:02.140
will help you translate them.

00:05:02.280 --> 00:05:06.460
So about internationalization,
maybe you've heard that making

00:05:06.460 --> 00:05:10.640
international apps is hard and there's
a lot of different languages out there,

00:05:10.640 --> 00:05:15.100
a lot of different formats and, you know,
why would you want to do that

00:05:15.100 --> 00:05:17.630
on top of all the other things
you've got to do with your app?

00:05:17.770 --> 00:05:22.660
Making new features and fixing bugs,
all that kind of stuff.

00:05:22.680 --> 00:05:25.300
Well,
the point is internationalization doesn't

00:05:25.300 --> 00:05:29.540
have to be hard and if you follow the
APIs and the guidelines we're going

00:05:29.540 --> 00:05:33.180
to set forth in today's presentation,
it's easy.

00:05:33.230 --> 00:05:38.260
We're going to be able to make one app
for all locales and that app will be

00:05:38.270 --> 00:05:41.280
able to support content in any language.

00:05:41.440 --> 00:05:46.920
So here we see pages and
it is localized in English.

00:05:47.000 --> 00:05:52.100
The content is in a variety of
languages including Chinese,

00:05:52.200 --> 00:05:54.350
Thai and Russian.

00:05:54.480 --> 00:05:57.000
So that's the kind of
thing you'll be able to do.

00:05:59.480 --> 00:06:03.880
For today's talk, first off,
we're going to talk about APIs.

00:06:03.950 --> 00:06:07.070
We're going to look at the
APIs that you'll use to develop an

00:06:07.070 --> 00:06:11.920
international application and some
guidelines for use of those APIs.

00:06:12.030 --> 00:06:17.080
We're then going to look at some
international user interfaces and

00:06:17.080 --> 00:06:22.560
how they pertain to testing and what
your users are going to be seeing.

00:06:22.560 --> 00:06:26.030
And finally,
we will look at some new APIs and

00:06:26.030 --> 00:06:26.910
features in the international space.

00:06:27.430 --> 00:06:32.290
So first,
let's look at international APIs.

00:06:33.150 --> 00:06:36.680
Now, many of these APIs are probably
familiar to you already if

00:06:36.770 --> 00:06:38.430
you're a Cocoa developer.

00:06:38.480 --> 00:06:41.820
APIs such as NSString, NSLocal.

00:06:42.000 --> 00:06:44.850
Today we're going to look at
these APIs as they pertain

00:06:44.850 --> 00:06:46.510
to internationalization.

00:06:46.690 --> 00:06:50.890
How to use them appropriately when
developing an international app.

00:06:52.340 --> 00:06:54.860
First of, let's talk about locales.

00:06:55.000 --> 00:06:57.190
Now,
locales are going to drive all of the

00:06:57.280 --> 00:06:59.840
other topics that we will cover today.

00:06:59.860 --> 00:07:04.500
A locale is fundamentally
an encapsulation of regional

00:07:04.720 --> 00:07:08.030
formatting standards,
which are specific to a language

00:07:08.150 --> 00:07:11.370
and usually a region in which
that language is spoken.

00:07:11.570 --> 00:07:16.860
So, for example, US English is a locale,
which corresponds to properties

00:07:16.960 --> 00:07:22.220
such as does not use metric system,
separates groups of numbers with commas,

00:07:22.220 --> 00:07:23.780
et cetera.

00:07:24.130 --> 00:07:27.830
And so these locale objects
are going to drive a lot of the

00:07:27.830 --> 00:07:28.870
APIs that we're going to use.

00:07:28.980 --> 00:07:32.680
They're going to be used
to localize UI controls,

00:07:32.680 --> 00:07:33.220
etc.

00:07:33.300 --> 00:07:37.500
And we're going to use the
NSLocale API to handle these.

00:07:39.800 --> 00:07:44.600
Now sometimes locales are
confused with localization.

00:07:44.750 --> 00:07:47.130
These are two separate concepts.

00:07:47.130 --> 00:07:51.540
Locales represent the formatting
standards for your app.

00:07:51.660 --> 00:07:54.140
How does it handle dates and times?

00:07:54.220 --> 00:07:54.940
What is the calendar?

00:07:54.940 --> 00:07:57.100
What is the currency?

00:07:57.460 --> 00:08:00.140
The localization is the UI language.

00:08:00.310 --> 00:08:03.020
How are the strings localized?

00:08:03.170 --> 00:08:05.410
What is the language of the app?

00:08:05.410 --> 00:08:09.190
Now, it's often the case that
these two correspond,

00:08:09.340 --> 00:08:12.080
but it's not necessary that they do.

00:08:12.160 --> 00:08:17.850
It is perfectly legitimate to have
your app be localized in English and

00:08:17.850 --> 00:08:20.370
have locale set to Japanese.

00:08:20.370 --> 00:08:24.690
You'll see English UI strings
and your dates and times

00:08:24.690 --> 00:08:24.690
will be shown in Japanese.

00:08:26.200 --> 00:08:29.400
So let's take a look at
what that would look like.

00:08:29.420 --> 00:08:31.420
On the left, we have iCal.

00:08:31.420 --> 00:08:33.780
And it is localized in English.

00:08:33.910 --> 00:08:37.840
You have an English keyboard
up and English UI strings.

00:08:37.970 --> 00:08:45.290
The dates and times are
in the standard U.S.

00:08:45.290 --> 00:08:45.290
English format.

00:08:45.290 --> 00:08:45.290
And using 12-hour time.

00:08:46.290 --> 00:08:50.490
Here we've set the locale
to be Japanese and now

00:08:50.490 --> 00:08:53.010
the dates are in Japanese.

00:08:53.230 --> 00:08:56.200
However, the localization of
the app didn't change.

00:08:56.200 --> 00:08:58.610
So you can mix and match these two.

00:09:00.470 --> 00:09:03.240
Now that we've seen what
a locale looks like,

00:09:03.390 --> 00:09:05.700
how do we actually access them?

00:09:05.880 --> 00:09:06.800
There are two ways.

00:09:06.800 --> 00:09:10.350
There's a way that you can get a
dynamic locale object which will update

00:09:10.350 --> 00:09:12.560
as the user changes their locale.

00:09:12.560 --> 00:09:17.120
And that is done with auto
updating current locale.

00:09:17.120 --> 00:09:21.040
There is also a way to get
a locale as a static object.

00:09:21.040 --> 00:09:22.850
And there are three
different ways to do that.

00:09:22.850 --> 00:09:24.860
First off,
you're probably going to want to

00:09:24.920 --> 00:09:29.560
use the current locale which is
the user's settings for formatting.

00:09:29.590 --> 00:09:34.370
Whenever you're doing UI visible things,
you always want to use

00:09:34.370 --> 00:09:36.200
the current locale.

00:09:36.200 --> 00:09:40.470
You can also create an arbitrary locale
using init with locale identifier.

00:09:40.470 --> 00:09:44.490
You might use this if you were, say,
trying to display a calendar

00:09:45.060 --> 00:09:47.390
from a different locale.

00:09:47.860 --> 00:09:51.320
And finally, there is the system locale.

00:09:51.320 --> 00:09:53.980
The system locale has limited uses.

00:09:54.020 --> 00:10:01.710
It's primarily used for parsing and
formatting fixed format expressions,

00:10:01.710 --> 00:10:01.710
and we'll get into that a little
bit later in the presentation.

00:10:03.580 --> 00:10:08.660
So now that we have locale objects,
we can do a variety of things with it.

00:10:08.730 --> 00:10:12.760
First off, let's say you're making an app
in which you want to present

00:10:12.760 --> 00:10:14.360
measurements to the user.

00:10:14.490 --> 00:10:18.490
Well, you probably want to present these
measurements in the measurement

00:10:18.490 --> 00:10:20.730
system that the user is familiar with.

00:10:20.790 --> 00:10:24.420
So we can use the NSLocale as
a dictionary and pull out

00:10:24.420 --> 00:10:28.370
the key associated with
NSLocale uses metric system.

00:10:28.370 --> 00:10:33.500
And that will tell us whether the
current locale uses metric system.

00:10:34.890 --> 00:10:37.720
Similarly,
we can access the current currency code.

00:10:37.900 --> 00:10:43.200
Let's say you're making an app which
needs to display currency information.

00:10:43.200 --> 00:10:52.020
We can do the currency conversion,
or you want to do currency conversion,

00:10:52.020 --> 00:10:54.310
so you need to know what
the currency code is.

00:10:54.310 --> 00:10:54.310
And so we pull out the currency
code from the locale like so.

00:10:55.970 --> 00:11:04.120
Now, let's say you want to present
a quotation in your UI.

00:11:04.120 --> 00:11:12.180
Well, quotation marks will vary
from locale to locale.

00:11:12.180 --> 00:11:12.790
Different locales use different symbols.

00:11:12.790 --> 00:11:12.790
So we want to create a
localized quotation string.

00:11:13.540 --> 00:11:14.880
And again we use locale.

00:11:14.880 --> 00:11:20.020
We can pull out the begin
quotation mark like so.

00:11:20.020 --> 00:11:23.400
And the end quotation mark.

00:11:23.560 --> 00:11:27.340
Create a formatted string with those two.

00:11:28.270 --> 00:11:33.640
And now you see this will do the right
thing in all the different locales.

00:11:33.750 --> 00:11:36.300
For China,
it will give you double quotes.

00:11:36.480 --> 00:11:37.950
For Korea, single quotes.

00:11:38.000 --> 00:11:40.870
And for Japan, the brackets.

00:11:43.040 --> 00:11:47.090
Now throughout today's presentation
we're going to talk about some

00:11:47.090 --> 00:11:53.920
common mistakes and pitfalls that
we see in using international APIs.

00:11:54.030 --> 00:12:00.260
First off for NSLocale,
it is commonly thought that you

00:12:00.260 --> 00:12:04.500
can access the UI language using
locale but as we saw in previous

00:12:04.500 --> 00:12:06.870
examples that's not the case.

00:12:06.870 --> 00:12:10.000
You can have those vary independently.

00:12:10.000 --> 00:12:15.260
So it's not a good idea to use
NSLocale language code in order

00:12:15.310 --> 00:12:17.960
to access the UI language.

00:12:17.960 --> 00:12:20.950
Instead you can use the NSBundle API.

00:12:21.140 --> 00:12:27.680
NSBundle is your resource for accessing
all of your localized resources.

00:12:27.680 --> 00:12:32.580
There is a preferred localizations method
from the main bundle which gives you a

00:12:32.590 --> 00:12:38.520
list of the user's preferred UI languages
and the item at index 0 in that list

00:12:38.520 --> 00:12:40.920
will be the preferred UI localization.

00:12:40.920 --> 00:12:42.580
visualization.

00:12:44.370 --> 00:12:50.340
Also, system locale is commonly
confused with current locale.

00:12:50.340 --> 00:12:54.700
It's important to always use current
locale when you're doing UI formatting.

00:12:54.700 --> 00:13:00.520
System locale is a static locale and
it's going to be used for formatting

00:13:00.520 --> 00:13:03.490
and parsing fixed expressions.

00:13:05.420 --> 00:13:09.980
So now I'd like to show you what
this looks like in the UI and

00:13:09.980 --> 00:13:17.230
how you configure these various
settings in the Mac OS X and iOS.

00:13:17.340 --> 00:13:20.780
So let's go to the demo machine.

00:13:22.340 --> 00:13:27.540
So here I have System Preferences and
we're going to go into Language and Text.

00:13:27.750 --> 00:13:31.100
And the formats panel.

00:13:31.100 --> 00:13:34.960
So here is where we would configure
the locale setting for the app.

00:13:35.030 --> 00:13:38.590
This is typically going to be done
during installation for the user.

00:13:38.780 --> 00:13:41.700
The user will configure
the locale appropriately.

00:13:41.700 --> 00:13:44.980
But when testing, you might want to test
with different locales.

00:13:44.980 --> 00:13:47.540
So here's how you would
go ahead and change that.

00:13:48.220 --> 00:13:50.650
The current region here
shows what I have set.

00:13:50.720 --> 00:13:52.670
It's currently set to United States.

00:13:52.670 --> 00:13:55.530
And these are all the locales
that are associated with my

00:13:55.530 --> 00:13:57.510
current UI language of English.

00:13:57.510 --> 00:14:04.160
I can go ahead and show all of the
regions that are in the system.

00:14:04.980 --> 00:14:11.100
And let's see what happens when I change
that to Chinese as spoken in China.

00:14:12.600 --> 00:14:15.050
So now as you see,
we have a different format

00:14:15.150 --> 00:14:17.040
for dates and times.

00:14:17.070 --> 00:14:23.950
Up in the menu bar, we're now showing a
Chinese date and time.

00:14:25.700 --> 00:14:31.550
And in our apps, our apps are showing
Chinese dates and times.

00:14:32.750 --> 00:14:38.800
So this is going to be useful
when testing various locales.

00:14:39.100 --> 00:14:44.000
For changing the language,
we can go to the Language window here.

00:14:44.000 --> 00:14:46.380
And this list is freely orderable.

00:14:46.380 --> 00:14:48.640
You can drag these into any language.

00:14:48.640 --> 00:14:50.940
This will affect things
like font fallback.

00:14:50.940 --> 00:14:58.000
So if you have some questions about that,
we can cover that in the lab.

00:14:58.000 --> 00:15:01.940
But let's say we want to
change this to Korean.

00:15:01.940 --> 00:15:08.240
So we're going to drag
Korean up to the top.

00:15:08.240 --> 00:15:10.290
and restart the app.

00:15:12.610 --> 00:15:16.910
So now you see the UI strings
of the app are in Korean.

00:15:17.300 --> 00:15:20.930
However,
the date and time has stayed in Chinese.

00:15:24.090 --> 00:15:28.200
Okay,
let's see what it looks like on iOS.

00:15:28.300 --> 00:15:31.800
Okay, so similarly,
I'm going to go into settings.

00:15:33.020 --> 00:15:39.420
And on the general panel,
let's go to International, Region Format.

00:15:39.480 --> 00:15:43.690
So here you have all
of your region formats.

00:15:43.690 --> 00:15:47.610
And we can change this to, say, Thai.

00:15:48.900 --> 00:15:54.400
And now in the region format example,
we have different dates coming up and

00:15:54.400 --> 00:15:56.730
that will show up throughout the UI.

00:15:56.910 --> 00:16:01.220
So this will be useful when
testing and just to make sure

00:16:01.220 --> 00:16:05.990
that your app is showing strings
that fit in the UI and so forth.

00:16:06.110 --> 00:16:09.850
Okay, next let's talk about numbers.

00:16:10.080 --> 00:16:14.540
Number formats will vary
widely from locale to locale.

00:16:14.540 --> 00:16:18.490
First off,
not every locale uses ASCII digits.

00:16:18.570 --> 00:16:24.270
In Arabic and Hindi,
non-ASCII digits are used in numbers.

00:16:25.970 --> 00:16:30.690
The grouping separator and the decimal
points change from locale to locale.

00:16:30.710 --> 00:16:38.310
For example, in French,
the space is used for separating

00:16:38.310 --> 00:16:38.310
groups of numbers and the comma
is used for decimal point.

00:16:39.100 --> 00:16:40.980
Different locales will use
different currency symbols,

00:16:41.000 --> 00:16:46.100
of course, but also the order relative to
the number will change and the

00:16:46.100 --> 00:16:48.910
spacing of the currency symbol.

00:16:49.590 --> 00:16:52.990
And finally, percentage amounts.

00:16:53.040 --> 00:16:58.070
In Arabic, a different percent symbol is
used for marking percentages.

00:16:59.400 --> 00:17:04.490
So in order to handle formats
in a locale appropriate manner,

00:17:04.600 --> 00:17:08.680
we want to use an API which is
aware of all these differences.

00:17:08.790 --> 00:17:11.540
That API is NSNumberFormatter.

00:17:11.540 --> 00:17:14.890
Now NSNumberFormatter gives
you a convenience method called

00:17:14.960 --> 00:17:18.470
localized string from number,
which we can use to

00:17:18.580 --> 00:17:20.680
create localized numbers.

00:17:20.800 --> 00:17:25.790
And you just pass in NSNumber and
a style for that number and

00:17:25.790 --> 00:17:25.790
it gives you the string.

00:17:26.360 --> 00:17:31.200
If you need to do things like customizing
the number of digits in your number

00:17:31.200 --> 00:17:39.890
or if you need to parse a number,
then you need to create your own

00:17:39.890 --> 00:17:39.890
NSNumber format or configure it
appropriately and maintain it.

00:17:41.680 --> 00:17:45.260
So here are some examples of
number formats that are built in.

00:17:45.340 --> 00:17:48.800
The general format will be
good for general purposes.

00:17:48.800 --> 00:17:51.600
You have the currency and
percentage and scientific,

00:17:51.600 --> 00:17:54.400
which are self-explanatory.

00:17:54.630 --> 00:18:02.270
And there's a spell out format,
which would be good for things

00:18:02.270 --> 00:18:04.510
like doing text to speech,
if you need to send a

00:18:04.510 --> 00:18:04.510
number to text to speech.

00:18:06.390 --> 00:18:11.270
So the most common mistake in working
with number formatting is using

00:18:11.470 --> 00:18:16.550
old C style functions like printf,
scanf, and string of format

00:18:16.630 --> 00:18:18.770
to format your numbers.

00:18:18.880 --> 00:18:24.070
Now these expressions like %d and %f,
those work fine when

00:18:24.070 --> 00:18:28.140
you're doing ASCII digits,
but they're not going to handle

00:18:28.140 --> 00:18:28.140
non-ASCII digits correctly.

00:18:28.630 --> 00:18:34.050
So if we use code like
this in an Arabic locale,

00:18:34.080 --> 00:18:38.290
we're not going to get the right result.

00:18:38.290 --> 00:18:38.290
That's not the correct Arabic digits.

00:18:39.340 --> 00:18:44.180
Instead, we should use NSNumberFormatter
and the LocalizeStringFromNumber

00:18:44.180 --> 00:18:49.470
convenience method to format this number
appropriately using the decimal style.

00:18:49.600 --> 00:18:56.950
And again, if you need to configure the
number of decimal points,

00:18:57.040 --> 00:19:00.090
you can do that with an option
on the NSNumberFormatter.

00:19:00.090 --> 00:19:00.090
Now we will get the right
result for both locales.

00:19:02.470 --> 00:19:09.020
Another common mistake is in setting
constant pattern on the number formatter.

00:19:09.020 --> 00:19:13.930
So in this example, we've set the format
string to include a dollar.

00:19:13.930 --> 00:19:17.890
And so we are trying to do
a currency format string.

00:19:17.890 --> 00:19:21.020
This might work fine
for the United States,

00:19:21.020 --> 00:19:25.220
but in countries that do not
use the dollar sign like China,

00:19:25.220 --> 00:19:26.890
it's not going to work.

00:19:26.890 --> 00:19:31.340
So we don't want to eliminate that
information that the locale object

00:19:31.340 --> 00:19:35.100
is providing for us by overriding
it with a constant pattern.

00:19:36.140 --> 00:19:38.820
Instead,
we can use the simple built-in format,

00:19:38.940 --> 00:19:47.100
the NSNumberFormatter currency style,
and that again will do the right thing

00:19:47.100 --> 00:19:47.100
regardless of the user's current locale.

00:19:48.200 --> 00:19:51.800
Now,
let's take a look at dates and times.

00:19:51.870 --> 00:19:56.350
A lot of similar suggestions
apply to dates and times.

00:19:56.770 --> 00:20:02.150
Dates and times start incorporating
more of the natural language strings.

00:20:02.150 --> 00:20:05.440
So when we are formatting
a date for French,

00:20:05.490 --> 00:20:08.680
we will see French strings in the date.

00:20:08.820 --> 00:20:11.670
That would be today's
current date in France.

00:20:12.320 --> 00:20:16.500
The calendar in use will
affect the date format string.

00:20:16.630 --> 00:20:19.810
There are many calendars out there
besides the Gregorian calendar and the

00:20:19.810 --> 00:20:21.800
Japanese calendar is just one of them.

00:20:21.930 --> 00:20:26.910
This is what the Japanese style date
would look like in the Japanese calendar.

00:20:28.710 --> 00:20:31.610
The digits in your date will
change as we saw earlier.

00:20:31.690 --> 00:20:35.830
This is what it would look
like in Devanagari in Hindi.

00:20:37.700 --> 00:20:43.040
The 12 versus 24 hour time
varies from locale to locale,

00:20:43.090 --> 00:20:48.770
so we want to present the
right time string for that.

00:20:49.350 --> 00:20:53.800
Finally, the order and the format
for dates will change.

00:20:53.800 --> 00:20:56.910
So in Vietnamese,
the time string comes first,

00:20:57.070 --> 00:21:00.590
and then the year, then the month,
then the day.

00:21:04.380 --> 00:21:09.380
So when we are working with dates,
we want to display dates in

00:21:09.380 --> 00:21:12.520
a locale-specific manner.

00:21:12.520 --> 00:21:15.110
And to do that, we use NSDateFormatter.

00:21:15.110 --> 00:21:18.240
Again,
NSDateFormatter has a convenience method

00:21:18.240 --> 00:21:20.720
called localized string from date.

00:21:20.810 --> 00:21:27.300
You can pass it in NSDate and the styles
for the date part and the time part.

00:21:27.300 --> 00:21:31.170
If you don't want to have the
date part or the time part,

00:21:31.170 --> 00:21:31.170
you can pass no style.

00:21:32.170 --> 00:21:36.580
And if you need to do more
complex applications such as

00:21:36.670 --> 00:21:41.080
parsing dates and times or setting
custom formats for your dates,

00:21:41.120 --> 00:21:45.660
then you can configure a date
formatter and maintain it.

00:21:47.640 --> 00:21:52.940
So here we see some of the
standard date and time formats.

00:21:52.940 --> 00:21:56.520
This goes from most abbreviated
to least abbreviated.

00:21:56.520 --> 00:21:59.900
And there's, of course,
the option for no style.

00:22:00.030 --> 00:22:04.710
So these will be localized appropriately
depending on the user's current locale.

00:22:06.000 --> 00:22:10.940
It may be the case that those built-in
formats don't meet your needs.

00:22:10.940 --> 00:22:14.870
Let's say maybe you have a very
constrained UI field and you want

00:22:14.870 --> 00:22:20.140
to just display the month and
the date of the current date.

00:22:20.230 --> 00:22:22.480
To do so,
we want to make sure that you are

00:22:22.480 --> 00:22:27.420
maintaining locale sensitivity and
not setting a constant pattern.

00:22:27.540 --> 00:22:32.060
So we have a built-in function
called Date Format from template,

00:22:32.120 --> 00:22:38.850
which will give you a properly
formatted string for the current locale.

00:22:40.240 --> 00:22:44.160
So in this example,
we're going to pass in

00:22:44.530 --> 00:22:48.150
the day and the month,
and we're going to get a format

00:22:48.150 --> 00:22:50.590
string for the user's current locale.

00:22:52.000 --> 00:22:57.290
And we're going to set the date formatter
to use this format string and then create

00:22:57.300 --> 00:23:00.920
a localized string from the current date.

00:23:01.750 --> 00:23:06.690
So now you can see this gives the right
result for both French and for Chinese.

00:23:06.770 --> 00:23:11.600
In French it places the day name,
the day first and then the month.

00:23:11.660 --> 00:23:18.820
And then for Chinese it
places the month digit,

00:23:18.820 --> 00:23:19.190
then the character for month,
and then the days,

00:23:19.190 --> 00:23:19.190
and then the character for day.

00:23:22.050 --> 00:23:25.190
Again,
using static formats is a way that you

00:23:25.190 --> 00:23:28.300
can get in trouble with these formatters.

00:23:28.300 --> 00:23:32.250
So in this example,
we're setting a custom format which

00:23:32.300 --> 00:23:37.500
puts the month and then the day and
then the year separated by hyphens.

00:23:37.500 --> 00:23:42.870
And that's just not going to
work for the majority of the

00:23:43.010 --> 00:23:46.170
formats out there in the world.

00:23:46.170 --> 00:23:47.080
So it will work for English but not for,
say, Chinese.

00:23:48.710 --> 00:23:52.830
Instead, we encourage you to use
localized string from date.

00:23:52.910 --> 00:23:57.260
There is an easy way to do
this using short style for the

00:23:57.270 --> 00:23:59.600
date and no style for the time.

00:23:59.640 --> 00:24:06.130
And then we get the right string in the
UI for both English and for Chinese.

00:24:08.790 --> 00:24:14.690
Now let's talk about a slightly
more complex example involving

00:24:14.690 --> 00:24:18.070
dates and get time zones involved.

00:24:18.070 --> 00:24:24.070
Let's say you're making an
application and it's pulling dates

00:24:24.070 --> 00:24:29.220
off of the web in a fixed format,
something like this,

00:24:29.240 --> 00:24:30.900
where year comes first, then the month,
then the day, and then hours,

00:24:30.900 --> 00:24:30.900
minutes and seconds.

00:24:31.330 --> 00:24:35.760
So we've got a date that we pulled
off the web and it has an inherent

00:24:35.880 --> 00:24:40.220
time zone associated with it,
in this case UTC.

00:24:40.340 --> 00:24:42.970
So this is roughly the current time.

00:24:44.380 --> 00:24:50.300
Now we've parsed that date and we want to
show it in the UI in a localized fashion.

00:24:50.470 --> 00:24:54.850
So we're going to display it
in the long style in the UI.

00:24:56.860 --> 00:25:01.230
Now, when we're using this
app in San Francisco,

00:25:01.300 --> 00:25:02.740
we've got the wrong time.

00:25:02.740 --> 00:25:04.360
It's not 5:46 right now.

00:25:04.400 --> 00:25:08.180
Also,
we're getting the wrong time in Beijing,

00:25:08.250 --> 00:25:11.720
where it is definitely not 5:46 either,
because there's a 15

00:25:11.720 --> 00:25:13.110
hour time difference.

00:25:13.220 --> 00:25:15.000
So what did we forget to do?

00:25:15.130 --> 00:25:21.720
What we need to do here is set the
time zone before we parse that date.

00:25:21.780 --> 00:25:25.570
That time zone was in the UTC format,
but we interpreted it

00:25:25.570 --> 00:25:27.170
as the local time zone.

00:25:27.250 --> 00:25:32.650
Instead, we wanna make sure that the date
formatter is using the UTC time zone,

00:25:32.700 --> 00:25:37.540
which you can get with time
zone for seconds from GMT-0.

00:25:37.620 --> 00:25:39.420
And then,

00:25:39.690 --> 00:25:42.800
We will get the right values
for the dates out and be able

00:25:42.800 --> 00:25:46.030
to localize them appropriately.

00:25:47.690 --> 00:25:52.220
Now there is still one thing
missing in this example,

00:25:52.320 --> 00:25:59.560
and it's a little more subtle,
but it'll come up when you are

00:25:59.560 --> 00:25:59.560
using a locale like Arabic.

00:25:59.660 --> 00:26:05.750
Now as we saw in a previous slide,
Arabic does not use ASCII digits

00:26:05.750 --> 00:26:08.770
for dates or times or numbers.

00:26:08.770 --> 00:26:11.840
It uses Arabic style digits.

00:26:11.840 --> 00:26:16.420
And so when we were parsing this string,
the date formatter was looking for those

00:26:16.420 --> 00:26:18.620
Arabic digits and it doesn't find them.

00:26:18.930 --> 00:26:22.740
So it's returning null.

00:26:22.740 --> 00:26:23.400
And of course,
that's not the right answer.

00:26:24.660 --> 00:26:28.500
This here is where we
want to use system locale.

00:26:28.500 --> 00:26:33.350
So system locale is going to be constant
across all of your user systems and it

00:26:33.520 --> 00:26:40.530
basically corresponds to POSIX settings
which allow you to parse and format

00:26:40.530 --> 00:26:44.640
dates in a numeric POSIX style format.

00:26:44.680 --> 00:26:48.930
So using system locale here will
override the user's current locale

00:26:48.930 --> 00:26:54.020
setting and make the date formatter
look for the ASCII digits and allow it

00:26:54.020 --> 00:26:58.960
to get the right value out so that we
can localize the string appropriately.

00:27:02.330 --> 00:27:05.480
So next, let's look at some calendars.

00:27:05.650 --> 00:27:08.400
As you're probably aware,
the Gregorian calendar is the

00:27:08.400 --> 00:27:13.230
standard calendar across most
of the countries of the world.

00:27:13.350 --> 00:27:16.440
However, there are countries that do
not use the Gregorian calendar,

00:27:16.440 --> 00:27:17.440
such as Thailand.

00:27:17.590 --> 00:27:22.080
And there are many calendars that
are in use for religious purposes,

00:27:22.080 --> 00:27:23.150
for example.

00:27:23.320 --> 00:27:27.990
So in the current Thai calendar,
the year is 2554.

00:27:28.910 --> 00:27:32.790
The era of your calendar may change.

00:27:32.830 --> 00:27:36.500
In the Japanese calendar,
the current era is Heisei

00:27:36.580 --> 00:27:40.570
and this corresponds to the
current emperor's reign.

00:27:42.250 --> 00:27:47.440
The number of months in a
year is sometimes variable.

00:27:47.440 --> 00:27:51.860
You may have 12 or you may have
13 in some learner calendars,

00:27:51.860 --> 00:27:54.230
or it could vary from year to year.

00:27:54.730 --> 00:27:56.890
And also the number of days in a month.

00:27:56.930 --> 00:28:00.630
So for example, in the Coptic calendar,
which is used in Egypt,

00:28:00.820 --> 00:28:06.260
there is a five-day month which picks up
the rest of the days from the other 12,

00:28:06.320 --> 00:28:10.740
30-day months,
which could be six months in a leap year.

00:28:10.910 --> 00:28:14.630
And of course, February changes in
the Gregorian calendar.

00:28:15.550 --> 00:28:21.190
The first day of the
week could be Saturday,

00:28:21.190 --> 00:28:21.190
Sunday,
or Monday depending on your calendar.

00:28:21.740 --> 00:28:26.620
And finally, not even the day on which
years change is static.

00:28:26.630 --> 00:28:30.960
For example, in the Japanese calendar,
whenever a new emperor is coronated,

00:28:30.960 --> 00:28:34.080
a new era and a new year begins.

00:28:34.320 --> 00:28:40.790
So the new era,
the Heisei era began on January 8th.

00:28:42.790 --> 00:28:48.000
So, in order to handle calendars in
a regionally appropriate way,

00:28:48.030 --> 00:28:49.520
we want to use NSCalendar.

00:28:49.520 --> 00:28:54.140
NSCalendar has all of these smarts baked
into it for handling all these calendars.

00:28:54.250 --> 00:28:57.950
It's going to be able to give you
information such as the number of

00:28:57.950 --> 00:29:00.640
days in a month and weeks in a year.

00:29:00.640 --> 00:29:04.910
It will also be able to break down a
date for you and give you the components

00:29:04.910 --> 00:29:09.500
like what is the current day of the
week or the current day of the year.

00:29:09.500 --> 00:29:11.820
And it's very handy for
doing delta computations.

00:29:11.820 --> 00:29:15.250
Let's say if you need to figure
out what the day is three days

00:29:15.250 --> 00:29:17.680
from now in the current calendar.

00:29:17.820 --> 00:29:22.310
Now, we had a talk about this at WWDC,
I believe, on Wednesday.

00:29:22.360 --> 00:29:26.050
If you didn't catch that one,
you can catch it in the video Slater.

00:29:26.060 --> 00:29:30.500
But there's some more details in
calendar processing at that talk.

00:29:31.020 --> 00:29:34.840
So for Lion, we support a number of
non-Gregorian calendars,

00:29:34.840 --> 00:29:40.490
including some lunar calendars like the
Islamic calendar and the Hebrew calendar.

00:29:41.260 --> 00:29:46.100
And for iOS 5,
we support Gregorian offset calendars.

00:29:46.110 --> 00:29:49.990
So this includes Thai, Buddhist,
and Japanese.

00:29:52.240 --> 00:29:54.700
Now our final stop on the
internationalization tour today

00:29:54.700 --> 00:29:57.220
will be strings and Unicode.

00:29:57.330 --> 00:30:02.530
All of the operations like sorting,
searching, and tokenization are very

00:30:02.530 --> 00:30:04.980
language and locale dependent.

00:30:05.070 --> 00:30:10.760
The behaviors of these functions are
going to depend on the user's current

00:30:10.760 --> 00:30:16.070
language and the language of the
text and the locale of the system.

00:30:16.070 --> 00:30:19.460
So we want to use NSString APIs to
handle strings in a locale sensitive way.

00:30:21.060 --> 00:30:24.590
Let's look at sorting
and comparison first.

00:30:24.770 --> 00:30:30.350
So, for English, it's true that you could
just order a string using the

00:30:30.350 --> 00:30:34.420
Unicode ordering of characters,
A through Z.

00:30:34.470 --> 00:30:36.070
That's not always the case, though.

00:30:36.160 --> 00:30:42.370
For example, in Hawaiian,
native Hawaiian letters sort

00:30:42.370 --> 00:30:42.370
before non-native letters.

00:30:43.430 --> 00:30:47.160
Also,
the significance of diacritics varies.

00:30:47.250 --> 00:30:50.110
So, for example, in German,
the letter U with a

00:30:50.110 --> 00:30:52.600
numlaut is sorted after Z.

00:30:52.930 --> 00:30:55.870
But in English, we wouldn't put it there,
we'd put it with U.

00:30:56.090 --> 00:30:59.070
So that's going to vary
from language to language.

00:30:59.840 --> 00:31:03.940
Also, sorting might use
language-specific knowledge.

00:31:04.060 --> 00:31:12.790
For example, in Chinese,
the pronunciation of characters

00:31:12.790 --> 00:31:12.790
or the stroke count of characters
can be used in sorting.

00:31:13.560 --> 00:31:17.240
So we definitely want to use
a sort which is localized,

00:31:17.270 --> 00:31:22.080
which is going to do the right thing
regardless of the user's current locale.

00:31:23.720 --> 00:31:29.300
So let's take a look at a
sorting example for Chinese.

00:31:29.300 --> 00:31:33.660
Now, as you can imagine,
it's very difficult in Chinese to

00:31:33.870 --> 00:31:38.600
find what you're looking for when
the characters are out of order.

00:31:38.640 --> 00:31:42.420
And when you use a standard
compare like seen here,

00:31:42.420 --> 00:31:47.220
the characters are going to be
sorted by the Unicode code point.

00:31:47.220 --> 00:31:47.790
And that's not going to
help your Chinese users find

00:31:47.790 --> 00:31:47.790
what they're looking for.

00:31:51.100 --> 00:31:55.900
Instead, we want to use localized
standard compare.

00:31:55.900 --> 00:32:00.700
This is a function that will
consider the collation ordering of

00:32:00.700 --> 00:32:03.600
the locale for the user in sorting.

00:32:03.800 --> 00:32:07.480
For the Chinese characters,
it's going to use the

00:32:07.480 --> 00:32:12.450
pinyin pronunciation,
which is the romanization of Chinese,

00:32:12.450 --> 00:32:15.780
and sort them alphabetically by pinyin.

00:32:15.810 --> 00:32:17.810
So now your users can find the
characters they're looking for.

00:32:19.860 --> 00:32:25.140
Some common errors in sorting
are using diacritics and case

00:32:25.200 --> 00:32:27.760
sensitivity when sorting.

00:32:27.820 --> 00:32:31.590
So this will get you into trouble
with languages such as French,

00:32:31.590 --> 00:32:38.280
where diacritic ordering is
a more complicated process.

00:32:38.280 --> 00:32:42.660
And some languages might sort
uppercase first and then lowercase.

00:32:42.760 --> 00:32:45.830
So in general,
we don't want to normalize case

00:32:46.040 --> 00:32:48.920
and diacritics when doing sorting.

00:32:48.930 --> 00:32:53.070
Those are operations that we
should reserve for doing searching.

00:32:54.690 --> 00:32:57.580
Let's talk about searching now.

00:32:57.680 --> 00:33:01.680
For searching,
we want to use range of string.

00:33:01.840 --> 00:33:10.790
Range of string is an API which will
allow you to search for substrings

00:33:10.790 --> 00:33:10.790
in a locale specific manner.

00:33:11.080 --> 00:33:16.570
The reason we would want to do that
is because in different languages,

00:33:16.570 --> 00:33:20.430
case and diacritics
comparisons will vary.

00:33:20.440 --> 00:33:25.280
So, for example, in Turkish,
what we consider the capital

00:33:25.430 --> 00:33:30.470
letter I when lowercased,
that is the dotless I in Turkish.

00:33:30.480 --> 00:33:36.230
And the lowercase I in English when
uppercased is a dotted capital I.

00:33:36.230 --> 00:33:40.210
So these kind of comparisons
are locale specific.

00:33:40.780 --> 00:33:45.910
Let's see what this would look like
doing a localized case-insensitive

00:33:45.910 --> 00:33:49.590
search for the string "iki" in Turkish.

00:33:49.990 --> 00:33:56.100
So we have a string and we want to
find the occurrence of "iki" in it.

00:33:56.820 --> 00:34:01.440
We're going to do a search
within the range of the string.

00:34:01.440 --> 00:34:04.300
And this search is going
to be case insensitive,

00:34:04.490 --> 00:34:08.810
but in a locale sensitive manner
using the user's current locale.

00:34:08.990 --> 00:34:17.110
So in a Turkish locale,
we will be able to find that

00:34:17.110 --> 00:34:17.110
capital I with a dot for IKI.

00:34:17.770 --> 00:34:22.580
Now if you're doing searching in your
app and you're writing an OS X app,

00:34:22.640 --> 00:34:26.090
you might be interested in taking
advantage of NS Text Finder,

00:34:26.190 --> 00:34:35.490
which is a new UI class in Lion,
which will give you that nice search

00:34:35.490 --> 00:34:35.490
call-out bar for searching in your app.

00:34:38.220 --> 00:34:42.280
Next,
I'd like to talk about tokenization.

00:34:42.400 --> 00:34:45.190
Now there are a number of
situations in which you would want

00:34:45.190 --> 00:34:47.100
to break up the text in your app.

00:34:47.530 --> 00:34:52.650
Maybe you'd want to enumerate your
text by lines or by paragraphs,

00:34:52.650 --> 00:34:55.550
possibly by sentences or words.

00:34:56.240 --> 00:34:59.240
Now, for words,
this is a very locale sensitive

00:34:59.240 --> 00:35:03.390
operation because of the different
writing systems out there that

00:35:03.390 --> 00:35:05.300
may or may not use spacing.

00:35:05.300 --> 00:35:10.730
Finally, there is the issue of iterating
through character sequences,

00:35:10.750 --> 00:35:13.200
which we will talk about here.

00:35:13.200 --> 00:35:18.870
We want to use this API for all
these different types of iteration,

00:35:18.970 --> 00:35:21.290
including characters.

00:35:23.280 --> 00:35:28.430
This is what it looks like,
enumerate substrings in range API.

00:35:28.550 --> 00:35:34.280
It is a block API so it takes the
range that you are going to search in,

00:35:34.390 --> 00:35:38.950
a enumeration option which
in this case is words,

00:35:39.140 --> 00:35:45.460
and a block which will process these
substrings in a sequential fashion.

00:35:45.510 --> 00:35:51.750
So here we are just going to log out the
substrings that we find in the string.

00:35:51.870 --> 00:35:56.340
For Chinese,
it will do the right thing even though

00:35:56.340 --> 00:35:58.390
Chinese is not written with spaces.

00:35:59.000 --> 00:36:02.400
And of course for English,
uses whitespace and

00:36:02.400 --> 00:36:04.530
punctuation tokenization.

00:36:06.910 --> 00:36:11.680
Now, it is important to not assume
that whitespace and punctuation

00:36:11.980 --> 00:36:16.530
are going to give you an adequate
segmentation for all kinds of text.

00:36:16.620 --> 00:36:19.530
Because as we saw,
Japanese and Chinese text

00:36:19.660 --> 00:36:21.540
don't use whitespace at all.

00:36:21.680 --> 00:36:25.750
So we actually need to do a
linguistic analysis of the text to

00:36:25.750 --> 00:36:28.160
analyze it for its word boundaries.

00:36:28.250 --> 00:36:31.860
And so enumerate_substr_and_range
will give you that information.

00:36:32.900 --> 00:36:35.800
For Thai,
whitespace separates phrases roughly,

00:36:35.800 --> 00:36:39.940
so that's not going to give you
the correct word boundaries either.

00:36:40.060 --> 00:36:43.500
So generally just stick with
enumerate_substr_and_range,

00:36:43.530 --> 00:36:45.960
and you'll get the right results.

00:36:48.130 --> 00:36:52.950
Now, I mentioned characters and that
you should be using enumerated

00:36:52.950 --> 00:36:55.700
substrings and range for characters.

00:36:55.710 --> 00:37:02.100
The reason for that is that not every
-- not every character in Unicode

00:37:02.100 --> 00:37:05.180
can be expressed as a single Unichar.

00:37:05.200 --> 00:37:10.560
It is not always the case that one user
visible glyph corresponds to one Unichar.

00:37:10.560 --> 00:37:14.600
So, for example,
the capital letter E with an accent can

00:37:14.600 --> 00:37:18.380
be stored as either one or two Unichars.

00:37:18.380 --> 00:37:21.790
You can store it as a capital
letter E with an acute,

00:37:21.860 --> 00:37:25.910
which is the combined form,
or a capital letter E plus

00:37:25.920 --> 00:37:28.510
the combining acute accent.

00:37:29.880 --> 00:37:34.500
It is true that there are methods
in Unicode to normalize a string.

00:37:34.500 --> 00:37:40.100
There's the canonical mapping which
will compose it as best as it can.

00:37:40.200 --> 00:37:44.910
This is not going to fix this
situation for us though because there

00:37:44.910 --> 00:37:50.080
are many situations in which there
are combining character sequences

00:37:50.080 --> 00:37:52.950
that have no pre-composed variants.

00:37:52.950 --> 00:37:56.590
For example,
in Vietnamese with tones and all the

00:37:56.630 --> 00:37:59.550
diacritics that are involved there.

00:37:59.790 --> 00:38:03.110
So, and also,
any character outside of the 16-bit

00:38:03.110 --> 00:38:08.910
range cannot be canonicalized.

00:38:08.910 --> 00:38:08.910
So we don't want to rely
on canonical mappings.

00:38:10.990 --> 00:38:15.030
Any character outside of the 16-bit
range is going to be stored as two

00:38:15.270 --> 00:38:18.230
surrogate pairs in your NSString.

00:38:18.320 --> 00:38:21.910
This is primarily used for
idiographic character extensions for

00:38:21.910 --> 00:38:26.320
Chinese and some historical scripts,
but these are important for Chinese,

00:38:26.320 --> 00:38:27.210
definitely.

00:38:27.430 --> 00:38:33.630
So, for example,
this Chinese character is

00:38:33.700 --> 00:38:35.470
beyond the 16-bit range,
U+272FE.

00:38:35.640 --> 00:38:40.300
and it is stored as
two unitars in memory.

00:38:40.340 --> 00:38:46.140
If we use a naive algorithm like
character at index to access

00:38:46.140 --> 00:38:51.760
the characters of this string
we are going to retrieve broken

00:38:51.760 --> 00:38:55.270
Unicode because these surrogate
pairs will not render correctly.

00:38:55.420 --> 00:38:59.450
So whenever we're working with
characters it's important to use

00:38:59.450 --> 00:39:04.010
enumerate substrings in range to access
those character ranges appropriately

00:39:04.250 --> 00:39:06.700
and to render the string appropriately.

00:39:09.090 --> 00:39:13.740
So now I'd like to talk about some
different UI topics that will come

00:39:13.840 --> 00:39:18.320
up when you're developing your app
and some different UIs that your

00:39:18.320 --> 00:39:20.950
international users will be using.

00:39:21.610 --> 00:39:24.420
First off, let's look at input methods.

00:39:24.530 --> 00:39:29.030
Now, for many alphabetic languages like
English and French and German,

00:39:29.120 --> 00:39:33.530
it's sufficient to just put all
the keys on the keyboard for all

00:39:33.530 --> 00:39:35.420
of the letters of the language.

00:39:35.490 --> 00:39:38.460
But when you have a language
like Chinese or Japanese that has

00:39:38.460 --> 00:39:42.160
tens of thousands of characters,
that's simply not possible.

00:39:42.280 --> 00:39:49.410
And so we use input methods to input
complex scripts to use a romanization,

00:39:49.410 --> 00:39:53.880
say, and turn that into the
appropriate characters.

00:39:54.270 --> 00:40:02.730
An input method may generate single
or multiple characters depending on

00:40:02.730 --> 00:40:02.730
the language of the input method.

00:40:03.670 --> 00:40:07.460
So for example,
here is what input looks like in Chinese.

00:40:07.690 --> 00:40:11.670
Now we have pinnion here,
which is the romanization of Chinese.

00:40:11.690 --> 00:40:15.160
And we are converting that
into Chinese characters.

00:40:15.160 --> 00:40:20.130
Now the pinnion here is in a
state which we call marked.

00:40:20.140 --> 00:40:24.140
It has the underline, meaning that it has
not been converted yet.

00:40:24.290 --> 00:40:29.580
So once the user has chosen a
candidate in that candidate bar,

00:40:29.610 --> 00:40:31.540
then it's going to be committed.

00:40:31.540 --> 00:40:34.160
It's going to be turned
into the Chinese text,

00:40:34.160 --> 00:40:37.450
and the marked text is replaced.

00:40:39.480 --> 00:40:45.130
So when you are working in UIs,
it's important to wait until the

00:40:45.130 --> 00:40:49.540
marked text has been committed
before you start to process the text.

00:40:49.640 --> 00:40:53.780
Because in this example,
the user is trying to search for the word

00:40:53.780 --> 00:40:58.840
"Apple." And they've written the pinion,
but they haven't converted it yet.

00:40:58.840 --> 00:41:01.810
So if you go off and start
searching on the pinion,

00:41:01.810 --> 00:41:04.040
it's not going to do the right thing.

00:41:04.130 --> 00:41:07.170
Instead,
wait until the candidate is converted,

00:41:07.170 --> 00:41:07.620
and then we can do the search.

00:41:08.860 --> 00:41:12.560
The way to do that is to identify
the marked text range and there's

00:41:12.560 --> 00:41:15.900
a couple of different ways to do
that depending on your platform.

00:41:16.000 --> 00:41:19.040
On iOS there's the
UI Text Input Protocol which

00:41:19.060 --> 00:41:21.280
gives you a marked text range.

00:41:21.370 --> 00:41:28.250
NS Text Input Client Protocol will
also give you has marked

00:41:28.250 --> 00:41:28.250
text and a marked range.

00:41:30.020 --> 00:41:33.100
And a couple of other things
to note about input methods.

00:41:33.160 --> 00:41:37.600
On iOS, we put the candidate
bar above the keyboard.

00:41:37.720 --> 00:41:42.390
So if your app has content behind there,
your app needs to be resilient

00:41:42.470 --> 00:41:46.640
to changes in the keyboard size
so that the candidate bar is not

00:41:46.670 --> 00:41:49.500
obscuring important information.

00:41:49.500 --> 00:41:54.300
On OS X, it's important to avoid
intercepting key events by,

00:41:54.300 --> 00:41:56.340
say, overwriting key down.

00:41:56.370 --> 00:42:00.900
There are ways to do this
on NSTextView that will

00:42:00.900 --> 00:42:02.090
not break input methods.

00:42:02.190 --> 00:42:07.190
So it's important not to intercept
those methods because input

00:42:07.190 --> 00:42:10.060
methods rely on space and enter.

00:42:12.500 --> 00:42:16.790
So let's take a look at how you
would bring up input methods.

00:42:16.800 --> 00:42:19.880
And I'm going to show you that on iOS.

00:42:20.800 --> 00:42:25.420
Okay, so here we have the general panel.

00:42:25.750 --> 00:42:30.140
This time I want to go into keyboards.

00:42:30.530 --> 00:42:35.640
And I'm going to turn on
some international keyboards.

00:42:35.800 --> 00:42:39.560
So if you've never added a new
keyboard to your iOS device,

00:42:39.560 --> 00:42:41.360
now's the time to learn.

00:42:41.510 --> 00:42:44.250
Let's say we want to
add the pinion keyboard.

00:42:44.270 --> 00:42:52.350
Now if I go into notes,

00:42:57.100 --> 00:42:59.800
Let's bring that back down.

00:42:59.800 --> 00:43:03.240
Now you see a new glow
button has come up.

00:43:03.240 --> 00:43:07.650
And this is going to allow us to
change between different keyboards.

00:43:09.780 --> 00:43:14.000
And so now we have the Chinese pinyin
keyboard up and the candidate

00:43:14.000 --> 00:43:17.500
bar appears above the keyboard.

00:43:17.760 --> 00:43:25.370
So when I type Chinese in pinyin,
we have the candidates showing up.

00:43:27.740 --> 00:43:32.870
And there's a variety of different
interactions with that candidate bar.

00:43:33.050 --> 00:43:41.740
So it's good when developing your
app just to check that the candidate

00:43:41.740 --> 00:43:45.190
bar is working properly in your app
and that your app's content is not

00:43:45.190 --> 00:43:45.190
obscured and that sort of thing.

00:43:45.370 --> 00:43:51.290
You can also use this to try
inputting Chinese text and

00:43:51.330 --> 00:43:51.910
test your app with Chinese.

00:43:52.420 --> 00:43:56.380
So now I converted and
that's Chinese text input.

00:43:56.450 --> 00:44:02.780
Okay, so a couple more topics around
international user interfaces.

00:44:02.960 --> 00:44:06.320
First off, let's look at text layout.

00:44:06.360 --> 00:44:10.350
Now if you're handling
Arabic and Hebrew text,

00:44:10.430 --> 00:44:15.110
Arabic and Hebrew are traditionally
written from right to left.

00:44:15.280 --> 00:44:20.240
So these scripts can also have
left to right embeddings and the

00:44:20.590 --> 00:44:27.000
order and directionality of the
text can get somewhat complicated.

00:44:27.120 --> 00:44:31.010
So here I see this is what it
would look like on the screen.

00:44:31.210 --> 00:44:34.090
Let's see what it would
look like in memory.

00:44:34.430 --> 00:44:44.730
The first word of this sentence is on
the right and it flips around so that the

00:44:44.730 --> 00:44:44.730
first character was actually on the left.

00:44:58.090 --> 00:44:58.090
So, for the Latin text,
that comes in left to right.

00:44:58.090 --> 00:44:58.090
So, that alignment is different
from the Arabic text.

00:45:00.150 --> 00:45:04.870
So as you can see in this example,
the text that is visually adjacent

00:45:04.960 --> 00:45:08.790
on the screen is not actually
always logically adjacent in memory.

00:45:08.880 --> 00:45:12.820
You can have directionality
shifts in the middle of the text.

00:45:12.840 --> 00:45:16.620
So if you are working on a text
view and you want to handle

00:45:16.620 --> 00:45:21.190
bidirectional text appropriately,
it's important to not make

00:45:21.190 --> 00:45:25.810
assumptions about the directionality
or the alignment of text.

00:45:25.820 --> 00:45:28.640
Text needs to have its natural alignment.

00:45:28.720 --> 00:45:34.070
So you can do this by setting the
NS paragraph style to natural alignment,

00:45:34.070 --> 00:45:38.760
and that will make sure that the
text is right aligned for Arabic and

00:45:38.880 --> 00:45:43.440
Hebrew and left aligned for
Latin languages and other scripts.

00:45:43.440 --> 00:45:47.180
And there's also UI text input
protocol set base writing direction,

00:45:47.180 --> 00:45:51.930
which will help you handle the
bidirectional text appropriately.

00:45:53.350 --> 00:45:59.690
Along the lines of text layout,
new in Lion, we now have vertical text,

00:45:59.690 --> 00:46:02.650
which is very popular in Japan.

00:46:02.650 --> 00:46:07.740
It's a very traditional way
of writing Japanese text.

00:46:07.900 --> 00:46:14.350
So you can now edit and display text in
a vertical fashion in your Cocoa apps.

00:46:14.710 --> 00:46:20.990
And this is accomplished by setting the
layout orientation on your text view

00:46:21.230 --> 00:46:23.900
to NS Text Layout Orientation Vertical.

00:46:24.000 --> 00:46:27.840
The substitutions of the vertical
glyphs will happen by default.

00:46:28.050 --> 00:46:32.640
It'll handle all the font
changes and all that for you.

00:46:32.920 --> 00:46:37.640
And you want to use a horizontal
iBeam cursor in these scenarios

00:46:37.640 --> 00:46:40.920
to match the style of the input.

00:46:42.760 --> 00:46:46.800
And the final new feature is emoji.

00:46:46.990 --> 00:46:51.480
So we now have these in
both iOS and in Lion.

00:46:51.580 --> 00:46:54.830
Previously emoji were only
available in Japan before

00:46:55.010 --> 00:46:58.730
standardization into Unicode,
but now these are in Unicode.

00:46:58.940 --> 00:47:00.550
So you can use them.

00:47:00.560 --> 00:47:04.650
We have an emoji font
on both iOS and Lion.

00:47:04.760 --> 00:47:10.650
And these characters are all in the
supplementary multilingual plane,

00:47:10.770 --> 00:47:14.400
meaning they are beyond the
16-bit range of Unicode.

00:47:14.610 --> 00:47:20.160
So all of those -- the comments about
Chinese characters and iterating

00:47:20.160 --> 00:47:24.480
through characters with ranges
definitely apply to emoji here.

00:47:24.620 --> 00:47:30.110
So for more details on emoji,
please see the Unicode 6.0 specification,

00:47:30.110 --> 00:47:33.250
and that will give you all
the information you need.

00:47:35.330 --> 00:47:39.700
To wrap up today,
the important message is even

00:47:39.700 --> 00:47:42.950
if you don't remember all the
particular examples of all the

00:47:42.950 --> 00:47:48.240
different formats out there,
the key is to use foundation APIs and

00:47:48.240 --> 00:47:51.470
use the standard UI widgets and
they're going to do the right thing

00:47:51.470 --> 00:47:54.160
for you in a locale-sensitive manner.

00:47:54.330 --> 00:47:59.550
Test your app in situations
that expose different languages,

00:47:59.550 --> 00:48:03.520
different locales,
and make sure that your UI is

00:48:03.520 --> 00:48:05.660
rendering appropriately.

00:48:05.710 --> 00:48:09.980
If you're using the built-in foundation
APIs and the built-in widgets,

00:48:09.980 --> 00:48:13.050
then things are going to
work properly for you.

00:48:15.600 --> 00:48:18.110
So with that,
I'd like to refer you to some

00:48:18.230 --> 00:48:19.990
of these related sessions.

00:48:20.300 --> 00:48:26.740
These have all actually passed already,
but you can catch them on the videos.

00:48:26.850 --> 00:48:29.190
So thank you very much.
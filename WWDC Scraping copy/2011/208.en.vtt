WEBVTT

00:00:12.830 --> 00:00:13.800
Good morning everybody.

00:00:13.850 --> 00:00:14.600
Thanks for coming.

00:00:14.610 --> 00:00:17.290
I'm glad to see such a
full room at 9:00 AM.

00:00:17.290 --> 00:00:19.750
That's actually encouraging.

00:00:20.080 --> 00:00:21.800
This is session 208.

00:00:21.870 --> 00:00:24.600
Andrew, Michael and I are going to
be talking to you today about

00:00:24.600 --> 00:00:26.300
securing iOS applications.

00:00:26.350 --> 00:00:29.710
And to be a little bit more specific,
we're going to talk about how to

00:00:29.720 --> 00:00:32.820
protect the user's data at rest
on the device as well as when you

00:00:32.860 --> 00:00:34.750
transmit it across the network.

00:00:34.900 --> 00:02:20.000
[Transcript missing]

00:02:20.490 --> 00:02:25.840
The application we have for you today
to demonstrate is called Oversharing.

00:02:25.890 --> 00:02:28.430
It's basically a simple
device-to-device photo sharing app.

00:02:28.550 --> 00:02:30.510
We didn't try to make any UI demos.

00:02:30.510 --> 00:02:33.330
This is really focusing
on the crypto below it.

00:02:33.500 --> 00:02:36.850
What basically happens is these
devices will be able to discover

00:02:36.850 --> 00:02:39.890
each other using Bonjour,
tell each other, "Hey,

00:02:39.890 --> 00:02:42.330
I'm interested to see your
pictures." Then any time the

00:02:42.380 --> 00:02:45.520
other device that takes a picture,
it sends it back to the

00:02:45.560 --> 00:02:48.790
requesting device and says,
"Here's another picture for

00:02:48.790 --> 00:02:51.580
you." The source code is not
available on the website,

00:02:51.580 --> 00:02:53.400
but we will take it with us to the lab.

00:02:53.400 --> 00:02:59.390
We'll skim the surface and talk about the
high-level calls that you'll be making.

00:02:59.530 --> 00:03:01.670
There are, of course,
a lot of details that come into

00:03:01.670 --> 00:03:03.400
place to make the application work.

00:03:03.400 --> 00:03:05.400
If you're really curious
to see how that works,

00:03:05.400 --> 00:03:06.400
please meet us at the Security Lab.

00:03:06.400 --> 00:03:09.400
That will actually be
right after our session.

00:03:09.700 --> 00:03:13.080
Another thing to ask is
we will be using Wi-Fi.

00:03:13.420 --> 00:03:16.550
If anyone brought a Wi-Fi base
station with them and it's

00:03:16.550 --> 00:03:19.360
sitting right in the front row,
you could turn it off.

00:03:19.510 --> 00:03:23.400
That would make it probably
better for us than the demo gods.

00:03:23.560 --> 00:03:26.190
We'll hope that it all pulls through.

00:03:26.660 --> 00:03:28.600
So why would you secure this app?

00:03:28.600 --> 00:03:30.560
I mean, you could say, like, well,
it's just a fun app, right?

00:03:30.620 --> 00:03:32.480
I'm just using it to share some pictures.

00:03:32.650 --> 00:03:36.450
But after you send your app into the
world and a customer downloads it,

00:03:36.520 --> 00:03:38.800
of course, there may be other things
that they do with it.

00:03:38.900 --> 00:03:42.310
They may potentially take
an embarrassing picture.

00:03:42.420 --> 00:03:45.560
If they take an embarrassing picture,
well, you know,

00:03:45.610 --> 00:03:50.600
they're in for a bad surprise if it
turns out that their picture can be,

00:03:50.600 --> 00:03:54.000
you know, caught in midair or basically
pulled from their device.

00:03:54.010 --> 00:03:58.210
So you have to kind of assume that a user
may use your application for any purpose

00:03:58.250 --> 00:04:02.380
necessary and that they may actually
care for you to protect their data.

00:04:02.420 --> 00:04:05.090
And as we'll see today,
the steps necessary are

00:04:05.090 --> 00:04:07.970
really not that hard,
or at least that is what we'll

00:04:07.970 --> 00:04:09.990
try to convince you of today.

00:04:10.530 --> 00:04:14.400
So, the threats that happen are
a little scary and abstract.

00:04:14.550 --> 00:04:17.770
So, when we talk about brute
force and man in the middle,

00:04:17.770 --> 00:04:21.000
you've all also seen those in the
news and you may have thought like,

00:04:21.130 --> 00:04:25.600
well, you know, yeah, it's bad,
but I don't really know what it means.

00:04:25.980 --> 00:04:29.000
That's another thing that we want to try
to show you a little bit more up close,

00:04:29.060 --> 00:04:30.980
that these attacks are fairly practical.

00:04:31.720 --> 00:04:34.010
And besides that,

00:04:35.150 --> 00:04:40.300
These threads are real because, well,
you've potentially lost track of

00:04:40.300 --> 00:04:43.570
your device and had to call it
and then retrieved it from the

00:04:43.570 --> 00:04:45.610
couch and suddenly it's like,
oh, okay, there it is.

00:04:45.640 --> 00:04:48.090
But you had that moment of, oops,
where is it?

00:04:48.200 --> 00:04:51.070
Well, another thing that may happen
is you may know someone that

00:04:51.070 --> 00:04:52.280
lost it at a conference.

00:04:52.340 --> 00:04:53.380
Could happen.

00:04:53.380 --> 00:04:57.740
So it can be out of your control for a
while and someone can go ahead and do

00:04:57.740 --> 00:05:00.550
everything that we'll show to you today.

00:05:01.880 --> 00:05:04.780
So lastly,
your device is networked and it will

00:05:04.780 --> 00:05:09.110
really get all of its data and send
all of its data over the network.

00:05:09.200 --> 00:05:11.380
There is really no other way
to go and there is no such

00:05:11.380 --> 00:05:12.710
thing as a secure network.

00:05:12.790 --> 00:05:13.600
There really isn't.

00:05:13.700 --> 00:05:16.170
You can have a secure
transmission across a network,

00:05:16.170 --> 00:05:18.480
but networks themselves
cannot be trusted.

00:05:21.040 --> 00:05:22.970
So how can our APIs help you?

00:05:23.020 --> 00:05:26.440
We're going to do this
in three large sections.

00:05:26.450 --> 00:05:29.800
I will start covering the
securing of network connections,

00:05:29.830 --> 00:05:33.050
which is pretty much the securing
of transmissions across a network.

00:05:33.330 --> 00:05:36.130
Then we'll talk about protecting data.

00:05:36.380 --> 00:05:40.150
This is protecting of data on the device,
so pictures that you've

00:05:40.150 --> 00:05:41.790
taken and stored locally.

00:05:42.030 --> 00:05:43.380
As well as protecting secrets.

00:05:43.400 --> 00:05:46.640
And secrets generally are credentials
that you may actually use to retrieve

00:05:46.670 --> 00:05:49.300
additional data from the network
and you may cache it on the device.

00:05:49.320 --> 00:05:52.900
But those secrets actually protect
the data that the device pulled

00:05:52.920 --> 00:05:56.580
off of the network and they're
equally as important to protect.

00:05:56.900 --> 00:07:38.900
[Transcript missing]

00:07:39.310 --> 00:07:42.200
So let's talk about our
application for a moment.

00:07:42.200 --> 00:07:45.150
Our application is going to
work in the following way.

00:07:45.420 --> 00:07:48.990
One device is going to send an
HTTP GET request to another device that

00:07:49.040 --> 00:07:51.240
it sees on the network using Bonjure.

00:07:51.300 --> 00:07:55.460
And then as soon as that other device
has acknowledged this other device,

00:07:55.550 --> 00:07:58.600
it can send back via a post.

00:07:58.600 --> 00:08:01.300
It will actually start publishing
pictures back to the device

00:08:01.330 --> 00:08:04.050
that requested the pictures,
and it can do so continuously.

00:08:04.060 --> 00:08:08.440
So it will basically push its pictures
out to the person that asked about them.

00:08:09.160 --> 00:08:11.670
So how do we do this
using the high-level API?

00:08:11.800 --> 00:08:13.500
First, the GET request.

00:08:13.510 --> 00:08:15.040
You start with the URL.

00:08:15.040 --> 00:08:17.100
The URL here is already prefabricated.

00:08:17.100 --> 00:08:19.200
Of course, in our application,
we will need to fill in

00:08:19.430 --> 00:08:20.540
which device that is.

00:08:20.540 --> 00:08:23.010
So the address that we
put in here is fictitious.

00:08:23.170 --> 00:08:26.900
We are going to basically do a Bonjur
lookup and insert that host in there.

00:08:27.980 --> 00:08:30.430
Then we are going to
create an NSURL request.

00:08:30.700 --> 00:08:33.050
And to create an NSURL request,
which holds all the state

00:08:33.050 --> 00:08:35.120
around this request,
you first need an NSURL.

00:08:35.200 --> 00:08:37.340
But an NSURL is easily
created from the string.

00:08:37.340 --> 00:08:41.160
And then we have our NSURL request.

00:08:41.160 --> 00:08:43.950
Now, at this point, you have the request.

00:08:44.060 --> 00:08:46.760
And the way that you
can manage this thing,

00:08:46.810 --> 00:08:50.470
there is an NSURL connection,
which is kind of a manager

00:08:50.530 --> 00:08:52.260
for the request object.

00:08:52.260 --> 00:08:55.730
You hand it to this NSURL connection,
and it takes it through the paces.

00:08:55.730 --> 00:08:57.870
It goes through all the various
steps that are required.

00:08:57.940 --> 00:09:01.510
And as it does,
it is specified a delegate,

00:09:01.510 --> 00:09:03.650
which is your controller.

00:09:04.100 --> 00:09:07.270
And your controller can then
basically implement the protocol

00:09:07.700 --> 00:09:09.780
called the NSURL connection delegate.

00:09:09.780 --> 00:09:15.000
And so that sounds potentially difficult,
but really what it does is it implements

00:09:15.000 --> 00:09:17.760
very simple calls like did receive data.

00:09:17.760 --> 00:09:22.400
Whenever this request has been run,
data comes back to the device.

00:09:22.400 --> 00:09:24.800
The callback will be called,
or the delegate will be

00:09:24.810 --> 00:09:27.910
invoked on your controller,
and it will present you with the data.

00:09:27.940 --> 00:09:31.100
Or if something goes wrong,
there is of course the failure

00:09:31.100 --> 00:09:34.940
message as well to let you know like
this request didn't go anywhere,

00:09:34.940 --> 00:09:36.430
and that will of course be the end of it.

00:09:36.440 --> 00:09:38.930
There are additional methods
that we'll get to later,

00:09:38.970 --> 00:09:41.100
but let's continue with the POST request.

00:09:41.100 --> 00:09:43.180
The POST request is very similar.

00:09:43.180 --> 00:09:46.960
We start again with a URL.

00:09:46.960 --> 00:09:50.360
We turn it into a mutable URL request,
because this time we

00:09:50.480 --> 00:09:52.080
don't want a GET request.

00:09:52.080 --> 00:09:54.230
We actually want to
POST data to the other side.

00:09:54.260 --> 00:09:57.700
So after we've created the request,
we need to make a couple modifications.

00:09:57.940 --> 00:10:00.100
One of them being, this is a POST.

00:10:00.210 --> 00:10:02.400
We're actually pushing
data out to the other side,

00:10:02.400 --> 00:10:05.680
and we're setting the image
data up as the HTTP body to

00:10:05.700 --> 00:10:06.890
present it to the other side.

00:10:06.970 --> 00:10:10.410
So the picture that we've taken,
we convert it into data,

00:10:10.700 --> 00:10:12.940
set it as the body, and then send it.

00:10:12.940 --> 00:10:16.420
So with that,
I'd like to invite my colleagues

00:10:16.550 --> 00:10:20.320
Andrew and Michael on stage
so that we can demo to you

00:10:20.320 --> 00:10:22.850
how this app basically works.

00:10:28.900 --> 00:10:32.900
I will be using the
iPad that is tethered,

00:10:32.900 --> 00:10:38.100
so I will be tethered to my booth here
a little bit and Michael will go out.

00:10:38.110 --> 00:10:41.440
So let's see if we can, yep,
there's my application.

00:10:41.440 --> 00:10:43.500
We're going to connect to each other.

00:10:43.500 --> 00:10:46.420
I'm going to go around and look
and there's Michael's iPad,

00:10:46.420 --> 00:10:47.240
so I connect to him.

00:10:47.390 --> 00:10:48.840
He's going to do the same.

00:10:48.840 --> 00:10:49.860
He may have already connected to me.

00:10:50.010 --> 00:10:51.200
I'm set.

00:10:51.200 --> 00:10:54.880
And so what we can do now is
ask him to take a picture.

00:10:58.260 --> 00:11:01.140
I told them not to take pictures of me.

00:11:01.230 --> 00:11:02.200
And there's a picture.

00:11:02.220 --> 00:11:05.080
Alright, so we can do this the
other way around as well.

00:11:05.080 --> 00:11:07.600
Let's take a picture of the
audience because I was playing.

00:11:08.300 --> 00:11:23.700
[Transcript missing]

00:11:30.000 --> 00:11:30.920
That was the picture you sent?

00:11:31.070 --> 00:11:32.000
Yep.

00:11:32.000 --> 00:11:32.970
Oh, that was a different one.

00:11:33.000 --> 00:11:34.000
Okay.

00:11:34.030 --> 00:11:34.970
One last one?

00:11:35.000 --> 00:11:36.000
Sure.

00:11:44.520 --> 00:11:46.700
So, with that,
I want to turn it over quickly to

00:11:46.710 --> 00:11:50.180
Andrew to let us know how we are doing.

00:11:50.230 --> 00:11:53.910
So, I'm fascinated about what these
two gentlemen are sharing,

00:11:53.910 --> 00:11:56.820
and I really want to get
my hands on those images.

00:11:56.850 --> 00:12:02.610
So, I've been in the coffee shop,
these two gentlemen are sharing images,

00:12:02.610 --> 00:12:06.460
and I've got my own setup on
the same wireless network.

00:12:06.480 --> 00:12:10.060
Or I could be another colleague
wanting to snoop on this,

00:12:10.060 --> 00:12:13.060
or just driven to evil intent
by the prospect of doing a

00:12:13.060 --> 00:12:14.980
live demo with packet capture.

00:12:15.030 --> 00:12:19.110
So, I walk over to my device,
and we've got some images that I've

00:12:19.140 --> 00:12:21.700
just pulled straight off the wire.

00:12:21.750 --> 00:12:24.940
This was done very easily,
I didn't actually write

00:12:25.230 --> 00:12:29.640
any custom code myself,
simply a script which

00:12:29.780 --> 00:12:32.860
recombines TCP flows,
dumps out to a file,

00:12:32.900 --> 00:12:35.900
strip off the HTTP header,
run it through the file command.

00:12:35.940 --> 00:12:36.920
Is it a... JPEG?

00:12:37.100 --> 00:12:37.830
Yes.

00:12:38.010 --> 00:12:40.260
Rename it, let Finder do the rest.

00:12:40.320 --> 00:12:41.400
Very simple.

00:12:41.400 --> 00:12:45.690
It doesn't require a huge
amount of technology to

00:12:45.700 --> 00:12:48.690
perform an attack such as this.

00:12:49.640 --> 00:12:53.320
So I am seeing that maybe
there's nothing interesting

00:12:53.320 --> 00:12:57.120
being sent over at the moment,
but if I wait a bit, maybe I'll get some

00:12:57.120 --> 00:12:58.940
of those juicy images.

00:13:00.950 --> 00:13:03.640
So that was our first demo.

00:13:03.770 --> 00:13:06.130
This was for most of
you probably obvious,

00:13:06.130 --> 00:13:09.670
we're sending data across the network,
but at least now you saw that it's

00:13:09.670 --> 00:13:11.930
actually not that hard to intercept.

00:13:12.110 --> 00:13:14.330
So what happened?

00:13:14.340 --> 00:13:17.060
We connected to each other,
we didn't use a secured connection,

00:13:17.060 --> 00:13:18.580
and the network is
kind of like this room.

00:13:18.740 --> 00:13:21.340
Anyone who has a conversation,
anyone else can overhear it.

00:13:21.380 --> 00:13:24.300
And in this case,
Andrew was right there to pick them up.

00:13:24.370 --> 00:13:27.000
You noticed some of the pictures
were like a little choppy,

00:13:27.030 --> 00:13:29.680
but of course that has everything
to do with how you make the

00:13:29.740 --> 00:13:30.900
packet capture reliable.

00:13:30.900 --> 00:13:35.600
And I'm pretty sure that there's people
in this room that can do better than we.

00:13:35.720 --> 00:13:37.740
So how are we going to improve this?

00:13:37.740 --> 00:13:39.340
Well on the client side,
this is really simple.

00:13:39.340 --> 00:13:40.480
I already kind of hinted at it.

00:13:40.560 --> 00:13:44.550
If we use HTTPS,
this high level request will go

00:13:44.550 --> 00:13:47.740
down and use secure transport
to make an SSL connection.

00:13:47.880 --> 00:13:50.700
So on the client side,
it's one letter change.

00:13:50.930 --> 00:13:51.160
Great.

00:13:51.410 --> 00:13:54.320
But let's talk about the server for
a moment because as you realize,

00:13:54.320 --> 00:13:57.330
these applications of course have
to also implement the server.

00:13:57.410 --> 00:14:00.900
So for that, we're going to quickly
discuss secure transport.

00:14:01.040 --> 00:14:03.530
Now to set up secure transport,
there's first some setup

00:14:03.550 --> 00:14:04.930
steps that are necessary.

00:14:05.060 --> 00:14:08.540
There is a SSL new context that
creates the object that holds all

00:14:08.540 --> 00:14:10.660
the state for an SSL connection.

00:14:10.790 --> 00:14:13.230
After that,
there are the callbacks that are needed.

00:14:13.440 --> 00:14:16.300
The callbacks whenever we want
to send out some data over the

00:14:16.300 --> 00:14:19.160
network or if we want to actually
get some data from the peer to see

00:14:19.160 --> 00:14:20.660
whether they send us some data.

00:14:20.810 --> 00:14:25.650
That is the SSL set IO functions and
it will have a couple of callbacks.

00:14:25.660 --> 00:14:27.630
I refer to the sample code
if you want to see how those

00:14:27.630 --> 00:14:29.020
callbacks are supposed to work.

00:14:29.180 --> 00:14:34.810
They have some... detail necessary
to them to understand how they work.

00:14:34.900 --> 00:14:37.350
Of course, you may already know from
the desktop how they work,

00:14:37.700 --> 00:14:40.580
but the application will
illustrate that more closely.

00:14:40.650 --> 00:14:43.320
Of course, just having these callbacks,
you may want to reuse them

00:14:43.320 --> 00:14:44.620
for multiple connections.

00:14:44.620 --> 00:14:48.280
So there is also an SSL set connection
that allows you to set a context

00:14:48.680 --> 00:14:50.620
object for this particular connection.

00:14:50.620 --> 00:14:52.790
So that any time your
callbacks are invoked,

00:14:52.790 --> 00:14:56.420
you will be told this is the exact
connection that we're talking about.

00:14:56.420 --> 00:14:59.450
It's just a void star,
but you can basically cast it to whatever

00:14:59.450 --> 00:15:00.820
you want under the covers to go over.

00:15:00.820 --> 00:15:02.780
So that you can go find
all your state again.

00:15:02.780 --> 00:15:04.780
And finally,
we need to set up the certificates.

00:15:04.870 --> 00:15:08.780
We're going to deal with
that a little later.

00:15:08.780 --> 00:15:14.780
After you've set up the connection,
it pretty much works like any file would.

00:15:14.780 --> 00:15:18.710
It's basically an open
read/write close cycle.

00:15:18.840 --> 00:15:23.660
SSL Handshake will go ahead and set up
the secure connection after it's done,

00:15:23.850 --> 00:15:25.780
which may take a couple of steps.

00:15:25.780 --> 00:15:30.780
You can call SSL read,
which will read the unencrypted

00:15:30.780 --> 00:15:30.780
data from the other side.

00:15:30.780 --> 00:15:34.590
And SSL write to send data to your peer.

00:15:34.770 --> 00:15:36.840
And finally,
you can call SSL close again to say,

00:15:36.840 --> 00:15:38.730
like, okay, finish up the connection.

00:15:38.770 --> 00:15:41.740
That will only finish up the
secure part of the connection.

00:15:41.740 --> 00:15:44.360
The network connection, of course,
continues to be open to

00:15:44.470 --> 00:15:45.670
send more data across it.

00:15:45.840 --> 00:15:50.370
So this will only shut down the
secure part of the connection.

00:15:51.350 --> 00:15:55.360
So, I skipped certificates,
and most of you may say, like, well,

00:15:55.360 --> 00:15:57.680
you know, certificates is difficult,
I don't want to deal with this,

00:15:57.680 --> 00:15:59.270
but it's actually relatively easy.

00:15:59.290 --> 00:16:02.970
But if you skip certificates,
you may find, like, hey, yeah,

00:16:02.970 --> 00:16:04.000
I can do that.

00:16:04.060 --> 00:16:06.080
I can use this one cipher suite here.

00:16:06.080 --> 00:16:08.810
It doesn't require me
to set up a certificate.

00:16:08.840 --> 00:16:11.310
And so,
our example here is an example that

00:16:11.380 --> 00:16:15.910
uses a Diffie-Hellman key exchange,
which is secure between two peers.

00:16:15.940 --> 00:16:19.040
The two peers will share the
same secret at the end of it,

00:16:19.040 --> 00:16:20.220
and nothing else.

00:16:20.870 --> 00:16:26.120
Then you get the AES encryption
in CBC mode with 256-bit keys.

00:16:26.120 --> 00:16:28.060
That seems rather hard to brute force.

00:16:28.060 --> 00:16:30.420
And, of course,
all your packets are protected

00:16:30.420 --> 00:16:31.850
by an HMAC using SHA-1.

00:16:31.860 --> 00:16:35.610
So, anything that's modified uses yet
another key to make sure that you

00:16:35.610 --> 00:16:37.620
can detect these modifications.

00:16:41.030 --> 00:16:44.680
This is of course encrypted,
but it's not secure.

00:16:44.750 --> 00:16:47.990
If we make this connection,
say Michael makes the connection to me,

00:16:48.010 --> 00:16:52.550
as shown here, we know that there is a
connection between the two of us,

00:16:52.550 --> 00:16:55.840
and when we send data across,
no one else can really easily see it.

00:16:55.940 --> 00:16:57.960
They see a bunch of
encrypted data flying across.

00:16:58.000 --> 00:16:59.840
But why is it not secure?

00:17:00.030 --> 00:17:06.000
Well, imagine that Andrew switches from a
passive attack to a more active attack.

00:17:06.000 --> 00:17:09.270
Now,
whether he does this by faking Michael's

00:17:09.340 --> 00:17:13.090
endpoint so that I accidentally
connect to the wrong IP address,

00:17:13.090 --> 00:17:16.150
or whether he does this by
having an entire environment up,

00:17:16.150 --> 00:17:20.100
like say this rogue base station
of his that we're sitting on,

00:17:20.180 --> 00:17:22.890
and he manages in such a way
that basically he can put himself

00:17:22.890 --> 00:17:25.260
perfectly in the middle of us,
what will happen is

00:17:25.290 --> 00:17:26.940
Michael will connect to Andrew,
and he will be able to connect to Andrew.

00:17:28.000 --> 00:17:29.570
He'll do this
Diffie-Hellman key exchange.

00:17:29.700 --> 00:17:31.900
He has a secure connection
between him and Andrew.

00:17:31.900 --> 00:17:33.330
He doesn't know that it's Andrew.

00:17:33.410 --> 00:17:35.700
Andrew goes ahead and
makes a connection to me.

00:17:35.730 --> 00:17:37.400
I don't know who's in the other end.

00:17:37.410 --> 00:17:39.800
And if Michael sends a picture,
I see the picture.

00:17:39.820 --> 00:17:43.240
So what has happened now is like
Michael and I are none the wiser.

00:17:43.500 --> 00:17:44.940
We have the connection set up.

00:17:44.940 --> 00:17:48.000
We know that it's secured,
but Andrew is still seeing the pictures.

00:17:48.000 --> 00:17:50.630
That was not what we set out to do.

00:17:51.400 --> 00:17:53.840
Certificate Authentication.

00:17:53.840 --> 00:17:55.850
We're going to go back to that
because it's actually relatively

00:17:55.850 --> 00:17:59.780
easy and that way we can stay
within the realm of HTTPS.

00:17:59.920 --> 00:18:03.740
You can of course implement your
own zero-knowledge protocol over an

00:18:03.740 --> 00:18:08.750
anonymous Diffie-Hellman connection,
but again, let's show you how to do that

00:18:08.750 --> 00:18:11.620
easier and just stick with TLS.

00:18:11.720 --> 00:18:14.870
For Certificate Authentication,
we're going to use asymmetric

00:18:14.870 --> 00:18:17.760
cryptography and it's going
to use an asymmetric key.

00:18:17.870 --> 00:18:21.300
An asymmetric key is
different from a normal key.

00:18:21.360 --> 00:18:23.800
In normal crypto, you use one key,
you encrypt a bunch of data,

00:18:23.800 --> 00:18:25.980
you get ciphertext,
you use that same key,

00:18:25.990 --> 00:18:28.360
you decrypt it again,
and there's the plaintext again.

00:18:28.470 --> 00:18:31.120
With asymmetric cryptography,
you have a key pair.

00:18:31.130 --> 00:18:35.420
There's a related key, two related keys,
there's a public key,

00:18:35.420 --> 00:18:36.400
and there's a private key.

00:18:36.400 --> 00:18:38.740
The public key you can
actually feel free to share,

00:18:38.740 --> 00:18:40.320
it's actually part of how it works.

00:18:40.580 --> 00:18:43.260
And there's a private key
that you must keep secret.

00:18:43.300 --> 00:18:44.760
Now, how do we go through this?

00:18:44.760 --> 00:18:47.760
This is one of the models
in SSL that happens.

00:18:47.940 --> 00:18:49.760
But it's the easiest one to explain.

00:18:49.760 --> 00:18:53.330
So, what I can do is I can use
my private key to create a

00:18:53.360 --> 00:18:55.560
signature over a bunch of data.

00:18:55.920 --> 00:18:59.910
What will happen is I create a checksum
and then I do an asymmetric crypto

00:19:00.080 --> 00:19:03.760
operation which will sign it for
me and give me the signature blob.

00:19:03.800 --> 00:19:06.880
Now, if I go ahead and pass
someone the signature blob,

00:19:06.880 --> 00:19:09.830
plus the data of course that
came across that we signed,

00:19:10.120 --> 00:19:13.620
as well as my public key,
the other party can happily take my

00:19:13.670 --> 00:19:17.760
public key because my public key is not
going to allow them to sign the data,

00:19:17.780 --> 00:19:21.350
but I can use it to verify that the
data that was signed by me with my

00:19:21.350 --> 00:19:23.760
private key was actually signed by me.

00:19:23.760 --> 00:19:27.750
Now, this doesn't show you
exactly who I am yet.

00:19:27.760 --> 00:19:30.760
This only shows you how I can prove
that I had possession of a key.

00:19:30.780 --> 00:19:34.760
So, the who is actually where
the certificates come in.

00:19:34.760 --> 00:19:38.760
If we zoom in on the
certificate that we have,

00:19:38.760 --> 00:19:40.900
if you look at it at a very high level,

00:19:41.460 --> 00:19:43.750
There is actually our
public key in there,

00:19:44.020 --> 00:19:47.310
which of course we needed to prove
to the other side who we were.

00:19:47.310 --> 00:19:50.090
But then the who is not in there,
the key is kind of an

00:19:50.090 --> 00:19:51.600
anonymous bag of bytes.

00:19:51.720 --> 00:19:55.850
So there's also an entity in there,
something that talks about

00:19:55.850 --> 00:19:59.900
whether it is my SSL server,
my web server or something.

00:19:59.900 --> 00:20:05.810
And so this combines basically the who
it is plus what key they will be using.

00:20:07.210 --> 00:20:10.480
That can of course be modified
unless you go ahead and sign this.

00:20:10.570 --> 00:20:14.300
So let's use the same method that
we just used to basically make sure

00:20:14.300 --> 00:20:18.440
that the signature is formed over
the subject in the public key and

00:20:18.450 --> 00:20:20.100
add the signature to the certificate.

00:20:20.100 --> 00:20:23.080
It just sits there separately,
but anyone who basically takes

00:20:23.080 --> 00:20:26.230
the public key that belonged with
the private key that created that

00:20:26.230 --> 00:20:29.910
signature on it can verify that the
subject and public key combination

00:20:29.910 --> 00:20:32.100
in the certificate were not modified.

00:20:32.300 --> 00:20:36.220
Now of course it would be pointless if
we did this to our certificate itself

00:20:36.220 --> 00:20:40.100
because well then we can only trust
it based on this one certificate.

00:20:40.130 --> 00:20:43.990
So generally speaking there will
be someone else's private key

00:20:44.030 --> 00:20:46.080
that signs your certificate.

00:20:46.080 --> 00:20:47.950
And so you can form a little tree.

00:20:48.100 --> 00:20:52.390
This root certificate that came into
view basically has a public key in

00:20:52.390 --> 00:20:56.180
it and a private key that someone
else holds and they went ahead and

00:20:56.180 --> 00:20:58.060
put the signature on my certificate.

00:20:58.120 --> 00:21:00.340
Now anyone who trusts this
root certificate will also

00:21:00.450 --> 00:21:01.060
be able to approve it.

00:21:01.110 --> 00:21:02.100
So that's the first thing
that we're going to do.

00:21:02.100 --> 00:21:05.100
So we're going to authenticate all
the certificates that it issued.

00:21:05.100 --> 00:21:11.050
Now for that our devices actually
trust an awful lot of certificates.

00:21:11.150 --> 00:21:16.100
So there's about 250 now so
that makes it a little awkward.

00:21:16.100 --> 00:21:20.600
But basically that is the trust pool
where we start from and as a result

00:21:20.600 --> 00:21:25.100
we can trust the leaves that are
dangling off of this large tree.

00:21:26.110 --> 00:21:28.870
So, Michael and I work at Honest Apes.

00:21:28.930 --> 00:21:31.500
We already have our
configuration profile installed.

00:21:31.500 --> 00:21:34.360
We actually have our
own CA in-house that,

00:21:34.470 --> 00:21:37.300
you know, bicycles can only make
you that much money.

00:21:37.300 --> 00:21:41.390
So we decided to open up a certificate
store here as well so that,

00:21:41.400 --> 00:21:43.380
you know, saves us some money.

00:21:43.620 --> 00:21:46.000
But we basically have a CA.

00:21:46.000 --> 00:21:48.080
So we have our two applications.

00:21:48.100 --> 00:21:53.130
Our applications both need a
certificate to connect to each other.

00:21:53.110 --> 00:21:55.430
So we're going to take the root
certificate and we're going to

00:21:55.430 --> 00:21:59.940
issue ourselves two certificates and
basically add them to the application.

00:22:00.880 --> 00:22:06.310
So in SSL, when you normally use it,
only the server really

00:22:06.310 --> 00:22:07.740
authenticates to you.

00:22:07.920 --> 00:22:10.900
When you use a website, that's okay,
because the information

00:22:10.900 --> 00:22:12.200
is technically public.

00:22:12.200 --> 00:22:14.400
You only want to know when
I go to this particular source,

00:22:14.400 --> 00:22:18.460
I want to see something
that is actually theirs,

00:22:18.460 --> 00:22:20.400
not someone else's.

00:22:20.550 --> 00:22:24.060
Server authentication,
if I connect to Michael,

00:22:24.080 --> 00:22:27.260
he is going to authenticate to me.

00:22:27.300 --> 00:22:29.950
And thereby, I know this is Michael.

00:22:30.090 --> 00:22:32.730
But in our situation, that's not enough.

00:22:32.880 --> 00:22:36.260
Because imagine that
Andrew connects to Michael.

00:22:36.310 --> 00:22:37.230
No problem.

00:22:37.460 --> 00:22:40.130
Michael will authenticate to Andrew,
but if he actually

00:22:40.130 --> 00:22:42.880
starts sharing pictures,
he would actually be happily

00:22:42.880 --> 00:22:45.760
forwarding pictures to Andrew,
which was kind of the point.

00:22:45.900 --> 00:22:48.430
We were trying to make sure
that Michael and I could share

00:22:48.520 --> 00:22:50.700
pictures without Andrew seeing it.

00:22:50.810 --> 00:22:53.300
So the only thing that server
authentication does in this

00:22:53.420 --> 00:22:56.790
scenario for our app is it avoids
me connecting to Andrew and getting,

00:22:56.790 --> 00:22:59.010
for example,
a LOLcat sent to me instead of

00:22:59.080 --> 00:23:01.010
a picture that Michael took.

00:23:01.550 --> 00:23:06.500
If we do client authentication,
Michael will also authenticate to Andrew.

00:23:06.810 --> 00:23:15.730
As Andrew tries to authenticate,
Michael notices, "Hey,

00:23:15.750 --> 00:23:18.500
this is not Conrad," and
drops the connection.

00:23:18.500 --> 00:23:20.500
That stops it from happening.

00:23:20.500 --> 00:23:22.950
For our main scenario,
that will still work because as

00:23:23.010 --> 00:23:26.410
Michael asks me to authenticate,
he'll notice, "Oh, that's Conrad.

00:23:26.600 --> 00:23:28.700
Good, we can make this connection."
And then in the future,

00:23:28.700 --> 00:23:32.500
he can start sending me pictures because
he knows that he talked to me before.

00:23:32.510 --> 00:23:34.490
And in future connections,
I am the server.

00:23:34.500 --> 00:23:36.500
He'll know that's Conrad
that I'm sending to.

00:23:36.500 --> 00:23:39.750
And I'll know that Michael is
actually sending me pictures instead

00:23:39.750 --> 00:23:41.490
of Andrew sending me wallcats.

00:23:41.500 --> 00:23:43.500
So now we have mutual authentication.

00:23:43.500 --> 00:23:44.500
How do we do this?

00:23:44.500 --> 00:23:48.020
So we're going back to our delegates.

00:23:48.300 --> 00:23:55.020
Whenever our delegate is called
for receiving data or errors that

00:23:55.060 --> 00:23:59.610
happen during the connection,
there are a couple of authentication

00:23:59.610 --> 00:24:01.300
challenges thrown our way.

00:24:01.410 --> 00:24:04.300
The first of which is going to
be for this client certificate.

00:24:04.440 --> 00:24:07.920
So the delegate did receive
an authentication challenge

00:24:08.350 --> 00:24:10.300
and it passes as a challenge.

00:24:10.450 --> 00:24:13.410
Now we can inspect that challenge
and notice that what it's asking us

00:24:13.410 --> 00:24:17.090
for is "I want a client certificate".
The other side asks us "Hey,

00:24:17.230 --> 00:24:21.430
please authenticate yourself so
I know that I want to send data

00:24:21.430 --> 00:24:24.700
to you". After this happens,
we create a credential

00:24:24.750 --> 00:24:26.280
and actually just set it.

00:24:26.290 --> 00:24:27.210
Fairly simple.

00:24:27.560 --> 00:24:29.100
Now how do we get here?

00:24:29.470 --> 00:24:33.300
You see us creating this NSURL credential
and we're creating it with an identity.

00:24:33.640 --> 00:24:35.280
Identity is really very simple.

00:24:35.330 --> 00:24:38.640
It's just a composite object that
really just puts together my private

00:24:38.680 --> 00:24:40.200
key as well as my certificate.

00:24:40.300 --> 00:24:43.020
If you put those two together, you know,
for logical purposes we

00:24:43.110 --> 00:24:44.300
have this identity object.

00:24:44.300 --> 00:24:47.280
And that is what you create
the NSURL credential with.

00:24:47.300 --> 00:24:50.300
Now you could also pass
along more certificates,

00:24:50.300 --> 00:24:52.300
but that's another detail that
I don't want to get into right here.

00:24:52.300 --> 00:24:57.300
That is also not necessary for a basic
mutual authentication as you'll see.

00:24:59.270 --> 00:25:02.060
Before this delegate is called,
there's one performance

00:25:02.060 --> 00:25:06.220
optimization that is pretty much a,
are you going to handle this

00:25:06.250 --> 00:25:09.200
particular authentication
challenge that is called first?

00:25:09.200 --> 00:25:12.220
So the first thing URL connection
will do before it even asks me for

00:25:12.220 --> 00:25:15.200
a client certificate is ask me,
like, do you support that?

00:25:15.200 --> 00:25:20.200
And so when that is being called,
I return yes, and off we go.

00:25:20.200 --> 00:25:24.190
So let's demo how our application
works with SSL enabled.

00:25:24.200 --> 00:25:25.200
All right, so there's my device again.

00:25:25.200 --> 00:25:27.200
We're going to connect
to each other again.

00:25:27.200 --> 00:25:29.590
Did you notice that really
nothing has changed?

00:25:29.950 --> 00:25:31.180
I'm connecting to Michael.

00:25:31.370 --> 00:25:32.540
Michael probably connected to me.

00:25:32.540 --> 00:25:36.570
Maybe he can start with the pictures.

00:25:36.610 --> 00:25:36.610
Oh, not me again.

00:25:38.410 --> 00:25:40.370
All right, well, great.

00:25:40.390 --> 00:25:41.900
There's a picture of me.

00:25:41.900 --> 00:25:47.320
Now I'm going to pass the buck
right around and go back to Andrew.

00:25:49.500 --> 00:25:54.170
One more for the audience because you
guys have been so patiently listening.

00:25:54.170 --> 00:25:56.210
You should be part of the show.

00:26:01.100 --> 00:26:08.940
As you saw, we managed to use the app
without any other thing.

00:26:08.940 --> 00:26:11.100
It worked the same way as it did before.

00:26:11.100 --> 00:26:14.260
That's pretty good for us as users.

00:26:14.260 --> 00:26:16.390
Let's see what Andrew got.

00:26:17.580 --> 00:26:23.000
So I've noticed that Michael and
Conrad are back on my network and

00:26:23.190 --> 00:26:26.750
I've been running the same
utility I was running earlier,

00:26:26.750 --> 00:26:28.600
and let's see what we've got.

00:26:28.800 --> 00:26:31.340
Lo and behold, I have no more images.

00:26:31.640 --> 00:26:33.810
Well,
I could see them using the application,

00:26:33.950 --> 00:26:35.110
so what's going on?

00:26:35.250 --> 00:26:38.200
Maybe my little setup here is broken.

00:26:38.310 --> 00:26:42.340
But if I go over to my intercepts folder,
I can see that, yes,

00:26:42.340 --> 00:26:48.920
I've got some traffic here,
but if I look at it, that's very odd.

00:26:48.920 --> 00:26:48.920
That doesn't look like...

00:26:49.800 --> 00:26:51.800
I'm going to show you how to use a JPEG.

00:26:51.800 --> 00:26:54.480
In fact, it looks incredibly encrypted.

00:26:54.480 --> 00:26:55.640
So maybe they're doing something else.

00:26:55.640 --> 00:27:01.240
At which point, I could go in and, say,
do a traffic flow analysis and

00:27:01.290 --> 00:27:07.660
perhaps use the Wireshark utility,
and I can see, ah, they're using TLS.

00:27:08.300 --> 00:27:11.270
Out of that, I can get information
such as the certificate,

00:27:11.330 --> 00:27:13.100
because that goes over privately.

00:27:13.250 --> 00:27:16.320
And I can find out that
they're using their company CA,

00:27:16.320 --> 00:27:17.660
which is Honest Apes.

00:27:17.800 --> 00:27:20.660
And as it happens,
I happen to know somebody who works

00:27:20.660 --> 00:27:22.660
in the IT department of Honest Apes.

00:27:22.800 --> 00:27:27.050
He's mostly just a bicycle repairman,
but he does it on the side.

00:27:27.060 --> 00:27:30.190
And as a favor, I said, "Hey, you know,
I've got these friends,

00:27:30.190 --> 00:27:31.270
Michael and Conrad.

00:27:31.270 --> 00:27:35.110
Could I have some certificates
for them?" And lo and behold,

00:27:35.230 --> 00:27:36.450
I got them.

00:27:36.600 --> 00:31:25.300
[Transcript missing]

00:31:25.370 --> 00:31:28.320
At the end of it,
we do the same thing as in the other one,

00:31:28.560 --> 00:31:30.990
whereby we specify back to the delegate,
like, "Okay,

00:31:30.990 --> 00:31:33.540
let's create a credential out of
the trust that we've evaluated

00:31:33.540 --> 00:31:35.780
successfully," and pass that back.

00:31:35.850 --> 00:31:39.050
If we do not trust the other party,
we return nothing,

00:31:39.050 --> 00:31:43.270
and as we come out of this delegate,
the higher-level APIs will close

00:31:43.340 --> 00:31:47.690
the connection and basically flag
the error up to your application.

00:31:48.920 --> 00:31:51.580
So, in summary,
I think I've tried to show you

00:31:51.580 --> 00:31:54.970
that HTTPS is fairly easy to
use from the high-level API use,

00:31:54.970 --> 00:31:58.100
and it does require some setup
work to use these certificates.

00:31:58.130 --> 00:32:00.780
But it provides a
simple experience which,

00:32:00.780 --> 00:32:05.210
you know, it only adds to oversharing and
remaining a fun application.

00:32:05.440 --> 00:32:08.450
If you have to dig in and
get some more things out,

00:32:08.450 --> 00:32:11.720
Secure Transport has a host
of options that you can use to

00:32:11.720 --> 00:32:15.400
optimize for your purposes and
other methods of authentication.

00:32:15.420 --> 00:32:17.800
But, of course,
you have to watch what you're doing.

00:32:17.800 --> 00:32:21.170
Again, hit us up at the lab if you
want to discuss those options,

00:32:21.170 --> 00:32:22.810
and we can help you with those.

00:32:23.050 --> 00:32:27.700
So, finally, let's see what happened now
that we restricted our routes.

00:32:27.700 --> 00:32:29.800
I do not trust Honest Abe's anymore.

00:32:29.850 --> 00:32:33.600
Let's see what happens when I go ahead
and try to go across the network.

00:32:33.600 --> 00:32:37.200
Imagine that Andrew is sitting
there with Honest Abe's certificate,

00:32:37.260 --> 00:32:41.370
and he's publishing Michael's name,
and I'm just connecting to him.

00:32:42.020 --> 00:32:44.670
And as I go ahead to connect,
I basically get the error back

00:32:44.840 --> 00:32:48.110
up at the top level of my client,
which is "did fail" and there

00:32:48.110 --> 00:32:50.710
are some additional information
passed to me which says like,

00:32:50.710 --> 00:32:53.290
"Well, Michael's iPad, we don't trust it.

00:32:53.400 --> 00:32:56.400
That certificate that you're using,
we're not currently trusting anyway."

00:32:56.520 --> 00:32:58.990
And an unhelpful suggestion of
would you like to connect anyway,

00:32:59.000 --> 00:32:59.830
"Of course I don't.

00:32:59.830 --> 00:33:02.420
I want to keep this connection
secure." So we're going to

00:33:02.460 --> 00:33:04.090
cancel out and leave it at that.

00:33:04.180 --> 00:33:07.810
And hopefully we'll find a network
where we can share pictures without

00:33:07.810 --> 00:33:09.610
Andrew getting in the middle.

00:33:12.810 --> 00:33:13.690
Thank you.

00:33:13.690 --> 00:33:15.820
So, now I really am lost.

00:33:15.980 --> 00:33:19.690
They've completely secured their
network connection and I can't

00:33:19.690 --> 00:33:21.760
get in through that method at all.

00:33:21.900 --> 00:33:24.710
However, very handily,
as Michael walked off stage,

00:33:24.880 --> 00:33:28.090
he left his iPad here and he forgot it.

00:33:28.330 --> 00:33:30.620
So, well, what can I do with this?

00:33:30.880 --> 00:33:34.420
Of course, by default,
there's no way I can get at the

00:33:34.520 --> 00:33:36.560
raw file system on a device.

00:33:36.560 --> 00:33:40.880
But the files are just
there in plain text.

00:33:40.880 --> 00:33:44.700
And if there's something such as
a forensics tool or jailbreaking

00:33:44.810 --> 00:33:47.720
or some other utilities,
I might be able to get at

00:33:47.760 --> 00:33:49.440
the raw data on the file.

00:33:49.460 --> 00:33:51.940
So, let's see what we can do there.

00:33:53.760 --> 00:33:58.870
So, there might have been
some pre-demo setup here,

00:33:59.010 --> 00:34:01.120
but I've just plugged it in.

00:34:01.350 --> 00:34:06.000
And let's run this demo
tool and see what happens.

00:34:06.020 --> 00:34:07.740
Oh, we have some images coming across.

00:34:07.760 --> 00:34:09.550
That looks interesting.

00:34:13.590 --> 00:34:17.980
Lo and behold, it looks like the images
that were sent earlier.

00:34:17.980 --> 00:34:22.600
So even though I am now forced to no
longer attack them on the network,

00:34:22.610 --> 00:34:26.000
I can attack the device if
I can get physical possession.

00:34:26.000 --> 00:34:29.560
It sounds like maybe there's
some work to be done there,

00:34:29.630 --> 00:34:31.990
but at the moment I'm still happy.

00:34:32.400 --> 00:35:03.400
[Transcript missing]

00:35:04.850 --> 00:35:08.420
Protects data in case the user
loses physical possession of

00:35:08.420 --> 00:35:11.800
the device assuming you set
a passcode on that device.

00:35:11.890 --> 00:35:14.210
Which obviously I had,
but since our application

00:35:14.230 --> 00:35:16.730
wasn't using data protection,
Andrew was able to get

00:35:16.730 --> 00:35:18.200
access to all that data.

00:35:18.460 --> 00:35:21.960
And as Andrew pointed out,
there's widely available hacking

00:35:21.960 --> 00:35:25.400
and various tools that will
let you access the file system.

00:35:25.400 --> 00:35:28.900
So without using data protection,
there really isn't much

00:35:28.900 --> 00:35:30.390
protecting your data.

00:35:30.950 --> 00:35:40.620
The way data protection works is,
we have a file on the device.

00:35:40.810 --> 00:35:43.810
That file is encrypted using
a randomly generated file key.

00:35:43.810 --> 00:35:49.240
Then the file key itself is
encrypted with a class key,

00:35:49.290 --> 00:35:51.080
which is also a randomly generated key.

00:35:51.080 --> 00:35:55.140
That class key is in turn
protected by a device key on the

00:35:55.390 --> 00:35:58.250
hardware and the user's passcode.

00:35:58.360 --> 00:36:01.570
Those two are scrambled together
using a special algorithm that

00:36:01.570 --> 00:36:07.320
makes it hard or impossible to
offline attack the user's passcode.

00:36:07.320 --> 00:36:09.440
It basically forces you,
when you want to brute

00:36:09.440 --> 00:36:11.500
force the passcode,
you have to brute force it

00:36:11.500 --> 00:36:13.000
on that particular device.

00:36:13.000 --> 00:36:15.900
Because the device key is a
per device key that can't be

00:36:16.000 --> 00:36:18.000
extracted out of the hardware.

00:36:19.260 --> 00:36:23.110
So this makes it that if your
password is strong enough,

00:36:23.130 --> 00:36:25.730
if the user's password is strong enough,
their data would be protected,

00:36:25.880 --> 00:36:29.430
assuming that you guys actually
start using data protection.

00:36:30.920 --> 00:36:34.960
There's a number of APIs in iOS
5 that support data protection.

00:36:34.960 --> 00:36:39.660
There's the NSFileManager APIs,
and basically there's a key added

00:36:40.030 --> 00:36:45.090
there called NSFileProtectionKey,
and there's various NSFileProtection

00:36:45.300 --> 00:36:47.620
options to that key,
which I'll go over.

00:36:47.620 --> 00:36:50.880
CoreData has the same key
and has the same options.

00:36:50.880 --> 00:36:53.520
NSData has the same options,
but they're called

00:36:53.630 --> 00:36:58.040
NSDataWritingOptions instead,
but it's the same exact functionality.

00:36:58.760 --> 00:37:02.360
We even added it to SQLite,
so if you're creating a SQLite database

00:37:02.360 --> 00:37:05.330
directly rather than using CoreData,
you can create a

00:37:05.450 --> 00:37:07.260
data-protected SQLite database.

00:37:07.260 --> 00:37:11.180
And SecItem,
which is the Keychain interface,

00:37:11.180 --> 00:37:15.620
also has data protection,
and historically those are

00:37:15.620 --> 00:37:19.400
called attribute-accessible,
so they're described as

00:37:19.400 --> 00:37:22.110
accessibility rather than protection,
but I'll show you the

00:37:22.110 --> 00:37:23.440
mapping between the two.

00:37:23.440 --> 00:37:23.970
They're the same.

00:37:26.040 --> 00:37:29.750
These APIs are nice,
but for probably 95% of

00:37:29.750 --> 00:37:32.870
the people in this room,
your applications only

00:37:32.880 --> 00:37:34.160
run in the foreground.

00:37:34.260 --> 00:37:37.430
So when the user clicks the menu button,
the application goes away,

00:37:37.440 --> 00:37:39.740
your app isn't really doing
anything in the background.

00:37:39.890 --> 00:37:43.550
For those apps,
adopting data protection is as

00:37:43.550 --> 00:37:48.330
easy as adding an entitlement
called Data Protection Class.

00:37:48.560 --> 00:37:52.160
and setting that to
NSFileProtectionComplete as its value.

00:37:52.180 --> 00:37:55.210
At that point,
all of your application's documents

00:37:55.330 --> 00:37:58.710
and files that it creates will
automatically be protected with the

00:37:58.710 --> 00:38:02.600
highest data protection class available,
which is ProtectionComplete.

00:38:02.650 --> 00:38:06.410
Which basically means that none of your
application's data can be accessed unless

00:38:06.410 --> 00:38:08.050
the device is unlocked at the time.

00:38:08.200 --> 00:38:10.320
So as soon as the user
hits the lock button,

00:38:10.340 --> 00:38:15.080
about 10 seconds after
the lock timeout goes off,

00:38:15.080 --> 00:38:17.840
so you can set in settings,
you can set go to sleep

00:38:17.870 --> 00:38:19.860
immediately or after one minute.

00:38:19.860 --> 00:38:22.650
Once that timeout expires,
apps get about 10

00:38:22.650 --> 00:38:25.130
seconds time to clean up,
write their files.

00:38:25.200 --> 00:38:27.900
At that point,
the keys are thrown away by the kernel

00:38:27.900 --> 00:38:33.500
and there is no way to decrypt that data
unless you re-enter the user's password.

00:38:33.540 --> 00:38:38.480
So this is what probably almost
all of you should go do today.

00:38:40.170 --> 00:38:47.550
Let's say you're not in the class of
app that just runs in the foreground

00:38:47.650 --> 00:38:52.270
and you need to use some of our
APIs because you have some files

00:38:52.270 --> 00:38:53.990
you need to access in other cases.

00:38:54.010 --> 00:38:58.390
Here's an example of what we
would use in our application here

00:38:58.440 --> 00:39:03.360
to write an image to our album.

00:39:03.360 --> 00:39:08.330
What we do is we get the data out
of the UI image and then just call

00:39:08.330 --> 00:39:14.100
NSData's write file to path with the data
writing file protection complete option.

00:39:14.100 --> 00:39:19.220
Which makes basically that image
protected and only accessible when

00:39:19.220 --> 00:39:23.680
the user's password is entered
and the device is unlocked.

00:39:25.780 --> 00:39:28.810
Some things to consider is
that data protection is only

00:39:28.810 --> 00:39:30.800
as good as the user's passcode.

00:39:30.800 --> 00:39:34.700
If you have A as your password,
it's not going to be very good.

00:39:34.780 --> 00:39:39.810
Even though we limit the speed
at which you can brute force it

00:39:39.810 --> 00:39:45.700
to about 10 tries per second,
if your password is a four-digit PIN,

00:39:45.700 --> 00:39:47.600
that's only 10,000 options.

00:39:47.770 --> 00:39:50.690
You can go through those
in a couple minutes.

00:39:50.730 --> 00:39:55.740
Users do need to choose a
somewhat longer passcode for it

00:39:55.740 --> 00:39:59.170
to actually make any real benefit.

00:39:59.340 --> 00:40:03.140
As we said, you can't access these
files when they're locked,

00:40:03.140 --> 00:40:04.940
and you can't create
them when they're locked.

00:40:04.940 --> 00:40:09.360
Now, what if your application needs
to be able to create files

00:40:09.360 --> 00:40:10.310
while the device is locked?

00:40:10.400 --> 00:40:12.990
Let's say,
in the case of our oversharing app,

00:40:12.990 --> 00:40:16.510
we want to receive images while
my device is in my pocket.

00:40:16.790 --> 00:40:21.640
So, I connected to Conrad's device,
but I put my device in my pocket.

00:40:21.770 --> 00:40:24.480
Conrad's taking pictures,
I still want them to be stored

00:40:24.620 --> 00:40:26.120
on the device and archived.

00:40:26.230 --> 00:40:29.460
Well, since it's locked,
I can't create files with

00:40:29.460 --> 00:40:31.240
NSProtectionComplete.

00:40:31.320 --> 00:40:35.860
For that, we have another class called
NSFileProtectionCompleteUnlessOpen.

00:40:35.930 --> 00:40:39.010
Under the covers,
that actually uses an asymmetric

00:40:39.010 --> 00:40:40.430
key pair to protect the data.

00:40:40.460 --> 00:40:43.960
So, what happens is the private key
is protected by the password,

00:40:43.960 --> 00:40:46.290
but the public key is always available.

00:40:46.350 --> 00:40:49.220
So, the system is always
able to create new files.

00:40:49.260 --> 00:40:52.170
And as long as you keep that file open,
the kernel lets you read

00:40:52.170 --> 00:40:53.220
and write to that file.

00:40:53.220 --> 00:40:57.310
As soon as you close the file,
the key for that file is thrown away,

00:40:57.310 --> 00:41:00.280
and the only way to get it back
is with access to the private key.

00:41:00.410 --> 00:41:03.060
And since the private key is
protected by the passcode,

00:41:03.110 --> 00:41:06.890
if the device is locked,
you can't reopen the file.

00:41:07.020 --> 00:41:10.240
Now, because it uses asymmetricKypto,
it puts a slightly heavier

00:41:10.240 --> 00:41:11.160
load on the system.

00:41:11.160 --> 00:41:16.330
So, as a general policy,
it's good practice to upgrade those

00:41:16.330 --> 00:41:20.780
files to ProtectionComplete the
next time your app is able to do so.

00:41:22.050 --> 00:41:24.480
I'm going to show you how
to do both those things.

00:41:24.480 --> 00:41:29.000
So here's the write images
while locked method again.

00:41:29.000 --> 00:41:32.760
And this is the version that actually
works even when the device is locked.

00:41:32.760 --> 00:41:36.160
So first we try to write the
file with protection complete.

00:41:36.160 --> 00:41:38.160
And if that fails because
the device is locked,

00:41:38.160 --> 00:41:40.030
we just write it with
complete unless open.

00:41:40.030 --> 00:41:44.070
And that's basically all there is to it.

00:41:45.400 --> 00:41:51.310
So, as far as the startup code that
we have to do to upgrade things,

00:41:51.550 --> 00:41:57.660
We start with looping through basically
all the files in our album directory.

00:41:57.660 --> 00:42:02.580
And for each file that isn't
already protection complete,

00:42:02.580 --> 00:42:04.580
so we look at the file attributes.

00:42:04.580 --> 00:42:09.480
If it's not protection complete already,
then we create a dictionary saying,

00:42:09.490 --> 00:42:14.040
set the protection key to complete
and set the attributes on the file.

00:42:14.080 --> 00:42:17.530
So this is using the file manager
APIs to basically modify the

00:42:17.530 --> 00:42:20.490
protection class of existing files.

00:42:21.820 --> 00:42:27.550
So, there's a third class of apps,
which what if in addition to receiving

00:42:27.550 --> 00:42:31.810
pictures while we were asleep,
we wanted to actually provide

00:42:32.020 --> 00:42:34.920
some kind of album service that
people could connect to after

00:42:34.980 --> 00:42:36.470
the fact and download pictures.

00:42:36.600 --> 00:42:39.580
Well,
that means that someone would actually

00:42:39.580 --> 00:42:43.850
be able to need to be able to read
files while the device is locked.

00:42:43.930 --> 00:42:47.210
Now,
this is a class that we'd rather you not

00:42:47.380 --> 00:42:52.350
use unless you really have to because
the downside of this protection class

00:42:52.560 --> 00:42:57.760
is once the user enters their passcode,
all files of protection complete

00:42:57.760 --> 00:43:02.280
until first user authentication
are accessible to the system

00:43:02.660 --> 00:43:05.110
until you reboot the device.

00:43:05.180 --> 00:43:10.850
So, what this means is if you took your
phone to like through airport security

00:43:10.850 --> 00:43:13.860
in some country where you're not really
sure what they're going to do with it,

00:43:13.860 --> 00:43:19.310
if you power it down or restart it before
you hand it off to the customs officer,

00:43:19.310 --> 00:43:21.870
these files are protected.

00:43:21.990 --> 00:43:25.990
If your device is just locked,
then in theory they could still pull

00:43:25.990 --> 00:43:28.640
those files off using a forensics tool.

00:43:29.110 --> 00:43:31.770
There are cases where
you need to use this,

00:43:31.770 --> 00:43:33.620
which is why we provide it.

00:43:33.620 --> 00:43:36.450
It's still better than
not protecting it at all.

00:43:37.530 --> 00:43:42.470
So, the example case in our case would
be we're making a background service

00:43:42.470 --> 00:43:45.140
that lets you download images.

00:43:47.500 --> 00:43:53.360
Here's how we would make a SQLite
database that can be read and written

00:43:53.840 --> 00:43:55.100
even when the device is locked.

00:43:55.100 --> 00:43:59.250
Let's say your application is something
that runs all the time in the background,

00:43:59.300 --> 00:44:02.760
some kind of system service,
then you could create a database

00:44:02.760 --> 00:44:07.720
using file protection complete
until first user authentication.

00:44:10.620 --> 00:44:15.470
So with that,
I'm going to bring Andrew back

00:44:15.470 --> 00:44:18.830
on stage to see if he can hack
into our app now that we have

00:44:18.830 --> 00:44:20.100
some data protection enabled.

00:44:20.210 --> 00:44:23.180
So, yet again,
that careless chap Michael has

00:44:23.180 --> 00:44:28.100
left his device lying around
and I've got hold of it.

00:44:28.120 --> 00:44:34.590
So, let's take a look and see what
I can get off it this time.

00:44:35.980 --> 00:44:40.060
This time it appears to be locked.

00:44:40.060 --> 00:44:45.500
And there's a, I need to set up the same,
there is a long password set on it.

00:44:45.660 --> 00:44:51.640
So let's see what we can get off it.

00:44:53.620 --> 00:44:58.920
So this time we're running the demo
tool and we get operation not permitted.

00:44:58.920 --> 00:45:02.680
And that shows that while
this device is locked,

00:45:02.680 --> 00:45:03.960
I can't get in.

00:45:04.600 --> 00:45:13.030
And the chances of me getting
to the device before that 10

00:45:13.040 --> 00:45:14.670
seconds elapses is quite small.

00:45:15.350 --> 00:45:18.600
However,
say for example you are in an airport

00:45:18.600 --> 00:45:22.300
and there's a charging station that
happens to be hanging out of the wall.

00:45:22.320 --> 00:45:24.630
And you think, okay,
I better lock my device before

00:45:24.740 --> 00:45:26.460
I put it into this charging station.

00:45:26.460 --> 00:45:27.720
I don't quite trust it.

00:45:27.720 --> 00:45:31.010
Make sure you wait those 10 seconds
for those keys to be thrown away.

00:45:32.020 --> 00:45:35.980
And you also might think, well,
we use flash storage on here

00:45:36.050 --> 00:45:39.700
and it's very difficult to
properly get rid of keys.

00:45:39.700 --> 00:45:43.240
You might have heard that's
a problem with some issues.

00:45:43.240 --> 00:45:47.210
But we've actually created a special
part of there where the keys can

00:45:47.210 --> 00:45:51.200
be easily thrown away and we can
guarantee they're overwritten.

00:45:51.200 --> 00:45:55.350
And for brevity,
I think I'm going to leave it there.

00:45:55.350 --> 00:45:59.390
But I'm now fully locked out of
that device and my evil plans to

00:45:59.390 --> 00:46:01.920
steal the embarrassing pictures.

00:46:02.040 --> 00:46:07.600
So, now we've seen how to
use data protection.

00:46:07.600 --> 00:46:08.690
And you think, well, that's great.

00:46:08.860 --> 00:46:10.240
Now I know how to protect all my data.

00:46:10.240 --> 00:46:13.300
So, if I need to store a password,
I'm just going to write it into a

00:46:13.300 --> 00:46:15.410
file that's data protection complete.

00:46:15.420 --> 00:46:19.430
And that's where we kind of want to
make a little change because we have

00:46:19.430 --> 00:46:21.820
another API here called the keychain.

00:46:21.880 --> 00:46:24.650
And to talk about what
belongs in the keychain is,

00:46:24.650 --> 00:46:29.000
as Conrad alluded to earlier,
what belongs in the keychain are secrets.

00:46:29.000 --> 00:46:33.630
And what we consider secrets versus data
is... Secrets is anything that would

00:46:33.630 --> 00:46:35.620
give you access to additional data.

00:46:35.790 --> 00:46:38.520
Say, you know,
a credential that you need to

00:46:38.520 --> 00:46:42.270
log into a service or a key that
you use to encrypt something.

00:46:42.390 --> 00:46:44.230
Those things would be
stored in the keychain.

00:46:44.360 --> 00:46:47.680
The keychain has actually been
around since iOS 1 and the

00:46:47.680 --> 00:46:51.410
keychain has always been our most
protected layer in the system.

00:46:51.620 --> 00:46:55.550
So, keychain has,
in addition to data protection,

00:46:55.870 --> 00:47:01.180
some higher level controls that
let you control migratability,

00:47:02.020 --> 00:47:05.520
it has different access groups,
so it's partitioned between applications.

00:47:05.530 --> 00:47:09.580
And there's some other features of the
keychain that make it something we'd

00:47:09.640 --> 00:47:15.090
rather see use that for credentials
than just storing them in a file.

00:47:16.580 --> 00:47:21.590
So, example would be, you know,
storing username and password

00:47:21.650 --> 00:47:25.210
because we want to add functionality
to our oversharing app to

00:47:25.210 --> 00:47:28.270
upload pictures to the system.

00:47:28.410 --> 00:47:31.820
Other than asking the user
for their password each time,

00:47:32.020 --> 00:47:36.460
we store those credentials
in the Keychain.

00:47:36.460 --> 00:47:37.400
How do you do this?

00:47:37.400 --> 00:47:43.360
Well, you use the Keychain interfaces
and the way you protect the data

00:47:43.360 --> 00:47:49.460
in the Keychain is you set the
accessibil- the atter accessible,

00:47:49.460 --> 00:47:53.850
which basically tells you when you need
to be able to access- or you're telling

00:47:53.920 --> 00:47:57.600
the Keychain when your application
needs to be able to access the data.

00:47:57.600 --> 00:48:00.130
And if you say,
"I only need to access the data

00:48:00.140 --> 00:48:04.560
when unlocked," that's equivalent
to data protection complete.

00:48:04.640 --> 00:48:07.050
If you say,
"I only need to access the data after

00:48:07.090 --> 00:48:10.890
first unlock," that's equivalent to
complete until first user authentication.

00:48:11.100 --> 00:48:14.200
And then finally, there's always,
which is equivalent

00:48:14.270 --> 00:48:15.690
to no data protection.

00:48:16.770 --> 00:48:19.740
So the default for Keychain,
if you don't set the

00:48:19.740 --> 00:48:23.490
accessibility attribute,
is when unlocked.

00:48:23.570 --> 00:48:26.040
So it's the highest protection level.

00:48:27.420 --> 00:48:32.090
By default, these classes also let
Keychain items migrate,

00:48:32.160 --> 00:48:35.540
which is to say,
if you backup your device and you've

00:48:35.600 --> 00:48:39.280
set a backup password and you restore
that backup to a different device,

00:48:39.280 --> 00:48:42.700
any items marked with any of
these accessibility attributes

00:48:42.940 --> 00:48:44.800
will show up on that new device.

00:48:44.800 --> 00:48:48.360
Most of the time, that's what you want,
if it's a credential or a password.

00:48:48.730 --> 00:48:52.350
Sometimes,
the credentials or keys or whatnot

00:48:52.420 --> 00:48:55.800
you're storing in your application
might be bound to the device itself,

00:48:56.010 --> 00:48:59.280
and you would want to get new credentials
when the user gets a new device.

00:48:59.280 --> 00:49:02.360
So if you need that,
there are variants of these where

00:49:02.360 --> 00:49:06.700
you append this device only to the
name of the accessibility attribute,

00:49:06.700 --> 00:49:10.520
and that prevents those items
from migrating to a new device.

00:49:10.520 --> 00:49:13.590
If you backup your device,
wipe the device,

00:49:13.590 --> 00:49:14.780
and restore the backup password,
you might want to set up a new device.

00:49:14.790 --> 00:49:20.640
If you don't have a new device,
you might want to set up a new one.

00:49:21.070 --> 00:49:26.180
I want to show you an example of how you
would use a Keychain in your application.

00:49:26.310 --> 00:49:30.320
For that, we start with a helper function
that we're going to use

00:49:30.320 --> 00:49:34.060
everywhere called QueryForAccount.

00:49:34.060 --> 00:49:35.540
This is in the case of
our oversharing app.

00:49:35.540 --> 00:49:38.730
We're going to use a
generic password item.

00:49:38.800 --> 00:49:40.720
Most of the time,
you would probably be using

00:49:40.720 --> 00:49:43.710
an internet password item,
which has a bunch more attributes.

00:49:43.800 --> 00:49:48.820
For brevity, I'm using a generic password
item here as an example.

00:49:48.820 --> 00:49:50.770
We're setting the class
to generic password.

00:49:50.770 --> 00:49:52.720
We're setting the service to oversharing.

00:49:52.720 --> 00:49:56.460
We're setting the account to the
account name on the service that,

00:49:56.460 --> 00:50:00.400
in this case,
was passed into this function.

00:50:00.400 --> 00:50:04.640
The passwordForAccount function is the
first function your code would call.

00:50:04.640 --> 00:50:07.680
Let's see if we already have
the password in the Keychain.

00:50:07.680 --> 00:50:09.480
First, we get the query.

00:50:09.510 --> 00:50:14.480
Then we add one attribute to that query,
which is return us the data, please.

00:50:14.650 --> 00:50:16.230
Now we say copy matching.

00:50:16.230 --> 00:50:19.480
Give me something that
matches this query.

00:50:19.480 --> 00:50:21.140
We get back the data for that item.

00:50:21.170 --> 00:50:24.470
If it exists, if it doesn't exist,

00:50:24.880 --> 00:50:30.160
The Keychain and the
Application Data are important.

00:50:30.160 --> 00:50:35.630
Learn how to use the Keychain
and the Application Data.

00:50:35.630 --> 00:50:41.820
Understand how to use the
Keychain and the Application Data.

00:50:41.820 --> 00:50:41.820
Understand how to use the
Keychain and the Application Data.

00:50:41.820 --> 00:50:41.820
Understand how to use the
Keychain and the Application Data.

00:50:41.820 --> 00:50:41.820
Understand how to use the
Keychain and the Application Data.

00:50:43.040 --> 00:50:48.440
The other function we need is, well,
if the password wasn't in the Keychain,

00:50:48.440 --> 00:50:49.200
we need to store it.

00:50:49.200 --> 00:50:51.000
We need to set password function.

00:50:51.110 --> 00:50:55.240
So for that, again,
we call the query for account,

00:50:55.240 --> 00:50:57.000
which is the helper thing.

00:50:57.000 --> 00:51:00.960
Then we set the data attribute.

00:51:00.990 --> 00:51:04.000
So we set the value data that actually
sets the password on the item.

00:51:04.000 --> 00:51:06.000
And then we set the
accessibility attribute.

00:51:06.000 --> 00:51:08.990
And we say we only want to
access it when unlocked,

00:51:09.130 --> 00:51:11.620
which happens to be the default,
but it doesn't hurt to be explicit.

00:51:13.210 --> 00:51:15.120
And then we add the item.

00:51:16.410 --> 00:51:18.970
And then finally we have
the update function,

00:51:19.060 --> 00:51:21.500
which is very similar to the set.

00:51:21.500 --> 00:51:25.860
The difference is that this is what
you would call to modify an existing

00:51:25.860 --> 00:51:27.180
item that's already in the Keychain.

00:51:27.270 --> 00:51:30.190
Let's say we had an item in the Keychain,
but the password was wrong

00:51:30.200 --> 00:51:32.860
because the user changed
their password on the server.

00:51:32.890 --> 00:51:34.830
You prompt the user
for their new password,

00:51:34.930 --> 00:51:37.400
and then we update the
Keychain item when we're done.

00:51:37.400 --> 00:51:40.270
So for that, again, we get the query.

00:51:40.430 --> 00:51:44.100
Now we create a second dictionary,
which are the changes we

00:51:44.150 --> 00:51:45.990
want to make to the item.

00:51:46.500 --> 00:52:59.600
[Transcript missing]

00:53:00.100 --> 00:53:04.080
So, we want you to store, you know,
credentials, secrets in the Keychain.

00:53:04.180 --> 00:53:06.120
There's really no excuse
anymore not to use the Keychain.

00:53:06.140 --> 00:53:09.850
There used to be, prior to 4.0,
Keychain items didn't migrate

00:53:09.850 --> 00:53:11.300
if you had a new device.

00:53:11.300 --> 00:53:13.140
So, that was the reason some
developers were like,

00:53:13.210 --> 00:53:15.540
oh, we don't want to use the Keychain
because it's a bad user experience

00:53:15.540 --> 00:53:16.670
when the user gets a new phone.

00:53:16.670 --> 00:53:18.220
That's no longer the case.

00:53:19.100 --> 00:53:21.640
We want you to protect files
with the best possible data

00:53:21.640 --> 00:53:23.140
protection class available.

00:53:23.140 --> 00:53:25.170
And again,
the first example I showed you,

00:53:25.170 --> 00:53:28.400
if you're not running in the background,
just set the entitlement.

00:53:28.400 --> 00:53:29.060
You're done.

00:53:29.060 --> 00:53:29.860
No code.

00:53:31.390 --> 00:53:35.460
And then finally,
encrypt network traffic as appropriate.

00:53:35.460 --> 00:53:40.110
Here's a list of some
of the reference guides,

00:53:40.320 --> 00:53:46.600
talks about the different APIs we touched
on today that are related to security.

00:53:46.600 --> 00:53:50.690
With that,
I'd like to thank you all for coming.
WEBVTT

00:00:10.260 --> 00:00:10.700
Hi, everybody.

00:00:10.700 --> 00:00:12.060
My name is Jim Ingham.

00:00:12.060 --> 00:00:16.380
I've been working on GDB for, God,
a decade here at Apple.

00:00:16.380 --> 00:00:22.840
And for the past year and a half or so,
we've cooked up this new LLDB,

00:00:22.840 --> 00:00:26.350
which is our attempt to make
a modern version of something

00:00:26.350 --> 00:00:30.290
that will do all the tasks that
GDB has done for you in the past.

00:00:30.420 --> 00:00:37.030
And so we're here to tell you kind of
how you can start moving over to using

00:00:37.030 --> 00:00:40.180
LLDB from using GDB if you were a person.

00:00:40.200 --> 00:00:42.430
So here's what we'll talk about.

00:00:42.450 --> 00:00:46.120
I'm going to talk a little bit
about the LLDB command line

00:00:46.120 --> 00:00:49.150
and just its basic structure,
how you can get used to using it.

00:00:49.400 --> 00:00:52.840
And then a couple of the other members
of the debugger team will come up to

00:00:52.870 --> 00:00:54.960
talk about some power user features.

00:00:54.960 --> 00:00:58.610
So Sean Callanan will come up
and talk about how to make good

00:00:58.620 --> 00:01:03.050
use of the expression parser for
programmatic data introspection.

00:01:03.120 --> 00:01:06.730
And then Caroline Tice will come
up and talk about how to make

00:01:06.730 --> 00:01:10.180
use of the LLDB Python bindings,
which can do many things.

00:01:10.200 --> 00:01:13.770
But, you know, kind of like automate some
complex debugging tasks for you.

00:01:13.770 --> 00:01:16.370
So first of all,
there's this LLDB project.

00:01:16.370 --> 00:01:17.370
So what is that?

00:01:17.370 --> 00:01:19.840
That's our modern replacement for GDB.

00:01:19.840 --> 00:01:21.630
It's actually an open source project.

00:01:21.630 --> 00:01:23.600
It's part of the LLVM project,
thus the LL.

00:01:23.600 --> 00:01:26.840
It's supposed to stand for low level,
but it's not a low level debugger.

00:01:26.890 --> 00:01:28.110
Anyway, whatever.

00:01:28.120 --> 00:01:29.910
It's an open source project.

00:01:29.950 --> 00:01:32.730
It's most of the work has
so far been done by us.

00:01:32.810 --> 00:01:36.110
But anybody who is interested
in debuggers or wants to poke

00:01:36.210 --> 00:01:40.120
around at the guts of the system
is welcome to take a look at it.

00:01:40.200 --> 00:01:42.210
And give a hand if they want to.

00:01:42.210 --> 00:01:46.200
It's hosted at the LLVM site,
ldb.lvm.org, as you see.

00:01:46.200 --> 00:01:50.520
So we do take advantage of being
a part of the LLVM project.

00:01:50.520 --> 00:01:54.430
And we use the Clang type
system for our type system and

00:01:54.490 --> 00:01:58.810
for our expression evaluation,
which is nice because then

00:01:58.820 --> 00:02:00.980
they get to do work for us.

00:02:01.100 --> 00:02:04.060
We also designed it from the
start to have very efficient

00:02:04.060 --> 00:02:05.900
handling of debug information.

00:02:05.900 --> 00:02:09.270
So it has an incremental dwarf part,
whatever that means.

00:02:09.540 --> 00:02:10.180
Anyway, what it means is that it's a very
efficient handling of debug information.

00:02:10.180 --> 00:02:12.540
And what it means is that
hopefully it will be faster startup

00:02:12.670 --> 00:02:15.970
times and lower memory usage,
particularly as your projects get larger

00:02:15.970 --> 00:02:17.700
and have more and more debug information.

00:02:17.700 --> 00:02:21.870
Threads are a first class citizen,
as opposed to GDB, where they're kind of

00:02:21.870 --> 00:02:23.170
tacked onto the side.

00:02:23.170 --> 00:02:28.030
So that's becoming important as threads
become more ubiquitous in your programs.

00:02:28.030 --> 00:02:31.540
And finally,
we designed it from the start to have a

00:02:31.760 --> 00:02:34.490
first class powerful scripting component.

00:02:34.880 --> 00:02:37.900
In this case,
we implemented it with Python,

00:02:37.920 --> 00:02:41.400
but it actually uses this
SWIG interface generator.

00:02:41.400 --> 00:02:44.500
So I mean, if you said, I hate Python,
I must have blah, blah, blah.

00:02:44.500 --> 00:02:46.780
And then it's an open source project,
we'll tell you it's an

00:02:46.780 --> 00:02:49.080
open source project,
why don't you go fit it to whatever blah,

00:02:49.080 --> 00:02:51.860
blah, blah is, and then you would say,
No, I'll use Python instead.

00:02:57.500 --> 00:07:14.400
[Transcript missing]

00:07:14.700 --> 00:14:43.800
[Transcript missing]

00:14:44.290 --> 00:14:49.200
We tried to make a few little convenience
things when we print out the registers,

00:14:49.210 --> 00:14:51.970
which ends up actually
being surprisingly useful.

00:14:52.340 --> 00:14:55.810
So if you see here's a register dump,
but in this case,

00:14:55.810 --> 00:14:59.030
one of the register values
pointed into a string section,

00:14:59.030 --> 00:15:01.500
so why not look up the string for you,
which we do.

00:15:01.590 --> 00:15:04.080
And one of them pointed into text,
so we tell you the

00:15:04.080 --> 00:15:05.510
function name in the text.

00:15:05.590 --> 00:15:07.620
That's convenient.

00:15:09.230 --> 00:15:14.220
So the main thing I want to tell you
about now is this alias facility,

00:15:14.220 --> 00:15:16.880
because I think that as you
get used to the program,

00:15:16.880 --> 00:15:21.460
you'll find that you can mold it to your
working patterns using this facility.

00:15:21.460 --> 00:15:25.010
So as I say, having this kind of
turgid object actions,

00:15:25.010 --> 00:15:29.070
dash, dash, something, something,
it makes it really easy

00:15:29.070 --> 00:15:32.340
to find and document,
but it makes it hard to type.

00:15:32.460 --> 00:15:35.280
So you have to start having
accelerator commands,

00:15:35.560 --> 00:15:38.620
obviously, and by default,
we ship with a GDB-like set,

00:15:38.620 --> 00:15:42.960
which should cover most of the common
operations that you'll need to do.

00:15:42.960 --> 00:15:46.420
They're all listed in the help,
so if you do just help itself,

00:15:46.540 --> 00:15:49.790
you'll see the list of built-in
commands and then the list of

00:15:49.950 --> 00:15:52.160
aliases that we've set up for you.

00:15:52.340 --> 00:15:54.810
But again, as you work,
you may do something all the time,

00:15:54.810 --> 00:15:58.200
which is not one of the things that
we expected you would do all the time.

00:15:58.200 --> 00:16:02.360
And so we want to allow you to
be able to write a shortcut.

00:16:02.460 --> 00:16:04.850
So there are two kinds of shortcuts.

00:16:04.970 --> 00:16:08.380
There's a simple one,
which is positional aliases,

00:16:08.380 --> 00:16:12.630
and then there's one that if you
have learned regular expression and

00:16:12.630 --> 00:16:15.280
you go hunting the world looking
for uses of regular expression,

00:16:15.280 --> 00:16:18.330
because you learned that aren't thing
and you've got to use it for something,

00:16:18.330 --> 00:16:20.170
then there's one that
you can use that for.

00:16:20.200 --> 00:16:22.300
So the positional aliases.

00:16:22.300 --> 00:16:25.060
These ones are just trivial to write.

00:16:25.060 --> 00:16:27.960
The command that creates
them is this command alias.

00:16:28.100 --> 00:16:29.230
You say, oh, I just clicked too much.

00:16:29.240 --> 00:16:29.810
Anyway, never mind.

00:16:30.030 --> 00:16:31.740
And then the alias name.

00:16:32.180 --> 00:16:33.690
What you are going to type.

00:16:33.880 --> 00:16:37.000
And then the substitute command line,
which is the command that will get run.

00:16:37.000 --> 00:16:39.920
So in the simplest case,
this is just straight substitution.

00:16:39.920 --> 00:16:44.050
So you say command alias step
is going to be thread step in.

00:16:44.060 --> 00:16:47.160
So then when you type step,
then what's actually going

00:16:47.160 --> 00:16:48.980
to get run is thread step in.

00:16:48.980 --> 00:16:51.880
If you were keeping a sharp eye,
you would have noticed in the

00:16:52.020 --> 00:16:55.580
case when I set a breakpoint,
it actually, I used in the first slide,

00:16:55.600 --> 00:16:56.680
I said be something.

00:16:56.680 --> 00:16:59.710
And it actually printed out
the command that it actually

00:16:59.710 --> 00:17:01.460
ran and then did the command.

00:17:01.460 --> 00:17:02.160
So you can.

00:17:02.160 --> 00:17:03.730
Learn how that works for yourself.

00:17:03.880 --> 00:17:07.930
And if you've made an alias,
then any additional arguments typed after

00:17:07.930 --> 00:17:12.660
the name of your alias will just get
appended to the substitute command line.

00:17:12.660 --> 00:17:15.190
In this case,
I'm doing dash avoid no debug false,

00:17:15.420 --> 00:17:17.510
and it's just getting
appended to the end.

00:17:17.540 --> 00:17:21.990
The reason they're called positional is
the other little bit of sophistication

00:17:22.060 --> 00:17:26.470
is that you can route arguments from the
substitution from the command that the

00:17:26.520 --> 00:17:30.130
user types into the substitution string,
which is particularly

00:17:30.400 --> 00:17:31.900
useful if you have two.

00:17:31.940 --> 00:17:36.000
Option value pairs and you want
to jam stuff into the two values.

00:17:36.140 --> 00:17:41.020
So the way you do that is you put percent
and some number in the command line,

00:17:41.050 --> 00:17:43.940
the substitution command string,
and then that will get filled with

00:17:43.940 --> 00:17:46.880
the argument of that number in the
command that actually gets run.

00:17:47.200 --> 00:17:50.040
So here, for instance,
I've made an alias which has

00:17:50.040 --> 00:17:52.840
a count in percent one and
a start address percent two.

00:17:53.240 --> 00:17:56.850
And then when I type it,
then it gets substituted in,

00:17:56.850 --> 00:18:00.710
but in the wrong order because
I didn't do the slides right.

00:18:00.880 --> 00:18:01.540
Um.

00:18:01.580 --> 00:18:04.710
And then, of course,
any additional arguments

00:18:04.710 --> 00:18:08.290
are appended to the end,
just like you would expect.

00:18:09.300 --> 00:18:11.960
In this case, though,
all the arguments are required.

00:18:12.050 --> 00:18:14.550
So if I said there was a
percent 1 and a percent 2,

00:18:14.630 --> 00:18:17.830
there's got to be a
percent 1 and a percent 2.

00:18:18.500 --> 00:21:16.300
[Transcript missing]

00:21:16.590 --> 00:21:18.500
So altogether,
the command looks like this then.

00:21:18.500 --> 00:21:21.870
I would say command regx,
I'm going to call it dfancy or whatever.

00:21:21.930 --> 00:21:24.130
And I gave myself help because
I'm going to forget how it works.

00:21:24.190 --> 00:21:26.780
And then you hit a return,
it will very nicely tell

00:21:26.780 --> 00:21:28.040
you what you have to do.

00:21:28.040 --> 00:21:30.940
So then you'll type them all in,
whatever, whatever.

00:21:30.940 --> 00:21:33.830
I'm going to go really fast
so you can't see my bug.

00:21:33.840 --> 00:21:36.520
And then this is just like I didn't lie,
right?

00:21:36.640 --> 00:21:39.010
We could do it in a demo,
but the slides I could

00:21:39.010 --> 00:21:40.150
have just typed in.

00:21:40.210 --> 00:21:42.350
So I might be out lying, I don't know.

00:21:42.350 --> 00:21:45.300
But the help works,
and then the command works.

00:21:47.110 --> 00:21:50.510
Okay, so summarizing this little
subsection of the talk,

00:21:50.650 --> 00:21:53.780
what I hope you come away with is that,
you know, to get started,

00:21:53.780 --> 00:21:57.580
what you have to do is, you know,
figure out how the top-level

00:21:57.600 --> 00:22:00.390
objects are laid out,
and then remember that help will

00:22:00.390 --> 00:22:02.490
always tell you what you need,
and tab will always

00:22:02.490 --> 00:22:03.550
tell you what you need.

00:22:03.560 --> 00:22:06.670
And then once you get more
familiar with what's going on,

00:22:06.770 --> 00:22:10.320
you can use the shortcut aliases
that we've provided for you.

00:22:10.320 --> 00:22:13.160
Actually, we'll probably use those first,
and then start typing the more

00:22:13.230 --> 00:22:14.720
verbose ones as you get further in.

00:22:15.160 --> 00:22:17.020
And then finally,
as you watch your behavior,

00:22:17.020 --> 00:22:20.140
you can start to construct
these shortcuts for yourself.

00:22:20.140 --> 00:22:21.760
So with that,
I'd like to turn it over to Sean,

00:22:21.760 --> 00:22:23.900
who's going to tell you
about the Expression Parser.

00:22:23.900 --> 00:22:24.380
Thank you.

00:22:27.060 --> 00:22:27.320
Thank you, Jim.

00:22:30.880 --> 00:22:32.300
I'm Sean Callanan.

00:22:32.340 --> 00:22:35.110
I worked on the expression
parser for LLDB,

00:22:35.110 --> 00:22:37.160
and I'm very excited to
show it to you today.

00:22:37.270 --> 00:22:39.680
Now, there's going to be some excitement,
there's going to be some drama,

00:22:39.860 --> 00:22:42.700
but first, let's start with the basics.

00:22:43.300 --> 00:22:47.090
You've got a program,
and you'd like to use the expression

00:22:47.190 --> 00:22:49.520
parser to examine it a little bit.

00:22:49.580 --> 00:22:53.760
Now, Jim just sold you on it earlier,
telling you you could do all

00:22:53.900 --> 00:22:55.660
sorts of low-level introspection.

00:22:55.690 --> 00:22:57.640
Now, let's see if that's actually true.

00:22:57.640 --> 00:23:02.680
Now, you're sitting at the LLDB prompt,
and the first thing you do is

00:23:02.680 --> 00:23:05.340
you've got to run your program.

00:23:05.510 --> 00:23:08.600
So you set a breakpoint
at a particular stop,

00:23:08.600 --> 00:23:12.760
or place where you want to stop,
and then you type run.

00:23:12.810 --> 00:23:17.550
You may be familiar with the syntax
from GDB if you've used GDB in the past.

00:23:17.780 --> 00:23:21.360
And just like you would expect,
the program will run

00:23:21.360 --> 00:23:23.310
and hit your breakpoint.

00:23:23.390 --> 00:23:26.090
Now you can use the expression command.

00:23:26.330 --> 00:23:30.930
Now I'm going to type it out here just
so you can see the full name of it,

00:23:30.930 --> 00:23:33.400
but you can also shorten it,
and I'm going to be shortening

00:23:33.400 --> 00:23:35.040
it later in the slides.

00:23:35.190 --> 00:23:39.460
So here we're going to just type a
very simple arithmetic expression,

00:23:39.530 --> 00:23:40.770
nothing fancy.

00:23:41.360 --> 00:23:46.560
And what you have happen in the
program is it's like a set of curly

00:23:46.560 --> 00:23:50.110
braces is inserted into your program,
creating a new scope,

00:23:50.260 --> 00:23:54.730
and your arithmetic expression is
put right in there and evaluated.

00:23:55.350 --> 00:23:59.300
Now, what happens after the evaluation
is you get the result back

00:23:59.360 --> 00:24:01.440
as a new result variable.

00:24:01.550 --> 00:24:03.540
Now,
your result variables are kind of cool.

00:24:03.650 --> 00:24:07.640
They're stored inside your
program's memory so you can

00:24:07.640 --> 00:24:09.660
access them like pointers.

00:24:09.760 --> 00:24:15.350
And they stay around for as long
as you're debugging your program.

00:24:15.710 --> 00:24:20.280
Then, once you've done this,
your code gets taken back out

00:24:20.410 --> 00:24:23.630
because obviously you don't want to
continue and keep running 3 plus 5.

00:24:23.640 --> 00:24:29.420
And when you continue,
your program just runs as normal.

00:24:29.670 --> 00:24:32.700
All right, well,
that's the simple arithmetic expressions,

00:24:32.700 --> 00:24:35.990
but I doubt you need
LLDB to compute 3 plus 2.

00:24:36.170 --> 00:24:39.060
So let's do something a little fancier.

00:24:39.220 --> 00:24:40.820
So I've inserted a new expression.

00:24:40.860 --> 00:24:42.440
So notice something, first of all.

00:24:42.490 --> 00:24:48.920
I've shortened expression down to expert
because I need space on my slides.

00:24:48.920 --> 00:24:48.920
So

00:24:49.390 --> 00:24:52.100
You still get your set
of braces inserted,

00:24:52.220 --> 00:24:55.100
but you can do cool things,
like you can access your

00:24:55.100 --> 00:24:57.290
program local variables.

00:24:57.410 --> 00:24:59.940
Now, that's not too fancy.

00:24:59.940 --> 00:25:01.690
I mean, it's kind of cool.

00:25:01.910 --> 00:25:04.740
But let's go and try
something even neater.

00:25:04.850 --> 00:25:07.600
So, you've got a -- you just
accessed a variable that

00:25:07.660 --> 00:25:10.100
already existed in the program,
right?

00:25:10.200 --> 00:25:13.100
Well, maybe you need a new variable.

00:25:13.350 --> 00:25:18.570
Now we get to see the power of LLDB's
expressions starting to peak out.

00:25:18.690 --> 00:25:22.860
LLDB's expressions are actually
using LLVM under the hood to

00:25:22.920 --> 00:25:25.360
compile your expressions for you.

00:25:25.510 --> 00:25:28.430
When I said there was a pair
of curly braces in there,

00:25:28.550 --> 00:25:31.860
that's actually because you're
getting a scope to execute some code.

00:25:32.030 --> 00:25:37.320
So if you declare an integer variable
and you actually use that variable,

00:25:37.720 --> 00:25:41.300
Also note that I have a
multi-line expression here.

00:25:41.300 --> 00:25:45.530
I pressed enter after the expert command
so you can actually enter multiple lines.

00:25:45.770 --> 00:25:50.010
You get these multiple lines
inserted into your new scope,

00:25:50.010 --> 00:25:54.110
and now you can use
your temporary variable.

00:25:54.430 --> 00:25:58.600
That expression local variable, though,
goes away after your

00:25:58.600 --> 00:26:01.300
expression completes.

00:26:01.340 --> 00:26:06.590
Now, obviously,
that's not all you might want to do.

00:26:06.690 --> 00:26:09.340
You might want to keep your
expression local variables around.

00:26:09.340 --> 00:26:13.290
Now, you know the result variable
that I showed you earlier,

00:26:13.290 --> 00:26:14.580
the little $0.

00:26:14.580 --> 00:26:18.020
What if you could create
your own user variables?

00:26:18.060 --> 00:26:21.010
Now,
the GDB gurus among you may know that

00:26:21.010 --> 00:26:23.540
you use the set command for that.

00:26:23.940 --> 00:26:28.390
Well, we've got the same kind of concept,
except you do this all from

00:26:28.390 --> 00:26:30.680
inside the expression command.

00:26:30.710 --> 00:26:35.820
Inside the expression command now,
you can actually create a $ variable

00:26:36.000 --> 00:26:41.690
that stores your value for you in
the program's memory for as long

00:26:41.760 --> 00:26:44.410
as you're debugging the program.

00:26:44.740 --> 00:26:51.840
So I'm going to say $i equals
3 and then compute $i plus 2.

00:26:51.870 --> 00:26:55.730
The $i variable gets
inserted as a new global.

00:26:56.510 --> 00:27:00.780
The instructions referencing it
get inserted into your program,

00:27:00.830 --> 00:27:02.350
and they run.

00:27:03.190 --> 00:27:06.640
Now, I've showed you how to
access simple variables,

00:27:06.760 --> 00:27:08.440
how to create your own ones.

00:27:08.490 --> 00:27:12.090
In C++,
things are going to act like you expect.

00:27:12.190 --> 00:27:15.100
Your code is going to get inserted
into the method you're stopped in,

00:27:15.310 --> 00:27:17.810
and you can access the
C++ member variables.

00:27:17.900 --> 00:27:21.430
And if you're in an Objective-C object,
it gets inserted into

00:27:21.430 --> 00:27:24.120
the Objective-C method,
and you get to access

00:27:24.120 --> 00:27:25.830
your instance variables.

00:27:26.030 --> 00:27:28.820
You're not going to get
any nasty surprises.

00:27:29.390 --> 00:27:30.140
All right.

00:27:30.190 --> 00:27:31.420
Well, I showed you a bunch of stuff.

00:27:31.610 --> 00:27:33.740
Let's just go through the summary
and then get on to the fun.

00:27:33.740 --> 00:27:34.680
The drama.

00:27:34.680 --> 00:27:35.800
I promised you drama, right?

00:27:35.980 --> 00:27:39.700
So you've got in-scope variables
that you can access just

00:27:39.860 --> 00:27:42.120
using the expression command.

00:27:42.120 --> 00:27:45.840
You can kind of think of it like GDB's
print command for this kind of purpose.

00:27:45.880 --> 00:27:49.670
You can also access your globals and
variables and your functions for which

00:27:49.710 --> 00:27:51.820
you already have debug information.

00:27:52.020 --> 00:27:53.880
Now,
there's a little bit of a wrinkle here,

00:27:53.950 --> 00:27:58.680
just as there was with GDB, by the way,
that if you don't have debug information,

00:27:58.700 --> 00:28:03.320
for example, if it's a function that you
got from the standard library,

00:28:03.320 --> 00:28:07.120
then you have to cast
the return value for it.

00:28:07.210 --> 00:28:10.080
And if it's a variable you
got from the standard library,

00:28:10.080 --> 00:28:13.590
you have to cast the variable to
the type you're expecting it to be.

00:28:15.930 --> 00:28:18.660
You can declare your own expression
local variables that live as

00:28:18.660 --> 00:28:20.680
long as the expression does.

00:28:20.810 --> 00:28:25.110
And you can create user variables,
declaring them once using

00:28:25.180 --> 00:28:27.190
the special dollar sign.

00:28:27.900 --> 00:28:32.720
and then referring to them in later
expressions just whenever you need them.

00:28:32.720 --> 00:28:36.060
Alright, now let's do something
a little bit more fun.

00:28:36.070 --> 00:28:38.300
Let's debug an RPN calculator.

00:28:38.320 --> 00:28:44.600
Now RPN is reverse perlic notation,
and what you do is you type in numbers,

00:28:44.600 --> 00:28:49.800
and then you type in operations to,
that operate on the numbers

00:28:49.890 --> 00:28:51.420
you've already put in.

00:28:51.550 --> 00:28:56.120
So in this case we put in seven
and five and we said plus,

00:28:56.120 --> 00:28:58.520
it pulls in the last two
numbers and adds them.

00:28:58.530 --> 00:29:01.840
Now the way this is implemented
is usually as a stack.

00:29:01.970 --> 00:29:06.100
So when I type seven,
seven gets pushed onto the stack,

00:29:06.110 --> 00:29:08.630
and when I type five,
then five gets pushed

00:29:08.630 --> 00:29:10.040
onto the stack after it.

00:29:10.040 --> 00:29:14.440
And then when I do the plus operation,
I get a 12 at the end,

00:29:14.440 --> 00:29:16.540
which is kind of what you'd expect.

00:29:16.540 --> 00:29:19.140
I'm not gonna debug that
kind of simple bug for you.

00:29:19.480 --> 00:29:23.070
Alright, now let's do something
a little bit more fun.

00:29:23.290 --> 00:29:25.810
First I'm gonna plus seven,
and now I'm gonna try

00:29:25.940 --> 00:29:27.800
using the add command.

00:29:27.920 --> 00:29:28.760
Oh!

00:29:28.820 --> 00:29:34.010
I'm sure you've seen this error before.

00:29:35.110 --> 00:29:37.000
So you're stuck at a segmentation fault.

00:29:37.010 --> 00:29:37.680
What do you do?

00:29:37.690 --> 00:29:41.020
Well, if you've used GDB in the
past or you use Xcode,

00:29:41.100 --> 00:29:44.080
you know we opened the debugger.

00:29:44.680 --> 00:29:46.760
So let's open the debugger
and let's think about how

00:29:46.760 --> 00:29:47.840
we're going to deal with this.

00:29:47.850 --> 00:29:54.440
Well, the first thing you do is you
run LLDB on your RPN calculator.

00:29:54.450 --> 00:30:03.080
Now, you type run and your RPN calculator
is running inside LLDB.

00:30:03.110 --> 00:30:07.030
Then we reproduce the bug
and the program crashes.

00:30:07.200 --> 00:30:08.940
LLDB catches you.

00:30:08.950 --> 00:30:13.390
Now let's try running a backtrace
to see what we can do about this.

00:30:13.690 --> 00:30:17.550
Now this is the moment where some
of you are going to start saying,

00:30:17.600 --> 00:30:22.480
"Uh,
because we have no debug information."

00:30:22.590 --> 00:30:25.520
This is all assembly offsets.

00:30:25.650 --> 00:30:30.320
So you're at add plus 33,
which means 33 bytes into

00:30:30.320 --> 00:30:32.160
the assembly code for add.

00:30:32.270 --> 00:30:34.710
What the heck are you going to do here?

00:30:34.920 --> 00:30:38.500
This is where LLDB is going
to come to your rescue.

00:30:38.640 --> 00:30:42.240
So the first thing we need to do,
because we want to be

00:30:42.240 --> 00:30:45.810
at the beginning of add,
where the arguments are kind of in

00:30:45.810 --> 00:30:49.680
registers where you'd like them to be,
so we're going to set a

00:30:49.680 --> 00:30:51.820
breakpoint on the add function.

00:30:52.120 --> 00:30:53.640
Now we run again.

00:30:53.680 --> 00:30:57.200
LLDB asks you, oh, wait,
do you want to restart your program?

00:30:57.200 --> 00:30:58.760
Fine, it's an RPM calculator.

00:30:58.760 --> 00:31:01.640
It's not exactly doing a
lot of Internet interactions

00:31:01.640 --> 00:31:02.470
and stuff like that.

00:31:02.790 --> 00:31:06.440
So we're going to say 7 and
plus and reproduce your bug.

00:31:06.620 --> 00:31:11.160
So now when you do a backtrace,
you notice you're right at the

00:31:11.160 --> 00:31:13.890
beginning of the add function.

00:31:14.000 --> 00:31:16.550
This is where you can get your
arguments out of registers,

00:31:16.790 --> 00:31:19.070
and that's what we're going to do.

00:31:19.880 --> 00:31:24.040
I'm going to first of all pull out the
first argument for the add function,

00:31:24.040 --> 00:31:27.540
and you're going to have to believe
me that that's a pointer to the stack.

00:31:27.850 --> 00:31:31.700
So when you do that,
you get the hexadecimal output of that.

00:31:31.720 --> 00:31:35.700
Notice I used the --format command here.

00:31:35.730 --> 00:31:43.170
The --format option tells LLDB what
format you'd like your output

00:31:43.290 --> 00:31:44.860
to be in from your expressions.

00:31:45.100 --> 00:31:46.780
So X means hexadecimal.

00:31:46.960 --> 00:31:49.770
You don't have to remember this.

00:31:49.770 --> 00:31:49.770
There's help on it.

00:31:50.170 --> 00:31:54.180
Now, let's try doing something
fancy with this.

00:31:54.260 --> 00:31:56.640
First of all, I'm going to enter a
multiline expression,

00:31:56.670 --> 00:31:59.340
again,
by pressing Enter after I type EXPR.

00:31:59.340 --> 00:32:05.020
Now, I'm going to redefine the type
that was missing because we

00:32:05.110 --> 00:32:06.500
didn't have debug information.

00:32:06.500 --> 00:32:12.060
I redefine my type and create a
new user variable of that type.

00:32:12.420 --> 00:32:13.500
It's actually a double pointer.

00:32:13.500 --> 00:32:17.410
And I'm going to assign
the $arg1 argument register

00:32:17.840 --> 00:32:19.490
to that new user variable.

00:32:19.500 --> 00:32:21.760
This user variable now has the type.

00:32:21.860 --> 00:32:23.360
I can actually access it.

00:32:23.490 --> 00:32:28.300
This is something that wasn't
really possible in GDB.

00:32:28.570 --> 00:32:31.480
You had to use weird hacks,
examine memory directly.

00:32:31.630 --> 00:32:32.500
Why do you want to do that?

00:32:32.500 --> 00:32:35.450
That's like, then you have to remember
all these obscure commands.

00:32:35.500 --> 00:32:36.490
You really want to do that.

00:32:36.500 --> 00:32:38.500
You really want to just be using types.

00:32:38.500 --> 00:32:41.490
And because we've got Clang
under the hood working for you,

00:32:41.530 --> 00:32:42.500
you can do that.

00:32:43.690 --> 00:32:46.820
So,
now let's look at the stack entry that

00:32:46.820 --> 00:32:49.250
we've got on the top of our stack.

00:32:49.680 --> 00:32:52.920
Well, the value is 7,
which makes sense because

00:32:53.110 --> 00:32:55.180
we typed 7 in at the prompt.

00:32:55.710 --> 00:32:59.460
But the next pointer is null,
and we're in the add function,

00:32:59.500 --> 00:33:03.590
so it's looking at a null pointer
to try to get out the next element.

00:33:03.900 --> 00:33:07.640
Well, that probably doesn't come
as a surprise to all of you,

00:33:07.640 --> 00:33:13.400
but we've got a stack with one element,
and we're trying to add two elements.

00:33:13.470 --> 00:33:14.930
Well, all right, fine.

00:33:15.250 --> 00:33:17.420
So let's try to fix this.

00:33:18.550 --> 00:33:22.370
You're going to use the push
function from your program to

00:33:22.500 --> 00:33:24.440
push a new element on the stack.

00:33:24.600 --> 00:33:26.700
Remember that we don't
have debug information,

00:33:26.700 --> 00:33:28.930
so you have to cast.

00:33:29.050 --> 00:33:33.010
And then, if you now look at the next
element of the top of the stack,

00:33:33.010 --> 00:33:36.100
you see, aha, there's something there.

00:33:36.180 --> 00:33:39.840
So now it's safe to continue
and let add do its work.

00:33:39.840 --> 00:33:41.440
And now we've fixed the problem.

00:33:41.440 --> 00:33:42.940
We've got 10 on the top of the stack.

00:33:42.940 --> 00:33:49.240
And hopefully,
you see how we've done that.

00:33:49.240 --> 00:33:52.580
Now the next thing I'd like to
show you is something a little

00:33:52.580 --> 00:33:55.770
bit cleverer and something that
showcases even more for you just the

00:33:55.790 --> 00:33:58.080
power that's under the hood here.

00:33:58.080 --> 00:34:03.290
Now let's do stop and add again after
putting some numbers onto the stack.

00:34:04.350 --> 00:34:08.480
We are going to enter a
multiline expression again.

00:34:08.480 --> 00:34:12.840
And now we're going to have to enter
the struct that we entered before.

00:34:13.140 --> 00:34:14.710
Now, why is this?

00:34:14.820 --> 00:34:18.110
It's because, remember,
we had a pair of curly braces that your

00:34:18.110 --> 00:34:20.150
expression is being executed inside.

00:34:20.150 --> 00:34:21.920
That means that there's a scope there.

00:34:21.920 --> 00:34:25.930
And things like the types that you
temporarily defined here are actually

00:34:26.230 --> 00:34:27.870
going to go out of scope for you.

00:34:27.900 --> 00:34:31.650
So you've got to remember to redefine
your types if you actually create

00:34:31.770 --> 00:34:33.670
new variables of that type again.

00:34:34.300 --> 00:34:37.800
So here we're going to
create a depth counter.

00:34:37.800 --> 00:34:39.080
And then we're going to use a for loop.

00:34:39.130 --> 00:34:44.620
We're going to use this iterator called
current to walk across our stack.

00:34:44.620 --> 00:34:47.740
And at each time we
walk across an element,

00:34:47.740 --> 00:34:51.270
we're going to increment
our depth counter.

00:34:51.710 --> 00:34:54.580
Finally, we tell it to report depth.

00:34:54.580 --> 00:34:57.560
We press enter, leave a blank line,
which I didn't show you here,

00:34:57.560 --> 00:34:59.750
but you have to do that at the
end of a multi-line expression.

00:34:59.780 --> 00:35:02.220
And then you get the result out,
which is two.

00:35:02.220 --> 00:35:04.350
Now, this is kind of cool.

00:35:04.370 --> 00:35:06.280
This is something you really couldn't do.

00:35:06.280 --> 00:35:10.010
There's this for loop here,
where you're using pointers and

00:35:10.010 --> 00:35:13.520
iterating across a data structure,
which incidentally wasn't

00:35:13.560 --> 00:35:15.040
even in the debug information.

00:35:15.900 --> 00:35:20.470
This is really where you're starting
to see that Clang is letting LLDB do

00:35:20.470 --> 00:35:23.460
things that you just couldn't do before.

00:35:23.480 --> 00:35:25.350
All right.

00:35:32.280 --> 00:35:37.260
And the real power comes when you start
to use this every day and realize,

00:35:37.300 --> 00:35:40.000
oh, wow, I don't have to worry.

00:35:40.980 --> 00:35:45.260
So let's summarize.

00:35:45.410 --> 00:35:49.980
So you can use the expression parser
to interact directly with your code.

00:35:50.300 --> 00:35:53.080
You can use registers,
you can use variables,

00:35:53.130 --> 00:35:56.910
you can use functions just
the way you would expect.

00:35:57.620 --> 00:36:01.580
You can create your own user
variables remembering the dollar sign,

00:36:01.600 --> 00:36:04.920
just the way you would
declare a normal C variable.

00:36:05.210 --> 00:36:08.650
And you can reconstruct the program
state with the help of these type

00:36:08.770 --> 00:36:11.980
definitions without debug information.

00:36:12.100 --> 00:36:15.740
You can use full objective
C++ in your expressions.

00:36:15.820 --> 00:36:18.530
Remember that for loop that we wrote?

00:36:19.600 --> 00:36:27.810
These kinds of features are what's making
LLDB the best debugger you've ever used.

00:36:28.430 --> 00:36:34.350
So let me show-- so the help expression
command will give you more information

00:36:34.350 --> 00:36:36.540
on the expression command's options.

00:36:36.540 --> 00:36:41.090
Most of them center around the kind of
output formatting I showed you earlier.

00:36:41.580 --> 00:36:44.770
and in any case,
you should just try to explore it.

00:36:44.770 --> 00:36:46.110
Try it out on your own.

00:36:46.490 --> 00:36:47.820
See what you can do.

00:36:47.940 --> 00:36:49.260
Thank you very much for your time.

00:36:49.300 --> 00:36:53.460
I'm going to pass you on to Caroline,
who's going to tell you

00:36:53.460 --> 00:36:53.460
about Python integration.

00:37:00.700 --> 00:37:01.580
Hi there.

00:37:01.590 --> 00:37:03.920
My name is Caroline Tice,
and I'm an engineer

00:37:03.920 --> 00:37:04.860
in the debugger group.

00:37:04.940 --> 00:37:07.170
And in this part of the talk,
we're going to be going over

00:37:07.200 --> 00:37:09.270
scripting and Python in LLDB.

00:37:09.400 --> 00:37:12.290
Now, I know that a lot of you have
been using GDB for years,

00:37:12.390 --> 00:37:14.590
and you've never written a script,
you've never wanted to write a script,

00:37:14.670 --> 00:37:16.020
you can't imagine wanting
to write a script.

00:37:16.100 --> 00:37:18.390
And you're probably asking
yourself if now wouldn't be a good

00:37:18.480 --> 00:37:19.700
time to go get a cup of coffee.

00:37:19.800 --> 00:37:21.700
Well, the short answer is no.

00:37:21.830 --> 00:37:23.720
If you miss this part of the talk,
you're really going to

00:37:23.760 --> 00:37:24.650
end up kicking yourself.

00:37:24.800 --> 00:37:27.800
We've made scripting in
LLDB extremely easy to use,

00:37:27.800 --> 00:37:29.000
extremely easy to access.

00:37:29.100 --> 00:37:32.290
We've fully integrated it with Python,
and we've added a lot of extensions

00:37:32.330 --> 00:37:36.280
to make it more powerful,
and to make it better for accomplishing

00:37:36.280 --> 00:37:38.600
some of your debugging tasks.

00:37:38.600 --> 00:37:40.970
In short,
scripting in LLDB is actually going to

00:37:41.070 --> 00:37:45.600
allow you to do a lot of things you've
only dreamed of being able to do in GDB.

00:37:45.600 --> 00:37:48.600
So let's dive right in and
see what I'm talking about.

00:37:48.620 --> 00:37:52.340
What can you do with scripting in LLDB?

00:37:52.830 --> 00:37:55.270
Well, to begin with,
it's going to allow you to set some

00:37:55.270 --> 00:37:57.600
really useful conditional breakpoints.

00:37:57.620 --> 00:38:00.640
So remember in LLDB,
you actually have access to

00:38:00.840 --> 00:38:02.600
the call stack as an object.

00:38:02.730 --> 00:38:06.540
This means you can query the call stack
and get useful information out of it.

00:38:06.630 --> 00:38:08.030
So therefore,
you can set conditions on your

00:38:08.300 --> 00:38:11.600
breakpoints based on things like
the name of the calling function.

00:38:11.730 --> 00:38:15.660
This is especially useful if you're
programming with Apple frameworks,

00:38:15.670 --> 00:38:17.600
which have lots of little functions
that are called everywhere,

00:38:17.600 --> 00:38:19.860
and you really don't care
about 90% of the places where

00:38:19.860 --> 00:38:21.100
those breakpoints are hit.

00:38:21.100 --> 00:38:23.430
You just want to see the breakpoints
where they're hit in your code.

00:38:23.600 --> 00:38:26.600
Well, now you can actually say,
I only want to stop on this breakpoint.

00:38:26.610 --> 00:38:27.600
When it is hit,
you can stop on this breakpoint.

00:38:27.600 --> 00:38:30.700
And the calling function
has a particular name,

00:38:30.700 --> 00:38:34.600
or when the calling function's
arguments have particular values.

00:38:34.600 --> 00:38:37.660
If you're doing multi-threaded debugging,
you can say,

00:38:37.660 --> 00:38:40.600
I want to collect information about
which thread hit this breakpoint,

00:38:40.600 --> 00:38:42.380
and I only want to stop
at this breakpoint if it's

00:38:42.460 --> 00:38:43.600
hit by a particular thread.

00:38:43.600 --> 00:38:45.510
You can trace the execution
of a particular thread.

00:38:45.600 --> 00:38:49.360
You can even record information about
which thread hit it last time and say,

00:38:49.650 --> 00:38:52.640
I only want to stop there if the
same thread hits it the next time,

00:38:52.640 --> 00:38:53.600
or if a different thread
hits it the next time.

00:38:53.600 --> 00:38:56.250
Anyway, you have lots and lots of
options for setting breakpoint

00:38:56.250 --> 00:39:00.720
conditions on your breakpoints
that you just didn't have before.

00:39:00.800 --> 00:39:03.200
In addition to setting
breakpoint commands,

00:39:03.310 --> 00:39:06.740
you can also use scripting to help you
traverse your dynamic data structures.

00:39:06.740 --> 00:39:09.460
So you've got a huge tree or
a huge heap or a linked list.

00:39:09.460 --> 00:39:12.690
There's a piece of data that's missing
or it's wrong or you want to see if

00:39:12.760 --> 00:39:14.580
it's been inserted multiple times.

00:39:14.580 --> 00:39:16.100
You want to find the path to your data.

00:39:16.100 --> 00:39:18.830
And you can actually write useful
Python scripts to go through your data

00:39:18.940 --> 00:39:22.200
structures and help you figure out what's
going on in your code now more easily.

00:39:22.200 --> 00:39:25.410
In addition,
you can actually record information

00:39:25.410 --> 00:39:29.200
at breakpoints about your registers,
about your local variables.

00:39:29.200 --> 00:39:32.200
You can write this to Python variables.

00:39:32.200 --> 00:39:34.700
You can write it to files
using Python system calls.

00:39:34.700 --> 00:39:36.940
You can do this every time you
hit your breakpoint so you're

00:39:36.940 --> 00:39:38.200
starting to build up traces.

00:39:38.200 --> 00:39:40.200
You can do this across
multiple runs of your program.

00:39:40.200 --> 00:39:43.410
So this helps you collect a lot
of useful information when you're

00:39:43.480 --> 00:39:45.700
debugging that's going to let you
get your tasks done more easily.

00:39:45.700 --> 00:39:51.660
Finally, you can do this with -- use
Python scripts to help you do this.

00:39:51.700 --> 00:39:53.700
You can also use Python scripts to
help you do automated testing in QA.

00:39:53.700 --> 00:39:56.870
So especially if you have some
of these really evil bugs that

00:39:56.870 --> 00:39:59.720
you only hit once in a blue moon,
you can write scripts to help

00:39:59.720 --> 00:40:01.700
you collect data around where
you think the problem is.

00:40:01.700 --> 00:40:04.820
And then you can run your Python --
write Python scripts to run your

00:40:04.820 --> 00:40:07.320
program over and over again,
collecting data every

00:40:07.320 --> 00:40:10.330
time you run through it,
and eventually it will hit the problem

00:40:10.490 --> 00:40:14.170
and stop and you'll have this great set
of data to help you do your debugging.

00:40:14.920 --> 00:40:18.910
This is just a little idea of
some of the things that you

00:40:18.910 --> 00:40:20.680
can do with scripting in LLDB.

00:40:20.700 --> 00:40:24.700
I want to talk a little bit about
what you actually have where.

00:40:24.700 --> 00:40:27.700
You've probably already figured
out by now that you have

00:40:27.700 --> 00:40:29.700
Python embedded within LLDB.

00:40:29.700 --> 00:40:32.370
What you probably have not
figured out is that you also can

00:40:32.500 --> 00:40:34.700
have LLDB embedded in Python.

00:40:34.700 --> 00:40:36.670
So you can actually run
Python from the Unix prompt,

00:40:36.740 --> 00:40:41.930
not use Xcode, not use the LLDB debugger,
and load the LLDB Python module and

00:40:41.930 --> 00:40:44.560
be off and running LLDB inside Python.

00:40:44.700 --> 00:40:47.190
So I'm going to talk about this for
just a second because it's useful

00:40:47.240 --> 00:40:49.970
for some automated QA and testing,
and then we'll get back

00:40:49.970 --> 00:40:52.710
to the main program,
which is Python in LLDB.

00:40:52.990 --> 00:40:54.870
So if you're going to run
LLDB directly from Python,

00:40:54.870 --> 00:40:57.370
the first thing you have to do
is you have to tell Python where

00:40:57.370 --> 00:40:59.040
to find your LLDB Python module.

00:40:59.040 --> 00:41:03.960
So that's going to be located in
your resources Python subdirectory

00:41:03.960 --> 00:41:06.370
below your LLDB framework,
which is going to be on your,

00:41:06.530 --> 00:41:09.410
wherever you installed Xcode,
usually in your slash

00:41:09.510 --> 00:41:10.260
developer directory.

00:41:10.260 --> 00:41:13.410
Once you've told Python where
to find your LLDB module,

00:41:13.410 --> 00:41:17.160
you start Python at the Unix prompt,
you import your LLDB module,

00:41:17.160 --> 00:41:19.880
and there you go, you're off and running.

00:41:19.880 --> 00:41:23.090
You can now create a debugger,
you can create a target,

00:41:23.170 --> 00:41:25.510
you can set breakpoints,
you can run your process,

00:41:25.510 --> 00:41:28.480
you can do all of your debugging
tasks directly straight from Python.

00:41:28.480 --> 00:41:31.060
You've never touched Xcode,
you've never touched the LLDB debugger.

00:41:31.720 --> 00:41:34.880
Thank you.

00:41:36.390 --> 00:41:39.360
For more examples on how to do this,
you can look at the LLDB test suite.

00:41:39.410 --> 00:41:42.200
We do this a lot in the LLDB test suite,
so there are some great examples

00:41:42.200 --> 00:41:43.200
there that you can look at.

00:41:43.220 --> 00:41:48.180
These functions that I've
highlighted in yellow here,

00:41:48.180 --> 00:41:52.500
these are part of the API functions
that come with your LLDB Python module,

00:41:52.500 --> 00:41:55.330
and I'll be talking about them a
lot more later on in this talk.

00:41:56.870 --> 00:42:02.460
So moving back to our main program,
which is Python inside LLDB.

00:42:02.470 --> 00:42:06.400
LLDB contains a full and
complete Python interpreter.

00:42:06.400 --> 00:42:08.040
This means you get all
the syntax checking,

00:42:08.040 --> 00:42:10.000
all the parsing,
all the exception handling,

00:42:10.000 --> 00:42:13.840
all the error handling, the system calls,
the modules, the whole nine yards.

00:42:13.930 --> 00:42:16.860
We have all of Python available
to you inside LLDB.

00:42:16.860 --> 00:42:19.060
We've also made it very easy to access.

00:42:19.060 --> 00:42:23.100
There are many different ways you
can access Python from inside LLDB.

00:42:23.120 --> 00:42:25.820
To begin with,
you can use the one-line script command.

00:42:25.820 --> 00:42:26.700
So this is what you do.

00:42:26.700 --> 00:42:29.440
If you have just a little bit of Python,
you want to execute it,

00:42:29.510 --> 00:42:34.080
but you want to stay in your
main LLDB prompt environment.

00:42:34.080 --> 00:42:35.920
You don't want to drop into
Python in particularly.

00:42:35.920 --> 00:42:39.220
So in this case, I've said to Python,
I have this decimal number.

00:42:39.220 --> 00:42:41.790
I want you to convert it to hex,
give me the answer, and let me just stay

00:42:41.850 --> 00:42:42.900
here in my LLDB prompt.

00:42:42.940 --> 00:42:44.370
And that's exactly what it's done.

00:42:44.380 --> 00:42:47.830
If you want to do more complicated
or interactive Python stuff,

00:42:47.830 --> 00:42:51.780
you can drop into a Python interactive
interpreter from inside LLDB.

00:42:51.780 --> 00:42:54.630
This is going to be just like
typing Python at the Unix prompt,

00:42:54.740 --> 00:42:56.680
except we've already preloaded it.

00:42:56.680 --> 00:42:58.830
So we've already put the
LLDB Python module in there for you,

00:42:59.160 --> 00:43:01.920
and we've set up some additional
extensions to make it easy

00:43:01.920 --> 00:43:04.930
for you to be off and running
doing your debugging tasks.

00:43:05.270 --> 00:43:06.530
Thank you.

00:43:06.530 --> 00:43:10.720
And finally, as I said,
you can also attach Python scripts

00:43:10.840 --> 00:43:15.430
to your breakpoint commands,
so this is what it would

00:43:15.430 --> 00:43:15.430
look like to do that.

00:43:16.300 --> 00:48:25.000
[Transcript missing]

00:48:25.340 --> 00:48:27.510
Once we do that,
we're going to initialize

00:48:27.510 --> 00:48:30.510
our other parameter,
which starts out the current path

00:48:30.510 --> 00:48:34.100
as an empty string because we're
starting at the root of the tree.

00:48:34.100 --> 00:48:37.550
And then we're going to call
our depth-first search function.

00:48:37.550 --> 00:48:41.250
Our depth-first search function,
we have to tell Python that it's in

00:48:41.250 --> 00:48:45.140
the tree utils file that we imported,
so that's what that's all about.

00:48:45.230 --> 00:48:47.700
And again,
we pass it our binary search tree and

00:48:47.890 --> 00:48:49.800
our search word and our current path.

00:48:49.830 --> 00:48:52.630
We then print out the path
to see did it find the node,

00:48:52.630 --> 00:48:55.180
and sure enough, it found the node.

00:48:55.200 --> 00:48:58.180
We then print out the path to see if
it found the word "Romeo" in our tree,

00:48:58.210 --> 00:49:01.310
and the path from the root of the tree
to the node containing Romeo is left,

00:49:01.310 --> 00:49:02.830
left, right, right, left.

00:49:04.090 --> 00:49:06.860
At this point, we are halfway there.

00:49:06.990 --> 00:49:09.000
We have found our word in
the binary search tree,

00:49:09.000 --> 00:49:12.250
so the next question is,
why didn't our program find it?

00:49:12.250 --> 00:49:14.430
And how are we going to figure
out what the problem is?

00:49:14.540 --> 00:49:16.660
And the answer is,
we're going to use scripted

00:49:16.660 --> 00:49:17.880
breakpoint commands.

00:49:17.880 --> 00:49:20.770
So the idea is something like this.

00:49:20.850 --> 00:49:22.610
We know that our word is here.

00:49:22.620 --> 00:49:26.430
We know that a binary search
algorithm has two decision points.

00:49:26.570 --> 00:49:29.400
There's the decision to go right
and the decision to go left.

00:49:29.480 --> 00:49:31.900
We're going to set breakpoints at
each of these two decision points,

00:49:32.060 --> 00:49:34.060
and then we're going to attach
a breakpoint script command

00:49:34.060 --> 00:49:35.660
to each decision point.

00:49:35.810 --> 00:49:38.540
The script is going to compare
the decision with the path.

00:49:38.850 --> 00:49:42.890
As long as the decision matches what
the path says we should be doing,

00:49:42.900 --> 00:49:45.320
we're going to continue executing.

00:49:45.440 --> 00:49:49.070
As soon as we come to a decision where
our decision differs from the path,

00:49:49.150 --> 00:49:52.510
we're going to halt execution and say,
"Here is our problem."

00:49:52.910 --> 00:49:57.000
So this is what our Python breakpoint
command would look like.

00:49:57.140 --> 00:49:59.550
Before I go over this in great detail,
there's something that

00:49:59.680 --> 00:50:00.800
I need to tell you about.

00:50:01.020 --> 00:50:04.310
Whenever you write a
breakpoint command in LLDB,

00:50:04.330 --> 00:50:06.380
a Python breakpoint command,
it's going to take the

00:50:06.510 --> 00:50:08.780
code that you wrote,
and it's going to wrap it up

00:50:08.780 --> 00:50:10.560
in a Python script function.

00:50:10.560 --> 00:50:14.010
So it actually wraps it up in a function,
and it's going to pass in two more

00:50:14.010 --> 00:50:15.830
convenience variables for you.

00:50:15.850 --> 00:50:18.450
So it's going to pass in the frame
where the breakpoint was hit and

00:50:18.490 --> 00:50:21.420
the breakpoint location object
for the breakpoint that was hit.

00:50:22.340 --> 00:50:24.900
Now, there are two important things you
have to remember from all of this.

00:50:24.900 --> 00:50:27.380
The first one is that these
two convenience variables are

00:50:27.380 --> 00:50:29.610
there for you whenever you write
a breakpoint script command,

00:50:29.690 --> 00:50:32.050
so you can just assume that
they're there and you can use them.

00:50:32.050 --> 00:50:34.770
The other thing that you have to
remember is if you want to use a

00:50:34.770 --> 00:50:38.300
Python variable that was defined outside
of your breakpoint script command,

00:50:38.300 --> 00:50:40.400
you have to tell Python it's
a global variable.

00:50:40.490 --> 00:50:43.220
Otherwise, Python's going to think
it's local to the script,

00:50:43.290 --> 00:50:45.680
and you're going to get
unexpected behavior.

00:50:45.740 --> 00:50:48.880
When you actually hit your breakpoint,
when you're executing,

00:50:48.880 --> 00:50:51.040
Python is then going
to call this function.

00:50:51.040 --> 00:50:51.880
It's going to pass in the frame where
the breakpoint location object was hit,

00:50:51.880 --> 00:50:51.880
and it's going to wrap
it up in a Python script.

00:50:51.880 --> 00:50:51.880
So it's going to wrap it
up in a Python script.

00:50:51.880 --> 00:50:56.410
the correct frame and the correct
breakpoint location object for you.

00:50:56.610 --> 00:50:59.100
So, going over the code in a
little more detail now,

00:50:59.100 --> 00:51:01.700
the first thing I've done is I've told
Python that we're going to use the

00:51:01.810 --> 00:51:05.420
global path variable that we already got
from our depth-first search function.

00:51:05.420 --> 00:51:07.270
So we're using this variable
that we got in one point,

00:51:07.270 --> 00:51:08.480
and we're using it in another.

00:51:08.480 --> 00:51:12.320
We're going to compare our current
decision to go right with the path,

00:51:12.440 --> 00:51:14.390
with the beginning of the path.

00:51:14.500 --> 00:51:16.370
If the path says, yes,
you should be going right,

00:51:16.420 --> 00:51:18.750
then we're going to strip the
first character off the path,

00:51:18.750 --> 00:51:20.640
and then we're going to resume execution.

00:51:20.640 --> 00:51:24.330
We're going to resume execution using
this frame variable that we know

00:51:24.330 --> 00:51:26.130
LLDB is going to have there for us.

00:51:26.500 --> 00:51:29.270
We're going to call these
API functions to first get our

00:51:29.380 --> 00:51:32.170
thread and then get our process,
and once we have our process,

00:51:32.240 --> 00:51:33.770
we're going to resume execution.

00:51:33.810 --> 00:51:37.770
So what this looks like for the user is,
as long as the decision matches the path,

00:51:37.880 --> 00:51:39.380
execution just keeps running.

00:51:39.380 --> 00:51:41.570
The user never even sees
this breakpoint being hit.

00:51:41.680 --> 00:51:44.880
However, if the path differs from
what our decision point is,

00:51:44.880 --> 00:51:47.540
then we're going to stay halted,
and we're going to print this

00:51:47.540 --> 00:51:48.530
error message for the user.

00:51:48.640 --> 00:51:51.990
So let's see what this
looks like in execution.

00:51:52.060 --> 00:51:56.200
So we set our breakpoint command
on our breakpoint to go left.

00:51:56.390 --> 00:51:57.920
We've already seen what
breakpoint to go right.

00:51:57.980 --> 00:51:59.360
We've seen what that looks like.

00:51:59.440 --> 00:52:01.690
We add our breakpoint script command
to the breakpoint to go left.

00:52:01.920 --> 00:52:05.170
That looks just like the one to go right,
except you say left.

00:52:05.460 --> 00:52:06.580
We continue execution.

00:52:06.580 --> 00:52:08.710
It runs for a little bit,
and then it actually halts and prints

00:52:08.740 --> 00:52:09.740
out one of these error messages.

00:52:09.910 --> 00:52:11.960
So we did find a problem.

00:52:12.080 --> 00:52:14.900
So now let's examine what's
going on at this place where we

00:52:14.900 --> 00:52:16.800
found the problem in our program.

00:52:16.920 --> 00:52:22.180
We look at the word at the current root,
and the current word is dramatis.

00:52:22.400 --> 00:52:24.220
We say, okay, well,
what are we searching for again?

00:52:24.220 --> 00:52:26.050
We're searching for Romeo.

00:52:26.240 --> 00:52:28.220
We say,
since the tree is sorted alphabetically,

00:52:28.220 --> 00:52:30.840
Romeo should come after dramatis,
so going right seems like it

00:52:30.900 --> 00:52:32.720
ought to be the correct decision.

00:52:32.880 --> 00:52:35.140
But we were going to go right,
and our path apparently

00:52:35.140 --> 00:52:36.280
says we should go left.

00:52:36.440 --> 00:52:37.780
Let's ask Python one more time.

00:52:37.780 --> 00:52:42.860
Show us the path variable from the
current node to where you found Romeo.

00:52:42.860 --> 00:52:46.500
So we use one of these one-line
commands to say print the path variable.

00:52:46.500 --> 00:52:47.470
It prints the path variable.

00:52:47.520 --> 00:52:48.860
It's still left, left, right, right,
left.

00:52:48.860 --> 00:52:51.420
So surprisingly,
we actually hit the problem in

00:52:51.420 --> 00:52:53.240
the very first node of our tree.

00:52:53.260 --> 00:52:56.000
We say, okay, what is left, left, right,
right, left from here?

00:52:56.090 --> 00:52:58.530
And we print out the word,
and it says Romeo.

00:52:58.580 --> 00:53:03.000
But, aha,
we have an uppercase and a lowercase.

00:53:03.200 --> 00:53:05.590
There is a case conversion
problem in our program,

00:53:05.830 --> 00:53:08.590
and this is the bug.

00:53:09.410 --> 00:53:13.720
So this is an example of just some
of the stuff that you can do using

00:53:13.720 --> 00:53:17.700
Python and scripting in LLDB to
help you accomplish your tasks.

00:53:17.740 --> 00:53:21.130
Hopefully, I've shown you that LLDB makes
scripting very easy,

00:53:21.210 --> 00:53:23.370
very useful, and very powerful.

00:53:23.540 --> 00:53:24.950
I've shown you that you
can use the convenience

00:53:24.950 --> 00:53:26.640
variables in the API functions.

00:53:26.670 --> 00:53:29.860
They really help you accomplish
a lot of great things.

00:53:29.900 --> 00:53:32.920
I've demonstrated if you want
to do automated testing in QA,

00:53:32.920 --> 00:53:36.060
you can actually run LLDB from
inside Python at the Unix prompt,

00:53:36.090 --> 00:53:38.380
and you don't have to touch Xcode,
you don't have to touch

00:53:38.380 --> 00:53:39.560
the LLDB debugger.

00:53:39.600 --> 00:53:41.110
If you want more examples of that,
as I said,

00:53:41.110 --> 00:53:44.780
you can look in the LLDB test suite,
and there's just lots and lots of more

00:53:44.860 --> 00:53:46.500
cool stuff you can do with scripting.

00:53:46.500 --> 00:53:49.490
I've just shown you
the tip of the iceberg.

00:53:49.740 --> 00:53:52.400
Going over what we've covered
in this entire session,

00:53:52.400 --> 00:53:55.160
we've shown you the LLDB command
line with its object,

00:53:55.160 --> 00:53:55.940
act and syntax.

00:53:56.120 --> 00:53:59.780
We've shown you that you can use help
and apropos and the tab key to find all

00:53:59.940 --> 00:54:01.840
the commands you need to use in LLDB.

00:54:01.900 --> 00:54:05.570
We've shown you how to use aliases
to create simple shortcuts to

00:54:05.570 --> 00:54:07.200
do what you want to do easily.

00:54:07.460 --> 00:54:09.450
We've shown you,
you can use the expression parser to

00:54:09.450 --> 00:54:12.250
execute your code in your own program,
and you can even use it to help

00:54:12.340 --> 00:54:15.090
you debug when you don't actually
have debug information there,

00:54:15.150 --> 00:54:16.760
which is going to be very useful.

00:54:16.760 --> 00:54:20.110
I've shown you some of the
great cool stuff you can do with

00:54:20.110 --> 00:54:22.170
scripting in Python and LLDB.

00:54:22.320 --> 00:54:25.850
For more information,
you can go to the LLDB website.

00:54:26.180 --> 00:54:29.140
The LLDB website has great
information about LLDB in general.

00:54:29.140 --> 00:54:32.160
There's this tutorial for how
to do stuff in LLDB that you

00:54:32.160 --> 00:54:33.780
used to be able to do in GDB.

00:54:33.780 --> 00:54:38.100
The entire scripting example with all the
code for the depth-first search function,

00:54:38.110 --> 00:54:42.320
all the code for the dictionary program,
more explanations than I had time for.

00:54:42.320 --> 00:54:44.310
It's all there on the website
if you want to go look at that.

00:54:45.440 --> 00:54:48.770
If you want more information
about the API functions or about

00:54:48.840 --> 00:54:52.410
running LLDB directly from Python,
I recommend that you actually

00:54:52.620 --> 00:54:54.320
download the source code from LLDB.

00:54:54.320 --> 00:54:55.590
Again, it's an open-source project.

00:54:55.670 --> 00:54:59.800
And then you look at the header files in
the source tree for the API functions,

00:54:59.800 --> 00:55:03.720
or you look at the test suite for how
to run LLDB from within Python directly.

00:55:03.720 --> 00:55:05.700
And of course,
if you want information about Python,

00:55:05.700 --> 00:55:06.900
Python has its own website.

00:55:06.900 --> 00:55:10.340
So, thank you very much.
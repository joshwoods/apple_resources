WEBVTT

00:00:10.670 --> 00:00:11.400
Hi.

00:00:11.400 --> 00:00:16.020
Welcome to session 508, Understanding and
Optimizing Web Graphics,

00:00:16.020 --> 00:00:20.940
or as I actually wanted to call it,
Pretty Pictures with Dean.

00:00:20.990 --> 00:00:26.000
But marketing with their so-called rules
said that that's not-- So I am Dean,

00:00:26.200 --> 00:00:31.740
represented in this image by the
little girl standing with the

00:00:31.840 --> 00:00:34.980
red bow ties somehow on water.

00:00:35.430 --> 00:00:36.300
Okay, web graphics.

00:00:36.310 --> 00:00:41.260
So we're pretty familiar with, I think,
with what graphics on the web are today.

00:00:41.630 --> 00:00:43.540
Websites are very highly designed.

00:00:43.540 --> 00:00:45.290
They use a lot of imagery.

00:00:45.430 --> 00:00:46.680
They're creating a particular brand.

00:00:46.680 --> 00:00:48.020
They're very stylized.

00:00:48.100 --> 00:00:52.800
There's some types of images
that react to the user somehow.

00:00:53.070 --> 00:00:58.970
There's even some images where
there's some kind of animation

00:00:58.970 --> 00:00:58.970
just giving you an ambient feel.

00:00:58.970 --> 00:00:58.970
Wait a minute.

00:00:59.170 --> 00:01:00.350
OK.

00:01:01.100 --> 00:01:02.950
But it wasn't always like that.

00:01:03.060 --> 00:01:04.880
In fact,
here's a screenshot of the world's

00:01:04.910 --> 00:01:08.860
first web browser written by
Tim Berners-Lee in the early '90s.

00:01:09.000 --> 00:01:11.300
And we'll notice I think
two cool things about it.

00:01:11.300 --> 00:01:15.930
One is that it was written on a Next,
which is the precursor to OSÂ X.

00:01:16.360 --> 00:01:19.030
But also, probably more importantly,
even though it's a

00:01:19.030 --> 00:01:23.170
graphical user interface,
the actual web content,

00:01:23.170 --> 00:01:26.620
which is mostly down in the
bottom right-hand corner,

00:01:26.760 --> 00:01:28.140
it's just plain text.

00:01:28.270 --> 00:01:29.250
There's different text styles.

00:01:29.320 --> 00:01:32.100
There's bold and there's different sizes.

00:01:32.400 --> 00:01:35.570
But the text is just plain.

00:01:35.740 --> 00:01:39.200
Now, at this time,
there were other technologies

00:01:39.200 --> 00:01:42.850
that were competing with the web,
such as Gopher and Wase, and they, too,

00:01:42.850 --> 00:01:44.640
were text-based systems.

00:01:44.640 --> 00:01:48.260
And there was something that happened
to the web that really made it kick off.

00:01:48.390 --> 00:01:50.870
And one of the things was the image tag.

00:01:50.990 --> 00:01:54.840
And this was added in 1993
to the Mosaic browser.

00:01:54.890 --> 00:01:58.320
And you can still read the
proposal online because,

00:01:58.320 --> 00:02:02.480
in fact, it's -- in fact,
the same tag that we're using today.

00:02:02.480 --> 00:02:06.870
And it -- this allowed the author
to have -- to point to a raster

00:02:06.870 --> 00:02:09.570
image file and embed it inline.

00:02:09.580 --> 00:02:12.180
Now, users absolutely loved this feature.

00:02:12.180 --> 00:02:14.720
They started putting images everywhere.

00:02:14.720 --> 00:02:18.690
The Mosaic browser became popular,
and web took off for

00:02:18.790 --> 00:02:20.710
this and other reasons.

00:02:21.430 --> 00:02:25.160
So when we talk about images on the web,
one of the ones probably the most

00:02:25.170 --> 00:02:26.980
familiar with is photographs.

00:02:27.070 --> 00:02:35.200
And in fact,
photographs aren't that interesting

00:02:35.500 --> 00:02:35.500
because they're pretty much the same
type of image that was enabled in 1993.

00:02:35.640 --> 00:02:39.040
Most people in the world nowadays
know what a JPEG file is.

00:02:39.100 --> 00:02:42.520
What we've done since then is
invented entirely new technologies

00:02:42.690 --> 00:02:44.920
to enable different types of imagery.

00:02:45.300 --> 00:02:46.880
An example is maps.

00:02:46.940 --> 00:02:51.210
Previously, a map on the web was pretty
much the same as a paper map.

00:02:51.370 --> 00:02:52.600
It was just a static image.

00:02:52.600 --> 00:02:54.600
Now, maps, we can pinch and zoom.

00:02:54.600 --> 00:02:57.460
We can overlay different layers,
see directions.

00:02:58.530 --> 00:03:00.610
Similarly to maps, we've got charts.

00:03:00.610 --> 00:03:04.790
Now, these are interesting
because as an image,

00:03:04.800 --> 00:03:09.580
they convey more data in a visual
form than would be possibly

00:03:09.580 --> 00:03:11.590
cumbersome to describe in text.

00:03:12.180 --> 00:03:14.820
Similar to charts, we have diagrams.

00:03:14.820 --> 00:03:16.910
So I'm not an American.

00:03:17.000 --> 00:03:19.960
I think this is some form
of religious diagram.

00:03:21.080 --> 00:03:25.060
But the idea is here,
the image itself is representing

00:03:25.060 --> 00:03:27.950
the relationship between objects.

00:03:28.310 --> 00:03:29.780
And the colors and the size.

00:03:29.840 --> 00:03:33.110
And we can take it a step further and
add another dimension to the image.

00:03:33.200 --> 00:03:34.520
We're adding animation.

00:03:34.610 --> 00:03:37.340
And so now we show how the
graphic changes over time,

00:03:37.340 --> 00:03:38.960
and that's giving more data to the user.

00:03:39.860 --> 00:03:42.240
And there's one last
type of image on the web,

00:03:42.240 --> 00:03:43.310
and that's games.

00:03:43.310 --> 00:03:47.410
Millions of people spend millions of
hours a day playing games on the web.

00:03:47.410 --> 00:03:51.730
And we actually call these games video
games because they are visual things.

00:03:51.730 --> 00:03:53.400
They're drawing lots of images.

00:03:53.400 --> 00:03:55.290
They're very interactive.

00:03:55.420 --> 00:03:58.000
And because of that,
they're very exciting.

00:03:58.760 --> 00:04:01.700
So these are the types of
images that we're talking about,

00:04:01.700 --> 00:04:03.700
or imagery we're talking about today.

00:04:06.420 --> 00:04:10.780
So there's two technologies
invented in the last few years that

00:04:10.780 --> 00:04:12.280
really form the basis of this talk.

00:04:12.350 --> 00:04:15.100
The first one is HTML canvas,
and the second one is SVG.

00:04:15.100 --> 00:04:19.740
And this is what we're going to talk
about for the remainder of the session.

00:04:19.800 --> 00:04:21.820
Now you might be asking, well,
these technologies have

00:04:21.820 --> 00:04:22.520
been around for a while.

00:04:22.520 --> 00:04:24.340
Why are you talking about them now?

00:04:24.410 --> 00:04:26.260
And I think there's three main reasons.

00:04:26.410 --> 00:04:28.570
The first one is resolution.

00:04:28.700 --> 00:04:33.050
So we've got now devices with
massive screens and powerful

00:04:33.450 --> 00:04:37.720
graphics processors that can decode,
say, four high-definition

00:04:37.720 --> 00:04:39.420
video streams at once.

00:04:39.470 --> 00:04:44.580
We also got smaller devices or
devices with smaller screens.

00:04:44.670 --> 00:04:47.700
Now the interesting thing here
is you might have a user that's

00:04:47.810 --> 00:04:50.380
pinched to zoom into your image,
and they might be viewing

00:04:50.380 --> 00:04:53.820
it on the 3.5-inch screen
of an iPhone or iPod touch.

00:04:53.890 --> 00:04:56.320
But they're in fact seeing a higher
resolution version of your image.

00:04:56.320 --> 00:04:59.320
And they would on a desktop browser.

00:04:59.320 --> 00:05:03.310
So resolution independence in
graphics formats is very important.

00:05:03.730 --> 00:05:06.740
If we just consider the
iOS family of devices,

00:05:06.810 --> 00:05:10.220
in the keynote on Monday,
it was mentioned there's

00:05:10.220 --> 00:05:14.420
now 200 million iOS devices,
and none of these support

00:05:14.420 --> 00:05:16.540
Flash or any other plugin.

00:05:16.540 --> 00:05:21.200
So if you're an author and you want
to produce interactive graphics,

00:05:21.200 --> 00:05:25.780
you need to use a technology
that's both supported on iOS,

00:05:25.780 --> 00:05:28.130
and you want to, of course,
enable it for other users,

00:05:28.130 --> 00:05:29.020
other browsers.

00:05:29.020 --> 00:05:31.470
And the answer here is HTML5.

00:05:31.550 --> 00:05:32.810
It provides these technologies.

00:05:32.880 --> 00:05:33.820
It's an open standard.

00:05:33.820 --> 00:05:37.650
It's giving you some future proof that
you know that the other vendors are

00:05:37.650 --> 00:05:40.390
going to implement the same technology.

00:05:41.170 --> 00:05:43.340
Now there's one, there's a third,
there's a third point,

00:05:43.340 --> 00:05:45.870
and the third point is actually
so cool and I'm excited about it,

00:05:45.930 --> 00:05:48.170
I'm not going to talk about it,
we're just going to show you.

00:05:48.330 --> 00:05:51.010
So I'm going to swap to...

00:05:53.800 --> 00:06:03.270
Now this is an iPad running--
iPad 2 running iOS 4.3.

00:06:03.270 --> 00:06:03.270
So I'm going to just launch this--

00:06:03.460 --> 00:06:06.940
This is a demo I wrote,
and it's just exercising

00:06:06.940 --> 00:06:07.740
the canvas element.

00:06:07.780 --> 00:06:10.980
You can see it's sort of got
five different types of tests.

00:06:11.300 --> 00:06:12.450
One's drawing rectangles.

00:06:12.600 --> 00:06:15.780
We've got some shapes that
are stroked and filled.

00:06:15.820 --> 00:06:17.090
We're scaling some images.

00:06:17.330 --> 00:06:20.940
We're doing 2D transforms on rectangles,
and we're doing some image compositing.

00:06:21.080 --> 00:06:23.180
Now,
we're getting 17 frames a second here.

00:06:23.180 --> 00:06:26.280
The graphics look great,
but there's sort of some restrictions

00:06:26.340 --> 00:06:30.150
with that level of performance that,
you know, people are writing great web

00:06:30.160 --> 00:06:33.670
apps that use these technologies,
but it could be a little bit better.

00:06:33.720 --> 00:06:41.060
So now I'm going to swap to the
same hardware running iOS 5.0.

00:06:41.410 --> 00:06:43.700
Okay, so same hardware.

00:06:43.700 --> 00:06:48.640
Got to run the same test.

00:06:48.640 --> 00:06:48.640
And this time --

00:06:52.690 --> 00:07:03.410
So about 70 frames,
about four and a bit times faster.

00:07:03.410 --> 00:07:03.410
Now, this is on the same hardware,
and it's in iOS 5.

00:07:04.040 --> 00:07:04.400
Cool.

00:07:04.400 --> 00:07:09.260
So those three things: resolution, HTML5,
and performance, are the reasons we're

00:07:09.260 --> 00:07:10.420
talking about graphics today.

00:07:10.420 --> 00:07:12.110
So what are we going to cover?

00:07:12.320 --> 00:07:15.130
We're going to cover the basic
concepts of Canvas and SVG,

00:07:15.130 --> 00:07:16.230
how to draw shapes.

00:07:16.350 --> 00:07:20.210
We're going to add some interaction
-- animation and interactivity.

00:07:20.320 --> 00:07:23.930
And we're going to finish with
some tips and special effects.

00:07:24.030 --> 00:07:26.800
So let's start with the basic concepts.

00:07:26.910 --> 00:07:29.020
The HTML5 Canvas element.

00:07:29.020 --> 00:07:34.020
So the way I think of Canvas is that
it's actually like an image tag,

00:07:34.180 --> 00:07:35.310
but it's blank.

00:07:35.640 --> 00:07:38.860
And instead of pointing the
source element at a raster

00:07:38.860 --> 00:07:40.720
file to get the pixels,
you, in fact,

00:07:40.720 --> 00:07:49.060
have a JavaScript API and you control
what the pixels in the element is.

00:07:49.060 --> 00:07:51.480
One thing to note about the
Canvas is this JavaScript API,

00:07:51.550 --> 00:07:54.700
which we'll get into in a minute,
every drawing command is immediately

00:07:54.700 --> 00:07:56.400
rendered into the Canvas.

00:07:56.400 --> 00:08:00.180
So if you're familiar with doing
animations and things in -- in

00:08:00.180 --> 00:08:00.180
-- in the -- in the JavaScript,
you know, you can actually do that.

00:08:00.180 --> 00:08:00.180
You can do that in the JavaScript.

00:08:00.180 --> 00:08:00.180
You can do that in the JavaScript.

00:08:00.180 --> 00:08:00.220
You can do that in the JavaScript.

00:08:00.220 --> 00:08:00.220
So you can do that in the JavaScript.

00:08:00.220 --> 00:08:00.220
So if you're familiar with
doing animations and things

00:08:00.220 --> 00:08:00.220
in -- in the JavaScript,
you can do that in the JavaScript.

00:08:00.220 --> 00:08:00.220
So if you're familiar with
doing animations and things

00:08:00.220 --> 00:08:00.260
in -- in the JavaScript,
you can do that in the JavaScript.

00:08:00.260 --> 00:08:00.280
So if you're familiar with
doing animations and things in

00:08:00.280 --> 00:08:03.040
HTML content where if you have a
development and you move it about,

00:08:03.130 --> 00:08:06.150
the browser's got to take
charge of redrawing it.

00:08:06.470 --> 00:08:09.780
In Canvas, if you draw something in one
place and you want to move it,

00:08:09.840 --> 00:08:12.560
you actually possibly have to
erase it from that new location

00:08:12.570 --> 00:08:15.320
and draw your entire scene again.

00:08:15.620 --> 00:08:16.670
How do you use canvas?

00:08:16.870 --> 00:08:19.050
Well, it's just a regular HTML element.

00:08:19.200 --> 00:08:23.410
So here I've got a canvas element,
and I've given it a width and a height,

00:08:23.410 --> 00:08:26.040
and it's just a rectangular
region in the page.

00:08:26.150 --> 00:08:28.140
So this bit's so boring,
let's actually start using it.

00:08:28.410 --> 00:08:32.440
So I wanted to draw something
that's fairly easy but recognizable.

00:08:32.440 --> 00:08:34.550
So let's draw the HTML5 logo.

00:08:34.880 --> 00:08:36.850
Now, if you look at this logo,
it's in fact three

00:08:36.850 --> 00:08:38.060
different shapes at once.

00:08:38.170 --> 00:08:39.810
So there's a background,
there's a shield,

00:08:39.910 --> 00:08:41.330
which is the orange background.

00:08:41.520 --> 00:08:44.520
There's a white shape
that's shaped to be,

00:08:44.650 --> 00:08:45.930
looks like a five.

00:08:46.180 --> 00:08:51.540
And then what looks here like a gray
polygon is in fact a white polygon

00:08:51.540 --> 00:08:55.820
that's partially transparent so that
when you draw them on top of each other,

00:08:55.820 --> 00:08:57.020
you get this highlight effect.

00:08:57.150 --> 00:08:59.540
So let's draw this shape.

00:08:59.590 --> 00:09:05.670
I'm going to start by having a canvas
that's 512 pixels in each dimension.

00:09:05.740 --> 00:09:07.170
I could have picked any size.

00:09:07.440 --> 00:09:10.390
Now, the first thing I want to do is I've
got to get this API that I talked about,

00:09:10.490 --> 00:09:11.420
which is the HTML5 canvas element.

00:09:11.420 --> 00:09:11.430
And I'm going to do that
by using the HTML5 element.

00:09:11.440 --> 00:09:13.480
So the object,
the JavaScript object that you

00:09:13.720 --> 00:09:15.380
issue the drawing commands on.

00:09:15.440 --> 00:09:17.340
So I've got a reference
to my canvas element,

00:09:17.340 --> 00:09:20.400
and I call the get context
with a parameter of 2D.

00:09:20.420 --> 00:09:22.940
And that gives me the,
what we call the context of,

00:09:22.950 --> 00:09:25.740
I've got the variable CTX here.

00:09:25.790 --> 00:09:28.070
Once I've got that context,

00:09:28.280 --> 00:09:31.540
I probably want to erase
what was already there.

00:09:31.540 --> 00:09:34.060
Like I said,
something might have drawn into it,

00:09:34.200 --> 00:09:36.680
some previous frame of what I've drawn.

00:09:36.750 --> 00:09:39.520
I'm going to erase what's there
and I just clear all the pixels.

00:09:39.680 --> 00:09:40.580
Now I want to draw this shape.

00:09:40.750 --> 00:09:45.420
Now the way we draw shapes in
Canvas is we first define geometry,

00:09:45.420 --> 00:09:49.440
and then once we've got that geometry,
issue the actual drawing commands.

00:09:49.580 --> 00:09:54.600
So I start by declaring that I'm going to
now start giving you geometry commands,

00:09:54.600 --> 00:09:55.820
beginning a path.

00:09:56.070 --> 00:09:59.960
And then I define the five
points in the path of the shield.

00:10:00.350 --> 00:10:05.270
So I start at the point 71, 460,
then I move up to 30, 0,

00:10:05.270 --> 00:10:06.680
and so on around.

00:10:06.680 --> 00:10:09.400
Finally, I'm going to close the path,
which is going to draw a straight line

00:10:09.400 --> 00:10:13.070
from the last point to the end point,
sorry, the last point to the first point.

00:10:13.200 --> 00:10:14.840
Now I've got the geometry,
I'm going to actually

00:10:14.840 --> 00:10:16.080
issue the drawing commands.

00:10:16.190 --> 00:10:19.440
The first thing I set the fill style
to be the particular shade of orange.

00:10:19.440 --> 00:10:21.420
And then I call fill.

00:10:21.500 --> 00:10:26.690
And Canvas goes and fills in
that shape with the orange color.

00:10:27.220 --> 00:10:28.760
Drawing the five is very similar.

00:10:28.780 --> 00:10:32.000
I'm starting a new geometry, a new path,
begin path.

00:10:32.040 --> 00:10:33.020
I add all the points.

00:10:33.100 --> 00:10:35.300
There's a few more of them here,
so I haven't listed them all.

00:10:35.350 --> 00:10:44.120
In the end,
I set the fill style to be almost white,

00:10:44.120 --> 00:10:44.120
a slightly bright gray,
and then call fill,

00:10:44.120 --> 00:10:44.120
and we get the five on top.

00:10:44.620 --> 00:10:46.820
The highlight is again very similar.

00:10:47.220 --> 00:10:50.770
Start the geometry, begin path,
define the outline.

00:10:50.930 --> 00:10:57.630
And here,
it's something slightly different

00:10:57.820 --> 00:10:59.980
is that because I wanted to
draw a transparent color,

00:10:59.980 --> 00:10:59.980
I set my fill style to be
RGB white that's 30% opaque.

00:11:01.780 --> 00:11:03.250
So how are you going to use that?

00:11:03.450 --> 00:11:04.640
You've got the object now.

00:11:04.640 --> 00:11:05.730
You've drawn into Canvas.

00:11:05.900 --> 00:11:07.150
Well,
I already mentioned that it could be

00:11:07.150 --> 00:11:10.670
just an element already in the page.

00:11:10.750 --> 00:11:11.310
That's pretty simple.

00:11:11.320 --> 00:11:14.700
There's another way to use
Canvas in WebKit in Safari,

00:11:14.720 --> 00:11:16.800
and that's via CSS.

00:11:16.930 --> 00:11:19.780
So let's say anywhere you
can use an image in CSS,

00:11:19.780 --> 00:11:23.210
such as background image or border image,
you can set your property

00:11:23.210 --> 00:11:25.660
value to be WebKit Canvas,
and you give a name

00:11:25.720 --> 00:11:27.120
for that Canvas object.

00:11:27.190 --> 00:11:30.540
And this gives you a canvas that's not
actually part of the content of the page,

00:11:30.540 --> 00:11:33.460
but it's kind of like an off-screen
buffer that you can draw into.

00:11:33.610 --> 00:11:38.760
So I've defined the WebKit Canvas,
and then somewhere else in my JavaScript,

00:11:38.870 --> 00:11:43.680
I call document getCssCanvasContext 2D,
and I use that same ID,

00:11:43.730 --> 00:11:47.100
the name that I used in my CSS,
and I give it a size.

00:11:47.140 --> 00:11:49.120
And then I've got this context
object that I can draw into,

00:11:49.120 --> 00:11:52.250
and it immediately goes
into the CSS engine.

00:11:53.140 --> 00:11:55.380
So we drew that logo,
and if we look at it,

00:11:55.380 --> 00:11:56.860
it's a fair bit of code.

00:11:56.860 --> 00:12:00.100
Most of it's the geometry,
but embedded in there, mixed in,

00:12:00.230 --> 00:12:02.600
is some styling commands or whatever.

00:12:02.600 --> 00:12:03.600
It's all JavaScript.

00:12:03.710 --> 00:12:05.590
It might be slightly
hard to maintain that,

00:12:05.590 --> 00:12:07.540
especially if you're not a programmer.

00:12:07.550 --> 00:12:09.880
So we're going to look at
how similar technology,

00:12:09.880 --> 00:12:11.800
SVG, would have done the same thing.

00:12:12.660 --> 00:12:15.880
So SVG,
it's a markup format for graphics.

00:12:15.880 --> 00:12:20.460
The way I like to think of it is
it's kind of like HTML for graphics.

00:12:20.700 --> 00:12:24.100
So instead of having P paragraphs
and heading elements,

00:12:24.150 --> 00:12:25.820
you've got circles and rectangles.

00:12:26.150 --> 00:12:29.910
This makes it really human
readable and easy to edit by hand.

00:12:29.910 --> 00:12:31.170
It's vector based.

00:12:31.270 --> 00:12:33.390
So what that means is that
instead of actually drawing,

00:12:33.600 --> 00:12:35.690
ultimately it's going
to end up with pixels,

00:12:35.940 --> 00:12:39.360
but you are defining the sort of
parameters to the shapes that you want,

00:12:39.360 --> 00:12:42.220
and the browser's going to
take care of the rendering.

00:12:42.220 --> 00:12:46.600
It's going to render the object at
the best resolution possible for

00:12:46.600 --> 00:12:49.480
whatever zoom factor the user might be.

00:12:50.880 --> 00:12:52.560
Lastly,
it actually has a lot of tool support.

00:12:52.560 --> 00:12:53.600
It's been around for a while.

00:12:53.600 --> 00:13:02.450
It's an open standard,
and there's some commercial tools like

00:13:02.450 --> 00:13:05.000
the Adobe Suite that export to SVG,
and there's a whole bunch of open source

00:13:05.000 --> 00:13:05.000
tools that edit and export to SVG.

00:13:05.350 --> 00:13:06.370
So how do we do it?

00:13:06.510 --> 00:13:10.390
An SVG is a file format just like HTML,
and HTML starts with an HTML tag.

00:13:10.390 --> 00:13:14.200
SVG starts with an SVG tag,
and you put your content in between.

00:13:14.200 --> 00:13:15.040
Very simple.

00:13:15.110 --> 00:13:18.460
There is one little difference in that,
remember we said that SVG is

00:13:18.460 --> 00:13:19.950
resolution independent.

00:13:20.030 --> 00:13:23.890
It means that the browser's got to
take care of how big it's rendered,

00:13:24.230 --> 00:13:26.860
but within the actual content itself,
we need to give a hint to

00:13:26.860 --> 00:13:29.840
the system as to what type of
coordinate system we're looking at.

00:13:29.990 --> 00:13:33.000
So in this case,
I've added a viewpox attribute,

00:13:33.140 --> 00:13:37.840
and what I said is this SVG assumes
that I'm drawing in a sort of

00:13:37.910 --> 00:13:44.940
arbitrary viewport of starts at zero
zero and is 512 pixels high and wide.

00:13:45.810 --> 00:13:46.580
So let's start.

00:13:46.660 --> 00:13:50.800
So there's my SVG viewport.

00:13:50.960 --> 00:13:52.670
And I'm going to add a polygon.

00:13:52.840 --> 00:13:58.320
And a polygon is actually
just a polygon tag.

00:13:58.450 --> 00:14:00.130
And it has an attribute fill.

00:14:00.270 --> 00:14:04.800
So in this case, I've got the tag name,
then what I call a styling attribute.

00:14:04.890 --> 00:14:10.650
So it says the fill color to
be this particular orange.

00:14:10.650 --> 00:14:11.870
And then the other attribute
on the element is--

00:14:14.310 --> 00:14:25.010
is the points, and that's giving you the
space-separated list of x,

00:14:25.010 --> 00:14:25.010
y pairs that define the
geometry of the shape.

00:14:25.990 --> 00:14:29.540
The HTML5 logo is very similar.

00:14:29.790 --> 00:14:32.230
Again, a little bit more points,
but I've said fill to

00:14:32.350 --> 00:14:33.540
be that bright gray.

00:14:33.590 --> 00:14:37.560
And now we're just mentioning
that SVG draws in document order.

00:14:37.690 --> 00:14:41.570
So if I put the orange polygon in
the document before the white five,

00:14:41.570 --> 00:14:44.140
then they get a render
in the right order.

00:14:44.140 --> 00:14:46.960
Otherwise, the five would be obscured.

00:14:48.800 --> 00:14:50.000
The last highlight again is very simple.

00:14:50.000 --> 00:14:50.500
It's another polygon.

00:14:50.500 --> 00:14:54.390
The difference here is I could have
used an RGBA color like I did in canvas,

00:14:54.520 --> 00:14:56.820
but instead I said I want
the fill color to be white,

00:14:56.830 --> 00:15:04.490
and I set another property opacity
to be 30%. And there's the logo.

00:15:07.810 --> 00:15:13.900
Okay, so that's the entire
file for that graphic.

00:15:14.020 --> 00:15:18.290
What's great about that is that just
that amount of code gives you an image

00:15:18.290 --> 00:15:19.850
that could be drawn at any scale.

00:15:19.960 --> 00:15:22.970
It could be used, you know,
10 pixels by 10 pixels or a million

00:15:22.970 --> 00:15:24.900
pixels by a million pixels zoomed in.

00:15:24.900 --> 00:15:27.020
The total file size

00:15:27.250 --> 00:15:29.300
It's 497 bytes.

00:15:29.410 --> 00:15:35.350
And that's actually uncompressed.

00:15:35.400 --> 00:15:40.530
When you send it over
HTTP with GZIP compression,

00:15:40.530 --> 00:15:40.530
you're at 272 bytes.

00:15:40.530 --> 00:15:40.530
That's probably smaller than
most HTML head elements.

00:15:41.630 --> 00:15:44.820
So you can use it as an image element.

00:15:45.000 --> 00:15:48.020
The way it takes a JPEG or a PNG file,
you can also point at an SVG file

00:15:48.020 --> 00:15:49.680
and it'll render the SVG file.

00:15:49.680 --> 00:15:54.500
Also in CSS,
you can use an SVG file anywhere.

00:15:54.500 --> 00:15:57.480
Again, you would use an image in CSS such
as borders or backgrounds.

00:15:57.760 --> 00:16:00.980
There's one important thing to mention
when you're using it in CSS is,

00:16:01.120 --> 00:16:04.760
again, SVG doesn't really have
a resolution itself,

00:16:04.760 --> 00:16:08.050
so you have to tell the CSS engine
how big you want that file to be

00:16:08.060 --> 00:16:09.810
rendered when you're using it.

00:16:09.910 --> 00:16:11.620
So in this case, I set a background size.

00:16:13.260 --> 00:16:18.820
There's a new way to use SVG which is
enabled in Safari Online and on iOS 5,

00:16:18.820 --> 00:16:23.500
and that is you can actually
embed SVG inline within HTML.

00:16:23.580 --> 00:16:25.930
In this case,
it's very similar to the canvas element.

00:16:26.190 --> 00:16:34.090
I just put the SVG file in and it's
a rectangular region on the page,

00:16:34.090 --> 00:16:34.090
and then my SVG content goes in between.

00:16:34.510 --> 00:16:37.580
So we have that file,
but there's something probably

00:16:37.580 --> 00:16:40.620
missing if we're web authors,
and that is we've been taught

00:16:40.620 --> 00:16:43.590
for years to separate our
sort of styling from our data.

00:16:43.600 --> 00:16:45.740
And this isn't doing it,
sort of mixing it all in one.

00:16:45.740 --> 00:16:48.780
So we can actually have
another pass at this file.

00:16:48.780 --> 00:16:50.600
It's hard to read,
so I'll just make it full screen,

00:16:50.600 --> 00:16:52.620
and I'm going to highlight
the bits that have changed.

00:16:52.660 --> 00:16:56.880
So instead of all these fill attributes,
I've instead put CSS class

00:16:57.050 --> 00:16:58.840
attributes on the element.

00:16:58.840 --> 00:17:00.780
So there's the shield, the five,
and the highlight.

00:17:01.210 --> 00:17:04.000
And then I've added a style element,
and I've added the CSS for

00:17:04.070 --> 00:17:05.260
those three things.

00:17:05.350 --> 00:17:08.390
I could have equally had it as a
link to an external style sheet.

00:17:08.400 --> 00:17:12.780
Now, the great thing here is that if
I take this very simple style rule

00:17:12.780 --> 00:17:16.420
and change it to something like this,
I've highlighted the changes,

00:17:16.420 --> 00:17:19.500
we can take that same graphic
and produce a dramatically

00:17:19.500 --> 00:17:21.420
different visual appearance.

00:17:21.420 --> 00:17:24.860
You haven't changed the
coordinates in any way.

00:17:24.860 --> 00:17:26.280
You've just changed the style sheet.

00:17:26.280 --> 00:17:28.740
So you could, in fact,
have the same graphic styled by different

00:17:28.820 --> 00:17:31.050
parts of your website or different
media queries for different things.

00:17:31.120 --> 00:17:34.170
different devices just through CSS.

00:17:34.780 --> 00:17:36.450
So we've got this file.

00:17:36.450 --> 00:17:40.620
Now we've seen canvas and SVG,
both the basic shapes.

00:17:40.750 --> 00:17:43.310
Let's have a look at where
we stand in comparison.

00:17:43.590 --> 00:17:49.340
So I mentioned canvas draws
immediately into its 2D image.

00:17:49.770 --> 00:17:54.790
SVG is a structural format,
as in you add elements into the document.

00:17:55.130 --> 00:17:57.500
Basic shapes, pretty much the same.

00:17:57.820 --> 00:17:59.640
You can use them both
as background images.

00:17:59.810 --> 00:18:01.000
You can embed them both inline.

00:18:01.000 --> 00:18:03.240
So we're going on pretty similarly now.

00:18:03.320 --> 00:18:05.920
It starts to get different when
we talk about accessibility.

00:18:05.920 --> 00:18:10.180
SVG by its nature is a little bit
more accessible because there is

00:18:10.300 --> 00:18:12.900
actual structure in your document.

00:18:12.910 --> 00:18:12.910
There is content there.

00:18:13.510 --> 00:18:15.560
You can side it with CSS, as I mentioned.

00:18:15.560 --> 00:18:17.570
And there's authoring tool support.

00:18:17.580 --> 00:18:20.940
There's less authoring
tool support for canvas.

00:18:21.020 --> 00:18:24.000
But before I give you the
impression that SVG is just better,

00:18:24.050 --> 00:18:28.520
there is one very important
use case that canvas wins at,

00:18:28.590 --> 00:18:33.620
and that's when either speed
or memory is essential.

00:18:33.640 --> 00:18:36.920
And the reason for that is,
SVG has this overhead of adding

00:18:36.920 --> 00:18:38.610
elements to the document.

00:18:38.710 --> 00:18:41.850
So there is some sort of processing
involved in navigating that tree

00:18:41.990 --> 00:18:43.620
and styling it and rendering it.

00:18:43.640 --> 00:18:45.200
There's also like the memory overhead.

00:18:45.200 --> 00:18:48.060
If you're going to draw a million points,
you don't necessarily want to have

00:18:48.060 --> 00:18:49.640
a million objects in your document.

00:18:49.640 --> 00:18:52.630
You just want to draw it once
and have it as that 2D image.

00:18:52.640 --> 00:18:58.900
And so that's why canvas is used for many
web games because it's great performance.

00:18:59.310 --> 00:19:01.360
So that's the basic concepts.

00:19:01.420 --> 00:19:07.130
Let's start shaking and baking and
add some animation interactivity.

00:19:08.550 --> 00:19:11.960
Now, we've got, to this point,
we could draw a graph

00:19:11.960 --> 00:19:13.900
like this pretty easily.

00:19:13.900 --> 00:19:17.980
It's just a polyline, a few shapes,
some text, would have done that.

00:19:18.270 --> 00:19:20.820
So the next step would have been
make it a little bit better.

00:19:20.910 --> 00:19:23.700
This is about the best I can
do because I'm not a designer.

00:19:23.960 --> 00:19:28.400
But we could take it one step
further and maybe add some kind

00:19:28.400 --> 00:19:30.650
of animation to this chart.

00:19:30.700 --> 00:19:32.960
And this would allow
you to do things like,

00:19:32.960 --> 00:19:36.620
you know, make it really clear that sort
of one value is bigger than the

00:19:36.620 --> 00:19:40.880
other because it animates longer or
just maybe even just looks cooler.

00:19:40.880 --> 00:19:45.870
So let's look at how we would add
this kind of animation to our graphic.

00:19:46.530 --> 00:19:49.740
So animating with canvas is in fact
very similar to what used to be

00:19:49.930 --> 00:19:53.430
called DHTML techniques or what plenty
of JavaScript libraries do today,

00:19:53.570 --> 00:19:57.060
which is they render the scene once,
and they run a bit of JavaScript,

00:19:57.060 --> 00:20:00.360
and they draw things again,
or they move things across the page,

00:20:00.360 --> 00:20:02.060
and just draw again and again.

00:20:02.060 --> 00:20:06.280
And you're in charge of
each frame of the animation.

00:20:06.320 --> 00:20:07.340
So there's plenty of ways to do this.

00:20:07.440 --> 00:20:08.430
Like I said, there's plenty of libraries.

00:20:08.520 --> 00:20:10.980
Let's just look at an
example that I came up with.

00:20:10.980 --> 00:20:15.300
Imagine I've defined this function that
takes-- that I'm going to-- it's going to

00:20:15.300 --> 00:20:18.760
be used to animate a shape in my canvas,
and it takes the starting

00:20:18.760 --> 00:20:22.060
value and the ending value,
when I started, and how long I want the

00:20:22.060 --> 00:20:23.570
animation to run for.

00:20:23.900 --> 00:20:26.960
The first thing I'm going to do is
work out where along-- you know,

00:20:26.960 --> 00:20:28.580
how far along the animation I am.

00:20:28.890 --> 00:20:33.460
Then I'm going to evaluate
based on that proportion where

00:20:33.460 --> 00:20:36.540
the element I want to draw is.

00:20:36.690 --> 00:20:37.840
Then I'm going to redraw the scene.

00:20:37.840 --> 00:20:40.590
I think it's a bit tricky that, you know,
I've done it once.

00:20:40.680 --> 00:20:43.280
I've now got to test, well,
have I hit the end of my animation?

00:20:43.280 --> 00:20:44.790
Should I have elapsed?

00:20:45.050 --> 00:20:48.350
And if I haven't, then I've got to set up
a JavaScript callback to,

00:20:48.350 --> 00:20:52.240
you know, recall this function at a
later state or as soon as I can

00:20:52.240 --> 00:20:53.730
to get a smooth animation.

00:20:53.740 --> 00:20:55.700
So we're getting a
fair bit of code there,

00:20:55.700 --> 00:20:57.150
but it's not so bad.

00:20:57.160 --> 00:20:59.080
But if you want to take
it a little bit further,

00:20:59.080 --> 00:21:04.120
let's say most animations look
wrong if you're just sort of doing

00:21:04.120 --> 00:21:05.380
a straight linear interpolation.

00:21:05.600 --> 00:21:09.010
If you look at many of them,
they sort of start slow and speed

00:21:09.010 --> 00:21:10.580
up and then maybe end slow again.

00:21:10.580 --> 00:21:12.980
So if you want to do something like that,
you're going to have to write extra

00:21:12.980 --> 00:21:17.810
code to control basically mapping
that proportion value in time to a

00:21:17.820 --> 00:21:19.790
proportion value in the animation.

00:21:21.760 --> 00:21:23.430
Maybe you want to animate
a whole bunch of things and

00:21:23.430 --> 00:21:24.520
you want to synchronize them.

00:21:24.520 --> 00:21:26.710
So you want to have one thing
start and then another thing

00:21:26.710 --> 00:21:28.300
start a second later or something.

00:21:28.300 --> 00:21:32.130
You have to write extra code
to keep this all arranged.

00:21:32.510 --> 00:21:35.500
And then maybe you want to animate some
things that are a bit more complex than

00:21:35.510 --> 00:21:37.050
just a single floating point value.

00:21:37.140 --> 00:21:39.640
For example, it could be a transform,
which is a matrix.

00:21:39.770 --> 00:21:43.250
So it doesn't necessarily always
work to do the interpolation of

00:21:43.270 --> 00:21:45.240
all the elements in the matrix.

00:21:45.330 --> 00:21:53.120
Or it could be animating between
two different shapes or path types,

00:21:53.210 --> 00:21:54.600
polygons.

00:21:54.600 --> 00:21:54.600
So you're going to have to write
extra code to do things like that.

00:21:55.370 --> 00:21:56.300
But this is all okay.

00:21:56.300 --> 00:22:00.240
I mean, if you're familiar with this,
and this technique is, again,

00:22:00.240 --> 00:22:01.800
used very often in HTML.

00:22:01.800 --> 00:22:03.600
It applies just as well to SVG.

00:22:03.600 --> 00:22:05.300
You can use the same
scripting techniques.

00:22:05.660 --> 00:22:14.300
But there is a form of SVG animation,
which I think is worth mentioning,

00:22:14.300 --> 00:22:14.300
that definitely makes these simple
animations a lot easier to code.

00:22:14.610 --> 00:22:17.990
And the way you do animation in
SVG is that instead of doing the frame

00:22:17.990 --> 00:22:19.830
base where you're calling yourself,
you just give the

00:22:19.830 --> 00:22:20.800
intent of the animation.

00:22:20.800 --> 00:22:28.430
I say I want to start from this
value and I'll end at this value,

00:22:28.430 --> 00:22:32.410
and the browser's going to be
the one that does the redrawing.

00:22:32.410 --> 00:22:32.410
Very similar to the way transitions
and animations work in CSS.

00:22:32.660 --> 00:22:33.740
It's pretty easy to add to your file.

00:22:33.740 --> 00:22:35.930
So let's imagine I've
got a circle element.

00:22:36.110 --> 00:22:38.190
It's drawn at 100,
100 with a radius of 8.

00:22:38.370 --> 00:22:39.540
And I just want to animate it.

00:22:39.710 --> 00:22:41.630
So I add an animate tag.

00:22:41.910 --> 00:22:44.330
I say that the attribute
that I want to animate is CX,

00:22:44.510 --> 00:22:46.600
which is the X value of the center point.

00:22:46.720 --> 00:22:49.440
And I want to start at the point
100 and go to the point 200.

00:22:49.770 --> 00:22:51.650
And my duration is two seconds.

00:22:51.780 --> 00:22:53.390
And all I do then is
when the document loads,

00:22:53.390 --> 00:22:55.130
that animation's going to fire.

00:22:55.230 --> 00:22:58.160
And the browser's going to
control the-- draw this animation.

00:22:58.320 --> 00:22:59.190
Pretty easy.

00:22:59.340 --> 00:23:01.150
So I want to do more animations.

00:23:01.160 --> 00:23:03.100
I just add more animation tags.

00:23:03.220 --> 00:23:05.300
So in this case,

00:23:05.550 --> 00:23:06.710
I've got two animations.

00:23:06.790 --> 00:23:10.080
I first want to animate that
slide along the x-axis and

00:23:10.080 --> 00:23:11.810
then move up in the y-axis.

00:23:11.990 --> 00:23:13.500
But I want to do it a little bit tricky.

00:23:13.580 --> 00:23:17.520
I've added an id attribute
to the first animation.

00:23:17.660 --> 00:23:19.520
So I've given it the name slide.

00:23:19.630 --> 00:23:23.920
And then the second animation, again,
takes cy from 100 to 80 over two seconds.

00:23:23.920 --> 00:23:26.980
But I've told it to
begin at this expression.

00:23:26.980 --> 00:23:29.450
And this expression is
the name of the animation,

00:23:29.460 --> 00:23:31.820
in case slide, when it ends.

00:23:31.940 --> 00:23:35.870
So now what will happen is the
browser will do that animation and

00:23:35.870 --> 00:23:38.800
then immediately do the y animation.

00:23:38.870 --> 00:23:40.650
This is really cool
because in JavaScript,

00:23:40.650 --> 00:23:42.660
you would have to sync this up yourself.

00:23:42.770 --> 00:23:45.530
And we can go beyond this.

00:23:45.660 --> 00:23:48.110
So that expression, in fact,
can take a little bit

00:23:48.270 --> 00:23:49.360
of arithmetic operation.

00:23:49.360 --> 00:23:51.220
So in this case,
I've done the same animation.

00:23:51.220 --> 00:23:56.100
But I now want to start
two seconds after.

00:23:56.190 --> 00:23:59.380
So one Mississippi, two Mississippi.

00:23:59.680 --> 00:24:01.900
And you count Mississippi a little
bit faster when you're on stage,

00:24:01.900 --> 00:24:06.100
obviously, and then the animation fires.

00:24:06.220 --> 00:24:08.100
So you can see that was pretty easy.

00:24:08.110 --> 00:24:10.100
There's another type
of sort of animation,

00:24:10.100 --> 00:24:14.100
or what I call interaction,
and that's a little bit more

00:24:14.100 --> 00:24:17.910
like-- imagine you have a chart,
and you've got a point on the chart,

00:24:17.910 --> 00:24:22.510
and you want the user to tap on it and
get a reading of the current value.

00:24:22.640 --> 00:24:26.100
So it might pop up this thing.

00:24:26.120 --> 00:24:28.440
Pretty common, very cool thing to do.

00:24:28.440 --> 00:24:31.160
Let's have a look at how we
would actually do it in Canvas.

00:24:31.160 --> 00:24:35.480
Now, one of the problems with Canvas is,
like I said, it's one element in the DOM.

00:24:35.610 --> 00:24:39.490
So when you're doing an interaction,
you're only getting the

00:24:39.520 --> 00:24:42.020
DOM event on that one element.

00:24:42.040 --> 00:24:44.930
So if you touch somewhere on the canvas,
it's the canvas that gets the

00:24:44.980 --> 00:24:46.880
event with the next Y location.

00:24:46.880 --> 00:24:51.040
And it's up to you to work out where
inside your canvas the shape that

00:24:51.040 --> 00:24:55.540
you're actually drawing or whether the
user is tapped on a particular shape.

00:24:55.580 --> 00:24:57.900
So here I've written a helper function.

00:24:57.900 --> 00:25:00.940
It's going to ask,
is my point in a particular shape?

00:25:00.950 --> 00:25:05.240
And I pass in the context and the
XY location of the user touch.

00:25:05.240 --> 00:25:09.220
Now, I could do the math to work
out the geometry myself,

00:25:09.220 --> 00:25:10.300
but I don't want to do that.

00:25:10.310 --> 00:25:12.740
What I'm going to start by is, again,
the same process that

00:25:12.740 --> 00:25:13.730
I did to draw the shape.

00:25:13.740 --> 00:25:17.440
I'm going to define the geometry with
beginPath and add all the points.

00:25:17.470 --> 00:25:20.280
And then I'm going to call as
a helper function on context,

00:25:20.280 --> 00:25:21.700
which is isPoint in path.

00:25:21.700 --> 00:25:22.860
And that's going to do it.

00:25:22.860 --> 00:25:24.500
Now, this seems really easy.

00:25:24.500 --> 00:25:27.810
In fact, it is really easy,
except it does get a bit more complicated

00:25:27.810 --> 00:25:29.600
when you've got a graphic like this.

00:25:29.650 --> 00:25:33.220
So here there's, what is it,
40-odd states or something?

00:25:33.240 --> 00:25:36.840
And some of them are pretty complex.

00:25:36.840 --> 00:25:39.310
And so every time a
tap or a drag happens,

00:25:39.310 --> 00:25:43.160
you're going to have to run that
code for each one of these shapes.

00:25:43.160 --> 00:25:44.120
Add all the geometry.

00:25:44.120 --> 00:25:44.860
Am I inside?

00:25:44.860 --> 00:25:45.380
No.

00:25:45.380 --> 00:25:46.120
What about the next one?

00:25:46.120 --> 00:25:46.620
Am I inside?

00:25:46.620 --> 00:25:46.780
No.

00:25:46.780 --> 00:25:47.900
And you can optimize this.

00:25:47.910 --> 00:25:50.160
But again, it's pretty cumbersome.

00:25:50.180 --> 00:25:53.180
So there is a way to do this
a little bit easier in SVG.

00:25:53.500 --> 00:25:58.060
And the reason is that the actual
shapes that you put into the document

00:25:58.060 --> 00:25:59.560
are elements in the document.

00:25:59.560 --> 00:26:02.530
And they can get event listeners
just the way any other element

00:26:02.530 --> 00:26:04.460
in HTML can get event listener.

00:26:04.780 --> 00:26:05.960
So here we've got a polygon.

00:26:05.970 --> 00:26:07.080
I want to add an event listener to it.

00:26:07.180 --> 00:26:09.890
So I get the element by ID myShape.

00:26:09.900 --> 00:26:12.000
And I've got the pointer
to this SVG element,

00:26:12.000 --> 00:26:13.040
which is a polygon.

00:26:13.040 --> 00:26:15.660
And I just add an event listener click.

00:26:15.690 --> 00:26:18.780
And it'll call this myClickHandler
when the user clicks on it.

00:26:18.780 --> 00:26:20.040
I haven't had to do the hit testing.

00:26:20.080 --> 00:26:20.640
It's not going to do it at all.

00:26:20.640 --> 00:26:22.120
The browser's done it for me.

00:26:22.130 --> 00:26:25.820
I've probably reduced
hundreds of lines of code.

00:26:25.820 --> 00:26:30.180
And it's probably faster,
because the browser can optimize this.

00:26:30.250 --> 00:26:33.710
So again, I've hinted that there was
some types of animation or

00:26:33.760 --> 00:26:36.630
interactivity that SVG's better for.

00:26:36.720 --> 00:26:39.680
But there is one type of
animation that Canvas-- well,

00:26:39.690 --> 00:26:42.860
there's definitely one type of animation
that Canvas is totally awesome for.

00:26:42.860 --> 00:26:44.380
And it's not supported in SVG.

00:26:44.390 --> 00:26:46.980
In order to describe that,
I'm going to start by explaining

00:26:47.060 --> 00:26:49.920
how you draw images in Canvas.

00:26:50.220 --> 00:26:53.760
So the first thing I want to do when
I'm drawing an image is actually

00:26:53.760 --> 00:26:55.060
get a reference to the image.

00:26:55.080 --> 00:26:57.980
I could have queried for an
image element in my document.

00:26:58.030 --> 00:27:00.570
In this case,
I'm just doing it through JavaScript,

00:27:00.570 --> 00:27:04.060
so I've created a new image object,
and I've set the source to be some URL.

00:27:04.500 --> 00:27:08.140
And we have to imagine here that I've
actually waited for the image to load.

00:27:08.140 --> 00:27:10.410
I probably would have added a
load event handler and made sure

00:27:10.410 --> 00:27:11.860
the image has actually appeared.

00:27:11.860 --> 00:27:15.150
And once I've got that image,
I'm going to call one of three functions,

00:27:15.150 --> 00:27:17.350
the three variants of
the drawImage function.

00:27:17.410 --> 00:27:19.860
The first one,
if I just call drawImage with that

00:27:19.940 --> 00:27:22.880
image and I give an xy location,
it's going to draw the image at its

00:27:22.880 --> 00:27:25.920
native resolution into the canvas,
and that's its native resolution.

00:27:25.920 --> 00:27:28.940
Let's call that 500 by 500.

00:27:29.050 --> 00:27:32.140
The second type is, imagine I don't want
the native resolution,

00:27:32.140 --> 00:27:34.830
I give it the image and the
point I want to draw it at,

00:27:34.830 --> 00:27:39.760
and this time I've said that I want it to
be 300 pixels wide and 600 pixels high,

00:27:39.780 --> 00:27:41.040
and it scaled it.

00:27:41.060 --> 00:27:43.640
Now the third type is where
it gets really interesting.

00:27:43.750 --> 00:27:47.060
The third type,
again saying I want to draw it,

00:27:47.060 --> 00:27:51.260
it's the last four parameters, it's 0, 0,
500, 500, but instead I've got

00:27:51.260 --> 00:27:53.930
these extra parameters,
I'm defining a region within

00:27:53.930 --> 00:27:55.760
the image that I want to crop.

00:27:55.790 --> 00:27:59.240
So in this case I've said that I'm
defining a rectangle that starts

00:27:59.340 --> 00:28:03.040
at 230 pixels into the image,
130 pixels down,

00:28:03.120 --> 00:28:06.330
and it's 250 pixels square,
and then when I draw that image

00:28:06.330 --> 00:28:09.570
it's going to take that cropped
region and draw it at the 500,

00:28:09.680 --> 00:28:12.880
500 resolution, so I get this full image.

00:28:12.930 --> 00:28:15.160
Now you might be thinking,
well that's not that cool,

00:28:15.220 --> 00:28:17.790
but there is some useful things to it.

00:28:18.180 --> 00:28:23.320
So the guys that write this game
called The Incident are really kind,

00:28:23.320 --> 00:28:26.120
they make great use of this technique.

00:28:26.260 --> 00:28:29.920
This is not a web game,
it's a game that's available on the

00:28:29.920 --> 00:28:34.190
iOS store and the Mac App store,
but again it gives a great example

00:28:34.260 --> 00:28:35.920
of what we're trying to do.

00:28:36.240 --> 00:28:39.120
So here is the trailer for the game.

00:28:39.170 --> 00:28:41.120
Take a look at the guy
down in the bottom.

00:28:41.120 --> 00:28:46.120
So you can see he blinks, looks left,
looks right, says what the,

00:28:46.120 --> 00:28:51.110
and then runs out of the way,
he's running around and jumping.

00:28:52.990 --> 00:28:54.900
So this is actually how it's done.

00:28:54.910 --> 00:29:00.200
They've got one image element,
and then this image has an 8x8 grid of

00:29:00.200 --> 00:29:04.310
beautifully hand-drawn pixel frames.

00:29:04.400 --> 00:29:08.700
And so let's look at
the row down the bottom,

00:29:08.700 --> 00:29:11.860
and you can see there is Frank,
the character, and there's the frames

00:29:11.860 --> 00:29:14.640
where he has eyes open,
blinking, looking left, looking right.

00:29:14.640 --> 00:29:15.780
What's going on?

00:29:15.850 --> 00:29:20.360
And that -- so we could -- then
also scroll up to this row,

00:29:20.550 --> 00:29:23.090
and we see the running animation.

00:29:23.470 --> 00:29:25.560
So what we would do,
we would use that draw image command

00:29:25.560 --> 00:29:27.420
that we did with the cropping,
and we could do things

00:29:27.510 --> 00:29:29.760
like if we drew this frame,
this cropped frame,

00:29:29.760 --> 00:29:32.440
then this cropped frame,
then this cropped frame.

00:29:32.440 --> 00:29:35.940
It looks a bit better when we see it
in full screen with Frank stationary,

00:29:35.940 --> 00:29:38.500
so I'm going to draw this, this, this,
this, this,

00:29:38.600 --> 00:29:40.510
and you can see Frank's running.

00:29:43.090 --> 00:29:46.780
So let's have a look at this in practice.

00:29:46.910 --> 00:29:52.060
So again, the guys that wrote the game
kindly gave me the assets to use.

00:29:52.260 --> 00:29:54.060
And here I'm going to do it.

00:29:54.080 --> 00:29:56.810
You see,
here I am drawing the walking frame.

00:29:56.820 --> 00:30:00.780
He's got a bit faster
and he's starting to run.

00:30:00.780 --> 00:30:02.270
Again,
I just mocked this up pretty quickly.

00:30:02.280 --> 00:30:08.980
Do not take this as any indication
of how it would happen in real life.

00:30:10.060 --> 00:30:13.530
Yes, okay, so then we jump.

00:30:13.660 --> 00:30:16.900
So, again, I'm just gonna scroll along.

00:30:16.900 --> 00:30:21.260
It's slowly speeding up, and...

00:30:21.610 --> 00:30:23.770
So, it's failing there.

00:30:23.980 --> 00:30:26.060
But anyway,
that's an example of how you would get

00:30:26.060 --> 00:30:36.890
that animation in Canvas and how you
would possibly write a similar game,

00:30:36.890 --> 00:30:36.890
obviously with a little bit more graphic
design skill than my rectangular squares.

00:30:37.050 --> 00:30:39.680
So that's animation and interactivity.

00:30:39.950 --> 00:30:44.150
So I think actually by now that I would
consider you know how to draw shapes

00:30:44.220 --> 00:30:48.870
and how to add some cool effects that
you're almost like web graphics experts.

00:30:49.180 --> 00:30:55.640
But before we send you back,
we want to show you some more

00:30:55.640 --> 00:31:00.160
tips and tricks that really
maybe take it to the next level.

00:31:00.160 --> 00:31:00.160
I hate using that phrase.

00:31:00.540 --> 00:31:05.890
So through this talk,
I've mentioned multiple

00:31:05.890 --> 00:31:11.900
times that Canvas is,
in fact, a-- well, it's a vector API,

00:31:11.900 --> 00:31:14.330
and you're drawing
resolution independent.

00:31:14.500 --> 00:31:17.310
Once it's rendered, it is, in fact,
pixels.

00:31:17.420 --> 00:31:21.370
And we sort of describe
that as if it's a bad thing.

00:31:21.380 --> 00:31:24.560
Well, actually, it's time to stop
disrespecting the pixels.

00:31:24.600 --> 00:31:30.090
Because these effects that we're
going to show here are enabled purely

00:31:30.090 --> 00:31:33.420
because Canvas is based in pixels.

00:31:33.600 --> 00:32:44.300
[Transcript missing]

00:32:44.470 --> 00:32:47.600
So step one is I'm going to
declare a variable called input,

00:32:47.600 --> 00:32:51.950
and I'm going to get the currently
rendered version of the canvas.

00:32:51.970 --> 00:32:53.780
And I'm going to get the
full width and height.

00:32:53.850 --> 00:32:58.070
And then next I'm going to declare
a variable which is my output,

00:32:58.070 --> 00:33:01.840
which is where I'm going to
actually set pixel data into.

00:33:02.110 --> 00:33:03.880
And again,
I've done it the same width and height,

00:33:03.880 --> 00:33:05.400
but I've called
Create Image Data because I'm not

00:33:05.410 --> 00:33:07.620
getting it from an existing canvas.

00:33:07.650 --> 00:33:10.480
Then I'm just going to iterate
over every pixel in the image.

00:33:10.580 --> 00:33:13.070
It doesn't really matter
what the code is here,

00:33:13.070 --> 00:33:14.500
what I'm actually doing.

00:33:14.520 --> 00:33:16.520
You could do things like
change the brightness,

00:33:16.520 --> 00:33:22.160
multiply each one of the RGB values by
add 10% to make it a little bit brighter,

00:33:22.200 --> 00:33:24.080
or do some edge detection or whatever.

00:33:24.100 --> 00:33:25.800
Or in fact,
you could just set the pixels directly.

00:33:25.800 --> 00:33:27.050
You might not be reading them.

00:33:27.260 --> 00:33:33.210
But it's important to note here that
because every pixel has four units,

00:33:33.440 --> 00:33:37.480
that's why we get this offset where
we're multiplying pixel number i by

00:33:37.480 --> 00:33:42.720
4 and then adding 1 and then adding
2 to get 3 to get the alpha version.

00:33:42.840 --> 00:33:45.050
So once we've manipulated
that output array,

00:33:45.180 --> 00:33:49.210
we've got to draw it back
into the existing context.

00:33:49.420 --> 00:33:53.090
And I can either draw it as an
image or I can say put image data,

00:33:53.090 --> 00:33:57.560
and I basically replace
whatever's currently in the

00:33:57.560 --> 00:34:01.320
canvas with my manipulated data.

00:34:03.210 --> 00:34:04.140
Hey, Dean.

00:34:04.200 --> 00:34:06.760
Remember last week when you told me,
like, I could manipulate pixels?

00:34:06.760 --> 00:34:09.240
Well, now I've written this game,
and I'm drawing the same

00:34:09.240 --> 00:34:11.250
image lots of times,
and the performance

00:34:11.250 --> 00:34:12.570
isn't quite what I like.

00:34:12.650 --> 00:34:16.410
So let's imagine here we're
drawing this shape with canvas,

00:34:16.450 --> 00:34:19.160
and you'll notice it
sort of looks simple,

00:34:19.160 --> 00:34:22.450
but if we look a little closer,
it is pretty simple,

00:34:22.450 --> 00:34:24.780
but it's not completely basic.

00:34:25.280 --> 00:34:28.940
You can see it's got a colored stroke,
which is, you know,

00:34:28.940 --> 00:34:32.220
we've got to change the curves
into a lot of points and render it.

00:34:32.330 --> 00:34:35.740
It's got a couple of different shadings
of red and a gradient in there,

00:34:35.740 --> 00:34:37.300
and then it's got this white highlight.

00:34:37.510 --> 00:34:39.680
And if you're going to draw
this hundreds of times,

00:34:39.840 --> 00:34:41.850
then, you know,
there is actually a fair bit

00:34:41.850 --> 00:34:43.410
of processing behind that.

00:34:43.650 --> 00:34:46.090
So the way you do this typically
in graphics program is you would

00:34:46.090 --> 00:34:52.320
render to an offscreen buffer and do
the curve to pixel operation once,

00:34:52.400 --> 00:34:54.840
and then draw that
pixels into the canvas.

00:34:54.860 --> 00:34:58.260
And as I mentioned
before with the IE9 demo,

00:34:58.300 --> 00:35:00.860
drawing images into
canvases is super fast now.

00:35:00.980 --> 00:35:03.280
So this is a really great technique.

00:35:03.330 --> 00:35:05.720
So let's say I'm going
to draw this heart.

00:35:05.720 --> 00:35:09.000
I know that I'm going to draw it lots
of times at 100 pixels by 100 pixels.

00:35:09.060 --> 00:35:11.560
So I'm going to create
a new canvas element.

00:35:11.570 --> 00:35:13.200
I'm not going to put this
canvas into the document.

00:35:13.200 --> 00:35:15.430
I'm just keeping it in
memory in JavaScript.

00:35:15.480 --> 00:35:20.590
I set its width and height to
be 100 pixels by 100 pixels.

00:35:20.930 --> 00:35:24.070
And then I get the context
for that new canvas element,

00:35:24.070 --> 00:35:26.780
and I'm going to call
my function drawHeart,

00:35:26.780 --> 00:35:28.840
taking that context and the size.

00:35:29.170 --> 00:35:35.290
So now that I've got this,
I've now got this canvas object

00:35:35.360 --> 00:35:42.870
that's my rasterization of the heart,
then I can just use it as drawImage the

00:35:42.870 --> 00:35:42.870
same way we showed with previous slides,
at some XY location.

00:35:44.540 --> 00:35:47.150
Now,
it's important to remember that you are

00:35:47.280 --> 00:35:53.000
actually rasterizing that graphic so that
if you decide to draw it at some other

00:35:53.010 --> 00:35:58.570
size other than 100-100 in this case,
what you define it to be,

00:35:58.670 --> 00:36:03.680
you probably get some kind of artifact,
and that might not be good.

00:36:03.760 --> 00:36:06.350
Or if you potentially want
to transform it or rotate it.

00:36:06.350 --> 00:36:06.350
But this is a great performance tip,
so well worth using if

00:36:06.350 --> 00:36:06.350
it does suit your code.

00:36:07.240 --> 00:36:10.270
So now you've really got
this attitude as the expert.

00:36:10.370 --> 00:36:13.650
So, "Hey, Dean, you let me draw these
awesome canvas things,

00:36:13.650 --> 00:36:16.200
but, like, once the page is gone,
the image is gone,

00:36:16.200 --> 00:36:19.640
and I want to save that image."

00:36:19.900 --> 00:36:22.560
I'm glad you asked.

00:36:22.560 --> 00:36:24.930
So the Canvas element has one method.

00:36:25.030 --> 00:36:28.510
It's very simple,
two data URL and you pass a mime type.

00:36:28.570 --> 00:36:30.960
In this case,
I've said image ping because what

00:36:30.960 --> 00:36:34.850
this does is gives you back a string
which is an encoded version of a ping

00:36:34.850 --> 00:36:37.120
file that represents that Canvas.

00:36:37.120 --> 00:36:38.730
Pretty simple call.

00:36:38.840 --> 00:36:41.180
What can you do with it
once you've done that?

00:36:41.230 --> 00:36:42.200
What would you do?

00:36:42.200 --> 00:36:44.350
So now that you have this string,
it's just like any other

00:36:44.350 --> 00:36:45.400
string in JavaScript.

00:36:45.400 --> 00:36:48.880
So I could potentially put it in local
storage so that the next time the

00:36:48.880 --> 00:36:52.710
user comes to your page or my site,
I can extract it and they don't

00:36:52.710 --> 00:36:54.700
have to recreate the image.

00:36:54.710 --> 00:36:56.650
I could send it back to the server.

00:36:56.720 --> 00:37:00.190
It's important to note here that there is
some security restrictions there because

00:37:00.270 --> 00:37:05.400
obviously a Canvas can have access to
images that are from a different domain.

00:37:05.400 --> 00:37:07.640
So if you do draw images from a
different domain or data from a

00:37:07.640 --> 00:37:11.290
different domain into a Canvas,
you can't get the image

00:37:11.290 --> 00:37:13.120
data back out of it.

00:37:13.120 --> 00:37:16.180
But if you could,
you could send it back to a server.

00:37:16.180 --> 00:37:18.150
Or lastly,
this seems like a pretty obscure case,

00:37:18.230 --> 00:37:21.930
is you could actually create a new
image element and set that -- set the

00:37:21.980 --> 00:37:27.400
source attribute of that image element
to the data URL that you just created.

00:37:27.400 --> 00:37:28.320
And you're thinking, well, wait a minute.

00:37:28.400 --> 00:37:29.960
I've got the image in the page.

00:37:29.960 --> 00:37:32.870
So why would I want to do this?

00:37:33.210 --> 00:37:37.500
So this, I've got basically a
full screen canvas here,

00:37:37.500 --> 00:37:41.410
and let's say I want to draw on it.

00:37:42.400 --> 00:37:46.300
So here I'm just drawing some radial
gradients with a little compositing mode.

00:37:46.370 --> 00:37:49.490
And I can actually-- because
it's a scripted image,

00:37:49.560 --> 00:37:53.690
I can actually-- I've taken a record
of what I drew so I could replay it,

00:37:53.810 --> 00:37:55.740
for example, to the user.

00:37:55.740 --> 00:38:04.240
Oops.

00:38:04.320 --> 00:38:06.810
So let's do something cool.

00:38:06.810 --> 00:38:06.810
I want to write--

00:38:18.130 --> 00:38:19.860
So, okay, now I've got this.

00:38:20.090 --> 00:38:22.320
Now I want to actually
make use of this image,

00:38:22.450 --> 00:38:23.740
so I'm going to hit save.

00:38:23.950 --> 00:38:26.800
Now what I did is this technique
here where I've created a new image

00:38:26.850 --> 00:38:35.790
element with the value of the canvas,
and now, thanks to iOS,

00:38:35.790 --> 00:38:35.790
I can tap and hold on
this image and save it.

00:38:35.900 --> 00:38:43.500
[Transcript missing]

00:38:43.850 --> 00:38:45.060
Boom.

00:38:45.090 --> 00:38:47.620
And the next session
we'll get a nice surprise.

00:38:48.110 --> 00:38:50.610
I said both.

00:38:55.300 --> 00:38:58.740
So we, we,
I talked about manipulating pixels.

00:38:58.740 --> 00:39:00.570
Let's have a look at this.

00:39:00.570 --> 00:39:03.940
You don't actually,
one of the things with this,

00:39:03.940 --> 00:39:07.610
being able to manipulate the
pixels is the sort of range

00:39:07.620 --> 00:39:09.780
of possibilities is endless.

00:39:09.780 --> 00:39:12.350
You can actually do whatever you want.

00:39:12.580 --> 00:39:14.100
So here's an example.

00:39:14.100 --> 00:39:19.140
And in this case I've got a video element
in the page and this is the canvas.

00:39:19.140 --> 00:39:22.330
And where I call draw
image on an image element,

00:39:22.330 --> 00:39:25.240
I can actually still call draw image.

00:39:25.300 --> 00:39:28.450
So I can actually draw image
on a video element and it's

00:39:28.450 --> 00:39:32.040
going to draw the current frame
of the video into the canvas.

00:39:32.140 --> 00:39:34.230
So here it is drawing the feature.

00:39:34.230 --> 00:39:37.960
Now, you notice that there's a
lot of white background here.

00:39:37.960 --> 00:39:41.770
So I can actually check the,
check the pixels and detect when I'm

00:39:41.770 --> 00:39:46.500
getting a block of white images and in
fact composite that over another image.

00:39:46.500 --> 00:39:50.970
In this case they're on,
the iPad is floating in midair in Hawaii.

00:39:51.230 --> 00:39:52.550
So I can do other things.

00:39:52.560 --> 00:39:54.280
It was easy to find those gray images.

00:39:54.280 --> 00:39:57.480
I could actually maybe now
manipulate the pixels here.

00:39:57.480 --> 00:39:58.680
I've upped the green.

00:39:58.850 --> 00:40:05.410
And I have risked my career by
making Phil Schiller look like Shrek.

00:40:05.740 --> 00:40:07.800
But I can go even further than this.

00:40:07.820 --> 00:40:09.230
I can sort of do a
whole of mirrors effect.

00:40:09.350 --> 00:40:11.460
So here I am getting the pixels.

00:40:11.460 --> 00:40:12.870
It'll start over again.

00:40:13.000 --> 00:40:17.110
And I'm drawing them again multiple
times with sort of varying opacity.

00:40:17.110 --> 00:40:20.500
Yeah,
you can do all sorts of stuff with this.

00:40:20.500 --> 00:40:22.330
It's pretty cool.

00:40:30.830 --> 00:40:35.660
So that's finished section three,
and so now it's what you have learned.

00:40:35.660 --> 00:40:37.430
You've done some basic shapes.

00:40:37.590 --> 00:40:40.630
We've done some interaction activity,
and then we've shown that you can

00:40:40.630 --> 00:40:43.430
actually do some amazing stuff if
you take it a little bit further,

00:40:43.430 --> 00:40:46.200
even though the operations that
enable this are quite simple.

00:40:46.200 --> 00:40:50.180
So to wrap up, so maybe some of you came
to this talk thinking,

00:40:50.180 --> 00:40:52.190
oh, well,
I really hope that he talks about

00:40:52.200 --> 00:40:55.720
something and tells me which of these
two technologies is the winner because

00:40:55.720 --> 00:40:57.880
there's people on the web that say,
oh, this sucks and that.

00:40:57.940 --> 00:41:00.660
Well, unfortunately,
the answer is they're both winners,

00:41:00.660 --> 00:41:03.670
and it's really more a case of
looking at the problem that you

00:41:03.670 --> 00:41:06.470
have and asking questions like,
does it need to be accessible?

00:41:06.480 --> 00:41:09.070
Do I have programmers that
are more familiar with

00:41:09.070 --> 00:41:11.140
JavaScript than maybe designers?

00:41:11.140 --> 00:41:16.240
Or do I need to style it with CSS?

00:41:16.240 --> 00:41:19.030
But the real point is that, you know,
you've got these two

00:41:19.030 --> 00:41:21.960
technologies that are really,
as far as 2D graphics are,

00:41:21.960 --> 00:41:23.430
are almost limitless.

00:41:23.490 --> 00:41:24.440
You can do whatever you want.

00:41:24.440 --> 00:41:28.200
And if you combine that with the
amazing speed increase that's

00:41:28.200 --> 00:41:31.730
available on Safari Online and iOS 5,
now, like,

00:41:31.820 --> 00:41:35.790
the web platform in terms of graphics
is really -- we're looking forward to

00:41:35.790 --> 00:41:37.720
seeing what stuff you come up with.

00:41:37.720 --> 00:41:39.650
So there's some other sessions.

00:41:39.740 --> 00:41:41.900
Unfortunately, the iBooks one,
which is a place where you can

00:41:41.970 --> 00:41:43.720
use lots of these technologies,
was earlier, so you'll have to catch

00:41:43.720 --> 00:41:43.720
that in the replay.

00:41:43.720 --> 00:41:49.150
But coming up next right here
is how to use -- what's new

00:41:49.240 --> 00:41:52.810
in CSS effects and animations.

00:41:53.150 --> 00:41:55.310
We're not competitive here,
but we like to think in the

00:41:55.450 --> 00:41:59.230
Safari team we have the best
evangelist that Apple has to offer,

00:41:59.330 --> 00:42:03.570
and that's Vicky Murley,
who you'll see on stage in a minute.

00:42:03.570 --> 00:42:06.730
Both of these technologies
are from the W3C,

00:42:06.780 --> 00:42:09.830
so while there's the
Safari Developer Center on

00:42:10.720 --> 00:42:14.730
developer.applecom,
there's also the specifications on W3C,

00:42:14.730 --> 00:42:18.250
and the joke I always make
is they will come out with an

00:42:18.470 --> 00:42:20.550
English language translation one day.

00:42:20.550 --> 00:42:20.550
And with that...
---
Title:  Turn-Based Gaming with Game Center
Year:   2011
Web:    https://nonstrict.eu/wwdcindex/wwdc2011/412/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Hello, everybody. I'm happy to see so many people here interested in turn-based gaming. For those of you who were around earlier, you would have seen some of the other interesting things we can do with Game Center, but this is totally new for iOS 5 and turn-based gaming. I'm Gabriel, and I'll be with you for the next hour, hopefully, and we have a lot to say. So this is Game Center and the Game Kit framework. We've seen this before. There's really three pieces to this. It's a Game Center app. There's a Game Kit framework and Game Kit services.

And so what I'm going to be talking about is just turn-based gaming, and that really falls into the middle category. And there's a set of APIs that we provided for you that will allow you to create turn-based games. We think of these as social asynchronous, a little bit leisurely. People don't have to be there all at the same time, but we're really going to be focusing on the middle piece for now.

Just an introduction, some of the things I'll be talking about. As I mentioned, turn-based gaming is new. I hope to see in the next few months a whole bunch of new turn-based games. I'm going to talk about the API and the user interface that we provide to help you create these games. We'll talk about different types of games that you can create.

I'll talk about how you can manage the game, so the state of the game and the flow of the game, how people -- how you pass the turn around, essentially. And I'll go over a bunch of code from the API so you can actually see how it's implemented. And that will be a little bit of a demo.

Specifically what I'm going to be talking about sort of in this order in a few different ways. The Game Center turn-based API basics. So what are the basics that you need to know in order to get your turn-based game off the ground? What handlers you need to implement, what notifications you'll get, all those kind of things. I'll show you how you can start a new match.

I'll show you how you can make turns in a match. Notifications that you'll need to handle. And finally, how you finish the match once you're done. So what is a turn-based game? A turn-based game really is a game that has turns. So each individual participant in the game will go sequentially.

And not everybody has to be there at the same time. Some examples of turn-based games. We can do chess, checkers, backgammon, go. Some sort of standard type games. Something a little bit more complicated would be a bridge. Card games where you have multiple people. I mean, it's clear that the turn goes around in the bidding. Those are familiar with bridge now, right?

And obviously all the interesting things that you're going to come out with. We've all seen instances of board games which could be implemented as turn-based or some strategy, not necessarily real-time strategy, games. And I'm really excited about this. And I can't say how much I'm looking forward to the games that are going to show up on the app store. Here we actually have an example. So one way that we've been visualizing this is people sitting around a table playing a game.

And one person has the turn. So that person is the only person in the game who can affect the state. So they have the dice. It's their turn to roll. They're going to move. Everybody else is sort of waiting. And traditionally the turn will go around the table in sort of an orderly manner, each person having their opportunity to take one turn at a time. We've also introduced an interesting concept to this which was matchmaking.

And so we've seen P2P matchmaking where essentially when a P2P match, a live game we've been calling it, is everybody needs to be there at the same time. And so what we've done is we've actually developed a game that's kind of a matchmaking type of thing. And with matchmaking, what you find is you want to start a match in a turn based game, but there aren't really people there yet. Right? And it's asynchronous. So they can be filled in as necessary.

So what happens in our implementation is as you make turns and you go around the game, you're going to set the turn to a participant who might not actually have a player in the seat yet. And as it becomes their turn, the matchmaker will find a person for them and fit them into their slot. So it will be their turn and they will be able to go.

This is really interesting because it has the effect that every time that I go and I create a new match and I matchmake into it, it's my turn. As soon as I get a callback from the matchmaker view controller, in this case it's a turn based matchmaker view controller, it's my turn.

The other thing is to talk about the control. So we've seen it go around the table in a clockwise manner, but it doesn't have to. When you end your turn, you say who the next participant is and it can go in any direction. It can be the next person, it can be the last person, it can be the person across the table from me.

We don't define that at all. And lastly, what we do support is we support multiple matches. So you can have up to 15 matches at a time. Some of them is your turn, some of them is somebody else's turn. Because of the asynchronous nature, I'm going to go in one and I'm going to send a notification to the persons that I'm playing, to the person whose next turn it is, and while I'm waiting for them, to return to me, I can go and I can start another game or I can make a move in a game that I've been invited to, all sorts of instances like that.

I'm going to show you a little bit of what the UI that we're providing. So you would typically start your game and here I have what we call a turn based matchmaker view controller. And it really has two functions. And the first function is to show you a list of the games that you're currently involved in. Right?

The ones that are my turn, there's three sections to this. The first section shows you the games which require your action. So it's my turn. I have the ability to change the state of the game. I have three games here. The first one is with Jessica. The second one with Eunice. And the third one is an auto match player. It's a new game. I haven't started. It says when the last turn of the game was. The second section is the other player's turn.

So if I'm in a multiplayer game and there are other people sitting around, virtually sitting around, playing the game, we can see when they made their turn, whose turn it is, a little notification. And again, I've showed you an example of an auto match player. So in this case, I've actually made the first turn. And I'm waiting for somebody to come and claim their spot so that they can take the second turn. The third section in here is a game over.

And you can see here we have a little custom message which you can play. You can provide. So there were two different games there. And we can show those. The second functionality, if you notice right at the top right-hand corner, there's a plus button. And this will allow you to create a new match. And the view for the new match looks very much similar to the P2P match maker.

So you're all familiar with this. It allows you the ability to invite somebody. Here I've invited my friend Eunice. It allows you to set slots as auto match. So this would be a three-person game where Eunice would be second and an auto match would be that empty seat.

: This is really interesting. And lastly, what we do is we provide some support in the home page so that we badge your app for you so you can easily -- your users can easily see how many turns they have. In this case, I have turns in two different matches. And we support the new notifications. So we can see here it's an invite notification from Unus.

Now what I'd like to do is bring back Jordan Ceccarelli to the stage, our ace achievement hunter here, to show us a little bit of how this works in action with the game that we've been showing all morning, which is Rochambeau, Jordan, how about it? All right. Turn-based games. Woo! Exciting. Okay. So here we go.

Many of you, if you were in our other sessions, we did single player and multiplayer games, may have wondered that we have a badge here for Rochambeau. And this badge actually means that we have two turns that are waiting us. So it's actually two games that are waiting for us to make our move. So at a quick glance, looking at the springboard, you can go, oh, okay, cool. We've got two turns.

So here's our app. We're going to go into turn-based because that's what we're going to focus on right now. And here is the matchmaking screen that Gabe was just talking about. And much like our other ones, you know, it should look pretty familiar. It's got the green felt. You have the header up top, the icon.

The awesome star rating so you can actually have your game rated from this, which is very cool. And now you've got your three sections. The top section is your turn. This is literally, you know, they're playing checkers, chess. It's just waiting for you to make the next move. The other player, you know, they have their phone in their pocket. They're doing whatever they're doing, and they're just waiting for you to make a move.

The second section here are turns that you can make. They're just waiting for you to make a move. The second section here are turns that you can make a move. The second section here are turns that you can make a move. And so you can see how many outstanding games you have.

And then finally we have the game over section. And these are games that you've completed. And this section, you know, it's kind of up to you for what you would like to show for this. It could be the board's last state. In this case, it's going to be just replaying the Rochambeau game. Because, you know, maybe you totally kicked butt and you want to go back and watch it again. So let's go through these. Let's do one where it's my turn. So let's go through these.

Let's do one where it's my turn. So someone has sent me a game here. I don't know what they've picked. Rock, paper, scissors, I'm not sure. So I'm feeling lucky. Let's go scissors. Looks like we both picked scissors and I picked it a little faster. No, I picked it a little slower. Ugh, okay, I lost. I was getting excited on that one. So I've lost the crown on this one, but it was a fun game.

Losing sometimes is fun. So we go back to our turn-based here and you can see that game has been removed from your turn. The game is now over. It's done. So let's say for some reason I want to show that game to my friend. Oh, you'd love to see this. I had this awesome tie. I thought I was going to win, but I lost. And your friend is like, oh, that's lame. But you're like, you can show them at any point.

So say you're done with that. You're done with that game. It's a harsh memory you don't want to remember ever again. So you can come here and you can just swipe the game and you can remove it. So this game is now gone. I don't have to relive this memory again.

Likewise, let's say you've made a turn and it's been on your friend, it's been a couple days, you're trying to play a game with them, they don't want to play the game anymore and you don't want this on your list anymore. You can just slide and actually resign from the game. The same goes for ones where it's your turn, you can just slide there and quit from the game.

So let's create a game. So here we have our regular matchmaking screen. You can invite a friend. You can auto match. You can add players here by selecting this. You can remove players. Let's say we want to get in a scenario where you want to invite one player and you want to auto match one player. You can customize this how you want. In this case, for a single auto match, this is going to place me up against another player who is also looking for a two-player auto match game.

The neat thing about turn-based games that a live game won't have is the concept of always being your turn. What does that mean? In this case, when you create a game, guess what? When you create the game, you're making the very first move. It's always your turn. When you want to make a game, boom, your turn.

Your friend doesn't get notified when you create this game. Because then your friend gets the notification and then what? Then they wait around and that's no fun. Your friend is actually going to get the notification after you've made your first turn. Your friend gets the notification, hey, do you want to play Rochambeau? You're like, okay, cool. When you click on it, guess what? It's your turn as that player. And so it eliminates the waiting, trying to get your friends together, like, oh, let's wait for this person. He's finishing dinner. This guy is playing Xbox.

We want everyone to get together at once. This is just you make the game, you make the move, you send it off, and when the other player gets it, guess what? It's their turn. They're good to go. So we're going to send, let's say, our friend Eunice. We'll send a match. Hey, let's play.

So we hit play now, but again, they're not receiving any notification of this. In a live game, they would have. So in this case, I'm going to pick paper because I like paper. And now we're back here at the menu. I can move on with my life. I can go to another game. I can go to another turn-based game. And this will wait until Unix makes their move.

And in this game, if Unix makes their move, it'll immediately cut to the game so I can see in real time what actually happened, and then I can go back and watch it again. So with that sheet, you can, once again, play your games that are waiting for your turn.

You can see your games that you're waiting for their turn, and you can rewatch games you've played. You can delete them at will as well. You can resign. Turn-based games is very exciting. I'm really, really, much like Gabe, looking forward to playing some of these. It's new for Game Center in iOS 5. Right on, guys. We're really looking forward to that. So thanks a lot. Gabe, back to you. Take it away. Thank you.

[Transcript missing]

I'm trying to follow the flow that Christy did in the Ready, Set, Go, but it's not exactly the same. But here we go. You want to start a match, you need to pick players in a match, and there's a few different ways that we can do this. You can use our matchmaking UI. You can bring it up from in-game. You can hit play from Game Center. That works for turn-based gaming as well.

And a user can accept an invite. So they're not really deciding who's in the game, but somebody's invited them to a game that already exists. Once you have the players, there's a few different ways that you can get the match. Did find match, which is a delegate callback on the view controller, which I'll show you on the next slide. There's load match data. So if you have the match ID, maybe you created your own UI. But if you have a match ID that you know, you can load the match directly using that.

And you want to take your turn, which is end turn. So you're going to be passing the turn around to different folks. They'll see the updated match data. They'll see your message. They'll be able to make some action on the game. And they'll end turns. And this will go on until the end of the game, at which point you have basically three exits. You can quit, whether it's your turn or whether it's not your turn. There's a few different subtleties there. If it's your turn, you hold the baton and you need to pass it off to somebody. Otherwise, it's dead in the water.

And you can end the match. So ending the match basically ends it for everybody. I just won. Everybody else is done. So these are the different -- I'm going to try to do them in order. All the different sort of activities, tasks that we can do. We talked about the view controller. You've seen it. I just want to reiterate before I show you how to use it.

You use this in your game so that you can allow your user to choose a match to play. They can quit from the match. They can remove a match from the list. They can do all those kind of management stuff of their game lists. There's the ability to create a new match. Right? And we've seen we can do that using invites. And we can also use auto match. And I'll show you both of those.

So this is how you can use the view controller. The first thing, it's kind of a repeat. You've seen the match request. I'm not going to go over the match request. But it's exactly the same match request that we used for P2P and hosted multiplayer. So the properties on there that you're most interested in, it would be the minimum player. The maximum number of players. Right? You want to initialize the view controller. In this case, it's clearly differentiated.

It's called a turn-based matchmaker view controller. So this is for turn-based only. You initialize it with the match request. The next couple of lines, this one is interesting. Show existing matches. So we've seen that there's two screens. Or there's sort of like two screens. The first one is the list of all the matches that you're currently involved in. And the second one is more of a -- you know, more of a creation.

So to create a new match or to get matched into a new match. To get auto matched. And so we allow you the ability through some of the APIs to generate your own lists and you can create your own UI. But if you want to use our UI, just set that property on the view controller. Show existing matches. And that will bring up the list of matches.

There's a delegate. It's a turn-based matchmaker. Should be turn-based matchmaker view controller for you. Right. And I'm going to go over the delegate callbacks on the next screen and then present the view controller. So this is all very similar to what we've seen earlier if you've been here. Or you've created any P2P games using Game Center in the past.

So here's the delegate callbacks. There's four of them. The first one is the one that we're most interested in. I did find match. So you will get this whenever the user selects a match. This is, you know, it's my turn. I want to go. It's the end of the game. I want you to replay it or I've just created a new game or just been matched into a new game.

So the first thing I do is I dismiss the controller. Right? And then the second thing I do is I'm checking to see whether it's my turn. Because if it's my turn, right, I show the state of the game. I missed that, right? So you want to update your UI. This is the match that the player is interested in. Show the board.

Show the, you know, it's totally your game. So I can't... You can't fathom yet what's going to be there. And this will give you a quick way to check to see. So what I'm doing is I'm taking the current player ID, right, and I'm checking to see if there actually is one because it might be on a matching slot, in which case there's no player ID.

And if there is one, I'm comparing it to the local player's player ID, which would be the person who's logged in on the device. And that way you can tell whether it's my turn. If it's my turn, I want to go. So allow user actions, allow me to submit my turn, whatever it needs to be in your game for me to actually go.

The second view controller delegate callback is player quit for match. This one I'm not going to go into too much details now other than showing it. But when I talk about quitting later on in the session, I'll revisit this one. So because we have this concept of it's always one person's turn, you can think of it as there's a baton that you're passing around the different participants. And if I'm holding the baton and I quit, right, then the game's pretty much dead in the water unless I have an opportunity to pass it off as I quit. And so that's exactly what this is.

Participant quit in turn. So I give myself a match outcome. Maybe it's just quit. I define who the next participant is. Who should get the turn? And if there's any updated state, so maybe I have to remove my pieces from the board, that kind of thing, I have the ability to do it here. But I'll go into a little bit more detail later.

This is the callback that we expect. And this will actually remain in our UI. Right? So you're still in our UI. They swipe. They quit. You get the callback. You quit the game. And then we go back to our UI. We stay in our UI. You shouldn't necessarily dismiss -- in fact, you shouldn't dismiss the view controller at this point.

So the first thing is if I cancel, I decide that I don't want to look at a game or I just wanted to look at my games but I don't really want to play any, there's a cancel button in the top left-hand corner. And you should handle this just by dismissing the controller is probably best. And then the last one is there's a failure.

Maybe you're not online and I tried to create a new game or -- I mean, there's a few different cases there. But you'd want to handle the error, dismiss the view controller, go back to your menu, go back to whatever the user was doing before. you brought up the view controller.

So invites. Here you can see I've invited Eunice. I haven't pressed play yet. Invites, as Jordan mentioned before, are also asynchronous. So unlike P2P where we've seen it goes through this phase where I send an invite to somebody, they respond to it, we go through a connecting phase, and it's not until everybody's ready that I can start to play the game. In this case, I'm inviting Eunice. She'll be attached to the game. She'll get the invite when it's her turn. She'll get a notification. But it means that when I press play now, I'm going to get a match back. It's going to be my turn.

I'm going to go. Right? There's one sort of caveat declining. If somebody decides that they're going to decline an invite, since they only get the invite on their turn, they're stuck holding the baton. And there's really not much that we can do at that point because they might have declined because they don't have the application installed. They might be on an iOS 4. device. I mean, there's a few reasons for that. And we can't guarantee at that point that we're going to be able to give control back to the developer so that they can choose where the baton should go.

It's unfortunate, but it's the nature of turn-based games. Here what I've done is I've updated this a little bit. You can see what happens after the invite. This would be the match that would be returned to me. Right? So it's match 001. It's really a UUID, but just so that I can keep the slides differentiated. The current participant in this case is me.

I'm the local player ID. I just started the game. I have an invited player ID, and their status is invited. So they haven't responded to this yet. It's my turn. I can go. When I go, I'm going to decide I'm going to change the current participant so the next participant will be the invited person, and they'll actually get the invite.

The other way we can support is matchmaking. So auto match. Right? Well, I just leave the slot open. I don't invite anybody. And they'll get filled in. Since it's asynchronous and that person doesn't actually get filled in until it's necessary, the same scenario happens. I'll get a match back. It will be my turn. I can go. We'll fill in the slots as necessary.

One other thing that might actually happen here is I might get matched into a game that's already ongoing, in which case I would be that auto matched player. Right? But in all cases, it's my turn when I get this match back. Right? You obviously can do this. You can have up to 16 people. You can have some invited, some auto matched. It works really great. Whenever I set the next participant to a match, to an auto match player, our services will find a player for that.

For that seat. And it kind of looks like this. So the other one, I had the second player was actually Eunice. I invited her. She had a player ID. In this case, there's no player ID, and it's just status of matching. It's a second match. Distinguished a little bit. And the status on the match is matching instead of being open.

What happens is as I'm going through, I'll make the next turn, and the server will find somebody for that person. Right? So now I have a remote player ID. He's active. It's his turn. He's just been returned. And the status on the match becomes open. So this will make more sense as I go through some of the other code pieces. The next thing that I need to talk about is event handling. three different types of events.

Invites from Game Center. So we've seen that. If I'm looking at a friend's games list and I have, you know, I decide I want to play him, I'll play him. We'll send you a notification. We'll send you kind of notification, but you'll get a call back on one of the delegates that says, I want to invite these people.

Turn notifications. So if you've been invited and you accept the invite or it's an ongoing game and the turn comes back to me, there's a notification. This one will actually have a notification in the notification center and a call back for you. Similarly, once the game is over. So when I end the game, a notification goes out to all the participants in the game that the game is over. So they have the ability to look at the resolution of the game. And I'll show you some. Some of the event handler delegates.

The first one is handle invite from Game Center. So this is very similar to getting a player, a list of players, right? You get a list of, you get an NSArray of players to invite. You start with a match request. The difference is you attach that players to invite that array to the match request.

And you initialize a view controller in the same manner that you did before. In this case, what I've done is I've. Show existing matches no, because the user is clearly in shown his intention that he wants to invite somebody. So I can skip the first screen, go right to the match creation screen.

I set myself as the delegate so I can handle the callbacks and I present it. So the user will see it. The next notification that you'll get, the next callback you'll get is a handle turn event for match. So this means that a turn is now available for you.

And it could be in any one of the outstanding matches. And it won't be the greatest user experience if I'm in the middle of one match and I get a turn notification for the other match and you pull the rug out from underneath me. So what I'm doing here is I'm checking just to see whether the match that I'm looking at is the same one as I just got a callback on.

Right? If it is, then what I can do is I can update the state in real time that I'm looking at. Otherwise, maybe I want to delay presenting that to the user. Maybe I'll want him to pick it from a list. Maybe I just want to notify him that there's a turn somewhere else, right?

If it is, I'm going to want to update the match that I'm currently holding because there's new data there. It's my turn, so I want to update the UI and I want to allow turn submission. So that means allowing actions in your game, in your UI that will allow me to Do what I need to do to make the next turn. Handle match ended. Same thing. I'm just checking to see whether it's the match that I'm currently looking at. If it is, then I can show the resolution right away. Otherwise, maybe I want to delay it, depending on where I am in the state of your app.

Those are the three delegates that you're going to need to implement. Here's a little bit more details about the actual class. So it's a GK turn-based match and these are the properties it has. So it has a match ID I've talked about before. It's a UUID. There's a creation date so you know when the game has started. We show this.

You can use this in your own UI if you're creating your own UI. Indication of when... helps the player maybe decide which game it is that they want to look at. There's an array of participants. There's a status. There's a current participant. That's the one whose turn it is. Match data, which is the state of the game. We store in our servers for you. And there's a custom message. So that custom message gets passed with the notifications on turns and at the end of a game.

And then there's the GK turn-based participant and the properties player ID, which might not be there if it's a matching. The last turn date, if they've ever made a turn. It will timestamp it when the last turn that that participant made. The status, which could be active or done or matching or invited, those kind of things. And a match outcome, which we can use to show on our UI and you can use to show on your UI.

So submitting a turn. This is, you know, primarily the meet. So it's my turn. I've gotten the state of the data. I want to update it. I want to pass it to somebody. So the first thing I do is I update the match data. This is a function that you're going to create because the match data is yours. It represents the state of the game.

The players are on the board. Those kind of things, right? The next thing I'm going to do is I'm going to pick our next participant. I've just shown you a simple example here of actually picking the next one in the list. So I get the index in the array of participants, right?

I add one, mod it so that it goes around in a circle, and that's the next person. What you'd really want to do is in a more advanced case, you'd want to look to see if the status of that player is appropriate. If somebody who's quit, you don't want to give the turn to somebody who quit. That's going to be an error. But it's pretty simple. The next participant has to be an object that comes from that participant's array. Otherwise, it's an error. And then I set a custom message.

Finally, once I've set all the parameters that I need, I call end turn with next participant. Defining who the next participant is, match data, define what the new match data is. This is going to be sent up to our servers and stored there. And a completion handler. So when it's done, if there are any errors, maybe my match data was too big, we limit it to 4K. Maybe the next participant doesn't make sense. Maybe it's not even my turn. So those are some of the errors that you might get back.

Now I'm going to show you what the match looks like after I've made a turn. So you can see the first match that I was playing with Eunice. There's my custom message that I just set. There's my match data that gets associated to it. And now the current participant is pointing at her because I just set it to her. So when she downloads, she'll get a notification. The match will get loaded. This is what she'll say.

It's her turn only from her perspective. She'll be the local user. So a little bit on turn flow. I showed you the diagram at the beginning where you saw it turn around on a clock. But essentially we've been talking about this baton. So the match data and the next participant, sort of the keys, can only be set by the current participant. If you try to do an end turn or an end game and it's not your turn, you'll get an error back. That's really what turn-based gaming is.

One person has control at a time and they pass it around. The next participant can be set to any participant. You can even set it to yourself. If you want to make a turn and then make another turn, okay. I'm sure there's use cases for that. I can set it to the person on my right, the person on my left, anyone. Anyone in that participant array. Of course, if I set it to somebody who's matching, that's an indication that when you upload it, we need to find somebody who's going to match to that spot.

So we're going to find the next person who's going to come in, who matches, to match those parameters, and give that back to him and it's his turn or her turn. So that's turn flow. But the focus here is that there's really only one person that can make changes to the match at any one time. And the flexibility of the changes that they can make.

Match data. It's in NSData. It's stored on our servers. It's defined by you. It's interpreted by you. We treat it sort of like an opaque blob that we pass around with the match. It's limited to 4K. So you're going to need to be a little bit creative on how you can store this data. Some examples, player positions around a board, what their last turns were.

If you don't find that there's enough space, you can use this as a pointer to your own server if you need more than 4K. One of the things that we might suggest is you can use it as a pointer to some static data already in your app. And this is the cool thing about being stored on the server is that it can be retrieved on multiple devices.

So if I'm playing a game and I start it on my iPad and I leave my house and I get a notification on my phone, oh, this is cool. I'm riding the bus to work. And I can take a turn. So I do. Right? And it loads the data and it gives me an updated state of what's really going on now. And it's cross-device. So that's pretty cool.

Quitting a match. So we've done the turns, right? We've updated the state. We've shown how you can pass the baton around. And now I actually -- okay, I'm done. I'm over with, right? Quitting a match is one of the ways that you can end your game, sort of abandoning it. And there's three different ways that you can affect a quit.

Quitting from a match when it's your turn. So there's API calls for the first two. And then there's a callback for the second one. Quitting a match when it's not your turn, when somebody else is in the match turn. And then finally quitting the match from the UI. That's -- I made reference to that before. I showed you the slide. But I'll actually talk about what the different parameters mean. You might be a little bit more familiar with it now. It's a callback from our UI. So you can quit from our UI.

If you've implemented our UI. So, quitting a turn. It's my turn, I have the baton. I don't really want to play anymore, but I don't want to cause the rest of the match to die. So, I'm going to pass it off to somebody. Right? And so, what I have to do now is I have to determine what the data is. So, the new match data, update it. I have to pick the next participant. I have a little function called choose next participant from the match. And I call participant quit in turn with outcome. So, I'm giving myself an outcome of quit. GK turn-based match outcome quit.

But there are a few others you can use. Lose, for example. Next participant, who I define who gets the baton next and who has the ability to make the next move. And updated match data. It gets sent to our server. It's a completion handler. I suppose you should handle the error if there is one because you're offline or it's not your turn. Those kind of things. And the play can continue without you. What you'll see in what the match looks like I'll show you in a minute after I go through the other two methods of quitting.

So quitting out of your turn. Really not much you can do, right? You don't have control of the board. You don't have control of the game. You can't change the status of the game. You can't change the data on the game. You can't change whose turn it is. All you can really do, this is kind of like an abandon, right? So what you can do in this case is you can set yourself to a match outcome. You can quit the game. And it's really simple.

And of course the last one is probably the most complex one, right, is the callback. So this is a delegate callback on the matchmaker view controller, on the turn-based matchmaker view controller. It's called player quit for match. So this indicates that the player actually quit. So I brought down the UI and there was one of the sections that was my turn and I don't want to play this game anymore, so I swipe and I press quit. Well, you're holding the baton. You need to pass it off as you do this. So we give you that ability.

We'll call you back, player quit for match. And essentially what you have to do is as if you were making a turn or you were quitting from turn, it's exactly the same thing. You have to define what the new match date is going to be. You have to choose an ex-participant and you call participant quit in turn without count. If you don't implement this, then it's going to be a poor UI experience because somebody is going to swipe to quit.

We'll call you back, you ignore it, and the person never actually quits. So we give you that ability. If somebody actually quits from the game, maybe you've implemented it so that they have to load it and quit it. We suggest you implement this. It's not all that difficult to do. And here you can see the parameters on this were next participant and match data. So quite simple.

This is what the match will look like after you quit. So the local player is done, not involved in the game anymore, and my status, my match outcome was quit. And I passed it off. So I guess this would be Eunice, right? Would have the ability to choose, you know, does she want to continue the game?

If it makes sense, if there are multiple people in the match, it certainly does. In a two-player match, maybe your quit is really an end match, but that's okay. You have that kind of flexibility, right? And so lastly, the last kind of task that you would need to accomplish for this is ending a match. Right? Again, you need the baton to be able to end the match, right? So only the current participant, if your local player is the current participant, then they will be able to end the match.

You need to set outcomes for everybody. The game is going to be over. There really is no next participant after this. It will show up in the game over section for everybody. And a notification is going to be sent to all the other participants. I'm not going to send a notification myself. Doesn't make too much sense. And this is what it looks like. So the first thing I do is I'm setting outcomes. There's a match outcome, which we've seen is a property on one of the participants.

In this case, I'm just setting everybody to tied. It's really simple, just for an example, but you really want to set the appropriate one. Whether somebody won, whether somebody lost, it's a bit field and there's even a section there for you to be able to set your own.

Custom outcome that you can use if you're creating your own UI or you want to present in your game. I need to resolve the game because this is the last chance that I have to set what the data state is going to be for the game. Everybody will see this as a result of a notification. Anybody who loads this game who was a participant in it. So this is really the last possible thing. And I have one more opportunity to set a message. This is an end game message.

So game is over. What you've seen in our demo case is press here to see the match outcome as an example. And I call end match in turn. There is no end match out of turn. You have to be your turn. With a completion handler and the same kind of errors that you would get from any of the other submission type.

[Transcript missing]

Exactly, right? Demos. When you're in Game Center and you're looking at somebody's list and you see a game and you want to play against them and you both have the game installed, you can press play and as you bring up the view controller, it will automatically have selected that person. That's actually kind of neat.

So if you guys are going to do customizations, I didn't show it to you here, but the documentation is quite good on this. There's a few methods that you can use so that you can provide your own UI. You can list matches. You can load individual matches. They will just give you a summary of the match IDs and the participants in them.

You can create your own UI. I think if anybody was watching the Game Essentials, they did a little bit with this app called Word for Word. They're also replaying on Friday. Suggest you go there if you're really interested in writing games. They've done some custom UI for this.

You can determine the state of the matches. So you can look at the state of the match. You can see whether it's matching, whether it's open, whether it's ended. So you can use those kind of parameters. When you're creating your UI, custom UI. The only caveat that we say is if you want to create a new match that includes invites, then you need to use our invite controller. So the GK turn-based matchmaker view controller. If you don't want us to do the list, you can just set that property, show existing matches to no, and just use it for invites. There's also a function.

A method on GK turn-based match that will allow you to do a quick auto match without any UI involved at all. Just give it a match request and we're done. So as a sort of a summary, just to cover what we've talked about before, I showed you all the UI. We showed a demo of it. Hope you're all really excited to go out and use these things. I showed you what events you need to handle, how to create matches, how to make turns, how to quit and end games. It's all really cool.

Most of these sessions, I didn't know about the repeats, but most of these sessions were early in this morning. They're here mostly so when you review this and you're looking for more material, because I think that they're going to release all the slides and videos in a few weeks, you'll know what to refer to. The introduction that was done by Nate Tuesday is being repeated Friday morning.

And also repeated Friday morning is the two game essentials that I think Graham is providing. Those are really cool. Lastly, if you have any questions, then we're not here. You can talk to our evangelist, Alan Shaver. This is his email address. And dev forums. We follow the forums. We respond to the forums. It's a great place to do that. - Thank you.

Be able to talk to us other than here, but really I encourage everybody to come downstairs this afternoon and talk to us directly because that's... That's what we love the most. Thank you for coming. Hope you enjoyed it. I hope you're going to create some awesome games for us.

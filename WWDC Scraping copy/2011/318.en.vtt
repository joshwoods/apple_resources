WEBVTT

00:00:09.750 --> 00:00:10.390
Hello, everyone.

00:00:10.550 --> 00:00:12.540
Welcome to iOS Performance in Depth.

00:00:12.540 --> 00:00:13.860
My name is Dan Crosby.

00:00:13.860 --> 00:00:16.100
I'm an engineer on the
iOS performance team.

00:00:16.100 --> 00:00:19.780
This talk is going to be kind of a grab
bag of different performance topics

00:00:19.930 --> 00:00:23.860
that we found that even more advanced
developers often either are not aware

00:00:23.860 --> 00:00:25.920
of or sometimes have trouble with.

00:00:26.000 --> 00:00:29.490
So I'm going to be talking about
Grand Central Dispatch and performance,

00:00:29.490 --> 00:00:32.310
ways you can use GCD to speed
up the performance of your app,

00:00:32.310 --> 00:00:34.600
and also using memory efficiently on iOS.

00:00:34.600 --> 00:00:36.560
And then I'll be joined by my teammate,
Ben Nham,

00:00:36.560 --> 00:00:39.680
who's going to be talking about view
and animation performance in iOS.

00:00:39.700 --> 00:00:42.530
So let's dive right in.

00:00:42.780 --> 00:00:45.820
So Grand Central Dispatch is a
set of APIs that was introduced

00:00:45.900 --> 00:00:49.880
in Mac OS 10.6 and iOS 4 to help
you use multiple threads in your

00:00:49.880 --> 00:00:51.750
applications more effectively.

00:00:51.760 --> 00:00:54.750
Now, many developers hear multithreading,
and they think, well,

00:00:54.750 --> 00:00:57.490
my application's not CPU-intensive,
or it is CPU-intensive,

00:00:57.490 --> 00:00:59.020
but it's not easy to make concurrent.

00:00:59.020 --> 00:01:00.740
And so they think this
doesn't apply to them.

00:01:00.800 --> 00:01:02.860
But in fact,
GCD can help the performance of

00:01:02.860 --> 00:01:04.860
almost any application on our system.

00:01:04.860 --> 00:01:08.190
It's also relatively simple to code,
and it's cheap at runtime,

00:01:08.250 --> 00:01:09.660
so you should look into it.

00:01:10.560 --> 00:01:12.760
There are a few gotchas,
performance-related gotchas

00:01:12.760 --> 00:01:15.170
associated with GCD that I'm
going to talk about as well.

00:01:15.180 --> 00:01:18.060
But this is not going to be a complete
introduction to Grand Central Dispatch.

00:01:18.120 --> 00:01:18.930
It's a really big topic.

00:01:18.940 --> 00:01:20.670
So I encourage you to
review the video of,

00:01:20.790 --> 00:01:23.960
for instance, yesterday's blocks in
Grand Central Dispatch in practice,

00:01:23.960 --> 00:01:26.200
or look, of course,
at the online documentation.

00:01:28.100 --> 00:01:31.080
So why would you want to consider
using GCD in your application?

00:01:31.200 --> 00:01:35.050
Well, the most important reason is to
keep work off of the main thread.

00:01:35.220 --> 00:01:38.490
The main thread in both iOS
and Mac OS X is where most of

00:01:38.560 --> 00:01:40.100
the user interaction happens.

00:01:40.230 --> 00:01:43.110
So, anytime you're drawing to
the screen or committing an

00:01:43.190 --> 00:01:45.960
animation to the render server,
or responding to touch

00:01:45.960 --> 00:01:47.980
events from the user,
this all has to happen

00:01:47.980 --> 00:01:48.900
on the main thread.

00:01:49.090 --> 00:01:52.440
So, if that's blocked with other work,
your animations won't be smooth,

00:01:52.460 --> 00:01:55.700
and your application won't
feel responsive to the user.

00:01:55.760 --> 00:01:57.610
And it's particularly important
if you've got anything that

00:01:57.610 --> 00:01:59.960
might block for a long time,
because there's a system

00:02:00.150 --> 00:02:02.300
on iOS called Watchdog,
which will actually terminate

00:02:02.300 --> 00:02:05.050
your application if it remains
unresponsive for too long.

00:02:05.230 --> 00:02:06.860
So, you definitely want to avoid that.

00:02:07.070 --> 00:02:10.670
When I say work off the main thread,
I don't just mean intensive CPU work.

00:02:10.750 --> 00:02:13.650
Anything that takes a long time,
like a potentially expensive

00:02:13.650 --> 00:02:17.020
file system or network operation,
can also block the main thread and

00:02:17.130 --> 00:02:19.330
cause the same performance problems.

00:02:19.570 --> 00:02:22.460
So, number one is avoiding --
avoid blocking the main thread.

00:02:22.500 --> 00:02:25.090
You can also use GCD in some
interesting ways to speed up

00:02:25.190 --> 00:02:25.660
the launch of your application.

00:02:25.660 --> 00:02:25.700
So, number one is avoiding --
avoid blocking the main thread.

00:02:25.700 --> 00:02:26.020
You can also use GCD in some
interesting ways to speed up

00:02:26.020 --> 00:02:26.900
the launch of your application.

00:02:26.950 --> 00:02:28.210
And of course,
if your application happens

00:02:28.320 --> 00:02:32.100
to be running on an iPad 2,
you'll automatically take advantage

00:02:32.100 --> 00:02:34.040
of the second CPU core there.

00:02:35.230 --> 00:02:39.120
So let's look at a somewhat contrived,
but I think typical example.

00:02:39.270 --> 00:02:43.360
We have an application that maybe the
user is flipping pages and new pages

00:02:43.360 --> 00:02:45.860
of text are appearing on the screen.

00:02:45.960 --> 00:02:49.100
And we want to go ahead and once
the user gets to this next page,

00:02:49.280 --> 00:02:52.310
prefetch the next page in
case they turn the page again.

00:02:52.440 --> 00:02:54.780
So we might do it like this,
the simple way.

00:02:54.780 --> 00:02:58.030
We use string with contents of file,
check to make sure that we

00:02:58.030 --> 00:03:01.530
actually didn't get an error,
and then take a text field and set its

00:03:01.550 --> 00:03:03.820
text to the contents of that string.

00:03:03.820 --> 00:03:08.120
Now, what's going to happen if
we do it this way is that

00:03:09.020 --> 00:03:12.300
is if the animation of the
page flip is still going,

00:03:12.320 --> 00:03:16.640
we need to actually complete layout and
drawing of each frame of the animation

00:03:16.640 --> 00:03:18.090
in a very short amount of time.

00:03:18.250 --> 00:03:21.060
In order to have smooth 60
frames per second animation,

00:03:21.110 --> 00:03:25.060
you only have about 16 milliseconds
to get all that work done.

00:03:25.170 --> 00:03:28.010
So if we do the layout
and draw of one frame,

00:03:28.010 --> 00:03:30.400
and then we kick off reading
the string in the background,

00:03:30.540 --> 00:03:33.270
which might be a huge string we
have to read off the file system.

00:03:33.590 --> 00:03:36.030
There might be other file system
I/O going on at the same time.

00:03:36.030 --> 00:03:39.500
The frame might be sinking or some other
operations happening in the background.

00:03:39.690 --> 00:03:41.130
This might block for a long time.

00:03:41.130 --> 00:03:43.790
By the time we get the layout
and draw for the next frame,

00:03:43.790 --> 00:03:47.560
we don't have time to finish it,
and we end up dropping the frame.

00:03:47.560 --> 00:03:51.230
So what we would like to do is get that
read string off of the main thread and

00:03:51.240 --> 00:03:53.240
send it down to a background thread.

00:03:53.550 --> 00:03:57.160
That allows the layout and draw
to happen on the main thread and

00:03:57.160 --> 00:03:59.960
complete that second frame in time.

00:03:59.960 --> 00:04:03.230
Now,
the catch to doing this using multiple

00:04:03.370 --> 00:04:05.410
threads is that you can't just do
anything you want in a background.

00:04:05.410 --> 00:04:06.160
You can't just do anything
you want in a background.

00:04:06.160 --> 00:04:06.160
You can't just do anything
you want in a background.

00:04:06.160 --> 00:04:06.160
You can't just do anything
you want in a background.

00:04:06.160 --> 00:04:06.160
You can't just do anything
you want in a background.

00:04:06.160 --> 00:04:06.160
You can't just do anything
you want in a background.

00:04:06.160 --> 00:04:08.160
on the background thread on iOS.

00:04:08.160 --> 00:04:11.160
Typically all UI kit work has
to be done on the main thread.

00:04:11.160 --> 00:04:13.050
Other frameworks don't work that way.

00:04:13.050 --> 00:04:15.170
You can use core animation,
core graphics,

00:04:15.170 --> 00:04:17.120
foundation on the background thread.

00:04:17.210 --> 00:04:21.810
But with the exception of making your own
UI graphics context and drawing into it,

00:04:21.810 --> 00:04:25.080
all other UI kit work has to
be done on the main thread.

00:04:25.150 --> 00:04:27.970
So I can't just take
that entire code snippet,

00:04:27.980 --> 00:04:31.250
send it into the background,
and then do that set text

00:04:31.250 --> 00:04:33.010
in the background thread.

00:04:33.010 --> 00:04:35.530
This is not a safe operation in iOS.

00:04:38.060 --> 00:04:40.820
So what I'm going to do is I'm going
to take that original code snippet,

00:04:40.850 --> 00:04:44.410
and I'm going to get this
expensive string with contents

00:04:44.410 --> 00:04:47.960
of file into the background,
but still keep the UI kit work on the

00:04:47.960 --> 00:04:50.270
main thread with only two lines of code.

00:04:50.320 --> 00:04:55.300
So this first line, dispatch async,
sends the work to a global queue.

00:04:55.300 --> 00:04:58.420
This is a concurrent queue that
can actually execute multiple

00:04:58.420 --> 00:05:01.620
blocks simultaneously that
does not block the main thread.

00:05:02.190 --> 00:05:04.670
So I do my string with
contents of file there.

00:05:04.760 --> 00:05:09.560
Then once I have the string back,
I dispatch async back to the main queue.

00:05:09.560 --> 00:05:13.680
So just that last line of text
will operate on the main queue,

00:05:13.680 --> 00:05:16.200
and I do the set text there.

00:05:16.400 --> 00:05:18.760
So this is the way I can do the
expensive work in the background

00:05:19.310 --> 00:05:23.180
without blocking the main thread,
keep my animation smooth.

00:05:24.000 --> 00:05:28.060
You can also use GCD in some
interesting ways to speed up launch.

00:05:28.240 --> 00:05:30.790
Suppose we have a typical scenario
where you've got some work that you

00:05:30.830 --> 00:05:32.170
need to kick off at launch time.

00:05:32.190 --> 00:05:34.820
Maybe it's going to go off and fetch
some resource from the network or read in

00:05:34.950 --> 00:05:37.880
some image files that I'm going to blip
to the screen as soon as they're ready.

00:05:37.880 --> 00:05:41.050
So I kick this off at launch time,
maybe an init on an object

00:05:41.050 --> 00:05:44.020
that's read in from a nib,
but it doesn't actually have

00:05:44.020 --> 00:05:45.940
to be completed at launch time.

00:05:46.820 --> 00:05:48.630
In this case,
we have launch time work with some

00:05:48.780 --> 00:05:51.800
deferrable work in the middle,
but it's not until all of that is done

00:05:51.840 --> 00:05:53.930
that the main run loop can start turning.

00:05:53.940 --> 00:05:57.000
No animations are going to happen,
no touch events are going to be received

00:05:57.130 --> 00:05:59.060
until that main run loop starts turning.

00:05:59.060 --> 00:06:03.130
So we would like to take that
deferrable work and have it not block

00:06:03.210 --> 00:06:05.670
the rest of this launch time work.

00:06:05.750 --> 00:06:09.040
Now, if I try to do the same thing
I just did a moment ago,

00:06:09.040 --> 00:06:12.320
dispatch this deferrable
work to a background queue,

00:06:12.550 --> 00:06:13.490
this might help.

00:06:13.490 --> 00:06:16.410
But if this really is expensive work...

00:06:17.700 --> 00:06:18.880
We can hit CPU contention.

00:06:18.950 --> 00:06:21.840
I now have two threads that are
both trying to do CPU intensive

00:06:21.840 --> 00:06:23.230
work at the same time.

00:06:23.330 --> 00:06:25.600
So while this is likely to
speed up my launch a little bit,

00:06:25.650 --> 00:06:29.430
it's not going to get nearly as much
of the benefit as we had expected.

00:06:29.820 --> 00:06:31.440
So, back to the drawing board.

00:06:31.490 --> 00:06:34.590
What we really want to do is
not do the deferrable work

00:06:34.770 --> 00:06:36.200
concurrently with the launch time.

00:06:36.200 --> 00:06:38.230
We want to do it after
the launch time work.

00:06:38.290 --> 00:06:42.540
So, and this is very counterintuitive,
but from the main thread

00:06:42.540 --> 00:06:47.260
that's already operating,
I'm going to dispatch to the main queue.

00:06:47.920 --> 00:06:50.250
Now,
this takes advantage of the fact that

00:06:50.250 --> 00:06:53.920
the main queue in GCD is actually
drained inside the main run loop.

00:06:53.920 --> 00:06:57.270
So, the deferrable work won't
actually happen until the main

00:06:57.300 --> 00:06:59.210
run loop has started turning.

00:06:59.220 --> 00:07:02.100
So, I dispatch from the main
thread to the main thread.

00:07:02.100 --> 00:07:03.370
It just defers the work.

00:07:03.440 --> 00:07:05.750
Now,
I'm back to the same problem that I had

00:07:05.870 --> 00:07:09.600
before where I'm trying to do this
deferrable work in the main run loop

00:07:09.600 --> 00:07:11.760
and my animations might not be smooth.

00:07:11.860 --> 00:07:14.410
So,
after I've dispatched to the main queue,

00:07:14.410 --> 00:07:16.930
I dispatch again to a background queue.

00:07:16.980 --> 00:07:17.880
So, I just use dispatch.

00:07:17.980 --> 00:07:21.550
I dispatch twice and now my deferrable
work is neither blocking the launch

00:07:21.630 --> 00:07:23.530
time nor blocking the main run loop.

00:07:26.060 --> 00:07:29.730
Now, there's a few performance-related
gotchas any time you use GCD that

00:07:29.770 --> 00:07:30.750
you need to watch out for.

00:07:30.760 --> 00:07:36.130
One of the common ones is having too
many threads servicing too... I'm sorry,

00:07:36.320 --> 00:07:39.160
you have too many threads
blocked on too few resources.

00:07:39.160 --> 00:07:42.970
So GCD, when you use a concurrent queue,
one of those global queues

00:07:42.970 --> 00:07:45.450
that I was using before,
usually just sort of magically

00:07:45.450 --> 00:07:48.240
makes the right number of
threads for the situation.

00:07:48.240 --> 00:07:50.840
So, for instance,
if you're running on an iPad 2,

00:07:51.300 --> 00:07:54.190
we'll make more threads to service
that concurrent queue than if we

00:07:54.190 --> 00:07:56.840
were running on an iPhone 3GS,
for example.

00:07:56.840 --> 00:07:59.460
So usually we'll just make
the right number of threads.

00:07:59.540 --> 00:08:03.490
But suppose I had that example before,
where I'm dispatching a block off

00:08:03.490 --> 00:08:06.070
to the background that's going
to go to the file system and read

00:08:06.070 --> 00:08:07.360
in some large amount of text.

00:08:07.420 --> 00:08:09.420
And maybe I want to
just go ahead... Well,

00:08:09.420 --> 00:08:10.580
it's happening in the background anyway.

00:08:10.580 --> 00:08:12.880
I'll just go ahead and
prefetch the next 10 pages.

00:08:12.920 --> 00:08:16.480
What will happen as soon as
that block hits the file system,

00:08:16.480 --> 00:08:19.330
as soon as I get to the file read,
the thread's going to block

00:08:19.420 --> 00:08:22.450
when it hits the file system,
and so GCD is going to spawn

00:08:22.650 --> 00:08:25.610
another thread to service the next
block in the queue because it's

00:08:25.610 --> 00:08:27.150
trying to keep the CPU cores busy.

00:08:27.160 --> 00:08:30.070
And pretty soon,
if I've dispatched 10 or 20 of those,

00:08:30.100 --> 00:08:31.980
I'm going to have all of
those threads running,

00:08:31.980 --> 00:08:34.180
and that's actually going to hurt
the performance of your application

00:08:34.180 --> 00:08:36.710
because you don't want too many
threads for the system to handle.

00:08:36.720 --> 00:08:40.660
So the way to avoid this,
if the shared resource that you're

00:08:40.760 --> 00:08:45.250
blocking on is a network operation,
you can use the NSURL connection

00:08:45.250 --> 00:08:47.900
asynchronous methods,
and this will all just happen for you.

00:08:47.920 --> 00:08:50.020
You'll get callbacks
when the work is done.

00:08:50.060 --> 00:08:52.840
If it's not, if it's not a network,
if it's some other file

00:08:52.930 --> 00:08:56.010
system operation or syscall,
you can use a serial queue to

00:08:56.010 --> 00:09:00.200
serialize those operations so that
they don't try to happen concurrently,

00:09:00.200 --> 00:09:03.220
and GCD does not spawn
new threads for you.

00:09:04.670 --> 00:09:08.100
Now, you want to serialize the
minimum possible amount of work.

00:09:08.220 --> 00:09:10.170
So this code snippet
would look like this.

00:09:10.270 --> 00:09:13.580
You'd have some global serial queue
that you've created just using one

00:09:13.580 --> 00:09:16.060
of the dispatch create functions.

00:09:16.060 --> 00:09:19.060
You dispatch a sync to
a global file IO queue.

00:09:19.170 --> 00:09:22.120
You do your read of the data
in from the file system there.

00:09:22.580 --> 00:09:25.250
After you've finished that work
that needs to be serialized,

00:09:25.370 --> 00:09:27.550
you dispatch back out to
some concurrent queue.

00:09:27.550 --> 00:09:29.730
And then if, say,
you're reading a bunch of files

00:09:29.730 --> 00:09:32.600
and doing some operation on them,
you can do that work concurrently,

00:09:32.600 --> 00:09:37.290
but you still have the
file system IO serialized.

00:09:37.460 --> 00:09:40.100
Now, if you're targeting iOS 5 only,
there's actually a better

00:09:40.210 --> 00:09:42.130
solution to this in iOS 5,
and that's to look into

00:09:42.130 --> 00:09:44.080
the dispatch IO functions.

00:09:44.080 --> 00:09:46.930
But this example that I have here
will work back in iOS 4 as well.

00:09:49.250 --> 00:09:53.290
Now, the next couple of GCD gotchas
I want to talk about have to

00:09:53.290 --> 00:09:55.930
do with memory use in GCD.

00:09:56.020 --> 00:09:58.980
And this first one, retain cycles,
is a particularly subtle problem

00:09:58.980 --> 00:10:02.090
that can be very difficult to
figure out what's going on.

00:10:02.390 --> 00:10:05.040
So using blocks,
especially if they reference objects,

00:10:05.140 --> 00:10:06.340
can cause retain cycles.

00:10:06.520 --> 00:10:09.920
So in this example,
we have an object that holds

00:10:09.920 --> 00:10:11.370
on to a copy of a block.

00:10:11.680 --> 00:10:13.800
Maybe it's planning to
dispatch this block repeatedly,

00:10:13.880 --> 00:10:15.930
so it just wants to copy
it to the heap one time.

00:10:15.960 --> 00:10:18.830
Or maybe it's going to be sending it
off to a timer or something like that.

00:10:19.240 --> 00:10:22.380
So when it's an init function,
it creates the block, and in this case,

00:10:22.380 --> 00:10:24.910
the block's going to do
something simple and contrived,

00:10:24.910 --> 00:10:27.450
just set my var to six,
and then copy it to the heap.

00:10:27.530 --> 00:10:30.270
If you don't copy it to the heap,
the block will go away

00:10:30.270 --> 00:10:31.510
after init returns.

00:10:31.560 --> 00:10:35.270
Well, in this case,
we actually have a retain cycle created,

00:10:35.270 --> 00:10:39.260
because my block owns a copy, I'm sorry,
the object owns a copy of my

00:10:39.260 --> 00:10:41.020
block because of the copy.

00:10:41.020 --> 00:10:45.390
But my block is referencing my var,
which is a member variable,

00:10:45.390 --> 00:10:48.900
so it is actually referencing
the object itself.

00:10:49.240 --> 00:10:53.260
So it is implicitly has to retain
self when it gets copied to the heap.

00:10:53.340 --> 00:10:55.260
So we have a classic retain cycle.

00:10:55.260 --> 00:10:59.470
The object owns a copy of the block,
and the block owns a copy of the object.

00:10:59.520 --> 00:11:01.490
This example probably
seems very contrived,

00:11:01.560 --> 00:11:03.600
but it's very common to
happen if you're using,

00:11:03.680 --> 00:11:05.610
for instance,
the NS timer or NS notification

00:11:05.700 --> 00:11:09.280
center functions that take blocks,
and you reference self from in there.

00:11:09.300 --> 00:11:12.420
So what we need to do is
cut the reference of the

00:11:12.420 --> 00:11:14.330
block back to the object.

00:11:14.440 --> 00:11:16.190
And there's a couple of ways to do this.

00:11:16.260 --> 00:11:18.440
If you're using the new
automatic reference counting,

00:11:18.440 --> 00:11:19.200
you can use a block to do this.

00:11:19.240 --> 00:11:23.110
So I'm going to use an underscore
underscore weak variable to replace self.

00:11:23.260 --> 00:11:25.670
If you're using iOS 4,
you can use an underscore

00:11:25.670 --> 00:11:27.420
underscore block reference.

00:11:27.420 --> 00:11:31.530
So in this case, I make an underscore
underscore block id weak self,

00:11:31.530 --> 00:11:34.720
which is simply a
non-retaining version of self.

00:11:34.720 --> 00:11:38.860
Then in my block, when I reference the
property of weak self,

00:11:38.860 --> 00:11:42.670
I'm not going to retain it
because it's a block variable,

00:11:42.670 --> 00:11:45.530
and I've cut the link back to the object.

00:11:46.920 --> 00:11:50.600
Another memory-related gotcha with
GCD has to do with auto-release pools.

00:11:50.600 --> 00:11:54.440
You need to take a lot of care
when you're dispatching away,

00:11:54.440 --> 00:11:57.000
especially a loop that's going
to use an auto-released object,

00:11:57.030 --> 00:11:59.940
because blocks don't have
implicit auto-release pools.

00:11:59.990 --> 00:12:03.820
GCD queues do have auto-release pools,
so there's no danger of your

00:12:03.820 --> 00:12:05.080
objects actually being leaked.

00:12:05.180 --> 00:12:08.300
But they don't necessarily
drain after every block.

00:12:08.360 --> 00:12:10.480
So if you're dispatching
away a bunch of blocks,

00:12:10.570 --> 00:12:14.100
and each of those blocks runs
some loop in which it uses a

00:12:14.100 --> 00:12:16.960
lot of auto-released objects,
there's not really any way for you

00:12:17.200 --> 00:12:20.440
at compile time to know when that
auto-release pool is going to be drained.

00:12:22.890 --> 00:12:25.560
So this advice for dealing with this is
pretty much the same advice you would

00:12:25.560 --> 00:12:29.840
have for using auto-released objects
anywhere in Cocoa or Cocoa Touch.

00:12:29.840 --> 00:12:33.820
You can make your own auto-release
pools inside the block to make sure that

00:12:33.820 --> 00:12:35.000
it gets drained when you want it to.

00:12:35.000 --> 00:12:37.700
And if you do that,
I strongly encourage you to use the

00:12:37.700 --> 00:12:42.020
new at-auto-release syntax instead of
the old NS auto-release pool syntax.

00:12:42.020 --> 00:12:42.930
It's a lot faster.

00:12:42.940 --> 00:12:46.600
And of course,
don't loop with auto-released objects.

00:12:46.730 --> 00:12:49.420
You have the possibility of having
this explosion of auto-released

00:12:49.420 --> 00:12:51.090
objects that stick around too long.

00:12:51.870 --> 00:12:55.840
One way to get rid of your
auto-released object loop is to

00:12:56.040 --> 00:12:59.220
use the dispatch apply function,
which actually takes the loop and

00:12:59.220 --> 00:13:02.530
unrolls it into a series of blocks,
each dispatched separately to a

00:13:02.530 --> 00:13:04.460
serial queue or concurrent queue.

00:13:04.460 --> 00:13:06.750
This doesn't get rid of
the problem entirely,

00:13:06.890 --> 00:13:10.640
but at least increases the chance that
the auto-release pool will be drained

00:13:10.640 --> 00:13:14.350
often enough that you won't have an
explosion of auto-released objects.

00:13:16.300 --> 00:13:19.240
So with that, I'm going to move on to
my second major topic,

00:13:19.240 --> 00:13:21.440
which is using memory efficiently in iOS.

00:13:21.440 --> 00:13:26.050
Now, as we all know, in iOS 4,
the memory system in the whole

00:13:26.310 --> 00:13:29.050
platform changed dramatically
when we got multitasking.

00:13:29.060 --> 00:13:31.220
So it used to be that
when your app was running,

00:13:31.220 --> 00:13:33.400
you were pretty much
the only game in town.

00:13:33.400 --> 00:13:37.020
It might be that mail or music or
something like that was playing.

00:13:37.020 --> 00:13:39.900
But for the most part,
you had access to most of the memory

00:13:39.900 --> 00:13:41.780
that was available to user space.

00:13:42.420 --> 00:13:44.660
In iOS 4,
that changed because we started keeping

00:13:44.660 --> 00:13:48.160
suspended apps around in order that the
user could resume them very quickly.

00:13:48.160 --> 00:13:51.800
We've got a better
story for this in iOS 5,

00:13:51.800 --> 00:13:54.220
and we think we've clearly
identified what our goals are

00:13:54.220 --> 00:13:55.710
in using memory in the system.

00:13:55.720 --> 00:13:59.930
So there are three primary goals that
we're trying to achieve in this order.

00:13:59.980 --> 00:14:02.570
First of all,
we need to protect the system.

00:14:02.730 --> 00:14:06.790
You always need to remember that you're
not running your program on a console

00:14:06.790 --> 00:14:08.940
where you are the only game in town.

00:14:08.940 --> 00:14:12.070
Your phone is, among other things,
a phone.

00:14:12.250 --> 00:14:14.440
It needs to still have enough
memory to receive phone calls.

00:14:14.550 --> 00:14:16.440
The kernel needs enough
memory that it doesn't panic,

00:14:16.520 --> 00:14:17.290
things like that.

00:14:17.420 --> 00:14:21.020
So our primary objective is to give the
system enough memory to protect itself.

00:14:21.180 --> 00:14:24.890
The second goal, and this really is the
next most important thing,

00:14:24.930 --> 00:14:27.430
is to always give the
foreground application enough

00:14:27.550 --> 00:14:28.950
memory for great performance.

00:14:28.960 --> 00:14:31.780
We want to make sure that
multitasking never interferes with

00:14:31.780 --> 00:14:33.750
the performance of the foreground app.

00:14:33.820 --> 00:14:37.180
And the third goal, still very important,
is to keep around as many

00:14:37.260 --> 00:14:38.830
suspended apps as possible.

00:14:38.880 --> 00:14:42.020
It's really a great user experience when
the user can just double-tap the app.

00:14:42.070 --> 00:14:44.010
Switch over to another app
and it's instantly there.

00:14:44.020 --> 00:14:46.010
It doesn't have to relaunch.

00:14:46.030 --> 00:14:48.530
So we want to keep as many of
those around as we can without

00:14:48.530 --> 00:14:52.010
sacrificing the system or the
performance of the foreground app.

00:14:52.020 --> 00:14:55.970
So how can we work together to make
sure that we have this great experience

00:14:55.970 --> 00:14:57.980
keeping these three goals in mind?

00:14:58.020 --> 00:15:00.020
Basically,
you want your app to be a good citizen

00:15:00.020 --> 00:15:03.010
both when it's in the foreground,
running as the foreground app,

00:15:03.020 --> 00:15:04.870
and when it's in the background.

00:15:05.020 --> 00:15:07.040
So first of all,
being a good citizen in the

00:15:07.150 --> 00:15:11.020
foreground means don't use more
memory than you really need to.

00:15:11.890 --> 00:15:14.130
So if you use too much memory,
the first thing that will happen is

00:15:14.130 --> 00:15:15.800
that suspended apps will be terminated.

00:15:15.950 --> 00:15:18.210
Now that's okay if you really
need -- if your application

00:15:18.210 --> 00:15:18.770
really needs that memory.

00:15:18.900 --> 00:15:20.710
We'd like to keep as many
of them around as we can.

00:15:20.820 --> 00:15:23.980
The second thing that can happen
is that purgeable memory in the

00:15:24.060 --> 00:15:26.810
system will actually be evicted,
and that includes code pages.

00:15:26.820 --> 00:15:30.720
So if your application is using
more memory than it really needs to,

00:15:30.910 --> 00:15:32.820
this can lead to your code
pages being evicted from memory.

00:15:32.820 --> 00:15:35.390
And then the next time you get
back to running that code again,

00:15:35.390 --> 00:15:36.780
it has to be reloaded from disk.

00:15:36.820 --> 00:15:38.820
This will actually hurt the
performance of your app.

00:15:38.820 --> 00:15:41.620
And finally, if you use too much,
the Jetson app will actually

00:15:41.620 --> 00:15:41.620
be evicted from memory.

00:15:41.620 --> 00:15:44.750
The Jetson system will actually
terminate your application even

00:15:44.750 --> 00:15:46.720
when it's running in the foreground.

00:15:47.130 --> 00:15:49.640
So the main way to avoid this happening,
if you're getting into

00:15:49.640 --> 00:15:52.740
really critical situations,
is to watch for memory warnings.

00:15:52.820 --> 00:15:54.790
Oh, I forgot my neat graphic here.

00:15:54.900 --> 00:15:58.070
Your app will push the other
apps out of the system and then

00:15:58.110 --> 00:16:00.310
eventually be terminated itself.

00:16:00.670 --> 00:16:02.940
So we've done a lot of work
to make memory warnings in

00:16:02.940 --> 00:16:05.390
iOS more effective in iOS 5.

00:16:05.650 --> 00:16:09.720
So many developers felt that in iOS 4,
they got memory warnings at times

00:16:09.720 --> 00:16:10.910
they didn't really understand.

00:16:10.920 --> 00:16:13.160
They seemed sort of spurious,
and if they ignored them,

00:16:13.160 --> 00:16:15.460
there weren't always
necessarily bad consequences.

00:16:15.770 --> 00:16:19.810
So we've modified the under-the-hood
system for memory warnings in iOS 5

00:16:19.810 --> 00:16:23.930
so that you should receive a lot fewer
memory warnings than you used to.

00:16:23.930 --> 00:16:26.390
But when you do receive
memory warnings in iOS 5,

00:16:26.520 --> 00:16:28.500
it really does mean they are critical.

00:16:28.500 --> 00:16:32.400
At the time you receive a memory warning,
the system has already terminated

00:16:32.400 --> 00:16:35.000
a lot of the suspended apps
that are in the system.

00:16:35.010 --> 00:16:38.550
So the system has already done a lot
of work for you to get the foreground

00:16:38.650 --> 00:16:41.390
app all the memory that it needs,
but now the situation

00:16:41.390 --> 00:16:43.680
is still looking bad,
and it's your turn to free

00:16:43.680 --> 00:16:45.670
up any memory that you can.

00:16:45.760 --> 00:16:45.880
Amen.

00:16:47.760 --> 00:16:49.900
Now, the API for memory
warnings has not changed.

00:16:49.900 --> 00:16:52.700
All the work has been--all the
changes have been under the hood.

00:16:52.710 --> 00:16:55.820
So the way you respond to a memory
warning is by implementing the

00:16:55.820 --> 00:16:59.300
application didReceiveMemoryWarning
method in your app delegate,

00:16:59.400 --> 00:17:03.210
by overriding the didReceiveMemoryWarning
in your UIViewController subclass,

00:17:03.300 --> 00:17:07.100
or subscribing to the UI application
didReceiveMemoryWarning notification.

00:17:07.240 --> 00:17:13.300
So exactly the same API will work in iOS
4 or iOS 5 to respond to memory warnings.

00:17:13.470 --> 00:17:16.170
So what should you do when you get one?

00:17:16.470 --> 00:17:20.010
Let's start with what you should not
do when you receive a memory warning.

00:17:20.130 --> 00:17:24.590
You should not ask the user to
fix the memory warning for you.

00:17:24.950 --> 00:17:27.360
They can't, okay?

00:17:27.360 --> 00:17:30.980
If you receive a memory warning,
remember, we have already terminated

00:17:31.090 --> 00:17:33.800
most of the suspended apps,
and we will continue, if necessary,

00:17:33.800 --> 00:17:36.200
to terminate the rest
of the suspended apps.

00:17:36.200 --> 00:17:38.300
If you're asking the user
to quit applications,

00:17:38.450 --> 00:17:40.840
they don't even know which apps
are actually suspended because

00:17:40.840 --> 00:17:44.150
the app switcher is showing a
most recently used list of apps,

00:17:44.260 --> 00:17:45.800
not a list of running apps.

00:17:45.930 --> 00:17:49.030
So please, please,
please do not ask the user to respond

00:17:49.030 --> 00:17:50.950
to the memory warning for you.

00:17:51.070 --> 00:17:52.700
This is your job.

00:17:53.350 --> 00:17:56.080
Next, do not try to figure out
if the warning is critical.

00:17:56.270 --> 00:18:00.070
I understand why many developers do this,
because memory warnings in

00:18:00.070 --> 00:18:01.280
the past seem to be spurious.

00:18:01.280 --> 00:18:03.850
Now,
if we're sending you a memory warning,

00:18:03.850 --> 00:18:04.940
it is critical.

00:18:04.940 --> 00:18:06.400
You need to respond to it.

00:18:06.440 --> 00:18:10.420
And linked to that, don't wait to receive
a more serious warning.

00:18:10.420 --> 00:18:11.650
There won't be one.

00:18:11.710 --> 00:18:15.370
If you don't free enough memory when
you get your first memory warning,

00:18:15.370 --> 00:18:16.820
that's your last chance.

00:18:16.930 --> 00:18:19.210
You're not going to receive another one,
and the next step is that

00:18:19.330 --> 00:18:20.610
your Apple will be terminated.

00:18:20.650 --> 00:18:22.990
So you need to do anything
you can at that first warning.

00:18:24.820 --> 00:18:27.790
So what you should do is, of course,
free up any memory that

00:18:27.800 --> 00:18:29.040
you reasonably can.

00:18:29.160 --> 00:18:31.340
That means any regenerable
caches that you have,

00:18:31.400 --> 00:18:34.620
any views or images that are not in use,
release them.

00:18:34.700 --> 00:18:38.260
Now, I mean it when I say any
memory you reasonably can,

00:18:38.260 --> 00:18:41.810
because as I said before,
it's more important to us that

00:18:41.810 --> 00:18:45.790
your app have enough memory
for reasonable performance.

00:18:45.800 --> 00:18:47.850
So don't free up something
you're going to have to

00:18:47.970 --> 00:18:51.000
immediately read back off disk,
you're going to have to regenerate,

00:18:51.000 --> 00:18:54.240
you know, don't just panic and evict
everything you possibly can.

00:18:54.560 --> 00:18:56.560
But anything that you're not
going to need immediately,

00:18:56.560 --> 00:18:58.500
go ahead and free it up,
give it back to the system,

00:18:58.500 --> 00:19:00.780
and then we will keep doing
our part to help you even more.

00:19:00.780 --> 00:19:02.820
Now,
if you need to serialize out any state,

00:19:02.820 --> 00:19:05.040
if, for instance,
there's some state that would

00:19:05.120 --> 00:19:07.940
be lost if you free everything,
you want to save it out to disk,

00:19:07.950 --> 00:19:09.730
go ahead and do that, but be quick.

00:19:09.820 --> 00:19:12.540
At the time you receive a memory warning,
again, it's critical.

00:19:12.540 --> 00:19:15.500
If you have another thread that's
continuing to allocate memory,

00:19:15.500 --> 00:19:18.160
you may actually get terminated
before you have time.

00:19:18.180 --> 00:19:21.060
So be as quick as you can in
responding to these memory warnings.

00:19:23.390 --> 00:19:25.300
So that's being a good
citizen in the foreground.

00:19:25.360 --> 00:19:28.660
Being a good citizen in the background,
you don't have the option of

00:19:28.660 --> 00:19:30.800
responding to memory warnings
because when you're suspended,

00:19:30.800 --> 00:19:31.750
you're never going to get them.

00:19:31.750 --> 00:19:34.380
Suspended apps don't
receive memory warnings,

00:19:34.470 --> 00:19:36.970
so you need to free anything you
can when you get that application

00:19:36.970 --> 00:19:38.670
did into background method called.

00:19:38.710 --> 00:19:40.780
And you would respond to it
pretty much the same way you

00:19:40.890 --> 00:19:42.420
would respond to a memory warning.

00:19:42.550 --> 00:19:46.710
Anything that you can regenerate
later when your application resumes,

00:19:46.710 --> 00:19:48.340
go ahead and free it now.

00:19:48.340 --> 00:19:52.480
Now, the catch to this is that you also
want to return from application did

00:19:52.580 --> 00:19:54.530
into background as quickly as possible.

00:19:54.540 --> 00:19:56.630
There's a number of things
that the system does to

00:19:56.770 --> 00:19:59.470
your app after it completes
application did into background.

00:19:59.470 --> 00:20:02.070
One example is that the little
snapshot that you see of

00:20:02.210 --> 00:20:04.940
your app when you resume it,
we can't take that snapshot

00:20:05.020 --> 00:20:08.120
by API contract until after
you've returned from application

00:20:08.120 --> 00:20:09.610
did into your background.

00:20:09.620 --> 00:20:13.280
So if you need to do any expensive work,
for instance, to serialize things out

00:20:13.390 --> 00:20:16.770
to disk and then free it,
you want to do that in a background task.

00:20:17.580 --> 00:20:19.310
And this is actually pretty simple to do.

00:20:19.510 --> 00:20:23.320
You call application begin background
task with expiration handler.

00:20:23.320 --> 00:20:26.340
And this code snippet, by the way,
is the thread safe way

00:20:26.400 --> 00:20:27.510
to do a background task.

00:20:27.560 --> 00:20:31.340
In your expiration handler,
this is what's going to fire when,

00:20:31.340 --> 00:20:34.280
if your time runs out,
if you've used too much time

00:20:34.280 --> 00:20:37.950
trying to run your background task,
you simply set a flag in your

00:20:37.970 --> 00:20:40.190
expiration handler saying time is up.

00:20:40.280 --> 00:20:44.320
And then you dispatch the actual
work away to a background queue.

00:20:44.320 --> 00:20:47.770
You do the work in some kind of loop
where you're periodically checking to

00:20:47.780 --> 00:20:49.260
see if you've been canceled or not.

00:20:49.260 --> 00:20:52.060
And then at the time,
either when you've completed all the

00:20:52.060 --> 00:20:55.580
work that you wanted to do or when
you receive that expiration handler,

00:20:55.580 --> 00:20:58.360
then you go ahead and end the
background task and then the

00:20:58.400 --> 00:20:59.490
system will suspend your app.

00:21:01.310 --> 00:21:03.500
So why is it so important to
free up memory when you're

00:21:03.500 --> 00:21:04.700
going into the background?

00:21:04.810 --> 00:21:07.340
The reason for that is that the
lower your memory footprint,

00:21:07.410 --> 00:21:10.250
the more likely you are to stay
suspended and give the user that

00:21:10.280 --> 00:21:13.650
nice resume experience instead of
having to relaunch from scratch.

00:21:13.870 --> 00:21:17.480
The critical threshold
here is 16 megabytes.

00:21:17.600 --> 00:21:20.960
If your application can get
down to 16 megabytes or less,

00:21:21.050 --> 00:21:23.080
we can actually hibernate
your application,

00:21:23.160 --> 00:21:27.060
which means we save the
contents of its memory to flash,

00:21:27.150 --> 00:21:29.260
and then we can evict it from memory.

00:21:29.350 --> 00:21:31.460
So you're no longer taking up
any memory from the system,

00:21:31.530 --> 00:21:34.140
and we're much less likely
to have to terminate you.

00:21:34.270 --> 00:21:37.730
Now, that doesn't mean that 16 megabytes
is the only thing to watch out for.

00:21:37.910 --> 00:21:41.450
If you can get even further below 16
megabytes once you're already there,

00:21:41.600 --> 00:21:43.150
well,
then you have less that we have to read

00:21:43.150 --> 00:21:44.980
back from flash in order to resume you.

00:21:45.200 --> 00:21:47.080
Your resume times are going to be better.

00:21:47.080 --> 00:21:50.270
If you can't quite get back to
16 megabytes for whatever reason,

00:21:50.400 --> 00:21:53.810
still get as small as you can,
because that'll get less memory

00:21:53.830 --> 00:21:56.480
pressure total on the system and
the less chance that we're going

00:21:56.480 --> 00:21:59.260
to have to terminate someone,
which, of course, could be you.

00:22:01.570 --> 00:22:04.190
Now, there's one exception to this
free everything you can when

00:22:04.190 --> 00:22:05.760
you go into the background.

00:22:05.760 --> 00:22:09.510
And that is that if resuming your
application would become so expensive

00:22:09.620 --> 00:22:13.100
that you might as well relaunch,
well, then there's not much point.

00:22:13.260 --> 00:22:16.040
Remember that the whole point of
resume is to be faster than launch.

00:22:16.040 --> 00:22:19.630
So there's some cases, for instance,
for very expensive 3D games where

00:22:20.000 --> 00:22:23.060
they have so many assets to read
in off of Flash that if they had

00:22:23.060 --> 00:22:25.020
to evict all that from memory,
well,

00:22:25.020 --> 00:22:27.390
then the resume time becomes terrible.

00:22:28.060 --> 00:22:31.670
In those cases, we would recommend, well,
don't even bother freeing all this up.

00:22:31.820 --> 00:22:33.960
Because in those cases,
you can hope the user just

00:22:33.960 --> 00:22:36.760
switched over to send an
iMessage or something like that,

00:22:36.930 --> 00:22:38.440
and it's going to come
right back to your app.

00:22:38.520 --> 00:22:40.860
But don't assume that this
applies to your application.

00:22:40.860 --> 00:22:43.080
You'll find that most
apps can resume much,

00:22:43.080 --> 00:22:46.790
much faster than they can launch,
even after they've freed up all these,

00:22:46.800 --> 00:22:48.600
all this regenerable contents.

00:22:51.190 --> 00:22:54.380
So that's talking about how to
respond to particular events when

00:22:54.380 --> 00:22:56.760
you receive a memory warning or
when you go into the background.

00:22:56.870 --> 00:22:59.720
Let's talk about some strategies
for reducing your application's

00:22:59.720 --> 00:23:01.080
memory footprint in total.

00:23:01.100 --> 00:23:06.100
One issue that many developers
have is with excessive caching.

00:23:06.100 --> 00:23:08.530
You really need to be careful
to only cache contents in

00:23:08.620 --> 00:23:10.100
memory if you really need to.

00:23:10.100 --> 00:23:13.420
Often you might think, well,
I loaded this image in from disk,

00:23:13.490 --> 00:23:16.100
that's a potentially expensive operation.

00:23:16.100 --> 00:23:19.070
I'm going to go ahead and
hold on to that in memory.

00:23:19.180 --> 00:23:22.280
You need to test the performance
of regenerating this stuff before

00:23:22.390 --> 00:23:23.940
you decide to cache it in memory.

00:23:24.100 --> 00:23:27.150
If you're caching something in
memory because you had to go to

00:23:27.160 --> 00:23:30.090
the network to get some asset
and you want to hold on to it,

00:23:30.150 --> 00:23:32.100
consider saving it to
the file system instead.

00:23:32.100 --> 00:23:34.100
Don't cache it in memory.

00:23:34.100 --> 00:23:35.770
And then if you do decide
there's a performance

00:23:35.770 --> 00:23:39.100
advantage to caching something,
use the NSCache API,

00:23:39.100 --> 00:23:41.910
which I'm going to talk
more about in just a moment.

00:23:43.000 --> 00:23:46.590
The worst thing that you can do
as far as your memory footprint

00:23:46.960 --> 00:23:48.640
is to cache images in memory.

00:23:48.660 --> 00:23:53.560
When an image is drawn into a bitmap
context or displayed to the screen,

00:23:53.560 --> 00:23:56.290
we actually have to decode
that image into a bitmap.

00:23:56.360 --> 00:24:01.540
That bitmap is four bytes per pixel,
no matter how big the original image was.

00:24:01.560 --> 00:24:05.240
And as soon as we've decoded it once,
that bitmap is attached to the

00:24:05.390 --> 00:24:08.720
image object and will then persist
for the lifetime of the object.

00:24:09.460 --> 00:24:12.400
So if you're putting images into a
cache and they ever get displayed,

00:24:12.400 --> 00:24:14.950
you're now holding on to that
entire bitmap until you release it.

00:24:15.040 --> 00:24:18.530
So never put UI images or CG images
into a cache unless you have a

00:24:18.540 --> 00:24:22.390
very clear and hopefully very
short-term reason for doing so.

00:24:24.630 --> 00:24:26.800
Now, if you do decide you need to
use a cache for something,

00:24:26.800 --> 00:24:30.470
you should look at the NSCache API,
which is an API that was introduced

00:24:30.470 --> 00:24:32.740
in iOS 5 and in Mac OS 10.6.

00:24:32.740 --> 00:24:36.080
We've done a lot of work in every
iOS release since to make its

00:24:36.080 --> 00:24:38.210
memory performance even better.

00:24:38.220 --> 00:24:41.200
So it works basically like
an NSMutable dictionary.

00:24:41.200 --> 00:24:43.580
It has a very similar API,
a key value API.

00:24:43.580 --> 00:24:47.750
It's thread safe, which is a nice benefit
for ease of coding.

00:24:47.760 --> 00:24:49.670
Because of that,
it's a little bit slower and

00:24:49.670 --> 00:24:51.170
returns auto-released results.

00:24:51.280 --> 00:24:53.450
So all in all,
it seems like it might not be a good

00:24:53.450 --> 00:24:55.240
choice compared to NSDictionary.

00:24:55.240 --> 00:24:59.140
But it gives you some great
characteristics with respect to memory.

00:24:59.140 --> 00:25:01.620
First of all,
the NSCache automatically evicts its

00:25:01.620 --> 00:25:03.720
contents when you get a memory warning.

00:25:03.720 --> 00:25:04.710
You don't have to do it.

00:25:04.870 --> 00:25:05.670
We'll do it for you.

00:25:05.740 --> 00:25:09.970
It can automatically grow and shrink
based on other system memory conditions.

00:25:10.020 --> 00:25:12.960
So things that, as an app developer,
you don't even have access to.

00:25:12.960 --> 00:25:18.500
The NSCache will adjust its total size
based on the system memory conditions.

00:25:18.540 --> 00:25:22.360
And when it goes into the background,
it automatically evicts its contents.

00:25:22.490 --> 00:25:24.520
So again,
this isn't something you have to worry

00:25:24.520 --> 00:25:25.680
about when you go into the background.

00:25:25.680 --> 00:25:29.710
And it uses least recently used eviction,
which can be very difficult

00:25:29.710 --> 00:25:30.580
to code on your own.

00:25:30.650 --> 00:25:31.780
It will automatically do it.

00:25:31.860 --> 00:25:35.360
So we'll keep track of which objects
you've used more recently and won't

00:25:35.360 --> 00:25:37.540
evict those as quickly as the older ones.

00:25:37.560 --> 00:25:40.560
Now, of course,
that means that the contents someday

00:25:40.560 --> 00:25:41.880
will get evicted from memory.

00:25:41.880 --> 00:25:43.120
And so you have to check them.

00:25:43.430 --> 00:25:47.200
When you do the lookup into the NSCache,
you have to check to make sure that

00:25:47.200 --> 00:25:48.910
you actually got an object back.

00:25:50.160 --> 00:25:53.090
Now, alongside NSCache,
you can use another API called

00:25:53.090 --> 00:25:55.600
NSPurgableData and get some
even more good behavior.

00:25:55.600 --> 00:26:00.910
NSPurgableData is an NSData subclass
that contains data that is actually

00:26:00.910 --> 00:26:03.530
marked purgable in the system,
and the system can discard

00:26:03.720 --> 00:26:05.240
automatically if it needs the data.

00:26:05.280 --> 00:26:08.870
So imagine a case where you've read
in some file or done some expensive

00:26:09.020 --> 00:26:12.650
computation where you'd like to
keep that stuff around in memory,

00:26:12.650 --> 00:26:15.100
but you could regenerate
it if you needed to,

00:26:15.100 --> 00:26:17.180
and it fits into an NSData object.

00:26:17.870 --> 00:26:20.760
So if the system needs that memory,
it will just take it away.

00:26:20.920 --> 00:26:23.710
And NSPurgableData provides
APIs where you can lock down the

00:26:23.710 --> 00:26:26.660
memory when you're actually using it,
and then let the system know

00:26:26.850 --> 00:26:30.830
when you're finished with it,
and it's free to evict it if it needs to.

00:26:31.350 --> 00:26:34.150
If you put in this purgeable
data objects into an NSCache,

00:26:34.210 --> 00:26:36.010
you get some really great extra behavior.

00:26:36.040 --> 00:26:40.660
NSCache will not evict purgeable
data objects as aggressively because,

00:26:40.690 --> 00:26:43.340
for example,
when an NSCache sees that we're

00:26:43.490 --> 00:26:46.720
going into the background,
its default is to just purge everything

00:26:46.940 --> 00:26:48.320
because there won't be another chance.

00:26:48.510 --> 00:26:50.950
But if it's purgeable data objects,
the cache can say, "Well,

00:26:51.130 --> 00:26:53.800
if the system really needs this memory,
it will come and take it,

00:26:53.900 --> 00:26:57.300
so I don't have to evict this object
from memory myself." And then hopefully,

00:26:57.450 --> 00:27:00.100
when the application resumes,
it might still be around.

00:27:01.220 --> 00:27:04.610
NSCache will also automatically
evict the purgeable data objects when

00:27:04.610 --> 00:27:06.640
their backing stores are released.

00:27:06.740 --> 00:27:09.980
So you don't have to check
to see the purgeable data,

00:27:10.090 --> 00:27:11.690
see that its backing
store is still around.

00:27:11.870 --> 00:27:15.570
If NSCache gives it back to you,
that means that it hasn't been purged.

00:27:15.750 --> 00:27:19.860
You can get this behavior from NSCache
with your own classes by adopting

00:27:19.860 --> 00:27:23.010
the NSDiscardableContent protocol,
which gives the same begin

00:27:23.070 --> 00:27:28.060
content access and end content
access that NSPurgeableData has.

00:27:28.960 --> 00:27:33.070
And the last thing is how to figure out
what the footprint of your application is

00:27:33.130 --> 00:27:34.920
and how to bring it down at debug time.

00:27:34.920 --> 00:27:37.470
And the first way to do that, of course,
is the allocations

00:27:37.470 --> 00:27:40.310
instrument in Instruments,
which is probably everyone's

00:27:40.310 --> 00:27:42.060
favorite memory tracking tool.

00:27:42.060 --> 00:27:44.180
It's got some great
debugging information.

00:27:44.180 --> 00:27:48.060
It can give you call stacks for
where that memory was allocated.

00:27:48.060 --> 00:27:50.930
It can give you retain counts
so you can see why objects,

00:27:50.930 --> 00:27:53.220
you know,
Cocoa objects are sticking around

00:27:53.280 --> 00:27:55.320
longer than you expected them to.

00:27:55.320 --> 00:27:57.400
What it does not do,
and I'm going to talk more

00:27:57.400 --> 00:27:59.910
about this in a moment,
is show you memory that your app

00:28:00.030 --> 00:28:01.320
is indirectly responsible for.

00:28:01.330 --> 00:28:04.970
So it shows objects that you
created directly or were created

00:28:04.970 --> 00:28:08.090
directly by those objects,
but not, for example,

00:28:08.120 --> 00:28:10.930
the bitmap stores for the decoded images.

00:28:10.940 --> 00:28:12.930
So here's what it looks like.

00:28:12.960 --> 00:28:18.460
And you can see, hopefully, there we go,
the total usage of your application,

00:28:18.460 --> 00:28:22.460
the total directly allocated
memory in your application is

00:28:22.460 --> 00:28:24.660
given by the live bytes here.

00:28:24.660 --> 00:28:27.130
And then, of course,
it's divided up into the different

00:28:27.320 --> 00:28:29.200
types of memory that were allocated.

00:28:29.250 --> 00:28:31.230
So in this case,
I have an application whose live

00:28:31.320 --> 00:28:35.260
bytes are only 2.28 megabytes,
which should be pretty safe.

00:28:36.000 --> 00:28:39.660
Be sure also to check out the
Flip View on the Info Panel.

00:28:40.080 --> 00:28:41.380
There it is.

00:28:41.490 --> 00:28:43.520
There's some great options for
getting more data out of this,

00:28:43.550 --> 00:28:47.140
in particular,
the Record Reference Counts checkbox.

00:28:47.270 --> 00:28:50.170
This is what you need to check
in order--before you take a

00:28:50.170 --> 00:28:53.650
trace in order to see the retains
and releases on your objects,

00:28:53.720 --> 00:28:56.670
which can--excuse me,
can be a great tool in tracking

00:28:57.090 --> 00:28:59.450
why your memory is not going away.

00:28:59.820 --> 00:29:02.740
But in addition to the
allocations object tool,

00:29:02.910 --> 00:29:05.240
don't forget about the
VM tracker instrument,

00:29:05.250 --> 00:29:09.000
which shows the total
application memory footprint.

00:29:09.090 --> 00:29:12.700
So this shows not only what your
application is directly responsible for,

00:29:12.700 --> 00:29:16.280
but also other memory that was
indirectly allocated on your behalf,

00:29:16.280 --> 00:29:17.530
like those bitmaps.

00:29:17.530 --> 00:29:20.690
And what you want to look for
in the VM tracker is the dirty

00:29:20.690 --> 00:29:22.330
memory usage of your app.

00:29:22.470 --> 00:29:24.230
This is what's actually going
to cause your app to get

00:29:24.230 --> 00:29:25.550
terminated if it grows too high.

00:29:25.550 --> 00:29:27.610
Unfortunately,
it doesn't have call stacks and

00:29:27.760 --> 00:29:29.270
other useful debugging info.

00:29:29.280 --> 00:29:33.280
But it's still a great tool for figuring
out why your application's memory usage

00:29:33.470 --> 00:29:35.620
is higher than you had thought it was.

00:29:35.620 --> 00:29:37.420
So in this case,
this is a trace I took on

00:29:37.500 --> 00:29:40.400
exactly the same application,
which only had 2.28

00:29:40.400 --> 00:29:41.730
megabytes of live bytes.

00:29:41.730 --> 00:29:45.840
But in this case,
I have 118 megabytes of dirty memory.

00:29:45.850 --> 00:29:47.140
Now, where's that coming from?

00:29:47.140 --> 00:29:49.620
Well, it's in this memory tag 70.

00:29:49.620 --> 00:29:51.150
And here's the big secret.

00:29:51.150 --> 00:29:53.470
Memory tag 70 means image IO memory.

00:29:53.470 --> 00:29:56.380
This is usually images that
have been decoded and we're

00:29:56.450 --> 00:29:58.140
holding onto these bitmaps.

00:29:58.860 --> 00:30:02.620
So any time you see memory tag 70
appearing with a lot of dirty memory,

00:30:02.640 --> 00:30:05.750
check to see if you've got images
that you're sticking around that

00:30:05.750 --> 00:30:07.980
you weren't expecting to have.

00:30:08.320 --> 00:30:14.340
So with that, I'm going to turn it
over to the second half.

00:30:14.350 --> 00:30:16.300
Ben, there he is.

00:30:25.700 --> 00:30:28.510
I'm an engineer on the
iOS Performance team,

00:30:28.520 --> 00:30:31.900
and I'm going to talk about view
and animation performance today.

00:30:32.950 --> 00:30:34.560
First, we're going to start
with some fundamentals.

00:30:34.720 --> 00:30:37.680
If your view overrides UIViewDrawRect,
it draws.

00:30:37.680 --> 00:30:41.540
And we're going to talk about how
those views draw and when they draw.

00:30:41.570 --> 00:30:44.130
If you're using UIImage views,
they display images.

00:30:44.140 --> 00:30:48.580
And we're going to talk about when these
images get deserialized into memory.

00:30:48.580 --> 00:30:51.870
Next, we're going to talk about some
useful effects for your images.

00:30:51.930 --> 00:30:55.150
You can crop, stretch,
and tile images efficiently if you know

00:30:55.150 --> 00:30:57.620
how to do them using a CA layer effects.

00:30:57.660 --> 00:30:59.820
And finally,
we'll talk about some performance

00:30:59.820 --> 00:31:01.860
guidelines for smooth animations.

00:31:01.940 --> 00:31:04.890
So first let's talk about
the view drawing cycle.

00:31:05.090 --> 00:31:07.360
In this example,
we're going to create a UI label.

00:31:07.360 --> 00:31:11.650
UI label actually overrides DrawRect
to actually draw the text in the label.

00:31:11.650 --> 00:31:13.820
And in this example,
we're going to set the

00:31:13.820 --> 00:31:17.460
background color to white,
and we're going to set the text to hello.

00:31:17.460 --> 00:31:20.380
And notice that nothing
expensive has happened yet.

00:31:20.380 --> 00:31:23.840
All we've done is created the
UI view and its backing CA layer.

00:31:23.840 --> 00:31:28.430
We haven't done any drawing yet,
but because the view implements DrawRect,

00:31:28.430 --> 00:31:31.650
we will mark the view as
dirty using set needs display

00:31:31.760 --> 00:31:34.320
automatically at view creation time.

00:31:34.520 --> 00:31:36.730
But again,
nothing expensive has happened yet.

00:31:36.780 --> 00:31:39.980
We've just created a view
and its backing layer.

00:31:39.980 --> 00:31:40.630
No drawing yet.

00:31:42.900 --> 00:31:45.280
Eventually, we'll probably add this
label to the view hierarchy.

00:31:45.280 --> 00:31:49.020
And you may not know this,
but every single core animation

00:31:49.090 --> 00:31:52.300
property change happens in the
context of a CA transaction.

00:31:52.380 --> 00:31:55.510
You can create your own
transaction and commit them.

00:31:55.520 --> 00:31:57.090
Most of you probably don't.

00:31:57.140 --> 00:32:01.500
So we actually create a transaction at
the beginning of the run loop implicitly,

00:32:01.500 --> 00:32:03.760
and at the end of the run loop,
we'll implicitly commit

00:32:03.910 --> 00:32:04.860
those transactions.

00:32:04.860 --> 00:32:07.420
So let's take a look at what
happens at the end of the run

00:32:07.420 --> 00:32:09.400
loop when the transaction commits.

00:32:10.460 --> 00:32:14.100
We're going to notice that there's
a dirty flag on this UI label

00:32:14.100 --> 00:32:16.000
when the transaction commits.

00:32:16.000 --> 00:32:20.390
And we're going to first create a
backing store for that CA layer.

00:32:20.400 --> 00:32:23.090
And a backing store is just a CG context.

00:32:23.100 --> 00:32:24.410
It's a place for you to draw into.

00:32:24.460 --> 00:32:27.470
So that's what you get back
when you call UIGraphics

00:32:27.470 --> 00:32:29.780
getCurrentContext in your drawRect.

00:32:31.660 --> 00:32:33.480
Next,
we'll fill the backing store with the

00:32:33.480 --> 00:32:37.030
background color you set for your view,
in this case, white.

00:32:37.280 --> 00:32:38.940
Then we'll actually call
the view's drawRect,

00:32:39.090 --> 00:32:43.430
in this case, UILabelDrawRect,
which will draw the text into the view.

00:32:43.450 --> 00:32:46.170
And finally,
we'll clear the dirty flag on the label,

00:32:46.170 --> 00:32:49.040
and we can use that contents,
that backing store,

00:32:49.050 --> 00:32:51.400
to composite the label
onto the view hierarchy.

00:32:51.410 --> 00:32:54.360
On subsequent draws,
the process is pretty similar.

00:32:54.380 --> 00:32:57.670
Let's say we set the text to hello--oh,
sorry, to buy,

00:32:57.770 --> 00:33:01.430
and we call sizeToFit to resize our view.

00:33:01.730 --> 00:33:04.210
When we call setText,
we'll immediately change

00:33:04.210 --> 00:33:05.700
the text property to buy.

00:33:05.720 --> 00:33:08.180
That's going to implicitly
call setNeedsDisplay,

00:33:08.290 --> 00:33:12.540
which will mark the view as dirty,
so that it will redraw.

00:33:12.550 --> 00:33:15.900
Notice that we can call setNeedsDisplay
as many times as we want,

00:33:15.910 --> 00:33:17.180
but it has no effect.

00:33:17.390 --> 00:33:20.480
It just sets the dirty flag
if it's not already dirty.

00:33:20.640 --> 00:33:22.780
In this case, it's already dirty,
so it has no effect.

00:33:22.860 --> 00:33:26.150
So setNeedsDisplay doesn't
cause an eager draw.

00:33:26.570 --> 00:33:30.530
Again, at the end of the run loop,
when the transaction commits,

00:33:30.640 --> 00:33:33.450
because we called size to fit,
the size of the backing

00:33:33.460 --> 00:33:34.520
store has to change.

00:33:34.630 --> 00:33:38.530
The size of our view has changed,
so the size of the backing store changes.

00:33:38.870 --> 00:33:41.230
We're going to create a new
backing store at the correct size.

00:33:41.480 --> 00:33:44.270
We're going to fill it again with
the correct background color,

00:33:44.430 --> 00:33:45.510
in this case white.

00:33:45.790 --> 00:33:48.110
And then we're going to call
UILabelDrawRec to actually render

00:33:48.120 --> 00:33:50.640
the text into that backing store.

00:33:50.640 --> 00:33:53.500
And then we'll clear the
dirty flag on the view.

00:33:54.770 --> 00:33:55.780
So why are we telling you this?

00:33:55.880 --> 00:33:59.660
Well, the first reason is so that you
understand what you see in Time Profiler.

00:33:59.820 --> 00:34:03.080
Time Profiler is probably the best
tool we have for solving a large

00:34:03.260 --> 00:34:05.190
class of performance problems.

00:34:05.270 --> 00:34:10.180
And it really helps to know what
you're looking at in Time Profiler.

00:34:10.590 --> 00:34:13.740
So in this case,
you'll see at the root of the call stack,

00:34:13.860 --> 00:34:15.720
in this case I've
un-inverted the call stack,

00:34:15.790 --> 00:34:17.630
which is not the default
view in Time Profiler,

00:34:17.630 --> 00:34:18.190
by the way.

00:34:18.220 --> 00:34:21.990
So at the root of the call stack,
you'll see this CF run loop observer,

00:34:21.990 --> 00:34:24.200
which calls a CA transaction commit.

00:34:24.200 --> 00:34:27.980
And this is the implicit CA transaction
commit that I was talking about earlier.

00:34:27.980 --> 00:34:29.940
That's how we actually implement that.

00:34:30.010 --> 00:34:33.540
So all your drawing work is going
to happen under this call stack,

00:34:33.820 --> 00:34:36.230
under this CA transaction
commit call stack.

00:34:36.240 --> 00:34:37.310
That's why it's there.

00:34:37.690 --> 00:34:39.420
Next,
you'll actually see some drawing work.

00:34:39.490 --> 00:34:41.400
And that's all under CA layer display.

00:34:41.400 --> 00:34:44.840
You'll actually see
this UI rect fill call.

00:34:44.840 --> 00:34:48.240
That's us filling the view with
the background color of the view.

00:34:48.240 --> 00:34:51.850
And then you'll also see, in this case,
we spent 96 milliseconds

00:34:52.090 --> 00:34:53.390
in UI label draw rect.

00:34:53.480 --> 00:34:55.760
So if you see a lot of time
spent in your draw rect,

00:34:55.860 --> 00:34:58.180
you're going to see it
here in Time Profile.

00:34:58.180 --> 00:35:02.910
And finally, you'll see that we call
CA render new bitmap to actually

00:35:03.000 --> 00:35:05.080
create the backing store.

00:35:05.080 --> 00:35:07.170
So if you see a lot of time
spent creating new bitmap,

00:35:07.640 --> 00:35:11.130
in this context,
it probably means you're going through

00:35:11.140 --> 00:35:13.080
a lot of resize and redraw cycles.

00:35:13.100 --> 00:35:15.040
And so really examine your code.

00:35:15.080 --> 00:35:17.270
Are you changing the size
of your views too often?

00:35:17.280 --> 00:35:20.250
Are you redrawing calling
set needs display too often?

00:35:20.260 --> 00:35:22.670
That's what to look for if you
see a lot of time spent there.

00:35:22.680 --> 00:35:25.530
The other reason why we're telling
you about these backing stores is

00:35:25.620 --> 00:35:30.060
they have this sort of mysterious tag
in VM tracker called core animation.

00:35:30.080 --> 00:35:34.080
That core animation tag is
actually view backing store.

00:35:34.080 --> 00:35:37.540
So in this case, in this example,
I've unchecked the core animation tag.

00:35:37.540 --> 00:35:40.780
I've checked the coalesce
regions option in VM tracker,

00:35:40.860 --> 00:35:43.310
and there is 1,000
core animation regions.

00:35:43.320 --> 00:35:44.140
So what does that mean?

00:35:44.160 --> 00:35:48.740
That means I have 1,000 CA layers live
in my app that have been added to a view

00:35:48.740 --> 00:35:50.650
hierarchy at some point and have drawn.

00:35:50.710 --> 00:35:54.700
So 1,000 CA layers or 1,000 UI views
that have drawn at some point.

00:35:54.720 --> 00:35:57.010
That's probably not what
you want in your app.

00:35:57.080 --> 00:35:59.850
1,000 views at a time is a lot.

00:36:00.080 --> 00:36:04.130
So if you see an accumulation in the
core animation region in VM tracker,

00:36:04.160 --> 00:36:07.040
those are view backing stores,
and you probably have

00:36:07.040 --> 00:36:08.670
leaked or abandoned views.

00:36:08.680 --> 00:36:10.560
And these backing stores
can be really large.

00:36:10.730 --> 00:36:13.370
For example, a full screen backing
store on an iPhone 4,

00:36:13.640 --> 00:36:14.930
that's 2.4 megabytes.

00:36:14.940 --> 00:36:17.570
So it can pile up really quickly
if you abandon your views.

00:36:17.580 --> 00:36:21.140
Let's talk about some
view drawing guidelines.

00:36:21.250 --> 00:36:23.930
The first is to mark your views opaque.

00:36:24.240 --> 00:36:28.060
Opaque views take a lot less work
for the compositor to composite.

00:36:28.060 --> 00:36:31.400
By default, UI views are opaque,
but you can override that behavior by,

00:36:31.400 --> 00:36:33.980
for example, in this case,
I've set a background color

00:36:34.410 --> 00:36:35.790
with the alpha of 0.5.

00:36:35.790 --> 00:36:39.090
So we're going to assume that
you actually want your view to

00:36:39.090 --> 00:36:43.420
be non-opaque when you set a
background color with a non-1 alpha,

00:36:43.430 --> 00:36:47.600
and we'll override the opaque flag
and set it to no behind your back.

00:36:47.680 --> 00:36:50.690
So, you know,
just be aware that just because the

00:36:50.690 --> 00:36:53.160
view starts as opaque doesn't mean
that it's going to end as opaque,

00:36:53.210 --> 00:36:57.090
even if you don't call setOpake no.

00:36:57.330 --> 00:37:01.500
And also note that UIView set opaque
on an image view has no effect.

00:37:01.590 --> 00:37:05.530
The opaqueness of an image is
determined by whether the image

00:37:05.580 --> 00:37:07.430
itself has an alpha channel.

00:37:07.430 --> 00:37:11.080
And I'll be going over that
again and again several times.

00:37:11.890 --> 00:37:13.760
The next guideline is to
flatten view hierarchies.

00:37:13.760 --> 00:37:15.390
You've probably heard this many,
many times.

00:37:15.420 --> 00:37:17.940
And you might wonder yourself why.

00:37:18.240 --> 00:37:20.780
And the reason why is because
all these backing stores,

00:37:20.780 --> 00:37:23.410
there's a per backing store
cost for allocating them,

00:37:23.410 --> 00:37:27.110
deallocating them, synchronizing them,
compositing them.

00:37:27.110 --> 00:37:30.550
And so a lot of times you can
get better scrolling performance,

00:37:30.550 --> 00:37:32.970
for example,
if you flatten your view hierarchies.

00:37:32.970 --> 00:37:37.160
You have to balance this against the cost
of when you flatten your view hierarchy,

00:37:37.160 --> 00:37:39.960
you're probably making
one larger coalesced view.

00:37:39.960 --> 00:37:41.870
So you have to balance those costs.

00:37:41.880 --> 00:37:44.280
And you have to profile
what you're doing.

00:37:44.290 --> 00:37:47.480
One example that can be kind of useful
here that not everyone knows about,

00:37:47.570 --> 00:37:51.130
in this example, I've got this UI table
view cell content view.

00:37:51.130 --> 00:37:55.480
And I've got three labels, a from label,
subject label, and message label.

00:37:55.570 --> 00:37:57.310
But they're not actually
in my view hierarchy.

00:37:57.350 --> 00:38:01.950
I'm just using them as sort of model
objects to encapsulate the drawing state.

00:38:02.010 --> 00:38:05.040
And draw text and racked on
UI label lets you just use the

00:38:05.040 --> 00:38:07.010
label to draw into another view.

00:38:07.010 --> 00:38:09.380
So this can be a really useful tool.

00:38:09.380 --> 00:38:11.380
And then the last one
is the view hierarchy.

00:38:11.380 --> 00:38:12.130
So this is a really useful way of
using labels without adding the

00:38:12.130 --> 00:38:15.150
labels to your view hierarchy if you
want to flatten your view hierarchy.

00:38:15.180 --> 00:38:17.710
And since those labels have never
been added to view hierarchy,

00:38:17.920 --> 00:38:20.420
they won't have a backing
store associated with them,

00:38:20.530 --> 00:38:22.380
as we've talked about earlier.

00:38:22.830 --> 00:38:25.080
Just one caution,
don't call drawRect yourself.

00:38:25.170 --> 00:38:26.830
Notice that I'm calling drawText in Rect.

00:38:26.940 --> 00:38:29.520
This is a method that
we expose on UILabel.

00:38:29.520 --> 00:38:34.540
And other model objects
have similar methods,

00:38:34.610 --> 00:38:37.410
such as UIImageDraw in Rect.

00:38:37.520 --> 00:38:40.980
Another view drawing guideline
is to understand the difference

00:38:40.980 --> 00:38:43.250
between view layout and view display.

00:38:43.320 --> 00:38:45.760
Every once in a while we go to the
labs and we see something like this.

00:38:45.990 --> 00:38:48.830
You call setNeedsDisplay
in your layout subviews,

00:38:49.140 --> 00:38:52.100
and this is probably not going
to do what you'd expect it to do.

00:38:52.170 --> 00:38:55.480
Because layout is about
positioning and sizing subviews,

00:38:55.600 --> 00:38:58.920
and display on your own view
is about redrawing yourself.

00:38:59.010 --> 00:39:02.490
And in general,
your view doesn't need to redraw just

00:39:02.630 --> 00:39:04.430
because it moved around a few subviews.

00:39:04.510 --> 00:39:07.540
So this is probably not
the right coding style.

00:39:07.630 --> 00:39:10.530
If you actually want your view
to redraw when its size changes,

00:39:10.630 --> 00:39:11.820
we actually have a flag for that.

00:39:11.920 --> 00:39:13.970
That's UIViewContentModeRedraw.

00:39:14.100 --> 00:39:20.100
So use that if you want your view to
implicitly redraw if its size changes.

00:39:20.460 --> 00:39:23.630
And finally, the last guideline is
to simply draw less.

00:39:23.840 --> 00:39:26.070
We have a set needs display in Rect.

00:39:26.070 --> 00:39:28.920
This will mark a
sub-rectangle of your view,

00:39:28.990 --> 00:39:33.360
dirty, and that will be passed as the
first parameter to draw Rect.

00:39:33.360 --> 00:39:37.240
And the idea is then to try to draw
only into that dirty Rect so you can

00:39:37.240 --> 00:39:39.200
reuse what you've drawn in the past.

00:39:39.210 --> 00:39:42.620
Now, of course, this only helps if your
view draws multiple times.

00:39:42.640 --> 00:39:45.590
Another thing that you can do is
use the CA Layer properties to crop,

00:39:45.650 --> 00:39:48.140
stretch, and tile images,
which can replace a lot of

00:39:48.320 --> 00:39:49.960
simple draw Rect implementations.

00:39:49.960 --> 00:39:52.380
And we're going to go over
that in just a few minutes.

00:39:52.410 --> 00:39:55.800
Next, let's talk about the image display
cycle if you use UI image views.

00:39:55.800 --> 00:39:59.820
This is going to look really similar to
the view drawing cycle I just went over.

00:39:59.840 --> 00:40:02.080
In this example,
we're going to create a UI image.

00:40:02.080 --> 00:40:06.060
A UI image is an immutable object
that is backed by a CG image.

00:40:06.380 --> 00:40:09.780
We're going to set that UI image
as the image on an image view.

00:40:09.810 --> 00:40:13.050
And behind your back,
what that does is sets the

00:40:13.050 --> 00:40:17.680
contents of the backing CA Layer to
the CG image in the UI image.

00:40:18.150 --> 00:40:19.040
So notice a couple things.

00:40:19.040 --> 00:40:22.310
First, creating the UI image
and the CG image is fast.

00:40:22.310 --> 00:40:25.290
All we do when you create a
UI image or a CG image is we

00:40:25.420 --> 00:40:29.560
read out some header metadata to
figure out how big the image is.

00:40:29.570 --> 00:40:32.750
We don't do actually--we don't actually
do any decompression at this point.

00:40:32.750 --> 00:40:36.050
And also notice that creating the
UI image view and the CA Layer is fast.

00:40:36.050 --> 00:40:39.600
So we haven't really done
anything expensive yet.

00:40:39.640 --> 00:40:42.220
In particular,
if you just go ahead and create a

00:40:42.220 --> 00:40:45.970
ton of UI images upfront in your app,
you're not really saving yourself any

00:40:45.970 --> 00:40:50.410
work because all you're doing is reading
a bunch of headers of several files.

00:40:50.430 --> 00:40:54.160
Again, eventually, we'll add this image
view to a view hierarchy.

00:40:54.220 --> 00:40:58.370
And we're going to notice that a
new view was added to view hierarchy

00:40:58.380 --> 00:41:01.300
at the end of the transaction,
generally at the end of the run loop.

00:41:01.320 --> 00:41:04.060
At the end of the run loop,
because this image view is new,

00:41:04.060 --> 00:41:07.330
we're going to notice that its
contents points to a CG image

00:41:07.330 --> 00:41:11.280
that has not been deserialized,
hasn't been decompressed.

00:41:11.280 --> 00:41:13.980
So, for example,
say the CG image is actually a JPEG,

00:41:14.080 --> 00:41:16.030
at some point,
we actually have to decompress

00:41:16.030 --> 00:41:17.880
that JPEG into a bitmap.

00:41:18.000 --> 00:41:19.840
And that bitmap can be really big.

00:41:19.840 --> 00:41:23.160
It's generally the width of the
bitmap--it's generally the width of

00:41:23.200 --> 00:41:27.400
the image times the height of the image
times four bytes because we use 32-bit

00:41:27.400 --> 00:41:31.050
RGBA as our general image format.

00:41:31.070 --> 00:41:34.220
So the key thing to notice here
is that that bitmap is hanging

00:41:34.220 --> 00:41:35.860
off the CG image instance.

00:41:35.980 --> 00:41:40.990
So if you hold on to your UI image or
CG image instance for a very long time,

00:41:41.050 --> 00:41:45.040
you may very well be holding on to
multi-megabyte bitmaps in memory.

00:41:45.140 --> 00:41:47.680
And this is a really,
really quick way to get your

00:41:47.680 --> 00:41:47.920
app to be able to do that.

00:41:47.920 --> 00:41:50.480
So, if you want to get your app
killed for low memory reasons.

00:41:50.510 --> 00:41:53.920
Note that UIImageImageNamed
actually holds on to the UIImage

00:41:54.010 --> 00:41:56.640
instance behind your back,
but we do try to manage

00:41:56.700 --> 00:41:58.110
this cache efficiently.

00:41:58.140 --> 00:42:02.030
So it will automatically free the
cache if the system is low on memory,

00:42:02.040 --> 00:42:04.600
also if your app goes
into the background.

00:42:04.600 --> 00:42:07.820
But in general,
you should be really wary about holding

00:42:07.820 --> 00:42:12.360
on to CG image or UIImage instance
past when you actually need them.

00:42:12.390 --> 00:42:13.920
Again, why are we telling you about this?

00:42:14.060 --> 00:42:15.860
Well, first,
we want you to understand what

00:42:15.860 --> 00:42:17.270
you're seeing in TimeProfiler.

00:42:17.460 --> 00:42:21.040
The call that you'll see for the
deserialization of the image where we

00:42:21.040 --> 00:42:24.740
actually call the JPEG decompression
or the ping decompression algorithm

00:42:24.740 --> 00:42:27.840
is going to be CG image provider
copy image block set with options

00:42:27.840 --> 00:42:32.230
or something along those lines,
something with an image block set.

00:42:32.250 --> 00:42:36.520
And if you expand that call stack,
you'll see actually time spent in ping

00:42:36.530 --> 00:42:38.980
decompression or JPEG decompression.

00:42:38.980 --> 00:42:40.350
So you see a lot of time spent here.

00:42:40.730 --> 00:42:42.930
Really make sure that your
images are the correct size.

00:42:43.070 --> 00:42:45.060
For example,
if you're displaying an image

00:42:45.060 --> 00:42:48.800
into a view that's 600 by 400,
you should not be putting a 12

00:42:48.920 --> 00:42:52.360
megapixel image into deserializing
12 megapixel image because

00:42:52.360 --> 00:42:54.000
that takes a really long time.

00:42:54.030 --> 00:42:57.560
The other reason why you want to make
sure your images are properly sized is,

00:42:57.570 --> 00:42:59.230
again, they take a lot of memory.

00:42:59.360 --> 00:43:03.080
So to take that previous
example of a 12 megapixel JPEG,

00:43:03.080 --> 00:43:05.240
it might be only 4 megabytes on disk.

00:43:05.250 --> 00:43:07.750
But at 4 bytes per pixel,
12 million pixels,

00:43:07.860 --> 00:43:11.760
that's 48 million bytes,
about 48 megabytes.

00:43:11.760 --> 00:43:14.610
And that's--this, again,
shows up as memory tag 70 in

00:43:14.700 --> 00:43:16.720
VM tracker as Dan pointed out.

00:43:16.740 --> 00:43:18.110
So if you see a lot of--if you see a lot
of--if you see a lot of--if you see a lot

00:43:18.110 --> 00:43:21.960
of memory tag 70 memory in VM tracker,
that probably means you're holding

00:43:21.960 --> 00:43:26.760
on to CG image or UI image instances
past when you should be or you

00:43:26.810 --> 00:43:29.360
just have some really large images.

00:43:29.460 --> 00:43:32.690
And we've seen some really big,
really popular apps do this where

00:43:32.690 --> 00:43:35.870
they'll just deserialize a huge bitmap,
deserialize a huge

00:43:35.870 --> 00:43:38.880
JPEG like 15 megapixels,
20 megapixels and put

00:43:38.880 --> 00:43:40.440
them into a tiny view.

00:43:40.590 --> 00:43:44.070
And this takes a lot of time and
takes--uses up a lot of memory

00:43:44.070 --> 00:43:46.410
and it's likely to get your app
killed because of low memory.

00:43:46.410 --> 00:43:49.360
So really, really important to really,
really watch out for this.

00:43:49.380 --> 00:43:51.860
A related topic is the
animated images API.

00:43:51.860 --> 00:43:53.660
We have a couple APIs for this.

00:43:53.820 --> 00:43:56.240
UI image view set animation images,
for example,

00:43:56.240 --> 00:43:58.060
has been available since 2.0.

00:43:58.070 --> 00:44:01.430
The good thing about them is they
use CA keyframe animation behind your

00:44:01.620 --> 00:44:03.720
back to animate the layer contents.

00:44:03.720 --> 00:44:05.970
So this guarantees smooth frame rate.

00:44:05.980 --> 00:44:08.020
The bad thing is to guarantee
the smooth frame rate,

00:44:08.110 --> 00:44:10.300
we have to go deserialize
all the images at once.

00:44:10.300 --> 00:44:15.210
So this is really only appropriate
for small animations like spinners.

00:44:15.490 --> 00:44:17.440
What happens if you use it for, say,
a slideshow,

00:44:17.440 --> 00:44:18.600
a full-screen image slideshow?

00:44:18.600 --> 00:44:20.750
In this case,
we've got 10 full-screen images.

00:44:20.970 --> 00:44:24.340
Each of them takes 2.4
megabytes of memory.

00:44:24.340 --> 00:44:29.300
So we end up with about 24 megabytes
of bitmap memory all at once allocated.

00:44:29.400 --> 00:44:32.210
That's probably not what you were
going for when you made the slideshow.

00:44:32.440 --> 00:44:34.730
As an alternative,
you can use a CA DisplayLink as

00:44:34.770 --> 00:44:38.420
a timer to set the image on
the image view on a callback.

00:44:38.420 --> 00:44:41.500
And the good thing about this is now
you're de-serializing the images one

00:44:41.500 --> 00:44:44.050
at a time rather than all at once.

00:44:44.130 --> 00:44:46.890
The bad part about that, of course,
is because you're de-serializing

00:44:46.890 --> 00:44:49.690
them one at a time,
your frame rate is no longer guaranteed.

00:44:49.790 --> 00:44:54.050
Notice in this example that we're using
image with contents of file or image

00:44:54.050 --> 00:44:55.700
with data rather than image named.

00:44:55.780 --> 00:44:58.770
Because, as I said before,
image named does cache the image

00:44:58.770 --> 00:45:05.790
instance behind your back and tries to
manage that global cache of image named

00:45:06.010 --> 00:45:08.040
calls and free them on low memory.

00:45:08.180 --> 00:45:10.340
But in this case,
we really just want to use the image

00:45:10.340 --> 00:45:12.120
and get rid of it as fast as possible.

00:45:12.120 --> 00:45:16.400
So in those cases,
use image with contents of file or

00:45:16.400 --> 00:45:19.940
image with data so that you don't
get this implicit caching behavior.

00:45:20.000 --> 00:45:21.690
Let's go over a few
image display guidelines.

00:45:21.780 --> 00:45:23.780
Again,
remove alpha channels from your images.

00:45:23.780 --> 00:45:27.280
If you have a ping that looks opaque,
really open it up in

00:45:27.280 --> 00:45:28.840
Photoshop or preview.

00:45:29.170 --> 00:45:31.880
Use that get info and make sure
it has no alpha channel because

00:45:31.880 --> 00:45:36.480
that is what determines whether
the image view is opaque or not.

00:45:36.630 --> 00:45:38.250
Size the images appropriately.

00:45:38.310 --> 00:45:40.820
As we were talking about
with the example earlier,

00:45:40.820 --> 00:45:43.460
if you have a 12 megapixel
image going to 600 by 400,

00:45:43.470 --> 00:45:45.650
that's a huge no-no.

00:45:45.670 --> 00:45:49.390
It should be a 600 by 400 image
going to a 600 by 400 view or

00:45:49.390 --> 00:45:51.240
even a smaller image than that.

00:45:51.270 --> 00:45:54.310
And maybe for whatever reason,
maybe you're pulling these

00:45:54.320 --> 00:45:55.200
images down from a server.

00:45:55.200 --> 00:45:56.980
You just have no control over it.

00:45:56.990 --> 00:45:57.970
What do you do in that case?

00:45:58.110 --> 00:46:03.680
Well, we do have APIs that down sample
images efficiently in memory.

00:46:04.040 --> 00:46:07.880
That's the CG image source
create thumbnail index API.

00:46:07.900 --> 00:46:10.680
This is in the image IO framework
and it's really easy to use.

00:46:10.720 --> 00:46:13.160
As you can see here, you just specify,
in this case,

00:46:13.170 --> 00:46:17.340
a max pixel size limit of 1024
and it will create a thumbnail

00:46:17.340 --> 00:46:22.040
that's a maximum of 1024 in width
or height from the source image.

00:46:22.410 --> 00:46:26.670
Finally, as I've been talking about,
all the image deserialization is lazy.

00:46:26.680 --> 00:46:28.280
And this is usually what you want.

00:46:28.280 --> 00:46:31.340
We want to be lazy if
we can get away with it.

00:46:31.340 --> 00:46:35.020
But sometimes if you profile
your app and you actually really,

00:46:35.020 --> 00:46:37.990
really just want to force the
image to deserialize right now,

00:46:38.080 --> 00:46:41.650
you have to create your own image
context to create a CG context

00:46:41.650 --> 00:46:42.860
and draw the image into the image.

00:46:42.860 --> 00:46:44.850
And you can do that by using
the image as a reference.

00:46:44.870 --> 00:46:46.860
So, you can create your own image into
that CG context as in this example.

00:46:46.860 --> 00:46:50.770
And really use this with care
because this is a real easy way

00:46:50.860 --> 00:46:50.860
to blow up your memory footprint.

00:46:50.930 --> 00:46:53.840
But if you know what you're doing,
you've profiled it in time profile,

00:46:53.930 --> 00:46:57.020
and you've determined that the only
way you can get good performance is

00:46:57.020 --> 00:47:00.880
by eagerly deserializing your image,
this is available for you.

00:47:00.880 --> 00:47:04.930
Next, let's talk about cropping,
stretching, and tiling images.

00:47:05.380 --> 00:47:08.870
Not too many people know about this
contents-rect property on CLayer because

00:47:08.870 --> 00:47:13.300
there is no equivalent UI view property
that shadows this contents-rect property,

00:47:13.300 --> 00:47:16.350
but it's really useful
for panorama effects.

00:47:16.490 --> 00:47:18.620
What it does is it
lets you crop an image.

00:47:18.680 --> 00:47:20.510
So in this case,
we're going to set the contents-rect

00:47:20.730 --> 00:47:23.780
first to that small rectangle
and then to this full rectangle.

00:47:23.780 --> 00:47:30.060
And the result of this animation is this
Ken Burns effect that looks like this.

00:47:30.060 --> 00:47:33.280
And it's really fluid on all
devices that support iOS 5.

00:47:33.370 --> 00:47:36.030
We're just going to deserialize the
image once and then per frame we'll

00:47:36.030 --> 00:47:39.500
update these four floating point
texture coordinates over and over.

00:47:39.500 --> 00:47:40.590
So it's really fast.

00:47:40.640 --> 00:47:43.600
If you're going to use this on
devices that don't support iOS 5,

00:47:43.600 --> 00:47:47.900
you're going to have to try this out
because it may not be as efficient on the

00:47:47.900 --> 00:47:50.740
older devices that don't support iOS 5.

00:47:50.740 --> 00:47:54.970
We have a similar property,
content center on CLayer and content

00:47:54.980 --> 00:47:59.440
stretch on UI view that lets you
pick a region of an image to stretch.

00:47:59.460 --> 00:48:02.090
So in this case,
we've got this small chat bubble

00:48:02.090 --> 00:48:06.060
and we're going to pick this
little rectangle to stretch.

00:48:06.090 --> 00:48:11.110
And this lets you animate or just
change the size of an image to be much

00:48:11.270 --> 00:48:13.140
bigger than the actual image size.

00:48:13.140 --> 00:48:15.780
So it's really useful,
not just for animations,

00:48:15.780 --> 00:48:19.800
but just for minimizing
the size of your assets.

00:48:19.800 --> 00:48:23.140
And this can replace a lot of
basic draw-rect implementations.

00:48:23.440 --> 00:48:27.560
Again, this is efficient on all iOS
devices that support iOS 5.

00:48:27.690 --> 00:48:31.200
If you're going to use this on older
devices that don't support iOS 5,

00:48:31.200 --> 00:48:33.380
you're going to want to try to profile
and change the size of the image.

00:48:33.380 --> 00:48:33.380
So this is really useful.

00:48:33.380 --> 00:48:33.980
And this is going to be a great
way to try this out on your own.

00:48:33.980 --> 00:48:34.700
So you can just go ahead and
try this out on your own.

00:48:34.700 --> 00:48:35.110
And you can also use this on your own.

00:48:35.110 --> 00:48:35.540
You can also use this on your own.

00:48:35.580 --> 00:48:35.950
You can also use this on your own.

00:48:35.950 --> 00:48:36.750
You can also use this on your own
and just try this out on your own.

00:48:36.750 --> 00:48:37.060
And this is really useful.

00:48:37.060 --> 00:48:38.380
And this is really useful
for your own iOS 5.

00:48:38.380 --> 00:48:39.510
Next, let's talk about tiling images.

00:48:39.510 --> 00:48:40.820
Tiled images are all over iOS 5.

00:48:40.820 --> 00:48:45.110
For example, the linens in springboard
and the pattern background,

00:48:45.110 --> 00:48:48.800
the pinstripe pattern background
on group table view cells.

00:48:48.800 --> 00:48:51.660
The way you create these
tiled images is UI color,

00:48:51.770 --> 00:48:53.740
color with pattern image.

00:48:53.740 --> 00:48:58.900
And then you can use that color to fill
into a CG context or you can just set the

00:48:58.900 --> 00:49:01.680
color as the background color for a view.

00:49:01.680 --> 00:49:05.440
Now, we've made a lot of improvements
to tiled images in iOS 5.

00:49:05.610 --> 00:49:07.870
But to take advantage
of those improvements,

00:49:08.050 --> 00:49:11.290
you need to make sure the width
and the height of your tiled

00:49:11.340 --> 00:49:12.770
images are a power of two.

00:49:13.040 --> 00:49:17.040
So for example, 512 by 1,
good tiled image size.

00:49:17.040 --> 00:49:20.160
256 by 256 is a good image size.

00:49:20.170 --> 00:49:23.570
Just make sure the width and height
are a power of two to get the optimal

00:49:23.690 --> 00:49:26.440
performance out of your tiled images.

00:49:26.560 --> 00:49:29.880
We've sort of combined these
tiled and stretched images

00:49:29.890 --> 00:49:32.040
into a single API in iOS 5.

00:49:32.040 --> 00:49:33.300
And this is the UI image.

00:49:33.300 --> 00:49:36.600
So the UI image is a sizeable
image with cap insets API.

00:49:36.600 --> 00:49:39.720
And you can just use this naively and
you can get pretty good performance.

00:49:39.970 --> 00:49:42.780
But I just want to go over some
guidelines on getting the maximum

00:49:42.780 --> 00:49:44.380
performance out of this API.

00:49:44.380 --> 00:49:48.580
So the first thing to notice is we
have a 31 by 31 pixel image here.

00:49:48.580 --> 00:49:52.580
And if I set the interior
region to be just 1 by 1 pixels,

00:49:52.590 --> 00:49:56.260
I'm guaranteed that that 1 by 1
pixel region will be stretched.

00:49:56.260 --> 00:49:59.620
And that's the maximum performance
you'll get out of this API.

00:49:59.620 --> 00:50:02.460
So if you're using resizable
image with cap insets,

00:50:02.580 --> 00:50:03.260
try to make sure that you're
not going to get the maximum

00:50:03.260 --> 00:50:03.260
performance out of this API.

00:50:03.260 --> 00:50:06.810
Make sure that one--that if you
can stretch the interior region,

00:50:07.110 --> 00:50:09.580
make sure it's one point by one point.

00:50:09.580 --> 00:50:12.340
Now, if you don't specify one point
by one point interior region,

00:50:12.580 --> 00:50:14.910
what we'll actually do is
tile the interior region.

00:50:14.910 --> 00:50:17.720
And tiling is a little less
efficient than stretching.

00:50:17.720 --> 00:50:18.650
So it'll work.

00:50:18.650 --> 00:50:23.920
It might be about 20 percent slower and
it takes--uses up a little more memory.

00:50:23.920 --> 00:50:26.930
So resizable images can
also be used for tiling.

00:50:26.970 --> 00:50:30.990
Again, the guidelines for tiling
resizable images are the

00:50:31.000 --> 00:50:33.220
same as with pattern images.

00:50:33.290 --> 00:50:36.770
If you can specify the edge insets
to be zero and the size--the width

00:50:36.770 --> 00:50:39.840
and height to be powers of two,
that's going to be the maximum

00:50:39.920 --> 00:50:43.040
speed that you'll get out
of a tiled resizable image.

00:50:43.100 --> 00:50:45.120
Otherwise,
you're going to go down a generalized

00:50:45.240 --> 00:50:49.960
path that may be about 20 percent
slower and use a little more memory.

00:50:50.060 --> 00:50:51.820
So to summarize,
if you're using resizable

00:50:51.820 --> 00:50:54.860
image with cap insets,
try to make sure the interior

00:50:54.980 --> 00:50:58.820
region is one point by one point
if you just want stretching.

00:50:59.000 --> 00:51:00.540
That always is fast.

00:51:00.540 --> 00:51:04.330
I didn't go over this,
but if you just want to set the

00:51:04.340 --> 00:51:09.740
interior region to say one by N and
your image view is N points high,

00:51:09.760 --> 00:51:11.270
that also is efficient.

00:51:11.270 --> 00:51:13.890
And if you want the
most efficient tiling,

00:51:13.900 --> 00:51:18.400
make sure your edge insets are zero and
the width and height are power of two.

00:51:18.420 --> 00:51:21.440
Finally,
let's go over some performance guidelines

00:51:21.440 --> 00:51:23.660
for smooth animation performance.

00:51:24.040 --> 00:51:25.930
And the first guideline which
you've probably heard over the

00:51:25.930 --> 00:51:27.040
years is to reduce blending.

00:51:27.040 --> 00:51:30.680
And the reason why this is
important is the GPU can only

00:51:30.780 --> 00:51:35.510
perform so many pixel operations
per frame at 60 frames per second.

00:51:35.710 --> 00:51:40.020
And a non-opaque pixel means
that we have to blend that pixel

00:51:40.020 --> 00:51:43.030
against all the pixels below it,
which increases the number

00:51:43.030 --> 00:51:44.270
of pixel operations.

00:51:44.330 --> 00:51:48.860
So you really want to make sure
every--as much of your view hierarchy

00:51:48.860 --> 00:51:53.300
is green as possible and when you
use this color blended layers option.

00:51:53.380 --> 00:51:56.210
So green means opaque,
red means non-opaque,

00:51:56.400 --> 00:52:00.760
the redder it is means more
and more layers of non-opaque.

00:52:00.790 --> 00:52:05.090
So in this case,
we've got about one layer of opaque

00:52:05.100 --> 00:52:09.780
views and about three quarters
of a layer of non-opaque views.

00:52:09.780 --> 00:52:14.210
So we've got about three quarters of a
screen's worth of overdraw in this case.

00:52:14.250 --> 00:52:17.400
And you really want to be
minimizing overdraw to be,

00:52:17.580 --> 00:52:20.540
say, less than one and a half screens
at most for good performance.

00:52:20.800 --> 00:52:21.420
So you want to be minimizing
overdraw to be less than one and

00:52:21.420 --> 00:52:23.400
a half screens at most for good
performance on all iOS devices.

00:52:23.480 --> 00:52:25.390
How do you make your views opaque?

00:52:25.610 --> 00:52:28.770
Well, if you override draw rect,
then make sure that your

00:52:28.890 --> 00:52:30.230
UI view is marked opaque.

00:52:30.570 --> 00:52:33.180
It is by default,
but as I went over earlier,

00:52:33.210 --> 00:52:36.880
if you change certain properties
like setting a background

00:52:36.880 --> 00:52:40.550
color with non-one alpha,
we're going to flip that opaque

00:52:40.680 --> 00:52:42.780
property for you behind your back.

00:52:42.900 --> 00:58:24.600
[Transcript missing]
WEBVTT

00:00:11.030 --> 00:00:12.000
Welcome.

00:00:12.000 --> 00:00:15.530
This is Making the Most of
Multi-Touch on iOS,

00:00:15.720 --> 00:00:17.860
Section 118.

00:00:17.860 --> 00:00:19.400
And I'm Ken Kocienda.

00:00:19.400 --> 00:00:20.150
And again, welcome.

00:00:20.150 --> 00:00:21.590
Thanks for coming.

00:00:21.700 --> 00:00:28.310
So, this talk is, as the title suggests,
about iOS Multi-Touch,

00:00:28.670 --> 00:00:32.670
the wonderful direct manipulation
system we have on iOS devices.

00:00:32.760 --> 00:00:37.230
It's a natural and fun interaction model.

00:00:37.440 --> 00:00:40.000
Get wonderful visual effects like this.

00:00:40.010 --> 00:00:44.470
Users really feel good about interacting
with apps when they behave like this,

00:00:44.490 --> 00:00:46.200
like things they're familiar
with from the real world.

00:00:47.840 --> 00:00:50.310
Keyboards, of course,
also familiar with in the real world,

00:00:50.440 --> 00:00:52.400
great apps like GarageBand.

00:00:52.400 --> 00:00:56.700
And then, you know, you can have fun with
apps like Photo Booth,

00:00:57.220 --> 00:00:57.470
right?

00:00:57.480 --> 00:01:01.520
So great examples of using
Multi-Touch in Apple's apps.

00:01:01.520 --> 00:01:03.470
But of course, this,
why you're here today,

00:01:03.470 --> 00:01:06.790
and why we're having this conference
is we're all interested in your apps.

00:01:07.580 --> 00:01:12.570
So the talk is about how to make the
best use of Multi-Touch in your apps.

00:01:12.570 --> 00:01:15.470
And hopefully,
I'll give you some ideas to

00:01:15.470 --> 00:01:19.070
help you direct your effort,
get the most out of your effort,

00:01:19.130 --> 00:01:20.530
the most out of your development time.

00:01:20.540 --> 00:01:24.610
And to do that,
I've got four big ideas that I'd

00:01:24.610 --> 00:01:28.060
like to go over during the session.

00:01:29.790 --> 00:01:34.960
First, just a brief introduction,
some kind of an overview of Multi-Touch

00:01:34.960 --> 00:01:37.690
strategies from a high level.

00:01:38.060 --> 00:01:42.120
And then we'll get into some touch system
concepts so that you understand what

00:01:42.220 --> 00:01:46.770
happens when touches come down in the
screen and the whole lifetime of a touch

00:01:46.960 --> 00:01:50.120
while the user is contacting the screen.

00:01:50.860 --> 00:01:53.510
And then thirdly,
some touch system tasks,

00:01:53.520 --> 00:01:57.450
so how you can get in there and
customize that whole process to

00:01:57.450 --> 00:01:59.600
do what you want in your app.

00:01:59.600 --> 00:02:01.670
And then finally,

00:02:02.070 --> 00:02:07.400
How to interact with the rest of iOS
and other apps running on the system,

00:02:07.400 --> 00:02:12.040
of course with special attention to
touch and touch APIs and frameworks,

00:02:12.040 --> 00:02:12.560
etc.

00:02:12.560 --> 00:02:17.870
So now, a quick word though,
is that we've got all of our sessions

00:02:17.880 --> 00:02:20.960
from last year's WWDC on iTunes U.

00:02:20.960 --> 00:02:23.670
If you're particularly
interested in this material,

00:02:23.670 --> 00:02:27.110
and I guess maybe you are at least
to some degree since you're here,

00:02:27.200 --> 00:02:30.110
there are two really,
really interesting sessions that

00:02:30.110 --> 00:02:33.120
you can go back and look at from
last year if you didn't see these.

00:02:33.120 --> 00:02:35.600
Gesture recognition and
advanced gesture recognition.

00:02:35.600 --> 00:02:38.410
Now,
this is not a repeat of those sessions.

00:02:38.410 --> 00:02:41.460
It's new material,
but there's quite a bit of overlap.

00:02:41.460 --> 00:02:46.720
And so, if you like this talk,
you'll love those.

00:02:46.720 --> 00:02:47.400
How about that?

00:02:47.440 --> 00:02:49.600
So, go back and take a look at those.

00:02:49.600 --> 00:02:50.800
Some good information.

00:02:50.960 --> 00:02:51.260
There's a lot of
information in there too.

00:02:51.260 --> 00:02:55.430
But today,
we've got those four big ideas.

00:02:55.490 --> 00:02:56.860
So, let's get started.

00:02:58.530 --> 00:03:00.260
Multi-Touch strategies.

00:03:00.260 --> 00:03:03.640
I like to think that there
are four general approaches to

00:03:03.640 --> 00:03:08.500
handling Multi-Touch on iOS.

00:03:08.500 --> 00:03:13.850
And the first is you can
ignore it altogether.

00:03:14.000 --> 00:03:18.400
Simple apps, particularly on the phone,
but also on the iPad.

00:03:18.400 --> 00:03:21.700
If you've got an
information app like Stocks,

00:03:21.820 --> 00:03:23.720
you're just ignoring Multi-Touches.

00:03:23.720 --> 00:03:26.180
It's really just a
single-touch interaction.

00:03:26.180 --> 00:03:28.670
Of course,
you get some of the advantages,

00:03:28.670 --> 00:03:31.940
and there's plenty of material
in the talk that you can take

00:03:31.970 --> 00:03:36.180
advantage of if you've still got
just a single-touch application.

00:03:36.440 --> 00:03:39.760
But again,
the concept is you can just completely

00:03:39.760 --> 00:03:44.060
ignore Multi-Touches throughout your app.

00:03:44.290 --> 00:03:46.620
Another example,
sort of another approach,

00:03:46.630 --> 00:03:49.350
is that you can handle multiple
touches on the screen independently.

00:03:49.360 --> 00:03:54.360
Here's an app that I love, Bloom HD,
wonderful music-making app.

00:03:54.430 --> 00:03:57.160
And the idea is you
touch down on the screen,

00:03:57.160 --> 00:03:58.760
and each of those
touches are independent.

00:03:58.760 --> 00:04:01.000
It's not like a gesture
or anything like that.

00:04:01.000 --> 00:04:03.300
Of course,
the touches do interact with each other,

00:04:03.300 --> 00:04:05.560
again, to make some wonderful music.

00:04:05.620 --> 00:04:09.340
But really,
the touches are independent from one

00:04:09.340 --> 00:04:12.290
another in terms of handling them.

00:04:13.780 --> 00:04:19.430
Then there's another example of sort of a
third strategy of having multiple touches

00:04:19.890 --> 00:04:22.380
interact with each other in this way.

00:04:22.410 --> 00:04:25.330
So we've got one finger on
the keyboard and going in and

00:04:25.400 --> 00:04:27.880
moving that pitch control.

00:04:28.050 --> 00:04:31.360
At some level in your program,
those touches should

00:04:31.360 --> 00:04:33.090
know about each other.

00:04:33.300 --> 00:05:03.600
[Transcript missing]

00:05:05.070 --> 00:05:09.200
And so those are the
four basic strategies.

00:05:09.320 --> 00:05:11.930
And I think probably what's
pretty common too is that you

00:05:11.930 --> 00:05:13.060
wind up with a mix and match.

00:05:13.110 --> 00:05:15.820
I mean, even if you have, say,
a Multi-Touch game,

00:05:15.820 --> 00:05:18.200
entering into the game isn't Multi-Touch,
right?

00:05:18.200 --> 00:05:21.000
You're just pressing the button,
it's single touch.

00:05:21.050 --> 00:05:24.420
So this kind of mix and match strategy
will happen throughout your app.

00:05:24.500 --> 00:05:27.500
Now, I like to think when I'm
designing an app that I know,

00:05:27.500 --> 00:05:30.500
at least in some level,
maybe it's just even subconscious,

00:05:30.560 --> 00:05:34.500
which of these strategies is being
employed at a particular time.

00:05:34.540 --> 00:05:37.000
And when I might be
transitioning to something else.

00:05:37.110 --> 00:05:41.080
So, you know, even maybe if you're
prototyping a new app,

00:05:41.080 --> 00:05:43.500
you might even want to think about
these things at a high level.

00:05:43.500 --> 00:05:45.490
Are we going to be doing multiple touch?

00:05:45.530 --> 00:05:50.500
How might Multi-Touch help you at a
particular spot in the app or not?

00:05:50.500 --> 00:05:54.000
You might ignore multiple touches,
because that just might be better.

00:05:54.090 --> 00:05:56.000
So again, kind of thinking about
it at a high level,

00:05:56.000 --> 00:06:00.490
I think it's a good idea to know
which one of these strategies

00:06:00.500 --> 00:06:02.980
you're using at a particular time.

00:06:04.780 --> 00:06:10.180
So again, that's pretty high-level
introduction about Multi-Touch.

00:06:10.310 --> 00:06:12.880
So now to kind of get into, well,
how do you make that work?

00:06:12.950 --> 00:06:15.190
Now you've decided on
one of those strategies,

00:06:15.300 --> 00:06:17.400
how do you actually go
ahead and implement?

00:06:17.400 --> 00:06:21.310
And so that's what this
section begins to talk about,

00:06:21.310 --> 00:06:23.210
touch system concepts.

00:06:25.820 --> 00:06:30.100
And so if you're new to iOS development,
these are the,

00:06:30.170 --> 00:06:31.520
this is the cast of characters.

00:06:31.580 --> 00:06:35.560
These are the classes that you
need to know about in order to

00:06:35.640 --> 00:06:37.700
make the best use of Multi-Touch.

00:06:37.800 --> 00:06:40.870
Right, a couple of that you
might not think about,

00:06:40.870 --> 00:06:45.250
like UI application, UI window,
UI view controller, and so forth.

00:06:45.350 --> 00:06:48.090
So we've got really
wonderful documentation,

00:06:48.100 --> 00:06:49.800
really great sample code.

00:06:49.940 --> 00:06:52.790
Again, if you're new to iOS development,
these are the classes that

00:06:52.790 --> 00:06:53.800
you should know about.

00:06:53.800 --> 00:06:57.800
You should be able to describe,
maybe even just to yourself,

00:06:57.800 --> 00:07:01.930
how these classes contribute to
the whole Multi-Touch system in

00:07:01.930 --> 00:07:03.800
order to make the best use of it.

00:07:05.350 --> 00:07:07.790
And of course I'll be talking
a lot more about these classes

00:07:07.790 --> 00:07:11.180
as the session goes on.

00:07:11.390 --> 00:07:14.220
So let's begin doing that and
talk about touch processing,

00:07:14.220 --> 00:07:17.880
kind of a simple example
of touch processing.

00:07:17.990 --> 00:07:22.740
So I wrote a demo app which I'll be
using a few times during the session,

00:07:22.740 --> 00:07:26.240
kind of a simple app which puts
some shapes up on the screen,

00:07:26.280 --> 00:07:30.390
and you can just drag them around,
direct manipulation,

00:07:30.440 --> 00:07:33.440
kind of manipulate them
with some gestures as well.

00:07:33.920 --> 00:07:36.410
And so the first thing that I'd
like to do with this sample app

00:07:36.510 --> 00:07:40.730
is to look at some just very,
very basic single-touch processing

00:07:41.290 --> 00:07:44.670
using these four touch handlers.

00:07:44.860 --> 00:07:47.680
So let's do a demo.

00:07:47.910 --> 00:07:51.960
So now, here I am in Xcode,
and so those shapes that

00:07:52.010 --> 00:07:56.260
you saw on the screen are
implemented with this shape class.

00:07:56.630 --> 00:07:58.180
Very, very simple class.

00:07:58.200 --> 00:08:05.800
It's just a UIView subclass that
you'll see just does some pretty simple

00:08:05.890 --> 00:08:11.790
drawing to implement different shapes.

00:08:11.900 --> 00:08:31.600
[Transcript missing]

00:08:32.410 --> 00:08:35.050
And you'll see that in the touches move,
sort of where the action happens,

00:08:35.090 --> 00:08:38.180
where the kind of the
direct manipulation happens.

00:08:38.400 --> 00:08:41.640
I'm just going and getting the
point that corresponds to a touch,

00:08:41.770 --> 00:08:44.790
and I'm using it to just
move the shape around,

00:08:44.800 --> 00:08:48.120
changing the center point of
the shape using the data that's

00:08:48.390 --> 00:08:50.580
coming through from the touch.

00:08:50.600 --> 00:08:51.920
So let's build this.

00:08:51.920 --> 00:08:55.000
Have a look on the iPad.

00:08:55.000 --> 00:08:57.690
Okay, so I've just got a simple
shape on the screen,

00:08:57.690 --> 00:09:01.200
and if I go and touch it,
you'll see that I'm tracking my touch.

00:09:01.580 --> 00:09:05.540
So if I touch with lots of fingers,
you'll see that where it

00:09:05.540 --> 00:09:07.370
is that I'm doing that.

00:09:07.470 --> 00:09:09.620
But now you see I'm just
going with one touch,

00:09:09.620 --> 00:09:12.830
and I'm moving around,
and the shape is kind of giving little

00:09:12.830 --> 00:09:16.840
updates on which of those handlers is
getting called at a particular time.

00:09:16.840 --> 00:09:18.500
You'll see that touch has began.

00:09:18.500 --> 00:09:21.560
If I can hold my finger steady,
if I move it at all, it changes.

00:09:21.560 --> 00:09:22.650
The touch has moved.

00:09:22.650 --> 00:09:24.420
It began, moved, and ended.

00:09:24.420 --> 00:09:26.820
And of course, if I do another one,
of course,

00:09:26.820 --> 00:09:28.640
that yellow one doesn't change.

00:09:28.640 --> 00:09:30.820
I'm just getting the
touches coming through.

00:09:30.820 --> 00:09:30.910
Okay.

00:09:31.520 --> 00:09:33.220
And then the shape that I'm touching.

00:09:33.220 --> 00:09:35.320
Of course, very, very simple, right?

00:09:35.320 --> 00:09:37.180
But of course, this is the first example.

00:09:37.180 --> 00:09:43.070
So let's go back and talk a little
bit about what's happening to

00:09:43.070 --> 00:09:46.320
have those handlers be called.

00:09:46.360 --> 00:09:49.420
What's the life cycle of
those touches such that it

00:09:49.420 --> 00:09:53.890
actually winds up coming out,
resulting in a callback in your code?

00:09:55.350 --> 00:09:58.100
So, there's a timeline for a touch.

00:09:58.130 --> 00:10:01.060
When a touch comes down on the screen,
we have this cycle.

00:10:01.060 --> 00:10:04.360
You kind of like think about
it along a series of steps.

00:10:04.440 --> 00:10:09.260
We already saw a series of steps,
but let's kind of go in and talk about

00:10:09.260 --> 00:10:15.580
one important step which happens before
you wind up getting your touch callbacks.

00:10:15.580 --> 00:10:18.260
And that's this,
finding the hit test view.

00:10:18.720 --> 00:10:22.240
So, this happens at the very,
very moment that a touch

00:10:22.240 --> 00:10:24.160
comes down on the display.

00:10:24.160 --> 00:10:29.480
The first thing that happens
is the whole OS goes and finds

00:10:29.480 --> 00:10:33.460
which touch is under your finger.

00:10:33.480 --> 00:10:35.520
All right,
this is special work for UI application.

00:10:35.550 --> 00:10:37.260
It's not something you
need to worry about.

00:10:37.260 --> 00:10:39.350
It's something we need to
worry about as the OS provider,

00:10:39.460 --> 00:10:40.720
as the framework provider.

00:10:40.720 --> 00:10:43.860
So, in UI application,
what it does is it goes and it

00:10:43.860 --> 00:10:48.480
finds the deepest view in the entire
view hierarchy in the application.

00:10:48.720 --> 00:10:50.020
that's under your touch.

00:10:50.020 --> 00:10:52.000
The very, very deepest view.

00:10:54.550 --> 00:10:57.640
Okay, finds that view.

00:10:57.750 --> 00:11:01.190
And it's all about view containment,
right?

00:11:01.300 --> 00:11:03.880
It has nothing to do
with first responder.

00:11:03.900 --> 00:11:05.520
I mean, if you're coming from
the Mac development,

00:11:05.520 --> 00:11:08.380
you kind of think about that
event handling is tied up with the

00:11:08.780 --> 00:11:10.530
responder chain and first response.

00:11:10.540 --> 00:11:12.620
That's not what happens with touches.

00:11:12.620 --> 00:11:14.390
It's all about view containment.

00:11:14.390 --> 00:11:16.980
It's all about taking that
touch and finding out which

00:11:16.980 --> 00:11:18.720
view is underneath your finger.

00:11:20.810 --> 00:11:25.160
Okay, and once this happens,
once this determination is made,

00:11:25.310 --> 00:11:30.040
that touch and that view are linked
for the remainder of the lifetime

00:11:30.040 --> 00:11:31.790
of that touch on the screen.

00:11:31.800 --> 00:11:35.610
If you move that, move that touch around,
right,

00:11:35.880 --> 00:11:40.780
the same hit test view and that touch,
they remain linked together.

00:11:40.810 --> 00:11:42.790
Now why is that important?

00:11:42.900 --> 00:11:45.800
Well,
because now we start delivering events,

00:11:45.800 --> 00:11:46.800
and where do the events go?

00:11:46.800 --> 00:11:48.790
Well,
the events go to that hit test view.

00:11:48.800 --> 00:11:53.190
Okay, so once that touch comes down,
hit test view is determined,

00:11:53.250 --> 00:11:55.620
and now we start delivering events.

00:11:55.800 --> 00:12:01.880
All right, event delivery is all about
UI application and UI window send event.

00:12:02.530 --> 00:12:07.200
And the hit test view winds up
receiving the event as part of

00:12:07.490 --> 00:12:11.760
this sort of built-in method that,
again, is part of the framework,

00:12:11.870 --> 00:12:14.330
part of what we provide to you.

00:12:15.070 --> 00:12:19.510
And of course, as we saw in the code,
right, as the label updated in the shape,

00:12:19.520 --> 00:12:23.850
touches began, right,
because that's the stage that we're at.

00:12:24.040 --> 00:12:26.580
The touch just came down.

00:12:27.830 --> 00:12:30.840
Okay,
so now subsequently the touch moves.

00:12:30.870 --> 00:12:32.000
Well, guess what?

00:12:32.030 --> 00:12:33.920
We don't have to go through
that first step again.

00:12:33.920 --> 00:12:37.810
There is no re-running of that
hit test view determination,

00:12:37.810 --> 00:12:39.340
right, because the touch and
the view are linked,

00:12:39.340 --> 00:12:40.860
again, for the whole life of the touch.

00:12:40.860 --> 00:12:42.580
So this process just runs again.

00:12:42.580 --> 00:12:44.330
Only a different method gets called.

00:12:44.330 --> 00:12:46.100
Touch is moved gets called instead.

00:12:49.110 --> 00:12:52.490
And then afterwards when
your touch finally lifts,

00:12:52.660 --> 00:12:54.100
again, it's simple.

00:12:54.320 --> 00:12:57.590
The view just continues to get
delivered to the same place

00:12:57.590 --> 00:12:59.300
that it has been all along.

00:12:59.300 --> 00:13:00.670
Touch is ended.

00:13:01.430 --> 00:13:04.840
So now if we back up a step,
and if something else happens,

00:13:04.840 --> 00:13:09.190
touch canceled, if you're on, say,
an iPhone, or if you're on an iPad,

00:13:09.190 --> 00:13:15.730
or an iPod Touch, any iOS device,
if you've got a touchdown on the

00:13:15.790 --> 00:13:19.330
screen and say you get an alert,
well, your application is going

00:13:19.330 --> 00:13:21.000
to get touches canceled.

00:13:21.000 --> 00:13:23.960
And you should really have an
implementation of touches canceled.

00:13:23.960 --> 00:13:25.540
I'll talk more about that later.

00:13:25.540 --> 00:13:28.300
But you really,
really should think through what it

00:13:28.300 --> 00:13:32.430
means when the rest of the system
sort of... interrupts your touches.

00:13:34.150 --> 00:13:35.280
Okay, so that's it.

00:13:35.280 --> 00:13:36.560
I mean, it really is pretty simple.

00:13:36.560 --> 00:13:40.290
Once you get these two concepts, right,
it's that two-step process.

00:13:40.470 --> 00:13:42.620
Finding the hit test view
right when the touch starts,

00:13:42.770 --> 00:13:45.460
and then event delivery
happens from there.

00:13:45.460 --> 00:13:51.430
So now, what about processing a gesture,
like a pinch gesture, zoom gesture,

00:13:51.430 --> 00:13:55.810
right, a long press gesture,
any of the gestures that are

00:13:55.900 --> 00:14:00.270
built into UIKit or any that
you've implemented yourself?

00:14:00.820 --> 00:14:04.680
You might have a question:
"Touch handlers or gestures,

00:14:04.680 --> 00:14:07.790
which one are you supposed
to use?" I just did this

00:14:07.790 --> 00:14:10.770
direct manipulation example,
but there's also a pan

00:14:10.770 --> 00:14:12.160
gesture recognizer.

00:14:12.250 --> 00:14:15.920
So which one should you use?

00:14:15.990 --> 00:14:19.460
There are certain situations
where gesture recognizers,

00:14:19.460 --> 00:14:21.390
I think, are clearly better.

00:14:21.490 --> 00:14:25.810
And this is an example when
you're trying to deliver kind

00:14:25.810 --> 00:14:30.960
of a standard gesture that users
have come to expect from iOS apps,

00:14:30.960 --> 00:14:32.400
like pinch to zoom.

00:14:32.400 --> 00:14:36.320
You should definitely use the pinch
gesture recognizer to implement pinch,

00:14:36.360 --> 00:14:38.640
or just take advantage
of it in scroll view,

00:14:38.640 --> 00:14:42.050
UI scroll view, if you're using that.

00:14:45.660 --> 00:14:47.860
may want to come along, and if your app,
you've got maybe a

00:14:47.860 --> 00:14:49.890
little text editing app,
and you want to implement

00:14:49.890 --> 00:14:51.630
a custom gesture,
sort of a little rub-out

00:14:51.630 --> 00:14:55.440
gesture to delete some text,
that might also be a really good idea

00:14:55.440 --> 00:14:59.660
to implement as a gesture recognizer,
rather than just touch handlers.

00:14:59.660 --> 00:15:02.440
Because, again,
gesture recognizers let you

00:15:02.500 --> 00:15:06.450
encapsulate the behavior of that
movement in such a way that you kind

00:15:06.450 --> 00:15:08.430
of deal with it in all one thing.

00:15:08.440 --> 00:15:10.520
You don't have to kind
of sprinkle that around,

00:15:10.520 --> 00:15:13.550
sprinkle that code around in touch
handlers and all of the views which

00:15:13.560 --> 00:15:15.380
may want to implement that gesture.

00:15:18.120 --> 00:15:22.390
So that's two sort of reasons why
gesture recognizers might be better.

00:15:22.390 --> 00:15:24.400
A reason why touch handlers
really might be better,

00:15:24.400 --> 00:15:27.170
even in sophisticated cases,
is if you're porting software

00:15:27.170 --> 00:15:28.230
from another platform.

00:15:28.240 --> 00:15:31.050
Let's say you've got a drawing
app that you're bringing over

00:15:31.050 --> 00:15:34.190
to iOS from someplace else,
and you probably don't have

00:15:34.190 --> 00:15:38.500
gesture recognizers or anything
like them in that existing code.

00:15:38.500 --> 00:15:42.190
And so maybe the quickest and easiest way
to get your code up and running would be

00:15:42.190 --> 00:15:46.060
to just kind of hook it up to those touch
handlers like I just showed in the demo.

00:15:46.560 --> 00:15:48.260
Again,
it's just the quickest and easiest way.

00:15:48.260 --> 00:15:51.300
You might do something different for 2.0,
sort of do rethink,

00:15:51.300 --> 00:15:54.660
but to getting up and running,
touch handlers might really be just the

00:15:54.660 --> 00:15:56.820
simplest and easiest way for you to go.

00:15:59.910 --> 00:16:02.490
So is it really this kind of six
or half dozen thing with touch

00:16:02.540 --> 00:16:04.360
handlers and gesture recognizers?

00:16:04.490 --> 00:16:06.700
Well, you know,
in some respects it really does come

00:16:06.730 --> 00:16:10.120
down to a matter of personal preference,
which style you like better.

00:16:10.120 --> 00:16:13.640
Maybe you've already got existing code,
again, like that porting example.

00:16:13.750 --> 00:16:17.300
But what I hope, in some other examples
I've got coming up,

00:16:17.360 --> 00:16:21.230
I'll show you that there really are some
sort of subtle points which will help

00:16:21.230 --> 00:16:26.330
you to decide which one might be better,
depending on the kind of the details of

00:16:26.330 --> 00:16:29.230
the behavior that you want to deliver.

00:16:29.900 --> 00:16:34.130
So, what about processing a gesture,
kind of stepping through that in

00:16:34.130 --> 00:16:35.620
the same way as processing touch?

00:16:35.620 --> 00:16:37.390
So I've got a demo for that.

00:16:37.390 --> 00:16:45.190
So, gesture processing demo,
and let's see.

00:16:48.980 --> 00:16:51.900
Okay.

00:16:51.980 --> 00:16:59.390
So now, what I'd like to do is
I'd like to add a pinch

00:16:59.500 --> 00:17:16.100
[Transcript missing]

00:17:16.540 --> 00:17:19.960
So I just go and I allocate
and initialize a pinch gesture

00:17:20.020 --> 00:17:22.590
recognizer and just add it to self.

00:17:22.590 --> 00:17:25.420
And then I go and I set a target.

00:17:27.660 --> 00:17:32.850
So I've got a pinch handler,
and in many ways a pinch handler is very,

00:17:32.850 --> 00:17:34.460
very similar to touch handlers.

00:17:34.490 --> 00:17:39.510
I've got these state callbacks coming in,
and you'll see sort of, again,

00:17:39.520 --> 00:17:41.930
just like in the touches
moved example from before,

00:17:41.940 --> 00:17:47.000
the real action is going on in
UI gesture recognizer state changed,

00:17:47.010 --> 00:17:53.320
where I take the state of
the pinch and I just go and

00:17:53.320 --> 00:17:53.320
set a transform on the view.

00:17:53.390 --> 00:17:56.790
Okay, so now just like before, again,
this is really unchanged.

00:17:56.840 --> 00:18:01.540
I can, you know, move this around,
but now also I can go in and touch

00:18:01.540 --> 00:18:05.270
and pinch the view to zoom it around,
and of course I can still

00:18:05.270 --> 00:18:06.740
move it subsequently.

00:18:06.840 --> 00:18:08.180
Okay?

00:18:08.190 --> 00:18:10.180
So that's really pretty simple.

00:18:10.180 --> 00:18:13.270
Of course, again, if I, you know,
have a second one,

00:18:13.380 --> 00:18:14.820
of course the first one is unaffected.

00:18:14.820 --> 00:18:18.420
It just doesn't get any calls
back or anything like that.

00:18:18.490 --> 00:18:22.480
Okay, so now if I go back to the code,

00:18:24.010 --> 00:18:31.960
You'll see that what I did, of course,
was add the pinch to...

00:18:32.240 --> 00:18:33.380
The shape itself.

00:18:33.510 --> 00:18:36.380
But wouldn't it be kind of cool
if I could just go out into sort

00:18:36.380 --> 00:18:40.670
of empty area where there isn't
a shape and pinch to zoom all

00:18:40.670 --> 00:18:42.070
of the shapes at the same time?

00:18:42.370 --> 00:18:44.900
So let's take a look at that.

00:18:44.900 --> 00:18:49.690
So instead of putting the pinch
gesture recognizer in the shape,

00:18:49.850 --> 00:18:55.300
I'm going to go and put
the gesture recognizer in

00:18:56.480 --> 00:19:00.400
A view controller class,
because now there is a view

00:19:00.400 --> 00:19:04.280
which of course contains those
couple of shapes that I've had,

00:19:04.380 --> 00:19:06.670
and there's a view controller
associated with that view.

00:19:06.810 --> 00:19:11.310
So I can go and put the gesture
recognizer on that view controller,

00:19:11.610 --> 00:19:16.100
assign it to the view controller's view,
and sort of get this sort

00:19:16.100 --> 00:19:17.940
of higher level effect.

00:19:18.020 --> 00:19:21.760
Right, so you'll see that I'm taking a
pinch gesture recognizer in the

00:19:21.760 --> 00:19:23.660
view controller's viewDidLoad,

00:19:24.080 --> 00:19:27.880
I've got that content view
associated with the view controller,

00:19:27.940 --> 00:19:30.380
which is again what is
containing all of those shapes,

00:19:30.380 --> 00:19:33.430
and that's where I add the
pinch gesture recognizer.

00:19:33.540 --> 00:19:38.370
And you'll see, sort of like before,
it winds up being very,

00:19:38.370 --> 00:19:42.450
very similar in the
UI gesture recognizer change.

00:19:42.760 --> 00:19:48.020
The only thing is now I'm stepping
through all of the shapes that are

00:19:48.480 --> 00:19:51.770
there and transforming each one in turn.

00:19:53.660 --> 00:19:55.440
So let's take a look at that.

00:19:55.560 --> 00:20:00.330
So now you'll see if I go and
just pinch out an empty area,

00:20:00.340 --> 00:20:05.940
I've got that sort of status update
happening in the top of the view.

00:20:06.010 --> 00:20:09.960
And if I add a couple more shapes,
you'll see that I can also do this.

00:20:09.960 --> 00:20:13.060
Now, there's a kind of a really
interesting interaction which

00:20:13.060 --> 00:20:16.780
I'd like to show you now,
which is I can drag this view around

00:20:17.340 --> 00:20:23.270
and then land a finger afterwards,
long afterwards,

00:20:23.450 --> 00:20:25.400
long after I've moved the view.

00:20:25.400 --> 00:20:30.510
And the pinch gesture recognizer for
the view controller will kick in.

00:20:30.510 --> 00:20:32.200
So again, let's look at that again.

00:20:32.200 --> 00:20:33.430
I can move this around.

00:20:33.510 --> 00:20:35.520
I've just got one touch on the screen.

00:20:35.520 --> 00:20:39.800
I can land a second touch
later and start pinching.

00:20:40.960 --> 00:20:42.240
It's pretty interesting.

00:20:42.320 --> 00:20:46.230
And what that means, of course,
is that somehow those touch

00:20:46.230 --> 00:20:50.320
handlers in the shape,
touches began, move change ended,

00:20:50.450 --> 00:20:55.030
and the pinch gesture
recognizer callbacks are somehow

00:20:55.030 --> 00:20:56.740
cooperating with each other.

00:20:57.090 --> 00:20:57.900
Right?

00:20:58.020 --> 00:20:59.900
One of them starts,
but then the other one can take over.

00:20:59.900 --> 00:21:02.130
So that's kind of an
interesting interaction,

00:21:02.250 --> 00:21:03.810
and I think it's worth going over.

00:21:03.970 --> 00:21:06.040
So let's talk about that.

00:21:08.970 --> 00:21:12.120
Okay,
so now really kind of focusing in on

00:21:12.120 --> 00:21:15.420
that last case of processing the gesture.

00:21:15.900 --> 00:21:21.820
So now, when touches come down and you've
got gesture recognizers in the mix,

00:21:21.940 --> 00:21:24.000
you've created some
and you've added some,

00:21:24.000 --> 00:21:27.300
so now this touch has come down, right?

00:21:27.320 --> 00:21:30.240
When that second touch came down,
not only did I find the hit

00:21:30.280 --> 00:21:33.250
test view for that second touch,
but I gathered up all the

00:21:33.250 --> 00:21:37.220
gesture recognizers which are
associated with the touches.

00:21:37.680 --> 00:21:38.640
And how does that happen?

00:21:38.640 --> 00:21:41.000
Well, again,
this is special work for UI application.

00:21:41.000 --> 00:21:50.670
This gesture gathering task starts
with the hit test view for each touch.

00:21:51.730 --> 00:21:54.120
And starting from that hit test view,
right,

00:21:54.120 --> 00:21:58.430
so we drill down to the deepest view in
the hierarchy to find the hit test view,

00:21:58.610 --> 00:22:02.440
this gesture gathering is now
sort of a bubbling back up.

00:22:02.510 --> 00:22:04.580
So starting from that view,
it goes and sees,

00:22:04.580 --> 00:22:07.520
have any gesture recognizer
been added to the hit test view?

00:22:07.620 --> 00:22:09.480
Well,
what about the hit test view super view?

00:22:09.600 --> 00:22:11.010
What about the hit test view super view?

00:22:11.190 --> 00:22:11.540
Right?

00:22:11.610 --> 00:22:13.610
All the way up.

00:22:14.300 --> 00:22:17.430
And they're kind of, you know,
added in order so that the deepest

00:22:17.430 --> 00:22:20.060
ones get added on a list first,
and the ones later,

00:22:20.060 --> 00:22:23.250
which were added up into views
higher in the view hierarchy,

00:22:23.300 --> 00:22:26.200
get added later.

00:22:26.500 --> 00:22:29.880
So again, this kind of gathering,
this kind of initial

00:22:29.880 --> 00:22:31.560
determination step goes on.

00:22:31.560 --> 00:22:34.820
Finding the hit test view,
gathering up all the gesture recognizers.

00:22:34.900 --> 00:22:36.430
Okay, right?

00:22:36.520 --> 00:22:39.960
And of course that priority,
the deepest view.

00:22:41.400 --> 00:22:48.200
[Transcript missing]

00:22:48.430 --> 00:22:51.030
Just like before, event delivery happens.

00:22:51.180 --> 00:22:55.010
But the difference is that
event delivery is two-tracked.

00:22:55.170 --> 00:22:56.050
We saw that.

00:22:56.400 --> 00:22:58.170
Event delivery is two-tracked.

00:22:58.330 --> 00:23:00.400
Touches and gestures are in the mix.

00:23:00.400 --> 00:23:01.740
Well, how does that happen?

00:23:01.740 --> 00:23:08.900
Gestures get tested for recognition,
and the hit test view receives events.

00:23:10.650 --> 00:23:17.190
Views get touches began if no
gesture has been recognized.

00:23:18.920 --> 00:23:22.000
So in the case of a pinch, right,
you can't pinch until your

00:23:22.000 --> 00:23:23.440
fingers start moving together.

00:23:23.440 --> 00:23:25.300
So that's really what happens here.

00:23:25.410 --> 00:23:30.150
I had that one touchdown,
and so the view got touches,

00:23:30.150 --> 00:23:32.770
touches began, and started moving around.

00:23:32.920 --> 00:23:36.850
But now, if touches move, right,
event delivery happens again.

00:23:36.930 --> 00:23:38.920
Of course, we don't do that first step,
just like before.

00:23:39.010 --> 00:23:41.920
We've already gathered touches and
done that hit test view determination.

00:23:41.920 --> 00:23:44.780
Event delivery is still two-tracked.

00:23:44.910 --> 00:23:48.120
But now, let's say, yes,
you did begin to move

00:23:48.120 --> 00:23:51.920
your fingers together,
and the gesture recognizes.

00:23:53.560 --> 00:23:58.900
Then, as we saw,
the View Got Touches cancelled.

00:23:58.960 --> 00:24:01.300
So that just continues to happen.

00:24:01.370 --> 00:24:04.160
As you are moving around,
all those gestures are recognizing

00:24:04.160 --> 00:24:06.590
until they fail to recognize.

00:24:06.700 --> 00:24:09.950
That pinch gesture requires two fingers,
it just kind of keeps going

00:24:10.030 --> 00:24:13.680
until such time as it recognizes
or of course the touches lift.

00:24:13.750 --> 00:24:20.020
But in this case, those two fingers did.

00:24:22.640 --> 00:24:25.660
caused the gesture to be
recognized and touch is canceled,

00:24:25.720 --> 00:24:26.030
got sent.

00:24:26.100 --> 00:24:28.730
Now the gesture runs its handler,
runs that pinch handler,

00:24:28.930 --> 00:24:32.610
and of course the scaling
takes place just as we saw.

00:24:36.630 --> 00:24:40.390
Okay,
so now touches move again after this,

00:24:40.530 --> 00:24:42.600
after this initial gesture recognition.

00:24:42.610 --> 00:24:45.540
Now event delivery is
just single-tracked,

00:24:45.540 --> 00:24:46.170
right?

00:24:46.280 --> 00:24:49.310
Touches are no longer
involved in the mix.

00:24:49.410 --> 00:24:54.140
Hit Test View will no
longer receive any events.

00:24:54.200 --> 00:24:56.690
Only the gesture will.

00:24:56.800 --> 00:24:57.800
gesture runs its handler.

00:24:57.800 --> 00:25:00.590
As we saw, you can scale all the views,
right?

00:25:00.630 --> 00:25:02.770
And touches lift.

00:25:03.060 --> 00:25:05.800
Again, it's the same from that point,
right?

00:25:05.840 --> 00:25:09.400
So we start out with this two-track

00:25:09.940 --> 00:25:12.960
Event delivery process.

00:25:12.960 --> 00:25:16.250
And if gesture recognizer,
we kind of go over to a single track.

00:25:16.320 --> 00:25:20.480
And at that point where that
changeover happens from being

00:25:20.520 --> 00:25:24.370
two-tracked to one-tracked,
your views will get touches cancelled.

00:25:24.370 --> 00:25:27.000
The hit test view will
get touches cancelled.

00:25:30.830 --> 00:25:34.990
So, as we see, we can, you know,
kind of going back to that idea of, well,

00:25:34.990 --> 00:25:37.280
does it really matter whether
you use gestures or touches?

00:25:37.300 --> 00:25:41.800
It really does matter depending
on the kind of behavior that you

00:25:41.800 --> 00:25:44.520
want your application to exhibit.

00:25:44.820 --> 00:25:47.870
Touch handlers and gestures
can really work together,

00:25:47.870 --> 00:25:50.410
work well together,
if you understand how the

00:25:50.410 --> 00:25:54.090
event delivery happens and how
they interact with each other.

00:25:54.330 --> 00:25:57.620
So that's touch system concepts.

00:25:57.650 --> 00:26:00.910
And so next,
going over to touch system tasks.

00:26:01.170 --> 00:26:06.720
How do we kind of get in there and change
some of these processes and procedures

00:26:06.770 --> 00:26:08.670
to customize them a little bit?

00:26:08.800 --> 00:26:12.680
And there's four topics
that I'd like to look at.

00:26:12.700 --> 00:26:16.040
So implementing direct manipulation,
a little bit more about that,

00:26:16.060 --> 00:26:19.210
picking an event handler using
the responder chain and using some

00:26:19.210 --> 00:26:22.300
details of gesture recognizers,
changing the event flow

00:26:22.400 --> 00:26:24.390
in interesting ways,
and then finally,

00:26:24.390 --> 00:26:26.160
some notes about subclassing.

00:26:26.200 --> 00:26:28.630
So about implementing
direct manipulation first.

00:26:28.750 --> 00:26:30.400
Of course, again, we've seen this, right?

00:26:30.400 --> 00:26:34.610
Touch handlers, you implement these touch
handlers in your view,

00:26:34.610 --> 00:26:39.180
and you can use those to respond
to touches appropriately.

00:26:39.180 --> 00:26:43.220
Gesture recognizers don't use these.

00:26:43.280 --> 00:26:44.230
They don't use them.

00:26:44.240 --> 00:26:48.820
If you've got a pan gesture recognizer,
or as we saw in the example,

00:26:48.820 --> 00:26:51.370
a pinch gesture recognizer,
you have to implement

00:26:51.370 --> 00:26:52.540
code that looks like this.

00:26:52.540 --> 00:26:58.100
A gesture recognizer callback,
which you set up using target action.

00:26:58.120 --> 00:27:00.600
When you allocate and initialize
your gesture recognizer,

00:27:00.600 --> 00:27:03.060
you set the target,
and you set an action method,

00:27:03.060 --> 00:27:05.160
and that action method
will look like this.

00:27:05.160 --> 00:27:08.870
And you'll get callbacks,
kind of with the gesture

00:27:08.870 --> 00:27:10.710
recognizer state machine.

00:27:12.430 --> 00:27:15.400
State-by-state doing
things as appropriate.

00:27:15.730 --> 00:27:16.380
Okay?

00:27:16.380 --> 00:27:19.550
So we'll take a look at another
example with that in a second,

00:27:19.550 --> 00:27:23.400
but first I'd like to talk
about picking an event handler.

00:27:24.320 --> 00:27:30.300
So now,
touches do not go to first responder,

00:27:30.390 --> 00:27:31.660
as we talked about before.

00:27:31.750 --> 00:27:34.980
Again, this is kind of a change
a little bit if you have

00:27:34.980 --> 00:27:37.750
experience developing on the Mac.

00:27:37.870 --> 00:27:40.090
But touches don't go to first responder.

00:27:40.210 --> 00:27:45.090
But you can still use the
responder chain if you wish.

00:27:45.120 --> 00:27:48.400
and have a higher level object
than the view that got touched.

00:27:48.400 --> 00:27:52.390
You can have a higher level
view handle the event.

00:27:52.500 --> 00:28:06.200
[Transcript missing]

00:28:06.890 --> 00:28:10.280
But you can take advantage, again,
of the whole responder chain.

00:28:10.300 --> 00:28:12.410
You can use a super view,
you can use the window,

00:28:12.410 --> 00:28:13.780
you can use the application.

00:28:13.870 --> 00:28:17.420
Now, I think as a kind of a general sort
of best practices sort of thing,

00:28:17.520 --> 00:28:21.680
kind of keeping your touch handling
down as close to the hit test view is

00:28:21.990 --> 00:28:25.350
probably what you want most of the time.

00:28:26.170 --> 00:28:27.850
of course these options
are available to you.

00:28:27.900 --> 00:28:31.560
And then of course really if we take
a look at the example that we have,

00:28:31.650 --> 00:28:33.530
we've also got a view
controller in the mix.

00:28:33.530 --> 00:28:36.580
View controllers do participate.

00:28:36.680 --> 00:28:40.330
They are a member of the responder chain,
so you can put touch

00:28:40.520 --> 00:28:42.540
handlers on view controllers.

00:28:44.120 --> 00:28:47.000
What about gestures and
the responder chain?

00:28:47.120 --> 00:28:52.310
Well, gestures don't use the
responder chain at all.

00:28:52.310 --> 00:28:52.310
At all.

00:28:52.450 --> 00:28:55.400
Again, gesture recognizers,
which ones recognize,

00:28:55.400 --> 00:29:02.140
it's all about that view containment and
that gesture gathering process related

00:29:02.440 --> 00:29:06.840
to which hit test view was determined,
and then gathering up gesture

00:29:06.840 --> 00:29:08.070
recognizers from there.

00:29:08.100 --> 00:29:11.080
So it's all about view containment,
not the responder chain.

00:29:11.860 --> 00:29:15.020
And of course,
gestures are attached to views, right?

00:29:15.020 --> 00:29:17.200
So they're attached to views,
this drill down and then

00:29:17.200 --> 00:29:20.000
come back up process,
and those gesture recognizers

00:29:20.010 --> 00:29:23.500
are attached to individual
views along the view hierarchy.

00:29:23.620 --> 00:29:27.680
And since gestures use target action,

00:29:29.200 --> 00:29:33.790
You can specify which handler
will respond and which object

00:29:33.790 --> 00:29:35.270
will implement that handler.

00:29:35.340 --> 00:29:37.760
You can implement, I think,
what's a pretty interesting pattern,

00:29:37.840 --> 00:29:40.830
which is a kind of a
gesture controller pattern.

00:29:41.010 --> 00:29:44.490
You might even have a whole new object.

00:29:45.670 --> 00:29:49.360
And that object's only
job is to respond to,

00:29:49.360 --> 00:29:54.760
you know,
be the target of gesture recognizers.

00:29:54.760 --> 00:29:56.230
This is not something
that I have in demos,

00:29:56.240 --> 00:29:59.910
but this is something that I've done,
kind of a... We've used the term

00:29:59.960 --> 00:30:05.280
interaction assistant quite a bit to
have that as an idea of a class that

00:30:05.650 --> 00:30:09.240
all that it does is sort of implement
a bunch of gesture recognizer handlers,

00:30:09.280 --> 00:30:13.560
kind of centralizing that event handling,
gesture recognition

00:30:13.600 --> 00:30:15.460
handling into one place.

00:30:15.520 --> 00:30:18.140
It's kind of an interesting idea,
maybe you want to think about it.

00:30:18.250 --> 00:30:23.520
So now let's take a look,
a demo of implementing direct

00:30:23.520 --> 00:30:26.750
manipulation a little bit more
and picking an event handler.

00:30:27.830 --> 00:30:33.200
So what I've done is
in the View Controller,

00:30:33.600 --> 00:30:36.590
You'll see that I still have
the pinch gesture recognizer

00:30:36.590 --> 00:30:40.570
handler up in the view controller,
but now I've taken the touches,

00:30:40.660 --> 00:30:45.010
the touch handling,
and moved it up to the view controller.

00:30:45.930 --> 00:30:49.040
And if we go and take
a look at the shape,

00:30:49.040 --> 00:30:52.820
you'll see that there is no
touch handling there at all.

00:30:52.890 --> 00:30:54.300
Here's where it was before.

00:30:54.460 --> 00:30:58.130
The touch handling is gone
from the shape completely.

00:30:58.190 --> 00:31:02.920
And this is kind of interesting because
now you can actually implement a view

00:31:02.920 --> 00:31:08.130
which doesn't have any sort of even a
little sort of controller-like behavior.

00:31:08.130 --> 00:31:11.940
It just really is a
visual representation.

00:31:12.300 --> 00:31:16.120
You're kind of passing along the
behavior to a higher level object.

00:31:16.230 --> 00:31:18.730
That's a really, I think,
a good reason for doing this,

00:31:18.830 --> 00:31:21.500
is the view is just about
visual representation.

00:31:21.500 --> 00:31:22.760
So let's take a look at this.

00:31:22.760 --> 00:31:26.780
You'll see that it winds up
behaving just like before,

00:31:26.780 --> 00:31:31.830
only I changed the little status message
there with the little sort of VC.

00:31:31.840 --> 00:31:36.090
You sort of see that the view
controller is the one responding,

00:31:36.100 --> 00:31:39.150
but in terms of from
the user's perspective,

00:31:39.150 --> 00:31:41.780
it behaves just like it did before.

00:31:41.780 --> 00:31:45.580
But it's sort of different
organization for you.

00:31:45.580 --> 00:31:49.370
This just might make more sense
for your program to implement touch

00:31:49.370 --> 00:31:51.820
handling in a higher level object.

00:31:51.900 --> 00:31:53.490
So now back to the code.

00:31:53.530 --> 00:31:57.820
What I'd like to do is now
come along and sort of restore,

00:31:57.820 --> 00:32:02.170
even though I pitched you
wonderfully on removing event

00:32:02.170 --> 00:32:07.080
handling from your low level,
so your leaf level view objects,

00:32:07.170 --> 00:32:11.260
I'd like to sort of go back and show
you that you can kind of do this.

00:32:11.260 --> 00:32:15.140
You can kind of do the same thing
as you do with touch handlers,

00:32:15.160 --> 00:32:18.790
but instead use a pan gesture recognizer.

00:32:19.400 --> 00:33:41.800
[Transcript missing]

00:33:42.340 --> 00:33:44.540
So that pinch gesture recognizer,
if you remember,

00:33:44.540 --> 00:33:46.750
was in the view controller's view.

00:33:46.850 --> 00:33:48.650
It's in a higher level view.

00:33:48.760 --> 00:33:52.290
The pan gesture recognizer
is on that deeper view.

00:33:52.310 --> 00:33:53.520
So it wins.

00:33:53.520 --> 00:33:58.050
And so that landing that second
finger later won't cause the pinch

00:33:58.090 --> 00:34:00.070
gesture recognizer to recognize.

00:34:00.070 --> 00:34:02.850
Whereas it did before,
because all we were using

00:34:02.850 --> 00:34:06.360
were touch handlers earlier,
right, in shapes.

00:34:06.480 --> 00:34:10.180
So that's kind of, again, a subtle point,
but this might help you to get

00:34:10.180 --> 00:34:13.320
the behavior that you want,
either one way or the other.

00:34:13.320 --> 00:34:15.300
You might want it one way or the other.

00:34:15.380 --> 00:34:20.450
But again, to try to figure out,
you know, how touches and gesture

00:34:20.450 --> 00:34:23.540
recognizers relate,
and then how multiple gesture

00:34:23.540 --> 00:34:25.200
recognizers relate to each other.

00:34:25.210 --> 00:34:25.880
Okay?

00:34:25.880 --> 00:34:28.180
I've got one more example.

00:34:30.300 --> 00:34:40.100
[Transcript missing]

00:34:42.990 --> 00:34:46.850
So if I add a shape,
I've got the pinch gesture recognizer

00:34:46.850 --> 00:34:50.210
now up on the view controller,
to do that pinch to

00:34:50.210 --> 00:34:52.400
scale all of the shapes.

00:34:52.550 --> 00:34:57.660
But now for each individual shape,
I can go and add a pan gesture

00:34:57.660 --> 00:35:02.040
recognizer to the shape,
so the shape view is still getting

00:35:02.690 --> 00:35:04.700
the gesture recognizer on it.

00:35:04.800 --> 00:35:05.700
But what is this illustrating?

00:35:05.700 --> 00:35:09.160
Again, it's kind of illustrating this
notion that I'm bringing the event

00:35:09.160 --> 00:35:13.580
handling up to a higher level object,
because even though I'm adding the

00:35:13.580 --> 00:35:19.800
gesture recognizer to the shape object,
to that leaf-level view object,

00:35:19.970 --> 00:35:24.750
the handler for the gesture is going
to be up in the view controller.

00:35:25.080 --> 00:35:28.920
So again, if I go over to the shape,
there's really nothing

00:35:28.920 --> 00:35:30.860
interesting in the shape at all.

00:35:30.860 --> 00:35:36.440
If you just looked at this shape code,
you wouldn't see anything that would

00:35:36.440 --> 00:35:41.890
lead you to believe that you can
actually act on the shape directly.

00:35:42.100 --> 00:35:43.490
But of course you can.

00:35:43.490 --> 00:35:44.690
So now I've got a shape.

00:35:44.960 --> 00:35:47.920
I've got now the pan gesture
recognizer being recognized

00:35:47.920 --> 00:35:49.400
up in the view controller.

00:35:49.690 --> 00:35:54.000
Again,
I can do the pinch to scale the shapes.

00:35:54.130 --> 00:35:56.880
And again,
it's that same behavior as before.

00:35:57.300 --> 00:36:02.260
One of them is winning,
and it prevents the other

00:36:02.260 --> 00:36:05.570
one from recognizing later.

00:36:07.560 --> 00:36:10.970
So, kind of some interesting details,
some interesting options

00:36:11.040 --> 00:36:12.540
about direct manipulation.

00:36:12.540 --> 00:36:14.140
I mean,
it kind of seems like a simple idea,

00:36:14.140 --> 00:36:17.190
but it does turn out that there are quite
a number of options for implementing it.

00:36:17.260 --> 00:36:19.550
Kind of getting very,
very similar behavior with

00:36:19.550 --> 00:36:21.170
some subtle differences,
again,

00:36:21.170 --> 00:36:24.640
depending on what you want and how you
set it up and pick an event handler.

00:36:28.020 --> 00:36:32.850
So now going on, the next step,
changing event flow.

00:36:32.920 --> 00:36:36.300
So pretty much, kind of a high-level idea
about changing event flow.

00:36:36.300 --> 00:36:40.860
Changing event flow is about changing
which view becomes the hit test view.

00:36:40.980 --> 00:36:45.030
Of course, again, because that's the view
that gets touch handlers,

00:36:45.030 --> 00:36:48.900
and that's also the starting point
for the gesture gathering process,

00:36:48.900 --> 00:36:51.810
which, of course,
matters quite a bit for which

00:36:51.860 --> 00:36:53.890
gestures will get recognized.

00:36:53.900 --> 00:36:54.900
So what can we do here, right?

00:36:54.900 --> 00:36:57.360
Well,
this is the point that I'm talking about,

00:36:57.360 --> 00:36:57.900
right?

00:36:57.900 --> 00:36:59.900
That initial touch is down, right?

00:36:59.900 --> 00:37:02.900
We talked about before in the timeline,
right?

00:37:02.900 --> 00:37:06.930
Finding that hit test view
before any events get delivered.

00:37:07.440 --> 00:37:13.540
So kind of a quick side
note on changing event flow.

00:37:13.860 --> 00:37:18.260
There is public API which you will
have access to on UI application

00:37:18.260 --> 00:37:20.160
and UI window send event.

00:37:20.160 --> 00:37:23.970
And you can override this to get a
look at every single event which gets

00:37:24.030 --> 00:37:27.640
delivered to your application and then
in turn gets delivered to every window.

00:37:28.640 --> 00:37:33.040
Now it used to be in older
versions of iOS before we had

00:37:33.040 --> 00:37:38.840
gesture recognize before OS 3.2,
before we had gesture recognizers that

00:37:38.840 --> 00:37:44.280
this was the only way really to get
that kind of land that first touch,

00:37:44.310 --> 00:37:46.720
land a subsequent touch and
have a gesture takeover.

00:37:47.310 --> 00:37:49.600
It's really kind of the,
you had to get this very,

00:37:49.600 --> 00:37:53.040
very high level view of how events
were flowing into your application.

00:37:53.040 --> 00:37:56.550
But you don't need to do that anymore.

00:37:57.250 --> 00:38:01.420
Really,
overriding SendEvent is not recommended.

00:38:01.780 --> 00:38:05.800
You should really kind of, you know,
understand kind of how the examples

00:38:05.840 --> 00:38:07.630
that I'm showing here are working.

00:38:07.640 --> 00:38:11.600
And if possible, use those mechanisms,
use the way that touch handlers

00:38:11.600 --> 00:38:15.500
and gesture recognizers interact
to get the behavior that you want,

00:38:15.670 --> 00:38:18.770
rather than kind of drinking from
the fire hose and trying to get

00:38:18.960 --> 00:38:21.030
everything right with SendEvent.

00:38:21.080 --> 00:38:24.600
All right, so really,
really think again if you think

00:38:24.650 --> 00:38:26.540
this is a good idea for you.

00:38:29.700 --> 00:38:38.260
Once we are using the standard
Send Event which we provide to you

00:38:38.580 --> 00:38:41.570
from UI application and UI window,
you still have some pretty

00:38:41.580 --> 00:38:42.700
interesting options.

00:38:42.700 --> 00:38:45.700
One of them is turning
off events for a view.

00:38:45.700 --> 00:38:50.700
So you have a view and you do not
want it to become the hit test view.

00:38:50.930 --> 00:38:52.700
What options do you have?

00:38:52.700 --> 00:38:55.330
The simplest, perhaps,
is just remove it from

00:38:55.400 --> 00:38:56.700
the view hierarchy.

00:38:56.700 --> 00:39:00.960
If it is not in the view hierarchy,
it will not become the hit test view.

00:39:01.130 --> 00:39:04.700
It will not be the target
for all of touch events.

00:39:04.700 --> 00:39:08.670
Alternatively,
you can leave the view in the view

00:39:08.670 --> 00:39:13.700
hierarchy and call other UI view APIs,
set user interaction and enable to know.

00:39:13.820 --> 00:39:15.690
So the view will still be there.

00:39:15.720 --> 00:39:17.830
You can still move it
around programmatically,

00:39:17.940 --> 00:39:20.700
but of course,
users cannot land their touches on it.

00:39:20.700 --> 00:39:23.130
It will not become the hit test view.

00:39:23.930 --> 00:39:27.320
You can also set the view to hidden,
which keeps it in the view hierarchy,

00:39:27.320 --> 00:39:31.790
which might actually be an
interesting option if at some point

00:39:31.790 --> 00:39:35.540
maybe that pinch gesture recognize,
maybe you want to even

00:39:35.540 --> 00:39:37.410
scale invisible views,
and when you bring the view

00:39:37.410 --> 00:39:39.810
and make it unhidden again,
maybe you want it to be scaled.

00:39:39.820 --> 00:39:41.800
That might be a good way to do it.

00:39:41.900 --> 00:39:44.840
Just make it hidden,
and you can still iterate over

00:39:44.840 --> 00:39:46.680
it and change its transform.

00:39:46.680 --> 00:39:49.900
That will all still work,
but of course the user won't see it.

00:39:50.020 --> 00:39:53.080
And of course it won't
become the hit test view.

00:39:54.470 --> 00:40:00.920
Or you can set the opaque property
to no and set the alpha to zero.

00:40:02.700 --> 00:40:04.680
Okay,
so if any one of these things are true,

00:40:04.720 --> 00:40:06.760
a view will not become the hit test view.

00:40:08.980 --> 00:40:10.610
And again, events won't flow to it.

00:40:10.760 --> 00:40:14.780
They will flow someplace else,
which may be what you want.

00:40:15.680 --> 00:40:19.040
Well, what about turning off
touches for your entire app?

00:40:19.220 --> 00:40:20.260
You can do that too.

00:40:20.440 --> 00:40:22.810
There's API and UI application.

00:40:22.970 --> 00:40:27.880
You go and you get a pointer to
the shared application and you call

00:40:28.170 --> 00:40:30.540
begin ignoring interaction events.

00:40:30.620 --> 00:40:34.550
So you do this and you
go and you run some code.

00:40:34.570 --> 00:40:35.240
Nothing will happen.

00:40:35.320 --> 00:40:37.710
Well, why would you want to do this?

00:40:37.730 --> 00:40:40.740
I think there are some good,
interesting situations.

00:40:40.770 --> 00:40:44.220
Let's say you have a game and you've
got sort of the startup screen for

00:40:44.220 --> 00:40:48.960
your game and the user presses a
sort of begin the game button and you

00:40:48.960 --> 00:40:50.530
don't really want anything to happen.

00:40:50.530 --> 00:40:53.830
You're sort of like in control of
the whole process of transitioning

00:40:54.380 --> 00:40:56.740
from your startup screen to the game.

00:40:56.740 --> 00:40:59.540
Perhaps even it's a multiplayer
game and you want to sort of

00:40:59.540 --> 00:41:01.700
synchronize the beginning of the game.

00:41:01.700 --> 00:41:04.540
You don't want anything to get
in the way of that in that maybe

00:41:04.540 --> 00:41:06.060
two or three second period.

00:41:06.460 --> 00:41:08.100
You just really,
really want to be in control.

00:41:08.100 --> 00:41:09.960
You don't want any other
event handlers firing,

00:41:09.970 --> 00:41:10.850
anything like that.

00:41:10.940 --> 00:41:13.820
So kind of situations like that,
this sort of makes sense.

00:41:13.820 --> 00:41:16.500
But of course,
when you're done with that process,

00:41:16.640 --> 00:41:19.860
you have to then call end,
ignoring interaction events.

00:41:19.860 --> 00:41:23.080
And of course, it's really important to
balance out these calls.

00:41:23.080 --> 00:41:25.800
I mean, I've had many,
many bugs where it was, oh,

00:41:25.900 --> 00:41:29.660
I can't touch anything in the app
now because sometimes the process of

00:41:29.660 --> 00:41:33.740
beginning is separated from ending and
it can get to be a little complicated

00:41:33.750 --> 00:41:35.890
to make sure that you get it right.

00:41:37.880 --> 00:41:41.800
But again, this is a way you can turn off
events for your entire application.

00:41:41.900 --> 00:41:43.580
Okay, so now touches during animations.

00:41:43.600 --> 00:41:45.580
What if a view is animating?

00:41:45.600 --> 00:41:46.800
Can you touch it?

00:41:46.910 --> 00:41:49.170
This is an interesting issue,
and I'd say, you know,

00:41:49.220 --> 00:41:51.910
there's not enough time to sort
of go into all the details,

00:41:51.910 --> 00:41:55.800
but this has actually changed
in different versions of iOS.

00:41:55.800 --> 00:41:59.800
I will tell you that
for version 5 of iOS,

00:41:59.800 --> 00:42:02.800
animating views will not
become the hit test view,

00:42:02.800 --> 00:42:05.800
although they really sort of will.

00:42:05.800 --> 00:42:07.650
They will become the hit test view,
but they won't get

00:42:07.720 --> 00:42:08.800
touches delivered to them.

00:42:08.800 --> 00:42:10.800
The touches will get eaten.

00:42:13.270 --> 00:42:17.390
It's kind of a subtle point,
and even sort of doing hit testing

00:42:17.530 --> 00:42:21.310
can be sort of interesting,
depending on what kind of

00:42:21.310 --> 00:42:22.630
animation you're doing.

00:42:22.740 --> 00:42:25.080
So if you have questions about this,
if this is something that

00:42:25.080 --> 00:42:27.920
you're really interested in,
you know, this is in some ways maybe

00:42:27.920 --> 00:42:32.000
even not so suggesting,
you know, not really always, you know,

00:42:32.000 --> 00:42:35.160
something you should expect users to do,
you know, kind of hit a moving target as

00:42:35.160 --> 00:42:36.700
it's going across the screen.

00:42:36.810 --> 00:42:39.130
So, you know,
maybe it's just kind of a special case

00:42:39.130 --> 00:42:41.160
where you'd really want this to happen.

00:42:41.190 --> 00:42:43.540
And if you do,
maybe just kind of come to the lab

00:42:43.630 --> 00:42:45.700
and find me or find a UIKit engineer.

00:42:45.700 --> 00:42:49.480
We can kind of talk
over the finer points.

00:42:52.030 --> 00:42:58.390
Okay, so now what if you want to direct
event delivery to a specific sub-view?

00:42:58.420 --> 00:43:02.000
There are two UI view API calls
which are interesting.

00:43:02.000 --> 00:43:05.180
One is hit test and one is point inside.

00:43:05.510 --> 00:43:08.560
Now, hit test is what gets
called from the start,

00:43:08.710 --> 00:43:11.780
from the very,
very top of your view hierarchy,

00:43:11.900 --> 00:43:14.000
sort of drilling down
through all of your views,

00:43:14.000 --> 00:43:15.280
trying to find that hit test view.

00:43:15.280 --> 00:43:20.870
This is the method which gets called,
UI application and then UI window,

00:43:20.940 --> 00:43:23.890
calls hit test on all of your views.

00:43:24.200 --> 00:43:28.630
So you can override this if, let's say,
maybe you've got sort of a more

00:43:28.660 --> 00:43:32.000
complicated version of my program,
my demo program,

00:43:32.000 --> 00:43:33.920
where you might have to select a view.

00:43:33.920 --> 00:43:36.980
You might have to touch a view
to maybe get some grab handles on

00:43:36.980 --> 00:43:38.720
it before you can drag it around.

00:43:38.740 --> 00:43:45.910
And so you want just kind of a different
set of sort of more complicated set

00:43:45.910 --> 00:43:52.580
of tests to be done before you let
a view become the hit test view.

00:43:53.500 --> 00:43:56.950
Now, I will say if you kind of think
back a couple of slides to that,

00:43:57.080 --> 00:44:01.980
the one where you can change whether
a view becomes the hit test view,

00:44:01.980 --> 00:44:05.880
removing from the super viewer,
checking hidden, or checking it's alpha,

00:44:05.880 --> 00:44:08.340
or checking if user
interaction is enabled.

00:44:08.340 --> 00:44:10.650
This is what hit test does by default.

00:44:10.660 --> 00:44:14.690
This is why if a view has any
of those properties true on it,

00:44:14.690 --> 00:44:19.250
why it won't become the hit test view,
because the default implementation

00:44:19.320 --> 00:44:21.440
of hit test tests those very things.

00:44:24.070 --> 00:44:27.450
Okay, so you can write a custom version
which adds a little bit of extra

00:44:27.450 --> 00:44:31.220
algorithmic smarts to hit test,
if that seems appropriate to you.

00:44:31.330 --> 00:44:33.910
Now the second one, Point Inside, I mean,
I think a really,

00:44:33.910 --> 00:44:37.370
really good example of why you'd want
to use Point Inside is just a very,

00:44:37.370 --> 00:44:39.260
very simple geometry test.

00:44:39.360 --> 00:44:41.580
A lot of applications,
it's pretty common in

00:44:41.580 --> 00:44:44.040
iOS to have pretty small,
circular, you know,

00:44:44.040 --> 00:44:47.160
buttons with a little italic I in it,
a little info button.

00:44:47.400 --> 00:44:49.400
And it's really small.

00:44:49.400 --> 00:44:52.710
It can be really hard to
actually land in that,

00:44:52.710 --> 00:44:54.490
even when you intend to.

00:44:54.640 --> 00:44:58.400
And so, if you want to make that
button small and unobtrusive,

00:44:58.400 --> 00:45:01.600
but still make it easy for
the user to interact with it,

00:45:01.730 --> 00:45:05.910
you can implement a custom view,
implement Point Inside to

00:45:05.980 --> 00:45:08.640
draw that little view,
that little circle,

00:45:08.640 --> 00:45:12.790
and override Point Inside to
change the geometry,

00:45:12.800 --> 00:45:17.240
make it sort of geometrically bigger.

00:45:17.690 --> 00:45:21.320
Not visually,
but just with respect to hit testing.

00:45:21.360 --> 00:45:24.680
So a very,
very simple little bit like that

00:45:24.790 --> 00:45:28.480
can make small views still really,
really easy to interact with.

00:45:30.040 --> 00:45:32.800
Okay, so that's changing event flow.

00:45:32.820 --> 00:45:36.570
Now,
a few notes on getting subclassing right.

00:45:36.860 --> 00:45:39.430
So if you subclass a
UIKit responder class,

00:45:39.450 --> 00:45:43.250
a UIView typically, right,
if you're going to

00:45:43.250 --> 00:45:45.130
implement one touch handler,
if you're going to

00:45:45.180 --> 00:45:49.040
implement touchesBegin,
you really should then go through

00:45:49.350 --> 00:45:51.120
and implement all the rest.

00:45:51.150 --> 00:45:53.800
TouchesMove, touchesEnded,
and touchesCancelled.

00:45:53.800 --> 00:45:56.670
If you implement one, implement them all.

00:45:56.680 --> 00:45:59.280
Again, there are some finer points here,
and you can wind up with some

00:45:59.300 --> 00:46:03.500
pretty difficult to diagnose bugs,
I'll tell you, if you don't do that.

00:46:03.600 --> 00:46:05.030
If you do, you're all safe.

00:46:05.220 --> 00:46:06.680
You're all good.

00:46:06.690 --> 00:46:07.080
Right?

00:46:07.110 --> 00:46:11.050
Also, don't draw in touch handlers.

00:46:11.220 --> 00:46:11.310
Right?

00:46:11.400 --> 00:46:13.270
Touch handlers are
really-- we're trying to,

00:46:13.350 --> 00:46:19.560
you know, keep sort of 50-- excuse me,
60 frames per second on sort

00:46:19.560 --> 00:46:21.400
of responding to events,
right?

00:46:21.400 --> 00:46:23.490
Sort of event frames per second.

00:46:23.630 --> 00:46:23.760
Right?

00:46:23.760 --> 00:46:26.270
So don't do expensive things
like drawing in touch handlers.

00:46:26.280 --> 00:46:27.690
You might be tempted to.

00:46:27.880 --> 00:46:31.600
And again, if maybe if you're coming from
the Mac and sort of thinking

00:46:31.600 --> 00:46:35.850
still in terms of draw rect to
sort of make your screen-- update

00:46:35.850 --> 00:46:37.510
your screen representation,
right?

00:46:37.640 --> 00:46:39.620
Maybe come to the labs and
we'll talk through maybe why

00:46:39.630 --> 00:46:41.080
that's not such a good idea.

00:46:41.080 --> 00:46:45.070
And there are cheaper ways to get
done what you want to get done.

00:46:45.730 --> 00:46:47.840
Also, don't forward events yourself.

00:46:47.840 --> 00:46:50.190
If you're interested in
using the responder chain

00:46:50.350 --> 00:46:53.930
to propagate touch events,
and maybe you've got a touches

00:46:53.930 --> 00:46:56.280
began implementation that
doesn't handle the event,

00:46:56.280 --> 00:46:58.540
you want to pass it up
to a higher level object,

00:46:58.560 --> 00:47:00.480
do not call next responder.

00:47:00.480 --> 00:47:03.320
Instead, just call super,
and it'll do the right thing.

00:47:03.330 --> 00:47:08.260
It'll propagate up the responder
chain just like we saw earlier.

00:47:08.440 --> 00:47:12.280
So now, what if you're interested in
subclassing UIView or UIControl,

00:47:12.370 --> 00:47:12.940
right?

00:47:12.940 --> 00:47:17.200
So now, the question is that you want
to implement a widget that sort

00:47:17.200 --> 00:47:19.000
of behaves like a UIControl.

00:47:19.510 --> 00:47:23.640
It sort of has that kind of
control concept attached to it,

00:47:23.640 --> 00:47:24.120
if you will.

00:47:24.120 --> 00:47:30.840
It's somehow manipulating something else,
manipulating a value, changing a number,

00:47:30.840 --> 00:47:36.430
maybe a knob in an application
that changes a value.

00:47:36.440 --> 00:47:37.640
So which do you do?

00:47:37.640 --> 00:47:40.100
Do you subclass UI view or UI control?

00:47:40.100 --> 00:47:42.560
I have to say it's really
a personal preference.

00:47:42.560 --> 00:47:44.020
I've done both quite a bit.

00:47:45.250 --> 00:47:48.040
Now, I will say that UI control,
if you choose it,

00:47:48.040 --> 00:47:51.750
it does give you some common
extras which are really useful.

00:47:51.890 --> 00:47:54.790
Things like target action are
just built into UI control,

00:47:54.920 --> 00:47:55.860
and you get that for free.

00:47:55.860 --> 00:47:58.200
You can just go and set a target action,
and it all just works.

00:47:58.250 --> 00:47:59.700
We've done the work for you.

00:47:59.700 --> 00:48:02.920
You don't have to worry
about setting that up.

00:48:03.000 --> 00:48:04.930
And of course,
I think this is really advisable

00:48:04.940 --> 00:48:07.490
if you've got something that
you're going to be reusing a lot in

00:48:07.520 --> 00:48:09.290
different places in your application.

00:48:09.410 --> 00:48:11.970
You're going to kind of put
two knobs next to each other,

00:48:11.970 --> 00:48:14.300
maybe a whole bank of
knobs next to each other.

00:48:14.450 --> 00:48:18.160
They're probably going to be hooked
up to then different code to actually

00:48:18.190 --> 00:48:20.580
respond when a user interacts with them.

00:48:20.990 --> 00:48:22.540
UI Control makes that easy.

00:48:22.540 --> 00:48:24.900
In terms of anything
that acts like a button,

00:48:24.900 --> 00:48:30.000
you get that touch-up-inside behavior
where if you touch down in the control

00:48:30.100 --> 00:48:34.490
and then drag out and then lift up,
the control won't fire,

00:48:34.710 --> 00:48:37.100
won't call its action method.

00:48:37.180 --> 00:48:39.830
You get that for free with UI Control.

00:48:39.830 --> 00:48:43.380
You can just sign up for
it using control states.

00:48:43.500 --> 00:48:48.610
That's a few reasons why you might
choose UI Control instead of UIView.

00:48:48.790 --> 00:48:52.060
What about subclassing an
existing UIKit control?

00:48:52.240 --> 00:48:55.330
Generally,
this is not really recommended.

00:48:55.330 --> 00:49:01.060
I make an exception for UIButton because
there are custom buttons and it implies

00:49:01.060 --> 00:49:05.100
that you will have to implement the
drawRect method on a custom button.

00:49:05.230 --> 00:49:07.630
Otherwise,
really check out the delegates and

00:49:07.630 --> 00:49:12.480
notifications that are on the existing
controls that are in UIKit and make

00:49:12.950 --> 00:49:20.460
sure that any custom behavior that
you want isn't already available

00:49:20.460 --> 00:49:22.740
through a delegate or a notification.

00:49:24.060 --> 00:49:26.680
Now, subclassing UI gesture recognizer,
get in making your own.

00:49:26.680 --> 00:49:29.410
Well, first again,
make sure that you look at

00:49:29.410 --> 00:49:31.090
the UIKit provided classes.

00:49:31.210 --> 00:49:34.460
And there are a number of properties
on these classes for number of fingers,

00:49:34.460 --> 00:49:38.560
and top recognizer has top counts,
and some other interesting properties.

00:49:38.560 --> 00:49:42.250
Make sure that you can't get what
you want by just going and using an

00:49:42.250 --> 00:49:44.710
existing class and setting a property.

00:49:44.710 --> 00:49:48.300
If you decide that you
do want a subclass,

00:49:48.300 --> 00:49:50.680
this class will help you.

00:49:50.750 --> 00:49:52.760
UI gesture recognizer subclass.

00:49:52.760 --> 00:49:53.490
Check it out.

00:49:53.580 --> 00:49:57.080
there are some interesting
methods there for you to override.

00:49:57.310 --> 00:50:00.320
And sort of the last bit of advice
there is to really keep gestures simple.

00:50:00.320 --> 00:50:03.320
I mean, I don't think that you
want sort of a five-finger,

00:50:03.320 --> 00:50:07.000
I need to move up and then to the side,
but more up, then to the side.

00:50:07.000 --> 00:50:10.020
You know, users a lot of times have,
you know, difficulty.

00:50:10.020 --> 00:50:14.000
The more complicated that a gesture is,
the more difficult it is for it to do.

00:50:14.000 --> 00:50:17.520
And as we saw in the example,
touch handlers are still firing.

00:50:17.520 --> 00:50:21.560
So users might wind up getting frustrated
by doing something that they didn't

00:50:21.560 --> 00:50:25.670
intend to as they were trying to sort
of trigger the higher-level gesture.

00:50:26.140 --> 00:50:28.390
So really try to keep
gestures simple if possible.

00:50:28.400 --> 00:50:29.790
Easy to do.

00:50:31.460 --> 00:50:34.580
And finally,
interacting with the rest of iOS.

00:50:34.670 --> 00:50:37.590
So I think, you know,
one of the best things about

00:50:37.660 --> 00:50:40.930
iOS and iOS devices is that when
the user is running your app,

00:50:40.930 --> 00:50:43.140
it's like the device becomes your app.

00:50:43.230 --> 00:50:46.400
If you've got a music application,
a musical instrument, you know,

00:50:46.530 --> 00:50:49.000
on an iPad,
an iPod becomes a musical instrument.

00:50:49.000 --> 00:50:49.790
It's really great.

00:50:49.800 --> 00:50:53.320
I mean, it's like the whole rest of
the system kind of melts away

00:50:53.320 --> 00:50:55.000
while your app is running.

00:50:55.080 --> 00:50:57.390
And of course,
you want to deliver that great

00:50:57.390 --> 00:50:59.000
experience to your users.

00:50:59.000 --> 00:51:03.060
You want users to enjoy
your apps and to love them.

00:51:03.420 --> 00:51:06.380
But, you know, even while, you know,
you're kind of thinking about

00:51:06.380 --> 00:51:09.130
providing this great experience,
having the device become your app,

00:51:09.220 --> 00:51:10.990
you do still have to work
and play well with others.

00:51:11.140 --> 00:51:15.530
Other code, other, you know,
facilities are running on the system.

00:51:15.670 --> 00:51:16.640
So like what?

00:51:16.950 --> 00:51:18.700
Well, there are things like on the phone.

00:51:18.700 --> 00:51:20.600
Well, on an iPhone, it's a phone, right?

00:51:20.600 --> 00:51:22.700
You might get a phone call at any time.

00:51:22.730 --> 00:51:28.700
Or an alert might fire from maybe you've
got some push notifications set up.

00:51:28.700 --> 00:51:33.100
You can interact with the device and
press the lock button at the same time.

00:51:33.140 --> 00:51:37.400
Or if your app is running while the
multitasking switching bar is running.

00:51:37.400 --> 00:51:40.620
You're still drawing,
but events are getting routed

00:51:40.690 --> 00:51:43.700
elsewhere in order to interact
with the multitasking switcher bar.

00:51:43.700 --> 00:51:47.570
And there are also multitasking gestures,
sort of swipe side to side

00:51:47.570 --> 00:51:49.800
to change between apps,
right?

00:51:49.800 --> 00:51:52.420
So there's, you know,
a bunch of other things which are

00:51:52.420 --> 00:51:58.400
going on which the users might do,
which may lead you to cancel touches.

00:51:58.400 --> 00:52:02.900
All right, so what do you need to do,
right, to be a good multitasking citizen?

00:52:02.900 --> 00:52:07.100
At least in terms of this talk,
it's implement touches canceled,

00:52:07.100 --> 00:52:11.870
but that also any,
the gesture recognizer state callback.

00:52:11.900 --> 00:52:13.840
You should really, really do this.

00:52:13.900 --> 00:52:15.900
Don't miss it.

00:52:15.900 --> 00:52:18.310
Don't neglect to think it through.

00:52:18.400 --> 00:52:23.480
What happens if you've got a game on
the phone and the user is touching

00:52:23.540 --> 00:52:25.350
the screen and a phone call comes in?

00:52:25.640 --> 00:52:28.000
Right, what happens?

00:52:29.380 --> 00:52:32.590
I think there are three
general strategies for

00:52:32.590 --> 00:52:34.800
handling cancelling touches.

00:52:34.800 --> 00:52:37.220
You can have cancelling just like ending.

00:52:37.450 --> 00:52:39.300
That's really the simplest thing to do.

00:52:39.360 --> 00:52:42.300
However,
whatever you do when touch is ended,

00:52:42.300 --> 00:52:47.160
just call that same factor out into a
shared function and have both touches

00:52:47.160 --> 00:52:48.780
ended and touches cancelled do that.

00:52:48.800 --> 00:52:50.800
I think that's perfectly reasonable.

00:52:50.800 --> 00:52:55.470
You can also leave your application in
a kind of a provisional state where you

00:52:55.470 --> 00:53:00.720
try to make it so that the user can kind
of pick up right when they left off.

00:53:00.800 --> 00:53:03.410
Again, that more sophisticated
example of my app,

00:53:03.460 --> 00:53:06.670
if a shape was selected, well,
you might want to leave it selected

00:53:06.770 --> 00:53:09.690
so that when the user comes back,
they can just kind of pick

00:53:09.730 --> 00:53:10.760
up right where they left off.

00:53:10.870 --> 00:53:14.790
Or, kind of another interesting
idea is you can implement undo.

00:53:14.900 --> 00:53:18.790
Really think about touches cancelled as
just forget like that touch ever happened

00:53:18.790 --> 00:53:20.800
and just put the application back.

00:53:20.800 --> 00:53:22.760
The way that it was.

00:53:22.810 --> 00:53:24.800
So I've got a simple example for that.

00:53:24.800 --> 00:53:28.430
So now, just a very, very simple...

00:53:32.620 --> 00:53:33.600
Touches cancelled example.

00:53:33.600 --> 00:53:38.580
So now I'm back in the shape class
and you'll see that all I've done,

00:53:38.600 --> 00:53:41.480
you know, before all I was doing was,
you know, kind of putting up the

00:53:41.480 --> 00:53:42.710
touches ended label.

00:53:42.850 --> 00:53:47.330
But now I've gone over in touches
cancelled and all I've done is have

00:53:47.380 --> 00:53:51.910
a little animation and this reference
point that I set the shape back to

00:53:52.000 --> 00:53:54.030
was just set up in touches began.

00:53:54.330 --> 00:53:56.180
A really pretty simple example.

00:53:56.260 --> 00:53:59.140
Almost the simplest possible undo.

00:53:59.300 --> 00:54:02.310
Okay,
so now I start interacting with my shape,

00:54:02.390 --> 00:54:04.420
I'm going to drag it up there,
and so now I'm going to press a button,

00:54:04.420 --> 00:54:06.300
I'm going to schedule an alert to run.

00:54:06.300 --> 00:54:08.250
So now I'm moving the thing
and now the alert fires,

00:54:08.370 --> 00:54:10.940
and all it does, right,
I get touches cancelled and I move

00:54:10.940 --> 00:54:13.160
the shape back to where it began.

00:54:13.300 --> 00:54:17.020
The simplest little way
of implementing undo,

00:54:17.020 --> 00:54:21.180
but it seems, I think to the user,
if that happened,

00:54:21.290 --> 00:54:23.300
it would seem natural enough.

00:54:23.300 --> 00:54:27.730
Now,
I did also talk to some of the UI kit

00:54:27.730 --> 00:54:33.700
engineers in preparation for this talk,
and we don't see any reason why you

00:54:33.700 --> 00:54:38.300
can't even use an NSUndoManager for
a more sophisticated application.

00:54:38.300 --> 00:54:42.300
And use that undo manager
to undo right here.

00:54:42.300 --> 00:54:46.480
So you can really kind of take
this quite a few steps further and

00:54:46.480 --> 00:54:48.300
implement undo and touches cancel.

00:54:48.320 --> 00:54:50.220
And if you really want to do that,
come to the labs,

00:54:50.250 --> 00:54:52.240
I'd be kind of interested
to talk it over with you.

00:54:52.350 --> 00:54:55.160
Okay,
so strategies for cancelling touches,

00:54:55.200 --> 00:54:59.290
right, it's like ending or kind of
a provisional state or undo.

00:55:00.800 --> 00:55:15.300
[Transcript missing]
WEBVTT

00:00:10.510 --> 00:00:14.800
Today we're going to talk about
practical drawing for iOS developers.

00:00:14.870 --> 00:00:18.280
So in my role at Apple,
what I spend a lot of time doing

00:00:18.280 --> 00:00:21.570
is talking to developers about
how they can make better apps,

00:00:21.680 --> 00:00:24.400
stronger apps, faster apps.

00:00:24.410 --> 00:00:26.420
And one of the things
I often say to them is,

00:00:26.430 --> 00:00:29.390
"Hey, why don't you try drawing
that with Core Graphics?

00:00:29.440 --> 00:00:30.370
I think you could do better.

00:00:30.460 --> 00:00:34.760
Your app might be faster,
might be smaller, and so forth." And the

00:00:34.760 --> 00:00:37.070
reaction I often get is,
"Are you kidding?

00:00:37.090 --> 00:00:38.600
Can I draw that with Quartz?

00:00:38.660 --> 00:00:43.170
What are you talking about?" And so
what I want to do over the next 60

00:00:43.220 --> 00:00:47.520
minutes is talk to you about how
at Apple we use Core Graphics to

00:00:47.520 --> 00:00:51.390
draw pieces of our applications,
to make them beautiful.

00:00:51.470 --> 00:00:55.400
So the first one I wanted to
talk about is the Stocks app.

00:00:55.400 --> 00:00:57.760
I'm not sure how many of you have
taken your Stocks app when you

00:00:57.760 --> 00:01:01.600
have the graph showing on the
bottom and turned it sideways and

00:01:01.600 --> 00:01:03.400
seen this interactive graphic.

00:01:03.400 --> 00:01:04.320
But this is fantastic.

00:01:04.570 --> 00:01:08.800
There's no way that we could ship all
of the possible images that would fit in

00:01:08.800 --> 00:01:11.400
there for every possible closing price.

00:01:11.400 --> 00:01:13.370
So we have to draw that at runtime.

00:01:13.400 --> 00:01:16.800
We use dynamic data that we
download off the internet,

00:01:16.800 --> 00:01:19.390
and then we draw it with Core Graphics.

00:01:20.360 --> 00:01:21.860
Another one is weather.

00:01:21.920 --> 00:01:25.600
So the images like the sun that's got a
little bit of cloud on it and so forth,

00:01:25.690 --> 00:01:27.640
those images are pre-rendered.

00:01:27.700 --> 00:01:32.700
But we draw those into this beautiful
looking table view at runtime.

00:01:32.810 --> 00:01:33.830
The next one is numbers.

00:01:33.850 --> 00:01:37.400
Of course you can put data
yourself into numbers.

00:01:37.460 --> 00:01:39.760
Hopefully your weight loss
progress looks like that.

00:01:39.840 --> 00:01:42.230
Mine often looks the other way.

00:01:42.640 --> 00:01:46.460
But users type this data in,
so we can't draw this beforehand,

00:01:46.570 --> 00:01:48.580
we have to draw it at runtime.

00:01:50.040 --> 00:01:53.450
Next is in a lot of our table view
cells to make them really fast,

00:01:53.450 --> 00:01:55.900
like the YouTube application
here on iPad,

00:01:56.010 --> 00:01:58.980
we draw that with Quartz.

00:02:00.430 --> 00:02:04.790
Next, this is one of my favorite pages,
has this beautiful rendered

00:02:04.820 --> 00:02:07.500
ruler at the top of every page.

00:02:07.630 --> 00:02:10.230
Now if you look closely you'll
notice in portrait and landscape

00:02:10.330 --> 00:02:12.200
we have a different ruler there.

00:02:12.310 --> 00:02:15.940
One is demarked in eighth inch increments
and the other one in sixteenth inch.

00:02:16.310 --> 00:02:18.900
Now of course we could have put
two different pings in there and we

00:02:18.900 --> 00:02:21.900
could ship with both of those pings
and then just switch between them.

00:02:22.050 --> 00:02:27.110
But it makes the application smaller
to draw that again with Quartz.

00:02:27.480 --> 00:02:28.370
Next up is iBooks.

00:02:28.390 --> 00:02:29.560
I love this application.

00:02:29.560 --> 00:02:33.090
There's so many cool things
available and it's just so beautiful.

00:02:33.190 --> 00:02:34.420
I don't know how many of you ever looked.

00:02:34.520 --> 00:02:37.790
I tried to get a screenshot of this,
but if you tap on your bookshelf

00:02:37.880 --> 00:02:40.230
here and you pull down,
there's a nice embossed

00:02:40.230 --> 00:02:41.440
Apple logo in the background.

00:02:41.440 --> 00:02:42.680
It's just beautiful.

00:02:42.680 --> 00:02:46.150
All this fit and finish and
this background and all the

00:02:46.150 --> 00:02:50.240
things you see on the screen
are of course drawn with Quartz.

00:02:50.760 --> 00:02:51.990
And then next is GarageBand.

00:02:52.000 --> 00:02:52.890
I love this app.

00:02:52.980 --> 00:02:54.820
I don't know if you've
played with this feature,

00:02:54.880 --> 00:02:57.380
but there's a whole bunch of
samples built in that you can play.

00:02:57.380 --> 00:03:00.020
My kids bark into the microphone
and then play themselves

00:03:00.130 --> 00:03:01.450
barking back at each other.

00:03:01.600 --> 00:03:02.710
It's a fantastic app.

00:03:02.840 --> 00:03:06.650
But the sound graph that you see
on the top right hand side there,

00:03:06.650 --> 00:03:09.250
that's drawn again with Core Graphics.

00:03:10.390 --> 00:03:14.500
So let's look at the agenda of
what we're going to do today.

00:03:14.630 --> 00:03:17.400
What I wanted to do was take you
through how to draw something

00:03:17.470 --> 00:03:19.300
that looks very similar to this.

00:03:19.410 --> 00:03:23.020
Last year we did a talk and one of
the engineers at that talk went to

00:03:23.090 --> 00:03:27.300
the labs and he was inundated with
questions about how this got drawn.

00:03:27.310 --> 00:03:30.110
Someone told that he drew this himself,
that he wrote the code.

00:03:30.460 --> 00:03:32.200
So people just mobbed him.

00:03:32.300 --> 00:03:36.300
So I thought this year what we do is
walk through drawing something like that.

00:03:36.300 --> 00:03:38.800
To see how it's drawn though,
let's break it down

00:03:38.800 --> 00:03:40.300
into individual layers.

00:03:40.300 --> 00:03:42.300
So first of all we start
with the gradient background.

00:03:42.300 --> 00:03:45.620
Now of course we can't have square edges,
everything has to be rounded

00:03:45.620 --> 00:03:47.080
and safe for children,
right?

00:03:47.300 --> 00:03:50.210
So we want to round the edges off.

00:03:50.280 --> 00:03:54.580
We'll talk about how to build
clip pads that look like that.

00:03:54.900 --> 00:03:56.810
We also want to draw a data grid.

00:03:56.890 --> 00:03:59.840
Now on the bottom is where
we'll draw the volume data,

00:03:59.840 --> 00:04:02.800
how many shares traded
hands in a particular day.

00:04:02.800 --> 00:04:05.970
And on the top part of that is where
we will draw the closing data that's

00:04:05.970 --> 00:04:07.590
got the waves in it and so forth.

00:04:07.590 --> 00:04:11.780
On the bottom we have room to put text,
and on the right we have room

00:04:11.870 --> 00:04:13.090
to put labels for these lines.

00:04:13.110 --> 00:04:16.100
So the clipped horizontal
lines show how much,

00:04:16.100 --> 00:04:19.760
what the value of the stock
was on any given closing day.

00:04:19.760 --> 00:04:24.780
And then also to really make it stand out
we draw this line pattern underneath it.

00:04:24.800 --> 00:04:26.280
underneath it.

00:04:26.980 --> 00:04:30.660
Finally,
we draw the closing data over the top

00:04:30.740 --> 00:04:34.980
of those two clipped groups of shapes,
and then the volume

00:04:35.150 --> 00:04:36.690
data down at the bottom.

00:04:37.190 --> 00:04:40.740
and also the text labels at the bottom,
we're going to draw those

00:04:40.760 --> 00:04:43.140
and I don't know how well it
shows up on the screen here,

00:04:43.140 --> 00:04:44.700
but there's a nice shadow behind those.

00:04:44.700 --> 00:04:47.330
So we'll look at how to do that as well.

00:04:47.950 --> 00:04:49.360
So simple stocks.

00:04:49.380 --> 00:04:51.140
That's what we're going to go
through in the next 60 minutes.

00:04:51.140 --> 00:04:53.280
And when you leave here,
you're going to know how to do

00:04:53.280 --> 00:04:55.280
everything that you see in this graphic.

00:04:57.280 --> 00:04:59.700
So let's get started by just
looking at a couple of simple

00:04:59.770 --> 00:05:02.260
examples of how drawing gets done.

00:05:02.360 --> 00:05:04.200
So again,
I spend a lot of time with developers

00:05:04.200 --> 00:05:07.210
and they bring me their code that they've
downloaded off of the internet and say,

00:05:07.210 --> 00:05:10.900
"I look at this and this looks so simple,
but when I try to do it myself,

00:05:11.050 --> 00:05:14.220
it doesn't seem quite that simple."

00:05:15.630 --> 00:05:20.850
The API that we use behind that
that makes drawing work is Quartz.

00:05:20.970 --> 00:05:22.450
And I've already said
Quartz several times.

00:05:22.650 --> 00:05:26.970
Behind that is Core Graphics
or the same thing as that.

00:05:27.020 --> 00:05:29.690
So I might say Quartz and
mean Core Graphics and say

00:05:29.690 --> 00:05:31.600
Core Graphics and mean Quartz.

00:05:31.600 --> 00:05:32.940
It's the marketing term.

00:05:33.100 --> 00:05:38.040
And you know it's the marketing term
because it has this beautiful Q graphic.

00:05:38.150 --> 00:05:40.900
Programmers don't make art like that.

00:05:41.390 --> 00:05:45.200
Okay, so when the developers bring me
their code and show it to me,

00:05:45.240 --> 00:05:47.260
oftentimes they've downloaded
something like this,

00:05:47.320 --> 00:05:51.000
where it's a really simple
example where we do color fill.

00:05:51.040 --> 00:05:54.710
And what you see is someone says
override the draw rect method on

00:05:54.710 --> 00:05:57.040
your custom implementation of view.

00:05:57.220 --> 00:06:02.170
Set red or whatever color to be your fill
color and then call this UI Rect Fill.

00:06:02.170 --> 00:06:05.170
Now of course this works and that's
exactly how I got the screenshot

00:06:05.170 --> 00:06:06.540
to show to you on screen here.

00:06:06.710 --> 00:06:08.340
But who wants to write code
when you could click one

00:06:08.490 --> 00:06:09.920
button in Interface Builder,
right?

00:06:09.920 --> 00:06:12.870
How many of you on your very first
iPhone project changed the color of

00:06:12.870 --> 00:06:14.540
your flashlight from white to red?

00:06:14.630 --> 00:06:16.470
We all did that, right?

00:06:16.480 --> 00:06:22.160
So this works but it's not a great
example of using Quartz because one,

00:06:22.160 --> 00:06:24.780
it's inefficient and two,
there's much better ways to do

00:06:24.820 --> 00:06:26.480
that with Interface Builder.

00:06:26.480 --> 00:06:30.660
So let's talk about an example
that actually requires that we

00:06:30.660 --> 00:06:32.980
dive down into the Quartz API.

00:06:32.980 --> 00:06:35.970
So we're going to build this
beautiful gray gradient.

00:06:36.180 --> 00:06:39.700
Start with white on the bottom
and fade into this little bit

00:06:39.800 --> 00:06:41.570
of a darker gray at the top.

00:06:41.800 --> 00:06:42.860
And here's the code.

00:06:42.980 --> 00:06:44.360
It's five lines of code.

00:06:44.360 --> 00:06:45.500
Deceptively simple, right?

00:06:45.500 --> 00:06:48.700
It's really easy to use once you
get your head wrapped around it.

00:06:48.840 --> 00:06:54.230
But you might notice that there's some
parentheses instead of square brackets.

00:06:54.340 --> 00:06:57.290
And so it is a CAPI,
but I don't want you to panic.

00:06:57.320 --> 00:07:01.970
It's really straightforward to
use once you get to know it.

00:07:03.100 --> 00:07:04.870
So it's just objects,
and instead of the object being

00:07:04.870 --> 00:07:07.540
on the left-hand side with a
square bracket in front of it,

00:07:07.590 --> 00:07:10.420
you have the thing you want done,
and then you pass in the object

00:07:10.420 --> 00:07:11.970
and then the arguments for it.

00:07:12.080 --> 00:07:14.880
So it's very straightforward once
you get your head wrapped around it,

00:07:14.880 --> 00:07:17.120
and that's what we'll do
in the next little while.

00:07:17.120 --> 00:07:21.820
But UIKit also covers a big
chunk of the Core Graphics API so

00:07:21.860 --> 00:07:27.010
that you don't ever really have
to think in terms of the CAPI.

00:07:27.280 --> 00:07:32.000
So let's go through the
code one line at a time.

00:07:32.040 --> 00:07:33.280
Thank you.

00:07:36.490 --> 00:07:39.490
The first thing we want to do is
grab the graphics context from the

00:07:39.490 --> 00:07:42.600
UI Graphics Get Current Context method.

00:07:43.240 --> 00:07:44.440
Then we create the gradient.

00:07:44.610 --> 00:07:46.860
Now I'm not showing you how
to create the gradient yet,

00:07:46.900 --> 00:07:48.880
but we will see that in
just a couple of slides.

00:07:48.900 --> 00:07:52.290
I wanted to put it behind a method
because it's important that we cache

00:07:52.730 --> 00:07:56.700
these objects that Core Graphics
uses so that we can reuse them again

00:07:56.710 --> 00:08:00.650
and again because when we do that,
that allows Quartz to take advantage

00:08:01.040 --> 00:08:03.850
of a lot of caching that it does on
the back end bookkeeping for what

00:08:03.960 --> 00:08:05.690
the gradient looks like and so forth.

00:08:16.570 --> 00:08:16.690
Then we specify the start and end
point and in this case we're going

00:08:16.690 --> 00:08:16.690
to draw a linear gradient so we just
set a beginning point and an end

00:08:16.690 --> 00:08:16.690
point and then we're going to have
that gradient build across that line.

00:08:17.120 --> 00:08:33.090
And then it's one function call.

00:08:33.090 --> 00:08:33.090
CG context, draw linear gradient.

00:08:33.090 --> 00:08:33.090
The first argument is the object
that you want to act on and then the

00:08:33.090 --> 00:08:33.090
remainder of the arguments are just
the parameters that you're passing

00:08:33.090 --> 00:08:33.090
into essentially that method call.

00:08:33.090 --> 00:08:33.090
I told you it was easy.

00:08:33.090 --> 00:08:33.090
Do you believe me?

00:08:33.690 --> 00:08:35.920
Okay, so building a gradient.

00:08:35.950 --> 00:08:38.160
The first thing we want to
do is set up the colors.

00:08:38.160 --> 00:08:41.620
So these are the individual colors,
the white color, the medium gray,

00:08:41.620 --> 00:08:43.830
and then the little bit darker gray.

00:08:44.160 --> 00:08:47.500
Then we set up the color stops and
these are the locations along that

00:08:47.500 --> 00:08:52.200
line where the color is going to reach
the particular color that we specified.

00:08:52.280 --> 00:08:55.650
We're going to grab the device
gray color space because in this

00:08:55.800 --> 00:08:57.790
case we're drawing a gray gradient.

00:08:58.990 --> 00:09:00.700
Then we create the gradient.

00:09:00.760 --> 00:09:01.260
Now we're done.

00:09:01.260 --> 00:09:04.570
We've created our gradient
and we can use it to draw.

00:09:04.650 --> 00:09:08.220
We do a little bit of memory
cleanup there by just releasing

00:09:08.300 --> 00:09:10.290
that color space that we created.

00:09:11.710 --> 00:09:15.280
So now we've seen a real example
of something that we actually need

00:09:15.280 --> 00:09:17.390
to use the Core Graphics API for.

00:09:17.480 --> 00:09:21.150
So let's take a step back and take a
look at the basics and walk through how

00:09:21.150 --> 00:09:24.890
drawing works and look at the drawing
model so that when it comes time for

00:09:24.890 --> 00:09:28.810
you to draw you'll understand how to
get what you want onto the screen.

00:09:29.100 --> 00:09:31.970
So if you've been to many of our
talks that have talked about any

00:09:31.970 --> 00:09:37.010
sort of graphics context inside iOS,
you know that the top left

00:09:37.030 --> 00:09:38.290
hand side is the origin.

00:09:38.470 --> 00:09:43.070
X is going to the right and
Y positive is going down.

00:09:44.410 --> 00:09:48.300
It's a geometric system in which
you describe what you want drawn.

00:09:48.300 --> 00:09:51.700
So you can make statements like,
"I'd like to draw a circle," or "I'd

00:09:51.700 --> 00:09:59.750
like to draw a triangle," or a square,
or something even more interesting

00:09:59.750 --> 00:09:59.750
like this double-headed triangle,
or a double-headed arrow.

00:10:00.370 --> 00:10:03.300
or even really interesting
stuff like this.

00:10:03.350 --> 00:10:07.170
So all of these are just individual
things called paths that have been

00:10:07.190 --> 00:10:10.730
drawn using particular colors and
you end up with something really

00:10:10.740 --> 00:10:12.130
beautiful that looks like that.

00:10:12.180 --> 00:10:15.530
I don't even know what that data
represents but it looks cool.

00:10:16.480 --> 00:10:19.640
Or you can take the closing data
that we're going to download off

00:10:19.640 --> 00:10:23.750
the internet and come up with
a graphic that looks like this.

00:10:25.100 --> 00:10:29.180
So to talk about what points are,
points are the individual sort

00:10:29.180 --> 00:10:33.350
of the atomic bit of how you
describe what you want drawn.

00:10:33.560 --> 00:10:34.540
They're abstract.

00:10:34.790 --> 00:10:38.040
They're a place in the space
that you're going to draw in.

00:10:38.150 --> 00:10:40.530
There's no concept of
resolution on a point.

00:10:40.550 --> 00:10:44.500
So Quartz doesn't think or it
doesn't present to you an API that

00:10:44.500 --> 00:10:46.850
thinks in terms of dots per inch.

00:10:47.210 --> 00:10:52.000
An important point to keep in mind
is a point is at the intersection

00:10:52.000 --> 00:10:56.490
of two pieces of your number line,
your X and your Y, just like you learned

00:10:56.490 --> 00:10:58.230
in your geometry class.

00:11:02.380 --> 00:11:05.300
On the flip side though, of course,
pixels are concrete.

00:11:05.370 --> 00:11:06.050
They're physical.

00:11:06.090 --> 00:11:08.820
They're either there
and on or they're off.

00:11:09.030 --> 00:11:11.300
And if they're on,
they have one color value.

00:11:11.300 --> 00:11:13.300
They can't have multiple color values.

00:11:13.300 --> 00:11:16.970
And so what Core Graphics does
for us is it does the translation

00:11:16.970 --> 00:11:18.640
between those two things.

00:11:18.720 --> 00:11:22.340
So we describe in a very abstract way,
we say, "Hey, I would like to have a

00:11:22.750 --> 00:11:26.210
line width of two points,
and I would like to have the

00:11:26.270 --> 00:11:29.290
first point be here and the second
point I want to make a line to."

00:11:29.300 --> 00:11:30.920
And that's what we end up with.

00:11:30.920 --> 00:11:33.800
On the left-hand side,
we see we're filling eight points

00:11:33.800 --> 00:11:37.160
because our line is two points wide
and it goes across four points.

00:11:37.200 --> 00:11:39.860
But if we were to push that
to a retina display where one

00:11:39.860 --> 00:11:44.300
point is equal to two pixels,
we would cover all 32 of those pixels.

00:11:46.500 --> 00:11:49.240
But it's really important that
instead of thinking in terms of

00:11:49.300 --> 00:11:51.500
pixels that we think geometrically.

00:11:51.540 --> 00:11:54.580
A 10 point system font
is the right point size,

00:11:54.820 --> 00:11:56.180
not 10 pixels.

00:11:56.370 --> 00:12:00.480
44 by 44 points is how big you
should make your touch areas.

00:12:00.650 --> 00:12:03.680
When the iPhone 4 came out and
we started talking about retina

00:12:03.680 --> 00:12:05.440
display we really stressed this.

00:12:05.540 --> 00:12:09.560
If you made a touch point that
was 22 pixels by 22 pixels,

00:12:09.630 --> 00:12:13.160
or 44 pixels by 44 pixels,
people wouldn't be able to tap it.

00:12:13.250 --> 00:12:15.850
It would be really hard
to get their finger on it.

00:12:16.020 --> 00:12:19.870
And then of course all of
the devices that we shipped,

00:12:19.870 --> 00:12:25.690
iPhones, iPod touches and so forth
are all 320 by 480 points.

00:12:28.110 --> 00:12:30.360
So we've talked a little
bit about context and what

00:12:30.360 --> 00:12:31.400
we're doing with the context.

00:12:31.450 --> 00:12:34.250
Let's take a step back and talk
about what we do with the context

00:12:34.280 --> 00:12:36.030
or how a context is put together.

00:12:36.230 --> 00:12:40.490
It has a list of properties and then
those properties are used at draw time

00:12:40.490 --> 00:12:44.970
to figure out what pixels need to be
filled and how they should be filled.

00:12:45.130 --> 00:12:50.100
One piece of those, of that property,
properties is called a path.

00:12:50.100 --> 00:12:52.310
And so here we're
creating a rectangle path.

00:12:52.360 --> 00:12:55.510
So we're asking the context,
please add a rectangle to

00:12:55.510 --> 00:12:57.100
your state that's a path.

00:12:57.100 --> 00:12:59.040
And so that would build this path.

00:12:59.140 --> 00:13:02.780
Now remember it's abstract,
that's why it's got dots around it.

00:13:03.120 --> 00:13:06.360
Then I can set the fill
color to some blue color.

00:13:06.360 --> 00:13:08.100
And it's kind of,
you can think about it like

00:13:08.110 --> 00:13:10.890
you're telling your kid what
color crayon to pick up,

00:13:10.890 --> 00:13:13.240
and then when you ask
the context to draw,

00:13:13.270 --> 00:13:17.010
it's going to fill with that crayon
that you asked it to pick up.

00:13:18.800 --> 00:13:23.120
So here we have our rectangle
that's filled with that blue color.

00:13:23.120 --> 00:13:27.750
It starts at zero, zero,
and it's 400 points by 400 points.

00:13:29.350 --> 00:13:34.770
I could also with the UIKit cover
API that sits over Core Graphics just

00:13:34.830 --> 00:13:37.700
call UIColor blue color set fill.

00:13:37.860 --> 00:13:41.780
Now that blue color becomes the
fill color and then I can call the

00:13:41.780 --> 00:13:46.510
UI graphics function UIRECT fill with
the CG RECT and it would fill that RECT.

00:13:46.710 --> 00:13:51.150
And again it does exactly the same
thing but this is using perhaps a

00:13:51.150 --> 00:13:54.000
more convenient or more familiar API.

00:13:55.270 --> 00:13:57.310
Another piece of the context,
or a bit of the

00:13:57.370 --> 00:14:01.580
information in the context,
is called the Current Transform Matrix,

00:14:01.630 --> 00:14:03.200
also called the CTM.

00:14:03.330 --> 00:14:06.040
This is the definition of user space.

00:14:06.040 --> 00:14:11.170
It's what defines where points lie,
how big they are, how far apart they are,

00:14:11.170 --> 00:14:12.350
and so forth.

00:14:13.560 --> 00:14:19.210
I can do things like translate that
CTM and then reuse the path again and

00:14:19.260 --> 00:14:23.790
draw it again and it will draw it in
what looks like a different location.

00:14:23.820 --> 00:14:29.180
So here I'm translating the CTM in the
X direction by a positive 100 points.

00:14:29.210 --> 00:14:35.830
So it moved my square from 00 to 100,
100 but the rectangle that

00:14:35.830 --> 00:14:38.710
I drew still started at 00.

00:14:40.410 --> 00:14:44.320
Context lives in what's called a stack,
a graphic state stack,

00:14:44.320 --> 00:14:47.750
and I can push copies of it onto a stack,
make changes,

00:14:47.800 --> 00:14:51.840
and then when I pop that copy off,
all those changes that

00:14:51.920 --> 00:14:53.710
I made are discarded.

00:14:53.890 --> 00:14:56.590
It's very convenient and it
becomes very important when

00:14:56.590 --> 00:14:59.810
we take a look at something,
some of the code that we

00:14:59.820 --> 00:15:03.690
use to draw the stock graph.

00:15:04.850 --> 00:15:08.660
So the first thing we do is call
saveGstate and that pushes a copy

00:15:08.760 --> 00:15:11.390
of the context onto the stack.

00:15:11.620 --> 00:15:14.520
Then we do some translation,
translate 100 to the right or left or

00:15:14.520 --> 00:15:17.260
however other we wanted to translate it.

00:15:17.400 --> 00:15:20.420
And then all the drawing that we
do from that point forward lives

00:15:20.420 --> 00:15:22.140
in that translated user space.

00:15:22.140 --> 00:15:26.400
So we've changed the definition of what a
point is and where they lie and so forth.

00:15:26.510 --> 00:15:29.360
And so all the drawing that
we do from that point forward

00:15:29.460 --> 00:15:31.220
is affected by those changes.

00:15:31.350 --> 00:15:34.800
Then when we call restore G state,
all of our changes are thrown away

00:15:35.130 --> 00:15:40.170
and we're back to the context that
we had before we called save G state.

00:15:41.440 --> 00:15:45.100
So really important point about context.

00:15:45.270 --> 00:15:47.000
You can't call us.

00:15:47.200 --> 00:15:48.230
We have to call you.

00:15:48.320 --> 00:15:50.880
I see code like this a lot
trying to help people understand

00:15:50.880 --> 00:15:52.330
why their drawing doesn't work.

00:15:52.400 --> 00:15:55.740
They have some event processing code,
the user's tapping on something

00:15:55.740 --> 00:15:58.550
and they want it to change
from red to green or whatever.

00:15:58.550 --> 00:16:02.360
In their event processing
code they're trying to draw.

00:16:02.360 --> 00:16:05.480
So they call UI Graphics
Get Current Context inside their

00:16:05.480 --> 00:16:07.300
tap gesture recognizer code.

00:16:07.520 --> 00:16:11.320
Well of course it's not going
to work there and the reason

00:16:11.400 --> 00:16:13.270
is that there's no context.

00:16:14.920 --> 00:16:18.470
It is really important that
when you have user interaction

00:16:18.480 --> 00:16:20.480
that you're updating state.

00:16:20.480 --> 00:16:23.400
So in this method,
instead of trying to draw,

00:16:23.400 --> 00:16:27.010
what you want to do is update your state,
make whatever state changes

00:16:27.010 --> 00:16:29.560
happen because the user
tapped or panned or whatever,

00:16:29.560 --> 00:16:33.320
and then tell the view that
it needs to display itself.

00:16:33.970 --> 00:16:36.360
Calling this method
is really inexpensive.

00:16:36.430 --> 00:16:40.740
It just flips a single bit on the view
and marks it that it needs to be redrawn.

00:16:40.740 --> 00:16:42.680
So you can call it as often as you want.

00:16:42.840 --> 00:16:46.030
Now the beauty of this is you can
mark a whole lot of views needing

00:16:46.030 --> 00:16:49.470
to be displayed or the same view
needing to be displayed many times

00:16:49.470 --> 00:16:52.960
and you won't actually trigger
any drawing until it's time.

00:16:52.960 --> 00:16:55.400
And we keep track of that inside UIKit.

00:16:55.400 --> 00:16:59.470
And when it's time to draw,
we'll set up a context and invoke

00:16:59.510 --> 00:17:01.830
your view's drawRect method.

00:17:02.580 --> 00:17:05.320
Inside drawRect,
we have done all the work to

00:17:05.320 --> 00:17:09.390
set up a context and we've set
that to be the active context.

00:17:09.390 --> 00:17:12.510
So when drawRect happens,
you're able to draw.

00:17:12.510 --> 00:17:15.200
So when you call
UIGraphics.getContext here,

00:17:15.200 --> 00:17:18.990
of course, there's going to be a context
because we set it up for you.

00:17:19.280 --> 00:17:22.700
Now of course it wouldn't be a great
rule if it didn't have an exception.

00:17:22.740 --> 00:17:25.570
And we understand that there are cases
where you're going to want to draw

00:17:25.570 --> 00:17:27.200
when something interesting happens.

00:17:27.350 --> 00:17:32.420
And so what you can do is call
UIGraphicsBeginImageContextWithOptions.

00:17:32.420 --> 00:17:36.070
And that does all the heavy
lifting to put together a context

00:17:36.070 --> 00:17:38.200
and make it the active context.

00:17:38.520 --> 00:17:42.040
Then when we do things like
use UIKit drawing methods like

00:17:42.040 --> 00:17:45.960
UIImagesDrawInRect method,
it has a current context so

00:17:45.960 --> 00:17:49.910
when it draws it's going to
go into that current context.

00:17:50.280 --> 00:17:52.680
Then I can ask the current context, hey,
give me the image.

00:17:52.750 --> 00:17:57.110
Now I have my scaled image,
which is what I'm doing in this method.

00:17:57.200 --> 00:18:13.400
[Transcript missing]

00:18:13.690 --> 00:18:18.400
So if you've spent any time in the
API documentation for Core Graphics,

00:18:18.400 --> 00:18:21.780
you've probably seen the
CG bitmap context create.

00:18:21.960 --> 00:18:24.420
Or if you've spent any time
searching on the internet for

00:18:24.420 --> 00:18:27.280
how to draw in the background,
you've probably encountered this.

00:18:27.280 --> 00:18:29.280
Now it's really feature rich.

00:18:29.280 --> 00:18:33.160
There's a lot of things you can
do to create a CG bitmap context.

00:18:33.160 --> 00:18:36.650
On the flip side,
you can use the really simple UI graphics

00:18:36.650 --> 00:18:41.260
begin image context with options and
all you have to do is pass in the size,

00:18:41.260 --> 00:18:44.130
how big do you want the context to be,
what opacity,

00:18:44.130 --> 00:18:48.020
do you want it to have opacity or not,
is it completely opaque,

00:18:48.020 --> 00:18:49.560
and then you set the scale.

00:18:49.670 --> 00:18:52.860
And you can even pass in zero
there and it will set the scale

00:18:52.860 --> 00:18:55.840
appropriate for whatever piece
of hardware you're running on.

00:18:55.920 --> 00:18:58.590
So two different approaches.

00:18:58.670 --> 00:19:02.890
The way you decide which one you want
to choose is based on whether or not

00:19:02.890 --> 00:19:07.130
you have some custom algorithm that
needs access to the backing data,

00:19:07.260 --> 00:19:09.960
to the actual bits that make up the
bitmap that you're going to build.

00:19:09.980 --> 00:19:13.600
That would be a case where you'd want
to use your own bitmap context that

00:19:13.600 --> 00:19:15.580
you build with CG bitmap context.

00:19:15.580 --> 00:19:18.450
In virtually every other case
you're going to want to use the

00:19:18.450 --> 00:19:20.300
UI Graphics Begin Image Context.

00:19:20.300 --> 00:19:23.560
We make sure that that's optimized for
displaying on the screen and then we

00:19:23.560 --> 00:19:26.820
have other functions that will pull
a ping file or a JPEG out of there.

00:19:26.920 --> 00:19:29.510
So if you want to email it
or whatever you can do that.

00:19:29.520 --> 00:19:35.150
So that's a wrap up,
or that's the extent of the basics.

00:19:38.010 --> 00:19:41.330
The context is a geometric space
in which you're going to draw.

00:19:41.610 --> 00:19:44.100
You should think geometrically.

00:19:44.340 --> 00:19:48.800
Core Graphics translates that
geometric description into some pixels.

00:19:48.800 --> 00:19:51.190
And the great thing is we
never have to worry about

00:19:51.200 --> 00:19:53.250
peaking and poking video memory.

00:19:53.280 --> 00:19:55.300
Hooray for that.

00:19:55.390 --> 00:19:58.170
The current transform matrix
defines how points live,

00:19:58.170 --> 00:20:01.200
how they relate to each other,
what the current space is.

00:20:01.330 --> 00:20:05.790
And then last and most important about
this initial section is you cannot just

00:20:05.880 --> 00:20:08.300
arbitrarily start drawing anywhere.

00:20:08.300 --> 00:20:11.300
You have to have an active context.

00:20:12.500 --> 00:20:18.420
So the primitive of how you draw
things in Core Graphics is a path.

00:20:18.600 --> 00:20:21.470
And a path is made up
of one of four pieces:

00:20:21.530 --> 00:20:25.870
a point, a line, an arc, or a curve.

00:20:26.990 --> 00:20:31.200
You create a path with UI Bezier Path,
call the class method Bezier Path,

00:20:31.290 --> 00:20:35.090
that's going to return an
auto-released object to you.

00:20:35.340 --> 00:20:39.030
Then you create a CG point
and you tell it move to point.

00:20:39.320 --> 00:20:45.010
Anytime you call move to point that's
going to create or begin a new path,

00:20:45.150 --> 00:20:47.880
but that point is kind of
lonely and he needs a friend,

00:20:47.890 --> 00:20:52.000
so we're going to set up another
point and call add line to point.

00:20:52.130 --> 00:20:55.820
So now I've built this geometric
abstraction which is the line

00:20:55.820 --> 00:20:59.320
that goes from the initial
point to the second point.

00:20:59.660 --> 00:21:06.040
When I set the line width to 1
and then ask that path to stroke,

00:21:06.080 --> 00:21:08.200
it's going to draw into
the current context,

00:21:08.240 --> 00:21:11.870
it's going to be one point wide,
and it's going to go across

00:21:11.870 --> 00:21:13.210
those three points long.

00:21:13.240 --> 00:21:18.500
Now, this is the abstract geometric
description for what would happen.

00:21:18.560 --> 00:21:21.770
However,
we know that pixels are not abstract,

00:21:21.770 --> 00:21:24.310
they're hardware,
and hardware is not nearly

00:21:24.310 --> 00:21:26.290
as malleable as software is,
right?

00:21:26.300 --> 00:21:30.800
On a high retina or a high
DPI display when we drew that,

00:21:30.800 --> 00:21:37.480
it would look great because there's
twice as many pixels as there are points.

00:21:38.100 --> 00:22:38.200
[Transcript missing]

00:22:39.810 --> 00:22:44.380
One other piece of information where you
have to think about that kind of stuff.

00:22:44.440 --> 00:22:50.060
So here we have a point or a line
that's going between these two points.

00:22:50.790 --> 00:22:53.600
And we've set its width to be one wide.

00:22:53.640 --> 00:23:00.290
If we want a one point wide line
to align exactly with pixels,

00:23:00.530 --> 00:23:02.730
And not overdraw like this.

00:23:02.730 --> 00:23:06.980
What we need to do is offset
its point value by .5.

00:23:06.980 --> 00:23:10.860
So that's any time that we
have an odd width on our,

00:23:10.860 --> 00:23:15.220
on the line width,
any time you have an odd value there,

00:23:15.220 --> 00:23:20.230
you're going to want to push the
line .5 one way or the other,

00:23:20.230 --> 00:23:23.110
right or left, or up or down.

00:23:23.420 --> 00:23:26.280
But of course there are many,
many cases where it doesn't

00:23:26.280 --> 00:23:29.150
matter how hard you work,
you're never going to get the thing you

00:23:29.220 --> 00:23:30.980
have described to line up with pixels.

00:23:31.140 --> 00:23:34.720
So,
I'm going to get back on my soapbox now

00:23:34.840 --> 00:23:37.060
and tell you to think geometrically.

00:23:37.150 --> 00:23:40.910
Unless in those rare cases where
you need to be pixel perfect.

00:23:41.080 --> 00:23:43.960
Alright,
so enough about points and lines.

00:23:44.040 --> 00:23:46.670
The next piece is arcs,
and arcs are exactly what you

00:23:46.670 --> 00:23:47.840
learned about in geometry.

00:23:48.040 --> 00:23:51.960
You have a center point,
you have some angle, and a radius,

00:23:51.960 --> 00:23:55.870
and that defines where the arc lies.

00:23:56.460 --> 00:23:57.870
You also have two types of curves.

00:23:58.000 --> 00:24:00.870
The one that's illustrated
here is called a Bezier curve.

00:24:01.010 --> 00:24:02.220
It has two endpoints.

00:24:02.240 --> 00:24:06.560
So you call move to point to
begin the curve and then you call

00:24:06.560 --> 00:24:11.240
this add curve to point control
point one and control point two.

00:24:11.240 --> 00:24:15.400
And those two control points
define the tangent of the

00:24:15.490 --> 00:24:17.830
curve at the two endpoints.

00:24:19.980 --> 00:24:23.660
So as you draw these paths,
eventually you will probably want

00:24:23.720 --> 00:24:28.120
to close them so that they are a
complete geometric package that you

00:24:28.120 --> 00:24:30.110
can then do interesting things with.

00:24:30.210 --> 00:24:33.130
So the way you do that,
you create a path,

00:24:33.240 --> 00:24:36.980
you call move to point,
then you call add line to point,

00:24:37.210 --> 00:24:40.310
you might draw add line to point again.

00:24:40.390 --> 00:24:41.850
Then you'd call closed path.

00:24:42.170 --> 00:24:46.100
Now we have a complete geometric path
that we can then pass around and we can

00:24:46.100 --> 00:24:49.900
maybe be able to fill with that or we
could use it to clip with like we saw

00:24:49.900 --> 00:24:52.710
with the rounded rectangles and so forth.

00:24:53.650 --> 00:24:55.180
Other interesting paths.

00:24:55.260 --> 00:24:59.760
Here I'm creating an arc that goes
all the way around a circle and

00:24:59.760 --> 00:25:02.500
then I call fill and it gets filled.

00:25:02.500 --> 00:25:04.510
Now again,
Core Graphics is going to worry

00:25:04.510 --> 00:25:06.080
about what pixels get filled.

00:25:06.160 --> 00:25:09.050
I just think geometrically.

00:25:09.580 --> 00:25:11.860
So another great thing
that we can do with paths.

00:25:11.930 --> 00:25:15.950
Once we have a path closed,
we can use it to clip with.

00:25:15.990 --> 00:25:21.070
So here's an image and we want to crop it
and we want to put some rounded rectangle

00:25:21.100 --> 00:25:24.920
edges on it so it just looks perfect,
beautiful.

00:25:25.590 --> 00:25:28.270
To do that,
we specify the rectangle that we

00:25:28.320 --> 00:25:31.830
want to pull out of the image,
the cropping rectangle.

00:25:31.980 --> 00:25:36.300
Then we create a UI Bezier path
telling it how big the rectangle is,

00:25:36.310 --> 00:25:38.780
which corners of that
rectangle we want rounded,

00:25:38.870 --> 00:25:43.270
and then what radius we want to
use to round each of those corners.

00:25:43.440 --> 00:25:45.900
Then when we add that
path as the clip path,

00:25:46.070 --> 00:25:47.840
and the clip path is
another piece of state,

00:25:47.900 --> 00:25:52.690
it's another property on the context,
when we add that to the context,

00:25:52.690 --> 00:25:56.820
no pixels that fall outside of that
will be affected by any drawing

00:25:56.850 --> 00:25:59.580
commands until we remove that clip path.

00:25:59.690 --> 00:26:03.490
So when we call image draw
at point or draw in rect,

00:26:03.720 --> 00:26:08.200
it will clip that image inside
our rounded rectangle and

00:26:08.240 --> 00:26:10.550
we'll end up with this image.

00:26:11.990 --> 00:26:17.350
That's a much more efficient
way to approach drawing images

00:26:17.350 --> 00:26:24.900
with rounded corners than it is
to use layers rounded corners,

00:26:24.900 --> 00:26:26.890
CA layers rounded corners.

00:26:26.920 --> 00:26:28.730
Let's go to the demo.

00:26:30.860 --> 00:26:32.790
Okay, so again, remember in our demo
what we're going to do,

00:26:32.810 --> 00:26:36.040
there's seven steps and they're
outlined here in each of these comments.

00:26:36.090 --> 00:26:39.200
We're going to draw the gradient,
we're going to round the corners,

00:26:39.250 --> 00:26:42.800
we're going to put the grid,
we're going to put the horizontal grid,

00:26:43.060 --> 00:26:45.210
then we're going to
draw that line pattern,

00:26:45.440 --> 00:26:47.550
then we're going to
draw the closing data,

00:26:47.550 --> 00:26:51.080
and then the volume data,
and then finally the month names.

00:26:51.770 --> 00:26:55.300
So let's start, make sure my demo script
is set up properly,

00:26:55.300 --> 00:27:00.140
let's start with drawing
the background gradient.

00:27:06.500 --> 00:27:07.740
So the code is straightforward.

00:27:07.740 --> 00:27:09.740
This is exactly what we
saw on the slide earlier.

00:27:09.750 --> 00:27:13.900
We happen to be using a colored gradient
instead of a black and white gradient.

00:27:13.910 --> 00:27:17.400
But we grab the context,
we set the start point,

00:27:17.400 --> 00:27:20.450
we set the end point,
and then we ask the context

00:27:20.450 --> 00:27:22.240
to draw the gradient.

00:27:23.000 --> 00:27:25.220
The gradient that we're
using is hidden behind this

00:27:25.300 --> 00:27:26.900
collapsed code just above here.

00:27:26.900 --> 00:27:27.960
We'll look at it in a second.

00:27:28.030 --> 00:27:32.880
We just grab the gradient, pass that off,
and ask the context to draw that.

00:27:34.300 --> 00:27:36.110
Just to prove I've got
nothing up my sleeve,

00:27:36.160 --> 00:27:38.050
we'll go ahead and look at that code.

00:27:38.050 --> 00:27:40.550
And it's the same thing,
but in this case we're using

00:27:40.550 --> 00:27:44.100
an RGB color space because we
want to have a blue gradient.

00:27:44.170 --> 00:27:48.410
And so we're setting up those colors
with all three of their color components.

00:27:48.710 --> 00:27:51.650
We have four color stops,
and that's how we get that sort

00:27:51.840 --> 00:27:53.400
of hard break in the middle.

00:27:53.400 --> 00:27:58.170
So we set up those four color stops and
that's what makes that look like that.

00:28:05.750 --> 00:28:08.700
It happens to also be a
universal application.

00:28:08.700 --> 00:28:15.300
I wanted it to run in the iPhone,
so let's do that.

00:28:15.320 --> 00:28:20.090
So now we have our blue gradient,
but we're missing the rounded corners.

00:28:30.130 --> 00:28:33.210
So just like again we saw on the slides,
we take a rectangle,

00:28:33.390 --> 00:28:35.450
we tell it which corners
we want to be rounded,

00:28:35.600 --> 00:28:39.060
we tell it the radius to round,
and then we add that to be the clip path.

00:28:39.080 --> 00:28:42.590
Now none of the drawing that we
do is going to fall outside of

00:28:42.590 --> 00:28:44.560
that path that we just set up.

00:28:49.160 --> 00:28:51.340
So now we have our nice rounded corners.

00:28:51.360 --> 00:28:55.010
The next step of course is
to draw our vertical grid.

00:28:55.010 --> 00:28:57.680
And I drew this into a ping file so
that we could talk about it for a

00:28:57.680 --> 00:29:01.220
second because there's some detail
here that I don't want to look at

00:29:01.290 --> 00:29:03.090
in code because it's too much code.

00:29:03.210 --> 00:29:05.780
So if we notice here we have
the three vertical lines that

00:29:05.780 --> 00:29:09.100
represent each of the months in
the data that we're going to draw.

00:29:09.100 --> 00:29:12.100
So the one on the far left hand side,
the next one, and the next one.

00:29:12.100 --> 00:29:15.100
So each of those represent a month.

00:29:15.100 --> 00:29:18.100
On the far right hand side
we have sort of the end cap.

00:29:18.230 --> 00:29:22.490
That marks the area in which to the
right we're going to have labels

00:29:22.490 --> 00:29:25.100
for each of the prices that we have.

00:29:25.100 --> 00:29:29.200
On the bottom we have two horizontal
lines that contain where our

00:29:29.200 --> 00:29:31.100
volume data is going to be.

00:29:31.100 --> 00:29:35.100
So remember we talked
about translating the CTM.

00:29:35.100 --> 00:29:39.470
So what we're going to do is set up
a path that's going to represent each

00:29:39.610 --> 00:29:43.840
of these lines and then we're going
to translate the CTM and reuse that

00:29:43.840 --> 00:29:45.100
path and draw the same exact lines.

00:29:45.210 --> 00:29:51.100
So we're going to do that path four times
in a row by just translating the CTM.

00:29:51.100 --> 00:29:53.100
So let's go make that happen.

00:30:05.390 --> 00:30:07.630
So the first step is
just to set the color,

00:30:07.630 --> 00:30:09.420
and I sampled this color
off of a screenshot.

00:30:09.510 --> 00:30:12.640
You'd probably have an artist
tell you what color to put there.

00:30:12.780 --> 00:30:17.330
And then I tell it to set
itself as the stroke color.

00:30:18.670 --> 00:30:21.520
Next,
I'm creating the line that I'm going

00:30:21.520 --> 00:30:23.810
to use to draw the vertical lines.

00:30:23.810 --> 00:30:26.000
And remember,
we're just going to use one path.

00:30:26.070 --> 00:30:29.880
And this path, since we're reusing it,
it allows Core Graphics again to

00:30:29.880 --> 00:30:33.430
take advantage of all the caching
and bookkeeping that it does to

00:30:33.460 --> 00:30:35.620
make this path draw the first time.

00:30:39.130 --> 00:30:41.340
The next step is to do a
little bit of bookkeeping.

00:30:41.340 --> 00:30:44.470
And I have, again, all of this code is
available in the demo.

00:30:44.690 --> 00:30:49.560
And this is just doing some math
based on the data set that we have.

00:30:49.700 --> 00:30:53.010
The trading day line spacing.

00:30:54.570 --> 00:30:58.050
Remember that in every trading month
there's somewhere between 19 and 24

00:30:58.100 --> 00:31:02.180
trading days per month and we want
the lines for each of our months

00:31:02.180 --> 00:31:04.100
to fall in the appropriate spot.

00:31:04.240 --> 00:31:08.910
And so that trading space per day tells
us how much space we have in each day.

00:31:08.910 --> 00:31:13.140
Then we have another calculation that
we use to calculate how many trading

00:31:13.140 --> 00:31:14.860
days we're in a particular month.

00:31:14.950 --> 00:31:17.280
And so that's what we're using that for.

00:31:19.340 --> 00:31:22.850
The next step is to grab the
graphics context and save the state.

00:31:22.860 --> 00:31:25.290
And again we're saving the state
because we're going to use Translate

00:31:25.360 --> 00:31:28.890
and we want to be able to get
back to the current context.

00:31:29.560 --> 00:31:34.030
So now for each of our sorted months,
so in our case here March, April,

00:31:34.030 --> 00:31:36.920
and May, we're going to go through,
figure out how many trading days

00:31:36.920 --> 00:31:40.800
were in that month in our data set,
and use that to calculate how

00:31:40.860 --> 00:31:44.430
far to the right we want to
move before we draw the line.

00:31:44.530 --> 00:31:47.790
Excuse me, then we draw our line once,
we move over the appropriate amount,

00:31:47.790 --> 00:31:50.430
we draw the line again,
we move over the appropriate amount,

00:31:50.430 --> 00:31:51.890
and we draw the line again.

00:31:51.940 --> 00:31:54.320
So that's the first
three lines for March,

00:31:54.320 --> 00:31:55.270
April, and May.

00:31:55.620 --> 00:31:57.400
Does it make sense?

00:32:00.280 --> 00:32:03.320
Now we've translated the CTM so we
want to make sure to restore it.

00:32:03.320 --> 00:32:06.850
So now we're back to the
context that we started in.

00:32:07.060 --> 00:32:10.760
So the next step is going
to be to draw that end cap,

00:32:10.770 --> 00:32:12.460
the last line on the right hand side.

00:32:12.520 --> 00:32:14.440
So we're going to move
all the way to the right,

00:32:14.520 --> 00:32:18.030
to the end of the data set that we
have and draw that line one more time.

00:32:18.040 --> 00:32:19.950
So now that we have all
of our vertical lines,

00:32:19.950 --> 00:32:24.410
it's time to draw the box that we're
going to put the volume data into.

00:32:24.440 --> 00:32:28.040
And that's basically,
the approach to that is exactly the same.

00:32:28.040 --> 00:32:30.900
We're going to create one
path that's going to go across

00:32:30.960 --> 00:32:32.440
the entire set that we want.

00:32:32.440 --> 00:32:36.620
We're going to draw that and then we're
going to translate in the Y direction

00:32:36.620 --> 00:32:38.800
this time and draw it one more time.

00:32:46.640 --> 00:32:47.980
And there we have our grid.

00:32:48.100 --> 00:32:51.330
So this is the place in which
we're going to draw the remaining

00:32:51.900 --> 00:32:54.790
pieces of our stock graph.

00:32:55.690 --> 00:32:59.060
So now that we have the grid,
the next step is to go and

00:32:59.060 --> 00:33:07.110
draw in the vertical grid.

00:33:10.360 --> 00:33:14.400
Sorry, I just drew the vertical grid,
the horizontal grid.

00:33:14.430 --> 00:33:15.390
Getting ahead of myself.

00:33:15.510 --> 00:33:19.680
So the horizontal grid is going to
be each of those dotted lines that

00:33:19.680 --> 00:33:22.520
shows us where the stock price is.

00:33:23.320 --> 00:33:43.230
And the approach to that is
going to be very similar,

00:33:43.230 --> 00:33:43.230
so I'm not going to spend as much
time going through that code.

00:33:43.230 --> 00:33:43.230
In my case, I chose to draw five lines.

00:33:43.230 --> 00:33:43.230
You might need to draw seven or
two or whatever for your data set,

00:33:43.230 --> 00:33:43.230
but in my case I chose
to draw five lines.

00:33:43.230 --> 00:33:43.230
Again,
they start on the left and they go all

00:33:43.230 --> 00:33:43.230
the way to the right of that rectangle
that we want to draw the data in.

00:33:43.960 --> 00:33:47.090
Now one interesting piece here
that we didn't cover in the

00:33:47.090 --> 00:33:49.160
slides is this dash pattern.

00:33:49.360 --> 00:33:53.780
So this is specifying one point on,
one point off, and set that as the dash

00:33:53.870 --> 00:33:54.890
pattern for the line.

00:33:54.900 --> 00:33:58.120
So anytime that this line is drawn,
it's going to have one

00:33:58.120 --> 00:33:59.890
point on and one point off.

00:34:05.720 --> 00:34:07.240
So pretty close.

00:34:07.250 --> 00:34:11.100
Now we have the lines that we need,
but they're not clipped to our data,

00:34:11.100 --> 00:34:11.300
right?

00:34:11.300 --> 00:34:13.460
And it's really important that it
gets clipped to the data because

00:34:13.460 --> 00:34:16.270
that's what gives it that beautiful
detail of one pattern on the top

00:34:16.270 --> 00:34:18.060
and a different pattern on the top.

00:34:18.100 --> 00:34:21.050
I mean,
one on the bottom and one on the top.

00:34:21.680 --> 00:34:23.760
So let's look at how we do that.

00:34:23.850 --> 00:34:28.750
And you can probably guess that what
we need to do is save the context

00:34:28.750 --> 00:34:31.140
state and get a clipping path.

00:34:31.250 --> 00:34:34.170
Now the clipping path that
we're drawing here though is I'm

00:34:34.170 --> 00:34:38.310
hiding it behind this method,
top clip path from data in rect.

00:34:38.440 --> 00:34:43.480
The way I created that was took the path
that I create for all of my closing data

00:34:43.640 --> 00:34:45.630
where the stock value closed on each day.

00:34:45.920 --> 00:34:47.340
That creates one path.

00:34:47.450 --> 00:34:50.080
Then I start on the right hand
side at the end of that data set.

00:34:50.190 --> 00:34:52.790
I go up to the top of my rectangle.

00:34:52.870 --> 00:34:57.220
I go all the way back to the left
down to the first data point in my

00:34:57.220 --> 00:34:59.740
data set and then close the path.

00:34:59.890 --> 00:35:04.080
That strangely shaped path
then becomes my clipping path.

00:35:04.140 --> 00:35:08.290
So any drawing that happens that's
outside of that area is going to be

00:35:08.400 --> 00:35:10.870
clipped and not shown on the screen.

00:35:18.380 --> 00:35:21.470
So now when I draw,
I get my horizontal lines,

00:35:21.560 --> 00:35:24.530
they're drawn in,
and you can see that they're clipped.

00:35:24.700 --> 00:35:26.910
But we still can't see
where the data lies.

00:35:27.060 --> 00:35:31.990
So let's go draw that nice
line pattern underneath.

00:35:40.340 --> 00:35:43.120
And the approach here is going to be
very similar to what we've done already.

00:35:43.130 --> 00:35:47.060
We're going to draw some lines,
translate the context,

00:35:47.100 --> 00:35:48.120
draw some lines again.

00:35:48.140 --> 00:35:51.180
Oops,
very important point I forgot to do.

00:35:51.180 --> 00:35:55.270
I told you guys never to forget to
do that and then I forgot to do it.

00:35:57.620 --> 00:36:03.730
Since I added that clipping
path to my horizontal grid and

00:36:03.830 --> 00:36:08.280
I forgot to restore the context,
now the top clipping path is set up.

00:36:08.360 --> 00:36:11.370
And if I had proceeded with writing
code and clipped to the bottom,

00:36:11.570 --> 00:36:14.040
we would see no new drawing
and then I would have panicked

00:36:14.040 --> 00:36:16.870
because I would have not been
able to see what was going on.

00:36:16.960 --> 00:36:20.790
So let's go add that down here.

00:36:22.010 --> 00:36:25.380
Now we're back in a consistent state.

00:36:25.430 --> 00:36:27.340
So actually a great learning opportunity.

00:36:27.340 --> 00:36:29.520
If you're drawing stuff and
you're setting up clipping

00:36:29.520 --> 00:36:32.560
paths and you see zero,
nothing on the screen,

00:36:32.620 --> 00:36:34.780
it's probably because you've
done something weird with your

00:36:34.820 --> 00:36:38.020
clipping path and you're not
allowing anything to be drawn.

00:36:38.120 --> 00:36:41.110
And a great debugging tip,
what I do when I'm in that situation

00:36:41.180 --> 00:36:45.260
is I take that path that I'm using
as the clip path and I draw it.

00:36:45.520 --> 00:36:48.220
Set my line width to be five,
set the color to be black,

00:36:48.240 --> 00:36:49.520
and just draw that path.

00:36:49.660 --> 00:36:53.120
And then at least I can see what
in the world it's clipping to.

00:36:53.120 --> 00:36:55.360
So, debugging tips.

00:36:55.520 --> 00:36:58.760
Alright, draw pattern under closing path.

00:36:59.120 --> 00:37:03.470
So the first thing we want to do is grab
the context and then create our path.

00:37:03.470 --> 00:37:05.890
And in this case we're setting
the line width to be one.

00:37:06.440 --> 00:37:12.240
Whenever we have an odd width we
want to make sure that we offset .5.

00:37:12.240 --> 00:37:15.890
If we wanted to fall right on a
point boundary we want to offset by

00:37:16.030 --> 00:37:18.510
.5 so that's what we're doing here.

00:37:20.840 --> 00:37:23.460
Then the next piece is
to grab this alpha step.

00:37:23.460 --> 00:37:27.580
So we want to start with our
alpha set to .8 and we want it to

00:37:27.680 --> 00:37:30.240
fade down to our alpha being .2.

00:37:30.240 --> 00:37:32.150
So we start at .8 and
we come up with a step.

00:37:32.240 --> 00:37:37.070
How much should we decrement the
alpha value essentially on each step?

00:37:37.480 --> 00:37:40.410
And that's the math to do that.

00:37:40.760 --> 00:37:44.620
Next we want to save the graphic state,
create our line,

00:37:44.900 --> 00:37:49.790
figure out how far we want to translate
the CTM in the Y direction each time,

00:37:49.790 --> 00:37:54.090
and then update the stroke color
with every time changing the alpha

00:37:54.090 --> 00:37:58.870
value to be a little bit more clear,
a little bit more clear, and so forth.

00:38:01.210 --> 00:38:03.610
And now if I draw this,
you can probably guess this too,

00:38:03.710 --> 00:38:07.200
it would draw over the entire data rect,
which is not what we want.

00:38:07.200 --> 00:38:09.990
We only want it to fall below.

00:38:16.530 --> 00:38:20.270
So let's grab the context and then
in this time we're going to get

00:38:20.270 --> 00:38:23.470
the bottom clip path which does
exactly the same thing that the top

00:38:23.570 --> 00:38:25.140
clip path does except it's flipped.

00:38:25.290 --> 00:38:29.040
So I go to the end of my data set,
I go down to the corner,

00:38:29.150 --> 00:38:32.890
back all the way to the left,
and then up to the beginning of my data

00:38:32.890 --> 00:38:35.120
set and clip to inside of that path.

00:38:36.850 --> 00:38:40.000
So, this method is deceptively
simple looking,

00:38:40.000 --> 00:38:40.680
right?

00:38:40.710 --> 00:38:45.530
This is just grabbing the path for our
closing data and then setting the stroke

00:38:45.660 --> 00:38:48.250
color to white and then drawing it.

00:38:59.170 --> 00:39:02.390
So barring the line pattern
underneath that I've totally

00:39:02.390 --> 00:39:07.670
messed up and can't make work,
I apologize, the sample code works.

00:39:12.760 --> 00:39:14.880
So now we see our
closing data showing up.

00:39:15.030 --> 00:39:18.840
The next step is to draw the
volume data across the bottom.

00:39:30.780 --> 00:39:34.860
One thing I wanted to show though before
we move on to drawing the volume data.

00:39:34.930 --> 00:39:39.780
So here's the method that's going
to create that path for the data.

00:39:40.170 --> 00:39:44.500
Now it looks like a lot of code but
really all it's doing is scaling,

00:39:44.500 --> 00:39:47.920
taking all of my closing data
and scaling it to fit within that

00:39:48.200 --> 00:39:50.410
rectangle that I have to draw it in.

00:39:50.580 --> 00:39:55.360
So it's really just a whole bunch of
different math to scale it properly

00:39:55.360 --> 00:39:58.670
and then it's calling move to point,
line to point, line to point,

00:39:58.670 --> 00:40:01.060
line to point, line to point for each
one of those things.

00:40:01.060 --> 00:40:02.930
So it really is pretty simple.

00:40:03.060 --> 00:40:07.050
It's just a bit of math to
make it all fit together.

00:40:14.240 --> 00:40:16.790
So the first thing we want to
do on drawing the volume data,

00:40:16.840 --> 00:40:20.120
now remember for every trading day we're
going to have some volume amount so we

00:40:20.120 --> 00:40:24.210
want to move along by that trading day
spacing that we saw earlier and we want

00:40:24.210 --> 00:40:28.800
to draw a line from the maximum value
down to the bottom of our rectangle.

00:40:28.940 --> 00:40:33.280
So this is doing all the math to set
us up to be able to do that and then

00:40:33.280 --> 00:40:35.830
we set white to be the stroke color.

00:40:36.290 --> 00:40:39.860
The next step is to iterate
through all of that data and then

00:40:39.860 --> 00:40:43.630
create a new path for each one of
these lines that we want to draw.

00:40:43.780 --> 00:40:48.910
Now in this case we can't use the
translate trick here to reuse the

00:40:48.910 --> 00:40:53.200
path again and again because each of
those paths are a different height.

00:40:53.280 --> 00:40:56.970
So we're going to create a path,
set its two endpoints,

00:40:57.000 --> 00:41:00.510
and then draw the path
and then release the path.

00:41:07.980 --> 00:41:10.900
And now we see the volume data.

00:41:10.940 --> 00:41:12.320
So that's it for this piece.

00:41:12.380 --> 00:41:18.840
The next thing is to go back
and talk about drawing text.

00:41:22.770 --> 00:41:26.160
So because I explained
to you how to debug it,

00:41:26.180 --> 00:41:27.400
it went south on stage.

00:41:27.400 --> 00:41:31.200
During my practice things I never told
anybody about how to debug that problem.

00:41:31.200 --> 00:41:33.590
So it's the demo monkey.

00:41:33.690 --> 00:41:35.400
I forgot to sacrifice
a goat or something.

00:41:35.400 --> 00:41:36.980
Okay, so demo wrap up.

00:41:36.980 --> 00:41:39.490
So we learned how to draw these lines.

00:41:39.490 --> 00:41:43.460
We learned how to apply a clipping
path with some group of data.

00:41:43.460 --> 00:41:46.930
And we also talked about
how to get crisp lines.

00:41:46.970 --> 00:41:49.900
Remember whenever you have an odd width,
if you want it to be crisp,

00:41:49.940 --> 00:41:52.280
you need to move it 0.5
one way or the other.

00:41:55.300 --> 00:41:58.240
So text drawing, there's two ways that
you can approach that.

00:41:58.290 --> 00:42:02.780
In UIKit there's a bunch of extensions
to the NSString class that allow you to

00:42:02.780 --> 00:42:06.620
find out interesting information like how
should I lay this text out and so forth,

00:42:06.660 --> 00:42:08.150
and then draw the text.

00:42:08.300 --> 00:42:12.180
But if you have serious text needs,
you need to look at Core Text.

00:42:12.340 --> 00:42:15.850
It's a full featured layout engine,
there's tons and tons of great features,

00:42:16.050 --> 00:42:19.120
and it will draw paragraphs and a
bunch of different fonts and so forth,

00:42:19.120 --> 00:42:20.300
it's really cool.

00:42:20.360 --> 00:42:23.120
We're not gonna talk about Core Text,
we're gonna talk about

00:42:23.200 --> 00:42:24.670
the UIKit approach.

00:42:24.870 --> 00:42:27.700
So you can do things like
give me the size with font.

00:42:27.800 --> 00:42:30.600
So you pass in the font and
the NSString will return to

00:42:30.600 --> 00:42:32.440
you a size that it will fit in.

00:42:32.500 --> 00:42:37.210
Knowing that size you can then use
that information to lay that text out.

00:42:37.310 --> 00:42:40.080
If you have multi-line text,
you can tell it a rectangle that

00:42:40.120 --> 00:42:44.080
you want it to draw in and it will
return to you a size in which it

00:42:44.180 --> 00:42:47.050
thinks it can fit all of that text.

00:42:47.560 --> 00:42:50.670
Once you know that,
you can calculate this point and

00:42:50.670 --> 00:42:53.620
tell it to draw at that point.

00:42:53.690 --> 00:42:56.490
And the same thing for
a bigger group of text.

00:42:56.550 --> 00:42:59.720
Once you know the information,
you would calculate your text

00:42:59.720 --> 00:43:01.770
recs and then have it draw.

00:43:02.080 --> 00:43:04.380
So again, I just want to drive
this home one more time.

00:43:04.500 --> 00:43:07.790
You cannot draw strings in your
tap gesture recognizer code.

00:43:07.920 --> 00:43:11.130
You have to have a context,
and in the event processing case,

00:43:11.320 --> 00:43:13.000
you don't have a context yet.

00:43:13.140 --> 00:43:17.230
Instead, tell it you need to display.

00:43:18.960 --> 00:43:23.870
If you want to know more about Core Text,
last year we had this great talk called

00:43:24.020 --> 00:43:26.900
Advanced Text Handling for iPhone OS.

00:43:26.900 --> 00:43:29.100
There's some sample code
that will actually draw the

00:43:29.240 --> 00:43:32.420
Constitution and a bunch of other
stuff in great interesting fonts.

00:43:32.420 --> 00:43:35.370
So go grab that at ADC on iTunes.

00:43:37.140 --> 00:43:38.820
Okay, now we've seen how to draw
the text across the bottom,

00:43:38.840 --> 00:43:40.910
but of course we also want
some nice shadows there.

00:43:40.910 --> 00:43:45.880
Shadow state is another piece
of information on the context.

00:43:45.880 --> 00:43:50.720
So we set that up by setting up a shadow,
telling it its offset, color,

00:43:50.720 --> 00:43:52.100
and blur radius.

00:43:52.100 --> 00:43:55.230
But it's really important
that we use this GState call

00:43:55.700 --> 00:43:58.730
because once we set the shadow,
all drawing from that point

00:43:58.860 --> 00:44:01.060
forward will use that same shadow.

00:44:01.060 --> 00:44:03.970
So we want to set it,
draw our shadowed stuff,

00:44:03.970 --> 00:44:06.110
and then call restore context.

00:44:06.160 --> 00:44:09.200
so that we go back to non-shadow drawing.

00:44:09.750 --> 00:44:13.930
So this is how we would set up some
text that we want to draw with a shadow.

00:44:14.030 --> 00:44:16.330
We set our shadow height to two,
we're going to set our

00:44:16.340 --> 00:44:19.450
shadow color to dark gray,
or actually in this case because it's

00:44:19.450 --> 00:44:21.520
hard to see dark gray I set it to orange.

00:44:21.590 --> 00:44:24.880
I asked it to draw and then
it shows up with a shadow.

00:44:24.970 --> 00:44:28.780
And then I call restoreGState and
any further drawing that happens

00:44:28.820 --> 00:44:30.880
isn't going to have that shadow.

00:44:31.490 --> 00:44:34.290
So I want to take a step back and
talk about this painter's algorithm

00:44:34.300 --> 00:44:36.550
which is the way that Quartz draws.

00:44:36.550 --> 00:44:38.000
And it's like when you paint your house.

00:44:38.050 --> 00:44:40.140
When you paint with red color
and you decide you don't like

00:44:40.280 --> 00:44:43.260
red and you paint with blue,
the color that you see is blue.

00:44:43.360 --> 00:44:45.300
Quartz uses that same approach.

00:44:45.300 --> 00:44:49.340
Now of course it takes into account alpha
and it will do blending and so forth,

00:44:49.340 --> 00:44:53.360
but the general idea is that whatever
the last color to go down is what wins.

00:44:54.140 --> 00:44:57.240
So if you were to draw these three
circles with three different colors,

00:44:57.240 --> 00:44:58.460
it would look like this.

00:44:58.460 --> 00:45:01.030
And since the red was the
last thing to be drawn,

00:45:01.140 --> 00:45:03.330
that's the thing that you see on top.

00:45:03.980 --> 00:45:06.530
In the shadow case,
and this is something that a

00:45:06.530 --> 00:45:08.330
lot of people get wrong and
they don't know how to do it,

00:45:08.340 --> 00:45:10.290
which is why I wanted to
make sure and put it in here.

00:45:10.310 --> 00:45:12.410
Our sample won't actually
run into this problem,

00:45:12.410 --> 00:45:13.900
but it's a really common thing.

00:45:13.900 --> 00:45:16.350
We set the shadow,
we draw those three circles,

00:45:16.390 --> 00:45:19.860
and the shadows look nothing like
what we wanted them to look like.

00:45:19.920 --> 00:45:21.780
The shadows overlay.

00:45:21.900 --> 00:45:25.870
So remember the shadow state
sort of lives with the context,

00:45:25.920 --> 00:45:29.050
and any drawing that you tell
the context to do is going

00:45:29.050 --> 00:45:30.850
to have that shadow applied.

00:45:30.950 --> 00:45:34.020
So since these three shapes
were drawn separately,

00:45:34.060 --> 00:45:37.810
they each get their own shadow,
so those shadows overlay.

00:45:38.620 --> 00:45:40.600
So if that's not the
effect that you want,

00:45:40.650 --> 00:45:44.590
if you want all of them to be together
and to end up drawing with one shadow,

00:45:44.600 --> 00:45:46.700
you would use this thing
called a transparency layer.

00:45:46.780 --> 00:45:48.200
It's sort of like a grouping thing.

00:45:48.200 --> 00:45:53.370
It says take some interesting pieces of
the context state like shadows and only

00:45:53.370 --> 00:45:56.000
apply them after all the drawing is done.

00:45:56.310 --> 00:45:59.110
Okay, so let's go back to the
demo machine one more time,

00:45:59.110 --> 00:46:02.050
or real quick, to look at text drawing.

00:46:11.320 --> 00:46:16.040
So we want our month
names to be localized.

00:46:16.050 --> 00:46:19.260
And I don't have time to go into all
the detail about how localization works.

00:46:19.260 --> 00:46:21.080
Again, we've had a lot of
great talks about that.

00:46:21.150 --> 00:46:24.870
But you can't just assume January,
February, March.

00:46:24.870 --> 00:46:27.860
Some calendars have 13 months,
some have 13 some years,

00:46:27.870 --> 00:46:29.260
and 12 others months.

00:46:29.260 --> 00:46:30.500
It's really complicated.

00:46:30.500 --> 00:46:32.580
Who wants to keep all
that stuff in their head?

00:46:32.630 --> 00:46:35.340
We've written it down into
something called NS Calendar.

00:46:35.420 --> 00:46:35.830
Use it.

00:46:35.830 --> 00:46:37.360
And that's what this code does.

00:46:37.360 --> 00:46:40.510
So go take a look at the sample
code and then some old WWDC stuff.

00:46:41.000 --> 00:46:42.810
So we do that setup stuff.

00:46:42.810 --> 00:46:47.020
And then remember that we
want each of these month names

00:46:47.030 --> 00:46:49.240
to fall under these lines.

00:46:49.240 --> 00:46:51.310
So we have one line
for each of our month.

00:46:51.440 --> 00:46:53.930
So we want those names to
fall in those locations.

00:46:53.930 --> 00:46:57.660
So we're using our daily trading
space calculation again to

00:46:57.740 --> 00:47:01.040
find out how far over March,
April, and May should fall.

00:47:01.120 --> 00:47:03.080
So we do those calculations.

00:47:03.220 --> 00:47:07.190
We figure out how wide the month is,
what the name of the month is,

00:47:07.190 --> 00:47:09.600
how wide it is, then we lay it out.

00:47:12.300 --> 00:47:15.580
"And now we have our text
labels across the bottom,

00:47:15.620 --> 00:47:16.900
but there's no shadows yet.

00:47:16.900 --> 00:47:18.890
So let's go do that."

00:47:20.600 --> 00:47:25.600
We're going to do that right here
after we save our graphic state.

00:47:25.620 --> 00:47:30.210
And I don't have an additional graphic
state saved here so I don't have to add

00:47:30.210 --> 00:47:33.010
an additional restore at the bottom.

00:47:36.620 --> 00:47:38.410
So now when I run,
I have the nice shadows

00:47:38.510 --> 00:47:39.720
at the bottom of my text.

00:47:39.870 --> 00:47:41.540
So we're almost there.

00:47:41.550 --> 00:47:44.290
And actually, we are done with what
I showed you in the agenda,

00:47:44.340 --> 00:47:46.930
but I have one extra piece
because we have six and a half

00:47:46.930 --> 00:47:50.870
minutes left that I want to show
you that I think is really fun.

00:47:51.000 --> 00:47:53.680
So let's go back over to slides.

00:47:54.920 --> 00:47:58.140
So we're almost there.

00:47:58.210 --> 00:47:59.790
Images.

00:47:59.850 --> 00:48:02.190
UIKit can draw images.

00:48:02.460 --> 00:48:04.400
And I want you to feel
free to draw images,

00:48:04.430 --> 00:48:10.470
but UI Image View is much more efficient
than drawing your own images this way.

00:48:10.610 --> 00:48:13.910
So if you have images and you want
to put the full image on screen,

00:48:14.100 --> 00:48:15.400
use a UI Image View.

00:48:15.400 --> 00:48:18.600
If you must draw an image,
you can use Draw at

00:48:18.600 --> 00:48:20.410
Point and Draw in Rect.

00:48:21.520 --> 00:48:23.770
Now in the sample I spilled this
earlier and I showed the code,

00:48:23.770 --> 00:48:26.250
I didn't want to, so I want you guys to
download it and play with it.

00:48:26.350 --> 00:48:30.790
There's a method in there that
will pull this beach thing and

00:48:30.800 --> 00:48:32.100
draw it inside a clipping path.

00:48:32.200 --> 00:48:35.220
So feel free to go after
it and mess with that.

00:48:35.820 --> 00:48:39.150
Earlier today there was
Understanding UI Kit Rendering,

00:48:39.190 --> 00:48:43.750
which talks in depth about why using
this approach is less efficient

00:48:43.750 --> 00:48:45.820
than using a UI Image View.

00:48:46.750 --> 00:48:49.780
Okay, so the last piece,
I love this stuff.

00:48:50.320 --> 00:48:52.680
It's sort of ugly, but I love it.

00:48:52.680 --> 00:48:53.830
It's ugly because I drew it.

00:48:53.950 --> 00:48:55.720
If I had an artist, it would be awesome.

00:48:55.720 --> 00:49:00.840
So a pattern is a single image that's
drawn repeatedly to fill some space.

00:49:00.840 --> 00:49:04.240
So in this case,
I used Core Graphics to draw this

00:49:04.320 --> 00:49:07.360
really simple 48 by 48 image.

00:49:07.360 --> 00:49:11.480
And it's just a radial gradient
with two lines across the corner.

00:49:11.480 --> 00:49:17.440
And then I call UIColor
Color with Pattern,

00:49:17.440 --> 00:49:20.670
and that pattern image becomes
then sort of a fill color that

00:49:20.710 --> 00:49:22.420
I can just fill this thing with.

00:49:22.570 --> 00:49:26.810
And so I set the background
color to be that pattern.

00:49:27.470 --> 00:49:29.160
and that's how I ended
up with the background.

00:49:29.280 --> 00:49:31.710
But don't be afraid to
do this in Draw Rect.

00:49:31.810 --> 00:49:35.090
I know earlier I sort of said, "Look,
if you can set the background color,

00:49:35.090 --> 00:49:38.400
set the background color." But you
can also use patterns in Draw Rect and

00:49:38.400 --> 00:49:41.020
they can be really efficient as well.

00:49:41.650 --> 00:49:44.180
So as homework,
in addition to putting the beach

00:49:44.260 --> 00:49:47.960
picture behind your stock graph,
I also want you to take that

00:49:48.080 --> 00:49:52.200
48 by 48 pattern and use that
to stroke the stock path.

00:49:52.370 --> 00:49:55.430
It looks pretty,
I don't know if cool is the right word,

00:49:55.430 --> 00:49:56.820
but it looks interesting.

00:49:56.820 --> 00:49:59.680
Okay, so I want to show you a
demo of using patterns,

00:49:59.680 --> 00:50:02.850
and I'm not sure how well it's
going to work out because it's

00:50:02.850 --> 00:50:06.280
supposed to show up in the bottom,
but we'll give it a shot.

00:50:07.120 --> 00:50:09.830
Okay,
so the pattern stuff is going to work.

00:50:09.830 --> 00:50:11.220
It's going to be magical, you'll love it.

00:50:11.510 --> 00:50:14.560
Okay, so I grab the image,
I set it to be the color,

00:50:14.560 --> 00:50:16.610
and then I'm getting
that bottom clip path,

00:50:16.830 --> 00:50:20.080
which is again my stock data and
down and right and left or whatever,

00:50:20.210 --> 00:50:23.350
and then I take that path and
I fill it with my pattern color.

00:50:35.500 --> 00:50:39.340
So it's kind of ugly,
but it's still pretty cool, right?

00:50:39.340 --> 00:50:42.630
I took this 48 by 48 image
that I created with Quartz and

00:50:42.630 --> 00:50:43.760
I stuck it in the background.

00:50:43.760 --> 00:50:47.040
Now, or I stuck it inside this
sort of really cool path.

00:50:47.120 --> 00:50:49.840
Now, observant,
if you're really observant,

00:50:49.840 --> 00:50:53.410
you'll notice that that pattern
is clipping half of our path.

00:50:53.510 --> 00:50:56.940
So remember how I talked to you how a
path is going to draw half of its stroke

00:50:56.940 --> 00:51:00.410
on the top and half on the bottom or
half to the right or half to the left?

00:51:00.510 --> 00:51:05.470
Since we drew this pattern
after we drew our path,

00:51:05.470 --> 00:51:05.480
we're going to draw half of its stroke
on the top and half on the bottom.

00:51:05.680 --> 00:51:11.340
So if we want to fix that,
we take advantage of our knowledge

00:51:11.340 --> 00:51:17.610
of the painter's algorithm and we
go back down here to draw rect.

00:51:18.700 --> 00:51:26.500
And we grab the line that's drawing that
and we put that above our closing data.

00:51:31.610 --> 00:51:34.100
And now since the
pattern gets drawn first,

00:51:34.110 --> 00:51:36.560
we see the full width of our path.

00:51:36.560 --> 00:51:39.480
So that's the end of the demo.

00:51:39.530 --> 00:51:42.670
Whoever sacrificed the goat,
thank you very much.

00:51:50.200 --> 00:51:53.260
So now when you download the
sample code you'll be able to draw

00:51:53.260 --> 00:51:55.890
this and that's the full thing.

00:51:56.710 --> 00:51:58.860
So in summary,
you can draw that with Quartz and

00:51:58.920 --> 00:52:01.990
I cannot wait to see the amazingly
cool stuff that you guys go and

00:52:01.990 --> 00:52:05.600
do with this knowledge when you
get out there after the beer bash.

00:52:05.600 --> 00:52:07.600
So draw in context.

00:52:07.600 --> 00:52:09.600
You have to have a context.

00:52:09.600 --> 00:52:12.540
You can't do it without a
context and think geometrically.

00:52:12.640 --> 00:52:15.600
So finally, if you have any questions,
feel free to send me an email.

00:52:15.800 --> 00:52:16.600
There's documentation.

00:52:16.600 --> 00:52:18.740
Please say hi.
WEBVTT

00:00:10.900 --> 00:00:12.260
Hi, everyone.

00:00:12.290 --> 00:00:14.300
Welcome to WWDC.

00:00:14.380 --> 00:00:15.790
I'm Anton D'Auria.

00:00:15.800 --> 00:00:18.230
I'm an engineer at iOS Safari and WebKit.

00:00:18.350 --> 00:00:20.490
And today,
we're going to talk about hidden

00:00:20.560 --> 00:00:26.220
gems for web apps and how you can
make your web apps look great on iOS.

00:00:29.940 --> 00:00:34.060
Safari revolutionized the way
we experience the mobile web.

00:00:34.200 --> 00:00:41.090
It was the first mobile browser
that showed us the real internet.

00:00:41.490 --> 00:00:47.730
And it took a step further and allowed us
to touch the web with intuitive gestures.

00:00:48.840 --> 00:00:53.830
And for developers,
Safari pioneered HTML5

00:00:53.830 --> 00:00:57.700
technologies like CSS3 transforms,
transitions, animations,

00:00:57.740 --> 00:01:01.950
audio/video tags that make
it simple and easier to make

00:01:02.260 --> 00:01:04.690
beautiful interactive websites.

00:01:05.550 --> 00:01:10.530
But there are other technologies that you
can take advantage of in your web apps,

00:01:10.570 --> 00:01:12.820
and that's what we'll discuss today.

00:01:16.600 --> 00:01:19.010
So what you'll learn today,
what are we going to go over?

00:01:19.210 --> 00:01:23.440
First, touch and gestures,
how you can add intuitive

00:01:23.440 --> 00:01:27.760
UI that users are familiar with.

00:01:28.640 --> 00:01:33.040
We're going to talk about geolocation,
making your apps aware

00:01:33.040 --> 00:01:37.110
of where the user is,
adding greater context to your app.

00:01:39.660 --> 00:01:43.200
We'll talk about motion,
making your app aware of how

00:01:43.200 --> 00:01:46.080
the user is holding the device,
how they're physically

00:01:46.080 --> 00:01:47.470
interacting with it.

00:01:48.160 --> 00:01:53.980
And we'll go over how you can make your
web app work offline and faster online.

00:01:54.530 --> 00:01:57.680
And in addition to the
HTML5 technologies,

00:01:57.690 --> 00:02:01.550
we'll also go over some ways in
which you can make your app look

00:02:01.550 --> 00:02:05.050
really good in iOS as an iOS app.

00:02:06.020 --> 00:02:09.590
Over the course of the talk,
we're going to take a website,

00:02:09.600 --> 00:02:12.400
which we call Destinations,
that shows us beautiful

00:02:12.400 --> 00:02:15.450
sites around the world,
and we're going to transform it

00:02:15.450 --> 00:02:21.250
into an iOS web app that will
be aware of where the user is,

00:02:21.250 --> 00:02:21.250
what's relevant to them,

00:02:21.610 --> 00:02:24.410
It's going to be aware of how
the user is holding the device,

00:02:24.420 --> 00:02:27.340
so it'll have an orientation,
and it'll work offline,

00:02:27.340 --> 00:02:31.610
and it'll look great as an iOS app.

00:02:32.650 --> 00:02:35.190
So first, touch and gestures.

00:02:35.350 --> 00:02:39.110
They've been available for years on iOS,
and users have come to expect that.

00:02:39.230 --> 00:02:40.630
They know how to use touch and gestures.

00:02:40.640 --> 00:02:43.630
But you may ask,
is it really available in JavaScript,

00:02:43.700 --> 00:02:44.750
HTML, and CSS?

00:02:44.760 --> 00:02:46.910
Yes, it is.

00:02:46.910 --> 00:02:49.880
But before we dive into
the Destinations project,

00:02:49.880 --> 00:02:54.180
I think it's simpler to
start with a small example,

00:02:54.180 --> 00:02:58.660
and I'd like to show you how I use touch
and gestures on just two DOM elements.

00:03:00.780 --> 00:03:02.080
So I'm switching to a demo.

00:03:02.300 --> 00:03:05.710
Here, overhead display.

00:03:08.600 --> 00:03:12.620
And here you see a simple website.

00:03:12.700 --> 00:03:14.700
And I place a finger down.

00:03:16.650 --> 00:03:20.480
And this site is actually
tracking my finger.

00:03:20.480 --> 00:03:22.450
You can see with the blue circle.

00:03:22.550 --> 00:03:25.880
It's aware of my finger
moving and tracking it.

00:03:26.160 --> 00:03:29.580
This would be impossible
with mouse events.

00:03:35.900 --> 00:03:39.400
I can place a finger down,
and I can start moving around with

00:03:39.400 --> 00:03:42.440
a little bit of JavaScript and CSS.

00:03:42.440 --> 00:03:45.170
I can move divs around.

00:03:46.680 --> 00:03:50.480
I can also design gestures
that make sense in my app.

00:03:50.510 --> 00:03:53.580
Like I want a color change gesture.

00:03:53.720 --> 00:03:58.880
So with a two finger tap,
I change the color of that div.

00:04:00.400 --> 00:04:03.290
And users are also familiar
with pinch and zoom,

00:04:03.290 --> 00:04:06.570
when your app has things
that can be enlarged,

00:04:06.670 --> 00:04:08.680
like photos or maps.

00:04:09.010 --> 00:04:15.820
And just placing two fingers down,
I can start scaling and rotating.

00:04:15.910 --> 00:04:20.130
And you can see as my fingers move apart,
I'm enlarging.

00:04:23.640 --> 00:04:28.030
And I'm rotating.

00:04:28.570 --> 00:04:32.230
And so you can make custom
gestures with touch events.

00:04:32.470 --> 00:04:39.500
And touch events play nicely with the new
system gestures on iOS that allow you to

00:04:39.760 --> 00:04:44.780
Open up the multitasking bar,
which you can see here.

00:04:45.150 --> 00:04:53.590
Or if the user decides to do a
four-finger pinch to close the app,

00:04:53.820 --> 00:04:57.380
your app will be able to
handle that case as well.

00:05:01.920 --> 00:05:05.200
How do we do this in JavaScript?

00:05:05.200 --> 00:05:10.460
Well,
I'd like to tell you a little bit about

00:05:10.520 --> 00:05:11.890
the touch event model in JavaScript.

00:05:12.030 --> 00:05:17.900
First, when you place a finger down,
a touch start event is fired.

00:05:17.900 --> 00:05:21.900
As the finger moves,
touch move events fire,

00:05:21.900 --> 00:05:24.150
and when you lift the
finger from the screen,

00:05:24.300 --> 00:05:26.150
touch end fires.

00:05:26.700 --> 00:05:31.550
If a user gets a phone call on iPhone,
or he performs a system gesture,

00:05:31.550 --> 00:05:34.600
or the screen is dimmed,
a touch cancel event comes in.

00:05:34.600 --> 00:05:38.570
And this is especially important
for you to handle because you'll

00:05:38.620 --> 00:05:43.170
need to update the state of your
UI that responds to touch events.

00:05:44.460 --> 00:05:47.260
And if you have any custom gestures,
you'll need to update the state of

00:05:47.260 --> 00:05:50.140
those recognizers with touch cancel.

00:05:50.870 --> 00:05:55.980
So let's see, what actually-- what do we
have to write in JavaScript?

00:05:56.120 --> 00:05:58.570
So let's say when we track three fingers.

00:05:58.750 --> 00:06:00.610
Start with touch start.

00:06:01.060 --> 00:06:03.550
We add an event listener
for a touch start event,

00:06:03.550 --> 00:06:07.330
and we have our callback
handle touch start.

00:06:07.950 --> 00:06:10.800
In our callback,
we get a touch event object.

00:06:10.930 --> 00:06:12.800
What does the object look like?

00:06:12.820 --> 00:06:15.800
The touch event object
has three properties.

00:06:15.800 --> 00:06:20.020
First, a list of touches
representing each finger.

00:06:20.950 --> 00:06:25.700
that are present on the
screen during this event.

00:06:25.800 --> 00:06:29.110
Then we have another list.

00:06:29.400 --> 00:06:33.310
I call it Change Touches,
and it only contains touch

00:06:33.380 --> 00:06:38.310
objects for the fingers that
have moved since the last event.

00:06:40.420 --> 00:06:45.940
And the next property is another list,
target touches.

00:06:46.010 --> 00:06:51.400
This contains touch objects
that are on the element that

00:06:51.400 --> 00:06:53.930
is listening to touch events.

00:06:54.180 --> 00:06:56.240
So let's go over this again.

00:06:56.740 --> 00:06:58.400
Three fingers are down.

00:06:58.560 --> 00:07:02.120
We have three elements in
the touches on touch start.

00:07:03.990 --> 00:07:09.040
Then, if only one of the
three fingers has moved,

00:07:09.090 --> 00:07:12.790
change touches has one object,
one touch object.

00:07:15.310 --> 00:07:20.040
And if all three fingers are
still on the element that is

00:07:20.040 --> 00:07:24.540
listening to the touch events,
target touches will have three touches.

00:07:25.040 --> 00:07:29.460
And so in this case,
when I had my two fingers on the red div,

00:07:29.530 --> 00:07:30.940
how many touch objects were there?

00:07:30.980 --> 00:07:31.880
Two.

00:07:32.370 --> 00:07:34.140
One for each finger.

00:07:35.870 --> 00:07:37.460
So what do the touch
objects actually look like?

00:07:37.460 --> 00:07:38.640
What are their properties?

00:07:38.700 --> 00:07:42.280
First, the identifier,
which distinctly identifies

00:07:42.460 --> 00:07:43.750
each touch that is down.

00:07:43.900 --> 00:07:46.640
It allows you to track the fingers.

00:07:46.700 --> 00:07:48.340
Here they are.

00:07:53.830 --> 00:07:58.190
What is the target of the touches?

00:07:58.330 --> 00:07:59.620
Two touches are on the red div.

00:07:59.800 --> 00:08:01.890
The target is the red div.

00:08:04.600 --> 00:08:09.080
All right.

00:08:09.150 --> 00:08:12.220
Then we see the screen X and screen Y,
page X and page Y.

00:08:12.520 --> 00:08:19.590
It's a little bit easier to use a smaller
screen to distinguish between the two.

00:08:19.980 --> 00:08:23.580
So finger comes down.

00:08:23.690 --> 00:08:28.340
Screen X and screen Y are with
respect to the top left of the screen.

00:08:29.580 --> 00:08:32.800
And if you have a large page
on which you're scrolling,

00:08:32.860 --> 00:08:36.490
page X and page Y will be with respect
to the top left of the actual page,

00:08:36.550 --> 00:08:38.190
not the screen.

00:08:38.840 --> 00:08:40.450
So here's the difference
between screen X and screen Y,

00:08:40.540 --> 00:08:42.900
page X and page Y.

00:08:43.050 --> 00:08:45.230
What can you use touch events for?

00:08:45.350 --> 00:08:49.550
Well, unlike with mouse events,
you can actually track multiple fingers.

00:08:52.720 --> 00:08:57.700
And you can make custom event,
custom touch, custom gestures,

00:08:57.700 --> 00:09:00.940
like as you've seen me add,
the change color gesture

00:09:00.940 --> 00:09:02.680
with a two-finger tap.

00:09:02.680 --> 00:09:05.420
And what did it take to
make the two-finger tap?

00:09:05.420 --> 00:09:06.660
Had a touch start.

00:09:06.690 --> 00:09:09.970
Both fingers were on the same element.

00:09:09.970 --> 00:09:13.380
So target touches is of length two.

00:09:13.450 --> 00:09:15.860
The fingers did not move.

00:09:16.550 --> 00:09:20.040
And they were lifted immediately
with no preceding touch movements.

00:09:20.210 --> 00:09:26.150
So it's that simple to make gestures
that make sense for your app.

00:09:26.930 --> 00:09:28.960
Well, what about pinch to zoom?

00:09:29.050 --> 00:09:33.770
You have photos, maps,
very intuitive gesture for users.

00:09:33.920 --> 00:09:36.280
You saw me perform Pitch and Zoom.

00:09:36.330 --> 00:09:37.660
Do you really have to do all the math?

00:09:37.690 --> 00:09:39.580
No, you don't.

00:09:39.590 --> 00:09:43.000
It is provided as a gesture event.

00:09:43.000 --> 00:09:45.530
It's a special event in JavaScript.

00:09:45.750 --> 00:09:48.360
And here's what the events look like.

00:09:49.250 --> 00:09:50.910
First,
you get a gesture start as soon as the

00:09:50.930 --> 00:09:54.060
second finger comes down on the screen.

00:09:54.180 --> 00:09:59.300
As the fingers move,
gesture events-- gesture change--

00:09:59.300 --> 00:10:01.130
gesture change events are fired.

00:10:01.500 --> 00:10:06.710
And when one of the fingers is lifted,
gesture change event comes in.

00:10:08.290 --> 00:10:12.070
And so here in my example on the red div,
I was performing a gesture

00:10:12.110 --> 00:10:14.590
change event-- gesture change.

00:10:14.800 --> 00:10:16.670
And this is what the
JavaScript would look like.

00:10:16.730 --> 00:10:19.690
You add an event listener
for gesture change,

00:10:19.900 --> 00:10:22.460
And your callback will
receive this object,

00:10:22.500 --> 00:10:25.110
this gesture event object.

00:10:26.540 --> 00:10:28.790
It'll have just a few things.

00:10:29.060 --> 00:10:35.580
Scale, which gets larger as
the fingers move apart.

00:10:36.160 --> 00:10:42.150
and smaller as the fingers move together,
and rotation, which is in degrees,

00:10:42.150 --> 00:10:47.930
as the fingers move clockwise.

00:10:48.810 --> 00:10:50.860
The degrees are positive.

00:10:50.950 --> 00:10:56.920
And as you move counterclockwise,
the degrees become negative.

00:10:57.010 --> 00:10:59.830
So how do we use scale and rotation?

00:11:00.760 --> 00:11:03.530
to actually rotate that div.

00:11:03.970 --> 00:11:07.700
We used WebKit transforms in this way.

00:11:08.960 --> 00:11:15.000
Our scale and rotate box callback
simply does a WebKit transform.

00:11:15.000 --> 00:11:20.740
It takes the event scale
and the event rotation,

00:11:20.900 --> 00:11:23.540
applies the transform.

00:11:23.560 --> 00:11:27.420
But you'll notice there's a
start rotation and a start scale.

00:11:28.170 --> 00:11:31.990
These are important because the
WebKit transforms are not cumulative.

00:11:32.120 --> 00:11:36.840
And so you need to multiply in
a start scale from a previous

00:11:36.980 --> 00:11:41.280
gesture event that has ended,
and a start rotation,

00:11:41.280 --> 00:11:44.470
and add in the start rotation
from the previous event.

00:11:44.610 --> 00:11:50.110
And that is because when
you begin a gesture event,

00:11:50.370 --> 00:11:54.790
The scale starts at 1,
and the rotation angle starts at 0.

00:11:54.890 --> 00:11:57.080
So adjust your end.

00:11:57.480 --> 00:12:00.150
You will save the scale and
you'll save the rotation.

00:12:00.160 --> 00:12:03.300
You'll multiply in the scale
and you'll add in the rotation.

00:12:03.460 --> 00:12:08.650
So for the next gesture start,
you can continue where you left off

00:12:08.650 --> 00:12:11.090
with the previous gesture event.

00:12:13.990 --> 00:12:19.280
So you may have noticed that in my demo,
the page wasn't bouncing around when

00:12:19.280 --> 00:12:20.650
I was moving the fingers around the page.

00:12:20.660 --> 00:12:23.930
It wasn't rubber banding as
you're used to seeing in Safari.

00:12:23.990 --> 00:12:27.290
And that's because I prevented
the default Safari behavior

00:12:27.550 --> 00:12:29.000
for touch move events.

00:12:29.050 --> 00:12:31.520
And you'll want to do
this too in your app.

00:12:31.590 --> 00:12:35.780
So to prevent scrolling,
you'll add an event listener.

00:12:36.140 --> 00:12:39.810
for TouchMove, and you'll prevent default
browser behavior by calling

00:12:39.810 --> 00:12:42.490
prevent default on the event.

00:12:43.580 --> 00:12:47.480
I also want to remind you to keep
your touch event handlers simple.

00:12:47.670 --> 00:12:48.410
Let them come in.

00:12:48.670 --> 00:12:54.420
You schedule what you want to
get done with set interval.

00:12:54.610 --> 00:12:58.340
Try to avoid moving things around
that will cause relay outs.

00:12:58.510 --> 00:13:01.470
But applying transforms, as I've done,
to scale and rotate

00:13:01.550 --> 00:13:03.770
is actually very fast,
and it's fine.

00:13:03.900 --> 00:13:07.110
It's fine to do in your
touch event handlers.

00:13:07.450 --> 00:13:09.940
And now I'd like to invite on
stage my colleague at Apple,

00:13:10.110 --> 00:13:11.920
Matt Lilek.

00:13:11.960 --> 00:13:13.470
Welcome, Matt.

00:13:18.130 --> 00:13:20.460
Hello, everyone.

00:13:20.470 --> 00:13:25.600
As Anton showed you earlier,
I wrote this Destinations

00:13:25.600 --> 00:13:26.980
app a few years ago.

00:13:27.060 --> 00:13:30.020
And let me show you the old version.

00:13:31.130 --> 00:13:32.990
This is it.

00:13:33.010 --> 00:13:35.000
Like I said, I wrote it a few years ago.

00:13:35.120 --> 00:13:37.040
The iPhone was brand new.

00:13:37.220 --> 00:13:40.280
I really only had the desktop in mind.

00:13:40.280 --> 00:13:43.720
And it looks okay on the iPad,
but I can't really

00:13:44.360 --> 00:13:46.220
interact with it at all.

00:13:46.220 --> 00:13:49.100
I can't pinch to zoom on any
of these photos or anything.

00:13:49.100 --> 00:13:52.280
It just doesn't feel
like an iOS app should.

00:13:52.980 --> 00:13:54.750
So I'm going to fix that today.

00:13:54.770 --> 00:14:01.710
And the first thing I'm going
to do is pull up my code here.

00:14:01.710 --> 00:14:01.710
And

00:14:02.480 --> 00:14:09.060
Each photo on screen is represented
by this Photo JavaScript class.

00:14:09.060 --> 00:14:14.110
And within that class,
the actual DOM is a development and

00:14:14.110 --> 00:14:17.700
then an image element inside of that.

00:14:17.700 --> 00:14:22.390
So what I'm going to do is I'm going
to add a touch gesture listener

00:14:22.970 --> 00:14:26.810
so that when I pinch on the image,
it's going to expand and

00:14:26.820 --> 00:14:28.580
I can see it more clearly.

00:14:28.580 --> 00:14:31.860
So what I'm going to
do here is in my code,

00:14:32.020 --> 00:14:36.700
I'm going to listen to the
gesture end event on my image,

00:14:36.700 --> 00:14:41.310
and then I'm going to
implement a simple callback.

00:14:43.690 --> 00:14:49.490
And what this does is it looks at the
scale property from the event object

00:14:49.590 --> 00:14:51.950
that were passed at gesture end.

00:14:52.060 --> 00:14:57.500
And if the scale is larger than one,
that means that the user has

00:14:57.500 --> 00:14:59.280
expanded their fingers outward.

00:14:59.280 --> 00:15:05.170
And I'm going to enlarge the image using
my set scale little helper function,

00:15:05.250 --> 00:15:07.460
which just applies a CSS transform to it.

00:15:07.520 --> 00:15:12.390
And if it's less than one,
I'm just going to scale it back.

00:15:12.480 --> 00:15:21.100
So I'm going to save this and switch
back to my iPad and pull up the--

00:15:21.970 --> 00:15:26.340
New version, which you can see I've
simplified already.

00:15:26.490 --> 00:15:32.190
And I can scroll it using standard
overflow scroll now with one finger.

00:15:32.470 --> 00:15:37.380
And I can pinch to zoom in on these,
as you can see.

00:15:40.880 --> 00:15:45.050
And in only half a dozen lines of code,
I've already made my app far more

00:15:45.050 --> 00:15:47.290
interactive than it was before.

00:15:47.300 --> 00:15:48.910
And it was just really simple.

00:15:48.970 --> 00:15:51.880
And Anton can tell us more.

00:15:56.260 --> 00:15:59.160
All right, so what did we just learn?

00:15:59.230 --> 00:16:03.030
With touch and gestures,
you can make your UI more interactive

00:16:03.100 --> 00:16:06.630
and intuitive with multi-touch.

00:16:06.840 --> 00:16:11.050
You have the touch event for
tracking multiple fingers and also

00:16:11.080 --> 00:16:14.670
making your own custom gestures
that make sense with your app.

00:16:15.580 --> 00:16:19.290
For pinch and zoom,
you have the gesture event,

00:16:19.290 --> 00:16:23.500
which you can use to pinch, zoom, rotate,
and use when you have graphics,

00:16:23.500 --> 00:16:26.540
just where you have maps,
things that users want to

00:16:26.540 --> 00:16:28.470
grab and scale and rotate.

00:16:29.060 --> 00:16:31.990
I want to remind you again
to handle touch cancel if

00:16:32.090 --> 00:16:40.190
you're using touch events,
to update the state of your UI in

00:16:40.190 --> 00:16:40.190
case there's an interruption from
phone calls or system gestures,

00:16:40.860 --> 00:16:45.010
Don't forget to prevent
scrolling with prevent default,

00:16:45.010 --> 00:16:50.070
and keep your touch event handlers
simple to not block other touch events.

00:16:50.400 --> 00:16:51.680
And most importantly, try it.

00:16:51.900 --> 00:16:52.800
It's easy.

00:16:52.860 --> 00:16:56.630
Improve your UI instantly
on iPad and iPhone.

00:16:57.770 --> 00:17:01.300
So we've made these changes
to the Destinations app.

00:17:01.610 --> 00:17:06.060
We made it easier to look at photos,
simplified the UI.

00:17:06.180 --> 00:17:10.650
But wouldn't it be great if we could just
know what are the awesome destinations

00:17:10.780 --> 00:17:13.620
within city limits within our web app?

00:17:13.620 --> 00:17:16.890
And we can do this with geolocation.

00:17:18.630 --> 00:17:22.290
You can do this in
your web app right now.

00:17:22.460 --> 00:17:26.490
Phones are everywhere,
and you can take advantage of this.

00:17:26.680 --> 00:17:27.680
Add a lot of contacts.

00:17:27.800 --> 00:17:31.000
There are great APIs out there,
Twitter API, Flickr API.

00:17:31.000 --> 00:17:33.000
You can enrich your app with this.

00:17:33.130 --> 00:17:34.680
So how do we use geolocation?

00:17:34.780 --> 00:17:35.740
What is it like?

00:17:35.890 --> 00:17:40.380
So the geolocation interface is
an asynchronous JavaScript API.

00:17:40.970 --> 00:17:43.800
And you can--so you
can do multiple things.

00:17:43.800 --> 00:17:47.580
First, you can find out where
the user is right away.

00:17:47.580 --> 00:17:52.470
You get an approximation
with getCurrentPosition.

00:17:53.980 --> 00:17:56.840
As the user moves,
you can be alerted of his changing

00:17:56.840 --> 00:17:59.750
location with watch position.

00:17:59.960 --> 00:18:01.380
You'll provide a callback.

00:18:01.500 --> 00:18:05.220
Your callback will fire when the
GPS determines the user has moved.

00:18:07.280 --> 00:18:12.480
And when your UI is done
using watch position,

00:18:12.520 --> 00:18:13.670
make sure to clear it.

00:18:13.840 --> 00:18:17.110
This is important,
and we'll get back to it shortly.

00:18:17.780 --> 00:18:21.640
So using cache position
is important as well.

00:18:21.710 --> 00:18:28.270
You would use it to not wake up the GPS,
and if you don't need

00:18:28.270 --> 00:18:31.500
very precise position.

00:18:31.610 --> 00:18:34.420
You call getCurrentPosition
on navigator geolocation,

00:18:34.560 --> 00:18:36.580
provide success callback
and error callback,

00:18:36.690 --> 00:18:42.080
and you'll notice the maximum age set to,
in this case, 10 minutes.

00:18:43.990 --> 00:18:47.400
If a cache position is available,
it'll return instantly.

00:18:47.500 --> 00:18:49.190
And it will--something like this.

00:18:49.240 --> 00:18:51.710
Your success callback will
look something like that.

00:18:51.930 --> 00:18:56.450
And make sure to provide
an error callback,

00:18:56.580 --> 00:19:02.390
because the user may decide
to not authorize your app

00:19:02.480 --> 00:19:05.800
or your security origin,
your domain,

00:19:05.920 --> 00:19:08.340
from knowing about their location.

00:19:08.730 --> 00:19:14.990
Also, of course, the user may be indoors,
and the GPS may time out.

00:19:16.590 --> 00:19:18.070
So how would we use it?

00:19:18.450 --> 00:19:21.670
So how would we use watch position?

00:19:22.450 --> 00:19:28.140
Because Get Current Position is fast,
it's also less precise.

00:19:28.270 --> 00:19:32.640
And so what you would do is you'd
provide your callback to watch position,

00:19:32.880 --> 00:19:35.090
you'd get a watch ID,

00:19:36.250 --> 00:19:40.390
And once you're satisfied with
zeroing in on the user's location,

00:19:40.410 --> 00:19:44.590
you will need to call
ClearWatch with that watch ID.

00:19:44.750 --> 00:19:46.450
This is important,
and you need to use this

00:19:46.450 --> 00:19:51.570
responsibly because keeping
the GPS radio up uses power.

00:19:52.890 --> 00:19:56.880
And of course, remember,
a user can-- a user is asked

00:19:57.050 --> 00:20:02.590
every 24 hours whether they'll
allow your security origin,

00:20:02.610 --> 00:20:03.670
your domain,

00:20:04.080 --> 00:20:08.010
to know about their location,
and so they can decline every 24 hours.

00:20:08.130 --> 00:20:09.940
And Matt,
I'd like to welcome you again to show

00:20:09.940 --> 00:20:13.270
how we use location in destinations.

00:20:17.180 --> 00:20:18.290
Hello again, everyone.

00:20:18.490 --> 00:20:23.280
So as we saw before,
there's a lot of photos

00:20:23.380 --> 00:20:26.890
here on our web app.

00:20:30.900 --> 00:20:36.480
And it's really inconvenient to
have to scroll through all these.

00:20:36.550 --> 00:20:41.730
I mean, there's places from New York and
Tokyo and San Francisco all around here.

00:20:41.980 --> 00:20:46.280
So what I'm going to do is I'm going
to use this little button I've got in

00:20:46.350 --> 00:20:51.440
my web app up here to allow the user to
only show images that are close to them.

00:20:51.550 --> 00:20:55.790
So how do I do that?

00:20:55.790 --> 00:20:55.790
In my code,

00:20:56.480 --> 00:21:00.430
I've got this application
JavaScript class,

00:21:00.430 --> 00:21:04.670
which handles loading
photos and handles rotation,

00:21:04.700 --> 00:21:06.300
just some other stuff.

00:21:06.430 --> 00:21:11.230
And what I'm going to do is I'm going to,
when I load the page,

00:21:11.290 --> 00:21:12.460
I'm going to get that button.

00:21:12.460 --> 00:21:16.730
I'm going to add a
touch end event to that.

00:21:16.810 --> 00:21:21.290
And in my callback,

00:21:21.950 --> 00:21:26.570
I'm going to use
navigator.geolocation.getcurrentposition

00:21:26.630 --> 00:21:30.220
to get the user's location.

00:21:30.260 --> 00:21:33.370
I only want to know generally
where they're at because I just,

00:21:33.370 --> 00:21:36.970
you know,
Beijing is far away from New York.

00:21:37.080 --> 00:21:39.410
I don't need to use watch
position to track them,

00:21:39.410 --> 00:21:41.460
so I may as well not waste the battery.

00:21:41.900 --> 00:21:45.540
So I've got two callbacks here,
success and error,

00:21:45.540 --> 00:21:47.230
and what do I do in those?

00:21:47.230 --> 00:21:52.580
Well, if the user authorizes me
and we get a location...

00:21:52.850 --> 00:21:56.510
I've got this code that I wrote earlier,
which queries our

00:21:56.510 --> 00:22:03.660
database for the location,
the latitude and longitude of the photos.

00:22:03.660 --> 00:22:06.970
And I provide that,
the coordinates from the position

00:22:07.400 --> 00:22:09.280
object that is returned to us.

00:22:09.280 --> 00:22:14.250
And then once I've got that information,
I just loop over all the photos that

00:22:14.250 --> 00:22:19.340
I've got on screen and either hide
them or keep them visible for the user.

00:22:19.340 --> 00:22:24.600
And in the case of an error,
or we don't have permission,

00:22:24.650 --> 00:22:30.540
I just simply get that button again
and make it look disabled for the user.

00:22:30.630 --> 00:22:33.180
So what does that actually look like?

00:22:34.420 --> 00:22:35.610
Let's switch back to this.

00:22:35.880 --> 00:22:36.820
That one.

00:22:36.960 --> 00:22:39.680
So I'm just going to reload this.

00:22:39.720 --> 00:22:42.590
And when I tap on this button,

00:22:42.750 --> 00:22:46.660
An alert's going to pop up asking
if Safari can use my location.

00:22:46.700 --> 00:22:49.230
This is the first time I've
used geolocation within Safari,

00:22:49.350 --> 00:22:55.320
so iOS needs to ask permission for
the app itself to use geolocation,

00:22:55.320 --> 00:22:56.620
and I'm just going to tap OK.

00:22:56.620 --> 00:22:58.690
And then...

00:23:01.800 --> 00:23:03.680
There we go.

00:23:03.680 --> 00:23:08.340
The website is going to
prompt for permission.

00:23:08.340 --> 00:23:12.210
We have to do that because you
can load a lot of sites in Safari.

00:23:12.210 --> 00:23:15.710
You can -- a lot of websites
can use geolocation,

00:23:15.720 --> 00:23:18.840
and you don't want to necessarily
authorize every single one

00:23:18.840 --> 00:23:20.110
of them just by default.

00:23:20.300 --> 00:23:21.630
I'm going to tap okay.

00:23:21.630 --> 00:23:23.810
And my photos are going to disappear.

00:23:23.980 --> 00:23:27.060
And now I only see ones
from around San Francisco.

00:23:27.190 --> 00:23:30.600
And that was only maybe
another dozen lines of code.

00:23:30.600 --> 00:23:35.420
And it's just already a lot
easier to use my web app.

00:23:35.420 --> 00:23:38.530
So I will give it back to Anton.

00:23:42.500 --> 00:23:47.130
Thanks, Matt.

00:23:47.230 --> 00:23:52.000
So we saw how you can use
geolocation to make your app

00:23:52.040 --> 00:23:54.680
aware of the user's context,
where they are,

00:23:54.700 --> 00:23:57.790
and show them what's relevant
to them in the moment.

00:24:01.890 --> 00:24:04.500
So with location-- with
the Geolocation API,

00:24:04.500 --> 00:24:07.640
you can determine the user's location,
and as they move,

00:24:07.680 --> 00:24:09.670
your app can know about it.

00:24:10.250 --> 00:24:14.310
You can make sure to
handle errors because,

00:24:14.310 --> 00:24:18.110
specifically with GPS,
you will not always be able

00:24:18.260 --> 00:24:20.590
to find out where the user is.

00:24:21.260 --> 00:24:24.180
And be mindful of power consumption.

00:24:24.510 --> 00:24:29.960
This is true for all devices,
and got to use this API responsibly.

00:24:30.090 --> 00:24:34.700
So now we've simplified
the UI significantly.

00:24:35.020 --> 00:24:40.500
We use geolocation as a gesture,
as an input, as a UI input.

00:24:40.630 --> 00:24:44.250
But wouldn't it be great if the user
takes the device and points it within

00:24:44.670 --> 00:24:48.490
their city limits and to see what
are the great things that lie ahead?

00:24:48.610 --> 00:24:53.560
What are the noteworthy things
to see that are in front of them?

00:24:53.660 --> 00:24:57.350
And we can do this with
orientation and motion.

00:24:58.730 --> 00:25:00.940
iOS developers,
iOS app developers have used

00:25:00.940 --> 00:25:04.190
Orientation in Motion to
create all sorts of innovative,

00:25:04.190 --> 00:25:07.760
interesting apps that were
previously unimaginable.

00:25:08.050 --> 00:25:14.810
And you can do this with JavaScript and
HTML and CSS in your web apps.

00:25:15.030 --> 00:25:18.580
You may think, well,
I already have window.orientation.

00:25:18.640 --> 00:25:21.410
I already can provide the
onOrientationChange callback

00:25:21.500 --> 00:25:24.140
and know if the user is holding
it portrait or landscape.

00:25:24.260 --> 00:25:26.670
But that's not what we're
interested in today.

00:25:27.010 --> 00:25:29.850
Portrait and landscape
just tells you 90 degrees,

00:25:29.920 --> 00:25:31.030
zero degrees.

00:25:31.140 --> 00:25:35.660
You know, it just tells you how the
user's holding it with respect

00:25:35.740 --> 00:25:36.780
to portrait and landscape.

00:25:36.880 --> 00:25:40.910
But we want to actually know,
how are they moving it in their 3D space?

00:25:41.170 --> 00:25:43.230
How are they leaning it forward or back?

00:25:43.310 --> 00:25:45.390
Or what if they're shaking it?

00:25:46.500 --> 00:25:47.540
That's motion.

00:25:47.610 --> 00:25:49.530
But first,
we start with device orientation,

00:25:49.530 --> 00:25:51.640
and we have precisely how it's held.

00:25:51.640 --> 00:25:57.980
And device motion tells us how
did the user move the device?

00:25:57.990 --> 00:26:03.990
What are the forces they
applied to it to move it?

00:26:04.060 --> 00:26:06.780
So first, let's look at orientation.

00:26:09.750 --> 00:26:12.160
If I want to listen to
changes in orientation,

00:26:12.160 --> 00:26:15.070
I listen to device orientation event.

00:26:15.200 --> 00:26:19.810
When it fires,
my callback runs on orientation,

00:26:19.810 --> 00:26:22.290
and I get this device
orientation event object.

00:26:22.300 --> 00:26:23.740
And what's in this object?

00:26:23.930 --> 00:26:25.590
Well, quite a lot.

00:26:26.770 --> 00:26:28.310
We see alpha, beta, gamma.

00:26:28.520 --> 00:26:32.900
These are ranges and degrees that
represent the three dimensions.

00:26:33.780 --> 00:26:35.960
What is alpha?

00:26:36.170 --> 00:26:44.000
Imagine pinning the device on its back,
and it's spinning around like this.

00:26:44.750 --> 00:26:47.590
As it moves,
you will get degrees in alpha,

00:26:47.590 --> 00:26:51.920
starting with zero when the app loads,
and as the user moves it around,

00:26:51.920 --> 00:26:55.320
like this, the alpha value will change.

00:26:56.320 --> 00:27:00.240
Beta represents rotation
around the x-axis.

00:27:00.240 --> 00:27:06.160
So if you put the green arrow through
the device and lean it forward like this,

00:27:06.170 --> 00:27:09.140
you will see rotations on the beta value.

00:27:09.140 --> 00:27:11.780
You will see beta value changing,
and it will represent the

00:27:11.780 --> 00:27:13.310
rotations there on the x-axis.

00:27:13.340 --> 00:27:19.470
And then for y-axis,
imagine the device rotating like this

00:27:19.540 --> 00:27:26.660
with the orange arrow through it,
and that's gamma.

00:27:27.740 --> 00:27:32.590
Now, you'll also notice two properties,
WebKit Compass Heading and

00:27:32.590 --> 00:27:34.500
WebKit Compass Accuracy.

00:27:34.750 --> 00:27:37.320
These are new in iOS 5.

00:27:37.870 --> 00:27:41.870
And WebKit Compass Heading
tells you where,

00:27:41.870 --> 00:27:46.560
with respect to magnetic north,
is the device facing.

00:27:46.810 --> 00:27:49.500
So you can use this
without waking up the GPS,

00:27:49.750 --> 00:27:50.740
without using geolocation.

00:27:50.740 --> 00:27:54.930
You'll know where the user is
heading with WebKit Compass Heading.

00:27:56.280 --> 00:28:02.120
WebKit Compass Accuracy tells you how
confident is the platform of that reading

00:28:02.150 --> 00:28:04.510
and if there's magnetic interference.

00:28:04.930 --> 00:28:09.850
Don't use alpha, which tells you how the
user is rotating like this,

00:28:09.850 --> 00:28:11.400
for compass heading.

00:28:11.400 --> 00:28:16.640
That's because alpha starts
at zero when your app loads.

00:28:20.380 --> 00:28:27.270
And this is supported by iPad 2,
iPhone 4, and the latest iPod Touch.

00:28:29.240 --> 00:28:31.750
Well, what about Shake?

00:28:31.810 --> 00:28:33.410
How do we detect Shake?

00:28:33.510 --> 00:28:38.600
And for this, device motion is the
perfect thing to use.

00:28:39.360 --> 00:28:42.490
It also has quite a bit,
but for this purpose,

00:28:42.490 --> 00:28:47.560
we'll use acceleration,
which is in meters per second squared,

00:28:47.560 --> 00:28:52.090
and it's what are the Gs along X, Y,
and Z axes?

00:28:52.720 --> 00:28:55.860
And then what is the
rate of velocity change?

00:28:56.080 --> 00:29:00.020
The next value is acceleration,
including gravity.

00:29:00.550 --> 00:29:06.060
And that's acceleration with gravity
factored in to the three axes.

00:29:08.330 --> 00:29:11.880
And in the spirit of how
is the device moving,

00:29:11.920 --> 00:29:14.640
we also get rotation rate,
which tells us how did

00:29:14.640 --> 00:29:16.940
the device rotate along x,
y,

00:29:16.940 --> 00:29:20.800
and z since the last device motion event.

00:29:20.830 --> 00:29:24.160
How did it move in terms of those angles,
alpha, beta, and gamma,

00:29:24.230 --> 00:29:26.750
that we just went over?

00:29:26.960 --> 00:29:30.890
And that interval is in milliseconds
since the last event fired.

00:29:31.870 --> 00:29:34.150
And now I'd like to turn it over
to Matt so he can show you how we

00:29:34.150 --> 00:29:37.110
use orientation in destinations.

00:29:41.250 --> 00:29:42.240
Hello again.

00:29:42.400 --> 00:29:46.320
So as you've seen,
we've been able to simplify and

00:29:46.320 --> 00:29:48.480
enhance our web app already.

00:29:48.480 --> 00:29:53.520
But one thing that we thought would
be cool is to give the device or to

00:29:53.520 --> 00:29:57.400
give our web app a different kind of
feel in the landscape orientation.

00:29:57.400 --> 00:30:00.150
And what we're going to
do is we're going to,

00:30:00.150 --> 00:30:03.750
in landscape,
when the user rotates the device around,

00:30:03.750 --> 00:30:07.820
we're going to make it so that
there's a little compass on screen,

00:30:07.870 --> 00:30:11.110
and it shows what lies
ahead in that direction.

00:30:11.200 --> 00:30:15.350
So in order to do that,
I'm going to go back to my code here.

00:30:15.360 --> 00:30:21.900
And in my application, I want to,

00:30:24.480 --> 00:30:29.860
Add an event listener for
the device orientation event.

00:30:29.870 --> 00:30:33.480
And in my callback for that, I'm going

00:30:35.760 --> 00:30:37.700
I'm going to do a couple of things.

00:30:37.700 --> 00:30:41.910
First, I'm going to get the
WebKit Compass Heading property

00:30:41.910 --> 00:30:43.650
from the event that's passed to us.

00:30:43.700 --> 00:30:47.240
And then I'm going to have a little
digital compass in the screen.

00:30:47.240 --> 00:30:50.930
And in order to do that,
I'm just going to use that

00:30:50.930 --> 00:30:55.140
compass heading and update
the direction on screen,

00:30:55.140 --> 00:31:00.930
as well as the kind of north
or south string for that.

00:31:01.210 --> 00:31:06.480
And then I've got some other code in my
application that determines the direction

00:31:06.730 --> 00:31:10.860
based off of the heading property,
and then looks at all of the

00:31:10.860 --> 00:31:15.130
photos in our database and figures
out which one the user should be

00:31:15.130 --> 00:31:17.360
seeing and shows that on screen.

00:31:17.360 --> 00:31:19.980
So let's see what that looks like.

00:31:31.200 --> 00:31:38.070
So if I rotate this to landscape,
you can see that we've got the

00:31:38.470 --> 00:31:42.700
direction that we're facing,
as well as an image up here.

00:31:42.880 --> 00:31:50.140
And as I rotate it around,
you can see that it changes.

00:31:50.400 --> 00:31:53.660
If we go north,
you can see that we're looking

00:31:53.700 --> 00:31:58.910
towards the Golden Gate Bridge,
which you can't really see up there.

00:31:59.880 --> 00:32:03.890
And it's pretty cool to use this.

00:32:04.050 --> 00:32:09.400
But if you're limited in your movement,
it's kind of awkward to use.

00:32:09.530 --> 00:32:15.140
Or say you don't want to have to spin
around 360 degrees to see all the photos.

00:32:15.200 --> 00:32:18.670
So what we want to do is make it
so that when you shake the device,

00:32:18.670 --> 00:32:22.650
a random photo pops up and you can
cycle through the photos that way.

00:32:22.900 --> 00:32:25.240
So in order to do that,
we're going to go back to

00:32:25.240 --> 00:32:26.490
our code one more time.

00:32:26.510 --> 00:32:30.290
And just like we've been doing,
we're going to add an event

00:32:30.290 --> 00:32:35.190
listener and provide it a callback,
just like we've done before,

00:32:35.190 --> 00:32:37.300
this time for the device motion event.

00:32:37.320 --> 00:32:42.810
And in that callback,
what we're going to do is...

00:32:43.220 --> 00:32:46.360
We're going to take a look at
the acceleration from the event.

00:32:46.360 --> 00:32:48.610
And in my case,
I'm only concerned about the

00:32:48.700 --> 00:32:50.300
acceleration along one axis.

00:32:50.300 --> 00:32:51.690
Your app may be different.

00:32:51.910 --> 00:32:53.480
You might want to use all three.

00:32:53.480 --> 00:32:57.460
You'll probably definitely want to use
all three depending on your use case.

00:32:57.540 --> 00:33:00.190
But this is good enough for my situation.

00:33:00.610 --> 00:33:06.500
And I'm just going to get the force
from that based off of the other motion

00:33:06.510 --> 00:33:09.640
events that have been passed to us.

00:33:10.130 --> 00:33:13.330
Because you're going to get a
lot of motion events every single

00:33:13.340 --> 00:33:15.400
time the user moves the device.

00:33:15.400 --> 00:33:18.630
So in order to make the determination
on whether it was a shake or not,

00:33:18.630 --> 00:33:20.730
we're going to look
at a couple of things.

00:33:20.730 --> 00:33:29.110
One, if the force exceeds the force
that we want to consider a shake.

00:33:29.270 --> 00:33:30.580
In my case, it's real low.

00:33:30.600 --> 00:33:37.490
Again, that's going to depend on your
use case and your application.

00:33:38.220 --> 00:33:45.390
Okay, that, and then after,
we're only concerned about shakes,

00:33:45.390 --> 00:33:48.690
possible shakes,
within the last half second,

00:33:49.030 --> 00:33:53.670
because we don't want a slow shake
to be considered a shake in our case.

00:33:53.680 --> 00:33:58.070
So if those conditions are met,
we're going to use some other code

00:33:58.070 --> 00:34:02.030
that we've got in our application
that just pulls out a random

00:34:02.280 --> 00:34:04.630
photo and updates it on screen.

00:34:04.640 --> 00:34:07.940
So let's take a look at
what that looks like.

00:34:08.100 --> 00:34:14.380
And I'm going to reload
this one more time.

00:34:19.800 --> 00:34:25.680
You can see as I move the device--
let's block the orientation there.

00:34:25.700 --> 00:34:29.560
As we move the device,
we get a new photo.

00:34:29.560 --> 00:34:33.490
Yes, no, maybe.

00:34:36.320 --> 00:34:41.740
It's a little iffy on stage here,
but you get the idea.

00:34:42.150 --> 00:34:46.500
You'll be able to do it in your
app a lot easier than up here with

00:34:46.590 --> 00:34:48.900
a bunch of magnetic interference.

00:34:48.900 --> 00:34:52.940
So that was, again,
only a few lines of code.

00:34:52.940 --> 00:34:56.250
So let's have Anton tell us some more.

00:35:02.040 --> 00:35:03.200
Thanks, Matt.

00:35:03.360 --> 00:35:08.200
So orientation and motion,
really amazing.

00:35:08.200 --> 00:35:08.200
You can add

00:35:08.360 --> 00:35:10.550
A new gesture, pointing the device.

00:35:10.560 --> 00:35:13.400
That's a new gesture that
is possible for web apps.

00:35:13.400 --> 00:35:14.890
It's pretty incredible.

00:35:14.960 --> 00:35:17.190
So what did we do?

00:35:17.600 --> 00:35:18.500
What did we learn?

00:35:18.500 --> 00:35:23.530
Orientation tells us how precisely
the device is held as the device

00:35:23.570 --> 00:35:28.140
is moving to know how--oh,
sorry.

00:35:28.480 --> 00:35:31.390
Remember,
WebKit Compass Heading is what you'll

00:35:31.390 --> 00:35:38.930
use for Magnetic North for geodirection,
and Motion--

00:35:39.390 --> 00:35:43.300
Motion tells us how the device
moved in a span of time.

00:35:43.340 --> 00:35:48.760
So it tells us meters per
second squared along three axes,

00:35:48.830 --> 00:35:53.370
and also how the rotation
changed in that time.

00:35:56.440 --> 00:36:03.540
So now we have this great app for
discovering places to go and see,

00:36:03.660 --> 00:36:07.190
but wouldn't it be great if we
could just take it and go and not be

00:36:07.260 --> 00:36:09.800
dependent on a network connection?

00:36:10.000 --> 00:36:13.490
And there are some HTML5 technologies
that you can use to do this,

00:36:13.490 --> 00:36:14.200
to accomplish this.

00:36:14.200 --> 00:36:16.970
And I just want to go over one,
which I think is really great.

00:36:17.090 --> 00:36:19.880
It's HTML5 Application Cache.

00:36:21.250 --> 00:36:25.470
It'll make your app run offline,
and when your app is online,

00:36:25.620 --> 00:36:26.750
it'll run much faster.

00:36:26.860 --> 00:36:29.410
It won't need to pull down anything.

00:36:29.940 --> 00:36:34.800
Your app is updated as a single unit,
so no one element in the app

00:36:34.830 --> 00:36:36.820
could be out of sync with another.

00:36:36.970 --> 00:36:39.050
These updates are atomic.

00:36:39.210 --> 00:36:41.980
And you don't need to write
much code to support this.

00:36:42.260 --> 00:36:45.000
Actually,
you don't need to write any code at all.

00:36:47.330 --> 00:36:51.930
And you can also control if you
want to go out and get things from

00:36:51.930 --> 00:36:54.300
the Twitter API or Flickr API.

00:36:54.340 --> 00:36:56.130
You can allow your app to do that.

00:36:56.370 --> 00:37:00.640
And as your app generates content
for the user-- with the user,

00:37:00.640 --> 00:37:03.490
you can use other persistent
storage technologies like

00:37:03.490 --> 00:37:06.370
Web SQL databases and local storage.

00:37:07.300 --> 00:37:09.550
We're not going to go into
the details on this today,

00:37:09.560 --> 00:37:13.150
but there's an excellent
session on Thursday.

00:37:13.480 --> 00:37:17.300
called Using HTML5 Offline Storage.

00:37:17.360 --> 00:37:19.000
And if you're serious
about making web apps,

00:37:19.080 --> 00:37:20.010
you've got to check this out.

00:37:23.640 --> 00:37:27.760
So now we've taken this app,
this website, and we've turned it into an

00:37:27.760 --> 00:37:31.500
interactive app that tells us
in the moment where we could go,

00:37:31.500 --> 00:37:32.930
what we can see.

00:37:33.210 --> 00:37:36.680
It has an intuitive UI,
but it's still running in the browser.

00:37:37.540 --> 00:37:40.700
We can make this an iOS app,
and I'm going to tell

00:37:40.710 --> 00:37:43.200
you a few tips for that.

00:37:43.350 --> 00:37:46.290
How your app can look great in iOS.

00:37:46.570 --> 00:37:52.380
We're going to talk about using CSS for
different orientations and resolutions.

00:37:52.970 --> 00:37:57.000
will talk about how you can launch your
web app from the home screen and how

00:37:57.000 --> 00:37:59.680
to make that process look really good.

00:38:00.630 --> 00:38:07.340
Make all your graphics, like icons,
look good on different screens.

00:38:07.590 --> 00:38:10.340
And we're going to talk
about startup images.

00:38:10.460 --> 00:38:14.330
So first, resolution-specific CSS.

00:38:14.660 --> 00:38:20.320
You already probably separate
style from content using CSS.

00:38:20.880 --> 00:38:26.750
You can also separate CSS just
for resolutions and just

00:38:26.920 --> 00:38:29.500
for different orientations.

00:38:30.880 --> 00:38:35.870
Because you might want certain
styles for portrait or landscape,

00:38:35.870 --> 00:38:40.210
and you may want to load high-resolution
images just for retina display

00:38:40.210 --> 00:38:46.090
devices and low-resolution images
just for iPod Touch or 3GS.

00:38:47.080 --> 00:38:54.140
And so you'll use media queries,
CSS media queries, for this.

00:38:54.250 --> 00:38:55.500
How does it work?

00:38:55.560 --> 00:38:58.960
In your main resource,
you'll provide a link tag

00:39:00.140 --> 00:39:07.200
That will have a media attribute,
which is a string that is evaluated

00:39:08.100 --> 00:39:12.500
as the browser is determining
whether to load the link or not.

00:39:12.630 --> 00:39:15.640
That string is evaluated,
and if it's evaluated to true,

00:39:15.860 --> 00:39:19.960
that iPhone 4 CSS file will be loaded.

00:39:20.100 --> 00:39:23.800
And that's the media query for iPhone 4.

00:39:26.410 --> 00:39:33.640
And you see for iPhone 3GS,
you simply negate the pixel ratio 2,

00:39:33.640 --> 00:39:37.030
which is the iPhone
4-specific media query,

00:39:37.150 --> 00:39:42.200
and only that CSS file will load
and not the iPhone 4 on 3GS.

00:39:42.360 --> 00:39:46.200
And for iPad,
this is the media query for iPad.

00:39:47.260 --> 00:39:50.550
This is extremely useful because you
don't want to load the pings that are

00:39:50.550 --> 00:39:54.040
high res for iPhone 4 when you're on 3GS.

00:39:55.460 --> 00:39:58.450
Now, what about the orientations?

00:39:58.490 --> 00:40:01.510
You want your app to lay out-- you
want to control how your app lays

00:40:01.510 --> 00:40:03.080
out in different orientations.

00:40:03.080 --> 00:40:05.800
And you may think, OK,
I'll just add a link tag

00:40:05.880 --> 00:40:08.920
that will add orientation.

00:40:08.920 --> 00:40:12.890
An orientation-- just use the
AND operator and specify the orientation.

00:40:13.000 --> 00:40:15.000
Well, actually, in the link tag,
that's not enough.

00:40:15.030 --> 00:40:18.660
Because link tags, as I said,
when the main resource is loaded,

00:40:18.660 --> 00:40:22.160
the link tag-- the media
attribute is evaluated.

00:40:22.220 --> 00:40:25.870
And if it's not in the right orientation,
if it's in portrait,

00:40:25.870 --> 00:40:27.210
landscape will not load.

00:40:27.250 --> 00:40:30.200
So what you'll need to do is inline CSS.

00:40:30.890 --> 00:40:34.980
Inline CSS in the
resolution-specific CSS files.

00:40:34.980 --> 00:40:40.140
So for a retina display, you'll have the
orientation portrait style.

00:40:40.460 --> 00:40:43.580
And you'll have the
orientation landscape style.

00:40:47.760 --> 00:40:50.630
Okay,
so now we have the separation of styles.

00:40:50.720 --> 00:40:54.040
We know how to lay things out
for different resolutions,

00:40:54.240 --> 00:40:56.910
but we still have to enter a URL.

00:40:57.530 --> 00:40:58.400
Still have to enter a URL.

00:40:58.400 --> 00:41:00.200
It's still in the browser.

00:41:00.350 --> 00:41:05.260
Well, you could--you could do-- you could
actually escape Safari and save

00:41:05.260 --> 00:41:10.650
a bookmark on the home screen and
make it launch like a real app.

00:41:10.730 --> 00:41:12.010
So we're gonna go over this now.

00:41:12.150 --> 00:41:14.420
How to launch from your home screen.

00:41:15.680 --> 00:41:19.970
You'll see in the action button,
you can get-- you have an

00:41:20.040 --> 00:41:22.250
option to add to home screen.

00:41:25.730 --> 00:41:29.260
And that will add an icon.

00:41:29.330 --> 00:41:32.630
And in your app,
you can actually find out if the user

00:41:33.440 --> 00:41:39.060
is in standalone mode without Safari UI,
which we'll go into next,

00:41:39.100 --> 00:41:43.660
and guide them to the action
button using this check,

00:41:43.660 --> 00:41:46.200
if navigator standalone.

00:41:48.550 --> 00:41:52.400
Your home screen icons will be--
should support-- must support,

00:41:52.400 --> 00:41:56.490
I should say,
Retina display and the normal-- and

00:41:56.490 --> 00:41:59.730
the 3GS and iPod Touch displays.

00:42:00.010 --> 00:42:03.690
You can specify this with
Apple Touch icon relation.

00:42:05.260 --> 00:42:09.880
Use the sizes attribute for
iPad and iPhone 4 so your icons

00:42:09.960 --> 00:42:12.390
look great on the home screen.

00:42:13.260 --> 00:42:19.080
If you don't want the default icon
gloss that's applied to all icons,

00:42:19.400 --> 00:42:25.280
Add this relation and the
reference to your ping.

00:42:27.200 --> 00:42:31.240
So we talked about the standalone--
bringing the app to the home screen

00:42:31.280 --> 00:42:33.380
and checking for standalone mode.

00:42:33.670 --> 00:42:40.340
You can remove Safari UI if your app
is launched from the home screen,

00:42:40.430 --> 00:42:47.320
and you provide this meta
tag in your main resource.

00:42:49.060 --> 00:42:51.110
From the home screen,
your app will be launched with your

00:42:51.120 --> 00:42:55.380
high-res icon for retina display,
and with this meta tag,

00:42:55.410 --> 00:42:56.390
your app will launch.

00:42:56.470 --> 00:42:59.490
Your web app will look
just like an iOS app.

00:43:05.580 --> 00:43:09.540
Now you have your app launching,
and you may think, well, the status bar,

00:43:09.550 --> 00:43:14.180
the status bar color really
conflicts with my application.

00:43:14.250 --> 00:43:17.910
You actually have three colors to
choose from for your status bar.

00:43:18.820 --> 00:43:21.660
Black, black translucent, and default.

00:43:21.710 --> 00:43:23.810
To make sure it looks great,

00:43:24.510 --> 00:43:30.280
And that's, again,
a meta tag in the main resource.

00:43:34.170 --> 00:43:37.580
If you have links in your web app,
which you probably do if you haven't

00:43:37.640 --> 00:43:42.160
yet turned it into an iOS web app,
if you have links to other pages,

00:43:42.830 --> 00:43:45.610
Even if it's on your security origin,
if it's in your domain,

00:43:45.810 --> 00:43:49.030
those links will open in Safari.

00:43:50.410 --> 00:43:56.000
So you should design your web app
to use HTML-- XML HTTP request to

00:43:56.100 --> 00:44:00.800
pull in resources from your-- from
your site without launching Safari.

00:44:00.850 --> 00:44:03.610
And that's how you stay out of Safari.

00:44:04.890 --> 00:44:09.430
And because this is a web app,
when a user hits on the home screen icon,

00:44:09.430 --> 00:44:14.400
it takes some time to
load all the resources.

00:44:14.560 --> 00:44:17.400
And as that time passes,
what happens now by default?

00:44:17.570 --> 00:44:23.860
Well, we show you a screenshot of what
the web app looked like last.

00:44:23.990 --> 00:44:26.940
When the web app was closed,

00:44:28.150 --> 00:44:29.880
We actually -- and it reopened.

00:44:29.980 --> 00:44:32.860
We actually reload the web app on launch.

00:44:32.890 --> 00:44:39.010
And so what could happen is a jarring
transition between the last screenshot of

00:44:39.060 --> 00:44:42.940
your app and reloaded state of your app.

00:44:43.040 --> 00:44:47.020
And to avoid that kind of transition,
you can add startup images.

00:44:47.190 --> 00:44:53.950
So as your app loads,
you'll show something that's -- you know,

00:44:53.950 --> 00:44:53.950
show something that looks good.

00:44:55.040 --> 00:45:01.900
And you can do this for iPhone and iPod
Touch only in portrait orientation.

00:45:01.900 --> 00:45:04.690
And you'll use media queries

00:45:06.140 --> 00:45:09.520
This is the relation you use,
Apple Touch Startup Image,

00:45:09.710 --> 00:45:13.000
and you provide the media query
that you're all familiar with now

00:45:13.170 --> 00:45:17.260
for iPhone 3GS and iPod Touch,
and you start a ping.

00:45:18.140 --> 00:45:20.110
And for Retina Display,
that's the resolution you'll use,

00:45:20.160 --> 00:45:22.860
640 by 920.

00:45:22.890 --> 00:45:27.580
And again, you'll use the media query for
iPhone 4 for Retina Display.

00:45:27.660 --> 00:45:35.080
On iPad, though, the startup image could
be orientation specific.

00:45:36.720 --> 00:45:40.190
Again, you'll use media queries,
and you have to provide

00:45:40.190 --> 00:45:44.060
exact image dimensions.

00:45:44.150 --> 00:45:48.110
768 by 10, 4 for portrait.

00:45:49.320 --> 00:45:53.500
Again, it's that Apple Touch Startup
image relation.

00:45:53.540 --> 00:45:57.740
And for landscape, 1024 by 748.

00:46:00.940 --> 00:46:04.530
So we went over how to make
your web app look good on iOS.

00:46:04.670 --> 00:46:09.540
First, we provide CSS that's specific
for resolutions and CSS specific

00:46:09.540 --> 00:46:11.580
for different orientations.

00:46:11.900 --> 00:46:17.810
We went over how to launch your app as
an iOS app from the home screen with--

00:46:18.020 --> 00:46:20.880
Correct resolution of icons
with the correct color of the

00:46:20.880 --> 00:46:23.010
title bar of the status bar.

00:46:23.950 --> 00:46:28.360
And as your app loads,
we show a startup image.

00:46:28.550 --> 00:46:32.340
So now we've gone from a website

00:46:33.760 --> 00:46:38.600
that had a cluttered UI that
was in Safari to a standalone

00:46:38.600 --> 00:46:41.100
web app that's interactive,
has gestures,

00:46:41.100 --> 00:46:44.350
is orientation and location aware.

00:46:44.680 --> 00:46:50.610
And we used HTML5 technologies
and some tricks in iOS.

00:46:51.570 --> 00:46:56.370
With touch and gestures,
you can create intuitive UI in your app.

00:46:56.470 --> 00:46:59.850
With geolocation, you can make your app
aware of where the user is,

00:47:00.140 --> 00:47:03.200
who's near him, what's around.

00:47:03.260 --> 00:47:06.020
Adds a lot of context to your web app.

00:47:07.840 --> 00:47:12.540
You can use motion and orientation
to add a new sense to your app.

00:47:12.570 --> 00:47:15.530
Your app can be aware of
how the user is holding it,

00:47:15.590 --> 00:47:18.700
how they're shaking it physically,
add a lot of interactivity

00:47:18.700 --> 00:47:21.200
to your web app.

00:47:21.250 --> 00:47:26.640
You can use HTML5 application
cache to bring your app offline,

00:47:26.700 --> 00:47:30.510
and it can look really
good just as an iOS app.

00:47:32.500 --> 00:47:35.210
So now you have everything
you need to know to make rich,

00:47:35.350 --> 00:47:38.630
dynamic, interactive websites,
web apps on iOS.

00:47:38.660 --> 00:47:41.940
And I look forward to seeing
what you guys come up with.

00:47:41.960 --> 00:47:43.400
Thank you.

00:47:49.530 --> 00:47:51.940
If you have any questions,
contact Vicki Murley,

00:47:51.940 --> 00:47:54.300
our Safari Technologies Evangelist.

00:47:54.360 --> 00:47:56.930
Check out
Safari Dev Center documentation.

00:47:57.130 --> 00:48:01.010
And don't be afraid to
look at the W3C spec.

00:48:01.030 --> 00:48:04.560
It's a great resource to find
out how web browsers work.

00:48:04.880 --> 00:48:07.000
Upcoming session, HTML5 Offline Storage.

00:48:07.060 --> 00:48:08.160
You've got to see that.

00:48:08.160 --> 00:48:09.250
It's on Thursday.
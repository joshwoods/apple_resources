WEBVTT

00:00:12.110 --> 00:00:14.000
Hello, good morning everybody.

00:00:14.000 --> 00:00:15.000
Good morning.

00:00:15.010 --> 00:00:17.500
Good morning,
thank you so much for coming.

00:00:17.740 --> 00:00:21.760
So this is session 112,
Writing Easy-To-Change Code:

00:00:21.810 --> 00:00:25.640
Your Second-Most Important Goal
As A Developer.

00:00:25.710 --> 00:00:27.400
And I'm Ken Kocienda.

00:00:27.480 --> 00:00:29.040
And again, thanks for coming.

00:00:29.150 --> 00:00:32.240
So this is a talk about writing code.

00:00:32.240 --> 00:00:35.140
Unlike some other sessions
where you get some specifics

00:00:35.240 --> 00:00:38.560
about new APIs or features,
this is sort of more general,

00:00:38.810 --> 00:00:42.000
talking about writing
code day in and day out.

00:00:42.000 --> 00:00:42.740
That's what I do.

00:00:42.740 --> 00:00:44.470
I think that's what a lot of you do.

00:00:44.520 --> 00:00:51.000
And so I think there's a lot of
interesting things to talk about.

00:00:51.210 --> 00:00:55.000
In terms of making your code easy
to read and learn and understand

00:00:55.000 --> 00:00:57.790
and maintain and easy to change.

00:00:57.890 --> 00:01:00.180
Easy-to-change code.

00:01:01.140 --> 00:01:02.930
Easy-to-change software.

00:01:02.930 --> 00:01:06.400
I think that this is your
second most important goal.

00:01:06.400 --> 00:01:08.160
So we'll get to the punchline right away.

00:01:08.160 --> 00:01:12.410
What is the first most
important goal that you have?

00:01:12.470 --> 00:01:14.240
I say, right?

00:01:14.240 --> 00:01:17.850
What's your most important goal?

00:01:17.850 --> 00:01:21.190
I say that is to ship products.

00:01:26.300 --> 00:01:31.510
That's your most important goal and
this is certainly how we think at Apple.

00:01:31.540 --> 00:01:34.560
I think some of you from the
applause you think that way as well.

00:01:34.650 --> 00:01:39.330
And at Apple we've done over
30 iOS releases since 2007.

00:01:39.420 --> 00:01:43.220
It's a huge amount of change
in a very short amount of time.

00:01:43.220 --> 00:01:46.400
And so we've come up with some
ways to try to manage that change,

00:01:46.410 --> 00:01:49.680
try to actually keep going at that pace.

00:01:49.680 --> 00:01:51.400
Because after all,
releases are complicated.

00:01:51.400 --> 00:01:53.680
There's all these things
that you need to juggle.

00:01:53.870 --> 00:01:56.190
There's new hardware and there's
legal and there's new features

00:01:56.290 --> 00:01:59.060
and there's tight schedules and
people are coming and going.

00:01:59.060 --> 00:02:05.080
There's lots of things to kind of
juggle to keep those releases on track.

00:02:05.250 --> 00:02:11.360
And so this talk is all about some
ideas to help you make change easier.

00:02:11.480 --> 00:02:13.700
Some ideas that I try
to put into practice,

00:02:13.790 --> 00:02:16.280
and I think that at Apple we
try to put into practice all

00:02:16.280 --> 00:02:18.160
the time in developing software.

00:02:18.160 --> 00:02:19.160
Right?

00:02:19.590 --> 00:02:21.930
Because you're always
changing your software.

00:02:21.960 --> 00:02:26.100
Try to make that change easy since you
always need to change your software.

00:02:26.100 --> 00:02:28.040
And what kind of changes
am I talking about here?

00:02:28.040 --> 00:02:30.040
Well, it's the typical stuff.

00:02:30.170 --> 00:02:32.360
I mean, it's not anything really
all that surprising.

00:02:32.400 --> 00:02:37.580
It's bug fixing and adding new
features and enhancing existing ones,

00:02:37.580 --> 00:02:38.110
right?

00:02:38.480 --> 00:02:42.500
Changing code that you wrote, yeah,
sometimes maybe six months ago.

00:02:42.500 --> 00:02:43.500
You did something.

00:02:43.500 --> 00:02:45.780
You were just hacking it
together to get a release done.

00:02:45.900 --> 00:02:49.100
And you go back later and you say, "Gosh,
what is this even trying to do?" Right?

00:02:49.100 --> 00:02:52.540
So if you kind of go up front
and think ahead of time to try to

00:02:52.540 --> 00:02:59.080
make your code easier to change,
going back later won't be such a hassle.

00:02:59.080 --> 00:02:59.080
Right?

00:02:59.700 --> 00:03:02.200
And so for the rest of the talk,
I'll be talking about some

00:03:02.200 --> 00:03:06.020
general conventions that apply to
whatever kind of software you're

00:03:06.020 --> 00:03:10.700
developing on whatever platform,
but then also some Mac and

00:03:10.700 --> 00:03:13.790
iOS-specific conventions.

00:03:14.980 --> 00:03:16.310
So, that's the pitch.

00:03:16.360 --> 00:03:18.710
I hope you are interested in staying.

00:03:18.800 --> 00:03:21.330
For the rest of the talk,
I've structured things

00:03:21.380 --> 00:03:23.970
along a series of topics,
or different angles,

00:03:23.970 --> 00:03:26.770
different ways of looking
at this same idea of making

00:03:26.770 --> 00:03:28.400
your software easy to change.

00:03:28.700 --> 00:03:30.040
So, things to think about.

00:03:30.210 --> 00:03:32.110
And here they are.

00:03:32.220 --> 00:03:34.590
As you can follow along,
make a little checklist

00:03:34.690 --> 00:03:37.380
perhaps as I'm going through.

00:03:38.400 --> 00:03:41.540
Different ways of looking
at this same problem.

00:03:41.690 --> 00:03:44.170
So, let's get started.

00:03:44.280 --> 00:03:46.810
The first one is about style.

00:03:47.080 --> 00:03:49.950
And I think that style
is more than skin deep.

00:03:50.060 --> 00:03:51.740
Well,
what is kind of that skin deep level?

00:03:51.740 --> 00:03:54.960
Well, I think the first thing we
think about when we think of

00:03:55.140 --> 00:03:56.300
style is coding conventions.

00:03:56.500 --> 00:04:00.100
And, you know, nothing, you know,
no rocket science here.

00:04:00.100 --> 00:04:02.450
It's, you know,
I think we all have a style,

00:04:02.530 --> 00:04:05.760
how we like to structure our if
statements and our parentheses

00:04:05.760 --> 00:04:07.780
and capitalize things,
right?

00:04:08.390 --> 00:04:10.100
But, um...

00:04:10.710 --> 00:04:15.390
I think that while local
consistency is important,

00:04:15.390 --> 00:04:18.630
I mean, you don't want different
styles of all those different

00:04:18.630 --> 00:04:20.620
things in one block of code.

00:04:20.940 --> 00:04:23.140
Local consistency is important, for sure.

00:04:23.270 --> 00:04:27.300
But I think that's really
only the beginning of style.

00:04:28.270 --> 00:04:33.710
"And real style runs deeper
than that." And so here I've got

00:04:33.800 --> 00:04:37.370
a quote from a famous writer,
19th century writer.

00:04:37.490 --> 00:04:40.290
"People think I can teach them style.

00:04:40.650 --> 00:04:41.560
What stuff it all is.

00:04:41.730 --> 00:04:45.400
Have something to say,
and say it as clearly as you can.

00:04:45.400 --> 00:04:50.010
That's the only secret to style."
And so if I were to reduce

00:04:50.010 --> 00:04:53.230
that slide down to one word,
here it is: clarity.

00:04:53.400 --> 00:04:58.400
Clarity is what you should really
be striving for above anything else.

00:04:58.410 --> 00:05:03.380
Because just like clear writing is easy
to understand when you're reading it,

00:05:03.380 --> 00:05:07.400
I think that clear code
is easier to change.

00:05:07.400 --> 00:05:09.810
And of course we're changing
our software all the time,

00:05:10.030 --> 00:05:10.400
right?

00:05:10.400 --> 00:05:13.150
So if you write your code clearly,
it'll be easier to change

00:05:13.150 --> 00:05:14.290
later when you go back.

00:05:14.400 --> 00:05:19.400
So what are the elements
of a clear coding style?

00:05:19.400 --> 00:05:21.680
To be honest,
I could spend the rest of the

00:05:21.680 --> 00:05:23.400
hour answering that question.

00:05:23.440 --> 00:05:27.560
But to just pick out a couple
things for just this session,

00:05:27.560 --> 00:05:32.330
I think good names and common idioms
are two good things to talk about.

00:05:32.460 --> 00:05:37.480
Now when it comes to the first one,
good names, I think we all know that,

00:05:37.480 --> 00:05:39.700
well, you know, a class,
the name of a class should

00:05:39.770 --> 00:05:41.280
describe what the class does.

00:05:41.430 --> 00:05:43.380
Same thing goes for a method.

00:05:43.390 --> 00:05:46.260
A method should describe clearly
what the code in the method does.

00:05:46.400 --> 00:05:49.540
So I'd like to look at a couple
of maybe sort of less common

00:05:49.540 --> 00:05:53.180
ways of thinking about good
names and good descriptive names.

00:05:54.700 --> 00:08:09.000
[Transcript missing]

00:08:09.560 --> 00:08:14.660
And so I think if we change the
method to just be more descriptive,

00:08:14.660 --> 00:08:16.900
it's now a lot clearer what it does.

00:08:16.900 --> 00:08:20.590
If you go in back and put
this in the calling code,

00:08:20.590 --> 00:08:25.590
it's very easy to see what that
yes/no is trying to communicate.

00:08:26.890 --> 00:08:29.940
So again, good names are descriptive,
and not just where you typically think,

00:08:30.050 --> 00:08:32.690
right, classes and methods,
but also little things,

00:08:32.820 --> 00:08:35.880
just like variable names,
Boolean variables.

00:08:36.400 --> 00:08:40.150
Okay, so that's good names.

00:08:40.160 --> 00:08:43.110
Now a little bit about common idioms.

00:08:45.890 --> 00:08:49.070
So now I would say that this line
of code is not very idiomatic,

00:08:49.070 --> 00:08:49.790
right?

00:08:49.880 --> 00:08:51.660
Try to take a look at that quickly.

00:08:51.780 --> 00:08:55.010
My goodness,
what is this even trying to do?

00:08:55.760 --> 00:08:58.590
Do you really want to count square
brackets when you're trying to

00:08:58.590 --> 00:09:03.680
go and read a line of code to
try to understand what it does?

00:09:04.000 --> 00:09:06.750
Very, very difficult to see
what that is trying to do.

00:09:06.990 --> 00:09:10.740
If you rewrite that, again,
that idea of clarity,

00:09:10.740 --> 00:09:12.700
you're not just communicating
to the compiler,

00:09:12.700 --> 00:09:15.010
you're also communicating
to other developers and to

00:09:15.010 --> 00:09:16.640
yourself six months from now.

00:09:16.740 --> 00:09:19.040
So if you just take a little
time and rewrite that and

00:09:19.040 --> 00:09:22.790
just make it a little clearer,
now it's easy to see what

00:09:22.790 --> 00:09:25.240
the code is trying to do.

00:09:25.380 --> 00:09:28.780
So rewrite those workhorse lines of code.

00:09:29.940 --> 00:09:33.990
So, even more,
you want to read and understand

00:09:33.990 --> 00:09:38.530
quickly beyond the scope
of a single line of code.

00:09:39.560 --> 00:09:45.570
And I think this is an idea
that comes up quite a bit:

00:09:45.720 --> 00:09:48.010
design patterns.

00:09:48.760 --> 00:09:51.590
Well, what are design patterns?

00:09:51.690 --> 00:09:55.590
These very common patterns that
we see in software quite a bit.

00:09:55.860 --> 00:09:59.410
And we use these
throughout our frameworks.

00:09:59.750 --> 00:10:03.840
At Apple, you use them if you
code on the Mac or iOS.

00:10:03.880 --> 00:10:07.070
And what's more,
we've got these sort of Apple-specific

00:10:07.640 --> 00:10:10.340
patterns that you see quite a bit.

00:10:10.420 --> 00:10:13.470
And we add new ones when the
situation presents itself,

00:10:13.470 --> 00:10:15.740
like the bottom one view controller.

00:10:15.740 --> 00:10:22.090
So sort of this new design pattern that
we use all over iOS to help your job,

00:10:22.090 --> 00:10:26.300
help make your job using
the frameworks easier,

00:10:26.300 --> 00:10:26.960
making your apps easier to develop.

00:10:27.810 --> 00:10:28.700
And so what's good about this?

00:10:28.700 --> 00:10:32.360
It's that these idioms are
communicating to you at a high level.

00:10:32.470 --> 00:10:35.270
If I say ViewController to you,
or if I say Observer,

00:10:35.270 --> 00:10:38.010
or I say Delegation,
it communicates a whole

00:10:38.010 --> 00:10:39.830
series of concepts to you.

00:10:39.980 --> 00:10:44.740
If you put that name,
if you say FooDelegate,

00:10:44.740 --> 00:10:48.940
you can see from the name of the class.

00:10:49.270 --> 00:10:52.200
What that code is supposed to do
and what role it has in the system.

00:10:52.200 --> 00:10:54.440
It communicates at a very,
very high level,

00:10:54.510 --> 00:10:58.120
and you create this shared
vocabulary between you and other

00:10:58.120 --> 00:10:59.250
people that you're coding with.

00:10:59.320 --> 00:11:03.070
Again, sometimes even you and
yourself six months from now,

00:11:03.070 --> 00:11:06.410
right, what a piece of code is
supposed to be doing.

00:11:07.590 --> 00:11:10.300
So use those common idioms,
and as you're looking through

00:11:10.300 --> 00:11:12.800
our developer documentation,
you'll see these names

00:11:12.880 --> 00:11:13.960
coming up quite a bit.

00:11:14.080 --> 00:11:17.350
If you see some name that
repeats itself quite a lot,

00:11:17.380 --> 00:11:20.790
go and try to see what that
design pattern or that common

00:11:20.980 --> 00:11:23.200
idiom is trying to communicate.

00:11:23.200 --> 00:11:30.410
It'll really help you try to get to the
bottom of what our frameworks do and

00:11:30.410 --> 00:11:30.410
how you can make the best use of them.

00:11:33.100 --> 00:11:40.300
[Transcript missing]

00:11:43.380 --> 00:11:46.320
So in your software,
let's say you have a bug.

00:11:46.620 --> 00:11:49.690
Well, why do you have a bug?

00:11:50.070 --> 00:11:53.510
A lot of times it's because there
was something that you didn't

00:11:53.510 --> 00:11:57.610
anticipate or you didn't understand
about your code or somebody else's

00:11:57.610 --> 00:11:59.600
code that you're depending on.

00:11:59.760 --> 00:12:02.170
And so you have to go and debug, right?

00:12:02.230 --> 00:12:03.820
Simple.

00:12:04.290 --> 00:12:08.040
Here's a quote from a great
developer about debugging:

00:12:08.090 --> 00:12:10.690
"Everyone knows that debugging
is twice as hard as writing

00:12:10.690 --> 00:12:12.200
a program in the first place.

00:12:12.320 --> 00:12:15.030
So if you are as clever as
you can be when you write it,

00:12:15.040 --> 00:12:20.000
how will you ever debug
it?" Brian Kernaghan

00:12:20.310 --> 00:12:31.010
Ryan Kernaghan, the K from KNRC, right?

00:12:31.010 --> 00:12:31.010
So, well, let's say that, you know,
you get this bug, so your step one,

00:12:31.010 --> 00:12:31.010
I guess you think, is, well,
you fire up the debugger.

00:12:32.820 --> 00:12:34.660
What are you really looking for?

00:12:34.660 --> 00:12:36.610
You see this bug and
you go into this bugger,

00:12:36.610 --> 00:12:37.110
right?

00:12:37.170 --> 00:12:41.690
What is it that you're hoping
the debugger will tell you?

00:12:42.400 --> 00:12:49.140
And so before I fire up the debugger,
I like to take some time and think first.

00:12:49.500 --> 00:12:51.140
How could a bug happen?

00:12:51.260 --> 00:12:55.390
If a bug is happening in the software,
what situation could make the bug,

00:12:55.390 --> 00:12:59.320
what could make the software
behave like I just saw?

00:12:59.650 --> 00:13:01.270
That's wrong.

00:13:03.230 --> 00:13:06.260
Go back to Brian Kernaghan,
the most effective debugging

00:13:06.260 --> 00:13:09.790
tool is still careful thought,
coupled with judiciously

00:13:09.790 --> 00:13:11.500
placed print statements.

00:13:11.500 --> 00:13:15.420
It seems very old-fashioned, right?

00:13:15.420 --> 00:13:20.300
But I admit that probably, you know,
Xcode Debugger,

00:13:20.300 --> 00:13:22.960
we put a huge amount of investment in it,
it's a great tool,

00:13:23.010 --> 00:13:27.490
but I have to say that 98% of the
time I debug with print statements.

00:13:27.490 --> 00:13:29.980
I've written a lot of
software over my career,

00:13:29.980 --> 00:13:32.460
and most of it has been
debugged with print statements.

00:13:32.570 --> 00:13:37.380
And careful thought, that's really it,
because debugging, after all,

00:13:37.380 --> 00:13:38.940
is understanding.

00:13:39.900 --> 00:13:43.170
It's increasing your understanding
about how your code works.

00:13:43.250 --> 00:13:47.220
It's not just jiggling code around
until the problem goes away.

00:13:47.400 --> 00:13:50.530
Have you ever done this?

00:13:50.810 --> 00:13:54.400
You use performSelector
with objectAfterDelay.

00:13:54.400 --> 00:13:57.800
If I just take this line of
code and make it happen later,

00:13:57.910 --> 00:14:02.590
maybe with zero, performAfterDelay zero,
make that code run at the

00:14:02.590 --> 00:14:04.240
bottom of the run loop.

00:14:04.960 --> 00:14:05.900
That's rarely right.

00:14:05.900 --> 00:14:07.400
That's rarely the right answer.

00:14:07.400 --> 00:14:11.810
It might make the bug go away,
but you probably just set a

00:14:11.810 --> 00:14:15.810
little trap in your software that
you may just trigger later on.

00:14:15.900 --> 00:14:18.730
Or if you do this,
if you just take two lines of

00:14:18.730 --> 00:14:21.900
code and just switch their order,
bug's gone.

00:14:21.900 --> 00:14:22.900
But why?

00:14:22.900 --> 00:14:26.930
Why did that make the bug go away?

00:14:29.440 --> 00:14:31.700
And I think that instead
of just doing that,

00:14:31.720 --> 00:14:35.010
you should really try to have
a good understanding of why

00:14:35.010 --> 00:14:38.070
your code change fixes the bug.

00:14:38.190 --> 00:14:41.870
And you should be able to tell
a story about your bug fix.

00:14:41.990 --> 00:14:43.820
Sometimes it's like
I investigate a bug and I go,

00:14:43.820 --> 00:14:46.580
"Eureka, I think I understand
what's going on here now.

00:14:46.580 --> 00:14:51.260
And before I even code the fix,
before I even write the

00:14:51.280 --> 00:14:53.840
software to fix the bug,
I'll get up and go

00:14:53.840 --> 00:14:55.000
tell somebody about it.

00:14:55.300 --> 00:14:58.060
Go and tell my story."
Because a lot of times,

00:14:58.060 --> 00:15:00.510
boy, when you think, you're sitting there
thinking at your desk,

00:15:00.580 --> 00:15:02.800
it's like, "Oh,
this is a good idea." And then you try

00:15:02.880 --> 00:15:04.490
to go and verbalize it to somebody.

00:15:04.770 --> 00:15:06.880
Actually go and tell a story,
and it's like, "Nah,

00:15:06.880 --> 00:15:11.430
that doesn't really make sense."
Or you go and maybe somebody else

00:15:11.430 --> 00:15:16.650
is really the expert on the piece
of code that you're working on,

00:15:16.780 --> 00:15:20.660
and they may have more understanding,
more knowledge that they

00:15:20.660 --> 00:15:22.280
can bring to your story.

00:15:22.280 --> 00:15:26.640
And again, maybe make it not seem
so solid and together.

00:15:26.760 --> 00:15:27.190
Or the opposite.

00:15:27.250 --> 00:15:29.410
Hopefully it is exactly
what needs to be done.

00:15:29.420 --> 00:15:33.330
And then you go back to your
desk and you write the fix.

00:15:33.340 --> 00:15:36.360
If you write it up,
go find yet a third person and tell that

00:15:36.360 --> 00:15:38.540
same story again during the code review.

00:15:38.540 --> 00:15:41.740
Spread that knowledge
throughout your team,

00:15:41.740 --> 00:15:43.340
your organization.

00:15:43.370 --> 00:15:48.540
And maybe you're doing this at 2:30 a.m.

00:15:48.540 --> 00:15:51.740
and there's nobody around,
so instead maybe write that story

00:15:51.740 --> 00:15:55.790
into your bug tracker somewhere
to capture that information

00:15:55.820 --> 00:15:57.200
about that increase in bugs.

00:15:57.200 --> 00:15:59.150
And then you go back to your software
and you try to get that increased

00:15:59.180 --> 00:16:00.290
understanding about your software.

00:16:00.410 --> 00:16:04.520
Because a lot of times, right,
a bug fix should be about anticipating

00:16:04.520 --> 00:16:09.940
more and understanding better about
the environment your software lives

00:16:10.110 --> 00:16:13.720
in and what it's trying to do.

00:16:13.770 --> 00:16:15.950
So that's stories.

00:16:17.590 --> 00:16:21.720
Next, laziness, or maybe what a lot of
you are thinking is,

00:16:21.800 --> 00:16:24.790
"Just wake me when it's over."

00:16:25.100 --> 00:17:40.500
[Transcript missing]

00:17:41.610 --> 00:17:45.260
So now if we go and take a look at
the implementation of the init method,

00:17:45.260 --> 00:17:52.400
a lot of times you'll see this,
where that singleton object needs

00:17:52.400 --> 00:17:57.670
to use another singleton object to
go and deliver all of its features,

00:17:57.670 --> 00:17:58.350
right?

00:17:58.460 --> 00:18:02.320
So this init method calls
another singleton object.

00:18:02.450 --> 00:18:04.520
And if we kind of go and we switch them,
right?

00:18:04.520 --> 00:18:07.510
So we've got the foo
calls the bar controller.

00:18:07.610 --> 00:18:10.410
And if we go over to the bar controller,
well, guess what?

00:18:10.510 --> 00:18:10.660
Right?

00:18:10.660 --> 00:18:17.040
The bar controller contains
a call to the foo controller.

00:18:17.040 --> 00:18:22.780
So now we've got this little
circular bit of lazy initialization.

00:18:22.820 --> 00:18:26.600
And this can cause an init storm,
because a lot of times it's not

00:18:26.600 --> 00:18:30.870
just two controllers which have
a relationship to each other.

00:18:31.090 --> 00:18:34.740
Sometimes you have a large
graph of controllers.

00:18:36.050 --> 00:18:38.600
That all depend on each other.

00:18:38.690 --> 00:18:42.740
And there are several problems to this.

00:18:43.140 --> 00:18:45.980
One is you might get a long pause,
not at application startup,

00:18:45.980 --> 00:18:49.310
so you solve one problem,
but you gave yourself another problem.

00:18:49.310 --> 00:18:53.470
So now the first time the user
goes and accesses a feature,

00:18:53.470 --> 00:18:59.600
there's a long stutter while all of these
objects go and instantiate themselves.

00:18:59.700 --> 00:19:03.790
So you don't want long
pauses in your program,

00:19:03.790 --> 00:19:03.790
obviously.

00:19:04.180 --> 00:19:08.100
But there's a more difficult problem,
which is the order of

00:19:08.100 --> 00:19:09.530
initialization problem.

00:19:09.730 --> 00:19:12.950
I mean, depending from that code example,
depending on whether I access

00:19:13.020 --> 00:19:16.050
the foo controller first or
the bar controller first,

00:19:16.090 --> 00:19:18.540
the code is going to run
in a different order.

00:19:18.540 --> 00:19:22.880
And that might not be known
while you're developing the code.

00:19:22.880 --> 00:19:26.100
It might just be based on
what the user does first,

00:19:26.250 --> 00:19:28.670
which features are used first.

00:19:28.780 --> 00:19:32.260
And it makes it more difficult
to understand how your software

00:19:32.260 --> 00:19:34.080
is going to behave and,
of course,

00:19:34.190 --> 00:19:41.280
managing change in your software
also is complicated by that.

00:19:42.790 --> 00:19:46.990
And yet there's one more
problem to lazy initialization,

00:19:46.990 --> 00:19:51.540
which doesn't exist in this code,
which uses dispatch once to

00:19:51.540 --> 00:19:55.970
go and allocate the instance
the first time this is called.

00:19:56.290 --> 00:20:04.260
If you have some older code,
which was written before dispatch was

00:20:04.260 --> 00:20:06.630
available on either the Mac or iOS,
you maybe wrote it like this.

00:20:07.210 --> 00:20:12.120
Well, you're just checking to see whether
that instance has been assigned yet.

00:20:12.120 --> 00:20:15.600
Not whether the object has been created,
but whether it's been

00:20:15.600 --> 00:20:16.740
assigned to that instance.

00:20:16.740 --> 00:20:19.180
And of course, that init,
that alloc and init,

00:20:19.360 --> 00:20:25.700
will completely run its entire call
chain before that instance gets assigned.

00:20:25.700 --> 00:20:28.700
You could actually, or if you're running
with multiple threads,

00:20:28.840 --> 00:20:31.670
calling it to this controller,
you've got a big problem.

00:20:31.680 --> 00:20:36.740
You might wind up with multiple
instances of a singleton.

00:20:37.100 --> 00:20:38.730
Which is probably not what you want.

00:20:38.740 --> 00:20:41.620
You wouldn't have written the
code like this if you could

00:20:41.620 --> 00:20:43.340
have more than one instance.

00:20:43.340 --> 00:20:45.620
So it's a problem.

00:20:47.630 --> 00:20:48.600
It's a mess.

00:20:48.600 --> 00:20:55.980
And so, well, what's the solution to...

00:20:56.150 --> 00:20:58.540
This lazy initialization problem.

00:20:58.560 --> 00:21:00.380
Unfortunately,
there are no silver bullets.

00:21:00.380 --> 00:21:01.730
It really is kind of case by case.

00:21:01.830 --> 00:21:03.680
But here are a couple of ideas.

00:21:03.850 --> 00:21:08.140
You can think about maybe
doing a lightweight of all

00:21:08.140 --> 00:21:11.770
of these controller objects,
and maybe not necessarily init them,

00:21:11.910 --> 00:21:15.910
or maybe partially init them in
a lightweight way that doesn't

00:21:15.990 --> 00:21:21.920
involve calls outside of the
class to other big components,

00:21:21.920 --> 00:21:23.440
other big controllers.

00:21:23.470 --> 00:21:27.290
Or you can decompose your controllers
better so that they don't rely

00:21:27.290 --> 00:21:29.370
on each other quite so much.

00:21:31.830 --> 00:21:35.090
Yet another idea is to have
alternative accessor patterns.

00:21:35.100 --> 00:21:38.720
So instead of that shared instance,
you could have variations of

00:21:38.860 --> 00:21:42.820
accessors to go get these singletons,
something like active instance,

00:21:42.960 --> 00:21:46.300
which will only return the instance
if it's already been created.

00:21:46.300 --> 00:21:49.930
It won't create it if it
hasn't been created yet.

00:21:50.320 --> 00:21:55.010
This really helps you at program startup.

00:21:55.120 --> 00:21:57.040
I've done this quite a bit,
and it's pretty successful.

00:21:57.420 --> 00:21:58.270
All right.

00:21:58.350 --> 00:21:59.290
Shared Instance or Create if needed.

00:21:59.300 --> 00:22:04.530
It's just yet a more descriptive
name for that very same thing.

00:22:08.250 --> 00:22:09.200
So laziness.

00:22:09.200 --> 00:22:12.760
Think through your lazy initialization.

00:22:12.790 --> 00:22:15.480
But do it so that your
program starts up quickly.

00:22:18.010 --> 00:22:19.010
Okay, next.

00:22:19.010 --> 00:22:19.900
Hygiene.

00:22:20.090 --> 00:22:22.720
You make the mess, you clean it up.

00:22:22.870 --> 00:22:27.410
So I think we can all accept, I mean,
this is true not only for WWDC, but,

00:22:27.660 --> 00:22:31.930
right, it's sort of a little bit of a
little kernel of truth for a life.

00:22:32.060 --> 00:22:34.260
Good hygiene takes effort, right?

00:22:34.300 --> 00:22:38.010
And if we kind of try to
apply that to great writing,

00:22:38.010 --> 00:22:39.310
right, E.B.

00:22:39.310 --> 00:22:44.020
White, a great writer,
he says the best writing is rewriting,

00:22:44.310 --> 00:22:47.860
right, going over,
iterating over your writing.

00:22:47.900 --> 00:22:53.400
Now, in terms of code,
we also don't want to throw away code,

00:22:53.400 --> 00:22:54.370
ever.

00:22:57.620 --> 00:23:00.280
Are those things in conflict?

00:23:00.470 --> 00:23:06.080
If the advice is to keep
iterating and rewriting things,

00:23:06.140 --> 00:23:07.340
but then you don't want
to throw things away,

00:23:07.340 --> 00:23:09.270
well, how do those two things relate?

00:23:09.280 --> 00:23:11.700
Well,
I think that changes in your software

00:23:11.700 --> 00:23:13.440
need to be part of a process.

00:23:13.440 --> 00:23:15.720
There's kind of different
levels of changes,

00:23:15.720 --> 00:23:18.400
different kinds of
change in your software.

00:23:18.400 --> 00:23:22.100
And of course, again,
your first priority should be to ship.

00:23:22.170 --> 00:23:25.170
And of course, kind of keeping your
code easy to change is,

00:23:25.200 --> 00:23:26.950
I think, the best way to do that.

00:23:27.600 --> 00:23:32.890
So, the secret here is not to
rewrite your code from scratch,

00:23:32.960 --> 00:23:34.330
but to refactor.

00:23:34.630 --> 00:23:35.920
And what is refactoring?

00:23:35.980 --> 00:23:38.480
Well, I think that's maybe a lot
of things to a lot of people.

00:23:38.480 --> 00:23:41.820
To try to fit it on one slide,
I think refactoring is keeping

00:23:42.190 --> 00:23:45.260
the functionality of your code,
but just changing the form.

00:23:45.300 --> 00:23:48.320
You don't change the behavior,
you just change the way

00:23:48.320 --> 00:23:49.910
that things are written.

00:23:49.930 --> 00:23:53.600
Saying the same thing,
but saying it with different words,

00:23:53.640 --> 00:23:54.950
a different code.

00:23:55.470 --> 00:23:56.400
Well, what about cruft?

00:23:56.410 --> 00:24:04.540
I mean, I think we've all maybe worked
on projects where code just kind

00:24:04.590 --> 00:24:08.670
of accretes all this junk in it,
and it's kind of hard to work with,

00:24:08.790 --> 00:24:12.330
so you're tempted to just kind of
throw it away and start over again.

00:24:12.400 --> 00:24:15.790
You get this code that's just
too difficult to work with.

00:24:15.970 --> 00:24:18.060
But cruft is not any of these things.

00:24:18.100 --> 00:24:22.260
It's not code you don't understand,
and it's not code you didn't write.

00:24:22.360 --> 00:24:25.010
It's somebody else's problem,
not invented here problem.

00:24:25.110 --> 00:24:28.260
And it's not code that
you don't like either.

00:24:28.350 --> 00:24:35.140
Don't be tempted to just throw away code
that meets any of those characteristics.

00:24:36.000 --> 00:24:40.070
But I do think there is a couple
things we can say about what's

00:24:40.070 --> 00:24:44.830
genuine cruft with a very,
very high degree of confidence.

00:24:44.980 --> 00:24:46.240
So what's genuine cruft?

00:24:46.340 --> 00:24:48.000
Dead code.

00:24:48.140 --> 00:24:51.680
Code that you've got in your
software which never gets called.

00:24:51.750 --> 00:24:54.130
Maybe you had an old feature,
and you've superseded

00:24:54.140 --> 00:24:58.560
it with a new feature,
and the code will now no longer run.

00:24:58.600 --> 00:25:01.380
I think you should get rid of dead code.

00:25:01.420 --> 00:25:03.240
It just gets in people's way.

00:25:03.280 --> 00:25:06.620
You just have to read something,
and maybe if you're new to a project,

00:25:06.710 --> 00:25:07.980
you're reading this
code to understand it,

00:25:07.980 --> 00:25:09.030
and it never runs.

00:25:09.330 --> 00:25:11.170
It's a waste of time.

00:25:11.320 --> 00:25:13.180
So dead code is cruft.

00:25:13.230 --> 00:25:17.560
The other thing is comments,
which no longer apply.

00:25:17.860 --> 00:25:22.230
In other words,
the code and the comments don't match.

00:25:22.860 --> 00:25:25.920
I think by definition it's the
comment that's wrong unless

00:25:26.230 --> 00:25:27.790
there's a really bad bug.

00:25:27.920 --> 00:25:31.450
A lot of times you write the
comment and then the code evolves

00:25:31.450 --> 00:25:35.800
over time so that the comment no
longer matches what the code does.

00:25:35.870 --> 00:25:38.790
And number three,
well there is no number three.

00:25:39.720 --> 00:25:41.290
That's the only thing
that I can think of,

00:25:41.290 --> 00:25:43.140
only two things I can
think of with really,

00:25:43.140 --> 00:25:47.170
really high level of
confidence that's cruft.

00:25:47.240 --> 00:25:49.370
So for the first one,
you can use the compiler

00:25:49.390 --> 00:25:50.520
for dead code checks.

00:25:50.620 --> 00:25:53.610
A lot of times when I'm
looking through my code and

00:25:53.610 --> 00:25:55.480
I think that something is dead,
I'll just go comment out the

00:25:55.480 --> 00:25:57.610
declaration and compile the code
and see if it's actually dead.

00:25:57.620 --> 00:26:00.460
Now sometimes, of course,
you've got a lot of dependencies,

00:26:00.460 --> 00:26:03.190
you might need to build other frameworks
or other apps or other projects,

00:26:03.250 --> 00:26:03.920
right?

00:26:03.920 --> 00:26:05.750
But this is a good way,
if you can actually

00:26:05.750 --> 00:26:07.490
build all of the code,
it's a great way to see

00:26:07.600 --> 00:26:08.260
if the code is dead.

00:26:08.260 --> 00:26:10.410
the compiler will tell you.

00:26:13.800 --> 00:26:16.450
And for comments,
I always like to go back and check them.

00:26:16.460 --> 00:26:20.950
You know, sometimes there's, you know,
you might put a reference

00:26:21.100 --> 00:26:25.740
to a bug in your code,
and the bug was filed 10 years ago.

00:26:25.760 --> 00:26:27.730
You know, it may not be relevant anymore.

00:26:27.740 --> 00:26:31.060
I mean, the software may have evolved
to the point where that

00:26:31.380 --> 00:26:35.340
bug is now such a built-in,
or the fix to that bug is such

00:26:35.340 --> 00:26:38.880
a built-in part of everyone's
conception of the software that

00:26:38.920 --> 00:26:40.440
the comment just gets in the way.

00:26:40.440 --> 00:26:42.060
People are tempted to go
and read in this thing,

00:26:42.060 --> 00:26:43.500
and it's just like, oh,
I already know that.

00:26:43.850 --> 00:26:46.270
That's the way the software works.

00:26:46.970 --> 00:26:49.400
Right, so old comments,
you might even just delete them,

00:26:49.400 --> 00:26:52.780
but particularly delete them
if they don't match the code.

00:26:53.210 --> 00:26:56.410
Because the code itself
is accumulated knowledge.

00:26:56.510 --> 00:27:00.010
Good comments are also
accumulated knowledge.

00:27:02.830 --> 00:27:06.430
And when it comes to the
size of the changes to make,

00:27:06.470 --> 00:27:14.070
I think the size of the change that
you want to make is really important.

00:27:14.180 --> 00:27:17.950
So for small changes,
if I go and fix a bug and I see that

00:27:17.950 --> 00:27:22.380
there's a name that could be improved,
even though changing the name

00:27:22.380 --> 00:27:25.180
to something more descriptive
doesn't really have anything

00:27:25.180 --> 00:27:28.780
to do with the bug fix per se,

00:27:29.060 --> 00:27:33.200
I'll make that change and just write a
little extra note to the code reviewer.

00:27:33.500 --> 00:27:35.900
Say, yeah, yeah,
it's not part of the change,

00:27:35.910 --> 00:27:37.350
but I think this just is better.

00:27:37.480 --> 00:27:39.670
I'm just going to kind
of clean up as I go.

00:27:39.730 --> 00:27:44.120
Make the name,
improve names as you do other things.

00:27:44.120 --> 00:27:47.650
For something medium, you know,
I think that once you get beyond

00:27:47.840 --> 00:27:50.940
the scope of a small change,
a lot of times it's about

00:27:51.120 --> 00:27:55.000
people skills more than anything
having to do with software.

00:27:55.000 --> 00:27:59.990
If you're going to make a medium change,
go and talk to people on your team.

00:27:59.990 --> 00:28:01.490
Think things through.

00:28:01.490 --> 00:28:02.450
Decide.

00:28:02.820 --> 00:28:06.850
Tell yourself a story about the code
change that you want to make and why.

00:28:06.880 --> 00:28:10.730
Maybe changing a set of names,
moving some interfaces to something

00:28:10.730 --> 00:28:14.310
that are maybe a little bit
cleaner and easier to maintain.

00:28:15.070 --> 00:28:18.290
For things that are really large,
we should probably maybe even get up

00:28:18.330 --> 00:28:20.630
and write something on the whiteboard.

00:28:20.630 --> 00:28:23.360
Maybe even write a quick
little design document.

00:28:23.360 --> 00:28:24.430
Put it in email.

00:28:25.390 --> 00:28:30.470
Think about what your change
is in a more formal way.

00:28:30.660 --> 00:28:33.390
I mean, I don't think that you
should be writing huge tomes,

00:28:33.390 --> 00:28:34.050
right?

00:28:34.140 --> 00:28:36.180
But if you kind of think things through,
and again,

00:28:36.180 --> 00:28:40.820
it's really more about people skills than
it is about sort of software or coding.

00:28:41.020 --> 00:28:45.260
Kind of deciding what you
want to do and coming up with

00:28:45.260 --> 00:28:45.260
a good plan before you do it.

00:28:46.160 --> 00:28:50.270
So kind of different scopes of change.

00:28:50.290 --> 00:28:54.160
Of course, you always want to be aware of
regressions when you go and make changes.

00:28:54.270 --> 00:28:57.500
That's what refactoring-- again,
refactoring in most cases,

00:28:57.520 --> 00:29:00.200
is keeping the same
behavior in your software,

00:29:00.200 --> 00:29:01.180
but just changing the form.

00:29:01.320 --> 00:29:03.740
Of course, the best thing that you
can do is to have tests.

00:29:03.740 --> 00:29:03.810
Right?

00:29:03.870 --> 00:29:04.930
You all have tests, right?

00:29:04.980 --> 00:29:07.760
You all have unit tests,
and performance tests,

00:29:07.760 --> 00:29:12.800
and correctness tests for your whole app,
right?

00:29:12.800 --> 00:29:15.060
If you don't, you should.

00:29:15.070 --> 00:29:19.740
Tests make things-- makes
your code easy to change.

00:29:19.770 --> 00:29:21.870
Gives you confidence.

00:29:22.900 --> 00:29:34.900
[Transcript missing]

00:29:35.340 --> 00:29:42.570
We have C, mostly C language family
programs that we write for iOS,

00:29:42.710 --> 00:29:43.420
right?

00:29:43.530 --> 00:29:44.300
GoTo.

00:29:44.310 --> 00:29:50.270
Now, I think that notifications
are just a glorified GoTo.

00:29:52.830 --> 00:29:58.180
But they're worse,
because you don't even say where to go.

00:29:58.340 --> 00:30:00.340
Just post this notification
and somebody's going to be

00:30:00.430 --> 00:30:01.560
listening for it out there.

00:30:01.650 --> 00:30:02.880
At least you think.

00:30:02.920 --> 00:30:03.050
Right?

00:30:03.100 --> 00:30:10.590
But not only that,
you can go to more than one place,

00:30:10.590 --> 00:30:10.590
because more than one hunk of code
can sign up for a notification.

00:30:12.210 --> 00:30:14.870
So it's their go-to, even worse.

00:30:15.210 --> 00:30:17.280
Now, why do I think this is even worse?

00:30:17.380 --> 00:30:21.240
Well, one of the things that I think it
does is it frustrates code inspection.

00:30:21.390 --> 00:30:25.420
Maybe you've written a bit
of code and you attach that

00:30:25.770 --> 00:30:30.320
patch to an email to somebody,
and the code reviewer reading

00:30:30.380 --> 00:30:33.830
that can't tell easily,
necessarily.

00:30:34.060 --> 00:30:38.300
What that notification is going to do,
what code is going to run as a result

00:30:38.300 --> 00:30:39.850
of a line of code being called.

00:30:39.850 --> 00:30:45.410
You can't see many times
easily what code will run.

00:30:49.610 --> 00:30:54.030
The behavior is non-deterministic
if you have more than one

00:30:54.030 --> 00:30:56.480
callback for a notification.

00:30:56.530 --> 00:30:59.090
The callbacks are unordered.

00:30:59.380 --> 00:31:03.880
There's no guarantee that the
system makes that one client which

00:31:03.880 --> 00:31:07.800
is signed up for a notification
will run before another.

00:31:07.910 --> 00:31:11.770
So notifications, I think,
can complicate change.

00:31:13.320 --> 00:31:16.390
Because it makes it more
difficult to understand what

00:31:16.390 --> 00:31:18.260
your software is going to do.

00:31:18.260 --> 00:31:23.090
Now, all that said, they're not all bad.

00:31:24.570 --> 00:31:28.070
Because notifications can
promote loose coupling.

00:31:28.430 --> 00:31:31.990
If two pieces of code can communicate
with each other and they don't

00:31:31.990 --> 00:31:35.210
know directly about each other,
that can be a good thing.

00:31:35.400 --> 00:31:38.520
Because you can change one
without necessarily having to

00:31:38.520 --> 00:31:40.220
worry too much about the other.

00:31:40.400 --> 00:31:42.370
And there are two really
good examples of that.

00:31:42.430 --> 00:31:46.910
Model View Controller uses
notifications to communicate between

00:31:46.910 --> 00:31:48.400
the different elements of MVC.

00:31:48.400 --> 00:31:57.930
And Core Data uses notification
to communicate changes in data.

00:32:02.070 --> 00:32:07.880
I think that if you can think
of your notifications in terms

00:32:07.890 --> 00:32:11.770
of will and did notifications,
if you've got something and you

00:32:11.910 --> 00:32:13.700
want to tell somebody else about it,
tell them some other

00:32:13.700 --> 00:32:18.720
piece of code about it,
well then post, "I'm about to change this

00:32:18.720 --> 00:32:24.150
variable notification." Then you
go and change the variable,

00:32:24.150 --> 00:32:27.760
and then perhaps you
might even want to say,

00:32:27.760 --> 00:32:29.070
"I just changed that
variable notification."

00:32:29.330 --> 00:32:33.120
If you can think of your notifications
in terms of will and did,

00:32:33.120 --> 00:32:37.850
giving some hooks to other pieces
of software to let them know about

00:32:37.850 --> 00:32:41.170
pending changes and let them know
about changes which just happened,

00:32:41.180 --> 00:32:45.020
that can be a really good
way to use notifications.

00:32:45.160 --> 00:32:48.680
And I think a good piece of advice,
a lot of times for you,

00:32:48.680 --> 00:32:53.650
since most of you are making apps instead
of Apple where we make frameworks and

00:32:53.650 --> 00:32:58.700
APIs that you all are going to use in
ways that we may not really know about.

00:32:58.700 --> 00:33:00.780
We're trying to make
a flexible framework.

00:33:00.870 --> 00:33:03.400
If you're making an app,
I think a lot of times you

00:33:03.400 --> 00:33:06.200
should know about the endpoints
for your notifications.

00:33:06.360 --> 00:33:11.200
You should know who's sending it
and who's receiving it and why.

00:33:11.290 --> 00:33:12.930
It's not just, "Well,
I think I'm going to put this

00:33:12.930 --> 00:33:16.190
hook in there and I don't know
who may sign up for this."

00:33:16.360 --> 00:33:19.850
If you know about the endpoints,
that helps you keep

00:33:19.850 --> 00:33:22.200
control over notifications.

00:33:22.240 --> 00:33:24.550
You should really think
twice about other uses.

00:33:24.550 --> 00:33:28.200
If you don't know about the endpoints,
if it's something other than will or did,

00:33:28.200 --> 00:33:30.990
really,
really think twice and think about

00:33:30.990 --> 00:33:35.170
whether notifications are the best
way to get the job done because

00:33:35.200 --> 00:33:37.200
code can be too loosely coupled.

00:33:37.200 --> 00:33:40.130
If two pieces of code are
interacting with each other in

00:33:40.130 --> 00:33:43.620
ways that are sort of non-standard,
not idiomatic,

00:33:43.760 --> 00:33:48.190
not using a common pattern,
it can frustrate change,

00:33:48.390 --> 00:33:51.200
make things more difficult to understand.

00:33:51.200 --> 00:33:57.700
An option is to use protocols or
delegates instead of notifications.

00:33:57.700 --> 00:34:01.550
If you think that two pieces of
code really are starting to get this

00:34:01.550 --> 00:34:05.680
real relationship with each other,
make an interface out of it

00:34:05.680 --> 00:34:06.700
or make a delegate out of it.

00:34:09.800 --> 00:34:18.600
[Transcript missing]

00:34:20.200 --> 00:34:21.090
Okay, next.

00:34:21.180 --> 00:34:23.660
Optimization, the 3% solution.

00:34:23.660 --> 00:34:28.420
Probably one of the most famous
quotations about computer

00:34:28.420 --> 00:34:31.130
science from one of the most
famous computer scientists.

00:34:31.140 --> 00:34:33.340
Donald Knuth says,
"We should forget about

00:34:33.340 --> 00:34:37.590
small efficiencies,
say, 97% of the time.

00:34:38.030 --> 00:34:44.260
Premature optimization is the root of
all evil." You've probably heard that.

00:34:44.480 --> 00:34:48.500
So I got out my pencil,
sharpened my pencil,

00:34:48.500 --> 00:34:50.430
and did a little bit of arithmetic.

00:34:50.430 --> 00:34:55.680
Knuth says, "97% of the time." And so,
we should worry about premature

00:34:55.700 --> 00:34:58.100
optimization 3% of the time.

00:34:58.100 --> 00:34:59.860
Well, that's helpful.

00:34:59.860 --> 00:35:02.970
Well, which 3% do I worry about?

00:35:04.200 --> 00:35:05.840
Which 3%?

00:35:05.850 --> 00:35:10.710
Well, if I kind of came up with a laundry
list of things which generally

00:35:10.710 --> 00:35:14.640
speaking can be slow or might be slow.

00:35:14.650 --> 00:35:19.310
Allocating tons of memory,
making a huge number of views, drawing,

00:35:19.310 --> 00:35:23.820
or maybe I've got new code and
I haven't chosen algorithms really

00:35:23.830 --> 00:35:28.550
well lately because I'm still thinking
about what the software should do,

00:35:28.610 --> 00:35:30.760
blocking on information from other code.

00:35:30.780 --> 00:35:32.800
A lot of times unnecessary work.

00:35:32.800 --> 00:35:37.100
A lot of times you write a method
and later you go and look at it

00:35:37.100 --> 00:35:38.680
in instruments in the debugger.

00:35:38.680 --> 00:35:42.230
You wind up calling this method
again and again and again during a

00:35:42.230 --> 00:35:46.720
single iteration of the run loop in
ways that you didn't think about.

00:35:46.720 --> 00:35:49.520
You're just going and doing the
same work over and over again.

00:35:49.520 --> 00:35:53.280
So those things can be slow.

00:35:53.280 --> 00:35:56.040
But really, don't jump to conclusions.

00:35:56.040 --> 00:35:59.490
Only optimize when you've
measured your software.

00:35:59.500 --> 00:36:00.380
Use instruments.

00:36:00.380 --> 00:36:01.240
It's a great tool.

00:36:01.240 --> 00:36:02.800
It's right built into Xcode.

00:36:02.800 --> 00:36:07.080
There's lots of different ways
that you can measure your software.

00:36:07.130 --> 00:36:08.820
So definitely use instruments.

00:36:08.990 --> 00:36:12.980
And only optimize when you
understand what instruments is

00:36:12.980 --> 00:36:15.680
telling you about your software.

00:36:18.770 --> 00:36:22.640
And I'd go even further to say
that as you're looking in the

00:36:22.640 --> 00:36:27.420
profiles which Instrument gives you,
you should go and look and see what

00:36:27.420 --> 00:36:32.120
the hottest functions are and optimize
the ones which you understand the best,

00:36:32.180 --> 00:36:35.590
the ones which have the
clearest role in your program.

00:36:36.410 --> 00:36:38.520
Very likely some new
code might be up there,

00:36:38.520 --> 00:36:41.590
but instead, you might want to pick
instead the one that has,

00:36:41.590 --> 00:36:43.220
you've been living with longer.

00:36:43.480 --> 00:36:46.660
You know what the software is
supposed to be accomplishing.

00:36:47.020 --> 00:36:50.330
And so here's an idea is that
you should optimize your slowest

00:36:50.330 --> 00:36:53.290
and oldest 3% of your code.

00:36:54.520 --> 00:36:56.920
Code that's been around the longest,
and it's the slowest.

00:36:57.120 --> 00:36:58.300
You understand it the best.

00:36:58.630 --> 00:37:01.000
Instruments is telling
you that it's slow.

00:37:01.070 --> 00:37:01.780
There you go.

00:37:01.860 --> 00:37:04.310
That's the code that you optimize.

00:37:09.250 --> 00:37:12.970
And what that will help you to do is to
keep your newest code easy to change,

00:37:13.260 --> 00:37:16.780
because a lot of times that's where the
features are still maybe provisional.

00:37:16.930 --> 00:37:20.350
You don't understand quite so well
maybe what the code is supposed to do.

00:37:20.510 --> 00:37:24.720
You haven't had enough time
to go in and clean things up,

00:37:24.770 --> 00:37:27.060
make things work as
efficiently as possible.

00:37:27.260 --> 00:37:31.150
So keep your newest
code easiest to change.

00:37:32.860 --> 00:37:34.160
And trades are okay.

00:37:34.160 --> 00:37:41.280
So I have a story about years ago,
I was an early developer on

00:37:41.280 --> 00:37:44.860
the Safari project and going
and making the web browser.

00:37:44.860 --> 00:37:47.470
Our goal was to make a
very fast web browser,

00:37:47.600 --> 00:37:49.280
and eventually, we succeeded.

00:37:49.280 --> 00:37:51.640
But in the beginning,
the browser was slow.

00:37:51.660 --> 00:37:54.150
So well,
how do you make a slow program fast?

00:37:54.150 --> 00:37:56.880
And so we came up with this
idea that we were going to

00:37:56.880 --> 00:37:58.490
never make the program slower.

00:37:58.490 --> 00:38:01.860
So from very, very early on,
I developed this tool that allowed

00:38:01.860 --> 00:38:05.520
us to go and just run through a
series of URLs and give timings on

00:38:05.520 --> 00:38:08.160
how fast the pages were loading.

00:38:08.160 --> 00:38:11.710
And so we ran this test every single day.

00:38:11.880 --> 00:38:16.590
And so we knew on a 24-hour or more,
24 hours was the largest

00:38:16.600 --> 00:38:19.420
amount of time that would pass
before we would run the test.

00:38:19.510 --> 00:38:23.190
A lot of times we ran it
before we even checked code in.

00:38:23.780 --> 00:38:27.340
And so we decided that we would never,
ever, ever let the program get slower,

00:38:27.340 --> 00:38:29.860
even as we were adding features.

00:38:29.860 --> 00:38:32.420
And this is where the trades comes in.

00:38:32.600 --> 00:38:36.220
So we added a feature and make
the browser behave more correctly

00:38:36.220 --> 00:38:37.430
in the way that it needs to.

00:38:37.430 --> 00:38:40.300
But how do you do that if it winds
up making the program slower?

00:38:40.300 --> 00:38:41.560
Well, we did what I just said.

00:38:41.560 --> 00:38:45.760
We went and optimized the oldest
and slowest 3% of the code.

00:38:45.870 --> 00:38:49.630
So we went and found a little
bit of headroom someplace

00:38:49.630 --> 00:38:53.520
else to pay for this new code,
this new feature that we added.

00:38:53.700 --> 00:38:56.360
And we decided that this was okay to do.

00:38:56.360 --> 00:38:56.920
It made sense.

00:38:57.060 --> 00:39:00.750
This was a good way to go
and make the software faster.

00:39:00.760 --> 00:39:03.140
And it helped us to really
keep that rule in place.

00:39:03.140 --> 00:39:06.780
Never, ever, ever,
ever make the software slower.

00:39:07.000 --> 00:39:11.890
Don't convince yourself that it's
okay because I'm adding a new feature

00:39:12.010 --> 00:39:14.300
so a little performance hit is okay.

00:39:14.350 --> 00:39:15.680
It's not okay.

00:39:15.680 --> 00:39:17.440
Never make your program slower.

00:39:17.440 --> 00:39:17.560
And it can only either stay the
same or it's going to be slower.

00:39:17.560 --> 00:39:17.970
And it can only either stay the
same or it's going to be slower.

00:39:17.970 --> 00:39:18.960
And it can only either stay
the same or it's or get faster,

00:39:18.960 --> 00:39:19.280
right?

00:39:19.380 --> 00:39:21.490
It's simple logic.

00:39:26.500 --> 00:39:31.370
Right, so the sort of the lather, rinse,
repeat recipe here is right, change,

00:39:31.460 --> 00:39:37.230
test, measure, and optimize, and repeat.

00:39:37.230 --> 00:39:41.600
And that's optimization.

00:39:44.120 --> 00:39:45.280
So next, dependencies.

00:39:45.380 --> 00:39:47.750
Don't call us, we'll call you.

00:39:47.760 --> 00:39:49.100
So me, I'm worried.

00:39:49.100 --> 00:39:50.720
I'm kind of paranoid, right?

00:39:50.720 --> 00:39:52.880
I'm nervous when I go
and change software.

00:39:52.880 --> 00:39:55.160
I'm worried about, well,
what are the implications of

00:39:55.160 --> 00:39:56.450
this change that I just made?

00:39:56.530 --> 00:39:58.800
Particularly,
sometimes I sort of parachute

00:39:58.800 --> 00:40:02.740
in on somebody else's project
and go and jiggle things around,

00:40:02.740 --> 00:40:04.300
right, in my own way.

00:40:04.300 --> 00:40:07.240
I'm worried about, who did I just break?

00:40:07.530 --> 00:40:11.730
What bug did I just introduce
by adding this new code?

00:40:12.120 --> 00:40:15.300
I always am worried about
limiting the collateral damage.

00:40:15.300 --> 00:40:24.200
And so here's a couple of tips on how
to do that from a design point of view,

00:40:24.200 --> 00:40:25.460
from a code design point of view.

00:40:25.460 --> 00:40:28.540
Inheritance trees and call graphs.

00:40:28.540 --> 00:40:31.850
So about inheritance trees,
I think the simple rule

00:40:32.150 --> 00:40:33.790
is shallow is better.

00:40:33.800 --> 00:40:39.110
I think we've decided at Apple in
making our frameworks that we don't

00:40:39.110 --> 00:40:42.910
want to wind up with these deep,
deep, deep inheritance hierarchies.

00:40:43.000 --> 00:40:45.190
We try to keep them as
shallow as possible.

00:40:45.240 --> 00:40:47.470
And why is that, right?

00:40:47.880 --> 00:40:52.020
Because if you wind up with these
layers and layers of overridden methods,

00:40:52.020 --> 00:40:54.790
a lot of times you've got to go
into the middle or sometimes even

00:40:54.870 --> 00:40:58.120
to the root of the inheritance
hierarchy and make a change in

00:40:58.440 --> 00:41:00.140
software that's being overridden.

00:41:00.200 --> 00:41:03.020
And now you have to think
about are people just doing

00:41:03.020 --> 00:41:04.590
straight up overrides on this?

00:41:04.710 --> 00:41:07.330
Are they supposed to be
calling super in their,

00:41:07.330 --> 00:41:09.000
you know, in their overridden methods?

00:41:09.090 --> 00:41:15.220
How does -- if they are calling super,
what does my change do for that

00:41:15.220 --> 00:41:16.780
code in the overridden method?

00:41:16.780 --> 00:41:20.310
If they're not calling super,
how do they maybe wind up getting

00:41:20.310 --> 00:41:23.540
this bug fixer feature that I just
put up in the overridden -- in the,

00:41:23.540 --> 00:41:26.300
you know, in the method way up at
the top of the hierarchy?

00:41:26.300 --> 00:41:26.820
Right?

00:41:26.820 --> 00:41:28.400
So this is complicated.

00:41:28.420 --> 00:41:31.650
It complicates change,
having a deep inheritance hierarchy.

00:41:31.660 --> 00:41:32.620
Right?

00:41:32.620 --> 00:41:38.900
And so the solution or a solution to
this is where possible to use delegation,

00:41:38.900 --> 00:41:43.100
design your classes so that
they have delegates when -- in

00:41:43.440 --> 00:41:45.990
the points of the code where
interesting work is getting done.

00:41:47.600 --> 00:41:49.200
So what is delegations?

00:41:49.200 --> 00:41:51.270
It's customizing by
calling another object.

00:41:51.270 --> 00:41:56.220
You define what kind of the interesting
things that you might want another

00:41:56.220 --> 00:41:59.950
object to have a role in delivering,
and you have that other

00:42:00.020 --> 00:42:01.580
object do that work.

00:42:01.580 --> 00:42:04.800
And it keeps the
conceptual overhead small,

00:42:04.800 --> 00:42:08.540
because you decide up front,
this is the kind of interesting

00:42:08.630 --> 00:42:11.530
work that this class does,
which might be customized

00:42:11.630 --> 00:42:12.740
by another class.

00:42:12.880 --> 00:42:17.070
So instead of adding to
the inheritance hierarchy,

00:42:17.070 --> 00:42:19.790
you add additional delegates.

00:42:21.220 --> 00:42:24.830
And the great thing about this is
that you can vary that customization

00:42:24.930 --> 00:42:26.720
at runtime as you need it.

00:42:26.800 --> 00:42:29.950
You can make a class behave
in two different ways simply

00:42:30.080 --> 00:42:31.900
by changing the delegate.

00:42:31.930 --> 00:42:33.910
I mean,
I think a great example of that is just

00:42:34.030 --> 00:42:38.540
going and removing a delegate that winds
up responding to maybe button presses.

00:42:38.540 --> 00:42:41.930
If you just remove the delegate and
replace it with nil implementations,

00:42:41.930 --> 00:42:43.440
the button will be disabled.

00:42:43.930 --> 00:42:47.840
You update its user interface,
it's nice and easy to sort of enable

00:42:47.840 --> 00:42:52.300
and disable user interface controls
by varying the delegate at runtime.

00:42:53.940 --> 00:42:56.990
Object becomes active again,
reassign the delegate that does the work,

00:42:57.160 --> 00:42:59.140
and you're good to go.

00:43:02.300 --> 00:43:11.800
[Transcript missing]

00:43:12.260 --> 00:43:16.140
Because it helps you to limit includes.

00:43:16.200 --> 00:43:20.930
If you limit includes in your software,
you get a bonus of faster compile times,

00:43:21.040 --> 00:43:24.960
particularly if you have
a bunch of C++ code.

00:43:25.060 --> 00:43:28.470
Compiler takes a longer amount
of time to compile C++ than

00:43:28.470 --> 00:43:31.570
straight C or Objective-C,
so you get faster compile times,

00:43:31.580 --> 00:43:32.400
which is great.

00:43:32.560 --> 00:43:39.780
More turns of the edit, compile,
debug cycle in your brain.

00:43:40.290 --> 00:43:42.810
But more than that,
I try to strive for unidirectional

00:43:43.010 --> 00:43:47.520
calling when I design two classes
that need to interact with each other.

00:43:47.560 --> 00:43:48.810
And so here's an example.

00:43:48.990 --> 00:43:52.580
I have two classes,
a foo class and a bar class,

00:43:52.580 --> 00:43:56.130
and you can see they message each other.

00:43:56.940 --> 00:43:59.400
So now if you go and
look at the Foo example,

00:43:59.400 --> 00:44:02.230
I'm going to go and change an interface.

00:44:03.150 --> 00:44:06.240
Now, of course,
since Barr calls that method,

00:44:06.320 --> 00:44:09.580
I need to go and update all the callers,
right?

00:44:09.580 --> 00:44:12.820
So this is potentially complicated,
particularly in a big framework.

00:44:12.900 --> 00:44:18.810
If you need to change an interface, well,
now you need to go and

00:44:18.810 --> 00:44:23.290
change all the callers,
and you need to make sure

00:44:23.290 --> 00:44:24.210
that you've got everybody,
even independent frameworks that

00:44:24.210 --> 00:44:24.210
maybe you don't develop every day.

00:44:25.060 --> 00:44:28.710
Right, so I think a different way is if
you can rethink the relationship

00:44:28.710 --> 00:44:30.960
between these two classes.

00:44:31.020 --> 00:44:34.000
Instead of just foo and bar,
two classes which are friends,

00:44:34.000 --> 00:44:37.280
if you have master and slave instead.

00:44:37.600 --> 00:44:41.460
So not only is the name more descriptive,
right, but the relationship between

00:44:41.460 --> 00:44:44.480
the code is sort of clear and
is communicated in the names.

00:44:44.580 --> 00:44:49.120
Now, what this means, of course,
is that now if I go and change

00:44:49.120 --> 00:44:53.320
that gold interface in master,
if I decide to decompose that,

00:44:53.320 --> 00:44:56.250
refactor that,
so it's not just change now,

00:44:56.250 --> 00:45:00.570
I've now broken it up into a data
receive and a data process step,

00:45:00.640 --> 00:45:02.740
I don't need to go and change the slave.

00:45:02.780 --> 00:45:03.700
It doesn't matter.

00:45:03.730 --> 00:45:06.930
I'm free to change that master
without having to worry about the

00:45:07.050 --> 00:45:08.640
collateral damage in the slaves.

00:45:08.640 --> 00:45:10.670
The slave doesn't depend on the master.

00:45:12.700 --> 00:45:17.600
I always try to strive for unidirectional
calling between two classes if I can.

00:45:17.670 --> 00:45:22.080
Keep those call graphs shallow, small.

00:45:22.080 --> 00:45:28.120
Next, mixing.

00:45:31.030 --> 00:45:34.900
So, Model-View-Controller,
I think it's a really neat concept.

00:45:34.900 --> 00:45:38.490
It keeps separate things separate,
the data in your program,

00:45:38.500 --> 00:45:42.990
the visual representation of the program,
and the way to mediate between them.

00:45:44.000 --> 00:45:46.640
It's a good design because
you don't mix these model and

00:45:46.640 --> 00:45:48.330
view changes in the same code.

00:45:48.390 --> 00:45:51.240
Helps to keep your code easier to change.

00:45:51.510 --> 00:45:56.390
Same model can have then later on
two different visual representations.

00:45:56.440 --> 00:46:01.850
Makes great sense if you're
doing iOS development,

00:46:01.850 --> 00:46:06.830
you have the same model,
different view system on

00:46:06.830 --> 00:46:07.350
the iPhone and iPod Touch,
and then a different one on the iPad.

00:46:08.300 --> 00:46:10.260
So that's, I think, a pretty good idea.

00:46:10.260 --> 00:46:14.530
Even more generally,
I say you shouldn't mix different

00:46:14.770 --> 00:46:16.760
things in your software.

00:46:16.760 --> 00:46:18.230
Don't mix different things.

00:46:18.240 --> 00:46:21.680
Like, for instance, computation and I.O.

00:46:21.680 --> 00:46:23.670
If you're receiving data
from over the network,

00:46:23.790 --> 00:46:28.180
don't do any important,
interesting work on it at the

00:46:28.340 --> 00:46:30.040
place where you received the data.

00:46:30.040 --> 00:46:31.560
Do that elsewhere.

00:46:31.560 --> 00:46:33.840
Don't mix your algorithms
and data sources,

00:46:33.840 --> 00:46:36.640
which is sort of another way
of saying the same thing.

00:46:37.960 --> 00:46:41.540
UI in a specific screen resolution.

00:46:41.830 --> 00:46:44.860
Because again, we wind up changing
the screen resolution.

00:46:44.870 --> 00:46:48.650
Or in the case of iPhone developers,
along came the iPad.

00:46:48.740 --> 00:46:50.190
Because we wind up changing.

00:46:50.240 --> 00:46:53.170
New hardware, new products.

00:46:53.480 --> 00:46:55.330
So don't just hard-code in.

00:46:55.340 --> 00:46:59.190
Don't bake in the notion of
a specific screen resolution.

00:46:59.360 --> 00:47:03.080
Or your user interaction in a
particular interface pattern.

00:47:03.200 --> 00:47:05.860
What's very common, of course,
in the iPhone is to have apps

00:47:05.890 --> 00:47:08.840
which show data's in screenfuls.

00:47:08.920 --> 00:47:11.340
And we've got this
side-to-side navigation.

00:47:11.340 --> 00:47:12.580
Along comes the iPad.

00:47:12.580 --> 00:47:16.440
And a lot of that same functionality
is then implemented in popovers.

00:47:16.470 --> 00:47:19.980
So don't bake in that
side-to-side notion.

00:47:20.050 --> 00:47:26.790
Because it complicates change
when the world changes around you.

00:47:28.940 --> 00:47:32.130
I'm conflicted about
lines of code like this:

00:47:32.320 --> 00:47:35.820
set editing which seems
sort of model-ish,

00:47:35.820 --> 00:47:40.140
and animations which
seem somewhat view-ish.

00:47:40.200 --> 00:47:43.890
I think this is maybe
mixing a little too much.

00:47:43.990 --> 00:47:48.900
Should you really hard code
animations in your code?

00:47:48.900 --> 00:47:51.090
So I've got a story about
multitasking gestures,

00:47:51.180 --> 00:47:52.400
the new feature for iOS 5.

00:47:52.400 --> 00:47:54.510
I don't know if you've
tried them out yet,

00:47:54.640 --> 00:47:58.580
the sort of swipe side to
side to switch between apps,

00:47:58.580 --> 00:48:03.120
and sort of the hand-closing gesture to
go back to the home screen from an app.

00:48:03.220 --> 00:48:07.740
Well, I did a lot of the work
for multitasking gestures.

00:48:08.730 --> 00:48:11.030
And of course,
this is a big change to how the

00:48:11.030 --> 00:48:16.380
system works that we came up with
in version 5 of the software.

00:48:16.430 --> 00:48:20.930
And it turns out that in SpringBoard,
getting an app to launch sort of

00:48:20.930 --> 00:48:24.600
behind the scenes as you swipe
side to side without that launch

00:48:24.600 --> 00:48:29.150
animation was really hard to do
because we baked in the notion of,

00:48:29.150 --> 00:48:31.860
oh, well, on iOS,
and when an app launches,

00:48:31.910 --> 00:48:34.280
it does this animation up from the icon.

00:48:34.280 --> 00:48:35.540
That's just how it works.

00:48:35.540 --> 00:48:37.080
But we change how the system works.

00:48:37.080 --> 00:48:41.300
So this is a case where we baked
in this notion of animation,

00:48:41.300 --> 00:48:46.590
and it turned out to be pretty
difficult to go and disentangle that

00:48:46.590 --> 00:48:49.200
to make the system work differently.

00:48:49.240 --> 00:48:52.180
So that's a lesson in
change management for us,

00:48:52.180 --> 00:48:52.910
for sure.

00:48:53.210 --> 00:48:54.580
So don't mix different things.

00:48:54.710 --> 00:48:58.510
App launching and animations
are two different things.

00:48:58.520 --> 00:49:03.760
Don't mix different things.

00:49:05.220 --> 00:49:08.100
And that's mixing.

00:49:08.300 --> 00:49:12.430
Next, expectations,
or how do I work this thing?

00:49:12.950 --> 00:49:14.580
I think bugs are disappointments.

00:49:14.580 --> 00:49:19.450
Maybe that's something that would
be better discussed with my analyst,

00:49:19.470 --> 00:49:23.190
but I'm also often disappointed
with bugs in the software.

00:49:23.510 --> 00:49:27.730
It's like I expected A and you did B,
and I'm all sad now.

00:49:27.730 --> 00:49:30.500
I have to figure out why.

00:49:30.580 --> 00:49:35.350
Of course,
this is now a good general rule of thumb,

00:49:35.420 --> 00:49:38.080
Postal's Law,
be conservative in what you send,

00:49:38.080 --> 00:49:40.040
be liberal in what you accept.

00:49:40.230 --> 00:49:46.420
I think that applies to app development
and not just network programming.

00:49:46.420 --> 00:49:49.570
Right,
and this idea of hard to use wrong,

00:49:49.570 --> 00:49:53.850
if I'm going to develop an interface,
a code interface that all

00:49:53.850 --> 00:49:56.860
of you are going to use,
I would like to think that it's

00:49:56.860 --> 00:49:59.680
difficult to use that interface wrong.

00:49:59.780 --> 00:50:01.470
It's hard to use wrong.

00:50:01.580 --> 00:50:04.700
And so I've got a couple of
ideas about how to make code

00:50:04.700 --> 00:50:06.480
that's hard to use wrong.

00:50:06.480 --> 00:50:08.960
One is method arguments,
and the other is assertions

00:50:08.960 --> 00:50:11.410
and early returns.

00:50:11.580 --> 00:50:16.560
Well, if we look at assertions,
we look at this method argument here,

00:50:16.560 --> 00:50:19.280
and I put it together with an assertion.

00:50:19.320 --> 00:50:22.060
So I say, if you call this method, well,
it's wrong.

00:50:22.060 --> 00:50:24.440
It's simply wrong to call this method.

00:50:24.450 --> 00:50:29.610
I've decided, as the interface provider,
that it's an error to call

00:50:29.630 --> 00:50:31.960
this method without a view.

00:50:31.960 --> 00:50:33.760
The software will break.

00:50:33.840 --> 00:50:39.590
So if you're using the assertions
that we provide as part of foundation,

00:50:39.590 --> 00:50:45.100
your software will go into the
debugger while you're debugging it,

00:50:45.110 --> 00:50:45.670
which is good.

00:50:45.740 --> 00:50:49.370
You'll fix that bug before
you ship to customers.

00:50:49.410 --> 00:50:51.080
So assertions are great.

00:50:51.150 --> 00:50:53.450
Put them in your software.

00:50:56.100 --> 00:52:41.300
[Transcript missing]

00:52:42.230 --> 00:52:44.680
Now, what about IVARs?

00:52:44.850 --> 00:52:47.000
IVARs bring up an interesting point, too.

00:52:47.000 --> 00:52:52.690
And I think we'll all accept
that global variables are bad.

00:52:52.810 --> 00:52:53.690
And why are they bad?

00:52:53.830 --> 00:52:56.320
Because the scope is too broad.

00:52:56.320 --> 00:53:01.480
A change to that global variable can
affect all of the code in your program.

00:53:01.480 --> 00:53:04.840
But I think that IVAR scope
can also be too broad,

00:53:04.840 --> 00:53:07.150
particularly in a large class.

00:53:07.150 --> 00:53:10.350
If you have a big class,
one of those singleton

00:53:10.350 --> 00:53:11.980
controller objects,

00:53:12.270 --> 00:53:14.660
An IVAR can be really,
really difficult to manage,

00:53:14.660 --> 00:53:17.500
and you may need to understand a
lot about that IVAR in order to

00:53:17.500 --> 00:53:20.880
make sure that you understand how
the software is supposed to work.

00:53:20.990 --> 00:53:23.580
So I've got some rules
of thumb for IVARs.

00:53:23.710 --> 00:53:26.660
Generally speaking,
have as few of them as possible.

00:53:27.500 --> 00:53:32.390
Try to design your code so that you're
not just squirreling away little bits of

00:53:32.390 --> 00:53:35.010
state in the scope of the whole class.

00:53:35.590 --> 00:53:39.840
I try to have simple life cycles,
getters and setters.

00:53:39.880 --> 00:53:44.230
Don't have complicated life
cycle transitions for IVARs,

00:53:44.240 --> 00:53:45.480
if possible.

00:53:45.680 --> 00:53:49.250
And avoid tight relationships
between multiple IVARs.

00:53:49.390 --> 00:53:54.860
Don't have IVAR at the state of
IVAR A depend on the state of IVAR B,

00:53:54.860 --> 00:53:56.680
where possible.

00:53:56.980 --> 00:54:01.050
Right, and avoid letting non-setter
methods change IVARs.

00:54:01.120 --> 00:54:03.480
I mean,
this is tempting a lot of times because,

00:54:03.590 --> 00:54:05.900
you know, you may want a function that
computes the value of an IVAR,

00:54:05.900 --> 00:54:08.770
but since a C function
can only return one value,

00:54:09.030 --> 00:54:13.630
you might be tempted to have a sort of
an update state method which goes and

00:54:13.630 --> 00:54:18.660
changes a bunch of different IVARs,
and that can be difficult to understand,

00:54:18.690 --> 00:54:22.400
particularly later if you're
trying to change that code or

00:54:22.450 --> 00:54:26.210
if you're trying to learn it,
what that method actually does.

00:54:27.410 --> 00:54:34.300
So, if you've got hard-to-manage
IVAR state already in your code,

00:54:34.360 --> 00:54:36.220
and maybe you're going
to try to refactor,

00:54:36.220 --> 00:54:39.780
using a state machine
might be a good idea.

00:54:39.780 --> 00:54:42.590
This is even a good idea if you're
going to design a class from scratch.

00:54:42.590 --> 00:54:44.550
Use a state machine.

00:54:44.560 --> 00:54:48.170
UI Gesture Recognizers in
UIKit implements a state machine

00:54:48.230 --> 00:54:50.440
to implement its functionality.

00:54:50.440 --> 00:54:52.560
Of course,
that's expressed to you in the API,

00:54:52.560 --> 00:54:53.960
how you wind up getting your callbacks.

00:54:54.100 --> 00:54:57.520
You wind up asking the
gesture what state it's in:

00:54:57.660 --> 00:55:02.180
possible, or record that changed,
or canceled, or ended.

00:55:02.290 --> 00:55:04.510
And it was such a good idea that
that's how I implemented--there's

00:55:04.510 --> 00:55:06.240
no API for this,
but this is how I implemented

00:55:06.290 --> 00:55:09.940
multitasking gestures in Springboard,
using a state machine.

00:55:10.110 --> 00:55:11.820
All right, so state machines,
how do they help?

00:55:11.900 --> 00:55:14.530
Well,
they help you to think things through.

00:55:15.070 --> 00:55:17.590
And they help you to limit possibilities.

00:55:17.710 --> 00:55:20.640
If you've only got a
specific number of states,

00:55:20.790 --> 00:55:21.760
there is no in-between.

00:55:21.760 --> 00:55:23.340
You can't read in-between the lines.

00:55:23.500 --> 00:55:28.000
You've got to transition
between one state to another.

00:55:28.000 --> 00:55:31.230
And states also help
you to make assertions.

00:55:31.230 --> 00:55:35.010
Some of those assertions you
might add to your code is,

00:55:35.010 --> 00:55:40.040
well, this function can only be called
if the class is in a certain state.

00:55:40.040 --> 00:55:41.230
If not, I'm asserting.

00:55:41.230 --> 00:55:41.230
It's wrong to call in the wrong state.

00:55:43.030 --> 00:55:45.040
And later, right,
because this is all about change, right,

00:55:45.040 --> 00:55:47.530
so you implement the state machine
and then later you realize it

00:55:47.530 --> 00:55:49.150
doesn't do everything that you want.

00:55:49.270 --> 00:55:50.770
You need to add a feature.

00:55:51.090 --> 00:55:54.390
Well,
you've just made your life easier because

00:55:54.390 --> 00:55:58.400
all you do then is you add a state and
you then you think through what are all

00:55:58.400 --> 00:56:02.400
the transitions between all the existing
states and the new state that I'm adding.

00:56:02.420 --> 00:56:03.280
What makes sense?

00:56:03.350 --> 00:56:05.710
Can you get there from here?

00:56:06.750 --> 00:56:11.300
So state machines help you to
manage change and make your

00:56:11.630 --> 00:56:16.480
code harder to use wrong,
even in internal implementation.

00:56:19.630 --> 00:56:24.910
So, wrapping up,
10 things to think about.

00:56:25.110 --> 00:56:26.390
Clear code.

00:56:26.860 --> 00:56:30.000
Your bug fixes should tell a story.

00:56:30.000 --> 00:56:33.400
Lazy initialization:
Keep control of that where possible.

00:56:33.400 --> 00:56:34.100
It's good.

00:56:34.100 --> 00:56:37.990
You want quick-launching programs,
but it's not magical.

00:56:37.990 --> 00:56:40.000
Refactor instead of rewriting.

00:56:40.160 --> 00:56:42.550
Don't overuse notifications.

00:56:42.560 --> 00:56:45.090
Use them for the right things.

00:56:46.630 --> 00:56:49.220
Keep your newest code easy to change.

00:56:49.220 --> 00:56:54.140
Optimize your slowest and oldest code.

00:56:54.590 --> 00:56:55.380
Limit dependencies.

00:56:55.380 --> 00:56:57.920
It's not about just like not working
and playing well with others,

00:56:58.000 --> 00:56:58.410
right?

00:56:58.530 --> 00:57:01.330
Just trying to keep your
code easy to change.

00:57:01.480 --> 00:57:06.340
Don't mix different things and
make code that's hard to use wrong.

00:57:06.340 --> 00:57:10.480
So, 10 things to think about,
and I hope those will help.

00:57:10.520 --> 00:57:14.020
And thank you for coming.
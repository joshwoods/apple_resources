WEBVTT

00:00:09.760 --> 00:00:10.240
Hi, everybody.

00:00:10.240 --> 00:00:13.780
Hopefully,
you're having a good time so far.

00:00:13.780 --> 00:00:14.580
I'm Jim Batson.

00:00:14.580 --> 00:00:18.400
And for those of you watching at home,
I'm the one with the full head of hair.

00:00:21.200 --> 00:00:22.480
OK.

00:00:22.510 --> 00:00:26.860
Today we're going to be talking to you
about AirPlay and external displays.

00:00:26.930 --> 00:00:29.780
And first thing we're going to
cover is how to create a great

00:00:29.820 --> 00:00:32.520
AirPlay experience for your application.

00:00:32.530 --> 00:00:34.760
And then we're going to be covering

00:00:35.370 --> 00:00:39.380
Some specific things about video
because there are some nuances there.

00:00:39.450 --> 00:00:41.140
And finally,
we'll be talking about taking

00:00:41.140 --> 00:00:43.950
advantage of multiple displays so
that you can create an immersive

00:00:43.950 --> 00:00:47.160
environment for your application.

00:00:47.640 --> 00:00:50.400
So starting with AirPlay.

00:00:51.460 --> 00:00:54.270
We released AirPlay for iOS last fall.

00:00:54.570 --> 00:00:56.920
And since then,
we've been working a whole lot,

00:00:56.980 --> 00:00:58.980
been adding a whole bunch of stuff.

00:00:59.030 --> 00:01:03.950
Now, AirPlay is a family of technologies
and user experiences that basically

00:01:04.020 --> 00:01:06.360
have one big goal in mind.

00:01:06.410 --> 00:01:09.760
That's the ability to
share the experience

00:01:11.100 --> 00:01:21.400
[Transcript missing]

00:01:22.070 --> 00:01:25.620
With AirPlay Audio,
you have the ability to share your

00:01:25.620 --> 00:01:33.000
audio stream from your phone or iPad
or iPod Touch straight to an Apple TV.

00:01:34.370 --> 00:01:39.100
Now, if you-- and this works for
all audio on your system.

00:01:39.170 --> 00:01:43.770
But if you are an
application that has music,

00:01:43.910 --> 00:01:47.950
You can make your app really shine by
sending additional information that will

00:01:47.960 --> 00:01:51.400
be displayed on the AirPlay receiver.

00:01:51.460 --> 00:01:54.990
Now,
AirPlay audio is not just for Apple TV.

00:01:55.640 --> 00:02:00.030
There's a whole host of devices that are
coming out from third-party companies

00:02:00.710 --> 00:02:04.120
that have AirPlay compatible devices,
AirPlay compatible receivers,

00:02:04.230 --> 00:02:06.820
and dockable speakers
and other accessories.

00:02:06.910 --> 00:02:10.030
So there's going to be more and more
places your AirPlay audio can play.

00:02:10.040 --> 00:02:13.580
Now on to video.

00:02:15.330 --> 00:02:20.020
With AirPlay Video,
the video content itself is

00:02:20.020 --> 00:02:23.190
streamed directly to the Apple TV.

00:02:23.910 --> 00:02:26.400
So that means there's no
degradation in quality and you

00:02:26.400 --> 00:02:28.190
get the best viewing experience.

00:02:28.190 --> 00:02:30.580
And you get to take advantage
of the whole screen.

00:02:33.760 --> 00:02:37.550
But one of the great features
of AirPlay Video is that while

00:02:37.550 --> 00:02:39.550
you're watching the video,

00:02:39.900 --> 00:02:41.420
You can also do multitasking.

00:02:41.590 --> 00:02:45.170
And so you can do other things while
people in the room are watching.

00:02:45.170 --> 00:02:48.650
So they're checking out your gnarly
moves and you still can surf the web

00:02:48.750 --> 00:02:51.980
and buy stuff for your dad because,
you know, it's Father's Day and

00:02:52.140 --> 00:02:53.700
less than two weeks away.

00:02:56.340 --> 00:03:00.520
Now, before we go to AirPlay Screen and
AirPlay Mirroring,

00:03:00.540 --> 00:03:03.620
let's talk a little bit about the iPad 2.

00:03:03.680 --> 00:03:06.010
When the iPad 2 was released,
we introduced a feature

00:03:06.140 --> 00:03:08.130
called Mirroring for that.

00:03:08.810 --> 00:03:12.880
And that's accomplished by plugging
in the Apple Digital AV adapter

00:03:13.250 --> 00:03:17.460
into your iPad and hooking it
up to a TV that supports HDMI.

00:03:18.150 --> 00:03:23.430
When you do that plug-in, the screen will
automatically be mirrored.

00:03:24.710 --> 00:03:31.060
And with iOS 5, with AirPlay mirroring,
you've got the same capability

00:03:31.120 --> 00:03:32.910
but without the wire.

00:03:33.560 --> 00:03:39.450
So the live audio and the live graphics
are sent to an Apple TV wirelessly,

00:03:39.450 --> 00:03:42.520
and you get the same behavior
as you did with a cable,

00:03:42.560 --> 00:03:45.410
namely that when you first connect,
you're mirrored.

00:03:45.410 --> 00:03:48.670
And this works great for collaboration.

00:03:48.750 --> 00:03:53.700
You can imagine working on slides with
some other people on the big screen while

00:03:53.700 --> 00:03:56.310
you're manipulating them on the pad.

00:03:57.270 --> 00:04:03.530
But since it's based on the same
technology as the cable case,

00:04:03.640 --> 00:04:06.370
you've got the support
for second display.

00:04:07.300 --> 00:04:09.730
Which really works great
for things like Keynote,

00:04:09.780 --> 00:04:15.710
where it has its independent content,
something different from the iPad screen.

00:04:16.180 --> 00:04:18.640
But it's not just great
for presentations.

00:04:18.720 --> 00:04:22.340
It's also great for things like
games and other applications.

00:04:22.420 --> 00:04:27.630
You've got the opportunity here to
create applications that go beyond

00:04:27.660 --> 00:04:29.340
just using it on a single display.

00:04:29.590 --> 00:04:35.430
So you have opportunities to kind
of create a new user experience.

00:04:35.510 --> 00:04:37.410
So you should look into that.

00:04:39.120 --> 00:04:45.140
So how do you as a developer
take advantage of AirPlay?

00:04:45.180 --> 00:04:49.170
Well, there is no AirPlay framework.

00:04:50.310 --> 00:04:53.370
AirPlay is implemented
throughout the system,

00:04:53.370 --> 00:04:58.260
integrated in all the frameworks and
technologies you're already using.

00:05:00.200 --> 00:05:05.100
So let's go take a closer
look at what you might do.

00:05:05.100 --> 00:05:10.700
We're going to take a look at
increasing the AirPlay experience.

00:05:10.700 --> 00:05:13.790
We're going to cover a little
bit about media routing.

00:05:14.730 --> 00:05:17.860
about the AirPlay UI.

00:05:17.930 --> 00:05:21.090
Showing extra information for the user.

00:05:22.200 --> 00:05:25.690
Accepting remote controls from
the AirPlay device and adding

00:05:25.690 --> 00:05:28.440
multitasking to your apps.

00:05:28.590 --> 00:05:30.610
Let's start with media routing.

00:05:32.200 --> 00:05:36.410
Now, media routing on the system
solves the basic problem that

00:05:36.410 --> 00:05:40.690
when you're playing media,
you want the audio and the video

00:05:40.700 --> 00:05:42.850
to go where the user wants.

00:05:44.180 --> 00:05:46.840
Now, with physical devices,
that's pretty easy.

00:05:46.900 --> 00:05:49.410
When you plug in some headphones,

00:05:54.690 --> 00:05:56.940
It's a physical gesture.

00:05:57.070 --> 00:06:00.670
So you know the user wants the
audio to go to the headphones.

00:06:01.880 --> 00:06:04.850
When they plug in an HDMI adapter,
they want the audio and

00:06:04.900 --> 00:06:08.260
video to go out through the
HDMI adapter to the television.

00:06:09.000 --> 00:06:12.700
But what if there's a TV available,
an Apple TV?

00:06:12.780 --> 00:06:15.570
There's no physical
connection that can be made.

00:06:15.690 --> 00:06:20.350
So instead,
the user finds the AirPlay route picker,

00:06:20.930 --> 00:06:23.740
uses it and selects the
Apple TV as a destination,

00:06:23.740 --> 00:06:26.710
and then the audio and video
will go to the Apple TV now.

00:06:28.510 --> 00:06:30.800
So while we're on the
topic of media routing,

00:06:30.990 --> 00:06:33.710
let's talk about audio routing behaviors.

00:06:34.800 --> 00:06:39.740
Now, when your application makes
sounds and plays audio,

00:06:39.810 --> 00:06:44.460
typically the audio you make is
about your application experience.

00:06:44.470 --> 00:06:48.450
There's ambient sounds or media playback.

00:06:49.310 --> 00:06:53.840
But there's another class of sounds
which are about direct user feedback,

00:06:53.890 --> 00:06:56.740
things like key clicks or alerts.

00:06:56.960 --> 00:07:01.510
Now, with iOS 5,
when you're using AirPlay,

00:07:01.510 --> 00:07:07.110
the application audio is
going to go to the Apple TV.

00:07:08.600 --> 00:07:13.540
But the system sounds are now
going to come from the device.

00:07:13.620 --> 00:07:14.900
So that's where the user is touching.

00:07:14.900 --> 00:07:17.300
That's where you want
key clicks to happen.

00:07:17.450 --> 00:07:20.460
So it's really important to
use system sound APIs for

00:07:20.460 --> 00:07:22.370
playing system sounds only.

00:07:22.370 --> 00:07:26.810
You don't want your audio that's
intended to go with your content to

00:07:26.810 --> 00:07:31.410
be playing locally when it should
be playing on the remote device.

00:07:31.900 --> 00:07:35.050
So some of you have been using system
sound APIs because they're easy to use

00:07:35.050 --> 00:07:37.600
and they're convenient for these small,
short sounds.

00:07:37.620 --> 00:07:41.620
There's a lot of choices,
but let me just point you to one of them,

00:07:41.620 --> 00:07:42.920
AV Audio Player.

00:07:42.920 --> 00:07:46.010
With AV Audio Player, it's pretty simple.

00:07:46.020 --> 00:07:49.920
You just create an
AV Audio Player using a file

00:07:49.920 --> 00:07:53.330
URL pointing to your audio content.

00:07:53.330 --> 00:07:56.570
And then with a few controls,
a few playback commands,

00:07:56.660 --> 00:07:59.110
you can play that sound inside your app.

00:07:59.190 --> 00:08:00.770
So check that out.

00:08:01.800 --> 00:08:03.790
Now I'm back to the route picker.

00:08:03.800 --> 00:08:07.380
I'm going to talk a little details
about how the user interacts.

00:08:08.540 --> 00:08:12.530
So there's the system AirPlay Picker,
which is available through the

00:08:12.530 --> 00:08:13.950
multitasking user interface.

00:08:14.170 --> 00:08:15.560
It's always available.

00:08:15.630 --> 00:08:18.190
The user just double
taps the menu button,

00:08:18.270 --> 00:08:21.900
swipes right,
and reveals these media controls.

00:08:21.960 --> 00:08:26.060
Now, if there's an AirPlay compatible
device available,

00:08:26.540 --> 00:08:29.040
You get an AirPlay button
that will appear.

00:08:29.040 --> 00:08:32.380
And then when the user clicks on that,
they get a list.

00:08:34.270 --> 00:08:36.440
And they can choose the Apple TV.

00:08:36.510 --> 00:08:39.460
Now,
if the Apple TV is the destination device

00:08:39.950 --> 00:08:43.950
and if the Apple TV is running iOS 5,
mirroring is an option.

00:08:43.950 --> 00:08:47.000
So that'll appear and
they can just slide that.

00:08:47.000 --> 00:08:50.510
You saw that yesterday to
invoke AirPlay mirroring.

00:08:52.020 --> 00:08:57.660
So keep in mind that the system route
AirPlay Picker is always available.

00:08:57.670 --> 00:09:00.990
Even though your app's in the front most,
the user can always get

00:09:00.990 --> 00:09:03.860
there and change the route.

00:09:03.920 --> 00:09:05.720
Just be aware of that.

00:09:06.440 --> 00:09:08.800
Now, for media-based applications,
it's really convenient

00:09:08.800 --> 00:09:12.840
to have an AirPlay picker
inside your application UI.

00:09:12.840 --> 00:09:15.710
You don't want the user to have
to change their focus from your

00:09:15.810 --> 00:09:19.090
application to direct the content
to wherever they want to play.

00:09:22.220 --> 00:09:25.180
So how do you go about adding
an AirPlay picker to your UI?

00:09:25.230 --> 00:09:25.850
It's really easy.

00:09:25.860 --> 00:09:28.300
Just use MPVolumeView.

00:09:28.440 --> 00:09:33.040
You just create a volume view and just
add it as a subview to one of your views.

00:09:33.060 --> 00:09:34.240
Then you can place it around.

00:09:34.370 --> 00:09:37.370
So the default is that you get the volume
slider as well as the route picker.

00:09:37.370 --> 00:09:41.000
But if you want the picker only,
it's really easy.

00:09:41.000 --> 00:09:44.270
You just set show as volume slider to no.

00:09:44.460 --> 00:09:47.320
And then you just get the picker element.

00:09:47.350 --> 00:09:50.410
Now keep in mind,
if there's no device available,

00:09:50.470 --> 00:09:51.600
the picker is not visible.

00:09:51.600 --> 00:09:55.040
But now you've got the ability to place
that wherever you want in your UI.

00:09:57.870 --> 00:10:04.200
So once you're routing media content
from the device to the AirPlay receiver,

00:10:04.250 --> 00:10:08.480
you want to enhance that
experience on that receiver.

00:10:08.840 --> 00:10:12.650
And you can do that because if you
don't do any extra coding yourself,

00:10:12.650 --> 00:10:14.650
there's nothing we can do.

00:10:14.650 --> 00:10:17.400
There's just no information
for us to display there.

00:10:19.830 --> 00:10:23.040
But with iOS 5,
you as an application have the

00:10:23.080 --> 00:10:28.720
ability to send metadata over that
will be displayed on the Apple TV.

00:10:30.870 --> 00:10:34.290
So you use MPNow Playing Info Center,
and it's part of the

00:10:34.490 --> 00:10:36.240
Media Player Framework.

00:10:36.250 --> 00:10:40.780
And it works with any playback framework
you're using to play your content.

00:10:43.840 --> 00:10:45.380
And it's really simple to use.

00:10:45.380 --> 00:10:49.210
You just call setNowPlayingInfo with
a dictionary of the metadata that

00:10:49.210 --> 00:10:50.860
you want associated with a song.

00:10:52.810 --> 00:10:54.100
What kind of metadata?

00:10:54.210 --> 00:10:57.740
Well, besides the standard
strings of like song name,

00:10:57.850 --> 00:11:02.270
artist, album title, things like that,
you have the ability

00:11:02.280 --> 00:11:04.470
to send artwork over.

00:11:06.190 --> 00:11:10.640
And that kind of really
enriches the experience.

00:11:10.690 --> 00:11:14.000
Now, besides the static information,
you can also have dynamic

00:11:15.270 --> 00:11:18.700
information that updates the
progress bar visible on the TV.

00:11:19.200 --> 00:11:22.540
You've got playback rate, duration,
and elapsed time.

00:11:22.560 --> 00:11:25.540
Now, it's important to give an
accurate playback rate.

00:11:25.590 --> 00:11:31.190
The reason is that the progress
bar is updated on the device.

00:11:31.380 --> 00:11:34.580
By interpolating those values so you
don't have to keep hitting it with,

00:11:34.600 --> 00:11:37.280
now is the elapsed time,
now is the elapsed time.

00:11:37.280 --> 00:11:40.700
So you don't want to do
that because that'll just

00:11:41.270 --> 00:11:43.710
unnecessarily send lots of data.

00:11:44.610 --> 00:11:47.600
Now that you've gotten extra
information going to the device

00:11:48.360 --> 00:11:54.100
being displayed on the Apple TV or
on an AirPlay compatible receiver,

00:11:54.150 --> 00:11:57.740
you want to be able to handle events
coming from the remote device.

00:11:58.310 --> 00:12:01.580
That allows your user to control
the media playback using the

00:12:01.580 --> 00:12:04.720
remote control from your Apple TV.

00:12:05.710 --> 00:12:07.790
And it's not just for Apple TV.

00:12:08.120 --> 00:12:12.570
These same APIs work with
a host of other devices.

00:12:19.900 --> 00:12:25.400
The example here is that the headphones--
you've got the remote control clicker--

00:12:25.880 --> 00:12:28.880
So if you support these APIs,
those will control the media

00:12:28.940 --> 00:12:31.240
playback as well as the lock screen.

00:12:31.280 --> 00:12:36.350
And then there's a host of accessories
that also support remote controls.

00:12:37.790 --> 00:12:40.050
So what do you need to do to
actually support remote controls?

00:12:40.270 --> 00:12:41.960
Well,
the first thing you have to do is the

00:12:41.960 --> 00:12:46.590
application has to ask to receive them,
these remote control events.

00:12:46.940 --> 00:12:50.170
First thing you do is you have
to become a first responder.

00:12:50.170 --> 00:12:52.600
And you do that by first overriding
the can become first responder

00:12:52.600 --> 00:12:53.750
method and returning yes.

00:12:53.870 --> 00:12:56.080
So the system knows you
can be in that situation.

00:12:56.100 --> 00:12:58.950
In your view, did the appear method,
you ask to begin receiving

00:12:58.950 --> 00:13:00.370
those remote control events.

00:13:00.380 --> 00:13:02.430
And then you become the first responder.

00:13:02.440 --> 00:13:05.600
Now this just makes you eligible to
receive these remote control events.

00:13:07.370 --> 00:13:09.550
The system will decide
when to send them to you.

00:13:09.790 --> 00:13:12.800
Typically,
that's when the user has pressed play

00:13:12.840 --> 00:13:15.810
inside your UI and media starts playing.

00:13:16.050 --> 00:13:18.400
Now, it's important to also
let the system know,

00:13:18.620 --> 00:13:20.170
don't send them to me anymore.

00:13:20.170 --> 00:13:23.810
So you do that by calling and
receiving remote control events

00:13:23.830 --> 00:13:25.780
and resign first responder.

00:13:25.780 --> 00:13:29.210
A very short example would be,
let's say I wrote a magazine

00:13:29.210 --> 00:13:32.850
application where I can play
incidental videos from my site,

00:13:32.850 --> 00:13:36.140
but when they're just reading
the magazine elsewhere,

00:13:36.140 --> 00:13:39.210
you'd like the user to be
able to listen to their music

00:13:39.220 --> 00:13:43.110
from their music application,
and you want them to control it.

00:13:43.160 --> 00:13:46.390
So it's important to have the
right context and only be getting

00:13:46.560 --> 00:13:49.940
these remote control events when
it's appropriate for your app.

00:13:50.640 --> 00:13:53.360
So once you start getting
these remote control events,

00:13:53.370 --> 00:13:54.940
what do you do with them?

00:13:54.960 --> 00:13:57.520
Well, when you get the events,
you look at the type and subtype.

00:13:57.550 --> 00:14:01.250
And there's a bunch of different
events that come to you,

00:14:01.350 --> 00:14:05.640
including toggle, play, pause,
next track, previous track.

00:14:05.700 --> 00:14:09.390
It's up to your application to
interpret those control events

00:14:09.460 --> 00:14:11.390
appropriately for your app.

00:14:13.140 --> 00:14:18.440
Now,
be careful and do something sensible.

00:14:18.510 --> 00:14:20.460
Since these are control
events for the user,

00:14:20.480 --> 00:14:22.600
you don't want them to be
confusing for your app.

00:14:22.600 --> 00:14:25.890
Otherwise, they're just going to think
your app behaves strangely.

00:14:27.130 --> 00:14:31.560
Now, once you've dealt with
controlling your media playback

00:14:31.560 --> 00:14:35.510
app from the remote events,
you want to add multitasking

00:14:35.700 --> 00:14:37.240
to round out the experience.

00:14:37.410 --> 00:14:41.780
Now, with iOS 4, you've been able to play
audio in the background.

00:14:41.870 --> 00:14:43.680
And of course,
playing audio in the background from

00:14:43.680 --> 00:14:46.640
your app works great with AirPlay Audio.

00:14:49.400 --> 00:14:51.800
With AirPlay Video,
you want to be able to play the video

00:14:51.800 --> 00:14:55.540
in the background and let the user
multitask and do something else as well.

00:14:55.690 --> 00:14:57.680
So what do you have to do?

00:14:58.020 --> 00:15:02.280
We do the same thing that you do
from playing audio in the background.

00:15:02.310 --> 00:15:06.530
You use Xcode, open your Info.plist.

00:15:07.650 --> 00:15:12.750
Add a required background
modes key and then add the app

00:15:12.750 --> 00:15:15.700
plays audio item to that key.

00:15:15.750 --> 00:15:18.820
That flags your app as
being able to do that.

00:15:19.530 --> 00:15:21.000
That's not quite the whole story.

00:15:21.050 --> 00:15:23.640
You need to also use AV Audio Session.

00:15:23.750 --> 00:15:26.080
AV Audio Session is a critical piece.

00:15:26.160 --> 00:15:31.490
AV Audio Session lets you tell the
system what kind of audio you're playing.

00:15:32.130 --> 00:15:37.180
And for the case of media playback,
you want to use the playback category.

00:15:37.360 --> 00:15:41.740
This gets all the right behaviors
for the audio in your application.

00:15:41.790 --> 00:15:45.400
Now, there's a whole host of things
you can do with IV Audio Session,

00:15:45.400 --> 00:15:49.560
and it's a good idea to really
understand all those intricate details.

00:15:49.690 --> 00:15:53.600
So I encourage you to check out
the Audio Session Management for

00:15:53.600 --> 00:15:55.280
iOS session tomorrow.

00:15:57.320 --> 00:16:01.430
So now that you've added
multitasking to your application,

00:16:01.430 --> 00:16:06.580
you've combined all these three to
kind of round out the whole experience.

00:16:06.640 --> 00:16:08.780
Now let's look at the lock screen.

00:16:09.840 --> 00:16:13.620
So first of all, your phone's locked and
your audio's still playing.

00:16:13.720 --> 00:16:17.470
That's because you've implemented
a background media playback.

00:16:18.020 --> 00:16:20.400
The lock screen also has
that great album art.

00:16:20.490 --> 00:16:23.090
That's because you use Now Playing Info.

00:16:23.090 --> 00:16:27.800
And the user can control playback
using either the remote on the headset

00:16:27.870 --> 00:16:30.180
or the controls in lock screen.

00:16:30.880 --> 00:16:32.910
So I encourage you, if you're playing any
kind of media playback,

00:16:33.000 --> 00:16:36.580
to support all these things together
and create a nice full rounded

00:16:37.090 --> 00:16:39.420
experience for your application.

00:16:39.440 --> 00:16:41.480
Next, we're going to talk about--

00:16:42.070 --> 00:16:45.500
Video and getting some more out
of the AirPlay video experience.

00:16:45.550 --> 00:16:53.190
We'll talk about some of the
different APIs available,

00:16:53.190 --> 00:16:53.190
determining when best
to use AirPlay video,

00:16:54.000 --> 00:16:58.070
Showing the user where the video
is playing and a few tips on

00:16:58.070 --> 00:17:02.790
providing the best full playback
experience for the screen.

00:17:03.560 --> 00:17:05.240
Now,
before we jump into which frameworks,

00:17:05.400 --> 00:17:09.770
let's take a quick sideline
about the kind of content.

00:17:13.130 --> 00:17:17.300
Media content, especially video content,
can come from many places.

00:17:17.320 --> 00:17:20.240
AirPlay video works
well with local content,

00:17:20.420 --> 00:17:24.010
content either from within your
app or from the asset library.

00:17:24.010 --> 00:17:28.650
But it's also used for internet content,
things like progressive download

00:17:28.710 --> 00:17:30.480
and HDTV live streaming.

00:17:30.480 --> 00:17:33.170
Now,
HDTV live streaming is used for video

00:17:33.530 --> 00:17:36.070
on demand as well as live events.

00:17:36.900 --> 00:17:43.400
And with iOS 5, encrypted streams work
with AirPlay Video.

00:17:43.560 --> 00:17:46.200
They work with AirPlay Video if
you've taken our recommendations

00:17:46.200 --> 00:17:54.040
from the past to implement encrypted
streams the way we suggest.

00:17:54.170 --> 00:17:56.510
So what are those recommendations?

00:17:57.660 --> 00:18:00.540
It's all about getting the right key,
getting the keys to the system.

00:18:00.540 --> 00:18:08.790
So either use custom URL protocols using
NSURL protocol to provide the keys,

00:18:08.800 --> 00:18:14.620
or you can use HTTPS and session
cookies to provide keys to the system.

00:18:15.060 --> 00:18:19.400
Now, later this afternoon,
there's a session on HDTV live streaming,

00:18:19.400 --> 00:18:21.910
filling in all the changes
that are happening,

00:18:22.000 --> 00:18:23.740
and some more details here as well.

00:18:23.740 --> 00:18:28.080
I encourage you to go to that
session to find out all the latest.

00:18:30.650 --> 00:18:31.960
Now about the APIs.

00:18:31.990 --> 00:18:36.440
You've heard a lot about AV Foundation,
a powerful set of APIs and a framework

00:18:36.970 --> 00:18:38.100
that lets you do lots of things.

00:18:38.190 --> 00:18:42.140
You get a lot of control,
but it has no UI elements.

00:18:42.260 --> 00:18:45.750
So you can totally write your
app on top of AV Foundation.

00:18:45.950 --> 00:18:47.680
It's great.

00:18:48.770 --> 00:18:50.160
If you want something a
little bit higher level,

00:18:50.290 --> 00:18:53.940
you have another choice,
the media player framework.

00:18:53.960 --> 00:18:59.520
The media player framework embodies the
expected behavior that we want the apps

00:18:59.520 --> 00:19:02.380
to have in terms of media playback.

00:19:02.400 --> 00:19:04.630
So that's a good place to look.

00:19:08.280 --> 00:19:13.420
So when's the right time to allow
AirPlay Video to work for your

00:19:13.420 --> 00:19:16.390
application and for your content?

00:19:22.760 --> 00:19:25.600
If your application is
a media playback app,

00:19:25.600 --> 00:19:28.400
it makes a lot of sense because you
want the full playback experience.

00:19:28.400 --> 00:19:30.930
Like I said before,
the content is streamed

00:19:30.930 --> 00:19:33.620
directly to the device.

00:19:33.620 --> 00:19:36.420
No degradation in playback quality.

00:19:36.420 --> 00:19:38.050
Works great.

00:19:38.420 --> 00:19:41.260
But it's not always the right choice.

00:19:41.320 --> 00:19:45.720
Imagine the user had just finished
watching their favorite TV show.

00:19:45.990 --> 00:19:47.100
Display it on the big screen.

00:19:47.300 --> 00:19:49.960
And then they go, play your video game,
and you have an intro movie.

00:19:49.960 --> 00:19:54.450
You don't want your intro movie to show
up on the TV taking focus away from where

00:19:54.460 --> 00:19:55.570
they're going to be playing the game.

00:19:58.560 --> 00:20:01.200
The other case,
other than incidental videos,

00:20:01.260 --> 00:20:02.780
is audio playback.

00:20:02.840 --> 00:20:05.200
You don't want the AirPlay video
mode to be used when you're

00:20:05.200 --> 00:20:07.770
playing audio-only content.

00:20:07.980 --> 00:20:10.330
MP Movie Player Controller takes
care of this for you,

00:20:10.330 --> 00:20:12.700
but when you're using
AV Foundation and AV Player,

00:20:12.730 --> 00:20:15.060
you need to take care of that yourself.

00:20:16.400 --> 00:20:21.900
Keep in mind that in iOS 5,
AirPlay Video is now allowed by default.

00:20:21.940 --> 00:20:25.890
When we first released
AirPlay Video in iOS 4.3,

00:20:26.590 --> 00:20:31.100
It was disabled for media player
framework and for web pages.

00:20:31.160 --> 00:20:34.490
The application or the web page
designer had to explicitly enable it.

00:20:34.530 --> 00:20:38.800
With iOS 5,
not only have we brought AirPlay video

00:20:38.800 --> 00:20:44.900
to AV Foundation and UI WebView,
but it's now the default to be allowed.

00:20:47.290 --> 00:20:52.800
So if you're delivering content or
applications to multiple iOS releases,

00:20:52.840 --> 00:20:54.700
go ahead and be explicit.

00:20:54.760 --> 00:20:59.100
Just use these APIs to set
the value that needs to be.

00:21:00.290 --> 00:21:01.660
So how do you do that for applications?

00:21:01.750 --> 00:21:02.470
It's pretty easy.

00:21:02.470 --> 00:21:05.740
There's a couple of properties,
mostly named about the same,

00:21:05.850 --> 00:21:06.880
allows AirPlay.

00:21:06.880 --> 00:21:09.230
And you just set that to yes or no.

00:21:09.230 --> 00:21:13.170
And UI WebView has media
playback allows AirPlay.

00:21:13.180 --> 00:21:17.410
This basically allows...

00:21:17.570 --> 00:21:23.830
web pages that enable AirPlay to
play inside the UI web view.

00:21:24.090 --> 00:21:26.320
It's a little bit more
about the web pages.

00:21:26.330 --> 00:21:29.850
There's two ways to enable
AirPlay video playback on a web page,

00:21:29.850 --> 00:21:32.420
using the video tag and the embed tag.

00:21:32.460 --> 00:21:34.930
For the video tag, it's xWebKitAirPlay.

00:21:35.160 --> 00:21:37.600
You set that to allow or deny.

00:21:37.630 --> 00:21:42.360
And for the embed tag, you use AirPlay,
and you set that to allow or deny.

00:21:46.210 --> 00:21:52.490
So when you're using AirPlay video
and it is actually playing on the TV,

00:21:53.850 --> 00:21:58.800
Make sure that your app
doesn't look broken.

00:21:58.830 --> 00:22:02.560
You don't want the user to be sitting
there and be confused what's going on.

00:22:02.730 --> 00:22:05.440
Instead,
you want to give them an indication

00:22:05.520 --> 00:22:07.910
where to look to see their content.

00:22:09.200 --> 00:22:11.620
So what do you have to do
with MPMoviePlayerController

00:22:12.040 --> 00:22:12.800
to get that behavior?

00:22:12.800 --> 00:22:14.320
Nothing.

00:22:14.800 --> 00:22:15.540
It does it for you.

00:22:17.750 --> 00:22:20.570
But for AV player,
you need to do some work yourself.

00:22:20.710 --> 00:22:23.090
Like I said before,
there's no built-in UI.

00:22:23.280 --> 00:22:26.480
There's no UI elements
inside AV Foundation.

00:22:26.500 --> 00:22:29.090
Instead, you do this yourself.

00:22:29.260 --> 00:22:31.220
You check the property
AirPlay Video Active,

00:22:31.220 --> 00:22:35.110
and if AirPlay Video is active,
you display your helpful message.

00:22:36.580 --> 00:22:42.740
And it's key value observable,
so you can listen for state changes.

00:22:42.790 --> 00:22:45.970
Now let's talk a little bit
about the full screen experience.

00:22:51.180 --> 00:22:55.600
Here's an example of an
application that uses inline video.

00:22:55.670 --> 00:22:58.870
While you're playing the video,
you've got this additional content

00:22:58.870 --> 00:23:03.380
that goes along with the video and
enhances the experience for the user.

00:23:05.950 --> 00:23:10.600
Whether you're hooked up to a TV through
a wire or through an AirPlay screen,

00:23:10.660 --> 00:23:14.700
it makes sense to mirror the whole
display because you want to watch

00:23:14.700 --> 00:23:17.410
the video and see the other content.

00:23:17.580 --> 00:23:20.860
Now, if the user clicks on
the full screen button,

00:23:20.860 --> 00:23:24.900
you want to transition into a
mode where you take advantage

00:23:24.980 --> 00:23:28.690
of the full screen of the TV,
either through

00:23:29.350 --> 00:23:35.760
AirPlay Video, or using UI Screen APIs,
which we'll talk more about later.

00:23:37.550 --> 00:23:41.980
So to achieve this with
MP Movie Player Controller,

00:23:42.020 --> 00:23:45.130
it takes care of most of it for you,
but it needs one piece of information.

00:23:45.270 --> 00:23:47.680
It needs to know that you
mean to be in full screen.

00:23:47.680 --> 00:23:51.040
So you just set full screen,
and then the player

00:23:51.140 --> 00:23:52.940
will do the right thing.

00:23:52.940 --> 00:23:55.640
It's not okay just to
stretch the view to fit,

00:23:55.920 --> 00:23:59.090
because then you're not going
to get the right behavior.

00:24:01.330 --> 00:24:04.970
With AVPlayer,
you've got more work to do.

00:24:05.090 --> 00:24:09.390
The application is responsible for taking
advantage of that external display.

00:24:12.150 --> 00:24:15.590
So typically,
your application has a concept that

00:24:15.590 --> 00:24:18.010
it wants to be in full screen or not.

00:24:21.290 --> 00:24:25.530
When you're in AirPlay screen mode,
everything's being mirrored.

00:24:25.650 --> 00:24:31.050
So you need to tell us that it's
okay to switch to AirPlay video.

00:24:31.970 --> 00:24:35.610
So you set the use this
AirPlay video while AirPlay screen

00:24:35.610 --> 00:24:37.400
active property to yes.

00:24:38.660 --> 00:24:44.870
And this is harmless if
AirPlay screen is not active.

00:24:45.100 --> 00:24:49.610
So go ahead and set it whenever
your app is in a full screen mode.

00:24:49.610 --> 00:24:51.900
And then we'll just do
the right thing then.

00:24:51.920 --> 00:24:55.450
Now in the wired case,
you need to do more work with

00:24:55.800 --> 00:25:00.100
the UI screen APIs to get the
video on the second display.

00:25:01.490 --> 00:25:06.580
So let's talk more about
using multiple displays.

00:25:09.960 --> 00:25:12.140
Remember what I said before.

00:25:12.170 --> 00:25:15.860
AirPlay Screen,
we use the same basic techniques

00:25:15.920 --> 00:25:21.370
at the lowest level to implement
the mirroring and second display as

00:25:21.370 --> 00:25:27.490
we did for wired displays through
the Apple Digital AV adapter.

00:25:28.540 --> 00:25:34.900
That means the same APIs,
from your perspective, work.

00:25:35.000 --> 00:25:37.350
And it's great for all apps.

00:25:37.970 --> 00:25:40.860
Not just media playback apps.

00:25:40.900 --> 00:25:44.290
And to tell you more about that,
I'd like to get Josh on the stage,

00:25:44.310 --> 00:25:49.030
and he'll walk you through
all sorts of great stuff.

00:25:54.110 --> 00:25:55.020
All right.

00:25:55.040 --> 00:25:55.410
Thanks, Jim.

00:25:55.410 --> 00:25:59.580
So now we're going to talk a little
bit more about how you can take

00:25:59.860 --> 00:26:03.840
full advantage of these external
displays as a unique second display.

00:26:03.840 --> 00:26:07.420
Everything that Jim's been talking
about so far is nice tweaks that you

00:26:07.500 --> 00:26:11.020
can make to your existing applications
and the things you already have

00:26:11.020 --> 00:26:14.380
in place to get great experiences
with the existing AirPlay video

00:26:14.380 --> 00:26:16.520
and AirPlay audio technologies.

00:26:16.520 --> 00:26:20.480
So now we'll look at using those
second displays as independent content.

00:26:21.340 --> 00:26:23.260
So we're going to cover
a few things today.

00:26:23.260 --> 00:26:28.340
First, we'll talk about mirroring your
content to the external display,

00:26:28.490 --> 00:26:30.640
which, as Jim said,
is the default behavior.

00:26:30.640 --> 00:26:33.410
If you do no other work,
this is what you'll get.

00:26:33.460 --> 00:26:36.200
But then from there,
we'll talk about how you can use that

00:26:36.200 --> 00:26:39.820
second display to display additional
content that is not the same as what's

00:26:39.830 --> 00:26:41.660
showing up on the internal panel.

00:26:41.660 --> 00:26:45.260
Once we've covered that,
there's two other sort of side

00:26:45.260 --> 00:26:47.230
notes we're going to go into.

00:26:47.310 --> 00:26:48.900
The first is overscan.

00:26:48.900 --> 00:26:52.270
So if you've been around for, you know,
the last 30 years,

00:26:52.270 --> 00:26:54.580
you've probably seen overscan
at some point and hoped that

00:26:54.580 --> 00:26:55.560
it had gone away by now.

00:26:55.560 --> 00:26:57.280
But it's here, so we'll talk about it.

00:26:57.340 --> 00:27:00.070
And finally,
we're going to talk about screen modes,

00:27:00.180 --> 00:27:03.730
which we'll get into later on,
how you can take advantage of different

00:27:03.730 --> 00:27:05.660
modes available on the display.

00:27:05.660 --> 00:27:08.800
So first off, what are we talking about
with this second display?

00:27:08.800 --> 00:27:10.740
Well, we're not talking about this.

00:27:10.740 --> 00:27:12.560
You may be used to Mac OS X.

00:27:12.560 --> 00:27:16.530
Second display is an extended
desktop where you share content

00:27:16.920 --> 00:27:21.220
across the displays and you can
bridge them with a single window.

00:27:21.220 --> 00:27:23.920
That's not what we're
talking about on iOS.

00:27:24.030 --> 00:27:27.190
On iOS,
the second display is a unique display.

00:27:27.190 --> 00:27:30.530
It is controlled entirely
by the foreground app.

00:27:30.540 --> 00:27:34.590
So while your application is frontmost,
you have full control over all content

00:27:34.590 --> 00:27:36.870
that shows up on that secondary display.

00:27:36.980 --> 00:27:38.770
No one else is going to run
and take over your screen.

00:27:38.910 --> 00:27:45.740
You also have these two different modes,
the mirroring and the second display,

00:27:45.860 --> 00:27:49.490
where you can display separate content.

00:27:49.800 --> 00:27:51.530
So first off, this mirroring.

00:27:51.610 --> 00:27:55.260
If you do nothing else, as I said,
this will happen automatically as soon

00:27:55.260 --> 00:27:59.220
as you either plug in the hard cable
or your user picks AirPlay from the

00:27:59.230 --> 00:28:01.460
route picker and turns on mirroring.

00:28:01.490 --> 00:28:04.650
And anything you have displayed on your
internal panel will automatically get

00:28:04.650 --> 00:28:08.320
mirrored out to that second display
exactly as you see it internally.

00:28:08.360 --> 00:28:11.630
Now, of course, as you can see here,
this isn't necessarily ideal.

00:28:11.850 --> 00:28:15.360
You're not using that entire screen
space that's available to you.

00:28:15.560 --> 00:28:18.780
You've got this beautiful
16 by 9 display connected,

00:28:18.840 --> 00:28:21.870
but we've got these big bars
down the side because our main

00:28:21.990 --> 00:28:26.880
content is just taking up that
small amount in the middle.

00:28:27.950 --> 00:28:30.920
So the nice thing, of course,
is that you don't have to do

00:28:30.920 --> 00:28:32.180
any additional work to get this.

00:28:32.180 --> 00:28:34.740
There is one thing that you
really do need to keep in mind

00:28:34.740 --> 00:28:38.210
if you plan on using mirroring,
though, and that is to set your status

00:28:38.300 --> 00:28:40.070
bar orientation appropriately.

00:28:40.080 --> 00:28:43.450
Now, hopefully you already know this
and are doing it for other reasons.

00:28:43.450 --> 00:28:45.940
For instance,
if you use keyboards in your application,

00:28:46.040 --> 00:28:48.400
the orientation that the
keyboard comes up in will follow

00:28:48.540 --> 00:28:50.020
the status bar orientation.

00:28:50.020 --> 00:28:52.320
So if you have the wrong
status bar orientation,

00:28:52.320 --> 00:28:53.730
it may come in upside down.

00:28:53.730 --> 00:28:56.950
System alerts will appear in
the status bar orientation.

00:28:57.300 --> 00:28:59.620
So there's many reasons that you
want to make sure this is right.

00:28:59.630 --> 00:29:05.060
But for the purposes of AirPlay Screen,
your mirroring will be upside down if

00:29:05.110 --> 00:29:08.320
you have your status bar orientation
right or possibly rotated sideways.

00:29:08.320 --> 00:29:12.580
So if your user rotates the iPad and you
don't update the status bar orientation,

00:29:12.580 --> 00:29:14.040
you're going to get that.

00:29:14.650 --> 00:29:16.660
Probably not what you wanted.

00:29:16.660 --> 00:29:18.060
But it's really easy to fix.

00:29:18.160 --> 00:29:21.950
Just make sure you set the status bar
orientation to match whatever orientation

00:29:21.950 --> 00:29:25.060
you're rendering your content in,
and it will just rotate right

00:29:25.060 --> 00:29:27.080
around and be correct right side up.

00:29:27.300 --> 00:29:31.280
no matter what orientation the
user is holding their iPad in.

00:29:32.930 --> 00:29:36.010
So if you need to detect
that mirroring is happening,

00:29:36.010 --> 00:29:38.770
for instance,
somewhere in your application you

00:29:38.770 --> 00:29:41.110
decide you need to do something
slightly different in the case

00:29:41.210 --> 00:29:43.650
where mirroring is occurring,
it's very easy with one line of code

00:29:43.650 --> 00:29:45.340
to detect that this is happening.

00:29:45.340 --> 00:29:48.690
Once you get your UI screen object,
which we'll look at in a little bit,

00:29:48.690 --> 00:29:51.230
you can just send it the
mirrored screen message.

00:29:51.230 --> 00:29:54.730
And if mirroring is occurring,
the object you get back from mirrored

00:29:54.730 --> 00:29:58.090
screen will be UI screen main screen,
because mirroring always is

00:29:58.090 --> 00:29:59.840
mirroring that main screen.

00:29:59.840 --> 00:30:02.650
So one line of code,
easy to see if it's happening.

00:30:02.800 --> 00:30:06.850
This is supported, of course, on iPad 2,
and it's supported with

00:30:06.910 --> 00:30:10.630
a variety of cables,
including the Apple Digital AV adapter,

00:30:10.650 --> 00:30:14.240
the Apple VGA adapter, and, of course,
now Apple TV.

00:30:14.240 --> 00:30:17.030
So there's a number of different
technologies that you can have

00:30:17.030 --> 00:30:19.990
connected with and still be
getting this mirroring experience.

00:30:19.990 --> 00:30:22.910
They're all the same from the
purposes of your application.

00:30:25.100 --> 00:30:25.990
All right, so that's mirroring.

00:30:26.110 --> 00:30:26.840
Not a whole lot there.

00:30:26.840 --> 00:30:28.390
Pretty easy to take advantage of.

00:30:28.460 --> 00:30:31.770
But what if you want to really
take full advantage of that second

00:30:31.810 --> 00:30:34.740
display and fill that full 16
by 9 bounds with that beautiful

00:30:35.050 --> 00:30:36.730
content that you have in your app?

00:30:36.840 --> 00:30:38.780
Well,
we want to do something more like this

00:30:38.930 --> 00:30:40.950
and really take advantage of that screen.

00:30:40.960 --> 00:30:42.560
This is pretty easy, too.

00:30:43.820 --> 00:30:47.800
The one thing that I want to strongly
encourage you to do is avoid this.

00:30:47.800 --> 00:30:50.700
If you're using second display
and displaying separate

00:30:50.750 --> 00:30:53.940
content out to the panel,
don't leave your main iPad

00:30:53.940 --> 00:30:55.670
or iPhone screen blank.

00:30:55.720 --> 00:30:58.540
The worst thing you can do for
your user is have the iPad,

00:30:58.540 --> 00:31:02.530
this beautiful device with a great
screen in their hands with nothing on it.

00:31:02.630 --> 00:31:06.960
So make sure you keep something, some UI,
on the main screen as well.

00:31:08.820 --> 00:31:13.540
So if you want to take advantage of this,
UIScreen is the API that you use to do

00:31:13.540 --> 00:31:15.800
all your drawing to the external screen.

00:31:15.900 --> 00:31:18.840
And the great thing about this is
that you already know how to do it.

00:31:18.890 --> 00:31:22.610
Any content that you know how
to draw on the internal panel,

00:31:22.610 --> 00:31:27.560
you can draw on the external screen
using all of the same APIs plus UIScreen.

00:31:28.580 --> 00:31:32.280
So there's two main things you'll
have to do in order to make

00:31:32.360 --> 00:31:33.680
use of UIScreen in this way.

00:31:33.680 --> 00:31:36.850
The first is to detect the presence
of an external display so that

00:31:36.850 --> 00:31:39.800
you know that it's time to try
and display content out there.

00:31:39.800 --> 00:31:44.600
And the second then is to configure
that screen and place content on it.

00:31:45.200 --> 00:31:47.330
So there's actually two places
where you'll want to detect

00:31:47.460 --> 00:31:48.920
the presence of a screen.

00:31:48.960 --> 00:31:50.580
The first is on application launch.

00:31:50.580 --> 00:31:53.820
And as with most other things that
you would do on application launch,

00:31:53.820 --> 00:31:56.760
you do this in the application
did finish launching method.

00:31:56.760 --> 00:32:00.150
You just can check on your
application launch if there's

00:32:00.150 --> 00:32:02.030
already a screen attached.

00:32:02.030 --> 00:32:04.910
And you do that just by
counting the number of screens.

00:32:04.910 --> 00:32:09.830
The first screen in the UIScreen screens
array will always be the main screen,

00:32:09.830 --> 00:32:11.320
the internal panel.

00:32:11.320 --> 00:32:15.080
So if there's more than one there,
the rest of them are external displays.

00:32:15.180 --> 00:32:18.940
For the purposes of what
I'm looking at here,

00:32:18.970 --> 00:32:22.010
we're going to simplify it and just
get the last screen out of that array.

00:32:22.080 --> 00:32:24.360
You may want to look through the
array and see if there's one in

00:32:24.360 --> 00:32:25.930
particular that you were interested in.

00:32:25.980 --> 00:32:28.260
But I'm just going to
grab the last screen.

00:32:28.260 --> 00:32:30.860
And I'll write in just a minute
this prepare screen method.

00:32:30.860 --> 00:32:31.940
This isn't a system call.

00:32:31.940 --> 00:32:34.120
It's one that we're going
to write in just a minute.

00:32:34.120 --> 00:32:38.670
But we're going to use that same method
to detect both application launch

00:32:38.670 --> 00:32:41.200
screens and screens that come later.

00:32:41.200 --> 00:32:44.100
So the second case is
detecting display connections.

00:32:44.100 --> 00:32:47.480
connections after your
application is already running.

00:32:47.480 --> 00:32:50.860
And this is also really easy
using an NS notification,

00:32:50.860 --> 00:32:53.640
UI screen did connect notification.

00:32:53.640 --> 00:32:56.210
So probably also, when your application
did finish launching,

00:32:56.210 --> 00:32:58.900
you would just register for this
notification and then you'll be

00:32:59.030 --> 00:33:02.550
called back any time the user
plugs in a cable or connects to an

00:33:02.550 --> 00:33:05.320
AirPlay screen through the route picker.

00:33:05.320 --> 00:33:09.740
And again, once we've registered
for this notification,

00:33:09.740 --> 00:33:12.300
we can call that same
prepare screen method,

00:33:12.300 --> 00:33:15.380
and this time we'll get the UI screen
object out of the notification

00:33:15.740 --> 00:33:19.000
because UIKit has passed the screen
object that was connected to you

00:33:19.000 --> 00:33:20.940
as the object of the notification.

00:33:20.990 --> 00:33:23.300
So in both cases,
we get the screen we want to display

00:33:23.300 --> 00:33:27.160
on and call this prepare screen
method that we're about to write.

00:33:27.160 --> 00:33:30.800
Now that method is pretty easy,
except you get to see it all at

00:33:30.890 --> 00:33:33.570
once because my build didn't work.

00:33:33.700 --> 00:33:36.760
There's basically three things
that we want to do here.

00:33:37.090 --> 00:33:39.050
The first is we want to
get the screen's bounds.

00:33:39.080 --> 00:33:41.380
We want to fill that entire
display with content.

00:33:41.380 --> 00:33:44.790
So we want to get the screen bounds,
which is the outer size

00:33:44.950 --> 00:33:46.440
of that entire display.

00:33:46.440 --> 00:33:49.800
Then we'll create a new UI window
that fills that entire screen

00:33:49.800 --> 00:33:53.220
bounds to make sure we fill the
entire area on that display.

00:33:53.940 --> 00:33:56.910
The only other thing we have to
do then is move that screen to the

00:33:56.910 --> 00:34:00.600
display to tell UIKit that we want
to be drawing to the external screen.

00:34:00.600 --> 00:34:03.830
So we'll call window set screen
and pass in the screen that we

00:34:03.830 --> 00:34:05.700
decided we want to display on.

00:34:05.720 --> 00:34:09.080
Of course, there is one last thing,
which is setting the window's

00:34:09.080 --> 00:34:11.890
hidden property to no,
because by default, windows,

00:34:11.900 --> 00:34:14.150
when they're created, start out hidden.

00:34:14.160 --> 00:34:16.190
So we've moved that window to the screen.

00:34:16.190 --> 00:34:19.020
We've caused it to become
visible by setting hidden no.

00:34:19.020 --> 00:34:22.000
And now you can use any of the
technologies you already know how

00:34:22.000 --> 00:34:23.680
to use on your internal panel.

00:34:24.040 --> 00:34:25.740
To draw content to the external panel.

00:34:25.780 --> 00:34:30.570
So you can use OpenGL through
CAEAGL layer or any of the various

00:34:30.570 --> 00:34:34.230
UIKit classes to get content out to
that screen exactly the same way you

00:34:34.230 --> 00:34:35.950
would get it onto your internal screen.

00:34:35.960 --> 00:34:38.380
So we've now written our app.

00:34:38.450 --> 00:34:39.460
Everything's looking great.

00:34:39.510 --> 00:34:42.930
We've got this beautiful game that we
wrote and we decide that we're going to

00:34:42.970 --> 00:34:45.030
add some overlays on top of our content.

00:34:45.040 --> 00:34:48.210
We want to add maybe some health
information for our player and a

00:34:48.220 --> 00:34:50.120
couple of messages along the bottom.

00:34:50.210 --> 00:34:53.880
So we just add those around the edges of
our game and everything's looking great.

00:34:53.950 --> 00:35:20.060
We've also added some of our So this is
something that you will end up seeing

00:35:20.060 --> 00:35:21.240
and have to deal with in some way.

00:35:21.750 --> 00:35:23.880
But we've greatly
improved this situation.

00:35:23.940 --> 00:35:25.150
In iOS 5.

00:35:25.200 --> 00:35:27.720
So we'll get to that in just a second.

00:35:27.720 --> 00:35:30.320
Of course,
what we want to do is inset that

00:35:30.390 --> 00:35:32.120
content so that it doesn't get clipped.

00:35:32.220 --> 00:35:35.070
Now we could do that by just
shrinking everything down.

00:35:35.080 --> 00:35:37.640
But of course,
then we have these black bars around the

00:35:37.640 --> 00:35:40.720
edges and I'll just highlight them in red
to make it more clear that they're there.

00:35:40.720 --> 00:35:43.590
So our content no longer
fills the entire screen.

00:35:43.600 --> 00:35:45.870
Ideally,
we would like to actually stretch

00:35:45.900 --> 00:35:49.320
that background content out to
fill all the available pixels,

00:35:49.320 --> 00:35:51.870
but still avoid clipping
the bits that are over top.

00:35:53.090 --> 00:35:53.920
So UIKit has actually
been able to do that.

00:35:53.940 --> 00:35:58.330
So we've added these new modes to
help you adapt to this UI screen

00:35:58.330 --> 00:36:03.550
overscanned situation much easier
than was ever possible before.

00:36:03.560 --> 00:36:07.750
So the new property is
UI screen overscan compensation.

00:36:08.030 --> 00:36:10.450
And there are three possible
modes that you can set it to.

00:36:10.630 --> 00:36:14.060
The default is UI screen
overscan compensation scale.

00:36:14.060 --> 00:36:17.850
And then there's two more,
inset bounds and inset application frame.

00:36:18.000 --> 00:36:20.820
So let's look at all three of these
and see what they're going to do.

00:36:20.980 --> 00:36:23.140
Now the default, as I said, is scale.

00:36:23.240 --> 00:36:26.510
And this is really great
for generic UIKit content.

00:36:26.910 --> 00:36:29.940
Generally anything that isn't
particularly performance sensitive.

00:36:30.020 --> 00:36:33.300
And what you'll get here,
and the reasons that you

00:36:33.300 --> 00:36:38.320
might want to use this,
are you get a full frame buffer of

00:36:38.320 --> 00:36:40.010
whatever size screen you're using.

00:36:40.020 --> 00:36:42.530
So for the purposes of all these
examples we're about to walk through,

00:36:42.670 --> 00:36:45.600
we'll assume that you're
connected to 720p displays.

00:36:45.620 --> 00:36:48.200
Now the same things we're talking
about here would apply if you're

00:36:48.200 --> 00:36:52.470
connected to a 1080p display with an
iPad 2 or even a 4:3 aspect ratio.

00:36:52.540 --> 00:36:54.620
Like 1024 by 768.

00:36:54.980 --> 00:36:59.420
So let's just assume 720p here
stands for whatever mode you're in.

00:36:59.520 --> 00:37:02.640
So the nice thing about the
scale mode is that you still

00:37:02.640 --> 00:37:05.020
have a 720p frame buffer to fill.

00:37:05.190 --> 00:37:08.360
So from the perspective
of your application,

00:37:08.530 --> 00:37:11.660
things are exactly the same
whether you're overscanning or not.

00:37:11.780 --> 00:37:13.960
And you don't have to
change any of your code.

00:37:14.060 --> 00:37:19.200
Then UIKit and CoreAnimation will make
sure that when you draw your content,

00:37:19.530 --> 00:37:21.840
it just doesn't get clipped by scaling
it down and keeping it centered.

00:37:21.840 --> 00:37:23.820
So there's no additional
work on your part.

00:37:23.870 --> 00:37:27.830
Of course the downside of this is
that your content is being scaled.

00:37:27.840 --> 00:37:31.520
And this scaling of your content
will introduce a performance

00:37:31.600 --> 00:37:35.510
penalty which will lower the quality
of your content and reduce your

00:37:35.850 --> 00:37:37.860
frame rate that you can render at.

00:37:37.860 --> 00:37:41.960
So it's not ideal if you can spend
a little bit of additional time

00:37:41.960 --> 00:37:44.770
working on your external display code.

00:37:44.870 --> 00:37:47.790
We can use one of these other modes
and greatly improve the situation.

00:37:47.910 --> 00:37:49.860
So let's look at inset bounds.

00:37:49.860 --> 00:37:51.100
This is sort of the next step.

00:37:51.230 --> 00:37:56.140
It's sort of the next step up in terms of
quality with minimal additional effort.

00:37:56.170 --> 00:37:59.140
This is really good for high
performance UIKit content.

00:37:59.240 --> 00:38:02.320
If you've got something that you
really are concerned about the

00:38:02.320 --> 00:38:05.990
performance of and you want to
get the best possible quality,

00:38:06.170 --> 00:38:08.140
you can switch to inset bounds.

00:38:08.140 --> 00:38:11.290
Now what this is going to do
for you is give you a smaller

00:38:11.290 --> 00:38:13.140
screen bounds to draw into.

00:38:13.140 --> 00:38:17.480
So if you're again at that 720p mode,
you actually will not have the

00:38:17.480 --> 00:38:20.440
full 1280 by 720 pixels to fill.

00:38:20.440 --> 00:38:22.440
So this is going to allow
you to fill fewer pixels.

00:38:22.440 --> 00:38:25.670
The result of that is that we won't
have to scale anything down in order

00:38:25.670 --> 00:38:27.440
to avoid cropping your content.

00:38:27.440 --> 00:38:30.430
So there will be no scaling
which will preserve that quality

00:38:30.430 --> 00:38:33.440
and give you the best quality
rendering that you could get.

00:38:33.670 --> 00:38:37.420
This will also give you that full
performance because you'll avoid the

00:38:37.420 --> 00:38:40.530
additional scaling pass that the system
would otherwise have to go through to

00:38:40.800 --> 00:38:43.440
scale your content down at every frame.

00:38:43.440 --> 00:38:47.420
Now the downside of this is that you
have to do a little bit of extra work.

00:38:47.550 --> 00:38:49.440
And because you have this
less than 720p frame buffer,

00:38:49.440 --> 00:38:49.440
you can't really scale your content down.

00:38:49.440 --> 00:38:52.400
So you have to make sure that
when you're drawing your content,

00:38:52.530 --> 00:38:56.410
you're able to draw it at slightly
less standard resolutions.

00:38:56.510 --> 00:39:00.870
In the case of 720p,
you'll probably have about 5 to 10% less

00:39:00.870 --> 00:39:04.440
area than a full 720p frame to fill.

00:39:04.440 --> 00:39:08.340
So you have to be able to draw at these
sort of resolution independent modes.

00:39:08.440 --> 00:39:09.440
So let's go back to the first slide.

00:39:10.160 --> 00:39:13.350
Now, if you can really spend a little
more time and go all the way,

00:39:13.350 --> 00:39:16.340
the best you can get is
inset application frame.

00:39:16.340 --> 00:39:20.890
Now, this is great for videos which are
already compensating for overscan or

00:39:20.950 --> 00:39:25.050
for game content where you can just
make sure that you don't draw anything

00:39:25.050 --> 00:39:27.460
that can't be clipped out to the edges.

00:39:27.780 --> 00:39:31.890
So the nice thing here is that you
still get that full 720p frame buffer,

00:39:31.910 --> 00:39:35.640
so you can actually fill all
of the pixels on the screen,

00:39:35.640 --> 00:39:37.500
and some of them around
the edges will be clipped,

00:39:37.590 --> 00:39:42.380
but you have access to every
pixel and can fill them all.

00:39:43.010 --> 00:39:46.720
You'll get the full screen bounds so that
you know that you can fill everything.

00:39:46.720 --> 00:39:49.040
And you'll get a smaller
application frame.

00:39:49.040 --> 00:39:52.380
Now for those of you that are not
familiar with the UIScreen API yet,

00:39:52.730 --> 00:39:55.480
there are two rects on
UIScreen that are interesting.

00:39:55.480 --> 00:39:58.790
The first is the bounds,
which is that full area of the screen.

00:39:58.790 --> 00:40:02.850
And the second is the application frame,
which is usually used to indicate the

00:40:02.850 --> 00:40:06.890
area that you can safely draw your
content in without it getting clipped.

00:40:06.980 --> 00:40:09.300
On the main screen,
the application frame is

00:40:09.300 --> 00:40:11.060
inset to avoid the status bar.

00:40:11.060 --> 00:40:13.280
On the external screen,
when you have inset

00:40:13.330 --> 00:40:16.590
application frame chosen,
the application frame will be inset

00:40:16.590 --> 00:40:18.620
to avoid clipping around the edges.

00:40:18.680 --> 00:40:20.660
This is,
for those of you familiar with the term,

00:40:20.660 --> 00:40:21.760
the content safe area.

00:40:21.800 --> 00:40:24.620
And you can just,
we'll tell you where it is so you can

00:40:24.620 --> 00:40:28.590
draw your extra content in there and
know that it will not get clipped.

00:40:28.910 --> 00:40:31.570
The nice thing here is that
there's no scaling again because

00:40:31.570 --> 00:40:35.290
you're filling the full bounds,
but you're allowing your content to

00:40:35.290 --> 00:40:39.120
get clipped and just insetting anything
important into the application frame.

00:40:39.120 --> 00:40:42.550
So you'll get full performance
and you'll get full quality.

00:40:42.560 --> 00:40:45.500
The downside, of course,
is that you have to have a little bit

00:40:45.500 --> 00:40:48.860
more ability to position different
parts of your content independent

00:40:48.940 --> 00:40:52.330
of one another because you may have
to have those overlays positioned

00:40:52.370 --> 00:40:53.880
inset from the outer bounds.

00:40:55.900 --> 00:40:57.190
So there was kind of a lot there.

00:40:57.280 --> 00:40:59.150
Let's just do a brief
recap of all of those.

00:40:59.150 --> 00:41:03.550
In the case where you're connected to
a display that is not overscanning,

00:41:03.550 --> 00:41:06.980
so we've detected that you're
connected to this display and the

00:41:06.980 --> 00:41:10.490
display has told UIKit and the
system that it is displaying every

00:41:10.500 --> 00:41:14.330
pixel and not overscanning it,
no matter which mode you have selected,

00:41:14.360 --> 00:41:17.180
scale, inset bounds,
or inset application frame,

00:41:17.180 --> 00:41:20.390
you will still have the full
720p buffer and all of them

00:41:20.390 --> 00:41:22.280
will get displayed on screen.

00:41:23.010 --> 00:41:27.870
So which mode you pick only has an
effect when we detect that the connected

00:41:27.960 --> 00:41:29.820
display is actually overscanning.

00:41:30.050 --> 00:41:32.910
Once we've detected that,
in the scale mode then, of course,

00:41:32.980 --> 00:41:35.750
you'll fill the full 720p buffer
and it will be scaled down.

00:41:35.750 --> 00:41:39.300
In the inset bounds mode,
you'll fill fewer than 720p.

00:41:39.300 --> 00:41:43.860
And in the inset application frame case,
you'll fill 720p but draw important

00:41:43.860 --> 00:41:45.950
things in that application frame.

00:41:49.800 --> 00:41:54.340
So now we've got all of our content,
and we've tested on one display,

00:41:54.340 --> 00:41:56.020
and everything's working great.

00:41:56.070 --> 00:41:59.990
And maybe we haven't tried on a whole
lot of different connections yet and

00:41:59.990 --> 00:42:01.560
a whole lot of different displays.

00:42:01.560 --> 00:42:04.710
Well, there's a number of different ways
that your users may be connecting

00:42:04.720 --> 00:42:06.260
their devices to their TVs.

00:42:06.340 --> 00:42:08.070
For instance,
there's a variety of different

00:42:08.170 --> 00:42:09.560
cables they might connect with.

00:42:09.600 --> 00:42:12.880
There's a variety of iOS devices
they may be using in the first place.

00:42:12.920 --> 00:42:15.700
And there are many different
TVs they may be connected to.

00:42:15.740 --> 00:42:18.960
And when you have all these
different combinations of things,

00:42:18.960 --> 00:42:22.620
there's a variety of different screen
modes that you may have available to you.

00:42:22.650 --> 00:42:24.960
Now we're going to get into a
large number of things here,

00:42:24.960 --> 00:42:27.760
and we're going to talk about a whole
lot of different modes you might see.

00:42:27.820 --> 00:42:30.530
But just at a high level,
keep in mind that if you test a

00:42:30.670 --> 00:42:35.640
4 by 3 mode and a 16 by 9 mode,
you've got yourself pretty well covered.

00:42:35.830 --> 00:42:38.000
So let's say that we've got
this combination right here.

00:42:38.140 --> 00:42:41.720
We've got an iPhone 4
with a digital AV adapter,

00:42:41.750 --> 00:42:44.540
and we've got one TV that
we're testing with.

00:42:44.940 --> 00:42:48.110
When we're using that,
maybe with doing nothing else,

00:42:48.150 --> 00:42:51.450
we're getting 720p output
as our default mode.

00:42:51.630 --> 00:42:54.840
But maybe our user is
actually using an iPad 2.

00:42:54.890 --> 00:42:57.990
So instead of that,
they're getting 1080p.

00:42:58.750 --> 00:43:01.780
They may also be using a different cable
or connected to a different screen,

00:43:01.780 --> 00:43:08.620
so you might instead see 1024x768,
800x600, 640x480,

00:43:08.620 --> 00:43:12.430
or possibly even if they're using
some of the older analog cables,

00:43:12.550 --> 00:43:13.480
NTSC and PAL.

00:43:13.480 --> 00:43:16.320
Now, as I mentioned,
there's a lot of stuff here,

00:43:16.320 --> 00:43:17.960
but don't worry too much.

00:43:17.960 --> 00:43:20.510
They're all going to
be either 4x3 or 16x9,

00:43:20.540 --> 00:43:23.580
so if you've tested with both,
you're pretty well covered.

00:43:24.020 --> 00:43:28.590
Even the NTSC and PAL resolutions, which,
as you maybe or maybe don't know,

00:43:28.610 --> 00:43:32.530
are not square pixel,
are actually fixed in UIKit to be

00:43:32.530 --> 00:43:35.470
square pixel display resolutions.

00:43:35.480 --> 00:43:38.440
So when you get an NTSC or
PAL display connected,

00:43:38.440 --> 00:43:42.630
as long as you're using a UI window
and putting it on that UI screen,

00:43:42.630 --> 00:43:50.480
you'll either have a 640x480 bounds or an
854 or something like that by 480 bounds.

00:43:50.540 --> 00:43:53.450
They'll either be 4x3 or 16x9.

00:43:53.980 --> 00:43:56.730
So if you test those two,
you're in pretty good shape.

00:43:56.760 --> 00:44:00.190
Now, with any one combination
of those devices,

00:44:00.190 --> 00:44:05.240
iPhone or iPad or iPod Touch,
particular cable and particular display,

00:44:05.240 --> 00:44:08.930
you will have one preferred
mode out of whatever large

00:44:08.930 --> 00:44:11.690
available list of modes there are.

00:44:11.700 --> 00:44:15.020
Now, there's no single preferred
mode for every combination,

00:44:15.040 --> 00:44:18.660
but in any given combination,
there will be one preferred mode.

00:44:18.660 --> 00:44:20.940
So let's say that in the
combination we've got,

00:44:21.300 --> 00:44:22.930
720p is our preferred mode.

00:44:22.940 --> 00:44:26.290
Now, preferred mode is... It's
actually an actual API thing.

00:44:26.300 --> 00:44:29.150
It's not just something I'm
saying as we prefer this mode.

00:44:29.160 --> 00:44:31.820
If you look on the UI screen API,
there's actually a property

00:44:31.820 --> 00:44:33.040
called preferred mode.

00:44:33.060 --> 00:44:36.980
And that may be 720p.

00:44:36.980 --> 00:44:38.460
It may be 1080p.

00:44:38.460 --> 00:44:40.620
It may be 1024x768.

00:44:40.620 --> 00:44:43.050
Again,
it depends on what combination of device,

00:44:43.110 --> 00:44:44.700
cable, and screen you're on.

00:44:44.740 --> 00:44:47.780
But there will always be one that's
preferred for that given combination.

00:44:47.780 --> 00:44:51.320
Now, the best advice that I can
give you about this is,

00:44:51.320 --> 00:44:55.050
to the best of your ability,
use the preferred mode.

00:44:55.060 --> 00:44:57.320
There's a variety of reasons for that.

00:44:57.580 --> 00:45:00.260
The preferred mode, first of all,
is chosen automatically.

00:45:00.530 --> 00:45:03.460
So if for no other reason,
you can be lazy and don't have to

00:45:03.460 --> 00:45:04.740
do anything and you're gonna get it.

00:45:04.860 --> 00:45:08.340
But there's actually
real good reasons too.

00:45:08.510 --> 00:45:12.450
So there's no hardware mode switch
if you stick with the preferred mode.

00:45:12.460 --> 00:45:16.320
When you tell a connected
display to change modes,

00:45:16.600 --> 00:45:20.140
this can be a lengthy operation,
possibly even taking multiple seconds.

00:45:20.280 --> 00:45:25.970
And there's often not real nice for
your users flashes of perhaps white

00:45:25.970 --> 00:45:29.140
or different colors on the screen
while the mode switch is happening.

00:45:29.230 --> 00:45:32.430
So sticking with the preferred mode
will avoid that hardware mode switch,

00:45:32.720 --> 00:45:36.500
avoid the screen flashes,
and give you a seamless transition

00:45:36.500 --> 00:45:38.500
between mirroring and second display.

00:45:38.830 --> 00:45:42.830
Mirroring, the system mirroring mode,
will always be using the preferred mode.

00:45:42.980 --> 00:45:46.060
So if when you switch from
mirroring to second display,

00:45:46.060 --> 00:45:48.460
you stick with the preferred mode,
you can be sure that there

00:45:48.460 --> 00:45:49.980
will be no display mode change.

00:45:49.980 --> 00:45:51.520
change.

00:45:51.710 --> 00:45:57.930
This will also give you faster launch
times or faster application transitions

00:45:58.100 --> 00:46:01.130
from mirroring to second display.

00:46:01.830 --> 00:46:03.600
A couple other things that
are nice about this is that it

00:46:03.600 --> 00:46:05.870
gives you the best aspect ratio.

00:46:05.970 --> 00:46:08.620
So if you're on a 16 by 9 display,
your preferred mode

00:46:08.620 --> 00:46:10.080
will be a 16 by 9 mode.

00:46:10.090 --> 00:46:12.270
And it gives you the best quality.

00:46:12.270 --> 00:46:15.950
All of these LCD TVs that are out there,
they have a native resolution.

00:46:16.000 --> 00:46:20.310
And very often, the native resolution,
when available, is the preferred mode.

00:46:20.310 --> 00:46:23.990
So if you're using the preferred mode,
you're probably also avoiding an

00:46:24.010 --> 00:46:25.780
extra pass through the TV scaler.

00:46:25.920 --> 00:46:29.940
So you're preserving the best possible
quality for your users as well.

00:46:29.940 --> 00:46:31.440
All right.

00:46:31.440 --> 00:46:35.970
So if I haven't hammered that in enough,
there may actually be a case where

00:46:36.180 --> 00:46:37.340
you might want to change modes.

00:46:37.350 --> 00:46:41.350
So why would you do that?

00:46:41.350 --> 00:46:41.350
Well,

00:46:42.260 --> 00:46:44.920
The best example I can give of why
you might want to do this is if you're

00:46:44.920 --> 00:46:49.170
writing a high-performance game and you
find that you simply can't render enough

00:46:49.300 --> 00:46:52.300
pixels fast enough to fill a large mode.

00:46:52.300 --> 00:46:54.430
So maybe you just can't
get your performance,

00:46:54.430 --> 00:46:58.150
your frame rate up high enough at
1080p to stick with 1080p and you

00:46:58.470 --> 00:47:01.950
really just want to always choose
720p instead when it's available.

00:47:01.960 --> 00:47:05.010
So there's three ways that
you can address this problem.

00:47:05.010 --> 00:47:09.660
The first is ignore that and do more
work and optimize your drawing code until

00:47:09.660 --> 00:47:12.080
you get to an acceptable frame rate.

00:47:12.200 --> 00:47:16.310
And so of course,
I strongly recommend that.

00:47:16.680 --> 00:47:19.700
But, you know,
the benefit there is that you'll still

00:47:19.750 --> 00:47:22.120
get to render at full resolution,
so you're going to get the best quality.

00:47:22.120 --> 00:47:25.550
This will, of course,
also give you that optimal quality

00:47:25.550 --> 00:47:27.480
and avoiding the mode switch.

00:47:27.480 --> 00:47:29.970
The downside is that, well,
it's more work.

00:47:30.060 --> 00:47:32.080
You have to do all this
extra performance tuning,

00:47:32.150 --> 00:47:35.030
which hopefully you're doing anyway,
so maybe you've already done it all

00:47:35.030 --> 00:47:36.430
and you just still can't get there.

00:47:36.440 --> 00:47:39.620
And you're still possibly ending
up with lower performance on

00:47:39.680 --> 00:47:41.700
these high-resolution displays.

00:47:42.080 --> 00:47:46.070
So, if that doesn't work,
next option is to use the preferred

00:47:46.070 --> 00:47:48.280
mode but render at a lower resolution.

00:47:48.280 --> 00:47:52.040
Now, what I mean by that is,
say you're drawing OpenGL content.

00:47:52.040 --> 00:47:58.030
Create your CA OpenGL layer at 720p size,
even if you're using a 1080p mode,

00:47:58.040 --> 00:48:01.610
and then apply a scale transform to
the layer to scale that smaller render

00:48:01.800 --> 00:48:04.080
buffer up to fill the full 1080p.

00:48:04.080 --> 00:48:08.750
This allows you to render fewer numbers
of pixels and just adds that final

00:48:08.750 --> 00:48:11.990
scaling pass to scale the rendered
pixels up to fill the entire frame.

00:48:12.090 --> 00:48:15.680
This way, you'll stick with the benefits
of the preferred mode.

00:48:15.680 --> 00:48:18.390
You won't have that hardware mode switch,
and you'll still be

00:48:18.440 --> 00:48:19.760
avoiding the TV scalers.

00:48:19.760 --> 00:48:23.600
You'll be using the built-in
high-quality scalers on the iOS device.

00:48:23.600 --> 00:48:26.320
But the disadvantage is that
you're going to be using more

00:48:26.320 --> 00:48:27.740
memory than is necessary.

00:48:27.760 --> 00:48:31.680
You'll be allocating 1080p frame buffers,
even though you're really only trying

00:48:31.680 --> 00:48:33.640
to display 720p worth of content.

00:48:35.200 --> 00:48:37.820
So if that's not acceptable,
your final option then, of course,

00:48:37.930 --> 00:48:39.370
is to actually change the mode.

00:48:39.370 --> 00:48:42.620
And there is a list of available
modes on the UI screen object.

00:48:42.620 --> 00:48:44.540
You can look through them,
find one you want,

00:48:44.540 --> 00:48:45.880
and set it as the current mode.

00:48:45.920 --> 00:48:50.540
The benefit will be that you can optimize
your performance for a known good mode.

00:48:50.640 --> 00:48:54.900
So if you can't support 1080p,
you can optimize for 720p and

00:48:54.900 --> 00:48:56.970
really get a great experience.

00:48:57.800 --> 00:49:00.580
The downside, of course, then,
is that you're going to end up

00:49:00.580 --> 00:49:03.930
with those hardware mode switches,
and you're going to require a

00:49:03.930 --> 00:49:07.190
pass through the TV scaler because
changing the mode will require that

00:49:07.250 --> 00:49:10.420
the TV scale your content down,
or up, rather, before it's displayed.

00:49:14.740 --> 00:49:18.350
So with that in mind, though,
the last and most important

00:49:18.410 --> 00:49:21.540
thing about modes is just don't
ask the user what mode to use.

00:49:21.540 --> 00:49:26.420
This isn't Mac OS X with the system
preference pane launching and looking

00:49:26.420 --> 00:49:29.120
at 20 different available modes.

00:49:29.200 --> 00:49:32.150
Please, please,
please don't put a big mode selection

00:49:32.150 --> 00:49:34.410
thing up there for your users to choose.

00:49:34.420 --> 00:49:38.090
Test your app, see what you can support,
optimize for a particular

00:49:38.090 --> 00:49:41.180
known good mode,
and then pick what's best for your app.

00:49:41.180 --> 00:49:44.980
And make sure that you've really tested
it and know that it's a great experience.

00:49:44.980 --> 00:49:48.240
Because leaving the experience up to
your end user is really just going

00:49:48.240 --> 00:49:50.840
to result in bad reviews anyway,
so might as well pick

00:49:50.840 --> 00:49:52.020
the right one for them.

00:49:52.040 --> 00:49:54.410
So in summary,
just three important things that

00:49:54.410 --> 00:49:56.200
I'd really like you to take away.

00:49:56.200 --> 00:50:00.800
The first is always set that status bar
orientation if you're just mirroring,

00:50:01.050 --> 00:50:03.090
because otherwise you're going
to end up sometimes with the

00:50:03.130 --> 00:50:04.420
content upside down on the TV.

00:50:04.420 --> 00:50:07.130
Second, adjust for overscan.

00:50:07.140 --> 00:50:10.520
I know that we'd like to think
that overscan didn't exist anymore.

00:50:10.680 --> 00:50:12.480
I know I would, but there it is.

00:50:12.550 --> 00:50:16.230
So think about it and use these
new APIs to adjust for it.

00:50:16.290 --> 00:50:19.120
And finally, use that preferred mode
if at all possible.

00:50:19.160 --> 00:50:21.640
So with that in mind,
we're going to have Jacques come

00:50:21.640 --> 00:50:23.930
up and give us a demo of
the AirPlay screen APIs.

00:50:24.000 --> 00:50:25.320
Jacques Pepin: Thanks, Jacques.

00:50:25.320 --> 00:50:27.140
Jacques Pepin: Okay.

00:50:31.360 --> 00:50:32.100
Hi, everyone.

00:50:32.100 --> 00:50:34.430
My name is Jacques-Philippe
Gasselin de Richebourg,

00:50:34.430 --> 00:50:35.860
and I'm from FireMint.

00:50:35.900 --> 00:50:37.940
I'm here to talk to you
today about external display

00:50:37.940 --> 00:50:40.320
support in Real Racing 2 HD.

00:50:40.670 --> 00:50:45.040
I'm going to first take you back a
little bit to our first racing game here,

00:50:45.040 --> 00:50:46.140
Real Racing.

00:50:46.360 --> 00:50:50.300
It was the first installment in
our Pro Circuit Racing franchise.

00:50:50.340 --> 00:50:53.260
We got an Apple Design Award for
this last year,

00:50:53.310 --> 00:50:56.300
and this was based on a
fixed-function rendering pipeline.

00:50:56.350 --> 00:50:59.340
We've since updated this
quite substantially.

00:50:59.390 --> 00:51:03.130
We have Real Racing 2 HD,
which I hope you've all played.

00:51:03.140 --> 00:51:05.620
This was specifically
updated for the iPad 2,

00:51:05.640 --> 00:51:09.600
and we really try to use the advanced
shader capabilities of the iPad

00:51:09.790 --> 00:51:12.110
2 to do some fantastic effects.

00:51:12.290 --> 00:51:15.900
We have per-pixel lighting,
anti-aliasing,

00:51:15.930 --> 00:51:18.260
and reflections on the cars, for example.

00:51:18.290 --> 00:51:20.830
Also,
the extra power of the iPad 2 allowed us

00:51:20.890 --> 00:51:25.390
to put about 10 to 20 times more geometry
in than we had in the first installment.

00:51:25.610 --> 00:51:28.220
There's also a very exciting
new feature of the iPad 2,

00:51:28.220 --> 00:51:30.540
of course,
that you should all know about by now,

00:51:30.630 --> 00:51:33.060
which is we have
external display support.

00:51:33.070 --> 00:51:37.270
I'd like to walk over here and
show you a bit of a demo of this.

00:51:37.840 --> 00:51:42.030
Okay, so we're starting the game
up here in connected mode.

00:51:42.040 --> 00:51:44.680
So we're actually displaying
the two screens at once.

00:51:44.680 --> 00:51:47.630
So I'm actually showing a bit
of a user interface right now

00:51:47.640 --> 00:51:49.480
as the user has shown the video.

00:51:49.480 --> 00:51:53.540
It was asking me to tap to continue,
which I did.

00:51:53.540 --> 00:51:57.130
And it's also important,
I think Josh mentioned this earlier,

00:51:57.130 --> 00:52:01.010
that you are always presenting user
interfaces on the iPad if you need

00:52:01.010 --> 00:52:03.220
the user to interact with the iPad.

00:52:03.220 --> 00:52:07.060
So you can see the game showing
there on the external display.

00:52:07.060 --> 00:52:11.170
I just want to show you some of the
effects we were able to do here.

00:52:11.430 --> 00:52:13.800
You can see a per pixel
lighting effect on the road,

00:52:13.800 --> 00:52:17.800
a per pixel lighting
effect on the car as well,

00:52:17.840 --> 00:52:20.820
and of course reflection there
of the scene that you're in.

00:52:20.820 --> 00:52:24.790
I'm going to take you into a race here
and show you some of the other great

00:52:24.820 --> 00:52:27.780
features of external display support.

00:52:28.120 --> 00:52:31.350
You could actually detach the
cable right now and play this

00:52:31.370 --> 00:52:34.470
in standalone mode as well,
and the game will switch.

00:52:34.530 --> 00:52:36.540
And you can plug it back in again.

00:52:36.870 --> 00:52:39.490
All right.

00:52:39.490 --> 00:52:39.490
So...

00:52:40.150 --> 00:52:44.020
The two screens allow you to
increase the level of immersion here.

00:52:44.040 --> 00:52:48.220
And I'm going to go inside the car
here just to show you what I mean.

00:52:48.400 --> 00:52:51.100
Now you see here, I'm turning the iPad 2.

00:52:51.100 --> 00:52:53.690
You can see the arms and
the steering wheel turn.

00:52:53.730 --> 00:52:56.350
This is actually increasing
my level of immersion because,

00:52:56.350 --> 00:53:00.250
well, if I was facing that way normally,
my eyeballs would be on the screen,

00:53:00.250 --> 00:53:00.760
right?

00:53:00.850 --> 00:53:03.210
So I'm not actually
distracted by the iPad,

00:53:03.210 --> 00:53:05.260
and I can really feel like I'm driving.

00:53:05.300 --> 00:53:09.700
Now we also display extra information
about the race on the iPad 2,

00:53:09.740 --> 00:53:12.780
just in case you are, you know,
maybe you're winning or something,

00:53:12.780 --> 00:53:15.690
and you have some time to look
at where the opponents are.

00:53:15.720 --> 00:53:18.720
I'm going to bring that up as soon
as I come around the corner here.

00:53:18.780 --> 00:53:21.850
Okay, I'm going to show it to you now,
what I see on the iPad.

00:53:21.920 --> 00:53:25.690
So you see this extra information here,
this race indicator, so where I am.

00:53:25.940 --> 00:53:28.590
That's the orange dot,
and we have the gray dots.

00:53:28.820 --> 00:53:31.460
That's the opponents.

00:53:31.510 --> 00:53:36.380
You can also see the position,
where I am, the laps, the speed, and,

00:53:36.380 --> 00:53:37.890
of course, the lap time.

00:53:37.960 --> 00:53:39.300
So I'm going to bring it back in here.

00:53:39.300 --> 00:53:40.770
- Right here.

00:53:40.990 --> 00:53:44.870
And, yeah,
I guess I just want to leave it there.

00:53:45.040 --> 00:53:48.600
I'll just tell you that, of course,
the API for this is very easy once

00:53:48.600 --> 00:53:52.480
you've got the wired connections
going because the wireless mode,

00:53:52.480 --> 00:53:54.690
as you saw yesterday,
works with exactly the same thing.

00:53:54.730 --> 00:54:01.220
So you just want to make sure that
you are supporting the notifications.

00:54:02.730 --> 00:54:05.500
That you're doing what
Josh told you to do?

00:54:05.590 --> 00:54:06.780
OK, so some tips and tricks.

00:54:06.970 --> 00:54:08.800
So follow Josh's advice.

00:54:08.820 --> 00:54:12.170
Make sure that you register for
the notifications and that you

00:54:12.170 --> 00:54:16.300
gracefully handle the display,
connect, and disconnect events.

00:54:16.300 --> 00:54:18.920
Now AirPlay,
as you see the new feature here,

00:54:18.930 --> 00:54:20.890
means that the user is going
to connect and disconnect

00:54:21.310 --> 00:54:23.390
when your app isn't active.

00:54:23.580 --> 00:54:26.890
You want to make sure that you
support that gracefully too.

00:54:27.400 --> 00:54:29.200
With the two displays,
you're going to have

00:54:29.370 --> 00:54:30.480
more screen real estate.

00:54:30.620 --> 00:54:33.400
So you want to make sure that
you are drawing appropriate

00:54:33.430 --> 00:54:34.850
content on each screen.

00:54:34.860 --> 00:54:38.290
As you can see in our game,
we were showing the action content

00:54:38.290 --> 00:54:42.250
up ahead where we were focusing
on the user having the attention.

00:54:42.250 --> 00:54:45.750
And then we gave you some extra
information on the actual iPad.

00:54:45.750 --> 00:54:49.740
So we gave the user more immersion
and more information because

00:54:49.740 --> 00:54:51.900
we had more screen real estate.

00:54:51.900 --> 00:54:56.060
Now an important part with a game
like ours is we're actually using

00:54:56.060 --> 00:54:58.390
the iPad 2 as a steering wheel.

00:54:58.390 --> 00:55:02.570
So you may get some orientation
notifications back and you need to make

00:55:02.570 --> 00:55:05.260
sure that you're handling them properly.

00:55:05.330 --> 00:55:09.050
The external display has to
obviously always be facing the

00:55:09.050 --> 00:55:13.420
right way and you don't want to get
the embarrassing situation of that

00:55:13.460 --> 00:55:15.680
turning as you turn the device.

00:55:16.550 --> 00:55:22.430
Josh mentioned there are many different
devices that you are going to connect to.

00:55:22.440 --> 00:55:26.020
You want to make sure that your game
is adequately prepared for this.

00:55:26.020 --> 00:55:28.960
I said before that the
API is really easy,

00:55:29.000 --> 00:55:31.750
and the hard part is making sure
that your game is actually up to it.

00:55:31.800 --> 00:55:34.160
Test on a variety of displays.

00:55:34.160 --> 00:55:35.440
They're going to have
different properties.

00:55:35.440 --> 00:55:37.810
They're going to have
different aspect ratios,

00:55:37.810 --> 00:55:40.670
different resolutions,
and you want to make sure that

00:55:40.670 --> 00:55:41.970
you're scaling your content to it.

00:55:42.760 --> 00:55:44.880
There's also a secondary
consideration there,

00:55:44.880 --> 00:55:48.360
which is the impact on performance
or perhaps on the effects you

00:55:48.360 --> 00:55:49.370
had prepared in your game.

00:55:49.380 --> 00:55:52.940
You may have prepared an effect that's
perfect for a certain screen resolution,

00:55:52.940 --> 00:55:56.640
let's say the iPad's internal display,
and that effect might not

00:55:56.640 --> 00:55:59.220
work so well at 1080p perhaps.

00:55:59.320 --> 00:56:02.290
So you might want to make sure
that you have a switchable effect

00:56:02.300 --> 00:56:05.330
in there that looks great on
each and every configuration

00:56:05.430 --> 00:56:07.130
that the user might connect to.

00:56:07.140 --> 00:56:09.580
Okay, thank you very much.

00:56:15.600 --> 00:56:18.000
Thanks, Jacques.

00:56:18.010 --> 00:56:21.880
Now, we've given you a lot of
information about AirPlay today

00:56:21.880 --> 00:56:25.760
and also Second Display,
but really encourage you

00:56:25.760 --> 00:56:27.820
to go install the SDK.

00:56:28.260 --> 00:56:33.190
Both your iPad and also your Apple TV.

00:56:33.190 --> 00:56:35.680
And explore AirPlay.

00:56:36.760 --> 00:56:40.360
Take a look at how AirPlay audio behaves,
AirPlay video behaves,

00:56:40.450 --> 00:56:41.730
and AirPlay screen.

00:56:41.770 --> 00:56:44.100
Make sure your app works well in
this environment because you want

00:56:44.100 --> 00:56:45.340
to work well in this ecosystem.

00:56:48.420 --> 00:56:50.690
Additionally,
we've given you a whole bunch

00:56:50.780 --> 00:56:53.880
of new stuff to help you
make your apps even better,

00:56:54.150 --> 00:56:55.540
especially in iOS 5.

00:56:55.590 --> 00:56:58.130
Take advantage,
like the overscan compensation

00:56:58.140 --> 00:57:04.200
that Josh mentioned,
the MP Now Playing Center info center to

00:57:04.210 --> 00:57:06.420
really fill out your media playback apps.

00:57:10.860 --> 00:57:13.000
And finally,
really look at taking advantage

00:57:13.060 --> 00:57:15.360
of the second display.

00:57:15.430 --> 00:57:19.500
The ability to add a second screen,
especially a large one,

00:57:19.540 --> 00:57:22.910
can really change the experience.

00:57:23.000 --> 00:57:26.860
For instance, people that know me
know I'm not a game guy.

00:57:27.920 --> 00:57:30.520
Played Real Racing, you know,
just on the iPad, and that was fine.

00:57:30.520 --> 00:57:31.600
That's nice.

00:57:31.600 --> 00:57:37.090
But then you hook it up to a TV,
a big TV, and it just totally

00:57:37.090 --> 00:57:39.610
changes the experience.

00:57:39.680 --> 00:57:42.560
It's really immersive, and it's great.

00:57:42.570 --> 00:57:45.140
And it's actually really fun to play,
even for me.

00:57:45.170 --> 00:57:50.390
So think about that.

00:57:50.800 --> 00:57:53.420
Take the opportunity
to look at your apps.

00:57:53.460 --> 00:57:56.430
There might be some unique
things you can do in that space.

00:57:56.800 --> 00:58:00.960
The ability to use a second
display to expand the experience

00:58:01.120 --> 00:58:03.810
of your app for your users.

00:58:06.230 --> 00:58:10.750
So for more information,
various people to contact,

00:58:10.750 --> 00:58:14.290
Alan Shafer and Eric Verschen.

00:58:15.350 --> 00:58:17.180
Customer-related sessions.

00:58:17.180 --> 00:58:18.960
The first two,
Audio Development for Games and

00:58:18.960 --> 00:58:22.140
Exploring AV Foundation,
have already occurred.

00:58:23.230 --> 00:58:27.000
If you didn't check them out here,
check them out when you get back.

00:58:27.050 --> 00:58:30.650
Coming up later today,
HTTP live streaming update.

00:58:31.260 --> 00:58:34.700
There's also the Advanced HTML5
Media Controllers in Safari.

00:58:34.700 --> 00:58:37.640
Talks about the web pages and the
various tags and how to use that.

00:58:37.700 --> 00:58:41.530
Audio Session Management on iOS.

00:58:41.530 --> 00:58:44.190
So you can find out all about
audio sessions and get the right

00:58:44.350 --> 00:58:45.760
audio behavior from your apps.

00:58:45.880 --> 00:58:49.940
And if you're writing games
or doing any kind of OpenGL,

00:58:49.960 --> 00:58:54.100
check out Best Practices
for OpenGL ES apps for iOS.

00:58:54.100 --> 00:58:57.200
You're going to get a whole
bunch of great tips there.

00:58:58.480 --> 00:58:59.860
OK, that's it.

00:59:00.200 --> 00:59:00.840
Thanks.

00:59:00.910 --> 00:59:01.510
Thanks for coming.

00:59:01.570 --> 00:59:03.350
Hope you enjoyed it.
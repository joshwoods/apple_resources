# Wwdc2020 10661

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

What’s new with in-app purchaseCreate a great in-app purchase experience for your iPhone, iPad, Mac, and Apple Watch apps. Discover how to handle refunds, integrate new App Store server notifications, and find out how to use receipts and server notifications to manage subscriber status. We'll also walk you through the latest updates in StoreKit, including in-app purchases on Apple Watch, Family Sharing, SKOverlay, SKAdNetwork, and more.ResourcesApp Store Server NotificationsAuto-renewable subscriptions overviewChoosing the right functionality for your App ClipEnabling App Store Server NotificationsHandling refund notificationsHandling Subscriptions BillingIn-App PurchaseLearn more about App Store ConnectSetting up promotional offersStoreKitValidating Receipts with the App StoreHD VideoSD VideoRelated VideosTech TalksExplore Family Sharing for In-App PurchasesWWDC21Manage in-app purchases on your serverMeet StoreKit 2Support customers and handle refundsWWDC20Architecting for subscriptionsBuild trust through better privacyIntroducing StoreKit Testing in XcodeStreamline your App ClipWWDC19In-App Purchases and Using Server-to-Server NotificationsSubscription Offers Best Practices

Create a great in-app purchase experience for your iPhone, iPad, Mac, and Apple Watch apps. Discover how to handle refunds, integrate new App Store server notifications, and find out how to use receipts and server notifications to manage subscriber status. We'll also walk you through the latest updates in StoreKit, including in-app purchases on Apple Watch, Family Sharing, SKOverlay, SKAdNetwork, and more.

App Store Server Notifications

Auto-renewable subscriptions overview

Choosing the right functionality for your App Clip

Enabling App Store Server Notifications

Handling refund notifications

Handling Subscriptions Billing

In-App Purchase

Learn more about App Store Connect

Setting up promotional offers

StoreKit

Validating Receipts with the App Store

HD VideoSD Video

HD Video

SD Video

Explore Family Sharing for In-App Purchases

Manage in-app purchases on your server

Meet StoreKit 2

Support customers and handle refunds

Architecting for subscriptions

Build trust through better privacy

Introducing StoreKit Testing in Xcode

Streamline your App Clip

In-App Purchases and Using Server-to-Server Notifications

Subscription Offers Best Practices

Search this video…Hello and welcome to WWDC. Hello and welcome to WWDC. I'm Tori,and I'll also be presenting with my colleague Ross who you'll hear fromlater today. I'm so excited to share with you what we have new for youwith in-app purchases. And we have a lot to cover today.This session will be divided into two sections. I'll focus on covering what'snew on the server side. And later I'll hand it off to Ross to cover StoreKit updates.So let's get started with our server updates. On the server side,first we'll cover refunds and how you can handle transactions that are refunded.Next we'll cover some new ways to help you manage the subscription statusfor your customers and how you can use App Store server notifications toget notified and respond to various subscription billing events.We'll also cover the different scenarios where you may still need to use verifyreceipt to get the latest status. And finally we'll dive into Family Sharing.We have a lot to cover so let's dive right in with arguably what broughtus all here today, an in-app purchase. So this is an in-app purchase inone of my apps. I'm so excited to use this. But what happens if I changemy mind, if I have an issue with the content and call Apple to request a refund,what should you as a developer do? That's why handling refunds is so important.But keep in mind that while it's important it only affects a small percentageof transactions. However proper refund management could drive that percentage down.So let's dive into that now by walking through a typical refund scenario.First a customer purchases some content in an app like 100 Gems.However the purchase was an accident so they call Apple for support. After consideringtheir case we issue a refund. Later the customer contacts you for supportas they notice they still have the gems that were refunded. If you don'tknow that Apple has refunded the content it's difficult to determine howto respond. It would be so much better if you could easily determine ifwe had already refunded that purchase so you could take action appropriately.Such as acknowledging the refund but letting the customer keep their gemsor deducting their balance. That's why we're working to bring you new waysto manage refunds for your content. Having the ability to manage your refundedpurchases is important for many reasons. Most importantly it gives youcontrol to take action as you see fit. Such as messaging the customer oreven taking back the content if needed. It also lets you handle any potentialabuse of your content such as customers trying to keep their content afterreceiving a refund from Apple. And you can resolve customer issues likethe previous one swiftly. This will also allow you to manage your in-gameeconomy, making game play more fair for all players as there will be repercussionsfor refunds. So for all of these reasons and because we want you to beable to manage refunds for purchases in your app we're bringing you a brandnew App Store server notification and our first ever notification for contenttypes other than auto renewable subscriptions. The Refund notification.So why did we decide on an App Store server notification for this.Well the primary reason is that you don't have to ask us for information.We'll just tell you. You're notified immediately with a JSON post upon a statuschange and we even retry up to three times if we don't get an HTTPOK back from you. If you're already receiving App Store server notificationsfor auto-renewing subscriptions then you'll get the new refund notificationfor your other content types with little additional work on your end.We'll also send you an updated unified receipt with your canceled transactionsincluded so you can update your records. And this solution is also scalableas you grow your business on our platform. So our goal for all contenttypes is to allow you to obtain information about refunded purchases throughApp Store server notifications. For consumables, non-consumables andnon-renewing subscriptions you'll receive the brand new refund notification.For subscriptions, you'll continue to receive the cancel notification.enabling App Store server notifications is straightforward if you've neverdone it before and can be done in a few steps. First set up your desiredend point for your notifications and App Store Connect. Next make sureyour End Point meets app transport security requirements as outlined inthe developer documentation. Then you're all set to start receiving notifications.So in App Store Connect, just navigate to your apps page and find theURL for App Store server notifications section. Enter your desiredend point here so we know where to send your notifications. Know that ifyour end point already meets security requirements you'll immediately startreceiving notifications. Now let's take a deeper look at the refund notification.We'll send you this notification when any consumable, non-consumable ornon-renewing subscription is refunded for your app, after we issue a refundto the customer for that purchase. Getting notified in this way makes iteasy for you to take immediate action on your refunded content. This notificationhas also been implemented in a privacy friendly way as we're not givingyou any information about the customer only information you'd already haveabout the purchase. The refund notification is live today so if you'realready receiving App Store server notifications make sure you're lookingfor it. With that in mind when you receive this notification there area few things I want you to look out for in the payload. You should lookfor the original_transaction_id to tell you which transaction we've refunded.The cancellation date to know when we refunded it and the cancellation reason.The reason can have values of zero or one and a value of one can indicatethe customer requested a refund due to an issue within the app which youcould then investigate. Also look for the bid, and the product_idto verify the app and product you've received a notification for. All thesefields can be found in the unified_receipt object in the App Store servernotification payload and the latest_receipt_info section. Except for thebid which is found at the top level of the payload. So what does the AppStore server notification look like. Well it looks something like this.Not all the fields are listed here but we have explanations for all possiblefields in the developer documentation. Right now let's take a look at theones we just discussed plus a few others. In addition to those transactionidentifying fields, look for the password and the payload. This is a sharedsecret for your app which you can find an App Store Connect and it allowsyou to verify the payload is from Apple and is trustworthy. At the samelevel as the password you'll find the bundle identifier. You can verifythis field to know which app you've received a refund for. Next look inthe unified_receipt object specifically in the latest_receipt_info array forinformation about your refund transactions. This array contains the 100latest transactions for your app and the four fields we told you to lookfor, the cancellation date, the cancellation reason, the original transactionID and the product ID. So let's revisit our refund scenario from earlierand look at how the refund notification can now help you in a slightlydifferent situation. In this situation the customer still buys 100gems but then consumes the gems and still asks Apple for support with their purchase.Once again we make a decision to honor or deny the refund because we don'tknow if the customer has consumed the gems. We may still honor the refundand if we do we'll send you a refund notification. Then if the customerreaches out to you asking for further support such as in-game compensation.But now you'll know the purchase has been refunded and you can choose totake proactive action such as providing an in-app message in your app. A messagesuch as this is great as it notifies the customer that you've observeda refund for their purchase. The action you've taken and what they cando to regain access to their content. In-app messaging is just one of manyactions you can take upon observing a refund. Let's take a quick lookat those now. So there are many actions you can take depending on the contenttype ranging from moderate to severe. For all content types, you can usethis for refund monitoring. For in-app messaging and restricting accessto the refunded purchase. Because we're sending you a server to server notification,this gives you the ability to restrict access cross-platform if needed.In the case of consumables there are additional actions you can take likededucting the in-app currency balance. You as a developer are responsible formaking decisions on what measures to take and how to implement them.So think carefully about which action you decide to take in order to promotea healthy community within your app. So now we've covered a lot about refundsand how to handle them appropriately. So now let's switch gears and jumpinto how we're making it easier for you to manage your subscriptions.First taking a look at some of the key events in the subscription lifecycle.These include acquiring a subscriber for the first time, any auto-renewsuccessful or unsuccessful, disabling or enabling auto-renew upgrades ordowngrades and cancellations. So what do all these events look like fora customer and for you. So when the customer first subscribes we establishthe subscription period and a fixed auto-renew period to repeat renewalafter renewal. Within the first subscription period, your customer decidesto turn off auto-renew thinking that they just aren't using the subscriptionenough, but later turns it back on after a little more time with their subscription.After that we approach our first scheduled auto-renew. But there is anauto-renew failure due to a billing issue. At this point, we'll try to autorenew for the duration of the billing retry period. Also establishing agrace period. Luckily the subscription is recovered during our grace periodso the renewal cycle remains the same. Shortly thereafter your customerdecides they are enjoying their subscription so much that they want toupgrade. For an upgrade we start the customer at the higher tier immediately,shifting our upcoming renewals. Later after not using that higher tieras much as expected your customer decides to downgrade back to a more basic tier.Downgrades take place at the end of the subscription period. So your customerwill have access to the higher tier of service until their next scheduledauto-renew. So how can you keep track of all of these important eventsfor your subscriptions. What we recommend is using App Store server notificationsfor status updates. This is a push approach, meaning you don't ask us forinformation we'll just tell you when something happens. And we do. We notifyyou when the status of one of your subscriptions changes providing youwith a new receipt for your records at that time but only when you need it.This solution is also more scalable as you require more subscribers.So let's dive into our App Store server notifications now to see what we offerand to learn a little bit more about them. When you start receiving App Storeserver notifications or if you already are. This is the payload you canexpect to see. Note that this is a subset of possible fields and not allof these may be present all the time. There's a lot of information here,so I want to focus on some of the key components. When you received thispayload first look for the auto_renew_product_id to see exactly whichproduct the notification applies to and the product we plan to auto-renew next.Then check the notification_type. This will tell you the type of eventyou are receiving. You should also verify the value and the password fieldmatches your shared secret. So you know the content comes directly fromApple and is trustworthy. You should also look for the bundle identifier.This will tell you which of your apps you've received a notification for.Then you want to look for the unified_receipt, this object mimics the responsefrom verify receipt, so if you're already using verify receipt this shouldbe familiar. The latest_receipt in the unified_receipt object gives you anupdated accuracy for this customer for your app. The latest_receipt_infoarray contains the 100 latest transactions for your app. You can searchhere by the original transaction id to know which subscriptions are activefor this customer. Finally look at the pending_renewal_info arrayto find the upcoming renewal info for each subscription the customer usesin your app. Now let's quickly revisit the notification type field.We'll send you notifications for several events and the notification type fieldcan have the following possible values. INITIAL_BUY when a customer firstsubscribes. INTERACTIVE_RENEWAL when a customer upgrades or renews theirsubscription in your app or through managed subscriptions. DID_CHANGE_RENEWAL_STAUSwhen a customer changes their renewal status such as togglingauto-renew on or off. DID_CHANGE_RENEWAL_PREF when a customer makesa change that takes place at the end of the subscription period such asa downgrade. CANCEL when a customer calls Apple support and we issue arefund to them for their subscription or for an upgrade as we cancel theprevious lower tier subscription. DID_FAIL_TO_RENEW when we failed to auto-renewas scheduled due to a billing issue. And DID_RECOVER, when we recoverbilling of the subscription in the billing retry period or grace period.For more information on these notifications and when you can expect toobserve them see our WWDC 2019 session "In-App Purchasesand Using Server-to-Server Notifications". And to learn more about whichnotifications are available to you in sandbox. Check out this year's session"Introducing StoreKit Testing in Xcode". So if we go back to our timelinefrom earlier we have notifications to cover almost all of these events.Initial buy for the purchase of the subscription did change renewal statusfor disabling and enabling auto-renew did fail to renew for the renewalfailure did recover for the billing recovery, interactive renewal for theupgrade plus a cancel for the previous lower tier subscription and didchange renewal preferences for the downgrade. So with App Store servernotifications you can easily monitor your subscription events. But we decidedwe could make this just a little bit better. Which is why this year we'rebringing you an App Store server notification for every successful auto-renew.This is a new notification type which we're calling DID_RENEW. Coming laterthis year, we'll send you this notification after every single successfulauto-renew, every time. Like all the other notifications it contains theunified receipt which gives you all the information you need to identifythe subscription that was renewed. This includes the original transactionid, which is a unique identifier for the subscription. The transactionid, a unique identifier for the new subscription period. The expirationdate of the new period and the auto-renew product id to tell you exactly whichproduct was auto-renewed. So jumping back to our timeline. Notice thatthe addition of the did renew notification completes our events, bringing youeverything you need to monitor your subscriptions in App Store server notifications.However, in addition to this new notification we thought there was a little moreinformation you might need concerning your subscriptions. We think youshould know if one of your customers has decided to apply a subscriptionoffer before we renew the subscription with that offer. That's why we'veadded the promotional offer id to the pending renewal info section.This will be available through your verify receipt and in the App Store server notificationand the pending renewal info array so you'll know if there are anypending offers for that subscription. This feature is live in the pendingrenewal info section today. So be sure you're looking for it. For moreinformation on using subscription offers. See our WWDC 2019session "Subscription Offers Best Practices". So now that we have a did renewnotification and the promotional offer id in the pending renewal info,what should you do with this new information? Most importantly this allowsyou to rely on App Store server notifications for updates, eliminating theneed to poll verify receipt. However you should still use verify receipt fora few key use cases. If you experience an outage on your server the nexttime one of your customers comes online you can call verify receipt tocheck their status. Making up for any missed updates. In this way verifyreceipt offers of recovery mode. Second you can use verify receipt toimmediately determine entitlements for a customer. To learn more aboutdetermining entitlements, tune into this year's architecting for a subscription session.Finally you can use verify receipt to verify a successful auto-renew.So what do we mean by using verified receipt to verify a successful auto-renew.Because auto-renew is so critical. You want to ensure that you get the update.For this reason approach marking an auto-renew through a double check.First subscribe to our App Store server notifications so you receive therenew notification in addition to our other notification types.Second schedule a call to verify receipt for your subscription shortly after itsscheduled expiration date. When you received the did renew notificationas expected you can cancel this job, but if there is a delay you can fallback to verify receipt to verify a successful auto-renew. So we just covereda lot about App Store service notifications and subscriptions. Now I'dlike to discuss a new feature for App Store subscriptions. One of the thingscustomers love most about subscriptions like News Plus or Apple Arcadeis that they can be shared with their family members. Well we're very excitedto announce that this year the app store will support Family Sharing forin-app purchases, which will allow up to five additional family membersto share a single purchase. Family Sharing works for both auto-renewalsubscriptions and non-consumable in-app purchases like those that are usedto offer a full feature unlock. Customers will choose which in-app purchasesthey'd like to share with their family. We're so excited about what thismeans for developers and your ability to engage millions of family membersthat are already set up. Because the use of family is so widely adopted,Family Sharing for in-app purchases can help increase customer engagementand improve retention for your app. To begin, you can visit App Store Connectto turn on Family Sharing for a specific product. You can navigate to yourapps page and select 'Turn On' in the Family Sharing section. Note that onceyou turn on Family Sharing for a product you cannot turn it off.Let's review how customers will manage their shared purchases. When new customerssubscribe, the subscription will be shared by default. Subscribers can turnoff sharing later for their family on the managed subscriptions page. Forexisting purchasers, they'll be notified if one of their subscriptionsbecomes shareable. Then they can manage their sharing preference from thesame managed subscriptions page. For non-consumables all purchases willbe shared with the family, if the customer has turned on 'Share Purchaseswith Family' in Settings. So what do you need to do in your app. So familymembers can enjoy access to the shared purchase. With this feature notonly are we creating a transaction for the purchaser we're also creatinga transaction for each family member. So when a family member opens theapp they will have a transaction available in the transaction queue foreach of their devices and there will be a unique receipt for each familymember that will contain shared transactions in the latest receipt info array.You should keep track of the original transaction id for each family memberas you already would for your subscriptions. Note that this only appliesto new purchases made after sharing is enabled. For non-consumable purchasesmade before sharing was enabled, you'll still have to restore purchasesfor these to be available to all family members. So let's get an idea ofwhat this looks like for new purchasers. After you've enabled Family SharingIn App Store Connect, when a family member makes a shareable purchase notonly do we put a transaction in the transaction queue for their deviceswe also put a transaction in the transaction queue for every member oftheir family, for all of their devices. So when their family members openup your app later you can unlock access to the subscription or non-consumable instantly.It's like magic. And it makes it so easy for you to reach more developersthan ever before. Before moving on let's quickly review what this lookslike for both new and existing subscribers for both subscriptions and non-consumables.So for new purchasers any shareable subscription they purchase is sharedwith their family by default. Any shareable non-consumable they purchaseis shared with their family, if they have purchase sharing enabled iniCloud. If the family is sharing payment and if the app is not hiddenfrom their purchase history. For existing purchasers for a shareable subscriptionto be shared with their family they must opt in from the managed subscriptionspage. For existing non-consumables to be shared, the same three conditionsmust be met and you have to restore purchases to unlock the content forthe family member. To manage access for all family members you'll needto use the receipt. You can get an updated receipt from verify receipt orfrom App Store server notifications. Additionally whenever the customeropens the app you can refresh the receipt on device to verify access foreach customer. But I'm getting ahead of myself here. So with that I'llhand off to my colleague Ross who who'll talk to you more about FamilySharing within StoreKit.Thanks Tori. So let's take a look at how Family Sharing in-app purchasesworks within your app. First off how can your app tell if a product supportsFamily Sharing. Well we've added a handy new property on SKProduct calledisFamilySharable. It's as easy to use as requesting your product informationfrom the App Store and then checking this isFamilySharable boolean.You can use this to programmatically display to customers that one of yourproducts is family shareable and not have to hard code any logic. So nowone of your customers has seen this family sharable product and taps topurchase it. What happens next? Well when a customer purchases a familyshareable in-app purchase everything begins as normal. Your app uses StoreKit tosend the purchase to the App Store and then you get a transaction backin the purchase date. The next time their family members open your appeach of the family members will get a transaction that looks just likea restored purchase, so your existing app logic should be able to handleit with no additional coding. Now Tori mentioned that customers can alsoenable and disable sharing for specific products. When a customer enablesFamily Sharing for a product something similar to a purchase happens. Theirfamily devices will all get a transaction that looks just like a restored purchase.So again your app should be able to handle it with no additional coding.What about the opposite case. What about when a customer disables Family Sharing.Well normally non-consumables are permanent and auto-renewal subscriptionsonly end when they expire. But when a customer disables Family Sharingthey expect access to be halted immediately. So for this case we've addeda new API.It's a new method on the SKPaymentTransactionObserver protocol calledpaymentQueue(didRevokeEntitlementsForProductIdentifiers:) When a customer disablesFamily Sharing StoreKit will automatically update your receipt and thencall this method. Inside the method you should be prepared to verify thereceipt whether locally or by uploading it to your server and using theverify receipt endpoint.Products that have been revoked will no longer be present in the receipt.Now you should make sure that you're not simply looking at the productidentifiers in the array and revoking access based on that. Depending onthe setup of your products and other products the customer may have purchasedthey may still be entitled to some access that overlap the revoked purchase.So we added this API to handle a couple of new situations that occur dueto Family Sharing. As I mentioned it will be called when a purchaser disablesFamily Sharing for a product. It will also be called if a customer leavesa family group that was sharing the purchase. And we've also taken thisopportunity to add support for refunds. If a customer receives a refundfor a non-consumable or an auto-renewable subscription, StoreKit will callthis method and you may revoke access immediate. And that wraps up FamilySharing which we think users will love. And we'll give you new opportunitiesto increase value to your customers and improve engagement and retention.Now I'm going to give you a tour of some of the other improvements andfeatures we've added to StoreKit, and what to look forward to in the latest releases.First I'll throw out a couple of things we already shipped since WWDClast year. We have in-app purchase on Apple Watch and improved storesubscription price increase flow. Then I'll move on to what's new includingSKOverlay and improvements to SKAdNetwork. So this first one is especiallyfor all you Apple Watch developers out there. As of watchOS 6.2earlier this year we've added StoreKit and in-app purchases to watchOS. This meansthat for apps your customers use mostly on the watch. You can offer in-apppurchases directly in the watchOS interface your customers are already using.Using StoreKit on watchOS is almost exactly the same as using it on any other platform.You can observe the payment queue, request products, and add them to the paymentqueue the same as you do on other platforms. When it comes to verifyingthe receipt you can of course continue to use server to server validation.However if you prefer to do local validation there is just one differenceyou should be aware of. When you're retrieving the device identifier, insteadof using UIDevice, you need to use the WKInterfaceDevice API.Here's an example of some code that runs on both iOS and watchOS. Once you'veretrieved the device identifier everything else is the same. Use that deviceidentifier along with your PAKE value in the receipt to create a hash.Then make sure that hash matches the one in the receipt.And that's all you need to know to add in-app purchases to your watchOS app.Another feature we rolled out in iOS 13.3 is an improvementto handling subscription price increases. A subscription price increaseoccurs when you have an existing subscription product you want to charge more for.Setting up for price increases is easy. Just go into App Store Connect and changethe price, but you can't just bump up the price of an auto-renewal subscriptionwithout telling your customers. That's why the App Store requires eachcustomer to agree to the new price. You should know that if you decreasethe price of the subscription customers don't have to take any action andlook at the new price automatically. Now unfortunately this process ofinforming the customer and asking them to agree to the new price can resultin churn. Churn is when customers stop using your product and are no longerpaying for it. And now you're thinking well of course customers don't wantto pay more. But actually found in a lot of cases that's not the issue.Customers can sometimes miss the e-mails that the App Store sends. Or perhapsthey don't want or engage in the price increase flow at that time.And sometimes they put it off until later and simply forget.Additionally customers might not be informed of additional value that you're providing.For example if you run a video service and you've added new content. Sofor users experiencing a price increase who are using your app, we've implementedan automatic in-app price increase consent sheet. After you initiate aprice increase in App Store Connect any affected customers will see this App StoreUI when opening your app. This way customers are informed and can agreeto continue their subscription, at the time they're using the app, whichpresumably means they're finding value in your products. Once they agreeor dismiss the sheet your apps UI is underneath it and continues as normal.Now we realize that not all apps will want to display the sheet immediatelyupon opening, so we've added some tools to allow you to control the flow.First you'll want to implement this new SKPaymentQueue delegate method.StoreKit will always call this method before presenting the price consent sheet.Inside the method, its up to you to determine if you want to show a sheetnow and then return true if you do, and false if you don't.Now if you return false here you're going to want a way to show the sheetlater at a time that's more opportune. Perhaps after you've educated thecustomer about additional value you're providing.To do that simply call this other new StoreKit API. SKPaymentQueue.showPriceConsentIfNeededNow you should only call this if you've previouslyreturned false to the method above. However if you do call it and there'sno pending price increase don't worry. StoreKit will always check tomake sure there is a pending price increase for the customer before showingthe sheet and it won't show it at all if there isn't. Next I'm happy tointroduce an entirely new API in the latest iOS release. It's called SKOverlayand it's a sleek new UI element for displaying and promoting apps.Take a look. SKOverlay presents a floating view at the bottom of yourUI that displays information about an app. It's similar to the SKStoreProductViewControllerclass that exists In StoreKit today, except SKOverlaywas designed to work seamlessly with your apps UI. Additionally unlikeSKStoreProductViewController, SKOverlay is only used to display apps.SKOverlay was also designed to work seamlessly with your app clips inorder to help you transition users From your app clip to your full app.But that's not all it's used for. You're entirely able to use it within yourfull apps as well. Simply enter the app id of the app you want to displayand customers can install it directly from the overlay. If you're interestedin learning more about our new app clips feature, I highly recommend checkingout the "Exploring App Clips" session as well as the "Streamline Your App Clip Experience"session both in this year's WWDC. So now let's dive into the SKOverlayAPIs and see how you can best integrate SKOverlay into your app.Creating and presenting an SKOverlay is fairly straightforward. First you initializeit using an SKOverlay configuration object. We'll get back into that configurationobject later but it essentially allows you to set up the details of the overlay.Then you call the present method passing in the window scene where youwant the overlay to appear. That's all you need to do to create and present anSKOverlay. Of course we've also added lots of other tools to allow youto customize the overlay flow. First there's a dismiss function that allowsyou to manually dismiss the overlay. You'll notice that this dismissalfunction is a class function and it doesn't take an overlay as an argumentbut rather another UIWindowScene. That's because only one overlay canbe displayed in a scene at a time and doing it this way allows you to removeany overlays that may be on a scene even if your current code context doesn'thave access to the specific overlay object. SKOverlay also has a delegate.As you'd expect this delegate allows you to react to changes in the overlay status.We'll see the details of that later. And finally SKOverlay has a configuration object.This allows you to see the configuration that was used to set it up.Now that we've come back around to the configuration, let's take a look at thosetwo objects. SKOverlay is actually comprised of two classes. The firstis called AppClipConfiguration and this configuration is used to transitionusers from your app clip to your full app. The AppClipConfiguration can onlydisplay the full app for the current app clip the overlays displayed in.The next class is the AppConfiguration. And this configuration can beused to display any app. Much of these two classes is the same. So let's start there.Both classes have a campaign token and a provider token so that you canuse SKOverlay with app analytics. They also have functions that allowyou to set and get arbitrary key values. Now most developers don't needto use these but they're there so you can integrate SKOverlay with otherStoreKit APIS such as SKAdNetwork.Both classes also have a position property. While SKOverlay always appearsat the bottom of your screen apps that use tab bars will want to choosethe bottomRaised property so that the overlay appears just above the tabbar rather than on top of it. In addition to these properties and functionsthe app configuration also offers two additional properties on top of these.First is the app identifier. You can use this to enter the iTunes identifierof the app you wish to display. The AppClipConfiguration doesn't havethis property because as I mentioned before that configuration is onlyused for displaying the full app of the current app clip the overlay is in.And the app configuration also has a user dismissible boolean. This is set to trueby default which means that the user will be able to swipe down on theoverlay to dismiss it from the screen. If you set this to false the userwill not be able to swipe down on it. And the overlay will only go awaywhen you call the dismiss function manually. That's it for the configuration.So let's move on to the delegate. The first delegate method is simply anerror handler. If you try to present an overlay and an unexpected erroroccurs it'll call this delegate method passing in the overlay and the specificerror as an argument. The rest of the delegate methods are all revolvingaround animating of the overlay. You can see there's a method for thestart and end of the presentation as well as the start and end of the dismissal.You can also see that each of these methods includes an SKOverlayTransitionContext object. That's because these methods are used to helpcoordinate your UI animations alongside the overlay. Let's walk throughhow you might present an overlay and use these APIs to coordinate animations.Here we're creating and presenting an SKOverlay inside our app clip.First we grab the current window scene and then we create an app clip configurationusing the bottom position. We'll then initialize an overlay using that configurationobject and we'll set its delegate. Finally, we present the overlay in that scene.And this is all you need to do to use SKOverlay in your app or app clip.If we want to animate our own UI alongside the overlay. We can do so usingthe delegate methods. First we can set up any initial state for our UIelements directly inside the delegate method. These delegate methods arealways called in the main queue so you can manipulate UI right inside them.Then we add any animations we want inside an animation block on the transition context.Again simply declare any changes in animatable properties here. There isno need to use a UI view animate block, since any code inside this block willbe animated for you by the overlay. Whether you're optimizing your app clipor promoting other apps inside your own app. SKOverlay is a greatoption for seamless integration and beautiful UI. Finally I'd like to sharewith you some updates about ourSKAdNetwork API. Introduced in iOS 11.3, SKAdNetworkallows ad networks to measure the effectiveness of their ads while stillrespecting customer privacy. In the latest iOS release we've made iteven more powerful while still not compromising on customer privacy.Let's start with an overview of SKAdNetwork. SKAdNetwork involvesthree stakeholders. Ad networks, source apps and advertising apps. Each stakeholderhas a role in making the feature work. Ad networks place ads within apps andreceive postbacks when ads results in conversions. Source apps displaythe ads that are sent to them by the ad networks. And advertising appsare the ones that appear in the ads and then submit the post back toSKAdNetwork once they're opened. Let's take a closer look at this flow fromstart to finish. First the ad network places the SKAdNetwork data insidean ad for the advertising app, which we'll call App B. Then it displays this adin the source app, which we can call App A. Once the user taps the ad, installsApp B and opens it, App B should call another SKAdNetwork API in orderto initialize the postback. Calling this API will set a timer. And oncethat timer expires the user's device will send the postback to the adnetworks URL. Ad networks should use Apple's public key to verifythe data in the postback and make sure it's legitimate. So that first bundleof data that the ad network sends up when displaying an ad looks like this.And contains the Ad network id, which has been registered with Apple and theCampaign ID from 1 to 100 which ad networks can use to measure their campaign effectiveness.It contains the id of the advertising app, the one that's displayed inthe ad. And it has a timestamp. This timestamps should be generated atthe time the ad is displayed because timestamps that are too old will causethe ad data to be rejected. The nonce is just a random UUID used to ensurethat each ad impression is unique and to prevent double counting. And finallythe signature is generated using all of the other pieces of data in thisbundle to ensure that only your ad network can start ads using your ad network id.In the latest iOS release we're requiring two new pieces of data.The first is the version which is now 2.0. And the second is the source app id.This is the id of the app thats displaying the ad. Next the postback APIshould be called by the advertising app, App B, upon the first launch oftheir app. This method generates a postback which is the cryptographicallysigned data validating that a user installed and launched this app afterseeing the ad. The first call to this API starts the postback process,if the device has attribution data for the app, and subsequent calls have noeffect. Starting in the latest iOS advertising apps will be able to callthe updateConversionValue API if they choose. This allows the app toadd an additional 6-bit value that represents some action that took placein the app. For example let's say you want to know whether a user purchasedan item in your app before you count the conversion. In this case you cancall updateConversionValue and include a value that you mapped purchasingan item. Since the conversion value is chosen at runtime we can't signit on the App Store server. So it's the only piece of the postback thatisn't protected with cryptography. The value itself as an integer between0 and 63, which may represent actions such as making a purchase,signing up for a free trial, or completing a level. Apps can call this APImultiple times to update the conversion value. However only values thatare higher than the previous value will be accepted. Values that are lowerthan the currently stored value will simply be ignored. This means you don'thave to worry about accidentally over writing your conversion value witha lower value. Now let's see the details of the postback that StoreKit sendsto the ad network once the process is complete. We'll send up the ad network idand the campaign id that were used in the ad, as well as the id of theadvertising app, App B. The transaction id is another unique identifier youcan use to make sure you aren't double counting conversions. And you canuse Apple's public key to verify the signature to know that it's all legitimate.In the latest iOS we've added new information to the postback too. First weadded the version. We've also added a key called redownload which willindicate whether this was the first time the customer purchased the appor if they'd previously purchased it and are installing it again.Prior to this SKAdNetwork only worked for the first purchase of an app.So adding re-downloads will give you a lot more insight into the effectivenessof your ads. Furthermore in the latest iOS we've added two new optionalitems to the postback. The first is the idea of the source app so thatyou can know which app displayed the ad that resulted in the conversion.And the second is the conversion value that was chosen by the advertising app.It's important to note that these last two pieces of data won't alwaysshow up in the postback. In order to preserve customer privacy the AppStore servers do calculations to make sure that sharing these values won'tallow the post back to be linked to the customer that generated it.So we'll share them when we can. But your server should be ready to handlethe postbacks both with and without them. So how do you get started.If you're interested in using SKAdNetwork as an ad network you'll needto sign up with Apple so we can register your information. You shouldenroll in the developer program as an organization and then fill out the formto request access to SKAdNetwork.Well then send you instructions on how to generate a public / private keypair and you'll send us the URL all you want postbacks to be sent toalong with your public key. Remember never send your private key.Always keep that secure. Then you're registered and you're ready to begin usingSKAdNetwork. If you're a source app and you want to work with an ad network,ask them for their ad network id and put it into your info.plist file.This will make sure StoreKit knows to accept the ad data, when you displayan ad in your app.And finally if you're an advertising app and you want to measure the conversionof your ads make sure to configure your app so that it initializes thepostback when it first launches. Today we've covered lots of informationon best practices and new features in both server to server and customerdevice environments. You can now take advantage of new server to servernotifications for refunded purchases. And we saw how you can use subscriptionnotifications to get the latest information without needing to poll theverify receipt endpoint. We introduced our brand new way to share in-apppurchases among family members, giving you a new tool to increase valueand engagement with your customers. On the client side you can now offerin-app purchases directly inside your watchOS apps. And subscriptiondevelopers will benefit from our new improved subscription price increase flow.We got into the details of our new SKOverlay API for promoting appsincluding using it inside app clips. And finally we explained how ourSKAdNetwork API can help advertisers gather and use conversion data without compromisingon customer privacy. We think these tools will help you continue to growyour business with in-app purchases.For more information please join us on the
forums and in the labs. Thank you.

Hello and welcome to WWDC. Hello and welcome to WWDC. I'm Tori,and I'll also be presenting with my colleague Ross who you'll hear fromlater today. I'm so excited to share with you what we have new for youwith in-app purchases. And we have a lot to cover today.This session will be divided into two sections. I'll focus on covering what'snew on the server side. And later I'll hand it off to Ross to cover StoreKit updates.

So let's get started with our server updates. On the server side,first we'll cover refunds and how you can handle transactions that are refunded.Next we'll cover some new ways to help you manage the subscription statusfor your customers and how you can use App Store server notifications toget notified and respond to various subscription billing events.We'll also cover the different scenarios where you may still need to use verifyreceipt to get the latest status. And finally we'll dive into Family Sharing.We have a lot to cover so let's dive right in with arguably what broughtus all here today, an in-app purchase. So this is an in-app purchase inone of my apps. I'm so excited to use this. But what happens if I changemy mind, if I have an issue with the content and call Apple to request a refund,what should you as a developer do? That's why handling refunds is so important.But keep in mind that while it's important it only affects a small percentageof transactions. However proper refund management could drive that percentage down.

So let's dive into that now by walking through a typical refund scenario.First a customer purchases some content in an app like 100 Gems.However the purchase was an accident so they call Apple for support. After consideringtheir case we issue a refund. Later the customer contacts you for supportas they notice they still have the gems that were refunded. If you don'tknow that Apple has refunded the content it's difficult to determine howto respond. It would be so much better if you could easily determine ifwe had already refunded that purchase so you could take action appropriately.Such as acknowledging the refund but letting the customer keep their gemsor deducting their balance. That's why we're working to bring you new waysto manage refunds for your content. Having the ability to manage your refundedpurchases is important for many reasons. Most importantly it gives youcontrol to take action as you see fit. Such as messaging the customer oreven taking back the content if needed. It also lets you handle any potentialabuse of your content such as customers trying to keep their content afterreceiving a refund from Apple. And you can resolve customer issues likethe previous one swiftly. This will also allow you to manage your in-gameeconomy, making game play more fair for all players as there will be repercussionsfor refunds. So for all of these reasons and because we want you to beable to manage refunds for purchases in your app we're bringing you a brandnew App Store server notification and our first ever notification for contenttypes other than auto renewable subscriptions. The Refund notification.

So why did we decide on an App Store server notification for this.Well the primary reason is that you don't have to ask us for information.We'll just tell you. You're notified immediately with a JSON post upon a statuschange and we even retry up to three times if we don't get an HTTPOK back from you. If you're already receiving App Store server notificationsfor auto-renewing subscriptions then you'll get the new refund notificationfor your other content types with little additional work on your end.We'll also send you an updated unified receipt with your canceled transactionsincluded so you can update your records. And this solution is also scalableas you grow your business on our platform. So our goal for all contenttypes is to allow you to obtain information about refunded purchases throughApp Store server notifications. For consumables, non-consumables andnon-renewing subscriptions you'll receive the brand new refund notification.For subscriptions, you'll continue to receive the cancel notification.enabling App Store server notifications is straightforward if you've neverdone it before and can be done in a few steps. First set up your desiredend point for your notifications and App Store Connect. Next make sureyour End Point meets app transport security requirements as outlined inthe developer documentation. Then you're all set to start receiving notifications.

So in App Store Connect, just navigate to your apps page and find theURL for App Store server notifications section. Enter your desiredend point here so we know where to send your notifications. Know that ifyour end point already meets security requirements you'll immediately startreceiving notifications. Now let's take a deeper look at the refund notification.

We'll send you this notification when any consumable, non-consumable ornon-renewing subscription is refunded for your app, after we issue a refundto the customer for that purchase. Getting notified in this way makes iteasy for you to take immediate action on your refunded content. This notificationhas also been implemented in a privacy friendly way as we're not givingyou any information about the customer only information you'd already haveabout the purchase. The refund notification is live today so if you'realready receiving App Store server notifications make sure you're lookingfor it. With that in mind when you receive this notification there area few things I want you to look out for in the payload. You should lookfor the original_transaction_id to tell you which transaction we've refunded.The cancellation date to know when we refunded it and the cancellation reason.The reason can have values of zero or one and a value of one can indicatethe customer requested a refund due to an issue within the app which youcould then investigate. Also look for the bid, and the product_idto verify the app and product you've received a notification for. All thesefields can be found in the unified_receipt object in the App Store servernotification payload and the latest_receipt_info section. Except for thebid which is found at the top level of the payload. So what does the AppStore server notification look like. Well it looks something like this.Not all the fields are listed here but we have explanations for all possiblefields in the developer documentation. Right now let's take a look at theones we just discussed plus a few others. In addition to those transactionidentifying fields, look for the password and the payload. This is a sharedsecret for your app which you can find an App Store Connect and it allowsyou to verify the payload is from Apple and is trustworthy. At the samelevel as the password you'll find the bundle identifier. You can verifythis field to know which app you've received a refund for. Next look inthe unified_receipt object specifically in the latest_receipt_info array forinformation about your refund transactions. This array contains the 100latest transactions for your app and the four fields we told you to lookfor, the cancellation date, the cancellation reason, the original transactionID and the product ID. So let's revisit our refund scenario from earlierand look at how the refund notification can now help you in a slightlydifferent situation. In this situation the customer still buys 100gems but then consumes the gems and still asks Apple for support with their purchase.Once again we make a decision to honor or deny the refund because we don'tknow if the customer has consumed the gems. We may still honor the refundand if we do we'll send you a refund notification. Then if the customerreaches out to you asking for further support such as in-game compensation.But now you'll know the purchase has been refunded and you can choose totake proactive action such as providing an in-app message in your app. A messagesuch as this is great as it notifies the customer that you've observeda refund for their purchase. The action you've taken and what they cando to regain access to their content. In-app messaging is just one of manyactions you can take upon observing a refund. Let's take a quick lookat those now. So there are many actions you can take depending on the contenttype ranging from moderate to severe. For all content types, you can usethis for refund monitoring. For in-app messaging and restricting accessto the refunded purchase. Because we're sending you a server to server notification,this gives you the ability to restrict access cross-platform if needed.

In the case of consumables there are additional actions you can take likededucting the in-app currency balance. You as a developer are responsible formaking decisions on what measures to take and how to implement them.So think carefully about which action you decide to take in order to promotea healthy community within your app. So now we've covered a lot about refundsand how to handle them appropriately. So now let's switch gears and jumpinto how we're making it easier for you to manage your subscriptions.First taking a look at some of the key events in the subscription lifecycle.

These include acquiring a subscriber for the first time, any auto-renewsuccessful or unsuccessful, disabling or enabling auto-renew upgrades ordowngrades and cancellations. So what do all these events look like fora customer and for you. So when the customer first subscribes we establishthe subscription period and a fixed auto-renew period to repeat renewalafter renewal. Within the first subscription period, your customer decidesto turn off auto-renew thinking that they just aren't using the subscriptionenough, but later turns it back on after a little more time with their subscription.

After that we approach our first scheduled auto-renew. But there is anauto-renew failure due to a billing issue. At this point, we'll try to autorenew for the duration of the billing retry period. Also establishing agrace period. Luckily the subscription is recovered during our grace periodso the renewal cycle remains the same. Shortly thereafter your customerdecides they are enjoying their subscription so much that they want toupgrade. For an upgrade we start the customer at the higher tier immediately,shifting our upcoming renewals. Later after not using that higher tieras much as expected your customer decides to downgrade back to a more basic tier.Downgrades take place at the end of the subscription period. So your customerwill have access to the higher tier of service until their next scheduledauto-renew. So how can you keep track of all of these important eventsfor your subscriptions. What we recommend is using App Store server notificationsfor status updates. This is a push approach, meaning you don't ask us forinformation we'll just tell you when something happens. And we do. We notifyyou when the status of one of your subscriptions changes providing youwith a new receipt for your records at that time but only when you need it.This solution is also more scalable as you require more subscribers.So let's dive into our App Store server notifications now to see what we offerand to learn a little bit more about them. When you start receiving App Storeserver notifications or if you already are. This is the payload you canexpect to see. Note that this is a subset of possible fields and not allof these may be present all the time. There's a lot of information here,so I want to focus on some of the key components. When you received thispayload first look for the auto_renew_product_id to see exactly whichproduct the notification applies to and the product we plan to auto-renew next.

Then check the notification_type. This will tell you the type of eventyou are receiving. You should also verify the value and the password fieldmatches your shared secret. So you know the content comes directly fromApple and is trustworthy. You should also look for the bundle identifier.This will tell you which of your apps you've received a notification for.

Then you want to look for the unified_receipt, this object mimics the responsefrom verify receipt, so if you're already using verify receipt this shouldbe familiar. The latest_receipt in the unified_receipt object gives you anupdated accuracy for this customer for your app. The latest_receipt_infoarray contains the 100 latest transactions for your app. You can searchhere by the original transaction id to know which subscriptions are activefor this customer. Finally look at the pending_renewal_info arrayto find the upcoming renewal info for each subscription the customer usesin your app. Now let's quickly revisit the notification type field.We'll send you notifications for several events and the notification type fieldcan have the following possible values. INITIAL_BUY when a customer firstsubscribes. INTERACTIVE_RENEWAL when a customer upgrades or renews theirsubscription in your app or through managed subscriptions. DID_CHANGE_RENEWAL_STAUSwhen a customer changes their renewal status such as togglingauto-renew on or off. DID_CHANGE_RENEWAL_PREF when a customer makesa change that takes place at the end of the subscription period such asa downgrade. CANCEL when a customer calls Apple support and we issue arefund to them for their subscription or for an upgrade as we cancel theprevious lower tier subscription. DID_FAIL_TO_RENEW when we failed to auto-renewas scheduled due to a billing issue. And DID_RECOVER, when we recoverbilling of the subscription in the billing retry period or grace period.

For more information on these notifications and when you can expect toobserve them see our WWDC 2019 session "In-App Purchasesand Using Server-to-Server Notifications". And to learn more about whichnotifications are available to you in sandbox. Check out this year's session"Introducing StoreKit Testing in Xcode". So if we go back to our timelinefrom earlier we have notifications to cover almost all of these events.Initial buy for the purchase of the subscription did change renewal statusfor disabling and enabling auto-renew did fail to renew for the renewalfailure did recover for the billing recovery, interactive renewal for theupgrade plus a cancel for the previous lower tier subscription and didchange renewal preferences for the downgrade. So with App Store servernotifications you can easily monitor your subscription events. But we decidedwe could make this just a little bit better. Which is why this year we'rebringing you an App Store server notification for every successful auto-renew.This is a new notification type which we're calling DID_RENEW. Coming laterthis year, we'll send you this notification after every single successfulauto-renew, every time. Like all the other notifications it contains theunified receipt which gives you all the information you need to identifythe subscription that was renewed. This includes the original transactionid, which is a unique identifier for the subscription. The transactionid, a unique identifier for the new subscription period. The expirationdate of the new period and the auto-renew product id to tell you exactly whichproduct was auto-renewed. So jumping back to our timeline. Notice thatthe addition of the did renew notification completes our events, bringing youeverything you need to monitor your subscriptions in App Store server notifications.However, in addition to this new notification we thought there was a little moreinformation you might need concerning your subscriptions. We think youshould know if one of your customers has decided to apply a subscriptionoffer before we renew the subscription with that offer. That's why we'veadded the promotional offer id to the pending renewal info section.This will be available through your verify receipt and in the App Store server notificationand the pending renewal info array so you'll know if there are anypending offers for that subscription. This feature is live in the pendingrenewal info section today. So be sure you're looking for it. For moreinformation on using subscription offers. See our WWDC 2019session "Subscription Offers Best Practices". So now that we have a did renewnotification and the promotional offer id in the pending renewal info,what should you do with this new information? Most importantly this allowsyou to rely on App Store server notifications for updates, eliminating theneed to poll verify receipt. However you should still use verify receipt fora few key use cases. If you experience an outage on your server the nexttime one of your customers comes online you can call verify receipt tocheck their status. Making up for any missed updates. In this way verifyreceipt offers of recovery mode. Second you can use verify receipt toimmediately determine entitlements for a customer. To learn more aboutdetermining entitlements, tune into this year's architecting for a subscription session.Finally you can use verify receipt to verify a successful auto-renew.So what do we mean by using verified receipt to verify a successful auto-renew.Because auto-renew is so critical. You want to ensure that you get the update.For this reason approach marking an auto-renew through a double check.

First subscribe to our App Store server notifications so you receive therenew notification in addition to our other notification types.Second schedule a call to verify receipt for your subscription shortly after itsscheduled expiration date. When you received the did renew notificationas expected you can cancel this job, but if there is a delay you can fallback to verify receipt to verify a successful auto-renew. So we just covereda lot about App Store service notifications and subscriptions. Now I'dlike to discuss a new feature for App Store subscriptions. One of the thingscustomers love most about subscriptions like News Plus or Apple Arcadeis that they can be shared with their family members. Well we're very excitedto announce that this year the app store will support Family Sharing forin-app purchases, which will allow up to five additional family membersto share a single purchase. Family Sharing works for both auto-renewalsubscriptions and non-consumable in-app purchases like those that are usedto offer a full feature unlock. Customers will choose which in-app purchasesthey'd like to share with their family. We're so excited about what thismeans for developers and your ability to engage millions of family membersthat are already set up. Because the use of family is so widely adopted,Family Sharing for in-app purchases can help increase customer engagementand improve retention for your app. To begin, you can visit App Store Connectto turn on Family Sharing for a specific product. You can navigate to yourapps page and select 'Turn On' in the Family Sharing section. Note that onceyou turn on Family Sharing for a product you cannot turn it off.Let's review how customers will manage their shared purchases. When new customerssubscribe, the subscription will be shared by default. Subscribers can turnoff sharing later for their family on the managed subscriptions page. Forexisting purchasers, they'll be notified if one of their subscriptionsbecomes shareable. Then they can manage their sharing preference from thesame managed subscriptions page. For non-consumables all purchases willbe shared with the family, if the customer has turned on 'Share Purchaseswith Family' in Settings. So what do you need to do in your app. So familymembers can enjoy access to the shared purchase. With this feature notonly are we creating a transaction for the purchaser we're also creatinga transaction for each family member. So when a family member opens theapp they will have a transaction available in the transaction queue foreach of their devices and there will be a unique receipt for each familymember that will contain shared transactions in the latest receipt info array.

You should keep track of the original transaction id for each family memberas you already would for your subscriptions. Note that this only appliesto new purchases made after sharing is enabled. For non-consumable purchasesmade before sharing was enabled, you'll still have to restore purchasesfor these to be available to all family members. So let's get an idea ofwhat this looks like for new purchasers. After you've enabled Family SharingIn App Store Connect, when a family member makes a shareable purchase notonly do we put a transaction in the transaction queue for their deviceswe also put a transaction in the transaction queue for every member oftheir family, for all of their devices. So when their family members openup your app later you can unlock access to the subscription or non-consumable instantly.It's like magic. And it makes it so easy for you to reach more developersthan ever before. Before moving on let's quickly review what this lookslike for both new and existing subscribers for both subscriptions and non-consumables.So for new purchasers any shareable subscription they purchase is sharedwith their family by default. Any shareable non-consumable they purchaseis shared with their family, if they have purchase sharing enabled iniCloud. If the family is sharing payment and if the app is not hiddenfrom their purchase history. For existing purchasers for a shareable subscriptionto be shared with their family they must opt in from the managed subscriptionspage. For existing non-consumables to be shared, the same three conditionsmust be met and you have to restore purchases to unlock the content forthe family member. To manage access for all family members you'll needto use the receipt. You can get an updated receipt from verify receipt orfrom App Store server notifications. Additionally whenever the customeropens the app you can refresh the receipt on device to verify access foreach customer. But I'm getting ahead of myself here. So with that I'llhand off to my colleague Ross who who'll talk to you more about FamilySharing within StoreKit.

Thanks Tori. So let's take a look at how Family Sharing in-app purchasesworks within your app. First off how can your app tell if a product supportsFamily Sharing. Well we've added a handy new property on SKProduct calledisFamilySharable. It's as easy to use as requesting your product informationfrom the App Store and then checking this isFamilySharable boolean.

You can use this to programmatically display to customers that one of yourproducts is family shareable and not have to hard code any logic. So nowone of your customers has seen this family sharable product and taps topurchase it. What happens next? Well when a customer purchases a familyshareable in-app purchase everything begins as normal. Your app uses StoreKit tosend the purchase to the App Store and then you get a transaction backin the purchase date. The next time their family members open your appeach of the family members will get a transaction that looks just likea restored purchase, so your existing app logic should be able to handleit with no additional coding. Now Tori mentioned that customers can alsoenable and disable sharing for specific products. When a customer enablesFamily Sharing for a product something similar to a purchase happens. Theirfamily devices will all get a transaction that looks just like a restored purchase.So again your app should be able to handle it with no additional coding.What about the opposite case. What about when a customer disables Family Sharing.

Well normally non-consumables are permanent and auto-renewal subscriptionsonly end when they expire. But when a customer disables Family Sharingthey expect access to be halted immediately. So for this case we've addeda new API.

It's a new method on the SKPaymentTransactionObserver protocol calledpaymentQueue(didRevokeEntitlementsForProductIdentifiers:) When a customer disablesFamily Sharing StoreKit will automatically update your receipt and thencall this method. Inside the method you should be prepared to verify thereceipt whether locally or by uploading it to your server and using theverify receipt endpoint.

Products that have been revoked will no longer be present in the receipt.

Now you should make sure that you're not simply looking at the productidentifiers in the array and revoking access based on that. Depending onthe setup of your products and other products the customer may have purchasedthey may still be entitled to some access that overlap the revoked purchase.So we added this API to handle a couple of new situations that occur dueto Family Sharing. As I mentioned it will be called when a purchaser disablesFamily Sharing for a product. It will also be called if a customer leavesa family group that was sharing the purchase. And we've also taken thisopportunity to add support for refunds. If a customer receives a refundfor a non-consumable or an auto-renewable subscription, StoreKit will callthis method and you may revoke access immediate. And that wraps up FamilySharing which we think users will love. And we'll give you new opportunitiesto increase value to your customers and improve engagement and retention.Now I'm going to give you a tour of some of the other improvements andfeatures we've added to StoreKit, and what to look forward to in the latest releases.First I'll throw out a couple of things we already shipped since WWDClast year. We have in-app purchase on Apple Watch and improved storesubscription price increase flow. Then I'll move on to what's new includingSKOverlay and improvements to SKAdNetwork. So this first one is especiallyfor all you Apple Watch developers out there. As of watchOS 6.2earlier this year we've added StoreKit and in-app purchases to watchOS. This meansthat for apps your customers use mostly on the watch. You can offer in-apppurchases directly in the watchOS interface your customers are already using.

Using StoreKit on watchOS is almost exactly the same as using it on any other platform.

You can observe the payment queue, request products, and add them to the paymentqueue the same as you do on other platforms. When it comes to verifyingthe receipt you can of course continue to use server to server validation.

However if you prefer to do local validation there is just one differenceyou should be aware of. When you're retrieving the device identifier, insteadof using UIDevice, you need to use the WKInterfaceDevice API.Here's an example of some code that runs on both iOS and watchOS. Once you'veretrieved the device identifier everything else is the same. Use that deviceidentifier along with your PAKE value in the receipt to create a hash.Then make sure that hash matches the one in the receipt.

And that's all you need to know to add in-app purchases to your watchOS app.Another feature we rolled out in iOS 13.3 is an improvementto handling subscription price increases. A subscription price increaseoccurs when you have an existing subscription product you want to charge more for.

Setting up for price increases is easy. Just go into App Store Connect and changethe price, but you can't just bump up the price of an auto-renewal subscriptionwithout telling your customers. That's why the App Store requires eachcustomer to agree to the new price. You should know that if you decreasethe price of the subscription customers don't have to take any action andlook at the new price automatically. Now unfortunately this process ofinforming the customer and asking them to agree to the new price can resultin churn. Churn is when customers stop using your product and are no longerpaying for it. And now you're thinking well of course customers don't wantto pay more. But actually found in a lot of cases that's not the issue.

Customers can sometimes miss the e-mails that the App Store sends. Or perhapsthey don't want or engage in the price increase flow at that time.

And sometimes they put it off until later and simply forget.Additionally customers might not be informed of additional value that you're providing.For example if you run a video service and you've added new content. Sofor users experiencing a price increase who are using your app, we've implementedan automatic in-app price increase consent sheet. After you initiate aprice increase in App Store Connect any affected customers will see this App StoreUI when opening your app. This way customers are informed and can agreeto continue their subscription, at the time they're using the app, whichpresumably means they're finding value in your products. Once they agreeor dismiss the sheet your apps UI is underneath it and continues as normal.Now we realize that not all apps will want to display the sheet immediatelyupon opening, so we've added some tools to allow you to control the flow.First you'll want to implement this new SKPaymentQueue delegate method.

StoreKit will always call this method before presenting the price consent sheet.

Inside the method, its up to you to determine if you want to show a sheetnow and then return true if you do, and false if you don't.

Now if you return false here you're going to want a way to show the sheetlater at a time that's more opportune. Perhaps after you've educated thecustomer about additional value you're providing.

To do that simply call this other new StoreKit API. SKPaymentQueue.showPriceConsentIfNeededNow you should only call this if you've previouslyreturned false to the method above. However if you do call it and there'sno pending price increase don't worry. StoreKit will always check tomake sure there is a pending price increase for the customer before showingthe sheet and it won't show it at all if there isn't. Next I'm happy tointroduce an entirely new API in the latest iOS release. It's called SKOverlayand it's a sleek new UI element for displaying and promoting apps.

Take a look. SKOverlay presents a floating view at the bottom of yourUI that displays information about an app. It's similar to the SKStoreProductViewControllerclass that exists In StoreKit today, except SKOverlaywas designed to work seamlessly with your apps UI. Additionally unlikeSKStoreProductViewController, SKOverlay is only used to display apps.

SKOverlay was also designed to work seamlessly with your app clips inorder to help you transition users From your app clip to your full app.But that's not all it's used for. You're entirely able to use it within yourfull apps as well. Simply enter the app id of the app you want to displayand customers can install it directly from the overlay. If you're interestedin learning more about our new app clips feature, I highly recommend checkingout the "Exploring App Clips" session as well as the "Streamline Your App Clip Experience"session both in this year's WWDC. So now let's dive into the SKOverlayAPIs and see how you can best integrate SKOverlay into your app.Creating and presenting an SKOverlay is fairly straightforward. First you initializeit using an SKOverlay configuration object. We'll get back into that configurationobject later but it essentially allows you to set up the details of the overlay.

Then you call the present method passing in the window scene where youwant the overlay to appear. That's all you need to do to create and present anSKOverlay. Of course we've also added lots of other tools to allow youto customize the overlay flow. First there's a dismiss function that allowsyou to manually dismiss the overlay. You'll notice that this dismissalfunction is a class function and it doesn't take an overlay as an argumentbut rather another UIWindowScene. That's because only one overlay canbe displayed in a scene at a time and doing it this way allows you to removeany overlays that may be on a scene even if your current code context doesn'thave access to the specific overlay object. SKOverlay also has a delegate.

As you'd expect this delegate allows you to react to changes in the overlay status.

We'll see the details of that later. And finally SKOverlay has a configuration object.This allows you to see the configuration that was used to set it up.Now that we've come back around to the configuration, let's take a look at thosetwo objects. SKOverlay is actually comprised of two classes. The firstis called AppClipConfiguration and this configuration is used to transitionusers from your app clip to your full app. The AppClipConfiguration can onlydisplay the full app for the current app clip the overlays displayed in.The next class is the AppConfiguration. And this configuration can beused to display any app. Much of these two classes is the same. So let's start there.Both classes have a campaign token and a provider token so that you canuse SKOverlay with app analytics. They also have functions that allowyou to set and get arbitrary key values. Now most developers don't needto use these but they're there so you can integrate SKOverlay with otherStoreKit APIS such as SKAdNetwork.

Both classes also have a position property. While SKOverlay always appearsat the bottom of your screen apps that use tab bars will want to choosethe bottomRaised property so that the overlay appears just above the tabbar rather than on top of it. In addition to these properties and functionsthe app configuration also offers two additional properties on top of these.

First is the app identifier. You can use this to enter the iTunes identifierof the app you wish to display. The AppClipConfiguration doesn't havethis property because as I mentioned before that configuration is onlyused for displaying the full app of the current app clip the overlay is in.And the app configuration also has a user dismissible boolean. This is set to trueby default which means that the user will be able to swipe down on theoverlay to dismiss it from the screen. If you set this to false the userwill not be able to swipe down on it. And the overlay will only go awaywhen you call the dismiss function manually. That's it for the configuration.So let's move on to the delegate. The first delegate method is simply anerror handler. If you try to present an overlay and an unexpected erroroccurs it'll call this delegate method passing in the overlay and the specificerror as an argument. The rest of the delegate methods are all revolvingaround animating of the overlay. You can see there's a method for thestart and end of the presentation as well as the start and end of the dismissal.

You can also see that each of these methods includes an SKOverlayTransitionContext object. That's because these methods are used to helpcoordinate your UI animations alongside the overlay. Let's walk throughhow you might present an overlay and use these APIs to coordinate animations.Here we're creating and presenting an SKOverlay inside our app clip.First we grab the current window scene and then we create an app clip configurationusing the bottom position. We'll then initialize an overlay using that configurationobject and we'll set its delegate. Finally, we present the overlay in that scene.

And this is all you need to do to use SKOverlay in your app or app clip.

If we want to animate our own UI alongside the overlay. We can do so usingthe delegate methods. First we can set up any initial state for our UIelements directly inside the delegate method. These delegate methods arealways called in the main queue so you can manipulate UI right inside them.Then we add any animations we want inside an animation block on the transition context.

Again simply declare any changes in animatable properties here. There isno need to use a UI view animate block, since any code inside this block willbe animated for you by the overlay. Whether you're optimizing your app clipor promoting other apps inside your own app. SKOverlay is a greatoption for seamless integration and beautiful UI. Finally I'd like to sharewith you some updates about ourSKAdNetwork API. Introduced in iOS 11.3, SKAdNetworkallows ad networks to measure the effectiveness of their ads while stillrespecting customer privacy. In the latest iOS release we've made iteven more powerful while still not compromising on customer privacy.Let's start with an overview of SKAdNetwork. SKAdNetwork involvesthree stakeholders. Ad networks, source apps and advertising apps. Each stakeholderhas a role in making the feature work. Ad networks place ads within apps andreceive postbacks when ads results in conversions. Source apps displaythe ads that are sent to them by the ad networks. And advertising appsare the ones that appear in the ads and then submit the post back toSKAdNetwork once they're opened. Let's take a closer look at this flow fromstart to finish. First the ad network places the SKAdNetwork data insidean ad for the advertising app, which we'll call App B. Then it displays this adin the source app, which we can call App A. Once the user taps the ad, installsApp B and opens it, App B should call another SKAdNetwork API in orderto initialize the postback. Calling this API will set a timer. And oncethat timer expires the user's device will send the postback to the adnetworks URL. Ad networks should use Apple's public key to verifythe data in the postback and make sure it's legitimate. So that first bundleof data that the ad network sends up when displaying an ad looks like this.And contains the Ad network id, which has been registered with Apple and theCampaign ID from 1 to 100 which ad networks can use to measure their campaign effectiveness.

It contains the id of the advertising app, the one that's displayed inthe ad. And it has a timestamp. This timestamps should be generated atthe time the ad is displayed because timestamps that are too old will causethe ad data to be rejected. The nonce is just a random UUID used to ensurethat each ad impression is unique and to prevent double counting. And finallythe signature is generated using all of the other pieces of data in thisbundle to ensure that only your ad network can start ads using your ad network id.

In the latest iOS release we're requiring two new pieces of data.The first is the version which is now 2.0. And the second is the source app id.This is the id of the app thats displaying the ad. Next the postback APIshould be called by the advertising app, App B, upon the first launch oftheir app. This method generates a postback which is the cryptographicallysigned data validating that a user installed and launched this app afterseeing the ad. The first call to this API starts the postback process,if the device has attribution data for the app, and subsequent calls have noeffect. Starting in the latest iOS advertising apps will be able to callthe updateConversionValue API if they choose. This allows the app toadd an additional 6-bit value that represents some action that took placein the app. For example let's say you want to know whether a user purchasedan item in your app before you count the conversion. In this case you cancall updateConversionValue and include a value that you mapped purchasingan item. Since the conversion value is chosen at runtime we can't signit on the App Store server. So it's the only piece of the postback thatisn't protected with cryptography. The value itself as an integer between0 and 63, which may represent actions such as making a purchase,signing up for a free trial, or completing a level. Apps can call this APImultiple times to update the conversion value. However only values thatare higher than the previous value will be accepted. Values that are lowerthan the currently stored value will simply be ignored. This means you don'thave to worry about accidentally over writing your conversion value witha lower value. Now let's see the details of the postback that StoreKit sendsto the ad network once the process is complete. We'll send up the ad network idand the campaign id that were used in the ad, as well as the id of theadvertising app, App B. The transaction id is another unique identifier youcan use to make sure you aren't double counting conversions. And you canuse Apple's public key to verify the signature to know that it's all legitimate.

In the latest iOS we've added new information to the postback too. First weadded the version. We've also added a key called redownload which willindicate whether this was the first time the customer purchased the appor if they'd previously purchased it and are installing it again.Prior to this SKAdNetwork only worked for the first purchase of an app.So adding re-downloads will give you a lot more insight into the effectivenessof your ads. Furthermore in the latest iOS we've added two new optionalitems to the postback. The first is the idea of the source app so thatyou can know which app displayed the ad that resulted in the conversion.

And the second is the conversion value that was chosen by the advertising app.

It's important to note that these last two pieces of data won't alwaysshow up in the postback. In order to preserve customer privacy the AppStore servers do calculations to make sure that sharing these values won'tallow the post back to be linked to the customer that generated it.So we'll share them when we can. But your server should be ready to handlethe postbacks both with and without them. So how do you get started.

If you're interested in using SKAdNetwork as an ad network you'll needto sign up with Apple so we can register your information. You shouldenroll in the developer program as an organization and then fill out the formto request access to SKAdNetwork.

Well then send you instructions on how to generate a public / private keypair and you'll send us the URL all you want postbacks to be sent toalong with your public key. Remember never send your private key.Always keep that secure. Then you're registered and you're ready to begin usingSKAdNetwork. If you're a source app and you want to work with an ad network,ask them for their ad network id and put it into your info.plist file.This will make sure StoreKit knows to accept the ad data, when you displayan ad in your app.

And finally if you're an advertising app and you want to measure the conversionof your ads make sure to configure your app so that it initializes thepostback when it first launches. Today we've covered lots of informationon best practices and new features in both server to server and customerdevice environments. You can now take advantage of new server to servernotifications for refunded purchases. And we saw how you can use subscriptionnotifications to get the latest information without needing to poll theverify receipt endpoint. We introduced our brand new way to share in-apppurchases among family members, giving you a new tool to increase valueand engagement with your customers. On the client side you can now offerin-app purchases directly inside your watchOS apps. And subscriptiondevelopers will benefit from our new improved subscription price increase flow.

We got into the details of our new SKOverlay API for promoting appsincluding using it inside app clips. And finally we explained how ourSKAdNetwork API can help advertisers gather and use conversion data without compromisingon customer privacy. We think these tools will help you continue to growyour business with in-app purchases.For more information please join us on the
forums and in the labs. Thank you.

## Code Samples


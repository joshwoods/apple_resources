# Wwdc2020 10616

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Debug GPU-side errors in MetalTrack down even the trickiest GPU-side programming errors with enhanced reporting in Xcode 12. While Metal's API validation layer can catch most problems in a project, GPU errors can cause a host of difficult-to-debug issues.

Get an introduction to GPU-side errors and learn how to find and eliminate problems like visual corruption, infinite loop timeouts, out of bounds memory accesses, nil resource access, or invalid resource residency with Xcode 12. Discover how to enable enhanced command buffer error reporting and shader validation, use them effectively as part of your debugging strategy, and automate them in your production pipeline.ResourcesMetalHD VideoSD VideoRelated VideosWWDC22Maximize your Metal ray tracing performanceWWDC21Discover Metal debugging, profiling, and asset creation toolsWWDC20Bring your Metal app to Apple silicon MacsBuild GPU binaries with MetalGain insights into your Metal app with Xcode 12Harness Apple GPUs with MetalOptimize Metal Performance for Apple silicon Macs

Track down even the trickiest GPU-side programming errors with enhanced reporting in Xcode 12. While Metal's API validation layer can catch most problems in a project, GPU errors can cause a host of difficult-to-debug issues.

Get an introduction to GPU-side errors and learn how to find and eliminate problems like visual corruption, infinite loop timeouts, out of bounds memory accesses, nil resource access, or invalid resource residency with Xcode 12. Discover how to enable enhanced command buffer error reporting and shader validation, use them effectively as part of your debugging strategy, and automate them in your production pipeline.

Metal

HD VideoSD Video

HD Video

SD Video

Maximize your Metal ray tracing performance

Discover Metal debugging, profiling, and asset creation tools

Bring your Metal app to Apple silicon Macs

Build GPU binaries with Metal

Gain insights into your Metal app with Xcode 12

Harness Apple GPUs with Metal

Optimize Metal Performance for Apple silicon Macs

Search this videoâ€¦Hello and welcome to WWDC.Hi, I'm Michael Harris and I'm a GPU Software Engineer at Apple. Today,I'd like to talk about the improvements we've made to Metal's debuggingtools. Specifically, for errors in GPU side Metal Shader code. So what are afew examples of errors that we can make in Metal Shader code? You couldhave an out of bounds access in global or shared memory. You could attemptto access a nil texture resource. Or you might have forgotten to call useresource when using argument buffers resulting in invalid resource residency.You may have a timeout which can be caused by long running or infinite loops.This isn't an exhaustive list but it's some of the more common errors weMetal developers experience. These errors can often cause one another.An infinite loop may be caused by an out-of-bounds axis of the loop iteration count.The result of the GPU side error is a message like this one. In comparison,here's what we get from an API usage error on the CPU.Let's compare and contrast these two errors because there's a pretty largegap and useful information. For a GPU error, all we get is a message thatsays something went wrong but not much about what or where. But when there'san API usage error, Metal provides a lot of useful information. It shows theAPI entry point the error occurred on. It shows what type of error it was.In this case, we set an offset larger than the buffers length. There's alsoa call stack of exactly where the error occurred including line and fileinformation from your code base. Wouldn't it be nice if the GPU errorslooked a bit more like the API errors? Today, we'll show you some new toolsto help improve the debugging experience of GPU errors. To help illustratewhere our new tools fit in, we'll use a debugging workflow of detect, locateclassify, and fix. Metal has always had API Validation to help you catchissues early. Finding them early means that they're caught before theycan cause problems further down the line. Using it, you can detect whenthere's API misuse, locate the function causing the issue, and classifythe error message. We leave fixing the error up to you. But what abouterrors in your Metal shading language usage on the GPU? You've seen howthese errors appeared on iOS 13 and MacOS Catalina. Metal providesa basic error message. It's enough to tell you that something bad happenedduring the execution of that command buffer but not much else. So today,Metal's introducing two new diagnostic tools that will help improve thedebug workflow, Enhance Command Buffer Errors and the Shader Validation layer.First let's talk about Enhanced Command Buffer Errors.What is it? Well it enhances your command buffer's errors. To be more specific,it improves the existing command buffer error mechanism by helping youdetect and locate execution errors at the encoder level. Here's that GPU error again.There isn't a lot of actionable information here. When you're debugginga command buffer that might have hundreds of encoders, making progress isa lot of work. Here's that same error, but this time, we've turned on EnhancedCommand Buffer Errors. It's an obvious improvement over what we had before.You have information about each encoder within this command buffer andthat helps you narrow down the failure. Most of our encoders completedtheir work, but there are a few suspect encoders that had been marked as affectedor faulted. That narrows our search down significantly. Enabling EnhancedCommand Buffer Errors is simple. All you have to do is create your commandbuffer with the new descriptor based API and set the error options to encoderexecution status. That's it. If an error occurs while the feature is enabled,you can get encoder level information about that error. Here, in our codeexample, we're using the encoder info error key to access the user info dataof this error. This is where we'll find the array of our encoder info objectsto iterate over. As you can see here, each encoder info object has the labeland debugSignposts that you're already using to uniquely identify eachcommand encoder. If you're not already using labels and signposts, now'sa great time to start. The error state tells you the status of the commandencoder at the time of the fault. Or alternatively, if you don't want toformat it yourself, you can just log the whole error. That will print all theinformation related to the error. The error state property has a few possiblevalues: completed, pending, faulted, affected, and unknown. Faulted is the mostimportant error state because it means that this encoder was directly responsiblefor the command buffer fault.Affected could still indicate the faulty encoder but unlike the faultedstate, we're not 100 percent sure. A fault on one encoder could have affectedmultiple encoders that are running in parallel including encoders fromdifferent processes. In the rare event where we can't tell the state ofan encoder, we'll report the unknown state. There is synergy with the existingGPU tools as well. Since the encoder info objects are in recorded orderand use your labels and debug signposts, you can easily associate themwith the same encoder and Metal debugger, Metal system trays, and other toolsbuilt into Xcode. For example, with this information you can jump rightto the relevant encoder in Metal debugger. So when should you turn it on?First off, you should enable it on every command buffer during developmentQA. That will enhance all of your internal error reports and give youquick feedback on any errors. Since Enhanced Command Buffer Errors are builtright into Metal, it doesn't require any auxiliary layers. It's designedso that the API can leverage hardware functionality in its implementation.That makes it into a low overhead feature. Because it is so low overhead,you can even ship your application with the feature enabled. Since it'scommand buffer specific, you can target what command buffers to enable it on.As you get telemetry and bug reports, you can tune the set of command buffersto hone in on the problem. That said, test your performance before enablingon user devices. The performance impact varies across devices and workloads.So you want to check whether the overhead is acceptable to you. The challengewith debugging Metal shader code is that the code base can be large andcan contain a lot of places for errors to occur. The first step is knowingwhere to look and Enhanced Command Buffer Errors helps with that. It can getus to the encoder level, but to go deeper Metal provides another tool.That's where Shader Validation comes in -- to detect, locate, and classify the errorat the draw call level to help you debug and fix it. So let's talk aboutthe Shader Validation layer and what it can do for you. It's a layer similarto API Validation layer but running on the GPU. It instruments your Metalshaders to detect logical issues as well as locate and classify them. Whenit detects that an operation would have caused undefined behavior,that operation is prevented and the log is created that can be used to locatethe draw call Metal function, possibly even the line in the shader causing the error.This tool can help you debug issues that cause command buffer errors and itcan help you detect ones that don't. This is important because there'smany types of errors that don't actually cause a command buffer to failbut are still undefined behavior. Let's walk through one of those cases now.We'll start by allocating two buffers: A and B. We want to read from bufferA but have a logic issue such that it causes us to read out of bounds.What happens next is undefined and depends on Metal's allocation behavior.You could get lucky and there's unallocated memory in between the two buffers.If you go out of bounds in this case you can get a command buffer fault. Sincethere is a fault, it's obvious feedback that something bad has happenedand Enhanced Command Buffer Errors will narrow down to the encoder. But if you'reunlucky, out of bounds access won't cause a command buffer fault. Metal may placethe buffers one after another in virtual memory with no unallocated spacebetween. Here, our logic error won't cause a command buffer fault. We stillgo out of bounds but end up landing in another allocation and either readthe wrong data or corrupt another buffer. Such issues can be hard to detectand frustrating to debug as they may appear intermittent. The most importantthing you should take from that example is that you should always testwith API Validation and Shader Validation before shipping. Just becauseyou're not seeing a command buffer fault does not rule out that you don'thave any undefined behavior. Undefined behavior isn't always obvious andit can appear intermittent. But the good news is that Shader Validationis meant to detect these cases including the ones that aren't obvious.Let's go over what Shader Validation can and cannot detect. It can detectout of bounds device and constant memory access, out of bounds threadgroupmemory access, and attempting to use texturing functions on a null texture object.This doesn't cover all of the common issues mentioned but for everythingelse Enhanced Command Buffer Errors can help.You won't get draw information but it will narrow down to the encoder.The most powerful way to use this feature when debugging is from withinXcode and enabling it is easy. First, bring up the scheme settings in yourproject. In the diagnostics tab, we have a new section for diagnostics specific to Metal.Checking the box next to Shader Validation will enable the layer and Enhanced CommandBuffer Errors for all command buffers. Once the layer's enabled, you still needto enable the Metal diagnostics breakpoint. The Metal diagnostics breakpoint tells Xcode to stop the execution of the program when a shadervalidation error occurs and to show the recorded GPU and CPU backtracefor that error.Clicking the arrow to the right of Shader Validation will add the breakpoint.Once the break point has been added, you can find it in the debug navigatoron the breakpoints tab. You can view the settings of this breakpoint byclicking on the blue arrow. That will bring up this interface where youcan customize the breakpoint. To configure the breakpoint for Shader Validation,first, make sure the breakpoint is enabled. Then, set the type to SystemFrameworks and enter Metal Diagnostics into the category field. At thispoint, you're ready to use a feature within Xcode. Now let's jump intoa demo showing it in action.We're using the Metal Performance Shader Ray Tracing sample code.We've introduced an easy to make GPU error into the sample for this demo.During the demo, we'll go through using Shader Validation to detect anddebug this issue. First, I'll start by launching the app without Shader Validation.That doesn't look quite right. There's missing shadows and a bunch of lineson the screen. Why this isn't rendering isn't obvious, though. We're notgetting any command buffer errors so we don't know which encoder or Metalfunction has the bug. Before we start trying to debug this line by line,I'll use Metal's new debugging workflow by enabling Shader Validation.First, I'll bring up the scheme settings in my project and then I'll gointo the diagnostics tab and then down at the bottom there'll be optionsfor API Validation and Shader Validation. The API Validation has been movedfrom a different tab to this one. Now I'll enable API Validation and Shader Validation.Since I want to have Xcode break on the first validation error, I'll clickthis arrow to add the Metal diagnostics breakpoint. Now I'm setup to use shadervalidation and I'll relaunch the application. So we have some logs beingprinted in the console from shader validation indicating that it detectedan error. Since I have the breakpoint enabled, Xcode has stopped my applicationand brought up the Metal shader where the error occurred. Xcode is alsoshowing a shader annotation on the line that Shader Validation found hadan error. I can click the shader annotation and it'll show you some moredetails about this error. Based on the annotation, I'm hitting an out ofbounds memory read. Looking at this expression there's only one memoryaccess going on. We're reading the max distance field from the shadow ray argument.Which is a pointer in device memory. There are two possibilities here: eithershadow ray is null or shadow ray points to invalid memory. Since we enabledthe API Validation, that would have called a null buffer binding so we canrule that one out. Just looking at the function here, it's not clear howthe address or shadow ray is being calculated. So we'll use theGPU backtrace view in the bottom left hand side of Xcode. This viewshows the GPU backtrace of the error which has the recorded call stack ofthe error at the time the error occurred. We can traverse this call stackjust like you would any other recorded call stack.I'll click on the stack below our function which will jump me to the callsite of the function shadow ray intersection. It looks like the variableshadow ray is what's being passed in, which is computed by taking the shadowray's argument and indexing it using the ray index variable. Since we suspectan invalid offset, we need to investigate ray index. Looking at the commentabove the computation of Ray Index its code intends to convert a 2D gridcoordinate into a 1D array coordinate. That's typically accomplishedby multiplying the grid Y with the grid width and then adding the grid X.However, looking closely at this expression we see that instead of multiplyingthe grid Y and the width, we're multiplying the X and the width.That's definitely a typo. So let's correct that and then rerun the application.Now our app is fixed. With the help of Shader Validation and API Validation,we were able to quickly locate and classify this issue.We realize you're not always able to run everything under Xcode. So withsome additional setup you can use shader validation without Xcode. Thatlets you use Shader Validation for use cases like automated testing.Similar to API Validation, Shader Validation can be enabled using two new environment variableswe've added to the new macOS and iOS 14. These variables must be setbefore any Metal device is created for that process. Once a device iscreated we latch their values so any changes to them after that point willnot have an effect.To enable API Validation, set MTL_DEBUG_LAYER to any non-zero value. Andto enable Shader Validation, set MTL_SHADER_VALIDATION to any non-zero value.Both of these can be set at once or used independently. The command buffernow has a new log's property, which allows you to retrieve the details forany validation errors that occurred. The first thing to note is that thelogs property is only valid after a command buffer finishes. For that reason,we're doing all of our work inside the completion handler. We'll walk throughthis code sample showing how to use the new API and what information it provides.Each command buffer can have multiple Shader Validation errors. So we'regoing to iterate through all of them. Every log object contains informationabout the Shader Validation error. Like the label of the encoder that had anerror, that will give you the label but there can be more information. Ifyour Metal library was compiled from source or was compiled with debug symbols,each log may also have a debug location property.This property is the GPU stack frame containing the error and it willhold the file URL and line of the faulting expression. Alternatively, youcould just use the description property. This contains all the same informationformatted in an easy to read string.You'll also be able to find this information in the system log. You canaccess this log by running this highlighted command in your terminal.When a validation error occurs, it'll show up like this. The first thingin the log is the process name the error is occurring from. The next willbe the type of error and then the error details.Finally, the name of the Metal file and the line information. We have sometips to help you get the most out of Shader Validation. You can expectpipelines to take a bit longer to compile. Because of that, you should reallybe using the asynchronous compilation methods. That will paralyze compilationacross multiple threads which will help mitigate the increased load timesduring development. You should also enable debug symbols when compilingyour Metal libraries. That should automatically happen if you're using adebug scheme in Xcode. But if you're invoking the Metal frontend manually,symbols can be enabled by adding the -g flag. If any of your librariesare compiled from source online, debug symbols will automatically be enabled.If you are compiling libraries online, we recommend using the line preprocessor directive.The backtracer report uses the file name to identify a shader. Offlinecompiled Metal files include this information automatically, but it's missingwhen compiling from source at runtime. You can manually add the file nameinformation by using the line directive to tell the compiler what fileit is sourced from or to provide a useful identifier. Due to the natureof its instrumentation, there are a few things to be aware of when enablingShader Validation. Shader Validation is a process-wide switch that whenenabled causes all Metal commands, including UI rendering, to go throughthe Shader Validation layer. Unlike Enhanced Command Buffer Errors, using shadervalidation does have a high performance and memory impact. We recommendenabling this feature when development and during QA but not for usersbecause of this impact. Enabling the feature may also change some queriesto return different values. In particular, you should always check themaxTotalThreadsPerThreadgroup and the threadExecutionWidth propertiesof a compute pipeline state as these two may change when Shader Validationis enabled. We support some level of customization on how this featurebehaves, such as disabling specific checks. For example, if you're alreadydoing null texture checks, you can safely disable texture usage instrumentationby setting the environment variable MTL_SHADER_VALIDATION_TEXTURE_USAGE = 0.While disabling some instrumentation can improve runtime and compile timeperformance, it's at the cost of no longer detecting some possible issues.More information about what flags are supported can be found at the new MetalValidation man page. Some features are not supported when using Shader Validation.Binary function pointers and dynamic linking are not supported.There is an additional limitation for MTLGPUFamilyMac1 as well asMTLGPUFamilyApple5 and older devices, which is that global memory accessof pointers coming from an argument buffer are not checked. Thank you verymuch for coming to our session about the two new Metal debugging toolswe've added this year. First we cover Enhanced Command Buffer Errors whichis a low overhead in-framework tool that helps you detect and locate yourfaulting encoders in multiple environments like during development andQA or even after you've shipped.And we just covered Shader Validation which helps you detect, locate, andclassify both subtle and obvious shader errors during development and QA.Now go out and try the features. Test your apps with Enhanced Command BufferErrors and Shader Validation. Thanks and
have a great WWDC.

Hello and welcome to WWDC.

Hi, I'm Michael Harris and I'm a GPU Software Engineer at Apple. Today,I'd like to talk about the improvements we've made to Metal's debuggingtools. Specifically, for errors in GPU side Metal Shader code. So what are afew examples of errors that we can make in Metal Shader code? You couldhave an out of bounds access in global or shared memory. You could attemptto access a nil texture resource. Or you might have forgotten to call useresource when using argument buffers resulting in invalid resource residency.

You may have a timeout which can be caused by long running or infinite loops.This isn't an exhaustive list but it's some of the more common errors weMetal developers experience. These errors can often cause one another.An infinite loop may be caused by an out-of-bounds axis of the loop iteration count.

The result of the GPU side error is a message like this one. In comparison,here's what we get from an API usage error on the CPU.

Let's compare and contrast these two errors because there's a pretty largegap and useful information. For a GPU error, all we get is a message thatsays something went wrong but not much about what or where. But when there'san API usage error, Metal provides a lot of useful information. It shows theAPI entry point the error occurred on. It shows what type of error it was.In this case, we set an offset larger than the buffers length. There's alsoa call stack of exactly where the error occurred including line and fileinformation from your code base. Wouldn't it be nice if the GPU errorslooked a bit more like the API errors? Today, we'll show you some new toolsto help improve the debugging experience of GPU errors. To help illustratewhere our new tools fit in, we'll use a debugging workflow of detect, locateclassify, and fix. Metal has always had API Validation to help you catchissues early. Finding them early means that they're caught before theycan cause problems further down the line. Using it, you can detect whenthere's API misuse, locate the function causing the issue, and classifythe error message. We leave fixing the error up to you. But what abouterrors in your Metal shading language usage on the GPU? You've seen howthese errors appeared on iOS 13 and MacOS Catalina. Metal providesa basic error message. It's enough to tell you that something bad happenedduring the execution of that command buffer but not much else. So today,Metal's introducing two new diagnostic tools that will help improve thedebug workflow, Enhance Command Buffer Errors and the Shader Validation layer.First let's talk about Enhanced Command Buffer Errors.

What is it? Well it enhances your command buffer's errors. To be more specific,it improves the existing command buffer error mechanism by helping youdetect and locate execution errors at the encoder level. Here's that GPU error again.There isn't a lot of actionable information here. When you're debugginga command buffer that might have hundreds of encoders, making progress isa lot of work. Here's that same error, but this time, we've turned on EnhancedCommand Buffer Errors. It's an obvious improvement over what we had before.You have information about each encoder within this command buffer andthat helps you narrow down the failure. Most of our encoders completedtheir work, but there are a few suspect encoders that had been marked as affectedor faulted. That narrows our search down significantly. Enabling EnhancedCommand Buffer Errors is simple. All you have to do is create your commandbuffer with the new descriptor based API and set the error options to encoderexecution status. That's it. If an error occurs while the feature is enabled,you can get encoder level information about that error. Here, in our codeexample, we're using the encoder info error key to access the user info dataof this error. This is where we'll find the array of our encoder info objectsto iterate over. As you can see here, each encoder info object has the labeland debugSignposts that you're already using to uniquely identify eachcommand encoder. If you're not already using labels and signposts, now'sa great time to start. The error state tells you the status of the commandencoder at the time of the fault. Or alternatively, if you don't want toformat it yourself, you can just log the whole error. That will print all theinformation related to the error. The error state property has a few possiblevalues: completed, pending, faulted, affected, and unknown. Faulted is the mostimportant error state because it means that this encoder was directly responsiblefor the command buffer fault.

Affected could still indicate the faulty encoder but unlike the faultedstate, we're not 100 percent sure. A fault on one encoder could have affectedmultiple encoders that are running in parallel including encoders fromdifferent processes. In the rare event where we can't tell the state ofan encoder, we'll report the unknown state. There is synergy with the existingGPU tools as well. Since the encoder info objects are in recorded orderand use your labels and debug signposts, you can easily associate themwith the same encoder and Metal debugger, Metal system trays, and other toolsbuilt into Xcode. For example, with this information you can jump rightto the relevant encoder in Metal debugger. So when should you turn it on?First off, you should enable it on every command buffer during developmentQA. That will enhance all of your internal error reports and give youquick feedback on any errors. Since Enhanced Command Buffer Errors are builtright into Metal, it doesn't require any auxiliary layers. It's designedso that the API can leverage hardware functionality in its implementation.That makes it into a low overhead feature. Because it is so low overhead,you can even ship your application with the feature enabled. Since it'scommand buffer specific, you can target what command buffers to enable it on.As you get telemetry and bug reports, you can tune the set of command buffersto hone in on the problem. That said, test your performance before enablingon user devices. The performance impact varies across devices and workloads.So you want to check whether the overhead is acceptable to you. The challengewith debugging Metal shader code is that the code base can be large andcan contain a lot of places for errors to occur. The first step is knowingwhere to look and Enhanced Command Buffer Errors helps with that. It can getus to the encoder level, but to go deeper Metal provides another tool.That's where Shader Validation comes in -- to detect, locate, and classify the errorat the draw call level to help you debug and fix it. So let's talk aboutthe Shader Validation layer and what it can do for you. It's a layer similarto API Validation layer but running on the GPU. It instruments your Metalshaders to detect logical issues as well as locate and classify them. Whenit detects that an operation would have caused undefined behavior,that operation is prevented and the log is created that can be used to locatethe draw call Metal function, possibly even the line in the shader causing the error.This tool can help you debug issues that cause command buffer errors and itcan help you detect ones that don't. This is important because there'smany types of errors that don't actually cause a command buffer to failbut are still undefined behavior. Let's walk through one of those cases now.

We'll start by allocating two buffers: A and B. We want to read from bufferA but have a logic issue such that it causes us to read out of bounds.What happens next is undefined and depends on Metal's allocation behavior.You could get lucky and there's unallocated memory in between the two buffers.If you go out of bounds in this case you can get a command buffer fault. Sincethere is a fault, it's obvious feedback that something bad has happenedand Enhanced Command Buffer Errors will narrow down to the encoder. But if you'reunlucky, out of bounds access won't cause a command buffer fault. Metal may placethe buffers one after another in virtual memory with no unallocated spacebetween. Here, our logic error won't cause a command buffer fault. We stillgo out of bounds but end up landing in another allocation and either readthe wrong data or corrupt another buffer. Such issues can be hard to detectand frustrating to debug as they may appear intermittent. The most importantthing you should take from that example is that you should always testwith API Validation and Shader Validation before shipping. Just becauseyou're not seeing a command buffer fault does not rule out that you don'thave any undefined behavior. Undefined behavior isn't always obvious andit can appear intermittent. But the good news is that Shader Validationis meant to detect these cases including the ones that aren't obvious.Let's go over what Shader Validation can and cannot detect. It can detectout of bounds device and constant memory access, out of bounds threadgroupmemory access, and attempting to use texturing functions on a null texture object.This doesn't cover all of the common issues mentioned but for everythingelse Enhanced Command Buffer Errors can help.

You won't get draw information but it will narrow down to the encoder.

The most powerful way to use this feature when debugging is from withinXcode and enabling it is easy. First, bring up the scheme settings in yourproject. In the diagnostics tab, we have a new section for diagnostics specific to Metal.

Checking the box next to Shader Validation will enable the layer and Enhanced CommandBuffer Errors for all command buffers. Once the layer's enabled, you still needto enable the Metal diagnostics breakpoint. The Metal diagnostics breakpoint tells Xcode to stop the execution of the program when a shadervalidation error occurs and to show the recorded GPU and CPU backtracefor that error.

Clicking the arrow to the right of Shader Validation will add the breakpoint.

Once the break point has been added, you can find it in the debug navigatoron the breakpoints tab. You can view the settings of this breakpoint byclicking on the blue arrow. That will bring up this interface where youcan customize the breakpoint. To configure the breakpoint for Shader Validation,first, make sure the breakpoint is enabled. Then, set the type to SystemFrameworks and enter Metal Diagnostics into the category field. At thispoint, you're ready to use a feature within Xcode. Now let's jump intoa demo showing it in action.

We're using the Metal Performance Shader Ray Tracing sample code.We've introduced an easy to make GPU error into the sample for this demo.During the demo, we'll go through using Shader Validation to detect anddebug this issue. First, I'll start by launching the app without Shader Validation.

That doesn't look quite right. There's missing shadows and a bunch of lineson the screen. Why this isn't rendering isn't obvious, though. We're notgetting any command buffer errors so we don't know which encoder or Metalfunction has the bug. Before we start trying to debug this line by line,I'll use Metal's new debugging workflow by enabling Shader Validation.First, I'll bring up the scheme settings in my project and then I'll gointo the diagnostics tab and then down at the bottom there'll be optionsfor API Validation and Shader Validation. The API Validation has been movedfrom a different tab to this one. Now I'll enable API Validation and Shader Validation.

Since I want to have Xcode break on the first validation error, I'll clickthis arrow to add the Metal diagnostics breakpoint. Now I'm setup to use shadervalidation and I'll relaunch the application. So we have some logs beingprinted in the console from shader validation indicating that it detectedan error. Since I have the breakpoint enabled, Xcode has stopped my applicationand brought up the Metal shader where the error occurred. Xcode is alsoshowing a shader annotation on the line that Shader Validation found hadan error. I can click the shader annotation and it'll show you some moredetails about this error. Based on the annotation, I'm hitting an out ofbounds memory read. Looking at this expression there's only one memoryaccess going on. We're reading the max distance field from the shadow ray argument.Which is a pointer in device memory. There are two possibilities here: eithershadow ray is null or shadow ray points to invalid memory. Since we enabledthe API Validation, that would have called a null buffer binding so we canrule that one out. Just looking at the function here, it's not clear howthe address or shadow ray is being calculated. So we'll use theGPU backtrace view in the bottom left hand side of Xcode. This viewshows the GPU backtrace of the error which has the recorded call stack ofthe error at the time the error occurred. We can traverse this call stackjust like you would any other recorded call stack.I'll click on the stack below our function which will jump me to the callsite of the function shadow ray intersection. It looks like the variableshadow ray is what's being passed in, which is computed by taking the shadowray's argument and indexing it using the ray index variable. Since we suspectan invalid offset, we need to investigate ray index. Looking at the commentabove the computation of Ray Index its code intends to convert a 2D gridcoordinate into a 1D array coordinate. That's typically accomplishedby multiplying the grid Y with the grid width and then adding the grid X.However, looking closely at this expression we see that instead of multiplyingthe grid Y and the width, we're multiplying the X and the width.That's definitely a typo. So let's correct that and then rerun the application.

Now our app is fixed. With the help of Shader Validation and API Validation,we were able to quickly locate and classify this issue.We realize you're not always able to run everything under Xcode. So withsome additional setup you can use shader validation without Xcode. Thatlets you use Shader Validation for use cases like automated testing.Similar to API Validation, Shader Validation can be enabled using two new environment variableswe've added to the new macOS and iOS 14. These variables must be setbefore any Metal device is created for that process. Once a device iscreated we latch their values so any changes to them after that point willnot have an effect.To enable API Validation, set MTL_DEBUG_LAYER to any non-zero value. Andto enable Shader Validation, set MTL_SHADER_VALIDATION to any non-zero value.Both of these can be set at once or used independently. The command buffernow has a new log's property, which allows you to retrieve the details forany validation errors that occurred. The first thing to note is that thelogs property is only valid after a command buffer finishes. For that reason,we're doing all of our work inside the completion handler. We'll walk throughthis code sample showing how to use the new API and what information it provides.

Each command buffer can have multiple Shader Validation errors. So we'regoing to iterate through all of them. Every log object contains informationabout the Shader Validation error. Like the label of the encoder that had anerror, that will give you the label but there can be more information. Ifyour Metal library was compiled from source or was compiled with debug symbols,each log may also have a debug location property.This property is the GPU stack frame containing the error and it willhold the file URL and line of the faulting expression. Alternatively, youcould just use the description property. This contains all the same informationformatted in an easy to read string.

You'll also be able to find this information in the system log. You canaccess this log by running this highlighted command in your terminal.

When a validation error occurs, it'll show up like this. The first thingin the log is the process name the error is occurring from. The next willbe the type of error and then the error details.Finally, the name of the Metal file and the line information. We have sometips to help you get the most out of Shader Validation. You can expectpipelines to take a bit longer to compile. Because of that, you should reallybe using the asynchronous compilation methods. That will paralyze compilationacross multiple threads which will help mitigate the increased load timesduring development. You should also enable debug symbols when compilingyour Metal libraries. That should automatically happen if you're using adebug scheme in Xcode. But if you're invoking the Metal frontend manually,symbols can be enabled by adding the -g flag. If any of your librariesare compiled from source online, debug symbols will automatically be enabled.

If you are compiling libraries online, we recommend using the line preprocessor directive.The backtracer report uses the file name to identify a shader. Offlinecompiled Metal files include this information automatically, but it's missingwhen compiling from source at runtime. You can manually add the file nameinformation by using the line directive to tell the compiler what fileit is sourced from or to provide a useful identifier. Due to the natureof its instrumentation, there are a few things to be aware of when enablingShader Validation. Shader Validation is a process-wide switch that whenenabled causes all Metal commands, including UI rendering, to go throughthe Shader Validation layer. Unlike Enhanced Command Buffer Errors, using shadervalidation does have a high performance and memory impact. We recommendenabling this feature when development and during QA but not for usersbecause of this impact. Enabling the feature may also change some queriesto return different values. In particular, you should always check themaxTotalThreadsPerThreadgroup and the threadExecutionWidth propertiesof a compute pipeline state as these two may change when Shader Validationis enabled. We support some level of customization on how this featurebehaves, such as disabling specific checks. For example, if you're alreadydoing null texture checks, you can safely disable texture usage instrumentationby setting the environment variable MTL_SHADER_VALIDATION_TEXTURE_USAGE = 0.

While disabling some instrumentation can improve runtime and compile timeperformance, it's at the cost of no longer detecting some possible issues.

More information about what flags are supported can be found at the new MetalValidation man page. Some features are not supported when using Shader Validation.Binary function pointers and dynamic linking are not supported.

There is an additional limitation for MTLGPUFamilyMac1 as well asMTLGPUFamilyApple5 and older devices, which is that global memory accessof pointers coming from an argument buffer are not checked. Thank you verymuch for coming to our session about the two new Metal debugging toolswe've added this year. First we cover Enhanced Command Buffer Errors whichis a low overhead in-framework tool that helps you detect and locate yourfaulting encoders in multiple environments like during development andQA or even after you've shipped.

And we just covered Shader Validation which helps you detect, locate, andclassify both subtle and obvious shader errors during development and QA.Now go out and try the features. Test your apps with Enhanced Command BufferErrors and Shader Validation. Thanks and
have a great WWDC.

3:40 -Enable enhanced command buffer errors

3:55 -Processing enhanced command buffer errors

15:39 -Command buffer logs API

15:40 -Accessing the log

## Code Samples

```swift
let
 desc 
=
 
MTLCommandBufferDescriptor
()
desc.errorOptions 
=
 .encoderExecutionStatus

let
 commandBuffer 
=
 commandQueue.makeCommandBuffer(descriptor: desc)
```

```swift
if
 
let
 error 
=
 commandBuffer.error 
as
 
NSError
? {

    
if
 
let
 encoderInfos 
=

        error.userInfo[
MTLCommandBufferEncoderInfoErrorKey
]
        
as?
 [
MTLCommandBufferEncoderInfo
] {

        
for
 info 
in
 encoderInfos {
            
print
(info.label 
+
 info.debugSignposts.joined())
            
if
 info.errorState 
==
 .faulted {
                
print
(info.label 
+
 
" faulted!"
)
            }
        }
    }
}
```

```swift
commandBuffer.addCompletedHandler { (commandBuffer) 
in

    
for
 log 
in
 commandBuffer.logs {
        
let
 encoderLabel 
=
 log.encoderLabel 
??
 
"Unknown Label"

        
print
(
"Faulting encoder 
\"
\(encoderLabel)
\"
"
)
        
guard
 
let
 debugLocation 
=
 log.debugLocation,
              
let
 functionName 
=
 debugLocation.functionName
        
else
 {
            
return

        }
        
print
(
"Faulting function 
\(functionName)
:
\(debugLocation.line)
:
\(debugLocation.column)
"
)
    }
}
```

```swift
log
 stream --predicate 
"subsystem = 'com.apple.Metal' and category = 'GPUDebug'"
```


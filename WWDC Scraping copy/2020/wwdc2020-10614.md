# Wwdc2020 10614

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Advancements in Game ControllersLet's rumble! Discover how you can bring third-party game controllers and custom haptics into your games on iPhone, iPad, Mac, and Apple TV. We'll show you how to add support for the latest controllers — including Xbox's Elite Wireless Controller Series 2 and Adaptive Controller — and map your game's controls accordingly. Learn how you can use the Game Controller framework in tandem with Core Haptics to enable rumble feedback. And find out how you can take your gaming experience to the next level with custom button mapping, nonstandard inputs, and control over specialty features like motion sensors, lights, and battery level.

To get the most out of this session, you should be familiar with the Game Controller framework. Check the documentation link for a primer.

And if you build games for iPad, be sure to check out "Bring keyboard and mouse gaming to iPad” for a guide on integrating keyboard, mouse, and trackpad inputs into your experience.ResourcesGame ControllerPlaying Haptics on Game ControllersHD VideoSD VideoRelated VideosWWDC23Bring your game to Mac, Part 1: Make a game planEnhance your iPad and iPhone apps for the Shared SpaceWWDC22Plug-in and play: Add Apple frameworks to your Unity game projectsWWDC21Qualities of great iPad and iPhone apps on Macs with M1Tap into virtual and physical game controllersWWDC20Bring keyboard and mouse gaming to iPadDesign for Game CenterWWDC19Expanding the Sensory Experience with Core HapticsSupporting New Game Controllers

Let's rumble! Discover how you can bring third-party game controllers and custom haptics into your games on iPhone, iPad, Mac, and Apple TV. We'll show you how to add support for the latest controllers — including Xbox's Elite Wireless Controller Series 2 and Adaptive Controller — and map your game's controls accordingly. Learn how you can use the Game Controller framework in tandem with Core Haptics to enable rumble feedback. And find out how you can take your gaming experience to the next level with custom button mapping, nonstandard inputs, and control over specialty features like motion sensors, lights, and battery level.

To get the most out of this session, you should be familiar with the Game Controller framework. Check the documentation link for a primer.

And if you build games for iPad, be sure to check out "Bring keyboard and mouse gaming to iPad” for a guide on integrating keyboard, mouse, and trackpad inputs into your experience.

Game Controller

Playing Haptics on Game Controllers

HD VideoSD Video

HD Video

SD Video

Bring your game to Mac, Part 1: Make a game plan

Enhance your iPad and iPhone apps for the Shared Space

Plug-in and play: Add Apple frameworks to your Unity game projects

Qualities of great iPad and iPhone apps on Macs with M1

Tap into virtual and physical game controllers

Bring keyboard and mouse gaming to iPad

Design for Game Center

Expanding the Sensory Experience with Core Haptics

Supporting New Game Controllers

Search this video…♪Hello and welcome to WDDC.James Kelly: Hello. My name is James Kelly, and I'm a memberof the Game Technologies Engineering team at Apple.In this video, we'll be talking aboutnew game controller features and changescoming to our platforms this year,and we'll give some adviceon how you can best adopt these new changes.As a reminder, the game controller frameworkhas a goal to make it easy to add supportfor MFI select third-party game controllers to your gameson iOS, tvOS and MacOS.By abstracting controller hardware through a common API,the game controller framework lets you write your code oncewithout you having to worry abouthow that controller data is mapped.This year we're making sure you can take advantage of,and customize, the great features of game controllerslike haptics and rumble, motion, lights,as well as unique inputs like touchpads and paddles.We'll also show how users can remap their controllers globallyor tune it to their gameto get just the configuration they want.Before we start, we're excited to announcesome additions to our supported lineup of great controllers.First up, we've added supportfor the Xbox Elite Wireless Controller Series 2.It's got a really great feeland it's been highly requested by our users.We're also really excited to announce supportfor the Xbox Adaptive Controller.This unique extensible controllerhelps to make gaming more accessible for all.So developers are creating some great gameswith controller support.Oceanhorn 2, Sonic Racing, Spyder, and Lego Brawlsare some excellent examples on Apple Arcadeand just a few of the games on the App Storethat support controllers.By using the game controller framework,these games automatically supportnewly-added controllers like the Xbox Adaptive Controlleror the Xbox Elite Wireless Controller Series 2.So now let's talk about changes comingto the game controller framework this yearin support of these new controllers.So let's start by talking about how you can accessthe buttons of these new controllers.There's a new way to access controller input this year.GC PhysicalInputProfile, which represents the collectionof all physical inputs available on a controller --meaning its buttons, triggers, Dpads, thumbsticks, and so on.We're calling this the new Extensible Input APIas it allows your game to dynamically query and supportall of the controller's inputs at runtime --even non-standard inputs like the DualShock 4's touchpador the Xbox Elite Controller's paddle buttons.Every controller now has a physical input profile.And so GC ExtendedGamepad and GC MicroGamepadhave both been made subclasses of this GC PhysicalInputProfile.You're encouraged to still check for the presence of profileslike GC ExtendedGamepad to filter out controllersthat don't have the buttons you need.You can then use the PhysicalInputProfileto access the controller's unique buttonslike the DualShock 4's touchpad.So let's take a look at a code exampleto get a sense of these changes.Let's say we want to add some special shortcutsfor controllers with extra buttons.First, we'll add an actionthat can instantly trigger an attack combowhich would normally require a combination of button presses.We'll also track the buttons on the controllerthat we have and have not mapped to actions.Now let's look at setupConnectedControllerthat is called when a controller connects.We grab a reference to the physical input profileon the controller.Remember that every controller will have this profile.We have a helper function, setupBasicControls,that will set up all the standard controlsfor the face buttons, the left and right thumbsticks,the Dpad, et cetera, and it will also update mapped buttons.Using that physical input profile,we can then easily grab a reference to a panel button,if one exists, and update our mapped button set.Finally, we can look at all of the buttons availableon the physical input profile and filter out any buttonsthat have already been mapped.We can use this to populate an in-game mapping UIwith a list of unused buttons.So for ease of use,we've added two new subclasses to GC ExtendedGamepad:GC DualShockGamepad and GC XboxGamepad.The DualShockGamepad exposes the touchpad surfacewith two-finger tracking as well as the touchpad's button.The XboxGamepad exposes the four paddle buttonsof the Xbox Elite Wireless Controller.Use extra buttons to augment your gameswith additional convenience controls,but avoid requiring these buttonsas other controllers don't have them.So one quick note about the paddle buttonson the Xbox Elite Wireless Controller Series 2.The controller supports hardware button remapping,which can be configured and then stored in one of three profiles.The selected profile is indicatedby the three LEDs on the front of the controller.And due to how the controller sends data,the paddle buttons will only work when the controllerdoes not have a button mapping profile selected,meaning that the three LEDs are unlit.So up next, let's talk about haptics and rumble,one of the most exciting additions to the API this year.Games coordinate visuals, sounds, and hapticsfrom the controller to more deeply immerse the player.So great haptics can help give a sensethat your car is driving over gravel,that your character is walking through sand,that you feel the recoil in your trigger finger,or even that a nearby explosion is shaking your room.Many of our supported controllerscan provide haptic feedback, including the DualShock 4,the Xbox Wireless Controller,and the Xbox Elite Wireless Controller.And that feedback is programmable,meaning that you have fine-grained controlover the low-level haptic feeling that is played.These controllers all use different hardwarefor generating haptics.So let's talk a little bit about how you can easilyadd haptic feedback to your game without having to worry aboutthe physical details of each controller.So this year we're happy to add game controller supportto Core Haptics, on top of the existing phone haptic support.Core Haptics is a powerful APIthat allows you to compose and play haptic patternsto customize your app's haptic feedback.In Core Haptics, you can craft custom haptic patternsfrom basic building blocks called haptic events.These patterns can be created programmaticallyor stored in Apple haptic and audio pattern, or AHAP, files.After designing your haptic patterns,you simply create pattern playersfrom a haptic engine to play your haptic content.Core Haptics and AHAPallows you to design your haptic content onceand then play it everywhere, be it a phone, a DualShock 4,or any one of our other supported devices.For more information on the detailsof the Core Haptics framework, including some excellentexamples on how to design AHAP content,please watch Introducing Core Haptics from WWDC 2019.Let's look at a simple practical example.Haptic feedback is a great way to immerse players in a gameand let them really feel the impact of their gameplay.So let's say we have a player and an enemy in an action game.When the enemy attacks the player,they're dealt damage and the controller rumbles.So how do we achieve this in our gameusing the game controller and Core Haptics frameworks?Well first, we need to design our haptic content.Here we've programmatically created a haptic patterncalled enemy strike that will play when an enemy attacks.We can then feed this data into a CHHapticPattern.Once we have our haptic content designedand loaded into a pattern, we can get ready to play it.But how do we play it on a controller?Well first we need a GCController instance.Here representing the Xbox Elite Controllershown on the right.Next, we can create a CHHapticEnginethat targets the locations on a controllerthat we'd like to play haptics on.A haptic engine is just an object that managesyour app's requests to play haptic patterns.Finally, we can create a CHHapticPatternPlayerfrom our engine and our pattern.Once we call start on this pattern player,our AHAP content will play on our controller.In this case, just the handles.You can even layer these pattern players.The system will automatically combine the hapticsfrom all active patterns for you at runtime,allowing you to create some really dynamic effects.So how do you create a haptic engine?Simply call createEngineWithLocalityon a controller instance and pass in a GC haptic locality.This locality defines the physical locationson the controller that the haptic engine will target.The default haptic locality is geared towards providinga haptic experience that your users would expect.For example, on game controllers,the default locality typically targets the handles.You can get more specific if you'd like.Here we're targeting just the left impulse trigger.So how do we put all this together?Let's look at a code example.We begin by creating an instance of a CH haptic engine.One that targets the handles of the active controller.The engine is assigned to our member variableso we can keep it around.After creating the haptic engine, we'll need to start itand check for possible errors.The engine will continue to run until the applicationor possible outside action stops it.So let's play some haptics.Here's the function that executes when the playeris dealt damage by the enemy.In this example, you want to generate a haptic patternthat scales with the amount of damage that was dealt.So we have to create the pattern playerand its pattern at the moment they're neededto account for this damage.Once the pattern player is created,we start it at time CHHapticTimeImmediate,which indicates that we want to play it with minimal latency.If you had two separate haptic playersthat you wanted to synchronize,you would need to specify an actual time here.Notice that the app does not hold ontothe instance of the player.It's pattern is guaranteedto continue playing until it's finished,so we can simply fire and forget it.Let's look at creating a pattern player.This method is responsible for creatingthe custom haptic content that will play when we take damage.We'll create a continuous haptic eventthat applies over a specified duration.We'll give it a sharpness and intensity.This will provide a nice baseline of haptic feedback,regardless of how much damage was done to the player.Next we create a transient haptic event.These are brief impulsesthat occur at a specific point in timesuch as the click you would feel from toggling a switch.Note that the transient events don't have a specified duration.They're just the shortest haptic event that you can produce,so the actual time a transient takeswill vary from controller to controller.Again, we set the sharpness and intensity.This time we scale the intensityby the amount of damage that was dealt to the player.Next, we create the pattern containing these two events.Finally, we create the pattern player from this patternand return it.OK. So now that you saw how easy it wasto generate haptic content in Core Haptics,let's talk about how you can transitionyour existing rumble code from other platforms.In many existing games,haptics are tied directly to the update loop.This typically means that every update,the engine will set the intensityof each physical actuator on a game controller directly.With this approach,the engine combines different haptic effects each frame.Let's talk about how you can migrate a gamethat uses this architecture to Core Haptics.Our goal is to update the intensitiesof the controller's motors each frame.To achieve this, we'll need to create a pattern playerso we can send changes to itand then we'll create a long-running patternwith an initial haptic intensity set to one.In our update loop,we'll just change the intensity of the motors.To do this, we create a dynamic parameterwith the haptic intensity we calculate for a given motorand then we send it to the pattern player.We can do this each frame,and as long as our updates are fast enough,the user will feel a continuous change in haptic intensity.Let's take a quick lookat how we can achieve this in code.Here we're setting up all the pieces you needto be able to update your controller's motorsin your update loop.We're setting up our pattern player,which will later send new intensities to each update.In this function, we'll create a long-running,continuous haptic eventwith a haptic intensity set to the max value of one.We'll use the continuous event to create a haptic pattern.And finally, we'll create our pattern playerand start it immediately.You'll need to hold onto this, as you'll be using it later.Now in our update loop,we're also going to update our haptics.This is where we update the intensity of our motors.We create a dynamic parameter targeting haptic intensity.These are similar to the parametersused to generate events,except these could be applied dynamicallyto an already-running pattern,and they apply to the entire pattern,not just a single event.Here, haptic engine motor intensityrepresents the intensity of the motor from 0 to 1as calculated by the engine for this frame.This will act as a multiplier on the pattern player's intensity.We finish up by sending our dynamic intensity parameterto our pattern player.Please note that this exampleonly covers one CH haptic engine.You will need to repeat this approach for each motorif you would like to control themindependently from one another.Next up, let's talk about some other featuresthat we've added to the Game Controller framework this yearthat'll help you to fully utilizethe extended capabilities of newly-supported controllers.Let's start by looking at a situationthat single-player games frequently need to handle.Your game launches, and you see multiple controllers connected.Particularly with the Apple TV, it's common to seethe Siri Remote and a game controller --but which one should you take input from?How do you know which controlleris currently being used by the player?You could register your controller connectionand disconnection handlersand manage the lifecycles of the controllers,but you still need to track when a controller becomes activeto update the UI and controlsas the user switches between input devices.This is why we're introducing some new APIto handle this for you.We've added the current property to GCControllerwhich always returns the most recently-used controlleror nil if no controller is connected.We've also added two new notificationsthat you can observe to properly respondto the current controller changing.GCControllerDidBecomeCurrentand GCControllerDidStopBeingCurrent.Single-player games should adaptto the currently active game controllerby using this property.By listening to the notifications,you can easily adapt your UIto reflect the currently used controller.Next, let's talk aboutthe motion sensors on the DualShock 4.The DualShock 4 has a gyroscope,meaning that it knows its rotation rate in 3D spaceallowing for some great gameplay possibilities.One common technique is to use the gyroscopefor fine-tuned camera aimingwith the thumbsticks used for more coarse aiming.The DualShock 4 also has an accelerometer.There are many ways to use accelerometer.For example, you can detect whether the controlleris tilted to the left or the rightfor driving controls in a racing gameor you can interpret high, rapid shifts in accelerationas a shake gesture to make your player character attack.We've introduced support for the DualShock 4'smotion sensors via GCMotion, a property on GCController.For those of you familiar withsupporting the Siri Remote on tvOS,we're using the same API here but with a few tweaks.When supporting the DualShock 4,you need to manually turn the motion sensors on and offto preserve battery.You can query whether you need to manage the sensors yourselfor leave it up to the system like with the Siri Remote.Set motion.sensorsActiveto toggle motion sensors on and off.Additionally, some controllers like the DualShock 4do not separate gravity from user accelerationand only report that total acceleration of the controller.Query whether the connected controller has the abilityto separate gravity from user acceleration,and if it doesn't, use the total acceleration instead.The next feature I want to tell you aboutis the DualShock 4's lightbar.It's usually used as a player indicatorbut you can also use it for game effects.For example, it could flash a different colorwhen the player walks into lavaor shine green, then yellow, then redas the player loses health.We've surfaced support for the DualShock 4's lightbarvia GCDeviceLight, a property on GCController.It's easy to change the color of a DualShock 4 lightbar.Just set the GCDeviceLight color value.Here, we're setting the color to red.Nowadays, many controllers are wirelessand may need charging.We're making battery state available to youso that you can show it in your UI,particularly in low battery situations.This is provided via GCDeviceBattery,a property on GCController.You can check the level of the batteryas well as its charging state,whether it's charging, discharging, or fully charged.You can then use key value observing (or KVO)to monitor any changes to the battery.Now I'd like to introduce my colleague Hannah Gillis,who will give some tips on how to best take advantageof our new input remapping feature.Hannah Gillis: Thanks, James.Let's talk about how you can indicatethat your app supports game controllersand the benefits that come along when you do so.There are a few reasons to indicate controller support.First, it surfaces information on the App Store and on Apple TVto communicate to userswhen a controller is required for an application.A game controller badge will be listed on the app's product pageto visually declare this info.Second, indicating controller support provides the abilityfor input remapping in your application,which I'll discuss shortly.For these reasons, we highly recommend you update your appsfor the best user experience.To indicate controller support,you should enable the game controllers capability in Xcode.This informs the systemthat your app uses game controller features.Once enabled, you can take advantageof many associated benefits.As mentioned, one of these benefitsis game controller input remapping.And I'm excited tell you about this featurein both iOS and tvOS.Have you ever played a gameand wished the buttons were configured differently?For example, maybe you're in an open world.You have a controller in your handand want your character to look up.What direction do you push the joystick?Well, depending on your preference,you might actually want to invert the Y-axisif it better matches your intuition.This is called input remapping and it's incredibly powerfulfor allowing users to customize their gaming experience.Additionally, it empowers our accessibility communityto enjoy gaming the way they want.In iOS 14 and tvOS 14,we have created a method to support input remapping,even if it's not built directly into your app.There are two ways you can take advantage of input remapping.The first is globally,meaning any button customizations will applyto all game controller apps on your device.The second is per application.It allows you to specify different remappingfor an individual app.Both of these options are availableif you've indicated game controller support in Xcode.Let's take a look at how a user will experience input remapping.In iOS 14, start by connecting one of our supportedgame controllers via Bluetooth.Go to Settings and tap General,where you will now see game controller.Tap Game Controller to see your currently connected device,then tap Customizationsto choose the button you want to customize.I want to remap the R1 button so I'll select that.Let's remap this to the L1 button.Now if you go back, you can see the R1 buttonis remapped to the L1 button.Remember our joystick example?You can invert the joystick axis here as well.Simply click Left Stickand then toggle Invert Vertically.Now let's say you want to add custom remappingfor just one specific app.You can do this by selecting Add Appand choosing one of your game controller supported appsto remap as needed.These customizations will only applyto the app you have selectedrather than all game controller apps you might have.We have input remapping available in tvOS 14 as well.It can be found under Settings > Remotes and Devices > Bluetooth.Then simply select your connected controllerfor customization.So now that you know how global and per appinput remapping work for the user,how can you adopt this in your game?To support global remapping,you simply need to use the game controller frameworkwe reviewed earlier.This ensures the benefit of input remappingacross all apps on the device.For per application remapping,you should additionally check the box called Extended Gamepadin the Game Controller section of Xcode.This allows users to apply unique customizationsto your app specifically.If a user has applied input remapping,you can make sure your in-game UI and tutorials reflect this,along with other controller scenariosyour player might encounter.To enable this, we have added game controller input glyphsto SF Symbols in iOS 14.You no longer need to generate art assets on your own,and Apple keeps this library of glyphsaccurate for all controllers that are supportedtoday and in the future.Like all SF Symbols, you can choose different weightsfor your game controller glyphs.And to match the look and feel of your game,you can choose Light and Dark Mode glyphsas well as tinted colors to go with your design.To learn more, check outIntroducing SF Symbols from WWDC 2019.To find the correct glyph that matches the player's input,you can look at the sfSymbolsName propertyof the GCController element.This works for the button, axis, joystick,trigger, or shoulder button.Here, if I want to display the corresponding glyphfor the classic Y button,it will return the Y in a circle glyphif the input device is an MFI or Xbox controlleror the triangle in a circle glyphif the input device is a DualShock 4.And of course we made sure that the UIaccurately reflects any global or per applicationbutton remapping your player has chosen to do.For example, say the playerremapped the Y button to the X button.When you reference the Y button in your game,it will display the X in a circle glyph in the UI.Your game and your UI are easily responsiveto input remapping decisions like these.And that wraps our section on input remapping and UI glyphs.Now I'll pass it back to James.James: Thanks, Hannah.OK, so let's summarize what we've discussed in this video.We talked about how the extensible input APIcan keep your controller support flexible to any new controllersthat may be added.We went over game controller and Core Haptics integrationthat will allow you to create rich haptic and rumbleexperiences on supported controllers.We dove into how you can support some of the more unique featuresof controllers like motion, lightbar, and battery.We also went over the new input remapping availableon iOS and tvOS and what that means for your game.We talked about new controller button glyphsthat have been added to SF Symbolsand how you can use themto create a polished and adaptive UI.And finally, we showed how updatingyour app's capabilities in Xcodeto indicate extended gamepad supportwill badge your game in the App Store,allow per app input remapping, and futureproof your gamefor any new features that rely on this capability.For more information about this year's game controller update,please visit the Developer sitefor the game controller framework.If you're interested in learning about addingkeyboard and mouse support to your game,watch this year's talk onBring Keyboard and Mouse Gaming to iPadOS.That's it for this year's game controllers update.Thank you for watching.We hope you found this information helpfuland that you use it to create some awesome gameswith game controller support.

♪Hello and welcome to WDDC.

James Kelly: Hello. My name is James Kelly, and I'm a memberof the Game Technologies Engineering team at Apple.

In this video, we'll be talking aboutnew game controller features and changescoming to our platforms this year,and we'll give some adviceon how you can best adopt these new changes.

As a reminder, the game controller frameworkhas a goal to make it easy to add supportfor MFI select third-party game controllers to your gameson iOS, tvOS and MacOS.

By abstracting controller hardware through a common API,the game controller framework lets you write your code oncewithout you having to worry abouthow that controller data is mapped.

This year we're making sure you can take advantage of,and customize, the great features of game controllerslike haptics and rumble, motion, lights,as well as unique inputs like touchpads and paddles.

We'll also show how users can remap their controllers globallyor tune it to their gameto get just the configuration they want.

Before we start, we're excited to announcesome additions to our supported lineup of great controllers.

First up, we've added supportfor the Xbox Elite Wireless Controller Series 2.

It's got a really great feeland it's been highly requested by our users.

We're also really excited to announce supportfor the Xbox Adaptive Controller.

This unique extensible controllerhelps to make gaming more accessible for all.

So developers are creating some great gameswith controller support.

Oceanhorn 2, Sonic Racing, Spyder, and Lego Brawlsare some excellent examples on Apple Arcadeand just a few of the games on the App Storethat support controllers.

By using the game controller framework,these games automatically supportnewly-added controllers like the Xbox Adaptive Controlleror the Xbox Elite Wireless Controller Series 2.

So now let's talk about changes comingto the game controller framework this yearin support of these new controllers.

So let's start by talking about how you can accessthe buttons of these new controllers.

There's a new way to access controller input this year.

GC PhysicalInputProfile, which represents the collectionof all physical inputs available on a controller --meaning its buttons, triggers, Dpads, thumbsticks, and so on.

We're calling this the new Extensible Input APIas it allows your game to dynamically query and supportall of the controller's inputs at runtime --even non-standard inputs like the DualShock 4's touchpador the Xbox Elite Controller's paddle buttons.

Every controller now has a physical input profile.

And so GC ExtendedGamepad and GC MicroGamepadhave both been made subclasses of this GC PhysicalInputProfile.

You're encouraged to still check for the presence of profileslike GC ExtendedGamepad to filter out controllersthat don't have the buttons you need.

You can then use the PhysicalInputProfileto access the controller's unique buttonslike the DualShock 4's touchpad.

So let's take a look at a code exampleto get a sense of these changes.

Let's say we want to add some special shortcutsfor controllers with extra buttons.

First, we'll add an actionthat can instantly trigger an attack combowhich would normally require a combination of button presses.

We'll also track the buttons on the controllerthat we have and have not mapped to actions.

Now let's look at setupConnectedControllerthat is called when a controller connects.

We grab a reference to the physical input profileon the controller.

Remember that every controller will have this profile.

We have a helper function, setupBasicControls,that will set up all the standard controlsfor the face buttons, the left and right thumbsticks,the Dpad, et cetera, and it will also update mapped buttons.

Using that physical input profile,we can then easily grab a reference to a panel button,if one exists, and update our mapped button set.

Finally, we can look at all of the buttons availableon the physical input profile and filter out any buttonsthat have already been mapped.

We can use this to populate an in-game mapping UIwith a list of unused buttons.

So for ease of use,we've added two new subclasses to GC ExtendedGamepad:GC DualShockGamepad and GC XboxGamepad.

The DualShockGamepad exposes the touchpad surfacewith two-finger tracking as well as the touchpad's button.

The XboxGamepad exposes the four paddle buttonsof the Xbox Elite Wireless Controller.

Use extra buttons to augment your gameswith additional convenience controls,but avoid requiring these buttonsas other controllers don't have them.

So one quick note about the paddle buttonson the Xbox Elite Wireless Controller Series 2.

The controller supports hardware button remapping,which can be configured and then stored in one of three profiles.

The selected profile is indicatedby the three LEDs on the front of the controller.

And due to how the controller sends data,the paddle buttons will only work when the controllerdoes not have a button mapping profile selected,meaning that the three LEDs are unlit.

So up next, let's talk about haptics and rumble,one of the most exciting additions to the API this year.

Games coordinate visuals, sounds, and hapticsfrom the controller to more deeply immerse the player.

So great haptics can help give a sensethat your car is driving over gravel,that your character is walking through sand,that you feel the recoil in your trigger finger,or even that a nearby explosion is shaking your room.

Many of our supported controllerscan provide haptic feedback, including the DualShock 4,the Xbox Wireless Controller,and the Xbox Elite Wireless Controller.

And that feedback is programmable,meaning that you have fine-grained controlover the low-level haptic feeling that is played.

These controllers all use different hardwarefor generating haptics.

So let's talk a little bit about how you can easilyadd haptic feedback to your game without having to worry aboutthe physical details of each controller.

So this year we're happy to add game controller supportto Core Haptics, on top of the existing phone haptic support.

Core Haptics is a powerful APIthat allows you to compose and play haptic patternsto customize your app's haptic feedback.

In Core Haptics, you can craft custom haptic patternsfrom basic building blocks called haptic events.

These patterns can be created programmaticallyor stored in Apple haptic and audio pattern, or AHAP, files.

After designing your haptic patterns,you simply create pattern playersfrom a haptic engine to play your haptic content.

Core Haptics and AHAPallows you to design your haptic content onceand then play it everywhere, be it a phone, a DualShock 4,or any one of our other supported devices.

For more information on the detailsof the Core Haptics framework, including some excellentexamples on how to design AHAP content,please watch Introducing Core Haptics from WWDC 2019.

Let's look at a simple practical example.

Haptic feedback is a great way to immerse players in a gameand let them really feel the impact of their gameplay.

So let's say we have a player and an enemy in an action game.

When the enemy attacks the player,they're dealt damage and the controller rumbles.

So how do we achieve this in our gameusing the game controller and Core Haptics frameworks?Well first, we need to design our haptic content.

Here we've programmatically created a haptic patterncalled enemy strike that will play when an enemy attacks.

We can then feed this data into a CHHapticPattern.

Once we have our haptic content designedand loaded into a pattern, we can get ready to play it.

But how do we play it on a controller?Well first we need a GCController instance.

Here representing the Xbox Elite Controllershown on the right.

Next, we can create a CHHapticEnginethat targets the locations on a controllerthat we'd like to play haptics on.

A haptic engine is just an object that managesyour app's requests to play haptic patterns.

Finally, we can create a CHHapticPatternPlayerfrom our engine and our pattern.

Once we call start on this pattern player,our AHAP content will play on our controller.

In this case, just the handles.

You can even layer these pattern players.

The system will automatically combine the hapticsfrom all active patterns for you at runtime,allowing you to create some really dynamic effects.

So how do you create a haptic engine?Simply call createEngineWithLocalityon a controller instance and pass in a GC haptic locality.

This locality defines the physical locationson the controller that the haptic engine will target.

The default haptic locality is geared towards providinga haptic experience that your users would expect.

For example, on game controllers,the default locality typically targets the handles.

You can get more specific if you'd like.

Here we're targeting just the left impulse trigger.

So how do we put all this together?Let's look at a code example.

We begin by creating an instance of a CH haptic engine.

One that targets the handles of the active controller.

The engine is assigned to our member variableso we can keep it around.

After creating the haptic engine, we'll need to start itand check for possible errors.

The engine will continue to run until the applicationor possible outside action stops it.

So let's play some haptics.

Here's the function that executes when the playeris dealt damage by the enemy.

In this example, you want to generate a haptic patternthat scales with the amount of damage that was dealt.

So we have to create the pattern playerand its pattern at the moment they're neededto account for this damage.

Once the pattern player is created,we start it at time CHHapticTimeImmediate,which indicates that we want to play it with minimal latency.

If you had two separate haptic playersthat you wanted to synchronize,you would need to specify an actual time here.

Notice that the app does not hold ontothe instance of the player.

It's pattern is guaranteedto continue playing until it's finished,so we can simply fire and forget it.

Let's look at creating a pattern player.

This method is responsible for creatingthe custom haptic content that will play when we take damage.

We'll create a continuous haptic eventthat applies over a specified duration.

We'll give it a sharpness and intensity.

This will provide a nice baseline of haptic feedback,regardless of how much damage was done to the player.

Next we create a transient haptic event.

These are brief impulsesthat occur at a specific point in timesuch as the click you would feel from toggling a switch.

Note that the transient events don't have a specified duration.

They're just the shortest haptic event that you can produce,so the actual time a transient takeswill vary from controller to controller.

Again, we set the sharpness and intensity.

This time we scale the intensityby the amount of damage that was dealt to the player.

Next, we create the pattern containing these two events.

Finally, we create the pattern player from this patternand return it.

OK. So now that you saw how easy it wasto generate haptic content in Core Haptics,let's talk about how you can transitionyour existing rumble code from other platforms.

In many existing games,haptics are tied directly to the update loop.

This typically means that every update,the engine will set the intensityof each physical actuator on a game controller directly.

With this approach,the engine combines different haptic effects each frame.

Let's talk about how you can migrate a gamethat uses this architecture to Core Haptics.

Our goal is to update the intensitiesof the controller's motors each frame.

To achieve this, we'll need to create a pattern playerso we can send changes to itand then we'll create a long-running patternwith an initial haptic intensity set to one.

In our update loop,we'll just change the intensity of the motors.

To do this, we create a dynamic parameterwith the haptic intensity we calculate for a given motorand then we send it to the pattern player.

We can do this each frame,and as long as our updates are fast enough,the user will feel a continuous change in haptic intensity.

Let's take a quick lookat how we can achieve this in code.

Here we're setting up all the pieces you needto be able to update your controller's motorsin your update loop.

We're setting up our pattern player,which will later send new intensities to each update.

In this function, we'll create a long-running,continuous haptic eventwith a haptic intensity set to the max value of one.

We'll use the continuous event to create a haptic pattern.

And finally, we'll create our pattern playerand start it immediately.

You'll need to hold onto this, as you'll be using it later.

Now in our update loop,we're also going to update our haptics.

This is where we update the intensity of our motors.

We create a dynamic parameter targeting haptic intensity.

These are similar to the parametersused to generate events,except these could be applied dynamicallyto an already-running pattern,and they apply to the entire pattern,not just a single event.

Here, haptic engine motor intensityrepresents the intensity of the motor from 0 to 1as calculated by the engine for this frame.

This will act as a multiplier on the pattern player's intensity.

We finish up by sending our dynamic intensity parameterto our pattern player.

Please note that this exampleonly covers one CH haptic engine.

You will need to repeat this approach for each motorif you would like to control themindependently from one another.

Next up, let's talk about some other featuresthat we've added to the Game Controller framework this yearthat'll help you to fully utilizethe extended capabilities of newly-supported controllers.

Let's start by looking at a situationthat single-player games frequently need to handle.

Your game launches, and you see multiple controllers connected.

Particularly with the Apple TV, it's common to seethe Siri Remote and a game controller --but which one should you take input from?How do you know which controlleris currently being used by the player?You could register your controller connectionand disconnection handlersand manage the lifecycles of the controllers,but you still need to track when a controller becomes activeto update the UI and controlsas the user switches between input devices.

This is why we're introducing some new APIto handle this for you.

We've added the current property to GCControllerwhich always returns the most recently-used controlleror nil if no controller is connected.

We've also added two new notificationsthat you can observe to properly respondto the current controller changing.

GCControllerDidBecomeCurrentand GCControllerDidStopBeingCurrent.

Single-player games should adaptto the currently active game controllerby using this property.

By listening to the notifications,you can easily adapt your UIto reflect the currently used controller.

Next, let's talk aboutthe motion sensors on the DualShock 4.

The DualShock 4 has a gyroscope,meaning that it knows its rotation rate in 3D spaceallowing for some great gameplay possibilities.

One common technique is to use the gyroscopefor fine-tuned camera aimingwith the thumbsticks used for more coarse aiming.

The DualShock 4 also has an accelerometer.

There are many ways to use accelerometer.

For example, you can detect whether the controlleris tilted to the left or the rightfor driving controls in a racing gameor you can interpret high, rapid shifts in accelerationas a shake gesture to make your player character attack.

We've introduced support for the DualShock 4'smotion sensors via GCMotion, a property on GCController.

For those of you familiar withsupporting the Siri Remote on tvOS,we're using the same API here but with a few tweaks.

When supporting the DualShock 4,you need to manually turn the motion sensors on and offto preserve battery.

You can query whether you need to manage the sensors yourselfor leave it up to the system like with the Siri Remote.

Set motion.sensorsActiveto toggle motion sensors on and off.

Additionally, some controllers like the DualShock 4do not separate gravity from user accelerationand only report that total acceleration of the controller.

Query whether the connected controller has the abilityto separate gravity from user acceleration,and if it doesn't, use the total acceleration instead.

The next feature I want to tell you aboutis the DualShock 4's lightbar.

It's usually used as a player indicatorbut you can also use it for game effects.

For example, it could flash a different colorwhen the player walks into lavaor shine green, then yellow, then redas the player loses health.

We've surfaced support for the DualShock 4's lightbarvia GCDeviceLight, a property on GCController.

It's easy to change the color of a DualShock 4 lightbar.

Just set the GCDeviceLight color value.

Here, we're setting the color to red.

Nowadays, many controllers are wirelessand may need charging.

We're making battery state available to youso that you can show it in your UI,particularly in low battery situations.

This is provided via GCDeviceBattery,a property on GCController.

You can check the level of the batteryas well as its charging state,whether it's charging, discharging, or fully charged.

You can then use key value observing (or KVO)to monitor any changes to the battery.

Now I'd like to introduce my colleague Hannah Gillis,who will give some tips on how to best take advantageof our new input remapping feature.

Hannah Gillis: Thanks, James.

Let's talk about how you can indicatethat your app supports game controllersand the benefits that come along when you do so.

There are a few reasons to indicate controller support.

First, it surfaces information on the App Store and on Apple TVto communicate to userswhen a controller is required for an application.

A game controller badge will be listed on the app's product pageto visually declare this info.

Second, indicating controller support provides the abilityfor input remapping in your application,which I'll discuss shortly.

For these reasons, we highly recommend you update your appsfor the best user experience.

To indicate controller support,you should enable the game controllers capability in Xcode.

This informs the systemthat your app uses game controller features.

Once enabled, you can take advantageof many associated benefits.

As mentioned, one of these benefitsis game controller input remapping.

And I'm excited tell you about this featurein both iOS and tvOS.

Have you ever played a gameand wished the buttons were configured differently?For example, maybe you're in an open world.

You have a controller in your handand want your character to look up.

What direction do you push the joystick?Well, depending on your preference,you might actually want to invert the Y-axisif it better matches your intuition.

This is called input remapping and it's incredibly powerfulfor allowing users to customize their gaming experience.

Additionally, it empowers our accessibility communityto enjoy gaming the way they want.

In iOS 14 and tvOS 14,we have created a method to support input remapping,even if it's not built directly into your app.

There are two ways you can take advantage of input remapping.

The first is globally,meaning any button customizations will applyto all game controller apps on your device.

The second is per application.

It allows you to specify different remappingfor an individual app.

Both of these options are availableif you've indicated game controller support in Xcode.

Let's take a look at how a user will experience input remapping.

In iOS 14, start by connecting one of our supportedgame controllers via Bluetooth.

Go to Settings and tap General,where you will now see game controller.

Tap Game Controller to see your currently connected device,then tap Customizationsto choose the button you want to customize.

I want to remap the R1 button so I'll select that.

Let's remap this to the L1 button.

Now if you go back, you can see the R1 buttonis remapped to the L1 button.

Remember our joystick example?You can invert the joystick axis here as well.

Simply click Left Stickand then toggle Invert Vertically.

Now let's say you want to add custom remappingfor just one specific app.

You can do this by selecting Add Appand choosing one of your game controller supported appsto remap as needed.

These customizations will only applyto the app you have selectedrather than all game controller apps you might have.

We have input remapping available in tvOS 14 as well.

It can be found under Settings > Remotes and Devices > Bluetooth.

Then simply select your connected controllerfor customization.

So now that you know how global and per appinput remapping work for the user,how can you adopt this in your game?To support global remapping,you simply need to use the game controller frameworkwe reviewed earlier.

This ensures the benefit of input remappingacross all apps on the device.

For per application remapping,you should additionally check the box called Extended Gamepadin the Game Controller section of Xcode.

This allows users to apply unique customizationsto your app specifically.

If a user has applied input remapping,you can make sure your in-game UI and tutorials reflect this,along with other controller scenariosyour player might encounter.

To enable this, we have added game controller input glyphsto SF Symbols in iOS 14.

You no longer need to generate art assets on your own,and Apple keeps this library of glyphsaccurate for all controllers that are supportedtoday and in the future.

Like all SF Symbols, you can choose different weightsfor your game controller glyphs.

And to match the look and feel of your game,you can choose Light and Dark Mode glyphsas well as tinted colors to go with your design.

To learn more, check outIntroducing SF Symbols from WWDC 2019.

To find the correct glyph that matches the player's input,you can look at the sfSymbolsName propertyof the GCController element.

This works for the button, axis, joystick,trigger, or shoulder button.

Here, if I want to display the corresponding glyphfor the classic Y button,it will return the Y in a circle glyphif the input device is an MFI or Xbox controlleror the triangle in a circle glyphif the input device is a DualShock 4.

And of course we made sure that the UIaccurately reflects any global or per applicationbutton remapping your player has chosen to do.

For example, say the playerremapped the Y button to the X button.

When you reference the Y button in your game,it will display the X in a circle glyph in the UI.

Your game and your UI are easily responsiveto input remapping decisions like these.

And that wraps our section on input remapping and UI glyphs.

Now I'll pass it back to James.

James: Thanks, Hannah.

OK, so let's summarize what we've discussed in this video.

We talked about how the extensible input APIcan keep your controller support flexible to any new controllersthat may be added.

We went over game controller and Core Haptics integrationthat will allow you to create rich haptic and rumbleexperiences on supported controllers.

We dove into how you can support some of the more unique featuresof controllers like motion, lightbar, and battery.

We also went over the new input remapping availableon iOS and tvOS and what that means for your game.

We talked about new controller button glyphsthat have been added to SF Symbolsand how you can use themto create a polished and adaptive UI.

And finally, we showed how updatingyour app's capabilities in Xcodeto indicate extended gamepad supportwill badge your game in the App Store,allow per app input remapping, and futureproof your gamefor any new features that rely on this capability.

For more information about this year's game controller update,please visit the Developer sitefor the game controller framework.

If you're interested in learning about addingkeyboard and mouse support to your game,watch this year's talk onBring Keyboard and Mouse Gaming to iPadOS.

That's it for this year's game controllers update.

Thank you for watching.

We hope you found this information helpfuland that you use it to create some awesome gameswith game controller support.

2:53 -Extensible input API

8:45 -Starting the Haptic Engine

9:05 -Play haptics

9:49 -Creating a haptic pattern

12:28 -Updating haptics every frame

14:11 -Current controller notifications

15:25 -Manual activation

15:44 -Using total acceleration

16:27 -Setting up the lightbar

22:36 -Input glyphs with SF Symbols

## Code Samples

```swift
// Extensible input API example



var
 attackComboBtn: 
GCControllerButtonInput
?

var
 mapBtn: 
GCControllerButtonInput
?

var
 mappedButtons 
=
 
Set
<
GCControllerButtonInput
>()

var
 unmappedButtons 
=
 
Set
<
GCControllerButtonInput
>()


func
 
setupConnectedController
(
_
 
controller
: 
GCController
)
 {
    
let
 input 
=
 controller.physicalInputProfile
    
    
// Set up standard button mapping

    setupBasicControls(input)
    
    
// Map a shortcut to the player's special combo attack

    attackComboBtn 
=
 input.buttons[
"Paddle 1"
]
    
if
 (attackComboBtn 
!=
 
nil
) { mappedButtons.insert(attackComboBtn
!
) }
    
    
// Map a shortcut to the in-game map

    mapBtn 
=
 input.buttons[
GCInputDualShockTouchpadButton
]
    
if
 (mapBtn 
!=
 
nil
) { mappedButtons.insert(mapBtn
!
) }
    
    
// Find buttons that havent' been mapped to any actions yet

    unmappedButtons 
=
 input.allButtons.filter { 
!
mappedButtons.contains(
$0
) }
}
```

```swift
private
 
func
 
createAndStartHapticEngine
()
 {
    
// Create and configure a haptic engine for the active controller

    
    
guard
 
let
 controller 
=
 activeController 
else
 { 
return
 }
    
    hapticEngine 
=
 controller.haptics
?
.createEngine(withLocality: .handles)
    
    
guard
 
let
 engine 
=
 hapticEngine 
else
 {
        
print
(
"Active controller does not support handle haptics"
)
        
return

    }
```

```swift
// Play haptics whenever the player is damaged



private
 
func
 
playerWasDamaged
(
damage
: 
Float
)
 {
    
do
 {
        
// Calculate the magnitude of damage as percentage of range [0, maxPossibleDamage]

        
let
 damageMagnitude: 
Float
 
=
 
...

        
        
// Create a haptic pattern player for the player being hit by an enemy

        
let
 hapticPlayer 
=
 
try
 patternPlayerForPlayerDamage(damageMagnitude)
        
        
// Start player, "fire and forget".

        
try
 hapticPlayer
?
.start(atTime: 
CHHapticTimeImmediate
)
    } 
catch
 
let
 error {
        
print
(
"Haptic Playback Error: 
\(error)
"
)
    }
}
```

```swift
// Create a haptic pattern that scales to the damage dealt to the player



private
 
func
 
patternPlayerForPlayerDamage
(
_
 
damage
: 
Float
)
 
throws
 -> 
CHHapticPatternPlayer
? {
    
let
 continuousEvent 
=
 
CHHapticEvent
(eventType: .hapticContinuous, parameters: [
        
CHHapticEventParameter
(parameterID: .hapticSharpness, value: 
0.5
),
        
CHHapticEventParameter
(parameterID: .hapticIntensity, value: 
0.3
),
    ], relativeTime: 
0
, duration: 
0.6
)
    
    
let
 firstTransientEvent 
=
 
CHHapticEvent
(eventType: .hapticTransient, parameters: [
        
CHHapticEventParameter
(parameterID: .hapticSharpness, value: 
0.5
),
        
CHHapticEventParameter
(parameterID: .hapticIntensity, value: 
0.9
 
*
 damage),
    ], relativeTime: 
0.2
)
    
    
let
 secondTransientEvent 
=
 
CHHapticEvent
(eventType: .hapticTransient, parameters: [
        
CHHapticEventParameter
(parameterID: .hapticSharpness, value: 
0.5
),
        
CHHapticEventParameter
(parameterID: .hapticIntensity, value: 
0.9
 
*
 damage),
    ], relativeTime: 
0.4
)
    
    
let
 pattern 
=
 
try
 
CHHapticPattern
(events: [continuousEvent, firstTransientEvent,
                                               secondTransientEvent], parameters: [])
    
    
return
 
try
 engine.makePlayer(with: pattern)
}
```

```swift
// Update the state of the connected controller's haptics every frame



private
 
func
 
update
()
 {
    updateHaptics()
}


private
 
func
 
updateHaptics
()
 {
    
// Update the controller's haptics by sending a dynamic intensity parameter each frame

    
do
 {
        
// Create dynamic parameter for the intensity.

        
let
 intensityParam 
=
 
CHHapticDynamicParameter
(parameterID: .hapticIntensityControl,
                                                        value: hapticEngineMotorIntensity,
                                                        relativeTime: 
0
)
        
        
// Send parameter to the pattern player.

        
try
 hapticsUpdateLoopPatternPlayer
?
.sendParameters([intensityParam],
                                 atTime: 
CHHapticTimeImmediate
)
    } 
catch
 
let
 error {
        
print
(
"Dynamic Parameter Error: 
\(error)
"
)
    }
}
```

```swift
NSNotification
.
Name
.
GCControllerDidBecomeCurrent


NSNotification
.
Name
.
GCControllerDidStopBeingCurrentNotification
```

```swift
if
 motion.sensorsRequireManualActivation {
    motion.sensorsActive 
=
 
true

}
```

```swift
if
 motion.hasGravityAndUserAcceleration {
    handleMotion(gravity: motion.gravity, userAccel: motion.userAcceleration)
} 
else
 {
    handleMotion(totalAccel: motion.acceleration)
}
```

```swift
guard
 
let
 controller 
=
 
GCController
.current 
else
 { 
return
 }
controller.light
?
.color 
=
 
GCColor
.
init
(red: 
1.0
, green: 
0
, blue: 
0
)
```

```swift
let
 xboxButtonY 
=
 xboxController.physicalInputProfile[
GCInputButtonY
]
!


guard
 
let
 xboxSfSymbolsName 
=
 xboxButtonY.sfSymbolsName 
else
 { 
return
 }

let
 xboxButtonYGlyph 
=
 
UIImage
(systemName: xboxSfSymbolsName)


let
 ds4ButtonY 
=
 ds4Controller.physicalInputProfile[
GCInputButtonY
]
!


guard
 
let
 ds4SfSymbolsName 
=
 ds4ButtonY.sfSymbolsName 
else
 { 
return
 }

let
 ds4ButtonYGlyph 
=
 
UIImage
(systemName: ds4SfSymbolsName)
```


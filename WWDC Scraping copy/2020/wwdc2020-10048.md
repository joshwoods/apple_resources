# Wwdc2020 10048

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Build complications in SwiftUISpice up your graphic complications on Apple Watch using SwiftUI. We'll teach you how to use custom SwiftUI views in complications on watch faces like Meridian and Infograph, look at some best practices when creating your complications, and show you how to preview your work in Xcode 12.

To get the most out of this session, you should be familiar with the basics of SwiftUI and building complications on Apple Watch. For an overview, watch “Create Complications for Apple Watch” and read “Building watchOS App Interfaces with SwiftUI.”

Once you've discovered how to build graphic complications in SwiftUI, you can combine this with other watchOS 7 features like multiple complications and Face Sharing to create a watch face packed with personality and customized for people who love your app.ResourcesBuilding a watchOS appClockKitCreating and updating a complication’s timelineHD VideoSD VideoRelated VideosWWDC22Go further with Complications in WidgetKitWWDC21Swift concurrency: Update a sample appWWDC20Create complications for Apple WatchKeep your complications up to dateMeet Watch Face SharingWhat's new in SwiftUI

Spice up your graphic complications on Apple Watch using SwiftUI. We'll teach you how to use custom SwiftUI views in complications on watch faces like Meridian and Infograph, look at some best practices when creating your complications, and show you how to preview your work in Xcode 12.

To get the most out of this session, you should be familiar with the basics of SwiftUI and building complications on Apple Watch. For an overview, watch “Create Complications for Apple Watch” and read “Building watchOS App Interfaces with SwiftUI.”

Once you've discovered how to build graphic complications in SwiftUI, you can combine this with other watchOS 7 features like multiple complications and Face Sharing to create a watch face packed with personality and customized for people who love your app.

Building a watchOS app

ClockKit

Creating and updating a complication’s timeline

HD VideoSD Video

HD Video

SD Video

Go further with Complications in WidgetKit

Swift concurrency: Update a sample app

Create complications for Apple Watch

Keep your complications up to date

Meet Watch Face Sharing

What's new in SwiftUI

Search this video…Hello and welcome to WWDC.Hi, my name is Matthew Koonce and I'm a watchOS SwiftUI engineer.I'll be joined later by my colleague, August.Today we get to dive into all the awesome things you can buildwith SwiftUI complications.Complications are how you display timely and relevant information about your appon the watch face.Some of the most powerful and useful complicationsare able to distill complex informationinto something that can be quickly understood at a glance.For example, the UVI complication features vertical gauges with a color gradientwhich quickly tells me that sunscreen would be a good choice today.Building complications like the UVI chart can be challenging.But with SwiftUI complications,you can bring your knowledge about SwiftUI right to the watch face.And of course,we can't have SwiftUI complications without Xcode previews.Now you can view your complications on different faces at the same time.So todaywe're going to take a look at how you can build your own complication in SwiftUI.To do that,we'll look at the new API in ClockKit and SwiftUI that make this all possible.We'll see how our SwiftUI views work with watch face tintingand some best practices.Let's get started with the API.In order to use SwiftUI views in complications,we turn to our trusty complication templates.ClockKit has dozens of predefined templatesthat provide easy-to-use layouts for your complications.New in watchOS 7,we've added templates that take a SwiftUI viewright alongside other ClockKit providers.These templates are for the Graphic Corner,Circular, Rectangular...and Extra Large families.But where SwiftUI really shinesare the templates that take just a single SwiftUI view.These templates provide a full canvas for drawing in each family.And the GraphicRectangularFullView templateis a brand-new template that gives you an even larger canvas for drawing.And with that canvas, you can use SwiftUI to do just about anything.SwiftUI's powerful drawing library is at your full disposal,allowing you to easily create novel designs for complicationslike this awesome tide chart from Dawn Patrol.So that's how you can get your SwiftUI views into ClockKit templates.We've also made changes in SwiftUIthat bring more power and flexibility to complications.First, let's talk about text.We've updated text to be aware of the complication family it will appear on.The default font size will change for each family.For example, this same text shown here in the GraphicRectangular complicationwill be much larger on the Extra Large face.The default font has also changed to SF Roundedto look right at home on the face.Additionally, text features new date formattersthat work great on the watch face.In particular, the relative, offset and timer styleswill be automatically kept up-to-date by the watch face.For example,using the relative style for this datewill make sure it's always accurate relative to now.Same for the timer style.I can place the date right inside an interpolated stringand it will automatically show the time remaining on my Sourdough Timer.So that's the improvements we've made to text.Next, let's look at two popular controlsfrom complications that we've brought right into SwiftUI.Those are Progress View and Gauge.Both Progress View and Gauge are super useful,and each have a specific purpose.Progress View is great for information that progresses in a linear fashion,like music.And the Gauge is great for information that varies over time, like temperature.Let's start with Progress View.In its most simple setup,Progress View just has a single value and can be set with a style.In this case, we're using the Circular style.We can also add a label to the Progress View which describes its purpose.In our case, we're using the music note SF symbol.Finally, Progress Views can be tinted,completing the look of our musical Progress View.Progress View also comes in a linear style.And all the same API works just like you'd expect.Next, let's look at Gauge.Gauge is a superpowerful control with a ton of configuration options.Let's take a look.Here we have a simple Gauge that shows the soil acidity level of our garden.It's using the CircularGaugeStyle.We can also add a current value labelthat will appear in the center of the Gaugeto provide some context at a glance.For some Gauges, it might be useful to label the start and end values.In our case, our Gauge is from three to ten.So let's add those labels with the minimum and maximum value labels.Like Progress View, Gauge can also be tinted with a color.Here we add a green color.But where Gauges really come into their own is with a gradient tint.By using SwiftUI's gradient,I can easily specify the color stops for my acidity Gauge.Gauge also comes in a linear stylewhich is great for Rectangular complicationslike on the Modular Compact face.So that's the Gauge API.But one thing to remember is that both Gauge and Progress Viewsare available in SwiftUI as a new control that you can build as needed.For example, we can use a Circular Gauge in a Rectangular complication...or use Gauges right in the app.So that's the new API we've added to SwiftUI and ClockKit.Next, let's talk about one of my favorite features of watch faces,watch face tinting.Watch faces support a full range of tinted colors,allowing for even more personalization.Complications take on this face color, giving each face a unique style.Some faces, like the Solar Dial face, take this a step furtherand alters the tint color and the color of each complication as the day progresses.So understanding how your complication will behave on a tinted watch faceis intrinsic to the design of your complication.So let's dive into how watch face tinting works.I have a full color view here of a yellow apple over a blue circle.When the watch face becomes tinted by a color,one of two possible tinting effects will be applied.The first is a desaturated tint.And the second is a color opacity tint.Let's start by talking about desaturated tinting.Desaturated tinting is the default tinting mode for complications.When the watch face is tinted, it creates a grayscale version of your view.Some faces, like the Extra Large face,may apply a single color over this desaturated view.Let's see how we can build a SwiftUI complicationthat becomes desaturated on the watch face.Here I have the code for my view which is a ZStack of a circle and an apple image.On the watch face that looks pretty good.When the watch face color is changed to red...you can see that the default desaturation mode kicks in,and the view becomes desaturated automatically on the watch face.And on the Extra Large face,a single color is applied over the desaturated view.So that's pretty easy.With no changes to our SwiftUI view, we get a good tinted complication.With that said, be mindful about the colors you choose for your complication.If I had instead chosen colors with a similar brightness,the apple will just disappear when the view is desaturated.So it's important to consider how your view will look desaturatedwhen building a complication.So that's desaturated tinting.Next, let's look at color opacity tinting.While desaturated tinting is the default tinting behavior,color opacity is an alternative tinting style that we can opt into.This tinting style works by creating layers within our complication.And then the watch face applies a color to each layer.Starting with our fullColor view,we first want to identify the layers of our complication.Watch faces support two distinct layers.In this case, we've chosen the circle to be separated from the apple.These will now be our two layers.Next, as the name implies,the watch face only considers the opacity of each view.Since each of these views are at full opacity, they both become white.Then the watch face applies a color to the appropriate layer.Each watch face determines the color applied to each layer.In this case, the watch face determined that the circle's layer should become redand the apple's layer should remain white.Then the layers are brought back together.It's up to the watch face to define how the chosen color is applied to each layer.On the Extra Large face, for example, our apple is white on a red background...but will be red on a white background on the Meridian face.And other faces, like the Solar Dial face,may apply a different color to both layers.So let's return to our example, this time using the Extra Large faceand see how we can make our complication use a color opacity tint.I want my circle and my apple to each be in their own distinct layer.By default, all view content is considered to be in the background layer.By applying the complicationForeground modifier,I've determined that the apple imageshould be promoted to the foreground layer.And the circle will remain in the background layer.Now that I have distinct layers, color opacity tinting kicks in.When the watch face color is changed to red...the apple now becomes white and the circle becomes red.If I change the color of the face again,you'll see that the background changes right along with it.On the Extra Large face,the background layer was given the watch face color.Let's look at a different face.On the Meridian face, you'll notice that the opposite layers are colored.So that's color opacity tinting,where we create distinct opacity layers within our view hierarchy.Then the watch face applies a color to these layers for a striking result.In some cases,you may want to make additional changes to your view for tinting.For example,you may want to change the background color to use a gradient.Or you may want to remove the background entirely.We can do that with the new ComplicationRenderingMode.The rendering mode has two values,fullColor for when this view is being rendered for a full color face,and tinted for when this view will be shown on a tinted face.We can get the current value out of the environment.Let's return to our exampleand see how we can use the ComplicationRenderingMode.First, I can use the environment to get the current rendering mode.Next, let's use the rendering mode by changing the fill of our circleand the complication is for color or tinted.We'll add a switch statementto check for the current value of rendering mode.In the fullColor case,we keep our circle exactly the sameusing a blue fill color...but in the tinted case, we're gonna change the fill entirely.Instead of a single color, we're gonna use a linear gradient.In particular,a gradient that only changes the opacity of this view.Recall from earlier,this is a color opacity complication.Therefore the opacity of the viewis the only thing being considered when it's shown onscreen.Since the opacity is the only thing we can change,this gradient goes from an opacity of one to an opacity of zero.So now we have a tinted complicationwith an opacity gradient fill in tinted modeand a blue fill in fullColor mode.That was a lot of information,so let's go over some key takeaways.First, by default, a SwiftUI view will be desaturated on the watch face.If you want a color opacity complication,use the complicationForeground modifierto group pieces of a view together for tinting.And finally, the ComplicationRenderingModeallows for advanced customization of a viewfor fullColor and tinted complications.So now we've learned about all the new APIthat you can use to build amazing SwiftUI complications.But to see it all happen in action, I'd like to hand it over to August.Thank you, Matthew.I'm August Joki, a watch face engineer,and I'm gonna show you how to use what we've learned in Xcode.Not long ago, we released new sample code for creating and updating complications.It's called Coffee Tracker. Here's what the app looks like.It already includes complications.This'll make a great place to show off the new SwiftUI complication features.Matthew and I have been working on incorporating a new SwiftUI viewto show the user their historical caffeine consumption.They can see the equivalent number of cups of coffee consumed in the past week,and the chart incorporates the colors of the app.The view's turning out really nice,and we think it'd make a great Graphic Rectangular complication.Let's go to Xcodeto see how to incorporate SwiftUI and complication templatesand how to support the two options for tinting.While previously working on the History View of the app,we set up a preview to quickly see changes we make to our view.Simple views may not need any changes for inclusion in a complicationor only need a new property or twoto key off of for rendering in a complication.But because our chart is fairly complex,we decided we will create a new view to use in our complication.The separate view allows us to encapsulate any changesthat are specific to the complication.We add the new view to our previewbecause we want to see the Apps version of the HistoryViewalongside our new ComplicationHistoryViewto ensure we are not accidentally modifying it.Let's take the HistoryChart part of the HistoryViewto use in our complication.To preview our complication, we start by creatinga FullViewGraphicRectangularTemplate using the new SwiftUI view.But the template is not a SwiftUI view itselfso it can't be previewed on its own.To address this,we've added a new function to CLKComplicationTemplate:previewContext.It is defined when both ClockKit and SwiftUI are imported together.The function wraps the template in a SwiftUI viewthat Previews knows how to transform into a clock facewith a complication template set on it.Every complication template previewed is set on a facethat is best suited for its family.Thanks to the power of SwiftUI,our complication looks almost done right out of the gate.But the default Graphic Rectangular font size is a bit largefor the kind of content we are displaying.Let's start by fixing that.We add a font modifier to the chartto set a size more suitable for displaying in our complication.We also wanna take up all the available spacefor the GraphicRectangular FullView template.Matthew will explain complication safe areas in more detail later.That font size looks great.And since we can see our chart is next to other complications on the watch face,we should provide some context for our complications data.Adding a title is a great way to provide that context.Since this is all SwiftUI, we can add "Weekly Coffee" as a textand wrap it up together with the History Chart in a VStack.And now that is looking really polished.But what does our complication look like when the face is tinted?To find out, let's set the preview's face color to blue.Nothing is blending together, but we lost all of our color.Let's use complicationForeground to make the title adopt the tint color.Now our title's automatically tinted to match the color of the face.Since we are focusing on supporting tinting,let's focus our previews on tinting too.Now we can see what a multicolor face looks like right next to a tinted face.And I've just noticed that using complicationForegroundalso made the gradient and the Gauges disappear.That's because, as soon as we adopt tinting support,our complication is no longer getting desaturated.Instead, only the opacity of our view hierarchy is used.That means everything in the hierarchy is reduced to their opacity values,the parts marked with complicationForegroundare grouped togetherand have the same color wash applied to them.As we learned earlier, we have another way to work with tinting:the ComplicationRenderingMode environment value.Let's use it to change how we render the chart when tinted.But first, let's paint our previews so that we can watch in real timethe complication update as we are making changes to a different file.Here we have the view that creates a column for a given day.We add an environment property for ComplicationRenderingModeand pass the new property to our custom HistoryGaugeStyleto hide the background when tinted.We can see that the chart now renders differentlyfrom the fullColor case.With ComplicationRenderingMode,we are able to change pieces of our view hierarchywhile keeping the code pads from drastically divergingbetween fullColor and tinted rendering.Let's go back to ComplicationHistoryView.We've seen what our new complication looks like with a blue face color,but what about the other sample preview colors?We can take advantage of the power of using ClockKit and SwiftUI togetherto enumerate the PreviewFaceColors to see them all at the same time.We can now make sure our complication looks goodwith a sampling of different options a user could set for their face color.I've shown you how easy it is to use SwiftUI and complication templates,how to quickly support tinting with complicationForegroundand how to make use of complicationRenderingModefor finer-grained tinting control.And now I'll hand it back to Matthew to talk about best practices. Thank you.Thanks, August. That was some pretty cool stuff.SwiftUI makes it really seamless to create compelling chartslike our weekly summary view.It has never been easier to turn that into a complication.Next, let's talk about some best practices to considerwhen building your own SwiftUI complication.First, it's important to knowthat tapping anywhere on a complication will always launch your app.Buttons, gestures and other interactive elementsare not supported in complications.Stick to text, images and drawing primitiveswhen building your complication.We've added a new runtime warning to Xcode,in case you try to use a view that is not compatible with complications.And finally, remember that a complication is a timeline composed of static views.Therefore, SwiftUI animations are not supported.We want you to also considerthe performance characteristics of your view.In order to keep the watch face performing at a high level,every SwiftUI view's performance is measured before it's shown on screen.Consult the Human Interface Guidelines and our documentation to ensure you useappropriately sized images for each complication...and be mindful about the runtime costs of certain drawing attributes,such as blurs and formatted text,and only use what is absolutely necessary.Note that poorly performing views may penalize your complication's runtime.Watch out for runtime warnings like this oneregarding the size or complexity of your view.If your complication is giving a runtime warning like this,treat it like a build errorand make sure you fix it before shipping your complicationfor the best experience for your customers.Finally, some layout best practices.Use the default font size for each complicationas a guide for the kinds of views that you should build.For example, the Extra Large complication may have a large canvas for drawing,but its purpose is to provide large and easy-to-see information.Note that the Circular and Rectangular complication familieswill mask your content to their respective shapes.And the Rectangular Full View complication features a safe area for layoutto help prevent your content from being clipped on the watch face.This new larger drawing areacould be clipped by the corners of the Apple Watch displayon certain watch faces.By default, the safe area provides you with space that's safefor all complication placements.If you'd like to use the full area of the complication,like we did for the Weekly Coffee complication,you can use the edgesIgnoringSafeArea modifier.This will give you that little bit of extra space.Be mindful, though, about the layout of your contentto prevent it being clipped.So that was a look at some of the awesome thingsthat you can now do with SwiftUI complications.We saw how, for the first time,you can bring your knowledge about SwiftUI right to the watch face.We saw some great new APIs for Text, Progress View and Gaugeand how our complications are tinted on the watch face.And how you can use Xcode previewsto work on multiple complications at the same timeand on different watch face colors.If you've never built a complication before,or you wanna freshen up your knowledgeabout complication templates and descriptors,check out the "Create Complications for Apple Watch" talk.And to make sure your complications are always showingthe right information at the right time,I highly recommend watching "Keep Your Complications Up to Date."Thank you.[chimes]

Hello and welcome to WWDC.

Hi, my name is Matthew Koonce and I'm a watchOS SwiftUI engineer.

I'll be joined later by my colleague, August.Today we get to dive into all the awesome things you can buildwith SwiftUI complications.Complications are how you display timely and relevant information about your appon the watch face.Some of the most powerful and useful complicationsare able to distill complex informationinto something that can be quickly understood at a glance.For example, the UVI complication features vertical gauges with a color gradientwhich quickly tells me that sunscreen would be a good choice today.

Building complications like the UVI chart can be challenging.But with SwiftUI complications,you can bring your knowledge about SwiftUI right to the watch face.And of course,we can't have SwiftUI complications without Xcode previews.Now you can view your complications on different faces at the same time.

So todaywe're going to take a look at how you can build your own complication in SwiftUI.To do that,we'll look at the new API in ClockKit and SwiftUI that make this all possible.

We'll see how our SwiftUI views work with watch face tintingand some best practices.Let's get started with the API.

In order to use SwiftUI views in complications,we turn to our trusty complication templates.ClockKit has dozens of predefined templatesthat provide easy-to-use layouts for your complications.

New in watchOS 7,we've added templates that take a SwiftUI viewright alongside other ClockKit providers.These templates are for the Graphic Corner,Circular, Rectangular...

and Extra Large families.But where SwiftUI really shinesare the templates that take just a single SwiftUI view.These templates provide a full canvas for drawing in each family.

And the GraphicRectangularFullView templateis a brand-new template that gives you an even larger canvas for drawing.

And with that canvas, you can use SwiftUI to do just about anything.SwiftUI's powerful drawing library is at your full disposal,allowing you to easily create novel designs for complicationslike this awesome tide chart from Dawn Patrol.So that's how you can get your SwiftUI views into ClockKit templates.We've also made changes in SwiftUIthat bring more power and flexibility to complications.

First, let's talk about text.We've updated text to be aware of the complication family it will appear on.The default font size will change for each family.For example, this same text shown here in the GraphicRectangular complicationwill be much larger on the Extra Large face.The default font has also changed to SF Roundedto look right at home on the face.

Additionally, text features new date formattersthat work great on the watch face.In particular, the relative, offset and timer styleswill be automatically kept up-to-date by the watch face.

For example,using the relative style for this datewill make sure it's always accurate relative to now.

Same for the timer style.I can place the date right inside an interpolated stringand it will automatically show the time remaining on my Sourdough Timer.

So that's the improvements we've made to text.Next, let's look at two popular controlsfrom complications that we've brought right into SwiftUI.Those are Progress View and Gauge.

Both Progress View and Gauge are super useful,and each have a specific purpose.

Progress View is great for information that progresses in a linear fashion,like music.And the Gauge is great for information that varies over time, like temperature.Let's start with Progress View.

In its most simple setup,Progress View just has a single value and can be set with a style.

In this case, we're using the Circular style.

We can also add a label to the Progress View which describes its purpose.In our case, we're using the music note SF symbol.

Finally, Progress Views can be tinted,completing the look of our musical Progress View.

Progress View also comes in a linear style.And all the same API works just like you'd expect.Next, let's look at Gauge.

Gauge is a superpowerful control with a ton of configuration options.Let's take a look.

Here we have a simple Gauge that shows the soil acidity level of our garden.It's using the CircularGaugeStyle.

We can also add a current value labelthat will appear in the center of the Gaugeto provide some context at a glance.

For some Gauges, it might be useful to label the start and end values.In our case, our Gauge is from three to ten.So let's add those labels with the minimum and maximum value labels.

Like Progress View, Gauge can also be tinted with a color.Here we add a green color.

But where Gauges really come into their own is with a gradient tint.By using SwiftUI's gradient,I can easily specify the color stops for my acidity Gauge.

Gauge also comes in a linear stylewhich is great for Rectangular complicationslike on the Modular Compact face.

So that's the Gauge API.But one thing to remember is that both Gauge and Progress Viewsare available in SwiftUI as a new control that you can build as needed.For example, we can use a Circular Gauge in a Rectangular complication...

or use Gauges right in the app.

So that's the new API we've added to SwiftUI and ClockKit.Next, let's talk about one of my favorite features of watch faces,watch face tinting.

Watch faces support a full range of tinted colors,allowing for even more personalization.Complications take on this face color, giving each face a unique style.

Some faces, like the Solar Dial face, take this a step furtherand alters the tint color and the color of each complication as the day progresses.

So understanding how your complication will behave on a tinted watch faceis intrinsic to the design of your complication.So let's dive into how watch face tinting works.

I have a full color view here of a yellow apple over a blue circle.When the watch face becomes tinted by a color,one of two possible tinting effects will be applied.

The first is a desaturated tint.And the second is a color opacity tint.

Let's start by talking about desaturated tinting.

Desaturated tinting is the default tinting mode for complications.When the watch face is tinted, it creates a grayscale version of your view.

Some faces, like the Extra Large face,may apply a single color over this desaturated view.Let's see how we can build a SwiftUI complicationthat becomes desaturated on the watch face.

Here I have the code for my view which is a ZStack of a circle and an apple image.

On the watch face that looks pretty good.

When the watch face color is changed to red...you can see that the default desaturation mode kicks in,and the view becomes desaturated automatically on the watch face.

And on the Extra Large face,a single color is applied over the desaturated view.So that's pretty easy.With no changes to our SwiftUI view, we get a good tinted complication.

With that said, be mindful about the colors you choose for your complication.

If I had instead chosen colors with a similar brightness,the apple will just disappear when the view is desaturated.So it's important to consider how your view will look desaturatedwhen building a complication.

So that's desaturated tinting.Next, let's look at color opacity tinting.While desaturated tinting is the default tinting behavior,color opacity is an alternative tinting style that we can opt into.

This tinting style works by creating layers within our complication.And then the watch face applies a color to each layer.

Starting with our fullColor view,we first want to identify the layers of our complication.Watch faces support two distinct layers.

In this case, we've chosen the circle to be separated from the apple.These will now be our two layers.Next, as the name implies,the watch face only considers the opacity of each view.

Since each of these views are at full opacity, they both become white.

Then the watch face applies a color to the appropriate layer.Each watch face determines the color applied to each layer.In this case, the watch face determined that the circle's layer should become redand the apple's layer should remain white.

Then the layers are brought back together.

It's up to the watch face to define how the chosen color is applied to each layer.On the Extra Large face, for example, our apple is white on a red background...

but will be red on a white background on the Meridian face.

And other faces, like the Solar Dial face,may apply a different color to both layers.

So let's return to our example, this time using the Extra Large faceand see how we can make our complication use a color opacity tint.

I want my circle and my apple to each be in their own distinct layer.By default, all view content is considered to be in the background layer.

By applying the complicationForeground modifier,I've determined that the apple imageshould be promoted to the foreground layer.And the circle will remain in the background layer.Now that I have distinct layers, color opacity tinting kicks in.

When the watch face color is changed to red...the apple now becomes white and the circle becomes red.

If I change the color of the face again,you'll see that the background changes right along with it.On the Extra Large face,the background layer was given the watch face color.Let's look at a different face.

On the Meridian face, you'll notice that the opposite layers are colored.

So that's color opacity tinting,where we create distinct opacity layers within our view hierarchy.Then the watch face applies a color to these layers for a striking result.

In some cases,you may want to make additional changes to your view for tinting.For example,you may want to change the background color to use a gradient.

Or you may want to remove the background entirely.

We can do that with the new ComplicationRenderingMode.

The rendering mode has two values,fullColor for when this view is being rendered for a full color face,and tinted for when this view will be shown on a tinted face.

We can get the current value out of the environment.

Let's return to our exampleand see how we can use the ComplicationRenderingMode.

First, I can use the environment to get the current rendering mode.

Next, let's use the rendering mode by changing the fill of our circleand the complication is for color or tinted.

We'll add a switch statementto check for the current value of rendering mode.

In the fullColor case,we keep our circle exactly the sameusing a blue fill color...

but in the tinted case, we're gonna change the fill entirely.Instead of a single color, we're gonna use a linear gradient.

In particular,a gradient that only changes the opacity of this view.Recall from earlier,this is a color opacity complication.Therefore the opacity of the viewis the only thing being considered when it's shown onscreen.Since the opacity is the only thing we can change,this gradient goes from an opacity of one to an opacity of zero.

So now we have a tinted complicationwith an opacity gradient fill in tinted modeand a blue fill in fullColor mode.That was a lot of information,so let's go over some key takeaways.

First, by default, a SwiftUI view will be desaturated on the watch face.If you want a color opacity complication,use the complicationForeground modifierto group pieces of a view together for tinting.

And finally, the ComplicationRenderingModeallows for advanced customization of a viewfor fullColor and tinted complications.So now we've learned about all the new APIthat you can use to build amazing SwiftUI complications.But to see it all happen in action, I'd like to hand it over to August.Thank you, Matthew.I'm August Joki, a watch face engineer,and I'm gonna show you how to use what we've learned in Xcode.Not long ago, we released new sample code for creating and updating complications.It's called Coffee Tracker. Here's what the app looks like.

It already includes complications.This'll make a great place to show off the new SwiftUI complication features.

Matthew and I have been working on incorporating a new SwiftUI viewto show the user their historical caffeine consumption.They can see the equivalent number of cups of coffee consumed in the past week,and the chart incorporates the colors of the app.The view's turning out really nice,and we think it'd make a great Graphic Rectangular complication.Let's go to Xcodeto see how to incorporate SwiftUI and complication templatesand how to support the two options for tinting.While previously working on the History View of the app,we set up a preview to quickly see changes we make to our view.Simple views may not need any changes for inclusion in a complicationor only need a new property or twoto key off of for rendering in a complication.

But because our chart is fairly complex,we decided we will create a new view to use in our complication.The separate view allows us to encapsulate any changesthat are specific to the complication.

We add the new view to our previewbecause we want to see the Apps version of the HistoryViewalongside our new ComplicationHistoryViewto ensure we are not accidentally modifying it.Let's take the HistoryChart part of the HistoryViewto use in our complication.

To preview our complication, we start by creatinga FullViewGraphicRectangularTemplate using the new SwiftUI view.

But the template is not a SwiftUI view itselfso it can't be previewed on its own.To address this,we've added a new function to CLKComplicationTemplate:previewContext.It is defined when both ClockKit and SwiftUI are imported together.The function wraps the template in a SwiftUI viewthat Previews knows how to transform into a clock facewith a complication template set on it.Every complication template previewed is set on a facethat is best suited for its family.Thanks to the power of SwiftUI,our complication looks almost done right out of the gate.But the default Graphic Rectangular font size is a bit largefor the kind of content we are displaying.Let's start by fixing that.

We add a font modifier to the chartto set a size more suitable for displaying in our complication.

We also wanna take up all the available spacefor the GraphicRectangular FullView template.Matthew will explain complication safe areas in more detail later.That font size looks great.And since we can see our chart is next to other complications on the watch face,we should provide some context for our complications data.Adding a title is a great way to provide that context.

Since this is all SwiftUI, we can add "Weekly Coffee" as a textand wrap it up together with the History Chart in a VStack.And now that is looking really polished.But what does our complication look like when the face is tinted?To find out, let's set the preview's face color to blue.

Nothing is blending together, but we lost all of our color.Let's use complicationForeground to make the title adopt the tint color.

Now our title's automatically tinted to match the color of the face.Since we are focusing on supporting tinting,let's focus our previews on tinting too.

Now we can see what a multicolor face looks like right next to a tinted face.And I've just noticed that using complicationForegroundalso made the gradient and the Gauges disappear.That's because, as soon as we adopt tinting support,our complication is no longer getting desaturated.Instead, only the opacity of our view hierarchy is used.That means everything in the hierarchy is reduced to their opacity values,the parts marked with complicationForegroundare grouped togetherand have the same color wash applied to them.As we learned earlier, we have another way to work with tinting:the ComplicationRenderingMode environment value.Let's use it to change how we render the chart when tinted.But first, let's paint our previews so that we can watch in real timethe complication update as we are making changes to a different file.Here we have the view that creates a column for a given day.

We add an environment property for ComplicationRenderingModeand pass the new property to our custom HistoryGaugeStyleto hide the background when tinted.We can see that the chart now renders differentlyfrom the fullColor case.

With ComplicationRenderingMode,we are able to change pieces of our view hierarchywhile keeping the code pads from drastically divergingbetween fullColor and tinted rendering.Let's go back to ComplicationHistoryView.We've seen what our new complication looks like with a blue face color,but what about the other sample preview colors?We can take advantage of the power of using ClockKit and SwiftUI togetherto enumerate the PreviewFaceColors to see them all at the same time.We can now make sure our complication looks goodwith a sampling of different options a user could set for their face color.I've shown you how easy it is to use SwiftUI and complication templates,how to quickly support tinting with complicationForegroundand how to make use of complicationRenderingModefor finer-grained tinting control.And now I'll hand it back to Matthew to talk about best practices. Thank you.Thanks, August. That was some pretty cool stuff.SwiftUI makes it really seamless to create compelling chartslike our weekly summary view.It has never been easier to turn that into a complication.

Next, let's talk about some best practices to considerwhen building your own SwiftUI complication.

First, it's important to knowthat tapping anywhere on a complication will always launch your app.Buttons, gestures and other interactive elementsare not supported in complications.

Stick to text, images and drawing primitiveswhen building your complication.

We've added a new runtime warning to Xcode,in case you try to use a view that is not compatible with complications.

And finally, remember that a complication is a timeline composed of static views.Therefore, SwiftUI animations are not supported.

We want you to also considerthe performance characteristics of your view.

In order to keep the watch face performing at a high level,every SwiftUI view's performance is measured before it's shown on screen.

Consult the Human Interface Guidelines and our documentation to ensure you useappropriately sized images for each complication...

and be mindful about the runtime costs of certain drawing attributes,such as blurs and formatted text,and only use what is absolutely necessary.

Note that poorly performing views may penalize your complication's runtime.

Watch out for runtime warnings like this oneregarding the size or complexity of your view.

If your complication is giving a runtime warning like this,treat it like a build errorand make sure you fix it before shipping your complicationfor the best experience for your customers.

Finally, some layout best practices.

Use the default font size for each complicationas a guide for the kinds of views that you should build.

For example, the Extra Large complication may have a large canvas for drawing,but its purpose is to provide large and easy-to-see information.

Note that the Circular and Rectangular complication familieswill mask your content to their respective shapes.

And the Rectangular Full View complication features a safe area for layoutto help prevent your content from being clipped on the watch face.

This new larger drawing areacould be clipped by the corners of the Apple Watch displayon certain watch faces.By default, the safe area provides you with space that's safefor all complication placements.If you'd like to use the full area of the complication,like we did for the Weekly Coffee complication,you can use the edgesIgnoringSafeArea modifier.

This will give you that little bit of extra space.Be mindful, though, about the layout of your contentto prevent it being clipped.So that was a look at some of the awesome thingsthat you can now do with SwiftUI complications.We saw how, for the first time,you can bring your knowledge about SwiftUI right to the watch face.

We saw some great new APIs for Text, Progress View and Gaugeand how our complications are tinted on the watch face.

And how you can use Xcode previewsto work on multiple complications at the same timeand on different watch face colors.

If you've never built a complication before,or you wanna freshen up your knowledgeabout complication templates and descriptors,check out the "Create Complications for Apple Watch" talk.

And to make sure your complications are always showingthe right information at the right time,I highly recommend watching "Keep Your Complications Up to Date."Thank you.[chimes]

3:17 -Relative Text

3:26 -Timer Text

4:04 -Progress View Sample #1

4:15 -Progress View Sample #2

4:23 -Progress View Sample #3

4:29 -Progress View Sample #4

4:45 -Gauge Sample #1

4:55 -Gauge Sample #2

5:02 -Gauge Sample #3

5:14 -Gauge Sample #4

5:21 -Gauge Sample #5

5:34 -Gauge Sample #6

## Code Samples

```swift
import
 SwiftUI

import
 ClockKit


struct
 
RelativeText
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
VStack
(alignment: .leading) {
            
Text
(
"Count Down"
)
                .font(.headline)
                .foregroundColor(.accentColor)
            
Label
(
"Nap Time"
, systemImage: 
"moon.fill"
)
            
Text
(
Date
() 
+
 
100
, style: .relative)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}


struct
 
RelativeText_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicRectangularFullView
(
RelativeText
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
TimerText
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
VStack
(alignment: .leading) {
            
Label
(
"Sourdough Timer"
, systemImage: 
"timer"
)
                .foregroundColor(.orange)
            
Text
(
"Time remaining: 
\(Date() 
+
 
100
, style: .timer)
"
)
        }
        .frame(maxWidth: .infinity, alignment: .leading)
    }
}


struct
 
TimerText_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicRectangularFullView
(
TimerText
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
ProgressSample
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
ProgressView
(value: 
0.7
)
            .progressViewStyle(
CircularProgressViewStyle
())
    }
}


struct
 
ProgressSample_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicCircularView
(
ProgressSample
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
ProgressSample
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
ProgressView
(value: 
0.7
) {
            
Image
(systemName: 
"music.note"
)
        }
        .progressViewStyle(
CircularProgressViewStyle
())
    }
}


struct
 
ProgressSample_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicCircularView
(
ProgressSample
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
ProgressSample
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
ProgressView
(value: 
0.7
) {
            
Image
(systemName: 
"music.note"
)
        }
        .progressViewStyle(
CircularProgressViewStyle
(tint: .red))
    }
}


struct
 
ProgressSample_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicCircularView
(
ProgressSample
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
ProgressSample
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
VStack
(alignment: .leading) {
            
Text
(
"Water Reminder"
)
                .foregroundColor(.blue)
            
Text
(
"32 oz. consumed"
)
            
ProgressView
(value: 
0.7
)
                .progressViewStyle(
LinearProgressViewStyle
(tint: .blue))
        }
        
    }
}


struct
 
ProgressSample_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicRectangularFullView
(
ProgressSample
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
GaugeSample
: 
View
 
{
    
var
 body: 
some
 
View
 {
        
Gauge
(value: 
5.8
, in: 
3
...
10
) {
            
Image
(systemName: 
"drop.fill"
)
                .foregroundColor(.green)
        }
        .gaugeStyle(
CircularGaugeStyle
())
    }
}


struct
 
GaugeSample_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicCircularView
(
GaugeSample
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
GaugeSample
: 
View
 
{
    
@State
 
var
 acidity 
=
 
5.8

    
    
var
 body: 
some
 
View
 {
        
Gauge
(value: acidity, in: 
3
...
10
) {
            
Image
(systemName: 
"drop.fill"
)
                .foregroundColor(.green)
        } currentValueLabel: {
            
Text
(
"
\(acidity, specifier: 
"%.1f"
)
"
)
        }
        .gaugeStyle(
CircularGaugeStyle
())
    }
}


struct
 
GaugeSample_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicCircularView
(
GaugeSample
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
GaugeSample
: 
View
 
{
    
@State
 
var
 acidity 
=
 
5.8

    
    
var
 body: 
some
 
View
 {
        
Gauge
(value: acidity, in: 
3
...
10
) {
            
Image
(systemName: 
"drop.fill"
)
                .foregroundColor(.green)
        } currentValueLabel: {
            
Text
(
"
\(acidity, specifier: 
"%.1f"
)
"
)
        } minimumValueLabel: {
            
Text
(
"3"
)
        } maximumValueLabel: {
            
Text
(
"10"
)
        }
        .gaugeStyle(
CircularGaugeStyle
())
    }
}


struct
 
GaugeSample_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicCircularView
(
GaugeSample
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
GaugeSample
: 
View
 
{
    
@State
 
var
 acidity 
=
 
5.8

    
    
var
 body: 
some
 
View
 {
        
Gauge
(value: acidity, in: 
3
...
10
) {
            
Image
(systemName: 
"drop.fill"
)
                .foregroundColor(.green)
        } currentValueLabel: {
            
Text
(
"
\(acidity, specifier: 
"%.1f"
)
"
)
        } minimumValueLabel: {
            
Text
(
"3"
)
        } maximumValueLabel: {
            
Text
(
"10"
)
        }
        .gaugeStyle(
CircularGaugeStyle
(tint: .green))
    }
}


struct
 
GaugeSample_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicCircularView
(
GaugeSample
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
GaugeSample
: 
View
 
{
    
@State
 
var
 acidity 
=
 
5.8

    
    
var
 body: 
some
 
View
 {
        
Gauge
(value: acidity, in: 
3
...
10
) {
            
Image
(systemName: 
"drop.fill"
)
                .foregroundColor(.green)
        } currentValueLabel: {
            
Text
(
"
\(acidity, specifier: 
"%.1f"
)
"
)
        } minimumValueLabel: {
            
Text
(
"3"
)
        } maximumValueLabel: {
            
Text
(
"10"
)
        }
        .gaugeStyle(
            
CircularGaugeStyle
(
                tint: 
Gradient
(colors: [.orange, .yellow, .green, .blue, .purple])
            )
        )
    }
}


struct
 
GaugeSample_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicCircularView
(
GaugeSample
())
            .previewContext()
    }
}
```

```swift
import
 SwiftUI

import
 ClockKit


struct
 
GaugeSample
: 
View
 
{
    
@State
 
var
 acidity 
=
 
5.8

    
    
var
 body: 
some
 
View
 {
        
VStack
(alignment: .leading) {
            
Text
(
"Garden Soil Acidity"
)
                .foregroundColor(.green)
            
Gauge
(value: acidity, in: 
3
...
10
) {
                
Image
(systemName: 
"drop.fill"
)
                    .foregroundColor(.green)
            } currentValueLabel: {
                
Text
(
"
\(acidity, specifier: 
"%.1f"
)
"
)
            } minimumValueLabel: {
                
Text
(
"3"
)
            } maximumValueLabel: {
                
Text
(
"10"
)
            }
            .gaugeStyle(
                
LinearGaugeStyle
(
                    tint: 
Gradient
(colors: [.orange, .yellow, .green, .blue, .purple])
                )
            )
        }
    }
}


struct
 
GaugeSample_Previews
: 
PreviewProvider
 
{
    
static
 
var
 previews: 
some
 
View
 {
        
CLKComplicationTemplateGraphicRectangularFullView
(
GaugeSample
())
            .previewContext()
    }
}
```


# Wwdc2020 10640

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Design for the iPadOS pointerBring the power of the pointer to your iPad app: We'll show you how Apple's design team approached designing the iPadOS pointer to complement touch input, and how you can customize and refine pointer interactions in your app to make workflows more efficient and gratifying. Discover how the pointer's adaptive precision enables people to quickly and confidently target interface elements regardless of their size. We'll also share some best practices on adapting the pointer to complement your app's unique needs including how to select pointer effects and design pointer shapes, integrate trackpad gestures, and keyboard modifiers.ResourcesHuman Interface Guidelines: Designing for iOSHuman Interface Guidelines: Pointing devicesHD VideoSD VideoRelated VideosWWDC21Take your iPad apps to the next levelWWDC20Build for the iPadOS pointerDesigned for iPad

Bring the power of the pointer to your iPad app: We'll show you how Apple's design team approached designing the iPadOS pointer to complement touch input, and how you can customize and refine pointer interactions in your app to make workflows more efficient and gratifying. Discover how the pointer's adaptive precision enables people to quickly and confidently target interface elements regardless of their size. We'll also share some best practices on adapting the pointer to complement your app's unique needs including how to select pointer effects and design pointer shapes, integrate trackpad gestures, and keyboard modifiers.

Human Interface Guidelines: Designing for iOS

Human Interface Guidelines: Pointing devices

HD VideoSD Video

HD Video

SD Video

Take your iPad apps to the next level

Build for the iPadOS pointer

Designed for iPad

Search this videoâ€¦Hello and welcome to WWDC.Hi everyone. I'm Brandon Walkin, a designer on the Apple design team.I'll be joined later by other designers on the team - Marcos Alonzo, CC Wan, andDylan Edwards. We're gonna talk about how to design for the new pointerin iPadOS. Today we're going to talk about the design principles behindthe new pointer, go behind the scenes and take a look at how it works andthe different effects you can use. Then we'll talk about the appearanceof the pointer, how to make a custom pointer or shape using Pointer Interactions,and how to make your app work great with gestures on the trackpad.Let's start off with some of the thinking behind the new pointer. The iPadworks great with touch. So why would we want to add pointing. Well oneof the reasons is ergonomics. Adding trackpad capability, allows peopleto have a more comfortable experience where they can leave their handson the same plane as the keyboard instead of having to frequently reach up totouch the screen. We also wanted to make editing text easier. Editing textrequires a lot of fine manipulation and since the finger is a course screeninput it's more difficult to position the text cursor and make a selectioncompared to using a trackpad or a mouse. What's the best way to let peoplecontrol the interface using the trackpad. iPad is unique in that its interfacewas fundamentally designed for touch. Hit areas are generous, so they cansupport being easily tapped with the finger. And buttons are spaced furtherapart to avoid accidental mis-taps. We looked at just bringing the traditionalarrow pointer over from the Mac, but that didn't feel quite right on iPadOSwhere the entire operating system and every app is designed to be usedby an input the size of a fingertip. You'd be using a high precision toolto interact with low precision controls. This got us thinking more deeplyabout the concept of precision. The traditional arrow pointer can movevery precisely over the whole screen. This is great for certain tasks.Say you're making a marquee selection to edit a particular section of an image.Or maybe you're just trying to select some texts from the middle of a paragraph.In these cases it's helpful to have very precise control over where thepointer is on screen, so you can place it just where you want it. But thishigh level of precision also has some downsides. Most of us are expertsat using mice and track pads and aren't conscious of this, but the traditionalpointer actually requires a lot of physical dexterity to use. Say you'retrying to click a button and you quickly move the pointer there, but endup clicking just a few pixels above the button and nothing happens.Or maybe you end up clicking between two buttons and neither is activated.Or, say you intend to click the pause button and end up rewinding to thebeginning of the track. Let's take a close look at what's happening here.There are two independent layers that are interacting with each other.The interface layer and the pointing layer. The traditional pointer movesat pixel level precision. You can place it on any pixel of the interfacebut the underlying interface is built out of three button regions. It onlycares which of the three playback buttons you click, not the precise pixel coordinateyou click on a button. There's an inconsistency between the precision ofthe pointer and the precision required by the app. So while people generallythink about the pointer in terms of giving you increased precision comparedto touch. In this case it's helpful to actually reduce the precision ofthe pointer to match the user interface. This concept of dynamically adjustingthe precision of the pointer to match the precision of the interface iscalled, Adaptive Precision. Let's look at how Adaptive Precision works.The pointer starts off as a circle. This is its default state when thepointing system isn't aware of any particular level of precision of theinterface around it.It's sized to match a fingertip, since everything you're interacting withon iPad must be usable with touch. When you move the pointer to a groupof buttons, the pointer will adjust itself to match the precision of the buttons.As I move the pointer into the group of buttons, it snaps itself to thebutton while morphing its shape to the shape of the button. The changein shape indicates its new reduced level of precision. As I move betweenthem the pointer will always snap its up to a button, making it clear exactlywhich one I'm interacting with. This feedback you get from the pointerreduces the likelihood that you'll miss click. You'll also notice thatthe pointer highlights the element rather than obscuring it. A traditionalpointer is drawn over the entire interface often obscuring the controlyou're interacting with. We thought it was important to have the controlsyou're interacting with completely unobstructed. In fact, when the pointersnaps to a control, the pointer actually moves along the z axis from beingin front of the app to being behind the buttons icon or label. This letspeople see the true color of the icon. The icon on the left with the pointer behindit has the brightness level that the designer intended. Now, let's lookat how the pointer interacts with text. You may have run into this issue before,where you try to select some text and you end up selecting the line just aboveor below the one you're aiming for. Here I'm trying to select the wordenvironment, but I've started my click just slightly too high and selectedthe line above. Why does this happen? Well, the traditional I-beam pointer movesup and down at pixel level precision letting you click on individual pixels.However, the text view behind it only cares about line-level precision- whichspecific line of text you're clicking on. Let's zoom in a little closer.There's an invisible boundary just above the line of text where if I movemy pointer just a single pixel over the boundary the TextView will thinkI'm interacting with the line above. This inconsistency between the inputprecision and the interface precision is what leads people to miss clickand select the wrong text. Now, let's unify the precision of the pointerand the TextView together with Adaptive Precision.As the pointer moves over the TextView it morphs from the circle pointerto a beam shape that matches the line height of the text. It's a new levelof vertical precision. As you move the pointer up and down it snaps toeach line of text making it clear which line you're interacting with.In fact the pointing system makes it impossible to place the pointer in anambiguous position between two lines. You can give the pointer a differentamount of precision for each axis, so when you move horizontally we giveyou pixel level precision so you can place the insertion point just whereyou want it and make your selection. So we showed how the pointer snapsthe buttons and lines of text. You get both of these behaviors for freeif you use our standard UIKit controls. But let's look at an example ofwhen you'd want to use Adaptive Precision in a view that's custom for your app.Here, we have a scheduling app that lets you manage events over a day view.You make new events by clicking and dragging on the day view. It's commonfor these types of interfaces to round the start times of the events to15 minute intervals. So instead of your click and drag starting a meetingat 9:41 for example which is an odd time to start meeting, it'll round itto a more common start time of 9:45. While this is a helpful behavior,it often results in errors when you're trying to make an event that startsat a certain time. Say you're trying to make an event that starts at 2:30.But the interface ends up interpreting that click as 2:15, resulting ina frustrating experience. Turns out what's happening here is exactly thesame issue as with the TextView. Just like with the TextView, the verticalprecision of the pointer, is different then the vertical precision of the interface.The pointer is letting you start to drag at any pixel on screen, but theinterface only accepts drag starting within fifteen minute blocks. And theboundaries of these blocks aren't exposed to you. So it's not clear whatwill happen on click. And from a design perspective it may be distractingto visualize these regions using divider lines or hover states. Let's useAdaptive Precision to customize the precision of the pointer to match the day view.Now as you move up and down, the pointer is always snapped to a 15 minuteinterval, making it clear what time the event will begin. When you move quickly,you can just barely tell that it's snapping. But when you slow down, youreally feel it snap to those time blocks. Here Adaptive Precision makesit easy to start an event at just the time you want, and reduces potential errorsyou'd see with a traditional pointer. So that's Adaptive Precision.Now let's take a look at how the pointer works behind the scenes. When you movethe pointer around on screen, you're actually moving two pointers.The one you see on screen and an invisible one, that tracks the true positionof the pointer. We call this the model pointer. The model pointer is usedto decide which item the pointer is hovering over and it takes advantageof the generous padding that buttons have on iPadOS to make them easierto tap with the finger. Let's see this in action. Once the true pointerposition reaches the edge of the button's hit area, it begins to move andresize to highlight the button. This effect of animating the pointer towardsthe button is called snapping. Now the pointer doesn't actually move tothe center of the button at this point, though it may appear that way.The true position of the pointer still remains on the edge of the button.And this is indicated with a parallax effect. We do this so the amount thetrue pointer position moves on screen is always based on how much movementyou apply to the trackpad, making it feel more predictable. As you move thepointer along a set of buttons, the visible pointer will animate to thenext button. Once the true pointer position reaches the edge of the button'shit area. Once you lift your finger the pointer centers itself on the control.This is called recentering. Recentering makes it easier to click the buttonwhen you put your finger back down on the trackpad. If you place a traditionalpointer near the edge of a button, released your finger and click,it's possible the finger may roll slightly, moving the pointer off of the button. The pointer then auto hides.After a short delay. We found that if the pointer persisted on screenit would remind people to perform their next interaction using thetrackpad rather than with touch or the pencil. We want people to feellike they can fluidly move between different inputs without thinking about it.In fact there are many places on iPadOS where you can usetouch and the pointer simultaneously. For example with one hand you canuse the pointer to pick up an app icon, and with the other, you can swipe onthe touchscreen to move it to another page.This is a huge advantage to having both input methods available. For your app,think about how users will switch between different inputs, and even tryto use multiple at the same time. Now, let's look at how the pointer movesaround the screen. The MacOS pointer moves at a speed that you can customizeto what feels right for you. But it gets a little extra speed boost withsomething called an acceleration curve. The acceleration curve moves thepointer a longer distance the faster you move your finger on the trackpad.Here I'm swiping slowly, and swiping quickly, over the same physical distanceon the trackpad. We've carefully tuned the acceleration curve on the Macto work just right and we're using that same curve on iPadOS. But sometimesthe boost you get from the acceleration curve just isn't enough to quicklymove the pointer to where you want it. For instance, with a traditionalpointer, to move it all the way over to the settings icon, I need to performtwo separate swipes on the trackpad. I wish I could get there in just oneswipe, but if we made the acceleration curve stronger, or increased the speedof the pointer, it could make it hard to control. On iPadOS, we solve thisby adding inertia. Inertia makes it easy to move long distances with asmall amount of physical input, similar to how you can flick to scroll along distance on the touch screen. Now with just one flick on the trackpad,I can reach the button. When we were building the pointer we liked beingable to flick to target controls. But we found that based on the speed ofyour swipe, sometimes the pointer would overshoot or undershoot the control.Wouldn't it be great if the pointer could just figure out which controlyou were aiming for and move there automatically. Well, the new pointerhas something called magnetism that does just that. Magnetism scans theinterface to find the control you most likely want to target. Let's goback in time to see how it works. At this point I'm mid-Swipe and my fingeris still touching the trackpad. The moment I lift my finger from the trackpadthe pointing system immediately calculates where the pointer would havelanded if it continued moving with inertia. We know that there isn't atarget there, so we start scanning around that position in circles up toa fixed radius. We'll find the nearest target in the direction of yourswipe and automatically move the pointer there. Since the settings iconis the closest snappable element to the projected position that is alsoin the direction of the pointer, we move the pointer there automaticallythe moment you lift your finger from the trackpad. We put a lot of workinto tuning this to feel just right. Ideally people aren't even aware thatthis is happening. The pointer just magically reads their mind and doesthe right thing. And what's great is any control in your app that supportspointer snapping gets magnetism for free.We just learned about why we added a pointer to iPadOS, the power of AdaptivePrecision, and went behind the scenes to look at how the pointer works withsnapping, recentering, inertia, and magnetism.Now I'm gonna pass it off to Marcos who's gonna talk about how you canuse pointer effects in your app.Things Brandon. Hi everyone. In this section we're going to have a look atthe different pointer effects you can use when adding trackpad support to your apps.When the iPadOS pointer hovers over an interactive element, both the appearanceand the behavior of the pointer and the interactive element become one,bringing focus to the item that is being targeted. We refer to this integrationof pointer and the content as a Pointer Effect, and it changes based oncontext and content type. iPadOS provides 3 pointer effects you canuse to bring focus to the interactive elements in your app. So when addingpointer support to your apps, you can use one of the provided effects,you can modify them to suit your app, or design a completely new oneif you desire so. The first effect we provide is called Highlight Effect.This effect is used for small controls that don't have a background and it'sthe default effect for bar buttons and tab bars. For instance, when the pointerhovers over a control it becomes a controlled background by moving behindit while adopting a lighter color. When the control gets selected, its contentsscale up and move with the pointer with a gentle parallax effect. A lighteffect connected to the pointer movement is added on top to highlight theobject. And on click, the three layers scale down and move to the object center.The next effect we provide is the Lift effect. You might want to use itfor medium sized elements that already have a background. The pointer transformsinto the element, highlighting it without obscuring its contents.Examples of this effect in iPadOS are the app icons or the control center modules.When the pointer approaches a control it disappears behind it. The objectappears lifted by scaling up and adding a shadow. And the color of the itembleeds around it and illuminates the background behind it. Let's look athow the effect works when an object gets selected. These are the differentlayers that are added on top and below the selected element. A soft specularhighlight is added on top of the element to illuminate it. The elementitself is scaled up and its colors bleed around it covering its surroundings.This light effect is called radiosity. And lastly a shadow is projected underthe element to give the illusion the element is floating above the screen.The specular light is used to highlight the selected object but it hasa second purpose. The position of the light shows the actual position ofthe pointer under the hood. As you can see with a dash circle here. thespecular light shows you where the pointer is and connects your gestureswith the movement on the screen. The strength of the light is based onthe object size too. It gets bigger and brighter for bigger elements wherethe position of the pointer is harder to see. And gets smaller or it'snot visible at all for smaller objects that don't require it. This is automaticallydone by the system, so you don't have to worry about it. The last effectwe provide is called Hover. It is generally used for larger objects thatwould behave poorly if the pointer were to morph into their shape. Whenthe pointer hovers over an object that uses this effect, the object changesits appearance to show its being focused and the cursor retains its defaultshape and remains visible on top of the object. This effect is highlycustomizable and it can be just a scale of the object and a shadowto lift it, a color tint added to the object, or any combination of the three.So how do you use a different effect. Let's have a look at how to pickthe best effect for your app and how to use it. The main rule when pickinga pointer effect is to try the Automatic Effect first. When using theAutomatic Effect the system uses a combination of rules like the objecttype and location, and the object size and shape to decide the best effectfor it. These rules can change in the future, so using the Automatic Effectensures your app will always look good. Using the Automatic Effect is very easy.Just pick "automatic" when assigning a UIPointerEffect to your interactive element.For more technical and implementation details check out the talk "Build for theiPadOS Pointer Interactions" from this year's WWDC. Well the automaticeffect is not always the right solution. Like in this example from thebooks app. The bookmark icon on the right has its own background and seemslike the Lift effect should be the appropriate one for it. But becauseit's in a toolbar next to other buttons that use a Highlight effect it feelsout of place and we shouldn't use it. The right thing to do in this caseis to use the Highlight effect. The Highlight effect will make the button lookconsistent with the other buttons around it. You should try to be consistentwith designing the size of your objects too. Like in this example, we havethree buttons side by side, but their highlight background size is not consistent.This discrepancy will look bad when the pointer moves over them. So makesure the objects in the same group have a consistent size between them.For toolbar sized buttons like in this example we recommend using a heightof 37 points. Effect consistency is not always the right choice though.For instance, when we were designing the pointer behavior for segmented controls,we arrived at the conclusion that mixing effects was the right thing todo in this situation. So even though day and month use the Highlight effectand get a rounded rectangle around them when focused, using the highlight effectfor the selected option looks out of place. In general you should tryto avoid the highlight effect around rectangular objects. The right thingto do in this case is to use the Lift effect so the selected option appearslifted above the control around it. The hit region of the object willdetermine the area your Pointer Effect is active and you should make sureit's the right size. If the hit region is too small, it can make peoplefeel that they have to be extra precise when interacting with the element.On the other hand when an element's hit region is too large, people canfeel that it takes a lot of effort to pull the pointer away from the element.So try to find a region that feels comfortable. In general it works well toadd about 12 points of padding around elements that include a bezel.And about 24 points around elements without a bezel. An extended hitregion will also make your apps more comfortable when using the touch screen.A common issue when defining your hit region is leaving a gap between objects.This will make the pointer morph back into the circular shape betweenthem, creating an unnecessary animation. So make sure your hit region extendsbetween your objects leaving no gap between them. That way the pointerwill flow nicely between them. This change will make your apps work muchbetter with touch too. A common problem when adopting the Lift effectis the extended shadow around it because your app was not designed for theextended size of the object the shadow might get clipped by other UI elementsaround it. So make sure that the objects that adopt the Lift effect areon top of their surrounding layers to ensure the shadow is rendered correctly.Next we're going to have a look at how to customize and combine the pointereffects in your app. When using the Highlight and Lift effects you can specifythe size and corner radius of your object. If your object has a circularshape or the corner radius is not 8 points it is very important that youprovide the correct corner radius. Otherwise it will not render correctly.When using the Hover effect your object can scale up or have a shadowwhen it is highlighted, like we see in this example. Both the scale effectand the shadow can be turn on and off so you can pick the right combinationthat matches your app design. But in general we don't recommend using theshadow if you're not scaling your object. Another effect you can combinewith Hover is tinting. You can use it to highlight objects you don't want to scaleas you can see here for notifications. When tinting is turned on it willadd a special material on top or below the object and change its color.This material can be dark or light depending on your dark mode settings.When using the Hover effect you can provide a custom shape for your pointertoo. The pointer will morph from the full circle into the provided shape whenit hovers over your object like the I-beam pointer we use for text on iPadOS.Custom pointers can show you extra information about a specificregion on the screen or a change in the pointer behavior. We're going tolearn a lot more about custom pointers in the next section. If we visualizethe actual position of the pointer we can see how the I-beam tries to stayin the center of the text field. This effect is called snapping and createsa magnetic attraction that pulls the pointer to the center of the object.It increases the precision of the pointer and creates a more comfortableexperience when interacting with your app controls. You can use this effectin your apps too. Adding snapping to controls helps you be more preciseand simplifies common tasks like grabbing small handlers, as you can seein this example. Just remember you should never enabled snapping if you'renot providing a custom pointer. So we just had a look at the three-pointereffects provided by iPadOS, Highlight Lift and Hover. Remember you shouldtry to use the Automatic Effect whenever possible. Be consistent pickingthe pointer effects and designing your object's shape. Extend your objectshit region to make it more comfortable to use. Remember when using theLift effect, you have to provide the correct size and corner radius.And if you use the Hover effect you can enable a scale, a shadow, or a tint colorfor your object. I hope this section gave you a good overview of the differentpointer effects provided by iPadOS and how to successfully use themto create a great pointer experience for your apps. That's all for me.I'm going to pass it over to CC who is going to show you how to designa great pointer for your app. Thank you.Thank you Marcos. Hi everyone. I'm going to talk about the pointer appearanceand how to design a custom pointer. First let's look at the pointer material.The pointer in iPadOS has a material that constantly adapts to the backgroundcolor smoothly. It provides optimal contrast at all times without beingdistracting. When the background color changes, so will the pointers color.This material maintains contrast without obscuring the background.That is because when people are using the iPad with the trackpad we want thepointer to be there to show the location of interaction. But it shouldn'tdraw too much attention to itself and take away from the content.However, the pointer should indicate intention when it's needed. In this case whenthe pointer is transformed into a button shape, not only does it changeits shape but the color of it also become lighter to provide good legibilityto the label. On top of that when people click, the circle scales down andbecomes darker to provide a satisfying feedback for the click action.These are examples of the pointers material adapting to its function. And allof these color adaptations are provided by the system automatically.Next, we are going to look at the pointer shape. As Brandon mentioned earlier,the pointer shape is a circle that represents touch. The size of its relateswell with the touch-based UI elements. The circle shape provides a perfectfoundation for it to transform into any shape. In the previous examplethe pointer transformed from a circle to a round rectangle to highlightthe button. This is our first type of pointer shape transformation - froma circle to a rounded rectangle. And it's not just for buttons.The circle can transform to a vertical bar for an I-beam, a horizontal pillto highlight the top status region, or to highlight a grabber. These areall considered the rectangle type of pointer transformation. The secondtype of transformation is when the circle morphs into any arbitrary shape.This can be used to inform people when there is a change of functionalityor precision. For example the pointer can turn into a cross shape to indicatean area with higher level of precision. It can also transform into a pairof triangles to inform people the direction of a drag movement or whenthe command key is held down and the functions of the pointer is modified.Both of these transformations are available with their corresponding APIs.If the pointer is going to morph from a circle to a rectangle shape,apply the top API. If it is changing to a more complex shape, use the bottom one.And check out the talk "Build for the iPadOS pointer" for more detailson how to use these APIs. Now, let's talk about how to design a greatcustom pointer. As we just learned the pointer in iPadOS has many waysto morph it's color and shape. These behaviors provide the pointer withthe flexibility to fully adapt to its context at any given moment. Whenwe design a new custom shape for it, we should keep in mind this characteristicof a constant state of transformation. So, how do we design a great customshape for the pointer. First, make sure your custom shape is simple andeasy to understand. The shape of the pointer informs people the actionthey can take in the current context. For example, in Keynote, the pointertransforms into a pair of arrows that show the direction in which peoplecan drag a selection handle. If people cannot instantly understand yourcustom pointer, they are likely to waste time trying to figure it out.Second, you solid shapes as much as possible. Remember the pointer color isconstantly changing. A solid shape will maintain legibility and make it easyto read. A shape with strokes will be difficult to read. But if it happensthat you cannot use a solid fill shape, use heavy strokes and make surethe stroke weight is thick enough to maintain visual weight. It will bedifficult to see the pointer if the stroke is too thin. And don't forget touse a size that is similar to the default pointer. The size of a customshape should visually balance with the default pointer which is a 19 point circle.In other words if you have a shape that is narrow you may want to makeit bigger to maintain a similar visual weight. In this example the crossmark is 24 points compared to the 19 points circle. Keep in mindthat the pointer will morphs from its default state to the custom state.If the custom pointer is too small it may get lost. And if there is a bigsize difference between the two states the transformation can become jarringand distracting. Now when you design your custom pointer, make sure the shapecommunicates its intention as directly as possible. Here's an example.Say if you're designing an app to read and highlight text. Instead of usinga marker pen glyph as the custom highlight pointer, a better solution isto show the marker tip shape. In this case the shape not only informs peoplethe height of the text selection but also resembles the I-beam, which impliesall the system behaviors of adaptive position and snapping. The shape ofthe marker tip has the same anchor points as the circle, resulting in anice transition between the two shapes. Speaking of anchor points, whendesigning a custom pointer, we should also make sure the anchor pointmatches well. If your custom shape is a circle, a simple geometric shape,or a symmetrical shape, it's natural to see the point of interaction asthe center of these shapes. If the shape is directional or with aspecific focus area, we will need the anchor point set to match the intent.However it also means the transformation will appear to be off-centered.It would be nice to think of other ways to indicate these functions andmaintain the center anchor point as much as possible for a nice experience.In this example instead of using an eyedropper glyph as our custom pointer,we can use a target shape for precise color sampling. Lastly a couple ofthings to keep in mind when designing a custom pointer. Make sure you applystandard pointer behaviors on your custom pointer. For example if buttonsin a custom navigation bar don't use the standard highlight effect, peoplemight think they are broken. Apply similar functions to similar pointers.For example, if your app helps people draw, every drawing area in your app shouldhave a similar pointer experience - so that people can apply the knowledgethey gain in one area to the others. Last but not least, try not to createunnecessary custom pointers. People notice when the appearance of the pointerchanges and they expect the change to be useful. Creating a purely decorativepointer effect can distract and even irritate people without providing anypractical value. All right. We just learn about the pointer of material, pointershape, and how to design a great custom pointer. I'm sure you can createa pointer that makes your app feel native and intuitive when people experienceit with a trackpad. Now, I'm going to pass it to my colleague Dylan. He is goingto talk about Pointer Interactions.Thanks CC. Let's talk about all the new interactive behaviors yourapp can gain with the pointer. Let's start by talking about increasingprecision in your app. The presence of a pointer means that people cannow interact with your app with much greater precision than previouslypossible with the finger.So how do we let them take advantage of this without redesigning our apps entirely.We can use the pointer to do finer grained selection as well as addingquicker interactivity to smaller elements of your interface. A great exampleof finer grained selection is the text editing experience on iOS. As shown here,you can use the low precision input of your finger to perform text selectionon a word boundary and then use the drag handles to carefully adjust your selection.But with the high precision input of the pointer this interaction is abit different. As Brandon described, the narrow beam pointer makes it easyto see exactly where you're selecting, while we also snap it to the currentline and grow its height to match the line height, reducing the ambiguityof its position. Because of this high precision and low ambiguity affordedby the pointer, we can begin selecting with character level precision immediately.Consider places in your app where you might need a more precise pointer,or where you can use snapping to aid people in navigating your UI, and striveto always use a pointer that matches the precision necessary for the current task,defaulting to the circle when necessary. You can find another case of thistype of precise input here in Numbers. Using our finger we can tap to selecta column header, and then drag a finger on the exposed drag handle to resizea column. But with the precision of pointer input, we can actually exposea control that isn't available with the finger. Rather than selecting acolumn to expose a resize handle, we can move the pointer directly to thesmall divider between columns and begin dragging, again avoiding the needto first make an imprecise selection to achieve our goal. It's importantto note that neither of these examples adds new functionality for the pointer,but rather they use the added precision to make this functionality easierto use with the pointer. You should avoid updating your app's layout,increasing density, or introducing features that only work with the pointer, but insteaduse the pointers precision to make using your app quicker and more intuitive.The pointer clearly enables new possibilities with precise input, but that'sonly half the story. The pointer system really shines when you make greatuse of adaptive precision. Let's take a look at how you can make your larger,low precision interfaces work wonderfully with the pointer too. Adoptingpointer effects and places where high precision isn't necessarystill can vastly improve the experience of your app. A great example is the interfacein Reminders for creating a new list. These are approximately finger sizedtargets- a UI that already works great with the finger- but adding the Lifteffect to these creates a fun and easy-to-use picker that gives exactlythe amount of precision required. Consider places in your app that adjacentcontrols can use pointer effects to gain great visual feedback and snappingbehaviors. As Marcos described previously, in cases of even larger UI thatmay behave poorly with a morphing pointer, you can still adopt a Hover effect.This isn't just for show. It can provide a lot of information about precision.The Calendar app often has events much larger than a finger. While youmight think such a course UI doesn't need to adapt to the pointer,this is actually an excellent place to add a Hover effect to indicate interactivityand disambiguate in cases of overlapping events. Now I'd like to sharehow the unique characteristics of pointer input can accelerate some ofthe interactions in your app. The pointers presence on the screen servesas a great indicator of intent. We can use this new information to speedup interactions that previously would have required a tap. Now that weknow the position of the pointer we know that hovering over a region meansa person is likely to interact with it and our app can respond proactively.For instance the Books app makes use of the hover position of the pointerto control the visibility of its toolbars. We can hide the bar interfacewhile reading to reduce distraction but immediately reveal it when thepointer moves over it, removing the need for a click to hide and show. Thepointers movement, or lack thereof, can also be a helpful hint to updateour UI. In a full screen experience, or immediate playback, you might wishto automatically hide UI after a period of inactivity. In these cases, pointermovement is a clear indication that someone wants to interact with yourinterface, and can be used to reveal your controls. Because pointing devicescan scroll with a dedicated gesture or scroll wheel, your app can instantaneouslyrespond to a click and drag to implement things like instantaneousdrag-and-drop, or drag select, as we see here in Pages. Previously, these interactionsrequired you to press and hold and wait with your finger to disambiguatebetween scrolling with a single finger and dragging on the content.Now let's take a step beyond the way the pointer interacts with your app, andthink about how the people using your app interact with the trackpaditself through gestures. While one finger interaction is largely reservedfor pointing and clicking, and three finger gestures are reserved by thesystem for actions like multitasking, your app can make use of two fingergestures on the trackpad. We'll automatically enable two fingers scrollingfor scroll views, but you may wish to provide more custom interactions.Be sure to design your trackpad gestures with a relationship to your touch screengestures to create a consistent experience across input modes. When addinggestures to the trackpad, we should always treat them as happening relativeto the pointer in your app. This means that gestures should be performedon the view under your pointer. In this example, the pointer is moved betweenthe left and right scroll views, and the scroll gesture is always performedon the appropriate view. Taking this a bit further let's take a look athow two-finger gestures behave in maps. As expected, the map scrolls withtwo fingers when the pointer is above it, and the card scrolls when thepointer is above it. But maps also allows using two fingers to zoom and rotate.This brings us to another detail about gestures behaving relative to the pointer-as we zoom and rotate, the view remains anchored to the pointer. This keepsthe pointer in a fixed position relative to the map below, no differentthan if I'd perform this gesture with my fingers on the touch screen centeredon the pointer. Because the two-finger gestures are intended to act relativeto the pointer, it follows that you should be able to use these gesturesdirectly on a focused element. Think about places in your app that alloweddragging with the finger today that could be adapted to a two-finger trackpad drag.Another capability of trackpads and mice is the ability to offer a secondary click.This can be exposed via two-finger click on a trackpads, a secondary buttonon a mouse, or even holding the control key and clicking, but the importantfact that these all have in common is that they're all fast and just aboutas easy as a regular click. This means we can instantaneously perform anaction that would have otherwise required a long press or a special modeto distinguish it from a regular tap with the finger. By default, we usethis to immediately show context menus. This is an accelerator for an actionthat would have otherwise required a long press. You'll get this for freein your app but in your custom interfaces you may want to consider theplaces that an accelerated or alternate action is appropriate for a secondary click.So we've learned a lot today. We've learned about adaptive precision, howto customize the pointer and its effects, and how to make use of pointerinteractions and gestures in your app. These are all small pieces whenviewed individually- adopting pointer effects to provide the right amountof precision and improve ergonomics, integrating hover to let your apprespond to intent, responding fluidly to two finger gestures,accelerating interactions with secondary click, and applying custom pointer shapes thatallow precision while using snapping to improve accuracy. But these smallpieces combine to form a whole powerful functional system that allows youto build a highly responsive, understandable interfaces combining unprecedentedprecision with ease of use. We hope you take what you've learned todayto elevate your already excellent touch screen apps and make them even more powerfulwith the pointer. Thank you.

Hello and welcome to WWDC.

Hi everyone. I'm Brandon Walkin, a designer on the Apple design team.I'll be joined later by other designers on the team - Marcos Alonzo, CC Wan, andDylan Edwards. We're gonna talk about how to design for the new pointerin iPadOS. Today we're going to talk about the design principles behindthe new pointer, go behind the scenes and take a look at how it works andthe different effects you can use. Then we'll talk about the appearanceof the pointer, how to make a custom pointer or shape using Pointer Interactions,and how to make your app work great with gestures on the trackpad.Let's start off with some of the thinking behind the new pointer. The iPadworks great with touch. So why would we want to add pointing. Well oneof the reasons is ergonomics. Adding trackpad capability, allows peopleto have a more comfortable experience where they can leave their handson the same plane as the keyboard instead of having to frequently reach up totouch the screen. We also wanted to make editing text easier. Editing textrequires a lot of fine manipulation and since the finger is a course screeninput it's more difficult to position the text cursor and make a selectioncompared to using a trackpad or a mouse. What's the best way to let peoplecontrol the interface using the trackpad. iPad is unique in that its interfacewas fundamentally designed for touch. Hit areas are generous, so they cansupport being easily tapped with the finger. And buttons are spaced furtherapart to avoid accidental mis-taps. We looked at just bringing the traditionalarrow pointer over from the Mac, but that didn't feel quite right on iPadOSwhere the entire operating system and every app is designed to be usedby an input the size of a fingertip. You'd be using a high precision toolto interact with low precision controls. This got us thinking more deeplyabout the concept of precision. The traditional arrow pointer can movevery precisely over the whole screen. This is great for certain tasks.Say you're making a marquee selection to edit a particular section of an image.

Or maybe you're just trying to select some texts from the middle of a paragraph.In these cases it's helpful to have very precise control over where thepointer is on screen, so you can place it just where you want it. But thishigh level of precision also has some downsides. Most of us are expertsat using mice and track pads and aren't conscious of this, but the traditionalpointer actually requires a lot of physical dexterity to use. Say you'retrying to click a button and you quickly move the pointer there, but endup clicking just a few pixels above the button and nothing happens.Or maybe you end up clicking between two buttons and neither is activated.

Or, say you intend to click the pause button and end up rewinding to thebeginning of the track. Let's take a close look at what's happening here.There are two independent layers that are interacting with each other.The interface layer and the pointing layer. The traditional pointer movesat pixel level precision. You can place it on any pixel of the interfacebut the underlying interface is built out of three button regions. It onlycares which of the three playback buttons you click, not the precise pixel coordinateyou click on a button. There's an inconsistency between the precision ofthe pointer and the precision required by the app. So while people generallythink about the pointer in terms of giving you increased precision comparedto touch. In this case it's helpful to actually reduce the precision ofthe pointer to match the user interface. This concept of dynamically adjustingthe precision of the pointer to match the precision of the interface iscalled, Adaptive Precision. Let's look at how Adaptive Precision works.

The pointer starts off as a circle. This is its default state when thepointing system isn't aware of any particular level of precision of theinterface around it.

It's sized to match a fingertip, since everything you're interacting withon iPad must be usable with touch. When you move the pointer to a groupof buttons, the pointer will adjust itself to match the precision of the buttons.

As I move the pointer into the group of buttons, it snaps itself to thebutton while morphing its shape to the shape of the button. The changein shape indicates its new reduced level of precision. As I move betweenthem the pointer will always snap its up to a button, making it clear exactlywhich one I'm interacting with. This feedback you get from the pointerreduces the likelihood that you'll miss click. You'll also notice thatthe pointer highlights the element rather than obscuring it. A traditionalpointer is drawn over the entire interface often obscuring the controlyou're interacting with. We thought it was important to have the controlsyou're interacting with completely unobstructed. In fact, when the pointersnaps to a control, the pointer actually moves along the z axis from beingin front of the app to being behind the buttons icon or label. This letspeople see the true color of the icon. The icon on the left with the pointer behindit has the brightness level that the designer intended. Now, let's lookat how the pointer interacts with text. You may have run into this issue before,where you try to select some text and you end up selecting the line just aboveor below the one you're aiming for. Here I'm trying to select the wordenvironment, but I've started my click just slightly too high and selectedthe line above. Why does this happen? Well, the traditional I-beam pointer movesup and down at pixel level precision letting you click on individual pixels.However, the text view behind it only cares about line-level precision- whichspecific line of text you're clicking on. Let's zoom in a little closer.There's an invisible boundary just above the line of text where if I movemy pointer just a single pixel over the boundary the TextView will thinkI'm interacting with the line above. This inconsistency between the inputprecision and the interface precision is what leads people to miss clickand select the wrong text. Now, let's unify the precision of the pointerand the TextView together with Adaptive Precision.

As the pointer moves over the TextView it morphs from the circle pointerto a beam shape that matches the line height of the text. It's a new levelof vertical precision. As you move the pointer up and down it snaps toeach line of text making it clear which line you're interacting with.In fact the pointing system makes it impossible to place the pointer in anambiguous position between two lines. You can give the pointer a differentamount of precision for each axis, so when you move horizontally we giveyou pixel level precision so you can place the insertion point just whereyou want it and make your selection. So we showed how the pointer snapsthe buttons and lines of text. You get both of these behaviors for freeif you use our standard UIKit controls. But let's look at an example ofwhen you'd want to use Adaptive Precision in a view that's custom for your app.

Here, we have a scheduling app that lets you manage events over a day view.

You make new events by clicking and dragging on the day view. It's commonfor these types of interfaces to round the start times of the events to15 minute intervals. So instead of your click and drag starting a meetingat 9:41 for example which is an odd time to start meeting, it'll round itto a more common start time of 9:45. While this is a helpful behavior,it often results in errors when you're trying to make an event that startsat a certain time. Say you're trying to make an event that starts at 2:30.But the interface ends up interpreting that click as 2:15, resulting ina frustrating experience. Turns out what's happening here is exactly thesame issue as with the TextView. Just like with the TextView, the verticalprecision of the pointer, is different then the vertical precision of the interface.The pointer is letting you start to drag at any pixel on screen, but theinterface only accepts drag starting within fifteen minute blocks. And theboundaries of these blocks aren't exposed to you. So it's not clear whatwill happen on click. And from a design perspective it may be distractingto visualize these regions using divider lines or hover states. Let's useAdaptive Precision to customize the precision of the pointer to match the day view.Now as you move up and down, the pointer is always snapped to a 15 minuteinterval, making it clear what time the event will begin. When you move quickly,you can just barely tell that it's snapping. But when you slow down, youreally feel it snap to those time blocks. Here Adaptive Precision makesit easy to start an event at just the time you want, and reduces potential errorsyou'd see with a traditional pointer. So that's Adaptive Precision.Now let's take a look at how the pointer works behind the scenes. When you movethe pointer around on screen, you're actually moving two pointers.The one you see on screen and an invisible one, that tracks the true positionof the pointer. We call this the model pointer. The model pointer is usedto decide which item the pointer is hovering over and it takes advantageof the generous padding that buttons have on iPadOS to make them easierto tap with the finger. Let's see this in action. Once the true pointerposition reaches the edge of the button's hit area, it begins to move andresize to highlight the button. This effect of animating the pointer towardsthe button is called snapping. Now the pointer doesn't actually move tothe center of the button at this point, though it may appear that way.The true position of the pointer still remains on the edge of the button.And this is indicated with a parallax effect. We do this so the amount thetrue pointer position moves on screen is always based on how much movementyou apply to the trackpad, making it feel more predictable. As you move thepointer along a set of buttons, the visible pointer will animate to thenext button. Once the true pointer position reaches the edge of the button'shit area. Once you lift your finger the pointer centers itself on the control.

This is called recentering. Recentering makes it easier to click the buttonwhen you put your finger back down on the trackpad. If you place a traditionalpointer near the edge of a button, released your finger and click,it's possible the finger may roll slightly, moving the pointer off of the button. The pointer then auto hides.After a short delay. We found that if the pointer persisted on screenit would remind people to perform their next interaction using thetrackpad rather than with touch or the pencil. We want people to feellike they can fluidly move between different inputs without thinking about it.

In fact there are many places on iPadOS where you can usetouch and the pointer simultaneously. For example with one hand you canuse the pointer to pick up an app icon, and with the other, you can swipe onthe touchscreen to move it to another page.This is a huge advantage to having both input methods available. For your app,think about how users will switch between different inputs, and even tryto use multiple at the same time. Now, let's look at how the pointer movesaround the screen. The MacOS pointer moves at a speed that you can customizeto what feels right for you. But it gets a little extra speed boost withsomething called an acceleration curve. The acceleration curve moves thepointer a longer distance the faster you move your finger on the trackpad.Here I'm swiping slowly, and swiping quickly, over the same physical distanceon the trackpad. We've carefully tuned the acceleration curve on the Macto work just right and we're using that same curve on iPadOS. But sometimesthe boost you get from the acceleration curve just isn't enough to quicklymove the pointer to where you want it. For instance, with a traditionalpointer, to move it all the way over to the settings icon, I need to performtwo separate swipes on the trackpad. I wish I could get there in just oneswipe, but if we made the acceleration curve stronger, or increased the speedof the pointer, it could make it hard to control. On iPadOS, we solve thisby adding inertia. Inertia makes it easy to move long distances with asmall amount of physical input, similar to how you can flick to scroll along distance on the touch screen. Now with just one flick on the trackpad,I can reach the button. When we were building the pointer we liked beingable to flick to target controls. But we found that based on the speed ofyour swipe, sometimes the pointer would overshoot or undershoot the control.

Wouldn't it be great if the pointer could just figure out which controlyou were aiming for and move there automatically. Well, the new pointerhas something called magnetism that does just that. Magnetism scans theinterface to find the control you most likely want to target. Let's goback in time to see how it works. At this point I'm mid-Swipe and my fingeris still touching the trackpad. The moment I lift my finger from the trackpadthe pointing system immediately calculates where the pointer would havelanded if it continued moving with inertia. We know that there isn't atarget there, so we start scanning around that position in circles up toa fixed radius. We'll find the nearest target in the direction of yourswipe and automatically move the pointer there. Since the settings iconis the closest snappable element to the projected position that is alsoin the direction of the pointer, we move the pointer there automaticallythe moment you lift your finger from the trackpad. We put a lot of workinto tuning this to feel just right. Ideally people aren't even aware thatthis is happening. The pointer just magically reads their mind and doesthe right thing. And what's great is any control in your app that supportspointer snapping gets magnetism for free.

We just learned about why we added a pointer to iPadOS, the power of AdaptivePrecision, and went behind the scenes to look at how the pointer works withsnapping, recentering, inertia, and magnetism.

Now I'm gonna pass it off to Marcos who's gonna talk about how you canuse pointer effects in your app.

Things Brandon. Hi everyone. In this section we're going to have a look atthe different pointer effects you can use when adding trackpad support to your apps.

When the iPadOS pointer hovers over an interactive element, both the appearanceand the behavior of the pointer and the interactive element become one,bringing focus to the item that is being targeted. We refer to this integrationof pointer and the content as a Pointer Effect, and it changes based oncontext and content type. iPadOS provides 3 pointer effects you canuse to bring focus to the interactive elements in your app. So when addingpointer support to your apps, you can use one of the provided effects,you can modify them to suit your app, or design a completely new oneif you desire so. The first effect we provide is called Highlight Effect.This effect is used for small controls that don't have a background and it'sthe default effect for bar buttons and tab bars. For instance, when the pointerhovers over a control it becomes a controlled background by moving behindit while adopting a lighter color. When the control gets selected, its contentsscale up and move with the pointer with a gentle parallax effect. A lighteffect connected to the pointer movement is added on top to highlight theobject. And on click, the three layers scale down and move to the object center.

The next effect we provide is the Lift effect. You might want to use itfor medium sized elements that already have a background. The pointer transformsinto the element, highlighting it without obscuring its contents.Examples of this effect in iPadOS are the app icons or the control center modules.When the pointer approaches a control it disappears behind it. The objectappears lifted by scaling up and adding a shadow. And the color of the itembleeds around it and illuminates the background behind it. Let's look athow the effect works when an object gets selected. These are the differentlayers that are added on top and below the selected element. A soft specularhighlight is added on top of the element to illuminate it. The elementitself is scaled up and its colors bleed around it covering its surroundings.This light effect is called radiosity. And lastly a shadow is projected underthe element to give the illusion the element is floating above the screen.

The specular light is used to highlight the selected object but it hasa second purpose. The position of the light shows the actual position ofthe pointer under the hood. As you can see with a dash circle here. thespecular light shows you where the pointer is and connects your gestureswith the movement on the screen. The strength of the light is based onthe object size too. It gets bigger and brighter for bigger elements wherethe position of the pointer is harder to see. And gets smaller or it'snot visible at all for smaller objects that don't require it. This is automaticallydone by the system, so you don't have to worry about it. The last effectwe provide is called Hover. It is generally used for larger objects thatwould behave poorly if the pointer were to morph into their shape. Whenthe pointer hovers over an object that uses this effect, the object changesits appearance to show its being focused and the cursor retains its defaultshape and remains visible on top of the object. This effect is highlycustomizable and it can be just a scale of the object and a shadowto lift it, a color tint added to the object, or any combination of the three.So how do you use a different effect. Let's have a look at how to pickthe best effect for your app and how to use it. The main rule when pickinga pointer effect is to try the Automatic Effect first. When using theAutomatic Effect the system uses a combination of rules like the objecttype and location, and the object size and shape to decide the best effectfor it. These rules can change in the future, so using the Automatic Effectensures your app will always look good. Using the Automatic Effect is very easy.Just pick "automatic" when assigning a UIPointerEffect to your interactive element.

For more technical and implementation details check out the talk "Build for theiPadOS Pointer Interactions" from this year's WWDC. Well the automaticeffect is not always the right solution. Like in this example from thebooks app. The bookmark icon on the right has its own background and seemslike the Lift effect should be the appropriate one for it. But becauseit's in a toolbar next to other buttons that use a Highlight effect it feelsout of place and we shouldn't use it. The right thing to do in this caseis to use the Highlight effect. The Highlight effect will make the button lookconsistent with the other buttons around it. You should try to be consistentwith designing the size of your objects too. Like in this example, we havethree buttons side by side, but their highlight background size is not consistent.

This discrepancy will look bad when the pointer moves over them. So makesure the objects in the same group have a consistent size between them.

For toolbar sized buttons like in this example we recommend using a heightof 37 points. Effect consistency is not always the right choice though.For instance, when we were designing the pointer behavior for segmented controls,we arrived at the conclusion that mixing effects was the right thing todo in this situation. So even though day and month use the Highlight effectand get a rounded rectangle around them when focused, using the highlight effectfor the selected option looks out of place. In general you should tryto avoid the highlight effect around rectangular objects. The right thingto do in this case is to use the Lift effect so the selected option appearslifted above the control around it. The hit region of the object willdetermine the area your Pointer Effect is active and you should make sureit's the right size. If the hit region is too small, it can make peoplefeel that they have to be extra precise when interacting with the element.

On the other hand when an element's hit region is too large, people canfeel that it takes a lot of effort to pull the pointer away from the element.So try to find a region that feels comfortable. In general it works well toadd about 12 points of padding around elements that include a bezel.

And about 24 points around elements without a bezel. An extended hitregion will also make your apps more comfortable when using the touch screen.

A common issue when defining your hit region is leaving a gap between objects.This will make the pointer morph back into the circular shape betweenthem, creating an unnecessary animation. So make sure your hit region extendsbetween your objects leaving no gap between them. That way the pointerwill flow nicely between them. This change will make your apps work muchbetter with touch too. A common problem when adopting the Lift effectis the extended shadow around it because your app was not designed for theextended size of the object the shadow might get clipped by other UI elementsaround it. So make sure that the objects that adopt the Lift effect areon top of their surrounding layers to ensure the shadow is rendered correctly.

Next we're going to have a look at how to customize and combine the pointereffects in your app. When using the Highlight and Lift effects you can specifythe size and corner radius of your object. If your object has a circularshape or the corner radius is not 8 points it is very important that youprovide the correct corner radius. Otherwise it will not render correctly.

When using the Hover effect your object can scale up or have a shadowwhen it is highlighted, like we see in this example. Both the scale effectand the shadow can be turn on and off so you can pick the right combinationthat matches your app design. But in general we don't recommend using theshadow if you're not scaling your object. Another effect you can combinewith Hover is tinting. You can use it to highlight objects you don't want to scaleas you can see here for notifications. When tinting is turned on it willadd a special material on top or below the object and change its color.This material can be dark or light depending on your dark mode settings.

When using the Hover effect you can provide a custom shape for your pointertoo. The pointer will morph from the full circle into the provided shape whenit hovers over your object like the I-beam pointer we use for text on iPadOS.Custom pointers can show you extra information about a specificregion on the screen or a change in the pointer behavior. We're going tolearn a lot more about custom pointers in the next section. If we visualizethe actual position of the pointer we can see how the I-beam tries to stayin the center of the text field. This effect is called snapping and createsa magnetic attraction that pulls the pointer to the center of the object.

It increases the precision of the pointer and creates a more comfortableexperience when interacting with your app controls. You can use this effectin your apps too. Adding snapping to controls helps you be more preciseand simplifies common tasks like grabbing small handlers, as you can seein this example. Just remember you should never enabled snapping if you'renot providing a custom pointer. So we just had a look at the three-pointereffects provided by iPadOS, Highlight Lift and Hover. Remember you shouldtry to use the Automatic Effect whenever possible. Be consistent pickingthe pointer effects and designing your object's shape. Extend your objectshit region to make it more comfortable to use. Remember when using theLift effect, you have to provide the correct size and corner radius.And if you use the Hover effect you can enable a scale, a shadow, or a tint colorfor your object. I hope this section gave you a good overview of the differentpointer effects provided by iPadOS and how to successfully use themto create a great pointer experience for your apps. That's all for me.I'm going to pass it over to CC who is going to show you how to designa great pointer for your app. Thank you.

Thank you Marcos. Hi everyone. I'm going to talk about the pointer appearanceand how to design a custom pointer. First let's look at the pointer material.

The pointer in iPadOS has a material that constantly adapts to the backgroundcolor smoothly. It provides optimal contrast at all times without beingdistracting. When the background color changes, so will the pointers color.

This material maintains contrast without obscuring the background.That is because when people are using the iPad with the trackpad we want thepointer to be there to show the location of interaction. But it shouldn'tdraw too much attention to itself and take away from the content.However, the pointer should indicate intention when it's needed. In this case whenthe pointer is transformed into a button shape, not only does it changeits shape but the color of it also become lighter to provide good legibilityto the label. On top of that when people click, the circle scales down andbecomes darker to provide a satisfying feedback for the click action.These are examples of the pointers material adapting to its function. And allof these color adaptations are provided by the system automatically.Next, we are going to look at the pointer shape. As Brandon mentioned earlier,the pointer shape is a circle that represents touch. The size of its relateswell with the touch-based UI elements. The circle shape provides a perfectfoundation for it to transform into any shape. In the previous examplethe pointer transformed from a circle to a round rectangle to highlightthe button. This is our first type of pointer shape transformation - froma circle to a rounded rectangle. And it's not just for buttons.The circle can transform to a vertical bar for an I-beam, a horizontal pillto highlight the top status region, or to highlight a grabber. These areall considered the rectangle type of pointer transformation. The secondtype of transformation is when the circle morphs into any arbitrary shape.

This can be used to inform people when there is a change of functionalityor precision. For example the pointer can turn into a cross shape to indicatean area with higher level of precision. It can also transform into a pairof triangles to inform people the direction of a drag movement or whenthe command key is held down and the functions of the pointer is modified.

Both of these transformations are available with their corresponding APIs.

If the pointer is going to morph from a circle to a rectangle shape,apply the top API. If it is changing to a more complex shape, use the bottom one.

And check out the talk "Build for the iPadOS pointer" for more detailson how to use these APIs. Now, let's talk about how to design a greatcustom pointer. As we just learned the pointer in iPadOS has many waysto morph it's color and shape. These behaviors provide the pointer withthe flexibility to fully adapt to its context at any given moment. Whenwe design a new custom shape for it, we should keep in mind this characteristicof a constant state of transformation. So, how do we design a great customshape for the pointer. First, make sure your custom shape is simple andeasy to understand. The shape of the pointer informs people the actionthey can take in the current context. For example, in Keynote, the pointertransforms into a pair of arrows that show the direction in which peoplecan drag a selection handle. If people cannot instantly understand yourcustom pointer, they are likely to waste time trying to figure it out.

Second, you solid shapes as much as possible. Remember the pointer color isconstantly changing. A solid shape will maintain legibility and make it easyto read. A shape with strokes will be difficult to read. But if it happensthat you cannot use a solid fill shape, use heavy strokes and make surethe stroke weight is thick enough to maintain visual weight. It will bedifficult to see the pointer if the stroke is too thin. And don't forget touse a size that is similar to the default pointer. The size of a customshape should visually balance with the default pointer which is a 19 point circle.In other words if you have a shape that is narrow you may want to makeit bigger to maintain a similar visual weight. In this example the crossmark is 24 points compared to the 19 points circle. Keep in mindthat the pointer will morphs from its default state to the custom state.

If the custom pointer is too small it may get lost. And if there is a bigsize difference between the two states the transformation can become jarringand distracting. Now when you design your custom pointer, make sure the shapecommunicates its intention as directly as possible. Here's an example.Say if you're designing an app to read and highlight text. Instead of usinga marker pen glyph as the custom highlight pointer, a better solution isto show the marker tip shape. In this case the shape not only informs peoplethe height of the text selection but also resembles the I-beam, which impliesall the system behaviors of adaptive position and snapping. The shape ofthe marker tip has the same anchor points as the circle, resulting in anice transition between the two shapes. Speaking of anchor points, whendesigning a custom pointer, we should also make sure the anchor pointmatches well. If your custom shape is a circle, a simple geometric shape,or a symmetrical shape, it's natural to see the point of interaction asthe center of these shapes. If the shape is directional or with aspecific focus area, we will need the anchor point set to match the intent.

However it also means the transformation will appear to be off-centered.

It would be nice to think of other ways to indicate these functions andmaintain the center anchor point as much as possible for a nice experience.

In this example instead of using an eyedropper glyph as our custom pointer,we can use a target shape for precise color sampling. Lastly a couple ofthings to keep in mind when designing a custom pointer. Make sure you applystandard pointer behaviors on your custom pointer. For example if buttonsin a custom navigation bar don't use the standard highlight effect, peoplemight think they are broken. Apply similar functions to similar pointers.

For example, if your app helps people draw, every drawing area in your app shouldhave a similar pointer experience - so that people can apply the knowledgethey gain in one area to the others. Last but not least, try not to createunnecessary custom pointers. People notice when the appearance of the pointerchanges and they expect the change to be useful. Creating a purely decorativepointer effect can distract and even irritate people without providing anypractical value. All right. We just learn about the pointer of material, pointershape, and how to design a great custom pointer. I'm sure you can createa pointer that makes your app feel native and intuitive when people experienceit with a trackpad. Now, I'm going to pass it to my colleague Dylan. He is goingto talk about Pointer Interactions.Thanks CC. Let's talk about all the new interactive behaviors yourapp can gain with the pointer. Let's start by talking about increasingprecision in your app. The presence of a pointer means that people cannow interact with your app with much greater precision than previouslypossible with the finger.So how do we let them take advantage of this without redesigning our apps entirely.

We can use the pointer to do finer grained selection as well as addingquicker interactivity to smaller elements of your interface. A great exampleof finer grained selection is the text editing experience on iOS. As shown here,you can use the low precision input of your finger to perform text selectionon a word boundary and then use the drag handles to carefully adjust your selection.But with the high precision input of the pointer this interaction is abit different. As Brandon described, the narrow beam pointer makes it easyto see exactly where you're selecting, while we also snap it to the currentline and grow its height to match the line height, reducing the ambiguityof its position. Because of this high precision and low ambiguity affordedby the pointer, we can begin selecting with character level precision immediately.

Consider places in your app where you might need a more precise pointer,or where you can use snapping to aid people in navigating your UI, and striveto always use a pointer that matches the precision necessary for the current task,defaulting to the circle when necessary. You can find another case of thistype of precise input here in Numbers. Using our finger we can tap to selecta column header, and then drag a finger on the exposed drag handle to resizea column. But with the precision of pointer input, we can actually exposea control that isn't available with the finger. Rather than selecting acolumn to expose a resize handle, we can move the pointer directly to thesmall divider between columns and begin dragging, again avoiding the needto first make an imprecise selection to achieve our goal. It's importantto note that neither of these examples adds new functionality for the pointer,but rather they use the added precision to make this functionality easierto use with the pointer. You should avoid updating your app's layout,increasing density, or introducing features that only work with the pointer, but insteaduse the pointers precision to make using your app quicker and more intuitive.The pointer clearly enables new possibilities with precise input, but that'sonly half the story. The pointer system really shines when you make greatuse of adaptive precision. Let's take a look at how you can make your larger,low precision interfaces work wonderfully with the pointer too. Adoptingpointer effects and places where high precision isn't necessarystill can vastly improve the experience of your app. A great example is the interfacein Reminders for creating a new list. These are approximately finger sizedtargets- a UI that already works great with the finger- but adding the Lifteffect to these creates a fun and easy-to-use picker that gives exactlythe amount of precision required. Consider places in your app that adjacentcontrols can use pointer effects to gain great visual feedback and snappingbehaviors. As Marcos described previously, in cases of even larger UI thatmay behave poorly with a morphing pointer, you can still adopt a Hover effect.This isn't just for show. It can provide a lot of information about precision.

The Calendar app often has events much larger than a finger. While youmight think such a course UI doesn't need to adapt to the pointer,this is actually an excellent place to add a Hover effect to indicate interactivityand disambiguate in cases of overlapping events. Now I'd like to sharehow the unique characteristics of pointer input can accelerate some ofthe interactions in your app. The pointers presence on the screen servesas a great indicator of intent. We can use this new information to speedup interactions that previously would have required a tap. Now that weknow the position of the pointer we know that hovering over a region meansa person is likely to interact with it and our app can respond proactively.

For instance the Books app makes use of the hover position of the pointerto control the visibility of its toolbars. We can hide the bar interfacewhile reading to reduce distraction but immediately reveal it when thepointer moves over it, removing the need for a click to hide and show. Thepointers movement, or lack thereof, can also be a helpful hint to updateour UI. In a full screen experience, or immediate playback, you might wishto automatically hide UI after a period of inactivity. In these cases, pointermovement is a clear indication that someone wants to interact with yourinterface, and can be used to reveal your controls. Because pointing devicescan scroll with a dedicated gesture or scroll wheel, your app can instantaneouslyrespond to a click and drag to implement things like instantaneousdrag-and-drop, or drag select, as we see here in Pages. Previously, these interactionsrequired you to press and hold and wait with your finger to disambiguatebetween scrolling with a single finger and dragging on the content.Now let's take a step beyond the way the pointer interacts with your app, andthink about how the people using your app interact with the trackpaditself through gestures. While one finger interaction is largely reservedfor pointing and clicking, and three finger gestures are reserved by thesystem for actions like multitasking, your app can make use of two fingergestures on the trackpad. We'll automatically enable two fingers scrollingfor scroll views, but you may wish to provide more custom interactions.Be sure to design your trackpad gestures with a relationship to your touch screengestures to create a consistent experience across input modes. When addinggestures to the trackpad, we should always treat them as happening relativeto the pointer in your app. This means that gestures should be performedon the view under your pointer. In this example, the pointer is moved betweenthe left and right scroll views, and the scroll gesture is always performedon the appropriate view. Taking this a bit further let's take a look athow two-finger gestures behave in maps. As expected, the map scrolls withtwo fingers when the pointer is above it, and the card scrolls when thepointer is above it. But maps also allows using two fingers to zoom and rotate.This brings us to another detail about gestures behaving relative to the pointer-as we zoom and rotate, the view remains anchored to the pointer. This keepsthe pointer in a fixed position relative to the map below, no differentthan if I'd perform this gesture with my fingers on the touch screen centeredon the pointer. Because the two-finger gestures are intended to act relativeto the pointer, it follows that you should be able to use these gesturesdirectly on a focused element. Think about places in your app that alloweddragging with the finger today that could be adapted to a two-finger trackpad drag.Another capability of trackpads and mice is the ability to offer a secondary click.This can be exposed via two-finger click on a trackpads, a secondary buttonon a mouse, or even holding the control key and clicking, but the importantfact that these all have in common is that they're all fast and just aboutas easy as a regular click. This means we can instantaneously perform anaction that would have otherwise required a long press or a special modeto distinguish it from a regular tap with the finger. By default, we usethis to immediately show context menus. This is an accelerator for an actionthat would have otherwise required a long press. You'll get this for freein your app but in your custom interfaces you may want to consider theplaces that an accelerated or alternate action is appropriate for a secondary click.So we've learned a lot today. We've learned about adaptive precision, howto customize the pointer and its effects, and how to make use of pointerinteractions and gestures in your app. These are all small pieces whenviewed individually- adopting pointer effects to provide the right amountof precision and improve ergonomics, integrating hover to let your apprespond to intent, responding fluidly to two finger gestures,accelerating interactions with secondary click, and applying custom pointer shapes thatallow precision while using snapping to improve accuracy. But these smallpieces combine to form a whole powerful functional system that allows youto build a highly responsive, understandable interfaces combining unprecedentedprecision with ease of use. We hope you take what you've learned todayto elevate your already excellent touch screen apps and make them even more powerfulwith the pointer. Thank you.

## Code Samples


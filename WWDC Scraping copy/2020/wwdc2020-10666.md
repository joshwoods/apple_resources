# Wwdc2020 10666

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

One-tap account security upgradesWhen you adopt the Account Authentication Modification Extension, you can provide people with fast, easy account security upgrades to use Sign in with Apple and strong passwords in the iCloud Keychain Password Manager. We'll show you how to add these upgrade flows to your app with the Account Authentication Modification Extension, the AuthenticationServices Framework API, and best practices required for a smooth password transition.ResourcesAuthentication ServicesImplementing User Authentication with Sign in with ApplePassword AutoFillSign In with AppleHD VideoSD VideoRelated VideosWWDC22Enhance your Sign in with Apple experienceWWDC20Get the most out of Sign in with AppleStreamline your App ClipWWDC19Introducing Sign In with Apple

When you adopt the Account Authentication Modification Extension, you can provide people with fast, easy account security upgrades to use Sign in with Apple and strong passwords in the iCloud Keychain Password Manager. We'll show you how to add these upgrade flows to your app with the Account Authentication Modification Extension, the AuthenticationServices Framework API, and best practices required for a smooth password transition.

Authentication Services

Implementing User Authentication with Sign in with Apple

Password AutoFill

Sign In with Apple

HD VideoSD Video

HD Video

SD Video

Enhance your Sign in with Apple experience

Get the most out of Sign in with Apple

Streamline your App Clip

Introducing Sign In with Apple

Search this videoâ€¦Hello and welcome to WWDC. Hi there.My name is Jay Mulani and I'm going to talk to you about one tap accountsecurity upgrades. I'm so excited to talk to you today about what we'veadded in iOS this year to help improve your user's account security.We've got some great new features that raise user awareness about account securityrisks and with your buy-in make addressing those risks faster and easier than ever.We'll get started with a brief discussion on account security and thenwalk through security recommendations new in iOS this year. I'll showyou how to adopt our new extension point to offer your users fast, easysecurity upgrades on the operating system and then how to add those flowswithin your app. We'll close with some best practices on adopting the extension.Let's start by talking about account security. Accounts are staples ofour identities. We use them to manage our most personal private data andto access services that power our lives. Accounts manage our finances, health,emails, social media profiles and more. Accounts are so important.They're ever-growing integral role in our lives means that we have a lot of themto keep track of and that they need to be carefully protected. Most accountsare unlocked with passwords and so account management is heavily dependenton password management. Many of you are already using iOS and macOS featuresto make password management easy for your users. Password autofill providesusers with a super fast and convenient login experience. Authentication Servicestakes this a step further and removes a keyboard from the sign in processSecurity code autofill streamlines the log-in process for accounts thathave SMS two-factor authentication enabled. And Sign in with Apple completelyremoved the password component of account management. It's the fastestway for users to get a new account in sign-in. Account should be convenientto use and secure. These features I just mentioned integrated into yourapps make signing in super easy.And this year's iOS we've added new account management features and APIsto help you keep your users' accounts secure.My goal today is to show you how beneficial it is and how easy it is foryou to use these new features to continue our joint mission of keepingusers accounts secure. To motivate that, let's talk about the new security recommendations feature.Every iPhone and iPad has the built-in iCloud keychain password manager.It's deeply integrated with the operating system and securely synchronizespasswords across all of the users devices.It provides easy password look up and powers password autofill, and nowit's home to security recommendations. This new section of the passwordmanager will show all of the warnings the system has found with passwordssaved in keychain. Security recommendations educates users about why certainpasswords are flagged and motivates them to take action. High priorityrecommendations will be highlighted based on the severity of the warningand the type of account. The system will flag passwords that are reusedacross sites, easily guessed, and new this year iOS will flag passwordsthat are seen in public data breaches. In fact iCloud keychain will showusers notifications when one of their passwords has been seen in a data breach.Tapping on one of those notifications will bring them into security recommendations,to view the warning for the password.Having a password to be publicly breached puts all accounts using thatpassword at risk. We'll show this notification for any account using apassword that has been breached, even if the breach came from another service.Each of the warnings and security recommendations will include actionsthe user can take to fix the corresponding account. One option users willhave to fix their accounts is the change password on website button.This will take the user to the web to the credentials well-known change password URL.If the service has adopted that standard. This is great for motivated usersbut navigating through a website to change your password is a hassle.Most users avoid changing passwords because doing so feels like so much work.Ideally users should be able to visit security recommendations and quicklymake progress on addressing their warnings. New in iOS this year, it willbe possible with just the tap of a button in the password manager for usersto upgrade at-risk password based accounts to an automatically generatedstrong password or even to use Sign in with Apple. These upgrades are poweredby the new account authentication modification extension. These extensionschange user perception on fixing accounts. They provide fast, easy accountsecurity upgrades. The extension point offers two upgrade options, upgradingto Sign him with Apple and upgrading to a strong password. If necessary,extensions allow the opportunity for additional user authentication beforecompleting an upgrade. For example, you may want a user to enter SMS two-factorauthentication code before they switch their account to use Sign inwith Apple. With just one extension implementation, these upgrades can beaccessed from three places: in the password manager, when looking at apassword detail view, directly off of a high priority recommendation itemand security recommendations, or third the automatic system prompts whenusers sign into your apps. The system will prompt users with security recommendationswhen they sign into your app with a weak or breached password. Once you'veimplemented an extension you can also add these upgrade flows within yourapp using new authentication services framework API. This is an awesomeway that you can offer system integrated account security upgrades withthe user experience you want your users to have in your app. We'll walkthrough how to do this towards the end.Now that I've introduced the new account authentication modification extensionpoint, let's walk through how to implement an extension. Throughout the presentation,I'll be adding upgrades to my test app, Shiny. We're going to walk throughfour different aspects of implementing the extension. Depending on whichupgrades you choose to support. some of these steps may not apply to you. Regardless,they'll all help you better understand what's involved in this process.We'll start by discussing how to associate your app with your domain. Foryour app to be able to upgrade users accounts saved in the password manager,you'll need to securely associate your app and domain. If you haven't alreadydone this for your app to support passwordautofill, it's really easy.You'll serve a JSON file on your domain server that identifies that thedomain is affiliated with your app. For the purpose of time your app anddomain together for authentication, use the web credential service then,you'll add a matching associated domain entitlement to your app. You cando that in Xcode by adding the associated domain capability and specifyingthe domain for your app. Once you've associated your app with the web credentialservice, your app will be eligible to offer an upgrade for a password savedin the user's iCloud keychain. For more information about associatingapps and domains, check out the WWDC session.Introducing Password Autofill for Apps. And that was associating your appwith your domain. Now it's time to implement a strong password upgrade.A strong password upgrade helps users by giving them a strong unique passwordfor your service. The very first step will be to create a new target inyour project using the new account authentication modification extensiontemplate in Xcode. Next, you'll need to declare support for strong passwordupgrades in your extensions info plist. Setting the AS account authenticationmodification supports strong password change key to yes will tell thesystem to offer the strong password extension upgrade option for credentialsfor your app. The template will declare support for both upgrades by default.If you don't want to support this upgrade you can just set the key to no.You'll implement your extension in a special subclass which will be thebrain of the operation and contains the business logic for the upgrade.including communicating with your back-end server to commit account changes.It's exposed out of the authentication services framework and you'll noticethat it's a view controller. The reason it's a view controller is becauseyou'll have the flexibility to show security step up UI to have the userfully authorized before performing an upgrade, if necessary. We'll talkabout that later. And for right now, we'll cover upgrade flows without securitystep up UI. When users tap an extension upgrade button within the passwordmanager, or just after signing into your app, the system will launch yourextension and start an upgrade request, with a system generated strong passwordand an existing credential. The system will call change password withoutuser interaction on the view controller to begin the request. Passing ina service identifier which provides the domain or URL for the passedin credential. The service identifier is useful if your extension offersupgrades for several different services. You'll also be passed a new, uniquestrong password generated by the system and user info which we will revisitwhen we talk about in-app upgrades. This argument will always be nil forsystem initiated upgrades. Upon receiving this initial request your extensionneeds to authorize the upgrade before proceeding. Communicating with yourback-end server to do so. The result of the authorization will decide whatyour view controller should do next. Your extension should check with yourback-end server to see if it is authorized to perform the upgrade for thepassed in credential. You can also leverage any existing log and cookiesor tokens stored in a data container shared between your app and extension.If the upgrade is authorized, you can continue with the upgrade. If not,you'll need to cancel the upgrade. When your extension is informed thatthe authorization failed, it should cancel the request. In your extensionimplementation you should do this by cancelling the request with the failederror code. If you'd like to provide a failure message to be shown to theuser you can specify one in the user info using the AS extension localizedfailure reason error key. If not the system will provide a default errormessage and encourage the user to try again later. If upgrade authorization succeeds,you can commit the change on your end and complete the request. In thissuccessful case your extension should commit the change on your back-endserver. If the change commits successfully you can complete the upgradeby calling complete change password request using an AS password credentialwith the username and updated password. Note that you can change the newpassword passed in from the system if you need to. If you end up doingso  you should be sure to pass the correct password to the completion method.That's the password that will be saved to keychain. This is an example passwordthat iCloud keychain could generate. It's a strong password designed tobe easily typable for those times at autofill can't help the user withusing the password. It's also designed with the length and character setto be compatible with most services. That said if the iCloud keychain generatedpasswords aren't compatible with your service you can specify your ownpassword rules to ensure iCloud keychain generates a compatible password.You can specify password requirements for your app with a technology calledpassword rules. At the Password Rules website, you'll find a validationtool that you can use to make your password rule string. You can then addit to your extension's info plist using the AS account authenticationmodification password generation requirements key. Once again, you shouldonly need to do this if you find the default passwords generated by thesystem are not compatible with your password rules. And that's how you supportstrong password upgrades. Next,let's look at supporting upgrades to Signin with Apple. Before adding Sign in with Apple upgrades, you'll needto support Sign in with Apple. Check out these talks for more informationon adding Sign in with Apple support to your apps. Just as we saw with strongpassword upgrades, you'll need to declare that your extension supports Sign inwith Apple upgrades and your extensions info plist. You'll do this by settingthe AS account authentication modification supports upgrade to Sign inwith Apple key to yes. By default the template will declare support forboth upgrades. If you don't want to support this upgrade, you can justset it to no. Sign in with Apple upgrades start just like strong password upgrades.The system will launch your extension and make the upgrade request withan existing credential. The system will call convert account to Sign in withApple without user interaction on the view controller to begin the request,passing in a service identifier and an existing password credential.And finally, user info which we'll ignore until we talk about in-app upgrades.User info will always be nil for system initiated upgrades. Once again,your extension will need to authorize the upgrade. Your extension shouldcheck with your back-end server to see if it is authorized to perform theupgrade for the passed in credential. You can also leverage any existinglog-in cookies or tokens stored in a data container shared between yourapp and extension. If the upgrade is authorized, you can continue with the upgrade.If not, you'll need to cancel the upgrade. When your extension is informedthat the authorization failed, it should cancel the request. In your extensionimplementation you should do this by cancelling the request with the failureerror code. You can use the AS extension localized failure reason errorkey to communicate the reason for the failure to the user, if you'd like.When upgrade authorization succeeds, your extension should request a Sign inwith Apple credential for the upgrade. In code your extension will requestthe credential from the system by calling get "sign in with Apple" upgradeauthorization on the extension context. This method takes state and nonsarguments that you can use to securely verify the Apple ID credential forthe upgrade. To learn more about this you should check out the Sign inwith Apple talks referenced earlier. It's possible that when you call thismethod the system won't be able to return a credential and your extensionwill need to fail the request. The system may fail to return a credentialhere for various reasons, such as the user tapping the cancel button onthe system sign in with Apple sheet or if there's a bad network connection.In this case your extension will cancel the request with the failure error code.If the system returns a Sign in with Apple credentials successfully, you shoulddo the necessary bookkeeping to process the upgrade on your end, and thensuccessfully complete the request. In code once your extension has successfullycommitted the upgrade on your back-end server it can complete the requestby simply calling complete upgrade to Sign In with Apple on the extension context.One of the promises of Sign in with Apple is having one fewer passwordto manage and keep track of. Once the upgrade is completed, the system willdelete the keychain password credential used for the upgrade.These flows cover the ideal scenarios for upgrades with minimal user interaction.However, in some cases your extension may require some additional user authenticationto complete an upgrade. Your extension will have the capability to showsecurity step up UI and upgrade flows. As an example, you may want the userto enter a two-factor authentication code to complete an upgrade.Let's pick back up on the flow when your extension is verifying the credentialpassed in for the upgrade. When your extension is checking with your back-endserver to authorize the upgrade, we saw that if the upgrade is authorizedyou can continue with the upgrade, or if not, you'll need to cancel the upgrade.But now, we'll consider a third possibility in which further authorizationis required to complete the upgrade. When further authorization is requiredyour extension can cancel the initial request and specify that it needsto show security step up UI. Your extension can do this by canceling theinitial request with the user interaction required error code. In response,the system will create a new request configured to allow user interaction.The system will call prepare interface to change password on your viewcontroller subclass for strong password upgrades. For Sign in with Apple upgrades,the system will call prepare interface to convert account to Sign in withApple. In each of these methods your extension should quickly do any worknecessary to prepare the interface to be presented. Once this method finishesthe system will present your interface. Your interface will be presentedwith a system provided navigation bar with the name of the containing appfor the extension is the title and a cancel button. Once your interfaceis presented there are three possible scenarios. If the additional userauthentication fails or something else goes wrong, you can fail the requestby cancelling with the failure error code. The second scenario is thatall goes well and you can continue with the upgrade. For a strong password upgrade,the next step will be to commit the password change. For a Sign in withApple upgrade, your extensions next step will be to request the Signwith Apple credential. The system will take this as a sign that the workin your security step up UI is complete and will dismiss it to show thesystem sign in with apple sheet. From here, the upgrade will continue thesame exact way we saw earlier. The third possibility, regardless of theupgrade type, is that the user taps the system provided cancel button.In this case, your extension will need to cancel the request. The system willcall cancel request on your view controller subclass. The superclass implementationof this method simply cancels the request with the user cancellederror code. If you want the ability to clean up state before the request is cancelled,you should override this method and be sure to still cancel the requestat the end.We've completed the core implementation for the extension and the hardwork is done. Now, if you want to use the upgrades from within your app,all you have to do is invoke the extension.Let's talk about in-app upgrades. In-app upgrades begin when your app createsand performs an upgrade request. Performing the request will launch your extension.The requests will have a username and will not have a password. There isno password in this flow because your app should not be able to provideplain text passwords and because, unlike the system, you won't have a handleto a keychain credential to perform the upgrade with. However, you may passany information you'd like to your extension for the upgrade with the userinfo property of the request object. We ignored this earlier because it'salways nil for system initiated upgrades. Your extension can use this informationto authorize the upgrade. The upgrade authorization process works as outlinedbefore, where your extension will need to talk to your back-end server toensure the account is authorized to perform the upgrade - with the same threepossible outcomes of successful authorization, failed authorization, or findingthat further authorization is required. Ideally you shouldn't need anyfurther authorization in this flow as the user has already logged intothe app. Let's add in-app upgrades to the account settings section of theShiny app. Let's start with in-app strong password upgrades. The upgradewill be added here and the handler for the change to strong password buttonand the account setting section. The first step is to specify the serviceidentifier for the credential to be upgraded by creating an ACE credentialservice identifier for the Shiny app. The next step is to get the usernamefor the upgrade. Remember that for in-app upgrades, your extensionwill not receive a password. You can authorize the upgrade by passing authorizationinformation in on the requests user info. In this example, I'm passing inthe off token for the current user logged into the Shiny app for the shinyextension to use to authorize the upgrade. These three pieces of informationare used to create a strong password upgrade request. Next, we need to createan AS account authentication modification controller to perform the request.In order to be informed of the results of the upgrade, the view controllerneeds to be set as the upgrade controllers delegate. Lastly, a presentationcontext provider must always be provided to tell the system the windowto show UI in. Once this is all done, the requests can be performed.Now, let's quickly see how to add in-app Sign in with Apple upgrades.They're very, very similar to the strong password upgrades we just saw. The onlydifference for the in-app Sign in with Apple upgrades will be to createand use a sign in with Apple request object. For in-app upgrades you arein control for communicating upgrade results to the user with your user interface.The AS account authentication modification controller delegate protocolhas two methods to handle upgrade results. There's a method that will becalled for successful upgrades where you should inform the user that theupgrade succeeded. After a successful upgrade, the system will look fora keychain credential for your service with a user username used in the upgrade.If a keychain credential is found it will either be updated or removed,depending on the type of upgrade. There's also a method to indicate anupgrade has failed. Where you should inform the user that it failed and providethe reason why, if possible. Here's a successful sign in with Apple upgradein the Shiny app. People love Sign in with Apple. Providing this upgrade flowin your app allows your users to convert existing accounts to Sign in withApple without having to create a new account. We just looked at addingupgrades in an account settings view. Another great opportunity to offerupgrades is when a user transitions into using your app after using yourapp clip. Let's quickly review some best practices for adopting the accountauthentication modification extension point. Keep upgrades as quick andas effortless as possible. Only request to show your extensions UI whenabsolutely necessary. Your extension can authorize upgrades by communicatingwith your back-end server but you can also leverage any existing logincookies or tokens that you have saved in a data container, shared betweenyour app and extension.Once an account upgrades to use Sign in with Apple do not allow the accountto log in using a password anymore. If you override the system cancel buttonmethod, cancel the request as soon as possible. Consider offering accountsecurity upgrade options when a user signs into your service with an appclip and is later upgraded to the full app. Those are some best practicesto keep in mind when implementing your extension. Let's wrap up by reviewingthe experience you can provide for your users by adopting the account authenticationmodification extension point. The new security recommendations featurewarns users about at risk password based accounts. It educates users aboutwhy certain passwords have been flagged and motivates them to take action.Users will even get notifications about breach passwords that will takethem to the password manager to secure their accounts. If you choose toadopt the new account authentication modification extension they'll haveaccess to upgrades to secure their accounts with a tap of a button anduse Sign in with Apple or change to a new strong password. When the systemalerts your users about a security warning for an account with your servicethey'll be able to address it instantly and seamlessly.Lastly, we saw that once you've implemented an extension you can easilyadd the upgrade flows within your application using new authenticationservices framework API. This buys you system integrated account securityupgrades with the experience you want your users to have in your app.I hope you'll choose to adopt the account authentication modification extensionto provide your users with a first-class experience when they need to securetheir accounts. Thank you so much for watching.
I hope you enjoyed WWDC 2020.

Hello and welcome to WWDC. Hi there.My name is Jay Mulani and I'm going to talk to you about one tap accountsecurity upgrades. I'm so excited to talk to you today about what we'veadded in iOS this year to help improve your user's account security.We've got some great new features that raise user awareness about account securityrisks and with your buy-in make addressing those risks faster and easier than ever.

We'll get started with a brief discussion on account security and thenwalk through security recommendations new in iOS this year. I'll showyou how to adopt our new extension point to offer your users fast, easysecurity upgrades on the operating system and then how to add those flowswithin your app. We'll close with some best practices on adopting the extension.

Let's start by talking about account security. Accounts are staples ofour identities. We use them to manage our most personal private data andto access services that power our lives. Accounts manage our finances, health,emails, social media profiles and more. Accounts are so important.They're ever-growing integral role in our lives means that we have a lot of themto keep track of and that they need to be carefully protected. Most accountsare unlocked with passwords and so account management is heavily dependenton password management. Many of you are already using iOS and macOS featuresto make password management easy for your users. Password autofill providesusers with a super fast and convenient login experience. Authentication Servicestakes this a step further and removes a keyboard from the sign in processSecurity code autofill streamlines the log-in process for accounts thathave SMS two-factor authentication enabled. And Sign in with Apple completelyremoved the password component of account management. It's the fastestway for users to get a new account in sign-in. Account should be convenientto use and secure. These features I just mentioned integrated into yourapps make signing in super easy.

And this year's iOS we've added new account management features and APIsto help you keep your users' accounts secure.

My goal today is to show you how beneficial it is and how easy it is foryou to use these new features to continue our joint mission of keepingusers accounts secure. To motivate that, let's talk about the new security recommendations feature.

Every iPhone and iPad has the built-in iCloud keychain password manager.It's deeply integrated with the operating system and securely synchronizespasswords across all of the users devices.It provides easy password look up and powers password autofill, and nowit's home to security recommendations. This new section of the passwordmanager will show all of the warnings the system has found with passwordssaved in keychain. Security recommendations educates users about why certainpasswords are flagged and motivates them to take action. High priorityrecommendations will be highlighted based on the severity of the warningand the type of account. The system will flag passwords that are reusedacross sites, easily guessed, and new this year iOS will flag passwordsthat are seen in public data breaches. In fact iCloud keychain will showusers notifications when one of their passwords has been seen in a data breach.

Tapping on one of those notifications will bring them into security recommendations,to view the warning for the password.

Having a password to be publicly breached puts all accounts using thatpassword at risk. We'll show this notification for any account using apassword that has been breached, even if the breach came from another service.Each of the warnings and security recommendations will include actionsthe user can take to fix the corresponding account. One option users willhave to fix their accounts is the change password on website button.This will take the user to the web to the credentials well-known change password URL.If the service has adopted that standard. This is great for motivated usersbut navigating through a website to change your password is a hassle.Most users avoid changing passwords because doing so feels like so much work.Ideally users should be able to visit security recommendations and quicklymake progress on addressing their warnings. New in iOS this year, it willbe possible with just the tap of a button in the password manager for usersto upgrade at-risk password based accounts to an automatically generatedstrong password or even to use Sign in with Apple. These upgrades are poweredby the new account authentication modification extension. These extensionschange user perception on fixing accounts. They provide fast, easy accountsecurity upgrades. The extension point offers two upgrade options, upgradingto Sign him with Apple and upgrading to a strong password. If necessary,extensions allow the opportunity for additional user authentication beforecompleting an upgrade. For example, you may want a user to enter SMS two-factorauthentication code before they switch their account to use Sign inwith Apple. With just one extension implementation, these upgrades can beaccessed from three places: in the password manager, when looking at apassword detail view, directly off of a high priority recommendation itemand security recommendations, or third the automatic system prompts whenusers sign into your apps. The system will prompt users with security recommendationswhen they sign into your app with a weak or breached password. Once you'veimplemented an extension you can also add these upgrade flows within yourapp using new authentication services framework API. This is an awesomeway that you can offer system integrated account security upgrades withthe user experience you want your users to have in your app. We'll walkthrough how to do this towards the end.

Now that I've introduced the new account authentication modification extensionpoint, let's walk through how to implement an extension. Throughout the presentation,I'll be adding upgrades to my test app, Shiny. We're going to walk throughfour different aspects of implementing the extension. Depending on whichupgrades you choose to support. some of these steps may not apply to you. Regardless,they'll all help you better understand what's involved in this process.We'll start by discussing how to associate your app with your domain. Foryour app to be able to upgrade users accounts saved in the password manager,you'll need to securely associate your app and domain. If you haven't alreadydone this for your app to support passwordautofill, it's really easy.You'll serve a JSON file on your domain server that identifies that thedomain is affiliated with your app. For the purpose of time your app anddomain together for authentication, use the web credential service then,you'll add a matching associated domain entitlement to your app. You cando that in Xcode by adding the associated domain capability and specifyingthe domain for your app. Once you've associated your app with the web credentialservice, your app will be eligible to offer an upgrade for a password savedin the user's iCloud keychain. For more information about associatingapps and domains, check out the WWDC session.Introducing Password Autofill for Apps. And that was associating your appwith your domain. Now it's time to implement a strong password upgrade.A strong password upgrade helps users by giving them a strong unique passwordfor your service. The very first step will be to create a new target inyour project using the new account authentication modification extensiontemplate in Xcode. Next, you'll need to declare support for strong passwordupgrades in your extensions info plist. Setting the AS account authenticationmodification supports strong password change key to yes will tell thesystem to offer the strong password extension upgrade option for credentialsfor your app. The template will declare support for both upgrades by default.If you don't want to support this upgrade you can just set the key to no.

You'll implement your extension in a special subclass which will be thebrain of the operation and contains the business logic for the upgrade.including communicating with your back-end server to commit account changes.

It's exposed out of the authentication services framework and you'll noticethat it's a view controller. The reason it's a view controller is becauseyou'll have the flexibility to show security step up UI to have the userfully authorized before performing an upgrade, if necessary. We'll talkabout that later. And for right now, we'll cover upgrade flows without securitystep up UI. When users tap an extension upgrade button within the passwordmanager, or just after signing into your app, the system will launch yourextension and start an upgrade request, with a system generated strong passwordand an existing credential. The system will call change password withoutuser interaction on the view controller to begin the request. Passing ina service identifier which provides the domain or URL for the passedin credential. The service identifier is useful if your extension offersupgrades for several different services. You'll also be passed a new, uniquestrong password generated by the system and user info which we will revisitwhen we talk about in-app upgrades. This argument will always be nil forsystem initiated upgrades. Upon receiving this initial request your extensionneeds to authorize the upgrade before proceeding. Communicating with yourback-end server to do so. The result of the authorization will decide whatyour view controller should do next. Your extension should check with yourback-end server to see if it is authorized to perform the upgrade for thepassed in credential. You can also leverage any existing log and cookiesor tokens stored in a data container shared between your app and extension.

If the upgrade is authorized, you can continue with the upgrade. If not,you'll need to cancel the upgrade. When your extension is informed thatthe authorization failed, it should cancel the request. In your extensionimplementation you should do this by cancelling the request with the failederror code. If you'd like to provide a failure message to be shown to theuser you can specify one in the user info using the AS extension localizedfailure reason error key. If not the system will provide a default errormessage and encourage the user to try again later. If upgrade authorization succeeds,you can commit the change on your end and complete the request. In thissuccessful case your extension should commit the change on your back-endserver. If the change commits successfully you can complete the upgradeby calling complete change password request using an AS password credentialwith the username and updated password. Note that you can change the newpassword passed in from the system if you need to. If you end up doingso  you should be sure to pass the correct password to the completion method.That's the password that will be saved to keychain. This is an example passwordthat iCloud keychain could generate. It's a strong password designed tobe easily typable for those times at autofill can't help the user withusing the password. It's also designed with the length and character setto be compatible with most services. That said if the iCloud keychain generatedpasswords aren't compatible with your service you can specify your ownpassword rules to ensure iCloud keychain generates a compatible password.You can specify password requirements for your app with a technology calledpassword rules. At the Password Rules website, you'll find a validationtool that you can use to make your password rule string. You can then addit to your extension's info plist using the AS account authenticationmodification password generation requirements key. Once again, you shouldonly need to do this if you find the default passwords generated by thesystem are not compatible with your password rules. And that's how you supportstrong password upgrades. Next,let's look at supporting upgrades to Signin with Apple. Before adding Sign in with Apple upgrades, you'll needto support Sign in with Apple. Check out these talks for more informationon adding Sign in with Apple support to your apps. Just as we saw with strongpassword upgrades, you'll need to declare that your extension supports Sign inwith Apple upgrades and your extensions info plist. You'll do this by settingthe AS account authentication modification supports upgrade to Sign inwith Apple key to yes. By default the template will declare support forboth upgrades. If you don't want to support this upgrade, you can justset it to no. Sign in with Apple upgrades start just like strong password upgrades.The system will launch your extension and make the upgrade request withan existing credential. The system will call convert account to Sign in withApple without user interaction on the view controller to begin the request,passing in a service identifier and an existing password credential.And finally, user info which we'll ignore until we talk about in-app upgrades.User info will always be nil for system initiated upgrades. Once again,your extension will need to authorize the upgrade. Your extension shouldcheck with your back-end server to see if it is authorized to perform theupgrade for the passed in credential. You can also leverage any existinglog-in cookies or tokens stored in a data container shared between yourapp and extension. If the upgrade is authorized, you can continue with the upgrade.

If not, you'll need to cancel the upgrade. When your extension is informedthat the authorization failed, it should cancel the request. In your extensionimplementation you should do this by cancelling the request with the failureerror code. You can use the AS extension localized failure reason errorkey to communicate the reason for the failure to the user, if you'd like.

When upgrade authorization succeeds, your extension should request a Sign inwith Apple credential for the upgrade. In code your extension will requestthe credential from the system by calling get "sign in with Apple" upgradeauthorization on the extension context. This method takes state and nonsarguments that you can use to securely verify the Apple ID credential forthe upgrade. To learn more about this you should check out the Sign inwith Apple talks referenced earlier. It's possible that when you call thismethod the system won't be able to return a credential and your extensionwill need to fail the request. The system may fail to return a credentialhere for various reasons, such as the user tapping the cancel button onthe system sign in with Apple sheet or if there's a bad network connection.

In this case your extension will cancel the request with the failure error code.

If the system returns a Sign in with Apple credentials successfully, you shoulddo the necessary bookkeeping to process the upgrade on your end, and thensuccessfully complete the request. In code once your extension has successfullycommitted the upgrade on your back-end server it can complete the requestby simply calling complete upgrade to Sign In with Apple on the extension context.

One of the promises of Sign in with Apple is having one fewer passwordto manage and keep track of. Once the upgrade is completed, the system willdelete the keychain password credential used for the upgrade.

These flows cover the ideal scenarios for upgrades with minimal user interaction.However, in some cases your extension may require some additional user authenticationto complete an upgrade. Your extension will have the capability to showsecurity step up UI and upgrade flows. As an example, you may want the userto enter a two-factor authentication code to complete an upgrade.Let's pick back up on the flow when your extension is verifying the credentialpassed in for the upgrade. When your extension is checking with your back-endserver to authorize the upgrade, we saw that if the upgrade is authorizedyou can continue with the upgrade, or if not, you'll need to cancel the upgrade.

But now, we'll consider a third possibility in which further authorizationis required to complete the upgrade. When further authorization is requiredyour extension can cancel the initial request and specify that it needsto show security step up UI. Your extension can do this by canceling theinitial request with the user interaction required error code. In response,the system will create a new request configured to allow user interaction.

The system will call prepare interface to change password on your viewcontroller subclass for strong password upgrades. For Sign in with Apple upgrades,the system will call prepare interface to convert account to Sign in withApple. In each of these methods your extension should quickly do any worknecessary to prepare the interface to be presented. Once this method finishesthe system will present your interface. Your interface will be presentedwith a system provided navigation bar with the name of the containing appfor the extension is the title and a cancel button. Once your interfaceis presented there are three possible scenarios. If the additional userauthentication fails or something else goes wrong, you can fail the requestby cancelling with the failure error code. The second scenario is thatall goes well and you can continue with the upgrade. For a strong password upgrade,the next step will be to commit the password change. For a Sign in withApple upgrade, your extensions next step will be to request the Signwith Apple credential. The system will take this as a sign that the workin your security step up UI is complete and will dismiss it to show thesystem sign in with apple sheet. From here, the upgrade will continue thesame exact way we saw earlier. The third possibility, regardless of theupgrade type, is that the user taps the system provided cancel button.In this case, your extension will need to cancel the request. The system willcall cancel request on your view controller subclass. The superclass implementationof this method simply cancels the request with the user cancellederror code. If you want the ability to clean up state before the request is cancelled,you should override this method and be sure to still cancel the requestat the end.

We've completed the core implementation for the extension and the hardwork is done. Now, if you want to use the upgrades from within your app,all you have to do is invoke the extension.

Let's talk about in-app upgrades. In-app upgrades begin when your app createsand performs an upgrade request. Performing the request will launch your extension.

The requests will have a username and will not have a password. There isno password in this flow because your app should not be able to provideplain text passwords and because, unlike the system, you won't have a handleto a keychain credential to perform the upgrade with. However, you may passany information you'd like to your extension for the upgrade with the userinfo property of the request object. We ignored this earlier because it'salways nil for system initiated upgrades. Your extension can use this informationto authorize the upgrade. The upgrade authorization process works as outlinedbefore, where your extension will need to talk to your back-end server toensure the account is authorized to perform the upgrade - with the same threepossible outcomes of successful authorization, failed authorization, or findingthat further authorization is required. Ideally you shouldn't need anyfurther authorization in this flow as the user has already logged intothe app. Let's add in-app upgrades to the account settings section of theShiny app. Let's start with in-app strong password upgrades. The upgradewill be added here and the handler for the change to strong password buttonand the account setting section. The first step is to specify the serviceidentifier for the credential to be upgraded by creating an ACE credentialservice identifier for the Shiny app. The next step is to get the usernamefor the upgrade. Remember that for in-app upgrades, your extensionwill not receive a password. You can authorize the upgrade by passing authorizationinformation in on the requests user info. In this example, I'm passing inthe off token for the current user logged into the Shiny app for the shinyextension to use to authorize the upgrade. These three pieces of informationare used to create a strong password upgrade request. Next, we need to createan AS account authentication modification controller to perform the request.

In order to be informed of the results of the upgrade, the view controllerneeds to be set as the upgrade controllers delegate. Lastly, a presentationcontext provider must always be provided to tell the system the windowto show UI in. Once this is all done, the requests can be performed.Now, let's quickly see how to add in-app Sign in with Apple upgrades.They're very, very similar to the strong password upgrades we just saw. The onlydifference for the in-app Sign in with Apple upgrades will be to createand use a sign in with Apple request object. For in-app upgrades you arein control for communicating upgrade results to the user with your user interface.

The AS account authentication modification controller delegate protocolhas two methods to handle upgrade results. There's a method that will becalled for successful upgrades where you should inform the user that theupgrade succeeded. After a successful upgrade, the system will look fora keychain credential for your service with a user username used in the upgrade.

If a keychain credential is found it will either be updated or removed,depending on the type of upgrade. There's also a method to indicate anupgrade has failed. Where you should inform the user that it failed and providethe reason why, if possible. Here's a successful sign in with Apple upgradein the Shiny app. People love Sign in with Apple. Providing this upgrade flowin your app allows your users to convert existing accounts to Sign in withApple without having to create a new account. We just looked at addingupgrades in an account settings view. Another great opportunity to offerupgrades is when a user transitions into using your app after using yourapp clip. Let's quickly review some best practices for adopting the accountauthentication modification extension point. Keep upgrades as quick andas effortless as possible. Only request to show your extensions UI whenabsolutely necessary. Your extension can authorize upgrades by communicatingwith your back-end server but you can also leverage any existing logincookies or tokens that you have saved in a data container, shared betweenyour app and extension.Once an account upgrades to use Sign in with Apple do not allow the accountto log in using a password anymore. If you override the system cancel buttonmethod, cancel the request as soon as possible. Consider offering accountsecurity upgrade options when a user signs into your service with an appclip and is later upgraded to the full app. Those are some best practicesto keep in mind when implementing your extension. Let's wrap up by reviewingthe experience you can provide for your users by adopting the account authenticationmodification extension point. The new security recommendations featurewarns users about at risk password based accounts. It educates users aboutwhy certain passwords have been flagged and motivates them to take action.

Users will even get notifications about breach passwords that will takethem to the password manager to secure their accounts. If you choose toadopt the new account authentication modification extension they'll haveaccess to upgrades to secure their accounts with a tap of a button anduse Sign in with Apple or change to a new strong password. When the systemalerts your users about a security warning for an account with your servicethey'll be able to address it instantly and seamlessly.

Lastly, we saw that once you've implemented an extension you can easilyadd the upgrade flows within your application using new authenticationservices framework API. This buys you system integrated account securityupgrades with the experience you want your users to have in your app.I hope you'll choose to adopt the account authentication modification extensionto provide your users with a first-class experience when they need to securetheir accounts. Thank you so much for watching.
I hope you enjoyed WWDC 2020.

## Code Samples


# Wwdc2020 10650

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Sync a Core Data store with the CloudKit public databaseDiscover how Core Data can help you adopt the CloudKit public database in your app with as little as one line of code. Learn how to easily manage the flow of data through your app and in and out of CloudKit. We'll show you how to combine the complementary power of Core Data and the CloudKit public database to allow people to access — and contribute to — data, such as high scores or application templates. 

To familiarize yourself with the CloudKit Database, check out our “CKDatabase” documentation, and to learn more about CloudKit integration, read “Mirroring a Core Data Store with CloudKit.”ResourcesCKDatabaseMirroring a Core Data store with CloudKitSynchronizing a local store to the cloudHD VideoSD VideoRelated VideosWWDC19Using Core Data With CloudKit

Discover how Core Data can help you adopt the CloudKit public database in your app with as little as one line of code. Learn how to easily manage the flow of data through your app and in and out of CloudKit. We'll show you how to combine the complementary power of Core Data and the CloudKit public database to allow people to access — and contribute to — data, such as high scores or application templates. 

To familiarize yourself with the CloudKit Database, check out our “CKDatabase” documentation, and to learn more about CloudKit integration, read “Mirroring a Core Data Store with CloudKit.”

CKDatabase

Mirroring a Core Data store with CloudKit

Synchronizing a local store to the cloud

HD VideoSD Video

HD Video

SD Video

Using Core Data With CloudKit

Search this video…Hello and welcome to WWDC.Hi my name's Nick Gillett. I'm an engineer here at Apple on the CoreData team, and today we're gonna talk about what it's like to build applicationswith NSPersistentCloudKitContainer that sync Core Data stores withthe public CloudKit database.  To do this, we'll be introducing some new API,and we'll talk a lot about things that you need to think about when buildingapplications for the public database. Finally, we'll take a detailed lookat how importing works with NSPersistentCloudKitContainer in the public database.Now before we get started, I'd like to do a quick review of where we areso far. In 2019, in our session "Using Core Data With CloudKit", we introducedNSPersistentCloudKitContainer as a way of easily syncing your Core Datastores with the private CloudKit database. As well, we introduced a newsample application that demonstrates how this works, and we wrote a tonof documentation about how NSPersistentCloudKitContainer works andhow you can integrate it with your applications. So, if at any point duringthis session you feel like you're lacking some context or some of the conceptswe're discussing feel foreign, I highly recommend that you review our documentationand our previous session. I also want to review some terms. You see, Core Dataand CloudKit are very similar frameworks, and they express themselvesthrough a similar set of ideas and APIs. We think of each frameworkin terms of objects, models and stores. In Core Data, we know these as instancesof NSManagedObject, and these are the objects that you work with directlyin your application. Likewise in CloudKit, we know them as CKRecord.We model these objects or describe them using an instance of NSManagedObjectModel,and in CloudKit, this is called the schema. Finally, objectsare persistent, to use the Core Data vernacular, and in an instance ofNSPersistentStore, or in CloudKit, in a CKRecordZone which is part of aCKRecord database. Now that we've got that out of the way I want to showyou what it's like to actually build an application, or in this case, customizeone that works with the public CloudKit database. To do that, I'm just gonnaopen our sample application, and I'm looking for a specific file calledthe Core Data Stack. You see the Core Data stack is where this applicationkeeps all of the code it needs to set up its instance ofNSPersistentCloudKitContainer. You can see here at the top that it's already usingNSPersistentCloudKitContainer, which means it's ready to sync with theprivate database. Now to make it work with the public database we justwant to add one new line of code. I'm simply going to change the existingstore description to set its cloudKitContainerOptions and use the new databaseScopeproperty to set it to public.You can see I've just pasted in a lot of code, so let's take a detailedlook at what's actually going on here. In this code we create a new instanceof NSPersistentStoreDescription and customize it with the normalcloudKitContainerOptions - things like history tracking and remote change notifications.Then we create a new instance of NSPersistentCloudKitContainerOptions.This is what tells NSPersistentCloudkitContainer that we want to usethis store description with CloudKit. We set its databaseScope propertyto public, and that tells it that we want to use it with the public database.Next, we assign the cloudKitContainerOptions to the store description andappend the store description to the array of stores that we wantNSPersistentCloudKitContainer to load. Finally, we load our stores as younormally would. Now I would like to say that that's all you have to do at allbut we have to configure our CloudKit container to work correctly withNSPersistentCloudKitContainer. You see it fetches data differently in thepublic database. And so I want to use the CloudKit Dashboard now to changethe configuration of our schema. To do that, I'm just gonna open Safari,and you can see that I already have the page I need open in Safari.So let's orient ourselves to where we are. At the top, you can see that I'veselected the iCloud container for our sample application, and we're in thedevelopment environment looking specifically at the schema. We're lookingat the indexes section of the schema because we need to add some indexesto all five of the record types that you see listed on the screen hereon the left-hand side. We need to add two new indexes to each record type,and to do that, I'm just going to use this Add Index button down here.I'll click it once and add one for the recordName and then another one forthe modifiedAt date, and finally I'll save my changes. And these are theindexes that NSPersistentCloudKitContainer needs to run its queries againstthe public database to fetch records of this type. Now of course for yourapplication you would have to repeat these steps for all of your record typesso we would do this four more times for our sample application. So that'sall we have to do to build an application that works with the public CloudKit database.We simply adopt NSPersistentCloudKitContainerOptions' new databaseScopeproperty and add a couple of indexes to all of our record types.Now if you don't see all of your indexes in the CloudKit dashboard, you may needto go through a process that we call schema initialization.And schema initialization is detailed in our documentation and in the sessionfrom 2019. Once you finish that, you will have a complete local mirror ofall of the data in CloudKit on the device your application is running on.Now you might be wondering why we create a complete local mirror. And thereason is - you asked us to. You see, since our talk in 2019, we've receiveda slew of feature requests for support with the public database, and theyhad some common themes. The first being that all of the requests wantedto create a data set that everyone could use - that is, all users of yourapplication could access. Now sometimes this was data that you, the developer,would create, such as an application template or an initial data setso the user has a rich experience with your application from day one.In other cases, it was data created by users. Now I'm going to be candid here.The most common request that we got for this was for a high scores tablein a video game, and this is actually a great example of what we wantNSPersistentCloudKitContainer to support. You need all the data locally sothat you can quickly fetch it, sort it, order it, and it's something that yourusers will want to contribute to. We also know that you want to mix datafrom the private database as needed in these applications. And this makesa lot of sense. Your user may want to upload their high score but theymay not want to upload their saved game state or their character configurationto the public database. And instead, to sync that, you would use the private database.And that's actually a great segue to our next section which is specialconsiderations or things that you need to think about as you're buildingapplications that work with the public database. To dig into this a littlebit, we're going to compare and contrast the behavior of NSPersistentCloudKitContainerwhen working with a private database and the public database.The first thing that we'll look at is the notion of accounts and ownershipand how that changes between the two. You see, in the private database, accountsare required and all of the data is owned by a single user so the behavioris fairly straightforward but the public database doesn't work that way.Accounts are optional. You can read data from the public database withoutan iCloud account, and that data could be owned by any user of your application.We'll also talk about import and how that changes between the public andprivate database. You see the private database supports push notifications,and the public database does not, so we have to query for records thatwe want to import using a process called polling. Now I wanted to callout export here because we won't be talking about it. It works identicallybetween the private and public databases. And we talked about it in detailin our session in 2019. When we think about accounts and ownership, what we'rereally talking about is the set of actions that your application can takewhen you're signed in or signed out of an iCloud account. Now as I said, inthe private database this is super straightforward. If you're signed out,you can't do anything. If you're signed in, you can do everything. The worldis your oyster, and all the data is yours to work with. In the public databasethough, this gets a lot more complicated. You can read data if you're signedout or signed in but you can only create data - new records - if you're signedinto an iCloud account. What about modifications? Well it's tricky.And this poses a problem for applications that have UI's like our sample application.And maybe you have some editing controls such as this Edit button in thetop left or this '+' button in the top right that allows us to createnew records. Likewise our sample application has a Detail view controllerthat allows us to edit individual objects and that also has an editingcontrol in it. Our application may need to know whether or not it can useone or any of these controls based on where that object is stored or thedatabase that that object lives in. And it turns out that you can useNSPersistentCloudKitContainer's existing APIs to figure this out. You simplyask CloudKit for the current account. Then you ask NSPersistentCloudKitContainerfor the record that backs an object you're working with. And if you comparethe creator UserID then you'll know whether or not that object is mutable.But this is a ridiculous amount of code just to turn this question markinto a yes or no, and it's an insane amount of code to execute for everyuser interface element in your application. So we can do better. And wehave. This is NSPersistentCloudKitContainer's new canUpdateRecordforManagedObjectWithID method, which tells us exactly what we needto know about whether or not this object is mutable with respect to thecurrent configuration of the device, the persistent store the object iskept in and whether or not that store is backed by CloudKit. It even handlesall the edge cases you might expect, like that object being stored in astore that's not backed by CloudKit at all or the account changing on thedevice while you're using your application. And we cache this state sothat it's efficient enough to use in your user interface. Now, if you havea more core screen view of the world such as this table view in our application,you can use NSPersistentCloudKitContainer's canModifyObjects in storeto tell whether or not any of the objects in a given persistent store wouldbe mutable with respect to the configuration on the device and whetheror not that store is backed by CloudKit. Now I'd like to switch gearsa bit and talk in detail about how import works in the public databasewithin NSPersistentCloudKitContainer. To do that, I want to review somecontent from our session in 2019. You may remember this graphic, where wetalked about how when we get a push notification from CloudKit, we schedulean import operation that brings all the changed records down to the local storeand makes them available to your application.And this works really well even if you have a large set of changed recordsor a very complicated object graph. NSPersistentCloudKitContainercan efficiently import complicated graphs and large change setswhether you're using the public database or the private database. To understandhow they're different, we want to take a look at exactly what happens betweenthe cloud and the local persistent store. When I say that we create animport operation, what I really mean is that we create an instance ofCKFetchRecordsZoneChangesOperation, and this creates a single request againstthe CloudKit server, which brings down all of the changed records from theprivate database. But CKFetchRecordsZoneChangesOperation relies on sometechnologies that are specific to the private database, and so in the publicdatabase, we have to use CKQueryOperation instead. Now if you've ever usedCKQueryOperation, you know that queries affect a specific record type, whichmeans that we have to make one request for the posts and another requestfor their tags.. and another request for the attachments... and another requestfor the images... and another request for the many to many relationships.. andso on. It continues until we fetch all of the record types in our application.And this means that public database - that stores backed by the public databaseare doing a lot more work. And that's how we import data into the public database.NSPersistentCloudKitContainer has to use CKQueryOperation instead ofCKFetchRecordsZoneChangesOperation, and we have to poll for changes insteadof using push notifications to know exactly when to make our requests.Now this means that we need to be careful about how we load up the CloudKitserver because of the way we want your applications to scale with the public database.So we're only going to poll for changes on application launch or afterabout every 30 minutes of application use. And this is to ensure that wealign the load of these requests with the actual usage of your applications.Of course, this does mean that the quality of freshness that you can expectfrom the public database will be noticeably different from the private database.Now I also want to mention that this means that simpler managed object models,that is managed object models that have fewer entities in them, will makefewer requests to the public database. Now that's not to say that you shouldn'thave complicated object graphs in your application or that the public databasedoesn't support them. In fact you absolutely should. You should build themanaged object models you need for the public database but it does meanthat you should restrict that model to only the entities that are usedin the public database so the NSPersistentCloudKitContainer isn'tmaking unnecessary requests. Now we do this using a configuration in themanage object model and we talk about those in detail in our documentationabout how you set up a managed object model for use within NSPersistentCloudKitContainer.You want to restrict the entities that are usingthe public database to a specific configuration for that store. Now whydoes any of this matter? Well, because the queries affect how deletes propagatethroughout the public database. Consider the following set of objects.If we import those objects onto two devices, both devices will come to anidentical picture of what's in the cloud, as we would expect. Right?In the private database, if we delete an object from one device and then exportthat delete to the cloud, that will leave behind a shell, called a tombstone,which contains the record type and the record ID of the object that was deleted.Now this allows us to fetch that tombstone via CKFetchRecordZoneChangesOperationwhen we import changes from the private database and delete that recordon the other device so both devices again come to the same picture ofwhat's in the cloud. However, as I said, NSPersistentCloudKitContainercan't use CKFetchRecordsZoneChangesOperation with the public database.It has to use CKQueryOperation.So when we delete our record from one device and export that delete tothe public database, the record is deleted immediately. With the query operation,we asked the public database what's changed. And it says nothing.There is no tombstone left behind for us to fetch. This means that we can'tpropagate the delete to the other device, and they will have different picturesof what's in the cloud. And this poses a potential problem for applications,especially if they have user interfaces like this one where we haveswipe-to-delete for example in our table view. In swiping to delete this object,that delete won't propagate in the public database to all the devices thathave downloaded this object.  And it turns out that you can totally detectthat this will occur using an API on CKRecordZone called Capabilities.If a zone doesn't support the fetchChanges capability, we can't useCKFetchRecordsZoneChangesOperation to important data from it. We have touse queries instead. But that takes so much code to integrate into yourapplication that I didn't even bother to put it on slides. Instead, we candetect this in one line of code using NSPersistentCloudKitContainer'snew canDeleteRecord(forManagedObjectWithID) method. If it returns false,that means that this record is stored in the public database andNSPersistentCloudKitContainer can't import the delete in the same way thatit would from the private database. So the delete won't propagate to allthe devices that have downloaded this object. Now that doesn't mean thatdeletes don't work at all. It's that you need to decide whether or notyour application is trying to delete an object or if it's trying to removeone from the UI because NSPersistentCloudKitContainer has to use a CKQueryOperationto fetch it. Now that doesn't mean that you can't delete.In fact, you definitely should delete data when you need to but there's adifference between deleting data for the sake of removing it from the publicdatabase and removing it from the user interface in your application.In this code we use canDeleteRecord(forManagedObjectWithID) to tellwhether or not we should be updating a record to remove it from our userinterface instead of deleting it. To do that we set the isTrashed propertyon this tag to 'true' when we can't delete something from the public database,and in our application we use a fetch request with a predicate that filtersout all the trashed records to remove them from the user interface.In this way we're using an update or a modification in place of a delete toachieve the desired effect in our user interface. Now we can carry thisparadigm even further. Say, for example, by milling out all the fields onthe record that we no longer need once it's trashed. This preserves... thisreclaims space in the public database as well as on disk on your users'devices, and you could go even further by eventually purging these trashedrecords from the public database once you're confident that all of theusers who downloaded these records have processed this update. And so whatyou really need to decide in your application is - do you want to delete somethingfrom the public database so that no one ever downloads it again? Or doyou want to pull something out of the UI? In this session,we learned a lot about NSPersistentCloudKitContainer, including its newdatabaseScope API that allows you to configure whether you want to usea store with a public or private database. And we took a detailed lookat what the public database means to your application. Finally, we learnedabout some other NSPersistentCloudKitContainer APIs and how theycan help make some of these considerations easier for you to deal with.So that's all about NSPersistentCloudKitContainer and the public database.It's been my pleasure to bring you this session, and from all of us hereat Apple, have an amazing  WWDC.

Hello and welcome to WWDC.

Hi my name's Nick Gillett. I'm an engineer here at Apple on the CoreData team, and today we're gonna talk about what it's like to build applicationswith NSPersistentCloudKitContainer that sync Core Data stores withthe public CloudKit database.  To do this, we'll be introducing some new API,and we'll talk a lot about things that you need to think about when buildingapplications for the public database. Finally, we'll take a detailed lookat how importing works with NSPersistentCloudKitContainer in the public database.Now before we get started, I'd like to do a quick review of where we areso far. In 2019, in our session "Using Core Data With CloudKit", we introducedNSPersistentCloudKitContainer as a way of easily syncing your Core Datastores with the private CloudKit database. As well, we introduced a newsample application that demonstrates how this works, and we wrote a tonof documentation about how NSPersistentCloudKitContainer works andhow you can integrate it with your applications. So, if at any point duringthis session you feel like you're lacking some context or some of the conceptswe're discussing feel foreign, I highly recommend that you review our documentationand our previous session. I also want to review some terms. You see, Core Dataand CloudKit are very similar frameworks, and they express themselvesthrough a similar set of ideas and APIs. We think of each frameworkin terms of objects, models and stores. In Core Data, we know these as instancesof NSManagedObject, and these are the objects that you work with directlyin your application. Likewise in CloudKit, we know them as CKRecord.

We model these objects or describe them using an instance of NSManagedObjectModel,and in CloudKit, this is called the schema. Finally, objectsare persistent, to use the Core Data vernacular, and in an instance ofNSPersistentStore, or in CloudKit, in a CKRecordZone which is part of aCKRecord database. Now that we've got that out of the way I want to showyou what it's like to actually build an application, or in this case, customizeone that works with the public CloudKit database. To do that, I'm just gonnaopen our sample application, and I'm looking for a specific file calledthe Core Data Stack. You see the Core Data stack is where this applicationkeeps all of the code it needs to set up its instance ofNSPersistentCloudKitContainer. You can see here at the top that it's already usingNSPersistentCloudKitContainer, which means it's ready to sync with theprivate database. Now to make it work with the public database we justwant to add one new line of code. I'm simply going to change the existingstore description to set its cloudKitContainerOptions and use the new databaseScopeproperty to set it to public.

You can see I've just pasted in a lot of code, so let's take a detailedlook at what's actually going on here. In this code we create a new instanceof NSPersistentStoreDescription and customize it with the normalcloudKitContainerOptions - things like history tracking and remote change notifications.

Then we create a new instance of NSPersistentCloudKitContainerOptions.This is what tells NSPersistentCloudkitContainer that we want to usethis store description with CloudKit. We set its databaseScope propertyto public, and that tells it that we want to use it with the public database.

Next, we assign the cloudKitContainerOptions to the store description andappend the store description to the array of stores that we wantNSPersistentCloudKitContainer to load. Finally, we load our stores as younormally would. Now I would like to say that that's all you have to do at allbut we have to configure our CloudKit container to work correctly withNSPersistentCloudKitContainer. You see it fetches data differently in thepublic database. And so I want to use the CloudKit Dashboard now to changethe configuration of our schema. To do that, I'm just gonna open Safari,and you can see that I already have the page I need open in Safari.So let's orient ourselves to where we are. At the top, you can see that I'veselected the iCloud container for our sample application, and we're in thedevelopment environment looking specifically at the schema. We're lookingat the indexes section of the schema because we need to add some indexesto all five of the record types that you see listed on the screen hereon the left-hand side. We need to add two new indexes to each record type,and to do that, I'm just going to use this Add Index button down here.I'll click it once and add one for the recordName and then another one forthe modifiedAt date, and finally I'll save my changes. And these are theindexes that NSPersistentCloudKitContainer needs to run its queries againstthe public database to fetch records of this type. Now of course for yourapplication you would have to repeat these steps for all of your record typesso we would do this four more times for our sample application. So that'sall we have to do to build an application that works with the public CloudKit database.We simply adopt NSPersistentCloudKitContainerOptions' new databaseScopeproperty and add a couple of indexes to all of our record types.Now if you don't see all of your indexes in the CloudKit dashboard, you may needto go through a process that we call schema initialization.And schema initialization is detailed in our documentation and in the sessionfrom 2019. Once you finish that, you will have a complete local mirror ofall of the data in CloudKit on the device your application is running on.Now you might be wondering why we create a complete local mirror. And thereason is - you asked us to. You see, since our talk in 2019, we've receiveda slew of feature requests for support with the public database, and theyhad some common themes. The first being that all of the requests wantedto create a data set that everyone could use - that is, all users of yourapplication could access. Now sometimes this was data that you, the developer,would create, such as an application template or an initial data setso the user has a rich experience with your application from day one.In other cases, it was data created by users. Now I'm going to be candid here.The most common request that we got for this was for a high scores tablein a video game, and this is actually a great example of what we wantNSPersistentCloudKitContainer to support. You need all the data locally sothat you can quickly fetch it, sort it, order it, and it's something that yourusers will want to contribute to. We also know that you want to mix datafrom the private database as needed in these applications. And this makesa lot of sense. Your user may want to upload their high score but theymay not want to upload their saved game state or their character configurationto the public database. And instead, to sync that, you would use the private database.

And that's actually a great segue to our next section which is specialconsiderations or things that you need to think about as you're buildingapplications that work with the public database. To dig into this a littlebit, we're going to compare and contrast the behavior of NSPersistentCloudKitContainerwhen working with a private database and the public database.

The first thing that we'll look at is the notion of accounts and ownershipand how that changes between the two. You see, in the private database, accountsare required and all of the data is owned by a single user so the behavioris fairly straightforward but the public database doesn't work that way.Accounts are optional. You can read data from the public database withoutan iCloud account, and that data could be owned by any user of your application.

We'll also talk about import and how that changes between the public andprivate database. You see the private database supports push notifications,and the public database does not, so we have to query for records thatwe want to import using a process called polling. Now I wanted to callout export here because we won't be talking about it. It works identicallybetween the private and public databases. And we talked about it in detailin our session in 2019. When we think about accounts and ownership, what we'rereally talking about is the set of actions that your application can takewhen you're signed in or signed out of an iCloud account. Now as I said, inthe private database this is super straightforward. If you're signed out,you can't do anything. If you're signed in, you can do everything. The worldis your oyster, and all the data is yours to work with. In the public databasethough, this gets a lot more complicated. You can read data if you're signedout or signed in but you can only create data - new records - if you're signedinto an iCloud account. What about modifications? Well it's tricky.And this poses a problem for applications that have UI's like our sample application.And maybe you have some editing controls such as this Edit button in thetop left or this '+' button in the top right that allows us to createnew records. Likewise our sample application has a Detail view controllerthat allows us to edit individual objects and that also has an editingcontrol in it. Our application may need to know whether or not it can useone or any of these controls based on where that object is stored or thedatabase that that object lives in. And it turns out that you can useNSPersistentCloudKitContainer's existing APIs to figure this out. You simplyask CloudKit for the current account. Then you ask NSPersistentCloudKitContainerfor the record that backs an object you're working with. And if you comparethe creator UserID then you'll know whether or not that object is mutable.

But this is a ridiculous amount of code just to turn this question markinto a yes or no, and it's an insane amount of code to execute for everyuser interface element in your application. So we can do better. And wehave. This is NSPersistentCloudKitContainer's new canUpdateRecordforManagedObjectWithID method, which tells us exactly what we needto know about whether or not this object is mutable with respect to thecurrent configuration of the device, the persistent store the object iskept in and whether or not that store is backed by CloudKit. It even handlesall the edge cases you might expect, like that object being stored in astore that's not backed by CloudKit at all or the account changing on thedevice while you're using your application. And we cache this state sothat it's efficient enough to use in your user interface. Now, if you havea more core screen view of the world such as this table view in our application,you can use NSPersistentCloudKitContainer's canModifyObjects in storeto tell whether or not any of the objects in a given persistent store wouldbe mutable with respect to the configuration on the device and whetheror not that store is backed by CloudKit. Now I'd like to switch gearsa bit and talk in detail about how import works in the public databasewithin NSPersistentCloudKitContainer. To do that, I want to review somecontent from our session in 2019. You may remember this graphic, where wetalked about how when we get a push notification from CloudKit, we schedulean import operation that brings all the changed records down to the local storeand makes them available to your application.

And this works really well even if you have a large set of changed recordsor a very complicated object graph. NSPersistentCloudKitContainercan efficiently import complicated graphs and large change setswhether you're using the public database or the private database. To understandhow they're different, we want to take a look at exactly what happens betweenthe cloud and the local persistent store. When I say that we create animport operation, what I really mean is that we create an instance ofCKFetchRecordsZoneChangesOperation, and this creates a single request againstthe CloudKit server, which brings down all of the changed records from theprivate database. But CKFetchRecordsZoneChangesOperation relies on sometechnologies that are specific to the private database, and so in the publicdatabase, we have to use CKQueryOperation instead. Now if you've ever usedCKQueryOperation, you know that queries affect a specific record type, whichmeans that we have to make one request for the posts and another requestfor their tags.. and another request for the attachments... and another requestfor the images... and another request for the many to many relationships.. andso on. It continues until we fetch all of the record types in our application.

And this means that public database - that stores backed by the public databaseare doing a lot more work. And that's how we import data into the public database.NSPersistentCloudKitContainer has to use CKQueryOperation instead ofCKFetchRecordsZoneChangesOperation, and we have to poll for changes insteadof using push notifications to know exactly when to make our requests.Now this means that we need to be careful about how we load up the CloudKitserver because of the way we want your applications to scale with the public database.

So we're only going to poll for changes on application launch or afterabout every 30 minutes of application use. And this is to ensure that wealign the load of these requests with the actual usage of your applications.

Of course, this does mean that the quality of freshness that you can expectfrom the public database will be noticeably different from the private database.

Now I also want to mention that this means that simpler managed object models,that is managed object models that have fewer entities in them, will makefewer requests to the public database. Now that's not to say that you shouldn'thave complicated object graphs in your application or that the public databasedoesn't support them. In fact you absolutely should. You should build themanaged object models you need for the public database but it does meanthat you should restrict that model to only the entities that are usedin the public database so the NSPersistentCloudKitContainer isn'tmaking unnecessary requests. Now we do this using a configuration in themanage object model and we talk about those in detail in our documentationabout how you set up a managed object model for use within NSPersistentCloudKitContainer.You want to restrict the entities that are usingthe public database to a specific configuration for that store. Now whydoes any of this matter? Well, because the queries affect how deletes propagatethroughout the public database. Consider the following set of objects.If we import those objects onto two devices, both devices will come to anidentical picture of what's in the cloud, as we would expect. Right?In the private database, if we delete an object from one device and then exportthat delete to the cloud, that will leave behind a shell, called a tombstone,which contains the record type and the record ID of the object that was deleted.

Now this allows us to fetch that tombstone via CKFetchRecordZoneChangesOperationwhen we import changes from the private database and delete that recordon the other device so both devices again come to the same picture ofwhat's in the cloud. However, as I said, NSPersistentCloudKitContainercan't use CKFetchRecordsZoneChangesOperation with the public database.It has to use CKQueryOperation.So when we delete our record from one device and export that delete tothe public database, the record is deleted immediately. With the query operation,we asked the public database what's changed. And it says nothing.There is no tombstone left behind for us to fetch. This means that we can'tpropagate the delete to the other device, and they will have different picturesof what's in the cloud. And this poses a potential problem for applications,especially if they have user interfaces like this one where we haveswipe-to-delete for example in our table view. In swiping to delete this object,that delete won't propagate in the public database to all the devices thathave downloaded this object.  And it turns out that you can totally detectthat this will occur using an API on CKRecordZone called Capabilities.

If a zone doesn't support the fetchChanges capability, we can't useCKFetchRecordsZoneChangesOperation to important data from it. We have touse queries instead. But that takes so much code to integrate into yourapplication that I didn't even bother to put it on slides. Instead, we candetect this in one line of code using NSPersistentCloudKitContainer'snew canDeleteRecord(forManagedObjectWithID) method. If it returns false,that means that this record is stored in the public database andNSPersistentCloudKitContainer can't import the delete in the same way thatit would from the private database. So the delete won't propagate to allthe devices that have downloaded this object. Now that doesn't mean thatdeletes don't work at all. It's that you need to decide whether or notyour application is trying to delete an object or if it's trying to removeone from the UI because NSPersistentCloudKitContainer has to use a CKQueryOperationto fetch it. Now that doesn't mean that you can't delete.In fact, you definitely should delete data when you need to but there's adifference between deleting data for the sake of removing it from the publicdatabase and removing it from the user interface in your application.In this code we use canDeleteRecord(forManagedObjectWithID) to tellwhether or not we should be updating a record to remove it from our userinterface instead of deleting it. To do that we set the isTrashed propertyon this tag to 'true' when we can't delete something from the public database,and in our application we use a fetch request with a predicate that filtersout all the trashed records to remove them from the user interface.In this way we're using an update or a modification in place of a delete toachieve the desired effect in our user interface. Now we can carry thisparadigm even further. Say, for example, by milling out all the fields onthe record that we no longer need once it's trashed. This preserves... thisreclaims space in the public database as well as on disk on your users'devices, and you could go even further by eventually purging these trashedrecords from the public database once you're confident that all of theusers who downloaded these records have processed this update. And so whatyou really need to decide in your application is - do you want to delete somethingfrom the public database so that no one ever downloads it again? Or doyou want to pull something out of the UI? In this session,we learned a lot about NSPersistentCloudKitContainer, including its newdatabaseScope API that allows you to configure whether you want to usea store with a public or private database. And we took a detailed lookat what the public database means to your application. Finally, we learnedabout some other NSPersistentCloudKitContainer APIs and how theycan help make some of these considerations easier for you to deal with.

So that's all about NSPersistentCloudKitContainer and the public database.

It's been my pleasure to bring you this session, and from all of us hereat Apple, have an amazing  WWDC.

## Code Samples


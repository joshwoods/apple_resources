# Wwdc2020 10648

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Unsafe SwiftWhat exactly makes code “unsafe”? Join the Swift team as we take a look at the programming language's safety precautions — and when you might need to reach for unsafe operations. We'll take a look at APIs that can cause unexpected states if not used correctly, and how you can write code more specifically to avoid undefined behavior. Learn how to work with C APIs that use pointers and the steps to take when you want to use Swift's unsafe pointer APIs.

To get the most out of this session, you should have some familiarity with Swift and the C programming language. And for more information on working with pointers, check out "Safely Manage Pointers in Swift".ResourcesManual Memory ManagementHD VideoSD VideoRelated VideosWWDC20Advancements in the Objective-C runtimeSafely manage pointers in SwiftWWDC16Understanding Swift Performance

What exactly makes code “unsafe”? Join the Swift team as we take a look at the programming language's safety precautions — and when you might need to reach for unsafe operations. We'll take a look at APIs that can cause unexpected states if not used correctly, and how you can write code more specifically to avoid undefined behavior. Learn how to work with C APIs that use pointers and the steps to take when you want to use Swift's unsafe pointer APIs.

To get the most out of this session, you should have some familiarity with Swift and the C programming language. And for more information on working with pointers, check out "Safely Manage Pointers in Swift".

Manual Memory Management

HD VideoSD Video

HD Video

SD Video

Advancements in the Objective-C runtime

Safely manage pointers in Swift

Understanding Swift Performance

Search this video…Hello, and welcome to WWDC.Hello, my name is Karoy Lorentey,and I'm an engineer on the Swift standard library teamhere at Apple.Today I'm going to talk about unsafe APIs in Swift.The standard library provides many different constructs:types, protocols, functions, properties, and so on.A small amount of these are explicitly labeled as "unsafe".What does this mean?What makes these special?The distinction between safe and unsafe constructs isnot apparent in the interface they provide.Rather, it arises from the way their implementationsdeal with invalid input.Most operations in the standard libraryfully validate their input before executing,so we can safely assume that any serious coding errors we may makewill be reliably caught and reported.One example for such an operation is the familiarforce-unwrapping operator on Swift's Optional type.It does require that the value must not be nil,but if we get this wrong, we are guaranteed to geta nice, clean fatal runtime error.Here, we asked Optional to do something that is nonsensical,so stopping execution isthe only responsible thing it can do.Of course, trying to force-unwrap a nil valueis still a serious programming error,but its consequences are well-defined.We say that the force unwrap operator is "safe"because we can fully describeits behavior for all possible inputs,including input that doesn't satisfy its requirements.So, by extension, unsafe operations must exhibitundefined behavior on at least some inputthat violates their documented expectations.For example, Optional also providesan "unsafe" force-unwrapping operation through its"unsafelyUnwrapped" property.Just like the regular force-unwrap operator,this also requires the underlying value to be non-nil.However, when compiled with optimizations enabled,this property does not verify this requirement;it trusts you that you only call it on a non-nil valueand directly reads it out.So what happens when you accidentally call it on nil?Well, it reads a value that isn't there,and it's difficult to say what exactly this means.Depending on arbitrary circumstances,it could trigger an immediate crash,or it may return some garbage value;perhaps it will do something else.It could do the same thing every time,or its result may change on every execution.The point is that by using this property,you assume full responsibility to fulfill its requirements.If you accidentally violate them,the effects can be unpredictable,and debugging the problemmay be extraordinarily difficult.This is the quintessential property of all unsafe typesand operations in the standard library:they all have assumptions that they are unable,or unwilling, to fully verify.The "unsafe" prefix is a naming conventionthat works a bit like a hazard symbol.It warns you, and anyone reading your code,of the danger inherent in their use.Interfaces marked "unsafe" can still be used to build codethat works reliably;indeed, some tasks can only be done using them.However, you need to be extra careful when you reach for these,and you must fully understand the conditions of their use.In exchange, though, we get to achieve somethingthat would be difficult or impossible to do otherwise.The use cases of unsafe APIstypically fall into one of two categories:either they provideinteroperability with C or Objective-C,or they providefine-grained control over runtime performance,or some other aspect of the execution of your program.Optional's unsafelyUnwrapped property falls squarely in thesecond category. It enables us to eliminatea superfluous check for a nil value.This is best reserved for themost critical parts of our code base,where performance measurements indicatethat the tiny, TINY cost of a potentially unnecessary checkstill has a detrimental impact.To help us catch potential mistakes,this property only elides the nil check in optimized builds;in unoptimized debug builds,it still fully validates its input value.If you ever implement your ownperformance-oriented unsafe interfaces,it is a good idea to replicate this behavior, because itmakes it so much easier to detect problems during development.It is important to notethat the goal of safe APIs is not to prevent crashes.In fact, it's kind of the opposite:when they are given input outside of theirdocumented constraints,safe APIs guarantee to stopexecution by raising a fatal runtime error.These situations indicate serious programming errors:our code broke a critical contract,and we need to go and fix it.Proceeding with execution would be irresponsible.The crash report generated by the error lets usknow the circumstances of how the problem occurred,so that we can debug the problem and correct it.When we say that Swift is a safe programming language,we mean that, by default,its language and library-level featuresfully validate their input.Any construct that does not or cannot do thisis explicitly marked as unsafe.For instance, the Swift standard libraryprovides powerful unsafe pointer types that areroughly on the same level of abstractionas pointers in the C programming language.In order to understand how pointers work,we have to talk a little bit about memory.Swift has a flat memory model:it treats memory as a linear addressspace of individually addressable 8-bit bytes.Each of these bytes has its own unique address,usually printed as a hexadecimal integer value.Now at runtime,the address space is sparsely populated with data thatreflects our app's execution state at any given moment.It includes:our app's executable binary;all the libraries and frameworksthat we have imported;the stack, providing storage for local and temporary variablesas well as some function arguments;dynamic memory regions, includingclass instance storage and memorywe manually allocate ourselves;some regions may even get mapped to read-only resourcessuch as image files.Each individual item is assigned a contiguous memory regionstoring some sort of data in the same,shared, linear address space. As your app executes,the state of its memory keeps evolving.New objects get allocated,the stack keeps changing, old items get destroyed.Luckily the Swift languageand the runtime take care of keepingtrack of where things are for us.We generally don't need to manually managememory in Swift.When we do need to do so though,unsafe pointers give us all the low-level operationswe need to effectively manage memory ourselves.Of course, the flip side of all of this controlis the responsibility that comes with it.These pointers simply representthe address of a location somewhere in memory.They provide powerful operations,but they have to trust you that you will use them correctly,and this makes them fundamentally unsafe.If you aren't careful, your pointer operationsmay scribble all over the address space,ruining the carefully maintained state of your application.For example, dynamically allocatingstorage for an integer valuecreates a storage location for youand gives you a direct pointer to it.The pointer gives youfull control over the underlying memory,but it does not manage it for you.Neither is it able to keep track of whathappens to that memory location later.It merely executes the operations you tell it to do.The pointer gets invalidated as the underlying memoryis deinitialized and deallocated.However, an invalid pointer looksjust like a regular valid one.The pointer itself doesn't know that ithas become invalid.Any attempt to dereference such a dangling pointeris a serious programming error.If we are lucky, the memory location wasrendered completely inaccessible by the deallocation,and trying to access it will result in an immediate crash.However, this isn't guaranteed.Subsequent allocations may have reusedthe same address to store some other value.In this case, dereferencing the dangling pointermay lead to even more serious problems.Attempting to write through it may silently corrupt thestate of some unrelated part of our application.This is bad, because this may have arbitrary effects;for example, it can lead to silent corruptionor even loss of user data.Such bugs are especially sinister when thevalues we access contain object references,or when the memory now containsthe Swift value of an incompatible type.Xcode provides a runtime debugging toolcalled the Address Sanitizer to help youcatch such memory problems.For more information on this and similar Xcode tools, see the"Finding Bugs Using Xcode Runtime Tools"session from a previous conference.For a more detailed discussion on how to avoidissues with pointer type safety,check out my colleague Andy's talk on this topic this week.So if pointers are so dangerous,why would you ever want to use them?Well, a big reason isinteroperability with unsafe languageslike C or Objective-C.In these languages, functions often take pointer arguments,so to be able to call them from Swift,you need to know how to generate pointers to Swift values.In fact, there is a direct mapping between C pointer typesand their corresponding Swift unsafe pointer counterparts.C APIs that we import to Swift get translatedusing this mapping.For example, consider this simple C function that processesa buffer of integer values in some way.When it gets imported to Swift,the const int pointer parametergets translated into an implicitly-unwrappedOptional unsafe pointer type.One way to get such a pointer is to usethe static "allocate" method on UnsafeMutablePointerto create a dynamic buffer suitable for holdinginteger values. Then we can use pointer arithmeticand dedicated initialization methods to set upthe buffer's elements to particular values.And once that's all arranged,we can at last call the C function,passing it the pointer to the initialized buffer.When the function returns, we can deinitialize anddeallocate the buffer,allowing Swift to re-use itsmemory location for something else later.We have full control over every operation along the way,but every step is fundamentally unsafe:The lifetime of the allocated bufferis not managed by the return pointer.We have to remember to manually deallocateit at the appropriate time,or it will stick around forever,causing a memory leak.Initialization cannot automatically verify that theaddressed location is within the buffer we allocated.If we get it wrong, we get undefined behavior.To correctly call the function, we have to be awareif it is going to take ownership of the underlying buffer.In this case, we are assuming that it merelyaccesses it for the duration of the function call,and it doesn't hold onto the pointeror attempt to deallocate it.This is not enforced by the language;we have to look it up in the function's documentation.Deinitialization only makes sense if the underlying memoryhas been previously initializedwith values the correct type.Finally, we must only deallocate memorythat was previously allocated,and which is in a deinitialized state.At every step, there are unchecked assumptions.Getting any one of them wrong will lead to undefined behavior.Now, this code works fine, but it has some questionable choices.One of these is that the buffer is representedsolely by its start address;its length is a separate value that is duplicated all over.We could improve the clarity of this code by modelingthe buffer as a pair of (start address, length) values.This way, the boundaries of the buffer are alwayseasily available, so for example,it becomes possible to easily checkagainst out-of-bounds access at any point.This is why the standard library provides thesefour unsafe buffer pointer types.These come in handy wheneverwe need to work with regions of memory,rather than pointers to individual values.By including the size of the region,as well its location in a nice package,they encourage best practices and let you manage memory more carefully.In an unoptimized debug builds,these buffer pointers check against out-of-bounds accessthrough their subscript operation,contributing a little bit of safety.However, this validation is incomplete by necessity:it is limited to bounds checking.Like pointers, they cannot verify that the underlying memoryis in the expected state.Still, partial checking is far more helpful thanno verification at all,and the mere act of considering the length and theaddress together as a single unitalready helps preventing some simple mistakes.Swift's standard contiguous collections use thesebuffer pointers to provide temporary direct access to theirunderlying storage buffer through thesehandy unsafe methods.It is also possible to geta temporary pointer to an individual Swift value,which we can then pass to C functions expecting such.We can use these methods to simplify our code,isolating unsafe operationsto the smallest possible code section.To get rid of the need for manual memory management,we can store our input data in an Array value.Then we can use thewithUnsafeBufferPointer method to temporarily get directaccess to the array's underlying storage.Within the closure we pass to this function,we can extract the start address and count values,and pass them directly to the C functionwe want to call.In fact, the need to pass pointers to C functionsis so frequent thatSwift provides special syntax for it.We can simply pass an array value to a functionexpecting an unsafe pointer,and the compiler will automatically generate theequivalent withUnsafeBufferPointer for us.Remember, though, that this does not change the factthat the pointer is only valid for theduration of the function call.If the function escapes the pointer and tries to accessthe underlying memory later,then that will result in undefined behavior,no matter what syntax we used to get the pointer.Here's a list of such implicitvalue-to-pointer conversions supported by Swift.As we have just seen,to pass the contents of a Swift Array to a C function,we can simply pass in the array value itself.If the function wants to mutate the elements,we can pass in an "inout" referenceto the array to get a mutable pointer.Functions that take C strings can be calledby directly passing in a Swift String value:the string will produce a temporary C string,including the all-important terminating NUL character.If the C function simply expectsa pointer to an individual value,we can use an "inout" reference to the correspondingSwift value to get a suitable temporary pointer to it.Careful use of this feature lets us call eventhe most complicated C interfaces.For instance, here is a C functionprovided by the Darwin module that youcan use to query or update low-level informationabout the running system. It comes with six parameters,specifying: the location and size of an integer buffer,serving as the identifier for the valuewe want to access;the location and size of another buffer, where we wantthe function to store the current value;and an optional, read-only third buffercontaining a new value we may want to set for the specified entry.However, calling this function from Swift isn'tnecessarily more complicated as it is in C.We can use implicit pointer conversions to great effecthere, resulting in code that is roughly similarin apparent complexity as it would be in its native language.For example, here we want to create a functionthat retrieves the size of a cache linefor the processor architecturewe are running on.The documentation of sysctl tells us thatthis information is available under the identifier"CACHELINE" in the hardware section.To pass this ID to sysctl,we can use an implicit array-to-pointer conversion,and an explicit integer conversion for its count.The information we want to retrieveis a C integer value,so we create a local integer variable,and generate a temporary pointer to itfor the third argument, with anotherinout-to-pointer conversion.The function will copy the size of the cache linesinto the buffer starting at this pointer,overwriting our original zero value with another integer.The fourth argument is a pointer to the size of this buffer,which we can get from the MemoryLayoutof the corresponding integer type.On return, the function will set thisvalue to the number of bytes it copied into "result".Because we only want to retrieve the current value,not set it, we supply a nil value for the "new value" buffer,and set its size to zero.sysctl is documented to return a zero value on success.We assume that this code cannot fail,but we do verify this assumption in casewe've made a mistake in the arguments we supplied.Similarly, we expect the call to set as many bytesas there are in a C integer value.Finally, we can convert the C integer to a Swift Int,and return the result.As it happens, the cache line is64 bytes wide on most platforms.Notice how the unsafe parts are neatly isolatedinto the single function call.Of course, we could also choose to expandthis code into explicit closure based calls.It would look something like this.This code is functionally equivalentto our original version;choosing between the two styles is mostly a matter of taste.To be honest though, in this particular case,I think I prefer to go with the shorter variant.Whichever version we choose though,we need to always be aware that thegenerated pointer values are temporary,and they get invalidated when the function returns.While inout-to-pointer conversions can be convenient,they are really only intended to help calling C functions.In pure Swift code,we need to pass around pointers far less often,so it makes sense to highlight the cases when we dosuch things by preferring to use closure-based APIs.They might be more verbose,but I find that their explicitnessmakes it easier to understand what exactly is happening.In particular, their closure-based design makesthe actual lifetime of the resulting pointerfar more explicit,helping you avoid lifetime issues,like this invalid pointer conversion.Here, passing a temporary pointerto the mutable pointer initializerescapes its value out of the initializer call.Accessing the resulting dangling pointervalue is undefined behavior: the underlying memory locationmay not exist anymore, or it may have been reused for someother value. To help catch these sort of bugs,the Swift 5.3 compiler now produces a helpfulwarning when it can detect such cases.Another recent improvement is that the Swift standard librarynow provides new initializers that allowus to create an Array or a String value by directly copyingdata into their underlying uninitalized storage.This gets rid of the need to allocate temporary buffersonly to prepare such data.For example, String's new initializercan be used to call the samesysctl function to retrieve a string value.Here, we want to find out the kernel version of theoperating system we're running on,which is identified by the VERSION entry in the kernel section.Unlike the cache line example,we don't know the size of the version string in advance.So in order to figure it out,we will need to call sysctl twice.First, we call the function with a nil output buffer.On return, the "length" variable will get setto the number of bytes required to store the string.Like before, we need to remember to check for anyreported errors. With the size of the result on hand,we can now ask String to prepare uninitializedstorage for us so that we can get the actual data.The initializer gives us a buffer pointerthat we can pass to the sysctl function.The function will copy the version stringdirectly into this buffer.On return, we verify that the call was successful.We double check that the functiondid actually copy some bytes to the buffer,and that the last byte is zero, corresponding to theNUL character terminating a C string.This NUL character is not part of the version string,so we discard it by returning one lessthan the amount of bytes copied.This signals to the String exactly howmany bytes of UTF-8 data we've copied into its storage.By using this new String initializer,we get rid of the need for manual memory management here.We get direct access to a buffer that will eventuallybecome storage for a regular Swift string instance.We don't need to manually allocateor deallocate memory.When we call this function,we get the expected version string.So, as we have seen, we can usethe standard library's unsafe APIs to elegantlysolve even the most tricky interoperability puzzles.In summary, to effectively use unsafe APIs,you need to be aware of their expectations,and be careful to always fulfill them;otherwise your code will have undefined behavior.It is easier to do this if you keepunsafe API usage to the minimum.It is always a good idea to choose safer alternativeswhenever they are available.When working with a region of memorycontaining more than one element,it is best to keep track of its boundariesby using unsafe buffer pointersrather than just a pointer value.Xcode provides a set of great tools to help debugissues with how we use unsafe APIs,including the Address Sanitizer.Use these to identify bugs in your codebefore putting it in production,and to debug problems that may have been uncovered.And with that, thank you,
and have a great WWDC.

Hello, and welcome to WWDC.

Hello, my name is Karoy Lorentey,and I'm an engineer on the Swift standard library teamhere at Apple.Today I'm going to talk about unsafe APIs in Swift.

The standard library provides many different constructs:types, protocols, functions, properties, and so on.A small amount of these are explicitly labeled as "unsafe".What does this mean?What makes these special?The distinction between safe and unsafe constructs isnot apparent in the interface they provide.Rather, it arises from the way their implementationsdeal with invalid input.Most operations in the standard libraryfully validate their input before executing,so we can safely assume that any serious coding errors we may makewill be reliably caught and reported.

One example for such an operation is the familiarforce-unwrapping operator on Swift's Optional type.It does require that the value must not be nil,but if we get this wrong, we are guaranteed to geta nice, clean fatal runtime error.Here, we asked Optional to do something that is nonsensical,so stopping execution isthe only responsible thing it can do.Of course, trying to force-unwrap a nil valueis still a serious programming error,but its consequences are well-defined.

We say that the force unwrap operator is "safe"because we can fully describeits behavior for all possible inputs,including input that doesn't satisfy its requirements.

So, by extension, unsafe operations must exhibitundefined behavior on at least some inputthat violates their documented expectations.

For example, Optional also providesan "unsafe" force-unwrapping operation through its"unsafelyUnwrapped" property.Just like the regular force-unwrap operator,this also requires the underlying value to be non-nil.However, when compiled with optimizations enabled,this property does not verify this requirement;it trusts you that you only call it on a non-nil valueand directly reads it out.

So what happens when you accidentally call it on nil?Well, it reads a value that isn't there,and it's difficult to say what exactly this means.Depending on arbitrary circumstances,it could trigger an immediate crash,or it may return some garbage value;perhaps it will do something else.It could do the same thing every time,or its result may change on every execution.

The point is that by using this property,you assume full responsibility to fulfill its requirements.If you accidentally violate them,the effects can be unpredictable,and debugging the problemmay be extraordinarily difficult.

This is the quintessential property of all unsafe typesand operations in the standard library:they all have assumptions that they are unable,or unwilling, to fully verify.

The "unsafe" prefix is a naming conventionthat works a bit like a hazard symbol.It warns you, and anyone reading your code,of the danger inherent in their use.Interfaces marked "unsafe" can still be used to build codethat works reliably;indeed, some tasks can only be done using them.However, you need to be extra careful when you reach for these,and you must fully understand the conditions of their use.

In exchange, though, we get to achieve somethingthat would be difficult or impossible to do otherwise.The use cases of unsafe APIstypically fall into one of two categories:either they provideinteroperability with C or Objective-C,or they providefine-grained control over runtime performance,or some other aspect of the execution of your program.

Optional's unsafelyUnwrapped property falls squarely in thesecond category. It enables us to eliminatea superfluous check for a nil value.This is best reserved for themost critical parts of our code base,where performance measurements indicatethat the tiny, TINY cost of a potentially unnecessary checkstill has a detrimental impact.

To help us catch potential mistakes,this property only elides the nil check in optimized builds;in unoptimized debug builds,it still fully validates its input value.If you ever implement your ownperformance-oriented unsafe interfaces,it is a good idea to replicate this behavior, because itmakes it so much easier to detect problems during development.

It is important to notethat the goal of safe APIs is not to prevent crashes.In fact, it's kind of the opposite:when they are given input outside of theirdocumented constraints,safe APIs guarantee to stopexecution by raising a fatal runtime error.

These situations indicate serious programming errors:our code broke a critical contract,and we need to go and fix it.Proceeding with execution would be irresponsible.The crash report generated by the error lets usknow the circumstances of how the problem occurred,so that we can debug the problem and correct it.

When we say that Swift is a safe programming language,we mean that, by default,its language and library-level featuresfully validate their input.Any construct that does not or cannot do thisis explicitly marked as unsafe.

For instance, the Swift standard libraryprovides powerful unsafe pointer types that areroughly on the same level of abstractionas pointers in the C programming language.In order to understand how pointers work,we have to talk a little bit about memory.

Swift has a flat memory model:it treats memory as a linear addressspace of individually addressable 8-bit bytes.Each of these bytes has its own unique address,usually printed as a hexadecimal integer value.

Now at runtime,the address space is sparsely populated with data thatreflects our app's execution state at any given moment.It includes:our app's executable binary;all the libraries and frameworksthat we have imported;the stack, providing storage for local and temporary variablesas well as some function arguments;dynamic memory regions, includingclass instance storage and memorywe manually allocate ourselves;some regions may even get mapped to read-only resourcessuch as image files.

Each individual item is assigned a contiguous memory regionstoring some sort of data in the same,shared, linear address space. As your app executes,the state of its memory keeps evolving.New objects get allocated,the stack keeps changing, old items get destroyed.Luckily the Swift languageand the runtime take care of keepingtrack of where things are for us.We generally don't need to manually managememory in Swift.

When we do need to do so though,unsafe pointers give us all the low-level operationswe need to effectively manage memory ourselves.Of course, the flip side of all of this controlis the responsibility that comes with it.These pointers simply representthe address of a location somewhere in memory.They provide powerful operations,but they have to trust you that you will use them correctly,and this makes them fundamentally unsafe.If you aren't careful, your pointer operationsmay scribble all over the address space,ruining the carefully maintained state of your application.

For example, dynamically allocatingstorage for an integer valuecreates a storage location for youand gives you a direct pointer to it.The pointer gives youfull control over the underlying memory,but it does not manage it for you.Neither is it able to keep track of whathappens to that memory location later.It merely executes the operations you tell it to do.

The pointer gets invalidated as the underlying memoryis deinitialized and deallocated.However, an invalid pointer looksjust like a regular valid one.The pointer itself doesn't know that ithas become invalid.Any attempt to dereference such a dangling pointeris a serious programming error.

If we are lucky, the memory location wasrendered completely inaccessible by the deallocation,and trying to access it will result in an immediate crash.However, this isn't guaranteed.Subsequent allocations may have reusedthe same address to store some other value.In this case, dereferencing the dangling pointermay lead to even more serious problems.Attempting to write through it may silently corrupt thestate of some unrelated part of our application.

This is bad, because this may have arbitrary effects;for example, it can lead to silent corruptionor even loss of user data.Such bugs are especially sinister when thevalues we access contain object references,or when the memory now containsthe Swift value of an incompatible type.

Xcode provides a runtime debugging toolcalled the Address Sanitizer to help youcatch such memory problems.For more information on this and similar Xcode tools, see the"Finding Bugs Using Xcode Runtime Tools"session from a previous conference.For a more detailed discussion on how to avoidissues with pointer type safety,check out my colleague Andy's talk on this topic this week.

So if pointers are so dangerous,why would you ever want to use them?Well, a big reason isinteroperability with unsafe languageslike C or Objective-C.

In these languages, functions often take pointer arguments,so to be able to call them from Swift,you need to know how to generate pointers to Swift values.In fact, there is a direct mapping between C pointer typesand their corresponding Swift unsafe pointer counterparts.C APIs that we import to Swift get translatedusing this mapping.

For example, consider this simple C function that processesa buffer of integer values in some way.When it gets imported to Swift,the const int pointer parametergets translated into an implicitly-unwrappedOptional unsafe pointer type.

One way to get such a pointer is to usethe static "allocate" method on UnsafeMutablePointerto create a dynamic buffer suitable for holdinginteger values. Then we can use pointer arithmeticand dedicated initialization methods to set upthe buffer's elements to particular values.And once that's all arranged,we can at last call the C function,passing it the pointer to the initialized buffer.When the function returns, we can deinitialize anddeallocate the buffer,allowing Swift to re-use itsmemory location for something else later.

We have full control over every operation along the way,but every step is fundamentally unsafe:The lifetime of the allocated bufferis not managed by the return pointer.We have to remember to manually deallocateit at the appropriate time,or it will stick around forever,causing a memory leak.

Initialization cannot automatically verify that theaddressed location is within the buffer we allocated.If we get it wrong, we get undefined behavior.

To correctly call the function, we have to be awareif it is going to take ownership of the underlying buffer.In this case, we are assuming that it merelyaccesses it for the duration of the function call,and it doesn't hold onto the pointeror attempt to deallocate it.This is not enforced by the language;we have to look it up in the function's documentation.

Deinitialization only makes sense if the underlying memoryhas been previously initializedwith values the correct type.

Finally, we must only deallocate memorythat was previously allocated,and which is in a deinitialized state.

At every step, there are unchecked assumptions.Getting any one of them wrong will lead to undefined behavior.

Now, this code works fine, but it has some questionable choices.One of these is that the buffer is representedsolely by its start address;its length is a separate value that is duplicated all over.

We could improve the clarity of this code by modelingthe buffer as a pair of (start address, length) values.This way, the boundaries of the buffer are alwayseasily available, so for example,it becomes possible to easily checkagainst out-of-bounds access at any point.

This is why the standard library provides thesefour unsafe buffer pointer types.These come in handy wheneverwe need to work with regions of memory,rather than pointers to individual values.By including the size of the region,as well its location in a nice package,they encourage best practices and let you manage memory more carefully.

In an unoptimized debug builds,these buffer pointers check against out-of-bounds accessthrough their subscript operation,contributing a little bit of safety.However, this validation is incomplete by necessity:it is limited to bounds checking.Like pointers, they cannot verify that the underlying memoryis in the expected state.Still, partial checking is far more helpful thanno verification at all,and the mere act of considering the length and theaddress together as a single unitalready helps preventing some simple mistakes.

Swift's standard contiguous collections use thesebuffer pointers to provide temporary direct access to theirunderlying storage buffer through thesehandy unsafe methods.It is also possible to geta temporary pointer to an individual Swift value,which we can then pass to C functions expecting such.We can use these methods to simplify our code,isolating unsafe operationsto the smallest possible code section.

To get rid of the need for manual memory management,we can store our input data in an Array value.Then we can use thewithUnsafeBufferPointer method to temporarily get directaccess to the array's underlying storage.Within the closure we pass to this function,we can extract the start address and count values,and pass them directly to the C functionwe want to call.

In fact, the need to pass pointers to C functionsis so frequent thatSwift provides special syntax for it.We can simply pass an array value to a functionexpecting an unsafe pointer,and the compiler will automatically generate theequivalent withUnsafeBufferPointer for us.

Remember, though, that this does not change the factthat the pointer is only valid for theduration of the function call.If the function escapes the pointer and tries to accessthe underlying memory later,then that will result in undefined behavior,no matter what syntax we used to get the pointer.

Here's a list of such implicitvalue-to-pointer conversions supported by Swift.As we have just seen,to pass the contents of a Swift Array to a C function,we can simply pass in the array value itself.If the function wants to mutate the elements,we can pass in an "inout" referenceto the array to get a mutable pointer.Functions that take C strings can be calledby directly passing in a Swift String value:the string will produce a temporary C string,including the all-important terminating NUL character.If the C function simply expectsa pointer to an individual value,we can use an "inout" reference to the correspondingSwift value to get a suitable temporary pointer to it.

Careful use of this feature lets us call eventhe most complicated C interfaces.

For instance, here is a C functionprovided by the Darwin module that youcan use to query or update low-level informationabout the running system. It comes with six parameters,specifying: the location and size of an integer buffer,serving as the identifier for the valuewe want to access;the location and size of another buffer, where we wantthe function to store the current value;and an optional, read-only third buffercontaining a new value we may want to set for the specified entry.

However, calling this function from Swift isn'tnecessarily more complicated as it is in C.We can use implicit pointer conversions to great effecthere, resulting in code that is roughly similarin apparent complexity as it would be in its native language.

For example, here we want to create a functionthat retrieves the size of a cache linefor the processor architecturewe are running on.

The documentation of sysctl tells us thatthis information is available under the identifier"CACHELINE" in the hardware section.To pass this ID to sysctl,we can use an implicit array-to-pointer conversion,and an explicit integer conversion for its count.

The information we want to retrieveis a C integer value,so we create a local integer variable,and generate a temporary pointer to itfor the third argument, with anotherinout-to-pointer conversion.The function will copy the size of the cache linesinto the buffer starting at this pointer,overwriting our original zero value with another integer.

The fourth argument is a pointer to the size of this buffer,which we can get from the MemoryLayoutof the corresponding integer type.On return, the function will set thisvalue to the number of bytes it copied into "result".

Because we only want to retrieve the current value,not set it, we supply a nil value for the "new value" buffer,and set its size to zero.

sysctl is documented to return a zero value on success.We assume that this code cannot fail,but we do verify this assumption in casewe've made a mistake in the arguments we supplied.Similarly, we expect the call to set as many bytesas there are in a C integer value.

Finally, we can convert the C integer to a Swift Int,and return the result.As it happens, the cache line is64 bytes wide on most platforms.

Notice how the unsafe parts are neatly isolatedinto the single function call.

Of course, we could also choose to expandthis code into explicit closure based calls.It would look something like this.This code is functionally equivalentto our original version;choosing between the two styles is mostly a matter of taste.To be honest though, in this particular case,I think I prefer to go with the shorter variant.

Whichever version we choose though,we need to always be aware that thegenerated pointer values are temporary,and they get invalidated when the function returns.

While inout-to-pointer conversions can be convenient,they are really only intended to help calling C functions.In pure Swift code,we need to pass around pointers far less often,so it makes sense to highlight the cases when we dosuch things by preferring to use closure-based APIs.They might be more verbose,but I find that their explicitnessmakes it easier to understand what exactly is happening.

In particular, their closure-based design makesthe actual lifetime of the resulting pointerfar more explicit,helping you avoid lifetime issues,like this invalid pointer conversion.Here, passing a temporary pointerto the mutable pointer initializerescapes its value out of the initializer call.Accessing the resulting dangling pointervalue is undefined behavior: the underlying memory locationmay not exist anymore, or it may have been reused for someother value. To help catch these sort of bugs,the Swift 5.3 compiler now produces a helpfulwarning when it can detect such cases.

Another recent improvement is that the Swift standard librarynow provides new initializers that allowus to create an Array or a String value by directly copyingdata into their underlying uninitalized storage.This gets rid of the need to allocate temporary buffersonly to prepare such data.

For example, String's new initializercan be used to call the samesysctl function to retrieve a string value.Here, we want to find out the kernel version of theoperating system we're running on,which is identified by the VERSION entry in the kernel section.

Unlike the cache line example,we don't know the size of the version string in advance.So in order to figure it out,we will need to call sysctl twice.

First, we call the function with a nil output buffer.On return, the "length" variable will get setto the number of bytes required to store the string.Like before, we need to remember to check for anyreported errors. With the size of the result on hand,we can now ask String to prepare uninitializedstorage for us so that we can get the actual data.The initializer gives us a buffer pointerthat we can pass to the sysctl function.The function will copy the version stringdirectly into this buffer.On return, we verify that the call was successful.We double check that the functiondid actually copy some bytes to the buffer,and that the last byte is zero, corresponding to theNUL character terminating a C string.This NUL character is not part of the version string,so we discard it by returning one lessthan the amount of bytes copied.This signals to the String exactly howmany bytes of UTF-8 data we've copied into its storage.

By using this new String initializer,we get rid of the need for manual memory management here.We get direct access to a buffer that will eventuallybecome storage for a regular Swift string instance.We don't need to manually allocateor deallocate memory.When we call this function,we get the expected version string.

So, as we have seen, we can usethe standard library's unsafe APIs to elegantlysolve even the most tricky interoperability puzzles.

In summary, to effectively use unsafe APIs,you need to be aware of their expectations,and be careful to always fulfill them;otherwise your code will have undefined behavior.

It is easier to do this if you keepunsafe API usage to the minimum.It is always a good idea to choose safer alternativeswhenever they are available.

When working with a region of memorycontaining more than one element,it is best to keep track of its boundariesby using unsafe buffer pointersrather than just a pointer value.

Xcode provides a set of great tools to help debugissues with how we use unsafe APIs,including the Address Sanitizer.Use these to identify bugs in your codebefore putting it in production,and to debug problems that may have been uncovered.

And with that, thank you,
and have a great WWDC.

0:52 -Optional's force unwrapping operator

1:58 -Unsafe force-unwrapping

2:25 -Invalid use of unsafe force-unwrapping

4:23 -Invalid use of unsafe force-unwrapping

7:37 -Manual memory management

10:04 -Passing an array of integers to a C function (1)

10:08 -Passing an array of integers to a C function (2)

10:17 -Passing an array of integers to a C function (3)

12:33 -Unsafe buffer pointer types

13:28 -Accessing contiguous collection storage

13:39 -Temporary pointers to Swift values

13:48 -Passing an array of integers to a C function (4)

14:25 -Passing an array of integers to a C function (5)

15:36 -Advanced C interoperability

16:32 -Advanced C interoperability

18:18 -Advanced C interoperability

18:30 -Advanced C interoperability

18:48 -Closure-based vs. implicit pointers

19:19 -Closure-based vs. implicit pointers

19:43 -Initializing contiguous collection storage

20:02 -Initializing a String value using a C function

## Code Samples

```swift
let
 value: 
Int
? 
=
 
nil



print
(value
!
) 
// Fatal error: Unexpectedly found nil while unwrapping an Optional value
```

```swift
let
 value: 
String
? 
=
 
"Hello"



print
(value.unsafelyUnwrapped) 
// Hello
```

```swift
let
 value: 
String
? 
=
 
nil



print
(value.unsafelyUnwrapped) 
// ?!
```

```swift
let
 value: 
String
? 
=
 
nil



print
(value.unsafelyUnwrapped) 
// Guaranteed fatal error in debug builds
```

```swift
let
 ptr 
=
 
UnsafeMutablePointer
<
Int
>.allocate(capacity: 
1
)
ptr.initialize(to: 
42
)

print
(ptr.pointee) 
// 42

ptr.deallocate()
ptr.pointee 
=
 
23
 
// UNDEFINED BEHAVIOR
```

```swift
void
 process_integers(
const
 
int
 *start, size_t count);
```

```swift
func
 
process_integers
(
_
 
start
: 
UnsafePointer
<
CInt
>!, 
_
 
count
: 
Int
)
```

```swift
let
 start 
=
 
UnsafeMutablePointer
<
CInt
>.allocate(capacity: 
4
)

start.initialize(to: 
0
)
(start 
+
 
1
).initialize(to: 
2
)
(start 
+
 
2
).initialize(to: 
4
)
(start 
+
 
3
).initialize(to: 
6
)

process_integers(start, 
4
)

start.deinitialize(count: 
4
)
start.deallocate()
```

```swift
UnsafeBufferPointer
<
Element
>

UnsafeMutableBufferPointer
<
Element
>


UnsafeRawBufferPointer


UnsafeMutableRawBufferPointer
```

```swift
Sequence
.withContiguousStorageIfAvailable(
_
:)

MutableCollection
.withContiguousMutableStorageIfAvailable(
_
:)


String
.withCString(
_
:)

String
.withUTF8(
_
:)


Array
.withUnsafeBytes(
_
:)

Array
.withUnsafeBufferPointer(
_
:)

Array
.withUnsafeMutableBytes(
_
:)

Array
.withUnsafeMutableBufferPointer(
_
:)
```

```swift
withUnsafePointer
(to:
_
:)

withUnsafeMutablePointer
(to:
_
:)
withUnsafeBytes(of:
_
:)
withUnsafeMutableBytes(of:
_
:)
```

```swift
let
 values: [
CInt
] 
=
 [
0
, 
2
, 
4
, 
6
]

values.withUnsafeBufferPointer { buffer 
in

  print_integers(buffer.baseAddress
!
, buffer.count)
}
```

```swift
let
 values: [
CInt
] 
=
 [
0
, 
2
, 
4
, 
6
]

print_integers(values, values.count)
```

```swift
func
 
sysctl
(
  
_
 
name
: 
UnsafeMutablePointer
<
CInt
>!,
  
_
 
namelen
: 
CUnsignedInt
,
  
_
 
oldp
: 
UnsafeMutableRawPointer
!,
  
_
 
oldlenp
: 
UnsafeMutablePointer
<
Int
>!,
  
_
 
newp
: 
UnsafeMutableRawPointer
!,
  
_
 
newlen
: 
Int

)
 -> 
CInt
```

```swift
import
 Darwin


func
 
cachelineSize
()
 -> 
Int
 {
    
var
 query 
=
 [
CTL_HW
, 
HW_CACHELINE
]
    
var
 result: 
CInt
 
=
 
0

    
var
 resultSize 
=
 
MemoryLayout
<
CInt
>.size
    
let
 r 
=
 sysctl(
&
query, 
CUnsignedInt
(query.count), 
&
result, 
&
resultSize, 
nil
, 
0
)
    
precondition
(r 
==
 
0
, 
"Cannot query cache line size"
)
    
precondition
(resultSize 
==
 
MemoryLayout
<
CInt
>.size)
    
return
 
Int
(result)
}


print
(cachelineSize()) 
// 64
```

```swift
import
 Darwin


func
 
cachelineSize
()
 -> 
Int
 {
    
var
 query 
=
 [
CTL_HW
, 
HW_CACHELINE
]
    
return
 query.withUnsafeMutableBufferPointer { buffer 
in

        
var
 result: 
CInt
 
=
 
0

        
withUnsafeMutablePointer
(to: 
&
result) { resultptr 
in

            
var
 resultSize 
=
 
MemoryLayout
<
CInt
>.size
            
let
 r 
=
 
withUnsafeMutablePointer
(to: 
&
resultSize) { sizeptr 
in

                sysctl(buffer.baseAddress, 
CUnsignedInt
(buffer.count),
                       resultptr, sizeptr,
                       
nil
, 
0
)
            }
            
precondition
(r 
==
 
0
, 
"Cannot query cache line size"
)
            
precondition
(resultSize 
==
 
MemoryLayout
<
CInt
>.size)
        }
        
return
 
Int
(result)
    }
}


print
(cachelineSize()) 
// 64
```

```swift
var
 value 
=
 
42


withUnsafeMutablePointer
(to: 
&
value) { p 
in

  p.pointee 
+=
 
1

}

print
(value)  
// 43
```

```swift
var
 value 
=
 
42


withUnsafeMutablePointer
(to: 
&
value) { p 
in

  p.pointee 
+=
 
1

}

print
(value)  
// 43



var
 value2 
=
 
42


let
 p 
=
 
UnsafeMutablePointer
(
&
value2) 
// BROKEN -- dangling pointer!

p.pointee 
+=
 
1


print
(value2)
```

```swift
Array
.
init
(unsafeUninitializedCapacity:initializingWith:)

String
.
init
(unsafeUninitializedCapacity:initializingUTF8With:)
```

```swift
import
 Darwin


func
 
kernelVersion
()
 -> 
String
 {
    
var
 query 
=
 [
CTL_KERN
, 
KERN_VERSION
]
    
var
 length 
=
 
0

    
let
 r 
=
 sysctl(
&
query, 
2
, 
nil
, 
&
length, 
nil
, 
0
)
    
precondition
(r 
==
 
0
, 
"Error retrieving kern.version"
)
    
return
 
String
(unsafeUninitializedCapacity: length) { buffer 
in

        
var
 length 
=
 buffer.count
        
let
 r 
=
 sysctl(
&
query, 
2
, buffer.baseAddress, 
&
length, 
nil
, 
0
)
        
precondition
(r 
==
 
0
, 
"Error retrieving kern.version"
)
        
precondition
(length 
>
 
0
 
&&
 length 
<=
 buffer.count)
        
precondition
(buffer[length 
-
 
1
] 
==
 
0
)
        
return
 length 
-
 
1

    }
}


print
(kernelVersion())

// Darwin Kernel Version 19.5.0: Thu Apr 30 18:25:59 PDT 2020; root:xnu-6153.121.1~7/RELEASE_X86_64
```


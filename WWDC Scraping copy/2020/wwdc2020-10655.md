# Wwdc2020 10655

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Discover how to download and play HLS offlineDiscover how to play HLS audio or video without an internet connection in your app by downloading HLS content for offline consumption using AVFoundation. Explore best practices for working with your HLS content while offline, learn how to use FairPlay Streaming to protect your offline audio and video, and hear updates on our media download policies.ResourcesUsing AVFoundation to play and persist HTTP Live StreamsHD VideoSD VideoRelated VideosWWDC21Explore HLS variants in AVFoundation

Discover how to play HLS audio or video without an internet connection in your app by downloading HLS content for offline consumption using AVFoundation. Explore best practices for working with your HLS content while offline, learn how to use FairPlay Streaming to protect your offline audio and video, and hear updates on our media download policies.

Using AVFoundation to play and persist HTTP Live Streams

HD VideoSD Video

HD Video

SD Video

Explore HLS variants in AVFoundation

Search this videoâ€¦Hello and welcome to WWDC.My name is Nishant and I am a Streaming Media Engineer at Apple. If youare looking to let your users download and play your HLS contentwhile off line, you've tuned in to the right session. We introduced the abilityto download HLS back in 2016. Over the years we have added new functionalityand in this talk we'll cover everything you need to know. Many of youalready have media content authored as HLS for streaming. You canuse the same for downloads. Along with that you can use FairPlay streamingcontent protection. And finally offline HLS allows your users to downloadthe content in the background. So first question first, should I use offline HLS? Yes.Use it when your user explicitly requests media downloads. They may wantto download say when they're about to get on an airplane, or they may beon some expensive cellular data dataplan and they may want to downloadon Wi-Fi, in all these cases. It's appropriate to use offline HLS.Let's see how we can get you started. Offline HLS starts with the creationof a download task. The download task represents the entire lifecycle ofa media download such as a movie. Later on, you need to monitor the downloadtask and update any progress in your app. And finally, once a download iscomplete you can play it offline. So let's take a look at the download task.Download tasks are defined on URLSession. What is a URLSession?URLSession is an object which coordinates all network related tasks such as upload and download tasks.The download task specifically inherit certain features from it. The importantones to remember are the Download task are scheduled according to availabilityof system resources. So in certain cases you may see that, the download doesnot start immediately. For example, the network connectivity is poor,the download starts when the network improves. Another important thing to rememberis that downloads are automatically retried. For example, if you hit networktimeouts, AVFoundation retries the download for you. Before we dig in,let's take a look at typical HLS asset we all are a familiar with.This particular asset has a bunch of video, audio and subtitle renditions.We will be using this as an example going forward. Coming to download tasks,there are two variants. The first one we're going to look at is AVAssetDownloadTask.Using it, you can download one combination of video audio andsubtitle renditions. To create one of these download tasks, you need to setup a URLSession specifically AVAssetDownloadURLSession. Youcreate it with the session configuration using an identifier. And then onceyou have the URLSession you can call makeAssetDownloadTask. Here In thisexample I'm downloading a movie at 2 megabits. When you createAVAssetDownloadTask automatic media selection will be used. What does that mean?Automatic media selection chooses renditions based on device region andlocalization preferences. For example if the device region is set as France,French audio and French subtitle renditions will be downloaded.Moving on, after creating one of these things, the next thing you may want to dois monitor it for progress. To do this you need to use AVAssetDownloadDelegateprotocol. I would like to highlight two of the interfaces we have here.The first one can be used to monitor the progress of your download.It provides you that with the time ranges that have been downloaded ratherthan bytes, so as to correlate better with media interfaces. We also havedidCompleteWithError, which informs you when the download is complete.You can use these interfaces to build a progress UI in your app. Here isan example on how you can do it. I wouldn't go into detail but it's herefor your reference. Some of you may be wondering what if I want to downloadmultiple audio and subtitle renditions. We have another API calledAVAggregateAssetDownloadTask. Using AVAggregateAssetDownloadTask, you choose whatrenditions you want to download. Going back to our earlier example usingAggregateDownloadTask, You can download English audio and English subtitlesfollowed by Spanish audio and Spanish subtitles and French subtitle renditions.This API is appropriate when you want to let your users choose which audioand subtitle renditions they want to download. To create one of these,first you need an array of media selections which you want to download. You cancreate a media selection by opening a mutableMediaSelection fromyour asset and choosing appropriate media selection option. Once you haveyour media selections you create AVAssetDownloadURLSession as wedid before. Later, you call aggregate AggregateAssetDownloadTask with the media selectionsyou wanted to download. Since AggregateAssetDownloadTask involves multiplemedia selections, monitoring it is a bit different compared to AVAssetDownloadTask.The first thing to do is split the download progress betweenyour various media selections. You can do this by assigning weights toeach one of these media selections. The first media selection will typicallyinvolve downloading video and hence will take a longer time. We have observedthat this accounts for approximately 70 percent of the download time, butthis may vary depending on how your content is authored. Then you splitthe remaining weight between your other media selections. Keep in mind thatdownloading audio takes more time compared to downloading subtitle tracks.Going back to our earlier example. You can assign 70 percent of the downloadtime to the video rendition, 10 percent of the time to each of the audiorenditions. Here I have split the time for the audio transition between studioand multi-channel representation. Finally we can assign the remaining timeto the subtitle renditions. In order to get you started, let's look at someof the downloadDelegate interfaces. To monitor progress, you stilluse the loadedTimeRanges callback. Similarly to AVAssetDownloadTask.But here, in addition to loadedTimeRanges you will be informed aboutthe media selection for which the time range was loaded. Another interfaceto look at as didCompleteForMediaSelection. You can use this as a synchronizationpoint while estimating your download progress. In case of audio rendition,expect the calls twice: once for studio representation, followed by once farmulti-channel representation. Another thing that might happen during theirdownload is your app may get backgrounded. Download tasks still run when yourapp is in background. When your app is relaunched, you need to restore yourexisting DownloadTask. You can do this by creating a URLSession with the sameconfiguration identifier you used previously. Then you can restore yourexisting task and then query the task to get the latest status of your downloads.You can also get the original AVAsset from the downloadTkask and youuse it. So now you know how to create and monitor the download task.Let's see how you can play them. First let's take a look at where your downloadis deposited on the disk. In case of AVAssetDownloadTask, you get thelocation once the download is complete. And in case of aggregateDownloadTask,you get the location via willDownloadTo delegate callback.We may want to store this location. We'll see that reason in a bit.Now let's see how we can play your download. Here is how we created a downloadtask earlier. For playback you to use the AVAsset to create your playbackitem. An advantage of using the same AVAsset is it allows AVFoundationto optimize resources between playback and download. This will be usefulin cases where the playback happens before the download is complete.We call this scenario as play while download is in progress. Any media resourcesfetch during playback will be stored to the disk and will not be refreshedagain for the download. Another scenario you may encounter is your useris trying to play along after the download is complete. In that case youmay not have the original AVAsset or the downloadTask object lying around.In such cases you can recreate an AVAsset using the file URL. This isthe same URL we saved earlier. Some of you may be wondering, Alright, I havean asset here probably with a bunch of audio and subtitled renditions,How can I find out what can be played offline? We have an interface calledAVAssetCache. We can obtain the AVAssetCache object from yourAVAsset. It tells you what can we play it offline. And also what mediaselections are playable offline. Now you know how to download and playmedia content while offline. Let's talk about how you can protect your contentusing FairPlay. FairPlay streaming for offline HLS was introduced back in 2016.Some of you may already be using FairPlay Streaming for protecting yourstreaming content. You can do the same for offline HLS as well.If you're new to FairPlay streaming I would recommend you check out our earliertalk "AVContentKeySession Best Practices" from WWDC 2018. When streaming,you get your key from your key server as needed, but during offline playback.You may not be able to reach your key server. Instead you create somethingcalled as offline key during the download and store it for later use.Let's see how we can get to this offline key. You need AVContentKeySession tostart with. Then, initiate key loading as you normally do for the streaming case.If you do not know the key required for the download, don't worry.When you create the downloadTask you will also receive a key request from AVContentKeySession,If the key is already not loaded. Then you create a server playbackcontext, SPC for short, by providing your FairPlay streaming applicationcertificate. You call your key server and get back the key in the form of Content Key Context.CKC for short. And provide the CKC to AVContentKeySession. You can laterobtain offline key from it. We store there offline key for subsequent use.During offline playback, when you receive a key request you can reply backwith the offline key you created earlier. One thing to remember is FairPlay streaminglets your keyservers set an expiration date for offline keys. If the key expiresduring existing playback session, in order to have a good user experience.The session continues to the end rather than stop abruptly. Finally rememberto create a new offline key before expiration. In some cases you may wantto securely delete an offline key before it expires. For example whenthe user deletes the download. Since iOS 12 we can invalidate an offlinekey by providing it to AVContentKeySession. We can also invalidateall your offline keys by providing your FairPlay streaming application certificate.AVContentKeySession also allows you to create offline keys for movie rentals.Typical rental scenario involves having 2 expiration dates. One which startswhen the user rents a movie, and the other one which starts when the userstarts playback. FairPlay Streaming supports this using dual expiry offlinekeys. For example, you can let your user watch a rental within 30 daysof purchase, but once they start watching they have to finish within 48 hours.Again this is explained in more detail in "AVContentKeySession Best Practices"from WWDC 2018. There is one more thing you may find useful. Your app may beusing custom protocols for URL resources when streaming. What arecustom protocols for URLs? These are the URLs which begin with custom scheme.For example URLs beginning with myscheme and URLs beginning with skd://.These are the resources specific to your app and AVFoundation handlesthem using AVAssetResourceLoader for playlists, andAVContentKeySessionfor keys. If your app gets backgrounded immediately after the downloadstarts, you can still answer resource requests for custom protocols.Starting from iOS 14, you have 30 seconds to answer any resource requestsinvolving custom protocols. Moving on, let's talk a few things you can doto improve user experience. First let's talk about the download time.Users prefer downloads which complete faster but they also prefer downloads whichare of higher quality. You need to find the right balance. One best practicewe recommend is to allow your users an option to do fast download.This may be really helpful for those users who are downloading just before catchinga flight and finally; and another option for best quality download. For eitherof these options. You may want to restrict the type and quality of the contentyou want to download. You can do this by using various option on the downloadTask.Firstly, we can restrict media rate using minimumRequiredMediaBitrateKey.For example, if we specify minimumRequiredMediaBitrateKey as five megabits,the bitrate really in just about five megabits would be chosen for downloads.Starting from iOS 14, you can also restrict based on presentation sizeas well. Another quality restriction you can do is to download HDR presentationsare not. By default, the download task would prefer to download HDR presentationsif available. Lastly, you may want to restrict based on audio type. Again,by default AVFoundation downloads both stereo and multi-channel audiorenditions. Can opt out of multi-channel by setting prefersMultichanneloption key to false. Some of you may be wondering, why download both studioand multi-channel representations? We believe that the stereo renditionmixed at the studio better reflects artistic intent. For example the dialoguemay be given more prominence compared to other background noise. You maywant to experiment with these options and choose them appropriatelydepending on how your media library is authored. Moving on, let's talk about storage management.Another best practice we recommend is you let the operating system managethe storage for your offline download. By doing so it allows operatingsystem to delete and reclaim storage when your app is not running.For example, during software updates operating system can automatically reclaimspace when the storage is running low. It also allows your users to deletemedia content through the settings app. Asset image and title you providewhen you create the download task will be displayed here. Now let's takea look at how you can opt into this. You start by getting a shared storage manager.Then you create a new policy by providing a priority and expiration dateAssets would be purged, based on expiration date and then based on the priority.Finally you set the policy on your downloaded content. Remember to keepthe downloaded content at the same system provided location and be preparedfor the assets to be deleted by the system. So that is offline HLS andwe are really excited for you to start using it. To wrap-up, we went overtwo different downloadTask using which you can download HLS. The first one is AVAssetDownloadTaskwhich uses automatic media selection to select media renditionsto download. And the second one is the aggregateDownloadTask which letsyou specify the audio and subtitle renditions you want to download.Finally we looked at how we can use FairPlay Streaming to protect your offline content,and learn some best practices on the way. To get you started, we have asample app which you can obtain from the resources below.Thank you for joining and
enjoy the rest of WWDC.

Hello and welcome to WWDC.

My name is Nishant and I am a Streaming Media Engineer at Apple. If youare looking to let your users download and play your HLS contentwhile off line, you've tuned in to the right session. We introduced the abilityto download HLS back in 2016. Over the years we have added new functionalityand in this talk we'll cover everything you need to know. Many of youalready have media content authored as HLS for streaming. You canuse the same for downloads. Along with that you can use FairPlay streamingcontent protection. And finally offline HLS allows your users to downloadthe content in the background. So first question first, should I use offline HLS? Yes.Use it when your user explicitly requests media downloads. They may wantto download say when they're about to get on an airplane, or they may beon some expensive cellular data dataplan and they may want to downloadon Wi-Fi, in all these cases. It's appropriate to use offline HLS.Let's see how we can get you started. Offline HLS starts with the creationof a download task. The download task represents the entire lifecycle ofa media download such as a movie. Later on, you need to monitor the downloadtask and update any progress in your app. And finally, once a download iscomplete you can play it offline. So let's take a look at the download task.

Download tasks are defined on URLSession. What is a URLSession?URLSession is an object which coordinates all network related tasks such as upload and download tasks.

The download task specifically inherit certain features from it. The importantones to remember are the Download task are scheduled according to availabilityof system resources. So in certain cases you may see that, the download doesnot start immediately. For example, the network connectivity is poor,the download starts when the network improves. Another important thing to rememberis that downloads are automatically retried. For example, if you hit networktimeouts, AVFoundation retries the download for you. Before we dig in,let's take a look at typical HLS asset we all are a familiar with.

This particular asset has a bunch of video, audio and subtitle renditions.

We will be using this as an example going forward. Coming to download tasks,there are two variants. The first one we're going to look at is AVAssetDownloadTask.Using it, you can download one combination of video audio andsubtitle renditions. To create one of these download tasks, you need to setup a URLSession specifically AVAssetDownloadURLSession. Youcreate it with the session configuration using an identifier. And then onceyou have the URLSession you can call makeAssetDownloadTask. Here In thisexample I'm downloading a movie at 2 megabits. When you createAVAssetDownloadTask automatic media selection will be used. What does that mean?Automatic media selection chooses renditions based on device region andlocalization preferences. For example if the device region is set as France,French audio and French subtitle renditions will be downloaded.Moving on, after creating one of these things, the next thing you may want to dois monitor it for progress. To do this you need to use AVAssetDownloadDelegateprotocol. I would like to highlight two of the interfaces we have here.

The first one can be used to monitor the progress of your download.It provides you that with the time ranges that have been downloaded ratherthan bytes, so as to correlate better with media interfaces. We also havedidCompleteWithError, which informs you when the download is complete.

You can use these interfaces to build a progress UI in your app. Here isan example on how you can do it. I wouldn't go into detail but it's herefor your reference. Some of you may be wondering what if I want to downloadmultiple audio and subtitle renditions. We have another API calledAVAggregateAssetDownloadTask. Using AVAggregateAssetDownloadTask, you choose whatrenditions you want to download. Going back to our earlier example usingAggregateDownloadTask, You can download English audio and English subtitlesfollowed by Spanish audio and Spanish subtitles and French subtitle renditions.

This API is appropriate when you want to let your users choose which audioand subtitle renditions they want to download. To create one of these,first you need an array of media selections which you want to download. You cancreate a media selection by opening a mutableMediaSelection fromyour asset and choosing appropriate media selection option. Once you haveyour media selections you create AVAssetDownloadURLSession as wedid before. Later, you call aggregate AggregateAssetDownloadTask with the media selectionsyou wanted to download. Since AggregateAssetDownloadTask involves multiplemedia selections, monitoring it is a bit different compared to AVAssetDownloadTask.The first thing to do is split the download progress betweenyour various media selections. You can do this by assigning weights toeach one of these media selections. The first media selection will typicallyinvolve downloading video and hence will take a longer time. We have observedthat this accounts for approximately 70 percent of the download time, butthis may vary depending on how your content is authored. Then you splitthe remaining weight between your other media selections. Keep in mind thatdownloading audio takes more time compared to downloading subtitle tracks.

Going back to our earlier example. You can assign 70 percent of the downloadtime to the video rendition, 10 percent of the time to each of the audiorenditions. Here I have split the time for the audio transition between studioand multi-channel representation. Finally we can assign the remaining timeto the subtitle renditions. In order to get you started, let's look at someof the downloadDelegate interfaces. To monitor progress, you stilluse the loadedTimeRanges callback. Similarly to AVAssetDownloadTask.But here, in addition to loadedTimeRanges you will be informed aboutthe media selection for which the time range was loaded. Another interfaceto look at as didCompleteForMediaSelection. You can use this as a synchronizationpoint while estimating your download progress. In case of audio rendition,expect the calls twice: once for studio representation, followed by once farmulti-channel representation. Another thing that might happen during theirdownload is your app may get backgrounded. Download tasks still run when yourapp is in background. When your app is relaunched, you need to restore yourexisting DownloadTask. You can do this by creating a URLSession with the sameconfiguration identifier you used previously. Then you can restore yourexisting task and then query the task to get the latest status of your downloads.

You can also get the original AVAsset from the downloadTkask and youuse it. So now you know how to create and monitor the download task.Let's see how you can play them. First let's take a look at where your downloadis deposited on the disk. In case of AVAssetDownloadTask, you get thelocation once the download is complete. And in case of aggregateDownloadTask,you get the location via willDownloadTo delegate callback.

We may want to store this location. We'll see that reason in a bit.Now let's see how we can play your download. Here is how we created a downloadtask earlier. For playback you to use the AVAsset to create your playbackitem. An advantage of using the same AVAsset is it allows AVFoundationto optimize resources between playback and download. This will be usefulin cases where the playback happens before the download is complete.We call this scenario as play while download is in progress. Any media resourcesfetch during playback will be stored to the disk and will not be refreshedagain for the download. Another scenario you may encounter is your useris trying to play along after the download is complete. In that case youmay not have the original AVAsset or the downloadTask object lying around.

In such cases you can recreate an AVAsset using the file URL. This isthe same URL we saved earlier. Some of you may be wondering, Alright, I havean asset here probably with a bunch of audio and subtitled renditions,How can I find out what can be played offline? We have an interface calledAVAssetCache. We can obtain the AVAssetCache object from yourAVAsset. It tells you what can we play it offline. And also what mediaselections are playable offline. Now you know how to download and playmedia content while offline. Let's talk about how you can protect your contentusing FairPlay. FairPlay streaming for offline HLS was introduced back in 2016.

Some of you may already be using FairPlay Streaming for protecting yourstreaming content. You can do the same for offline HLS as well.If you're new to FairPlay streaming I would recommend you check out our earliertalk "AVContentKeySession Best Practices" from WWDC 2018. When streaming,you get your key from your key server as needed, but during offline playback.You may not be able to reach your key server. Instead you create somethingcalled as offline key during the download and store it for later use.Let's see how we can get to this offline key. You need AVContentKeySession tostart with. Then, initiate key loading as you normally do for the streaming case.

If you do not know the key required for the download, don't worry.When you create the downloadTask you will also receive a key request from AVContentKeySession,If the key is already not loaded. Then you create a server playbackcontext, SPC for short, by providing your FairPlay streaming applicationcertificate. You call your key server and get back the key in the form of Content Key Context.CKC for short. And provide the CKC to AVContentKeySession. You can laterobtain offline key from it. We store there offline key for subsequent use.During offline playback, when you receive a key request you can reply backwith the offline key you created earlier. One thing to remember is FairPlay streaminglets your keyservers set an expiration date for offline keys. If the key expiresduring existing playback session, in order to have a good user experience.The session continues to the end rather than stop abruptly. Finally rememberto create a new offline key before expiration. In some cases you may wantto securely delete an offline key before it expires. For example whenthe user deletes the download. Since iOS 12 we can invalidate an offlinekey by providing it to AVContentKeySession. We can also invalidateall your offline keys by providing your FairPlay streaming application certificate.

AVContentKeySession also allows you to create offline keys for movie rentals.Typical rental scenario involves having 2 expiration dates. One which startswhen the user rents a movie, and the other one which starts when the userstarts playback. FairPlay Streaming supports this using dual expiry offlinekeys. For example, you can let your user watch a rental within 30 daysof purchase, but once they start watching they have to finish within 48 hours.

Again this is explained in more detail in "AVContentKeySession Best Practices"from WWDC 2018. There is one more thing you may find useful. Your app may beusing custom protocols for URL resources when streaming. What arecustom protocols for URLs? These are the URLs which begin with custom scheme.

For example URLs beginning with myscheme and URLs beginning with skd://.

These are the resources specific to your app and AVFoundation handlesthem using AVAssetResourceLoader for playlists, andAVContentKeySessionfor keys. If your app gets backgrounded immediately after the downloadstarts, you can still answer resource requests for custom protocols.Starting from iOS 14, you have 30 seconds to answer any resource requestsinvolving custom protocols. Moving on, let's talk a few things you can doto improve user experience. First let's talk about the download time.Users prefer downloads which complete faster but they also prefer downloads whichare of higher quality. You need to find the right balance. One best practicewe recommend is to allow your users an option to do fast download.This may be really helpful for those users who are downloading just before catchinga flight and finally; and another option for best quality download. For eitherof these options. You may want to restrict the type and quality of the contentyou want to download. You can do this by using various option on the downloadTask.

Firstly, we can restrict media rate using minimumRequiredMediaBitrateKey.For example, if we specify minimumRequiredMediaBitrateKey as five megabits,the bitrate really in just about five megabits would be chosen for downloads.

Starting from iOS 14, you can also restrict based on presentation sizeas well. Another quality restriction you can do is to download HDR presentationsare not. By default, the download task would prefer to download HDR presentationsif available. Lastly, you may want to restrict based on audio type. Again,by default AVFoundation downloads both stereo and multi-channel audiorenditions. Can opt out of multi-channel by setting prefersMultichanneloption key to false. Some of you may be wondering, why download both studioand multi-channel representations? We believe that the stereo renditionmixed at the studio better reflects artistic intent. For example the dialoguemay be given more prominence compared to other background noise. You maywant to experiment with these options and choose them appropriatelydepending on how your media library is authored. Moving on, let's talk about storage management.

Another best practice we recommend is you let the operating system managethe storage for your offline download. By doing so it allows operatingsystem to delete and reclaim storage when your app is not running.For example, during software updates operating system can automatically reclaimspace when the storage is running low. It also allows your users to deletemedia content through the settings app. Asset image and title you providewhen you create the download task will be displayed here. Now let's takea look at how you can opt into this. You start by getting a shared storage manager.

Then you create a new policy by providing a priority and expiration dateAssets would be purged, based on expiration date and then based on the priority.

Finally you set the policy on your downloaded content. Remember to keepthe downloaded content at the same system provided location and be preparedfor the assets to be deleted by the system. So that is offline HLS andwe are really excited for you to start using it. To wrap-up, we went overtwo different downloadTask using which you can download HLS. The first one is AVAssetDownloadTaskwhich uses automatic media selection to select media renditionsto download. And the second one is the aggregateDownloadTask which letsyou specify the audio and subtitle renditions you want to download.Finally we looked at how we can use FairPlay Streaming to protect your offline content,and learn some best practices on the way. To get you started, we have asample app which you can obtain from the resources below.

Thank you for joining and
enjoy the rest of WWDC.

2:52 -AVAssetDownloadTask

3:41 -Monitor AVAssetDownloadTask

4:10 -Monitoring example

4:55 -Choose media-selections

5:11 -AVAggregateAssetDownloadTask

6:31 -Monitor AVAggregateAssetDownloadTask

7:04 -Restore Tasks on App Launch

7:44 -Store the download location

8:05 -Instantiating Your AVAsset for Playback

8:56 -Create using file URL

9:16 -What can I play offline?

11:33 -Invalidate Offline Key

13:54 -Quality Selection

14:30 -Multichannel Audio Selection

15:51 -AVAssetDownloadStorageManager

## Code Samples

```swift
let
 hlsAsset 
=
 
AVURLAsset
(url: assetURL)


let
 backgroundConfiguration 
=
 
URLSessionConfiguration
.background(
    withIdentifier: 
"assetDownloadConfigurationIdentifier"
)

let
 assetURLSession 
=
 
AVAssetDownloadURLSession
(configuration: backgroundConfiguration,
    assetDownloadDelegate: 
self
, delegateQueue: 
OperationQueue
.main())


// Download a Movie at 2 mbps


let
 assetDownloadTask 
=
 assetURLSession.makeAssetDownloadTask(asset: hlsAsset,
    assetTitle: 
"My Movie"
, assetArtworkData: myAssetArtwork,
    options: [AVAssetDownloadTaskMinimumRequiredMediaBitrateKey: 
2000000
])
!

assetDownloadTask.resume()




// AVAssetDownloadTask uses automatic media selection
```

```swift
// Monitor AVAssetDownloadTask


public
 
protocol
 
AVAssetDownloadDelegate
: 
URLSessionTaskDelegate
 
{


	
// Use to monitor progress

	
func
 
urlSession
(
_
 
session
: 
URLSession
, 
assetDownloadTask
: 
AVAssetDownloadTask
,
		
didLoad
 
timeRange
: 
CMTimeRange
, 
totalTimeRangesLoaded
 
loadedTimeRanges
: [
NSValue
],
		
timeRangeExpectedToLoad
: 
CMTimeRange
)



	
// Listen for completion

	
func
 
urlSession
(
_
 
session
: 
URLSession
, 
task
: 
URLSessionTask
,
		
didCompleteWithError
 
error
: 
Error
?)


}
```

```swift
// Monitoring


MyAssetDownloadDelegate
: 
NSObject
, 
AVAssetDownloadDelegate
 {
    
func
 
urlSession
(
_
 
session
: 
URLSession
, 
assetDownloadTask
: 
AVAssetDownloadTask
,

didLoad
 
timeRange
: 
CMTimeRange
, 
totalTimeRangesLoaded
 
loadedTimeRanges
: [
NSValue
], 
timeRangeExpectedToLoad
: 
CMTimeRange
)
 {

		
// Convert loadedTimeRanges to CMTimeRanges

		
var
 percentComplete 
=
 
0.0

		
for
 value 
in
 loadedTimeRanges {
			
let
 loadedTimeRange: 
CMTimeRange
 
=
 value.timeRangeValue 
			percentComplete 
+=
 
CMTimeGetSeconds
(loadedTimeRange.duration) 
/

				
CMTimeGetSeconds
(timeRangeExpectedToLoad.duration)
		}
		percentComplete 
*=
 
100

		
print
(
"percent complete: 
\(percentComplete)
"
)
	}
}
```

```swift
let
 hlsAsset 
=
 
AVURLAsset
(url: assetURL)

let
 myMediaSelections 
=
 [] 
// audio media-selections followed by subtitle media-selections



guard
 hlsAsset.statusOfValue(forKey: 
"availableMediaCharacteristicsWithMediaSelectionOptions"
, error: 
nil
) 
   
==
 
AVKeyValueStatus
.loaded 
else
 { 
return
 }


let
 mediaCharacteristic 
=
 
//AVMediaCharacteristic.audible or AVMediaCharacteristic.legible


let
 mediaSelectionGroup 
=
 hlsAsset.mediaSelectionGroup(forMediaCharacteristic: mediaCharacteristic)

if
 
let
 options 
=
 mediaSelectionGroup
?
.options {
    
for
 option 
in
 options {
        
// chose your media selection option

        
if
 
/* this is my option */
 {
            
let
 mutableMediaSelection 
=
 hlsAsset.preferredMediaSelection.mutableCopy()
            mutableMediaSelection.select(option, in: mediaSelectionGroup)
            myMediaSelections.append(mutableMediaSelection)
        }
    }
}
```

```swift
let
 hlsAsset 
=
 
AVURLAsset
(url: assetURL)

let
 myMediaSelections 
=
 
...



let
 backgroundConfiguration 
=
 
URLSessionConfiguration
.background(
    withIdentifier: 
"assetDownloadConfigurationIdentifier"
)

let
 assetURLSession 
=
 
AVAssetDownloadURLSession
(configuration: backgroundConfiguration,
    assetDownloadDelegate: 
self
, delegateQueue: 
OperationQueue
.main())


// Download a Movie at 2 mbps


let
 aggDownloadTask 
=
 assetURLSession.aggregateAssetDownloadTask(with: hlsAsset,
    mediaSelections: myMediaSelections,
    assetTitle: 
"My Movie"
,
    assetArtworkData: myAssetArtwork,
    options:[AVAssetDownloadTaskMinimumRequiredMediaBitrateKey: 
2000000
])
!

aggDownloadTask.resume()
```

```swift
// Monitor AVAggregateAssetDownloadTask


public
 
protocol
 
AVAssetDownloadDelegate
: 
URLSessionTaskDelegate
 
{

	
// Use to monitor progress

	
func
 
urlSession
(
_
 
session
: 
URLSession
, 
		
aggregateAssetDownloadTask
: 
AVAggregateAssetDownloadTask
, 
		
didLoad
 
timeRange
: 
CMTimeRange
, 
totalTimeRangesLoaded
 
loadedTimeRanges
: [
NSValue
], 
		
timeRangeExpectedToLoad
: 
CMTimeRange
, 
		
for
 
mediaSelection
: 
AVMediaSelection

	)


	
// Listen for completion for each media selection

	
func
 
urlSession
(
_
 
session
: 
URLSession
, 
		
aggregateAssetDownloadTask
: 
AVAggregateAssetDownloadTask
, 
		
didCompleteFor
 
mediaSelection
: 
AVMediaSelection
)


    
// In case of audio rendition, expect calls once for stereo followed by once for multichannel rep.

}
```

```swift
// Restore Tasks on App Launch


class
 
MyAppDelegate
: 
UIResponder
, 
UIApplicationDelegate
 
{
	
func
 
application
(
_
 
application
: 
UIApplication
, 
			
didFinishLaunchingWithOptions
 
launchOptions
: [
UIApplication
.
LaunchOptionsKey
: 
Any
]
?
)
 -> 
Bool
 {
		
let
 configuration 
=
 
URLSessionConfiguration
.background(withIdentifier:
			
"assetDownloadConfigurationIdentifier"
)
		
let
 session 
=
 
URLSession
(configuration: configuration) 
		session.getAllTasks { tasks 
in

			
for
 task 
in
 tasks {
				
if
 
let
 assetDownloadTask 
=
 task 
as?
 
AVAssetDownloadTask
 {
					
// restore progress indicators, state, etc...

				} 
			}
		}
	}
}
```

```swift
// Store the download location


public
 
protocol
 
AVAssetDownloadDelegate
: 
URLSessionTaskDelegate
 
{

	
// AVAssetDownloadTask

	
func
 
urlSession
(
_
 
session
: 
URLSession
, 
		
assetDownloadTask
: 
AVAssetDownloadTask
, 
		
didFinishDownloadingTo
 
location
: 
URL
)


	
// AVAggregateAssetDownloadTask

	
func
 
urlSession
(
_
 
session
: 
URLSession
, 
		
aggregateAssetDownloadTask
: 
AVAggregateAssetDownloadTask
, 
		
willDownloadTo
 
location
: 
URL
)


}
```

```swift
// Instantiating Your AVAsset for Playback



// 1) Create Asset for AVAssetDownloadTask


let
 networkURL 
=
 
URL
(string: 
"http://example.com/master.m3u8"
)
!


let
 asset 
=
 
AVURLAsset
(url: networkURL)

let
 task 
=
 assetDownloadSession.makeAssetDownloadTask(asset: asset, assetTitle: 
"My Movie"
,
assetArtworkData: 
nil
, options: 
nil
)



// 2) Re-use Asset for Playback, Even After Task Restoration at App Launch


let
 playerItem 
=
 
AVPlayerItem
(asset: task.urlAsset)



// Reusing asset, will allow AVFoundation to optimize resources between playback and download in cases where the playback happens before the download is complete.
```

```swift
// Create using file URL



let
 fileURL 
=
 
URL
(fileURLWithPath: 
self
.savedAssetDownloadLocation)

let
 asset 
=
 
AVURLAsset
(url: fileURL)


let
 playerItem 
=
 
AVPlayerItem
(asset: task.urlAsset)
```

```swift
// What can I play offline?



public
 
class
 
AVURLAsset
 
{

	
public
 
var
 assetCache: 
AVAssetCache
? { 
get
 }

}


public
 
class
 
AVAssetCache
 
{

	
public
 
var
 isPlayableOffline: 
Bool
 { 
get
 }

	
public
 
func
 
mediaSelectionOptions
(
in
 
mediaSelectionGroup
: 
AVMediaSelectionGroup
)

		-> [
AVMediaSelectionOption
]

}
```

```swift
// Invalidate Offline Key



public
 
class
 
AVContentKeySession
 
{

	
func
 
invalidatePersistableContentKey
(
_
 
persistableContentKeyData
: 
Data
, 
		
options
: [
AVContentKeySessionServerPlaybackContextOption
 : 
Any
]
?
 
=
 
nil
, 
		
completionHandler
 
handler
: 
@escaping
 (
Data
?, 
Error
?) -> 
Void
)



	
func
 
invalidateAllPersistableContentKeys
(
forApp
 
appIdentifier
: 
Data
, 
		
options
: [
AVContentKeySessionServerPlaybackContextOption
 : 
Any
]
?
 
=
 
nil
, 
		
completionHandler
 
handler
: 
@escaping
 (
Data
?, 
Error
?) -> 
Void
)



}
```

```swift
// Quality Selection



public
 
class
 
AVAssetDownloadTask
 
{

	
public
 
let
 
AVAssetDownloadTaskMinimumRequiredMediaBitrateKey
: 
String


	
//Starting in iOS 14


	
public
 
let
 
AVAssetDownloadTaskMinimumRequiredPresentationSizeKey
: 
String


	
public
 
let
 
AVAssetDownloadTaskPrefersHDRKey
: 
String


}
```

```swift
// Multichannel Audio Selection



public
 
class
 
AVAssetDownloadTask
 
{

	
public
 
let
 
AVAssetDownloadTaskPrefersMultichannelKey
: 
String


}
```

```swift
// AVAssetDownloadStorageManager 


// Get the singleton 


let
 storageManager 
=
 
AVAssetDownloadStorageManager
.shared()
 

// Create the policy 


let
 newPolicy 
=
 
AVMutableAssetDownloadStorageManagementPolicy
() 

newPolicy.expirationDate 
=
 myExpiryDate

newPolicy.priority 
=
 .important 


// Set the policy

storageManager.setStorageManagementPolicy(newPolicy, forURL: myDownloadStorageURL)
```


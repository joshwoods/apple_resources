# Wwdc2020 10214

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Port your Mac app to Apple siliconYour porting questions, answered: Learn how to recompile your macOS app for Apple silicon Macs and build universal apps that launch faster, have better performance, and support the future of the platform. We'll show you how Xcode makes it simple to build a universal macOS binary and go through running, debugging, and testing your app. Learn what changes to low-level code you might need to make, find out how to handle in-process and out-of-process plug-ins, and discover some useful tips for working with universal apps.

We've designed this session for experienced macOS developers who want to get their existing apps running natively on Apple silicon Macs. You can learn more about doing so in the Apple silicon documentation.

For more information on the transition to Apple silicon, watch "Explore the new system architecture of Apple silicon Macs", "Bring your Metal app to Apple silicon Macs", and "Optimize Metal Performance for Apple silicon Macs". And to learn how to run your iPhone and iPad apps on Mac, check out "iPad and iPhone apps on Apple silicon Macs".ResourcesLearn more about Apple SiliconHD VideoSD VideoRelated VideosWWDC20Bring your Metal app to Apple silicon MacsExplore the new system architecture of Apple silicon MacsiPad and iPhone apps on Apple silicon MacsOptimize Metal Performance for Apple silicon MacsWWDC19All About NotarizationWWDC18Understanding Crashes and Crash Logs

Your porting questions, answered: Learn how to recompile your macOS app for Apple silicon Macs and build universal apps that launch faster, have better performance, and support the future of the platform. We'll show you how Xcode makes it simple to build a universal macOS binary and go through running, debugging, and testing your app. Learn what changes to low-level code you might need to make, find out how to handle in-process and out-of-process plug-ins, and discover some useful tips for working with universal apps.

We've designed this session for experienced macOS developers who want to get their existing apps running natively on Apple silicon Macs. You can learn more about doing so in the Apple silicon documentation.

For more information on the transition to Apple silicon, watch "Explore the new system architecture of Apple silicon Macs", "Bring your Metal app to Apple silicon Macs", and "Optimize Metal Performance for Apple silicon Macs". And to learn how to run your iPhone and iPad apps on Mac, check out "iPad and iPhone apps on Apple silicon Macs".

Learn more about Apple Silicon

HD VideoSD Video

HD Video

SD Video

Bring your Metal app to Apple silicon Macs

Explore the new system architecture of Apple silicon Macs

iPad and iPhone apps on Apple silicon Macs

Optimize Metal Performance for Apple silicon Macs

All About Notarization

Understanding Crashes and Crash Logs

Search this video…Hello and welcome to WWDC.Hello and welcome to Port Your Mac App to Apple Silicon. My name is KubaMracek and I will be guiding you Mac app developers through the journeyof transitioning your apps to Apple Silicon. We will start with an overviewof what the transition means for you and your apps. Then we'll discussbuilding universal Mac apps and what problems you might hit there. I willshow running, debugging, and testing on Apple Silicon, and we will talkabout implications for plug-ins. Finally I will mention a few tips forworking with universal apps. So let's jump in. The Mac is transitioningto Apple Silicon. You're probably wondering what exactly that means foryou and your apps. Let's start with the basics. The native CPU architectureon Apple Silicon Macs is called arm64, which will sound familiarif you're developing for iOS. iOS devices use the same architecture.Apps can of course be built as native ARM code and run natively, but existingIntel apps continue to work on Apple Silicon Mac computers. The Rosettatranslation will seamlessly run them. arm64 is the primary topic fortoday, because that's the new CPU architecture that your apps will use,and not just your GUI code. All user space programs will now be using arm64as their CPU architecture. In this session we will cover how to useXcode 12 to compile all your code to arm64 to get it to run natively.So I have an Apple Silicon Mac here, and I'm going to launch Xcodeand open an existing project called Solar System. Let's focus on this areahere in the toolbar that contains the active run destination. It says MyMac, but if I open it it reveals more options. I can choose to run underRosetta or to build a universal app for both Apple Silicon and Intel.Let's stick with building natively and let's just build and run the app.And there it is. Without any code changes or project setting tweaks, the appbuilds and runs natively with just a press of the Run button in Xcode.In Activity Monitor, I can verify the process type. So under Solar SystemMac, in the Kind column, it shows as Apple CPU architecture. That meansit does run natively. Xcode 12 handles the necessary project settingsfor you. You don't have to change build settings to select CPU architectures.And as we've just seen, for apps that don't have portability issues,building a native version is often as simple as clicking the Run button in Xcode.So I recommend you just go ahead and try that. If your app works and runscorrectly, your job is done. In case you do run into issues, I will be describingsome common pitfalls later in the session. We're also publishing an extensiveporting documentation at developer.apple.com/documentationand you can start with the page called Apple Silicon, and from thereyou can navigate to other articles that cover many of the topics from thissession in greater detail. The documentation is an excellent resource thatwill answer many of your porting questions. Let's discuss some basic conceptsaround Mac apps. Your apps, and basically all executable code, are storedin a file format called Mach-O. These files can either be targeting a singleCPU architecture — let's say 64-bit Intel — or they can be universal,that means support multiple CPU architectures. To examine a file on disk,you can use the lipo command, and I will be showing you how to do that later.Starting this year, Mac apps should be built and distributed as universalapps, built for both Apple Silicon and 64-bit Intel CPU architectures.If you have any existing Intel only apps, or if for some reason you can'tstart building your app natively right away, Apple Silicon computers haveRosetta, a translation environment that can seamlessly run these. In Rosetta,the entire process is always translated. You cannot load native code intoa translated process or vice versa. You also cannot use Rosetta for kernel extensions,AVX vector instructions, or virtualization. Xcode fully supports buildingand running apps for Rosetta. Let's look at how that works. As we've noticedbefore, the run destination in Xcode allows you to target Rosetta.Pressing Run will build the code for Intel and then run it in Rosetta. In Activity Monitor,the app now shows as Intel CPU. So it is running in translation. Allaspects of development from Xcode, including testing, debugging, and profilingare supported, and it's all translated on the fly. So if you perhaps happento use the debugger to look at individual CPU instructions, you'll noticethat they are Intel instructions. Don't be surprised by that. They're allbeing transparently translated by Rosetta. Let's now focus on getting yourapps ported over to run natively on Apple Silicon Mac computers.And the first step here is building your apps as universal. Let me start byexplaining why I think building your apps for Apple Silicon is actuallygoing to be a very easy task. First of all, the endianness of arm64 isthe same as x86. So if you remember the PowerPC to Intel transition,you will not have to deal with any byte order swapping problems this time.Second, if you have any shared code with iOS apps, that code is almost certainlyalready fully ported to arm64, because iOS uses the same CPU architectureas Apple Silicon Mac computers. And third, you can use any Mac that youalready have to build apps as universal. Xcode 12, the SDK, and theentire toolchain fully support cross compilation. That is, it's able to producecode for a different architecture than the one you're using Xcode on.I'm going to demonstrate some possible porting issues on this little utility appI've been working on called Network Benchmarking. I have a copy of thisapp from last year, so it's Intel only, and we can see that in the Infodialog in Finder, it shows as "Application (Intel)". But as you can see, I can stillrun it, and it will run under Rosetta. The app lets me create a TCP serverand a client, and I can start a benchmark, and while it's going it's measuringthe data throughput. The app is also showing a bunch of system informationlike the current CPU and memory usage. And that's pretty much all it does.Now let's actually open this app in Xcode 12, and let's start bringingit over to be a native app. Let me briefly describe the overall structureof this project. It has a few targets inside, like this first one whichis the actual GUI of the app. And it's mostly high level AppKit code,so I have things like an app delegate and a view controller, etc. But thenI also have a few more low level components, like this TimeTools package andsome networking libraries, and I even include a plug-in. Generally you shouldexpect that the high level AppKit code shouldn't have any portability problems.But for the more low level parts, we might need to make some fixes. So let'sstart building. Step one is to verify that the app still builds correctlyfor Intel with Xcode 12. So let me select "My Mac (Rosetta)" as the rundestination, and hit Build. In my case the app will build fine.Generally this shouldn't produce any errors, but there is one case I wanted to point out.Native page size is different between Intel machines and Apple Silicon systems.If you use the PAGE_SIZE macro, it's no longer a compile time constant,so you might see a build failure because of that. The fix is very easy:either use PAGE_MAX_SIZE for a compile time upper bound, or vm_page_sizeto read the value at runtime dynamically. Also note that Rosetta will befully matching the Intel environment: the CPU on Apple Silicon Macs willsupport 4 kB pages for translated processes. Now onto step two.Switch to build for the native architecture, and let's resolve errors.In Xcode, I will open the run destination menu again, and select "My Mac", andperform another build. This time I do get a compile time error. Let's lookat it. It looks like that there's something wrong with this function calledGetDefaultTimerClass which is using preprocessor macros — these #iflines — to switch behavior between different platforms. This is a prettycommon pattern. It's called target conditionals. But it looks like I'vemade a mistake when I wrote this code. For this branch here, I wanted totarget macOS and simulators, but instead my condition says __x86_64__ — that is, IntelCPUs — which used to be OK but it's no longer correct. The right way touse target conditionals here is to express them in the right terms. If Iwant to target macOS and simulators, I should use TARGET_OS_OSX orTARGET_OS_SIMULATOR. This problem is pretty common even in portable code.You should use the semantic target conditionals based on what you actuallywant to express. Here's a table with some common target conditionals.When you want to conditionally compile code for the Mac, use TARGET_OS_OSXor #if os(macOS) in Swift code. Don't assume a CPU architectureimplies the platform.When you want to conditionally compile code for Intel, use TARGET_CPU_X86_64or #if arch(x86_64) in Swift. And similarly for the other cases.Don't assume that a platform or running in the simulator uses a specific CPU architecture.Related to this is any usage of CPU specific code and assembly, eitherinline in your Objective-C code or standalone assembly files. All suchcode needs to be properly guarded with #ifs and the right targetconditionals I just mentioned. If you only have Intel implementations forsome functions like this, you will need to provide a second implementationfor Apple Silicon. However in a lot of cases you can just rely on OSprovided functionality instead. Use the Accelerate and Compression frameworksfor high-performance optimized implementations of math functions and compression algorithms.Now that the code is fixed, let's build it again.This time I received a different build time issue. It's not a bug in anyof the source code that I wrote, because the error message doesn't actuallypoint to any source file. And if I click it, it only takes me to the buildlog. This time it's the linker that's emitting the error. That leads usto step three: resolving link-time issues. The problem here is that my appfails to link. Let me switch to Errors Only, so we can focus on what thelinker is trying to tell me: "Undefined symbols for architecture arm64",and I see the symbol name, but it doesn't look familiar to me. This is nota symbol or class name from my code. The important part of the error messageis actually the yellow warning right above it. Let's look at it.The linker says, "ignoring file when building for macOS-arm64, but attemptingto link with file built for macOS-x86_64." What this error means is thatI'm depending on a binary framework that's not universal. This output alsoprovides details. It mentions the offending framework name, and it printsthe symbol name — in this case it's an Objective-C class name — and alsothe referencing object file. In my app, it's the AppDelegate file that usesthis class. This is useful to know because you might want to try to removethe dependency to make progress. So to do it in my app, I would go edit theAppDelegate source code. But again, in short, the problem here is that Ihave a pre-compiled binary framework in my project. Having pre-compiled binariesin your project will require some work. All static and dynamic librariesthat you depend on will need to first be built universal before you canactually build your app. You'll need to contact the vendors of those binariesand ask them to provide universal builds of them that contain both theIntel code and Apple Silicon code. Then you can replace your old binarieswith the universal ones, and the linker will be actually able to linkyour app. To make incremental progress, you can consider temporarily removingthat binary dependency, but don't forget to put it back once you have auniversal build of that library. What I also recommend doing right away is toscan your source code and do a search for anything that's not being builtfrom source code, but is pre-compiled by someone else. Typically that'sfiles and bundles with extensions of .a, .dylib, .framework, and.xcframework. And you can use the lipo -info command to inspectany binary and see whether it's already universal or not. So let's do thaton our demo project. I will open the project directory in Finder, and I willalso open Terminal.Then I will drag Sparkle.framework into Terminal to get its full filepath, and use the lipo -info command on the binary inside the framework.And once I run this command, lipo will say that it is really an Intel-only binary.So what I need to do is update the version of this framework with a newone that's universal. Here you would typically reach out to the vendorand ask for a new version or go to the vendor's web site and download auniversal binary if it's published already. But I have a new universalversion of this framework already. My teammate was actually able to provideit for me. Because the framework is open source, and building it universalwas literally just a matter of rebuilding with Xcode 12, we didnot hit any portability issues at all. Let me replace the old versionwith the new oneand let's inspect this new version of the framework.Indeed it is universal now. lipo says it's now a fat file that containsboth the x86_64 code as well as arm64 code. And if I build my app in Xcodeone more timethis time it will build successfully. Step 4. There is no step 4!I now have a native build of my app.In this example project, we've seen a few typical problems when buildinguniversal apps. Please see the documentation on the Apple Silicon pageon developer.apple.com which covers many of the porting problems thatwe've run into. If you prefer building on command line with xcodebuild,it's important to select the right destination for building. Use the-showdestinations option to get a list of available run destinations.And then you can use the -destination flag to select one. Here's twoexamples how to target either arm64 or x86_64. So let me just summarizethe steps that we went through to be able to build our app as a nativeapp. First, we verified that the app still builds correctly for Intel CPUs.Then we switched to build natively and we fixed code issues. This isthe case where the code itself was not correctly portable. And third, wefixed link-time issues, which are typically caused by having binary dependencies.And that's it. As a reminder, building universal apps works on any Mac. Youcan use your Intel Mac computer for that too. Now that we have our appbuilding, let's move on and talk about running and debugging your nativebuild of your app. I know what you're thinking: the app builds, so let'sship it right? Well, no. Your native app still definitely needs runtime testing.Don't assume that if the app builds that it's going to work flawlessly.For this part you will need an Apple Silicon Mac. Things like debugging,running unit tests, profiling, using sanitizers, all need to run nativecode, and that can only happen on Apple Silicon. Please plan to do fullruntime testing, validation, and profiling of both CPU architectures beforeyou ship your app. Let's do some runtime testing on our demo project.Now that the app builds I can finally run it natively. It seems to launch fine:the UI shows up, and the system information table seems to be accurate.Let's try to start the client server data transfer. Notice that there issome problem with the transfer statistics and the progress bar. It seemsto refresh with some wrong frequency. It's supposed to update every onehundred milliseconds, but instead the progress bar just makes these weirdlarge jumps. So let's look into this problem. Based on the benchmark values,I think the benchmark is actually running fine. It's just the UI that'snot refreshing fast enough. So let me set a breakpoint into my view controllerinto a method called updateClientProgressUI and let's run the benchmark again.We will eventually hit this breakpoint, but notice that it takes a while —more than a couple of seconds. So I think that there is something wrongwith the timer that's calling this method. Let's look a few stack framesbelow, where I have an implementation of this custom timer. And it seemsto be measuring a monotonic timestamp using an API called mach_absolute_time.So I think that's the source of the problem: whoever wrote this code assumedthat mach_absolute_time is always returning values in nanoseconds.That's why the code right below it is dividing by a thousand three times to convertit into seconds. However that's not correct. I can option-click the APIto peek into the documentation for it, and it says that it returns valuesin tick units.So, assuming these tick units are one nanosecond is incorrect. The time basefor this API is different on different CPU architectures. Probably thebest solution here would be to just avoid writing custom timers usinglow level APIs. Foundation and GCD have implementations of timers thatoften work better.But if you really need to use timestamps to measure time we can eitherquery the time base dynamically or switch to another API. There's a variantof the clock_gettime API that always returns the timestamp in nanoseconds.So let's use that in our demo. The documentation pop-up conveniently mentionsthis other API, so I can copy it right from here.And let's run the app one more time and let me also disable the breakpointI've put in earlier. This time if I run the benchmark, the progress barwill update fluently. This problem is actually quite common, and the typicaleffect of this bug is that something is running roughly 40 times sloweror an event is occurring 40 times less often than it should. If you observesomething like this, search your code base for mach_absolute_time. The bestway to test software is of course with automation. In this project, I havemost of the code covered with unit tests, so let's run them.Luckily all my unit tests are passing. But notice that the entire testsuite only ran once. In this case, in the run destination menu, I have thenative mode selected. So all my tests and the code under test were runin native mode. If I want to run the tests as Intel code under Rosetta, Ihave to switch the run destination and rerun my tests.In my project they all appear to pass for both architectures. But if yousee a test failing only under one of the two destinations, that again indicatessome non-portable code. Similarly to building on the command line, when testingwith xcodebuild, think about the destination that your tests are using.If you want to run your tests as native, specify arch=arm64 insidethe -destination flag. This also is the default, so if you don't useany destination, your tests will run as native code. To run your tests asIntel code under Rosetta, use arch=x86_64. You might also want toset up your CI systems to run tests in both these modes to catch any non-portablecode causing test failures. Let's look at one particular test that I havebecause it's a performance benchmark. I'll select the native destination againand run the test,which is just measuring how long it takes to transfer 10 megabytes of datafrom a local server.The result is that it takes 21 milliseconds. If I switch to Rosetta,and run the test again, we'll get a different result.This time it takes 29 milliseconds, which is slower than native,but the translated code still performs very well and the result is veryclose to native execution.When profiling and benchmarking on Apple Silicon Mac computers, nativecode generally has the best performance, and you should aim at optimizingnative execution. If you see a performance degradation in native mode,watch out for any Intel-specific code optimizations that you might have,for example optimized assembly using SSE or AVX. To achieve best performance,you might need to provide a matching implementation for Apple Siliconusing the ARM instruction set. But in general, you should try using Appleprovided APIs whenever possible, like Accelerate.framework, becausethose will provide high-performance implementations for all supported CPUs.Apple Silicon Macs use asymmetric CPU cores and that might have effecton your high-performance code. There's two types of CPU cores: high-performance,also called P cores, and energy-efficient, called E cores. All of them canbe active at the same time for maximum performance on parallel workloads.In Instruments, this distinction is visible in the CPUs view of the timeline.The individual CPU cores in the list have labels telling you whichones are efficient and which ones are performance cores. Don't be surprisedif you see a graph like this where almost all the work is scheduled onlyon the P cores or only on the E cores. The system is dynamically choosingthe best way to perform work to make the right performance and batterylife tradeoff. One important pattern to avoid on asymmetric CPU systemsis using spinlocks and busy-waiting code. In this example the first functionis using a spinlock and the second example is busy-waiting. That meansactively spending CPU time to check in a loop whether a new job is availablein a queue. This is something that's generally wrong to do on any computersystem. A much better alternative for the first function is to use someblocking type of lock — for example, os_unfair_lock — and instead of checkinga condition in a spinning loop, use condition variables, which will blockuntil the condition is met. On Apple Silicon Macs, busy-waiting can havethe effect of pointlessly occupying the P cores, causing an overall delayin completion of the entire work. You should prefer a synchronization primitivesthat block when they can't make progress, NSLock, os_unfair_lock, pthread mutexes,are all examples of blocking locks. NSCondition and pthreadcondition variables provide a way to wait until a specific condition occurs.In general, use GCD when possible, and avoid splitting your work basedon number of available CPUs. Instead, prefer splitting tasks intosmaller sized units. For details about GCD, please watch a video fromWWDC 2017. And if you're using threading for audio processing, the MeetAudio Workgroups session from this year will help you fine-tune youraudio apps and plug-ins. So when you're debugging, testing, and profilingyour app, remember that you can build on any Mac, but running native arm64code needs an Apple Silicon Mac. When running your tests, try to runthem under both native and translated modes to discover non-portable codein your tests. And watch out for any Intel-specific code optimizationsand any code that is using busy-waiting instead of blocking. The next topicI'd like to talk about is plug-ins, because these need some special considerationson Apple Silicon computers. Plug-ins are a way to dynamically load and executecode. Using plug-ins that just implement standard system extension pointsvia NSExtension is going to just work: both native and translated plug-insare supported. However, if your app is a plug-in host, and if it's using acustom plug-in loading mechanism, you will need to consider how plug-ins workon Apple Silicon Macs. Your app's process at runtime will contain the code thatyou wrote and also code from system frameworks. If your app supportsplug-ins, it will typically discover them at runtime and then load them when needed.That's called an in-process plug-in model, and typically the app uses a callto dlopen or Bundle.load for this.Alternatively, the plug-ins can be spawned as new processes, and we call thoseout-of-process plug-ins. The app and the plug-in process then use someinterprocess communication mechanism like XPC. Loading another plug-intypically spawns another process. While out-of-process plug-ins generallyprovide better security and stability, in-process plug-ins are still very common.If your app is using in-process plug-ins, you need to consider that on macOSon Apple Silicon, all code in one process must always have the sameCPU architecture. Let's look at typical use cases for plug-ins. As I'vementioned, there's out-of-process and in-process plug-ins. What's alsoimportant is whether the plug-in is first party, which means you are buildingit from source code and ship it inside your app, or whether it's a thirdparty plug-in that some other software vendor distributes in pre-compiledbinary form. If your plug-ins are first party and you can rebuild them, makesure to build them as universal plug-ins, and everything will work. For thirdparty plug-ins using the out-of-process plug-in model, you can make somesmall changes in your loading code to support both CPU architectures.If you make sure to load the plug-in executable as the right CPU architecture,your app will be able to load both native and translated plug-ins.In-process third party plug-ins have some restrictions. Native apps can only loadnative plug-ins and Rosetta translated apps can only load Intel-based plug-ins.If your plug-in vendor hasn't updated the plug-in to be universal,it might affect your users. Let's look at what happens if we have a plug-inCPU mismatch. In my network benchmarking app, I am using a plug-in toimplement TLS support. And it gets loaded the first time I switch to theTLS mode, so let me do that. The plug-in loading fails, so let's inspectthe console. The dynamic linker explains what happened. We tried to usedlopen to load a plug-in with this name, and the file was found on disk,but it has a wrong CPU architecture. Let's verify this. I'll copy thefull path of this file and open Terminal, and I will paste the path intoTerminal and use lipo -info again. And indeed this binary is Intel only.Now if this was a third party precompiled plug-in, the right solution wouldbe to contact that third party and urge them to publish a universal buildof the plug-in as soon as possible. But let's go back into Xcode becausein this case I do have the source code of this plug-in and I should be ableto rebuild it as universal.Let's go into my project, and let's open the TLS plug-in target, and let'sinspect its Build Settings. It looks like I have some unusual configuration here.I am forcing Architectures to always be x86_64. Now this is probably someleftover from when I wanted to drop 32-bit support, but hard-coding x86_64is incorrect now. We should instead be using Standard Architectures everywhere.But an even better option is just to avoid setting Architectures altogether.So I will just select the build setting and hit the Delete key. This wayXcode will use the correct default settings. Let's build and run theapp again, and this time if I switch to the TLS mode, the plug-in will getloaded correctly now. A typical pattern to load a plug-in is to use dlopenwith a file path. It is very important to always check the returnvalue from dlopen, and if it's NULL, the full error message explaining what iswrong is provided by calling dlerror. When running this code with amismatching plug-in CPU architecture, you will get an error explainingwhat file on disk has a wrong architecture. That indicates that theplug-in is not universal. I'd like to point out that the out-of-process plug-inmodel doesn't have this restriction. If you're using in-process plug-ins,I encourage you to explore XPC as a solution. You can have one processper plug-in, but also one process per CPU architecture. In this case, you'llonly ever use up to two extra processes. Out-of-process plug-ins providebetter stability and security for your app, and for details about XPCI recommend watching a WWDC session from 2013 called Efficient Designwith XPC. If your users are stuck with an Intel-only plug-in, they can stillforce the app to run in Rosetta, which will allow loading those plug-ins.For universal apps, the Info dialog in Finder has a checkbox called Openusing Rosetta to do that. This checkbox can be disallowed withan Info.plist key. Details are explained in the Apple Silicon documentation soplease refer to it if you'd like to know more. Let me finally share a few tipswhen working on apps that run on both Intel-based Macs and Apple Silicon Macs.Once your app is building, running, and it's tested and verified to workcorrectly on each architecture, you're going to start distributing yourapp, either on the App Store or perhaps by a download link on your website, in which case you'll need your entire software package to be notarized.Please watch a WWDC session from 2019 called All About Notarization for details.In Xcode, your distribution process starts with an archive build, whichnow by default produces universal apps. In Xcode, the Archiveaction is available in the Product menu. If your primary development workflowis to use only one type of Mac computer, doing an archive build might actuallybe the first time that your code builds universally. So if your debugiterations build fine, but your archive build fails, that indicates you havesome portability issues that we've covered earlier in the session.Once your archive build succeeds, you can find your package for distributionin the Organizer window of Xcode. In Xcode 12, it now shows whichCPU architectures are included in your archive builds. The Organizeralso provides access to crash statistics and individual crash logs fromyour users of your app. For details about crash logs and how to investigatethe root causes of crashes, please watch a video from WWDC 2018called Understanding Crashes and Crash Logs. With universal apps you shouldnow watch out that you'll be receiving three different kinds of crash logs:x86 crash logs from Intel Macs, native arm64 crash logs for Apple SiliconMacs, but also translated x86 crash logs when running under Rosetta on AppleSilicon Macs. If you select a particular crash log in the Organizer, theDetails section now shows what CPU architecture the crash originatedon and whether the process was running translated or not. If your app relieson a kernel extension, or if you provide drivers for hardware using DriverKit,there are some special considerations that you should understand whenporting these types of software. In particular, more types of kernel extensionsare now deprecated or disallowed on Apple Silicon Macs, and you'll haveto use DriverKit for those instead. Please refer to the macOS portingdocumentation for details. One more thing to watch out for is multithreading bugs.Intel CPUs and Apple Silicon implement a different memory ordering model.For correct multithreaded code, this doesn't matter. It will always run correctly.But bugs like race conditions and data races might have slightly differentbehavior on each of these architectures. Specifically, a data race on Intel CPUsmight have worked fine and appeared to be benign, but the same bug couldbe causing crashes on Apple Silicon instead. Note that running under Rosettafully supports the Intel memory ordering, so you will not see a differencein behavior there. Whether you do see crashes in multithreaded code ornot, I highly recommend using Thread Sanitizer as a tool to detect andprevent data races. We have presented this tool in WWDC session in 2016 called ThreadSanitizer and Static Analysis. You can enable Thread Sanitizer in the schemeeditor of your project. In the Diagnostics tab, you can find a checkboxcalled Thread Sanitizer. But remember this is a runtime tool. You have torun your app and exercise code at the run time to find bugs. So thisconcludes the tips that I had for working with universal apps. Let me nowwrap up the session and let's summarize what we have talked about today.Mac apps should from now on be built as universal apps, and you can startbringing them to Apple Silicon today. Scan your source code fornon-universal binaries. You will need to get them updated as universal to runyour app natively. Use Xcode 12 to build your app universal, identify and fixany portability issues you discover on the way, and don't forget to runand test the native build of your apps. Watch out for any of the platformdifferences that we have discussed today.Finally, I would like to remind you that developer.apple.com/documentationcontains many more details. The article called Apple Siliconprovides guidance and answers to questions you might have aboutporting your app. Thank you for watching.

Hello and welcome to WWDC.

Hello and welcome to Port Your Mac App to Apple Silicon. My name is KubaMracek and I will be guiding you Mac app developers through the journeyof transitioning your apps to Apple Silicon. We will start with an overviewof what the transition means for you and your apps. Then we'll discussbuilding universal Mac apps and what problems you might hit there. I willshow running, debugging, and testing on Apple Silicon, and we will talkabout implications for plug-ins. Finally I will mention a few tips forworking with universal apps. So let's jump in. The Mac is transitioningto Apple Silicon. You're probably wondering what exactly that means foryou and your apps. Let's start with the basics. The native CPU architectureon Apple Silicon Macs is called arm64, which will sound familiarif you're developing for iOS. iOS devices use the same architecture.

Apps can of course be built as native ARM code and run natively, but existingIntel apps continue to work on Apple Silicon Mac computers. The Rosettatranslation will seamlessly run them. arm64 is the primary topic fortoday, because that's the new CPU architecture that your apps will use,and not just your GUI code. All user space programs will now be using arm64as their CPU architecture. In this session we will cover how to useXcode 12 to compile all your code to arm64 to get it to run natively.So I have an Apple Silicon Mac here, and I'm going to launch Xcodeand open an existing project called Solar System. Let's focus on this areahere in the toolbar that contains the active run destination. It says MyMac, but if I open it it reveals more options. I can choose to run underRosetta or to build a universal app for both Apple Silicon and Intel.Let's stick with building natively and let's just build and run the app.And there it is. Without any code changes or project setting tweaks, the appbuilds and runs natively with just a press of the Run button in Xcode.In Activity Monitor, I can verify the process type. So under Solar SystemMac, in the Kind column, it shows as Apple CPU architecture. That meansit does run natively. Xcode 12 handles the necessary project settingsfor you. You don't have to change build settings to select CPU architectures.And as we've just seen, for apps that don't have portability issues,building a native version is often as simple as clicking the Run button in Xcode.So I recommend you just go ahead and try that. If your app works and runscorrectly, your job is done. In case you do run into issues, I will be describingsome common pitfalls later in the session. We're also publishing an extensiveporting documentation at developer.apple.com/documentationand you can start with the page called Apple Silicon, and from thereyou can navigate to other articles that cover many of the topics from thissession in greater detail. The documentation is an excellent resource thatwill answer many of your porting questions. Let's discuss some basic conceptsaround Mac apps. Your apps, and basically all executable code, are storedin a file format called Mach-O. These files can either be targeting a singleCPU architecture — let's say 64-bit Intel — or they can be universal,that means support multiple CPU architectures. To examine a file on disk,you can use the lipo command, and I will be showing you how to do that later.Starting this year, Mac apps should be built and distributed as universalapps, built for both Apple Silicon and 64-bit Intel CPU architectures.

If you have any existing Intel only apps, or if for some reason you can'tstart building your app natively right away, Apple Silicon computers haveRosetta, a translation environment that can seamlessly run these. In Rosetta,the entire process is always translated. You cannot load native code intoa translated process or vice versa. You also cannot use Rosetta for kernel extensions,AVX vector instructions, or virtualization. Xcode fully supports buildingand running apps for Rosetta. Let's look at how that works. As we've noticedbefore, the run destination in Xcode allows you to target Rosetta.Pressing Run will build the code for Intel and then run it in Rosetta. In Activity Monitor,the app now shows as Intel CPU. So it is running in translation. Allaspects of development from Xcode, including testing, debugging, and profilingare supported, and it's all translated on the fly. So if you perhaps happento use the debugger to look at individual CPU instructions, you'll noticethat they are Intel instructions. Don't be surprised by that. They're allbeing transparently translated by Rosetta. Let's now focus on getting yourapps ported over to run natively on Apple Silicon Mac computers.And the first step here is building your apps as universal. Let me start byexplaining why I think building your apps for Apple Silicon is actuallygoing to be a very easy task. First of all, the endianness of arm64 isthe same as x86. So if you remember the PowerPC to Intel transition,you will not have to deal with any byte order swapping problems this time.

Second, if you have any shared code with iOS apps, that code is almost certainlyalready fully ported to arm64, because iOS uses the same CPU architectureas Apple Silicon Mac computers. And third, you can use any Mac that youalready have to build apps as universal. Xcode 12, the SDK, and theentire toolchain fully support cross compilation. That is, it's able to producecode for a different architecture than the one you're using Xcode on.

I'm going to demonstrate some possible porting issues on this little utility appI've been working on called Network Benchmarking. I have a copy of thisapp from last year, so it's Intel only, and we can see that in the Infodialog in Finder, it shows as "Application (Intel)". But as you can see, I can stillrun it, and it will run under Rosetta. The app lets me create a TCP serverand a client, and I can start a benchmark, and while it's going it's measuringthe data throughput. The app is also showing a bunch of system informationlike the current CPU and memory usage. And that's pretty much all it does.

Now let's actually open this app in Xcode 12, and let's start bringingit over to be a native app. Let me briefly describe the overall structureof this project. It has a few targets inside, like this first one whichis the actual GUI of the app. And it's mostly high level AppKit code,so I have things like an app delegate and a view controller, etc. But thenI also have a few more low level components, like this TimeTools package andsome networking libraries, and I even include a plug-in. Generally you shouldexpect that the high level AppKit code shouldn't have any portability problems.But for the more low level parts, we might need to make some fixes. So let'sstart building. Step one is to verify that the app still builds correctlyfor Intel with Xcode 12. So let me select "My Mac (Rosetta)" as the rundestination, and hit Build. In my case the app will build fine.Generally this shouldn't produce any errors, but there is one case I wanted to point out.

Native page size is different between Intel machines and Apple Silicon systems.If you use the PAGE_SIZE macro, it's no longer a compile time constant,so you might see a build failure because of that. The fix is very easy:either use PAGE_MAX_SIZE for a compile time upper bound, or vm_page_sizeto read the value at runtime dynamically. Also note that Rosetta will befully matching the Intel environment: the CPU on Apple Silicon Macs willsupport 4 kB pages for translated processes. Now onto step two.Switch to build for the native architecture, and let's resolve errors.In Xcode, I will open the run destination menu again, and select "My Mac", andperform another build. This time I do get a compile time error. Let's lookat it. It looks like that there's something wrong with this function calledGetDefaultTimerClass which is using preprocessor macros — these #iflines — to switch behavior between different platforms. This is a prettycommon pattern. It's called target conditionals. But it looks like I'vemade a mistake when I wrote this code. For this branch here, I wanted totarget macOS and simulators, but instead my condition says __x86_64__ — that is, IntelCPUs — which used to be OK but it's no longer correct. The right way touse target conditionals here is to express them in the right terms. If Iwant to target macOS and simulators, I should use TARGET_OS_OSX orTARGET_OS_SIMULATOR. This problem is pretty common even in portable code.You should use the semantic target conditionals based on what you actuallywant to express. Here's a table with some common target conditionals.When you want to conditionally compile code for the Mac, use TARGET_OS_OSXor #if os(macOS) in Swift code. Don't assume a CPU architectureimplies the platform.

When you want to conditionally compile code for Intel, use TARGET_CPU_X86_64or #if arch(x86_64) in Swift. And similarly for the other cases.Don't assume that a platform or running in the simulator uses a specific CPU architecture.

Related to this is any usage of CPU specific code and assembly, eitherinline in your Objective-C code or standalone assembly files. All suchcode needs to be properly guarded with #ifs and the right targetconditionals I just mentioned. If you only have Intel implementations forsome functions like this, you will need to provide a second implementationfor Apple Silicon. However in a lot of cases you can just rely on OSprovided functionality instead. Use the Accelerate and Compression frameworksfor high-performance optimized implementations of math functions and compression algorithms.

Now that the code is fixed, let's build it again.

This time I received a different build time issue. It's not a bug in anyof the source code that I wrote, because the error message doesn't actuallypoint to any source file. And if I click it, it only takes me to the buildlog. This time it's the linker that's emitting the error. That leads usto step three: resolving link-time issues. The problem here is that my appfails to link. Let me switch to Errors Only, so we can focus on what thelinker is trying to tell me: "Undefined symbols for architecture arm64",and I see the symbol name, but it doesn't look familiar to me. This is nota symbol or class name from my code. The important part of the error messageis actually the yellow warning right above it. Let's look at it.

The linker says, "ignoring file when building for macOS-arm64, but attemptingto link with file built for macOS-x86_64." What this error means is thatI'm depending on a binary framework that's not universal. This output alsoprovides details. It mentions the offending framework name, and it printsthe symbol name — in this case it's an Objective-C class name — and alsothe referencing object file. In my app, it's the AppDelegate file that usesthis class. This is useful to know because you might want to try to removethe dependency to make progress. So to do it in my app, I would go edit theAppDelegate source code. But again, in short, the problem here is that Ihave a pre-compiled binary framework in my project. Having pre-compiled binariesin your project will require some work. All static and dynamic librariesthat you depend on will need to first be built universal before you canactually build your app. You'll need to contact the vendors of those binariesand ask them to provide universal builds of them that contain both theIntel code and Apple Silicon code. Then you can replace your old binarieswith the universal ones, and the linker will be actually able to linkyour app. To make incremental progress, you can consider temporarily removingthat binary dependency, but don't forget to put it back once you have auniversal build of that library. What I also recommend doing right away is toscan your source code and do a search for anything that's not being builtfrom source code, but is pre-compiled by someone else. Typically that'sfiles and bundles with extensions of .a, .dylib, .framework, and.xcframework. And you can use the lipo -info command to inspectany binary and see whether it's already universal or not. So let's do thaton our demo project. I will open the project directory in Finder, and I willalso open Terminal.

Then I will drag Sparkle.framework into Terminal to get its full filepath, and use the lipo -info command on the binary inside the framework.

And once I run this command, lipo will say that it is really an Intel-only binary.

So what I need to do is update the version of this framework with a newone that's universal. Here you would typically reach out to the vendorand ask for a new version or go to the vendor's web site and download auniversal binary if it's published already. But I have a new universalversion of this framework already. My teammate was actually able to provideit for me. Because the framework is open source, and building it universalwas literally just a matter of rebuilding with Xcode 12, we didnot hit any portability issues at all. Let me replace the old versionwith the new oneand let's inspect this new version of the framework.

Indeed it is universal now. lipo says it's now a fat file that containsboth the x86_64 code as well as arm64 code. And if I build my app in Xcodeone more timethis time it will build successfully. Step 4. There is no step 4!I now have a native build of my app.

In this example project, we've seen a few typical problems when buildinguniversal apps. Please see the documentation on the Apple Silicon pageon developer.apple.com which covers many of the porting problems thatwe've run into. If you prefer building on command line with xcodebuild,it's important to select the right destination for building. Use the-showdestinations option to get a list of available run destinations.

And then you can use the -destination flag to select one. Here's twoexamples how to target either arm64 or x86_64. So let me just summarizethe steps that we went through to be able to build our app as a nativeapp. First, we verified that the app still builds correctly for Intel CPUs.Then we switched to build natively and we fixed code issues. This isthe case where the code itself was not correctly portable. And third, wefixed link-time issues, which are typically caused by having binary dependencies.

And that's it. As a reminder, building universal apps works on any Mac. Youcan use your Intel Mac computer for that too. Now that we have our appbuilding, let's move on and talk about running and debugging your nativebuild of your app. I know what you're thinking: the app builds, so let'sship it right? Well, no. Your native app still definitely needs runtime testing.Don't assume that if the app builds that it's going to work flawlessly.For this part you will need an Apple Silicon Mac. Things like debugging,running unit tests, profiling, using sanitizers, all need to run nativecode, and that can only happen on Apple Silicon. Please plan to do fullruntime testing, validation, and profiling of both CPU architectures beforeyou ship your app. Let's do some runtime testing on our demo project.Now that the app builds I can finally run it natively. It seems to launch fine:the UI shows up, and the system information table seems to be accurate.Let's try to start the client server data transfer. Notice that there issome problem with the transfer statistics and the progress bar. It seemsto refresh with some wrong frequency. It's supposed to update every onehundred milliseconds, but instead the progress bar just makes these weirdlarge jumps. So let's look into this problem. Based on the benchmark values,I think the benchmark is actually running fine. It's just the UI that'snot refreshing fast enough. So let me set a breakpoint into my view controllerinto a method called updateClientProgressUI and let's run the benchmark again.

We will eventually hit this breakpoint, but notice that it takes a while —more than a couple of seconds. So I think that there is something wrongwith the timer that's calling this method. Let's look a few stack framesbelow, where I have an implementation of this custom timer. And it seemsto be measuring a monotonic timestamp using an API called mach_absolute_time.So I think that's the source of the problem: whoever wrote this code assumedthat mach_absolute_time is always returning values in nanoseconds.That's why the code right below it is dividing by a thousand three times to convertit into seconds. However that's not correct. I can option-click the APIto peek into the documentation for it, and it says that it returns valuesin tick units.

So, assuming these tick units are one nanosecond is incorrect. The time basefor this API is different on different CPU architectures. Probably thebest solution here would be to just avoid writing custom timers usinglow level APIs. Foundation and GCD have implementations of timers thatoften work better.But if you really need to use timestamps to measure time we can eitherquery the time base dynamically or switch to another API. There's a variantof the clock_gettime API that always returns the timestamp in nanoseconds.So let's use that in our demo. The documentation pop-up conveniently mentionsthis other API, so I can copy it right from here.

And let's run the app one more time and let me also disable the breakpointI've put in earlier. This time if I run the benchmark, the progress barwill update fluently. This problem is actually quite common, and the typicaleffect of this bug is that something is running roughly 40 times sloweror an event is occurring 40 times less often than it should. If you observesomething like this, search your code base for mach_absolute_time. The bestway to test software is of course with automation. In this project, I havemost of the code covered with unit tests, so let's run them.

Luckily all my unit tests are passing. But notice that the entire testsuite only ran once. In this case, in the run destination menu, I have thenative mode selected. So all my tests and the code under test were runin native mode. If I want to run the tests as Intel code under Rosetta, Ihave to switch the run destination and rerun my tests.

In my project they all appear to pass for both architectures. But if yousee a test failing only under one of the two destinations, that again indicatessome non-portable code. Similarly to building on the command line, when testingwith xcodebuild, think about the destination that your tests are using.If you want to run your tests as native, specify arch=arm64 insidethe -destination flag. This also is the default, so if you don't useany destination, your tests will run as native code. To run your tests asIntel code under Rosetta, use arch=x86_64. You might also want toset up your CI systems to run tests in both these modes to catch any non-portablecode causing test failures. Let's look at one particular test that I havebecause it's a performance benchmark. I'll select the native destination againand run the test,which is just measuring how long it takes to transfer 10 megabytes of datafrom a local server.The result is that it takes 21 milliseconds. If I switch to Rosetta,and run the test again, we'll get a different result.

This time it takes 29 milliseconds, which is slower than native,but the translated code still performs very well and the result is veryclose to native execution.

When profiling and benchmarking on Apple Silicon Mac computers, nativecode generally has the best performance, and you should aim at optimizingnative execution. If you see a performance degradation in native mode,watch out for any Intel-specific code optimizations that you might have,for example optimized assembly using SSE or AVX. To achieve best performance,you might need to provide a matching implementation for Apple Siliconusing the ARM instruction set. But in general, you should try using Appleprovided APIs whenever possible, like Accelerate.framework, becausethose will provide high-performance implementations for all supported CPUs.Apple Silicon Macs use asymmetric CPU cores and that might have effecton your high-performance code. There's two types of CPU cores: high-performance,also called P cores, and energy-efficient, called E cores. All of them canbe active at the same time for maximum performance on parallel workloads.

In Instruments, this distinction is visible in the CPUs view of the timeline.The individual CPU cores in the list have labels telling you whichones are efficient and which ones are performance cores. Don't be surprisedif you see a graph like this where almost all the work is scheduled onlyon the P cores or only on the E cores. The system is dynamically choosingthe best way to perform work to make the right performance and batterylife tradeoff. One important pattern to avoid on asymmetric CPU systemsis using spinlocks and busy-waiting code. In this example the first functionis using a spinlock and the second example is busy-waiting. That meansactively spending CPU time to check in a loop whether a new job is availablein a queue. This is something that's generally wrong to do on any computersystem. A much better alternative for the first function is to use someblocking type of lock — for example, os_unfair_lock — and instead of checkinga condition in a spinning loop, use condition variables, which will blockuntil the condition is met. On Apple Silicon Macs, busy-waiting can havethe effect of pointlessly occupying the P cores, causing an overall delayin completion of the entire work. You should prefer a synchronization primitivesthat block when they can't make progress, NSLock, os_unfair_lock, pthread mutexes,are all examples of blocking locks. NSCondition and pthreadcondition variables provide a way to wait until a specific condition occurs.

In general, use GCD when possible, and avoid splitting your work basedon number of available CPUs. Instead, prefer splitting tasks intosmaller sized units. For details about GCD, please watch a video fromWWDC 2017. And if you're using threading for audio processing, the MeetAudio Workgroups session from this year will help you fine-tune youraudio apps and plug-ins. So when you're debugging, testing, and profilingyour app, remember that you can build on any Mac, but running native arm64code needs an Apple Silicon Mac. When running your tests, try to runthem under both native and translated modes to discover non-portable codein your tests. And watch out for any Intel-specific code optimizationsand any code that is using busy-waiting instead of blocking. The next topicI'd like to talk about is plug-ins, because these need some special considerationson Apple Silicon computers. Plug-ins are a way to dynamically load and executecode. Using plug-ins that just implement standard system extension pointsvia NSExtension is going to just work: both native and translated plug-insare supported. However, if your app is a plug-in host, and if it's using acustom plug-in loading mechanism, you will need to consider how plug-ins workon Apple Silicon Macs. Your app's process at runtime will contain the code thatyou wrote and also code from system frameworks. If your app supportsplug-ins, it will typically discover them at runtime and then load them when needed.That's called an in-process plug-in model, and typically the app uses a callto dlopen or Bundle.load for this.

Alternatively, the plug-ins can be spawned as new processes, and we call thoseout-of-process plug-ins. The app and the plug-in process then use someinterprocess communication mechanism like XPC. Loading another plug-intypically spawns another process. While out-of-process plug-ins generallyprovide better security and stability, in-process plug-ins are still very common.If your app is using in-process plug-ins, you need to consider that on macOSon Apple Silicon, all code in one process must always have the sameCPU architecture. Let's look at typical use cases for plug-ins. As I'vementioned, there's out-of-process and in-process plug-ins. What's alsoimportant is whether the plug-in is first party, which means you are buildingit from source code and ship it inside your app, or whether it's a thirdparty plug-in that some other software vendor distributes in pre-compiledbinary form. If your plug-ins are first party and you can rebuild them, makesure to build them as universal plug-ins, and everything will work. For thirdparty plug-ins using the out-of-process plug-in model, you can make somesmall changes in your loading code to support both CPU architectures.If you make sure to load the plug-in executable as the right CPU architecture,your app will be able to load both native and translated plug-ins.In-process third party plug-ins have some restrictions. Native apps can only loadnative plug-ins and Rosetta translated apps can only load Intel-based plug-ins.

If your plug-in vendor hasn't updated the plug-in to be universal,it might affect your users. Let's look at what happens if we have a plug-inCPU mismatch. In my network benchmarking app, I am using a plug-in toimplement TLS support. And it gets loaded the first time I switch to theTLS mode, so let me do that. The plug-in loading fails, so let's inspectthe console. The dynamic linker explains what happened. We tried to usedlopen to load a plug-in with this name, and the file was found on disk,but it has a wrong CPU architecture. Let's verify this. I'll copy thefull path of this file and open Terminal, and I will paste the path intoTerminal and use lipo -info again. And indeed this binary is Intel only.

Now if this was a third party precompiled plug-in, the right solution wouldbe to contact that third party and urge them to publish a universal buildof the plug-in as soon as possible. But let's go back into Xcode becausein this case I do have the source code of this plug-in and I should be ableto rebuild it as universal.Let's go into my project, and let's open the TLS plug-in target, and let'sinspect its Build Settings. It looks like I have some unusual configuration here.I am forcing Architectures to always be x86_64. Now this is probably someleftover from when I wanted to drop 32-bit support, but hard-coding x86_64is incorrect now. We should instead be using Standard Architectures everywhere.But an even better option is just to avoid setting Architectures altogether.So I will just select the build setting and hit the Delete key. This wayXcode will use the correct default settings. Let's build and run theapp again, and this time if I switch to the TLS mode, the plug-in will getloaded correctly now. A typical pattern to load a plug-in is to use dlopenwith a file path. It is very important to always check the returnvalue from dlopen, and if it's NULL, the full error message explaining what iswrong is provided by calling dlerror. When running this code with amismatching plug-in CPU architecture, you will get an error explainingwhat file on disk has a wrong architecture. That indicates that theplug-in is not universal. I'd like to point out that the out-of-process plug-inmodel doesn't have this restriction. If you're using in-process plug-ins,I encourage you to explore XPC as a solution. You can have one processper plug-in, but also one process per CPU architecture. In this case, you'llonly ever use up to two extra processes. Out-of-process plug-ins providebetter stability and security for your app, and for details about XPCI recommend watching a WWDC session from 2013 called Efficient Designwith XPC. If your users are stuck with an Intel-only plug-in, they can stillforce the app to run in Rosetta, which will allow loading those plug-ins.For universal apps, the Info dialog in Finder has a checkbox called Openusing Rosetta to do that. This checkbox can be disallowed withan Info.plist key. Details are explained in the Apple Silicon documentation soplease refer to it if you'd like to know more. Let me finally share a few tipswhen working on apps that run on both Intel-based Macs and Apple Silicon Macs.Once your app is building, running, and it's tested and verified to workcorrectly on each architecture, you're going to start distributing yourapp, either on the App Store or perhaps by a download link on your website, in which case you'll need your entire software package to be notarized.Please watch a WWDC session from 2019 called All About Notarization for details.

In Xcode, your distribution process starts with an archive build, whichnow by default produces universal apps. In Xcode, the Archiveaction is available in the Product menu. If your primary development workflowis to use only one type of Mac computer, doing an archive build might actuallybe the first time that your code builds universally. So if your debugiterations build fine, but your archive build fails, that indicates you havesome portability issues that we've covered earlier in the session.Once your archive build succeeds, you can find your package for distributionin the Organizer window of Xcode. In Xcode 12, it now shows whichCPU architectures are included in your archive builds. The Organizeralso provides access to crash statistics and individual crash logs fromyour users of your app. For details about crash logs and how to investigatethe root causes of crashes, please watch a video from WWDC 2018called Understanding Crashes and Crash Logs. With universal apps you shouldnow watch out that you'll be receiving three different kinds of crash logs:x86 crash logs from Intel Macs, native arm64 crash logs for Apple SiliconMacs, but also translated x86 crash logs when running under Rosetta on AppleSilicon Macs. If you select a particular crash log in the Organizer, theDetails section now shows what CPU architecture the crash originatedon and whether the process was running translated or not. If your app relieson a kernel extension, or if you provide drivers for hardware using DriverKit,there are some special considerations that you should understand whenporting these types of software. In particular, more types of kernel extensionsare now deprecated or disallowed on Apple Silicon Macs, and you'll haveto use DriverKit for those instead. Please refer to the macOS portingdocumentation for details. One more thing to watch out for is multithreading bugs.Intel CPUs and Apple Silicon implement a different memory ordering model.For correct multithreaded code, this doesn't matter. It will always run correctly.But bugs like race conditions and data races might have slightly differentbehavior on each of these architectures. Specifically, a data race on Intel CPUsmight have worked fine and appeared to be benign, but the same bug couldbe causing crashes on Apple Silicon instead. Note that running under Rosettafully supports the Intel memory ordering, so you will not see a differencein behavior there. Whether you do see crashes in multithreaded code ornot, I highly recommend using Thread Sanitizer as a tool to detect andprevent data races. We have presented this tool in WWDC session in 2016 called ThreadSanitizer and Static Analysis. You can enable Thread Sanitizer in the schemeeditor of your project. In the Diagnostics tab, you can find a checkboxcalled Thread Sanitizer. But remember this is a runtime tool. You have torun your app and exercise code at the run time to find bugs. So thisconcludes the tips that I had for working with universal apps. Let me nowwrap up the session and let's summarize what we have talked about today.Mac apps should from now on be built as universal apps, and you can startbringing them to Apple Silicon today. Scan your source code fornon-universal binaries. You will need to get them updated as universal to runyour app natively. Use Xcode 12 to build your app universal, identify and fixany portability issues you discover on the way, and don't forget to runand test the native build of your apps. Watch out for any of the platformdifferences that we have discussed today.

Finally, I would like to remind you that developer.apple.com/documentationcontains many more details. The article called Apple Siliconprovides guidance and answers to questions you might have aboutporting your app. Thank you for watching.

21:19 -Don’t assume the time is returned in nanoseconds

21:40 -Use clock_gettime_nsec_np to read timestamp in nanoseconds

26:40 -Avoid spinlocks and spinning to check for work

27:03 -Prefer blocking locks and condition variables

33:51 -Load a plug-in dynamically

## Code Samples

```swift
// Don’t assume the time is returned in nanoseconds



func
 
monotonicTimestampInSeconds
()
 -> 
Double
 {
  
let
 ticks 
=
 mach_absolute_time()
  
let
 seconds 
=
 
Double
(ticks) 
/
 
1_000_000_000

  
return
 seconds
}
```

```swift
// Use clock_gettime_nsec_np to read timestamp in nanoseconds



func
 
monotonicTimestampInSeconds
()
 -> 
Double
 {
  
let
 nanoseconds 
=
 clock_gettime_nsec_np(
CLOCK_UPTIME_RAW
)
  
let
 seconds 
=
 
Double
(nanoseconds) 
/
 
1_000_000_000

  
return
 seconds
}
```

```swift
func
 
performWorkUnderSpinlock
()
 { 
  spinlock_lock()
  performWork()
  spinlock_unlock()
}


func
 
retrieveNextWorkTask
()
 -> 
WorkTask
 {
  
while
 
true
 {
    
let
 task 
=
 queue.sync { taskQueue.pop() }
    
if
 
let
 task 
=
 task { 
return
 task }
    
else
 { 
continue
 }
  }
}
```

```swift
func
 
performWorkUnderSpinlock
()
 { 
  os_unfair_lock_lock()
  performWork()
  os_unfair_lock_unlock()
}


func
 
retrieveNextWorkTask
()
 -> 
WorkTask
 {
  condition.lock()
  
while
 
!
taskQueue.hasAnyWork {
    condition.wait()
  }
  
let
 task 
=
 taskQueue.pop()
  condition.unlock()
  
return
 task
}
```

```swift
void
 *plugin_module = dlopen(
"./path/to/plugin.dylib"
, RTLD_NOW);

if
 (plugin_module == 
NULL
) {
  fprintf(stderr, 
"loading module failed:\n"
);
  fprintf(stderr, 
"%s\n"
, dlerror());
  
return
 
0
;
}
```


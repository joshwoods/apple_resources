# Wwdc2020 10219

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Build localization-friendly layouts using XcodeLocalizing your app is a wonderful way to share your work with a worldwide audience and make it relevant to more cultures and languages. We'll show you how you can prepare for localization before ever translating a word by building thoughtful layouts for your app. Learn how to structure your UI in Xcode, identify common issues prevalent with more verbose and right-to-left languages, and easily adapt your interfaces to provide a great experience for everyone.ResourcesAuto Layout GuideAutosizing Views for Localization in iOSLocalization-Friendly Layouts in macOSHD VideoSD VideoRelated VideosWWDC20Build location-aware enterprise apps

Localizing your app is a wonderful way to share your work with a worldwide audience and make it relevant to more cultures and languages. We'll show you how you can prepare for localization before ever translating a word by building thoughtful layouts for your app. Learn how to structure your UI in Xcode, identify common issues prevalent with more verbose and right-to-left languages, and easily adapt your interfaces to provide a great experience for everyone.

Auto Layout Guide

Autosizing Views for Localization in iOS

Localization-Friendly Layouts in macOS

HD VideoSD Video

HD Video

SD Video

Build location-aware enterprise apps

Search this videoâ€¦Hello and welcome to WWDC.Hello my name is Paul Borokhov and I am a software localization engineerat Apple. Today I will discuss how to build localization friendly layoutsusing Xcode. We'll go over some common patterns to accomplish this goaland things to avoid and discuss the tools that are at your disposal tomake your job easier. First let's take a look at some common design patternsthat you want to follow in your apps to make them localization friendly.Crucially, these patterns are applicable no matter what platform you developon or whether you employ manual layout, auto layout, or SwiftUI to implementyour designs. First and foremost, you want to avoid using fixed widths orframes on any controls containing text. In a practical sense, this meansremembering to call sizeToFit with manual layouts, avoiding fixed widthconstraints with auto layout and not setting explicit frames in SwiftUI.As an example, consider this button on macOS: while in English it looks good,when we translate it into Greek, which tend to use longer strings for thesame words, you can see that we clip the word midway through a character,and the ellipsis is missing completely. In most cases, you can simply removethe fixed with or change it to a greater than or equal to constraint toallow the text to show fully. Next, you want to avoid having fixed spacingwhen it is between two distant objects. Consider the example below:there is a bunch of free space between the Publish and Cancel buttons.While this looks good in English, when we translate to Greek you can see thatthe entire window grows because the translations for Publish and Cancelare longer. But a more pleasant design would allow the wider buttons tosimply eat into the space between them, keeping the window width the same.We can accomplish this with stacks or greater than or equal to constraints.On all platforms, you'll want to make sure that text is allowed to wrapto multiple lines when it makes sense to do so. Consider the followingexample on iOS where UILabel is restricted to one line of textby default. This looks fine in English on an iPhone 11 Pro. To get asense of how it might look in other languages that are longer, we can usedouble strings mode. This feature which can be enabled both in the previewand at runtime simply doubles the text inside every control and label.Testing out this UI and double strings mode shows that the text no longerfits on one line and truncates as a result. Setting the number of linesto zero will allow the text to wrap properly. Finally, try to avoid placingtoo many controls in a fixed space with no affordance for an alternate layout.Consider this example where I have four buttons side by side. As you cansee, in double strings mode they no longer fit on a single line and endup truncating. This can be particularly problematic in Bars where you cannoteasily provide an alternate layout. We will see in the demo one of theways we can work around this problem. Now let's jump in to Xcode to seethese patterns in action and how we can apply them on a typical app. Here,I have a simple iOS app that prompts the user to pick their favorite food.We have a title label, a regular label, and a bunch of buttons to make the choice.I'm going to go ahead and open the document preview. I will then clickEnglish at the bottom right and choose double length pseudo language to seewhat my UI might look like when I go to localize my app. Immediately Isee that my labels should have their number of lines set to zero so that theyare allowed to wrap. Once I fix that In the attributes inspector, the labelslook good but the buttons are still truncating. Before I go and addressthat, let me add a comment to my translator explaining the context for thetitle label. I will select the title, switch over to the Identity Inspectorand provide a helpful comment in the localizer hint field. Now, to addressthe truncated buttons, I have a couple of options. Perhaps instead of usingstrings in these buttons I could use pictures of the food so that they'reall the same size. The approach we will cover today will be to change the layoutof the buttons from horizontal to vertical, when there is not sufficientspace to display them all side by side. You can do this by placing the buttonsin a horizontal stack view and then querying its layout fitting size todetermine whether it has sufficient space to display all of its content.If it doesn't we will change its orientation to vertical. Conveniently, I alreadyhave a custom class written to do just that. So I will simply set it inthe storyboard and make a connection to the leading constraint of the stack view.If you want to see the details of how this dynamic behavior is implemented,go ahead and download the companion sample project below this video.Since this is a code change, I will not be able to see its effects in the previewand I will need to build and run the app. First let's just try runningit in English. As you can see the layout hasn't changed from what I havedefined in Interface Builder. Now let's try running it again in double strings mode.I will go into the Scheme Editor, go into the Options tab, and select DoubleLength Pseudolanguage from the app language pop up. Since I haven't changed theapp, I will run it with Command-Control-R to relaunch the already built version.You can see that the labels have wrapped as we expect and our stack viewhas also changed its orientation to vertical, to accommodate the longer buttons.Now I have also set up a first generation iPhone SE here with the largestnon-accessibility Dynamic Type set. You can see that even in English thelayout gracefully adjust to accommodate the narrower screen width. I canopen the Accessibility Inspector, from Xcode to change the Dynamic Typesettings to the default, and as you can see the layout reverts back to thehorizontal layout as expected. I can also use Xcode's environment overrides featureto do the same thing.We just saw a lot of the design best practices applied in the demo, as wellas some tools that Xcode provides for you to make it easy to test your appin other languages and validate the layout works well. Let's recapsome of the tools that we used in the demo to achieve a localization-friendlylayout and see additional ones that are at your disposal. As we saw inthe demo the document preview allows you to preview your UI adjustmentsimmediately without having to build and run your app. It supports thePseudolanguages, as well as any localizations that you have in your application,as we will see shortly. Scheme options allow you to runtime test your appin specific languages, including the numerous Pseudolanguages. To quicklychange Dynamic Type settings and verify that your app adapts to them accordingly,you can add the Dynamic Type widget to Control Center on iOS, as well asuse the Accessibility Inspector and Xcode's Environment Overrides featurewith devices that are attached to your Mac. There are additional toolsthat Xcode provides to make your job even easier when implementing your layout.Just like in your source code, Interface Builder provides fix-its with quicksolutions to common problems like sub-optimal or missing constraints whenusing Auto Layout. The "Embed in" feature in Interface Builder allows youto adopt modern container views for multiple controls that automaticallyprovide the correct constraints for a wider variety of scenarios, includingStack Views and Grid Views. Now let's jump into Xcode to see auto layoutfix-its and the Embed in functionality in action. Here I have a XIB fora Mac app in which I have not added any Auto Layout constraints yet.You can immediately see that there is a warning icon in the documentsidebar for the top level window. If I click it, I will see multiple localizationissues being reported about missing constraints. If we open up the documentpreview and choose the Double Length Pseudolanguage, we can see that none of thecontrols grow to accommodate the longer text. If we build and run the app,we can also see that the UI does not flip in Arabic. Going back to thelist of issues, perhaps seeing so many at once is a bit overwhelming,and I want a quick way to resolve them all. If I click the Resolve Auto LayoutOptions button in the bottom right of the canvas, there is an option toAdd Missing Constraints for all views in the window. So let me try that.Now all the controls have constraints, but I still have a bunch of localization warnings.Let's look at the one about the Publish button. We don't really need thisFixed width at all, and it was added because the button happened to be alittle larger than its intrinsic content size. The natural size of aview that takes only its contents into account. I can go ahead and clickthe yellow triangle and choose the Remove Constraint fix-it to resolvethis issue. Next, I have the OK button with a width of 70. In some languages,the word for "OK" could be much longer. So we do not want to restrict thewith here. However for languages like English with very short translationswe don't want a tiny button, either. Conveniently, the fix-it popover providesan option to do just what we want. Choose the "Set Constraint to Greater ThanOr Equal To A Minimum Width" to get appropriate behavior for all languages.Next, let's make sure that the Cancel and Publish buttons can't overrun each other.This is highlighted by the trailing constraint is missing warning forthe Publish button. We can choose the "Fixed Leading and Resizing TrailingConstraints" option here as we want the space to the right of the buttonto be flexible in this case. Finally, we can resolve all of the misplacedviews by clicking the windows content view and clicking the update framesbutton in the lower right of the canvas. Now I'm down to just three localization warnings.I could go ahead and resolve them here but I will take the opportunity toillustrate the Embed-in functionality in Xcode instead. The entiretop part of this dialog looks a lot like a spreadsheet, so let's tryembedding it in a Grid View, which is specifically tailored for these kindsof layouts. Before we start I will fix the width and height of the iconbecause I do not want it to change size. Let's also add a height constraintto the description input field, since we always want it to be two lines tall.We will do this by control-click and dragging over the TextField and choosingHeight from the pop-up menu. Finally the vertical constraint between theimage and the Publish button is no longer needed so we can delete it.Now let's select all the text fields and the checkbox. Click "Embed-in"in the bottom right and choose Grid View. The layout of the controls is nowmanaged entirely by the Grid View, so they don't need any explicit constraints.Of course, I must still constrain the Grid View to its sub-lengths, so letme do that by adding standard space constraints on the top, leading, andtrailing edges and set the bottom space to 27. Using standardspace gives me spacing recommended by the Human Interface Guidelines whichautomatically changes based on the context, avoiding the need for hardcoded values.The bottom space of 27 was given to me by my designer, so that'swhat I will use. Our OK button used to be trailing aligned with the TextFieldabove it and that went away when we put it in the Grid View. So let's addit back by control-click and dragging from the OK button in the canvasto the Grid View in the document sidebar, and choosing trailing from the menuthat appears. Next,I need to merge the cells in the first row so the title can span both columnsand move the Ignore alerts checkbox from the first column to the second.First, let me select the top two cells in the document sidebar by holdingdown the command key as I click them. Then choose Merge Cells from the RowOptions menu in the canvas. To move the checkbox, I will simply drag anddrop it from one cell into the other. The basic structure is now done, butthe lab doesn't quite match what I want. First, lets adjust the Grid Viewattributes to match our expectations. I will select the Grid View and thenshow the attributes inspector. Since we have text in our Grid View, weshould set our rule alignment attribute to First Baseline. We also wantto set the xPlacement to Fill so that all the available space is takenup by the content inside. The spacing should match standard spacing implying row spacingof 12 and column spacing of 8. And we still have an unnecessary widthconstraint on the name label. So let's go ahead and remove that.We also don't want the first column to be any wider than it needs to be.So let's set the horizontal hugging priority of the name and descriptionlabels to 749 causing the Grid Views column tohug them tightly. We choose 749 because it is lowerthan the labels default compression priority of 750, but higher than thewindows holding priority of 500. Finally, set the vertical contenthugging priority of the Grid View to 600 so that our window cannotbe resized vertically. Looks like we have misplaced views again, but wecan quickly resolve that by clicking the Windows Content View, and thenclicking the update frames button in the lower end of the canvas. Now let'sopen up the document preview and see our outlooks in different languages. Greek. Chinese.And Double Length Pseudolanguage. All look great. Now let's do a quick runtimetest in Arabic as well. No issues. Looks perfect.Before we wrap up, I wanted to call out the importance of user testing fordelivering a high quality localized app.Of course, no amount of automation and scrupulous testing can replace humandriven testing by native language speakers. These testers will be ableto immediately spot glaring issues in your application. Such as inconsistencieswith OS terminology, truncated and clipped text, which might not be obvious to anon-native speaker as well as out-of-context translations which no automationor fix-its can determine. This testing is particularly critical if you'readding new localization or making big UI changes to your app.Customers will be very excited to see their app is finally localized into their nativelanguage, and making a good first impression will do wonders for buildinga good relationship and reputation for your brand in a new market. In summary,as international customers are the majority of your customers, it is importantthat you're aware of the impact localization will have on the design andlayout of your app. By following the localization friendly design patternsthat we have discussed and demonstrated, you can make non-disruptive adjustmentsto your app to make it truly world-ready. Finally, UI testing by native speakersof the localizations can make a significant impact in the quality of yourlocalized apps and the impression they leave on users.Thanks for watching.

Hello and welcome to WWDC.

Hello my name is Paul Borokhov and I am a software localization engineerat Apple. Today I will discuss how to build localization friendly layoutsusing Xcode. We'll go over some common patterns to accomplish this goaland things to avoid and discuss the tools that are at your disposal tomake your job easier. First let's take a look at some common design patternsthat you want to follow in your apps to make them localization friendly.Crucially, these patterns are applicable no matter what platform you developon or whether you employ manual layout, auto layout, or SwiftUI to implementyour designs. First and foremost, you want to avoid using fixed widths orframes on any controls containing text. In a practical sense, this meansremembering to call sizeToFit with manual layouts, avoiding fixed widthconstraints with auto layout and not setting explicit frames in SwiftUI.

As an example, consider this button on macOS: while in English it looks good,when we translate it into Greek, which tend to use longer strings for thesame words, you can see that we clip the word midway through a character,and the ellipsis is missing completely. In most cases, you can simply removethe fixed with or change it to a greater than or equal to constraint toallow the text to show fully. Next, you want to avoid having fixed spacingwhen it is between two distant objects. Consider the example below:there is a bunch of free space between the Publish and Cancel buttons.While this looks good in English, when we translate to Greek you can see thatthe entire window grows because the translations for Publish and Cancelare longer. But a more pleasant design would allow the wider buttons tosimply eat into the space between them, keeping the window width the same.We can accomplish this with stacks or greater than or equal to constraints.

On all platforms, you'll want to make sure that text is allowed to wrapto multiple lines when it makes sense to do so. Consider the followingexample on iOS where UILabel is restricted to one line of textby default. This looks fine in English on an iPhone 11 Pro. To get asense of how it might look in other languages that are longer, we can usedouble strings mode. This feature which can be enabled both in the previewand at runtime simply doubles the text inside every control and label.Testing out this UI and double strings mode shows that the text no longerfits on one line and truncates as a result. Setting the number of linesto zero will allow the text to wrap properly. Finally, try to avoid placingtoo many controls in a fixed space with no affordance for an alternate layout.Consider this example where I have four buttons side by side. As you cansee, in double strings mode they no longer fit on a single line and endup truncating. This can be particularly problematic in Bars where you cannoteasily provide an alternate layout. We will see in the demo one of theways we can work around this problem. Now let's jump in to Xcode to seethese patterns in action and how we can apply them on a typical app. Here,I have a simple iOS app that prompts the user to pick their favorite food.We have a title label, a regular label, and a bunch of buttons to make the choice.I'm going to go ahead and open the document preview. I will then clickEnglish at the bottom right and choose double length pseudo language to seewhat my UI might look like when I go to localize my app. Immediately Isee that my labels should have their number of lines set to zero so that theyare allowed to wrap. Once I fix that In the attributes inspector, the labelslook good but the buttons are still truncating. Before I go and addressthat, let me add a comment to my translator explaining the context for thetitle label. I will select the title, switch over to the Identity Inspectorand provide a helpful comment in the localizer hint field. Now, to addressthe truncated buttons, I have a couple of options. Perhaps instead of usingstrings in these buttons I could use pictures of the food so that they'reall the same size. The approach we will cover today will be to change the layoutof the buttons from horizontal to vertical, when there is not sufficientspace to display them all side by side. You can do this by placing the buttonsin a horizontal stack view and then querying its layout fitting size todetermine whether it has sufficient space to display all of its content.If it doesn't we will change its orientation to vertical. Conveniently, I alreadyhave a custom class written to do just that. So I will simply set it inthe storyboard and make a connection to the leading constraint of the stack view.

If you want to see the details of how this dynamic behavior is implemented,go ahead and download the companion sample project below this video.Since this is a code change, I will not be able to see its effects in the previewand I will need to build and run the app. First let's just try runningit in English. As you can see the layout hasn't changed from what I havedefined in Interface Builder. Now let's try running it again in double strings mode.I will go into the Scheme Editor, go into the Options tab, and select DoubleLength Pseudolanguage from the app language pop up. Since I haven't changed theapp, I will run it with Command-Control-R to relaunch the already built version.You can see that the labels have wrapped as we expect and our stack viewhas also changed its orientation to vertical, to accommodate the longer buttons.Now I have also set up a first generation iPhone SE here with the largestnon-accessibility Dynamic Type set. You can see that even in English thelayout gracefully adjust to accommodate the narrower screen width. I canopen the Accessibility Inspector, from Xcode to change the Dynamic Typesettings to the default, and as you can see the layout reverts back to thehorizontal layout as expected. I can also use Xcode's environment overrides featureto do the same thing.

We just saw a lot of the design best practices applied in the demo, as wellas some tools that Xcode provides for you to make it easy to test your appin other languages and validate the layout works well. Let's recapsome of the tools that we used in the demo to achieve a localization-friendlylayout and see additional ones that are at your disposal. As we saw inthe demo the document preview allows you to preview your UI adjustmentsimmediately without having to build and run your app. It supports thePseudolanguages, as well as any localizations that you have in your application,as we will see shortly. Scheme options allow you to runtime test your appin specific languages, including the numerous Pseudolanguages. To quicklychange Dynamic Type settings and verify that your app adapts to them accordingly,you can add the Dynamic Type widget to Control Center on iOS, as well asuse the Accessibility Inspector and Xcode's Environment Overrides featurewith devices that are attached to your Mac. There are additional toolsthat Xcode provides to make your job even easier when implementing your layout.

Just like in your source code, Interface Builder provides fix-its with quicksolutions to common problems like sub-optimal or missing constraints whenusing Auto Layout. The "Embed in" feature in Interface Builder allows youto adopt modern container views for multiple controls that automaticallyprovide the correct constraints for a wider variety of scenarios, includingStack Views and Grid Views. Now let's jump into Xcode to see auto layoutfix-its and the Embed in functionality in action. Here I have a XIB fora Mac app in which I have not added any Auto Layout constraints yet.You can immediately see that there is a warning icon in the documentsidebar for the top level window. If I click it, I will see multiple localizationissues being reported about missing constraints. If we open up the documentpreview and choose the Double Length Pseudolanguage, we can see that none of thecontrols grow to accommodate the longer text. If we build and run the app,we can also see that the UI does not flip in Arabic. Going back to thelist of issues, perhaps seeing so many at once is a bit overwhelming,and I want a quick way to resolve them all. If I click the Resolve Auto LayoutOptions button in the bottom right of the canvas, there is an option toAdd Missing Constraints for all views in the window. So let me try that.Now all the controls have constraints, but I still have a bunch of localization warnings.Let's look at the one about the Publish button. We don't really need thisFixed width at all, and it was added because the button happened to be alittle larger than its intrinsic content size. The natural size of aview that takes only its contents into account. I can go ahead and clickthe yellow triangle and choose the Remove Constraint fix-it to resolvethis issue. Next, I have the OK button with a width of 70. In some languages,the word for "OK" could be much longer. So we do not want to restrict thewith here. However for languages like English with very short translationswe don't want a tiny button, either. Conveniently, the fix-it popover providesan option to do just what we want. Choose the "Set Constraint to Greater ThanOr Equal To A Minimum Width" to get appropriate behavior for all languages.

Next, let's make sure that the Cancel and Publish buttons can't overrun each other.This is highlighted by the trailing constraint is missing warning forthe Publish button. We can choose the "Fixed Leading and Resizing TrailingConstraints" option here as we want the space to the right of the buttonto be flexible in this case. Finally, we can resolve all of the misplacedviews by clicking the windows content view and clicking the update framesbutton in the lower right of the canvas. Now I'm down to just three localization warnings.I could go ahead and resolve them here but I will take the opportunity toillustrate the Embed-in functionality in Xcode instead. The entiretop part of this dialog looks a lot like a spreadsheet, so let's tryembedding it in a Grid View, which is specifically tailored for these kindsof layouts. Before we start I will fix the width and height of the iconbecause I do not want it to change size. Let's also add a height constraintto the description input field, since we always want it to be two lines tall.

We will do this by control-click and dragging over the TextField and choosingHeight from the pop-up menu. Finally the vertical constraint between theimage and the Publish button is no longer needed so we can delete it.

Now let's select all the text fields and the checkbox. Click "Embed-in"in the bottom right and choose Grid View. The layout of the controls is nowmanaged entirely by the Grid View, so they don't need any explicit constraints.

Of course, I must still constrain the Grid View to its sub-lengths, so letme do that by adding standard space constraints on the top, leading, andtrailing edges and set the bottom space to 27. Using standardspace gives me spacing recommended by the Human Interface Guidelines whichautomatically changes based on the context, avoiding the need for hardcoded values.The bottom space of 27 was given to me by my designer, so that'swhat I will use. Our OK button used to be trailing aligned with the TextFieldabove it and that went away when we put it in the Grid View. So let's addit back by control-click and dragging from the OK button in the canvasto the Grid View in the document sidebar, and choosing trailing from the menuthat appears. Next,I need to merge the cells in the first row so the title can span both columnsand move the Ignore alerts checkbox from the first column to the second.First, let me select the top two cells in the document sidebar by holdingdown the command key as I click them. Then choose Merge Cells from the RowOptions menu in the canvas. To move the checkbox, I will simply drag anddrop it from one cell into the other. The basic structure is now done, butthe lab doesn't quite match what I want. First, lets adjust the Grid Viewattributes to match our expectations. I will select the Grid View and thenshow the attributes inspector. Since we have text in our Grid View, weshould set our rule alignment attribute to First Baseline. We also wantto set the xPlacement to Fill so that all the available space is takenup by the content inside. The spacing should match standard spacing implying row spacingof 12 and column spacing of 8. And we still have an unnecessary widthconstraint on the name label. So let's go ahead and remove that.

We also don't want the first column to be any wider than it needs to be.So let's set the horizontal hugging priority of the name and descriptionlabels to 749 causing the Grid Views column tohug them tightly. We choose 749 because it is lowerthan the labels default compression priority of 750, but higher than thewindows holding priority of 500. Finally, set the vertical contenthugging priority of the Grid View to 600 so that our window cannotbe resized vertically. Looks like we have misplaced views again, but wecan quickly resolve that by clicking the Windows Content View, and thenclicking the update frames button in the lower end of the canvas. Now let'sopen up the document preview and see our outlooks in different languages. Greek. Chinese.

And Double Length Pseudolanguage. All look great. Now let's do a quick runtimetest in Arabic as well. No issues. Looks perfect.

Before we wrap up, I wanted to call out the importance of user testing fordelivering a high quality localized app.Of course, no amount of automation and scrupulous testing can replace humandriven testing by native language speakers. These testers will be ableto immediately spot glaring issues in your application. Such as inconsistencieswith OS terminology, truncated and clipped text, which might not be obvious to anon-native speaker as well as out-of-context translations which no automationor fix-its can determine. This testing is particularly critical if you'readding new localization or making big UI changes to your app.Customers will be very excited to see their app is finally localized into their nativelanguage, and making a good first impression will do wonders for buildinga good relationship and reputation for your brand in a new market. In summary,as international customers are the majority of your customers, it is importantthat you're aware of the impact localization will have on the design andlayout of your app. By following the localization friendly design patternsthat we have discussed and demonstrated, you can make non-disruptive adjustmentsto your app to make it truly world-ready. Finally, UI testing by native speakersof the localizations can make a significant impact in the quality of yourlocalized apps and the impression they leave on users.

Thanks for watching.

## Code Samples


# Wwdc2020 10646

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

What's new in Web InspectorThe Web Inspector makes introspection and debugging simpler than ever. Discover how you can use debugger stepping, editing cookies, and overriding network loaded resources to provide you with powerful development capabilities and help you create faster, more efficient websites.ResourcesSafari Technology PreviewWeb Inspector ReferenceWebKit Open Source ProjectHD VideoSD VideoRelated VideosWWDC21Discover Web Inspector improvementsWWDC20Discover WKWebView enhancementsMeet Safari Web ExtensionsWhat's new for web developers

The Web Inspector makes introspection and debugging simpler than ever. Discover how you can use debugger stepping, editing cookies, and overriding network loaded resources to provide you with powerful development capabilities and help you create faster, more efficient websites.

Safari Technology Preview

Web Inspector Reference

WebKit Open Source Project

HD VideoSD Video

HD Video

SD Video

Discover Web Inspector improvements

Discover WKWebView enhancements

Meet Safari Web Extensions

What's new for web developers

Search this video…Hello and welcome to WWDC.Hi my name is Devin and I'm thrilled to be able to show you some of themany improvements and new features added to Web Inspector in the last year.To start let's enable Web Inspector in Safari.First, click on the Safari menu bar item and select Preferences to showSafari's Preferences. Go to the Advanced Tab and enable "Show Develop menuin menu bar." In the now visible Develop menu, click "Show Web Inspector."And there it is! Web Inspector is your one stop shop for all introspectionand debugging tools for Web content whether that be in Safari, aWKWebView in an app or even a JSContext.Before we dive into individual features, let's take a look at some of thechanges that have been made to the overall interface. We've merged thetoolbar and dashboard into the tab bar to save on vertical space.Additionally, we've tightened the spacing around many controls throughout the interface,allowing you to see more content in Web Inspector without having to sacrificeon visibility of content in the inspected page. These changes also arenot limited to when docked to the bottom, as they also apply when docked tothe side and even when undocked into a separate window. We've also improvedAccessibility support for navigating around Web Inspector when using ascreen reader. For those of you that prefer Dark Mode, we've created DarkMode variants for all of the icons throughout Web Inspector as well asadded a way to toggle Dark Mode independently from the rest of the systemin the Settings Tab. Because there is no longer a dashboard, the NetworkTab now shows the Inspected Page Statistics below the main table and hasbeen expanded to include the number of unique domains, the total transfersize and a count of all redirects. This year, we've added new features to almostevery tab as well as adding a few entirely new tabs. So let's go througheach, starting with the new Sources Tab. For those of you who've used WebInspector in the past, the Sources Tab takes all of the best features ofthe Resources Tab and the Debugger Tab and combines them into a single tab.The Sources Tab lists all resources loaded by the inspected page sinceWeb Inspector was opened, including long-lived things like 'WebSocket's ormore ephemeral things like XHRs or 'fetch's. The Sources Tab is alsothe primary place for JavaScript debugging, containing all of the JavaScriptdebugger stepping controls and many of the breakpoint adding capabilitiesprovided by Web Inspector. And new this year, the Sources Tab is home tothe network overriding capabilities provided by Web Inspector, which we'llsee in a minute. So let's take a look. When viewing resources in the SourcesTab, Web Inspector will provide alternate representations for applicablecontent, giving you another way to explore and examine the content to understandwhat's going on or fix any issues. Right now, we're looking at the Responsecontent of this resource, which we can see is HTML text. In this case,the  is filled with a lot of  and  text, meaning that we'd haveto scroll down to see any of the content of the . Additionally, it'sharder to see where tags begin and end when they're all scrunched up likethis in a text. It would be a lot easier to navigate if we could visualizethis response content as a DOM tree instead, just like in the Elements Tab.Clicking on the Response breadcrumb item will show a dropdown with allof the alternate representations Web Inspector provides for this resource.Selecting the "Response (DOM Tree)" will visualize the response content asa DOM tree, just like we want it. Similar alternate representations arealso provided for when the content is valid JSON, showing an object treeas if it were logged in the Console. These alternate representations arealso available when content is sent as part of a request.In situations that you do find an issue in the resource's response, it'snot always easy to make a change to the source code that the resource wasloaded from, as it may exist on a faraway server or involve complicated pre-processing steps.I am very excited to tell you that this year, Web Inspector has added anew feature to solve this exact problem. We call them "Local Overrides."Creating one is as simple as clicking the "Create Override" button when viewingany resource which will automatically copy the current contents of thatresource into a new local override for that resource. They are fully editableand are preserved by Web Inspector across sessions of both the inspectorpage and Web Inspector itself. So let's try making a simple change to seea local override in action. Scrolling down in the content area, we can seethe "WebKit" text in the . We can change this "WebKit" text to somethinglike "Hello WWDC!" instead. If we take a look at the inspected page and reload,we can see that the "WebKit" text in the  of the inspected page changesto match the edits we just made. Even better, local overrides support morethan just modifying the response's content. If you right-click on the localoverride in Web Inspector and select the "Edit Local Override…" action, it'salso possible to modify the HTTP status code or any HTTP headers. When theinspected page loads anything over the network that matches any local override's URL,the entire response, including the HTTP status code and any HTTP headers, willbe completely replaced by the local override as it's been configured.Whenever this happens, the icon of the overridden resource will change, indicatingthat it was replaced. And this overridden icon is shown anywhere that theresource can be seen throughout Web Inspector. As further proof, if we selectthe overridden resource and scroll down, the same modifications we madeto the content are also present. All resources, including the main resourcelike we just saw and even non-text resources, like images, can be overriddenand fully configured from within Web Inspector. Sometimes, however, it'snot necessarily a particular resource that you want to change but reallya JavaScript API provided by WebKit. In these cases, you'll want to usethe new Inspector Bootstrap Script which can be added from the add resourcebutton in the bottom corner of the navigation sidebar in the Sources Tab,by selecting the Inspector Bootstrap Script action. Similar to how localoverrides allow you to modify resources loaded over the network,the Inspector Bootstrap Script can be thought of as a way to modifythe JavaScript API surface itself. The contents of the Inspector BootstrapScript are guaranteed to run before anything else in the inspected page.Hence, the "bootstrap" name. This allows you to do things like swizzle built-infunctions to see where they get called or setup some global state thatcauses your code to log additional debugging information.Just like local overrides, the Inspector Bootstrap Script is preservedby Web Inspector across sessions of both the inspected page and Web Inspector itself.Speaking of debugging JavaScript, we've also added a number of new global breakpoints.The Debugger Statements breakpoint controls whether or not JavaScript executionis paused at 'debugger' statements. Previously, the only way to control thiswas to completely disable all breakpoints. We felt this was unnecessarily restrictive,so we created this separate control to allow you to use other types ofbreakpoints while simultaneously disabling 'debugger' statements specifically.The other new breakpoints, since they relate to specific APIs, must be enabledby clicking on the add breakpoint button which will show a menu with actionsthat each enableone of these new breakpoints. So let's go through each of themone by one. The All Microtasks breakpoint will pause JavaScript executionwhenever any microtask is about to be executed, such as from 'Promise'objects or the 'queueMicrotask()' global function. Along these lines, the All AnimationFrames breakpoint does the same for 'requestAnimationFrame' callbacks.The All Timeouts breakpoint does the same for 'setTimeout' callbacks and theAll Intervals breakpoint does the same for 'setInterval' callbacks. Lastly, theAll Events breakpoint will pause before any callback is invoked for anyevent listener, even those unrelated to the DOM. But sometimes these globalbreakpoints are almost too global, in the sense that they pause more oftenthan desired. Let's take a look at an example using the All Events breakpoint.I have a simple page that uses jQuery to add an event listener to aelement. Because I've enabled the All Events breakpoint, I wouldexpect to pause inside this event listener. But in reality, jQuery wrapsmy event listener callback with its own logic. So instead, we pause injQuery's event listener wrapper which is not really ideal as none of thisis my code. Really, what I want to do is have this breakpoint pause in mycode after all of jQuery's code has run.Script blackboxing is a new feature that allows you to do just that – instructingthe JavaScript debugger to defer any pause that would occur in a scriptto pause at the first expression to execute outside of that script.We can do this to jQuery by hovering over the jQuery resource in thenavigation sidebar and clicking on the button that appears. Now, if we triggerthis breakpoint again, we should pause in our event listener instead.If, for some reason, you still do want to dig into the library/frameworkcode, Web Inspector will still show any call frames from blackboxed Script,greying them out to indicate their blackboxed nature. For larger librariesand frameworks, it's also possible to blackbox multiple scripts at onceby configuring regular expression patterns to match against the script'sURL in the Settings Tab.In addition to some of the global breakpoints we've seen so far, WebInpector also allows you to set breakpoints on specific lines of JavaScripteven after pretty printing. Clicking on any line in the gutter area of the content preview,Will add a JavaScript breakpoint that will pause right before that line executes.Because JavaScript is so flexible with its syntax, however, it's not uncommonto see lots of operations combined onto a single line using a mix of various operators.In this case, the logical "or" operator. Previously, if I wanted to pause insidethe 'c' function call and I didn't know where 'c' was declared to set a breakpoint,the only way to do this would be to use the Step In JavaScript debuggeraction to step into "a()".And, then, step out to move past 'a', then, step in again to go inside 'b',And finally, step back out, again, to arrive at 'c'.This is a very tedious process with lots of opportunity for mistakes whichcan be incredibly frustrating, especially in cases where the starting stateis hard to reach.This has led us to introduce a new JavaScript debugger action which we call Step.Unlike the Step Over JavaScript debugger action, which resumes and re-pausesexecution before the next statement in the current call frame, which inthis case, would be after the entire 'foo' variable declaration, this newStep debugger action will resume and re-pause Javascript execution beforethe next expression in the current call frame. And just like that, we'veresumed, executed 'a' and re-paused on the same line without ever having to Stepin or Step out. Once more, we can Step to resume execute 'b' and re-pausearriving at the call for 'c'.This Step JavaScript debugger action provides more fine grained controlover how the JavaScript debugger execution head moves through the program,allowing for fewer stepping mistakes and even less actions in total.But sometimes scripts are inlined in HTML. In the past, there was noway to pretty print this inlined script content or even any of the surrounding HTML.As a result, it was often difficult to set breakpoints or even step throughcode in a nicely readable way. I'm very happy to say that in the latestSafari, Web Inspector now supports formatting HTML and other XML-likecontent, including inline scripts and style sheets, allowing supportfor all of the existing JavaScript debugger and stepping capabilities too.Simply click on the pretty print button in the top right of any text-basedcontent preview, to toggle between the original content and the pretty printed version.Web Inspector will also attempt to detect when HTML has been minifiedand automatically toggle pretty printing, just like it has always done forJavaScript and CSS content. So speaking of Web Inspector functionality,there's so much more than just viewing resources. So, let's move on to someof the other powerful or more specialized features starting with the Timelines Tab.The Timelines Tab contains the majority of performance profiling toolsoffered by Web Inspector. It captures activity in the inspected page duringwhat we call a "recording" which organizes and plots the data into one ofa handful of different timelines based on the type of data.Timeline recordings can also be exported and imported allowing you to sharethem with others or save them for later use. The main change this yearin the Timelines Tab, is an introduction of an entirely new timeline, whichyou can activate by clicking the Edit button in the main graph area.This will put us in edit mode where we can enable or disable any of the various timelines.The new timeline we've added this year is the Media & Animations timelinewhich captures events related to media elements, like  or , andalso captures the lifecycle of CSS animations and CSS transitions.After checking the checkbox to enable the Media & Animations timeline and clicking the Donebutton to leave Edit mode, if we reload the inspected page we can see alist of all media elements, CSS animations and CSS transitions that havehad any activity during the recorded interval. Each individual media element,CSS animation or CSStransition has its own row in the table with linksto any related DOM node or information about the CSS 'animation-name' orCSS 'transition-property'. The Media & Animations timeline can alsobe used to correlate activity captured in other timelines with state changesin any media elements, such as a video being paused or the creation or destructionof any CSS animations or CSS transitions to figure out what's going onand understand why. And that's a quick look at the Media & Animationstimeline in the Timelines Tab.Let's move on to the Storage Tab. So the Storage Tab contains a list ofall of the data stored by the inspected page in the browser via thingslike cookies or LocalStorage or IndexedDB. This year, we've added filteringcapabilities for all storage types and improved editing and deleting capabilitiesespecially for cookies. The new filtering capabilities take the form ofan always visible filter bar shown at the top of most storage views. As an example,filtering cookies is as simple as typing some text into the filter barwhich is compared against the various fields of each cookie, hiding anyrows that had no matches. The second major feature is the ability to edit cookies.Double clicking on one of a cookie's cells, will show a popover with inputsfor each field of that cookie. All modifications made in this popover willbe applied as soon as the popover is dismissed. It is also possible to addentirely new cookies by clicking on the add cookie button which will showa similar popover. But, this time, all of the inputs will be empty.Note, that a name is required in order for a cookie to be added. Just like HTTPcookies, or those set by 'document.cookie', they will persist beyond Web Inspector,so be careful what you add. But many other features of the web are not persistent,so let's take a look at tooling for some of those. Starting with the allnew Graphics Tab.For those of you who've used Web Inspector in the past few years, you mayremember using the Canvas Tab. The Graphics Tab expands the scope and functionalityof the Canvas Tab still showing all  contexts and shaders and supportingtaking recordings of JavaScript API calls made to  contexts, but nowalso listing all web animations including those created by CSS animations andCSS transitions, providing in-depth information about each. The previouslyavailable information about all  contexts in the inspected page isstill shown in the Canvases section at the top, followed by the new sectionsfor the various types of animations created by the web animations API separatedby how they're created, such as from JavaScript, CSS animations or CSS transitions.Clicking on one of these animations will expand the details sidebar whichcontains all of the information about the selected animation, such as theID which can be thought of as the animation's name, the associated nodeof the animation, the configured timing parameters, like the number of iterationsor the total duration, the keyframes list, each item containing a list ofCSS properties and values that are interpolated between as the animation progresses,and, finally, for animations that are created by the JavaScript API,a backtrace for how the animation was created.Clicking the markup icon in the header of any animation, will show a contextmenu with a number of utility actions, such as Log Animation which willsave the JavaScript object for that Web Animation in a temporary variablein the Console (in this case '$1'), allowing us to have easy accessfor manipulating it using the powerful Web Animations API. For more informationabout the new Web Animations API, be sure to check out the "What's New forWeb Developer" session in your Developer app. But sometimes animations areconfigured incorrectly, which causes performance problems. So, let's takea look at the new Layers Tab to see how it can help. The Layers Tab showsa live view of the layer tree of the inspected page, listing the memorycost and the paint count for each layer. While it's not exactly one to one,it's generally a good idea to keep the number of unintended layers as lowas possible, as a greater number of layers can be associated with increasedmemory use and worse performance. The keyword there though is "unintended"which really requires you, the developer, to know your layout and when thingsshould and should not create a layer. To assist with this, clicking on alayer either in the visualization itself or in the detailed sidebar, will showinformation about that layer, such as why it was created. In the case ofthe currently selected layer, it was created because the associated nodewas being animated by CSS and how to CSS 'will-change' property. The entirelayer tree visualization can also be manipulated using common orbit controlssuch as rotating vertically by clicking and dragging up and down,rotating horizontally by clicking and dragging left and right, zooming by scrollingin and out and panning by right-clicking and dragging, making it easy tofind layers visually to find out more about them. So now let's move on toour final tab, the Console. The Console Tab lists all of the various messageslogged by the inspected page and allows arbitrary JavaScript evaluationin the inspected page. Special functionality is also exposed while evaluatingJavaScript, intended to make inspecting and debugging JavaScript easier byproviding more information previously known only to WebKit. There are awhole bunch of these Console-only specially exposed bits of functionalitythat are new this year, but there are two that are particularly noteworthy.The first is called "queryInstances." So let's imagine a simple JavaScriptclass hierarchy of an 'Animal' base class with a 'Pet' subclass. Now let'ssay that we want to find all instances of this 'Pet' subclass. One way todo it, would be to examine a captured heap snapshot in the Timelines Tab,but that includes a lot of other information that is likely not relevant.So instead, 'queryInstances' when given a constructor, will scan the entireJavaScript heap for instances of objects that inherit from that given constructor,returning them all in an array that can be further manipulated in the Console.As we can see here, there is one instance of this 'Pet' class, which is heldin the variable with the name 'buddy.' Note, however, that due to the natureof JavaScript inheritance, the term "instance" also applies to subclassobjects as well. As an example, if we call 'queryInstances' with the 'Animal'constructor, we will not only see the previously seen 'buddy' variable butwe will also see an instance of 'Animal' held by the 'cat' variable and eventhe entire 'Pet' class as it also inherits from the 'Animal' class. For moreflexibility, it's also possible to provide a prototype instead of a constructorwhich will have the exact same result we saw earlier with the related constructor.The second noteworthy function is called 'queryHolders.' So again, let'simagine a simple JavaScript class called 'Person.' Similar to reality,each 'Person' can have a 'parent.' This is represented in JavaScript as a 'parent'property whose value is the other 'Person' object. This is called a strongreference and is a common cause a memory leaks in JavaScript programs.If we wanted to find all objects that have a strong reference to a givenobject, we could examine a captured heap snapshot in the Timelines Tab,but again this may include other information that is likely not relevant.Instead we can use the 'queryHolders' Console function which, when givenan object, will scan the entire JavaScript heap for all other objects thathave a strong reference to that given object. As we can see in this example,'alice' has a strong reference to 'john' through its 'parent' property whichis why 'alice' appears in the array returned by 'queryHolders.' Now let'stalk about our last feature for today. I'm very happy to announce thatin the latest Safari, so long as Web Inspector is already open, enablingIntelligent Tracking Prevention Debug Mode from Safari's Develop menuwill cause all debug logging from Safari's Intelligent Tracking Preventionto also appear in the Web Inspector Console, as well as in the macOS systemConsole.app. Additionally, logs for Ad Click Attribution Debug Modewill also be shown in the Web Inspector console, which can be enabledfrom the Experimental Features submenu of Safari's Develop menu. This way, you'llnever have to switch away from Safari to see all of the logs you mightfind useful. And with that we've, reached the end of our feature highlights.There is so much more coming in the latest Safari, including a ton of bugfixes and minor tweaks throughout Web Inspector. Before we finish up,there's a few general tips I'd like to leave you with. Tooltips are your friend.If you're unsure of what something does, simply hover over it with yourcursor for a few seconds, and voila! The answer will appear. Every icon inWeb Inspector has a tooltip. All links have a tooltip. In fact, almost everycomponent of the interface has a tooltip. Web Inspector makes heavy useof iconography as there's a ton of varying functionality that has to fitinto a very limited amount of space. As such, it relies on tooltips to provideadditional explanation and description where there isn't enough room.For a similar reason, Context Menus are everywhere and they often contain additionalfunctionality that can't be accessed anywhere else. Many icons have a context menu.Every link has a context menu. Again, almost every component of the interfacehas a context menu. And in fact, most of what we've done so far could havealso been done via a context menu action. For much of the same reasonas tooltips, Web Inspector puts a lot of functionality into context menuactions as there isn't enough room for each action to have its own componentin the interface. For more tips like those, there's an all new section ofthe WebKit website that talks specifically about Web Inspector. It containsa bunch of reference pages that each explore both the breadth and the depthof various features, parts of the interface and more. In fact, many of thefeatures we talked about today already have reference pages and we're workingon writing even more from many of the others. Also, be sure to follow@webkit on Twitter as we post weekly tips about various features in Web Inspector.And I'd also highly recommend using Safari Technology Preview for yourdaily development, as it gets bi-weekly updates with bug fixes and new features,both to Web Inspector and to the rest of WebKit. Be sure to check outthis session's related resources for other sessions about some of thesenew features, as well as links to our documentation. I really hope you'veenjoyed learning about what's new in Web Inspector and I hope you findthat as things we've discussed useful for understanding and debugging webcontent in the future.Thank you so much for listening and
I hope you have a wonderful WWDC.

Hello and welcome to WWDC.

Hi my name is Devin and I'm thrilled to be able to show you some of themany improvements and new features added to Web Inspector in the last year.

To start let's enable Web Inspector in Safari.

First, click on the Safari menu bar item and select Preferences to showSafari's Preferences. Go to the Advanced Tab and enable "Show Develop menuin menu bar." In the now visible Develop menu, click "Show Web Inspector."And there it is! Web Inspector is your one stop shop for all introspectionand debugging tools for Web content whether that be in Safari, aWKWebView in an app or even a JSContext.Before we dive into individual features, let's take a look at some of thechanges that have been made to the overall interface. We've merged thetoolbar and dashboard into the tab bar to save on vertical space.Additionally, we've tightened the spacing around many controls throughout the interface,allowing you to see more content in Web Inspector without having to sacrificeon visibility of content in the inspected page. These changes also arenot limited to when docked to the bottom, as they also apply when docked tothe side and even when undocked into a separate window. We've also improvedAccessibility support for navigating around Web Inspector when using ascreen reader. For those of you that prefer Dark Mode, we've created DarkMode variants for all of the icons throughout Web Inspector as well asadded a way to toggle Dark Mode independently from the rest of the systemin the Settings Tab. Because there is no longer a dashboard, the NetworkTab now shows the Inspected Page Statistics below the main table and hasbeen expanded to include the number of unique domains, the total transfersize and a count of all redirects. This year, we've added new features to almostevery tab as well as adding a few entirely new tabs. So let's go througheach, starting with the new Sources Tab. For those of you who've used WebInspector in the past, the Sources Tab takes all of the best features ofthe Resources Tab and the Debugger Tab and combines them into a single tab.

The Sources Tab lists all resources loaded by the inspected page sinceWeb Inspector was opened, including long-lived things like 'WebSocket's ormore ephemeral things like XHRs or 'fetch's. The Sources Tab is alsothe primary place for JavaScript debugging, containing all of the JavaScriptdebugger stepping controls and many of the breakpoint adding capabilitiesprovided by Web Inspector. And new this year, the Sources Tab is home tothe network overriding capabilities provided by Web Inspector, which we'llsee in a minute. So let's take a look. When viewing resources in the SourcesTab, Web Inspector will provide alternate representations for applicablecontent, giving you another way to explore and examine the content to understandwhat's going on or fix any issues. Right now, we're looking at the Responsecontent of this resource, which we can see is HTML text. In this case,the  is filled with a lot of  and  text, meaning that we'd haveto scroll down to see any of the content of the . Additionally, it'sharder to see where tags begin and end when they're all scrunched up likethis in a text. It would be a lot easier to navigate if we could visualizethis response content as a DOM tree instead, just like in the Elements Tab.

Clicking on the Response breadcrumb item will show a dropdown with allof the alternate representations Web Inspector provides for this resource.Selecting the "Response (DOM Tree)" will visualize the response content asa DOM tree, just like we want it. Similar alternate representations arealso provided for when the content is valid JSON, showing an object treeas if it were logged in the Console. These alternate representations arealso available when content is sent as part of a request.

In situations that you do find an issue in the resource's response, it'snot always easy to make a change to the source code that the resource wasloaded from, as it may exist on a faraway server or involve complicated pre-processing steps.

I am very excited to tell you that this year, Web Inspector has added anew feature to solve this exact problem. We call them "Local Overrides."Creating one is as simple as clicking the "Create Override" button when viewingany resource which will automatically copy the current contents of thatresource into a new local override for that resource. They are fully editableand are preserved by Web Inspector across sessions of both the inspectorpage and Web Inspector itself. So let's try making a simple change to seea local override in action. Scrolling down in the content area, we can seethe "WebKit" text in the . We can change this "WebKit" text to somethinglike "Hello WWDC!" instead. If we take a look at the inspected page and reload,we can see that the "WebKit" text in the  of the inspected page changesto match the edits we just made. Even better, local overrides support morethan just modifying the response's content. If you right-click on the localoverride in Web Inspector and select the "Edit Local Override…" action, it'salso possible to modify the HTTP status code or any HTTP headers. When theinspected page loads anything over the network that matches any local override's URL,the entire response, including the HTTP status code and any HTTP headers, willbe completely replaced by the local override as it's been configured.Whenever this happens, the icon of the overridden resource will change, indicatingthat it was replaced. And this overridden icon is shown anywhere that theresource can be seen throughout Web Inspector. As further proof, if we selectthe overridden resource and scroll down, the same modifications we madeto the content are also present. All resources, including the main resourcelike we just saw and even non-text resources, like images, can be overriddenand fully configured from within Web Inspector. Sometimes, however, it'snot necessarily a particular resource that you want to change but reallya JavaScript API provided by WebKit. In these cases, you'll want to usethe new Inspector Bootstrap Script which can be added from the add resourcebutton in the bottom corner of the navigation sidebar in the Sources Tab,by selecting the Inspector Bootstrap Script action. Similar to how localoverrides allow you to modify resources loaded over the network,the Inspector Bootstrap Script can be thought of as a way to modifythe JavaScript API surface itself. The contents of the Inspector BootstrapScript are guaranteed to run before anything else in the inspected page.Hence, the "bootstrap" name. This allows you to do things like swizzle built-infunctions to see where they get called or setup some global state thatcauses your code to log additional debugging information.

Just like local overrides, the Inspector Bootstrap Script is preservedby Web Inspector across sessions of both the inspected page and Web Inspector itself.Speaking of debugging JavaScript, we've also added a number of new global breakpoints.

The Debugger Statements breakpoint controls whether or not JavaScript executionis paused at 'debugger' statements. Previously, the only way to control thiswas to completely disable all breakpoints. We felt this was unnecessarily restrictive,so we created this separate control to allow you to use other types ofbreakpoints while simultaneously disabling 'debugger' statements specifically.The other new breakpoints, since they relate to specific APIs, must be enabledby clicking on the add breakpoint button which will show a menu with actionsthat each enableone of these new breakpoints. So let's go through each of themone by one. The All Microtasks breakpoint will pause JavaScript executionwhenever any microtask is about to be executed, such as from 'Promise'objects or the 'queueMicrotask()' global function. Along these lines, the All AnimationFrames breakpoint does the same for 'requestAnimationFrame' callbacks.The All Timeouts breakpoint does the same for 'setTimeout' callbacks and theAll Intervals breakpoint does the same for 'setInterval' callbacks. Lastly, theAll Events breakpoint will pause before any callback is invoked for anyevent listener, even those unrelated to the DOM. But sometimes these globalbreakpoints are almost too global, in the sense that they pause more oftenthan desired. Let's take a look at an example using the All Events breakpoint.

I have a simple page that uses jQuery to add an event listener to aelement. Because I've enabled the All Events breakpoint, I wouldexpect to pause inside this event listener. But in reality, jQuery wrapsmy event listener callback with its own logic. So instead, we pause injQuery's event listener wrapper which is not really ideal as none of thisis my code. Really, what I want to do is have this breakpoint pause in mycode after all of jQuery's code has run.

Script blackboxing is a new feature that allows you to do just that – instructingthe JavaScript debugger to defer any pause that would occur in a scriptto pause at the first expression to execute outside of that script.We can do this to jQuery by hovering over the jQuery resource in thenavigation sidebar and clicking on the button that appears. Now, if we triggerthis breakpoint again, we should pause in our event listener instead.If, for some reason, you still do want to dig into the library/frameworkcode, Web Inspector will still show any call frames from blackboxed Script,greying them out to indicate their blackboxed nature. For larger librariesand frameworks, it's also possible to blackbox multiple scripts at onceby configuring regular expression patterns to match against the script'sURL in the Settings Tab.

In addition to some of the global breakpoints we've seen so far, WebInpector also allows you to set breakpoints on specific lines of JavaScripteven after pretty printing. Clicking on any line in the gutter area of the content preview,Will add a JavaScript breakpoint that will pause right before that line executes.Because JavaScript is so flexible with its syntax, however, it's not uncommonto see lots of operations combined onto a single line using a mix of various operators.In this case, the logical "or" operator. Previously, if I wanted to pause insidethe 'c' function call and I didn't know where 'c' was declared to set a breakpoint,the only way to do this would be to use the Step In JavaScript debuggeraction to step into "a()".And, then, step out to move past 'a', then, step in again to go inside 'b',And finally, step back out, again, to arrive at 'c'.

This is a very tedious process with lots of opportunity for mistakes whichcan be incredibly frustrating, especially in cases where the starting stateis hard to reach.This has led us to introduce a new JavaScript debugger action which we call Step.

Unlike the Step Over JavaScript debugger action, which resumes and re-pausesexecution before the next statement in the current call frame, which inthis case, would be after the entire 'foo' variable declaration, this newStep debugger action will resume and re-pause Javascript execution beforethe next expression in the current call frame. And just like that, we'veresumed, executed 'a' and re-paused on the same line without ever having to Stepin or Step out. Once more, we can Step to resume execute 'b' and re-pausearriving at the call for 'c'.

This Step JavaScript debugger action provides more fine grained controlover how the JavaScript debugger execution head moves through the program,allowing for fewer stepping mistakes and even less actions in total.

But sometimes scripts are inlined in HTML. In the past, there was noway to pretty print this inlined script content or even any of the surrounding HTML.As a result, it was often difficult to set breakpoints or even step throughcode in a nicely readable way. I'm very happy to say that in the latestSafari, Web Inspector now supports formatting HTML and other XML-likecontent, including inline scripts and style sheets, allowing supportfor all of the existing JavaScript debugger and stepping capabilities too.Simply click on the pretty print button in the top right of any text-basedcontent preview, to toggle between the original content and the pretty printed version.

Web Inspector will also attempt to detect when HTML has been minifiedand automatically toggle pretty printing, just like it has always done forJavaScript and CSS content. So speaking of Web Inspector functionality,there's so much more than just viewing resources. So, let's move on to someof the other powerful or more specialized features starting with the Timelines Tab.

The Timelines Tab contains the majority of performance profiling toolsoffered by Web Inspector. It captures activity in the inspected page duringwhat we call a "recording" which organizes and plots the data into one ofa handful of different timelines based on the type of data.

Timeline recordings can also be exported and imported allowing you to sharethem with others or save them for later use. The main change this yearin the Timelines Tab, is an introduction of an entirely new timeline, whichyou can activate by clicking the Edit button in the main graph area.This will put us in edit mode where we can enable or disable any of the various timelines.The new timeline we've added this year is the Media & Animations timelinewhich captures events related to media elements, like  or , andalso captures the lifecycle of CSS animations and CSS transitions.After checking the checkbox to enable the Media & Animations timeline and clicking the Donebutton to leave Edit mode, if we reload the inspected page we can see alist of all media elements, CSS animations and CSS transitions that havehad any activity during the recorded interval. Each individual media element,CSS animation or CSStransition has its own row in the table with linksto any related DOM node or information about the CSS 'animation-name' orCSS 'transition-property'. The Media & Animations timeline can alsobe used to correlate activity captured in other timelines with state changesin any media elements, such as a video being paused or the creation or destructionof any CSS animations or CSS transitions to figure out what's going onand understand why. And that's a quick look at the Media & Animationstimeline in the Timelines Tab.Let's move on to the Storage Tab. So the Storage Tab contains a list ofall of the data stored by the inspected page in the browser via thingslike cookies or LocalStorage or IndexedDB. This year, we've added filteringcapabilities for all storage types and improved editing and deleting capabilitiesespecially for cookies. The new filtering capabilities take the form ofan always visible filter bar shown at the top of most storage views. As an example,filtering cookies is as simple as typing some text into the filter barwhich is compared against the various fields of each cookie, hiding anyrows that had no matches. The second major feature is the ability to edit cookies.Double clicking on one of a cookie's cells, will show a popover with inputsfor each field of that cookie. All modifications made in this popover willbe applied as soon as the popover is dismissed. It is also possible to addentirely new cookies by clicking on the add cookie button which will showa similar popover. But, this time, all of the inputs will be empty.Note, that a name is required in order for a cookie to be added. Just like HTTPcookies, or those set by 'document.cookie', they will persist beyond Web Inspector,so be careful what you add. But many other features of the web are not persistent,so let's take a look at tooling for some of those. Starting with the allnew Graphics Tab.

For those of you who've used Web Inspector in the past few years, you mayremember using the Canvas Tab. The Graphics Tab expands the scope and functionalityof the Canvas Tab still showing all  contexts and shaders and supportingtaking recordings of JavaScript API calls made to  contexts, but nowalso listing all web animations including those created by CSS animations andCSS transitions, providing in-depth information about each. The previouslyavailable information about all  contexts in the inspected page isstill shown in the Canvases section at the top, followed by the new sectionsfor the various types of animations created by the web animations API separatedby how they're created, such as from JavaScript, CSS animations or CSS transitions.

Clicking on one of these animations will expand the details sidebar whichcontains all of the information about the selected animation, such as theID which can be thought of as the animation's name, the associated nodeof the animation, the configured timing parameters, like the number of iterationsor the total duration, the keyframes list, each item containing a list ofCSS properties and values that are interpolated between as the animation progresses,and, finally, for animations that are created by the JavaScript API,a backtrace for how the animation was created.

Clicking the markup icon in the header of any animation, will show a contextmenu with a number of utility actions, such as Log Animation which willsave the JavaScript object for that Web Animation in a temporary variablein the Console (in this case '$1'), allowing us to have easy accessfor manipulating it using the powerful Web Animations API. For more informationabout the new Web Animations API, be sure to check out the "What's New forWeb Developer" session in your Developer app. But sometimes animations areconfigured incorrectly, which causes performance problems. So, let's takea look at the new Layers Tab to see how it can help. The Layers Tab showsa live view of the layer tree of the inspected page, listing the memorycost and the paint count for each layer. While it's not exactly one to one,it's generally a good idea to keep the number of unintended layers as lowas possible, as a greater number of layers can be associated with increasedmemory use and worse performance. The keyword there though is "unintended"which really requires you, the developer, to know your layout and when thingsshould and should not create a layer. To assist with this, clicking on alayer either in the visualization itself or in the detailed sidebar, will showinformation about that layer, such as why it was created. In the case ofthe currently selected layer, it was created because the associated nodewas being animated by CSS and how to CSS 'will-change' property. The entirelayer tree visualization can also be manipulated using common orbit controlssuch as rotating vertically by clicking and dragging up and down,rotating horizontally by clicking and dragging left and right, zooming by scrollingin and out and panning by right-clicking and dragging, making it easy tofind layers visually to find out more about them. So now let's move on toour final tab, the Console. The Console Tab lists all of the various messageslogged by the inspected page and allows arbitrary JavaScript evaluationin the inspected page. Special functionality is also exposed while evaluatingJavaScript, intended to make inspecting and debugging JavaScript easier byproviding more information previously known only to WebKit. There are awhole bunch of these Console-only specially exposed bits of functionalitythat are new this year, but there are two that are particularly noteworthy.The first is called "queryInstances." So let's imagine a simple JavaScriptclass hierarchy of an 'Animal' base class with a 'Pet' subclass. Now let'ssay that we want to find all instances of this 'Pet' subclass. One way todo it, would be to examine a captured heap snapshot in the Timelines Tab,but that includes a lot of other information that is likely not relevant.So instead, 'queryInstances' when given a constructor, will scan the entireJavaScript heap for instances of objects that inherit from that given constructor,returning them all in an array that can be further manipulated in the Console.As we can see here, there is one instance of this 'Pet' class, which is heldin the variable with the name 'buddy.' Note, however, that due to the natureof JavaScript inheritance, the term "instance" also applies to subclassobjects as well. As an example, if we call 'queryInstances' with the 'Animal'constructor, we will not only see the previously seen 'buddy' variable butwe will also see an instance of 'Animal' held by the 'cat' variable and eventhe entire 'Pet' class as it also inherits from the 'Animal' class. For moreflexibility, it's also possible to provide a prototype instead of a constructorwhich will have the exact same result we saw earlier with the related constructor.

The second noteworthy function is called 'queryHolders.' So again, let'simagine a simple JavaScript class called 'Person.' Similar to reality,each 'Person' can have a 'parent.' This is represented in JavaScript as a 'parent'property whose value is the other 'Person' object. This is called a strongreference and is a common cause a memory leaks in JavaScript programs.If we wanted to find all objects that have a strong reference to a givenobject, we could examine a captured heap snapshot in the Timelines Tab,but again this may include other information that is likely not relevant.

Instead we can use the 'queryHolders' Console function which, when givenan object, will scan the entire JavaScript heap for all other objects thathave a strong reference to that given object. As we can see in this example,'alice' has a strong reference to 'john' through its 'parent' property whichis why 'alice' appears in the array returned by 'queryHolders.' Now let'stalk about our last feature for today. I'm very happy to announce thatin the latest Safari, so long as Web Inspector is already open, enablingIntelligent Tracking Prevention Debug Mode from Safari's Develop menuwill cause all debug logging from Safari's Intelligent Tracking Preventionto also appear in the Web Inspector Console, as well as in the macOS systemConsole.app. Additionally, logs for Ad Click Attribution Debug Modewill also be shown in the Web Inspector console, which can be enabledfrom the Experimental Features submenu of Safari's Develop menu. This way, you'llnever have to switch away from Safari to see all of the logs you mightfind useful. And with that we've, reached the end of our feature highlights.There is so much more coming in the latest Safari, including a ton of bugfixes and minor tweaks throughout Web Inspector. Before we finish up,there's a few general tips I'd like to leave you with. Tooltips are your friend.

If you're unsure of what something does, simply hover over it with yourcursor for a few seconds, and voila! The answer will appear. Every icon inWeb Inspector has a tooltip. All links have a tooltip. In fact, almost everycomponent of the interface has a tooltip. Web Inspector makes heavy useof iconography as there's a ton of varying functionality that has to fitinto a very limited amount of space. As such, it relies on tooltips to provideadditional explanation and description where there isn't enough room.For a similar reason, Context Menus are everywhere and they often contain additionalfunctionality that can't be accessed anywhere else. Many icons have a context menu.

Every link has a context menu. Again, almost every component of the interfacehas a context menu. And in fact, most of what we've done so far could havealso been done via a context menu action. For much of the same reasonas tooltips, Web Inspector puts a lot of functionality into context menuactions as there isn't enough room for each action to have its own componentin the interface. For more tips like those, there's an all new section ofthe WebKit website that talks specifically about Web Inspector. It containsa bunch of reference pages that each explore both the breadth and the depthof various features, parts of the interface and more. In fact, many of thefeatures we talked about today already have reference pages and we're workingon writing even more from many of the others. Also, be sure to follow@webkit on Twitter as we post weekly tips about various features in Web Inspector.

And I'd also highly recommend using Safari Technology Preview for yourdaily development, as it gets bi-weekly updates with bug fixes and new features,both to Web Inspector and to the rest of WebKit. Be sure to check outthis session's related resources for other sessions about some of thesenew features, as well as links to our documentation. I really hope you'veenjoyed learning about what's new in Web Inspector and I hope you findthat as things we've discussed useful for understanding and debugging webcontent in the future.Thank you so much for listening and
I hope you have a wonderful WWDC.

## Code Samples


WEBVTT

00:00:22.516 --> 00:00:28.026
[ Applause ]

00:00:28.526 --> 00:00:30.126
>> DAN OMACHI: Good morning,
welcome to the second part

00:00:30.126 --> 00:00:31.816
of our What's New in
Metal presentation.

00:00:32.036 --> 00:00:33.436
My name is Dan Omachi.

00:00:33.866 --> 00:00:36.616
I'm an engineer in Apple's
GPU software frameworks team.

00:00:37.206 --> 00:00:40.226
Today my colleague Anna
Tikhonova and I will talk

00:00:40.226 --> 00:00:42.756
about technologies
that build upon Metal,

00:00:43.166 --> 00:00:46.266
helping you deliver great
rendering experiences

00:00:46.376 --> 00:00:49.136
on both iOS and OS X.

00:00:50.416 --> 00:00:53.506
So this is the second
of three sessions

00:00:53.606 --> 00:00:56.586
at this years WWDC
talking about Metal.

00:00:57.546 --> 00:01:01.386
In the first session, Rob
Duraf talked about developments

00:01:01.386 --> 00:01:03.266
in Metal that have
happened in the past year.

00:01:04.025 --> 00:01:06.206
He also described some
of the new features

00:01:06.206 --> 00:01:08.096
in Metal we just released.

00:01:09.476 --> 00:01:12.686
He also described how app
thinning is a great match

00:01:12.816 --> 00:01:14.316
for your Metal applications.

00:01:14.856 --> 00:01:19.496
In this session, I will be
up here first to talk to you

00:01:19.496 --> 00:01:23.886
about MetalKit, convenience
APIs allowing you bring

00:01:23.886 --> 00:01:26.556
up Metal applications
much more quickly.

00:01:27.486 --> 00:01:30.026
Then Anna will come up to talk

00:01:30.026 --> 00:01:32.356
about Metal performance
shaders framework,

00:01:32.956 --> 00:01:36.086
which offers great shaders

00:01:36.806 --> 00:01:40.276
for common data parallel
operations available

00:01:40.276 --> 00:01:42.666
on iOS devices with
an A8 processor.

00:01:43.186 --> 00:01:46.636
And tomorrow, you
will get a chance

00:01:47.036 --> 00:01:50.416
to catch the Metal Performance
Optimization Techniques session,

00:01:50.886 --> 00:01:54.346
where they will introduce
the Metal System Trace Tool

00:01:54.926 --> 00:01:57.396
and provide you with
some best practices

00:01:57.796 --> 00:02:00.356
for shipping an efficient
Metal application.

00:02:00.356 --> 00:02:04.966
So let's get started
with Metal kit.

00:02:05.226 --> 00:02:08.186
Utility functionality
for your Metal apps.

00:02:09.616 --> 00:02:13.586
So because Metal is a low
level API, there are a number

00:02:13.586 --> 00:02:17.616
of things you need to do
to get up and running.

00:02:17.766 --> 00:02:20.346
MetalKit hopes to help with this

00:02:20.346 --> 00:02:22.596
by providing efficient
implementation

00:02:22.856 --> 00:02:24.956
for commonly used scenarios.

00:02:25.466 --> 00:02:28.576
This requires less effort
on your part to get up

00:02:28.576 --> 00:02:31.936
and rendering and we offer
increased performance

00:02:32.056 --> 00:02:35.676
and stability over the
standard boilerplate code

00:02:35.866 --> 00:02:37.416
that you might implement
yourself.

00:02:38.156 --> 00:02:41.246
There is less maintenance
for you as the burden

00:02:41.246 --> 00:02:45.786
of that maintenance has
been shifted from you to us.

00:02:46.046 --> 00:02:49.966
So MetalKit consists of
three main components.

00:02:50.926 --> 00:02:53.236
First is the MetalKit view.

00:02:53.506 --> 00:02:57.656
A unified view class
between iOS and OS X

00:02:58.206 --> 00:02:59.596
for rendering your Metal scenes.

00:03:01.126 --> 00:03:05.666
Second is the texture loader
which creates texture objects

00:03:06.016 --> 00:03:08.576
from image files on disk.

00:03:09.966 --> 00:03:14.556
And finally, Metal kit's model
I/O integration which loads

00:03:14.676 --> 00:03:17.176
and manages mesh data
from Metal rendering.

00:03:20.506 --> 00:03:23.366
MetalKit view is
the simplest way

00:03:23.486 --> 00:03:25.556
to get Metal rendering
on screen.

00:03:26.136 --> 00:03:31.746
It's a unified class
on both iOS and OS X.

00:03:32.006 --> 00:03:34.146
It offers pretty much
the same interface

00:03:34.406 --> 00:03:37.546
on both Operating Systems,
but naturally it's a subclass

00:03:37.546 --> 00:03:42.956
of UI view for iOS and a
subclass of NS view on OS X.

00:03:43.456 --> 00:03:48.126
Its main job is to manage
displayable render targets

00:03:48.126 --> 00:03:51.276
for you, and it creates
render path descriptors

00:03:51.326 --> 00:03:53.536
for these render
targets automatically.

00:03:53.536 --> 00:03:58.906
Now, it's super flexible
in terms of the ways

00:03:59.276 --> 00:04:02.206
that it can execute
your draw code.

00:04:03.436 --> 00:04:05.676
You can use a timer-based mode

00:04:06.206 --> 00:04:09.056
where it will execute your
draw code at a regular interval

00:04:09.456 --> 00:04:11.416
in synchronization
with a display,

00:04:12.806 --> 00:04:14.366
or you can use an
event-based mode

00:04:14.366 --> 00:04:16.776
which will trigger your
draw code whenever a touch

00:04:16.826 --> 00:04:19.836
or UI event has occurred, so
you can respond to that event.

00:04:21.055 --> 00:04:23.836
Finally, you can explicitly
drive your draw code,

00:04:24.156 --> 00:04:27.066
perhaps in an open loop
on a secondary thread

00:04:27.686 --> 00:04:29.096
at your own frame rate.

00:04:29.726 --> 00:04:35.676
So there are two approaches
to using the MetalKit view.

00:04:37.146 --> 00:04:39.586
The simplest approach is
to implement a delegate

00:04:39.716 --> 00:04:42.556
to handle your draw
and resize operations.

00:04:43.336 --> 00:04:45.756
In this case, you would
implement the draw

00:04:45.756 --> 00:04:50.386
in view method to handle your
per-frame updates including

00:04:50.726 --> 00:04:52.456
encoding any rendering commands.

00:04:53.846 --> 00:04:56.006
You would also implement
the view will layout

00:04:56.126 --> 00:05:00.836
with size method to handle
size changes to your view.

00:05:01.466 --> 00:05:04.696
This is where you might
update your projection matrix

00:05:05.016 --> 00:05:06.966
or change any texture sizes

00:05:06.996 --> 00:05:09.366
to better fit your
displayable area.

00:05:10.836 --> 00:05:14.566
Now, if you have any other
pieces of the view that you need

00:05:14.566 --> 00:05:18.536
to override, you can
subclass the MetalKit view.

00:05:18.926 --> 00:05:20.896
And in this case on iOS,

00:05:21.666 --> 00:05:23.566
you would override
the draw Rect method

00:05:25.126 --> 00:05:26.466
to handle your per-frame updates

00:05:27.336 --> 00:05:30.346
and the layout subviews
method to handle resizes.

00:05:31.156 --> 00:05:33.706
Likewise on OS X
you would handle,

00:05:34.106 --> 00:05:36.516
you would override these
two methods, the draw Rect

00:05:36.516 --> 00:05:38.606
and set frame size method.

00:05:39.316 --> 00:05:49.756
So here is an example of
setting up a view controller

00:05:49.946 --> 00:05:53.166
that also serves as the
delegate to our view.

00:05:54.446 --> 00:05:58.896
In the view did load method,
after we received a reference

00:05:59.106 --> 00:06:02.976
to the view, we will assign
ourself as the delegate,

00:06:04.306 --> 00:06:11.516
and particularly important on OS
X is that we will need to choose

00:06:11.516 --> 00:06:13.376
and set a Metal device.

00:06:13.976 --> 00:06:18.136
Once we are done with
that, we can configure some

00:06:18.136 --> 00:06:21.186
of the view's properties
including choosing our own

00:06:21.186 --> 00:06:23.576
custom pixel formats
for the color

00:06:23.576 --> 00:06:24.836
and depth and stencil buffers.

00:06:25.516 --> 00:06:28.496
We can use multisampling

00:06:28.706 --> 00:06:32.336
by increasing the sample count
property to a value above 1,

00:06:32.336 --> 00:06:41.036
or we can set our
custom clear color.

00:06:41.196 --> 00:06:45.626
Now, here is a very basic
usage of the MetalKit view

00:06:45.796 --> 00:06:48.566
in the implementation
of the per frame update.

00:06:49.506 --> 00:06:53.336
In our drawing view method,
we call the views render,

00:06:53.336 --> 00:06:55.466
I'm sorry, current
render past descriptor.

00:06:55.966 --> 00:06:59.666
Now, the first time you access
this property each frame,

00:07:00.086 --> 00:07:02.516
the view will call
into core animation

00:07:02.816 --> 00:07:04.646
and get a drawable back,

00:07:05.256 --> 00:07:07.406
which you can encode
your rendering commands

00:07:07.406 --> 00:07:08.076
and render to.

00:07:08.686 --> 00:07:12.956
So we will render our
final render pass,

00:07:13.466 --> 00:07:15.196
which will show up
in this drawable.

00:07:15.726 --> 00:07:18.996
And then we will present the
drawable, which is stored

00:07:18.996 --> 00:07:20.736
in the view's current
drawable property

00:07:21.796 --> 00:07:24.866
and we will commit
our command buffer.

00:07:25.036 --> 00:07:26.776
Now, because of its importance

00:07:27.296 --> 00:07:30.396
in structuring your per-frame
updates, let me take a minute

00:07:30.656 --> 00:07:32.896
to talk about managing
these drawables.

00:07:33.586 --> 00:07:36.906
So there are a limited
pool of drawables

00:07:37.436 --> 00:07:40.026
in this system all
managed by core animation.

00:07:41.556 --> 00:07:44.246
There are only a few of them
mostly because of their size,

00:07:44.246 --> 00:07:45.456
they take up some space.

00:07:46.556 --> 00:07:49.346
Now, these drawables
are concurrently used

00:07:49.346 --> 00:07:52.456
through many stages of
the display pipeline.

00:07:53.916 --> 00:07:55.206
Here is roughly how it works.

00:07:55.656 --> 00:07:57.706
First, your application
encodes commands

00:07:57.706 --> 00:07:58.926
to be rendered onto
the drawable.

00:08:00.016 --> 00:08:02.216
It sends that drawable
down to the GPU

00:08:02.596 --> 00:08:05.656
as your application encodes
commands for the next frame

00:08:05.876 --> 00:08:09.766
and the GPU renders to that
drawable, and core animation

00:08:09.766 --> 00:08:11.666
at this stage may do compositing

00:08:11.666 --> 00:08:15.026
with other layers
into that drawable.

00:08:15.636 --> 00:08:19.726
And finally, the display
can take the drawable

00:08:19.726 --> 00:08:21.016
and slap it up onto the screen.

00:08:21.966 --> 00:08:24.086
Now, the display can't
replace it with anything

00:08:24.086 --> 00:08:25.806
until another drawable
is available.

00:08:26.106 --> 00:08:29.106
So if any of these previous
stages are taking a lot of time,

00:08:29.416 --> 00:08:31.166
it just has to sit
there for awhile.

00:08:31.606 --> 00:08:36.876
Additionally, the display can't
recycle that drawable back

00:08:36.876 --> 00:08:39.015
up to your frame until it
has something available.

00:08:39.015 --> 00:08:44.986
So let's take a look at
your application frame

00:08:45.436 --> 00:08:47.456
with respect to these drawables.

00:08:48.936 --> 00:08:51.796
First, you call the MetalKit
views current render past

00:08:51.796 --> 00:08:54.166
descriptor which
reserves a drawable.

00:08:54.166 --> 00:08:59.176
Then you will encode rendering
commands that you want

00:08:59.176 --> 00:09:02.136
into that drawable, and
finally you will present

00:09:02.236 --> 00:09:03.196
and commit the drawable

00:09:03.396 --> 00:09:06.366
which will release it
back to core animation.

00:09:06.926 --> 00:09:11.266
Now, this is fine if all we
are doing is rendering a single

00:09:11.266 --> 00:09:13.156
render pass, however,

00:09:13.156 --> 00:09:16.246
it's likely we will
do other operations

00:09:16.856 --> 00:09:24.216
such as some app logic, encoding
in offscreen render pass

00:09:24.456 --> 00:09:28.076
where we don't actually
need the drawable,

00:09:28.076 --> 00:09:31.166
or running some compute
kernels for physics or whatnot.

00:09:31.716 --> 00:09:36.426
In this case we are
essentially hogging the drawable

00:09:36.426 --> 00:09:39.216
from our future self because
in a subsequent frame,

00:09:39.216 --> 00:09:41.816
we will call this current
render pass descriptor

00:09:42.256 --> 00:09:44.996
and it will sit there
waiting for a drawable

00:09:44.996 --> 00:09:47.176
to become available,
which may not be the case

00:09:47.176 --> 00:09:50.936
because we are doing these other
operations and reserving it

00:09:50.936 --> 00:09:52.186
for much longer than we need to.

00:09:52.606 --> 00:09:54.086
So to solve this problem,

00:09:54.876 --> 00:09:58.136
let's put these operations
before our access

00:09:58.246 --> 00:09:59.906
to the current render
pass descriptor.

00:10:00.436 --> 00:10:04.306
Now, let me just note that
this isn't a problem specific

00:10:04.396 --> 00:10:05.536
to the MetalKit view.

00:10:05.896 --> 00:10:08.816
You need to be aware of this
issue if you roll your own view

00:10:09.066 --> 00:10:11.056
in access core animation
directly.

00:10:12.126 --> 00:10:17.656
So this is information that's
quite useful in any case.

00:10:18.526 --> 00:10:20.846
Now, here is a more
complete example

00:10:20.846 --> 00:10:22.806
of our per-frame
rendering update.

00:10:23.816 --> 00:10:27.316
First, as I described we want to
update our app's render state,

00:10:28.046 --> 00:10:29.866
encode any offscreen passes,

00:10:30.166 --> 00:10:31.986
do anything where we
don't need the drawable.

00:10:32.576 --> 00:10:36.266
And then we can continue
as we did previously,

00:10:36.266 --> 00:10:39.256
get the current render pass
descriptor, encode our commands

00:10:39.256 --> 00:10:41.996
for that final pass, and present
and commit our command buffer.

00:10:42.996 --> 00:10:46.166
The key point is that
these two stages should be

00:10:46.166 --> 00:10:48.236
as close together as possible.

00:10:49.016 --> 00:10:52.166
It's a critical section where
we are holding onto a resource

00:10:52.736 --> 00:10:57.386
and we don't want to hold onto
it any longer than we need to.

00:10:57.626 --> 00:10:58.476
That's it for the view.

00:11:00.216 --> 00:11:01.886
Let's move on to
the texture loader.

00:11:02.476 --> 00:11:06.036
It's textural loading
made simple.

00:11:07.096 --> 00:11:11.336
You give a reference and
you get back a fully formed

00:11:11.666 --> 00:11:12.446
Metal Texture.

00:11:13.006 --> 00:11:18.586
Not only is it simple, it's
fast and fully featured.

00:11:19.656 --> 00:11:22.226
It asynchronously decodes files

00:11:22.976 --> 00:11:26.486
and creates textures
on a separate thread.

00:11:27.936 --> 00:11:31.376
It has support for many common
image file formats including

00:11:31.376 --> 00:11:36.076
JPG, TIF and PNG and
also supports the PVR

00:11:36.336 --> 00:11:38.646
and KTX texture file formats.

00:11:38.996 --> 00:11:43.026
What's interesting about these
formats is that they store data

00:11:43.296 --> 00:11:47.166
in a raw form that can be
uploaded to your Metal Texture

00:11:47.166 --> 00:11:48.516
without any conversion.

00:11:49.516 --> 00:11:54.996
Additionally, you can encode
data for MIT maps for any

00:11:55.146 --> 00:11:58.896
of the other types of
textures including 3D textures,

00:11:59.336 --> 00:12:01.886
cube maps, and texture arrays.

00:12:05.716 --> 00:12:07.206
Its usage is really simple.

00:12:08.716 --> 00:12:10.976
First, we create a
texture loader object

00:12:11.416 --> 00:12:13.386
by supplying a device.

00:12:14.916 --> 00:12:17.586
Then, once we have that
texture loader object,

00:12:17.586 --> 00:12:20.356
we can create many
textures with it.

00:12:21.196 --> 00:12:26.116
First, we will give a URL
location of our image file,

00:12:26.786 --> 00:12:29.996
and we can supply a number of
options including how we want

00:12:29.996 --> 00:12:33.886
to treat the sRGB information
in the file or whether

00:12:33.886 --> 00:12:36.136
or not we want to allocate
memory for MIT maps

00:12:36.546 --> 00:12:37.866
when we create this texture,

00:12:38.496 --> 00:12:42.426
and finally we will supply
a completion handler block.

00:12:42.936 --> 00:12:45.526
Now, this block will
get executed as soon

00:12:45.526 --> 00:12:48.206
as the texture loader has
finished loading the texture

00:12:48.276 --> 00:12:49.086
and created it.

00:12:49.166 --> 00:12:51.056
It will pass the texture
handler back to you

00:12:51.096 --> 00:12:54.086
which you can stash away
for later and render

00:12:54.086 --> 00:12:57.166
with when you need to.

00:12:57.356 --> 00:12:59.396
That's very simple,
the texture loader.

00:12:59.506 --> 00:13:02.686
Let's move on to model I/O.

00:13:04.496 --> 00:13:07.236
So model I/0 is a new
framework introduced

00:13:07.236 --> 00:13:09.396
with iOS 9 and OS X El Capitan.

00:13:11.236 --> 00:13:13.246
And one of its key features is

00:13:13.246 --> 00:13:17.696
that it can load many
model file formats for you.

00:13:19.006 --> 00:13:22.336
You can create your own
importers and exporters

00:13:22.366 --> 00:13:25.056
for proprietary formats
if you need to.

00:13:25.056 --> 00:13:28.776
Some of the cooler
features here are

00:13:28.776 --> 00:13:32.806
that you can do offline
baking operations.

00:13:32.806 --> 00:13:36.286
You can create static
ambient occlusion maps,

00:13:36.826 --> 00:13:40.856
light map generations, it
also includes the Voxelization

00:13:40.956 --> 00:13:41.656
of your meshes.

00:13:42.256 --> 00:13:48.536
It provides you a way to
focus on your rendering code

00:13:48.536 --> 00:13:49.636
and write your shaders.

00:13:49.706 --> 00:13:52.346
You don't have to deal
with creating some parchers

00:13:52.346 --> 00:13:53.766
to get some stuff off disk.

00:13:53.766 --> 00:13:57.106
You have to deal less
with serialization,

00:13:57.776 --> 00:14:00.606
you just load a model
file with Model I/O,

00:14:01.636 --> 00:14:03.566
put it into some form
you can render it with,

00:14:04.246 --> 00:14:06.596
and start writing your shaders.

00:14:06.596 --> 00:14:12.216
So what does MetalKit
provide in this context?

00:14:12.216 --> 00:14:15.456
It's utilities to efficiently
use model I/O with Metal.

00:14:16.796 --> 00:14:19.636
It offers optimized
loading of model I/O meshes

00:14:19.636 --> 00:14:23.786
into Metal buffers, the
encapsulation of mesh data

00:14:24.206 --> 00:14:28.606
within MetalKit objects, and
there are a number of functions

00:14:28.606 --> 00:14:31.676
to prepare mesh data
for Metal pipelines.

00:14:32.326 --> 00:14:40.356
Let me walk you through the
process of loading a model file

00:14:41.426 --> 00:14:46.026
with model I/O and getting it
rendering on screen with Metal.

00:14:46.596 --> 00:14:53.626
And here are the
steps we will take.

00:14:53.846 --> 00:14:58.986
So first, we will create a
Metal render state pipeline

00:14:58.986 --> 00:15:01.866
that we'll use to create our
mesh, to render our mesh.

00:15:02.406 --> 00:15:06.256
Then we will actually
load the model file

00:15:06.336 --> 00:15:09.426
by initializing the
model I/O asset.

00:15:10.456 --> 00:15:14.506
And with that asset, we
will create MetalKit mesh

00:15:14.506 --> 00:15:16.076
and sub mesh objects.

00:15:17.496 --> 00:15:20.416
Finally, we will render
those objects with Metal.

00:15:22.216 --> 00:15:26.146
So let's focus on creating a
Metal Render State Pipeline

00:15:27.316 --> 00:15:29.436
and we will pay particular
attention

00:15:29.756 --> 00:15:33.356
to creating a vertex descriptor
that will describe the layout

00:15:33.356 --> 00:15:36.326
of vertices that we'll
need our mesh to be

00:15:36.326 --> 00:15:40.086
in to feed our pipeline.

00:15:40.086 --> 00:15:43.226
Here is the bare bones
of a vertex shader.

00:15:45.046 --> 00:15:48.306
It uses the stage in
qualifier which basically says

00:15:48.306 --> 00:15:51.776
that our per vertex
inputs, the layout for them,

00:15:52.306 --> 00:15:54.426
will be described
outside of the shader

00:15:54.426 --> 00:15:58.156
in our objective-C code
using a vertex descriptor.

00:15:59.626 --> 00:16:02.386
It uses this vertex
input structure

00:16:03.556 --> 00:16:04.706
which is defined up here.

00:16:06.096 --> 00:16:09.406
And the key part of this vertex
input structure are these

00:16:09.506 --> 00:16:13.026
attributes, the indices here
which we will use to connect

00:16:13.026 --> 00:16:16.306
up outside inside of
our Objective-C code.

00:16:17.136 --> 00:16:22.136
Note that these floating-point
vector types define how the data

00:16:22.136 --> 00:16:27.456
looks within the shader, not
actually how the data looks

00:16:27.456 --> 00:16:29.366
as it's being fed
into the shader

00:16:29.416 --> 00:16:30.686
from our Objective-C code.

00:16:33.036 --> 00:16:41.226
For that, we need to
create a vertex descriptor.

00:16:41.796 --> 00:16:46.296
Now, I'm going to put this
vertex input structure

00:16:46.296 --> 00:16:49.826
up here just for reference,
but let me just remind you

00:16:49.826 --> 00:16:53.136
that it does not define
the layout of the data

00:16:53.456 --> 00:16:54.796
as it's being fed
into the shader.

00:16:54.796 --> 00:16:57.256
We are actually creating
the Metal Vertex Descriptor

00:16:57.756 --> 00:17:01.146
that is down below.

00:17:01.826 --> 00:17:06.256
And for that, what we will
do is for attribute zero,

00:17:07.156 --> 00:17:12.796
the position will define as
using three floating points,

00:17:13.215 --> 00:17:14.876
three floating point values.

00:17:15.986 --> 00:17:23.756
For attribute one, the color
will specify that it's going

00:17:23.756 --> 00:17:26.736
to be composed of four
unsigned characters,

00:17:26.965 --> 00:17:29.666
not the four floats above,
four unsigned characters

00:17:29.906 --> 00:17:31.396
and it will have an offset

00:17:32.506 --> 00:17:40.906
of 12 bytes immediately
following the position data.

00:17:41.086 --> 00:17:46.636
Now, for the texture coordinates
in attribute 2, we will define

00:17:46.636 --> 00:17:49.026
that it uses two half floats.

00:17:49.586 --> 00:17:55.756
And that it immediately follows
the position and color data

00:17:55.836 --> 00:17:57.556
with an offset of 16 bytes.

00:17:58.056 --> 00:18:02.576
And finally, we will
specify that the size

00:18:02.576 --> 00:18:05.656
of each vertex is 20 bytes
by setting the stride

00:18:05.896 --> 00:18:07.646
to 20 for that buffer.

00:18:11.736 --> 00:18:15.676
Now, this defines the
layout of each vertex

00:18:15.786 --> 00:18:17.776
within our array of vertices.

00:18:17.776 --> 00:18:23.386
So now that we have got our
Metal Vertex Descriptor,

00:18:23.986 --> 00:18:26.046
we can assign it to our
render state pipeline,

00:18:27.636 --> 00:18:28.426
and with that render --

00:18:28.526 --> 00:18:31.016
excuse me, with the
render pipeline descriptor,

00:18:31.306 --> 00:18:34.256
we can create a Metal
Render State Pipeline.

00:18:35.776 --> 00:18:40.246
So let's move on to
actually loading our asset

00:18:41.056 --> 00:18:45.646
and using model I/O
for that task.

00:18:46.326 --> 00:18:49.086
And we will actually use the
vertex descriptor we just

00:18:49.086 --> 00:18:50.366
created in the previous step,

00:18:51.336 --> 00:18:55.056
along with a MetalKit
mesh buffer object,

00:18:55.516 --> 00:18:58.066
a mesh buffer allocator object.

00:18:58.876 --> 00:19:00.636
I will describe a
little bit more

00:19:00.636 --> 00:19:06.456
about its importance
as we continue.

00:19:06.556 --> 00:19:11.426
So the model I/O
vertex descriptor

00:19:11.686 --> 00:19:14.506
and Metal Vertex
Descriptor are very similar,

00:19:15.586 --> 00:19:18.726
but while the model I/O vertex
descriptor describes the layouts

00:19:18.726 --> 00:19:20.796
of vertex attributes
within a mesh,

00:19:22.336 --> 00:19:25.076
the Metal Vertex Descriptor
describes the layout

00:19:25.076 --> 00:19:27.156
of vertex attributes
as their input

00:19:27.666 --> 00:19:29.166
to a render state pipeline.

00:19:30.536 --> 00:19:33.696
Now, they are intentionally
designed to look similar

00:19:34.456 --> 00:19:38.386
as they contain attribute
and buffer layout objects,

00:19:39.376 --> 00:19:43.396
and the reason for this is
it simplifies the translation

00:19:43.396 --> 00:19:44.906
of one object to another.

00:19:47.366 --> 00:19:52.276
Now, each attribute in a model
I/O vertex descriptor has an

00:19:52.276 --> 00:19:53.866
identifying string base name.

00:19:54.836 --> 00:19:59.456
Model I/O assigns a default
name if one does not exist

00:19:59.486 --> 00:20:02.626
in the model file or that
model file does not support

00:20:02.626 --> 00:20:03.366
these names.

00:20:04.046 --> 00:20:07.046
These names include position,
normal, texture, coordinate,

00:20:07.046 --> 00:20:11.046
color, et cetera, and
model I/0 defines these

00:20:11.046 --> 00:20:14.746
with the string based
MDLVertex attribute constants.

00:20:15.856 --> 00:20:19.796
There are a number of files
including the Alembic file

00:20:19.796 --> 00:20:23.136
format where you can
customize those names.

00:20:23.796 --> 00:20:27.646
Be aware if you are changing
the names you will need

00:20:27.646 --> 00:20:31.806
to access these attributes
with those customized names.

00:20:32.406 --> 00:20:39.146
So we recommend that you create
a custom model I/O vertex

00:20:39.146 --> 00:20:42.366
descriptor, because by default
model I/O loads vertices

00:20:42.586 --> 00:20:43.816
as high-precision

00:20:44.066 --> 00:20:48.526
yet memory-hungry
floating-point types.

00:20:48.526 --> 00:20:52.446
This is one of the
advantages of using model I/0.

00:20:52.916 --> 00:20:58.976
You can actually load a model
format and have the vertex data

00:20:58.976 --> 00:21:03.486
in any form that you would like
and use model I/0 to massage

00:21:03.536 --> 00:21:06.596
that data into a format
you can actually use.

00:21:07.306 --> 00:21:09.766
In this case, we want
to feed the pipelines

00:21:10.126 --> 00:21:11.206
with the smallest type

00:21:11.596 --> 00:21:13.796
that meets your precision
requirements.

00:21:14.186 --> 00:21:17.686
This would improve your
vertex bandwidth efficiency;

00:21:18.036 --> 00:21:20.716
as you are feeding each
vertex to the pipeline,

00:21:21.066 --> 00:21:23.086
you don't really want
a bloated vertex.

00:21:23.626 --> 00:21:28.756
So here is the layout
we defined previously

00:21:28.756 --> 00:21:30.906
when creating our Metal
Vertex Descriptor.

00:21:31.456 --> 00:21:37.186
Now, we will create our
model I/O vertex descriptor

00:21:37.606 --> 00:21:42.406
by calling this MTK model
I/O vertex format from Metal

00:21:42.486 --> 00:21:45.426
and we will supply our
Metal Vertex Descriptor.

00:21:45.716 --> 00:21:51.546
This builds the majority of this
model I/O vertex descriptor,

00:21:52.376 --> 00:21:55.786
yet we still need to tag
each attribute with a name,

00:21:55.786 --> 00:21:59.136
so model I/O knows what
we are talking about.

00:22:00.066 --> 00:22:03.646
So for attribute
0, we will tag it

00:22:03.646 --> 00:22:06.216
with the vertex attribute
position name.

00:22:07.446 --> 00:22:10.846
And similarly for attribute
1 and 2, we will tag them

00:22:10.846 --> 00:22:13.696
with a color and texture
coordinate attributes.

00:22:17.036 --> 00:22:20.096
The other thing we will do here
is we will create a MetalKit

00:22:20.356 --> 00:22:24.466
mesh buffer allocator and we
will supply a Metal device.

00:22:24.996 --> 00:22:29.376
Now, what this object does
is it allows model I/0

00:22:29.906 --> 00:22:35.116
to load vertex data directly
into GPU backed memory.

00:22:35.936 --> 00:22:39.056
Now, you don't have to use a
MetalKit mesh buffer allocator,

00:22:39.856 --> 00:22:44.206
but what that will do is it
will allocate system memory

00:22:44.676 --> 00:22:49.876
for these vertex and index
buffers inside of the mesh.

00:22:50.136 --> 00:22:53.596
And when you want to actually
render it, we will need to copy

00:22:53.626 --> 00:22:56.816
from that system memory down
into the GPU backed memory.

00:22:56.816 --> 00:23:01.926
So for efficiency, it's
really desirable to use one

00:23:01.926 --> 00:23:05.026
of these mesh buffer allocators,
and here is how you use it.

00:23:06.106 --> 00:23:09.856
Now, we are going to
load our asset file.

00:23:10.086 --> 00:23:16.806
We will supply the URL location,
the model I/0 vertex descriptor

00:23:16.806 --> 00:23:19.996
which will tell model I/0
how to lay out each vertex

00:23:21.366 --> 00:23:24.406
and we will also supply
this mesh buffer allocator

00:23:24.996 --> 00:23:28.006
so that model I/0 can
load this data directly

00:23:28.006 --> 00:23:29.656
into GPU backed memory.

00:23:30.916 --> 00:23:35.336
So now that we have
got our asset,

00:23:35.556 --> 00:23:37.986
let's actually create
some MetalKit mesh

00:23:37.986 --> 00:23:39.146
and some mesh objects.

00:23:39.146 --> 00:23:43.636
So here's an example of an asset

00:23:43.636 --> 00:23:47.686
that might be created
by model I/0.

00:23:47.866 --> 00:23:51.606
Inside of an asset, we
might have camera objects,

00:23:53.236 --> 00:23:57.616
light objects, and
particularly important

00:23:57.616 --> 00:23:59.966
to us right now are
the mesh objects.

00:24:00.346 --> 00:24:03.266
Now, MetalKit is
primarily concerned

00:24:03.266 --> 00:24:04.166
with these mesh objects.

00:24:04.166 --> 00:24:07.226
It doesn't really deal
directly with the light

00:24:07.336 --> 00:24:10.876
and camera objects because that
sort of data is very specific

00:24:11.166 --> 00:24:13.886
to your custom shaders
and your engines.

00:24:14.676 --> 00:24:18.246
You can actually
introspect into this object

00:24:18.246 --> 00:24:20.876
or go look inside this object
and grab out that camera

00:24:20.876 --> 00:24:23.806
and light information to
plug it into your shaders,

00:24:24.086 --> 00:24:27.106
but MetalKit isn't directly
involved in that process.

00:24:28.116 --> 00:24:38.066
So what we can do is pass
in this asset directly

00:24:38.066 --> 00:24:42.386
to this mesh, meshes
from asset class function

00:24:42.756 --> 00:24:46.246
which will create an
array of MetalKit meshes.

00:24:50.636 --> 00:24:54.006
Let's take a look at what's
inside this mesh object.

00:24:55.276 --> 00:24:57.476
So first are these
vertex buffers

00:24:57.476 --> 00:25:00.106
which includes the
position attributes,

00:25:00.366 --> 00:25:04.006
the normal attributes,
textural attributes, et cetera.

00:25:04.406 --> 00:25:07.496
In our example, we
only needed one array

00:25:07.696 --> 00:25:09.366
because we interleaved
all of our data.

00:25:09.946 --> 00:25:13.696
However, you can define the
layout to use multiple arrays,

00:25:13.696 --> 00:25:17.216
and therefore you would have
multiple vertex buffers.

00:25:17.376 --> 00:25:21.326
You could define that
attribute 0 would be inside

00:25:21.426 --> 00:25:23.966
of a single array, so you would
have an array of positions

00:25:24.476 --> 00:25:28.156
in one array, an array of
texture coordinates in the next,

00:25:28.636 --> 00:25:32.056
another array with
colors, and so on.

00:25:35.276 --> 00:25:37.696
The mesh also includes
a vertex descriptor

00:25:37.696 --> 00:25:39.336
which defines this layout

00:25:39.436 --> 00:25:41.896
and it's the same object
we just created and passed

00:25:41.896 --> 00:25:45.266
in when we initialized
our asset.

00:25:46.026 --> 00:25:49.716
And finally, the mesh contains
a number of sub mesh objects.

00:25:50.086 --> 00:25:53.666
Now, the key part of each
sub mesh object is this index

00:25:53.696 --> 00:25:57.506
buffer, which references
vertices inside the

00:25:57.506 --> 00:25:59.846
vertex buffer.

00:26:00.016 --> 00:26:03.076
Additionally, there are a number
of properties which you can use

00:26:03.566 --> 00:26:08.556
to make a draw call with Metal.

00:26:08.696 --> 00:26:12.696
So now that we have
got our Metal kit mesh

00:26:12.696 --> 00:26:21.086
and sub mesh objects, let's
go ahead and render them.

00:26:21.586 --> 00:26:26.046
So first we will iterate
through each vertex buffer.

00:26:27.426 --> 00:26:29.796
Now, we may have a sparse
array, so we need to make sure

00:26:29.796 --> 00:26:32.136
that there is actually
something in each buffer,

00:26:32.136 --> 00:26:35.956
but once we are sure of
that, we can continue on

00:26:35.956 --> 00:26:39.716
and set the vertex buffer
in our render encoder.

00:26:40.696 --> 00:26:43.346
Now, the vertex buffer
actually has two properties,

00:26:43.556 --> 00:26:47.126
the buffer itself, and an
offset within the buffer

00:26:47.616 --> 00:26:50.026
where your vertex data resides.

00:26:50.026 --> 00:26:57.046
We also need to supply a buffer
index telling the pipeline

00:26:57.546 --> 00:26:59.316
exactly where the data is.

00:26:59.946 --> 00:27:03.826
Now, we will actually
render our mesh.

00:27:04.756 --> 00:27:06.466
We will iterate through
every sub mesh,

00:27:07.906 --> 00:27:10.156
and make our draw
index primitives call.

00:27:11.126 --> 00:27:15.506
Note here that the sub mesh
has all of the parameters

00:27:15.506 --> 00:27:18.496
for this draw index parameter.

00:27:20.416 --> 00:27:25.486
So today we posted this
MetalKit essentials sample

00:27:25.486 --> 00:27:28.696
on the WWDC 2015 site.

00:27:29.396 --> 00:27:31.356
I encourage you to download it.

00:27:31.356 --> 00:27:34.116
It describes a number of
the techniques I described.

00:27:34.506 --> 00:27:38.936
It uses model I/0 to load this
little airplane object that's

00:27:38.996 --> 00:27:44.666
stuffed in an OBJ file and
creates a MetalKit mesh

00:27:45.126 --> 00:27:47.226
and renders it on screen.

00:27:47.526 --> 00:27:51.186
So you can get an idea of
exactly how this is all done.

00:27:51.686 --> 00:27:55.966
So I encourage you
to check that out.

00:27:56.226 --> 00:27:58.356
So that's it for me,
my name is Dan Omachi,

00:27:58.616 --> 00:28:02.076
I will be at the Metal Lab
tomorrow if you have questions

00:28:02.076 --> 00:28:03.516
about topics I have discussed.

00:28:03.516 --> 00:28:07.366
I would like to welcome my
colleague, Anna Tikhonova

00:28:07.366 --> 00:28:12.336
on stage to talk about the Metal
performance shaders frameworks.

00:28:12.636 --> 00:28:12.976
Thank you.

00:28:13.516 --> 00:28:18.546
[ Applause ]

00:28:19.046 --> 00:28:19.386
>> ANNA TIKHONOVA: Good morning.

00:28:20.276 --> 00:28:22.676
Thank you, Dan, for the
introduction, my name is Anna

00:28:23.206 --> 00:28:26.086
and I will be talking to you
about Metal performance shaders.

00:28:26.266 --> 00:28:26.996
Let's get started.

00:28:27.946 --> 00:28:29.926
So first of all, what is it?

00:28:30.406 --> 00:28:34.276
It's a framework of optimized
high performance data parallel

00:28:34.276 --> 00:28:35.926
algorithms for the GPU in Metal.

00:28:37.066 --> 00:28:38.156
When and why would you use it?

00:28:39.136 --> 00:28:41.466
If you are writing
C code and you want

00:28:41.466 --> 00:28:42.996
to add a common sorting
algorithm

00:28:42.996 --> 00:28:46.486
to your CPU application, you are
very unlikely to implement one

00:28:46.486 --> 00:28:49.346
from scratch unless it
was out of self-interest.

00:28:49.976 --> 00:28:52.736
You are a lot more likely to
use the implementation provided

00:28:52.736 --> 00:28:56.746
to you by the library because
it's already been debugged

00:28:56.986 --> 00:28:58.096
and optimized for you.

00:28:59.006 --> 00:29:02.036
Likewise, if you wanted to add
an image processing operation

00:29:02.036 --> 00:29:05.496
to your CPU application,
on our platform,

00:29:05.496 --> 00:29:07.086
you would use the
accelerate framework

00:29:07.466 --> 00:29:08.716
because it uses vImage.

00:29:09.596 --> 00:29:10.796
It's a powerful,

00:29:10.796 --> 00:29:14.976
high-performance tuned image
processing framework for --

00:29:16.256 --> 00:29:19.136
that utilizes the CPU's
vector processing.

00:29:19.656 --> 00:29:21.536
These are just a few examples.

00:29:22.516 --> 00:29:25.636
The point is that there is
a rich environment available

00:29:25.636 --> 00:29:26.836
for your CPU applications.

00:29:27.496 --> 00:29:30.096
On the GPU the story
is a bit different,

00:29:30.866 --> 00:29:33.366
you simply have fewer
options but we would

00:29:33.366 --> 00:29:34.466
like to change the story.

00:29:34.546 --> 00:29:38.136
Our goal is to enrich your
Metal programming environment.

00:29:38.776 --> 00:29:42.536
We have selected a
collection of common filters

00:29:42.756 --> 00:29:45.746
that we see often used in
graphic processing pipelines

00:29:46.066 --> 00:29:47.956
in your image processing
applications and games.

00:29:49.736 --> 00:29:53.656
These algorithms are
optimized for iOS and available

00:29:53.906 --> 00:29:55.966
in iOS 9 for the A8 processor.

00:29:56.996 --> 00:30:00.306
The Metal performance shaders
framework has two goals,

00:30:00.786 --> 00:30:02.956
performance and ease of use.

00:30:03.336 --> 00:30:05.416
It's designed to
integrate easily

00:30:05.496 --> 00:30:06.726
into your Metal applications.

00:30:07.476 --> 00:30:10.136
It operates on Metal
resources directly.

00:30:10.596 --> 00:30:13.356
They are the input
and the output.

00:30:13.356 --> 00:30:14.936
We are not only giving
you collection

00:30:15.206 --> 00:30:18.086
of these high performance
optimized awesome kernels --

00:30:18.386 --> 00:30:22.156
we are giving you that, but
we are also taking care of all

00:30:22.156 --> 00:30:24.996
of the host code necessary
to launch these kernels.

00:30:25.716 --> 00:30:28.756
We take care of the
decision-making process of how

00:30:28.756 --> 00:30:30.996
to split up the work for
parallel computation.

00:30:31.556 --> 00:30:35.556
The work you have to do to take
advantage of this framework

00:30:35.556 --> 00:30:37.656
in your applications
usually amounts

00:30:37.656 --> 00:30:40.266
to only a few lines of code.

00:30:40.436 --> 00:30:42.636
It's as simple as calling
a library function.

00:30:44.226 --> 00:30:46.186
So now that I have introduced
the framework to you,

00:30:46.366 --> 00:30:48.306
let's take a look at the
available operations.

00:30:49.296 --> 00:30:52.396
Here is a full list and let's
start from the beginning.

00:30:52.666 --> 00:30:54.296
I will cover just a
few of these actually

00:30:54.476 --> 00:30:55.586
and I will show you examples.

00:30:56.756 --> 00:30:59.806
So first, the framework
supports the histogram filter

00:30:59.806 --> 00:31:02.726
and the histogram equalization
and specification filters.

00:31:03.846 --> 00:31:06.116
The equalization and
specification filters,

00:31:06.566 --> 00:31:10.596
they allow you to
change the distribution

00:31:10.596 --> 00:31:12.216
of color intensities
in your image.

00:31:12.446 --> 00:31:15.076
The equalization filter
is a special case.

00:31:15.536 --> 00:31:16.946
It changes the distribution

00:31:17.396 --> 00:31:20.016
from the current
distribution to the uniform one.

00:31:20.736 --> 00:31:23.046
And the specification
filter enables you

00:31:23.046 --> 00:31:24.866
to set any distribution
of your choice.

00:31:25.216 --> 00:31:27.606
You specify the histogram that
will be used in the filter.

00:31:30.576 --> 00:31:34.386
This is an example of
the equalization filter.

00:31:34.936 --> 00:31:40.186
It increases the global
contrast in the image.

00:31:40.366 --> 00:31:43.216
Here it brings out the rainbow
in the sky quite beautifully.

00:31:43.956 --> 00:31:45.446
One thing I'd like to mention

00:31:45.846 --> 00:31:48.606
about these filters is they
are not an end in themselves.

00:31:49.496 --> 00:31:51.606
They can be used as
an intermediate step

00:31:52.026 --> 00:31:53.476
in a more complex algorithm.

00:31:53.826 --> 00:31:57.336
The histogram filter can be
used as an intermediate step

00:31:57.336 --> 00:31:58.636
in implementing tune mapping,

00:31:58.966 --> 00:32:01.646
which is a technique commonly
used by graphics developers

00:32:02.096 --> 00:32:05.076
to approximate the appearance
of high dynamic range.

00:32:05.676 --> 00:32:09.756
So moving on, we also
support Lancos resampling.

00:32:10.226 --> 00:32:13.456
It's a high-quality resampling
algorithm that can used

00:32:13.576 --> 00:32:16.476
to downscale, upscale,
squeeze, and stretch images.

00:32:16.476 --> 00:32:21.906
In this example, I
stretched the image vertically

00:32:22.086 --> 00:32:24.566
and squeezed it horizontally
while preserving all

00:32:24.566 --> 00:32:25.506
of the image content.

00:32:27.396 --> 00:32:29.566
You also support the
thresholding filter.

00:32:30.156 --> 00:32:31.956
It can be used to
find image edges

00:32:32.076 --> 00:32:33.486
if chained with a Sobel filter.

00:32:34.746 --> 00:32:36.296
Let's take a look at an example.

00:32:36.776 --> 00:32:39.776
This is the output of
the thresholding filter,

00:32:39.776 --> 00:32:44.926
and now it's fed into the Sobel
filter to give you image edges.

00:32:46.626 --> 00:32:49.666
And finally we support
a whole range

00:32:49.666 --> 00:32:52.616
of convolution kernels
including general convolution,

00:32:52.616 --> 00:32:55.296
where you can specify your
own convolution matrix.

00:32:55.356 --> 00:32:57.716
And we also support
Gaussian blur,

00:32:57.936 --> 00:32:59.696
box tent, and Sobel filters.

00:33:00.196 --> 00:33:03.136
My final example will
be of a Gaussian blur.

00:33:03.766 --> 00:33:05.326
You should all be
very familiar with it;

00:33:05.706 --> 00:33:07.076
we like to use it in our UI.

00:33:07.806 --> 00:33:09.936
What if you wanted to
use a Gaussian blur

00:33:09.936 --> 00:33:11.426
in your own application,

00:33:12.366 --> 00:33:15.396
the Metal performance shaders
framework makes it very easy.

00:33:16.736 --> 00:33:17.616
How easy, you ask?

00:33:18.716 --> 00:33:20.186
I'm building some
anticipation here.

00:33:20.666 --> 00:33:23.206
It's just two lines of code.

00:33:23.536 --> 00:33:28.466
You first have to create a blur
filter object, and then you have

00:33:28.466 --> 00:33:33.356
to encode the filter
to the command buffer.

00:33:33.986 --> 00:33:35.796
And that's it [applause].

00:33:37.466 --> 00:33:38.226
Thank you, guys.

00:33:40.906 --> 00:33:43.716
And one thing I just wanted to
point out again and just note is

00:33:43.716 --> 00:33:47.536
that this API takes your common
Metal resources as input.

00:33:48.146 --> 00:33:50.036
Your device, your command
buffer, your textures.

00:33:51.096 --> 00:33:53.496
These are the Metal resources

00:33:53.496 --> 00:33:55.176
that you already create
in your application.

00:33:55.736 --> 00:33:59.116
And now that I have shown
you these two lines of code,

00:33:59.536 --> 00:34:01.816
let's take a look
at where they plug

00:34:01.816 --> 00:34:03.926
in into your current
Metal work flow.

00:34:04.436 --> 00:34:06.336
So this is a graphical
representation

00:34:06.336 --> 00:34:07.086
of your command buffer.

00:34:08.436 --> 00:34:10.686
It contains all of the
commands you are going

00:34:10.686 --> 00:34:11.866
to be submitting to the device.

00:34:12.716 --> 00:34:14.755
You do your work as
you usually would.

00:34:15.056 --> 00:34:17.025
You render your scene
by issuing draw calls

00:34:18.326 --> 00:34:21.206
and you do your post processing
effect by dispatching kernels.

00:34:21.545 --> 00:34:23.536
Now you have decided that one

00:34:23.536 --> 00:34:26.136
of your post processing effects
is going to be a blur filter.

00:34:26.976 --> 00:34:29.576
So this is exactly
where it goes.

00:34:30.346 --> 00:34:34.315
And don't forget that you still
have to submit your commands

00:34:34.315 --> 00:34:36.396
to the device as
you normally would.

00:34:36.396 --> 00:34:37.356
Nothing changes here.

00:34:38.106 --> 00:34:41.446
And now, if you would like
to look at the sample code

00:34:41.446 --> 00:34:43.466
for the example I was
just going through,

00:34:43.466 --> 00:34:44.485
you could do so right now.

00:34:44.485 --> 00:34:46.295
You can go to
developer.Apple.com

00:34:46.585 --> 00:34:49.275
and download the example called
Metal performance shaders

00:34:49.356 --> 00:34:49.926
hello world.

00:34:51.315 --> 00:34:54.626
I've mentioned before that
the Metal performance shaders

00:34:54.626 --> 00:34:57.566
framework has two goals,
performance and ease of use.

00:34:57.666 --> 00:35:00.206
I just showed you how
easy it is to use.

00:35:01.116 --> 00:35:03.056
Let's take a quick
look behind the scenes

00:35:03.556 --> 00:35:05.416
at what's giving you
this performance.

00:35:07.676 --> 00:35:10.606
For every one of these filters
including the Gaussian blur

00:35:10.606 --> 00:35:13.656
filter, we had to choose
the right algorithm.

00:35:14.106 --> 00:35:18.676
The right here means correct
and it has to be the fastest.

00:35:19.346 --> 00:35:24.606
The fastest for a particular
combination of input data,

00:35:24.836 --> 00:35:27.366
input parameters,
and device GPU.

00:35:28.276 --> 00:35:30.286
What do I mean by this?

00:35:30.366 --> 00:35:32.686
There are multiple ways to
implement Gaussian blur.

00:35:32.686 --> 00:35:36.346
There are constant
cost, log 2, linear,

00:35:36.346 --> 00:35:37.736
and brute force algorithms.

00:35:39.276 --> 00:35:40.906
All of these approaches
have different start

00:35:40.906 --> 00:35:42.296
up costs and overheads.

00:35:42.666 --> 00:35:45.636
One approach may work really
well for a small kernel radius

00:35:45.976 --> 00:35:48.806
but perform very poorly
on a large kernel radius.

00:35:49.976 --> 00:35:54.326
The point is we had to implement
each one of these approaches

00:35:54.406 --> 00:35:57.126
and find out experimentally
which one is going

00:35:57.126 --> 00:35:59.536
to be the fastest for a
particular combination

00:35:59.536 --> 00:36:03.956
of input problem, input
parameters, and device GPU.

00:36:03.956 --> 00:36:09.076
And after this process, all
of the kernels had to be tuned

00:36:09.076 --> 00:36:11.266
for such parameters
as your kernel radius,

00:36:12.436 --> 00:36:13.456
your pixel format,

00:36:14.416 --> 00:36:16.936
your underlying hardware
architecture's memory hierarchy,

00:36:17.326 --> 00:36:19.776
and such parameters as
number of pixels per thread

00:36:19.776 --> 00:36:20.846
and thread group dimensions.

00:36:21.206 --> 00:36:23.636
This is what determines how to
split up your work in parallel.

00:36:23.636 --> 00:36:26.476
And finally, I would
like to mention

00:36:27.196 --> 00:36:30.626
that the framework also performs
CPU optimizations for you.

00:36:31.176 --> 00:36:35.016
It optimizes program
loading speed.

00:36:36.266 --> 00:36:40.546
It also reuses intermediate
textures,

00:36:41.206 --> 00:36:45.096
and finally it does some compute
encoder optimization for you.

00:36:45.146 --> 00:36:47.256
Specifically, it can defect

00:36:47.646 --> 00:36:51.106
if you are using multiple
computing coders in a row and if

00:36:51.106 --> 00:36:52.416
so it will coalesce them.

00:36:53.116 --> 00:36:58.896
And after we have done all
of these steps for you,

00:36:58.896 --> 00:37:01.076
that's cool, but what would
this actually look like in terms

00:37:01.076 --> 00:37:03.776
of code, for example, for an
optimized Gaussian blur shader

00:37:03.776 --> 00:37:04.736
that I just showed you?

00:37:07.436 --> 00:37:08.656
Well, are you ready for it?

00:37:09.686 --> 00:37:11.926
Here is the code.

00:37:12.436 --> 00:37:13.606
So now all of you know how

00:37:13.606 --> 00:37:15.726
to implement your own
optimized Gaussian blur, right?

00:37:16.196 --> 00:37:17.396
I bet you didn't
know you were going

00:37:17.396 --> 00:37:19.046
to learn this in this session.

00:37:19.826 --> 00:37:23.016
Basically all joking aside,
this is 49 Metal kernels,

00:37:23.066 --> 00:37:25.066
2,000 lines of kernel code

00:37:25.296 --> 00:37:29.756
and 821 different Metal
Gaussian blur implementations

00:37:30.576 --> 00:37:33.706
where each implementation
is some combination

00:37:33.706 --> 00:37:37.426
of these 49 Metal kernels, so it
looks like a lot of work we did

00:37:37.686 --> 00:37:39.566
and now you don't have to.

00:37:39.566 --> 00:37:40.946
Now, let's take a look

00:37:40.946 --> 00:37:50.216
at the Metal performance
shaders framework in action.

00:37:50.316 --> 00:37:53.286
So first, I will
demonstrate the performance

00:37:53.366 --> 00:37:58.556
of a simple textbook separable
Gaussian blur implementation

00:37:59.466 --> 00:38:01.486
that took only minutes
to write in Metal.

00:38:01.656 --> 00:38:04.026
This is probably something you
would start with if you had

00:38:04.026 --> 00:38:05.646
to implement your own blur

00:38:05.646 --> 00:38:07.806
and you didn't have Metal
performance shaders available

00:38:07.806 --> 00:38:08.086
to you.

00:38:08.456 --> 00:38:11.336
So now we are happily running
at 60 frames per second

00:38:11.336 --> 00:38:12.996
but we are not actually
doing any work yet.

00:38:13.996 --> 00:38:15.186
The sigma value is 0.

00:38:15.606 --> 00:38:19.466
Let's change the sigma value
to 6 and we are down to

00:38:19.466 --> 00:38:21.146
about 8 frames per second.

00:38:21.956 --> 00:38:23.046
Dare we go any further?

00:38:23.376 --> 00:38:24.736
Let's try a sigma of 20.

00:38:25.396 --> 00:38:30.896
Okay. And we are down
to 3 frames per second

00:38:30.896 --> 00:38:32.176
so that's not going to work.

00:38:33.006 --> 00:38:34.806
Let's switch to the
Metal performance

00:38:34.806 --> 00:38:35.956
shaders implementation.

00:38:36.566 --> 00:38:39.946
So now we are back to
60 frames per second,

00:38:39.946 --> 00:38:42.626
not doing any work, sigma of 6.

00:38:43.416 --> 00:38:44.846
Still 60 frames per second.

00:38:45.576 --> 00:38:46.556
Sigma of 20.

00:38:47.136 --> 00:38:48.586
Still 60 frames per second.

00:38:49.876 --> 00:38:53.366
And, of course, we had to go
further and really blur it,

00:38:53.706 --> 00:38:55.226
still at 60 frames per second.

00:38:55.226 --> 00:38:56.486
So this looks like a winner.

00:39:02.516 --> 00:39:12.026
[ Applause ]

00:39:12.526 --> 00:39:12.656
Okay.

00:39:13.046 --> 00:39:15.336
So your screen refresh
rate is 60 hertz.

00:39:17.096 --> 00:39:21.056
This means that we are running
at 60 frames we are second,

00:39:21.056 --> 00:39:24.956
so the performance of this
optimized Gaussian blur shader

00:39:24.956 --> 00:39:28.326
you have seen in the demo is
capped at 60 frames per second.

00:39:28.966 --> 00:39:33.786
This means that you have 16.6
milliseconds to draw your frame,

00:39:33.786 --> 00:39:36.566
and this also includes
any compositing work

00:39:36.596 --> 00:39:39.306
that your system
might need to do.

00:39:39.806 --> 00:39:43.066
This chart shows you
the execution time

00:39:43.646 --> 00:39:46.616
of this optimized Gaussian blur
filter for different values

00:39:46.616 --> 00:39:51.096
of sigma and as you can see,
the execution time is a lot less

00:39:51.246 --> 00:39:52.756
than 16.6 milliseconds.

00:39:53.436 --> 00:39:56.416
So this means that you
still have some extra time

00:39:56.416 --> 00:39:57.976
to do additional GPU work,

00:39:59.496 --> 00:40:02.766
and still hit the desired
60 frames per second.

00:40:03.416 --> 00:40:07.036
And now there are just a
few more details I would

00:40:07.036 --> 00:40:07.596
like to cover.

00:40:08.966 --> 00:40:12.266
Sometimes you will need to
work on very large images

00:40:12.266 --> 00:40:13.376
and you will need to tile them.

00:40:14.546 --> 00:40:16.036
And sometimes you
will just need to work

00:40:16.036 --> 00:40:17.186
on a portion of your image.

00:40:17.186 --> 00:40:18.976
So there is a mechanism
for that.

00:40:19.486 --> 00:40:22.616
It's called source offset
and destination clip Rect.

00:40:23.106 --> 00:40:25.616
Clip rect has an
origin and size.

00:40:26.206 --> 00:40:28.866
It determines the region
of the destination texture,

00:40:28.866 --> 00:40:32.416
which is going to be
updated by a filter.

00:40:32.416 --> 00:40:34.346
The source offset
only has an origin.

00:40:35.136 --> 00:40:37.356
The size is implicit, it's
determined by the clip rect,

00:40:37.356 --> 00:40:40.066
and it is just an offset
from the upper left corner

00:40:40.066 --> 00:40:41.436
of your source texture.

00:40:42.316 --> 00:40:45.366
They work together to
give you the final image.

00:40:45.916 --> 00:40:50.716
In the Metal performance
shaders framework your source

00:40:50.716 --> 00:40:53.646
and destination can be
one in the same texture.

00:40:54.096 --> 00:40:56.066
In this case, the clip rect

00:40:56.896 --> 00:40:59.546
and source offset work
exactly the same way.

00:41:00.126 --> 00:41:06.246
When the source and destination
are the same texture,

00:41:06.406 --> 00:41:08.246
we call it an in
place operation.

00:41:08.836 --> 00:41:09.846
Use it to save memory.

00:41:09.846 --> 00:41:12.386
How could you do you
actually encode one

00:41:12.386 --> 00:41:13.466
of these filters in place?

00:41:14.836 --> 00:41:17.936
You have to use the encode to
command buffer method that takes

00:41:17.936 --> 00:41:20.606
in place texture and a fall
by back copy allocator.

00:41:22.376 --> 00:41:25.346
One thing to keep in mind
here, it's not always possible

00:41:25.346 --> 00:41:26.716
for the shaders to run in place.

00:41:27.076 --> 00:41:28.596
It depends on your filter,

00:41:28.996 --> 00:41:30.506
on the filter parameters
and properties.

00:41:31.106 --> 00:41:32.806
If you want this operation

00:41:32.806 --> 00:41:35.486
to always succeed,
use a copy allocator.

00:41:35.726 --> 00:41:40.086
It will be called automatically,
only in the situation where the

00:41:40.086 --> 00:41:41.646
in place operation
is not possible.

00:41:42.046 --> 00:41:44.866
And we will create a new
destination texture for you

00:41:46.216 --> 00:41:47.736
so that the operation
can proceed

00:41:47.736 --> 00:41:49.286
out of place if necessary.

00:41:50.206 --> 00:41:54.206
And here is an example of a
simple fall back copy allocator.

00:41:55.826 --> 00:41:58.946
This one simply creates
a new destination texture

00:41:59.726 --> 00:42:02.886
with the same pixel
format and dimensions

00:42:02.886 --> 00:42:04.626
as the source texture,
very simple.

00:42:05.326 --> 00:42:08.016
So now I have shown you
an example before of an

00:42:08.016 --> 00:42:10.796
in place operation where
you only modified a portion

00:42:10.796 --> 00:42:13.976
of your destination texture
and everything outside

00:42:13.976 --> 00:42:15.866
of the clip rect
remained unchanged.

00:42:16.226 --> 00:42:18.366
You can also do this
in the copy allocator.

00:42:19.346 --> 00:42:22.596
Just initialize your destination
texture with the contexts

00:42:22.596 --> 00:42:23.536
of your source texture.

00:42:24.136 --> 00:42:28.696
And I would also like
to mention that all

00:42:28.696 --> 00:42:31.176
of the usual Metal
resources such as your device

00:42:31.176 --> 00:42:33.316
and your command buffer
are available to you

00:42:33.316 --> 00:42:34.286
in the copy allocator.

00:42:34.796 --> 00:42:36.916
Now that I have covered
these details,

00:42:37.166 --> 00:42:38.286
let's jump into the summary.

00:42:38.846 --> 00:42:43.296
I would like to say please use
the Metal support frameworks,

00:42:43.416 --> 00:42:46.416
MetalKit and Metal performance
shaders, they are robust,

00:42:46.606 --> 00:42:49.716
they are optimized, and as I
have shown you, they're easy

00:42:49.716 --> 00:42:51.486
to integrate into your
Metal applications.

00:42:52.026 --> 00:42:54.586
They will allow for faster bring
up time of your applications.

00:42:54.906 --> 00:42:56.216
Now, you can spend the time

00:42:56.216 --> 00:42:58.316
on making application
unique instead

00:42:58.316 --> 00:43:00.626
of implementing common tasks.

00:43:00.626 --> 00:43:03.566
And, of course, as an added
benefit, there is less code

00:43:03.566 --> 00:43:04.956
for you to write and maintain.

00:43:05.736 --> 00:43:07.746
And come to our labs,
give us feedback.

00:43:07.856 --> 00:43:10.366
Let us know how to get
started or give us questions.

00:43:10.836 --> 00:43:14.106
Let us know if there are new
utilities or shaders you would

00:43:14.106 --> 00:43:15.856
like to see added to
the support frameworks.

00:43:16.466 --> 00:43:19.686
You can always find
more information online.

00:43:19.786 --> 00:43:22.886
We have documentation videos
available, and take advantage

00:43:22.886 --> 00:43:25.216
of the Apple Developer
Forums and technical support.

00:43:25.496 --> 00:43:28.416
For general inquiries,
contact our gaming technologies

00:43:28.416 --> 00:43:29.706
evangelist Allan Schaffer.

00:43:31.926 --> 00:43:35.726
You can watch the past sessions
online, but if you would

00:43:35.726 --> 00:43:38.236
like to learn new Metal
performance optimization

00:43:38.236 --> 00:43:40.576
techniques, come to
our talk tomorrow

00:43:40.576 --> 00:43:42.956
at 11:00 a.m. Thank you.

00:43:44.516 --> 00:43:58.360
[ Applause ]
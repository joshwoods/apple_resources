WEBVTT

00:00:23.306 --> 00:00:24.016
>> ALI OZER: Good afternoon.

00:00:24.306 --> 00:00:25.946
Welcome to What's New in Cocoa.

00:00:30.546 --> 00:00:31.696
My name is Ali Ozer.

00:00:32.326 --> 00:00:36.266
I'll be talking to you about
what's new in Cocoa this year.

00:00:36.656 --> 00:00:39.796
Three areas: Swiftificaiton,
AppKit, and Foundation.

00:00:41.016 --> 00:00:43.826
We have a lot of
material, so let's dive in.

00:00:44.516 --> 00:00:48.606
Swiftification refers to the
API enhancements we have done

00:00:48.606 --> 00:00:52.946
across our frameworks
in support of Swift.

00:00:53.176 --> 00:00:56.606
The changes also improve our
Objective-C APIs as well.

00:00:57.156 --> 00:01:00.566
As you know, Swift
provides features

00:01:00.566 --> 00:01:02.426
to express APIs more precisely.

00:01:02.836 --> 00:01:05.366
For instance, you can
indicate this is an array.

00:01:05.366 --> 00:01:07.216
The Subviews property
is an array

00:01:07.216 --> 00:01:09.186
of NSView, not just an array.

00:01:09.866 --> 00:01:12.036
You can indicate that a
method such as System Font

00:01:12.036 --> 00:01:15.156
Of Size returns an NSFont
and will never return nil.

00:01:16.096 --> 00:01:18.246
In methods such as
Image For Resource,

00:01:18.246 --> 00:01:20.996
an NSBundle may return
nil because it is declared

00:01:20.996 --> 00:01:22.246
as an optional NSImage.

00:01:24.256 --> 00:01:27.096
We enable these features
in Objective-C as well

00:01:27.096 --> 00:01:28.466
with nullability in generics.

00:01:28.926 --> 00:01:31.506
So I'm going to talk about
these two areas briefly,

00:01:31.766 --> 00:01:33.946
and then also a few
other changes we made

00:01:34.186 --> 00:01:38.466
to make our Objective-C
and Swift APIs better.

00:01:38.666 --> 00:01:41.386
We applied these in APIs
of many our frameworks,

00:01:41.386 --> 00:01:44.606
not just AppKit and Foundation.

00:01:45.086 --> 00:01:48.096
By doing this we not only do
better exposure of the APIs

00:01:48.096 --> 00:01:51.906
in Swift but also
make the APIs clearer

00:01:52.096 --> 00:01:54.176
and also provide compile
time type-checking

00:01:54.176 --> 00:01:57.506
which is very important,
of course.

00:01:57.656 --> 00:02:00.896
Nullability is whether
values can or cannot be nil.

00:02:01.516 --> 00:02:06.146
If you use Swift with
X v10 or iOS 8 SDKs,

00:02:06.146 --> 00:02:09.985
you know the Swift APIs already
have the proper nullability

00:02:09.985 --> 00:02:11.446
and optional declarations
on them.

00:02:11.706 --> 00:02:15.186
We have managed that with
handcrafted side data,

00:02:15.226 --> 00:02:15.916
side files.

00:02:16.436 --> 00:02:19.886
In X v11 and iOS 9, we bring
this ability to Objective-C,

00:02:20.086 --> 00:02:22.766
and we have several new keywords
we've added to Objective-C.

00:02:23.446 --> 00:02:27.666
Nonnull indicates never nil,
Nullable indicates can be nil,

00:02:28.166 --> 00:02:31.726
Null Resettable indicates that
a property can be set to nil

00:02:31.726 --> 00:02:33.176
but won't ever return nil.

00:02:33.316 --> 00:02:36.036
We'll have an example
in a second.

00:02:36.036 --> 00:02:38.706
Last and least, we
have Null Unspecified,

00:02:38.706 --> 00:02:39.836
meaning not specified.

00:02:40.186 --> 00:02:43.146
This is used for
deprecated stuff or stuff

00:02:43.146 --> 00:02:47.636
that has not yet been audited.

00:02:47.686 --> 00:02:51.306
Since nonnull is the
majority of cases in our API,

00:02:51.556 --> 00:02:53.256
we also have these
two declarations:

00:02:53.256 --> 00:02:54.866
Assume Nonnull Begin and End,

00:02:54.866 --> 00:02:56.556
which we wrap our
header files with.

00:02:57.056 --> 00:02:59.506
With this, the nonnull
declarations are no

00:02:59.506 --> 00:03:00.216
longer needed.

00:03:00.696 --> 00:03:03.206
Nonnull is unnecessary

00:03:03.206 --> 00:03:05.066
and we have the other
declarators on our APIs.

00:03:05.066 --> 00:03:08.026
We recommend you use
these in your header files

00:03:08.266 --> 00:03:10.586
if you have a lot of
header files of your own.

00:03:11.656 --> 00:03:15.256
Let's look at some examples
of how these affect our APIs.

00:03:15.756 --> 00:03:18.276
You can see the Color
property on NSColorWell.

00:03:18.696 --> 00:03:22.096
We have not put any declaration
on it, which means it is nonnull

00:03:22.506 --> 00:03:25.566
and comes across in Swift
as a non-optional value.

00:03:25.616 --> 00:03:26.496
The Color property.

00:03:27.056 --> 00:03:29.336
The Image property of
NSImageView, on the other hand,

00:03:29.336 --> 00:03:33.806
is nullable which means that
it can be set to nil and comes

00:03:33.806 --> 00:03:36.376
across in Swift as
an optional value.

00:03:36.796 --> 00:03:39.636
And finally the Font property
of NSMenu is declarated

00:03:39.636 --> 00:03:42.616
as null resettable,
and this comes

00:03:42.616 --> 00:03:44.236
as implicitly unwrapped
optional.

00:03:44.956 --> 00:03:48.176
In this case what this means is
we can set this value to nil,

00:03:48.176 --> 00:03:49.706
but it will never return nil.

00:03:50.236 --> 00:03:53.706
What NSMenu does is if you ever
set it to nil, it goes back

00:03:53.756 --> 00:03:56.776
to the default font that it
would have had for the system.

00:03:56.816 --> 00:03:58.666
So it never will return nil.

00:04:00.176 --> 00:04:03.016
With nullability, you may
see some build time warnings.

00:04:03.756 --> 00:04:04.866
Let me show you an example.

00:04:05.186 --> 00:04:07.926
If you have code like this that
was setting the Color property

00:04:07.926 --> 00:04:11.156
of a ColorWell to nil,
the compiler will now warn

00:04:11.456 --> 00:04:13.156
because we declared
this to be nonnull.

00:04:13.726 --> 00:04:16.856
This is a good thing because it
turns out if you had the code

00:04:16.856 --> 00:04:19.546
and it was being run, it
would have raised a parameter

00:04:19.546 --> 00:04:20.456
assertion anyway.

00:04:20.866 --> 00:04:22.926
This is kind of things that
now you'll get warnings

00:04:22.926 --> 00:04:23.906
about from the compiler.

00:04:23.906 --> 00:04:24.446
That's great.

00:04:26.106 --> 00:04:31.146
As you probably know, in general
nil is not a valid object value

00:04:31.146 --> 00:04:32.796
in our APIs.

00:04:32.796 --> 00:04:36.146
NSString, NSArray, NSDictionary,
et cetera have easy

00:04:36.146 --> 00:04:40.916
to express empty values
and APIs that accept

00:04:40.916 --> 00:04:44.016
or return nils should
document what nil means

00:04:44.016 --> 00:04:45.206
as an exceptional case.

00:04:45.576 --> 00:04:47.736
I'll give you several
examples from our APIs.

00:04:48.326 --> 00:04:51.476
If you set the background color
of an NSTextView object to nil,

00:04:51.616 --> 00:04:53.126
it means don't draw
the background.

00:04:53.936 --> 00:04:55.486
A nil locale in many of our APIs

00:04:55.486 --> 00:04:58.696
that take locale
means nonlocalized.

00:04:58.696 --> 00:04:59.976
So you can specify a locale,

00:04:59.976 --> 00:05:02.696
but if you specify nil
it means nonlocalized.

00:05:03.286 --> 00:05:07.336
Let's talk about generics.

00:05:08.666 --> 00:05:12.366
Generics as you have
heard is lightweight type

00:05:12.366 --> 00:05:16.326
parameterization that we
added to Objective-C and great

00:05:16.646 --> 00:05:19.726
for specifying types of
elements in collections.

00:05:21.076 --> 00:05:23.116
Here is an example
of NSSearchField.

00:05:23.486 --> 00:05:24.916
The Recent Search property

00:05:24.916 --> 00:05:28.456
of NSSearchField is
declared like this in X v10.

00:05:28.456 --> 00:05:31.666
The name Recent Searches
is not superclear.

00:05:31.666 --> 00:05:33.126
What does this contain?

00:05:33.126 --> 00:05:34.716
Strings? URLs?

00:05:34.716 --> 00:05:35.916
Some search objects?

00:05:36.386 --> 00:05:39.926
In X v11 SDK, we
can clarify this.

00:05:39.976 --> 00:05:41.996
It is an array of NSString.

00:05:42.376 --> 00:05:45.516
And the Swift declaration goes
from an array of any object

00:05:45.766 --> 00:05:47.266
to an array of string as well.

00:05:47.836 --> 00:05:53.196
The way we have done this, we
have taken NSArray in Foundation

00:05:53.516 --> 00:05:56.256
and added the Object Type
parameter to it, like so.

00:05:56.256 --> 00:05:59.406
We have applied this object
type to all of the APIs,

00:05:59.886 --> 00:06:02.826
appropriate APIs, which
used to take or return ID,

00:06:02.826 --> 00:06:06.146
such as object at index,
contains object, and so on.

00:06:06.536 --> 00:06:09.916
There is many other APIs
this applies to in NSArray.

00:06:10.236 --> 00:06:13.866
With this, the code we
had with Recent Searches,

00:06:14.486 --> 00:06:15.806
let's say you had
a code like this,

00:06:16.266 --> 00:06:19.006
Recent Searches contains
object, some URL,

00:06:19.936 --> 00:06:21.196
we are passing in NSURL.

00:06:21.476 --> 00:06:24.536
The compiler now will warn
you that you're passing URL

00:06:25.126 --> 00:06:27.336
into a method that expects
an array of strings.

00:06:27.676 --> 00:06:30.246
The great thing here is this
code would have never failed

00:06:30.246 --> 00:06:32.696
or crashed because that
URL never would have been

00:06:32.696 --> 00:06:33.316
found before.

00:06:33.386 --> 00:06:36.496
The compiler is telling you of
a potential bug in the code.

00:06:38.166 --> 00:06:40.926
We have added generic support in
Foundation not only to NSArray

00:06:40.926 --> 00:06:43.996
but to all the other collections
as well, including NSEnumerator,

00:06:43.996 --> 00:06:48.106
which strictly speaking is not
even a collection, of course.

00:06:48.556 --> 00:06:50.486
You can apply this to
non-collections as well.

00:06:51.066 --> 00:06:55.266
Now with generics you can use
them as well, you can use them

00:06:55.316 --> 00:06:57.446
in variable declarations
in your own classes.

00:06:57.886 --> 00:07:00.876
If you are taking the result of
Recent Searches and assigning it

00:07:00.936 --> 00:07:04.716
to a property of your own,
you can go ahead and declarate

00:07:04.766 --> 00:07:07.866
that to be NSArray of NSString,
and that will allow the type

00:07:07.946 --> 00:07:09.536
to propagate through
your own code.

00:07:10.656 --> 00:07:12.116
You can declarate your
own properties in APIs.

00:07:12.116 --> 00:07:14.476
Here is an array of files.

00:07:14.476 --> 00:07:15.306
What are they?

00:07:15.306 --> 00:07:16.396
Strings or URLs?

00:07:16.906 --> 00:07:17.946
You can be clear.

00:07:17.946 --> 00:07:21.346
You can apply generics to
your custom collections

00:07:21.346 --> 00:07:23.686
if you have any or even
to your custom categories

00:07:23.686 --> 00:07:24.816
on foundation collections.

00:07:25.536 --> 00:07:28.216
For instance, here is
a category on NSArray.

00:07:29.076 --> 00:07:32.296
You can go in and add it, just
right there in your own code.

00:07:32.296 --> 00:07:34.736
These generics work
with categories as well.

00:07:35.346 --> 00:07:43.166
Now kindof is another feature
we have added to Objective-C.

00:07:43.636 --> 00:07:46.216
Let's give you motivation
as to why we need this.

00:07:46.656 --> 00:07:48.316
Here's what the subviews
declaration looked

00:07:48.316 --> 00:07:49.026
like in X v10.

00:07:49.896 --> 00:07:54.766
Here is what we did our first
attempt in applying generics.

00:07:55.456 --> 00:07:58.136
Subviews was changed
to NSArray of NSView.

00:07:58.806 --> 00:08:02.546
Then we had code like this,
where we assign an element

00:08:02.546 --> 00:08:04.116
out of this array into NSButton.

00:08:04.966 --> 00:08:07.206
Turns out that this
concerns the compiler,

00:08:07.746 --> 00:08:10.986
the compiler is always looking
out for us, always concerned.

00:08:11.456 --> 00:08:12.476
It generates a warning.

00:08:12.946 --> 00:08:15.606
Why? Because we're assigning
something that's explicitly

00:08:15.606 --> 00:08:18.626
declared to be an NSView
to a subclass of NSView,

00:08:18.816 --> 00:08:20.816
and the compiler is
right in being concerned.

00:08:21.326 --> 00:08:23.736
However, this is a kind
of code we use a lot,

00:08:23.736 --> 00:08:25.046
and it is often valid.

00:08:25.636 --> 00:08:28.586
So we added this kindof keyword
and changed the declaration

00:08:28.846 --> 00:08:33.486
of the subviews property to
be NSArray of kindof NSViews.

00:08:33.916 --> 00:08:35.145
What this says is --

00:08:36.515 --> 00:08:39.655
[Applause]

00:08:40.155 --> 00:08:40.895
>> ALI OZER: Thank you.

00:08:41.606 --> 00:08:45.976
Thank you for overlooking
the under bars there!

00:08:45.976 --> 00:08:48.096
What this says, it is okay
for the caller to be able

00:08:48.096 --> 00:08:50.826
to access the elements
of the array as instances

00:08:50.826 --> 00:08:54.086
of the specified class or
instances of a subclass as well.

00:08:54.826 --> 00:08:56.946
So this is now -- this works.

00:08:57.616 --> 00:09:02.826
Note that kindof is a compile
time facility like most

00:09:02.826 --> 00:09:04.206
of the things I have
talked about here.

00:09:04.676 --> 00:09:07.356
There is no runtime
code changes,

00:09:08.396 --> 00:09:11.196
there is no runtime check
for the type, for instance.

00:09:11.586 --> 00:09:14.066
There are cases where we
want the caller to think

00:09:14.066 --> 00:09:16.936
about what the elements
are before accessing them.

00:09:17.396 --> 00:09:20.526
So we're going to use
these sparingly in our APIs

00:09:20.526 --> 00:09:22.166
and we recommend
you do the same.

00:09:22.396 --> 00:09:24.466
They should be used when
it is safe for the caller

00:09:24.466 --> 00:09:25.566
to make that assumption.

00:09:25.896 --> 00:09:27.486
If you want the caller
to think twice

00:09:27.486 --> 00:09:29.816
or maybe do some runtime
query, don't use the kindof.

00:09:30.236 --> 00:09:32.346
An example is this
Representations method

00:09:32.346 --> 00:09:33.136
on NSImage.

00:09:33.866 --> 00:09:35.886
It returns an array
of NSImage reps,

00:09:36.066 --> 00:09:40.086
which are often subclassed,
almost always subclassed.

00:09:40.536 --> 00:09:42.136
However, we have
not used kindof here

00:09:42.136 --> 00:09:44.626
because the kindof
representations you get back

00:09:45.096 --> 00:09:47.686
isn't always predictable
and it might, in fact,

00:09:47.686 --> 00:09:50.406
change during the runtime
of an application or in fact

00:09:50.406 --> 00:09:52.216
between releases of the OS.

00:09:52.216 --> 00:09:54.576
It is better for the
caller to be more alert here

00:09:54.576 --> 00:09:55.866
and do some runtime checks.

00:09:56.386 --> 00:10:01.026
Let me talk about
error handling.

00:10:01.026 --> 00:10:03.906
As you heard yesterday, Swift
2 brings an amazing error

00:10:03.906 --> 00:10:06.326
handling facility.

00:10:08.226 --> 00:10:11.336
What that means is for a method
like this on NSData write

00:10:11.436 --> 00:10:15.426
to URL options error, it now
looks like this in Swift.

00:10:15.426 --> 00:10:18.206
The Boolean return value goes
away, it is now implicit.

00:10:18.566 --> 00:10:21.426
And the error, the by
reference NSError parameter,

00:10:21.726 --> 00:10:24.516
also goes away because it is
captured in the throw statement.

00:10:24.946 --> 00:10:28.486
Here is a kindof code you
write to deal with this.

00:10:28.486 --> 00:10:30.066
As you can see in
the catch phrase,

00:10:30.066 --> 00:10:32.986
you can capture the error,
it is either available

00:10:32.986 --> 00:10:34.886
for you automatically
or you can declare it.

00:10:34.886 --> 00:10:36.816
And you can declare
different catch statements,

00:10:36.816 --> 00:10:37.576
of course, as well.

00:10:38.066 --> 00:10:40.536
It is great, straightforward.

00:10:40.536 --> 00:10:41.876
Now, one thing.

00:10:42.056 --> 00:10:45.206
Note that despite the
terminology here, throw, try,

00:10:45.206 --> 00:10:47.516
catch, et cetera, these
are not exceptions

00:10:47.516 --> 00:10:48.606
in the Objective-C sense.

00:10:48.996 --> 00:10:50.606
We're not raising
exceptions here.

00:10:50.606 --> 00:10:53.796
We're actually returning
errors and unwinding properly

00:10:53.796 --> 00:10:58.116
through the stack just like, you
know, what we do with NSErrors.

00:10:58.816 --> 00:11:01.356
In fact, NSError
guidelines apply

00:11:01.446 --> 00:11:03.696
to the Swift error handling.

00:11:03.806 --> 00:11:08.056
Use NSErrors and Swift error
handling for runtime errors,

00:11:08.056 --> 00:11:10.656
errors that you expect to
present to the user or handle

00:11:10.656 --> 00:11:12.996
at runtime, such as file
not found and so forth.

00:11:12.996 --> 00:11:16.576
We continue to use
exceptions or Swift assertions

00:11:16.576 --> 00:11:20.266
for programming errors such
as array index out of bounds.

00:11:20.406 --> 00:11:22.736
The last category, of
course, are the kind of errors

00:11:22.736 --> 00:11:26.176
that are not expected
to be captured.

00:11:26.176 --> 00:11:28.386
One more Swiftification
item is naming cleanup.

00:11:29.186 --> 00:11:32.406
As you might be away, we
still have a lot of enum names

00:11:32.406 --> 00:11:35.896
from a long time ago where
we use a common suffix rather

00:11:35.896 --> 00:11:38.566
than common prefix, and we have
renamed them in some cases,

00:11:38.566 --> 00:11:40.576
not all, to have
a common prefix,

00:11:40.576 --> 00:11:41.766
which means that they come

00:11:41.766 --> 00:11:43.416
across in Swift with
a better name.

00:11:43.416 --> 00:11:45.466
Instead of dot left
text alignment it comes

00:11:45.466 --> 00:11:46.616
across as dot.left.

00:11:46.976 --> 00:11:48.476
There are many more
examples of this.

00:11:49.066 --> 00:11:51.446
Note that in many cases we
haven't actually deprecated the

00:11:51.446 --> 00:11:54.496
old names, so your sources
will continue to compile,

00:11:54.496 --> 00:11:56.896
but you can switch to the new
names as you rewrite your code.

00:11:57.386 --> 00:12:01.646
And there is many more of these.

00:12:01.676 --> 00:12:03.146
With that, let's
switch to AppKit.

00:12:04.576 --> 00:12:06.246
There are many AppKit
topics I would love

00:12:06.246 --> 00:12:09.356
to talk about, I'll
talk about some.

00:12:09.826 --> 00:12:13.666
One note here: from this point
on i'm going to show APIs

00:12:13.666 --> 00:12:16.426
and code samples
mostly in Swift.

00:12:16.596 --> 00:12:18.626
Even if you're not
comfortable yet in Swift,

00:12:19.086 --> 00:12:21.476
don't worry because no
code I show will be all

00:12:21.476 --> 00:12:22.256
that complicated.

00:12:22.736 --> 00:12:23.916
After all, I'm just a manager.

00:12:24.476 --> 00:12:25.506
It is important to note --

00:12:26.016 --> 00:12:27.126
[Laughter]

00:12:27.126 --> 00:12:27.766
>> ALI OZER: It is
important to note

00:12:27.766 --> 00:12:29.806
that these APIs are
all available

00:12:29.806 --> 00:12:31.226
in Objective-C and Swift.

00:12:31.536 --> 00:12:33.256
So we're not showing you
anything that works only

00:12:33.256 --> 00:12:34.426
for Objective-C or Swift.

00:12:34.426 --> 00:12:37.086
It is available for whatever
language you're using.

00:12:37.616 --> 00:12:43.686
As you know, the new Force
Touch trackpad brings pressure

00:12:43.686 --> 00:12:46.716
sensitivity as well
as haptic feedback.

00:12:46.806 --> 00:12:49.696
opening up interesting
possibilities for applications.

00:12:49.696 --> 00:12:53.486
Let's look at some use cases.

00:12:53.486 --> 00:12:56.956
Here, for instance, by applying
Force Click on some text,

00:12:56.956 --> 00:12:59.796
you can do lookup or you
can automatically create a

00:12:59.796 --> 00:13:00.426
calendar event.

00:13:01.626 --> 00:13:03.686
In this case, by
applying a pressure

00:13:03.686 --> 00:13:05.816
to the fast-forward button,
you can cause the movie

00:13:05.816 --> 00:13:07.936
to fast-forward even faster.

00:13:08.496 --> 00:13:13.006
Here you can apply pressure
to draw thin or thick strokes

00:13:13.246 --> 00:13:16.446
when you're signing your name
or doing drawing in markup.

00:13:17.336 --> 00:13:20.996
Finally, in this case, as you
move objects around in a program

00:13:20.996 --> 00:13:23.936
like Xcode's Interface
Builder or in a drawing program

00:13:24.316 --> 00:13:27.576
as objects go into alignment
you will get haptic feedback.

00:13:28.306 --> 00:13:32.666
Now some of the Force Touch APIs
made an appearance in X v10.3,

00:13:32.666 --> 00:13:34.796
some of you may have seen those.

00:13:35.146 --> 00:13:37.376
First, we have accelerator
controls APIs.

00:13:38.246 --> 00:13:40.956
These APIs interpret variable
pressure and are useful

00:13:40.956 --> 00:13:43.746
for creating the likes of
the fast-forward buttons

00:13:43.746 --> 00:13:45.746
or zoom buttons in an
application like Maps.

00:13:46.146 --> 00:13:48.476
You can set accelerator
controls on NSButton

00:13:48.476 --> 00:13:49.616
in NSSegmentedControl.

00:13:50.236 --> 00:13:51.726
If you want to do more
sophisticated things

00:13:51.726 --> 00:13:55.266
with pressure, we give you
an event, a new event type

00:13:55.316 --> 00:13:57.716
for pressure with the
corresponding methods

00:13:57.956 --> 00:14:00.276
on NSResponder and
gesture recognizer as well,

00:14:00.376 --> 00:14:01.656
Pressure Change With event.

00:14:01.656 --> 00:14:03.406
You can interpreter
pressure events yourself.

00:14:04.376 --> 00:14:08.286
In X v11, we introduced
several new classes.

00:14:08.286 --> 00:14:10.106
One is pressure configuration
class.

00:14:10.526 --> 00:14:12.526
You set the pressure
configuration of a view

00:14:12.526 --> 00:14:13.746
or gesture recognizer

00:14:14.026 --> 00:14:16.406
to indicate how the
trackpad should react.

00:14:16.916 --> 00:14:18.976
In general, the haptic
feedback provided

00:14:18.976 --> 00:14:20.296
to the user will be dependent

00:14:20.296 --> 00:14:22.466
on the pressure configuration
you specified.

00:14:22.976 --> 00:14:26.106
We have two other classes,
haptic feedback manager

00:14:26.106 --> 00:14:28.416
and alignment feedback
filter, allowing you

00:14:28.416 --> 00:14:34.896
to customize the kind of haptic
feedback you give to the user.

00:14:34.896 --> 00:14:38.356
Many of you may have
used spring loading.

00:14:38.736 --> 00:14:42.026
That's when you start a
drag, and when you hover

00:14:42.026 --> 00:14:44.656
over a destination the
destination opens up for you.

00:14:44.816 --> 00:14:46.226
You probably use this in Finder.

00:14:46.686 --> 00:14:48.876
With Force Click, we now have it

00:14:48.936 --> 00:14:52.706
such that you can also do
spring loading immediately just

00:14:52.706 --> 00:14:54.346
by force clicking
on the destination.

00:14:55.136 --> 00:14:59.536
We have a new API for making
spring loading even easier.

00:14:59.536 --> 00:15:02.776
This is just a simple Boolean
property, spring loaded

00:15:02.776 --> 00:15:04.916
on NSButton and
NSSegmentedControl,

00:15:05.286 --> 00:15:08.416
and the action will be sent
on hover or on Force Click.

00:15:08.606 --> 00:15:09.586
Very straightforward.

00:15:09.936 --> 00:15:15.326
If this doesn't quite meet your
needs, we have a new protocol,

00:15:15.426 --> 00:15:17.336
NSSpringLoadingDestination,
which allows you

00:15:17.336 --> 00:15:19.526
to do spring loading on
arbitrary destinations.

00:15:20.036 --> 00:15:24.086
For example, the Finder example
would be appropriate for this.

00:15:24.276 --> 00:15:26.906
Swipe to delete, you're
familiar with this,

00:15:26.906 --> 00:15:29.656
you saw it yesterday
likely in the keynote

00:15:29.956 --> 00:15:33.316
and you may be familiar with
it from iOS, you can swipe left

00:15:33.316 --> 00:15:37.956
or right in a table view such
as the messages list in Mail

00:15:38.026 --> 00:15:40.936
to mark messages as unread,
or delete them, and so on.

00:15:41.236 --> 00:15:43.246
We now have API for
this also in El Capitan.

00:15:43.826 --> 00:15:44.816
It is a delegate method

00:15:44.876 --> 00:15:47.056
on NSTableView, Row
Actions for Row.

00:15:47.556 --> 00:15:50.686
You simply return an array
of NSTableView row action,

00:15:51.066 --> 00:15:56.796
and these instances of the class
simply declares how the items,

00:15:56.856 --> 00:15:59.266
the row should be drawn
and what should happen

00:15:59.266 --> 00:16:01.656
when the user selects that
action via this block,

00:16:01.746 --> 00:16:04.486
this handler block at the end.

00:16:04.486 --> 00:16:05.836
I sort of breezed
through the topics.

00:16:06.236 --> 00:16:09.026
There is a talk, Adopting
New Rrackpad Features,

00:16:09.026 --> 00:16:11.826
Thursday morning at 10:00
a.m. that you can catch

00:16:11.826 --> 00:16:14.406
that will give you more
detail on these topics.

00:16:15.586 --> 00:16:18.176
Full screen, you heard
about this yesterday.

00:16:18.306 --> 00:16:21.626
Full screen enables you to
remove distractions and focus

00:16:21.626 --> 00:16:24.216
on one task, as you
can see here.

00:16:24.486 --> 00:16:28.986
Now with split view full screen,
you can focus on one task

00:16:29.036 --> 00:16:30.786
but possibily bring
in another window.

00:16:30.866 --> 00:16:34.026
For instance, here you are using
Xcode and you brought up Safari

00:16:34.026 --> 00:16:36.686
to look at some documentation
or some forums.

00:16:36.996 --> 00:16:38.976
You can imagine bringing
up messages next to Xcode

00:16:38.976 --> 00:16:42.036
because you want to chat
with a buddy about a piece

00:16:42.036 --> 00:16:42.816
of code you're writing.

00:16:43.696 --> 00:16:45.986
This is called tiling, when
the windows are brought

00:16:46.526 --> 00:16:47.536
into split view.

00:16:48.656 --> 00:16:51.436
Tiling is automatic
for many windows.

00:16:52.866 --> 00:16:55.156
Resizable windows are
automatically eligible

00:16:55.156 --> 00:16:55.736
for tiling.

00:16:55.736 --> 00:16:57.056
This means your applications,

00:16:57.056 --> 00:16:58.386
the windows in your
applications,

00:16:58.386 --> 00:17:01.416
will automatically be candidates
for being tiled in full screen

00:17:01.416 --> 00:17:02.776
without any changes
on your part.

00:17:03.146 --> 00:17:05.386
Whether they're full
screen-capable or not already.

00:17:06.086 --> 00:17:09.146
However, there is API for opting
windows in and out of tiling,

00:17:09.246 --> 00:17:12.146
and it's part of this NSWindow
collection behavior options

00:17:12.146 --> 00:17:12.896
on NSWindow.

00:17:13.715 --> 00:17:15.675
For instance, you may
have a nonresizable window

00:17:15.675 --> 00:17:17.226
that you think should
be tillable.

00:17:17.695 --> 00:17:19.976
You can use the Allowd
Tiling option.

00:17:20.126 --> 00:17:22.156
Or you have an antisocial window

00:17:22.156 --> 00:17:23.586
that just doesn't
want to be tiled.

00:17:23.695 --> 00:17:25.236
You can set Disallows Tiling.

00:17:25.415 --> 00:17:28.236
I don't know an example
of that, but it is there.

00:17:28.636 --> 00:17:31.756
These joined full
screen primary settings

00:17:31.756 --> 00:17:34.226
that we had here
already in X v7.

00:17:34.286 --> 00:17:37.086
It is important to note that the
full-screen primary is the way

00:17:37.086 --> 00:17:41.356
that you specify a window
should go into full screen.

00:17:41.726 --> 00:17:44.106
Note that this is still
very much an opt-in setting

00:17:44.706 --> 00:17:47.666
because we want you to think
about how your windows behave

00:17:47.806 --> 00:17:50.006
in the vast screen
space of full screen,

00:17:50.346 --> 00:17:53.146
so that is still an opt-in
thing where you think

00:17:53.146 --> 00:17:55.216
about how your window
should act in full screen.

00:17:55.216 --> 00:17:59.306
That one you still opt into.

00:18:00.246 --> 00:18:03.186
You can also set these of course
in Xcode's attributes inspector

00:18:03.186 --> 00:18:04.866
as well, both the tiling

00:18:04.866 --> 00:18:07.916
and whether a window
becomes full screen or not.

00:18:07.916 --> 00:18:10.206
I said that tiling is
automatic for many windows,

00:18:10.486 --> 00:18:12.216
but AppKit does check to see,

00:18:12.216 --> 00:18:14.806
make sure that windows can
coexist in the same screen.

00:18:15.186 --> 00:18:17.016
Imagine you have a
relatively small screen

00:18:17.016 --> 00:18:20.786
and two fairly large windows,
when you try to tile them,

00:18:20.856 --> 00:18:23.036
if the windows cannot
be resized small enough,

00:18:23.036 --> 00:18:24.906
AppKit will not allow
them to be tiled.

00:18:24.906 --> 00:18:29.236
I want you to think about how
your windows can resize small

00:18:29.236 --> 00:18:31.876
enough, how they can be
flexible enough to fit

00:18:31.876 --> 00:18:35.576
into the smaller area
of tiled split view.

00:18:36.146 --> 00:18:39.086
To help achieve this,
we have some APIs.

00:18:39.256 --> 00:18:41.846
For instance, split view item
now has sidebar behavior,

00:18:42.146 --> 00:18:44.766
where the sidebar gets
smaller and collapses

00:18:44.806 --> 00:18:47.136
and can be brought
back up as an overlay,

00:18:47.576 --> 00:18:48.986
and also has proper vibrancy.

00:18:49.816 --> 00:18:53.296
NSStackView automatic detaching
of hidden views allows you

00:18:53.296 --> 00:18:56.106
to create NSToolbar-like
experiences

00:18:56.106 --> 00:18:58.396
for your custom views
where the items,

00:18:58.396 --> 00:19:00.216
as they're dropped off the edge,

00:19:00.346 --> 00:19:03.096
can be put into a
menu, and so on.

00:19:03.646 --> 00:19:04.446
And many more.

00:19:04.666 --> 00:19:05.746
You can hear about these

00:19:05.746 --> 00:19:07.876
in Improving the
Full-Screen Window Experience,

00:19:07.876 --> 00:19:09.066
which is Thursday afternoon.

00:19:11.246 --> 00:19:14.626
Auto Layout, as you know,
this is very important,

00:19:14.626 --> 00:19:16.756
we have made some
significant changes,

00:19:16.756 --> 00:19:19.616
significant improvements
in Auto Layout as well.

00:19:19.946 --> 00:19:21.166
First is stack view.

00:19:22.416 --> 00:19:25.276
Stack view is a very
important class.

00:19:25.536 --> 00:19:28.356
It should be the first-stop
shop for your Auto Layout needs.

00:19:28.356 --> 00:19:30.026
If you can get done what
you have to get done

00:19:30.026 --> 00:19:31.176
within a stack view rather

00:19:31.176 --> 00:19:33.206
than using constraints
directly, do it.

00:19:33.206 --> 00:19:36.406
It is a high level of
abstraction, very powerful.

00:19:36.856 --> 00:19:39.896
First good news about stack view
is it is now on iOS as well,

00:19:39.896 --> 00:19:43.196
as UI stack view, with
equal pretty much APIs.

00:19:43.196 --> 00:19:46.196
This goes along with
our constant attempt

00:19:46.196 --> 00:19:49.096
of bringing parity
between our platforms,

00:19:49.136 --> 00:19:50.456
and this is one of
those examples.

00:19:50.846 --> 00:19:52.796
Secondly, it is now
even better than ever.

00:19:52.836 --> 00:19:55.486
I already mentioned the
detaching functionality.

00:19:55.936 --> 00:19:58.086
There is also new options
for view distribution

00:19:58.086 --> 00:19:59.596
with this property
called distribution.

00:20:01.206 --> 00:20:03.276
One value in here
is gravity areas,

00:20:03.276 --> 00:20:07.426
which is the option you had
in stack view from day one

00:20:07.516 --> 00:20:09.386
when we introduced it in X v9.

00:20:09.386 --> 00:20:11.296
We have added other settings,

00:20:11.296 --> 00:20:12.606
and rather than explaining
these,

00:20:12.836 --> 00:20:14.556
I will show you a quick video.

00:20:14.556 --> 00:20:18.476
There are six stack views here
configured with these settings.

00:20:18.516 --> 00:20:21.036
I will resize the
window, larger,

00:20:21.036 --> 00:20:22.526
smaller, back larger again.

00:20:22.726 --> 00:20:25.286
As you can see, you get
some powerful functionality,

00:20:25.346 --> 00:20:27.926
such as ability to have
equal sizes, equal spacing,

00:20:27.926 --> 00:20:30.666
and so on that hopefully
will fit your needs.

00:20:30.666 --> 00:20:34.346
The stack views can be
nested in arbitrary ways

00:20:34.416 --> 00:20:36.346
to give you powerful layouts.

00:20:36.946 --> 00:20:40.146
NSLayoutAnchor is a new
class providing a concise

00:20:40.366 --> 00:20:42.636
representation of an
edge or dimension.

00:20:43.046 --> 00:20:44.376
Let's say you have
two views and you want

00:20:44.376 --> 00:20:45.696
to create a constraint
between them.

00:20:46.326 --> 00:20:47.866
This is code that you would
have had to have write.

00:20:48.546 --> 00:20:51.926
With layout anchors, here is
the code that you can write.

00:20:52.506 --> 00:20:55.426
Note that these two items here
are basically layout anchors

00:20:55.426 --> 00:20:58.286
referring to those
edges of those views,

00:20:58.666 --> 00:21:00.776
and this is not only
shorter, sweeter,

00:21:00.776 --> 00:21:04.026
it is also giving you more
compile time type-checking.

00:21:04.026 --> 00:21:04.476
It is great.

00:21:05.516 --> 00:21:10.076
[Applause]

00:21:10.576 --> 00:21:12.836
>> ALI OZER: NSLayoutGuide
is another new class.

00:21:12.836 --> 00:21:15.826
If you ever find yourself
doing this sort of stuff,

00:21:15.886 --> 00:21:20.596
creating dummy views to do
things like equal spacing

00:21:20.596 --> 00:21:24.126
between views, you can now
instead create layout guides.

00:21:24.126 --> 00:21:27.256
It's a lightweight object that
takes the place of a view,

00:21:27.256 --> 00:21:29.826
but it is much lighter
weight so it can participate

00:21:29.826 --> 00:21:31.806
in Auto Layout without
creating views.

00:21:33.306 --> 00:21:35.846
Collection view has been
with us for a while.

00:21:36.306 --> 00:21:39.666
As you know, UICollectionView
was also introduced a few

00:21:39.766 --> 00:21:41.356
releases ago.

00:21:41.786 --> 00:21:44.426
With X v11, we brought
NSCollectionView to parity

00:21:44.426 --> 00:21:47.686
with the iOS version while still
maintaining important features

00:21:47.686 --> 00:21:50.226
for the desktop, such as drag
and drop and bulk selection.

00:21:50.816 --> 00:21:53.356
So here are some of the features
in the new collection view.

00:21:53.816 --> 00:21:56.346
Features such as
heterogeneous items,

00:21:56.346 --> 00:21:58.386
optional grouping,
customizable layout.

00:21:58.846 --> 00:22:01.696
Let me show you a quick video
of a sample application here.

00:22:01.696 --> 00:22:03.556
There is a bunch of
images being displayed.

00:22:03.556 --> 00:22:08.396
I will first group by group with
headers and footers and use some

00:22:08.396 --> 00:22:10.506
of the custom layouts
provided by the app.

00:22:11.726 --> 00:22:15.006
You see this app in action and
learn about the features and how

00:22:15.006 --> 00:22:17.206
to apply them in your own
applications in What's New

00:22:17.206 --> 00:22:20.216
in Collection View, that's
Thursday afternoon at 4:30.

00:22:22.436 --> 00:22:23.876
We have some great
changes in text.

00:22:24.166 --> 00:22:25.936
First is the new system UI font.

00:22:26.246 --> 00:22:30.456
Here is what the new system
font looks like, San Francisco.

00:22:30.456 --> 00:22:35.136
As you know, it is the same
font on iOS and watchOS as well.

00:22:35.826 --> 00:22:39.156
This font is automatic
for applications.

00:22:39.156 --> 00:22:41.976
When you run your application
in X v11 on El Capitan,

00:22:41.976 --> 00:22:42.926
you will get this font.

00:22:43.006 --> 00:22:44.816
But it's possible that
you are doing something

00:22:44.816 --> 00:22:45.516
that prevents this.

00:22:46.026 --> 00:22:49.586
If you see this font, it
was introduced in X v10,

00:22:49.806 --> 00:22:53.596
there is something going on,
check it to see what you need

00:22:53.596 --> 00:22:55.786
to do to make sure you're
using San Francisco.

00:22:56.446 --> 00:23:00.356
If you're using this font, this
is one we introduced in X v0,

00:23:00.356 --> 00:23:02.506
more of that is going on.

00:23:02.976 --> 00:23:05.896
Finally, if you're
using this font --

00:23:06.066 --> 00:23:08.066
[Laughter]

00:23:08.116 --> 00:23:09.566
>> ALI OZER: You have
a lot of work to do.

00:23:09.806 --> 00:23:10.396
Hang in there.

00:23:11.496 --> 00:23:13.826
This was the font we
stopped using in Mac OS 9.

00:23:13.826 --> 00:23:18.386
Here are the APIs in
NSFont that you can use

00:23:18.386 --> 00:23:20.736
to make sure you're using
the latest system font,

00:23:21.126 --> 00:23:22.846
system font of size and so on.

00:23:22.846 --> 00:23:25.926
These fonts, these
APIs, they have been

00:23:25.926 --> 00:23:27.096
with us for a long time.

00:23:27.676 --> 00:23:32.196
You can set the system fonts via
the Xcode attributes inspector.

00:23:32.726 --> 00:23:34.776
Fairly straightforward
There is a pop-up,

00:23:34.826 --> 00:23:36.766
you choose the appropriate
system font

00:23:36.766 --> 00:23:37.646
for your application.

00:23:39.456 --> 00:23:41.916
We do have new API for a system
font at different weights.

00:23:42.476 --> 00:23:45.956
If your designers are asking
you to use different weights,

00:23:46.416 --> 00:23:49.056
you can now do that with a
system font with this API,

00:23:49.266 --> 00:23:51.346
system font of size and weight.

00:23:52.016 --> 00:23:54.656
There is nine different
weights predefined,

00:23:54.706 --> 00:23:56.406
I'm showing you only
three of them,

00:23:56.616 --> 00:23:58.026
ranging from ultralight
to black.

00:23:58.476 --> 00:24:00.626
The regular setting is
what you get by default

00:24:00.626 --> 00:24:01.806
for system font of size.

00:24:02.676 --> 00:24:06.916
We have another API, mono space
system font of size weight.

00:24:07.496 --> 00:24:08.936
Let me show you why
you need this.

00:24:09.996 --> 00:24:14.286
If you call the system font
of size API in an application

00:24:14.286 --> 00:24:16.646
that is linked against X v11 SDK

00:24:16.646 --> 00:24:19.096
and you draw some digits,
here is what you see.

00:24:19.616 --> 00:24:24.036
Those of you with eagle eyes
for fonts may note, wow,

00:24:24.126 --> 00:24:26.516
those digits are
not fixed pitched,

00:24:26.516 --> 00:24:27.476
they're different widths.

00:24:28.066 --> 00:24:31.076
This is shocking because
traditionally system fonts have

00:24:31.076 --> 00:24:33.476
always had digits that
are the same width.

00:24:33.946 --> 00:24:39.466
That's to make sure that tabular
data appears organized or UIs

00:24:39.466 --> 00:24:43.306
with changing numbers
in text doesn't jiggle

00:24:43.306 --> 00:24:44.676
as the numbers are changing.

00:24:45.526 --> 00:24:47.236
But now, if your app is linked

00:24:47.236 --> 00:24:50.636
against X v11 you will get this
system font with the fonts.

00:24:50.846 --> 00:24:53.246
If you have to have
fixed pitched fonts,

00:24:53.366 --> 00:24:56.816
that's when you use this
API, this will give up digits

00:24:56.896 --> 00:24:59.266
that are equal widths.

00:24:59.746 --> 00:25:02.776
Typographically not as pleasing,
but it will get the job done.

00:25:03.216 --> 00:25:05.496
The changes are drastic.

00:25:05.776 --> 00:25:08.796
Here is the proportional, and
here is the fixed widths ones.

00:25:09.006 --> 00:25:10.086
It is a tool for you.

00:25:10.716 --> 00:25:13.826
You can hear more about
this and more about the APIs

00:25:13.826 --> 00:25:15.416
in Introducing New System Fonts,

00:25:15.416 --> 00:25:18.856
which is Friday afternoon
at 2:30.

00:25:19.196 --> 00:25:23.136
I also mentioned new APIs, there
is new APIs in the tech system.

00:25:23.476 --> 00:25:26.916
These bring new functionality
and parity with TextKit and iOS,

00:25:27.426 --> 00:25:28.556
there is a lot of items here.

00:25:28.556 --> 00:25:30.736
I'm just going to cover
two, three of them.

00:25:31.136 --> 00:25:32.526
First is exclusion paths.

00:25:33.126 --> 00:25:36.276
This is the ability to
easily put paths so you can

00:25:36.276 --> 00:25:38.736
to wrap text around objects
such as this butterfly,

00:25:38.796 --> 00:25:41.476
it is straightforward.

00:25:42.196 --> 00:25:44.926
Another one is two properties
on text field: maximum number

00:25:44.926 --> 00:25:48.116
of lines, which is great
especially with Auto Layout,

00:25:48.526 --> 00:25:53.976
or allows default tightening
for truncation, which allows you

00:25:53.976 --> 00:25:55.466
to specify if the contents

00:25:55.466 --> 00:25:59.016
of the text field should be
tightened before it actually

00:25:59.016 --> 00:25:59.716
gets truncated.

00:25:59.786 --> 00:26:02.546
There was a way to control this,
before but now it is controlled

00:26:02.546 --> 00:26:03.766
with this one Boolean property.

00:26:05.226 --> 00:26:07.646
There are many more changes,
these are some highlights.

00:26:07.646 --> 00:26:11.836
So last thing I want to talk

00:26:11.836 --> 00:26:14.656
about in the AppKit
section is visual atomicity.

00:26:15.276 --> 00:26:17.676
You may wonder, what
is visual atomicity?

00:26:18.386 --> 00:26:19.106
A mountain?

00:26:19.106 --> 00:26:22.316
What does it have to
do with Half Dome?

00:26:22.346 --> 00:26:25.096
I'll show you a short clip
demonstrating what I mean

00:26:25.096 --> 00:26:28.426
by visual atomicity or
lack of visual atomicity.

00:26:28.746 --> 00:26:30.566
You see the Open
panel come up twice.

00:26:31.406 --> 00:26:33.086
First time, okay, not great.

00:26:33.776 --> 00:26:41.276
Second time, judge for yourself.

00:26:42.526 --> 00:26:44.936
Unless you blinked, you
saw what I'm talking about.

00:26:45.206 --> 00:26:46.726
Let's show you in slow motion.

00:26:47.226 --> 00:26:49.466
Shadow. Parts of the panel.

00:26:49.566 --> 00:26:50.356
Rest of the panel.

00:26:50.796 --> 00:26:53.796
This is the Open panel
running in Yosemite.

00:26:54.686 --> 00:26:57.136
Open panel is a rough
case because it is drawn

00:26:57.136 --> 00:27:00.136
by multiple processes,
but that's not an excuse.

00:27:00.456 --> 00:27:03.316
A UI like this should
appear to the user as coming

00:27:03.316 --> 00:27:05.976
up in one step, one
frame, it shouldn't go

00:27:05.976 --> 00:27:08.876
through a few visual
steps like that.

00:27:09.576 --> 00:27:11.236
That's what we mean
by visual atomicity,

00:27:11.236 --> 00:27:14.436
achieving that one
single-step drawing when needed.

00:27:15.256 --> 00:27:18.796
Those of you who had to
[undecipherable] windows, views,

00:27:19.086 --> 00:27:21.626
also Core Animation
layers explicitly,

00:27:21.626 --> 00:27:24.176
you know that achieving
visual atomicity is not always

00:27:24.176 --> 00:27:25.076
that straightforward.

00:27:26.546 --> 00:27:28.766
There are a number of APIs,
you don't have to read

00:27:28.766 --> 00:27:30.216
through the list,
there is no quiz.

00:27:30.676 --> 00:27:32.896
There are a number of
APIs that do the job,

00:27:32.956 --> 00:27:36.366
but they don't necessarily
work well together.

00:27:36.366 --> 00:27:41.636
In X v11, we fixed it up so that
you can achieve visual atomicity

00:27:41.636 --> 00:27:42.966
with NSAnimationContext.

00:27:44.786 --> 00:27:47.856
You can call Begin Grouping or
End Grouping or its equivalent,

00:27:47.856 --> 00:27:50.146
Run Animation Group,
around a bunch

00:27:50.146 --> 00:27:53.506
of independent drawing you're
doing, such as you see here.

00:27:53.566 --> 00:27:56.946
This should give you
visual atomicity.

00:27:56.946 --> 00:28:00.876
Beyond this, we discourage the
use of Disable Screen Updates

00:28:00.876 --> 00:28:01.946
and Enable Screen Updates

00:28:01.946 --> 00:28:04.046
and Disable Screen
Updates until Flush.

00:28:04.486 --> 00:28:07.506
They're not deprecated, but
they are not recommended anymore

00:28:07.816 --> 00:28:12.956
and should not be necessary.

00:28:12.956 --> 00:28:15.376
With that, we can
move on to Foundation.

00:28:15.996 --> 00:28:18.286
There is a lot of things to talk
about in Foundation as well.

00:28:19.696 --> 00:28:20.876
First one is undo manager.

00:28:21.846 --> 00:28:25.636
Those of you who used undo
manager from Swift know

00:28:25.636 --> 00:28:28.506
that undo manager APIs is
not a perfect fit in Swift.

00:28:29.216 --> 00:28:30.666
This is what the APIs look like.

00:28:30.966 --> 00:28:34.506
The first has a selector, and
it only works in some cases.

00:28:34.506 --> 00:28:36.166
The second one has
an indication.

00:28:36.546 --> 00:28:39.646
NSIndication in Objective-C
is of course awesome,

00:28:39.886 --> 00:28:42.976
but it doesn't know about all
of the fancier types in Swift.

00:28:43.576 --> 00:28:45.966
So we're adding block-based
undo.

00:28:46.926 --> 00:28:48.666
This is how it looks
in Objective-C,

00:28:48.666 --> 00:28:50.086
and this is how it
looks in Swift.

00:28:50.586 --> 00:28:52.626
As you will see, there
is a target argument

00:28:52.916 --> 00:28:55.196
and also a block, which
is basically the code

00:28:55.196 --> 00:28:57.946
to be executed to undo
the action you just did.

00:28:59.126 --> 00:29:01.836
Separate argument for the
target means you don't have

00:29:01.886 --> 00:29:03.526
to reference the
target in the block,

00:29:03.526 --> 00:29:05.236
which avoids retain cycles.

00:29:05.706 --> 00:29:07.486
And there is also a
use of generic type

00:29:07.486 --> 00:29:09.616
in the Swift declaration, and
I'll tell you how it works.

00:29:10.296 --> 00:29:11.286
Here is an example.

00:29:11.626 --> 00:29:13.146
You have a class
named Colorful Shape,

00:29:13.726 --> 00:29:15.346
it's got a property named Color,

00:29:17.106 --> 00:29:20.066
we add a Did Set property
observer to this property.

00:29:20.426 --> 00:29:23.376
This is just one of the ways
you can do undo, you can undo

00:29:23.376 --> 00:29:24.926
in other ways as well,
but here we're doing it

00:29:24.926 --> 00:29:26.066
in the Did Set property.

00:29:26.066 --> 00:29:28.626
This is the call to
register undo with target,

00:29:29.386 --> 00:29:32.756
and here is actually the code to
be executed to undo the action

00:29:32.826 --> 00:29:33.616
that I might be doing.

00:29:34.476 --> 00:29:38.696
Note that thanks to the use of
generics in the register undo

00:29:38.696 --> 00:29:41.496
at target, this all works

00:29:41.546 --> 00:29:43.676
and the target is
automatically recognized

00:29:43.676 --> 00:29:46.316
as a colorful shape thanks to
the reference to self there

00:29:46.316 --> 00:29:48.136
in the register undo column.

00:29:48.136 --> 00:29:52.066
You don't have to cast the
target to colorful shape.

00:29:53.036 --> 00:29:55.156
NSCoder now has error handling.

00:29:55.656 --> 00:29:58.756
Those of you who have used
NSCoders like NSKeyedArchiver

00:29:58.756 --> 00:30:02.946
or so on, you know there is no
error arguments to those things.

00:30:02.946 --> 00:30:04.646
We have added explicit
error handling.

00:30:05.406 --> 00:30:08.456
Methods such as these, Decode
Object for Key and Decode Object

00:30:08.726 --> 00:30:11.186
of Classes for Key,
now have versions

00:30:11.186 --> 00:30:13.836
that actually return errors,
throw errors in Swift.

00:30:14.276 --> 00:30:16.476
They're named Decode
Top Level Object for Key

00:30:16.476 --> 00:30:18.486
and Decode Top Level
Object of Classes for Key.

00:30:18.886 --> 00:30:21.876
Note that they have
throws declaration,

00:30:21.876 --> 00:30:23.296
which means that
they return an error.

00:30:23.636 --> 00:30:25.976
And note that they
return an optional object

00:30:26.006 --> 00:30:29.056
because a nil return is actually
a valid return out of these,

00:30:29.056 --> 00:30:31.396
it just indicates that the
object was not in the archive.

00:30:33.216 --> 00:30:36.176
Note that these are named
Decode Top Level Object for Key,

00:30:36.176 --> 00:30:39.356
and we intend for this to
be used at the top levels

00:30:39.356 --> 00:30:41.216
when you're unarchiving
your root objects.

00:30:41.496 --> 00:30:44.366
We don't intend these to be
called in your implementations

00:30:44.366 --> 00:30:45.276
of [unintelligible] coder.

00:30:46.726 --> 00:30:48.666
Also note that these are not
the only the two methods we have

00:30:48.666 --> 00:30:51.026
here; we have another two or
three to go along with all

00:30:51.026 --> 00:30:55.526
of the decode object type
methods we have currently.

00:30:56.176 --> 00:30:59.666
NSError now has a value
provider, let me model this.

00:31:00.256 --> 00:31:04.486
This is a simple way you may
be creating an NSError object.

00:31:04.486 --> 00:31:06.696
It's pretty simple,
straightforward, however,

00:31:06.696 --> 00:31:08.226
note that it's not
user presentable.

00:31:08.576 --> 00:31:10.506
If this were ever to
be shown to the user,

00:31:10.506 --> 00:31:11.596
this is what they'll see.

00:31:12.176 --> 00:31:16.286
Not good. This is really what
you would like them to see

00:31:16.286 --> 00:31:17.966
if this was ever
presented to the user.

00:31:18.246 --> 00:31:20.466
Even if you don't ever present
this to the user, you know,

00:31:20.466 --> 00:31:22.576
in the debugger something like
this would be helpful too,

00:31:22.576 --> 00:31:24.326
as opposed to getting error 42.

00:31:25.266 --> 00:31:28.366
So the code that you write
for this looks like this.

00:31:29.386 --> 00:31:33.536
So you specify the values for
various keys, and if you want it

00:31:33.536 --> 00:31:36.246
to be user presentable you
would also localize them.

00:31:36.856 --> 00:31:38.396
So you know, it is
a bunch of code,

00:31:38.926 --> 00:31:40.996
you can create methods
here forever.

00:31:41.186 --> 00:31:44.206
The code isn't the problem,
writing code, it is our job,

00:31:44.206 --> 00:31:46.296
right, we're paid for it,
that's not the problem.

00:31:46.616 --> 00:31:48.896
The problem is that all this
is happening at the time

00:31:48.896 --> 00:31:51.956
that errors are being
created even if the consumer

00:31:51.956 --> 00:31:53.746
of the error does
nothing with the error.

00:31:53.746 --> 00:31:55.806
So it is, performance-wise,
wasteful.

00:31:56.436 --> 00:31:58.796
So we've added this
ability to create

00:31:58.796 --> 00:32:01.076
and return desired
values on demand.

00:32:02.296 --> 00:32:05.646
We have this method, set
user info value provider

00:32:05.646 --> 00:32:07.236
for domain provider.

00:32:07.476 --> 00:32:11.186
You basically specify a
domain you created for NSError

00:32:11.186 --> 00:32:13.966
in your application and provide
a provider, which is a block

00:32:13.966 --> 00:32:17.206
that returns values
for any keys missing

00:32:17.206 --> 00:32:18.296
in the user info dictionary.

00:32:18.296 --> 00:32:20.256
So it will be invoked
on demand lazily.

00:32:20.586 --> 00:32:24.206
You can go back to using this
nice, shortened piece of code

00:32:24.206 --> 00:32:28.086
for generating errors, and
the user information will be

00:32:29.036 --> 00:32:31.036
filled dynamically.

00:32:31.096 --> 00:32:32.806
You may be familiar
with NSProgress.

00:32:32.966 --> 00:32:35.276
It is an object for
reporting progress

00:32:35.276 --> 00:32:36.716
and it has a great feature

00:32:36.716 --> 00:32:41.736
where it will implicitly compose
progress from across a hierarchy

00:32:41.736 --> 00:32:43.616
of operations and
it will present

00:32:43.616 --> 00:32:45.656
that to the user as
one single number.

00:32:46.126 --> 00:32:47.976
It is pretty good,
but it is implicit.

00:32:48.676 --> 00:32:52.196
As being implicit,
it has some issues

00:32:52.196 --> 00:32:53.196
that you may have run into.

00:32:53.546 --> 00:32:55.616
We're introducing
an explicit mode

00:32:55.616 --> 00:32:57.106
for managing progress reporting.

00:32:57.766 --> 00:33:00.436
This has two pieces:
one is APIs to add

00:33:00.436 --> 00:33:03.456
and remove child progress
objects directly to a hierarchy

00:33:03.456 --> 00:33:06.486
of progress objects and
the second is this protocol

00:33:06.486 --> 00:33:09.426
which lets you declare the
progress on an object directly.

00:33:09.866 --> 00:33:12.086
For instance, if you have
a subclass of NSOperation,

00:33:12.086 --> 00:33:16.466
which does some one-shot
operation, you know, it starts

00:33:16.466 --> 00:33:19.526
and ends, it is a good candidate
for this progress property.

00:33:19.846 --> 00:33:23.266
It allows it to opt in to
explicit progress reporting.

00:33:24.426 --> 00:33:27.056
NSProgress now also has
the ability to resume.

00:33:27.436 --> 00:33:30.476
It had the ability to pause,
we have added the second part.

00:33:32.066 --> 00:33:34.876
NSNotificationCenter
now has the ability

00:33:34.876 --> 00:33:37.466
to automatically unregister
the allocated observers.

00:33:39.516 --> 00:33:43.176
[Applause]

00:33:43.676 --> 00:33:45.056
>> ALI OZER: Here is the kind
of code you would have had

00:33:45.056 --> 00:33:47.476
to have write to add
yourself as an observer,

00:33:47.476 --> 00:33:48.406
and here is the code you write

00:33:48.406 --> 00:33:49.686
to remove yourself
as an observer.

00:33:49.946 --> 00:33:51.546
You can call this
code if you want

00:33:51.546 --> 00:33:53.356
to remove yourself
as an observer.

00:33:53.876 --> 00:33:57.286
If you don't, and freed, you'll
automatically be unregistered.

00:33:57.356 --> 00:33:59.316
That's pretty great.

00:34:01.406 --> 00:34:05.966
So here is the class whose name
Toby did not dare say yesterday

00:34:05.966 --> 00:34:09.576
in the State of the Union,
NSFirstNameComponentsFormatter.

00:34:09.996 --> 00:34:13.106
The rule is, if it is not
long enough to be wrapped

00:34:13.106 --> 00:34:15.085
on a slide title,
it is not too long.

00:34:15.246 --> 00:34:17.306
So,
NSFirstNameComponentsFomatter.

00:34:18.146 --> 00:34:20.666
It allows proper localized
formatting of names.

00:34:20.936 --> 00:34:23.616
This joins other
formatters we have added

00:34:23.616 --> 00:34:26.656
over the last few years such
as date components formatter,

00:34:27.045 --> 00:34:29.356
byte count formatter,
length formatter, and so on.

00:34:30.606 --> 00:34:34.196
It also provides styles for
a number of different forms.

00:34:34.346 --> 00:34:35.815
Let me give you a quick example.

00:34:36.306 --> 00:34:39.666
You create a person named
Components Object, it has parts

00:34:39.666 --> 00:34:42.295
of name, you specify the
parts of name you have,

00:34:42.466 --> 00:34:44.976
there is many more, let's say
here we're specifying three

00:34:44.976 --> 00:34:45.235
of them.

00:34:46.726 --> 00:34:49.376
Then you create a person in
componenst formatter and ask

00:34:49.376 --> 00:34:50.606
for it to be formatted.

00:34:51.196 --> 00:34:54.226
Depending on the kind
of style that you give,

00:34:54.226 --> 00:34:56.436
you get different forms
of the name, like long,

00:34:56.466 --> 00:34:58.286
default, short, and so on.

00:34:58.696 --> 00:35:01.856
Note that if you ask for short,
but in some other language,

00:35:01.856 --> 00:35:05.576
you may get a totally different
form of the name depending

00:35:05.576 --> 00:35:07.426
on rules of localization
for that language.

00:35:07.426 --> 00:35:09.146
Don't make assumptions
about the kind

00:35:09.146 --> 00:35:11.126
of names you will get
back from this API.

00:35:11.916 --> 00:35:14.256
The purpose of this API,
one of the main purposes is

00:35:14.256 --> 00:35:16.276
to isolate you from complexities

00:35:16.276 --> 00:35:18.336
of writing world-ready
applications.

00:35:19.316 --> 00:35:22.516
NSString has new APIs to
help you write world-ready

00:35:22.516 --> 00:35:24.196
internationalizable
applications.

00:35:24.636 --> 00:35:27.486
There is facility for
conditional quotation,

00:35:27.776 --> 00:35:31.556
whether a technical term, for
instance, should be surrounded

00:35:31.816 --> 00:35:34.406
by quotes, for which rules
change in different languages.

00:35:34.766 --> 00:35:37.236
Simpler localized case
changing and searching APIs,

00:35:38.106 --> 00:35:41.306
transliteration APIs, which
previously were in CFString,

00:35:41.306 --> 00:35:44.296
now they're in NSString,
and also facilities

00:35:44.296 --> 00:35:47.276
for adaptive strings
for UI presentation.

00:35:47.606 --> 00:35:51.406
You can provide multiple forms,
multiple lengths of the string

00:35:51.406 --> 00:35:54.716
in your strings files and have
the right one chosen depending

00:35:54.716 --> 00:35:58.026
on how much space you have
in your UI to display it.

00:35:58.136 --> 00:36:00.936
You can hear about the person
name components formatter

00:36:01.286 --> 00:36:03.836
and all of these facilities
and more in What's New

00:36:03.836 --> 00:36:05.736
in Internationalization,
which is Friday morning

00:36:05.736 --> 00:36:10.066
at 9:00 a.m. Let me talk
about thermal state.

00:36:10.066 --> 00:36:15.156
These are APIs introduced in X
v10.3, which was the same time

00:36:15.156 --> 00:36:18.146
as our sexy new MacBook
which, of course,

00:36:18.146 --> 00:36:20.286
as you may know doesn't
have any fans

00:36:20.396 --> 00:36:23.256
and in fact is a good
case study for this API.

00:36:23.896 --> 00:36:27.646
Note that although this API was
introduced at the same time,

00:36:27.866 --> 00:36:30.816
it works on our other machines

00:36:30.816 --> 00:36:32.396
and is generally
available and functional.

00:36:32.396 --> 00:36:33.936
It's not just for
the MacBook only.

00:36:34.806 --> 00:36:37.896
This API is captured
with a property,

00:36:37.896 --> 00:36:40.026
a thermal state property
on NSProcessInfo.

00:36:40.456 --> 00:36:43.196
It has four values: nominal,
fair, serious, critical.

00:36:43.586 --> 00:36:46.836
There is a notification you can
get whenever the value changes.

00:36:48.496 --> 00:36:51.476
Note that serious, that's
when the fans are going

00:36:51.476 --> 00:36:53.796
at maximum speed if
your machine had fans,

00:36:54.246 --> 00:36:56.876
imagine what's happening
if you don't have fans.

00:36:57.196 --> 00:36:59.586
Serious is typically when
you want to take some action.

00:36:59.586 --> 00:37:02.376
For instance, let's say
you're doing custom animation

00:37:03.386 --> 00:37:05.306
at 60 FIPS, this a time to think

00:37:05.306 --> 00:37:07.346
about reducing your
animation to 30 FIPS.

00:37:07.846 --> 00:37:11.056
That's what NSScrollView
will do for you automatically

00:37:11.056 --> 00:37:12.856
so you don't have to worry
about NSScrollView case.

00:37:13.196 --> 00:37:15.156
Let's say you're using
high-quality textures

00:37:15.156 --> 00:37:17.696
in the application and you
get a serious thermal state,

00:37:18.176 --> 00:37:21.116
time to drop to maybe
lower-quality textures.

00:37:22.166 --> 00:37:25.296
This API is great for cases when
you need it, but it is important

00:37:25.296 --> 00:37:28.726
to note that this API is
reactive and not proactive.

00:37:28.726 --> 00:37:32.046
It is the kind of API where the
system calls you to tell you

00:37:32.046 --> 00:37:35.146
of trouble and you have to
take action, and, of course,

00:37:35.146 --> 00:37:36.966
the action you take
is not adding more

00:37:36.966 --> 00:37:38.056
to the load on the system.

00:37:38.696 --> 00:37:40.956
We have a lot of other
APIs which are proactive

00:37:40.956 --> 00:37:43.666
that we have introduced
over the last few releases.

00:37:44.386 --> 00:37:46.976
These are the kind of APIs
where you tell the system

00:37:46.976 --> 00:37:51.756
about what you're doing, and the
system optimizes your activities

00:37:51.756 --> 00:37:55.666
and tasks based on whatever
happens to be going on.

00:37:56.046 --> 00:37:58.046
For instance, tolerance
on timers,

00:37:58.396 --> 00:38:01.936
process info activity
APIs, doing downloads

00:38:01.936 --> 00:38:03.786
in the background
with NSURLSession,

00:38:03.846 --> 00:38:06.526
setting quality service, so on.

00:38:07.476 --> 00:38:10.826
These APIs allow not only
energy efficient behavior,

00:38:10.826 --> 00:38:13.156
but they also enable
proper thermal behavior.

00:38:13.156 --> 00:38:17.496
They enable longer battery
life and make your system coo,

00:38:17.856 --> 00:38:19.826
figuratively and
literally as well.

00:38:22.386 --> 00:38:26.326
Last, core data, quick mention
here since I'm short on time.

00:38:26.696 --> 00:38:29.136
A lot of great features in
core data, unique constraints

00:38:29.136 --> 00:38:31.796
and batch deletion and many
other API enhancements,

00:38:32.046 --> 00:38:33.106
that's all I'll say.

00:38:34.176 --> 00:38:35.746
Of course, it wouldn't
be a what's new talk

00:38:35.746 --> 00:38:38.106
if I don't leave a lot
of things on the floor.

00:38:38.436 --> 00:38:40.646
These are many other topics
I just didn't get around to,

00:38:40.646 --> 00:38:42.746
you can read about them
hopefully in the release notes.

00:38:43.176 --> 00:38:45.656
This is not even including
amazing new technologies

00:38:45.716 --> 00:38:48.086
such as Metal or
GameplayKit as well.

00:38:48.686 --> 00:38:53.366
In summary, we have a lot
of general API improvements

00:38:53.366 --> 00:38:55.246
across the board
for Swiftification.

00:38:55.246 --> 00:38:57.956
In addition, we have a lot of
great features and enhancements.

00:38:58.666 --> 00:39:03.466
Look at the material, think
about how to adopt them,

00:39:03.466 --> 00:39:07.266
and come see us at the labs
if you have any questions.

00:39:07.736 --> 00:39:10.426
For more information,
here are the pointers.

00:39:10.806 --> 00:39:13.006
The AppKit and Foundation
release notes are available

00:39:13.006 --> 00:39:16.176
at developer.apple.com.osx.

00:39:16.236 --> 00:39:19.516
The release notes are for the
seed, so it's a good source.

00:39:20.086 --> 00:39:21.506
Thank you for joining me today.

00:39:21.506 --> 00:39:22.856
Have a great rest
of the conference.

00:39:23.516 --> 00:39:28.500
[Applause]
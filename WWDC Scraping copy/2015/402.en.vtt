WEBVTT

00:00:23.046 --> 00:00:24.456
>> KATE STONE: Good
afternoon and welcome

00:00:24.456 --> 00:00:26.016
to What's New In LLDB.

00:00:26.326 --> 00:00:27.086
My name is Kate.

00:00:28.516 --> 00:00:33.566
[ Applause ]

00:00:34.066 --> 00:00:36.106
>> KATE STONE: And I manage
the runtime analysis tools

00:00:36.106 --> 00:00:37.756
in Xcode, including LLDB.

00:00:37.926 --> 00:00:40.246
I will be getting us started
here but I'll be bringing up two

00:00:40.246 --> 00:00:42.386
of my engineers,
Sean and Enrico,

00:00:42.386 --> 00:00:44.616
to dive into the details
in just a little bit.

00:00:45.346 --> 00:00:47.806
But to get us started, I would
like to talk a little bit

00:00:47.886 --> 00:00:49.936
about the year's highlights,
some of the changes,

00:00:49.936 --> 00:00:53.346
big and small, since the
last time we were at WWDC.

00:00:54.356 --> 00:00:58.426
Most notably we shipped
our first Swift debugger.

00:00:58.936 --> 00:01:01.446
It is a step forward, obviously,
in being able to write

00:01:01.596 --> 00:01:04.156
and develop the Swift code that
you have come to know and love.

00:01:05.676 --> 00:01:07.926
But more importantly it
wasn't our last step.

00:01:08.316 --> 00:01:10.156
We continued to improve
that debugger

00:01:10.156 --> 00:01:12.556
and we hope your continued
feedback will help us make it

00:01:12.556 --> 00:01:13.466
even better still.

00:01:13.626 --> 00:01:16.626
At the same time we
shipped the Swift REPL;

00:01:17.156 --> 00:01:17.966
it's a little bit different

00:01:17.966 --> 00:01:21.266
than your standard request
response REPL environment,

00:01:21.556 --> 00:01:24.496
in that it is really
LLDB in disguise.

00:01:25.226 --> 00:01:28.856
The REPL is not just a way that
you can ask questions in Swift.

00:01:28.856 --> 00:01:31.376
It is a way that you can
debug those questions,

00:01:31.376 --> 00:01:33.106
you can actually set
breakpoints in the REPL

00:01:33.336 --> 00:01:34.396
and do everything you'd expect

00:01:34.476 --> 00:01:37.276
from a debugging environment
because it is LLDB.

00:01:37.276 --> 00:01:39.186
If you haven't dug
deep into that,

00:01:39.346 --> 00:01:41.916
I'd recommend you take a look at
the blog posts on the subject.

00:01:42.876 --> 00:01:44.606
But, of course, that's
not the end.

00:01:44.606 --> 00:01:47.176
There are numerous improvements
that we have made since then.

00:01:47.176 --> 00:01:50.286
Since we first shipped, we've
made over 100 improvements

00:01:50.286 --> 00:01:52.576
in the Swift debugging
experience, and we continue

00:01:52.576 --> 00:01:54.226
to enhance the debugging
experience

00:01:54.226 --> 00:01:55.706
for Objective-C as well.

00:01:56.106 --> 00:01:57.396
We're going to cover
some of them here,

00:01:57.826 --> 00:01:59.976
but just to recap some of the
changes that have been made

00:01:59.976 --> 00:02:04.766
since last year, Swift types
initially did not show inherited

00:02:04.766 --> 00:02:05.876
Objective-C fields.

00:02:06.146 --> 00:02:07.096
We've since corrected that.

00:02:07.986 --> 00:02:10.416
Help now includes
command aliases.

00:02:10.416 --> 00:02:12.386
And it is important
to understand these,

00:02:12.386 --> 00:02:15.706
because while LLDB has what
may look like a wordy syntax,

00:02:16.576 --> 00:02:17.956
we might ask you to type 'help,

00:02:18.416 --> 00:02:20.246
in practice there are
a number of short cuts.

00:02:20.246 --> 00:02:22.866
And throughout this presentation
we'll use the following notation

00:02:22.866 --> 00:02:23.616
to describe them.

00:02:24.296 --> 00:02:28.366
Help can actually be abbreviated
to the first unique sequence.

00:02:28.716 --> 00:02:31.076
So in this case H is
enough to bring up help.

00:02:31.846 --> 00:02:34.536
More importantly, for
more elaborate examples

00:02:34.536 --> 00:02:39.136
like expression-O-- , which
means 'evaluate an expression,

00:02:39.706 --> 00:02:41.946
tell me the results as
if it were an object

00:02:42.046 --> 00:02:44.216
by sending it a method
to describe itself,

00:02:44.736 --> 00:02:48.086
and then no more options
followed by the expression,

00:02:48.546 --> 00:02:49.826
but you can just type PO.

00:02:49.926 --> 00:02:52.746
PO is a handy alias
that is shorthand

00:02:52.806 --> 00:02:53.946
for everything to the left.

00:02:54.776 --> 00:02:57.226
So, as you get used to
the help, you should learn

00:02:57.226 --> 00:02:59.966
to use the aliases, because they
are going to be your fastest way

00:03:00.076 --> 00:03:04.036
to get to some of the
powerful functionality in LLDB.

00:03:04.196 --> 00:03:06.726
We've also improved data
formatting, because telling you

00:03:06.726 --> 00:03:08.486
about your data is
absolutely critical

00:03:08.626 --> 00:03:10.236
to your debugging experience.

00:03:10.716 --> 00:03:15.696
So types like set and NS Index
Path now have default formatting

00:03:15.696 --> 00:03:17.726
to help you understand
your data instead

00:03:17.726 --> 00:03:19.146
of just showing you the raw dump

00:03:19.196 --> 00:03:20.726
of the underlying
representation.

00:03:21.586 --> 00:03:23.546
Printf prototype
for expressions,

00:03:24.176 --> 00:03:27.216
if you've ever tried to evaluate
an expression involving printf,

00:03:27.216 --> 00:03:30.046
you may have seen some
slightly suspect results.

00:03:30.546 --> 00:03:32.416
That's because the
debugger tries to make a lot

00:03:32.416 --> 00:03:35.586
of assumptions about your
expression for any declaration

00:03:35.586 --> 00:03:36.446
that it doesn't know,

00:03:36.516 --> 00:03:39.176
and it didn't know
printf, in most cases.

00:03:39.786 --> 00:03:42.476
So it didn't know that it was
a variatic function, that is,

00:03:42.476 --> 00:03:44.426
one that can take a
variable number of arguments,

00:03:44.836 --> 00:03:47.876
and didn't know especially
on 64-bit devices how

00:03:47.876 --> 00:03:49.416
to pass those arguments
correctly.

00:03:49.886 --> 00:03:51.476
That has been corrected
so that all

00:03:51.476 --> 00:03:54.086
of your expressions
involving printf for C

00:03:54.086 --> 00:03:56.886
and Objective-C should just
work right out of the box.

00:03:57.536 --> 00:03:59.586
And then lastly, and
truly lastly, this time,

00:03:59.876 --> 00:04:01.506
we have improved the
disassembly format

00:04:01.506 --> 00:04:05.066
to make it easier
than ever to read.

00:04:05.426 --> 00:04:07.846
Digging into some of the more
interesting enhancements,

00:04:08.716 --> 00:04:10.926
breakpoint enhancements
were made this spring

00:04:10.926 --> 00:04:12.466
that you may not be aware of.

00:04:12.826 --> 00:04:15.076
Specifically you can
now name breakpoints.

00:04:15.076 --> 00:04:18.505
And it may not seem obvious
why a named breakpoint would be

00:04:18.505 --> 00:04:21.236
easier to use than any other
breakpoint, until you realize

00:04:21.286 --> 00:04:23.156
that those names don't
have to be unique

00:04:23.156 --> 00:04:25.736
and that you can apply multiple
names to a single breakpoint.

00:04:26.006 --> 00:04:29.396
You can think of
them a lot like tags.

00:04:29.566 --> 00:04:32.426
And all breakpoint
commands take those names.

00:04:32.586 --> 00:04:35.786
So I can set a breakpoint
by providing breakpoint set

00:04:35.936 --> 00:04:40.526
and dash N, capital N followed
by a name, optionally followed

00:04:40.526 --> 00:04:43.286
by another dash capital N and
additional name, and so forth.

00:04:44.156 --> 00:04:46.616
But more importantly, once
I've given a breakpoint

00:04:46.796 --> 00:04:50.216
or multiple breakpoints a name,
I can then operate on them

00:04:50.466 --> 00:04:51.606
with all the other commands.

00:04:51.606 --> 00:04:54.966
Breakpoint enable name
will enable all breakpoints

00:04:55.266 --> 00:04:59.846
that share that name or,
again, think of it as that tag.

00:05:00.046 --> 00:05:02.466
That is made even more
interesting by the fact

00:05:02.466 --> 00:05:05.496
that we now allow you to
set breakpoints in LLDBinit.

00:05:06.276 --> 00:05:07.996
If you're not familiar
with LLDBinit,

00:05:08.206 --> 00:05:12.416
this is a filename starting with
a prefix with a period that goes

00:05:12.416 --> 00:05:15.666
in your home directory that
tells LLDB, here are a bunch

00:05:15.666 --> 00:05:19.366
of commands to execute every
time I start an LLDB session.

00:05:20.256 --> 00:05:22.156
So if you use these,
you can create a set

00:05:22.156 --> 00:05:24.846
of default breakpoints
when LLDB starts,

00:05:25.166 --> 00:05:28.226
and all breakpoints you set
before you actually create a

00:05:28.226 --> 00:05:31.536
target are inherited by
every target you create.

00:05:32.646 --> 00:05:36.256
So combine these two, and I
can write an LLDBinit along

00:05:36.256 --> 00:05:36.846
these lines.

00:05:37.236 --> 00:05:39.306
A set of breakpoints, -n
everything named malloc,

00:05:39.696 --> 00:05:41.426
a breakpoint -n everything
named free,

00:05:41.656 --> 00:05:45.176
name all of those breakpoints
memory, and then disable them.

00:05:45.366 --> 00:05:47.966
And what this gives me
is a handy way to get all

00:05:47.966 --> 00:05:49.966
of my memory handling
breakpoints just

00:05:49.966 --> 00:05:53.876
by typing 'breakpoint enable
memory' in any session

00:05:53.876 --> 00:05:54.896
that I use thereafter.

00:05:55.406 --> 00:05:58.236
So, you'll have your own set,
I'm sure, of handy breakpoints

00:05:58.276 --> 00:05:59.706
that you always want
to have access to

00:05:59.896 --> 00:06:02.126
and now you can give them
easy to remember names.

00:06:02.746 --> 00:06:07.586
But, of course, you are here
not just to learn about things

00:06:07.586 --> 00:06:09.086
that we have done
and already shipped,

00:06:09.356 --> 00:06:11.706
but the things we are
just starting to preview.

00:06:11.786 --> 00:06:14.636
Xcode 7, really important
release,

00:06:14.986 --> 00:06:16.406
a lot of improvements here.

00:06:16.636 --> 00:06:18.376
An expression evaluation,
notably.

00:06:18.606 --> 00:06:21.066
And Sean is going to talk to you
a lot more in depth about this.

00:06:21.696 --> 00:06:24.406
Swift 2 support, because, of
course, the language continues

00:06:24.406 --> 00:06:27.546
to evolve, as well as
Objective-C support in terms

00:06:27.546 --> 00:06:29.376
of advanced handling
for modules.

00:06:30.646 --> 00:06:32.146
Some of this we'll
cover in depth,

00:06:32.546 --> 00:06:34.806
but some of it is really
just behind the scenes.

00:06:34.806 --> 00:06:36.796
If you go digging, you
may notice, for example,

00:06:36.796 --> 00:06:39.976
that in Xcode 7, because
we know about modules,

00:06:40.736 --> 00:06:44.086
we can actually build debug
information for the module once

00:06:44.366 --> 00:06:46.516
and then not replicate
it everywhere else.

00:06:46.856 --> 00:06:50.176
This allows us to
drastically decrease the size

00:06:50.746 --> 00:06:54.096
of debug information and improve
the performance of compilation.

00:06:54.666 --> 00:06:56.656
Once you get into
actual .dSYM file,

00:06:56.656 --> 00:06:59.596
that .dSYM file will then
contain absolutely everything

00:06:59.596 --> 00:07:00.056
you need.

00:07:00.536 --> 00:07:03.026
But it also contains some
handy other optimizations,

00:07:03.026 --> 00:07:06.006
like not duplicating
information for C++ types,

00:07:06.376 --> 00:07:07.886
thanks to the one
definition rule,

00:07:08.126 --> 00:07:10.266
whereas before we may
have had multiple copies.

00:07:10.786 --> 00:07:13.576
In fact, we have seen
debug information winding

00:07:13.576 --> 00:07:18.076
up a sixth the size
that it was in Xcode 6,

00:07:18.236 --> 00:07:19.906
especially for C++ projects.

00:07:20.466 --> 00:07:23.456
We have also improved the data
formatting in a variety of ways.

00:07:23.706 --> 00:07:26.996
Vector types now get unique
automatic data formatting both

00:07:26.996 --> 00:07:28.476
for Objective-C and Swift.

00:07:29.036 --> 00:07:31.946
And, perhaps most importantly,
if you have custom types

00:07:32.086 --> 00:07:35.396
in Swift, you can now customize
the way they are presented just

00:07:35.506 --> 00:07:36.576
by writing Swift code.

00:07:36.576 --> 00:07:39.936
And Enrico will talk
about this in depth.

00:07:40.276 --> 00:07:42.796
We have integrated support for
address sanitizer into LLDB.

00:07:42.796 --> 00:07:45.986
So not only will address
sanitizer tell you

00:07:45.986 --> 00:07:47.506
when you reference
memory that is invalid,

00:07:47.796 --> 00:07:49.466
but you can ask questions
about memory.

00:07:49.846 --> 00:07:52.906
You can ask, for example, for
the history of memory to see

00:07:52.906 --> 00:07:55.556
where it was allocated or
when it was deallocated,

00:07:55.756 --> 00:07:59.006
right from the LLDB
console, so the memory family

00:07:59.006 --> 00:08:01.286
of commands are ones you
might want to dig into

00:08:01.346 --> 00:08:03.706
and look at the help for.

00:08:03.916 --> 00:08:06.606
We've also added
type lookup commands.

00:08:06.886 --> 00:08:09.496
The type lookup command will
allow you to get information

00:08:09.496 --> 00:08:10.906
about any type in the system.

00:08:11.436 --> 00:08:13.786
Basically it's a
header-like representation

00:08:13.786 --> 00:08:16.296
that you can get right there
in the debugger to remind you

00:08:16.376 --> 00:08:17.746
about the contents of the type.

00:08:19.146 --> 00:08:20.606
So, from the LLDB prompt,

00:08:21.116 --> 00:08:24.596
all I need to do is type 'type
lookup' followed by a type name

00:08:24.836 --> 00:08:26.806
and I'll get a quick
description of that type.

00:08:26.966 --> 00:08:28.866
In this case the new
error type that's used

00:08:28.866 --> 00:08:31.026
by Swift's error
handling mechanism.

00:08:31.346 --> 00:08:33.586
I see that behind the
scenes we have a pair

00:08:33.586 --> 00:08:36.606
of properties normally
implemented for you so long

00:08:36.606 --> 00:08:37.785
as you're using a EDAM type,

00:08:38.216 --> 00:08:40.726
but nonetheless you can see the
details right from the console.

00:08:41.206 --> 00:08:43.145
Similarly if I'm
interested in a type

00:08:43.145 --> 00:08:44.876
like 'Comparable,' a protocol.

00:08:45.216 --> 00:08:47.136
It will tell me that this
protocol actually derives

00:08:47.136 --> 00:08:49.936
from two others, so that you
will see that Equatable is

00:08:49.936 --> 00:08:51.626
where we get the
equality operator.

00:08:52.066 --> 00:08:54.806
The underscore Comparable is
where we get the basic less-than

00:08:55.116 --> 00:08:57.246
and then the derived
operators are part

00:08:57.246 --> 00:08:58.316
of the Comparable protocol.

00:08:58.776 --> 00:09:01.206
So there's a lot of convenient
information you can get here.

00:09:01.496 --> 00:09:04.516
And like everything else,
remind you that you don't have

00:09:04.566 --> 00:09:06.576
to type the full
command 'type lookup.'

00:09:06.836 --> 00:09:10.266
TY space L is sufficient
to use this command.

00:09:10.846 --> 00:09:13.986
But to dive into more depth,
especially to talk to us

00:09:13.986 --> 00:09:15.696
about how we evaluate
expressions,

00:09:15.996 --> 00:09:17.956
I would like to invite up
Sean Callanan [applause].

00:09:19.456 --> 00:09:19.876
>> SEAN CALLANAN: Hello.

00:09:21.606 --> 00:09:24.276
I want to tell you
about compilers in LLDB.

00:09:24.276 --> 00:09:26.346
Now you may be saying

00:09:26.346 --> 00:09:28.916
to yourself there are
lots of compiler sessions.

00:09:29.296 --> 00:09:30.456
Why do I care about compilers?

00:09:31.566 --> 00:09:34.486
Compilers are a critical
part of LLDB.

00:09:35.276 --> 00:09:37.646
They are what makes
LLDB powerful,

00:09:37.646 --> 00:09:40.646
and they are what
makes LLDB easy to use.

00:09:41.196 --> 00:09:44.866
It is really powerful because
compilers have a unique

00:09:44.866 --> 00:09:49.076
understanding of the way your
program works, the way it lays

00:09:49.076 --> 00:09:53.976
out its data, and what you mean
when you say I want to look

00:09:53.976 --> 00:09:56.876
at this variable or
call this function.

00:09:56.956 --> 00:10:00.246
Another reason the
compilers are so important is

00:10:00.246 --> 00:10:02.946
because they make it easy
to work with the debugger.

00:10:03.896 --> 00:10:08.156
If you want to print something
you just use the code you are

00:10:08.156 --> 00:10:11.476
used to typing, pass it
to the expression command,

00:10:11.476 --> 00:10:14.916
and the compiler
takes over from there.

00:10:16.176 --> 00:10:19.436
So today I want to tell you

00:10:19.436 --> 00:10:21.326
about the improvements
we've made

00:10:21.816 --> 00:10:25.206
in two important areas related
to our compiler integration.

00:10:26.776 --> 00:10:29.296
First of all, I've
got some great news

00:10:29.296 --> 00:10:31.276
for you long-time
Objective-C developers.

00:10:32.486 --> 00:10:35.996
And then I'm going to tell
all you Swift developers,

00:10:35.996 --> 00:10:38.206
whom I hope is all
of you at this point,

00:10:39.446 --> 00:10:41.946
about the improvements
we've made there, too.

00:10:42.516 --> 00:10:47.246
Let's get started
on Objective-C.

00:10:47.506 --> 00:10:52.376
Now, LLDB contains two
separate compilers.

00:10:53.916 --> 00:10:58.646
Clang, a powerful Objective-C
compiler and, of course,

00:10:58.796 --> 00:11:02.606
since last year,
the Swift compiler.

00:11:02.606 --> 00:11:06.196
Our Objective-C compiler
support has been improving

00:11:06.196 --> 00:11:09.446
over the years and we have
been adding great new features.

00:11:10.686 --> 00:11:13.996
For example, the Objective-C
runtime integration.

00:11:14.826 --> 00:11:18.006
So if there's some information
in the Objective-C runtime

00:11:18.296 --> 00:11:21.946
that isn't present in your debug
information, we know to feed

00:11:21.946 --> 00:11:25.166
that to the compiler so that
you can use lots of classes

00:11:25.606 --> 00:11:27.136
without having to
do anything special.

00:11:27.656 --> 00:11:29.596
Last year, of course,

00:11:29.936 --> 00:11:32.966
we introduced the Swift
compiler into LLDB.

00:11:32.966 --> 00:11:39.026
And the Swift compiler already
is a very powerful tool.

00:11:39.496 --> 00:11:41.996
And we've used a lot of
lessons that we learned

00:11:41.996 --> 00:11:43.546
from integrating
the Swift compiler,

00:11:43.546 --> 00:11:46.106
and we are improving
them both together.

00:11:47.636 --> 00:11:50.576
Let's talk about how the
expression parser works

00:11:51.596 --> 00:11:54.696
with Swift, with a
view of Objective-C.

00:11:54.696 --> 00:11:59.966
Let's look at a simple
print command.

00:12:00.686 --> 00:12:03.556
Now I say print here because
I'm using the p shortcut.

00:12:04.476 --> 00:12:07.116
What that actually
means is expression.

00:12:08.186 --> 00:12:09.466
Notice the dash dash.

00:12:10.336 --> 00:12:14.156
That means everything after
the p command has to be code.

00:12:14.476 --> 00:12:17.746
You can't pass extra options
to the command this way.

00:12:18.356 --> 00:12:20.186
There are other ways,
as Enrico will tell you,

00:12:20.296 --> 00:12:21.496
and as Kate showed you before.

00:12:22.686 --> 00:12:25.866
Now here is some simple code
that runs through a loop

00:12:25.866 --> 00:12:27.366
and prints the loop
counter each time.

00:12:28.046 --> 00:12:30.876
And, indeed, if you run
it you get the numbers

00:12:30.876 --> 00:12:31.796
out that you would expect.

00:12:33.296 --> 00:12:34.066
Why is this cool?

00:12:35.006 --> 00:12:39.736
Well, LLDB and your program
are separate processes.

00:12:40.766 --> 00:12:43.116
LLDB has a swift
compiler inside it.

00:12:44.316 --> 00:12:48.276
Your program is already
running, but with LLDB's help,

00:12:48.866 --> 00:12:52.356
the Swift compiler can inject
the code that you just typed

00:12:52.596 --> 00:12:53.906
into your program to run.

00:12:54.506 --> 00:12:58.726
That's kind of cool if you
like printing loop counters.

00:12:59.436 --> 00:13:03.426
But there's a little
bit more to debugging.

00:13:03.516 --> 00:13:05.886
Swift also works
with your variables.

00:13:06.536 --> 00:13:08.836
You type in some code.

00:13:09.486 --> 00:13:13.176
And the contents of
an array are printed.

00:13:14.626 --> 00:13:17.526
Now, this array here
is just a piece of data

00:13:17.526 --> 00:13:18.426
that is in your program.

00:13:19.436 --> 00:13:23.236
And LLDB arranges to show
that data to the compiler

00:13:23.626 --> 00:13:26.426
so that it can generate
the code that you expect.

00:13:27.176 --> 00:13:31.306
There is another thing I want
to talk about really quickly.

00:13:31.746 --> 00:13:33.836
And that is how Swift
works with the SDK.

00:13:35.426 --> 00:13:39.286
When you type an expression like
NSApplication.sharedApplication,

00:13:40.606 --> 00:13:42.796
what happens is, first

00:13:42.796 --> 00:13:46.166
of all you see the
NSApplication.sharedApplication,

00:13:46.166 --> 00:13:46.926
the way you would expect.

00:13:48.396 --> 00:13:53.146
But what LLDB is doing is going
out and finding the SDK module

00:13:53.146 --> 00:13:56.916
that contains that, giving
the compiler access to it,

00:13:57.566 --> 00:14:00.646
then the compiler finds
NSApplication and figures

00:14:00.646 --> 00:14:02.556
out how to use
sharedApplication.

00:14:03.896 --> 00:14:07.516
That's all great and it
is automatic in Swift.

00:14:08.686 --> 00:14:12.306
In Objective-C it
doesn't always work.

00:14:13.516 --> 00:14:18.086
So let's try all these things
in Objective-C and some

00:14:18.086 --> 00:14:20.926
of you may be getting a little
bit apprehensive at this moment,

00:14:21.596 --> 00:14:25.476
because you know that trying to
NSLog something isn't as easy

00:14:25.476 --> 00:14:26.916
as it sounds in the debugger.

00:14:26.916 --> 00:14:32.356
Well, in the past when
you've typed in NSLog,

00:14:32.766 --> 00:14:36.826
you've seen errors like this:
NS log has unknown return type.

00:14:37.716 --> 00:14:40.006
That's because in
the SDK, sure enough,

00:14:40.006 --> 00:14:41.706
there's a definition of NSLog.

00:14:42.116 --> 00:14:44.296
But what LLDB sees
is only what's

00:14:44.296 --> 00:14:46.016
in the debug information
in the symbols.

00:14:46.426 --> 00:14:48.056
In this case, all
it sees is a symbol.

00:14:48.836 --> 00:14:51.236
That symbol, we don't know
what its return type is

00:14:51.376 --> 00:14:53.616
and we don't even know that
it takes a format string.

00:14:54.536 --> 00:14:57.006
Well, the good news is,
we fixed that [applause].

00:14:58.126 --> 00:14:59.686
>> SEAN CALLANAN: NSLog works
the way you would expect.

00:15:05.846 --> 00:15:09.766
Now, let's try something a
little bit more underhanded.

00:15:11.316 --> 00:15:12.836
Print NSMakeRect.

00:15:13.566 --> 00:15:14.206
Wait a second!

00:15:14.276 --> 00:15:15.516
Why is this underhanded?

00:15:15.716 --> 00:15:19.476
It's right there
in the frameworks.

00:15:19.476 --> 00:15:22.856
Unfortunately it looks like this
identifier doesn't even exist.

00:15:23.766 --> 00:15:26.706
Now, you may know
that if you use NSLog

00:15:26.706 --> 00:15:29.166
and you cast the result,
yeah, you can use that.

00:15:30.096 --> 00:15:32.086
But with NSMakeRect
you can't even do that.

00:15:33.546 --> 00:15:37.336
That's because NSMakeRect
is defined NS-Inline.

00:15:37.896 --> 00:15:39.236
There is no symbol for it.

00:15:39.796 --> 00:15:42.166
What LLDB sees is nothing.

00:15:44.106 --> 00:15:44.566
Good news.

00:15:45.346 --> 00:15:47.816
No problem anymore.

00:15:48.516 --> 00:15:53.566
[ Applause ]

00:15:54.066 --> 00:15:55.566
>> SEAN CALLANAN: Just
one more pain point left.

00:15:56.796 --> 00:16:00.266
Now let's look at
the old NSApplication

00:16:00.266 --> 00:16:01.526
sharedApplication case.

00:16:01.846 --> 00:16:04.486
Sure, if you ran that
expression by yourself, yes,

00:16:04.486 --> 00:16:05.656
it would work in Objective-C.

00:16:05.656 --> 00:16:06.826
I mean, we have been working

00:16:06.826 --> 00:16:08.536
on the Objective-C
runtime integration.

00:16:09.446 --> 00:16:12.216
But if you try to get out the
undo.Manager you quickly see

00:16:12.446 --> 00:16:14.496
that the runtime doesn't
tell you everything.

00:16:15.226 --> 00:16:17.316
In particular you
get this weird error

00:16:17.576 --> 00:16:21.546
about undo.Manager not being
found on an object of type id.

00:16:22.536 --> 00:16:23.686
What is going on there?

00:16:24.146 --> 00:16:25.636
In the SDK, sure enough,

00:16:25.636 --> 00:16:28.316
sharedApplication returns
an NSApplication star.

00:16:28.786 --> 00:16:32.836
But if you look at the
runtime, what it returns is id,

00:16:33.076 --> 00:16:36.426
a generic Objective-C object.

00:16:36.956 --> 00:16:39.906
Great news.

00:16:40.186 --> 00:16:41.426
That is no longer a problem.

00:16:41.926 --> 00:16:45.086
In fact we see information
that we can only find

00:16:45.086 --> 00:16:48.956
out from the SDK such as that
that pointer is nullable.

00:16:49.076 --> 00:16:51.716
This is some of the great
new SDK support for Swift

00:16:52.066 --> 00:16:54.266
that just bubbles down
into Objective-C as well.

00:16:55.066 --> 00:17:00.076
But the information
is right there.

00:17:00.466 --> 00:17:02.676
And that's the philosophy
that we've applied here.

00:17:03.526 --> 00:17:05.415
Read straight from the SDK.

00:17:06.205 --> 00:17:08.406
Your code has always
worked in LLDB.

00:17:08.705 --> 00:17:13.215
We knew about local variables,
functions, your own classes.

00:17:14.986 --> 00:17:16.886
SDK functions, on
the other hand,

00:17:17.656 --> 00:17:20.106
we had a little bit more
issues with, as you see.

00:17:20.915 --> 00:17:24.256
SDK classes like NSView
and NSApplication, yeah,

00:17:24.256 --> 00:17:25.695
we saw them but, as you see,

00:17:25.695 --> 00:17:27.266
because of the runtime
integration,

00:17:28.006 --> 00:17:29.626
there was a little bit
of an asterisk there.

00:17:31.116 --> 00:17:33.966
Now, SDK constants, if
you ever tried using

00:17:34.136 --> 00:17:36.566
NSASCIIStringEncoding
in an expression,

00:17:36.566 --> 00:17:37.866
you know that never flew.

00:17:39.136 --> 00:17:43.256
And if you tried using macros
like int-max, and, you know,

00:17:43.456 --> 00:17:46.006
max, to take the
largest of two numbers,

00:17:46.616 --> 00:17:48.106
that wasn't going
anywhere either.

00:17:49.226 --> 00:17:52.816
Well, all of that is
fixed in the latest LLDB.

00:17:53.516 --> 00:17:59.776
[ Applause ]

00:18:00.276 --> 00:18:00.866
>> SEAN CALLANAN: And we got rid

00:18:00.866 --> 00:18:04.776
of the annoying asterisk,
too [laughter].

00:18:05.046 --> 00:18:06.316
>> SEAN CALLANAN:
Now, you may say,

00:18:06.316 --> 00:18:09.936
how many easy monthly payments
of 39.95 do I need to make

00:18:10.196 --> 00:18:11.406
to get this functionality?

00:18:11.406 --> 00:18:13.116
Well, good news, it is all free

00:18:13.116 --> 00:18:15.766
and the way you do
it is @import AppKit.

00:18:17.116 --> 00:18:18.886
You just run an expression

00:18:19.026 --> 00:18:21.656
that says import the
frameworks I care about,

00:18:22.526 --> 00:18:24.736
if you pull in AppKit,
or for the two

00:18:24.736 --> 00:18:31.966
or three iOS programmers among
you, import UIKit, this works.

00:18:32.566 --> 00:18:39.726
Now, we haven't been standing
still with Swift either.

00:18:40.156 --> 00:18:44.476
Swift 2.0 has great
error handling support

00:18:44.656 --> 00:18:47.956
and LLDB is right off
at the bat supporting

00:18:47.956 --> 00:18:52.856
that just the way
you would expect.

00:18:52.986 --> 00:18:58.596
We can handle Swift errors and
you don't need to call 'try'

00:18:58.596 --> 00:19:00.016
when you are calling functions

00:19:00.046 --> 00:19:02.416
that could throw
errors in expressions.

00:19:03.396 --> 00:19:07.576
The reason is because
we catch stuff for you.

00:19:08.176 --> 00:19:12.456
If you type this
function 'throws' and pass

00:19:12.506 --> 00:19:13.496
that to an expression,

00:19:13.496 --> 00:19:15.366
notice this is the
same as the p command.

00:19:16.646 --> 00:19:20.996
You will get an error
variable created for you

00:19:21.256 --> 00:19:23.646
that contains the error
that that function threw.

00:19:24.236 --> 00:19:28.576
You can also do this
in the REPL.

00:19:29.276 --> 00:19:34.356
If from the REPL prompt,
you do the same thing,

00:19:34.566 --> 00:19:36.476
you get an error variable.

00:19:38.516 --> 00:19:44.226
Now, let's look at a little bit
more detail of LLDB support.

00:19:44.466 --> 00:19:47.126
And that is, you
don't always want

00:19:47.246 --> 00:19:49.236
to see what the resulting
error was.

00:19:49.926 --> 00:19:52.916
You want to know what was the
code that threw that error.

00:19:54.546 --> 00:19:55.486
Well, the way you've done this

00:19:55.486 --> 00:19:57.476
in Objective-C is
you used breakpoints.

00:19:58.706 --> 00:20:01.976
Specifically you set breakpoints
on Objective-C exceptions.

00:20:03.166 --> 00:20:06.706
The way you did this was you
used the breakpoint set command.

00:20:07.276 --> 00:20:12.676
You specify that you want
to set the breakpoint

00:20:13.016 --> 00:20:15.776
for the Objective-C exception,

00:20:16.656 --> 00:20:18.676
and we set that breakpoint
for you.

00:20:19.106 --> 00:20:21.886
Now whenever your
Objective-C code tries

00:20:21.956 --> 00:20:23.806
to throw an exception,
we'll stop.

00:20:25.196 --> 00:20:27.376
You can do the same
thing with Swift errors.

00:20:28.196 --> 00:20:30.536
Just replace the
Objective-C with Swift

00:20:30.536 --> 00:20:34.276
and we'll stop whenever
your program wants

00:20:34.316 --> 00:20:36.056
to throw a Swift error.

00:20:37.476 --> 00:20:40.806
But there's another cool
thing that you can do.

00:20:40.806 --> 00:20:45.516
And that is you can stop on
specific types of errors.

00:20:46.646 --> 00:20:48.456
This is something
we support in Swift.

00:20:49.146 --> 00:20:52.026
And the way you do it is very
simple, it's very similar

00:20:52.026 --> 00:20:54.826
to the way you would set an
expression breakpoint anyway.

00:20:56.136 --> 00:21:01.596
You use the dash O parameter,
which specifies the type name

00:21:01.876 --> 00:21:04.606
of the error you want to catch.

00:21:04.816 --> 00:21:10.886
Now if you do that, you
will stop only when the type

00:21:10.886 --> 00:21:15.276
of error you're interested
in would be thrown.

00:21:15.876 --> 00:21:23.616
Now, finally, of course you can
still catch errors the way you

00:21:23.616 --> 00:21:24.776
would in normal code.

00:21:24.776 --> 00:21:28.646
After all, the REPL is meant
partially as a way to learn

00:21:28.706 --> 00:21:30.646
and explore the way
the language works.

00:21:32.016 --> 00:21:35.076
If you import Foundation
to get an NSError

00:21:36.236 --> 00:21:39.436
and then you write some
code that throws an NSError,

00:21:40.336 --> 00:21:44.306
you can catch that
NSError and print it.

00:21:45.096 --> 00:21:48.616
If you do that, the output
will be exactly the same

00:21:48.746 --> 00:21:50.566
as if you had caught
it in your own program.

00:21:50.596 --> 00:21:55.666
So I hope you go out of
this remembering two things.

00:21:56.126 --> 00:22:01.606
First of all, add import your
modules, and second of all,

00:22:02.416 --> 00:22:04.916
try playing around with
error handing in LLDB.

00:22:04.916 --> 00:22:07.436
It's a great place to do it.

00:22:07.696 --> 00:22:10.226
Now, for much more
detail, not about how

00:22:10.226 --> 00:22:12.256
to tell your program what to do,

00:22:12.696 --> 00:22:16.006
but how to print the information
your program produces

00:22:16.006 --> 00:22:18.766
after it's done it,
I would like to call

00:22:18.766 --> 00:22:19.686
up Enrico Granata [applause].

00:22:23.046 --> 00:22:23.176
>> ENRICO GRANATA: Hi!

00:22:23.846 --> 00:22:26.036
I was in the Labs this morning.

00:22:26.316 --> 00:22:30.266
And we were trying to look
through a problem and one thing

00:22:30.266 --> 00:22:33.366
that came up is, why can
I not see this variable?

00:22:33.796 --> 00:22:35.566
What's up with that?

00:22:35.566 --> 00:22:37.956
And in order to help
us figure that out,

00:22:38.516 --> 00:22:39.856
we tried several commands.

00:22:39.856 --> 00:22:42.886
We tried expression, we tried
PO, we tried frame variable.

00:22:43.376 --> 00:22:47.086
And people usually at this
point ask, why do you have

00:22:47.086 --> 00:22:49.576
so many commands to do
pretty much the same thing?

00:22:49.616 --> 00:22:51.916
Look at my data, see what
is happening in my program.

00:22:52.536 --> 00:22:56.266
Well, all of you here get
the insider scoop now.

00:22:56.716 --> 00:22:58.596
Let's look at the
commands that LLDB has

00:22:58.716 --> 00:22:59.676
to let you look at data.

00:23:00.326 --> 00:23:01.526
There's three of them.

00:23:01.526 --> 00:23:07.046
Frame variable, the expression
command, which is the p command,

00:23:07.686 --> 00:23:09.686
the expression dash uppercase O,

00:23:09.876 --> 00:23:11.716
which as you've been
told before,

00:23:12.296 --> 00:23:14.856
you know as the po command.

00:23:15.976 --> 00:23:17.976
First one, frame
variable command.

00:23:18.696 --> 00:23:21.666
The frame variable command
which you can shorten as frv

00:23:21.666 --> 00:23:26.036
when you type it, is pretty
much the Xcode variables view.

00:23:26.606 --> 00:23:29.346
It lets you look at all
your local variables.

00:23:30.356 --> 00:23:33.656
It lets you look at only a
few of your local variables,

00:23:34.596 --> 00:23:37.806
and optionally you can
also apply formatting

00:23:38.116 --> 00:23:40.166
with the dash dash format flag.

00:23:40.636 --> 00:23:45.086
One thing I want to highlight,
because I will get back to it,

00:23:45.086 --> 00:23:48.616
is when you see that
Tuple in the first output,

00:23:49.056 --> 00:23:51.926
that is an aggregate,
that is an object

00:23:51.966 --> 00:23:53.706
that contains other objects.

00:23:54.146 --> 00:23:56.446
The things that are
within that aggregate,

00:23:56.976 --> 00:23:59.206
we call them children.

00:23:59.866 --> 00:24:04.596
The expression command is
the command you've seen a lot

00:24:04.596 --> 00:24:05.226
in this session.

00:24:05.486 --> 00:24:06.446
I'll be really brief.

00:24:06.986 --> 00:24:09.206
Of course, with the
expression command,

00:24:09.206 --> 00:24:11.426
you can do simple
arithmetic, as you'd guess.

00:24:12.526 --> 00:24:16.056
It is totally possible
to use previous results

00:24:16.666 --> 00:24:19.926
and actually do more
stuff with them.

00:24:20.166 --> 00:24:22.416
And of course, the expression
command also knows how

00:24:22.416 --> 00:24:24.576
to do custom formatting
of your results.

00:24:25.716 --> 00:24:29.356
One thing I want to point
out, once again, children.

00:24:30.786 --> 00:24:33.226
Third command, the po command.

00:24:34.146 --> 00:24:36.626
This is probably the
command that all of you

00:24:36.626 --> 00:24:39.896
who are Objective-C developers,
I'm guessing quite a few prior

00:24:39.896 --> 00:24:43.216
to Objective-C code, and
you know the po command.

00:24:43.796 --> 00:24:46.886
You can create objects and get
their description printed out.

00:24:47.786 --> 00:24:51.006
You can just create an NSArray
or print the existing NSArray

00:24:51.006 --> 00:24:52.246
and you'll see the
contents of it.

00:24:53.046 --> 00:24:56.336
Or, guess what, it
simply works for a string.

00:24:57.756 --> 00:24:59.266
So, three commands.

00:24:59.906 --> 00:25:02.076
They don't all do
exactly the same thing,

00:25:02.206 --> 00:25:03.766
as you probably guessed by now.

00:25:04.706 --> 00:25:07.996
Actually, they are
somewhat similar

00:25:07.996 --> 00:25:09.036
and not at all identical.

00:25:09.416 --> 00:25:11.846
For instance, the
expression command

00:25:11.846 --> 00:25:15.586
and the po command are
'run my code' commands.

00:25:16.086 --> 00:25:19.826
Whatever code you type,
these commands will run it.

00:25:20.556 --> 00:25:22.386
But then the frame
variable command

00:25:22.386 --> 00:25:25.236
and expression command
do step 2 differently.

00:25:25.716 --> 00:25:27.486
When they have to
show you your result,

00:25:27.856 --> 00:25:30.136
they use the LLDB
formatter system.

00:25:31.346 --> 00:25:34.216
We talked quite a bit about
the LLDB formatter system

00:25:34.346 --> 00:25:36.476
in past WWDC sessions.

00:25:36.856 --> 00:25:38.546
And you should totally
go check them out.

00:25:39.086 --> 00:25:41.896
But really briefly,
LLDB has knowledge

00:25:41.896 --> 00:25:45.446
of some built-in system types
and automatically formats them.

00:25:45.776 --> 00:25:48.456
NSArray, NSDictionaries
with strings.

00:25:48.936 --> 00:25:50.966
And it is possible for you

00:25:50.966 --> 00:25:53.496
to provide your own format
as written in Python.

00:25:54.696 --> 00:25:55.576
On the other hand,

00:25:55.986 --> 00:25:58.216
the po command will not
use LLDB formatters.

00:25:58.646 --> 00:26:02.766
The po command runs some more
extra code behind the covers,

00:26:03.136 --> 00:26:06.276
behind the scenes, to actually
produce the result it has

00:26:06.316 --> 00:26:06.766
to show you.

00:26:06.806 --> 00:26:10.576
You probably have written at
least one description method

00:26:10.576 --> 00:26:13.376
in one of your Objective-C
classes and then you realized,

00:26:13.506 --> 00:26:15.196
oh, that's what po prints.

00:26:16.266 --> 00:26:20.016
Now I want you to think for a
second about these two models

00:26:20.016 --> 00:26:23.756
of actually taking your object
and producing data for it.

00:26:24.136 --> 00:26:28.346
The LLDB formatter's model
is what we call the 'out

00:26:28.346 --> 00:26:29.576
of process' formatting model.

00:26:29.996 --> 00:26:33.636
Why? Because the formatter
sits outside of your process.

00:26:33.946 --> 00:26:36.376
It is either built
knowledge into the debugger

00:26:36.846 --> 00:26:39.596
or you brought some Python
script to represent your object.

00:26:39.596 --> 00:26:41.976
It's different languages,
different files

00:26:42.066 --> 00:26:43.756
that live in different scopes.

00:26:44.636 --> 00:26:48.706
On the other hand, that external
formatter lives in the dugger.

00:26:48.906 --> 00:26:51.936
It is really easy for
that guy to get access

00:26:51.936 --> 00:26:54.436
to all the knowledge about your
program that the debugger has.

00:26:54.736 --> 00:26:57.276
It's kind of like a bird's
eye view of your process.

00:26:57.526 --> 00:27:01.506
Because of that, it's also
really easy for this kind

00:27:01.506 --> 00:27:03.076
of formatter to make sure

00:27:03.076 --> 00:27:05.146
that your program
state is not changed.

00:27:05.666 --> 00:27:07.986
You don't want to change
the state of your program

00:27:07.986 --> 00:27:10.326
as a result of looking
at data in the debugger.

00:27:10.756 --> 00:27:13.786
The debugger is kind of
like the stage inspector.

00:27:13.786 --> 00:27:16.406
It looks at things and
tries not to change them.

00:27:17.616 --> 00:27:20.046
The other model, the po model,

00:27:20.416 --> 00:27:24.286
the 'write a description
method' model is an in-process

00:27:24.286 --> 00:27:25.126
formatting model.

00:27:25.616 --> 00:27:28.356
You write your data and
your formatter together,

00:27:28.666 --> 00:27:30.566
you write them in
the same language.

00:27:31.116 --> 00:27:33.656
You probably even write
them in the same file.

00:27:34.606 --> 00:27:37.056
And because your formatter
is just code that runs

00:27:37.056 --> 00:27:40.496
in your application, it
gets easy and full access

00:27:40.496 --> 00:27:42.746
to the object model
of your application.

00:27:44.046 --> 00:27:47.846
But with great power,
comes great responsibility.

00:27:48.526 --> 00:27:52.116
You want to make sure that your
formatter does not change the

00:27:52.116 --> 00:27:52.976
state of your program.

00:27:53.526 --> 00:27:56.486
You want to make sure you don't
do anything in your formatter

00:27:56.896 --> 00:27:59.176
that will alter the object
you're trying to represent.

00:28:00.976 --> 00:28:04.396
Well, you say, okay,
Objective-C has an in-process

00:28:04.396 --> 00:28:05.136
formatting model.

00:28:05.456 --> 00:28:06.856
I can write a description
method,

00:28:06.856 --> 00:28:08.036
the debugger will pick it up.

00:28:08.786 --> 00:28:10.556
What about Swift?

00:28:11.346 --> 00:28:13.566
Turns out, and once again,
those of you that are

00:28:13.566 --> 00:28:15.006
in this room get
the insider scoop,

00:28:15.446 --> 00:28:18.256
that Swift has had an
in-process formatting model

00:28:18.646 --> 00:28:19.746
since the very beginning.

00:28:20.696 --> 00:28:21.396
But, where is it?

00:28:21.616 --> 00:28:22.676
How do I use it?

00:28:23.126 --> 00:28:26.496
I hope all of you have
used the Swift playground.

00:28:27.116 --> 00:28:28.986
If you have used the
Swift playground,

00:28:29.496 --> 00:28:32.126
you have used the Swift
in-process formatting model.

00:28:32.356 --> 00:28:35.836
It has been there
since the beginning.

00:28:35.836 --> 00:28:36.526
So what is new?

00:28:37.436 --> 00:28:41.236
Now in Xcode 7, we take
that very same model,

00:28:41.796 --> 00:28:43.486
we make it public API.

00:28:44.416 --> 00:28:46.986
It is available for you to use.

00:28:46.986 --> 00:28:50.066
And it still powers
the playgrounds,

00:28:50.656 --> 00:28:53.806
but now it also powers
the LLDB po command.

00:28:54.436 --> 00:28:56.606
Now you've got the
right Swift formatters

00:28:56.656 --> 00:28:58.006
for your Swift objects.

00:28:58.696 --> 00:29:01.406
How? Let's look a little
bit under the cover.

00:29:01.916 --> 00:29:05.306
The model is based
upon four protocols.

00:29:05.886 --> 00:29:07.836
These are their names.

00:29:09.286 --> 00:29:11.426
Yes, I said four protocols.

00:29:12.086 --> 00:29:13.856
And their names are
also quite lengthy.

00:29:14.616 --> 00:29:16.666
But I wouldn't worry
too much about that.

00:29:16.946 --> 00:29:20.126
It's possible to only opt-in
partially to this model.

00:29:20.376 --> 00:29:22.306
The four protocols
doesn't mean you have

00:29:22.306 --> 00:29:23.956
to conform to all of them.

00:29:23.956 --> 00:29:26.576
You can choose a subset to
get the result you want done.

00:29:27.156 --> 00:29:30.256
>> ENRICO: Conform to those,
do that work, and profit.

00:29:31.486 --> 00:29:32.406
Let's look at the protocols.

00:29:33.836 --> 00:29:37.336
CustomStringConvertible is
the protocol that tells,

00:29:37.926 --> 00:29:42.286
that tells us, how would I
print my object as a string?

00:29:42.816 --> 00:29:45.426
It doesn't only tell LLDB.

00:29:45.716 --> 00:29:47.166
It also tells Swift.

00:29:47.856 --> 00:29:50.266
How? The Swift print function,

00:29:50.816 --> 00:29:53.466
as well as the Swift string
interpolation feature,

00:29:53.776 --> 00:29:55.656
both use the
CustomStringConvertible

00:29:55.656 --> 00:29:56.206
protocol.

00:29:57.276 --> 00:29:58.416
That's a lot of benefit.

00:29:58.586 --> 00:30:00.596
How hard can it be to get it?

00:30:01.346 --> 00:30:02.676
It's pretty easy.

00:30:02.846 --> 00:30:05.026
I have a data structure
that represents the bottles

00:30:05.026 --> 00:30:07.946
of beer song, because I'm
preparing myself for the bash.

00:30:08.376 --> 00:30:10.186
And I want to print the lyrics.

00:30:10.886 --> 00:30:13.316
I create an instance of that,
and I say, how many bottles

00:30:13.316 --> 00:30:14.396
of beer are on the wall.

00:30:14.396 --> 00:30:18.366
But that's for when
everything in my app works fine.

00:30:18.366 --> 00:30:20.286
If I'm debugging it,
maybe I need a little bit

00:30:20.286 --> 00:30:21.176
more information.

00:30:21.666 --> 00:30:24.546
That's where Custom Debug
String Convertible kicks in.

00:30:25.376 --> 00:30:28.536
It's a debugger specific
representation of the object.

00:30:29.536 --> 00:30:33.786
What debugger-specific means
is really up to your app.

00:30:33.786 --> 00:30:35.756
It's really up to the
semantics of your object model.

00:30:36.506 --> 00:30:40.166
But, as a hint, the
debugPrint function will default

00:30:40.166 --> 00:30:41.626
to choosing this protocol.

00:30:42.326 --> 00:30:46.266
Of course, both print and
debugPrint will fall back

00:30:46.316 --> 00:30:49.496
to the other conformance if
their favorite one isn't there.

00:30:50.476 --> 00:30:52.266
How to get this to work?

00:30:52.266 --> 00:30:52.986
Pretty simple.

00:30:53.966 --> 00:30:55.276
Let's extend our
bottles of beer.

00:30:55.386 --> 00:30:58.626
Because we are debugging, we
want to know a little bit more

00:30:58.626 --> 00:31:01.436
about the bottles of beer on
the wall, so we can just check

00:31:01.496 --> 00:31:03.916
that they are all correctly
stout, and it is going

00:31:03.916 --> 00:31:05.466
to be a great bash
because they all are.

00:31:06.316 --> 00:31:10.656
Third protocol is Custom
Playground Quick Lookable.

00:31:11.776 --> 00:31:12.876
As the name implies,

00:31:13.366 --> 00:31:16.196
this protocol is
specifically for playgrounds.

00:31:16.476 --> 00:31:20.726
It is meant to provide rich
graphical representations

00:31:20.726 --> 00:31:22.596
of your object in a playground.

00:31:23.706 --> 00:31:24.466
You want an example?

00:31:24.726 --> 00:31:25.716
Sure thing.

00:31:26.626 --> 00:31:29.636
I can write a data structure
that represents a person,

00:31:29.636 --> 00:31:32.726
and then I can get a
depiction of a person to show

00:31:32.726 --> 00:31:35.306
up in my playground
sidebar as a result

00:31:35.306 --> 00:31:37.526
of creating an object
of that type.

00:31:38.556 --> 00:31:41.846
I'm quite sorry to disappoint
you guys, I really wanted

00:31:41.846 --> 00:31:42.826
to get this to happen.

00:31:43.146 --> 00:31:44.716
But, unfortunately the t-shirts

00:31:44.716 --> 00:31:47.806
with my person will not
be sold at the conference.

00:31:48.356 --> 00:31:52.176
Sorry. But I have something
to make up for that.

00:31:52.696 --> 00:31:56.126
The last protocol in the lot,
the Custom Reflectable protocol.

00:31:56.426 --> 00:31:58.466
It allows us to invent
a entirely custom

00:31:58.686 --> 00:31:59.666
children hierarchy.

00:32:00.076 --> 00:32:02.916
Yes, I said I would get back to
the word 'children' and I did.

00:32:04.036 --> 00:32:07.136
When I say an entirely
custom children hierarchy,

00:32:08.276 --> 00:32:11.926
what I mean is that
I can make a new --

00:32:11.926 --> 00:32:14.786
I can make a new
structure for my object.

00:32:15.016 --> 00:32:17.196
I can tell the language,
I can tell the debugger,

00:32:17.196 --> 00:32:18.206
I can tell the playgrounds,

00:32:18.636 --> 00:32:20.786
this is what my object
is actually made of.

00:32:20.876 --> 00:32:22.006
This is how you should see it.

00:32:22.566 --> 00:32:26.416
And the way you do this, the
currency that you transact in,

00:32:26.866 --> 00:32:29.106
when you're trying to describe
the structure of objects

00:32:29.156 --> 00:32:33.426
to Swift, is called a
Mirror, reflectable mirror.

00:32:35.226 --> 00:32:37.766
Let's see an example,
without further ado.

00:32:38.056 --> 00:32:40.596
I have an application
whose job it is

00:32:40.816 --> 00:32:42.726
to collect temperature samples.

00:32:43.046 --> 00:32:45.116
It has got a couple
data structures.

00:32:45.706 --> 00:32:49.556
One that describes a moment
in time, and one says,

00:32:49.746 --> 00:32:51.126
for a given moment in time,

00:32:51.536 --> 00:32:53.516
this was the temperature
information I got.

00:32:54.236 --> 00:32:56.206
And then we have got
temperature samples, of course.

00:32:57.256 --> 00:32:58.356
Now I'm debugging this app.

00:32:58.356 --> 00:33:00.796
I'm trying to see
what is going on,

00:33:00.796 --> 00:33:02.146
how it's processing the samples.

00:33:02.686 --> 00:33:05.156
So I say po temperatures.

00:33:05.626 --> 00:33:07.246
And that's what I got.

00:33:08.716 --> 00:33:11.426
Honestly, you know, I
look at it and I say,

00:33:11.426 --> 00:33:13.676
it is not bad for a default.

00:33:14.406 --> 00:33:16.216
But I immediately see
a couple things I want

00:33:16.216 --> 00:33:17.146
to change about this.

00:33:17.936 --> 00:33:20.136
Why stack time on two lines?

00:33:20.136 --> 00:33:22.456
I really wish it
was all in one line.

00:33:22.826 --> 00:33:24.906
And it would be great
if it was in a.m.

00:33:24.906 --> 00:33:26.756
/p.m. format, too.

00:33:26.916 --> 00:33:29.816
And that temperature, I
look at it and I'm like,

00:33:30.046 --> 00:33:31.636
what scale is that in?

00:33:31.706 --> 00:33:32.436
I don't even know.

00:33:32.676 --> 00:33:35.696
Is it Kelvin, is it
Reaumur, is it Rankine?

00:33:36.006 --> 00:33:39.116
We are in America and
we want our Fahrenheit

00:33:40.766 --> 00:33:40.966
degrees [laughter].

00:33:41.056 --> 00:33:44.296
>> ENRICO GRANATA: Well, the
good news is that we can fix all

00:33:44.296 --> 00:33:46.856
of these things, in two steps.

00:33:48.306 --> 00:33:52.356
Let's go. Step one, let's get
the time printed on one line.

00:33:53.156 --> 00:33:56.776
Here is what I did to get
that to happen for me.

00:33:57.186 --> 00:33:59.076
I used an NSDate formatter.

00:34:00.726 --> 00:34:03.806
Because I got to run
within my application,

00:34:04.186 --> 00:34:05.696
because the code I'm running

00:34:05.696 --> 00:34:09.686
to format this object is
actually just normal Swift code,

00:34:09.976 --> 00:34:12.766
it is just code I would normally
write as part of my app,

00:34:12.846 --> 00:34:15.056
whatever framework,
whatever library,

00:34:15.386 --> 00:34:17.696
whatever technology my
app would normally use

00:34:17.696 --> 00:34:21.016
to get this job done, I can
just use it in my formatters.

00:34:21.496 --> 00:34:23.606
In this case NSDate formatter.

00:34:24.926 --> 00:34:28.295
Step two, let's get those
Fahrenheit degrees going.

00:34:29.456 --> 00:34:30.886
How do we do it?

00:34:31.696 --> 00:34:32.946
We create a mirror.

00:34:33.576 --> 00:34:34.176
Here we are.

00:34:34.876 --> 00:34:38.266
Now we are saying that our
temperature data object is

00:34:38.266 --> 00:34:41.626
structured as a container
of three things.

00:34:42.246 --> 00:34:44.286
A time, a temperature
in Centigrade,

00:34:44.286 --> 00:34:45.596
and a temperature in Fahrenheit.

00:34:46.235 --> 00:34:48.626
The time is the string
interpolation

00:34:48.916 --> 00:34:51.755
of the actual time data
stored inside the object.

00:34:52.496 --> 00:34:54.896
And because it is
string interpolated

00:34:54.896 --> 00:34:57.766
and because we provided a custom
string convertible conformance,

00:34:58.386 --> 00:35:00.266
that will be automatically
picked up.

00:35:01.216 --> 00:35:04.496
One more thing worth
noticing here is

00:35:04.576 --> 00:35:08.246
that when I get both scales,
when I get both Centigrade

00:35:08.246 --> 00:35:10.596
and Fahrenheit for
my result printing,

00:35:11.106 --> 00:35:13.916
I don't change the value
stored inside the object.

00:35:13.976 --> 00:35:15.866
Of course, you say, you don't.

00:35:16.346 --> 00:35:20.036
Well, it is actually quite a
bit important to remember not

00:35:20.036 --> 00:35:21.416
to change the state
of your program

00:35:21.596 --> 00:35:23.296
by writing in-process
formatters.

00:35:24.066 --> 00:35:27.476
And now that we've done all this
work, now we've got all this,

00:35:28.666 --> 00:35:30.376
now how do we benefit?

00:35:31.726 --> 00:35:35.496
Well, we could try
po-ing that again.

00:35:35.686 --> 00:35:36.986
And here we go.

00:35:37.196 --> 00:35:38.526
And now I look at it again.

00:35:38.666 --> 00:35:39.586
I see my object.

00:35:39.636 --> 00:35:42.256
And I can look and I see now

00:35:42.256 --> 00:35:46.806
that at 6:30 p.m.
it was 93.2 degrees.

00:35:49.056 --> 00:35:51.396
Yup, in case you are
wondering, it was really hot

00:35:51.396 --> 00:35:52.456
in Cupertino yesterday.

00:35:53.746 --> 00:35:58.116
And now we did this work but
we did it because we were smart

00:35:58.186 --> 00:35:59.836
and we did the work
ahead of time.

00:36:00.516 --> 00:36:03.346
Sometimes I'm trying
to debug something

00:36:03.796 --> 00:36:07.076
and I got my program
just where I want it.

00:36:07.286 --> 00:36:09.806
I have got this one
hard-to-reproduce bug

00:36:10.006 --> 00:36:12.066
to finally happen.

00:36:12.326 --> 00:36:14.816
But now it is really
hard to look at the data.

00:36:15.316 --> 00:36:17.126
The data is confusing,
it's complicated.

00:36:17.286 --> 00:36:20.136
And I wish I had done
this work before,

00:36:20.436 --> 00:36:21.746
so that now I could
actually look

00:36:21.746 --> 00:36:23.146
at my data in much simpler ways.

00:36:24.066 --> 00:36:26.186
But alas I haven't.

00:36:26.186 --> 00:36:27.156
All hope is lost.

00:36:28.606 --> 00:36:30.266
Nope! No, it isn't!

00:36:30.706 --> 00:36:33.246
You can add conformances
and runtime, too.

00:36:33.246 --> 00:36:36.656
Through the expression parser
you can add these conformances

00:36:36.826 --> 00:36:39.126
and run while debugging
your app.

00:36:39.806 --> 00:36:43.156
On the other hand, you
cannot change them.

00:36:43.236 --> 00:36:45.186
Existing conformances stay.

00:36:45.186 --> 00:36:49.246
You are in the REPL,
you're experimenting.

00:36:50.016 --> 00:36:51.706
You really wish you
could po something.

00:36:52.166 --> 00:36:54.136
Oh, how I wish I could
add a conformance.

00:36:55.326 --> 00:36:56.786
You can do that in
the REPL as well.

00:36:57.166 --> 00:37:02.926
And, of course, but I'm sure
you all expect that, guess what?

00:37:04.086 --> 00:37:06.346
In playgrounds, too.

00:37:07.176 --> 00:37:11.106
Look at that!

00:37:11.306 --> 00:37:15.876
It seems to me that a lot
of this work that we've done

00:37:15.876 --> 00:37:18.086
over the last year in
debugger land that you've heard

00:37:18.086 --> 00:37:22.896
from Kate, from Sean, and from
me, has to do with making sure

00:37:22.896 --> 00:37:26.826
that it is really easy to access
as much of your information

00:37:26.826 --> 00:37:28.556
as possible while
you are debugging.

00:37:29.606 --> 00:37:33.596
Access to the Objective-C
runtime gives you more insight

00:37:33.666 --> 00:37:36.146
into fields that before
were unavailable to you.

00:37:36.426 --> 00:37:41.556
The SDK modules offer an
unprecedented level of access

00:37:41.606 --> 00:37:43.056
to the operating environment

00:37:43.056 --> 00:37:45.986
that your application is
running in, more types,

00:37:45.986 --> 00:37:48.086
more functions, even macros.

00:37:49.186 --> 00:37:51.156
And in-process formatting,

00:37:52.726 --> 00:37:55.016
in-process formatting
is a great way for you

00:37:55.016 --> 00:37:58.666
to create compelling
representations of your types,

00:37:59.126 --> 00:38:00.846
that apply across the board.

00:38:01.176 --> 00:38:03.696
They apply in the playgrounds,
they apply in the REPL,

00:38:03.816 --> 00:38:05.216
they apply in the debugger.

00:38:06.626 --> 00:38:09.656
For more information, of
course, do not hesitate

00:38:09.656 --> 00:38:12.216
to visit our website,
Swift language docs,

00:38:12.486 --> 00:38:15.776
or Developer Forums, of
course, the Labs, and Stefan,

00:38:15.776 --> 00:38:17.776
our Evangelist, is
but an email away.

00:38:19.376 --> 00:38:22.326
Thank you very much,
and have a great WWDC!

00:38:24.516 --> 00:38:36.190
[ Applause ]
WEBVTT

00:00:23.516 --> 00:00:27.126
[Applause]

00:00:27.626 --> 00:00:28.126
>> MIKE SWINGLER: Good morning.

00:00:29.336 --> 00:00:32.026
Welcome to Advanced Debugging
and the Address Sanitizer.

00:00:32.576 --> 00:00:34.496
I'm Mike and [break in video]
So how are we all doing?

00:00:35.036 --> 00:00:36.506
Good? Ready?

00:00:36.856 --> 00:00:38.346
Excited? All right.

00:00:38.346 --> 00:00:38.946
Let's get going.

00:00:39.516 --> 00:00:41.816
[Applause]

00:00:42.316 --> 00:00:44.286
So I will start off and
cover some neat new features

00:00:44.286 --> 00:00:47.436
that we added to Xcode and
also show you some old tips

00:00:47.436 --> 00:00:49.276
and some new tricks that
you might not know about.

00:00:49.746 --> 00:00:51.496
We will begin with
the view debugger

00:00:51.806 --> 00:00:53.876
and see how you can get
even more insight --

00:00:53.876 --> 00:00:56.546
even more insight
into your app's UI

00:00:56.636 --> 00:01:00.116
and its user interface elements,
and how they behave at runtime.

00:01:00.646 --> 00:01:02.896
We are going to debug an
AutoLayout Constraints problem,

00:01:03.096 --> 00:01:05.206
which, at least for me, I
could always use a little help

00:01:05.465 --> 00:01:07.866
understanding exactly what
AutoLayout is doing at runtime.

00:01:09.006 --> 00:01:11.436
Next, we will dive into
debugging your code

00:01:11.436 --> 00:01:12.486
with Advanced Breakpoints.

00:01:12.916 --> 00:01:16.286
I will show you how you can set
custom actions and conditions

00:01:16.576 --> 00:01:18.166
to quickly diagnose exceptions,

00:01:18.466 --> 00:01:21.056
and conditionally print
values all without cluttering

00:01:21.056 --> 00:01:22.876
up your code with
NSLogs or prints.

00:01:23.936 --> 00:01:26.356
And after that, my colleague
Anna is going to come up

00:01:26.356 --> 00:01:27.716
and show us the newest,

00:01:27.716 --> 00:01:29.476
most exciting debugging
feature we've added

00:01:29.476 --> 00:01:32.546
to Xcodes' debugging toolbox,
the Address Sanitizer.

00:01:33.456 --> 00:01:35.896
She will do a deep dive into
how it works, and what kinds

00:01:35.896 --> 00:01:38.266
of bugs it captures, and
how you can start using it

00:01:38.266 --> 00:01:40.456
to start scrubbing
your code today.

00:01:41.146 --> 00:01:44.026
So for these first two topics,
I thought I would just start off

00:01:44.296 --> 00:01:51.076
and jump right over to the
demo machine, and show you.

00:01:55.856 --> 00:01:58.776
So here we have an
application called Jogr.

00:01:59.586 --> 00:02:03.466
It's a fitness application that
allows you to time your runs,

00:02:03.526 --> 00:02:07.116
track the routes that you take,
and tag photos along the way.

00:02:07.236 --> 00:02:10.386
We have used Jogr as a demo
app for a few years now

00:02:10.606 --> 00:02:13.766
and this year we've added
some new features using Swift,

00:02:14.086 --> 00:02:17.426
and converted some of the
classes from Objective-C.

00:02:17.666 --> 00:02:19.206
It's very much a
hybrid application.

00:02:19.956 --> 00:02:22.716
It also now uses size
classes in its storyboard,

00:02:22.716 --> 00:02:24.256
and has fully adopted
AutoLayout.

00:02:25.366 --> 00:02:27.856
So, since we changed and added
all this new code this year,

00:02:28.226 --> 00:02:30.116
it's a pretty good bet that
we've added a few bugs.

00:02:30.376 --> 00:02:31.426
So let's find them.

00:02:32.166 --> 00:02:35.796
I'm going to start off just
by clicking on the timer here,

00:02:36.536 --> 00:02:40.166
and well, the first problem
that's pretty obvious is

00:02:40.166 --> 00:02:43.646
that our ring around our
timer is getting clipped.

00:02:43.646 --> 00:02:46.036
This was not how it was

00:02:46.036 --> 00:02:48.086
in the original artwork
that I had provided.

00:02:49.026 --> 00:02:50.976
So this might have
something to do with the fact

00:02:50.976 --> 00:02:53.756
that I'm running Jogr on
an iPhone 5 screen size.

00:02:53.756 --> 00:02:56.406
As I was developing
this on the iPhone 6,

00:02:56.526 --> 00:02:57.986
I probably did not fully test,

00:02:57.986 --> 00:02:59.946
to see that the layout
was fully adaptable

00:02:59.946 --> 00:03:01.306
down to smaller screen sizes.

00:03:01.656 --> 00:03:05.336
To help get a little insight
into what's going on here,

00:03:05.676 --> 00:03:10.596
I will click on the Debug
View Hierarchy button

00:03:10.926 --> 00:03:12.126
down here in the Debug bar.

00:03:13.006 --> 00:03:16.336
Right now, a snapshot is
getting taken of all of my views

00:03:16.406 --> 00:03:19.896
and loaded into Xcode along with
a bunch of runtime information

00:03:19.956 --> 00:03:21.426
about how those views interact.

00:03:23.206 --> 00:03:26.396
As I click and drag
around the canvas,

00:03:26.786 --> 00:03:29.926
you can see how I can
twist the scene to show all

00:03:29.926 --> 00:03:31.606
of the different views,
and how they are layered

00:03:31.606 --> 00:03:32.456
on top of each other.

00:03:32.716 --> 00:03:35.376
I can even click on a
specific view to select it,

00:03:36.086 --> 00:03:39.286
and we can see all sorts of
details about it over here

00:03:39.286 --> 00:03:40.306
in the object inspector.

00:03:41.696 --> 00:03:43.566
Now, there's a lot of
stuff going on here,

00:03:43.886 --> 00:03:47.426
and with this navigation bar and
the background and all of that,

00:03:47.426 --> 00:03:49.476
and I really just want
to focus on the one thing

00:03:49.476 --> 00:03:50.866
that you care about,
which is the content

00:03:50.866 --> 00:03:52.246
that I put in the center.

00:03:53.416 --> 00:03:56.976
So you can do that just by
double-clicking on the view.

00:03:57.346 --> 00:04:00.636
Just in case you missed that,
I will show you how to unfocus,

00:04:00.706 --> 00:04:02.416
which is just double-clicking
on the canvas

00:04:03.126 --> 00:04:06.526
and here we can go again, and
we can just focus on this one.

00:04:06.526 --> 00:04:11.466
You will also notice that over
here, in the Debug Navigator,

00:04:11.616 --> 00:04:17.906
all of the hierarchy above the
UI stack view has been elided

00:04:17.906 --> 00:04:23.516
away, since we are currently
focused on the UI stack view.

00:04:24.756 --> 00:04:30.226
If I click on the image that
is getting clipped here,

00:04:30.816 --> 00:04:34.056
I can inspect its
balance and constraints

00:04:34.146 --> 00:04:38.836
with the size inspector here.

00:04:39.766 --> 00:04:43.246
The size inspector doesn't
just show me the x, y,

00:04:43.246 --> 00:04:47.206
and Rect coordinates of this,
it also shows me the constraints

00:04:47.236 --> 00:04:49.426
that are affecting
this view at runtime.

00:04:49.946 --> 00:04:53.566
The constraints that are not
actually in play right now,

00:04:53.566 --> 00:04:56.916
that are affecting the size, or
the bounds, or the x and the y,

00:04:57.346 --> 00:04:58.986
are shown down here in gray.

00:04:59.846 --> 00:05:01.836
So this is actually
a little odd.

00:05:01.836 --> 00:05:05.706
I see that the self height
constraint of 249 points,

00:05:05.806 --> 00:05:07.646
which is the actual
content size of this image,

00:05:08.036 --> 00:05:09.766
is not actually in
play at runtime.

00:05:10.206 --> 00:05:11.406
If I look up to the constraint

00:05:11.406 --> 00:05:15.646
that says the superview should
be the same size as the image,

00:05:15.916 --> 00:05:17.176
we see that it is in play.

00:05:17.606 --> 00:05:20.516
It's like something else
is constraining the size

00:05:20.666 --> 00:05:21.446
of superview.

00:05:22.116 --> 00:05:25.816
So let's walk up the view
hierarchy and see what's going

00:05:25.816 --> 00:05:26.666
on with that superview.

00:05:28.226 --> 00:05:34.516
So here, we see that
there is a three-fourths

00:05:34.516 --> 00:05:38.256
or a .75 relationship
to this other view,

00:05:38.526 --> 00:05:40.286
and I know that that
other view is the one

00:05:40.286 --> 00:05:42.636
that contains my start
button down below.

00:05:43.446 --> 00:05:45.066
We can see all the
same constraints

00:05:45.136 --> 00:05:46.966
over in the debug
navigator as well,

00:05:47.256 --> 00:05:49.666
and we can open them
up like this.

00:05:49.666 --> 00:05:54.386
We see that we have the same
three-fourths constraint

00:05:54.626 --> 00:05:56.446
on the view that
contains the button,

00:05:56.896 --> 00:05:58.746
and everything here
looks normal.

00:05:58.746 --> 00:06:01.386
The top and the bottom
relationships are sensical,

00:06:01.386 --> 00:06:03.146
top is higher than
bottom, bottom is connected

00:06:03.146 --> 00:06:06.296
to the superviews
bottom, and nothing else.

00:06:06.506 --> 00:06:09.806
So why don't we walk up the
view hierarchy one more level.

00:06:10.406 --> 00:06:16.566
And we can see here that there
is something a little bit odd.

00:06:17.276 --> 00:06:20.876
We have a center
y-constraint that is trying

00:06:20.876 --> 00:06:24.346
to keep the entire stack
view centered vertically

00:06:24.346 --> 00:06:28.786
in its container, but we also
have this self-top connected

00:06:28.786 --> 00:06:31.686
to the superview
top by 50 points.

00:06:32.186 --> 00:06:35.366
And that's kind of odd.

00:06:35.366 --> 00:06:38.356
So I don't think that 50-point
constraint should actually

00:06:38.356 --> 00:06:38.726
be there.

00:06:39.066 --> 00:06:40.446
I think it probably was added

00:06:40.446 --> 00:06:42.956
when I was initially switching
this view over to size classes,

00:06:42.956 --> 00:06:45.646
and I told IB to just add
all the missing constraints,

00:06:46.066 --> 00:06:47.956
and then later I set up
the vertical centering,

00:06:47.956 --> 00:06:49.986
and I probably forgot
to remove it.

00:06:49.986 --> 00:06:53.576
Let's change this over
here on our storyboard

00:06:55.176 --> 00:06:56.196
and see if that's the issue.

00:06:57.516 --> 00:07:01.446
So I can select the stack
view and there it is.

00:07:01.496 --> 00:07:03.046
That's our 50-point constraint.

00:07:03.046 --> 00:07:04.166
I will just delete that.

00:07:05.006 --> 00:07:05.996
And rerun.

00:07:06.626 --> 00:07:10.196
And great!

00:07:10.306 --> 00:07:13.296
Now our circle goes
all the way around.

00:07:13.446 --> 00:07:16.366
Nothing is clipped, and this
view is fully adaptable.

00:07:17.556 --> 00:07:20.476
So let's try running the timer.

00:07:22.006 --> 00:07:24.796
Okay. Looks like I got a crash.

00:07:25.226 --> 00:07:28.456
I'm going to switch the
Debug Navigator here

00:07:28.456 --> 00:07:31.866
to view the crashing thread,

00:07:32.456 --> 00:07:34.996
and that's not really
all that helpful.

00:07:34.996 --> 00:07:37.066
It has crashed in main.

00:07:37.646 --> 00:07:43.616
If I pull up here on the
console, I can see that, well,

00:07:43.616 --> 00:07:46.716
this was some sort of exception
that was thrown, but this is not

00:07:46.716 --> 00:07:49.076
as helpful to me right
now, because I want

00:07:49.076 --> 00:07:52.246
to actually stop the program
and be able to debug it

00:07:52.246 --> 00:07:53.926
at the moment that the
exception is thrown.

00:07:55.086 --> 00:07:59.076
In order to do that, I can go
to the Breakpoint Navigator

00:07:59.676 --> 00:08:04.356
and click down here on the plus
to add an exception breakpoint,

00:08:04.356 --> 00:08:07.096
and I'm going to configure
this breakpoint to stop

00:08:07.096 --> 00:08:09.296
on just Objective-C exceptions.

00:08:09.926 --> 00:08:11.576
Like that.

00:08:12.926 --> 00:08:17.046
And we can just re-run
the application.

00:08:17.746 --> 00:08:23.176
And hopefully we'll just
catch the problem right

00:08:23.176 --> 00:08:25.006
at the moment that it occurred.

00:08:25.936 --> 00:08:29.606
So this is great, but if I look

00:08:29.606 --> 00:08:32.366
at my console now, I
don't see anything.

00:08:32.525 --> 00:08:36.926
There's no message to describe
exactly what the exception is.

00:08:37.116 --> 00:08:39.816
So I'm going to use a trick
that I learned from my friends

00:08:39.816 --> 00:08:42.416
on the LLVM team,
I'm going to navigate

00:08:42.556 --> 00:08:44.726
to the Ob-C Exception
Throw function,

00:08:44.866 --> 00:08:45.936
inside the Ob-C runtime.

00:08:45.936 --> 00:08:49.496
I will print the first
argument of that function,

00:08:50.026 --> 00:08:52.266
which is actually the
exception object itself.

00:08:52.326 --> 00:08:56.266
I do that by saying
print object, arg1,

00:08:57.276 --> 00:09:01.286
and this is the actual
exception message itself.

00:09:02.106 --> 00:09:04.086
So this is so helpful
that I'm going

00:09:04.086 --> 00:09:06.856
to actually modify our
exception breakpoint

00:09:07.186 --> 00:09:09.616
to just do this all the time,
for any exception that we hit.

00:09:09.616 --> 00:09:13.746
I can add an action
here and I'm going

00:09:13.746 --> 00:09:15.386
to just type the
exact same thing

00:09:15.386 --> 00:09:16.506
that I typed into the console.

00:09:17.186 --> 00:09:19.446
Print object arg1.

00:09:21.146 --> 00:09:28.146
Now if I rerun the
application, run the timer,

00:09:29.486 --> 00:09:32.196
now I'm still stopped
at the exact moment

00:09:32.426 --> 00:09:35.646
that the exception was thrown.

00:09:36.056 --> 00:09:40.226
I actually have the exception
message itself in the console,

00:09:41.186 --> 00:09:44.666
and so here now when
I look at the line

00:09:44.666 --> 00:09:46.746
that this exception
is being thrown from,

00:09:47.036 --> 00:09:52.116
I can see that I'm constructing
a range, and the range is

00:09:52.116 --> 00:09:54.786
out of bounds, and I bet it's
probably because we are starting

00:09:54.966 --> 00:09:57.856
at index one instead
of index zero,

00:09:57.856 --> 00:09:59.826
and going for the full
length of the string

00:09:59.826 --> 00:10:01.566
when we are setting
the font attribute.

00:10:02.566 --> 00:10:09.986
So let's rerun this
again and see, alright,

00:10:10.046 --> 00:10:13.526
so it looks like our timer
works correctly here.

00:10:14.896 --> 00:10:18.226
So, now we've successfully
found two bugs.

00:10:18.526 --> 00:10:20.056
Let's go for a third.

00:10:21.076 --> 00:10:24.706
So I'm now going to try
taking a look at a route

00:10:24.786 --> 00:10:28.356
that I ran this morning,
before I came here.

00:10:29.306 --> 00:10:36.536
And, that looks about right,
but if we go back again, well,

00:10:36.656 --> 00:10:39.236
that really doesn't look right
at all, I didn't start off

00:10:39.236 --> 00:10:41.336
at Mosconi, and run
down the Embarcadero,

00:10:41.336 --> 00:10:44.316
and jump in the water,
that's kind of silly.

00:10:44.826 --> 00:10:50.666
Let's try that again, And,
alright, now I just hit a crash,

00:10:50.666 --> 00:10:53.846
so, I don't know, this seems
like a, definitely a problem

00:10:53.846 --> 00:10:56.836
with our data model here.

00:10:56.836 --> 00:10:58.966
So I want to figure
out what we are doing

00:10:58.966 --> 00:11:02.516
when we are making
the overlay of points

00:11:02.856 --> 00:11:04.056
that we put on to the map.

00:11:06.556 --> 00:11:10.666
So here, I'm going
to go to the class

00:11:10.936 --> 00:11:14.586
that we know makes the
route path overlay.

00:11:15.186 --> 00:11:18.006
And this is where we actually
take a bunch of data points,

00:11:18.506 --> 00:11:21.396
and pull them out of a
dictionary, and create

00:11:21.396 --> 00:11:28.286
and construct a poly line that
represents the route that I ran.

00:11:28.386 --> 00:11:33.226
So here I'm going to set a
breakpoint and see what sort

00:11:33.226 --> 00:11:34.776
of data values we get.

00:11:35.886 --> 00:11:39.436
I'm going to open up the
Debug Console and look

00:11:39.436 --> 00:11:44.316
at the variables view, and
down here, we can see the point

00:11:44.676 --> 00:11:45.656
that I'm interested in.

00:11:45.656 --> 00:11:47.806
It has these values.

00:11:47.806 --> 00:11:51.476
I will just kind of
step forward and, well,

00:11:51.476 --> 00:11:54.696
this is interesting,
but kind of tedious.

00:11:54.736 --> 00:11:56.246
All the values kind
of look similar.

00:11:56.836 --> 00:11:59.286
What I will do here
to make this faster,

00:11:59.286 --> 00:12:01.096
and just to see all
the values together,

00:12:01.096 --> 00:12:02.396
is I will edit this breakpoint.

00:12:02.936 --> 00:12:06.396
I will print the point Struct

00:12:07.866 --> 00:12:12.356
that I'm actually inspecting
here in the variables view.

00:12:12.576 --> 00:12:14.766
And then I will say,
automatically continue

00:12:15.186 --> 00:12:16.496
after evaluating action.

00:12:16.556 --> 00:12:18.736
Actually, this is
not a condition.

00:12:18.736 --> 00:12:19.966
This is an action.

00:12:19.966 --> 00:12:20.416
There we go.

00:12:22.006 --> 00:12:24.896
And let's just continue
running this.

00:12:25.746 --> 00:12:30.886
And we can see that all of our
points look relatively the same,

00:12:31.396 --> 00:12:34.146
but there's still that
one that's teleporting off

00:12:34.146 --> 00:12:35.326
into the middle of nowhere.

00:12:36.226 --> 00:12:39.556
But all the values still
look, you know, reasonable.

00:12:40.096 --> 00:12:42.346
I'm not exactly sure
what the problem is here.

00:12:42.346 --> 00:12:49.466
We might have to get some
more help from someone else.

00:12:49.796 --> 00:12:59.996
So, let's switch
back to the sides.

00:13:00.506 --> 00:13:04.016
So just to recap what we saw,
first we started off by digging

00:13:04.016 --> 00:13:06.746
into a constraint problem
on the timer view of Jogr.

00:13:07.246 --> 00:13:10.416
I showed you how you can now
double-click on a view to focus

00:13:10.416 --> 00:13:11.516
on a specific component.

00:13:12.096 --> 00:13:14.376
We inspected some of the
constraints and found

00:13:14.376 --> 00:13:18.126
that just one of them needed
to be removed when we ran

00:13:18.126 --> 00:13:19.246
into another screen size.

00:13:20.206 --> 00:13:23.076
Next, we hit an exception
running the timer,

00:13:23.386 --> 00:13:25.286
and used the exception
breakpoint to stop

00:13:25.286 --> 00:13:26.756
at the exact moment
of the crash,

00:13:27.106 --> 00:13:28.716
and also print the
exception message.

00:13:29.326 --> 00:13:32.686
And finally, we were able to add
a print and continue breakpoint

00:13:32.966 --> 00:13:35.546
that added logging, all
without cluttering up our code

00:13:35.546 --> 00:13:37.146
with NSLogs or print statements.

00:13:37.906 --> 00:13:40.376
Now to help solve the next
mystery of why we are getting

00:13:40.376 --> 00:13:43.276
such odd results from the
run that I did this morning,

00:13:43.566 --> 00:13:44.856
I would like to introduce Anna.

00:13:46.516 --> 00:13:52.796
[Applause]

00:13:53.296 --> 00:13:53.936
>> ANNA ZAKS: Thank you, Mike.

00:13:54.326 --> 00:13:57.266
Hello. Let's go back
to that route

00:13:57.266 --> 00:14:00.266
that Mike showed
last in his demo.

00:14:00.266 --> 00:14:03.006
As we were testing this demo
app, you saw all of these routes

00:14:03.006 --> 00:14:05.216
and more, including
the correct one.

00:14:06.266 --> 00:14:08.516
We were really hoping
Mike would not run

00:14:08.516 --> 00:14:11.796
into the correct one again
and again while on stage,

00:14:11.796 --> 00:14:14.756
because it would be not so
good for our presentation.

00:14:15.376 --> 00:14:18.116
This unpredictable
behavior is often caused

00:14:18.116 --> 00:14:21.096
by memory corruptions, for
example, memory allocated

00:14:21.096 --> 00:14:23.956
for one object might be
overwritten by another object.

00:14:24.766 --> 00:14:27.746
Or maybe you are using memory
that does not belong to you due

00:14:27.746 --> 00:14:29.226
to some miscalculation.

00:14:29.796 --> 00:14:32.896
I'm sure a lot of you have
seen something similar

00:14:32.896 --> 00:14:34.326
to this before, as well.

00:14:34.836 --> 00:14:37.256
A random crash happening
somewhere in our code.

00:14:37.626 --> 00:14:41.176
Maybe you see this every single
time you test a certain aspect

00:14:41.176 --> 00:14:45.096
of your app or maybe you only
see this on Friday evenings

00:14:45.246 --> 00:14:47.096
when you are really
ready to go home!

00:14:48.016 --> 00:14:49.396
[Laughter]

00:14:49.396 --> 00:14:50.796
The worst case scenario is

00:14:50.796 --> 00:14:53.996
when your users see these
instabilities or random crashes,

00:14:53.996 --> 00:14:55.766
and you can't even
produce them locally.

00:14:56.226 --> 00:15:00.436
Memory corruptions are
known to be notoriously hard

00:15:00.476 --> 00:15:03.356
to consistently reproduce
and finding the root cause

00:15:03.396 --> 00:15:05.896
of the misbehavior is
often a difficult task.

00:15:06.986 --> 00:15:07.876
So what can be done?

00:15:08.636 --> 00:15:11.516
Best way to minimize your
exposure to memory errors,

00:15:11.836 --> 00:15:14.616
is to avoid memory
manipulations altogether.

00:15:15.256 --> 00:15:18.076
For example, using language
occurrences such as Swift

00:15:18.156 --> 00:15:21.566
and automated reference counting
will take you a long way.

00:15:22.726 --> 00:15:24.866
Even though the memory
corruptions are still

00:15:24.866 --> 00:15:27.686
technically possible there,
writing code that causes them,

00:15:27.686 --> 00:15:28.896
will be much less likely.

00:15:30.276 --> 00:15:32.626
On the other hand,
if you have code

00:15:32.626 --> 00:15:35.246
that manipulates memory
directly, by calling malloc,

00:15:35.246 --> 00:15:36.656
or by doing [unintelligible]
arithmetic,

00:15:37.146 --> 00:15:39.916
or you simply have code
that interoperates with C

00:15:39.916 --> 00:15:43.536
and C++ APIs, you
are in the risk group

00:15:43.536 --> 00:15:45.646
that needs the most help.

00:15:47.806 --> 00:15:51.766
Address Sanitizer is an LLVM
tool for C-based languages,

00:15:51.766 --> 00:15:55.026
that serves the same
purpose as Guard Malloc,

00:15:55.086 --> 00:16:00.576
as it finds memory errors at
runtime, however, it has a lot

00:16:00.576 --> 00:16:02.376
of benefits over
the other tools.

00:16:03.066 --> 00:16:05.126
It has much less
runtime overhead

00:16:05.606 --> 00:16:07.566
and it also produces
comprehensive,

00:16:07.566 --> 00:16:10.526
detailed diagnostics that
are integrated directly

00:16:10.526 --> 00:16:11.366
into the Xcode UI.

00:16:11.366 --> 00:16:15.716
What's also very important is
that it is the only such tool

00:16:15.716 --> 00:16:19.046
that works on iOS devices.

00:16:19.046 --> 00:16:20.536
Here's a list of common errors

00:16:20.536 --> 00:16:22.176
that Address Sanitizer
can catch for you.

00:16:23.036 --> 00:16:28.986
For example, it's very good
at catching buffer overflows,

00:16:29.766 --> 00:16:33.536
which is a very common error
to make, that is notorious

00:16:33.536 --> 00:16:35.546
for its relation to
security exploits.

00:16:35.946 --> 00:16:38.926
As you can see it finds some
of the tools that are --

00:16:38.926 --> 00:16:40.986
some of the errors that
are found by Valgrind

00:16:40.986 --> 00:16:44.136
and Guard Malloc, however
it also finds new categories

00:16:44.136 --> 00:16:47.176
of bugs, that the other
tools do not focus on.

00:16:48.396 --> 00:16:49.876
Let's go back to the demo

00:16:49.876 --> 00:16:52.596
and see how you can turn
this on in your project.

00:17:02.896 --> 00:17:06.386
So I will start right at the
place where Mike left off

00:17:06.576 --> 00:17:09.586
and let's see if the Address
Sanitizer will help us diagnose

00:17:09.586 --> 00:17:10.685
this routes issue.

00:17:11.435 --> 00:17:13.346
In order to turn
Address Sanitizer [on],

00:17:13.925 --> 00:17:15.455
you go to Edit Scheme.

00:17:16.066 --> 00:17:20.046
Go to the Diagnostics tab.

00:17:21.126 --> 00:17:22.836
And check Enable
Address Sanitizer.

00:17:23.626 --> 00:17:25.976
Unlike the other
memory management tools,

00:17:25.976 --> 00:17:28.026
Address Sanitizer
requires re-compilation.

00:17:28.366 --> 00:17:32.286
So after this check box is
checked, Xcode will know

00:17:32.286 --> 00:17:35.356
to rebuild your application with
Address Sanitizer turned on,

00:17:35.696 --> 00:17:37.526
and it will launch
it in a special mode

00:17:37.526 --> 00:17:39.276
that will allow Address
Sanitizer to poke

00:17:39.276 --> 00:17:41.516
at your process even
more at runtime.

00:17:42.076 --> 00:17:46.306
Let's go ahead, rebuild
and re-run this app.

00:17:47.996 --> 00:17:52.086
And see what happens when we go
to the route, to see the route.

00:17:52.086 --> 00:17:54.326
Now, what you see here is
Address Sanitizer has spotted an

00:17:54.326 --> 00:17:57.516
issue, and its diagnostics
are integrated directly

00:17:57.516 --> 00:17:58.946
into the Xcode Debugger UI.

00:17:59.976 --> 00:18:03.106
What happens is very similar
to what will occur on a crash,

00:18:03.676 --> 00:18:05.846
however, unlike the
case with a Sec fold,

00:18:05.846 --> 00:18:07.816
you get much better diagnostics.

00:18:08.556 --> 00:18:11.836
Here, it tells us that the
heap buffer overflow has been

00:18:11.836 --> 00:18:15.046
detected, and you also
see the stack trace,

00:18:15.276 --> 00:18:17.896
at which this memory
fault has occurred.

00:18:18.456 --> 00:18:22.756
As you can see, we are calling
it Poly Line With Points

00:18:22.756 --> 00:18:24.136
and common method of Map Kit.

00:18:24.136 --> 00:18:28.316
We are testing at the buffer,
and the number of points,

00:18:28.316 --> 00:18:30.676
which is calculated by taking
the length of the buffer

00:18:30.676 --> 00:18:33.596
and dividing it by the
size of each point.

00:18:34.426 --> 00:18:35.876
That looks okay.

00:18:35.876 --> 00:18:38.816
As your application
is being executed

00:18:38.816 --> 00:18:42.126
under Address Sanitizer, it
collects important information

00:18:42.126 --> 00:18:44.376
about the heap objects
in your process.

00:18:44.816 --> 00:18:47.106
For example, allocation,
heap allocation,

00:18:47.106 --> 00:18:48.216
and deallocation events.

00:18:48.956 --> 00:18:53.266
And when it finds this memory
fault, it uses heuristics

00:18:53.266 --> 00:18:56.786
to relate the faulty address
to a valid object in your heap.

00:18:57.416 --> 00:18:59.116
And that information
is presented here

00:18:59.116 --> 00:19:00.216
under the memory item.

00:19:00.836 --> 00:19:04.766
So here it tells us that the
faulty address is one byte

00:19:05.296 --> 00:19:09.876
after 2,240-byte heap
region, and it also tells us

00:19:09.916 --> 00:19:12.406
where that heap region
has been allocated.

00:19:13.556 --> 00:19:15.506
Even though this is
not a live thread,

00:19:15.916 --> 00:19:18.926
but a historical snapshot
of the process execution

00:19:18.926 --> 00:19:22.776
when that allocation event
occurred, we can look at streams

00:19:23.766 --> 00:19:28.036
as if it was a live thread,
and here it takes us right

00:19:28.216 --> 00:19:30.426
to the point where the
memory has been allocated.

00:19:31.506 --> 00:19:34.356
Okay. So let's see, the size
of the buffer is calculated

00:19:34.356 --> 00:19:37.886
by taking the size of each point
and multiplying it by number

00:19:37.886 --> 00:19:42.746
of points and we
use MK Map Point to,

00:19:43.466 --> 00:19:45.286
as our points representation.

00:19:45.286 --> 00:19:46.636
It's a Struct with two doubles.

00:19:48.066 --> 00:19:49.306
So what is the problem here?

00:19:50.106 --> 00:19:52.226
Let's go back to the Use site.

00:19:53.866 --> 00:19:57.506
Well, the type you pass the
size of here, is different.

00:19:58.146 --> 00:20:01.366
We pass MK Map Point star.

00:20:02.406 --> 00:20:06.216
But we know that we have just
allocated a buffer of Structs,

00:20:06.216 --> 00:20:07.646
not a buffer of pointers.

00:20:08.636 --> 00:20:12.266
And since the size of each
pointer is smaller than the size

00:20:12.266 --> 00:20:14.226
of our struct, that
contained two doubles,

00:20:15.026 --> 00:20:17.976
the count we get here will
be larger than the number

00:20:17.976 --> 00:20:20.016
of elements that
our buffer contains.

00:20:20.706 --> 00:20:22.906
So that would explain
why we get all

00:20:22.946 --> 00:20:26.426
of those extra points
on the map.

00:20:26.626 --> 00:20:29.606
To fix this problem, we just
need to remove the star.

00:20:29.606 --> 00:20:31.896
And as you see, this is
like a very common mistake

00:20:31.896 --> 00:20:35.756
that people could make and it
would be very hard to find this

00:20:35.816 --> 00:20:37.756
by just looking at this code.

00:20:37.756 --> 00:20:42.906
Now, in this case, this
information alone is sufficient

00:20:42.906 --> 00:20:44.576
to diagnose and fix the problem.

00:20:45.116 --> 00:20:49.116
However, you can -- if you
feel like you want to poke

00:20:49.116 --> 00:20:52.936
at this report even more,
you can go to the Memory View

00:20:52.936 --> 00:20:54.816
and see which memory is
considered to be valid,

00:20:55.116 --> 00:20:57.116
and which memory is
considered to be invalid,

00:20:57.196 --> 00:20:58.936
from Address Sanitizer's
perspective.

00:20:59.646 --> 00:21:03.096
To go to the Memory View, you
can click on the address here,

00:21:03.876 --> 00:21:07.366
and here you can see all the
greyed-out stuff is invalid

00:21:07.366 --> 00:21:14.176
memory, and all the black memory
is considered to be valid.

00:21:14.446 --> 00:21:17.486
Now let's go back
and re-run our app,

00:21:17.486 --> 00:21:20.576
and see if removing the
asterisk did, fix that problem.

00:21:21.456 --> 00:21:28.126
Now, I'm going to go back
to the Routes view, and aha,

00:21:28.326 --> 00:21:31.576
here is the path that
Mike ran this morning,

00:21:31.846 --> 00:21:33.436
and the morning after
the Bash, too.

00:21:34.006 --> 00:21:34.776
I'm impressed.

00:21:35.426 --> 00:21:36.916
So let's go back and
switch to the slides.

00:21:37.836 --> 00:21:40.756
So as you had seen, turning on
Address Sanitizer is very easy.

00:21:40.756 --> 00:21:44.286
You go to Scheme Editor,
open the Diagnostics tab,

00:21:44.816 --> 00:21:47.176
and check the Enable
Address Sanitizer checkbox,

00:21:47.946 --> 00:21:50.016
then you just build
and run your project.

00:21:52.216 --> 00:21:55.406
And also as you have seen in
the demo app, the overhead

00:21:55.406 --> 00:21:58.106
of using Address Sanitizer
was not even noticeable.

00:21:58.626 --> 00:22:01.776
This low runtime overhead allows
you to use Address Sanitizer,

00:22:02.126 --> 00:22:06.136
not only when you are debugging
some memory corruption problem,

00:22:06.366 --> 00:22:09.516
but also while performing
UI-driven testing,

00:22:09.516 --> 00:22:13.026
where you manually test
different aspects of your app.

00:22:13.506 --> 00:22:15.726
Taking it one step
further we recommend

00:22:15.726 --> 00:22:18.576
that you use Address Sanitizer
in your continuous integration.

00:22:19.276 --> 00:22:23.236
Since it's a runtime bug-finding
tool, it will only catch bugs

00:22:23.236 --> 00:22:25.046
in the code that
has been executed.

00:22:25.696 --> 00:22:27.826
So you should provide
it as much coverage

00:22:27.826 --> 00:22:29.346
as possible for best results.

00:22:30.656 --> 00:22:34.906
To enable Address Sanitizer
in your tasks in Xcode

00:22:34.906 --> 00:22:40.706
or in Xcode Server go to
Edit Scheme, select Task,

00:22:40.706 --> 00:22:42.906
and then again go to
the Diagnostics tab,

00:22:42.906 --> 00:22:45.096
and check the Enable
Address Sanitizer checkbox,

00:22:45.166 --> 00:22:46.986
build and test your app.

00:22:47.496 --> 00:22:49.156
You can also enable
it on command line,

00:22:49.156 --> 00:22:51.936
by passing an extra
argument to Xcode Build.

00:22:52.576 --> 00:22:56.546
We recommend that you
use Address Sanitizer

00:22:56.546 --> 00:22:58.956
in Debug builds, where the
compiler optimizations are

00:22:58.956 --> 00:22:59.616
turned off.

00:23:00.426 --> 00:23:03.926
However, it is also supported
with the Fast optimization level

00:23:05.066 --> 00:23:07.536
that corresponds to
01 compiler flag.

00:23:08.436 --> 00:23:11.036
One thing to keep in mind is
that when you are deciding

00:23:11.036 --> 00:23:13.266
between those two
optimization levels,

00:23:14.346 --> 00:23:17.046
is that your debugging
experience will not be as smooth

00:23:17.166 --> 00:23:20.476
in case you have any compiling
optimizations turned on.

00:23:23.026 --> 00:23:26.616
So now we will go to the most
exciting part of this talk.

00:23:26.816 --> 00:23:29.126
I will tell you the
cool technology

00:23:29.126 --> 00:23:30.426
that powers this tool.

00:23:30.976 --> 00:23:36.106
So traditionally, Xcode compiles
your source code using the clang

00:23:36.106 --> 00:23:39.816
compiler, which produces
an executable binary.

00:23:41.376 --> 00:23:42.896
In order to use Address
Sanitizer,

00:23:42.896 --> 00:23:45.366
Xcode passes a special
flag to clang.

00:23:45.596 --> 00:23:47.356
It produces an instrumented
binary

00:23:47.356 --> 00:23:48.766
that contains more
memory checks.

00:23:50.136 --> 00:23:55.566
And at runtime, this binary
links with asan runtime dylib,

00:23:55.636 --> 00:23:59.096
that contains even more checks,
and that dylib is required

00:23:59.096 --> 00:24:00.186
by the instrumentation.

00:24:00.726 --> 00:24:03.726
But how does these
memory checks work?

00:24:04.266 --> 00:24:07.386
Address Sanitizer checks all
allocations in your process.

00:24:07.386 --> 00:24:09.416
If this is your process memory,

00:24:09.836 --> 00:24:14.156
Address Sanitizer maintains
so-called shadow memory,

00:24:14.526 --> 00:24:17.766
that tracks each byte
in your real memory,

00:24:17.876 --> 00:24:20.056
and it has information
of whether

00:24:20.196 --> 00:24:22.696
that byte is address-accessible
or not.

00:24:24.136 --> 00:24:27.306
Bytes on invalid memory are
called red zones or as we say,

00:24:27.306 --> 00:24:28.686
memory there is poisoned.

00:24:28.686 --> 00:24:33.126
When you compile your program
with Address Sanitizer,

00:24:33.126 --> 00:24:35.066
it instruments every
memory access

00:24:35.406 --> 00:24:36.746
and prefixes it with a check.

00:24:37.826 --> 00:24:38.986
If the memory is poisoned,

00:24:39.026 --> 00:24:41.226
the Address Sanitizer
will track the program

00:24:41.566 --> 00:24:43.756
and generate a diagnostics
report.

00:24:44.166 --> 00:24:46.056
Otherwise, it will
allow you to continue.

00:24:46.586 --> 00:24:49.126
Let's take a closer look.

00:24:49.246 --> 00:24:50.536
Assume p is a pointer,

00:24:50.956 --> 00:24:54.466
then IsPoisoned function
checks the relevant byte

00:24:54.466 --> 00:24:55.376
in the shadow memory.

00:24:56.136 --> 00:24:59.466
In this case, the memory is
valid, so the program is allowed

00:24:59.466 --> 00:25:01.426
to write to that
memory location.

00:25:01.866 --> 00:25:06.936
However, if it does not
point to valid memory,

00:25:07.196 --> 00:25:08.646
the condition will be true,

00:25:09.096 --> 00:25:11.606
and the program will
trap right there,

00:25:11.876 --> 00:25:14.396
where the invalid memory
access was about to happen.

00:25:15.216 --> 00:25:18.106
This is how Address
Sanitizer produces reports,

00:25:18.106 --> 00:25:21.896
and reports this
problem to the user.

00:25:21.966 --> 00:25:24.736
Now, the lookups into the shadow
memory need to be very fast.

00:25:26.266 --> 00:25:30.226
To achieve this, we maintain a
lookup table where every 8 bytes

00:25:30.226 --> 00:25:33.636
of your memory are tracked
by one byte in the shadow.

00:25:35.026 --> 00:25:37.056
This is a very large
lookup table.

00:25:37.056 --> 00:25:40.276
So we don't actually allocate
it, instead, we reserve it

00:25:40.326 --> 00:25:42.906
when the process launches,
and use it as needed.

00:25:44.366 --> 00:25:46.166
With that, we can
look up the address

00:25:46.166 --> 00:25:49.286
by simply taking the value
of the original pointer,

00:25:49.496 --> 00:25:52.636
dividing it by 8, and
adding a constant offset,

00:25:52.676 --> 00:25:55.816
which is the location of
the shadow in the memory.

00:25:55.816 --> 00:25:58.856
Even if the byte of the
computed address is nonzero,

00:25:59.136 --> 00:26:00.516
we know that the
memory is poisoned.

00:26:00.516 --> 00:26:05.176
Now, let's talk a little
bit about the heap.

00:26:06.116 --> 00:26:08.816
To catch overflows and
other bugs in heap,

00:26:09.366 --> 00:26:12.266
Address Sanitizer provides
its custom allocator

00:26:12.266 --> 00:26:15.216
that replaces the default
Malloc implementation.

00:26:16.106 --> 00:26:18.866
The default allocator
can organize objects

00:26:18.866 --> 00:26:19.656
in various ways.

00:26:20.346 --> 00:26:23.846
For example, it can lay out
objects one after the other,

00:26:24.706 --> 00:26:27.926
which is great for optimizing
a memory consumption.

00:26:28.656 --> 00:26:30.766
However, this is not so
good for catching bugs

00:26:30.766 --> 00:26:33.336
because an overflow on
one object will land

00:26:33.336 --> 00:26:35.276
on another object,
and therefore,

00:26:35.276 --> 00:26:38.036
it will be indistinguishable
from a valid memory access.

00:26:38.536 --> 00:26:42.786
So to fix this problem,
ASan's allocator lays

00:26:42.786 --> 00:26:45.006
out objects further
apart from each other,

00:26:46.016 --> 00:26:49.656
and all the unused memory in
between those objects is marked

00:26:49.656 --> 00:26:51.006
as poisoned in the shadow.

00:26:51.566 --> 00:26:55.886
When an object is
deallocated, we mark the object

00:26:55.886 --> 00:26:57.066
as poisoned in the shadow.

00:26:57.706 --> 00:27:03.866
To summarize, the custom Malloc
implementation inserts poisoned

00:27:03.866 --> 00:27:06.546
red zones around the
valid allocations,

00:27:06.856 --> 00:27:09.126
to catch heap underflows
and overflows.

00:27:10.456 --> 00:27:12.616
It delays the user-freed memory

00:27:12.806 --> 00:27:16.966
to make Address Sanitizer more
effective at catching user-free

00:27:16.966 --> 00:27:18.086
and double-free errors.

00:27:19.306 --> 00:27:22.316
And it also collects Sect
traces for allocations

00:27:22.316 --> 00:27:25.686
and deallocations, that allow it
to provide those comprehensive,

00:27:25.686 --> 00:27:28.376
detailed diagnostics that
we have seen in our demo,

00:27:28.606 --> 00:27:29.946
and that could be the difference

00:27:29.946 --> 00:27:32.176
between understanding
the problem immediately,

00:27:32.436 --> 00:27:35.866
or spending a lot of time
debugging it and, you know,

00:27:35.866 --> 00:27:38.596
figuring out what happens.

00:27:38.756 --> 00:27:43.426
Now, let's talk about the stack.

00:27:43.616 --> 00:27:45.906
So similarly, to heap
memory, red zones are put

00:27:45.906 --> 00:27:47.816
in between individual
stack variables.

00:27:48.416 --> 00:27:50.846
So, suppose we have an
array, and an integer

00:27:50.846 --> 00:27:53.876
as our local variables,
then when compiling

00:27:53.876 --> 00:27:55.236
under Address Sanitizer,

00:27:56.016 --> 00:27:57.856
additional red zones
are inserted

00:27:57.856 --> 00:27:59.406
in between those variables,

00:27:59.406 --> 00:28:03.486
so we can detect any
overflows on stack variables.

00:28:04.326 --> 00:28:08.876
Stack red zones are poisoned
when you enter the function

00:28:08.876 --> 00:28:11.086
at runtime, and they
are unpoisoned

00:28:11.086 --> 00:28:16.696
when you are exiting
the function at runtime.

00:28:16.696 --> 00:28:20.396
Dealing with global variables
is very similar, again,

00:28:20.396 --> 00:28:24.156
during compilation, the global
variables are instrumented,

00:28:24.656 --> 00:28:27.136
and additional red zones
are inserted around them.

00:28:27.136 --> 00:28:32.256
Now, both stack and global
compiler instrumentation is a

00:28:32.256 --> 00:28:34.846
really useful feature
of Address Sanitizer.

00:28:35.256 --> 00:28:37.856
This is what allows
it to find those bugs

00:28:37.856 --> 00:28:39.466
that other tools cannot catch.

00:28:39.976 --> 00:28:43.526
Here is yet another
type of a unique bug

00:28:43.526 --> 00:28:46.656
that Address Sanitizer finds,
that is of special interest

00:28:46.656 --> 00:28:49.406
to those of you who are
Avid C++ developers.

00:28:50.856 --> 00:28:53.066
Here we have a C++
container vector,

00:28:53.666 --> 00:28:56.026
and even though all
memory to v.begin,

00:28:56.026 --> 00:28:58.476
to v.begin plus capacity
has been allocated,

00:28:59.186 --> 00:29:02.286
accessing memory past
v.end is an error.

00:29:03.426 --> 00:29:07.006
Leap C++ has been instrumented
to provide more information

00:29:07.006 --> 00:29:10.006
to Address Sanitizer so
that it can find errors

00:29:10.376 --> 00:29:11.246
such as this one.

00:29:15.756 --> 00:29:19.706
As we had seen, all the
checks that we have talked

00:29:19.706 --> 00:29:21.976
about required compiler
instrumentation.

00:29:21.976 --> 00:29:26.176
However, we know that some
errors could occur even --

00:29:26.176 --> 00:29:29.476
could be triggered even in the
code has not been recompiled,

00:29:29.636 --> 00:29:31.726
for example when we are
calling memcpy function.

00:29:32.106 --> 00:29:36.496
Address Sanitizer uses a
technique called BYOD function

00:29:36.496 --> 00:29:40.646
interposition to replace dozens
of standard library functions

00:29:41.076 --> 00:29:43.326
with its own versions
at runtime.

00:29:44.206 --> 00:29:45.936
Since this is a running
technique,

00:29:45.936 --> 00:29:48.546
those checks will
trigger even on code

00:29:48.546 --> 00:29:49.826
that has not been recompiled.

00:29:51.006 --> 00:29:54.056
Here's an example
of a memcpy wrapper.

00:29:54.226 --> 00:29:57.126
As you expect, it first
checks if the source

00:29:57.126 --> 00:30:00.756
and the destination buffers
are valid, before forwarding

00:30:00.946 --> 00:30:03.256
on towards the original
memcpy implementation.

00:30:03.756 --> 00:30:08.426
All of this additional
checks mean

00:30:08.426 --> 00:30:10.136
that there will be
a runtime overhead

00:30:10.136 --> 00:30:11.616
and you might be
wondering what it is.

00:30:12.126 --> 00:30:16.796
The specifics heavily depend
on your individual program.

00:30:16.796 --> 00:30:19.236
Address Sanitizer typically
causes CPUs slowdown

00:30:19.236 --> 00:30:23.386
of about 2x, however we have
seen it go as high as 5x

00:30:23.386 --> 00:30:27.766
in some edge cases, and the
memory overhead is from 2 to 3x.

00:30:28.356 --> 00:30:30.856
One thing that I
want to note here is

00:30:30.856 --> 00:30:34.236
that this overhead is much
smaller than what you would get

00:30:34.266 --> 00:30:36.716
from other tools that
find similar issues.

00:30:37.966 --> 00:30:40.456
And compiling the
compiler instrumentation

00:30:40.766 --> 00:30:43.396
with the runtime
techniques is the key

00:30:43.476 --> 00:30:46.866
that makes Address Sanitizer
so effective and scalable.

00:30:47.786 --> 00:30:52.086
For example, we run and test
Safari under Address Sanitizer.

00:30:52.086 --> 00:30:53.906
And that's a large app.

00:30:54.416 --> 00:31:00.196
And this was Address
Sanitizer, new in Xcode 7.

00:31:01.856 --> 00:31:02.726
Thank you.

00:31:03.516 --> 00:31:09.116
[Applause]

00:31:09.616 --> 00:31:12.336
Let's switch the focus a little
bit, and take a closer look

00:31:12.336 --> 00:31:15.256
at other memory management tools
that are also available to you

00:31:15.256 --> 00:31:18.916
on our platform, what they do
and when you should use them.

00:31:19.666 --> 00:31:22.966
So let's start off with
Guard Malloc which finds some

00:31:22.966 --> 00:31:24.876
of the same issues
as Address Sanitizer.

00:31:25.256 --> 00:31:27.426
And the main advantage
of using Guard Malloc is

00:31:27.426 --> 00:31:29.536
that it doesn't require
recompilation.

00:31:30.076 --> 00:31:32.866
On the other hand, it has
other limitations as well.

00:31:33.566 --> 00:31:35.716
Guard Malloc does not
work on iOS devices,

00:31:36.046 --> 00:31:38.246
and it also doesn't
find all of the issues

00:31:38.246 --> 00:31:39.566
that Address Sanitizer finds.

00:31:40.316 --> 00:31:45.246
For example, since it uses guard
pages, it will not catch all

00:31:45.246 --> 00:31:46.926
of by-one buffer overflows,

00:31:47.246 --> 00:31:49.136
which is a common
mistake to make.

00:31:49.976 --> 00:31:52.456
These are the tradeoffs
to consider when choosing

00:31:52.456 --> 00:31:53.946
which of the two tools to use.

00:31:54.606 --> 00:31:59.126
And also at your disposal
is NSZombie, which is good

00:31:59.126 --> 00:32:01.616
for catching Objective-C
object over-releases.

00:32:02.556 --> 00:32:05.516
It works by replacing
deallocated objects

00:32:05.876 --> 00:32:09.336
with zombie objects
that trap when messaged.

00:32:10.326 --> 00:32:12.346
The basic functionality
can be enabled

00:32:12.676 --> 00:32:15.456
from the same Diagnostics
tab in Xcode.

00:32:15.816 --> 00:32:17.866
However, if you want
to gain full power

00:32:17.866 --> 00:32:20.566
of this feature do use
Zombies Instrument.

00:32:22.076 --> 00:32:23.936
Malloc Scribble will help

00:32:23.936 --> 00:32:27.016
in investigating
uninitialized memory issues.

00:32:27.496 --> 00:32:29.716
It makes those errors
much more predictable,

00:32:29.956 --> 00:32:32.766
by filling the allocated
and deallocated memory

00:32:32.766 --> 00:32:33.996
with preset constants.

00:32:34.476 --> 00:32:38.206
And finally, the leaks
Instrument will help you find

00:32:38.206 --> 00:32:41.586
retained cycles, and
abandoned memory that leads

00:32:41.616 --> 00:32:43.016
to higher memory consumption.

00:32:43.606 --> 00:32:48.316
So to summarize, we have seen
three different techniques

00:32:48.316 --> 00:32:51.806
that will help you get a deeper
understanding of your program.

00:32:52.336 --> 00:32:54.876
First, use the View
Debugger to find

00:32:54.876 --> 00:32:57.086
and fix constrained
problems in your layout.

00:32:58.266 --> 00:33:00.166
Second, set up breakpoint
actions

00:33:00.196 --> 00:33:03.926
to automatically evaluate and
print any LLVD expressions,

00:33:04.316 --> 00:33:05.876
and use the exception breakpoint

00:33:05.876 --> 00:33:08.896
to stop debugging your
program right at the place

00:33:08.896 --> 00:33:12.366
where an exception
occurs, and finally, third,

00:33:12.796 --> 00:33:15.876
use Address Sanitizer to
scrub your applications clean

00:33:16.256 --> 00:33:18.776
of those elusive
memory corruption bugs.

00:33:20.196 --> 00:33:23.176
Here are some resources that
you can use to learn more

00:33:23.176 --> 00:33:26.526
about what we have talked
about today, and the sessions

00:33:26.526 --> 00:33:30.596
from earlier this week covered
LLDB continuous integration

00:33:30.596 --> 00:33:31.326
and testing.

00:33:31.686 --> 00:33:34.206
You can watch them even
once the conference is over.

00:33:34.706 --> 00:33:36.756
Thank you very much, and
enjoy the rest of your day.

00:33:37.516 --> 00:33:40.500
[Applause]
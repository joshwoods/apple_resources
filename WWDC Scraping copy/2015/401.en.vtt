WEBVTT

00:00:25.406 --> 00:00:26.386
>> JORDAN ROSE: Good
afternoon, everyone.

00:00:26.986 --> 00:00:27.956
My name is Jordan Rose.

00:00:28.516 --> 00:00:33.306
[Applause]

00:00:33.806 --> 00:00:34.006
>> JORDAN ROSE: Wow.

00:00:34.006 --> 00:00:34.266
Thank you.

00:00:34.266 --> 00:00:35.316
I haven't even done
anything yet.

00:00:36.346 --> 00:00:37.246
My name is Jordan Rose.

00:00:37.246 --> 00:00:39.446
Joining me later will be
my colleague, Doug Gregor.

00:00:39.536 --> 00:00:41.926
We are here to talk to you about
the language changes we made

00:00:41.926 --> 00:00:44.606
in both Swift and
Objective-C over the last year,

00:00:45.006 --> 00:00:47.516
especially in the areas
of interoperability.

00:00:48.166 --> 00:00:51.746
And this is important because
all Objective-C APIs are

00:00:51.746 --> 00:00:52.936
available in Swift.

00:00:53.726 --> 00:00:56.116
And in Xcode 7 we
made it even easier

00:00:56.116 --> 00:00:57.606
to see how this mapping works.

00:00:57.716 --> 00:00:59.676
Go to any Objective-C header

00:01:00.076 --> 00:01:02.506
and choose the 'show
related items' button

00:01:02.686 --> 00:01:03.766
in the top-left corner.

00:01:04.256 --> 00:01:06.296
This will bring down a
menu of related items,

00:01:06.356 --> 00:01:09.066
one of which is 'generated
interface.'

00:01:09.846 --> 00:01:12.796
And this will show you the
Swift mapping for that header.

00:01:13.966 --> 00:01:15.956
This is the exact
same view that you got

00:01:16.056 --> 00:01:19.446
in Xcode 6 using the 'jump
to definition' feature,

00:01:19.766 --> 00:01:22.726
but now you can get it easily
from any header in your target.

00:01:22.726 --> 00:01:26.266
So we are going to be
talking about a variety

00:01:26.266 --> 00:01:29.126
of improvements today that we
have made to Swift for working

00:01:29.126 --> 00:01:31.086
with Objective-C, and
that we have been making

00:01:31.086 --> 00:01:32.346
to Objective-C itself.

00:01:32.446 --> 00:01:35.496
We will start off with some
of the basic features working

00:01:35.496 --> 00:01:38.296
between Swift and
Objective-C, and at the details

00:01:38.296 --> 00:01:40.716
of the new error-handling
feature and how that works

00:01:40.716 --> 00:01:41.976
across the language boundaries.

00:01:42.386 --> 00:01:43.406
After that, we are going to talk

00:01:43.406 --> 00:01:44.946
about the three major
improvements we've made

00:01:44.946 --> 00:01:47.936
to Objective-C in the last
year, nullability annotations,

00:01:48.046 --> 00:01:50.556
lightweight generics,
and kindof types.

00:01:52.206 --> 00:01:53.866
Let's start on the
Swift side of things.

00:01:54.536 --> 00:01:56.346
We just saw how easy it is

00:01:56.346 --> 00:01:58.876
to get the Objective-C
APIs into Swift.

00:01:58.956 --> 00:02:01.626
But a lot of people come
up with the question,

00:02:01.976 --> 00:02:05.126
when is my Swift
exposed to Objective-C?

00:02:06.456 --> 00:02:08.276
And so, let's go over
the rules for this.

00:02:09.925 --> 00:02:12.506
If you have a class that's
a subclass of NSObject,

00:02:12.976 --> 00:02:14.406
then by default, its methods

00:02:14.406 --> 00:02:16.686
and properties are
exposed to Objective-C.

00:02:17.266 --> 00:02:20.046
In this case, we have a class
MyController that's a subclass

00:02:20.046 --> 00:02:21.256
of UIViewController.

00:02:21.616 --> 00:02:23.826
That's indirectly a
subclass of NSObject,

00:02:24.196 --> 00:02:28.126
so this refresh method will
be exposed to Objective-C.

00:02:29.356 --> 00:02:32.446
However, if you mark
that method as private,

00:02:33.106 --> 00:02:35.696
that means it's only supposed to
be visible to the current file.

00:02:36.246 --> 00:02:39.286
So in this case, Swift
will not expose the method

00:02:39.286 --> 00:02:41.036
to Objective-C by default.

00:02:42.076 --> 00:02:44.416
Additionally, if you
are only using --

00:02:44.546 --> 00:02:46.746
if you are using some kind
of Swift-only feature,

00:02:47.056 --> 00:02:49.776
like this unusual return
type here, then, again,

00:02:50.206 --> 00:02:52.696
there's no way to expose
this method to Objective-C

00:02:52.806 --> 00:02:55.756
and Swift won't even try.

00:02:55.956 --> 00:03:00.116
Finally, if you are not
a subclass of NSObject

00:03:00.546 --> 00:03:03.416
but simply conforming to
an Objective-C protocol,

00:03:03.966 --> 00:03:05.736
then you have to take
extra care to make sure

00:03:05.736 --> 00:03:08.146
that your methods actually
satisfy the requirements

00:03:08.146 --> 00:03:08.846
of the protocol.

00:03:09.266 --> 00:03:11.506
And in Xcode 7, you will
get a warning for this.

00:03:12.116 --> 00:03:16.036
In this case, 'web view did
start load' is non-objc,

00:03:16.296 --> 00:03:18.456
and so it cannot
satisfy the requirements

00:03:18.686 --> 00:03:20.826
of the 'UI web view
delegate protocol.'

00:03:21.446 --> 00:03:24.086
So that covers the defaults.

00:03:24.756 --> 00:03:26.196
What happens when you
want to change those

00:03:26.536 --> 00:03:27.656
from that default behavior?

00:03:28.756 --> 00:03:31.276
So let's go back to that
version of MyController here

00:03:31.276 --> 00:03:33.636
with the refresh method,
and I want to expose it

00:03:33.636 --> 00:03:36.306
to Objective-C, but
it really depends --

00:03:36.446 --> 00:03:39.476
what I want to do next really
depends on what I need to do

00:03:39.476 --> 00:03:40.616
with this refresh method.

00:03:41.286 --> 00:03:45.166
So, if I'm going to make this,
say, something that I want

00:03:45.166 --> 00:03:48.046
to use an interface builder
or maybe it's a property

00:03:48.046 --> 00:03:49.046
that I want to use
from Core data,

00:03:49.546 --> 00:03:51.336
we have dedicated
attributes for these,

00:03:51.406 --> 00:03:53.746
and adding that attribute
is all you need to do.

00:03:54.236 --> 00:03:56.976
So, if you use the IBAction
attribute as shown here,

00:03:58.466 --> 00:03:59.426
that's all you need to do

00:03:59.426 --> 00:04:01.676
to make this refresh
method a valid action

00:04:01.676 --> 00:04:02.626
in interface builder.

00:04:04.196 --> 00:04:06.546
Similarly, if you are
looking to use a property

00:04:06.746 --> 00:04:09.006
with foundations key
value observing system,

00:04:09.196 --> 00:04:11.366
or Cocoa bindings, all you need

00:04:11.366 --> 00:04:13.736
to do is add the
dynamic modifier.

00:04:14.196 --> 00:04:15.906
This tells Swift that
the implementation

00:04:15.906 --> 00:04:18.666
of this property might
be replaced at run time

00:04:18.896 --> 00:04:20.636
by the key value
observing system.

00:04:22.036 --> 00:04:24.996
But if you really just want
to expose a particular method

00:04:24.996 --> 00:04:26.656
or property to Objective-C,

00:04:27.006 --> 00:04:31.516
you can always just use the
plain-old at-objc modifier,

00:04:31.516 --> 00:04:36.436
or objc attribute -- sorry --
and this will expose a method

00:04:36.436 --> 00:04:37.956
or objective to Objective-C

00:04:38.176 --> 00:04:39.776
without any additional
semantics.

00:04:40.066 --> 00:04:44.156
The objc attribute is also
useful for one other thing,

00:04:44.426 --> 00:04:46.996
which is to figure out why
something is not visible

00:04:46.996 --> 00:04:48.896
in Objective-C when you
thought it would be.

00:04:49.406 --> 00:04:52.176
So if I tried to apply this to
that other version of Refresh

00:04:52.176 --> 00:04:54.046
that has the unusual
result type here,

00:04:54.046 --> 00:04:57.376
then I will get an error message
saying this 'method cannot be

00:04:57.376 --> 00:05:00.216
marked at-objc because
its result type cannot be

00:05:00.216 --> 00:05:03.006
represented in Objective-C.'

00:05:03.246 --> 00:05:06.766
All of these rules are covered
in the 'Using Swift with Cocoa

00:05:06.766 --> 00:05:09.566
and Objective-C' guide,
which is available online

00:05:09.656 --> 00:05:12.546
at developer.apple.com/Swift.

00:05:13.736 --> 00:05:16.536
So now we've covered the
defaults, and we've covered what

00:05:16.536 --> 00:05:19.006
to do when you want to
override those defaults

00:05:19.456 --> 00:05:21.306
to make things more ObjC.

00:05:21.306 --> 00:05:23.526
But what if you have
the opposite problem?

00:05:25.006 --> 00:05:27.526
Let's look at this class
here: calculator controller.

00:05:28.086 --> 00:05:30.606
It has two methods named
'perform operation.'

00:05:31.216 --> 00:05:32.876
One of them takes
one kind of closure

00:05:33.026 --> 00:05:34.666
and the other takes a
different kind of closure.

00:05:35.626 --> 00:05:36.316
That's fine.

00:05:36.566 --> 00:05:39.256
Swift is able to differentiate
these methods purely based

00:05:39.256 --> 00:05:40.286
on their argument types.

00:05:41.086 --> 00:05:42.706
But Objective-C doesn't
work like this.

00:05:42.926 --> 00:05:45.426
In Objective-C, methods
are only differentiated

00:05:45.426 --> 00:05:47.246
by name, not by type.

00:05:48.636 --> 00:05:51.306
And so in this case, Swift
knows this might be an issue

00:05:51.306 --> 00:05:52.806
and it will give you
an error message.

00:05:54.006 --> 00:05:55.046
Now, you have always been able

00:05:55.046 --> 00:05:58.966
to fix this using the selector
form of the ObjC attribute.

00:05:59.476 --> 00:06:02.936
So if I write this code, then
I've renamed the bottom method

00:06:03.006 --> 00:06:05.456
to 'perform binary operation,

00:06:05.866 --> 00:06:07.986
when I'm accessing
it from Objective-C.

00:06:08.646 --> 00:06:11.536
The top method is still
named 'perform operation.'

00:06:12.236 --> 00:06:16.636
In Xcode 7, we've added another
option for solving this problem,

00:06:16.876 --> 00:06:18.636
which is the non-ObjC attribute.

00:06:19.176 --> 00:06:20.346
As you might have expected,

00:06:20.606 --> 00:06:23.606
this will take something that's
normally exposed to Objective-C

00:06:23.826 --> 00:06:26.606
and prevent it from
being exposed as such.

00:06:27.036 --> 00:06:29.806
You can apply the non-ObjC
attribute to any method,

00:06:30.086 --> 00:06:32.496
property, subscript,
or initializer.

00:06:33.126 --> 00:06:37.366
So that's a fair amount about
Objective-C and methods,

00:06:37.706 --> 00:06:39.506
but how about something
lower level.

00:06:40.656 --> 00:06:41.666
Let's talk about C.

00:06:42.286 --> 00:06:45.486
So there are a few people in
this room that are really happy

00:06:45.486 --> 00:06:47.176
that we have a slide
called function pointers.

00:06:49.636 --> 00:06:52.736
[Laughter] A function pointer
is what C uses for callbacks.

00:06:53.416 --> 00:06:55.876
That means they are
kind of like closures,

00:06:56.406 --> 00:06:58.676
but they can't carry any
additional state with them.

00:06:59.336 --> 00:07:00.466
What do I mean by that?

00:07:01.466 --> 00:07:03.086
Let's say I'm in
Swift and I'm trying

00:07:03.086 --> 00:07:05.516
to call this C function,
funopen.

00:07:05.766 --> 00:07:07.416
It takes a lot of arguments.

00:07:07.416 --> 00:07:08.686
You don't have to know
what they all are.

00:07:09.116 --> 00:07:10.136
One of them is a callback.

00:07:11.176 --> 00:07:14.376
In this callback, I'm trying
to use self to do something.

00:07:14.986 --> 00:07:18.296
Now, self is not an
argument to this closure.

00:07:18.886 --> 00:07:20.686
So it has to be stored
away somewhere

00:07:20.686 --> 00:07:22.176
for the closure to access later.

00:07:23.106 --> 00:07:25.486
That's what we mean by a
closure carrying state.

00:07:25.956 --> 00:07:29.136
So when you try to use this
closure, with this API,

00:07:29.546 --> 00:07:32.156
you get an error message.

00:07:32.306 --> 00:07:36.476
Now, in Swift 1.2, C function
pointers weren't very useful.

00:07:36.946 --> 00:07:39.366
You had this C type that
is shown on the top,

00:07:39.566 --> 00:07:43.306
and it came into Swift as this
opaque, C function pointer type.

00:07:43.626 --> 00:07:47.526
You could pass it around but you
couldn't do much else with it.

00:07:47.716 --> 00:07:50.976
In Swift 2.0, we've just
made these a special kind

00:07:50.976 --> 00:07:53.606
of closure marked with the
convention-C attribute.

00:07:54.006 --> 00:07:55.456
You can create these in Swift,

00:07:55.666 --> 00:07:57.676
pass them around,
and even call them.

00:07:58.116 --> 00:08:00.226
Which means there's a
whole family of C APIs

00:08:00.506 --> 00:08:02.386
that you can now
access directly in Swift

00:08:02.496 --> 00:08:03.526
that you couldn't before.

00:08:05.516 --> 00:08:10.666
[Applause]

00:08:11.166 --> 00:08:11.986
>> JORDAN ROSE: So
those are just two

00:08:11.986 --> 00:08:14.516
of the little things we have
done to enhance the bridge

00:08:14.516 --> 00:08:17.466
from Swift and to
C and Objective-C.

00:08:18.476 --> 00:08:20.726
But there's also some
big-name features this year

00:08:20.726 --> 00:08:22.226
that have had some
really big impacts

00:08:22.226 --> 00:08:23.386
on this language bridging.

00:08:24.576 --> 00:08:26.666
The most important, of
course, being error handling.

00:08:28.176 --> 00:08:29.466
Now, if you haven't really heard

00:08:29.466 --> 00:08:33.275
about the error handling model
yet, essentially we took a lot

00:08:33.275 --> 00:08:37.496
of lessons from Cocoa's
NSError paradigm and the rules

00:08:37.496 --> 00:08:39.155
and the conventions
that surrounded that,

00:08:39.696 --> 00:08:41.416
and used what we
learned from that

00:08:41.686 --> 00:08:43.096
to make a new language feature,

00:08:43.186 --> 00:08:45.256
represented by the
'throws' keyword.

00:08:46.106 --> 00:08:48.486
This was covered in a lot of
depth in this morning's talk

00:08:48.486 --> 00:08:49.486
"What's New In Swift."

00:08:50.126 --> 00:08:53.276
Which was -- which you -- if
you didn't make it to that,

00:08:53.276 --> 00:08:55.586
I strongly suggest you
check it out later on,

00:08:55.586 --> 00:08:58.606
to find out really how all this
error handling stuff works.

00:08:59.126 --> 00:09:04.266
But what I want to focus on now
is specifics about this going

00:09:04.266 --> 00:09:05.766
between the two languages.

00:09:06.526 --> 00:09:08.136
And one thing I want
you to understand is

00:09:08.136 --> 00:09:11.176
that this isn't just a mapping
from Objective-C into Swift.

00:09:11.576 --> 00:09:15.766
It's also how Swift APIs get
exposed back to Objective-C.

00:09:16.426 --> 00:09:18.296
So this mapping is
bidirectional.

00:09:18.866 --> 00:09:22.316
Let's take a closer look
at the return types here.

00:09:23.076 --> 00:09:26.236
In Objective-C, the
error conventions say

00:09:26.476 --> 00:09:30.536
that returning a nil value
represents a failure case.

00:09:31.326 --> 00:09:33.876
That's when this 'out
error' parameter is going

00:09:33.876 --> 00:09:34.836
to be populated.

00:09:36.056 --> 00:09:38.496
In Swift, however,
that's entirely covered

00:09:38.496 --> 00:09:41.656
by the error handling model, and
so the return type you will see

00:09:41.656 --> 00:09:45.666
in Swift is a non-optional
object type.

00:09:46.726 --> 00:09:48.486
Similarly in Objective-C,

00:09:48.486 --> 00:09:50.586
you can also have a
Boolean return value

00:09:51.046 --> 00:09:53.036
where the no case
is the failure case.

00:09:53.536 --> 00:09:56.726
Again, that's entirely
covered by the Swift model

00:09:57.006 --> 00:09:59.296
and so the return type
you will get will be void.

00:09:59.946 --> 00:10:04.026
Now, on both of these examples,
I have shown that these methods

00:10:04.026 --> 00:10:06.096
in Objective-C have
multiple parameters,

00:10:06.096 --> 00:10:07.956
only one of which is
the error parameter,

00:10:08.516 --> 00:10:11.046
but there are also cases where
methods only have one parameter

00:10:11.256 --> 00:10:12.126
and you will get something

00:10:12.126 --> 00:10:15.406
like 'check resource is
researchable and return error.'

00:10:16.216 --> 00:10:18.806
As you can see in Swift,
since we already know

00:10:18.806 --> 00:10:20.376
that the method can
return an error

00:10:20.696 --> 00:10:22.066
from that 'throws' keyword,

00:10:22.306 --> 00:10:24.066
we will chop off
those last three words

00:10:24.096 --> 00:10:25.466
for you, just for you!

00:10:27.776 --> 00:10:30.756
[Laughter] Now, all of
this is about what happens

00:10:30.756 --> 00:10:33.586
when you have the
NSError-star-star type,

00:10:33.586 --> 00:10:35.696
when you are using
the really basic form

00:10:35.696 --> 00:10:37.706
of the NSError conventions.

00:10:38.116 --> 00:10:39.406
What happens in other cases?

00:10:39.986 --> 00:10:42.276
Well, we just keep things as is.

00:10:42.636 --> 00:10:45.596
If you have an NSError in
Objective-C, it will come

00:10:45.596 --> 00:10:48.326
into Swift usually as an
optional NSError reference

00:10:48.616 --> 00:10:50.366
and you can handle
it as appropriate

00:10:50.366 --> 00:10:52.076
for whatever API you are using.

00:10:53.146 --> 00:10:57.006
Remember that NSError conforms
to Swift's error type protocol,

00:10:57.006 --> 00:10:58.206
so you can also use it

00:10:58.206 --> 00:11:00.316
with Swift's own error
handling mechanisms.

00:11:00.316 --> 00:11:05.786
All of this shows that Swift
is well equipped to deal

00:11:05.786 --> 00:11:08.026
with all the errors
coming from Objective-C.

00:11:09.206 --> 00:11:12.086
But what if I call a
method from Objective-C,

00:11:12.846 --> 00:11:15.936
and it's a Swift method
that produces a Swift error?

00:11:16.626 --> 00:11:19.696
Now, of course, we
need this to work.

00:11:19.926 --> 00:11:21.326
Let's find out how it works.

00:11:22.656 --> 00:11:24.936
Here I have a type
named 'request error.'

00:11:25.256 --> 00:11:28.416
It's a new type I'm defining
using Swift's error system.

00:11:28.606 --> 00:11:31.616
It conforms to the error type
protocol, and in this case,

00:11:31.616 --> 00:11:35.526
it's an enum that only has
one possible enum case.

00:11:36.726 --> 00:11:39.466
I can use this error in
a method very easily.

00:11:39.996 --> 00:11:42.256
Here I'm defining a
'send request' method.

00:11:42.556 --> 00:11:45.236
I mark it with the
'throws' keyword to indicate

00:11:45.236 --> 00:11:48.436
that it can fail, and then
I actually use the 'throw'

00:11:48.436 --> 00:11:50.926
statement when I hit
that failure condition.

00:11:51.506 --> 00:11:55.246
Now, if I try to call this
method from Objective-C,

00:11:55.246 --> 00:11:56.416
it ought to just work.

00:11:56.836 --> 00:11:58.646
Let's see what that looks like.

00:11:59.836 --> 00:12:02.086
The first thing to
notice is that the name

00:12:02.086 --> 00:12:03.436
of the method has changed.

00:12:03.756 --> 00:12:05.296
Instead of just 'send request,

00:12:05.526 --> 00:12:07.706
we now have 'send
request error.'

00:12:08.416 --> 00:12:09.676
The name that you
would have used

00:12:09.676 --> 00:12:12.256
if you had written this method
in Objective-C to begin with.

00:12:13.326 --> 00:12:17.106
Additionally, we're just using
a plain-old NSError type,

00:12:17.146 --> 00:12:19.476
from foundation here,
even though the error

00:12:19.476 --> 00:12:21.296
that we produced
came from Swift.

00:12:22.226 --> 00:12:25.526
And what's more, that error
type actually contains

00:12:25.526 --> 00:12:26.806
useful information.

00:12:27.156 --> 00:12:30.126
If we print the domain and
code that go with this error,

00:12:30.376 --> 00:12:33.866
we will see that it turns out
to be the type and the raw value

00:12:33.866 --> 00:12:36.086
of the enum case
that we saw before.

00:12:36.086 --> 00:12:40.446
Now, there's one more nice
thing that's going on here.

00:12:41.016 --> 00:12:43.656
I marked this enum with
the ObjC attribute.

00:12:44.276 --> 00:12:46.946
This is a feature we
added in Xcode 6.3.

00:12:47.276 --> 00:12:50.006
If you mark an enum
with the ObjC attribute,

00:12:50.486 --> 00:12:52.996
then it will get printed
into your generated header.

00:12:53.616 --> 00:12:56.246
The header that exposes
the Objective-C side

00:12:56.476 --> 00:12:57.626
of your Swift classes.

00:12:59.566 --> 00:13:01.826
In Xcode -- sorry -- in Xcode 7,

00:13:02.186 --> 00:13:04.146
we've added one more
little nice feature here.

00:13:04.646 --> 00:13:07.516
This is an enum that conforms
to the error type protocol,

00:13:08.126 --> 00:13:11.596
so we'll also generate a string
constant representing the

00:13:11.596 --> 00:13:12.396
error domain.

00:13:13.026 --> 00:13:16.796
Now, all of this is great
for errors you have defined

00:13:16.796 --> 00:13:19.926
in Swift, and you probably
want to run out and use this

00:13:19.926 --> 00:13:23.126
for your own classes, but
then the errors that come back

00:13:23.126 --> 00:13:25.826
from Cocoa and the
rest of the SDKs start

00:13:25.826 --> 00:13:28.436
to feel a little lacking.

00:13:28.566 --> 00:13:30.286
And, don't worry, we have
got you covered there too.

00:13:30.286 --> 00:13:33.066
So if you were at the
presentation earlier today,

00:13:33.126 --> 00:13:34.986
you might have seen
this preflight method

00:13:35.346 --> 00:13:38.176
which is checking that
a resource is reachable

00:13:38.176 --> 00:13:40.396
and then catching some
various error cases.

00:13:41.146 --> 00:13:43.166
Now one of the error
cases here is listed

00:13:43.166 --> 00:13:46.286
as 'NSURLError, file
does not exist.'

00:13:47.116 --> 00:13:49.086
That's an error that
comes from Cocoa.

00:13:49.706 --> 00:13:52.186
Why is that showing up,
using the Swift notation?

00:13:53.376 --> 00:13:56.126
Well, we have taken the most
common error types throughout

00:13:56.126 --> 00:13:58.946
our SDKs and made it so
that you can use them

00:13:58.946 --> 00:14:00.786
with Swift's own catch syntax.

00:14:01.506 --> 00:14:03.336
So there's are all sorts
of errors you can use here.

00:14:03.336 --> 00:14:05.936
And the general idea that you
should take away from this,

00:14:06.366 --> 00:14:09.166
is that errors should feel
like NSError when you're

00:14:09.166 --> 00:14:11.946
in Objective-C, and they
should feel like Swift errors

00:14:12.006 --> 00:14:12.916
when you are in Swift.

00:14:13.256 --> 00:14:14.206
Things should just work.

00:14:14.696 --> 00:14:18.566
So that's just some of the
enhancements we've made to Swift

00:14:18.656 --> 00:14:21.446
in the area of interoperability
over the last year.

00:14:21.986 --> 00:14:23.466
So to talk about the
enhancements we've made

00:14:23.466 --> 00:14:24.976
in the Objective-C
side of the world,

00:14:25.016 --> 00:14:26.416
I would like to hand
it over to Doug.

00:14:27.516 --> 00:14:33.586
[Applause]

00:14:34.086 --> 00:14:34.266
>> DOUG GREGOR: Thank you.

00:14:34.266 --> 00:14:34.936
Thank you, Jordan.

00:14:35.956 --> 00:14:37.336
So today I would like to talk

00:14:37.336 --> 00:14:40.906
about three new Objective-C
features we've added this year.

00:14:41.716 --> 00:14:42.586
These features can be used

00:14:42.586 --> 00:14:44.196
to make your Objective-C
code better,

00:14:44.196 --> 00:14:47.006
your Objective-C APIs better,
make them reflect better

00:14:47.006 --> 00:14:50.576
into Swift, and improve static
type safety in your Objective-C.

00:14:50.766 --> 00:14:52.126
The first thing we
are going to talk

00:14:52.126 --> 00:14:54.516
about is nullability
for Objective-C.

00:14:55.836 --> 00:14:58.626
So take a look at this
bit of Objective-C code.

00:14:59.696 --> 00:15:00.616
Lots of pointers here.

00:15:01.286 --> 00:15:02.616
Which one of these can be nil?

00:15:04.296 --> 00:15:05.356
The code doesn't tell you.

00:15:06.476 --> 00:15:07.936
If you go read the
documentation,

00:15:07.936 --> 00:15:10.716
maybe it will tell you if
you are feeling lucky today.

00:15:11.936 --> 00:15:13.406
You could go write some tests

00:15:13.406 --> 00:15:16.676
and see what you think it
behaves like or maybe guess,

00:15:16.676 --> 00:15:18.176
but that's not really good.

00:15:18.176 --> 00:15:19.716
There's really missing
information here.

00:15:20.696 --> 00:15:22.336
When we introduced
Swift last year,

00:15:22.646 --> 00:15:25.606
this lack of information
became much more apparent

00:15:26.246 --> 00:15:28.566
in these implicitly
unwrapped optionals,

00:15:29.266 --> 00:15:30.836
which essentially
means we don't know

00:15:30.836 --> 00:15:32.176
if it can be nil
on the Swift side.

00:15:34.116 --> 00:15:35.456
So we weren't too
thrilled with this,

00:15:35.976 --> 00:15:39.176
and so after releasing
Swift 1.0, we went

00:15:39.376 --> 00:15:41.996
and audited a couple
thousand pointers

00:15:41.996 --> 00:15:46.376
within our own core
frameworks to tell the compiler

00:15:46.756 --> 00:15:48.326
which of these pointers
can be nil.

00:15:48.776 --> 00:15:51.726
And the interfaces after this
audit got much, much cleaner.

00:15:52.366 --> 00:15:54.876
Now, we are only
using optional types

00:15:54.986 --> 00:15:57.296
where nil is actually
something you have to deal with,

00:15:58.076 --> 00:15:59.516
and everything else
is non-optional.

00:16:00.836 --> 00:16:02.726
This is still not
that wonderful,

00:16:02.726 --> 00:16:04.986
because this knowledge is
baked into the compiler.

00:16:04.986 --> 00:16:06.136
It's not something you can do.

00:16:06.936 --> 00:16:10.766
So with Xcode 6.3, we introduced
nullability qualifiers

00:16:10.766 --> 00:16:11.596
for Objective-C.

00:16:13.056 --> 00:16:15.056
So a nullability qualifier
is something you can add

00:16:15.306 --> 00:16:17.006
to a C/Objective-C pointer

00:16:17.586 --> 00:16:19.366
to state whether it
accepts nil or not.

00:16:19.466 --> 00:16:23.426
Of course, this better
communicates what your API

00:16:23.426 --> 00:16:24.276
actually does.

00:16:24.486 --> 00:16:25.556
Does it accept nil?

00:16:25.556 --> 00:16:26.856
Does that make sense for it?

00:16:27.686 --> 00:16:29.926
It helps our tools do
better static checking

00:16:29.926 --> 00:16:32.026
to catch bugs before they
manifest at run time,

00:16:32.646 --> 00:16:35.426
and it makes the Swift
experience so much better

00:16:35.646 --> 00:16:37.066
with your Objective-C APIs!

00:16:37.626 --> 00:16:41.616
Now, there are three
nullability qualifiers.

00:16:42.486 --> 00:16:45.206
Nullable, which indicates
that the pointer may be null.

00:16:46.366 --> 00:16:48.256
This, of course, maps
into a Swift optional.

00:16:49.366 --> 00:16:50.406
And then there's non-null.

00:16:50.806 --> 00:16:55.546
So this indicates that null or
nil is not a meaningful value.

00:16:57.326 --> 00:16:59.876
Now, for a non-null pointer,
it could end up being nil

00:17:00.616 --> 00:17:01.916
in an Objective-C program.

00:17:02.116 --> 00:17:05.026
Maybe it comes because we
messaged nil at some point

00:17:05.026 --> 00:17:06.286
and the nil propagated through

00:17:07.165 --> 00:17:08.705
and maybe this has
worked in the past.

00:17:08.986 --> 00:17:11.705
The compiler is not going to
change the way it generates code

00:17:11.705 --> 00:17:13.246
because of a non-null
annotation.

00:17:13.556 --> 00:17:16.175
But this indicates the
intent of the API author

00:17:16.175 --> 00:17:17.756
that nil does not
make sense here.

00:17:18.316 --> 00:17:22.996
We also have a third qualifier,
and that is null-unspecified.

00:17:23.866 --> 00:17:26.695
This is for cases where
neither nullable nor non-null is

00:17:26.695 --> 00:17:29.736
actually the right thing,
and we map these into Swift

00:17:29.736 --> 00:17:32.776
as the same implicitly
unwrapped optional you would get

00:17:32.936 --> 00:17:34.856
if we knew nothing about
the pointer whatsoever.

00:17:35.396 --> 00:17:37.816
And the most important thing

00:17:37.876 --> 00:17:40.506
about nullability qualifiers
is we've rolled them

00:17:40.506 --> 00:17:42.066
out throughout our SDKs.

00:17:43.356 --> 00:17:44.786
Alright, so instead of
just covering a couple

00:17:44.866 --> 00:17:45.846
of core frameworks,

00:17:45.886 --> 00:17:47.816
we've covered the
majority of the SDKs.

00:17:47.816 --> 00:17:51.726
So this gives a much, much
better Swift experience

00:17:52.036 --> 00:17:54.086
with true optionals where
they actually matter

00:17:54.236 --> 00:17:55.776
and non-optionals
everywhere else.

00:17:56.866 --> 00:17:59.226
For your Objective-C code, it
means you are going to start

00:17:59.226 --> 00:18:01.116
to see new warnings for places

00:18:01.116 --> 00:18:02.926
where you have been
misusing APIs.

00:18:03.586 --> 00:18:06.246
So, here, for example, you see a
warning that you've passed null

00:18:06.246 --> 00:18:09.436
or nil to a method that
did not expect it here.

00:18:09.436 --> 00:18:11.106
It is not part of
the API contract.

00:18:12.116 --> 00:18:14.536
Now maybe passing a
nil has worked before;

00:18:14.976 --> 00:18:16.346
it may continue to work.

00:18:16.826 --> 00:18:18.226
But you should heed
these warnings,

00:18:18.266 --> 00:18:20.166
because the API author
has told you,

00:18:20.346 --> 00:18:22.816
you should not pass nil
here, it's good to be careful

00:18:22.816 --> 00:18:26.346
because it may change
in the future.

00:18:26.526 --> 00:18:27.636
Now, let's say you want

00:18:27.636 --> 00:18:29.876
to add nullability
qualifiers to your own headers.

00:18:30.206 --> 00:18:32.996
The place to start is
with an audited region.

00:18:33.656 --> 00:18:36.236
So, these are described by
'NS-assume non-null begin,

00:18:36.566 --> 00:18:37.876
'NS-assume non-null end;

00:18:38.516 --> 00:18:41.126
bracket your header
with these macros.

00:18:42.116 --> 00:18:44.036
What this does is it
allows the compiler

00:18:44.036 --> 00:18:46.896
to make default assumptions
about pointers

00:18:46.896 --> 00:18:48.526
that are not otherwise
annotated.

00:18:49.146 --> 00:18:51.656
So, if you have a single
level pointer, that's going

00:18:51.656 --> 00:18:54.426
to be assumed non-null,
because what we've found is

00:18:54.426 --> 00:18:57.736
that nil is not a meaningful
value for most of our APIs.

00:18:58.256 --> 00:19:01.506
The other interesting
special case here is

00:19:01.506 --> 00:19:03.166
NSError-star-star parameters.

00:19:03.166 --> 00:19:06.216
Where you're doing error
handling in Objective-C,

00:19:06.386 --> 00:19:08.446
these are assumed to be
nullable at both levels,

00:19:08.446 --> 00:19:11.226
because that's the way you
work with them for nullability.

00:19:12.726 --> 00:19:15.036
Now the defaults are good, they
should cover most of the cases,

00:19:15.546 --> 00:19:18.276
but that means you have to
annotate the exceptional cases.

00:19:18.646 --> 00:19:22.026
So here we are marking the super
view property as being nullable,

00:19:22.026 --> 00:19:24.696
because, of course, not
every view has a super view.

00:19:24.836 --> 00:19:25.806
Nil has meaning there.

00:19:27.076 --> 00:19:29.536
Hit test with event has
a nullable parameter.

00:19:30.186 --> 00:19:32.936
You don't have to pass in an
event to do hit testing and,

00:19:32.936 --> 00:19:35.246
of course, the result
is nullable

00:19:35.246 --> 00:19:36.516
because nil has meaning there.

00:19:36.516 --> 00:19:39.976
It means we didn't hit anything.

00:19:40.066 --> 00:19:42.386
Now, this is where
null-unspecified comes up.

00:19:43.056 --> 00:19:44.306
Say you are auditing a header.

00:19:45.426 --> 00:19:49.596
You run into some really weird
implementation that's been

00:19:49.596 --> 00:19:50.526
around forever.

00:19:50.906 --> 00:19:52.646
You have no idea what
it does with nil.

00:19:53.206 --> 00:19:54.636
It hasn't been documented.

00:19:55.206 --> 00:19:57.806
Maybe it's doing something
really, really interesting

00:19:57.806 --> 00:20:00.396
with messaging nil that may or
may not work and the only guy

00:20:00.396 --> 00:20:02.236
that can answer it
retired five years ago.

00:20:03.726 --> 00:20:05.356
Great place to use
null unspecified.

00:20:06.046 --> 00:20:07.626
Just mark it as null
unspecified.

00:20:07.856 --> 00:20:11.556
This means, 'I thought about it,
I couldn't come to an answer.'

00:20:11.876 --> 00:20:15.246
The best thing to do is keep it
implicitly unwrapped optional

00:20:15.246 --> 00:20:18.686
in Swift, keep it
null-unspecified here.

00:20:18.686 --> 00:20:20.256
You can always come
back to it later.

00:20:20.336 --> 00:20:21.496
So when auditing,
you really want

00:20:21.496 --> 00:20:23.626
to get some good breadth early

00:20:23.846 --> 00:20:26.326
to make your APIs much,
much better, faster.

00:20:28.296 --> 00:20:31.896
Now, when you go down to C,

00:20:31.976 --> 00:20:33.616
things get a little
bit more murky.

00:20:34.446 --> 00:20:36.846
So we have all of the same
qualifiers but they need

00:20:36.846 --> 00:20:38.626
to be preceded by the
double-underscore.

00:20:39.856 --> 00:20:42.876
Now, these double-underscored
keywords, those qualifiers,

00:20:42.876 --> 00:20:45.176
can be used on any
pointer, anywhere.

00:20:45.746 --> 00:20:50.226
The important rule here is that
the qualifier goes to the right

00:20:51.326 --> 00:20:54.216
of the pointer it applies
to, the same place that const

00:20:54.216 --> 00:20:56.486
or volatile would go to,
to apply to that pointer.

00:20:57.766 --> 00:21:00.816
This is particularly important
for multilevel pointers

00:21:00.956 --> 00:21:02.786
like this values parameter here

00:21:03.376 --> 00:21:07.366
where the outer pointer is
nullable, because you can pass

00:21:07.366 --> 00:21:10.446
in nil to this parameter so
long as num-values is also zero.

00:21:12.196 --> 00:21:15.916
The inner pointer is non-null,
because when you are passing

00:21:15.916 --> 00:21:19.886
in an array of values, all of
those values must be non-null

00:21:19.886 --> 00:21:20.976
to work with CF array.

00:21:21.586 --> 00:21:26.606
That's all we're going to
talk about with nullability.

00:21:27.436 --> 00:21:29.316
We've pushed it throughout
our SDKs this year,

00:21:29.316 --> 00:21:30.856
so you get a much
better experience

00:21:30.856 --> 00:21:32.566
in both Objective-C and Swift.

00:21:33.016 --> 00:21:35.366
We highly recommend
that you use it

00:21:35.366 --> 00:21:38.276
to improve your own
Objective-C APIs, particularly

00:21:38.276 --> 00:21:39.986
for a much better
Swift experience.

00:21:40.106 --> 00:21:44.286
Alright, let's come on
to the next feature.

00:21:44.676 --> 00:21:47.596
This is a big one.

00:21:47.596 --> 00:21:49.016
Lightweight generics
for Objective-C.

00:21:49.626 --> 00:21:52.336
Now, the origin of this feature,

00:21:52.706 --> 00:21:54.566
it's actually fairly
easy to motivate.

00:21:55.016 --> 00:21:55.666
Collections.

00:21:56.996 --> 00:21:59.696
Here we have this
NSArray of subviews.

00:22:00.226 --> 00:22:02.406
What's in the array?

00:22:03.246 --> 00:22:04.636
We don't say what's
in the array.

00:22:05.056 --> 00:22:08.176
We bring this into Swift and
you say, ah, it's an array

00:22:08.176 --> 00:22:09.466
of any object, of course.

00:22:09.566 --> 00:22:11.476
That still tells me
absolutely nothing.

00:22:12.126 --> 00:22:14.556
I have to cast a lot.

00:22:14.556 --> 00:22:15.216
That's what it tells me.

00:22:15.896 --> 00:22:19.976
So we have had, of
course, this common request

00:22:19.976 --> 00:22:21.476
for typed collections.

00:22:22.246 --> 00:22:25.096
Because people really want to
say I have an array of views.

00:22:25.466 --> 00:22:27.416
I have a dictionary that
maps from string keys

00:22:27.416 --> 00:22:29.576
over to the images
associated with those keys.

00:22:30.536 --> 00:22:32.986
This has been probably been the
most highly requested feature

00:22:32.986 --> 00:22:34.996
for the last decade
of Objective-C.

00:22:35.666 --> 00:22:37.386
So, now we are finally
rolling it

00:22:37.386 --> 00:22:39.656
out with lightweight
generics for Objective-C.

00:22:40.276 --> 00:22:42.656
So this is a general language
feature that can be used

00:22:42.656 --> 00:22:44.966
to improve the expressivity
of your APIs;

00:22:45.806 --> 00:22:48.836
it makes collections
way easier to use now

00:22:48.836 --> 00:22:51.956
that we have all the static type
safety of typed collections.

00:22:52.486 --> 00:22:54.366
Let's take a look.

00:22:55.546 --> 00:22:57.296
So here's our subviews
property again.

00:22:58.546 --> 00:23:00.596
To make this an array
of UI-views,

00:23:01.096 --> 00:23:04.896
we just place UI-view-star, so
UIV pointer, in angle brackets.

00:23:05.086 --> 00:23:06.556
Same syntax you have seen.

00:23:06.556 --> 00:23:06.886
Whoops, sorry.

00:23:07.516 --> 00:23:14.566
[Applause]

00:23:15.066 --> 00:23:18.056
The same syntax you have
seen from Swift and C++

00:23:18.056 --> 00:23:20.376
and C-Sharp, et cetera,
et cetera.

00:23:20.796 --> 00:23:21.976
Yes, we are completely aware

00:23:21.976 --> 00:23:24.056
that angle brackets are
quote protocol qualifiers.

00:23:24.266 --> 00:23:28.536
Don't worry, we've got it.

00:23:28.536 --> 00:23:31.956
So this introduces more type
information into Objective-C.

00:23:32.056 --> 00:23:33.886
Of course, this reflects
into Swift

00:23:33.886 --> 00:23:36.036
as much more beautiful
type information.

00:23:36.476 --> 00:23:38.486
But really I want to talk
about the Objective-C effect

00:23:38.576 --> 00:23:41.276
because this is a really
useful feature for Objective-C.

00:23:41.766 --> 00:23:43.706
Because let's talk
about type safety.

00:23:44.176 --> 00:23:46.686
Here's an example.

00:23:47.236 --> 00:23:51.106
So I'm taking the path
components of any URL, NSURL.

00:23:51.106 --> 00:23:53.506
And I'm putting it
into an array of URLs.

00:23:54.036 --> 00:23:56.506
That almost seems reasonable
if I didn't know this API

00:23:56.506 --> 00:23:59.826
and it would be a while before
I got the run time error,

00:23:59.826 --> 00:24:02.136
the unrecognized selector
that points out that no,

00:24:02.136 --> 00:24:04.636
I'm completely wrong in my
usage of path components.

00:24:05.406 --> 00:24:07.156
With type collections
and, of course,

00:24:07.226 --> 00:24:09.366
us rolling out type
collections throughout our SDKs,

00:24:09.366 --> 00:24:12.696
now you get a warning to tell
you just what you did wrong

00:24:13.006 --> 00:24:16.336
at the point where it happens.

00:24:16.496 --> 00:24:19.726
Many other cases here say I'm
building up immutable array

00:24:19.796 --> 00:24:24.496
of NS strings and I foolishly go
and add something to that array

00:24:24.726 --> 00:24:27.886
without turning it into
a string first, okay,

00:24:28.056 --> 00:24:29.816
the compiler is going
to tell me, no,

00:24:29.816 --> 00:24:31.276
you can't put an NS number

00:24:31.276 --> 00:24:33.076
into this NS mutable
array of strings.

00:24:33.326 --> 00:24:34.476
It doesn't make sense.

00:24:34.986 --> 00:24:38.566
Now, the compiler actually
has fairly deep knowledge

00:24:39.066 --> 00:24:42.226
of the semantics here of
the Cocoa collections.

00:24:42.896 --> 00:24:46.336
So let's take this example
here, we have an array of views,

00:24:46.956 --> 00:24:48.156
we have an array of responders.

00:24:48.206 --> 00:24:49.856
We assign from the array
of views to the array

00:24:49.856 --> 00:24:54.286
of responders, okay every
view is a responder.

00:24:54.286 --> 00:24:55.266
This seems fine.

00:24:55.846 --> 00:24:56.366
It is okay.

00:24:57.026 --> 00:25:00.886
Let's do the same thing
with the mutable variant.

00:25:02.336 --> 00:25:05.986
So we take the stored mutable
array of views and assign it

00:25:05.986 --> 00:25:09.456
over to the stored mutable
array of responders.

00:25:09.936 --> 00:25:11.866
There's a trap here.

00:25:12.676 --> 00:25:14.176
The trap, of course,
is I can go ahead

00:25:14.176 --> 00:25:17.936
and mutate my stored
responders, put something

00:25:17.936 --> 00:25:20.316
in there that's a
responder but not a view.

00:25:21.836 --> 00:25:24.376
Now, something later on is
getting very, very confused

00:25:24.436 --> 00:25:25.936
that the array of
views it's looking

00:25:25.936 --> 00:25:28.506
at has a view controller
in it, not a view.

00:25:29.946 --> 00:25:31.346
Compiler understands
this is as well.

00:25:31.396 --> 00:25:33.946
It will complain at the point
of initialization, here,

00:25:34.146 --> 00:25:37.136
that while it's perfectly safe
to do this kind of assignment

00:25:37.356 --> 00:25:40.776
with immutable arrays
because they don't change

00:25:40.776 --> 00:25:43.196
from underneath you,
it is not safe to do

00:25:43.296 --> 00:25:44.346
with the mutable variants.

00:25:44.796 --> 00:25:49.006
Alright. You have
actually seen all you need

00:25:49.006 --> 00:25:50.666
to use lightweight generics

00:25:50.666 --> 00:25:53.136
and typed collections
throughout your applications.

00:25:53.496 --> 00:25:55.646
But let's take a look
at how we use this

00:25:55.646 --> 00:25:57.116
within Foundation itself,

00:25:58.446 --> 00:26:00.346
to actually create
typed collections.

00:26:00.466 --> 00:26:02.226
Because the feature
here is generics.

00:26:02.826 --> 00:26:04.416
Typed collections is one
of the outcomes of it.

00:26:04.736 --> 00:26:07.196
So here we have NSArray as
you are used to seeing it.

00:26:08.436 --> 00:26:09.666
Now we are going
to parameterize it,

00:26:09.766 --> 00:26:13.756
based on the object type
that's stored in the NSArray,

00:26:14.636 --> 00:26:16.106
again, using angle brackets.

00:26:16.106 --> 00:26:17.316
We are just introducing
a name here.

00:26:18.056 --> 00:26:20.536
We can use that name throughout
the interface, so, of course,

00:26:20.536 --> 00:26:23.406
object at index, returns
something of the object type.

00:26:23.406 --> 00:26:26.306
If we go ahead and add
other methods here.

00:26:27.066 --> 00:26:29.526
When you initialize with
objects the array you get in,

00:26:29.526 --> 00:26:32.036
the C-array, contains objects.

00:26:32.976 --> 00:26:34.176
Use array by adding object.

00:26:34.176 --> 00:26:36.526
You put in a new object, you
get an NSArray of objects.

00:26:36.526 --> 00:26:38.456
So it composes very,
very, very nicely.

00:26:39.416 --> 00:26:42.446
Of course this also works for
categories and extensions.

00:26:43.276 --> 00:26:46.406
Here we have an NSDictionary
category, parameterized

00:26:46.406 --> 00:26:49.206
on key type and the object
type, and we have gone ahead

00:26:49.206 --> 00:26:52.066
and added object for key
here, takes in a key type,

00:26:52.366 --> 00:26:55.336
returns a nullable object
type because, of course,

00:26:55.666 --> 00:26:57.566
nil matters here
and we want to have

00:26:57.566 --> 00:27:00.326
that information in our APIs.

00:27:00.526 --> 00:27:04.116
Now, of course, there are
existing categories defined

00:27:04.116 --> 00:27:07.706
on NSDictionary, NSArray, and so
on, you may have some yourself.

00:27:08.096 --> 00:27:09.916
Those will continue to
work as they always have.

00:27:10.336 --> 00:27:12.966
They cannot access the
type parameters in any way,

00:27:13.826 --> 00:27:15.986
but they also won't
change behavior at all,

00:27:15.986 --> 00:27:17.666
they will continue working
as they always have.

00:27:19.206 --> 00:27:21.976
That brings me to
backward compatibility.

00:27:23.236 --> 00:27:26.006
So the entire lightweight
generics feature is based

00:27:26.076 --> 00:27:27.276
on a type erasure model.

00:27:27.696 --> 00:27:29.266
Which means that
the compiler has all

00:27:29.266 --> 00:27:32.036
of this rich static type
information but it erases

00:27:32.036 --> 00:27:34.126
that information
when generating code.

00:27:34.986 --> 00:27:37.296
There's huge benefits
here for Objective-C,

00:27:37.616 --> 00:27:39.576
that we did not have
to make any changes

00:27:39.576 --> 00:27:43.306
to the Objective-C run time
to make this feature work.

00:27:43.986 --> 00:27:46.086
That means we are able
to roll out generics

00:27:46.086 --> 00:27:48.416
in type collections, you
can adopt them in all

00:27:48.416 --> 00:27:52.206
of your applications and it
does not affect your ability

00:27:52.206 --> 00:27:54.376
to deploy back to
existing operating systems.

00:27:55.516 --> 00:28:02.546
[Applause]

00:28:03.046 --> 00:28:04.836
>> DOUG GREGOR: And if it wasn't
obvious from that description,

00:28:04.836 --> 00:28:06.366
of course, we are also not going

00:28:06.366 --> 00:28:08.476
to change cogeneration
in any way.

00:28:08.476 --> 00:28:11.186
We are not adding runtime
checking to Objective-C

00:28:11.186 --> 00:28:13.166
that doesn't make
sense in Objective-C.

00:28:13.876 --> 00:28:16.136
We just maintain full
binary compatibility.

00:28:16.136 --> 00:28:19.306
So adopt this feature, enjoy
the warnings preventing you

00:28:19.306 --> 00:28:20.616
from making horrible mistakes.

00:28:21.956 --> 00:28:27.966
And you can adopt it
very, very, very...

00:28:28.516 --> 00:28:30.676
hmm gradually, I guess
is the best term here.

00:28:31.386 --> 00:28:33.266
So in addition to
binary compatibility,

00:28:33.336 --> 00:28:35.296
we want to provide
source compatibility,

00:28:35.626 --> 00:28:37.546
because we have rolled this
feature out through our SDKs.

00:28:37.546 --> 00:28:40.786
We don't want you to have to
update all of your source code

00:28:40.786 --> 00:28:42.346
to use these things everywhere.

00:28:42.656 --> 00:28:44.096
We want you to gradually
adopt it.

00:28:44.176 --> 00:28:45.576
Use it where it makes
sense for you.

00:28:46.076 --> 00:28:47.906
And so we provided these
implicit conversions

00:28:47.906 --> 00:28:49.506
in the language that allow you

00:28:49.506 --> 00:28:52.126
to add type arguments
or take them away.

00:28:52.856 --> 00:28:56.126
Okay? Again, there's no run
time cost to doing this.

00:28:56.526 --> 00:28:57.616
But it lets you get in and get

00:28:57.616 --> 00:28:59.506
out of the generic
system as you need.

00:28:59.806 --> 00:29:01.846
So all of your new code can
be written with generics

00:29:01.936 --> 00:29:03.316
and if you don't want
to touch your old code,

00:29:03.576 --> 00:29:04.436
that's perfectly line.

00:29:04.516 --> 00:29:07.256
It's not going to change.

00:29:07.406 --> 00:29:07.726
All right.

00:29:08.086 --> 00:29:12.586
We have one last feature to talk
about, this one's kind of cool.

00:29:12.836 --> 00:29:16.716
So kindof types.

00:29:17.236 --> 00:29:19.686
Actually, came out of our
work on lightweight generics.

00:29:20.366 --> 00:29:22.276
And so we started
with, of course,

00:29:22.946 --> 00:29:25.606
using the untyped
collection here for subviews,

00:29:26.196 --> 00:29:28.916
and there's code that
may go grab a view

00:29:28.916 --> 00:29:30.346
and send some message to it.

00:29:31.186 --> 00:29:32.056
This code is fine.

00:29:32.236 --> 00:29:32.946
It works today.

00:29:34.546 --> 00:29:36.996
We went ahead and did these
annotations to say, okay,

00:29:36.996 --> 00:29:41.506
subviews contains UI views
and now we get some warnings.

00:29:43.676 --> 00:29:46.006
The compiler is completely
justified

00:29:46.006 --> 00:29:46.996
in giving this warning.

00:29:48.076 --> 00:29:51.866
It knows now that the
first subview is a UI view.

00:29:52.906 --> 00:29:56.476
It can't know that you
know it's a UI button

00:29:56.776 --> 00:29:58.356
that would actually
respond to this selector.

00:29:59.486 --> 00:30:02.846
And so while the
compiler is right,

00:30:03.286 --> 00:30:05.056
it's not necessarily useful

00:30:05.056 --> 00:30:07.056
to be producing warnings
on all of this code.

00:30:07.056 --> 00:30:09.716
You get a raft of warnings
most of which would be benign

00:30:09.716 --> 00:30:11.556
and you would be
adding casts everywhere.

00:30:12.606 --> 00:30:14.696
This really forced
us to consider ID

00:30:14.796 --> 00:30:17.286
and how it's used
as an API contract.

00:30:18.616 --> 00:30:20.386
And so let's make this a
little simpler example.

00:30:20.386 --> 00:30:23.316
Let's talk about NSApp,
which is this global in Cocoa

00:30:23.316 --> 00:30:26.006
that gives you access to
your NSApplication instance.

00:30:26.916 --> 00:30:32.786
Now, what this really means
is NSApp is a subclass

00:30:32.976 --> 00:30:34.036
of NSApplication.

00:30:34.036 --> 00:30:35.906
But we couldn't describe
that to the type system.

00:30:36.796 --> 00:30:40.586
With kindof types, we can say
this exactly in Objective-C.

00:30:41.066 --> 00:30:43.946
What does this mean?

00:30:44.936 --> 00:30:47.246
This means NSApp is some
kind of application.

00:30:47.586 --> 00:30:51.866
So we are going to give it
some limited behavior, like ID.

00:30:53.256 --> 00:30:56.716
So I have my NSApp, of course
I can convert it to an NSObject

00:30:56.936 --> 00:30:59.686
because every NSApplication
is an NSObject.

00:31:00.466 --> 00:31:02.746
The important part here,
the ID-like behavior,

00:31:02.996 --> 00:31:05.666
is the implicit downcast
from NSApplication

00:31:06.026 --> 00:31:07.796
to your MyApplication subclass.

00:31:08.286 --> 00:31:09.836
That's good.

00:31:10.016 --> 00:31:12.346
We want that behavior
because that's how NSApp has

00:31:12.346 --> 00:31:13.056
always worked.

00:31:13.706 --> 00:31:16.326
Now, what we won't allow
is some silly cross-cast.

00:31:16.426 --> 00:31:19.496
You tried to use
NSApp in a string?

00:31:19.496 --> 00:31:21.816
Well, that's not an
NSApplication and never can be.

00:31:22.236 --> 00:31:23.396
So you can produce
a warning there.

00:31:23.976 --> 00:31:27.356
Of course, coming with
this is the notion

00:31:27.356 --> 00:31:30.836
that you can message NSApp and
get all of the methods that are

00:31:31.006 --> 00:31:32.016
in NSApplication,

00:31:32.016 --> 00:31:33.916
its superclasses,
and its subclasses.

00:31:34.436 --> 00:31:37.306
Now, with kindof types
we actually found

00:31:37.306 --> 00:31:39.366
that this is much
more useful than ID.

00:31:39.686 --> 00:31:43.526
Because it gives you more type
information in the API contract

00:31:43.956 --> 00:31:46.626
which is great for both
Swift and Objective-C.

00:31:47.156 --> 00:31:49.226
So here we have this
NS tableview method,

00:31:49.416 --> 00:31:51.116
you have column,
row, makeIfNecessary.

00:31:51.606 --> 00:31:52.776
It's always returned to ID,

00:31:52.776 --> 00:31:54.716
because that implicit
downcasting behavior

00:31:54.716 --> 00:31:55.426
is important.

00:31:56.316 --> 00:31:59.396
Well, now we can rewrite
it as a kindof NSview.

00:31:59.396 --> 00:32:03.846
So returning some kind of
NSView, and on the Swift side,

00:32:04.176 --> 00:32:06.466
ah, now we are returning
an optional NSView.

00:32:06.836 --> 00:32:09.206
That's the right API for Swift

00:32:09.586 --> 00:32:11.476
and it works beautifully
in Objective-C.

00:32:12.386 --> 00:32:13.936
Let's bring it back to
our original example

00:32:13.936 --> 00:32:15.076
with lightweight generics.

00:32:15.606 --> 00:32:20.876
Here we were with our subviews
stated as an NSArray of UIViews.

00:32:21.196 --> 00:32:25.336
Well, now we can state that it's
an NSArray of kinds of UI views.

00:32:25.956 --> 00:32:28.006
So we get the stronger
API contract

00:32:28.006 --> 00:32:29.196
in Objective-C and Swift.

00:32:29.196 --> 00:32:32.976
It's far easier to tell
what this property is,

00:32:34.296 --> 00:32:37.486
but you don't cause any spurious
warnings because you still have

00:32:37.486 --> 00:32:40.606
that nice, implicit
downcasting behavior from ID.

00:32:41.916 --> 00:32:46.116
Hopefully this leads
you to a question.

00:32:46.186 --> 00:32:49.816
Should I even use ID in an API?

00:32:50.046 --> 00:32:52.596
Over the years we have
actually been rolling out a lot

00:32:52.596 --> 00:32:56.286
of features that give more
specific type information

00:32:56.286 --> 00:32:59.056
than ID for various
important scenarios.

00:33:00.056 --> 00:33:01.866
And the same year
we introduced Arc,

00:33:01.866 --> 00:33:03.136
we introduced instance type,

00:33:04.126 --> 00:33:06.506
which says that the method you
are calling returns something

00:33:06.506 --> 00:33:08.446
of the same dynamic
type as self.

00:33:09.676 --> 00:33:11.766
This year we are
introducing type collections

00:33:11.766 --> 00:33:14.176
that eliminate tons
of uses of ID.

00:33:14.596 --> 00:33:17.526
From our own APIs we have been
rolling out these features and,

00:33:17.526 --> 00:33:19.776
of course, from your APIs
when you adopt this feature.

00:33:21.096 --> 00:33:24.666
We now have kindof X to
talk about any subclass of X

00:33:24.666 --> 00:33:26.066
with implicit downcasting.

00:33:26.616 --> 00:33:29.346
So you can keep your
code working,

00:33:29.486 --> 00:33:31.846
at least all the actually
working code that's not doing

00:33:31.846 --> 00:33:35.896
weird things, but have a better
API contract, and, of course,

00:33:35.936 --> 00:33:38.096
protocols have been in
Objective-C for a very,

00:33:38.096 --> 00:33:41.906
very long time and using ID of
some protocol is a great way

00:33:41.906 --> 00:33:43.466
to say I don't care
what the class type is.

00:33:43.466 --> 00:33:44.986
It just has to conform
to this protocol.

00:33:45.586 --> 00:33:49.696
So there's one major
class of uses for ID.

00:33:50.136 --> 00:33:51.256
And that's when you really,

00:33:51.256 --> 00:33:53.866
really do mean an
object of any type.

00:33:54.246 --> 00:33:56.586
And there's no static type
information that could make

00:33:56.586 --> 00:33:57.626
that statement better.

00:33:58.606 --> 00:34:02.786
So, a canonical example here
is the user info dictionary.

00:34:03.156 --> 00:34:07.886
You have string keys and
you have ID for the values.

00:34:08.666 --> 00:34:09.766
It's completely reasonable

00:34:09.766 --> 00:34:12.315
because the different keys
will have different types

00:34:12.315 --> 00:34:14.505
in those values and it's
something you can only

00:34:14.505 --> 00:34:15.525
determine dynamically.

00:34:16.085 --> 00:34:20.456
Let's wrap things up.

00:34:20.985 --> 00:34:24.866
So, we have big improvements
for both Swift and Objective-C.

00:34:25.025 --> 00:34:27.496
These languages are
codesigned and coevolved

00:34:27.835 --> 00:34:29.576
to work together beautifully.

00:34:30.136 --> 00:34:34.295
And Xcode and the tools
supporting it will help you move

00:34:34.295 --> 00:34:37.976
between the two languages, the
best way for your workflow.

00:34:39.346 --> 00:34:41.996
We have rolled out a lot of
great features for Objective-C.

00:34:41.996 --> 00:34:44.126
We highly recommend you
modernize your usage

00:34:44.126 --> 00:34:44.916
of Objective-C.

00:34:45.525 --> 00:34:48.246
These new language features
give you much better APIs,

00:34:48.246 --> 00:34:50.766
and you will see this in
our APIs and in yours,

00:34:50.766 --> 00:34:53.065
and give you far
better type safety

00:34:53.106 --> 00:34:55.196
to catch bugs before
they manifest

00:34:55.196 --> 00:34:57.386
as the dreaded unrecognized
selector at runtime.

00:34:57.386 --> 00:35:01.526
And using these features can
really make your Objective-C

00:35:01.526 --> 00:35:03.226
interfaces beautiful in Swift,

00:35:03.376 --> 00:35:07.186
so you have the best Swift
experience with your own code.

00:35:07.796 --> 00:35:12.596
For more information, please
contact our Evangelist,

00:35:12.706 --> 00:35:15.166
Stefan Lesser, check
out the documentation,

00:35:15.166 --> 00:35:16.536
or talk to us in
the forum online.

00:35:17.136 --> 00:35:19.826
There's a bunch of
related sessions talking

00:35:19.826 --> 00:35:21.386
about what's new
in Swift and Cocoa.

00:35:21.846 --> 00:35:23.716
Lots of great Swift
sessions here.

00:35:24.386 --> 00:35:24.976
Thank you very much.

00:35:25.516 --> 00:35:39.370
[Applause]
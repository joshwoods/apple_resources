WEBVTT

00:00:25.690 --> 00:00:26.100
Good afternoon.

00:00:26.100 --> 00:00:29.600
I had way too many brownies at lunch and
if you're like me you'll probably just

00:00:29.730 --> 00:00:31.460
knock right off in about an hour here.

00:00:31.480 --> 00:00:36.680
But it's the last couple of sessions this
week and the purpose of this session is

00:00:36.680 --> 00:00:40.660
to present to you some new technology
that's in Panther called SearchKit.

00:00:40.660 --> 00:00:45.240
And the value of SearchKit I think is
that it provides some functionality

00:00:45.320 --> 00:00:48.800
that's been missing in the system
first of all and that wasn't

00:00:48.800 --> 00:00:50.120
available to you as a developer.

00:00:50.360 --> 00:00:54.070
And secondly if you can leverage that
functionality in your application you

00:00:54.070 --> 00:00:57.520
can really deliver a very consistent
user experience for searching.

00:00:57.520 --> 00:01:00.990
Not to mention the fact that you'll
have a search engine that's already

00:01:01.090 --> 00:01:03.030
written for you in your application.

00:01:03.050 --> 00:01:07.130
So to talk you through the specifics of
this new technology in Panther I want

00:01:07.130 --> 00:01:08.920
to introduce Wayne Loofbro.

00:01:08.920 --> 00:01:11.080
To the stage.

00:01:11.390 --> 00:01:12.580
Thanks.

00:01:20.920 --> 00:01:23.280
Thanks, John.

00:01:23.390 --> 00:01:25.220
So welcome to the SearchKit session.

00:01:25.220 --> 00:01:29.820
If you're having trouble finding a seat,
there are some up front.

00:01:32.920 --> 00:01:39.050
So today we're going to talk a bit about
SearchKit and how it's used in Mac OS X.

00:01:39.060 --> 00:01:42.350
It's actually been used for a while,
even before it's been

00:01:42.350 --> 00:01:43.970
released as a public API.

00:01:44.100 --> 00:01:48.540
A bit about what it can do and how
to add search to your application.

00:01:50.120 --> 00:01:53.590
So specifically,
we'll talk about what SearchKit is,

00:01:53.700 --> 00:01:57.940
some of the challenges of providing
searching that SearchKit solves,

00:01:57.950 --> 00:02:02.750
and then how to go about doing
indexing in three steps and how

00:02:02.780 --> 00:02:05.440
to do searching in three steps.

00:02:05.440 --> 00:02:09.300
And then we'll talk a bit
about an application of

00:02:09.300 --> 00:02:13.290
SearchKit called Summarization,
which provides a specific API that

00:02:13.290 --> 00:02:13.290
you may also be interested
in using in your application.

00:02:14.480 --> 00:02:16.490
So where does SearchKit fit
into the technology framework?

00:02:16.590 --> 00:02:18.890
So you've all seen this diagram by now.

00:02:18.890 --> 00:02:22.530
In this diagram,
we also show core services in the middle,

00:02:22.530 --> 00:02:24.160
the middle green one there.

00:02:24.350 --> 00:02:27.640
And that's precisely
where SearchKit fits in.

00:02:27.650 --> 00:02:32.440
So this is a layer above Darwin and
below the level of the frameworks.

00:02:35.360 --> 00:02:36.090
So just a bit of history.

00:02:36.180 --> 00:02:39.100
Some of you actually may already
be familiar with SearchKit if you

00:02:39.210 --> 00:02:41.570
looked at all at V-Twin or AIAT.

00:02:41.690 --> 00:02:44.870
This is a technology that
was available in Mac OS 9.

00:02:44.950 --> 00:02:47.590
It was called the
Apple Information Access Toolkit,

00:02:47.590 --> 00:02:48.870
if you can believe it.

00:02:48.960 --> 00:02:51.870
And it's a C++ API.

00:02:52.070 --> 00:02:57.700
It used its own custom data types,
and it was a rather complex API.

00:02:57.700 --> 00:03:03.000
In fact, I think the manual for
it was about 300 pages.

00:03:03.000 --> 00:03:08.900
So we wanted to improve this in Mac OS X,
and so what we did was we created

00:03:08.900 --> 00:03:13.880
a very streamlined C API that's
based on the core foundation types.

00:03:13.880 --> 00:03:13.880
It has about maybe 40 or 50 calls,
and it's much shorter documentation.

00:03:15.730 --> 00:03:18.350
So as I mentioned,
SearchKit is used in a number of

00:03:18.440 --> 00:03:20.290
the applications in the system.

00:03:20.290 --> 00:03:23.770
In particular, in Address Book,
the sort of searches you type

00:03:23.830 --> 00:03:27.750
that lets you find addresses in
your Address Book uses SearchKit.

00:03:28.150 --> 00:03:33.240
In Apple Help, you want to know how do
I connect to the internet?

00:03:33.250 --> 00:03:36.130
Apple Help will use SearchKit to
find all the documents that

00:03:36.130 --> 00:03:37.720
are relevant to that query.

00:03:40.690 --> 00:03:44.090
In Apple Mail,
it's also used to search mailboxes.

00:03:44.100 --> 00:03:48.430
Each mailbox is indexed using SearchKit,
and you can search individual indexes

00:03:48.430 --> 00:03:52.240
or all of them at the same time,
and you get relevance-ranked results.

00:03:54.420 --> 00:03:56.580
and in the Finder in
the content searching.

00:03:56.580 --> 00:03:58.980
So when you do content
searching in the Finder,

00:03:58.980 --> 00:04:02.270
SearchKit does the underlying
search and again you get relevance

00:04:02.270 --> 00:04:05.790
ranked results based on the contents
of the documents on your disk.

00:04:07.960 --> 00:04:11.100
So now to demonstrate a
few of the applications,

00:04:11.100 --> 00:04:15.030
I'd like to invite David Casseres,
the Find by Content tech lead.

00:04:20.910 --> 00:04:22.030
Thank you very much.

00:04:22.140 --> 00:04:25.350
I'm going to do,
if we can have demo one here.

00:04:25.430 --> 00:04:28.780
I'm going to do a couple of
very brief demonstrations.

00:04:28.900 --> 00:04:31.030
First I'll show you Mail.

00:04:34.530 --> 00:04:43.100
Where we have a few mailboxes and
I can put a little text right in here.

00:04:49.740 --> 00:04:54.040
I type in iTunes,
I find the one message in all

00:04:54.040 --> 00:04:56.660
those mailboxes that has it.

00:04:56.710 --> 00:05:02.690
I can type in Beatles.

00:05:05.500 --> 00:05:12.200
[Transcript missing]

00:05:14.610 --> 00:05:16.030
and several there.

00:05:16.100 --> 00:05:20.770
Got a Switch commercial.

00:05:20.770 --> 00:05:20.770
Got an article.

00:05:21.760 --> 00:05:25.040
Yes, it does have the word switch in it.

00:05:25.060 --> 00:05:28.480
And because this is mail,
it's doing prefix searching.

00:05:28.500 --> 00:05:30.430
So I can type.

00:05:32.210 --> 00:05:34.590
There,
and I get the ones that have Abbey Road.

00:05:34.600 --> 00:05:36.100
All I typed was A-B-B.

00:05:36.100 --> 00:05:37.790
That's mail.

00:05:42.910 --> 00:05:50.960
Now in the Finder,
I can search some files.

00:05:51.020 --> 00:05:53.200
I have a set of demo files here.

00:05:53.200 --> 00:05:57.520
There are 770 files in here,
and they are previously indexed,

00:05:57.520 --> 00:06:00.730
so you're not going to see
the initial indexing process.

00:06:00.730 --> 00:06:02.920
But the Finder does something
much more complicated.

00:06:02.920 --> 00:06:07.150
It uses a couple of other frameworks
to go through to do something

00:06:07.150 --> 00:06:10.400
complicated with SearchKit,
and it will first search

00:06:10.480 --> 00:06:13.250
the existing index,
then start validating the index to

00:06:13.450 --> 00:06:17.310
make sure that it's still up to date,
and it will search repeatedly

00:06:17.310 --> 00:06:18.900
while it's doing that.

00:06:18.900 --> 00:06:20.140
And you'll see that it's all very quick.

00:06:24.690 --> 00:06:25.120
There we are.

00:06:25.260 --> 00:06:27.240
Relevance-ranked results.

00:06:27.280 --> 00:06:28.600
We've got all kinds of files here.

00:06:28.600 --> 00:06:32.260
We've got PDFs.

00:06:33.360 --> 00:06:33.360
We've got

00:06:35.020 --> 00:06:38.880
Text files, and so forth and so on.

00:06:38.880 --> 00:06:44.750
This works in practically any
language you can use with the Mac.

00:06:45.020 --> 00:06:49.310
and it's very much improved in
Panther and that's fine by content.

00:06:54.480 --> 00:06:55.390
Thank you, David.

00:06:55.390 --> 00:07:03.960
So there are a number of challenges
to providing search in SearchKit.

00:07:03.960 --> 00:07:06.320
In particular,
doing relevance ranked results.

00:07:06.320 --> 00:07:09.240
You don't just want the documents
that match a particular query,

00:07:09.240 --> 00:07:11.470
you also want them ranked by
how relevant they are to what

00:07:11.470 --> 00:07:13.270
it is you were asking for.

00:07:13.270 --> 00:07:17.920
Being able to support multiple languages,
as David mentioned,

00:07:17.920 --> 00:07:21.380
with SearchKit you can index a
large number of different languages.

00:07:21.380 --> 00:07:24.700
These are human languages,
not computer languages,

00:07:24.700 --> 00:07:26.980
and get correct results.

00:07:27.060 --> 00:07:29.610
We need to be flexible
about what a document means.

00:07:29.610 --> 00:07:33.840
It could be a document on your disk,
but it could also be a message in

00:07:33.840 --> 00:07:36.420
mail or an address in address book.

00:07:36.420 --> 00:07:38.940
And we have to be flexible
about the kinds of queries.

00:07:38.940 --> 00:07:42.210
You saw an example of prefix searching,
as well as you can do word-based

00:07:42.210 --> 00:07:45.850
searching and some other ones
that I'll talk about in a bit.

00:07:46.560 --> 00:07:55.450
So how does SearchKit deal
with some of these challenges?

00:07:55.450 --> 00:07:55.450
Well,
one example that comes up in Apple help

00:07:55.450 --> 00:07:55.450
is that you'd like to be able to

00:07:55.780 --> 00:08:00.670
type in a query like "How do
I connect to the internet?" Now,

00:08:00.670 --> 00:08:06.340
do you really mean to find documents
that contain the exact phrase "How

00:08:06.340 --> 00:08:12.940
do I connect to the internet?" Well,
no, that's not what you're looking for.

00:08:12.950 --> 00:08:14.190
What you want to know is documents
that are relevant to the query "How do

00:08:14.190 --> 00:08:14.190
I connect to the internet?" So you're
not just doing a string matching search.

00:08:14.900 --> 00:08:17.080
So what documents match this query?

00:08:17.110 --> 00:08:19.820
Well, it's really hard to know without
breaking it first into words.

00:08:19.820 --> 00:08:21.200
So that's what SearchKit does.

00:08:21.200 --> 00:08:23.310
It breaks it into words.

00:08:23.500 --> 00:08:27.400
But which document is
relevant to these words?

00:08:27.680 --> 00:08:31.160
Is a document that contains the
words "do," "I," "to," and "the"

00:08:31.160 --> 00:08:32.430
very relevant to the query?

00:08:32.440 --> 00:08:33.980
Well, probably not.

00:08:34.030 --> 00:08:38.210
It's probably not as relevant as
a document that contains "how,"

00:08:38.210 --> 00:08:43.030
"connect," and "internet." And so
one of the things that SearchKit does

00:08:43.040 --> 00:08:47.280
is to try to determine which words
in the query are most relevant to

00:08:47.280 --> 00:08:49.660
what it is that you're looking for.

00:08:49.660 --> 00:08:51.170
And it does this using
some statistical analysis.

00:08:53.230 --> 00:08:58.730
So another challenge in SearchKit is
dealing with different languages.

00:08:58.910 --> 00:09:02.600
So, it's fairly easy to break things into
words when you're dealing with English,

00:09:02.630 --> 00:09:07.920
say, or a world or a language that
separates words by spaces.

00:09:07.920 --> 00:09:09.610
But what if you're dealing with Japanese?

00:09:10.030 --> 00:09:12.240
There are no spaces between words.

00:09:12.240 --> 00:09:17.740
And so what SearchKit does is uses a
Japanese language analysis which was

00:09:17.740 --> 00:09:20.040
developed by the folks in Apple Japan.

00:09:20.120 --> 00:09:22.650
It's the language analysis framework.

00:09:22.830 --> 00:09:26.280
And it uses this to do a
grammatical analysis of Japanese,

00:09:26.280 --> 00:09:29.940
and then it can break
Japanese into words.

00:09:29.940 --> 00:09:34.410
And then use the same statistical
techniques to then find

00:09:34.480 --> 00:09:35.840
the most relevant document.

00:09:37.230 --> 00:09:39.420
But what is a document?

00:09:39.420 --> 00:09:41.270
Is a document just a
file on your hard disk?

00:09:41.470 --> 00:09:44.270
Well,
that would be a fairly limited capability

00:09:44.360 --> 00:09:46.400
if that's all you could look for.

00:09:46.450 --> 00:09:54.230
But, you know,
so we do search text documents,

00:09:54.330 --> 00:09:59.750
but we also search documents of other
file types such as Word and PDF and HTML.

00:10:00.180 --> 00:10:04.150
But in addition,
we support searching items that

00:10:04.150 --> 00:10:06.920
are within the application,
such as mail messages,

00:10:06.930 --> 00:10:09.460
address book items,
or in your application,

00:10:09.460 --> 00:10:14.100
really any object or maybe
an entry from a database.

00:10:14.200 --> 00:10:18.970
Really anything that contains text can
be indexed and searched with SearchKit.

00:10:21.030 --> 00:10:24.440
The other area of flexibility that
we need is in what a query is.

00:10:24.440 --> 00:10:27.760
I already gave the example of a
natural language query such as

00:10:27.800 --> 00:10:29.900
how do I connect to the internet.

00:10:29.900 --> 00:10:35.070
But we also want to be able to do
prefix queries such as the one that

00:10:35.160 --> 00:10:41.200
David demonstrated so that you can type
just the beginnings of words and even

00:10:41.300 --> 00:10:42.400
in the middle of your typing you can
do a search and get relevant results

00:10:42.400 --> 00:10:42.400
back without having to complete a word.

00:10:43.840 --> 00:10:45.690
You also want to be able
to do a Boolean query.

00:10:45.780 --> 00:10:49.620
In some cases you want to have
an exact match and so you'd be

00:10:49.620 --> 00:10:52.200
able to construct a Boolean query.

00:10:52.200 --> 00:11:00.590
And then there's a popular method used
in some of the internet search engines

00:11:00.590 --> 00:11:00.590
of marking things with pluses and minuses
to indicate inclusion or exclusion.

00:11:00.890 --> 00:11:03.240
And then as well, you might also want to
be able to find things.

00:11:03.240 --> 00:11:07.210
You've already found some items,
and now you want to find other

00:11:07.210 --> 00:11:10.990
items that are most like the
items you've already found.

00:11:11.010 --> 00:11:13.980
And so we also support
a similarity search.

00:11:14.080 --> 00:11:18.200
So you can provide documents as the input
and produce documents as the output.

00:11:21.650 --> 00:11:26.260
So we talked a little bit about a typical
usage scenario for using SearchKit.

00:11:26.260 --> 00:11:27.000
Really it's very simple.

00:11:27.000 --> 00:11:30.510
You index the documents and
then you search the index.

00:11:30.570 --> 00:11:34.590
And then we'll go into more
detail about that of course.

00:11:34.940 --> 00:11:38.460
Really the index's only purpose,
the only purpose of creating an

00:11:38.460 --> 00:11:40.500
index is to make searching fast.

00:11:40.590 --> 00:11:43.490
You could certainly look through
all the text content of all

00:11:43.570 --> 00:11:46.600
your documents to find things
if that's all you wanted to do,

00:11:46.600 --> 00:11:47.600
but you'd be missing a couple things.

00:11:47.600 --> 00:11:51.120
You'd be missing speed first of all,
but you'd also be missing the relevance

00:11:51.120 --> 00:11:56.600
ranking and some of the statistical
analysis that goes into the index.

00:11:56.600 --> 00:11:59.560
Once you've created an index,
you don't need the original

00:11:59.560 --> 00:12:01.600
documents in order to do searching.

00:12:01.730 --> 00:12:03.600
The index contains references
to those documents,

00:12:03.600 --> 00:12:05.600
not the content itself.

00:12:05.720 --> 00:12:09.340
But it also contains
statistical information about

00:12:09.440 --> 00:12:11.640
the words in the documents.

00:12:13.240 --> 00:12:17.860
And the index can be stored in memory,
if you like, for performance.

00:12:17.860 --> 00:12:21.650
Or if you want it to be persistent,
because you're going to use it again,

00:12:21.660 --> 00:12:23.720
then you could create it in a file.

00:12:25.280 --> 00:12:29.290
The basic process of
indexing is pretty simple.

00:12:29.560 --> 00:12:33.370
You provide the documents to SearchKit.

00:12:33.430 --> 00:12:36.330
It analyzes the text
and updates the index.

00:12:36.800 --> 00:12:38.990
The process of searching
is equally simple.

00:12:39.000 --> 00:12:41.750
You provide it with a query
and the index to search,

00:12:41.750 --> 00:12:44.710
and it searches the index
and returns results.

00:12:44.810 --> 00:12:48.120
So that's the basic outline, of course,
and we'll go into more detail.

00:12:48.220 --> 00:12:53.240
Indexing can be done
in three basic steps.

00:12:53.240 --> 00:12:55.700
You open the index that
you'd like to search.

00:12:55.780 --> 00:13:00.160
You add the documents to
the index and then flush it.

00:13:02.790 --> 00:13:05.100
So opening the index, of course,
could be opening an existing

00:13:05.100 --> 00:13:06.360
one or creating a new one.

00:13:06.590 --> 00:13:08.860
Opening an existing one is pretty basic.

00:13:08.950 --> 00:13:10.430
I won't bother talking about that.

00:13:10.600 --> 00:13:13.630
Creating a new one,
there's a decision to be made about

00:13:13.630 --> 00:13:16.010
what kind of index you want to create.

00:13:17.890 --> 00:13:21.760
There are three different types.

00:13:21.760 --> 00:13:25.100
The first is an inverted index.

00:13:25.100 --> 00:13:29.500
This kind of an index maps the
terms or words in each document to

00:13:29.500 --> 00:13:34.880
the document itself and provides
statistical information about them.

00:13:35.530 --> 00:13:40.680
This kind of index is used for most
of the query kinds of searches.

00:13:41.970 --> 00:13:44.700
A vector index maps the other way.

00:13:44.790 --> 00:13:47.480
It maps documents to terms.

00:13:47.580 --> 00:13:50.360
This kind of index is
actually seldom used.

00:13:50.360 --> 00:13:54.230
More common is the third kind of index,
which is an inverted vector index,

00:13:54.230 --> 00:13:55.300
which does both.

00:13:55.320 --> 00:13:58.260
So you might ask, you know,
why not just always create

00:13:58.260 --> 00:13:59.880
an inverted vector index?

00:13:59.900 --> 00:14:03.500
Because it obviously has the
capabilities of the first two.

00:14:03.580 --> 00:14:06.200
And really the answer is
just space and performance.

00:14:06.200 --> 00:14:07.370
It takes a bit longer to create.

00:14:07.500 --> 00:14:09.300
It has more information to put in it.

00:14:09.360 --> 00:14:13.300
And it takes more space
on the disk or in memory.

00:14:13.300 --> 00:14:16.490
So it turns out that for most purposes,
an inverted index is really the kind

00:14:16.500 --> 00:14:20.500
that you're going to want to use,
both for performance reasons

00:14:20.730 --> 00:14:23.170
and for space reasons.

00:14:23.770 --> 00:14:27.700
But just breaking it down a bit more,
if you're doing ranked prefix

00:14:27.700 --> 00:14:30.800
required or Boolean searching,
the four kinds that I talked about,

00:14:30.830 --> 00:14:33.990
four of the kinds that I talked about,
then you really want to be

00:14:33.990 --> 00:14:35.220
using an inverted index.

00:14:35.350 --> 00:14:38.080
It'll pretty much do,
it'll give you the best

00:14:38.320 --> 00:14:40.310
performance and size ratio.

00:14:40.320 --> 00:14:43.380
If you're going to be
doing similarity searching,

00:14:43.380 --> 00:14:45.620
it's okay to use an inverted index.

00:14:45.740 --> 00:14:46.450
It will still work.

00:14:46.560 --> 00:14:49.790
It's going to be a bit lower
performance in doing similarity

00:14:49.790 --> 00:14:52.010
searches than the inverted,
sorry,

00:14:52.010 --> 00:14:53.750
the inverted vector index is going to be.

00:14:53.760 --> 00:14:57.340
But if you're only doing
similarity searching pretty seldom,

00:14:57.340 --> 00:14:58.610
then that's probably the best choice.

00:14:58.620 --> 00:15:00.780
If you're going to do a lot
of similarity searching,

00:15:00.780 --> 00:15:02.520
then you probably want
an inverted vector index.

00:15:05.490 --> 00:15:12.500
Okay, so we've either opened an
existing index or created one.

00:15:12.500 --> 00:15:12.500
Now we gotta add the documents.

00:15:15.180 --> 00:15:17.640
So as I mentioned before,
documents can be any of a

00:15:17.640 --> 00:15:19.890
number of different kinds.

00:15:19.890 --> 00:15:23.800
It could be something on your disk,
something inside your application.

00:15:25.040 --> 00:15:29.940
For each of these documents,
what you provide is a document reference.

00:15:29.940 --> 00:15:33.930
The index doesn't need to store a
lot about the document itself other

00:15:33.940 --> 00:15:38.580
than a reference and the statistical
information that it wants to gather.

00:15:38.600 --> 00:15:41.530
And when you get results back,
you're going to get references back

00:15:41.530 --> 00:15:43.540
rather than the actual document itself.

00:15:43.560 --> 00:15:50.680
These references are just URLs or
they're created from URLs,

00:15:50.680 --> 00:15:51.390
I should say, to be more precise.

00:15:53.000 --> 00:16:00.490
The other thing you need to provide is,
of course, the text of the document.

00:16:00.600 --> 00:16:02.880
And there are a number
of ways to do this.

00:16:02.880 --> 00:16:02.880
If you have a file,
such as the first example on the left,

00:16:03.870 --> 00:16:08.000
Then you use a file call and reference
and that tells SearchKit that it's

00:16:08.000 --> 00:16:09.800
something that it knows how to read.

00:16:09.800 --> 00:16:12.780
And the text from the document
will be read automatically.

00:16:14.410 --> 00:16:17.910
In addition, if you'd like it to handle
multiple file formats,

00:16:18.040 --> 00:16:21.500
we have built-in support for
a number of them in SearchKit.

00:16:21.500 --> 00:16:23.850
And all you need to do is
load the default extractors,

00:16:23.960 --> 00:16:25.300
which is a call in SearchKit.

00:16:25.410 --> 00:16:30.490
And that means whenever you read a file,
it will do the text extraction for you.

00:16:33.110 --> 00:16:35.110
But if you'd like to
handle any kind of item,

00:16:35.120 --> 00:16:39.120
in particular you want to handle
something that's inside your application,

00:16:39.120 --> 00:16:42.640
or you have a document format
that we don't know about that you

00:16:42.720 --> 00:16:45.740
know how to get this text from,
then you can provide

00:16:45.740 --> 00:16:47.390
the text as a CFString.

00:16:49.080 --> 00:16:51.000
That's the universal method.

00:16:51.000 --> 00:16:53.740
And it can be,
the document reference at that point

00:16:53.740 --> 00:16:57.620
can be any kind of scheme and any
kind of hierarchy that you'd like

00:16:57.620 --> 00:17:00.190
to create within your application.

00:17:04.570 --> 00:17:08.430
And then the last step is simply
flushing the index to disk or to memory.

00:17:08.430 --> 00:17:12.630
And at that point, you're done indexing.

00:17:12.730 --> 00:17:14.940
So it's actually pretty simple.

00:17:14.980 --> 00:17:16.910
Now you're ready to search.

00:17:18.110 --> 00:17:20.610
So searching has three
basic steps as well,

00:17:20.650 --> 00:17:22.790
and I'll talk about each of those.

00:17:22.840 --> 00:17:25.140
First, you create the search group.

00:17:25.220 --> 00:17:29.130
Then you send the query to
SearchKit and process the results.

00:17:32.800 --> 00:17:34.340
I just hit the blink button there.

00:17:34.500 --> 00:17:37.730
OK.

00:17:38.720 --> 00:17:38.750
So searching.

00:17:39.860 --> 00:17:42.700
One thing that SearchKit supports
is the ability to have more than one

00:17:42.700 --> 00:17:44.700
index to be searched at the same time.

00:17:44.700 --> 00:17:46.700
Now you might ask why we do this.

00:17:46.700 --> 00:17:49.690
One reason is to support
multiple attributes.

00:17:49.700 --> 00:17:52.970
It might be that the objects
in your application have

00:17:52.970 --> 00:17:54.700
not just one text attribute,
the content,

00:17:54.710 --> 00:17:56.700
but they may have other text attributes.

00:17:56.700 --> 00:18:01.710
Maybe it's a description of a movie
or maybe the additional attributes

00:18:01.720 --> 00:18:04.700
that you'd like to index as well.

00:18:04.700 --> 00:18:06.690
One example of this is in the Finder.

00:18:07.000 --> 00:18:09.950
When FindMyContent does
indexing in the Finder,

00:18:10.030 --> 00:18:14.700
it indexes not only
the names of the files,

00:18:14.700 --> 00:18:16.700
but also the contents of the files.

00:18:16.700 --> 00:18:19.840
And you'll see in these results
that the top few items there were

00:18:20.160 --> 00:18:21.700
found because of their names.

00:18:21.700 --> 00:18:23.680
The search was for quartz.

00:18:23.720 --> 00:18:25.850
So a couple of files
had quartz in the name,

00:18:25.850 --> 00:18:29.700
and the bulk of the files there
had quartz in the content.

00:18:29.770 --> 00:18:33.130
So there are two indexes and
they get searched simultaneously.

00:18:35.010 --> 00:18:38.790
So creating a search group allows you to
search multiple indexes at the same time.

00:18:38.870 --> 00:18:41.130
Now you might ask why use a search group?

00:18:41.150 --> 00:18:43.050
Why not just search each
index individually and then

00:18:43.050 --> 00:18:44.300
combine the results somehow?

00:18:44.690 --> 00:18:48.210
Well, the reason is--

00:18:48.570 --> 00:18:49.500
Oh, I guess I gave an example.

00:18:49.500 --> 00:18:53.780
Okay, let me give another example
here before I mention that.

00:18:53.780 --> 00:18:57.800
Multiple containers is another reason
why you might create multiple indexes.

00:18:57.860 --> 00:19:01.060
An example here is mail.

00:19:01.170 --> 00:19:05.340
So in mail,
each mailbox is indexed distinctly.

00:19:05.450 --> 00:19:09.910
So when you want to do an entire
content search for all the

00:19:09.910 --> 00:19:14.220
mailboxes in mail at the same time,
it creates a search group in order

00:19:14.220 --> 00:19:14.220
to search multiple mailboxes.

00:19:15.480 --> 00:19:17.490
Now we'll get to the point
about normalizing ranking.

00:19:17.530 --> 00:19:20.780
If you were to do searching on
individual indexes and try to

00:19:20.780 --> 00:19:24.450
combine the results yourself,
the problem is that the relevance

00:19:24.460 --> 00:19:28.710
ranking would only be relative to
the content of each individual index.

00:19:28.850 --> 00:19:31.780
You haven't normalized the
rankings across all the indexes.

00:19:31.860 --> 00:19:37.070
So by creating a search group,
the statistics are normalized

00:19:37.070 --> 00:19:40.990
and then the documents you find
will be the most relevant across

00:19:40.990 --> 00:19:40.990
all the different categories.

00:19:42.320 --> 00:19:44.560
And of course it's possible to create
a search group with just one index

00:19:44.560 --> 00:19:47.310
and that may be a common case as well.

00:19:48.320 --> 00:19:54.610
Okay, so you've got your search group
created and now it's time to send the

00:19:54.710 --> 00:19:55.870
query to SearchKit to do the search.

00:19:58.590 --> 00:20:00.900
But we're not quite ready for that
because we have to determine what

00:20:01.050 --> 00:20:02.910
kind of search we're going to do.

00:20:02.910 --> 00:20:07.890
And the kinds, as I mentioned before,
are ranked, prefix, boolean, required,

00:20:07.930 --> 00:20:09.820
and similarity searching.

00:20:11.130 --> 00:20:12.910
Just to go into a little
more detail about each one,

00:20:12.910 --> 00:20:15.480
Ranked supports kind of a
natural language kind of query.

00:20:15.530 --> 00:20:17.800
So if you're trying to do
something like Apple Help does,

00:20:17.990 --> 00:20:20.270
where you've got a large
number of documents,

00:20:20.350 --> 00:20:23.890
you're trying to find the ones that
are most relevant from a sort of

00:20:23.890 --> 00:20:27.810
English or other language point of view,
then this is the kind of search

00:20:27.850 --> 00:20:29.630
you're going to want to do.

00:20:29.750 --> 00:20:32.980
So the user can ask a question,
they can name a topic,

00:20:32.980 --> 00:20:37.340
or they can provide just related words,
and it'll do a reasonably good

00:20:37.370 --> 00:20:41.000
job of finding the documents
that are most relevant.

00:20:41.860 --> 00:20:43.360
Again,
an example of this is in Apple Help.

00:20:43.380 --> 00:20:47.660
Prefix searching allows you
to do the search as you type,

00:20:47.660 --> 00:20:50.320
so if you want one of those
interfaces where as you type the

00:20:50.400 --> 00:20:53.840
results come down like you'll see
in address book or in mail as well,

00:20:53.840 --> 00:20:56.840
then this is the kind of
searching you'll want to do.

00:20:56.910 --> 00:21:02.410
It's basically just like the previous
one except that it supports prefixes,

00:21:02.470 --> 00:21:05.620
which has the advantage of
supporting searches you type.

00:21:05.630 --> 00:21:09.710
One disadvantage it has is, of course,
you'll get more matches than might

00:21:09.820 --> 00:21:13.270
be intended because even if you type
what seems like a complete word,

00:21:13.270 --> 00:21:16.320
it may be the prefix of some other word,
and so you'll probably get more

00:21:16.320 --> 00:21:18.140
results than you would otherwise.

00:21:20.970 --> 00:21:24.240
An example, this is an address book.

00:21:24.240 --> 00:21:28.170
Boolean searching is just
what you'd think it would be,

00:21:28.180 --> 00:21:28.820
and/or not.

00:21:28.860 --> 00:21:32.370
And you can combine
things with parentheses,

00:21:32.380 --> 00:21:33.400
et cetera.

00:21:33.400 --> 00:21:37.650
And this one's maybe less often used
because most users aren't really familiar

00:21:37.650 --> 00:21:41.900
with doing this except advanced users.

00:21:41.900 --> 00:21:43.240
But it is, in fact, supported in Mail.

00:21:43.350 --> 00:21:46.370
So you'll notice if you type an
ampersand or a vertical bar in Mail,

00:21:46.460 --> 00:21:48.060
it'll do Boolean searching.

00:21:48.060 --> 00:21:51.360
And the way it does this is it looks
at the query that you typed in.

00:21:51.360 --> 00:21:54.720
And if it contains any of those symbols,
then it sends it on as a Boolean search.

00:21:54.720 --> 00:21:57.560
And otherwise,
it sends it on as a ranked-- or, sorry,

00:21:57.560 --> 00:21:58.850
a prefix search.

00:22:04.150 --> 00:22:05.490
And then required
searching is the last type,

00:22:05.610 --> 00:22:09.140
and that allows you to
add pluses and minuses.

00:22:09.140 --> 00:22:12.880
We don't have any examples in any
of the Apple apps of using this,

00:22:13.000 --> 00:22:17.340
but it's a popular search technique
that's used on the internet.

00:22:18.700 --> 00:22:23.000
And then similarity searching
is a different call.

00:22:23.120 --> 00:22:25.500
For that one you provide
the sample documents.

00:22:25.500 --> 00:22:27.890
You don't have any sort
of text query at all.

00:22:27.900 --> 00:22:33.510
And SearchKit returns documents that are
similar to the ones that you provided it.

00:22:36.130 --> 00:22:37.360
Okay,
so now we're ready to send the query.

00:22:37.360 --> 00:22:40.100
We decided, let's say,
to do a ranked search in this case.

00:22:40.100 --> 00:22:43.100
So you send the query to SearchKit.

00:22:43.290 --> 00:22:47.840
SearchKit efficiently searches the
index and then returns the results.

00:22:47.920 --> 00:22:51.070
And then the next step is, of course,
to process those results.

00:22:53.510 --> 00:22:56.950
So the results contain a number of
bits of information that are helpful

00:22:56.960 --> 00:23:00.400
in displaying the results to your user.

00:23:00.400 --> 00:23:02.160
One is the document reference,
which is really the same

00:23:02.160 --> 00:23:03.280
thing you provided it before.

00:23:03.280 --> 00:23:06.960
And it's up to you what kind of a
hierarchy you want to create to make it

00:23:06.990 --> 00:23:09.320
easy to find items in your application.

00:23:09.380 --> 00:23:13.180
In this case, as an example,
I said mail message 21.

00:23:13.180 --> 00:23:15.850
That's one way to identify a document.

00:23:15.850 --> 00:23:20.090
You might have more of a hierarchy,
like which mailbox it's in.

00:23:20.120 --> 00:23:22.000
And you could do it by
subject or something.

00:23:25.050 --> 00:23:27.220
So it's up to you to then
map that back and say,

00:23:27.220 --> 00:23:31.140
OK, these are the documents I want to
display based on that reference.

00:23:32.290 --> 00:23:36.540
The second bit of information it returns
is the relevance ranking and this is of

00:23:36.650 --> 00:23:38.790
course used in displaying your results.

00:23:41.630 --> 00:23:45.610
And the third, in the case that you have
multiple indexes that you

00:23:45.610 --> 00:23:49.340
were searching simultaneously,
then it's going to return a

00:23:49.350 --> 00:23:53.370
reference to which index this
particular result came from.

00:23:53.600 --> 00:23:57.540
The reason for that in the mail
example is you need to know,

00:23:57.640 --> 00:24:00.420
well, I'll just go through all of them.

00:24:00.420 --> 00:24:04.100
The document reference
tells you which message.

00:24:04.100 --> 00:24:06.600
The relevance rank tells you, of course,
the relevance column.

00:24:06.900 --> 00:24:12.060
And the third one I mentioned,
the index reference,

00:24:12.060 --> 00:24:15.100
is to tell you which mailbox it came
from because it has multiple indexes

00:24:15.100 --> 00:24:15.100
that it has to know where it came from.

00:24:18.780 --> 00:24:20.520
So that's basically
searching in three steps.

00:24:20.520 --> 00:24:23.690
And at that point, you've added searching
to your application.

00:24:23.750 --> 00:24:25.670
So how easy is that?

00:24:31.240 --> 00:24:38.240
Now, one of the things that SearchKit is
capable of doing if you use it in

00:24:38.240 --> 00:24:42.040
just the right way is summarization.

00:24:42.040 --> 00:24:47.050
But to make it easy,
we've brought that API up at a

00:24:47.060 --> 00:24:50.040
higher level so that you can directly
do summarization of documents.

00:24:50.040 --> 00:24:50.040
And I'd like to invite David back
up to talk about summarization.

00:24:59.660 --> 00:25:01.140
Hello again.

00:25:01.230 --> 00:25:04.040
Summarization is my
favorite feature of OS X,

00:25:04.050 --> 00:25:09.950
and I'm wondering if I could see a show
of hands how many of you have discovered

00:25:09.950 --> 00:25:14.300
the summary service in-- some of you,
not all of you.

00:25:14.340 --> 00:25:17.070
It'll be my pleasure to show that off.

00:25:19.370 --> 00:25:24.540
It's been,
we've had summarization as the service.

00:25:25.330 --> 00:25:33.900
Since 10.1, and it became better in 10.2,
it'll be essentially the same in Panther.

00:25:34.380 --> 00:25:36.820
Now we've provided this,
you heard me mention

00:25:36.820 --> 00:25:40.590
Find My Content before,
and it's a high level

00:25:40.590 --> 00:25:42.060
interface to SearchKit.

00:25:43.530 --> 00:25:48.080
And it lives in App Services,
which you probably already linked to.

00:25:48.170 --> 00:25:55.640
And you want to find a header called
findbycontent.h to see the syntax.

00:25:55.750 --> 00:25:57.240
There's SearchKit.

00:25:57.350 --> 00:25:59.590
There's FindByContent.

00:26:02.770 --> 00:26:05.390
Find by Content called SearchKit.

00:26:05.390 --> 00:26:09.980
Now to do summarization of text,
it uses a very simple technique

00:26:10.050 --> 00:26:12.490
and it's using the SearchKit.

00:26:12.490 --> 00:26:12.490
It's

00:26:12.760 --> 00:26:14.230
indexing the sentences.

00:26:14.390 --> 00:26:19.090
The document now is a sentence and
it takes that index and it searches

00:26:19.100 --> 00:26:23.740
for the best sentences by using--it
constructs an idea of what is the

00:26:23.850 --> 00:26:29.160
meaningful stuff in this document,
in this thing that we're summarizing.

00:26:29.580 --> 00:26:33.970
Looks for that among the sentences
and gives you back the best ones.

00:26:34.040 --> 00:26:37.670
So you see there it's
indexing and it's searching.

00:26:37.670 --> 00:26:39.000
It's exactly like what Wayne described.

00:26:39.000 --> 00:26:39.000
And here is the demo.

00:26:50.420 --> 00:26:54.830
They should play a little music
while we walk back and forth here.

00:26:54.940 --> 00:26:59.130
I have a weblog document here.

00:26:59.220 --> 00:27:02.230
For an interesting thing
that I found on the web,

00:27:02.230 --> 00:27:06.030
it's an article by a guy named
David Stutz that he wrote as part

00:27:06.030 --> 00:27:09.490
of his farewell to Microsoft when
he quit working there.

00:27:09.540 --> 00:27:11.740
I love it because it has this
great sentence at the end.

00:27:11.740 --> 00:27:16.500
I don't know if you can read it.

00:27:16.500 --> 00:27:16.500
He says, "Stop looking over your
shoulder and invent something."

00:27:18.150 --> 00:27:19.800
But, you know,
when I get this on the web,

00:27:19.800 --> 00:27:22.500
I don't really know if it's
something that I want to read or not.

00:27:22.500 --> 00:27:25.800
It's kind of long.

00:27:25.800 --> 00:27:25.800
So...

00:27:27.370 --> 00:27:34.530
Here in Safari, I'm going to select all,
go to the Safari menu, Services,

00:27:34.770 --> 00:27:36.170
Summarize.

00:27:36.240 --> 00:27:38.170
And there's the summary.

00:27:38.800 --> 00:27:42.630
And it's giving me a
default size summary.

00:27:42.880 --> 00:27:44.080
I can read that.

00:27:44.220 --> 00:27:46.760
Or I can take the slider here.

00:27:47.390 --> 00:27:50.490
I can find the best sentence.

00:27:50.490 --> 00:27:53.820
I can find the paragraph that
contained the best sentence.

00:27:54.100 --> 00:27:56.340
I can zoom up a little bit to get more.

00:27:56.370 --> 00:27:58.570
I can just scrub back and
forth and get more and less.

00:27:58.660 --> 00:28:00.540
I can get the entire text like that.

00:28:00.610 --> 00:28:02.540
Is that cool?

00:28:07.060 --> 00:28:08.900
That's the demo.

00:28:08.900 --> 00:28:11.870
But because it's a service,
a lot of people have never

00:28:11.870 --> 00:28:13.900
even found it at all.

00:28:13.900 --> 00:28:17.200
And this should be in your application.

00:28:19.050 --> 00:28:22.360
By the fact that you're here at all,
I'm guessing that quite a few of you

00:28:22.360 --> 00:28:26.030
have applications that are text-oriented.

00:28:28.070 --> 00:28:29.120
So why would you use this?

00:28:29.330 --> 00:28:32.060
Well, to begin with, it's useful,
as I just described.

00:28:32.170 --> 00:28:34.060
You can make little thumbnails.

00:28:34.110 --> 00:28:38.300
You can make these dynamic summaries
that a user can play around with.

00:28:38.630 --> 00:28:42.770
and generally improve the
usefulness of your application

00:28:42.770 --> 00:28:44.400
and you can advertise it.

00:28:44.440 --> 00:28:46.010
And it's a lot of fun.

00:28:46.060 --> 00:28:48.360
Text is not usually much fun.

00:28:48.360 --> 00:28:54.700
Maybe you envy the graphics people
who can put all this wonderful

00:28:54.700 --> 00:28:58.560
court stuff in their applications.

00:28:58.560 --> 00:28:58.560
You can put summarization with

00:28:59.120 --> 00:29:02.800
dynamic size summaries
and it's quite easy.

00:29:03.010 --> 00:29:10.640
If you're doing a fixed size
summarization like to create

00:29:10.640 --> 00:29:10.640
a set of thumbnails of text,
there's one function that you call.

00:29:10.880 --> 00:29:15.260
You give it a CFString,
you tell it how many sentences you want.

00:29:15.260 --> 00:29:18.800
If you pass zero, it'll figure out a good
number of sentences.

00:29:18.800 --> 00:29:20.430
Gives you back a CFString.

00:29:20.570 --> 00:29:22.250
It's that simple.

00:29:24.250 --> 00:29:28.720
The resizable summarization like
what you saw there is twice as hard.

00:29:28.840 --> 00:29:31.430
There are two functions you have to call.

00:29:31.670 --> 00:29:33.940
There's two others,
but they're not interesting.

00:29:33.940 --> 00:29:37.860
First function does all the hard work,
and you can do that before the

00:29:37.860 --> 00:29:39.220
user even asks for a summary.

00:29:39.220 --> 00:29:40.900
You can do that in the
background on a thread.

00:29:40.920 --> 00:29:44.960
It does all of the analysis
of the text into sentences.

00:29:44.960 --> 00:29:46.900
It does the indexing.

00:29:46.940 --> 00:29:52.470
It gives back an object
that you can keep around.

00:29:52.480 --> 00:29:56.030
And from that object,
you can construct the

00:29:56.250 --> 00:29:58.990
different size summaries very,
very quickly as you saw.

00:29:59.740 --> 00:30:03.170
One thing you should think of, though,
is that that object takes about as

00:30:03.250 --> 00:30:05.530
much memory as the original text.

00:30:08.400 --> 00:30:11.140
How does it work?

00:30:11.190 --> 00:30:18.050
It works by some very simple stuff.

00:30:18.050 --> 00:30:19.150
It's statistics on the
words in the sentences.

00:30:19.150 --> 00:30:19.150
It's just SearchKit searching
like you saw Wayne doing.

00:30:19.490 --> 00:30:23.640
And the key is that it's
analyzing the text into sentences.

00:30:23.710 --> 00:30:28.850
And we do that probably as
well as anything that any

00:30:28.850 --> 00:30:31.040
other code that I've seen.

00:30:31.700 --> 00:30:33.210
We only keep complete sentences.

00:30:33.260 --> 00:30:34.280
We throw out everything else.

00:30:34.360 --> 00:30:38.830
And that makes the summary actually
come out better because it throws away

00:30:39.090 --> 00:30:42.860
Page footers, it throws away little
headings and things.

00:30:43.030 --> 00:30:49.300
So it's only keeping the real
sentences and it does not care

00:30:49.390 --> 00:30:53.760
anything about meaning and grammar.

00:30:53.760 --> 00:31:00.560
And that's summarization.

00:31:00.560 --> 00:31:00.560
Thank you very much.

00:31:05.700 --> 00:31:09.180
Thanks, David.

00:31:09.180 --> 00:31:12.450
So as you've seen,
you can add searching to your

00:31:12.710 --> 00:31:15.900
application fairly easily.

00:31:15.970 --> 00:31:23.230
You can add summarization to
your application fairly easily.

00:31:23.230 --> 00:31:24.380
And both of these APIs are
available in Mac OS X Panther.

00:31:24.380 --> 00:31:24.380
Summarization is actually
available in Jaguar.

00:31:25.950 --> 00:31:29.930
So SearchKit is a powerful
text searching framework that's

00:31:29.930 --> 00:31:31.660
now available in Mac OS X.

00:31:31.660 --> 00:31:35.560
It indexes anything that has text in it,
whether it's in your

00:31:35.560 --> 00:31:37.380
application or on disk.

00:31:37.380 --> 00:31:40.870
It provides powerful, fast searching.

00:31:41.130 --> 00:31:42.940
and Summerization.

00:31:43.030 --> 00:31:45.340
So now the cat's out of the
bag and it's up to you guys.

00:31:49.390 --> 00:31:52.080
So I'd like to point to some other
sessions that may be of interest to you.

00:31:52.100 --> 00:31:56.960
If you use Unicode in your application,
well, of course these sessions

00:31:56.960 --> 00:31:59.600
have already occurred,
but for folks watching DVDs,

00:31:59.600 --> 00:32:01.460
if you'd like to look at these sessions.

00:32:01.460 --> 00:32:04.770
If you're using Unicode
in your application,

00:32:04.800 --> 00:32:07.840
the session number 404,
Unicode for Japanese, Chinese,

00:32:07.840 --> 00:32:09.010
and everything else.

00:32:09.020 --> 00:32:16.130
If you're interested in
searching the address book,

00:32:16.200 --> 00:32:19.130
then you probably want to use
the address book APIs rather

00:32:19.130 --> 00:32:20.790
than the search code APIs.

00:32:20.800 --> 00:32:27.020
And similarly, if you're interested in
providing Apple Help,

00:32:27.060 --> 00:32:29.910
Apple Help uses search code underneath,
but you want to go look at the

00:32:29.910 --> 00:32:32.000
session for Apple Help number 408.

00:32:33.830 --> 00:32:36.900
And if you're interested in
indexing things off the internet,

00:32:36.900 --> 00:32:38.910
then you'll probably want
to look at the session,

00:32:38.910 --> 00:32:42.690
the Internet Technology Session on
the Advanced Foundation URL APIs.

00:32:42.700 --> 00:32:49.820
And of course,
our friend John is the person to contact.

00:32:52.770 --> 00:33:02.320
And for more information,
there is a SearchKit reference

00:33:02.370 --> 00:33:02.830
that's available on the
ADC site for ADC members,

00:33:02.830 --> 00:33:02.830
which is a free membership.

00:33:05.000 --> 00:33:10.790
and as well you can look at the header
files on the Panther CD that you have.

00:33:10.790 --> 00:33:13.800
And if you just go in
System Library Frameworks Core Services,

00:33:13.800 --> 00:33:16.800
you'll see in the frameworks
folder there's a SearchKit folder

00:33:16.800 --> 00:33:18.330
which has all the headers.

00:33:18.360 --> 00:33:25.470
And those are fairly well
documented with comments as well.

00:33:25.470 --> 00:33:25.690
And similarly you can look
at the Find My Content and

00:33:25.690 --> 00:33:25.690
Summarization APIs there.
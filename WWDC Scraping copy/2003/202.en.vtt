WEBVTT

00:00:26.300 --> 00:03:11.600
[Transcript missing]

00:03:12.070 --> 00:03:13.430
So why do we want to talk about Keynote?

00:03:13.560 --> 00:03:16.670
And I think the main reason we
want to do this is because Keynote

00:03:16.670 --> 00:03:19.000
is very platform compelling.

00:03:19.000 --> 00:03:22.120
It's an application that
uses a lot of technologies,

00:03:22.120 --> 00:03:25.840
and at the same time it's really
simple and it's really powerful.

00:03:26.000 --> 00:03:28.000
It's kind of like Mac OS X.

00:03:28.000 --> 00:03:30.000
Mac OS X has got the
power of Unix at the core,

00:03:30.000 --> 00:03:33.110
it's also got a very simple expression
in terms of the Acura user interface,

00:03:33.110 --> 00:03:35.000
and that combination is fantastic.

00:03:35.000 --> 00:03:38.040
One of the reasons Keynote is really
able to do this is because Keynote

00:03:38.040 --> 00:03:41.000
uses the core technology that's
built into the operating system.

00:03:41.000 --> 00:03:43.560
So the Keynote team was able
to really sort of think about

00:03:43.560 --> 00:03:44.960
how do they make a great app?

00:03:45.000 --> 00:03:47.000
How do they make a great app
that adds value to what the user

00:03:47.000 --> 00:03:49.450
is attempting to do with it,
rather than have to worry about

00:03:49.450 --> 00:03:52.560
architecting graphics engines,
architecting 3D transition

00:03:52.560 --> 00:03:54.890
effects using their own engine?

00:03:55.000 --> 00:03:58.380
And that's a very important
point as moving forward,

00:03:58.530 --> 00:04:02.790
as you guys really engage the platform
and develop your own sort of platform

00:04:03.090 --> 00:04:06.580
compelling Mac OS X applications,
is where does the engineering

00:04:06.580 --> 00:04:10.000
that Apple does every year that
we improve the operating system,

00:04:10.030 --> 00:04:14.090
what advantage does that give you in
terms of if you adopt that technology,

00:04:14.120 --> 00:04:17.490
what can you do somewhere else
inside your application to add

00:04:17.520 --> 00:04:20.220
value to your user experience,
because you don't have to worry

00:04:20.220 --> 00:04:23.000
about the dredgery of inventing
your own technology portfolio?

00:04:23.000 --> 00:04:27.100
And then one of the key points is a lot
of the technologies that Keynote uses are

00:04:27.380 --> 00:04:30.000
very important technologies for Apple.

00:04:30.000 --> 00:04:34.220
There are things like Cocoa, Quartz 2D,
our new 2D drawing API, QuickTime,

00:04:34.220 --> 00:04:37.550
our multimedia architecture,
and obviously we spend a lot of

00:04:37.560 --> 00:04:39.000
time talking about OpenGL and how
that's the gateway to access that.

00:04:39.000 --> 00:04:41.000
So the gateway to accessing
the power of the GPU.

00:04:41.000 --> 00:04:44.000
And then also we're going to
talk a little bit about XML.

00:04:44.000 --> 00:04:47.000
XML is a way to contain
document information.

00:04:47.000 --> 00:04:49.890
And then I think the key
point is these applications,

00:04:50.030 --> 00:04:52.900
these technologies are available
for you to use as well.

00:04:53.000 --> 00:04:56.640
And then one of the other things we
wanted to do is essentially enable

00:04:56.640 --> 00:05:00.000
you to learn a little bit from the
development cycle of an application

00:05:00.000 --> 00:05:02.990
that's being brought up with all these
new Mac OS X specific technologies.

00:05:03.000 --> 00:05:06.330
And part of what the Keynote,
this presentation is

00:05:06.330 --> 00:05:08.000
going to communicate,
in addition to which technologies

00:05:08.000 --> 00:05:12.120
are adopted where in the world,
is to actually provide areas where, hey,

00:05:12.130 --> 00:05:15.000
the technology wasn't a perfect fit
and we had to do some working around,

00:05:15.000 --> 00:05:18.000
and we had to do something special
to make it work for application.

00:05:18.000 --> 00:05:22.320
Because many of those cases are
significant for you as developers as

00:05:22.320 --> 00:05:25.000
well as you adopt those technologies.

00:05:25.000 --> 00:05:27.000
So it's my pleasure
to invite Brad Vaughn,

00:05:27.000 --> 00:05:30.000
the Keynote
Engineering Manager at this stage,

00:05:30.000 --> 00:05:33.000
who's going to take you
through the presentation.

00:05:33.000 --> 00:05:35.030
Thank you.

00:05:39.440 --> 00:05:40.740
Thanks, Travis.

00:05:40.870 --> 00:05:41.700
I'm Brad Vaughan.

00:05:41.700 --> 00:05:43.910
I manage the Keynote engineering team.

00:05:43.910 --> 00:05:46.160
And we'll do a quick demo
of the application in case

00:05:46.180 --> 00:05:47.400
you're not familiar with it.

00:05:47.460 --> 00:05:48.200
Actually, can I get a show?

00:05:48.200 --> 00:05:49.400
Who's used the app?

00:05:49.470 --> 00:05:51.900
And I know you've all seen
it because you're at WWDC,

00:05:52.120 --> 00:05:54.270
you're looking at Keynote all day, right?

00:05:54.510 --> 00:05:57.790
But first I want to emphasize the
two things that Travis kind of

00:05:57.990 --> 00:06:02.800
touched on that I want to kind of
make themes for my talk here today.

00:06:02.940 --> 00:06:05.900
Those are the things that make
Keynote great are the technologies

00:06:06.370 --> 00:06:08.030
that are available in OS X.

00:06:08.040 --> 00:06:10.980
And I want to talk about those in depth.

00:06:10.980 --> 00:06:14.870
And the second point
is that in some cases,

00:06:15.120 --> 00:06:19.040
the high-level APIs,
maybe the out-of-the-box functionality

00:06:19.040 --> 00:06:19.980
isn't exactly what you need.

00:06:19.980 --> 00:06:22.820
I'll show you, in fact,
in some cases I'll show you

00:06:22.820 --> 00:06:26.100
code that explains how we
worked around those issues,

00:06:26.100 --> 00:06:29.680
how we extended the available frameworks,
etc.

00:06:29.680 --> 00:06:31.750
So let's take a look at the app.

00:06:34.490 --> 00:06:36.120
So the first thing, this is Keynote.

00:06:36.440 --> 00:06:39.400
First thing you see is this,
what we call the theme chooser.

00:06:39.400 --> 00:06:43.840
You have out of the box 12
beautifully designed themes that

00:06:43.840 --> 00:06:47.240
are created by Apple designers,
each of which contain nicely

00:06:47.240 --> 00:06:51.780
coordinated background graphics,
fonts, colors, shadows, et cetera.

00:06:51.890 --> 00:06:56.100
So let's create a new document
with this leather book theme,

00:06:56.140 --> 00:06:57.370
for example.

00:06:58.470 --> 00:06:59.180
Create the document.

00:06:59.270 --> 00:07:01.940
The first thing you see
is on our main window,

00:07:01.940 --> 00:07:02.790
it's very simple.

00:07:02.940 --> 00:07:05.660
This is Aqua.

00:07:05.810 --> 00:07:09.380
This is standard UI controls
that everybody's used to,

00:07:09.400 --> 00:07:11.740
something that's easy for
users to get into and quickly

00:07:12.230 --> 00:07:14.700
manipulate their own documents.

00:07:14.730 --> 00:07:16.760
Over here we have...

00:07:17.020 --> 00:07:19.140
What's called our slide navigator.

00:07:19.220 --> 00:07:23.260
So I can easily kind of
move around my slides,

00:07:23.310 --> 00:07:24.860
organize my slideshow like this.

00:07:25.020 --> 00:07:26.810
It's very simple.

00:07:27.990 --> 00:07:28.740
Got other views.

00:07:28.740 --> 00:07:34.190
We can edit outlines if you've
got a text-oriented presentation,

00:07:34.190 --> 00:07:35.160
but let's take a look at this one.

00:07:35.160 --> 00:07:37.930
I can change masters.

00:07:38.080 --> 00:07:41.800
Let me show you a feature
we call alignment guides.

00:07:41.820 --> 00:07:43.700
This is a bad example.

00:07:43.700 --> 00:07:44.720
Let me show you here.

00:07:44.720 --> 00:07:46.800
You can see our alignment
guides a little better.

00:07:46.800 --> 00:07:49.720
You notice these little
yellow lines snap.

00:07:51.250 --> 00:07:54.460
These are actually
static alignment guides.

00:07:54.500 --> 00:07:58.330
When I create new objects on my slide,
I get dynamic alignment guides,

00:07:58.380 --> 00:08:03.030
so I can easily manipulate my
graphics and I get a new alignment

00:08:03.130 --> 00:08:05.700
guide so I can center these guys.

00:08:05.840 --> 00:08:08.800
If you do a lot of graphically
rich presentations,

00:08:08.800 --> 00:08:10.100
this is very nice.

00:08:10.650 --> 00:08:12.180
Couple other features.

00:08:12.180 --> 00:08:13.680
Let me see, make another blank.

00:08:13.680 --> 00:08:16.110
Make a new slide and show you our charts.

00:08:16.120 --> 00:08:18.320
So charts and tables are
built into the application.

00:08:18.320 --> 00:08:24.060
You don't have to go out to an external
utility or another app to create a chart.

00:08:24.170 --> 00:08:26.100
So I just click my chart button there.

00:08:26.100 --> 00:08:28.100
I've got a data editor.

00:08:28.100 --> 00:08:32.930
I can go in and edit my data live,
updates my histogram.

00:08:35.230 --> 00:08:38.940
So that's kind of the
gross control of my chart.

00:08:38.940 --> 00:08:42.580
I can move my legend around, resize,
et cetera.

00:08:42.710 --> 00:08:46.090
Over here is my chart inspector.

00:08:46.190 --> 00:08:47.720
So I get kind of more
fine-grained control.

00:08:47.720 --> 00:08:49.620
And I can pick from
several varieties of chart.

00:08:49.680 --> 00:08:50.990
Here's a pie chart.

00:08:51.210 --> 00:08:54.240
As you see, the content that's created
when I create text or I create

00:08:54.320 --> 00:08:58.950
a chart or create a table,
it's all nicely integrated

00:08:58.970 --> 00:09:02.890
with the template,
the style that I've chosen,

00:09:02.890 --> 00:09:04.430
which in this case is LeatherBook.

00:09:04.580 --> 00:09:08.250
So really, it's kind of hard to make
a presentation that's ugly.

00:09:08.370 --> 00:09:10.700
You have to do some work.

00:09:10.780 --> 00:09:14.970
So yeah, so I've got--

00:09:15.480 --> 00:09:19.690
A lot of control over how
I manipulate my chart there.

00:09:19.800 --> 00:09:22.900
So let's take a look at another feature,
tables.

00:09:23.110 --> 00:09:26.270
It's as easy as clicking
the table button.

00:09:26.640 --> 00:09:30.310
Over here, it's automatically switched
to my table inspector.

00:09:30.500 --> 00:09:33.940
Let's make a table of two rows and
I'll put some content in there.

00:09:34.100 --> 00:09:40.000
Let's see, I can't have all caps.

00:09:51.150 --> 00:09:53.260
Try a few shapes in there.

00:09:53.290 --> 00:09:54.980
This will invariably
be in the wrong column,

00:09:54.980 --> 00:09:56.180
but I'll put it in there.

00:09:56.180 --> 00:09:58.430
Researches microscope.

00:09:58.440 --> 00:10:06.810
I missed one.

00:10:13.440 --> 00:10:17.420
As I can resize my columns,
it's very fast.

00:10:17.610 --> 00:10:23.920
The graphics smoothly scale, text wraps.

00:10:24.920 --> 00:10:26.550
And let's do a little build.

00:10:26.680 --> 00:10:31.240
So as I do my actual presentation
as I'm showing the slides,

00:10:31.240 --> 00:10:34.400
I can build the content onto the slide.

00:10:34.460 --> 00:10:36.900
And we've got several options for that.

00:10:36.900 --> 00:10:37.920
So I'll pick my table.

00:10:37.920 --> 00:10:40.800
And for instance,
this is my build inspector.

00:10:40.930 --> 00:10:45.080
I can pick, for instance, a flip build,
we call it.

00:10:45.380 --> 00:10:47.960
And that would-- here's
my little preview.

00:10:49.240 --> 00:10:51.040
This would build the
entire table all at once.

00:10:51.040 --> 00:10:54.820
I can also deliver it, say,
by row or by column.

00:10:54.870 --> 00:10:58.540
So let's take a look at what it looks
like if I build this guy on by column.

00:11:00.900 --> 00:11:03.580
One, two, three columns.

00:11:03.990 --> 00:11:06.260
Very smooth.

00:11:06.410 --> 00:11:10.740
Finally, well,
let me show you next to last,

00:11:10.740 --> 00:11:11.550
our export formats.

00:11:11.560 --> 00:11:15.100
We support QuickTime export,
so you can generate a QuickTime movie

00:11:15.100 --> 00:11:18.140
that contains all the transitions,
3D builds, et cetera,

00:11:18.210 --> 00:11:20.440
ship it off to a user
on another platform,

00:11:20.440 --> 00:11:21.740
and they can share it.

00:11:21.870 --> 00:11:26.110
We also support
PowerPoint export and PDF.

00:11:29.100 --> 00:11:38.180
So, let me show you finally a sampling
of some of our 3D transitions.

00:11:39.710 --> 00:11:46.390
This is a simple kind of fade transition,
a push, a move.

00:11:46.500 --> 00:11:48.980
These are all--this is the
set of 2D transitions that

00:11:48.980 --> 00:11:54.050
we provide out of the box,
wipe transition and a pivot.

00:11:54.730 --> 00:11:57.060
Finally, a drop,
so you drop one slide over the other.

00:11:57.200 --> 00:12:02.640
Getting into the 3D transitions,
that's called Twirl.

00:12:02.640 --> 00:12:05.040
This is a large mosaic.

00:12:05.060 --> 00:12:06.940
And most of these
transitions you can control,

00:12:06.940 --> 00:12:09.770
no, all of the transitions,
you can control their speed,

00:12:09.780 --> 00:12:11.960
several you can control their direction.

00:12:12.010 --> 00:12:15.090
Perhaps they come from the center,
they move out or in.

00:12:15.240 --> 00:12:18.690
There's a flip, a 3D flip.

00:12:20.200 --> 00:12:24.600
horizontal 3D flip, and finally theCUBE,
everybody's favorite.

00:12:24.600 --> 00:12:29.030
So that's Keynote.

00:12:34.100 --> 00:12:36.860
We want to talk about the technologies,
the things that make Keynote great.

00:12:36.890 --> 00:12:38.900
First,
we'll talk about application frameworks.

00:12:38.900 --> 00:12:40.100
Keynote built on Cocoa.

00:12:40.100 --> 00:12:44.100
We'll talk about why we think Cocoa is
a great basis for your applications.

00:12:44.100 --> 00:12:49.700
One of the things Cocoa provides is
very simple high-level access to the

00:12:49.700 --> 00:12:52.920
text technologies that make OS X great.

00:12:53.580 --> 00:12:56.100
Things you get from Atsui, Quartz, etc.

00:12:56.100 --> 00:12:57.640
We'll talk about Quartz.

00:12:57.640 --> 00:13:01.650
Keynote really excels at creating
graphically rich presentations,

00:13:01.650 --> 00:13:04.100
and we get all that power from Quartz.

00:13:04.100 --> 00:13:09.230
I'll show you some code that we
use to manage images in Quartz.

00:13:09.910 --> 00:13:12.800
Obviously, OpenGL,
the examples I just showed you.

00:13:13.000 --> 00:13:17.400
Great 2D and 3D effects
that we use OpenGL.

00:13:17.450 --> 00:13:20.400
We'll talk about some of the
kit support for OpenGL as well.

00:13:20.520 --> 00:13:24.060
Rich media support that
you get from QuickTime and,

00:13:24.060 --> 00:13:27.910
you know, it's not just about
playing movies on slides.

00:13:28.660 --> 00:13:34.100
and Chris Lester,
are the founders of QuickTime.

00:13:34.370 --> 00:13:36.940
Finally, we use XML as our file format.

00:13:37.050 --> 00:13:38.380
Really excited about that.

00:13:38.450 --> 00:13:41.940
There's been some community
support for our format,

00:13:41.940 --> 00:13:46.740
and I'll talk about the operating
system support that's there for XML.

00:13:47.470 --> 00:13:49.790
So first, application frameworks.

00:13:50.430 --> 00:13:57.180
When we chose, when we sat down to decide
how we're gonna start Keynote,

00:13:57.230 --> 00:14:01.720
the main thing we wanted to do was kind
of emphasize the power that's in OS X,

00:14:01.910 --> 00:14:05.730
the graphical, the power behind the
graphical technologies that

00:14:05.730 --> 00:14:07.580
are in there like OpenGL,
Quark, Time and Quartz.

00:14:07.750 --> 00:14:11.820
So we wanted first-class integration with
those technologies with this framework.

00:14:11.820 --> 00:14:14.100
We choose a high-level framework,
we wanna be able to get the maximum

00:14:14.430 --> 00:14:16.190
out of each of these technologies.

00:14:16.330 --> 00:14:20.840
We wanna be able to grab
powerful components from the kit.

00:14:20.910 --> 00:14:25.380
Okay, so we wanna be able to, you know,
use a lot of these things out of the box.

00:14:25.400 --> 00:14:28.600
We don't have to reinvent the wheel
for things like UI components,

00:14:28.630 --> 00:14:29.460
et cetera.

00:14:29.510 --> 00:14:33.620
But we want the components to be flexible
and extendable enough that we can,

00:14:33.690 --> 00:14:38.240
you know, tweak the parameters,
tweak a few things,

00:14:38.330 --> 00:14:41.020
get the look and feel,
the capabilities we want without

00:14:41.020 --> 00:14:42.160
having to extend everything.

00:14:42.230 --> 00:14:46.280
But we wanna be able to extend it and
override certain behaviors if we want.

00:14:46.280 --> 00:14:47.540
to

00:14:47.910 --> 00:14:50.130
We want great performance.

00:14:50.270 --> 00:14:54.220
We don't want layers and layers
of software between us and the

00:14:54.220 --> 00:14:58.800
application and the core components,
the core technologies in

00:14:58.850 --> 00:15:00.500
OS X that we want to use.

00:15:00.500 --> 00:15:01.420
For instance, OpenGL.

00:15:01.430 --> 00:15:04.610
We want to make sure we have
very fast access to OpenGL.

00:15:05.300 --> 00:15:25.830
We want to make sure we have
very fast access to OpenGL.

00:15:27.600 --> 00:15:31.560
High-level access to, again,
the graphic capabilities,

00:15:31.640 --> 00:15:33.800
the graphic technologies
that come with OS X.

00:15:33.800 --> 00:15:38.760
Quartz, OpenGL and QuickTime.

00:15:40.110 --> 00:15:44.230
With Cocoa, you get the standard flexible
UI controls that everybody's used

00:15:44.230 --> 00:15:48.440
to in the OS X operating system,
the Aqua user interface.

00:15:48.440 --> 00:15:53.830
And as Aqua progresses,
as new releases of Cocoa come out,

00:15:54.020 --> 00:15:56.560
we're kind of reaping
the benefits of those.

00:15:56.600 --> 00:15:58.480
If you saw the Scott Forstall
talk yesterday,

00:15:58.500 --> 00:16:00.550
the tab view is improving.

00:16:00.560 --> 00:16:03.100
The switch view is improving.

00:16:03.100 --> 00:16:04.900
So we're going to get those benefits.

00:16:04.900 --> 00:16:12.160
NS Image with Cocoa gives you access to
not only native formats that NS Image

00:16:12.400 --> 00:16:55.300
[Transcript missing]

00:16:55.710 --> 00:17:01.380
Koko provides macros and classes that
make it very easy to localize your app,

00:17:01.530 --> 00:17:04.500
provide your app for multiple languages.

00:17:04.520 --> 00:17:06.300
And with Koko, you're using Mako.

00:17:06.440 --> 00:17:11.220
You've got great compatibility with
the runtime throughout the system.

00:17:11.240 --> 00:17:15.780
And you've got NSBundle,
the ability to load running code,

00:17:15.880 --> 00:17:18.300
executable code,
and resources into your app.

00:17:18.300 --> 00:17:23.300
And in Keynote, all our transitions,
all our builds, our 3D builds,

00:17:23.300 --> 00:17:27.600
I think our exporters and our
inspectors are all loadable bundles.

00:17:27.600 --> 00:17:31.260
So in theory,
people can load new ones in.

00:17:32.400 --> 00:17:34.820
For ease of development,
we love Objective-C.

00:17:34.970 --> 00:17:39.500
Objective-C, an object-oriented language,
very, very powerful dynamic runtime.

00:17:39.560 --> 00:17:40.380
But it's simple enough.

00:17:40.510 --> 00:17:49.460
You can take-- it's got a small
surface area of specific features

00:17:49.500 --> 00:17:51.000
that are in the language.

00:17:51.010 --> 00:17:53.800
So you take a Java programmer,
an ANSI C programmer,

00:17:53.800 --> 00:17:57.530
it's a very small learning curve to
bring them up to speed on Objective-C.

00:17:57.760 --> 00:18:01.100
And this, as project builders,
should just say tools, right?

00:18:01.170 --> 00:18:03.500
Because it's not just project builder.

00:18:03.500 --> 00:18:04.530
Now it's Xcode.

00:18:04.700 --> 00:18:07.290
I'm looking forward to
using Xcode quite a bit.

00:18:07.390 --> 00:18:08.990
Project builder,
a full-featured integrated

00:18:08.990 --> 00:18:13.190
development environment with
features like indexed code,

00:18:13.260 --> 00:18:20.400
syntax, coloring, documentation built in,
source code management integration.

00:18:20.410 --> 00:18:24.570
And the other tools like, you know,
malloc debug, sampler,

00:18:25.040 --> 00:18:28.360
things that let you ship a
high-quality application.

00:18:32.450 --> 00:18:34.920
So why we chose Cocoa.

00:18:34.960 --> 00:18:38.290
First class integration with the
graphical technologies that we really

00:18:38.290 --> 00:18:43.360
wanted to highlight in OS X really was
gonna make Keynote a great application.

00:18:43.420 --> 00:18:46.020
Powerful components, things you can grab,
use out of the box,

00:18:46.080 --> 00:18:50.280
they're flexible enough that you
can tweak them to your desires

00:18:50.350 --> 00:18:54.400
and extendable enough that you
can tweak them even further.

00:18:54.540 --> 00:18:58.700
Best of breed tools like
Project Builder and now Xcode.

00:18:59.350 --> 00:19:02.990
So let's talk about specific
features that Cocoa provides,

00:19:02.990 --> 00:19:04.420
like Cocoa Text.

00:19:04.610 --> 00:19:07.810
Well, with OS X,
you really get capabilities from

00:19:07.810 --> 00:19:10.440
several layers of the operating system.

00:19:10.440 --> 00:19:15.170
In Quartz, you know, anti-alias text,
something we've all come to expect now.

00:19:15.500 --> 00:19:17.970
AtSuite,
Apple's type system for Unicode imaging,

00:19:18.160 --> 00:19:22.500
provides Unicode,
multiple input handlers, styled text,

00:19:22.540 --> 00:19:26.610
and the typographic features that
I'll display in a minute here.

00:19:26.940 --> 00:19:31.130
And what you get from Cocoa is
just some of the application-level

00:19:31.270 --> 00:19:33.550
features like undo,
key bindings.

00:19:33.620 --> 00:19:36.510
You have things we don't
use so much in Keynote,

00:19:36.510 --> 00:19:39.640
like formatted text input.

00:19:40.370 --> 00:19:47.110
So let's look very quickly at some
of the text capabilities in Keynote.

00:19:50.340 --> 00:19:56.210
Starting with a blank slide, just click,
create a new text object.

00:20:00.950 --> 00:20:03.000
Bring up the font panel.

00:20:03.030 --> 00:20:05.220
You've got access to all the
fonts available in the system,

00:20:05.220 --> 00:20:08.450
TrueType, PostScript, et cetera.

00:20:16.000 --> 00:20:19.590
I don't have my slider,
so I'm not showing exactly

00:20:19.650 --> 00:20:25.160
how smoothly it can resize,
but you know.

00:20:25.240 --> 00:20:28.790
It's anti-aliased, razor sharp,
looks great.

00:20:30.860 --> 00:20:35.790
Let me go to my text
inspector here in Keynote.

00:20:35.800 --> 00:20:38.580
So I have control over
simple things like alignment,

00:20:38.610 --> 00:20:40.070
color,

00:20:40.210 --> 00:20:43.500
I also can manipulate
the character spacing.

00:20:43.630 --> 00:20:47.600
This is all built into Cocoa,
no code required here.

00:20:47.600 --> 00:20:53.060
And you have fine control over character
spacing within a certain range of text.

00:20:53.060 --> 00:20:55.750
And designers love this capability.

00:20:56.640 --> 00:20:59.280
So if I go to my next slide,
I've got some multi-line text.

00:20:59.280 --> 00:21:04.080
I can control the line spacing,
negative line spacing.

00:21:05.350 --> 00:21:08.600
And I want to talk about ligatures.

00:21:08.660 --> 00:21:14.300
So this is an example of a ligature,
which is just an elegant way of combining

00:21:14.300 --> 00:21:16.280
characters that's built into these fonts.

00:21:16.430 --> 00:21:18.160
This is the Zapfino font.

00:21:18.200 --> 00:21:20.530
So T and H are actually
-- it's one glyph,

00:21:20.630 --> 00:21:21.520
one character glyph.

00:21:21.530 --> 00:21:24.370
When I type T-H, it combines it.

00:21:26.310 --> 00:21:28.960
But you can also
manipulate those ligatures.

00:21:29.020 --> 00:21:30.540
And this is built into Cocoa.

00:21:30.610 --> 00:21:33.940
So if I turn off the
ligature on that combination,

00:21:36.100 --> 00:21:58.700
[Transcript missing]

00:22:00.860 --> 00:22:04.240
So again,
advanced features with CocoaText,

00:22:04.240 --> 00:22:08.200
kerning character spacing,
Unicode character sets.

00:22:08.250 --> 00:22:12.230
So we've got some kanji here in
the really nice Hidagino font.

00:22:12.650 --> 00:22:14.490
Ligatures.

00:22:16.240 --> 00:22:18.960
There was one feature
we needed in Keynote,

00:22:18.960 --> 00:22:23.270
and essentially you've already seen it,
that wasn't supported in Cocoa Text,

00:22:23.360 --> 00:22:26.050
and that's this kind of
cascaded style sheet.

00:22:26.160 --> 00:22:29.320
We wanted to be able to
let the user pick a theme,

00:22:29.320 --> 00:22:32.920
pick a master slide,
and it's got a certain design.

00:22:33.220 --> 00:22:35.100
They get those design attributes.

00:22:35.170 --> 00:22:38.060
They make a change,
then they may pick another theme.

00:22:38.110 --> 00:22:40.470
We want to preserve the style
changes that the user made.

00:22:40.510 --> 00:22:42.100
Let me show you how that would work.

00:22:42.100 --> 00:22:47.090
So the user creates a new show,
and they use the white theme.

00:22:47.110 --> 00:22:48.070
Type a little text.

00:22:48.070 --> 00:22:52.000
Make an attribute change.

00:22:52.000 --> 00:22:52.000
So they've gone from...

00:22:52.260 --> 00:23:15.380
and others have been
working on the application.

00:23:15.460 --> 00:23:15.490
We've changed the background,
added graphics, changed the font,

00:23:15.490 --> 00:23:15.490
added a little shadow in this case,
but we've preserved the attribute

00:23:15.490 --> 00:23:15.490
changes that the user made,
so we've still got bolded

00:23:15.490 --> 00:23:15.490
text in the last word.

00:23:16.320 --> 00:23:19.400
Another capability this gives the
user is they can kind of revert.

00:23:19.540 --> 00:23:22.100
All additional changes,
all overrides that they've

00:23:22.130 --> 00:23:23.720
made can be reverted out.

00:23:23.890 --> 00:23:25.680
We'll just go back to
the standard style sheet.

00:23:25.770 --> 00:23:29.860
So continuing from the last example,
here we are on the crayon theme.

00:23:29.900 --> 00:23:34.310
The user goes to menu and says,
"Reapply master to selection."

00:23:36.140 --> 00:23:37.150
and the overrides go away.

00:23:37.350 --> 00:23:40.500
So we wanna go back to the
standard master or cascaded

00:23:40.580 --> 00:23:42.660
style sheet set of attributes.

00:23:42.680 --> 00:23:47.130
Cocoa Text doesn't really
support this and here's a...

00:23:48.000 --> 00:24:33.400
[Transcript missing]

00:24:35.110 --> 00:24:36.290
That wasn't going to quite do it for us.

00:24:36.420 --> 00:24:39.650
That's a flattened set of attributes.

00:24:39.800 --> 00:24:42.800
We needed to be able to say which
attributes existed on the master,

00:24:42.800 --> 00:24:44.990
which ones were created by the user.

00:24:45.000 --> 00:24:48.070
So how we did this,
we extended the NSTextStorage

00:24:48.180 --> 00:24:49.980
by creating a subclass.

00:24:50.010 --> 00:24:53.000
NSTextStorage is called
a semi-concrete class.

00:24:53.000 --> 00:24:54.990
When you make a subclass
of NSTextStorage,

00:24:55.200 --> 00:24:58.000
you're expected to provide
your own data storage.

00:24:58.000 --> 00:24:59.500
In this case, it's on the bottom.

00:24:59.500 --> 00:25:01.810
It's the attributed string,
which is just an NSMutable

00:25:01.850 --> 00:25:05.000
attributed string that contains all
the attributes that the user sees,

00:25:05.010 --> 00:25:08.000
both inherited from the style
sheet and added by the user.

00:25:08.000 --> 00:25:11.960
What we also added was this
master attributes dictionary.

00:25:12.020 --> 00:25:15.740
This is the set of attributes
that existed in the dictionary

00:25:15.740 --> 00:25:18.000
when the user created this text.

00:25:18.060 --> 00:25:22.410
So it would be the last example,
you know, the Gil Sands font at

00:25:22.410 --> 00:25:24.530
size 14 or something.

00:25:24.950 --> 00:25:27.480
When you create a
subclass of NSTextStorage,

00:25:27.510 --> 00:25:30.830
again, it's the semi-concrete class,
you have to provide the data storage,

00:25:31.020 --> 00:25:32.900
you have to override certain methods.

00:25:32.970 --> 00:25:35.450
This is the list of methods
you have to override.

00:25:35.570 --> 00:25:39.300
String returns just a plain
string with no attributes.

00:25:39.380 --> 00:25:45.900
Attributes at index effective range
tells me that at index 4 I've got,

00:25:45.900 --> 00:25:49.700
or at index 7 in the last example,
I've got 10 characters

00:25:49.830 --> 00:25:51.550
of text that are bold.

00:25:51.690 --> 00:25:55.610
Replace characters and range is
what happens when the user types or

00:25:55.630 --> 00:25:59.440
and text is pasted in,
set attributes and arrange, again,

00:25:59.440 --> 00:26:03.710
which I actually covered last time
on the last slide was just applying

00:26:03.910 --> 00:26:06.840
attributes to a range of characters.

00:26:06.840 --> 00:26:10.460
What we added in our subclass,
we have an initializer that

00:26:10.490 --> 00:26:14.680
just takes the set of styles
that exist on the master slide.

00:26:14.680 --> 00:26:19.930
We have a method that returns
whether an override exists,

00:26:19.950 --> 00:26:23.760
excuse me,
so that is used for menu enabling,

00:26:23.770 --> 00:26:24.960
or menu validation.

00:26:24.960 --> 00:26:26.220
Does this menu need to be turned on?

00:26:26.220 --> 00:26:27.220
Is there an override?

00:26:27.220 --> 00:26:31.260
Can the user revert this string?

00:26:31.260 --> 00:26:33.870
Reapply master attributes,
which is what happens when

00:26:33.930 --> 00:26:35.320
the user clicks that menu.

00:26:35.320 --> 00:26:38.290
That's basically the way
that's implemented is we take

00:26:38.290 --> 00:26:41.520
the dictionary that exists,
we apply it to the entire

00:26:41.520 --> 00:26:43.060
range of the string.

00:26:43.060 --> 00:26:47.840
Set master attributes is kind
of the money method here.

00:26:47.840 --> 00:26:52.160
What this guy does is he looks
at the existing set of master

00:26:52.160 --> 00:26:56.320
attributes in the string,
compares them to the new set.

00:26:56.320 --> 00:27:01.710
This guy is called when the
user changes the master slide or

00:27:01.710 --> 00:27:04.620
changes the cascaded style sheet.

00:27:04.660 --> 00:27:06.760
We say, "Okay.

00:27:07.590 --> 00:27:12.930
For each run of text,
for each effective range of styled text,

00:27:13.770 --> 00:27:15.830
Does an attribute exist
in the old master?

00:27:15.900 --> 00:27:19.200
If so, let's replace it with the
attributes in the new master.

00:27:19.200 --> 00:27:21.760
That preserves the stuff
that's been changed,

00:27:21.760 --> 00:27:25.430
the stuff that didn't exist in
the old master attribute list.

00:27:27.260 --> 00:27:31.400
So CocoaText,
you have a great set of features,

00:27:31.450 --> 00:27:34.060
typography, Unicode text, out of the box.

00:27:34.060 --> 00:27:36.920
It just works with Cocoa and
the set of kind of application

00:27:36.920 --> 00:27:38.580
level undo and key bindings.

00:27:38.580 --> 00:27:43.410
Minimal amount of coding
to get at those features.

00:27:43.540 --> 00:27:45.700
And they're all supported in the UI.

00:27:45.700 --> 00:27:51.250
You know, the standard menus for cut,
paste, manage kerning, ligatures, fonts,

00:27:51.300 --> 00:27:54.970
et cetera, just work out of the box.

00:27:55.360 --> 00:27:58.500
But as we all know,
after watching some of these slides,

00:27:58.550 --> 00:28:02.040
great presentations are
not built on text alone.

00:28:03.150 --> 00:28:07.020
All the graphical features you get
in Keynote come from Quartz 2D.

00:28:07.060 --> 00:28:09.410
Very quick overview of what
you get with Quartz 2D.

00:28:09.420 --> 00:28:15.300
Path-based drawing, vector-based drawing,
so we draw our shapes with paths and

00:28:15.300 --> 00:28:17.230
they resize perfectly and all that.

00:28:17.390 --> 00:28:19.780
Control of stroke and dash settings.

00:28:19.780 --> 00:28:23.840
Bitmap image rendering.

00:28:23.860 --> 00:28:25.530
It's based on PDF.

00:28:25.610 --> 00:28:30.190
You can actually have control over
drawing PDF documents or sections

00:28:30.310 --> 00:28:32.660
of PDF documents or PDF clip art.

00:28:33.000 --> 00:28:40.100
[Transcript missing]

00:28:40.210 --> 00:28:44.240
Translation, scaling, shearing,
et cetera.

00:28:44.240 --> 00:28:48.180
And transparency, awesome alpha blending,
which again I'll show.

00:28:48.460 --> 00:28:50.180
Let's take a look.

00:28:56.840 --> 00:29:00.030
There's a blank slate.

00:29:00.090 --> 00:29:02.680
I'll just throw a couple shapes on.

00:29:03.690 --> 00:29:08.600
And these guys come
on with an image fill.

00:29:08.660 --> 00:29:11.200
Let me look at my graphics inspector.

00:29:11.380 --> 00:29:15.110
So I can change to say a gradient fill.

00:29:15.700 --> 00:29:17.340
- This is supported by Quartz.

00:29:17.340 --> 00:29:24.910
I can change my colors, change the angle,
make it semi-opaque,

00:29:29.400 --> 00:29:31.960
It's very fast.

00:29:31.960 --> 00:29:37.140
Out of stroke, various dash styles.

00:29:39.900 --> 00:29:41.900
"Expect opacity here.

00:29:41.900 --> 00:29:46.420
Changes the order."

00:29:47.760 --> 00:29:49.820
And here's some images.

00:29:49.820 --> 00:29:54.610
So, these images are very high quality,
but they rotate very fast.

00:29:56.500 --> 00:30:02.500
[Transcript missing]

00:30:10.070 --> 00:30:12.830
So again,
Quartz features path-based drawing,

00:30:12.990 --> 00:30:13.720
PDF drawing.

00:30:13.900 --> 00:30:20.410
We've got a shape with a standard color
and stroke and an image where now I've

00:30:20.460 --> 00:30:23.900
added a gradient fill and a shadow.

00:30:24.330 --> 00:30:27.170
The thing I didn't mention about shadows.

00:30:27.800 --> 00:30:31.050
What we wanted in Keynote was
shadows that are a lot like what

00:30:31.090 --> 00:30:36.400
you get from the menu in OS X or the
Windows and didn't really have that.

00:30:36.400 --> 00:30:39.690
We had to actually add
some code to do that.

00:30:39.790 --> 00:30:43.700
The good news is in Panther,
the shadow APIs are available,

00:30:43.700 --> 00:30:47.540
so you guys hopefully won't have
to do quite as much as we did.

00:30:47.640 --> 00:30:49.090
Again, back to the features.

00:30:49.160 --> 00:30:51.180
Anti-alias text.

00:30:51.400 --> 00:30:56.670
Image drawing, alpha blending,
and great performance.

00:30:58.500 --> 00:31:02.240
Quartz 2D,
you have a PDF-based imaging model,

00:31:02.240 --> 00:31:06.420
the same imaging model that
sends information to the display,

00:31:06.420 --> 00:31:09.900
that draws what you see,
is what's sent to your printer drivers

00:31:09.970 --> 00:31:12.190
for raster and postscript output.

00:31:13.120 --> 00:31:17.840
ColorSync, color syncing both to the
display and to your output device

00:31:17.980 --> 00:31:19.950
and on compatible hardware.

00:31:20.020 --> 00:31:25.690
Quartz Extreme for GPU accelerated
window compositing.

00:31:26.880 --> 00:31:30.430
Now, what do we need in Keynote
that we didn't get from Quartz?

00:31:30.740 --> 00:31:34.040
We wanted professional
quality image manipulation.

00:31:34.210 --> 00:31:38.640
As you may know, if you heard the Keynote
at Macworld San Francisco,

00:31:38.720 --> 00:31:41.240
it was designed for Steve Jobs,
and he's using these very,

00:31:41.240 --> 00:31:46.610
very high quality images, multi-megabyte,
and we can't sit around and wait while

00:31:46.610 --> 00:31:48.860
we're rotating and resizing these images.

00:31:48.860 --> 00:31:53.200
So manipulation has to be fast,
but we also have to quickly move.

00:31:53.200 --> 00:31:54.510
It's a presentation app.

00:31:54.520 --> 00:31:57.710
We have to quickly go back
and forth through slides.

00:31:58.000 --> 00:32:03.430
Well, with Quartz,
high quality resize is built in.

00:32:03.500 --> 00:32:05.740
Here's an example of
how you do it in Cocoa.

00:32:05.740 --> 00:32:09.360
You just grab a graphics context
and set high image interpolation,

00:32:09.470 --> 00:32:14.240
set NSImage interpolation high,
and Quartz goes off and does

00:32:14.450 --> 00:32:18.570
more complicated scaling.

00:32:19.710 --> 00:32:22.280
If you're not using Cocoa,
you can still do this in Core Graphics.

00:32:22.390 --> 00:32:25.600
Grab the graphics port,
use a different flag.

00:32:25.740 --> 00:32:27.590
It's available.

00:32:30.290 --> 00:32:33.920
Now, talking about image manipulation,
when a user rotates or

00:32:33.920 --> 00:32:37.910
moves an image around,
we want the interaction to be very,

00:32:37.910 --> 00:32:38.850
very fast.

00:32:38.900 --> 00:32:42.900
So what we do is we cache a smaller
representation of that image.

00:32:42.900 --> 00:32:47.200
So if the user is using
a 50 megabyte TIFF file,

00:32:47.260 --> 00:32:50.870
we'll actually save a smaller
version if the user is resizing,

00:32:50.870 --> 00:32:51.850
for instance.

00:32:51.990 --> 00:32:54.000
This is a kind of abbreviated UML.

00:32:54.000 --> 00:32:57.170
Our image view is what the user
actually sees and manipulates on

00:32:57.170 --> 00:32:59.500
what we call the slide canvas.

00:32:59.500 --> 00:33:01.490
The image model,

00:33:02.220 --> 00:33:05.800
In this instance,
the instance variable is called myImage.

00:33:05.800 --> 00:33:08.200
That's kind of the canonical
image that the user brought in

00:33:08.200 --> 00:33:11.300
from the finder or they pasted.

00:33:11.380 --> 00:33:13.430
So we're keeping track
of the original image,

00:33:13.430 --> 00:33:15.100
but in many cases,
and I'll show you where

00:33:15.100 --> 00:33:17.240
we create this guy,
we have a cached image that

00:33:17.290 --> 00:33:20.590
we use to render instead,
and it's much faster.

00:33:21.910 --> 00:33:25.240
So on our canvas,
if the user mouses down,

00:33:25.240 --> 00:33:28.600
we determine whether an
image was selected and tell

00:33:28.600 --> 00:33:30.980
it to dynamically resize.

00:33:31.010 --> 00:33:34.120
Within that method,
when the image view is

00:33:34.190 --> 00:33:36.440
told to dynamically resize,
it determines whether the

00:33:36.440 --> 00:33:38.990
model has changed enough that
it's actually worth doing.

00:33:39.030 --> 00:33:44.200
So we say if this image is,
say in this case, 90% scaled,

00:33:44.200 --> 00:33:45.390
then we'll create a cached image.

00:33:45.400 --> 00:33:49.460
We'll just make a copy, sock it away,
on subsequent renders,

00:33:49.460 --> 00:33:52.910
we'll just render the cached image,
and this actually makes a big

00:33:52.910 --> 00:33:56.670
difference in interaction performance.

00:33:57.170 --> 00:33:58.250
Another challenge.

00:33:58.370 --> 00:34:03.530
So when creating multi-page PDF,
as you see in this example,

00:34:03.650 --> 00:34:07.000
all these slides use,
I think with the exception

00:34:07.100 --> 00:34:09.100
of the first one,
they all use the same background image.

00:34:09.100 --> 00:34:11.900
The last two use the
same piece of clip art,

00:34:11.990 --> 00:34:13.300
this calendar.

00:34:13.300 --> 00:34:16.590
The one and the eight are actually text,
so it looks pretty good.

00:34:16.650 --> 00:34:21.120
The charts in this
example use an image fill,

00:34:21.120 --> 00:34:23.620
so it's kind of a repeating image.

00:34:23.930 --> 00:34:26.970
When we generate PDF,
we want to make sure that we're not

00:34:26.970 --> 00:34:31.070
sending these images out to PDF,
to our PDF stream multiple times.

00:34:31.140 --> 00:34:32.100
How do we do that?

00:34:32.500 --> 00:34:35.470
Well, PDF supports this optimization.

00:34:35.590 --> 00:34:38.930
You write the image once and
then use this X object reference,

00:34:38.930 --> 00:34:42.090
and PDF will go back and read
it out of the original stream.

00:34:42.340 --> 00:34:45.140
CG ImageRef supports this capability.

00:34:45.140 --> 00:34:46.340
Let me show you how we create it.

00:34:46.340 --> 00:34:49.830
create these CG images.

00:34:50.480 --> 00:34:52.290
Again, back to our UMM model.

00:34:52.450 --> 00:34:55.950
The image model contains the original
NS image that we've instantiated

00:34:55.950 --> 00:34:59.160
from the finder or pulled in
off the clipboard or whatever.

00:34:59.360 --> 00:35:01.620
We also keep track of a CG image ref.

00:35:01.660 --> 00:35:03.320
It uses the same data.

00:35:03.350 --> 00:35:06.710
As long as we use that
CG image ref to render,

00:35:06.840 --> 00:35:09.900
We'll get this optimization
in our PDF output.

00:35:10.020 --> 00:35:14.400
So to create a CG image ref,
you have to create a CG data provider.

00:35:14.470 --> 00:35:15.180
So you can create it.

00:35:15.200 --> 00:35:18.860
If you've got an image,
if you have an NS bitmap image rep,

00:35:18.900 --> 00:35:21.220
which image rep in this example is.

00:35:21.400 --> 00:35:24.160
Image rep is an NS bitmap image rep.

00:35:24.250 --> 00:35:28.830
We just pull the bitmap data out,
tell the data provider what the

00:35:28.840 --> 00:35:31.890
depth is and how big the image is,
create that provider,

00:35:31.900 --> 00:35:34.390
hand that off to CG image create.

00:35:34.510 --> 00:35:36.570
CG image create, again,
you tell it how big the

00:35:36.570 --> 00:35:40.960
image is going to be,
how big you want to render it.

00:35:41.250 --> 00:35:45.000
The depth, a couple other flags that
control the color space.

00:35:45.000 --> 00:35:49.190
These are kind of the default flags here,
what the alpha value is.

00:35:49.270 --> 00:35:54.640
And when you want to draw the CG image,
the CG image variable that I've got here,

00:35:54.640 --> 00:35:58.650
which is a CG image ref, to draw that,
you just draw it to the graphics port,

00:35:58.690 --> 00:36:01.480
the current graphics context,
and tell it how big you want to draw.

00:36:01.760 --> 00:36:04.940
As long as you draw that
to your PDF output context,

00:36:04.980 --> 00:36:07.490
you're going to get
this optimized output.

00:36:08.570 --> 00:36:14.620
So, to summarize Quartz:
rich 2D capabilities, path-based drawing,

00:36:14.620 --> 00:36:17.410
PDF model, all available to you.

00:36:17.520 --> 00:36:20.590
Layered APIs, if it turns out you're
using Cocoa or whatever,

00:36:20.810 --> 00:36:26.030
Java, and the APIs aren't available,
you've always got core graphics,

00:36:26.030 --> 00:36:29.560
which is the Quartz kind
of standard layer of APIs.

00:36:29.670 --> 00:36:33.800
And phenomenal performance
with Quartz Extreme.

00:36:34.820 --> 00:36:39.690
Now, that was one of our 3D transitions.

00:36:39.770 --> 00:36:44.780
All the editing on a Keynote
slide canvas is Quartz,

00:36:44.780 --> 00:36:50.410
but how do we get this core graphics,
these Quartz objects,

00:36:50.480 --> 00:36:55.030
up to the screen in OpenGL so we can
do these kind of cinematic effects?

00:36:55.350 --> 00:36:57.720
So there's, again, the 3D effect.

00:36:57.720 --> 00:37:01.200
We've also got the 2D effects,
so there's a drop.

00:37:01.510 --> 00:37:07.700
And we can not only apply these
effects to a slide transition

00:37:07.700 --> 00:37:10.220
from one slide to another,
but also objects that

00:37:10.220 --> 00:37:12.200
are going onto the slide.

00:37:12.210 --> 00:37:17.200
So there's a 3D text build,
a little flip.

00:37:17.200 --> 00:37:20.200
We can also build objects off the slide.

00:37:20.200 --> 00:37:24.150
So here's a scale.

00:37:24.200 --> 00:37:25.250
Okay.

00:37:27.330 --> 00:37:31.560
As you saw when I was
creating my builds earlier,

00:37:31.560 --> 00:37:33.700
I got a little preview in my inspector.

00:37:33.700 --> 00:37:35.510
So this is an NSOpenGL view.

00:37:35.710 --> 00:37:37.600
It's available in Cocoa.

00:37:37.710 --> 00:37:42.700
Basically drop this view into your
Cocoa application and off you go.

00:37:42.700 --> 00:37:45.900
Your programming OpenGL is
actually a really good way to get

00:37:45.900 --> 00:37:48.300
started with OpenGL programming.

00:37:48.460 --> 00:37:51.400
So in this case,
what the user sees in this preview

00:37:51.400 --> 00:37:54.780
is exactly what they're going to get
when they go to full screen mode.

00:37:55.680 --> 00:38:02.760
How do we get the Quartz 2D
images and text and all that,

00:38:02.900 --> 00:38:05.480
path-based shapes, into OpenGL?

00:38:05.480 --> 00:38:10.190
We use this abstraction that's in the
center here called a textured rectangle.

00:38:10.270 --> 00:38:13.330
So I'll walk you through how we go
from something like an NS image.

00:38:13.410 --> 00:38:19.670
We grab data from the image,
apply GL operations to it,

00:38:19.800 --> 00:38:34.300
[Transcript missing]

00:38:35.150 --> 00:38:37.500
and others are working on
the new features of the new

00:38:37.760 --> 00:38:39.230
hardware that's available.

00:38:39.230 --> 00:38:43.110
In some cases you want to chop your
textures up on power of two boundaries.

00:38:43.110 --> 00:38:46.150
So this textured rectangle
kind of abstracts the fact that

00:38:46.150 --> 00:38:49.660
there are this array of smaller
textures that we may have created.

00:38:49.660 --> 00:38:52.660
And we also track the target,
the thing that we're going to

00:38:52.760 --> 00:38:54.830
actually render the textures to.

00:38:55.100 --> 00:38:58.000
The way you initialize this guy,
in this case, there are several,

00:38:58.000 --> 00:39:00.260
it's a much bigger API than this,
obviously.

00:39:00.390 --> 00:39:03.270
You can create it with a bitmap,
and when you want to draw,

00:39:03.480 --> 00:39:06.340
there's an API for
drawing all four corners.

00:39:06.370 --> 00:39:09.260
If your model view
matrix isn't transformed,

00:39:09.300 --> 00:39:14.160
you actually just want to specify exactly
where the texture's going to draw,

00:39:14.210 --> 00:39:15.410
with opacity.

00:39:16.730 --> 00:39:21.350
Now, in NSBitmap Image Rep,
the data is actually RGBA.

00:39:21.420 --> 00:39:28.220
OpenGL will render this stuff,
but the most efficient way

00:39:28.220 --> 00:39:32.210
to do it is using ARGB.

00:39:32.210 --> 00:39:32.210
So this is just a very simple method that

00:39:32.310 --> 00:39:35.080
swaps the high order and low order bytes.

00:39:35.090 --> 00:39:38.840
And it's very fast, and now with ARGB,
we've got kind of the highest

00:39:38.950 --> 00:39:42.820
performance manipulation of the
textures on the graphics card.

00:39:43.830 --> 00:39:46.880
We want to draw the image.

00:39:46.940 --> 00:39:50.400
This first page here shows how
we turn on the opacity support.

00:39:50.450 --> 00:39:55.600
So we hand off the GL blend
method to GL enable.

00:39:56.720 --> 00:39:58.600
Pass some flags to the GL blend function.

00:39:58.610 --> 00:40:02.900
We apply the opacity using GL color 4F.

00:40:02.900 --> 00:40:06.600
I'm not actually not the OpenGL expert,
but there's a session on

00:40:06.670 --> 00:40:11.210
OpenGL optimization where they kind
of address why that's important,

00:40:11.350 --> 00:40:13.940
that the image is pre-multiplied.

00:40:14.430 --> 00:40:18.300
In order to render the textures,
as I said, we've got this, you know,

00:40:18.300 --> 00:40:22.690
abstraction that hides the fact that
this thing's been chopped up into several

00:40:23.040 --> 00:40:24.540
textures on power of two boundaries.

00:40:24.680 --> 00:40:27.760
So we walk through the texture
array and blit it all out.

00:40:28.050 --> 00:40:34.840
GL_TEX_CORD_2DF and GL_VERTEX_2F to
draw at the corners based on the

00:40:34.840 --> 00:40:36.460
offset from the original texture.

00:40:36.460 --> 00:40:40.740
So we've chopped it up and we're
keeping track of where the offsets are.

00:40:41.060 --> 00:40:46.810
Turn off opacity with the disabling
blending and release the target.

00:40:47.900 --> 00:40:52.800
So OpenGL, you know,
we're not just using OpenGL to do,

00:40:52.800 --> 00:40:55.600
you know, moving, to do our flips.

00:40:55.600 --> 00:40:57.330
You know, the GPU is available.

00:40:57.480 --> 00:41:01.500
We found a good way to use
it to accelerate 2D effects,

00:41:01.530 --> 00:41:04.310
accelerate Quartz 2D output.

00:41:04.770 --> 00:41:08.250
With Cocoa,
you have these high-level abilities

00:41:08.520 --> 00:41:12.880
like OpenGL view to do previews
to get started with OpenGL.

00:41:13.000 --> 00:41:16.310
And there are several levels of
APIs available with OpenGL that

00:41:16.310 --> 00:41:17.380
are all there in OS X.

00:41:17.640 --> 00:41:21.860
CGL we use in Keynote to
manage the display and GL for

00:41:21.860 --> 00:41:24.600
the lower-level operations.

00:41:25.070 --> 00:41:28.630
So the last graphical technology
we'll talk about is QuickTime,

00:41:28.630 --> 00:41:33.760
and I've got a little demo here.

00:41:34.900 --> 00:41:52.500
[Transcript missing]

00:41:57.200 --> 00:42:01.880
I think you can see, you know,
you've got excellent frame rate

00:42:01.920 --> 00:42:04.110
while the builds are happening.

00:42:04.400 --> 00:42:05.800
and this opacity.

00:42:05.860 --> 00:42:07.660
And this is really, you know,
the power of Quartz

00:42:07.660 --> 00:42:10.570
Extreme kind of at work here.

00:42:12.760 --> 00:42:16.590
So with QuickTime, you've got, you know,
you're really leveraging

00:42:17.060 --> 00:42:19.480
all the advantages that are
there within the system.

00:42:19.650 --> 00:42:23.280
You've got all the image formats,
and those are available

00:42:23.290 --> 00:42:25.000
through NSImage and Cocoa.

00:42:25.010 --> 00:42:29.600
All these sound formats, all our,
you know, the sound that we use in Cocoa,

00:42:29.600 --> 00:42:30.810
we kind of treat them as movies.

00:42:30.890 --> 00:42:35.320
We just play a sound and
obviously full motion video.

00:42:35.320 --> 00:42:38.660
And when I say, you know,
you're leveraging the power of QuickTime,

00:42:38.670 --> 00:42:42.200
updates to QuickTime come out,
they supply new file formats.

00:42:42.270 --> 00:42:46.540
They support new image
formats or movie formats,

00:42:46.540 --> 00:42:49.300
and that just works, you know.

00:42:49.460 --> 00:42:52.570
QuickTime 6.3 came out a few days,
a few weeks ago.

00:42:52.780 --> 00:42:56.620
Suddenly,
Keynote supports exporting 3GPP movies.

00:42:56.660 --> 00:43:00.540
So we can export a 3GPP movie of slides,
and, you know,

00:43:00.540 --> 00:43:03.890
it's like a little slideshow
preview on your cell phone.

00:43:07.010 --> 00:43:08.960
The image file types that
are available on your system,

00:43:08.960 --> 00:43:12.240
so it depends on what codecs and what
version of QuickTime are available,

00:43:12.370 --> 00:43:15.780
but you can ask NSImage what
image file types are supported.

00:43:15.780 --> 00:43:20.590
This returns a list of file
extensions and HFS file types.

00:43:22.010 --> 00:43:24.010
So again,
the image formats are available.

00:43:24.240 --> 00:43:26.730
It's integrated into NSImage and Cocoa.

00:43:27.080 --> 00:43:30.900
You have NSMovieView,
which you can use to preview a

00:43:30.900 --> 00:43:35.240
movie and control the playback
and speed and scrub through it.

00:43:35.290 --> 00:43:39.510
And a very flexible,
extremely flexible core API for

00:43:39.510 --> 00:43:45.580
not only showing movies,
grabbing content from your media,

00:43:45.630 --> 00:43:48.900
but also export QuickTime movies.

00:43:51.270 --> 00:43:55.190
So when you use NSMovieView,
this is kind of just the simple

00:43:55.190 --> 00:43:58.620
look at how you can use NSMovieView.

00:43:59.200 --> 00:44:03.840
To actually build kind of a small,
simple version of QuickTime, the API is,

00:44:03.840 --> 00:44:07.250
you know, you start to start the motion,
set the rate if you want to fast

00:44:07.380 --> 00:44:09.770
forward or reverse through the movie.

00:44:09.830 --> 00:44:13.050
You can control volume
and mute the movie.

00:44:15.010 --> 00:44:16.710
What we wanted in Keynote,
as I pointed out,

00:44:16.820 --> 00:44:19.250
these movies I was building on,
they're all set to a

00:44:19.250 --> 00:44:21.080
certain poster frame.

00:44:21.220 --> 00:44:23.570
So in this example, the--

00:44:24.480 --> 00:44:27.960
The inspector, the top slider,
controls the poster frame that the user

00:44:27.960 --> 00:44:29.240
wants to see when the movie comes on.

00:44:29.240 --> 00:44:31.270
So you can kind of move this
guy back and forth and you're

00:44:31.270 --> 00:44:32.800
scrubbing through the entire movie.

00:44:32.930 --> 00:44:36.550
So let me show you how you
do that using NSMovieView.

00:44:36.790 --> 00:44:41.570
The slider sends an action called
"take poster frame from the slider."

00:44:42.140 --> 00:44:43.490
The slider value would be a percentage.

00:44:43.500 --> 00:44:47.600
You want to start at zero or go to 100%
all the way through the end of the movie.

00:44:47.720 --> 00:44:54.100
We determine the floating value,
0.5 would be halfway, from the slider.

00:44:55.140 --> 00:44:57.860
"Determine the time offset within
the movie that that corresponds to,

00:44:57.860 --> 00:45:01.850
that percentage corresponds to,
and then set it on this subclass of

00:45:01.850 --> 00:45:07.890
NSMovie that you'd create." You say,
"Set poster time to that offset."

00:45:08.140 --> 00:45:13.790
Tell the movie to display that offset,
obviously, as the user scrubs through.

00:45:15.050 --> 00:45:17.480
I do believe I missed a slide.

00:45:17.500 --> 00:45:20.430
The implementation of those methods

00:45:20.840 --> 00:45:22.440
Well, yeah, actually I did miss a slide.

00:45:22.590 --> 00:45:25.130
Within the implementation
of set poster time,

00:45:25.140 --> 00:45:29.140
you would use QuickTime API,
set movie poster time,

00:45:29.500 --> 00:45:33.150
which takes a QuickTime movie and a
time value to set the poster frame.

00:45:33.360 --> 00:45:37.060
So that's a case where you're
kind of mixing the high-level

00:45:37.200 --> 00:45:41.430
APIs for NSMovieView and the
lower-level APIs of QuickTime.

00:45:42.210 --> 00:45:45.400
So, to summarize QuickTime,
phenomenal compatibility

00:45:45.400 --> 00:45:49.900
with all these image formats,
media formats, sounds, etc.

00:45:49.950 --> 00:45:54.600
Cocoa integration with NSMovieView and
NSImage to support the image formats,

00:45:54.600 --> 00:46:02.690
and a rich, comprehensive set of APIs to
control media playback and export.

00:46:04.220 --> 00:46:06.130
Finally, XML.

00:46:06.240 --> 00:46:07.120
We love XML.

00:46:07.120 --> 00:46:10.810
It's really created kind of a
community already around Keynote.

00:46:10.920 --> 00:46:16.200
There are applications available that
manipulate and use the Keynote format.

00:46:16.320 --> 00:46:18.670
We think XML is a great way
to encourage innovation,

00:46:18.700 --> 00:46:21.780
get other parties involved
in supporting your app,

00:46:21.780 --> 00:46:24.190
encouraging use of your application.

00:46:25.840 --> 00:46:26.650
Finally, XML.

00:46:26.840 --> 00:46:30.600
It's really created kind of a
community already around Keynote.

00:46:30.630 --> 00:46:35.190
There are applications available that
manipulate and use the Keynote format.

00:46:35.200 --> 00:46:38.150
We think XML is a great way
to encourage innovation,

00:46:38.150 --> 00:46:41.130
get other parties involved
in supporting your app,

00:46:41.130 --> 00:46:43.810
encouraging use of your application.

00:46:44.050 --> 00:46:46.240
Very simple way to do some testing.

00:46:46.330 --> 00:46:48.000
Validate the output.

00:46:48.130 --> 00:46:52.590
Make sure that your archiving or your
unarchiving code is actually generating

00:46:52.730 --> 00:46:57.140
documents that conform to the standard
that you've specified for your XML.

00:46:58.090 --> 00:46:58.870
What do you get in OS X?

00:46:58.950 --> 00:47:03.720
Core Foundation has several
layers of XML support.

00:47:03.800 --> 00:47:06.340
If you're just using NSCoder, NSCoder,
if you're not familiar,

00:47:06.340 --> 00:47:10.850
is kind of the standard way of
serializing objects in Cocoa.

00:47:11.000 --> 00:47:15.000
And you can tell NSCoder to
use an XML format.

00:47:15.000 --> 00:47:16.970
The standard format's binary.

00:47:17.060 --> 00:47:20.970
You pass to NSCoder this flag,
property list XML format,

00:47:21.110 --> 00:47:26.280
then the output will be XML,
and that property list format

00:47:26.280 --> 00:47:29.000
is defined on some website.

00:47:29.000 --> 00:47:31.000
I think it's on ADC someplace.

00:47:31.000 --> 00:47:35.350
You have within Core Foundation a
high-level parser,

00:47:35.350 --> 00:47:39.950
which you just handed a document
or a stream of XML text.

00:47:40.020 --> 00:47:43.000
It hands back the structure
called the CFXML tree,

00:47:43.000 --> 00:47:47.900
so you can then walk through elements,
data, and attributes for each node,

00:47:48.000 --> 00:47:51.800
construct your data model that way,
or just maybe manipulate,

00:47:51.850 --> 00:47:53.870
search for data, et cetera.

00:47:54.000 --> 00:47:59.720
There's also a low-level parser,
which is kind of a SACS-type parser.

00:48:00.020 --> 00:48:02.530
Elements are encountered,
attributes are encountered,

00:48:02.630 --> 00:48:04.000
and you can define callbacks.

00:48:04.000 --> 00:48:07.290
So your code is called into,
then you're going to create

00:48:07.290 --> 00:48:08.880
your data model that way.

00:48:09.000 --> 00:48:10.040
Thank you.

00:48:10.400 --> 00:48:15.000
Well, for Keynote,
we use the low-level parser.

00:48:15.000 --> 00:48:17.590
We encounter a slide and we
go off and create a slide.

00:48:17.750 --> 00:48:23.360
But when we generate XML,
we actually just use a mutable string.

00:48:23.510 --> 00:48:26.600
We just generate this
NSMutable string on the fly.

00:48:26.600 --> 00:48:30.330
And this is kind of the
class that we use to do that.

00:48:30.420 --> 00:48:33.240
It's called a DOM writer,
a document object model writer.

00:48:33.240 --> 00:48:34.620
So you start an element.

00:48:34.620 --> 00:48:37.230
You say,
here's what I want to start something

00:48:37.230 --> 00:48:39.240
that's a slide or a bullet point.

00:48:39.480 --> 00:48:39.890
End it.

00:48:40.320 --> 00:48:43.070
Write attributes like what color it uses.

00:48:43.340 --> 00:48:46.570
Control formatting with indent,
increase and decrease indent.

00:48:46.720 --> 00:48:51.150
And you can also pass in the structure,
this XML element,

00:48:51.270 --> 00:48:55.520
similar to CFXML element,
to create -- to write an actual

00:48:55.520 --> 00:48:58.710
subtree all the way out to the string.

00:48:59.660 --> 00:49:01.560
So our file format is open.

00:49:01.790 --> 00:49:06.090
The scheme is available at TechNote 2067.

00:49:06.130 --> 00:49:08.600
There's already third-party
developer support.

00:49:08.600 --> 00:49:12.230
FileMaker has an application that
generates and a library of code

00:49:12.250 --> 00:49:14.830
that generates Keynote documents.

00:49:15.040 --> 00:49:17.980
4D has the same thing.

00:49:18.020 --> 00:49:19.780
We think there are a lot
of possible applications.

00:49:19.780 --> 00:49:23.380
You can obviously pull data off the web,
pull data from your

00:49:23.380 --> 00:49:26.260
enterprise data store,
generate kiosks,

00:49:26.310 --> 00:49:31.980
presentations with great 3D transitions,
migrate your legacy data

00:49:32.040 --> 00:49:33.820
into our tables or builds.

00:49:33.910 --> 00:49:36.650
I'm sorry, our tables are charts.

00:49:38.730 --> 00:49:41.340
And here's an,
I'm gonna actually give you a demo

00:49:41.340 --> 00:49:43.140
of the 4D presentation builder.

00:49:43.140 --> 00:49:46.520
What this does is it's,
the user interacts with

00:49:46.630 --> 00:49:50.640
this UI to create a query,
it generates the XML,

00:49:50.680 --> 00:49:52.130
and the output is a presentation.

00:49:52.260 --> 00:49:54.210
I'll show it to you.

00:50:02.990 --> 00:50:03.760
So here's the UI.

00:50:03.860 --> 00:50:07.840
They've set up this kind of
sample database of properties.

00:50:08.010 --> 00:50:11.330
You know, they've got this,
I think they include the

00:50:11.330 --> 00:50:14.000
code to generate these,
our format,

00:50:14.040 --> 00:50:18.870
but this is just a sample database of,
for instance, real estate properties.

00:50:19.180 --> 00:50:20.790
User can go pick a buyer.

00:50:21.100 --> 00:50:24.860
So the idea is I'm a real estate agent,
I'm gonna edit properties

00:50:25.230 --> 00:50:26.000
of this or that.

00:50:28.340 --> 00:50:30.340
Edit attributes of this buyer,
what they want to spend,

00:50:30.340 --> 00:50:33.840
where they want to live.

00:50:33.890 --> 00:50:36.360
And then create a new presentation.

00:50:38.060 --> 00:50:41.040
So it tells me I'm going to
show you all the properties

00:50:41.040 --> 00:50:43.430
in this price range at this

00:50:44.130 --> 00:50:49.340
This price and this zip code,
and I want to open the new presentation.

00:50:51.790 --> 00:50:57.330
So the document's created, Keynote opens,
and I'll just play it.

00:51:00.410 --> 00:51:01.840
So now I'm a real estate agent.

00:51:01.840 --> 00:51:06.000
I've got this very simple,
simply created little kiosk that I can

00:51:06.000 --> 00:51:13.200
show my client who's been sitting
there with me for three minutes.

00:51:13.200 --> 00:51:20.200
So you get the idea.

00:51:24.700 --> 00:51:25.990
Can you see the slides, please?

00:51:25.990 --> 00:51:27.900
Thanks.

00:51:28.020 --> 00:51:33.010
So XML, it's great for building a
community around your application.

00:51:33.360 --> 00:51:35.290
It's really great for development.

00:51:35.470 --> 00:51:39.600
Validate your documents,
generate your documents before your app's

00:51:39.600 --> 00:51:41.640
even ready to generate your documents.

00:51:41.660 --> 00:51:45.720
And there's support in
Core Foundation for several

00:51:45.720 --> 00:51:48.030
levels of XML usage.

00:51:50.410 --> 00:51:56.120
So Keynote, as we develop the app,

00:51:57.690 --> 00:51:59.730
We found that Cocoa was
the best framework for us.

00:51:59.920 --> 00:52:03.080
We made great use of the Cocoa text
capabilities to make it very

00:52:03.080 --> 00:52:08.470
simple to get at the very powerful
technology that's available.

00:52:08.700 --> 00:52:15.400
We use Quartz for creating beautiful,
graphically rich presentations.

00:52:15.470 --> 00:52:21.360
OpenGL for 3D cinematic
effects as well as 2D effects.

00:52:21.450 --> 00:52:23.950
QuickTime, we generate QuickTime movies.

00:52:24.030 --> 00:52:25.310
We display QuickTime movies.

00:52:25.490 --> 00:52:27.380
We have great control over
the QuickTime movies that

00:52:27.390 --> 00:52:28.490
are in the presentation.

00:52:28.650 --> 00:52:32.480
And XML, again,
an open file format that you

00:52:32.480 --> 00:52:34.510
can really build support around.

00:52:35.140 --> 00:52:36.830
So what can you get out of this?

00:52:37.040 --> 00:52:39.640
Now,
all these technologies are available.

00:52:39.710 --> 00:52:40.760
It's a modern operating system.

00:52:40.760 --> 00:52:42.840
Make use of the technologies.

00:52:42.870 --> 00:52:46.720
If one way of getting at the
feature set you want doesn't work,

00:52:46.750 --> 00:52:51.110
there's probably another set of APIs,
and they're all extensible.

00:52:51.590 --> 00:52:53.960
First rate tools available
on the operating system.

00:52:53.970 --> 00:52:55.680
Take the people you've
got in your organization.

00:52:55.680 --> 00:52:57.160
I look forward to seeing your apps.

00:52:57.290 --> 00:52:58.920
Thanks a lot.

00:53:06.390 --> 00:53:09.270
So what I'd like to do is just go
through the roadmap of the remaining

00:53:09.340 --> 00:53:11.730
graphics and imaging related sessions.

00:53:11.990 --> 00:53:15.270
Starting tomorrow morning, Wednesday,
in the marina,

00:53:15.270 --> 00:53:16.880
we have image capture update.

00:53:17.110 --> 00:53:19.480
What we're going to do is talk
about the APIs that are available

00:53:19.480 --> 00:53:23.500
in the system that handle both
digital cameras and also scanners.

00:53:23.530 --> 00:53:26.470
So if your applications need to
import or bring graphics in from

00:53:26.470 --> 00:53:29.200
the real world into the virtual
world inside your computer,

00:53:29.220 --> 00:53:33.300
this is the architecture and the
APIs you're going to want to know about.

00:53:34.800 --> 00:55:41.500
[Transcript missing]

00:55:42.390 --> 00:55:45.630
Then another key session,
if you're an OpenGL application

00:55:45.840 --> 00:55:48.420
and you want to learn how to
optimize your application,

00:55:48.420 --> 00:55:51.810
or you're a beginning OpenGL programmer
and you want to learn how to do

00:55:51.810 --> 00:55:54.660
the right things the first time,
you want to come to 209

00:55:54.660 --> 00:55:55.950
OpenGL optimizations.

00:55:56.040 --> 00:55:59.600
And this is really going to focus
on providing a lot of information

00:55:59.600 --> 00:56:02.600
about the fast path that we
put into Mac OS X's OpenGL.

00:56:02.660 --> 00:56:06.030
Because it's interesting,
our OpenGL stack is optimized and

00:56:06.030 --> 00:56:10.400
tuned in certain ways that once you put
your application on those fast paths,

00:56:10.400 --> 00:56:12.640
you're going to get
unbelievable performance.

00:56:12.730 --> 00:56:16.000
So that's 209 on Thursday is
going to go over that.

00:56:16.100 --> 00:56:19.450
And then we have 210,
Mac OS X printing update.

00:56:19.540 --> 00:56:22.400
And this is going to talk about
a lot of the new developments

00:56:22.400 --> 00:56:23.590
in Mac OS X printing.

00:56:23.680 --> 00:56:25.440
We're actually going to
talk about one exciting one,

00:56:25.440 --> 00:56:29.220
which is the ability for the system
to convert PostScript into PDF now,

00:56:29.310 --> 00:56:30.440
which is a new Panther feature.

00:56:30.440 --> 00:56:32.540
And that has significant ramifications.

00:56:32.610 --> 00:56:35.290
So it's going to be a great tool
for people in printing and imaging.

00:56:35.380 --> 00:56:38.080
So it's an excellent session to attend.

00:56:38.180 --> 00:56:41.480
Then we have 211,
which is introduction to Quartz services.

00:56:41.570 --> 00:56:43.960
This is our first session on Friday.

00:56:44.050 --> 00:56:48.630
And this session is going to
talk about essentially the parts

00:56:48.630 --> 00:56:53.430
of the Quartz architecture which
do not actually draw anything.

00:56:53.490 --> 00:56:57.280
These are the parts that
control and manage displays.

00:56:57.350 --> 00:57:01.630
So this is an important session if you
have a full screen application or you

00:57:01.630 --> 00:57:05.480
have an application that needs to find
out what the display environment is.

00:57:05.590 --> 00:57:08.680
Because there's a lot of API that
developers have had trouble finding

00:57:08.730 --> 00:57:12.110
and understanding how to use that we're
going to talk about in this session.

00:57:12.370 --> 00:57:17.320
And then we have on 212
our hardware partners,

00:57:17.320 --> 00:57:20.710
ATI, coming this year to talk
about essentially the latest

00:57:21.060 --> 00:57:24.480
techniques that you can do to do
interesting visual effects using

00:57:24.480 --> 00:57:27.980
programmability and their product,
the Radeon 9700.

00:57:28.090 --> 00:57:32.420
So that's session 212,
cutting edge OpenGL techniques.

00:57:33.210 --> 00:57:35.860
We have a partially related session.

00:57:35.860 --> 00:57:39.050
If you're an application developer,
you might want to check out the

00:57:39.050 --> 00:57:41.340
Mac OS X accessibility session,
where we're going to be talking

00:57:41.340 --> 00:57:45.100
about how to make your applications
accessible to users with disabilities.

00:57:45.100 --> 00:57:48.110
It's an important session for anyone
who develops an application to attend,

00:57:48.110 --> 00:57:50.100
because there's a large
audience out there who,

00:57:50.100 --> 00:57:52.020
through simple changes
in your application,

00:57:52.110 --> 00:57:56.100
you may be able to reach new customers
who happen to have a disability.

00:57:56.450 --> 00:57:58.320
Finally,
we have the main opportunity for you

00:57:58.320 --> 00:58:02.100
guys to give us your feedback and let us
know what you thought of the sessions,

00:58:02.100 --> 00:58:04.100
what you want to see inside the OS.

00:58:04.100 --> 00:58:06.940
Essentially,
let us know what we need to do to

00:58:07.320 --> 00:58:11.160
continue to involve Mac OS X as
the most innovative and graphically

00:58:11.160 --> 00:58:13.760
powerful operating system on the planet.

00:58:14.140 --> 00:58:18.040
That's the feedback forum,
which is in our traditional slot,

00:58:18.050 --> 00:58:20.100
Friday at 5:00 p.m.

00:58:20.250 --> 00:58:23.090
Thank you very much for
attending this session.

00:58:23.310 --> 00:58:24.100
Appreciate it.
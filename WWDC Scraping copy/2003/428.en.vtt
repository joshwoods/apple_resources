WEBVTT

00:00:25.670 --> 00:00:28.260
Good afternoon and
welcome to session 428,

00:00:28.490 --> 00:00:31.900
Understanding the
New Ink API on Mac OS X.

00:00:31.910 --> 00:00:36.740
We are thrilled today to introduce
a new set of APIs on Mac OS X that

00:00:36.740 --> 00:00:42.810
will allow you to provide
additional support for handwriting

00:00:42.810 --> 00:00:42.810
recognition in your application.

00:00:47.730 --> 00:00:51.890
As you know, with Jaguar,
Apple introduced Inkwell,

00:00:52.130 --> 00:00:55.780
the end customer solution
for handwriting recognition.

00:00:55.800 --> 00:01:01.980
Inkwell provides system-wide support for
Cocoa and Carbon applications without

00:01:01.980 --> 00:01:05.580
requiring any modification to the apps.

00:01:05.690 --> 00:01:11.240
And what I'd like to do first
today is give you a brief overview

00:01:11.320 --> 00:01:15.280
of the functionality that Inkwell
supports in the applications.

00:01:17.740 --> 00:01:21.320
here is a Wacom tablet, my Wacom tablet.

00:01:21.320 --> 00:01:26.530
And I have downloaded the
Wacom driver from the web.

00:01:26.630 --> 00:01:32.140
And the first thing I'm going to do,
is go to the system preference and

00:01:32.240 --> 00:01:35.640
know that there's an ink panel there.

00:01:35.790 --> 00:01:38.670
So I'm going to launch that panel.

00:01:38.850 --> 00:01:44.110
And there is a control that is going to
allow me to turn recognition on and off.

00:01:44.310 --> 00:01:48.400
Recognition is already on,
but if it went off, I turn it on.

00:01:48.400 --> 00:01:52.720
And that's all basically all I need
to do to have system-wide support

00:01:52.810 --> 00:01:55.650
for handwriting recognition in Java.

00:01:56.160 --> 00:01:59.200
There's more stuff that you can
do in the Ink Preference Panel.

00:01:59.200 --> 00:02:02.880
Basically,
tweak the settings for recognition.

00:02:03.050 --> 00:02:04.820
Look at the gestures that we support.

00:02:04.950 --> 00:02:07.000
Add words to your user dictionary.

00:02:07.000 --> 00:02:09.760
But I'm not going to go
into those right now.

00:02:09.960 --> 00:02:12.680
So let me quit the Ink Preference Panel.

00:02:12.680 --> 00:02:18.150
And now I'm ready to start inputting
text in my Cocoa application.

00:02:18.160 --> 00:02:20.080
I have text added up here.

00:02:20.080 --> 00:02:24.640
And I'm going to start writing
anywhere I like on the screen.

00:02:24.640 --> 00:02:30.370
And you'll see that the strokes and
the writing guidelines will show up.

00:02:30.480 --> 00:02:34.760
The strokes get shipped as
a unit to the recognizer,

00:02:34.760 --> 00:02:39.380
recognized as text,
sent to Cocoa as a Carbon event.

00:02:39.380 --> 00:02:42.630
Cocoa will extract the information
and enter into the document.

00:02:42.640 --> 00:02:46.300
I can continue to ride.

00:02:47.300 --> 00:02:53.820
On this tablet,
strokes we build collected, recognized,

00:02:53.880 --> 00:02:55.940
and boom, they go to my application.

00:02:55.940 --> 00:02:57.240
As easy as that.

00:02:57.310 --> 00:03:00.820
Text edits have not been
modified to support recognition.

00:03:00.840 --> 00:03:06.760
However, Inkwell allows you to do much
more text than entering your text.

00:03:07.080 --> 00:03:10.910
It also allows you to do editing.

00:03:10.910 --> 00:03:13.040
So, for instance,
if I hold down the stylus,

00:03:13.040 --> 00:03:16.980
the pen will go into mouse mode.

00:03:16.980 --> 00:03:18.890
And now I have a selection.

00:03:18.970 --> 00:03:24.180
I can act upon the selection and
I can erase it by just doing a

00:03:24.180 --> 00:03:27.610
simple erase gesture on the screen.

00:03:27.700 --> 00:03:30.840
And boom, that word is gone.

00:03:30.840 --> 00:03:34.570
But I really didn't
want to erase that word.

00:03:34.670 --> 00:03:38.560
I want it back in my
document and I'm going to...

00:03:39.120 --> 00:03:44.030
do an undo gesture a shaky and new
gesture but there it is i got my word

00:03:44.030 --> 00:03:50.330
back on this on the document so now let
me switch to a Carbon application and

00:03:50.330 --> 00:03:56.800
i'm going to show you that exactly the
same paradigm works there i have itunes

00:03:56.940 --> 00:04:02.580
and say that i bought a new cd and
i want to add it to my collection and

00:04:02.580 --> 00:04:09.980
i want to give it a name i'm gonna pick
up my stylus and i'm gonna write the

00:04:10.160 --> 00:04:17.420
name for my new cd there you go i'm done
so without any modification i can enter

00:04:17.420 --> 00:04:25.750
text edit and manipulate the ui however
this is that's pretty powerful but there

00:04:25.750 --> 00:04:30.650
is much more than really applications
could do if they had access to the

00:04:30.870 --> 00:04:35.660
information that the recognition system
provides and to give you just a glimpse

00:04:35.770 --> 00:04:41.800
of that i'm going to show you what the
ink pad does the ink pad is this little

00:04:41.800 --> 00:04:48.110
input window that we ship on jaguar
that is accessible from the ink window

00:04:49.400 --> 00:04:54.200
And that we like to call it the
first Ink Aware application.

00:04:54.280 --> 00:05:01.850
So as you see, I can go to the Ink pad,
and now right there on the window, again,

00:05:01.940 --> 00:05:06.710
the text, the ink is recognized and
will show up on the document.

00:05:07.180 --> 00:05:10.720
However,
if I can go now to that same text,

00:05:10.810 --> 00:05:13.000
and because this is an
Ink Aware application,

00:05:13.000 --> 00:05:17.600
I can double click and hold,
and I can look at all of the

00:05:17.600 --> 00:05:21.030
alternatives that the recognizing
the system has given us.

00:05:21.040 --> 00:05:24.820
On top of that,
I can choose one of them if I like, or,

00:05:24.900 --> 00:05:28.920
and I can look at the strokes
that they use that I've written

00:05:29.110 --> 00:05:33.080
so that I get feedback on what
that word was meant to be.

00:05:33.240 --> 00:05:35.140
So I can select that.

00:05:35.290 --> 00:05:40.910
And now,
the case for the word has changed.

00:05:41.020 --> 00:05:42.540
Okay.

00:05:42.600 --> 00:05:44.620
Let me use the undo.

00:05:44.670 --> 00:05:46.370
It works right there.

00:05:47.100 --> 00:05:51.350
Okay, so I can continue to write on
the ink pad exactly the same

00:05:51.350 --> 00:05:55.270
way that I wrote on TextEdit.

00:05:55.500 --> 00:05:58.380
The phone ran,
and I stopped in the middle of the word,

00:05:58.380 --> 00:06:01.560
where I can pick it up
right where I left it.

00:06:02.760 --> 00:06:10.950
Like the other part of the cognition,
and then do a gesture to merge those two

00:06:10.960 --> 00:06:14.600
pieces of those two words that I wrote.

00:06:15.100 --> 00:06:18.560
So with a simple gesture that
looks very much like a V,

00:06:18.560 --> 00:06:20.760
I can merge those two strings.

00:06:20.760 --> 00:06:25.980
And now, notice that because this
is an InkAware application,

00:06:25.980 --> 00:06:30.540
I can erase a word just by
scribbling on top of that without

00:06:30.710 --> 00:06:35.910
having to go through the process
of selecting and then erasing.

00:06:35.910 --> 00:06:41.610
So there is much more power that you
can add to your application by using

00:06:41.610 --> 00:06:42.770
the stylus directly on the objects.

00:06:43.030 --> 00:06:45.880
And developers have recognized that.

00:06:45.990 --> 00:06:50.980
And since we introduced Inkwell,
we have had a series of requests

00:06:51.760 --> 00:06:56.480
for developers to tap into the
Ink services that we provide.

00:06:56.570 --> 00:07:01.220
And the requests have
ranged from questions like,

00:07:01.300 --> 00:07:05.360
how can I add support for devices
other than the Wacom tablets,

00:07:05.500 --> 00:07:10.490
to requests where developers are
asking about separating the process

00:07:10.530 --> 00:07:15.090
of gathering the digital ink from
the process of recognizing the ink--

00:07:15.250 --> 00:07:18.570
basically doing deferred recognition,
if you are familiar with the

00:07:18.570 --> 00:07:22.380
term-- to questions about--

00:07:22.700 --> 00:07:26.130
and other developers who want
to have more control on where

00:07:26.210 --> 00:07:28.400
and when the ink is drawn.

00:07:28.550 --> 00:07:32.720
So we have taken, for Panther,
we have taken those requests and

00:07:32.720 --> 00:07:37.170
combined it with our vision on how
handwriting support should work

00:07:37.270 --> 00:07:41.290
on Mac OS X to provide you with
a set of very simple yet powerful

00:07:41.290 --> 00:07:46.430
APIs that would allow you to provide
additional support for handwriting.

00:07:46.430 --> 00:07:50.360
They will allow you to ship to
your customers the solutions

00:07:50.360 --> 00:07:52.350
that they are looking for.

00:07:54.000 --> 00:07:57.900
So today,
what I want to do for the rest of the

00:07:57.980 --> 00:08:04.790
presentation is introduce you to some
of the concepts that we are going

00:08:04.790 --> 00:08:09.720
to use throughout the presentation,
some very basic concepts

00:08:10.600 --> 00:08:12.520
that we use in the APIs.

00:08:12.670 --> 00:08:15.680
And then we're going to talk
briefly about the technologies

00:08:15.820 --> 00:08:20.500
that you use behind the scenes to
provide the recognition support.

00:08:20.510 --> 00:08:22.440
And finally,
we're going to go into the meat

00:08:22.440 --> 00:08:26.360
of the presentation and give you
a brief overview of the API we

00:08:26.470 --> 00:08:33.320
support and how you can use them to
develop solutions for your customers.

00:08:35.650 --> 00:08:40.540
One question that we often get is,
what kind of device do I need in order

00:08:40.540 --> 00:08:43.640
to get Inkwell or Ink services to work?

00:08:43.640 --> 00:08:47.700
And for Jaguar, the answer was,
you need a Wacom tablet

00:08:47.700 --> 00:08:49.210
and a Wacom driver.

00:08:49.330 --> 00:08:54.660
For Panther, we're going to continue,
of course, to support the Wacom devices,

00:08:54.680 --> 00:08:59.810
but we are going to add support
for devices that provide

00:08:59.980 --> 00:09:05.150
XY and pressure information,
either in a real-time fashion,

00:09:05.150 --> 00:09:12.210
like tablets do, or in an offline way,
like the readily available

00:09:12.280 --> 00:09:17.000
USB and Bluetooth pens that you
have these days on the market.

00:09:17.740 --> 00:09:19.540
Now, let's go through the concept.

00:09:19.730 --> 00:09:23.060
There are basically five concepts,
very simple concepts that we're

00:09:23.060 --> 00:09:27.290
going to use throughout the
presentation and in the documentation.

00:09:27.350 --> 00:09:32.010
The first one is an ink phrase,
and you are already familiar with that.

00:09:32.190 --> 00:09:35.540
Think of an ink phrase as a group
of strokes that stays on the screen

00:09:35.800 --> 00:09:39.020
before being shipped to the recognizer.

00:09:39.060 --> 00:09:42.100
There are a little bit of
nuances to that concept that you

00:09:42.220 --> 00:09:46.680
can read in the documentation,
but that basically is what you need

00:09:46.680 --> 00:09:49.980
to think about for this presentation.

00:09:50.210 --> 00:09:54.580
Now, as I was writing on the
tablet and I lifted the pen,

00:09:54.620 --> 00:09:57.870
the ink phrase was terminated,
shipped to the recognizer,

00:09:57.970 --> 00:09:59.950
and then to the application.

00:10:00.110 --> 00:10:03.120
There are other ways that
I can terminate a phrase.

00:10:03.220 --> 00:10:06.470
And basically, I can,
if I hold the pen for

00:10:06.470 --> 00:10:10.020
a while and nothing,
and I don't do anything, anything else,

00:10:10.020 --> 00:10:14.080
a timeout is going to happen and the
ink phrase is going to terminate.

00:10:14.410 --> 00:10:20.140
The other way that ink phrases terminate
is because if I write my strokes apart on

00:10:20.260 --> 00:10:24.990
the X direction and on the Y direction,
that's also a way that the

00:10:25.090 --> 00:10:26.360
ink phrase is terminated.

00:10:26.520 --> 00:10:30.730
And the reason why I'm telling you this,
what is an important concept to you,

00:10:30.810 --> 00:10:35.520
is because later on when we go through
the developer scenarios and the APIs,

00:10:35.520 --> 00:10:40.810
we're going to talk about ways for you
to take control over phrase termination

00:10:41.160 --> 00:10:46.100
if your application needs to do so.

00:10:48.360 --> 00:10:51.160
The next concept is Ink Text Ref.

00:10:51.550 --> 00:11:00.340
And if the strokes you wrote are
recognized by the ink services as text,

00:11:00.400 --> 00:11:03.430
essentially what you are going to get

00:11:03.830 --> 00:11:06.500
The first tool you need to get in
your application is an ink text ref.

00:11:06.600 --> 00:11:10.600
An ink text ref is an opaque object
that contains information about

00:11:10.600 --> 00:11:15.340
the digital ink that you wrote,
the location of that ink,

00:11:15.350 --> 00:11:17.510
and the information from the recognizer.

00:11:17.640 --> 00:11:24.640
That set of strings that the recognizer
is provided as the alternate for the ink.

00:11:24.640 --> 00:11:30.610
And the APIs provide a way for you to
access most of the information that

00:11:30.710 --> 00:11:33.010
is available on the ink text ref.

00:11:37.330 --> 00:11:39.100
The Alternates Menu.

00:11:39.100 --> 00:11:43.650
If you want to present to your user
the results of the recognition so

00:11:43.650 --> 00:11:48.400
that they can browse the information,
we're going to provide a simple

00:11:48.490 --> 00:11:52.630
API for you to construct that
menu and show it to the user.

00:11:52.720 --> 00:11:56.860
And the menu will contain, again,
the alternates plus the ink.

00:11:56.880 --> 00:12:02.630
And the final concept that
I want to go over is gestures.

00:12:02.850 --> 00:12:09.090
You saw me use all of
these gestures in the demo.

00:12:09.110 --> 00:12:12.180
And so we basically have
three types of gestures.

00:12:12.230 --> 00:12:18.170
The first kind, let me position myself,
on the right hand of the

00:12:18.170 --> 00:12:21.530
screen is the undo gesture.

00:12:21.560 --> 00:12:24.900
And we call those kind of
gestures non-targeted gestures.

00:12:25.420 --> 00:12:29.350
And what those kind of gestures,
what it really means is no matter

00:12:29.350 --> 00:12:34.920
where you draw them on the screen,
they're going to perform the same action.

00:12:35.910 --> 00:12:39.840
The second type of gestures,
which I have here on the

00:12:39.840 --> 00:12:42.470
top left of the screen,
are what we call optionally

00:12:42.570 --> 00:12:43.750
targeted gestures.

00:12:43.760 --> 00:12:47.130
And an example of that
is the erase gesture.

00:12:47.140 --> 00:12:49.980
And you saw me use it in
two different contexts.

00:12:50.160 --> 00:12:54.620
In text edit, which is at this point
not an InkAware app,

00:12:54.740 --> 00:12:57.600
I had to do a selection
in order to erase.

00:12:57.620 --> 00:13:03.360
In the InkPad,
which has been an InkAware application,

00:13:04.150 --> 00:13:06.960
you can just erase on top of the text.

00:13:07.040 --> 00:13:12.140
So that is the difference
for those gestures.

00:13:13.960 --> 00:13:19.010
And we have additional gestures
that are optionally targeted.

00:13:20.830 --> 00:13:24.880
And finally, the third class of gestures
is the joint gesture.

00:13:24.950 --> 00:13:28.520
Those are gestures that are
only supported in InkAware apps

00:13:28.530 --> 00:13:34.240
because we need to know where on
the screen that gesture occurs.

00:13:34.330 --> 00:13:39.060
So there is no way for the
Ink services to differentiate between

00:13:39.060 --> 00:13:44.170
a V or a joint gesture unless the
application gives us the information

00:13:44.410 --> 00:13:49.240
or where on the context of the
application the gesture has occurred.

00:13:49.370 --> 00:13:52.290
So again,
there are three classes of gestures,

00:13:52.290 --> 00:13:55.640
and the reason why we're telling
you this is because you again can

00:13:55.640 --> 00:14:02.370
choose to support those gestures
in your application to allow the

00:14:02.370 --> 00:14:06.520
user to do direct manipulation,
to interact with the stylus directly

00:14:06.520 --> 00:14:10.930
with the objects without requiring
them to go through the metaphor that is

00:14:11.300 --> 00:14:16.170
needed for the keyboard where you have to
select and then act upon the selection.

00:14:16.180 --> 00:14:19.170
You can just go and use the
stylus directly in the object.

00:14:19.240 --> 00:14:22.760
And so the non-targeted gesture,
basically you don't

00:14:22.760 --> 00:14:24.490
need to add the support.

00:14:24.620 --> 00:14:26.530
The system can handle it.

00:14:26.670 --> 00:14:30.500
For the optionally targeted gesture,
you may want to add the support

00:14:30.500 --> 00:14:33.940
if you want that interaction to
happen because you need to add

00:14:33.940 --> 00:14:36.170
the information of the location.

00:14:36.210 --> 00:14:39.830
And for the always targeted gesture,
the support has to come

00:14:39.900 --> 00:14:41.490
from the application.

00:14:41.860 --> 00:14:47.190
And that concludes kind of the basic
concept that you need to know today.

00:14:47.240 --> 00:14:51.340
Now let me move on to the ink components.

00:14:51.380 --> 00:14:57.620
And we have basically four
components for the ink services.

00:14:57.660 --> 00:15:02.630
On the right-hand side of the screen,
that blue rectangle shows

00:15:02.630 --> 00:15:05.320
the application context.

00:15:05.370 --> 00:15:09.660
And in the application context,
two of the components live there.

00:15:09.720 --> 00:15:14.580
The ink input method is the part of
the ink services that provide data

00:15:14.660 --> 00:15:17.160
collection and drawing of the ink.

00:15:17.280 --> 00:15:20.270
So as you write,
the ink input method is going

00:15:20.610 --> 00:15:23.130
to gather the data and draw it.

00:15:23.350 --> 00:15:27.880
The other component on the context of
the application is the ink framework.

00:15:28.040 --> 00:15:30.910
That's where the implementation
of the API lives.

00:15:31.030 --> 00:15:37.220
On the left-hand corner of the screen,
the box shows you the user preferences,

00:15:37.280 --> 00:15:39.160
which I show you in the demo.

00:15:39.230 --> 00:15:43.310
And that contains the-- and then
contains the press pane that allows

00:15:43.610 --> 00:15:47.800
users to set their recognition mode,
look at the gesture,

00:15:47.800 --> 00:15:51.840
turn gestures on and off,
add words to their dictionary.

00:15:51.870 --> 00:15:56.480
And finally,
on the top corner of the screen,

00:15:56.500 --> 00:15:57.650
we have the ink server.

00:15:57.780 --> 00:16:00.180
That's where the core of
the recognition lives,

00:16:00.230 --> 00:16:03.190
where there's the segmentation,
the recognition process,

00:16:03.330 --> 00:16:05.560
the language model is instantiated.

00:16:05.670 --> 00:16:07.320
And in addition, the ink window.

00:16:07.440 --> 00:16:11.710
But the important-- for you today
is the fact that that's where the

00:16:11.710 --> 00:16:13.760
core of the recognition lives.

00:16:13.760 --> 00:16:17.790
And with that, it is my pleasure to
introduce Larry Yeager.

00:16:18.000 --> 00:16:19.590
Larry.

00:16:25.600 --> 00:16:27.640
Larry is a distinguished
engineer at Apple.

00:16:27.640 --> 00:16:35.510
He's worked for us for several
years in handwriting recognition,

00:16:35.510 --> 00:16:35.510
and I'm very pleased to
have him on stage today.

00:16:35.910 --> 00:16:37.260
Okay,
I'm going to give you a quick run through

00:16:37.260 --> 00:16:40.560
some of the technologies underlying
what Giulia has just demonstrated

00:16:40.560 --> 00:16:44.080
for you and even dive down a little
bit into the recognition technology,

00:16:44.080 --> 00:16:46.160
though that doesn't
directly affect your apps.

00:16:46.250 --> 00:16:49.300
It's sort of what provides
all these services.

00:16:50.510 --> 00:16:56.380
The recognizer can be boiled
down to something very simple.

00:16:56.380 --> 00:16:58.320
Basically,
these three boxes pretty much define

00:16:58.320 --> 00:16:59.520
the last ten years of my life.

00:16:59.600 --> 00:17:05.470
It starts off with X,
Y points and pen lifts,

00:17:05.480 --> 00:17:08.360
just exactly what you would imagine
are coming from the graphics tablet.

00:17:08.360 --> 00:17:12.000
And we take those in strokes,
what you normally think of as

00:17:12.100 --> 00:17:15.550
strokes with pen and paper,
and we look at combinations

00:17:15.610 --> 00:17:19.000
of those strokes to see what
might possibly be characters,

00:17:19.170 --> 00:17:20.870
and that's what we call
character segmentation.

00:17:20.880 --> 00:17:24.820
So out of this tentative
segmentation block comes these

00:17:24.820 --> 00:17:29.150
character segmentation hypotheses,
and some of them are going to be right

00:17:29.150 --> 00:17:31.230
and some of them are going to be wrong,
and we can't possibly

00:17:31.320 --> 00:17:32.340
predict up front which.

00:17:32.360 --> 00:17:39.180
The next block is a
neural network classifier.

00:17:39.180 --> 00:17:42.740
It takes these combinations of
strokes that might be characters,

00:17:42.740 --> 00:17:45.920
looks at them in a certain way,
and tries to decide

00:17:46.040 --> 00:17:49.140
whether they are or not,
and which characters they are.

00:17:49.140 --> 00:17:53.420
So what it emits are these
character class hypotheses.

00:17:53.420 --> 00:17:56.600
It's trying to say if it's A, B, C, D, E,
F, or whatever.

00:17:58.820 --> 00:18:04.800
That sequence of probability vectors
are fed into a search engine.

00:18:04.800 --> 00:18:07.720
And the search engine sits
there with a language model,

00:18:07.720 --> 00:18:10.960
that's the context,
and tries to just find the best

00:18:11.090 --> 00:18:15.760
combination of all those possible
character combinations and vectors

00:18:15.790 --> 00:18:20.140
of probabilities of characters and
look for the maximum likelihood path

00:18:20.240 --> 00:18:24.040
through this graph and end up with,
finally, word probabilities,

00:18:24.140 --> 00:18:25.500
what the person wrote.

00:18:25.960 --> 00:18:29.510
So, sort of to see what that looks like,
suppose a person wrote

00:18:29.600 --> 00:18:31.360
this on the computer.

00:18:31.360 --> 00:18:33.900
You, you know,
hopefully maybe 50% of the people

00:18:34.030 --> 00:18:37.060
in the audience thought it was
clog and 50% thought it was dog,

00:18:37.070 --> 00:18:40.440
although dog's such a common word,
maybe a little skewed that way.

00:18:40.440 --> 00:18:45.510
Well, what we do is take those strokes
and take the first stroke that

00:18:45.640 --> 00:18:51.120
kind of looks like a C and feed it
into the neural network classifier.

00:18:51.120 --> 00:18:55.140
It emits this vector of probabilities,
and let's say it's pretty good.

00:18:55.200 --> 00:18:55.940
You know, 0.2.

00:18:55.960 --> 00:18:58.440
90% certain that it's a C.

00:18:58.470 --> 00:19:00.320
Okay, that's great.

00:19:01.660 --> 00:19:05.000
Next, we'll probably try the
first two strokes together.

00:19:05.050 --> 00:19:08.140
And let's say that, well, you know,
there's a written kind of far apart.

00:19:08.180 --> 00:19:09.520
That's an awfully big gap in there.

00:19:09.520 --> 00:19:12.250
Let's say the neural net kind
of picks up on that and says,

00:19:12.250 --> 00:19:14.440
well, 70% probability that's a D.

00:19:14.440 --> 00:19:18.200
And, you know,
a few other things scattered around.

00:19:19.340 --> 00:19:22.970
When that second stroke
is then tried by itself,

00:19:22.970 --> 00:19:27.610
the only legal transition
is from the C to the L.

00:19:27.610 --> 00:19:31.100
You can't have the C and the
D because they use the same strokes.

00:19:31.160 --> 00:19:34.830
So let's say that the neural net's
pretty good and it's got about an

00:19:34.890 --> 00:19:37.370
80% probability that that's an L.

00:19:37.380 --> 00:19:41.160
Well, I've deliberately jury-rigged
the numbers so that that looks

00:19:41.280 --> 00:19:44.290
like 0.9 times 0.8 is 0.72.

00:19:44.900 --> 00:19:50.060
So 72% chance that the
theory so far is CL.

00:19:50.060 --> 00:19:51.660
72% chance that that's right.

00:19:51.700 --> 00:19:55.810
Well, and I assigned 70% to the D.

00:19:55.820 --> 00:19:59.110
So, so far,
our little engine thinks that it's

00:19:59.110 --> 00:20:01.490
more likely to be CL than it is D.

00:20:05.360 --> 00:20:07.770
Okay, well,
when the O stroke comes along,

00:20:07.770 --> 00:20:09.450
let's say it's pretty good.

00:20:09.450 --> 00:20:12.960
There's an interesting thing going
on here that it almost doesn't matter

00:20:12.960 --> 00:20:15.130
what that probability is at this point.

00:20:15.140 --> 00:20:18.300
The CLO is going to win over the
DO because the CL won over the D,

00:20:18.300 --> 00:20:21.020
and that's going to be true
when we bring up the G.

00:20:23.200 --> 00:20:25.440
You multiply those
probabilities together,

00:20:25.440 --> 00:20:28.070
and indeed, ever so slightly the way
I've jury-rigged the numbers,

00:20:28.070 --> 00:20:29.250
it would probably pick clog.

00:20:29.250 --> 00:20:33.300
But in fact, as I mentioned earlier,
it's guided by context.

00:20:33.300 --> 00:20:36.660
We have a language model that's fairly
complex that's guiding all this,

00:20:36.660 --> 00:20:39.020
and you can write outside
of the dictionaries.

00:20:39.020 --> 00:20:40.780
You don't have to write
in the dictionaries.

00:20:40.780 --> 00:20:47.130
It's a loosely applied language model,
but it does guide the search.

00:20:47.210 --> 00:20:51.800
And so if you were searching with
the pet philosophy news group

00:20:52.330 --> 00:20:55.410
where the only words were cat,
dog, and dogma,

00:20:56.440 --> 00:21:00.930
That would guide the search,
and so the only viable path through that

00:21:00.930 --> 00:21:05.540
graph of the language model would be dog,
and so really dog would win.

00:21:09.260 --> 00:21:15.000
And there's tons more information
actually published available on the web

00:21:15.010 --> 00:21:16.600
that we'll give you a URL for later.

00:21:16.600 --> 00:21:20.400
Okay, so given that the recognition
engine is sitting under there

00:21:20.400 --> 00:21:24.170
ready to provide these answers,
let's take a look at how the data

00:21:24.180 --> 00:21:27.700
flows through the system before
it gets to your application.

00:21:27.720 --> 00:21:31.750
And again, you don't have to worry about
every little detail in here,

00:21:31.760 --> 00:21:36.040
but hopefully this will give you
an idea enough about how things are

00:21:36.130 --> 00:21:40.240
working that it'll make sense when
you do have to make calls to make

00:21:40.440 --> 00:21:41.830
things happen just the way you want.

00:21:41.900 --> 00:21:43.850
You'll understand why those
are the right things to do.

00:21:43.860 --> 00:21:47.080
So initially, data comes in through
the graphics tablet.

00:21:47.080 --> 00:21:52.750
That tablet data is fed into,
really this is kind of two

00:21:52.750 --> 00:21:55.330
layers in this next block,
but I just lumped them together

00:21:55.330 --> 00:21:57.060
to fit it on the slide gracefully.

00:21:57.060 --> 00:22:02.240
There's a tablet driver
living at the IOHID layer,

00:22:02.240 --> 00:22:09.440
and what it's really emitting is,
mouse events with tablet data in them.

00:22:09.440 --> 00:22:13.350
So they really are true, honest to God,
first rate citizen mouse events,

00:22:13.360 --> 00:22:16.640
but they also have this block of
data that has to do with pressure

00:22:16.640 --> 00:22:21.000
and orientation of the pen and all
the special things that pens can do.

00:22:21.000 --> 00:22:22.150
Okay.

00:22:22.900 --> 00:22:26.770
Those mouse event plus tablidator are
fed through a core graphics layer,

00:22:26.770 --> 00:22:27.580
of course.

00:22:27.580 --> 00:22:31.290
And the core graphics layer does
something very special for us.

00:22:31.290 --> 00:22:34.630
You may have noticed while
Giulia was demoing ink text

00:22:34.630 --> 00:22:38.110
and some of the other things,
she did not have to write in

00:22:38.330 --> 00:22:40.020
any of ink text's windows.

00:22:40.020 --> 00:22:42.610
She could write off
apparently on the desktop.

00:22:42.730 --> 00:22:45.010
We call that our write anywhere model.

00:22:45.020 --> 00:22:47.790
And it's something the
user can turn on or off,

00:22:47.790 --> 00:22:52.410
but we turn it on by default if you
turn ink on at all because it's deemed,

00:22:52.420 --> 00:22:52.680
we call it a write anywhere model.

00:22:52.700 --> 00:22:56.030
We think it's an easy way to interact
with the system when you're using a pen.

00:22:56.250 --> 00:22:58.910
Basically, you write where you want to,
the recognition results

00:22:58.910 --> 00:23:00.440
flow to the insertion point.

00:23:00.440 --> 00:23:04.540
So core graphics is sitting there,
and if this mouse event coming

00:23:04.540 --> 00:23:09.010
through the pipeline has tablet data
in it and recognition is enabled,

00:23:09.010 --> 00:23:13.110
and we've told it that in the background,
then it will route those

00:23:13.110 --> 00:23:15.150
events to the frontmost app.

00:23:15.240 --> 00:23:18.580
That's going to be important
later because you might very well,

00:23:18.580 --> 00:23:21.200
in the process of handling
ink-related events,

00:23:21.200 --> 00:23:22.680
get points that lie out there.

00:23:22.700 --> 00:23:24.640
So you can write outside your windows,
and you kind of need to know that.

00:23:24.720 --> 00:23:28.570
Okay, so there's one other thing
that core graphics does for us.

00:23:28.690 --> 00:23:31.740
If we're going to allow you
to write outside of windows

00:23:31.740 --> 00:23:35.570
and write all over the screen,
well, there are some places where

00:23:35.600 --> 00:23:38.650
you're going to put the pen,
the user is going to put the

00:23:38.770 --> 00:23:42.450
pen down that they really want
it to just behave like a mouse.

00:23:42.480 --> 00:23:44.580
When you put it down in the
drag region of a window,

00:23:44.580 --> 00:23:48.000
you don't want to have it start writing
while you're trying to drag the window.

00:23:48.000 --> 00:23:50.890
If you put it down in the scroll bar,
you don't want it to start writing while

00:23:50.890 --> 00:23:52.480
you're trying to scroll the window.

00:23:52.700 --> 00:23:55.260
And the dock is the same way.

00:23:55.260 --> 00:23:59.130
So we've invented this idea
of instant mousing regions,

00:23:59.190 --> 00:24:02.780
and so there are certain
special places that if the pen

00:24:02.780 --> 00:24:06.750
lands in one of these regions,
it will instantly behave as

00:24:06.750 --> 00:24:08.910
a mouse instead of inking.

00:24:08.920 --> 00:24:12.960
And so core graphics has its own idea
of a few very special places like the

00:24:12.960 --> 00:24:17.130
menu bar and the dock that are known,
and the draggable regions of windows

00:24:17.130 --> 00:24:20.870
that are server-side dragged,
that it knows to go ahead

00:24:20.870 --> 00:24:22.580
and treat instantly.

00:24:22.700 --> 00:24:24.420
as a mouse.

00:24:25.830 --> 00:24:30.540
Then we take-- so it finally still emits
just a mouse event with tablet data in.

00:24:30.690 --> 00:24:34.530
And this is now we're getting into
your application context area.

00:24:34.660 --> 00:24:37.900
But first, our input method,
our text services manager,

00:24:38.110 --> 00:24:41.660
TSM input method,
gets a chance at the data first.

00:24:41.770 --> 00:24:45.090
We have our own idea
about instant mousing.

00:24:45.200 --> 00:24:50.480
And we take care of some things for you,
like most controls in the user interface

00:24:51.120 --> 00:24:53.310
probably want to be instant mousers.

00:24:53.450 --> 00:24:54.580
Well, we know about that.

00:24:54.660 --> 00:24:57.800
So all your standard
Carbon and Cocoa controls are

00:24:57.800 --> 00:25:00.980
automatically instant mousers,
except for the ones that--where we

00:25:00.980 --> 00:25:02.980
think you ought to be able to write.

00:25:03.060 --> 00:25:06.100
There's going to be a way
for you to manage your own

00:25:06.100 --> 00:25:08.190
custom controls in a minute.

00:25:08.680 --> 00:25:11.990
As Giulia said,
we gather that ink data up into strokes.

00:25:12.100 --> 00:25:15.930
We add those strokes to the idea of
this current phrase and eventually

00:25:15.930 --> 00:25:18.510
get around to terminating the phrase,
as Giulia said.

00:25:18.520 --> 00:25:20.410
We send that off to the recognizer.

00:25:20.410 --> 00:25:21.780
We get the results back.

00:25:21.840 --> 00:25:25.800
And in Jaguar, we post,
first we post a unit code for key

00:25:25.850 --> 00:25:30.610
event so that apps that are already
TSM savvy and looking for that can

00:25:30.660 --> 00:25:33.380
get the whole block of text at once.

00:25:34.130 --> 00:25:36.100
But if you don't handle that,
then by gosh,

00:25:36.100 --> 00:25:37.680
we turn it into raw key downs.

00:25:37.710 --> 00:25:40.940
So finally,
your application will get the text data

00:25:40.960 --> 00:25:43.460
corresponding to what the user wrote.

00:25:44.840 --> 00:25:46.610
For Panther...

00:25:48.320 --> 00:25:51.940
We still have Unicode for key and
key down at the end of the chain,

00:25:51.980 --> 00:25:57.150
but we've just introduced four
events that let you manage what

00:25:57.210 --> 00:25:59.560
happens with ink in your application.

00:25:59.830 --> 00:26:04.620
There's an instant mouser event
that lets you decide if some special

00:26:04.620 --> 00:26:09.740
region on your document layout
needs to be an instant mouser.

00:26:09.790 --> 00:26:14.290
Hopefully there won't be any of those,
but this lets you manage it just in case.

00:26:15.450 --> 00:26:19.240
We send an ink point event for
each of the points that comes in

00:26:19.470 --> 00:26:23.590
that we think should be inking.

00:26:23.890 --> 00:26:27.030
Now, I've talked about instant mousing
and write anywhere and all that.

00:26:27.440 --> 00:26:31.680
There's always this decision going on
when a person is using a pen whether

00:26:31.680 --> 00:26:34.370
it is supposed to be mousing or inking.

00:26:34.380 --> 00:26:36.720
And there's a fair bit of logic.

00:26:36.720 --> 00:26:39.060
We queue events up and wait
until they've moved far enough,

00:26:39.110 --> 00:26:42.070
soon enough, and to make a decision that,
yeah, they really think they're

00:26:42.070 --> 00:26:44.270
inking and all these things,
and they're not in the right

00:26:44.300 --> 00:26:45.280
place on the screen and so on.

00:26:45.870 --> 00:26:48.800
So we do have all this logic in
place to take care of that for you.

00:26:48.800 --> 00:26:52.000
If you install an ink
point event handler,

00:26:52.000 --> 00:26:57.360
you will only get these events when we've
already done all that and decided that,

00:26:57.410 --> 00:26:59.780
yeah, really, the person thinks they're
writing at this point,

00:26:59.800 --> 00:27:02.890
or at least that's our system view
of when they ought to be writing.

00:27:02.900 --> 00:27:05.480
So if you want to, for example,
draw your own ink,

00:27:05.490 --> 00:27:08.990
you have a calligraphy application
where you want to pay attention to

00:27:08.990 --> 00:27:12.860
pen orientation and all these things
and produce really beautiful ink.

00:27:13.400 --> 00:27:15.020
Basically,
you can tell us to stop drawing.

00:27:15.910 --> 00:27:18.150
Handle the ink point event
and do what you want with it.

00:27:18.240 --> 00:27:20.610
And yet,
you'll get the same user interface

00:27:20.610 --> 00:27:23.630
for your application as every
other ink aware or non-ink

00:27:23.630 --> 00:27:25.710
aware application in the system.

00:27:27.190 --> 00:27:33.830
Okay, the Ink Gesture event allows you to
intercept those gestures that Giulia

00:27:33.900 --> 00:27:38.620
was showing you so that when you want
to provide targeted gesture support,

00:27:38.620 --> 00:27:40.960
you just put in an
Ink Gesture event handler,

00:27:40.960 --> 00:27:43.550
and now we'll send you things
when the user has written one

00:27:43.560 --> 00:27:45.000
of these special gestures.

00:27:45.000 --> 00:27:49.520
Finally, there's the Ink Text event,
and that's what provides that ink text

00:27:49.610 --> 00:27:53.990
ref that Giulia described that lets
you provide the correction model with

00:27:53.990 --> 00:27:56.340
the alternate word list and so on.

00:28:01.680 --> 00:28:04.360
Okay, now I'm going to do a
quick run through the APIs.

00:28:04.430 --> 00:28:05.840
This is not the in-depth portion.

00:28:05.840 --> 00:28:08.840
You're going to get a really good
walkthrough by Brad Reigel in a minute,

00:28:08.840 --> 00:28:12.170
who's going to show you how to actually,
you know, sample code,

00:28:12.170 --> 00:28:15.840
show you how to actually use them
in some very specific examples.

00:28:15.840 --> 00:28:23.350
This is an attempt to give you a broad
overview so you know what to draw

00:28:23.360 --> 00:28:25.530
from and what's possible in addition
to the specifics that you'll see.

00:28:28.320 --> 00:28:30.700
Okay, I mentioned those four events.

00:28:30.700 --> 00:28:31.840
There they are.

00:28:31.850 --> 00:28:34.270
Don't need to go through them again
because we've just talked through them.

00:28:34.390 --> 00:28:37.360
There's the instant mouser,
there's the ink point,

00:28:37.360 --> 00:28:40.800
there's the ink gesture,
and the ink text.

00:28:44.020 --> 00:28:47.440
This is the,
there's only one object in the ink world,

00:28:47.440 --> 00:28:48.810
and that is the ink text ref.

00:28:49.700 --> 00:28:55.140
And there are a very limited set,
but hopefully fully flexible

00:28:55.140 --> 00:28:56.640
set of ink text APIs.

00:28:56.640 --> 00:28:59.560
There's,
you can find out how many of those

00:28:59.610 --> 00:29:02.200
recognition alternates there are.

00:29:02.270 --> 00:29:05.340
There will never be more than five.

00:29:06.420 --> 00:29:12.280
You can find out, you can get the
CFString for the top choice,

00:29:12.280 --> 00:29:14.300
or the second choice, or third,
or whatever.

00:29:15.850 --> 00:29:21.550
You can get, you can hand us a menu ref,
and we will populate it for

00:29:21.550 --> 00:29:23.720
you with all those alternates.

00:29:23.810 --> 00:29:26.550
So it's very easy to create this.

00:29:26.580 --> 00:29:28.580
You can just, in fact,
that'll be an example,

00:29:28.580 --> 00:29:29.490
so you'll see that.

00:29:33.420 --> 00:29:37.360
You can find out what modifiers,
keyboard modifiers, were held down while

00:29:37.360 --> 00:29:38.160
the user was writing.

00:29:38.160 --> 00:29:40.140
There may be occasions
where that's useful.

00:29:40.140 --> 00:29:43.560
You can grab a copy of a text ref.

00:29:43.610 --> 00:29:45.390
You can find out its bounds.

00:29:45.390 --> 00:29:47.900
You can draw it into a
rect that you specify.

00:29:47.900 --> 00:29:49.570
You can flatten it.

00:29:49.660 --> 00:29:54.800
That just means you collapse the
data structures into a contiguous

00:29:55.060 --> 00:29:59.080
block of memory into a CFDataRef that
you can write out to disk,

00:29:59.220 --> 00:30:00.560
should you want to save
any of these things.

00:30:01.020 --> 00:30:05.460
And the counterpart to that is that
you can do a create from CFDataRef.

00:30:10.310 --> 00:30:16.980
There are a few Ink state APIs that let
you query the state of the system and set

00:30:17.080 --> 00:30:20.040
the state of the system in certain cases.

00:30:20.040 --> 00:30:23.700
For example, you can find out that--

00:30:24.350 --> 00:30:26.290
I can't even see it, but oh, there we go.

00:30:26.420 --> 00:30:30.180
Ink user writing mode.

00:30:30.530 --> 00:30:33.550
That lets you find out if the
user has basically turned on that

00:30:33.550 --> 00:30:35.850
write anywhere option or not.

00:30:35.910 --> 00:30:41.020
And the alternative to write anywhere
is write only in ink-aware applications,

00:30:41.020 --> 00:30:43.500
which is what you'll be writing.

00:30:43.500 --> 00:30:48.520
The ink set application writing mode,
as opposed to the user writing mode,

00:30:48.590 --> 00:30:53.460
allows you to basically tell the system
that you are one of those ink-aware

00:30:53.460 --> 00:30:59.180
applications that ink should work in when
the user has turned off write anywhere.

00:31:02.520 --> 00:31:07.780
Ink set application recognition mode
lets you control text recognition

00:31:07.780 --> 00:31:12.350
versus gesture recognition and
appropriate combinations of those.

00:31:12.400 --> 00:31:16.860
Set phrase termination mode allows
you to take control over when

00:31:16.860 --> 00:31:21.880
and how phrases are terminated,
including if you want to eliminate R,

00:31:21.880 --> 00:31:24.200
handling of it altogether,
and have it only terminate a

00:31:24.200 --> 00:31:27.020
phrase when the user presses
an I'm done writing button.

00:31:27.020 --> 00:31:28.670
And you'll get an example of that.

00:31:30.140 --> 00:31:32.660
And ink is phrase in progress.

00:31:32.680 --> 00:31:37.130
Well,
that's important for an API I'm about to

00:31:37.130 --> 00:31:42.410
show you that if you think you're going
to handle control terminating the phrase,

00:31:42.420 --> 00:31:44.520
well, it's probably best to make sure
there's actually one in progress

00:31:44.600 --> 00:31:45.600
before you go terminating it.

00:31:47.880 --> 00:31:54.720
And the only public structure
from ink is this ink point.

00:31:54.840 --> 00:31:56.270
It contains just three things.

00:31:56.410 --> 00:32:00.470
The, the HI point, the location on the
screen where it happened.

00:32:00.790 --> 00:32:03.200
It gives you the tablet point rec.

00:32:03.310 --> 00:32:06.800
That's defined in carbonevents.h.

00:32:06.940 --> 00:32:11.420
It's standard data structure that's
passed up all the way from the tablet,

00:32:11.610 --> 00:32:14.130
the tablet driver and on.

00:32:14.240 --> 00:32:16.630
And the keyboard modifiers
that were held down.

00:32:16.690 --> 00:32:19.780
Basically,
it's everything that we know about the

00:32:19.780 --> 00:32:22.840
state under which this ink was written.

00:32:23.510 --> 00:32:26.030
There's ink add stroke to current phrase.

00:32:26.140 --> 00:32:28.740
Now,
especially if you're a device-specific

00:32:28.930 --> 00:32:32.550
solution where you have a bunch of
data that you want to pass all at

00:32:32.610 --> 00:32:37.000
once to have recognition performed on,
it doesn't involve the

00:32:37.000 --> 00:32:40.340
user writing real time,
you'll probably be adding a stroke

00:32:40.340 --> 00:32:43.990
at a time to the current phrase
until your idea of a phrase is done,

00:32:43.990 --> 00:32:47.490
at which point you'll call
ink terminate current phrase.

00:32:49.540 --> 00:32:55.030
And add stroke to current phrase
just passes an array of ink points.

00:32:57.120 --> 00:32:59.120
Okay, with that,
I think I'll hand it over to Brad.

00:32:59.140 --> 00:33:03.370
Brad will take you through some specific
examples of applying these things.

00:33:08.120 --> 00:33:09.770
Thank you, Larry.

00:33:09.910 --> 00:33:11.380
Good afternoon, everyone.

00:33:11.400 --> 00:33:13.580
We're going to take a look
at some developer scenarios.

00:33:13.680 --> 00:33:16.520
Basically,
we're going to walk through the APIs that

00:33:16.520 --> 00:33:20.210
Larry just briefly introduced and see
how we can use some of them in our

00:33:20.310 --> 00:33:24.370
applications to go beyond the basic
services that you already get in Jaguar,

00:33:24.370 --> 00:33:27.370
allow you to provide more
functionality for your users to

00:33:27.530 --> 00:33:29.520
take advantage of their tablets.

00:33:30.780 --> 00:33:35.040
We're going to take a look at three basic
applications or three basic scenarios.

00:33:35.040 --> 00:33:39.080
First one's going to be text engines,
ways that text engines can take advantage

00:33:39.100 --> 00:33:43.380
of the functionality we provide and
make better use of ink services.

00:33:43.380 --> 00:33:45.690
Second one is going to be input devices.

00:33:45.710 --> 00:33:48.020
These are going to be,
you've got your own

00:33:48.020 --> 00:33:51.610
whiteboard or pen or whatever,
and you want to be able to provide

00:33:51.610 --> 00:33:55.490
a custom solution for your users
that takes advantage of handwriting

00:33:55.490 --> 00:33:57.920
recognition through ink services.

00:33:57.920 --> 00:33:59.290
All right.

00:33:59.500 --> 00:34:02.810
And the third one is
controlling phrase termination.

00:34:02.940 --> 00:34:04.340
It's not really an application,
obviously.

00:34:04.340 --> 00:34:08.630
It's applications that wanted to
control when phrases are terminated.

00:34:08.640 --> 00:34:11.440
They don't want to use the standard
termination that we have in place.

00:34:11.440 --> 00:34:15.820
They may want to do something custom
because of the way that users would

00:34:15.920 --> 00:34:20.050
input text into their application,
things along those lines.

00:34:20.280 --> 00:34:22.410
I'm not going to go
through in-depth the APIs.

00:34:22.520 --> 00:34:25.210
We've actually got full documentation,
believe it or not.

00:34:25.290 --> 00:34:26.350
We have two documents.

00:34:26.350 --> 00:34:29.470
One's a reference document that
actually goes through all the APIs and

00:34:29.610 --> 00:34:31.170
describes all of them in depth.

00:34:31.250 --> 00:34:33.990
And we have an overview document
that talks about a lot of what

00:34:34.020 --> 00:34:35.660
we're talking about here today.

00:34:38.920 --> 00:34:42.320
So first we're going to
take a look at text engines.

00:34:42.520 --> 00:34:43.700
In this case,
we're going to look at first

00:34:43.840 --> 00:34:47.820
how your text engine can
interact directly with gestures.

00:34:47.820 --> 00:34:52.080
So as Giulia showed earlier in Jaguar,
right now you already get

00:34:52.080 --> 00:34:55.650
support with gestures,
but only untargeted.

00:34:56.120 --> 00:35:00.730
Basically what this means is if the
user were to write a cut gesture,

00:35:00.810 --> 00:35:05.460
clear space, things like that,
it only applies to the current selection.

00:35:05.680 --> 00:35:09.960
So you can use whatever the
selection is or the insertion point.

00:35:09.960 --> 00:35:12.770
So in this case, you'll notice up at
the top of the screen,

00:35:12.770 --> 00:35:16.040
we have an example of,
and this actually was done on

00:35:16.170 --> 00:35:17.700
InkPad at InkAware application.

00:35:19.350 --> 00:35:21.060
You have the cut gesture.

00:35:21.080 --> 00:35:22.750
In this case,
you'll notice that the insertion point,

00:35:22.750 --> 00:35:23.600
there's no selection.

00:35:23.600 --> 00:35:26.420
The insertion point is sitting
down next to the word menu,

00:35:26.420 --> 00:35:30.840
but we're actually using the cut gesture
to target cutting the word contextual.

00:35:30.870 --> 00:35:33.760
It doesn't matter where the selection is,
where the insertion point is.

00:35:34.040 --> 00:35:37.400
Your users can use those gestures
to directly interact with text,

00:35:37.400 --> 00:35:40.560
objects, whatever makes sense
for your application.

00:35:41.220 --> 00:35:43.570
The bottom of the screen,
you'll see another example,

00:35:43.570 --> 00:35:44.880
which is the clear gesture.

00:35:44.880 --> 00:35:49.020
In this case, Giulia showed you earlier,
you can write the clear gesture today,

00:35:49.020 --> 00:35:51.240
and it simply clears,
deletes whatever the

00:35:51.240 --> 00:35:52.610
current selection is.

00:35:52.620 --> 00:35:55.680
In this case,
you'll see that the insertion point

00:35:55.680 --> 00:35:59.880
is at the end of the phrase there,
but we're actually going to clear,

00:36:00.190 --> 00:36:05.300
delete the word recognition right out of
the middle of the phrase using gestures.

00:36:05.300 --> 00:36:07.500
So how do you do this?

00:36:13.650 --> 00:36:16.790
You do this using the Ink Gesture
Event that Larry referred to.

00:36:16.800 --> 00:36:19.460
Ink Gesture Event is
pretty straightforward.

00:36:19.460 --> 00:36:20.980
It's only got three parameters.

00:36:20.980 --> 00:36:23.190
The first parameter is
just what type of gesture,

00:36:23.290 --> 00:36:23.900
what kind.

00:36:23.900 --> 00:36:28.100
It could be clear, it could be undo, cut,
copy, paste.

00:36:28.100 --> 00:36:31.040
If you look in the Ink Pref pane,
it actually has one of the panels

00:36:31.040 --> 00:36:33.920
in there that lists out all
the gestures that we support.

00:36:34.740 --> 00:36:37.310
The other two parameters are
the bounds of the gesture.

00:36:37.310 --> 00:36:39.750
This is just the global
coordinates on the screen where

00:36:39.750 --> 00:36:41.270
the user wrote that gesture.

00:36:41.270 --> 00:36:43.060
And the last one is the hotspot.

00:36:43.060 --> 00:36:47.200
And we'll take a look at those two and
see how you take advantage of those.

00:36:50.720 --> 00:36:53.370
So hotspots and bounds.

00:36:53.670 --> 00:36:58.680
You need to pay attention to this in
order to support targeted gestures.

00:36:58.800 --> 00:37:02.100
On the upper corner up here,
you've got the cut gesture.

00:37:02.360 --> 00:37:05.870
And you'll notice that there's a red
circle around the very beginning point.

00:37:05.880 --> 00:37:10.600
Basically,
you write the cut gesture starting

00:37:10.600 --> 00:37:13.380
from that bottom point going up.

00:37:13.380 --> 00:37:13.380
The hotspot is treated as the
starting point for that gesture.

00:37:13.600 --> 00:37:16.840
So when you're interacting with gestures,
you're going to look at that point

00:37:16.990 --> 00:37:20.030
to determine what piece of text is
the user trying to interact with,

00:37:20.030 --> 00:37:22.420
what object is the user
trying to interact with.

00:37:22.500 --> 00:37:25.900
The other corner,
we've got the space gesture.

00:37:25.900 --> 00:37:29.060
In this case,
the hotspot is actually the uppermost

00:37:29.060 --> 00:37:32.360
point of that upside-down V,
however you want to describe it.

00:37:32.380 --> 00:37:35.760
And wherever that point lands is
where you're going to insert a space.

00:37:35.760 --> 00:37:38.210
So once again,
as we saw in the screenshot a minute ago,

00:37:38.210 --> 00:37:40.340
it doesn't matter where
the insertion point is,

00:37:40.340 --> 00:37:41.570
what the selection is.

00:37:42.040 --> 00:37:46.690
You can take a look at the gesture and
the hotspot of it and do the right thing.

00:37:46.700 --> 00:37:50.980
The bottom of the screen,
we've got the join gesture.

00:37:50.980 --> 00:37:56.580
This is one, as Giulia mentioned earlier,
the join gesture is actually

00:37:56.580 --> 00:37:59.050
one where it depends upon where
it's written on the screen,

00:37:59.150 --> 00:37:59.960
how it's handled.

00:37:59.960 --> 00:38:02.240
And in this case,
you want to take a look at

00:38:02.240 --> 00:38:03.900
the bounds of the gesture.

00:38:03.900 --> 00:38:05.340
There's not a single hotspot.

00:38:05.340 --> 00:38:06.420
You take a look at the bounds.

00:38:06.420 --> 00:38:08.970
And for this one,
the bounds are the upper

00:38:08.970 --> 00:38:11.880
two most corners of,
sorry, the hotspots, really.

00:38:11.960 --> 00:38:15.610
That you're looking at are the
upper two points for the bounds.

00:38:15.620 --> 00:38:18.880
And you're going to take a look
at those two points and say,

00:38:18.880 --> 00:38:20.960
okay, did those land on text?

00:38:20.960 --> 00:38:25.280
If so, I want to treat it as a join,
join those two pieces of text together.

00:38:25.280 --> 00:38:28.100
If they didn't land on text,
you're actually going to end up returning

00:38:28.460 --> 00:38:30.200
event not handled for that gesture.

00:38:30.200 --> 00:38:35.180
We'll then turn around and recognize
that gesture as the letter V.

00:38:38.180 --> 00:38:42.100
So real quickly,
it's just a standard event handler.

00:38:42.100 --> 00:38:48.500
You'll go through and grab the kind,
grab the hotspot, and grab the bounds,

00:38:48.500 --> 00:38:50.510
and save those off.

00:38:51.090 --> 00:38:54.240
And depending upon which
gesture you've got,

00:38:54.300 --> 00:38:56.000
you're going to do things differently.

00:38:56.060 --> 00:38:58.390
The undo gesture,
if you're getting that one,

00:38:58.400 --> 00:39:00.440
it's not targeted toward anything.

00:39:00.440 --> 00:39:04.250
It's just, if you get an undo gesture,
it's just your standard whatever

00:39:04.250 --> 00:39:06.050
undoes the last user action.

00:39:07.630 --> 00:39:10.570
Currently in Jaguar,
the way we make this work is, in Panther,

00:39:10.610 --> 00:39:12.950
if you don't handle these events,
what we actually end up

00:39:13.000 --> 00:39:14.080
doing is turning around.

00:39:14.080 --> 00:39:17.500
If you don't handle the events,
we turn around, and for undo,

00:39:17.500 --> 00:39:20.540
we end up issuing a command U,
or whatever makes sense,

00:39:20.540 --> 00:39:23.450
the standard command key
shortcuts for those actions.

00:39:23.460 --> 00:39:25.860
So you actually don't
have to handle the undo.

00:39:25.860 --> 00:39:28.500
If you don't,
we'll just end up issuing a command U,

00:39:28.510 --> 00:39:31.130
assuming that your
application supports that.

00:39:32.810 --> 00:39:36.380
So you're walking through,
handling the events.

00:39:36.460 --> 00:39:37.590
First one, the undo gesture.

00:39:37.700 --> 00:39:40.080
Just call your basic undo routine.

00:39:40.080 --> 00:39:42.100
Second one is the cut gesture.

00:39:42.100 --> 00:39:46.140
As we just saw,
cut depends upon a hotspot.

00:39:46.140 --> 00:39:49.050
So you're going to have some
routine that handles that gesture,

00:39:49.090 --> 00:39:51.320
and you're just going
to hand it the hotspot.

00:39:51.320 --> 00:39:56.230
And if the hotspot lands on text,
then you want to cut whatever object

00:39:56.230 --> 00:40:01.110
or text that gesture lands on top of,
the hotspot lands on top of.

00:40:01.140 --> 00:40:02.580
If you determine that the
hotspot lands on text,

00:40:02.580 --> 00:40:02.680
then you want to cut whatever object
or text that gesture lands on top of.

00:40:02.700 --> 00:40:07.010
If the hotspot landed somewhere outside
of text or not on an object or whatever,

00:40:07.030 --> 00:40:10.280
you'll probably want to handle
that as just cutting whatever

00:40:10.320 --> 00:40:12.920
the current selection is,
whatever makes sense

00:40:12.920 --> 00:40:14.370
for free application.

00:40:14.380 --> 00:40:17.220
The join gesture, as we just looked at,
this one you're going

00:40:17.270 --> 00:40:18.490
to look at the bounds.

00:40:18.490 --> 00:40:22.270
You're going to have a routine that looks
at the upper two points of the bounds,

00:40:22.270 --> 00:40:24.560
determines if they land on text,
and if they do,

00:40:24.620 --> 00:40:27.030
do the right thing for your application.

00:40:27.060 --> 00:40:31.740
And if all that comes back true,
you did handle it and everything.

00:40:32.170 --> 00:40:34.960
You just return no error,
and the event's done with.

00:40:35.000 --> 00:40:38.930
If you determine that that join
gesture didn't land on top of text,

00:40:38.930 --> 00:40:41.810
then you're going to go ahead and
return event not handled error,

00:40:41.990 --> 00:40:46.340
like I said before, and we go ahead,
reprocess that, and treat it as letter V.

00:40:46.340 --> 00:40:47.570
Thank you.

00:40:50.110 --> 00:40:55.010
So second thing we're going to take
a look at is how to implement an

00:40:55.010 --> 00:40:57.240
alternates menu for a text engine.

00:40:57.340 --> 00:41:00.530
So as you saw earlier,
this already supported in the ink pad,

00:41:00.530 --> 00:41:03.840
and it's pretty straightforward,
easy to implement.

00:41:03.840 --> 00:41:08.320
Actually, the ink pad in Panther uses our
public API as well and doesn't

00:41:08.320 --> 00:41:10.330
do anything special with it.

00:41:10.420 --> 00:41:14.990
So in this case,
you've got your text editor, or actually,

00:41:15.040 --> 00:41:20.320
this case has to be a text editor,
and you want to support bringing

00:41:20.320 --> 00:41:24.280
up a list of alternates for
the word that's been selected.

00:41:24.280 --> 00:41:26.270
Usually,
it would be just a contextual menu click

00:41:26.280 --> 00:41:28.660
or whatever makes sense on that word.

00:41:28.690 --> 00:41:31.080
So how do you do that?

00:41:32.290 --> 00:41:35.100
First thing you need to do
is handle the ink text event.

00:41:35.130 --> 00:41:37.730
And as we saw earlier,
the ink text event is sent once

00:41:37.810 --> 00:41:39.460
we've finished recognition.

00:41:39.500 --> 00:41:41.970
The user has written everything they're
going to on the screen for a phrase.

00:41:41.970 --> 00:41:46.710
And we issue one ink text event
per word that we recognize.

00:41:46.720 --> 00:41:49.200
So if the user wrote hello
world or something like that,

00:41:49.200 --> 00:41:51.750
they're going to end up
receiving two ink text events.

00:41:51.800 --> 00:41:56.330
And each text event
contains an ink text ref,

00:41:56.590 --> 00:42:01.490
which, as we saw earlier,
one of the pieces of information it

00:42:01.550 --> 00:42:06.070
contains is the list of alternates,
basically recognition

00:42:06.070 --> 00:42:09.310
choices for that word.

00:42:09.310 --> 00:42:09.310
And you'll end up...

00:42:10.060 --> 00:42:13.040
handling that ink text event.

00:42:13.060 --> 00:42:16.700
Go through the first thing for the
ink text event is-- and actually,

00:42:16.710 --> 00:42:19.700
it's missing off that last slide--
there's actually one other parameter,

00:42:19.700 --> 00:42:22.140
which is, is it a keyboard shortcut?

00:42:22.170 --> 00:42:25.380
Because we handle just single letters,
things like that,

00:42:25.400 --> 00:42:27.790
and you could be holding down a
modifier key at the same time,

00:42:27.790 --> 00:42:31.810
the user could have actually--
can write a command key shortcut

00:42:31.940 --> 00:42:35.860
purely using the tablet without
actually using the keyboard.

00:42:35.930 --> 00:42:38.310
In most cases for your application,
you're probably not going to

00:42:38.310 --> 00:42:39.920
want to treat that as a text.

00:42:39.920 --> 00:42:41.160
You're going to want to allow
that to filter through as a

00:42:41.160 --> 00:42:44.740
standard command key shortcut.

00:42:44.740 --> 00:42:47.940
So first parameter is
just a Boolean that says,

00:42:47.940 --> 00:42:49.700
you know, do we believe this is
a command key shortcut,

00:42:49.900 --> 00:42:52.760
command or control,
along with a single character?

00:42:52.800 --> 00:42:55.660
Assuming it's not,
then you're going to go through and

00:42:55.770 --> 00:42:58.380
extract the ink text ref from the event.

00:42:58.580 --> 00:43:02.300
You're going to call ink text
create CFString with that text ref.

00:43:02.350 --> 00:43:06.780
The zero parameter there just
means it's the topmost choice.

00:43:06.800 --> 00:43:09.900
This is the piece of text that
we think the user just wrote.

00:43:09.940 --> 00:43:12.360
You're then going to take that CFString.

00:43:12.360 --> 00:43:14.970
If your application
doesn't want a CFString,

00:43:15.070 --> 00:43:17.640
you can get the data
out of the CFStringRef.

00:43:17.700 --> 00:43:20.630
But you're then going to
insert that in your document.

00:43:20.630 --> 00:43:24.270
And one of the things you need to do is
when you insert that into your document,

00:43:24.270 --> 00:43:27.570
you also need to take a look at the
ink text ref and keep that around.

00:43:28.500 --> 00:43:32.430
And you need to associate that ink text
ref with the word that you just inserted.

00:43:32.440 --> 00:43:35.270
The reason why is,
as we'll see here in a moment,

00:43:35.300 --> 00:43:38.250
we end up using that ink text ref
to create the alternates menu.

00:43:43.170 --> 00:43:46.040
So you want to implement
an alternates menu.

00:43:46.070 --> 00:43:48.560
One single API does it for you.

00:43:48.690 --> 00:43:50.840
Basically,
you're going to create a menu ref.

00:43:50.840 --> 00:43:53.190
This could be one that you've already
got laying around that you use.

00:43:53.240 --> 00:43:55.640
It's completely up to you
how you want to handle it.

00:43:55.700 --> 00:44:00.340
You pass ink insert alternates and
menu and pass this to the ink text ref.

00:44:00.430 --> 00:44:02.380
This is why we needed to
keep it in that last step.

00:44:02.460 --> 00:44:07.000
That corresponds to that word that the
user is clicking on and your menu ref.

00:44:07.070 --> 00:44:09.850
And we then insert,
just like you saw in that screenshot and

00:44:09.860 --> 00:44:13.570
like you saw in ink pad demo earlier,
we insert the five alternates and we

00:44:13.690 --> 00:44:17.720
actually insert an item that draws the
original ink so that the user then,

00:44:17.720 --> 00:44:20.260
say, they look at it and
that's not what I wanted,

00:44:20.260 --> 00:44:23.300
but then they look at what they wrote,
oh, that was what I wrote.

00:44:23.330 --> 00:44:25.910
They can see it all on the fly there.

00:44:26.090 --> 00:44:28.040
So we insert in the menu.

00:44:28.390 --> 00:44:29.080
It's up to you then.

00:44:29.080 --> 00:44:31.470
You just call pop-up menu select,
contextual menu select,

00:44:31.470 --> 00:44:32.950
whatever makes sense
for your application.

00:44:33.040 --> 00:44:35.720
And when you're done,
you'll just get the selection

00:44:35.740 --> 00:44:37.420
that was made from that menu.

00:44:37.420 --> 00:44:40.890
And that's the piece of text that
you should replace in your document.

00:44:40.900 --> 00:44:43.200
So say they wrote hello.

00:44:43.200 --> 00:44:45.120
It got recognized with a capital H.

00:44:45.290 --> 00:44:47.700
They really wanted a
lowercase h at the beginning.

00:44:47.700 --> 00:44:49.990
The alternate menu
would contain that item.

00:44:50.720 --> 00:44:53.330
If the user selects that,
you go grab that menu item text,

00:44:53.360 --> 00:44:57.020
replace the capitalized
version with the opposite,

00:44:57.020 --> 00:44:59.520
you know, whatever the user chooses.

00:45:01.580 --> 00:45:04.340
And that gives you an alternate menu,
an alternates menu.

00:45:04.350 --> 00:45:10.520
A single API along with a couple of the
menu manager routines will do it for you.

00:45:13.580 --> 00:45:14.960
Third scenario.

00:45:15.020 --> 00:45:19.110
We're going to look at input
devices and how you can create a

00:45:19.110 --> 00:45:21.720
custom solution for your users.

00:45:21.730 --> 00:45:24.640
And the demo, I have a little demo here.

00:45:24.640 --> 00:45:28.100
It's actually pretty,
it's really basic what our demo does,

00:45:28.100 --> 00:45:30.140
just for the sake of simplicity.

00:45:30.140 --> 00:45:33.580
It could vary a lot for whether
or not you've got a pen or

00:45:33.580 --> 00:45:37.400
you could be gathering data
just in a single application.

00:45:37.540 --> 00:45:38.760
It varies a lot.

00:45:38.880 --> 00:45:41.480
But essentially what you're
going to do is collect the

00:45:41.480 --> 00:45:43.130
ink data in your application.

00:45:43.550 --> 00:45:46.340
And then you're going to tell
us to perform recognition on it.

00:45:46.440 --> 00:45:50.490
And let me show you a demo real
quick here of what I'm talking about.

00:45:54.250 --> 00:45:59.480
So we've got a simple application here,
and all it does is it's got an

00:46:00.220 --> 00:46:03.820
area in the window here where
it's going to collect data.

00:46:03.830 --> 00:46:06.700
And in this case, I'm using a tablet,
but that's just because I'm

00:46:06.700 --> 00:46:08.280
used to inputting it that way.

00:46:08.280 --> 00:46:11.510
This application, though,
turns off ink recognition.

00:46:11.510 --> 00:46:12.820
We don't get in the way at all.

00:46:12.820 --> 00:46:18.510
The application itself ends up
collecting the mouse events.

00:46:20.740 --> 00:46:21.940
and draws them on the screen.

00:46:21.940 --> 00:46:24.940
So you'll see, you know,
this is not the standard black,

00:46:24.960 --> 00:46:25.800
all that kind of stuff.

00:46:25.800 --> 00:46:28.660
The application is actually
drawing all this on their own.

00:46:28.760 --> 00:46:33.460
They're collecting the data and then
they end up sending us that data.

00:46:33.500 --> 00:46:34.920
We perform recognition on it.

00:46:34.930 --> 00:46:38.450
And just like the standard behavior is,
we end up sending a series

00:46:38.450 --> 00:46:41.630
of ink text events and then
you get the text out of that.

00:46:41.640 --> 00:46:46.810
So let me show you how we do that.

00:46:49.840 --> 00:46:53.100
So first thing you're going to do,
set the recognition state with

00:46:53.100 --> 00:46:54.560
ink set application writing mode.

00:46:54.560 --> 00:46:57.540
And you're going to tell us,
don't do any recognition.

00:46:57.580 --> 00:47:00.160
Don't allow writing with ink
services in your application.

00:47:00.160 --> 00:47:02.230
I'm going to handle it all on my own.

00:47:02.410 --> 00:47:05.190
For our demo app here, like I said,
for sake of simplicity,

00:47:05.190 --> 00:47:07.000
we're just looking at mouse events.

00:47:07.110 --> 00:47:10.650
Depending upon your device and such,
you could gather the data in

00:47:10.650 --> 00:47:12.580
whatever manner you wanted to.

00:47:13.090 --> 00:47:16.440
And as we looked at earlier,
we gather data just

00:47:16.440 --> 00:47:17.840
like we do internally.

00:47:17.840 --> 00:47:19.940
You're going to want to
gather data into strokes.

00:47:19.940 --> 00:47:21.880
And strokes are simply,
as we said earlier,

00:47:21.880 --> 00:47:27.260
a basically mouse down, mouse drag,
mouse up sequence defines one stroke.

00:47:27.260 --> 00:47:30.390
So you're going to gather data,
and once you've gathered

00:47:30.400 --> 00:47:33.560
an entire stroke,
you're just going to call ink add stroke

00:47:33.600 --> 00:47:37.990
to current phrase and send us the stroke
along with how many points are in there,

00:47:37.990 --> 00:47:40.570
and we start building
up a phrase for you.

00:47:41.280 --> 00:47:43.500
You continue doing this,
iterating through for each stroke

00:47:43.590 --> 00:47:46.100
that you've gathered data for,
and when you're finished,

00:47:46.100 --> 00:47:49.410
you call ink terminate current phrase,
and we go ahead and perform

00:47:49.410 --> 00:47:51.140
recognition at that point.

00:47:53.340 --> 00:47:56.360
So the code to do it, initial setup.

00:47:56.360 --> 00:47:59.050
In this case,
we just have a mouse event handler.

00:47:59.300 --> 00:48:02.480
We turn off automatic
recognition for our application.

00:48:02.540 --> 00:48:04.860
Don't want Inkwell getting in the way.

00:48:05.720 --> 00:48:07.940
And then we just have a
simple mouse event handler.

00:48:07.960 --> 00:48:09.680
And as we go through,
we're going to look for

00:48:09.830 --> 00:48:11.480
first a mouse down event.

00:48:11.520 --> 00:48:14.090
When we see that first one,
we'll go ahead and start

00:48:14.090 --> 00:48:17.340
a new array of ink points,
start building that up.

00:48:17.410 --> 00:48:20.520
So you get a mouse down,
a series of mouse drag events.

00:48:20.580 --> 00:48:22.420
For each mouse drag event,
you're just going to continue

00:48:22.420 --> 00:48:25.150
building on your array of ink points.

00:48:25.360 --> 00:48:27.770
And when you get a
mouse-up event in our case,

00:48:27.770 --> 00:48:30.950
or whatever defines a
stroke for your case,

00:48:30.950 --> 00:48:34.270
you'll call inkaddstroke
to current phrase,

00:48:34.350 --> 00:48:38.480
send us that array and the
number of points in that array,

00:48:38.620 --> 00:48:41.580
and continue on in that loop.

00:48:42.110 --> 00:48:44.390
And when you finish gathering the data,
you just call ink

00:48:44.390 --> 00:48:47.020
terminate current phrase,
no parameters or anything to it.

00:48:47.160 --> 00:48:49.740
We terminate the phrase that you
were sending us the data for.

00:48:49.740 --> 00:48:53.360
We perform the recognition,
send a series of ink text events

00:48:53.360 --> 00:48:57.040
for each word that we recognized,
and business as usual.

00:49:00.050 --> 00:49:04.040
So last scenario we're going to look
at are controlling phrase termination.

00:49:04.040 --> 00:49:11.190
This is applications where your user may
be interacting with your application in,

00:49:11.270 --> 00:49:13.200
I don't want to say a nonstandard way,
but you want to control

00:49:13.270 --> 00:49:14.460
when phrases are terminated.

00:49:14.460 --> 00:49:17.180
You want to control when
you're getting the data.

00:49:17.180 --> 00:49:20.710
You want the user to be able to
continue writing until the user said,

00:49:20.740 --> 00:49:21.940
I'm done with this.

00:49:21.940 --> 00:49:25.420
We're going to do this by looking
at the ink point events that we

00:49:25.450 --> 00:49:29.820
talked about earlier and by doing
your own custom phrase termination.

00:49:30.010 --> 00:49:35.190
So let me show you a quick
demo of that as well.

00:49:35.190 --> 00:49:35.190
That will show you.

00:49:35.940 --> 00:49:41.880
So in this case, it's just a window.

00:49:41.880 --> 00:49:44.680
And we don't do anything special
here except for the fact that we

00:49:44.960 --> 00:49:48.700
have an API that says turn off
automatic phrase termination.

00:49:48.700 --> 00:49:53.010
So in this case,
the application is in complete control.

00:49:58.490 --> 00:50:00.920
And as Giulia was saying earlier,
say the phone rings.

00:50:00.920 --> 00:50:03.280
Oh, I want to go answer
the phone or whatever.

00:50:03.280 --> 00:50:05.290
Whatever makes sense
for your application.

00:50:05.350 --> 00:50:06.880
Notice I've taken the pen away.

00:50:06.880 --> 00:50:08.160
I'm waiting a really long time.

00:50:08.160 --> 00:50:09.480
No termination is happening.

00:50:09.480 --> 00:50:11.180
You're in complete control of it.

00:50:11.350 --> 00:50:14.460
The thing you need to keep in mind here
is you're in complete control of it.

00:50:14.460 --> 00:50:18.180
The phrase will not get terminated until
your application says to terminate it.

00:50:18.300 --> 00:50:21.700
So this ink will stay
here until you finish.

00:50:22.600 --> 00:50:24.240
So we have a button
down here at the bottom,

00:50:24.240 --> 00:50:28.200
and if I actually clicked on it,
there we go.

00:50:28.220 --> 00:50:30.160
And we've terminated the phrase.

00:50:30.160 --> 00:50:31.550
Recognition happens.

00:50:31.550 --> 00:50:33.000
We send ink text events.

00:50:33.000 --> 00:50:34.440
We get the data out of it.

00:50:34.440 --> 00:50:36.960
Go along from there, business as usual.

00:50:36.960 --> 00:50:39.060
How we do that...

00:50:42.010 --> 00:50:46.160
So one step back, as we said,
automatic termination can be turned

00:50:46.160 --> 00:50:47.960
off using ink set phrase termination.

00:50:47.960 --> 00:50:50.900
Giulia went through earlier when
termination happens normally.

00:50:50.900 --> 00:50:52.820
You actually also have
finer grain of control.

00:50:52.820 --> 00:50:55.720
You can control so that
termination only doesn't happen

00:50:55.720 --> 00:50:57.540
when the pen leaves proximity.

00:50:57.540 --> 00:51:00.390
It might only happen,
or you can turn off so it only

00:51:00.610 --> 00:51:04.720
doesn't terminate if a timeout
happens or if it takes too long.

00:51:04.720 --> 00:51:08.610
And if you turn off
termination altogether,

00:51:09.030 --> 00:51:14.210
then you can control termination
through ink terminate current phrase.

00:51:16.400 --> 00:51:19.670
So the way we do this,
one of the things you need to keep in

00:51:19.670 --> 00:51:22.400
mind is we continue handling all those
mouse events that are coming through.

00:51:22.400 --> 00:51:24.790
So normally,
notice we had a button in there

00:51:24.790 --> 00:51:27.050
that controlled phrase termination.

00:51:27.050 --> 00:51:29.020
Normally,
we're going to continue writing.

00:51:29.020 --> 00:51:31.870
Once we've started a phrase,
we don't send anything

00:51:31.870 --> 00:51:33.260
through to controls.

00:51:33.260 --> 00:51:34.060
We don't do anything.

00:51:34.060 --> 00:51:39.660
We can keep sucking all that data
in as further data for writing.

00:51:40.680 --> 00:51:43.790
One of the things we talked about
earlier was for each mouse event that

00:51:43.890 --> 00:51:46.700
we get through that we've decided,
okay, the user's now inking.

00:51:46.700 --> 00:51:49.990
For each mouse event that comes through,
we send an ink point event.

00:51:50.000 --> 00:51:52.550
And the ink point event
contains a single parameter,

00:51:52.550 --> 00:51:54.800
which is actually the
original mouse event.

00:51:54.830 --> 00:51:59.150
And things you can use this for is
controlling whether or not to even

00:51:59.200 --> 00:52:01.590
allow inking in a certain region.

00:52:01.600 --> 00:52:04.210
Say a phrase is started,
but you don't want to allow

00:52:04.210 --> 00:52:07.020
inking outside of a certain
region in your window.

00:52:08.590 --> 00:52:10.720
Or in our case,
what we're doing with this

00:52:10.720 --> 00:52:13.340
application is you want to,
if a mouse down event

00:52:13.690 --> 00:52:17.000
happens in a certain area,
such as on a button or things like that,

00:52:17.000 --> 00:52:19.640
you want to do something
special with that.

00:52:19.680 --> 00:52:23.460
So if you return event not
handled there for the ink point,

00:52:23.460 --> 00:52:27.630
you can just look at it,
see if you want to do anything with it.

00:52:27.790 --> 00:52:30.830
If you return event not handled,
we continue on with recognition,

00:52:30.830 --> 00:52:32.640
continue sucking all that data in.

00:52:32.640 --> 00:52:36.270
If you return no error,
then we basically drop that

00:52:36.270 --> 00:52:38.320
and regenerate or repost.

00:52:38.370 --> 00:52:38.430
Okay.

00:52:38.460 --> 00:52:39.220
So that's the original mouse event.

00:52:39.220 --> 00:52:41.550
So if you say you've looked
at an ink point event,

00:52:41.550 --> 00:52:44.460
you've determined, okay,
it landed in an area where I don't

00:52:44.500 --> 00:52:46.200
want them to treat it as ink.

00:52:46.240 --> 00:52:49.350
I want to terminate and start
or just repost as a mouse

00:52:49.410 --> 00:52:51.460
event so it gets to my control.

00:52:51.460 --> 00:52:54.110
You just return no error
for that ink point event.

00:52:58.530 --> 00:53:00.900
So the steps to do it,
ink set phrase termination or

00:53:00.900 --> 00:53:02.640
turn off automatic termination.

00:53:02.640 --> 00:53:05.940
You've got an ink point event
handler that checks the location

00:53:05.940 --> 00:53:07.440
of mouse down events in our case.

00:53:07.440 --> 00:53:10.720
If the mouse down lands on
basically the region where that

00:53:10.920 --> 00:53:14.260
terminate phrase button is,
and if there's currently

00:53:14.260 --> 00:53:16.870
a phrase in session,
then you just call ink

00:53:16.870 --> 00:53:19.820
terminate current phrase,
and we finish.

00:53:19.830 --> 00:53:23.080
We do recognition,
and you get the ink text events.

00:53:23.080 --> 00:53:25.870
Otherwise,
just return event not handled error,

00:53:25.870 --> 00:53:28.280
and we continue building up the ink data.

00:53:30.790 --> 00:53:34.580
The code to do it is simply
you handle an ink point event.

00:53:34.770 --> 00:53:37.520
It's not the k-event ink text
event that shows up in there.

00:53:37.530 --> 00:53:39.580
It's actually an ink point event.

00:53:39.580 --> 00:53:42.340
You install a handler on it,
and you call ink set phrase

00:53:42.340 --> 00:53:44.440
termination and say termination none.

00:53:44.460 --> 00:53:46.580
Don't do any automatic termination.

00:53:46.720 --> 00:53:49.060
The application is in complete control.

00:53:52.290 --> 00:53:54.660
In Point Event Handler,
you're going to grab the

00:53:54.660 --> 00:53:57.260
mouse event out of there,
the single parameter.

00:53:57.260 --> 00:54:01.320
You're going to check to see,
for our application's purposes,

00:54:01.320 --> 00:54:04.050
you're going to check to see,
was that a mouse down event?

00:54:04.100 --> 00:54:08.190
If so, check to see, you know, hit test,
where did that event land?

00:54:08.190 --> 00:54:10.690
If it landed on the area
where your button is or,

00:54:10.690 --> 00:54:13.330
you know,
wherever you're trying to terminate,

00:54:13.330 --> 00:54:16.470
then check to see if there's
currently a phrase happening,

00:54:16.470 --> 00:54:19.320
you know,
are they actually inking right now?

00:54:19.340 --> 00:54:22.180
And if so, terminate the phrase
and return no response.

00:54:22.200 --> 00:54:24.610
If there's no error, everything finishes,
we perform recognition.

00:54:24.660 --> 00:54:28.660
Otherwise, like I said,
just return event not handled error,

00:54:28.660 --> 00:54:30.560
and we continue building up the data.

00:54:32.980 --> 00:54:37.500
And that's all you need to do for that.

00:54:37.540 --> 00:54:40.360
So summary things to keep in mind.

00:54:40.580 --> 00:54:43.460
If you're keeping count,
we have actually less than 20 APIs total.

00:54:43.460 --> 00:54:45.400
They're really straightforward.

00:54:45.400 --> 00:54:48.960
We put a lot of effort in
making them easy for you to use

00:54:48.960 --> 00:54:51.200
without a lot of complexity.

00:54:52.820 --> 00:54:55.860
And the Carbon events that we
have basically take advantage

00:54:55.860 --> 00:54:57.450
of the current event model.

00:54:57.450 --> 00:55:00.960
They're really easy to just flow
into your current event handlers.

00:55:00.960 --> 00:55:04.020
And basically,
we just want to encourage you

00:55:04.060 --> 00:55:08.460
to add more support to ink,
allow your users to take advantage of

00:55:08.460 --> 00:55:12.800
the services that are provided to you,
and ink different.

00:55:17.200 --> 00:55:23.040
So we have, as I mentioned earlier,
we have two documents that are

00:55:23.140 --> 00:55:28.730
available on the ADC website,
and they're already up there.

00:55:28.740 --> 00:55:32.500
One is the Ink Services Reference,
which goes through and actually

00:55:32.500 --> 00:55:36.960
documents all these APIs and everything,
and goes into pretty in-depth.

00:55:37.060 --> 00:55:39.580
We've got some sample code in there as
well that shows you how to use them.

00:55:39.580 --> 00:55:43.190
And also we have an overview document
that shows you how to integrate

00:55:43.260 --> 00:55:46.150
ink services into your application,
goes through some of the

00:55:46.180 --> 00:55:47.120
samples we've got here.

00:55:47.700 --> 00:55:51.660
Review all that and see how
you can take advantage of it.

00:55:53.360 --> 00:55:56.020
The application that I was just
using here is called InkSample.

00:55:56.020 --> 00:55:58.330
We've also got the code for that posted,
so you can go take a

00:55:58.330 --> 00:55:59.130
look at how we do it.

00:55:59.240 --> 00:56:02.210
And if you're interested in
more information on how the

00:56:02.210 --> 00:56:05.920
recognition technology works,
Larry's got a website.

00:56:05.920 --> 00:56:10.220
It's pobox.com slash tilde Larry Y.

00:56:10.220 --> 00:56:12.690
And he's got a lot of good
information up there as far as

00:56:12.690 --> 00:56:14.520
how the recognition system works.

00:56:17.340 --> 00:56:22.400
And if you have further questions,
you can contact Xavier and

00:56:22.400 --> 00:56:25.200
send him questions,
feedback.
WEBVTT

00:00:18.710 --> 00:00:19.600
Good morning and welcome.

00:00:19.600 --> 00:00:20.530
I'm Craig Keithley.

00:00:20.580 --> 00:00:24.200
I'm Apple's IOT Technology Evangelist,
and I'm a Bluetooth Bluetooth.

00:00:24.200 --> 00:00:25.600
Thank you for coming today.

00:00:25.600 --> 00:00:28.310
We're really,
really pleased and excited with

00:00:28.310 --> 00:00:31.320
our success with Bluetooth in
the last year or so.

00:00:31.430 --> 00:00:33.360
We've been doing this
for about a year now,

00:00:33.360 --> 00:00:34.720
and we're really happy about it.

00:00:34.720 --> 00:00:37.360
This is one of those things
that comes out of left field.

00:00:37.360 --> 00:00:39.360
We're watching for new hardware devices.

00:00:39.360 --> 00:00:43.160
We're evangelizing gaming device makers,
computer makers,

00:00:43.160 --> 00:00:46.700
and suddenly something comes
along which is unexpected,

00:00:46.700 --> 00:00:49.390
so we're pleased when things come back.

00:00:49.400 --> 00:00:51.620
Today,
what we're going to go into is an update

00:00:51.620 --> 00:00:54.820
on where we are with Bluetooth and
give a little sense of what kind of

00:00:54.820 --> 00:00:57.790
products we'd like to see in the future,
what kind of things we'd

00:00:57.890 --> 00:00:59.460
like to see in the future.

00:00:59.460 --> 00:01:02.320
So, having said that,
I'm going to bring up Eric Brown.

00:01:02.320 --> 00:01:06.400
Thank you.

00:01:09.900 --> 00:03:34.100
[Transcript missing]

00:03:37.180 --> 00:03:40.170
So that's what we had in our
1.0 release back in Jaguar.

00:03:40.190 --> 00:03:42.900
Well, over the past year,
we've shipped a number of software

00:03:42.900 --> 00:03:47.360
updates that added a number of new
both user and developer features that

00:03:47.370 --> 00:03:50.030
you might or might not be aware of.

00:03:50.070 --> 00:03:52.960
So through these releases,
we've added support in addition

00:03:53.000 --> 00:03:54.560
to the Object Push profile.

00:03:54.560 --> 00:03:58.720
We now have the File Transfer Profiler,
FTP for short,

00:03:58.720 --> 00:04:03.500
that whereas Object Push allows you
to send single files back and forth,

00:04:04.000 --> 00:04:07.910
you can actually do both
directory listings and treat

00:04:07.910 --> 00:04:09.670
it much like a file system.

00:04:09.720 --> 00:04:13.120
So we've added support to
Bluetooth File Exchange as well

00:04:13.120 --> 00:04:16.960
as our system services so that
you can go browse other systems,

00:04:16.960 --> 00:04:20.130
actually seeing some kind of cool
devices you can connect up to,

00:04:20.150 --> 00:04:22.140
palms and access file systems.

00:04:22.140 --> 00:04:24.490
There's even a little portable
hard drive that's kind of

00:04:24.540 --> 00:04:27.760
need to be connected up to it,
read and write files from it,

00:04:27.800 --> 00:04:31.630
just keep it in your backpack,
we're pretty nice.

00:04:31.700 --> 00:04:34.000
In our latest release,
we added support for the HIT program,

00:04:34.000 --> 00:04:38.440
so with that you can use
Bluetooth Keyboard to mice,

00:04:38.440 --> 00:04:41.000
it just works,
it makes it really easy to set up.

00:04:41.000 --> 00:04:45.710
As far as the setup process goes,
we've added a new Bluetooth Setup

00:04:45.710 --> 00:04:50.520
Assistant that provides a nice easy
step-by-step approach to configuring

00:04:50.520 --> 00:04:53.800
new devices and makes it so that
hopefully your mother can actually

00:04:53.880 --> 00:04:56.000
go and configure a Bluetooth device.

00:04:56.000 --> 00:04:59.000
As a part of the work
that we've been doing,

00:04:59.000 --> 00:05:04.000
we looked at how serial port
services have been in the system,

00:05:04.000 --> 00:05:06.840
and as we kept adding features to it,
we decided that those just

00:05:06.870 --> 00:05:09.000
getting a little too complicated
for the average user,

00:05:09.000 --> 00:05:12.510
so what we've done is taken
those serial port configuration

00:05:12.510 --> 00:05:15.000
out of preference panel where
it was for the original release,

00:05:15.000 --> 00:05:19.090
and added a separate application,
Bluetooth Serial Utility,

00:05:19.090 --> 00:05:25.000
that provides all of the more power user
options for configuring serial ports.

00:05:25.000 --> 00:05:30.000
And we also then, in removing that from
the preferences pane,

00:05:30.000 --> 00:05:33.000
we've reworked that a little bit
and added a new devices tab that

00:05:33.000 --> 00:05:33.000
makes it really easy to make changes.

00:05:34.000 --> 00:05:44.000
So it provides a kind of a
one-stop shop to configure that.

00:05:44.000 --> 00:05:46.000
As a part of the work that
we've done over the past year,

00:05:46.000 --> 00:05:50.180
we've also added some new and
updated APIs to the existing

00:05:50.240 --> 00:05:52.000
services that we provide already.

00:05:52.000 --> 00:05:55.170
So most of the main objects we've
added some new features to that

00:05:55.250 --> 00:05:56.950
I'll talk about in a little bit.

00:05:57.020 --> 00:06:00.960
So Bluetooth device, L2CAP channel,
our COM channel, all really have been,

00:06:01.050 --> 00:06:03.000
has some new features as well.

00:06:03.000 --> 00:06:04.000
We've added some new features to that.

00:06:04.000 --> 00:06:05.990
We've added a bunch of new
support to the UI elements,

00:06:06.000 --> 00:06:12.000
both with the user visible
features and one developer API.

00:06:12.000 --> 00:06:15.460
And as always,
all of the APIs that we provide are

00:06:15.460 --> 00:06:20.000
in both C and Objective-C versions,
so we've compared between the two.

00:06:20.000 --> 00:06:28.000
So we've been getting a lot of questions
about the HID support in the system.

00:06:28.000 --> 00:06:30.000
How do I customize the HID device?

00:06:30.000 --> 00:06:33.000
I've got some special things
I want to do with the HID device.

00:06:33.000 --> 00:06:36.110
So it's probably a good idea to
go ahead and tell you a little bit

00:06:36.170 --> 00:06:38.000
about how that works in the system.

00:06:38.000 --> 00:06:43.990
So what we've done is we provide
a full compliant HID class driver.

00:06:44.030 --> 00:06:46.950
So we've pretty much done
all the work for you there.

00:06:47.020 --> 00:06:49.800
When you configure a new HID device,
there'll be a HID class

00:06:49.800 --> 00:06:52.000
driver that loads up,
connects to the device,

00:06:52.000 --> 00:06:56.540
takes care of all of the profile
specific issues and talking

00:06:56.540 --> 00:06:57.990
with the Bluetooth partner.

00:06:58.040 --> 00:07:01.000
And what this does is that makes
the device itself accessible

00:07:01.000 --> 00:07:01.980
through the HID manager APIs.

00:07:02.060 --> 00:07:07.990
So if you need to do some custom
things with the HID device,

00:07:07.990 --> 00:07:08.990
you can just use the HID manager APIs.

00:07:09.000 --> 00:07:13.000
You shouldn't even touch
the hardware at all.

00:07:13.000 --> 00:07:15.650
Which is kind of a good thing because
we don't actually give you access

00:07:15.650 --> 00:07:17.000
in the kernel to the hardware.

00:07:17.000 --> 00:07:20.000
So that's really the
only place you can do it.

00:07:20.000 --> 00:07:24.000
Now, if you have really
have a need to do this,

00:07:24.000 --> 00:07:27.000
Craig Keithley, our developer contact,
is the person to talk to.

00:07:27.000 --> 00:07:30.000
There's maybe some things that can
be done if it's absolutely necessary.

00:07:30.000 --> 00:07:31.000
But hopefully, you'll be able to do it.

00:07:31.000 --> 00:07:34.000
Hopefully, we've made it so that you
don't have to do that.

00:07:34.000 --> 00:07:39.500
I want to talk a little bit about the
way that the Bluetooth serial ports

00:07:39.500 --> 00:07:45.000
work on the system and the way that
the serial utilities use the figure.

00:07:45.000 --> 00:07:48.120
So again, as I was saying,
we decided that the settings were just

00:07:48.120 --> 00:07:50.000
a little too complex for novice users.

00:07:50.000 --> 00:07:54.380
So we created the serial utility
application that now gives you full

00:07:54.390 --> 00:07:56.990
control over the creation of the ports.

00:07:57.010 --> 00:07:59.000
It's currently the only
way to create those ports.

00:07:59.000 --> 00:07:59.990
So it's kind of good
to know how it works.

00:08:00.000 --> 00:08:03.810
There are really two different
types of serial ports that are

00:08:03.930 --> 00:08:06.000
subtly different semantics.

00:08:06.000 --> 00:08:07.990
So it's good to treat them independently.

00:08:08.000 --> 00:08:10.000
There's incoming ports
and outgoing ports.

00:08:10.000 --> 00:08:13.000
Now, with a normal serial cable,
you don't have to worry about it.

00:08:13.000 --> 00:08:14.000
You connect up the cable.

00:08:14.040 --> 00:08:15.000
You talk to the device on the end.

00:08:15.000 --> 00:08:17.000
It's not incoming or outgoing.

00:08:17.060 --> 00:08:20.000
But with Bluetooth,
it's a little bit different.

00:08:20.000 --> 00:08:24.050
So with incoming serial ports,
a device itself will

00:08:24.120 --> 00:08:27.460
connect up to the system,
and any device can connect to a

00:08:27.460 --> 00:08:29.000
particular serial port service.

00:08:29.000 --> 00:08:32.770
And the application that is
listening on that serial port will

00:08:32.900 --> 00:08:34.960
get the data from that device.

00:08:36.140 --> 00:08:39.450
Now, as a result of that,
the device is going to,

00:08:39.450 --> 00:08:42.860
or the application rather,
is going to connect up and

00:08:42.860 --> 00:08:45.720
attempt to use the port before
there's anything connected.

00:08:45.720 --> 00:08:48.860
So in that particular case,
it treats it just like you would a

00:08:49.080 --> 00:08:50.980
serial port with no cable connected.

00:08:50.980 --> 00:08:53.690
If you do a read, you don't get any data.

00:08:53.760 --> 00:08:57.210
If you write to it,
it just goes to bit bucket.

00:08:58.360 --> 00:09:01.980
Once an incoming
connection is established,

00:09:01.980 --> 00:09:05.150
it gets routed automatically
to the application that

00:09:05.150 --> 00:09:08.990
has the serial port open,
has an outstanding read,

00:09:09.010 --> 00:09:11.990
and just automatically
starts passing data.

00:09:14.500 --> 00:09:17.740
As far as outgoing serial
ports are concerned,

00:09:17.740 --> 00:09:20.850
it's up to the user to configure
the single outgoing port

00:09:20.880 --> 00:09:22.740
works with a single device.

00:09:22.760 --> 00:09:25.950
So they select the device,
they can select any RFCOM-based

00:09:25.950 --> 00:09:29.420
service on the device,
and that serial port becomes configured.

00:09:29.420 --> 00:09:32.600
When you go to open up that
port in an application,

00:09:32.600 --> 00:09:36.190
the system will go and attempt
to connect to the device,

00:09:36.190 --> 00:09:41.630
attempt to open up the necessary channels
to create the data pipes for that port.

00:09:42.200 --> 00:09:46.330
Now, one possible problem here
is that this open process is

00:09:46.330 --> 00:09:48.740
actually can be quite lengthy.

00:09:48.740 --> 00:09:51.890
If the device isn't present,
there are timeouts associated with it.

00:09:51.930 --> 00:09:55.520
So you might spend 10,
15 seconds in the synchronous open

00:09:55.640 --> 00:09:57.960
call waiting for a connection to fail.

00:10:00.640 --> 00:10:07.380
So as a result, it's not always resulting
in the best user experience.

00:10:09.940 --> 00:10:12.900
So, now that we know kind of
how the serial ports work,

00:10:12.900 --> 00:10:16.420
I want to tell you that we really
recommend that you don't use them.

00:10:16.420 --> 00:10:18.460
They're really for legacy support.

00:10:18.460 --> 00:10:21.620
If you've got an application
that's already written that

00:10:21.620 --> 00:10:25.060
needs to use serial ports,
or maybe for debugging purposes,

00:10:25.060 --> 00:10:28.480
it's a little bit easier, that's fine,
but for a number of the

00:10:28.670 --> 00:10:32.440
reasons I've mentioned,
it's really an inefficient way to do it.

00:10:32.500 --> 00:10:35.770
You can get full access to
those serial ports by using

00:10:35.770 --> 00:10:37.820
the RFCOM APIs that we provide.

00:10:37.910 --> 00:10:42.070
And those APIs provide you with a
much richer set of functionality.

00:10:42.070 --> 00:10:44.730
It gives you a lot better and
more granular error reporting.

00:10:44.740 --> 00:10:48.260
You get a lot more direct control
over the channel creation and the

00:10:48.260 --> 00:10:51.180
behavior of the channel itself,
as well as provide a lot

00:10:51.430 --> 00:10:52.950
more information about it.

00:10:53.060 --> 00:10:56.190
Again,
we can't recommend this technique enough.

00:10:56.210 --> 00:10:59.690
It just will result in a
lot better applications.

00:11:01.370 --> 00:11:06.140
In addition to the serial port changes,
we've added a number of features

00:11:06.140 --> 00:11:10.420
in our UI elements that make
the user experience a lot nicer.

00:11:10.530 --> 00:11:14.030
Now, to support that,
we've added a couple of new

00:11:14.240 --> 00:11:15.100
device categories.

00:11:15.130 --> 00:11:19.790
So we've allowed now the concept of
favorite device or multiple favorite

00:11:19.880 --> 00:11:23.040
devices so that if you have a device
that you use over and over again,

00:11:23.040 --> 00:11:26.280
you just mark it as a favorite
and then every time you go in any

00:11:26.280 --> 00:11:30.330
application to one of our UI panels,
that device will be accessible.

00:11:30.330 --> 00:11:33.870
So if you say you always say send
files over to your Palm or want to

00:11:34.010 --> 00:11:37.210
send new applications to your Palm,
now you can just use the

00:11:37.210 --> 00:11:38.770
Bluetooth file exchange.

00:11:38.780 --> 00:11:42.060
Every time you go to send a file,
Palm's going to be listed right

00:11:42.500 --> 00:11:44.080
there as a favorite device.

00:11:44.100 --> 00:11:47.760
So you don't have to spend time going
through a lengthy discovery process

00:11:47.760 --> 00:11:50.640
every time you want to send a file.

00:11:50.820 --> 00:11:54.280
We've also added support for
recent devices where we keep

00:11:54.320 --> 00:11:57.980
track of each connection that's
established and we'll go ahead and

00:11:57.980 --> 00:12:00.520
list those in most recent first.

00:12:00.610 --> 00:12:03.940
So if you're sending contacts to
your phone and you've got three

00:12:04.070 --> 00:12:08.770
different ones you want to send,
as soon as you've sent that first one,

00:12:08.790 --> 00:12:10.200
it now shows up in your recent list.

00:12:10.200 --> 00:12:12.840
So you can keep selecting that
phone over and over again.

00:12:12.840 --> 00:12:16.760
So again, it drastically speeds up the
process where you're doing

00:12:16.760 --> 00:12:18.530
more than one thing at once.

00:12:18.720 --> 00:12:21.210
In the UI itself,
we've added new filters that let

00:12:21.280 --> 00:12:23.200
you filter by those categories.

00:12:23.200 --> 00:12:24.790
So say you only want
to see your favorites,

00:12:24.790 --> 00:12:25.770
you can easily do that.

00:12:25.800 --> 00:12:28.540
Only want to see recents or
just the discovered devices,

00:12:28.540 --> 00:12:30.180
you can do all of those things.

00:12:30.180 --> 00:12:33.860
As well, we've let you filter by
the actual type of device,

00:12:33.940 --> 00:12:35.910
so computer, PDA, phones.

00:12:35.910 --> 00:12:39.640
So if you're in an environment that
tend to have a lot of Bluetooth devices,

00:12:39.640 --> 00:12:44.660
which we're not there yet, but someday,
we'll actually let you easily

00:12:44.660 --> 00:12:48.490
go and find the specific device
you're looking for without having

00:12:48.510 --> 00:12:50.270
to wade through a long list.

00:12:54.800 --> 00:12:58.070
In addition to those user features,
there's a number of new pieces of

00:12:58.070 --> 00:13:04.920
API that make things a lot better in
the UI elements that allow you to,

00:13:04.920 --> 00:13:07.270
for example,
run PanelModal or as a sheet,

00:13:07.270 --> 00:13:11.960
full control over all of the text
that actually appears on the panel.

00:13:11.960 --> 00:13:14.930
So the title bar, the description,
the prompt that's used,

00:13:14.930 --> 00:13:18.840
and the button to select the device are
fully customizable by the application,

00:13:18.840 --> 00:13:22.260
and as well, lets you fully localize the
information that you put in there.

00:13:22.260 --> 00:13:24.790
So you should be able to do pretty much
anything you want with these panels.

00:13:24.800 --> 00:13:30.660
We've also added support for filtering
and validating user selection.

00:13:30.680 --> 00:13:35.660
So if you know you want to connect to,
say, an object push service on a device,

00:13:35.660 --> 00:13:39.620
you can tell the panel that I only want
devices to let the user select a device

00:13:39.620 --> 00:13:41.940
that supports the object push service.

00:13:41.960 --> 00:13:46.250
In that case,
it will actually go and verify,

00:13:46.250 --> 00:13:50.790
it'll do an SCP query,
it'll verify the device has that

00:13:50.790 --> 00:13:54.250
service before finalizing the selection.

00:13:54.730 --> 00:13:57.210
Your code returns,
you'll know that the device,

00:13:57.220 --> 00:13:59.860
it'll basically give you the
service that you asked for.

00:13:59.860 --> 00:14:01.700
You know that the device has it,
you don't have to worry

00:14:01.760 --> 00:14:02.580
about doing it yourself.

00:14:02.600 --> 00:14:07.400
All of these new APIs are
fully header-docked,

00:14:07.400 --> 00:14:10.070
and they're consistent across
all the different UI elements,

00:14:10.160 --> 00:14:12.590
so once you learn it for one,
it applies to all of them.

00:14:15.950 --> 00:14:19.660
To support the new different
categories and device types,

00:14:19.660 --> 00:14:23.620
we've added some new API onto the
IO Bluetooth device object itself.

00:14:23.660 --> 00:14:27.270
So we've got a whole slew of
API to manage the favorite devices.

00:14:27.280 --> 00:14:30.140
It lets you get to list the
currently logged in users' favorites,

00:14:30.140 --> 00:14:32.940
lets you check to see if a single
device is actually a favorite,

00:14:33.060 --> 00:14:36.630
and then you can even add and remove
the device from the favorites as well.

00:14:36.640 --> 00:14:40.190
So hopefully you only do that at the user
prompting and not just behind their back,

00:14:40.190 --> 00:14:42.580
because they probably
wouldn't like it too much.

00:14:43.280 --> 00:14:47.910
But we also add, finally,
API to access the paired devices,

00:14:47.920 --> 00:14:50.180
so you can get a list of all
the system-paired devices,

00:14:50.180 --> 00:14:53.960
as well as find out if an
individual device is paired.

00:14:53.960 --> 00:14:59.260
And then in order to support recent,
we've added a recent access date

00:14:59.260 --> 00:15:02.020
attribute to the device object.

00:15:02.110 --> 00:15:04.960
So it lets you see when the
device was most recently accessed,

00:15:04.960 --> 00:15:09.470
and there's API that lets you get
the list of the end most recently

00:15:09.480 --> 00:15:10.940
accessed device for the user.

00:15:10.940 --> 00:15:13.240
So say you only have room for the 5G.

00:15:13.280 --> 00:15:16.600
So you can just call this API,
and it will return you the 5

00:15:16.600 --> 00:15:19.380
most recent devices for the user.

00:15:26.530 --> 00:15:31.800
Additionally, we've added a lot of new
functionality in the,

00:15:31.820 --> 00:15:34.280
basically in our L2CAP and RFCOM layers.

00:15:34.470 --> 00:15:38.810
The original set of APIs we had worked,
but there wasn't really a

00:15:38.820 --> 00:15:42.330
distinction between asynchronous
and synchronous versions of the API.

00:15:42.330 --> 00:15:45.370
So the APIs that were
there were kind of a...

00:15:45.800 --> 00:15:47.770
and the rest of the team.

00:15:47.900 --> 00:16:15.780
Thank you.

00:16:15.800 --> 00:16:19.660
There's a number of new notifications
about channel state changes.

00:16:19.660 --> 00:16:24.940
Now, all of these new APIs are available
only in 10.2.5 and forward.

00:16:24.940 --> 00:16:27.440
So, if you do make use of them,
you will need to be

00:16:27.440 --> 00:16:29.650
dependent upon 10.2.5.

00:16:29.650 --> 00:16:34.200
However, we highly recommend that you
do this because these new APIs,

00:16:34.200 --> 00:16:38.530
especially for asynchronous behavior,
really lets you provide a

00:16:38.530 --> 00:16:40.710
much better user experience.

00:16:40.740 --> 00:16:43.370
You can really improve the
application responsiveness,

00:16:43.550 --> 00:16:45.330
avoid the spinning
cursor in a lot of cases,

00:16:45.330 --> 00:16:47.860
since a number of the operations
tend to take a long time,

00:16:47.860 --> 00:16:49.680
especially in the failure cases.

00:16:49.680 --> 00:16:53.910
So, it's really worthwhile to use
the asynchronous APIs so that the

00:16:54.040 --> 00:16:58.420
user doesn't have to feel like
the application isn't responding.

00:17:01.700 --> 00:17:05.570
Within the L2CAP channel object,
in order to support the

00:17:05.570 --> 00:17:09.170
new asynchronous behavior,
we've added the concept

00:17:09.190 --> 00:17:10.390
of a channel delegate.

00:17:10.400 --> 00:17:13.240
And what it does,
it allows the delegate to then

00:17:13.280 --> 00:17:16.640
receive the necessary callbacks,
notifications,

00:17:16.640 --> 00:17:20.520
and events that go along with the
different happenings in the system.

00:17:20.520 --> 00:17:24.750
So the delegate will get new
incoming data when it'll get the

00:17:24.860 --> 00:17:28.800
channel open complete notification,
it'll get notified when

00:17:28.800 --> 00:17:31.520
the channel gets closed,
when it gets reconfigured.

00:17:31.600 --> 00:17:33.350
This is a new one that
we didn't have before,

00:17:33.350 --> 00:17:36.590
so if the L2CAP channel itself
goes through the configuration

00:17:36.620 --> 00:17:40.020
process to get some new parameters,
it will do that.

00:17:40.040 --> 00:17:42.340
It's also then a write
complete notification,

00:17:42.340 --> 00:17:44.950
so it's kind of a one-stop
shop for all the asynchronous

00:17:44.950 --> 00:17:47.010
notifications within the channel.

00:17:48.750 --> 00:17:52.240
The APIs for those are divided
into a couple different categories.

00:17:52.240 --> 00:17:55.120
We've got a couple new APIs on
Bluetooth device that lets

00:17:55.120 --> 00:17:58.600
you both open the channel
asynchronously or synchronously.

00:17:58.600 --> 00:18:02.810
Now,
as a result of the new channel delegate,

00:18:02.900 --> 00:18:07.520
every channel has to have
a delegate when opened.

00:18:07.600 --> 00:18:11.740
So, since that is now the one way to
receive incoming data notifications,

00:18:11.740 --> 00:18:14.130
for example,
it's a requirement that there is a

00:18:14.130 --> 00:18:18.600
delegate that at least implements
the incoming data callback.

00:18:18.600 --> 00:18:21.560
Otherwise, if data comes in,
it would just get dropped on the floor.

00:18:21.600 --> 00:18:25.330
So, pretty much have to have that set up.

00:18:25.490 --> 00:18:27.960
The old method that was
used to open the channel,

00:18:28.000 --> 00:18:31.580
as we are going to be deprecating that,
so we definitely recommend that

00:18:31.580 --> 00:18:33.040
you move to these new APIs.

00:18:33.040 --> 00:18:35.040
It's just generally a lot better.

00:18:35.040 --> 00:18:37.330
You know whether it's a synchronous call,
you know whether it's

00:18:37.330 --> 00:18:38.340
an asynchronous call.

00:18:38.340 --> 00:18:42.380
It really defines what the behavior
is rather than kind of leaving it

00:18:42.380 --> 00:18:44.420
up to how we've decided to do it.

00:18:50.520 --> 00:18:55.140
We also have new asynchronous write
methods on the L2CAP channel objects.

00:18:55.140 --> 00:18:57.470
So we've got writeAsync
and writeSync that,

00:18:57.570 --> 00:18:58.700
again, behave the same way.

00:18:58.700 --> 00:19:00.360
It does the right thing
in the right place.

00:19:00.360 --> 00:19:03.620
The asynchronous write will go
ahead and return right away.

00:19:03.620 --> 00:19:05.190
It's not going to block on you.

00:19:05.220 --> 00:19:08.410
It lets, you know, gives you a real good
user experience with that.

00:19:08.580 --> 00:19:12.380
Both of these replace the old write call.

00:19:13.450 --> 00:19:17.460
RFCOM channel has APIs really similar.

00:19:17.500 --> 00:19:20.980
There's a new RFCOM channel delegate
object that gets the same messages

00:19:21.030 --> 00:19:23.570
when there's new incoming data,
channel open/closed.

00:19:23.680 --> 00:19:27.950
RFCOM has some additional control
signals and flow control information

00:19:27.950 --> 00:19:30.320
that are communicated to the delegate.

00:19:30.320 --> 00:19:33.640
Gets a write complete notification
and then there's a new queue space

00:19:33.640 --> 00:19:38.030
available notification that I'll explain
in a little more detail in a minute.

00:19:39.130 --> 00:19:43.020
For the RFCOM APIs,
we have the same kind of channel

00:19:43.200 --> 00:19:46.630
open APIs on the Bluetooth device
object itself for opening

00:19:46.630 --> 00:19:49.000
a channel synchronously,
asynchronously.

00:19:49.020 --> 00:19:52.080
As with L2CAP,
the delegate is required to

00:19:52.160 --> 00:19:53.240
be able to open a new channel.

00:19:53.240 --> 00:19:57.670
And as with L2CAP,
we're going to be deprecating the old

00:19:57.730 --> 00:20:00.660
open RFCOM channel method as well.

00:20:04.160 --> 00:20:08.710
The RFCOM channel APIs itself have,
as you'd expect, write async,

00:20:08.820 --> 00:20:11.610
write sync versions that are
going to be replacing the old

00:20:11.750 --> 00:20:13.520
write and write simple methods.

00:20:13.670 --> 00:20:15.950
Now,
we're also deprecating the old incoming

00:20:15.950 --> 00:20:21.400
data listener and incoming event listener
methods because all of those listeners

00:20:21.400 --> 00:20:22.630
are now replaced by the delegate.

00:20:22.660 --> 00:20:26.050
Everything goes to the one
place in the delegate object.

00:20:27.650 --> 00:20:30.570
Now, one of the things that in
doing these fully synchronous,

00:20:30.570 --> 00:20:34.060
fully asynchronous
APIs with RFCOM channels,

00:20:34.060 --> 00:20:37.180
a little different than L2CAP,
is that RFCOM provides flow control.

00:20:37.180 --> 00:20:41.200
So, we're basically told when we can
and when we can't write data.

00:20:41.200 --> 00:20:43.240
So,
in the case where we can't write data,

00:20:43.240 --> 00:20:45.120
we have to queue it up internally.

00:20:45.120 --> 00:20:48.900
Now, in order to avoid having just
an unbounded queue space,

00:20:48.900 --> 00:20:53.380
there are some maximums set within
the channel that are pretty high.

00:20:53.480 --> 00:20:56.000
It's unlikely you're going to
run into a case where you're

00:20:56.000 --> 00:20:58.280
queuing up too much data,
but it's possible.

00:20:58.280 --> 00:21:02.170
So, in order to deal with
that situation nicely,

00:21:02.170 --> 00:21:08.600
we've added the case where a write call
may fail with a KR return no space error.

00:21:08.600 --> 00:21:11.990
So, if that happens,
we will then subsequently call

00:21:11.990 --> 00:21:15.820
the delegate the queue space
available notification once the

00:21:15.880 --> 00:21:18.400
queue is actually available again.

00:21:18.400 --> 00:21:21.690
So, you can easily just pen that
operation until you're notified

00:21:21.700 --> 00:21:23.440
that we have queue space again.

00:21:23.460 --> 00:21:27.890
It's pretty much a common operation when
dealing with a system with flow control.

00:21:35.410 --> 00:21:37.830
Now, we've also gotten a number
of questions about how

00:21:37.840 --> 00:21:40.790
SDP services work in the system.

00:21:40.790 --> 00:21:44.810
It's not straightforward to
just go and add new services,

00:21:44.820 --> 00:21:48.920
so I thought it's a good idea to talk
a little bit about how that works.

00:21:48.920 --> 00:21:51.750
You pretty much,
if you're looking to add support

00:21:51.750 --> 00:21:54.480
for new Bluetooth profiles,
or maybe you want to

00:21:54.530 --> 00:21:57.560
write your own profile,
like maybe your chat service

00:21:57.570 --> 00:22:00.790
or something like that,
you will likely need to add

00:22:00.890 --> 00:22:05.180
services to the system so that
other devices can find that service.

00:22:05.300 --> 00:22:08.480
So, we've defined really
two types of services,

00:22:08.490 --> 00:22:10.410
transient and persistent.

00:22:10.460 --> 00:22:14.540
A transient service is, as implied,
it's going to only exist

00:22:14.540 --> 00:22:16.490
for a short period of time.

00:22:16.530 --> 00:22:18.280
In our case,
what we've done is we've defined

00:22:18.280 --> 00:22:22.570
that amount of time to be the
running time for the application

00:22:22.570 --> 00:22:23.940
that registers to the service.

00:22:23.940 --> 00:22:27.940
So, as soon as that application dies,
exits, is quit by the user,

00:22:27.940 --> 00:22:30.260
we're going to remove that service.

00:22:30.260 --> 00:22:32.860
So, you don't have to worry
about cleaning up,

00:22:32.860 --> 00:22:34.490
it'll just go away for you.

00:22:34.740 --> 00:22:37.410
Persistent Service is
a little bit better,

00:22:37.540 --> 00:22:41.080
where, maybe not better,
but more useful in some cases anyway,

00:22:41.080 --> 00:22:43.610
where it will stick around
outside of the scope of the

00:22:43.610 --> 00:22:45.370
application that registered it.

00:22:45.460 --> 00:22:48.720
So, it'll exist through reboots.

00:22:48.720 --> 00:22:52.220
It doesn't actually require that
your client application be running.

00:22:52.220 --> 00:22:55.630
It can be configured to go and
automatically launch an application

00:22:55.630 --> 00:22:58.660
when an incoming connection
is created to the service.

00:23:01.040 --> 00:23:04.500
Now the service itself,
we've defined a dictionary format to

00:23:04.500 --> 00:23:07.400
describe how a particular service looks.

00:23:07.400 --> 00:23:11.910
So the dictionary itself has
individual entries where each entry

00:23:12.060 --> 00:23:13.720
corresponds to an SDP attribute.

00:23:13.720 --> 00:23:17.120
Now that format itself is a little
bit in-depth and a little bit

00:23:17.270 --> 00:23:20.130
more that we can go into here,
but it should be fully

00:23:20.210 --> 00:23:22.190
documented in the HeaderDoc.

00:23:22.240 --> 00:23:23.850
And if you do have any
questions about it,

00:23:23.850 --> 00:23:26.480
we've got a developer mailing list,
so we'd be more than happy to help

00:23:26.490 --> 00:23:27.990
you with anything you need there.

00:23:29.540 --> 00:23:34.330
In addition to the format itself,
some of the attributes will

00:23:34.330 --> 00:23:37.270
actually be defined by the system.

00:23:37.280 --> 00:23:41.120
So the service record handle and
RFCOM channel ID are the two that are

00:23:41.120 --> 00:23:43.420
currently assigned by the systems.

00:23:43.420 --> 00:23:46.130
That way,
there's a single namespace essentially

00:23:46.140 --> 00:23:50.520
for the record handles and channel IDs,
so we have to manage that internally.

00:23:50.520 --> 00:23:55.830
We also have this additional local
attributes attribute that lets

00:23:55.830 --> 00:23:58.520
you specify some custom controls.

00:23:59.540 --> 00:24:02.800
So we have controls for a
particular service that control

00:24:02.800 --> 00:24:06.660
the behavior of the system with
regards to that single service.

00:24:09.910 --> 00:24:13.160
Currently,
we only have two supported attributes.

00:24:13.160 --> 00:24:16.660
Persistent attributes, as you'd expect,
it's a Boolean attribute

00:24:16.660 --> 00:24:19.810
that if it's set to true,
it indicates that the service

00:24:19.810 --> 00:24:22.150
will exist until you remove it.

00:24:22.250 --> 00:24:26.700
If it's either missing or false,
then that service will be removed

00:24:26.700 --> 00:24:29.200
as soon as the application exits.

00:24:29.200 --> 00:24:34.500
There's also a target application that
specifies a particular application

00:24:34.500 --> 00:24:39.680
to launch when an incoming connection
to that service is established.

00:24:39.800 --> 00:24:43.740
So, that pretty much will only work
when there's a logged-in user.

00:24:43.740 --> 00:24:46.410
So, when that user's logged in,
connection to, say,

00:24:46.410 --> 00:24:49.400
you've created your new chat service,
and you've said, oh,

00:24:49.400 --> 00:24:54.040
here's my chat application to
launch when somebody connects to it,

00:24:54.120 --> 00:24:55.240
well, what happened then?

00:24:55.240 --> 00:24:58.060
It'll go and launch that application
as the currently logged-in user.

00:24:58.060 --> 00:24:59.450
So,
it's just like they're running an app.

00:25:01.110 --> 00:25:03.830
Now,
you don't actually have to have a target

00:25:03.830 --> 00:25:08.440
application for persistent service,
but it's more useful in that case.

00:25:08.440 --> 00:25:13.430
You might want to have a running
process like a menu extra

00:25:13.500 --> 00:25:17.120
or something that provides
notifications on the states of things,

00:25:17.140 --> 00:25:19.520
so you can set up even a
persistent service without

00:25:19.530 --> 00:25:22.180
launching your application,
and a running app can get

00:25:22.180 --> 00:25:24.080
notifications for that service.

00:25:25.440 --> 00:25:30.120
Additionally,
we're likely to add new local attributes

00:25:30.150 --> 00:25:34.570
to control additional things about the
way that individual services behave.

00:25:41.030 --> 00:25:47.270
Now in order to actually
add a new service,

00:25:47.270 --> 00:25:47.270
we've got a function out of Bluetooth,
Add Service Stick.

00:25:47.400 --> 00:25:50.700
It's pretty simple to use,
and what we've done is for the

00:25:50.700 --> 00:25:55.040
service dictionary description,
we've defined it so that it only

00:25:55.040 --> 00:25:57.500
uses the native plist data types.

00:25:57.500 --> 00:25:59.140
So it makes it real easy.

00:25:59.140 --> 00:26:02.490
You can define your service
actually in a plist file,

00:26:02.490 --> 00:26:06.500
load it in, and then call add service
with that dictionary.

00:26:06.500 --> 00:26:10.020
So you don't have to create a lot of
code to build up a complex dictionary.

00:26:10.020 --> 00:26:11.400
You can just do it in the file.

00:26:11.530 --> 00:26:12.620
It makes it real easy.

00:26:13.540 --> 00:26:16.690
This particular function will
actually return a newly created

00:26:16.800 --> 00:26:21.050
Bluetooth SDP service record that
includes all of the attributes

00:26:21.130 --> 00:26:23.160
that were signed by the system.

00:26:23.160 --> 00:26:25.880
So one thing to really take
note here is that if you're

00:26:25.880 --> 00:26:29.730
creating a persistent service,
the client has to remember the

00:26:29.780 --> 00:26:33.840
record handle returned in this
particular service record,

00:26:33.840 --> 00:26:38.160
because that record handle
actually is then used in the remove

00:26:38.160 --> 00:26:40.740
service with record handle call.

00:26:42.240 --> 00:26:47.980
So if it doesn't remember it,
then you're kind of stuck.

00:26:47.980 --> 00:26:50.760
You need to know that
to remove that service.

00:26:50.760 --> 00:26:53.820
So in this particular case,
the transient services you

00:26:53.820 --> 00:26:57.900
don't need to worry about,
they'll be removed automatically for you.

00:26:57.900 --> 00:27:00.590
But again, if, say,
you only want a service to exist for not

00:27:00.590 --> 00:27:03.210
for the entire run of the application,
but just part of it,

00:27:03.230 --> 00:27:06.300
you'll need to remember that
as well for columnist function.

00:27:06.300 --> 00:27:07.470
Thank you.

00:27:09.400 --> 00:27:11.620
So,
I've got a number of helpful hints here.

00:27:11.620 --> 00:27:15.470
We've got some sample code that does a
number of the things I've talked about.

00:27:15.510 --> 00:27:18.180
We've got the RFCOM server
sample is actually a,

00:27:18.180 --> 00:27:20.810
it's a simple chat server
that goes along with,

00:27:20.810 --> 00:27:22.860
there's an RFCOM client sample.

00:27:22.860 --> 00:27:27.200
Well, the server code shows how to,
it has its own plist file with the

00:27:27.340 --> 00:27:31.880
dictionary format set for a sort
of a fictional custom chat service.

00:27:31.880 --> 00:27:36.000
It also shows how to load that in,
how to set up the service,

00:27:36.000 --> 00:27:40.620
save off the handle,
and then remove it when needed.

00:27:42.220 --> 00:27:44.760
Now, in case you do get
into a situation where,

00:27:44.770 --> 00:27:47.680
say, your code crashed and
didn't save off the handle,

00:27:47.680 --> 00:27:51.500
or if you forgot to implement
the code to save it off,

00:27:51.570 --> 00:27:54.920
it is possible to remove it
with a little bit of surgery.

00:27:54.920 --> 00:27:59.300
So, in this case,
there's the blueD.plist file in the

00:27:59.410 --> 00:28:02.800
Roots Library Preferences directory.

00:28:02.800 --> 00:28:04.270
So, you can remove that file.

00:28:04.440 --> 00:28:06.080
It will remove your service.

00:28:06.080 --> 00:28:09.520
It will also remove all of the other
cached information on your system.

00:28:09.520 --> 00:28:13.810
So, I definitely recommend only doing
this as a last-ditch effort,

00:28:13.820 --> 00:28:15.460
because you will lose
all the device names,

00:28:15.470 --> 00:28:16.300
device services.

00:28:16.300 --> 00:28:17.820
You'll lose all your pairings.

00:28:17.820 --> 00:28:22.540
So, it's useful as a developer tool,
but definitely not for the end user.

00:28:27.870 --> 00:28:30.940
So now, how do you actually get
access to these new APIs?

00:28:30.940 --> 00:28:35.740
Well, we are currently in the last stages
of working on an SDK that will

00:28:35.740 --> 00:28:38.200
be based on the R1025 release.

00:28:38.200 --> 00:28:42.230
Keep checking the developer site
because it will be up there real soon.

00:28:42.230 --> 00:28:45.200
It includes all the APIs that
I've talked about here.

00:28:45.200 --> 00:28:47.930
It also includes support
for Packet Decoder,

00:28:47.930 --> 00:28:51.960
which, as some of you have noticed,
in one of our software updates,

00:28:52.000 --> 00:28:54.370
we disabled it for security reasons.

00:28:55.120 --> 00:28:58.690
The Packet Decoder itself would allow
pretty much anybody access to all of the

00:28:58.690 --> 00:29:01.750
traffic going over your Bluetooth link,
and that includes link key

00:29:01.890 --> 00:29:03.370
data with the hid stuff,
hid data.

00:29:03.530 --> 00:29:06.160
They could snoop your
keyboards and everything.

00:29:06.160 --> 00:29:09.660
So by default, in production builds,
all of the support for Packet

00:29:09.660 --> 00:29:11.580
Decoder is completely removed.

00:29:13.590 --> 00:29:16.840
The SDK itself includes a build
that has that turned back on,

00:29:16.860 --> 00:29:21.610
so all you need to do to use
that application and develop your

00:29:21.820 --> 00:29:25.120
new services is just install the
SDK and you'll get support for it.

00:29:27.580 --> 00:29:31.300
So now I'd like to turn the
presentation over to Mike Larson.

00:29:31.300 --> 00:29:32.850
He's a Bluetooth technology manager.

00:29:32.900 --> 00:29:37.130
He's going to talk about kind
of new directions and new what's

00:29:37.130 --> 00:29:40.490
going on in the Bluetooth industry.

00:29:46.670 --> 00:29:47.600
Thanks, Eric.

00:29:47.600 --> 00:29:50.080
It's been a long year.

00:29:50.140 --> 00:29:51.840
There's been a lot going on.

00:29:52.120 --> 00:29:54.090
Bluetooth industry has
really come a long way.

00:29:54.090 --> 00:29:59.920
The few industry events I've attended,
it's gone from how do we create

00:30:00.070 --> 00:30:02.980
this brand-new technology and
get people to adopt it to,

00:30:02.980 --> 00:30:05.430
okay, it's out there,
it's starting to become

00:30:05.430 --> 00:30:08.740
successful and in lots of devices,
what do we have to do now?

00:30:09.440 --> 00:30:12.020
The push is largely for
simple configuration.

00:30:12.020 --> 00:30:14.680
People are realizing that
if it takes more than five

00:30:14.710 --> 00:30:18.070
minutes to configure a device,
the user's going to drop it on the

00:30:18.070 --> 00:30:21.350
floor and not touch it again and say,
this doesn't work.

00:30:21.360 --> 00:30:24.820
Along those lines,
the special interest group has

00:30:24.950 --> 00:30:29.280
now started what they call the
five-minute ready initiative.

00:30:29.280 --> 00:30:33.240
What they're looking for there is a
five-minute out-of-box experience.

00:30:33.320 --> 00:30:36.840
And as the industry shows,
others are pushing for even sooner.

00:30:36.850 --> 00:30:38.970
I've heard as low as 30 seconds.

00:30:39.440 --> 00:30:41.830
So that's the goal.

00:30:41.890 --> 00:30:46.520
What else has happened in terms of
Bluetooth devices over the last year?

00:30:46.520 --> 00:30:48.780
The user interfaces have
gotten a lot simpler.

00:30:48.880 --> 00:30:51.290
If you've been an early adopter of this,
like I've been,

00:30:51.300 --> 00:30:56.210
you've been able to notice that the
user interface has moved from five

00:30:56.210 --> 00:31:00.330
or six levels deep in a device to
right at the foreground with the new

00:31:00.340 --> 00:31:03.180
devices like the Sony Ericsson T610.

00:31:03.180 --> 00:31:05.220
So that's the direction this is going.

00:31:05.220 --> 00:31:08.800
People are starting to take this
seriously and figure out a way to get the

00:31:09.000 --> 00:31:10.970
user up and running in very little time.

00:31:16.480 --> 00:31:19.620
There are a few changes coming on
on the technology side from the

00:31:19.620 --> 00:31:22.020
Bluetooth SIG and the industry.

00:31:22.020 --> 00:31:26.780
The first one is late this year,
they're coming out with version 1.2.

00:31:26.780 --> 00:31:29.900
They have a few features included there.

00:31:29.900 --> 00:31:32.680
The primary one is improved
quality of service,

00:31:32.680 --> 00:31:35.850
which means that you can
guarantee that your HID devices

00:31:36.000 --> 00:31:39.150
will get time to transfer their
HID data when they need to,

00:31:39.150 --> 00:31:42.870
and other quality of service-dependent
devices will get the time

00:31:42.870 --> 00:31:44.810
they need when they need it.

00:31:45.680 --> 00:31:49.950
Another feature of version 1.2
is adaptive frequency hopping.

00:31:49.950 --> 00:31:56.330
What AFH is going to provide is better
coexistence of Bluetooth devices

00:31:56.330 --> 00:31:58.980
with other 2.4 GHz devices.

00:31:58.980 --> 00:32:01.360
In order for AFH to
work and be successful,

00:32:01.380 --> 00:32:05.290
it does require a version 1.2
radio on both sides of the link.

00:32:06.930 --> 00:32:08.460
Now that said,
this is something you're going

00:32:08.460 --> 00:32:10.670
to want to consider if you're
building a hardware device.

00:32:10.670 --> 00:32:13.950
If you have the choice and are
making radio decisions now,

00:32:13.950 --> 00:32:17.280
check with your vendors and make
sure that the radio that you're

00:32:17.280 --> 00:32:21.490
going to use for your device will
be 1.2 capable and will support AFH.

00:32:21.490 --> 00:32:24.630
It will help you out and it will
help your users out down the road.

00:32:30.300 --> 00:32:32.690
Past the end of this year
and onto the next horizon,

00:32:32.760 --> 00:32:36.270
sometime next year hopefully,
the Bluetooth SIG and the technology

00:32:36.350 --> 00:32:38.340
leaders are looking at medium data rate.

00:32:38.370 --> 00:32:40.480
This will require a new radio.

00:32:40.710 --> 00:32:43.280
Today's radios aren't likely
to be upgradable through

00:32:43.280 --> 00:32:44.790
firmware to support this.

00:32:44.800 --> 00:32:46.300
It will require new hardware.

00:32:46.300 --> 00:32:48.300
What does medium data rate give you?

00:32:48.300 --> 00:32:53.300
It gives you up to 2 to 3 megabit per
second throughput on a single channel.

00:32:53.300 --> 00:32:57.170
So that's currently
scheduled for mid-next year.

00:32:57.170 --> 00:33:02.150
We hope everything comes
together and that will allow

00:33:02.150 --> 00:33:06.300
a few more Bluetooth devices
to exist on a single link.

00:33:06.300 --> 00:33:10.290
Get some new things using Bluetooth.

00:33:12.270 --> 00:33:15.950
There are a few things that we've
noticed in the last year and a half,

00:33:16.130 --> 00:33:19.100
two years that we've been
playing with Bluetooth.

00:33:19.170 --> 00:33:22.730
And here are a few of our notes
that will help you out and make

00:33:22.730 --> 00:33:26.640
your Bluetooth devices coexist
with the rest of the world.

00:33:26.650 --> 00:33:31.250
Inquiry operations and paging operations,
which are device discovery and

00:33:31.760 --> 00:33:35.860
creating connections respectively,
they really disrupt 802.11

00:33:36.020 --> 00:33:39.840
traffic as well as other
Bluetooth traffic on the link.

00:33:40.580 --> 00:33:43.930
For that reason and a couple others,
we do not plan to offer

00:33:43.930 --> 00:33:47.460
a direct inquiry API.

00:33:47.460 --> 00:33:51.570
Accessing the inquiry API is
possible through our user interface.

00:33:52.000 --> 00:33:56.810
Another thing to make note of is 720
kilobits per second is the total link

00:33:56.810 --> 00:33:59.080
budget for bandwidth and throughput.

00:33:59.080 --> 00:34:02.660
If you assume that that is the
budget available for your connection,

00:34:02.660 --> 00:34:05.580
you're not going to be very
kind to other connections.

00:34:05.650 --> 00:34:09.200
And you will not get that throughput
if the user is selected to use

00:34:09.280 --> 00:34:12.750
a Bluetooth keyboard or a mouse
because the quality of service

00:34:12.820 --> 00:34:16.720
constraints will require us to
access those devices as well.

00:34:16.720 --> 00:34:19.950
So if you need a full 700
kilobits of bandwidth,

00:34:19.960 --> 00:34:24.240
Bluetooth is probably the wrong
choice for your wireless connectivity.

00:34:24.320 --> 00:34:27.150
If you need somewhat less
than that and can coexist and

00:34:27.150 --> 00:34:30.150
deal with less throughput,
then it's a good choice.

00:34:36.410 --> 00:34:39.890
This goes back to the point I mentioned
on the last slide where paging

00:34:39.890 --> 00:34:45.880
operations disrupt both existing
Bluetooth traffic and 802.11 traffic.

00:34:45.900 --> 00:34:49.490
In order to find out if
devices are within range,

00:34:49.490 --> 00:34:53.490
a loop of paging to find if the
device is there and connect to it

00:34:53.570 --> 00:34:55.660
is not a real good use of resources.

00:34:55.700 --> 00:34:59.240
It's not kind to the other
people using the link,

00:34:59.240 --> 00:35:04.960
and it's not kind to the 802.11
connections that are in place.

00:35:05.500 --> 00:35:10.140
Now I'd like to introduce Craig Keithley,
who's going to talk about some

00:35:10.200 --> 00:35:13.980
opportunities that are out there in
the Bluetooth world for our customers.

00:35:13.990 --> 00:35:16.310
Thank you very much.

00:35:21.310 --> 00:35:23.300
Thanks, Mike.

00:35:23.300 --> 00:35:26.300
So there are a number of opportunities.

00:35:26.300 --> 00:35:29.670
In fact, before I came up on stage today,
we were talking with Mike,

00:35:29.720 --> 00:35:31.420
and he just got back from
the Bluetooth Congress,

00:35:31.440 --> 00:35:36.300
and he tells me that my price point
of $75 for a low-cost serial adapter

00:35:36.300 --> 00:35:39.660
is too high and that it should
be doable at $40 based on some

00:35:39.660 --> 00:35:41.290
new chipsets that are coming out.

00:35:41.310 --> 00:35:45.290
So scratch that and put $40 in there.

00:35:45.610 --> 00:35:48.580
We do want to see more HID devices,
and I'm particularly interested in

00:35:48.580 --> 00:35:50.620
seeing gaming devices come along.

00:35:50.750 --> 00:35:55.020
There are some gamepads, for example,
that are RF-based,

00:35:55.020 --> 00:35:58.060
but they work with the USB adapter,
custom one.

00:35:58.080 --> 00:35:59.440
I'd like to see those go to Bluetooth.

00:36:00.460 --> 00:36:04.740
The I3A Committee,
which is the organization

00:36:04.740 --> 00:36:09.340
that deals with specifications
for digital stealth cameras,

00:36:09.340 --> 00:36:13.620
does have a PTP over
Bluetooth specification and development.

00:36:13.620 --> 00:36:16.450
For those of you who
aren't familiar with PTP,

00:36:16.450 --> 00:36:18.820
it's Picture Transport Protocol.

00:36:18.820 --> 00:36:23.060
It's the core of which our image
capture architecture is based.

00:36:23.060 --> 00:36:26.290
All the command sets that
are in image capture,

00:36:26.290 --> 00:36:29.620
all those that architecture
is structuring.

00:36:30.460 --> 00:36:33.850
So there's USB PTP cameras
available today,

00:36:33.930 --> 00:36:38.260
built in support with a
profile or a USB class driver.

00:36:38.260 --> 00:36:41.830
There's a FireWire PTP class
specification in works,

00:36:41.830 --> 00:36:46.510
and we want to see that extended
to digital stealth cameras as well.

00:36:47.890 --> 00:36:52.010
I've seen some GPS receivers,
samples that are just in

00:36:52.010 --> 00:36:55.410
prototype form now that have
a Bluetooth interface on them,

00:36:55.470 --> 00:36:58.900
and I think that would be a very cool
device to have to be able to get your

00:36:58.900 --> 00:37:01.230
GPS location over Bluetooth wirelessly.

00:37:01.240 --> 00:37:06.760
Application-wise, this is a somewhat
challenging area for us.

00:37:06.760 --> 00:37:11.480
Certainly, the silent clicker is a
nice innovative product.

00:37:11.480 --> 00:37:13.660
The question now is,
what other things can

00:37:13.660 --> 00:37:15.310
you do application-front?

00:37:15.420 --> 00:37:16.380
I'd like to hear about them.

00:37:16.410 --> 00:37:19.590
If you've got ideas,
you want to have us help

00:37:19.750 --> 00:37:22.430
you with marketing efforts,
please contact me.

00:37:22.460 --> 00:37:25.260
That actually goes for all
of Bluetooth products that

00:37:25.260 --> 00:37:26.150
you might be working on.

00:37:26.160 --> 00:37:28.560
I'm looking at stuff that
we can do at Next Macworld

00:37:28.560 --> 00:37:31.370
San Francisco for a Bluetooth area,
and I'd like to be able

00:37:31.380 --> 00:37:34.140
to highlight products,
so please do contact me if you've

00:37:34.140 --> 00:37:35.940
got something in the works.

00:37:38.590 --> 00:37:43.740
The Bluetooth hardware solutions, well,
so serial and audio are the ones

00:37:43.740 --> 00:37:47.650
that are presently on our minds.

00:37:47.820 --> 00:37:49.860
Our hardware is capable
of supporting SEO.

00:37:49.860 --> 00:37:52.150
We haven't released any
profile support for that yet.

00:37:52.160 --> 00:37:55.740
We should, if all things go well,
be able to do that in the future.

00:37:55.740 --> 00:37:59.260
What I do want to encourage people to
do is to pay attention that SEO and

00:37:59.270 --> 00:38:03.420
its current implementation is not
adequate for doing speech recognition.

00:38:03.420 --> 00:38:06.200
So the SEO-based cell
phone-style headsets,

00:38:06.200 --> 00:38:10.150
although we may be able to support
them in the operating system,

00:38:10.150 --> 00:38:12.800
would not be something that
I want you to plan on using with

00:38:12.800 --> 00:38:14.500
our speech recognition engine.

00:38:14.800 --> 00:38:19.080
If you do an advanced audio product,
however, where you can do, say,

00:38:19.080 --> 00:38:23.500
stereo headphones or you can get
good sample rates on the microphone,

00:38:23.500 --> 00:38:26.340
that's something I'm very
interested in working with you on.

00:38:26.340 --> 00:38:29.050
I want to make sure that we have
support in our speech recognition

00:38:29.050 --> 00:38:30.660
engine for those types of devices.

00:38:30.680 --> 00:38:34.490
So as a just general rule,
if you're working on advanced audio,

00:38:34.490 --> 00:38:38.030
we need 22 kilohertz,
16-bit resolution to be able

00:38:38.110 --> 00:38:40.200
to do good speech recognition.

00:38:40.200 --> 00:38:44.560
So as was mentioned earlier,
we haven't put anything in the kernel.

00:38:44.800 --> 00:38:46.860
For developers,
it's not released to Darwin.

00:38:46.860 --> 00:38:52.760
I'm able to consider some specialized
requests that I then need to go work

00:38:52.860 --> 00:38:59.440
with marketing and engineering on to make
sure that it's the right thing to do.

00:38:59.440 --> 00:39:02.360
But I do want to hear from you if you
need to do something in the kernel.

00:39:04.880 --> 00:39:07.350
So the roadmap, well,
this was yesterday's session,

00:39:07.410 --> 00:39:09.920
but as you're aware,
we do have DVDs that come out

00:39:10.010 --> 00:39:12.150
usually about three months
after developer conference,

00:39:12.160 --> 00:39:13.720
so that's one session you should look at.

00:39:13.760 --> 00:39:17.230
The other thing is that,
and I should have put it on the slide,

00:39:17.440 --> 00:39:22.280
Friday morning at 9 o'clock in this room,
we have a HID and force feedback session.

00:39:22.280 --> 00:39:24.890
And if you're doing HID devices,
or you want to be able to

00:39:24.890 --> 00:39:28.160
access a Bluetooth HID device,
you should come to this session.

00:39:28.660 --> 00:39:31.720
As was mentioned,
we really are strongly encouraging

00:39:31.740 --> 00:39:36.000
people to do everything that's
HID-related through the HID manager.

00:39:36.000 --> 00:39:40.350
So that includes Bluetooth, and in fact,
it could include almost

00:39:40.380 --> 00:39:42.240
any transport protocol.

00:39:42.240 --> 00:39:45.660
We could do HID controls over FireWire,
for that matter.

00:39:45.660 --> 00:39:50.640
The representation of a HID device
with a HID-style report descriptor

00:39:50.640 --> 00:39:53.900
and getting HID reports will
come in through the HID manager,

00:39:53.900 --> 00:39:55.660
regardless of the transport
layer in the future.

00:39:55.660 --> 00:39:58.400
And that's where we want
people to go to get HID data.

00:39:58.580 --> 00:39:59.710
Thank you.

00:40:00.680 --> 00:40:03.190
So contact-wise,
there's the standard list.

00:40:03.300 --> 00:40:06.350
I do encourage all of you to take a look
at the Bluetooth developer mailing list.

00:40:06.390 --> 00:40:11.940
I've got a long mural there,
but look for list.apple.com and then

00:40:12.050 --> 00:40:13.960
click on the lists on that website.

00:40:13.960 --> 00:40:16.720
There's a lot of lists run by us.

00:40:16.720 --> 00:40:19.390
Bluetooth is one of them,
and you should go there to

00:40:19.390 --> 00:40:22.910
participate in discussions with
other Bluetooth developers.

00:40:22.920 --> 00:40:26.590
Our standard reference library stuff.
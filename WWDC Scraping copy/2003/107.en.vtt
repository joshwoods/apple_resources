WEBVTT

00:00:21.510 --> 00:00:23.450
Good morning,
and welcome to the Kernel Programming

00:00:23.450 --> 00:00:25.020
Interfaces for Extension sessions.

00:00:25.030 --> 00:00:25.900
I'm Craig Keithley.

00:00:25.900 --> 00:00:28.170
I'm the I/O Technology Evangelist
in Apple's Worldwide

00:00:28.170 --> 00:00:29.400
Developer Relations Group.

00:00:29.400 --> 00:00:33.400
As the I/O Technology Evangelist,
I work with a lot of Kecks developers,

00:00:33.400 --> 00:00:38.400
and over the past couple of years,
we've faced some challenges with regard

00:00:38.400 --> 00:00:43.390
to making sure that we have a set
of consistent APIs that will remain

00:00:43.400 --> 00:00:47.400
useful through the life of a product.

00:00:47.400 --> 00:00:50.250
So we've now looked at
providing what's known as KPIs,

00:00:50.260 --> 00:00:52.390
or Kernel Programming Interfaces.

00:00:52.400 --> 00:00:56.910
To talk about that, Simon Patience,
Director of Engineering.

00:01:01.810 --> 00:01:06.240
Good morning.

00:01:06.240 --> 00:01:09.860
So let's briefly describe what's
going to be covered today.

00:01:09.860 --> 00:01:13.190
First of all,
we'll go through a definition of

00:01:13.250 --> 00:01:16.830
rationale of kernel interfaces,
and where we're gonna be taking them

00:01:16.830 --> 00:01:19.460
over the course of the next year or so.

00:01:19.460 --> 00:01:23.210
We'll be looking at how we're
going to be managing the version

00:01:23.310 --> 00:01:25.720
progressions as we evolve them.

00:01:25.720 --> 00:01:28.400
We'll have a look at
the effects on I/O Kit.

00:01:28.400 --> 00:01:32.780
We'll cover general kernel interfaces
and the file system interfaces.

00:01:32.790 --> 00:01:36.560
Then we'll have a look at some networking
interfaces for kernel extensions,

00:01:36.560 --> 00:01:38.980
and then we'll sum up, and then Q&A.

00:01:41.920 --> 00:01:43.640
So KPI's, so what are they?

00:01:43.780 --> 00:01:46.050
Well,
obviously kernel programming interfaces,

00:01:46.110 --> 00:01:48.800
there's obviously a relationship
between those and API's,

00:01:48.800 --> 00:01:53.200
just in the same way that in libraries
there's a whole lot of functions,

00:01:53.200 --> 00:01:55.000
but you don't actually get
to program to them all.

00:01:55.000 --> 00:01:58.800
We're using that kind of
analogy here for the kernel.

00:01:59.050 --> 00:02:02.450
The sets of well-defined
interfaces are bounded,

00:02:02.450 --> 00:02:03.800
as I mentioned.

00:02:03.800 --> 00:02:07.470
They cover both functions
that the kernel provides,

00:02:07.590 --> 00:02:10.910
but also the rules by
which you can access data.

00:02:11.570 --> 00:02:13.660
The sets are versioned.

00:02:13.770 --> 00:02:17.940
As we move through time,
we will be evolving these interfaces.

00:02:17.940 --> 00:02:22.680
Some will be changing,
some will be being added.

00:02:22.680 --> 00:02:25.260
And the reasons that they're versioned
is because they really reflect

00:02:25.260 --> 00:02:29.520
the implementation rather than
the interface as the system moves on.

00:02:29.520 --> 00:02:32.300
And we want to have a well-defined
lifecycle so that you know

00:02:32.350 --> 00:02:35.300
what's coming and what to

00:02:35.630 --> 00:02:38.840
We're currently targeting specific
classes of kernel extensions.

00:02:38.970 --> 00:02:43.420
We will be adding new
classes as there is demand,

00:02:43.420 --> 00:02:47.560
and as we can identify what the
correct interfaces for those will be.

00:02:50.410 --> 00:02:53.430
So let's have a look at one of the
motivating factors that we have

00:02:53.430 --> 00:02:57.620
for putting in kernel interfaces,
which is what we could describe

00:02:57.620 --> 00:02:59.870
as the Keck dependency problem.

00:02:59.970 --> 00:03:02.840
So here's a picture of the OS X kernel.

00:03:03.000 --> 00:03:05.200
There's a picture of your KEXT.

00:03:05.220 --> 00:03:08.590
As you load it,
let's say it's a networking KEXT.

00:03:08.950 --> 00:03:14.820
There's a set of interfaces which we
can clearly see you're dependent on,

00:03:14.820 --> 00:03:19.490
because those are the
unresolved symbols in your KEXT.

00:03:19.490 --> 00:03:23.030
The big problem for us
is that we have no idea,

00:03:23.330 --> 00:03:28.510
especially if you're going through data,
what these additional

00:03:28.640 --> 00:03:31.320
implicit dependencies are,
and so we cannot define what

00:03:31.320 --> 00:03:31.320
the compatibility points are
that your KEXT is depending on.

00:03:33.210 --> 00:03:36.180
So,
why do we need these kernel interfaces?

00:03:36.220 --> 00:03:40.890
Well, as I just mentioned,
KEX have no explicit dependencies,

00:03:40.930 --> 00:03:42.770
not a total set of explicit dependencies.

00:03:42.840 --> 00:03:46.600
We cannot work out exactly what
it is that we can't change.

00:03:46.630 --> 00:03:49.040
And OS X needs to evolve.

00:03:49.230 --> 00:03:52.700
There's a whole set of reasons
why we need to change the kernel.

00:03:52.700 --> 00:03:56.870
We have new features that we're coming
in to provide a better user experience.

00:03:57.150 --> 00:04:00.230
We have performance
improvements that we need to do.

00:04:00.640 --> 00:04:02.850
There are bug fixes, obviously.

00:04:02.850 --> 00:04:06.530
We try to limit the number of
bugs that we have in the system,

00:04:06.530 --> 00:04:09.820
but they do occur from time to time,
and we need to be able to fix

00:04:09.820 --> 00:04:12.500
those in ways that don't break
binary compatibility for KEX.

00:04:12.500 --> 00:04:15.260
Clearly, there's new hardware,
such as the hardware

00:04:15.420 --> 00:04:17.500
that was announced today,
this week.

00:04:17.500 --> 00:04:20.500
I mean, that takes a certain amount
of change in the kernel,

00:04:20.500 --> 00:04:24.470
and has ramifications on KEX,
if there are no boundaries.

00:04:24.500 --> 00:04:26.490
And, SMP support.

00:04:26.490 --> 00:04:30.100
The funnels are well-known
within the system,

00:04:30.100 --> 00:04:35.500
and we need to do something about
them to get better SMP performance.

00:04:35.520 --> 00:04:40.090
And so, without these interfaces,
this really makes change within the

00:04:40.090 --> 00:04:42.500
kernel very difficult to achieve.

00:04:42.500 --> 00:04:47.340
So, these interfaces define what I like
to call our innovation sandbox.

00:04:48.510 --> 00:04:50.960
So why would developers
want kernel interfaces?

00:04:51.020 --> 00:04:54.060
Well, first of all,
it means that we can have a

00:04:54.060 --> 00:04:57.260
set of interfaces that are
best suited for your needs.

00:04:57.360 --> 00:05:00.820
We can design them such that they perform
the functions that you're trying to

00:05:00.820 --> 00:05:03.400
achieve in the most efficient manner.

00:05:03.400 --> 00:05:06.550
We can improve the stability
of the environment,

00:05:06.550 --> 00:05:09.990
and we can provide binary
compatibility from release to

00:05:10.120 --> 00:05:12.270
release for these interfaces.

00:05:12.620 --> 00:05:16.940
and they've significantly reduced
the chance of us changing things that

00:05:16.970 --> 00:05:21.380
unbeknownst to us is breaking your KEXT,
because we can now test those

00:05:21.380 --> 00:05:24.800
interfaces and ensure that they
are semantically and syntactically

00:05:24.920 --> 00:05:26.890
equivalent from release to release.

00:05:30.130 --> 00:05:33.990
So we have a number of states,
just to let you know exactly where

00:05:33.990 --> 00:05:37.240
the status of this interface is.

00:05:37.260 --> 00:05:38.970
We have defined four states.

00:05:39.030 --> 00:05:42.850
The stable interface,
these are basically the things

00:05:42.940 --> 00:05:45.770
that you've seen in the kernel,
and the general stuff,

00:05:45.830 --> 00:05:49.000
all the libc functions, for example,
stuff like that.

00:05:49.070 --> 00:05:53.560
They're not going away,
and they're guaranteed to be

00:05:53.560 --> 00:05:55.470
in the next major release,
and so you can rely on

00:05:55.470 --> 00:05:55.470
those in your products.

00:05:56.270 --> 00:05:59.240
Compatibility interfaces are basically
the same as stable interfaces

00:05:59.240 --> 00:06:00.920
in terms of their longevity.

00:06:00.980 --> 00:06:03.070
The difference is the fact that
we're trying to mark them specially

00:06:03.130 --> 00:06:05.840
because they are there for porting
from one system to another,

00:06:05.840 --> 00:06:08.910
and they may not necessarily be the
most efficient interface to use.

00:06:08.920 --> 00:06:12.260
So we don't want to mix them
in with the stable interfaces.

00:06:12.260 --> 00:06:15.080
We want to indicate which
ones are the ones that you

00:06:15.080 --> 00:06:17.180
should really be going towards.

00:06:17.880 --> 00:06:21.920
When we decide that an interface
has to change or go away for

00:06:21.920 --> 00:06:26.600
various implementation reasons,
then we'll mark it as being deprecated.

00:06:26.600 --> 00:06:29.850
This means that the interface is going
to be removed or is planned to be

00:06:29.850 --> 00:06:32.000
removed in the following major release.

00:06:32.000 --> 00:06:35.240
And finally, we have another set,
which is called evolving.

00:06:35.240 --> 00:06:36.510
What is evolving?

00:06:37.270 --> 00:06:42.460
These interfaces are under development,
and normally under development with you.

00:06:42.460 --> 00:06:45.400
This is in order to be able to support
new kinds of KEX that we don't really

00:06:45.470 --> 00:06:48.180
know what the right interface is,
and we would like to work with

00:06:48.240 --> 00:06:53.130
you in order to be able to develop
the best set of interfaces,

00:06:53.240 --> 00:06:55.780
both for your purposes and for ours.

00:07:02.910 --> 00:07:05.300
So when are we going to be doing this?

00:07:05.350 --> 00:07:09.710
Well, the draft specification for these
interfaces is available now.

00:07:09.860 --> 00:07:12.800
We'll be giving you information about
how to get hold of them later on.

00:07:12.800 --> 00:07:16.790
This is really just the
interface specifications.

00:07:16.810 --> 00:07:21.800
The implementation for those will
be coming in the Panther timeframe.

00:07:21.800 --> 00:07:28.610
And during Panther, as the system evolves
in the Panther updates,

00:07:28.610 --> 00:07:32.800
we'll be also evolving these interfaces
and the implementations of them,

00:07:32.800 --> 00:07:38.250
so that you can track them to see
how we're adding to them and evolving

00:07:38.370 --> 00:07:43.100
them so that they become something
that we can actually make stable

00:07:43.150 --> 00:07:44.760
and say that we can live behind.

00:07:44.800 --> 00:07:48.440
The first set of stable
interfaces will be declared

00:07:48.440 --> 00:07:52.270
with enough time before Panther,
so that you can actually port to them and

00:07:52.270 --> 00:07:57.800
make sure that you are in a stable place
by the time the next release comes out,

00:07:57.880 --> 00:08:01.010
the post-Panther major release comes out,
where we will start to

00:08:01.010 --> 00:08:02.800
enforce these interfaces.

00:08:06.700 --> 00:08:09.570
And with that,
I'd like to hand over to Dean Reece,

00:08:09.600 --> 00:08:11.610
who's the Engineering Manager of
the I/O Kit team,

00:08:11.810 --> 00:08:19.390
who will talk about how we're going to
manage the versions of these interfaces.

00:08:25.830 --> 00:08:27.800
Thanks Simon, good morning.

00:08:27.800 --> 00:08:35.160
I'm going to be talking a bit about the
KEXT system and how we're going to manage

00:08:35.160 --> 00:08:39.870
the KPIs that Simon just talked about.

00:08:41.080 --> 00:08:44.160
So let's get right into it.

00:08:44.180 --> 00:08:47.720
For Panther,
the KEXT tools have not really changed.

00:08:47.720 --> 00:08:50.570
As you recall, for Jaguar,
we totally revved the entire

00:08:50.570 --> 00:08:54.000
set of kernel extension
management and development tools.

00:08:54.030 --> 00:08:55.890
Pretty much got them where
we wanted them to be,

00:08:55.890 --> 00:08:58.000
so for Panther,
we didn't really change them.

00:08:58.000 --> 00:09:01.520
We have, however,
added some new capabilities to support

00:09:01.520 --> 00:09:04.000
the kernel programming interfaces.

00:09:04.000 --> 00:09:06.000
Basically,
we've created a new type of KEXT.

00:09:06.000 --> 00:09:09.990
It's not something that you're
going to be needing to use directly.

00:09:09.990 --> 00:09:11.000
We're going to provide them.

00:09:11.000 --> 00:09:12.000
You'll link against them.

00:09:12.000 --> 00:09:15.260
It'll be pretty much transparent,
and I'm going to talk about

00:09:15.260 --> 00:09:17.000
that in the next few slides.

00:09:17.220 --> 00:09:19.940
But the fundamental
change that you'll notice,

00:09:20.000 --> 00:09:23.990
and again, it shouldn't really cause
any code changes for you,

00:09:24.000 --> 00:09:26.530
is that right now,
your KEXTs link directly

00:09:26.590 --> 00:09:28.000
against the kernel.

00:09:28.000 --> 00:09:30.620
And in Panther and beyond,
they will link indirectly

00:09:30.790 --> 00:09:32.000
against the kernel.

00:09:32.000 --> 00:09:34.000
I've got some diagrams
to show how that works.

00:09:34.000 --> 00:09:35.390
works.

00:09:36.670 --> 00:09:39.840
So in Jaguar,
if you list a dependency for

00:09:39.840 --> 00:09:45.300
your text on any of these
CFBundle identifiers here listed in blue,

00:09:45.300 --> 00:09:47.280
then you're saying that
you need the kernel.

00:09:47.360 --> 00:09:52.090
And because of the way that we did
the linking for kernel extensions,

00:09:52.140 --> 00:09:54.500
if you said you needed
something from BSD,

00:09:54.500 --> 00:09:57.560
then you actually got the
entire set of kernel symbols.

00:09:57.610 --> 00:10:01.600
So you could have a dependency over an
I/O Kit that you didn't actually declare,

00:10:01.600 --> 00:10:02.410
and it would actually work.

00:10:02.520 --> 00:10:06.360
But the linking would succeed
because you were getting the whole

00:10:06.360 --> 00:10:08.520
kernel and all the symbols in it.

00:10:08.520 --> 00:10:11.260
Obviously,
as we're trying to move towards

00:10:11.340 --> 00:10:14.140
an enforced interface design,
we can't have this.

00:10:14.140 --> 00:10:17.640
We have to have a little bit
more partitioning between the

00:10:17.710 --> 00:10:20.180
different programming interfaces.

00:10:20.600 --> 00:10:23.440
For all versions prior to 7.0,
this is true.

00:10:23.500 --> 00:10:26.740
If you link against one of these,
you get all of them for free.

00:10:28.400 --> 00:10:31.740
This is what it looks like,
sort of in a pictorial form.

00:10:31.830 --> 00:10:35.420
Basically,
all of the sub-identifiers for the

00:10:35.480 --> 00:10:38.820
kernel represented the whole kernel,
and no matter which one you linked on,

00:10:38.870 --> 00:10:40.680
you got the whole kernel.

00:10:43.890 --> 00:10:48.060
So in Panther, we're going to provide
binary compatibility through

00:10:48.230 --> 00:10:52.530
a set of interface keks,
the new type of keks I talked about.

00:10:52.590 --> 00:10:55.410
And basically all they
contain is a set of symbols.

00:10:55.470 --> 00:10:58.680
They're basically re-exporting
the symbols from the kernel.

00:10:58.710 --> 00:11:02.550
But they only export the set of
symbols that you should be using

00:11:02.560 --> 00:11:04.910
for whatever version you wanted.

00:11:05.100 --> 00:11:08.350
Basically what we're doing is taking
all of the symbols that shipped in,

00:11:08.380 --> 00:11:12.880
all the versions of Jaguar,
for all of the com.apple.kernel

00:11:12.890 --> 00:11:15.330
bundle identifiers,
and we're putting them together

00:11:15.330 --> 00:11:17.100
in one big interface KEXT.

00:11:17.120 --> 00:11:19.080
And if you list a
dependency on one of those,

00:11:19.080 --> 00:11:21.750
a version prior to 7.0,
then you're going to

00:11:21.810 --> 00:11:23.360
get that interface KEXT,
and you'll get all the

00:11:23.360 --> 00:11:26.950
symbols that you got before,
modulo a few that we had to take

00:11:26.970 --> 00:11:31.300
out to support the new G5 hardware.

00:11:31.440 --> 00:11:34.560
Basically, you're going to get exactly
what you got before.

00:11:34.570 --> 00:11:38.180
It should just come up and work.

00:11:38.720 --> 00:11:41.900
Yeah, let's move on and look at a
picture of how this looks.

00:11:41.940 --> 00:11:46.440
So, in this case,
your KEXT in orange there is linking

00:11:46.440 --> 00:11:50.540
against the BSD interface KEXT,
which supports compatibility,

00:11:50.540 --> 00:11:54.000
everything from version
1.1 up through version 6.0.

00:11:54.020 --> 00:11:56.870
Actually,
I think we've made that up through 6.9,

00:11:56.910 --> 00:11:58.760
just to give us some leeway there.

00:11:58.760 --> 00:12:01.290
And that, in turn,
links against the actual kernel,

00:12:01.290 --> 00:12:04.220
the actual running kernel,
and that sort of provides the filter

00:12:04.270 --> 00:12:08.040
to give you the correct set of symbols
for the version that you've asked for.

00:12:14.090 --> 00:12:19.440
So we're also going to provide a new set
of kernel interface KEXTs for Panther.

00:12:19.450 --> 00:12:23.240
These are going to be
version number seven.

00:12:23.350 --> 00:12:26.690
So they're going to contain all
the symbols that we believe we

00:12:26.710 --> 00:12:28.320
should support carrying forward.

00:12:28.330 --> 00:12:32.320
We're going to remove a large number of
symbols that are sort of internal support

00:12:32.400 --> 00:12:35.860
functions that really shouldn't have
ever been exported in the first place.

00:12:35.900 --> 00:12:39.220
And we're also going to add the
new functionality that we've

00:12:39.220 --> 00:12:41.160
introduced in Panther there.

00:12:41.220 --> 00:12:43.180
So basically,
if you've got a kernel extension

00:12:43.180 --> 00:12:45.550
that you've been shipping,
it'll continue to run in link in

00:12:45.550 --> 00:12:49.150
Panther because it'll link against
the older version one through version

00:12:49.150 --> 00:12:51.600
six compatibility interface KEXTs.

00:12:51.600 --> 00:12:53.970
And if you've got a brand new
kernel extension that needs to take

00:12:53.970 --> 00:12:57.510
advantage of new functionality,
then you use the new set.

00:13:02.010 --> 00:13:04.500
Okay, and this picture looks exactly
like the picture before,

00:13:04.500 --> 00:13:06.130
the only thing that's changed
is the version numbers.

00:13:06.140 --> 00:13:09.930
You'll see everything
across the board is 7.0.

00:13:15.370 --> 00:13:19.700
Now, we still provide a capability in
Panther that we provided in Jaguar,

00:13:19.700 --> 00:13:22.540
and that is you can still link
directly against the kernel.

00:13:22.540 --> 00:13:25.290
It's necessary, in fact,
as an implementation detail.

00:13:25.380 --> 00:13:27.520
Our interface keks link
directly against the kernel,

00:13:27.520 --> 00:13:30.180
and they actually play by the
same rules that your keks do.

00:13:30.290 --> 00:13:34.850
So, if you select com.apple.kernel
as the dependency,

00:13:34.930 --> 00:13:37.680
you will still get all of the
symbols exported by the kernel.

00:13:37.760 --> 00:13:41.930
Now, we don't guarantee any
release-to-release compatibility with

00:13:42.010 --> 00:13:45.980
the global set of symbol kernels,
because we can't, as Simon said,

00:13:45.980 --> 00:13:48.820
unless we have some enforcement
and partitioning here,

00:13:48.820 --> 00:13:51.900
we can't guarantee you compatibility,
because we can't know what

00:13:51.900 --> 00:13:55.300
exactly you've used out of
that large mass of interfaces.

00:13:55.400 --> 00:13:58.260
So, what we do,
every time we ship a new kernel,

00:13:58.330 --> 00:14:00.340
it gets a new version number,
as it should.

00:14:00.350 --> 00:14:02.380
And if you list a
dependency on the kernel,

00:14:02.450 --> 00:14:06.300
you must list a dependency on
an exact version of the kernel.

00:14:06.930 --> 00:14:09.090
The implication being that the
next time we ship a software

00:14:09.180 --> 00:14:12.700
update with a new kernel in it,
your kernel extension will not

00:14:12.700 --> 00:14:16.800
load on that version of the OS,
or the next major version as well.

00:14:16.800 --> 00:14:19.800
So, this is really not a
good way to ship product.

00:14:19.800 --> 00:14:22.800
It's useful in,
say with open source projects,

00:14:22.800 --> 00:14:27.360
where you're shipping source code,
and the client can recompile for whatever

00:14:27.370 --> 00:14:30.280
version of the OS they want to use,
or maybe in educational

00:14:30.370 --> 00:14:34.800
institutions where you're working
on a particular OS for a class.

00:14:34.800 --> 00:14:37.780
But, I thought I would point it out,
it is still a possibility,

00:14:37.800 --> 00:14:41.800
it just isn't something you would
really want to do as part of a product.

00:14:43.900 --> 00:14:45.290
and that's what that looks like.

00:14:45.390 --> 00:14:47.890
Basically you're bypassing all
of the compatibility interfaces,

00:14:47.890 --> 00:14:49.900
and you're linking straight
against the kernel.

00:14:49.900 --> 00:14:52.990
And again here you'll notice
the dependency version listed

00:14:52.990 --> 00:14:56.110
in the KEXT is identical to the
version of the kernel listed,

00:14:56.110 --> 00:14:58.230
otherwise the linkage would fail.

00:15:01.820 --> 00:15:05.160
So what does this mean
going beyond Panther?

00:15:05.210 --> 00:15:08.840
Well, basically you'll continue to use
the same rules you used today.

00:15:08.880 --> 00:15:13.000
We're introducing a new namespace,
actually not a new namespace,

00:15:13.060 --> 00:15:17.020
a new naming convention within
the existing CFBundle Identifier

00:15:17.020 --> 00:15:19.010
namespace that we already use.

00:15:19.060 --> 00:15:21.510
And that is com.apple.kpi.

00:15:21.510 --> 00:15:26.240
You'll see this in the Panther seed
CD that we've given out this week,

00:15:26.280 --> 00:15:28.360
and you'll see it more going forward.

00:15:28.360 --> 00:15:31.790
So com.apple.kernel will still be around,
and will represent the

00:15:31.800 --> 00:15:33.120
compatibility interfaces.

00:15:33.200 --> 00:15:36.490
com.apple.kpi will be used
going forward to present the

00:15:36.490 --> 00:15:39.920
new supportable interfaces,
and the two will coexist on

00:15:39.930 --> 00:15:41.950
the system as much as possible.

00:15:43.110 --> 00:15:47.400
We'll also use this mechanism to make
experimental interfaces available to you,

00:15:47.400 --> 00:15:54.000
as we, over the life of Panther,
deliver newer updates to our KPI package.

00:15:54.000 --> 00:15:56.340
We'll deliver that,
and that will introduce new

00:15:56.340 --> 00:15:59.260
interface kecks to your system,
possibly a new kernel as well for

00:15:59.260 --> 00:16:03.250
the implementation behind them,
but that'll partition them off

00:16:03.290 --> 00:16:06.970
from the compatibility interfaces,
because, again,

00:16:07.010 --> 00:16:11.790
the version numbers kind of
separate them into past and future.

00:16:13.280 --> 00:16:16.050
Obviously, and again as Simon said,
as the kernel evolves,

00:16:16.070 --> 00:16:19.720
we're going to need to deprecate APIs,
particularly initially as we

00:16:19.720 --> 00:16:23.190
start to thin that set down to the
ones that we really can support.

00:16:23.200 --> 00:16:27.790
KPIs allows us to do this because
we can have a version set that

00:16:27.790 --> 00:16:32.040
we maintain as long as possible,
and then whenever point in time

00:16:32.040 --> 00:16:35.310
it becomes impossible for us
to continue to support that,

00:16:35.310 --> 00:16:37.620
we can remove them,
and it won't affect anybody who's

00:16:37.620 --> 00:16:41.200
dependent on a different interface or
a different version of that interface.

00:16:41.200 --> 00:16:43.320
It will only affect the people
needing the old version of

00:16:43.320 --> 00:16:45.200
that particular interface.

00:16:45.340 --> 00:16:47.720
So it really provides
us a sliding window,

00:16:47.730 --> 00:16:52.200
or what I like to view it as sort of a
conveyor belt that's some length long,

00:16:52.200 --> 00:16:54.630
and we introduce an interface,
and we can support it pretty

00:16:54.640 --> 00:16:58.190
much as long as we want to,
but eventually we may have to move

00:16:58.190 --> 00:17:00.360
off of it as we evolve the kernel.

00:17:03.600 --> 00:17:06.450
Alright, so I'm also going to talk
a little bit this morning,

00:17:06.490 --> 00:17:11.240
put on my I/O Kit manager hat,
and talk about how this Panther release

00:17:11.380 --> 00:17:14.370
introduces new things for I/O Kit.

00:17:15.840 --> 00:17:19.050
So the good news is,
the I/O Kit in Panther is

00:17:19.250 --> 00:17:21.540
binary compatible with
what we shipped in Jaguar.

00:17:21.640 --> 00:17:26.570
So the V6 versions of the interfaces
that we ship will continue to load your

00:17:26.600 --> 00:17:30.490
I/O Kit keks from Jaguar on Panther,
and they should work.

00:17:30.560 --> 00:17:33.270
Obviously there's always
a potential for bugs.

00:17:33.290 --> 00:17:35.830
This is what you need to do,
is take the seed that we've given you,

00:17:35.940 --> 00:17:38.140
try it out with your products,
make sure that they work.

00:17:38.210 --> 00:17:40.140
Let us know if they don't.

00:17:40.210 --> 00:17:44.070
But the expectation is that
properly written kernel extensions

00:17:44.090 --> 00:17:46.990
for I/O kits should continue
to load and run on Panther.

00:17:47.790 --> 00:17:50.500
We've also introduced a few
new interfaces for Panther.

00:17:50.580 --> 00:17:53.340
Those are only available
in the V7 interface.

00:17:53.400 --> 00:17:56.500
Again, a kex needing V6 shouldn't
need those interfaces.

00:17:56.640 --> 00:17:59.300
And we've also deprecated
a few interfaces.

00:17:59.300 --> 00:18:02.070
I think they've actually been marked
in the header files for a couple

00:18:02.080 --> 00:18:03.800
years now as going to be deprecated.

00:18:03.800 --> 00:18:06.380
Well, now we have a mechanism to
actually deprecate them,

00:18:06.390 --> 00:18:07.790
so we're making use of that.

00:18:10.430 --> 00:18:14.300
Alright, so the V7 interface that we
provide in Panther for I/O Kit,

00:18:14.300 --> 00:18:17.100
it has a number of changes
to I/O Memory Descriptor.

00:18:17.100 --> 00:18:19.750
As you can imagine,
being able to address greater

00:18:19.750 --> 00:18:22.740
than 4 GB of memory has some
implications for the way drivers

00:18:22.740 --> 00:18:24.300
deal with physical memory.

00:18:24.300 --> 00:18:27.730
So, if you've used the abstractions for
I/O Memory Descriptor correctly,

00:18:27.770 --> 00:18:31.210
you should not have any problem with
your driver continuing to work on those

00:18:31.210 --> 00:18:33.290
machines and addressing large memory.

00:18:33.300 --> 00:18:39.300
If you've gone directly to the
PMAP functions or other workarounds,

00:18:39.300 --> 00:18:42.710
so that you've avoided Memory Descriptor,
then you probably won't

00:18:42.710 --> 00:18:44.300
work on those machines.

00:18:44.320 --> 00:18:46.290
So, you need to use Memory Descriptor.

00:18:46.320 --> 00:18:49.300
We've added some convenience
functions listed down here:

00:18:49.300 --> 00:18:52.300
I/O Mapped Read 8, 16, 32, 64.

00:18:52.350 --> 00:18:55.310
Basically,
these allow you to do direct I/O to

00:18:55.310 --> 00:19:00.380
your hardware without generating,
having to create new Memory Descriptors

00:19:00.380 --> 00:19:02.390
just for your registers.

00:19:03.760 --> 00:19:08.390
We've also removed a few from Panther V7,
from I/O Kit.

00:19:08.450 --> 00:19:11.600
These are two classes,
I think there's another one on the list.

00:19:11.640 --> 00:19:15.000
This is not a final list, obviously,
as Panther is not yet final.

00:19:15.180 --> 00:19:18.250
But I/O Command Queue and
I/O Sync are two classes that were

00:19:18.250 --> 00:19:22.530
introduced very early on in I/O Kit,
and were realized as not

00:19:22.530 --> 00:19:25.660
supportable long term,
and I think they've been marked

00:19:25.660 --> 00:19:27.200
as deprecated for quite a while.

00:19:27.200 --> 00:19:29.290
Hopefully this shouldn't
affect any of you,

00:19:29.290 --> 00:19:31.600
but again,
they will be present in the kernel,

00:19:31.600 --> 00:19:34.800
but they'll only be available for
linking if you have a V6 dependency.

00:19:34.800 --> 00:19:38.220
They'll just be absent
from the V7 dependency.

00:19:40.400 --> 00:19:42.990
So with that,
I would like to introduce Mark Gorlinsky,

00:19:42.990 --> 00:19:45.900
the manager of the kernel team at Apple.

00:19:45.900 --> 00:19:49.060
And take it away, Mark.

00:19:52.400 --> 00:19:56.400
Thank you for bringing my script with me.

00:19:56.400 --> 00:19:59.010
So as a kernel manager,
it's my job to improve

00:19:59.010 --> 00:20:02.220
the Mac OS X kernel and
maintain the stability,

00:20:02.220 --> 00:20:07.400
scalability, and performance without
breaking binary compatibility.

00:20:07.400 --> 00:20:11.050
Today we expose all
the kernel interfaces,

00:20:11.050 --> 00:20:15.400
and so every bug fix we make,
every feature we add,

00:20:15.400 --> 00:20:19.740
we risk the opportunity,
or we have the opportunity to

00:20:19.740 --> 00:20:21.400
break binary compatibility.

00:20:21.400 --> 00:20:27.470
So we needed a way to evolve the
Mac OS X kernel without breakage.

00:20:27.670 --> 00:20:29.840
So, we need to move forward.

00:20:29.840 --> 00:20:36.140
Today we used two funnels to address
the scalability of the MACWIS10 kernel,

00:20:36.140 --> 00:20:41.600
but funnel contention has led to a
performance impact of MP systems.

00:20:41.600 --> 00:20:44.600
To address this,
we're moving beyond the funnels.

00:20:44.600 --> 00:20:48.480
We're going to be making the
VSD kernel thread-safe and

00:20:48.480 --> 00:20:51.270
implementing fine-grain locking.

00:20:51.900 --> 00:20:56.780
We will also be making extensive
changes to the kernel data structures,

00:20:56.780 --> 00:20:59.900
which includes adding
reference and usage counts.

00:20:59.900 --> 00:21:02.900
So kernel data structures
are going opaque,

00:21:02.900 --> 00:21:05.900
and they'll be accessible
only through data accessors,

00:21:05.900 --> 00:21:08.900
functional routines,
and convenience APIs.

00:21:08.900 --> 00:21:12.940
We will also be exposing locking
protocols of the data structures,

00:21:12.940 --> 00:21:16.850
where it leads to efficiency,
but otherwise we will be hiding the

00:21:16.860 --> 00:21:18.900
locking details behind the interface.

00:21:18.900 --> 00:21:22.900
All new interfaces will be MP safe.

00:21:22.900 --> 00:21:26.130
This includes data accessors,
functional routines,

00:21:26.130 --> 00:21:27.800
as well as convenience APIs.

00:21:32.410 --> 00:21:35.900
Today the file system
block numbers are 32 bits.

00:21:35.900 --> 00:21:39.300
As we move forward,
they're going to be going to 64 bit.

00:21:39.300 --> 00:21:43.300
This is important for
large file system volumes.

00:21:43.300 --> 00:21:48.300
Also, it will have an impact on all
interfaces that use block numbers.

00:21:48.300 --> 00:21:52.700
File system vnode operations are
currently not symmetric with respect to

00:21:52.700 --> 00:21:55.300
vnode locking and reference counting.

00:21:55.300 --> 00:22:00.300
This makes the job of providing efficient
stackable file systems very difficult.

00:22:00.300 --> 00:22:06.450
For example, operations such as vopclose
and vopgetatter are entered

00:22:06.450 --> 00:22:10.300
without locks being held,
vnode locks.

00:22:10.320 --> 00:22:14.300
Moving forward,
all vnode locking will be symmetric.

00:22:14.300 --> 00:22:18.310
There are also many common
functions in the VFS layer

00:22:18.310 --> 00:22:23.140
that the VFS layer should have,
that are currently replicated

00:22:23.140 --> 00:22:25.300
by all the file systems.

00:22:25.300 --> 00:22:28.300
To address this,
we are moving some of this

00:22:28.300 --> 00:22:28.300
functionality into the VFS layer.

00:22:28.300 --> 00:22:33.200
For example,
functionality like NFS export,

00:22:33.200 --> 00:22:38.710
device alias checks,
will be moving into this area,

00:22:38.710 --> 00:22:40.300
this layer.

00:22:40.300 --> 00:22:41.450
Keep in mind that the goal
of these interfaces is to

00:22:41.450 --> 00:22:47.750
allow the Mac OS X kernel
to evolve without breakage.

00:22:48.910 --> 00:22:53.880
When we started this,
we took a look at our

00:22:53.880 --> 00:22:57.140
own kernel interfaces,
we looked at our shipping file system

00:22:57.140 --> 00:22:58.900
drivers and networking extensions.

00:22:58.900 --> 00:23:04.900
We determined that drivers and ILCit
based extensions were in good shape,

00:23:04.900 --> 00:23:09.060
so we decided to first address BSD file
systems and network extensions,

00:23:09.060 --> 00:23:11.900
and we'll address other extensions later.

00:23:11.900 --> 00:23:15.180
We considered only providing
interfaces that were reliable,

00:23:15.180 --> 00:23:18.880
scalable, and could be implemented
without affecting compatibility

00:23:18.880 --> 00:23:20.900
of the extensions.

00:23:20.900 --> 00:23:23.900
This is our first round of
iterating on these interfaces.

00:23:23.900 --> 00:23:28.890
We are expecting them to evolve,
and we look forward to your feedback.

00:23:31.100 --> 00:23:35.050
Okay, this diagram gives you a
perspective as to where file system

00:23:35.050 --> 00:23:38.100
extensions reside in the kernel.

00:23:38.100 --> 00:23:45.810
As you can see,
file system operations are dispatched

00:23:45.810 --> 00:23:45.810
through the VFS layer as a set of

00:23:46.020 --> 00:23:52.070
VFS and VNode Operations.

00:23:52.070 --> 00:23:52.070
Let's look at what other
interfaces they may use.

00:23:52.540 --> 00:24:00.650
Okay, so like I said,
they are implemented as VFS and VNodeOps.

00:24:01.310 --> 00:24:05.980
They also use Common C functions
and Kernel Support functions,

00:24:05.980 --> 00:24:09.000
which every kernel extension can use.

00:24:09.030 --> 00:24:13.540
They also utilize functions that
the BSD kernel extensions would use,

00:24:13.540 --> 00:24:17.300
such as credentials for
authentication and process APIs.

00:24:17.300 --> 00:24:23.610
They also utilize file system specific
interfaces for file data caching,

00:24:23.610 --> 00:24:26.300
such as Buffer Cache and UBC.

00:24:26.300 --> 00:24:30.300
Let's take a look at C functions here.

00:24:30.300 --> 00:24:31.370
Thank you.

00:24:32.000 --> 00:24:36.130
Okay, so the kernel provides a
subset of standard C functions,

00:24:36.130 --> 00:24:39.000
such as string and memory manipulation.

00:24:39.000 --> 00:24:42.350
As a kernel extension developer,
you should be aware that these

00:24:42.350 --> 00:24:47.000
functions are not as fully featured
as their user layer libc counterparts.

00:24:47.000 --> 00:24:53.600
Also, there's really no change
that's any significance here.

00:24:53.600 --> 00:24:57.210
Kernel extensions will continue
to have access to all the standard

00:24:57.210 --> 00:24:59.000
C functions that exist today.

00:24:59.000 --> 00:25:04.950
Additionally,
there are kernel support interfaces,

00:25:07.600 --> 00:25:11.220
That provide access to resource
management and thread control,

00:25:11.220 --> 00:25:14.600
as well as memory management
routines such as malloc and free,

00:25:14.600 --> 00:25:17.720
synchronization routines
like sleep and wake up,

00:25:17.720 --> 00:25:21.240
routines to provide locking
using simple locks and mutexes,

00:25:21.240 --> 00:25:24.600
which can be used by kernel
extensions to protect their data.

00:25:24.600 --> 00:25:26.970
There are also routines
to do thread call out,

00:25:26.970 --> 00:25:30.660
routines for data copy like copy in,
copy out, which will be changing to

00:25:30.660 --> 00:25:32.600
support 64-bit addresses.

00:25:32.600 --> 00:25:38.600
So far, the interfaces we've discussed
are relatively gone on change,

00:25:38.600 --> 00:25:41.600
with the exception of
64-bit address support.

00:25:41.600 --> 00:25:44.780
However,
as you'll see from this point on,

00:25:44.780 --> 00:25:48.490
you'll see a significant
change in the interfaces.

00:25:50.170 --> 00:25:56.690
Many kernel extension use routines that
are considered BSD kernel interfaces,

00:25:57.000 --> 00:26:00.390
We are providing interfaces
for authentication and process

00:26:00.390 --> 00:26:01.900
limits and process IDs.

00:26:01.900 --> 00:26:06.670
For example, for a given process ID,
you can signal the process or you

00:26:06.670 --> 00:26:13.960
can get a handle to the process,
but you should now be aware that

00:26:13.960 --> 00:26:16.580
this handle is opaque and does not
point to the process struct directly.

00:26:17.400 --> 00:26:21.940
and it comes with a reference count
that will have to be dropped later.

00:26:21.940 --> 00:26:25.700
Also we are moving towards
thread based credentials.

00:26:25.700 --> 00:26:28.660
These credentials,
the credentials that are processed,

00:26:28.660 --> 00:26:34.460
enters the syscall with, you know,
the thread enters the syscall actually,

00:26:34.460 --> 00:26:37.120
will be stored in a
thread local data area,

00:26:37.120 --> 00:26:40.180
so it can be accessed
quickly without contention.

00:26:40.180 --> 00:26:45.220
We will also be providing interfaces
to obtain a reference V node or

00:26:45.220 --> 00:26:48.900
socket through a file descriptor,
we will consider adding other

00:26:48.910 --> 00:26:53.940
interfaces to things like file ops
and TTYs sometime in the future.

00:26:53.940 --> 00:26:57.650
If you need access to
something that is not covered,

00:26:57.660 --> 00:26:59.380
send us your feedback.

00:26:59.400 --> 00:27:04.030
However, some interfaces,
we chose not to provide

00:27:04.030 --> 00:27:08.160
interfaces at risk stability
and that are not sustainable.

00:27:08.160 --> 00:27:11.860
For example,
direct access to the system call

00:27:11.860 --> 00:27:14.800
table is not going to be provided.

00:27:14.800 --> 00:27:17.080
In these cases,
you will have to work with us,

00:27:17.080 --> 00:27:23.860
possibly find alternative mechanisms
or work with us so we can provide you

00:27:23.860 --> 00:27:27.220
with a sustainable and stable mechanism.

00:27:28.400 --> 00:27:35.100
File Caching These interfaces are mostly
used by file system kernel extensions

00:27:35.100 --> 00:27:37.400
to do caching of meta and file data.

00:27:37.400 --> 00:27:42.400
Both structbuf and
ubcinfo are going opaque.

00:27:42.400 --> 00:27:46.400
All data structures are going opaque.

00:27:46.400 --> 00:27:48.890
For buffer cache,
we have left the semantics

00:27:48.890 --> 00:27:53.010
and usage the same,
but we have implemented new interfaces

00:27:53.010 --> 00:27:56.400
to use 64-bit block numbers.

00:27:56.400 --> 00:28:00.300
For example,
getblock is now called buff_getblock,

00:28:00.300 --> 00:28:03.400
and it takes a 64-bit block number.

00:28:03.400 --> 00:28:07.490
We have also left the
semantics of UBC the same,

00:28:07.490 --> 00:28:11.890
except for the UBC macros,
such as UBC is invalid,

00:28:11.890 --> 00:28:14.790
are now actually functions.

00:28:15.100 --> 00:28:18.400
Otherwise,
we have maintained the same API,

00:28:18.400 --> 00:28:22.100
but remember,
these structures are now opaque.

00:28:22.100 --> 00:28:25.340
So, another example would be bwrite.

00:28:25.340 --> 00:28:30.520
Instead of taking a struct buff,
it now takes a buff t.

00:28:30.800 --> 00:28:34.520
Throughout all our efforts,
we've tried to maintain the

00:28:34.520 --> 00:28:36.800
familiarity of the subsystem.

00:28:36.800 --> 00:28:38.800
We didn't want you to have
to learn all new interfaces.

00:28:38.800 --> 00:28:43.810
But we had to make changes to support
the opaqueness of the data structures

00:28:43.810 --> 00:28:45.800
and for locking and reference counting.

00:28:45.800 --> 00:28:51.790
If there's an interface, again,
that we missed, send us your feedback.

00:28:53.100 --> 00:28:54.720
Okay.

00:28:54.720 --> 00:28:56.940
VFS Ops.

00:28:56.940 --> 00:29:00.710
VFS operations are already a
set of well-defined routines to

00:29:00.710 --> 00:29:03.100
manipulate individual volumes
through a mount structure.

00:29:03.100 --> 00:29:06.100
However,
the mount structure is now opaque,

00:29:06.100 --> 00:29:08.100
and is called mount_t, mount_t.

00:29:08.100 --> 00:29:12.100
This is the data type every
VFS operation will receive.

00:29:12.100 --> 00:29:15.450
We are now providing new accessors,
accessor functions to

00:29:15.460 --> 00:29:16.900
the mount structure.

00:29:16.900 --> 00:29:22.100
For example, instead of testing mount_rd
only in the mount flags,

00:29:22.100 --> 00:29:28.100
you would now use VFS is_rd only to check
the file system is mounted read only.

00:29:28.100 --> 00:29:32.590
All mount flags that are visible
directly to user level will be exposed.

00:29:32.590 --> 00:29:37.100
Additional functions will cover
access to other kernel mount flags.

00:29:37.100 --> 00:29:40.710
Oop, I need to go back.

00:29:41.800 --> 00:29:47.100
We have also added interfaces
like VFS Iterate to provide

00:29:47.100 --> 00:29:49.800
access to VNodes on a given mount.

00:29:49.800 --> 00:29:52.800
These are done in an MP Safe way.

00:29:52.800 --> 00:29:56.760
We have renamed and modified
the StataFS structure.

00:29:56.760 --> 00:29:58.980
It is now called VFS StataFS.

00:29:58.980 --> 00:30:01.950
We have changed the block
number fields to 64-bit,

00:30:01.950 --> 00:30:04.800
so we can support large
file system volumes.

00:30:04.800 --> 00:30:09.620
We have expanded the path
names to max_path_length to

00:30:09.620 --> 00:30:12.800
address localization issues.

00:30:12.800 --> 00:30:17.890
We have created a new I/O attribute
structure called VFS I/O Atter.

00:30:18.200 --> 00:30:25.870
Again, this is the structure that
contains IO attributes

00:30:25.870 --> 00:30:25.870
associated with the map point,
but we have added some new

00:30:26.100 --> 00:30:30.190
New information about the device
capabilities such as how many

00:30:30.190 --> 00:30:34.100
bytes the device can actually
read and write at one time.

00:30:34.100 --> 00:30:36.870
There are also new interfaces
to get and set these structures

00:30:36.870 --> 00:30:38.380
within the mount structure.

00:30:38.600 --> 00:30:41.880
Also,
we've added some new VFS operations to

00:30:41.880 --> 00:30:45.840
support dynamic growth of a file system.

00:30:45.840 --> 00:30:48.600
They are VFS Extend and VFS Truncate.

00:30:48.600 --> 00:30:53.760
We have added VFS Uninit
to complement VFS Init.

00:30:55.500 --> 00:31:00.460
We moved them both to file system
registration instead of VFS op.

00:31:00.460 --> 00:31:05.500
We have untangled VFS mount
operations and defined new

00:31:05.500 --> 00:31:08.500
VFS ops for update and reload.

00:31:08.500 --> 00:31:12.500
This was done to keep the logic
and code clean and uncomplicated.

00:31:12.500 --> 00:31:19.500
VFS operations are defined by a
structure with various function pointers.

00:31:19.500 --> 00:31:23.540
We are changing this to be similar
to the way that VNode ops are done.

00:31:23.540 --> 00:31:28.400
We will make VFF ops extensible so
that we don't have to worry about

00:31:28.400 --> 00:31:30.570
breakage when we add new VFS ops.

00:31:31.500 --> 00:31:34.840
Okay, VNode Ops,
VNode operations are a set

00:31:34.840 --> 00:31:39.030
of well-defined routines to
manipulate individual files

00:31:39.030 --> 00:31:42.370
through a VNode structure.

00:31:42.370 --> 00:31:42.370
Again,

00:31:42.900 --> 00:31:46.230
As in all the data structures,
VNode structure is now

00:31:46.230 --> 00:31:49.100
opaque and is called VNodeT.

00:31:49.100 --> 00:31:52.940
This will be the data type all
VNode operations will receive.

00:31:53.000 --> 00:31:57.420
and we are also providing new
accessor functions for this structure.

00:31:57.420 --> 00:32:02.000
We are making VNode operations
symmetric with respect to VNode locking,

00:32:02.000 --> 00:32:06.820
and this does have an impact on

00:32:08.400 --> 00:32:10.280
We have also modified the
VNode locks with respect to how

00:32:10.280 --> 00:32:11.400
you manage your VNode locks.

00:32:11.400 --> 00:32:18.510
We wanted to empower the file systems
to enforce the locking their way,

00:32:18.510 --> 00:32:22.670
so now file systems don't have
to use the same locking rules

00:32:22.670 --> 00:32:25.400
that VFS used to be enforcing.

00:32:25.400 --> 00:32:28.840
So if a file system wants
to provide multi-reader,

00:32:28.840 --> 00:32:31.960
single writer locks,
they will be able to do so

00:32:31.960 --> 00:32:36.400
without having every file system
support the locking semantics.

00:32:36.400 --> 00:32:43.980
We have also modified the sequence
of events to create a VNode.

00:32:44.300 --> 00:32:47.570
Instead of calling get new VNode,
and then associating the relevant

00:32:47.570 --> 00:32:51.590
data and so on to the VNode structure,

00:32:51.900 --> 00:32:56.460
You can now call vnode create,
which passes in all the relevant

00:32:56.460 --> 00:32:59.130
information in one call.

00:32:59.800 --> 00:33:00.800
and others.

00:33:00.800 --> 00:33:06.160
The main thing is to make sure
that the kernel is fully structured

00:33:06.160 --> 00:33:11.000
and has complete information.

00:33:11.000 --> 00:33:17.460
In this way we avoid having to use
too many accessors to set all this up.

00:33:17.460 --> 00:33:21.940
The side effect is you have the
ability to manage your own inode pool

00:33:21.940 --> 00:33:25.070
without tying it to the vnode pool.

00:33:27.540 --> 00:33:31.050
We are adding new functionality
to suspend and resume a VNode

00:33:31.050 --> 00:33:32.660
and a mounted file system.

00:33:32.660 --> 00:33:35.710
This can be used to acquiesce
an entire file system,

00:33:35.710 --> 00:33:39.780
so we can make on-disk
manipulation changes.

00:33:41.090 --> 00:33:48.110
Finally, there's a new VADDR structure
that's been updated to support

00:33:48.110 --> 00:33:52.240
64-bit blocks called VNode VADDRT.

00:33:52.240 --> 00:33:57.150
And I just want to
close with saying that,

00:33:57.160 --> 00:34:02.790
again,
we are iterating on these interfaces,

00:34:02.790 --> 00:34:05.700
and your feedback is going
to be very important to us.

00:34:05.700 --> 00:34:05.700
Otherwise,

00:34:06.500 --> 00:34:11.740
We consider the interfaces not complete
if you don't give us your feedback.

00:34:11.740 --> 00:34:15.220
You get to help determine our
future and your own future as

00:34:15.220 --> 00:34:17.460
to where these interfaces go.

00:34:17.460 --> 00:34:20.020
That's it.

00:34:20.020 --> 00:34:26.010
I'd like to introduce Josh Graessley,
who will be doing Network Extensions.

00:34:31.600 --> 00:34:34.530
Hi, I'm going to be telling you about
the network kernel programming

00:34:34.530 --> 00:34:37.230
interfaces that we've been working on.

00:34:40.300 --> 00:34:43.790
We have six interfaces
we've been planning.

00:34:43.800 --> 00:34:49.700
The mbuf socket, socket filter,
IP filter, interface filter,

00:34:49.700 --> 00:34:49.700
and interface.

00:34:51.100 --> 00:34:53.910
And here's a diagram of
the networking stack.

00:34:53.920 --> 00:34:57.030
So at the top we have the sockets,
and between the sockets and the

00:34:57.030 --> 00:34:59.380
protocols we have socket filters.

00:34:59.380 --> 00:35:02.610
And attached to IP we have IP filters.

00:35:03.360 --> 00:35:07.800
and down at the bottom we have interfaces
with interface filters attached to those.

00:35:07.800 --> 00:35:12.600
All of the items in purple will be,
kernel extensions can

00:35:12.600 --> 00:35:14.560
supply to the stack.

00:35:17.360 --> 00:35:20.220
So, as a engineer that's been working
on the stack for quite a while,

00:35:20.220 --> 00:35:24.320
I spend a lot of time tracking down bugs,
and I quite often run into

00:35:24.320 --> 00:35:27.370
a bug that has a simple fix,
but the simple fix would end

00:35:27.370 --> 00:35:29.080
up breaking a kernel extension.

00:35:29.080 --> 00:35:32.770
So we end up with some pretty
innovative fixes in the kernel,

00:35:32.770 --> 00:35:36.800
which we're getting a little...
we'd like to do better.

00:35:36.820 --> 00:35:41.740
So one of our goals is to make
all of the data structures opaque,

00:35:41.740 --> 00:35:41.740
so we can extend them when we need to.

00:35:42.100 --> 00:35:45.470
We're going to change a lot of the
filters to be based on operations

00:35:45.470 --> 00:35:46.740
instead of implementation.

00:35:46.740 --> 00:35:48.970
As much of the implementation
as we can hide from you,

00:35:48.970 --> 00:35:51.890
the better off we are,
because that lets us change it.

00:35:52.240 --> 00:35:58.120
We'll modify a lot of the fun--
The new APIs return errors more

00:35:58.120 --> 00:36:01.450
often than the old ones did.

00:36:01.450 --> 00:36:07.520
So, for example,
instead of-- When you call mclget,

00:36:07.520 --> 00:36:09.090
instead of checking a flag to determine
whether or not the call succeeded,

00:36:09.090 --> 00:36:09.090
the call will just return
an error if it didn't work.

00:36:09.870 --> 00:36:13.260
We're also looking at
additional interface sets.

00:36:13.270 --> 00:36:16.340
We're looking at adding support
for new interface families,

00:36:16.340 --> 00:36:18.560
as well as new protocols.

00:36:20.500 --> 00:36:23.440
First KPI is the mbuf KPI.

00:36:23.440 --> 00:36:27.140
All of the packets in the networking
stack are stored in mbufs.

00:36:27.140 --> 00:36:31.260
The mbuf structure used to be
visible to kernel extensions,

00:36:31.260 --> 00:36:32.500
but we're making a change.

00:36:32.500 --> 00:36:36.500
The mbuf will be opaque,
and it will be referenced with an mbuf_t.

00:36:36.500 --> 00:36:40.920
You'll be provided accessor functions
for allocating and manipulating mbufs,

00:36:40.920 --> 00:36:44.560
as well as inspecting them and
getting to the data that they contain.

00:36:45.110 --> 00:36:48.000
The naming of the new functions will
be consistent with the old functions,

00:36:48.000 --> 00:36:50.600
so it should be pretty simple
to port most of your code.

00:36:50.600 --> 00:36:57.990
For example, mtd becomes mbuf_mtd,
and m_freem becomes mbuf_freem.

00:36:58.410 --> 00:37:00.400
Most of the functions
will return errors now.

00:37:00.400 --> 00:37:02.180
MCL_GET is a great example of that.

00:37:02.180 --> 00:37:06.010
It should make the code a
little bit less error prone.

00:37:08.600 --> 00:37:12.740
Again, we have the network diagram,
the diagram of the stack,

00:37:12.750 --> 00:37:16.580
and at the top we have the sockets,
and we will be providing

00:37:16.580 --> 00:37:20.600
a socket interface,
or socket KPI to kernel extensions,

00:37:20.600 --> 00:37:23.600
so they can make use of
sockets within the kernel.

00:37:23.600 --> 00:37:25.600
Common use of this would
be a network file system.

00:37:25.600 --> 00:37:29.380
The socket KPI will be provided
so they can perform all of their

00:37:29.380 --> 00:37:31.600
network operations using this.

00:37:31.600 --> 00:37:35.600
The KPI is based on the user space APIs.

00:37:35.600 --> 00:37:38.600
To create a socket,
the kernel extension uses

00:37:38.600 --> 00:37:39.740
sock underscore socket.

00:37:39.740 --> 00:37:44.430
To bind to a specific address and port,
it uses sock underscore bind.

00:37:44.700 --> 00:37:48.140
The socket and proto-SW
structures will now be opaque.

00:37:48.140 --> 00:37:50.840
You will have no direct
access to these structures,

00:37:50.850 --> 00:37:53.700
and the protocol control
block will also be hidden.

00:37:53.700 --> 00:37:56.610
So you'll need to use things
such as get_sock_name,

00:37:56.610 --> 00:37:59.970
get_peer_name,
and get_sock_opt to get access

00:37:59.970 --> 00:38:04.210
to the information that's stored
in the protocol control blocks.

00:38:06.800 --> 00:38:12.480
Between the sockets and the protocols,
we have socket filters.

00:38:12.480 --> 00:38:16.460
Socket filters have been
completely rewritten.

00:38:17.350 --> 00:38:21.200
They are now based on the operations,
instead of the implementation.

00:38:21.200 --> 00:38:26.410
It lets you filter data and
commands at the socket layer.

00:38:26.510 --> 00:38:29.370
You'll be able to receive
notification of changes,

00:38:29.370 --> 00:38:31.360
of state changes to the socket.

00:38:31.360 --> 00:38:33.560
For example,
you'll get a state change notification

00:38:33.560 --> 00:38:37.500
when the socket goes from the
connecting state to the connected state.

00:38:37.510 --> 00:38:41.790
You'll no longer be able to
intercept or prevent these changes.

00:38:42.080 --> 00:38:46.840
We also allow you to specify
inbound and outbound data filters.

00:38:46.840 --> 00:38:50.420
The inbound data filter
will pass data to you,

00:38:50.420 --> 00:38:51.700
no matter how it comes in.

00:38:51.700 --> 00:38:53.840
In the past,
you used to have to filter SBAppend,

00:38:53.840 --> 00:38:58.580
SBAppend data, SBAppend control,
and a wide variety of similar things.

00:38:58.580 --> 00:39:00.260
And there were some
other problems with that.

00:39:00.260 --> 00:39:04.330
If you're filtering inbound data
and TCP input called SBAppend to

00:39:04.340 --> 00:39:06.950
put the data in the socket buffer,

00:39:07.110 --> 00:39:12.450
When, if your kernel extension
held onto the data,

00:39:12.450 --> 00:39:19.860
so that it could later re-inject it,
and it returned, you just return,

00:39:19.860 --> 00:39:26.410
SBA pin didn't actually have any
semantics to let the caller know

00:39:26.410 --> 00:39:26.490
whether or not there was data
appended to the socket buffer.

00:39:26.490 --> 00:39:26.490
So, TCP would go ahead and wake up the,

00:39:27.000 --> 00:39:30.240
and the client who was
waiting on the socket.

00:39:30.240 --> 00:39:34.050
The client would read, get 0 bytes read,
and it would think it was an end of

00:39:34.050 --> 00:39:40.110
file and erroneously close the socket,
which would lead to lots

00:39:40.110 --> 00:39:40.110
of strange problems.

00:39:41.240 --> 00:39:44.640
So we have inbound and outbound
data filters that should just work,

00:39:44.640 --> 00:39:46.340
and make things a lot simpler.

00:39:46.360 --> 00:39:49.240
We also have inbound and
outbound connection filters.

00:39:49.240 --> 00:39:52.010
So your inbound connection filter
is past the address that the

00:39:52.010 --> 00:39:54.550
connection is coming in from,
and you'll have an

00:39:54.550 --> 00:39:55.880
opportunity to refuse that.

00:39:55.880 --> 00:39:57.940
In the case of TCP,
we'll actually send a reset,

00:39:57.940 --> 00:39:59.500
if you refuse the connection.

00:39:59.500 --> 00:40:03.570
So you could potentially build a firewall
using these filters at the socket layer,

00:40:03.570 --> 00:40:05.900
instead of doing it at the packet layer.

00:40:06.900 --> 00:40:12.210
We can also filter outbound connections,
so you can enforce stricter security.

00:40:13.030 --> 00:40:18.750
You can also filter on binds
and get and set socket options,

00:40:18.750 --> 00:40:18.750
as well as listen and di-octal.

00:40:21.240 --> 00:40:23.840
Moving down the stack a little bit,
attached to the IP protocol,

00:40:23.840 --> 00:40:25.140
we have IP filters.

00:40:25.140 --> 00:40:32.460
The IP filters give you a place
to filter packets at the IP layer,

00:40:32.460 --> 00:40:34.160
it's brand new.

00:40:34.160 --> 00:40:36.460
You can filter inbound
and outbound packets,

00:40:36.460 --> 00:40:38.710
and on the inbound side,
you get the packet after

00:40:38.710 --> 00:40:41.130
it's been reassembled,
and after all of the media specific

00:40:41.130 --> 00:40:43.150
headers have been stripped off.

00:40:43.250 --> 00:40:46.960
You also get to filter both before and
after IPSec processing has occurred.

00:40:46.980 --> 00:40:49.340
So if the packets are
encrypted and authenticated,

00:40:49.340 --> 00:40:52.900
you'll get to see it both when it's
encrypted and after it's been decrypted.

00:40:52.900 --> 00:40:57.530
And you'll get to see any credentials
or any authentication that's occurred.

00:40:58.470 --> 00:41:01.800
On the outbound side,
you'll get to filter before

00:41:01.800 --> 00:41:07.160
the packet's been fragmented,
and before

00:41:08.200 --> 00:41:12.660
Before we apply the IPSec processing,
this will let you modify the data before

00:41:12.660 --> 00:41:17.000
it gets encrypted and authenticated,
and inspect it before it's encrypted

00:41:17.000 --> 00:41:19.360
and won't mean anything to you anymore.

00:41:19.360 --> 00:41:22.910
The filters can be attached
to IPv4 as well as IPv6.

00:41:25.100 --> 00:41:29.400
and moving down the stack further,
attached to the interfaces we have

00:41:29.400 --> 00:41:34.310
interface filters that let you filter
packets at the interface layer.

00:41:34.900 --> 00:41:39.330
The Network Interface Filter KPI provides
kernel extensions the ability to

00:41:39.330 --> 00:41:45.330
attach these filters to interfaces.

00:41:46.300 --> 00:41:49.440
The interface filters are based
on the DLL interface filters,

00:41:49.440 --> 00:41:52.580
the difference being that
the types are all opaque.

00:41:52.580 --> 00:41:56.110
You'll be able to filter inbound and
outbound packets on an interface,

00:41:56.110 --> 00:42:01.170
as well as iOctyls to an interface,
and events coming from an interface.

00:42:04.310 --> 00:42:06.270
and at the bottom of
the networking stack,

00:42:06.280 --> 00:42:09.300
we have the interfaces themselves.

00:42:09.300 --> 00:42:15.410
The Network Interface
KPI provides a number of things

00:42:15.410 --> 00:42:17.350
you can do with the interfaces.

00:42:17.500 --> 00:42:22.500
The interface is used to be
represented by IFNET structures.

00:42:22.500 --> 00:42:26.500
The IFNET structure will now be opaque,
and you will get a reference to it.

00:42:26.500 --> 00:42:33.970
The structure is reference counted,
and will provide accessors for inspecting

00:42:33.970 --> 00:42:40.090
various properties of the interface,
as well as sending packets,

00:42:40.090 --> 00:42:40.090
and performing I-Octols,
and other various operations.

00:42:40.300 --> 00:42:43.360
We'll also give you functions
for getting a list of interfaces,

00:42:43.360 --> 00:42:46.180
and finding a specific interface.

00:42:46.300 --> 00:42:49.340
You'll also have the ability to
retrieve a list of addresses that

00:42:49.340 --> 00:42:53.200
are attached to the interface,
as well as multicast addresses,

00:42:53.200 --> 00:42:56.040
and you'll be able to
join and leave multicasts.

00:42:56.040 --> 00:42:58.770
You'll also be able to add an interface,
but you'll only be able to add

00:42:58.770 --> 00:43:02.720
an interface that belongs to
an existing interface family,

00:43:02.720 --> 00:43:08.160
such as Ethernet, PPP, and FireWire.

00:43:08.160 --> 00:43:11.790
And with that,
I'd like to bring Simon up for a summary.

00:43:21.480 --> 00:43:25.630
So, obviously we can't go into huge
amounts of detail in the amount

00:43:25.720 --> 00:43:29.390
of time that we've had available,
but I hope that's given you an indication

00:43:29.390 --> 00:43:31.400
of the direction that we're going.

00:43:31.400 --> 00:43:34.440
So to summarize,
the reason that we're doing

00:43:34.440 --> 00:43:37.820
this is numerous actually,
it's to allow Apple to

00:43:37.860 --> 00:43:42.400
innovate in the kernel,
to take the OS X kernel into the future

00:43:42.400 --> 00:43:46.700
where the new hardware and the new
configurations are waiting and the

00:43:46.700 --> 00:43:48.400
new functionality is waiting for us.

00:43:48.400 --> 00:43:51.350
It allows us to improve
the quality of the kernel.

00:43:51.460 --> 00:43:54.030
As was mentioned a couple of times,
there have been bug fixes where

00:43:54.030 --> 00:43:58.400
we've actually found it difficult to
fix without breaking compatibility,

00:43:58.400 --> 00:44:01.590
and somewhere it's
actually been impossible.

00:44:02.010 --> 00:44:05.990
It allows developers to
write keks more easily.

00:44:06.000 --> 00:44:09.760
You now don't have 100,000
interfaces to choose from,

00:44:10.060 --> 00:44:13.040
many of which will be the wrong ones,
which you may not know at the time.

00:44:13.040 --> 00:44:17.080
So now the programming interface
becomes a lot more clear as to

00:44:17.100 --> 00:44:19.880
exactly how you can develop your keks.

00:44:21.010 --> 00:44:23.570
We can provide some
future proofing for you.

00:44:23.630 --> 00:44:27.400
We guarantee the compatibility of an
interface from release to release.

00:44:27.590 --> 00:44:30.390
We actually have a much greater
chance of ensuring that that's

00:44:30.460 --> 00:44:37.460
correct as we move forward,
because assuring the 100,000 interfaces

00:44:37.530 --> 00:44:44.380
that are currently in the kernel,
including all the data usage

00:44:44.380 --> 00:44:44.380
models that there may be,
is almost an impossible job.

00:44:44.830 --> 00:44:48.470
With this, because of the state
transitions of interfaces,

00:44:48.500 --> 00:44:51.670
we can provide a much more predictable
rate of change for developers.

00:44:51.730 --> 00:44:55.700
We can guarantee that interfaces will
exist from one release to another.

00:44:55.700 --> 00:44:58.200
We understand the contract,
and you understand the contract,

00:44:58.200 --> 00:45:01.400
so we can give you a much
more predictable environment.

00:45:02.490 --> 00:45:05.610
We also believe that this will
provide a better user experience

00:45:05.790 --> 00:45:11.390
for when kecks become out of date,
and things do go wrong.

00:45:11.410 --> 00:45:13.710
At the moment,
probably what will happen is

00:45:13.710 --> 00:45:16.440
that the kecks will be loaded,
and then sometime later

00:45:16.440 --> 00:45:18.810
the kernel will crash,
because there's some

00:45:18.810 --> 00:45:24.390
incompatibility of data usage
between the kernel and your kecks.

00:45:24.450 --> 00:45:28.780
So now it becomes much more apparent,
we actually catch it at load time,

00:45:28.800 --> 00:45:32.400
that something has changed,
and this kecks is no longer

00:45:32.400 --> 00:45:36.250
available to be used on this
particular rev of the system.

00:45:36.850 --> 00:45:38.690
The other big thing is
that they start today.

00:45:38.700 --> 00:45:46.500
Well, actually, perhaps not quite today,
because we don't have the interfaces

00:45:46.570 --> 00:45:49.220
actually available on the web yet.

00:45:49.320 --> 00:45:53.850
However, we will be getting them onto
the developer website very soon,

00:45:53.850 --> 00:45:57.880
where you can download the
draft interface specifications.

00:45:57.880 --> 00:46:02.370
You should look at developer.apple.com,
and there will be a new section,

00:46:02.370 --> 00:46:05.210
I believe,
Craig will correct me if I'm wrong,

00:46:05.700 --> 00:46:08.740
the new section there,
which will announce their availability,

00:46:08.830 --> 00:46:10.500
and so keep your eyes on that space.

00:46:12.540 --> 00:46:17.120
What we would like you to do is to review
the interfaces against your KEXTs to

00:46:17.120 --> 00:46:23.400
tell us where we've not gone far enough,
or things that we're missing,

00:46:23.510 --> 00:46:25.390
or actually whether
we've done a good job,

00:46:25.390 --> 00:46:26.540
and that you're quite happy with them.

00:46:26.540 --> 00:46:28.210
That's also very valuable information.

00:46:28.240 --> 00:46:30.670
We'd like you to send us feedback.

00:46:30.680 --> 00:46:35.090
There is an email address that you
can use that will come directly

00:46:35.090 --> 00:46:38.820
through to us in engineering,
and we'll be monitoring

00:46:38.820 --> 00:46:42.100
that very carefully,
so be gentle with us.

00:46:42.400 --> 00:46:52.120
We will be continuing to update both the
header files containing the interfaces,

00:46:52.160 --> 00:46:55.240
and the specifications of the interfaces,
and the implementation behind it,

00:46:55.320 --> 00:46:58.600
so you should track the updates
for this and make sure that they're

00:46:58.600 --> 00:47:00.330
going in the right direction.

00:47:01.730 --> 00:47:03.870
Ultimately, when we actually have
the implementations,

00:47:03.960 --> 00:47:07.140
we would like you to port your
KEX to use these interfaces,

00:47:07.140 --> 00:47:09.700
and then give us your
feedback on your experiences.

00:47:09.900 --> 00:47:12.180
Ultimately,
what we want to do in the release

00:47:12.190 --> 00:47:15.690
after Panther is to actually
have these interfaces in place,

00:47:15.730 --> 00:47:18.690
so we're very concerned
that we get this right.

00:47:18.700 --> 00:47:21.370
We'd like you to work with us,
work with Apple,

00:47:21.370 --> 00:47:23.700
to make this a success for everyone.

00:47:23.700 --> 00:47:26.150
I mean, for a success for us,
so that we end up with a

00:47:26.390 --> 00:47:30.980
kernel that we can develop in,
and make progress in, and support future

00:47:31.020 --> 00:47:34.700
configurations and hardware,
and future functionality,

00:47:34.890 --> 00:47:39.020
and make it a success for you,
that you can implement your KEX in a much

00:47:39.020 --> 00:47:43.700
more reliable and predictable manner,
and a success for our user base,

00:47:43.700 --> 00:47:48.820
where they now actually have much more
sensible things happening when the

00:47:48.880 --> 00:47:51.550
kernel moves on and your KEX hasn't.

00:47:52.380 --> 00:47:55.970
So with that, I'd like to just wrap up.

00:47:56.220 --> 00:47:58.310
Here are some other

00:47:58.500 --> 00:48:08.600
[Transcript missing]

00:48:09.040 --> 00:48:11.000
Oh, you have them on the DVD, sorry.

00:48:11.120 --> 00:48:15.580
So, Session 100,
the I/O Kit Kernel Extension Programming,

00:48:15.580 --> 00:48:18.950
this actually was very interesting
about how you deal with

00:48:19.070 --> 00:48:23.430
multi-threaded environments and
real-time priority environments.

00:48:23.460 --> 00:48:25.830
The open source at Apple,

00:48:26.740 --> 00:48:32.790
The Bluetooth update,
all these have passed, the USB update,

00:48:32.800 --> 00:48:35.590
and the Firewire in depth.

00:48:36.060 --> 00:48:41.260
The Darwin update was yesterday,
and the one today, this afternoon,

00:48:41.370 --> 00:48:44.060
Firewire and USB,
that's a feedback session,

00:48:44.060 --> 00:48:45.650
which I encourage you to attend.

00:48:49.290 --> 00:48:51.860
So Craig Keithley is the person
that you need to talk to if

00:48:51.860 --> 00:48:54.160
you're having trouble with this,
like you can't find the downloads.

00:48:58.300 --> 00:49:13.400
[Transcript missing]

00:49:18.140 --> 00:49:23.180
So we have some URLs that
you can refer to.

00:49:23.630 --> 00:49:30.510
and the documentation you can
refer to inside the OS X kernel.

00:49:30.700 --> 00:49:32.120
Kernel Programming.

00:49:32.170 --> 00:49:36.200
These are all things on
the developer website.

00:49:36.870 --> 00:49:50.920
and the ADC website.

00:49:50.930 --> 00:49:52.250
I/O Kit Fundamentals, Device Drivers,
API Reference,

00:49:52.250 --> 00:49:52.250
Kernel Extensions API Reference,
and these things are areas

00:49:52.250 --> 00:49:52.250
where you could expect to,
that we will add to and

00:49:52.250 --> 00:49:52.250
extend quite considerably as
we go through this process.
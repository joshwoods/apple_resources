WEBVTT

00:00:27.700 --> 00:02:19.600
[Transcript missing]

00:02:24.390 --> 00:02:26.270
So again,
we're talking about OpenGL in Depth,

00:02:26.360 --> 00:02:28.510
and as Travis said,
it's kind of a multi-tiered

00:02:28.510 --> 00:02:29.800
approach to this session.

00:02:30.050 --> 00:02:33.630
What we want to do is we want to take
you from the beginnings of OpenGL for

00:02:33.700 --> 00:02:38.540
those who don't know a lot about OpenGL,
building on that with our

00:02:38.620 --> 00:02:44.200
API frameworks that access OpenGL,
and then moving on to some techniques

00:02:44.200 --> 00:02:48.680
and tips which will allow those
who do know OpenGL fairly well to

00:02:48.680 --> 00:02:48.680
gain something from the session,
things they can use in their app.

00:02:49.770 --> 00:02:53.570
So first I'll start out with
introducing the OpenGL subsystem.

00:02:53.630 --> 00:02:56.260
I'll then show how to use
OpenGL and talk about how to

00:02:56.450 --> 00:02:58.240
get the functionality out of it.

00:02:58.260 --> 00:03:02.720
I'll then show some techniques for
using the 3D API and following up with,

00:03:02.720 --> 00:03:04.290
as I said, the tips.

00:03:04.780 --> 00:03:06.780
So, let's first take a look at
the technology framework.

00:03:06.780 --> 00:03:09.950
And I have this in kind of a strange
way that you may not have seen

00:03:09.950 --> 00:03:11.460
before as far as looking at OpenGL.

00:03:11.460 --> 00:03:15.530
This is an application on the top
that accesses OpenGL in two ways.

00:03:15.580 --> 00:03:19.360
On the right side of the screen is
the actual OpenGL access and where

00:03:19.360 --> 00:03:22.290
it would actually access OpenGL,
call the GL functions.

00:03:22.300 --> 00:03:26.590
On the left side of the screen is the
API that you have to use to get at

00:03:26.590 --> 00:03:30.240
the windowing system or provide the
windowing system interface for OpenGL.

00:03:30.240 --> 00:03:33.920
It looks complicated as far as
the number of different APIs.

00:03:34.060 --> 00:03:36.820
But what this actually is,
it gives you a choice from the

00:03:36.820 --> 00:03:40.880
highest level GLUD API to the
lowest level CGL API depending on

00:03:40.880 --> 00:03:42.280
how your application is written.

00:03:42.280 --> 00:03:45.740
It will depend on what API you use
and it gives you a lot of different

00:03:45.740 --> 00:03:49.140
options for writing an application and
accessing the OpenGL functionality.

00:03:49.140 --> 00:03:52.040
Let's introduce OpenGL to you guys.

00:03:53.810 --> 00:03:54.840
Talk about what is OpenGL.

00:03:54.840 --> 00:03:58.830
And we'll answer the question that
Peter touched on in his introduction

00:03:58.830 --> 00:04:02.500
session to the graphics track is
why do you want to use OpenGL?

00:04:02.500 --> 00:04:05.300
Why does... I have a
mainly 2D application.

00:04:05.340 --> 00:04:08.420
Why would I want to use
OpenGL when it's a 3D API,

00:04:08.420 --> 00:04:09.090
right?

00:04:09.100 --> 00:04:11.180
So that's not something
I normally would want to use.

00:04:11.220 --> 00:04:13.440
We'll talk about the
OpenGL state machine,

00:04:13.440 --> 00:04:15.880
which is key to understanding
the OpenGL operations,

00:04:15.880 --> 00:04:19.620
and finally talk about the API and
a little bit how it's different

00:04:19.620 --> 00:04:22.740
than a lot of other APIs figuring
out what actual functionalities

00:04:22.740 --> 00:04:25.540
available on the platform.

00:04:26.100 --> 00:04:30.620
So OpenGL in simple terms is a
software interface for hardware.

00:04:30.620 --> 00:04:34.940
A lot of cases,
it's design and development,

00:04:35.140 --> 00:04:37.420
parallel hardware design
and hardware development.

00:04:37.420 --> 00:04:40.210
It's platform agnostic,
which is why when we move

00:04:40.210 --> 00:04:43.350
on to the interfaces,
those interfaces are different

00:04:43.350 --> 00:04:45.490
on Mac OS X than you may
have seen on other platforms.

00:04:45.500 --> 00:04:46.560
And it's asynchronous.

00:04:46.560 --> 00:04:51.340
This is something that Peter touched
on in depth in his presentation,

00:04:51.340 --> 00:04:55.680
and it's good to kind of
reemphasize that here.

00:04:55.680 --> 00:04:57.460
Because what happens
with an asynchronous API,

00:04:57.460 --> 00:04:58.880
you're going to actually issue commands.

00:04:58.880 --> 00:05:02.000
The commands at some later
time will be executed by the

00:05:02.000 --> 00:05:03.740
graphics processing unit or GPU.

00:05:03.740 --> 00:05:10.310
Most developers are used to when they
call a command like a GL vertex or even a

00:05:10.390 --> 00:05:15.970
GL flush to say that command is executed
by the time that command returns.

00:05:15.980 --> 00:05:18.960
In the case of OpenGL, in most cases,
that's not true.

00:05:18.960 --> 00:05:22.420
The GPUs are so fast that we
don't see this a lot of times.

00:05:22.420 --> 00:05:23.620
We don't see that there's a lag.

00:05:23.660 --> 00:05:28.400
But if you issue enough commands,
you can actually be waiting on the GPU.

00:05:28.400 --> 00:05:30.120
And you can see this in
some of the profiling tools.

00:05:30.120 --> 00:05:31.740
But in any case,
keep that in mind when you

00:05:31.760 --> 00:05:32.450
develop your application.

00:05:32.480 --> 00:05:36.650
You want to maximize your
asynchronicity in your application.

00:05:36.660 --> 00:05:39.900
Issue the commands,
go on and use the CPU to do other things.

00:05:39.900 --> 00:05:43.060
It uses geometric primitives, points,
lines, polygons.

00:05:43.100 --> 00:05:45.780
So the basic primitive for drawing,
you can draw lines,

00:05:45.780 --> 00:05:47.980
you can draw polygons made
up of multiple points.

00:05:47.980 --> 00:05:50.020
It's fairly simple things
that we all understand.

00:05:50.020 --> 00:05:52.570
It also is a state machine.

00:05:52.580 --> 00:05:55.360
OpenGL has a state you set,
and that state is a state machine.

00:05:55.450 --> 00:05:56.810
It stays set until you change it.

00:05:56.860 --> 00:06:00.100
So if you turn texturing off,
and you draw a polygon,

00:06:00.100 --> 00:06:02.380
texturing is obviously going to be off,
and it will not texture.

00:06:02.380 --> 00:06:06.240
If you continue to draw polygons,
those will also have no texturing on them

00:06:06.240 --> 00:06:08.280
until you actually turn texturing on.

00:06:08.320 --> 00:06:13.100
For example, texturing is off when you
first initialize the interface.

00:06:13.100 --> 00:06:15.590
And so a lot of people initially
get bit by the fact of why

00:06:15.670 --> 00:06:16.840
am I not drawing a texture?

00:06:16.840 --> 00:06:18.950
You're not drawing a texture
because you never turned it on.

00:06:18.980 --> 00:06:21.880
So something to keep in mind, again,
when you're developing for OpenGL,

00:06:21.880 --> 00:06:25.180
is that it is a state machine and
will remain set until you change it.

00:06:25.200 --> 00:06:26.300
you change that state.

00:06:28.340 --> 00:06:32.160
So, the big question is why
should I use OpenGL?

00:06:32.200 --> 00:06:36.670
Peter showed in his talk that the
GPU development is increasing at a

00:06:36.670 --> 00:06:41.390
higher rate than CPU development and
even the simple fact that the GPU is a

00:06:41.390 --> 00:06:45.700
very powerful processor on the system
that you want to utilize to its fullest.

00:06:45.800 --> 00:06:50.590
It's not a good application design in
most cases to process data with a CPU.

00:06:50.850 --> 00:06:53.490
Then wait for the GPU to
finish processing some data

00:06:53.810 --> 00:06:54.620
and then go back to the CPU.

00:06:54.700 --> 00:06:57.280
What you want to do is use
OpenGL to get asynchronous

00:06:57.280 --> 00:07:01.060
processing so they're both working
and utilize the power of that GPU.

00:07:01.060 --> 00:07:01.840
Power like this.

00:07:01.990 --> 00:07:04.160
We've measured in simple tests.

00:07:04.280 --> 00:07:05.850
Oh, by the way,
for all these measurements,

00:07:05.900 --> 00:07:07.260
these are all G4 measurements.

00:07:07.260 --> 00:07:10.680
So as of yesterday,
all these numbers moved up a notch.

00:07:10.710 --> 00:07:13.870
And I think some of the developers we
have here just went down to the lab

00:07:13.970 --> 00:07:17.090
and tested their applications on G5,
were very pleased and saw huge

00:07:17.160 --> 00:07:20.670
increases in performance above what
some of these numbers I mentioned.

00:07:21.700 --> 00:07:26.570
So we've measured in simple apps
650 megabytes per second across

00:07:26.570 --> 00:07:28.500
the texture upload across the bus.

00:07:28.810 --> 00:07:31.130
This is like modifying a
texture that's 4 megabytes.

00:07:31.230 --> 00:07:33.830
It's 1,000 by 1,000 by 32 bits.

00:07:33.930 --> 00:07:36.800
So that's like if you had a movie
that was 1,000 by 1,000 by 32 bits.

00:07:36.850 --> 00:07:41.130
You can modify that at 200 hertz,
200 times a second.

00:07:41.180 --> 00:07:44.650
You can modify that texture,
play a movie at that large size

00:07:44.930 --> 00:07:47.430
across the bus to the GPU every frame.

00:07:48.700 --> 00:07:52.490
So you have the full world ability to
upload something in the neighborhood

00:07:52.490 --> 00:07:54.870
of 140 million triangles per second.

00:07:54.930 --> 00:07:57.190
What that means is,
let's say your single scene

00:07:57.390 --> 00:07:59.610
takes 100,000 triangles.

00:07:59.610 --> 00:08:04.480
You get 1,400 hertz or 1,400 frames
per second in your application.

00:08:04.560 --> 00:08:07.050
Or if you took a game like the
kind of ubiquitous Quake 3,

00:08:07.050 --> 00:08:09.530
which is about 10,000
triangles per frame,

00:08:09.530 --> 00:08:11.910
that's all they were doing
was uploading triangles.

00:08:11.910 --> 00:08:14.270
You could get 14,000 frames per second.

00:08:14.270 --> 00:08:16.090
You can see this is a lot of power.

00:08:39.030 --> 00:08:44.180
OpenGL provides a large,
powerful API that is good

00:08:44.180 --> 00:08:45.900
for 2D and 3D operations.

00:08:45.900 --> 00:08:50.090
It has vertex and pixel program
for complete customization.

00:08:50.090 --> 00:08:53.380
And finally, which is, I think,
a really good draw for OpenGL,

00:08:53.380 --> 00:08:56.580
it is cross-platform and there's
lots of code samples from

00:08:56.580 --> 00:09:00.340
Apple and on the web for you to
pattern your applications after.

00:09:01.950 --> 00:09:03.450
So if you want a quick look
at the OpenGL pipeline,

00:09:03.460 --> 00:09:06.460
we're not going to go over this in depth,
but what you see is the

00:09:06.560 --> 00:09:10.370
application is sending primitives,
like the points, lines, and polygons.

00:09:10.380 --> 00:09:15.310
They're sending image data to the
GPU or to the OpenGL framework.

00:09:15.410 --> 00:09:17.080
It's going to do some
transformer lighting.

00:09:17.080 --> 00:09:19.130
It's going to do
clipping to the viewport.

00:09:19.250 --> 00:09:21.090
It'll then move into
the rasterization step.

00:09:21.150 --> 00:09:23.710
At that point,
you do some multi-texturing.

00:09:23.720 --> 00:09:27.080
You apply the fog, and then you do,
at the end, the per-fragment operations.

00:09:27.080 --> 00:09:30.090
And one key to what's a fragment.

00:09:30.280 --> 00:09:32.440
Some people who are new to
OpenGL don't understand a fragment.

00:09:32.440 --> 00:09:36.610
Think of a fragment as a smart pixel,
as a dot on the screen that may have

00:09:36.610 --> 00:09:39.430
additional information other than color,
may have an alpha value,

00:09:39.440 --> 00:09:40.890
have a depth factor on it.

00:09:40.950 --> 00:09:42.250
Those kind of things are fragments.

00:09:42.260 --> 00:09:45.340
And that's why we get fragment shaders,
vice pixel shaders.

00:09:45.360 --> 00:09:49.470
And last is the frame buffer blending
to blend with the frame buffer.

00:09:49.540 --> 00:09:56.170
In the future presentations about
vertex programs and fragment shaders,

00:09:56.180 --> 00:09:58.560
you'll see how we take parts of
these pipelines and remove it,

00:09:58.850 --> 00:10:00.560
and you can put in a customized
part of the pipeline.

00:10:00.560 --> 00:10:04.280
So again, you can customize the control
of the GPU to your application.

00:10:06.500 --> 00:10:07.710
So we talked about state.

00:10:07.710 --> 00:10:09.160
The OpenGL is a state machine.

00:10:09.240 --> 00:10:10.120
You set the state.

00:10:10.200 --> 00:10:11.620
So it does remain unchanged.

00:10:11.690 --> 00:10:14.380
We talked about it does
remain unchanged until reset.

00:10:14.380 --> 00:10:17.550
And one thing to also remember is
state changes can be expensive.

00:10:17.620 --> 00:10:20.370
That is not to say that you
shouldn't do any state changes.

00:10:20.430 --> 00:10:23.030
And you shouldn't over-optimize
for state changes.

00:10:23.030 --> 00:10:25.990
I mean, you could spend months or
years optimizing so you do as

00:10:25.990 --> 00:10:27.590
few state changes as possible.

00:10:27.590 --> 00:10:30.100
It's probably not a
good use of your time.

00:10:30.100 --> 00:10:33.570
But also, on the other end,
you don't want to do duplicate state

00:10:33.570 --> 00:10:38.440
change and large amount of state
changes per vertex or per primitive.

00:10:38.440 --> 00:10:40.980
I mean, I don't want to draw a polygon,
change a whole bunch of state,

00:10:40.980 --> 00:10:42.490
draw another polygon,
change a whole bunch of state,

00:10:42.490 --> 00:10:44.100
draw another polygon,
change a whole bunch of state.

00:10:44.100 --> 00:10:45.020
That can be really expensive.

00:10:45.020 --> 00:10:47.720
So try and avoid that in
your applications in general.

00:10:47.720 --> 00:10:51.720
Change some state, draw some polygons,
change some state, draw some polygons.

00:10:51.810 --> 00:10:55.100
And that organization will be
much more efficient for OpenGL.

00:10:55.100 --> 00:10:59.180
You can examine state both
yourself and at programmatic level.

00:10:59.910 --> 00:11:03.160
If you want to examine it yourself,
the OpenGL Profiler is a great tool.

00:11:03.210 --> 00:11:06.120
The OpenGL Profiler can
pause your application at

00:11:06.120 --> 00:11:08.040
any point on any OpenGL call.

00:11:08.040 --> 00:11:11.460
You can bring up the entire OpenGL state
and you can look at exactly what it sets.

00:11:11.460 --> 00:11:14.620
So if you're in that texturing case
where you're not getting any texturing,

00:11:14.620 --> 00:11:18.050
you could pause at the point
you're drawing that and look

00:11:18.050 --> 00:11:19.580
at the OpenGL state and say,
"Huh,

00:11:19.580 --> 00:11:22.870
why am I not getting texturing?" "Oh,
look, texturing's turned off.

00:11:22.990 --> 00:11:27.860
2D texturing is disabled." Thus,
you can debug your apps and get

00:11:27.860 --> 00:11:29.620
a lot more information about
what the GPU capabilities are.

00:11:29.730 --> 00:11:34.340
And what they're set at
with the OpenGL Profiler.

00:11:34.340 --> 00:11:36.520
Also, programmatically,
you may want to make

00:11:36.520 --> 00:11:37.810
decisions based on state.

00:11:37.940 --> 00:11:42.220
It's not always a good idea to do
this kind of "if this state's not set,

00:11:42.220 --> 00:11:42.910
set it.

00:11:42.950 --> 00:11:44.320
If this state's not set, set it.

00:11:44.400 --> 00:11:46.650
If this state's not set,
set it." Because that

00:11:46.700 --> 00:11:48.190
can stall the pipeline.

00:11:48.300 --> 00:11:49.060
Think about it this way.

00:11:49.060 --> 00:11:51.340
We talked about this
being an asynchronous API.

00:11:51.390 --> 00:11:52.620
So you have a command.

00:11:52.620 --> 00:11:53.760
You issue the command.

00:11:53.840 --> 00:11:55.380
The command's going to
move down to the pipeline.

00:11:55.380 --> 00:11:59.380
And that command could be
a state setting command.

00:11:59.380 --> 00:12:01.620
What's going to happen is,
if the next command following that,

00:12:01.620 --> 00:12:03.380
you want to get what
the current state is,

00:12:03.460 --> 00:12:05.220
we're going to have to wait
for that command to flush

00:12:05.220 --> 00:12:07.380
all the way through the GPU,
all the way through the pipeline,

00:12:07.380 --> 00:12:10.680
and then retrieve the state to make
sure that we're actually retrieving

00:12:10.680 --> 00:12:13.250
a valid state vector for you.

00:12:13.490 --> 00:12:16.350
So, realize that getting and
setting state can be expensive,

00:12:16.390 --> 00:12:18.380
but do it when necessary.

00:12:18.380 --> 00:12:20.380
Some calls at the bottom.

00:12:20.380 --> 00:12:23.380
You have enable and disable
for enabling and disabling.

00:12:23.380 --> 00:12:25.370
For example, texturing.

00:12:25.400 --> 00:12:29.140
You have a gl_get or gl_is_enabled
for getting some state there.

00:12:29.140 --> 00:12:31.890
want to do a large amount of state,
you can do a push and pop attributes.

00:12:35.470 --> 00:12:37.240
So the OpenGL API.

00:12:37.240 --> 00:12:38.540
It is a procedural command.

00:12:38.540 --> 00:12:41.500
It is a client-server interface
to get this asynchronicity.

00:12:41.500 --> 00:12:44.120
You're going to issue commands and
they're going to be collected and

00:12:44.260 --> 00:12:46.400
sent to the graphic processing unit.

00:12:46.560 --> 00:12:48.480
And the type of commands
are state commands,

00:12:48.570 --> 00:12:51.920
drawing primitives, and manipulating of
buffers in most cases.

00:12:51.920 --> 00:12:56.160
So here's an area I want to spend
a little bit of time concentrating

00:12:56.160 --> 00:12:59.950
on is OpenGL functionality and what
that means to you as a developer.

00:13:00.020 --> 00:13:03.500
One of the big misunderstandings in
OpenGL is exactly what functionality

00:13:03.640 --> 00:13:05.470
do I have when I'm running my program.

00:13:05.470 --> 00:13:08.000
You may have your design
system that's tricked out,

00:13:08.000 --> 00:13:10.230
has the best graphics card,
has everything,

00:13:10.230 --> 00:13:11.840
and your app may run great.

00:13:12.060 --> 00:13:14.940
But how do you make,
how do you detect what functionality

00:13:15.060 --> 00:13:16.730
the end user is going to have?

00:13:16.730 --> 00:13:19.150
And that's where two
types of things come in,

00:13:19.300 --> 00:13:22.190
both extensions and the
core API version number.

00:13:22.200 --> 00:13:28.200
The core API version for OpenGL in
general ranges from OpenGL 1.0 to 1.4.

00:13:28.200 --> 00:13:31.670
On Mac OS X,
we only support 1.1 and above.

00:13:31.830 --> 00:13:35.350
We never supported 1.0 on Mac OS X,
which just means that you never have

00:13:35.350 --> 00:13:39.270
to worry about ever having that case
of 1.0 occurring in your user base.

00:13:39.370 --> 00:13:41.320
So it's always going to be 1.1 to 1.4.

00:13:41.320 --> 00:13:44.370
And usually,
it's not a case of when did a

00:13:44.390 --> 00:13:48.780
driver come out or when did a
card come out or when did we rev a

00:13:48.840 --> 00:13:51.430
driver to get what version it is.

00:13:51.500 --> 00:13:54.260
It's what is that
actual hardware support?

00:13:54.260 --> 00:13:57.900
So for example,
if a hardware does support 3D texturing.

00:13:58.310 --> 00:14:01.700
It can say it's going to be 1.2
or above probably in the hardware.

00:14:01.700 --> 00:14:05.290
If it doesn't support 3D texturing,
you're never going to get to

00:14:05.290 --> 00:14:10.390
report a core OpenGL version
of above 1.1 because the 1.2

00:14:10.400 --> 00:14:13.950
OpenGL spec requires 3D texturing.

00:14:15.250 --> 00:14:19.600
So, but what about a card that may say,
"Hey, I'm 1.1," but really can do some

00:14:19.600 --> 00:14:23.010
more things than the 1.1 spec allows?

00:14:23.300 --> 00:14:25.600
Well,
that's where OpenGL extensions come in.

00:14:25.600 --> 00:14:27.080
We support over 80 OpenGL extensions.

00:14:27.200 --> 00:14:29.230
They range from things
that are Apple-specific,

00:14:29.230 --> 00:14:32.100
like some of the things we
did with vertex array object,

00:14:32.270 --> 00:14:34.690
some of the texture range stuff
that John will talk about,

00:14:34.690 --> 00:14:37.540
and the optimization thing,
some things that we give you to allow

00:14:37.790 --> 00:14:43.100
you to do as optimum a texturing path
or vertex path as possible on Mac OS X,

00:14:43.100 --> 00:14:45.560
or to things that are
like ARB multisample,

00:14:45.560 --> 00:14:49.860
which is for full-screen anti-aliasing,
and is an ARB extension, which is by the

00:14:49.860 --> 00:14:52.360
architecture review board,
and is cross-platform and

00:14:52.640 --> 00:14:55.920
supported on a variety of cards.

00:14:56.230 --> 00:15:05.540
This extends the functionality above
the OpenGL core functionality which

00:15:05.540 --> 00:15:05.540
is specified by the OpenGL renderer.

00:15:05.800 --> 00:15:08.240
So how do we detect this,
which is really what I want to talk

00:15:08.350 --> 00:15:09.380
about as far as an application.

00:15:09.380 --> 00:15:11.940
If I'm in an application,
I don't want to just run and say, well,

00:15:11.940 --> 00:15:15.540
a 3D text stream is not
supported on every card,

00:15:15.540 --> 00:15:17.880
so I'm not going to run in anything
that doesn't support 3D text stream.

00:15:17.880 --> 00:15:18.960
Well, that's not a good example.

00:15:18.960 --> 00:15:22.880
Or, you know, I really wanted this fog
effect in my application,

00:15:22.880 --> 00:15:25.980
but that was a 3D texture,
and since I don't know everything's

00:15:25.980 --> 00:15:29.170
going to support a 3D texture,
I'm not going to even use the fog effect,

00:15:29.170 --> 00:15:30.760
not another non-good solution.

00:15:30.790 --> 00:15:33.180
So what you can do,
there's simple checks you can do when

00:15:33.180 --> 00:15:36.800
you start your application to determine
if that 3D text stream is supported.

00:15:36.800 --> 00:15:39.260
First thing you can do
is use a git string,

00:15:39.420 --> 00:15:40.190
gl version.

00:15:40.200 --> 00:15:41.440
That will give you the core version.

00:15:41.440 --> 00:15:43.750
That's a string in a certain
format that's defined.

00:15:43.760 --> 00:15:46.490
It'll be like 1.4 space,
and then there'll be some

00:15:46.490 --> 00:15:49.360
additional vendor-specific stuff,
but the beginning of that's

00:15:49.390 --> 00:15:50.430
always going to be the same.

00:15:50.440 --> 00:15:54.640
So if you're OpenGL 1.2 or greater,
you know you have 3D text stream.

00:15:54.640 --> 00:15:56.020
No more checking necessary.

00:15:56.020 --> 00:16:00.080
It comes back and says, hey,
I'm OpenGL 1.1 for whatever reason.

00:16:00.080 --> 00:16:04.050
You can then move on and look for
the extension for 3D text stream.

00:16:04.060 --> 00:16:06.080
You can do that by getting
the extension string,

00:16:06.080 --> 00:16:09.940
and then we provide through the GLU,
the GL Utilities API,

00:16:09.940 --> 00:16:14.260
we provide additional API to
check for specific extensions.

00:16:14.260 --> 00:16:16.450
In this example,
I used Apple Fence extension.

00:16:16.460 --> 00:16:19.020
I'm checking here for Apple Fence,
and this will tell me if

00:16:19.020 --> 00:16:21.340
the fence is supported,
so I can then, in my code,

00:16:21.340 --> 00:16:24.810
determine if I want to do a code
path that uses a fence or not.

00:16:24.840 --> 00:16:27.420
This is a really good thing,
a good example of this

00:16:27.470 --> 00:16:28.800
is rectangle texture.

00:16:28.800 --> 00:16:32.740
A rectangle texture is a great
extension to use if you're doing

00:16:32.740 --> 00:16:36.440
a lot of image text stream,
and it's not supported, for example,

00:16:36.450 --> 00:16:38.020
on the Rage 128.

00:16:38.020 --> 00:16:42.120
But it simplifies your code path
a lot if you can use rectangle

00:16:42.120 --> 00:16:43.710
texture on some other GPUs.

00:16:43.790 --> 00:16:46.240
So you wouldn't want to write
everything as if it was a Rage 128.

00:16:46.240 --> 00:16:49.170
You can use this method right here,
check for the texture

00:16:49.220 --> 00:16:51.750
rectangle extension,
and then decide which code path you're

00:16:51.800 --> 00:16:53.270
going to use in your application.

00:16:53.280 --> 00:16:57.180
Finally, one thing you should be
aware of is OpenGL limits.

00:16:57.320 --> 00:16:59.600
OpenGL has limits that
are card dependent.

00:16:59.600 --> 00:17:01.820
If you're on the high-end card,
you may have a texture

00:17:01.980 --> 00:17:03.480
limits of 4,000 pixels.

00:17:03.480 --> 00:17:03.740
If you're on the high-end card,
you may have a texture

00:17:03.740 --> 00:17:04.010
limits of 4,000 pixels.

00:17:04.080 --> 00:17:06.450
If you're on the low-end card,
it could be as low as maybe 1,000 pixels.

00:17:06.820 --> 00:17:09.780
Something to determine if you're
working with large textures,

00:17:09.780 --> 00:17:10.840
you may have to divide them up.

00:17:11.090 --> 00:17:15.220
You can use things like max texture
size right here in the GL get integer,

00:17:15.220 --> 00:17:17.290
and that will get the texture
size for you so you can,

00:17:17.290 --> 00:17:20.550
again,
set your code up to maximize the ability

00:17:20.550 --> 00:17:23.680
of that GPU to perform function for you.

00:17:25.740 --> 00:17:28.420
So I want to point out at the bottom,
I should have pointed

00:17:28.420 --> 00:17:30.350
this out at the beginning,
but this is a good time to do it.

00:17:30.450 --> 00:17:32.380
I have this blue line
at the bottom of it.

00:17:32.520 --> 00:17:36.500
It says sample code, Carbon OpenGL,
Carbon CGL, and Cocoa OpenGL.

00:17:36.500 --> 00:17:38.300
I put that on the bottom
of a lot of slides.

00:17:38.360 --> 00:17:41.220
What that is saying is
that's online sample code,

00:17:41.220 --> 00:17:44.610
online references that talk more
about the subject on the slide.

00:17:44.620 --> 00:17:47.670
So instead of, you know,
taking notes on all these things,

00:17:47.680 --> 00:17:50.900
you can just go to this sample code and
it actually has functions to do this.

00:17:50.980 --> 00:17:55.120
The other thing that's interesting about
this detecting functionality thing,

00:17:55.190 --> 00:17:59.970
it can be a large effort to put
a lot of checks in for a lot

00:17:59.970 --> 00:18:00.820
of different functionalities.

00:18:00.910 --> 00:18:04.240
So what I did was build some sample
code that has a GL check function in it,

00:18:04.240 --> 00:18:05.350
and these three samples have it.

00:18:05.420 --> 00:18:08.340
And this sample code will go through,
and for every display and for

00:18:08.630 --> 00:18:11.270
every render on your system,
it'll go through and build a list

00:18:11.340 --> 00:18:13.600
of all the functionality present,
including limits.

00:18:13.720 --> 00:18:16.150
You can use it all as is,
or you can extend it or reduce

00:18:16.150 --> 00:18:17.640
it as it fits your application.

00:18:17.700 --> 00:18:20.900
So I say look at that sample code,
look at how that's done,

00:18:20.900 --> 00:18:22.880
and either model your application,
directly off of that,

00:18:22.910 --> 00:18:25.190
or use the sample code directly
in your application as is.

00:18:25.350 --> 00:18:27.710
And that'll help you doing the
detecting functionality so you all

00:18:27.710 --> 00:18:30.680
don't have to write the same kind
of functionality detection code

00:18:30.680 --> 00:18:32.190
for every one of your applications.

00:18:34.750 --> 00:18:44.490
So let's show kind of what the
detection of functionality sample

00:18:44.490 --> 00:18:44.490
code gets and show you kind of how

00:18:45.080 --> 00:18:46.660
What I talked about,
functionality for extended

00:18:46.660 --> 00:18:47.960
functionality and core functionality.

00:18:47.960 --> 00:18:50.860
This is just a simple OpenGL demo.

00:18:50.860 --> 00:18:52.400
Let me move this out of the way.

00:18:52.400 --> 00:18:56.620
And one thing I want to show you is
not anything specific on the demo,

00:18:56.620 --> 00:18:58.000
but this information.

00:18:58.000 --> 00:19:01.670
You probably can't even read what it is,
but specifically it talks

00:19:01.770 --> 00:19:03.260
about OpenGL capabilities.

00:19:03.260 --> 00:19:06.780
The beginning is texturized,
but the bottom is a list of every

00:19:06.790 --> 00:19:10.650
extension or every feature supported
by this render on this machine.

00:19:10.660 --> 00:19:11.910
You can see there's a lot of them.

00:19:12.550 --> 00:19:15.630
So sticking to the core
functionality is probably not going

00:19:15.630 --> 00:19:17.560
to give you a very robust app.

00:19:17.660 --> 00:19:20.110
A lot of functionality,
a lot of things you can do

00:19:20.110 --> 00:19:21.440
with OpenGL in extensions.

00:19:21.440 --> 00:19:24.300
You can use the GL check,
which generates this information to

00:19:24.300 --> 00:19:27.380
determine what extensions are there and
code your app to take advantage of this.

00:19:27.380 --> 00:19:28.830
I'm going to go back to slides.

00:19:33.220 --> 00:19:35.460
So let's move on and
talk about interfaces.

00:19:35.520 --> 00:19:37.700
Interfaces are going to be the
meat and potatoes of getting

00:19:37.730 --> 00:19:38.810
your applications started.

00:19:39.090 --> 00:19:43.590
That's something that everyone here who
writes an OpenGL app will have to touch.

00:19:43.700 --> 00:19:46.070
Some of you who are already
working with OpenGL may think,

00:19:46.070 --> 00:19:49.190
"Nah, don't need to know this." But I'm
going to go through all the interfaces

00:19:49.510 --> 00:19:52.230
and you might learn something
about if you're a Carbon developer,

00:19:52.300 --> 00:19:54.440
you may, "Hey,
that Cocoa interface looks pretty

00:19:54.440 --> 00:19:57.890
nice." So if you're a Cocoa developer,
some Carbon interface stuff may work for

00:19:57.990 --> 00:19:59.630
you or a CGL interface may work for you.

00:19:59.630 --> 00:20:02.600
So that's what we're going to talk
about in the interfaces section.

00:20:02.650 --> 00:20:04.720
All the interfaces
share some basic things.

00:20:04.760 --> 00:20:06.900
These are the basic things
that the windowing system

00:20:06.900 --> 00:20:08.460
has to provide to OpenGL.

00:20:08.460 --> 00:20:11.720
Remember I said OpenGL was
a platform agnostic API.

00:20:11.720 --> 00:20:14.920
What that means is there's no
windowing system calls in it.

00:20:15.270 --> 00:20:19.220
There's not any Windows calls or any
Mac OS X calls or there's nothing to say,

00:20:19.220 --> 00:20:21.160
hey, this is a window,
I want to attach to that window.

00:20:21.160 --> 00:20:23.070
These interfaces provide that.

00:20:23.130 --> 00:20:25.810
They provide a pixel format,
which basically describes

00:20:25.810 --> 00:20:27.060
buffering capabilities.

00:20:27.060 --> 00:20:29.100
So it's buffers like,
do I want a depth buffer?

00:20:29.100 --> 00:20:30.960
Do I want an auxiliary buffer?

00:20:31.200 --> 00:20:33.380
Or capabilities like,
do I want full screen

00:20:33.380 --> 00:20:35.260
or do I want stencil,
et cetera.

00:20:35.260 --> 00:20:39.380
The context you can think of,
which these provide, is a state bucket.

00:20:39.380 --> 00:20:42.120
It's a big bucket of state,
and commands are sent and can

00:20:42.120 --> 00:20:43.360
be sent to that current context.

00:20:43.410 --> 00:20:47.100
You can create as many contexts
as you need for your rendering,

00:20:47.100 --> 00:20:49.680
but these will create
your context for you.

00:20:49.860 --> 00:20:51.840
And finally,
the drawable is basically equivalent

00:20:51.840 --> 00:20:54.000
to the window of view or the screen.

00:20:54.000 --> 00:20:58.550
It provides the size for your buffers,
and actually the buffers are instantiated

00:20:58.590 --> 00:21:00.020
when you attach to the drawable.

00:21:02.110 --> 00:21:03.400
Interfaces available.

00:21:03.520 --> 00:21:05.000
There are four interfaces
we're going to talk about.

00:21:05.000 --> 00:21:05.500
CGL.

00:21:05.500 --> 00:21:07.330
CGL is a low-level interface.

00:21:07.450 --> 00:21:09.200
It's the basis for all
the other interfaces.

00:21:09.200 --> 00:21:11.260
It's for full-screen only applications.

00:21:11.260 --> 00:21:13.860
But if you have an application
that's full-screen and windowed,

00:21:13.860 --> 00:21:16.050
you could use a CGL interface
for the full-screen portion

00:21:16.150 --> 00:21:19.220
of it and then use a different
interface for the windowed portion.

00:21:19.580 --> 00:21:21.720
AGL is the Carbon interface to OpenGL.

00:21:21.720 --> 00:21:24.430
So if you're a Carbon developer,
you're going to look at AGL and

00:21:24.430 --> 00:21:26.460
use that to interface with OpenGL.

00:21:26.460 --> 00:21:31.440
NSGL or NSOpenGL is going to be
the Cocoa interface to OpenGL.

00:21:31.440 --> 00:21:34.560
And finally,
GLUT is a very high-level interface

00:21:34.560 --> 00:21:38.660
that provides source-level
cross-platform compatibility.

00:21:38.660 --> 00:21:42.080
And it's used a lot for examples
and in the scientific community.

00:21:42.080 --> 00:21:45.500
It doesn't provide that rich of a UI set,
but for some basic,

00:21:45.500 --> 00:21:48.830
we want to test something out,
it works fairly well.

00:21:50.640 --> 00:21:51.800
So again, we've seen this before.

00:21:51.800 --> 00:21:54.080
You can see that GLUT would be
the highest level interface.

00:21:54.220 --> 00:21:56.340
It's actually built on
top of NSOpenGLView.

00:21:56.760 --> 00:22:01.600
NSOpenGLView is built on top of
NSOpenGLContext and PixelFormat.

00:22:01.660 --> 00:22:04.870
AGL is built on top of CGL,
and everything else kind of sits

00:22:04.990 --> 00:22:06.600
on top of the pancake that way.

00:22:06.600 --> 00:22:09.290
Again, your application is going to pick
one of the interfaces on the left

00:22:09.460 --> 00:22:13.440
side and then access OpenGL from
the right side of the diagram.

00:22:13.940 --> 00:22:18.280
So, CGL, Core OpenGL, again,
it's low-level, it's a basic interface,

00:22:18.280 --> 00:22:21.260
it's a foundation for everything else,
it's full-screen only,

00:22:21.260 --> 00:22:23.230
and let's talk about setting it up.

00:22:23.290 --> 00:22:26.130
All these interfaces have almost
the exact same setup code,

00:22:26.190 --> 00:22:27.950
so if you're not developing
OpenGL right now,

00:22:28.030 --> 00:22:31.280
this is what you're going to have to do
to get your OpenGL window on the screen.

00:22:31.760 --> 00:22:34.920
It's going to get a desired, for the CGL,
for the full-screen,

00:22:34.920 --> 00:22:36.400
you want to pick a desired display mode.

00:22:36.400 --> 00:22:38.860
Do you want 1024 by 768,
do you want something else?

00:22:38.860 --> 00:22:43.320
Capture displays to make sure you do not
modify anything else on the desktop or,

00:22:43.320 --> 00:22:47.120
you know, some other application has,
or icons on the desktop.

00:22:47.120 --> 00:22:49.760
You want to switch the video
mode that you have chosen,

00:22:49.760 --> 00:22:52.190
create a pixel format for
that specific display,

00:22:52.190 --> 00:22:55.500
the key here is a specific display,
so you're going to pick a specific

00:22:55.680 --> 00:22:58.470
one display that you want to
render onto and make a pixel format

00:22:58.500 --> 00:23:01.720
that centers on that display,
and then you're going to set full-screen.

00:23:01.760 --> 00:23:02.850
in the CGL.

00:23:03.020 --> 00:23:06.080
It'll create the context
and then set full screen.

00:23:06.250 --> 00:23:07.360
So let's walk through the code example.

00:23:07.360 --> 00:23:11.200
Again, the CGL sample code here,
CarbonCGL,

00:23:11.200 --> 00:23:13.060
has almost the exact same code in it.

00:23:13.080 --> 00:23:15.170
This is simplified slightly,
but if you really want to

00:23:15.170 --> 00:23:17.320
look at this and study it,
please download the sample.

00:23:17.320 --> 00:23:20.170
It's on the web right now,
and look at that.

00:23:20.180 --> 00:23:22.680
I'll go through the code here,
but I'm not going to go through

00:23:22.680 --> 00:23:24.200
every detail in this session.

00:23:24.200 --> 00:23:26.920
So first we're talking
about the pixel format,

00:23:26.920 --> 00:23:28.810
and this is what you'll see
in a lot of these setup codes.

00:23:28.820 --> 00:23:30.840
You'll see a pixel format,
and you'll have attributes.

00:23:30.940 --> 00:23:33.900
These attributes define things like what
buffers you want and what capabilities.

00:23:33.940 --> 00:23:37.300
And here what's important to note is
you have the fullscreen attribute.

00:23:37.370 --> 00:23:40.180
Supplying the fullscreen
attribute will tell CGL that you

00:23:40.180 --> 00:23:41.380
definitely want a fullscreen.

00:23:41.380 --> 00:23:44.280
CGL could work with offscreens also,
but in this case we're

00:23:44.390 --> 00:23:45.130
talking about fullscreen.

00:23:45.140 --> 00:23:48.690
The other thing of interest is that
first two attributes put together,

00:23:48.920 --> 00:23:50.000
display mask and the zero.

00:23:50.000 --> 00:23:51.600
The zero doesn't mean anything right now.

00:23:51.600 --> 00:23:52.340
It's a placeholder.

00:23:52.340 --> 00:23:55.380
But we put that in,
and that's going to tell CGL what

00:23:55.380 --> 00:23:57.150
screen we want to actually work on.

00:23:57.160 --> 00:24:00.320
We then go down,
and we get the main display, for example.

00:24:00.400 --> 00:24:03.820
We get a display mode for the height
and width and depth that we want.

00:24:03.840 --> 00:24:06.060
We capture all the displays,
and we switch to display mode.

00:24:06.060 --> 00:24:07.030
Those are CG calls.

00:24:07.080 --> 00:24:09.420
Those are things that
are covered in a CG API.

00:24:09.420 --> 00:24:13.670
Then we have one additional call
that may look new that's in the

00:24:13.670 --> 00:24:15.240
CG API you may not have seen before.

00:24:15.240 --> 00:24:20.600
That's CGL, get the CG display ID for
OpenGL display mask.

00:24:20.620 --> 00:24:24.090
And what that means is it's going
to return an OpenGL display mask and

00:24:24.090 --> 00:24:26.300
fill it into that attribute section.

00:24:26.300 --> 00:24:30.460
That's going to tell OpenGL,
the CGL interface,

00:24:30.460 --> 00:24:32.240
what display you want to use.

00:24:32.280 --> 00:24:32.990
So you call that.

00:24:33.020 --> 00:24:35.400
You then set the pixel format
so you have the display mask.

00:24:35.400 --> 00:24:39.570
And there for that specific display,
create the context.

00:24:39.600 --> 00:24:42.110
You can destroy the pixel format
right now because it's not needed.

00:24:42.120 --> 00:24:44.260
You could keep it,
but you can destroy it if you want to.

00:24:44.450 --> 00:24:46.410
Set the current context,
and then you'll set full screen.

00:24:46.440 --> 00:24:49.200
At that point,
you'll have an OpenGL context

00:24:49.200 --> 00:24:50.860
on your full screen,
and you can draw to it.

00:24:51.000 --> 00:24:51.460
Fairly simple.

00:24:51.480 --> 00:24:52.550
.

00:24:53.060 --> 00:24:56.560
AGL is a Carbon interface,
and it's windowed in full screen support.

00:24:56.560 --> 00:25:01.740
If you look at the setup here,
it's really very, very similar to CGL.

00:25:01.740 --> 00:25:05.050
You're going to create a
view of a window or whatever,

00:25:05.110 --> 00:25:06.900
since CGL uses screen,
but then you're going to

00:25:06.900 --> 00:25:07.640
create a pixel format.

00:25:07.640 --> 00:25:12.720
And I'm going to make a note here about
limits on multi-screen pixel formats.

00:25:12.780 --> 00:25:14.680
It's something that's probably
more complicated than we want

00:25:14.710 --> 00:25:15.740
to go into for this session.

00:25:15.740 --> 00:25:17.690
If you have specific questions
about it for your apps,

00:25:17.690 --> 00:25:19.020
we can talk about it afterwards.

00:25:19.020 --> 00:25:21.980
But I also point you to
two tech notes there.

00:25:22.720 --> 00:25:25.200
AGL choose pixel format at the
inside scoop and the correct

00:25:25.200 --> 00:25:26.280
setup of an AGL drawable.

00:25:26.280 --> 00:25:29.240
Both of those have a significant
amount of information about

00:25:29.240 --> 00:25:32.440
choosing pixel formats and how it
contends with multi-screen displays.

00:25:32.440 --> 00:25:36.600
If you choose just a normal pixel format,
you should normally pick every

00:25:36.790 --> 00:25:39.520
renderer it possibly can support,
and you'll be able to drag the

00:25:39.520 --> 00:25:41.100
window between multi-screen displays.

00:25:41.100 --> 00:25:43.840
There are reasons you may not
want to do that in some cases.

00:25:43.860 --> 00:25:45.780
There are reasons that you
probably want it that way.

00:25:45.780 --> 00:25:47.820
So for just a normal app,
you would want to just

00:25:47.820 --> 00:25:51.120
choose an open pixel format,
let it choose to support all the renders,

00:25:51.120 --> 00:25:53.540
and then you get the ability
to drag between displays.

00:25:53.540 --> 00:25:57.140
You then create the context attached
to the drawable as we've seen before.

00:25:57.140 --> 00:26:01.010
So the code example for windowed,
basically the attributes,

00:26:01.100 --> 00:26:02.220
we've seen the attributes before.

00:26:02.220 --> 00:26:04.480
They're AGL attributes
instead of CGL in this case.

00:26:04.480 --> 00:26:07.520
Double buffer depth,
those are similar to what we saw in CGL.

00:26:07.520 --> 00:26:09.480
You then choose a pixel format.

00:26:11.200 --> 00:26:13.450
You then, in this case,
I just do some checking here.

00:26:13.450 --> 00:26:15.750
If I created a pixel format,
I then create a context.

00:26:15.750 --> 00:26:18.020
If I create the context,
I then set the drawable.

00:26:18.020 --> 00:26:20.680
And if you notice,
the get window port to the window,

00:26:20.920 --> 00:26:23.390
what that's going to do is
actually going to use the window

00:26:23.390 --> 00:26:26.780
that I've created and the normal
Carbon routines as the drawable.

00:26:26.780 --> 00:26:28.570
And I'm going to set the current context.

00:26:28.570 --> 00:26:31.200
And then you can draw
into it with OpenGL.

00:26:31.200 --> 00:26:34.290
One thing the bottom of that shows
is something people ask about,

00:26:34.290 --> 00:26:35.380
about VBL syncing.

00:26:35.520 --> 00:26:39.140
Normally, in Mac OS X,
we do not sync a display or sync

00:26:39.140 --> 00:26:43.500
the OpenGL drawing to the VBL or
limit the OpenGL drawing to the VBL.

00:26:43.500 --> 00:26:47.220
So what you can do with this is
use the set integer call that's

00:26:47.220 --> 00:26:50.140
in almost all of the APIs,
and that will allow you

00:26:50.140 --> 00:26:51.580
to sync to the VBL here.

00:26:51.580 --> 00:26:54.100
In this case, you call AGL set integer
with the context,

00:26:54.100 --> 00:26:56.790
and you want to use the swap
interval and set that to one.

00:26:56.800 --> 00:26:59.240
And that means, hey,
we're going to limit to the VBL sync.

00:27:01.430 --> 00:27:03.560
So now let's move on to AGL fullscreen.

00:27:03.560 --> 00:27:05.780
In the AGL API,
you can also do fullscreen

00:27:05.780 --> 00:27:07.600
inside of that API itself.

00:27:07.600 --> 00:27:10.560
This looks pretty much the same,
but let's just highlight the

00:27:10.560 --> 00:27:11.580
things that are different.

00:27:11.580 --> 00:27:14.660
There's only about three or four lines
that are actually different here.

00:27:14.660 --> 00:27:18.300
First, we've added the fullscreen
attribute to the pixel format.

00:27:18.300 --> 00:27:20.180
So that's saying, hey,
I want a fullscreen,

00:27:20.180 --> 00:27:22.700
not a windowed pixel format.

00:27:22.700 --> 00:27:26.400
Then we're gonna get a main device,
so we need a device to do fullscreen.

00:27:26.400 --> 00:27:27.980
You need to tell it where
to do the fullscreen.

00:27:27.980 --> 00:27:31.470
And AGL's a little bit different
than CGL in the fact that you add,

00:27:31.500 --> 00:27:34.810
you put the display into the create pixel
format instead of in the attributes.

00:27:34.840 --> 00:27:39.100
So you put the display you just got,
one display to draw to,

00:27:39.100 --> 00:27:40.820
and the attributes to
create a pixel format.

00:27:40.820 --> 00:27:43.730
And then instead of setting the drawable,
you do a set fullscreen.

00:27:43.890 --> 00:27:44.460
Fairly simple.

00:27:44.460 --> 00:27:46.780
So this is really,
really simple stuff as far

00:27:46.780 --> 00:27:48.000
as how you set up OpenGL.

00:27:48.000 --> 00:27:50.620
You can get running with
OpenGL depending on what API you

00:27:50.770 --> 00:27:52.120
pick in a matter of minutes.

00:27:54.000 --> 00:27:57.880
Let's talk about NSGL and NSOpenGL.

00:27:57.880 --> 00:28:00.530
This is the Cocoa interface,
very similar to the other interfaces

00:28:00.560 --> 00:28:01.550
we've already talked about.

00:28:01.560 --> 00:28:06.520
Two ways to use Cocoa and NSOpenGL.

00:28:06.520 --> 00:28:09.620
First is the NSOpenGL view subclass.

00:28:09.620 --> 00:28:13.250
We already have provided an
NSOpenGL view in the Cocoa interface.

00:28:13.260 --> 00:28:17.160
What that allows you to do is basically
encapsulate a context and a pixel

00:28:17.280 --> 00:28:21.630
format already in it and give you some
basic utility functions handling some

00:28:22.050 --> 00:28:26.890
of the bookkeeping functions for you,
and so you have to do very little work.

00:28:27.000 --> 00:28:28.110
There are some limitations to it.

00:28:28.230 --> 00:28:32.080
For example, if you wanted to have two
contexts that work with one view,

00:28:32.080 --> 00:28:36.000
it's possible to do in Cocoa,
but the NSOpenGL view subclass

00:28:36.000 --> 00:28:37.480
would not allow you to do it.

00:28:37.660 --> 00:28:40.900
In that case, you would have to roll
your own NSOpenGL view.

00:28:40.900 --> 00:28:45.090
So let me go back to the
NSOpenGL view subclass.

00:28:45.160 --> 00:28:48.740
The last point on that
is that it's basically,

00:28:48.740 --> 00:28:51.360
you can build it via interface builder,
which I'll show you in a minute,

00:28:51.560 --> 00:28:54.070
and it's fairly simple to
hook this into an application.

00:28:54.090 --> 00:28:57.140
But let's say you have an application,
you want to special case it.

00:28:57.400 --> 00:28:59.810
For example,
you want a context that does,

00:28:59.900 --> 00:29:02.260
let me think, multi-samples.

00:29:02.340 --> 00:29:05.590
You want an anti-alias context
and a non-anti-alias context,

00:29:05.640 --> 00:29:08.290
and you want them in the same view,
and you want the kind of switch

00:29:08.290 --> 00:29:09.920
between the two without any flash.

00:29:09.960 --> 00:29:11.320
You don't want to
actually replace the view.

00:29:11.320 --> 00:29:14.120
All you're going to do is not render one,
and the next frame you're

00:29:14.120 --> 00:29:15.080
going to render the other.

00:29:15.080 --> 00:29:18.040
You can do this fairly easily by
just replacing the context in a view.

00:29:18.040 --> 00:29:19.680
You're not going to tear the view down.

00:29:19.680 --> 00:29:21.520
You're not going to, you know,
have this big white,

00:29:21.670 --> 00:29:24.420
black flash or black flash
of nothing being drawn.

00:29:24.420 --> 00:29:26.130
You're actually going to
have to replace the context.

00:29:26.140 --> 00:29:28.240
But this would not work
with NSOpenGL view.

00:29:28.240 --> 00:29:32.670
You'd have to roll your own NSOpenGL,
custom NSOpenGL view based

00:29:32.670 --> 00:29:36.310
on the NSView subclass
using the NSOpenGL context

00:29:36.410 --> 00:29:37.720
and NSOpenGL pixel format.

00:29:37.720 --> 00:29:40.460
This might seem daunting to some people.

00:29:40.460 --> 00:29:42.080
Make sure they cover all the cases.

00:29:42.080 --> 00:29:44.790
To simplify this,
we provided some sample code.

00:29:44.840 --> 00:29:47.490
The custom Cocoa OpenGL sample code,
which went up this week,

00:29:47.500 --> 00:29:48.700
is on the web now.

00:29:48.700 --> 00:29:51.110
For folks who want to roll their own,
it shows you basically an

00:29:51.110 --> 00:29:52.740
attempt to create a template
that you can use directly,

00:29:52.740 --> 00:29:54.300
and you can modify it as needed.

00:29:54.300 --> 00:29:55.900
And that should be a great
starting point for that.

00:29:55.900 --> 00:29:59.270
I'm not going to go into detail here,
but that sample code I wanted to point

00:29:59.270 --> 00:30:01.760
out is available and for your use today.

00:30:05.190 --> 00:30:07.220
So let's talk about
NSOpenGLView and using that.

00:30:07.240 --> 00:30:08.660
You create it for your interface builder.

00:30:08.660 --> 00:30:10.260
You create your window.

00:30:10.260 --> 00:30:12.390
You create your view,
and maybe you use a custom

00:30:12.390 --> 00:30:15.440
view or an OpenGL view,
and you drag it into your window,

00:30:15.440 --> 00:30:18.780
allowing that to have the class.

00:30:18.780 --> 00:30:22.570
You create a subclass of NSOpenGLView,
having that class manage the

00:30:22.570 --> 00:30:24.400
view creating interface builder.

00:30:24.400 --> 00:30:26.220
Then in code,
what you're going to do is you're

00:30:26.220 --> 00:30:29.210
going to have to override a few
of the methods of NSOpenGLView.

00:30:29.300 --> 00:30:32.480
First one is a knit with
frame or a knit with coder.

00:30:32.480 --> 00:30:34.900
Depending on whether you use
a custom view or OpenGL view,

00:30:34.900 --> 00:30:36.710
you can override one of those.

00:30:36.770 --> 00:30:39.870
And you can do things like set your pixel
format up there if you didn't want to

00:30:39.870 --> 00:30:41.490
set it up in interface builder itself.

00:30:42.900 --> 00:32:07.100
[Transcript missing]

00:32:08.430 --> 00:32:08.770
Update.

00:32:08.770 --> 00:32:11.800
Update routine is called
in about four cases,

00:32:11.800 --> 00:32:15.770
and there's a Q&A that just went
up about updating OpenGL context.

00:32:15.870 --> 00:32:18.140
I suggest you all,
when you're looking into update,

00:32:18.140 --> 00:32:20.170
look at that Q&A,
and it describes all the cases

00:32:20.270 --> 00:32:21.820
that update needs to be called.

00:32:21.820 --> 00:32:24.820
In the cases it needs to be called
are things like display configuration

00:32:24.820 --> 00:32:27.710
change or if a window could be
dragged and change renderer.

00:32:27.950 --> 00:32:32.270
The idea behind update is update takes
care of renderer changes for you.

00:32:32.380 --> 00:32:35.040
So if you have two displays and
someone's going to drag your window

00:32:35.040 --> 00:32:38.000
from one display to the other,
at some point it's likely that

00:32:38.000 --> 00:32:41.450
your renderer will change into a
second renderer or whatever your

00:32:41.450 --> 00:32:43.410
other card may be in your system.

00:32:43.420 --> 00:32:46.540
Update needs to be called in
these cases to make it happen.

00:32:46.540 --> 00:32:50.540
Normally with NSOpenGL view you
probably just want to ignore update.

00:32:51.120 --> 00:32:53.820
Unless you need to
track renderer changes.

00:32:53.820 --> 00:32:56.140
You just need to make
sure it works right.

00:32:56.300 --> 00:32:58.100
It'll happen behind your back.

00:32:58.230 --> 00:33:01.400
Update will be called, taken care of,
and you won't need to do anything.

00:33:01.400 --> 00:33:04.700
If, for example,
in some of the examples that I have,

00:33:04.790 --> 00:33:06.350
I want to show what renderer I'm on.

00:33:06.360 --> 00:33:07.670
I want to update some text.

00:33:07.680 --> 00:33:11.380
I actually would subclass or
override the update method.

00:33:11.380 --> 00:33:14.140
But you've got to make sure you
call the super update first.

00:33:15.920 --> 00:33:16.800
Lastly, DrawRack.

00:33:16.800 --> 00:33:17.960
DrawRack is where you're
going to do your work.

00:33:17.960 --> 00:33:20.800
I'm going to handle my resize there and
I'm going to do a lot of draws there.

00:33:20.800 --> 00:33:23.040
I'm going to draw the
content in DrawRack.

00:33:23.300 --> 00:33:25.460
Finally, animation timers.

00:33:25.460 --> 00:33:27.800
So if you want to do animation,
you can use an NSTimer.

00:33:27.910 --> 00:33:32.010
And the only note I would have other than
normal NSTimer use is you want to use

00:33:32.340 --> 00:33:38.240
both tracking run loop mode and normal
run loop and default run loop mode,

00:33:38.240 --> 00:33:40.530
event tracking run loop mode,
which allows you to get the

00:33:40.920 --> 00:33:44.910
updates during the resize.

00:33:45.140 --> 00:33:50.660
So I'm going to take a
departure here from the

00:33:52.660 --> 00:33:56.220
What normally folks would do with a demo,
and I'm actually going

00:33:56.220 --> 00:33:57.600
to create some code.

00:33:57.600 --> 00:34:03.240
So what we're going to do,
we're going to go to Xcode and we're

00:34:03.240 --> 00:34:09.450
just going to start and we're going
to create a new project and we're

00:34:09.450 --> 00:34:13.590
going to make it a Cocoa application
and show you how easily it is

00:34:13.590 --> 00:34:13.590
to create an OpenGL demo live,
on stage, even when you can't type well.

00:34:13.760 --> 00:34:15.980
So first thing I'm going to do is
I'm going to look at the nib file.

00:34:16.000 --> 00:34:19.060
And the standard nib file you get
has just this one window in it.

00:34:19.080 --> 00:34:22.140
What I'm going to do is I'm
going to take a custom view,

00:34:22.160 --> 00:34:24.900
I'm going to drag it into the window,
and I'm going to resize this

00:34:24.900 --> 00:34:27.130
the entire size of the window.

00:34:28.180 --> 00:34:30.090
Then I want a class to
control that custom view,

00:34:30.150 --> 00:34:31.640
so what I'm going to do is move in.

00:34:31.640 --> 00:34:35.100
We mentioned that NSOpenGLView is
a subclass of NSView.

00:34:35.100 --> 00:34:37.560
It's NSOpenGLView,
and I'm actually going to

00:34:37.620 --> 00:34:40.140
subclass that with my own class,
MyOpenGLView,

00:34:40.140 --> 00:34:42.100
and that's fine for the name there.

00:34:42.240 --> 00:34:45.090
Going back to the custom view,
get some information on it.

00:34:45.100 --> 00:34:47.710
First thing I want to do is make
sure when the window resizes that

00:34:47.710 --> 00:34:49.080
it actually adjusts its size.

00:34:49.190 --> 00:34:51.100
I'll do it that way.

00:34:51.220 --> 00:34:54.530
And then finally,
I want to make that a custom class

00:34:54.530 --> 00:34:57.100
using MyOpenGLView like that.

00:34:57.100 --> 00:35:01.030
Let's use Interface Builder's ability
to create some files for that.

00:35:01.030 --> 00:35:03.100
It's going to automatically
create those two files,

00:35:03.100 --> 00:35:08.050
put it into the demo right there,
and then we're going to save this,

00:35:08.050 --> 00:35:09.060
and we're going to
quit Interface Builder.

00:35:09.150 --> 00:35:11.840
If you notice now,
we have two additional files

00:35:12.260 --> 00:35:14.100
that were created in our
project by Interface Builder.

00:35:14.100 --> 00:35:16.570
We're going to add some
code to these files.

00:35:18.630 --> 00:35:21.970
So because of my poor typing,
I don't want to type all these codes

00:35:22.060 --> 00:35:25.170
because I'm sure I would make mistakes,
but I'm going to add some

00:35:25.170 --> 00:35:28.500
simple things like headers,
some variables, and that kind of thing.

00:35:28.510 --> 00:35:37.100
So first thing we're going to add is
we're going to add the OpenGL headers,

00:35:37.170 --> 00:35:39.490
the OpenGL framework, GLEXT, and GLU.

00:35:39.490 --> 00:35:39.490
I'm going to add some
member variables over here.

00:35:40.100 --> 00:35:43.000
And what that's going to do is that's
going to add an initialization variable,

00:35:43.000 --> 00:35:46.000
it's going to have a timer,
a flag on animation,

00:35:46.130 --> 00:35:50.180
a time for the timer,
and then some rotation values.

00:35:50.180 --> 00:35:51.820
Nothing, no OpenGL values here.

00:35:51.820 --> 00:35:54.090
I mean,
this is just things you can do for

00:35:54.100 --> 00:35:58.710
doing some simple animation to make
the demo a little bit more interesting.

00:36:00.020 --> 00:36:03.110
And here I'm going to add the
functions I'm going to override.

00:36:03.110 --> 00:36:05.780
I'm going to have a pixel format,
update a projection,

00:36:05.860 --> 00:36:07.130
update my model view matrix.

00:36:07.240 --> 00:36:09.290
I'm going to do some
animation right here,

00:36:09.290 --> 00:36:10.560
do my drawing routine.

00:36:10.840 --> 00:36:12.750
This is the
Prepare OpenGL I talked about.

00:36:12.750 --> 00:36:15.090
We have our knit with frame,
we have a wake with nib

00:36:15.090 --> 00:36:16.280
to set up some variables.

00:36:16.400 --> 00:36:17.780
So that's all I need in there.

00:36:20.690 --> 00:36:25.440
In the OpenGL view class,
the first thing we're going to add

00:36:25.440 --> 00:36:28.400
is the rotation and drawing code.

00:36:29.690 --> 00:36:32.600
This code does some things to
actually calculate some rotations

00:36:32.620 --> 00:36:35.400
to spin some things around
to make it look interesting.

00:36:35.400 --> 00:36:39.730
And then at the end,
this is the drawing code right here.

00:36:39.840 --> 00:36:41.190
This is the color.

00:36:41.310 --> 00:36:42.590
This is the vertex.

00:36:42.740 --> 00:36:43.980
So you draw some quads.

00:36:43.980 --> 00:36:48.150
So this is the actual
OpenGL drawing code.

00:36:48.150 --> 00:36:52.440
And then I draw a line around it,
around the cube with this.

00:36:52.440 --> 00:36:53.480
So this is going to draw the cube.

00:36:53.480 --> 00:36:56.220
This data up here is the
actual vertices for the cube.

00:36:56.350 --> 00:36:59.600
Notice they're all ones and zeros,
but it's just a unit cube.

00:37:03.130 --> 00:37:05.000
We talked about pixel formats.

00:37:05.160 --> 00:37:07.440
This code right here actually
defines a pixel format.

00:37:07.440 --> 00:37:09.500
This looks very similar
to the example I showed.

00:37:09.500 --> 00:37:10.930
It's going to be a windowed pixel format.

00:37:11.080 --> 00:37:13.260
It's double buffered,
and I'm going to add a depth buffer here.

00:37:13.260 --> 00:37:16.560
So it's real similar to what we
talked about in the CGL and the AGL.

00:37:19.610 --> 00:37:23.670
These two functions I added here:
update projection,

00:37:23.970 --> 00:37:28.850
updates my projection so I actually
get a projected spinning cube,

00:37:28.850 --> 00:37:36.580
and this actually updates the world,
especially the rotate call here from GL,

00:37:36.580 --> 00:37:36.580
to actually rotate the cube.

00:37:38.240 --> 00:37:41.100
Now I'm going to add the animation timer.

00:37:41.170 --> 00:37:42.400
So this is what we talked about before.

00:37:42.400 --> 00:37:44.100
This is the timer.

00:37:44.140 --> 00:37:47.400
It's going to get some time,
do a difference here.

00:37:47.400 --> 00:37:49.330
If I'm animating,
I'm going to spin the object,

00:37:49.420 --> 00:37:51.340
then I'm going to call
that drawRefRoutine.

00:37:51.390 --> 00:37:58.130
This is the actual spin the object,
does some math to make it look a nice,

00:37:58.130 --> 00:37:58.130
pretty spinning object.

00:37:58.130 --> 00:37:58.130
And finally,

00:37:58.520 --> 00:38:01.900
This is the four functions that
you actually need to override.

00:38:01.900 --> 00:38:03.390
A draw-rec routine.

00:38:03.390 --> 00:38:05.740
What's this going to do is going
to handle the resize right here,

00:38:05.740 --> 00:38:07.900
which is what I talked
about handling in draw-rec.

00:38:07.900 --> 00:38:10.790
It's going to do the init at the
very beginning if it's not been done.

00:38:10.790 --> 00:38:12.400
It's going to do a clear.

00:38:12.580 --> 00:38:18.300
It's going to draw the cube,
and then it's going to do

00:38:18.300 --> 00:38:18.300
the flush or the flush buffer
depending on what situation I'm in.

00:38:18.960 --> 00:38:22.860
Prepare OpenGL,
some OpenGL setup code right here.

00:38:22.890 --> 00:38:25.030
And again,
this is the Cocoa version of that

00:38:25.040 --> 00:38:29.900
swap interval for BBL syncing,
very similar to the AGL version.

00:38:29.910 --> 00:38:31.230
Anit with frame is very simple.

00:38:31.360 --> 00:38:32.900
All I'm going to do is
create a pixel format,

00:38:32.900 --> 00:38:33.900
what we talked about.

00:38:33.900 --> 00:38:37.060
And finally, the Awake with Nib,
I'm going to use this to set up

00:38:37.060 --> 00:38:39.880
some values and set up a timer.

00:38:39.910 --> 00:38:43.260
So if I didn't do anything wrong,
we should be able to

00:38:43.520 --> 00:38:44.880
build this and run it.

00:38:51.420 --> 00:38:55.810
And so this is an OpenGL spinning
square that resizes,

00:38:55.820 --> 00:39:00.290
handles updates correctly, handles the

00:39:00.510 --> 00:39:04.390
The full-screen zoom very easily.

00:39:04.390 --> 00:39:06.240
And so that's all it
takes to do an OpenGL app.

00:39:06.560 --> 00:39:09.400
And I put a square in here,
but you can do any content you want.

00:39:09.400 --> 00:39:11.770
The point is it's real easy
to get to the point where you

00:39:11.800 --> 00:39:13.240
actually can draw your content.

00:39:13.420 --> 00:39:16.560
And all this code that I used
here is based on the sample

00:39:16.560 --> 00:39:18.260
code that's on the website.

00:39:18.330 --> 00:39:21.850
There's a Cocoa OpenGL sample
that's really simple to use,

00:39:21.850 --> 00:39:25.640
and you can just take that,
rip the guts out for the drawing code,

00:39:25.640 --> 00:39:26.700
and put whatever drawing
code you want in.

00:39:26.700 --> 00:39:26.700
We can go back to slides now.

00:39:29.060 --> 00:39:30.970
Last thing I'm going to talk about GLUT.

00:39:31.030 --> 00:39:33.020
GLUT, as I said,
is a source-level compatible

00:39:33.020 --> 00:39:34.390
cross-platform API.

00:39:34.390 --> 00:39:36.880
It's a limited API,
but it's fairly simple to use.

00:39:36.880 --> 00:39:39.060
So it works really well
for doing examples.

00:39:39.060 --> 00:39:42.180
Another idea is if you wanted to
do an example or test some things,

00:39:42.190 --> 00:39:45.000
you could use GLUT, set it up quickly,
and do it that way.

00:39:45.040 --> 00:39:46.840
And it works across many platforms.

00:39:46.850 --> 00:39:48.040
It's callback-based.

00:39:48.040 --> 00:39:49.450
The setup is fairly simple.

00:39:49.600 --> 00:39:51.810
You initialize GLUT,
you create your windows,

00:39:51.810 --> 00:39:54.280
you set your callbacks for
the things you want to do,

00:39:54.350 --> 00:39:55.740
and you call GLUT main loop.

00:39:55.840 --> 00:39:58.940
Don't expect GLUT main
loop to return something.

00:39:59.000 --> 00:40:00.380
So don't put any code past it.

00:40:00.380 --> 00:40:04.190
It'll probably exit without returning
through a different code path.

00:40:04.690 --> 00:40:06.840
Here's an example of what
your main in Glut works like.

00:40:06.950 --> 00:40:09.310
We're not going to talk
about the specific callbacks.

00:40:09.320 --> 00:40:11.070
I just wanted to show
you an example of it.

00:40:11.140 --> 00:40:13.560
What you have is you
have the init function.

00:40:13.560 --> 00:40:14.620
You have the window.

00:40:14.620 --> 00:40:17.200
You set the display mode
similar to pixel format.

00:40:17.200 --> 00:40:18.380
You create a window.

00:40:18.380 --> 00:40:21.760
You actually can then initialize
some OpenGL state if you need to,

00:40:21.760 --> 00:40:23.100
and then you set your callbacks.

00:40:23.330 --> 00:40:26.060
Realize that a couple of
the callbacks are app-based,

00:40:26.060 --> 00:40:27.540
vice window-based.

00:40:27.560 --> 00:40:29.450
For example, the idle function,
you get one of them.

00:40:29.460 --> 00:40:32.150
So if you set an idle callback,
you have one idle callback for

00:40:32.150 --> 00:40:35.800
your entire application where,
for example, the reshape function is

00:40:35.840 --> 00:40:38.180
on a per-window basis,
whatever the current window is.

00:40:38.290 --> 00:40:41.940
So that's what some Glut code looks like,
and there's a lot of Glut examples

00:40:41.940 --> 00:40:43.550
also on the web and on our site.

00:40:45.290 --> 00:40:47.780
So let's talk about some
OpenGL techniques here.

00:40:47.810 --> 00:40:57.480
These techniques are things you can use
in your current applications to either

00:40:57.480 --> 00:40:57.480
improve them or some things to make
more content that's more interesting

00:40:57.480 --> 00:40:57.480
than just having your spinning square.

00:40:57.810 --> 00:41:04.260
First technique is some texturing,
then we'll move on to some fonts,

00:41:04.260 --> 00:41:04.260
talk about handling images,
and then movies.

00:41:04.520 --> 00:41:07.650
In this section in general,
you'll see that I'm going to talk about

00:41:07.800 --> 00:41:12.100
the technique and not specifically show
you every nuance of the code behind it.

00:41:12.100 --> 00:41:14.740
Again, there are samples for
all this on the web.

00:41:14.980 --> 00:41:19.770
I want to talk about giving you an
overview and a context to work from so

00:41:20.180 --> 00:41:25.730
you can look at the sample and understand
what it's doing and rather have you work

00:41:25.730 --> 00:41:28.970
through the code at your own pace and ask
questions on the mailing list or whatever

00:41:28.970 --> 00:41:28.970
if you need to after the session.

00:41:29.280 --> 00:41:30.770
So first, texturing,
we can do texturing in

00:41:30.770 --> 00:41:31.870
two different directions.

00:41:31.870 --> 00:41:34.840
One will be using Cocoa and
one is Carbon using QuickTime.

00:41:35.010 --> 00:41:37.600
First, for Cocoa,
we're going to texture from a

00:41:37.600 --> 00:41:41.690
packed 8888 or 1555 ARGB buffer.

00:41:41.800 --> 00:41:44.590
What that means is it's going to be
alpha red-green bool pixel format.

00:41:44.950 --> 00:41:52.110
It's going to be 8 bits per pixel or 1
bit alpha and then 5 bits per component.

00:41:52.490 --> 00:41:53.650
You can allocate a texture.

00:41:53.710 --> 00:41:55.990
For example, if you wanted to do that,
you allocate a texture-sized

00:41:56.000 --> 00:41:58.920
buffer using new pointer or malloc,
whatever your routine of choice is.

00:41:58.940 --> 00:42:01.020
That's going to be the exact size
of your texture you're reading in.

00:42:01.020 --> 00:42:05.520
You can create a G world from the buffer
with a Qt new G world from pointer.

00:42:05.520 --> 00:42:07.960
There's also the function
is new G world from pointer.

00:42:07.960 --> 00:42:09.360
Use whichever one you'd prefer.

00:42:09.360 --> 00:42:11.080
They're actually the exact same routine.

00:42:11.080 --> 00:42:15.790
What this does is create a buffer
that you can actually draw into using

00:42:15.930 --> 00:42:19.450
quick time and quick draw that does
not have padding on the end of it

00:42:19.560 --> 00:42:20.720
so you can texture from it easily.

00:42:21.140 --> 00:42:23.210
You can draw into the G world
with whatever content you want,

00:42:23.260 --> 00:42:24.940
whether it's an image,
whether it's a movie,

00:42:24.940 --> 00:42:28.680
whether it's just lines and circles
or text or whatever you want to draw,

00:42:28.780 --> 00:42:29.350
you draw into it.

00:42:29.430 --> 00:42:32.270
You can dispose the G world if you
want unless you want to draw some more

00:42:32.440 --> 00:42:33.560
because you don't need to keep it around.

00:42:33.560 --> 00:42:35.620
All you need is the buffer
you created initially.

00:42:35.620 --> 00:42:37.460
You don't need that
G world to texture from.

00:42:37.460 --> 00:42:39.140
And then you're going to
texture from the buffer.

00:42:39.140 --> 00:42:43.190
You'll use standard OpenGL texturing
techniques and understand that

00:42:43.190 --> 00:42:46.020
Apple Pack Pixels will be used here.

00:42:46.020 --> 00:42:48.870
It's an extension that's on every
single Mac OS X implementation so

00:42:48.870 --> 00:42:50.260
you can count on it being there.

00:42:50.720 --> 00:42:54.710
And the texture formats are
either unsigned in 8888 reversed

00:42:54.780 --> 00:42:56.840
or unsigned short 155 reversed.

00:42:56.940 --> 00:42:59.740
And what that does is it tells
what the pixel format you have

00:42:59.740 --> 00:43:04.620
natively in that quick draw
format is to use for texturing.

00:43:04.660 --> 00:43:09.590
So some code, fairly complicated,
or fairly busy looking,

00:43:09.590 --> 00:43:11.260
not actually complicated.

00:43:11.260 --> 00:43:14.890
But I'll go through it and we'll talk
about it and then we'll show a demo

00:43:14.890 --> 00:43:16.990
in a little while using this code.

00:43:17.180 --> 00:43:20.000
The Git graphics importer
profile in this case is going to,

00:43:20.380 --> 00:43:22.920
you have a file descriptor and you're
going to actually try and load a file in.

00:43:22.920 --> 00:43:26.370
You can get the natural bounds for that,
which gets the size of it.

00:43:26.650 --> 00:43:30.910
You then can allocate a handle the
size of the image descriptor here to

00:43:30.910 --> 00:43:34.070
get the additional information on the
depth of the thing where I get the

00:43:34.200 --> 00:43:35.700
depth part of the image descriptor.

00:43:35.700 --> 00:43:39.700
I then get the height and width
out of the image information.

00:43:39.700 --> 00:43:43.480
I then calculate a stride to
use for convenience later and

00:43:43.610 --> 00:43:45.040
then allocate a new buffer.

00:43:45.040 --> 00:43:46.760
That new buffer is
going to be my texture.

00:43:46.840 --> 00:43:48.290
I'm going to use that
actually for texturing.

00:43:48.300 --> 00:43:50.120
Qt new G wolf and pointer.

00:43:50.340 --> 00:43:52.680
As we talked about,
that's actually going to create

00:43:52.710 --> 00:43:56.130
a G world from that buffer that
you can then use to draw into with

00:43:56.130 --> 00:44:00.140
Quick Draw or Quick Time and then
you can texture out of using OpenGL.

00:44:01.740 --> 00:44:05.090
Graphics importer, set GWorld,
graphics import, set quality,

00:44:05.090 --> 00:44:08.000
we're going to do lossless quality,
and then we're going to get the Pixmap,

00:44:08.000 --> 00:44:09.660
lock the pixels,
and we're going to drawline it

00:44:09.660 --> 00:44:10.810
using the graphics importer.

00:44:10.910 --> 00:44:14.520
So this basically took the contents of
that file and drew it into that GWorld,

00:44:14.770 --> 00:44:16.940
which in turn was drawing
it into your buffer.

00:44:16.940 --> 00:44:20.570
You can unlock the pixels,
close the component for the importer,

00:44:20.570 --> 00:44:23.670
and actually you can just
dispose the GWorld at this point,

00:44:23.670 --> 00:44:24.840
because you don't need it.

00:44:24.880 --> 00:44:26.620
All you need is that buffer you created.

00:44:26.620 --> 00:44:28.940
And then later on when you
want to texture from it,

00:44:28.980 --> 00:44:30.950
you're going to just call glTextImage2D.

00:44:31.430 --> 00:44:33.950
Notice I use a rectangle texture,
which we mentioned in brief earlier,

00:44:33.950 --> 00:44:37.400
which allows you to texture
from nonpower of two images,

00:44:37.400 --> 00:44:42.900
and I do a switch on the depth of that
image and determine whether I'm going

00:44:42.980 --> 00:44:45.430
to use the 1555 or 8888 pixel format.

00:44:45.570 --> 00:44:49.590
That would be kind of the overview
of how to texture from a GWorld.

00:44:49.640 --> 00:44:54.690
So moving on to texturing from
Cocoa using NSImage and NSBitmapImageRep.

00:44:54.820 --> 00:44:56.480
So first, in this case,
we're going to texture

00:44:56.550 --> 00:44:56.820
from the 8888 pixel format.

00:44:56.820 --> 00:44:56.820
So we're going to use the
1555 or 8888 pixel format.

00:44:56.820 --> 00:44:56.820
That would be kind of the overview
of how to texture from a GWorld.

00:44:56.820 --> 00:44:56.820
So moving on to texturing from
Cocoa using NSImage and NSBitmapImageRep.

00:44:56.820 --> 00:45:00.350
So first, 8888 RGBA format,
which is what you're going to see

00:45:00.500 --> 00:45:03.060
from Core Graphics or from Cocoa.

00:45:03.130 --> 00:45:04.820
We're going to create a
texture size NS image.

00:45:04.820 --> 00:45:06.960
So you create an NS image
as you would normally.

00:45:07.020 --> 00:45:11.300
We're going to lock the focus on this
image and we're going to draw into it.

00:45:11.360 --> 00:45:15.560
We're then going to create a
bitmap image from the NS bitmap

00:45:15.670 --> 00:45:17.820
image rep from the NS image.

00:45:17.820 --> 00:45:20.870
Usually I do the focused
view to create that,

00:45:21.010 --> 00:45:23.020
so it's fairly simple to do.

00:45:23.020 --> 00:45:25.710
The texture size will be
that bitmap size you create,

00:45:25.790 --> 00:45:29.580
and then you can texture
directly from the bitmap data,

00:45:29.640 --> 00:45:34.100
in this case RGBA,
and using the unsigned byte format.

00:45:34.180 --> 00:45:35.610
So what does code for that look like?

00:45:35.610 --> 00:45:37.420
A little bit shorter,
a little bit simpler.

00:45:37.420 --> 00:45:41.170
So if you're using the Cocoa,
a little bit less work to do here.

00:45:41.220 --> 00:45:42.770
The NS image alloc init.

00:45:42.770 --> 00:45:45.560
Then you get the lock
the focus for that image.

00:45:45.560 --> 00:45:48.180
You draw whatever your
content would be there.

00:45:48.380 --> 00:45:50.650
You create the bitmap,
or you can get me back up a little

00:45:50.730 --> 00:45:52.280
bit when you create the NS image.

00:45:52.280 --> 00:45:52.280
You can create the bitmap.

00:45:52.280 --> 00:45:52.280
You can create the bitmap,
but you can also create the bitmap.

00:45:52.280 --> 00:45:52.280
You can create the bitmap,
but you can also create the bitmap.

00:45:52.280 --> 00:45:52.280
You can create the bitmap,
or you can get me back up a little

00:45:52.280 --> 00:45:52.280
bit when you create the NS image.

00:45:52.280 --> 00:45:52.600
You can create the bitmap or
you can create the bitmap,

00:45:52.610 --> 00:45:53.420
or you can create the bitmap,
or you can create the bitmap.

00:45:53.440 --> 00:45:54.790
You can create the NS image from a file.

00:45:54.790 --> 00:45:57.340
In that case, you would not really be
drawing just a lock focus,

00:45:57.420 --> 00:45:58.870
and then you'd create the bitmap.

00:45:58.900 --> 00:45:59.960
You'd already have the content.

00:45:59.960 --> 00:46:03.160
To create the bitmap,
you unlock the focus because you

00:46:03.160 --> 00:46:04.460
don't need to have it locked anymore.

00:46:04.460 --> 00:46:08.040
You get the size from the bitmap,
and then you call text image 2D,

00:46:08.040 --> 00:46:10.600
texture rectangle again
to handle any size image,

00:46:10.600 --> 00:46:14.300
and you're going to use the
RGBA and unsigned byte for that.

00:46:14.300 --> 00:46:16.890
So bitmap release, image release.

00:46:16.990 --> 00:46:18.310
Again, this is in Cocoa.

00:46:18.310 --> 00:46:19.880
Same thing we showed in Carbon.

00:46:20.230 --> 00:46:21.170
Fairly simple to do.

00:46:21.170 --> 00:46:24.440
This is areas of OpenGL where you
have to interface with the operating

00:46:24.440 --> 00:46:26.680
system to handle that image,
and this is things that

00:46:26.680 --> 00:46:28.560
OpenGL does not have built into it.

00:46:28.940 --> 00:46:32.250
So there's two areas you
would have to interface there.

00:46:32.450 --> 00:46:35.810
Taking the texture then,
we can extend that to drawing fonts.

00:46:35.950 --> 00:46:38.170
And if you want to use,
there's a couple ways

00:46:38.210 --> 00:46:39.430
to do drawing fonts.

00:46:39.530 --> 00:46:43.320
First, on a per-character basis,
there's things like AGL use font.

00:46:43.410 --> 00:46:46.030
And also in the CGL example,
I wrote a CGL use font,

00:46:46.220 --> 00:46:48.440
which works very similar to AGL use font.

00:46:48.440 --> 00:46:50.750
So if you're not using AGL,
you can get that

00:46:50.750 --> 00:46:52.490
per-character bitmap fonts.

00:46:52.490 --> 00:46:56.700
Good for what you saw in that previous
example for putting up text like that.

00:46:56.700 --> 00:46:59.970
Just kind of debug text,
text that you want, information,

00:47:00.210 --> 00:47:01.980
but it's not optimum.

00:47:02.450 --> 00:47:05.560
Bitmaps are not real fast,
especially redrawing the bitmap

00:47:05.560 --> 00:47:07.420
every frame is not a good idea.

00:47:07.420 --> 00:47:09.500
So what can we do?

00:47:09.500 --> 00:47:10.490
There's two options here.

00:47:10.610 --> 00:47:13.640
One I mentioned here and one we'll talk
about at the end if we have some time.

00:47:13.800 --> 00:47:15.300
And I'll show you a quick demo on that.

00:47:15.300 --> 00:47:18.610
First, if you're doing a per-string
textures or text and you want

00:47:18.610 --> 00:47:21.980
to sort them in textures,
that's a fairly simple thing to do.

00:47:21.980 --> 00:47:24.410
Some tips on doing this
is limit your updates.

00:47:24.480 --> 00:47:27.310
Every time you change that texture,
you have to re-upload the texture.

00:47:27.410 --> 00:47:30.860
If you keep your texture constant
through the entire application or you

00:47:30.860 --> 00:47:34.150
have some things that's limited to
when the user responds to something,

00:47:34.230 --> 00:47:37.670
update only the string at that point,
update the texture at that point,

00:47:37.820 --> 00:47:40.710
and you limit the amount of updates
of the texture onto the graphics card.

00:47:41.220 --> 00:47:43.650
Using pre-multiplied alpha for textures.

00:47:43.660 --> 00:47:46.620
And if some of you aren't familiar
with pre-multiplied alpha,

00:47:46.620 --> 00:47:49.350
we can take a little sidebar and
talk about pre-multiplied alpha.

00:47:51.550 --> 00:47:55.610
Premultiplied alpha is something
that is not... A lot of people,

00:47:55.610 --> 00:47:58.510
depending on what your
background is in graphics,

00:47:58.540 --> 00:48:01.960
you either think in this terms
or don't think in this terms.

00:48:01.960 --> 00:48:05.940
But for people who don't think about
premultiplied alpha as something

00:48:05.940 --> 00:48:09.670
really good to use in your application,
it's alpha which is already

00:48:09.820 --> 00:48:12.500
multiplied through your pixel,
your color.

00:48:12.620 --> 00:48:18.220
So a 50% gray, non-premultiplied,
red of 1.0, green of 1.0, blue of 1.0,

00:48:18.220 --> 00:48:20.310
alpha of 0.5.

00:48:21.500 --> 00:48:24.110
Premultiplied 0.5, 0.5, 0.5, 0.5.

00:48:24.150 --> 00:48:27.560
So that gives you the alpha is
already premultiplied through.

00:48:27.560 --> 00:48:28.760
Why use it?

00:48:28.800 --> 00:48:33.020
It's simpler and it's
closed on the over operator.

00:48:33.020 --> 00:48:35.020
So over is basically the
compositing operator.

00:48:35.030 --> 00:48:37.220
If you composite something
over top of something else,

00:48:37.420 --> 00:48:38.560
you get a closed function.

00:48:38.560 --> 00:48:42.080
If you don't use premultiplied
alpha and you take two images

00:48:42.080 --> 00:48:45.910
and you composite them,
what you get out is premultiplied.

00:48:45.910 --> 00:48:49.650
So then you try and use this
image with something else.

00:48:49.810 --> 00:48:52.280
Well, this is... I know, well,
what's the first to know?

00:48:52.280 --> 00:48:54.580
Well, let's just use
premultiplied all the time.

00:48:54.610 --> 00:48:57.300
Two pre-multiplied images,
you get premultiplied out.

00:48:57.420 --> 00:49:00.110
Two more pre-multiplied images,
you get premultiplied out.

00:49:00.110 --> 00:49:01.910
Take the results of those two,
put them together,

00:49:01.980 --> 00:49:03.220
and you get premultiplied out.

00:49:03.480 --> 00:49:06.190
Consistent across the board, easy to use.

00:49:06.190 --> 00:49:08.120
You can use it very simply.

00:49:08.120 --> 00:49:12.290
The only change in OpenGL to understand
is the blend function changes.

00:49:12.310 --> 00:49:15.390
Non-premultiplied,
if people are doing blending out here,

00:49:15.510 --> 00:49:19.060
they're probably used to doing
source alpha on the source component.

00:49:19.060 --> 00:49:19.220
In this case, since you know that you're
doing blending out here,

00:49:19.220 --> 00:49:19.530
you're probably used to doing source
alpha on the source component.

00:49:19.560 --> 00:49:21.090
In this case,
since you know that the alpha's

00:49:21.170 --> 00:49:26.190
already multiplying through your color,
you'd use GL1 and know that the color

00:49:26.190 --> 00:49:28.240
already has the alpha value in it.

00:49:28.240 --> 00:49:30.440
That's the sidebar in
premultiplied alpha.

00:49:30.530 --> 00:49:31.510
We have more questions about it.

00:49:31.510 --> 00:49:32.640
We can talk more about that later.

00:49:32.640 --> 00:49:34.480
Back to drawing fonts.

00:49:34.530 --> 00:49:38.540
So the last thing,
if you want to have a colored text, one,

00:49:38.540 --> 00:49:41.820
or color-changing text,
instead of putting the

00:49:41.820 --> 00:49:45.180
color in the text itself,
put it in the polygon.

00:49:45.180 --> 00:49:48.080
Use the polygon for alpha for blending.

00:49:48.080 --> 00:49:48.560
Use the polygon for blending.

00:49:48.560 --> 00:49:52.100
Use the polygon for colorizing font
strings if you want to do that.

00:49:52.150 --> 00:49:56.420
So it's really easy to get high-quality
fonts into OpenGL through textures.

00:49:56.420 --> 00:49:59.150
So let's go to a quick demo on that.

00:50:03.100 --> 00:50:07.250
So this is my Cocoa OpenGL example which
is something also available on the web.

00:50:07.250 --> 00:50:09.760
I'll move, I'll actually leave the square
there and I'll bring the,

00:50:09.820 --> 00:50:11.360
so this is the same
thing you've seen before.

00:50:11.500 --> 00:50:12.710
Probably too hard to read,
it's not really important

00:50:12.840 --> 00:50:15.480
what the text says,
but how it operates on the

00:50:15.480 --> 00:50:17.010
frame is more important.

00:50:17.160 --> 00:50:20.340
This is using very,
very simple NSStringTexture class

00:50:20.340 --> 00:50:23.360
that uses exactly the techniques
we showed for texturing and for

00:50:23.360 --> 00:50:27.890
handling strings and creates simple
strings that you can easily update,

00:50:28.130 --> 00:50:30.810
scale,
they composite very nicely over top

00:50:30.870 --> 00:50:34.170
of each other using pre-multiplied
alpha and it's set up in such a

00:50:34.170 --> 00:50:37.160
way that if you're using Cocoa,
go ahead and download the

00:50:37.240 --> 00:50:40.190
sample and just use the class
directly in your applications.

00:50:40.260 --> 00:50:42.310
You pass a string in,
it creates a texture for you and

00:50:42.310 --> 00:50:43.880
you can draw with the texture.

00:50:44.000 --> 00:50:46.000
You can go back to the slides.

00:50:48.400 --> 00:55:03.000
[Transcript missing]

00:55:04.210 --> 00:55:07.350
So OpenGL, handling images works great.

00:55:07.570 --> 00:55:09.220
So let's talk about playing movies.

00:55:09.220 --> 00:55:12.880
Playing movies with OpenGL,
the setup is very similar to

00:55:12.880 --> 00:55:14.180
the Carbon setup we saw before.

00:55:14.180 --> 00:55:16.500
You can use QuickTime as
the API to play the movie.

00:55:16.650 --> 00:55:18.960
And you can use standard
QuickTime setup techniques.

00:55:18.970 --> 00:55:21.560
And you can use this in a
Cocoa or a Carbon application.

00:55:21.580 --> 00:55:24.400
One thing you do need to do is
know when QuickTime has finished

00:55:24.400 --> 00:55:26.100
drawing a frame of your movie.

00:55:26.100 --> 00:55:29.500
What you'll do is use the new
movie drawing complete UPP.

00:55:29.500 --> 00:55:31.870
And you'll create a callback
basically that says,

00:55:31.980 --> 00:55:33.860
hey, I'm done with drawing a frame.

00:55:33.860 --> 00:55:37.240
At that point, OpenGL can check to see if
the frame's been updated.

00:55:37.240 --> 00:55:39.890
If it has,
it can texture from the updated frame.

00:55:40.160 --> 00:55:42.840
Same technique to just use
an OpenGL image and update

00:55:42.930 --> 00:55:43.910
the frame on the screen.

00:55:43.990 --> 00:55:46.920
So really what you're doing is you're
drawing a sequence of images and updating

00:55:47.020 --> 00:55:48.720
when you're told to by QuickTime.

00:55:48.720 --> 00:55:50.010
That's the simple technique.

00:55:50.140 --> 00:55:53.570
There's nothing more involved
than playing movies on the screen.

00:55:53.890 --> 00:55:55.690
Some people when they sit
back and think about it,

00:55:55.720 --> 00:55:57.980
will realize there's actually
2 points of synchronization.

00:55:57.980 --> 00:56:00.210
One when Quicktime's done with
the image and you can use it,

00:56:00.210 --> 00:56:02.190
and one when OpenGL's
done with the image.

00:56:02.190 --> 00:56:04.720
It takes a little more
complicated code to handle both

00:56:04.720 --> 00:56:06.620
of those synchronization points.

00:56:06.620 --> 00:56:09.900
Many applications will do fine
updating their OpenGL texture

00:56:09.900 --> 00:56:12.690
when Quicktime's done with it,
and not worry about the second sync.

00:56:12.700 --> 00:56:15.350
We do have a sample that's the
OpenGL compositor lab that shows

00:56:15.350 --> 00:56:19.510
creating a custom codec to actually sync
at both ends of the thing for things that

00:56:19.510 --> 00:56:24.020
people that need specific syncing and
very fine control of the movie playing.

00:56:24.020 --> 00:56:27.880
And then we'll use GLTextImage2D and
then we'll use a different routine,

00:56:27.950 --> 00:56:31.450
GLTextSubImage2D to actually update
the movies when we're only updating the

00:56:31.450 --> 00:56:34.040
part of the movie that actually changed.

00:56:34.040 --> 00:56:35.260
And we'll go to another demo of this.

00:56:35.260 --> 00:56:38.140
Again, this is sample code that's
available on the web.

00:56:38.340 --> 00:56:39.110
This is OpenGL Movie.

00:56:42.250 --> 00:56:45.950
And I will grab something
you've probably seen before.

00:56:45.950 --> 00:56:48.490
And this is again,
it's basically drawing a new

00:56:48.630 --> 00:56:54.160
frame every single time that the
movie tells it has a frame update.

00:56:54.340 --> 00:56:57.070
And you can see right now
I'm getting about 250,

00:56:57.070 --> 00:57:02.250
260 frames per second of OpenGL drawing,
updating the texture at the rate the

00:57:02.250 --> 00:57:05.800
QuickTime updates the texture for a 24,
30 frame per second movie.

00:57:05.800 --> 00:57:08.290
So the point here is that you can,
with OpenGL,

00:57:08.290 --> 00:57:12.150
easily handle the texturing capabilities
for a single QuickTime stream

00:57:12.160 --> 00:57:14.200
or multiple QuickTime streams.

00:57:14.200 --> 00:57:18.570
So dual effects on movies,
get movies to the screen at a high speed,

00:57:18.600 --> 00:57:22.340
it's not a bad thing for this integration
to use OpenGL for your application.

00:57:22.400 --> 00:57:24.880
And manipulating the polygon,
that's free.

00:57:24.910 --> 00:57:28.260
I can draw that just as fast, lift,
spinning as I could,

00:57:28.260 --> 00:57:30.600
square on the screen, full screen.

00:57:30.600 --> 00:57:35.190
Let's go back to slides.

00:57:36.400 --> 00:57:39.360
So the final section of the presentation
is some tips and we're going to go

00:57:39.360 --> 00:57:43.450
through three things that a lot of
developers run into and that can

00:57:43.450 --> 00:57:46.750
help you develop your applications,
help you either polish them up or

00:57:46.910 --> 00:57:49.040
understand what's going on behind
the scenes a little bit better.

00:57:49.040 --> 00:57:51.290
First we'll talk about shared
context and we'll talk about

00:57:51.370 --> 00:57:52.660
full screen anti-aliasing.

00:57:52.730 --> 00:57:55.080
Finally we'll talk
about render to texture,

00:57:55.080 --> 00:57:58.220
a much requested feature
that we've added for Panther.

00:57:59.350 --> 00:58:00.390
First, shared context.

00:58:00.460 --> 00:58:02.960
You have a lot of windows,
you have a lot of different

00:58:02.960 --> 00:58:05.070
stuff on your screen,
you have a lot of textures,

00:58:05.150 --> 00:58:07.900
you have maybe used display lists,
you have vertex programs,

00:58:08.050 --> 00:58:10.130
fragment programs,
but you only want to write

00:58:10.130 --> 00:58:11.600
them once or load them once.

00:58:11.720 --> 00:58:14.510
You don't want to have to load the
texture into every single context.

00:58:14.580 --> 00:58:16.970
You can use shared context
to alleviate the problem with

00:58:16.970 --> 00:58:18.380
loading multiple textures.

00:58:18.380 --> 00:58:21.970
Texture objects, vertex programs,
fragment programs, display list,

00:58:22.040 --> 00:58:25.160
and a vertex array objects all
can be shared between context.

00:58:25.160 --> 00:58:29.010
The other context state,
like is texture enabled or not,

00:58:29.010 --> 00:58:30.200
is not shared.

00:58:30.200 --> 00:58:33.090
So it's just the objects and the
associated state with those objects.

00:58:33.180 --> 00:58:36.660
The trick here is it's the same
virtual screen configuration,

00:58:36.710 --> 00:58:40.510
which sounds like a mouthful and
kind of in some cases gets tricky.

00:58:40.510 --> 00:58:42.750
There are two ways to avoid
worrying about virtual screen

00:58:42.840 --> 00:58:44.500
configurations and sharing context.

00:58:44.560 --> 00:58:48.860
First, create the same pixel format,
create a single display pixel format,

00:58:48.860 --> 00:58:51.980
or share it with other contexts
of the same pixel format.

00:58:52.060 --> 00:58:54.390
So first,
if you're doing full screen or if

00:58:54.390 --> 00:58:58.340
you know that you only have a single
screen system or you want to constrain

00:58:58.340 --> 00:59:01.860
your windows to a single screen,
create that pixel format using

00:59:01.860 --> 00:59:05.170
some of the techniques we showed
for the full screen section to

00:59:05.240 --> 00:59:09.410
only support that one screen and
you'll be able to share no problem.

00:59:09.870 --> 00:59:13.650
Second is you can create a single
pixel format and share across

00:59:13.650 --> 00:59:16.300
contacts with a single pixel format.

00:59:16.490 --> 00:59:18.500
Full screen pixel formats
and window drawables are also

00:59:18.500 --> 00:59:20.800
something new for Panther.

00:59:21.030 --> 00:59:25.550
For Panther, for pre-Panther,
people would create a full screen

00:59:25.560 --> 00:59:29.190
pixel format and then we would,
if they tried to attach that full

00:59:29.190 --> 00:59:33.430
screen pixel format with the full
screen attribute to a windowed drawable,

00:59:33.530 --> 00:59:34.870
we would fail on that.

00:59:34.870 --> 00:59:38.000
We've relaxed that description,
basically made that

00:59:38.000 --> 00:59:38.210
full screen attribute a

00:59:38.460 --> 00:59:40.580
Additional constraint
on the pixel format,

00:59:40.580 --> 00:59:43.770
but when it attaches to the drawable,
it's an optional item.

00:59:43.790 --> 00:59:46.410
So you can create one pixel
format that's full screen,

00:59:46.450 --> 00:59:48.760
and you can attach it
to your window drawable.

00:59:48.760 --> 00:59:50.820
You can manipulate
your thing in a window,

00:59:50.820 --> 00:59:53.020
like maybe a keynote kind of application.

00:59:53.090 --> 00:59:55.000
You manipulate your slide,
and you want to go full screen.

00:59:55.420 --> 00:59:57.820
Well,
when the user shifts to full screen,

00:59:57.820 --> 00:59:59.780
you actually use the
exact same pixel format,

00:59:59.780 --> 01:00:02.990
and you can actually create a full
screen context and create that

01:00:03.090 --> 01:00:06.460
attached to a full screen drawable,
rather than having to tear

01:00:06.460 --> 01:00:08.180
down and recreate everything.

01:00:08.180 --> 01:00:10.840
This will help your code
and simplify your code path.

01:00:12.760 --> 01:00:15.060
looking at some context sharing code.

01:00:15.060 --> 01:00:18.280
For this example,
it's an example of using a windowed

01:00:18.280 --> 01:00:20.360
and full-screen drawable and
sharing the same pixel format.

01:00:20.360 --> 01:00:23.440
First thing we do is create a
pixel format with full screen.

01:00:23.440 --> 01:00:25.620
We create the same pixel
format without full screen.

01:00:25.620 --> 01:00:29.080
We're going to get the main device
to show you that we create both,

01:00:29.320 --> 01:00:32.800
choose pixel format and uses
the same device in both cases.

01:00:32.800 --> 01:00:36.000
And you'll notice that the
second create context call,

01:00:36.000 --> 01:00:39.430
the final parameter is the
AGL context of the first context.

01:00:39.500 --> 01:00:41.580
That shows you the code,
what sharing a context

01:00:41.640 --> 01:00:42.390
is going to be like.

01:00:42.790 --> 01:00:45.980
In this case,
this too will share the object resources,

01:00:45.980 --> 01:00:47.380
those five things we talked about.

01:00:47.380 --> 01:00:51.030
There's some examples of this also
in some of the samples on the web.

01:00:52.750 --> 01:00:54.850
Full-Screen Anti-Aliasing,
something that people ask about.

01:00:54.980 --> 01:00:58.990
How do you do FSAA or Full-Screen
Anti-Aliasing on the Macintosh?

01:00:59.040 --> 01:00:59.760
It's not supported.

01:00:59.760 --> 01:01:02.920
I don't see a Full-Screen Anti-Aliasing
button on a control panel.

01:01:02.920 --> 01:01:07.090
Well, what Full-Screen Anti-Aliasing
does is it actually is using

01:01:07.090 --> 01:01:10.570
the R multi-sample extension,
which is a standard way of supporting

01:01:10.580 --> 01:01:12.610
OpenGL Full-Screen Anti-Aliasing.

01:01:12.680 --> 01:01:15.950
And I say scene rather than screen
because it's not a per-window basis,

01:01:16.040 --> 01:01:17.290
it's not a per-screen basis.

01:01:17.300 --> 01:01:19.340
So you can have one window
that's anti-aliased and one

01:01:19.340 --> 01:01:20.630
window that's not anti-aliased.

01:01:21.260 --> 01:01:23.490
The extension has specific
details on how it works,

01:01:23.650 --> 01:01:27.240
but let me go and say the
setup of it is pretty simple.

01:01:27.240 --> 01:01:29.780
You're going to basically create a
pixel format and you're going to add

01:01:29.780 --> 01:01:33.240
a couple items to your pixel format of
samples and a sample buffers to your

01:01:33.340 --> 01:01:36.670
pixel format that tells you that you
want to do Full-Screen Anti-Aliasing.

01:01:36.680 --> 01:01:39.550
Then you're going to enable
our multi-sample with the

01:01:39.740 --> 01:01:43.200
multi-sample ARB GL extension,
and then you're going to, if optionally,

01:01:43.200 --> 01:01:45.870
if you would like to,
you can send a hint that GL can

01:01:45.870 --> 01:01:51.200
recognize nicest or fastest to tell
the driver that you prefer either way.

01:01:51.260 --> 01:01:55.440
Either the best-looking possible
multi-sample or anti-aliasing

01:01:55.440 --> 01:01:58.260
or the fastest possible for the
number of samples you've picked.

01:01:58.340 --> 01:02:01.660
That won't hurt, even if you're not,
it's an NVIDIA extension,

01:02:01.740 --> 01:02:03.800
but it won't hurt to call it on any card.

01:02:03.800 --> 01:02:06.850
It's not going to break your
application or reject it.

01:02:06.880 --> 01:02:11.520
It'll just ignore the setting if the card
does not support that particular setting.

01:02:11.520 --> 01:02:15.440
Code for this, we'll get rid of the stuff
that we've already seen,

01:02:15.440 --> 01:02:17.400
and really, really simple here.

01:02:17.400 --> 01:02:19.930
Sample buffers ARB is
always going to be one.

01:02:19.940 --> 01:02:22.000
Samples ARB, we're going to set the four.

01:02:22.000 --> 01:02:26.110
In this case, I added the no recovery,
and that basically means I don't want a

01:02:26.270 --> 01:02:29.420
software backup because the software does
not support multi-sample at this point.

01:02:29.420 --> 01:02:32.540
No recovery will tell you
only to get hardware renders,

01:02:32.540 --> 01:02:37.220
and you can see more about this on one
of the Q&As that was updated talking

01:02:37.220 --> 01:02:40.420
about multi-sample and context selection.

01:02:40.420 --> 01:02:45.870
GL enable, multi-sample ARB, GL hint,
multi-sample filter hint,

01:02:46.040 --> 01:02:49.110
NV and nicest if I want to use that,
and that's how to set up

01:02:49.110 --> 01:02:50.140
full screen anti-aliasing.

01:02:51.850 --> 01:02:55.300
For the final item,
we'll talk about render to texture.

01:02:55.380 --> 01:02:56.960
Three ways to do render to texture.

01:02:57.160 --> 01:02:58.260
First is surface texture.

01:02:58.350 --> 01:02:59.310
We've had that in Jaguar.

01:02:59.640 --> 01:03:03.130
That was calling the AGL surface texture,
GLUT surface texture,

01:03:03.140 --> 01:03:06.520
or the NS create texture APIs,
and you can use them

01:03:06.520 --> 01:03:08.400
for surface texturing.

01:03:08.490 --> 01:03:10.880
Added for Panther was Pbuffers.

01:03:10.900 --> 01:03:12.310
It's a Windows API.

01:03:12.700 --> 01:03:16.530
Prior to this, also supported across
Linux as a WGL extension.

01:03:16.530 --> 01:03:19.560
We've taken that extension,
taken the meat out of it,

01:03:19.660 --> 01:03:22.160
and basically implemented an
API that corresponds to that.

01:03:22.160 --> 01:03:25.300
We couldn't implement it exactly
because it deals with things like

01:03:25.320 --> 01:03:29.560
HTCs and Windows-specific kind
of drawable code and formats.

01:03:29.560 --> 01:03:32.140
So what we've done is make the
setup a little bit simpler,

01:03:32.190 --> 01:03:35.430
but then make the functionality the same.

01:03:35.440 --> 01:03:36.900
It's more robust than surface textures.

01:03:36.900 --> 01:03:38.100
It allows you to do more things.

01:03:38.100 --> 01:03:40.270
In the end,
what it allows you to do is create

01:03:40.390 --> 01:03:44.370
an accelerated off screen to do some
rendering into and then use that

01:03:44.670 --> 01:03:48.510
rendering as the source of a texture.

01:03:48.520 --> 01:03:50.390
It's supported in AGL, CGL,
and soon in the NSGL.

01:03:50.560 --> 01:03:53.790
The Panther that you have
does not have that support,

01:03:53.790 --> 01:03:57.610
but by the shipping time,
we should have the support in for the

01:03:57.610 --> 01:04:00.520
NSGL version of the code to use Pbuffers.

01:04:00.720 --> 01:04:02.040
Final method is Superbuffers.

01:04:02.080 --> 01:04:05.080
We're following closely with
the ARB working group on that,

01:04:05.080 --> 01:04:08.050
working directly with them,
and when the Superbuffers

01:04:08.050 --> 01:04:11.430
extension is finalized,
we'll be shortly after that.

01:04:11.430 --> 01:04:15.310
Should be having our
implementation of that.

01:04:16.080 --> 01:04:18.630
So P buffers,
we talked a little bit about it,

01:04:18.690 --> 01:04:19.840
generalized pixel buffers.

01:04:19.880 --> 01:04:21.280
It can be the target of rendering.

01:04:21.280 --> 01:04:24.820
In this case, you're going to want to use
the commands like AGL set

01:04:24.890 --> 01:04:28.330
P buffer or CGL set B buffer,
which will basically say, hey,

01:04:28.490 --> 01:04:29.900
this is what I want to render into.

01:04:29.900 --> 01:04:31.740
Think of that as a set drawable call.

01:04:31.740 --> 01:04:33.930
So basically, you have an offscreen,
and you call that,

01:04:33.930 --> 01:04:35.650
and that's going to do your set drawable.

01:04:35.660 --> 01:04:38.590
Then if when you want
to render from that,

01:04:38.590 --> 01:04:43.340
you're going to use AGL text image
P buffer or CGL text image P buffer.

01:04:43.640 --> 01:04:49.010
Think of this exactly as a texture
2D call to render from the P buffer,

01:04:49.100 --> 01:04:51.180
or you can even use
cube maps of P buffers,

01:04:51.180 --> 01:04:53.140
or you can do a cube map text stream.

01:04:53.140 --> 01:04:56.120
And finally, the setup is going to be
you're going to set it up,

01:04:56.140 --> 01:04:58.420
you create it,
you're going to draw to it,

01:04:58.480 --> 01:05:00.620
you're going to bind to it,
and then you're going to texture from it.

01:05:00.680 --> 01:05:01.750
Okay.

01:05:02.460 --> 01:05:04.490
So code example,
I'm not going to go through

01:05:04.490 --> 01:05:06.480
all the nuances here,
but I want you to understand

01:05:06.480 --> 01:05:09.230
that this is things you've seen
before with creating pbuffers.

01:05:09.240 --> 01:05:12.240
There's an AGL create pbuffer call,
which is new,

01:05:12.240 --> 01:05:16.180
and then you have a set pbuffer call,
which is new, but you notice these are

01:05:16.180 --> 01:05:19.590
very similar to other APIs,
the APIs you've seen and

01:05:19.680 --> 01:05:20.920
stuff you've used before.

01:05:20.920 --> 01:05:22.610
You're going to draw to it.

01:05:22.870 --> 01:05:24.650
When you're finished
drawing to the pbuffer,

01:05:24.650 --> 01:05:28.100
you want to use a GL flush to flush it,
and then I set my current context to null

01:05:28.140 --> 01:05:31.640
for safety to make sure I'm not drawing
to my pbuffer when I don't intend to.

01:05:33.090 --> 01:05:36.040
So if I don't have a texture ID created,
I'm actually going to generate a texture.

01:05:36.210 --> 01:05:39.320
I'm going to bind to that
texture and then I'm going

01:05:39.400 --> 01:05:42.960
to set linear as a parameter,
as a filter parameter here.

01:05:43.090 --> 01:05:44.380
So I don't want to have any mipmaps.

01:05:44.490 --> 01:05:45.640
PBuffers do support mipmaps.

01:05:45.640 --> 01:05:49.440
In this case, I'm only showing an
example without mipmaps.

01:05:49.530 --> 01:05:52.470
I'm going to texture from the PBuffer.

01:05:52.480 --> 01:05:55.060
Once I have that established and
I have that texture name established,

01:05:55.060 --> 01:05:59.060
I'm just going to bind to the PBuffer
directly without using the text image.

01:05:59.060 --> 01:06:01.860
And then when I destroy it,
I'm going to delete the texture,

01:06:02.130 --> 01:06:04.870
destroy the PBuffer, destroy the context,
and destroy the pixel format

01:06:04.870 --> 01:06:06.160
like we've seen before.

01:06:06.240 --> 01:06:09.790
And let's show a quick example of that.

01:06:17.310 --> 01:06:20.850
So what this example
is was just a square.

01:06:20.850 --> 01:06:23.440
And then what I did,
I took the Stanford rabbit and

01:06:23.440 --> 01:06:28.180
I actually rendered it to... let
me actually do that... I actually

01:06:28.180 --> 01:06:31.720
rendered the rabbit onto a pbuffer.

01:06:31.760 --> 01:06:33.650
and it's actually a flat,
you can see from the top,

01:06:33.720 --> 01:06:34.790
it's actually a flat surface.

01:06:34.820 --> 01:06:38.470
It's not, so it's on each face of the,
each face of the cube

01:06:38.480 --> 01:06:40.670
is rendered the same,
same rabbit.

01:06:40.810 --> 01:06:41.860
You can do a lot of different things.

01:06:41.920 --> 01:06:44.750
You could do a,

01:06:44.950 --> 01:06:47.960
Any kind of rendering you want
to do as a source here and then

01:06:47.960 --> 01:06:49.400
texture in any way possible.

01:06:49.400 --> 01:06:51.480
For example,
you could render cube maps and

01:06:51.480 --> 01:06:57.500
render a full reflection map rendered
and then put it into the pbuffer.

01:07:00.680 --> 01:07:06.090
I do have one more
quick thing to show you.

01:07:06.100 --> 01:07:08.310
I think we're a little
bit into the Q&A time,

01:07:08.310 --> 01:07:11.640
but I'd rather show you this and we
can hang around for questions if people

01:07:11.640 --> 01:07:13.280
don't get enough answered at the end.

01:07:13.660 --> 01:07:24.120
I showed you that demo earlier of
how to create a simple OpenGL sample.

01:07:24.120 --> 01:07:26.400
Well, thinking about it,
after Peter's session,

01:07:26.400 --> 01:07:32.480
we could take that sample and fairly
quickly extend it to use another method

01:07:32.480 --> 01:07:37.140
of getting text on the screen and
high-quality images to use with OpenGL,

01:07:37.140 --> 01:07:38.720
which is the CG on OpenGL.

01:07:38.720 --> 01:07:41.970
And so what we did was we took that
sample that we had before that I just

01:07:41.970 --> 01:07:45.200
created in a few minutes and we
added the code required to do that.

01:07:45.310 --> 01:07:47.980
So let me go to the bottom and
show you what code we added here.

01:07:47.980 --> 01:07:54.040
So this little section of code here
basically is the create a CGGL contact.

01:07:54.120 --> 01:08:04.510
So this is a new call,
CGGL context create,

01:08:04.520 --> 01:08:08.610
which actually creates a CG context
based on that OpenGL context

01:08:08.610 --> 01:08:10.260
we've created to draw CG into.

01:08:10.260 --> 01:08:11.970
Let me shoot back to the top here.

01:08:11.980 --> 01:08:14.440
Then we added a lot of
code in this first section,

01:08:14.440 --> 01:08:18.170
but this is all CG code to draw
something more interesting than nothing.

01:08:18.180 --> 01:08:20.460
So all of this is just CG drawing code.

01:08:20.470 --> 01:08:23.850
I thought drawing one line to the
screen would be pretty boring.

01:08:24.120 --> 01:08:28.440
So the key here is this CG draw routine,
which does the fills and the

01:08:28.860 --> 01:08:31.020
strokes and those kind of things.

01:08:31.020 --> 01:08:33.380
That's a key routine at the very bottom.

01:08:33.380 --> 01:08:35.030
Let me scroll it up so
you all can see that.

01:08:35.300 --> 01:08:37.890
It's a CG context flush.

01:08:37.920 --> 01:08:40.650
And what this does is actually
flushes the drawing out.

01:08:40.660 --> 01:08:43.010
So when you actually draw
the OpenGL and flush the

01:08:43.010 --> 01:08:45.750
OpenGL context into the swap there,
you actually get the

01:08:45.770 --> 01:08:47.340
CG context state updated.

01:08:47.340 --> 01:08:50.460
Additionally, going back to the bottom,
things that we added,

01:08:50.570 --> 01:08:52.460
we added that one little piece of code.

01:08:52.460 --> 01:08:56.120
And then we added...
We flushed our GL drawing,

01:08:56.120 --> 01:08:59.860
and then we just added the draw
CG to the OpenGL drawing routine.

01:08:59.860 --> 01:09:00.900
This is a draw record routine.

01:09:00.900 --> 01:09:02.230
This is exactly the same code.

01:09:02.240 --> 01:09:03.620
No changes to the code.

01:09:03.620 --> 01:09:05.340
I added the CG drawing.

01:09:05.340 --> 01:09:06.820
I added the CG create.

01:09:06.820 --> 01:09:10.470
And I added the draw CG call
to call that CG drawing.

01:09:10.480 --> 01:09:11.010
That was it.

01:09:11.270 --> 01:09:15.640
And so what I end up getting from that,
to save time, I already built this,

01:09:15.640 --> 01:09:20.380
is kind of the ovaltine sample with
the spinning square in the background.

01:09:20.380 --> 01:09:23.610
You can see these are all
the shapes in the front.

01:09:23.740 --> 01:09:24.460
We're all drawn with CG.

01:09:24.460 --> 01:09:29.030
It's doing good transparency
and good blending with its

01:09:29.110 --> 01:09:32.300
pre-multiplied alpha on the square.

01:09:32.300 --> 01:09:37.130
And you can easily add CG overlays
or CG content to your OpenGL views

01:09:37.130 --> 01:09:39.400
and to your OpenGL windows.

01:09:39.400 --> 01:09:41.310
I just wanted to show you that,
show you how easy it was

01:09:41.310 --> 01:09:42.420
to use those new routines.

01:09:42.420 --> 01:09:44.410
So back to the slides.

01:09:44.470 --> 01:09:48.020
So again, we talked in the introduction
a little bit about OpenGL.

01:09:48.020 --> 01:09:49.340
We talked about the interfaces.

01:09:49.400 --> 01:09:52.220
We then talked about some techniques
that everyone can use in their apps.

01:09:52.340 --> 01:09:55.440
And we talked about some... Again,
I want to point out that there

01:09:55.440 --> 01:09:58.420
is sample code out for almost
everything we showed here.

01:09:58.420 --> 01:10:01.280
There is one Q&A that I'll
be posting later this week.

01:10:01.360 --> 01:10:04.660
And the Pbuffer sample will be posted
probably at the very beginning of

01:10:04.660 --> 01:10:06.380
next week or shortly thereafter.

01:10:06.480 --> 01:10:06.980
It's complete.

01:10:06.980 --> 01:10:09.820
It just needs to be run
through the posting process.

01:10:09.820 --> 01:10:12.650
Everything else is on the web,
available for your use.

01:10:12.660 --> 01:10:14.140
So you can go look at it today.

01:10:16.170 --> 01:10:19.140
The best place to go to for
more information though is

01:10:19.360 --> 01:10:21.320
developer.apple.com/opengl.

01:10:21.330 --> 01:10:23.950
There's links to sample code,
there's links to documentation,

01:10:24.120 --> 01:10:26.100
that's a good central repository for it.

01:10:26.130 --> 01:10:30.060
Or another good place for OpenGL in
general is the opengl.org website.

01:10:30.100 --> 01:10:33.100
And I'm going to shoot through here.

01:10:33.100 --> 01:10:37.910
There's some documentation,
a link to the Q&As that I referenced,

01:10:38.200 --> 01:10:41.020
the TechNote that I referenced,
all the samples that were referenced,

01:10:41.100 --> 01:10:45.050
all the samples are on the web,
they're all listed on the OpenGL website.

01:10:45.290 --> 01:10:48.220
And then I'm going to bring
Travis up to talk about the roadmap

01:10:48.270 --> 01:10:50.100
and we'll take some questions.

01:10:50.100 --> 01:10:51.870
Travis Scott Thank you, Geoff.

01:10:56.000 --> 01:10:59.570
So real quick,
what I want to do is just pop through

01:10:59.570 --> 01:11:03.390
the rest of the graphics and imaging
track we have for you here at WWDC and

01:11:03.390 --> 01:11:05.280
focus on the OpenGL-related sessions.

01:11:05.360 --> 01:11:09.670
Next, actually, interestingly enough,
in this hall immediately following this

01:11:09.680 --> 01:11:13.380
presentation is a special presentation
that was not in your show guides,

01:11:13.380 --> 01:11:15.620
and that is the
Technology Magicka Keynote.

01:11:15.640 --> 01:11:18.980
And this is where we have an engineer,
the lead engineer on the keynote product,

01:11:18.980 --> 01:11:22.820
our presentation package,
is going to come essentially talk

01:11:22.820 --> 01:11:25.930
shop about the application and tell
you what technologies they adopted,

01:11:25.940 --> 01:11:29.910
obstacles they overcame when
delivering the application.

01:11:30.160 --> 01:11:32.300
And the interesting point
is that app is a heavy user,

01:11:32.300 --> 01:11:36.540
a heavy client of OpenGL technology for
a lot of its transition and 2D effects.

01:11:36.610 --> 01:11:39.450
Then obviously we have
image capture update,

01:11:39.450 --> 01:11:43.390
which we're going to talk about
our scanning and digital camera

01:11:43.390 --> 01:11:45.590
support API inside the system.

01:11:48.560 --> 01:11:53.410
So then we sort of dive into the
deep end of the pool with OpenGL.

01:11:53.580 --> 01:11:56.590
Starting on Wednesday,
we have a vertex programming with OpenGL.

01:11:56.600 --> 01:11:59.020
A big theme that we talked about in
the graphics and imaging overview

01:11:59.020 --> 01:12:01.580
session was programmability,
harnessing the GPU to

01:12:01.580 --> 01:12:02.820
do interesting things.

01:12:03.010 --> 01:12:05.300
So we have a section on
vertex programmability.

01:12:05.330 --> 01:12:07.770
And then also, if you notice,
on Thursday we have a session

01:12:07.940 --> 01:12:09.260
on fragment programmability.

01:12:09.500 --> 01:12:12.470
And these are really key sessions
if you want to be at the sort of

01:12:12.480 --> 01:12:17.170
cutting edge of the evolution of both
3D and 2D graphics using the GPU.

01:12:17.610 --> 01:12:22.150
We're also going to talk about Quartz
2D in Depth on Thursday as well.

01:12:22.560 --> 01:12:25.180
Another big announcement that
we made in the graphics imaging

01:12:25.180 --> 01:12:28.230
overview and Geoff did the quick
demo where we have the ability to

01:12:28.310 --> 01:12:32.150
take our 2D drawing API Quartz 2D,
also known as CG by short,

01:12:32.290 --> 01:12:36.840
it's a whole different story,
and point it into an OpenGL context.

01:12:36.840 --> 01:12:40.920
And that was what the Ovaltine
example that Geoff showed

01:12:40.920 --> 01:12:40.920
you at the end was about.

01:12:41.810 --> 01:12:43.460
And then we have a key session.

01:12:43.530 --> 01:12:46.500
If you're developing any
OpenGL applications on Mac OS X,

01:12:46.500 --> 01:12:51.940
you want to attend Section 209,
which is OpenGL optimizations.

01:12:51.940 --> 01:12:54.430
You're going to learn just tons
of information about how to make

01:12:54.480 --> 01:12:57.700
OpenGL applications run as fast
as possible on the platform.

01:12:57.700 --> 01:13:01.640
And we'll learn a lot about our
enhanced OpenGL profiler application.

01:13:02.580 --> 01:13:07.820
And then I want to jump down into
cutting-edge OpenGL techniques,

01:13:07.910 --> 01:13:09.620
which is on Friday.

01:13:09.670 --> 01:13:14.090
And this is going to be a great
session that's going to -- we have

01:13:14.090 --> 01:13:18.260
our hardware partners from ATI,
who their demo guides essentially

01:13:18.260 --> 01:13:21.580
are going to come and tell us how
they do a lot of the absolutely

01:13:21.670 --> 01:13:23.660
cutting-edge effects they do
in their demo applications.

01:13:23.660 --> 01:13:25.650
It may be very interesting
for you guys to learn from.

01:13:25.740 --> 01:13:28.480
And they're going to talk about all sorts
of different levels of programmability,

01:13:28.480 --> 01:13:30.620
vertex programmability and
fragment programmability.

01:13:33.430 --> 01:13:35.880
And then obviously we have
a feedback form on Friday.

01:13:36.160 --> 01:13:39.300
So what we want to do is
need to contact either of us.

01:13:39.300 --> 01:13:40.300
I can be contacted.

01:13:40.300 --> 01:13:43.220
I'm Travis@apple.com.

01:13:43.440 --> 01:13:48.780
And Geoff also answers
developer questions and he can

01:13:48.780 --> 01:13:48.780
be found at gstahl@apple.com.
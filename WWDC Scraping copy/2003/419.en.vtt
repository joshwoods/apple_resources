WEBVTT

00:00:19.100 --> 00:00:20.360
Good morning everybody.

00:00:20.360 --> 00:00:24.350
Welcome to session 419,
Cocoa User Interface Programming In-Debt.

00:00:24.410 --> 00:00:29.100
It's the first session of the last day,
so hopefully you guys are wide awake.

00:00:29.100 --> 00:00:32.100
If you're here at 9
o'clock in the morning,

00:00:32.100 --> 00:00:35.960
either you saw Andreas Wencke's
presentation on two days ago,

00:00:35.960 --> 00:00:38.600
the intro version of this,
or you still think this is

00:00:38.600 --> 00:00:41.390
Cocoa Performance Techniques,
it's not.

00:00:41.470 --> 00:00:47.060
We're going to go in depth on some of the
cool new ways of doing your interface,

00:00:47.060 --> 00:00:50.050
and to talk about it is Mark Piccirelli.

00:00:55.400 --> 00:00:57.110
Thank you, Jason.

00:01:03.060 --> 00:01:04.240
So, good morning.

00:01:04.240 --> 00:01:07.760
Wednesday we introduced a lot of
new technology that makes user

00:01:07.760 --> 00:01:09.700
interface programming much easier.

00:01:09.820 --> 00:01:12.660
Now today we're going to
talk about the details.

00:01:13.380 --> 00:01:15.930
In session 412,
we let you know about all the

00:01:15.930 --> 00:01:19.150
new bindings and controllers
technology we're introducing.

00:01:19.290 --> 00:01:21.300
The goal is to automate
user interface handling,

00:01:21.300 --> 00:01:23.300
so you have to write much less code.

00:01:23.300 --> 00:01:26.270
It provides some of the
features you've been asking for.

00:01:26.360 --> 00:01:29.300
Of course, we integrated support for
it into Interface Builder,

00:01:29.300 --> 00:01:33.160
and the whole goal, of course,
is to make your development

00:01:33.160 --> 00:01:34.670
faster and easier.

00:01:35.200 --> 00:01:38.890
and the effect on your application,
much less glue coat.

00:01:38.890 --> 00:01:40.340
So I love this screenshot.

00:01:40.340 --> 00:01:44.310
A big list of IB outlets
just goes completely away.

00:01:44.820 --> 00:01:47.560
So what I'm going to talk about today,
in general I'm going to talk about

00:01:47.630 --> 00:01:51.800
what it takes for your model objects
to integrate into this system.

00:01:51.940 --> 00:01:56.710
And the interfaces by which we allow
that to happen are key value coding,

00:01:56.800 --> 00:01:59.800
key value observing, key value binding.

00:01:59.800 --> 00:02:02.940
We'll talk a little bit about how all
the controller classes fit into this,

00:02:02.940 --> 00:02:06.680
and there'll be some notes
about performance at the end.

00:02:07.250 --> 00:02:11.900
So the architecture that we tried to
adhere to while implementing all of

00:02:11.900 --> 00:02:15.930
this is a classic model view controller.

00:02:18.690 --> 00:02:21.500
For Cocoa,
Model View Controller means the

00:02:21.500 --> 00:02:25.220
view classes that we've always had,
a full set of user interface

00:02:25.220 --> 00:02:26.980
controls and everything.

00:02:27.350 --> 00:02:30.740
Model classes like NS Document and
NSDictionary makes a

00:02:30.790 --> 00:02:32.640
great generic model class.

00:02:32.770 --> 00:02:35.830
And of course the model
classes you provide.

00:02:36.040 --> 00:02:38.280
Now we're introducing three
new controller classes:

00:02:38.280 --> 00:02:41.330
NSArrayController,
NSUserDefaultsController,

00:02:41.330 --> 00:02:43.510
and NSObjectsController.

00:02:44.320 --> 00:02:48.580
We're using the key value coding
system that's been in foundation

00:02:48.580 --> 00:02:53.280
since Mac OS 10.0 and before,
actually.

00:02:53.890 --> 00:02:58.300
We're introducing key value observing
in Panther and key value binding,

00:02:58.300 --> 00:03:00.180
which ties it all together.

00:03:00.180 --> 00:03:03.320
It's how object relationships
are established at nib loading

00:03:03.320 --> 00:03:05.140
times and things like that.

00:03:05.140 --> 00:03:08.780
And in the interest of full disclosure,
at this point I should admit

00:03:08.830 --> 00:03:12.810
that on the WWDC seed disk,
NSArrayController's there.

00:03:13.000 --> 00:03:16.920
Key value observing is mostly there,
but NSArrayController doesn't

00:03:16.930 --> 00:03:18.840
use key value observing.

00:03:18.840 --> 00:03:23.810
So a lot of what I'm going to talk
about is a little bit idealized.

00:03:25.100 --> 00:03:27.150
But it's definitely all
going to be there in Panther,

00:03:27.160 --> 00:03:30.430
and there's still lots of things
on the WWCC worth playing with.

00:03:30.610 --> 00:03:33.800
And when I give examples today,
I'm just going to use

00:03:33.800 --> 00:03:35.420
the old classic Sketch.

00:03:35.420 --> 00:03:40.890
I updated Sketch so that the graphics
view supports binding and does observing,

00:03:40.990 --> 00:03:41.780
things like that.

00:03:41.800 --> 00:03:44.780
And it hooks up to one of
the new array controllers.

00:03:44.820 --> 00:03:49.480
And the draw document got updated a
little bit to support key value coding,

00:03:49.480 --> 00:03:52.230
key value observing,
and I'll show you that.

00:03:52.850 --> 00:03:53.800
So, terminology.

00:03:53.800 --> 00:03:56.890
There's some words that I'm going
to be using that everybody uses,

00:03:56.890 --> 00:03:59.020
but not everybody uses the same way.

00:03:59.020 --> 00:04:03.850
So, today, when I say property,
I mean an attribute, a 2-1 relationship,

00:04:03.850 --> 00:04:05.680
or a too-many relationship.

00:04:05.720 --> 00:04:09.590
By attribute, I mean something simple,
a single immutable value,

00:04:09.700 --> 00:04:13.080
like the fill color or stroke
width of a sketch graphic.

00:04:13.720 --> 00:04:18.500
A 2-1 related object is a single
object related to another.

00:04:18.500 --> 00:04:22.210
It's not an attribute,
it has properties of its own,

00:04:22.210 --> 00:04:23.910
so it'll have attributes.

00:04:23.960 --> 00:04:27.760
An example is the sketch image class,
if you've walked through

00:04:27.850 --> 00:04:29.120
that sample code.

00:04:29.120 --> 00:04:34.680
The image is 2-1 related to
the graphic that holds it.

00:04:34.760 --> 00:04:37.640
And too-many related objects are,
as the name implies,

00:04:37.640 --> 00:04:41.380
collections of related objects,
so the graphics of a sketch document.

00:04:41.380 --> 00:04:43.700
A sketch document has a
collection of graphics.

00:04:43.720 --> 00:04:45.390
for ethics.

00:04:52.390 --> 00:04:58.220
So the first leg of the tripod on which
all this is built is key value coding.

00:04:58.220 --> 00:05:00.840
It's been around for a long, long time.

00:05:00.840 --> 00:05:04.290
We're making some changes to the
implementations of existing API.

00:05:04.510 --> 00:05:07.040
We're adding new API.

00:05:07.040 --> 00:05:09.060
And why do you care?

00:05:09.060 --> 00:05:12.580
Because if you're implementing
custom model classes and you

00:05:12.640 --> 00:05:15.950
want them to work with this
binding and work with controllers,

00:05:15.970 --> 00:05:18.120
they have to be key
value coding compliant.

00:05:18.120 --> 00:05:22.050
And I'll show you what key
value coding compliant means.

00:05:23.050 --> 00:05:26.350
So key value coding is our system
for giving access to object

00:05:26.350 --> 00:05:31.560
properties using a very generic
API that identifies them by key.

00:05:31.560 --> 00:05:34.190
And by key,
we just mean string for the most part.

00:05:34.340 --> 00:05:38.380
A sketch graphic has -- or I'm sorry,
a sketch document has graphics

00:05:38.380 --> 00:05:42.220
identified by the word graphics,
and the individual graphics

00:05:42.220 --> 00:05:43.960
have properties like fill color.

00:05:43.960 --> 00:05:47.600
And you just name the keys, you know,
something programmer readable.

00:05:47.600 --> 00:05:50.780
And these are the same keys that you
saw typed into the interface builder

00:05:50.780 --> 00:05:53.230
bindings inspector in Wednesday's demos.

00:05:53.340 --> 00:05:56.210
So and in the context of
what we're talking about,

00:05:56.210 --> 00:06:00.280
key value coding lets views get
and set values in controllers,

00:06:00.300 --> 00:06:03.180
and it lets controllers get and
set values in model objects.

00:06:05.660 --> 00:06:08.260
So the first method of key value coding,
there's a bunch,

00:06:08.290 --> 00:06:10.530
I'm only going to go through
like four of them today though.

00:06:10.600 --> 00:06:14.570
They serve about 90% of the time.

00:06:14.600 --> 00:06:19.590
Value for key returns the
value of the keyed property.

00:06:19.590 --> 00:06:24.310
What's interesting about what it does is
it actually uses the Objective-C runtime

00:06:24.730 --> 00:06:30.100
to poke around in the class of the model
object to which this message is sent.

00:06:30.100 --> 00:06:34.490
And it invokes an accessor
method whose name is typically

00:06:34.490 --> 00:06:36.550
just the same as the key.

00:06:36.550 --> 00:06:40.310
So your model classes you get
to write in a very natural way,

00:06:40.810 --> 00:06:47.900
but this API allows clients to
access them in a very generic way.

00:06:48.940 --> 00:06:53.540
One of the features it does for you,
it converts scalar values like booleans

00:06:53.540 --> 00:06:58.580
and integers and floats to NSNumbers so
that they can be passed up through the

00:06:58.580 --> 00:07:01.140
API and around to different parts easily.

00:07:01.140 --> 00:07:05.160
So, for example, a sketch graphic has a
boolean attribute drawStroke,

00:07:05.160 --> 00:07:08.880
and the accessor method is
implemented in a totally natural way,

00:07:08.880 --> 00:07:11.340
and it still works.

00:07:11.340 --> 00:07:14.030
When value for key drawStroke
is sent to that object,

00:07:14.030 --> 00:07:15.430
an NSNumber is returned.

00:07:15.440 --> 00:07:18.310
An NSNumber is a little bit
easier to pass around through

00:07:18.310 --> 00:07:21.500
this generic stuff than a boolean
or an integer or a float would be.

00:07:24.560 --> 00:07:28.200
Something new we're adding
to Value4Key for Panther is

00:07:28.200 --> 00:07:32.560
actually inspired by scripting,
and we're adding specific support to

00:07:32.560 --> 00:07:34.840
Value4Key for too many relationships,
you know,

00:07:34.840 --> 00:07:40.930
collections of objects that aren't
most easily stored in NSArray.

00:07:41.040 --> 00:07:44.150
A complicated example of
this is in text storage,

00:07:44.190 --> 00:07:49.620
its scripting support has a too
many relationship called words.

00:07:49.620 --> 00:07:53.950
And to have it pick it all apart and
return an array of words every time

00:07:53.990 --> 00:07:58.620
somebody asks just for one of them
isn't really that great of a thing.

00:07:58.620 --> 00:08:02.760
So we're adding a few more key
value coding compliance methods.

00:08:02.760 --> 00:08:05.560
So you'll have your choice.

00:08:05.560 --> 00:08:09.400
You can either implement graphics in the
example of this sketch draw document,

00:08:09.400 --> 00:08:13.120
or you can implement two methods,
count of graphics and object

00:08:13.120 --> 00:08:18.340
and graphics at index to provide
access to that relationship.

00:08:18.340 --> 00:08:19.230
And

00:08:23.000 --> 00:08:26.780
So, and whatever you choose,
the key value coding client,

00:08:26.780 --> 00:08:29.350
the caller of value for key,
can't tell the difference.

00:08:29.360 --> 00:08:31.130
It gets back an NSArray.

00:08:31.250 --> 00:08:33.800
Key value coding puts the
NSArray together and the client

00:08:33.920 --> 00:08:39.500
that uses key value coding can
send any NSArray method to it,

00:08:39.500 --> 00:08:44.530
including methods that are
implemented in categories on NSArray.

00:08:45.910 --> 00:08:53.100
Something new we added just by request
was support for key value coding get

00:08:53.100 --> 00:08:58.500
accessor names that more closely match
the conventions that you see in our API.

00:08:58.500 --> 00:09:02.160
Value for key not only looks
for methods of the same name,

00:09:02.160 --> 00:09:04.360
but it looks for methods
that begin with is.

00:09:04.360 --> 00:09:07.820
So you can write still more natural code.

00:09:10.410 --> 00:09:12.980
A brand new method for
Panther is setValueForKey,

00:09:12.980 --> 00:09:15.760
and as its name implies,
it sets the value of the keyed property.

00:09:15.760 --> 00:09:19.840
It's a renaming of a method that's
already in there called takeValueForKey,

00:09:19.840 --> 00:09:24.050
and typically we don't just
go rename things in the kit.

00:09:24.060 --> 00:09:27.190
This is actually in addition
to the takeValueForKey

00:09:27.190 --> 00:09:30.240
method that's already there,
but we consider it a renaming.

00:09:30.240 --> 00:09:33.540
We realized while we were working
on this that key value coding was

00:09:33.540 --> 00:09:36.940
going to get much more popular,
more widely used than it has been,

00:09:36.940 --> 00:09:39.740
so we decided to clean
up things like this.

00:09:40.490 --> 00:09:44.800
So in the default implementation does the
equivalent of what valueForKey would do.

00:09:44.800 --> 00:09:49.150
It looks for a method whose name
fits the pattern and invokes it.

00:09:49.160 --> 00:09:52.410
So when you send an object
setValueForKey fillColor,

00:09:52.410 --> 00:09:55.160
it will invoke a method
named setFillColor.

00:09:55.160 --> 00:09:59.330
And just like valueForKey does,
it does NSNumber to

00:09:59.330 --> 00:10:01.720
scalar value conversion.

00:10:03.560 --> 00:10:06.060
Something that's been missing that
we're adding to Panther that's going

00:10:06.060 --> 00:10:10.340
to be very useful in the context of
this UI programming is a new method

00:10:10.340 --> 00:10:12.070
named ValidateValueForKeyError.

00:10:12.100 --> 00:10:15.570
And its implementation is supposed
to either return a value good enough

00:10:15.570 --> 00:10:19.160
for passing into setValueForKey or
it's supposed to return an error.

00:10:19.160 --> 00:10:22.340
And the reason this is separate
from setValue is because it

00:10:22.340 --> 00:10:26.320
separates validation roles from
decisions about when to validate.

00:10:26.320 --> 00:10:29.730
How to validate is
always a model decision,

00:10:29.730 --> 00:10:32.850
but when to validate is a UI decision.

00:10:33.080 --> 00:10:37.660
So for truly reusable model objects,
keeping this separate is a good thing.

00:10:37.660 --> 00:10:41.400
You might want to defer validation
until the user hits the next button

00:10:41.400 --> 00:10:43.350
on a pane or something like that.

00:10:43.380 --> 00:10:47.580
And the way you implement this
follows a typical KVC pattern.

00:10:47.580 --> 00:10:49.150
You just have to name
the method correctly,

00:10:49.190 --> 00:10:49.800
and that's it.

00:10:49.850 --> 00:10:52.720
I couldn't think of an
example of this for Sketch,

00:10:52.720 --> 00:10:55.230
so I picked a zip code,
which I think people will

00:10:55.230 --> 00:10:56.270
probably be typing in a lot.

00:10:56.300 --> 00:10:59.960
And the method name just
follows that pattern.

00:11:03.280 --> 00:11:05.790
Something really new for
Panther is this method,

00:11:05.800 --> 00:11:08.260
mutable array value for key.

00:11:08.260 --> 00:11:11.800
And what it does is it returns
an NSMutableArray or something

00:11:11.800 --> 00:11:16.000
indistinguishable from one that
contains too many related objects.

00:11:16.000 --> 00:11:19.140
And the reason we need this is
because you're not supposed to

00:11:19.140 --> 00:11:22.470
mutate the NSArray that's returned
by value for key when the key

00:11:22.470 --> 00:11:24.580
refers to too many relationships.

00:11:24.580 --> 00:11:29.200
So we wanted to support this concept of,
you know, a client that's naive of the

00:11:29.200 --> 00:11:33.840
class to which it's bound being
able to mutate sets of objects.

00:11:33.840 --> 00:11:35.220
So we added this.

00:11:35.220 --> 00:11:39.960
And the invoker of this method
gets to send any NSMutableArray

00:11:39.960 --> 00:11:43.040
message to the result,
again, including things that are

00:11:43.040 --> 00:11:44.100
implemented on categories.

00:11:46.780 --> 00:11:49.300
The user of this method
really has total flexibility.

00:11:49.300 --> 00:11:54.690
It's not limited to a specific
API when manipulating the data.

00:11:55.780 --> 00:12:01.540
But the model class that provides the
data doesn't have much responsibility.

00:12:01.540 --> 00:12:05.680
It just has to implement two methods
that correspond to the two most

00:12:05.820 --> 00:12:09.010
primitive NSMutable array primitives,
insertion and removal.

00:12:09.020 --> 00:12:14.100
So the client of key value coding gets
to do all sorts of different things,

00:12:14.100 --> 00:12:17.170
but the thing that implements key
value coding support for that key

00:12:17.170 --> 00:12:19.040
doesn't have much responsibility.

00:12:28.940 --> 00:12:33.180
A concept that will be coming up a lot
as I talk and shows up a lot in this

00:12:33.210 --> 00:12:35.700
UI technology is a concept of key paths.

00:12:35.700 --> 00:12:37.900
And for each one of the
methods I just showed you,

00:12:37.900 --> 00:12:41.540
there's a variant that takes a
key path instead of just a key.

00:12:41.540 --> 00:12:44.840
And these are actually probably
invoked a little more often

00:12:44.850 --> 00:12:46.600
than the plain key methods.

00:12:46.600 --> 00:12:48.830
And what's a key path?

00:12:48.830 --> 00:12:52.350
A key path is just a
dot-separated list of keys.

00:12:52.350 --> 00:12:56.620
And those methods that take key
paths pick them apart at the right

00:12:56.670 --> 00:12:58.880
times and invoke accessor methods.

00:12:58.900 --> 00:12:59.900
And those methods correctly.

00:12:59.900 --> 00:13:04.340
So if you send to some object set
value for key path image dot flipped,

00:13:04.340 --> 00:13:09.390
it'll get the image and it'll effectively
send set value for key to that image,

00:13:09.390 --> 00:13:14.120
which boils down basically to the line
you see on the bottom of just getting

00:13:14.120 --> 00:13:16.700
the image and calling set flipped.

00:13:20.040 --> 00:13:22.960
So key value binding is in
terms of key paths and key value

00:13:22.960 --> 00:13:25.240
observing is in terms of key paths.

00:13:25.240 --> 00:13:26.880
And our controllers use key paths.

00:13:26.880 --> 00:13:29.890
For example,
an NSRA controller republishes the

00:13:29.970 --> 00:13:33.920
properties of whatever it's bound to.

00:13:33.920 --> 00:13:38.940
It republishes those properties,
you know, of the selected objects and it

00:13:39.010 --> 00:13:41.440
does it using this key path form.

00:13:41.440 --> 00:13:43.730
So you have to know about them,
but you don't have to do

00:13:43.730 --> 00:13:45.400
anything to implement them.

00:13:46.810 --> 00:13:50.180
So,
if you're writing custom model objects,

00:13:50.180 --> 00:13:54.220
like sketch graphics, for example,
here's basically all you have

00:13:54.220 --> 00:13:56.620
to do to make those classes
key value coding compliant.

00:13:56.620 --> 00:13:59.940
You'd have to implement enough methods
for value for key and set value for

00:13:59.940 --> 00:14:01.640
key and things like that to work.

00:14:01.640 --> 00:14:04.420
So,
for each attribute or 2-1 relationship,

00:14:04.420 --> 00:14:08.380
you know, single values,
you can just implement methods named

00:14:08.380 --> 00:14:12.800
the same as the key that you've
picked to identify that property.

00:14:13.630 --> 00:14:17.100
And if it's a mutable property,
you have to implement a set method also.

00:14:17.100 --> 00:14:20.380
If there's validation to be done,
you implement the validation method.

00:14:20.380 --> 00:14:23.120
If there is no validation method,
that's fine.

00:14:23.120 --> 00:14:27.550
Validate value for key error just
assumes there's no validation necessary.

00:14:27.560 --> 00:14:32.630
For each 2-many relationship,
like the graphics in a sketch document,

00:14:32.630 --> 00:14:34.320
you have your choice.

00:14:34.320 --> 00:14:38.020
You can either implement a simple method
with the same name as the relationship,

00:14:38.020 --> 00:14:42.010
or you can implement a pair of methods,
whichever is most convenient

00:14:42.010 --> 00:14:43.250
in your situation.

00:14:43.620 --> 00:14:45.800
And, you know,
you can change it after the fact

00:14:45.800 --> 00:14:47.830
without having to go change other code.

00:14:47.860 --> 00:14:50.200
For each 2-many relationship
that can be mutated,

00:14:50.260 --> 00:14:52.860
things can be inserted, removed,
or replaced in it,

00:14:52.860 --> 00:14:55.440
you just have to implement
this pair of methods:

00:14:55.440 --> 00:14:58.460
insert object and key at index,
or remove object from key at index.

00:15:01.520 --> 00:15:06.130
So the demos you saw on
Wednesday were great,

00:15:06.130 --> 00:15:09.560
and they took advantage of
the fact that NSDictionary is

00:15:09.560 --> 00:15:10.860
key value coding compliant.

00:15:10.860 --> 00:15:15.740
So for simple model objects,
don't bother writing the class.

00:15:15.740 --> 00:15:17.030
Just use NSDictionary.

00:15:45.850 --> 00:15:45.850
So the demos you saw on
Wednesday were great,

00:15:45.850 --> 00:15:45.850
and they took advantage of
the fact that NSDictionary is

00:15:45.850 --> 00:15:45.850
key value coding compliant.

00:15:45.850 --> 00:15:45.850
So for simple model objects,
don't bother writing the class.

00:15:45.850 --> 00:15:45.850
Just use NSDictionary.

00:15:48.740 --> 00:15:52.040
So the next thing that we're introducing
in Panther is key value observing.

00:15:52.040 --> 00:15:54.070
It's all new API.

00:15:54.080 --> 00:15:55.660
I'll talk about how to observe.

00:15:55.660 --> 00:16:00.820
I'll explain why your model objects have
to be key value observing compliant so

00:16:00.820 --> 00:16:02.780
that other objects can bind to them.

00:16:02.780 --> 00:16:05.990
And I'll explain what you have
to do to make your model classes

00:16:05.990 --> 00:16:07.960
key value observing compliant.

00:16:09.990 --> 00:16:12.060
So what does key value observing do?

00:16:12.060 --> 00:16:15.520
The summary is that it allows
objects to be notified of changes to

00:16:15.520 --> 00:16:17.900
specific properties of other objects.

00:16:17.900 --> 00:16:20.300
The notifications are very detailed.

00:16:20.400 --> 00:16:24.910
In the context of this UI programming,
it lets views be notified of

00:16:24.940 --> 00:16:29.180
changes to values and controllers,
and it lets controllers be notified of

00:16:29.180 --> 00:16:31.530
changes to values and model objects.

00:16:34.260 --> 00:16:38.200
An observer registers its interest in
getting notifications using this method:

00:16:38.200 --> 00:16:41.660
@ObserverForKeyPathOptionsContext.

00:16:41.660 --> 00:16:45.690
This isn't part of an informal protocol,
and this object really does

00:16:45.750 --> 00:16:48.180
have an implementation of this
that does everything you need.

00:16:48.180 --> 00:16:52.600
We don't even really expect this
to be overridden that often.

00:16:52.600 --> 00:16:55.810
These messages are actually sent to
the individual objects to be observed.

00:16:55.840 --> 00:16:59.780
There's no observer center that you
know about or anything like that.

00:17:00.010 --> 00:17:02.540
For this to be meaningful,
The receiver must be key

00:17:02.540 --> 00:17:04.400
value observing compliant.

00:17:05.430 --> 00:17:08.590
As far as reference counting goes,
I think there's probably going to

00:17:08.610 --> 00:17:13.440
be a bunch of different situations
as far as reference counting goes.

00:17:13.460 --> 00:17:18.380
What's appropriate for the observer
to observe the observed object or not.

00:17:18.430 --> 00:17:21.200
So key value observing just
stays out of the discussion.

00:17:21.200 --> 00:17:21.780
It's API.

00:17:21.780 --> 00:17:24.570
It doesn't cause any retains or releases.

00:17:24.570 --> 00:17:28.010
There'll be some standard things that
people will do over and over again

00:17:28.010 --> 00:17:31.200
as far as retaining and releasing,
but key value observing leaves

00:17:31.200 --> 00:17:32.730
everything very flexible.

00:17:34.940 --> 00:17:36.900
And as you would expect,
if there's an addObserver method,

00:17:36.900 --> 00:17:39.890
there's also a removeObserver method.

00:17:40.300 --> 00:17:43.330
So the first parameter is the observer.

00:17:43.330 --> 00:17:46.270
It's the recipient of notifications
about changes to the property

00:17:46.270 --> 00:17:47.560
identified by the keypath.

00:17:47.730 --> 00:17:53.420
This observer must implement the
NSKeyValueObservingInformer protocol,

00:17:53.420 --> 00:17:56.600
which is one method, this one,
ObserveValueForKeyPathOfObjectChangeCont

00:17:56.600 --> 00:17:58.500
ext,
and I'll talk about it a bit later.

00:17:59.940 --> 00:18:02.800
And again,
as an example of who's observing what,

00:18:02.840 --> 00:18:05.260
the controls in sketches
and specter panel,

00:18:05.260 --> 00:18:08.300
that I'll show you in a bit,
will observe the selection

00:18:08.350 --> 00:18:13.250
properties of an NSArrayController
to which they're bound.

00:18:14.980 --> 00:18:17.040
So the key path is just the key path.

00:18:17.100 --> 00:18:20.100
It identifies the
property to be observed.

00:18:20.100 --> 00:18:23.540
Sticking to that example,
selection.fillcolor.

00:18:23.540 --> 00:18:26.280
And it can identify an attribute
to too one relationship

00:18:26.350 --> 00:18:27.500
or too many relationships.

00:18:27.500 --> 00:18:31.590
You can not only observe simple values,
you can observe collections

00:18:31.590 --> 00:18:35.180
values and be told when things are
inserted or removed or replaced.

00:18:37.000 --> 00:18:39.400
Key value observing supports
two options right now.

00:18:39.400 --> 00:18:41.610
We definitely expect this
list to grow in the future,

00:18:41.620 --> 00:18:45.580
but right now there are just two,
new and old.

00:18:45.580 --> 00:18:48.710
And these don't control when
observer notifications are sent,

00:18:48.710 --> 00:18:52.040
just what's in them when they are sent.

00:18:52.040 --> 00:18:55.660
So new controls whether or not
the observer notification has

00:18:55.660 --> 00:18:59.160
the value after the change,
and old controls whether or not

00:18:59.160 --> 00:19:03.250
the observer notification contains
the value from before the change

00:19:03.280 --> 00:19:05.260
that's causing the observer.

00:19:05.260 --> 00:19:09.410
So I think in the feedback
after the session on Wednesday,

00:19:09.410 --> 00:19:12.690
somebody asked about
automatic undo support,

00:19:12.720 --> 00:19:15.450
which is something we always think about.

00:19:15.460 --> 00:19:17.700
And I think this old option
will probably be a big piece

00:19:17.730 --> 00:19:19.100
of that when it comes around.

00:19:21.520 --> 00:19:25.550
And there's a context parameter
following a pattern that's

00:19:25.880 --> 00:19:29.160
common in a lot of Cocoa APIs,
something that you can pass

00:19:29.160 --> 00:19:31.360
in that'll just be passed
back to you at the right time.

00:19:31.360 --> 00:19:35.900
And we think people will probably
use this for identifying the

00:19:35.990 --> 00:19:39.390
reason for the observation,
when one observer is observing

00:19:39.390 --> 00:19:40.620
a bunch of different things.

00:19:42.930 --> 00:19:46.000
So the notification method,
observe value for key path

00:19:46.010 --> 00:19:48.940
of object change context,
is what's sent to the observer for

00:19:48.940 --> 00:19:50.900
every change to the observed property.

00:19:50.900 --> 00:19:52.820
And it's very generic.

00:19:52.970 --> 00:19:57.330
Key value observing doesn't care
what you do when you observe.

00:19:57.450 --> 00:20:02.540
It's meant to be very low
level and very generic.

00:20:03.230 --> 00:20:07.230
So, and the key path and the
object are pretty much just the

00:20:07.230 --> 00:20:09.580
things bouncing back to you.

00:20:09.580 --> 00:20:12.480
Same thing with context.

00:20:12.480 --> 00:20:17.530
Change is an NSDictionary full of
the information about what changed.

00:20:18.030 --> 00:20:21.040
There are four possible entries into it,
the kind of change,

00:20:21.120 --> 00:20:27.110
indexes for the change if there are any,
and new values and old values.

00:20:29.480 --> 00:20:34.140
There are two basic kinds of
observable change notification.

00:20:34.140 --> 00:20:37.260
The first one is for simple setting.

00:20:37.260 --> 00:20:41.300
When the key value coding set
value for key method is invoked and

00:20:41.300 --> 00:20:44.800
somebody's observing for that property,
this is the kind of

00:20:44.800 --> 00:20:46.400
change that will be used,
setting.

00:20:46.510 --> 00:20:52.560
If somebody's observing a too many
relationship and something gets

00:20:52.560 --> 00:20:56.530
inserted or removed or replaced,
one of these next three observer

00:20:56.610 --> 00:20:58.050
notifications will be sent.

00:20:58.580 --> 00:21:00.500
And for example, when might that happen?

00:21:00.500 --> 00:21:03.500
When somebody uses that mutable
array value for key method and

00:21:03.500 --> 00:21:08.170
mutates the array that it gets back,
something like this will

00:21:08.180 --> 00:21:10.320
be sent to any observers.

00:21:13.060 --> 00:21:16.430
and in the case of insertion, removal,
or replacement,

00:21:16.440 --> 00:21:20.160
it provides the indexes of the objects
that are inserted or removed or

00:21:20.160 --> 00:21:24.120
replaced using the new NSIndexSet class
we're introducing in Panther.

00:21:24.120 --> 00:21:27.310
It doesn't make sense for
simple setting changes,

00:21:27.330 --> 00:21:29.570
so it's not there then.

00:21:30.980 --> 00:21:34.440
In the last two entries of the
Key Value Observing Change notification

00:21:34.440 --> 00:21:36.500
are old values and new values.

00:21:36.540 --> 00:21:38.890
And, you know,
these aren't there if the observer

00:21:38.890 --> 00:21:43.240
didn't specify it wanted them
when it registered as an observer.

00:21:43.290 --> 00:21:47.020
So for simple changes, settings,
these are just the old and

00:21:47.020 --> 00:21:49.130
new values of the property.

00:21:49.290 --> 00:21:51.960
For insertions, removals,
and replacements,

00:21:51.960 --> 00:21:55.020
these are actually arrays of
the objects that are inserted,

00:21:55.060 --> 00:21:56.560
removed, or replaced.

00:22:04.980 --> 00:22:08.820
So how do you,
what does your model class have to do for

00:22:08.830 --> 00:22:12.570
these key value observer notifications
to be sent out when properties

00:22:12.570 --> 00:22:14.720
in your model class are changed?

00:22:14.720 --> 00:22:18.250
Well, there's the pretty easy way
and the really easy way.

00:22:18.270 --> 00:22:20.060
This is the pretty easy way.

00:22:20.060 --> 00:22:25.760
You just have to surround the change
with indications of will change value

00:22:25.760 --> 00:22:29.020
for key and did change value for key.

00:22:30.650 --> 00:22:32.310
and in the case of too many,
that was for attributes

00:22:32.350 --> 00:22:33.520
and too many relationships.

00:22:33.530 --> 00:22:35.540
For too many relationships,
when collections of

00:22:35.540 --> 00:22:38.590
objects are being changed,
the methods you have to invoke

00:22:38.600 --> 00:22:39.600
are a little more detailed.

00:22:39.600 --> 00:22:44.440
Will change and you have to specify
removal replacement or insertion.

00:22:44.440 --> 00:22:47.060
The relevant indexes and then
again the key that identifies

00:22:47.110 --> 00:22:48.510
the too many relationship.

00:22:51.600 --> 00:22:56.680
So that's not so bad,
but we don't even want to force

00:22:56.680 --> 00:23:00.110
you to have to write that much
stuff into your model classes.

00:23:00.120 --> 00:23:02.770
So we're introducing a
feature called Automatic

00:23:02.770 --> 00:23:07.600
Key Value Observer Notification,
and it's actually on by default,

00:23:07.600 --> 00:23:09.540
so you don't even have to
do anything to turn it on.

00:23:09.540 --> 00:23:13.940
And what Automatic Key Value Observer
Notification means is whenever any

00:23:13.960 --> 00:23:19.690
of those key value coding methods,
like set value for key, is invoked,

00:23:19.740 --> 00:23:22.160
that will cause an
Automatic Key Value Observer

00:23:22.160 --> 00:23:23.390
Notification to be sent out.

00:23:23.400 --> 00:23:26.060
And not only that,
but indications of key value

00:23:26.210 --> 00:23:29.850
coding compliant methods result
in observer notifications.

00:23:31.630 --> 00:23:34.530
So not only does setValueForKey
messages cause observer

00:23:34.530 --> 00:23:38.440
notifications for that key,
but so do implementations of the

00:23:38.440 --> 00:23:41.860
accessor methods for that property.

00:23:41.860 --> 00:23:44.500
And not only do mutations of the
result of mutable array value

00:23:44.500 --> 00:23:50.540
for key cause notifications,
but when anybody sends an insert

00:23:50.820 --> 00:23:54.210
object in key at index or a
move object from key at index

00:23:54.270 --> 00:23:58.850
message to an observed container,
that will cause key value

00:23:58.850 --> 00:24:01.100
observer notifications.

00:24:01.280 --> 00:24:04.370
So you don't have to sprinkle "will
change value for key" and "did change

00:24:04.370 --> 00:24:07.280
value for key" all over your code.

00:24:07.280 --> 00:24:11.320
If your model objects access
their own values and each other's

00:24:11.320 --> 00:24:15.690
values consistently through key
value coding compliant methods,

00:24:15.690 --> 00:24:16.930
we'll do the rest.

00:24:17.120 --> 00:24:19.800
You know, simple set methods,
just keep using those.

00:24:19.800 --> 00:24:22.220
You know,
you might already be using those

00:24:22.220 --> 00:24:25.000
and it'll just automatically work.

00:24:25.000 --> 00:24:26.900
So and of course,
there are a couple of situations

00:24:26.900 --> 00:24:30.360
where you can't go through those
key value coding compliant methods.

00:24:30.360 --> 00:24:35.950
And even when you're using automatic
key value observer notification,

00:24:35.950 --> 00:24:38.120
the manual mode keeps working.

00:24:38.990 --> 00:24:43.120
So, key value binding is the third leg
of the tripod that all this sits on.

00:24:43.190 --> 00:24:45.900
It's a brand new API and it's
what ties it all together.

00:24:45.900 --> 00:24:50.110
It's what allows the value of an
object's property to be tied to the

00:24:50.110 --> 00:24:51.840
value of another object's property.

00:24:51.840 --> 00:24:56.290
And this API we're introducing
provides plenty of flexibility so

00:24:56.310 --> 00:25:00.840
that objects can support binding
options that we can't even anticipate.

00:25:00.840 --> 00:25:03.740
And key value binding,
when it's being used,

00:25:03.740 --> 00:25:07.380
that implies that typically
key value coding and key value

00:25:07.380 --> 00:25:09.490
observing are being used too.

00:25:10.400 --> 00:25:13.350
So this API,
this key value binding API is used

00:25:13.350 --> 00:25:15.500
at nib loading time typically.

00:25:15.580 --> 00:25:17.660
It can be used at other times of course.

00:25:17.750 --> 00:25:22.130
And views and controllers get hooked
up to controllers and model objects.

00:25:22.200 --> 00:25:26.130
Key value observer or key value
observers are registered with the

00:25:26.130 --> 00:25:28.810
things that they're observing.

00:25:28.810 --> 00:25:34.940
UI controls at that point take
responsibility for updating

00:25:35.020 --> 00:25:38.190
whatever they're bound to
whenever the user manipulates the

00:25:38.190 --> 00:25:40.220
value that they're presenting.

00:25:40.290 --> 00:25:43.840
And of course all the app kit
classes to which we're adding

00:25:43.840 --> 00:25:45.720
binding support do this.

00:25:47.840 --> 00:25:49.170
So this is what the method looks like.

00:25:49.170 --> 00:25:51.800
It's just bind to object
with key path options.

00:25:51.820 --> 00:25:54.980
And this is, again,
it's sent at nib loading time.

00:25:54.980 --> 00:25:58.460
You can use it at other times, too,
for more complicated situations.

00:25:58.460 --> 00:26:00.880
But for a while,
this will probably -- we don't

00:26:00.880 --> 00:26:04.900
expect too many uses of it,
you know, other than nib loading time,

00:26:04.900 --> 00:26:06.300
but it's there for you.

00:26:06.310 --> 00:26:08.090
So and, of course,
there's an unbind method, too.

00:26:13.570 --> 00:26:17.810
So the parameters are the name
of the binding and a lot of these

00:26:17.810 --> 00:26:22.960
look like key value coding keys,
but they don't necessarily have to be.

00:26:22.960 --> 00:26:29.190
And for example,
NSControl exposes a value binding and

00:26:29.250 --> 00:26:35.380
NSTextField exposes an editable binding,
things like text color too.

00:26:35.380 --> 00:26:38.420
The other parameters are
what is being bound to,

00:26:38.420 --> 00:26:42.360
the object that contains
the property to be bound to,

00:26:42.360 --> 00:26:44.590
and the key path of the property.

00:26:44.760 --> 00:26:47.730
And there's a dictionary
that takes options.

00:26:47.810 --> 00:26:51.340
So I think Andrea's covered most of
these options pretty well on Wednesday,

00:26:51.340 --> 00:26:54.600
but just to refresh your memory,
things like value transformer,

00:26:54.600 --> 00:26:58.960
something that can
manipulate the value for,

00:26:58.960 --> 00:27:03.920
you know, as part of more glue while
things are moving around.

00:27:03.920 --> 00:27:07.280
Placeholders,
the marker values that come out of

00:27:07.280 --> 00:27:12.270
controllers for complicated selection
situations become placeholders

00:27:12.270 --> 00:27:14.460
that are presented in the UI.

00:27:14.460 --> 00:27:17.400
And any options that are
specific to the binding.

00:27:21.920 --> 00:27:26.020
So, controller classes,
they're the first big

00:27:26.020 --> 00:27:29.790
clients of key value coding,
key value observing,

00:27:29.790 --> 00:27:31.140
and key value binding.

00:27:31.140 --> 00:27:36.330
There is an abstract superclass,
NSController, and three subclasses,

00:27:36.330 --> 00:27:40.770
NSArrayController, object controller,
and user defaults controller.

00:27:50.540 --> 00:27:56.010
So, NSArrayController is what you would
typically bind a table view to now.

00:27:56.140 --> 00:28:00.900
And NSArrayControllers have a too many
relationship named arranged objects.

00:28:00.900 --> 00:28:05.200
They're the set of objects to be
presented to the user after any sorting

00:28:05.200 --> 00:28:07.420
or filtering or whatever is done.

00:28:07.550 --> 00:28:10.020
On the other side of
the Arrange Controller,

00:28:10.020 --> 00:28:14.410
you can bind it, its array relationship,
to the too-many relationship

00:28:14.440 --> 00:28:15.900
of a model object.

00:28:15.900 --> 00:28:18.850
In our example, for example,
the graphics of a sketch

00:28:18.850 --> 00:28:23.040
document are what the Array
Controller we're using binds to.

00:28:23.040 --> 00:28:26.530
So key-value observer notifications
from the model object cause

00:28:26.530 --> 00:28:30.850
key-value observer notifications
to be sent to the table view,

00:28:30.890 --> 00:28:33.780
first to the Array Controller,
then to the table view.

00:28:33.780 --> 00:28:37.840
And the Array Controller just
doesn't pass them straight through.

00:28:37.840 --> 00:28:41.220
It updates them to take things
like sorting into account,

00:28:41.220 --> 00:28:45.740
because that's what the table view is
thinking about as arranged objects.

00:28:45.740 --> 00:28:48.020
And it also keeps the
selection up to date.

00:28:48.020 --> 00:28:53.930
When objects are removed or inserted,
it makes sure that the

00:28:53.990 --> 00:28:58.180
selection that's showing in the
table view still makes sense.

00:28:58.530 --> 00:29:02.150
And in addition to binding
an NSArray controller to a

00:29:02.150 --> 00:29:06.640
relationship of a model object,
you can just use the set content method

00:29:06.640 --> 00:29:11.660
that it publishes and let it manage
the life cycle of an array of objects.

00:29:11.720 --> 00:29:14.400
You don't have to bind it to anything.

00:29:14.400 --> 00:29:18.870
You can just let it do all the
work for simple situations.

00:29:20.370 --> 00:29:24.050
So the first big feature
that an NSArrayController

00:29:24.070 --> 00:29:26.790
has is selection management.

00:29:26.850 --> 00:29:30.800
You combine the selection indexes
of a table view to an array

00:29:30.800 --> 00:29:33.700
controller's selection indexes.

00:29:33.700 --> 00:29:36.940
And when you do that,
and you've also bound the

00:29:36.940 --> 00:29:43.500
selection properties of an
array controller to UI elements,

00:29:43.500 --> 00:29:48.020
whenever the selection changes,
key value observer notifications

00:29:48.020 --> 00:29:50.160
are sent to the UI elements.

00:29:50.300 --> 00:29:53.040
So, for example,
a color well that's bound

00:29:53.140 --> 00:29:57.110
to an array controller's
selection is notified whenever,

00:29:57.110 --> 00:29:59.950
in this example,
whenever the fill color of

00:29:59.950 --> 00:30:02.240
the selected graphics changes.

00:30:02.240 --> 00:30:07.040
And that might happen either because
the fill color of an individual

00:30:07.040 --> 00:30:10.880
graphic changed or the set of
selected graphics changed and all

00:30:10.880 --> 00:30:15.970
the different situations that would
cause that to be updated in the UI.

00:30:17.290 --> 00:30:24.080
NSRA Controller isn't just for binding,
it provides a real API of its own,

00:30:24.080 --> 00:30:26.830
you know,
big set of methods you get to call,

00:30:26.830 --> 00:30:29.040
and just a selection of them.

00:30:29.040 --> 00:30:33.860
NSRA Controller has built-in support
for user-friendly selection behavior.

00:30:33.860 --> 00:30:38.470
A few flags like avoids empty selection,
for when that's appropriate

00:30:38.470 --> 00:30:41.210
in a table view,
preserves selection so that

00:30:41.210 --> 00:30:44.980
things are being inserted and
removed around the selection,

00:30:44.980 --> 00:30:48.640
the selection stays still,
and selects inserted objects for

00:30:48.640 --> 00:30:50.320
when that's the right UI behavior.

00:30:51.810 --> 00:30:55.430
and for situations where the array
controller is being manipulated

00:30:55.430 --> 00:30:59.140
by some other code of your own,
you can get it all the things like the

00:30:59.140 --> 00:31:03.820
selection indexes using methods like set
selection indexes and add and remove.

00:31:06.280 --> 00:31:08.760
The other big feature that
NSArrayController supports

00:31:08.760 --> 00:31:10.960
right now is sorting.

00:31:10.980 --> 00:31:14.770
So you can bind the sort descriptors
of a table view to the sort

00:31:14.770 --> 00:31:17.680
descriptors of an array controller.

00:31:17.700 --> 00:31:22.700
So as the user is clicking in the table
column headers to change the sort order,

00:31:22.700 --> 00:31:28.280
the table view tells the controller that
the list of sort descriptors has changed.

00:31:28.280 --> 00:31:31.880
And when it does that, NSArrayController,
you know,

00:31:31.890 --> 00:31:36.750
actually does the sorting and sends
out key value observer notifications

00:31:36.750 --> 00:31:39.470
for the arranged objects relationship.

00:31:41.080 --> 00:31:42.490
So that was an NSArray controller.

00:31:42.500 --> 00:31:46.040
NSObject controller is also there,
and as its name implies,

00:31:46.040 --> 00:31:49.250
it controls a single
object instead of an array.

00:31:49.420 --> 00:31:56.620
So why is it useful to bind a
UI control to an object controller?

00:31:56.620 --> 00:31:59.390
It's because you can bind an
object controller to something

00:31:59.390 --> 00:32:01.330
that might be coming and going.

00:32:01.340 --> 00:32:05.360
It will observe a 2-1
relationship in another object.

00:32:05.400 --> 00:32:10.240
And it does clever things like
handling the situations where that

00:32:10.580 --> 00:32:16.990
2-1 related object disappears or
the type of it means that the bound

00:32:16.990 --> 00:32:19.820
to property is no longer applicable.

00:32:19.840 --> 00:32:22.910
So in general,
NSObjectController serves the purpose

00:32:22.910 --> 00:32:26.640
of generating these marker objects
that you heard about on Wednesday that

00:32:26.640 --> 00:32:30.200
get converted to placeholder
objects that show up in the UI,

00:32:30.240 --> 00:32:32.400
even in simple situations.

00:32:32.400 --> 00:32:36.430
So just as with NSArrayController,
for NSObjectController,

00:32:36.440 --> 00:32:40.000
it has a set content method,
so you can just let it own

00:32:40.070 --> 00:32:42.030
what's being presented.

00:32:48.930 --> 00:32:51.460
and the third new controller
is NSUserDefaultsController.

00:32:51.460 --> 00:32:54.700
We saw demonstrations
of that on Wednesday.

00:32:54.700 --> 00:32:59.500
And what you do is you bind the
values of UI controllers to the

00:32:59.500 --> 00:33:03.950
value of a UserDefaultsController,
you know, some subproperty of it,

00:33:03.950 --> 00:33:07.120
the key for which, you know,
you get to pick the name.

00:33:07.120 --> 00:33:09.170
So not only can you do that,
but you can observe

00:33:09.170 --> 00:33:10.680
NSUserDefaultsController.

00:33:10.700 --> 00:33:13.980
So other parts of your program that want
to know immediately when the preference

00:33:14.070 --> 00:33:18.080
has changed can just register themselves
as key value observers of those

00:33:18.190 --> 00:33:21.200
properties in NSUserDefaultsController.

00:33:21.200 --> 00:33:23.310
It also supports handy
support for setting the

00:33:23.310 --> 00:33:27.410
initial values of preferences,
you know, the factory defaults.

00:33:27.480 --> 00:33:32.680
And shared UserDefaultsController
is easy to get to in IB.

00:33:32.680 --> 00:33:36.270
You saw it being picked from
the pull-down menu in the

00:33:36.270 --> 00:33:39.240
Bindings Inspector on Wednesday.

00:33:39.240 --> 00:33:42.460
So let me show you some of
this code I'm talking about.

00:33:51.820 --> 00:33:57.900
So let's say that Sketch was so useful
that it was worth packaging up and making

00:33:57.900 --> 00:34:01.520
sure that it was properly reusable.

00:34:01.520 --> 00:34:05.100
The first thing we would do in
doing that is adding binding

00:34:05.100 --> 00:34:07.520
support to its graphic view.

00:34:07.530 --> 00:34:11.850
And here's a simple implementation
of the key value binding

00:34:11.860 --> 00:34:14.240
method that I told you about.

00:34:14.240 --> 00:34:17.520
This Sketch graphic view

00:34:17.760 --> 00:34:19.360
supports two binding names.

00:34:19.360 --> 00:34:22.940
One is graphics, the list of graphics to
be presented in the view,

00:34:23.070 --> 00:34:30.200
and selection indexes, just the,
you know, which graphics are selected.

00:34:30.200 --> 00:34:32.820
So the implementation is pretty simple.

00:34:32.820 --> 00:34:38.370
All it does is it just stores a
pointer to the container of the

00:34:38.410 --> 00:34:42.270
graphics that's being passed in,
the key path that was specified.

00:34:43.120 --> 00:34:49.010
And then it starts observing
that container of graphics.

00:34:50.740 --> 00:34:55.640
Both graphics that are being inserted
and graphics that are being removed

00:34:55.660 --> 00:34:57.740
so it can update the display.

00:34:57.740 --> 00:35:00.940
I'm sorry,
removed while that's happening.

00:35:00.940 --> 00:35:05.100
And the context it specifies,
just so it can identify why it's

00:35:05.100 --> 00:35:08.570
getting these observer notifications,
is just

00:35:09.220 --> 00:35:12.700
One of a handful, you know, simple ints.

00:35:12.700 --> 00:35:16.200
It really just needs them
for identification purposes.

00:35:18.320 --> 00:35:30.930
And for selection indexes,
it does a similar thing.

00:35:30.930 --> 00:35:30.930
It records the information about
what the graphic view is bound to

00:35:30.930 --> 00:35:30.930
and then adds itself as an observer.

00:35:30.930 --> 00:35:30.930
And then it updates the display.

00:35:34.040 --> 00:35:38.430
So Sketch's draw document,
for it to allow things to bind to it,

00:35:38.610 --> 00:35:42.600
it has to be key value coding and key
value observing compliant for this

00:35:42.600 --> 00:35:45.300
graphics relationship that it publishes.

00:35:45.300 --> 00:35:49.920
This is all it takes to do to be both
key value coding and key value observing

00:35:49.920 --> 00:35:52.320
compliant for that relationship.

00:35:52.320 --> 00:35:55.050
Just something that returns
an array of the graphics and a

00:35:55.180 --> 00:35:57.250
method that handles insertion.

00:35:57.250 --> 00:36:00.800
And in this case,
it still has to do its own undo support.

00:36:00.800 --> 00:36:03.780
And In addition to doing
the actual insertion,

00:36:03.780 --> 00:36:05.990
it also tells the graphic.

00:36:06.860 --> 00:36:11.530
will be joined by the panel of speakers.

00:36:14.570 --> 00:36:18.350
For individual graphics,
individual graphics also have to be key

00:36:18.350 --> 00:36:23.900
value observing compliant so that the
Sketch graphic view can observe them,

00:36:23.900 --> 00:36:29.240
can be told when they're changed
so it knows to update the screen.

00:36:30.780 --> 00:36:33.850
The first one I'll show
you here is set fill color.

00:36:33.850 --> 00:36:35.560
And I didn't have to change this at all.

00:36:35.630 --> 00:36:37.850
This is already key
value coding compliant.

00:36:37.850 --> 00:36:41.030
And because we're using automatic
key value observer notification,

00:36:41.030 --> 00:36:42.520
it's already KVO compliant.

00:36:42.520 --> 00:36:47.360
So no changes necessary for this one.

00:36:48.780 --> 00:36:51.770
For set stroke line width,
it does a little more.

00:36:51.770 --> 00:36:56.210
The line width of the sketch
graphic affects how large

00:36:56.210 --> 00:36:58.240
the graphic is on the screen.

00:36:58.240 --> 00:37:01.700
So it just manually says
when the line width changes,

00:37:01.700 --> 00:37:03.680
the drawing bounds change.

00:37:04.520 --> 00:37:06.740
And actually,
there's another feature that's going to

00:37:06.830 --> 00:37:10.500
be in Panther called set keys trigger
change notifications for dependent key.

00:37:12.420 --> 00:37:12.960
A mouthful.

00:37:12.960 --> 00:37:17.580
But this is what you can use to
indicate things like the drawing bounds.

00:37:18.340 --> 00:37:20.650
Of the sketch graphic
depends on the line width.

00:37:20.650 --> 00:37:23.660
So this will change value for
key and did change value for key.

00:37:24.400 --> 00:37:26.340
It won't even be necessary
in this situation,

00:37:26.370 --> 00:37:26.820
though.

00:37:26.820 --> 00:37:29.370
I should leave it in just so
you can see what it looks like.

00:37:30.620 --> 00:37:31.100
So.

00:37:38.490 --> 00:37:44.400
So we just run this and it's Sketch,
you know, Sketch, that's all.

00:37:44.400 --> 00:37:46.600
So it has an inspector panel.

00:37:46.600 --> 00:37:50.810
And here I'll select them all.

00:37:54.030 --> 00:37:56.800
So as you change things, that just works.

00:37:56.800 --> 00:38:01.870
So, and I'll show you the code for
the inspector panel in a second.

00:38:04.050 --> 00:38:15.640
is the owner of the software.

00:38:15.640 --> 00:38:15.900
The code for the Inspector Panel,
I think you can see this coming,

00:38:15.900 --> 00:38:15.900
is automatically updated on the screen.

00:38:16.460 --> 00:38:19.900
I'll show you some of
the bindings in the nib.

00:38:19.900 --> 00:38:20.620
This is pretty neat.

00:38:20.660 --> 00:38:23.640
IB gives you a nice summary of
what's going on with the bindings.

00:38:23.650 --> 00:38:28.030
So the checkbox here for controlling
whether or not the graphic is filled is

00:38:28.030 --> 00:38:32.780
just bound to the selection.drawAsFill
of an array controller.

00:38:33.560 --> 00:38:45.580
The fill color is bound
to selection.fillColor

00:38:45.580 --> 00:38:51.990
of an array controller.

00:38:51.990 --> 00:38:51.990
And actually, it's really not appropriate
to leave that enabled when

00:38:51.990 --> 00:38:51.990
that checkbox is not checked.

00:38:51.990 --> 00:38:51.990
So you can bind the enabled binding of
the color well to selection.drawsFill.

00:38:51.990 --> 00:38:51.990
So, and so on.

00:38:54.400 --> 00:39:01.400
So because of all the binding support
in the Inspector Panel and because,

00:39:01.400 --> 00:39:04.630
you know, NSRA controller is taking
care of everything for you,

00:39:04.630 --> 00:39:07.840
here is the source code
for Inspector Controller,

00:39:07.840 --> 00:39:09.280
which is no longer part of the project.

00:39:09.280 --> 00:39:11.210
I got to take all of it out.

00:39:11.230 --> 00:39:14.700
So this is not actually built
into the project anymore.

00:39:14.700 --> 00:39:18.610
So how many lines of code got to
go away because of that binding

00:39:18.610 --> 00:39:20.700
support in Inspector Panel?

00:39:20.700 --> 00:39:22.100
We won't count a copyright notice.

00:39:24.760 --> 00:39:26.100
So about 250 lines.

00:39:26.100 --> 00:39:28.100
So it has to go completely away.

00:39:38.320 --> 00:39:41.910
So the last thing I'll talk
about today is performance.

00:39:41.990 --> 00:39:46.820
Some of what we're doing to make sure
that the new technology is fast enough

00:39:46.820 --> 00:39:51.140
to use and some performance notes
about being key value coding compliant

00:39:51.140 --> 00:39:53.400
and key value observing compliant.

00:39:55.330 --> 00:39:59.470
So as I mentioned,
observation info is actually associated

00:39:59.470 --> 00:40:03.040
with each individual observed object.

00:40:03.040 --> 00:40:04.460
And that might sound expensive to you.

00:40:04.460 --> 00:40:07.220
You might imagine, oh, no,
that means that there's going to be

00:40:07.220 --> 00:40:09.580
twice as many objects in my system,
each object and then the

00:40:09.590 --> 00:40:11.440
observation info for each object.

00:40:11.440 --> 00:40:13.020
And no, that won't be the case.

00:40:13.020 --> 00:40:17.330
We're actually taking great care to make
sure that when multiple model objects

00:40:17.330 --> 00:40:22.360
are being observed in the same way,
same set of observers, same keys,

00:40:22.360 --> 00:40:26.240
same things like that,
the memory that's allocated to record

00:40:26.240 --> 00:40:31.710
that observation is shared between
the individual observed objects.

00:40:40.920 --> 00:40:43.710
Key value coding's performance
has always been very important

00:40:43.710 --> 00:40:47.390
and we're making sure we don't
ruin it with key value observing.

00:40:47.410 --> 00:40:53.120
So set value for key has a certain
cost to it and we're making sure

00:40:53.180 --> 00:40:56.890
that cost isn't going to go up
inappropriately when somebody is

00:40:57.260 --> 00:41:00.080
observing that key for that model object.

00:41:00.100 --> 00:41:03.340
So in the general rule we're following
is that we're providing good default

00:41:03.430 --> 00:41:07.080
implementations for everything,
but we're open to optimization,

00:41:07.080 --> 00:41:12.080
but we're leaving things open to
optimization for specific cases,

00:41:12.080 --> 00:41:13.850
which I'll show you.

00:41:15.280 --> 00:41:22.040
One piece of advice for you,
value for key, don't override it.

00:41:22.040 --> 00:41:25.800
There's a bunch of performance
tricks we can play as far as caching

00:41:25.800 --> 00:41:30.770
Objective-C runtime info goes,
but all those tricks are effectively

00:41:30.840 --> 00:41:34.060
defeated if value for key is overridden.

00:41:34.060 --> 00:41:38.510
So in general,
just stick to the pattern of

00:41:38.690 --> 00:41:42.330
implementing key value coding
compliant accessor methods.

00:41:46.900 --> 00:41:51.900
So I mentioned that we added the support
for implementing key value coding

00:41:51.900 --> 00:41:56.780
compliant methods of the form count
of key and object and key at index.

00:41:56.780 --> 00:42:01.830
Those are required if you're using that
pattern of giving access to relationship.

00:42:01.840 --> 00:42:07.180
If measurement says it's worth it,
you can also implement a method

00:42:07.180 --> 00:42:10.700
whose name follows this pattern,
get key range.

00:42:10.700 --> 00:42:16.400
So those first two methods correspond
roughly to the primitives of NSRA.

00:42:16.900 --> 00:42:20.570
And this next method corresponds
pretty much to another

00:42:20.570 --> 00:42:23.090
NSRA method that you can override.

00:42:26.590 --> 00:42:30.850
For mutable too-many relationships,
you have to implement these insert

00:42:30.850 --> 00:42:32.640
object and remove object methods.

00:42:32.640 --> 00:42:37.580
You can also implement a replace
method if it makes a difference in

00:42:37.580 --> 00:42:40.060
your too-many relationships case.

00:42:43.150 --> 00:42:47.740
So that's just two optional key
value coding compliant methods.

00:42:47.740 --> 00:42:51.010
We plan on adding a bunch
more in the future as we get

00:42:51.010 --> 00:42:55.690
more experience with this,
see how people are using it,

00:42:55.690 --> 00:43:00.280
and see the performance issues
that need to be dealt with.

00:43:00.280 --> 00:43:03.510
And for example,
we might add more optional key value

00:43:03.510 --> 00:43:07.890
coding compliant methods that let
you insert and remove ranges or work

00:43:07.970 --> 00:43:12.090
with the new NS index set class
that's being introduced in Panther.

00:43:12.200 --> 00:43:15.230
So and whatever we do though,
we don't intend to change the

00:43:15.230 --> 00:43:19.550
list of methods that's required
to be key value coding compliant.

00:43:22.230 --> 00:43:30.590
As far as using key value coding goes,
the advice is don't overuse it.

00:43:30.610 --> 00:43:34.100
So if you're converting code,
making it more generic,

00:43:34.100 --> 00:43:38.100
letting it support bindings,
and you're converting implementations

00:43:38.100 --> 00:43:41.940
of simple methods to use as a value for
key and mutable array value for key,

00:43:41.940 --> 00:43:45.400
that might be worth measuring
when you're all done with that.

00:43:45.980 --> 00:43:48.650
These methods are pretty fast
considering what they do,

00:43:48.650 --> 00:43:51.020
but they will always be
more expensive than a simple

00:43:51.020 --> 00:43:54.000
Objective-C message dispatch,
so you should check that.

00:44:05.480 --> 00:44:07.890
When you're using value for
key and getting an array back,

00:44:07.970 --> 00:44:12.030
or using mutable array value for key
and getting a mutable array back,

00:44:12.030 --> 00:44:16.580
what we're suggesting for now is
try to use it just like you would a

00:44:16.580 --> 00:44:19.350
normal NSArray or NS mutable array.

00:44:19.360 --> 00:44:23.210
Our intent is that the
performance characteristics will

00:44:23.210 --> 00:44:27.460
be pretty much the same as a
real NSArray or NS mutable array.

00:44:27.460 --> 00:44:30.770
So when that's not the case,
we want to hear about it.

00:44:31.430 --> 00:44:33.920
And if you see optimization
needs to be done,

00:44:33.920 --> 00:44:39.240
try and keep that in the model code and,
you know, where it will be more reusable.

00:44:42.630 --> 00:44:45.850
As far as efficient key value
observing compliance goes,

00:44:45.850 --> 00:44:49.740
there's a pair of methods that you
get to override if you need to,

00:44:49.740 --> 00:44:53.700
and I think typically you won't,
but they're called set observation

00:44:53.700 --> 00:44:55.200
info and observation info.

00:44:55.200 --> 00:44:59.070
So when large numbers of
objects are being observed,

00:44:59.170 --> 00:45:03.560
the observation info is actually
stored separately from the object

00:45:03.560 --> 00:45:05.700
and associated with a hash table.

00:45:05.700 --> 00:45:07.930
And that should be good
for most of the time,

00:45:07.930 --> 00:45:10.340
but there may be
situations where it's not.

00:45:10.920 --> 00:45:13.420
And when it's not,
we just want you to give us four bytes

00:45:13.420 --> 00:45:17.760
of instance variable space and let
us put the observation info there.

00:45:19.070 --> 00:45:22.090
and in general with key value observing,
take advantage of the fact that

00:45:22.090 --> 00:45:25.790
these observation notifications
are super fine granularity.

00:45:25.840 --> 00:45:27.890
It just doesn't say
that the object changed,

00:45:28.030 --> 00:45:31.000
it says that this property
of the object changed.

00:45:31.000 --> 00:45:34.010
So, you know,
don't cause key value observer

00:45:34.010 --> 00:45:38.510
notifications to be sent out
when nothing's actually changing.

00:45:40.810 --> 00:45:44.630
And on the other side of it,
don't observe unnecessarily.

00:45:44.700 --> 00:45:48.790
So the app kit views to which
binding support are being added take

00:45:48.960 --> 00:45:51.900
care not to observe gratuitously.

00:45:51.900 --> 00:45:54.890
The best example of this is table view.

00:45:54.900 --> 00:46:00.970
When a table view's row objects are bound
to too many relationships in a container,

00:46:01.020 --> 00:46:03.750
for example in an
NSArray controller's arranged objects,

00:46:03.750 --> 00:46:08.500
which will be typical, if the table view,
if there's like 100,000

00:46:08.500 --> 00:46:13.200
rows in the table,
it doesn't observe 100,000 objects,

00:46:13.200 --> 00:46:16.700
it just observes the 50 that
are visible at any one time.

00:46:16.700 --> 00:46:20.470
And we're taking care to make
sure that adding and removing one

00:46:20.470 --> 00:46:24.700
object as an observer of another is
fast enough to make that feasible.

00:46:24.700 --> 00:46:28.860
So there isn't any noticeable
overhead while you're scrolling a

00:46:28.860 --> 00:46:33.110
table view caused by the fact that
the table view is deregistering

00:46:33.110 --> 00:46:34.700
itself as an observer of objects.

00:46:34.700 --> 00:46:37.060
So the table view is just a
scroll of objects as they scroll

00:46:37.060 --> 00:46:39.700
off and registering itself as
an observer as they scroll on.

00:46:42.440 --> 00:46:45.640
So one more pair of methods
I haven't told you about yet.

00:46:45.640 --> 00:46:49.400
It's the bulk variant of
AddObserver and RemoveObserver.

00:46:49.400 --> 00:46:52.430
So the same set of parameters
as the AddObserver and the

00:46:52.430 --> 00:46:57.390
RemoveObserver I've already shown you,
but it's sent to an NSArray and

00:46:57.420 --> 00:47:00.400
it takes an index set,
identifying the objects

00:47:00.400 --> 00:47:03.400
to which KeyValueObserver
should be added or removed.

00:47:03.400 --> 00:47:07.290
So, and in general, you know,
there's a little bit of work that

00:47:07.290 --> 00:47:11.400
has to be done when one object adds
itself as an observer of another.

00:47:11.400 --> 00:47:14.400
With these methods, that little bit of
work is only done once.

00:47:14.400 --> 00:47:17.240
Basically,
the observed objects are just told,

00:47:17.420 --> 00:47:20.390
you know, here's your observation info,
hold on to it for me.

00:47:22.950 --> 00:47:24.400
So that's pretty much it.

00:47:24.400 --> 00:47:29.020
On Wednesday we introduced great new
technology to make User Interface

00:47:29.020 --> 00:47:30.820
Programming much easier.

00:47:30.820 --> 00:47:34.350
And today we talked about what
it takes for your custom model

00:47:34.350 --> 00:47:36.720
objects to hook into that.

00:47:36.720 --> 00:47:40.320
So it basically boils down to
being key value coding compliant

00:47:40.420 --> 00:47:42.160
and key value observing compliant.

00:47:42.160 --> 00:47:44.940
And we've worked pretty hard
to make sure that that's going

00:47:45.030 --> 00:47:46.260
to be fast and easy for you.

00:47:46.310 --> 00:47:51.820
So I hope you all give what
is on the WWC seat a try.

00:47:51.820 --> 00:47:53.990
It should work pretty well for you.

00:47:53.990 --> 00:47:56.880
And we hope you write great
custom maps with this.

00:47:56.920 --> 00:47:57.160
Thank you.

00:48:05.100 --> 00:48:43.600
[Transcript missing]

00:48:46.150 --> 00:48:47.090
Okie dokie.

00:48:47.180 --> 00:48:48.130
There we go.

00:48:48.130 --> 00:48:50.590
So,
John Galenzi is the person you want to

00:48:50.590 --> 00:48:54.160
talk to if you've got some information,
feedback, what have you,

00:48:54.160 --> 00:48:57.460
on all the Cocoa stuff that
you've seen at the show.

00:48:57.460 --> 00:49:02.470
If you have general API suggestions,
they should go to coco-feedback

00:49:02.470 --> 00:49:04.580
at group.apple.com.

00:49:04.580 --> 00:49:07.020
Those go directly to the
Cocoa engineering team.

00:49:07.020 --> 00:49:09.660
And if you have code level questions,
they should come to my team,

00:49:09.660 --> 00:49:12.260
developer technical support,
and we're happy to help you.

00:49:13.140 --> 00:49:16.290
If you need more information,
we've got no documentation.

00:49:24.520 --> 00:49:27.600
But feel free to check the headers.

00:49:27.600 --> 00:49:30.270
We will have documentation for Panther.
WEBVTT

00:00:20.140 --> 00:00:22.590
My name is Ben Trumbull and
I'm a senior engineer with the

00:00:22.670 --> 00:00:26.530
Development Technologies Group here
at Apple and Steve Minehr is going

00:00:26.540 --> 00:00:30.460
to be assisting us with some demos
and he's one of our fellow engineers.

00:00:34.860 --> 00:00:37.020
So this year we're going to try to
do something a little bit different.

00:00:37.020 --> 00:00:40.200
We're going to try to provide a brief
overview of a variety of topics,

00:00:40.200 --> 00:00:42.400
some topics that have
challenged you in the past.

00:00:42.480 --> 00:00:47.340
So last year we talked about some things
with validation and key value coding,

00:00:47.340 --> 00:00:51.500
and we're going to try to
just skip over all that stuff.

00:00:52.250 --> 00:00:54.100
So basically this session
isn't about anything.

00:00:54.100 --> 00:00:57.460
You can find the documentation
for the most part.

00:00:57.460 --> 00:01:00.840
And the documentation of particular
relevance to this particular topic,

00:01:00.870 --> 00:01:04.160
EOF, is going to be the 5.2
Delta documentation,

00:01:04.160 --> 00:01:07.820
and I believe they call it
What's New in 5.2 on the website,

00:01:07.860 --> 00:01:09.550
and the EOF Developer Guide.

00:01:09.830 --> 00:01:12.600
So can I have a show of hands
of who's actually read the

00:01:12.600 --> 00:01:14.540
republished EOF Developer Guide?

00:01:14.700 --> 00:01:18.110
It was redone, rewritten this February?

00:01:19.550 --> 00:01:21.550
So Brent Shank and all the
people in TechPubs did a

00:01:21.550 --> 00:01:23.180
fantastic job rewriting this.

00:01:23.180 --> 00:01:25.700
It includes most of the material.

00:01:28.080 --> 00:01:30.260
It includes most of the material
from last year's advanced session,

00:01:30.260 --> 00:01:33.800
so we're going to have
to keep pushing further.

00:01:33.900 --> 00:01:36.630
So when I said a brief overview,
we've got about five slides for

00:01:36.630 --> 00:01:38.000
all the multithraded programming.

00:01:38.000 --> 00:01:40.080
This is going to go pretty quick.

00:01:40.100 --> 00:01:43.350
It's really more about identifying
obstacles and getting you

00:01:43.350 --> 00:01:44.600
to ask the right questions.

00:01:44.600 --> 00:01:48.750
And then you can go back to
documentation or community resource,

00:01:48.790 --> 00:01:52.600
one of the mailing lists,
to get more information.

00:01:52.740 --> 00:01:55.900
So first on our agenda is
memory management in EOF.

00:01:57.160 --> 00:01:59.520
We're going to assume you know
something about how garbage collection

00:01:59.520 --> 00:02:02.700
works in Java and the difference
between strong and weak references.

00:02:02.700 --> 00:02:06.500
Some interesting point is you can create
your own subclass for weak reference,

00:02:06.500 --> 00:02:07.300
and EOF does this.

00:02:07.300 --> 00:02:09.300
It's a handy little trick.

00:02:09.300 --> 00:02:12.790
EOF also uses a mechanism called faults,
and faults are Enterprise Objects

00:02:12.790 --> 00:02:14.330
that have not been initialized yet.

00:02:14.620 --> 00:02:18.810
So they're lazy initialization at work,
and they provide assistance in

00:02:18.810 --> 00:02:22.300
memory management as the boundary
for the active object graph.

00:02:22.300 --> 00:02:26.210
So everything beyond the fault
is not fetched from the database.

00:02:26.410 --> 00:02:30.970
Deferred faults are a special kind of
fault used in too many relationships,

00:02:30.970 --> 00:02:33.300
and they're significantly more
memory efficient because until

00:02:33.300 --> 00:02:36.300
you touch them the first time,
they are empty.

00:02:36.300 --> 00:02:37.300
They don't have anything.

00:02:37.300 --> 00:02:38.300
They're just a little fault.

00:02:38.300 --> 00:02:41.550
And then they grow to expand to
include one fault for each object

00:02:41.580 --> 00:02:43.300
in the too many relationship.

00:02:43.380 --> 00:02:46.160
And finally, shared ending contexts,
another mechanism you can

00:02:46.160 --> 00:02:47.300
use to reduce your memory.

00:02:47.300 --> 00:02:51.300
And it's probably best to think of
these as read-only object stores,

00:02:51.330 --> 00:02:53.610
and we'll talk more about that later.

00:02:54.940 --> 00:02:58.280
So a lot of changes went into
5.2 sort of under the hood,

00:02:58.420 --> 00:03:00.860
so hopefully not too
much API impact on you,

00:03:00.900 --> 00:03:02.980
but a lot of things did happen.

00:03:03.040 --> 00:03:06.410
And the first is a lot of complaints
about editing contexts using strong

00:03:06.420 --> 00:03:08.400
references to their Enterprise Objects.

00:03:08.420 --> 00:03:09.530
This has been changed.

00:03:09.700 --> 00:03:12.090
Enterprise Objects are now
held with weak references,

00:03:12.090 --> 00:03:15.000
so the garbage collector can come
along and just start pruning the

00:03:15.000 --> 00:03:19.060
object graph of things that you're
no longer accessing directly.

00:03:19.110 --> 00:03:23.610
Only modified objects,
so things that are inserted, deleted,

00:03:23.810 --> 00:03:26.190
or updated are still retained.

00:03:26.400 --> 00:03:29.910
And Enterprise Objects have a reference
back to their editing context now

00:03:29.910 --> 00:03:33.400
and it will hold the editing context
in memory until it's done using it.

00:03:33.400 --> 00:03:37.470
So you have to be careful not to have
any Enterprise Objects floating around,

00:03:37.810 --> 00:03:41.400
but this is better than previous
years where if the editing context

00:03:41.400 --> 00:03:44.030
got garbage collected first,
the Enterprise Object was

00:03:44.030 --> 00:03:45.530
no longer very useful.

00:03:46.490 --> 00:03:50.620
Consequence of these changes
is that the registered objects

00:03:50.630 --> 00:03:52.640
method is not really useful.

00:03:52.640 --> 00:03:55.290
Since these objects are going to
be pruned just sort of randomly

00:03:55.290 --> 00:03:57.810
by the garbage collecting thread,
you can't account on

00:03:57.810 --> 00:03:59.300
anything still being there.

00:03:59.380 --> 00:04:02.220
I know people in the past have
bound their woke components

00:04:02.220 --> 00:04:06.020
to this method to just grab
everything in the editing context.

00:04:06.020 --> 00:04:09.160
You really are never going
to know what you get.

00:04:09.160 --> 00:04:10.520
If you want to lock an
object graph into memory,

00:04:10.520 --> 00:04:13.300
you can use set retains registered
objects on an editing context.

00:04:13.320 --> 00:04:16.690
And you can only do this when the editing
context doesn't have any objects in it,

00:04:16.870 --> 00:04:18.810
but that will change the way
it works and it will hold

00:04:18.850 --> 00:04:20.340
everything with strong reference.

00:04:20.550 --> 00:04:22.710
And shared editing contexts
always use strong references,

00:04:22.710 --> 00:04:24.220
otherwise they wouldn't be very useful.

00:04:26.460 --> 00:04:27.700
So a bit about faulting.

00:04:27.700 --> 00:04:30.360
Something many people don't realize
is that the size of your fault

00:04:30.500 --> 00:04:34.590
is the same as the size of the
Enterprise Object that it represents.

00:04:34.870 --> 00:04:37.350
Deferred faults, as I mentioned earlier,
are significantly more memory

00:04:37.350 --> 00:04:40.200
efficient than the too many
relationships they represent.

00:04:40.260 --> 00:04:43.730
And Enterprise Objects can extend
EO Generic Record to transparently

00:04:43.740 --> 00:04:45.750
inherit the deferred faulting feature.

00:04:45.830 --> 00:04:48.300
If you subclass directly
from EO Custom Object,

00:04:48.300 --> 00:04:52.360
you're not going to get
deferred faulting by default.

00:04:52.690 --> 00:04:54.230
And Awake from Fetch and
Awake from Insertion.

00:04:54.240 --> 00:04:57.480
So this is on the faulting page
because faults are constructed the

00:04:57.480 --> 00:04:59.120
same way Enterprise Objects are.

00:04:59.170 --> 00:05:01.060
And this is due to strong typing in Java.

00:05:01.160 --> 00:05:03.480
So we've got to create a new
Enterprise Object when we're

00:05:03.480 --> 00:05:05.020
creating a fault and vice versa.

00:05:05.080 --> 00:05:08.090
This means that if you have a
constructor on your Enterprise Object,

00:05:08.100 --> 00:05:09.880
you're going to start doing
things while we're faulting.

00:05:10.070 --> 00:05:11.330
This is bad.

00:05:11.340 --> 00:05:13.560
It defeats the purpose
of lazy initialization.

00:05:13.610 --> 00:05:16.570
In addition, when the fault gets fired,
that's when EOF thinks that it's

00:05:16.570 --> 00:05:18.330
going to finish the initialization.

00:05:18.410 --> 00:05:21.950
So it's going to overwrite stuff and
it might just ignore things completely.

00:05:22.060 --> 00:05:25.680
And typically,
at the time that the constructor in an

00:05:25.720 --> 00:05:30.170
Enterprise Object is invoked by the VM,
that object is not inserted

00:05:30.290 --> 00:05:31.100
into the editing context.

00:05:31.100 --> 00:05:33.780
So that means any changes you
make in there aren't going to get

00:05:33.780 --> 00:05:35.020
noticed by the editing context.

00:05:35.020 --> 00:05:37.020
And that breaks pretty much everything.

00:05:37.020 --> 00:05:40.520
So you really,
really have to use Awake from

00:05:40.520 --> 00:05:43.020
Fetch and Awake from Insertion.

00:05:44.430 --> 00:05:47.110
So some basic memory optimizations.

00:05:47.240 --> 00:05:49.830
Blobs and clobs should be
factored into their own tables and

00:05:49.840 --> 00:05:51.300
accessed through a relationship.

00:05:51.410 --> 00:05:54.850
And then the relationship can be
faulted and keep the in-memory

00:05:54.850 --> 00:05:57.090
object graph as small as possible.

00:05:57.190 --> 00:05:59.980
Some other things that some people do,
you know, you don't want to

00:05:59.980 --> 00:06:04.150
over-optimize too early,
but having too many relationships not

00:06:04.150 --> 00:06:06.710
be a class property can be very helpful.

00:06:06.860 --> 00:06:09.080
So there's a lot of overhead
in managing a relationship,

00:06:09.080 --> 00:06:12.090
or there can be,
particularly for a very large too many.

00:06:12.180 --> 00:06:16.690
So if you don't need both sides of the
relationship between two related EOs,

00:06:16.790 --> 00:06:19.990
you can have it be a unidirectional
relationship instead of bidirectional.

00:06:20.070 --> 00:06:23.660
And you can put rarely used attributes
across the relationship the same

00:06:23.660 --> 00:06:25.600
way you would with a blob or a clob.

00:06:25.670 --> 00:06:27.770
And you can replace the too
many entirely with a fetch.

00:06:27.910 --> 00:06:31.700
And one of the nice things about this
is it can be vended as a Java method.

00:06:31.720 --> 00:06:34.080
And to key value coding
and the rest of EOF,

00:06:34.080 --> 00:06:37.610
it looks exactly like a property
on your Enterprise Object.

00:06:37.800 --> 00:06:41.700
But instead, it can be a hand-coded fetch
that's doing something special.

00:06:41.700 --> 00:06:42.920
Thank you.

00:06:43.900 --> 00:06:46.000
So shared editing context.

00:06:46.040 --> 00:06:50.430
I like to think of this as probably one
of the most badly named classes in EOF.

00:06:50.430 --> 00:06:52.660
And it's not that it's
too long or too short,

00:06:52.810 --> 00:06:55.430
and it's not that technically
it's not a shared editing context.

00:06:55.450 --> 00:06:57.370
It is.

00:06:58.380 --> 00:06:58.390
Unfortunately,

00:06:58.680 --> 00:07:01.780
The best behavior is a
read-only object store.

00:07:02.130 --> 00:07:04.440
It's not really an editing context,
and if you try to use it

00:07:04.440 --> 00:07:07.280
just like an editing context,
you're going to run into some problems.

00:07:07.400 --> 00:07:09.990
And if you try to use it as a
shared area of read/write EOs,

00:07:09.990 --> 00:07:12.440
you're also going to
run into some problems.

00:07:12.530 --> 00:07:17.350
It's best is using read-only EOs in here,
and then you can modify other EOs related

00:07:17.350 --> 00:07:20.080
to them in your regular editing contexts.

00:07:20.170 --> 00:07:23.110
The main advantage of this,
despite those complications,

00:07:23.200 --> 00:07:27.540
is you get to reuse the memory for
the entire Enterprise Object instead

00:07:27.540 --> 00:07:30.320
of just the row-level snapshots,
which is what normally happens

00:07:30.320 --> 00:07:31.680
between editing contexts.

00:07:31.750 --> 00:07:34.810
And it's very important not to
have outgoing relationships.

00:07:34.880 --> 00:07:38.280
So if you have a relationship
coming from a shared EO going into

00:07:38.410 --> 00:07:42.100
an EO in a regular editing context,
EOF will be very unhappy with you.

00:07:42.220 --> 00:07:44.770
And shared editing contexts and
regular editing contexts should all

00:07:44.770 --> 00:07:46.330
use the same object store coordinator.

00:07:46.500 --> 00:07:49.600
So we'll touch more on that in a sec.

00:07:50.550 --> 00:07:52.220
So you've got a million EOs.

00:07:52.220 --> 00:07:56.120
The most important advice I can give you
is to divide the operations into batches.

00:07:56.170 --> 00:07:59.730
Most users are not going to interact with
a million EOs at the same time anyway,

00:07:59.730 --> 00:08:01.500
and if they're browsing
through a result set,

00:08:01.500 --> 00:08:04.840
they're probably only going to browse
the first few sets before they get bored.

00:08:04.950 --> 00:08:07.460
So that's the best advice.

00:08:07.510 --> 00:08:09.460
You can use raw rows,
and you can fetch back just the

00:08:09.460 --> 00:08:12.590
primary keys or some other subset
of the EO so you don't have to

00:08:12.620 --> 00:08:14.160
bring the full EO into memory.

00:08:14.200 --> 00:08:17.340
And Project Wonder already has
some of this stuff done for you,

00:08:17.340 --> 00:08:20.920
so you can use their fetch specification
batch iterator to do batching,

00:08:21.200 --> 00:08:23.680
and it basically actually
incorporates all these ideas,

00:08:23.770 --> 00:08:26.780
and it gives tons of
stuff in Project Wonder.

00:08:28.000 --> 00:08:30.300
So a more advanced technique
that you can use is you can

00:08:30.300 --> 00:08:33.140
intercept the rows as they're
being fetched at the adapter level.

00:08:33.260 --> 00:08:36.090
And you can use a custom
JDBC channel subclass.

00:08:36.090 --> 00:08:39.000
You can override fetchRow,
and as you're going through,

00:08:39.060 --> 00:08:40.740
you can use a row and then throw it away.

00:08:40.880 --> 00:08:45.240
And in this way, EOF will not keep all of
the results set in memory.

00:08:45.370 --> 00:08:46.950
And Dave Newman,
who was one of the speakers

00:08:46.970 --> 00:08:49.620
for the previous session,
actually has done this and got an order

00:08:49.620 --> 00:08:53.030
of magnitude improvement in peak memory
use for one of his reporting tools.

00:08:53.060 --> 00:08:55.220
So it works.

00:09:00.490 --> 00:09:04.830
Okay,
so next on our agenda is data freshness.

00:09:04.830 --> 00:09:09.770
EOF is a big cache, and it's caching the
rows from your database.

00:09:09.920 --> 00:09:13.380
And editing contexts build an object
graph mapping on top of this cache.

00:09:13.400 --> 00:09:17.630
So data freshness is about when and
how to refresh those cache lines,

00:09:17.730 --> 00:09:19.770
and in EOF we call them snapshots.

00:09:20.110 --> 00:09:22.730
Refaulting is about taking an
Enterprise Object and turning it

00:09:22.730 --> 00:09:24.300
back into an uninitialized fault.

00:09:24.470 --> 00:09:27.540
This is an important mechanism for
saving memory as it prunes entire

00:09:27.540 --> 00:09:29.860
branches out of the object graph.

00:09:30.010 --> 00:09:31.820
Invalidating is a little
bit like refaulting,

00:09:31.820 --> 00:09:33.340
and a lot of people get the two mixed up.

00:09:33.690 --> 00:09:37.750
The main difference is unlike
gently shearing the object graph,

00:09:37.750 --> 00:09:39.580
you're using a chainsaw.

00:09:39.640 --> 00:09:42.720
Fetch timestamps measure
staleness for those snapshots,

00:09:42.720 --> 00:09:46.370
and the EO database object is the
cache object that you can work with,

00:09:46.690 --> 00:09:49.630
and you can get at it through
the EO database context through

00:09:49.630 --> 00:09:51.530
your object store coordinator.

00:09:53.390 --> 00:09:56.330
So just to really kind of
home in on why refaulting is

00:09:56.420 --> 00:09:59.550
much better than invalidation,
refaulting affects only

00:09:59.550 --> 00:10:00.800
one editing context.

00:10:00.860 --> 00:10:03.300
There are no notifications,
no effect on other editing

00:10:03.300 --> 00:10:05.540
contexts or other user sessions.

00:10:05.680 --> 00:10:08.600
The existing snapshot gets
reused if it's fresh enough,

00:10:08.600 --> 00:10:10.650
and there's no trip back to the database.

00:10:10.730 --> 00:10:13.270
So it's much more gentle
on your performance.

00:10:13.450 --> 00:10:16.290
Now, if the snapshot's too stale,
then it will have to go

00:10:16.290 --> 00:10:18.400
back to the database,
refetch that row,

00:10:18.400 --> 00:10:20.950
and get you something that's fresh
enough for your configuration.

00:10:21.020 --> 00:10:23.500
and that will post a notification.

00:10:24.590 --> 00:10:26.110
Invalidating affects the whole stack.

00:10:26.170 --> 00:10:29.210
It affects everyone using
that object store coordinator.

00:10:29.590 --> 00:10:33.630
Editing context can lose changes for that
object because you've just smashed it,

00:10:33.730 --> 00:10:37.030
and the snapshot will be discarded,
and the next time any editing

00:10:37.030 --> 00:10:39.500
context touches that object,
which is now a fault,

00:10:39.500 --> 00:10:41.900
a round trip to the database will occur.

00:10:43.160 --> 00:10:46.740
Now, sometimes you do have to invalidate,
so some things to keep in mind.

00:10:46.790 --> 00:10:50.140
You really don't want to end up in
a position where you've basically

00:10:50.180 --> 00:10:51.790
invalidated a lot of objects.

00:10:51.790 --> 00:10:53.940
They're now faults,
and you're going through and you're

00:10:53.940 --> 00:10:56.830
telling EOF one at a time and firing
those faults to go back to the database,

00:10:57.000 --> 00:10:59.110
because that's going to cause thousands
of round trips to the database.

00:10:59.330 --> 00:11:00.920
That's something you want to avoid.

00:11:00.980 --> 00:11:04.690
Batch faulting in your relationship
can help immorality some of this,

00:11:04.690 --> 00:11:07.730
but really a manual fetch with
an object to fetch specification

00:11:07.830 --> 00:11:09.060
is probably the best way to go.

00:11:09.230 --> 00:11:11.700
You invalidate a set of
objects that you know about,

00:11:11.860 --> 00:11:14.470
and then you go and you do a
fetch for the working set that

00:11:14.520 --> 00:11:16.130
you expect to be using next.

00:11:16.200 --> 00:11:18.480
And this way,
you're going to minimize faulting.

00:11:18.660 --> 00:11:21.830
And prefetch and keypass are
extremely useful for doing this and

00:11:21.880 --> 00:11:23.860
grabbing a whole lot of data at once.

00:11:25.040 --> 00:11:28.270
So Refresh Object,
I believe this is introduced in 5.1.

00:11:28.410 --> 00:11:30.090
It's a smarter refault object.

00:11:30.190 --> 00:11:33.350
It merges changes back into
the Enterprise Object in

00:11:33.350 --> 00:11:35.000
that editing context.

00:11:35.130 --> 00:11:38.350
So it'll pick up any changes
that occurred to the snapshot.

00:11:38.450 --> 00:11:41.080
It skips over inserts,
which can't be refaulted,

00:11:41.090 --> 00:11:44.580
and it reuses the existing row
snapshot unless it's too stale.

00:11:46.280 --> 00:11:49.370
So the most important thing to understand
about fetch timestamps is they just

00:11:49.370 --> 00:11:50.840
don't work the way you want them to.

00:11:50.840 --> 00:11:54.890
Fetch timestamp lag is relative,
and it defaults to one hour.

00:11:54.900 --> 00:11:57.490
And you're not really going to have
a whole lot of interaction with this.

00:11:57.500 --> 00:12:01.140
But what this means is when a
new edit context gets created,

00:12:01.140 --> 00:12:05.380
its fetch timestamp gets
set to one hour ago.

00:12:05.380 --> 00:12:07.880
And that's all the data
it considers fresh enough.

00:12:07.900 --> 00:12:10.370
So those fetch timestamps
are always absolute,

00:12:10.370 --> 00:12:13.560
like June 25th,
4.15 p.m., if we created an

00:12:13.560 --> 00:12:15.320
edit context right about now.

00:12:16.200 --> 00:12:18.640
And no matter how long the
edit context stays around,

00:12:18.670 --> 00:12:21.640
say three days in your application,
it's going to consider all

00:12:21.750 --> 00:12:25.510
the data since June 25th,
4.15 p.m., to be fresh enough.

00:12:25.580 --> 00:12:27.320
Most people don't want that.

00:12:27.380 --> 00:12:29.270
And right now,
you're going to have to work

00:12:29.340 --> 00:12:32.170
around it by periodically
resetting the fetch timestamp.

00:12:34.540 --> 00:12:36.350
A good place to do that
is in session awake.

00:12:36.520 --> 00:12:38.470
That's a great time, a callback.

00:12:38.580 --> 00:12:40.770
You know the user is now
interacting with that default

00:12:40.770 --> 00:12:42.330
session editing context again.

00:12:42.450 --> 00:12:46.700
You can also refresh rows with a
fetch specification and setting

00:12:47.030 --> 00:12:49.070
the setRefreshedObject flag.

00:12:49.390 --> 00:12:51.340
And did I mention prefetching?

00:12:51.360 --> 00:12:54.130
It's a great way to get
lots of data at once.

00:12:55.590 --> 00:12:57.620
So another advanced technique,
and I haven't seen very

00:12:57.620 --> 00:12:58.420
many people do this.

00:12:58.610 --> 00:13:02.600
The EOF database is your snapshot cache,
and EOF is a big cache.

00:13:02.770 --> 00:13:06.440
So by directly manipulating this object,
you can do some pretty cool things

00:13:06.440 --> 00:13:08.160
and really improve performance.

00:13:08.280 --> 00:13:09.340
You can cheat at faulting.

00:13:09.340 --> 00:13:12.620
If you've gotten a row back from
the database using raw rows or one

00:13:12.620 --> 00:13:16.860
customer used some custom JDBC code,
writing raw JDBC code,

00:13:16.860 --> 00:13:20.490
he implemented a cursor,
pulled that stuff back,

00:13:20.490 --> 00:13:23.140
and now he sets those rows into EOF.

00:13:23.140 --> 00:13:26.240
He records the snapshot,
calls fault for global ID,

00:13:26.240 --> 00:13:27.630
and he's good to go.

00:13:27.650 --> 00:13:29.740
You can also preflight
a too-many relationship.

00:13:29.780 --> 00:13:32.820
This is particularly
useful for inserted EOs.

00:13:32.820 --> 00:13:35.870
So inserted EOs begin life
with a too-many fault,

00:13:35.870 --> 00:13:39.060
and most of the time, that fault,
when it goes to the database,

00:13:39.170 --> 00:13:43.260
there aren't going to be any records
there because it's a brand-new EO.

00:13:43.260 --> 00:13:44.680
Sometimes it could be if
you've got multiple writers,

00:13:44.680 --> 00:13:47.480
but for the most part,
those relationships tend to be empty.

00:13:47.610 --> 00:13:48.840
But EOF doesn't know that.

00:13:48.840 --> 00:13:52.840
So the first time you touch that fault,
you modify that newly saved object.

00:13:52.840 --> 00:13:54.260
It's going to fire.

00:13:54.260 --> 00:13:56.870
It's going to go to the database,
and it could be -- there could

00:13:56.890 --> 00:14:00.690
be a lot of records there,
so you might want to just skip that.

00:14:00.700 --> 00:14:04.060
And you can use record snapshot
for source global ID to do that.

00:14:04.060 --> 00:14:08.340
And to refresh a too-many snapshot,
a lot of people ask questions about this,

00:14:08.340 --> 00:14:10.770
so pass in null,
and that will blow away the snapshot

00:14:10.890 --> 00:14:14.890
for that too-many relationship,
and then it will be refetched.

00:14:14.900 --> 00:14:17.700
And you have to remember to lock and
unlock the object store coordinator,

00:14:17.830 --> 00:14:21.130
and that's the one that's associated
with the database context that's

00:14:21.160 --> 00:14:22.980
using this EO database object.

00:14:25.510 --> 00:14:30.560
Okay, so we're going to spend some
time with optimistic locking now.

00:14:30.560 --> 00:14:33.540
There's an entire chapter on optimistic
locking in the new EOF Developer Guide,

00:14:33.810 --> 00:14:36.610
Update Strategies,
and mostly the subject is

00:14:36.650 --> 00:14:39.730
about dealing with multiple
writers affecting the same data.

00:14:42.600 --> 00:14:44.720
Basically, it's about cache validity
and what to do when multiple

00:14:44.720 --> 00:14:46.000
people change the same thing.

00:14:46.000 --> 00:14:48.130
And this can happen when
you've got deployments with

00:14:48.130 --> 00:14:49.830
multiple WebObjects instances.

00:14:49.920 --> 00:14:52.090
If you're using a single application,
you've got multiple

00:14:52.100 --> 00:14:53.840
EO Objects or coordinators,
they're going to have their

00:14:53.860 --> 00:14:55.660
own channels to the database,
and they can make changes

00:14:55.660 --> 00:14:56.980
that interact with each other.

00:14:57.060 --> 00:14:59.450
Or you have external writers,
someone who's got an admin

00:14:59.450 --> 00:15:03.040
app that's doing raw SQL or
something outside your control.

00:15:05.040 --> 00:15:07.240
So the material we just talked
about in data freshness is pretty

00:15:07.240 --> 00:15:08.920
important in avoiding this problem.

00:15:08.950 --> 00:15:11.000
Obviously,
if you don't ever modify stale data,

00:15:11.000 --> 00:15:13.170
you're going to be much better off.

00:15:13.350 --> 00:15:17.690
So you can tweak your fetch timestamps
to keep the data fresh enough.

00:15:17.700 --> 00:15:19.860
If you keep the data too fresh,
then you have performance problems as

00:15:19.860 --> 00:15:21.870
you're always going back to the database.

00:15:21.950 --> 00:15:26.110
And you can also implement code to
propagate a distributed notification.

00:15:26.680 --> 00:15:28.290
However,
EOF does not at this time implement

00:15:28.290 --> 00:15:29.670
distributed notifications itself.

00:15:29.890 --> 00:15:31.850
There are a variety of
third-party solutions,

00:15:31.930 --> 00:15:34.850
and here are two, one from Wirehose and
one from Project Wonder,

00:15:35.020 --> 00:15:38.180
and they're both free,
so you can check those out.

00:15:40.870 --> 00:15:44.140
Recovering from this problem,
basically you have to catch an

00:15:44.190 --> 00:15:46.000
EO General Adapter exception.

00:15:46.000 --> 00:15:47.690
We're going to have a demo and
I'll show you where that is.

00:15:47.800 --> 00:15:49.900
It's also in the developer guide.

00:15:49.990 --> 00:15:53.290
But basically that's your hook for
implementing a recovery specific to your

00:15:53.290 --> 00:15:57.100
application because EOF doesn't know
if you want to have the first save win,

00:15:57.100 --> 00:15:58.990
the last save win,
you want to do a merge.

00:15:59.220 --> 00:16:01.840
It's really specific
to what you're doing.

00:16:02.610 --> 00:16:05.640
The EO adapter operation in
the User Info Dictionary,

00:16:05.640 --> 00:16:08.330
that exception,
is one of the most important parts.

00:16:08.360 --> 00:16:11.320
It's got the attempted row
changes and operation type code,

00:16:11.400 --> 00:16:14.060
so inserted, updated, deleted, or locked.

00:16:14.250 --> 00:16:19.140
And then the EO database operation has
a reference to the Enterprise Object as

00:16:19.140 --> 00:16:21.900
well as the out-of-sync stale snapshot.

00:16:22.010 --> 00:16:24.360
And as you're recovering from
an optimistic locking exception,

00:16:24.390 --> 00:16:28.140
keep in mind that refaulting is going to
remove that EO from the updated lists.

00:16:28.180 --> 00:16:31.250
So if it's a deleted or updated object,
it's just going to get refaulted

00:16:31.250 --> 00:16:33.890
and the editing context is
going to forget about that.

00:16:34.010 --> 00:16:37.480
And you can't refault a newly
inserted Enterprise Object.

00:16:37.600 --> 00:16:42.200
So it's best to basically pull out
the deltas from the Enterprise Object,

00:16:42.240 --> 00:16:44.370
refault it,
and then apply those deltas again.

00:16:44.450 --> 00:16:47.740
And in the process of
applying those deltas again,

00:16:47.740 --> 00:16:52.320
the editing context will notice
that the object has changed again.

00:16:54.490 --> 00:16:57.050
So we're going to go to demo two now.

00:16:57.120 --> 00:17:01.980
And something new in WebObjects 5.2
is multiple channels to the database.

00:17:01.980 --> 00:17:03.450
You can do simultaneous operations.

00:17:03.490 --> 00:17:07.000
We're going to talk a little
bit more about this later.

00:17:07.620 --> 00:17:11.530
But basically, you're just creating your
own object store coordinator,

00:17:11.530 --> 00:17:13.460
and we've got a new thread here.

00:17:13.480 --> 00:17:17.480
And I'm doing something pretty simple
just to show you how to recover from

00:17:17.480 --> 00:17:19.060
an optimistic locking exception.

00:17:19.140 --> 00:17:23.690
And in my application constructor,
I just create this new thread.

00:17:25.850 --> 00:17:29.000
So first you're going to want
to do the save and catch the

00:17:29.000 --> 00:17:30.460
general adapter exception.

00:17:30.560 --> 00:17:32.700
And then you're going to have to
check the user info dictionary

00:17:32.930 --> 00:17:35.890
to find out whether or not it's
actually an optimistic locking

00:17:35.890 --> 00:17:38.080
exception or something else entirely.

00:17:42.780 --> 00:17:48.400
So you can do that by getting this key
out of the dictionary and then checking.

00:17:48.490 --> 00:17:49.840
Handy little method.

00:17:49.840 --> 00:17:53.160
This is documented,
but it is a little obtuse,

00:17:53.200 --> 00:17:56.840
so I'll go through all of it.

00:17:56.840 --> 00:17:59.240
When you handle all of this,
you want to get the adapter operation

00:17:59.240 --> 00:18:02.100
out of that user info dictionary,
which has got everything just

00:18:02.100 --> 00:18:03.340
sort of jumbled together.

00:18:03.340 --> 00:18:06.880
And from that adapter operation,
you get the operation type code,

00:18:06.880 --> 00:18:08.810
which you can use to
decide what you want to do,

00:18:08.860 --> 00:18:10.660
as well as the database operation here.

00:18:10.660 --> 00:18:14.890
And the database operation
has your failed EO.

00:18:16.840 --> 00:18:20.580
You can get a delta dictionary from
the adapter operation and the current

00:18:20.600 --> 00:18:23.100
snapshot from the database operation.

00:18:23.160 --> 00:18:27.360
And I believe in this example
I just assume I'm using the

00:18:27.390 --> 00:18:30.300
session's default editing context,
but you can pull the

00:18:30.300 --> 00:18:34.000
editing context off of the
Enterprise Object itself if you want to.

00:18:34.080 --> 00:18:38.130
And our recovery mechanism
is just last write wins.

00:18:41.380 --> 00:18:45.660
What you see here,
we grabbed the delta above

00:18:45.780 --> 00:18:49.240
from the adapter operation,
we refault the object,

00:18:49.240 --> 00:18:52.800
and this line we just
used for our component,

00:18:52.800 --> 00:18:55.650
we reapply the changes,
and we'll go back and save again

00:18:55.680 --> 00:18:57.550
because it's in a little loop.

00:19:11.320 --> 00:19:16.090
So this is just using the
real estate example framework.

00:19:16.090 --> 00:19:19.540
And housing prices aren't really
going up very much anymore.

00:19:19.610 --> 00:19:21.790
They used to be going up more.

00:19:22.490 --> 00:19:25.300
And so these are a whole bunch of things
that our background thread decided to

00:19:25.310 --> 00:19:26.400
change while we were working at it.

00:19:26.400 --> 00:19:30.400
That's pretty much it.

00:19:30.400 --> 00:19:33.910
So we're going to go back to slides.

00:19:38.280 --> 00:19:42.240
Next we're going to talk
about multithreading in EOF.

00:19:42.240 --> 00:19:44.870
So there are a variety of good
books available about multithreading

00:19:44.870 --> 00:19:47.850
in Java and we can't really go
into just general multithreading in

00:19:47.850 --> 00:19:49.890
Java because that's a pretty big topic.

00:19:49.970 --> 00:19:52.400
Concurrent Programming in
Java by Doug Lees in my library.

00:19:52.400 --> 00:19:55.600
It's a pretty good book and
there are just a zillion of them.

00:19:55.610 --> 00:19:57.570
You probably want to pick up several.

00:19:57.690 --> 00:20:01.190
So some necessary concepts that
we're just going to skip over:

00:20:01.210 --> 00:20:03.340
synchronized methods
and synchronized blocks,

00:20:03.440 --> 00:20:06.040
try-finally blocks,
and the wait and notify

00:20:06.040 --> 00:20:07.310
methods on object.

00:20:07.440 --> 00:20:13.370
And then the WebObjects 5.2 Delta doc on
the What's New area has more information

00:20:13.370 --> 00:20:16.270
about locking issues specific to EOF.

00:20:22.330 --> 00:20:25.280
and David are all
involved in the process.

00:20:25.280 --> 00:20:27.280
Java applications are
always multithreaded,

00:20:27.280 --> 00:20:29.250
whether you like it or not.

00:20:29.280 --> 00:20:32.060
The object finalization thread,
so this has nothing

00:20:32.190 --> 00:20:33.280
to do with WebObjects.

00:20:33.280 --> 00:20:35.280
The object finalization
occurs in a separate thread.

00:20:35.280 --> 00:20:39.280
So if you have a finalizer,
those finalizer methods are going

00:20:39.280 --> 00:20:41.280
to get executed in another thread.

00:20:41.280 --> 00:20:43.280
That's just the way it is.

00:20:43.280 --> 00:20:47.280
With WebObjects applications,
there's also the session timeout thread,

00:20:47.380 --> 00:20:49.280
and that's also going to
be doing EOF operations.

00:20:49.280 --> 00:20:50.550
And then there are timers, notifications,

00:20:51.680 --> 00:20:53.690
So here's proper use of try finally.

00:20:53.790 --> 00:20:57.500
You just want to lock the resource,
do the try, use it.

00:20:57.540 --> 00:20:59.980
You really never want to mess
with the lock object itself.

00:21:00.200 --> 00:21:02.760
It's extraordinarily
difficult to do properly.

00:21:02.760 --> 00:21:06.590
It usually involves having another
lock object just to manage it.

00:21:06.660 --> 00:21:08.690
It's kind of Heisenberg effect.

00:21:08.770 --> 00:21:11.500
So you pretty much want
to leave those alone.

00:21:12.560 --> 00:21:15.250
So EOF's contract with you,
and this is again talked

00:21:15.250 --> 00:21:18.260
more about in the Delta doc,
is that you have to lock everything

00:21:18.260 --> 00:21:19.500
that you access directly.

00:21:19.500 --> 00:21:21.470
It's just the way it is.

00:21:21.520 --> 00:21:23.690
The locking,
in addition to everything else it does,

00:21:23.700 --> 00:21:28.830
helps keep EOF informed about what
resources you're using at any given time.

00:21:28.940 --> 00:21:33.250
The NSLocking interface is for all the
objects that support thread-safe use.

00:21:33.350 --> 00:21:36.250
Objects that don't implement NSLocking,
like NSRays and NSDictionary's,

00:21:36.300 --> 00:21:39.740
you're going to have to protect yourself,
so you can just create an

00:21:39.750 --> 00:21:41.310
NSRecursiveLock to do that.

00:21:41.430 --> 00:21:43.990
Trylock is amazingly useful,
and it's supported by

00:21:44.000 --> 00:21:46.880
NSRecursiveLock and EOEditingContext,
two of the main

00:21:46.880 --> 00:21:48.510
interactions with locking.

00:21:48.580 --> 00:21:50.990
And what this lets you do is
execute an operation only if

00:21:51.080 --> 00:21:52.700
you're certain you won't block.

00:21:52.790 --> 00:21:53.800
So that's great.

00:21:53.860 --> 00:21:57.060
You can queue up an operation,
happen later if you think you will block,

00:21:57.180 --> 00:22:00.300
and it's used in the
notification delivery mechanism.

00:22:00.500 --> 00:22:04.490
Control slash or kill dash quit
to the process ID produces a stack

00:22:04.490 --> 00:22:08.900
trace of every thread in the JVM and
I can't recommend this too highly.

00:22:08.900 --> 00:22:10.650
It's a phenomenal debugging aid.

00:22:10.840 --> 00:22:12.760
You get to see what all
the threads are doing.

00:22:12.820 --> 00:22:15.340
The JVM will tell you which
locks they're waiting on.

00:22:15.450 --> 00:22:18.720
It's really the only
reason I'm still here.

00:22:18.790 --> 00:22:21.130
Optimize It and JProbe are
both commercial products.

00:22:21.180 --> 00:22:23.760
They can help you debug
multithreading issues and they

00:22:23.870 --> 00:22:27.990
also support memory performance
and CPU performance profiling.

00:22:28.000 --> 00:22:29.100
So they're really great products.

00:22:29.100 --> 00:22:30.360
You can check them out.

00:22:31.760 --> 00:22:35.360
The main lock you're going to interact
with in EOF is on the editing context.

00:22:35.390 --> 00:22:37.600
This controls all kinds of things.

00:22:37.730 --> 00:22:40.270
Now,
it's true that nested editing contexts

00:22:40.270 --> 00:22:42.600
share the same lock as their parent.

00:22:42.600 --> 00:22:43.600
However, you still have to lock it.

00:22:43.600 --> 00:22:48.530
This is the contract that you have
with EOF and EOF has with you.

00:22:48.640 --> 00:22:50.610
Basically,
the only consequence of this that you

00:22:50.610 --> 00:22:53.700
can depend on is multiple threads can't
come in and use the same hierarchy of

00:22:53.780 --> 00:22:55.600
nested editing contexts at the same time.

00:22:55.600 --> 00:23:01.600
You can't cheat at locking this way.

00:23:01.600 --> 00:23:01.600
Well, you can try, but...

00:23:01.760 --> 00:23:05.330
Shared Edit Context Lock themselves,
and they're the only

00:23:05.330 --> 00:23:06.900
objects in EOF to do so.

00:23:07.340 --> 00:23:10.500
Otherwise, it just gets to be a
nightmare to maintain them.

00:23:10.620 --> 00:23:12.840
But basically, they're the only object
in EOF to do this,

00:23:12.840 --> 00:23:15.200
and it's really important
to lock everything else.

00:23:15.200 --> 00:23:17.750
You always have to lock the
editing context before you access

00:23:17.750 --> 00:23:19.200
any of its Enterprise Objects.

00:23:19.200 --> 00:23:21.430
So even operations you think
would be read-only or sort

00:23:21.530 --> 00:23:24.200
of intrinsically thread-safe,
they're not.

00:23:24.200 --> 00:23:26.150
There's faulting going
on behind your back.

00:23:26.150 --> 00:23:29.200
There's a lot of caching in the
frameworks themselves that's going on,

00:23:29.200 --> 00:23:32.200
a lot of transparent operations to
keep the object graph maintained,

00:23:32.200 --> 00:23:34.200
to keep memory down.

00:23:34.200 --> 00:23:37.200
You just have to lock everything.

00:23:37.200 --> 00:23:40.410
And the EO Object Store Coordinators
will lock all of their cooperating object

00:23:40.410 --> 00:23:43.650
stores if you ask them to lock directly,
and those are usually

00:23:43.650 --> 00:23:45.530
your database contexts.

00:23:46.790 --> 00:23:50.220
So what you see here is a
threads view of the EOF stack.

00:23:50.270 --> 00:23:52.570
The EO Object Store Coordinator is
the focal point.

00:23:52.640 --> 00:23:55.390
It's sort of the center of mass for EOF.

00:23:55.470 --> 00:23:59.280
And it serves as a mediator between the
EO control and the EO access layers.

00:23:59.550 --> 00:24:01.100
This diagram is a little oversimplified.

00:24:01.100 --> 00:24:02.600
There are callbacks and
delegates and stuff.

00:24:02.670 --> 00:24:06.430
But this is your basic idea
of how threading works in EOF.

00:24:06.660 --> 00:24:09.800
And the Object Store Coordinator is
the center of it all.

00:24:14.110 --> 00:24:17.760
So multithreading in EOF,
there are a couple remaining bottlenecks.

00:24:17.930 --> 00:24:20.330
The critical sections in these
classes tend to be very small,

00:24:20.330 --> 00:24:24.100
but if you're doing something that
does a lot of models or entity work,

00:24:24.100 --> 00:24:26.740
you're parsing models or you're
creating your own models on the fly,

00:24:26.870 --> 00:24:30.300
you should be aware that there are
some concurrency implications there.

00:24:30.300 --> 00:24:33.150
And the allows concurrent request
handling flag only affects WebObjects,

00:24:33.150 --> 00:24:36.900
the WebObjects Framework,
not WebObjects and EOF.

00:24:36.900 --> 00:24:41.630
This affects how requests are dispatched
to both sessions and direct actions and

00:24:41.770 --> 00:24:43.500
any other request handlers you have.

00:24:43.500 --> 00:24:45.100
And it has no effect on EOF.

00:24:45.170 --> 00:24:47.180
So like I said,
both the Object Finalizer thread

00:24:47.260 --> 00:24:50.160
and the Session Timeout thread are
going to be doing EOF operations

00:24:50.160 --> 00:24:52.510
whether you like it or not,
and this is to deal with

00:24:52.570 --> 00:24:55.030
memory management and snapshots
and a bunch of other things.

00:24:55.230 --> 00:24:58.660
So it's really important to keep
the editing context locked properly.

00:24:59.240 --> 00:25:02.100
One thing I have seen some customers
do is they lock an editing context,

00:25:02.100 --> 00:25:05.500
they use it to do one little
thing and then they unlock it.

00:25:05.590 --> 00:25:07.400
You can lock it for as
long as you need to.

00:25:07.400 --> 00:25:10.530
If you're not going to share that
editing context with another thread,

00:25:10.560 --> 00:25:11.300
you can just keep it locked.

00:25:11.430 --> 00:25:14.060
You don't have to make the
locks really fine-grained.

00:25:14.160 --> 00:25:17.300
That's the point of implementing
these locks on these objects is

00:25:17.300 --> 00:25:21.810
to allow you the flexibility to
control the grain of the locking.

00:25:23.610 --> 00:25:26.880
So my life might have purpose.

00:25:26.880 --> 00:25:30.750
Some stuff that I learned
painfully while working on EOF.

00:25:30.750 --> 00:25:32.360
Non-parallel locks are like debts.

00:25:32.430 --> 00:25:35.870
If you've got more than three locks
and they're all somehow related,

00:25:35.870 --> 00:25:37.160
you will regret it.

00:25:37.630 --> 00:25:40.310
Intersecting locks increase
the probability of deadlock.

00:25:40.500 --> 00:25:44.210
So the more locks that any thread
needs to acquire to get its work done,

00:25:44.450 --> 00:25:47.280
the greater likelihood some bug
is going to come along and cause

00:25:47.280 --> 00:25:48.470
your application to deadlock.

00:25:48.730 --> 00:25:50.270
Because some threads will have
some of the locks and some

00:25:50.350 --> 00:25:51.490
threads will have other locks.

00:25:51.490 --> 00:25:55.490
And this is a permutation that
increases combinatorially.

00:25:55.490 --> 00:25:57.270
It's ugly.

00:25:57.600 --> 00:26:00.340
And unfortunately,
these apps tend to work very well in

00:26:00.340 --> 00:26:04.500
development and not so well in deployment
under high stress after many days.

00:26:04.510 --> 00:26:06.500
So those are kinds of
bugs I like to avoid.

00:26:06.500 --> 00:26:08.980
Something that a lot of people
don't realize is the synchronized

00:26:08.980 --> 00:26:12.500
method and the synchronized block,
these are their own implicit lock object.

00:26:12.530 --> 00:26:16.020
And it's on either that Java lang object
or the Java class that you're working on,

00:26:16.320 --> 00:26:18.490
depending on the kind of
synchronized statement.

00:26:18.500 --> 00:26:23.000
So you can deadlock with these and you
can crosslock with the synchronized

00:26:23.000 --> 00:26:25.500
statement and an actual lock object.

00:26:25.530 --> 00:26:28.710
And if you come in and you block
inside a synchronized block,

00:26:28.710 --> 00:26:31.500
you do some I/O or you try
to grab a different lock,

00:26:31.500 --> 00:26:35.500
no other thread is going to be
able to do anything involving that

00:26:35.500 --> 00:26:36.500
object with that synchronized.

00:26:36.500 --> 00:26:39.500
So it's not going to be able to
execute any synchronized methods,

00:26:39.500 --> 00:26:41.500
not even the little one-line
setters and getters.

00:26:41.500 --> 00:26:44.500
And that's usually not what
people intend to have happen.

00:26:44.500 --> 00:26:47.590
So if you're going to lock for
something that you expect might block,

00:26:47.590 --> 00:26:51.260
like either acquiring a new lock,
doing some I/O, something expensive,

00:26:51.260 --> 00:26:53.340
you should do it outside
a synchronized scope.

00:26:53.340 --> 00:26:55.500
And you can use the NS recursive lock.

00:26:55.500 --> 00:26:58.830
I prefer that because it allows you to
use the try finally syntax regardless

00:26:58.830 --> 00:27:00.500
of what the call stack looks like.

00:27:00.500 --> 00:27:04.380
So you can just keep invoking
methods recursively or not.

00:27:04.500 --> 00:27:07.450
Or you can use Java's wait
notify protocol if you

00:27:07.610 --> 00:27:09.500
feel comfortable with that.

00:27:11.950 --> 00:27:14.870
Okay, so we're going to talk about a
new feature in WebObjects 5.2,

00:27:14.870 --> 00:27:17.750
and this is concurrent database access.

00:27:18.550 --> 00:27:21.880
and that's putting all those new threads
that you've learned how to create

00:27:21.950 --> 00:27:24.540
to use and to do a bunch of things
simultaneously with your database.

00:27:27.290 --> 00:27:29.820
As the diagram showed,
the EO Object Store Coordinator is

00:27:29.820 --> 00:27:32.840
the root of everything in the
EOF in terms of threading.

00:27:32.950 --> 00:27:37.080
So each EO Object Store Coordinator has
its own stack underneath it,

00:27:37.210 --> 00:27:39.450
its own set of locks,
its own database channels,

00:27:39.500 --> 00:27:41.910
and its own snapshot cache.

00:27:42.440 --> 00:27:43.960
So they're extremely independent.

00:27:43.980 --> 00:27:48.570
Notifications between them don't -- well,
there are no notifications

00:27:48.570 --> 00:27:51.110
in between them,
so they're very independent.

00:27:51.210 --> 00:27:52.700
It's pretty easy to do.

00:27:52.770 --> 00:27:54.520
Just create a new one,
pass it on to the constructor

00:27:54.520 --> 00:27:55.980
for your editing context.

00:27:56.140 --> 00:27:59.990
You can also change the default
object store coordinator.

00:28:01.210 --> 00:28:03.170
and I believe in
Project Wonder there's now an object

00:28:03.170 --> 00:28:06.260
store coordinator pool you can use.

00:28:06.260 --> 00:28:09.080
So you can use these independent
stacks any way you'd like,

00:28:09.080 --> 00:28:12.580
but there are some benefits to using
raw row operations with these stacks.

00:28:12.580 --> 00:28:15.190
And that's there's no overhead
from duplicated snapshots

00:28:15.330 --> 00:28:17.140
so there's less memory use.

00:28:17.140 --> 00:28:20.000
And you're not worried about
propagating notifications.

00:28:20.140 --> 00:28:22.430
The actual concurrency is
throttled by your database,

00:28:22.460 --> 00:28:25.210
so you have to make sure that
your database is set up to

00:28:25.210 --> 00:28:27.110
keep adding more channels.

00:28:30.380 --> 00:28:31.300
All right.

00:28:31.450 --> 00:28:35.740
And we're on to raw rows.

00:28:35.820 --> 00:28:39.330
So these are the lowest level
operations you can use in EOF.

00:28:39.390 --> 00:28:42.230
And they allow you to bypass
the entire EOF control layer.

00:28:42.300 --> 00:28:45.670
They'll return a result set
in NSArray of NSDictionary's.

00:28:45.790 --> 00:28:48.450
And each raw row is
itself an NSDictionary.

00:28:48.550 --> 00:28:53.460
There's no object graph management,
no undo/redo, no relationships,

00:28:53.640 --> 00:28:55.850
no faulting, which may be good.

00:28:55.850 --> 00:28:57.870
And there's no row caching.

00:28:57.870 --> 00:29:00.120
And you can use hand-coded SQL.

00:29:02.370 --> 00:29:05.540
So the EOF fetch specification,
you can just take a fetch specification,

00:29:05.540 --> 00:29:07.720
you set this flag,
and you'll get back raw rows

00:29:07.720 --> 00:29:09.100
instead of Enterprise Objects.

00:29:09.120 --> 00:29:11.880
Really easy to do,
probably the best way to get started.

00:29:11.980 --> 00:29:16.310
You can also pass in the custom SQL hint,
and this will allow you

00:29:16.310 --> 00:29:20.040
to pass in optimized SQL,
something specific to your database,

00:29:20.080 --> 00:29:24.550
or you can do something that EOF won't
generate automatically for you.

00:29:24.670 --> 00:29:28.330
My other favorite is raw rows for SQL,
really easy to use,

00:29:28.470 --> 00:29:32.500
and there are a bunch of other areas in
EOF where you can interact at this level.

00:29:34.390 --> 00:29:36.950
So some things to keep in mind while
you're using raw rows is that both

00:29:37.130 --> 00:29:40.660
Enterprise Objects and Dictionaries
implement NSKeyValue coding.

00:29:40.750 --> 00:29:45.090
So you can make instance variables type
to NSKeyValue coding the interface,

00:29:45.090 --> 00:29:48.300
and then as you're processing
the results from either an

00:29:48.300 --> 00:29:52.800
Enterprise Objects request,
a fetch, or a raw row fetch,

00:29:52.890 --> 00:29:55.040
those results can be
displayed in the same code.

00:29:55.120 --> 00:29:56.700
So the same code path can reuse them.

00:29:56.910 --> 00:30:00.910
That's really useful with both
components or UI layer work.

00:30:01.630 --> 00:30:05.700
You can promote raw rows into
full EOs as long as you fetch

00:30:05.810 --> 00:30:07.670
the primary key attributes.

00:30:07.750 --> 00:30:10.640
And you can demote EOs back into
their primary keys if you want

00:30:10.640 --> 00:30:12.240
to return to bare metal work.

00:30:12.280 --> 00:30:14.890
And the Think Movies example
that ships with Valve Objects

00:30:14.890 --> 00:30:16.360
demonstrates these ideas.

00:30:16.440 --> 00:30:19.210
So it uses the primary key
to do direct action-based

00:30:19.210 --> 00:30:21.720
work and there's no sessions.

00:30:23.880 --> 00:30:26.300
So there are a couple of features
that EOF doesn't provide at this time,

00:30:26.300 --> 00:30:28.660
and you can use raw
SQL to get these features.

00:30:28.790 --> 00:30:30.100
They're pretty handy.

00:30:30.170 --> 00:30:33.310
So there's in-qualification
and null relationship

00:30:33.310 --> 00:30:35.300
qualification or sub-queries.

00:30:35.390 --> 00:30:38.030
And again, Project Wonder has got some of
these things built in for you,

00:30:38.100 --> 00:30:43.360
so they're query operators for you,
and it's a good reason

00:30:43.360 --> 00:30:46.490
to go check it out.

00:30:46.590 --> 00:30:50.100
And now Steve Mine is going to come
up and give you a demonstration.

00:31:00.920 --> 00:31:01.610
Hi, thanks Ben.

00:31:01.790 --> 00:31:06.400
Alright,
I have a demonstration here for how

00:31:06.400 --> 00:31:10.510
to execute SQL using the EOF stack.

00:31:10.520 --> 00:31:15.460
I've written a little SQL tool that just
is similar to any command line tool that

00:31:15.540 --> 00:31:17.500
you might get from your database vendor.

00:31:17.620 --> 00:31:21.810
The advantage to my tool is I can use
it with any model and if I don't have

00:31:21.940 --> 00:31:28.160
a local database vendor's SQL tool,
I can use this to make changes

00:31:28.160 --> 00:31:32.220
to my database or just to
explore a little bit on the data.

00:31:32.540 --> 00:31:35.820
Before I get into that,
I want to show you the code.

00:31:35.820 --> 00:31:38.410
It's very easy to execute.

00:31:38.700 --> 00:31:59.100
[Transcript missing]

00:31:59.530 --> 00:32:03.080
You can add that model to a group,
the EO Model Group.

00:32:03.080 --> 00:32:03.780
Take a look at that.

00:32:03.880 --> 00:32:07.270
That's just a way of
grouping multiple models.

00:32:07.330 --> 00:32:09.900
You probably use that when you're
developing your applications.

00:32:10.000 --> 00:32:16.240
The Model Group knows about all your
entities across the set of models.

00:32:16.570 --> 00:32:21.030
You have to make sure you don't have any
entity name conflicts within your group.

00:32:21.410 --> 00:32:26.030
So the next thing you have
to do is collect an adapter.

00:32:26.430 --> 00:32:29.020
Given a model,
you can always say adapter with model.

00:32:29.190 --> 00:32:32.460
That will instantiate the adapter
and that allows you to make

00:32:32.460 --> 00:32:34.530
your connection to the database.

00:32:34.650 --> 00:32:40.220
The adapter context is your
scope for your transactions.

00:32:40.220 --> 00:32:42.830
You don't have to interact too
much with your adapter context,

00:32:42.830 --> 00:32:45.830
but the adapter context also
allows you to create a channel.

00:32:46.020 --> 00:32:49.560
And a channel at the adapter
level is the entity that,

00:32:49.560 --> 00:32:54.190
or the object that knows how to
actually do a query to the database.

00:32:56.830 --> 00:33:00.060
So with that, just a few lines of code,
you can get set up so

00:33:00.060 --> 00:33:03.340
you've opened a channel,
now you have a way of talking

00:33:03.350 --> 00:33:05.040
directly to your database.

00:33:05.120 --> 00:33:12.120
I'm going to show you how the
SQL command actually executes the SQL.

00:33:14.410 --> 00:33:17.100
and I will just slide down a bit.

00:33:17.400 --> 00:33:20.090
So given an adapter channel,

00:33:20.200 --> 00:33:22.900
There's just one line here
that's going to execute SQL.

00:33:22.900 --> 00:33:26.610
Your SQL string is just
a regular Java string.

00:33:26.710 --> 00:33:29.760
We have to convert that into
an expression that an adapter

00:33:29.760 --> 00:33:31.250
channel knows how to use.

00:33:31.480 --> 00:33:34.260
So we ask the adapter for
its expression factory,

00:33:34.260 --> 00:33:37.700
and the expression factory has a
method called expression for string.

00:33:37.790 --> 00:33:41.220
That expression converts it into an
expression that we just call evaluate

00:33:41.220 --> 00:33:43.140
expression on the adapter channel.

00:33:43.250 --> 00:33:45.960
That sends a SQL to the database.

00:33:46.280 --> 00:33:48.580
We get back a result set.

00:33:48.710 --> 00:33:53.370
Our results are going to be
an array of dictionaries.

00:33:53.480 --> 00:33:58.490
So you can see here what we
do is set up a mutable array.

00:33:59.380 --> 00:34:04.060
We have to tell the adapter channel what
the result set is going to look like.

00:34:04.060 --> 00:34:07.300
I want to take a minute to
show you how we specify that.

00:34:07.310 --> 00:34:08.860
I'll come back to that in a second.

00:34:09.100 --> 00:34:12.980
Once we've told the adapter channel
what the result set will look like,

00:34:13.020 --> 00:34:16.780
we call fetchRow multiple
times until we get back a null.

00:34:16.830 --> 00:34:18.540
Each of those rows is a dictionary.

00:34:18.580 --> 00:34:21.440
We're holding on to our
own result set this way.

00:34:23.080 --> 00:34:27.670
When we're setting up the result set,
there's one method in the adapter

00:34:27.750 --> 00:34:29.180
channel called describeResults.

00:34:29.240 --> 00:34:33.600
After you've made a
query to the database,

00:34:33.730 --> 00:34:35.640
the database knows what the
result set will look like.

00:34:35.640 --> 00:34:39.640
The adapter channel has a method called
describeResults that's specialized for

00:34:39.640 --> 00:34:41.480
whatever adapter you happen to be using.

00:34:41.480 --> 00:34:46.440
It will create an
NSArray of EO attributes.

00:34:46.760 --> 00:34:52.010
So, if you're doing raw SQL,
the adapter channel doesn't know

00:34:52.020 --> 00:34:54.200
anything about any particular attributes.

00:34:54.200 --> 00:34:58.330
We have to synthesize,
make new attributes on the fly

00:34:58.540 --> 00:35:01.470
to describe each of those result
columns that are coming back.

00:35:01.480 --> 00:35:06.210
Now, one thing in normal EOF operations,
we never have any name conflicts,

00:35:06.310 --> 00:35:09.540
but when you're doing raw SQL,
your result dictionaries are

00:35:09.540 --> 00:35:13.290
going to use the column labels
that the database gives us.

00:35:13.490 --> 00:35:19.320
In SQL, there's... the results
are returned by position,

00:35:19.320 --> 00:35:21.960
so there's not any problem
with name conflicts.

00:35:21.960 --> 00:35:24.200
But if you're doing
some complicated join,

00:35:24.220 --> 00:35:26.670
and two of those columns
happen to have the same name,

00:35:26.680 --> 00:35:30.950
when we turn that into a dictionary,
we're going to smash some values,

00:35:30.950 --> 00:35:32.440
because we're going to
be using the same keys.

00:35:32.440 --> 00:35:36.810
So, I have a few lines of code here
just to walk through the result

00:35:36.870 --> 00:35:40.280
set and change the attribute
names if there's any conflicts.

00:35:40.280 --> 00:35:46.690
We can also use that a bit later to
manipulate the result set so it's

00:35:46.690 --> 00:35:50.990
more convenient to use when you want
to turn things back into real EOs.

00:35:52.440 --> 00:35:55.840
All right,
so that's enough code to look at.

00:35:55.840 --> 00:35:59.880
Let's, what is that again?

00:36:00.520 --> 00:36:02.390
So now back to the demo.

00:36:02.470 --> 00:36:04.720
This command line tool,
you can just type SQL to it,

00:36:04.730 --> 00:36:05.400
it executes it.

00:36:05.460 --> 00:36:09.500
There's a few other commands it knows
about in dealing with your model.

00:36:09.500 --> 00:36:12.650
For the demo purposes,
there's a command that I call demo

00:36:12.650 --> 00:36:17.030
that's going to load the commands
from a text file so that way you won't

00:36:17.030 --> 00:36:19.630
have to watch me make any mistypes.

00:36:19.820 --> 00:36:22.220
So one reason you might
want to use SQL is if you're

00:36:22.240 --> 00:36:24.760
generating some kind of report,
you're doing something with

00:36:24.850 --> 00:36:28.340
SQL aggregate functions,
or you're doing a complicated

00:36:28.340 --> 00:36:32.700
query that EOF doesn't have a
facility or a way of expressing.

00:36:32.730 --> 00:36:36.100
If you're doing, in this case,
we want to get the

00:36:36.100 --> 00:36:38.200
minimum value for revenue,
the maximum value,

00:36:38.200 --> 00:36:41.570
and the average out of the movie table.

00:36:41.770 --> 00:36:42.550
So we execute that.

00:36:42.690 --> 00:36:45.700
We got back just a raw
row that's a dictionary,

00:36:45.700 --> 00:36:49.200
and then you can see each of the
labels and each of the results.

00:36:49.750 --> 00:36:53.210
For display purposes,
I'm just running down the dictionary

00:36:53.210 --> 00:36:54.880
showing you the keys and the values.

00:36:55.920 --> 00:36:58.560
Another common thing
is to ask for a count.

00:36:58.700 --> 00:37:03.400
Count* is kind of a special
aggregate function in SQL.

00:37:03.520 --> 00:37:06.620
In this case,
we want to take a look and find all the

00:37:06.620 --> 00:37:09.000
movies that start with the letter C.

00:37:09.130 --> 00:37:12.630
So we're going to get back just a result,
a single dictionary,

00:37:12.760 --> 00:37:15.300
or a dictionary with a single entry,
that's the count.

00:37:15.450 --> 00:37:20.160
You might do something like this if you
want to customize your user interface

00:37:20.700 --> 00:37:23.200
according to how big the result set is.

00:37:23.200 --> 00:37:26.200
If you just have a few objects,
you might display it one way.

00:37:26.200 --> 00:37:29.190
If you have millions of objects,
you might want to do something different.

00:37:29.230 --> 00:37:31.740
We're going to come back
to this a little bit later.

00:37:31.930 --> 00:37:35.380
I want to show you a bit of a trick,
a way to do this by staying

00:37:35.410 --> 00:37:40.790
in the normal object world,
using objects with fetch specification.

00:37:40.920 --> 00:37:44.630
This is how you do it in straight SQL.

00:37:45.290 --> 00:37:48.650
All right,
so now we figured out what our count was.

00:37:48.920 --> 00:37:53.380
Now we want to actually go out and
get some bits of those movie rows.

00:37:53.550 --> 00:37:57.370
In this case, I'm asking for the movie
ID and for the title.

00:37:57.660 --> 00:37:59.970
That's useful if you're doing
some kind of display list.

00:38:00.120 --> 00:38:02.110
We're getting back these dictionaries.

00:38:02.110 --> 00:38:03.320
They're not full EOs.

00:38:03.450 --> 00:38:07.740
We're not keeping any snapshots here,
but you can put up a display of all the,

00:38:07.760 --> 00:38:08.800
say, titles.

00:38:08.920 --> 00:38:11.550
And because you're
saving also the movie ID,

00:38:11.560 --> 00:38:14.310
you can convert those
back into EOs later.

00:38:15.240 --> 00:38:18.140
Okay,
so those were pretty simple SQL examples.

00:38:18.210 --> 00:38:21.400
You probably wouldn't need to
execute straight SQL to do that.

00:38:21.400 --> 00:38:25.620
But a more complicated
query in the EOF world is,

00:38:25.640 --> 00:38:29.200
in this case, find all the movies
that have no director.

00:38:29.200 --> 00:38:31.340
I want to take a second,
go back to EOModeler,

00:38:31.340 --> 00:38:34.090
and just remind you what the
model looks like for movies.

00:38:34.210 --> 00:38:36.200
This is our basic example.

00:38:36.200 --> 00:38:39.690
We have a movie table,
and it has basically a many-to-many

00:38:39.690 --> 00:38:42.200
relationship with the talent table.

00:38:42.200 --> 00:38:44.710
So any movie could have
multiple directors,

00:38:44.760 --> 00:38:47.920
and of course any director
could direct multiple movies.

00:38:48.260 --> 00:38:50.730
So when you're modeling that
in a SQL relational database,

00:38:50.730 --> 00:38:52.190
you need a correlation table.

00:38:52.200 --> 00:38:54.140
In this case, we called it Director.

00:38:54.350 --> 00:38:58.090
So a director is just a pair of
the movie ID and the talent ID.

00:38:58.320 --> 00:39:01.720
That allows us to form the
many-to-many relationship.

00:39:05.100 --> 00:39:06.340
Back to our SQL.

00:39:06.410 --> 00:39:09.040
So the question is how do we find
all the movies that have no director?

00:39:09.040 --> 00:39:12.500
If we were doing that with a
normal fetch specification,

00:39:12.540 --> 00:39:14.700
well, we'd have to write some
code actually in EOF.

00:39:14.700 --> 00:39:18.920
We'd have to get all the movies,
check each of their directors'

00:39:18.960 --> 00:39:22.640
too many relationships,
find all those with a count of zero.

00:39:22.640 --> 00:39:25.490
And that's perfectly easy to do,
but if you have a large data set,

00:39:25.490 --> 00:39:28.160
that's going to do a bit of
work in fetching all that

00:39:28.160 --> 00:39:29.760
information from the database.

00:39:29.810 --> 00:39:35.100
And in SQL, you can pretty much do that
sort of thing in just one query.

00:39:35.100 --> 00:39:41.910
Here I'm doing a subquery and
using the SQL in operator.

00:39:41.910 --> 00:39:47.270
So we want to find out all the movies
that have a movie ID where that movie

00:39:47.330 --> 00:39:49.980
ID does not exist in the director table.

00:39:50.130 --> 00:39:52.610
That's the same thing as
saying it has no directors.

00:39:52.790 --> 00:39:54.410
So we can just execute that directly.

00:39:54.420 --> 00:39:57.510
And again, I'm getting the title back
just for display purposes.

00:39:57.510 --> 00:39:59.780
The main thing if you're doing
something else with an EO is

00:39:59.780 --> 00:40:02.070
to get back that primary key,
which is the movie ID here.

00:40:03.730 --> 00:40:06.170
Alright,
so that was a fairly simple query.

00:40:06.190 --> 00:40:08.970
A little more complicated query:
you want to find all the movies

00:40:08.970 --> 00:40:10.600
that have more than one director.

00:40:10.600 --> 00:40:14.590
Okay, this is a good one for all
you sequel experts out there.

00:40:14.640 --> 00:40:16.570
You can think about this a bit.

00:40:16.670 --> 00:40:18.600
I came up with this line of sequel.

00:40:18.600 --> 00:40:22.820
What I'm doing here is joining the
director table and the movie table.

00:40:22.820 --> 00:40:26.600
That basically kind of gives me
all the director-movie pairs.

00:40:26.600 --> 00:40:31.590
Then I'm, for each of those directors
that have directed a movie,

00:40:31.590 --> 00:40:34.930
I'm looking in the director
table for anyone else who's

00:40:34.930 --> 00:40:36.480
directed that same movie.

00:40:36.600 --> 00:40:41.560
Okay, and I'm taking account of all those
talent IDs where those movie IDs match.

00:40:41.600 --> 00:40:44.000
And that's in a subquery
that I'm comparing that,

00:40:44.000 --> 00:40:47.260
so I'm saying greater than one,
because I want to find all the movies

00:40:47.680 --> 00:40:49.600
that have more than one director.

00:40:49.600 --> 00:40:52.810
Okay, this would be,
take the same kind of loop if you're

00:40:52.810 --> 00:40:54.600
just writing regular EOF code.

00:40:54.700 --> 00:40:56.510
You'd have to go fetch all the movies,
fetch all the directors.

00:40:56.600 --> 00:40:58.600
And check their counts.

00:40:58.630 --> 00:41:01.310
So here we have six results.

00:41:01.690 --> 00:41:04.600
Again, I just fetched the
titles and the movie IDs.

00:41:06.640 --> 00:41:09.740
Now, given any primary key,
of course you can go

00:41:09.920 --> 00:41:10.760
select the right row.

00:41:10.890 --> 00:41:14.360
Here I want to select the
movie given my primary key,

00:41:14.360 --> 00:41:15.520
so 111.

00:41:15.540 --> 00:41:16.230
Let's see what I get.

00:41:16.370 --> 00:41:17.480
This is a raw row now.

00:41:17.660 --> 00:41:19.350
I said select star.

00:41:19.690 --> 00:41:23.790
So when I say select star,
I don't really have much control

00:41:23.790 --> 00:41:26.720
over the label in that dictionary.

00:41:26.940 --> 00:41:29.520
The database is then going
to decide what labels to use.

00:41:29.810 --> 00:41:35.020
We're translating those labels into
the keys for the result dictionary.

00:41:35.170 --> 00:41:37.900
Now you may notice that it's
using all capital letters.

00:41:37.900 --> 00:41:39.290
That's typical for SQL.

00:41:39.300 --> 00:41:41.100
The labels are all caps.

00:41:41.170 --> 00:41:44.800
When I want to turn this
back into a movie EO,

00:41:44.830 --> 00:41:48.320
I need to have a dictionary,
a primary key dictionary,

00:41:48.370 --> 00:41:51.800
that matches the name of my attribute
that was used in the primary key.

00:41:51.910 --> 00:41:54.000
So I need to change the key.

00:41:54.080 --> 00:41:57.000
And what I've done here
in my little application,

00:41:57.000 --> 00:42:00.700
I've kept a small dictionary
where I can do key mapping.

00:42:00.700 --> 00:42:03.600
So I'm going to say, okay,
whenever you give me a result set,

00:42:03.600 --> 00:42:07.470
and I map that uppercase
movie_id into movie_id,

00:42:07.600 --> 00:42:09.700
that'll give me a good result.

00:42:09.940 --> 00:42:12.700
All right,
so I'm just going to execute that again.

00:42:12.700 --> 00:42:16.150
And you'll see the only
difference here that matters,

00:42:16.150 --> 00:42:18.390
right, is I have a key here,
the underscore movie ID.

00:42:18.400 --> 00:42:22.060
Now, another way to do this,
often in SQL, if you're specifying

00:42:22.060 --> 00:42:26.260
your whole select list,
you can say what label to use for any

00:42:26.260 --> 00:42:29.290
particular column that's coming back.

00:42:29.400 --> 00:42:32.320
And so you might just put a label there,
call it movie ID,

00:42:32.320 --> 00:42:35.230
put it in double quotes so
you control the case that way.

00:42:35.400 --> 00:42:40.260
But people have had a problem when
they're doing raw rows for SQL.

00:42:40.400 --> 00:42:44.250
Sometimes they're doing a join,
they get either name collisions or

00:42:44.250 --> 00:42:46.400
they get the wrong case on something.

00:42:46.460 --> 00:42:50.260
So in an upcoming update,
there's going to be a new version of

00:42:50.260 --> 00:42:53.810
raw rows with SQL that gives you an
extra parameter where you can specify

00:42:53.810 --> 00:42:55.880
the mapping for all those column names.

00:42:56.180 --> 00:43:01.090
That might make it a
little easier to use.

00:43:01.970 --> 00:43:06.240
So, we said before we can select
with SQL to get things,

00:43:06.240 --> 00:43:10.370
but you can also do a lot of this
kind of stuff just in regular

00:43:10.570 --> 00:43:12.540
EOF using fetch specifications.

00:43:12.650 --> 00:43:19.640
So I want to show you here how to
fetch an object using a primary key.

00:43:20.020 --> 00:43:25.960
Let me go back to the model and
show you a fetch specification.

00:43:30.410 --> 00:43:36.790
So, in DeepFetch 1 Movie,
this is used in the Think Movies example,

00:43:36.790 --> 00:43:40.300
we're doing a qualifier that's
based on the movie ID and we

00:43:40.300 --> 00:43:43.880
have a qualifier variable,
in this case $MYMOVIE.

00:43:43.930 --> 00:43:46.490
So when you use this fetch specification,
you need to have a binding

00:43:46.490 --> 00:43:47.870
for that qualifier variable.

00:43:48.050 --> 00:43:51.880
You can think of this fetch
specification as kind of a template.

00:43:52.080 --> 00:43:55.510
So when you bind something to it,
you create a new fetch specification.

00:43:55.640 --> 00:43:56.610
We're using movie ID.

00:43:56.690 --> 00:43:59.960
Now if you remember,
movie ID is the primary

00:44:00.820 --> 00:44:04.350
key for the movie entity,
but it, let me go back and show

00:44:04.450 --> 00:44:05.740
you the movie entity.

00:44:05.750 --> 00:44:08.320
Movie ID is not marked
as a class property.

00:44:08.320 --> 00:44:13.260
Okay,
so that's maybe not obvious to everyone,

00:44:13.260 --> 00:44:17.440
but you can qualify over attributes
that are not class properties.

00:44:17.500 --> 00:44:19.360
As long as they're in your model,
we know how to map

00:44:19.360 --> 00:44:21.020
things with your entity.

00:44:22.770 --> 00:44:23.550
All right.

00:44:23.730 --> 00:44:27.300
So we have a simple fetch here.

00:44:27.300 --> 00:44:30.370
We're fetching all Enterprise Objects.

00:44:31.240 --> 00:44:32.830
Let me execute this command.

00:44:32.850 --> 00:44:35.140
EO is a command that's
built into my little tool.

00:44:35.350 --> 00:44:41.060
It basically just calls an object with
primary key value and does a real fetch.

00:44:41.100 --> 00:44:44.010
In the display here,
I have a real movie and we're

00:44:44.310 --> 00:44:48.100
showing the primary key and
I'm showing all the attributes.

00:44:48.100 --> 00:44:52.970
Of course, the advantage to getting real
EOs is you can use key value coding.

00:44:53.220 --> 00:44:56.640
Here I'm going to fetch that
same movie and then apply the

00:44:56.640 --> 00:45:00.100
key value coding studio.name.

00:45:00.180 --> 00:45:04.370
It executed that, got that EO,
found the studio, which is another EO,

00:45:04.590 --> 00:45:07.100
and then went and got the name out of it.

00:45:07.100 --> 00:45:13.100
That's much easier than writing all
the SQL to go get that particular name.

00:45:13.100 --> 00:45:19.610
I want to show you another
fetch with a qualifier variable.

00:45:25.800 --> 00:45:28.800
Okay, so this one is just the
explicit with the deep fetch.

00:45:28.800 --> 00:45:33.790
The deep fetch is doing the same
thing as my other command did.

00:45:38.200 --> 00:45:43.170
Coming back here,
I have another fetch specification.

00:45:43.210 --> 00:45:46.010
This one is a raw fetch specification,
so I'm getting an

00:45:46.120 --> 00:45:47.430
attribute called ZCount.

00:45:47.550 --> 00:45:50.460
I'm going to take a look at that in
a second in how that was modeled.

00:45:50.550 --> 00:45:54.700
Qualifier is checking the title,
so it's title-like, my title,

00:45:54.700 --> 00:45:57.570
my title is going to be some
pattern that we have to bind to.

00:45:57.640 --> 00:46:00.050
Now remember, we're fetching ZCount,
we're doing a raw fetch,

00:46:00.050 --> 00:46:02.610
so we're not getting back folios,
we're just getting back

00:46:02.610 --> 00:46:03.700
a value for ZCount.

00:46:03.760 --> 00:46:06.010
And if you look at movie,
ZCount is an attribute

00:46:06.620 --> 00:46:10.950
that's not a class property,
so it's not part of your EO's class,

00:46:10.950 --> 00:46:15.580
but it's defined in the entity,
and our definition for that is count*.

00:46:15.670 --> 00:46:18.980
So we're going to use that
SQL expression count* in the fetch

00:46:18.980 --> 00:46:21.230
specification when we execute it.

00:46:22.300 --> 00:46:27.100
So this is an alternative to using
raw SQL and it keeps you in the

00:46:27.100 --> 00:46:30.160
normal EOF fetch specification world.

00:46:30.220 --> 00:46:32.960
It's a little bit easier to maintain
than executing your own SQL.

00:46:33.090 --> 00:46:37.000
So I'm binding C* to my title.

00:46:37.060 --> 00:46:40.960
Now I'm going to fetch using
that count for title like.

00:46:41.040 --> 00:46:43.880
So I found out that there's
five movies on that count.

00:46:43.930 --> 00:46:46.970
And again,
this is a way if you have to adjust your

00:46:46.970 --> 00:46:51.270
interface to how big your result set is,
it might make sense you want

00:46:51.400 --> 00:46:52.790
to go find a count first.

00:46:54.170 --> 00:46:56.270
and just to show you,
if we can fetch those same

00:46:56.270 --> 00:46:58.860
movies once we have them,
we know how big it is.

00:46:58.870 --> 00:47:03.400
I'm doing a raw fetch here just to
get the movie IDs and displaying it.

00:47:03.810 --> 00:47:06.200
So that's the end of my demo here.

00:47:06.230 --> 00:47:09.100
What I want to do is give you
a feel for the fact that you

00:47:09.100 --> 00:47:10.880
can execute any SQL you want.

00:47:10.900 --> 00:47:14.340
It's good for generating some kind
of reports or complicated queries.

00:47:14.380 --> 00:47:16.910
But for other things you want to take
a look and try to use Objects with

00:47:16.970 --> 00:47:20.460
Fetch Specification when you can.

00:47:25.110 --> 00:47:28.100
Thank you, Steve.

00:47:28.210 --> 00:47:32.380
So today we reviewed memory management,
data freshness, optimistic locking,

00:47:32.420 --> 00:47:35.780
multithreading in EOF,
concurrent database access,

00:47:35.780 --> 00:47:37.890
and raw row operations.

00:47:39.260 --> 00:47:43.000
I note about the forthcoming
WebObjects 5.2.2 update.

00:47:43.030 --> 00:47:47.220
The main focus of this update is on
Mac OS X server and J2E integration,

00:47:47.400 --> 00:47:48.800
particularly with JBoss.

00:47:48.960 --> 00:47:52.100
But there's some EOF impact,
some goodies here like log4j support,

00:47:52.200 --> 00:47:56.020
and some JNDI lookup for
your application properties,

00:47:56.060 --> 00:47:58.390
as well as assorted bug fixing.

00:48:02.270 --> 00:48:05.740
So the Apple Technical Publications
Group has got tons of documentation

00:48:05.830 --> 00:48:08.270
and this is the stuff that I use.

00:48:08.630 --> 00:48:10.760
and particularly the
EOF Developer Developer Guide and

00:48:10.760 --> 00:48:16.000
the 5.2 Delta doc are both very
important and the API reference.

00:48:16.200 --> 00:48:18.910
Reporting bugs, bugreport.apple.com.

00:48:19.000 --> 00:48:21.000
If you don't file it,
we won't know about it.

00:48:21.070 --> 00:48:22.830
Probably.

00:48:24.950 --> 00:48:27.990
Project Wonder - lots of
interesting extensions to EOF as

00:48:27.990 --> 00:48:31.660
well as just some general idioms
already implemented for you for

00:48:31.660 --> 00:48:33.780
Java programming and EOF programming.

00:48:33.810 --> 00:48:37.640
And some third party sites,
the Omni Group and Stepwise sites,

00:48:37.710 --> 00:48:39.870
they've got mailing lists,
community resources,

00:48:39.900 --> 00:48:43.450
and technical articles both
on WebObjects and on EOF.

00:48:45.440 --> 00:48:46.400
Who to contact?

00:48:46.400 --> 00:48:50.300
webobjects@apple.com goes
to a bunch of people.

00:48:50.300 --> 00:48:52.560
You can also use bugreport.apple.com.

00:48:52.710 --> 00:48:55.890
And there's enterprise-level services
and consulting support if you

00:48:55.890 --> 00:49:00.620
want to hire an Apple consultant.

00:49:00.620 --> 00:49:03.890
And here's some stuff that somebody
else thought you should know about.
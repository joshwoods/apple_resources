WEBVTT

00:00:27.920 --> 00:00:31.220
We have two FireWire sessions this year,
like we do every year.

00:00:31.320 --> 00:00:34.190
One is more in-depth and
focuses on writing software.

00:00:34.350 --> 00:00:36.890
The other is more introductory
and this year focuses a

00:00:36.910 --> 00:00:38.790
great deal on FireWire 800.

00:00:38.790 --> 00:00:40.790
But this year they are in reverse order.

00:00:40.790 --> 00:00:42.750
So you haven't missed anything.

00:00:42.820 --> 00:00:44.480
The next one is tomorrow at 9 a.m.

00:00:44.480 --> 00:00:46.830
I'm sure you'll all be up
bright and early for that.

00:00:49.820 --> 00:00:52.690
What this session is about
is writing FireWire software.

00:00:52.760 --> 00:00:55.300
We're gonna talk about
what's in Mac OS X,

00:00:55.460 --> 00:00:59.100
how the FireWire services work,
what's available for you to

00:00:59.120 --> 00:01:02.260
tap into where you can hook
your software into ours.

00:01:02.260 --> 00:01:07.340
And we have a new focus this year
on a number of topics more in-depth.

00:01:07.550 --> 00:01:09.340
For example,
we'll look at how Isochronous

00:01:09.340 --> 00:01:11.440
Transmit really works,
which we've always

00:01:11.440 --> 00:01:12.680
glossed over in the past.

00:01:12.720 --> 00:01:14.640
And we have a bunch of new
tools for you that I think

00:01:14.640 --> 00:01:15.650
you'll be really interested in.

00:01:15.780 --> 00:01:18.150
So let's launch right into this.

00:01:21.560 --> 00:01:23.300
Wasn't expecting this to
be tipped over like that.

00:01:23.350 --> 00:01:26.930
We're going to go over
the architecture first.

00:01:27.020 --> 00:01:28.660
We'll look at the layers
of FireWire software,

00:01:28.660 --> 00:01:31.420
the various modules,
how driver matching and loading works,

00:01:31.480 --> 00:01:34.060
where you can hook in,
how you develop software.

00:01:34.060 --> 00:01:38.570
Then we have special sections on TCPIP,
the internet protocol

00:01:38.570 --> 00:01:42.000
running over FireWire,
some detailed examples of how

00:01:42.000 --> 00:01:45.480
isochronous transfer works,
what a DCL wheelie is and

00:01:45.480 --> 00:01:47.300
what happens when you run one.

00:01:47.300 --> 00:01:51.920
We'll look at new AVC services,
including new AVC target support that

00:01:51.920 --> 00:01:53.200
adds some great new capabilities.

00:01:53.200 --> 00:01:56.430
We'll talk briefly about SPP3,
which adds some new

00:01:56.560 --> 00:01:57.740
performance capability.

00:01:57.740 --> 00:02:01.160
And then we'll have a detailed look
at some new tools and other support

00:02:01.160 --> 00:02:04.630
that we have for you to help you
develop for FireWire on Mac OS X.

00:02:07.260 --> 00:02:09.090
Let's start with the architecture.

00:02:09.090 --> 00:02:12.100
Let's see if this thing works.

00:02:12.310 --> 00:02:15.530
Here's the stack showing the various
elements in Mac OS X FireWire.

00:02:15.530 --> 00:02:19.300
The four that are brightly colored are
the core services that are provided

00:02:19.300 --> 00:02:23.630
by the FireWire software team and some
others are shown around them for context.

00:02:24.510 --> 00:02:26.270
Starting at the bottom,
you see the silicon that

00:02:26.270 --> 00:02:29.300
represents the FireWire interface
in the Power Macintosh system.

00:02:29.300 --> 00:02:31.840
The PHY,
which we'll talk more about later,

00:02:32.000 --> 00:02:34.920
and the OHCI chip together,
that's what you typically

00:02:34.920 --> 00:02:36.570
find on a FireWire card.

00:02:37.950 --> 00:02:40.900
When that's detected,
our services load in the Kernel.

00:02:40.960 --> 00:02:43.710
Pretty much all of FireWire is in
the Kernel because FireWire is a

00:02:43.710 --> 00:02:44.870
resource that we can boot from.

00:02:44.930 --> 00:02:47.070
We can take a page fault
from a FireWire device,

00:02:47.070 --> 00:02:48.800
so it's got to be there in the Kernel.

00:02:49.400 --> 00:02:52.420
Similarly, our IP networking services
have to be in the Kernel.

00:02:54.240 --> 00:02:56.230
So we'll go over the
layers in the Kernel,

00:02:56.230 --> 00:02:59.910
and we'll also talk about how you can
hook into that from user space up on top.

00:02:59.910 --> 00:03:02.440
You can see the three
layers in the Kernel there.

00:03:02.440 --> 00:03:05.130
The controller hooks
directly onto the hardware,

00:03:05.130 --> 00:03:09.110
the family pulls everything together,
the protocol layers where we start

00:03:09.110 --> 00:03:12.290
to differentiate into SPP2 or AVC,
and then the user client

00:03:12.370 --> 00:03:13.820
interfaces up on top.

00:03:16.950 --> 00:03:19.110
Let's start with the
family right in the middle.

00:03:19.110 --> 00:03:21.760
The family is the layer that
brings everything together.

00:03:21.870 --> 00:03:25.690
You've got multiple FireWire devices,
multiple drivers, multiple applications.

00:03:25.690 --> 00:03:28.550
They all want to use the same
FireWire bus at the same time.

00:03:28.560 --> 00:03:30.660
Well,
there's only so many DMA contexts and

00:03:30.660 --> 00:03:32.650
address space and interrupts and so on.

00:03:32.650 --> 00:03:35.500
You don't want them trying to
know what each other are doing.

00:03:35.700 --> 00:03:38.100
You want them all to
function independently.

00:03:38.870 --> 00:03:40.010
That's what the family does.

00:03:40.020 --> 00:03:42.250
It lets the different
drivers make their requests.

00:03:42.250 --> 00:03:44.120
It queues them up and
sends them on the bus.

00:03:44.120 --> 00:03:46.980
When packets come back in,
it figures out which packets go to which

00:03:46.980 --> 00:03:48.810
driver and hands them out accordingly.

00:03:48.840 --> 00:03:51.090
So your drivers don't have
to tiptoe around each other.

00:03:51.090 --> 00:03:53.950
You can write just to do your thing
and not worry about everybody else.

00:03:53.950 --> 00:03:55.530
That's what the family is for.

00:03:55.540 --> 00:03:58.900
The family also provides some
basic management services.

00:03:58.980 --> 00:04:01.790
For example,
the family may tune the performance

00:04:01.790 --> 00:04:05.530
of the FireWire bus to optimize
some of the hardware settings.

00:04:05.560 --> 00:04:08.630
The family is provided
in a kernel extension.

00:04:08.780 --> 00:04:12.320
extension called io-firewire-family KEXT.

00:04:12.980 --> 00:04:15.900
and there's going to be one of these
for each FireWire bus in your system.

00:04:15.900 --> 00:04:18.540
Typically, you only have one FireWire
bus in the system,

00:04:18.540 --> 00:04:21.730
but if you want,
you can have more than one.

00:04:22.760 --> 00:04:24.600
The layer below that is the Controller.

00:04:24.670 --> 00:04:28.690
This is what glues the family
to the hardware in your system.

00:04:28.770 --> 00:04:31.280
In most systems,
this will be Apple FW-OHCI,

00:04:31.280 --> 00:04:34.700
the Kernel Extension,
although in certain very old systems,

00:04:34.810 --> 00:04:38.640
it will be Apple Lynx,
such as on the blue and white G3.

00:04:38.760 --> 00:04:41.190
The Controller actually
knows how to program DMA,

00:04:41.190 --> 00:04:44.010
knows how to handle interrupts,
and knows how to do all the

00:04:44.010 --> 00:04:45.700
hardware-specific stuff.

00:04:45.890 --> 00:04:48.620
This is the same whether you
have an integrated controller,

00:04:48.770 --> 00:04:51.860
like Steve showed yesterday in
the new G5 architecture where

00:04:51.860 --> 00:04:54.850
the FireWire controller is
just built into the chipset,

00:04:54.850 --> 00:04:57.530
or if you have a PCI card
or a CardBus card.

00:04:57.700 --> 00:04:59.570
It's all the same with
the Controller layer.

00:04:59.700 --> 00:05:02.780
Now, as I described,
all those things sharing the family,

00:05:02.920 --> 00:05:05.640
everything they do has to
go through the Controller.

00:05:05.750 --> 00:05:08.650
The Controller cannot be subclassed,
even though it's in the Kernel.

00:05:08.700 --> 00:05:11.640
This is a location that
has to please everybody.

00:05:11.700 --> 00:05:13.600
So if you go in there changing
it to please your device,

00:05:13.660 --> 00:05:15.700
you're probably going to
make someone else unhappy.

00:05:15.700 --> 00:05:18.700
So don't even think about trying
to subclass the Controller.

00:05:18.700 --> 00:05:22.700
This does mean if you make add-in cards,
be sure to pick silicon that works.

00:05:23.850 --> 00:05:25.620
Now, moving up from the family protocols.

00:05:25.710 --> 00:05:28.090
This is where things
start to differentiate.

00:05:28.110 --> 00:05:30.670
If you're a camcorder
or an iPod or a printer,

00:05:30.720 --> 00:05:33.690
you start to have a different
personality at this layer.

00:05:33.690 --> 00:05:36.220
For example, SBP,
the Serial Bus Protocol,

00:05:36.220 --> 00:05:38.890
is what's used by storage
devices like the iPod,

00:05:38.890 --> 00:05:40.130
hard disk drives.

00:05:40.130 --> 00:05:44.730
It's also used by other SCSI type devices
like scanners or printers on FireWire.

00:05:44.730 --> 00:05:48.350
In comparison, the AVC command set
is used by camcorders,

00:05:48.350 --> 00:05:52.500
TV sets, digital VCRs,
sort of consumer electronic devices.

00:05:53.160 --> 00:05:56.460
Each of these has a service layer
that sits on top of the FireWire

00:05:56.460 --> 00:05:59.900
family that provides all the basics of
that protocol so that you don't have

00:05:59.900 --> 00:06:03.230
to reinvent it from scratch just to
communicate with that particular device.

00:06:03.300 --> 00:06:08.620
These layers also perform
protocol-specific matching services.

00:06:08.620 --> 00:06:11.020
Now, we don't have our own matching.

00:06:11.160 --> 00:06:14.490
We use I/O Kit for everything,
but these layers know how

00:06:14.490 --> 00:06:17.870
to take a closer look at,
say, an AVC device and figure

00:06:17.930 --> 00:06:19.620
out what subunits it has.

00:06:19.620 --> 00:06:21.540
Is it a tape or a VCR or a TV?

00:06:22.620 --> 00:06:25.450
This information goes into the
registry so that you can use I/O Kit to

00:06:25.450 --> 00:06:26.990
match properly to your device.

00:06:29.520 --> 00:06:33.030
Finally, outside the Kernel,
we provide a variety of User Clients.

00:06:33.120 --> 00:06:35.100
Officially,
these are known as Device Interfaces,

00:06:35.120 --> 00:06:36.830
but everyone seems to
call them User Clients,

00:06:36.830 --> 00:06:37.760
so we'll do that here.

00:06:39.120 --> 00:06:42.940
This is a way to hook into all the
FireWire services in the Kernel

00:06:42.940 --> 00:06:47.620
from an application or from your
plug-in that's running in the context

00:06:47.640 --> 00:06:49.990
of an application in User Space.

00:06:50.000 --> 00:06:52.990
Just about everything you can
do in the Kernel in FireWire,

00:06:53.000 --> 00:06:56.950
you can also do from User Space and
you'll find it's usually a lot easier.

00:06:57.000 --> 00:07:00.000
There's direct APIs for
sending and receiving packets.

00:07:00.000 --> 00:07:04.990
You can also access the protocols
like SPP and AVC from User Space.

00:07:05.000 --> 00:07:09.000
When you do this,
you're not using a copy of the services.

00:07:09.130 --> 00:07:12.940
You're not using some user
safe version of the services.

00:07:13.000 --> 00:07:17.000
You're using the real SPP2 or the
real AVC that's in the Kernel.

00:07:17.000 --> 00:07:18.990
So you're going to get
the exact same behavior,

00:07:19.090 --> 00:07:20.000
the same performance.

00:07:20.000 --> 00:07:23.990
Places where buffers have to move
across the User Kernel boundary,

00:07:23.990 --> 00:07:25.000
we map memory.

00:07:25.000 --> 00:07:26.000
We don't copy your data across.

00:07:26.000 --> 00:07:29.990
We just map it directly into the
DMA so data moves as fast as it can.

00:07:30.000 --> 00:07:32.750
Writing and debugging your software
out in User Space is much easier

00:07:32.860 --> 00:07:34.770
than doing so in the Kernel.

00:07:35.000 --> 00:07:36.260
So please do that if you can.

00:07:39.380 --> 00:07:41.320
Somebody wasn't listening to
the announcement before we

00:07:41.320 --> 00:07:42.650
started about cell phones.

00:07:42.680 --> 00:07:44.800
Now, how does driver matching work?

00:07:44.860 --> 00:07:48.070
As I said,
we use standard I-O kit services.

00:07:48.080 --> 00:07:51.290
There's nothing special about FireWire
like we had in Mac OS 9 where we had

00:07:51.290 --> 00:07:52.640
our own unique FireWire matching.

00:07:52.640 --> 00:07:54.770
In Mac OS X, it's all just I-O kit.

00:07:54.820 --> 00:07:58.610
But we put FireWire-specific
information in the I-O registry so you

00:07:58.820 --> 00:08:02.810
can find the unit directory in your
device or the vendor ID or the GUID,

00:08:02.870 --> 00:08:04.790
all the FireWire
information that you expect.

00:08:04.800 --> 00:08:09.460
The FireWire family discovers nodes
on the bus that have configuration

00:08:09.460 --> 00:08:13.690
ROMs and creates a device object for
each one of them in the I-O registry.

00:08:13.780 --> 00:08:17.980
It then scans the ROM further,
and if it finds unit directories,

00:08:17.980 --> 00:08:21.200
it creates unit objects,
typically one per device,

00:08:21.200 --> 00:08:22.410
but there could be more than one.

00:08:22.420 --> 00:08:26.380
The unit is where you start to
differentiate whether you become

00:08:26.380 --> 00:08:28.440
SBP2 or AVC or something else.

00:08:28.460 --> 00:08:32.010
So the appropriate protocol layer loads,
and it takes a further

00:08:32.010 --> 00:08:33.420
examination of the device.

00:08:33.420 --> 00:08:36.520
If the SBP2 layer loads like
is shown in the picture,

00:08:36.520 --> 00:08:40.720
it will create a target object,
then it will scan the device further

00:08:40.720 --> 00:08:44.240
and create logical unit objects
with SBP-specific information,

00:08:44.250 --> 00:08:46.880
such as the device type,
whether it's a disk or

00:08:46.960 --> 00:08:48.400
a tape or a printer.

00:08:48.400 --> 00:08:50.910
So the matching is iterative.

00:08:50.920 --> 00:08:53.240
These items build up one
by one in the registry.

00:08:53.240 --> 00:08:56.410
At each stage,
you have the opportunity to do active

00:08:56.520 --> 00:08:59.570
matching if you need to actually talk
to the device and find out whether

00:08:59.570 --> 00:09:01.080
it's really the one you want to drive.

00:09:01.080 --> 00:09:03.440
If you're working in the kernel,
you can do subclassing at

00:09:03.450 --> 00:09:04.690
the various layers as well.

00:09:09.650 --> 00:09:11.620
In addition to the devices
we find on the bus,

00:09:11.680 --> 00:09:16.510
there's also a device in the
registry called the Local Node.

00:09:18.120 --> 00:09:20.960
The local node is there whether
anything is plugged in or not.

00:09:21.020 --> 00:09:23.930
It represents the Macintosh itself,
but it doesn't mean you're

00:09:23.930 --> 00:09:25.000
talking to yourself.

00:09:25.070 --> 00:09:28.080
It's just an all-purpose
portal onto the bus.

00:09:28.080 --> 00:09:30.460
If you want to talk to a
single device out there,

00:09:30.460 --> 00:09:32.930
you should probably match
against that device.

00:09:33.150 --> 00:09:35.650
But if you're talking to several devices,
the local node gives

00:09:35.650 --> 00:09:36.540
you a way to do that.

00:09:36.850 --> 00:09:40.110
For example,
IP over FireWire or the MLan protocol

00:09:40.120 --> 00:09:42.760
or multi-node cluster computing.

00:09:42.760 --> 00:09:45.090
The local node might be a good
way to hook in for those because

00:09:45.180 --> 00:09:47.980
it's always there no matter how
many or how few devices are there.

00:09:48.000 --> 00:09:51.350
The local node might be a good
way to hook in for those because

00:09:51.410 --> 00:09:55.310
it's always there no matter how
many or how few devices are there.

00:09:56.830 --> 00:09:59.700
Now that you've seen the layers
and you know where to hook in,

00:09:59.700 --> 00:10:02.500
where exactly should you
develop your software?

00:10:02.760 --> 00:10:06.700
Your first choice should be to
write software out in user space.

00:10:06.700 --> 00:10:10.780
As I said, just about every service that
we have in FireWire is available

00:10:10.780 --> 00:10:12.690
to a user client in user space.

00:10:12.700 --> 00:10:15.470
IO FireWire Lib is the
primary user client.

00:10:15.470 --> 00:10:19.700
It has direct access to all the
packet send and receive services.

00:10:19.700 --> 00:10:25.690
And there's specific user clients for
AVC and SBP that are listed here as well.

00:10:25.840 --> 00:10:29.190
However, if you're looking to use SBP,
you may instead want to use

00:10:29.250 --> 00:10:30.760
the SCSI Task User Client.

00:10:30.760 --> 00:10:34.800
We'll talk more about that later,
but if your device complies with SAM,

00:10:34.940 --> 00:10:38.400
the SCSI Architecture Model,
SCSI Task User Client is going to be

00:10:38.400 --> 00:10:40.310
a lot easier than SBP2 User Client.

00:10:40.320 --> 00:10:44.750
If you're working in user space,
we have lots of sample code available.

00:10:44.760 --> 00:10:49.110
If you've installed the FireWire SDK,
you can look in this path and you'll find

00:10:49.110 --> 00:10:53.540
all the sample code for writing drivers
and applications out in user space.

00:10:54.680 --> 00:10:57.780
Now, I said writing in user space
should be your first choice.

00:10:57.780 --> 00:10:59.800
You only actually have two choices.

00:10:59.800 --> 00:11:01.780
Writing in the kernel
is your last choice.

00:11:01.780 --> 00:11:03.800
You really don't want to do
this if you can avoid it.

00:11:03.880 --> 00:11:07.760
All FireWire services are available,
and you may need to write in here

00:11:07.760 --> 00:11:11.700
if you're writing a bootable driver,
although we provide one for you,

00:11:11.700 --> 00:11:13.360
so you shouldn't have to.

00:11:13.360 --> 00:11:16.460
If you're writing a networking driver,
same caveat,

00:11:16.460 --> 00:11:19.960
or something else that supports
another kernel service.

00:11:19.960 --> 00:11:22.790
But many kinds of things
simply can't go in the kernel.

00:11:23.200 --> 00:11:25.440
You can't put a printer
driver in the kernel.

00:11:25.540 --> 00:11:28.080
There's no way to hook
it into Print Center.

00:11:28.090 --> 00:11:30.350
The same goes with a scanner driver.

00:11:30.380 --> 00:11:34.120
But if you need to write in the kernel,
you can, and that may give you the

00:11:34.120 --> 00:11:37.970
opportunity to subclass some of the
layers that we have in the kernel.

00:11:38.080 --> 00:11:40.070
For example,
we do this fairly extensively

00:11:40.110 --> 00:11:41.660
in the mass storage class.

00:11:41.660 --> 00:11:46.080
We subclass so that we can provide the
best possible support for each of the

00:11:46.130 --> 00:11:51.300
different kinds of bridge silicon that's
out there in FireWire hard drives.

00:11:51.800 --> 00:11:54.280
Sample code for working
in the kernel is limited.

00:11:54.280 --> 00:11:57.770
Basically all we have to offer is
the source code for FireWire itself,

00:11:57.780 --> 00:11:58.690
which is in Darwin.

00:11:58.700 --> 00:12:01.490
So you can start there and you'll
see how it works and you can

00:12:01.490 --> 00:12:03.090
figure out how to hook into it.

00:12:03.160 --> 00:12:06.810
Debugging and testing is more difficult
in the kernel than in user space.

00:12:06.810 --> 00:12:09.340
If you crash in user space,
you can just run again.

00:12:09.340 --> 00:12:11.420
But if you crash your
driver in the kernel,

00:12:11.420 --> 00:12:13.520
you'll get to reboot the machine.

00:12:13.520 --> 00:12:16.590
That'll give you some time to ponder
when you last ran your backups.

00:12:16.640 --> 00:12:20.720
So you should really develop
out in user space if you can.

00:12:24.960 --> 00:12:27.890
If that wasn't enough incentive,
here's all the sample code

00:12:27.940 --> 00:12:30.020
that we have now in SDK 16.

00:12:30.020 --> 00:12:32.160
Once you've installed SDK 16,
that path is where

00:12:32.160 --> 00:12:33.300
you'll find all of this.

00:12:33.410 --> 00:12:36.090
There's some very general
purpose sample code,

00:12:36.190 --> 00:12:39.330
like FWSampleProject,
it's very non-specific,

00:12:39.330 --> 00:12:40.880
IOFireWireLibBasics.

00:12:40.880 --> 00:12:44.780
If you want to cause trouble,
you can start with the

00:12:44.780 --> 00:12:46.970
ResetStorm sample code.

00:12:47.560 --> 00:12:49.960
We have some new stuff
that's very exciting,

00:12:49.960 --> 00:12:52.650
the DVHS Capture Sample
and the FireWire MPEG.

00:12:52.660 --> 00:12:57.420
If you have FireWire devices like
a Digital VCR or FireWire TV,

00:12:57.490 --> 00:12:58.490
try these out.

00:12:58.590 --> 00:13:00.500
You'll find some really
interesting new capabilities there.

00:13:00.500 --> 00:13:06.050
So whatever you're trying to do,
we've surely got something on this

00:13:06.050 --> 00:13:06.050
list that's a good starting point.

00:13:07.010 --> 00:13:10.170
Now I mentioned
SCSI Task User Client and SAM.

00:13:10.400 --> 00:13:14.900
Lots of devices that use SBP2 also
comply with the SCSI Architecture Model.

00:13:15.000 --> 00:13:17.890
So SCSI Task User Client
may be a lot easier for you.

00:13:17.890 --> 00:13:23.420
If you use SBP2 User Client,
you have to deal with bus resets, logins,

00:13:23.420 --> 00:13:24.810
reconnects and so on.

00:13:24.810 --> 00:13:27.860
All that's handled for you
in SCSI Task User Client.

00:13:27.900 --> 00:13:31.810
You can just form the commands or tasks
and hand them down to have them executed.

00:13:31.980 --> 00:13:35.920
So if you'd like to try that,
this shows where it's located.

00:13:35.920 --> 00:13:39.850
It's inside
ioscssiarchitecturemodelfamily KEXT.

00:13:40.730 --> 00:13:43.970
If your device is some kind
of optical media burner,

00:13:43.970 --> 00:13:46.600
you may want to move to
an even higher level.

00:13:46.600 --> 00:13:50.480
We now have APIs for disk recording,
for DVDR, CDR and so on.

00:13:50.480 --> 00:13:53.600
You can find documentation
as listed there.

00:13:53.600 --> 00:13:56.640
That would be generally even
easier than using SCSI TASK and

00:13:56.640 --> 00:13:58.380
certainly than using SPP2.

00:14:18.040 --> 00:14:18.800
If your device has some SPP2 unique
behavior or it isn't quite SPP2,

00:14:18.800 --> 00:14:18.800
then you may need to move back down
the software stack and use SPP2 itself

00:14:18.800 --> 00:14:18.800
or even the basic FireWire APIs.

00:14:18.800 --> 00:14:18.800
Whatever your device does,
there is some way we provide that

00:14:18.800 --> 00:14:18.800
you can hook into it and there may
be several ways to choose from.

00:14:25.070 --> 00:14:30.100
New this year, possibly late last year,
TCP/IP, the Internet Protocol.

00:14:30.120 --> 00:14:33.190
We now support this on FireWire.

00:14:33.530 --> 00:14:34.910
This is an industry standard.

00:14:34.980 --> 00:14:37.220
IEEE standard 2734.

00:14:37.500 --> 00:14:38.500
It's very straightforward.

00:14:38.500 --> 00:14:39.370
It's only a few pages.

00:14:39.370 --> 00:14:43.130
It shows how to send
IP datagrams on FireWire.

00:14:43.130 --> 00:14:46.050
You can get it at the
IEEE website if you want.

00:14:48.010 --> 00:14:52.040
Internet Datagrams are simply
packaged up in FireWire block writes.

00:14:52.090 --> 00:14:56.160
Each FireWire node that supports
IP allocates an address in

00:14:56.160 --> 00:15:00.040
its own address space where
it will receive these packets.

00:15:00.110 --> 00:15:03.740
And that address is published in the
node's configuration ROM so that other

00:15:03.740 --> 00:15:05.550
nodes on the bus can discover it.

00:15:05.560 --> 00:15:09.180
So our driver finds all the
other nodes that speak IP and

00:15:09.230 --> 00:15:11.570
then can send datagrams to them.

00:15:12.520 --> 00:15:14.280
Broadcast packets are supported.

00:15:14.400 --> 00:15:16.920
That's used, for example, for ARP,
the Address Resolution Protocol.

00:15:16.920 --> 00:15:20.540
That's done with a FireWire
asynchronous stream packet.

00:15:20.540 --> 00:15:24.640
It's like an isochronous packet,
but it's not sent in real time,

00:15:24.810 --> 00:15:27.100
so no reservation is required.

00:15:27.100 --> 00:15:28.230
So it's fine for ARP.

00:15:28.230 --> 00:15:31.260
It's also very low bandwidth,
so it doesn't interfere

00:15:31.310 --> 00:15:32.600
with anything else.

00:15:33.870 --> 00:15:37.310
So, in the case of 1394A,
set aside isochronous channel

00:15:37.310 --> 00:15:40.820
number 31 for this purpose
and certain related purposes.

00:15:40.820 --> 00:15:43.750
If you have a device that's
hardwired to channel 31,

00:15:43.820 --> 00:15:45.330
I don't know of any,
you're going to have to

00:15:45.330 --> 00:15:46.050
move to another channel.

00:15:46.060 --> 00:15:49.240
But you'll see these packets in
Firebug as isochronous packets.

00:15:49.240 --> 00:15:51.760
They're actually
asynchronous stream packets.

00:15:51.760 --> 00:15:54.520
Firebug can't tell whether it
was sent in real time or not.

00:15:54.690 --> 00:15:58.400
It only knows when it arrived,
so it shows it as if it was isochronous.

00:16:00.890 --> 00:16:01.690
So what's this good for?

00:16:01.690 --> 00:16:04.570
The Internet's good for a lot of things.

00:16:04.660 --> 00:16:06.630
Everyone you ask will have
a different favorite use.

00:16:07.110 --> 00:16:08.130
There's no restriction here.

00:16:08.300 --> 00:16:12.190
We support IP, so anything that runs on
IP should run on IP over FireWire.

00:16:12.200 --> 00:16:15.740
HTTP protocol,
file services like FTP or AFP,

00:16:15.740 --> 00:16:17.390
whatever you want.

00:16:17.420 --> 00:16:21.700
Now you may find this interesting if
you're presently using target disk mode.

00:16:21.700 --> 00:16:27.750
Using AFP or personal file sharing,
you may want to investigate that.

00:16:27.790 --> 00:16:29.410
Is it faster?

00:16:29.530 --> 00:16:30.160
That depends.

00:16:30.160 --> 00:16:32.050
You don't have to reboot twice,
so that may help,

00:16:32.190 --> 00:16:34.490
but you do have to log in and
set up personal file sharing.

00:16:34.500 --> 00:16:36.610
The actual performance is
likely to depend on the

00:16:36.610 --> 00:16:39.310
kind of files you're moving,
how much of the CPU you're using,

00:16:39.310 --> 00:16:39.810
and so on.

00:16:39.810 --> 00:16:40.680
So give this a try.

00:16:40.680 --> 00:16:42.330
You may find it to your liking.

00:16:42.340 --> 00:16:46.440
Many cluster computing APIs use IP.

00:16:47.330 --> 00:16:48.600
Because it's ubiquitous.

00:16:48.800 --> 00:16:51.260
Nobody makes a computer
that doesn't have TCP/IP,

00:16:51.260 --> 00:16:53.100
or they certainly don't
sell very many of them.

00:16:53.100 --> 00:16:56.980
So if you have a cluster computing
application that you'd like to run

00:16:56.980 --> 00:17:00.450
on FireWire and it's based on IP,
you can run it immediately

00:17:00.450 --> 00:17:01.740
on IP over FireWire.

00:17:01.740 --> 00:17:05.320
However,
FireWire's direct memory access model,

00:17:05.320 --> 00:17:08.810
where memory space is
visible on the FireWire bus,

00:17:08.810 --> 00:17:13.800
is very well suited for certain kinds
of cluster computing that exchange

00:17:13.800 --> 00:17:16.260
a lot of data between the nodes.

00:17:17.120 --> 00:17:19.260
So if that's the kind you're doing,
IP will work,

00:17:19.260 --> 00:17:23.670
but you may get the best performance
by going to a FireWire native solution.

00:17:24.700 --> 00:17:26.420
So how do you get this configured?

00:17:26.490 --> 00:17:28.480
Like any other IP interface,
you start in the

00:17:28.480 --> 00:17:34.900
Network Preferences Panel.

00:17:35.770 --> 00:17:38.940
In the upper left,
there's a pop-up menu called Show.

00:17:38.940 --> 00:17:42.300
If you'd pick that, at the bottom,
there's always something called

00:17:42.300 --> 00:17:43.700
Network Port Configurations.

00:17:43.850 --> 00:17:45.740
You've probably mostly tried this.

00:17:45.770 --> 00:17:49.420
Once you pick that,
you'll find FireWire is in

00:17:49.420 --> 00:17:51.200
your list of network ports.

00:17:51.220 --> 00:17:54.610
Unless you're running Mac OS 10.2,
in which case you may instead

00:17:54.680 --> 00:17:56.730
find Ethernet Adapter EN2.

00:17:56.960 --> 00:17:58.760
We're working on that.

00:17:59.020 --> 00:18:03.090
If you see that, just double-click on it
and rename it to FireWire.

00:18:03.370 --> 00:18:05.800
Once you've done that,
and be sure to turn on the checkbox,

00:18:05.800 --> 00:18:09.700
you can then drag FireWire to the
top of the list if you'd like to use

00:18:09.700 --> 00:18:13.400
Rendezvous to automatically provide
an IP address for your FireWire port.

00:18:13.400 --> 00:18:15.470
Just drag it up to the
top like is shown there.

00:18:15.480 --> 00:18:18.100
Then if you'd like to
further configure it,

00:18:18.100 --> 00:18:22.560
go back to the network port pop-up
and just pick FireWire from the list.

00:18:22.580 --> 00:18:25.150
Then you can select your IP address
or whatever else you like.

00:18:25.960 --> 00:18:33.390
Now, in Mac OS 10.2, it will allow you to
configure AppleTalk and PPPoE,

00:18:33.390 --> 00:18:37.120
not F-E, and neither of those make
any sense on FireWire,

00:18:37.120 --> 00:18:38.100
so ignore those.

00:18:38.140 --> 00:18:40.220
You can try to set them up,
but they won't do anything.

00:18:40.220 --> 00:18:42.540
We fixed this all in Mac OS 10.3.

00:18:42.540 --> 00:18:46.460
Here's where we have deployed
support for IP on FireWire.

00:18:46.460 --> 00:18:48.450
There's two developer preview releases.

00:18:48.450 --> 00:18:50.500
They're available
through the ADC website.

00:18:50.550 --> 00:18:52.010
Anybody can download those.

00:18:52.010 --> 00:18:53.870
They run on 10.2.5.

00:18:55.730 --> 00:18:59.480
It is also included in
Mac OS X Server version 10.2.5 and

00:18:59.480 --> 00:19:01.780
it's pre-installed on every XServe.

00:19:01.820 --> 00:19:07.300
In Mac OS 10.3, it is pre-installed for
everybody using the seed that you

00:19:07.300 --> 00:19:09.280
received from this conference.

00:19:09.280 --> 00:19:11.290
You can go turn it on and
try it out right away.

00:19:27.510 --> 00:19:27.530
In Mac OS X version 10.3,
we have fixed all the little user

00:19:27.530 --> 00:19:27.530
interface issues because we were
able to change everything at once

00:19:27.530 --> 00:19:27.530
rather than just adding our new text.

00:19:27.530 --> 00:19:27.530
And we've added support for
IPv6 and we've improved the

00:19:27.530 --> 00:19:27.530
performance quite a bit.

00:19:27.530 --> 00:19:27.530
Let's look at that.

00:19:27.960 --> 00:19:31.460
Now, this is somewhere where the Ethernet
guys have a big advantage over us.

00:19:31.500 --> 00:19:33.060
Ethernet is an IP network.

00:19:33.120 --> 00:19:35.600
Hardly anyone uses it for anything else.

00:19:35.760 --> 00:19:39.030
Ethernet hardware is designed
for optimal transmission and

00:19:39.100 --> 00:19:40.800
reception of IP datagrams.

00:19:41.010 --> 00:19:42.020
FireWire hardware is not.

00:19:42.300 --> 00:19:47.900
It's designed to do everything: iPods,
camcorders, still cameras, TVs.

00:19:48.010 --> 00:19:51.190
It can do a lot of things really well,
but it's not customized for IP.

00:19:51.310 --> 00:19:53.900
So we had a little bit of a
disadvantage when we started.

00:19:54.120 --> 00:19:55.890
So how do we do?

00:19:56.200 --> 00:19:59.650
In the first preview release,
our standard benchmark is to

00:19:59.650 --> 00:20:02.100
run NetPerf between two X-SERVs.

00:20:02.100 --> 00:20:06.100
The first preview release on 10.2.4
could get 216 megabits per second.

00:20:06.100 --> 00:20:08.160
That's more than half
of the FireWire bus.

00:20:08.200 --> 00:20:08.820
It's not bad.

00:20:08.820 --> 00:20:12.120
And in fact, if you were running this
on your iBook or your eMac,

00:20:12.410 --> 00:20:16.080
that's twice as fast as the
built-in 100 megabit Ethernet port.

00:20:16.090 --> 00:20:18.460
So this already may be very
useful to a lot of people.

00:20:18.460 --> 00:20:20.350
But of course, we'd like to go faster.

00:20:21.700 --> 00:20:25.170
In the second preview release and
what's in Mac OS 10.2.5 Server,

00:20:25.200 --> 00:20:27.430
we got that up to 277
megabits per second.

00:20:27.430 --> 00:20:29.120
We're never going to hit 400.

00:20:29.120 --> 00:20:32.420
There's overhead, there's arbitration,
there's acknowledgements.

00:20:32.420 --> 00:20:36.410
We're going to get somewhere in the 300s,
but we're never going to hit 400.

00:20:36.410 --> 00:20:38.290
But we're going to keep trying.

00:20:39.000 --> 00:20:41.160
So how have we done for Mac OS 10.3?

00:20:41.160 --> 00:20:41.790
Same test.

00:20:41.790 --> 00:20:44.100
We're now up to 317 megabits per second.

00:20:44.130 --> 00:20:48.090
And if you hook up the FireWire 800 ports
that are now included on the X-SERV,

00:20:48.100 --> 00:20:51.030
we're getting 660 megabits per second.

00:20:51.700 --> 00:20:54.400
Now these are preliminary and
they're benchmark numbers,

00:20:54.400 --> 00:20:56.500
so nothing will ever go
this fast in real life.

00:20:56.500 --> 00:20:59.780
But you can see we're making it a lot
faster and it's really getting very

00:20:59.780 --> 00:21:01.550
competitive with gigabit Ethernet.

00:21:01.550 --> 00:21:04.580
So if you want to run IP on FireWire,
we think we've put you in pretty

00:21:04.580 --> 00:21:06.070
good shape to try that out.

00:21:08.910 --> 00:21:11.150
Next, Isochronous Services.

00:21:11.230 --> 00:21:14.030
Every year we talk about the fact that
we have Isochronous Services and we

00:21:14.050 --> 00:21:16.800
say they're complicated and we kind of
gloss over how you actually use them.

00:21:16.800 --> 00:21:19.850
This year we're going to go
into depth and try to explain

00:21:19.850 --> 00:21:21.530
the basics of how it works.

00:21:22.320 --> 00:21:26.510
We have something called a
Data Stream Control Language,

00:21:26.510 --> 00:21:27.100
DCL.

00:21:27.160 --> 00:21:32.190
Isochronous transfer on FireWire sends
or receives 8,000 packets per second.

00:21:32.420 --> 00:21:36.170
Each one is very precisely
spaced on the FireWire bus.

00:21:36.270 --> 00:21:39.140
You wouldn't want to do this through
some kind of system call API.

00:21:39.190 --> 00:21:42.050
8,000 system calls per second,
even if you can do it,

00:21:42.050 --> 00:21:44.630
is very expensive and it's
going to be almost impossible to

00:21:44.660 --> 00:21:47.720
get them at the right time and
meet your real-time guarantee.

00:21:47.740 --> 00:21:49.290
So that's just not how it's designed.

00:21:49.290 --> 00:21:50.720
Nobody's ever done it that way.

00:21:50.720 --> 00:21:55.600
We have hardware that can send or
receive the packets according to a fixed

00:21:55.600 --> 00:21:57.760
program of when they should appear.

00:21:57.760 --> 00:21:59.940
But that hardware is also complicated.

00:21:59.940 --> 00:22:03.130
So it has different register
sets on different models of Mac,

00:22:03.230 --> 00:22:06.790
requires taking interrupts,
knowing physical memory addresses.

00:22:06.790 --> 00:22:08.760
You don't want to be exposed to it.

00:22:08.820 --> 00:22:11.100
That's what DCLs solve.

00:22:11.130 --> 00:22:17.070
A DCL is an abstract description
of data flow on FireWire.

00:22:17.070 --> 00:22:21.540
A DCL program that you write in memory,
describes on a

00:22:21.610 --> 00:22:25.200
packet-by-packet basis how,
where, and when you'd like to

00:22:25.210 --> 00:22:26.250
send or receive data.

00:22:26.270 --> 00:22:30.360
You write the program, you hand it to us,
we figure out how to make the

00:22:30.360 --> 00:22:31.940
hardware do what you told us to.

00:22:31.940 --> 00:22:33.060
So it's very precise.

00:22:33.060 --> 00:22:35.900
It gives you packet-level control,
but you don't have to make

00:22:35.980 --> 00:22:37.320
frequent system calls.

00:22:37.320 --> 00:22:39.530
You don't have to hit
real-time guarantees yourself,

00:22:39.540 --> 00:22:41.540
at least not 8,000 times per second.

00:22:43.280 --> 00:22:46.950
A DCL program is a linked list of
operations and they're going to execute

00:22:47.000 --> 00:22:49.200
in the order of the linked list.

00:22:49.370 --> 00:22:52.380
Each operation in there
does one basic thing.

00:22:52.400 --> 00:22:55.200
It sends a packet or
it receives a packet,

00:22:55.200 --> 00:22:57.200
though you can't mix
those in a single program,

00:22:57.200 --> 00:23:00.060
or it may invoke a callback
to tell you that it's reached

00:23:00.060 --> 00:23:03.750
a certain point in a program,
or it may jump to another DCL if you

00:23:03.760 --> 00:23:07.010
don't want to run the program exactly
in the order that it's written.

00:23:07.200 --> 00:23:10.510
For example,
you can make a loop and jump back

00:23:10.540 --> 00:23:11.930
to the top so that you keep going.

00:23:13.810 --> 00:23:17.080
We will compile your DCL program
to execute natively on whatever

00:23:17.080 --> 00:23:19.300
hardware we actually have.

00:23:19.300 --> 00:23:21.360
But because of this,
there's some restrictions to what you

00:23:21.400 --> 00:23:23.100
can do while the program is running.

00:23:23.100 --> 00:23:26.290
If you make changes to the source,
they won't necessarily affect the

00:23:26.290 --> 00:23:28.300
DMA unless you tell us what you've done.

00:23:28.460 --> 00:23:31.700
And there's some limitations on
the kind of change you can make.

00:23:31.700 --> 00:23:34.170
Here's a picture.

00:23:34.810 --> 00:23:38.640
Here's a DCL shown on the left
as a linked list of operations.

00:23:38.640 --> 00:23:41.660
The solid arrows pointing
down are the linked list.

00:23:42.180 --> 00:23:45.700
Very important, at the bottom you can
see it links to zero.

00:23:45.700 --> 00:23:48.460
If you link it back to the top,
the compiler will hang trying

00:23:48.490 --> 00:23:51.170
to find the end of your program,
so please don't forget to

00:23:51.170 --> 00:23:52.640
link it to zero at the end.

00:23:54.380 --> 00:23:55.880
The last instruction, though,
is a jump instruction,

00:23:55.880 --> 00:23:57.880
and you can see the dotted
line going up to the top,

00:23:57.980 --> 00:23:59.350
which is a label instruction.

00:23:59.360 --> 00:24:01.920
This causes the program
to run in an endless loop,

00:24:01.970 --> 00:24:04.950
even though it's only actually
about nine steps long.

00:24:06.080 --> 00:24:08.180
This program sends data continuously.

00:24:08.180 --> 00:24:11.350
All of the operations that move
packets are send operations.

00:24:11.410 --> 00:24:14.070
Each one points to a buffer
that contains a packet.

00:24:14.920 --> 00:24:19.160
Interspersed between the send
operations are call proc operations.

00:24:20.710 --> 00:24:24.710
After sending three packets,
this program will cause your

00:24:24.830 --> 00:24:28.600
callback to be executed and you'll
know that those three packets

00:24:28.600 --> 00:24:30.600
have been delivered onto the bus.

00:24:30.600 --> 00:24:33.800
This gives you the opportunity,
in a looping program like this,

00:24:33.800 --> 00:24:36.990
to update those three buffers
so that the next time through

00:24:36.990 --> 00:24:38.710
they send something fresh.

00:24:41.850 --> 00:24:44.440
Time waits for nobody,
and neither does the DMA.

00:24:44.440 --> 00:24:48.450
It's really important to understand
when you write these programs.

00:24:48.710 --> 00:24:52.000
Packets 1,
2 and 3 are sent approximately 125

00:24:52.000 --> 00:24:56.570
microseconds apart on the FireWire
bus and then we call your callback.

00:24:56.690 --> 00:24:58.460
But we also send packet number 4.

00:24:58.460 --> 00:25:00.600
We don't wait for your
callback to finish.

00:25:00.600 --> 00:25:03.700
Your callback may not have even started
yet when we get to packet number 4

00:25:03.820 --> 00:25:06.810
if it's on your work loop and you're
waiting for something else to run.

00:25:07.160 --> 00:25:10.150
The DMA is going to march through
those packets exactly on time

00:25:10.150 --> 00:25:11.960
according to the FireWire clock.

00:25:11.980 --> 00:25:16.720
This means if your callback is going to
fill in new data for buffers number 1,

00:25:16.720 --> 00:25:19.300
2 and 3, you have to do so quickly.

00:25:19.300 --> 00:25:22.270
Now, an ordinary program is
not really this small.

00:25:22.270 --> 00:25:25.780
This program sends only three
packets and then has a callback.

00:25:25.870 --> 00:25:31.030
So at 8,000 packets per second,
you'd have 2,700 callbacks per second.

00:25:31.120 --> 00:25:33.660
That's really a little too fine grained.

00:25:33.680 --> 00:25:37.120
Typical program will have 20 to 200.

00:25:37.160 --> 00:25:39.260
So you'd have 2,700
packets for each callback.

00:25:39.300 --> 00:25:42.780
And that depends on the latency that
you need in processing the packets.

00:25:42.820 --> 00:25:45.510
Typical program may also
have more than two clusters.

00:25:45.510 --> 00:25:48.540
It might have three or four so
that you have a little more time.

00:25:48.540 --> 00:25:52.540
There's less danger of the DMA wrapping
around and catching you by surprise.

00:25:55.120 --> 00:25:57.350
There's another thing in the
program that I'm not showing because

00:25:57.370 --> 00:25:59.290
it doesn't fit on that slide,
so let's zoom in.

00:25:59.300 --> 00:26:03.450
Very important is an update DCL.

00:26:03.460 --> 00:26:04.590
Update the DCL.

00:26:05.460 --> 00:26:08.200
If you change the contents of
one of the transmit buffers

00:26:08.240 --> 00:26:11.400
while the program is running,
we need to know about it.

00:26:11.400 --> 00:26:13.360
In particular,
we usually have to byte swap the

00:26:13.470 --> 00:26:16.310
header so that the transmitter will
be able to pick it up over PCI where

00:26:16.310 --> 00:26:18.400
everything ends up getting byte swapped.

00:26:18.400 --> 00:26:21.210
So after every callback
in a transmit program,

00:26:21.210 --> 00:26:23.400
typically you'll have an update.

00:26:23.400 --> 00:26:27.400
This doesn't take any time
from the DMA's point of view.

00:26:27.400 --> 00:26:31.890
It still just marches through from
send number 3 to send number 4.

00:26:32.230 --> 00:26:36.030
The update, though,
tells the FireWire family that

00:26:36.040 --> 00:26:40.500
some previous or some DCLs in
the program may have changed.

00:26:40.640 --> 00:26:44.330
The update instruction has a list
of pointers to other instructions.

00:26:44.370 --> 00:26:48.100
You can see here it points to the
three send operations just before.

00:26:48.100 --> 00:26:50.170
You don't have to tell us what changed.

00:26:50.270 --> 00:26:56.410
We'll figure that out because we
know what kind of operation they are,

00:26:56.410 --> 00:26:56.410
but you do have to tell
us when they've changed.

00:26:57.710 --> 00:27:02.190
The callback will execute to
completion before the update happens.

00:27:02.190 --> 00:27:05.410
They're both done in the CPU,
so even though the DMA may have marched

00:27:05.410 --> 00:27:08.580
on many packets into the future,
your callback will finish

00:27:08.580 --> 00:27:10.280
before the update happens.

00:27:11.930 --> 00:27:15.490
In a transmit DCL, you have to update the
packets before they get sent.

00:27:15.490 --> 00:27:17.940
In a receive DCL,
you have to update the packets

00:27:17.940 --> 00:27:21.190
after they've been received,
but before you look at them.

00:27:21.210 --> 00:27:23.010
If you don't do this,
or if you get out of

00:27:23.010 --> 00:27:25.750
sequence with the updates,
you may find packets that don't

00:27:25.750 --> 00:27:28.790
make any sense because we haven't
byteswapped the headers or done

00:27:28.790 --> 00:27:30.560
other necessary adjustments.

00:27:34.930 --> 00:27:36.800
DCL programs don't have to loop.

00:27:36.800 --> 00:27:39.020
You could have a one-shot program,
that's very rare,

00:27:39.020 --> 00:27:42.370
or you can change the jumps on
the fly in order to keep feeding

00:27:42.370 --> 00:27:46.080
new data to the DCL engine without
ever actually making a loop.

00:27:46.140 --> 00:27:48.240
That's what our DV transmitter does.

00:27:48.240 --> 00:27:50.380
You'd never want to send stale DV data.

00:27:50.390 --> 00:27:52.770
Every packet has a sequence number in it.

00:27:52.780 --> 00:27:55.930
So we make sure that the
program always ends somewhere,

00:27:55.930 --> 00:27:59.590
and if we fall behind,
the DMA is going to hit the end and stop.

00:27:59.630 --> 00:28:03.380
So we won't confuse any TV or camcorder,
we'll just stop sending data.

00:28:03.380 --> 00:28:07.200
Of course, our goal is to never let that
happen and just keep running,

00:28:07.260 --> 00:28:08.590
which we usually do.

00:28:09.340 --> 00:28:12.120
There's another operation
called a timestamp.

00:28:12.290 --> 00:28:15.980
This is something you can insert
into the program if you want to

00:28:15.980 --> 00:28:20.180
find out exactly what time it was
when the DMA reached that point.

00:28:20.240 --> 00:28:23.190
You could use a timestamp,
which returns the FireWire cycle time,

00:28:23.200 --> 00:28:26.420
to synchronize two programs or
synchronize a program with some

00:28:26.420 --> 00:28:29.890
external activity or to make sure
that the program is really running

00:28:29.890 --> 00:28:33.580
on time and you're not losing
packets or having some other problem.

00:28:34.360 --> 00:28:36.890
Timestamps also have to be updated
before you look at them because

00:28:36.890 --> 00:28:39.700
they're generated by hardware,
so they may come in byteswapped or

00:28:39.700 --> 00:28:42.440
they may need other modification
before they're accurate.

00:28:45.660 --> 00:28:49.590
In Mac OS 10.3,
we're adding a new kind of DCL.

00:28:49.710 --> 00:28:53.570
DCLs were invented about seven years ago,
back when we didn't have OHCI,

00:28:53.710 --> 00:28:57.190
so they're very flexible,
so that we had room for growth.

00:28:57.190 --> 00:29:00.560
Now we have OHCI everywhere,
and that's not going to change.

00:29:00.560 --> 00:29:04.000
So we've adapted DCLs to
really fit well on OHCI.

00:29:04.870 --> 00:29:07.060
Previously,
there were a lot of hidden rules in DCLs,

00:29:07.060 --> 00:29:11.040
like a label had to be immediately
followed by a send op or a receive op.

00:29:11.120 --> 00:29:13.640
The compiler didn't enforce that,
but if you forgot,

00:29:13.640 --> 00:29:15.060
your program wouldn't work.

00:29:15.130 --> 00:29:17.120
It wasn't hard to code
around these rules,

00:29:17.190 --> 00:29:19.230
but it was hard to
remember to follow them.

00:29:19.240 --> 00:29:21.650
The new style DCLs map much
better to the hardware,

00:29:21.680 --> 00:29:23.560
so they don't have this kind of rule.

00:29:23.560 --> 00:29:26.370
The new style DCL has one
operation for each cycle.

00:29:26.390 --> 00:29:29.660
It's going to send or receive a packet,
or do nothing at all,

00:29:29.820 --> 00:29:31.310
if that's what you want.

00:29:31.320 --> 00:29:34.610
And for that one operation,
you have one call.

00:29:34.620 --> 00:29:36.610
You can send one call
back if you want it,

00:29:36.650 --> 00:29:39.670
one update, one time stamp,
you get one of everything.

00:29:39.880 --> 00:29:40.800
This is being added.

00:29:40.800 --> 00:29:41.560
Mac OS X 10.3.

00:29:41.560 --> 00:29:45.810
It's not yet in the SDK,
but we will have it out there soon.

00:29:46.110 --> 00:29:49.330
Because it maps better to the hardware,
we can now do some new things

00:29:49.330 --> 00:29:50.600
too that we couldn't do before.

00:29:50.600 --> 00:29:53.750
In particular,
we can give you the error status

00:29:53.840 --> 00:29:56.530
for any particular packet,
which may be very important if

00:29:56.530 --> 00:30:01.490
you have to check data integrity,
and we can let you change the length

00:30:01.560 --> 00:30:05.000
of the packets in a transmit program,
which was really difficult to do before.

00:30:05.000 --> 00:30:07.420
The old style of DCL will
still be supported,

00:30:07.420 --> 00:30:11.410
but they are compiled into the new style,
so if you're doing anything new,

00:30:11.410 --> 00:30:15.050
as soon as the new style is available,
you should try to use it.

00:30:17.610 --> 00:30:22.500
We have new services for AVC.

00:30:22.680 --> 00:30:26.320
First of all,
if you need to manage plugs,

00:30:26.320 --> 00:30:29.590
these are connections established
between devices on the FireWire bus

00:30:29.590 --> 00:30:33.640
that represent an ongoing data flow
isochronously between two devices.

00:30:33.640 --> 00:30:36.340
We have APIs now to make that easier.

00:30:36.500 --> 00:30:41.550
You can call these APIs to establish
input or output plugs and we will take

00:30:41.560 --> 00:30:44.460
care of them so that they remain set up.

00:30:44.960 --> 00:30:51.240
Every bus reset invalidates all
the plugs that are out there and

00:30:51.240 --> 00:30:52.500
they have to be re-established.

00:30:52.500 --> 00:30:55.720
So if you've used these APIs,
we'll do that for you.

00:30:55.750 --> 00:30:58.260
You don't have to keep tracking them.

00:30:58.260 --> 00:30:58.260
So that should make it easier.

00:30:58.390 --> 00:31:02.480
We've also added a lot of stuff
to help you become an AVC target.

00:31:02.520 --> 00:31:04.480
Up till now,
the Mac has been really good at

00:31:04.480 --> 00:31:06.290
telling other devices what to do.

00:31:06.340 --> 00:31:09.290
Camcorders should play,
tuners should go to Channel 37 and so on.

00:31:09.290 --> 00:31:12.070
But AVC, some of those devices
want to control the Mac,

00:31:12.130 --> 00:31:15.300
or they may if you write software
that makes the Mac do something

00:31:15.300 --> 00:31:17.220
interesting when they talk to you.

00:31:17.940 --> 00:31:20.500
So we have APIs to help you do that.

00:31:20.670 --> 00:31:24.570
Publish AVC Unit Directory causes
the Mac to publish in its own

00:31:24.570 --> 00:31:28.310
config ROM a unit directory telling
everyone that it speaks AVC and

00:31:28.310 --> 00:31:30.580
you can send commands to it.

00:31:30.760 --> 00:31:34.360
Add Subunit adds an AVC subunit
to the Mac so that when someone

00:31:34.370 --> 00:31:37.730
asks us what subunits we have,
we'll respond accordingly,

00:31:37.730 --> 00:31:40.170
that we have a tape subunit
or a tuner subunit or whatever

00:31:40.180 --> 00:31:41.460
it is that you've added.

00:31:41.460 --> 00:31:44.370
Now, you'd actually call those
in the reverse order.

00:31:44.380 --> 00:31:46.460
First add your subunits, then publish.

00:31:46.470 --> 00:31:48.730
Otherwise, you may start getting
requests before you're ready.

00:31:48.740 --> 00:31:51.000
The Publish API will cause a bus reset.

00:31:51.000 --> 00:31:54.130
That's how AVC lets everybody
know that something new is

00:31:54.130 --> 00:31:56.250
available or might be available.

00:31:59.010 --> 00:32:01.010
If you want to handle
commands that come in,

00:32:01.020 --> 00:32:03.900
say, to the subunit that you've added,
you can use these APIs.

00:32:03.900 --> 00:32:08.350
You can install a command handler,
and you can specify which subunit and

00:32:08.350 --> 00:32:11.260
which opcodes you're going to handle,
and there's wildcards so you don't

00:32:11.260 --> 00:32:12.750
have to enumerate everything.

00:32:12.760 --> 00:32:15.310
And, very important,
most things that you get

00:32:15.310 --> 00:32:18.940
require some kind of response,
so you can now call sendABCResponse

00:32:18.940 --> 00:32:22.590
to send that response back to the
device to tell it what happened with

00:32:22.600 --> 00:32:24.630
that command that it sent to you.

00:32:29.410 --> 00:32:32.900
We handle all of these
commands automatically,

00:32:33.060 --> 00:32:35.040
but there is a mechanism for
you to handle them too if

00:32:35.100 --> 00:32:36.100
you know what you're doing.

00:32:36.120 --> 00:32:39.470
For example, Unit Info and Subunit
Info there at the bottom,

00:32:39.470 --> 00:32:42.560
we handle those based on
the subunits you've added.

00:32:42.560 --> 00:32:44.920
We automatically respond and say, yes,
we've got one of those.

00:32:48.080 --> 00:32:50.750
Here's a list of the existing
AVC APIs before we went

00:32:50.760 --> 00:32:52.200
and made all these changes.

00:32:52.240 --> 00:32:53.800
All but one are still available.

00:32:53.850 --> 00:32:58.000
We have deprecated the one at the bottom,
Set AVC Request Callback.

00:32:58.000 --> 00:33:02.000
That was the old way to handle incoming
commands and it really wasn't right.

00:33:02.000 --> 00:33:04.670
So if you were using that,
you really want to use

00:33:04.670 --> 00:33:06.430
the new functions instead.

00:33:08.350 --> 00:33:09.100
SBP3.

00:33:09.100 --> 00:33:12.580
This is a new revision
of the SBP2 standard.

00:33:12.580 --> 00:33:16.300
That's the standard used for hard drives,
iPods, storage devices on Firewire.

00:33:16.300 --> 00:33:19.760
We've added support for
something called Fast Start.

00:33:19.760 --> 00:33:23.660
If you've watched in
Firebug an SBP2 device,

00:33:23.660 --> 00:33:26.690
you may have noticed it takes
up to five packets just to get

00:33:26.770 --> 00:33:28.590
the device to start doing I.O.

00:33:28.600 --> 00:33:31.750
You send it the orb pointer,
it asks for the orb, you send it the orb,

00:33:31.750 --> 00:33:34.480
it asks for the page table,
you send it the page table.

00:33:34.890 --> 00:33:36.050
Finally, it can move some data.

00:33:36.050 --> 00:33:38.110
That's okay if you're
moving megabytes of data,

00:33:38.110 --> 00:33:40.300
but for small I.O.s,
it's really expensive.

00:33:40.320 --> 00:33:44.330
Fast Start defines a way to send all
that information in a single packet.

00:33:44.330 --> 00:33:46.520
The drive can immediately
start moving payload.

00:33:46.520 --> 00:33:49.500
We have measured a 30%
performance speed up for optimal

00:33:49.590 --> 00:33:53.170
I.O.s using this technique,
so it's definitely worth having.

00:33:53.180 --> 00:33:56.070
This technique is in
ballot now within ANSI,

00:33:56.070 --> 00:33:58.930
which is the standards
group that owns it.

00:33:58.960 --> 00:34:02.820
Fast Start has been stabilized,
which means nobody's going to change it.

00:34:02.820 --> 00:34:04.800
In fact,
we've been supporting it since 10.5.

00:34:04.800 --> 00:34:09.520
Now, your device has to
understand this new packet.

00:34:09.520 --> 00:34:11.530
You can't just turn it
on and it goes faster.

00:34:11.540 --> 00:34:13.870
But if your device does
understand this new packet,

00:34:13.870 --> 00:34:16.420
publish the appropriate key
in your configuration ROM so

00:34:16.420 --> 00:34:19.820
that we know you understand it,
and we'll send you Fast Start packets.

00:34:19.840 --> 00:34:22.480
If you're doing hardware that does this,
we'd like to hear from you,

00:34:22.480 --> 00:34:24.060
because we've only seen one so far.

00:34:24.060 --> 00:34:25.200
So please let us know.

00:34:25.200 --> 00:34:27.090
We'll try it out and see if it works.

00:34:27.100 --> 00:34:28.290
Thanks.

00:34:29.440 --> 00:34:32.740
Now, that's covered new and more
detailed information about

00:34:32.740 --> 00:34:37.240
what's in FireWire software in
Mac OS X for you to develop with.

00:34:37.240 --> 00:34:39.820
Let's talk about some of the resources
we provide to help you do this.

00:34:41.090 --> 00:34:42.070
Software Development Kits.

00:34:42.120 --> 00:34:43.660
We've made 16 of these so far.

00:34:43.660 --> 00:34:46.340
It's our biggest product
for you developers.

00:34:46.400 --> 00:34:47.600
It has lots of sample code.

00:34:47.600 --> 00:34:49.000
I showed you the list earlier.

00:34:49.230 --> 00:34:53.740
The SDKs often have pre-release versions
of the FireWire KEXTs so that you can

00:34:53.740 --> 00:34:57.880
try out new APIs or new bug fixes before
your customers are exposed to them.

00:34:57.950 --> 00:35:01.770
The SDKs also have tools,
utilities and lots of documentation

00:35:01.800 --> 00:35:04.000
to help you program on FireWire.

00:35:04.440 --> 00:35:08.700
These have always been available
for free public download at

00:35:08.700 --> 00:35:09.090
the URL shown on the slide.

00:35:10.900 --> 00:35:13.800
We have something new in the past year,
the FireWire Reference Platform.

00:35:13.800 --> 00:35:16.730
This is completely independent
from our Mac OS X FireWire.

00:35:17.180 --> 00:35:20.800
This is a software stack that
can run on embedded devices.

00:35:20.800 --> 00:35:26.440
So if you're making a set-top box or a
TV or a FireWire multi-function printer,

00:35:26.440 --> 00:35:28.170
take a look at our Reference Platform.

00:35:28.180 --> 00:35:30.350
You'll find a lot of code,
especially for the

00:35:30.350 --> 00:35:32.070
AVC protocol and command sets.

00:35:32.070 --> 00:35:34.570
They can give you a big
head start for implementing

00:35:34.670 --> 00:35:36.370
FireWire on embedded systems.

00:35:36.380 --> 00:35:40.170
There's also a session
on this later this week.

00:35:40.780 --> 00:35:43.280
We hold several developer
events for FireWire.

00:35:43.360 --> 00:35:46.460
We have PlugFests at
Macworld and here at WWDC.

00:35:46.460 --> 00:35:51.330
In fact, we had 40 devices submitted that
are now being tested by the 1394

00:35:51.490 --> 00:35:55.340
TA for PlugFest testing and we
will bring them all Thursday during

00:35:55.340 --> 00:35:57.160
the campus bash down at Apple.

00:35:57.550 --> 00:36:01.300
Plus, you're welcome to bring
additional devices then.

00:36:01.300 --> 00:36:01.300
We'll plug them all in.

00:36:01.800 --> 00:36:03.020
We hold Developer Kitchens.

00:36:03.020 --> 00:36:05.500
This is where we bring our core
engineers and meet with your

00:36:05.500 --> 00:36:08.690
engineers for two to three days
of hands-on debugging development.

00:36:08.700 --> 00:36:12.620
Often we introduce new SDKs
and new APIs at these sessions.

00:36:12.690 --> 00:36:14.830
These have been held
in Tokyo and Cupertino.

00:36:14.830 --> 00:36:16.490
We've done about ten of these so far.

00:36:16.490 --> 00:36:19.350
We hold these on demand,
so when you're ready for one of these,

00:36:19.350 --> 00:36:21.520
contact Apple Developer Relations,
let us know,

00:36:21.520 --> 00:36:22.980
and we'll try to schedule one.

00:36:24.570 --> 00:36:27.150
And we participate in the
1394 TA Interop Workshops.

00:36:27.410 --> 00:36:30.000
These are like plug fests,
only they're much more rigorous.

00:36:30.120 --> 00:36:32.430
There's three kinds of
testing done at these events:

00:36:32.430 --> 00:36:36.700
pairwise testing of each device
against each other device,

00:36:36.880 --> 00:36:40.030
The official test suites which
go through the spec line by line,

00:36:40.030 --> 00:36:43.280
electrical testing, config ROM testing,
all kinds of things.

00:36:43.370 --> 00:36:46.220
And the grand melee where we plug
all the devices together and try

00:36:46.220 --> 00:36:47.800
to get a 63 node bus to work.

00:36:47.870 --> 00:36:49.850
That's always a lot of fun.

00:36:50.530 --> 00:36:51.900
These happen four times every year.

00:36:51.900 --> 00:36:56.000
There's one in Tokyo, usually in April,
one in Taipei, usually in October,

00:36:56.100 --> 00:36:58.700
and two on the West Coast,
either in the Bay Area or up

00:36:58.700 --> 00:37:01.080
in Redmond for some reason.

00:37:02.080 --> 00:37:03.600
These are not limited to TA members.

00:37:03.600 --> 00:37:04.590
Anyone can come to these.

00:37:04.770 --> 00:37:07.800
There is a slight fee reduction
if you belong to the TA,

00:37:07.800 --> 00:37:09.000
but it's not expensive either way.

00:37:09.000 --> 00:37:12.200
We learn a ton of stuff about
our own products and other

00:37:12.200 --> 00:37:14.270
products we've never seen before.

00:37:14.500 --> 00:37:15.450
You should come to these events.

00:37:15.450 --> 00:37:16.280
They're really valuable.

00:37:18.180 --> 00:37:21.900
1394 TA is an industry trade
group that promotes 1394.

00:37:21.950 --> 00:37:24.070
That's where all the AVC specs come from.

00:37:24.330 --> 00:37:26.440
They also do a lot of
marketing and evangelism work,

00:37:26.500 --> 00:37:30.080
so you may want to consider joining
the TA if you make 1394 products.

00:37:30.100 --> 00:37:35.760
Okay, now let's look at some
new FireWire tools.

00:37:38.210 --> 00:37:39.820
I mentioned this earlier.

00:37:39.820 --> 00:37:40.950
This is related to tools.

00:37:41.000 --> 00:37:42.480
We'll get to it in a second.

00:37:42.500 --> 00:37:43.780
What exactly is a PHY?

00:37:43.900 --> 00:37:46.540
There was a box marked PHY in
that architecture stack

00:37:46.540 --> 00:37:48.120
right at the beginning.

00:37:48.310 --> 00:37:50.200
PHY is short for Physical Layer.

00:37:50.200 --> 00:37:54.380
It's the chip that actually drives
differential voltages on the FireWire

00:37:54.380 --> 00:37:56.200
cable and makes ones and zeros.

00:37:56.200 --> 00:38:00.210
And it receives them at the other
end and turns them back into bits.

00:38:00.520 --> 00:38:04.640
The PHY acts as a repeater
if it has two or more ports.

00:38:04.710 --> 00:38:06.940
And the PHY performs the arbitration.

00:38:06.940 --> 00:38:08.990
So there's no software
control for the PHY.

00:38:08.990 --> 00:38:09.890
It's all automated.

00:38:09.930 --> 00:38:12.400
It makes the arbitration go very fast.

00:38:12.470 --> 00:38:15.350
In comparison, the link layer,
which in a Mac is OHCI,

00:38:15.350 --> 00:38:17.000
is much higher level.

00:38:17.000 --> 00:38:23.880
It knows about DMA, CRCs,
isochronous time.

00:38:23.880 --> 00:38:23.880
It's higher level than the PHY.

00:38:25.850 --> 00:38:27.800
The PHY does not have a device driver.

00:38:27.800 --> 00:38:29.800
It's not programmable.

00:38:29.800 --> 00:38:31.880
But it does have a small register file.

00:38:31.900 --> 00:38:35.770
This is a page from the 1394A standard
that shows the registers in the PHY.

00:38:35.820 --> 00:38:36.790
Each one is 8 bits wide.

00:38:36.800 --> 00:38:39.360
But there's some very
interesting information in there,

00:38:39.450 --> 00:38:41.650
like the status of each
of the ports on the PHY.

00:38:41.800 --> 00:38:44.140
Often,
when you find some unique and interesting

00:38:44.480 --> 00:38:48.290
thing happening on your FireWire bus,
you may want to look at the PHY ports

00:38:48.290 --> 00:38:51.800
to find out why it's doing that
unique and interesting thing.

00:38:51.800 --> 00:38:56.640
1394A defined these bits,
1394B defines a few more.

00:38:57.190 --> 00:39:00.520
We now have a tool that lets
you examine these directly.

00:39:00.560 --> 00:39:03.100
This was possible in Mac OS 9
if you dropped into Mac's bug,

00:39:03.100 --> 00:39:04.100
but it was really tedious.

00:39:04.100 --> 00:39:06.050
I think you'll find this
a little bit easier.

00:39:06.100 --> 00:39:12.090
FiTool is a real-time browser
and editor for FiRegisters.

00:39:12.100 --> 00:39:15.100
It displays the FiRegisters
just like the specification,

00:39:15.100 --> 00:39:20.100
except each one of those boxes is
now a checkbox or a pop-up menu,

00:39:20.100 --> 00:39:23.100
and it has an explanation of what its
current value is and what that means.

00:39:23.100 --> 00:39:27.100
FiTool has integrated documentation.

00:39:27.100 --> 00:39:28.300
If you move the mouse
over one of the bits,

00:39:28.300 --> 00:39:31.250
like "Enable Standby," the text
from the specification itself will

00:39:31.250 --> 00:39:34.130
appear at the bottom of the screen,
telling you exactly how that

00:39:34.130 --> 00:39:35.100
bit is supposed to work.

00:39:35.100 --> 00:39:38.370
FiTool can examine the
Fi in your Macintosh,

00:39:38.380 --> 00:39:44.000
or it can reach out across the FireWire
bus and examine the Fi in other devices,

00:39:44.110 --> 00:39:48.170
if they support 1394A or 1394B.

00:39:48.510 --> 00:39:51.710
It also provides a continually updated
summary of the PHY it's looking at

00:39:51.710 --> 00:39:54.620
and the status of all of its ports,
so you can see devices that are

00:39:54.620 --> 00:39:56.490
plugged and unplugged in real time.

00:39:56.490 --> 00:39:59.340
PHY tool doesn't require
any special hardware.

00:39:59.340 --> 00:40:01.610
PHY tool runs on every Mac that we sell.

00:40:01.620 --> 00:40:04.520
It runs on the 1394 OHCI controller.

00:40:06.290 --> 00:40:07.260
Here's a full screen shot.

00:40:07.370 --> 00:40:10.280
You can see the center portion
looks just like the spec.

00:40:10.280 --> 00:40:14.700
Down at the bottom there is the text
explaining what the speed field means,

00:40:14.700 --> 00:40:16.680
where the cursor is
located on line three.

00:40:17.260 --> 00:40:18.950
Over on the left,
you have a summary of what

00:40:18.950 --> 00:40:19.920
all the ports are doing.

00:40:20.040 --> 00:40:21.220
Port number one is connected.

00:40:21.270 --> 00:40:22.770
The other two are disconnected.

00:40:23.570 --> 00:40:25.940
And there's pop-up menus
to pick which interface,

00:40:25.940 --> 00:40:28.380
if you have multiple interfaces,
and which node,

00:40:28.380 --> 00:40:30.940
if you want to look across
the bus at another node.

00:40:31.620 --> 00:40:32.680
So it's really easy to use.

00:40:32.680 --> 00:40:35.140
Believe me,
if you've never tried Cocoa programming,

00:40:35.260 --> 00:40:37.710
you won't believe how easy it is
to get this kind of stuff working.

00:40:37.720 --> 00:40:40.660
This was a lot of fun, and I think you'll
really enjoy this tool.

00:40:41.170 --> 00:40:42.500
Even if you don't have
problems in your PHY,

00:40:42.500 --> 00:40:45.470
this tool is very educational,
just looking at the bits,

00:40:45.550 --> 00:40:47.360
seeing them change,
finding out what's happening

00:40:47.640 --> 00:40:48.940
on a running PHYWIRE bus.

00:40:51.150 --> 00:40:52.430
We have another new tool for you.

00:40:52.480 --> 00:40:54.680
This is called Fire Starter.

00:40:54.870 --> 00:40:57.100
This tool was written for plug fests.

00:40:57.470 --> 00:41:00.100
All of the commercial FireWire
analyzers out there can show the

00:41:00.100 --> 00:41:04.100
topology of the FireWire bus,
but none of them does it very quickly.

00:41:04.220 --> 00:41:07.590
Like I mentioned the Grand Melee
where we get 63 nodes on the bus,

00:41:07.600 --> 00:41:09.100
which we've really done.

00:41:09.100 --> 00:41:12.410
Some of the commercial analyzers take
30 seconds or more to try to figure

00:41:12.490 --> 00:41:14.000
out how to draw a picture of that.

00:41:14.060 --> 00:41:16.930
By that time,
one of them has caused a bus

00:41:16.960 --> 00:41:19.500
reset and everything's changed.

00:41:19.500 --> 00:41:20.090
It's just too slow.

00:41:20.600 --> 00:41:23.920
Firestarter can draw a
slightly simpler version,

00:41:23.920 --> 00:41:28.710
but topologically accurate map of the bus
and it can update it 10 times per second.

00:41:28.850 --> 00:41:32.840
So it gives you a very real-time idea
of exactly what's actually on your bus.

00:41:32.840 --> 00:41:35.550
In the picture there you can
see on the right a simple

00:41:35.550 --> 00:41:38.230
ASCII rendering of the bus,
and on the left various

00:41:38.230 --> 00:41:41.380
information that's especially
applicable to plugfests,

00:41:41.470 --> 00:41:44.090
like how many nodes,
what's the maximum hop count,

00:41:44.140 --> 00:41:46.830
how long has it been
since the last bus reset,

00:41:46.850 --> 00:41:50.460
and what's the longest time we
ever survived between bus resets.

00:41:50.500 --> 00:41:54.010
There's also a bunch of data in the
lower left that sorts all the nodes

00:41:54.010 --> 00:41:58.500
and shows you how many are S400,
S200, how many are 1394B.

00:41:58.500 --> 00:42:03.320
So you can get a very rapid snapshot
of what's connected to your bus.

00:42:03.320 --> 00:42:04.730
Here's a full screen display.

00:42:05.020 --> 00:42:06.820
This is a bus with just six nodes on it.

00:42:06.890 --> 00:42:11.320
You can see in the upper right the
hierarchy showing who's connected to who.

00:42:11.610 --> 00:42:14.940
Here's a picture from one
of the plugfests where we

00:42:14.950 --> 00:42:17.190
got 63 nodes on the bus.

00:42:17.250 --> 00:42:19.160
I didn't actually have
a big enough screen.

00:42:19.160 --> 00:42:21.750
You have to stretch the window down a
little bit to see the last seven nodes,

00:42:21.860 --> 00:42:25.200
but it's showing the topology of how
everyone's connected to everybody else.

00:42:25.200 --> 00:42:28.280
And I'd like to point out
that the bus was stable for,

00:42:28.280 --> 00:42:30.310
I believe, more than a minute.

00:42:30.700 --> 00:42:38.200
[Transcript missing]

00:42:39.480 --> 00:42:44.760
We have one more new tool, FW Busy Bus.

00:42:44.820 --> 00:42:47.200
This is a traffic generator.

00:42:47.370 --> 00:42:51.800
FWBusy Bus can send any kind of
asynchronous packet on the FireWire bus.

00:42:51.800 --> 00:42:55.600
It can also send bus resets and
it can cause bus reset storms.

00:42:55.600 --> 00:43:00.270
It will even enable and disable its
own ports to simulate hot plugging.

00:43:00.270 --> 00:43:01.250
It's automated.

00:43:01.370 --> 00:43:04.490
It can automatically ramp up
and down the level of activity,

00:43:04.560 --> 00:43:07.980
so you can leave it running over a
period of time and test different

00:43:07.980 --> 00:43:10.000
levels of activity on your bus.

00:43:10.000 --> 00:43:12.630
You can also turn on and off
every different kind of packet,

00:43:12.630 --> 00:43:15.160
packet speed, bus reset,
everything that it does.

00:43:15.160 --> 00:43:17.260
All three of these tools are
available on our website.

00:43:17.300 --> 00:43:20.180
Work on OHCI,
so you don't need any special hardware.

00:43:20.350 --> 00:43:23.420
Here's a full screen picture of Busy Bus.

00:43:23.420 --> 00:43:26.420
The sliders at the top let you
adjust the intensity level and

00:43:26.420 --> 00:43:28.170
how quickly it ramps up and down.

00:43:28.170 --> 00:43:31.220
The check boxes in the middle let
you turn on and off every different

00:43:31.330 --> 00:43:33.100
kind of packet and packet speeds.

00:43:33.100 --> 00:43:36.430
And the control at the bottom
gives you a brief summary of what's

00:43:36.430 --> 00:43:39.770
on the bus and what the tool is
doing at any particular moment.

00:43:39.770 --> 00:43:43.170
Plus, on the left, we have the PHY status
that is copied from...

00:43:43.770 --> 00:43:48.780
FW Busy Bus can send any kind of packet.

00:43:48.830 --> 00:43:51.460
If you configure it properly,
it can write garbage data onto

00:43:51.460 --> 00:43:53.420
physical memory in your Mac.

00:43:53.750 --> 00:43:56.000
Be careful what you turn on and
what you don't in this tool.

00:43:56.000 --> 00:43:57.800
The default settings are safe.

00:44:01.510 --> 00:44:04.580
Now, if there are interesting things
happening on your FireWire bus,

00:44:04.650 --> 00:44:06.540
if somebody's writing garbage
data into your memory,

00:44:06.540 --> 00:44:10.400
you might want to examine the
FireWire bus and see what's going on.

00:44:10.400 --> 00:44:12.400
We have a tool for that called Firebug.

00:44:12.400 --> 00:44:17.400
I'm pleased to announce today that
Firebug is now available for Mac OS X.

00:44:17.420 --> 00:44:18.400
Really.

00:44:18.400 --> 00:44:19.830
There it is.

00:44:22.070 --> 00:44:24.340
Firebug is a real-time packet snooper.

00:44:24.340 --> 00:44:28.070
It can decode every packet on
the bus and show them to you in

00:44:28.070 --> 00:44:31.770
a sort of semi-English ASCII way.

00:44:32.300 --> 00:44:36.400
Firebug provides precision
timestamps to within one cycle time,

00:44:36.520 --> 00:44:38.380
usually much better than that.

00:44:38.630 --> 00:44:42.310
Firebug can decode common
protocols like SPP2 and AVC,

00:44:42.350 --> 00:44:45.110
so you don't have to pull out
the spec and look up hex codes.

00:44:45.170 --> 00:44:50.370
It'll tell you if that's a block read,
he told the camcorder to play.

00:44:50.680 --> 00:44:53.400
Firebug also provides some simple
bus configuration services.

00:44:53.400 --> 00:44:57.340
If you'd like to tune the gap count or
cause a bus reset or go poke at the PHY,

00:44:57.490 --> 00:44:59.600
you can do that from within Firebug.

00:44:59.680 --> 00:45:02.600
Firebug still requires the
TI PCI links interface.

00:45:02.630 --> 00:45:05.590
We made it run on Mac OS X,
but OHCI just doesn't have

00:45:05.590 --> 00:45:06.580
the snooping hardware.

00:45:06.600 --> 00:45:09.060
These interfaces are still available.

00:45:09.070 --> 00:45:11.760
You can get them on
Cardbus card or PCI card.

00:45:11.890 --> 00:45:14.450
And if you have a really old
Mac like the blue and white G3,

00:45:14.730 --> 00:45:17.410
it actually has one of those built in.

00:45:18.290 --> 00:45:19.900
But we've not only
brought it to Mac OS X,

00:45:19.900 --> 00:45:21.200
we've made a few improvements.

00:45:21.200 --> 00:45:23.180
We've improved the decoding.

00:45:23.280 --> 00:45:28.180
We added a bunch of new AVC commands,
especially the unit info command,

00:45:28.180 --> 00:45:29.940
so you can see when that's happening.

00:45:29.940 --> 00:45:33.020
The SPP2 decode can now survive
a bus reset almost every time,

00:45:33.020 --> 00:45:35.230
whereas usually it almost never survived.

00:45:35.230 --> 00:45:39.280
It would just go back to showing hex
because it didn't know what was going on.

00:45:40.390 --> 00:45:42.220
There's a tool called
the PHY Register Dump.

00:45:42.250 --> 00:45:45.420
If you don't have PHY Tool handy,
you can just ask Firebug

00:45:45.580 --> 00:45:48.230
to do the same thing,
and you can see in the picture there,

00:45:48.230 --> 00:45:53.640
it has dumped out the contents of
the PHY in a concise ASCII format.

00:45:53.640 --> 00:45:55.720
We've added Node ID filters.

00:45:55.720 --> 00:45:59.550
You can now look at packets
only going to or from or between

00:45:59.550 --> 00:46:01.600
whatever nodes you choose.

00:46:01.600 --> 00:46:04.970
You can select which isochronous
channel you'd like to look at.

00:46:05.000 --> 00:46:06.820
You can get an isochronous summary.

00:46:06.820 --> 00:46:10.120
Usually you don't look at isochronous
packets because there's 8,000 per second.

00:46:10.120 --> 00:46:11.800
It just wipes out the display.

00:46:11.800 --> 00:46:14.630
But Firebug will now tell you,
even if it's not showing

00:46:14.720 --> 00:46:18.350
the isochronous packets,
ah, channel 63 has gone active.

00:46:18.380 --> 00:46:20.380
In fact, it's active at S100.

00:46:20.380 --> 00:46:21.790
It's coming from Node 2.

00:46:21.880 --> 00:46:22.900
It's NTSC video.

00:46:22.900 --> 00:46:25.980
So now you'll know something's
happening even though you didn't get

00:46:25.980 --> 00:46:29.560
the display blown away by thousands
and thousands of isochronous packets.

00:46:29.620 --> 00:46:32.570
And because it runs on Mac OS X,
we've been able to make Firebug

00:46:32.580 --> 00:46:35.000
support dual processors,
so now it's even faster

00:46:35.000 --> 00:46:36.560
than it ever was before.

00:46:36.620 --> 00:46:40.110
So let's demo Firebug on Mac OS X.

00:46:43.150 --> 00:46:48.430
May I have number three please?

00:46:48.430 --> 00:46:48.430
There we go.

00:46:51.080 --> 00:46:54.170
It's right here.

00:46:54.230 --> 00:46:56.430
Launches just like that.

00:46:56.880 --> 00:47:01.750
This system running Firebug,
it's a G4 tower,

00:47:01.800 --> 00:47:05.800
so I installed a PCI links,
PCI card into it.

00:47:05.800 --> 00:47:10.050
It's connected to this other G4 tower,
and you can see the packets there

00:47:10.110 --> 00:47:11.610
as the other G4 tower scans the bus.

00:47:11.640 --> 00:47:14.800
So I'm going to plug in my iPod,
and we'll see all the

00:47:14.800 --> 00:47:19.060
activity that this generates,
and we'll see that Firebug can decode

00:47:19.230 --> 00:47:22.080
the SPP2 protocol that the iPod is using.

00:47:22.720 --> 00:47:26.060
It takes the iPod a few seconds to
switch from MP3 mode over into disk mode,

00:47:26.060 --> 00:47:28.620
but it should be ready
to go right about now.

00:47:28.620 --> 00:47:29.280
There we go.

00:47:31.680 --> 00:47:35.140
Mac OS X is mounding it as a file system,
so it's reading different blocks,

00:47:35.200 --> 00:47:37.810
it's figuring out that it's
HFS+. You can't see it,

00:47:37.880 --> 00:47:41.710
but it drew the icon on the
desktop over on this other Mac.

00:47:42.430 --> 00:47:45.980
You can see here some of the new
features in the decode of the normal

00:47:46.050 --> 00:47:47.300
command orb there at the bottom.

00:47:47.300 --> 00:47:51.720
It says read one block at LBA 900E3C.

00:47:51.770 --> 00:47:54.090
So you no longer have to figure
that out for yourself from those

00:47:54.150 --> 00:47:55.890
12 bytes of hex under command.

00:47:55.900 --> 00:47:58.630
Additionally,
I can cause a bus reset and fire

00:47:58.630 --> 00:48:02.480
bug and then go ask this Mac to do
something with the iPod and you'll

00:48:02.480 --> 00:48:06.470
see that it's still decoding the
commands even after the bus reset,

00:48:06.470 --> 00:48:08.780
which almost never worked before.

00:48:11.660 --> 00:48:15.260
I mentioned Firebug takes
advantage of dual processors.

00:48:15.330 --> 00:48:19.040
It also no longer completely monopolizes
the machine like it did on Mac OS 9,

00:48:19.080 --> 00:48:20.740
so if you want,
you can leave your other apps open.

00:48:20.740 --> 00:48:23.810
Now it's not doing anything,
but let me ask it to

00:48:23.810 --> 00:48:27.480
show cycle start packets,
and you'll see that it gets quite busy.

00:48:29.910 --> 00:48:31.300
This is a pretty fast G4 tower.

00:48:31.300 --> 00:48:35.720
I have on slower units maxed out both
processors at 100% running Firebug,

00:48:35.800 --> 00:48:38.180
but you can see it is using them both.

00:48:38.510 --> 00:48:42.240
So if you are a long time Firebug user,
if you're tired of booting back

00:48:42.240 --> 00:48:45.700
into Mac OS 9 to run Firebug,
if you'd like some of these new features,

00:48:45.750 --> 00:48:48.240
I think you'll be pretty happy with this.

00:48:48.240 --> 00:48:50.810
Let's go back to the slides.

00:48:56.230 --> 00:48:57.860
Okay,
so I've announced all these new tools.

00:48:57.940 --> 00:49:02.320
FiTool, FireStarter, FWBusyBus,
those all run on OHCI,

00:49:02.320 --> 00:49:04.390
so you can use them on any
Mac that we have today,

00:49:04.390 --> 00:49:07.220
plus Firebug,
which still requires PCI links.

00:49:07.220 --> 00:49:12.030
All of these tools require
Mac OS X 10.2.5 or later.

00:49:12.030 --> 00:49:13.920
Very important.

00:49:13.920 --> 00:49:16.930
If you're familiar with Firebug,
you know how it works.

00:49:17.000 --> 00:49:18.350
It touches the hardware directly.

00:49:18.350 --> 00:49:20.160
All of these tools do that.

00:49:20.220 --> 00:49:21.870
That's good and bad.

00:49:22.980 --> 00:49:26.080
We displace all FireWire
services when you run the tool.

00:49:26.080 --> 00:49:28.240
We do it in a clean way.

00:49:28.240 --> 00:49:32.170
If you have an iPod or a disk mounted,
the tool will refuse to run.

00:49:32.230 --> 00:49:35.870
It won't just displace the driver
and leave you with a corrupt iPod.

00:49:35.900 --> 00:49:38.350
You will have to unplug any
disks or iPods that you have

00:49:38.350 --> 00:49:39.800
in order to run these tools.

00:49:39.800 --> 00:49:44.650
But because we displaced the software,
you no longer have Mac OS X on

00:49:44.650 --> 00:49:47.220
the bus trying to manage the bus.

00:49:47.220 --> 00:49:49.710
So if you're trying to run
FiTool to figure out why some

00:49:49.750 --> 00:49:52.760
camcorder keeps resetting the bus,
you don't have to wonder.

00:49:52.940 --> 00:49:55.460
The Mac OS X is also on there
trying to manage the bus.

00:49:55.560 --> 00:49:56.080
It's not.

00:49:56.080 --> 00:49:56.790
We've displaced it.

00:49:56.950 --> 00:49:59.740
The tool is the only
thing touching the bus.

00:50:00.000 --> 00:50:01.840
These are all new.

00:50:01.910 --> 00:50:03.860
We've tested them as best we can,
but please be careful.

00:50:03.890 --> 00:50:07.900
They do touch hardware directly,
so they can crash the machine.

00:50:07.900 --> 00:50:10.420
Make backups or run this
on a dedicated machine,

00:50:10.420 --> 00:50:12.990
at least until you're sure
that it's really going to be

00:50:12.990 --> 00:50:14.610
stable in your environment.

00:50:14.770 --> 00:50:18.370
And watch our mailing list for
updates regarding these tools because,

00:50:18.370 --> 00:50:19.580
again, they're new.

00:50:19.580 --> 00:50:23.240
So you're probably wondering,
where can I get all these great tools?

00:50:23.240 --> 00:50:25.610
These sound like I want
to try them out today.

00:50:25.610 --> 00:50:26.500
Well, you can.

00:50:26.550 --> 00:50:29.420
FireWire SDK 17 is available
live today on the web.

00:50:29.420 --> 00:50:31.980
The only catch is that
because they redesigned the

00:50:31.980 --> 00:50:35.170
whole ADC website yesterday,
the link is missing.

00:50:35.460 --> 00:50:37.300
I know you can all figure this out.

00:50:37.300 --> 00:50:42.740
Go find SDK 16, copy the link,
change the 6 to a 7,

00:50:42.740 --> 00:50:45.950
and you'll get the disk image for SDK 17.

00:50:50.390 --> 00:50:52.300
Okay, let's wrap up.

00:50:52.300 --> 00:50:56.390
Here are the FireWire
sessions at WWDC this week,

00:50:56.480 --> 00:50:59.300
not including 505,
which you're in right now.

00:50:59.480 --> 00:51:02.710
Tomorrow morning, 504,
Developing with FireWire 800.

00:51:02.890 --> 00:51:05.760
That's the higher level session,
but we have a ton of new content this

00:51:05.820 --> 00:51:07.780
year about how FireWire 800 works.

00:51:09.030 --> 00:51:12.090
We have a feedback forum
for both FireWire and USB.

00:51:12.090 --> 00:51:14.020
Like we do every year,
you can get all your serial bus

00:51:14.020 --> 00:51:16.190
feedback in one convenient location.

00:51:16.260 --> 00:51:18.250
We have a new session
this year on Thursday,

00:51:18.320 --> 00:51:20.600
5:08, the FireWire Reference Platform.

00:51:20.600 --> 00:51:23.800
We'll go into much greater detail
about what's in there and how

00:51:23.800 --> 00:51:26.200
you can use it to make products.

00:51:26.200 --> 00:51:29.350
Finally, Thursday evening during
the Apple Campus Bash,

00:51:29.480 --> 00:51:33.200
we have our FireWire,
USB and Bluetooth Plug and Unplug Fest,

00:51:33.200 --> 00:51:36.190
and I'm sure that will
be very interesting.

00:51:37.780 --> 00:51:39.570
If you'd like to contact Apple,
if you want to come

00:51:39.580 --> 00:51:41.700
to a FireWire kitchen,
if you need help developing,

00:51:41.700 --> 00:51:43.700
you want to license
the reference platform,

00:51:43.700 --> 00:51:44.700
here's contact information.

00:51:44.700 --> 00:51:47.150
Prashant Kanheri,
he'll be up here in a moment,

00:51:47.160 --> 00:51:49.870
is the Program Manager for
FireWire Technologies.

00:51:49.890 --> 00:51:53.280
You can also contact Yermo Ortiz
and Apple Developer Relations.

00:52:08.930 --> 00:52:09.180
We have a public developer mailing list.

00:52:09.180 --> 00:52:09.180
Anybody can join.

00:52:09.180 --> 00:52:09.180
There's a lot of people on there.

00:52:09.180 --> 00:52:09.180
This is a place where
developers can ask questions,

00:52:09.180 --> 00:52:09.180
developers can answer questions,
we answer questions too,

00:52:09.180 --> 00:52:09.180
we announce new tools,
we announce things about Firebug.

00:52:09.700 --> 00:52:11.570
Just follow this link
and you can subscribe.

00:52:11.600 --> 00:52:14.600
At the same place you can subscribe to
the Reference Platform mailing list,

00:52:14.600 --> 00:52:18.600
which is the same thing but it's
focused on the Reference Platform.

00:52:19.820 --> 00:52:23.850
If you'd like more information about
developing FireWire on Mac OS X,

00:52:23.850 --> 00:52:28.400
our standard document is a book called
Working with FireWire Device Interfaces.

00:52:28.400 --> 00:52:31.120
I said earlier that's the
formal name for a user client.

00:52:31.120 --> 00:52:32.700
It's available online.

00:52:32.700 --> 00:52:35.110
It has a lot of information
about how to use the user client

00:52:35.110 --> 00:52:36.520
to talk to FireWire devices.

00:52:38.580 --> 00:52:40.360
Our Software Development Kits
are all available on the web,

00:52:40.360 --> 00:52:42.060
SDK 17, as I just described.

00:52:42.060 --> 00:52:45.230
We also have a Tech Note coming,
I don't think it's live yet,

00:52:45.230 --> 00:52:47.950
that goes into more depth
about how to use DCLs.

00:52:47.950 --> 00:52:50.360
It should be posted soon
and we'll announce it on

00:52:50.360 --> 00:52:51.880
the mailing list when it is.

00:52:53.300 --> 00:52:58.160
The IEEE 1394 standard itself is
available from the IEEE on the web.

00:52:58.160 --> 00:53:03.290
The 1394 TA, also on the web,
has standards for AVC command sets,

00:53:03.290 --> 00:53:07.560
the IIDC digital camera, automotive 1394,
various other standards.

00:53:08.570 --> 00:53:11.850
And if you're working with AVC,
you may also need some

00:53:11.850 --> 00:53:15.980
standards from the ISO,
such as the format for DV video.

00:53:15.990 --> 00:53:18.320
It's also available on the web.
WEBVTT

00:00:25.800 --> 00:00:35.400
[Transcript missing]

00:00:36.110 --> 00:00:38.860
We're going to talk to you
about some cool tips and tricks.

00:00:38.980 --> 00:00:40.990
Sort of think of this as the
roar for sticking around so

00:00:40.990 --> 00:00:42.000
late on a Friday evening.

00:00:42.000 --> 00:00:45.300
And what we're going to do is we're
going to talk about some things that

00:00:45.480 --> 00:00:49.150
you could do which would put cool
features in your applications and

00:00:49.150 --> 00:00:52.000
mimic some of the things that you've
seen our own applications doing.

00:00:52.000 --> 00:00:55.480
And these topics will range from
beginner level topics that will

00:00:55.480 --> 00:00:59.000
be easy for everyone to understand
to some more advanced topics.

00:00:59.000 --> 00:01:01.780
And don't worry, there's going to be
lots of code and demos,

00:01:01.940 --> 00:01:05.000
but all the source code will be
available online for download.

00:01:05.000 --> 00:01:08.000
I don't know if it's there right now,
but it should be there sometime today.

00:01:09.650 --> 00:01:10.980
Okay,
so the way we're going to run things

00:01:10.980 --> 00:01:14.710
today is you guys get to ask the
questions and we're going to answer them.

00:01:14.990 --> 00:01:17.360
Unfortunately,
Jason gave me a list of questions

00:01:17.390 --> 00:01:19.980
right before I came up on
stage a couple minutes ago,

00:01:19.980 --> 00:01:23.580
and I punched in all the slides
and all of the demos so that we can

00:01:23.580 --> 00:01:28.310
just flow through nice and smoothly
without having to go out to the crowd.

00:01:29.120 --> 00:01:31.400
So the first question
you guys had for us was,

00:01:31.520 --> 00:01:35.120
well I've seen iChat, Safari,
Address Book, all these applications with

00:01:35.190 --> 00:01:37.200
these cool roll-over effects.

00:01:37.290 --> 00:01:39.590
So just to explain what
the roll-over effect is,

00:01:39.620 --> 00:01:43.170
we've got the mouse moving back
and forth and you see it represents

00:01:43.170 --> 00:01:45.220
that I have some clickable area.

00:01:45.310 --> 00:01:49.070
Okay, so the idea for doing a
roll-over is really quite simple.

00:01:49.390 --> 00:01:51.850
What we're going to
do is track the mouse.

00:01:51.900 --> 00:01:54.500
We're going to need to know when
it enters and exits a region.

00:01:54.500 --> 00:01:57.000
And once it does that,
we're going to set up some state

00:01:57.000 --> 00:01:59.660
that lets us know that either
we want to draw a roll-over or

00:01:59.780 --> 00:02:02.530
we're done drawing the roll-over.

00:02:02.970 --> 00:02:05.700
Okay, so how do we track the mouse?

00:02:05.770 --> 00:02:09.190
Well, you could imagine that we
continually monitor where the

00:02:09.190 --> 00:02:11.800
mouse's position is at every instant,
every time it moves.

00:02:11.910 --> 00:02:14.960
But that seems a little, well,
a little unnecessary

00:02:14.960 --> 00:02:16.170
and very inefficient.

00:02:16.280 --> 00:02:21.040
So, all we really need to do in most
situations is know when the mouse enters

00:02:21.040 --> 00:02:23.180
an area and when it exits an area.

00:02:23.370 --> 00:02:25.290
If we had to,
we really could track the mouse at

00:02:25.300 --> 00:02:27.900
every instant in every location,
but we don't need to for this.

00:02:27.900 --> 00:02:29.900
Let's just be nice and
efficient about it.

00:02:29.950 --> 00:02:34.780
We're going to use NSView's
API to add a tracking rectangle.

00:02:34.940 --> 00:02:37.330
And when we do this,
one of the parameters we

00:02:37.330 --> 00:02:38.900
can specify is the owner.

00:02:39.050 --> 00:02:41.900
And the owner gets notified with
"mouse entered" and "mouse exited"

00:02:41.900 --> 00:02:46.480
whenever the mouse enters a
region and when it exits a region.

00:02:47.670 --> 00:02:51.600
Okay, so once it enters a region,
we want to set up our drawing states

00:02:51.600 --> 00:02:53.580
that we know we want to draw a roll-over.

00:02:53.610 --> 00:02:58.040
And we're going to use NSBezierPath
to help us draw the roll-over

00:02:58.040 --> 00:02:59.590
when we have our state set.

00:02:59.860 --> 00:03:04.230
And what we're going to do
is use this API to append

00:03:05.690 --> 00:03:07.530
There's supposed to be a little image
there that shows you what we're doing,

00:03:07.620 --> 00:03:09.570
but there we go.

00:03:09.790 --> 00:03:13.600
We're going to append
two caps at the end,

00:03:13.600 --> 00:03:16.740
two half-circular arcs,
and when we're done,

00:03:16.880 --> 00:03:20.580
we're going to use its
API to close the path,

00:03:20.630 --> 00:03:24.100
close it up nicely, and when we draw it,
we're going to use its API to fill.

00:03:24.250 --> 00:03:28.100
And we're going to draw a filled
region created using this Bezier path.

00:03:28.250 --> 00:03:30.940
So if we could go to demo one, please.

00:03:33.160 --> 00:03:37.090
Okay, so I'm going to start out first
by showing you what we get

00:03:37.090 --> 00:03:40.710
when we run the application.

00:03:42.400 --> 00:03:45.100
See, we have some other fans out there.

00:03:45.130 --> 00:03:47.510
When we move over a region,

00:03:48.060 --> 00:03:50.600
We get a nice little highlight
effect with the Bezier path.

00:03:50.650 --> 00:03:53.040
Okay, so let's see how we did that.

00:03:53.280 --> 00:03:57.590
We start by bringing up our nib
to see how things are configured.

00:03:58.360 --> 00:04:01.790
And we have a number
of text fields in here.

00:04:01.790 --> 00:04:05.910
And the important thing about these text
fields that I wanted to point out is

00:04:05.950 --> 00:04:08.300
that it's called a roll-over text field.

00:04:08.300 --> 00:04:13.500
And if we look at the classes,
we see that roll-over text field

00:04:13.500 --> 00:04:16.280
is a subclass of NSTextField.

00:04:18.070 --> 00:04:21.940
Alright, so we look at the code
in rollover text field.

00:04:21.940 --> 00:04:23.360
We have two instance variables.

00:04:23.360 --> 00:04:25.240
One is a rollover path.

00:04:25.240 --> 00:04:28.290
So whenever we enter a region,
we're going to set up a rollover path.

00:04:28.410 --> 00:04:31.070
When we have a rollover path,
that's our cue that we

00:04:31.070 --> 00:04:32.540
want to draw a rollover.

00:04:32.540 --> 00:04:35.600
And we have this rollover
tracking rect tag.

00:04:35.600 --> 00:04:38.800
This is a value that's returned
from the add tracking rect API,

00:04:38.800 --> 00:04:43.020
and it's what we're going to use to
reference that tracking rectangle if we

00:04:43.020 --> 00:04:45.960
need to remove it or change its position.

00:04:47.320 --> 00:04:50.300
So bring up the implementation file.

00:04:50.300 --> 00:04:52.550
And we start out,
we have a number of routines which

00:04:52.610 --> 00:04:56.650
are just utility nicety routines
that we're going to use when we

00:04:56.950 --> 00:04:58.190
manage our tracking rectangle.

00:04:58.320 --> 00:05:01.300
We've got something to clear
the current tracking rectangle,

00:05:01.300 --> 00:05:04.300
and then we've got one to reset
the current tracking rectangle.

00:05:04.410 --> 00:05:08.270
And you notice the first thing it
does is clear the tracking rectangle,

00:05:08.270 --> 00:05:10.190
and then put it at a new position.

00:05:10.300 --> 00:05:14.300
And we only do this when
we're not in live resize.

00:05:14.300 --> 00:05:16.260
There's no point in doing it
during live resize because the

00:05:16.260 --> 00:05:17.300
mouse is over the girl box.

00:05:17.300 --> 00:05:19.260
It's not over your control.

00:05:19.300 --> 00:05:22.720
So we're going to do that at
the end of live resize and be a

00:05:22.850 --> 00:05:25.300
little more performance intensive.

00:05:26.630 --> 00:05:29.130
Okay,
now we've got a number of places where

00:05:29.200 --> 00:05:33.190
we insert calls to these routines which
will either clear the tracking rectangle

00:05:33.190 --> 00:05:34.830
or reset it at the appropriate times.

00:05:34.900 --> 00:05:38.150
So, for instance,
if the frame origin of our view moves,

00:05:38.230 --> 00:05:40.370
well, that's a good time to reset
the tracking rectangle.

00:05:40.410 --> 00:05:44.130
When our frame size changes,
we'll do it also.

00:05:44.200 --> 00:05:47.860
If we, for some reason,
get moved into a new window, well,

00:05:47.860 --> 00:05:50.260
clear the tracking rectangle
information for the old window.

00:05:50.380 --> 00:05:52.300
We're about to move into a new one.

00:05:53.420 --> 00:05:55.600
And finally,
when we move into a new window, well,

00:05:55.600 --> 00:05:57.960
let's set up a tracking
rectangle in that new window.

00:05:58.000 --> 00:06:02.380
And again,
we skipped setting up any tracking

00:06:02.380 --> 00:06:05.580
rectangle during live resize.

00:06:05.600 --> 00:06:08.880
So when live resize is over,
let's set it up then.

00:06:10.280 --> 00:06:12.940
Okay, so that should be all the
points that we need to catch.

00:06:12.940 --> 00:06:15.400
And now that we have a tracking
rectangle as the owner,

00:06:15.430 --> 00:06:18.710
we're going to get a callback
when the mouse enters.

00:06:19.160 --> 00:06:23.470
When the mouse enters,
we will create a Bezier path,

00:06:23.470 --> 00:06:26.220
and we're going to
append one half arc on,

00:06:26.220 --> 00:06:28.020
I guess, the left side first.

00:06:28.100 --> 00:06:29.100
Not sure.

00:06:29.100 --> 00:06:30.100
Yep, it's on the left side first.

00:06:30.100 --> 00:06:33.100
And then we're going to append
another half arc on the right side,

00:06:33.100 --> 00:06:35.100
and finally, close the path.

00:06:35.100 --> 00:06:38.100
And we get just that diagram
that I had showed you.

00:06:38.210 --> 00:06:43.050
And since, you know, Bezier path can tell
us what its bounds is,

00:06:43.180 --> 00:06:44.090
well, let's just dirty the
bounds of the Bezier path.

00:06:44.100 --> 00:06:46.090
That's what really needs to be updated.

00:06:46.100 --> 00:06:49.990
And finally, when the mouse exits,
we're going to say that we need to

00:06:49.990 --> 00:06:53.440
re-display in that bounds again,
and we're going to get

00:06:53.490 --> 00:06:55.100
rid of the Bezier path.

00:06:55.980 --> 00:06:59.930
And finally, to draw the Bezier path,
if we have a roll-over path,

00:06:59.930 --> 00:07:01.440
we want to draw it.

00:07:01.440 --> 00:07:04.780
And we're going to set the color that
we're going to fill the Bezier path with,

00:07:04.930 --> 00:07:06.870
a nice gray color.

00:07:06.900 --> 00:07:10.300
And let's go ahead and change
the text color to white so that

00:07:10.380 --> 00:07:13.900
it can be more easily seen on
top of the roll-over effect.

00:07:14.080 --> 00:07:16.870
And then we're just going to
let NSTextField do its thing.

00:07:16.950 --> 00:07:17.880
It knows how to draw the text.

00:07:17.960 --> 00:07:19.900
So we draw the roll-over
in the background,

00:07:19.900 --> 00:07:21.900
and then we let it draw the text on top.

00:07:21.970 --> 00:07:23.900
And that's it.

00:07:23.900 --> 00:07:27.060
So if we could go back to the slides,
please.

00:07:31.400 --> 00:07:33.400
Okay,
so we've answered the first question.

00:07:33.400 --> 00:07:37.590
Now, the second question that I've heard
was that you've seen this cool little

00:07:37.680 --> 00:07:40.000
raised editing effect in address book.

00:07:40.200 --> 00:07:42.790
When there's a selected area,
it looks like it's, you know,

00:07:42.800 --> 00:07:45.340
in an editor,
which has this nice shadow around it.

00:07:45.340 --> 00:07:47.460
How can I do that?

00:07:47.990 --> 00:07:51.610
Well, the idea is actually really
pretty simple once you have a key

00:07:51.770 --> 00:07:53.900
bit of insight on how to do it.

00:07:54.040 --> 00:07:58.980
And what we're going to do is track
the text selection and draw this raised

00:07:59.060 --> 00:08:00.900
editor around where the selection is.

00:08:00.900 --> 00:08:03.900
And the key bit of insight is that, well,
first of all,

00:08:03.920 --> 00:08:07.460
we have this new class called
NSShadow in Panther that we're

00:08:07.460 --> 00:08:08.900
going to take advantage of.

00:08:08.900 --> 00:08:12.040
And the second bit is,
what we're going to do is create an

00:08:12.040 --> 00:08:17.900
image which has a hole punched out of the
middle and a shadow around the outsides.

00:08:17.900 --> 00:08:20.420
And because there's a hole
punched in the middle,

00:08:20.420 --> 00:08:23.040
we can just have NSTextView do
its normal drawing,

00:08:23.040 --> 00:08:25.900
and then we draw the image
over top of the text.

00:08:25.900 --> 00:08:28.860
And because there's a hole in the middle,
you get to see the text through it.

00:08:28.900 --> 00:08:32.900
So this is actually just going
to be a subclass of NSTextView.

00:08:32.900 --> 00:08:38.520
Okay, so I mentioned NSShadow
is a new class in Panther.

00:08:42.980 --> 00:08:46.780
It has API which allows you
to configure the shadow,

00:08:46.930 --> 00:08:49.900
configure things about it like
the offset and the blur radius.

00:08:49.900 --> 00:08:54.420
And it has API which lets you
set it as something that's used

00:08:54.540 --> 00:08:57.380
as the current drawing style.

00:08:57.460 --> 00:09:01.430
Just like you can use an NSColor
or an NSFont and tell it to set as

00:09:01.430 --> 00:09:05.870
part of the current drawing style,
you can do the same - you can use it -

00:09:06.000 --> 00:09:39.000
[Transcript missing]

00:09:42.530 --> 00:09:46.160
All right, let's run this and see
what we're going to get.

00:09:46.280 --> 00:09:51.090
So this is a mock-up of something
that you might see in Address Book,

00:09:51.090 --> 00:09:52.710
and it behaves much like Address Book.

00:09:52.830 --> 00:09:54.360
When I click, I get a raised editor.

00:09:54.650 --> 00:09:58.240
If I type,
the raised editor follows the selection.

00:09:58.350 --> 00:10:01.140
And pretty much everything
works sort of like I expect.

00:10:01.250 --> 00:10:03.240
And just for fun,
we know how to do roll-overs now,

00:10:03.240 --> 00:10:05.820
so let's throw those in.

00:10:07.740 --> 00:10:11.920
We'll take a quick look at the nib again.

00:10:11.920 --> 00:10:17.600
We just have one special class in there,
and it's called Raised Editing TextView,

00:10:17.600 --> 00:10:19.580
and it's a subclass of NSTextView.

00:10:19.600 --> 00:10:23.590
We'll go to the code.

00:10:24.520 --> 00:10:31.510
And we have here four classes which
are all part of the implementation

00:10:31.510 --> 00:10:33.400
of this raised text view.

00:10:33.470 --> 00:10:35.400
We're going to focus on one of
those in particular right now,

00:10:35.400 --> 00:10:37.450
but again, like I said,
you can download the code and

00:10:37.760 --> 00:10:39.400
look what the rest of it does.

00:10:39.400 --> 00:10:41.400
But I'll just give a quick overview.

00:10:41.400 --> 00:10:45.100
We have one file which has a category
that defines all the methods dealing

00:10:45.100 --> 00:10:49.380
with handling the text selection,
and making text selection in that

00:10:49.380 --> 00:10:53.710
example works just like you'd expect
it to work if it was address book.

00:10:53.940 --> 00:10:58.230
and then we have a small file that
handles the roll-over effects,

00:10:58.230 --> 00:11:04.010
and then a file which deals with text
attributes and makes those easier

00:11:04.260 --> 00:11:06.900
to use in the rest of our code.

00:11:06.900 --> 00:11:11.750
And if you want to find out more
about what text attributes are,

00:11:12.090 --> 00:11:16.910
A text view and its text storage
deal in attributed text and

00:11:16.910 --> 00:11:20.740
give you the ability to attach
attributes to certain ranges of text.

00:11:20.830 --> 00:11:22.540
And that's sort of what
that class deals with.

00:11:22.590 --> 00:11:26.440
I'd suggest going to Doug Davidson's
talk at 5 o'clock today if you

00:11:26.440 --> 00:11:28.700
want to find out more about that.

00:11:29.120 --> 00:11:31.690
And finally,
we get to the part that deals with

00:11:31.690 --> 00:11:34.740
drawing that raised shadow look.

00:11:34.760 --> 00:11:37.240
And we start out,
we have in our Awake From Nib,

00:11:37.250 --> 00:11:43.620
we do a little UI setup so it fills the
text view with some dummy information.

00:11:43.640 --> 00:11:47.020
And then we have a routine
called Shadow Image Around Path.

00:11:47.020 --> 00:11:51.740
It takes a Bezier path,
which specifies the boundary of

00:11:51.740 --> 00:11:53.980
where we want the shadow to be.

00:11:53.990 --> 00:11:57.410
And what we're going to do is,
given that Bezier path,

00:11:57.730 --> 00:11:59.180
figure out how big the image should be.

00:11:59.180 --> 00:12:01.480
And the image is going to
need to be a little bit bigger

00:12:01.790 --> 00:12:05.400
than the Bezier path's bounds,
because it needs some offsets left,

00:12:05.400 --> 00:12:08.970
right, top,
and bottom to accommodate for the shadow.

00:12:09.350 --> 00:12:14.500
So what we do is we create an image,
and we're going to do something special.

00:12:14.500 --> 00:12:16.330
We're going to cache it
separately because we know

00:12:16.330 --> 00:12:17.960
we're resizing this image a lot.

00:12:17.960 --> 00:12:21.490
We don't want it to be cached in the
same cache window as all the other ones.

00:12:21.560 --> 00:12:24.620
I'd suggest reading up on the
documentation on the web to

00:12:24.630 --> 00:12:28.010
find out more about why we
might do this and what it means.

00:12:28.580 --> 00:12:33.250
We set the image to be flipped because,
well, we're dealing with drawing

00:12:33.250 --> 00:12:37.000
text and typically flipping the
coordinates makes that easier.

00:12:37.090 --> 00:12:40.390
So what this means is the
origin will be at the top left

00:12:40.390 --> 00:12:42.500
instead of the bottom left.

00:12:42.500 --> 00:12:45.960
And finally, we lock focus on the image.

00:12:46.070 --> 00:12:50.140
And what that does is tell the
drawing system that our current

00:12:50.180 --> 00:12:51.500
drawing context is that image.

00:12:51.500 --> 00:12:54.000
All the drawings are going
to go into that image.

00:12:54.000 --> 00:12:58.000
We do a little translation so
that we draw to the right spot.

00:12:58.000 --> 00:13:00.990
And finally,
if we're the first responder,

00:13:00.990 --> 00:13:03.000
we want to have the raised look.

00:13:03.000 --> 00:13:06.120
And what we're going to do is save
away the graphic state so that shadows

00:13:06.140 --> 00:13:09.000
only apply to what we're about to do.

00:13:09.160 --> 00:13:13.580
We create a shadow and
give it some parameters.

00:13:13.580 --> 00:13:17.920
And finally,
we set the shadow and set a color

00:13:17.920 --> 00:13:21.100
so that when we fill the path,
we actually fill something.

00:13:21.100 --> 00:13:25.120
And it'll turn out that it doesn't
matter what color we set that path to,

00:13:25.120 --> 00:13:27.920
because we're about to
erase it in a little bit.

00:13:28.040 --> 00:13:30.100
And you'll see what I'm
talking about there.

00:13:30.100 --> 00:13:32.100
So we set the shadow,
and then we fill with the path.

00:13:32.100 --> 00:13:37.100
So we fill in a region,
in a rectangular region,

00:13:37.100 --> 00:13:40.090
and outside of that
region that we filled in,

00:13:40.100 --> 00:13:42.170
it's going to get some shadow.

00:13:42.640 --> 00:13:43.920
And finally,
we're done drawing with shadows,

00:13:43.960 --> 00:13:46.440
so let's restore the graphics state.

00:13:46.480 --> 00:13:49.030
And now let's knock a
hole out of the middle,

00:13:49.050 --> 00:13:51.080
because we're going to need to
be able to see through that image

00:13:51.170 --> 00:13:52.930
to the text that's behind it.

00:13:52.990 --> 00:13:57.750
And what we do is we clip to the path,
so we make sure that only drawing

00:13:57.760 --> 00:14:02.130
goes into that area inside of the
path that we originally passed.

00:14:02.190 --> 00:14:06.500
We set the color to be clear color,
and then we fill the entire bounds.

00:14:06.610 --> 00:14:08.730
Setting it to clear color basically
knocks a hole out of the middle,

00:14:08.850 --> 00:14:13.010
so it doesn't matter what we set that
color to be before that white color,

00:14:13.050 --> 00:14:15.480
because we've knocked
a hole in the middle.

00:14:15.510 --> 00:14:20.040
And finally, we set sort of a nice light
gray color and draw a border

00:14:20.050 --> 00:14:23.330
around where the shadow is,
just to make it stand

00:14:23.330 --> 00:14:24.920
out a little bit better.

00:14:24.960 --> 00:14:27.220
All right, and then we return the image.

00:14:27.300 --> 00:14:31.110
And finally, we have a routine which
draws the raised editor.

00:14:31.180 --> 00:14:36.520
What it's going to do is find out
where the currently edited range is.

00:14:36.520 --> 00:14:40.480
And if there's a currently
edited selection,

00:14:40.540 --> 00:14:43.020
and TextView deals in glyphs,
not characters.

00:14:43.020 --> 00:14:44.680
Again,
I would go to Doug Davidson's talk if

00:14:44.740 --> 00:14:48.020
you want to find out more about glyphs
and characters and things like that.

00:14:48.020 --> 00:14:53.510
If we have an area that we want
to draw the raised editor in,

00:14:53.550 --> 00:14:57.020
what we're going to do is talk
to the layout manager and find

00:14:57.110 --> 00:15:02.080
out where those glyphs live,
so we get a rectangle back.

00:15:02.850 --> 00:15:06.000
And then we're going to inset - well,
actually,

00:15:06.000 --> 00:15:08.740
we're going to outset it - outset
that rectangle just a little bit

00:15:08.800 --> 00:15:12.410
so there's some separation between
the selection and where the raised

00:15:12.550 --> 00:15:15.160
editor and the shadows start.

00:15:15.230 --> 00:15:18.330
And given that,
we're going to create a Bezier path

00:15:18.440 --> 00:15:23.590
with the rectangle that contains the
edited glyphs and pass that off to our

00:15:23.590 --> 00:15:26.060
helper routine to create a shadow image.

00:15:26.140 --> 00:15:31.150
We get the shadow image back and
we composite it to the screen.

00:15:31.490 --> 00:15:36.200
And finally, all we did was override
DrawRect in NSTextView.

00:15:36.200 --> 00:15:39.400
We let TextView do its thing
because it knows what to do.

00:15:39.400 --> 00:15:40.350
It knows how to draw text best.

00:15:40.400 --> 00:15:44.400
And afterwards, well,
we draw a roll-over if we have one.

00:15:44.400 --> 00:15:47.400
And...roll-overs are cool.

00:15:47.420 --> 00:15:51.400
And then we draw the raised editor.

00:15:51.590 --> 00:15:54.530
And that's it, because, you know,
we draw that image,

00:15:54.530 --> 00:16:00.400
and you're able to see through the
image and to the text behind it.

00:16:00.400 --> 00:16:03.650
Okay, if we go back to the slides,
please.

00:16:08.680 --> 00:16:10.900
So that ends my portion of the talk.

00:16:10.930 --> 00:16:15.410
I'm going to invite up on stage our
next speaker who's going to bring back

00:16:15.470 --> 00:16:18.160
an old friend that some of you might
have been familiar with if you've

00:16:18.160 --> 00:16:19.990
been to WWDC the last couple of years.

00:16:20.090 --> 00:16:23.600
She's going to enhance Dot View and
try to make it the best app ever.

00:16:23.600 --> 00:16:25.270
Tina?

00:16:29.400 --> 00:16:31.200
Thank you very much, Chuck.

00:16:31.230 --> 00:16:34.160
Once again, my name is Tina Huang,
and I work with Chuck on

00:16:34.160 --> 00:16:36.500
the Cocoa frameworks.

00:16:36.720 --> 00:16:41.510
So, many of you are probably familiar
with two of our apps on the system,

00:16:41.510 --> 00:16:42.900
Mail and iChat.

00:16:42.900 --> 00:16:46.540
And you may be thinking, "Wow,
how do they do so many great things

00:16:46.690 --> 00:16:50.850
with their Dock icons?" For instance,
you'll notice here that Mail puts the

00:16:51.160 --> 00:16:55.680
number of unread messages you have
on the upper right side of the icon,

00:16:55.890 --> 00:17:00.000
and when you minimize one
of your iChat buddy windows,

00:17:00.000 --> 00:17:02.250
chat windows,
you have a big picture of your

00:17:02.360 --> 00:17:07.310
buddy's icon in there rather than a
mini version of the entire window.

00:17:07.440 --> 00:17:10.490
Well, there's two things going on here.

00:17:10.540 --> 00:17:15.590
The first is Mail uses something
called Dock icon badging.

00:17:15.590 --> 00:17:19.710
And for iChat,
they actually do something called

00:17:19.710 --> 00:17:22.970
your - they set the Docs mini window.

00:17:22.970 --> 00:17:22.970
And so,

00:17:23.430 --> 00:17:26.100
We want to make
Dot View the best app ever.

00:17:26.250 --> 00:17:29.500
So,
notice here that Dot View traditionally

00:17:29.500 --> 00:17:34.580
has just an icon that's this big red dot,
and for the mini window,

00:17:34.600 --> 00:17:38.780
it just miniaturizes the
window of the entire Dot View.

00:17:38.900 --> 00:17:45.080
So notice here that we're going to have
a colored badge on the dot view icon to

00:17:45.080 --> 00:17:48.570
represent what color your current dot is.

00:17:48.800 --> 00:17:52.520
And we're also going to change the
menu window to just be a version of

00:17:52.520 --> 00:17:54.990
the colored dot that's in your window.

00:17:56.790 --> 00:17:59.840
So first,
let's talk about Dock icon badging.

00:17:59.970 --> 00:18:01.060
It's pretty simple.

00:18:01.220 --> 00:18:03.600
The first thing you want to
do is you want to grab the

00:18:03.600 --> 00:18:07.080
original icon of your Dock,
of your application.

00:18:07.080 --> 00:18:10.010
So to do this,
you're going to ask NSBundle to

00:18:10.020 --> 00:18:14.280
give you the application's main
bundle and then get the path for

00:18:14.280 --> 00:18:17.370
the application from that bundle.

00:18:17.440 --> 00:18:20.720
Once you have the application,
you can go to NSWorkspace and get

00:18:20.720 --> 00:18:25.620
the application's icon for the Dock,
for the application icon.

00:18:25.620 --> 00:18:28.860
Then you want to apply
that badge to the image.

00:18:28.860 --> 00:18:33.200
Then you want to set that new
image to be your new Dock icon.

00:18:33.200 --> 00:18:34.680
And there's one last thing.

00:18:34.680 --> 00:18:39.310
You have to reset the icon back to this
original icon before app termination.

00:18:39.430 --> 00:18:43.340
And the reason being is, you know,
you can imagine a case where an app

00:18:43.340 --> 00:18:47.620
might want to leave that changed,
modified icon as the application.

00:18:47.670 --> 00:18:49.000
But in this case, we don't.

00:18:49.000 --> 00:18:52.940
So we're going to register for
the NSApplicationWillTerminate

00:18:52.940 --> 00:18:54.540
notification and set that icon
back before the application.

00:18:54.540 --> 00:18:55.540
So you can see that the
application is now being set.

00:18:55.540 --> 00:18:55.540
And then you can see that the
application is now being set.

00:18:55.540 --> 00:18:56.510
So you can see that the
application is now being set.

00:18:56.540 --> 00:18:57.530
And then you can see that the
application is now being set.

00:18:57.530 --> 00:18:57.540
And then you can see that the
application is now being set.

00:18:57.540 --> 00:18:58.540
And then you can see that the
application is now being set.

00:18:58.540 --> 00:18:58.630
And then you can see that the
application is now being set.

00:18:58.690 --> 00:18:59.540
And then you can see that the
application is now being set.

00:18:59.540 --> 00:18:59.960
And then you can see that the
application is now being set.

00:18:59.960 --> 00:19:00.540
And then you can see that
the application is now being

00:19:12.420 --> 00:19:16.920
So first, the code here that we're going
to change is pretty simple.

00:19:16.920 --> 00:19:20.290
In the main dot view,

00:19:22.990 --> 00:19:27.440
We have this method that
updates the application badge.

00:19:27.440 --> 00:19:32.270
And what you'll see here is,
the first thing we do is we grab

00:19:32.630 --> 00:19:35.500
the unmodified applications image.

00:19:36.800 --> 00:19:40.110
And we do a bunch of computations
to determine where we want

00:19:40.370 --> 00:19:42.200
to draw that new badge.

00:19:43.770 --> 00:19:45.990
So, here it is.

00:19:46.080 --> 00:19:49.070
We draw the original image.

00:19:54.280 --> 00:20:00.080
We add the badge,
which in this case is just a

00:20:00.080 --> 00:20:00.080
rectangle in the color of the dot.

00:20:02.770 --> 00:20:07.170
Then we call this NSApplication
method "SetApplicationIconImage"

00:20:07.380 --> 00:20:12.290
to set the image to be the new
image with the badge applied.

00:20:13.680 --> 00:20:18.960
And that's basically it,
except for in order to have the

00:20:18.960 --> 00:20:22.800
icon reset to its original state
when the application terminates,

00:20:22.980 --> 00:20:27.640
we want to register for the app
will terminate notification.

00:20:27.690 --> 00:20:29.220
And here it is.

00:20:29.280 --> 00:20:33.340
When we terminate,
we grab the original application icon and

00:20:33.830 --> 00:20:38.950
reset that to be your application's icon.

00:20:39.000 --> 00:20:41.820
And here we're going to run it for you.

00:20:45.050 --> 00:20:47.560
So here's DotView in NOLS Glory.

00:20:47.560 --> 00:20:48.990
And you can resize it.

00:20:49.000 --> 00:20:52.260
And notice here, you have just a red dot.

00:20:52.300 --> 00:20:54.720
I'll make this bigger for you.

00:20:54.890 --> 00:20:58.490
So here, we just have the main dot,
but now we have this colored badge.

00:20:58.740 --> 00:21:04.620
So if we change the color of the dot,
you'll notice here that there's

00:21:04.620 --> 00:21:07.390
now a badge applied to it.

00:21:07.450 --> 00:21:08.200
And that's it.

00:21:08.210 --> 00:21:10.270
May I go back to slides, please?

00:21:17.020 --> 00:21:22.200
So now let's talk about that -
how we do the Dock mini window.

00:21:22.200 --> 00:21:25.460
So the first thing is we want
to actually compute the image

00:21:25.670 --> 00:21:27.580
for the mini window lazily.

00:21:27.580 --> 00:21:31.140
So in order to do this,
we're going to first register for the

00:21:31.140 --> 00:21:34.140
NSWindowDidMiniaturize notification.

00:21:34.140 --> 00:21:36.750
And when we get that notification,
that's when we're going to compute

00:21:36.800 --> 00:21:39.070
the image for the mini window.

00:21:39.580 --> 00:21:42.560
You don't want to be receiving
these notifications for all

00:21:42.560 --> 00:21:44.000
the windows in your app.

00:21:44.000 --> 00:21:47.070
So in order to make sure that
we only have the main window

00:21:47.070 --> 00:21:50.820
receive these notifications,
we're going to look at two

00:21:50.820 --> 00:21:52.610
NSVUE delegate methods.

00:21:52.910 --> 00:21:59.160
And so when you receive the NSView,
didMoveToWindow delegate method,

00:21:59.160 --> 00:22:02.110
you know that you are
now the main window.

00:22:02.110 --> 00:22:04.710
And at this point,
you will register for the

00:22:04.710 --> 00:22:06.840
didMiniaturize notification.

00:22:07.560 --> 00:22:11.510
When you receive the NSView,
View will move to window,

00:22:12.040 --> 00:22:13.220
delegate method.

00:22:13.220 --> 00:22:15.810
That means you're about to switch
out of your window and that's no

00:22:15.810 --> 00:22:17.500
longer going to be your main window.

00:22:17.500 --> 00:22:19.960
And at this point you
want to unregister for the

00:22:19.960 --> 00:22:22.500
NSWindowDidMinitrized notification.

00:22:22.500 --> 00:22:27.110
So, once you get this notification,
you're going to want to create

00:22:27.110 --> 00:22:31.670
the new mini window image and
then set that to be your NSWindow,

00:22:31.790 --> 00:22:33.500
your Windows mini window.

00:22:33.550 --> 00:22:38.500
And to do this, use NSWindow's set mini
window image method.

00:22:38.500 --> 00:22:42.950
So, can I switch back to demo, please?

00:22:55.980 --> 00:23:02.900
So first we'll take a look at the code.

00:23:03.010 --> 00:23:08.280
So again, we first take a look at the
viewDidMoveToWindowDelegate method.

00:23:08.290 --> 00:23:11.600
And when we receive this,
we're going to register for the

00:23:11.600 --> 00:23:14.520
NSWindowDidMinitrized notification.

00:23:15.110 --> 00:23:17.550
When you're about to
move out of the window,

00:23:17.550 --> 00:23:22.100
then you're going to remove
yourself from that notification.

00:23:22.560 --> 00:23:29.440
And here's where the main crux
of the mini window occurs.

00:23:29.480 --> 00:23:34.860
Once we receive that notification,
prepare mini window gets called and

00:23:34.870 --> 00:23:38.940
first we want to compute that new image.

00:23:39.380 --> 00:23:46.100
So we're going to create the image and
draw the dot with the proper color set.

00:23:46.120 --> 00:23:48.770
And that's going to be
a new mini window image.

00:23:49.850 --> 00:23:51.310
And then, here it is.

00:23:51.460 --> 00:23:54.660
You take the main window and
you set the mini window image

00:23:54.780 --> 00:23:56.800
to be the newly computed image.

00:23:56.800 --> 00:23:59.800
And just for fun,
we're going to actually have it

00:23:59.800 --> 00:24:03.790
tell you the radius for the title.

00:24:03.800 --> 00:24:07.010
And so we're going to see that run here.

00:24:10.760 --> 00:24:12.600
So here we go.

00:24:12.700 --> 00:24:17.750
When you change size and
the color of your dot,

00:24:17.750 --> 00:24:19.270
and then

00:24:19.820 --> 00:24:21.500
We're going to miniaturize it.

00:24:21.530 --> 00:24:25.940
Notice here now we just have the
dot as a mini window and it tells

00:24:25.940 --> 00:24:29.460
you that the radius here is 86.6.

00:24:29.460 --> 00:24:33.380
Back to slides, please.

00:24:38.090 --> 00:24:40.830
And so you may now think, wow,
we have dot view with

00:24:40.830 --> 00:24:44.910
all this great stuff,
like this great descriptive Doc icons.

00:24:45.030 --> 00:24:48.350
But what I really want is,
rather than have the slider

00:24:48.460 --> 00:24:52.000
and the color well at the
bottom of your dot view window,

00:24:52.000 --> 00:24:57.000
wouldn't it be great if it had an
animating inspector like Finders?

00:24:57.020 --> 00:24:59.000
Most of you have probably
seen this in Finder,

00:24:59.000 --> 00:25:00.000
and you know, it's pretty neat.

00:25:00.000 --> 00:25:04.000
You have these disclosure triangles,
so you have like the main information.

00:25:04.090 --> 00:25:08.000
You click on the disclosure triangle,
more detailed information occurs.

00:25:08.030 --> 00:25:10.190
So how do you do that?

00:25:11.260 --> 00:25:12.700
Well, it's pretty simple.

00:25:12.710 --> 00:25:18.200
You have your three main views that are
your general views of your inspector.

00:25:18.380 --> 00:25:22.660
And then each one of these views
will have an associated detailed

00:25:22.660 --> 00:25:24.570
view to go along with it.

00:25:25.660 --> 00:25:29.100
The main difficulty here is that
you want to temporarily adjust the

00:25:29.220 --> 00:25:34.600
resizing behavior of each of the
views during the window animation,

00:25:34.600 --> 00:25:38.000
and then animate the window.

00:25:38.190 --> 00:25:42.200
So, let's take a look at
that resizing behavior.

00:25:42.650 --> 00:25:45.900
Most of you are probably used to
doing this in Interface Builder.

00:25:45.900 --> 00:25:50.260
What you have here is you set
a spring that indicates which

00:25:50.260 --> 00:25:53.830
part of your view is variable.

00:25:53.970 --> 00:25:59.160
So in this case, if you set the spring of
the top part of your view,

00:25:59.260 --> 00:26:02.760
that means you're going to be
pinned to the bottom of your window.

00:26:02.820 --> 00:26:06.680
And most of you who are familiar
with Interface Builder are

00:26:06.680 --> 00:26:08.900
probably used to doing this.

00:26:09.290 --> 00:26:13.120
We're going to show you how you can
do the same behavior programmatically.

00:26:13.120 --> 00:26:18.740
So we have this method on
NSView called setAutoResizingMask.

00:26:18.740 --> 00:26:21.330
And here,
rather than have the springs indicate

00:26:21.470 --> 00:26:24.430
the variable parts of your view,
we're going to have the mask

00:26:24.470 --> 00:26:26.360
indicate the same parts.

00:26:26.380 --> 00:26:30.710
And so here you'll notice
you have the NSMaxYMargin,

00:26:30.710 --> 00:26:35.480
the MinYMargin,
and the heightSizableMask.

00:26:35.550 --> 00:26:37.580
And so once again,
if you want your view to

00:26:37.580 --> 00:26:41.210
be pinned to the bottom,
you would set your auto resizing

00:26:41.210 --> 00:26:44.710
mask to be NSMaxYMargin.

00:26:46.520 --> 00:26:50.000
So, for your inspector,
what you're going to want to do is,

00:26:50.050 --> 00:26:55.050
for each view above your expanding view,
you're going to want to set the min-y

00:26:55.600 --> 00:26:57.400
margin as your auto resizing mask.

00:26:57.640 --> 00:27:01.800
For everything below that expanding view,
you're going to want to

00:27:01.980 --> 00:27:03.400
set the max-y margin.

00:27:03.400 --> 00:27:08.370
And for the expanding view itself,
you'll want to make the height sizable.

00:27:08.460 --> 00:27:11.370
And once again, remember,
if you want your window to be resizable,

00:27:11.410 --> 00:27:14.400
make sure that you set them
back to their original states,

00:27:14.400 --> 00:27:18.400
or else funny things will happen
when you try to resize your window.

00:27:18.400 --> 00:27:21.590
So let's go back to demo.

00:27:35.000 --> 00:27:43.900
So first we're going to
take a look at the code.

00:27:43.950 --> 00:27:49.280
And so all the main code here occurs
during this toggle detail visible.

00:27:49.280 --> 00:27:53.580
And this is going to occur every time
you hit that disclosure triangle.

00:27:54.020 --> 00:27:59.470
So the first thing that we do is we
use this new setHidden API available

00:27:59.470 --> 00:28:02.000
in NetEaseView that's new to Panther.

00:28:02.110 --> 00:28:05.790
And basically, if you're now toggling
your view to be visible,

00:28:05.910 --> 00:28:09.640
you want to make sure you make that
view visible before you animate so

00:28:09.640 --> 00:28:12.520
that you're not animating into nothing.

00:28:14.300 --> 00:28:16.780
Then you're going to want to
order all your disclosure views

00:28:16.840 --> 00:28:18.320
to the proper Y coordinate.

00:28:18.440 --> 00:28:22.060
And we have some code that does that.

00:28:22.200 --> 00:28:25.580
And here's that auto-resizing
code we're talking about.

00:28:25.580 --> 00:28:28.860
So for everything above and
below the expanding views,

00:28:28.860 --> 00:28:33.430
you're going to want to set the
auto-resizing mask to the proper mask,

00:28:33.530 --> 00:28:35.310
as we talked about

00:28:36.000 --> 00:28:38.370
And for the view that's
actually expanding,

00:28:38.460 --> 00:28:42.930
we're going to set the auto-resizing
mass to NSViewHeightSizable.

00:28:43.300 --> 00:28:47.490
And finally, you're going to resize the
window using the animation API.

00:28:47.490 --> 00:28:52.640
So we have a set frame to display
and set animate to be yes.

00:28:52.790 --> 00:28:58.110
And once again, if your view is no longer
- if you're now hiding your

00:28:58.190 --> 00:29:00.570
Closing up the disclosure triangle,
you're going to want to set the

00:29:00.650 --> 00:29:03.900
detailed view to be hidden so that
it's taken out of the keyboard

00:29:03.900 --> 00:29:05.100
loop and a bunch of other things.

00:29:05.100 --> 00:29:08.590
So, let's take a look at that.

00:29:12.860 --> 00:29:18.080
So now we have this great
inspector for dot view.

00:29:18.180 --> 00:29:20.400
And so we have a bunch
of things you can do.

00:29:20.650 --> 00:29:23.240
Again,
you can change the size of your dot,

00:29:23.270 --> 00:29:25.660
the color of your dot,
and we have a bunch of

00:29:25.840 --> 00:29:28.760
great new features that,
surprisingly,

00:29:28.760 --> 00:29:31.160
require no code to implement.

00:29:40.100 --> 00:29:41.100
And that's it.

00:29:41.100 --> 00:29:43.250
And notice here that the
disclosure triangles animate

00:29:43.250 --> 00:29:47.100
and everything stays in place.

00:29:47.100 --> 00:29:49.100
Back to slides, please.

00:29:52.560 --> 00:29:55.140
And so, that's DotView for you.

00:29:55.140 --> 00:29:57.380
New and improved.

00:29:57.380 --> 00:30:00.940
So, to teach you some great tricks
that you can do with OpenGL View,

00:30:00.940 --> 00:30:03.080
I'd now like to introduce Mr.

00:30:03.080 --> 00:30:05.420
NSView himself, Troy Stephens.

00:30:10.500 --> 00:30:12.100
Thank you very much, Tina.

00:30:12.170 --> 00:30:15.000
Boy, that dot view just gets more
and more powerful every year.

00:30:15.000 --> 00:30:18.530
I mean, I think we're revolutionizing
dot management,

00:30:18.530 --> 00:30:19.770
am I right?

00:30:21.270 --> 00:30:29.380
So, my topic today,
the slide says it all.

00:30:29.380 --> 00:30:32.760
How can you take an OpenGL view
that you're doing some rendering

00:30:32.880 --> 00:30:34.550
into and go full screen with it?

00:30:34.590 --> 00:30:35.570
You've seen this in games.

00:30:35.660 --> 00:30:37.510
Games take over the entire screen.

00:30:37.770 --> 00:30:40.120
Keynote does this to
show your presentation.

00:30:40.120 --> 00:30:41.530
It's doing it right now.

00:30:41.750 --> 00:30:42.750
Here it is.

00:30:42.750 --> 00:30:44.260
Here's our demo.

00:30:44.260 --> 00:30:46.500
Full screen OpenGL.

00:30:46.650 --> 00:30:47.600
How can you do this?

00:30:47.600 --> 00:30:49.620
Well, there are of course a number
of different ways to connect

00:30:49.710 --> 00:30:54.940
between the platform-independent
industry standard OpenGL API and

00:30:54.940 --> 00:30:57.200
different windowing systems,
and even on Mac OS X.

00:30:57.200 --> 00:31:00.510
I think one of the reasons it's the best
is we give you so many ways to connect.

00:31:00.650 --> 00:31:03.740
We have GLUT, we have AGL,
which existed on Mac OS 9 and is

00:31:03.810 --> 00:31:08.600
generally used by Carbon apps,
we have CGL, which supports AGL,

00:31:08.600 --> 00:31:11.670
and then we have the
NSOpenGL layer in AppKit,

00:31:11.670 --> 00:31:12.520
of course.

00:31:12.630 --> 00:31:15.260
So, in this case,
we're going to focus on how

00:31:15.260 --> 00:31:18.550
you would do this if you're
using the NSOpenGL classes,

00:31:18.550 --> 00:31:23.680
NSOpenGL view, NSOpenGL context,
NSOpenGL pixel format to handle your

00:31:23.680 --> 00:31:26.440
OpenGL windowing in your Cocoa app.

00:31:26.610 --> 00:31:28.600
So we're going to do things a
little differently for this demo.

00:31:28.600 --> 00:31:30.800
We're going to go to the
demo first and take a look,

00:31:30.800 --> 00:31:34.460
just so we have a mental picture in mind
of what it is we're trying to accomplish.

00:31:34.600 --> 00:31:37.810
Then we'll go to slides and we'll take
a look at what some of the concepts

00:31:37.820 --> 00:31:40.620
are that are involved in doing this,
and then I promise we'll

00:31:40.620 --> 00:31:41.600
go back to the code.

00:31:41.600 --> 00:31:42.560
We'll take a look at the code.

00:31:42.600 --> 00:31:44.360
at the code and how you actually do this.

00:31:44.360 --> 00:31:47.460
So if we could go to demo one, please.

00:32:00.850 --> 00:32:06.210
So here we've got an
OpenGL view in a window.

00:32:06.430 --> 00:32:07.800
It does some simple GL rendering.

00:32:07.800 --> 00:32:11.610
We've got a three-dimensional sphere
here with a texture map on it.

00:32:12.320 --> 00:32:16.980
And you'll notice there's some
various... it supports mouse input.

00:32:17.040 --> 00:32:20.300
We can grab with the mouse,
and if we move the mouse vertically,

00:32:20.300 --> 00:32:22.080
we can rotate the sphere.

00:32:22.100 --> 00:32:25.140
We can move the mouse horizontally
and change the direction

00:32:25.140 --> 00:32:26.500
the sun is coming from.

00:32:26.500 --> 00:32:27.440
There's some animation.

00:32:27.440 --> 00:32:28.900
It's rotating.

00:32:28.900 --> 00:32:30.280
There's also keyboard support.

00:32:30.310 --> 00:32:32.940
If I hit the W key,
you'll have to take my word on this.

00:32:32.940 --> 00:32:34.310
I am hitting the W key.

00:32:34.540 --> 00:32:37.600
And it's toggling
wireframe rendering mode.

00:32:37.640 --> 00:32:39.880
We can resize this.

00:32:40.780 --> 00:32:42.930
So if we want to go to
full screen with this,

00:32:42.970 --> 00:32:46.180
say, and take over the entire screen,
fill the entire screen area,

00:32:46.270 --> 00:32:49.700
we just grab this thing down here.

00:32:49.800 --> 00:32:54.900
And there you go!

00:32:54.900 --> 00:32:54.900
Voila!

00:32:55.910 --> 00:32:58.210
But seriously folks,
you want to be able to - what we're

00:32:58.210 --> 00:33:01.940
really talking about here is - I want
to make this clear - not just filling

00:33:01.940 --> 00:33:04.480
the entire screen with your OpenGL view,
you really want to

00:33:04.550 --> 00:33:05.400
take over the hardware.

00:33:05.400 --> 00:33:08.800
You want to take control of that
display so that you can do various

00:33:08.830 --> 00:33:11.300
other things that can help to
improve your rendering performance.

00:33:11.300 --> 00:33:12.850
You want to lock to your screen refresh.

00:33:12.900 --> 00:33:16.690
So we've got a little method
that's wired up to this button,

00:33:16.720 --> 00:33:18.900
and if we do that,
now we're in full screen mode.

00:33:18.900 --> 00:33:19.900
We've still got a mouse pointer.

00:33:19.900 --> 00:33:21.900
We could have hidden
that if we wanted to.

00:33:21.900 --> 00:33:31.290
And you'll notice we still have mouse
response here and keyboard response.

00:33:32.190 --> 00:33:33.340
and we can hit escape.

00:33:33.340 --> 00:33:35.780
You of course always want to
give your users a way out,

00:33:35.790 --> 00:33:36.020
right?

00:33:36.110 --> 00:33:39.040
Because we're in full screen mode,
there's no quit menu

00:33:39.040 --> 00:33:41.710
item here or anything,
so hit escape and we're back

00:33:41.710 --> 00:33:43.040
to non-full screen mode.

00:33:43.140 --> 00:33:47.460
And we can bang on this all
we want and go back and forth.

00:33:47.460 --> 00:33:48.530
It's a pretty smooth transition.

00:33:48.600 --> 00:33:52.320
I'm not trying to do anything
sophisticated like a gamma fade here,

00:33:52.340 --> 00:33:53.430
but it just works.

00:33:53.690 --> 00:33:56.000
I tried to keep the code fairly simple.

00:33:56.090 --> 00:33:57.570
So,

00:33:58.590 --> 00:34:01.090
This is, as I said,
more than just taking a view

00:34:01.090 --> 00:34:03.740
and going full screen with it,
than filling the screen.

00:34:03.740 --> 00:34:05.970
What we're actually doing is
we're rendering to a context.

00:34:06.050 --> 00:34:08.940
We have what's called a
full screen OpenGL context,

00:34:09.040 --> 00:34:13.080
and there's actually no view involved
when we go to full screen mode.

00:34:13.130 --> 00:34:15.500
So this is going to take a
little refactoring of our code,

00:34:15.500 --> 00:34:18.150
some re-architecting of our app
to really fully support this,

00:34:18.150 --> 00:34:18.600
right?

00:34:18.600 --> 00:34:21.600
And if we could go back to slides,
please.

00:34:25.100 --> 00:34:28.000
What are some of the prerequisites?

00:34:28.000 --> 00:34:30.970
This is a somewhat advanced technique,
so we've got a bunch

00:34:30.970 --> 00:34:32.000
of stuff to go through.

00:34:32.120 --> 00:34:36.110
But remember, the sample code, I believe,
is available now online,

00:34:36.110 --> 00:34:40.000
so you can download it after this talk
and study it to your heart's content.

00:34:40.000 --> 00:34:42.380
It'll give you a good baseline
to start with if you're trying to

00:34:42.380 --> 00:34:43.990
implement this technique yourself.

00:34:44.000 --> 00:34:46.000
You can start with something that works.

00:34:46.000 --> 00:34:50.160
One of the things that we need
to do with NSOpenGL is start by

00:34:50.160 --> 00:34:53.000
creating a separate NSOpenGL context.

00:34:53.030 --> 00:34:54.430
So,
if you're using a single-screen context,

00:34:54.520 --> 00:34:56.100
there's one that's
implicitly created for you,

00:34:56.110 --> 00:34:59.000
or you may be explicitly creating
it in your NSOpenGL view.

00:34:59.000 --> 00:35:02.970
So, we want a separate context to render
to when we go to full-screen mode.

00:35:03.010 --> 00:35:05.900
We want to give it the same,
more or less,

00:35:05.900 --> 00:35:10.880
pixel format attributes that we
gave to our non-windowed context.

00:35:11.270 --> 00:35:13.400
Let's say we have some common
attributes that we're using.

00:35:13.400 --> 00:35:18.190
We want 24 bits of color buffer,
we want a 16-bit depth buffer,

00:35:18.190 --> 00:35:20.900
we want a double-buffered
context so we can page flip,

00:35:21.050 --> 00:35:23.350
and we want to specify
that we'd like to have a

00:35:23.350 --> 00:35:27.020
hardware-accelerated rendering context,
because we know we've got some

00:35:27.020 --> 00:35:29.030
great hardware we can render with.

00:35:29.160 --> 00:35:31.560
So when we create our
full-screen OpenGL context,

00:35:31.560 --> 00:35:35.800
we want to use those attributes,
and we want to also specify the

00:35:35.800 --> 00:35:38.010
full-screen pixel format attribute.

00:35:38.090 --> 00:35:39.600
That's pretty straightforward.

00:35:39.690 --> 00:35:42.310
We also want to specify a screen mask.

00:35:42.470 --> 00:35:45.380
Remember, you could be running on
a multi-monitor system,

00:35:45.430 --> 00:35:48.730
so you need to specify which screen
it is that you want to take over

00:35:48.760 --> 00:35:50.800
and go into full-screen mode with.

00:35:50.940 --> 00:35:54.560
And the mask itself, for example,
if you were on the main display,

00:35:54.560 --> 00:35:57.600
you could simply pass this
simple expression here,

00:35:57.600 --> 00:35:59.750
cgDisplayId to OpenGL display mask.

00:35:59.860 --> 00:36:01.350
There's a mask macro for that.

00:36:01.510 --> 00:36:08.000
If you look in cgDirectDisplay.h,
you will find, I believe, this API.

00:36:08.000 --> 00:36:10.100
So let's just say we're
going to the main display.

00:36:10.100 --> 00:36:11.200
We specify that for the mask.

00:36:11.300 --> 00:36:14.600
We also need to do something special
in the non-full-screen context,

00:36:14.600 --> 00:36:17.100
since we know that we want
to go full-screen with that.

00:36:17.150 --> 00:36:20.590
This one's a little obscure,
but by specifying the no-recovery

00:36:20.590 --> 00:36:25.880
attribute in the non-full-screen context,
what we're doing is we're telling

00:36:26.250 --> 00:36:32.400
NSOpenGL that we want a context that
cannot fall back to a software renderer.

00:36:32.400 --> 00:36:34.160
If we want our non-full-screen context
to be compatible with our full-screen

00:36:34.160 --> 00:36:36.000
context for purposes of text-to-text,
then we want to specify that.

00:36:36.000 --> 00:36:36.390
So we specify that for the mask.

00:36:36.450 --> 00:36:38.920
We also need to specify that for the
non-full-screen context for purposes

00:36:38.920 --> 00:36:42.390
of texture sharing and sharing display
lists and other such OpenGL objects.

00:36:42.500 --> 00:36:45.700
We need them to -- we need cgl
to consider them compatible.

00:36:45.700 --> 00:36:48.980
To do that,
we have to make our non-full-screen

00:36:48.980 --> 00:36:51.940
context hardware only,
and that we do that using

00:36:51.940 --> 00:36:53.500
the no-recovery attribute.

00:36:53.500 --> 00:36:57.820
So another thing that we need to
do is we're going to sort of change

00:36:57.820 --> 00:37:00.000
the model of our application.

00:37:00.000 --> 00:37:02.000
Normally, you let AppKit do the driving.

00:37:02.000 --> 00:37:03.200
AppKit runs your run loop.

00:37:03.200 --> 00:37:04.900
AppKit hands you events.

00:37:04.900 --> 00:37:06.200
It tells you when to draw, rec.

00:37:06.200 --> 00:37:07.500
It tells you when to
correct in your view.

00:37:07.500 --> 00:37:09.690
It tells you when you've got a
key down and that sort of thing.

00:37:09.870 --> 00:37:13.700
But when we're in full-screen mode,
we're really taking over the system.

00:37:13.700 --> 00:37:15.100
We're going to drive everything.

00:37:15.160 --> 00:37:17.800
We're going to be in our own loop
for the whole time that we're in

00:37:17.810 --> 00:37:21.490
full-screen mode until we exit,
driving the event loop and

00:37:21.510 --> 00:37:23.990
processing our own events.

00:37:24.210 --> 00:37:28.210
So in order to facilitate this,
what we're going to do is factor

00:37:28.290 --> 00:37:32.880
code out of our NSOpenGLView subclass
and move it into some other common

00:37:32.880 --> 00:37:35.780
objects so that we can reference
it both when we're in full screen

00:37:35.780 --> 00:37:38.460
mode and when we're in windowed mode.

00:37:38.490 --> 00:37:41.740
We're going to take all the
OpenGL initialization and drawing that

00:37:41.740 --> 00:37:46.500
we normally do in our drawRect call
and move that into another object.

00:37:46.600 --> 00:37:48.090
And also our input event handling.

00:37:48.100 --> 00:37:50.350
We want to be able to handle the
same keyboard and mouse events,

00:37:50.460 --> 00:37:53.980
whether we're in full
screen or non-full screen.

00:37:54.680 --> 00:37:57.010
So to help illustrate exactly
what we're doing here,

00:37:57.020 --> 00:37:58.940
we've got our OpenGL view to start with.

00:37:58.940 --> 00:38:02.500
Normally it's got a drawRect method,
it's got a reshape method that

00:38:02.500 --> 00:38:06.730
gets called whenever the view
is resized and needs to adjust

00:38:06.780 --> 00:38:08.640
its GL viewport and so on.

00:38:08.640 --> 00:38:11.300
We also get mouse down
and key down events.

00:38:11.300 --> 00:38:15.730
So the first thing we're going to do
is we're going to take the rendering

00:38:15.730 --> 00:38:20.250
and updating for changes in size,
move those into a scene object

00:38:20.360 --> 00:38:23.430
- this is just an NS object,
this is your sort of data model

00:38:23.430 --> 00:38:26.840
object - so we're going to move all
the rendering out into a separate

00:38:26.840 --> 00:38:29.520
scene object that we define,
so that OpenGL view just

00:38:29.520 --> 00:38:30.840
calls the scene to do that.

00:38:30.840 --> 00:38:33.610
And then we're going to have a
controller object that handles

00:38:33.610 --> 00:38:35.930
all of the keyboard events.

00:38:36.000 --> 00:38:38.640
And we're just going to have
OpenGL view forward all these sort

00:38:38.640 --> 00:38:43.100
of requests to delegate effectively
to these different objects.

00:38:43.100 --> 00:38:46.120
And then main controller
has a go full screen method.

00:38:46.120 --> 00:38:47.500
We're going to look
at that one in detail.

00:38:47.560 --> 00:38:50.280
That's going to be the focus of
what's unique about this demo.

00:38:50.280 --> 00:38:55.720
And that is the method, as I said,
we stay in that method for the entire

00:38:55.720 --> 00:38:57.430
time that we are in full screen mode.

00:38:57.430 --> 00:39:00.840
It takes over control and only
when we exit full screen mode

00:39:00.840 --> 00:39:01.980
does it relinquish control.

00:39:01.980 --> 00:39:04.990
That invocation is live for the
whole time we're in full screen mode.

00:39:05.000 --> 00:39:07.190
And that's exactly what's
wired up to that button that

00:39:07.190 --> 00:39:08.800
I clicked to go full screen.

00:39:08.800 --> 00:39:10.960
So if you'll notice here,
we have a scene object.

00:39:10.960 --> 00:39:12.070
This is our model.

00:39:12.240 --> 00:39:18.880
So we have here, everybody with me,
model view controller.

00:39:19.990 --> 00:39:23.000
It's Friday.

00:39:23.180 --> 00:39:25.800
Okay, since I'm not planning
on quitting my day job,

00:39:25.800 --> 00:39:27.800
we'll look at some API.

00:39:27.910 --> 00:39:29.700
Just a quick overview of some of the API.

00:39:29.700 --> 00:39:31.200
I know this is a lot of stuff,
but these are some of the

00:39:31.200 --> 00:39:34.600
API that we will find particularly
useful in implementing this.

00:39:34.710 --> 00:39:37.600
One thing we want to be able to
do is capture to the display,

00:39:37.600 --> 00:39:40.060
talk to Quartz and say, "Hey,
we want to own this display so that

00:39:40.060 --> 00:39:43.260
we can control it." One of the other
things that you may want to do is

00:39:43.590 --> 00:39:45.200
actually change screen resolution.

00:39:45.200 --> 00:39:48.880
Maybe you want to run in
800x600 or an even higher res

00:39:48.900 --> 00:39:50.490
than the user is running in.

00:39:50.790 --> 00:39:52.500
We don't do that for
simplicity in this demo,

00:39:52.500 --> 00:39:54.730
but it's fairly easy to go
ahead and do that once you've

00:39:54.730 --> 00:39:56.010
taken control of the display.

00:39:56.230 --> 00:39:59.000
You can query Quartz and ask it,
"What are the different modes this

00:39:59.000 --> 00:40:01.690
display supports?" and do that.

00:40:01.790 --> 00:40:05.370
Of course, we're going to be creating
an NSOpenGL context.

00:40:05.560 --> 00:40:09.200
The standard initializer for that,
init with format, share context.

00:40:09.210 --> 00:40:12.110
Notice the share context,
that's what's going to enable us

00:40:12.280 --> 00:40:17.320
to share texture objects with our,
in fact, the earth texture is

00:40:17.320 --> 00:40:19.170
uploaded only once to OpenGL.

00:40:19.300 --> 00:40:21.030
And when we go to full screen mode,
we just,

00:40:21.030 --> 00:40:23.890
since we're specifying the non-full
screen context as a share context,

00:40:23.940 --> 00:40:25.500
we just automatically get it.

00:40:25.500 --> 00:40:27.300
We don't have to send it up there again.

00:40:27.490 --> 00:40:31.120
Set full screen, of course,
a method on NSOpenGL context.

00:40:31.120 --> 00:40:34.740
That's the main method you use to go
into full screen mode when you're ready.

00:40:34.960 --> 00:40:37.380
And then we make,
we want to use make current context

00:40:37.380 --> 00:40:40.280
to make that context current so
we can start drawing into it.

00:40:40.790 --> 00:40:43.440
Another thing you're going to
want to do is potentially sync to

00:40:43.460 --> 00:40:46.080
the refresh rate so that you can,
what this does is it

00:40:46.090 --> 00:40:47.690
avoids tearing artifacts.

00:40:47.880 --> 00:40:52.040
It's basically telling GL that
you want this context to swap

00:40:52.290 --> 00:40:55.990
front and back buffers since we're
double buffered in sync with the

00:40:56.060 --> 00:40:57.200
vertical retrace on your monitor.

00:40:57.200 --> 00:40:58.900
This matters even on an LCD panel.

00:40:58.900 --> 00:41:01.160
Even LCD panels,
people are surprised to discover,

00:41:01.230 --> 00:41:04.100
have a concept of retrace.

00:41:04.260 --> 00:41:09.850
We also are going to need in full
screen mode to flush our buffer each

00:41:09.900 --> 00:41:11.240
time we're done drawing a frame.

00:41:11.400 --> 00:41:13.380
We'll do that explicitly.

00:41:13.480 --> 00:41:15.900
So that's where we swap the
back buffer to the front buffer.

00:41:15.900 --> 00:41:17.900
And then when we want to
exit full screen mode,

00:41:17.900 --> 00:41:19.600
we clear the current context.

00:41:19.600 --> 00:41:24.500
We send a clear drawable message to the
context and that's how we get out of it.

00:41:24.500 --> 00:41:27.100
And then we can let go of the full
screen context and be done with it.

00:41:27.100 --> 00:41:30.100
So if we could go back
to the demo machine,

00:41:30.300 --> 00:41:33.400
look at the source code
that implements this.

00:41:49.540 --> 00:41:51.000
And we have a few different classes here.

00:41:51.000 --> 00:42:00.900
As promised, we have a controller class.

00:42:00.940 --> 00:42:07.350
Our controller has a
connection to the model.

00:42:08.400 --> 00:42:10.600
This is our full screen context here.

00:42:10.600 --> 00:42:13.200
It's just an OpenGL context
like any other.

00:42:13.450 --> 00:42:19.110
We've got a connection out to our view.

00:42:20.190 --> 00:42:23.240
The OpenGL view has a connection
to the scene object that

00:42:23.240 --> 00:42:25.660
knows how to render the scene,
so it can delegate out to

00:42:25.660 --> 00:42:26.900
the scene to draw itself.

00:42:27.050 --> 00:42:28.870
And it has a connection
to the controller,

00:42:28.900 --> 00:42:31.500
so it can send all the input
events to the controller.

00:42:31.500 --> 00:42:34.370
So let's look at the
real interesting part,

00:42:34.710 --> 00:42:35.740
going full screen.

00:42:36.090 --> 00:42:38.330
That's in main controller.

00:42:41.070 --> 00:42:41.950
It's fairly easy to see?

00:42:42.000 --> 00:42:43.590
Okay, good.

00:42:43.650 --> 00:42:46.210
So we'll go right down here
to the Go Fullscreen method.

00:42:46.410 --> 00:42:47.900
This is what's wired up to that button.

00:42:47.900 --> 00:42:51.520
This is where we go first when
we're entering fullscreen mode.

00:42:51.760 --> 00:42:54.120
We have, first of all,
we create our list of

00:42:54.210 --> 00:42:55.700
pixel format attributes.

00:42:55.710 --> 00:42:58.400
You notice we have the
common attributes here.

00:42:58.410 --> 00:43:00.140
These are the same,
you'll see if you look

00:43:00.140 --> 00:43:01.990
at the source code,
as are specified for the

00:43:01.990 --> 00:43:03.200
non-fullscreen context.

00:43:03.200 --> 00:43:05.390
In addition, we've got the display mask.

00:43:05.550 --> 00:43:09.470
We've got the fullscreen
attribute specified here.

00:43:11.440 --> 00:43:13.810
I should say they're the same
common attributes with the exception

00:43:13.860 --> 00:43:15.250
of the no recovery attribute.

00:43:15.350 --> 00:43:18.130
That's in the
non-fullscreen context only.

00:43:18.220 --> 00:43:20.180
So just to - this is a lot of stuff.

00:43:20.240 --> 00:43:23.810
You can look at this at your leisure,
but just to quickly go through it,

00:43:23.810 --> 00:43:27.900
we create the pixel format
with those attributes.

00:43:27.930 --> 00:43:31.270
And just for debugging,
I'm printing out here the renderer ID,

00:43:31.270 --> 00:43:34.440
which identifies uniquely
what card you're running on.

00:43:34.500 --> 00:43:37.530
And you can see in the console
output when we run the app that

00:43:37.530 --> 00:43:39.330
we can do that for diagnostics.

00:43:39.360 --> 00:43:42.180
We see that - we end up seeing that
both the fullscreen and non-fullscreen

00:43:42.180 --> 00:43:43.640
context have the same renderer ID.

00:43:43.640 --> 00:43:45.430
They're talking to the same hardware.

00:43:45.450 --> 00:43:48.500
And that's the whole point
of the no recovery attribute.

00:43:48.500 --> 00:43:50.390
So we create our fullscreen context.

00:43:50.530 --> 00:43:52.440
We're done with the pixel format.

00:43:52.470 --> 00:43:56.420
We temporarily stop the animation timer
because instead of having a timer call us

00:43:56.540 --> 00:44:00.100
back every time we want to switch frames,
what we do is we drive

00:44:00.320 --> 00:44:02.610
the animation ourselves.

00:44:02.680 --> 00:44:06.090
We just check the time interval
each time we go through the loop.

00:44:06.210 --> 00:44:09.040
We're in this loop of checking for input.

00:44:09.100 --> 00:44:12.440
Updating the simulation,
which in this case is just very quickly

00:44:12.440 --> 00:44:15.580
advancing the globe to the next frame,
and then rendering,

00:44:15.590 --> 00:44:18.270
and we just keep doing
that over and over again.

00:44:18.370 --> 00:44:20.060
So we capture the display here.

00:44:20.230 --> 00:44:23.470
Here I've just done capture all displays,
but you can be more specific than that.

00:44:23.480 --> 00:44:25.820
You would want to do that
on a multi-monitor system.

00:44:25.980 --> 00:44:30.200
But capture all displays is
fairly simple and universal.

00:44:30.280 --> 00:44:34.180
Now we tell the context
to set fullscreen.

00:44:34.180 --> 00:44:35.130
We make it current.

00:44:35.420 --> 00:44:36.840
Here's where we set the swap interval.

00:44:36.840 --> 00:44:38.740
This is a case in which we
have to drop down to see if we

00:44:38.740 --> 00:44:38.740
can get it to the fullscreen.

00:44:38.770 --> 00:44:45.370
We're saving the old swap interval
as a courtesy so we can set it back

00:44:45.370 --> 00:44:47.970
again after we exit fullscreen mode.

00:44:48.100 --> 00:44:54.110
We tell the scene to set
up for a new display size.

00:44:54.860 --> 00:44:57.090
And then we enter our loop.

00:44:57.090 --> 00:44:58.800
And the loop is fairly
simple in structure.

00:44:58.800 --> 00:45:00.800
We're checking for and
processing input events.

00:45:00.800 --> 00:45:02.760
It's the first thing we do
each time through the loop.

00:45:02.870 --> 00:45:05.390
Notice what we're doing
with the mouse down event.

00:45:05.520 --> 00:45:07.500
We're sending it to self.

00:45:07.540 --> 00:45:11.550
The controller handles these events,
and the view likewise forwards

00:45:11.550 --> 00:45:13.800
mouse down events to the controller.

00:45:13.800 --> 00:45:15.450
Same thing for mouse up, mouse drag.

00:45:15.450 --> 00:45:17.800
We don't actually use those,
but they're in there.

00:45:17.850 --> 00:45:18.790
Key down.

00:45:18.800 --> 00:45:20.420
So we check for input.

00:45:20.420 --> 00:45:23.330
We check the time
interval for this frame,

00:45:23.330 --> 00:45:26.630
and we advance our
animation by the time delta.

00:45:26.800 --> 00:45:28.800
And then we render the scene.

00:45:28.800 --> 00:45:31.800
And as I said, we flush buffer when
we're in full screen mode.

00:45:31.860 --> 00:45:35.860
This is telling GL to do the page flip,
bring the back buffer forward,

00:45:35.960 --> 00:45:37.690
and now we're going to start
over and draw the next frame

00:45:37.760 --> 00:45:38.800
on the new back buffer.

00:45:38.800 --> 00:45:42.040
And we're using an auto-release pool
here so that each time through the

00:45:42.040 --> 00:45:44.720
loop any objects that are created,
since, again,

00:45:44.720 --> 00:45:46.800
AppKit isn't driving things anymore.

00:45:46.800 --> 00:45:48.770
We don't have it to clean
up auto-release things.

00:45:48.850 --> 00:45:50.460
We have to clean up the
first objects for us,

00:45:50.530 --> 00:45:51.800
so this is a common technique.

00:45:51.800 --> 00:45:54.100
You create an auto-release pool,
and you release it at

00:45:54.190 --> 00:45:56.800
the end of the loop,
and everything gets cleaned up for you.

00:45:56.800 --> 00:45:59.540
Then there's a little trick
in here you'll see to sort

00:45:59.650 --> 00:46:02.650
of clear the frame buffer,
clear a couple of pages before we

00:46:02.650 --> 00:46:04.800
switch back out of full screen mode.

00:46:04.800 --> 00:46:08.200
This avoids just kind of an
ugly flash of garbage when you

00:46:08.200 --> 00:46:11.760
go out to back to full screen,
back to non-full screen.

00:46:11.830 --> 00:46:13.800
We're setting the swap interval
back to be a good citizen.

00:46:13.800 --> 00:46:17.350
We're clearing the current context,
clearing the drawable.

00:46:17.600 --> 00:46:21.250
We're releasing all displays
and just telling our windowed

00:46:21.250 --> 00:46:23.500
OpenGL view we need display,
and that's it.

00:46:23.500 --> 00:46:25.710
So you see we have a key down
method in the controller that

00:46:25.710 --> 00:46:29.500
actually handles the response for
any key that might be pressed.

00:46:29.500 --> 00:46:34.120
Mouse down is implemented in main
controller to do the work that is done

00:46:34.120 --> 00:46:38.500
when the mouse is clicked and then
dragged to rotate the globe and so on.

00:46:38.500 --> 00:46:42.480
So if we look at, very quickly,
at the view object,

00:46:42.490 --> 00:46:46.480
we've got very little left
in the view object here.

00:46:46.770 --> 00:46:49.260
It creates the pixel format,
its own pixel format,

00:46:49.260 --> 00:46:53.990
again with the no recovery attribute,
and it's in it with frame method.

00:46:54.760 --> 00:46:59.290
But everything else -
DrawRec delegates out to the scene,

00:46:59.290 --> 00:47:01.070
Reshape delegates out to the scene.

00:47:01.070 --> 00:47:04.130
You get the idea by now that
we're just forwarding all those

00:47:04.130 --> 00:47:06.880
input objects to the scene,
all those input events

00:47:06.880 --> 00:47:09.350
to the controller object,
and all of the requests

00:47:09.350 --> 00:47:10.690
to render to the scene.

00:47:10.700 --> 00:47:15.690
So we've refactored our code, as it said,
to better facilitate going full screen.

00:47:15.710 --> 00:47:16.570
So I know it's a lot of stuff.

00:47:16.690 --> 00:47:20.690
The source code, I believe,
is online now if you log

00:47:20.690 --> 00:47:22.700
into your ADC account.

00:47:22.860 --> 00:47:25.990
And with that,
I'd like to go back to slides.

00:47:26.810 --> 00:47:29.530
and puts you in the very
capable hands of Mr.

00:47:29.530 --> 00:47:33.210
Doug Davidson,
owner of the incredibly powerful,

00:47:33.210 --> 00:47:35.540
insanely great tech system in Cocoa,
who's going to show you

00:47:35.540 --> 00:47:36.700
some very cool stuff.

00:47:36.700 --> 00:47:39.110
So, thank you.

00:47:44.150 --> 00:47:48.100
Hi, I'm Doug Davidson,
and I'm here to answer the next question.

00:47:48.100 --> 00:47:50.100
So let's see, the question, please.

00:47:50.260 --> 00:47:54.170
All right, the question is:
iChat puts these beautiful

00:47:54.170 --> 00:47:55.860
bubbles around its text.

00:47:55.860 --> 00:47:58.040
How could you do something like that?

00:47:58.130 --> 00:47:59.060
Good question, folks.

00:47:59.060 --> 00:48:00.100
Thanks.

00:48:00.100 --> 00:48:03.250
Now, if you want to know more about
the theoretical underpinnings

00:48:03.310 --> 00:48:05.480
for this sort of thing,
you can come to my talk

00:48:05.480 --> 00:48:09.070
later on this afternoon,
5:00, on the Cocoa text system.

00:48:09.070 --> 00:48:12.130
But this is Tips and Tricks,
so we're just going to

00:48:12.130 --> 00:48:13.790
jump right in and do it.

00:48:14.890 --> 00:48:19.130
And what we're going to do is
draw one of these bubbles around

00:48:19.130 --> 00:48:21.580
each paragraph of the text.

00:48:21.610 --> 00:48:24.040
So there are a few things
we have to keep in mind.

00:48:24.150 --> 00:48:28.850
Now, the Cocoa text system automatically
makes sure that the text will

00:48:28.850 --> 00:48:31.260
be redrawn whenever it changes.

00:48:31.400 --> 00:48:35.450
But these bubbles are going to be
a little bit bigger than the text,

00:48:35.560 --> 00:48:39.730
so we're going to need to make sure
ourselves that they get redrawn,

00:48:39.730 --> 00:48:40.270
too.

00:48:40.940 --> 00:48:46.370
Now, we're going to be drawing these
bubbles above the background and

00:48:46.370 --> 00:48:48.900
below the glyphs in the text itself.

00:48:48.900 --> 00:48:51.800
So the way we're going to do that is
- should be fairly obvious - we're

00:48:51.800 --> 00:48:57.890
going to subclass NSTextView to
add some additional drawing to it.

00:48:58.120 --> 00:49:02.800
And we're going to want to draw one
bubble around each paragraph of the text.

00:49:02.900 --> 00:49:07.070
So the main thing we need to know
in order to do that is where the

00:49:07.070 --> 00:49:11.900
paragraphs are located - location
and size for each paragraph.

00:49:12.000 --> 00:49:16.960
And the general answer to any question
of that sort in the text system is:

00:49:16.960 --> 00:49:18.900
ask the Layout Manager.

00:49:18.900 --> 00:49:20.890
NSLayoutManager knows all.

00:49:20.960 --> 00:49:22.430
So we're going to ask the
Layout Manager to find out the

00:49:22.430 --> 00:49:25.540
information that will tell us
where the paragraphs are located,

00:49:25.580 --> 00:49:27.680
so we can draw the bubbles around them.

00:49:29.440 --> 00:49:33.060
So some APIs we're going to need.

00:49:33.060 --> 00:49:36.460
All views have a method
setNeedsDisplayInRect,

00:49:36.600 --> 00:49:41.270
but nstextview has an additional,
somewhat more specific method,

00:49:41.320 --> 00:49:45.800
setNeedsDisplayInRectAvoidAdditionalLay
out.

00:49:45.800 --> 00:49:48.040
So we need to know that because
we're going to be overriding that.

00:49:48.110 --> 00:49:53.280
It gets called quite a bit from
the text system when text changes

00:49:53.280 --> 00:49:56.800
and things need to be redisplayed.

00:49:56.800 --> 00:50:01.230
And nstextview has another method,
new for Panther,

00:50:01.610 --> 00:50:04.300
called drawViewBackgroundInRect.

00:50:04.370 --> 00:50:06.940
And what this does,
this is the method that

00:50:07.090 --> 00:50:11.300
nstextview uses to actually draw
the background for the view.

00:50:11.300 --> 00:50:15.870
And so we're going to be overriding
that so we can do our drawing above

00:50:15.870 --> 00:50:18.250
the background below the text.

00:50:18.970 --> 00:50:24.230
And then we're going to need
some NSLayoutManager methods.

00:50:24.290 --> 00:50:26.300
First of all,
generically in the Cocoa system,

00:50:26.300 --> 00:50:32.530
you always need to use the layout
manager to convert between ranges of

00:50:32.620 --> 00:50:36.430
characters in the text and ranges of
glyphs that are displayed on the screen.

00:50:36.450 --> 00:50:38.760
So we'll need those methods.

00:50:38.850 --> 00:50:43.990
And we'll need some more layout manager
methods to go from a rec that's being

00:50:43.990 --> 00:50:47.870
drawn to the glyphs in that range.

00:50:48.150 --> 00:50:55.500
and to determine where the lines
of text are in the text view.

00:50:55.500 --> 00:51:00.090
And we also have a new method
in Panther on NSString called

00:51:00.530 --> 00:51:02.990
paragraph range for range.

00:51:03.090 --> 00:51:05.190
There's always been a
method line range for range,

00:51:05.200 --> 00:51:09.640
but in Panther we distinguish between
line ranges and paragraph ranges.

00:51:09.640 --> 00:51:21.320
And what we really want here is the
range of a paragraph in the text.

00:51:21.320 --> 00:51:21.320
So we're going to use that method to
determine what the ranges of paragraphs

00:51:21.320 --> 00:51:21.320
are in the characters of the text.

00:51:21.390 --> 00:51:26.200
So let's take a look at some code.

00:51:26.200 --> 00:51:26.200
If we can come over to demo one.

00:51:40.080 --> 00:51:49.040
Here's our subclass of NSTextView.

00:51:49.040 --> 00:51:54.220
And so the first method I want to point
out is our override of set needs display

00:51:54.330 --> 00:51:56.840
and rect avoid additional layout.

00:51:56.970 --> 00:52:01.540
And so, as I said,
we need to make sure that these bubbles,

00:52:01.580 --> 00:52:05.620
which are a little bit bigger
than the paragraphs they enclose,

00:52:05.710 --> 00:52:09.100
are going to get redrawn
when the paragraph changes.

00:52:09.180 --> 00:52:13.430
And the quick and dirty way to do
that here is to simply expand the rect

00:52:13.540 --> 00:52:18.250
that is being dirtied by the amount,
the width and height that the

00:52:18.380 --> 00:52:20.900
bubble overlaps from the text.

00:52:20.990 --> 00:52:24.380
We could probably be a little
bit more precise here if we

00:52:24.420 --> 00:52:27.670
did a little bit more work,
but this works fine.

00:52:29.020 --> 00:52:36.600
And then the next method I want to point
out is draw a view background in Rect,

00:52:36.600 --> 00:52:39.300
which we are overriding in NSTextView.

00:52:39.300 --> 00:52:42.180
So the first thing we do
is call the super method,

00:52:42.290 --> 00:52:45.440
which actually draws the background,
because we want to draw the

00:52:45.440 --> 00:52:47.550
background first before the bubbles.

00:52:48.010 --> 00:52:52.920
And then we're going to figure out
where each paragraph is in the rack

00:52:52.920 --> 00:52:57.300
that we're being asked to draw so
we can draw a bubble around it.

00:52:58.510 --> 00:53:03.830
So, one thing we always have to do in
working with the Layout Manager,

00:53:03.930 --> 00:53:06.760
the Layout Manager works in
text container coordinates,

00:53:06.810 --> 00:53:09.520
not in view coordinates,
so we have to do a translation to

00:53:09.520 --> 00:53:11.400
get into container coordinates.

00:53:11.720 --> 00:53:16.210
Then we ask the Layout Manager to
determine what the range of glyphs is

00:53:16.370 --> 00:53:21.400
that we need to deal with to cover the
rec that we're being asked to redraw.

00:53:21.400 --> 00:53:25.480
And we'll convert that to
a character range so we can

00:53:25.480 --> 00:53:28.410
examine the corresponding text.

00:53:30.300 --> 00:53:33.890
This is the text that we need to
determine the ranges of paragraphs,

00:53:33.910 --> 00:53:38.160
and we'll go through that
text paragraph by paragraph,

00:53:38.240 --> 00:53:40.000
iterating through each.

00:53:40.100 --> 00:53:45.350
And so we determine the range of a given
paragraph by using the NSString method

00:53:45.350 --> 00:53:47.530
paragraph range for range.

00:53:47.560 --> 00:53:50.340
So we'll loop through it
paragraph by paragraph,

00:53:50.440 --> 00:53:52.950
and for each paragraph,
we'll have the range of

00:53:52.950 --> 00:53:54.800
characters in that paragraph.

00:53:54.920 --> 00:53:59.800
Then we're going to go back to
the Layout Manager to determine

00:53:59.920 --> 00:54:02.600
where that paragraph is located.

00:54:02.700 --> 00:54:06.380
So we'll get a glyph range
corresponding to that paragraph

00:54:06.460 --> 00:54:08.500
range from the Layout Manager.

00:54:08.590 --> 00:54:12.310
And then we're going to go to the
Layout Manager to determine where

00:54:12.560 --> 00:54:20.500
the lines in that paragraph are in
the text container and the text view.

00:54:21.020 --> 00:54:24.910
So this is a very common idiom when
dealing with the Layout Manager,

00:54:24.910 --> 00:54:27.900
to iterate through by lines.

00:54:27.900 --> 00:54:32.890
And we call the line fragment
used rect for glyph and index

00:54:33.000 --> 00:54:34.780
method in the Layout Manager.

00:54:34.820 --> 00:54:38.010
And what that does is it
returns what we're asking for,

00:54:38.010 --> 00:54:41.690
which is the used rect
for a particular line.

00:54:41.730 --> 00:54:45.600
And we want that because
that's part of the paragraph.

00:54:45.670 --> 00:54:49.490
And it also returns by reference
the range of glyphs in that line.

00:54:49.550 --> 00:54:52.790
So that will help us
iterate through by lines.

00:54:52.830 --> 00:54:55.200
We're going to skip after we're
done with this to the beginning

00:54:55.200 --> 00:54:59.300
of the next glyph after this line.

00:54:59.340 --> 00:55:03.430
And then we take that used rect and
unit it in to the rect that we're

00:55:03.460 --> 00:55:08.510
determining for the paragraph that
tells us where the paragraph lives.

00:55:08.880 --> 00:55:11.630
But again,
all the coordinates that the Layout

00:55:11.630 --> 00:55:14.360
Manager uses are container coordinates.

00:55:14.360 --> 00:55:16.800
So, in order to get it back
to view coordinates,

00:55:16.800 --> 00:55:21.800
we take our paragraph correct and
we undo that same translation.

00:55:21.800 --> 00:55:26.800
And then we call a method that we
have that actually draws the bubble.

00:55:27.050 --> 00:55:30.520
And actually drawing the
bubble is pretty simple.

00:55:30.520 --> 00:55:32.800
I don't want to go into
it in too much detail,

00:55:32.800 --> 00:55:35.800
but we have some nice images.

00:55:35.880 --> 00:55:39.640
And we draw an image on one side,
an image on the other side,

00:55:39.640 --> 00:55:42.790
and we fill the middle
with a pattern image.

00:55:42.790 --> 00:55:46.420
So, now we put it all together.

00:55:46.790 --> 00:55:52.440
Let's run it and see how it works.

00:55:57.600 --> 00:55:59.600
There we go.

00:55:59.600 --> 00:56:04.600
Thank you.

00:56:04.600 --> 00:56:07.710
Now if we could go back to the slides.

00:56:10.720 --> 00:56:14.300
I'd like to bring up
Chuck again to wrap things up.

00:56:15.520 --> 00:56:17.290
Thank you, Doug.

00:56:17.300 --> 00:56:18.260
All right.

00:56:18.300 --> 00:56:19.780
Thanks, Doug.

00:56:23.330 --> 00:56:26.000
So, I hope you guys have had
some fun with this session.

00:56:26.000 --> 00:56:29.010
That was sort of the intent of it,
have some fun, show you guys how to

00:56:29.010 --> 00:56:30.300
do some cool features.

00:56:30.450 --> 00:56:32.290
And I think, you know,
I had a lot of fun.

00:56:32.300 --> 00:56:36.250
In fact, the most fun of the afternoon
was seeing Troy sing up here.

00:56:36.330 --> 00:56:39.040
I hope you all enjoyed
that as much as I did.

00:56:39.550 --> 00:56:46.000
So let's do the wrap-up and, well,
there's not much left.

00:56:46.160 --> 00:56:48.970
Okay, so you all know by now you're
getting DVDs and so on,

00:56:49.000 --> 00:56:52.000
so take a look at those
when you get a chance.

00:56:52.000 --> 00:56:56.450
What I want to point out is
a talk that's at 5 o'clock.

00:56:56.530 --> 00:56:57.990
I hope some of you can
stick around for that.

00:56:58.000 --> 00:57:01.260
You're going to see Doug talk even
more about the tech system and

00:57:01.260 --> 00:57:03.990
find out how powerful it really is.

00:57:04.000 --> 00:57:06.250
It's very, very cool stuff.

00:57:06.480 --> 00:57:09.600
And the other thing I want to
point out is who to contact.

00:57:09.600 --> 00:57:12.790
You probably all know this by now.

00:57:13.370 --> 00:57:16.040
John Glunzey is your main contact.

00:57:16.040 --> 00:57:17.790
We've all seen this before.

00:57:17.800 --> 00:57:19.300
I'm just going to skip ahead.

00:57:19.300 --> 00:57:22.150
I want to show you that
there's some more information.

00:57:22.330 --> 00:57:27.300
What I want to point out
here is the demo code.

00:57:27.300 --> 00:57:29.640
The demo code,
if it's not available right now,

00:57:29.640 --> 00:57:31.300
should be up there very soon.

00:57:31.300 --> 00:57:35.040
Each of the demos that you saw on
stage here will be available for you to

00:57:35.140 --> 00:57:37.300
download and look at at your leisure.
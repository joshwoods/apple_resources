WEBVTT

00:00:24.600 --> 00:00:26.920
Welcome to the final day of WWDC.

00:00:26.920 --> 00:00:31.650
So, kicking the graphics track off
this morning with Session 211,

00:00:31.650 --> 00:00:33.590
which is Introduction to Quartz Services.

00:00:33.710 --> 00:00:36.490
And the primary focus of this session
is going to be the non-drawing APIs that

00:00:36.490 --> 00:00:38.220
are part of the Quartz architecture.

00:00:38.220 --> 00:00:40.930
These APIs do things
like manage the displays,

00:00:40.930 --> 00:00:45.400
even facilitate doing certain common
operations that developers need to do,

00:00:45.400 --> 00:00:48.850
such as what we call screen scraping,
or pulling pixels back

00:00:48.920 --> 00:00:50.530
out of the framebuffer.

00:00:51.160 --> 00:00:54.850
And the key thing is that the important
part of the session is that these

00:00:54.850 --> 00:00:59.050
APIs that we're going to be talking
about in the session are essentially

00:00:59.190 --> 00:01:04.300
the APIs that lie underneath other
APIs to do display management

00:01:04.300 --> 00:01:07.300
that you might be familiar with,
like some QuickTime APIs,

00:01:07.300 --> 00:01:11.880
DrawSprocket APIs,
and Display Manager APIs.

00:01:11.880 --> 00:01:15.200
And one of the reasons we put this
session together is because we

00:01:15.200 --> 00:01:18.820
really want developers to migrate
to the Display Services APIs,

00:01:18.820 --> 00:01:21.130
because that's really where
all the work actually happens.

00:01:21.160 --> 00:01:24.040
And you're getting closer to
the native API and getting more

00:01:24.040 --> 00:01:26.030
functionality in doing it that way.

00:01:26.040 --> 00:01:28.240
So,
it's my pleasure to invite Mike Paquette,

00:01:28.240 --> 00:01:30.790
Graphics and Imaging Engineer,
to the stage to take you

00:01:30.790 --> 00:01:32.220
through the presentation.

00:01:36.800 --> 00:01:38.700
Good morning!

00:01:38.700 --> 00:01:41.650
I'm Mike Paquette.

00:01:41.650 --> 00:01:44.680
I'm the person in the Quartz
team who takes care of all the

00:01:45.400 --> 00:01:48.410
non-drawing parts of Quartz.

00:01:48.700 --> 00:01:50.910
I'm the guy working way down
there in the bowels of the system,

00:01:50.970 --> 00:01:53.200
fixing the plumbing,
wrapping in a little duct tape here

00:01:53.210 --> 00:01:56.020
and there as your requests come in,
implementing all those

00:01:56.020 --> 00:01:57.170
nice features you need.

00:01:57.290 --> 00:02:00.280
And I'll be going over Quartz Services.

00:02:02.110 --> 00:02:03.000
Quartz Services.

00:02:03.000 --> 00:02:04.650
What can Quartz Services do for you?

00:02:04.660 --> 00:02:07.700
We're the non-drawing part of Quartz.

00:02:07.800 --> 00:02:09.400
Yeah,
there's code that doesn't draw in there.

00:02:09.510 --> 00:02:11.660
That's a lot, but eh.

00:02:12.000 --> 00:02:14.400
We handle all the
display management stuff.

00:02:14.420 --> 00:02:20.020
We give you the functionality you need to
take over a display to do a presentation.

00:02:20.720 --> 00:02:23.370
We let you reconfigure the displays.

00:02:23.670 --> 00:02:27.360
We can let you position
displays on your desktop.

00:02:27.360 --> 00:02:29.680
We can let you adjust the
resolution of the displays,

00:02:29.750 --> 00:02:33.200
change the refresh rate,
do all those fun little tweaks.

00:02:33.200 --> 00:02:37.620
The Display Preferences panel is an
example of someone who uses our services.

00:02:37.620 --> 00:02:40.440
We also handle some
special purpose tasks.

00:02:40.440 --> 00:02:44.510
We give you the basics you need to
read the framebuffer contents off,

00:02:44.680 --> 00:02:46.410
that screen scraping thing.

00:02:46.410 --> 00:02:51.510
We also have support for doing
remote control of the computer.

00:02:51.800 --> 00:02:57.200
programs like Apple Remote Desktop and
Timbuk2 can take advantage of this stuff.

00:02:57.360 --> 00:03:00.450
Now,
most apps don't need Quartz Services,

00:03:00.450 --> 00:03:02.320
this low-level stuff.

00:03:02.320 --> 00:03:06.790
Most apps will run just fine and don't
even need to know this stuff exists.

00:03:08.010 --> 00:03:09.960
Where does this fit in in Quartz?

00:03:09.980 --> 00:03:12.380
We're the display management code.

00:03:12.410 --> 00:03:14.910
We're your screen scraping support,
and we're event injection.

00:03:14.940 --> 00:03:18.480
Event injection's a fancy way of saying,
take an event and stick it into

00:03:18.480 --> 00:03:22.520
the event chain and let it dribble
on down to all the applications.

00:03:26.000 --> 00:03:30.000
We're going to give you full-screen
application support information here

00:03:30.000 --> 00:03:33.780
and display configuration information,
and we'll go over a few of the more

00:03:33.790 --> 00:03:35.540
obscure APIs that are in there.

00:03:35.540 --> 00:03:40.120
Some just help you out with backward
compatibility and some to help you do

00:03:40.120 --> 00:03:43.360
some neat things that you might not
have been able to do very easily before.

00:03:43.360 --> 00:03:45.800
We're also going to cover the
Remote Operation Services.

00:03:45.800 --> 00:03:47.130
That's the screen scraping part.

00:03:47.190 --> 00:03:48.740
I've got some sample code for you.

00:03:48.740 --> 00:03:52.000
We'll walk you through a little
bit of tricks and techniques there

00:03:52.000 --> 00:03:54.760
and show you how to post some
events for remote control purposes.

00:03:55.700 --> 00:03:58.450
And also give you guys who are writing
user-based device drivers some tips

00:03:58.450 --> 00:03:59.710
on how to make that work right.

00:04:01.970 --> 00:04:03.660
Now, we've got some definitions.

00:04:03.710 --> 00:04:05.700
We use some funny terms
in Quartz sometimes.

00:04:05.700 --> 00:04:08.050
Display ID.

00:04:08.050 --> 00:04:10.840
Well, it's probably something
that identifies a display,

00:04:10.840 --> 00:04:11.100
huh?

00:04:11.100 --> 00:04:12.130
You figured that much out.

00:04:12.160 --> 00:04:15.840
Okay, display IDs are numbers
that go along with displays.

00:04:15.840 --> 00:04:17.920
They're 32-bit-ish kind of things.

00:04:17.920 --> 00:04:19.830
There's a typedef in there for them.

00:04:19.840 --> 00:04:26.480
The numbers stay the same for any
specific exact hardware configuration,

00:04:26.480 --> 00:04:28.780
even across reboots.

00:04:29.200 --> 00:04:31.260
Any changes in the
hardware configuration,

00:04:31.260 --> 00:04:33.380
you unplug a display and replace
it with a different model,

00:04:33.380 --> 00:04:36.060
you move the display to a different
connector on the back of the machine,

00:04:36.060 --> 00:04:37.750
you're going to get a
different display ID.

00:04:40.370 --> 00:04:43.390
Now, all these displays that
we hook up to the machine,

00:04:43.390 --> 00:04:46.680
you'll query in Quartz
Services using that display ID.

00:04:46.680 --> 00:04:50.010
That's how you identify them to Quartz,
and that's how Quartz tells

00:04:50.050 --> 00:04:51.130
you about the displays.

00:04:54.830 --> 00:04:57.100
Display States.

00:04:57.130 --> 00:04:59.940
We have a bunch of different
states monitors can be in.

00:04:59.940 --> 00:05:01.400
A bunch of states the
framebuffers can be in.

00:05:01.400 --> 00:05:04.540
We combine all that together and just
refer to this as a display state.

00:05:04.540 --> 00:05:08.280
States include active,
and active display is

00:05:08.280 --> 00:05:09.580
one you can draw on.

00:05:09.810 --> 00:05:11.190
That's pretty straightforward.

00:05:11.260 --> 00:05:13.210
It's there and it's nice and drawable.

00:05:13.440 --> 00:05:15.780
We can have displays that go to sleep.

00:05:15.870 --> 00:05:16.540
You're familiar with that.

00:05:16.570 --> 00:05:18.650
It goes blank.

00:05:18.790 --> 00:05:20.740
One of the energy star modes
usually kicks in on a monitor.

00:05:20.740 --> 00:05:23.770
It gets all nice and quiet.

00:05:24.440 --> 00:05:26.450
Don't draw on asleep displays.

00:05:26.580 --> 00:05:29.400
Now, again,
if you're an ordinary application,

00:05:29.460 --> 00:05:30.590
you don't need to worry about that.

00:05:30.780 --> 00:05:32.870
It's all covered for you.

00:05:33.160 --> 00:05:36.490
The only time you really need to be
concerned about these is if you're

00:05:36.490 --> 00:05:39.390
writing something that's drawing directly
to the screen itself through one of our

00:05:39.390 --> 00:05:41.570
fancy APIs we're going to get into here.

00:05:41.780 --> 00:05:43.600
Mirroring.

00:05:43.660 --> 00:05:47.430
Oh, mirroring has changed
so much over the years.

00:05:47.810 --> 00:05:50.710
We've introduced things
like hardware mirroring,

00:05:50.710 --> 00:05:52.420
and we've got software mirroring.

00:05:52.420 --> 00:05:55.700
We have hardware-generated display maps
and all sorts of other wacky things.

00:05:55.700 --> 00:05:59.160
I'll be getting into all those
different states in detail and giving

00:05:59.220 --> 00:06:01.330
you some tips on how to deal with that.

00:06:01.800 --> 00:06:02.960
We have online displays.

00:06:02.960 --> 00:06:07.900
An online display is pretty much a
monitor plugged into the computer.

00:06:08.940 --> 00:06:12.300
It may be awake or asleep,
it may be mirrored or unmirrored,

00:06:12.300 --> 00:06:13.560
but it's connected.

00:06:13.560 --> 00:06:14.220
Offline?

00:06:14.220 --> 00:06:18.700
Well, that's the connector on the back of
your computer with no monitor there.

00:06:18.700 --> 00:06:22.200
It's just offline, all alone,
a placeholder in the system.

00:06:22.200 --> 00:06:25.380
Don't try to talk to the
system about offline monitors.

00:06:25.380 --> 00:06:26.910
They aren't there.

00:06:28.060 --> 00:06:32.370
You'll see all through our
programming interfaces this CG prefix.

00:06:32.770 --> 00:06:35.060
CG is, of course,
as is intuitively obvious

00:06:35.110 --> 00:06:39.070
to the most casual observer,
the prefix for Quartz.

00:06:42.960 --> 00:06:45.980
Now,
the Display Services part of the system

00:06:46.040 --> 00:06:49.710
is going to cover display enumeration,

00:06:50.770 --> 00:06:54.350
It's going to tell you that is,
what are all the displays?

00:06:54.540 --> 00:06:55.190
Give me a list, please.

00:06:55.190 --> 00:06:58.060
It's going to cover
display configuration.

00:06:58.180 --> 00:07:01.790
Place this display here,
change this one's resolution,

00:07:01.790 --> 00:07:05.090
change the refresh rate,
change the bit depth.

00:07:05.600 --> 00:07:08.230
We're going to cover
Palette Display Support.

00:07:08.230 --> 00:07:12.340
Now there's something you
haven't heard about in a while.

00:07:12.470 --> 00:07:13.420
Palettes.

00:07:13.420 --> 00:07:15.410
It's so 70s.

00:07:16.270 --> 00:07:18.520
And we've got some new
goodies for Panther,

00:07:18.540 --> 00:07:21.510
our Display Fade API.

00:07:25.800 --> 00:07:26.810
Competitive technologies.

00:07:26.960 --> 00:07:28.940
By competitive, I don't mean that, oh,
it's something those people

00:07:28.960 --> 00:07:29.560
up north are building.

00:07:29.560 --> 00:07:34.930
What I mean is other technologies inside
Mac OS X that do a lot of the same

00:07:35.270 --> 00:07:38.030
functions that you see in this code.

00:07:40.540 --> 00:07:42.170
There's the Sprockets stuff.

00:07:42.340 --> 00:07:45.900
Draw Sprockets has a lot of
display management goodies in it.

00:07:46.060 --> 00:07:49.770
QuickTime has a few obscure APIs in
the corners for handling displays,

00:07:49.770 --> 00:07:52.510
as does the AGL,
Apple Graphics Library package.

00:07:52.660 --> 00:07:55.360
And of course, there's our old buddy,
Display Manager.

00:07:55.380 --> 00:07:59.310
Now, these APIs are present in Mac OS X.

00:08:00.090 --> 00:08:02.340
Why are they in Mac OS X?

00:08:02.340 --> 00:08:07.740
Oh, so you could bring your apps
forward to assist you in porting.

00:08:08.920 --> 00:08:13.530
They're there so that those CFM,
PEF-based apps,

00:08:13.530 --> 00:08:15.580
that you want to run on 9 and 10 can run.

00:08:19.000 --> 00:08:24.030
You can use CG Direct Display,
these new APIs, instead.

00:08:24.320 --> 00:08:28.390
Those older functions on
Mac OS X are all built on top

00:08:28.530 --> 00:08:32.780
of the CG Direct Display APIs.

00:08:32.830 --> 00:08:35.540
So you don't really need to put
up with those things if they

00:08:35.540 --> 00:08:37.190
don't do exactly what you want.

00:08:37.440 --> 00:08:40.590
If you cut right down the
CG Direct Display APIs,

00:08:40.590 --> 00:08:42.850
you can get some finer
control over the system.

00:08:42.990 --> 00:08:46.210
You might be able to make
it do just what you want.

00:08:46.270 --> 00:08:48.650
I'll give you some
tips on how to do that.

00:08:49.830 --> 00:08:54.900
Clients of these display services: Games!

00:08:54.900 --> 00:08:55.400
We like games.

00:08:55.460 --> 00:08:58.750
Full-screen applications, like Keynote.

00:08:59.630 --> 00:09:04.500
Configuration Tools, Display Preferences,
your own apps.

00:09:08.010 --> 00:09:09.250
New functionality that we have.

00:09:09.250 --> 00:09:11.560
Mirroring.

00:09:11.600 --> 00:09:13.170
I told you about mirroring before, right?

00:09:13.180 --> 00:09:13.870
Mirroring.

00:09:14.100 --> 00:09:17.470
Software mirroring is something that
pretty much everyone is used to.

00:09:17.480 --> 00:09:20.380
We all remember writing
in those good old loops.

00:09:20.380 --> 00:09:22.660
Run through the G device list.

00:09:22.660 --> 00:09:24.560
Find those displays.

00:09:24.560 --> 00:09:26.910
Figure out which ones intersect
our window and draw on all of

00:09:26.910 --> 00:09:28.410
them over and over and over again.

00:09:28.420 --> 00:09:31.410
Well, you know,
you don't actually have to do

00:09:31.410 --> 00:09:33.470
that in a Carbon or Cocoa app.

00:09:33.520 --> 00:09:34.960
That's covered for you.

00:09:34.960 --> 00:09:37.160
The Quartz Compositor does that work.

00:09:38.970 --> 00:09:42.490
But if you are talking directly
to the displays yourselves,

00:09:42.600 --> 00:09:45.990
you still get to do that,
which might be one good reason to think

00:09:46.000 --> 00:09:51.470
about sticking with Windows systems and
not bothering to go right to the display.

00:09:51.580 --> 00:09:53.880
Something to keep in mind.

00:09:53.930 --> 00:09:57.940
If we're doing software mirroring,
software mirroring will happen

00:09:57.940 --> 00:10:01.360
on all these machines with
different graphics cards,

00:10:01.380 --> 00:10:06.830
monitor on each graphics card,
or if displays are in different depths,

00:10:07.700 --> 00:10:11.150
Software mirroring you have to go
through if you are talking right to the

00:10:11.150 --> 00:10:15.080
display and draw on each display in turn,
going down the line.

00:10:15.770 --> 00:10:19.400
Hardware mirroring is something that's
shown up just in the past few years.

00:10:19.580 --> 00:10:23.880
Hardware mirroring happens when
all those displays are running

00:10:23.880 --> 00:10:30.290
at the same depth and they're
attached to the same controller.

00:10:32.210 --> 00:10:36.460
You'll see hardware mirroring
when you connect up external

00:10:36.460 --> 00:10:42.720
monitors to the newer iBooks,
to the shiny PowerBooks,

00:10:43.600 --> 00:10:47.160
to those funny new graphics
cards that support two monitors.

00:10:47.270 --> 00:10:48.860
Hardware mirroring.

00:10:48.950 --> 00:10:53.040
One display is the active display,
the primary display.

00:10:53.360 --> 00:10:54.820
Keyword.

00:10:56.130 --> 00:10:58.140
The other displays are
mirrored in hardware.

00:10:58.420 --> 00:10:59.440
You don't need to draw on those.

00:10:59.440 --> 00:11:04.060
So you just draw on the
active or the primary display

00:11:04.160 --> 00:11:05.530
in a hardware mirrored set.

00:11:05.720 --> 00:11:09.360
We have more programming interfaces to
tell you which ones are the primary,

00:11:09.360 --> 00:11:12.800
which ones are active,
and which ones are hardware mirrors.

00:11:18.870 --> 00:11:20.440
We also had hot plugging in the system.

00:11:20.550 --> 00:11:23.330
I'm going to get into that in some
more detail in a little while.

00:11:23.680 --> 00:11:26.540
Hot plugging turns mirroring on and
off automatically in some cases.

00:11:26.540 --> 00:11:28.860
In other cases,
you get extended desktops.

00:11:28.860 --> 00:11:32.200
In either case,
if you're going to do full-screen access

00:11:32.260 --> 00:11:37.160
using what we call display capture,
you need to worry about all these things.

00:11:37.970 --> 00:11:42.160
Display capture is something really cool.

00:11:42.290 --> 00:11:46.550
It lets you steal the display
away from the Windows system.

00:11:46.750 --> 00:11:48.400
It's yours.

00:11:48.490 --> 00:11:50.790
You got it.

00:11:50.910 --> 00:11:54.280
You have lots of control that way.

00:11:54.960 --> 00:11:57.720
But, you know what?

00:11:57.720 --> 00:11:59.610
The Windows system doesn't know about it.

00:11:59.810 --> 00:12:03.260
So anything that normally goes into
a window isn't going to work there.

00:12:03.420 --> 00:12:08.820
Like views, HI views, NS views, controls,
buttons,

00:12:08.820 --> 00:12:10.440
all those fancy high-level widgets.

00:12:10.480 --> 00:12:14.560
They don't work on capture displays
because you can't put a window on that.

00:12:14.580 --> 00:12:17.230
You've just taken over that
hardware for your own purposes.

00:12:18.770 --> 00:12:20.910
Now, when you do take over
the hardware like that,

00:12:21.010 --> 00:12:23.200
though, there are advantages.

00:12:23.230 --> 00:12:25.920
OpenGL, for example,
can put that display into some

00:12:25.920 --> 00:12:30.550
very unusual modes of operation
that are extremely fast.

00:12:30.740 --> 00:12:33.160
Game developers have probably
noticed this already,

00:12:33.160 --> 00:12:33.540
huh?

00:12:33.710 --> 00:12:37.140
So you've got more control,
but less high-level functionality.

00:12:37.160 --> 00:12:39.260
In particular, because you're not going
through the Windows system,

00:12:39.260 --> 00:12:42.130
you don't have that view hierarchy
and all those other goodies there.

00:12:42.280 --> 00:12:45.530
All those accessibility APIs that
are going to be covered in

00:12:45.530 --> 00:12:48.250
another session today don't work.

00:12:48.410 --> 00:12:50.780
So that's something to bear in mind.

00:12:50.850 --> 00:12:53.720
Captured displays are
normally used by games.

00:12:53.900 --> 00:12:56.020
That's a big use of them,
particularly OpenGL games.

00:12:56.020 --> 00:12:59.420
You like to take over the display
and go as fast as you can.

00:13:01.920 --> 00:13:03.940
There's another way to
do full-screen access,

00:13:03.940 --> 00:13:07.930
and this will be familiar to lots of
folks coming from the Mac OS 9 world,

00:13:07.930 --> 00:13:10.000
Carbon developers, Hide Menu.

00:13:10.000 --> 00:13:15.110
If you call Carbon's Hide Menu function,
the menu bar disappears,

00:13:15.120 --> 00:13:18.940
the dock goes off the screen,
it looks big and empty,

00:13:18.940 --> 00:13:21.120
you then create a full-screen
window and put it up there,

00:13:21.120 --> 00:13:23.080
and you draw through a window.

00:13:23.080 --> 00:13:26.500
Now, your app is still running
in the Windows system.

00:13:26.520 --> 00:13:28.550
This is used by some
other presentation apps,

00:13:28.550 --> 00:13:30.900
such as PowerPoint,
to do its full-screen thing.

00:13:31.320 --> 00:13:33.130
It's also used by a number of games.

00:13:33.180 --> 00:13:39.290
This is the way a lot of the games that
are based on the PEF CFM technology that

00:13:39.500 --> 00:13:43.490
run on both Mac OS 9 and Mac OS X work,
because this sort of functionality

00:13:43.490 --> 00:13:44.900
is available on both.

00:13:45.310 --> 00:13:46.950
You are going through the
Windows system to do this.

00:13:46.950 --> 00:13:48.400
You're doing a full-screen window.

00:13:48.450 --> 00:13:50.240
That has advantages for
accessibility purposes.

00:13:50.240 --> 00:13:53.770
It has disadvantages in that
it might not be as fast as,

00:13:53.770 --> 00:13:57.420
for example,
running OpenGL in a full-screen mode.

00:13:58.770 --> 00:14:00.680
Display Capture.

00:14:00.740 --> 00:14:02.800
We've got functions for you.

00:14:02.920 --> 00:14:05.060
CG Capture Display.

00:14:05.180 --> 00:14:06.810
Grab one display.

00:14:06.990 --> 00:14:08.620
Take control.

00:14:08.760 --> 00:14:11.160
The display is removed
from the Windows system.

00:14:11.330 --> 00:14:13.940
The app that calls this is
forced to the foreground.

00:14:14.050 --> 00:14:16.670
You wouldn't believe how bad it is
to leave somebody taking over an

00:14:16.670 --> 00:14:20.310
entire display in the background
so the events go to some other app.

00:14:20.440 --> 00:14:22.560
It's really hard to recover
from that situation.

00:14:22.690 --> 00:14:25.100
So if you capture a display,
we're going to make sure

00:14:25.100 --> 00:14:26.100
you're the foreground app.

00:14:26.100 --> 00:14:28.130
You'll be pulled to the foreground.

00:14:28.600 --> 00:14:32.600
It's your responsibility then
to process events and respond.

00:14:35.210 --> 00:14:37.040
Once you've captured a display,
you can draw directly

00:14:37.040 --> 00:14:41.680
to that screen using GL,
Quartz, or other techniques.

00:14:41.680 --> 00:14:43.800
You can get a port to it.

00:14:44.400 --> 00:15:03.600
[Transcript missing]

00:15:04.590 --> 00:15:07.280
If you've captured the displays,
you release them to go

00:15:07.280 --> 00:15:09.370
bring up some UI elements,
you can do that,

00:15:09.420 --> 00:15:12.640
and then you capture them again,
it will apply the last captured

00:15:12.640 --> 00:15:14.770
mode to the displays again,
so you'll be right back in

00:15:14.840 --> 00:15:16.840
the last mode of operation
you were running full-screen.

00:15:24.650 --> 00:15:27.140
After you're done using a display,
you might want to release it.

00:15:27.220 --> 00:15:30.390
You can do this in the middle of
your program just so that you can

00:15:30.390 --> 00:15:33.040
go ahead and use those UI elements,
bring up some control panels

00:15:33.110 --> 00:15:35.350
for setting up game options,
that sort of thing.

00:15:35.460 --> 00:15:39.700
CG Display Release releases one display,
lets it back into the Windows system.

00:15:39.900 --> 00:15:43.190
CG Release All Displays is really handy.

00:15:43.520 --> 00:15:47.830
This releases all the displays.

00:15:47.830 --> 00:15:47.830
Okay, that was obvious.

00:15:48.120 --> 00:15:51.750
It also restores all the display
modes to the ones the user last

00:15:51.770 --> 00:15:53.710
set up in their preferences.

00:15:53.810 --> 00:15:58.560
It puts the gamma tables back the
way color sync thinks they should be.

00:15:58.560 --> 00:16:02.320
And you can use it after a display
capture or a capture all displays.

00:16:02.320 --> 00:16:05.800
One function, boom,
puts everything back the way it was.

00:16:05.800 --> 00:16:08.660
You don't have to keep notes yourself
of what the display layout used to be.

00:16:08.660 --> 00:16:09.630
You don't have to go through, "Oh,
let's see.

00:16:09.670 --> 00:16:10.660
I think this one was over here.

00:16:10.660 --> 00:16:13.550
I think this one might have been
up here." None of that stuff.

00:16:13.610 --> 00:16:16.120
Just call one function, boom.

00:16:16.120 --> 00:16:17.560
You're all set.

00:16:19.710 --> 00:16:21.600
drawing to a capture display.

00:16:21.600 --> 00:16:27.790
We have a couple of new functions,
new for Panther.

00:16:28.300 --> 00:16:30.400
CG Display Get Drawing Context.

00:16:30.420 --> 00:16:33.160
This gets you a Quartz
drawing context for a display.

00:16:33.260 --> 00:16:35.460
The context is owned by the framework.

00:16:35.500 --> 00:16:38.600
Notice it doesn't say create there,
so don't release it.

00:16:39.260 --> 00:16:40.090
OpenGL.

00:16:40.460 --> 00:16:41.770
You can use OpenGL.

00:16:42.020 --> 00:16:43.440
Pick a pixel format.

00:16:43.490 --> 00:16:48.160
Set up a full-screen GL context,
those CG GL APIs.

00:16:48.260 --> 00:16:52.200
When you're done, destroy your context,
put everything back the way it was.

00:16:52.260 --> 00:16:55.090
OpenGL is usually going to give you
the best overall graphics performance.

00:16:55.200 --> 00:16:57.200
If you've been going to any of
the GL sessions you've seen,

00:16:57.200 --> 00:17:00.120
you can use it to do 2D animations,
you can use it to blit

00:17:00.120 --> 00:17:01.780
images to the screen,
you can use it to do all sorts

00:17:01.800 --> 00:17:04.200
of interesting special effects.

00:17:04.200 --> 00:17:06.010
GL is pretty cool stuff.

00:17:06.970 --> 00:17:10.530
And even better,
you can now get a CG context

00:17:10.530 --> 00:17:13.800
from your OpenGL context to
get an accelerated context.

00:17:13.800 --> 00:17:15.450
That's been covered in
a few sessions here,

00:17:15.450 --> 00:17:15.740
too.

00:17:19.820 --> 00:17:22.560
Some people might need to change
their display configuration.

00:17:22.560 --> 00:17:26.110
If you're playing a game and, oh,
you're on one of those

00:17:26.110 --> 00:17:29.430
nice big cinema displays,
well, you probably didn't do all

00:17:29.430 --> 00:17:33.040
your artwork for that 1280x900
or whatever that thing is.

00:17:33.040 --> 00:17:36.600
You probably did a lot of artwork for,
oh, 640x480.

00:17:36.600 --> 00:17:38.270
So you've got two choices.

00:17:38.270 --> 00:17:40.780
You can do a little bitty square
in the middle of the display,

00:17:40.780 --> 00:17:43.460
or you can change the display
mode and fill the screen.

00:17:44.400 --> 00:17:46.620
The Display Configuration
API lets you do this.

00:17:46.620 --> 00:17:48.370
It's a transactional model.

00:17:48.370 --> 00:17:51.660
You tell the system,
I want to begin a display configuration.

00:17:55.400 --> 00:17:57.990
I want to accumulate a
series of operations.

00:17:58.000 --> 00:17:59.240
I want to set a display mode.

00:17:59.240 --> 00:18:00.860
I want to set a position.

00:18:00.920 --> 00:18:01.930
I want to set a refresh rate.

00:18:01.990 --> 00:18:03.780
All these goodies.

00:18:04.090 --> 00:18:06.320
And then,
once you've accumulated this new state

00:18:06.410 --> 00:18:10.040
that you want all the displays in,
you apply it with one function call,

00:18:10.120 --> 00:18:14.680
and the system will then go through
and do whatever's needed to get there.

00:18:14.940 --> 00:18:18.660
Now,
the system has constraints built into it.

00:18:18.660 --> 00:18:21.440
We don't let you put gaps
between your displays.

00:18:21.710 --> 00:18:24.200
You can lose your mouse cursor that way.

00:18:24.410 --> 00:18:27.510
We don't allow overlapping
displays that can look kind of odd,

00:18:27.550 --> 00:18:29.930
be very confusing to a user.

00:18:30.300 --> 00:18:32.560
We don't allow you to make
up your own display modes.

00:18:32.560 --> 00:18:34.600
You go, "Oh, let's see,
42's a good number.

00:18:34.600 --> 00:18:35.440
"I'll use that one.

00:18:35.440 --> 00:18:37.800
"I wonder what that does." No,
you can't do that.

00:18:37.840 --> 00:18:40.800
The system's going to
reject these sort of things.

00:18:40.810 --> 00:18:43.340
If you're on, for instance,
an iBook that's doing

00:18:43.340 --> 00:18:45.040
mirroring of displays,

00:18:45.190 --> 00:18:48.020
The hardware doesn't handle
not mirroring the displays,

00:18:48.020 --> 00:18:50.480
so if you try to do that,
the system's going to say, no, no,

00:18:50.540 --> 00:18:51.310
I don't do that.

00:18:51.360 --> 00:18:52.970
And you can't un-mirror.

00:18:52.990 --> 00:18:54.660
So.

00:18:56.480 --> 00:18:59.830
We have these constraints
that get applied.

00:18:59.940 --> 00:19:02.160
One other constraint that gets
applied is it's going to look at

00:19:02.160 --> 00:19:04.200
all the displays you're setting.

00:19:04.450 --> 00:19:08.860
The one that shows up at 00 for its
origin point becomes the main display.

00:19:08.860 --> 00:19:12.590
That's the one that gets the
menu bar and the login window.

00:19:14.710 --> 00:19:18.760
If you don't set any displays to 00,
we get to pick one.

00:19:18.830 --> 00:19:23.800
So we'll just do it ourselves.

00:19:25.930 --> 00:19:28.820
CG-begin display configuration is how
you get the whole process rolling.

00:19:28.820 --> 00:19:33.340
This is going to return to you a
CG display config ref in a pointer.

00:19:33.340 --> 00:19:36.000
This little ref thing is what
you're going to pass to all the

00:19:36.110 --> 00:19:37.900
other configuration functions.

00:19:37.900 --> 00:19:41.070
It's going to be the accumulator for
all the state you want to build up,

00:19:41.070 --> 00:19:43.900
and it's going to be what you
use to apply the state change.

00:19:43.900 --> 00:19:46.900
You're going to call CG-complete
display configuration to complete

00:19:46.900 --> 00:19:48.950
the display configuration,
or if you've done all

00:19:49.270 --> 00:19:50.870
this work and decided,
that's a hassle,

00:19:50.870 --> 00:19:53.340
I don't want to do this anymore,
you can throw it away with

00:19:53.340 --> 00:19:55.160
cancel display configuration.

00:19:59.520 --> 00:20:02.680
To set the display origin,
you use the mysteriously named

00:20:02.680 --> 00:20:05.350
function CGConfigureDisplayOrigin.

00:20:05.510 --> 00:20:10.500
This sets the origin point,
the upper left corner of that display.

00:20:10.500 --> 00:20:13.720
You can move them in X,
you can move them in Y.

00:20:13.750 --> 00:20:15.300
Not in Z.

00:20:19.200 --> 00:20:25.400
and his team are working on a new
application called Display Mode.

00:20:26.780 --> 00:20:31.700
CodeWise looks like a CFDictionaryRef.

00:20:31.700 --> 00:20:36.800
A display mode describes a
particular display resolution,

00:20:36.870 --> 00:20:43.780
a particular refresh rate,
a particular bit depth, and some options.

00:20:44.110 --> 00:20:47.440
Display modes come from a couple
of different APIs that we have.

00:20:47.670 --> 00:20:51.100
We have APIs that will let you

00:20:51.290 --> 00:20:54.000
is the Chief Executive Officer of
the CgConfigure Display Mode.

00:20:54.000 --> 00:21:01.550
He's been working on the
development of the CgConfigure

00:21:01.550 --> 00:21:05.630
Display Mode for a long time.

00:21:05.630 --> 00:21:12.980
He's been working on the
development of the CgConfigure

00:21:12.980 --> 00:21:17.310
Display Mode for a long time.

00:21:17.310 --> 00:21:17.310
He's been working on the
development of the CgConfigure

00:21:17.310 --> 00:21:17.310
Display Mode for a long time.

00:21:17.310 --> 00:21:17.310
He's been working on the
development of the CgConfigure

00:21:17.310 --> 00:21:17.310
Display Mode for a long time.

00:21:18.560 --> 00:21:22.790
You can also use our little chooser.

00:21:23.220 --> 00:21:27.480
CD Display Best Mode for
Parameters and a set of related

00:21:27.480 --> 00:21:31.530
functions with really long names,
longer than that even,

00:21:31.750 --> 00:21:33.680
can be used to pick a mode.

00:21:33.720 --> 00:21:36.860
These are sets of functions
which take a desired width,

00:21:37.000 --> 00:21:42.120
height, pixel depth, refresh rate,
and some other options

00:21:42.120 --> 00:21:43.390
that you can feed in.

00:21:44.200 --> 00:22:01.100
[Transcript missing]

00:22:01.720 --> 00:22:04.040
They also have some options
that let you specify,

00:22:04.080 --> 00:22:07.830
"I want only modes that are known
safe for this monitor and graphics

00:22:07.830 --> 00:22:11.840
card." So you don't have to bother
putting up that confirmation panel.

00:22:11.950 --> 00:22:13.950
That can be handy.

00:22:15.130 --> 00:22:18.340
There are options to pick
stretched modes to fill in gaps

00:22:18.340 --> 00:22:20.500
on the sides of your monitor.

00:22:24.880 --> 00:22:26.320
You can turn on mirroring.

00:22:26.320 --> 00:22:28.900
Now,
some interesting things that happen here.

00:22:28.900 --> 00:22:31.300
When you mirror a display
and another display,

00:22:31.300 --> 00:22:34.080
the system is going to do
some interesting things.

00:22:35.710 --> 00:22:38.220
It's going to try for hardware mirroring.

00:22:38.320 --> 00:22:41.340
So if you're not explicitly setting
the mode of some displays that

00:22:41.340 --> 00:22:43.990
you're putting into a mirror set,
the system is going to auto-configure

00:22:44.000 --> 00:22:51.570
those to match in resolution and to
match in depth so that it can use

00:22:51.570 --> 00:22:53.770
that hardware mirroring I mentioned.

00:22:54.290 --> 00:22:56.710
So if you don't explicitly
set the mode of a display,

00:22:56.710 --> 00:23:00.990
we will try to match them all up
to avoid those matting borders.

00:23:01.070 --> 00:23:03.260
What's a matting border?

00:23:03.380 --> 00:23:04.200
You might have seen these.

00:23:04.200 --> 00:23:07.700
We get these nifty widescreen gadgets.

00:23:09.100 --> 00:23:25.800
[Transcript missing]

00:23:29.290 --> 00:23:30.960
So when you go to set
up displays as a mirror,

00:23:30.960 --> 00:23:35.010
the system is going to try and change the
modes of some of the displays in the set

00:23:35.090 --> 00:23:38.040
to match the smallest display in the set,
to match the depth of

00:23:38.040 --> 00:23:40.160
the displays together,
so we can use our

00:23:40.160 --> 00:23:42.310
hardware mirroring tricks.

00:23:43.270 --> 00:23:46.530
Now, unmirroring,
some displays cannot be unmirrored.

00:23:46.680 --> 00:23:50.500
For example, the iBooks,
that secondary display

00:23:50.500 --> 00:23:53.120
port is only for mirroring,
so you really can't break them apart.

00:23:53.510 --> 00:23:57.020
The hardware doesn't handle that.

00:24:00.160 --> 00:24:05.760
One other thing, if you look in the
display mode dictionary,

00:24:05.760 --> 00:24:09.010
you might see numbers in there for
things like the display row bytes.

00:24:09.270 --> 00:24:12.320
That's sort of a value
taken in isolation.

00:24:12.630 --> 00:24:15.720
When you mirror displays together,
the robot's values for the individual

00:24:15.720 --> 00:24:19.620
modes may change because the device
driver and the hardware might

00:24:19.750 --> 00:24:22.160
require certain amounts of padding.

00:24:22.640 --> 00:24:25.180
If we do matte generation,
we may do that matte

00:24:25.200 --> 00:24:27.200
generation in hardware.

00:24:27.200 --> 00:24:29.890
So the only,
the video portion that's live

00:24:29.890 --> 00:24:32.600
is the only piece of framebuffer
memory that actually exists.

00:24:32.740 --> 00:24:35.600
Those black bands are just an
artifact of the video system.

00:24:35.600 --> 00:24:37.840
They don't actually
exist in the framebuffer.

00:24:37.840 --> 00:24:40.980
So things like row bytes may
change after display configuration

00:24:40.980 --> 00:24:42.690
where you set mirroring setup.

00:24:46.990 --> 00:24:50.890
Once you've set up your display modes,
your display positions,

00:24:50.970 --> 00:24:53.040
you've got your mirroring
set up the way you want it,

00:24:53.170 --> 00:24:57.390
you then call CGComplete
Display Configuration.

00:24:57.860 --> 00:25:00.760
That takes that ref,
pulls all the data in,

00:25:00.970 --> 00:25:03.500
grinds on it for a while,
applies some of the system constraints,

00:25:03.500 --> 00:25:04.080
and applies it.

00:25:04.080 --> 00:25:08.100
It then releases that configuration ref.

00:25:08.750 --> 00:25:09.760
There's a couple of different options.

00:25:09.760 --> 00:25:12.080
Well, there's three different options,
actually, this takes.

00:25:12.080 --> 00:25:14.020
Configure for app only.

00:25:14.020 --> 00:25:16.580
This is a really handy little mechanism.

00:25:16.580 --> 00:25:19.020
If you tell the system,
I want this configuration

00:25:19.020 --> 00:25:22.660
just to apply to my app,
what that tells the system is,

00:25:22.660 --> 00:25:24.840
this is not a permanent configuration.

00:25:24.840 --> 00:25:27.080
This program wants it.

00:25:27.230 --> 00:25:28.860
It might be a presentation app like this.

00:25:28.860 --> 00:25:29.570
It might be a game.

00:25:29.580 --> 00:25:31.210
It wants it in its
particular display mode.

00:25:31.220 --> 00:25:35.610
If something bad happens,
and that game ceases to

00:25:35.610 --> 00:25:42.850
function for some reason,
say it fails, quits, escapes, dies,

00:25:43.030 --> 00:25:44.600
blows up, poof,

00:25:44.810 --> 00:25:47.050
The system says, oh, well,
that was a mode only for that app.

00:25:47.130 --> 00:25:49.930
I better go back to
the user's preferences.

00:25:49.930 --> 00:25:52.090
And it restores everything for you.

00:25:53.750 --> 00:25:56.090
So, if you're just setting things
up for your own app's purposes,

00:25:56.230 --> 00:26:00.040
please use the Configure
for App Only option.

00:26:00.230 --> 00:26:02.970
That gives us this auto
recovery mechanism.

00:26:03.710 --> 00:26:05.500
One of the other cool things
is if you tell the system this

00:26:05.500 --> 00:26:07.880
configuration is for an app only,
if you need to get back

00:26:07.960 --> 00:26:11.580
to the user's preferences,
say, at the end of the game,

00:26:11.580 --> 00:26:17.040
you can use CG restore
permanent display configuration.

00:26:17.040 --> 00:26:20.400
And that's a long one.

00:26:21.710 --> 00:26:23.360
That'll put things
back the way they were.

00:26:23.360 --> 00:26:26.000
That restores the permanent
display configuration.

00:26:26.050 --> 00:26:28.190
Caught you by surprise, didn't it?

00:26:29.220 --> 00:26:32.560
Now, configure for session
is kind of interesting.

00:26:32.750 --> 00:26:37.000
This applies a configuration change
that lasts while that user's logged in,

00:26:37.550 --> 00:26:37.950
but

00:26:39.100 --> 00:26:55.900
[Transcript missing]

00:26:56.430 --> 00:27:00.260
and configure permanently it.

00:27:00.300 --> 00:27:01.410
Anyone?

00:27:01.450 --> 00:27:02.340
Anyone?

00:27:02.350 --> 00:27:03.180
Bueller?

00:27:03.180 --> 00:27:07.400
It configures it permanently!

00:27:08.330 --> 00:27:12.060
writes it in Display Preferences and
it comes back the next time the user

00:27:12.060 --> 00:27:14.940
logs in or the machine is rebooted.

00:27:14.970 --> 00:27:19.300
Interesting tidbit for you:
if you're an administrative user,

00:27:19.860 --> 00:27:21.980
and you do a configure permanently.

00:27:22.120 --> 00:27:26.510
That also becomes the boot
configuration for the machine.

00:27:31.610 --> 00:27:34.620
The configuration is adjusted by
the system after you feed it in.

00:27:34.620 --> 00:27:41.410
So, you should,
after setting the configuration,

00:27:49.370 --> 00:27:50.260
I really do.

00:27:50.260 --> 00:27:52.260
Did you get what you expected?

00:27:52.260 --> 00:27:55.610
Did it do some tweaks on
you that you didn't realize?

00:27:55.610 --> 00:27:59.260
We actually have functions in
the system that you can use to

00:27:59.260 --> 00:28:01.280
read back the configuration.

00:28:01.280 --> 00:28:04.390
You can read back the
origin point for a display.

00:28:04.390 --> 00:28:06.910
You can read back its width and height.

00:28:06.910 --> 00:28:10.190
You can read back all sorts
of interesting things.

00:28:10.190 --> 00:28:10.220
You can get the current display
mode out of the system and see,

00:28:10.220 --> 00:28:10.220
"Oh, is this the mode I access for?

00:28:10.220 --> 00:28:10.220
That's pretty close."

00:28:10.890 --> 00:28:13.480
In addition, we also have some other
APIs you might find handy.

00:28:13.480 --> 00:28:17.830
You can ask for Displays Vendor

00:28:18.300 --> 00:28:33.100
[Transcript missing]

00:28:34.930 --> 00:28:36.850
You can ask for the display resolution.

00:28:37.000 --> 00:28:38.100
That's the width and height.

00:28:38.240 --> 00:28:40.160
You can get the origin point.

00:28:40.160 --> 00:28:44.070
One interesting thing is,
CG display uses OpenGL acceleration.

00:28:44.140 --> 00:28:49.580
That's our little way of saying,
you got Quartz Extreme.

00:28:51.100 --> 00:28:52.700
CG Display I/O Service Port.

00:28:52.700 --> 00:28:54.500
Yeah, what is that?

00:28:54.500 --> 00:28:56.300
That's an I/O Service Port.

00:28:56.310 --> 00:28:57.600
Yeah, right.

00:28:57.630 --> 00:29:00.280
An I/O Service Port is a
little representation that

00:29:00.280 --> 00:29:01.670
you can pass into I/O Kit.

00:29:01.680 --> 00:29:06.070
I/O Kit can then look at that and say,
"Oh yeah,

00:29:06.460 --> 00:29:09.130
This display, and you can read back
all sorts of interesting,

00:29:09.130 --> 00:29:12.580
really low-level things from I/O Kit,
things like EDIT data.

00:29:12.840 --> 00:29:15.780
And everyone's eye just glazed over.

00:29:15.920 --> 00:29:17.470
Next slide.

00:29:18.510 --> 00:29:22.020
We have display change
notifications you can subscribe to.

00:29:22.200 --> 00:29:24.920
Now, quick draw.

00:29:25.040 --> 00:29:26.810
pays attention to these.

00:29:26.970 --> 00:29:28.720
It does its own thing and reconfigures.

00:29:28.750 --> 00:29:30.820
Quikter also has the
implementation for Display Manager,

00:29:30.820 --> 00:29:31.610
by the way.

00:29:31.660 --> 00:29:33.440
Many of you might be calling
Display Manager to get display

00:29:33.520 --> 00:29:35.160
configuration state changes.

00:29:35.180 --> 00:29:36.630
That works.

00:29:36.660 --> 00:29:38.560
Guess what it's built on?

00:29:42.500 --> 00:29:44.740
It's Friday morning, isn't it?

00:29:44.740 --> 00:29:47.020
It's built on this stuff.

00:29:47.020 --> 00:29:51.390
CG Display Register Reconfiguration
Callback.

00:29:53.390 --> 00:29:58.000
That you can pass a function into,
it registers it, and it calls you back

00:29:58.130 --> 00:29:59.160
when something happens.

00:29:59.160 --> 00:30:02.880
In fact, it calls you back when
something's about to happen.

00:30:02.880 --> 00:30:04.500
Is that cool or what?

00:30:06.290 --> 00:30:10.520
We know in advance,
something's going to happen.

00:30:10.540 --> 00:30:12.680
The callback is invoked for each display.

00:30:12.680 --> 00:30:16.150
We'll call it back with this display,
with that display,

00:30:16.260 --> 00:30:20.180
with the other display, one at a time,
with a flag telling you,

00:30:20.180 --> 00:30:22.830
"Something's about to happen."

00:30:23.980 --> 00:30:27.760
And then, after something happens,
displays are reconfigured,

00:30:27.820 --> 00:30:30.220
it gets called again for each display.

00:30:30.270 --> 00:30:32.460
This display, its origin changed.

00:30:32.460 --> 00:30:34.460
This display, its mode changed.

00:30:34.460 --> 00:30:36.930
This display,
it's a mirror of this display.

00:30:37.040 --> 00:30:40.170
And this display was
removed from the system.

00:30:40.390 --> 00:30:40.530
What?

00:30:40.880 --> 00:30:45.970
We support hot plugging of displays now.

00:30:47.890 --> 00:30:51.540
Yeah, you got that ADC or DVI connector
on the back of a PowerBook?

00:30:51.590 --> 00:30:53.550
You plug a display in that?

00:30:53.670 --> 00:30:54.600
You don't have to close the lid.

00:30:54.600 --> 00:30:55.850
You don't have to put
that thing to sleep first.

00:30:55.870 --> 00:30:59.240
We noticed that, oh, look,
something changed in the hardware.

00:30:59.620 --> 00:31:01.190
Quick, reorganize the system.

00:31:03.100 --> 00:31:06.400
We reorganize the system,
we bring up the new display states,

00:31:06.560 --> 00:31:07.900
and you're good.

00:31:07.900 --> 00:31:11.450
And this you have to be prepared for.

00:31:11.560 --> 00:31:14.160
Those darn users can just take
that connector and pull it right

00:31:14.170 --> 00:31:15.850
out while your machine's running.

00:31:15.850 --> 00:31:19.690
Displays can vanish on you.

00:31:19.690 --> 00:31:23.490
Boy, if that doesn't mess up a game.

00:31:26.750 --> 00:31:30.240
So you have to be aware that these
state changes can happen at any time.

00:31:30.240 --> 00:31:33.610
It can be really shocking for you.

00:31:34.830 --> 00:31:37.320
We do have some cool tricks, by the way.

00:31:37.360 --> 00:31:42.470
If you've captured displays,
if you captured the display,

00:31:43.650 --> 00:31:48.070
Hot plugging and unplugging isn't
going to perturb your system that much.

00:31:48.190 --> 00:31:51.260
You capture the display you're running
on the built-in display in a PowerBook.

00:31:51.340 --> 00:31:54.410
Somebody plugs in another display,
disconnects it.

00:31:54.780 --> 00:31:56.380
will note that, oh look,
something's connected.

00:31:56.380 --> 00:31:57.400
We have to change state.

00:31:57.430 --> 00:32:00.700
After he's done,
after he's let that display go,

00:32:00.700 --> 00:32:01.660
we'll change state.

00:32:01.780 --> 00:32:02.950
So we hold off for a little while.

00:32:02.950 --> 00:32:06.620
That keeps your game code
from exploding on you.

00:32:06.820 --> 00:32:08.580
It's a good thing.

00:32:12.090 --> 00:32:16.230
Now, when somebody actually hot plugs
that monitor into a system,

00:32:16.350 --> 00:32:19.200
fun stuff happens.

00:32:19.220 --> 00:32:20.980
I/O Kit gets pinged by
the hardware saying,

00:32:21.100 --> 00:32:23.070
"Hey, look, something changed."

00:32:24.630 --> 00:32:28.340
The device drivers go rattling along,
"Oh, this one!

00:32:28.360 --> 00:32:29.730
Hey, look, there's a monitor on it now.

00:32:29.730 --> 00:32:31.510
I had one before."

00:32:31.730 --> 00:32:33.880
and the hardware and the
software will work together to

00:32:34.020 --> 00:32:35.880
pull the monitor and find out,
oh, what kind of monitor are you?

00:32:35.880 --> 00:32:37.380
Okay, we're one of these, huh?

00:32:37.380 --> 00:32:40.180
And you run in watch display modes?

00:32:40.180 --> 00:32:42.440
Okay, I'll just pick one.

00:32:44.570 --> 00:32:47.700
And it fires up the monitor and
puts it into some mode of operation.

00:32:47.730 --> 00:32:52.750
Usually a mode of operation that's marked
as a default state for that monitor.

00:32:54.740 --> 00:32:56.870
At this point,
we send notifications out to

00:32:56.870 --> 00:33:00.540
all the applications saying,
"Oh, look, something changed.

00:33:00.630 --> 00:33:02.890
"You've got a new monitor."

00:33:03.390 --> 00:33:05.800
and your application can do something
with that or just ignore it.

00:33:05.970 --> 00:33:07.380
Most apps will just ignore it.

00:33:07.440 --> 00:33:08.420
It's not a big deal.

00:33:08.420 --> 00:33:10.500
If you're a Carbon or Cocoa app,
you don't care.

00:33:10.500 --> 00:33:11.560
It's no big deal.

00:33:13.290 --> 00:33:15.380
If you're some kind of
full-screen presentation app,

00:33:15.380 --> 00:33:16.900
you might be interested in this.

00:33:16.900 --> 00:33:19.980
You might be able to do something
special with that extra display.

00:33:20.170 --> 00:33:22.470
Ah, the one that's going to get you,
though, is when they unplug the display.

00:33:22.480 --> 00:33:25.160
What if you were doing something on that,
too?

00:33:25.160 --> 00:33:27.680
What if you thought you had it captured,
but you didn't?

00:33:28.860 --> 00:33:35.000
If you actually capture the
display and it gets unplugged,

00:33:36.030 --> 00:33:37.050
Well, that's not so good.

00:33:37.080 --> 00:33:40.670
If you're capturing displays,
you might want to think about

00:33:40.670 --> 00:33:44.080
keeping your UI on a display that's
marked as the built-in display.

00:33:44.080 --> 00:33:48.290
And yeah, there's API that tells you,
CG is display built-in.

00:33:48.290 --> 00:33:49.170
True.

00:33:49.170 --> 00:33:50.060
Okay.

00:33:50.060 --> 00:33:51.920
So you can check for that.

00:33:57.240 --> 00:34:07.100
The old way of fading a display
was grab the gamma table,

00:34:07.100 --> 00:34:10.780
stuff some values in, okay,
that's pretty good, take those values up,

00:34:10.790 --> 00:34:14.190
put some slightly smaller values in,
okay, keep doing that over

00:34:14.250 --> 00:34:16.530
and over and over again,
hundreds and hundreds of times,

00:34:16.600 --> 00:34:21.960
burning up CPU cycles until you
finally fade the screen out to black

00:34:21.960 --> 00:34:21.960
or whatever you were going to fade to.

00:34:24.110 --> 00:34:26.400
Well, that has a couple of bad effects.

00:34:26.480 --> 00:34:29.600
First, you burn a lot of CPU cycles.

00:34:29.680 --> 00:34:32.670
And let's face it,
monitors have refresh periods.

00:34:32.890 --> 00:34:35.900
They aren't going to see that
change but 70 or 80 times a second.

00:34:35.940 --> 00:34:37.100
You can do it thousands
of times a second.

00:34:37.100 --> 00:34:38.600
It doesn't help.

00:34:38.620 --> 00:34:40.700
It's CPU intensive.

00:34:41.430 --> 00:34:43.050
You lose your color sync data.

00:34:43.190 --> 00:34:44.500
Yeah,
those color sync guys went to a lot of

00:34:44.500 --> 00:34:46.810
trouble to calibrate those displays,
and now look what you've done.

00:34:46.820 --> 00:34:53.060
So, we have a new API, new for Panther!

00:34:53.060 --> 00:34:57.380
Boy, I can't wake him up at all.

00:34:59.780 --> 00:35:02.950
The Display Fade APIs lets
you tell the system,

00:35:02.950 --> 00:35:05.380
"I want to do a fade operation now.

00:35:05.580 --> 00:35:11.420
Please reserve the hardware and do a nice
smooth transition." It's driven off the

00:35:11.750 --> 00:35:14.610
hardware and off of some fancy timers.

00:35:14.680 --> 00:35:17.100
It does a really nice job of
fading displays in and out for you

00:35:17.100 --> 00:35:18.940
to handle all those transitions.

00:35:19.000 --> 00:35:22.680
You can use this instead of doing
the Gamma Table tricks on your own.

00:35:22.760 --> 00:35:24.720
Very easy to use.

00:35:26.150 --> 00:35:27.240
Built-in.

00:35:27.240 --> 00:35:30.330
Now, we already have a fade effect
built-in for display mode changes.

00:35:52.780 --> 00:35:52.800
Yeah, we do.

00:35:52.800 --> 00:35:52.800
Yeah.

00:35:52.800 --> 00:35:52.800
Haven't you seen that fade
to blue thing that happens?

00:35:52.800 --> 00:35:52.800
That's the fade transition.

00:35:52.800 --> 00:35:52.800
0.3 seconds fade out, 0.5 fade in.

00:35:52.800 --> 00:35:52.800
You can override it when you're
doing a configuration for that

00:35:52.800 --> 00:35:52.800
configuration operation only by
calling CGConfigureDisplayFadeEffect.

00:35:53.700 --> 00:35:56.600
This wonderful function takes
the config ref that you're using,

00:35:56.660 --> 00:35:59.240
the time to fade out,
the time to fade back in,

00:35:59.320 --> 00:36:01.440
and the color to use
for the fade transition.

00:36:01.560 --> 00:36:04.720
The default that's built into the
system will fade to that lovely shade of

00:36:04.720 --> 00:36:07.800
French blue when you do a display change.

00:36:08.100 --> 00:36:21.500
[Transcript missing]

00:36:25.100 --> 00:36:27.380
Now, there's other places where
people like to do phase.

00:36:27.380 --> 00:36:30.110
If you're in a game,
you've been running some sort

00:36:30.110 --> 00:36:33.580
of cinematic piece and you want
to do a transition over to,

00:36:33.580 --> 00:36:36.070
say, your GL-based animations.

00:36:36.330 --> 00:36:39.600
Often people will do a fade out,
perhaps a hardware mode change,

00:36:39.600 --> 00:36:41.630
bring up their full-screen context,
and do a fade in.

00:36:41.640 --> 00:36:43.670
We can automate all this for you.

00:36:43.680 --> 00:36:47.320
You can acquire the hardware
to do the fade operation by

00:36:47.360 --> 00:36:49.120
calling acquire fade reservation.

00:36:50.770 --> 00:36:53.760
When you're done, you can release the
display fade reservation.

00:36:53.770 --> 00:36:56.260
The reservation is good
for up to 15 seconds.

00:36:56.260 --> 00:36:59.440
If it takes longer than 15
seconds to your fade transition,

00:36:59.440 --> 00:37:03.180
I'd think about that.

00:37:03.200 --> 00:37:04.080
That's a long time.

00:37:04.080 --> 00:37:06.240
Users get impatient.

00:37:09.450 --> 00:37:13.300
Now, you can do the fade
synchronously or asynchronously.

00:37:13.340 --> 00:37:15.840
You can tell the system,
"I want to do a fade.

00:37:15.890 --> 00:37:18.510
I want to start with a normal display.

00:37:18.850 --> 00:37:23.450
I want to end up with a solid color,
and I want the color to have

00:37:23.450 --> 00:37:27.300
this RGB value." This is just
in the display color space.

00:37:27.490 --> 00:37:30.800
0, 0, 0 would happen to be black.

00:37:31.380 --> 00:37:32.300
and True.

00:37:32.300 --> 00:37:34.800
Yes, I want this to be a
synchronous operation.

00:37:34.960 --> 00:37:38.280
You'll call this, and two seconds later,
this call will return,

00:37:38.280 --> 00:37:40.700
and the display will
then fade into black.

00:37:40.930 --> 00:37:41.560
Very straightforward.

00:37:41.560 --> 00:37:43.880
You can then do some setup operations.

00:37:43.880 --> 00:37:46.960
For instance, stop your cinematic,
start your GL sequence running.

00:37:46.960 --> 00:37:50.940
You might want to fade back in
while you're already rendering.

00:37:50.940 --> 00:37:53.880
In that case,
you want to start the fade in and then

00:37:53.880 --> 00:37:56.180
go right to doing your animations.

00:37:56.180 --> 00:37:59.160
Let the fade proceed on its own,
not worry about it.

00:37:59.980 --> 00:38:03.280
To do that, you'd start off with,
for instance, we're starting from a

00:38:03.280 --> 00:38:04.550
solid color in this case.

00:38:04.550 --> 00:38:06.910
We want to end up with the
display looking normal.

00:38:06.910 --> 00:38:10.200
The starting color was black,
so we're doing a fade in from black.

00:38:10.200 --> 00:38:12.300
False, meaning asynchronous.

00:38:12.370 --> 00:38:15.720
In this case,
CG display fade returns immediately.

00:38:17.180 --> 00:38:20.240
The fade occurs over
the next two seconds,

00:38:20.510 --> 00:38:22.660
which is what we specified.

00:38:22.770 --> 00:38:24.700
While you get your
GL animations up and running,

00:38:24.750 --> 00:38:26.520
so you do a nice fade in,
your game figures are

00:38:26.800 --> 00:38:29.020
already running around,
busily stabbing each other.

00:38:29.100 --> 00:38:31.590
Just having a grand old time.

00:38:33.200 --> 00:38:34.890
This can actually look pretty slick.

00:38:34.890 --> 00:38:39.560
And this is easier than trying to do a
lot of the async callback stuff yourself.

00:38:41.350 --> 00:38:44.420
All the actual callback and work
to drive this is handled outside

00:38:44.450 --> 00:38:48.230
of your process in the fade
machinery we've added to the system.

00:38:49.740 --> 00:38:51.940
Palette of Displays, whoa.

00:38:51.940 --> 00:38:54.510
Here we go.

00:38:54.520 --> 00:39:00.380
Who here uses Palette of Displays
in their new app they're coding up?

00:39:01.240 --> 00:39:03.200
Good.

00:39:03.370 --> 00:39:05.070
So I got some news for you.

00:39:05.200 --> 00:39:07.260
This stuff's in the
system for legacy support.

00:39:09.440 --> 00:39:12.730
There's minimal to no hardware
acceleration available when

00:39:12.730 --> 00:39:13.860
you're using 8-bit palettes.

00:39:13.860 --> 00:39:18.340
All that fancy hardware
just loves 32-bit mode.

00:39:18.340 --> 00:39:19.780
It goes fast then.

00:39:19.780 --> 00:39:22.190
You go down to 8-bit mode and it's,
"What?

00:39:22.190 --> 00:39:27.540
I've got these huge honking buses and
you want me to move 8 bits at a time?"

00:39:30.420 --> 00:39:31.900
It's got a low precision.

00:39:31.900 --> 00:39:34.290
It doesn't composite very well at all.

00:39:34.360 --> 00:39:37.210
It's barely supported by the hardware.

00:39:37.280 --> 00:39:39.200
Come on, guys!

00:39:39.240 --> 00:39:40.100
We're past the 70s.

00:39:40.100 --> 00:39:41.220
We're past the 80s even.

00:39:41.220 --> 00:39:43.210
We can get better.

00:39:44.130 --> 00:39:47.820
The configuration functions will
let you select an 8-bit mode.

00:39:47.820 --> 00:39:51.180
They won't let you make
it a permanent setting.

00:39:51.200 --> 00:39:53.370
There is a reason for that.

00:39:58.280 --> 00:39:59.190
"Anyone?

00:39:59.290 --> 00:39:59.720
No?

00:40:00.750 --> 00:40:04.320
All right.

00:40:04.320 --> 00:40:06.460
We do have palette functions
for you to play with.

00:40:06.590 --> 00:40:10.030
This is for legacy support, by the way.

00:40:10.030 --> 00:40:10.030
I don't know if I mentioned that."

00:40:11.020 --> 00:40:12.660
You can create a palette.

00:40:12.770 --> 00:40:14.850
You can create a palette
from the display's contents.

00:40:14.980 --> 00:40:18.420
You can create a palette with
an array of samples you provide.

00:40:18.540 --> 00:40:20.120
You can get the color at an index.

00:40:20.300 --> 00:40:22.410
You can set the color at an index.

00:40:22.550 --> 00:40:24.380
You can tell a display,
"Here's your palette."

00:40:24.380 --> 00:40:27.540
And you can release a palette.

00:40:27.540 --> 00:40:28.120
Any questions?

00:40:28.120 --> 00:40:28.500
No good.

00:40:28.500 --> 00:40:34.250
Common developer issues.

00:40:37.900 --> 00:40:41.900
What sort of issues could developers
possibly have with this stuff?

00:40:41.990 --> 00:40:46.900
Well, there's recognizing those mirroring
and display configuration changes.

00:40:46.900 --> 00:40:50.050
If you're playing with
the display directly,

00:40:50.600 --> 00:40:53.360
You need to be aware of mirroring.

00:40:53.360 --> 00:40:55.500
That old device loop
comes back to haunt you.

00:40:55.500 --> 00:40:58.250
You're going to need to look at all the
displays in the mirroring set and make

00:40:58.280 --> 00:41:00.900
sure you draw on all of them in turn.

00:41:01.510 --> 00:41:09.590
is the Director of the Center for
Data and Information Technology at

00:41:09.590 --> 00:41:09.590
the University of

00:41:09.960 --> 00:41:12.020
Most of the newer hardware will
be doing hardware mirroring.

00:41:12.150 --> 00:41:14.720
That's what you're going to get
in all the nice shiny PowerBooks,

00:41:14.720 --> 00:41:18.600
in the newer iBooks, the white iBooks.

00:41:19.550 --> 00:41:21.730
That's what you're going to get
with those funny cards that have two

00:41:21.730 --> 00:41:23.500
monitor connectors on a single card.

00:41:23.560 --> 00:41:25.960
Those will normally do hard remembering
unless you work really hard to make

00:41:25.980 --> 00:41:30.430
it not do it by setting the displays
to different depths explicitly.

00:41:30.500 --> 00:41:32.300
Don't do that.

00:41:32.350 --> 00:41:34.790
Unless you really like to work at things.

00:41:35.800 --> 00:41:40.470
If you're capturing displays,
you must be aware of the mirroring

00:41:40.470 --> 00:41:44.210
state to get the correct behavior.

00:41:46.430 --> 00:41:50.640
Capturing displays and changing
the display configuration.

00:41:50.640 --> 00:41:54.060
Some people have been capturing the
displays just so they could change

00:41:54.060 --> 00:41:55.590
the modes and then releasing them.

00:41:55.590 --> 00:41:57.360
That looks funny.

00:41:57.360 --> 00:42:00.610
The entire screen goes black
for a couple of seconds.

00:42:00.610 --> 00:42:03.730
Your app comes to the foreground
even though you thought you were

00:42:03.730 --> 00:42:06.860
doing this from some faceless
UI element in the background.

00:42:06.860 --> 00:42:07.660
Looks bad.

00:42:07.880 --> 00:42:08.670
Don't do that.

00:42:08.670 --> 00:42:09.280
Please.

00:42:09.770 --> 00:42:10.040
Please.

00:42:10.040 --> 00:42:16.410
There is no need to capture the
display in order to reconfigure them.

00:42:19.120 --> 00:42:23.310
Use CG Capture All Displays to
avoid funny desktop layout effects.

00:42:23.630 --> 00:42:27.190
If you capture all the displays,
there's no desktop showing.

00:42:27.290 --> 00:42:30.060
And we won't bother telling
things on the desktop that,

00:42:30.060 --> 00:42:32.150
"Oh, yeah, the display's changed size.

00:42:32.330 --> 00:42:35.190
Quick,
cram all your icons into one corner."

00:42:35.850 --> 00:42:37.500
We can stop that behavior.

00:42:37.590 --> 00:42:38.460
We can do it, people.

00:42:38.460 --> 00:42:39.500
We can work together.

00:42:39.500 --> 00:42:40.980
Capture all the displays.

00:42:40.980 --> 00:42:41.940
Please.

00:42:43.850 --> 00:42:46.140
That hides display mode changes
from the rest of the system.

00:42:46.140 --> 00:42:49.710
Only your app needs to worry
about them in that case.

00:42:52.540 --> 00:42:54.040
Display Changing.

00:42:54.060 --> 00:42:59.280
Let's take a look over on Demo Machine 1
and see what this is all about.

00:43:01.560 --> 00:43:07.190
I mentioned we had some APIs that let
us actually look at the display state.

00:43:09.400 --> 00:43:31.800
[Transcript missing]

00:43:32.390 --> 00:43:35.240
New for Panther!

00:43:35.280 --> 00:43:37.810
We have a new function that
returns you the display width

00:43:37.890 --> 00:43:39.670
and height in millimeters.

00:43:39.790 --> 00:43:42.250
No, this is not actually 310 millimeters.

00:43:42.340 --> 00:43:44.200
This one here is.

00:43:46.220 --> 00:43:49.040
This number here is the display
ID for this particular display.

00:43:49.170 --> 00:43:51.180
I mentioned you can get information
about particular models.

00:43:51.180 --> 00:43:53.440
This is vendor ID 610.

00:43:53.600 --> 00:43:54.540
I wonder who that could be.

00:43:54.540 --> 00:43:59.020
And product ID 9215.

00:44:03.200 --> 00:44:15.100
[Transcript missing]

00:44:19.500 --> 00:44:21.800
- Fuck yeah, there is a mode for 640,
480.

00:44:21.820 --> 00:44:26.140
How about if I go for, say, a... Oh,
that's close.

00:44:26.160 --> 00:44:30.890
800 by 600 is the nearest mode
that would enclose that size.

00:44:36.740 --> 00:44:39.760
1024 by 768 is the nearest mode
that would enclose this size.

00:44:39.760 --> 00:44:44.080
Oh, look, we can get to 8-bit.

00:44:44.110 --> 00:44:46.680
Let's see what happens if we apply it.

00:44:49.200 --> 00:45:00.700
[Transcript missing]

00:45:01.900 --> 00:45:06.660
Now, some displays have stretched
modes they can support.

00:45:06.740 --> 00:45:11.520
Suppose I ask for 800 by 600 on this one.

00:45:12.850 --> 00:45:19.770
Yep, this display's nearest
stretched mode is 10/24/7/68,

00:45:19.770 --> 00:45:19.770
so it would take that and
try to stretch things.

00:45:20.080 --> 00:45:29.850
Safe Modes.

00:45:29.850 --> 00:45:29.850
Ah, we have a safe mode.

00:45:29.850 --> 00:45:29.850
This is all the modes that are known
to function for this hardware and

00:45:29.850 --> 00:45:29.850
the graphics card that's in here.

00:45:30.820 --> 00:45:33.670
is the director of the Office of
Software Engineering at

00:45:33.670 --> 00:45:35.320
the University of Michigan.

00:45:39.690 --> 00:45:45.320
To get the information about a display,
we needed to get a display ID.

00:45:45.450 --> 00:45:48.560
Let's get the main
display ID in this case.

00:45:48.610 --> 00:45:49.430
We can feed in things.

00:45:49.470 --> 00:45:52.780
This returns us the physical bounds
in millimeters for the display.

00:45:52.890 --> 00:45:55.470
This returns us the pixel bounds.

00:45:57.730 --> 00:46:00.220
For that display,
we can ask for the current mode.

00:46:00.240 --> 00:46:04.890
That returns us that CFDictionaryRef,
and we can pull information out of that.

00:46:06.600 --> 00:46:14.660
Anything in a CFDictionaryRef is
accessed by key.

00:46:14.970 --> 00:46:15.870
In this case, the values that you'll get
back will all be CFNumberRef.

00:46:16.160 --> 00:46:21.920
and you can use that to fetch out the
value as an integer or as a double,

00:46:21.920 --> 00:46:21.920
whatever's most convenient for you.

00:46:22.130 --> 00:46:26.200
The CFNumberRef will do the right
things as far as converting those.

00:46:26.200 --> 00:46:29.680
Other APIs to let you get the vendor ID,
the model number,

00:46:29.680 --> 00:46:31.620
very straightforward stuff.

00:46:32.040 --> 00:46:34.990
Searching for a display mode,
this is a rough one.

00:46:36.600 --> 00:46:45.200
[Transcript missing]

00:46:45.330 --> 00:46:52.440
It takes a display ID, a desired width,
a desired height, depth,

00:46:52.460 --> 00:46:54.670
a desired refresh rate,

00:46:54.980 --> 00:46:57.180
An optional property value,
you can just feed in null

00:46:57.180 --> 00:46:59.310
for the property by default,
or if you're looking

00:46:59.310 --> 00:47:01.640
for only safe displays,
so you don't have to put up any

00:47:01.680 --> 00:47:03.620
kind of confirmation dialogue,
you can feed in,

00:47:03.620 --> 00:47:05.300
KCG Display Mode is safe for hardware.

00:47:05.300 --> 00:47:07.700
And it returns you a mode.

00:47:07.700 --> 00:47:10.890
The function will always return a mode.

00:47:11.340 --> 00:47:14.430
If it can't figure out what
on earth you're asking for,

00:47:14.430 --> 00:47:15.990
it'll hand back the current
display mode and say,

00:47:16.070 --> 00:47:17.060
"I don't know.

00:47:17.180 --> 00:47:18.340
Use this.

00:47:18.370 --> 00:47:20.250
It works right now."

00:47:22.940 --> 00:47:24.900
tries for a depth-first match on those.

00:47:24.900 --> 00:47:30.840
Now, when we change the configuration,
I told you this is rough stuff.

00:47:30.860 --> 00:47:33.490
We found a mode with
that best mode for stuff.

00:47:33.520 --> 00:47:36.940
Begin configuration,
we get back our configuration handle,

00:47:36.980 --> 00:47:40.960
configure the display mode for
the main display to that mode.

00:47:40.990 --> 00:47:44.410
These modes are only valid for the
display you queried them on and

00:47:44.410 --> 00:47:47.470
you don't get to make up your own.

00:47:47.780 --> 00:47:50.580
The mode will only work if it's
returned by one of the APIs that

00:47:50.610 --> 00:47:53.390
vends modes or lists of modes.

00:47:54.480 --> 00:47:57.000
And once we've got things set up,
all we're doing is changing the mode.

00:47:57.000 --> 00:47:59.390
In this case, we call
CG Complete Display Configuration.

00:47:59.390 --> 00:48:01.930
Configure for app only,
so if something bad happens

00:48:01.930 --> 00:48:03.740
and the app crashes,
we get back.

00:48:10.400 --> 00:48:12.100
Capturing all the displays.

00:48:12.390 --> 00:48:14.500
We have a new for Panther item.

00:48:14.710 --> 00:48:18.240
You can specify an option,
capture with no fill.

00:48:18.280 --> 00:48:22.710
That actually captures the display but
leaves the contents as you see them.

00:48:23.320 --> 00:48:24.890
You can do your fade transition.

00:48:24.900 --> 00:48:26.690
It looks like you're fading
out from the desktop,

00:48:26.690 --> 00:48:29.180
really slick, and go into your app.

00:48:33.000 --> 00:48:36.880
I'm going to show you an
example of capturing a display,

00:48:36.910 --> 00:48:40.800
doing a fade-out, we're going to draw a
color bar's pattern,

00:48:40.840 --> 00:48:44.200
and then we'll do that
asynchronous fade-back in.

00:48:44.240 --> 00:48:45.200
One of the interesting things,
by the way,

00:48:45.200 --> 00:48:49.020
is you can start a fade-back in and
release your reservation token if the

00:48:49.140 --> 00:48:52.580
fade-back in ends with a normal display.

00:48:53.460 --> 00:48:57.600
If it ends with a normal display state,
then releasing that token will have

00:48:57.600 --> 00:49:00.320
no effect on the display's appearance.

00:49:00.350 --> 00:49:03.250
The system will automatically say, "Okay,
this is a deferred release.

00:49:03.340 --> 00:49:09.160
I'll release it once this fade-in
is done." And once we're done,

00:49:09.160 --> 00:49:13.110
we're going to use Release All Displays
to release the displays.

00:49:18.140 --> 00:49:19.100
Let's capture the display.

00:49:19.100 --> 00:49:21.440
You'll see we're going to capture it,
but not actually fill it.

00:49:21.480 --> 00:49:23.470
And we'll do a fade out.

00:49:24.760 --> 00:49:26.840
Fade back in with our color bar pattern.

00:49:26.840 --> 00:49:28.860
It's all captured.

00:49:28.860 --> 00:49:29.640
It's ours now.

00:49:29.680 --> 00:49:30.970
We can do with it as we wish.

00:49:30.980 --> 00:49:32.920
Now let's click.

00:49:32.930 --> 00:49:34.100
We restored everything.

00:49:34.120 --> 00:49:35.570
That easy.

00:49:36.880 --> 00:49:38.540
didn't have to record all
the display locations,

00:49:38.540 --> 00:49:40.460
didn't have to try and put
them all back ourselves.

00:49:40.460 --> 00:49:41.440
Very straightforward.

00:49:41.440 --> 00:49:44.280
This sample code will be
appearing on our website soon,

00:49:44.280 --> 00:49:46.240
here in the next few weeks.

00:49:57.000 --> 00:50:00.510
Welcome to something
completely different,

00:50:00.510 --> 00:50:02.240
Remote Operations.

00:50:02.240 --> 00:50:04.830
Remote Operations is all the
stuff you need to do remote

00:50:04.830 --> 00:50:06.270
control over the machine.

00:50:07.920 --> 00:50:11.120
Display Drawing Activity Monitor and
Generation and Hosting of Events.

00:50:11.170 --> 00:50:13.630
What could that mean?

00:50:13.790 --> 00:50:17.240
Display Drawing Activity Monitor lets you
listen for state changes on the display.

00:50:17.300 --> 00:50:18.600
Oh, look,
a window just flushed over here.

00:50:18.600 --> 00:50:20.440
Oh, look, Quick Draw Movie's playing
over in that corner.

00:50:20.440 --> 00:50:21.240
Stuff's happening.

00:50:21.310 --> 00:50:23.560
It tells you the areas that
have changed on the display.

00:50:23.660 --> 00:50:26.440
We'll also let you post events into
the system for remote control purposes

00:50:26.440 --> 00:50:28.760
or for user space device drivers.

00:50:28.900 --> 00:50:31.540
Now, how's all this going to work?

00:50:31.780 --> 00:50:33.380
Why do you have to scrape
the bits off the screen?

00:50:33.380 --> 00:50:35.060
Why can't I go get them somewhere else?

00:50:35.280 --> 00:50:36.920
Well,
all the apps in the system are drawing

00:50:36.920 --> 00:50:39.500
into their own private buffers.

00:50:40.170 --> 00:50:41.360
You don't get to play with those.

00:50:41.400 --> 00:50:43.940
They're the app's buffers,
not your buffers.

00:50:43.940 --> 00:50:45.870
The buffers all go into
the Quartz compositor,

00:50:45.890 --> 00:50:48.780
which takes all the bits,
blends them together,

00:50:48.830 --> 00:50:51.350
seasons them lightly,
and sends them to the

00:50:51.350 --> 00:50:52.980
framebuffer for display.

00:50:53.030 --> 00:50:54.720
Some bits can be transparent.

00:50:54.760 --> 00:50:57.160
Some of the bits in the framebuffer
may be the result of several

00:50:57.160 --> 00:50:59.490
windows accumulated together.

00:50:59.640 --> 00:51:02.400
The only place where you can get a
consistent picture of what all the

00:51:02.490 --> 00:51:05.120
pieces look like is at the framebuffer.

00:51:07.200 --> 00:51:11.230
There's a lot of processing that
can happen between here and there.

00:51:11.300 --> 00:51:13.140
If you've looked at some of
the accessibility interfaces,

00:51:13.170 --> 00:51:16.760
we have things like
Display Zoom that can actually occur.

00:51:17.260 --> 00:51:19.950
So what you see on the display
doesn't actually correlate very

00:51:20.020 --> 00:51:24.780
closely with what you started with
in the individual app buffers.

00:51:24.840 --> 00:51:26.990
The final framebuffer product,
if that's what you need,

00:51:27.110 --> 00:51:29.230
you pretty much have to go to that.

00:51:29.400 --> 00:51:33.580
The Remote Operation Services is the
best way of getting these finished bits.

00:51:34.800 --> 00:51:41.410
Clients of remote services
include Apple Remote Desktop,

00:51:41.410 --> 00:51:41.410
Timbuk2, good old VNC,

00:51:41.860 --> 00:51:45.060
Some accessibility applications
like to play with this too.

00:51:45.090 --> 00:51:47.440
They may need to post
events into the system.

00:51:47.480 --> 00:51:51.160
So they'll be using the event posting
interface to post into a particular

00:51:51.850 --> 00:51:55.620
session and tell the apps in that
session to show certain behaviors.

00:51:57.100 --> 00:51:59.090
Screen scraping.

00:51:59.190 --> 00:52:00.780
All I get is bits.

00:52:00.790 --> 00:52:03.180
Well, we have this complicated pipeline.

00:52:03.180 --> 00:52:05.660
It's really hard to get to the
individual bits from the window.

00:52:05.660 --> 00:52:08.550
If you wanted to get the bits on
the screen but not go to the screen,

00:52:08.550 --> 00:52:08.840
eh.

00:52:09.400 --> 00:52:17.300
[Transcript missing]

00:52:22.600 --> 00:52:24.950
So to assist you in finding
what's changed on the screen,

00:52:25.000 --> 00:52:28.480
we give you a system of
asynchronous notifications.

00:52:28.800 --> 00:52:31.020
Async means that we tell
you something has changed,

00:52:31.020 --> 00:52:33.400
your app goes and picks it up
and gets the current state of

00:52:33.460 --> 00:52:34.500
what's changed on the system.

00:52:34.500 --> 00:52:37.390
It's async so that applications
that don't behave well don't

00:52:37.390 --> 00:52:39.010
get to hang the entire system.

00:52:39.010 --> 00:52:40.020
It's very straightforward.

00:52:42.410 --> 00:52:45.130
If you have delays in your processing,
delays that occur,

00:52:45.130 --> 00:52:48.460
system-wide scheduling or load that
cause you to be a little slow about

00:52:48.460 --> 00:52:51.640
getting the current state back,
that's not a big problem.

00:52:51.640 --> 00:52:53.740
We keep coalescing the
state changes for you.

00:52:53.740 --> 00:52:56.220
They're built up,
and your app will get the latest image

00:52:56.220 --> 00:52:58.160
of whatever state's on the display.

00:53:00.320 --> 00:53:02.270
There are new functions
added to Panther that tell

00:53:02.270 --> 00:53:04.920
you not about just changes,
but about areas that are

00:53:04.940 --> 00:53:06.300
moving on the screen.

00:53:06.490 --> 00:53:09.420
This will help speed up certain
operations that you might get into

00:53:09.420 --> 00:53:11.750
if you're doing screencasting.

00:53:14.600 --> 00:53:17.030
: Oh, good morning.

00:53:17.140 --> 00:53:19.560
Now, screen scraping performance.

00:53:19.910 --> 00:53:22.540
Now,
that screen is at the end of a long bus,

00:53:22.540 --> 00:53:24.580
that long pipeline.

00:53:24.890 --> 00:53:28.000
It's out there at the distant end
of an AGP or PCI bus connector.

00:53:28.000 --> 00:53:31.080
And if you go out there and
read those pixels yourself,

00:53:31.080 --> 00:53:32.670
it's going to be slow.

00:53:35.800 --> 00:53:40.820
The fastest way to read the pixels
off the screen is not obvious at all.

00:53:40.940 --> 00:53:43.310
You use OpenGL.

00:53:43.690 --> 00:53:49.070
You build a full-screen GL context,
select the screen with GL Read Buffer,

00:53:49.070 --> 00:53:50.120
GL Front.

00:53:50.210 --> 00:53:54.540
You read the screen with
GL Read Pixels into your own buffer.

00:53:55.410 --> 00:53:59.460
That's going to get you DMA transfers
from the screen right into

00:53:59.530 --> 00:54:02.640
your application's buffer,
if you do it right.

00:54:04.370 --> 00:54:06.740
If you don't do it so right,
it's still going to get

00:54:06.740 --> 00:54:09.700
you a fast software path,
but it won't be as fast

00:54:09.700 --> 00:54:10.800
as doing the DMA trick.

00:54:10.820 --> 00:54:13.020
Things to be aware of.

00:54:14.360 --> 00:54:16.520
GL is a little different view of the
world than you might be used to if

00:54:16.580 --> 00:54:18.120
you're used to dealing with framebuffers.

00:54:18.120 --> 00:54:21.840
It puts things in quadrant one,
the origin point being down

00:54:21.840 --> 00:54:23.770
in the lower left corner.

00:54:23.770 --> 00:54:26.170
It's upside down.

00:54:28.300 --> 00:54:33.500
Now, if you're just processing the bits
to pack them up and send them across

00:54:33.540 --> 00:54:36.260
for a screencasting application,
that's not actually that big a deal.

00:54:36.260 --> 00:54:38.530
It just means you have to walk through
the bitmap in a different order.

00:54:38.540 --> 00:54:42.120
Set your pointers up correctly and set
up your stride as you traverse the data,

00:54:42.130 --> 00:54:43.290
and you'll be all set.

00:54:43.320 --> 00:54:47.000
Source code showing you how to
do this is going to be online.

00:54:48.880 --> 00:54:53.910
I'm going to show you right now what
this looks like over here on DEMO 1.

00:55:00.250 --> 00:55:03.600
A little bitty grab application.

00:55:03.600 --> 00:55:11.010
We can grab the screen contents
and go ahead and save it to a file.

00:55:20.020 --> 00:55:22.030
There we are.

00:55:22.220 --> 00:55:23.490
And look, it's a screen grab.

00:55:23.530 --> 00:55:27.000
Wow, that was exciting, wasn't it?

00:55:27.660 --> 00:55:30.230
He can go back to sleep now.

00:55:34.440 --> 00:55:36.480
I hooked up something interesting
to this version of Grab.

00:55:36.480 --> 00:55:40.570
We can time it.

00:55:40.650 --> 00:55:45.270
We'll do 10 Grabs in a row and average
it out and see how many milliseconds it

00:55:45.270 --> 00:55:49.930
takes to go ahead and scrape this 10,
24, 7, 68, 32-bit screen in software.

00:55:49.930 --> 00:55:50.810
Okay.

00:55:50.810 --> 00:55:53.850
140 milliseconds.

00:55:55.800 --> 00:55:56.360
That's not too bad.

00:55:56.360 --> 00:56:02.790
Let's try it with OpenGL.

00:56:06.030 --> 00:56:07.800
It got faster, didn't it?

00:56:07.810 --> 00:56:10.680
That's more time for your application
to get the data compressed,

00:56:10.680 --> 00:56:14.260
shove it over the wire,
and catch the next screen update.

00:56:14.270 --> 00:56:16.040
I buy a factor of 10 in this case.

00:56:16.050 --> 00:56:17.610
Now, you won't always see
that big of a change,

00:56:17.670 --> 00:56:21.140
but on pretty much any of the hardware
we've built in the last couple of years,

00:56:21.210 --> 00:56:23.550
this is faster than doing it in software.

00:56:23.610 --> 00:56:27.130
DMA, good.

00:56:27.450 --> 00:56:30.500
So, how did this code do it?

00:56:32.930 --> 00:56:33.890
It's rough.

00:56:33.900 --> 00:56:37.950
We set up...

00:56:40.910 --> 00:56:44.220
For our main display, a mask bit.

00:56:44.220 --> 00:56:50.140
We say we'd like a full-screen
context for that display.

00:56:50.140 --> 00:56:53.370
We choose a pixel format.

00:56:54.600 --> 00:56:59.700
[Transcript missing]

00:57:02.410 --> 00:57:05.640
Set that context to be
the current context.

00:57:05.680 --> 00:57:07.630
Tell the system, "This is full screen.

00:57:07.750 --> 00:57:09.750
Here we go."

00:57:10.750 --> 00:57:14.060
Point GL at the front buffer,
that is the display.

00:57:14.070 --> 00:57:16.400
Ask it for the width and height.

00:57:16.450 --> 00:57:19.330
Get a place to put the
data we're going to grab.

00:57:20.130 --> 00:57:22.770
makes sure that all the
GL commands are finished and the

00:57:22.780 --> 00:57:24.640
display is correct and current.

00:57:24.770 --> 00:57:26.250
Tell the system we'd
like the data packed,

00:57:26.250 --> 00:57:26.520
please.

00:57:26.780 --> 00:57:32.100
Call GL Read Pixels with the
mystical incantation GL BGRA.

00:57:32.190 --> 00:57:36.600
GL unsigned int dash 8888 rev.

00:57:36.670 --> 00:57:39.200
These are Apple extensions.

00:57:39.250 --> 00:57:42.200
They're present on all Mac OS X systems.

00:57:42.200 --> 00:57:43.640
So I didn't bother
checking for that first.

00:57:43.720 --> 00:57:45.210
Naughty me.

00:57:46.790 --> 00:57:49.660
If you ask for this pattern,
this will match 32-bit

00:57:49.840 --> 00:57:51.800
deep display hardware.

00:57:51.800 --> 00:57:53.170
You'll get the DMA effect.

00:57:53.250 --> 00:57:59.370
GL unsigned int 1555 rev,
the only other rev depth in there,

00:57:59.370 --> 00:58:03.760
will get you the 16-bit display format,
and you'll get DMA transfers

00:58:03.760 --> 00:58:05.120
in that case also.

00:58:08.970 --> 00:58:14.080
When you're all done, release the stuff.

00:58:14.130 --> 00:58:16.380
That's all there is to it.

00:58:16.420 --> 00:58:25.270
Less than two pages of code in really
big type to capture the screen contents.

00:58:25.380 --> 00:58:30.000
And back to the slides, please.

00:58:30.040 --> 00:58:33.790
Over in the event side of systems,
you need to post events into the works,

00:58:33.790 --> 00:58:34.370
right?

00:58:37.600 --> 00:58:40.830
This is interesting.

00:58:41.010 --> 00:58:43.990
We have keyboard and
mouse events coming in

00:58:45.220 --> 00:58:49.070
from the kernel,
or to the kernel from our hardware.

00:58:49.210 --> 00:58:52.330
The kernel and HID system
pick up those events,

00:58:53.350 --> 00:58:56.620
Chew on them a little bit,
put them into a nice format for us.

00:58:56.680 --> 00:58:58.500
Pass those into the Quartz Compositor.

00:58:58.500 --> 00:58:59.990
What?

00:59:00.100 --> 00:59:02.520
The Quartz Compositor knows
where all your windows live.

00:59:02.760 --> 00:59:06.660
It knows which app is foreground,
so it can be used to route these

00:59:06.670 --> 00:59:09.300
events out to all your applications.

00:59:09.300 --> 00:59:13.580
There's a couple of ways to
push events into the system.

00:59:14.450 --> 00:59:18.070
IOHitPostEvent is a call from
user space into the I/O Kit that

00:59:18.070 --> 00:59:21.710
takes an event structure and
shoves it right in as though it

00:59:21.710 --> 00:59:24.040
were coming from other hardware.

00:59:24.170 --> 00:59:27.130
If you are writing a user space
device driver or something that wants

00:59:27.170 --> 00:59:31.700
to pretend to be a device driver
synthesizing events system-wide,

00:59:31.730 --> 00:59:34.080
use IOHitPostEvent.

00:59:34.200 --> 00:59:37.160
There are also some techniques
that can be used to inject events

00:59:37.570 --> 00:59:39.500
at the Quartz compositor level.

00:59:39.640 --> 00:59:42.430
These are actually not appropriate
for user space device drivers.

00:59:42.960 --> 00:59:45.830
They are used in some
assistive technology,

00:59:45.830 --> 00:59:46.610
though.

00:59:47.290 --> 00:59:49.970
These let you post a keyboard event in,
a scroll wheel event,

00:59:50.110 --> 00:59:52.440
or a mouse event in at the
Quartz compositor level.

00:59:52.560 --> 00:59:55.320
Now, why are these not appropriate?

00:59:56.060 --> 01:00:01.850
We have multiple user
sessions on the machine now.

01:00:02.200 --> 01:00:06.300
There can be a second user login
with a second set of Windows,

01:00:06.300 --> 01:00:11.890
a second Windows system,
second set of apps, a second dock,

01:00:11.890 --> 01:00:13.040
all that.

01:00:14.220 --> 01:00:16.560
Post Keyboard Event,
Post Scroll Wheel Event,

01:00:16.560 --> 01:00:22.060
and Post Mouse Event are going to post
into the session they are called in.

01:00:22.190 --> 01:00:24.830
So if you're emulating hardware,
you missed.

01:00:29.380 --> 01:00:34.410
The difference there?

01:00:34.410 --> 01:00:34.410
I don't want anyone to
get tripped up on this.

01:00:35.600 --> 01:00:38.040
Posting mouse events is
pretty straightforward.

01:00:38.060 --> 01:00:40.360
CGPost mouse event,
you give it a cursor position,

01:00:40.360 --> 01:00:42.120
you tell it a Boolean that tells it,
"I want to move the

01:00:42.210 --> 01:00:44.660
cursor to this position."
Normally you'd pass the true in.

01:00:44.680 --> 01:00:48.770
You pass in a count of buttons, one, two,
three, and a set of Booleans

01:00:48.770 --> 01:00:50.190
for the button state.

01:00:50.280 --> 01:00:54.540
If you push a button down,
don't forget to post another

01:00:54.570 --> 01:00:56.910
event to let the button up.

01:00:57.060 --> 01:00:58.000
Thank you.

01:00:58.000 --> 01:01:00.800
That has a really bad effect on the
system I'm going to get to in a minute.

01:01:00.820 --> 01:01:02.930
There's also an interface,
CG Warp Cursor,

01:01:02.960 --> 01:01:04.860
you can use just to move the
cursor around on the display.

01:01:07.990 --> 01:01:09.160
Posting keyboard events.

01:01:09.160 --> 01:01:12.140
There are key codes,
which are the decrypted glyph

01:01:12.160 --> 01:01:13.520
codes that you see in a system.

01:01:13.520 --> 01:01:16.420
There are also character, I'm sorry,
there are key codes.

01:01:16.420 --> 01:01:18.480
Boy, is this terminology fuzzy.

01:01:18.480 --> 01:01:19.900
Key codes are virtual key codes.

01:01:19.900 --> 01:01:21.880
They're scan codes
coming off the keyboard.

01:01:21.880 --> 01:01:24.690
Character codes are the encoding
for a particular character or glyph.

01:01:24.690 --> 01:01:28.790
The thing you need to get right
passing into this call is the key code.

01:01:28.790 --> 01:01:31.830
Most environments ignore
the character code part.

01:01:31.830 --> 01:01:34.850
The virtual key code is the
part you need to pass in.

01:01:34.850 --> 01:01:37.370
There's actually a dummy
flag you can pass in.

01:01:38.020 --> 01:01:39.860
For the character code,
it'll cause the system to guess at

01:01:39.890 --> 01:01:41.020
the best key code to use with it.

01:01:41.080 --> 01:01:46.070
Application environments like Carbon and
Cocoa use the key mapping and the key

01:01:46.070 --> 01:01:51.030
char API as part of Carbon to actually
do the translation from that raw virtual

01:01:51.030 --> 01:01:53.440
key code into the character code.

01:01:53.630 --> 01:01:56.750
Modifier flags are set by posting
virtual key codes for the modifier keys.

01:01:56.790 --> 01:01:58.970
All the keys on the keyboard
have these key codes.

01:01:58.970 --> 01:02:02.220
You pass them into this interface and
it's just like you're pushing the keys

01:02:02.220 --> 01:02:03.860
and letting them up on the keyboard.

01:02:03.860 --> 01:02:06.700
Don't forget to release the
key after you've pressed it.

01:02:07.900 --> 01:02:12.600
Event suppression,
when you post events into the system,

01:02:15.160 --> 01:02:19.720
We turn off the hardware event
path for a little while by default.

01:02:19.780 --> 01:02:21.330
That's to avoid mouse wars.

01:02:21.690 --> 01:02:24.720
A student help desk system,
you want to drive a system for a

01:02:24.730 --> 01:02:26.440
little by posting events into it.

01:02:26.500 --> 01:02:31.220
You don't want the eight-year-old
grabbing his mouse and fighting you.

01:02:31.220 --> 01:02:33.940
So we'll turn off the local
mouse for a short period of time.

01:02:34.020 --> 01:02:36.810
The force-quit key combination
reconnects the local hardware

01:02:36.860 --> 01:02:38.140
if things get really bad.

01:02:38.140 --> 01:02:41.490
Say you goof when
you're debugging things.

01:02:41.500 --> 01:02:45.470
You forget to let the mouse button up.

01:02:48.180 --> 01:02:51.280
There are functions to
override the default behavior.

01:02:51.320 --> 01:02:53.320
Now, I'd suggest you always
set the state as you want,

01:02:53.320 --> 01:02:56.440
just in case the default
behavior changes in the future.

01:02:56.480 --> 01:02:58.320
Event state combining
is one of these things.

01:02:58.330 --> 01:03:03.480
That combines the flags from your
keyboard modifiers from the real keyboard

01:03:04.000 --> 01:03:06.910
with the events from the remote system.

01:03:07.830 --> 01:03:10.770
You might want to keep this off
to keep local modifier keys,

01:03:11.020 --> 01:03:13.480
say the local shift key being held
down from getting into your events.

01:03:13.480 --> 01:03:16.730
The most frequent question we get is,
how do we turn this off?

01:03:20.890 --> 01:03:22.510
To do that,
you just want to set the suppression

01:03:22.510 --> 01:03:25.560
interval to zero so it doesn't
suppress things for any length of time.

01:03:25.640 --> 01:03:27.540
Tell the system, "Yeah,
I want event combining.

01:03:27.540 --> 01:03:32.240
I want my local shift key and my
remote shift key to all act the same."

01:03:32.380 --> 01:03:35.540
And you'll want to tell the system,
"Don't bother blocking

01:03:35.540 --> 01:03:37.180
local hardware events.

01:03:38.040 --> 01:03:42.700
Permit all events during the
suppression interval and permit all

01:03:42.700 --> 01:03:45.450
local events during remote mouse drags.

01:03:45.790 --> 01:03:48.240
Told you you had to let
that mouse button up.

01:03:48.390 --> 01:03:51.030
If you leave that mouse button down,
you're doing a drag operation.

01:03:51.040 --> 01:03:54.300
And this will normally block all
local events during that drag to keep

01:03:54.300 --> 01:03:55.820
things from going horribly astray.

01:03:55.820 --> 01:04:00.020
If you don't post that mouse up,
you're sticking in a drag state.

01:04:00.080 --> 01:04:00.720
Bad.

01:04:00.720 --> 01:04:01.480
Don't do that.

01:04:07.950 --> 01:04:09.800
Common Developer Problems,
questions we run into.

01:04:09.800 --> 01:04:12.320
"I want to filter all the
events in the system." Well,

01:04:12.320 --> 01:04:15.220
you don't do that at the Quartz level.

01:04:15.720 --> 01:04:19.200
That's the kind of thing
that goes deep in I/O Kit.

01:04:19.300 --> 01:04:22.930
Or you might want to think
about what you're doing,

01:04:23.030 --> 01:04:24.550
what is it you really need to accomplish?

01:04:24.560 --> 01:04:26.440
For example,
some of the questions we've gotten on

01:04:26.440 --> 01:04:30.110
this are operations that are better
handled as input managers in the

01:04:30.110 --> 01:04:33.360
system than as generic low-level,
I filter every event and pick

01:04:33.360 --> 01:04:38.090
out the ones I'm interested
in sort of operations.

01:04:38.170 --> 01:04:40.490
Another little comment for people.

01:04:40.800 --> 01:04:46.900
[Transcript missing]

01:04:48.830 --> 01:04:51.220
: Documented interfaces may change.

01:04:51.220 --> 01:04:53.300
They may go away.

01:04:53.300 --> 01:04:55.540
They may stop working.

01:04:55.970 --> 01:05:00.400
Undocumented parameters to
undocumented functions may do

01:05:00.510 --> 01:05:03.310
undocumented things to the system.

01:05:03.420 --> 01:05:06.710
You may let the smoke out of some parts.

01:05:07.470 --> 01:05:09.350
The stuff in the public
headers is actually better.

01:05:09.350 --> 01:05:12.940
When we do our development,
we often build things

01:05:12.940 --> 01:05:15.300
first as a private SPI,
and then once we've figured

01:05:15.300 --> 01:05:18.320
out all the quirks and have,
well, we've gotten our act together,

01:05:18.320 --> 01:05:20.820
we turn it into a public interface.

01:05:20.820 --> 01:05:22.840
Please use the public interfaces.

01:05:22.840 --> 01:05:25.720
Who here is calling a private interface?

01:05:25.720 --> 01:05:28.720
Any volunteers?

01:05:30.920 --> 01:05:32.220
Ah, yes, yes.

01:05:32.220 --> 01:05:34.610
I'll change that for you.

01:05:34.750 --> 01:05:37.300
I'll take care of that one.

01:05:37.380 --> 01:05:45.050
And for more information,
let's get Travis up here.

01:05:52.200 --> 01:05:53.700
Thank you, Mike.

01:05:53.720 --> 01:05:58.350
I think we have some reference
documentation available for you guys.

01:05:58.460 --> 01:06:00.380
We're actually going to aggregate it.

01:06:00.450 --> 01:06:05.210
It's all aggregated on sort of the
reorganized ADC website where TechPubs

01:06:05.260 --> 01:06:09.990
has moved the documentation from
where it was before we began WWDC.

01:06:10.150 --> 01:06:15.870
So everything should be, you know,
documentation should be appearing on a

01:06:15.870 --> 01:06:19.270
lot of the stuff under the graphics and
imaging area on the revised ADC website.

01:06:19.770 --> 01:06:21.800
We also have some tech
notes that are available.

01:06:21.800 --> 01:06:24.700
So there's going to be Tech Note 207.

01:06:24.700 --> 01:06:27.640
It talks about the CG Direct Display API.

01:06:27.770 --> 01:06:30.980
And then, well, probably very many people
won't be going to 208,

01:06:31.100 --> 01:06:35.770
the CG Direct Palette API,
considering how unpopular 8-bit palette

01:06:35.770 --> 01:06:39.090
is actually becoming and should become.

01:06:40.840 --> 01:06:46.210
We have some additional QAs,
such as many relating to

01:06:46.210 --> 01:06:49.150
Quick Draw and how to use it if
I'm a Carbon Quick Draw app and

01:06:49.150 --> 01:06:52.060
I need to use CG Direct Display.

01:06:52.100 --> 01:06:56.590
You know,
several Q&As up here that are available.

01:06:57.870 --> 01:06:59.990
And we have lots of sample code
that are going to be appearing.

01:07:00.000 --> 01:07:02.080
I don't think all of
these are up quite yet,

01:07:02.080 --> 01:07:04.330
but check the ADC website.

01:07:04.450 --> 01:07:10.270
We plan to push a lot of the samples that
you saw in today's demo up very shortly.

01:07:12.950 --> 01:07:15.800
And then obviously,
if you need more information on

01:07:15.800 --> 01:07:20.010
how to use GL and GL Read Pixels,
you can look at a couple different

01:07:20.010 --> 01:07:24.010
GL references at OpenGL.org,
which is a good resource

01:07:24.010 --> 01:07:25.700
for OpenGL in general.
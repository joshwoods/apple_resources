WEBVTT

00:00:25.540 --> 00:00:26.490
I'm Craig Keithley.

00:00:26.540 --> 00:00:28.980
I'm Apple's
Security Technology Evangelist in Apple's

00:00:29.030 --> 00:00:31.090
Worldwide Developer Relations Group.

00:00:31.130 --> 00:00:34.800
My job is to work with
security developers.

00:00:34.830 --> 00:00:38.210
It also includes, as it happens,
it's not shown here, that I'm Apple's

00:00:38.220 --> 00:00:39.940
I/O Technology Evangelist.

00:00:39.940 --> 00:00:43.530
So if you're working on smart cards
or other security devices that are

00:00:43.530 --> 00:00:48.090
connected via the USB bus or Bluetooth,
I'd be happy to talk to you as well.

00:00:48.500 --> 00:00:51.390
So today we're going to talk about
certificates and how they're used.

00:00:51.420 --> 00:00:54.540
We'll discuss security management.

00:00:54.540 --> 00:00:56.750
If you're not familiar with it,
we are adding new

00:00:56.750 --> 00:00:58.390
security APIs to Panther.

00:00:58.400 --> 00:01:02.890
So we'll go into what's in certificates,
their identities,

00:01:02.890 --> 00:01:06.990
how you store and retrieve them,
and the issue of establishing

00:01:07.040 --> 00:01:09.550
trust is an important one when
you're dealing with certificates,

00:01:09.550 --> 00:01:11.400
so we'll talk about that.

00:01:11.400 --> 00:01:14.960
We'll certainly reveal or show
you on a demo some of our new

00:01:14.960 --> 00:01:20.400
functions to display certificates,
and we'll discuss secure transport.

00:01:20.400 --> 00:01:24.300
So, to get started, Michael.

00:01:36.440 --> 00:01:38.830
I'd like to,
I'm going to talk a little bit

00:01:38.880 --> 00:01:42.900
about the security framework,
which is basically where most

00:01:42.900 --> 00:01:44.900
of our security APIs live.

00:01:44.900 --> 00:01:47.340
The security framework is
actually part of Darwin,

00:01:47.470 --> 00:01:50.940
so all the sources for the
security framework are available

00:01:50.940 --> 00:01:53.080
for download at Apple's website.

00:01:53.160 --> 00:01:56.270
In particular,
I'm going to cover a couple areas.

00:01:56.350 --> 00:02:00.650
SecKeychain, for as far as,
we use keychains to store certificates,

00:02:00.790 --> 00:02:04.760
and that's where we want you to
store your certificates as well.

00:02:04.850 --> 00:02:07.800
So, I'm going to cover that, you know,
not in depth.

00:02:08.110 --> 00:02:10.340
We've had plenty of keychain
sessions in the past,

00:02:10.390 --> 00:02:13.150
and if you have questions on that,
there's documentation online.

00:02:13.200 --> 00:02:15.990
But I'm just going to cover the
part of that that's relevant

00:02:15.990 --> 00:02:17.360
to our certificate APIs.

00:02:17.400 --> 00:02:20.850
SecCertificate,
which is basically an object

00:02:20.850 --> 00:02:23.160
that represents a certificate.

00:02:23.210 --> 00:02:26.430
It contains the actual raw data
of the certificate and a couple

00:02:26.490 --> 00:02:28.110
of higher level operations.

00:02:28.160 --> 00:02:34.160
It's mainly used to pass around
certificates between our different APIs.

00:02:34.160 --> 00:02:38.090
Then there's SecIdentity,
which I'll go into,

00:02:38.170 --> 00:02:42.160
which actually represents a
certificate and a private key.

00:02:42.160 --> 00:02:46.600
So, this is actually a certificate
that the user on that machine

00:02:46.600 --> 00:02:48.850
can do something with,
because this represents

00:02:49.460 --> 00:02:51.160
the user's identity.

00:02:51.160 --> 00:02:53.150
Or, one of his identities.

00:02:53.160 --> 00:02:57.650
So, that's actually something that
you can sign with or decrypt with,

00:02:57.650 --> 00:02:57.960
etc.

00:02:58.380 --> 00:03:02.140
Whereas, just a plain certificate really
could be anyone's certificate.

00:03:02.240 --> 00:03:05.160
A certificate from some other person.

00:03:05.320 --> 00:03:12.790
And finally, SecTrust is our,
it's like a workflow object that lets you

00:03:12.870 --> 00:03:18.510
evaluate whether or not a certificate or
a group of certificates can be trusted.

00:03:19.280 --> 00:03:22.730
In addition to the security framework,
there are two new frameworks

00:03:22.730 --> 00:03:25.840
being introduced in Panther called
Security Foundation and

00:03:25.840 --> 00:03:27.200
Security Interface.

00:03:27.200 --> 00:03:32.480
For those of you familiar with Cocoa,
these are analogous with Foundation and

00:03:32.490 --> 00:03:34.200
AppKit at the Cocoa level.

00:03:34.270 --> 00:03:39.860
Security Foundation contains
our low-level,

00:03:39.900 --> 00:03:46.190
non-GUI Cocoa APIs for dealing with some
of the certificate and authorization

00:03:46.250 --> 00:03:49.200
and other security-related things.

00:03:49.210 --> 00:03:53.950
Whereas Security Interface actually
contains views and dialogues and

00:03:54.010 --> 00:03:57.730
things like that to have to do with
displaying certificates and displaying

00:03:57.730 --> 00:03:59.200
other security-related information.

00:03:59.200 --> 00:04:02.930
Previously, some of the things that are
in Security Interface and

00:04:02.930 --> 00:04:08.200
Security Foundation were:
Security HI Cocoa,

00:04:08.200 --> 00:04:08.200
which was a private framework.

00:04:08.200 --> 00:04:12.070
But since it was Cocoa,
I'm sure that some of you in this

00:04:12.090 --> 00:04:16.030
room must have reverse-engineered our
APIs and figured out what was there.

00:04:16.860 --> 00:04:19.340
Unfortunately,
Security HI Cocoa is going away,

00:04:19.400 --> 00:04:22.320
and it's being superseded
by Security Interface

00:04:22.320 --> 00:04:24.140
and Security Foundation.

00:04:24.220 --> 00:04:27.080
The good news is that
those two are public,

00:04:27.080 --> 00:04:29.980
so we're committed to supporting them.

00:04:33.600 --> 00:04:36.530
Let's see if the... There we go.

00:04:36.670 --> 00:04:41.080
So,
I'll start with a quick overview of CDSA,

00:04:41.080 --> 00:04:46.600
which stands for
Common Data Security Architecture.

00:04:46.720 --> 00:04:49.570
And that's basically...
It's an open group standard.

00:04:49.590 --> 00:04:54.600
It's the foundation on which all
of our security APIs are built.

00:04:54.750 --> 00:05:01.590
CDNA is somewhat analogous to, let's say,
Microsoft's CAPI or OpenSSL,

00:05:01.590 --> 00:05:03.600
which some of you might be aware of.

00:05:03.600 --> 00:05:08.370
And some of the key differences between
those are that CDSA is pluggable.

00:05:08.730 --> 00:05:11.600
In essence, it's a plug-in architecture.

00:05:11.600 --> 00:05:14.190
It's an empty shell,
and you have different module

00:05:14.240 --> 00:05:15.580
types that perform different tasks.

00:05:15.600 --> 00:05:19.600
I'll go into more
detail about that later.

00:05:19.600 --> 00:05:23.440
I'll cover some of the basic
functionality provided by the security

00:05:23.440 --> 00:05:25.430
framework in addition to CDSA.

00:05:25.620 --> 00:05:30.180
Then we'll talk a little bit how you
can use certificates to establish trust

00:05:30.230 --> 00:05:35.360
and what APIs we provide to help you
do that and show you how to store and

00:05:35.460 --> 00:05:38.420
retrieve certificates from keychains.

00:05:40.000 --> 00:05:41.800
So I have a quick question.

00:05:41.800 --> 00:05:45.210
How many of you know
what a certificate is?

00:05:46.100 --> 00:07:44.200
[Transcript missing]

00:07:45.670 --> 00:07:49.100
So we have a number of
different modules we provide.

00:07:49.120 --> 00:07:53.340
Now, the two modules that are
more relevant to this session

00:07:53.580 --> 00:07:59.030
are at the Certificate Library Module,
which the Certificate Library Module,

00:07:59.030 --> 00:08:02.660
or CL, is used to syntactically
peel apart a certificate.

00:08:02.810 --> 00:08:06.540
So a certificate consists of
a number of attributes and

00:08:06.540 --> 00:08:09.910
potentially a number of extensions.

00:08:09.980 --> 00:08:14.040
And the Certificate Library Module can
take this bob of binary data and

00:08:14.440 --> 00:08:18.650
peel it apart so you can actually
get these attributes and extensions

00:08:18.650 --> 00:08:23.480
in C structures or different formats
that your application can work with.

00:08:24.790 --> 00:08:28.240
In contrast to the CL,
we have the Trust Policy Module,

00:08:28.280 --> 00:08:31.940
which doesn't actually operate on
the low level on the certificates,

00:08:32.050 --> 00:08:35.690
but it operates on groups of
certificates and can construct a

00:08:35.770 --> 00:08:38.770
chain of trust in the case of X.509.

00:08:39.780 --> 00:08:40.530
The Trust Policy Module is a tool
that allows you to have a trust policy

00:08:40.530 --> 00:08:41.770
module that is based on the trust
policy that you have in your system.

00:08:41.780 --> 00:08:43.660
If you were to have, let's say,
a PGP trust policy module,

00:08:43.660 --> 00:08:47.150
you take a bag of certificates and
you could determine whether the

00:08:47.170 --> 00:08:51.900
certificate that you're looking for is,
or that you want to evaluate,

00:08:51.910 --> 00:08:56.600
is actually trusted due to
whatever relationships are needed.

00:08:56.600 --> 00:09:00.530
So Trust Policy Modules,
we currently provide one

00:09:00.530 --> 00:09:04.900
Trust Policy Module and it has
five or six different policies.

00:09:04.900 --> 00:09:07.300
There's a policy for SMIME,
there's a policy for

00:09:07.330 --> 00:09:11.280
SSL clients for SSL servers,
and there's a number of different

00:09:11.280 --> 00:09:15.270
policies because there are slight
differences in what fields and

00:09:15.570 --> 00:09:21.600
extensions and attributes need to be
there in a certificate chain for it to

00:09:21.600 --> 00:09:23.660
be trusted for a particular operation.

00:09:23.660 --> 00:09:26.070
So that's what
Trust Policy Modules is for.

00:09:26.170 --> 00:09:28.750
And again,
all these modules are pluggable,

00:09:28.780 --> 00:09:31.610
so as a developer,
if you find that we don't provide

00:09:31.870 --> 00:09:35.210
the exact service you need,
you can actually write an additional

00:09:35.400 --> 00:09:38.660
plug-in module that provides,
you know, a different trust policy.

00:09:38.660 --> 00:09:40.170
So if you're looking for a
specific type of service,

00:09:40.170 --> 00:09:41.570
you can write an
additional plug-in module.

00:09:41.580 --> 00:09:49.610
And again, you can do that by adding
your own Trust Policy Module.

00:09:49.610 --> 00:09:57.490
And since ours are open source,
you have a nice starting point.

00:10:00.950 --> 00:10:06.080
So here's a little picture
of our entire security stack.

00:10:06.570 --> 00:10:11.410
The CDSA part of that
is the lower two blocks.

00:10:11.460 --> 00:10:14.050
So there's the
Common Security Services Manager and

00:10:14.050 --> 00:10:15.490
then the add-in modules.

00:10:15.490 --> 00:10:20.190
So that's really the
part we just covered.

00:10:23.160 --> 00:10:28.100
So, some functionality that
CDSA has through the CSP.

00:10:28.420 --> 00:10:33.760
You can do key generation,
generate symmetric keys, asymmetric keys,

00:10:33.760 --> 00:10:38.100
HMAC signing keys, you name it,
it's there.

00:10:38.100 --> 00:10:42.840
Encryption and decryption,
we support AES in the form of, well,

00:10:42.850 --> 00:10:45.100
Raindell, the algorithm.

00:10:45.240 --> 00:10:52.100
We support triple DAS, DAS, RC2, RC4,
RC5, all the common algorithms.

00:10:52.110 --> 00:10:56.860
Support different types of digests, MD5,
SHA1,

00:10:56.860 --> 00:11:00.340
there's a couple others in there too.

00:11:00.550 --> 00:11:09.900
Data Storage and
Retrieval through the DL,

00:11:09.900 --> 00:11:09.900
so for storing security-related things
like keys or certificates or whatnot.

00:11:10.000 --> 00:13:10.100
[Transcript missing]

00:13:12.270 --> 00:13:18.720
Finally, there's certificate parsing and
evaluation and determination of

00:13:18.780 --> 00:13:21.860
trust through the CLNTP modules.

00:13:22.960 --> 00:13:26.370
So, back to the step up to
the security framework.

00:13:26.440 --> 00:13:29.910
So one of the things it does,
it implements CDSA.

00:13:29.990 --> 00:13:33.040
Actually,
all the plugin modules that we ship

00:13:33.040 --> 00:13:34.970
are actually built into the framework.

00:13:35.180 --> 00:13:36.540
They're not actual plugins.

00:13:36.540 --> 00:13:44.640
That's really just a performance hack
or performance implementation detail.

00:13:44.830 --> 00:13:47.980
From the developer's point of view,
they still look like plugins.

00:13:47.980 --> 00:13:51.950
It's just we don't have
to actually load them.

00:13:52.380 --> 00:13:57.660
So we provide, in addition to CDSA,
we also provide the higher level

00:13:57.660 --> 00:14:01.910
security interfaces like Sec Keychain
APIs and some of the other

00:14:01.910 --> 00:14:05.530
APIs I talked about in the introduction,
Sec Certificate, Sec Trust.

00:14:05.700 --> 00:14:07.030
There's a whole suite of APIs.

00:14:07.280 --> 00:14:09.260
There's authorization APIs in there.

00:14:09.260 --> 00:14:11.620
There's a bunch of other things.

00:14:11.720 --> 00:14:16.700
There is no user interface
in the security framework.

00:14:16.700 --> 00:14:19.010
The security framework depends
on the system framework,

00:14:19.140 --> 00:14:19.660
and that's it.

00:14:19.660 --> 00:14:22.310
It's part of Darwin,
but it doesn't have any other

00:14:22.330 --> 00:14:23.910
dependencies than the system framework.

00:14:24.050 --> 00:14:26.250
So, no Carbon, no Cocoa, nothing.

00:14:26.290 --> 00:14:29.450
So, your app command line tool could
link against the security framework,

00:14:29.560 --> 00:14:33.120
and in fact,
many command line tools should, probably,

00:14:33.240 --> 00:14:35.450
if they are anything related to security.

00:14:35.460 --> 00:14:39.840
And, as I said before,
it's part of Darwin open source.

00:14:39.930 --> 00:14:42.900
You can go to opensource.apple.com,
I think,

00:14:42.900 --> 00:14:47.990
or developer.apple.com/opensource,
and just download the latest

00:14:48.120 --> 00:14:50.980
version of the security framework,
which is what you have on your

00:14:50.980 --> 00:14:52.670
machines right now on Panther.

00:14:52.700 --> 00:14:57.190
The only difference between the
open source version of security

00:14:57.910 --> 00:15:02.740
framework and what's on your machine
in Panther is that there are two

00:15:02.740 --> 00:15:04.700
algorithms in the CSP that are used
to create the security framework.

00:15:04.700 --> 00:15:07.760
There are two algorithms that
are patented by Apple and

00:15:07.760 --> 00:15:12.060
still considered proprietary,
which are FEE, which is a fast elliptic

00:15:12.150 --> 00:15:14.940
curve implementation,
and ASC,

00:15:14.940 --> 00:15:17.940
which is Apple secure compression.

00:15:17.940 --> 00:15:21.940
Neither of those are actually used in
any of the default software we ship.

00:15:21.940 --> 00:15:23.980
So, if you were to take the open
source version and build it,

00:15:23.980 --> 00:15:25.940
you wouldn't get these two algorithms.

00:15:25.940 --> 00:15:28.680
But you have to be aware,
if you're planning to

00:15:28.690 --> 00:15:32.020
actually use these algorithms,
they're not part of the

00:15:32.020 --> 00:15:33.940
open source distribution.

00:15:33.940 --> 00:15:37.750
So, if you're planning to use these
two algorithms in your application,

00:15:37.750 --> 00:15:41.100
you can't use a security
framework that you built yourself.

00:15:41.990 --> 00:15:46.800
So now on to the Sec APIs,
which Sec is short for security.

00:15:46.800 --> 00:15:48.440
It's not French for dry.

00:15:48.440 --> 00:15:53.290
I mean, it is,
but that wasn't our intention.

00:15:53.800 --> 00:17:02.300
[Transcript missing]

00:17:02.770 --> 00:17:05.060
So if you're in a Cocoa app,
that might benefit you.

00:17:05.060 --> 00:17:09.770
Be aware of copy versus get.

00:17:09.980 --> 00:17:12.040
You know, that's the,
if you call a method that,

00:17:12.040 --> 00:17:15.640
or a function that has copy in its name,
that means that the object

00:17:15.750 --> 00:17:19.500
returned by it is being copied,
which means that you as a

00:17:19.540 --> 00:17:22.340
developer are responsible for
calling cfrelease on its result.

00:17:22.360 --> 00:17:25.890
Whereas if it has get in its name,
you shouldn't call cfrelease

00:17:26.070 --> 00:17:27.570
unless you call cfretain before.

00:17:27.660 --> 00:17:29.600
So if you want to actually
keep that object around,

00:17:29.630 --> 00:17:30.760
you better cfretain it.

00:17:31.830 --> 00:17:35.860
And in fact, in some of our APIs where,
that are named get,

00:17:35.860 --> 00:17:40.610
it'll be clear from the documentation
that the lifetime of the object

00:17:40.720 --> 00:17:45.540
you're getting is most likely
tied to the lifetime of the object

00:17:45.620 --> 00:17:48.580
that you're getting it from.

00:17:49.410 --> 00:17:53.780
So, for example, if you were to get a,
we have, for example,

00:17:53.780 --> 00:17:57.280
if you have a certificate object,
you can actually get a CL handle,

00:17:57.300 --> 00:18:00.670
which lets you operate at the
CDSA level with that certificate.

00:18:00.800 --> 00:18:04.040
That CL handle is only guaranteed
to be valid for as long as that

00:18:04.040 --> 00:18:05.940
SEC certificate object is valid.

00:18:06.000 --> 00:18:09.210
So, it might be valid after that,
but we don't guarantee it.

00:18:09.280 --> 00:18:12.250
And the CL handle happens
to not be a SEC object,

00:18:12.330 --> 00:18:14.010
so you can't retain it.

00:18:14.100 --> 00:18:16.940
It's just a CDSA level handle.

00:18:17.340 --> 00:18:20.610
Which brings me to the last point,
which is bridge functions to CSSM.

00:18:20.800 --> 00:18:25.800
So we didn't try to make
the Sec layer complete.

00:18:25.800 --> 00:18:29.710
We tried to make it, you know,

00:18:30.090 --> 00:18:33.500
have most of the high-level
functionality that you would wanna use.

00:18:33.510 --> 00:18:38.010
Now, in most applications,
it's sufficient to have the SecLayer.

00:18:38.060 --> 00:18:43.600
Now, SecCertificate, as an example,
does not have actual APIs to

00:18:43.630 --> 00:18:46.700
decompose a certificate and get all
the different fields out of there.

00:18:46.870 --> 00:18:49.470
If you wanna actually go down to
that level and really peel apart the

00:18:49.470 --> 00:18:53.780
certificate and see what's in there,
you can get the CL handle out from there,

00:18:53.790 --> 00:18:58.240
and you can call the CL functions
to basically parse the certificate

00:18:58.240 --> 00:18:59.700
and figure out what's in it.

00:18:59.790 --> 00:19:04.380
So if your application has the need to do
its own custom display of certificates,

00:19:04.380 --> 00:19:05.440
you could do that.

00:19:05.620 --> 00:19:08.380
Now, normally,
you probably wouldn't need that because

00:19:08.440 --> 00:19:14.010
we provide a SF certificate view class,
which actually can display a certificate

00:19:14.020 --> 00:19:15.980
and does all this work for you.

00:19:16.000 --> 00:19:20.210
Again, if you wanted to customize this,
we do provide a way to

00:19:20.210 --> 00:19:22.220
bridge down to CSSM.

00:19:24.170 --> 00:19:27.010
So here's where the
Sec APIs are in the big picture.

00:19:27.220 --> 00:19:31.920
So there's CDSA below,
and the Sec APIs sit

00:19:31.920 --> 00:19:33.760
right on top of that.

00:19:33.860 --> 00:19:37.140
In addition to the Sec APIs,
that same layer,

00:19:37.290 --> 00:19:41.800
we have Secure Transport,
which is our SSL implementation.

00:19:41.800 --> 00:19:46.200
The Authorization APIs,
which aren't covered

00:19:46.200 --> 00:19:49.800
in this session today,
but if you have any questions

00:19:49.800 --> 00:19:51.890
at all about authorization,
about how to use them,

00:19:51.890 --> 00:19:54.270
there's actually some really
cool new stuff we've added to

00:19:54.270 --> 00:19:57.820
authorization that many of you
have been asking us for years,

00:19:57.880 --> 00:20:01.800
which is we now allow you to customize
the dialogs in authorization.

00:20:01.930 --> 00:20:06.230
That's actually not on the CDs you have,
but in the authorization

00:20:06.230 --> 00:20:10.740
lab downstairs in the,
I think it's the Marina conference room,

00:20:10.790 --> 00:20:14.800
we have an updated version
of the security agent,

00:20:14.800 --> 00:20:17.800
which actually supports
the customizable dialogs.

00:20:17.980 --> 00:20:21.460
And we also let you now add and
manipulate authorization rules,

00:20:21.460 --> 00:20:24.550
so as a developer,
you can now actually do a lot of new,

00:20:24.550 --> 00:20:26.760
cool stuff with authorization.

00:20:26.800 --> 00:20:29.800
So be sure to come down to our lab
any time this week to check that out.

00:20:29.800 --> 00:20:30.800
Thank you.

00:20:30.800 --> 00:20:31.760
Thank you.

00:20:31.930 --> 00:20:34.400
Learn more about that.

00:20:37.110 --> 00:20:40.870
So, I just want to do a quick
thing on Keychain APIs,

00:20:40.920 --> 00:20:42.660
because some of you might
have come from OS 9,

00:20:42.660 --> 00:20:46.000
and we're really thankful because
you've been with us for a long time,

00:20:46.000 --> 00:20:48.680
and you might have been early
adopters of the Keychain APIs,

00:20:48.680 --> 00:20:51.850
and going, "Well,
what's all this new Sec API stuff?

00:20:52.000 --> 00:20:54.850
Do I really care?" Well,
the good news is the Keychain

00:20:54.850 --> 00:21:00.600
Manager APIs that have been around
since OS 8.6 or 8.5 are staying.

00:21:00.600 --> 00:21:01.270
They're here to stay.

00:21:01.310 --> 00:21:02.180
They're part of Carbon.

00:21:02.240 --> 00:21:06.860
They're not changing,
which also means they're not evolving.

00:21:06.960 --> 00:21:11.040
But they do everything that
most apps would need to do for

00:21:11.040 --> 00:21:13.590
manipulating Keychain objects.

00:21:13.770 --> 00:21:16.190
Now,
in addition to the Keychain Manager APIs,

00:21:16.190 --> 00:21:18.900
back in Jaguar,
we introduced the Sec Keychain APIs.

00:21:19.000 --> 00:21:24.280
And the advantage of the
Sec APIs versus the Keychain

00:21:24.280 --> 00:21:28.240
Manager APIs is they're not in Carbon.

00:21:28.240 --> 00:21:32.120
So, the Sec APIs would be usable from
a Cocoa app without you having to

00:21:32.180 --> 00:21:33.880
pull in the entire Carbon stack.

00:21:34.110 --> 00:21:36.920
There's a couple other things,
so I'll get to that.

00:21:36.920 --> 00:21:39.760
So, like I said, both APIs are supported.

00:21:39.890 --> 00:21:42.960
They're going to be
supported in the future.

00:21:43.140 --> 00:21:48.740
And, in fact, a Sec Keychain Ref is
the same as a KC Ref,

00:21:49.090 --> 00:21:52.800
and a Sec Keychain Item Ref is
the same as a KC Item Ref.

00:21:52.960 --> 00:21:57.420
So, that's not documented anywhere, but,
you know, you can actually use those

00:21:57.450 --> 00:22:00.760
APIs interchangeably,
because the core implementation of

00:22:00.760 --> 00:22:02.950
them is actually exactly the same.

00:22:04.230 --> 00:22:09.200
Both these APIs might bring up UI.

00:22:09.200 --> 00:22:11.720
You might be wondering, I just said,
you know,

00:22:11.720 --> 00:22:13.190
security framework doesn't do any UI.

00:22:13.190 --> 00:22:14.200
What are you talking about?

00:22:14.200 --> 00:22:16.350
Well,
the security framework itself doesn't

00:22:16.360 --> 00:22:20.200
actually depend on any UI framework,
so linking against the security framework

00:22:20.200 --> 00:22:25.200
doesn't pull in UI code into your
application if it didn't already have it.

00:22:25.320 --> 00:22:28.910
But if you're calling into
security framework calls,

00:22:29.030 --> 00:22:33.420
we might bring up UI through this
application that gets run in the

00:22:33.420 --> 00:22:39.200
background called the security agent,
which basically is our way of doing

00:22:39.200 --> 00:22:42.190
secure interaction with the user.

00:22:42.200 --> 00:22:46.230
So we, the security framework actually
talks to the security server,

00:22:46.230 --> 00:22:50.340
which is a background process that's
always running on your machine,

00:22:50.340 --> 00:22:54.200
which manages any persistent state about,
you know,

00:22:54.200 --> 00:22:54.200
your keychains and things like that.

00:22:54.200 --> 00:22:55.200
So you can actually run it.

00:22:55.200 --> 00:23:00.700
And the security server can launch
the security agent on behalf of

00:23:00.700 --> 00:23:05.960
the user if your application is
part of a GUI-enabled session.

00:23:06.200 --> 00:23:08.200
So the security server
knows this magically.

00:23:08.200 --> 00:23:12.410
Basically, if you SSH into your machine
and you do something that

00:23:12.410 --> 00:23:16.630
would normally require a UI,
it won't happen because, you know,

00:23:16.740 --> 00:23:21.180
that SSH session is not part of a
login session that can put up GUI.

00:23:21.300 --> 00:23:23.300
So if your process was
launched by system startup,

00:23:23.300 --> 00:23:24.190
you could do that.

00:23:24.200 --> 00:23:27.650
But if it was launched by system
starter or by some low-level demon,

00:23:27.650 --> 00:23:29.200
it's not going to put up UI.

00:23:29.200 --> 00:23:32.200
The only way it's going to put up
UI is if it was launched somehow by

00:23:32.210 --> 00:23:35.390
the Windows server or a child of the
Windows server like the Finder or

00:23:35.390 --> 00:23:38.110
if you launched it from terminal,
it would still bring

00:23:38.110 --> 00:23:39.200
up UI in that session.

00:23:39.200 --> 00:23:44.300
And now with multiple users in Panther,
which are the fast user switching,

00:23:44.340 --> 00:23:47.360
you know,
there can be multiple GUI sessions

00:23:47.360 --> 00:23:50.730
at a given point in time,
but it'll bring up the UI in

00:23:50.820 --> 00:23:53.200
the appropriate user session.

00:23:55.610 --> 00:23:59.360
Unless you turn off user interaction,
which there's a call at both in the

00:23:59.450 --> 00:24:02.740
Keychain Manager layer and in the
Sec layer to turn that on and off.

00:24:02.970 --> 00:24:05.980
And if you're using authorization API,
it's actually every time you

00:24:05.980 --> 00:24:08.600
call an authorization call,
there's a flag saying, you know,

00:24:08.600 --> 00:24:10.700
do I want to allow user
interaction this time?

00:24:10.700 --> 00:24:13.100
So as a developer,
you still have the option

00:24:13.170 --> 00:24:16.740
to override to turn it off,
but you can't turn it on in a session

00:24:16.760 --> 00:24:19.430
that wouldn't otherwise be able to do UI.

00:24:21.900 --> 00:24:26.220
Some of the advantages of a Sec Keychain:
If you have an app

00:24:26.220 --> 00:24:28.740
using Keychain Manager,
it's all good.

00:24:28.740 --> 00:24:30.070
You probably don't have to transition.

00:24:30.120 --> 00:24:33.650
But if you're writing a new app,
I'd highly recommend you actually use

00:24:33.650 --> 00:24:36.860
the Sec Keychain interfaces versus
the Keychain Manager interfaces,

00:24:36.960 --> 00:24:37.840
and here's why.

00:24:37.900 --> 00:24:42.890
The Sec Keychain interfaces support
all different application environments.

00:24:42.890 --> 00:24:45.880
So you can use it in a Carbon app,
you can use it in a Cocoa app,

00:24:45.910 --> 00:24:49.900
you can use it in a tool,
in a command line tool,

00:24:49.900 --> 00:24:52.900
you can use it in a system daemon,
you can use it in just about anything.

00:24:52.920 --> 00:24:55.560
Because there's so little dependencies,
you're not dependent on

00:24:55.560 --> 00:24:56.900
any additional frameworks.

00:24:56.900 --> 00:25:00.850
Also,
the Sec Keychain API is more flexible.

00:25:00.970 --> 00:25:05.760
You can get and set all the
attributes of a single application.

00:25:06.060 --> 00:25:12.900
With the Keychain Manager layer,
you're doing that as individual calls.

00:25:12.900 --> 00:25:16.970
One of the downsides is if for
some reason two apps would be

00:25:16.970 --> 00:25:22.100
manipulating an item at the same time,
you might not get a coherent

00:25:22.110 --> 00:25:23.900
snapshot of that item.

00:25:23.900 --> 00:25:27.800
Because app A might change one attribute
and app B might change another attribute.

00:25:27.860 --> 00:25:30.900
You'd end up with an item
that doesn't make sense.

00:25:30.960 --> 00:25:32.910
If you're using the Sec APIs when
you're manipulating an object,

00:25:32.910 --> 00:25:33.900
you can do it all in one call.

00:25:33.900 --> 00:25:40.490
So it's an atomic modification
or an atomic add or remove.

00:25:41.030 --> 00:25:47.350
And finally, well actually not finally,
but one more important thing is that

00:25:47.430 --> 00:25:54.830
both APIs have access control support
as far as the user will be prompted

00:25:54.980 --> 00:26:04.760
to update the ACL of the item if the
current access controller doesn't let a

00:26:04.770 --> 00:26:05.950
particular application access that item.

00:26:06.430 --> 00:26:10.140
The Sec layer lets you specify
an initial access control list

00:26:10.200 --> 00:26:12.630
that's different from the default.

00:26:12.660 --> 00:26:15.590
The default access control list
that we put in every item you

00:26:15.770 --> 00:26:27.130
create using the Keychain API is the
current application can modify and

00:26:27.130 --> 00:26:27.130
access that item without warning.

00:26:27.610 --> 00:26:31.520
If you, for example,
had an application and you have some

00:26:31.560 --> 00:26:36.240
background process that runs that
also needs to access that same item,

00:26:36.240 --> 00:26:38.600
using the Sec layer,
you can actually set up an access control

00:26:38.600 --> 00:26:42.730
list that allows both of those to access
the item without warning initially.

00:26:42.740 --> 00:26:44.940
So the user would never get a
dialogue in his face saying,

00:26:44.940 --> 00:26:47.810
you know,
do you want to allow application X or,

00:26:47.890 --> 00:26:52.340
you know, my background faceless
process X to access this item.

00:26:52.340 --> 00:26:56.810
So that's an advantage of the Sec APIs is
that you can actually do that.

00:26:56.870 --> 00:27:01.800
And last but not least,
system keychain support,

00:27:01.800 --> 00:27:06.240
which is new in Panther,
and internally at least a lot of

00:27:06.330 --> 00:27:07.750
people have been asking us for this.

00:27:07.800 --> 00:27:11.800
And I'm sure that some of you
might find a need for this too,

00:27:11.800 --> 00:27:16.800
which is basically, rather than,
if you have a system service

00:27:16.800 --> 00:27:20.800
that somehow needs a password,
for example, PPP,

00:27:20.800 --> 00:27:24.800
if it's not configured for a particular
user but for your machine as a whole,

00:27:24.800 --> 00:27:28.200
when your machine boots,
it needs to make, let's say,

00:27:28.200 --> 00:27:31.240
a VPN connection to somewhere,
but you want to store that password

00:27:31.240 --> 00:27:32.800
for the VPN connection somewhere.

00:27:32.800 --> 00:27:36.800
Well, if there's no user logged in,
you don't have a keychain unlocked yet.

00:27:36.800 --> 00:27:39.790
Well, that's where we introduced
system keychains.

00:27:39.810 --> 00:27:44.040
So this is a way that you can use
the same keychain APIs that we've

00:27:44.040 --> 00:27:48.800
always had from a system daemon,
and it actually,

00:27:48.800 --> 00:27:49.800
we automatically detect whether
your system is logged in or not.

00:27:49.800 --> 00:27:50.340
So this is a way that you can use
the same keychain APIs that we've

00:27:50.340 --> 00:27:50.800
always had from a system daemon,
and it actually,

00:27:50.800 --> 00:27:50.800
we automatically detect whether
your system is logged in or not.

00:27:50.800 --> 00:27:55.730
a user processor system daemon,
and there are APIs you can override it,

00:27:55.730 --> 00:27:58.480
so you can actually switch
explicitly to be a system daemon.

00:27:58.530 --> 00:28:01.340
If you were started from
a regular user session,

00:28:01.340 --> 00:28:04.260
you can say, "Well, no,
I'd want to be -- I want to access

00:28:04.260 --> 00:28:08.600
the system keychains instead." But it
lets you store secrets that are

00:28:08.600 --> 00:28:11.420
available as soon as the machine boots.

00:28:11.550 --> 00:28:16.110
The way the system keychain is locked
and unlocked is currently there's

00:28:16.120 --> 00:28:20.780
basically a root-only readable file
containing a random generated key

00:28:20.800 --> 00:28:22.500
that unlocks the system keychain.

00:28:22.500 --> 00:28:26.500
So you need root access to the machine to
gain access to the secrets in this file.

00:28:26.500 --> 00:28:28.850
In the future,
we might improve this mechanism

00:28:28.920 --> 00:28:31.880
and add support for things like
you have to have a hardware key in

00:28:32.010 --> 00:28:35.370
the machine when you boot to unlock
the system keychain or whatnot.

00:28:35.500 --> 00:28:39.500
The main thing is you as an app
writer don't have to worry about it,

00:28:39.500 --> 00:28:41.500
and it sure is a lot better than just,
you know,

00:28:41.500 --> 00:28:46.370
XORing your password with FF and
writing it to some file on the disk.

00:28:47.690 --> 00:28:48.780
So, it's there.

00:28:48.800 --> 00:28:50.560
If you need it,
you should probably be using it.

00:28:50.620 --> 00:28:53.980
Basically, if your app does
anything with a password,

00:28:54.040 --> 00:28:57.600
you should give the user the option to
store that password in the Keychain.

00:28:57.740 --> 00:29:00.910
That's pretty much the deal on that.

00:29:01.620 --> 00:29:06.430
So, back to the main meat of the session,
which are certificates.

00:29:06.500 --> 00:29:09.820
So,
I guess I already asked this question.

00:29:09.820 --> 00:29:11.660
Most of you already know
what an X5 and insert is,

00:29:11.730 --> 00:29:13.500
so I'll kind of skip
through this quickly.

00:29:13.500 --> 00:29:17.960
Certificate consists of a public key
and a number of fixed attributes,

00:29:18.030 --> 00:29:21.980
the most important one being the subject,
which is, you know,

00:29:21.980 --> 00:29:26.080
who does this certificate pertain to,
and that contains a number

00:29:26.080 --> 00:29:29.660
of fields like X500 name,
which is this name based

00:29:29.660 --> 00:29:33.910
out of different components,
which can contain your common name,

00:29:33.910 --> 00:29:37.500
your organization,
all these different fields.

00:29:37.500 --> 00:29:40.030
And an issuer,
which is just like the subject,

00:29:40.060 --> 00:29:43.330
is an X500 name, which is, well,
who is the issuer?

00:29:43.580 --> 00:29:45.500
And an issuer is the person who issued
this certificate to this person.

00:29:45.500 --> 00:29:48.250
And in addition to the issuer,
there's a serial number

00:29:48.250 --> 00:29:50.670
and some other things,
and there's some validity

00:29:50.670 --> 00:29:53.500
information in the cert,
like from when to when is it valid,

00:29:53.500 --> 00:29:55.830
and there's a couple other attributes.

00:29:56.170 --> 00:29:58.470
In addition to attributes,
there can be one or more

00:29:58.470 --> 00:30:01.570
extensions in a certificate,
and the extensions fall

00:30:01.570 --> 00:30:03.170
apart into two categories.

00:30:03.270 --> 00:30:08.100
There's a flag in an extension that says
whether it's critical or non-critical.

00:30:08.240 --> 00:30:11.690
If you're somehow processing
certificates and you run across

00:30:11.690 --> 00:30:15.100
a non-critical extension and
you have no clue what it is,

00:30:15.100 --> 00:30:17.270
you just, you know, "Oh well,
I don't know what it is,

00:30:17.270 --> 00:30:20.200
that's fine." However,
if you run across an extension marked as

00:30:20.260 --> 00:30:23.540
critical and you have no clue what it is,
you're supposed to not continue

00:30:23.540 --> 00:30:25.100
processing that certificate.

00:30:25.100 --> 00:30:27.750
You should say, "Well,
this is a critical extension,

00:30:27.750 --> 00:30:30.450
but I don't understand how to parse it,
so I can't deal with

00:30:30.490 --> 00:30:34.060
this." Now fortunately,
our CL module actually supports,

00:30:34.130 --> 00:30:37.930
as far as we know, all the known,
currently documented critical and

00:30:38.010 --> 00:30:40.080
non-critical extensions out there.

00:30:40.190 --> 00:30:43.970
If you find any, you know,
weird or new extensions that

00:30:43.970 --> 00:30:47.370
you think we need to support,
please let us know again in the

00:30:47.370 --> 00:30:51.630
feedback forum or on our mailing list,
and we'll be sure to add support

00:30:51.730 --> 00:30:54.100
for that in a future release.

00:30:54.100 --> 00:30:57.590
And then finally,
a public key certificate contains a

00:30:57.590 --> 00:31:02.670
signature of all of the above fields,
and that signature is made

00:31:02.670 --> 00:31:06.030
using the issuer's private key.

00:31:06.200 --> 00:31:11.030
So the issuing certificate actually signs
the subject certificate in question.

00:31:13.530 --> 00:31:17.490
So, like I said,
each certificate is signed by its issuer,

00:31:17.490 --> 00:31:21.100
which basically means you can
have a chain of certificates.

00:31:21.100 --> 00:31:23.060
You have a certificate,
a leaf certificate,

00:31:23.110 --> 00:31:24.940
the leaf certificate is
signed by its issuer,

00:31:24.940 --> 00:31:27.500
the issuing certificate might
be signed by its issuer,

00:31:27.500 --> 00:31:28.780
and that keeps going forever.

00:31:28.990 --> 00:31:29.670
Well, no.

00:31:29.670 --> 00:31:33.590
It actually stops at some point
because you end up with a certificate

00:31:33.680 --> 00:31:35.500
that has itself as its issuer.

00:31:35.500 --> 00:31:37.300
So it's signed by itself.

00:31:37.640 --> 00:31:41.530
Well, that signature doesn't really
mean much because anyone can make

00:31:41.580 --> 00:31:43.600
a certificate signed by itself.

00:31:43.600 --> 00:31:46.100
Because I can just generate a
public key or in a private key,

00:31:46.390 --> 00:31:49.590
create a certificate, and sign it.

00:31:49.700 --> 00:31:50.480
Well, what's the problem there?

00:31:50.620 --> 00:31:54.800
Well, the only way to trust a
self-signed certificate is by

00:31:54.840 --> 00:32:00.960
predetermining trust for it,
or by trusting it by prior arrangement.

00:32:01.080 --> 00:32:04.520
And we do that through this thing
called the RIDCERT database.

00:32:04.710 --> 00:32:08.130
On Mac OS X,
the RIDCERT database is in a file

00:32:08.240 --> 00:32:14.300
called System Library X509 Anchors,
which, incidentally, is a keychain file.

00:32:14.370 --> 00:32:16.700
Or, if you want to look at
it at a lower level,

00:32:16.700 --> 00:32:23.070
it's actually a CSSM DB file
managed by the Datastore library.

00:32:24.270 --> 00:32:28.570
So that's the Root Certificate Database,
and that basically contains all

00:32:28.660 --> 00:32:34.580
the root certificates that are
commonly used today by Verisign,

00:32:34.580 --> 00:32:39.190
Thought, all the different root
certs that are needed.

00:32:39.210 --> 00:32:44.120
Now, if for some reason you have your
own local CA at your institution

00:32:44.120 --> 00:32:48.020
or whatever it is you have,
you can add new root certs

00:32:48.020 --> 00:32:50.060
to the Root Cert Database.

00:32:50.350 --> 00:32:54.680
To do that,
you can actually use just Keychain

00:32:54.680 --> 00:32:57.990
Access or our command line tool,
which is new in

00:32:58.190 --> 00:33:01.840
New in Panther, called Security,
which actually lets you manipulate

00:33:01.840 --> 00:33:04.100
keychains and other CDSA functionality.

00:33:04.100 --> 00:33:08.970
And normally you'd need
administrator access to do that.

00:33:09.140 --> 00:33:11.900
So if you're using Keychain access,
you'll get a dialog asking you

00:33:11.900 --> 00:33:13.080
to authenticate as administrator.

00:33:13.180 --> 00:33:16.100
If you're using the command line tool,
you'd have to run it as root.

00:33:16.280 --> 00:33:20.140
So the RootCert database
is actually machine-wide,

00:33:20.180 --> 00:33:24.100
so that's like all the RootCerts that all
the users in that machine would trust.

00:33:24.100 --> 00:33:27.880
As of today, we don't have support yet
for per-user RootCerts,

00:33:27.880 --> 00:33:33.290
but that's definitely something
we're looking into for the future.

00:33:34.590 --> 00:33:40.200
So, I want to give a quick example
of how SSL uses certificates,

00:33:40.400 --> 00:33:43.140
and I'm not going to go,
to make it not too complicated,

00:33:43.140 --> 00:33:46.250
I'm just going to do authenticating
the server to the client,

00:33:46.350 --> 00:33:47.960
not authenticating the
client to the server,

00:33:48.010 --> 00:33:51.200
which is something we support.

00:33:51.460 --> 00:33:54.400
So first the client
connects to the server.

00:33:54.550 --> 00:33:58.070
Server responds with a bunch of stuff,
which one of the things that's

00:33:58.070 --> 00:34:01.700
included in that response
is one or more certificates.

00:34:02.410 --> 00:34:07.700
The client then verifies and
constructs a certificate chain.

00:34:07.700 --> 00:34:11.300
So it takes a certificate,
looks for the issuer of the certificate,

00:34:11.300 --> 00:34:15.910
and it's either in the list of
certificates provided by the server,

00:34:15.910 --> 00:34:18.300
or it's in one of the
user's keychains already,

00:34:18.300 --> 00:34:21.240
or somewhere on the machine,
my quad to LDAP databases or whatever,

00:34:21.240 --> 00:34:23.300
to figure out where
those certificates are.

00:34:23.300 --> 00:34:28.200
So it builds this chain,
and then if the chain itself is valid,

00:34:28.200 --> 00:34:34.300
the final step is to actually see if the
root of that chain is already trusted.

00:34:34.300 --> 00:34:38.770
And the way we do that is to check if
it's actually in this X.509 anchors file,

00:34:38.850 --> 00:34:42.300
or a root cert database, and if it's not,
then well,

00:34:42.300 --> 00:34:46.200
unfortunately the chain can't be trusted,
because you can't trust a cert

00:34:46.290 --> 00:34:51.450
that's self-signed unless you've
previously agreed to trust it.

00:34:52.100 --> 00:35:54.500
[Transcript missing]

00:35:54.760 --> 00:35:58.020
So, depending on what you're
using the certificate for,

00:35:58.020 --> 00:36:02.820
the policy might state some additional
requirements on that certificate.

00:36:02.860 --> 00:36:06.420
And this is exactly what our
trust policy modules encapsulate.

00:36:06.540 --> 00:36:09.260
So they'll actually go and do
this additional check for you.

00:36:09.300 --> 00:36:13.790
Now obviously the application has to know
what additional information to provide.

00:36:13.900 --> 00:36:17.820
So, a browser, or actually something
using Secure Transport,

00:36:17.850 --> 00:36:21.680
will actually provide the
URL to the trust layer to say,

00:36:21.680 --> 00:36:24.570
well, you know, check this field as well.

00:36:24.600 --> 00:36:28.490
So...

00:36:31.330 --> 00:36:37.810
So, talk about Sec Certificate itself,
which is the Sec or security

00:36:37.900 --> 00:36:41.480
low-level wrapper for a certificate.

00:36:41.840 --> 00:36:46.220
It's like all the other Sec things,
they're, you know, C objects,

00:36:46.310 --> 00:36:49.300
just like CF things,
so it has a number of operations.

00:36:49.300 --> 00:36:53.290
You can import and export
raw certificate data.

00:36:53.590 --> 00:36:56.190
Currently, Sec Certificate only
supports X509 certificates,

00:36:56.330 --> 00:37:01.300
but that's because all the,
the only CL and TP we ship are X509.

00:37:01.300 --> 00:37:03.680
But if you were to write
a CL or TP supporting

00:37:03.770 --> 00:37:07.440
different certificate formats,
then that would automatically

00:37:07.440 --> 00:37:11.550
start being supported because of
the plugin architecture of CDSA.

00:37:12.840 --> 00:37:17.140
You can store and retrieve
Sec certificates from a Keychain if

00:37:17.140 --> 00:37:22.270
you Sec certificate has an add to
Keychain method that you can call.

00:37:22.530 --> 00:37:26.810
You can use a CL module to parse
the certificate if you wanted

00:37:26.810 --> 00:37:31.530
to syntactically pull it apart,
because you can use the bridging

00:37:31.530 --> 00:37:34.930
down to CSSM to actually get a
certificate library module and pull

00:37:35.150 --> 00:37:37.500
apart the certificate in fields.

00:37:37.630 --> 00:37:40.630
And you can display it using
an SF certificate view,

00:37:40.630 --> 00:37:43.290
which is part of the security interface.

00:37:44.260 --> 00:37:47.530
And finally,
rather than calling directly into the TP,

00:37:47.560 --> 00:37:51.420
which you can do if you really want to,
we actually recommend you

00:37:51.420 --> 00:37:52.800
use SecTrust for that.

00:37:52.880 --> 00:37:58.440
SecTrust actually behaves as a
wrapper for using the trust policy

00:37:58.520 --> 00:38:02.000
module to evaluate the certificate,
but it adds some

00:38:02.080 --> 00:38:06.150
additional functionality,
which I'll go into a little bit later.

00:38:07.920 --> 00:38:14.620
Secure Transport expects you
to pass in certificates and let

00:38:14.620 --> 00:38:17.930
you get at the certificates that
are a result of the connection,

00:38:18.030 --> 00:38:20.800
which we'll show you a little
bit later how that works.

00:38:20.800 --> 00:38:24.770
They're used in SecTrust, obviously,
because SecTrust deals

00:38:24.770 --> 00:38:26.800
with trust of certificates.

00:38:26.800 --> 00:38:29.130
And they're actually used in identities,
which,

00:38:29.150 --> 00:38:32.910
if you don't remember what those were,
an identity is actually an

00:38:32.970 --> 00:38:35.800
object that represents a
certificate and a private key.

00:38:35.800 --> 00:38:39.390
So the certificate
component of the identity is

00:38:39.400 --> 00:38:41.840
represented by SecCertificate.

00:38:42.320 --> 00:38:44.040
Certificates don't have access control.

00:38:44.060 --> 00:38:45.290
Wait, isn't that a bad thing?

00:38:45.450 --> 00:38:49.230
Well, no,
because certificates are public.

00:38:49.550 --> 00:38:51.810
They're public key certificates,
and there's nothing in a

00:38:51.810 --> 00:38:52.780
certificate that's secret.

00:38:52.960 --> 00:38:55.550
And in fact, you know,
you can't tamper with a

00:38:55.790 --> 00:38:59.700
certificate and still have it be,
still have it verified correctly.

00:38:59.700 --> 00:39:02.800
So you don't need to
protect certificates.

00:39:02.800 --> 00:39:05.410
The only thing you can do by
not having access control on

00:39:05.410 --> 00:39:07.040
them is delete a certificate.

00:39:07.110 --> 00:39:14.070
So, but that level of access control
is provided by the file system.

00:39:15.330 --> 00:39:19.180
Secure Transport, SSL,
and Keychain storage operations.

00:39:45.200 --> 00:39:48.490
So, Secure Identity is not an
object that exists in a Keychain

00:39:48.490 --> 00:39:50.150
database in and of itself.

00:39:50.220 --> 00:39:53.300
It's actually constructed
on the fly by looking for a

00:39:53.300 --> 00:39:56.200
certificate and a key that match.

00:39:56.210 --> 00:40:02.150
And the construction of Sec Identity
is done by looking for a certificate

00:40:02.300 --> 00:40:05.200
through all your Keychains and looking
for a key through all your Keychains.

00:40:05.200 --> 00:40:08.110
So that actually means that the
certificate and the key don't even have

00:40:08.110 --> 00:40:14.200
to be in the same Keychain or in the
same place for them to form an identity.

00:40:14.600 --> 00:41:00.800
[Transcript missing]

00:41:00.980 --> 00:41:03.920
But if you get multiple matches,
you should probably let the user

00:41:03.920 --> 00:41:05.900
pick which one he wants to use.

00:41:05.980 --> 00:41:10.910
And rely on us to do access control,
because the user can set his

00:41:10.910 --> 00:41:15.770
preferences any way he wants in
Keychain Access as to how much,

00:41:16.350 --> 00:41:21.820
which apps and how can
access the private key,

00:41:21.820 --> 00:41:21.820
so you don't need to
worry about that part.

00:41:23.130 --> 00:41:26.210
Some uses of Sec identities.

00:41:26.580 --> 00:41:31.720
Secure Transport uses identities
in the client-side authentication.

00:41:31.840 --> 00:41:35.740
802.1X is actually new in Panther,
which I'm sure you've all

00:41:35.740 --> 00:41:37.000
seen the big new session.

00:41:37.000 --> 00:41:39.950
It's like, "Yay,
we're adding 802.1X." Well,

00:41:40.410 --> 00:41:47.630
that's actually authentication over IP,
which is both for airport

00:41:47.630 --> 00:41:47.630
and for wired networks.

00:41:47.830 --> 00:41:51.200
And one of the ways of
authenticating to the server

00:41:51.200 --> 00:41:54.580
with 802.1X is using identities.

00:41:55.150 --> 00:42:00.160
And there's future applications coming,
one being, for example, S/MIME,

00:42:00.540 --> 00:42:01.500
secure email.

00:42:01.500 --> 00:42:06.090
The S/MIME, we have an S/MIME SPI,
which it is an API yet

00:42:06.100 --> 00:42:09.060
that we're working on,
and we encourage you to take a

00:42:09.060 --> 00:42:12.930
look at it if you're planning
on using our S/MIME APIs in the

00:42:12.930 --> 00:42:15.500
future and give us feedback,
what you think.

00:42:15.500 --> 00:42:19.620
And the SPI code is actually open source,
so you can go to the

00:42:19.620 --> 00:42:22.300
Darwin website and download that.

00:42:22.300 --> 00:42:25.500
The project is Security NSS S/MIME.

00:42:25.530 --> 00:42:29.120
It's actually based on
the Netscape S/MIME code,

00:42:29.120 --> 00:42:33.480
but we're using our CDSA-based
crypto stack instead of what

00:42:33.480 --> 00:42:36.270
Netscape was using themselves.

00:42:36.320 --> 00:42:38.940
So you get all the advantage
of access control lists and

00:42:38.940 --> 00:42:40.600
all these things that we have.

00:42:44.020 --> 00:42:50.440
So, going to policies,
I talked a bit about

00:42:50.440 --> 00:42:52.330
trust policy modules.

00:42:52.360 --> 00:42:57.390
And so a trust policy module can
actually support one or more policies.

00:42:57.400 --> 00:42:59.920
And I've mentioned this
a couple of times before,

00:43:00.420 --> 00:43:07.640
and policy basically is the set of rules
that decides whether or not a particular

00:43:07.640 --> 00:43:10.300
chain of certificates will be trusted.

00:43:10.850 --> 00:43:14.200
And like I said before,
there's an SSL policy,

00:43:14.200 --> 00:43:18.110
there's S/MIME signing policy,
there will be an encryption policy.

00:43:18.150 --> 00:43:22.560
There's a separate policy in SSL actually
for client versus server auth.

00:43:22.800 --> 00:43:26.210
You could have a code signing policy,
which might have different

00:43:26.480 --> 00:43:28.800
requirements on the leaf certificate.

00:43:28.800 --> 00:43:31.790
It can't just be a random
email certificate someone got,

00:43:31.790 --> 00:43:36.640
but it might have to be, in the case of,
for example, VeriSign, they have class 1,

00:43:36.710 --> 00:43:37.800
class 2, class 3.

00:43:37.800 --> 00:43:40.590
They have different certificates,
which for them to issue

00:43:40.590 --> 00:43:43.550
that certificate to you,
you have to provide different levels

00:43:43.580 --> 00:43:46.800
of proof of who you are before
they'll issue that certificate.

00:43:46.800 --> 00:43:49.240
Well,
for a cert to be valid for code signing,

00:43:49.240 --> 00:43:52.960
you probably want to require a higher
level of proof that this developer

00:43:53.040 --> 00:43:54.950
really is who they claim to be.

00:43:55.600 --> 00:44:01.140
And unlike an SSL or an SMIME cert,
there should probably never be

00:44:01.140 --> 00:44:05.660
an automated way of trusting a
code signing cert without at least

00:44:05.660 --> 00:44:07.500
having shown it once to the user.

00:44:07.730 --> 00:44:14.500
Because even if this developer is
registered and it's a real developer,

00:44:14.500 --> 00:44:17.750
the user still might want to decide
whether or not he wants to install

00:44:17.750 --> 00:44:19.430
software from this developer.

00:44:20.320 --> 00:44:23.490
So, some policies take parameters
like SSL and SMIME,

00:44:23.490 --> 00:44:26.340
and the parameters depend
on what the policy is.

00:44:26.500 --> 00:44:29.540
And typically your application
should know what that parameter is,

00:44:29.660 --> 00:44:33.570
like in SMIME it's the email address,
in SSL it's the URL.

00:44:35.080 --> 00:44:39.260
So, SecTrust deals with policies
and certificates and all these

00:44:39.260 --> 00:44:42.270
different things and kind of wraps
it up in this neat little object

00:44:42.400 --> 00:44:46.810
that really makes your life a lot
easier when trying to determine

00:44:46.830 --> 00:44:48.950
whether a certificate is trusted.

00:44:49.390 --> 00:44:53.880
So it validates the certificate,
it validates the certificate

00:44:53.880 --> 00:44:55.600
using the policy.

00:44:55.840 --> 00:44:59.330
Now in addition to that,
it established the user trust.

00:44:59.470 --> 00:45:03.890
So go back to the code signing example.

00:45:04.120 --> 00:45:08.000
The first time the user sees
code from a particular developer,

00:45:08.000 --> 00:45:10.720
they might not-- you'd
preferably like to display the

00:45:10.720 --> 00:45:12.780
certificate to the user and say,
well,

00:45:12.780 --> 00:45:14.860
do you really want to trust this thing?

00:45:15.010 --> 00:45:15.920
You're installing Flash.

00:45:15.970 --> 00:45:21.340
Do you really want to trust the
software signed by company XYZ?

00:45:21.800 --> 00:45:24.350
The user can then decide, "Well, sure,
go ahead, do it.

00:45:24.520 --> 00:45:29.630
I'm fine with installing the
software." The user can actually say,

00:45:29.630 --> 00:45:31.920
"Well, no, I don't want to,
and I never want to install any

00:45:31.980 --> 00:45:34.620
software signed by this company
because I don't trust them,

00:45:34.830 --> 00:45:37.590
and I think there's probably a virus
or something." Or they might say,

00:45:37.720 --> 00:45:39.010
"Yeah, sure, go ahead.

00:45:39.110 --> 00:45:39.710
It's Apple.

00:45:39.750 --> 00:45:40.670
It's all good.

00:45:40.760 --> 00:45:42.180
Apple software updates signed by Apple.

00:45:42.180 --> 00:45:42.630
It's good.

00:45:42.630 --> 00:45:43.560
Sign them, install them.

00:45:43.690 --> 00:45:49.700
That's fine." That decision that the user
makes is stored as a user trust setting,

00:45:49.700 --> 00:45:54.080
and SecTrust actually manages these
user trust settings in addition to doing

00:45:54.080 --> 00:45:56.890
the regular certificate evaluation.

00:45:57.450 --> 00:46:02.460
SecTrust isn't an actual object that
represents some real world thing,

00:46:02.460 --> 00:46:04.400
it's a workflow object.

00:46:04.400 --> 00:46:07.200
You create one,
stick in the certificates,

00:46:07.200 --> 00:46:10.390
set what policies you want to use,
set some additional parameters,

00:46:10.400 --> 00:46:13.140
attributes, and evaluate it.

00:46:13.400 --> 00:46:16.400
That's pretty much what you do with it.

00:46:16.400 --> 00:46:19.480
In addition to that,
you can actually use it to set these

00:46:19.480 --> 00:46:23.760
user trust parameters and inspect the
user trust parameters on the cert.

00:46:24.990 --> 00:46:29.900
So, when you evaluate SecTrust,
there's a couple of different outcomes.

00:46:29.940 --> 00:46:33.900
It could be, you know,
the certificate's valid, it's all good,

00:46:33.900 --> 00:46:36.900
and if it's valid,
there's actually three possible answers.

00:46:37.050 --> 00:46:39.980
The answer could be denied,
which means the certificate was valid,

00:46:40.060 --> 00:46:41.900
but the user didn't want to trust it.

00:46:41.900 --> 00:46:45.980
Or it could be, yep, go ahead, proceed,
it's all good, the certificate's valid,

00:46:45.980 --> 00:46:48.070
and the user actually has
previously seen this and they

00:46:48.110 --> 00:46:51.380
decided that they want to always,
you know, continue without bothering them

00:46:51.380 --> 00:46:52.820
when they see the certificate.

00:46:52.900 --> 00:46:56.900
Or it could be, well, we don't know yet.

00:46:56.900 --> 00:46:58.520
We haven't actually displayed
this to the user and,

00:46:58.540 --> 00:46:59.860
you know, he never really decided.

00:46:59.900 --> 00:47:02.850
And finally,
it could be the user decided to,

00:47:02.900 --> 00:47:07.980
you know, always ask me when you get this
certificate because I want to see each

00:47:07.980 --> 00:47:10.900
time something happens that uses this.

00:47:11.360 --> 00:47:15.690
There can also be errors
during the evaluation.

00:47:16.020 --> 00:47:18.890
Now, those errors are actually
divided into two categories.

00:47:18.900 --> 00:47:20.900
You have recoverable
errors and fatal errors.

00:47:21.030 --> 00:47:22.900
Fatal errors means, you know,
something was wrong and

00:47:22.900 --> 00:47:23.900
there's no way to fix it.

00:47:23.920 --> 00:47:26.900
You know, root cert was missing.

00:47:26.900 --> 00:47:29.560
There was like, you know,
there were actually invalid signatures

00:47:29.560 --> 00:47:30.840
in the chain or something like that.

00:47:31.020 --> 00:47:35.410
Well, recoverable errors are something
we've had to add because people

00:47:35.410 --> 00:47:39.890
using certs for servers didn't
really update their certs in time.

00:47:39.910 --> 00:47:41.900
Remember earlier on we talked
about what's in a cert.

00:47:41.900 --> 00:47:43.860
Well,
one of the things is the validity date.

00:47:43.900 --> 00:47:48.130
Well, it turns out that, you know,
20 or 30% of the websites out there

00:47:48.190 --> 00:47:49.900
that use SSL use expired root certs.

00:47:49.900 --> 00:47:54.330
And it's like, well, according to X509,
if you, you know, read these books,

00:47:54.350 --> 00:47:56.650
it's like, well, okay,
root certs expired.

00:47:57.100 --> 00:47:57.800
Sorry, you can't connect.

00:47:58.150 --> 00:48:01.250
Well, it's kind of annoying if you
can't connect to Amazon.com

00:48:01.250 --> 00:48:02.890
with Apple's browser,
so.

00:48:03.650 --> 00:48:07.870
There needs to be a way for you to say,
"Well, okay, the root cert was expired,

00:48:07.980 --> 00:48:08.740
but that's okay.

00:48:08.740 --> 00:48:12.300
Go ahead anyway." And that's
what a recoverable error is.

00:48:12.360 --> 00:48:15.140
It's basically,
if you get a recoverable failure,

00:48:15.140 --> 00:48:17.260
you can actually tell SecTrust, "Well,
you know what?

00:48:17.350 --> 00:48:18.920
If root certs are expired, that's okay.

00:48:19.000 --> 00:48:21.650
Go ahead." So you set this parameter,
you devaluate it again,

00:48:21.650 --> 00:48:26.890
and if that was the only thing wrong,
it would say, "Okay, now it's good."

00:48:27.110 --> 00:48:31.500
We do encourage you to not just go and,
you know, let's always set these things.

00:48:31.500 --> 00:48:34.400
We do encourage you to actually,
you know, tell the user or warn somewhere

00:48:34.400 --> 00:48:36.000
there is something wrong.

00:48:36.260 --> 00:48:40.000
But, you know, okay,
from now on we'll just go on and,

00:48:40.000 --> 00:48:42.330
you know, not worry about the
fact that it's expired.

00:48:42.520 --> 00:48:46.570
But you shouldn't just blindly
turn off all these things because

00:48:47.000 --> 00:48:49.650
there are a couple of different
options and you shouldn't,

00:48:49.650 --> 00:48:53.250
you should, in your app,
try and be as strict as possible,

00:48:53.250 --> 00:48:55.990
but allow for, you know, real world use.

00:48:57.760 --> 00:49:00.140
There are some additional
results on the side.

00:49:00.220 --> 00:49:02.540
If something goes wrong
during the evaluation,

00:49:02.540 --> 00:49:07.460
you can actually get a detailed
structure of the entire evaluation.

00:49:07.460 --> 00:49:10.180
It will show you details about
each cert in the chain and what

00:49:10.180 --> 00:49:11.700
was right or wrong with those.

00:49:11.700 --> 00:49:14.980
As it happens,
we actually have a UI object to

00:49:15.270 --> 00:49:18.720
display that in a nice way to the user,
because that information

00:49:18.720 --> 00:49:19.700
can be fairly complicated.

00:49:19.700 --> 00:49:25.710
There's actually a UI object that
lets you display these trust results

00:49:25.730 --> 00:49:28.670
coming from a SecTrust object.

00:49:29.380 --> 00:49:36.650
Some of the ingredients you can stick
in to SecTrust before you evaluate it:

00:49:36.820 --> 00:49:38.460
policies, parameters.

00:49:38.460 --> 00:49:41.850
Obviously you have to put in the
certificate you're actually evaluating,

00:49:41.850 --> 00:49:43.740
and you can,
in addition to that certificate,

00:49:43.780 --> 00:49:47.590
add a bunch of helpful certificates
that might not be available

00:49:47.590 --> 00:49:49.290
to the system otherwise.

00:49:49.360 --> 00:49:50.230
They're optional.

00:49:50.230 --> 00:49:52.770
If they're already there in some
keychain or some other place

00:49:52.870 --> 00:49:55.300
where the system can find it,
they're not needed.

00:49:55.300 --> 00:49:58.070
But typically,
like if you connect to a server,

00:49:58.090 --> 00:49:59.280
it'll send you a bunch of certificates.

00:49:59.300 --> 00:50:02.230
You just drop them all in,
and SecTrust will do whatever

00:50:02.340 --> 00:50:03.850
it needs to do with them.

00:50:04.290 --> 00:50:06.430
and like I said,
it'll search any keychains

00:50:06.510 --> 00:50:07.730
for more certificates.

00:50:07.960 --> 00:50:11.340
Now,
if you have a very custom application

00:50:11.340 --> 00:50:15.880
and you don't want to use the system
anchor certificate or root cert database,

00:50:16.000 --> 00:50:18.950
SecTrust actually lets you
specify your own list of anchors.

00:50:19.090 --> 00:50:23.140
So for a particular application,
you only want to trust this one root,

00:50:23.140 --> 00:50:25.160
you can actually pass that
in in SecTrust and say,

00:50:25.160 --> 00:50:29.990
"Well, just only trust this root or this
list of roots." So that's possible.

00:50:31.450 --> 00:50:36.400
The user trust settings are
actually part of SecTrust,

00:50:36.400 --> 00:50:42.530
and that lets you manage the user trust
settings for a particular certificate.

00:50:42.670 --> 00:50:46.360
They're really only useful for
administrative applications.

00:50:46.360 --> 00:50:51.080
You normally don't really need to
manipulate those because the normal way

00:50:51.080 --> 00:50:54.850
you would do it is you'd bring up this
user trust dialog and that actually lets

00:50:54.850 --> 00:50:59.600
the user change their trust settings on
the fly while displaying the certificate.

00:50:59.600 --> 00:51:04.620
These trust settings are actually
per certificate per operation,

00:51:04.620 --> 00:51:08.600
or really per certificate
per policy is what it is.

00:51:08.610 --> 00:51:11.590
So if a certificate is
valid for multiple policies,

00:51:11.590 --> 00:51:15.620
each of those policies could have
a different user trust setting.

00:51:16.690 --> 00:51:20.570
And the four different
values for trust are:

00:51:20.600 --> 00:51:22.920
It's not set, which is the default.

00:51:22.930 --> 00:51:28.630
It can be always ask, always deny,
or always proceed without asking.

00:51:30.150 --> 00:51:33.860
This is what the
Edit User Trust dialog looks like,

00:51:33.860 --> 00:51:35.100
more or less.

00:51:35.100 --> 00:51:38.100
So there's a view of the
certificate in there,

00:51:38.100 --> 00:51:43.090
and you can change all these
different trust settings.

00:51:43.890 --> 00:51:47.540
And now we'd like to demo,
invite Ken up on stage,

00:51:47.570 --> 00:51:51.540
and he's going to show you
exactly how all this works.

00:51:56.540 --> 00:51:57.500
Thanks, Michael.

00:51:57.500 --> 00:52:01.190
The first thing I want to show
you is a brand new web browser

00:52:01.270 --> 00:52:05.450
that was just released this week,
and it's not Safari.

00:52:05.600 --> 00:53:58.000
[Transcript missing]

00:53:59.810 --> 00:54:02.580
That's all well and good,
but as Michael said,

00:54:02.610 --> 00:54:05.990
there's a lot of sites out there
that have some kind of problem.

00:54:06.130 --> 00:54:09.700
So these bad SSL sites,
what happens when you go there?

00:54:09.700 --> 00:54:14.750
Here's one: digitalidverisign.com.

00:54:14.960 --> 00:54:17.700
So I tried to connect to this,
and there's a problem.

00:54:17.700 --> 00:54:22.700
So what I can do is just put up this
panel that tells me what the problem is.

00:54:22.700 --> 00:54:25.700
In this case, there's an untrusted root.

00:54:25.700 --> 00:54:27.700
So why is this root untrusted?

00:54:27.870 --> 00:54:30.700
Oh, it expired in 1999.

00:54:30.700 --> 00:54:30.700
Whoops.

00:54:30.700 --> 00:54:35.540
So I can give the user the option
to go ahead and connect or not.

00:54:35.540 --> 00:54:39.550
In this case, you know,
I don't trust that, so I won't connect.

00:54:39.700 --> 00:54:44.590
Here's another example: authorized.net.

00:54:44.890 --> 00:54:46.700
And there's a problem there, too.

00:54:46.700 --> 00:54:47.700
Let's see.

00:54:47.700 --> 00:54:50.690
Certificate chain not verified
because the root was not found.

00:54:50.700 --> 00:54:52.700
So Michael explained to me that.

00:54:52.700 --> 00:54:56.230
Michael explained that the
only roots that are trusted are

00:54:56.230 --> 00:54:59.700
in that system-wide database,
X509 anchors.

00:54:59.800 --> 00:55:04.460
So let's go and see if I can.

00:55:04.670 --> 00:55:06.490
Add that to my Anchor database.

00:55:06.520 --> 00:55:07.810
I downloaded the cert.

00:55:07.940 --> 00:55:09.590
I've got it sitting out on the desktop.

00:55:09.740 --> 00:55:11.950
So I'll just double click it here.

00:55:13.900 --> 00:55:18.020
And Keychain Access is launched,
and it asked me if I want to

00:55:18.020 --> 00:55:19.920
add this cert to a keychain.

00:55:19.960 --> 00:55:21.430
And I've got a couple
different keychains,

00:55:21.590 --> 00:55:25.180
but again, X.509 Anchors is the root
certificate database,

00:55:25.220 --> 00:55:26.800
so I'll stick it in there.

00:55:26.800 --> 00:55:29.880
Now, because that's managed
as it's owned by root,

00:55:29.880 --> 00:55:33.790
I have to be an admin user on the
system to change that database.

00:55:33.790 --> 00:55:37.540
So I'll go ahead and type
in my password to import it.

00:55:37.800 --> 00:55:41.800
And actually, let's look at the
contents of this keychain.

00:55:41.800 --> 00:55:44.800
We can see all the different
root certs that are in there.

00:55:44.800 --> 00:55:47.720
And sure enough, there's my Entrust cert.

00:55:47.800 --> 00:55:51.510
And I can look at it,
and I can verify the fingerprint,

00:55:51.520 --> 00:55:53.990
and I can see all the fields in it.

00:55:54.170 --> 00:55:57.880
and all the extensions
and its CRL distribution

00:55:57.880 --> 00:56:00.380
points and verify it myself.

00:56:00.650 --> 00:56:05.180
Keychain Access is using that same view
that is available on security interface

00:56:05.540 --> 00:56:07.000
to display the contents of the cert.

00:56:07.000 --> 00:56:10.510
It's just inserted in the window,
much as you'd put it in

00:56:10.510 --> 00:56:12.240
your own application.

00:56:12.430 --> 00:56:17.770
So now that that route is in there,
let's go back here to the web browser.

00:56:17.880 --> 00:56:19.890
Let's try to reload this.

00:56:20.590 --> 00:56:27.090
Well, actually, let's start fresh and
try to go to that site.

00:56:28.140 --> 00:56:30.800
And this time, I can get there.

00:56:30.820 --> 00:56:35.800
And when I look at the actual cert chain,
I see now that it's actually verified

00:56:35.800 --> 00:56:39.170
all the way back to the root,
and it's in there.

00:56:44.420 --> 00:56:49.460
So, how much work was it for me to just
take that sample app and put the

00:56:49.720 --> 00:56:51.800
certificate trust management into it?

00:56:51.800 --> 00:56:55.300
Well, let me show you the
actual source code here.

00:56:55.430 --> 00:56:59.960
I added a method called Evaluate Trust,
and it gets called

00:56:59.960 --> 00:57:01.900
whenever a URL is loaded.

00:57:01.960 --> 00:57:04.970
So I can go off and evaluate the trust.

00:57:05.160 --> 00:57:08.290
I start,
what I want to do is make a trust object,

00:57:08.300 --> 00:57:10.740
a SecTrustRef.

00:57:10.740 --> 00:57:12.570
As Michael explained,
it's a workflow object,

00:57:12.680 --> 00:57:16.420
so I'll be just sort of putting
stuff into it to encapsulate what

00:57:16.420 --> 00:57:19.100
the trust means for this connection.

00:57:19.180 --> 00:57:20.710
I can get a policy ref.

00:57:20.710 --> 00:57:24.470
I've written some code to give
me back the policy for SSL,

00:57:24.640 --> 00:57:28.100
because that's the one
I'm interested in here.

00:57:28.100 --> 00:57:32.100
And then I call
SecTrustCreateWithCertificates.

00:57:32.120 --> 00:57:34.630
So I take the certificates
that I got back from that

00:57:34.630 --> 00:57:36.990
connection in server certs,
and I take the policy

00:57:37.130 --> 00:57:41.100
that I'm interested in,
which is SSL, and I feed them into that,

00:57:41.100 --> 00:57:45.860
and it gives me back a trust
object for that particular policy.

00:57:47.810 --> 00:57:50.800
So once I have the trust object,
I want to evaluate the trust.

00:57:50.900 --> 00:57:54.200
I want to actually make sure that
it verifies to a trusted root and

00:57:54.200 --> 00:57:55.700
that there's no problems with it.

00:57:55.700 --> 00:57:59.700
And the call I made to do
that is SecTrustEvaluate.

00:57:59.700 --> 00:58:04.010
I just pass in the trust object
and I get the trust result back.

00:58:04.570 --> 00:58:06.960
So then I can look at what
that trust result was.

00:58:06.960 --> 00:58:13.350
One of the possible values that it
can return is KSEC trust result deny,

00:58:13.350 --> 00:58:15.230
which means, no, it's just denied.

00:58:15.340 --> 00:58:19.600
The user has said, "Don't ever trust this
cert." So I bail out.

00:58:20.510 --> 00:58:24.360
But if not, they may have also said,
"KSEC, trust, result,

00:58:24.480 --> 00:58:29.290
proceed." So they may have said,
"Always trust this cert, no matter what."

00:58:30.130 --> 00:58:34.490
For that particular policy,
for that trust.

00:58:34.580 --> 00:58:38.830
In that case, I can return and go
ahead and load the page.

00:58:39.380 --> 00:58:43.490
In the case that's interesting,
when we get a recoverable trust

00:58:43.490 --> 00:58:47.160
failure from the evaluation,
we can ask the user what to do,

00:58:47.360 --> 00:58:48.290
and that's real easy.

00:58:48.290 --> 00:58:54.060
Cook up my own message telling
the user what the situation

00:58:54.060 --> 00:58:57.360
is and why they might care,
and then I get a

00:58:57.360 --> 00:58:59.160
SF certificate trust panel.

00:58:59.300 --> 00:59:05.230
This is just a singleton object that
I can grab and then put up a sheet.

00:59:05.230 --> 00:59:09.030
The parameters to put up the sheet
are the window I want to put it

00:59:09.030 --> 00:59:13.290
up on and a selector for what
happens when the user puts it away.

00:59:13.300 --> 00:59:16.030
I pass in the URL so
that I can display it,

00:59:16.030 --> 00:59:20.260
and I pass in the trust because
that's what gets displayed.

00:59:20.290 --> 00:59:23.240
It's got the certificate chain,
and it has all the things that

00:59:23.240 --> 00:59:27.490
will be displayed to the user,
and then my own custom message.

00:59:29.180 --> 00:59:34.280
And if the result was
some other kind of error,

00:59:34.280 --> 00:59:34.280
I can...

00:59:34.470 --> 00:59:36.400
return the flag that says, "No,
don't load the page.

00:59:36.400 --> 00:59:40.560
There was an error." And otherwise,
the page loads and everything's fine.

00:59:40.740 --> 00:59:47.360
So that was basically all it
took to implement Certificate

00:59:47.360 --> 00:59:49.280
Trust in that web browser.

00:59:49.380 --> 00:59:51.940
So with that,
I'd like to hand it back to Michael,

00:59:51.970 --> 00:59:54.230
and thank you.

00:59:58.910 --> 01:00:00.730
Thank you, Ken.

01:00:01.010 --> 01:00:03.900
Well, so just to summarize
what we've done today,

01:00:03.900 --> 01:00:05.120
or we talked about today.

01:00:05.250 --> 01:00:09.800
So there's new and improved
APIs for your development pleasure.

01:00:09.800 --> 01:00:13.760
Most of them have been
available since Jaguar.

01:00:13.780 --> 01:00:15.950
Some of them are new in Panther.

01:00:16.390 --> 01:00:20.300
If you need your app to run
on Mac OS 10.1 or earlier,

01:00:20.300 --> 01:00:23.410
you should stick to the
Carbon Keychain Manager APIs,

01:00:23.410 --> 01:00:26.690
which I doubt very many of you
are still developing for 10.1,

01:00:26.690 --> 01:00:31.970
but if you are,
then that's what you can do,

01:00:31.970 --> 01:00:31.970
and it's there.

01:00:32.480 --> 01:00:34.990
The Sec APIs are easier to
use than the CSSM layer.

01:00:35.210 --> 01:00:38.890
The CSSM layer is fairly
complicated to use,

01:00:38.940 --> 01:00:40.540
but it's very, very flexible.

01:00:40.560 --> 01:00:48.380
And because of our
toll-free bridging to CDSA,

01:00:48.380 --> 01:00:52.350
you can bridge down to that when
you do need the extra flexibility.

01:00:52.360 --> 01:00:57.410
But you don't have to always deal with
the complexity in the simple cases.

01:00:58.100 --> 01:02:15.800
[Transcript missing]

01:02:17.620 --> 01:02:21.600
And avoid micromanaging.

01:02:21.600 --> 01:02:24.080
That's basically what I just said.

01:02:24.080 --> 01:02:28.680
Just use the APIs you need
and use them appropriately.

01:02:28.680 --> 01:02:32.630
And with that, I'd like to bring...

01:02:32.830 --> 01:02:39.510
Craig back on stage.

01:02:39.510 --> 01:02:39.510
We'll go through these little road
map thingies and we'll get to Q&A.

01:02:44.050 --> 01:02:47.480
So the reason why we put roadmap
things on for things that have already

01:02:47.480 --> 01:02:51.080
happened is because you'll get the DVDs,
and we wanted you to be

01:02:51.080 --> 01:02:54.300
able to go back in time,
even though we don't give you

01:02:54.320 --> 01:02:56.220
time machines here at WWDC.

01:03:00.400 --> 01:03:01.600
I'm going to skip past these.

01:03:01.600 --> 01:03:03.680
I'll bring them back up on
the screen while we're doing

01:03:03.680 --> 01:03:05.800
Q&A because we're running long.
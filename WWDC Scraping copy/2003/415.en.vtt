WEBVTT

00:00:26.200 --> 00:00:26.940
Data Exchange.

00:00:26.940 --> 00:00:29.200
So what do we mean by data exchange?

00:00:29.200 --> 00:00:34.400
As Xavier mentioned,
we're talking about in today's

00:00:34.400 --> 00:00:38.560
Mac OS X and earlier Mac OS,
some technologies such

00:00:38.630 --> 00:00:42.460
as the Scrap Manager,
which we've had since 1984

00:00:42.580 --> 00:00:47.120
for doing data exchange,
moving data between

00:00:47.120 --> 00:00:48.810
applications on the clipboard.

00:00:48.820 --> 00:00:53.280
A few years later,
we introduced the Drag Manager,

00:00:53.340 --> 00:00:59.160
which is a similar API in many ways
for moving data between applications,

00:00:59.160 --> 00:01:01.420
but through drag gestures.

00:01:01.580 --> 00:01:05.300
We're also talking today
about the Translation Manager,

00:01:05.350 --> 00:01:09.860
which was also introduced several
years ago and integrated into scrap

00:01:09.930 --> 00:01:14.890
and drag so that translations can be
performed somewhat automatically when

00:01:14.890 --> 00:01:17.620
moving data between applications.

00:01:17.930 --> 00:01:23.140
And all of these technologies are
based on OS type data identifiers,

00:01:23.140 --> 00:01:26.180
four character data identifiers.

00:01:26.320 --> 00:01:29.340
And all of these technologies
have served us very well.

00:01:29.340 --> 00:01:33.890
We've made a lot of strides in user
interface in making it easy for users

00:01:33.890 --> 00:01:36.170
to move their data between applications.

00:01:36.440 --> 00:01:40.690
But there are also some limitations,
some problems, that we would like to

00:01:40.690 --> 00:01:42.700
get past going forward.

00:01:42.700 --> 00:01:47.250
We have a lot of ideas for
enhancing the user experience and

00:01:47.250 --> 00:01:51.280
being able to make applications
work together more seamlessly.

00:01:51.350 --> 00:01:54.560
And we're bumping up
against some problems.

00:01:54.580 --> 00:01:59.520
One is just that the scrap
manager and the drag manager,

00:01:59.520 --> 00:02:03.340
although they have a lot in common for
marshalling a bunch of data together

00:02:03.360 --> 00:02:06.280
to move to another application,
they're separate APIs.

00:02:06.370 --> 00:02:08.100
And so if you want to
support the clipboard,

00:02:08.100 --> 00:02:09.120
you do one thing.

00:02:09.120 --> 00:02:11.000
When you want to add
drag and drop support,

00:02:11.020 --> 00:02:14.060
you have a whole other similar
API that you also have to adopt.

00:02:14.160 --> 00:02:16.230
So it's kind of double the work for you.

00:02:16.260 --> 00:02:17.260
Thank you.

00:02:18.250 --> 00:02:23.310
With the Translation Manager,
it's kind of a difficult API to use.

00:02:23.320 --> 00:02:26.880
The model isn't really quite what
we want for data translation.

00:02:26.880 --> 00:02:30.390
It's handle-based,
so it doesn't really work with core

00:02:30.390 --> 00:02:35.600
foundation collections and so on,
which make memory management much easier.

00:02:35.600 --> 00:02:40.820
And so translation just isn't
really working quite right.

00:02:41.420 --> 00:02:44.360
And then finally,
the whole issue of type identification.

00:02:44.360 --> 00:02:49.500
As I said, the Carbon technologies
tend to be OS type-based.

00:02:49.540 --> 00:02:52.580
Cocoa uses strings.

00:02:52.580 --> 00:02:55.660
NS Pasteboard uses strings
for data identifiers.

00:02:55.660 --> 00:02:58.320
And then there's also MIME types
coming in over the internet.

00:02:58.320 --> 00:02:59.800
There's file name extensions.

00:02:59.820 --> 00:03:02.180
So all these different
ways of identifying types.

00:03:02.180 --> 00:03:06.730
And there's a number of issues with
that that we'd like to resolve.

00:03:06.760 --> 00:03:10.740
So what are the solutions that we're
going to be talking about today?

00:03:11.470 --> 00:03:14.280
The first one is the Carbon Pasteboard.

00:03:14.280 --> 00:03:19.360
This is a new technology, new API,
which is a complete replacement for the

00:03:19.440 --> 00:03:25.700
Scrap Manager and also a replacement
for large pieces of the Drag Manager.

00:03:25.700 --> 00:03:30.100
So it unifies that data model for
moving data around between apps.

00:03:32.120 --> 00:03:34.850
And then there's a new
API called Translation Services,

00:03:34.880 --> 00:03:38.000
which is integrated into the
Carbon Pasteboard and improves the

00:03:38.050 --> 00:03:43.830
translation architecture to make it
easier and faster to work with when

00:03:43.830 --> 00:03:46.270
you're developing your applications.

00:03:46.540 --> 00:03:51.020
And underneath those technologies
is something we're calling

00:03:51.020 --> 00:03:54.610
Uniform Type Identifiers,
which is a new way to describe type

00:03:54.880 --> 00:04:00.960
information and gives a very rich
model for managing type information.

00:04:00.960 --> 00:04:05.170
And it's a foundation both for
translation and Pasteboard,

00:04:05.300 --> 00:04:08.520
as well as future technologies
that we're hoping to introduce.

00:04:08.920 --> 00:04:13.090
So since it's really the foundation,
we're going to talk about

00:04:13.090 --> 00:04:16.920
Uniform Type Identifiers first,
and then later on, my colleague,

00:04:16.920 --> 00:04:20.540
Bryan Prusha, will come up and talk about
Carbon Pasteboard and Translation.

00:04:22.610 --> 00:04:26.280
So in order to help you kind
of understand the concepts of

00:04:26.280 --> 00:04:30.940
Uniform Type Identification,
I wanted to start with an example of,

00:04:30.950 --> 00:04:34.120
I just picked a type, TIFF, TIFF images.

00:04:34.120 --> 00:04:36.240
How do we know what a TIFF image is?

00:04:36.240 --> 00:04:37.180
What's a TIFF?

00:04:37.180 --> 00:04:40.760
I'm not talking about what's the format,
but how do we identify TIFFs?

00:04:41.360 --> 00:04:47.540
And the first one that you
might see is the OS type TIFF.

00:04:47.540 --> 00:04:49.700
It's what a lot of Carbon apps
would work with if they were

00:04:49.700 --> 00:04:54.110
putting TIFF data on the scrap.

00:04:54.790 --> 00:04:55.980
But there's also a MIME type.

00:04:56.030 --> 00:04:59.170
So an image coming in over
the internet would have the

00:04:59.170 --> 00:05:01.100
image slash TIFF MIME type.

00:05:01.130 --> 00:05:04.050
There also happens to be
a file name extension,

00:05:04.050 --> 00:05:04.860
.TIFF.

00:05:04.860 --> 00:05:09.460
There's another file name extension,
.TIFF, which you have to recognize.

00:05:09.460 --> 00:05:12.880
Your app working with TIFF data or
TIFF files has to also recognize

00:05:12.880 --> 00:05:14.500
that file name extension.

00:05:15.280 --> 00:05:21.740
And then data put on the Pasteboard by
a Cocoa application would use a string,

00:05:21.740 --> 00:05:23.190
NSTIFF_PBOARD_TYPE.

00:05:23.270 --> 00:05:27.140
So there's kind of this whole
cloud of type identifiers.

00:05:27.140 --> 00:05:32.940
And currently on Mac OS X and
previous macOSes,

00:05:32.940 --> 00:05:37.840
the only facility really for tying these
together at all was Internet Config,

00:05:37.840 --> 00:05:39.940
which was very internet oriented.

00:05:39.940 --> 00:05:45.040
And its API is also pretty fixed in
terms of the type of the interface.

00:05:45.140 --> 00:05:46.620
So it's not just a type of the interface.

00:05:46.630 --> 00:05:48.200
It's a type of the
interface that supports,

00:05:48.210 --> 00:05:50.370
for instance,
it doesn't understand anything about

00:05:50.700 --> 00:07:50.700
[Transcript missing]

00:07:51.100 --> 00:07:54.150
In the example here,
the identifier that we're

00:07:54.170 --> 00:07:56.490
talking about is public.tiff.

00:07:57.370 --> 00:08:06.610
And this is the Uniform
Type Identifier for the Tiff data type.

00:08:06.610 --> 00:08:06.610
And I like to think of

00:08:06.980 --> 00:08:12.280
The new Type Identifier is the one
true name for the type on the system.

00:08:12.280 --> 00:08:18.280
To use a literary analogy,
it's one name to rule them,

00:08:18.280 --> 00:08:22.400
one name to find them,
one name to bring them

00:08:22.400 --> 00:08:23.840
all in the darkness,
bind them.

00:08:25.700 --> 00:08:31.760
Not only does the Uniform
Type Identifier identify the TIF type,

00:08:31.860 --> 00:08:35.850
but the API makes it very easy
to discover all of the other

00:08:35.970 --> 00:08:37.530
type descriptors for this type.

00:08:37.610 --> 00:08:42.030
It's kind of the nexus
for type description.

00:08:43.590 --> 00:08:45.180
So what about that public thing up front?

00:08:45.180 --> 00:08:49.860
Well, unlike MIME types,
Uniform Type Identifiers don't

00:08:50.050 --> 00:08:57.750
actually express any sort of
type hierarchy in the name.

00:08:57.760 --> 00:09:03.420
So the prefix on any type identifier is,
in general, a reverse DNS name.

00:09:03.420 --> 00:09:06.610
We're reusing the reverse
DNS naming convention that is in

00:09:06.610 --> 00:09:10.740
use in several places on Mac OS X,
such as in bundle identifiers.

00:09:10.740 --> 00:09:16.430
So type identifiers that are proprietary
or associated with a particular

00:09:16.430 --> 00:09:21.140
organization are prefixed with that
organization's reverse domain space.

00:09:21.140 --> 00:09:23.980
However,
there's a lot of types that really aren't

00:09:23.990 --> 00:09:28.170
owned by any particular organization,
and those go in the public domain,

00:09:28.170 --> 00:09:31.130
which is, at this point,
controlled by Apple.

00:09:31.140 --> 00:09:33.830
I encourage you not to use the
public domain and let us put

00:09:33.830 --> 00:09:35.590
things into the public domain.

00:09:35.600 --> 00:09:39.590
Now, because of this naming convention,
I mean, Uniform Type Identifier really

00:09:39.650 --> 00:09:43.900
is just... It's just a string,
and the format is a naming convention

00:09:43.900 --> 00:09:46.020
that we're asking everyone to use.

00:09:46.020 --> 00:09:50.010
If you follow the naming convention,
you're pretty much guaranteed to

00:09:50.010 --> 00:09:52.220
not conflict with anybody else,
A.

00:09:52.220 --> 00:09:57.200
And B, it's a very descriptive
string for what the type is.

00:09:57.200 --> 00:10:02.030
It tells you not only at the end,
it can describe something about the type,

00:10:02.050 --> 00:10:07.050
but it indicates what organization
actually owns and defines that type.

00:10:07.100 --> 00:10:09.840
And so it gives you, as a developer,
when you see some Uniform

00:10:09.840 --> 00:10:13.870
Type... Identifier coming at
you from another application,

00:10:13.880 --> 00:10:17.530
you have an idea of where to go
to learn more about that type.

00:10:19.210 --> 00:10:22.790
Throughout the rest of the talk,
we might be referring to them as UTIs,

00:10:22.850 --> 00:10:24.040
Uniform Type Identifiers.

00:10:24.040 --> 00:10:26.070
That's the abbreviation.

00:10:26.420 --> 00:10:27.700
So what are some examples?

00:10:27.850 --> 00:10:31.830
In addition to public.tiff,
another one is a little more verbose,

00:10:31.830 --> 00:10:34.070
public.utf.plaintext.

00:10:34.230 --> 00:10:36.120
So that's an example of
a very descriptive type.

00:10:36.200 --> 00:10:39.200
You can pretty much look at
that and figure out what it is.

00:10:39.200 --> 00:10:43.500
It's a Unicode UTF-16
encoded chunk of plain text.

00:10:43.500 --> 00:10:45.200
In fact,
this is the type that we encourage

00:10:45.200 --> 00:10:50.030
everyone to start using with the
Carbon Pasteboard when you are sending

00:10:50.030 --> 00:10:53.110
plain text to another application.

00:10:55.020 --> 00:10:55.890
Here's an example.

00:10:55.890 --> 00:11:00.690
Picked, a quick draw picked is something
that is specific to Apple and so

00:11:00.690 --> 00:11:02.900
we put it in the com.apple space.

00:11:02.950 --> 00:11:07.900
Adobe might, they haven't done this,
but just as an example,

00:11:07.900 --> 00:11:13.410
they might for Photoshop documents use
com.adobe.psd or they might use something

00:11:13.430 --> 00:11:15.820
more verbose like Photoshop document.

00:11:18.110 --> 00:11:23.600
So in addition to describing,
identifying types specifically,

00:11:23.610 --> 00:11:27.190
there's something else which the
system has never done before to model

00:11:27.650 --> 00:11:31.440
our understanding of types that we
all have as developers and as users,

00:11:31.440 --> 00:11:35.560
which is what else do we
know about a TIFF as humans?

00:11:35.800 --> 00:11:40.310
We know that it's an image,
and we know that it's a chunk of data.

00:11:40.310 --> 00:11:46.210
And what the Uniform Type Identification
system does is allow types to

00:11:46.240 --> 00:11:48.240
exist in a conformance hierarchy.

00:11:48.290 --> 00:11:52.880
We can declare types as conforming
to supertypes so that even if your

00:11:52.880 --> 00:11:57.680
app doesn't know anything about a
very specific type that you receive,

00:11:57.680 --> 00:12:02.080
you can discover that, oh,
this type is actually a form of text,

00:12:02.080 --> 00:12:04.580
or it's a form, or it's an image.

00:12:05.340 --> 00:12:09.000
That example was somewhat trivial,
but a somewhat more interesting

00:12:09.000 --> 00:12:13.010
example is receiving something that
I'm not even going to pronounce because

00:12:13.010 --> 00:12:16.140
every time I did during rehearsals,
I sounded silly.

00:12:16.140 --> 00:12:19.520
But this is an example of something
you have no idea what it is,

00:12:19.520 --> 00:12:22.780
and it arrives at your application
through a drag gesture,

00:12:22.780 --> 00:12:26.060
say, and you would think you
can't do anything with it.

00:12:26.060 --> 00:12:31.540
But if you happen to be an XML parser,
you can say, is this type XML?

00:12:31.540 --> 00:12:34.500
And it turns out it does conform to XML.

00:12:34.880 --> 00:12:36.980
Or is it even generic text?

00:12:36.990 --> 00:12:40.870
And you can discover from by asking the
system that it does conform to text.

00:12:40.870 --> 00:12:43.270
And so you can actually
work with this data,

00:12:43.270 --> 00:12:46.990
even though you don't know the
complete specifics of its format.

00:12:49.770 --> 00:12:53.400
So in those last few slides, then,
I've just outlined all the major

00:12:53.400 --> 00:12:58.210
goals of Uniform Type Identifiers
to kind of tie together all the

00:12:58.210 --> 00:13:04.410
disparate type identifier spaces,
model conformance between types,

00:13:04.600 --> 00:13:08.570
Enable extensibility through new
third-party type declarations

00:13:08.570 --> 00:13:12.530
without needing a registry or
having to worry about collisions.

00:13:12.720 --> 00:13:16.340
And in support of all that,
just provide a very simple,

00:13:16.340 --> 00:13:20.710
lightweight API,
which is a foundation for any component

00:13:20.780 --> 00:13:24.140
or code that needs to do type management.

00:13:24.610 --> 00:13:28.020
So now I'd like to go back and
just go through the same concepts

00:13:28.100 --> 00:13:32.170
with a little more detail about
some of the API behind this.

00:13:32.490 --> 00:13:36.860
When we talk about OS types
and MIME types and extensions

00:13:36.860 --> 00:13:40.310
and NSPasteboard types,
we needed a word to describe all of that,

00:13:40.380 --> 00:13:42.140
so we just kind of picked this one, tags.

00:13:42.200 --> 00:13:45.450
What we have,
that cloud of blue identifiers

00:13:45.450 --> 00:13:50.120
are all tags that are related to a
particular Uniform Type Identifier.

00:13:50.120 --> 00:13:52.840
And each tag has a class.

00:13:52.840 --> 00:13:57.560
The class indicates if it's an OS type
or a file name extension or a MIME type,

00:13:57.590 --> 00:13:58.100
etc.

00:13:58.960 --> 00:14:01.530
And the thing to remember
about tags is that there's not

00:14:01.650 --> 00:14:03.120
always a one-to-one mapping.

00:14:03.120 --> 00:14:05.550
Usually there's a one-to-one mapping,
but not always.

00:14:05.560 --> 00:14:07.600
And so some cases are complex.

00:14:07.600 --> 00:14:10.300
You have to map multiple file
name extensions back to the

00:14:10.300 --> 00:14:12.020
same Uniform Type Identifier.

00:14:12.020 --> 00:14:19.560
Sometimes the same extension or
OS type may have a collision and may

00:14:19.560 --> 00:14:21.440
map to two different type identifiers.

00:14:21.440 --> 00:14:26.840
So our API makes it easy to deal with
the common case of a one-to-one mapping,

00:14:26.840 --> 00:14:30.770
but it also allows you to...
enumerate all the different

00:14:30.850 --> 00:14:36.390
combinations so that you can discover
more complex type relationships.

00:14:37.660 --> 00:14:45.120
So here's that cloud again of types,
and the API lets you easily map between

00:14:45.120 --> 00:14:50.360
the tags around the outside and the
one true type identifier in the middle.

00:14:50.360 --> 00:14:54.380
And so that makes it very easy
to go through kind of a two-step

00:14:55.130 --> 00:14:57.540
translation where you get to
the uniform type identifier,

00:14:57.540 --> 00:15:00.340
and then you want to know what
the tag is in another space,

00:15:00.420 --> 00:15:02.320
and you can go from there to the tag.

00:15:02.780 --> 00:15:07.010
And this is actually used probably
more heavily in the system than you

00:15:07.010 --> 00:15:12.320
may have to use it because we have
to deal with Cocoa Apps and file name

00:15:12.320 --> 00:15:16.730
extensions in the file dialogs and

00:15:16.890 --> 00:15:19.800
We're going to talk about the
OS types in the Scrap Manager,

00:15:19.800 --> 00:15:22.940
and we need to make all
those systems work together,

00:15:22.940 --> 00:15:27.900
especially moving data between the
NS Pasteboard and the Scrap Manager.

00:15:27.900 --> 00:15:33.600
And so we rely on this internally to do
all of our mapping between namespaces.

00:15:33.600 --> 00:15:35.410
And how do we do that?

00:15:35.510 --> 00:15:36.540
It's very simple.

00:15:36.540 --> 00:15:40.800
This is just a trivial example
of taking the OS type JPEG,

00:15:40.800 --> 00:15:44.840
which is treated as a string in the API,
and you call UT type create

00:15:44.900 --> 00:15:47.310
preferred identifier for tag.

00:15:47.320 --> 00:15:49.180
You pass in the tag information.

00:15:49.180 --> 00:15:52.470
You say that it's an OS type tag,
and you get back the

00:15:52.670 --> 00:15:56.790
type identifier for JPEG,
which happens to be public.jpeg.

00:15:58.370 --> 00:16:00.750
Then if you want to go to
the MIME type for that,

00:16:00.750 --> 00:16:03.950
you would just do another--
it's another string operation,

00:16:03.980 --> 00:16:06.270
UT type copy preferred tag with class.

00:16:06.340 --> 00:16:08.370
And you say you want the MIME type class.

00:16:08.560 --> 00:16:12.510
And you get back the string,
which is image/jpeg.

00:16:12.590 --> 00:16:16.210
So it's a very simple mapping process.

00:16:17.820 --> 00:16:22.940
Now onto the conformance model
and testing types for equality.

00:16:23.100 --> 00:16:27.150
So this is just a simple
hierarchy of type identifiers.

00:16:27.280 --> 00:16:31.900
We've got HTML and XML as
generic text types,

00:16:31.910 --> 00:16:38.360
and then XML includes
com.apple.propertylist on your right,

00:16:38.480 --> 00:16:43.680
and XHTML is a subtype of XML.

00:16:43.900 --> 00:16:49.870
And let's say you're receiving some
data from another application and you

00:16:50.510 --> 00:16:51.800
There it is.

00:16:51.840 --> 00:16:53.140
You handle XML.

00:16:53.140 --> 00:16:55.160
You're some sort of XML processor.

00:16:55.160 --> 00:16:58.620
You want to find out if the data is XML.

00:16:58.620 --> 00:17:03.320
You can ask, does the data that I'm
receiving conform to XML?

00:17:03.320 --> 00:17:07.380
And if the type identifier that
you're receiving is XHTML or

00:17:07.380 --> 00:17:12.640
com.apple.plist or just plain XML,
then you get back the answer, yes,

00:17:12.640 --> 00:17:15.230
this is data that I can deal with.

00:17:15.560 --> 00:17:19.870
In other contexts,
you actually do want to test for

00:17:20.100 --> 00:17:25.540
specific equality of type information,
and we provide an API for that,

00:17:25.630 --> 00:17:29.940
which fundamentally uses a string
comparison to do the equality.

00:17:29.940 --> 00:17:34.010
But there are cases where a
string comparison isn't enough.

00:17:34.060 --> 00:17:35.560
Here are those APIs.

00:17:35.560 --> 00:17:36.420
Again, very simple.

00:17:36.420 --> 00:17:38.760
Just two input strings,
returns a Boolean.

00:17:38.760 --> 00:17:43.540
And I wanted to say a little
bit more about why the equal...

00:17:45.990 --> 00:17:47.890
Why the equality test is there?

00:17:48.030 --> 00:17:51.980
Obviously, to do conformance testing,
you have to resort to calling

00:17:51.980 --> 00:17:54.700
that so that we can use the
type information in our database

00:17:54.940 --> 00:17:56.020
to give you the right answer.

00:17:56.020 --> 00:17:59.630
As for equality, well,
we do use a string comparison

00:17:59.630 --> 00:18:01.850
internally to test equality.

00:18:01.850 --> 00:18:04.340
It's case insensitive since
these are like DNS names.

00:18:04.340 --> 00:18:06.000
UTIs are all case insensitive.

00:18:06.520 --> 00:18:09.080
But we also expect in the future that,
you know,

00:18:09.080 --> 00:18:13.040
as carefully as we've tried to design
the naming conventions for types,

00:18:13.040 --> 00:18:18.060
we're expecting that
little warts will happen.

00:18:18.060 --> 00:18:21.450
There will be a type identifier
which is in somebody's or some

00:18:21.450 --> 00:18:25.610
organization's domain and somebody else
will put it in the public domain or

00:18:25.670 --> 00:18:28.180
Apple will want it in the public domain.

00:18:28.180 --> 00:18:31.720
And if you use this API to test
for conformance and equality,

00:18:31.810 --> 00:18:36.260
we'll be able to do things like declare
two type identifiers as synonyms.

00:18:36.520 --> 00:18:41.310
and everyone will just continue
to work if you use our API.

00:18:43.590 --> 00:18:48.360
So I want to talk a little
bit about declaring new types.

00:18:48.390 --> 00:18:52.550
I don't want to go into the details,
but there are some samples

00:18:52.630 --> 00:18:54.030
I can point you at.

00:18:54.060 --> 00:18:58.470
So new type identifiers are
declared in bundle property lists,

00:18:58.470 --> 00:19:01.300
in your application's
bundle property lists.

00:19:01.300 --> 00:19:05.630
In fact, all of our built-in identifiers
are declared currently,

00:19:05.630 --> 00:19:08.820
anyway,
in the seed in systemicons.bundle,

00:19:08.820 --> 00:19:11.500
down in system library core services.

00:19:12.410 --> 00:19:15.880
So you can go there to find an example.

00:19:16.720 --> 00:19:19.790
It's very similar to the,
if you're familiar with declaring

00:19:19.790 --> 00:19:22.660
document types in your P-List,
declaring the types of

00:19:22.660 --> 00:19:25.640
documents you can open,
it's very similar to that.

00:19:25.640 --> 00:19:29.250
We've kind of taken that idea and
abstracted it out to just deal with

00:19:29.250 --> 00:19:33.120
type information so that you can
declare in your P-List what your

00:19:33.160 --> 00:19:37.700
type identifier is that you want to
use and what the equivalent tags are

00:19:37.700 --> 00:19:42.400
so that you can associate it with
MIME types and file name extensions,

00:19:42.400 --> 00:19:46.480
as well as what it conforms to.

00:19:46.480 --> 00:19:47.780
Is it an image?

00:19:47.780 --> 00:19:49.580
Is it text?

00:19:50.320 --> 00:19:52.480
or something more specific.

00:19:52.520 --> 00:19:56.080
And once you do that and your app
becomes registered on the system,

00:19:56.220 --> 00:19:59.090
we add that type information to our
database and it's available globally

00:19:59.340 --> 00:20:02.910
so that when you send your data to
another application with your specific

00:20:03.110 --> 00:20:07.850
type identifier attached to it,
that application can use our API to

00:20:07.850 --> 00:20:10.260
discover things about your data.

00:20:11.350 --> 00:20:15.600
The last thing I wanted to say
about it was that there's actually

00:20:15.600 --> 00:20:17.390
two ways to declare a type.

00:20:17.460 --> 00:20:20.100
One is called exported
and one is imported.

00:20:20.100 --> 00:20:22.180
It's a little subtle, but it's necessary.

00:20:22.180 --> 00:20:26.990
In general, for any type identifier that
you are giving out to the

00:20:26.990 --> 00:20:31.750
world for your data type,
you export it from your property list.

00:20:32.030 --> 00:20:34.920
You make an exported declaration.

00:20:36.520 --> 00:20:40.890
If you're using a built-in type,
such as any of the public types,

00:20:40.920 --> 00:20:45.470
then you can rely on that always
being declared in the system because

00:20:45.520 --> 00:20:48.180
the OS guarantees that it's there.

00:20:48.180 --> 00:20:51.310
But sometimes your app might
depend on some third-party

00:20:51.310 --> 00:20:55.160
type that has been declared in,
say, a Microsoft application.

00:20:55.230 --> 00:21:01.050
You want to import Word documents,
and Microsoft has declared in their

00:21:01.050 --> 00:21:04.440
bundle a Microsoft Word identifier.

00:21:05.800 --> 00:21:08.100
You depend on that declaration.

00:21:08.100 --> 00:21:10.840
You depend on the system
knowing about that UTI.

00:21:10.840 --> 00:21:14.680
But you don't know if
Microsoft Word is installed on

00:21:14.680 --> 00:21:17.130
the system you're running on.

00:21:17.140 --> 00:21:18.810
In fact,
you probably hope it isn't installed

00:21:18.810 --> 00:21:21.340
because you want to read those
files and provide services for

00:21:21.340 --> 00:21:23.500
importing Microsoft Word documents.

00:21:23.500 --> 00:21:27.060
In that case,
you can actually re-declare Microsoft's

00:21:27.060 --> 00:21:29.950
definition or declaration of their type.

00:21:30.000 --> 00:21:31.900
That's called importing.

00:21:31.900 --> 00:21:34.360
You say,
I'm importing this type declaration,

00:21:35.080 --> 00:21:39.290
which really tells us that you're not
the definitive owner of that type.

00:21:39.320 --> 00:21:43.420
And if Word is installed or the
third-party app is installed,

00:21:43.420 --> 00:21:44.800
we'll use their declaration.

00:21:44.800 --> 00:21:48.040
But if you want to ensure
that a declaration is there,

00:21:48.040 --> 00:21:51.300
then you can use that style of importing.

00:21:53.410 --> 00:21:55.560
So that is really an overview.

00:21:55.560 --> 00:21:57.240
I didn't cover all of the API.

00:21:57.240 --> 00:22:02.290
As I said, there's additional functions
for dealing with ambiguities and

00:22:02.290 --> 00:22:04.480
mapping between different types.

00:22:04.480 --> 00:22:06.870
But it's a conceptual overview.

00:22:06.940 --> 00:22:10.720
And what are the guidelines
for working with these?

00:22:10.760 --> 00:22:14.340
Again, we provide tests,
especially when working with

00:22:14.340 --> 00:22:16.500
Pasteboard data and drag data.

00:22:16.980 --> 00:22:23.060
You want to use -- these new
APIs use uniform type identifiers.

00:22:23.090 --> 00:22:25.910
And so you want to use the
conformance and equality test

00:22:25.970 --> 00:22:30.860
when receiving data to find out
if it's data that you can accept.

00:22:31.190 --> 00:22:34.120
Wherever possible, use the built-in types
that we're providing.

00:22:34.120 --> 00:22:37.320
And when you do need
to declare new types,

00:22:37.320 --> 00:22:41.260
just make sure you pick an identifier
that's in your organization's domain

00:22:41.260 --> 00:22:44.710
space so that you're guaranteed,
as long as your own organization

00:22:44.770 --> 00:22:48.050
is coordinating within itself,
you're guaranteed to have a

00:22:48.050 --> 00:22:49.600
unique identifier for your data.

00:22:51.080 --> 00:22:54.110
This is all implemented as
essentially an extension of

00:22:54.120 --> 00:22:56.720
the Launch Services database.

00:22:56.720 --> 00:23:01.180
And so in the seed anyway,
the API and extensive commentary and

00:23:01.180 --> 00:23:04.720
documentation lives in launchservices.h.

00:23:04.720 --> 00:23:07.520
It's likely to get its own
header file before we go GM,

00:23:07.520 --> 00:23:11.100
but that's where you can look in
the seed for more information.

00:23:12.590 --> 00:23:15.130
So that is the foundation
for type management.

00:23:15.130 --> 00:23:19.300
And this brings us to
Bryan's part of the talk,

00:23:19.300 --> 00:23:22.400
where he'll talk about
how the Carbon Pasteboard

00:23:22.470 --> 00:23:24.910
leverages type identification.

00:23:30.010 --> 00:23:31.440
All right, thank you, Chris.

00:23:31.540 --> 00:23:34.640
Chris has just laid a great
foundation for these two new

00:23:34.640 --> 00:23:37.660
APIs with Uniform Type Identification.

00:23:37.740 --> 00:23:39.580
Now I'd like to introduce
the Carbon Pasteboard

00:23:39.920 --> 00:23:43.970
and Translation Services,
which will leverage this foundation.

00:23:44.970 --> 00:23:48.740
First, I want to talk about
Data Exchange today a little bit more.

00:23:48.740 --> 00:23:51.310
As Chris mentioned earlier,
we have separate scrap and drag managers.

00:23:51.310 --> 00:23:52.660
They do basically the same thing.

00:23:52.660 --> 00:23:55.410
You put information on a scrap
or a drag on one application,

00:23:55.410 --> 00:23:57.310
you pull it off on another application.

00:23:57.510 --> 00:23:58.800
This is a little redundant.

00:23:58.800 --> 00:24:01.800
This not only means that you have
to pay attention to two APIs,

00:24:01.930 --> 00:24:04.390
then you have to do twice
the work in your app.

00:24:04.500 --> 00:24:06.540
So you have twice the amount of code.

00:24:06.540 --> 00:24:08.400
And these involve different models.

00:24:08.400 --> 00:24:10.310
The scrap manager only has a single item.

00:24:10.630 --> 00:24:12.450
Drag manager has multiple items.

00:24:12.450 --> 00:24:15.810
The way that you provide
data or provide promises and

00:24:15.810 --> 00:24:18.020
fulfill promises are different.

00:24:18.020 --> 00:24:23.490
So it's really kind of a pain to
keep in mind which model you're in.

00:24:23.790 --> 00:24:25.940
Also, as Chris mentioned,
there's a limited typing mechanism.

00:24:25.940 --> 00:24:27.610
They're both based on OS types.

00:24:27.770 --> 00:24:29.540
And you can have collisions.

00:24:29.540 --> 00:24:33.700
You need to contact Apple and make
sure that you register your types.

00:24:33.700 --> 00:24:36.690
And this is difficult and something
we wanted to move away from.

00:24:36.990 --> 00:24:40.060
and currently there's pretty much
non-existent communication with Cocoa.

00:24:40.180 --> 00:24:42.660
You might think, well,
I can copy and paste between Cocoa and

00:24:42.660 --> 00:24:45.390
certainly they can communicate,
but this is something that's

00:24:45.390 --> 00:24:46.840
handled by us internally.

00:24:46.890 --> 00:24:52.380
We only do it for a few
standard text and picture types.

00:24:52.820 --> 00:24:57.150
And so there's really no way for
an OS-type based API to communicate

00:24:57.220 --> 00:24:59.990
with a string-based Cocoa API.

00:25:00.090 --> 00:25:04.400
And the memory model is
fairly labor intensive.

00:25:04.520 --> 00:25:06.780
What I mean by this is that when
you want to pull information

00:25:06.800 --> 00:25:11.040
off of a scrap or drag,
you have to ask how

00:25:11.040 --> 00:25:13.500
large the information is.

00:25:13.630 --> 00:25:16.260
And then once you have that,
create your own memory,

00:25:16.280 --> 00:25:20.400
then ask for that memory to be filled in,
and then release that later.

00:25:20.520 --> 00:25:23.000
So we wanted to get away
from each of these issues.

00:25:23.050 --> 00:25:25.990
Now the solution to that
is the Carbon Pasteboard.

00:25:26.060 --> 00:25:31.000
The Carbon Pasteboard is the unification
of the scrap and drag flavor APIs.

00:25:31.100 --> 00:25:34.870
So it's a complete replacement,
and you can move away from them today.

00:25:35.510 --> 00:25:38.090
The Carbon Pasteboard
supports copy and paste,

00:25:38.270 --> 00:25:40.970
drag and drop, and services,
both Apple menu services and

00:25:41.330 --> 00:25:44.930
translation filter services,
which I'll get into later.

00:25:45.100 --> 00:25:47.500
We really like the model
of having multiple items,

00:25:47.510 --> 00:25:51.700
each with their own set of
flavors that the drag manager has.

00:25:51.700 --> 00:25:55.000
We think this is very flexible and
we wanted to bring that forward.

00:25:55.000 --> 00:25:57.910
Flavor types are now based
on Uniform Type Identifiers.

00:25:58.230 --> 00:26:05.000
One great thing for scrap and drag
means that because it's based on UTIs,

00:26:05.000 --> 00:26:07.810
you can now communicate
with NS Pasteboard types.

00:26:08.000 --> 00:26:13.530
You can now convert the UTIs into UTIs
and then you can pull them off as Uniform

00:26:13.530 --> 00:26:20.000
Type Identifiers and then convert them
into any type you like using the UTI API.

00:26:20.210 --> 00:26:24.480
and the Pasteboard, Carbon Pasteboard is
core foundation based.

00:26:24.530 --> 00:26:27.210
The Pasteboard Reference itself
is a core foundation type and

00:26:27.210 --> 00:26:29.460
so you'll want to use the,
you'll want to release them

00:26:29.460 --> 00:26:30.600
after you've created them.

00:26:30.760 --> 00:26:38.140
But the entire, throughout the API,
it's based on core foundations.

00:26:38.140 --> 00:26:38.140
You'll see CFStrings,
dictionaries and data.

00:26:40.350 --> 00:26:42.800
All right,
let's talk about the base type that

00:26:42.800 --> 00:26:45.650
you'll be dealing with Pasteboard,
the Pasteboard Reference.

00:26:45.920 --> 00:26:49.620
A Pasteboard Reference is a proxy
to a global Pasteboard resource.

00:26:49.770 --> 00:26:53.660
You can have multiple references,
a reference in multiple applications

00:26:54.040 --> 00:26:55.100
to a single global Pasteboard.

00:26:55.100 --> 00:26:57.800
That's kind of the point so you
can communicate between the two.

00:26:57.800 --> 00:27:01.060
You can have multiple references
within a single application.

00:27:01.060 --> 00:27:03.100
So if you have multiple objects
within your application,

00:27:03.100 --> 00:27:06.730
each one of them could have
a local Pasteboard ref.

00:27:08.150 --> 00:27:13.710
As the number of references on the system
within multiple applications increases,

00:27:13.990 --> 00:27:16.950
the ref count on the global
Pasteboard resource increases.

00:27:17.060 --> 00:27:20.580
And so as each of the references
are released through CF release,

00:27:20.630 --> 00:27:23.300
then the references on the
global Pasteboard release,

00:27:23.300 --> 00:27:26.960
once the last application
has released its reference,

00:27:27.010 --> 00:27:29.000
the global Pasteboard memory goes away.

00:27:29.070 --> 00:27:32.670
Now there are two exceptions to this,
which I'll mention in a moment.

00:27:34.000 --> 00:29:28.200
[Transcript missing]

00:29:38.730 --> 00:29:41.190
Now that we've created a Pasteboard,
you want to access that Pasteboard

00:29:41.250 --> 00:29:44.840
to do certain operations with it,
typically reading or writing.

00:29:44.980 --> 00:29:47.990
So the first thing I'm going to talk
about is reading from the Pasteboard.

00:29:48.110 --> 00:29:49.570
Before you want to read
from the Pasteboard,

00:29:49.570 --> 00:29:52.860
you want to check out and see if any
other applications have modified it.

00:29:52.860 --> 00:29:56.010
So you can call PasteboardSynchronize,
which returns a set of flags indicating

00:29:56.010 --> 00:29:57.960
whether the Pasteboard has been modified.

00:29:58.160 --> 00:30:00.740
So if some other
application is in the front,

00:30:00.740 --> 00:30:03.920
the user has performed a copy,
your application has been

00:30:03.930 --> 00:30:05.810
brought to the front,
and you're curious as to whether

00:30:05.810 --> 00:30:07.230
you want to enable paste or not.

00:30:07.430 --> 00:30:10.750
You can call PasteboardSynchronize
on the clipboard,

00:30:11.030 --> 00:30:14.830
the clipboard pasteboard,
and it will return a set

00:30:15.020 --> 00:30:17.700
of flags indicating whether
it's been modified or not.

00:30:17.700 --> 00:30:20.520
If it has, then you can go ahead and
look at the Pasteboard,

00:30:20.520 --> 00:30:22.170
see if there are any
tasty flavors on there.

00:30:22.230 --> 00:30:25.280
If so,
go ahead and enable your paste item,

00:30:25.280 --> 00:30:26.690
paste menu item.

00:30:26.960 --> 00:30:28.770
Now if you're going to write
new information to a Pasteboard,

00:30:28.770 --> 00:30:30.540
you want to make sure
that you clear it first.

00:30:30.680 --> 00:30:32.890
Clearing the Pasteboard wipes
out any data that any other

00:30:32.890 --> 00:30:36.730
application has written to it and
makes your application the owner.

00:30:36.800 --> 00:30:39.120
So you are the only one who
can write to it at that time.

00:30:39.260 --> 00:30:42.770
So the two rules here are always
sync your Pasteboard before reading

00:30:42.770 --> 00:30:46.860
data from it and always clear the
Pasteboard before writing to it.

00:30:49.400 --> 00:30:51.270
There are two branches
I could take at this point,

00:30:51.390 --> 00:30:52.600
either writing or reading data.

00:30:52.600 --> 00:30:54.620
I'm going to take the
reading data branch first.

00:30:54.660 --> 00:30:58.160
When you're receiving
data from the Pasteboard,

00:30:58.160 --> 00:30:59.900
the Pasteboard has multiple items.

00:30:59.940 --> 00:31:03.700
You want to get the number of items
through Pasteboard Get Item Count,

00:31:03.700 --> 00:31:07.400
and then we access each of the
items through a unique identifier.

00:31:07.400 --> 00:31:10.600
It doesn't matter what the identifier is.

00:31:10.600 --> 00:31:15.420
It could be 1, 2, 3, just indices,
or it could be a pointer

00:31:15.420 --> 00:31:17.400
to your data in memory.

00:31:18.330 --> 00:31:21.290
This is actually very similar to
the way the Drag Manager works

00:31:21.290 --> 00:31:22.810
today with multiple items.

00:31:22.820 --> 00:31:26.000
So if you're used to that model,
most of you should have some drag code or

00:31:26.110 --> 00:31:28.130
copy and paste code in your application.

00:31:28.140 --> 00:31:29.640
So a lot of this will look very familiar.

00:31:29.640 --> 00:31:30.890
Thank you.

00:31:31.340 --> 00:31:33.430
Okay,
once you've looked at the first item,

00:31:33.490 --> 00:31:34.780
you can enumerate the items.

00:31:34.850 --> 00:31:37.510
You want to look at all the
flavors that are inside.

00:31:38.400 --> 00:31:41.430
So unlike the drag manager,
which required you to not only

00:31:41.430 --> 00:31:44.130
iterate through each of the items,
but then iterate through

00:31:44.130 --> 00:31:46.130
each of the flavors,
we'll pass all the flavors to

00:31:46.130 --> 00:31:48.840
you at once in a single API,
Pasteboard Copy Item Flavors.

00:31:48.840 --> 00:31:51.120
It passes back a core foundation array.

00:31:51.120 --> 00:31:55.560
Each of the types on the Pasteboard
are uniform type identifiers.

00:31:55.560 --> 00:31:58.590
So you'll want to make sure to
use the comparison routines,

00:31:58.590 --> 00:32:02.400
especially when you're reading the data,
especially conformance.

00:32:02.420 --> 00:32:05.220
Ask for the data in as
general a way as possible.

00:32:05.340 --> 00:32:07.320
If you're a general text editor,
first you want to ask,

00:32:07.320 --> 00:32:10.440
is text available on the Pasteboard?

00:32:10.440 --> 00:32:13.620
And then you can be more
specific after that if you like.

00:32:15.890 --> 00:32:17.700
One important thing to notice,
translations are back

00:32:18.030 --> 00:32:20.020
with Translation Services.

00:32:20.020 --> 00:32:24.360
And the translations are always
offered after the sender flavors.

00:32:24.360 --> 00:32:30.040
So ordering is important when pulling
flavors off of the Pasteboard.

00:32:30.160 --> 00:32:33.330
When you're done with the flavor array,
you'll want to release it.

00:32:34.270 --> 00:32:35.500
Okay,
now you've got a bunch of these flavors,

00:32:35.500 --> 00:32:38.530
but you want some more rich metadata
associated with these flavors.

00:32:38.540 --> 00:32:43.340
So you can grab the flavor flags via
Pasteboard Get Item Flavor Flags.

00:32:45.200 --> 00:32:46.940
Now,
these are almost exactly the same sort

00:32:46.940 --> 00:32:49.820
of flags available in Drag Manager today.

00:32:49.820 --> 00:32:53.580
This is for compatibility,
with one exception.

00:32:53.780 --> 00:32:56.480
There's a request-only flag now
that behaves very similarly to

00:32:56.480 --> 00:33:00.700
the sender-only flag of yesterday.

00:33:00.700 --> 00:33:05.150
It behaves a little like having
an unlisted phone number.

00:33:05.300 --> 00:33:09.860
So somebody trolling through the phone
book can't find your phone number,

00:33:09.860 --> 00:33:13.220
but if you share it with your friends,
then you can call each other.

00:33:13.330 --> 00:33:16.020
And so this is very nice if you
have a suite of applications and you

00:33:16.020 --> 00:33:19.180
want to communicate between them,
but you don't really want to announce

00:33:19.180 --> 00:33:20.910
certain data types out to the world.

00:33:20.990 --> 00:33:25.200
And so any flavor that you add to the
Pasteboard that has a request-only

00:33:25.470 --> 00:33:30.680
flag set on it will not be advertised
in the previous API that returns

00:33:30.680 --> 00:33:32.490
all the flavors on the Pasteboard.

00:33:32.720 --> 00:33:36.820
But if you know the flavor name,
you can go ahead and ask for

00:33:36.820 --> 00:33:39.980
it explicitly and then get
its flags and get the data.

00:33:40.090 --> 00:33:43.010
So this is a nice addition
that I think you'll appreciate.

00:33:44.000 --> 00:33:45.740
Okay, once you've looked at
all the flavor flags,

00:33:45.740 --> 00:33:47.810
you've looked at the flavors,
paid attention to their ordering,

00:33:47.970 --> 00:33:50.400
there's a rich amount of information
there that you want to pay attention to.

00:33:50.520 --> 00:33:52.700
But you've decided you've got
the flavor that's right for you,

00:33:52.810 --> 00:33:54.400
and you want to get the data.

00:33:54.600 --> 00:33:57.200
The single API you want to
deal with at this point is

00:33:57.290 --> 00:33:59.400
Pasteboard Copy Item Flavor Data.

00:33:59.510 --> 00:34:02.320
Again, it's based on CFData,
and so you'll want to release the

00:34:02.320 --> 00:34:03.390
memory when you're done with it.

00:34:03.560 --> 00:34:05.400
But now you don't have
to do any allocation,

00:34:05.400 --> 00:34:06.800
you don't have to ask
how big the flavor is,

00:34:07.060 --> 00:34:08.660
it's very simple.

00:34:09.960 --> 00:34:11.260
Okay, now let's back up a little bit.

00:34:11.300 --> 00:34:13.200
I mentioned that there are
two branches we could take.

00:34:13.200 --> 00:34:17.570
Let's go down the other branch where we
can add information to the Pasteboard.

00:34:18.410 --> 00:34:19.800
When you add data,
the first thing you want to do

00:34:19.800 --> 00:34:23.740
is add data in your application's
order of preference in richness.

00:34:23.740 --> 00:34:25.140
Now, that seems a little odd.

00:34:25.140 --> 00:34:27.550
You'd think you want to add it
in the order of richness that

00:34:27.550 --> 00:34:29.040
a receiving app would prefer.

00:34:29.040 --> 00:34:32.140
But really, when you're initiating a drag
or putting information onto

00:34:32.140 --> 00:34:34.480
the Pasteboard for a copy,
there's no way to know what

00:34:34.480 --> 00:34:35.920
the receiver is going to be.

00:34:35.940 --> 00:34:39.150
And so you can't anticipate what order
they will want the information in.

00:34:39.160 --> 00:34:42.730
So the best thing you can do is
indicate this by adding information

00:34:42.940 --> 00:34:47.420
in your application's order of
richness as just an indication saying,

00:34:47.420 --> 00:34:50.230
"You might want to look
at this item first."

00:34:51.350 --> 00:34:55.190
In order to add a promise,
you can pass null as the data or

00:34:55.190 --> 00:34:59.090
the KPasteboardPromiseData constant.

00:34:59.910 --> 00:35:00.830
Now, this is very convenient.

00:35:00.830 --> 00:35:03.450
There's just one way to add data,
one way to add promises.

00:35:03.550 --> 00:35:07.340
There's no longer two separate
models between scrap and drag.

00:35:07.440 --> 00:35:09.230
Once you've added data,
you want to fulfill this

00:35:09.230 --> 00:35:13.550
in a promise keeper,
so keeping promises.

00:35:14.530 --> 00:35:18.680
You have to install a Promise Keeper
before making promises.

00:35:18.730 --> 00:35:23.190
The Carbon Pasteboard makes sure that
you are able to fulfill the promises

00:35:23.190 --> 00:35:27.300
that you add because it wants to
guarantee that receivers of that

00:35:27.300 --> 00:35:29.470
information can get access to it.

00:35:29.770 --> 00:35:34.210
In order to keep the promise,
some application has requested that your

00:35:34.210 --> 00:35:39.200
promise be fulfilled and your Pasteboard
Promise Keeper proc will be called back.

00:35:39.300 --> 00:35:42.060
You'll be given the Pasteboard
that the promise was made on,

00:35:42.150 --> 00:35:46.230
the item that it was made within,
and the flavor type being requested,

00:35:46.350 --> 00:35:49.310
and any context information
that you've passed through.

00:35:50.880 --> 00:35:53.660
So when the promise is going to be kept,
just call Pasteboard put item

00:35:53.730 --> 00:35:56.600
flavor data as if you were not
making a promise to begin with.

00:35:56.600 --> 00:35:57.100
Very simple.

00:35:57.100 --> 00:36:01.040
Again, it's just a single API for adding
data and fulfilling promises.

00:36:01.160 --> 00:36:05.360
So promises-- one cool thing here
is that promises are resolved when

00:36:05.360 --> 00:36:06.840
you release your Pasteboard ref.

00:36:06.920 --> 00:36:09.720
So if you have, again,
a plugin architecture,

00:36:09.720 --> 00:36:12.280
and each one of your plugins has
its own Pasteboard reference,

00:36:12.350 --> 00:36:15.620
and they can each make promises
to the global Pasteboard

00:36:15.670 --> 00:36:17.010
independently of the others.

00:36:17.140 --> 00:36:19.590
And so if one plugin
is brought into memory,

00:36:19.660 --> 00:36:21.270
it adds a promise to the Pasteboard.

00:36:21.470 --> 00:36:23.710
But for some reason,
it's going to be moved out.

00:36:23.910 --> 00:36:26.390
You're dropping that plugin.

00:36:26.630 --> 00:36:29.830
Then when it releases the Pasteboard,
only its promises will

00:36:29.830 --> 00:36:30.960
be explicitly called in.

00:36:31.030 --> 00:36:32.260
All the others will remain.

00:36:32.330 --> 00:36:37.070
So this is a great way to allow
promises in a plugin architecture.

00:36:38.550 --> 00:36:41.290
All right, I mentioned that this is a
replacement for the Drag Flavor APIs.

00:36:41.430 --> 00:36:43.300
There are a couple of
additions to the Drag Manager.

00:36:43.300 --> 00:36:47.310
You can see some HeaderDoc on
them in drag.h in HIToolbox.

00:36:47.380 --> 00:36:52.400
You can use the Pasteboard
with the Drag in two ways.

00:36:52.440 --> 00:36:54.630
Either create a drag and pull
the Pasteboard out of it.

00:36:54.630 --> 00:36:58.240
This is useful if you're receiving a drag
and you want to use the Pasteboard API.

00:36:58.480 --> 00:37:00.670
Then you can just,
when you're given the drag ref,

00:37:00.710 --> 00:37:02.170
pull the Pasteboard out of it.

00:37:02.330 --> 00:37:04.480
Or, depending on the flow
of your application,

00:37:04.480 --> 00:37:08.190
if you're using the same code to perform
copy and paste and drag and drop,

00:37:08.240 --> 00:37:10.070
maybe you have a Pasteboard
that exists already.

00:37:10.080 --> 00:37:14.010
So you can call new drag with Pasteboard,
and a new drag will be created with

00:37:14.010 --> 00:37:16.260
the Pasteboard that you've provided.

00:37:19.180 --> 00:37:24.430
A couple guidelines now for
using the Carbon Pasteboard.

00:37:24.850 --> 00:37:27.150
Always pay attention to the
flavor flags and ordering.

00:37:27.280 --> 00:37:31.280
If you're receiving information,
you want to take advantage of

00:37:31.360 --> 00:37:34.000
all the information that you
have to choose the right flavor.

00:37:34.000 --> 00:37:37.050
We've had issues when trying to
add some default translations that

00:37:37.080 --> 00:37:40.060
applications will see a translated
flavor and think that that's the

00:37:40.310 --> 00:37:42.000
one they want in a given context.

00:37:42.000 --> 00:37:44.560
In fact,
the context that you'd be pasting

00:37:44.700 --> 00:37:48.430
or dragging into might not even
be applicable for that type.

00:37:49.060 --> 00:37:51.560
So it's very important to take all
the information that you have and

00:37:51.560 --> 00:37:52.570
make the best decision you can.

00:37:54.020 --> 00:37:56.440
Always use UTI comparisons
for the best results.

00:37:56.440 --> 00:38:02.760
You want to leverage that API to get the
most coverage you can in receiving data.

00:38:02.760 --> 00:38:07.440
One note about the WWDC seed is
that NSPasteboard types are added

00:38:07.530 --> 00:38:09.900
by Cocoa as NSPasteboard types.

00:38:09.960 --> 00:38:12.890
They are not yet converted
to Uniform Type Identifiers.

00:38:12.980 --> 00:38:15.060
Their existence is only temporary.

00:38:15.110 --> 00:38:16.060
They will be going away.

00:38:16.060 --> 00:38:19.400
They will be converted to Uniform
Type Identifiers before Panther ships.

00:38:19.460 --> 00:38:21.950
So I don't want you to see
them and depend on them.

00:38:22.100 --> 00:38:24.560
So pay attention to that being there.

00:38:24.560 --> 00:38:25.630
This will change for Panther.

00:38:27.200 --> 00:38:30.200
And again, there's plenty of header
documentation in Pasteboard.h.

00:38:30.300 --> 00:38:34.100
This is located in hiservices in
the Application Services Framework.

00:38:34.210 --> 00:38:35.100
There's HeaderDoc there.

00:38:35.100 --> 00:38:38.100
There's a couple features that
I wasn't able to get into here.

00:38:38.130 --> 00:38:40.100
Go check it out for details.

00:38:40.100 --> 00:38:43.830
Also, there's some sample code that we
whipped up for the conference,

00:38:43.830 --> 00:38:45.100
Pasteboard Peeker.

00:38:45.100 --> 00:38:49.100
It's kind of a cool little sort of text
editing app that shows you everything

00:38:49.240 --> 00:38:51.100
that is on a drag or in the Pasteboard.

00:38:51.100 --> 00:38:54.100
You can add information
to a drag or Pasteboard.

00:38:54.380 --> 00:38:58.100
And it exercises the API and
shows you how you can use it.

00:38:58.100 --> 00:38:59.800
That's on the ADC member site.

00:39:00.040 --> 00:39:01.100
Go check it out.

00:39:03.120 --> 00:39:05.270
All right, that's the Carbon Pasteboard.

00:39:05.480 --> 00:39:06.790
Let's get on to Translation Services.

00:39:06.800 --> 00:39:08.360
Thank you.

00:39:11.310 --> 00:39:13.400
Let's talk about translation
the way it is today.

00:39:13.400 --> 00:39:15.720
Again, there are a set of problems
that we've discovered,

00:39:15.720 --> 00:39:17.700
and we really wanted to solve these.

00:39:18.070 --> 00:39:23.630
Again, there's a limited typing mechanism
with four character codes,

00:39:23.670 --> 00:39:24.400
OS types.

00:39:24.400 --> 00:39:27.000
And we've gone over this several times.

00:39:27.000 --> 00:39:28.800
It's also a legacy API.

00:39:28.800 --> 00:39:33.980
For instance, it's based on FS specs,
which have no Unicode support,

00:39:33.980 --> 00:39:38.940
and so we couldn't support the
full type of -- full number of --

00:39:39.250 --> 00:39:42.120
of files that we want to
support on Mac OS X today.

00:39:42.120 --> 00:39:44.920
In fact, with the memory model,
it's still based on handles,

00:39:45.020 --> 00:39:47.720
and it's still based on
C arrays of all things.

00:39:47.720 --> 00:39:50.240
If you wanted to get some
information in an array back

00:39:50.410 --> 00:39:53.620
from the translation manager,
you'd have to pass through a C array.

00:39:53.780 --> 00:39:58.650
And if you didn't allocate enough space,
too bad if it wanted to give you more

00:39:58.650 --> 00:40:01.400
information than you had asked for.

00:40:01.400 --> 00:40:03.960
And the third thing,
and really one of the biggest things,

00:40:04.090 --> 00:40:08.520
is that the way to extend
translations in Mac OS 9 and earlier,

00:40:08.550 --> 00:40:10.950
the plug-in mechanism
was based on extensions.

00:40:10.980 --> 00:40:13.880
And extensions simply don't
exist in Mac OS X today.

00:40:14.020 --> 00:40:16.820
And so this is an issue that
really needed to be resolved.

00:40:16.820 --> 00:40:17.900
And the solution?

00:40:18.010 --> 00:40:19.400
Translation services.

00:40:19.510 --> 00:40:23.990
So translation services is the
successor to the translation manager.

00:40:24.180 --> 00:40:28.000
The source and destination types are both
provided as Uniform Type Identifiers,

00:40:28.000 --> 00:40:29.630
so very flexible.

00:40:29.740 --> 00:40:32.800
It's extensible via filter services,
which I mentioned earlier.

00:40:32.910 --> 00:40:35.660
This is something else, actually,
that we've adopted from Cocoa.

00:40:35.660 --> 00:40:38.240
They're very similar to
Apple Menu Services with

00:40:38.290 --> 00:40:41.160
a modified plist,
and I'll get into that later.

00:40:41.290 --> 00:40:43.900
And the entire API, again,
is core foundation-based,

00:40:43.920 --> 00:40:46.300
so it has an advanced memory model.

00:40:47.380 --> 00:40:48.570
So a translation reference.

00:40:48.670 --> 00:40:50.990
A translation reference is the
base type you'll be dealing with.

00:40:51.160 --> 00:40:55.150
It's a proxy to a resource on
the system that translates data

00:40:55.220 --> 00:40:57.300
from one format to another.

00:40:57.310 --> 00:41:00.290
It contains all the information that's
required to perform a translation,

00:41:00.360 --> 00:41:04.300
the source type that it handles,
the destination type it will provide,

00:41:04.300 --> 00:41:08.540
and whether it handles
file or data translations.

00:41:08.890 --> 00:41:12.840
And in the Translation Services model,
translation discovery and

00:41:12.840 --> 00:41:14.290
execution are separated.

00:41:14.390 --> 00:41:17.110
And so that's important because
you can create a translation if you

00:41:17.110 --> 00:41:19.440
know you're going to be referencing
that translation many times,

00:41:19.470 --> 00:41:22.200
translating many files or something,
for instance.

00:41:22.200 --> 00:41:23.200
You can hold on to that.

00:41:23.200 --> 00:41:24.740
Because it's a CF type,
you can throw it in a

00:41:24.740 --> 00:41:27.870
CFArray or a dictionary and
keep it around until later.

00:41:30.400 --> 00:41:31.700
So let's talk about discovery.

00:41:31.840 --> 00:41:32.860
Translation Create.

00:41:32.960 --> 00:41:36.400
Translation Create is a pretty simple,
straightforward API for finding

00:41:36.400 --> 00:41:37.750
a translation you might need.

00:41:37.760 --> 00:41:40.040
Let's say you have a source file.

00:41:40.040 --> 00:41:42.040
You have point A here,
and you want to get to point B.

00:41:42.040 --> 00:41:44.040
You know that there's a
destination you want to get to.

00:41:44.040 --> 00:41:46.090
Does a translation exist
that supports that?

00:41:46.120 --> 00:41:48.650
So you can hand the source type,
the destination type,

00:41:48.680 --> 00:41:53.750
and searching for data and
file translations is performed

00:41:53.750 --> 00:41:55.280
through the same API now.

00:41:56.120 --> 00:41:58.060
And so you can pass through
the translation flags,

00:41:58.060 --> 00:42:00.300
whether you want a translation
that handles just data,

00:42:00.300 --> 00:42:01.840
just files, or maybe both.

00:42:01.940 --> 00:42:04.950
And then if the resource exists
that performs this translation,

00:42:04.950 --> 00:42:07.330
the translation reference
is handed back to you.

00:42:08.720 --> 00:42:10.400
So that was for very simple needs.

00:42:10.400 --> 00:42:12.580
If you have more detailed
or complex discovery needs,

00:42:12.820 --> 00:42:14.570
you can use Translation
Create with SourceArray.

00:42:14.680 --> 00:42:19.090
This will handle any permutation of
translation discovery that you need.

00:42:19.640 --> 00:42:22.520
Given an array of source types,
it will provide to you all the

00:42:22.520 --> 00:42:26.040
possible destinations that can be
generated from those source types

00:42:26.040 --> 00:42:30.400
and a dictionary of translation refs
which perform those translations.

00:42:30.400 --> 00:42:35.650
The dictionary of translation refs
is keyed by the destination type,

00:42:35.650 --> 00:42:38.600
and so it's easy to do the lookup.

00:42:39.130 --> 00:42:42.470
Again, when you decide on the
translation that's right for you,

00:42:42.470 --> 00:42:46.520
you need to release the
CFArray and the CFDictionary.

00:42:47.520 --> 00:42:49.300
Now,
how do you discover which translation,

00:42:49.300 --> 00:42:51.690
out of all those translations,
which one is the right one for you?

00:42:51.830 --> 00:42:54.500
Well,
you can use the translation accessors.

00:42:54.730 --> 00:42:58.620
You have access to the source type,
the destination type, and the translation

00:42:58.620 --> 00:42:59.600
flags that it supports.

00:42:59.600 --> 00:43:05.670
We hope to add more accessors in the
future when more information is provided.

00:43:06.110 --> 00:43:09.020
This is a way you can go through
and decide that I really want to

00:43:09.090 --> 00:43:13.480
get to this destination type and

00:43:13.860 --> 00:43:15.020
You really want to get
to one destination type,

00:43:15.110 --> 00:43:17.700
but I'd prefer it coming from
this source than this source,

00:43:17.780 --> 00:43:19.290
because maybe this one
is a little bit richer.

00:43:19.300 --> 00:43:21.380
You can really get fine
detailed if you want to.

00:43:25.400 --> 00:43:27.060
All right,
you've discovered a translation.

00:43:27.060 --> 00:43:28.210
You've created it.

00:43:28.290 --> 00:43:29.340
You've got it in your hot little hand.

00:43:29.340 --> 00:43:31.860
And you want to now
perform a translation.

00:43:31.860 --> 00:43:32.770
You want to execute a translation.

00:43:32.780 --> 00:43:36.580
So if you want to perform
a data translation,

00:43:36.580 --> 00:43:38.940
you can call translation
perform for data,

00:43:38.940 --> 00:43:42.600
hand it to the translation ref,
hand it your source data as a CFData.

00:43:42.600 --> 00:43:46.960
And then a CFDataRef will be given back
to you holding the destination data.

00:43:47.000 --> 00:43:49.150
Read that data out,
do whatever you want with it,

00:43:49.150 --> 00:43:50.140
and then release it.

00:43:50.700 --> 00:43:52.000
There are a couple things
you need to pay attention to.

00:43:52.000 --> 00:43:55.460
Make sure that when you're handing
a translation ref to translation

00:43:55.460 --> 00:43:58.500
perform for data that it actually
handles data translations.

00:43:58.570 --> 00:44:00.000
Otherwise,
you'll receive an error immediately.

00:44:00.020 --> 00:44:02.620
Also,
something that you want to make sure

00:44:02.830 --> 00:44:07.500
is that the source and destination
types in the translation ref are the

00:44:07.500 --> 00:44:12.780
same source and destination that you're
providing and expecting from this API.

00:44:13.870 --> 00:44:17.960
Very similar for translating files,
call translation perform for file,

00:44:18.020 --> 00:44:20.600
pass through the translation ref,
your source file,

00:44:20.710 --> 00:44:24.040
you can provide the destination directory
and name for the destination file.

00:44:24.040 --> 00:44:29.800
And then the API will return an
FSRef of your translated file.

00:44:29.930 --> 00:44:32.560
And again, you need to make sure that the
translation ref supports files

00:44:32.560 --> 00:44:37.220
and that you have the correct
source and destination types.

00:44:37.400 --> 00:44:40.470
If your application happens
to not be FSRef based or your

00:44:40.740 --> 00:44:44.580
translation code is not FSRef based,
you can use the URL API.

00:44:44.720 --> 00:44:48.300
Currently, only file URLs are supported.

00:44:49.070 --> 00:44:54.630
And again, when you receive the URL to
your translated file,

00:44:55.000 --> 00:44:57.580
release the CFURL reference.

00:44:59.620 --> 00:45:01.560
I've mentioned filter services
a couple times along the way.

00:45:01.560 --> 00:45:05.020
These are the extension mechanism
for the default translations.

00:45:05.040 --> 00:45:09.900
These are very similar to
Apple Menu Services with

00:45:10.000 --> 00:45:10.940
a modified plist.

00:45:10.980 --> 00:45:12.820
So if you've written one of those,
these will be very familiar.

00:45:12.820 --> 00:45:14.840
I don't want to get into
too much detail here.

00:45:14.840 --> 00:45:17.920
The Pasteboard Peeker sample, again,
that I mentioned earlier,

00:45:17.920 --> 00:45:21.230
down at the bottom of the slide,
has an example for you.

00:45:21.280 --> 00:45:25.540
But when you're going to
perform a translation,

00:45:25.540 --> 00:45:28.120
your service is launched, if necessary,
if it's not already running.

00:45:28.720 --> 00:45:30.700
The source data is delivered
to you on a Pasteboard.

00:45:30.700 --> 00:45:33.170
You can pull that data off,
perform a translation,

00:45:33.180 --> 00:45:35.960
and then put the destination
data back on the Pasteboard,

00:45:35.960 --> 00:45:40.840
hand it back, and the client can have
access to that data.

00:45:43.260 --> 00:45:45.940
All right, a couple guidelines for
Translation Services.

00:45:45.940 --> 00:45:48.410
Use Translate Create for
very simple needs.

00:45:48.420 --> 00:45:52.300
If you have one or two types that you're
interested in for a given source type,

00:45:52.480 --> 00:45:54.090
you can just call it a
couple times and ask,

00:45:54.090 --> 00:45:55.500
does it handle this flavor?

00:45:55.590 --> 00:45:56.260
Can I get this flavor?

00:45:56.260 --> 00:45:56.880
Can I get this flavor?

00:45:56.930 --> 00:45:57.560
Oh, I can get this one.

00:45:57.560 --> 00:45:58.420
Great.

00:45:58.420 --> 00:46:01.910
If you have more complex needs than that,
call Translation Create with SourceArray.

00:46:02.020 --> 00:46:05.080
And again,
it'll handle any permutations you have.

00:46:05.320 --> 00:46:08.800
Definitely check out the
TranslationServices.h header for details.

00:46:08.850 --> 00:46:10.040
Lots of HeaderDoc there again.

00:46:12.700 --> 00:46:16.760
There's lots of examples there for how to
create a translation service and so on.

00:46:16.760 --> 00:46:21.300
So go check it out in HSServices in
the Application Services Framework.

00:46:22.180 --> 00:46:22.840
All right.

00:46:22.970 --> 00:46:25.460
In summary,
we've come up with three great new

00:46:25.460 --> 00:46:29.250
APIs that I think will -- I know
they definitely help us internally,

00:46:29.370 --> 00:46:32.670
and we're really hoping that
they'll be great for you.

00:46:32.900 --> 00:46:36.240
What we need to do now is, you know,
you've got the seed in your hands.

00:46:36.410 --> 00:46:37.020
Get to work.

00:46:37.020 --> 00:46:42.390
Uniform Type Identifiers are a
really flexible framework for typing.

00:46:42.390 --> 00:46:46.860
If you have data that you need to type,
it's the way to go.

00:46:46.860 --> 00:46:49.640
Always declare new types
in your Internet domain so

00:46:49.640 --> 00:46:52.040
that if they are your types,
you own them.

00:46:52.190 --> 00:46:56.580
otherwise import them
from other applications.

00:46:56.930 --> 00:46:59.440
and always use the
UTI API for conformance tests.

00:46:59.570 --> 00:47:01.490
This is your mantra,
because you want to make sure that you

00:47:01.490 --> 00:47:06.170
can really leverage the full flexibility
of the Uniform Type Identification API.

00:47:06.580 --> 00:47:09.060
Pasteboards can really streamline
your scrap and drag usage.

00:47:09.060 --> 00:47:13.220
I was coming up with that
Pasteboard peeker sample and it

00:47:13.220 --> 00:47:15.540
was really cool just how simple.

00:47:15.540 --> 00:47:20.480
I could use the same function
to read data from both drags and

00:47:20.480 --> 00:47:24.240
copies and the same function to add
information to drags and copies.

00:47:24.450 --> 00:47:26.600
Really convenient.

00:47:26.650 --> 00:47:30.710
Now that you have access through
UTIs to Cocoa applications,

00:47:30.820 --> 00:47:33.550
look at Cocoa applications
that your app might be able to

00:47:33.550 --> 00:47:39.260
correspond with and really see how
you can leverage Cocoa app usage.

00:47:39.700 --> 00:47:42.650
And then always be aware
of automatic translations.

00:47:42.900 --> 00:47:45.200
They're there to help you,
but make sure that they're

00:47:45.200 --> 00:47:46.500
not getting in your way.

00:47:46.500 --> 00:47:50.000
Make sure that you're looking at
the flags to see whether it's a

00:47:50.350 --> 00:47:54.640
translation or not and decide whether
you want to have a translation or not.

00:47:54.640 --> 00:47:55.940
And update to translation services.

00:47:56.000 --> 00:47:59.360
Translation Manager is
frankly unimplemented on 10.

00:47:59.360 --> 00:48:01.100
We wanted to make it happen,
but because of the

00:48:01.130 --> 00:48:04.540
reasons I stated earlier,
I knew that we could create a

00:48:04.540 --> 00:48:06.700
much better solution for you.

00:48:06.700 --> 00:48:09.240
And use filter services to
extend the default translations.

00:48:09.300 --> 00:48:12.640
There's only a limited set that
Apple will be able to provide.

00:48:12.700 --> 00:48:15.940
There was a really rich set
of translations available

00:48:15.940 --> 00:48:17.200
in the Mac OS 9 world.

00:48:17.250 --> 00:48:19.900
We'd really like to see those
brought forward to Mac OS X.

00:48:19.920 --> 00:48:20.590
So check this out.

00:48:20.620 --> 00:48:23.950
This is an excellent third-party
opportunity for all of you.

00:48:25.110 --> 00:48:27.090
So with that,
I'd like to bring Xavier back

00:48:27.100 --> 00:48:28.580
up for the wrap up.

00:48:28.610 --> 00:48:30.110
Thank you.

00:48:40.220 --> 00:48:43.500
OK, quickly,
the roadmap before we go to the Q&A.

00:48:43.610 --> 00:48:46.020
Session 4.9, the HIToolbox was Wednesday.

00:48:46.090 --> 00:48:47.700
Some of you can travel in time.

00:48:47.710 --> 00:48:49.240
I encourage you to look at that session.

00:48:49.240 --> 00:48:50.180
It was pretty good.

00:48:50.210 --> 00:48:53.150
And if not, we'll have it on DVDs.

00:48:53.550 --> 00:48:55.870
Using the Apple tools
for Carbon development,

00:48:55.910 --> 00:48:56.400
same thing.

00:48:56.400 --> 00:48:57.730
That was just before.

00:48:57.790 --> 00:49:02.180
But Apple has been investing a
lot of time and effort in Xcode,

00:49:02.180 --> 00:49:05.670
and I encourage you as
well to check it out.

00:49:07.020 --> 00:49:09.460
You won't have to travel
in time to see session 416,

00:49:09.460 --> 00:49:12.580
which is optimizing
performance on Presidio.

00:49:12.580 --> 00:49:15.630
It's a great,
great session for anybody that is doing

00:49:15.630 --> 00:49:17.520
C and C++ development on our platform.

00:49:17.820 --> 00:49:20.460
We're going to be going
through a ton of information.

00:49:20.460 --> 00:49:23.760
We're going to give you ideas on how
to improve performance on your app.

00:49:23.960 --> 00:49:25.380
Please join us this afternoon.

00:49:25.380 --> 00:49:29.300
And tomorrow, of course,
if you haven't heard,

00:49:29.300 --> 00:49:30.260
we have a brand new H.I.

00:49:30.260 --> 00:49:31.530
Toolbox available in Mac OS X.

00:49:31.580 --> 00:49:33.640
Since 10.2, we introduced H.I.

00:49:33.650 --> 00:49:34.030
View.

00:49:34.030 --> 00:49:37.090
And should you need more information
on this great technology please

00:49:37.090 --> 00:49:38.220
join us tomorrow afternoon

00:49:41.340 --> 00:49:42.300
All right.

00:49:42.300 --> 00:49:44.590
Should you... Did you change that?

00:49:44.860 --> 00:49:46.050
You're so fired.

00:49:46.060 --> 00:49:46.700
You are so fired.

00:49:48.300 --> 00:49:51.130
Anyway, we'll fix that later.

00:49:51.300 --> 00:49:54.620
Should you have any questions
on the new Pasteboard Services,

00:49:54.760 --> 00:49:57.200
please send me an email and
we'll try to get you going.

00:49:57.250 --> 00:50:00.460
It's very important to understand
that the idea here is we

00:50:00.800 --> 00:50:02.270
need to have your feedback.

00:50:02.450 --> 00:50:07.120
So please check out the APIs and contact
us should you have any specific needs.

00:50:07.120 --> 00:50:10.550
Or maybe we forgot something,
or maybe there's a special case to

00:50:10.550 --> 00:50:12.680
make you run that we need to implement.

00:50:12.680 --> 00:50:18.080
And that's the idea with having
WDC and giving you the seat of painter.
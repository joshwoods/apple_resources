WEBVTT

00:00:28.040 --> 00:00:29.000
I'm Brett Halle.

00:00:29.000 --> 00:00:30.710
I'm the Director of
Pro Video Engineering.

00:00:30.890 --> 00:00:33.620
We're going to spend a few minutes
this afternoon and talk about how

00:00:33.620 --> 00:00:38.920
you're going to be extending the
Pro applications with plug-ins.

00:00:39.000 --> 00:00:40.990
This is going to be a
pretty busy session.

00:00:41.000 --> 00:00:44.310
We've got a lot of different
plug-ins we want to cover,

00:00:44.440 --> 00:00:45.920
so we'll get right to it.

00:00:46.000 --> 00:00:50.990
Very quickly,
just so you have a bit of a context,

00:00:51.100 --> 00:00:54.980
we have a number of applications
in our application suite

00:00:54.980 --> 00:00:57.000
or Pro application suite.

00:00:57.130 --> 00:01:01.880
Final Cut 4, which is a whopping, gee,
I think it's almost two weeks old,

00:01:02.340 --> 00:01:05.000
launched a week ago last Saturday.

00:01:05.000 --> 00:01:08.000
And Shake 3, which launched last weekend.

00:01:08.000 --> 00:01:12.000
Final Cut Express,
which came out earlier this year.

00:01:12.000 --> 00:01:16.950
And Logic, which is an acquisition
that we did last year.

00:01:17.070 --> 00:01:20.120
We're going to cover a number of
different plug-in models that are

00:01:20.120 --> 00:01:22.000
supported by all these applications.

00:01:22.000 --> 00:01:25.000
And to kick us off and to
talk about audio units,

00:01:25.000 --> 00:01:30.000
I'd like to invite Roger Powell,
the Lead Engineer for Final Cut Audio.

00:01:38.230 --> 00:01:39.510
Thanks very much for coming today.

00:01:39.610 --> 00:01:43.850
We're going to start off this
session by talking about audio units

00:01:43.960 --> 00:01:48.090
and how they're deployed in these
three Apple Pro Media applications:

00:01:48.190 --> 00:01:51.840
Final Cut Pro, Soundtrack, and Logic.

00:01:51.920 --> 00:01:54.640
We're not going to teach you how
to write an audio unit today.

00:01:54.640 --> 00:01:57.830
For that,
you should go to the developer site,

00:01:58.020 --> 00:02:02.800
developer.apple.com/audio,
if you're new to this technology.

00:02:03.290 --> 00:02:10.400
Each of these applications has
individual usage scenarios and

00:02:10.420 --> 00:02:18.300
requirements for audio units,
and we thought it would be beneficial

00:02:18.300 --> 00:02:20.030
to you if we could go over those
points so that you could effectively

00:02:20.030 --> 00:02:20.030
deploy your audio units in any
or all of these applications.

00:02:20.200 --> 00:02:24.940
These points that we're going to cover
fall into three general categories.

00:02:25.050 --> 00:02:28.420
The first is the user interface,
the parameter user

00:02:28.660 --> 00:02:32.930
interface that's supported,
either custom or generic.

00:02:33.050 --> 00:02:37.600
The second is the input and output
channel configurations that your

00:02:37.600 --> 00:02:42.070
plug-in should support in order
to work in these applications.

00:02:42.240 --> 00:02:47.040
And then there are some issues with
audio unit property implementations.

00:02:47.040 --> 00:02:47.040
Let's start off with Final Cut Pro.

00:02:50.400 --> 00:03:48.900
[Transcript missing]

00:03:49.400 --> 00:03:53.520
This, you can see on the left,
we have the controls that we've

00:03:53.520 --> 00:03:56.540
generated by reading your parameters.

00:03:56.660 --> 00:04:00.340
And then on the right is the,
what we call the keyframe interface.

00:04:00.490 --> 00:04:04.700
And these keyframes can
be produced either through

00:04:05.020 --> 00:04:10.000
recording gestures while you,
during playback while you're

00:04:10.000 --> 00:04:12.330
using these controls on the left,
or they can be edited manually with

00:04:12.330 --> 00:04:12.330
the standard editing procedures.

00:04:13.900 --> 00:04:16.560
I'll go back for a second.

00:04:16.660 --> 00:04:21.350
For channel configurations
in Final Cut Pro,

00:04:21.350 --> 00:04:25.790
at this time,
because of our clip-based and

00:04:25.790 --> 00:04:31.940
track bussing architecture,
we support mono-in and mono-out.

00:04:31.940 --> 00:04:31.940
You can think of this more or less as
an insert/effect type of model rather

00:04:31.940 --> 00:04:31.940
than as a send/return type of model.

00:04:32.200 --> 00:04:36.440
It's okay if you support other
configurations in your plug-in,

00:04:36.440 --> 00:04:40.450
but they must support Mono In and
Mono Out in order for them to

00:04:40.450 --> 00:04:42.450
be loaded into Final Cut Pro.

00:04:42.780 --> 00:04:46.490
At this time, we're not supporting the
Audio Unit Preset mechanism.

00:04:46.590 --> 00:04:55.770
However, users can make changes to the
plug-in and then save a version of

00:04:55.770 --> 00:04:55.770
that using our Favorites mechanism.

00:04:58.110 --> 00:05:05.000
Let's move ahead to another
important item for Final Cut Pro.

00:05:05.040 --> 00:05:08.580
This is an audio unit
property called Tail Time,

00:05:08.580 --> 00:05:11.520
and it's very important to Final Cut Pro.

00:05:11.910 --> 00:05:14.870
We sort of expect that you're
going to implement this or at least

00:05:14.870 --> 00:05:16.760
understand the issues surrounding it.

00:05:17.000 --> 00:05:21.990
Tail Time can be thought of
as the decay of a plug-in.

00:05:21.990 --> 00:05:23.990
A good example would be a reverb.

00:05:23.990 --> 00:05:26.600
A reverb, obviously,
you're going to set to, you know,

00:05:26.600 --> 00:05:29.840
a two-second decay,
and so when a signal hits it,

00:05:29.910 --> 00:05:32.970
it's going to decay out
for about two seconds.

00:05:33.000 --> 00:05:38.660
This actually indicates the length of
the sample history to reach steady state.

00:05:38.660 --> 00:05:41.000
This is how we interpret this.

00:05:41.000 --> 00:05:44.230
We use this for a pre-roll computation
so that we can maintain sample

00:05:44.230 --> 00:05:46.000
accurate seeming across edits.

00:05:46.000 --> 00:05:48.000
The example of this, again,
is the reverb.

00:05:48.000 --> 00:05:50.980
If we place the reverb on
a clip in the timeline,

00:05:50.980 --> 00:05:53.750
and then we render the
first half of that clip,

00:05:53.960 --> 00:05:55.990
we then go back and
start playing that clip.

00:05:56.000 --> 00:05:58.890
The first half of the clip
will play from the render file,

00:05:58.890 --> 00:06:01.990
which has the computed reverb effect,
and then suddenly when

00:06:01.990 --> 00:06:04.800
we hit the crossover,
normally we would start feeding

00:06:04.800 --> 00:06:07.000
source samples again to the reverb.

00:06:07.000 --> 00:06:09.740
Well,
the reverb has to get primed up again,

00:06:09.740 --> 00:06:12.870
so this would produce an
inconsistent sample stream

00:06:13.010 --> 00:06:14.870
across that crossover point.

00:06:15.030 --> 00:06:18.440
In order to avoid this,
we query the tail time property,

00:06:18.440 --> 00:06:21.990
see how many samples we have to
pre-compute to reach a steady

00:06:21.990 --> 00:06:26.430
state point at the crossover,
and then when you play back,

00:06:26.550 --> 00:06:29.830
we've pre-computed that,
and then we start up with the samples

00:06:29.830 --> 00:06:31.940
that are current at the crossover point.

00:06:32.060 --> 00:06:36.000
So this essentially eliminates
the seeming artifacts.

00:06:36.000 --> 00:06:39.170
We do expect this to be
implemented; however,

00:06:39.170 --> 00:06:44.000
there are cases where you should
actually report not implemented.

00:06:44.170 --> 00:06:48.920
One example of this would be if you
have an infinite tail time on a reverb,

00:06:48.920 --> 00:06:50.810
which would last forever.

00:06:51.340 --> 00:06:54.710
Clearly, at that point,
we'll have to render the entire

00:06:54.710 --> 00:06:59.000
clip in order to do that,
because we can't pre-roll forever.

00:06:59.000 --> 00:07:04.000
Or if the state can be indeterminate,
and this is a little interesting,

00:07:04.000 --> 00:07:07.990
but an indeterminate plug-in would
be something like where there was an

00:07:07.990 --> 00:07:12.960
internal modulation from a low frequency
oscillator that was not synchronous.

00:07:13.020 --> 00:07:16.410
Or if there's some other random
element in the plug-in which would

00:07:16.410 --> 00:07:20.000
cause its state to be indeterminate
at a given sample position.

00:07:20.000 --> 00:07:25.000
These types of plug-ins
should report not implemented,

00:07:25.000 --> 00:07:28.000
and there's some gory details associated
with how you actually handle that,

00:07:28.000 --> 00:07:30.000
which I won't go into right now.

00:07:30.000 --> 00:07:33.570
But we do have experts from all
of the applications up here,

00:07:33.570 --> 00:07:38.000
so you can grab one of us later,
and we can give you more detail on that.

00:07:38.460 --> 00:07:42.160
Also, the latency property,
which is somewhat similar in usage.

00:07:42.170 --> 00:07:45.950
If your plug-in has a latency,
that is a delay between when the input

00:07:46.000 --> 00:07:48.300
goes into it before samples come out.

00:07:48.340 --> 00:07:56.730
We need to know that as well in order
to produce sample-accurate seaming.

00:07:56.730 --> 00:07:56.730
That's it for Final Cut Pro.

00:07:56.730 --> 00:07:56.730
Let's go on to Soundtrack.

00:07:58.910 --> 00:08:05.260
Once again, Soundtrack,
and this is a theme that you'll

00:08:05.260 --> 00:08:13.260
hear throughout all of this,
we want you to produce complete and

00:08:13.260 --> 00:08:13.260
accurate parameter descriptions,
type and range.

00:08:13.260 --> 00:08:13.260
This is so that automation
can be handled accurately.

00:08:13.660 --> 00:08:18.320
Soundtrack actually supports the
Audio Unit custom UI and presets,

00:08:18.320 --> 00:08:20.130
and in order to do that,
you would click on the

00:08:20.230 --> 00:08:21.780
Advanced button in the Effect panel.

00:08:21.950 --> 00:08:23.870
I have a screenshot of that as well.

00:08:24.060 --> 00:08:27.060
On the left, you'll see the generic
view for the preset,

00:08:27.070 --> 00:08:29.590
or for the plug-in,
and you can see the controls

00:08:29.600 --> 00:08:33.650
listed and the generic controls,
the names and the controls listed there.

00:08:34.040 --> 00:08:37.130
If you hit the Advanced button,
you'll get a screen like

00:08:37.130 --> 00:08:40.680
what's on the right there,
where it gets overlaid with the custom

00:08:40.820 --> 00:08:43.190
UI that's been embedded in the plug-in.

00:08:45.190 --> 00:08:49.900
Channel configurations for Soundtrack
is stereo in and stereo out only.

00:08:49.980 --> 00:09:00.200
Again, you can put other channel
configurations in your plug-in,

00:09:00.200 --> 00:09:00.200
but they must support stereo in,
stereo out in order to be

00:09:00.200 --> 00:09:00.200
used within Soundtrack.

00:09:00.530 --> 00:09:03.020
Soundtrack also uses
the tail time property.

00:09:03.020 --> 00:09:05.140
It uses it in a little bit different way.

00:09:05.140 --> 00:09:08.560
It's only required for audio units
that would have an audible tail,

00:09:08.560 --> 00:09:10.060
again, something like a reverb.

00:09:10.060 --> 00:09:14.810
And the property value must be
accurate to avoid artifacts.

00:09:14.830 --> 00:09:17.380
Otherwise,
there will be some truncation of output.

00:09:17.380 --> 00:09:21.890
The way this is used is if you have a
reverb on a clip and that clip is the,

00:09:22.050 --> 00:09:26.150
that track ends and you don't
want the reverb to cut off when

00:09:26.150 --> 00:09:27.280
the source signal cuts off.

00:09:27.960 --> 00:09:31.570
So Soundtrack will query that property
and allow playback to continue

00:09:31.690 --> 00:09:36.000
for the length of time required
to process all of the effect samples.

00:09:38.420 --> 00:09:40.300
Let's move on to Logic.

00:09:40.300 --> 00:09:45.950
In Logic, the reference hosts are
Logic Platinum 5.5.1 or higher and

00:09:46.090 --> 00:09:49.300
Logic Platinum 6.0.1 or higher.

00:09:49.300 --> 00:09:52.180
This is where the
Audio Unit Support was first introduced.

00:09:52.300 --> 00:09:57.240
You should put your resource allocations
into the initialization part of the

00:09:57.620 --> 00:10:00.300
plug-in rather than the instantiation.

00:10:00.300 --> 00:10:05.300
This is because Logic will instantiate
one copy of each plug-in on startup,

00:10:05.300 --> 00:10:10.230
and so you don't want to
incur startup penalties.

00:10:10.400 --> 00:10:16.730
The custom UI is supported,
and the generic parameter

00:10:17.050 --> 00:10:21.030
UI is also supported.

00:10:21.030 --> 00:10:23.030
Parameter descriptions must
be complete and accurate.

00:10:23.030 --> 00:10:23.030
We'll take a quick look at
the Logic Audio Unit views.

00:10:23.430 --> 00:10:31.910
The generic views are on
the left and the top right,

00:10:31.910 --> 00:10:31.910
and the custom UI is
displayed in the bottom right.

00:10:34.210 --> 00:10:36.640
For Logic,
the channel configurations that

00:10:36.640 --> 00:10:40.870
are supported are mono to mono,
mono to stereo,

00:10:40.890 --> 00:10:45.400
and stereo to stereo audio
channel configurations.

00:10:45.480 --> 00:10:49.390
So this is a little more
flexible than the other two.

00:10:49.660 --> 00:10:58.430
Each of these applications has a
different purpose in life and has

00:10:58.430 --> 00:10:58.430
different support for these things.

00:10:58.960 --> 00:11:01.240
There are a couple of
other points for Logic.

00:11:01.390 --> 00:11:06.240
Logic will use the standard .au
preset for saving and loading presets.

00:11:06.420 --> 00:11:11.020
It also pays attention to the
latency and tail time properties.

00:11:11.260 --> 00:11:14.310
And then the last two points
are regarding automation.

00:11:14.440 --> 00:11:20.400
Your plug-in should send the
Audio Unit Carbon View Event parameters

00:11:20.690 --> 00:11:24.610
or messages,
mouse down and up in control,

00:11:24.610 --> 00:11:26.030
to the host.

00:11:26.290 --> 00:11:30.650
The reason for this is mostly
to support automation recording

00:11:30.650 --> 00:11:33.100
for latch mode in automation.

00:11:33.230 --> 00:11:38.000
And likewise, for automation support,
your plug-in should use the

00:11:38.130 --> 00:11:43.220
Parameter Listener Scheme to inform
the host of parameter changes.

00:11:43.790 --> 00:11:52.090
That basically covers the
points that we wanted to make

00:11:52.110 --> 00:11:54.190
for these three applications.

00:11:54.190 --> 00:11:54.190
We know it's probably generated some
questions and will all be available

00:11:54.190 --> 00:11:54.190
for QA at the end of the session.

00:11:55.280 --> 00:11:57.990
At this point,
I would like to hand things

00:11:58.000 --> 00:11:59.700
over to Angus Taggart.

00:11:59.710 --> 00:12:06.200
He's from Shake,
and he's going to talk about

00:12:06.200 --> 00:12:06.200
Shake plug-in development.

00:12:06.200 --> 00:12:06.200
Thank you, Roger.

00:12:09.840 --> 00:12:11.780
Thanks again for joining
us this afternoon.

00:12:11.940 --> 00:12:16.620
As Roger said, I'm going to be presenting
an introduction to the

00:12:16.620 --> 00:12:18.830
Shake plug-in architecture.

00:12:19.160 --> 00:12:23.160
Our goal is to cover some brief
introduction to Shake itself,

00:12:23.330 --> 00:12:27.040
try to give you a feeling for
what the application does.

00:12:27.040 --> 00:12:32.650
We're also going to cover what you
get with the Shake SDK and also

00:12:32.650 --> 00:12:36.550
look at some basic concepts that are
involved with building a Shake plug-in.

00:12:37.050 --> 00:12:40.070
So let's start out with
an introduction to Shake.

00:12:40.210 --> 00:12:44.550
Shake has very rapidly established
itself as an industry-leading

00:12:44.550 --> 00:12:48.990
compositing and 2D effects solution,
an invaluable tool in many

00:12:48.990 --> 00:12:51.060
major post-production houses.

00:12:51.250 --> 00:12:52.200
So what does Shake do?

00:12:52.200 --> 00:12:59.680
It does things such as color correction,
filters, grain removal, blurs,

00:12:59.690 --> 00:13:02.530
all kinds of filtering.

00:13:02.570 --> 00:13:06.330
It ships with two of the
industry-leading color keyers,

00:13:06.460 --> 00:13:10.480
Photron's Primat keyer,
and also the computer frame

00:13:11.050 --> 00:13:13.550
store key light keyer.

00:13:13.630 --> 00:13:19.530
It has tools for doing tracking, masking,
rotoscoping paint,

00:13:19.670 --> 00:13:21.340
also retiming controls.

00:13:21.530 --> 00:13:25.630
And for those that are interested,
there's a huge list of Shake's

00:13:25.730 --> 00:13:28.960
capabilities up on the Apple website.

00:13:29.760 --> 00:13:31.200
So how does Shake work?

00:13:31.310 --> 00:13:34.170
A very brief introduction
to Shake is under the hood,

00:13:34.220 --> 00:13:37.860
there is an advanced,
very efficient node-based

00:13:37.860 --> 00:13:39.670
compositing engine.

00:13:39.950 --> 00:13:43.780
The highlights of it is that
the primary processing within

00:13:43.790 --> 00:13:48.240
Shake occurs within nodes,
and that nodes are connected and data

00:13:48.240 --> 00:13:50.700
gets in and out of nodes through plugs.

00:13:50.870 --> 00:13:54.730
And somebody who's using Shake will
actually create very complex

00:13:54.730 --> 00:13:58.700
compositing trees and effects
trees by connecting nodes up.

00:13:58.700 --> 00:14:03.980
I've got a simple example where you can
see there's a foreground and a background

00:14:03.980 --> 00:14:09.820
layer being composited over each other,
and you can see the node representation

00:14:09.970 --> 00:14:12.570
of this operation in Shake.

00:14:13.460 --> 00:14:17.520
Something that's very important to
plug-in developers is who uses Shake?

00:14:17.520 --> 00:14:19.650
Who's my audience going to
be when I build a plug-in?

00:14:19.660 --> 00:14:24.300
Shake is used at a lot of the
top post-production facilities.

00:14:24.300 --> 00:14:28.220
A list includes Weta,
the New Zealand-based company that's

00:14:28.260 --> 00:14:29.450
doing the Lord of the Rings work.

00:14:29.540 --> 00:14:33.860
Escape, based close by here in Alameda,
who's doing The Matrix.

00:14:33.860 --> 00:14:36.640
Cineside, DreamWorks, Blue Sky.

00:14:36.640 --> 00:14:38.730
It's pretty much the
A-list of post-production

00:14:38.790 --> 00:14:40.070
houses and a lot of others.

00:14:41.300 --> 00:14:44.360
To its credit,
it has been used in the production

00:14:44.360 --> 00:14:47.210
pipeline for the last six
Academy Award-winning movies.

00:14:47.240 --> 00:14:52.610
It's becoming more commonly
used in film schools.

00:14:52.640 --> 00:14:57.700
With Apple's aggressive
pricing and positioning,

00:14:57.700 --> 00:15:00.680
it's being used more and more for
commercial work and that sort of thing.

00:15:02.900 --> 00:15:04.480
Who uses the Shake SDK?

00:15:04.480 --> 00:15:08.300
In terms of third-party
commercial plug-in developers,

00:15:08.870 --> 00:15:13.290
pretty much, you know,
we've got fairly strong industry support.

00:15:13.380 --> 00:15:18.060
The Foundry uses or develops for
Shake with Tinder and also with

00:15:18.070 --> 00:15:20.400
their Furnace plug-in suite.

00:15:20.520 --> 00:15:25.560
Also, GenArts with their Sapphire
plug-in suite supports Shake,

00:15:25.660 --> 00:15:30.310
and we've also got support from
Ultimat and Revision Effects'

00:15:30.310 --> 00:15:32.550
warping and morphing tools.

00:15:33.490 --> 00:15:36.220
Also,
another very big user of the Shake SDK is

00:15:36.220 --> 00:15:40.290
actually the Shake customers,
the large post-production houses

00:15:40.300 --> 00:15:44.390
that have to integrate Shake into
their production pipelines,

00:15:44.500 --> 00:15:51.950
and also to create custom effects
within Shake to get the kind of

00:15:51.950 --> 00:15:51.950
creative effects that they need.

00:15:53.300 --> 00:15:56.960
So, you're a plug-in developer,
you're ready to start working with Shake.

00:15:56.960 --> 00:16:00.600
What you'll need to do is actually
request the Shake SDK package

00:16:00.740 --> 00:16:03.200
through Apple Developer Relations.

00:16:03.200 --> 00:16:06.630
And when you get a hold of that package,
you'll see that it not only

00:16:06.630 --> 00:16:10.140
supports the Mac platform,
but it also provides support

00:16:10.680 --> 00:16:15.110
for the IRIX platform or
SGI platform as well as Linux.

00:16:15.260 --> 00:16:18.940
One of the things that we've put a
lot of effort into over the last year

00:16:18.950 --> 00:16:21.200
is really enhancing the Shake docs.

00:16:21.290 --> 00:16:25.200
We've got great tutorials,
really good reference guides,

00:16:25.200 --> 00:16:27.540
some white paper kind of things
to give you some technical

00:16:27.600 --> 00:16:30.200
overviews of Shake's Node engine.

00:16:30.200 --> 00:16:34.080
It also ships with 18 example
plug-ins for doing everything

00:16:34.150 --> 00:16:38.200
from image processing filters,
custom overlays, custom widgets.

00:16:38.200 --> 00:16:41.200
There's a lot of examples
to help you get started.

00:16:41.200 --> 00:16:45.200
And we've got an example project
builder development environment.

00:16:45.220 --> 00:16:48.150
The last point on this slide,
and this is something that is

00:16:48.150 --> 00:16:51.420
both very powerful and it's
something that also requires a

00:16:51.420 --> 00:16:55.150
little bit of a learning curve,
is that there isn't a layer

00:16:55.330 --> 00:16:59.200
that Shake provides for its
plug-in development environment.

00:16:59.200 --> 00:17:01.200
Basically,
when you start working with Shake,

00:17:01.200 --> 00:17:03.610
you're using the same headers
and frameworks that the

00:17:03.640 --> 00:17:05.200
Shake internal developers use.

00:17:05.200 --> 00:17:09.020
And this means that you get the same
access to the Node engine that the

00:17:09.140 --> 00:17:11.200
Shake internal development team has.

00:17:11.200 --> 00:17:13.200
And that's a very cool thing.

00:17:13.200 --> 00:17:14.200
It's a very powerful thing.

00:17:14.200 --> 00:17:17.200
It means that you can do just about
anything with Shake that you want.

00:17:17.200 --> 00:17:21.730
It also means that you need to spend
a little bit of time making yourself

00:17:21.730 --> 00:17:25.200
familiar with some of the concepts
of how the Shake Node engine works.

00:17:25.350 --> 00:17:29.210
And so what I'm going to do really
quickly in the final few slides is

00:17:29.300 --> 00:17:33.200
just hit on some very basic concepts
involved with Shake plug-in development.

00:17:33.200 --> 00:17:36.320
As we said earlier,
the building blocks or the

00:17:36.320 --> 00:17:40.050
basics of the Node engine,
of Shake's Node engine, is just that.

00:17:40.200 --> 00:17:42.200
We've got nodes and plugs.

00:17:42.200 --> 00:17:45.170
And in review,
a node is where processing occurs.

00:17:45.210 --> 00:17:47.400
And this is where you're going
to put your logic for image

00:17:47.500 --> 00:17:49.180
processing or whatever you're doing.

00:17:49.240 --> 00:17:51.200
It's going to be embedded in the node.

00:17:51.200 --> 00:17:53.200
And the node is a C++ class.

00:17:53.250 --> 00:17:57.290
And there's a base class defined
that has a lot of functionality

00:17:57.290 --> 00:17:59.200
that you'll derive from.

00:17:59.230 --> 00:18:03.200
And when you want to get data into
your node or data out of your node,

00:18:03.200 --> 00:18:04.200
you're going to do that through a plug.

00:18:04.200 --> 00:18:07.180
That's the way to get --
that's the way the data moves

00:18:07.230 --> 00:18:09.190
through the Shake Node engine.

00:18:09.330 --> 00:18:13.200
Once again, it's a C++ object.

00:18:13.200 --> 00:18:16.200
One concept with plugs is that
they don't exist on their own.

00:18:16.200 --> 00:18:18.200
They're always owned by a node.

00:18:18.200 --> 00:18:21.660
And so that's something that
they'll -- within a node,

00:18:21.660 --> 00:18:24.190
you'll add a plug that provides
a mechanism to get data

00:18:24.200 --> 00:18:26.970
either in or out of your node.

00:18:27.440 --> 00:18:32.190
And it has a base class as well that
provides a lot of functionality.

00:18:32.240 --> 00:18:34.200
So what are the mechanics
of the Shake Node engine?

00:18:34.200 --> 00:18:38.200
How do you actually produce
your result for Shake?

00:18:38.200 --> 00:18:41.200
Well,
there's a concept called lazy evaluation.

00:18:41.200 --> 00:18:43.860
Shake really only cares
about your output plugs,

00:18:43.880 --> 00:18:45.030
what you can produce.

00:18:45.200 --> 00:18:48.140
It's not going to ask you for any
information about your input plugs.

00:18:48.200 --> 00:18:50.160
It's only ever going to,
when it comes time to

00:18:50.160 --> 00:18:52.390
render and evaluate,
it's going to call your node and

00:18:52.390 --> 00:18:56.190
it's going to ask for information
about your output plugs.

00:18:56.300 --> 00:18:59.120
And so at that point,
once there's a request comes in for a

00:18:59.120 --> 00:19:02.640
value out of one of your output plugs,
what you'll be doing then is pulling

00:19:02.640 --> 00:19:06.110
information in from your input plugs,
whether it's input parameters

00:19:06.110 --> 00:19:08.250
that users define or it could
be data actually coming in from

00:19:08.250 --> 00:19:09.200
a node that you're connected to.

00:19:09.200 --> 00:19:14.110
So you'll be pulling on a plug,
getting data out of it, processing it,

00:19:14.130 --> 00:19:17.200
and placing that value in an output plug.

00:19:17.200 --> 00:19:20.390
And then Shake then takes that
data and moves it down to the

00:19:20.400 --> 00:19:23.590
next node or it might actually
take -- if it's image data,

00:19:23.590 --> 00:19:26.200
it'll maybe even put
it up in a render view.

00:19:28.250 --> 00:19:33.940
Let's take a look at the code structure
that supports this calling mechanism.

00:19:33.940 --> 00:19:38.450
As I said before,
Shake plugin is basically a node.

00:19:38.560 --> 00:19:41.360
It's a C++ class.

00:19:41.360 --> 00:19:47.310
In this case I've got it deriving
from the NRI node base class and

00:19:47.460 --> 00:19:52.210
there's three primary methods that
you will be working with extensively.

00:19:52.300 --> 00:19:55.430
First of all, and even though it's
probably considered best,

00:19:55.440 --> 00:19:59.000
not the best practice in C++,
but Shake plugins do a heck of

00:19:59.000 --> 00:20:01.100
a lot in their constructors.

00:20:01.100 --> 00:20:03.770
So essentially when your
constructor is called in Shake,

00:20:03.820 --> 00:20:07.300
you're going to be adding all the plugs,
the input plugs that you need,

00:20:07.300 --> 00:20:09.480
do any wiring that you
need inside of your node,

00:20:09.480 --> 00:20:12.520
any setup that you need is going
to occur in your constructor.

00:20:12.620 --> 00:20:15.500
So you'll end up doing
quite a bit of work there.

00:20:15.500 --> 00:20:18.480
Another key routine is your eval routine.

00:20:18.480 --> 00:20:21.760
This is where Shake calls for
the value of your output plugs.

00:20:21.770 --> 00:20:25.170
So any output plugs that you've
registered that Shake wants a value for,

00:20:25.290 --> 00:20:26.660
it's going to call that eval routine.

00:20:26.660 --> 00:20:31.220
With a pointer to the output plug that
it's interested in getting a value for.

00:20:31.220 --> 00:20:35.100
So you'll look at which output plug it's
asking for and do whatever you need to

00:20:35.100 --> 00:20:38.500
do to compute an updated value for Shake.

00:20:38.500 --> 00:20:41.860
And finally,
there's a virtual notify method.

00:20:41.860 --> 00:20:45.730
You can actually register with
Shake to be called when one of your

00:20:45.730 --> 00:20:48.380
input plugs is somehow modified.

00:20:48.380 --> 00:20:52.690
And so Shake will call you and
you might want to do something,

00:20:52.690 --> 00:20:56.600
either some kind of processing or
changing the structure of your node.

00:20:56.680 --> 00:20:59.460
upon the notification that you get.

00:21:00.010 --> 00:21:02.770
This is the final slide.

00:21:02.980 --> 00:21:05.370
Something that's very important
for Shake plug-in developers,

00:21:05.370 --> 00:21:06.830
I do quite a bit of Shake SDK support.

00:21:06.830 --> 00:21:12.390
One of the things that we find is that
Shake provides quite a rich set of

00:21:12.560 --> 00:21:15.900
base classes that you can start from.

00:21:15.900 --> 00:21:20.120
We talked about the NRI node
base class a couple slides back,

00:21:20.120 --> 00:21:24.320
but as a plug-in developer,
you will rarely start and derive

00:21:24.430 --> 00:21:26.900
from that base class directly.

00:21:26.900 --> 00:21:28.680
There's a number of base
classes depending upon the

00:21:28.730 --> 00:21:32.450
operation that you want to do,
whether it's a filter that takes one,

00:21:32.460 --> 00:21:36.370
two, or N number of input images,
whether you're a custom

00:21:36.370 --> 00:21:37.860
widget or an overlay.

00:21:37.960 --> 00:21:40.880
That's something that we really like
to emphasize with plug-in developers

00:21:40.880 --> 00:21:43.900
is become acquainted with the base
classes that are provided by Shake.

00:21:43.900 --> 00:21:46.900
You can save yourself
a huge amount of work.

00:21:46.900 --> 00:21:50.900
There's a lot of functionality
built into those base classes.

00:21:50.900 --> 00:21:54.190
That wraps up my presentation,
and at this point,

00:21:54.210 --> 00:21:56.600
I'd like to introduce Donald Liu.

00:22:07.320 --> 00:22:13.150
How are you doing?

00:22:13.430 --> 00:22:15.360
Today I'll be showing an
overview of FXScript and a

00:22:15.360 --> 00:22:15.360
couple of demos at the end.

00:22:20.260 --> 00:22:24.000
So, what is FXScript?

00:22:24.050 --> 00:22:27.690
FXScript is a video scripting
language used to create video

00:22:27.690 --> 00:22:30.180
effects for Final Cut Pro.

00:22:30.800 --> 00:22:37.300
[Transcript missing]

00:22:37.920 --> 00:22:44.360
It's procedural language.

00:22:44.360 --> 00:22:44.360
It's parsed and interpreted at runtime.

00:22:45.590 --> 00:22:52.530
Since it's built-in,
it uses the same rendering

00:22:52.530 --> 00:22:52.530
engine as Final Cut Pro.

00:22:54.330 --> 00:22:57.540
There are over 150 effects
in Final Cut Pro which

00:22:57.540 --> 00:23:00.210
are written in FXScript.

00:23:03.580 --> 00:23:10.150
These are some of the features
available in FXScript.

00:23:10.150 --> 00:23:10.150
Variable types.

00:23:11.020 --> 00:23:15.900
You can declare multi-dimensional
arrays up to five levels:

00:23:17.530 --> 00:23:19.600
built-in functions,

00:23:20.630 --> 00:23:31.090
Standard Input Controls,
and Loops and Branches.

00:23:31.090 --> 00:23:31.090
The subroutine supports
recursion up to 12 levels.

00:23:47.320 --> 00:23:51.860
There are three types of
effects in Final Cut Pro that

00:23:52.060 --> 00:23:56.600
you can create using FXScript.

00:23:56.600 --> 00:23:56.600
Filters for single video streaming,

00:23:58.160 --> 00:24:11.470
Transitions for two video streams.

00:24:11.470 --> 00:24:11.470
And there's a generator,
which is a special type of clip,

00:24:11.470 --> 00:24:11.470
such as text or particle generators.

00:24:17.500 --> 00:24:24.400
Final Cut Pro has a built-in tool which
you can edit and preview your script.

00:24:25.360 --> 00:24:27.510
There are three windows.

00:24:31.070 --> 00:24:34.800
You can edit your script
in the text entry window.

00:24:34.800 --> 00:24:38.990
You can run and see your
effect in the preview window.

00:24:40.850 --> 00:24:49.210
And then you can adjust
your input controls.

00:24:49.210 --> 00:24:49.210
You can edit your parameters
in your input control windows.

00:24:51.850 --> 00:25:00.210
There are several ways of
saving your script in FXBuilder.

00:25:00.210 --> 00:25:00.210
You can directly add your
effect to your project.

00:25:01.440 --> 00:25:09.810
Or you can make a favorite effect,
which is saved in your preference file.

00:25:09.810 --> 00:25:09.810
Or you can save it as a text file.

00:25:10.200 --> 00:25:17.070
You can save as a plug-in or you
can save it as an encrypted plug-in.

00:25:18.500 --> 00:25:24.350
Once you encrypt your script,
you cannot view the script again.

00:25:26.640 --> 00:25:36.900
All the plug-ins,
all the effects in Final Cut Pro are

00:25:36.900 --> 00:25:36.900
saved as text files,
so you can view them in an FX builder

00:25:36.900 --> 00:25:36.900
or in any other text editor.

00:25:41.200 --> 00:25:43.600
This is an example of FXScript.

00:25:44.770 --> 00:25:48.520
There are two sections,
the header and the body.

00:25:49.490 --> 00:25:53.530
In the header, you define the type and
the name of the effect.

00:25:53.630 --> 00:25:57.490
You can also define the input parameters.

00:25:57.890 --> 00:26:02.190
The main body starts
with the keyword "code."

00:26:16.670 --> 00:26:19.240
So who is this for?

00:26:19.250 --> 00:26:26.420
For Final Cut Pro developers,
post-Effect houses, and advanced users.

00:26:26.720 --> 00:26:36.500
And now I'm ready to show you a demo.

00:26:42.260 --> 00:26:43.040
Okay.

00:26:43.040 --> 00:26:47.760
This is one of the filters I wrote.

00:26:52.400 --> 00:26:53.950
Let me turn this up in here.

00:26:54.030 --> 00:26:54.830
So this is a rock.

00:26:55.040 --> 00:27:05.320
If I turn off this filter,
I can see an object in front of the car.

00:27:05.320 --> 00:27:05.320
So I want to remove that object.

00:27:07.500 --> 00:27:11.930
This filter removes that object.

00:27:11.930 --> 00:27:13.130
And let's open that up in FX Builder.

00:27:22.780 --> 00:27:34.140
So I'll be customizing this in just a
few minutes for this sequence right here.

00:27:34.200 --> 00:27:38.890
So this sequence has a diagonal object.

00:27:41.300 --> 00:27:48.040
And I'll be removing that object
by customizing this effect.

00:27:48.160 --> 00:27:53.290
First of all,
I'll be adding an input parameter.

00:28:05.100 --> 00:28:19.000
[Transcript missing]

00:28:23.500 --> 00:28:37.860
The Rotate function: Polygon,
the Center Point, the amount of rotation,

00:28:37.860 --> 00:28:39.690
and the aspect ratio.

00:28:39.690 --> 00:28:39.690
Let's just run this to make
sure there's no syntax error.

00:28:41.480 --> 00:28:48.430
So you can see right here,
there's a new angle control right here.

00:28:53.700 --> 00:29:12.900
[Transcript missing]

00:29:16.500 --> 00:29:25.900
[Transcript missing]

00:29:28.630 --> 00:29:31.070
Then, offset the timer.

00:29:31.070 --> 00:29:37.360
And let's just adjust a
little bit the source.

00:29:42.700 --> 00:29:45.260
Just get rid of the overlay.

00:29:45.270 --> 00:29:46.690
Soften the edges.

00:29:46.700 --> 00:29:49.930
There you go.

00:30:00.990 --> 00:30:09.900
In my second demo,
I'll be showing how to make

00:30:09.900 --> 00:30:11.070
a call to a built-in filter.

00:30:13.100 --> 00:30:17.600
So this is a generator which
generates a random pattern.

00:30:19.090 --> 00:30:23.910
Let's just open this in our FX Builder.

00:30:30.400 --> 00:30:32.400
Let's just run this.

00:30:32.400 --> 00:30:38.440
It's just random pattern.

00:30:38.440 --> 00:30:45.760
And I like to make a function call to
one of the filters in Final Cut Pro.

00:30:45.980 --> 00:30:49.910
Just stop this for a second.

00:30:59.100 --> 00:31:07.100
[Transcript missing]

00:31:08.070 --> 00:31:13.260
So I'll be making a quick call
to find edges to this pattern.

00:31:13.260 --> 00:31:20.410
So I'm going to temporarily save
the image to a temporary buffer.

00:31:23.820 --> 00:31:27.340
I'm going to make a call filter.

00:31:27.340 --> 00:31:33.590
And the name of the filter,
which is find edges.

00:31:34.870 --> 00:31:40.110
And then the source,
which I copied it to buffer.

00:31:40.630 --> 00:31:42.990
And then the destination.

00:31:43.290 --> 00:31:49.360
And then frame, duration, and frame rate.

00:31:49.360 --> 00:31:53.870
So let's run that.

00:31:57.300 --> 00:32:04.800
[Transcript missing]

00:32:05.200 --> 00:32:14.330
And you don't have to even type or copy
and paste the script of the find edges.

00:32:14.700 --> 00:32:20.200
This should eliminate such problem
as variable name collisions,

00:32:20.200 --> 00:32:20.200
typos, and other problems.

00:32:25.820 --> 00:32:36.770
And you can, once you make this change,
you can save as a plug-in,

00:32:36.770 --> 00:32:36.770
but this time I'm going to make it

00:32:42.820 --> 00:32:43.800
Where is it?

00:32:45.700 --> 00:32:47.910
Make Fabric Effect, right here.

00:32:49.360 --> 00:32:57.290
If you look in here,
it will save it as a favorite

00:32:57.290 --> 00:32:57.290
effect and you can use it.

00:33:01.900 --> 00:33:08.910
So let's close that.

00:33:08.910 --> 00:33:12.450
And in my third demo,
I'll be showing performance

00:33:12.450 --> 00:33:12.450
issues in FXBuilder.

00:33:17.210 --> 00:33:18.360
Let's open this.

00:33:18.410 --> 00:33:22.040
This is a particle generator.

00:33:22.070 --> 00:33:24.000
Let's open this up.

00:33:24.000 --> 00:33:28.070
Let's run this.

00:33:36.910 --> 00:33:40.420
We have all these
parameters you can control:

00:33:40.420 --> 00:33:55.450
gravity, initial velocity, speed, decay,
the size of the particles, softness,

00:33:55.450 --> 00:33:55.450
you can change the color,

00:34:00.400 --> 00:34:14.300
[Transcript missing]

00:34:14.740 --> 00:34:20.990
If I add any more particles,
you will see degradation in performance.

00:34:23.600 --> 00:34:30.200
[Transcript missing]

00:34:37.700 --> 00:34:48.500
[Transcript missing]

00:34:49.790 --> 00:34:58.080
Now this is drawing 10 times 100,
over 1,000 particles.

00:35:04.400 --> 00:35:11.210
This has same control,
some similar controls as the first one.

00:35:14.500 --> 00:35:22.000
[Transcript missing]

00:35:22.710 --> 00:35:31.430
Now, I've included Bezier curve to this,
so I can control the

00:35:31.430 --> 00:35:31.430
path of the particles.

00:36:03.430 --> 00:36:10.970
So with all the additional calculation,
you don't see any performance

00:36:10.970 --> 00:36:10.970
difference between these two right here.

00:36:21.740 --> 00:36:25.860
Okay, that concludes my
demonstration for FXScript.

00:36:25.860 --> 00:36:38.780
And next, I'll be, I think,
Avi will be up here to show

00:36:38.780 --> 00:36:38.780
you AfterEffects plug-ins.

00:36:38.780 --> 00:36:38.780
Thank you.

00:36:44.800 --> 00:36:45.640
Thank you.

00:36:45.640 --> 00:36:51.500
So my name's Avi Chaplinsky,
I'm one of the engineers

00:36:51.500 --> 00:36:53.420
on Final Cut Pro,
and I'm here to talk about

00:36:53.420 --> 00:36:55.730
After Effects plugin support
inside Final Cut Pro.

00:36:55.820 --> 00:37:01.680
So as a bit of an intro,
I'm just gonna cover some of the basics,

00:37:01.680 --> 00:37:04.940
'cause some of you may be aware of this,
and some of you may not be.

00:37:04.970 --> 00:37:06.400
So what is After Effects?

00:37:06.400 --> 00:37:10.960
After Effects is Adobe's package for
2D and 3D compositing and effects

00:37:11.210 --> 00:37:14.040
for video and motion graphics.

00:37:14.040 --> 00:37:15.420
What are After Effects plugins?

00:37:15.420 --> 00:37:19.360
After Effects plugins are usually
third-party developed modules

00:37:19.360 --> 00:37:22.510
that add some functionality
to the host application.

00:37:22.850 --> 00:37:29.000
These are typically things like effects,
titlers, keyers, time remappers,

00:37:29.000 --> 00:37:32.800
but really there's a
wide variety out there.

00:37:32.800 --> 00:37:36.800
Now, why does Final Cut Pro support
the After Effects plugin?

00:37:36.800 --> 00:37:40.900
Well, it is a public SDK,
so it's available for everyone

00:37:40.900 --> 00:37:42.700
to download and play with.

00:37:42.700 --> 00:37:48.520
And, when Final Cut Pro came onto the
market and in the intervening time,

00:37:48.550 --> 00:37:53.800
the After Effects plugin has sort of
developed into a de facto standard for,

00:37:53.950 --> 00:37:59.480
well, cross-application plugins.

00:37:59.640 --> 00:38:03.480
So it's actually supported by several
other applications besides After Effects.

00:38:03.550 --> 00:38:06.080
From Adobe,
Premiere has support for them,

00:38:06.120 --> 00:38:10.920
but also Combustion and Commotion also
have support for After Effects plugins.

00:38:11.040 --> 00:38:12.520
So for people developing them,
and if they're interested,

00:38:12.520 --> 00:38:14.520
if you're developing them
in a third-party setting,

00:38:14.540 --> 00:38:18.520
your audience is a lot wider than any
one specific application standard,

00:38:18.560 --> 00:38:22.710
because it's embraced by
several competing applications.

00:38:22.930 --> 00:38:26.210
So in this brief presentation,
I'm just going to cover some of what's

00:38:26.350 --> 00:38:28.800
of interest to us in Final Cut Pro.

00:38:28.800 --> 00:38:32.650
So that is what works
inside Final Cut Pro,

00:38:32.800 --> 00:38:40.590
any limitations,
and some Final Cut Pro specific

00:38:40.590 --> 00:38:40.590
API that we've added in the
last release of Final Cut Pro.

00:38:41.400 --> 00:40:08.100
[Transcript missing]

00:40:08.910 --> 00:40:11.240
Okay,
so some limitations to our implementation

00:40:11.300 --> 00:40:12.420
of the After Effects standard.

00:40:12.420 --> 00:40:17.890
In Final Cut Pro, we don't allow plug-in
defined on-frame UI elements.

00:40:17.900 --> 00:40:21.960
So if you require the user to
directly interact with the frame

00:40:21.960 --> 00:40:28.770
in order to place elements or to
pick up various kinds of things,

00:40:28.810 --> 00:40:31.440
then you can't do it directly
in the Final Cut Pro UI.

00:40:31.440 --> 00:40:33.540
Typically, if this is the kind of
thing you need to do,

00:40:33.540 --> 00:40:37.460
you'll want to do your own UI on top,
and you can pull the frame out and

00:40:37.460 --> 00:40:42.200
draw whatever you want on top of it and
let the user interact in your own UI.

00:40:42.200 --> 00:40:47.110
We support only 8-bit RGB rendering,
although Final Cut Pro 4 has a

00:40:47.130 --> 00:40:54.720
brand-new 32-bit float rendering engine
for After Effects in Final Cut Pro.

00:40:54.720 --> 00:40:59.420
The greater-than-8-bit format defined
in After Effects is 16-bit integer,

00:40:59.420 --> 00:41:02.780
which is not something we have
native support for in Final Cut Pro.

00:41:02.780 --> 00:41:06.110
Another key thing to keep in mind,
especially as you're working on your own,

00:41:06.180 --> 00:41:09.990
as you make more elaborate plug-ins,
is we don't allow

00:41:09.990 --> 00:41:11.350
dynamic parameter lists.

00:41:11.500 --> 00:41:16.370
These typically are if the list of
parameters you have wants to depend

00:41:16.370 --> 00:41:20.150
on the state of a pop-up or something,
then we can't allow

00:41:20.310 --> 00:41:22.100
that in Final Cut Pro.

00:41:22.100 --> 00:41:26.950
All the parameters that your effect
has need to be static and defined

00:41:26.950 --> 00:41:29.120
when the effect is initially read in.

00:41:29.120 --> 00:41:31.390
So basically,
Final Cut Pro doesn't really

00:41:31.390 --> 00:41:34.360
have an analogous construct to
changing the number of parameters,

00:41:34.360 --> 00:41:35.970
so we don't allow it.

00:41:36.140 --> 00:41:40.310
for the After Effects plugins themselves.

00:41:43.360 --> 00:41:47.930
All right, so a quick overview
of some new API calls.

00:41:47.960 --> 00:41:53.130
So we added some that these are useful
if you're trying to better integrate

00:41:53.130 --> 00:41:56.280
your plug-in into Final Cut Pro,
and they deal with some

00:41:56.530 --> 00:41:59.400
of the differences between
After Effects and Final Cut Pro.

00:41:59.400 --> 00:42:04.700
There's also a few that are particularly
useful if you have your own custom

00:42:04.700 --> 00:42:08.600
UI that you're drawing and you want
to interact with the application,

00:42:08.620 --> 00:42:12.670
and particularly if you'd like to
send frames out to the currently

00:42:12.670 --> 00:42:14.650
enabled video out device.

00:42:15.160 --> 00:42:20.730
So briefly, there are four new calls
in Final Cut Pro 4.

00:42:20.820 --> 00:42:22.740
The first two are rather simple.

00:42:22.740 --> 00:42:26.200
They simply allow you to retrieve
the current version number of the

00:42:26.200 --> 00:42:28.260
Final Cut Pro you're running under.

00:42:28.390 --> 00:42:31.470
So there's the major version number,
things like 3, 4,

00:42:31.470 --> 00:42:34.540
and then the minor version
number for the dot releases.

00:42:35.640 --> 00:42:41.180
The third one is just a call to cause
Final Cut Pro to redraw all of its UI.

00:42:41.270 --> 00:42:45.150
This is good if you've drawn custom
UI on top that might have interfered

00:42:45.150 --> 00:42:49.080
with or drawn on top of any of
it or otherwise damaged the UI.

00:42:49.080 --> 00:42:52.720
When your plug-in is completed running,
you'll probably want to call this

00:42:52.720 --> 00:42:55.510
function to just make sure the
UI is in a good state when the

00:42:55.510 --> 00:42:57.580
user comes back into Final Cut Pro.

00:42:57.580 --> 00:43:00.670
The last one is what's
of particular interest,

00:43:00.700 --> 00:43:02.920
again, if you have custom UI.

00:43:02.920 --> 00:43:07.690
So it allows you to...
force the viewer or canvas,

00:43:07.750 --> 00:43:11.320
the window that the user
is seeing for the clip that

00:43:11.320 --> 00:43:14.090
they've applied your effect to,
to move to a particular

00:43:14.090 --> 00:43:15.560
frame inside the clip.

00:43:15.580 --> 00:43:19.120
What this means is that if you've got
your own UI with maybe your own kind

00:43:19.120 --> 00:43:22.580
of timeline and you want the user to
be able to scrub through the clip,

00:43:22.650 --> 00:43:25.520
you can call back into
Final Cut Pro and have

00:43:25.520 --> 00:43:28.280
Final Cut Pro move to that same frame.

00:43:28.280 --> 00:43:32.290
And what that really gets you is not
only showing it in the Final Cut Pro UI,

00:43:32.290 --> 00:43:35.400
but if there's a video
device turned on and enabled.

00:43:35.640 --> 00:43:39.560
Final Cut Pro will want to do
the rendering for that new frame,

00:43:39.560 --> 00:43:42.880
which, since it'll call you if
you're in the render stack,

00:43:42.890 --> 00:43:45.690
that'll let you push your frame
with all your effects out to the

00:43:45.750 --> 00:43:49.430
video out device directly without
having to worry about writing

00:43:49.430 --> 00:43:52.820
your own interface to do all that.

00:43:53.740 --> 00:43:56.520
So in order to support
those additional calls,

00:43:56.530 --> 00:44:00.400
what we've done is added a single
function pointer that you call

00:44:00.400 --> 00:44:04.120
that's in the PFUtil callback,
if anyone's familiar.

00:44:04.120 --> 00:44:09.050
But that's basically a set of utility
callback function pointers that the host

00:44:09.050 --> 00:44:11.830
application provides to every plug-in.

00:44:11.900 --> 00:44:14.190
In this case, the host is Final Cut Pro.

00:44:14.380 --> 00:44:17.120
If you call that function at
the bottom to get the private

00:44:17.260 --> 00:44:19.950
callbacks with a block of memory,
then we'll fill in those

00:44:19.980 --> 00:44:23.240
function pointers for you,
and then you can just call them directly

00:44:23.390 --> 00:44:25.430
to do basically what I outlined before.

00:44:28.950 --> 00:44:35.080
Okay, so quickly in summary,
the After Effects API is a very

00:44:35.090 --> 00:44:39.020
useful way to add additional
image processing to Final Cut Pro.

00:44:39.020 --> 00:44:44.670
This is particularly true for those
in the third-party setting because

00:44:44.670 --> 00:44:50.260
since it's a standard API that's
supported by several other applications,

00:44:50.260 --> 00:44:54.280
it's a good opportunity to sell to a
wider audience than just one application.

00:44:54.300 --> 00:44:57.300
But of course,
keep in mind that we only support a

00:44:57.300 --> 00:44:59.280
subset of the full After Effects API.

00:44:59.280 --> 00:45:02.280
This subset is what we
felt was most important and

00:45:02.280 --> 00:45:08.850
appropriate for Final Cut Pro,
and it's, yeah, what we felt was what you

00:45:08.850 --> 00:45:11.090
would need to best interact.

00:45:11.160 --> 00:45:15.780
But a good thing to keep in mind is that
we really would welcome your feedback.

00:45:15.780 --> 00:45:19.360
If there's pieces of the
SDK that we don't support or

00:45:19.390 --> 00:45:22.880
that might have been added since
we have done our last revision,

00:45:22.880 --> 00:45:26.820
we'd be very interested to hear from
people on what they... what they'd be

00:45:26.820 --> 00:45:30.730
looking for to give us an idea of what
the benefits might be because if it,

00:45:30.730 --> 00:45:34.140
you know, if it looks good,
we'd like to add any support we can in

00:45:34.210 --> 00:45:36.760
order to make your lives a little easier.

00:45:36.760 --> 00:45:40.200
So we'd really encourage feedback,
not only now,

00:45:40.200 --> 00:45:44.000
but later there'll be some email
addresses we'll post at the end

00:45:44.000 --> 00:45:47.930
to give you a forum to provide
that kind of feedback to us.

00:45:50.000 --> 00:45:53.730
Okay, well that is basically everything
I wanted to talk about,

00:45:53.730 --> 00:45:56.480
so I'm going to welcome
David Black up to talk about

00:45:56.480 --> 00:45:58.900
some future plug-in directions.

00:45:58.990 --> 00:46:00.970
Thank you.

00:46:06.620 --> 00:46:08.500
Good afternoon.

00:46:08.500 --> 00:46:11.120
I'd like to spend a little bit of
time talking about sort of where

00:46:11.120 --> 00:46:14.500
the future lies with plug-ins and
Apple's Pro Video Applications.

00:46:14.630 --> 00:46:17.220
Plug-ins, we've seen,
are very important to us and sort of

00:46:17.220 --> 00:46:20.940
want to take things to the next level
and only increase the opportunities

00:46:20.970 --> 00:46:22.690
for developers going forward.

00:46:22.850 --> 00:46:26.340
really what sort of our core direction
comes down to trying to move to a unified

00:46:26.340 --> 00:46:30.000
plug-in model where it makes sense
for Apple's professional applications.

00:46:30.000 --> 00:46:34.360
And it's important to note that this is
not something that's going to supplement

00:46:34.360 --> 00:46:40.040
normal current operating system plug-in
models like the audio unit specification.

00:46:40.040 --> 00:46:45.620
Really what it boils down to for us
is having a common base architecture

00:46:45.620 --> 00:46:48.780
in place across different types of
plug-ins and different applications

00:46:48.800 --> 00:46:52.500
so that it's only easier for us to
support them and you to develop them.

00:46:52.540 --> 00:46:56.840
On top of that basic layer,
we have sort of function or tasks of

00:46:56.840 --> 00:46:58.560
APIs depending on what you're doing.

00:46:58.560 --> 00:47:01.420
So there might be sort of one set of
APIs for an effect plug-in or one set

00:47:01.540 --> 00:47:03.640
of APIs for a data interchange plug-in.

00:47:03.640 --> 00:47:05.750
And really, again,
sort of the key point of all

00:47:05.750 --> 00:47:08.930
this is giving you a model
where you can know that multiple

00:47:08.930 --> 00:47:10.400
applications will support this.

00:47:10.400 --> 00:47:13.120
Certainly we're looking to commit to
support these across our applications

00:47:13.120 --> 00:47:16.430
and also provide enough detail so
that others can support it as needed.

00:47:16.440 --> 00:47:21.750
Also another key point is trying to
build the support in so that you'll

00:47:21.860 --> 00:47:22.680
have the choice of developing a
model that's going to support you and

00:47:22.680 --> 00:47:22.690
you'll have the choice of developing a
model that's going to support you and

00:47:22.690 --> 00:47:22.900
you'll have the choice of developing
a model that's going to support you.

00:47:22.930 --> 00:47:24.500
tools to use for these plug-ins.

00:47:24.500 --> 00:47:28.180
Certainly a lot of models in
the past have been very focused

00:47:28.180 --> 00:47:29.660
on C or very focused on C++.

00:47:29.660 --> 00:47:32.670
To as much of an extent as possible,
we really want to give you that

00:47:32.670 --> 00:47:35.690
choice because certainly different
tasks may require different

00:47:35.690 --> 00:47:37.970
tools and developers may be at
different technical skill levels.

00:47:40.640 --> 00:47:43.000
It's going into a little bit more detail
about what we're trying to go for.

00:47:43.000 --> 00:47:46.360
We're basing this model
on Objective-C protocols.

00:47:46.360 --> 00:47:48.320
If you're familiar with
Objective-C protocols,

00:47:48.320 --> 00:47:53.000
it's a very nice way to sort of pass data
messages between objects without being

00:47:53.000 --> 00:47:54.840
forced to rely on a common base class.

00:47:54.840 --> 00:47:57.670
And we found that actually
solved quite a few problems for

00:47:57.670 --> 00:47:58.620
us in the implementation phase.

00:47:58.620 --> 00:48:02.780
The files on disk just
stored as standard bundles.

00:48:02.780 --> 00:48:04.020
Nothing really new there.

00:48:04.020 --> 00:48:06.780
Bundles are actually great because
they put everything together,

00:48:06.780 --> 00:48:09.170
even sort of defining
multiple plugins within one,

00:48:09.830 --> 00:48:11.400
sort of to the user at least, object.

00:48:11.400 --> 00:48:15.640
We will be supporting static and or
dynamic plugin loading and registration.

00:48:15.640 --> 00:48:20.480
Your plugin may have requirements that
depend on what libraries are installed

00:48:20.480 --> 00:48:23.410
or what application is running,
or it may be very simple and just can

00:48:23.490 --> 00:48:25.020
simply document that in a structure.

00:48:25.040 --> 00:48:29.670
And services and data from the host
application will be made available

00:48:29.750 --> 00:48:32.740
via objects and callbacks so that
you'll be able to make those calls.

00:48:32.740 --> 00:48:36.130
And it won't sort of be a simple one-way
model where image buffer comes in,

00:48:36.130 --> 00:48:38.500
you do your thing, image buffer goes out,
but there is some

00:48:38.500 --> 00:48:41.590
bidirectional communication,
support in there.

00:48:42.060 --> 00:48:44.590
But you might ask,
what about other plug-in models?

00:48:44.590 --> 00:48:47.980
How does this relate to everything we've
been doing and sort of new industry

00:48:48.160 --> 00:48:50.000
standards that may be coming out?

00:48:50.140 --> 00:48:53.420
Really, this is meant to be a
superset of a lot of things.

00:48:53.440 --> 00:48:56.700
For us, it's very important to
support what makes sense,

00:48:56.740 --> 00:48:59.510
but at the same time,
providing sort of native engineering

00:48:59.520 --> 00:49:02.320
support for multiple plug-in models
at the core application level

00:49:02.390 --> 00:49:04.790
is really kind of a lot of work.

00:49:04.880 --> 00:49:07.090
By building sort of a
superset glue layer,

00:49:07.090 --> 00:49:09.590
we hope to support more plug-in APIs,
not fewer,

00:49:09.770 --> 00:49:13.420
and also leverage those efforts
across multiple applications.

00:49:13.510 --> 00:49:15.600
And to this end,
it actually is designed to

00:49:15.700 --> 00:49:18.340
support adapter or host plug-ins,
so that you can sort of

00:49:18.370 --> 00:49:20.710
have that indirection of
you have a pro-application,

00:49:20.850 --> 00:49:25.590
you'll have a pro-application plug-in,
and then an adapter layer that goes

00:49:25.600 --> 00:49:28.750
off to some other vendor's code.

00:49:28.840 --> 00:49:31.890
And we are certainly intending
to provide those adapters for the

00:49:31.890 --> 00:49:34.840
most popular plug-ins and support
developers in providing more.

00:49:34.840 --> 00:49:36.070
are.

00:49:37.810 --> 00:49:39.520
So I might ask,
when will this be available?

00:49:39.520 --> 00:49:43.580
We're going to begin to roll this out
later this year on top of Final Cut Pro.

00:49:43.580 --> 00:49:47.400
The first sort of functional API we're
going to implement is a data interchange

00:49:47.470 --> 00:49:50.900
model based around the XML data format
that we discussed earlier this week.

00:49:50.900 --> 00:49:53.360
In brief,
we're essentially making the entire

00:49:53.360 --> 00:49:57.560
contents of a Final Cut Pro project
available via XML to developers

00:49:57.560 --> 00:49:58.620
in a very clean manner.

00:49:58.620 --> 00:50:02.400
And this is really giving you a
programmatic interface to define commands

00:50:02.400 --> 00:50:06.000
within the Final Cut Pro application
environment that receive this data,

00:50:06.640 --> 00:50:09.000
perform necessary translations,
and do something useful with it.

00:50:09.060 --> 00:50:11.840
We'll be releasing a public
beta of this in August.

00:50:11.840 --> 00:50:12.790
That's our current intention.

00:50:12.800 --> 00:50:16.360
If you watch the Final Cut Pro website,
details will be up there,

00:50:16.360 --> 00:50:18.900
all so you can get in contact
with developer relations,

00:50:18.900 --> 00:50:20.000
and they'll make sure you're in the loop.

00:50:20.060 --> 00:50:24.510
And the intention is also to release
this in final form to developers

00:50:24.510 --> 00:50:25.880
and users by the end of the year.

00:50:25.880 --> 00:50:29.270
Earlier this week,
one of the demonstrations at the data

00:50:29.320 --> 00:50:33.920
interchange session was AutomaticDuck,
providing AAF import and export

00:50:33.920 --> 00:50:35.720
support for Final Cut Pro.

00:50:36.440 --> 00:50:39.830
AAF being the advanced authoring format,
an industry-standard binary

00:50:39.830 --> 00:50:43.140
container format intended to take
data between editing applications.

00:50:43.140 --> 00:50:46.840
That plugin is currently sitting
on top of a very early version

00:50:46.840 --> 00:50:49.510
of this plugin specification,
and it's basically a great proof

00:50:49.550 --> 00:50:50.820
of concept for the whole idea.

00:50:50.820 --> 00:50:54.750
So to sort of now summarize
the entire session here,

00:50:59.170 --> 00:51:02.310
All of our applications
support plug-in models.

00:51:02.530 --> 00:51:05.010
This is really very important to us.

00:51:05.010 --> 00:51:11.140
Logic, Soundtrack, and also, excuse me,
Logic, Soundtrack support audio units.

00:51:11.140 --> 00:51:14.420
Shake, of course,
supports Shake plug-ins.

00:51:14.420 --> 00:51:18.260
And Final Cut Pro supports audio units,
AfterEffects,

00:51:18.280 --> 00:51:20.820
and FXScript plug-ins at this time.

00:51:20.820 --> 00:51:23.120
Of course, we're hoping to make
this list grow over time,

00:51:23.120 --> 00:51:23.120
both with your help and with
new technologies internally.

00:51:23.820 --> 00:51:26.450
And really, they're important,
and they're not only important

00:51:26.500 --> 00:51:27.950
to Apple and important to you,
but they're really

00:51:28.010 --> 00:51:28.830
important to end users.

00:51:28.840 --> 00:51:34.240
Really, no one tool can do it all,
and providing plugins allows end

00:51:34.240 --> 00:51:38.230
users to get the tools they want,
sort of unique tools that Apple may not

00:51:38.310 --> 00:51:42.090
develop to be integrated into that space,
and it really gives the end users more

00:51:42.090 --> 00:51:43.740
control over their product in the end.

00:51:43.740 --> 00:51:45.660
And it also just helps
advance technology.

00:51:45.660 --> 00:51:47.860
Certainly,
we're not going to think of everything,

00:51:47.860 --> 00:51:53.100
and by at least opening that door,
it's available to put new technologies

00:51:53.100 --> 00:51:56.540
and new workflows together just as
they come up in the marketplace.

00:51:56.540 --> 00:51:59.070
And really,
we want more extensive support

00:51:59.150 --> 00:52:00.880
for plugins in the future.

00:52:00.880 --> 00:52:04.200
All the apps intend to
support more plugins.

00:52:04.200 --> 00:52:07.100
We're also trying to move toward
modern plugin architectures.

00:52:07.100 --> 00:52:08.770
As mentioned earlier,
this is not sort of a

00:52:08.770 --> 00:52:11.440
replacement for existing models,
but just sort of open the

00:52:11.440 --> 00:52:12.940
door wider to more models.

00:52:12.960 --> 00:52:15.700
And we also really want to
be able to share plugins

00:52:15.730 --> 00:52:17.720
across multiple applications.

00:52:17.720 --> 00:52:20.080
We certainly have this today with audio.

00:52:20.160 --> 00:52:21.680
We have a plugin unit
supported across Logic,

00:52:21.680 --> 00:52:24.120
Soundtrack, and Final Cut Pro,
and this just adds more

00:52:24.120 --> 00:52:27.340
value to sort of everyone,
and it's really important to us.

00:52:27.340 --> 00:52:31.080
And we want to add sort of more
and different types of APIs.

00:52:31.080 --> 00:52:34.960
Again, the data interchange
API is an example of this.

00:52:34.960 --> 00:52:38.050
Certainly, it's very simple to provide
import and export functionality

00:52:38.060 --> 00:52:40.150
with this plugin API,
but it's also there for sort

00:52:40.150 --> 00:52:43.000
of integrated tools for data
management and workflow purposes.

00:52:45.060 --> 00:52:47.820
And really,
I can't emphasize this enough,

00:52:48.010 --> 00:52:50.840
that really input from you
is very important to us.

00:52:51.030 --> 00:52:52.680
We've certainly done all our research.

00:52:52.680 --> 00:52:53.900
We have our own ideas.

00:52:53.900 --> 00:52:57.080
But we really need to know
from you what we're missing,

00:52:57.100 --> 00:52:57.850
what we're not doing.

00:52:57.970 --> 00:53:00.760
So please let us know what
sort of APIs you want,

00:53:00.960 --> 00:53:03.060
what are the development
tools you prefer to work in?

00:53:03.080 --> 00:53:04.860
Certainly,
Code Warrior and Project Builder,

00:53:04.870 --> 00:53:06.850
now Xcode, are very popular.

00:53:06.960 --> 00:53:10.600
But how much of a difference
would it make to be running from a

00:53:10.600 --> 00:53:12.790
Java IDE or even from AppleScript?

00:53:13.090 --> 00:53:16.770
And are there tools that you want
to do that you just don't know how

00:53:16.770 --> 00:53:18.790
to fit in the current framework?

00:53:18.980 --> 00:53:20.980
Certainly,
we might be able to suggest approaches

00:53:20.980 --> 00:53:24.170
with current APIs or use that
feedback to then generate new APIs in

00:53:24.170 --> 00:53:27.490
the future that are just going
to open up the platform even more.

00:53:27.650 --> 00:53:29.740
At this point,
I'd like to invite up Brett Halley

00:53:29.740 --> 00:53:32.550
to do the wrap up and do QA.

00:53:38.820 --> 00:53:41.220
Thanks very much.

00:53:41.420 --> 00:53:46.700
This week is kind of an
applications introduction to WWDC.

00:53:46.700 --> 00:53:51.300
We've worked this week to have a
number of different sessions available

00:53:51.310 --> 00:53:55.140
to you to show that we really like
to see developers get more involved

00:53:55.140 --> 00:53:57.410
in our professional applications.

00:53:57.470 --> 00:54:00.840
Be it with plug-ins,
be it cards and various

00:54:00.840 --> 00:54:05.180
type of hardware devices,
be it content creation.

00:54:05.180 --> 00:54:09.080
The plug-in session here today
is intended to be yet another way

00:54:09.080 --> 00:54:13.560
that you can participate in our
applications and to provide new

00:54:13.560 --> 00:54:20.030
products to our collective customers
and to make this a great platform.

00:54:20.080 --> 00:54:22.840
If you have questions
about any of these things,

00:54:22.840 --> 00:54:26.420
we strongly encourage you, one,
please send us feedback.

00:54:26.460 --> 00:54:27.400
We do have a feedback box.

00:54:27.400 --> 00:54:31.400
We have a feedback address,
fcpfeedback@apple.com.

00:54:31.410 --> 00:54:35.760
And our industry evangelist
for professional development

00:54:35.760 --> 00:54:38.890
and video is Jeff Lowe,
and he's the person for you to get

00:54:38.890 --> 00:54:42.730
in touch with should you have more
questions or interest in discussing

00:54:42.730 --> 00:54:44.400
opportunities in this space.
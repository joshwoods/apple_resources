WEBVTT

00:00:26.410 --> 00:00:28.660
Okay.

00:00:28.660 --> 00:00:31.260
Enough with all this JBoss and J2E crap.

00:00:31.450 --> 00:00:34.100
Finally a WebObjects session.

00:00:38.800 --> 00:00:46.100
[Transcript missing]

00:00:50.850 --> 00:00:52.700
Good afternoon, good afternoon,
early evening.

00:00:52.730 --> 00:00:55.180
My name is Brian Fitzpatrick and
I'm here with Kenny Leung and

00:00:55.180 --> 00:01:00.800
David Neumann to talk a little bit
about reusable components in WebObjects.

00:01:00.840 --> 00:01:02.510
Now,
there's a lot of different things that

00:01:02.510 --> 00:01:05.800
are reusable about WebObjects and in fact
even reusable about this presentation.

00:01:05.800 --> 00:01:07.540
So, you know,
we'll talk about some things

00:01:07.540 --> 00:01:08.770
like some reusable slides.

00:01:08.800 --> 00:01:12.080
You know, every presentation I've done
on WebObjects for the last four

00:01:12.130 --> 00:01:13.720
years has had this slide in it.

00:01:13.800 --> 00:01:15.800
Unfortunately, it has nothing to do
with reusable components,

00:01:15.800 --> 00:01:17.790
but they look great.

00:01:17.830 --> 00:01:20.430
I mean, look at the stuff you
can do with WebObjects.

00:01:22.040 --> 00:01:25.330
This is a really nice
slide from last year,

00:01:25.330 --> 00:01:27.080
WWC 2002.

00:01:27.130 --> 00:01:28.320
So this is another reusable slide.

00:01:28.320 --> 00:01:32.360
But we'd like to move on
to some reusable jokes.

00:01:32.400 --> 00:01:35.960
Anybody who caught my presentation
last year on optimizing WebObjects?

00:01:36.270 --> 00:01:36.750
Anybody?

00:01:36.750 --> 00:01:37.560
You still left?

00:01:37.560 --> 00:01:40.480
Still using WebObjects?

00:01:40.480 --> 00:01:41.410
We had a few jokes here.

00:01:41.490 --> 00:01:42.240
We have a couple questions.

00:01:42.240 --> 00:01:43.760
This is a Q&A.

00:01:43.760 --> 00:01:45.840
So to sort of get
everybody paying attention,

00:01:45.840 --> 00:01:48.920
waking up, I'm going to put a question up
there and we're going to put

00:01:48.990 --> 00:01:50.380
up a couple different answers.

00:01:50.380 --> 00:01:52.430
When you see the answer that
you think is the correct answer,

00:01:52.430 --> 00:01:53.220
I want to hear you clap.

00:01:53.220 --> 00:01:55.700
Exactly.

00:01:55.770 --> 00:01:56.720
Is that your rest pass?

00:01:56.810 --> 00:01:57.780
No?

00:01:57.830 --> 00:01:58.800
Okay.

00:01:58.800 --> 00:02:00.220
So the first question.

00:02:00.220 --> 00:02:03.120
What's the longest method
name in WebObjects?

00:02:03.120 --> 00:02:06.780
Now start clapping to the answer
because these guys have prizes

00:02:06.780 --> 00:02:09.320
which are lovely WebObjects hats.

00:02:09.320 --> 00:02:15.520
Longest method name in WebObjects
is it add objects to both

00:02:15.520 --> 00:02:18.510
sides of relationship with key.

00:02:18.660 --> 00:02:19.350
Oh, it gets better.

00:02:19.360 --> 00:02:21.100
It gets much better.

00:02:21.100 --> 00:02:22.510
Is it database context?

00:02:22.610 --> 00:02:24.540
We'll run login panel to
open database channel.

00:02:27.100 --> 00:02:28.800
That's a delegate,
so it's kind of cheating, isn't it?

00:02:28.800 --> 00:02:29.240
Yeah, it's kind of cheating.

00:02:29.240 --> 00:02:29.920
Yeah, well.

00:02:29.920 --> 00:02:31.170
But we've got this one.

00:02:31.180 --> 00:02:34.680
Adaptive channels should construct
stored procedure return values.

00:02:34.720 --> 00:02:38.200
Nobody thinks that's a long...
You see empty space down there.

00:02:38.200 --> 00:02:39.440
You're expecting
something a little bigger?

00:02:46.700 --> 00:02:51.460
We do have one more that's a little bit
too long to fit onto this one screen.

00:02:51.460 --> 00:02:55.540
So, anyway.

00:03:00.740 --> 00:03:04.140
So what is the most popular
WebObjects movie this summer?

00:03:04.140 --> 00:03:05.700
We have a lot of movies out this summer.

00:03:05.700 --> 00:03:06.540
- I Need Nemo.

00:03:06.540 --> 00:03:07.500
- I Need Nemo.

00:03:07.500 --> 00:03:08.320
- Oh, come on.

00:03:08.340 --> 00:03:11.320
We have the NS Matrix Reloaded.

00:03:13.740 --> 00:03:16.460
We have Xcode 2, Code United.

00:03:16.460 --> 00:03:18.100
That was a popular one.

00:03:18.210 --> 00:03:19.700
I don't hear any clapping.

00:03:19.700 --> 00:03:21.140
NSD Bugrats?

00:03:21.140 --> 00:03:25.940
Did anybody catch that?

00:03:26.020 --> 00:03:28.300
Terminate Application 3,
the rise of the virtual machine?

00:03:28.300 --> 00:03:36.090
Or is it finding EO?

00:03:45.310 --> 00:03:46.790
Okay.

00:03:46.830 --> 00:03:49.490
What's the best name for
the release notes to get

00:03:49.490 --> 00:03:51.460
people to actually read them?

00:03:51.460 --> 00:04:00.910
Is it "Don't Read Me"? "Nothing to
See Here"? "EOEditingContext.java"?

00:04:04.300 --> 00:04:11.400
[Transcript missing]

00:04:15.840 --> 00:04:16.790
Okay.

00:04:16.790 --> 00:04:19.840
We got all that out of the way now.

00:04:19.840 --> 00:04:22.940
Now we're going to talk about
actual reusable components.

00:04:22.940 --> 00:04:27.180
We're going to talk about a
number of different things.

00:04:27.180 --> 00:04:29.450
But the first thing I want to point out
is that this is an advanced session.

00:04:29.460 --> 00:04:31.910
A lot of people in the past have
asked for an advanced session.

00:04:31.910 --> 00:04:34.650
They want a session where we can
talk about doing some stuff with

00:04:34.690 --> 00:04:38.710
WebObjects that you don't normally see
or figure out the first six months,

00:04:38.710 --> 00:04:41.020
a year or two using WebObjects.

00:04:41.120 --> 00:04:45.040
So the first thing we're going
to talk about is commitment.

00:04:45.140 --> 00:04:49.410
Okay, when designing reusable components,
if EOF is all about relationships

00:04:49.510 --> 00:04:52.900
and reusable components are
about commitment and bindings,

00:04:52.900 --> 00:04:56.420
you should strive for... Am I missing
something in the background here?

00:04:56.420 --> 00:04:57.570
Okay.

00:04:58.010 --> 00:05:00.830
You should strive for loose
bindings and low commitment.

00:05:00.930 --> 00:05:02.560
What do you mean by commitment?

00:05:02.560 --> 00:05:06.980
We mean frameworks to include.

00:05:06.980 --> 00:05:06.980
You want to--

00:05:07.240 --> 00:05:08.400
Is there something funny going on here?

00:05:08.400 --> 00:05:10.080
What am I missing here?

00:05:10.080 --> 00:05:11.100
Mostly men in this room.

00:05:11.160 --> 00:05:12.500
Mostly men in this room?

00:05:12.660 --> 00:05:13.760
Oh, well, my wife's out here somewhere.

00:05:13.760 --> 00:05:15.690
Commitment.

00:05:15.690 --> 00:05:17.130
Frameworks to include.

00:05:17.130 --> 00:05:18.760
Reusable components.

00:05:18.760 --> 00:05:21.960
If you really want people to
reuse your components or you want

00:05:21.960 --> 00:05:24.300
to reuse your own components,
you want to have as little

00:05:24.300 --> 00:05:25.700
commitment as possible.

00:05:25.870 --> 00:05:28.640
You want to use the least
amount of frameworks to include.

00:05:28.680 --> 00:05:30.970
You want to have the least amount of
interfaces and the least amount of

00:05:30.970 --> 00:05:33.320
bindings that are absolutely necessary.

00:05:33.420 --> 00:05:36.170
So if you have a component that
someone's going to drag into their

00:05:36.180 --> 00:05:39.590
other component and bind up to that,
you may have 5, 10,

00:05:39.590 --> 00:05:42.470
20 different bindings,
but maybe only one or

00:05:42.480 --> 00:05:44.280
two of them are required.

00:05:44.280 --> 00:05:46.400
Or it only works with enterprise objects.

00:05:46.500 --> 00:05:48.840
Maybe that's a requirement
of your component.

00:05:48.840 --> 00:05:51.350
Maybe you can just get
by with key value coding.

00:05:51.900 --> 00:05:53.680
So that's what the most
important thing is,

00:05:53.680 --> 00:05:56.340
is about commitment and how
to deal with the bindings.

00:05:56.340 --> 00:05:58.720
So we're going to do a
little introduction now,

00:05:58.720 --> 00:06:02.470
and then Kenny's going to come on and
talk about bindings and how to use

00:06:02.750 --> 00:06:07.580
bindings in the most efficient manner and
smart bindings and that sort of thing.

00:06:08.170 --> 00:06:10.240
Dave's going to come on and
talk about component content.

00:06:10.240 --> 00:06:13.740
I'll come back and I'm going to
talk about streaming HTTP requests.

00:06:13.740 --> 00:06:15.960
Boy, we've got something great there.

00:06:15.960 --> 00:06:20.570
Then we've got some different tips and
tricks and a section we like to call Dr.

00:06:20.670 --> 00:06:25.200
Evil, which is going to talk about some
things that you can do with WebObjects

00:06:25.200 --> 00:06:28.960
and the WebObjects framework,
but a little on the edge.

00:06:28.960 --> 00:06:30.860
And then finally,
we have a few examples to show

00:06:30.860 --> 00:06:32.240
you of reusable components.

00:06:32.240 --> 00:06:36.650
So reusable components are
WebObjects GUI widgets.

00:06:37.440 --> 00:06:40.120
If you're coming from Cocoa Land,
you've used Interface Builder,

00:06:40.120 --> 00:06:43.440
you've got your pallets of
different things you can use.

00:06:43.440 --> 00:06:45.670
In WebObjects,
you've got dynamic elements.

00:06:45.670 --> 00:06:49.230
Reusable components involve
taking these dynamic elements,

00:06:49.510 --> 00:06:51.760
composing them,
modifying them to make more

00:06:51.860 --> 00:06:55.910
interesting reusable components that
you can reuse either within your

00:06:55.910 --> 00:06:59.120
project or from project to project.

00:06:59.320 --> 00:07:02.440
Reusable components are subclass
as a rule of will component.

00:07:02.600 --> 00:07:05.620
And an important distinction to
make is there's no difference

00:07:05.700 --> 00:07:08.920
between a small reusable component,
that is anywhere from one character,

00:07:08.920 --> 00:07:10.780
to the size of an entire page.

00:07:10.780 --> 00:07:13.170
In fact,
when most people begin using WebObjects,

00:07:13.230 --> 00:07:15.470
most of their components
are entire pages.

00:07:15.480 --> 00:07:19.020
You can edit your reusable
components in WebObjects Builder.

00:07:19.030 --> 00:07:21.320
You can also use your
favorite text editor,

00:07:21.320 --> 00:07:23.830
Emacs, VI, Cat, Stickies,
as Steve Hayman has

00:07:23.870 --> 00:07:25.400
pointed out in the past.

00:07:26.820 --> 00:07:30.000
We talk about child components
and parent components.

00:07:30.000 --> 00:07:32.780
When a component is
within another component,

00:07:32.780 --> 00:07:34.620
that is referred to as
the child component.

00:07:34.620 --> 00:07:38.540
The component that contains that
component is referred to as the parent.

00:07:38.570 --> 00:07:40.740
So that's a little
terminology to get straight.

00:07:40.770 --> 00:07:43.590
Now, there's no limit to how deep
components can be nested.

00:07:43.590 --> 00:07:45.060
They can be arbitrarily deep.

00:07:45.060 --> 00:07:46.800
You can have three components deep.

00:07:46.800 --> 00:07:48.160
You can go 40, 50.

00:07:48.160 --> 00:07:51.830
But as you get deeper and deeper,
there's a performance price to be paid.

00:07:51.840 --> 00:07:55.220
And you would use your reusable
components just the same way

00:07:55.240 --> 00:07:56.760
that you would use WebObjects.

00:07:56.770 --> 00:07:59.000
Well, string, well, hyperlink.

00:07:59.000 --> 00:08:02.430
And you maybe use my component,
my string, or whatnot.

00:08:03.390 --> 00:08:05.320
There's a number of different
design patterns that you're all

00:08:05.320 --> 00:08:07.230
familiar with when writing software.

00:08:07.230 --> 00:08:11.290
And I'm going to talk just briefly about
some design patterns for using components

00:08:11.780 --> 00:08:13.190
in the WebObjects component model.

00:08:13.200 --> 00:08:16.890
One thing is templates,
which there's a number of different

00:08:16.890 --> 00:08:18.860
ways to deal with templates.

00:08:18.860 --> 00:08:23.190
You know that your WebObjects
components have three major parts,

00:08:23.190 --> 00:08:26.910
the Java file, the bindings file,
and the HTML file.

00:08:28.220 --> 00:08:30.420
Now, the Java file,
you can keep the same.

00:08:30.420 --> 00:08:33.770
If you create a component and
include that into your project

00:08:33.770 --> 00:08:36.430
or your other component,
but if you need the view

00:08:36.430 --> 00:08:39.560
layer to look different,
if you need the template part,

00:08:39.610 --> 00:08:43.010
the HTML markup to look differently,
what you might want to do is

00:08:43.370 --> 00:08:46.980
either subclass that component and
create a new WAD and HTML file,

00:08:46.980 --> 00:08:50.360
or you can even,
there are ways to dynamically replace

00:08:50.710 --> 00:08:53.550
the WAD and HTML file in your components.

00:08:53.620 --> 00:08:56.200
Another thing, another design pattern,
which I'm going to talk

00:08:56.200 --> 00:08:58.010
a little more about,
is mini components.

00:08:58.090 --> 00:09:01.290
Now, I've done a lot of different
WebObjects projects,

00:09:01.290 --> 00:09:05.290
and one of the favorite things
that I've used is mini components.

00:09:05.340 --> 00:09:08.970
Now, if you put everything in a very
complex page into one component,

00:09:09.070 --> 00:09:12.110
not only do you wind up with an
HTML file this big and a million

00:09:12.110 --> 00:09:15.160
bindings and a whole heap of Java,
which is a little harder

00:09:15.160 --> 00:09:18.360
to deal with and maintain,
but you also wind up with

00:09:18.460 --> 00:09:21.360
everything's kind of mooshed together.

00:09:21.360 --> 00:09:23.470
So what you start doing,
one of the first steps you do is

00:09:23.470 --> 00:09:24.830
you start dividing things out.

00:09:24.840 --> 00:09:27.590
One of the first things people
do is a header and a footer.

00:09:28.080 --> 00:09:30.100
And then they'll,
or maybe they'll wrap their

00:09:30.200 --> 00:09:31.550
page in a header and a footer.

00:09:31.560 --> 00:09:35.120
People will then create a menu
bar or a navigation bar component,

00:09:35.120 --> 00:09:36.780
different type of things.

00:09:36.780 --> 00:09:41.120
So mini components is a pattern
where you create bunches of different

00:09:41.120 --> 00:09:43.170
components and compose them.

00:09:43.220 --> 00:09:45.540
So it could also be called
component composition.

00:09:45.540 --> 00:09:49.230
So if you look up here on the screen,
you'll see we have a screenshot

00:09:49.230 --> 00:09:51.870
of a WebObjects application,
which has a navigation

00:09:52.290 --> 00:09:54.760
bar at the very top,
and it has a QuickTime VR,

00:09:54.760 --> 00:09:57.940
or in this case,
it's an image map you can click on.

00:09:58.080 --> 00:09:59.320
So you can go look at a VR.

00:09:59.360 --> 00:10:00.790
And we've got different pop-up menus.

00:10:00.890 --> 00:10:04.300
Choose a country, choose a city,
and then we've got a search box,

00:10:04.320 --> 00:10:07.550
and then below that,
we also have an image map,

00:10:07.560 --> 00:10:10.420
a clickable image map of the
world and another search box.

00:10:10.460 --> 00:10:13.590
Now looking at this,
how many components would you think on?

00:10:13.610 --> 00:10:15.830
Who thinks there's one to
five components on this page?

00:10:16.420 --> 00:10:16.850
Anyone?

00:10:16.960 --> 00:10:18.000
No one?

00:10:18.260 --> 00:10:18.910
Five to ten?

00:10:19.020 --> 00:10:19.970
Five to ten components.

00:10:20.080 --> 00:10:21.900
Anyone for ten to fifteen?

00:10:21.960 --> 00:10:22.940
Okay.

00:10:23.170 --> 00:10:27.440
We have actually, click,
about ten to fifteen components.

00:10:27.500 --> 00:10:27.980
And that isn't included.

00:10:28.150 --> 00:10:31.510
It's included the wrapper component
of the HTML header and footer,

00:10:31.510 --> 00:10:32.560
whatever or not.

00:10:32.680 --> 00:10:36.440
So including all these components,
binding them together,

00:10:36.530 --> 00:10:40.840
provides you a very powerful way
of using WebObjects components.

00:10:40.840 --> 00:10:42.910
And a lot of these
components are reusable,

00:10:42.910 --> 00:10:45.430
if not necessarily from one
application to the next,

00:10:45.430 --> 00:10:48.170
definitely within this
application and other sections.

00:10:48.340 --> 00:10:50.400
So it's something to think about.

00:10:50.910 --> 00:10:55.530
So now to talk about bindings,
I'm going to introduce Kenny Leung from,

00:10:55.560 --> 00:10:56.860
oh, you know, it's just drawing a blank.

00:10:56.860 --> 00:10:57.360
Who are you?

00:10:57.590 --> 00:10:58.150
Banzai Research Institute.

00:10:58.960 --> 00:11:00.930
Banzai Research Institute in
Southern California.

00:11:02.130 --> 00:11:03.790
Thanks, Fitz.

00:11:06.830 --> 00:11:11.330
So bindings are really the
heart of reusable components.

00:11:11.560 --> 00:11:13.550
They're the mechanism by
which reusable components

00:11:13.690 --> 00:11:15.960
communicate with their parents.

00:11:15.960 --> 00:11:20.400
You can call them arguments to
your reusable component or the

00:11:20.400 --> 00:11:22.800
API to your reusable component.

00:11:22.800 --> 00:11:25.980
And like all API,
you should try to make them

00:11:26.010 --> 00:11:28.110
lightweight and simple.

00:11:28.590 --> 00:11:32.590
We talk about bindings being pulled into
the child or pushed into the parent,

00:11:32.590 --> 00:11:35.850
the child being the reusable component,
the parent being whatever it

00:11:35.850 --> 00:11:37.500
is that you're using it in.

00:11:37.500 --> 00:11:40.640
The child is in full control
of pulling and pushing of the

00:11:40.830 --> 00:11:42.500
bindings and not the parent.

00:11:42.500 --> 00:11:46.500
The parent really can't
do anything about that.

00:11:46.640 --> 00:11:53.420
And I've seen even experienced
developers neglect this last point.

00:11:53.540 --> 00:11:56.500
You should fill out the API for
your components that way.

00:11:57.300 --> 00:11:59.430
So, in WebObjects Builder,
that's the little puzzle

00:11:59.430 --> 00:12:00.490
piece in the toolbar.

00:12:00.820 --> 00:12:04.810
And when you push it,
what you get is a little

00:12:04.810 --> 00:12:06.380
panel that pops up.

00:12:06.620 --> 00:12:10.840
And you can basically document
the bindings that your

00:12:10.840 --> 00:12:12.460
reusable component requires.

00:12:12.460 --> 00:12:15.770
Not only that,
but you can make it so that --

00:12:15.950 --> 00:12:20.130
mark some of them as required,
make it so that if one is bound,

00:12:20.160 --> 00:12:22.380
then the other -- another
one must be bound,

00:12:22.380 --> 00:12:25.110
or if one is bound,
then another one can't be bound.

00:12:25.120 --> 00:12:29.020
So it really gives you --
gives the person using it a lot

00:12:29.020 --> 00:12:33.240
of clues as to how to do it,
good documentation without their having

00:12:33.240 --> 00:12:36.680
to remember what all the bindings are,
especially if you've got a big

00:12:36.680 --> 00:12:38.430
one that has a ton of bindings.

00:12:38.500 --> 00:12:43.560
And I've got a little request to
the WAB team to actually allow

00:12:43.650 --> 00:12:46.810
us to put help in there as well.

00:12:48.800 --> 00:12:51.300
There are many ways of handling bindings.

00:12:51.460 --> 00:12:55.250
You see from auto synchronization
to all kinds of stuff,

00:12:55.250 --> 00:12:57.860
more than we can fit on the page here.

00:12:57.860 --> 00:13:01.800
Unfortunately,
there's not one way we can say

00:13:01.800 --> 00:13:05.580
is better than all the rest,
except to say that auto

00:13:05.580 --> 00:13:10.660
synchronization is probably not a
good idea for reusable components.

00:13:10.800 --> 00:13:15.720
Basically, the best thing to do is learn
how they all work and apply them

00:13:15.720 --> 00:13:18.330
properly in the right situation.

00:13:19.450 --> 00:13:21.880
and in the interest of time
I'm not going to go through all

00:13:21.880 --> 00:13:25.920
these so don't be surprised if
we skip a couple along the way.

00:13:27.620 --> 00:13:29.740
So what is auto synchronization?

00:13:29.760 --> 00:13:34.730
It's WebObjects mechanism for
automatically pushing and pulling

00:13:34.730 --> 00:13:39.970
the bindings at the appropriate times
within the request response loop.

00:13:40.320 --> 00:13:43.110
Bindings are pulled at the beginning
and end of the three phases

00:13:43.110 --> 00:13:45.690
of the request response loop,
take values from request,

00:13:45.690 --> 00:13:48.260
invoke action for request,
and append to response.

00:13:48.350 --> 00:13:51.880
They're actually pulled at the
beginning of take values from request,

00:13:51.880 --> 00:13:54.800
pushed at the end of
take values from request,

00:13:54.800 --> 00:13:57.380
and likewise in the other two phases.

00:13:57.890 --> 00:14:01.240
It's the WebObjects default,
but it's important to note

00:14:01.300 --> 00:14:04.080
that it doesn't preclude,
if you have it turned on,

00:14:04.080 --> 00:14:06.400
it doesn't preclude
manual synchronization.

00:14:06.400 --> 00:14:10.190
So you have these six points where
things get synchronized for you.

00:14:10.220 --> 00:14:15.420
But if you need to do it at some other
point within your request response loop,

00:14:15.420 --> 00:14:19.720
you can still call value for binding,
set value for binding.

00:14:19.720 --> 00:14:24.770
It doesn't interfere one way or the
other with the getting of binding values.

00:14:25.800 --> 00:14:30.880
And in the grand tradition of extra long,
gratuitously long method names,

00:14:30.970 --> 00:14:36.200
you can override synchronizes variables
with bindings to return false in your

00:14:36.200 --> 00:14:39.070
reusable component to go fully manual.

00:14:41.340 --> 00:14:46.990
Now, why is auto synchronization
undesirable for reusable components?

00:14:46.990 --> 00:14:49.600
One thing is it's really magical.

00:14:49.600 --> 00:14:53.480
For people first coming into WebObjects,
they're like,

00:14:53.710 --> 00:14:54.630
How does this work?

00:14:54.630 --> 00:14:57.400
How does it know exactly when
to stuff values into and out

00:14:57.400 --> 00:15:00.200
of my reusable components?

00:15:00.200 --> 00:15:04.270
So by doing all the handling
of bindings yourself,

00:15:04.270 --> 00:15:08.670
you know exactly when they happen,
where it's going on,

00:15:08.850 --> 00:15:13.760
and it takes all the mystery out of it,
which I think is a good thing.

00:15:13.760 --> 00:15:18.270
Another reason is it happens
more often than necessary.

00:15:18.360 --> 00:15:21.500
If you add it all up,
it's six times per component

00:15:21.500 --> 00:15:27.040
for every request response loop,
and that can really add up.

00:15:27.040 --> 00:15:30.290
For display only components,
you can usually get away with just

00:15:30.290 --> 00:15:33.700
one pull per request response loop,
and there may be a lot of bindings that,

00:15:33.700 --> 00:15:35.540
depending on the values
of other bindings,

00:15:35.540 --> 00:15:38.960
that you'll never grab,
so you can get away with just not doing

00:15:39.160 --> 00:15:42.330
any synchronization on those bindings.

00:15:42.570 --> 00:15:45.570
The other thing is you may have
to worry about side effects

00:15:45.580 --> 00:15:47.180
on your accessor methods.

00:15:47.180 --> 00:15:49.290
You know,
if you increment something inside an

00:15:49.290 --> 00:15:52.730
accessor method or something that you
really only expected to get called

00:15:52.730 --> 00:15:56.830
once during a request response loop,
now it gets called three times.

00:15:56.850 --> 00:16:00.090
So it's just more stuff
for you to worry about.

00:16:00.490 --> 00:16:04.040
The third and probably the most
important bit here is that the

00:16:04.190 --> 00:16:07.100
order in which bindings are pushed
and pulled is indeterminate.

00:16:07.100 --> 00:16:11.170
So if you have some kind of behavior
or value that actually depends

00:16:11.170 --> 00:16:15.280
on the values of two bindings,
like if binding one is null

00:16:15.400 --> 00:16:18.160
and binding two has a value,
or if binding two is null

00:16:18.160 --> 00:16:20.900
and binding one has a value,
you do something.

00:16:21.510 --> 00:16:25.020
When your accessor
method gets called for,

00:16:25.250 --> 00:16:29.030
say, binding two,
you can't be sure that the

00:16:29.040 --> 00:16:31.640
value for binding one has the
right value at that point.

00:16:35.670 --> 00:16:40.700
So I'm going to go on and talk about
accessor methods with cache as one of

00:16:40.710 --> 00:16:43.140
the techniques for handling bindings.

00:16:43.260 --> 00:16:46.480
If you look at the examples
that come with WebObjects,

00:16:46.500 --> 00:16:48.680
you'll see that a lot of
them use this technique.

00:16:48.680 --> 00:16:50.950
And it's not rocket science.

00:16:50.960 --> 00:16:53.060
It's very simple.

00:16:53.060 --> 00:16:57.050
We use caches to improve performance,
and we flush the caches at the

00:16:57.050 --> 00:16:59.220
beginning of a pending response.

00:16:59.220 --> 00:17:04.280
Now, there's a good reason for
doing it at that point,

00:17:04.280 --> 00:17:07.080
but we're not going to get into

00:17:07.450 --> 00:17:09.840
Take a look at a little code example.

00:17:09.840 --> 00:17:12.530
I'm going to try to use
my wimpy little laser.

00:17:12.530 --> 00:17:14.880
I don't know if you can see it here.

00:17:15.360 --> 00:17:21.150
We're sharks with lasers coming
off their heads when you need them.

00:17:21.150 --> 00:17:21.150
So...

00:17:21.490 --> 00:17:23.160
Here it's very simple.

00:17:23.160 --> 00:17:25.900
We just say if binding equals null,
then binding equals value

00:17:25.900 --> 00:17:27.640
for binding binding.

00:17:27.640 --> 00:17:28.940
That's how we return the binding.

00:17:28.940 --> 00:17:34.130
In the set binding method,
we say set value for binding to push

00:17:34.130 --> 00:17:36.040
the value back up to the parent.

00:17:36.090 --> 00:17:38.740
And in the ped response,
to empty the cache,

00:17:38.870 --> 00:17:41.110
we just say binding equals null.

00:17:43.490 --> 00:17:47.950
As an extension to this,
we can have default values for bindings.

00:17:47.950 --> 00:17:53.440
This is really good in keeping with
the low commitment part of philosophy.

00:17:53.440 --> 00:17:59.980
If the component itself
provides a default value,

00:17:59.980 --> 00:18:04.440
it's one less thing that the
consumer needs to provide.

00:18:05.800 --> 00:18:07.720
And again, it's very simple.

00:18:07.720 --> 00:18:12.580
We just say if after checking --
after doing value for binding,

00:18:12.580 --> 00:18:14.580
we check again to see
if the binding is null.

00:18:14.580 --> 00:18:17.620
And if it is null,
we just do set binding.

00:18:17.620 --> 00:18:22.770
And as in the previous example,
set binding will just push

00:18:22.770 --> 00:18:27.620
our default value back up
to the parent if it's bound,

00:18:27.620 --> 00:18:27.620
which is --

00:18:27.810 --> 00:18:31.170
Which is a good thing, you know,
the parent will need to

00:18:31.170 --> 00:18:33.200
know what that value is.

00:18:36.380 --> 00:18:42.890
Next,
we'll talk about page-level bindings.

00:18:43.450 --> 00:18:47.120
The typical way in which we
see this is you've created

00:18:47.120 --> 00:18:49.280
a beautiful input component.

00:18:49.600 --> 00:18:50.810
It has a flag on it.

00:18:51.030 --> 00:18:55.510
You can have it either in a
display mode or editable mode,

00:18:55.760 --> 00:18:58.370
and you want to drop a whole
bunch of these things into a page.

00:18:58.480 --> 00:19:03.750
And you'd like to control them all by
just throwing one switch on the page.

00:19:04.860 --> 00:19:07.650
But, you know,
it becomes a pain to bind up editable

00:19:07.650 --> 00:19:10.980
to all of these little components.

00:19:10.980 --> 00:19:12.640
And, you know, it's error prone.

00:19:12.640 --> 00:19:13.860
It's another extra thing to do.

00:19:13.860 --> 00:19:15.690
And if you nest them
inside other components,

00:19:15.720 --> 00:19:18.710
you're going to have to propagate
that editable flag all the way down.

00:19:18.720 --> 00:19:23.210
It's much more convenient to
just have the component crawl up

00:19:23.260 --> 00:19:27.800
to the page that it's in and ask
for the editable flag itself,

00:19:27.930 --> 00:19:32.700
a little implicit thing that
it automatically knows about.

00:19:33.620 --> 00:19:37.000
We can still allow manual
overrides by explicitly providing

00:19:37.060 --> 00:19:38.700
a binding to one of these.

00:19:38.700 --> 00:19:42.440
So if you want, for instance, to have,
for whatever reason,

00:19:42.440 --> 00:19:45.980
to have one of the fields not
be editable while the rest are,

00:19:46.060 --> 00:19:47.840
you can easily control that.

00:19:47.880 --> 00:19:50.680
Similarly,
you can have session and application

00:19:50.680 --> 00:19:54.240
level bindings where a component
can just go to the session or the

00:19:54.240 --> 00:19:57.910
application for a flag or some
value and figure out what to do.

00:20:03.120 --> 00:20:08.060
Looking at our example here,
so we check if we have a certain

00:20:08.150 --> 00:20:11.660
binding by using hasBinding,
and if we have the binding,

00:20:11.670 --> 00:20:12.860
we return the value for binding.

00:20:12.860 --> 00:20:15.330
This is our manual override.

00:20:15.340 --> 00:20:19.980
And then if we don't,
we just return root value for key

00:20:19.980 --> 00:20:23.530
for the flag that we're looking for.

00:20:23.660 --> 00:20:26.190
Now, root is just a little recursive
method I'm not going to show

00:20:26.190 --> 00:20:29.220
here that just crawls up,
calls parent continually

00:20:29.220 --> 00:20:31.920
until it gets to the top.

00:20:32.220 --> 00:20:35.360
and again with the low
commitment philosophy,

00:20:35.360 --> 00:20:39.190
we catch NSK valid coding unknown
key exception so that if the

00:20:39.390 --> 00:20:42.050
page we're embedded in doesn't
actually implement editable,

00:20:42.190 --> 00:20:47.260
everything is still cool
and we just keep on going.

00:20:47.260 --> 00:20:50.780
And I'm going to turn it over to
Dave to talk about component content.

00:20:50.780 --> 00:20:50.780
Dave, you want to start?

00:21:00.120 --> 00:21:04.300
Okay,
before component content came around,

00:21:04.430 --> 00:21:05.690
there was this thing called
the switch component.

00:21:05.790 --> 00:21:10.280
And the switch component existed to
allow you to create reusable components

00:21:10.280 --> 00:21:13.570
that had a region of dynamic content,
something that you as a component

00:21:13.660 --> 00:21:16.880
designer didn't provide and
you wanted the consumer to be

00:21:16.880 --> 00:21:19.050
able to provide this thing.

00:21:19.060 --> 00:21:24.480
It had and still exists,
I shouldn't say had, it has some...

00:21:25.110 --> 00:21:28.740
The WebObjects component
architecture is a complex design

00:21:28.740 --> 00:21:32.810
that requires the existence of
some other reusable components.

00:21:32.810 --> 00:21:36.310
If you have a page and you use
this reusable component and you

00:21:36.310 --> 00:21:40.360
want to use some customized stuff,
you've got to have this other

00:21:40.360 --> 00:21:42.830
component around to switch into it.

00:21:42.950 --> 00:21:47.140
Also, your switch component
defines a set of bindings.

00:21:47.140 --> 00:21:51.470
Your reusable component design
says I have binding type A,

00:21:51.470 --> 00:21:52.700
B, C, and D.

00:21:55.100 --> 00:21:58.460
That means any component that
you provide to customize,

00:21:58.460 --> 00:22:01.860
to switch in,
also has to adhere to those limitations.

00:22:01.860 --> 00:22:05.250
So later on in the history of WebObjects,
something called component

00:22:05.250 --> 00:22:08.050
content came around,
and it let the parent define anything

00:22:08.050 --> 00:22:10.100
it wanted right there in the template.

00:22:10.100 --> 00:22:12.790
And there was no constraint
on the dynamic area.

00:22:12.800 --> 00:22:15.350
You could do anything you wanted,
and there wasn't even the need

00:22:15.450 --> 00:22:19.980
for passing bindings because
the customized stuff was defined

00:22:19.980 --> 00:22:22.370
right in the parent directly.

00:22:23.000 --> 00:22:26.760
Now, having said that,
dissing the switch component,

00:22:26.760 --> 00:22:29.580
let me just say that it is actually
still useful for certain things.

00:22:29.580 --> 00:22:33.220
You might want a component inside
a framework to express itself in

00:22:33.220 --> 00:22:37.040
a certain limited number of ways,
and you want to just get some type

00:22:37.090 --> 00:22:40.580
of polymorphic effect where you
just have certain discrete kinds of

00:22:40.630 --> 00:22:43.860
components that do one particular
thing and do it in that particular

00:22:43.860 --> 00:22:45.620
way just inside your framework.

00:22:45.620 --> 00:22:49.910
There's also the situation where
you created a reusable component

00:22:49.910 --> 00:22:53.880
that had this dynamic capability
and you didn't want the consumer

00:22:53.880 --> 00:22:55.740
to have to customize anything.

00:22:55.740 --> 00:22:57.580
To them, you wanted it just to
look like a black box.

00:22:57.580 --> 00:23:00.860
And the other one that's still
relevant today is the need to

00:23:00.860 --> 00:23:03.070
have more than one dynamic region.

00:23:03.080 --> 00:23:07.490
And it's to address that one that
I want to introduce this concept

00:23:07.970 --> 00:23:10.700
called multiple component content.

00:23:10.700 --> 00:23:15.890
I'd imagine anyone who's used real
component content has probably wanted to

00:23:15.890 --> 00:23:19.800
have more than one of these things that
they could put in there so the parent

00:23:19.800 --> 00:23:22.720
could define more than one template,
and in which to customize

00:23:22.720 --> 00:23:23.630
the reusable component.

00:23:23.680 --> 00:23:27.670
And this concept I'm calling
multiple component content

00:23:27.680 --> 00:23:29.480
removes this type of constraint.

00:23:29.480 --> 00:23:34.460
And in an example app that we'll
be demoing in parts and that

00:23:34.470 --> 00:23:37.230
you'll be able to download,
there's a source for a couple dynamic

00:23:37.230 --> 00:23:39.200
elements that implement this concept.

00:23:39.260 --> 00:23:45.130
And one's called RC component
content and the other's RC template.

00:23:45.130 --> 00:23:49.500
So I wanted to give you an example
of where this might come in handy.

00:23:49.500 --> 00:23:52.100
On the screen here,
we've got a page template.

00:23:52.160 --> 00:23:57.380
Almost every WebObjects application
tends to have something like this.

00:23:57.380 --> 00:24:01.610
And the typical way this would be
implemented today would be you'd have

00:24:01.610 --> 00:24:05.270
a component content for the body,
and you might switch components

00:24:05.270 --> 00:24:07.160
for the header and for the menu.

00:24:07.310 --> 00:24:09.860
And what I'm saying here with
multiple component content,

00:24:09.860 --> 00:24:14.210
the parent page that incorporated
this template reusable component could

00:24:14.210 --> 00:24:21.060
define all three of those regions
right there inside the parent itself.

00:24:21.190 --> 00:24:23.600
So what does this look like
from a development perspective?

00:24:23.600 --> 00:24:26.600
I've got on here the definitions
for a reusable component.

00:24:26.600 --> 00:24:31.800
We've got the component.html
and the component.wadfile.

00:24:31.800 --> 00:24:34.800
And this is a trivial example,
but I just want to

00:24:34.940 --> 00:24:36.890
illustrate what's going on.

00:24:36.900 --> 00:24:38.410
So I've got a table
and I've got two cells.

00:24:38.410 --> 00:24:40.520
One's got a top template and
one's got a bottom template.

00:24:40.520 --> 00:24:44.770
And the reusable component.wadfile,
the declaration file, has instead of one

00:24:44.810 --> 00:24:48.200
will component content,
it has two RC component contents.

00:24:48.200 --> 00:24:50.020
And there's one new thing here.

00:24:50.130 --> 00:24:52.480
Will component content
didn't have a name,

00:24:52.580 --> 00:24:54.780
but multiple component content does.

00:24:54.780 --> 00:24:57.650
In this case,
I've named the first one top template

00:24:57.670 --> 00:24:59.960
and the other one bottom template.

00:24:59.960 --> 00:25:02.830
And what this looks like to the consumer,
the parent,

00:25:02.830 --> 00:25:05.880
they put one of these reusable
components on the page.

00:25:05.880 --> 00:25:08.720
And you may recall for
will component content,

00:25:08.720 --> 00:25:10.450
I don't need the nested elements.

00:25:10.480 --> 00:25:11.720
That you see here.

00:25:11.750 --> 00:25:15.030
There's only one element,
so I don't need one nested

00:25:15.510 --> 00:25:16.610
template to define it.

00:25:16.610 --> 00:25:21.360
Anything between the opening and closing
tags of the reusable component is

00:25:21.360 --> 00:25:24.290
enough to define the customized content.

00:25:24.380 --> 00:25:26.790
But in this case,
we've got more than one.

00:25:26.790 --> 00:25:29.490
So in this example,
you see two things up there.

00:25:29.740 --> 00:25:32.640
But imagine there were four
or five or more defined.

00:25:32.640 --> 00:25:35.530
And in the example below,
you see in the parent.wadfile,

00:25:35.530 --> 00:25:36.880
we've got two RC templates.

00:25:36.960 --> 00:25:40.500
And they have a template name of
top template and bottom template.

00:25:40.500 --> 00:25:43.820
And this is how your parent
tells the reusable component,

00:25:43.820 --> 00:25:47.700
I want this content to go here and
I want this content to go there.

00:25:47.700 --> 00:25:49.100
Okay.

00:25:49.310 --> 00:25:53.570
So, let's go to demo.

00:25:58.250 --> 00:26:02.480
I'm going to not show so
much as just introduce.

00:26:02.480 --> 00:26:09.370
This is the example that you'll be able
to download that has the example code.

00:26:09.370 --> 00:26:14.450
This is an example of a page
template that defines a look.

00:26:14.540 --> 00:26:17.720
It's a complex formatted table.

00:26:17.720 --> 00:26:21.240
And I've got content here in the
header and in the left and in the body

00:26:21.240 --> 00:26:23.280
that is all defined in the parent.

00:26:23.280 --> 00:26:25.960
The table itself,
everything you see on the outline

00:26:26.010 --> 00:26:29.250
with this sort of Aqua effect
is in the reusable component.

00:26:29.270 --> 00:26:33.700
And to better identify what is dynamic
in terms of the component and the page,

00:26:34.170 --> 00:26:42.830
let me show you this one.

00:26:43.380 --> 00:26:47.490
with the same reusable
component but different content

00:26:47.500 --> 00:26:48.760
inside both of the cells.

00:26:48.760 --> 00:26:51.680
There's also a notion of what
this allows you to implement

00:26:51.680 --> 00:26:55.380
something or more easily implement
a concept I call view inheritance.

00:26:55.440 --> 00:26:58.270
Don't have time to talk about this
whole sort of abstract thing now,

00:26:58.270 --> 00:27:02.040
but maybe we can talk about
it afterwards or in the Q&A.

00:27:02.040 --> 00:27:05.570
There's also the notion of you
can have conditional content.

00:27:05.570 --> 00:27:09.680
This is an example of a reusable
component that has two templates and the

00:27:09.680 --> 00:27:15.500
reusable component decides to only show
one of them based on some conditional.

00:27:15.500 --> 00:27:17.920
And there's some other examples
here that use component content,

00:27:17.920 --> 00:27:21.010
but I just sort of wanted to give
you a little overview of where

00:27:21.010 --> 00:27:24.660
it's been used and illustrated
its uses inside the example here.

00:27:30.560 --> 00:27:32.500
Back to the slides.

00:27:32.500 --> 00:27:36.100
Thank you.

00:27:36.100 --> 00:27:38.420
And just to sort of review what's
in multiple component content,

00:27:38.420 --> 00:27:40.840
why you might like this,
it allows you to do away

00:27:40.840 --> 00:27:46.900
with a switch component,
so you can have just your parent,

00:27:46.900 --> 00:27:49.630
you can have your three
regions of dynamic content,

00:27:49.750 --> 00:27:51.320
and you're pretty much done.

00:27:51.320 --> 00:27:52.820
There's no other
components that are needed,

00:27:52.900 --> 00:27:55.240
and therefore you get less
complexity in this type of solution.

00:27:55.240 --> 00:28:00.800
So, let me move on to streaming
requests and responses,

00:28:00.800 --> 00:28:03.650
where Brian will come up
and take care of this area.

00:28:08.910 --> 00:28:11.700
Thanks, Dave.

00:28:11.700 --> 00:28:15.380
So before I start talking about
streaming request and responses,

00:28:15.380 --> 00:28:19.000
who in this room has used a
non-streaming WoW file upload and

00:28:19.010 --> 00:28:20.360
run out of memory in their machine?

00:28:20.360 --> 00:28:21.220
Anyone?

00:28:21.220 --> 00:28:24.860
Who's asked for this streaming
adapter for the last few years?

00:28:24.870 --> 00:28:26.430
I've been one of the
people asking for this,

00:28:26.630 --> 00:28:26.900
okay?

00:28:26.900 --> 00:28:27.940
Yeah, Francois.

00:28:27.940 --> 00:28:29.150
Not you, Francois.

00:28:29.160 --> 00:28:32.730
We now have streaming file uploads,
and it's all thanks to

00:28:32.840 --> 00:28:34.670
Carl Su and Francois Jouel.

00:28:34.670 --> 00:28:37.140
Let's give them a big hand, please.

00:28:38.140 --> 00:28:40.250
All these guys.

00:28:42.110 --> 00:28:45.360
Carl almost did himself physically
harm by working so hard on this.

00:28:45.360 --> 00:28:46.830
He worked hours and hours and hours.

00:28:46.830 --> 00:28:47.600
His poor hands.

00:28:47.600 --> 00:28:50.620
We now have streaming
requests and responses.

00:28:50.620 --> 00:28:53.220
For those of you who are
relatively new to WebObjects,

00:28:53.260 --> 00:28:56.140
in the past,
if someone uploaded a file to

00:28:56.210 --> 00:28:58.510
your WebObjects application,
that was pretty big.

00:28:58.560 --> 00:29:01.460
Let's say someone uploaded a 50
megabyte file into your application.

00:29:01.460 --> 00:29:04.700
The WebObjects adapter in the
web server would suck it all in,

00:29:04.700 --> 00:29:07.950
and it would shift it over to
your WebObjects application,

00:29:07.950 --> 00:29:11.620
which would have a copy of this 50
megabyte file in its request object.

00:29:12.040 --> 00:29:14.640
And then,
when it went through and did take values,

00:29:14.640 --> 00:29:18.220
it would create another copy of this
50 megabyte file for you to just

00:29:18.300 --> 00:29:21.350
muck about with or do what you wish,
which you could then shoot to a file,

00:29:21.350 --> 00:29:23.280
a database, another server,
that sort of thing.

00:29:23.280 --> 00:29:26.580
With this going on,
you pretty quickly ran out of memory,

00:29:26.580 --> 00:29:28.320
garbage collection or not.

00:29:28.360 --> 00:29:31.310
So now we have streaming
requests and responses.

00:29:31.320 --> 00:29:35.740
When someone uploads,
you can use a reusable component.

00:29:35.740 --> 00:29:37.960
Now,
this is a component that is way reusable.

00:29:37.960 --> 00:29:39.210
We'll file upload.

00:29:39.220 --> 00:29:43.470
Depending on what you bind to it,
you can... You can get the standard

00:29:43.470 --> 00:29:45.900
no streaming WebObjects file upload.

00:29:46.040 --> 00:29:47.740
Bind to the data binding.

00:29:47.740 --> 00:29:49.560
You get just what you used to have,
which is fine for a lot

00:29:49.560 --> 00:29:50.540
of different things.

00:29:50.680 --> 00:29:54.410
If you know people are only going
to be uploading small objects or

00:29:54.410 --> 00:29:56.750
small files and that sort of thing.

00:29:57.170 --> 00:29:59.860
You can use the stream
to file path binding,

00:29:59.860 --> 00:30:04.470
which allows you to just
simply specify a path,

00:30:04.470 --> 00:30:06.550
and the file will get shot off to that.

00:30:06.560 --> 00:30:09.980
You can use the output stream
binding or the input stream binding.

00:30:09.980 --> 00:30:13.390
So there's been some confusion
about which one does what.

00:30:13.470 --> 00:30:15.780
So we'll start off talking
about stream to file path.

00:30:15.820 --> 00:30:19.200
Actually, I believe there's an issue or
two with stream to file path,

00:30:19.200 --> 00:30:21.220
but that's being worked on right now.

00:30:21.260 --> 00:30:23.620
You provide a path.

00:30:23.880 --> 00:30:25.340
WebObjects streams the data to it.

00:30:25.800 --> 00:30:26.580
It's just that simple.

00:30:26.580 --> 00:30:31.380
Come up with a simple Java line string,
and your data is going to wind up there.

00:30:31.380 --> 00:30:33.300
You don't have to create
any stream objects.

00:30:33.300 --> 00:30:34.830
You just come up with a file name.

00:30:34.840 --> 00:30:39.540
You can also set the overwrite binding
if you want to make sure that the user

00:30:39.540 --> 00:30:42.170
doesn't overwrite an existing file.

00:30:43.440 --> 00:30:45.520
And the other neat thing
about this is that,

00:30:45.700 --> 00:30:48.540
you know, how Kenny said earlier
that you don't know,

00:30:48.540 --> 00:30:51.310
it's nondeterministic,
which order the bindings in a

00:30:51.310 --> 00:30:54.030
particular component are filled out.

00:30:54.410 --> 00:30:57.650
However, this makes sure that the file
name binding is set first for you

00:30:57.700 --> 00:31:00.660
so that you can take a look at
that binding and perhaps come up

00:31:00.660 --> 00:31:04.140
with a different output stream,
I'm sorry, a different file path to

00:31:04.140 --> 00:31:05.500
write to based on that.

00:31:06.700 --> 00:31:08.330
Input stream versus output stream.

00:31:08.330 --> 00:31:13.890
So output stream is the easiest way to
take advantage of streaming requests.

00:31:13.890 --> 00:31:16.820
The data is streamed for
you during take values.

00:31:16.820 --> 00:31:20.240
You have to, by the time your action
gets a hold of the request,

00:31:20.240 --> 00:31:22.980
the data is already where
it was supposed to be.

00:31:22.980 --> 00:31:25.200
So piece of cake, you're ready to go.

00:31:25.500 --> 00:31:27.230
However,
you need to create the output stream.

00:31:27.230 --> 00:31:29.810
So you have to come up and
create a Java output stream,

00:31:29.810 --> 00:31:32.720
which might be to a file,
to another server, to a database,

00:31:32.720 --> 00:31:33.530
whatever not.

00:31:33.530 --> 00:31:34.550
It's up to you.

00:31:34.960 --> 00:31:37.620
And the other nice thing about
this is you can have more than

00:31:37.620 --> 00:31:40.520
one file upload on your form,
and it can be in any order.

00:31:40.520 --> 00:31:44.220
You can have text boxes here,
file upload, more text boxes, buttons,

00:31:44.300 --> 00:31:46.530
multiple submit, that sort of thing.

00:31:46.540 --> 00:31:51.000
So if you really need a lot of control
about data that someone's uploading,

00:31:51.000 --> 00:31:53.290
you might want to use input stream.

00:31:53.330 --> 00:31:57.430
Now input stream is really fascinating
because you are sort of taking part into

00:31:57.510 --> 00:31:59.610
the whole take values from requests.

00:31:59.660 --> 00:32:03.820
You're really getting in, I'm sorry,
you're taking part in

00:32:03.820 --> 00:32:04.900
processing the request.

00:32:04.990 --> 00:32:11.200
You're getting in and handling
part of the take values section.

00:32:11.200 --> 00:32:15.000
So what you do is you
set up this input stream,

00:32:15.000 --> 00:32:15.980
and then you read from it.

00:32:16.010 --> 00:32:17.960
WebObjects points the data at it,
you read from it,

00:32:18.070 --> 00:32:19.600
and then you decide what to do with it.

00:32:19.700 --> 00:32:24.310
Now this is really fascinating because
what you can do in either a component

00:32:24.310 --> 00:32:28.380
or a direct action is you can get a
hold of this input stream and say,

00:32:28.380 --> 00:32:31.410
hang on a second,
I want to make sure that nobody's

00:32:31.410 --> 00:32:33.910
sending me up a copy of Oracle 8.

00:32:34.960 --> 00:32:38.030
You get your request object,
then you get your

00:32:38.300 --> 00:32:41.950
multi-part iterator object,
and you can ask it how many bytes

00:32:42.000 --> 00:32:44.140
are remaining in your request.

00:32:44.140 --> 00:32:47.650
And it'll tell you with
very close exactness,

00:32:47.650 --> 00:32:52.270
and it's not exact,
about how much is left in your request.

00:32:52.340 --> 00:32:56.070
So that's a great thing for people
I've talked about in the past of

00:32:56.120 --> 00:33:00.620
having issues with someone mistakenly
uploading something really huge.

00:33:00.620 --> 00:33:04.890
Other thing to remember with this is
that you can only use one file upload.

00:33:04.990 --> 00:33:09.030
and you can't use multiple submit.

00:33:10.000 --> 00:33:14.380
So you get more control
using input stream.

00:33:14.380 --> 00:33:15.790
Maybe you don't want to
write anything in full.

00:33:15.790 --> 00:33:18.120
Maybe you want to process the
data or send it to another server.

00:33:18.120 --> 00:33:21.210
So you can do all these different
things with your input stream.

00:33:21.340 --> 00:33:24.750
Now, one of the things I want to point
out is that you can use these as a

00:33:24.750 --> 00:33:29.210
component action or component action,
as some people say,

00:33:29.270 --> 00:33:31.040
or you can use them as a direct action.

00:33:31.090 --> 00:33:34.920
Now, if you use a direct action
with an input stream,

00:33:34.920 --> 00:33:40.850
you can use the WoW multipart iterator,
which is documented beautifully,

00:33:40.850 --> 00:33:44.220
to go through, to basically do the take
values part yourself.

00:33:44.220 --> 00:33:46.160
You get ahold of this
iterator and you say,

00:33:46.160 --> 00:33:46.820
"Give me the next thing.

00:33:46.820 --> 00:33:49.660
Give me the next thing." It'll hand
you all the form values and then

00:33:49.660 --> 00:33:53.260
it'll hand you the file upload,
which you can stream off to somewhere,

00:33:53.420 --> 00:33:57.000
and then you can continue going,
more form values, another file upload.

00:33:57.090 --> 00:34:00.240
So that you should only
use with direct action.

00:34:00.240 --> 00:34:02.880
That's the WoW multipart iterator.

00:34:02.880 --> 00:34:04.840
Really great stuff.

00:34:04.840 --> 00:34:07.060
So streaming responses.

00:34:07.060 --> 00:34:08.840
Okay,
so if streaming requests weren't enough,

00:34:08.840 --> 00:34:11.960
these guys decided to go ahead and
implement some streaming responses.

00:34:11.960 --> 00:34:15.230
In the past, if you had a file to
download to the user,

00:34:15.230 --> 00:34:20.360
for example, dynamically created graphic,
a JPEG or a PNG or a GIF or something,

00:34:20.490 --> 00:34:24.960
what you would do is you would override
appended responses in your component.

00:34:24.960 --> 00:34:27.480
You do set content on the response.

00:34:27.640 --> 00:34:30.510
You set your content type,
and then you shuffle it off,

00:34:30.510 --> 00:34:31.450
and you're done with it.

00:34:31.660 --> 00:34:34.160
However, that means that, of course,
you have to have in memory the

00:34:34.160 --> 00:34:36.940
entire thing that you're going
to stream down at the client.

00:34:37.090 --> 00:34:39.140
With streaming responses,
you create an input stream,

00:34:39.140 --> 00:34:42.140
you assign it to a WoW response
by using set content stream,

00:34:42.140 --> 00:34:44.690
and you return the
response and you're done.

00:34:44.770 --> 00:34:46.080
It's just that easy.

00:34:46.260 --> 00:34:49.780
And your memory is going
to stay at a constant rate.

00:34:49.780 --> 00:34:53.030
So that's it for the streaming
request and responses.

00:34:53.050 --> 00:34:56.580
Again, thanks to Francois and
Carl for the hard work on that.

00:35:05.230 --> 00:35:07.230
Got a couple topics,
and Kenny's going to come up

00:35:07.320 --> 00:35:08.340
here and give a couple topics.

00:35:08.340 --> 00:35:11.420
What I want to talk to you is about
something I've seen by looking at

00:35:11.420 --> 00:35:12.840
various code bases over the years.

00:35:12.840 --> 00:35:16.930
People have difficulty sometimes
creating reusable components because of,

00:35:16.930 --> 00:35:21.880
they trip over what I call just
initialization of certain things.

00:35:21.880 --> 00:35:24.760
And the crux of the problem comes
because you start creating pages,

00:35:24.760 --> 00:35:27.540
and then later you may start
creating reusable components.

00:35:27.540 --> 00:35:29.950
And even though they're the same thing,
and that they both inherit

00:35:29.950 --> 00:35:32.250
from one component,
there are differences in how you interact

00:35:32.250 --> 00:35:33.850
with them when you're creating them.

00:35:33.880 --> 00:35:37.200
So with a page, you create it,
you set state into it,

00:35:37.200 --> 00:35:38.730
and then you return it.

00:35:38.930 --> 00:35:41.790
And with a reusable component
that appears on the page,

00:35:41.800 --> 00:35:44.860
the system is doing the creation,
and bindings are the things

00:35:44.860 --> 00:35:46.560
that are being pushed into it,
and you don't have

00:35:46.600 --> 00:35:47.590
direct control over it.

00:35:47.640 --> 00:35:50.780
So the question becomes,
when is it safe to initialize

00:35:50.780 --> 00:35:52.450
supporting structures?

00:35:52.450 --> 00:35:54.760
This is more than just
getting bindings here.

00:35:54.760 --> 00:35:57.850
It's creating that list that's
driving a pop-up button.

00:35:57.860 --> 00:36:01.160
It's filtering something,
a bunch of singletons,

00:36:01.160 --> 00:36:05.740
just creating a bunch of stuff
basically one time only creation.

00:36:05.740 --> 00:36:08.640
You don't want to necessarily
do it over and over again.

00:36:08.780 --> 00:36:11.910
In creating these supporting
structures you may need bindings,

00:36:11.910 --> 00:36:12.530
you may not.

00:36:12.660 --> 00:36:15.770
It may involve going to the
database or it could be expensive.

00:36:15.770 --> 00:36:19.710
So you only would want to redo it
unless it was absolutely necessary.

00:36:19.800 --> 00:36:23.250
So I'm going to actually
give you a solution,

00:36:23.450 --> 00:36:25.990
the one that I prefer,
the way I've approached this problem.

00:36:25.990 --> 00:36:28.180
And that's just to
construct things lazily.

00:36:28.180 --> 00:36:31.060
This is a pattern used
throughout WebObjects and EOF.

00:36:31.090 --> 00:36:32.870
It's not just for performance.

00:36:32.870 --> 00:36:35.310
It's something I found
simplifies this whole problem.

00:36:35.310 --> 00:36:39.300
So basically the way it works is
it's an extension of a pattern

00:36:39.310 --> 00:36:40.950
that Kenny talked about earlier.

00:36:41.040 --> 00:36:41.900
A list of stuff.

00:36:41.900 --> 00:36:43.590
If it's not there, create it.

00:36:43.640 --> 00:36:45.420
And if it is there, just return it.

00:36:45.580 --> 00:36:48.230
Now, you know,
why go to the trouble of having that

00:36:48.230 --> 00:36:51.810
method with that type of a format when
there's a constructor laying around?

00:36:52.000 --> 00:36:56.070
I just want to sort of go over some of
the things where I've seen people try

00:36:56.180 --> 00:37:00.780
to do the same thing in different places
and some of the pitfalls with that.

00:37:00.780 --> 00:37:02.580
So why not a constructor?

00:37:02.580 --> 00:37:04.440
Well, one reason is when you're
in the constructor,

00:37:04.440 --> 00:37:06.340
you don't actually have
access to the bindings.

00:37:06.340 --> 00:37:13.400
So suppose you needed access to that,
then you couldn't put it there.

00:37:13.400 --> 00:37:16.330
If you didn't need bindings,
you still would probably want to

00:37:16.330 --> 00:37:19.300
do it in the thing I suggested
rather than this because you might

00:37:19.350 --> 00:37:20.580
create objects unnecessarily.

00:37:20.580 --> 00:37:21.610
You're in the constructor.

00:37:21.700 --> 00:37:23.770
The page hasn't rendered at all yet.

00:37:23.920 --> 00:37:28.100
It may turn out you don't need half
the things that are on the page,

00:37:28.100 --> 00:37:30.420
that could be on the page
because they're being hidden

00:37:30.420 --> 00:37:31.930
by conditionals or something.

00:37:31.940 --> 00:37:32.950
And then another point there,
Another point there is,

00:37:32.950 --> 00:37:36.200
what if you need to
change the list later?

00:37:36.350 --> 00:37:38.460
There's issues there with cache and
validation since the constructor

00:37:38.460 --> 00:37:40.060
is after all called only once.

00:37:40.060 --> 00:37:42.470
The other thing is, well, OK, fine,
I'll put it in Awake,

00:37:42.470 --> 00:37:44.100
but you still have some
of the same problems.

00:37:44.100 --> 00:37:47.140
Again, bindings aren't available.

00:37:47.210 --> 00:37:48.810
Probably the next best place
to try and put this sort of

00:37:48.810 --> 00:37:51.240
thing is in AppendedResponse.

00:37:51.240 --> 00:37:53.800
But again, you might create objects
unnecessarily because if you

00:37:53.800 --> 00:37:55.440
put it in AppendedResponse,
you need to do this

00:37:55.440 --> 00:37:56.490
before you call super.

00:37:56.570 --> 00:38:02.510
So the reason-- well,
I guess I want to-- one more

00:38:02.510 --> 00:38:04.010
thing to talk about here.

00:38:04.560 --> 00:38:05.790
This is a workaround I've seen.

00:38:05.800 --> 00:38:09.570
Just don't do this.

00:38:09.650 --> 00:38:11.810
But anyway, this is something I've seen.

00:38:11.820 --> 00:38:12.580
I just want to highlight it.

00:38:12.630 --> 00:38:15.570
If you've seen it in your code,
maybe you should pull it out.

00:38:15.580 --> 00:38:17.520
People want to use that
constructor really bad.

00:38:17.520 --> 00:38:19.260
They want to put the
stuff in the constructor,

00:38:19.320 --> 00:38:21.050
but they don't have access to bindings.

00:38:21.060 --> 00:38:22.270
They just say, I know what I'll do.

00:38:22.340 --> 00:38:23.980
I'll take this stuff and
I'll put it in the session,

00:38:24.040 --> 00:38:26.200
and then I'll put these things
in the session in my page,

00:38:26.200 --> 00:38:27.950
then I'll return my page,
and then the component

00:38:28.020 --> 00:38:28.990
will construct itself.

00:38:29.070 --> 00:38:31.170
It'll pull this stuff out of the session,
and hey, I don't got any problem.

00:38:31.280 --> 00:38:33.840
I've avoided the whole deal with
not having access to bindings,

00:38:33.840 --> 00:38:35.660
and my constructor's only called once.

00:38:35.660 --> 00:38:38.520
And the downside to this is
I've got a more complex session.

00:38:38.520 --> 00:38:42.380
It's less reusable because now
you've got all this external

00:38:42.380 --> 00:38:43.980
coordination that's required.

00:38:43.980 --> 00:38:46.440
The page that's returning this
thing has got to know something

00:38:46.440 --> 00:38:49.240
about the components that are on
the page that you're returning.

00:38:49.240 --> 00:38:51.840
And again,
you have some of the other limitations

00:38:51.890 --> 00:38:53.880
I mentioned on the previous slide.

00:38:56.170 --> 00:38:58.880
So to summarize the advantages
of lazy initialization,

00:38:58.880 --> 00:39:02.010
instead of coordinating,
you let your reusable component

00:39:02.010 --> 00:39:03.700
coordinate things itself.

00:39:03.730 --> 00:39:07.200
Construction is deferred
until bindings are available.

00:39:07.200 --> 00:39:10.290
That means the only time you would
ask for a list of states that are

00:39:10.290 --> 00:39:13.590
populated in a pop-up button that
you fetch from a database would be

00:39:13.600 --> 00:39:17.330
in either take values from request,
invoke action, or append a response.

00:39:17.340 --> 00:39:19.960
And those are also the places
where bindings are available.

00:39:19.960 --> 00:39:21.560
So that problem is kind of solved.

00:39:22.440 --> 00:39:25.120
And if the list is never needed,
it's never created.

00:39:25.120 --> 00:39:27.620
So this is one of those rare situations
where the thing that is good for

00:39:27.650 --> 00:39:30.460
performance is also good for making
your code as simple as possible.

00:39:30.460 --> 00:39:33.020
And the fourth point
there is a bit subtle.

00:39:33.020 --> 00:39:35.390
You get easy cache invalidation.

00:39:35.400 --> 00:39:37.790
Instead of you going,
every time you make a change,

00:39:37.790 --> 00:39:40.790
explicitly changing something or
rebuilding it every request and

00:39:40.870 --> 00:39:44.190
append a response or some other place,
all the change agent does,

00:39:44.190 --> 00:39:47.950
the code that makes the affecting change,
all that code does is nulls

00:39:47.950 --> 00:39:49.620
out an instance variable.

00:39:49.620 --> 00:39:54.440
And if the new list is never needed,
it's never constructed.

00:39:54.440 --> 00:39:56.440
And more importantly,
from a simplicity standpoint,

00:39:56.440 --> 00:40:00.500
as long as consumers are
only asking for the accessor,

00:40:00.500 --> 00:40:02.500
and they're never actually
asking for the instance variable,

00:40:02.500 --> 00:40:06.080
then the consumer never worries
about what's going on underneath it.

00:40:06.100 --> 00:40:08.220
So.

00:40:08.530 --> 00:40:11.290
Getting to this next topic,
topic number two.

00:40:11.290 --> 00:40:15.480
I call this thing the
mysterious take values failure.

00:40:15.480 --> 00:40:18.250
I couldn't think of a better name for it,
and I even kind of got

00:40:18.250 --> 00:40:20.740
criticized for this,
but maybe someone will

00:40:20.740 --> 00:40:22.220
give me a better name.

00:40:22.220 --> 00:40:25.550
Anyway,
let me just summarize the problem here.

00:40:25.760 --> 00:40:28.720
Some but not all the changes are missing.

00:40:28.720 --> 00:40:31.560
You fill out some stuff on the page,
you submit the page,

00:40:31.630 --> 00:40:33.760
and some stuff in this
text field shows up,

00:40:33.760 --> 00:40:37.290
and this checkbox shows up,
but these other things aren't there.

00:40:37.300 --> 00:40:38.370
Okay, that's weird.

00:40:38.680 --> 00:40:41.440
Number two,
on occasion you see exceptions thrown

00:40:41.440 --> 00:40:44.100
in the take values from request process.

00:40:44.100 --> 00:40:46.300
Writing take values from request,
your code isn't even called,

00:40:46.300 --> 00:40:47.990
and you're like,
is this bugging WebObjects?

00:40:48.000 --> 00:40:48.450
What's going on?

00:40:48.470 --> 00:40:51.500
And then the third point there is,
and this is the kicker,

00:40:51.500 --> 00:40:55.550
you've noticed that you've rearranged
elements maybe sheerly by accident,

00:40:55.550 --> 00:40:57.260
and the problem goes away.

00:40:57.260 --> 00:40:59.270
So like...

00:41:00.950 --> 00:41:02.600
What's going on?

00:41:02.600 --> 00:41:06.590
To illustrate what's going on,
let me give you a more concrete example.

00:41:06.720 --> 00:41:08.530
Let's assume a very simple page.

00:41:08.550 --> 00:41:10.560
You've got a checkbox,
you've got a conditional,

00:41:10.560 --> 00:41:12.340
and inside that conditional
is a text field.

00:41:12.340 --> 00:41:15.490
And it turns out that the setting
in the checkbox controls whether

00:41:15.490 --> 00:41:17.540
or not the text field is visible.

00:41:17.600 --> 00:41:18.210
So it's checked.

00:41:18.330 --> 00:41:21.080
The user sees the checked
checkbox and they uncheck it.

00:41:21.140 --> 00:41:22.980
And they type some
stuff in the text field.

00:41:22.980 --> 00:41:26.530
They hit submit, and what happens on the
server is the server extracts

00:41:26.540 --> 00:41:28.330
that value from the checkbox.

00:41:28.370 --> 00:41:31.950
And as far as the server is concerned,
the text field doesn't exist anymore.

00:41:32.080 --> 00:41:32.470
It's hidden.

00:41:32.660 --> 00:41:34.910
The user sees it in the browser,
but as far as the server is concerned,

00:41:34.940 --> 00:41:36.040
that thing's gone.

00:41:36.130 --> 00:41:38.540
So it's not going to ask for the value.

00:41:38.590 --> 00:41:39.500
The value is in the request.

00:41:39.500 --> 00:41:40.410
Everything went over OK.

00:41:40.410 --> 00:41:41.590
Everything was fine on the browser.

00:41:41.630 --> 00:41:43.740
It's just that the page just
at the very last minute went,

00:41:43.740 --> 00:41:45.200
no, I'm not going to pull that.

00:41:45.200 --> 00:41:52.800
So the solution to this would
be rearranging the page.

00:41:52.970 --> 00:41:57.340
You might just-- if you put the checkbox
after the text field in this example,

00:41:57.340 --> 00:42:00.300
then it would in fact get the
value in the text field and

00:42:00.300 --> 00:42:01.900
the value in the checkbox.

00:42:01.950 --> 00:42:06.790
And to summarize the basic condition
of the problem is if you are doing

00:42:07.240 --> 00:42:10.130
things and take values from request,
if the user is submitting changes

00:42:10.130 --> 00:42:14.620
which change the structure of the page,
you could be headed for this problem.

00:42:14.710 --> 00:42:17.580
So there's two solutions to this.

00:42:17.580 --> 00:42:21.010
There's the brittle solution, which is,
well, I don't have a lot of time,

00:42:21.030 --> 00:42:23.840
so I'm just going to take the checkbox
and I'm going to move it down here.

00:42:23.840 --> 00:42:24.260
Done.

00:42:24.260 --> 00:42:25.270
I'm going skiing.

00:42:25.290 --> 00:42:28.000
I'm going to do this.

00:42:28.000 --> 00:42:28.160
I'm going to do this.

00:42:28.160 --> 00:42:33.120
I'm going to do this.

00:42:33.120 --> 00:42:33.120
I'm going to do this.

00:42:33.120 --> 00:42:33.120
I'm going to

00:42:33.280 --> 00:42:36.650
But it's going to get chewed out on
Monday when the design people rearrange

00:42:36.650 --> 00:42:39.640
the page and everything looks better
to them and your app doesn't work.

00:42:39.710 --> 00:42:42.720
Or worse,
someone did this in design and they

00:42:42.900 --> 00:42:45.430
didn't even bother sending it through
QA because they didn't change any code,

00:42:45.510 --> 00:42:46.810
so hey, there's no big problem.

00:42:46.810 --> 00:42:49.390
And these exceptions are flying
all over the place and you've

00:42:49.390 --> 00:42:50.640
got to come home from Tahoe.

00:42:50.640 --> 00:42:51.460
So that's no fun.

00:42:52.520 --> 00:42:58.300
So what I suggest you guys do is if you
have things like the checkbox example,

00:42:58.300 --> 00:43:00.900
take that state,
put it in a holding variable,

00:43:00.900 --> 00:43:04.650
and take values from request in your
reusable component before you call super,

00:43:04.650 --> 00:43:08.140
extract from the holding variable
and put it in the ultimate storage.

00:43:08.140 --> 00:43:10.560
That way if you're retrofitting
this back onto an app that

00:43:10.560 --> 00:43:13.140
may have more than one action,
you put the change in one place

00:43:13.140 --> 00:43:16.100
and all the rest of your code on
the page doesn't have to change.

00:43:16.100 --> 00:43:18.210
If you only have one action,
then it's okay to put this kind

00:43:18.300 --> 00:43:20.560
of thing in the action method
if that's more convenient.

00:43:22.900 --> 00:43:25.740
Getting on to the next topic is Kenny.

00:43:30.900 --> 00:43:33.900
So the next topic is
obtaining values from objects.

00:43:33.900 --> 00:43:35.900
It seems deceptively simple.

00:43:35.900 --> 00:43:38.890
Why am I even talking about it?

00:43:39.430 --> 00:43:43.650
Typically you run into this when
you have a component that displays

00:43:43.650 --> 00:43:47.570
a list of objects or takes an
array of objects for a binding,

00:43:47.570 --> 00:43:51.640
so it's trying to display a list,
a custom pop-up button or a table

00:43:51.640 --> 00:43:53.610
component or something like that.

00:43:53.620 --> 00:43:57.540
And the problem arises, I think,
because people try to encapsulate too

00:43:57.540 --> 00:43:59.500
much into their reusable component.

00:43:59.560 --> 00:44:01.240
The whole idea is for
it to be functional,

00:44:01.240 --> 00:44:08.180
so they try to insulate the consumer
from the innards as much as possible.

00:44:08.180 --> 00:44:12.960
So what beginners typically do is they
have a binding for the array of objects,

00:44:12.980 --> 00:44:16.900
and then they have a key binding,
which they take in,

00:44:16.950 --> 00:44:20.920
and then as the component
-- as the reusable component

00:44:20.980 --> 00:44:24.840
iterates over the list,
they call value for key on the

00:44:24.880 --> 00:44:28.010
object to get a value to display.

00:44:28.270 --> 00:44:32.640
As it turns out,
this isn't very flexible.

00:44:32.800 --> 00:44:37.390
It's better to make the consumer
provide the item and display

00:44:37.390 --> 00:44:40.670
string binding instead of a key.

00:44:40.680 --> 00:44:46.830
The advantages being the objects being
displayed then don't have to actually

00:44:46.830 --> 00:44:51.010
respond to key value coding because
you're not calling value for key into it.

00:44:51.080 --> 00:44:55.820
WebObjects has another neat trick to do
key value coding on objects that don't

00:44:55.830 --> 00:44:58.480
actually respond to key value coding.

00:45:00.520 --> 00:45:04.560
And also the parent is free to use
custom methods to generate the value.

00:45:04.560 --> 00:45:08.590
So if you want to derive some value
off an attribute of the object

00:45:08.590 --> 00:45:12.820
that's not already in the object,
this gives you a lot more flexibility.

00:45:12.820 --> 00:45:16.560
Let's take a look at an example here
of the not-so-flexible situation.

00:45:18.360 --> 00:45:22.360
So we have the list binding
and the display key binding in

00:45:22.360 --> 00:45:24.210
the parent where you use it.

00:45:24.510 --> 00:45:28.640
In the reusable component,
we're repeating over a label.

00:45:28.760 --> 00:45:34.030
And in the WAD of the reusable component,
we have value equals display string

00:45:34.130 --> 00:45:40.530
for the string we want to display,
and we're doing value for key

00:45:40.660 --> 00:45:42.900
here in the reusable components

00:45:43.730 --> 00:45:50.500
The more flexible version is we
make the consumer provide an item,

00:45:50.610 --> 00:45:53.000
an item binding,
and now the display string,

00:45:53.000 --> 00:45:55.930
instead of being a constant,
it says display string,

00:45:55.930 --> 00:45:57.680
so bind to my method display string.

00:45:57.680 --> 00:46:00.080
And the HTML stays the same.

00:46:00.080 --> 00:46:01.760
The important thing here is the WAD.

00:46:01.760 --> 00:46:04.310
You see that item,
the item binding in the

00:46:04.310 --> 00:46:07.950
repetition is now caret item,
which means it's pushing that

00:46:07.950 --> 00:46:11.580
item back up into the consumer
every time during the repetition.

00:46:12.960 --> 00:46:16.230
And the display string is
also caret display string,

00:46:16.230 --> 00:46:19.720
which means instead of using my
method to get the display string,

00:46:19.720 --> 00:46:22.490
use my binding value of display string.

00:46:22.500 --> 00:46:26.460
And in the parent here,
you see it's returning the name

00:46:26.460 --> 00:46:31.750
bracketed by square brackets,
so a little example of derived value.

00:46:31.760 --> 00:46:38.390
Now, if you didn't want to have a custom
value for the display string,

00:46:38.500 --> 00:46:44.080
you can just here in the parent's WAD,
you can say display string equals

00:46:44.410 --> 00:46:49.030
item.name instead of display string,
and you can get rid of the display

00:46:49.030 --> 00:46:51.000
string method in the parent altogether.

00:46:51.000 --> 00:46:52.910
It makes things lighter
weight for everybody.

00:46:56.140 --> 00:47:01.160
The next tip is using
WoW component content in tables.

00:47:01.160 --> 00:47:04.250
It's kind of an extension of
the same mentality as before.

00:47:04.450 --> 00:47:07.210
People tend to, when they write their
first table component,

00:47:07.320 --> 00:47:10.740
have dual repetition inside
their table component.

00:47:10.740 --> 00:47:20.930
And they repeat all the cells
within their reusable component.

00:47:20.940 --> 00:47:25.780
Then what ends up happening is, well,
they want this column to

00:47:25.850 --> 00:47:28.180
be left justified and this
column to be right justified,

00:47:28.180 --> 00:47:29.760
so they add a justification binding.

00:47:29.760 --> 00:47:33.500
And then they want one to have bold font,
so they add a font binding.

00:47:33.510 --> 00:47:36.590
And then they want another one
to have a larger font size,

00:47:36.620 --> 00:47:38.450
so they have a size binding.

00:47:38.460 --> 00:47:42.990
And it eventually gets to where... you
have an infinite number of bindings

00:47:43.060 --> 00:47:46.160
to try to configure your table,
and it's still not as

00:47:46.160 --> 00:47:48.150
flexible as you want it to be.

00:47:48.370 --> 00:47:54.340
So the solution is to put more
work onto the consumer and have the

00:47:54.340 --> 00:48:00.940
consumer provide the table cells
themselves in WoW component content.

00:48:00.940 --> 00:48:03.770
And this allows the
parent to do anything.

00:48:03.780 --> 00:48:06.270
You can put images in your cells,
hyperlinks.

00:48:06.330 --> 00:48:09.530
You can make multi-line cells,
colored cell backgrounds,

00:48:09.540 --> 00:48:11.020
whatever it is you want.

00:48:11.020 --> 00:48:21.450
So taking an example -- or taking a
look at the not-so-flexible version.

00:48:21.450 --> 00:48:21.450
Whoops.

00:48:23.220 --> 00:48:29.890
We see here that the list is passed into
the reusable component and the parent,

00:48:29.890 --> 00:48:35.900
passing in headers, display keys,
display align, display style,

00:48:36.270 --> 00:48:40.100
and then the reusable component
has the dual repetitions,

00:48:40.100 --> 00:48:46.590
the row repetition and the column
repetition with the TD tags

00:48:46.590 --> 00:48:50.230
and the TR tags being repeated.

00:48:50.230 --> 00:48:50.230
In the more flexible version,

00:48:51.150 --> 00:48:57.900
We see that now the parent
has a lot more stuff in it.

00:48:57.900 --> 00:49:02.510
In the HTML,
it now is bolding the first column

00:49:02.510 --> 00:49:06.900
and centering the second column and
right aligning the third column.

00:49:07.000 --> 00:49:10.400
And we have a finite list of bindings.

00:49:10.700 --> 00:49:15.520
And the table,
the reusable component now just contains

00:49:15.520 --> 00:49:16.980
the TR tags but not the TD tags.

00:49:16.980 --> 00:49:22.640
And this example is a little bit broken,
forgot the wool repetition tags.

00:49:22.640 --> 00:49:28.180
But it maintains control of the
TR tags so it can still do things

00:49:28.260 --> 00:49:32.410
like alternate row colors and
highlight a row for a selected row.

00:49:34.750 --> 00:49:36.940
Okay, that brings us to the Dr.

00:49:36.940 --> 00:49:38.100
Evil segment.

00:49:38.100 --> 00:49:43.930
You know, sometimes there are some
techniques that are so handy

00:49:43.940 --> 00:49:46.890
that you just have to use them,
even though you know you're

00:49:46.890 --> 00:49:48.220
going to go to hell for doing it.

00:49:50.860 --> 00:49:56.550
So the first one is the parent talking
directly to the reusable component.

00:49:56.620 --> 00:50:02.820
I said before that the child is
totally in control of communicating

00:50:02.820 --> 00:50:05.470
with the parent via bindings.

00:50:05.560 --> 00:50:09.420
Of course, as in all things,
that's not quite true.

00:50:09.420 --> 00:50:14.210
What we can do is at the beginning of
a Pender response we can do set value

00:50:14.210 --> 00:50:16.840
for binding this to a binding value.

00:50:16.840 --> 00:50:21.920
Now, then whatever the parent has bound
to that binding value takes on

00:50:21.920 --> 00:50:26.830
the value of the subcomponent,
then the parent can start

00:50:26.830 --> 00:50:29.040
talking to the subcomponent.

00:50:29.140 --> 00:50:33.850
You might want to use this in cases where
no number of bindings is flexible enough.

00:50:34.020 --> 00:50:38.410
You just need to be able to
talk directly to the object.

00:50:38.410 --> 00:50:43.840
And it's important to note that the
value is not available until the

00:50:43.840 --> 00:50:47.080
child starts generating its response.

00:50:47.080 --> 00:50:50.690
So you may want to do your
communication like inside a set

00:50:50.690 --> 00:50:54.550
method or something like that,
or after the child

00:50:54.550 --> 00:50:59.480
starts a Pender response,
it may get a binding which will

00:50:59.480 --> 00:51:06.160
signal to the parent that it can
start now talking to the child.

00:51:06.160 --> 00:51:08.250
As a fallout of this,
you can do something that's

00:51:08.250 --> 00:51:09.830
also otherwise impossible.

00:51:09.830 --> 00:51:16.430
Allow two sibling components
to communicate on the page.

00:51:16.600 --> 00:51:20.760
If -- as the page is
generating its response,

00:51:20.760 --> 00:51:24.700
the first sibling will
push itself into a binding.

00:51:24.700 --> 00:51:28.920
Some other component further down
the page can pull the binding and

00:51:29.080 --> 00:51:34.340
suddenly you have two siblings
talking directly to each other.

00:51:34.340 --> 00:51:35.360
Be careful when doing this.

00:51:37.840 --> 00:51:42.500
The next topic is array bindings.

00:51:42.830 --> 00:51:45.880
A lot of times you have a lot
of bindings that are just simply

00:51:45.880 --> 00:51:48.150
arrays of string constants.

00:51:48.160 --> 00:51:51.900
And you don't want to write a whole
bunch of little bits of tedious

00:51:51.900 --> 00:51:56.410
code to create arrays of string
constants because the syntax in

00:51:56.410 --> 00:51:58.560
Java is almost as bad as it is in C.

00:52:00.680 --> 00:52:05.530
So what we can do is
just use a little trick,

00:52:05.620 --> 00:52:10.990
use a method called -- we can
call it array binding named.

00:52:11.040 --> 00:52:16.610
And it just checks a binding to
see if it's of the type NSArray.

00:52:16.650 --> 00:52:17.920
It just passes it on through.

00:52:17.920 --> 00:52:20.110
And if it's a string,
then it just assumes it's

00:52:20.120 --> 00:52:24.400
a comma-separated list and
uses components separated by

00:52:24.600 --> 00:52:27.500
string to pass an array back.

00:52:27.500 --> 00:52:31.400
And now I'm going to bring Dave and
Fitz up and -- And we're going

00:52:31.400 --> 00:52:33.090
to talk about the rest of these.

00:52:39.500 --> 00:52:40.900
Okay,
one more thing and then we'll get on

00:52:40.900 --> 00:52:43.970
to just kind of go into the examples a
little bit and this will be the close

00:52:43.970 --> 00:52:45.960
of the formal part of this sucker.

00:52:45.960 --> 00:52:48.440
I want to talk about smart bindings.

00:52:48.440 --> 00:52:49.970
This is just a name I'm
going to come up with.

00:52:49.970 --> 00:52:51.680
I'm really bad at naming things,
so anyway.

00:52:53.640 --> 00:52:56.310
I want to address a situation
that you may or may not have.

00:52:56.360 --> 00:52:59.270
I've run into this situation where I've
had hundreds of stuff on the page and

00:52:59.270 --> 00:53:01.360
I just need to do some trivial thing.

00:53:01.360 --> 00:53:03.980
I wanted to like hell to stick
it in the declaration file,

00:53:03.980 --> 00:53:05.940
but we don't do that
in declaration files,

00:53:05.940 --> 00:53:09.580
so you end up having a whole bunch of
trivial methods to do that sort of thing.

00:53:09.580 --> 00:53:12.800
The kind of thing I'm talking about
is like an example we'll see up there.

00:53:12.910 --> 00:53:13.780
You might have a path.

00:53:13.930 --> 00:53:16.330
You might want to append
something to the front.

00:53:16.330 --> 00:53:20.530
You might have a lot of low
strings and you might end up

00:53:20.530 --> 00:53:23.620
having the same basic method,
but it takes a lot of time.

00:53:23.620 --> 00:53:26.200
You might have a lot of arguments and you
have like a gazillion different constant

00:53:26.200 --> 00:53:27.420
arguments you need to pass to it.

00:53:27.470 --> 00:53:30.690
Now, the solutions to this type of
miniature problem is you can create

00:53:30.690 --> 00:53:33.740
a little component that performs
the intervention and then you're

00:53:33.740 --> 00:53:36.900
not adding code to your page,
but now instead of having a low string,

00:53:36.900 --> 00:53:40.380
you've got your special trivial
string that you've got everywhere.

00:53:40.380 --> 00:53:42.250
That's kind of unsatisfying.

00:53:42.260 --> 00:53:43.910
The alternative is dozens
of trivial methods,

00:53:43.910 --> 00:53:46.180
but there's one other alternative
called the smart binding.

00:53:46.180 --> 00:53:49.040
To illustrate what that means
is I want to give you an example

00:53:49.040 --> 00:53:50.840
from something I had to deal with.

00:53:50.890 --> 00:53:53.600
I had this page and it had
a customer's order history.

00:53:53.600 --> 00:53:56.940
And therefore there were an
enormous amount of totals,

00:53:56.940 --> 00:53:58.550
money totals on the page.

00:53:58.550 --> 00:54:03.600
And I ended up having to have literally
hundreds of methods like those up there.

00:54:03.600 --> 00:54:05.680
Order detail subtotal, blah, blah, blah.

00:54:05.690 --> 00:54:08.970
And all these guys did was turn around
and do value for key path on the page,

00:54:08.980 --> 00:54:12.100
got the value, and then they did some
currency conversion on it.

00:54:23.580 --> 00:54:26.580
And so what I was able to do is I was
able to do some key value for key path.

00:54:26.580 --> 00:54:29.100
This is the way that all the key
value coding happens from your

00:54:29.120 --> 00:54:30.640
component into everything else.

00:54:30.650 --> 00:54:32.940
You might override it and
do certain special stuff.

00:54:32.940 --> 00:54:35.060
Like in this case,
it looks for native currency and

00:54:35.130 --> 00:54:36.500
the at sign inside the key path.

00:54:36.500 --> 00:54:38.820
And if it finds it,
it does some special processing.

00:54:38.860 --> 00:54:41.390
Now, there's a version of this
kind of taken to its logical,

00:54:41.390 --> 00:54:44.160
you know, logic,
but it's a little bit different.

00:54:44.770 --> 00:54:47.250
This is an obnoxious
extreme called Woe OG&L.

00:54:47.270 --> 00:54:49.570
I believe it's part of a certain project.

00:54:49.570 --> 00:54:53.380
But anyway, even if you don't go all,
you know, use that technique,

00:54:53.380 --> 00:54:54.860
this can be quite useful.

00:54:54.860 --> 00:54:58.570
Imagine sticking something like this
and a lot of similar things in an

00:54:58.620 --> 00:55:01.320
abstract component that is just used,
you know,

00:55:01.320 --> 00:55:05.170
throughout the application and then,
you know, you've done away with

00:55:05.280 --> 00:55:07.700
lines and lines of code,
trivial code.

00:55:10.700 --> 00:55:16.740
Okay, so now if Kenny is going
to hell for what he did,

00:55:16.860 --> 00:55:19.590
I'm sure I'm going to be submitted
to something much worse like having

00:55:19.590 --> 00:55:22.940
to write VB code for the rest of
my life or something for this one.

00:55:22.940 --> 00:55:26.340
This is sort of just like plant
a seed in your head about some of

00:55:26.340 --> 00:55:30.120
the things you can do to really
abuse the WebObjects framework.

00:55:31.870 --> 00:55:34.740
WebObjects components,
the dynamic elements that

00:55:34.740 --> 00:55:38.160
ship with WebObjects,
really know how to display themselves.

00:55:38.180 --> 00:55:41.280
You can do, like WoeString,
it can display a string.

00:55:41.280 --> 00:55:45.610
WoeHyperlink knows how to display a
hyperlink and how to provide a link and

00:55:45.610 --> 00:55:49.480
all the jazz that gets you to another
action in your WebObjects application.

00:55:49.480 --> 00:55:52.240
You can actually develop
your own components that sort

00:55:52.240 --> 00:55:53.820
of subclass Woe components.

00:55:53.820 --> 00:55:56.860
So, for example,
up here in the screen we have WoeString.

00:55:56.860 --> 00:56:00.730
You can make MyString or MyRepetition
or MyImage and that sort of thing.

00:56:01.790 --> 00:56:03.770
And here's an example.

00:56:03.780 --> 00:56:06.210
You can make these components so that
they know how to edit themselves.

00:56:06.220 --> 00:56:11.000
So if you take a reusable component,
say MyString, for example,

00:56:11.000 --> 00:56:15.830
and you set it up in a little conditional
so that if it's in display mode,

00:56:15.830 --> 00:56:20.090
it'll display itself just like
you would see when a user's

00:56:20.090 --> 00:56:22.060
looking at your page in your app.

00:56:22.120 --> 00:56:26.030
But edit mode would allow the
user to maybe edit the binding,

00:56:26.030 --> 00:56:29.780
the component,
change the content of whatnot.

00:56:29.780 --> 00:56:32.210
And finally,
you could even... You have another

00:56:32.210 --> 00:56:34.540
mode that would write itself to disk
so that it would know what to do.

00:56:34.540 --> 00:56:35.800
You say, write yourself to disk.

00:56:35.800 --> 00:56:37.140
And it's MyImage.

00:56:37.140 --> 00:56:39.720
And it would point to the image
that someone had configured

00:56:39.870 --> 00:56:41.180
it to point at in edit mode.

00:56:41.220 --> 00:56:41.820
Okay?

00:56:41.820 --> 00:56:45.100
So that's... And last but not least,
and this is what I did,

00:56:45.100 --> 00:56:47.600
is I created this whole
tree of components.

00:56:47.600 --> 00:56:50.740
So each one had MyString, MyImage,
et cetera.

00:56:50.740 --> 00:56:52.520
And I linked them together.

00:56:52.520 --> 00:56:56.270
And if you add a little
pop-up of other components,

00:56:56.270 --> 00:56:59.890
you can sort of allow the
user in edit mode to add more

00:56:59.890 --> 00:57:01.520
components and add a repetition.

00:57:01.620 --> 00:57:03.720
And then add other things
with HTML around it.

00:57:03.770 --> 00:57:06.910
And what you're essentially doing
at this point is creating WebObjects

00:57:06.910 --> 00:57:08.660
components in a page on the fly.

00:57:08.660 --> 00:57:12.400
And then archive them all in XML,
stick them in the database.

00:57:12.400 --> 00:57:15.710
And you can pull it out and edit it again
at some point right on an HTML page.

00:57:15.720 --> 00:57:19.500
The example that I'm using here is
I created an application that basically

00:57:19.500 --> 00:57:21.170
allowed people to create websites.

00:57:21.180 --> 00:57:25.430
So it's really on the border
of abusing WebObjects,

00:57:25.430 --> 00:57:26.460
I'd say.

00:57:26.460 --> 00:57:29.180
But, you know,
it's one of the things that you can do.

00:57:30.700 --> 00:57:34.540
So, Ken, we've got a little bit of
time to look at some examples.

00:57:34.540 --> 00:57:39.780
You've already seen some of mine,
so I want you guys to show one of yours.

00:57:40.780 --> 00:57:46.100
Got a couple examples here
of the table component here.

00:57:46.100 --> 00:57:47.540
Oh, look at that.

00:57:47.540 --> 00:57:51.110
So this is an example of a table
component that uses WOL component

00:57:51.270 --> 00:57:52.660
content for its columns.

00:57:52.660 --> 00:57:57.610
And as you can see,
it's got row highlighting,

00:57:57.610 --> 00:58:02.690
but you can still have images
and bold or anything you want.

00:58:02.740 --> 00:58:07.990
This is actually showing -- I'm sure
you're familiar with the movie database.

00:58:07.990 --> 00:58:11.440
So it's actually, you know,
able to show a too-many

00:58:11.440 --> 00:58:13.100
relationship here.

00:58:13.360 --> 00:58:15.600
Let's see, where are we here?

00:58:15.600 --> 00:58:16.060
Oh, here we go.

00:58:16.060 --> 00:58:20.380
Where we have more than one item
across too-many relationship,

00:58:20.380 --> 00:58:23.090
and we've got multiple rows going on.

00:58:23.470 --> 00:58:30.410
and another one is an EO validation
framework where the validation

00:58:30.420 --> 00:58:35.410
messages that EOF spits out aren't
the easiest to show in your UI,

00:58:35.410 --> 00:58:41.370
but this is a high commitment framework
that involves a lot more other objects

00:58:41.370 --> 00:58:45.680
and makes you commit to using like
a subclass of EO editing context

00:58:45.680 --> 00:58:47.540
in order to do this kind of stuff.

00:58:47.540 --> 00:58:51.740
But you can make error messages
that show up right beside the

00:58:51.740 --> 00:58:55.760
fields that are being entered,
and these are actually bubbled

00:58:55.760 --> 00:58:57.350
up from the EOs themselves.

00:58:59.350 --> 00:59:02.330
I've got a couple of simple little
reusable components here that are just

00:59:02.370 --> 00:59:05.920
more of examples of little widgets
or whatnot you could come up with.

00:59:05.960 --> 00:59:09.440
I don't know if Steve Heyman's here,
but this is one I got from him,

00:59:09.440 --> 00:59:10.680
which is really a lot of fun.

00:59:10.680 --> 00:59:11.730
SQL Logging.

00:59:11.760 --> 00:59:14.380
So you could turn that on and
off with this little widget.

00:59:14.380 --> 00:59:16.160
Sort of a helper to
help your programming.

00:59:16.160 --> 00:59:19.200
So you notice it's currently true,
and if you look up there,

00:59:19.200 --> 00:59:21.560
you'll see that we printed out
a little bit of SQL debug stuff.

00:59:21.560 --> 00:59:23.830
And turn it to false,
and all you see is false.

00:59:23.840 --> 00:59:27.740
So it's something you could drop in,
have it show up only in development mode,

00:59:27.740 --> 00:59:29.060
and that sort of thing.

00:59:29.300 --> 00:59:31.840
So an example of a helpful widget.

00:59:31.840 --> 00:59:35.910
And also a reminder that sometimes it's
useful to develop little tools to help

00:59:36.060 --> 00:59:38.440
yourself in developing an application.

00:59:38.440 --> 00:59:40.980
This is a great one
I got from David Black,

00:59:41.010 --> 00:59:45.440
who works in my group here,
which is a reusable calendar component,

00:59:45.440 --> 00:59:47.960
which I've made really big,
and now I'm showing it

00:59:47.960 --> 00:59:49.420
on a really small screen.

00:59:49.420 --> 00:59:53.880
This is a great example
of loose bindings.

00:59:53.880 --> 00:59:56.780
He's got about a million different
bindings for this calendar component,

00:59:56.780 --> 00:59:59.220
but all you're required to do is bind it.

00:59:59.300 --> 01:00:02.070
So you can bind in an entity and say,
hey, this particular attribute

01:00:02.100 --> 01:00:02.730
is a date field.

01:00:02.800 --> 01:00:05.870
And in this example,
I've selected August 1999 in the

01:00:05.870 --> 01:00:09.230
movies database because it has two
separate movies occurring in that month.

01:00:09.260 --> 01:00:13.080
And you can tie actions,
which I haven't done,

01:00:13.140 --> 01:00:15.540
to the movies themselves,
or the objects themselves.

01:00:15.540 --> 01:00:19.460
So you can go look at them or get
further information from them.

01:00:19.460 --> 01:00:22.950
And you can tie an action to the date
and go do further stuff with that.

01:00:23.020 --> 01:00:26.760
And one last quick little
reasonable widget I'll point

01:00:26.770 --> 01:00:28.530
up here is not this one.

01:00:28.560 --> 01:00:29.210
It's this one.

01:00:29.220 --> 01:00:32.000
It's a button widget.

01:00:32.000 --> 01:00:36.180
When you're writing a create, read,
update, delete type application,

01:00:36.180 --> 01:00:38.290
when you're doing a lot
of dealing with data,

01:00:38.420 --> 01:00:40.790
that type of stuff,
you find yourself putting the

01:00:40.970 --> 01:00:44.240
same four buttons in a page or
maybe three buttons or one button.

01:00:44.240 --> 01:00:47.200
So what we did is we created this button
bar that when you look at it in HTML,

01:00:47.200 --> 01:00:48.800
it looks just like the
top one right there.

01:00:48.800 --> 01:00:50.090
It's like all these different buttons.

01:00:50.100 --> 01:00:54.080
And then you just bind action methods
from your parent component into that,

01:00:54.120 --> 01:00:55.780
and then it'll go ahead and show it.

01:00:55.780 --> 01:00:58.560
So below that,
you see we only bound cancel and save.

01:00:59.140 --> 01:01:02.250
And those went ahead and
only showed those buttons.

01:01:02.260 --> 01:01:04.920
But it's the same exact component
that shows the price on that screen.

01:01:04.920 --> 01:01:09.620
I think we're over now,
so I think that's it.

01:01:09.700 --> 01:01:09.900
Yeah.

01:01:20.620 --> 01:01:21.800
I forgot to mention Project Wonder.

01:01:21.800 --> 01:01:22.490
One more thing.

01:01:22.680 --> 01:01:26.200
We forgot to mention Project Wonder.

01:01:26.200 --> 01:01:29.110
If you're not familiar with it and
you're doing WebObjects programming,

01:01:29.110 --> 01:01:33.860
you should get yourself to a web browser
as soon as possible and check out the

01:01:33.860 --> 01:01:39.180
reusable components that these guys have
implemented from low commitment to high

01:01:39.180 --> 01:01:41.510
commitment stuff and the woe OGNL stuff.

01:01:41.520 --> 01:01:44.660
And the frameworks, a lot of the stuff.
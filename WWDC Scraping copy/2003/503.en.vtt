WEBVTT

00:00:42.540 --> 00:00:43.880
Good afternoon.

00:00:44.030 --> 00:00:47.340
This is a general introduction to USB 2.

00:00:47.340 --> 00:00:51.810
I have been asked when the
harsh introduction to USB 2 is,

00:00:51.810 --> 00:00:54.670
and I'm really hoping that
this is when you don't get,

00:00:54.740 --> 00:00:57.300
not when you get to do all of this.

00:00:57.300 --> 00:01:00.490
So, which is the bite button?

00:01:00.490 --> 00:01:04.080
Okay.

00:01:12.650 --> 00:01:13.870
That's the right button.

00:01:13.980 --> 00:01:16.480
So, USB 2.

00:01:16.670 --> 00:01:20.740
What I'm going to talk
about is what USB 2 is,

00:01:20.740 --> 00:01:26.610
as well as what USB 2 is not,
and also what it means to all of you,

00:01:26.650 --> 00:01:32.120
and a little bit about how it's done,
and finally, I'll finish up with a little

00:01:32.120 --> 00:01:35.090
bit about high-speed ISOC APIs.

00:01:35.630 --> 00:01:37.420
So, what is USB 2?

00:01:37.530 --> 00:01:40.070
It is USB 2, but it adds high speed.

00:01:40.560 --> 00:01:44.300
It is USB 2.

00:01:45.450 --> 00:01:48.170
It's compatible with the
USB 1.1 specification.

00:01:48.340 --> 00:01:53.820
It includes almost everything
in the USB 1.1 specification.

00:01:54.140 --> 00:01:58.340
It's almost exactly like the
USB that you all know and love,

00:01:58.390 --> 00:02:01.970
but it adds the high speed.

00:02:02.100 --> 00:02:05.160
This is high speed, yeah.

00:02:05.220 --> 00:02:11.510
It will transfer data at an orbit
rate of 480 megabits a second.

00:02:12.050 --> 00:02:13.720
How fast is 480 megabits, you ask?

00:02:13.800 --> 00:02:18.000
Well, it's 40 times faster
than USB 1.1 full speed.

00:02:18.000 --> 00:02:22.300
Er, 40 times faster.

00:02:22.300 --> 00:02:22.300
So...

00:02:22.580 --> 00:02:23.860
How fast is that?

00:02:23.880 --> 00:02:28.320
Imagine, I presume you're all going to
be going to our plug fest on

00:02:28.320 --> 00:02:30.000
the campus on Thursday evening.

00:02:30.070 --> 00:02:32.490
So you're going to go outside,
you're going to go on the bus,

00:02:32.500 --> 00:02:35.340
it'll take you about 40
minutes to get to Cupertino's.

00:02:35.420 --> 00:02:38.670
If that was a high speed bus though,
it would take you one minute.

00:02:38.760 --> 00:02:42.910
So, you can see it's quite a lot faster.

00:02:43.900 --> 00:02:45.980
Okay, what USB 2 is not?

00:02:45.980 --> 00:02:50.520
USB 2 is not the same
thing as high speed,

00:02:50.520 --> 00:02:53.590
and also USB 2 is not...

00:02:54.120 --> 00:02:54.630
inefficient.

00:02:54.630 --> 00:02:57.080
There's a lot of confusion
out there in the marketplace,

00:02:57.080 --> 00:03:02.200
particularly USB 2 and high speed.

00:03:02.240 --> 00:03:06.190
USB 2 is not a synonym for high speed.

00:03:06.190 --> 00:03:11.370
A USB 2 device can be high speed,
it can be full speed,

00:03:11.380 --> 00:03:13.850
it can be low speed.

00:03:14.170 --> 00:03:23.020
However, recently there has been some
confusion about USB 2 hosts.

00:03:23.230 --> 00:03:27.330
If a computer says that it's USB 2,
you can plug in a high speed

00:03:27.330 --> 00:03:31.720
peripheral and you can get 480 megabit
per second communication going.

00:03:34.080 --> 00:03:39.190
Okay, so USB 2 includes the full and low
speeds that you're already familiar with.

00:03:39.240 --> 00:03:43.050
These can be called classic speed,
although as we already use

00:03:43.050 --> 00:03:45.770
classic for other things,
it's not really a word

00:03:45.820 --> 00:03:47.160
we'd like you to use.

00:03:47.160 --> 00:03:54.400
Also, the USB Implementers Forum,
the governing body of all this,

00:03:54.400 --> 00:03:59.650
frowns on you confusing
USB 2 and high speed.

00:03:59.660 --> 00:04:05.780
You should not say if you have a full
speed USB 2 peripheral that it's USB 2.

00:04:06.000 --> 00:04:09.310
You should say that it's just USB.

00:04:09.400 --> 00:04:11.890
If you were to say that,
say you had a printer,

00:04:11.910 --> 00:04:15.760
and you said on the box that it is USB 2,
the user will have an

00:04:15.760 --> 00:04:19.390
expectation that they plug it in,
and it will run faster than

00:04:19.490 --> 00:04:20.890
a previous USB printer.

00:04:21.160 --> 00:04:21.840
It won't.

00:04:22.000 --> 00:04:22.980
The user will be upset.

00:04:22.980 --> 00:04:24.480
You'll get support calls.

00:04:24.480 --> 00:04:26.260
So, don't do that sort of thing.

00:04:26.380 --> 00:04:29.490
It's leased all sorts of marketing
tricks we'd really like you to not do.

00:04:29.660 --> 00:04:35.610
Also, USB 2 is not inefficient.

00:04:35.900 --> 00:04:38.900
There's also some confusion
about this out there.

00:04:38.900 --> 00:04:43.110
USB 2,
the high speed and the full and low

00:04:43.110 --> 00:04:46.510
speed communications are segregated.

00:04:46.710 --> 00:04:49.060
They never share the same bus.

00:04:49.140 --> 00:04:54.250
So, the full and low speed communications
don't get in the way of the

00:04:54.250 --> 00:04:56.620
high speed communications.

00:04:57.830 --> 00:05:03.340
There is a theory out there that
if you plug a single USB 1.1

00:05:03.340 --> 00:05:06.300
device into a USB 2 system,
every high-speed device

00:05:06.300 --> 00:05:07.470
on the system slows down.

00:05:07.480 --> 00:05:08.820
This is not true.

00:05:08.820 --> 00:05:10.780
It is absolutely not true at all.

00:05:10.790 --> 00:05:12.660
We try and dispel myths like that.

00:05:12.660 --> 00:05:18.750
There is also some performance
tweaks in USB 2 to make it work

00:05:18.750 --> 00:05:22.180
even better than it did before.

00:05:23.380 --> 00:05:29.120
The bulk packets, all of them,
are now 512 bytes instead of the 64

00:05:29.120 --> 00:05:31.220
bytes or less that they were previously.

00:05:31.450 --> 00:05:34.680
This reduces the overhead
of protocol to data,

00:05:34.710 --> 00:05:36.220
so it will run faster.

00:05:36.220 --> 00:05:41.210
And then there's also things like the
Niet handshake and the ping protocol.

00:05:41.720 --> 00:05:46.160
Previously in USB 1,
if you wanted to send data out to

00:05:46.170 --> 00:05:50.260
a device and it couldn't accept it,
the host would go out and data,

00:05:50.260 --> 00:05:53.160
and the host would say,
it would receive the data and say, sorry,

00:05:53.160 --> 00:05:54.750
I couldn't actually deal with that,
oh well.

00:05:54.860 --> 00:05:57.630
And then you'd have to continue
sending all this data until it could,

00:05:57.700 --> 00:06:00.540
and this could use up an awful
lot of bandwidth doing nothing.

00:06:00.540 --> 00:06:02.910
Now the device can say,
you send the data out,

00:06:02.910 --> 00:06:05.960
and the device will say, yes, thank you,
I got that data,

00:06:05.960 --> 00:06:08.300
but I don't have any space for any more.

00:06:08.300 --> 00:06:10.140
It will say, niet, as a handshake.

00:06:10.990 --> 00:06:13.980
Now, niet actually just means not yet,
it has nothing to do with a

00:06:13.980 --> 00:06:15.820
Russian word which looks similar.

00:06:18.710 --> 00:06:23.040
So in this state,
the host will now not speculatively

00:06:23.040 --> 00:06:24.500
send data to the device.

00:06:24.500 --> 00:06:26.550
It will instead send pings.

00:06:26.670 --> 00:06:27.240
"Ping!

00:06:27.240 --> 00:06:31.100
Do you have any space for data?"
And if the device says "Nak", "No

00:06:31.100 --> 00:06:34.190
I don't." Or the device will say "Ack,
yes I do." And then you

00:06:34.230 --> 00:06:35.660
can carry on sending data.

00:06:35.660 --> 00:06:39.910
So you're not constantly using
up bandwidth doing nothing.

00:06:41.230 --> 00:06:45.180
Okay, what does it mean to you?

00:06:45.300 --> 00:06:47.650
In this case,
if you're a device developer,

00:06:47.770 --> 00:06:50.970
if you have a classic speed,
full or low speed device,

00:06:51.160 --> 00:06:53.740
and the answer is very little.

00:06:53.830 --> 00:06:56.960
If you want to make your device
a USB 2 device for some reason,

00:06:57.170 --> 00:07:01.100
all you need to do, usually,
is to change the version number

00:07:01.280 --> 00:07:02.330
in the device descriptor.

00:07:02.570 --> 00:07:07.650
Instantly, you're a USB 2 device.

00:07:07.650 --> 00:07:07.650
However,

00:07:08.320 --> 00:07:12.730
You should be sure to
conform to the 1.1 spec,

00:07:12.730 --> 00:07:17.660
because you should be sure to
store requests that you don't know.

00:07:17.720 --> 00:07:21.200
And in particular,
USB 2 defines a new descriptor,

00:07:21.400 --> 00:07:23.810
the device qualifier descriptor.

00:07:24.070 --> 00:07:27.090
This is used by the
system to ask the device,

00:07:27.100 --> 00:07:30.100
"What can you do if you're
plugged in at the other speed?"

00:07:30.270 --> 00:07:33.640
If you're a full-speed device,
you don't support this,

00:07:33.660 --> 00:07:35.800
because you don't support high speed.

00:07:35.800 --> 00:07:37.170
There is no other speed.

00:07:37.190 --> 00:07:39.970
So if the system asks this,
and you gave the wrong reply,

00:07:40.120 --> 00:07:42.760
the system may think that, hey,
it's capable of working

00:07:42.860 --> 00:07:43.700
at the other speed.

00:07:43.700 --> 00:07:46.040
I should tell the user,
plug it into a different port.

00:07:46.040 --> 00:07:46.840
It will work better.

00:07:46.840 --> 00:07:48.150
The user is confused.

00:07:48.270 --> 00:07:51.080
So be sure to store requests
that you don't know about.

00:07:51.080 --> 00:07:52.960
You should be doing this already.

00:07:52.970 --> 00:07:55.410
Whoever does, we don't know.

00:07:56.400 --> 00:07:58.960
Oh, sorry.

00:07:59.020 --> 00:08:04.330
Okay, and a slight modification
is that ISOC endpoints now

00:08:04.330 --> 00:08:07.080
must use no data by default.

00:08:07.130 --> 00:08:10.680
Previously, this was a very good idea
and a common practice,

00:08:10.700 --> 00:08:16.380
that in the unconfigured state,
or in the initially configured state,

00:08:16.380 --> 00:08:20.720
all the endpoints in an ISOC interface
would have zero bandwidth.

00:08:20.720 --> 00:08:24.500
You would then configure it to use
more bandwidth as you go along.

00:08:24.500 --> 00:08:27.900
This stops a device which
is actually plugged in,

00:08:27.900 --> 00:08:30.540
but idle, taking up bandwidth.

00:08:30.540 --> 00:08:33.470
So, the user will plug in a device,
not use it.

00:08:33.660 --> 00:08:36.280
Plug in the video camera he wants to use.

00:08:36.290 --> 00:08:38.130
He says, "Oh,
there's no bandwidth available."

00:08:38.150 --> 00:08:40.170
The other one is using it,
even though the user isn't.

00:08:40.290 --> 00:08:42.880
So, be careful with bandwidth,
and in particular,

00:08:42.880 --> 00:08:47.530
it's now a specification that you
should not use any bandwidth by default.

00:08:47.720 --> 00:08:51.320
There are also some changes to the
low-speed cabling requirements.

00:08:51.320 --> 00:08:54.680
If what's written on the slide
actually makes any sense to you,

00:08:54.770 --> 00:08:57.700
you should be sure to go
read Chapter 6 of the spec.

00:08:57.740 --> 00:08:59.380
In particular,
you should be sure to read the

00:08:59.470 --> 00:09:02.380
second half of Chapter 6 in the spec,
because the relevant parts in the

00:09:02.460 --> 00:09:05.330
first half don't mention this,
but the ones in the second half do.

00:09:05.340 --> 00:09:06.770
Oh, well.

00:09:12.600 --> 00:09:16.360
Okay,
what does it mean to device developers?

00:09:16.360 --> 00:09:17.600
You have a huge opportunity.

00:09:17.600 --> 00:09:20.340
You can make your
device work much faster.

00:09:20.340 --> 00:09:22.440
Users like this.

00:09:22.440 --> 00:09:25.980
And by much faster,
I mean that transferring,

00:09:25.980 --> 00:09:28.160
and say for isochnos
or interrupt devices,

00:09:28.160 --> 00:09:33.010
they can now have 24 megabytes a second.

00:09:33.150 --> 00:09:37.050
The obvious candidate for
this sort of thing is video.

00:09:37.170 --> 00:09:39.940
Video usually uses megabits,
so I should convert to

00:09:39.940 --> 00:09:40.900
megabits temporarily.

00:09:40.940 --> 00:09:45.180
This gives you 183 megabits a
second to use for your video.

00:09:45.210 --> 00:09:49.070
And if you consider that
DV is standard 25 megabits,

00:09:49.090 --> 00:09:50.660
you have plenty of space for DV.

00:09:50.950 --> 00:09:53.350
Uncompressed DV is 125 megabits.

00:09:53.390 --> 00:09:55.180
You can use uncompressed DV.

00:09:55.360 --> 00:09:57.920
You can use your imagination as to
what else you want to put in all

00:09:57.920 --> 00:10:00.490
this bandwidth that you have to use.

00:10:01.170 --> 00:10:04.280
Also, bulk runs much faster now.

00:10:04.500 --> 00:10:10.340
20 to 24 megabytes a second is pretty
typical transfer rates for bulk.

00:10:10.370 --> 00:10:13.740
So, typically now,
hard drives go a lot faster,

00:10:13.780 --> 00:10:15.730
and users are very happy by this.

00:10:15.740 --> 00:10:23.440
The transfer rate for bulk is mainly
constrained by the host controller.

00:10:23.460 --> 00:10:28.320
So, different host controller
implementations in future may go faster.

00:10:28.410 --> 00:10:34.120
We think that 35 to 40 megabytes
a second is not unreasonable

00:10:34.120 --> 00:10:35.320
for future controllers.

00:10:35.550 --> 00:10:37.940
In fact, I've seen an early
version of one recently,

00:10:37.940 --> 00:10:42.310
which actually looks like it could
manage 39 megabytes if I could find

00:10:42.380 --> 00:10:44.740
a hard drive fast enough to keep up.

00:10:47.070 --> 00:10:48.390
What does it mean to driver developers?

00:10:48.400 --> 00:10:50.440
I presume there's a lot of
driver developers out there.

00:10:50.450 --> 00:10:53.730
Hopefully, very little.

00:10:53.900 --> 00:10:55.820
We're here to make your life easy.

00:10:55.940 --> 00:10:59.780
And for most of you,
you should do nothing,

00:10:59.930 --> 00:11:01.030
and it will just work.

00:11:01.100 --> 00:11:02.580
This is USB.

00:11:02.700 --> 00:11:06.290
Once you've got over the fact
that it's running high speed,

00:11:06.440 --> 00:11:10.430
if it even is running high speed,
all the rest of the protocols are more

00:11:10.430 --> 00:11:14.160
or less the same as they were before,
with the exception of

00:11:14.230 --> 00:11:15.310
packet sizes and whatever.

00:11:16.150 --> 00:11:20.790
So in general, you should not care

00:11:21.100 --> 00:11:23.040
How fast your device is running.

00:11:23.050 --> 00:11:25.720
Just transfer the data
as fast as it's going,

00:11:25.720 --> 00:11:28.260
and be thankful that
it comes in that fast.

00:11:28.300 --> 00:11:29.890
Don't worry about it.

00:11:32.540 --> 00:11:36.200
The exception to this, of course,
is ISOC.

00:11:36.200 --> 00:11:39.260
If you're doing ISOC,
everything has changed.

00:11:39.270 --> 00:11:40.980
All the timings are different.

00:11:40.980 --> 00:11:45.810
Now, instead of the one millisecond
frames that you had before,

00:11:45.810 --> 00:11:49.510
you have 125 microsecond microframes.

00:11:49.520 --> 00:11:53.310
And you put together eight of these,
and you have a good old traditional

00:11:53.310 --> 00:11:54.900
frame at one millisecond.

00:11:54.920 --> 00:11:57.710
So all your timings now have
to be in terms of microframes,

00:11:57.710 --> 00:12:00.980
not frames, if you're doing high speed,
that is, of course.

00:12:01.600 --> 00:12:07.800
And in each one of these microframes,
you can transfer up to 3K of data.

00:12:07.800 --> 00:12:11.860
That adds up to the 24
megabytes I'd mentioned earlier.

00:12:15.730 --> 00:12:18.500
So, how is all this done?

00:12:18.520 --> 00:12:21.580
On the bus,
we use a new controller standard,

00:12:21.600 --> 00:12:25.190
the enhanced host controller interface.

00:12:25.430 --> 00:12:28.530
This is a companion to the
open host controller interface,

00:12:28.570 --> 00:12:34.630
which runs full speed and low speed,
as we did previously.

00:12:34.890 --> 00:12:40.560
There is support for this in Panther,
a new driver, the EHCI driver.

00:12:40.600 --> 00:12:44.190
The EHCI only works with high speed.

00:12:44.210 --> 00:12:46.080
As I mentioned,
the speeds are segregated.

00:12:46.280 --> 00:12:49.130
There will be more on this later.

00:12:49.160 --> 00:12:53.460
So, the EHCI is dealing there solely
with high speed transactions.

00:12:53.730 --> 00:12:56.530
It needs something to help it
with the full and low speed.

00:12:56.550 --> 00:13:00.940
It actually has companion controllers,
which in our case will

00:13:00.940 --> 00:13:04.210
be OHCI controllers,
like you're used to.

00:13:04.930 --> 00:13:08.600
And also, how is this done?

00:13:08.600 --> 00:13:10.650
You have all these
speeds going on at once,

00:13:10.650 --> 00:13:12.070
and they need to be segregated.

00:13:12.270 --> 00:13:13.900
The answer is magic hubs.

00:13:13.900 --> 00:13:16.850
And there's going to be more,
Rhoaads is going to be telling

00:13:16.850 --> 00:13:19.180
you a lot more about those later,
but these are really

00:13:19.180 --> 00:13:20.600
complicated beasties.

00:13:20.600 --> 00:13:22.680
They've got most of a
host controller in them,

00:13:22.810 --> 00:13:26.220
because they have to translate between
high speed and full and low speed.

00:13:28.890 --> 00:13:32.100
So, how are you going to do it?

00:13:32.240 --> 00:13:33.600
First of all,
you need some hardware which

00:13:33.600 --> 00:13:37.440
supports USB 2.0 high speed.

00:13:37.440 --> 00:13:40.110
You can either buy one of
our lovely new Macintosh G5s,

00:13:40.110 --> 00:13:43.560
or you can get yourself a
PCI card or a PC card and plug

00:13:43.560 --> 00:13:45.900
it into your existing hardware.

00:13:46.440 --> 00:13:48.440
Then you need some software.

00:13:48.440 --> 00:13:52.410
You need the version of the
USB family we have in Panther.

00:13:52.410 --> 00:13:54.950
This will enable high speed.

00:13:55.020 --> 00:13:58.860
The version number of
the software is now 2.0.

00:13:58.860 --> 00:14:02.490
We reserved the number 2.0 a
long time ago so that no one

00:14:02.490 --> 00:14:07.530
would ever get confused between
USB spec 2.0 and USB software 2.0.

00:14:07.600 --> 00:14:09.920
There's been plenty of that
sort of thing in the past,

00:14:09.920 --> 00:14:11.140
and we didn't want to do it.

00:14:11.140 --> 00:14:13.630
As you notice,
we've almost run out of version numbers.

00:14:13.630 --> 00:14:15.420
We're up to 1.99 already.

00:14:15.460 --> 00:14:16.420
So, it's good.

00:14:16.420 --> 00:14:17.480
Good job we did it now.

00:14:17.480 --> 00:14:19.780
Okay.

00:14:19.780 --> 00:14:24.010
When writing your driver,
I suggest that you first of all do

00:14:24.030 --> 00:14:29.290
it full speed like you're used to,
and then plug it into a high speed port,

00:14:29.290 --> 00:14:32.720
and it will just work,
and you'll be happy.

00:14:32.720 --> 00:14:34.530
And like I said, we make it easy for you.

00:14:34.800 --> 00:14:37.260
However, if it doesn't work,
this may be where the harsh

00:14:37.260 --> 00:14:39.120
introduction to USB 2.0 is.

00:14:39.120 --> 00:14:40.520
So, be careful.

00:14:40.520 --> 00:14:41.360
Okay.

00:14:41.360 --> 00:14:42.600
Tools you might use.

00:14:42.600 --> 00:14:47.700
I may have mentioned before that
I think a USB analyzer... ...is a really

00:14:47.700 --> 00:14:49.940
useful thing to do USB software with.

00:14:50.020 --> 00:14:54.000
And it still is a really useful
thing to do USB software with.

00:14:54.060 --> 00:14:56.180
Now,
if you're doing high speed development,

00:14:56.180 --> 00:14:58.770
you should really get yourself
a high speed analyzer.

00:14:58.780 --> 00:15:02.060
The usual suspects make
high speed analyzers.

00:15:02.060 --> 00:15:03.400
Cat C has the advisor.

00:15:03.400 --> 00:15:05.220
Catalyst has the SBA20.

00:15:05.220 --> 00:15:07.940
Data Transit has the
pod for their machine.

00:15:07.940 --> 00:15:10.800
They have pods for every
sort of bus imaginable.

00:15:10.800 --> 00:15:13.460
And I'm sure there's more out there,
and I didn't mean to

00:15:13.630 --> 00:15:14.810
leave them off the list.

00:15:16.730 --> 00:15:21.100
Okay, now I want to tell you a little
bit about high-speed ISOC.

00:15:21.270 --> 00:15:26.830
As I mentioned before,
high-speed ISOC is different.

00:15:28.210 --> 00:15:29.630
The driver has to know
that it's different.

00:15:29.640 --> 00:15:31.440
The device has to know
that it's different.

00:15:31.440 --> 00:15:33.540
Say the timings are different.

00:15:33.560 --> 00:15:39.200
You have 125 microsecond microframes
instead of the 1 millisecond frames.

00:15:39.200 --> 00:15:45.800
And the amount of data you can transfer
in any microframe is increased to 3K.

00:15:45.800 --> 00:15:50.300
There is one small wrinkle in this,
is that now the frequency of an

00:15:50.550 --> 00:15:53.410
ISOC transaction does not have to be one.

00:15:53.420 --> 00:15:58.770
You don't have to do one every microframe
or one every frame as you used to.

00:15:58.780 --> 00:16:02.340
You can now specify 2
or 4 or 16 or whatever.

00:16:02.340 --> 00:16:05.490
However, we haven't seen any
devices which do this,

00:16:05.490 --> 00:16:07.810
so we have not implemented that yet.

00:16:07.850 --> 00:16:09.710
If you have one,
we'd love to hear from you.

00:16:11.390 --> 00:16:16.300
Okay, having said that high-speed
ISOC is different,

00:16:16.300 --> 00:16:19.530
high-speed ISOC is also the same,
in that we recycle the old APIs,

00:16:19.530 --> 00:16:25.690
use exactly the same APIs,
we just treat the parameters you

00:16:25.690 --> 00:16:25.690
send us a little differently.

00:16:29.720 --> 00:16:33.640
As I said, high-speed ISOC is different
from the device's perspective.

00:16:33.640 --> 00:16:36.730
The packets on the bus are different,
the timings are different,

00:16:36.940 --> 00:16:39.240
you have 125 microsecond microframes.

00:16:39.280 --> 00:16:44.920
Here are diagrams of
what the device sees.

00:16:44.920 --> 00:16:49.560
If you have a small transaction,
less than 1K, and note you can actually

00:16:49.630 --> 00:16:51.970
go up to 1024 bytes,
where you could only

00:16:52.040 --> 00:16:55.460
previously go up to 1023,
it's still just in one data zero packet,

00:16:55.460 --> 00:16:57.070
like it always used to be.

00:16:57.530 --> 00:17:02.090
However, if you need more data
than that in a microframe,

00:17:02.090 --> 00:17:07.720
you send multiple packets of a suitable
size to add up to the size that you want.

00:17:07.720 --> 00:17:12.580
It will say, if you're sending data out,
the host will say, here's a packet,

00:17:12.580 --> 00:17:17.440
there's more to come, by saying data one,
data zero, or data two, data one,

00:17:17.450 --> 00:17:20.290
data zero, it will count down like that.

00:17:20.690 --> 00:17:25.860
Similarly, if the device wants to send
the host multiple data packets.

00:17:27.140 --> 00:17:30.310
If you're 1K or less,
it will just send the single

00:17:30.730 --> 00:17:33.110
data packet like it always did.

00:17:33.140 --> 00:17:36.800
If it's more than 1K,
you send it in multiple data packets,

00:17:36.800 --> 00:17:39.390
the device will say,
there's more to come,

00:17:39.390 --> 00:17:44.260
there's more to come, oh, that was it,
and you got one or two extra packets.

00:17:44.260 --> 00:17:49.530
That's encoded in the packet
identifiers sent with these.

00:17:49.540 --> 00:17:56.580
Interrupt will also allow you
to do 3K of data per microframe.

00:17:57.190 --> 00:17:59.590
But it uses the same old data zero,
data one,

00:17:59.590 --> 00:18:01.850
alternating PIDs that it always did.

00:18:05.110 --> 00:18:08.480
Okay, the high-speed ISOC APIs.

00:18:08.500 --> 00:18:12.400
As I said, the APIs used are the same
as they were previously.

00:18:12.430 --> 00:18:16.470
The interpretation of some of
the parameters is different.

00:18:16.500 --> 00:18:22.120
Here you see a typical
ISOC API read ISOC byte async.

00:18:22.170 --> 00:18:25.160
And the first thing to note,
or the things to note are the ones,

00:18:25.160 --> 00:18:27.310
the parts highlighted in orange.

00:18:27.460 --> 00:18:31.310
And first to note is the frame start.

00:18:31.530 --> 00:18:35.460
Now, frame start has not changed,
even if it... Oh, sorry,

00:18:35.460 --> 00:18:36.920
I missed something out there.

00:18:36.940 --> 00:18:42.940
Whereas previously you had frames,
it's now you should consider these

00:18:42.940 --> 00:18:44.960
to be transfer opportunities.

00:18:44.960 --> 00:18:48.170
Where an API said frame,
you should interpret that as saying

00:18:48.470 --> 00:18:51.810
you now have a transfer opportunity,
whether it's a transfer

00:18:51.810 --> 00:18:54.760
opportunity once per millisecond,
or transfer opportunity

00:18:54.880 --> 00:18:55.960
once per microframe.

00:18:56.520 --> 00:19:00.870
So as I was saying, the frame start,
however, has not changed.

00:19:00.900 --> 00:19:04.670
A high-speed ISOC transaction
starts on a frame boundary,

00:19:04.670 --> 00:19:06.790
not on a microframe boundary.

00:19:08.600 --> 00:19:13.940
Next, the num frames is now the number
of transfers you want to happen.

00:19:14.130 --> 00:19:19.060
Either a number of frames for full speed,
or a number of microframes

00:19:19.210 --> 00:19:21.290
for high speed.

00:19:21.440 --> 00:19:25.180
And finally,
the frame list now specifies the

00:19:25.180 --> 00:19:31.050
list of transfers that you want
to happen either in frames or

00:19:31.050 --> 00:19:34.670
in microframes for high speed.

00:19:36.360 --> 00:19:42.130
and there is also a new API,
Get Framelist Time,

00:19:42.150 --> 00:19:46.100
which actually tells you how long
your transfer opportunity lasts,

00:19:46.100 --> 00:19:49.970
either 125 microseconds
or 1,000 microseconds,

00:19:49.970 --> 00:19:54.710
so you know what the timing should be,
or in effect,

00:19:54.710 --> 00:19:57.090
whether you're running full speed or
whether you're running high speed.

00:19:59.640 --> 00:20:01.110
Okay?

00:20:01.250 --> 00:20:08.470
So, in summary, USB 2 is USB,
but it will run faster

00:20:08.470 --> 00:20:11.290
if it's high speed,
if there's a high speed host,

00:20:11.360 --> 00:20:13.580
and if there's a high speed device.

00:20:13.690 --> 00:20:20.520
But most of the time,
it looks just like the

00:20:20.520 --> 00:20:20.520
USB you always knew and loved.

00:20:21.190 --> 00:20:27.420
As I say, USB 2.0 is just like full speed
if you're not a high speed device.

00:20:27.480 --> 00:20:31.640
And don't worry about the
speed if you do not have to.

00:20:31.700 --> 00:20:34.100
Just transfer the data
and don't worry about it.

00:20:34.240 --> 00:20:38.630
You do need to worry about the
speed if you're doing ISOC there.

00:20:39.330 --> 00:20:43.990
And the high-speed
ISOC APIs are different.

00:20:44.170 --> 00:20:48.400
We use the same APIs, but we reinterpret
some of the parameters.

00:20:48.470 --> 00:20:51.750
And with that,
I shall turn it over to Rhoaads.

00:20:51.780 --> 00:20:57.310
Thank you very much, Barry.

00:21:00.400 --> 00:21:05.240
Okay, I'm going to talk a little
bit about USB 2.0 hubs.

00:21:05.240 --> 00:21:10.810
The USB Implementers Forum worked very
hard to make sure that USB devices just

00:21:10.940 --> 00:21:18.140
worked no matter whether you were on
an old USB 1.1 bus or on a USB 2.0 bus.

00:21:18.230 --> 00:21:26.110
And as Barry said, however,
the data traffic is actually segregated.

00:21:26.110 --> 00:21:32.140
You do not have full speed and low speed
data on the same wire as high speed.

00:21:33.300 --> 00:22:33.500
[Transcript missing]

00:22:34.090 --> 00:22:39.670
Now most of this is transparent to
driver writers because the drivers

00:22:39.680 --> 00:22:43.500
don't really care too much about
which kind of host they're on.

00:22:43.600 --> 00:22:47.720
The exception would be the hub drivers,
which do need to know whether the

00:22:47.770 --> 00:22:51.260
hub is attached to a high speed
bus running in high speed mode,

00:22:51.260 --> 00:22:55.170
or to a full speed bus
running in full speed mode.

00:22:55.310 --> 00:22:58.900
Luckily Apple produces the
hub driver for Mac OS X,

00:22:58.900 --> 00:23:03.370
and so you wouldn't necessarily
need to worry about that.

00:23:04.990 --> 00:23:11.340
Now, having this magic hub can cause some
problems if it's not configured properly.

00:23:11.340 --> 00:23:13.990
For example,
you may have a high-speed hub,

00:23:14.090 --> 00:23:16.140
and if you plug it into the
root hub of your computer,

00:23:16.140 --> 00:23:17.590
it runs in high-speed mode.

00:23:17.590 --> 00:23:21.120
If, however,
you plug it into a keyboard hub or

00:23:21.190 --> 00:23:25.190
a display hub that is a 1.1 hub,
your high-speed hub has now

00:23:25.330 --> 00:23:27.130
become a full-speed hub.

00:23:27.170 --> 00:23:31.260
And this can cause some confusion if you
have high-speed devices attached to it,

00:23:31.260 --> 00:23:33.710
and you want them to
work in high-speed mode.

00:23:34.420 --> 00:23:38.250
Because once a hub is running in
full-speed mode or low-speed mode,

00:23:38.250 --> 00:23:42.300
well, full-speed mode,
then all downstream devices of

00:23:42.300 --> 00:23:46.880
that hub have now become full-
or low-speed mode devices.

00:23:47.100 --> 00:23:52.140
Now the segregation that happens between
the high speed bus and full speed and low

00:23:52.140 --> 00:23:57.750
speed devices happens in something inside
the hub called a transaction translator.

00:23:57.860 --> 00:24:01.090
Now these transaction translators,
there is at least one of

00:24:01.160 --> 00:24:03.560
these in every high speed hub.

00:24:03.640 --> 00:24:07.490
And in most high speed hubs that
I've seen on the market today,

00:24:07.500 --> 00:24:10.060
there is exactly one
transaction translator.

00:24:10.150 --> 00:24:14.560
However, it's possible to have a
transaction translator on

00:24:14.570 --> 00:24:17.200
every port of a high speed hub.

00:24:17.270 --> 00:24:20.020
And this produces a
much more complex hub,

00:24:20.160 --> 00:24:24.970
but at the same time
allows some benefits.

00:24:25.220 --> 00:24:29.360
You can have one full speed
controller's worth of bandwidth for

00:24:29.360 --> 00:24:34.600
isochronous and interrupt endpoints
on each transaction translator.

00:24:34.640 --> 00:24:38.500
Which means if you have one transaction
translator in a high speed hub,

00:24:38.500 --> 00:24:41.570
you have one full speed

00:24:42.100 --> 00:24:53.200
[Transcript missing]

00:24:53.680 --> 00:24:59.080
So multi-TT hubs can have
more full-speed ISOC devices,

00:24:59.190 --> 00:25:02.740
for example, attached than a single
TT hub would be able to have.

00:25:02.800 --> 00:25:07.190
Again, the root hub, being special,
does not use transaction

00:25:07.190 --> 00:25:08.290
translators at all.

00:25:08.340 --> 00:25:13.190
What happens is when you plug in a
full-speed device to a root hub port,

00:25:13.190 --> 00:25:17.610
the high-speed controller sees
that it's a full-speed device and

00:25:17.610 --> 00:25:22.690
electrically disconnects itself from
the port and passes the connection

00:25:22.770 --> 00:25:26.000
over to the companion controller,
and that device is now

00:25:26.000 --> 00:25:27.960
running on an OHCI controller.

00:25:29.720 --> 00:25:35.080
These transaction translators in the hub
are therefore store and forward units

00:25:35.290 --> 00:25:37.600
for what are called split transactions.

00:25:41.260 --> 00:25:45.560
Now, a split transaction essentially
is a transaction where when the

00:25:45.560 --> 00:25:50.200
host wants to talk to a full-speed
device or a low-speed device,

00:25:50.200 --> 00:25:53.540
it transfers information to
the hub to which that device

00:25:53.540 --> 00:25:56.650
is attached in high-speed mode.

00:25:56.650 --> 00:26:00.450
The hub stores that information,
buffers it up,

00:26:00.450 --> 00:26:05.870
and then transfers the information to or
from the full-speed or low-speed device,

00:26:05.870 --> 00:26:10.240
separate from any activity
happening on the high-speed bus.

00:26:11.410 --> 00:26:19.630
This transfer occurs in two parts
called start split and complete split.

00:26:19.660 --> 00:26:23.640
And in between a start
split and a complete split,

00:26:23.640 --> 00:26:26.840
which is the information going
to and from the high-speed hub,

00:26:26.840 --> 00:26:31.870
there can be more high-speed activity
happening while the hub is doing

00:26:31.960 --> 00:26:37.140
full-speed or low-speed communication
with the downstream device.

00:26:37.140 --> 00:26:40.740
Now, this works very nicely.

00:26:41.210 --> 00:26:43.880
And allows you to plug in
devices into a hub without really

00:26:43.950 --> 00:26:46.250
paying much attention to it,
but it can have some

00:26:46.310 --> 00:26:47.960
significant performance issues.

00:26:47.960 --> 00:26:51.590
And you probably should
be aware of these.

00:26:51.730 --> 00:26:52.050
Here.

00:26:52.050 --> 00:26:55.440
So here's, let me show you graphically
why that occurs,

00:26:55.530 --> 00:26:57.260
why you can have some performance issues.

00:26:57.380 --> 00:27:04.460
Let's say that I have a host,
and I have a full speed hard drive

00:27:05.050 --> 00:27:06.660
attached to a high speed hub.

00:27:06.700 --> 00:27:10.480
And the host needs to send out a
data packet to this hard drive,

00:27:10.480 --> 00:27:13.630
and it's an out packet from
the host to the hard drive.

00:27:13.740 --> 00:27:18.700
So what happens is first the host
sends a start split command to the hub,

00:27:19.010 --> 00:27:22.090
saying I have a packet,
a data out packet destined

00:27:22.170 --> 00:27:23.690
for this hard drive.

00:27:23.760 --> 00:27:27.520
It sends the out PID to specify
that it is an out packet.

00:27:27.520 --> 00:27:31.700
Sends the data,
a 64 byte data packet for example,

00:27:31.910 --> 00:27:35.550
and receives an acknowledgement
from the high speed hub that that

00:27:35.550 --> 00:27:37.700
data was successfully received.

00:27:37.810 --> 00:27:41.460
However, that acknowledgement is that
it was received by the hub,

00:27:41.460 --> 00:27:43.700
not that it was received by the device.

00:27:43.700 --> 00:27:46.810
Then the host and the hub,
or the host and other high speed

00:27:46.940 --> 00:27:48.700
devices can continue to talk.

00:27:48.700 --> 00:27:50.700
So the host sends the
data packet to the device,

00:27:50.700 --> 00:27:51.690
while the hub starts its
transfer to the device itself.

00:27:51.700 --> 00:27:54.670
So it sends the same
out PID to the device.

00:27:54.790 --> 00:27:57.390
It sends the 64 byte
packet to the device,

00:27:57.440 --> 00:27:59.700
which takes significantly
longer at this point.

00:27:59.700 --> 00:28:03.110
And it receives an acknowledgement
from the device that everything

00:28:03.120 --> 00:28:04.570
was received successfully.

00:28:04.970 --> 00:28:08.980
Now the hub remembers that
acknowledgement and says,

00:28:09.080 --> 00:28:11.700
okay,
at some point the host is going to ask me

00:28:11.730 --> 00:28:13.690
whether the device got the data or not.

00:28:13.700 --> 00:28:18.700
So when the host is able to do so,
it sends a complete split to the device.

00:28:18.790 --> 00:28:20.670
So the host sends the
data packet to the device,

00:28:20.750 --> 00:28:28.700
and then the hub is able to then
acknowledge that transaction.

00:28:29.190 --> 00:28:35.070
So that completes what used to be an
old fashioned out data ACK packet,

00:28:35.090 --> 00:28:38.370
but it takes a little bit longer.

00:28:39.800 --> 00:28:45.090
The time between when the full-speed
device acknowledges the receipt

00:28:45.140 --> 00:28:49.090
of the data and the beginning of
the complete split transaction can

00:28:49.090 --> 00:28:52.820
depend on what other activity is
happening on the high-speed bus.

00:28:52.820 --> 00:28:58.300
And because of this,
it causes some significant delay in,

00:28:58.640 --> 00:29:02.940
or can cause significant
delay in this data.

00:29:03.080 --> 00:29:06.410
And the upshot of this is
that a full-speed hard drive,

00:29:06.520 --> 00:29:09.850
for example,
attached to a high-speed hub can end up

00:29:09.850 --> 00:29:15.930
functioning to the point where the actual
throughput to the drive is half what it

00:29:15.930 --> 00:29:18.450
is if it's attached to a full-speed bus.

00:29:21.830 --> 00:29:25.850
Now, some hubs, as I mentioned earlier,
high speed hubs, have a single TT and

00:29:25.850 --> 00:29:27.920
some have multiple TTs.

00:29:27.920 --> 00:29:30.320
And as I mentioned,
each transaction translator

00:29:30.320 --> 00:29:33.380
essentially is a full speed bus.

00:29:33.380 --> 00:29:37.320
So this is especially important
for people doing ISOC work

00:29:37.320 --> 00:29:41.050
with these hubs because,
let's take for an example,

00:29:41.050 --> 00:29:46.240
if you have a camera that transfers
980 bytes per millisecond frame,

00:29:46.240 --> 00:29:47.770
it's a full speed camera.

00:29:47.920 --> 00:29:50.200
Well,
if you have two of these cameras and

00:29:50.200 --> 00:29:54.730
you try to plug them into two ports of
a single transaction translator hub,

00:29:54.730 --> 00:29:59.140
only one of the cameras is going to work
because that's going to saturate the full

00:29:59.140 --> 00:30:01.620
speed bandwidth available to that hub.

00:30:01.640 --> 00:30:07.560
If the hub has multi TTs and you
plug a camera into each of two ports,

00:30:07.580 --> 00:30:12.690
each port has its own full
speed isochronous bandwidth

00:30:12.690 --> 00:30:15.260
and both cameras can work.

00:30:15.440 --> 00:30:21.900
A more likely example might be a
camera with a microphone for input

00:30:21.900 --> 00:30:27.880
and a pair of USB speakers for output,
all of which use isochronous bandwidth.

00:30:27.970 --> 00:30:32.080
And so with a single TT hub,
you may have a difficult time or have

00:30:32.290 --> 00:30:37.010
reduced quality of your video input or
output because you're trying to share

00:30:37.010 --> 00:30:40.980
the bandwidth amongst all the devices,
whereas with a multi TT hub,

00:30:40.980 --> 00:30:44.050
you'd be able to plug both the
camera and the speakers into two

00:30:44.050 --> 00:30:47.060
separate ports and they and they
each have their own bandwidth,

00:30:47.060 --> 00:30:50.050
so it's fine.

00:30:51.160 --> 00:30:56.940
Multi TT hubs also allow for better
throughput with bulk devices as well.

00:30:59.150 --> 00:31:02.080
Now, I have mentioned before that the
root hub is different because we

00:31:02.100 --> 00:31:05.380
have these companion controllers,
so there's no need for the

00:31:05.380 --> 00:31:06.740
transaction translator.

00:31:06.770 --> 00:31:10.310
Again, the EHCI driver,
if it exists in the system,

00:31:10.340 --> 00:31:12.670
determines that, oh,
this is a full-speed device,

00:31:12.670 --> 00:31:15.280
I need to switch it over to
the companion controller,

00:31:15.320 --> 00:31:19.140
and it disconnects itself
from that particular port.

00:31:19.330 --> 00:31:21.970
So, no split transactions are necessary.

00:31:22.210 --> 00:31:27.190
What ends up happening is you
have a completely separate

00:31:27.580 --> 00:31:30.260
and the O-H-C-I controller
running your full speed,

00:31:30.260 --> 00:31:32.500
low speed devices,
and you get the same performance

00:31:32.500 --> 00:31:38.250
as you do today on a full
speed O-H-C-I controller.

00:31:39.080 --> 00:31:42.970
So in summary,
split transactions allow for a seamless

00:31:42.970 --> 00:31:47.000
transition from USB 1.1 to USB 2.0.

00:31:47.000 --> 00:31:49.220
Your full speed,
low speed devices just work.

00:31:49.220 --> 00:31:51.480
You plug them into a hub
and everything works great.

00:31:51.580 --> 00:31:54.520
However, you can end up with some
performance issues which you

00:31:54.530 --> 00:31:56.700
might want to be aware of.

00:31:56.750 --> 00:32:02.610
And any performance critical full
speed devices may want to consider

00:32:02.680 --> 00:32:06.560
Somehow telling the user to
put the device on an OHCI bus.

00:32:06.560 --> 00:32:10.710
One way to do this, for example,
would be let's say you have

00:32:10.710 --> 00:32:14.630
two EHCI ports on a computer,
or three or four from

00:32:14.680 --> 00:32:16.080
a PCI card or whatnot.

00:32:16.080 --> 00:32:19.440
You might plug a high speed hub into
one port and a full speed hub into

00:32:19.500 --> 00:32:22.290
another port and have all the high
speed devices living on the high

00:32:22.290 --> 00:32:26.780
speed hub and all the full speed
devices living on the full speed hub.

00:32:26.780 --> 00:32:32.400
Because a full speed hub will provide
data transfer on the full speed OHCI bus,

00:32:32.400 --> 00:32:37.920
and a high speed hub will provide
these transfers on the high speed bus.

00:32:38.590 --> 00:32:41.950
So with that, I'm going to turn it
over to Fernando Urbina,

00:32:41.950 --> 00:32:44.770
and he's going to talk
about the new APIs.

00:32:47.400 --> 00:32:47.850
Thank you, Mr.

00:32:47.850 --> 00:32:48.130
Rhodes.

00:32:48.160 --> 00:32:54.310
We're going to leave USB 2.0 aside
for a little bit now and talk about

00:32:54.310 --> 00:32:59.330
what we've been doing since the
last time we've met with respect

00:32:59.330 --> 00:33:01.760
to adding APIs to our family.

00:33:02.180 --> 00:33:07.380
We've added both kernel
and IOUSB library updates,

00:33:07.380 --> 00:33:12.960
and on request from multiple developers,
we finally have a way to get the

00:33:13.040 --> 00:33:18.170
version number of the family and the
USB library programmatically instead

00:33:18.180 --> 00:33:22.230
of having to go by hand to get the
CFBundle version and all that stuff.

00:33:22.240 --> 00:33:25.080
So that is available to you.

00:33:25.080 --> 00:33:32.140
We did add, like Barry mentioned,
a couple of USB 2.0 related APIs.

00:33:32.260 --> 00:33:37.390
One is to get the frame list time,
whether it's 125 microseconds

00:33:37.390 --> 00:33:40.190
or 1,000 microseconds.

00:33:40.200 --> 00:33:46.000
And the other one is to get
the bus microframe number.

00:33:46.000 --> 00:33:50.630
And actually,
this 64-bit value encodes both the

00:33:50.630 --> 00:33:57.000
frame number and the microframe number
at the time that the call is made.

00:33:57.020 --> 00:34:03.220
And just like the regular bus
frame... So you get bus frame number.

00:34:03.220 --> 00:34:10.680
It is time stamped so that you can know
when we exactly got that frame number.

00:34:14.130 --> 00:34:17.090
One request that we've had
for a long time as well was

00:34:17.380 --> 00:34:23.900
to have a more straightforward
API to recover from a stall.

00:34:23.900 --> 00:34:28.670
Presently, when you get a stall,
you have to clear the data toggle both

00:34:28.710 --> 00:34:33.390
on the controller and on that device,
and this involves having to

00:34:33.480 --> 00:34:37.140
issue a device request to your
device with a set feature,

00:34:37.140 --> 00:34:38.800
endpoint halt, blah, blah, blah, blah,
blah.

00:34:38.800 --> 00:34:44.530
Now you have this clear pipe stall
both ends that will do that for you,

00:34:44.860 --> 00:34:47.200
and so that will make your life easier.

00:34:49.390 --> 00:34:56.930
We also augmented the isochronous
APIs to help you and us

00:34:56.930 --> 00:35:01.380
manage the bandwidth better.

00:35:01.380 --> 00:35:06.280
One of the big differences, however,
since we introduced this API,

00:35:06.330 --> 00:35:11.700
is that when you create an interface,
which in turn creates the pipe

00:35:11.700 --> 00:35:16.880
objects for your endpoints,
previously we would fail that

00:35:16.880 --> 00:35:22.890
call if there was not enough
bandwidth to create the pipes.

00:35:23.150 --> 00:35:28.780
With these new APIs,
we will now create the pipes even

00:35:28.780 --> 00:35:32.000
if there is not enough bandwidth.

00:35:32.170 --> 00:35:35.850
And so your pipes will actually have
zero bandwidth allocated to them,

00:35:35.910 --> 00:35:38.610
so you have to be able to

00:35:38.730 --> 00:35:45.960
Realize this and do something appropriate
like allocating bandwidth for them.

00:35:46.460 --> 00:35:49.060
These are the new APIs.

00:35:49.060 --> 00:35:52.070
The first two,
the GetBandwidthAvailable and

00:35:52.300 --> 00:35:57.420
the GetEndpointProperties,
are unique in the sense that you

00:35:57.420 --> 00:36:03.240
don't have to have the USB interface
open in order to make these calls.

00:36:03.300 --> 00:36:08.300
BandwidthAvailable is
pretty straightforward.

00:36:08.300 --> 00:36:13.300
It just tells you how many
bytes are available in the bus.

00:36:14.470 --> 00:36:19.450
The GetEndpointProperties will allow you
to inquire of the different alternate

00:36:19.570 --> 00:36:25.290
settings of a particular interface to
see how much bandwidth they would use.

00:36:25.300 --> 00:36:28.450
So typically you would get
the bandwidth available,

00:36:28.450 --> 00:36:31.300
iterate through all
your alternate settings,

00:36:31.300 --> 00:36:37.470
pick one that has a lower
amount of bandwidth,

00:36:37.470 --> 00:36:42.300
and then call SetAlternateInterface,
and this call is not really new,

00:36:42.300 --> 00:36:43.300
it's just here for completeness.

00:36:43.340 --> 00:36:46.830
To create that interface and
allocate the pipe objects,

00:36:46.900 --> 00:36:50.770
then, very importantly,
you should call GetPipeProperties

00:36:50.880 --> 00:36:54.710
on that isochronous endpoint,
or isochronous pipe object,

00:36:54.770 --> 00:36:59.300
and make sure that the max packet
size for that endpoint is not zero.

00:36:59.300 --> 00:37:02.120
If it is zero,
it meant that even though we

00:37:02.160 --> 00:37:06.150
had told you that there was
bandwidth available earlier,

00:37:06.150 --> 00:37:10.980
somebody might have come in and
grabbed that bandwidth away from you,

00:37:10.980 --> 00:37:13.300
and it's not going to be zero.

00:37:14.300 --> 00:37:15.300
And it's not there anymore.

00:37:15.300 --> 00:37:21.890
So you should really make sure that
once your pipes are created once again,

00:37:21.890 --> 00:37:25.300
there is enough bandwidth for them.

00:37:26.170 --> 00:37:29.770
Finally,
we're back to par with our Mac OS 9

00:37:29.770 --> 00:37:35.040
implementation in the sense that
we have a set by policy API.

00:37:35.060 --> 00:37:40.580
And this essentially allows you to
return bandwidth to the system if

00:37:40.580 --> 00:37:46.290
you know that you're never going to
use the amount of bandwidth that was

00:37:46.340 --> 00:37:49.230
specified in the alternate settings.

00:37:49.320 --> 00:37:54.330
The granularity of the alternate
settings in an interface depends on

00:37:54.440 --> 00:37:57.180
the whim of the device manufacturer.

00:37:57.190 --> 00:38:01.870
And you might know that you're not
going to use all that because there's

00:38:02.090 --> 00:38:06.580
never going to be a case where the
device is going to send that data.

00:38:06.630 --> 00:38:11.030
So be a good citizen and
call set by policy and return

00:38:11.190 --> 00:38:13.710
that bandwidth back to us.

00:38:15.530 --> 00:38:22.400
For 10.2.3, we added some new APIs that
I'm going to talk about now.

00:38:22.400 --> 00:38:28.400
These were trying to solve what
I call the latency problem.

00:38:28.400 --> 00:38:30.290
What is the latency?

00:38:30.420 --> 00:38:33.360
Most of you are probably
aware that on Mac OS X,

00:38:33.360 --> 00:38:39.710
the time between when the hardware
transaction completes on the bus

00:38:39.900 --> 00:38:43.470
and your callback is called varies.

00:38:43.810 --> 00:38:48.980
Sometimes it comes right away,
but sometimes it can be delayed

00:38:49.250 --> 00:38:53.280
for 80 milliseconds or more.

00:38:53.850 --> 00:38:57.920
The callback happens
on the IOUSB work loop,

00:38:57.960 --> 00:39:01.690
and there are other threads that run at
a higher priority than that work loop,

00:39:01.770 --> 00:39:10.630
and if they're doing work,
your callback will be delayed.

00:39:10.770 --> 00:39:16.740
This presents a problem in some cases,
but you can work around it like you

00:39:16.740 --> 00:39:23.540
have done in Mac OS 9 and in previous
versions by keeping the ISOC endpoint

00:39:23.540 --> 00:39:28.560
busy and having multiple transactions,
so that even if your callback is delayed,

00:39:28.560 --> 00:39:33.760
it doesn't matter because you have
already scheduled a transaction to start

00:39:33.760 --> 00:39:36.530
prior to your callback being called.

00:39:36.550 --> 00:39:41.530
So that's great and that
works very well in most cases.

00:39:41.870 --> 00:39:45.510
However, sometimes there is a problem.

00:39:46.700 --> 00:41:02.200
[Transcript missing]

00:41:02.400 --> 00:41:07.980
So, we thought about it,
and we came with the following solution.

00:41:07.980 --> 00:41:12.290
We realized that this being USB,
and isochronous USB especially,

00:41:12.300 --> 00:41:19.300
the data from the device was in
the user's buffer as soon as the

00:41:19.650 --> 00:41:23.090
USB controller completed that frame.

00:41:23.470 --> 00:41:29.200
However, we lacked one critical piece of
information that was not in the buffer.

00:41:29.200 --> 00:41:33.120
In fact, it's in the USB controller,
and that is how many bytes

00:41:33.120 --> 00:41:35.300
were actually transferred.

00:41:35.690 --> 00:41:40.720
Isochronous data varies in the amount,
even though you ask for

00:41:40.720 --> 00:41:44.770
a certain amount of data,
it can transfer more or less.

00:41:44.770 --> 00:41:49.610
And so you need to actually
know how much data was there.

00:41:51.190 --> 00:41:55.640
However, realizing this,
we knew that then the client could go and

00:41:55.640 --> 00:42:03.750
peek into the buffer that they gave us
and get that data at the expected time,

00:42:03.750 --> 00:42:09.560
if only they had the appropriate
number of bytes that were

00:42:10.160 --> 00:42:12.600
transferred in that frame.

00:42:12.900 --> 00:42:20.890
So we augmented the frameless
structure to actually have a timestamp.

00:42:23.230 --> 00:42:28.630
We decided to update the actual number,
what is called the FR actual count,

00:42:28.740 --> 00:42:31.220
at primary interrupt time.

00:42:31.320 --> 00:42:34.760
Now doing processing at primary
interrupt time is sort of dicey

00:42:34.760 --> 00:42:39.300
because you are preventing any other
thread from running at that time.

00:42:39.300 --> 00:42:44.430
So we really have to do some
minimal processing at that time,

00:42:44.430 --> 00:42:47.300
and what we do is we look
through our structures,

00:42:47.390 --> 00:42:51.060
get the number of bytes
from the controller,

00:42:51.060 --> 00:42:54.300
update the frame list, and get out.

00:42:54.300 --> 00:43:00.300
Your callback will still happen at the
same time that it's happened in the past.

00:43:00.610 --> 00:43:03.240
However, since you know when the
data was going to be there,

00:43:03.360 --> 00:43:07.790
you can go and look at your data buffer
and at your frame list buffer and know

00:43:07.790 --> 00:43:10.300
how many bytes were actually transferred.

00:43:12.000 --> 00:43:16.540
So there are four new calls for
these load latency transfers.

00:43:16.540 --> 00:43:24.350
The first two are just
for user-lent drivers,

00:43:25.170 --> 00:43:33.010
and the last two are the read and write
APIs for both user and kernel drivers.

00:43:33.270 --> 00:43:39.800
We thought it was a good idea to have
the IOUSB library manage your buffers.

00:43:39.810 --> 00:43:44.110
So you have, as a client in user space,
you have to call in and

00:43:44.110 --> 00:43:47.340
give us the information for
how big to make the buffer,

00:43:47.400 --> 00:43:48.100
essentially.

00:43:48.100 --> 00:43:53.100
You don't have to have just one
whole buffer for your whole data.

00:43:53.100 --> 00:43:56.100
You can have multiple buffers
for each transfer if you want.

00:43:56.100 --> 00:43:59.030
You can manage that yourself.

00:43:59.250 --> 00:44:02.310
However,
when you do finish the transfers,

00:44:02.380 --> 00:44:06.980
you need to call us back so we can
release our buffers and we can inform

00:44:06.980 --> 00:44:12.900
the kernel entities that those memory
descriptors are no longer being used.

00:44:14.370 --> 00:44:22.230
Again, a typical API for the low
latency read ISOC is as follows.

00:44:22.590 --> 00:44:27.770
You can see in the highlight
there that there are two changes.

00:44:28.200 --> 00:44:33.600
One is we have added this
update frequency parameter.

00:44:33.690 --> 00:44:39.190
That tells us how often you want your

00:44:39.490 --> 00:44:46.640
If you wanted to be updated,
of course the granularity

00:44:46.640 --> 00:44:48.280
is one millisecond.

00:44:48.280 --> 00:44:50.640
If you wanted it to be
updated every millisecond,

00:44:50.640 --> 00:44:52.380
you would pass in a one.

00:44:52.400 --> 00:44:54.900
If you wanted it every
eight milliseconds,

00:44:54.900 --> 00:44:56.550
you would pass in an eight.

00:44:56.600 --> 00:45:05.080
If you have a 64 frame transfer,
and you're only going to be looking

00:45:05.080 --> 00:45:09.800
at it from user space or from kernel
space every eight milliseconds,

00:45:09.940 --> 00:45:13.920
you should really pass
an eight and not a one.

00:45:13.920 --> 00:45:16.840
Because, again,
we're taking processing time

00:45:16.840 --> 00:45:20.280
at filter interrupt time,
and that is preventing any

00:45:20.430 --> 00:45:24.290
other threads from running on
that processor at that time.

00:45:25.330 --> 00:45:32.790
The low latency ISOC frame list now has,
as I mentioned earlier,

00:45:32.790 --> 00:45:38.700
an absolute time parameter
that is timestamp at the time

00:45:38.700 --> 00:45:44.740
that we process the data,
that we updated your number

00:45:44.740 --> 00:45:46.020
of bytes transferred.

00:45:46.020 --> 00:45:49.460
If we are updating more
than one frame at that time,

00:45:49.470 --> 00:45:53.350
all those frames are going
to have the same timestamp.

00:45:54.020 --> 00:45:59.320
This is used by the audio drivers,
for example, to synchronize all their

00:45:59.320 --> 00:46:01.380
stuff and do their magic.

00:46:01.410 --> 00:46:08.330
These APIs are detailed on HeaderDoc.

00:46:08.420 --> 00:46:13.820
If you have any questions,
feel free to ask them on the USB list,

00:46:13.980 --> 00:46:17.280
and we'll answer them as soon as we can.

00:46:17.280 --> 00:46:23.540
And again,
don't abuse the low latency APIs.

00:46:24.000 --> 00:46:25.250
I can't stress that.

00:46:25.340 --> 00:46:31.820
We got some pushback from the kernel
guys when we were adding these APIs,

00:46:31.820 --> 00:46:35.420
because they don't want anything
to happen at filter interrupt time.

00:46:35.420 --> 00:46:39.980
And if you abuse it,
then performance for the whole

00:46:40.080 --> 00:46:42.640
system is going to go down.

00:46:46.400 --> 00:46:50.340
Just a quick note on the
USB Implementers Forum.

00:46:50.340 --> 00:46:55.010
One of the big things going on right
now is that a video device class

00:46:55.120 --> 00:46:57.280
specification is nearing release.

00:46:57.290 --> 00:47:04.270
In fact, I think this week it's going
to the 30-day comment period,

00:47:04.290 --> 00:47:10.220
at the end of which it will become a
1.0 specification and will be released.

00:47:10.240 --> 00:47:15.430
You should go to the
Implementers website.

00:47:15.430 --> 00:47:20.580
It's public for now,
and take a look at it.

00:47:22.460 --> 00:47:29.880
It provides support for a
wide range of video devices,

00:47:29.900 --> 00:47:33.410
everything that, you know,
video related that you can think of.

00:47:33.520 --> 00:47:36.990
All sorts of different payloads.

00:47:37.820 --> 00:47:44.680
We plan to provide a class
driver for some of those devices.

00:47:44.710 --> 00:47:47.460
I am the one working on it.

00:47:49.210 --> 00:47:53.860
The specification, as I mentioned,
is all-encompassing.

00:47:53.860 --> 00:47:59.570
It does not specify whether you need
to be a high-speed device or not.

00:47:59.600 --> 00:48:02.950
Of course,
for some of the payload formats, like DV,

00:48:02.950 --> 00:48:04.310
it does not make sense.

00:48:04.320 --> 00:48:07.580
It cannot work on a full-speed device.

00:48:09.740 --> 00:48:14.110
Some chipsets right now
only do bulk transfers,

00:48:14.110 --> 00:48:19.570
and there is support for
just bulk transfer for video.

00:48:19.780 --> 00:48:25.380
Of course,
you have the pros and cons about that.

00:48:25.600 --> 00:48:28.520
There's still image support.

00:48:28.620 --> 00:48:31.850
It's not limited to
receiving video on the host.

00:48:31.950 --> 00:48:38.110
It also has support for
sending video out to a device.

00:48:38.260 --> 00:48:46.680
There's plenty of manufacturers
on the working group that are

00:48:46.760 --> 00:48:50.740
Gearing up to produce these devices,
so there's something exciting that

00:48:50.930 --> 00:48:53.290
we're going to see in the near future.

00:48:54.160 --> 00:48:59.440
Another change from the implementers
forum is that they've now defined an

00:48:59.560 --> 00:49:05.190
interface association descriptor as
a change notice to the USB 2.0 spec.

00:49:05.270 --> 00:49:11.580
And all this does is allows classes like
the audio class and the video class,

00:49:11.650 --> 00:49:14.600
for which this descriptor
is now mandatory,

00:49:14.630 --> 00:49:18.070
to relate different
interfaces to each other.

00:49:18.200 --> 00:49:22.890
So that the system will know
that when you change something

00:49:22.890 --> 00:49:27.720
on the control interface,
it also needs something to

00:49:27.720 --> 00:49:31.200
happen to a streaming interface.

00:49:31.370 --> 00:49:37.250
We are looking at the ramifications
of this and expect to support

00:49:37.410 --> 00:49:40.200
this descriptor in the future.

00:49:42.510 --> 00:49:45.720
A quick debugging tools update.

00:49:45.800 --> 00:49:51.720
This year we gave up on giving a
demo on tool machine debugging.

00:49:51.720 --> 00:49:53.320
It didn't work for the last two years.

00:49:53.320 --> 00:49:57.300
We decided, you know,
we'll save face this time.

00:49:57.460 --> 00:50:04.800
We do provide login versions of
the IOUSBFamily on the website,

00:50:05.320 --> 00:50:09.490
on our website in developer.apple.com.

00:50:09.830 --> 00:50:14.580
The latest versions actually
I produced so that you can install

00:50:14.660 --> 00:50:18.880
as a package the shipping version
as well as the login version so that

00:50:18.880 --> 00:50:24.800
you don't have to save the other
one aside and copy it over later.

00:50:24.800 --> 00:50:29.030
A quick caveat,
if you do try to download the sources

00:50:29.030 --> 00:50:33.650
and build your own IOUSBFamily,
do not try to boot with an

00:50:33.750 --> 00:50:36.800
unstripped version of the USBFamily.

00:50:38.140 --> 00:50:43.420
And actually when you use
Project Builder and build the project

00:50:43.940 --> 00:50:53.140
using the development build style,
it will not strip the binary and

00:50:53.140 --> 00:50:57.800
you will get an unhappy Mac or
whatever the equivalent is now.

00:50:58.010 --> 00:51:01.800
And you won't boot and you'll
need another partition to boot it.

00:51:01.940 --> 00:51:04.800
Caveat emptor.

00:51:05.800 --> 00:51:06.800
So, this is the new tools.

00:51:06.800 --> 00:51:08.800
It seems to change with every
release of Project Builder.

00:51:08.800 --> 00:51:12.720
This is for the December 2002
developer tools.

00:51:12.930 --> 00:51:16.800
This is a line that you use to
produce an unstripped version.

00:51:16.800 --> 00:51:17.730
It's simpler now.

00:51:17.800 --> 00:51:24.800
I have no idea what it is or if this
will work with Xcode or... but...

00:51:25.580 --> 00:51:28.000
For the December tools, use this.

00:51:28.020 --> 00:51:31.850
Of course, if you're going to do
machine to machine debugging,

00:51:31.850 --> 00:51:37.240
you have to change your default boot
arguments to what's on the screen so

00:51:37.260 --> 00:51:39.290
that you can actually connect to it.

00:51:39.450 --> 00:51:44.120
If you don't, you'll just get the
multilingual panic message.

00:51:44.480 --> 00:51:50.200
Finally, actually in solving some bugs,
I was able to use the CHOD tools,

00:51:50.200 --> 00:51:55.300
which stands for Computer Hardware
Understanding Developer Tools.

00:51:55.300 --> 00:52:02.060
There is actually a session tomorrow,
and it was very handy,

00:52:02.060 --> 00:52:05.870
and actually you wouldn't
think that get bus frame number

00:52:05.870 --> 00:52:07.710
could lock out your machine.

00:52:09.590 --> 00:52:13.890
Just a tiny bit of administrivia.

00:52:13.990 --> 00:52:17.370
The repository,
as most of you who accessed

00:52:17.370 --> 00:52:21.290
it before now know,
is not live anymore.

00:52:21.460 --> 00:52:24.040
However, we are still open source.

00:52:24.070 --> 00:52:28.190
Once Panther is released,
we are going to release the

00:52:28.190 --> 00:52:32.280
EHCI driver for the EHCI controller.

00:52:32.580 --> 00:52:36.340
You've noticed that things,
releases are better now,

00:52:36.340 --> 00:52:38.880
and very soon after
an update is released,

00:52:38.960 --> 00:52:42.400
the tarballs with all the
sources are released on the web,

00:52:42.590 --> 00:52:48.160
so I still encourage you to
go and build it if you need to

00:52:48.160 --> 00:52:52.400
build a family to debug things.

00:52:53.660 --> 00:52:59.220
So this is just a brief summary
of the APIs that we've changed.

00:52:59.540 --> 00:53:06.570
Again, if you have any suggestions for
new APIs that would make your life

00:53:06.570 --> 00:53:10.600
easier for some reason or another,
we're always on the list.

00:53:10.700 --> 00:53:11.720
You know who we are.

00:53:11.720 --> 00:53:15.060
Just send us some email,
and the only way we're going to

00:53:15.060 --> 00:53:17.670
consider them is if we know about them.

00:53:17.730 --> 00:53:20.730
So feel free to suggest that.

00:53:21.580 --> 00:53:24.650
We're looking forward
to the video class spec,

00:53:24.660 --> 00:53:29.730
and the repository is not live anymore,
but we are, and we're still working,

00:53:29.730 --> 00:53:32.100
and we're enjoying ourselves.

00:53:34.860 --> 00:53:39.390
These references are pretty
much unchanged from last year,

00:53:39.390 --> 00:53:43.690
even though some of the
documents have been updated.

00:53:43.690 --> 00:53:47.700
It's the usual suspects.

00:53:47.830 --> 00:53:51.120
There are technical notes
on debugging kernel panics,

00:53:51.190 --> 00:53:55.670
if you feel like doing
that for some reason.

00:53:55.790 --> 00:54:01.660
We still get for persons just coming
to develop on "my driver doesn't

00:54:01.660 --> 00:54:07.590
load." I have that bookmark and
always fire it out on the list.

00:54:08.000 --> 00:54:15.400
Again, some sessions that you
might want to attend.

00:54:15.400 --> 00:54:22.360
Just use your time transport and
go to Godfrey's session yesterday.

00:54:23.480 --> 00:54:28.400
As an aside, of course,
this is for the DVD, blah, blah, blah.

00:54:28.400 --> 00:54:31.380
There's, as I mentioned,
the shot performance

00:54:31.450 --> 00:54:35.390
optimization session tomorrow.

00:54:35.400 --> 00:54:38.030
Of course,
we are expecting you guys to come to

00:54:38.030 --> 00:54:45.600
the feedback forum tomorrow as well,
and give us, you know, let us have it.

00:54:46.090 --> 00:54:50.090
Finally on Friday,
we have a session on the Hit Manager and

00:54:50.090 --> 00:54:52.000
our forest feedback support.

00:54:52.000 --> 00:54:57.020
So if you want to listen to me again,
bookmark your Friday morning session.

00:54:58.920 --> 00:55:04.380
and you know our email addresses.

00:55:04.380 --> 00:55:09.580
Again, the USB list at list.apple.com.

00:55:10.140 --> 00:55:13.800
I also monitored one or
several of the Dartwin lists,

00:55:13.900 --> 00:55:18.930
and the first thing I say when
somebody posts a USB question there is,

00:55:18.930 --> 00:55:22.570
go ahead and join the USB list,
and your question will be

00:55:22.660 --> 00:55:24.970
answered faster that way.
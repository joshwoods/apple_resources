WEBVTT

00:00:23.960 --> 00:00:29.460
Thank you all for joining us today at the
Cocoa User Interface Programming session.

00:00:29.460 --> 00:00:31.550
4.12.

00:00:31.550 --> 00:00:35.900
One quick note, there's another session
coming up later on Friday,

00:00:35.900 --> 00:00:38.220
which is an in-depth
version of this 4.19.

00:00:38.220 --> 00:00:40.280
It's not on your schedule.

00:00:40.280 --> 00:00:43.850
After seeing this,
you will want to go to 4.19.

00:00:44.030 --> 00:00:46.570
Consider this a requirement.

00:00:46.570 --> 00:00:50.600
If you don't sit through this,
you can't sit through

00:00:52.070 --> 00:00:54.740
Thank you, I appreciate that.

00:00:54.790 --> 00:00:57.500
Today we're going to talk about
some of the coolest additions to

00:00:57.500 --> 00:01:00.760
building Cocoa applications out there.

00:01:00.760 --> 00:01:03.990
And to take us through it,
Andreas Wendker.

00:01:09.730 --> 00:01:10.540
Good afternoon.

00:01:10.540 --> 00:01:19.290
So my name is Andreas Wendker
and I manage the Web Objects

00:01:19.290 --> 00:01:20.220
Engineering team.

00:01:20.220 --> 00:01:22.640
And if you now wonder what
exactly I'm doing here and whether

00:01:22.640 --> 00:01:24.480
you're in the right session,
then don't run away,

00:01:24.480 --> 00:01:26.840
this really is a Cocoa session.

00:01:29.990 --> 00:01:33.130
Cocoa already is the best and the
fastest way to develop desktop

00:01:33.130 --> 00:01:34.620
applications for Mac OS X.

00:01:34.770 --> 00:01:37.480
And as you saw in the
introductory sessions on Monday,

00:01:37.480 --> 00:01:39.620
we will make it even better.

00:01:41.020 --> 00:01:43.610
To take a look at the existing
Cocoa applications out there,

00:01:43.700 --> 00:01:46.670
you will find that there's actually
a lot of code being written simply

00:01:46.770 --> 00:01:49.880
to keep the user interface in sync
with the underlying data objects.

00:01:49.880 --> 00:01:54.370
What you have to do is you have to pretty
much write a lot of repetitive glue code.

00:01:54.400 --> 00:01:56.640
You have to add a lot of
outlets to your Nib files,

00:01:56.640 --> 00:01:59.840
you have to set targets and delegates,
and you have to implement

00:01:59.910 --> 00:02:02.960
a lot of methods simply to
react to user interface input.

00:02:02.960 --> 00:02:05.640
That is very straightforward
and routine work,

00:02:05.650 --> 00:02:09.450
but it also takes a lot of time,
and frankly, it's really boring.

00:02:12.060 --> 00:02:13.760
So we decided to do something about that.

00:02:13.780 --> 00:02:15.440
And at Panther,
we are going to introduce a

00:02:15.510 --> 00:02:18.580
completely new layer of functionality,
a controller layer.

00:02:18.610 --> 00:02:22.760
This controller layer will automate
the handling of your user interface

00:02:22.970 --> 00:02:26.360
and it will add a lot of features
that you've been asking for.

00:02:26.380 --> 00:02:28.300
And of course,
we extended interface builder so

00:02:28.300 --> 00:02:31.780
that you can make use of these
new features without writing code.

00:02:31.800 --> 00:02:34.910
And the effect will really be that
developing Cocoa applications will

00:02:34.910 --> 00:02:37.720
become a lot faster and a lot easier.

00:02:42.660 --> 00:02:45.380
This is a screenshot of FineWord,
our code-diffing tool,

00:02:45.380 --> 00:02:48.640
and I put it here to give you an
impression of what impact this technology

00:02:48.640 --> 00:02:50.320
will have on your own applications.

00:02:50.330 --> 00:02:54.340
If you imagine your current
Cocoa applications on the left side

00:02:54.400 --> 00:02:57.530
of the picture and the way you would
be able to write that same application

00:02:57.670 --> 00:03:00.550
in Panther on the right side,
then as you can see in the bottom there,

00:03:00.620 --> 00:03:01.650
there will be only one difference.

00:03:01.870 --> 00:03:04.800
Your code, your glue code will be gone.

00:03:10.010 --> 00:03:11.920
So the next hour, I'll give you,
first of all,

00:03:11.920 --> 00:03:13.820
an overview of how the new API works.

00:03:14.060 --> 00:03:16.460
And I will show you that the
concepts of this new technology

00:03:16.860 --> 00:03:19.520
are based upon the very known
model view controller paradigm,

00:03:19.520 --> 00:03:21.960
which I believe most of
you are familiar with.

00:03:22.040 --> 00:03:24.370
And we'll also show you how
you can use Interface Builder

00:03:24.470 --> 00:03:25.550
to use the new features.

00:03:25.560 --> 00:03:27.310
And throughout this session,
I will get a lot of

00:03:27.430 --> 00:03:29.840
help from my colleague,
James Dempsey.

00:03:29.840 --> 00:03:31.930
And he's not only going to
drive the demos for you,

00:03:32.040 --> 00:03:35.190
he also brought his guitar.

00:03:35.810 --> 00:03:38.070
So if you attended WebObject
sessions in the past years,

00:03:38.190 --> 00:03:39.400
you know this will be good.

00:03:39.400 --> 00:03:42.510
And if not, stay a few minutes
after my summary slide.

00:03:43.490 --> 00:03:47.070
And I can say this often enough,
session number 419 will be a

00:03:47.180 --> 00:03:48.400
follow-up session to this one.

00:03:48.400 --> 00:03:51.140
There's simply so much to talk about
in the context of the controller layer

00:03:51.430 --> 00:03:52.840
that we felt we need a second session.

00:03:52.840 --> 00:03:56.110
So 419, Friday morning at 9 o'clock.

00:03:56.190 --> 00:03:58.600
So with that,
let me bring up James for a first demo.

00:03:58.620 --> 00:04:02.360
And he will give you a first
demo of how you can use interface

00:04:02.460 --> 00:04:04.320
better with the new features.

00:04:07.110 --> 00:04:09.390
Good afternoon,
my name is James Dempsey and

00:04:09.390 --> 00:04:13.200
I write in-house Cocoa and
WebObjects applications for Apple.

00:04:13.200 --> 00:04:17.520
And what I'm going to show you today is
some of the new features in Interface

00:04:17.520 --> 00:04:22.690
Builder that allow you to access the
new controller layer features in Cocoa.

00:04:22.720 --> 00:04:26.480
So, let's make a new nib file,
new Cocoa application.

00:04:26.520 --> 00:04:28.420
Don't need that menu.

00:04:28.420 --> 00:04:33.020
And so let's start out by dragging out
a good old-fashioned checkbox here.

00:04:33.300 --> 00:04:35.800
And we're going to use it
to hide or show something,

00:04:35.810 --> 00:04:37.610
so I'll label it appropriately.

00:04:37.620 --> 00:04:41.610
The first thing you'll notice in
Interface Builder is that we have our

00:04:42.170 --> 00:04:46.180
familiar attributes and connections,
attribute, or excuse me, inspectors,

00:04:46.290 --> 00:04:49.240
but we also have the addition
of this new bindings inspector.

00:04:49.240 --> 00:04:53.870
And the bindings inspector shows
all of the attributes that the

00:04:53.870 --> 00:04:58.290
selected view item are exposed or
have exposed to the controller layer.

00:04:58.300 --> 00:05:01.120
So they're all things we can
configure with this controller layer.

00:05:01.120 --> 00:05:03.280
You'll notice they're
all grouped by category.

00:05:03.300 --> 00:05:05.880
So their availability,
whether it's enabled or hidden,

00:05:06.010 --> 00:05:08.830
all different items
about the font display,

00:05:08.860 --> 00:05:10.300
and of course the value.

00:05:10.300 --> 00:05:12.320
So we've got this little rollover.

00:05:12.320 --> 00:05:16.320
We click that and we can configure
everything about this binding.

00:05:16.320 --> 00:05:21.040
Now, every application has a shared
user defaults controller,

00:05:21.040 --> 00:05:23.510
and user defaults have values.

00:05:23.540 --> 00:05:27.220
And within there,
we're going to define an arbitrary key.

00:05:27.220 --> 00:05:29.880
We're going to call it flag,
ever popular.

00:05:31.650 --> 00:05:37.410
And we have just configured that
checkbox to now stuff its value into

00:05:37.410 --> 00:05:41.140
shared user defaults under the key flag.

00:05:41.190 --> 00:05:43.230
Now let's have something
that actually reacts to that.

00:05:43.260 --> 00:05:46.710
We'll drag out a text view,
which of course is enclosed

00:05:46.710 --> 00:05:51.440
in an NSScroll view,
which has one available binding hidden.

00:05:51.550 --> 00:05:55.440
We'll hook that up to the same
shared user defaults values.

00:05:55.490 --> 00:05:58.240
And Interface Builder
remembers we defined a key,

00:05:58.240 --> 00:06:00.360
so we can just pick it from the list.

00:06:00.360 --> 00:06:04.500
And I head into test interface mode,
and of course when I click the checkbox,

00:06:04.750 --> 00:06:07.300
away goes my text view.

00:06:11.450 --> 00:06:14.080
And so as opposed to just
having attributes that are

00:06:14.110 --> 00:06:17.510
set-able in Interface Builder,
we now have attributes that are dynamic

00:06:17.600 --> 00:06:21.480
and propagate through the UI on the fly.

00:06:21.550 --> 00:06:27.360
Now, no IB demo would be complete
without a scroll thing in it,

00:06:27.360 --> 00:06:28.410
of course.

00:06:28.510 --> 00:06:32.210
So let's hit its value.

00:06:32.220 --> 00:06:35.940
It's going to go into
user defaults of values.

00:06:35.980 --> 00:06:39.170
And we're going to have
it set some font size.

00:06:39.410 --> 00:06:42.610
And let's head on over to
the Attributes Inspector.

00:06:42.890 --> 00:06:45.180
The two are not mutually exclusive.

00:06:45.180 --> 00:06:47.750
You can use both in
conjunction with each other.

00:06:47.750 --> 00:06:49.850
And zero is not a very
reasonable font size,

00:06:49.850 --> 00:06:50.970
so we'll change that.

00:06:51.050 --> 00:06:55.040
24 for the...

00:06:55.330 --> 00:06:57.500
Sure, 25, great font size.

00:06:57.530 --> 00:07:00.770
All right, let's head on over,
type some text into our text view.

00:07:00.790 --> 00:07:05.300
2003, yeah, whatever.

00:07:05.390 --> 00:07:08.180
And multiple fonts allowed,
so we have one font.

00:07:08.680 --> 00:07:12.500
Go to bindings and set the font size up,
shared user defaults,

00:07:12.500 --> 00:07:14.600
going to pull from those values.

00:07:14.780 --> 00:07:17.100
Again, that font size.

00:07:17.130 --> 00:07:22.170
Go into test interface mode and voila,
I move the slider and something

00:07:22.470 --> 00:07:23.390
happens in the user interface.

00:07:27.500 --> 00:07:31.190
You've seen that before,
but in the past you've left

00:07:31.680 --> 00:07:35.000
test interface mode and
everything you did went away.

00:07:35.160 --> 00:07:38.310
But when you're binding
up to a controller object,

00:07:38.310 --> 00:07:41.200
this one's a shared user
defaults controller object,

00:07:41.320 --> 00:07:45.410
behind the scenes is the actual
NS user defaults object that is

00:07:45.580 --> 00:07:47.700
pushing things into the database.

00:07:47.810 --> 00:07:52.990
So when I rerun, I persist.

00:07:57.990 --> 00:08:01.130
So that kind of gives you an idea
of how little code your preferences

00:08:01.270 --> 00:08:03.140
panels might need in the future.

00:08:03.140 --> 00:08:05.140
Now back to Andreas.

00:08:05.140 --> 00:08:06.140
Thank you, James.

00:08:07.140 --> 00:08:07.140
Hi, everyone.

00:08:07.140 --> 00:08:08.140
I'm Andreas Wendker,
and I'm the executive director of Cocoa.

00:08:14.290 --> 00:08:16.620
So how did we come up
with this technology?

00:08:16.620 --> 00:08:19.700
Some of you might know that we
currently have a technology called EOF,

00:08:19.710 --> 00:08:23.160
or Enterprise Objects Framework,
which is part of the WebObjects product,

00:08:23.160 --> 00:08:25.140
and it's used for database access.

00:08:25.270 --> 00:08:27.910
And EOF has a layer that we
call the interface layer,

00:08:27.990 --> 00:08:31.160
and it's used to automatically
populate Java swing applications

00:08:31.590 --> 00:08:34.070
with content from databases.

00:08:34.140 --> 00:08:37.100
So what we have done is we have taken
the ideas and concepts of that layer

00:08:37.100 --> 00:08:40.050
and all the lessons we learned from it,
and we've implemented the next

00:08:40.050 --> 00:08:43.700
generation of this technology
in Objective-C for Cocoa.

00:08:48.410 --> 00:08:51.680
So when we set out, when we started,
we set the following goals for us.

00:08:51.680 --> 00:08:54.240
First of all,
we wanted to support a large variety

00:08:54.240 --> 00:08:55.650
of use cases and applications.

00:08:55.650 --> 00:08:58.240
We certainly didn't want this
to be limited to databases.

00:08:58.240 --> 00:09:00.230
We wanted it to be useful
for preferences panels,

00:09:00.230 --> 00:09:02.990
for applications like Mail, AdWords Book,
and all the applications

00:09:03.000 --> 00:09:04.040
you're familiar with.

00:09:04.820 --> 00:09:07.750
We wanted it to integrate easily
into existing applications so

00:09:07.750 --> 00:09:10.450
that you don't have to rewrite
your applications completely,

00:09:10.450 --> 00:09:12.090
just if you want to make
use of our features.

00:09:12.120 --> 00:09:14.740
And we wanted it to be flexible
and extensible so that you could

00:09:14.820 --> 00:09:16.050
get good mileage out of it.

00:09:16.080 --> 00:09:17.680
We wanted it to be fast,
and we wanted it to have

00:09:17.680 --> 00:09:20.250
great interface integration,
and we wanted it to be easy to learn.

00:09:20.250 --> 00:09:22.940
Or in other words,
we wanted it to kick ass.

00:09:27.180 --> 00:09:29.290
So I hope that at the end of the session
you'll actually agree with me that

00:09:29.290 --> 00:09:31.560
we achieved what we set out to do.

00:09:31.560 --> 00:09:35.880
So let me now give you an overview,
if I get this right.

00:09:35.880 --> 00:09:38.180
Let me actually first recap quickly
what the Model-View-Controller

00:09:38.290 --> 00:09:40.150
paradigm is about.

00:09:40.510 --> 00:09:43.380
With the Model-View-Controller paradigm,
you essentially split your

00:09:43.480 --> 00:09:45.590
application in three parts:
The model,

00:09:45.590 --> 00:09:49.760
which represents your data objects
and the underlying logic and rules.

00:09:49.830 --> 00:09:53.280
And the view, which handles the input and
the output of your application,

00:09:53.330 --> 00:09:55.200
so it consists of all the
windows and views you typically

00:09:55.200 --> 00:09:57.260
assemble in an interface builder.

00:09:57.350 --> 00:10:00.260
And the controller,
which glues these two pieces together.

00:10:00.400 --> 00:10:03.430
The controller is the glue
between the model and the view.

00:10:03.820 --> 00:10:06.460
And for the purpose of this session,
we'll keep the interaction and the

00:10:06.460 --> 00:10:10.340
roles and the responsibilities of
these three pieces fairly simple.

00:10:10.530 --> 00:10:13.410
All I want you to keep in mind
is that when the user enters a

00:10:13.410 --> 00:10:15.980
new value in the user interface,

00:10:17.320 --> 00:10:20.420
The view will notify the controller
that a change has happened,

00:10:20.420 --> 00:10:25.320
and the controller will then apply that
change to the appropriate model objects.

00:10:25.870 --> 00:10:28.920
But not all the changes in an
application happen in the user interface.

00:10:29.000 --> 00:10:32.040
Sometimes you have the script
running in the background,

00:10:32.040 --> 00:10:33.980
or you might have different
views for the same model.

00:10:33.980 --> 00:10:36.620
So you might have multiple windows
open that show the same data.

00:10:36.720 --> 00:10:38.970
And because of that,
controllers also listen for

00:10:39.040 --> 00:10:40.650
changes from the model objects.

00:10:40.730 --> 00:10:43.580
They will observe the model objects,
and if they are told that

00:10:43.580 --> 00:10:46.980
the model has changed,
they will automatically update the view.

00:10:47.800 --> 00:10:50.870
So what are the advantages of the
Model-View-Controller paradigm?

00:10:50.920 --> 00:10:52.570
Essentially,
the Model-View-Controller paradigm

00:10:52.910 --> 00:10:57.030
makes your applications code more
reusable and easier to extend.

00:10:57.130 --> 00:11:00.050
For example,
since the model isn't really concerned

00:11:00.050 --> 00:11:02.940
with the details of the view,
it's fairly easy for you to add an

00:11:02.940 --> 00:11:06.660
additional window of a different type of
user interface that shows the same data.

00:11:06.660 --> 00:11:10.610
You might even be able to use the same
model objects in different applications.

00:11:10.730 --> 00:11:12.160
And also,
since the view isn't really concerned

00:11:12.160 --> 00:11:14.940
with the details of the model object,
you can easily switch

00:11:14.940 --> 00:11:16.530
the data representation.

00:11:16.580 --> 00:11:18.300
For example,
you can easily change the class

00:11:18.300 --> 00:11:20.840
that you use to represent your
data objects without impacting

00:11:20.840 --> 00:11:21.960
the code written for the view.

00:11:25.410 --> 00:11:28.620
So in the past,
you had to write the controller by hand.

00:11:28.630 --> 00:11:32.030
The glue code that I talked about in
the beginning pretty much formed the

00:11:32.030 --> 00:11:34.100
controller layer of your applications.

00:11:34.120 --> 00:11:36.710
Going forward in Panther,
we will provide you with a

00:11:36.710 --> 00:11:41.390
reusable component with a reusable
controller layer out of the box.

00:11:43.250 --> 00:11:46.100
I would like now to give you just
an overview of the most important

00:11:46.130 --> 00:11:48.470
features of our controller layer.

00:11:48.530 --> 00:11:51.630
Let's start with using any model object.

00:11:51.780 --> 00:11:54.750
You can apply the new functionality
of our controller layer to

00:11:54.750 --> 00:11:56.700
pretty much any problem domain.

00:11:56.780 --> 00:11:59.530
Whether you want to display NS documents,
whether you want to work on

00:11:59.540 --> 00:12:02.820
preferences panels and store
preference in the user defaults,

00:12:02.870 --> 00:12:05.980
whether you use NSDictionary's as
generic data containers,

00:12:06.040 --> 00:12:08.000
or whether you use your
own custom model objects,

00:12:08.030 --> 00:12:11.770
you will be able to apply our
controller layer to all these models.

00:12:11.840 --> 00:12:15.210
And we achieved that by using
a common data access protocol

00:12:15.290 --> 00:12:17.560
that we call key value coding.

00:12:18.210 --> 00:12:21.470
Key-value coding is actually already
part of Mac OS X for quite a while now,

00:12:21.620 --> 00:12:24.600
but it has only been used
in the context of scripting.

00:12:24.600 --> 00:12:27.060
So unless you have made
your application scriptable,

00:12:27.130 --> 00:12:29.260
you're probably not familiar with it.

00:12:29.410 --> 00:12:33.180
Key-value coding is a unified
way to access properties

00:12:33.260 --> 00:12:37.500
of model objects by name,
or as we refer to it, by key.

00:12:37.600 --> 00:12:40.200
And we talk a lot more about
this in session number 419.

00:12:40.200 --> 00:12:43.110
It's really essential to
understand this protocol.

00:12:45.030 --> 00:12:47.640
The second feature,
Automatic User Interface Refresh.

00:12:47.640 --> 00:12:51.060
Our controller layer will make sure,
as the Model View Controller paradigm

00:12:51.060 --> 00:12:53.060
promises,
that different parts of the user

00:12:53.060 --> 00:12:55.000
interface will always stay in sync.

00:12:55.000 --> 00:12:57.980
So if you have documents with multiple
windows for the same document to open,

00:12:57.990 --> 00:13:01.650
you will not have to write any line
of code to keep the content of those

00:13:01.800 --> 00:13:04.000
windows in sync with the data objects.

00:13:04.000 --> 00:13:08.000
And we achieved that by using
a common observing protocol,

00:13:08.070 --> 00:13:10.340
which we call Key Value Observing.

00:13:10.700 --> 00:13:13.090
So key-value observing
allows interested objects,

00:13:13.150 --> 00:13:16.190
our controllers,
to register for change notifications

00:13:16.400 --> 00:13:17.480
from the model objects.

00:13:17.530 --> 00:13:19.600
And when they are told
that something has changed,

00:13:19.690 --> 00:13:21.730
they will use that information to
propagate the change throughout

00:13:21.770 --> 00:13:23.100
your complete application.

00:13:23.170 --> 00:13:27.040
So they will always keep all the views
that display the same data in sync.

00:13:27.120 --> 00:13:30.500
And that will happen independent
of how the change was triggered.

00:13:30.540 --> 00:13:32.900
So independent of whether the
user entered something in the

00:13:32.900 --> 00:13:36.570
user interface or whether a script
was running in the background.

00:13:36.660 --> 00:13:39.540
And if you don't use multiple
windows for the same document,

00:13:39.540 --> 00:13:42.170
another area where this
will be very visible will be

00:13:42.170 --> 00:13:43.500
in the preferences panels.

00:13:43.580 --> 00:13:46.480
With our controller layer,
changes in the preferences

00:13:46.480 --> 00:13:49.700
panel will apply immediately
to the complete application.

00:13:52.670 --> 00:13:55.000
Displaying and editing all
standard Cocoa data types.

00:13:55.050 --> 00:13:57.620
So we really went for the full
breadth of functionality in Cocoa,

00:13:57.620 --> 00:14:02.020
whether you deal with strings, numbers,
dates, colors, images, fonts, paths,

00:14:02.020 --> 00:14:02.410
URLs.

00:14:02.500 --> 00:14:04.510
Whether you want to
display in a text field,

00:14:04.510 --> 00:14:07.080
in a slide, in an image view,
we pretty much have bindings

00:14:07.080 --> 00:14:09.840
available for all Cocoa widgets.

00:14:09.980 --> 00:14:13.210
and we have excellent support for
table views to display object arrays.

00:14:13.370 --> 00:14:16.110
The one thing that we'll probably
not get to in the Panther timeframe

00:14:16.200 --> 00:14:17.370
is support for tree views.

00:14:17.370 --> 00:14:20.060
So, and its outline views in its
browser support for those,

00:14:20.060 --> 00:14:22.370
we'll probably have to
wait for the next release.

00:14:25.310 --> 00:14:27.840
Speaking about table views,
our controller layer will

00:14:27.840 --> 00:14:29.090
manage selections for you.

00:14:29.160 --> 00:14:32.560
It will track which rows the
user selected in the table views.

00:14:32.560 --> 00:14:34.300
And again,
it will synchronize the content of

00:14:34.310 --> 00:14:35.810
other widgets with that selection.

00:14:35.810 --> 00:14:39.290
So if you have text fields
or other widgets that are

00:14:39.290 --> 00:14:43.620
dependent on the selected row,
that show the values of the selected row,

00:14:43.620 --> 00:14:46.510
you will make sure that those
widgets stay in sync with the

00:14:46.510 --> 00:14:48.190
selection in the table views.

00:14:48.240 --> 00:14:51.520
And of course,
we will allow or we will handle editing

00:14:51.610 --> 00:14:53.940
of multiple objects the right way.

00:14:53.940 --> 00:14:56.360
This is something that actually
requires a lot of code to get right,

00:14:56.380 --> 00:14:58.730
but we felt that it makes applications
really more user friendly,

00:14:58.850 --> 00:15:00.590
so we put it right in
the controller layer.

00:15:03.350 --> 00:15:06.180
So the features I listed so far are
pretty much the essential features you

00:15:06.180 --> 00:15:07.780
would expect from any controller layer.

00:15:07.890 --> 00:15:09.320
But we wanted to go further.

00:15:09.600 --> 00:15:13.390
We wanted to make sure that our features
really helped you create polished,

00:15:13.420 --> 00:15:14.880
great applications.

00:15:14.940 --> 00:15:18.400
And one area that we found where we
could help you greatly is when it comes

00:15:18.400 --> 00:15:21.960
to handling all these different states
you encounter in user interfaces.

00:15:22.010 --> 00:15:25.480
So the states we will handle for you,
first of all, the value state,

00:15:25.520 --> 00:15:30.290
which pretty much means that a value has
not been specified in the model so far.

00:15:30.460 --> 00:15:32.580
We also handle multiple selections.

00:15:32.610 --> 00:15:34.600
We handle the state of no selection.

00:15:34.620 --> 00:15:36.600
And we even came up with
the not applicable state,

00:15:36.610 --> 00:15:39.740
which is intended to be used
if you display different kind

00:15:39.740 --> 00:15:41.080
of objects in a table view.

00:15:41.100 --> 00:15:43.570
In those cases,
not all table columns might apply

00:15:43.630 --> 00:15:44.940
to all the objects you display.

00:15:45.180 --> 00:15:46.780
So you don't want the application
to crash in that case.

00:15:47.040 --> 00:15:48.260
You want it to be handled cleanly.

00:15:48.400 --> 00:15:50.140
So we will do that for you.

00:15:50.800 --> 00:15:55.080
What will happen is that when views
query the controller and they ask

00:15:55.080 --> 00:15:58.140
for the values to be displayed,
our controllers will indicate those

00:15:58.140 --> 00:16:00.210
states through special object values.

00:16:00.220 --> 00:16:01.900
We call those object values markers.

00:16:01.900 --> 00:16:03.890
And for all the states that
are listed on the slides,

00:16:04.050 --> 00:16:05.080
we have a marker object.

00:16:05.160 --> 00:16:08.450
And then the views are informed about
the states and can handle it cleanly.

00:16:08.550 --> 00:16:10.950
And what you as a developer
will be able to do,

00:16:10.950 --> 00:16:13.730
you'll be able to specify
placeholder values.

00:16:14.160 --> 00:16:15.240
Let me give you an example of that.

00:16:15.290 --> 00:16:18.590
If you ever used address book or
mail to configure new mail accounts,

00:16:18.600 --> 00:16:21.380
you might have noticed that the
forms you have to fill out show

00:16:21.380 --> 00:16:25.420
some kind of informative text
in gray in the text fields until

00:16:25.420 --> 00:16:27.190
you specify a concrete value.

00:16:27.260 --> 00:16:29.710
So in our world,
that simply is a placeholder

00:16:29.710 --> 00:16:31.340
for the Nile value state.

00:16:31.400 --> 00:16:34.990
So placeholders really help you to
create informative user interfaces,

00:16:35.010 --> 00:16:38.160
and I really encourage you to
make use of that new feature.

00:16:40.840 --> 00:16:46.240
Manipulating object relationships.

00:16:46.240 --> 00:16:49.700
Most editing in applications is
just related to simple values

00:16:49.700 --> 00:16:50.850
like strings and numbers.

00:16:50.870 --> 00:16:52.940
If you want to assign a new
name to a person object,

00:16:52.940 --> 00:16:55.370
for example,
all you do is you create a new string

00:16:55.370 --> 00:16:57.460
and you assign it to that person object.

00:16:57.620 --> 00:17:00.800
But the identity of that string
doesn't really have a specific

00:17:00.800 --> 00:17:02.650
meaning to your application.

00:17:03.480 --> 00:17:06.270
Many models are more complicated though,
and sometimes you have

00:17:06.290 --> 00:17:07.440
complete graphs of objects.

00:17:07.440 --> 00:17:11.070
You might have a graph of person
objects and group objects.

00:17:11.230 --> 00:17:14.030
And if these groups and persons
are assigned to each other,

00:17:14.030 --> 00:17:16.350
you don't want to reference them
indirectly through a name or

00:17:16.360 --> 00:17:17.270
an ID or something like that.

00:17:17.370 --> 00:17:20.660
You want these objects to
have pointers to each other.

00:17:20.760 --> 00:17:24.130
So we call these pointers
that have a real meaning in

00:17:24.130 --> 00:17:27.240
your model a relationship,
and we typically distinguish

00:17:27.320 --> 00:17:30.640
between two-many relationships,
which are just arrays of references,

00:17:30.730 --> 00:17:34.340
and two-one relationships,
which are single object references.

00:17:34.450 --> 00:17:37.910
And our controller layer will give you
all the mechanisms you need to manipulate

00:17:37.910 --> 00:17:41.900
these relationships and to traverse them,
even if they are multiple levels deep.

00:17:42.000 --> 00:17:44.450
So one example could be a
UI where you have two tables,

00:17:44.450 --> 00:17:48.100
a table with all the groups and a
table with the persons in those groups.

00:17:48.100 --> 00:17:50.710
So the content of the second table,
the person table,

00:17:50.710 --> 00:17:54.170
depends on the group that is selected,
and the content is populated

00:17:54.170 --> 00:17:57.430
essentially through a relationship
from the group object.

00:18:01.130 --> 00:18:01.990
Value Transformers.

00:18:02.000 --> 00:18:06.930
Value Transformers represent an effort
on our side to make simplification of

00:18:06.960 --> 00:18:09.340
our controller layer simple for you.

00:18:09.380 --> 00:18:13.070
They are very small but powerful
objects that you attach to the

00:18:13.070 --> 00:18:14.990
bindings of the view objects.

00:18:15.070 --> 00:18:17.800
And Value Transformers are
given the opportunity to modify,

00:18:17.800 --> 00:18:21.200
to convert values before they are
displayed and convert them back

00:18:21.260 --> 00:18:24.090
in a different representation
after they've been edited.

00:18:24.180 --> 00:18:28.490
So essentially you can apply expressions
to the values in your model object.

00:18:28.690 --> 00:18:31.450
It probably sounds a little
bit like a formatter,

00:18:31.450 --> 00:18:32.840
but it's not limited to strings.

00:18:32.840 --> 00:18:34.680
It works with arbitrary data types.

00:18:34.680 --> 00:18:37.640
And also we have a named registry,
a global named registry

00:18:37.640 --> 00:18:40.470
for value transformers,
so that you can easily reference

00:18:40.470 --> 00:18:41.660
them from the Nib files.

00:18:41.740 --> 00:18:44.580
So you can register your own
value transformers in our

00:18:44.680 --> 00:18:48.020
registry and then just specify
them by name in the Nib files,

00:18:48.020 --> 00:18:50.500
and then this reference
will be resolved at runtime.

00:18:50.540 --> 00:18:52.510
So to give you an idea
of what you can do,

00:18:52.520 --> 00:18:56.220
we are planning to ship a few default
placeholders for you in Panther.

00:18:56.390 --> 00:18:58.010
One will just negate booleans.

00:18:58.010 --> 00:19:01.370
That would be very helpful when you
give enabled flags and things like that.

00:19:01.380 --> 00:19:05.840
We'll have transformers that
test values for nil or not nil.

00:19:05.840 --> 00:19:08.970
So what we will do is pretty much we
create a boolean depending on whether a

00:19:08.970 --> 00:19:10.950
value has already been specified or not.

00:19:10.960 --> 00:19:15.460
And we also have a value transformer
to archive values in an NSData.

00:19:15.460 --> 00:19:17.920
That last one will be very
handy when you actually talk

00:19:17.920 --> 00:19:19.490
to the user defaults database.

00:19:19.500 --> 00:19:23.380
Some of you might know that the user
defaults can only store plist objects,

00:19:23.380 --> 00:19:26.360
something like strings, numbers, arrays,
dictionaries, and NSData objects.

00:19:26.360 --> 00:19:28.720
But they can store
things like an NS color.

00:19:28.720 --> 00:19:30.720
So what do you do?

00:19:30.720 --> 00:19:33.000
In our world,
with the value transformers,

00:19:33.000 --> 00:19:36.090
you can simply use the value
transformer to encode or to archive

00:19:36.170 --> 00:19:39.720
the color object into an NSData and
store that in the user defaults.

00:19:39.720 --> 00:19:42.400
And then when it's read and
actually displayed in the UI,

00:19:42.400 --> 00:19:43.720
it's unarchived again.

00:19:43.720 --> 00:19:48.020
So these value transformers we expect
will probably be the most important way

00:19:48.020 --> 00:19:50.510
for you to customize our functionality.

00:19:53.050 --> 00:19:56.440
The last feature I want to mention
is controlling display parameters.

00:19:56.510 --> 00:19:59.340
We've done a lot in this area,
a bunch of different things.

00:19:59.340 --> 00:20:03.270
And most importantly, probably,
we have added automatic sorting

00:20:03.310 --> 00:20:04.250
and table views for you.

00:20:04.260 --> 00:20:06.880
This is something that a lot
of you have been asking for,

00:20:06.880 --> 00:20:08.930
and we're finally adding it in Panther.

00:20:09.260 --> 00:20:11.950
So what you'll be able to do is you'll be
able to click on the table column headers

00:20:11.960 --> 00:20:15.510
and we automatically sort the content of
the table according to that table column.

00:20:15.550 --> 00:20:17.260
And if you click a second time,
you'll reverse the sort

00:20:17.260 --> 00:20:18.190
order and things like that.

00:20:18.200 --> 00:20:19.670
We'll show that to you in the next demo.

00:20:21.100 --> 00:20:24.000
Beyond that,
we simply allow you to manage a large

00:20:24.110 --> 00:20:26.110
variety of user interface state.

00:20:26.170 --> 00:20:29.240
For example, what display colors and
fonts you want to use,

00:20:29.370 --> 00:20:31.480
how large windows are,
the window positions,

00:20:31.640 --> 00:20:35.400
the width of table columns,
which item in the tab view is selected,

00:20:35.400 --> 00:20:37.650
what windows are visible,
what drawers are visible.

00:20:37.660 --> 00:20:40.230
And you'll be able to collect
all that state and store it

00:20:40.230 --> 00:20:43.400
either in the user defaults
database or within your documents.

00:20:43.400 --> 00:20:46.970
So when users leave the application or
reopen documents they closed before,

00:20:46.970 --> 00:20:50.130
the application comes up in exactly
the same state as they left it.

00:20:55.330 --> 00:20:58.100
So now I'd like to ask James again
to come up on stage and show you an

00:20:58.100 --> 00:21:02.360
application that will make use of most
of the features that I just listed.

00:21:03.580 --> 00:21:04.990
All right.

00:21:05.040 --> 00:21:08.670
I have a little address
manager application here.

00:21:08.670 --> 00:21:13.030
And it basically is using the
address book framework to import

00:21:13.090 --> 00:21:14.270
everything in our address book.

00:21:14.330 --> 00:21:17.980
And I'm going to show you basically
a demo of all the features

00:21:17.980 --> 00:21:19.900
Andreas just talked about.

00:21:19.900 --> 00:21:21.970
So first let's take a
look at the table view.

00:21:22.200 --> 00:21:24.400
You'll notice as I select
items in the table view,

00:21:24.400 --> 00:21:27.900
the current selected item,
all of its data gets

00:21:27.900 --> 00:21:30.230
updated as you would expect.

00:21:30.320 --> 00:21:31.590
I can sort.

00:21:31.650 --> 00:21:34.640
Voila, as you might expect.

00:21:35.200 --> 00:21:38.880
Notice when I do sort and do not
have a particular row selected,

00:21:38.960 --> 00:21:43.280
I get that no selection indicator
in the text fields down here.

00:21:43.280 --> 00:21:46.560
And of course if I have
multiple items selected,

00:21:46.560 --> 00:21:48.900
I get the multiple selection.

00:21:50.680 --> 00:21:54.160
Andreas had mentioned, well,
let's take a look at groups here.

00:21:54.160 --> 00:21:55.320
We can add a new group.

00:21:55.440 --> 00:21:58.050
Call it my Bridge Club.

00:21:58.060 --> 00:22:00.910
Very exciting life I lead.

00:22:05.640 --> 00:22:07.230
Make that blue.

00:22:07.230 --> 00:22:10.480
And let's select four random people.

00:22:10.490 --> 00:22:12.120
Notice I'm not in my own bridge club.

00:22:14.710 --> 00:22:18.400
Pick that and obviously that
selection gives me all of the

00:22:18.450 --> 00:22:23.000
selected items take on that value and
now the pop-up displays that value.

00:22:23.120 --> 00:22:25.720
And I've connected those
people to a group object,

00:22:25.830 --> 00:22:31.670
not just a string called Bridge Club.

00:22:32.110 --> 00:22:34.940
Let's go take a look at the inspector.

00:22:34.940 --> 00:22:37.780
So I have an inspector
that also is changing.

00:22:37.780 --> 00:22:39.660
Well,
everybody works in five infinite loop.

00:22:39.660 --> 00:22:43.100
That's not very interesting.

00:22:43.100 --> 00:22:43.100
There we go.

00:22:43.860 --> 00:22:46.720
Let me bring up a new document.

00:22:46.820 --> 00:22:49.300
You'll notice as I switch
between documents,

00:22:49.300 --> 00:22:51.630
the inspector changes on the fly.

00:22:51.710 --> 00:22:53.800
Let me import from
dress book in this one.

00:22:53.810 --> 00:22:54.650
Voila.

00:22:54.650 --> 00:22:56.400
We'll go to context.

00:22:56.400 --> 00:23:00.370
I'll leave it on image.

00:23:00.370 --> 00:23:00.370
Now.

00:23:01.270 --> 00:23:02.860
Hit Preferences as well.

00:23:02.920 --> 00:23:06.570
In Preferences, we can

00:23:06.680 --> 00:23:09.180
crank up the row height,
crank up the font size,

00:23:09.180 --> 00:23:11.460
and you'll notice that
in both table views,

00:23:11.490 --> 00:23:13.590
it's happening live as we update.

00:23:13.600 --> 00:23:16.600
Let's save this document.

00:23:16.600 --> 00:23:20.060
Save document.

00:23:20.310 --> 00:23:22.530
And quit the app.

00:23:24.620 --> 00:23:29.400
When we relaunch and
get that document back,

00:23:29.400 --> 00:23:31.360
you'll notice that we
get the state we were in.

00:23:31.360 --> 00:23:34.510
It remembered that we did
indeed have this pulled out,

00:23:34.510 --> 00:23:36.900
and it's back to the way it was.

00:23:36.900 --> 00:23:40.980
So that's a sampling of
what's in this control layer.

00:23:40.980 --> 00:23:41.960
Thank you, Andreas.

00:23:47.870 --> 00:23:50.310
Do you want to show the project?

00:23:50.520 --> 00:23:51.060
Which one?

00:23:51.100 --> 00:23:51.530
The project.

00:23:51.660 --> 00:23:53.080
Do you want to show the project?

00:23:53.130 --> 00:23:55.600
Oh, goodness gracious.

00:23:55.800 --> 00:23:57.590
The kicker.

00:23:58.070 --> 00:24:01.640
I completely forgot that I had
to come here at all since I did

00:24:01.640 --> 00:24:03.400
so much in Project Builder.

00:24:03.460 --> 00:24:04.390
Documents.

00:24:04.500 --> 00:24:05.660
We go to the source code.

00:24:05.660 --> 00:24:09.030
So let's take a look at the source
code for that entire project.

00:24:09.410 --> 00:24:14.260
It's this much and it mainly deals
with grabbing stuff from address

00:24:14.360 --> 00:24:19.880
book and getting and setting
the values into the file system.

00:24:24.530 --> 00:24:32.230
That's 69 lines of code including
the imports and the comments.

00:24:32.230 --> 00:24:33.500
Now back to you, Andreas.

00:24:33.560 --> 00:24:35.150
Thank you.

00:24:40.730 --> 00:24:42.610
Okay, so the next step,
I'd like to give you an overview of

00:24:42.610 --> 00:24:44.960
the APIs we're introducing in the
context of the controller layer.

00:24:44.980 --> 00:24:48.060
And the APIs can be
grouped in three groups.

00:24:48.080 --> 00:24:51.810
Some utility classes,
some controller classes,

00:24:51.810 --> 00:24:53.360
and a few protocols.

00:24:56.480 --> 00:24:58.720
The utility classes,
the new utility classes,

00:24:58.810 --> 00:25:01.090
you'll find in the foundation layer.

00:25:01.090 --> 00:25:03.700
And the first one is
NSIndexSet and NSMutableIndexSet.

00:25:03.720 --> 00:25:07.780
NSIndexSet is a collection to
efficiently manage index information

00:25:07.780 --> 00:25:10.020
and to store them in a compact form.

00:25:10.020 --> 00:25:13.040
So that's something that we haven't had,
a concept we haven't had before,

00:25:13.040 --> 00:25:15.390
but it turned out to be really
important in the context of the

00:25:15.410 --> 00:25:18.020
controller layer where we manage
a lot of index information,

00:25:18.040 --> 00:25:20.450
selections and what indexes
have changed in the table view,

00:25:20.450 --> 00:25:20.860
etc.

00:25:21.640 --> 00:25:25.200
So you will see this class and
NSIndexSet in a bunch of our APIs,

00:25:25.200 --> 00:25:28.640
but it will probably be useful for many
other cases outside our controller layer.

00:25:28.640 --> 00:25:30.100
So I think you'll really like this class.

00:25:32.320 --> 00:25:34.340
The second one is an Assort Descriptor.

00:25:34.340 --> 00:25:37.500
An Assort Descriptor facilitates our
automatic sorting in table views.

00:25:37.540 --> 00:25:40.910
An Assort Descriptor essentially
represents sort criteria.

00:25:40.920 --> 00:25:43.280
So they specify the key
that is used for sorting.

00:25:43.280 --> 00:25:46.740
They specify how the values are compared,
whether they are case-sensitive

00:25:46.740 --> 00:25:47.960
or case-insensitive.

00:25:47.960 --> 00:25:50.440
And they specify the
direction of the sort,

00:25:50.440 --> 00:25:52.400
ascending versus descending.

00:25:52.400 --> 00:25:56.580
And typically, you assemble multiple sort
descriptors in an array to specify

00:25:56.660 --> 00:25:58.650
a sort order down multiple levels.

00:25:58.700 --> 00:26:01.620
So when you click in the table view,
we will pretty much create an

00:26:01.620 --> 00:26:04.250
array of sort descriptors for
you and pass it to the controller

00:26:04.250 --> 00:26:05.590
layer to actually perform the sort.

00:26:07.610 --> 00:26:09.740
Now I already talked
about NSValue Transformer.

00:26:09.760 --> 00:26:12.500
NSValue Transformers
are very simple APIs.

00:26:12.520 --> 00:26:14.840
You typically only implement
two or three methods.

00:26:14.860 --> 00:26:18.020
And it's just a method to convert a
value from one direction to the other one

00:26:18.020 --> 00:26:19.930
and another method to do the opposite.

00:26:20.170 --> 00:26:24.580
And you can attach them to the bindings
to customize or control the layer.

00:26:29.660 --> 00:26:32.200
The controller classes in Panther,
there will be first of

00:26:32.200 --> 00:26:34.840
all an NSController class,
which is just a super class,

00:26:34.840 --> 00:26:37.060
an abstract super class of all
the controllers we are shipping.

00:26:37.060 --> 00:26:38.850
And if you want to implement
your own controllers,

00:26:38.850 --> 00:26:40.400
you should subclass that class as well.

00:26:42.950 --> 00:26:45.070
There's going to be an
NSUserDefaultsController.

00:26:45.100 --> 00:26:49.000
NSUserDefaultsController is specialized
in talking to the user defaults database.

00:26:49.000 --> 00:26:52.260
Typically,
you use only one single instance,

00:26:52.260 --> 00:26:55.580
a shared instance of the
UserDefaultsController

00:26:55.800 --> 00:26:57.190
in your application.

00:26:57.800 --> 00:27:00.280
We made sure that the user
defaults controller is,

00:27:00.290 --> 00:27:02.550
to make it really easy for you
to access the user defaults,

00:27:02.550 --> 00:27:03.760
we made sure that the
user defaults controller,

00:27:03.760 --> 00:27:05.900
the shared user defaults controller,
is so easily accessible

00:27:05.900 --> 00:27:06.730
with the Nib files.

00:27:06.740 --> 00:27:09.410
That's why it was the one controller
that showed up in the first demo.

00:27:09.430 --> 00:27:12.520
So user defaults will be really simple
and transparent for you in the future.

00:27:12.660 --> 00:27:15.110
In addition to just talk to
the user defaults database,

00:27:15.110 --> 00:27:19.200
you can also use the user defaults
controller to specify initial values.

00:27:19.200 --> 00:27:21.870
So if the user never went to
the preferences panel and never

00:27:21.870 --> 00:27:25.210
specified preferences values,
you can transparently specify initial

00:27:25.210 --> 00:27:29.060
values for those and then they will be
just used throughout your application.

00:27:31.800 --> 00:27:34.750
and his object controller and then
this array controller and his object

00:27:34.830 --> 00:27:38.260
controller will be used or is used
for displaying and editing a single

00:27:38.260 --> 00:27:41.970
object in your user interface and this
array controller is used for displaying

00:27:41.970 --> 00:27:43.670
and editing an array of objects.

00:27:43.680 --> 00:27:47.350
And typically you use a combination
of those two classes and its object

00:27:47.370 --> 00:27:48.920
controllers and its array controllers.

00:27:48.930 --> 00:27:52.500
You typically bind the content of
those controllers to each other.

00:27:52.600 --> 00:27:55.080
So if you have, you know,
a table or let's say a

00:27:55.080 --> 00:27:57.740
document for a person object,
you could create an NS object

00:27:57.830 --> 00:28:00.540
controller and place the person
object within that controller.

00:28:00.610 --> 00:28:03.060
And if you then want to display
the groups that person is in,

00:28:03.160 --> 00:28:05.970
you create an array controller
and bind the content of that array

00:28:05.970 --> 00:28:08.390
controller to the parent controller,
to the object controller which

00:28:08.390 --> 00:28:13.040
contains the person object and it then
traverses the relationship for you.

00:28:17.330 --> 00:28:20.420
The protocols that will be important in
the context of the control area will be,

00:28:20.470 --> 00:28:21.930
first of all, NSKValue coding.

00:28:21.970 --> 00:28:23.180
I also mentioned that in the beginning.

00:28:23.180 --> 00:28:24.640
It's our data access protocol.

00:28:24.640 --> 00:28:27.430
And KValue observing is
our observing mechanism,

00:28:27.430 --> 00:28:30.610
so it's the one that we use to
receive change notifications

00:28:30.610 --> 00:28:32.130
from the model objects.

00:28:32.140 --> 00:28:35.790
And we talk about both these protocols
in great detail in session number 419.

00:28:37.960 --> 00:28:40.400
Editor tracking is a protocol
that I haven't mentioned so far,

00:28:40.400 --> 00:28:42.620
but it will be also very useful for you.

00:28:42.690 --> 00:28:46.790
Most Cocoa applications don't
immediately submit changes in the

00:28:46.790 --> 00:28:48.470
user interface to the model objects.

00:28:48.530 --> 00:28:51.990
Most of the time you wait until
the user presses the tab key or the

00:28:51.990 --> 00:28:55.860
return key and leaves the text field,
and only then apply the value.

00:28:55.950 --> 00:28:57.350
There's nothing wrong with that.

00:28:57.490 --> 00:28:59.410
You just need to make sure
that if you save a document,

00:28:59.410 --> 00:29:01.770
you capture those last edits.

00:29:01.820 --> 00:29:04.650
So with editor tracking,
views will be able to tell

00:29:04.650 --> 00:29:07.600
the controllers that they have
uncommitted changes right now,

00:29:07.660 --> 00:29:10.440
and then with a single method call,
you will be able to commit those

00:29:10.440 --> 00:29:11.700
changes to the model objects.

00:29:11.720 --> 00:29:13.770
You will be able to force
the views to submit their

00:29:13.770 --> 00:29:16.590
changes to the model objects,
or to add editing, for example,

00:29:16.600 --> 00:29:18.600
before you want to revert.

00:29:20.460 --> 00:29:24.870
So bringing up this picture again,
key value coding is the protocol used

00:29:25.050 --> 00:29:28.680
when the view talks to the controller
to ask for values and also when the

00:29:28.790 --> 00:29:30.710
controller talks to the model objects.

00:29:30.820 --> 00:29:34.140
So the arrows in this diagram
don't represent the data flow,

00:29:34.240 --> 00:29:38.060
it represents who
initiates the method calls.

00:29:38.290 --> 00:29:41.000
And on the way back,
we use key value observing to

00:29:41.000 --> 00:29:44.270
tell the controller and the
views that something has changed.

00:29:45.620 --> 00:29:48.660
Editor tracking will go back and forth
between the controllers and the views.

00:29:48.660 --> 00:29:50.950
So the views will register
with the controllers if they

00:29:51.010 --> 00:29:53.280
have uncommitted changes,
and then the controllers,

00:29:53.280 --> 00:29:55.440
before a save or a revert,
they will commit the changes

00:29:55.440 --> 00:29:59.040
or they will abort the editing.

00:29:59.170 --> 00:30:01.160
So those are the protocols.

00:30:07.480 --> 00:30:13.440
I'd like to now specify or give
you an idea of a few more APIs that

00:30:13.440 --> 00:30:15.780
you will encounter when you start
working with our controller layer.

00:30:15.780 --> 00:30:18.790
The first one is our
key value binding API,

00:30:18.790 --> 00:30:21.360
which you use to create bindings.

00:30:21.380 --> 00:30:24.080
There are two methods,
and these are methods on the view

00:30:24.080 --> 00:30:25.800
objects that you want to bind.

00:30:25.800 --> 00:30:29.490
So the first method is bind to
object with key path options,

00:30:29.590 --> 00:30:32.840
and there's an unbind
method to do the reverse.

00:30:32.840 --> 00:30:36.440
Let's take a look at the
arguments to the methods.

00:30:37.320 --> 00:30:40.710
The first argument to the bind
method is the name of the binding.

00:30:40.720 --> 00:30:43.920
So it typically represents the
property that you want to control.

00:30:43.920 --> 00:30:46.450
It's something like text color, enabled,
or value.

00:30:47.740 --> 00:30:50.010
The second argument is
the object you observe.

00:30:50.020 --> 00:30:51.840
It's typically the
controller that you bind to.

00:30:51.840 --> 00:30:56.680
And the key path, the third argument,
specifies what value to use

00:30:56.680 --> 00:30:58.790
when you control the property.

00:30:58.840 --> 00:31:03.320
And then the fourth argument is simply
an end of dictionary of options,

00:31:03.320 --> 00:31:06.520
simply an end of dictionary with several
parameters that you can specify to

00:31:06.600 --> 00:31:08.260
influence the behavior of the bindings.

00:31:08.260 --> 00:31:10.840
What you typically put in
this options dictionary is,

00:31:10.850 --> 00:31:14.250
for example, the value transformer name,
and you can also specify the

00:31:14.250 --> 00:31:17.540
placeholders for the various states
I mentioned a few minutes ago.

00:31:17.600 --> 00:31:19.980
in this options dictionary.

00:31:21.430 --> 00:31:24.530
You typically don't have to
invoke these methods by hand.

00:31:24.630 --> 00:31:26.740
These are the methods that
Interface Builder uses when

00:31:26.740 --> 00:31:29.990
bindings are established,
but you might have to use them by

00:31:29.990 --> 00:31:34.160
hand if you want to bind objects from
different Nib files to each other.

00:31:38.530 --> 00:31:44.440
I just talked about specifying the
placeholders in the options dictionary.

00:31:44.440 --> 00:31:47.940
And that is important that you can,
for each individual binding,

00:31:47.940 --> 00:31:50.450
specify placeholders,
but we expect that most of the time

00:31:50.450 --> 00:31:53.650
you will want to use generic terms,
something like no selection,

00:31:53.650 --> 00:31:55.700
multiple selection, et cetera.

00:31:55.730 --> 00:31:58.650
So to make that easier for you,
we defined an API where you can

00:31:58.650 --> 00:32:02.370
set default placeholder values
for your complete application.

00:32:02.670 --> 00:32:05.690
And these are class methods, again,
methods that you invoke

00:32:05.830 --> 00:32:08.920
on the view classes,
for example, on as text field.

00:32:08.920 --> 00:32:12.330
And they are called
setDefaultPlaceholderForMarkerWithBinding

00:32:12.600 --> 00:32:15.540
and
defaultPlaceholderForMarkerWithBinding.

00:32:15.540 --> 00:32:18.980
So the arguments here are first
of all the placeholder value,

00:32:18.980 --> 00:32:20.120
then the marker.

00:32:20.140 --> 00:32:22.370
And for the marker,
you will either pass in nil to

00:32:22.520 --> 00:32:25.260
indicate the null value state,
or one of the three object

00:32:25.300 --> 00:32:26.210
values I listed here.

00:32:26.220 --> 00:32:29.080
And it's multiple values marker,
and it's no selection marker,

00:32:29.080 --> 00:32:30.900
and it's not applicable marker.

00:32:30.900 --> 00:32:34.060
So these are the marker object
that we defined to indicate the

00:32:34.150 --> 00:32:36.200
different states to the view objects.

00:32:36.220 --> 00:32:39.760
And you simply pass the marker object
to the setDefaultPlaceholder method.

00:32:42.170 --> 00:32:43.900
And then the third argument
is the binding name.

00:32:43.990 --> 00:32:47.340
So per binding,
you can define different placeholders.

00:32:50.880 --> 00:32:55.850
Another API that will be very useful
for you is an API that you can--if

00:32:55.950 --> 00:33:00.530
you have subclasses of views that have
additional parameters that you want

00:33:00.530 --> 00:33:04.100
to expose to the controller layer,
then as long as you have a key

00:33:04.100 --> 00:33:08.120
value coding compliant--as long as
you have key value coding compliant

00:33:08.120 --> 00:33:10.550
methods for this parameter,
pretty much just a simple

00:33:10.550 --> 00:33:11.590
set and get method.

00:33:11.630 --> 00:33:14.640
As long as you have that,
you can expose the parameters

00:33:14.640 --> 00:33:17.780
simply by invoking the class
method exposed binding.

00:33:17.880 --> 00:33:21.190
You typically do that in the
initialized method of your class.

00:33:21.360 --> 00:33:23.260
And once you invoke it
to the parameter name,

00:33:23.260 --> 00:33:26.870
the binding will show up automatically
in interface builder and everything

00:33:26.900 --> 00:33:28.380
else will be taken care of.

00:33:28.380 --> 00:33:30.600
There's also an instance method,
exposed bindings,

00:33:30.600 --> 00:33:33.270
which returns all the available
bindings for an object,

00:33:33.420 --> 00:33:34.990
including the ones that we provide.

00:33:36.380 --> 00:33:40.640
and optionally you can implement
the method value class for binding,

00:33:40.710 --> 00:33:43.160
which is pretty much used in
interface builder to match other

00:33:43.160 --> 00:33:44.540
objects against the bindings.

00:33:44.540 --> 00:33:47.100
So for example, you can filter out what
value transformers do not

00:33:47.280 --> 00:33:48.960
apply to a given binding.

00:33:48.970 --> 00:33:52.460
So it's optionally for you,
but if you do, it's helpful for interface

00:33:52.470 --> 00:33:54.090
builder if you implement it.

00:33:54.690 --> 00:33:58.140
If you need to go beyond a
simple key value coding binding,

00:33:58.250 --> 00:34:01.260
then you will have to override
the bind method at this time.

00:34:01.350 --> 00:34:03.990
And in the bind method,
you have to pretty much register the

00:34:03.990 --> 00:34:07.140
state that you need for your binding
by hand and track that yourself.

00:34:07.240 --> 00:34:10.250
So simple key value coding
bindings are very simple to expose

00:34:10.250 --> 00:34:11.850
with a single method called.

00:34:11.850 --> 00:34:13.840
Beyond that,
override the bind method and pretty

00:34:13.840 --> 00:34:16.090
much manage the state yourself.

00:34:18.380 --> 00:34:22.700
The last API I want to list here is the
API that you use to populate the content

00:34:22.700 --> 00:34:24.500
of the object and array controllers.

00:34:24.580 --> 00:34:27.340
The method is simply called setContent.

00:34:27.460 --> 00:34:31.340
And you can invoke it by hand, manually,
or more commonly,

00:34:31.340 --> 00:34:34.000
you'll probably use bindings
to bind the content of the

00:34:34.000 --> 00:34:36.030
controllers through relationships.

00:34:36.110 --> 00:34:39.990
The names of the bindings are object
relationship and array relationship.

00:34:43.400 --> 00:34:46.760
So I'd like to ask James to come
up on stage again and give you a

00:34:46.840 --> 00:34:50.750
third demo of Interface Builder
with the more advanced features.

00:34:51.600 --> 00:34:59.490
Okay, let's make another new nib file.

00:34:59.490 --> 00:34:59.490
Oops, wrong app.

00:34:59.490 --> 00:34:59.490
There we go.

00:34:59.490 --> 00:34:59.490
Another new nib file.

00:34:59.930 --> 00:35:03.500
This time,
let's go a little bit deeper into how

00:35:03.500 --> 00:35:06.510
I set up and configure these bindings.

00:35:06.920 --> 00:35:08.830
So if we take a look,
we have a new palette

00:35:08.930 --> 00:35:11.250
in Interface Builder,
the Binder palette.

00:35:11.260 --> 00:35:15.760
It has the user defaults controller,
the object controller,

00:35:15.860 --> 00:35:18.740
and the array controller
that Andreas talked about.

00:35:18.740 --> 00:35:20.720
And we'll start with an array controller.

00:35:20.720 --> 00:35:23.640
And if we look at the attributes
of an array controller,

00:35:23.640 --> 00:35:27.170
you'll notice that by default,
that array controller is going to be

00:35:27.170 --> 00:35:31.190
holding onto NSMutable dictionaries,
which we can use as a generic

00:35:31.330 --> 00:35:33.940
container to hold any key value pairs.

00:35:34.470 --> 00:35:37.180
However,
you can use an NSArray controller

00:35:37.180 --> 00:35:41.820
to hold an array of any key value
coding compliant class in your model.

00:35:41.820 --> 00:35:44.280
Let's add a few keys.

00:35:44.280 --> 00:35:47.330
Of course, we can add them on the fly,
but it's just a little easier to do

00:35:47.330 --> 00:35:48.960
it all at once for demo purposes.

00:35:48.960 --> 00:35:55.720
We're going to put in a flag, a string,
and an aptly named number

00:35:55.720 --> 00:35:58.080
as our items there.

00:35:58.080 --> 00:36:01.600
And let's hook this
array up to a table view.

00:36:01.600 --> 00:36:03.030
There we go.

00:36:04.380 --> 00:36:09.510
So we'll add another column,
drag that on out.

00:36:11.990 --> 00:36:13.750
Get that a little wider.

00:36:13.750 --> 00:36:16.300
Set for multiple selection.

00:36:16.330 --> 00:36:18.810
Now, how do we hook this up?

00:36:19.590 --> 00:36:23.820
Select the table view,
let's call this one flag.

00:36:23.820 --> 00:36:26.830
Go to the bindings and
set the value of this.

00:36:26.840 --> 00:36:28.680
Instead of pulling from
shared user defaults,

00:36:28.810 --> 00:36:30.500
we'll pull from the NSArrayController.

00:36:30.500 --> 00:36:34.410
The controller key,
the array controller has a key that will

00:36:34.410 --> 00:36:39.500
let us get at all of the arranged objects
or just the items that are selected.

00:36:39.500 --> 00:36:41.540
We want all the objects,
so we'll pick that and

00:36:42.110 --> 00:36:43.500
choose flag for this column.

00:36:43.500 --> 00:36:49.510
In fact, we're going to make this one of
these handy dandy checkbox columns.

00:36:52.340 --> 00:36:54.800
You can clap, feel free.

00:36:54.800 --> 00:36:59.860
For the string, we'll hook that up,
shared user, excuse me,

00:36:59.860 --> 00:37:02.430
that NSArray controller,
arranged objects,

00:37:02.520 --> 00:37:03.640
we'll go for the string.

00:37:03.640 --> 00:37:07.620
And this time,
if somebody hasn't typed in something,

00:37:07.620 --> 00:37:09.240
we'll put in a null placeholder.

00:37:09.690 --> 00:37:13.310
So we'll say no value.

00:37:14.600 --> 00:37:18.060
In the last column,
we'll display a number.

00:37:18.060 --> 00:37:21.500
But this time we'll display it using
one of these handy-dandy slider cells.

00:37:21.500 --> 00:37:27.720
And we'll set that value up to be
NSArrayControllerArrangedObjects.

00:37:27.840 --> 00:37:29.030
Notice a pattern.

00:37:29.030 --> 00:37:29.500
Number.

00:37:29.500 --> 00:37:34.600
And we're also going to just
make sure that those cells,

00:37:34.600 --> 00:37:36.490
click that little widget
to get to the cell,

00:37:36.550 --> 00:37:40.500
has reasonable min and max values.

00:37:40.500 --> 00:37:41.500
There we go.

00:37:41.500 --> 00:37:42.500
Great.

00:37:42.600 --> 00:37:46.500
Now let's add an add and remove button.

00:37:46.520 --> 00:37:48.190
There we go.

00:37:48.190 --> 00:37:50.080
Option drag.

00:37:54.400 --> 00:37:56.450
We'll line them up all Aqua-y like.

00:37:56.560 --> 00:37:57.520
Okay.

00:37:57.610 --> 00:37:59.900
We can use regular old target action.

00:37:59.900 --> 00:38:04.200
A NSArrayController has an add
action that we can hook up to and a

00:38:04.200 --> 00:38:06.780
remove action that we can hook up to.

00:38:06.900 --> 00:38:09.210
Let's get a little more room here.

00:38:09.830 --> 00:38:15.420
and add a text view to show the
selected object and a checkbox

00:38:15.420 --> 00:38:18.970
to show that selected flag.

00:38:21.110 --> 00:38:25.040
Again, go to the bindings,
hook that value up, shared user,

00:38:25.040 --> 00:38:29.200
excuse me, that NSArrayController,
and this time we want the selection,

00:38:29.200 --> 00:38:32.130
not all the arranged objects,
and we're going to hook

00:38:32.130 --> 00:38:33.670
that on up to the string.

00:38:33.830 --> 00:38:36.800
And this time around,
if there are multiple items selected,

00:38:36.800 --> 00:38:40.460
we'll say multiple items selected.

00:38:40.550 --> 00:38:42.030
That might be clear enough.

00:38:42.090 --> 00:38:45.760
If there's no selection,
we'll say no selection.

00:38:46.060 --> 00:38:49.670
And if null, we'll say,
"Please just type wacky

00:38:49.670 --> 00:38:51.880
stuff like nothing."

00:38:53.500 --> 00:38:55.640
And then for the flag,
we'll hook that up to

00:38:55.640 --> 00:39:00.500
the array controller,
selection, and flag.

00:39:01.900 --> 00:39:06.140
Finally,
let's just bring color into this here.

00:39:06.140 --> 00:39:08.160
And we're going to have this
color going to shared user

00:39:08.270 --> 00:39:12.480
defaults values as a font color.

00:39:13.070 --> 00:39:16.900
And we'll hook that up to the font color.

00:39:16.900 --> 00:39:17.610
Where are we?

00:39:17.860 --> 00:39:19.780
There it is, text color.

00:39:19.970 --> 00:39:26.100
Shared user defaults, values, font color.

00:39:26.870 --> 00:39:28.850
Should it work, Andreas?

00:39:28.860 --> 00:39:29.740
I think so.

00:39:29.740 --> 00:39:31.580
OK.

00:39:31.590 --> 00:39:32.400
Of course, I should say.

00:39:32.400 --> 00:39:32.870
All righty.

00:39:33.010 --> 00:39:35.360
So first things first,
we hit Test Interface mode,

00:39:35.360 --> 00:39:37.480
and we can ship.

00:39:37.860 --> 00:39:39.910
I'm pretty much ready at this point.

00:39:40.040 --> 00:39:43.940
So we got that no value hanging out
there because there is no value.

00:39:43.940 --> 00:39:46.500
If I select it, obviously,

00:39:47.420 --> 00:39:49.680
I'll type in there.

00:39:49.710 --> 00:39:50.340
Bob.

00:39:50.370 --> 00:39:51.240
Let's add some people.

00:39:51.370 --> 00:39:53.140
What'd I do?

00:39:53.530 --> 00:39:54.640
Uh-oh.

00:39:54.720 --> 00:39:55.400
Oh dear.

00:39:55.400 --> 00:39:58.400
I broked it.

00:39:58.400 --> 00:40:01.230
Alright.

00:40:01.390 --> 00:40:04.670
For just such an occasion...

00:40:08.910 --> 00:40:13.040
I did the cooking class
thing and worked one out.

00:40:13.080 --> 00:40:15.900
So let's add a few items here.

00:40:16.020 --> 00:40:18.940
Honest to God, come see me,
it works on my PowerBook.

00:40:21.510 --> 00:40:31.060
Put in Phil, some Jerry,
misspelled Jerry, and Yolanda.

00:40:32.640 --> 00:40:35.600
Of course, we do all of this fun stuff,
give some settings.

00:40:35.600 --> 00:40:39.250
We select along and obviously
we get what we're selecting.

00:40:39.460 --> 00:40:41.600
We do a multiple selection.

00:40:41.600 --> 00:40:44.460
We get the mixed state for the checkbox.

00:40:44.460 --> 00:40:48.400
We get bobs are both the same value,
so it puts the value in there.

00:40:48.790 --> 00:40:53.270
If we add fill to the mix,
it jumps to multiple selected.

00:40:59.760 --> 00:41:02.640
Now of course,
maybe that's one Bob too many,

00:41:02.640 --> 00:41:05.400
so we'll get rid of him.

00:41:05.400 --> 00:41:06.310
We can sort.

00:41:06.470 --> 00:41:09.180
This is so tough to do.

00:41:09.260 --> 00:41:13.010
Oh, it's killer.

00:41:13.630 --> 00:41:18.870
Let's see,
is that pretty much the whole pup?

00:41:19.530 --> 00:41:21.460
I know what I did.

00:41:21.460 --> 00:41:24.030
Dag Navit, I think I know what I did.

00:41:24.030 --> 00:41:25.800
And I'm going to show you.

00:41:25.850 --> 00:41:31.260
I forgot one handy thing that many
beginning Cocoa programmers forget,

00:41:31.370 --> 00:41:35.240
which is that you can't just put
an NSColor into the user defaults.

00:41:35.480 --> 00:41:35.780
Why?

00:41:35.780 --> 00:41:37.440
It has to go in as an NSData.

00:41:37.440 --> 00:41:42.220
So I'm going to use this
transformer to do that.

00:41:42.220 --> 00:41:45.450
And then when it comes back out,
I have to turn it from

00:41:45.640 --> 00:41:47.110
an NSData into a color.

00:41:48.470 --> 00:41:50.400
Now this was not pre-planned,
I just screwed it up,

00:41:50.400 --> 00:41:54.710
but let's see if that now works.

00:41:59.680 --> 00:42:06.190
That's fix and continue.

00:42:06.290 --> 00:42:10.100
I believe that is all that I have,
and thank you very much

00:42:10.100 --> 00:42:12.520
for your kind indulgence.

00:42:22.240 --> 00:42:23.470
Thank you, James.

00:42:23.560 --> 00:42:25.260
So a few more things before I wrap up.

00:42:25.290 --> 00:42:27.080
I've read about performance.

00:42:27.110 --> 00:42:30.060
We spent a lot of time on
tuning our refresh logic.

00:42:30.060 --> 00:42:32.890
And if you get detailed
enough observer notifications,

00:42:32.900 --> 00:42:36.130
we actually tuned the refresh down
to single cells and table views.

00:42:36.190 --> 00:42:39.840
So we only redraw the minimum area in the
user interface that we have to redraw.

00:42:39.840 --> 00:42:41.790
And of course,
we added a few caches in the right

00:42:41.870 --> 00:42:44.140
places to further enhance that.

00:42:44.200 --> 00:42:47.840
To make you curious
of session number 419,

00:42:47.880 --> 00:42:51.130
through the introduction
of key value coding,

00:42:51.220 --> 00:42:53.320
we introduced a level of indirection.

00:42:53.340 --> 00:42:55.170
You're not invoking
methods directly anymore.

00:42:55.240 --> 00:42:57.700
You're referring to values by name.

00:42:57.700 --> 00:43:00.750
So key value coding calls are
a tiny little bit slower than

00:43:00.750 --> 00:43:03.210
direct method invocations,
nothing that you have to worry about,

00:43:03.210 --> 00:43:03.490
really.

00:43:03.620 --> 00:43:06.380
But if you get into millions of
objects on the screen at the same time,

00:43:06.530 --> 00:43:08.390
you need to know how
key value coding works.

00:43:08.600 --> 00:43:10.460
So you need to use it
the way it is intended.

00:43:10.460 --> 00:43:13.840
And for session 419,
we'll talk about all the details.

00:43:15.090 --> 00:43:17.980
So if you like this new functionality
and you want to start using it,

00:43:17.980 --> 00:43:20.330
the good news is you don't have
to rewrite your application.

00:43:20.340 --> 00:43:22.800
We have made sure that our
controller layer can easily

00:43:22.800 --> 00:43:25.780
coexist with the traditional
glue code that you wrote so far.

00:43:25.800 --> 00:43:28.900
So we recommend that you start
using the functionality soon.

00:43:28.900 --> 00:43:31.190
You'll probably get a better
user experience because

00:43:31.300 --> 00:43:34.730
of our selection handling,
the automatic sorting, the placeholders,

00:43:34.730 --> 00:43:35.780
the user defaults.

00:43:35.860 --> 00:43:40.750
You might even see improved performance
because of our tuned redraw logic.

00:43:41.580 --> 00:43:44.220
And since you'll be able to phase
out a lot of your glue code,

00:43:44.220 --> 00:43:46.470
you will simply reduce
your maintenance cost.

00:43:46.630 --> 00:43:47.980
Less code is always good.

00:43:49.430 --> 00:43:52.460
And also,
if you start using our controller layer,

00:43:52.510 --> 00:43:54.880
you will be much better
prepared for future releases.

00:43:54.880 --> 00:43:57.730
If we add features in
Cocoa in future releases,

00:43:57.730 --> 00:43:59.900
you'll just be able to get them for free.

00:43:59.900 --> 00:44:01.770
You just need to start using
the controller layer now.

00:44:06.710 --> 00:44:09.740
But the seed that you have in
your hands is a better version.

00:44:09.790 --> 00:44:12.110
So there are a few things you need to
know if you want to play around with

00:44:12.160 --> 00:44:14.200
the seed that you have in your hands.

00:44:14.260 --> 00:44:15.760
First of all,
there's unfortunately very little

00:44:15.760 --> 00:44:18.700
documentation available for
the controller layer right now.

00:44:18.720 --> 00:44:21.430
The documentation is still forthcoming,
so at this time we have to point you

00:44:21.440 --> 00:44:25.360
only to the headers that you find in
the foundation of the AppKit framework.

00:44:25.360 --> 00:44:27.940
And also there are a few pieces
missing in the implementation.

00:44:28.050 --> 00:44:30.770
Most importantly,
the controllers and the seed do not use

00:44:30.810 --> 00:44:33.500
the key value observing mechanism yet.

00:44:33.600 --> 00:44:36.350
So when I talked about the automatic
propagation of changes to the

00:44:36.350 --> 00:44:39.560
user interfaces that won't work,
what we will refresh automatically for

00:44:39.730 --> 00:44:43.070
you is all the pieces of the UI that
are controlled by the same controller,

00:44:43.110 --> 00:44:45.080
as you saw on the Nib files here,
it all worked.

00:44:45.080 --> 00:44:48.460
But if you go across multiple
controllers for the same model objects,

00:44:48.460 --> 00:44:51.360
we won't--the automatic
propagation of changes won't work.

00:44:51.360 --> 00:44:53.360
Also,
please treat the available bindings and

00:44:53.460 --> 00:44:55.440
the names of the bindings as preliminary.

00:44:55.440 --> 00:44:58.000
You might make a few
more changes in there.

00:44:58.000 --> 00:45:01.780
And another thing that you need to know
is that when you start using our value

00:45:01.780 --> 00:45:05.160
and content bindings for individual
widgets-- we are starting to take over

00:45:05.220 --> 00:45:08.040
the targets and delegates at this time.

00:45:08.040 --> 00:45:10.320
So if you have a checkbox and
you bind the value binding,

00:45:10.320 --> 00:45:13.170
you will not be able to specify
a target action anymore for it.

00:45:13.180 --> 00:45:14.540
We will take ownership of that.

00:45:14.540 --> 00:45:15.860
So we resolved that for the GM.

00:45:15.860 --> 00:45:19.080
We fixed that, of course,
but it might impact how fast you

00:45:19.190 --> 00:45:21.100
can adopt the new technology.

00:45:21.100 --> 00:45:22.800
And in general,
I'd like to recommend that you use

00:45:22.800 --> 00:45:26.300
the 10.2 and later Nib file format
in interface builder because that

00:45:26.300 --> 00:45:28.420
greatly enhances compatibility.

00:45:31.080 --> 00:45:33.270
So this is all a brand
new implementation.

00:45:33.340 --> 00:45:34.830
It's a brand new feature.

00:45:34.880 --> 00:45:36.640
And so please submit back reports.

00:45:36.660 --> 00:45:37.950
It's in your own interest.

00:45:38.150 --> 00:45:41.210
And also, if you have ideas and thoughts,
we'd like to know about them.

00:45:41.210 --> 00:45:44.250
So please use the Cocoa feedback
at group.apple.com mailing list.

00:45:44.310 --> 00:45:46.950
We won't guarantee your response,
but we promise that we will read all

00:45:46.960 --> 00:45:50.130
your input and take it into concern.

00:45:51.930 --> 00:45:56.460
So in summary, in Panther we are adding a
great new functionality for you,

00:45:56.470 --> 00:45:59.770
a controller layer that will automate
a lot of your user interface handling.

00:45:59.800 --> 00:46:02.370
It will get rid of a lot of code
that you had to write so far.

00:46:04.480 --> 00:46:06.880
And we thought a lot about
customization with value

00:46:06.960 --> 00:46:08.690
transformers to make that easy.

00:46:08.790 --> 00:46:11.030
And as you saw,
we extended interface barriers so

00:46:11.100 --> 00:46:15.400
that you can use the new functionality
without writing any single line of code.

00:46:15.440 --> 00:46:18.400
So with that, it's time for what
you've been waiting for.

00:46:19.590 --> 00:46:21.290
James!

00:46:27.930 --> 00:46:32.920
So I guess it was just a little
while ago and I had the good fortune

00:46:32.920 --> 00:46:37.560
to see this technology before
it was rolled out here at WWDC.

00:46:37.560 --> 00:46:43.000
And as sometimes happens with
technologies that I get stoked about,

00:46:43.000 --> 00:46:47.640
the first thing I do is go to the iTunes
music store and type in some keywords,

00:46:47.640 --> 00:46:49.320
see if there are any songs about it.

00:46:49.360 --> 00:46:52.700
And there weren't any.

00:46:52.750 --> 00:46:57.040
Not one song about Model View Controller.

00:46:57.040 --> 00:47:00.540
So then, of course,
the next step is I tend to write one.

00:47:00.540 --> 00:47:06.900
So this year's song is a
Model View Controller song.

00:47:13.030 --> 00:47:16.570
And once again,
I thank you for your kind indulgence.

00:47:16.690 --> 00:47:20.050
Are we good to go?

00:47:20.110 --> 00:47:22.080
Am I good to go?

00:47:24.900 --> 00:47:27.980
We're going to switch
over to demo machine,

00:47:27.980 --> 00:47:29.740
the one Victor's in front of.

00:47:29.780 --> 00:47:31.810
One or two?

00:47:39.700 --> 00:47:49.800
[Transcript missing]

00:47:56.700 --> 00:48:02.730
♪ There's a paradigm for factoring
your code ♪ ♪ Into functional segments

00:48:02.750 --> 00:48:07.840
so your brain does not explode
♪ ♪ To achieve reusability you

00:48:07.840 --> 00:48:10.770
gotta keep those boundaries clean ♪

00:48:11.020 --> 00:48:16.430
Model on the one side, view on the other,
the controllers in between.

00:48:18.650 --> 00:48:23.440
It's got three layers
like Oreos do Model view,

00:48:23.440 --> 00:48:25.890
creamy controller

00:48:35.340 --> 00:48:41.360
represent your applications rays on
detra custom classes that contain data

00:48:41.360 --> 00:48:49.200
logic and etc you create custom classes
in your apps problem domain then you can

00:48:49.200 --> 00:48:54.120
choose to reuse them with other views
but the model objects stay the same you

00:48:54.120 --> 00:49:00.920
can model a throttle in a manifold model
of a two year old model a bottle of fine

00:49:00.920 --> 00:49:06.200
Chardonnay bottle all the collado stops
people say model the coddle in a boil

00:49:06.200 --> 00:49:14.840
in eggs model the waddle in Hexley's
legs one two three four model you you

00:49:14.840 --> 00:49:18.370
can model all the models opposed for GQ

00:49:34.550 --> 00:49:39.150
♪ Cocoa's got a lot of those
♪ ♪ Well written to its credit

00:49:39.150 --> 00:49:42.880
♪ ♪ Take an NS TextView,
hand it any old unit code ♪

00:49:45.000 --> 00:50:05.100
[Transcript missing]

00:50:14.800 --> 00:50:20.960
and Probably wondering how data
flows between model and view.

00:50:21.090 --> 00:50:26.940
The controller has to mediate
between each layer's changing state

00:50:26.990 --> 00:50:30.510
to synchronize the data of the two.

00:50:30.640 --> 00:50:35.080
It pulls and pushes every changed value.

00:50:35.080 --> 00:50:35.920
Yeah.

00:50:35.920 --> 00:50:37.680
Model view.

00:50:37.680 --> 00:50:44.680
Mad props to the small
talk crew for model view.

00:51:04.100 --> 00:51:36.800
[Transcript missing]

00:51:42.500 --> 00:51:45.980
"They model in view very intimately.

00:51:45.980 --> 00:51:52.480
They often are hard coding which
is very foreboding for reusability.

00:51:54.000 --> 00:51:57.270
any value you select
to any view property.

00:51:57.280 --> 00:52:01.330
And I think you'll stop buying
and then you'll be finding

00:52:01.330 --> 00:52:03.420
less code in your source tree.

00:52:03.420 --> 00:52:05.490
Yeah, I know I was astounded.

00:52:05.490 --> 00:52:07.310
That's not even a rhyme.

00:52:07.320 --> 00:52:11.180
But I think it bears repeating
all the codes you won't be

00:52:11.180 --> 00:52:13.720
needing when you hook it up in IB.

00:52:13.720 --> 00:52:19.860
Model view,
it even handles multiple selections too.

00:52:19.860 --> 00:52:22.760
Model view controller.

00:52:24.000 --> 00:52:26.380
Model view.

00:52:26.380 --> 00:52:29.360
Hope I get my G5 before you.

00:53:07.300 --> 00:53:20.300
[Transcript missing]

00:53:21.200 --> 00:53:23.200
This is the roadmap
for the Cocoa sessions.

00:53:23.250 --> 00:53:26.400
I make this short, so 419 again.

00:53:26.400 --> 00:53:30.550
And the Cocoa Feedback Forum is probably
the other one that will be important.

00:53:32.020 --> 00:53:34.050
These are the usual contacts.

00:53:34.050 --> 00:53:37.880
Again, send feedback to
cocoafeedback@group.apple.com.

00:53:40.500 --> 00:53:43.100
For more information,
documentation is forthcoming.

00:53:43.100 --> 00:53:44.880
Please check the headers at this time.

00:53:44.880 --> 00:53:46.930
And we also don't even
have demo code available,

00:53:46.940 --> 00:53:49.020
but we'll try to do that in
the next one or two weeks.

00:53:49.080 --> 00:53:50.560
So please check the
ADC member site again,

00:53:50.570 --> 00:53:52.140
and we'll try to put
some demo code there.

00:53:52.160 --> 00:53:54.660
And with that,
I'd like to ask a few colleagues to come

00:53:54.740 --> 00:53:56.570
up on stage and take some questions.
WEBVTT

00:00:20.570 --> 00:00:26.740
I'd like to welcome you to session 110,
Overview of Mac OS X Networking APIs.

00:00:26.850 --> 00:00:28.590
My name's Tom Weier.

00:00:28.600 --> 00:00:32.020
I'm a consulting engineer in
our field engineering group,

00:00:32.160 --> 00:00:36.520
and I have the fortune of
introducing this session.

00:00:36.660 --> 00:00:39.780
There's a lot of things in Mac OS X that
have changed over the years.

00:00:39.780 --> 00:00:42.880
A lot of new features have
come into the operating system,

00:00:42.980 --> 00:00:45.420
and there's a lot of
material in this session.

00:00:45.420 --> 00:00:49.790
As you saw in the keynote,
we have new VPN functionality,

00:00:50.020 --> 00:00:55.140
new enhanced support for IPv6,
and a number of other key features.

00:00:55.240 --> 00:01:04.940
So with that,
I'd like to welcome up Vincent Lubet,

00:01:05.050 --> 00:01:08.370
manager of CoreOS Networking.

00:01:12.820 --> 00:01:13.790
Good morning.

00:01:13.790 --> 00:01:17.800
So this is what we're
going to go through today.

00:01:17.800 --> 00:01:24.800
So we're going to start with a brief
overview of the Mac OS X networking,

00:01:24.800 --> 00:01:29.320
a little bit the architecture,
what's the new features,

00:01:29.430 --> 00:01:33.740
and then we're going to
delve into networking APIs.

00:01:34.190 --> 00:01:39.810
There are a lot of networking APIs,
so it will be relatively high-level,

00:01:39.810 --> 00:01:46.800
just more a list of features, and maybe,
hopefully, you will have some idea which,

00:01:46.800 --> 00:01:50.800
depending on your needs,
which API to use.

00:01:50.800 --> 00:01:56.990
And basically, we have system-level APIs,
and then also framework APIs,

00:01:57.010 --> 00:02:01.310
framework-level,
and Becky will do the second part,

00:02:01.310 --> 00:02:03.800
talking about the frameworks.

00:02:05.290 --> 00:02:09.330
So we have ongoing goals,
and they haven't changed since

00:02:09.330 --> 00:02:10.990
last year and the year before,
I think.

00:02:11.050 --> 00:02:14.950
So the ease of use,
we'd like to have the networking

00:02:14.970 --> 00:02:17.010
be as transparent as possible.

00:02:17.110 --> 00:02:23.510
So one great example is Rendezvous
and other zero-conf effort.

00:02:23.520 --> 00:02:25.550
Performance, also, is very important.

00:02:25.660 --> 00:02:29.370
We have the same kernel
that runs on a laptop,

00:02:29.370 --> 00:02:30.620
run also on an XR.

00:02:30.620 --> 00:02:36.110
So performance and scalability
is an ongoing goal for us.

00:02:36.160 --> 00:02:39.770
Extensibility,
that's a common feature from you,

00:02:39.770 --> 00:02:41.590
from a lot of developers.

00:02:41.730 --> 00:02:43.340
And also standards compliance.

00:02:43.340 --> 00:02:47.310
Whenever we can stick to standards,
we would like to do it.

00:02:47.750 --> 00:02:53.480
So the core of the
networking is in the kernel,

00:02:53.680 --> 00:02:57.440
that Darwin layer,
and basically that where you have

00:02:57.440 --> 00:03:01.700
the Apple Talks stack that is
not used very much these days,

00:03:01.700 --> 00:03:04.700
but also the TCP/IP stack.

00:03:04.700 --> 00:03:08.740
And all of that through the core
services and a lot of framework

00:03:08.740 --> 00:03:11.690
serves the application's environment.

00:03:12.280 --> 00:03:17.840
So, Mac OS X,
the stack is based on FreeBSD.

00:03:17.840 --> 00:03:26.590
Last year, we updated it to FreeBSD 3.7,
I remember, something like that.

00:03:26.590 --> 00:03:26.590
No, 4.

00:03:26.970 --> 00:03:34.190
And so with that,
you get-- so it's a Unix-like--

00:03:34.490 --> 00:03:47.120
The TCP stack includes IPSec and IPv6.

00:03:47.120 --> 00:03:51.670
We introduced that last year already,
so we still have support for Apple Talk,

00:03:51.710 --> 00:03:56.800
a full remote access suite
of protocols based on PPP.

00:03:56.800 --> 00:04:04.060
The stack comes with a
firewall and also NAT daemon.

00:04:04.060 --> 00:04:09.550
The cool stuff we have added to Unix is
this dynamic configuration based on the

00:04:09.550 --> 00:04:15.750
frameworks with plugin architecture,
so that as far as we can,

00:04:15.750 --> 00:04:20.660
we're trying to push the system
so that the configuration

00:04:20.660 --> 00:04:22.880
reconfigures automatically.

00:04:22.880 --> 00:04:27.120
And of course, we have Rendezvous,
and that was the major

00:04:27.150 --> 00:04:29.430
breakthrough of last year.

00:04:29.860 --> 00:04:31.350
So what's new in Painter?

00:04:31.400 --> 00:04:35.470
So more rendezvous-aware
applications and services.

00:04:35.470 --> 00:04:38.350
So if you went to the
Stuart session yesterday,

00:04:38.350 --> 00:04:42.330
you saw a lot more
applications in Painter.

00:04:42.420 --> 00:04:45.790
You have iChat, iTunes, Safari, and more.

00:04:45.800 --> 00:04:49.790
We have also more IPv6-aware
applications and services.

00:04:49.800 --> 00:04:56.970
One of them, so for example, AFP,
the one that you have in Painter,

00:04:56.970 --> 00:04:58.800
runs over IPv6.

00:04:58.910 --> 00:05:01.990
We are introducing also
an IPSec-based VPN,

00:05:01.990 --> 00:05:09.130
802.1X for link layer authentication,
even better support for mobility and

00:05:09.130 --> 00:05:14.800
WebKit and all the Safari framework,
and a lot more.

00:05:14.800 --> 00:05:17.800
So we're going to go
through a little bit.

00:05:17.810 --> 00:05:20.800
So 802.1X is a link layer authentication.

00:05:20.800 --> 00:05:27.800
That means that that's a user
authentication that allows,

00:05:27.800 --> 00:05:33.080
that runs,
before really your link can go up.

00:05:33.080 --> 00:05:37.120
So it's really the...

00:05:38.040 --> 00:05:42.740
coming to be the prevalent
way to secure wireless LANs.

00:05:42.910 --> 00:05:48.480
But it's also used in some
switch environments for ethernet.

00:05:48.480 --> 00:05:53.880
And in Panther, we support a wide range
of authentication methods.

00:05:53.880 --> 00:05:57.990
822.1X is still a young protocol,
so it's not clear which of

00:05:57.990 --> 00:06:01.630
those authentication protocols
will be the prevalent.

00:06:01.640 --> 00:06:05.380
But we support all that list.

00:06:05.380 --> 00:06:12.110
That are the ones that are used by Cisco,
Microsoft, and other vendors.

00:06:12.310 --> 00:06:15.060
The Apple VPN,
so it's a client and server.

00:06:15.190 --> 00:06:21.400
And so we use IPSec to provide
really the secure layers.

00:06:21.400 --> 00:06:25.880
And we use also L2TP for
interoperability.

00:06:25.880 --> 00:06:31.400
L2TP is, in fact,
it's running PPP over UDP.

00:06:31.400 --> 00:06:34.680
And that provides
interoperability with Windows,

00:06:34.680 --> 00:06:37.230
Cisco, and things like that.

00:06:37.240 --> 00:06:41.960
That's really the really the only
standard VPN protocol out there.

00:06:41.960 --> 00:06:48.590
And so we prefer AES for the encryption.

00:06:48.590 --> 00:06:51.000
For those who know the
cryptographic algorithm,

00:06:51.000 --> 00:06:53.000
it's more efficient.

00:06:53.000 --> 00:06:58.600
But we still support triple
DES and other algorithms.

00:06:58.750 --> 00:07:01.080
And we have also added
support for SecureID.

00:07:01.080 --> 00:07:06.430
It's a very popular way to
provide user authentication.

00:07:06.430 --> 00:07:11.160
So I think that's a lot of --
it's deployed in the company.

00:07:11.160 --> 00:07:18.200
But we have also other support, MSCHAP,
V2, and things like that.

00:07:19.550 --> 00:07:25.040
So we have a different
level of networking APIs,

00:07:25.060 --> 00:07:27.520
so that's just a short list.

00:07:27.580 --> 00:07:32.490
And we're going to go through
that in the rest of the session.

00:07:33.400 --> 00:07:36.580
So first,
I'm going to start by the bottom,

00:07:36.580 --> 00:07:39.420
if you like,
that are the system-level APIs.

00:07:39.500 --> 00:07:42.490
It's more or less what
you find in Darwin,

00:07:42.490 --> 00:07:45.260
the open source implementation.

00:07:45.260 --> 00:07:47.480
So I'll start with the BSD Socket.

00:07:47.480 --> 00:07:51.660
So that's the fundamental
APIs for networking.

00:07:51.660 --> 00:07:59.400
Everything else is mostly-- every other
networking API is based on BSD Socket.

00:07:59.400 --> 00:08:05.700
And so that's the one you use to
get the most out of the system.

00:08:05.790 --> 00:08:07.600
That's the raw access to the kernel.

00:08:07.600 --> 00:08:09.800
It's done via Socket.

00:08:09.820 --> 00:08:11.240
So when to use Socket?

00:08:11.240 --> 00:08:12.240
For performance.

00:08:12.240 --> 00:08:17.200
So if you're in server environment,
if you're writing a server application,

00:08:17.200 --> 00:08:17.200
you can use

00:08:18.020 --> 00:08:22.560
You have the insurance to
have the most of the system.

00:08:22.560 --> 00:08:25.000
You have very fine control
of what's happening.

00:08:25.000 --> 00:08:30.280
You have access to all
the low-level controls,

00:08:30.500 --> 00:08:34.000
complete IPsecs, PF and DRV,
and things like that.

00:08:34.000 --> 00:08:36.000
We're going to talk about that.

00:08:36.150 --> 00:08:39.970
And also, BSD, so it brings you Unix
compatibility and portability.

00:08:40.000 --> 00:08:45.000
On Windows, they have WinSocs,
relatively close,

00:08:45.000 --> 00:08:51.460
so often it's a good way
to ensure portability.

00:08:52.070 --> 00:08:55.550
With the BSD Socket comes
the resolver library.

00:08:55.580 --> 00:09:01.080
So it provides name
and address resolution.

00:09:01.080 --> 00:09:05.060
In fact, there are two levels of APIs.

00:09:05.060 --> 00:09:07.240
Some of them work with
other name systems,

00:09:07.240 --> 00:09:10.300
not only the DNS.

00:09:10.300 --> 00:09:11.850
And it goes on and on.

00:09:11.900 --> 00:09:18.920
So with the Socket API, in Panther,
it's been updated to bind line,

00:09:18.920 --> 00:09:21.380
so the latest and greatest.

00:09:21.380 --> 00:09:24.240
And we have also full IPv6 support.

00:09:24.240 --> 00:09:31.980
That means that you can resolve an IPv6
address using the resolver functions.

00:09:31.980 --> 00:09:37.300
But also, you can resolve over V4 and V6.

00:09:37.320 --> 00:09:42.620
So it's the full set.

00:09:43.080 --> 00:09:47.090
So IPv6,
so we implement the standard APIs.

00:09:47.100 --> 00:09:48.090
It's part of Socket.

00:09:48.160 --> 00:09:53.710
It's an extension of
the basic Socket API.

00:09:53.890 --> 00:09:59.060
Something that we turned
off that was a nice--

00:09:59.360 --> 00:10:03.860
Functionality was mapped address that
we're able to use when you were a server.

00:10:03.860 --> 00:10:07.900
You were, for example,
people were using just one socket,

00:10:07.900 --> 00:10:08.820
a V6 socket.

00:10:08.870 --> 00:10:13.940
Because V6 addresses are
larger than V4 addresses,

00:10:13.940 --> 00:10:18.900
with this option of mapped address,
you could have also, receive also V4

00:10:18.940 --> 00:10:21.160
connection on that socket.

00:10:21.160 --> 00:10:26.300
For security reasons,
we disabled that by default.

00:10:26.300 --> 00:10:29.300
It's off, it's not disabled,
but it's off by default.

00:10:29.340 --> 00:10:31.860
Because there are some
security reason implication,

00:10:31.860 --> 00:10:36.730
there are some implementation
out there that in fact,

00:10:37.130 --> 00:10:38.340
We use Tunnel, really.

00:10:38.340 --> 00:10:42.400
It's a way to tunnel v4 in v6,
and sometimes it bypasses firewalls,

00:10:42.400 --> 00:10:44.460
and people are not very happy with that.

00:10:44.490 --> 00:10:47.020
So in Panther, it's by default.

00:10:47.020 --> 00:10:49.460
There's still a socket option,
if you know what you're doing.

00:10:49.460 --> 00:10:50.440
You can use it.

00:10:50.460 --> 00:10:53.380
Mac OS X doesn't tunnel v4 in v6,
but there are other

00:10:53.380 --> 00:10:54.980
implementations that do.

00:10:54.980 --> 00:10:58.540
And so we have the
DNS over IPv6 in Panther.

00:10:59.220 --> 00:11:02.890
And so the idea here is
for application last year,

00:11:02.900 --> 00:11:09.770
we had a full office session
on IPv6 and how to code for

00:11:09.770 --> 00:11:11.220
address family independence.

00:11:11.220 --> 00:11:17.780
It's really easy to write programs
that support both v4 and v6.

00:11:17.780 --> 00:11:23.620
That's why those APIs are standard,
and we encourage you to do that.

00:11:23.780 --> 00:11:29.130
And so one of the great
stuff about v6 is rendezvous.

00:11:29.220 --> 00:11:35.730
We have a team who works over IPv6,
so it's a very easy way to find out

00:11:35.730 --> 00:11:38.880
services and test stuff on the network.

00:11:38.960 --> 00:11:41.990
You don't need to have...

00:11:42.430 --> 00:11:45.610
With IPv6,
you don't need to have an infrastructure.

00:11:45.620 --> 00:11:49.810
V6 automatically configure addresses,
link local addresses

00:11:49.890 --> 00:11:52.620
on all the interfaces,
so you can find services.

00:11:52.660 --> 00:11:57.270
It works perfectly with
multi-owned system.

00:11:57.920 --> 00:12:03.200
IPSec provides IP-level
security from within the kernel,

00:12:03.240 --> 00:12:04.840
the bottom of the stack.

00:12:04.930 --> 00:12:12.070
So we support a bunch of... There are
a number of APIs to set those security

00:12:12.200 --> 00:12:14.540
policy and association database.

00:12:14.540 --> 00:12:19.740
Those are the kind of the
filters that tells you what

00:12:19.790 --> 00:12:23.290
traffic to encrypt using IPSec.

00:12:23.680 --> 00:12:26.290
There's the PFK socket.

00:12:27.400 --> 00:12:30.080
IPSec set policy,
it's a library function.

00:12:30.080 --> 00:12:33.020
And also you can have
a per-socket control.

00:12:33.150 --> 00:12:38.160
So we saw a few, already a few in Jaguar,
a few application,

00:12:38.210 --> 00:12:40.350
third-party application using IPSec.

00:12:40.450 --> 00:12:46.720
So the new thing is that in Panther,
we're also using IPSec for our VPN.

00:12:46.770 --> 00:12:53.850
So there is something that is...
Something to remember is that this is

00:12:53.850 --> 00:12:56.900
a single shared system-wide resource.

00:12:56.900 --> 00:13:01.900
So, and it's managed by the
internet key exchange,

00:13:01.900 --> 00:13:06.900
the one, the protocol that exchange
the keys managed by a single

00:13:06.900 --> 00:13:08.360
daemon called Raccoon.

00:13:08.400 --> 00:13:10.580
And so it's a single resource.

00:13:10.580 --> 00:13:18.000
So please, if you use IPSec,
make sure you don't override preferences

00:13:18.000 --> 00:13:20.060
or settings from other applications.

00:13:20.060 --> 00:13:24.140
And we've added also
Net Traversal in Panther.

00:13:24.140 --> 00:13:27.640
That's something that really,
in this data, in these days,

00:13:27.640 --> 00:13:29.780
with that is prevalent.

00:13:29.780 --> 00:13:31.520
And so we support that.

00:13:31.630 --> 00:13:34.400
That's the, it's not yet a standard.

00:13:34.400 --> 00:13:41.450
It's still a ITF draft,
but that's what we, that's the best,

00:13:41.450 --> 00:13:41.450
that's the best solution.

00:13:41.690 --> 00:13:48.040
That's the way to traverse NAT with IPSec
that's most likely to be interoperable,

00:13:48.040 --> 00:13:49.600
although it's not yet a standard.

00:13:49.600 --> 00:13:56.600
So we have an IP firewall that
works also with IPv6 in Panther.

00:13:56.600 --> 00:14:01.600
And again,
just like with IPSec and Raccoon,

00:14:01.600 --> 00:14:04.600
it's a single system-wide resource.

00:14:04.600 --> 00:14:08.400
So with IPSec,
you can define filters and actions

00:14:08.400 --> 00:14:10.600
to do on certain types of packets.

00:14:10.600 --> 00:14:13.600
But just remember it's a single,
wide resource.

00:14:13.600 --> 00:14:18.910
And just like, so for example,
you've certainly noticed that the

00:14:18.910 --> 00:14:24.870
built-in firewall will not turn
itself on if it detects there

00:14:24.870 --> 00:14:26.600
are other rules on the system.

00:14:26.600 --> 00:14:34.550
So be nice and don't overwrite
other people's rules.

00:14:34.600 --> 00:14:39.070
Or you can ask the user
if he wants to flush.

00:14:39.270 --> 00:14:43.200
There are two ways to
control the firewall:

00:14:43.200 --> 00:14:48.990
a command line, a PFW,
and also just straight socket options.

00:14:51.110 --> 00:14:59.750
PFND RV Sockets are sockets that allow
us to write user space protocols.

00:14:59.750 --> 00:15:05.150
That means that's a facility
we have in the kernel,

00:15:05.150 --> 00:15:11.520
using these types of sockets,
to send raw Ethernet

00:15:11.520 --> 00:15:14.500
frames up to user space.

00:15:14.750 --> 00:15:19.490
And we use that with 822.1X.

00:15:19.500 --> 00:15:22.000
It's an Ethernet protocol, in fact.

00:15:22.220 --> 00:15:27.990
And so that's a great way
to stay out of the kernel.

00:15:28.000 --> 00:15:33.720
And it's also used to implement
other protocol stacks that are

00:15:33.720 --> 00:15:40.000
maybe specific for an application
like DECNIC or IPX and others.

00:15:40.000 --> 00:15:43.990
There are other solutions
that you also can be used.

00:15:44.060 --> 00:15:49.000
It can be used instead of PFND RV Sockets
also to implement user space protocol.

00:15:49.000 --> 00:15:54.000
Those are listed to the diverged
sockets that work with the firewall.

00:15:54.000 --> 00:15:58.000
And NBPF, the Berkeley Packet Filter.

00:15:58.090 --> 00:15:59.380
So...

00:16:00.820 --> 00:16:07.690
We, given the state of the internal
API for network kernel extensions,

00:16:08.010 --> 00:16:13.800
we really like, if possible,
that you implement your

00:16:13.830 --> 00:16:17.500
protocol in user space,
if possible,

00:16:17.500 --> 00:16:23.800
so that you can be sure that there's no
problem of compatibility in the future.

00:16:23.960 --> 00:16:28.940
So let's talk about the problem, I mean,
the network kernel extension.

00:16:28.940 --> 00:16:37.190
So today, the NKEs are tied to the
kernel implementation.

00:16:37.320 --> 00:16:40.700
So we cannot really say
that we have an API.

00:16:40.700 --> 00:16:47.020
It's really-- we provide hooks
where extensions can really

00:16:47.020 --> 00:16:48.760
get to the internal mechanism.

00:16:48.830 --> 00:16:50.530
That's fragile.

00:16:50.630 --> 00:16:51.360
It's going to break.

00:16:51.400 --> 00:16:52.620
It broke in the past.

00:16:52.620 --> 00:16:57.900
And every time we implement a fix,
for example,

00:16:57.900 --> 00:17:01.610
or want to improve performance,
we have to think about,

00:17:01.630 --> 00:17:06.220
is this going to break a
third-party kernel extension?

00:17:06.230 --> 00:17:12.670
So if you came to the session
about the kernel yesterday morning,

00:17:12.670 --> 00:17:19.460
you're certainly aware that we
are working on a new API that will

00:17:19.460 --> 00:17:24.620
isolate extensions from the internal
implementation of the kernel.

00:17:24.630 --> 00:17:26.580
And it's not yet ready.

00:17:26.660 --> 00:17:27.550
It's underway.

00:17:27.560 --> 00:17:33.080
And we certainly like your
participation and feedback,

00:17:33.080 --> 00:17:38.900
because we're going to do certainly
some drastic change in there.

00:17:40.490 --> 00:17:41.640
System configuration.

00:17:41.640 --> 00:17:44.960
So that's the foundation
for our mobility solution.

00:17:44.960 --> 00:17:52.460
And it's based on a daemon
and a couple of set of APIs.

00:17:52.480 --> 00:17:58.560
So we have a set of
APIs to manage preferences.

00:17:58.560 --> 00:18:03.740
That's the one that I use, for example,
by the network preference panel.

00:18:03.740 --> 00:18:09.600
So those are system-wide,
local preference for this host.

00:18:10.400 --> 00:18:16.640
And we have also an API to get the status
about the state of some parameters.

00:18:16.640 --> 00:18:21.280
So that's the basis for
the dynamic behavior.

00:18:21.280 --> 00:18:26.790
So there are notifications when
there's a change in the state of

00:18:26.790 --> 00:18:31.120
some data or key or the preference.

00:18:31.120 --> 00:18:38.140
And they are used today also by a
lot of third-party applications,

00:18:38.190 --> 00:18:42.610
for example, ISPs,
ones who provide their own dialers.

00:18:42.640 --> 00:18:43.680
They use that.

00:18:43.680 --> 00:18:45.200
And also application.

00:18:45.200 --> 00:18:53.600
That's how they can dynamically react
to a networking change using the status.

00:18:53.770 --> 00:18:56.710
And it's used, for example,
by Mail and Safari.

00:18:56.710 --> 00:19:00.880
And also it's the basis
for the dial-on-demand.

00:19:02.160 --> 00:19:07.360
So what applications they use usually,
so the preference API I just

00:19:07.360 --> 00:19:11.440
talked about are more used
to manage the configuration,

00:19:11.440 --> 00:19:18.100
but we have an API called the
ASC Network Catchability API that

00:19:18.100 --> 00:19:25.100
allows to check whether a set of maybe
NAM addresses or pair of addresses,

00:19:25.100 --> 00:19:29.820
NAM in Panther, are reachable.

00:19:29.820 --> 00:19:36.700
Rich Ability, it's not a guarantee that,
for example, the distant host is,

00:19:36.700 --> 00:19:39.090
you can really connect to a distant host.

00:19:39.120 --> 00:19:43.270
But what it says is that
from the standpoint of the

00:19:43.270 --> 00:19:48.220
system locally on the machine,
there's an IP address, a router is there,

00:19:48.220 --> 00:19:50.900
maybe there's also a
DNS server configured.

00:19:50.900 --> 00:19:57.900
And so it's this API, so Unify,
a set of information, you know,

00:19:57.900 --> 00:19:59.540
it gives you a synthetic view of it.

00:19:59.820 --> 00:20:02.190
Um...

00:20:03.120 --> 00:20:06.590
So when to use SC Network Catchability?

00:20:06.650 --> 00:20:13.460
So just to tell you if you have a
chance to connect to the server.

00:20:13.460 --> 00:20:18.180
Maybe the server is-- so it will
not tell you if there's a firewall,

00:20:18.180 --> 00:20:21.140
if you have a problem with
NAT or things like that,

00:20:21.150 --> 00:20:23.480
things outside of the
control of the system.

00:20:23.480 --> 00:20:28.600
But at least it can tell you the
system is properly configured.

00:20:28.730 --> 00:20:32.340
So when there are
changes in connectivity,

00:20:32.340 --> 00:20:36.480
that's you have the chance to clean up,
and maybe to provide some

00:20:36.480 --> 00:20:38.390
feedback to the user.

00:20:38.510 --> 00:20:44.220
For example,
CFSocketStream use that on every socket.

00:20:44.220 --> 00:20:49.510
Becky's going to talk about the
CFSocket API a little bit later,

00:20:49.510 --> 00:20:55.380
but our own frameworks use
this API as its base API.

00:20:57.580 --> 00:21:01.590
So something new in Panter that works,
in fact, with the reachability API is

00:21:01.670 --> 00:21:06.380
the SC Network Connection API.

00:21:06.380 --> 00:21:11.980
This is the API that enables dial-on
demand from within the application.

00:21:11.980 --> 00:21:20.860
And it's similar to the OTPP remote
access API we had on Mac OS 7 and 8.9.

00:21:20.880 --> 00:21:25.700
So the idea-- so today,
what we have is really something that

00:21:25.790 --> 00:21:27.660
we call at Apple dial-on traffic.

00:21:27.660 --> 00:21:34.540
So if you enable that preference in PPP,
the PPP, every time it sees that

00:21:34.540 --> 00:21:40.100
some data is to be sent,
it will dial the modem.

00:21:40.260 --> 00:21:42.620
And that's the cause
of a lot of complaints,

00:21:42.620 --> 00:21:46.490
because it's the system dials
at the most unopportune times.

00:21:46.650 --> 00:21:53.140
So what we want to do is, instead,
with having this new API,

00:21:53.140 --> 00:21:56.860
to enable application developers
to-- to be in control.

00:21:56.860 --> 00:22:00.320
And they can decide or
maybe prompt the user.

00:22:00.400 --> 00:22:02.970
So I need to get on the network.

00:22:02.980 --> 00:22:05.340
Do you want me-- this request to dial.

00:22:05.340 --> 00:22:06.240
Do you want me to dial?

00:22:06.240 --> 00:22:07.400
Yes, no.

00:22:07.400 --> 00:22:10.780
And so, for example,
it's great for male clients.

00:22:10.780 --> 00:22:17.440
And also, that's the same API that is
used not only for application,

00:22:17.440 --> 00:22:21.700
but also for dialers also,
with different set of parameters.

00:22:21.700 --> 00:22:25.340
Internet Connect,
our own Internet Connect in Panter,

00:22:25.340 --> 00:22:27.300
uses this API.

00:22:27.360 --> 00:22:32.060
So really,
we would like you to adopt this API.

00:22:32.100 --> 00:22:36.580
So I put together this
little sample code.

00:22:36.580 --> 00:22:41.880
It's just to show you how simple it is.

00:22:42.110 --> 00:22:46.340
So, for example,
this is how to tell if you want to,

00:22:46.340 --> 00:22:51.770
for example, to access www.apple.com,
what you would do, you would call

00:22:51.780 --> 00:22:59.850
sc_network_hability_create_with_name,
so where you pass the server name,

00:22:59.960 --> 00:23:07.780
and then you specify a
callback for this reference,

00:23:07.800 --> 00:23:11.170
you get back a reference,
and you specify your callback.

00:23:11.220 --> 00:23:15.540
So when there's an event that
happens for the change in the

00:23:15.540 --> 00:23:20.340
reachability of www.apple.com,
your callback will be called.

00:23:20.350 --> 00:23:24.550
And you just schedule
it with your run loop,

00:23:24.550 --> 00:23:29.380
so it was great for applications
above the BSD layer,

00:23:29.380 --> 00:23:32.520
let's say, and you just run the run loop.

00:23:32.670 --> 00:23:36.320
And then this is the
reachability callback.

00:23:36.370 --> 00:23:40.340
When you get an event, basically,

00:23:41.730 --> 00:23:47.120
The major event is the
flag that tells you.

00:23:47.120 --> 00:23:50.500
It's a set of flags you get,
but the one that's really interesting

00:23:50.570 --> 00:23:52.510
here is whether it's reachable or not.

00:23:52.520 --> 00:23:57.310
There are sub-flags,
and one tells you if a

00:23:57.310 --> 00:24:00.480
connection is required.

00:24:00.480 --> 00:24:07.120
And now in Panther,
if the server -- so if you

00:24:07.120 --> 00:24:13.590
need to start a connection,
you just have to use the connection API.

00:24:14.140 --> 00:24:19.600
And the Start Connection API,
usually when you are not a dialer,

00:24:19.600 --> 00:24:25.640
you just want to use the default,
certainly the most current connection

00:24:25.640 --> 00:24:27.870
the user did with Internet Connect.

00:24:28.060 --> 00:24:36.750
So you just tell the user,
just copy the current preference,

00:24:36.750 --> 00:24:42.780
and you tell the system to
create a reference again,

00:24:42.780 --> 00:24:47.160
because that's kind of the hook,
the endpoint that you will use.

00:24:47.160 --> 00:24:55.530
And again, it's an event-based mechanism,
so you schedule in the run loop,

00:24:55.940 --> 00:25:00.610
to to be ready to receive event and
then you you call the the start and

00:25:00.620 --> 00:25:06.110
you release the stuff you you don't
need and again when there's an event

00:25:06.110 --> 00:25:11.000
on the on the connections you're being
called back and here the the main event

00:25:11.000 --> 00:25:16.790
you you have it's very similar to the
remote access api and it's just so if

00:25:16.830 --> 00:25:23.430
it's disconnected connecting connected
disconnecting and in case of error you

00:25:23.430 --> 00:25:32.280
get invalid but and when you're done you
close the connection so the one point

00:25:32.280 --> 00:25:39.980
in the in this api the the connection as
are raf counted that means that the idea

00:25:39.980 --> 00:25:45.930
is that the when the the connect when
your application doesn't doesn't need

00:25:45.930 --> 00:25:53.080
to to use the the system certainly you
would like to the the modem to disconnect

00:25:53.240 --> 00:25:57.710
so you just release the connection if
there was another application using

00:25:57.710 --> 00:26:01.720
the connection it will still hold
the reference on the connection so

00:26:01.720 --> 00:26:07.160
the it's on the on the last reference
that the connection will be turned on

00:26:07.390 --> 00:26:14.780
And with that, I'd like to... Oh, no,
one more thing.

00:26:14.860 --> 00:26:18.140
Last but not least,
that was my... It's the

00:26:18.140 --> 00:26:24.160
DNS Service Discovery API,
so those are the rendezvous APIs.

00:26:24.180 --> 00:26:28.990
There was a session yesterday about...

00:26:29.230 --> 00:26:32.720
Oh, something is wrong here.

00:26:32.720 --> 00:26:36.700
The session is not kernel programming,
but that's the Rendezvous API.

00:26:36.700 --> 00:26:38.100
It's 102.

00:26:38.230 --> 00:26:42.100
So the NAN service discovery APIs are
the foundation for Rendezvous,

00:26:42.100 --> 00:26:48.100
and you have sets of APIs to
register NAN services.

00:26:48.100 --> 00:26:51.100
Also an API to browse for services.

00:26:51.100 --> 00:26:56.090
Rendezvous is really
something for end users.

00:26:56.100 --> 00:26:57.830
So that's the idea,
is that the end user will

00:26:57.830 --> 00:26:59.090
pick and choose a service.

00:26:59.100 --> 00:27:06.190
It's not so great for
background connections,

00:27:06.190 --> 00:27:09.100
because really the idea
is that the user chooses,

00:27:09.100 --> 00:27:12.100
browse something,
and just remember the name.

00:27:12.100 --> 00:27:15.090
And then when it's time to
connect to that service,

00:27:15.140 --> 00:27:20.470
you have an API to resolve,
and the service into an address on

00:27:20.470 --> 00:27:25.100
the port you can use in subsequent,
for example, Socket score.

00:27:25.430 --> 00:27:33.100
We have three API flavors,
depending what level your application,

00:27:33.100 --> 00:27:36.100
what type of API your
application is using.

00:27:36.100 --> 00:27:39.070
So we have the DNS service discovery API.

00:27:39.100 --> 00:27:41.070
It's a system-level API.

00:27:41.090 --> 00:27:43.090
That's the foundation for the other ones.

00:27:43.100 --> 00:27:47.100
In CF Network,
there's the CFNet services.

00:27:47.100 --> 00:27:50.390
So if you have a run loop,
it certainly could be

00:27:50.390 --> 00:27:52.810
the natural way to use.

00:27:53.110 --> 00:27:54.090
And in Cocoa, there's NSNet services.

00:27:54.100 --> 00:27:57.100
That works for Cocoa.

00:27:57.100 --> 00:28:01.090
It's Objective-C.

00:28:01.110 --> 00:28:06.100
And now with that,
I'd like to introduce Bikki Woolrich,

00:28:06.110 --> 00:28:09.100
who's going to talk about frameworks.

00:28:14.480 --> 00:28:16.100
Thanks, Vincent.

00:28:16.100 --> 00:28:20.900
So Vincent has taken you through the
basic feature set of what's available

00:28:20.900 --> 00:28:23.850
direct from the Darwin system,
what's available at the

00:28:23.940 --> 00:28:25.160
Berkeley Sockets layer.

00:28:25.160 --> 00:28:28.990
And what I'm going to do now is talk
about what we've built on top of that

00:28:29.130 --> 00:28:31.740
into the framework layers above it.

00:28:32.770 --> 00:28:35.600
So I was thinking about
how to prepare this talk,

00:28:35.720 --> 00:28:38.560
and it seemed with the
introduction of Safari 1.0,

00:28:38.620 --> 00:28:43.600
the best way to look at those APIs was
to look at what Safari has built upon.

00:28:43.600 --> 00:28:45.380
And that's how we're going to start out.

00:28:45.430 --> 00:28:47.260
After that,
I'm going to talk briefly about

00:28:47.260 --> 00:28:50.720
some of the other networking
technologies on the system.

00:28:50.810 --> 00:28:52.830
And finally,
I'm going to give you some tips and

00:28:52.900 --> 00:28:58.740
hints on how you can transition off
some of the older Mac OS 9-based APIs.

00:29:00.530 --> 00:29:04.560
So let's talk for a moment
about the Safari technologies.

00:29:04.560 --> 00:29:07.270
When we started writing Safari, we,
of course,

00:29:07.280 --> 00:29:12.410
built on the technologies we already
had built on top of the existing APIs.

00:29:12.740 --> 00:29:16.900
But we also discovered a lot of
places where those APIs were lacking.

00:29:16.900 --> 00:29:19.600
And so we developed many
new APIs at the same time.

00:29:19.600 --> 00:29:22.440
And now we've made those
APIs available to you.

00:29:22.440 --> 00:29:24.280
That's part of the Safari SDK.

00:29:24.280 --> 00:29:28.100
As you've already heard from the keynote,
those APIs are available on any

00:29:28.100 --> 00:29:34.630
Panther system and on any Jaguar system,
provided Safari 1.0 has been installed.

00:29:34.640 --> 00:29:38.910
And I do not have enough time to
go into those APIs in great detail.

00:29:39.130 --> 00:29:41.840
So I'm going to point you to
some other sessions as we go,

00:29:41.840 --> 00:29:44.790
including session 403,
which took place on Tuesday.

00:29:44.800 --> 00:29:48.200
But when you get the DVDs,
you can take a look at it.

00:29:48.200 --> 00:29:52.240
Don Melton gave a pretty good overview
of all of those APIs in greater detail

00:29:52.240 --> 00:29:54.700
than I'm going to have time for.

00:29:55.620 --> 00:29:57.740
So what goes into Safari?

00:29:57.860 --> 00:29:59.970
It's on Mac OS X,
so you know the core of the

00:29:59.970 --> 00:30:02.300
networking has to be BSD Sockets.

00:30:02.390 --> 00:30:06.160
But there's a lot of stuff between
Sockets and what ultimately

00:30:06.160 --> 00:30:08.610
is the Safari application.

00:30:09.380 --> 00:30:13.460
And the first layer in that
stack is Core Foundation.

00:30:13.480 --> 00:30:16.130
Now, Core Foundation provides a couple
different important things.

00:30:16.160 --> 00:30:18.800
It's not really a
networking library per se,

00:30:18.840 --> 00:30:21.690
but it provides a couple
basic abstractions for us.

00:30:21.800 --> 00:30:23.660
First and foremost, the run loop.

00:30:23.750 --> 00:30:28.020
The run loop is how all of the
different interesting events inside an

00:30:28.020 --> 00:30:32.640
application get funneled into a single
callback mechanism on our system.

00:30:32.720 --> 00:30:35.080
So if you look at
NSRunLoop or Carbon Events,

00:30:35.120 --> 00:30:38.540
that's how user events
ultimately are transmitted.

00:30:38.560 --> 00:30:42.000
And it provides our basic
asynchrony mechanism.

00:30:42.340 --> 00:30:47.060
CFURLs, Basic Abstraction for URL,
Pure Data Type.

00:30:47.060 --> 00:30:49.900
And those two kind of come
together with CF Socket,

00:30:50.000 --> 00:30:53.280
which provides a way to take a socket,
a file descriptor,

00:30:53.300 --> 00:30:55.280
and connect it into the run loop.

00:30:55.360 --> 00:30:58.370
So rather than having to manage
a select loop yourself or a

00:30:58.480 --> 00:31:02.290
file descriptor set yourself,
you can use CF Socket to get that

00:31:02.290 --> 00:31:06.290
input managed in the same way that all
of the other user events are managed.

00:31:06.300 --> 00:31:08.870
CF Socket can handle
literally any socket.

00:31:08.870 --> 00:31:12.570
It works with most file descriptors, too,
but we only promise it

00:31:12.570 --> 00:31:14.300
with every true socket.

00:31:14.300 --> 00:31:20.820
That includes UDP sockets,
as well as server-side accept sockets.

00:31:21.170 --> 00:31:24.080
Built on top of CFSocket is CFStream.

00:31:24.220 --> 00:31:27.460
CFStream is just a basic
stream abstraction.

00:31:27.460 --> 00:31:30.980
You get a stream, you open it,
you read it, eventually you close it.

00:31:31.110 --> 00:31:34.100
If you're unlucky,
it errored out somewhere along the way.

00:31:34.100 --> 00:31:37.540
It's hooked into the run loop so
that it can signal the client,

00:31:37.590 --> 00:31:40.590
your application,
whenever bytes are available or

00:31:40.590 --> 00:31:43.070
something interesting has happened.

00:31:43.530 --> 00:31:48.070
However, because it's a stream-based API,
it only really works with TCP sockets.

00:31:48.110 --> 00:31:51.620
It doesn't make much sense
to talk about a stream for an

00:31:51.620 --> 00:31:54.500
accept socket or a UDP socket.

00:31:56.500 --> 00:31:58.610
So that's Core Foundation.

00:31:58.830 --> 00:32:01.900
If you take a step up
from Core Foundation,

00:32:01.900 --> 00:32:04.140
we get to CF Network.

00:32:05.860 --> 00:32:09.840
CFNetwork is the library on
our system that provides the

00:32:09.840 --> 00:32:12.140
basic protocol implementations.

00:32:12.140 --> 00:32:14.270
This is where our HTTP stack lives.

00:32:14.560 --> 00:32:16.790
This is where the FTP stack lives.

00:32:16.810 --> 00:32:21.520
CFNetwork itself does not actually
provide the SSL implementation,

00:32:21.520 --> 00:32:24.690
but it provides all the
hooks into SSL and TLS.

00:32:24.800 --> 00:32:27.800
So if you've got a socket stream,
you want to make it secure,

00:32:27.800 --> 00:32:31.780
CFNetwork provides the hooks to
run SSL over the socket stream.

00:32:32.450 --> 00:32:34.330
Finally, Rendezvous.

00:32:34.540 --> 00:32:41.280
Vincent mentioned CFNet Services,
which is the API that CFNetwork

00:32:41.280 --> 00:32:45.280
provides for accessing Rendezvous.

00:32:46.980 --> 00:32:50.590
The basic goal besides
CF Network is to provide you with

00:32:50.710 --> 00:32:55.340
those protocol implementations
and hook them into the run loop.

00:32:55.400 --> 00:32:59.750
However, our goal with CF Network was not
to be the most convenient API.

00:32:59.820 --> 00:33:03.000
There are higher-level APIs that
provide that convenience.

00:33:03.010 --> 00:33:06.400
At this level,
we're trying to give you full control.

00:33:06.580 --> 00:33:11.400
What that means is that all the
protocol details are fully exposed.

00:33:11.400 --> 00:33:13.380
So,
there's a lot of power implied with that.

00:33:13.490 --> 00:33:16.380
There's nothing you can do with HTTP,
for instance,

00:33:16.450 --> 00:33:18.400
that you cannot do through CF Network.

00:33:18.400 --> 00:33:21.890
But, on the other hand,
you better know HTTP or the

00:33:21.890 --> 00:33:25.990
CF Network APIs aren't going
to make a lot of sense to you.

00:33:26.220 --> 00:33:29.400
Other ways we give you full control:
At the CF Network layer,

00:33:29.400 --> 00:33:33.860
you have complete control over precisely
when the reads and writes are done.

00:33:34.000 --> 00:33:37.020
Again, this can be a pain if you're not
actually interested in the details,

00:33:37.060 --> 00:33:40.360
but if you need that control,
this is the layer to get it at.

00:33:40.520 --> 00:33:43.890
Likewise, the threading policy:
We do not dictate a threading

00:33:43.890 --> 00:33:45.730
policy for you at this level.

00:33:45.870 --> 00:33:49.030
At higher levels,
we'll see some APIs that will

00:33:49.030 --> 00:33:52.190
actually take care of spawning
background threads for you,

00:33:52.320 --> 00:33:54.960
for instance, but not at this level.

00:33:57.010 --> 00:33:59.800
A couple things new in
CF Network with Panther:

00:33:59.800 --> 00:34:01.850
We've added DNS host resolution.

00:34:01.880 --> 00:34:06.680
This is asynchronous host resolution,
so you can start a request to look up

00:34:06.850 --> 00:34:11.610
the address of yahoo.com or anything,
and you'll get a callback

00:34:11.610 --> 00:34:14.830
later on telling you when
that address is available.

00:34:15.440 --> 00:34:28.350
We've also added FTP support
inside CF Network.

00:34:28.350 --> 00:34:28.350
For more information about CF Network,
come to session 112 tomorrow

00:34:28.350 --> 00:34:28.350
afternoon at 5:00 PM.

00:34:30.120 --> 00:34:34.500
Yeah, okay, last talk of the conference,
but what do you want?

00:34:34.500 --> 00:34:38.000
Okay,
so what do we have above CF Network?

00:34:38.190 --> 00:34:41.170
Well,
I mentioned some convenience APIs that do

00:34:41.170 --> 00:34:43.980
not expose as many of the details to you.

00:34:44.090 --> 00:34:48.810
That's what these new
Foundation URL APIs are all about.

00:34:50.430 --> 00:34:53.680
So, new set of APIs in Panther.

00:34:53.730 --> 00:34:56.110
It's a full-featured
set of URL loading APIs,

00:34:56.140 --> 00:34:58.490
and here,
the point is for the API to be as

00:34:58.600 --> 00:35:00.770
convenient and abstract as possible.

00:35:00.800 --> 00:35:04.180
So, the policy is to make most
of the choices for you.

00:35:04.300 --> 00:35:07.140
Does that mean that you
can't modify those choices

00:35:07.240 --> 00:35:09.160
if you want an unusual setup?

00:35:09.280 --> 00:35:10.790
No, of course you can.

00:35:10.800 --> 00:35:13.440
But the policy is going to
be to start out by making the

00:35:13.440 --> 00:35:16.070
most common decision for you,
and then you kind of have

00:35:16.150 --> 00:35:17.290
to undo those decisions.

00:35:17.330 --> 00:35:20.920
Whereas at CF Network,
the policy was that you have to apply

00:35:20.920 --> 00:35:23.700
each and every policy decision yourself.

00:35:24.220 --> 00:35:27.420
The API is asynchronous,
building on the run loop, of course.

00:35:27.440 --> 00:35:29.070
It's basically callback-based.

00:35:29.120 --> 00:35:31.510
If you're familiar with
the Cocoa API paradigms,

00:35:31.610 --> 00:35:34.100
we do it via delegates.

00:35:34.100 --> 00:35:38.100
And at this level,
we add extensibility via subclassing.

00:35:38.100 --> 00:35:41.100
So if you've got to have the
Gopher scheme implementation,

00:35:41.100 --> 00:35:44.290
we don't provide it for you,
but there's a class you can subclass to

00:35:44.290 --> 00:35:49.760
implement it yourself and get it plugged
into the entire URL loading system.

00:35:50.090 --> 00:35:52.680
And again,
it's part of the Foundation library,

00:35:52.770 --> 00:35:57.400
so it's built right into the core
and available to you at that layer.

00:35:57.500 --> 00:36:02.100
And for more information about these,
go to session 418 this afternoon,

00:36:02.230 --> 00:36:05.750
where we'll be talking about these
APIs in much greater depth than

00:36:05.760 --> 00:36:07.720
I'll have time to go into here.

00:36:07.960 --> 00:36:10.380
But just to give you
a flavor for the API,

00:36:10.490 --> 00:36:12.770
here are the basic abstractions.

00:36:12.840 --> 00:36:15.570
You start out by creating
an NSURL request.

00:36:15.610 --> 00:36:18.400
This encapsulates everything,
all the information needed

00:36:18.500 --> 00:36:20.790
to configure a URL download.

00:36:20.950 --> 00:36:23.550
So the URL itself,
if you have a custom user

00:36:23.550 --> 00:36:26.890
agent and you're doing HTTP,
you can set it there.

00:36:27.000 --> 00:36:29.900
Proxy settings,
all of that goes into the request.

00:36:29.930 --> 00:36:33.900
Once you've got a request,
you build a connection from the request.

00:36:33.900 --> 00:36:35.890
The connection represents
the ongoing download.

00:36:35.890 --> 00:36:37.890
The connection has a delegate.

00:36:37.900 --> 00:36:40.900
That's the NSURL connection delegate.

00:36:40.930 --> 00:36:44.650
And you use that to get information
about how your connection,

00:36:44.740 --> 00:36:46.890
how the download is proceeding.

00:36:46.900 --> 00:36:50.250
Finally, what you're going to get back
from the delegate is the data,

00:36:50.300 --> 00:36:53.900
of course,
but also an NSURL response object

00:36:53.900 --> 00:36:57.900
that encapsulates everything that's
not actually part of the data.

00:36:57.900 --> 00:37:01.030
So that includes things
like the MIME type,

00:37:01.030 --> 00:37:03.770
like the HTTP headers that came back.

00:37:05.920 --> 00:37:10.170
And then I just want to highlight
briefly the other features that are

00:37:10.230 --> 00:37:13.450
built into the Foundation URL APIs.

00:37:13.500 --> 00:37:15.970
I've listed each and every class here,
but I'm just going to talk

00:37:16.000 --> 00:37:18.900
about the major bullet points
to explain the features.

00:37:18.940 --> 00:37:22.400
Caching happens
automatically with this API.

00:37:22.400 --> 00:37:26.890
There's both an on-disk and
in-memory cache available and used.

00:37:26.900 --> 00:37:30.700
Cookie storage and management,
all handled automatically,

00:37:30.800 --> 00:37:34.010
all shared for a given user
across all applications,

00:37:34.010 --> 00:37:37.890
unless there are preferences to change
whether your particular cookie is stored.

00:37:37.900 --> 00:37:40.740
But by default,
they'll be stored so that all

00:37:40.740 --> 00:37:42.900
applications can access them.

00:37:42.900 --> 00:37:46.800
Authentication and credential management,
we've got a bunch of classes built

00:37:46.800 --> 00:37:49.710
in so that you can know exactly
who's asking for a password,

00:37:50.090 --> 00:37:53.900
whether there's a password already
available on the system for your use,

00:37:53.900 --> 00:37:55.860
and give you everything you need so
you can prompt the user in your system.

00:37:55.910 --> 00:37:58.880
So you can prompt the user and
get that password if necessary.

00:37:58.900 --> 00:38:01.860
And finally,
the extensibility I mentioned.

00:38:01.900 --> 00:38:04.900
So there's a class available,
NSURL protocol,

00:38:04.900 --> 00:38:08.980
that you can subclass if you
want to add your own particular

00:38:08.980 --> 00:38:10.890
scheme that we do not provide.

00:38:13.630 --> 00:38:16.670
So that takes us all the way
through the URL loading APIs.

00:38:16.820 --> 00:38:20.150
The last piece, of course, is WebKit.

00:38:20.950 --> 00:38:22.300
WebKit is new in Panther.

00:38:22.300 --> 00:38:24.800
It's a brand-new public framework.

00:38:24.800 --> 00:38:28.800
And this is the layer that actually
does all the rendering and navigation.

00:38:28.800 --> 00:38:32.790
So it's what actually draws to the
screen and interprets the user events,

00:38:32.800 --> 00:38:36.600
as the user clicks or moves
throughout the document.

00:38:36.740 --> 00:38:40.940
It's a fully-pluggable architecture,
so that you can support rendering

00:38:40.940 --> 00:38:42.790
new kinds of document types.

00:38:42.890 --> 00:38:48.540
We, of course, handle HTML text and the
image types out of the box.

00:38:48.620 --> 00:38:51.630
But in fact,
we provide sample code in the

00:38:51.630 --> 00:38:56.830
SDK that shows how you would extend
WebKit to be able to display PDFs.

00:38:57.480 --> 00:39:01.900
It's an Objective-C API fully
integrated with the AppKit classes.

00:39:01.910 --> 00:39:06.400
So, in fact, the central class WebView is
a subclass of NSView.

00:39:06.580 --> 00:39:10.820
The SDK also provides a bunch of example
code that shows how you can take that

00:39:10.820 --> 00:39:15.740
WebView and use it from a pure C or
C++ API and integrate it fully with

00:39:15.740 --> 00:39:18.400
Carbon HI views and Carbon events.

00:39:18.590 --> 00:39:22.310
For more information about that,
there's a session tomorrow sometime,

00:39:22.310 --> 00:39:26.610
I'm not sure when, but session 420,
they're going to go into the

00:39:26.610 --> 00:39:28.400
WebKit APIs in much greater detail.

00:39:30.470 --> 00:39:31.370
And that's the full stack.

00:39:31.500 --> 00:39:35.770
That's what goes into the
networking portion of Safari.

00:39:38.180 --> 00:39:42.500
So now I'm going to touch briefly on
these three other networking APIs:

00:39:42.600 --> 00:39:46.290
Web Services, NS Stream,
and Launch Services.

00:39:46.910 --> 00:39:50.380
Web Services is a framework
we introduced in Jaguar.

00:39:50.520 --> 00:39:55.800
It provides APIs for issuing
an XML RPC or a SOAP request.

00:39:55.800 --> 00:39:59.770
In Jaguar,
the API was very focused on the client,

00:39:59.800 --> 00:40:01.930
so if you were a client and
wanted to issue such a request and

00:40:01.990 --> 00:40:06.780
receive a response from the server,
we had APIs for that.

00:40:06.830 --> 00:40:09.270
But starting in Panther,
we've added support for

00:40:09.410 --> 00:40:12.060
server-side operations,
so if you're on the other side

00:40:12.060 --> 00:40:14.790
of the equation and need to
interpret an incoming request,

00:40:14.950 --> 00:40:17.830
we can now help you do that.

00:40:27.110 --> 00:40:31.100
NSStream is new in Foundation in Panther.

00:40:31.100 --> 00:40:36.200
It's actually two different classes:
NSInputStream and NSOutputStream.

00:40:36.220 --> 00:40:39.640
They're toll-free bridge to
CFReadStream and CFWriteStream,

00:40:39.640 --> 00:40:41.740
which have existed for a while.

00:40:41.770 --> 00:40:45.550
And the reason why that's important
is because NSInput and NSOutputStream

00:40:45.830 --> 00:40:47.390
is designed for subclassing.

00:40:47.430 --> 00:40:49.610
So we've received a
lot of requests saying,

00:40:49.670 --> 00:40:51.660
"Hey,
I don't want to talk to a socket," or,

00:40:51.660 --> 00:40:54.810
"I need to interpose a data
filter between the actual bytes

00:40:54.810 --> 00:40:59.760
coming in from the network
before you start processing it.

00:40:59.940 --> 00:41:03.400
How do I do that?" Well,
you can't really do that with a C API,

00:41:03.400 --> 00:41:05.370
but with NSStream,
we now have a way to do that.

00:41:05.590 --> 00:41:08.900
Just subclass NSInputStream
or NSOutputStream,

00:41:08.950 --> 00:41:12.100
insert the filter or extra
data processing you need,

00:41:12.150 --> 00:41:15.750
and then thanks to toll-free bridging,
you can take that object and pass

00:41:15.800 --> 00:41:20.600
it directly into the APIs that
consume read and write streams.

00:41:20.670 --> 00:41:24.200
And this was touched on briefly
at session 410 yesterday,

00:41:24.200 --> 00:41:27.040
the Cocoa update,
where they talked about everything

00:41:27.040 --> 00:41:29.300
that was new in Foundation and AppKit.

00:41:31.720 --> 00:41:33.620
And finally, Launch Services.

00:41:33.640 --> 00:41:37.990
Well, most of you are familiar with
Launch Services as the API you use if

00:41:38.070 --> 00:41:42.700
you have a file and you want to open
it exactly the same way Finder does.

00:41:42.700 --> 00:41:44.690
So you're probably thinking, "Well,
what the heck?

00:41:44.750 --> 00:41:48.890
That's not a networking API." Well,
the fact is that Launch Services is

00:41:48.890 --> 00:41:51.690
good at finding helper
applications of all kinds,

00:41:51.700 --> 00:41:53.690
not just for files.

00:41:53.700 --> 00:42:00.700
So the Launch Services APIs can be
used to open an arbitrary URL as well,

00:42:00.700 --> 00:42:04.690
or to find out what application
would handle a particular MIME type.

00:42:04.700 --> 00:42:07.840
In fact, Internet Config,
which is an older API that

00:42:07.850 --> 00:42:12.170
you may be more familiar with,
calls through to Launch Services to

00:42:12.170 --> 00:42:14.640
handle these kinds of services.

00:42:15.970 --> 00:42:19.540
And so I mention that, of course,
to get to this next point.

00:42:19.790 --> 00:42:22.660
We have some older APIs,
some legacy APIs,

00:42:22.690 --> 00:42:25.950
that we're kind of interested
in getting you to transition off

00:42:25.950 --> 00:42:27.780
of to some of the newer ones.

00:42:27.850 --> 00:42:29.870
And Internet Config is one of those.

00:42:29.900 --> 00:42:32.040
Are we taking these APIs away from you?

00:42:32.040 --> 00:42:33.130
No, of course not.

00:42:33.270 --> 00:42:34.900
They're still on the system.

00:42:34.900 --> 00:42:36.830
They'll continue to work the
way they always have worked.

00:42:36.910 --> 00:42:41.960
But we're no longer extending these
APIs the way we're extending some of the

00:42:41.960 --> 00:42:44.900
newer APIs that I've just talked about.

00:42:45.130 --> 00:42:47.900
These are the four I'm going
to address in particular:

00:42:47.900 --> 00:42:52.890
URL Access Manager, NSURL Handle,
Internet Config, and OT.

00:42:55.060 --> 00:42:57.430
So URL Access Manager.

00:42:57.530 --> 00:43:00.700
Clients tend to use it
in one of two fashions.

00:43:00.720 --> 00:43:04.100
Either they have a one-off,
well-controlled transaction,

00:43:04.100 --> 00:43:06.900
or they're doing some kind
of longer-lived transaction.

00:43:06.900 --> 00:43:10.040
If you're in that one-off case
where you know exactly the

00:43:10.040 --> 00:43:13.720
details of what you want to do,
you know you're performing an

00:43:13.720 --> 00:43:17.900
HTTP post to a server you control,
you set up as part of your business,

00:43:17.900 --> 00:43:22.800
CF Network is probably the best way
for you to go with something like that.

00:43:22.890 --> 00:43:24.740
It gives you full control of the details.

00:43:25.050 --> 00:43:28.900
At that kind of level,
the extra abstraction

00:43:28.900 --> 00:43:30.830
almost gets in your way,
because you know exactly

00:43:30.830 --> 00:43:31.880
what you're trying to do.

00:43:31.940 --> 00:43:35.360
On the other hand,
if you want an API that's simpler,

00:43:35.360 --> 00:43:40.760
kind of one-shot, fire and forget,
NSURL Connection is the way to go.

00:43:40.900 --> 00:43:44.900
And then if you're using
URL Access in the other way,

00:43:44.900 --> 00:43:46.900
where you're performing
some very long-lived,

00:43:46.900 --> 00:43:49.900
complex transaction, where you don't want
to handle the details,

00:43:49.900 --> 00:43:55.680
NSURL Upload and NSURL Download are
the two new glasses in the

00:43:55.680 --> 00:44:00.900
URL loading APIs that are available
for that kind of functionality.

00:44:02.700 --> 00:44:05.670
NSURL Handle in Foundation.

00:44:05.670 --> 00:44:13.460
The new URL loading APIs really
supersede NSURL Handle,

00:44:13.460 --> 00:44:16.580
so use NSURL Connection instead.

00:44:16.640 --> 00:44:19.630
We've added a compatibility shim
that connects the two engines,

00:44:19.700 --> 00:44:23.500
so if you have some investment
in a URL Handle subclass,

00:44:23.610 --> 00:44:25.660
that'll continue to
work as it always has.

00:44:25.700 --> 00:44:28.090
And not only that,
anyone using the new API,

00:44:28.090 --> 00:44:30.870
the URL Connection API,
will automatically see and

00:44:30.870 --> 00:44:32.620
talk to that subclass as well.

00:44:32.890 --> 00:44:38.670
Works in the other direction,
so if you have a URL Handle-based API,

00:44:38.790 --> 00:44:41.720
you'll actually see and
call through to the new

00:44:41.720 --> 00:44:44.360
Foundation loading engine as well.

00:44:46.870 --> 00:44:48.350
Internet Config.

00:44:48.440 --> 00:44:51.400
So if you're looking for a helper app,
you're just trying to figure out,

00:44:51.730 --> 00:44:55.260
who should I use to open this URL,
or who should I use to

00:44:55.270 --> 00:44:59.800
handle this MIME type,
call Launch Services directly instead.

00:44:59.990 --> 00:45:02.890
The other thing that we see
in Internet Config is access

00:45:02.990 --> 00:45:06.800
to these system preferences,
things like the proxy setting.

00:45:06.800 --> 00:45:11.750
To get those, talk directly to
System Configuration instead.

00:45:13.760 --> 00:45:15.750
Finally, OpenTransport.

00:45:15.880 --> 00:45:19.070
We've been telling you for at least
three years now that OpenTransport

00:45:19.170 --> 00:45:23.370
is not your high-performance native
networking solution on this system.

00:45:23.470 --> 00:45:25.200
BSD Sockets is.

00:45:25.300 --> 00:45:29.200
So as you're writing new code,
we encourage you to use Sockets directly.

00:45:29.460 --> 00:45:32.020
Also, when you're choosing
your networking code,

00:45:32.180 --> 00:45:34.700
maybe Sockets is not
the right layer for you,

00:45:34.700 --> 00:45:37.740
and we encourage you to think about
whether one of the higher-level

00:45:37.740 --> 00:45:41.200
APIs that's going to provide
connection to the run loop for you

00:45:41.240 --> 00:45:43.700
will maybe serve your needs better.

00:45:46.570 --> 00:45:50.940
So that's all the
material I had for today.

00:45:50.950 --> 00:45:53.230
I want to continue to
repeat this roadmap.

00:45:53.290 --> 00:45:57.460
I've talked about most of these already.

00:45:57.550 --> 00:46:00.500
I did not talk about 4.11
Internet Technologies,

00:46:00.500 --> 00:46:03.020
which talked a lot about the
Safari technologies and the

00:46:03.020 --> 00:46:04.430
web in kind of a general sense.

00:46:04.850 --> 00:46:06.420
That took place yesterday.

00:46:06.500 --> 00:46:10.320
Vincent mentioned the Rendezvous talk,
also yesterday.

00:46:10.500 --> 00:46:15.620
Kernel Extensions,
CF Network In-Depth is tomorrow,

00:46:15.620 --> 00:46:17.500
and then the Feedback Forum.

00:46:17.500 --> 00:46:20.380
So if you don't like
all of what I just said,

00:46:20.380 --> 00:46:23.490
come tomorrow morning at 10:30.

00:46:24.690 --> 00:46:26.880
Some contact information there.

00:46:26.880 --> 00:46:29.750
And with that,
I'd like to ask Tom Weier back

00:46:29.850 --> 00:46:32.100
up on the stage for the Q&A.

00:46:32.290 --> 00:46:33.600
Oh, sorry.

00:46:33.600 --> 00:46:35.400
I should mention the documentation.

00:46:35.520 --> 00:46:38.520
There's a load of documentation for
the different networking available.

00:46:38.590 --> 00:46:43.530
Go to ADC Home Documentation Networking,
and pretty much every

00:46:43.530 --> 00:46:46.870
API I've talked about here,
everything that Vincent talked about,

00:46:46.990 --> 00:46:50.770
has documentation under that heading.
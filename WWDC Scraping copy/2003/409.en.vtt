WEBVTT

00:00:21.620 --> 00:00:24.500
My name is Xavier Legro and
I'm the Mac OS X evangelist.

00:00:24.500 --> 00:00:27.500
I work in developer relations
and I'd like to welcome you

00:00:27.500 --> 00:00:30.920
all today to session 409,
the new HITooLbox.

00:00:31.520 --> 00:00:34.820
Last year, if you remember correctly,
not in the same room, but you know,

00:00:34.930 --> 00:00:38.080
it's a bit more south,
we introduced HIView,

00:00:38.080 --> 00:00:40.300
which is a new drawing
compositing model for like,

00:00:40.300 --> 00:00:42.500
you know, drawing controls on Mac OS X.

00:00:42.500 --> 00:00:46.210
We got a lot of feedback from you guys
and we're very happy to present you

00:00:46.210 --> 00:00:48.250
what we've been doing in the last year.

00:00:48.500 --> 00:00:52.340
You have to understand that if you're
doing Carbon development and if you're

00:00:52.340 --> 00:00:56.120
a C/C++ developer on our platform,
this technology is very,

00:00:56.120 --> 00:00:57.500
very important for you.

00:00:57.500 --> 00:01:00.140
And at one point or other
of your development cycle,

00:01:00.140 --> 00:01:03.150
you have to look at what we're
doing with HIView and what we're

00:01:03.150 --> 00:01:04.500
doing with the new HITooLbox.

00:01:04.500 --> 00:01:09.490
Because this is really the future of
C and C++ development on Mac OS X.

00:01:09.500 --> 00:01:14.930
We have a session full of new
things and very cool demos.

00:01:15.470 --> 00:01:17.520
And in order to talk about that,
we're going to go

00:01:17.540 --> 00:01:18.960
directly into the content.

00:01:18.960 --> 00:01:23.730
I'd like to introduce Guy Fullerton,
who is known as well as Guy,

00:01:23.740 --> 00:01:25.730
who's going to be actually talking
about the brand new HIToolbox

00:01:25.790 --> 00:01:27.800
that we have for you guys.

00:01:27.840 --> 00:01:28.610
Guy.

00:01:28.700 --> 00:01:30.750
Thank you.

00:01:31.880 --> 00:01:33.800
Thank you Xavier.

00:01:33.800 --> 00:01:34.660
Get him back.

00:01:34.670 --> 00:01:35.730
Call him Xavier.

00:01:35.790 --> 00:01:38.100
So you have to forgive me a little bit.

00:01:38.100 --> 00:01:40.800
I've been told that there's a Krispy
Kreme donut waiting for me back there

00:01:40.800 --> 00:01:43.800
after I finish the presentation,
so I might go a little quickly here.

00:01:43.800 --> 00:01:46.580
I really, really like donuts.

00:01:49.070 --> 00:01:54.240
Can we get the front monitors on so I can
see the slides without turning around?

00:01:54.240 --> 00:01:57.200
If not, I'll just stand back here
and I can see this screen.

00:01:57.460 --> 00:01:59.460
So I'm sure some of you
are sitting here wondering,

00:01:59.500 --> 00:02:03.510
new HIToolbox, why'd they call this
session the New HIToolbox?

00:02:03.550 --> 00:02:06.200
I mean, it's not like the
Control Manager APIs have

00:02:06.260 --> 00:02:08.710
changed fundamentally since 1984.

00:02:08.870 --> 00:02:11.290
You can still call many manager
routines the same way you've

00:02:11.340 --> 00:02:13.020
always been able to call them.

00:02:13.050 --> 00:02:16.520
And the contents of MacWindows.h
is almost the same as it

00:02:16.520 --> 00:02:18.520
has been back in 1984.

00:02:18.790 --> 00:02:22.140
So why are we calling the
session the new HI Toolbox?

00:02:24.360 --> 00:02:26.940
Well, the reason is that over
the past couple years,

00:02:27.120 --> 00:02:30.310
we've completely rewritten
the foundations of HIToolbox.

00:02:30.360 --> 00:02:33.710
In Jaguar, we introduced HIObject,
which is our standard

00:02:33.710 --> 00:02:35.270
toolbox object model.

00:02:35.290 --> 00:02:38.260
And every object model, of course,
needs some kind of messaging model,

00:02:38.260 --> 00:02:40.060
and Carbon Events is
that messaging model.

00:02:40.060 --> 00:02:43.610
And Carbon Events have been
around even longer than HIObject.

00:02:43.760 --> 00:02:46.410
And of course, if you've got objects,
you need base handlers

00:02:46.460 --> 00:02:47.620
and base functionality.

00:02:47.620 --> 00:02:49.250
And of course,
we have that in the form of the

00:02:49.270 --> 00:02:53.040
standard window handler and the base
handlers for controls and applications

00:02:53.040 --> 00:02:54.790
and menus and things like that.

00:02:54.850 --> 00:02:57.810
And so with this foundation in place,
what we were able to do is completely

00:02:57.810 --> 00:03:01.760
rewrite the control manager so that
the control system is now HIView.

00:03:01.890 --> 00:03:06.130
And HIViews are now a full-featured
view system that supports a one-pass

00:03:06.130 --> 00:03:09.030
efficient composited drawing model.

00:03:09.490 --> 00:03:11.080
So in short,
the reason we call this the new

00:03:11.080 --> 00:03:15.090
HIToolbox is because it's built
on a completely modern foundation.

00:03:17.280 --> 00:03:20.140
Now, there's a famous saying,
to stand still is to regress.

00:03:20.170 --> 00:03:22.860
And what this means to us on
the toolbox is that the world

00:03:22.860 --> 00:03:24.060
moves kind of fast around us.

00:03:24.060 --> 00:03:25.740
There's a lot of other things going on.

00:03:25.750 --> 00:03:29.200
And if we don't at least keep up,
and if not move faster

00:03:29.220 --> 00:03:32.470
than the rest of everybody,
we're falling behind.

00:03:32.570 --> 00:03:36.360
And so that's actually the reason why
we rewrote the foundations of HIToolbox.

00:03:36.430 --> 00:03:38.610
Because now that we have this
modern foundation in place,

00:03:38.670 --> 00:03:42.600
we can innovate much more quickly
than we were able to before.

00:03:42.630 --> 00:03:44.100
And that's fine for us.

00:03:44.100 --> 00:03:45.480
Let's put new features out there.

00:03:45.550 --> 00:03:47.430
But you might be wondering,
why do we care?

00:03:47.580 --> 00:03:51.630
An application that was written
back in 1984 that underwent the

00:03:51.630 --> 00:03:54.990
PowerPC transition and then ported
to Carbon still runs about the

00:03:54.990 --> 00:03:57.390
same on Mac OS X as it did in 1984.

00:03:57.490 --> 00:03:59.180
Sure,
it's got a new user interface and stuff,

00:03:59.250 --> 00:04:01.660
but your code can just work
the same if you want it to.

00:04:01.770 --> 00:04:05.460
So what does it really matter
if we have a new HIToolbox?

00:04:05.480 --> 00:04:08.150
Well,
the reason is that the new foundation

00:04:08.210 --> 00:04:12.550
forms the basis of all of our new
functionality from here on out.

00:04:13.100 --> 00:04:15.910
We have things like the toolbar,
which were introduced in Jaguar.

00:04:16.000 --> 00:04:18.390
And you can't really use the
toolbar unless you understand

00:04:18.390 --> 00:04:20.000
how HIobject and HIView works.

00:04:20.130 --> 00:04:22.700
And in fact, you can't even customize
the toolbar unless you know

00:04:22.700 --> 00:04:23.830
how to make a custom HIView.

00:04:24.300 --> 00:04:26.480
Similarly,
if you want to put sheets in your

00:04:26.480 --> 00:04:29.900
application to be truly Aqua-compliant,
you need to understand

00:04:29.900 --> 00:04:31.000
how Carbon events work.

00:04:31.000 --> 00:04:34.000
So you really need to understand
how this foundation works,

00:04:34.000 --> 00:04:36.090
and you need to start adopting
this as soon as you can,

00:04:36.090 --> 00:04:37.990
so you can bring your
applications forward.

00:04:38.220 --> 00:04:41.310
Another real benefit of this new
foundation is it offers much,

00:04:41.400 --> 00:04:43.000
much better performance.

00:04:43.000 --> 00:04:45.170
Compositing view systems
are an awful lot faster,

00:04:45.170 --> 00:04:47.300
more efficient,
and even more predictable than

00:04:47.310 --> 00:04:51.000
the old-school sorts of view
systems that we had on Mac OS.

00:04:51.000 --> 00:04:55.160
But the best point is that sticking
with HIToolbox is a very easy,

00:04:55.260 --> 00:04:59.080
iterative adoption path that
allows you to keep using the same,

00:04:59.080 --> 00:05:03.000
often cross-platform, C and C+ code that
you're already used to.

00:05:04.000 --> 00:05:05.990
So in short,
the new HIToolbox is what allows

00:05:05.990 --> 00:05:10.190
you to take your applications
to the next level on Mac OS X.

00:05:11.980 --> 00:05:14.940
So with this new foundation in place,
we actually did tons more stuff

00:05:14.940 --> 00:05:17.720
for Panther and HIToolbox than
we were able to for Jaguar

00:05:17.790 --> 00:05:18.840
for previous system releases.

00:05:18.840 --> 00:05:20.480
And I'm going to talk about
an awful lot of stuff.

00:05:20.580 --> 00:05:23.370
So the real reason I'm going
to talk fast is I've got to get

00:05:23.520 --> 00:05:24.690
all this stuff fit into an hour.

00:05:24.840 --> 00:05:31.130
It wouldn't surprise me if
we go a little bit over.

00:05:31.130 --> 00:05:33.210
But before I start going
into the new features,

00:05:33.210 --> 00:05:33.210
I want to talk about something else.

00:05:33.460 --> 00:05:36.970
When we were implementing Panther,
one of our mantras was performance.

00:05:37.110 --> 00:05:41.160
We really had to look hard at ways
we could make the toolbox faster.

00:05:41.190 --> 00:05:42.790
Performance is the main goal of Panther,
you know,

00:05:42.790 --> 00:05:44.510
it was talked about in other sessions.

00:05:44.560 --> 00:05:47.690
So we took a good hard look at a
number of different facets of the

00:05:47.690 --> 00:05:51.460
toolbox and did some intelligent
things to make it as fast and perform

00:05:51.470 --> 00:05:53.640
as efficiently as it possibly could.

00:05:53.640 --> 00:05:56.930
For instance, you know, we send a lot of
Carbon events on the system,

00:05:56.930 --> 00:06:00.180
but if you sample your application,
you're not going to see a lot of

00:06:00.240 --> 00:06:02.410
time spent in Carbon event routines,
right?

00:06:02.410 --> 00:06:04.380
The bulk of the time
is spent in your app.

00:06:04.470 --> 00:06:07.040
But still, we know the number of
Carbon events we're sending out.

00:06:07.150 --> 00:06:09.280
We know that over the course
of a run of an application,

00:06:09.280 --> 00:06:11.660
there's going to be thousands
and thousands of Carbon events

00:06:11.680 --> 00:06:14.560
getting sent to various objects
all over your application.

00:06:14.630 --> 00:06:17.170
So we need to make sure Carbon events
are as lightweight as possible.

00:06:17.280 --> 00:06:21.090
So we rethought some of the algorithms,
rethought some of the data structures,

00:06:21.100 --> 00:06:24.550
and we put some speed boosts in there,
the best of which is that event

00:06:24.760 --> 00:06:28.980
construction is now twice as fast
on Panther as it was on Jaguar.

00:06:30.220 --> 00:06:34.460
Now, we took a similar look at HIVU in
the compositing view system.

00:06:34.460 --> 00:06:36.990
We found some ways we
could do invalidation of

00:06:36.990 --> 00:06:38.610
views a little bit better.

00:06:38.610 --> 00:06:40.860
We found ways of
speeding other things up,

00:06:40.860 --> 00:06:45.160
like doing our vis region calculations in
a deferred manner and things like that.

00:06:45.160 --> 00:06:48.170
And the net result is that now
live resize for a fairly typical

00:06:48.180 --> 00:06:51.960
compositing window that probably has
a toolbar and a couple complex views,

00:06:51.960 --> 00:06:56.880
that's now about 30 to 40 percent
faster on Panther than it was on Jaguar.

00:06:56.980 --> 00:06:59.870
And it doesn't just affect
compositing windows.

00:06:59.880 --> 00:07:00.410
See, you can see that the window
frame is still being drawn,

00:07:00.410 --> 00:07:00.880
and the title bar is still being drawn.

00:07:00.880 --> 00:07:02.900
So even though your windows
may not yet be compositing,

00:07:02.900 --> 00:07:05.400
we still draw the window frame
and the title bar widgets and

00:07:05.400 --> 00:07:06.710
all that with compositing.

00:07:06.740 --> 00:07:09.650
So these performance improvements we
did just at the compositing path even

00:07:09.650 --> 00:07:11.380
helps your non-compositing windows.

00:07:11.390 --> 00:07:14.690
Now, it's hard to say exactly how much it
helps out non-compositing windows,

00:07:14.690 --> 00:07:17.430
because it depends greatly on
what exactly you draw and how

00:07:17.430 --> 00:07:18.650
you draw on those windows.

00:07:18.820 --> 00:07:21.630
But with our test apps,
we're seeing up to about a 10

00:07:21.630 --> 00:07:24.260
percent performance improvement
in library size during,

00:07:24.260 --> 00:07:26.280
for non-compositing windows.

00:07:26.280 --> 00:07:28.680
And of course,
these same changes speed up just about

00:07:28.740 --> 00:07:31.440
anything having to do with the number
of views that you have in your library.

00:07:31.520 --> 00:07:35.020
So, for example, if you're drawing, say,
a 10 percent performance

00:07:35.020 --> 00:07:38.500
improvement in a library,
you're going to have to make a 10 percent

00:07:38.500 --> 00:07:39.890
performance improvement in a library.

00:07:39.950 --> 00:07:41.900
So we're going to have to
make a 10 percent performance

00:07:41.900 --> 00:07:42.890
improvement in a library.

00:07:42.890 --> 00:07:44.510
So,
we're going to have to make a 10 percent

00:07:44.510 --> 00:07:45.830
performance improvement in a library.

00:07:45.830 --> 00:07:48.340
So, we're going to have to make a 10
percent performance improvement.

00:07:48.340 --> 00:07:50.520
So,
we're going to have to make a 10 percent

00:07:50.520 --> 00:07:52.430
performance improvement in a library.

00:07:52.480 --> 00:07:54.390
So,
we're going to have to make a 10 percent

00:07:54.400 --> 00:07:56.020
performance improvement in a library.

00:07:56.020 --> 00:07:57.160
So,
we're going to have to make a 10 percent

00:07:57.250 --> 00:07:59.020
performance improvement in a library.

00:07:59.020 --> 00:07:59.300
So,
we're going to have to make a 10 percent

00:07:59.300 --> 00:07:59.970
performance improvement in a library.

00:08:00.020 --> 00:08:00.020
So,
we're going to have to make a 10 percent

00:08:00.040 --> 00:08:01.020
performance improvement in a library.

00:08:01.020 --> 00:08:01.020
So,
we're going to have to make a 10 percent

00:08:01.020 --> 00:08:02.020
performance improvement in a library.

00:08:02.020 --> 00:08:02.020
So,
we're going to have to make a 10 percent

00:08:02.020 --> 00:08:02.980
performance improvement in a library.

00:08:03.020 --> 00:08:03.020
So,
we're going to have to make a 10 percent

00:08:03.020 --> 00:08:03.020
performance improvement in a library.

00:08:03.040 --> 00:08:03.480
So,
we're going to have to make a 10 percent

00:08:03.480 --> 00:08:04.020
performance improvement in a library.

00:08:04.020 --> 00:08:04.470
So,
we're going to have to make a 10 percent

00:08:04.470 --> 00:08:05.020
performance improvement in a library.

00:08:05.020 --> 00:08:06.550
So, we're going ways to enable
and disable your items,

00:08:06.550 --> 00:08:09.920
but we still wanted to make that
experience faster for the user.

00:08:09.920 --> 00:08:12.090
So we tweaked some menu
manager algorithms,

00:08:12.090 --> 00:08:16.670
and now typical menu item manipulation
is about 30 to 40 percent faster

00:08:16.670 --> 00:08:18.780
on Panther as it was on Jaguar.

00:08:18.780 --> 00:08:20.460
And of course,
we've had a lot of feedback

00:08:20.710 --> 00:08:22.780
about Data Browser,
and some of the complaints is

00:08:22.780 --> 00:08:24.430
that it's slow in a few areas.

00:08:24.560 --> 00:08:28.940
So we concentrated on certain algorithms
that people were complaining about,

00:08:28.940 --> 00:08:31.510
and we made Data Browser Item Addition,
I think it was about 30

00:08:31.570 --> 00:08:34.210
percent faster on Panther,
and Data Browser Item Removal

00:08:34.210 --> 00:08:38.670
and Selection 10 times faster on
Panther than it was on Jaguar.

00:08:41.150 --> 00:08:44.100
Well, I know you're not here to listen to
me pat myself on the back or anything,

00:08:44.100 --> 00:08:45.780
so let's just jump into the features.

00:08:45.810 --> 00:08:48.920
And I'd like to start
off with HITextView.

00:08:49.110 --> 00:08:53.450
This got mentioned in other sessions,
but HITextView is a

00:08:53.770 --> 00:08:58.230
A very full-featured compositing
text editing view based around MLTE,

00:08:58.240 --> 00:09:01.180
the Multilingual Text Engine.

00:09:01.420 --> 00:09:03.900
It's compositing mode only,
so this is another reason why

00:09:03.900 --> 00:09:06.400
you need to start switching your
windows over to compositing mode,

00:09:06.420 --> 00:09:08.300
so you can adopt a
cool feature like this.

00:09:08.300 --> 00:09:11.410
The reason why we based it on
MLTE is because MLTE already

00:09:11.460 --> 00:09:13.300
had a lot of functionality.

00:09:13.300 --> 00:09:16.300
It already supports mixed style runs,
full Unicode support,

00:09:16.300 --> 00:09:21.300
so it supports all the language
that Mac OS X supports.

00:09:21.300 --> 00:09:25.190
It's got advanced typographic
features and things like that.

00:09:25.300 --> 00:09:29.300
And it already integrates with certain
standard systems on the system,

00:09:29.300 --> 00:09:31.300
like the edit and services menu.

00:09:31.300 --> 00:09:34.300
And right now we're working
on support for the font panel.

00:09:34.300 --> 00:09:38.360
It's not there in the WWDC seed,
but it will be there by the

00:09:38.370 --> 00:09:40.330
time we ship Panther GM.

00:09:42.310 --> 00:09:45.420
So MLTE already has this really rich API.

00:09:45.430 --> 00:09:48.290
It can already do things
like insert text into it,

00:09:48.300 --> 00:09:52.420
associate an MLTE instance with a file,
set up styles,

00:09:52.420 --> 00:09:55.160
do complex manipulations and whatnot.

00:09:55.260 --> 00:09:59.300
So that allowed us to make
the HITextView API very,

00:09:59.300 --> 00:10:00.240
very small.

00:10:00.530 --> 00:10:03.470
There's basically two
APIs in the HITextView API.

00:10:03.490 --> 00:10:06.140
The first allows you
to create a textview.

00:10:06.140 --> 00:10:09.350
The second allows you to get the
MLTE object out of that textview

00:10:09.350 --> 00:10:11.470
so you can do manipulations on it.

00:10:11.470 --> 00:10:15.430
So the intended usage model
is you create your view,

00:10:15.430 --> 00:10:19.450
you get out the MLTE object,
and you call MLTE APIs on it.

00:10:19.450 --> 00:10:23.260
But the main thing you need to
realize is that some MLTE APIs do

00:10:23.260 --> 00:10:26.950
not work with these MLTE objects
that are bound to a view.

00:10:27.030 --> 00:10:30.890
And the reason for that is
because the MLTE API is so huge,

00:10:30.920 --> 00:10:35.130
and it predates HIView actually,
that it does some things that don't

00:10:35.160 --> 00:10:36.920
make sense in the world of HIView.

00:10:36.920 --> 00:10:40.200
For instance,
there's an MLTE API which allows you

00:10:40.200 --> 00:10:42.510
to change the bounds of an MLTE object.

00:10:42.630 --> 00:10:45.990
Well, we'd much prefer you use
the HIView APIs to change

00:10:45.990 --> 00:10:47.660
the bounds of a given view.

00:10:47.660 --> 00:10:51.580
So we actually disabled the
MLTE APIs that do those things

00:10:51.680 --> 00:10:55.240
just for these MLTE objects
that are bound to HIViews.

00:10:55.240 --> 00:10:58.630
So as you're perusing the
MLTE APIs and you see something,

00:10:58.630 --> 00:11:00.830
you're going to want to make
sure there's not an HIView--an

00:11:00.830 --> 00:11:02.380
equivalent HIView API instead.

00:11:02.380 --> 00:11:06.980
And make sure to call that
HIView instead--HIVW API instead.

00:11:06.980 --> 00:11:09.960
Now, another way that we leveraged
existing technology to make our

00:11:09.960 --> 00:11:13.600
textview a lot quicker or to
implement our textview a lot quicker

00:11:13.600 --> 00:11:15.360
was through the use of HIScrollView.

00:11:15.370 --> 00:11:18.270
The scrollview was something
we implemented in Jaguar.

00:11:18.310 --> 00:11:21.200
It's an HIView that can
manage the scrolling for any

00:11:21.200 --> 00:11:23.640
arbitrary scrollable canvas.

00:11:23.640 --> 00:11:25.440
It could be a picture, who knows what.

00:11:25.440 --> 00:11:26.320
It could be a list.

00:11:26.320 --> 00:11:27.170
It could be text.

00:11:27.170 --> 00:11:28.660
And it already does a
whole bunch of work.

00:11:28.660 --> 00:11:28.660
So it's a very, very good tool.

00:11:28.660 --> 00:11:29.660
And it's a very good tool to work for us.

00:11:29.660 --> 00:11:30.910
It manages the scrollbars.

00:11:30.910 --> 00:11:34.090
It'll hide and show the scrollbars
appropriately according to the

00:11:34.090 --> 00:11:36.000
AcroHuman interface guidelines.

00:11:36.000 --> 00:11:38.740
It'll keep the canvas sized at
the right amount and all that.

00:11:38.840 --> 00:11:42.350
And it's got a Carbon event protocol
that communicates with the canvas itself.

00:11:42.530 --> 00:11:45.860
So we built the HITextView to understand
that protocol and to communicate via

00:11:45.860 --> 00:11:48.260
that protocol with the scrollview.

00:11:48.260 --> 00:11:49.980
So that all you need to
do is you take a textview,

00:11:49.980 --> 00:11:53.670
you embed it in a scrollview,
and now you've got a scrollable textview.

00:11:54.700 --> 00:11:57.200
So here's a very quick example
of hi-text-view creation.

00:11:57.200 --> 00:12:00.370
It's pretty much exactly
what you would expect.

00:12:00.470 --> 00:12:03.100
You create a text view by
calling hi-text-view create.

00:12:03.140 --> 00:12:06.170
It's an hi-view creation API like
the ones we introduced in Jaguar,

00:12:06.200 --> 00:12:07.900
so it'll look real familiar to you.

00:12:07.900 --> 00:12:09.360
You can pass a frame to it.

00:12:09.390 --> 00:12:11.780
In this particular example,
I did not need to pass a frame,

00:12:11.780 --> 00:12:15.220
and I'll get to that in a second.

00:12:15.300 --> 00:12:16.600
We support some option bits.

00:12:16.770 --> 00:12:19.800
Right now, there are no option bits that
are specific to the hi-text-view,

00:12:19.800 --> 00:12:22.010
but it just gives us
future expandability.

00:12:22.040 --> 00:12:25.280
But more importantly is the fact
that you can pass MLTE option

00:12:25.280 --> 00:12:27.460
bits into our creation function.

00:12:27.460 --> 00:12:30.640
That's the TX and frame
options parameter.

00:12:30.690 --> 00:12:34.980
So this TX and frame options parameter
allows you to configure the MLTE object

00:12:34.980 --> 00:12:40.340
with certain creation data to turn
on certain behaviors and whatnot.

00:12:40.340 --> 00:12:44.580
These are all in the normal MLTE headers.

00:12:44.580 --> 00:12:47.060
But in this particular example,
we didn't need any options.

00:12:47.060 --> 00:12:50.460
And after you call this routine,
of course, you get back your text view.

00:12:50.460 --> 00:12:52.020
The next thing you need
to do is make it visible.

00:12:52.020 --> 00:12:55.260
Because by default,
an hiview is created invisibly.

00:12:55.270 --> 00:12:58.080
And then the next step is we just
take our text view and embed it in a

00:12:58.080 --> 00:12:59.760
scroll view that we've already created.

00:12:59.760 --> 00:13:01.990
And then our text view is just working.

00:13:02.790 --> 00:13:04.500
Now, more likely than not,
you're going to actually

00:13:04.500 --> 00:13:07.060
need to manipulate your text
view in some way via MLTE.

00:13:07.060 --> 00:13:09.240
So here's a very brief
example of how to do that.

00:13:09.280 --> 00:13:11.200
We've already got our text view created.

00:13:11.200 --> 00:13:15.880
So we call hitextview get txn object
to extract the MLTE object from it.

00:13:15.900 --> 00:13:19.190
And let's say we want to associate
that MLTE object with a file.

00:13:19.200 --> 00:13:21.330
So it will display the contents
of the file and support revert

00:13:21.420 --> 00:13:22.950
functionality and things like that.

00:13:22.980 --> 00:13:26.590
So we build a URL to that file using,
you know, the normal APIs.

00:13:26.600 --> 00:13:30.570
And then we call the textension
routine to associate that

00:13:30.580 --> 00:13:32.680
file with the MLTE object.

00:13:32.700 --> 00:13:33.650
And that's it.

00:13:33.710 --> 00:13:35.700
Very, very straightforward.

00:13:39.120 --> 00:13:40.800
Now, of course,
you can build it in code if you want,

00:13:40.920 --> 00:13:43.260
but better yet,
you can go into IB and build it there,

00:13:43.260 --> 00:13:45.860
because the IB,
the interface builder in Panther,

00:13:45.910 --> 00:13:48.800
now supports a bunch of the new HIViews.

00:13:48.800 --> 00:13:51.020
They implemented the ones
we introduced in Jaguar,

00:13:51.020 --> 00:13:54.320
and they've implemented most of the
ones we've introduced in Panther.

00:13:54.320 --> 00:13:56.810
And we're continuing to work with
them to make the Carbon experience

00:13:56.810 --> 00:13:58.510
in interface builder a lot richer.

00:13:58.550 --> 00:14:00.080
So, this is a good way to go as well.

00:14:03.290 --> 00:14:08.250
So another new view that was talked about
at the earlier sessions is HISearchField.

00:14:09.750 --> 00:14:13.090
Search fields are a big part of
the Aqua user interface on Panther.

00:14:13.160 --> 00:14:16.500
They're really convenient for the
users and offer a lot of functionality.

00:14:16.500 --> 00:14:19.390
And our HISearchField supports
all the standard behaviors.

00:14:19.400 --> 00:14:21.630
You know, it's an editable text field,
it's got the rounded frame,

00:14:21.630 --> 00:14:25.010
which indicates that it's a search field,
it's got an optional cancel button,

00:14:25.010 --> 00:14:28.930
it's got an optional pop-up menu,
completely customizable menu,

00:14:29.060 --> 00:14:32.150
and it has an optional descriptive label,
which is the little grayed-out text

00:14:32.170 --> 00:14:34.990
you can see that's in the text field
right now that kind of indicates

00:14:34.990 --> 00:14:36.730
what you're going to be searching.

00:14:37.470 --> 00:14:39.300
So here's a very quick example
of how you might create one.

00:14:39.300 --> 00:14:41.820
I'm going to assume you've
already created a menu ref.

00:14:41.880 --> 00:14:43.690
And in fact,
I'm going to assume you already know how

00:14:43.690 --> 00:14:46.250
to handle Carbon events on a menu ref,
because this is something you've been

00:14:46.250 --> 00:14:47.600
able to do for the past couple of years.

00:14:47.620 --> 00:14:48.500
It's very straightforward.

00:14:48.500 --> 00:14:49.600
You build up a menu.

00:14:49.600 --> 00:14:50.870
You put HI commands in it.

00:14:50.880 --> 00:14:53.570
You put the K event command
process handler on the menu.

00:14:53.580 --> 00:14:55.580
And then you can react to
commands as they get sent out.

00:14:55.640 --> 00:14:57.770
So we'll assume that's already been done.

00:14:57.780 --> 00:15:00.400
The next step is to just
create our search field.

00:15:00.420 --> 00:15:02.200
Give it its bounding rectangle.

00:15:02.200 --> 00:15:04.020
You can set up the attributes.

00:15:04.080 --> 00:15:05.600
Right now,
the only attribute is whether or

00:15:05.670 --> 00:15:06.840
not you want to cancel button.

00:15:07.220 --> 00:15:08.780
In this case,
we do want the cancel button.

00:15:08.780 --> 00:15:10.100
And you hand it your menu.

00:15:10.100 --> 00:15:12.770
And you give it the descriptive
text you want displayed.

00:15:12.780 --> 00:15:14.790
And you receive back the search field.

00:15:14.800 --> 00:15:19.600
Now, we also offer APIs so that you
can set the attributes and the

00:15:19.600 --> 00:15:22.740
menu and the descriptive text
on the fly later if you need to.

00:15:24.730 --> 00:15:26.560
Now once you've set it up,
you're going to want to

00:15:26.560 --> 00:15:27.650
handle events for two things.

00:15:27.780 --> 00:15:29.750
You want to react to clicks
on the cancel widget.

00:15:29.770 --> 00:15:32.040
And of course,
you're going to want to react to the text

00:15:32.040 --> 00:15:34.980
as the user types it and hits return,
so you can actually do the search.

00:15:34.980 --> 00:15:38.100
There's two Carbon events you need to
handle to deal with those two things.

00:15:38.120 --> 00:15:40.450
The first is keventextaccepted.

00:15:40.530 --> 00:15:43.380
And the second is
keventserchfieldcancelclicked.

00:15:43.380 --> 00:15:47.300
You install a handler the way I'm sure
you guys already know how to install.

00:15:47.300 --> 00:15:49.580
And the handler might
look something like this.

00:15:49.580 --> 00:15:52.360
If you receive the text accepted event,
you get your search field.

00:15:52.500 --> 00:15:54.480
You ask for the text
out of the search field.

00:15:54.480 --> 00:15:56.710
You do your search,
and you update your interface the

00:15:56.710 --> 00:15:58.900
way you would normally do that.

00:15:59.110 --> 00:16:02.000
And if the cancel button's clicked,
you just undo that search.

00:16:02.000 --> 00:16:07.950
You remove whatever filtering you did and
restore your list to its normal state.

00:16:10.170 --> 00:16:12.080
So the next view I want to
talk about is the segment view,

00:16:12.080 --> 00:16:15.100
or as it was called in other sessions,
I think, that switcher thingy.

00:16:15.100 --> 00:16:18.090
But we prefer the segment view.

00:16:21.600 --> 00:16:24.050
So I'm sure everybody's used
the segment view in the finder,

00:16:24.050 --> 00:16:24.480
right?

00:16:24.530 --> 00:16:26.170
It's a view switcher control.

00:16:26.230 --> 00:16:27.620
It's like a group of radio buttons.

00:16:27.620 --> 00:16:30.600
You can choose between icon, list,
and column view,

00:16:30.620 --> 00:16:33.160
and each of those choices
is mutually exclusive.

00:16:33.220 --> 00:16:35.540
So of course,
our segment view supports that.

00:16:35.540 --> 00:16:38.800
But some other uses of segment view
have a more momentary behavior.

00:16:38.890 --> 00:16:41.650
The best example are the back and
forward buttons that you see in

00:16:41.650 --> 00:16:45.350
Safari and the back and forward buttons
you see in the new open and save panels.

00:16:45.450 --> 00:16:47.310
That's essentially a segment view.

00:16:47.330 --> 00:16:49.690
It's just got two segments,
but each of those two segments

00:16:49.690 --> 00:16:52.520
is a push button that does
back and forward functionality.

00:16:52.580 --> 00:16:54.420
So of course,
the segment view supports that.

00:16:54.430 --> 00:16:57.000
The segment view also
supports sticky behavior.

00:16:57.000 --> 00:16:59.010
You can think of that as a checkbox,
right?

00:16:59.070 --> 00:17:01.630
You click it, it stays pressed until
you click it again,

00:17:01.650 --> 00:17:03.030
at which point it pops back up.

00:17:03.110 --> 00:17:06.290
Now the cool thing is that every segment
in a segment view is configurable.

00:17:06.290 --> 00:17:09.790
You can set the number of segments,
and you can set each one up differently.

00:17:09.790 --> 00:17:13.470
So you could have, for instance,
think of like a DVD player control.

00:17:13.470 --> 00:17:17.240
You could have a play, pause, record,
fast forward, reverse,

00:17:17.240 --> 00:17:20.440
each of those with a different
type of button behavior.

00:17:20.560 --> 00:17:22.000
And of course,
you can customize each of the

00:17:22.000 --> 00:17:23.680
button contents differently as well.

00:17:23.700 --> 00:17:27.240
We support icon services, icon refs,
CG image refs,

00:17:27.240 --> 00:17:30.990
which is sort of the preferred format,
and text, of course,

00:17:30.990 --> 00:17:34.530
for those applications that
need text-based segment views.

00:17:36.100 --> 00:17:38.730
Oh, the last point is that
unfortunately we did not get

00:17:38.830 --> 00:17:41.960
the SegmentView APIs publicized
in time for the WWDC build,

00:17:41.990 --> 00:17:44.990
but we are currently actually
using the implementation

00:17:45.250 --> 00:17:47.000
inside the new nav services.

00:17:47.000 --> 00:17:51.940
So it is there, it does exist,
it's fully functional,

00:17:51.950 --> 00:17:57.910
it's just the API didn't look quite
the way we wanted to for the seed,

00:17:57.910 --> 00:17:58.010
so we pulled it back.

00:17:58.010 --> 00:17:58.010
But the API will definitely be in
place by the time Panther ships.

00:17:59.680 --> 00:18:01.600
So we've got a lot of feedback
about Data Browser over the years.

00:18:01.600 --> 00:18:04.300
It's actually had quite a long lifespan.

00:18:04.450 --> 00:18:08.620
It's been around since before Mac OS X,
because it shipped in CarbonLib.

00:18:08.800 --> 00:18:12.390
And so we wanted to implement some of
the feature requests you've asked for.

00:18:12.670 --> 00:18:14.760
Now, in Jaguar, our big push was for HIV.

00:18:14.760 --> 00:18:17.340
You know, we wanted everybody to
get out there and use HIV.

00:18:17.580 --> 00:18:19.520
And it's this really exciting,
cool functionality.

00:18:19.520 --> 00:18:21.520
So I'm sure everybody raced out,
tried it,

00:18:21.520 --> 00:18:24.550
and then hit a brick wall and went, oh,
data browser doesn't support it.

00:18:24.640 --> 00:18:26.400
I guess I can't use it.

00:18:26.430 --> 00:18:28.270
I guess I can't use compositing mode.

00:18:28.420 --> 00:18:29.420
And yeah, that's true.

00:18:29.450 --> 00:18:30.120
It is unfortunate.

00:18:30.120 --> 00:18:31.890
And so that's one of
the things we really,

00:18:31.890 --> 00:18:33.750
really wanted to fix for Panther.

00:18:33.820 --> 00:18:36.300
So I'm happy to say that now
it works in compositing mode.

00:18:36.360 --> 00:18:38.070
It's pretty darn cool
in compositing mode.

00:18:38.080 --> 00:18:40.070
It's actually a lot faster.

00:18:40.100 --> 00:18:43.650
Because of the way compositing
modes and validation system works,

00:18:43.650 --> 00:18:47.840
I have to redraw a lot less in data
browser when things happen to it than

00:18:47.840 --> 00:18:50.160
I had to in non-compositing mode.

00:18:50.160 --> 00:18:52.710
In fact,
just normal data browser API usage

00:18:52.780 --> 00:18:55.200
got a little bit faster because
there were some data browser

00:18:55.200 --> 00:18:57.020
APIs that would immediately redraw.

00:18:57.020 --> 00:19:00.060
And so if you did sort of a
multi-state change on the data browser,

00:19:00.060 --> 00:19:01.960
you might get three or four redraws.

00:19:02.090 --> 00:19:05.600
Whereas now in compositing mode,
those four state changes will

00:19:05.600 --> 00:19:07.460
only be accompanied by one redraw.

00:19:07.460 --> 00:19:10.360
But data browser is a really huge API.

00:19:10.360 --> 00:19:11.920
I got it working in my test tools.

00:19:11.920 --> 00:19:16.060
We got it working enough for the new
nav services and finder in a few places.

00:19:16.080 --> 00:19:18.120
But I know we didn't
quite cover all the bases.

00:19:18.120 --> 00:19:19.440
So I need your feedback.

00:19:19.510 --> 00:19:23.630
So those of you who hit the brick wall
for adopting compositing in Jaguar,

00:19:23.630 --> 00:19:25.130
please go try it out.

00:19:25.310 --> 00:19:27.900
Go let us know if you see any
problems in compositing mode with

00:19:27.990 --> 00:19:29.370
various data types and whatnot.

00:19:29.420 --> 00:19:31.610
I'd like to have this thing
rock solid for Panther,

00:19:31.620 --> 00:19:32.640
but I need your help to do it.

00:19:32.640 --> 00:19:34.900
So write up any bugs you see.

00:19:37.810 --> 00:19:40.880
So the other thing we added for--
one thing we added for Jaguar,

00:19:40.930 --> 00:19:44.920
actually,
was type selection in column view.

00:19:44.920 --> 00:19:49.150
And we could actually do type selection
for free in column view because there's

00:19:49.270 --> 00:19:52.580
only one column that's focused at a time,
if you will.

00:19:52.580 --> 00:19:55.800
In ListView, however,
if you've got multiple columns,

00:19:55.860 --> 00:20:00.510
the data browser doesn't know which
column to apply the type selecting to.

00:20:00.510 --> 00:20:03.530
In Finder,
it would need to be the name column,

00:20:03.530 --> 00:20:05.340
but we could make that guess.

00:20:05.390 --> 00:20:07.330
We could find the first
column that does text,

00:20:07.330 --> 00:20:08.430
but it's a little fishy.

00:20:08.430 --> 00:20:10.800
It might not work for every application.

00:20:10.800 --> 00:20:13.640
So what we decided to do was
make it an adoption path thing,

00:20:13.640 --> 00:20:17.100
which actually gives us a benefit
in a second that I'll talk about.

00:20:17.100 --> 00:20:18.980
When you set up your
columns for ListView,

00:20:18.990 --> 00:20:21.940
you can specify a new property,
this KDataBrowser ListView type

00:20:21.940 --> 00:20:25.290
select column property,
which is in control definitions dot H,

00:20:25.430 --> 00:20:28.720
associate that with one of your columns,
and that's the column we'll

00:20:28.720 --> 00:20:30.060
apply type selection to.

00:20:30.220 --> 00:20:33.040
Now, the benefit we got, actually,
for making this an

00:20:33.040 --> 00:20:34.500
adoption path thing is--.

00:20:34.600 --> 00:20:34.600
Yeah.

00:20:34.980 --> 00:20:38.080
It prevented us from breaking
your existing applications.

00:20:38.080 --> 00:20:41.240
We know there are some applications
out there that filter the incoming

00:20:41.240 --> 00:20:43.380
text before it hits the data browser.

00:20:43.380 --> 00:20:45.730
And you could filter it at
sort of the wait next event

00:20:45.730 --> 00:20:48.640
level because up until now,
data browser wasn't

00:20:48.640 --> 00:20:52.660
particularly Carbon event savvy.

00:20:52.660 --> 00:20:54.660
And so, you know,
you could get away with taking

00:20:54.660 --> 00:20:56.660
an event out of wait next event,
filtering it,

00:20:56.660 --> 00:20:59.520
and then calling data browser
with only those key presses you

00:20:59.520 --> 00:21:01.410
wanted to give to data browser.

00:21:01.590 --> 00:21:05.100
Well, when type selection is turned on,
in order to do proper Unicode

00:21:05.380 --> 00:21:09.440
matching with the contents
of the type select column,

00:21:09.440 --> 00:21:14.500
we need to handle our text input via
the KEVENT_TEXT_INPUT_CARBON_EVENTS.

00:21:14.520 --> 00:21:15.500
So that is a difference.

00:21:15.500 --> 00:21:17.950
When you turn on type select,
text input will be grabbed by

00:21:17.950 --> 00:21:19.500
Data Browser in a different way.

00:21:19.500 --> 00:21:22.620
So if you need to do filtering,
make sure you filter using the

00:21:22.630 --> 00:21:26.500
KEVENT_TEXT_INPUT_CARBON_EVENTS or
some other similar mechanism.

00:21:26.500 --> 00:21:30.200
In fact,
there are some new events put out by

00:21:30.200 --> 00:21:34.500
the Text Services Manager that make
text filtering in general a lot easier.

00:21:34.500 --> 00:21:38.500
So take a look at carbon-events.h
for that kind of stuff.

00:21:42.530 --> 00:21:45.920
So the Appearance Manager was
introduced in Mac OS 8.

00:21:45.980 --> 00:21:47.760
I'm sure most of you
are familiar with it.

00:21:47.760 --> 00:21:49.800
I'm sure some of you have even used it.

00:21:49.870 --> 00:21:51.040
And it worked great on Mac OS 8.

00:21:51.040 --> 00:21:52.880
It was really fast.

00:21:52.940 --> 00:21:56.700
But on Mac OS X,
it didn't perform particularly well.

00:21:56.780 --> 00:21:59.100
And the reason for that is
that the Appearance Manager was

00:21:59.130 --> 00:22:00.500
entirely Quick Draw based.

00:22:00.580 --> 00:22:03.400
It assumed it was drawing
into the current port.

00:22:03.430 --> 00:22:07.030
That's basically the main
Quick Draw basis that it had.

00:22:07.260 --> 00:22:09.340
Now, Mac OS X is very Quartz-based.

00:22:09.340 --> 00:22:11.850
We want to use core
graphics all over the place.

00:22:11.870 --> 00:22:14.620
And in fact,
the internals of the Appearance

00:22:14.620 --> 00:22:16.870
Manager on Mac OS X draw in Quartz.

00:22:16.890 --> 00:22:20.220
So we had this weird sandwich effect
going on in the Appearance Manager where,

00:22:20.220 --> 00:22:22.260
OK, somebody would call
the Appearance Manager,

00:22:22.260 --> 00:22:23.980
they would have set up
their port properly.

00:22:23.980 --> 00:22:27.100
But before we call our internal stuff,
we needed to convert the port

00:22:27.160 --> 00:22:30.420
information to CG context and make
sure to synchronize the clip of the

00:22:30.420 --> 00:22:34.030
CG context with the Quick Draw clip,
and that was just horrifically expensive.

00:22:34.030 --> 00:22:37.250
Now, sometimes,
after we were done doing our drawing,

00:22:37.350 --> 00:22:41.480
we needed to call your code back to
do label drawing and stuff like that.

00:22:41.480 --> 00:22:43.760
And that is yet another sort of
mode switch where we had to shore

00:22:43.760 --> 00:22:46.080
up the data structures and make
sure everything was right in the

00:22:46.080 --> 00:22:49.300
Quick Draw world to match the way we'd
set it up in the core graphics world.

00:22:49.300 --> 00:22:51.580
So you had the sandwich of Quick Draw,
core graphics in the middle,

00:22:51.580 --> 00:22:52.850
and Quick Draw on the other side.

00:22:52.930 --> 00:22:54.650
And that just slowed everything down.

00:22:54.720 --> 00:22:57.360
So what we did is we took
just that center portion,

00:22:57.490 --> 00:23:00.110
just that Quartz portion,
and we exported it as

00:23:00.110 --> 00:23:02.130
HI-themed drawing primitives.

00:23:03.760 --> 00:23:07.080
Now, of course, this is going to give you
massive performance increases.

00:23:07.230 --> 00:23:11.160
In general,
we see about a two-time speed boost for

00:23:11.160 --> 00:23:17.190
an HITHeme API on Panther compared to
the equivalent appearance API on Jaguar.

00:23:17.200 --> 00:23:20.300
So if you can adopt this stuff
conditionally in your code for Panther,

00:23:20.300 --> 00:23:22.530
you're going to see really big
speed benefits for those of you who

00:23:22.530 --> 00:23:24.160
are using the Appearance Manager.

00:23:24.220 --> 00:23:27.490
Now, the best thing is that the
HITHeme APIs will look really,

00:23:27.490 --> 00:23:28.640
really familiar.

00:23:28.740 --> 00:23:32.200
It's virtually an identical usage model,
so it should be

00:23:32.200 --> 00:23:33.800
extraordinarily easy to adopt.

00:23:33.870 --> 00:23:36.600
And the number one request
for the Appearance Manager is,

00:23:36.850 --> 00:23:38.750
"Give us a way to draw
pulsing push buttons,

00:23:38.760 --> 00:23:42.350
please!" So you can do that
through the HITHeme APIs now.

00:23:42.930 --> 00:23:46.490
Now, another reason HITHeme is so
important is because this is the

00:23:46.490 --> 00:23:49.310
API set that will allow you to
draw all the new Aqua widgets,

00:23:49.310 --> 00:23:49.800
right?

00:23:49.930 --> 00:23:52.700
You need to use HITHeme if you want
to draw that new tab look and the

00:23:52.770 --> 00:23:54.610
segment views and things like that.

00:23:54.640 --> 00:23:57.300
So, you need to get familiar with this
and understand how to use it if you

00:23:57.310 --> 00:23:58.800
need your own drawing primitives.

00:23:58.800 --> 00:24:03.140
And lastly, the HITHeme APIs actually lay
the foundation for the toolbox

00:24:03.140 --> 00:24:04.740
and its ability to print.

00:24:04.850 --> 00:24:08.180
Well, it doesn't print quite yet,
but this lays enough groundwork

00:24:08.270 --> 00:24:09.790
so that we can actually print.

00:24:09.820 --> 00:24:12.270
Whereas the Appearance
Manager APIs simply cannot print by

00:24:12.370 --> 00:24:17.800
virtue of the way we have to manufacture
a context to match the QuickDrop port.

00:24:19.620 --> 00:24:23.110
So like I said, it's a very,
very familiar usage model,

00:24:23.120 --> 00:24:24.740
but there are some differences.

00:24:24.750 --> 00:24:27.800
First, obviously,
is that the HITHeme APIs are

00:24:27.830 --> 00:24:29.800
completely Quartz-savvy.

00:24:30.190 --> 00:24:34.260
So, no longer will you be able to assume,
"Oh, I can set up the current port with a

00:24:34.260 --> 00:24:37.280
background color and the appearance
manager is going to erase to it." No,

00:24:37.280 --> 00:24:40.230
you have to do your erase beforehand
if that's something you need to do,

00:24:40.250 --> 00:24:42.100
and then call the HITHeme API.

00:24:42.100 --> 00:24:44.320
And in fact,
the HITHeme API requires that you

00:24:44.320 --> 00:24:46.100
pass in a core graphics context.

00:24:46.100 --> 00:24:49.890
So you manufacture one of these core
graphics contexts and you can call

00:24:49.900 --> 00:24:52.100
multiple HITHeme APIs as you need to.

00:24:52.250 --> 00:24:55.840
The second major difference is
the fact that the HITHeme APIs use

00:24:55.950 --> 00:24:58.100
HIPoint and HIREctangle parameters.

00:24:58.100 --> 00:25:00.070
And there's two reasons for this.

00:25:00.160 --> 00:25:03.120
The first is that since HITHeme
is entirely core graphics based,

00:25:03.190 --> 00:25:08.100
and since core graphics has a floating
point based coordinate system,

00:25:08.100 --> 00:25:09.980
quick draw coordinates,
the old quick draw coordinates,

00:25:10.010 --> 00:25:12.100
which were not floating point,
don't really work well

00:25:12.100 --> 00:25:13.100
in the context of CG.

00:25:13.100 --> 00:25:16.090
They don't allow maximum flexibility.

00:25:16.100 --> 00:25:20.100
And so that made it natural
to use HIPoint and HIREct.

00:25:20.100 --> 00:25:23.490
The second reason is that the HITHeme
APIs were literally designed so that

00:25:23.640 --> 00:25:26.100
we could implement our system HIViews
like the push button and whatnot.

00:25:26.100 --> 00:25:29.950
And since they are HIViews,
they also use HIPoint and

00:25:29.950 --> 00:25:32.100
HIREctangle parameters.

00:25:32.100 --> 00:25:34.100
So it was just a perfectly natural fit.

00:25:35.970 --> 00:25:38.460
Now, you guys are all used to drawing
with a top left-hand origin.

00:25:38.510 --> 00:25:39.700
I think that's more comfortable.

00:25:39.700 --> 00:25:41.040
I'm sure all of you do, too.

00:25:41.110 --> 00:25:43.520
So, of course,
the HITHeme APIs support that model.

00:25:43.680 --> 00:25:48.650
But if you're doing more
PDF-compatible drawing,

00:25:48.650 --> 00:25:53.990
or if you're trying to do
some theme-primitive drawing

00:25:53.990 --> 00:25:56.760
from a Cocoa application,
HITHeme supports a bottom

00:25:56.760 --> 00:25:56.760
left origin as well,
so you can use it from

00:25:56.760 --> 00:25:56.760
just about anywhere.

00:25:59.010 --> 00:26:01.370
So we introduced HIView in Jaguar,
and it has a lot of

00:26:01.370 --> 00:26:03.440
cool new functionality,
but we wanted to add something

00:26:03.440 --> 00:26:05.780
really key to it in Panther,
and so we've got something

00:26:05.780 --> 00:26:08.900
that's kind of exciting,
and it's called HIViewLayout.

00:26:09.130 --> 00:26:13.300
But rather than explain it,
I want to give you a brief demo,

00:26:13.410 --> 00:26:16.130
because I think that'll do a better
job showing you what it's all about.

00:26:16.130 --> 00:26:19.180
So if we could go to the demo machine.

00:26:23.720 --> 00:26:25.300
I'm being told I need to talk faster.

00:26:25.410 --> 00:26:29.780
Something tells me that's not the case.

00:26:29.780 --> 00:26:31.070
Okay, so this is Rebounder.

00:26:31.080 --> 00:26:34.320
This is our test tool
for the HIV layout stuff,

00:26:34.320 --> 00:26:36.880
but it's also,
we're also going to sort of

00:26:36.880 --> 00:26:38.920
polish it up and put it out
as sample code after the show,

00:26:38.920 --> 00:26:39.920
but it needs a little bit of work.

00:26:40.000 --> 00:26:43.100
I mean, for one,
we're stretching a push button well

00:26:43.100 --> 00:26:44.520
beyond the bounds of good taste.

00:26:44.770 --> 00:26:48.940
Anyway,
so this is basically just a normal

00:26:48.940 --> 00:26:50.390
window with a push button in it.

00:26:50.390 --> 00:26:52.950
You can click and track on it,
but we've put some Carbon event

00:26:52.950 --> 00:26:56.180
handlers on the push button so that
we can put it into sort of edit mode,

00:26:56.210 --> 00:26:56.720
right?

00:26:56.720 --> 00:26:58.850
You can see these little
handles get associated with it.

00:26:58.850 --> 00:27:01.100
And, you know,
I can rearrange the push button.

00:27:01.100 --> 00:27:02.940
We've showed demos like this before.

00:27:04.190 --> 00:27:05.860
But that's not the point
of this application.

00:27:05.870 --> 00:27:08.740
The point of this application
is it lets us test out all

00:27:08.740 --> 00:27:11.220
of the HIV view layout stuff.

00:27:11.220 --> 00:27:15.990
Now, layouts, simply speaking,
are just a way to make a view resize

00:27:15.990 --> 00:27:18.140
or move when a window resizes.

00:27:18.140 --> 00:27:19.660
You can think of it that way.

00:27:19.660 --> 00:27:22.260
So for instance, I've got this view A.

00:27:22.260 --> 00:27:24.630
I can set up a binding,
which is the first type

00:27:24.630 --> 00:27:26.060
of layout that we support.

00:27:26.060 --> 00:27:29.080
And I can associate that view with
the right hand side of the window.

00:27:29.080 --> 00:27:31.380
And when I grow the window,
the view stays in place

00:27:31.380 --> 00:27:32.640
just like you'd expect.

00:27:32.640 --> 00:27:35.320
And you're not limited to just one edge,
of course.

00:27:35.320 --> 00:27:36.960
I can bind it to the
bottom of the window.

00:27:36.960 --> 00:27:39.680
Let's say it's like an OK button.

00:27:39.850 --> 00:27:41.320
You know, and it's going to stay
in the right place.

00:27:41.380 --> 00:27:42.070
It's all automatic.

00:27:42.140 --> 00:27:45.250
I just set up some data structures,
call an API, and the toolbox will

00:27:45.250 --> 00:27:46.580
take care of the rest.

00:27:46.970 --> 00:27:52.030
Now another cool thing is that you can
do sort of arbitrary relationships.

00:27:52.090 --> 00:27:54.310
I've associated this
view A with its parent,

00:27:54.310 --> 00:27:57.790
the window, but you're not limited to
just parent relationships.

00:27:57.880 --> 00:27:59.980
I can create another view, view B.

00:28:00.020 --> 00:28:02.160
Let's move it down here next to
view A because I like it there.

00:28:02.210 --> 00:28:04.210
Let's make it a little bit smaller
so I'm at least somewhat close to

00:28:04.210 --> 00:28:06.360
the Aqua Human Interface guidelines.

00:28:06.360 --> 00:28:10.100
And I'm going to bind that view,
I'm going to bind its right

00:28:10.100 --> 00:28:12.870
edge to the left edge of view A.

00:28:12.940 --> 00:28:15.900
And now when I resize the window,
you get this sort of cascade

00:28:15.950 --> 00:28:19.130
of automatic repositioning.

00:28:19.190 --> 00:28:22.600
Now, of course, I can bind view B to
view A's top as well.

00:28:22.600 --> 00:28:25.680
And so now you've got a really easy
way to keep your OK and cancel buttons

00:28:25.680 --> 00:28:27.980
down in the bottom of the window.

00:28:33.090 --> 00:28:33.500
OK.

00:28:33.500 --> 00:28:39.220
So-- but bindings are just
one of the layouts we support,

00:28:39.220 --> 00:28:41.270
one of the types of
relationships we support.

00:28:41.320 --> 00:28:42.980
Another thing we support is positioning.

00:28:42.980 --> 00:28:46.340
And you can think of positioning
sort of as alignments.

00:28:46.360 --> 00:28:48.390
And it's an alternative
way to do something we've

00:28:48.390 --> 00:28:49.600
already done in this demo.

00:28:49.610 --> 00:28:54.710
So I'm going to go ahead and position
A horizontally such that it is

00:28:54.710 --> 00:28:56.620
now right aligned with the window.

00:28:56.640 --> 00:28:57.850
So it immediately snaps over there.

00:28:57.860 --> 00:29:00.560
And it's going to stay over there,
just like you'd expect.

00:29:00.560 --> 00:29:03.100
But positionings also support offsets.

00:29:03.240 --> 00:29:07.720
So I think the AquaHuman interface
guidelines say that the right offset

00:29:07.830 --> 00:29:10.040
from the edge of the window is 13 pixels.

00:29:10.240 --> 00:29:12.820
So let me apply an offset to
the positioning I've set up.

00:29:12.820 --> 00:29:15.120
And it'll stay 13 pixels
from the edge of the window.

00:29:15.160 --> 00:29:17.040
Of course,
I can do the same thing to the bottom.

00:29:17.040 --> 00:29:21.620
But before I do that,
let me actually turn off the bindings.

00:29:22.000 --> 00:29:23.920
Do the same thing,
position that 13 pixels up

00:29:23.920 --> 00:29:25.790
from the bottom of the window.

00:29:26.360 --> 00:29:28.200
And A is going to stay
in the right place,

00:29:28.260 --> 00:29:29.220
just the way we want.

00:29:29.340 --> 00:29:32.200
And B is still moving as well,
because it's still bound to A,

00:29:32.200 --> 00:29:33.170
A's movement.

00:29:33.290 --> 00:29:36.990
But one other cool aspect is that
the relationships are one way.

00:29:37.270 --> 00:29:40.810
So I can actually move B someplace else,
and it'll still maintain

00:29:40.810 --> 00:29:42.200
B's relative offset from A.

00:29:42.200 --> 00:29:43.800
So it's kind of powerful in that way.

00:29:43.800 --> 00:29:46.200
You can move your views
around and change the layouts,

00:29:46.200 --> 00:29:49.490
and things still behave
the way you'd expect.

00:29:49.910 --> 00:29:53.180
Okay, so another cool thing you can do
with positionings is centering.

00:29:53.180 --> 00:29:56.290
Let me clear the offsets.

00:29:59.200 --> 00:30:01.300
And I can center A.

00:30:01.440 --> 00:30:02.500
So A is going to stay in the center.

00:30:02.610 --> 00:30:04.700
Of course, B is still bound to it.

00:30:04.750 --> 00:30:08.400
B is going to stay right
where we want him to be.

00:30:08.440 --> 00:30:11.670
And if I clear the centering,
I can show you the third

00:30:11.670 --> 00:30:14.730
type of layout we support,
and that's scaling.

00:30:14.770 --> 00:30:17.150
I can say, all right,
let's say for some strange reason

00:30:17.180 --> 00:30:20.860
I always want view A to be 50%
of the width of the window.

00:30:20.870 --> 00:30:21.880
I can set that up.

00:30:21.880 --> 00:30:24.430
And let's say for some other
strange reason I want it to be

00:30:24.430 --> 00:30:26.500
25% the height of the window.

00:30:26.590 --> 00:30:27.560
That works as well.

00:30:27.560 --> 00:30:29.720
So now whenever the window's
height changes and width changes,

00:30:29.830 --> 00:30:33.150
A's size changes along with it.

00:30:33.180 --> 00:30:35.280
Now probably the coolest part
about layouts is you can mix

00:30:35.280 --> 00:30:36.630
and match them and combine them.

00:30:36.700 --> 00:30:39.770
So I'm going to leave A's bindings
all set up so that he's staying

00:30:39.770 --> 00:30:41.550
a proportion of the window size.

00:30:41.640 --> 00:30:45.210
But now I'm also going to say, all right,
center him too.

00:30:45.250 --> 00:30:47.150
And both of those bindings are respected.

00:30:47.210 --> 00:30:49.050
So this is really, really powerful.

00:30:49.090 --> 00:30:52.080
We switched the new navigation
services over to using this stuff,

00:30:52.110 --> 00:30:56.560
got rid of a ton of code in nav,
and it not only library sizes faster,

00:30:56.710 --> 00:31:00.560
but it just makes the code
so much easier to maintain.

00:31:00.670 --> 00:31:04.410
So if we can go back to the slides now,
that'd be great.

00:31:12.370 --> 00:31:14.580
So, obviously layouts are cool,
but there's some other technical

00:31:14.580 --> 00:31:16.690
reasons why you might want to use these.

00:31:16.730 --> 00:31:20.900
It's a very rich descriptive language
for associating views together.

00:31:20.900 --> 00:31:23.740
For one, you can do peer
relationships like I showed,

00:31:23.740 --> 00:31:24.040
A to B.

00:31:24.310 --> 00:31:26.510
You can do parent relationships,
A to the window.

00:31:26.670 --> 00:31:29.350
But you can even do strange
relative relationships.

00:31:29.350 --> 00:31:32.120
You could do A to its second
cousin if you wanted to.

00:31:32.120 --> 00:31:34.310
We took advantage of this in
Navigation Services as well,

00:31:34.410 --> 00:31:39.500
and it made some of the relay out of the
dialogue that we needed to do to support

00:31:39.500 --> 00:31:41.300
various optional pop-ups and whatnot.

00:31:41.330 --> 00:31:43.530
It made that super simple.

00:31:43.930 --> 00:31:48.390
The other main benefit is that if
you let us do the layout for you,

00:31:48.650 --> 00:31:51.000
not only do you have less
code you need to maintain,

00:31:51.100 --> 00:31:54.340
but we can make sure that our layout
code is as efficient as possible,

00:31:54.340 --> 00:31:56.070
so you don't have to
spend time optimizing it,

00:31:56.190 --> 00:31:58.400
and we can also make sure we
do it at the most optimal time,

00:31:58.400 --> 00:32:00.740
so that we invalidate as
little as possible and cause as

00:32:00.740 --> 00:32:02.200
little of a redraw as possible.

00:32:03.740 --> 00:32:06.170
This is about all I'm going to talk
about in terms of HIView layouts,

00:32:06.230 --> 00:32:10.570
but session 425 is going to go
into quite a bit more detail.

00:32:10.590 --> 00:32:13.770
So go check that one out.

00:32:21.940 --> 00:32:27.490
So the Aqua Human Interface
Guidelines give sort of the desired

00:32:27.490 --> 00:32:29.040
look for simple about boxes.

00:32:29.040 --> 00:32:31.800
And yeah, it's really simple,
but we figured, well,

00:32:31.850 --> 00:32:34.230
if we can do that for you, why not?

00:32:34.310 --> 00:32:38.380
So we added the HIAboutBox API to
the toolbox for Panther to

00:32:38.380 --> 00:32:40.290
do simple about boxes.

00:32:40.380 --> 00:32:41.790
And of course,
it's going to support everything

00:32:41.840 --> 00:32:44.160
you're looking for in one
of these simple about boxes.

00:32:44.160 --> 00:32:47.490
It gives you the right look.

00:32:47.540 --> 00:32:50.480
It's going to display your
application's name and version

00:32:50.480 --> 00:32:52.700
and copyright information.

00:32:52.700 --> 00:32:55.250
And it does that by looking
at your application's bundle,

00:32:55.250 --> 00:32:56.980
which probably already
has that information.

00:32:56.980 --> 00:33:00.880
So we'll just fetch it from there
and display it appropriately.

00:33:00.880 --> 00:33:02.580
But if you want to customize it,
there's two different

00:33:02.580 --> 00:33:04.340
ways you can customize it.

00:33:04.340 --> 00:33:06.390
You can either give us a
CFDictionary full of strings

00:33:06.390 --> 00:33:09.160
with well-known keys and say,
"Please use this string for the name.

00:33:09.160 --> 00:33:11.440
Please use this string for
the version," and whatnot.

00:33:11.440 --> 00:33:13.320
And that might actually be
useful for plug-ins that want

00:33:13.320 --> 00:33:14.550
to display in an about box,
right?

00:33:14.610 --> 00:33:16.890
You wouldn't want the plug-in
to display in an about box

00:33:16.890 --> 00:33:18.420
that points at the apps bundle.

00:33:18.420 --> 00:33:20.560
So you'd supply your own strings.

00:33:20.610 --> 00:33:24.610
Alternatively to supplying a dictionary,
you can point the HIAboutBox API at

00:33:24.610 --> 00:33:28.740
a strings file and we'll pull
the strings out of there.

00:33:28.740 --> 00:33:31.490
So it makes it easier
to localize and whatnot.

00:33:32.200 --> 00:33:36.240
Now, if you use runApplicationEventLoop
to drive your event loop,

00:33:36.380 --> 00:33:40.530
the About box will display automatically
whenever the default application object

00:33:40.530 --> 00:33:43.180
receives the HICommandAbout command.

00:33:43.180 --> 00:33:45.220
So all you need to do to get one
of these wired into your apps

00:33:45.240 --> 00:33:48.710
is just associate that command
ID with your About menu item.

00:33:48.710 --> 00:33:50.740
It will put it up automatically.

00:33:50.740 --> 00:33:54.730
But if you need to display it manually,
like in the case of a plug-in perhaps,

00:33:54.730 --> 00:33:57.220
or for a WaitNext event-based
application,

00:33:57.260 --> 00:34:00.890
you can call the HIAboutbox
command directly if you need to.

00:34:01.280 --> 00:34:03.880
Now,
the About box is a mode list window in

00:34:03.880 --> 00:34:07.080
the document layer of your application.

00:34:07.080 --> 00:34:08.430
And so, you know,
the user's going to expect

00:34:08.490 --> 00:34:10.140
to click between it,
so you need to be prepared

00:34:10.140 --> 00:34:11.130
to deal with that.

00:34:11.140 --> 00:34:14.220
You need to be sort of
prepared for this other window,

00:34:14.220 --> 00:34:17.380
a window you may not have created
to be in your document list.

00:34:17.800 --> 00:34:20.520
And the other thing the user's going
to need to be able to do is close it.

00:34:20.610 --> 00:34:23.230
Well, the About box already handles a
bunch of Carbon events on itself.

00:34:23.250 --> 00:34:26.940
It's standard handler-based,
so it's going to automatically close

00:34:26.940 --> 00:34:28.820
if the user clicks on the Close box.

00:34:28.920 --> 00:34:31.310
But the user's, of course,
going to want to close it by choosing the

00:34:31.360 --> 00:34:33.290
appropriate command from the File menu.

00:34:33.460 --> 00:34:36.700
And the easiest way to do that
is to put the HICommandClose

00:34:36.700 --> 00:34:39.920
command ID in your Close window,
command in your File menu.

00:34:39.920 --> 00:34:41.360
Did I say command enough?

00:34:41.430 --> 00:34:42.120
I think so.

00:34:42.150 --> 00:34:43.870
Anyway, you get the point.

00:34:46.350 --> 00:34:50.100
toolbar was another technology we
added in jaguar and uh... found the

00:34:50.100 --> 00:34:53.330
need to add a few things to that
as well uh... the toolbar is set

00:34:53.330 --> 00:34:56.290
up such that it can automatically
save its configuration to your

00:34:56.370 --> 00:34:59.210
preferences and that's really powerful,
it means you have to write less code

00:34:59.210 --> 00:35:03.900
and uh... the user gets the desired
experience uh... but there was a small

00:35:04.060 --> 00:35:08.140
hole in that plan uh... having to do
with custom toolbar items there are some

00:35:08.210 --> 00:35:11.980
custom toolbar items you may have added
to your toolbar and those items may

00:35:11.980 --> 00:35:16.580
have had their own internal state there
may be times when that internal state

00:35:16.580 --> 00:35:21.300
changes uh... without the user doing
something explicit and if that happened

00:35:21.340 --> 00:35:24.700
there was no way for your toolbar item
to communicate back to the toolbar and

00:35:24.700 --> 00:35:28.660
say hey i'm i'm dirty now you need to
save me at the next possible chance so it

00:35:28.660 --> 00:35:32.750
was possible that our automatic saving of
configuration data would kinda would lose

00:35:32.950 --> 00:35:36.580
some configuration every now and again
so we added an API to deal with that

00:35:36.620 --> 00:35:41.050
which is HIToolbarItemConfigDataChanged
anytime your internal state changes

00:35:41.050 --> 00:35:43.880
in a custom item just call this
the toolbar will automatically save

00:35:43.880 --> 00:35:45.810
your configuration configuration.

00:35:46.450 --> 00:35:49.810
A lot of people that use toolbars
build them up programmatically.

00:35:49.900 --> 00:35:54.470
Not everybody can use our
sort of automatic regeneration

00:35:54.470 --> 00:35:56.440
from pref technique.

00:35:56.440 --> 00:35:59.660
But what we found--and in fact,
Finder was one of those clients.

00:35:59.660 --> 00:36:02.600
They built it up manually from
their own preferences store.

00:36:02.600 --> 00:36:07.420
And what we found is it's actually quite
slow because the previous APIs only

00:36:07.420 --> 00:36:11.160
allowed you to programmatically add
toolbar items to a toolbar one at a time.

00:36:11.170 --> 00:36:13.180
And every time you add a
toolbar item to a toolbar,

00:36:13.180 --> 00:36:15.710
there's a bunch of Carbon events
that get sent out so that all the

00:36:15.710 --> 00:36:18.990
toolbar views in the various windows
that use that toolbar know to update.

00:36:18.990 --> 00:36:20.620
And then each of those
toolbar views says,

00:36:20.620 --> 00:36:22.030
"Oh, I've got a new view in me.

00:36:22.100 --> 00:36:23.590
I think I need to relay stuff out,
you know,

00:36:23.620 --> 00:36:26.820
shift stuff around." So that's a lot
of work for every single toolbar item.

00:36:26.840 --> 00:36:30.230
You multiply that times n items and
things start slowing down a lot.

00:36:30.230 --> 00:36:33.580
So we added the
HIToolbarSetItemsWithIdentifiers

00:36:33.580 --> 00:36:38.980
API to allow you to add a whole batch
of toolbar items at once to a toolbar.

00:36:38.980 --> 00:36:42.520
So if you are doing this custom
toolbar creation programmatically,

00:36:42.620 --> 00:36:44.720
make sure to conditionally
use this API on panels.

00:36:44.720 --> 00:36:46.720
So you can see that it's going
to speed up your creation,

00:36:46.720 --> 00:36:49.400
possibly dramatically,
depending on how many

00:36:49.420 --> 00:36:50.550
toolbar items are in it.

00:36:53.470 --> 00:36:56.040
So I'm running out of good segues,
so I'm just going to say let's talk

00:36:56.120 --> 00:36:58.990
about the Carbon Event Manager.

00:36:59.350 --> 00:37:01.000
We added a few APIs.

00:37:01.000 --> 00:37:03.980
The first is kind of an
edge case usage thing.

00:37:04.060 --> 00:37:09.340
HIMouseTrackingGetParameters is
an API that allows you to ask us

00:37:09.430 --> 00:37:13.240
how we do our sticky menu tracking
in sort of an abstract way.

00:37:13.370 --> 00:37:15.600
There's some applications out
there that want to replicate

00:37:15.600 --> 00:37:16.760
our sticky menu tracking.

00:37:16.760 --> 00:37:18.950
You know,
perhaps you're doing something menu-like,

00:37:18.950 --> 00:37:21.190
or you're doing your own
custom menu implementation,

00:37:21.200 --> 00:37:22.980
something,
and you need to behave the same.

00:37:23.000 --> 00:37:26.140
This API allows you to make sure
you're behaving the same with

00:37:26.140 --> 00:37:29.250
respect to all the things the
user's configured on the system

00:37:29.260 --> 00:37:31.410
and all of that user's preferences.

00:37:31.820 --> 00:37:35.940
The next API we added is CopyEventAs.

00:37:36.030 --> 00:37:39.120
In the Carbon Event Manager, we

00:37:40.330 --> 00:37:43.000
We transform events as they
cascade through the system.

00:37:43.000 --> 00:37:45.550
A raw mouse down becomes
a window content click.

00:37:45.550 --> 00:37:48.970
A window content click might
spawn a K-event control click.

00:37:48.970 --> 00:37:51.540
The control click will
spawn a control track,

00:37:51.540 --> 00:37:52.970
and so on and so on and so on.

00:37:53.010 --> 00:37:56.710
And our model generally dictates that
an event spawned from another event

00:37:57.080 --> 00:38:00.630
should have pretty much all the same
parameters as the event that spawned it.

00:38:00.630 --> 00:38:03.300
And if you're trying to
replicate that in your own code,

00:38:03.300 --> 00:38:06.640
or if you're trying to do some,
trigger some functionality in the

00:38:06.640 --> 00:38:09.600
standard window handlers and you want to
make sure you're passing the right kind

00:38:09.600 --> 00:38:12.690
of event to the standard window handler,
the copyEventAs function

00:38:12.690 --> 00:38:13.930
you might find useful.

00:38:13.950 --> 00:38:17.550
It allows you to take any given event
of a certain class and kind and create

00:38:17.550 --> 00:38:20.920
another event of a different class and
kind while still maintaining all the same

00:38:20.920 --> 00:38:22.630
parameters that the original event had.

00:38:25.320 --> 00:38:28.490
Now,
another API we added fills a hole and

00:38:28.580 --> 00:38:32.660
fixes a performance bug at the same time.

00:38:32.710 --> 00:38:34.150
You know,
we're pushing everybody to adopt

00:38:34.150 --> 00:38:36.000
Carbon events as much as possible,
and we've pretty much got

00:38:36.000 --> 00:38:39.260
all the bases covered,
but we found out that some people still

00:38:39.260 --> 00:38:43.800
need to use Event Avail and Still Down in
their applications for various reasons.

00:38:43.800 --> 00:38:47.140
We just didn't have a sort of
Carbon event savvy version of those.

00:38:47.230 --> 00:38:48.060
And that's fine.

00:38:48.060 --> 00:38:51.730
I mean, generally those two APIs give
you the information you need,

00:38:51.840 --> 00:38:55.160
but the real problem was that they
were kind of performance hogs.

00:38:55.390 --> 00:38:58.630
Not only does Event Avail tell
you whether or not one of these

00:38:58.630 --> 00:39:02.600
types of events is available,
but it also calls the run loop,

00:39:02.710 --> 00:39:05.900
which might fire timers,
and it may also flush your

00:39:05.950 --> 00:39:08.390
windows that are dirty,
which means that any given call

00:39:08.390 --> 00:39:11.140
to Event Avail may take a lot
more time than you want it to,

00:39:11.260 --> 00:39:14.990
considering most people use
Event Avail in a fairly tight loop.

00:39:15.320 --> 00:39:19.010
So, what we did is we implemented
AcquireFirstMatchingEventInQueue,

00:39:19.080 --> 00:39:21.850
which is kind of like a
Carbon Event Savvy version of EventAvail,

00:39:21.900 --> 00:39:24.520
without all the horrendously
expensive stuff underneath it.

00:39:24.580 --> 00:39:27.020
It just synchronizes our queue
with the Windows Server's

00:39:27.020 --> 00:39:30.330
queue and tells you real quick,
"Hey, yeah, this event is in the queue.

00:39:30.380 --> 00:39:30.950
Here it is.

00:39:30.950 --> 00:39:35.880
Have fun." It does not do any
flushing or anything like that.

00:39:35.880 --> 00:39:38.500
So you need to look at your code,
find all places where you're

00:39:38.500 --> 00:39:42.000
using EventAvail and still down,
and see if you can switch over to

00:39:42.000 --> 00:39:45.020
AcquireFirstMatchingEventInQueue
for Panther.

00:39:45.020 --> 00:39:48.720
Additionally,
it'll make things an awful lot faster.

00:39:48.720 --> 00:39:51.570
One sort of important thing to
note is that you can't do a direct

00:39:51.650 --> 00:39:56.340
one-to-one replacement from still down
to AcquireFirstMatchingEventInQueue.

00:39:56.340 --> 00:39:59.020
You're probably still going to
want to check button because,

00:39:59.020 --> 00:40:02.680
you know, that's generally the semantics
used--that's generally the semantics

00:40:02.720 --> 00:40:04.440
you desire when you use still down.

00:40:08.480 --> 00:40:12.880
So we had some requests from
accessibility developers for a way to

00:40:12.940 --> 00:40:15.180
look at other applications' events.

00:40:15.180 --> 00:40:18.640
They, for whatever reason,
need to watch the key downs and

00:40:18.640 --> 00:40:21.830
key ups and mouse ups and mouse
downs and other similar events as

00:40:21.830 --> 00:40:26.020
they happen in other applications,
generally for accessibility purposes.

00:40:26.120 --> 00:40:30.630
So we invented GetEventMonitorTarget,
which returns a Carbon Event event target

00:40:30.630 --> 00:40:34.780
ref that you can put handlers on for
these sort of low-level user events.

00:40:34.900 --> 00:40:36.370
And it only receives the low-level ones.

00:40:36.370 --> 00:40:38.320
It's not like we're going
to give you kEvent1,

00:40:38.320 --> 00:40:40.170
window activated events and whatnot.

00:40:40.220 --> 00:40:42.380
It's just the low level layer.

00:40:42.810 --> 00:40:45.190
So you can install handlers
for the events you want to

00:40:45.230 --> 00:40:46.690
see in other applications.

00:40:46.780 --> 00:40:50.090
And your handler in your
application will see those events.

00:40:50.090 --> 00:40:53.680
The first important note is that
there are times when the system puts

00:40:53.700 --> 00:40:55.700
itself in sort of a secure event mode.

00:40:55.700 --> 00:40:57.640
Password fields are the best example,
right?

00:40:57.640 --> 00:40:59.440
I mean, if the user is typing
in a password field,

00:40:59.440 --> 00:41:02.860
you don't want other applications
to see those keyboard

00:41:02.860 --> 00:41:04.820
input--see a keyboard input.

00:41:04.820 --> 00:41:06.810
So we will not send you those events.

00:41:06.810 --> 00:41:10.620
The other important thing to realize
is that Get Event Monitor Target can

00:41:10.620 --> 00:41:12.530
slow the system down in general.

00:41:12.530 --> 00:41:14.890
So you only want to use
it when you need to.

00:41:14.890 --> 00:41:17.740
And those of you who need to
use it already know who you are.

00:41:17.740 --> 00:41:20.870
This is not something for
general applications out there.

00:41:20.940 --> 00:41:24.090
And the reason why it slows things
down is because normally as the

00:41:24.090 --> 00:41:26.720
user types and clicks and stuff,
the Windows server just

00:41:26.730 --> 00:41:28.690
sends events to one process.

00:41:28.840 --> 00:41:32.080
Well, with Get Event Monitor Target,
if another application

00:41:32.170 --> 00:41:35.970
installs handlers for key ups,
key downs, mouse ups, mouse downs,

00:41:35.970 --> 00:41:38.460
the Windows server is
sending two copies out.

00:41:38.460 --> 00:41:39.330
And not only are there two copies out,
but there are two copies

00:41:39.330 --> 00:41:39.460
out of the entire system.

00:41:39.460 --> 00:41:39.460
So you can see that the
system is slowing down.

00:41:39.460 --> 00:41:39.460
And that's why you want to
use it when you need to.

00:41:39.460 --> 00:41:39.460
And those of you who need to
use it already know who you are.

00:41:39.460 --> 00:41:39.670
This is not something for
general applications out there.

00:41:39.670 --> 00:41:40.020
And those of you who need to
use it already know who you are.

00:41:40.020 --> 00:41:40.320
And those of you who need to
use it already know who you are.

00:41:40.320 --> 00:41:40.610
And those of you who need to
use it already know who you are.

00:41:40.610 --> 00:41:40.890
And those of you who need to
use it already know who you are.

00:41:40.900 --> 00:41:41.020
And those of you who need to
use it already know who you are.

00:41:41.020 --> 00:41:41.170
And those of you who need to
use it already know who you are.

00:41:41.170 --> 00:41:41.320
And those of you who need to
use it already know who you are.

00:41:41.420 --> 00:41:43.340
And that means your application that's
in the background normally being

00:41:43.340 --> 00:41:46.330
quiet and not consuming any resources
is suddenly consuming resources,

00:41:46.480 --> 00:41:49.170
taking away the user's ability
to use the program in the front.

00:41:49.170 --> 00:41:50.670
So don't use this unless you need to.

00:41:50.670 --> 00:41:51.900
It's very specialized.

00:41:55.260 --> 00:41:57.640
Let's jump right into the Menu Manager.

00:41:57.640 --> 00:42:00.230
The first Menu Manager API we
added is CancelMenuTracking.

00:42:00.240 --> 00:42:01.740
It does just what you'd expect.

00:42:01.950 --> 00:42:03.300
It cancels the menu tracking.

00:42:03.300 --> 00:42:06.100
So if you have some kind of need
where you want to programmatically

00:42:06.100 --> 00:42:08.200
stop the user from tracking
the menus-- I don't know,

00:42:08.200 --> 00:42:11.520
maybe you want to put up an
alert or do some other UI-- you

00:42:11.520 --> 00:42:13.680
can now do so programmatically.

00:42:13.750 --> 00:42:17.570
And we also send out a pair
of Carbon events whenever the

00:42:17.580 --> 00:42:19.180
menu bar is shown in hidden.

00:42:19.180 --> 00:42:22.990
This would allow you to-- certain
pieces of your interface may want

00:42:22.990 --> 00:42:25.550
to show or hide appropriately,
like your palettes and whatnot,

00:42:25.640 --> 00:42:27.260
whenever the menu bar is shown in hidden.

00:42:27.270 --> 00:42:30.020
So you just install handlers
for these pair of events on

00:42:30.020 --> 00:42:32.440
the application event target,
listen to it,

00:42:32.440 --> 00:42:35.000
modify your interface appropriately.

00:42:37.500 --> 00:42:40.210
But probably the best feature
we added to the menu manager was

00:42:40.220 --> 00:42:42.500
support for HIView-based menus.

00:42:42.500 --> 00:42:44.650
Now, coming into Panther,
we'd already HIViewified

00:42:44.750 --> 00:42:46.290
most of the system,
right?

00:42:46.550 --> 00:42:49.300
HIViews are controls,
so that was already done.

00:42:49.300 --> 00:42:52.240
The window manager got changed so
that now window frames and whatnot

00:42:52.240 --> 00:42:54.560
are drawn with compositing views,
so that was all in place.

00:42:54.680 --> 00:42:56.370
But the big missing piece
was the menu manager.

00:42:56.370 --> 00:43:00.360
And the menu manager was kind of this
weird environment where you had a quick

00:43:00.440 --> 00:43:03.750
draw port that didn't really point
to anything besides some buffer of

00:43:03.750 --> 00:43:05.220
bits that the menu manager managed.

00:43:05.230 --> 00:43:07.020
And on 9,
it would look those to the screen,

00:43:07.020 --> 00:43:09.420
but on 10, you know,
we got some other functionality for free.

00:43:09.510 --> 00:43:14.080
And MDEFs were confusing, I guess,
at best, and hard to do.

00:43:14.080 --> 00:43:17.620
And therefore, you didn't see a whole
lot of custom menus.

00:43:17.930 --> 00:43:20.480
Well,
HIView-based menus changes all that.

00:43:20.510 --> 00:43:23.080
Makes menu customization super,
super easy.

00:43:23.090 --> 00:43:25.540
But you just need to know a
few fundamental principles.

00:43:25.570 --> 00:43:27.620
And for those of you who
understand HIView already,

00:43:27.620 --> 00:43:30.050
this is going to be
really straightforward.

00:43:30.300 --> 00:43:33.020
So if you've got HIVs,
you need compositing windows.

00:43:33.120 --> 00:43:36.210
And that means every menu is now
drawn in a compositing window,

00:43:36.320 --> 00:43:37.460
just like you'd expect.

00:43:37.470 --> 00:43:40.100
It has the normal view hierarchy
of a compositing window.

00:43:40.100 --> 00:43:42.540
There's sort of a structure
view and there's a content view.

00:43:42.540 --> 00:43:45.020
But there's a few special
nuances of a menu view system

00:43:45.020 --> 00:43:46.570
that you need to be aware of.

00:43:46.650 --> 00:43:49.520
And the first is the notion
of the menu content view.

00:43:49.580 --> 00:43:53.200
The menu content view lives inside
the window's normal content view.

00:43:53.240 --> 00:43:55.450
And the menu content view's
responsibility is to draw

00:43:55.450 --> 00:43:56.620
all of the menu items.

00:43:56.640 --> 00:43:59.730
So of course, we have a standard menu
content view for our menus,

00:43:59.730 --> 00:44:03.410
and that's what draws icon text,
command key, and whatnot.

00:44:03.700 --> 00:44:07.700
Now the window's normal content view is
where the menu background gets drawn.

00:44:07.770 --> 00:44:11.150
In the case of our standard one,
we draw those Aqua lines.

00:44:11.850 --> 00:44:14.260
And if you're going to write
one of these custom menus,

00:44:14.360 --> 00:44:16.940
you need to be able to find out--you
need to be able to go back and

00:44:16.940 --> 00:44:18.220
forth between views and menus.

00:44:18.220 --> 00:44:21.460
So we've got two APIs that
facilitate that functionality.

00:44:21.460 --> 00:44:24.420
HIMenuGetContentView says, "All right,
given this menu ref,

00:44:24.610 --> 00:44:27.100
give me the content view
that's going to render it."

00:44:27.100 --> 00:44:30.920
And there's the inverse as well,
HIMenuViewGetMenu,

00:44:30.920 --> 00:44:33.130
which is really useful for
inside your custom menu view,

00:44:33.130 --> 00:44:33.480
right?

00:44:33.490 --> 00:44:38.190
You need to know which menu to render
so you can ask for it with that API.

00:44:40.120 --> 00:44:43.460
Now, there's not a lot of custom menus
out there because it's hard,

00:44:43.460 --> 00:44:46.210
but let me give you a little advice
on why you might want to make a custom

00:44:46.210 --> 00:44:47.840
menu and show you a couple examples.

00:44:47.840 --> 00:44:52.970
Basically, you'd want to do a custom menu
to get functionality that isn't

00:44:52.970 --> 00:44:55.080
already provided by our system menu.

00:44:55.080 --> 00:44:59.860
That is, to get a menu that's not just,
you know, text command keys.

00:45:00.050 --> 00:45:03.520
Good example of that would
be something like the finder.

00:45:03.520 --> 00:45:06.050
In Panther,
the file menu now has a menu item

00:45:06.050 --> 00:45:10.420
that allows you to change the
label of any given finder item.

00:45:10.510 --> 00:45:13.380
And that's actually done by a
custom HIView that's inserted in

00:45:13.420 --> 00:45:15.360
that menu implemented by finder.

00:45:15.480 --> 00:45:18.860
Another example that was shown up
here in the center is something like,

00:45:18.860 --> 00:45:19.880
we call an XY menu.

00:45:19.880 --> 00:45:22.560
It would be great for like a color
sort of palette like we show there,

00:45:22.560 --> 00:45:25.040
or maybe some kind of tool palette.

00:45:25.040 --> 00:45:27.920
And lastly, some menus in our system
really aren't menus,

00:45:27.940 --> 00:45:28.340
right?

00:45:28.340 --> 00:45:31.120
If you look at the volume menu in
the right-hand side of your menu bar,

00:45:31.220 --> 00:45:32.200
it's got a slider in it.

00:45:32.200 --> 00:45:34.180
It's not much of a menu,
but it displays like one.

00:45:34.680 --> 00:45:36.620
So, if you want to make a custom menu,
you to do some functionality like that,

00:45:36.690 --> 00:45:37.890
you would do it with the custom menu.

00:45:40.070 --> 00:45:44.400
Making one is very straightforward if
you already understand the architecture.

00:45:44.400 --> 00:45:46.030
We introduced HIObject in Jaguar.

00:45:46.030 --> 00:45:47.400
It's the object model.

00:45:47.400 --> 00:45:52.070
You can derive from base classes,
and we provide the base menu content

00:45:52.070 --> 00:45:55.460
view class as KHIMenuViewClassID.

00:45:55.470 --> 00:45:58.410
So you derive from that
using the HIObject mechanism.

00:45:58.410 --> 00:46:02.030
Now that you have your object class,
you can associate that view

00:46:02.030 --> 00:46:04.910
class with any given menu,
and then when that menu draws,

00:46:04.910 --> 00:46:07.420
it's going to display with
your--it'll actually create an

00:46:07.490 --> 00:46:11.600
instance of your custom view,
and then draw with that custom view.

00:46:11.600 --> 00:46:14.740
And since it's a normal HIView
in a normal compositing window,

00:46:14.740 --> 00:46:19.000
you can embed other views inside
your custom view as you need to.

00:46:19.000 --> 00:46:21.480
And after you've done that,
you just want to handle five fairly

00:46:21.480 --> 00:46:22.690
straightforward Carbon events.

00:46:22.730 --> 00:46:24.480
And in fact,
they're very familiar Carbon events

00:46:24.480 --> 00:46:27.360
that we've already had on
the system for a year or so.

00:46:27.360 --> 00:46:31.620
But the important thing to understand
is the protocol the menu manager

00:46:31.620 --> 00:46:33.720
uses with respect to part codes.

00:46:33.720 --> 00:46:38.010
So the control manager and HIView
often talk in terms of part codes,

00:46:38.010 --> 00:46:38.570
right?

00:46:38.570 --> 00:46:40.460
What part of a control was hit?

00:46:40.540 --> 00:46:43.500
What part of a control is the mouse over?

00:46:43.500 --> 00:46:45.800
But the menu manager always
talks in terms of menu items,

00:46:45.800 --> 00:46:48.490
and it wants to know the
same pieces of information.

00:46:48.520 --> 00:46:50.960
So the protocol with respect
to menu content views is that

00:46:51.340 --> 00:46:54.490
part codes correspond directly
to the equivalent menu item.

00:46:54.510 --> 00:46:57.220
If you receive an HIView event
that's asking for information

00:46:57.280 --> 00:46:59.800
about part code five,
give it information about menu item five.

00:47:02.720 --> 00:47:05.700
So the first event you want to
handle is KEventControlDraw.

00:47:05.730 --> 00:47:07.820
And in fact,
you wouldn't necessarily even need to

00:47:07.820 --> 00:47:12.690
handle this if all of your drawing was
done by just embedding other HIViews.

00:47:12.780 --> 00:47:17.020
But the responsibility
for KEventControlDraw,

00:47:17.020 --> 00:47:22.220
or for your content view
when it receives this event,

00:47:22.220 --> 00:47:22.600
is to draw your menu items
really straightforward,

00:47:22.600 --> 00:47:22.600
forward.

00:47:22.600 --> 00:47:22.600
Draw them however you need to draw them.

00:47:23.100 --> 00:47:26.410
But as the user's tracking
the mouse over a menu,

00:47:26.490 --> 00:47:28.480
the menu manager wants one
of those items highlighted,

00:47:28.490 --> 00:47:28.980
of course.

00:47:29.050 --> 00:47:30.640
So you need to draw that highlighted.

00:47:30.710 --> 00:47:33.620
The way you find out which item is
highlighted is by looking at the

00:47:33.740 --> 00:47:35.860
focused part of your menu content view.

00:47:35.920 --> 00:47:37.470
So you can call HIView getFocusedPart.

00:47:37.590 --> 00:47:39.500
That'll tell you the menu item
that's currently highlighted.

00:47:39.500 --> 00:47:42.940
So you draw that in the inverted manner,
or whatever is appropriate

00:47:42.940 --> 00:47:44.240
for your custom menu.

00:47:45.330 --> 00:47:49.270
Now, the second event you want to
handle is KEventControl hit test.

00:47:49.270 --> 00:47:52.580
The menu manager will send this event
to your custom menu whenever it needs to

00:47:52.580 --> 00:47:54.360
find out which item is under the mouse.

00:47:54.360 --> 00:47:57.710
So all you need to do is look
at the coordinate in the event.

00:47:57.710 --> 00:47:59.770
It's a view relative coordinate.

00:47:59.940 --> 00:48:02.390
Figure out which menu item
that corresponds to and pass

00:48:02.400 --> 00:48:04.150
that back in the Carbon event.

00:48:04.150 --> 00:48:07.280
And similarly,
the KEventControl get part region

00:48:07.280 --> 00:48:11.230
Carbon event will be sent whenever
the menu manager needs to know

00:48:11.230 --> 00:48:15.720
the total area that that menu item
occupies visually in the menu.

00:48:15.790 --> 00:48:18.390
So you look at the incoming part,
you build up a region that represents

00:48:18.390 --> 00:48:21.130
the bounding rectangle for that item,
pass it back in the event.

00:48:23.720 --> 00:48:26.950
The fourth event is
KEventControl Get Optimal Bounds.

00:48:26.950 --> 00:48:29.710
The menu manager will send this
to you sort of early at menu time

00:48:29.710 --> 00:48:33.660
when it needs to figure out how
big your menu would ideally be,

00:48:33.680 --> 00:48:34.350
right?

00:48:34.360 --> 00:48:36.360
This is assuming you've got
infinite screen real estate.

00:48:36.360 --> 00:48:40.410
So if you've got an 8,000 item menu,
make sure you return a

00:48:40.410 --> 00:48:41.880
really big rectangle.

00:48:41.880 --> 00:48:45.340
But the--one thing to note is
that your menu may be sized

00:48:45.370 --> 00:48:47.930
smaller to fit on a screen,
just like you'd expect,

00:48:48.010 --> 00:48:50.680
so you need to be prepared
to deal with that.

00:48:50.800 --> 00:48:53.460
And the way the menu
manager does scrolling,

00:48:53.460 --> 00:48:56.210
most of it is actually
handled automatically for you.

00:48:56.210 --> 00:48:59.240
But the way it scrolls you is by
offsetting your content view's

00:48:59.260 --> 00:49:01.030
bounds origin appropriately.

00:49:01.030 --> 00:49:03.930
So in your draw handler,
what you can do is look at your

00:49:03.930 --> 00:49:07.850
bounds origin and constrain drawing
appropriately to cover only those

00:49:07.850 --> 00:49:10.610
items that are visible on the screen,
which will speed up your menu a lot,

00:49:10.620 --> 00:49:13.560
right, if you've got a lot of menu
items that aren't displayed.

00:49:13.560 --> 00:49:15.430
There's no point in drawing those.

00:49:16.060 --> 00:49:18.070
So there's one last
Carbon event you need to handle,

00:49:18.160 --> 00:49:19.830
and that's to facilitate scrolling.

00:49:19.870 --> 00:49:22.630
It's KEventScrollableGitInfo,
and we introduced that

00:49:22.630 --> 00:49:25.370
in Jaguar as part of the
HI ScrollView Carbon Event Protocol,

00:49:25.430 --> 00:49:27.180
but we're leveraging it here.

00:49:27.180 --> 00:49:28.820
There's about, I think,
four or five pieces of data

00:49:28.820 --> 00:49:31.720
that you need to provide in
this event to the menu manager.

00:49:31.720 --> 00:49:35.430
Take a look in Carbonevents.h--actually,
no, I think that one's in HIView.h--to

00:49:35.450 --> 00:49:37.620
see what those parameters are.

00:49:37.620 --> 00:49:39.890
But they describe things like
how much of you is visible,

00:49:39.980 --> 00:49:43.930
how much total of you there is,
how much you want to have scrolled

00:49:43.930 --> 00:49:48.130
every time the user--or sort
of in every scroll increment,

00:49:48.140 --> 00:49:49.700
right, that kind of information.

00:49:49.700 --> 00:49:51.190
It's really straightforward.

00:49:51.590 --> 00:49:54.160
And the rest of the functionality
is all going to be taken care of

00:49:54.160 --> 00:49:56.050
for you by the base menu handling,
right?

00:49:56.100 --> 00:49:58.030
So if you just implement
those five Carbon events,

00:49:58.150 --> 00:50:00.160
you're going to have a
custom menu up and running.

00:50:00.250 --> 00:50:04.480
But there's a few more events you might
want to handle for various other reasons,

00:50:04.480 --> 00:50:09.000
if you need to do further customization
or change sort of the default behaviors.

00:50:09.000 --> 00:50:13.040
So the first of those is
KEventMenuCreateFrameView.

00:50:13.040 --> 00:50:16.910
This event is sent to your menu
content view when it needs--when the

00:50:16.910 --> 00:50:20.980
menu manager wants to know what the
window frame view should look like.

00:50:20.980 --> 00:50:23.540
This is the thing that actually
draws the menu background.

00:50:23.540 --> 00:50:25.720
By default,
the base handler will create a

00:50:25.720 --> 00:50:28.850
frame view that will draw the
normal Aqua line background.

00:50:28.880 --> 00:50:31.800
But if you want a custom background,
like a picture or something,

00:50:31.800 --> 00:50:34.560
you can handle this event and
create your own view and do

00:50:34.560 --> 00:50:36.290
whatever drawing you need to.

00:50:36.990 --> 00:50:40.440
The second event is
KEventMenuGitFrameBounds.

00:50:40.440 --> 00:50:45.070
This event is sent to the ContentView to
determine where the total menu area

00:50:45.070 --> 00:50:47.900
should be displayed globally on screen.

00:50:47.900 --> 00:50:52.110
Generally, they're going to pop
down from the menu bar,

00:50:52.220 --> 00:50:54.720
but you might have a
pop-up button or something,

00:50:54.730 --> 00:50:58.710
and it needs to position appropriately
relative to the item that the caller

00:50:58.710 --> 00:51:00.800
called pop-up menu select with.

00:51:00.800 --> 00:51:03.240
So there's a whole bunch of
data that gets passed into the

00:51:03.260 --> 00:51:06.190
GitFrameBounds Carbon event,
so you can decide or customize

00:51:06.190 --> 00:51:09.020
how exactly you want it to
be positioned on screen.

00:51:09.940 --> 00:51:11.500
Then finally,
does the K event menu become

00:51:11.500 --> 00:51:12.920
scrollable Carbon event?

00:51:13.000 --> 00:51:16.290
This Carbon event is sent to your
content view whenever your content

00:51:16.360 --> 00:51:18.340
view is a candidate for scrolling.

00:51:18.340 --> 00:51:21.450
And this will happen whenever
your content view represents

00:51:21.450 --> 00:51:24.550
the sort of leaf-node menu,
right, of a series of menus,

00:51:24.570 --> 00:51:27.310
because that's the one the
user can type select in.

00:51:27.330 --> 00:51:30.270
So you'll receive this event and
you can either block the default

00:51:30.490 --> 00:51:33.540
scrolling behavior if you don't
want any scrolling for some reason,

00:51:33.540 --> 00:51:36.700
or you can do your own scrolling behavior
if you've got really unique needs.

00:51:36.700 --> 00:51:38.210
You know,
maybe you need to scroll horizontally

00:51:38.210 --> 00:51:41.000
through a menu or something,
who knows.

00:51:41.000 --> 00:51:43.260
And so it comes with a lot
of info you can look at.

00:51:43.300 --> 00:51:45.820
Generally,
you want to--when you receive this event,

00:51:45.820 --> 00:51:48.970
you're going to want to install
a bunch of event handlers on the

00:51:48.970 --> 00:51:53.180
menu's window so that you can
receive other input and whatnot.

00:51:53.180 --> 00:51:55.850
And then when your menu is no
longer a candidate for scrolling,

00:51:55.940 --> 00:51:58.640
we send the K event menu cease to
be scrollable Carbon event to you.

00:51:58.640 --> 00:52:01.110
And that's where you tear down
all the handlers you set up

00:52:01.180 --> 00:52:03.460
when you became scrollable.

00:52:06.290 --> 00:52:10.230
So that's just sort of one
technique-- sort of the comprehensive

00:52:10.340 --> 00:52:12.640
technique for creating a custom menu.

00:52:12.780 --> 00:52:14.500
But it's certainly not
the only technique,

00:52:14.530 --> 00:52:14.950
right?

00:52:15.020 --> 00:52:16.910
If you've got a composited window,
you can do just about

00:52:16.910 --> 00:52:18.020
anything with that thing.

00:52:18.020 --> 00:52:20.480
There's all kinds of Carbon events
you can hook into to create views,

00:52:20.480 --> 00:52:22.500
and you can use existing
views on the system,

00:52:22.500 --> 00:52:24.350
and install Carbon event
handlers to handle user

00:52:24.350 --> 00:52:25.740
interaction and all that stuff.

00:52:25.830 --> 00:52:28.120
So there's lots of other techniques.

00:52:28.120 --> 00:52:30.430
We've got a piece of
sample code out there.

00:52:30.440 --> 00:52:33.940
It went on the website earlier this week,
so I suggest you go check that out.

00:52:34.010 --> 00:52:37.500
It shows, I think,
about four different custom menus.

00:52:37.530 --> 00:52:40.680
In fact, that was the app I used to take
the screenshots a few slides

00:52:40.730 --> 00:52:41.660
back of those custom menus.

00:52:41.660 --> 00:52:43.590
So it'll show you how to do all
three of those custom menus,

00:52:43.650 --> 00:52:46.490
plus one additional one,
which puts a picture

00:52:46.550 --> 00:52:48.920
as a menu background.

00:52:48.920 --> 00:52:51.190
So it's really, really good sample code.

00:52:52.300 --> 00:52:55.640
Let's jump right into the Window Manager.

00:52:55.640 --> 00:52:58.540
So the first API we added
there is HIWindowChangeClass.

00:52:58.540 --> 00:53:01.050
Now this is really cool because
it allows you to sort of

00:53:01.050 --> 00:53:05.080
polymorphically change a window from,
say, document to floating and back.

00:53:05.090 --> 00:53:07.160
So you can do some really
interesting UI there.

00:53:07.160 --> 00:53:08.800
You can sort of promote
things to a floater,

00:53:08.800 --> 00:53:10.450
you know,
change them around a little bit,

00:53:10.460 --> 00:53:12.040
so that's really neat.

00:53:12.040 --> 00:53:17.500
The next API we added is both sort of a
technology thing and a convenience thing.

00:53:17.610 --> 00:53:20.090
Right now,
if you need to programmatically

00:53:20.130 --> 00:53:23.100
flush a window to the screen,
the only way to do that

00:53:23.100 --> 00:53:24.510
was with the QuickDraw API.

00:53:24.620 --> 00:53:26.590
And if we're really
moving towards Quartz,

00:53:26.720 --> 00:53:29.140
it doesn't make sense to keep
you guys using the QuickDraw

00:53:29.140 --> 00:53:30.260
API to do the flushing.

00:53:30.330 --> 00:53:33.360
So now HIWindowFlush allows you to
do a flush on just a window ref.

00:53:33.360 --> 00:53:37.010
You can, you know, completely ignore the
implementation details of the

00:53:37.010 --> 00:53:38.680
fact that there's a port there.

00:53:38.680 --> 00:53:41.820
The other benefit is that flush time
now in the toolbox is more than just

00:53:41.820 --> 00:53:44.430
painting the bits to the screen,
right?

00:53:45.470 --> 00:53:46.940
We do other interesting
things in the context.

00:53:46.940 --> 00:53:49.110
We have a compositing view system,
like right at flush time,

00:53:49.190 --> 00:53:50.750
we look to see which of
your views are dirty,

00:53:50.750 --> 00:53:54.300
and we tell them to repaint right now,
and then we can flush that to the screen.

00:53:54.300 --> 00:53:56.410
And similarly,
window shadows often need to get

00:53:56.410 --> 00:53:58.080
recalculated right at flush time.

00:53:58.140 --> 00:54:02.170
So this HIWindowFlush API is this
one-stop shopping API to just say,

00:54:02.170 --> 00:54:04.920
"Hey, blit this window the way it
needs to be blitted now."

00:54:07.240 --> 00:54:10.790
With the advent of sheets,
more and more applications are adopting

00:54:10.790 --> 00:54:14.570
them and probably the number one piece
of feedback we heard about sheets is

00:54:14.580 --> 00:54:19.060
that you've got a document window,
an error happens, you put up a sheet.

00:54:19.130 --> 00:54:22.710
That document window is still sort
of mode-less with respect to the

00:54:22.710 --> 00:54:25.180
rest of the windows in your app
and you might get into a situation

00:54:25.180 --> 00:54:28.380
where you need to display another
sheet on that same document window.

00:54:28.380 --> 00:54:30.550
But the Aqua Human Interface
Guidelines say,

00:54:30.550 --> 00:54:32.870
"No, you shouldn't do that."
And unfortunately,

00:54:32.870 --> 00:54:35.550
there's no really good way to
find out if you've already got

00:54:35.550 --> 00:54:37.140
a sheet on your document window.

00:54:37.140 --> 00:54:41.700
So, HI Window is document modal target
is designed to solve that problem.

00:54:41.700 --> 00:54:45.780
It tells you easily in just a
one-stop shopping API for whether or

00:54:45.830 --> 00:54:48.100
not there's a sheet on your window.

00:54:48.100 --> 00:54:50.240
We also have a detached
sheet window API which will

00:54:50.240 --> 00:54:54.160
allow you to create a sheet,
display it and then recycle it

00:54:54.160 --> 00:54:57.030
for display at a later time as
opposed to just disposing it and

00:54:57.030 --> 00:54:58.920
then creating a new sheet later,
right?

00:54:58.960 --> 00:55:00.420
So,
this will buy you a little bit in terms

00:55:00.510 --> 00:55:04.600
of efficiency if you're constantly
reusing a particular type of sheet.

00:55:05.190 --> 00:55:07.970
We also send out a couple new
Carbon events having to do with Windows.

00:55:08.250 --> 00:55:10.770
You can think of this
as a Carbon event hook.

00:55:10.770 --> 00:55:14.320
KEventAppActiveWindowChanged gets
sent out whenever the active window

00:55:14.320 --> 00:55:16.120
in your application gets changed.

00:55:16.220 --> 00:55:19.210
So if you need to maintain
state or update some UI based on

00:55:19.210 --> 00:55:21.780
whatever the active window is,
you can just install a handler for

00:55:21.780 --> 00:55:25.210
this event on the application target,
and you'll be notified

00:55:25.240 --> 00:55:26.900
whenever that happens.

00:55:26.900 --> 00:55:30.200
Now the window manager will
automatically take care of rearranging

00:55:30.200 --> 00:55:33.930
windows on the screen whenever
the monitor configuration changes,

00:55:33.930 --> 00:55:37.240
or whenever the dock moves from
the bottom over to the side.

00:55:37.240 --> 00:55:39.550
So the window manager
will already do that,

00:55:39.590 --> 00:55:41.660
and it sends events to your application.

00:55:41.660 --> 00:55:44.200
I think they're KEventWindowConstraint
events to each window,

00:55:44.200 --> 00:55:46.600
so each window can deal with it itself.

00:55:46.600 --> 00:55:50.660
But if you need a global way to hook
into that and replace the window

00:55:50.660 --> 00:55:54.500
manager's entire batch of functionality,
you can now install a handler for

00:55:54.500 --> 00:55:57.860
KEventAppAvailableWindowBoundsChanged
on the application target,

00:55:57.860 --> 00:56:00.850
and then completely replace the window
manager's functionality if you need to.

00:56:10.450 --> 00:56:13.200
So we also enriched the
existing window transition API.

00:56:13.230 --> 00:56:16.150
The coolest part now, as you can see,
is we now support a

00:56:16.150 --> 00:56:17.340
genie transition effect.

00:56:17.370 --> 00:56:19.980
So you can genie whatever you
need to whenever you need to.

00:56:19.980 --> 00:56:21.530
It's not just for coming
in and out of the dock.

00:56:21.550 --> 00:56:23.560
And it'll give you the
standard UI for it,

00:56:23.680 --> 00:56:25.220
so you're going to match
the rest of the system.

00:56:25.220 --> 00:56:27.260
Now,
we also came up with a new API called

00:56:27.260 --> 00:56:29.080
Transition Window with Options.

00:56:29.080 --> 00:56:31.950
It's going to look very familiar
because it's based off the

00:56:31.950 --> 00:56:33.860
existing transition window API.

00:56:33.920 --> 00:56:35.860
But some of the options it
allows you to customize,

00:56:35.890 --> 00:56:37.100
it has to do with durations.

00:56:37.200 --> 00:56:39.180
You can make, say,
a window fade transition as

00:56:39.200 --> 00:56:40.550
fast or as slow as you want.

00:56:40.550 --> 00:56:44.350
You can speed up or slow down
the genie effect as you need to.

00:56:44.420 --> 00:56:48.270
And it also supports asynchronous
transitions so that you can just

00:56:48.270 --> 00:56:50.130
call Transition Window with Options.

00:56:50.130 --> 00:56:52.730
It'll return immediately,
and the transition will happen

00:56:52.730 --> 00:56:54.890
sort of behind your back
without you having to block,

00:56:55.010 --> 00:56:56.240
so you can continue processing.

00:56:57.500 --> 00:57:00.000
Now of course,
if you're using asynchronous transitions,

00:57:00.130 --> 00:57:02.400
you probably want to know when
the transition's finished.

00:57:02.400 --> 00:57:05.400
So we have a pair of Carbon events
to help you out with that.

00:57:05.400 --> 00:57:07.800
We have a kEventWindow
transition started event.

00:57:07.820 --> 00:57:13.400
It's sent to the window right
when the transition starts,

00:57:13.450 --> 00:57:16.790
so you can set up any
state you need to maintain.

00:57:16.790 --> 00:57:16.790
And then a kEventWindow transition
completed Carbon event when

00:57:16.790 --> 00:57:16.790
the transition is finished.

00:57:20.720 --> 00:57:24.200
Now, performance is not all just
about super-duper fast code.

00:57:24.200 --> 00:57:29.760
Super-duper fast code helps, of course,
but it's not the end-all, be-all.

00:57:29.760 --> 00:57:31.640
Some of it has to do with
perceived performance.

00:57:31.640 --> 00:57:33.840
How fast does your app seem?

00:57:33.920 --> 00:57:36.080
And one way we facilitate
that on Panther is through

00:57:36.120 --> 00:57:37.980
asynchronous window dragging.

00:57:38.080 --> 00:57:41.950
So traditionally on Mac OS,
when you wanted to drag a window--sorry,

00:57:41.950 --> 00:57:44.260
this is on Mac OS X--when
you want to drag a window,

00:57:44.280 --> 00:57:46.600
you click on its title bar,
the Windows Server has to send the

00:57:46.600 --> 00:57:48.700
click event to your application.

00:57:48.700 --> 00:57:51.800
Your application catches that event,
and either you call drag window or

00:57:51.800 --> 00:57:54.980
the toolbox calls drag window for you,
and then the user starts

00:57:54.980 --> 00:57:56.690
moving the window around.

00:57:56.780 --> 00:57:58.460
And there is a slight lag there, right?

00:57:58.460 --> 00:58:01.140
There's a cross-process
message that has to be sent.

00:58:01.230 --> 00:58:04.370
So if we can actually allow window
dragging at the Windows Server level,

00:58:04.470 --> 00:58:08.240
that process is going to be--we're going
to eliminate the cross-process message,

00:58:08.240 --> 00:58:10.640
and the drag is going to start
virtually instantaneously.

00:58:10.640 --> 00:58:14.100
It's much,
much faster perceived performance.

00:58:14.610 --> 00:58:17.500
The secondary benefit is
that if your app is busy,

00:58:17.500 --> 00:58:19.050
if you've got the
spinning cursor of death,

00:58:19.060 --> 00:58:22.500
or if you're doing some intense
computation and you can't

00:58:22.500 --> 00:58:25.060
service events very often,
the user will still be

00:58:25.060 --> 00:58:27.750
able to click your window,
even if your app is not

00:58:27.750 --> 00:58:29.330
generally responsive.

00:58:29.340 --> 00:58:32.100
Of course, the best part is that
it's real easy to turn on.

00:58:32.100 --> 00:58:35.300
We've got a new window attribute,
kWindowAsyncDrag attribute.

00:58:35.410 --> 00:58:39.240
You can specify that attribute
either in Create New Window or

00:58:39.250 --> 00:58:41.900
Change Window Attributes
later if you need to.

00:58:41.940 --> 00:58:44.850
But there's one very,
very important caveat.

00:58:45.010 --> 00:58:49.350
Because the Windows Server is
handling your window dragging,

00:58:49.480 --> 00:58:53.700
you are not going to receive a steady
stream of kEvent window bounds changing

00:58:53.700 --> 00:58:55.610
events as the window is dragged around.

00:58:55.750 --> 00:58:57.590
You will get them occasionally,
but they will be sort

00:58:57.590 --> 00:58:58.630
of like a hiccup effect.

00:58:58.740 --> 00:59:01.540
You'll get them every now and again,
sort of as the user pauses.

00:59:01.620 --> 00:59:05.670
So if you were relying on kEvent
window bounds changing to do some

00:59:05.670 --> 00:59:08.400
sort of custom window drag gridding,
you know,

00:59:08.400 --> 00:59:11.820
you want it to snap to various locations
or snap toolbars together and whatnot,

00:59:11.840 --> 00:59:15.840
it's not going to work real
well with async window dragging.

00:59:15.840 --> 00:59:17.410
So you've got a couple options there.

00:59:17.480 --> 00:59:20.450
The first is just don't
use async window dragging.

00:59:20.480 --> 00:59:23.080
You don't have to use it for all
the windows in your application.

00:59:23.080 --> 00:59:25.210
If your interface is better
served by that gridding,

00:59:25.210 --> 00:59:26.800
you know, keep doing that gridding.

00:59:26.970 --> 00:59:28.280
Don't turn on async for those windows.

00:59:28.280 --> 00:59:28.740
That's fine.

00:59:29.280 --> 00:59:31.760
Alternatively,
we do send out a kEvent window

00:59:31.760 --> 00:59:36.140
drag completed Carbon event
whenever a window drag is finished.

00:59:36.200 --> 00:59:39.860
So one thing you could do is install
a handler for that event instead

00:59:39.970 --> 00:59:41.780
of the bounds changing events.

00:59:41.780 --> 00:59:44.280
And then let the user drag the window
all around the screen wherever.

00:59:44.280 --> 00:59:46.380
Don't do the sort of live snapping.

00:59:46.380 --> 00:59:48.960
And then when the drag's finished,
you'll get the drag completed

00:59:48.960 --> 00:59:51.560
event and you can snap the window
to the correct location then.

00:59:51.590 --> 00:59:53.420
So you've got a couple options there.

00:59:53.420 --> 00:59:56.000
The other real important thing to
realize about asynchronous window

00:59:56.000 --> 01:00:00.570
dragging is that if you turn this on,
you don't want to call drag window when

01:00:00.670 --> 01:00:02.020
you finally receive the mouse down.

01:00:02.040 --> 01:00:04.780
Because you will receive that
mouse down in your application.

01:00:04.780 --> 01:00:07.580
And if you turn on async dragging,
receive the mouse down,

01:00:07.580 --> 01:00:11.180
and then call drag window yourself,
you're going to get a really weird

01:00:11.180 --> 01:00:12.980
effect as the window sort of jumps
around between two different locations.

01:00:12.980 --> 01:00:16.920
So make sure to take out your calls
to drag window and similar APIs.

01:00:18.050 --> 01:00:20.040
So I've talked about
an awful lot of stuff,

01:00:20.040 --> 01:00:21.120
and that's not even it.

01:00:21.120 --> 01:00:23.550
I mean, we have a couple other sessions
for HIToolbox where we talk

01:00:23.550 --> 01:00:26.930
about entirely other pieces of
functionality that we've added.

01:00:26.970 --> 01:00:29.840
But that shouldn't stop you from going
and implementing some of this stuff now.

01:00:29.840 --> 01:00:32.340
There's a lot of quick and
easy things you can do.

01:00:32.340 --> 01:00:36.200
You can conditionalize some of your code
for Panther such that it uses the HITheme

01:00:36.200 --> 01:00:38.420
APIs instead of the Appearance Manager.

01:00:38.420 --> 01:00:40.700
You're going to get a lot of
performance boost from that.

01:00:40.750 --> 01:00:44.870
You can use the replacement
for Event Avail and Still Down.

01:00:44.890 --> 01:00:48.660
You can start adopting
the new Aqua widgets,

01:00:48.660 --> 01:00:49.560
right?

01:00:49.560 --> 01:00:51.450
Start using that search field.

01:00:51.450 --> 01:00:55.630
Start using the segment view
when it's finally available.

01:00:55.660 --> 01:00:58.650
But even more important than that
is if you haven't started looking

01:00:58.720 --> 01:01:01.550
at the new technologies and our
underlying foundational technologies,

01:01:01.550 --> 01:01:03.140
you've got to start looking at that now.

01:01:03.150 --> 01:01:06.080
More and more of our stuff is only
going to work under this new model.

01:01:06.080 --> 01:01:08.410
You need to start learning
about compositing.

01:01:08.470 --> 01:01:11.750
Try turning on the standard window
handler in some of your windows.

01:01:11.820 --> 01:01:13.730
You are going to run through some issues.

01:01:13.730 --> 01:01:16.300
There is a little bit of a code
thrash that needs to happen,

01:01:16.300 --> 01:01:18.020
but it's not a very big code thrash.

01:01:18.020 --> 01:01:19.080
So go turn those things on.

01:01:19.080 --> 01:01:23.840
Start iteratively making these
improvements to your application

01:01:23.970 --> 01:01:27.410
so you'll be completely flexible
as we throw new technologies

01:01:27.480 --> 01:01:28.850
out there for you to use.

01:01:28.890 --> 01:01:32.200
Now this is something we actually did for
the new navigation services for Panther.

01:01:32.290 --> 01:01:35.360
The old nav was
completely dialogue based.

01:01:35.410 --> 01:01:38.710
It did all the event handling
itself except for a few edge cases.

01:01:38.710 --> 01:01:40.960
Therefore, nav was a really big binary.

01:01:40.960 --> 01:01:42.000
It did a lot of work.

01:01:42.000 --> 01:01:46.680
So as part of the new UI,
we actually switched navigation services

01:01:46.680 --> 01:01:50.050
over to using the standard handlers,
over to using compositing.

01:01:50.050 --> 01:01:53.740
And sure,
it took us a little bit of time,

01:01:53.920 --> 01:01:55.820
but the end result was great.

01:01:55.820 --> 01:01:57.680
We gave much better performance.

01:01:57.790 --> 01:02:01.140
We got to adopt all the new widgets.

01:02:01.140 --> 01:02:02.480
We got to use the
segment view and whatnot.

01:02:02.500 --> 01:02:06.080
We got to use data browser
and compositing mode.

01:02:06.080 --> 01:02:08.800
But the best thing is that we got
rid of a lot of code out of nav.

01:02:08.800 --> 01:02:13.970
The nav binary, which is more now in
Panther than it did in Jaguar,

01:02:14.060 --> 01:02:16.640
is still 10% smaller
than it was in Jaguar.

01:02:16.640 --> 01:02:19.210
So for your applications,
that's going to mean

01:02:19.280 --> 01:02:21.890
quicker download times,
less paging that needs to

01:02:21.920 --> 01:02:24.110
happen when your application
is loaded and things like that.

01:02:24.190 --> 01:02:25.140
So you got to get out there.

01:02:25.140 --> 01:02:27.550
Start adopting these new technologies
and move your applications

01:02:27.550 --> 01:02:29.840
to the future of Mac OS X.

01:02:29.840 --> 01:02:33.490
So now I would like to bring
back up Xavier to take us

01:02:33.490 --> 01:02:35.790
through the roadmap and some Q&A.

01:02:41.300 --> 01:02:42.300
Good job.

01:02:42.300 --> 01:02:48.680
All right.

01:02:48.680 --> 01:02:50.740
We have a couple of things that
are very important to understand,

01:02:50.740 --> 01:02:53.500
and hopefully that will make sense
for you guys on what we've been

01:02:53.610 --> 01:02:58.580
trying to achieve this year with
the sessions for Carbon developers.

01:02:58.580 --> 01:03:01.440
Very important, the data exchange option
for Carbon application.

01:03:01.440 --> 01:03:04.590
We have brand new services
for the PACE board.

01:03:04.920 --> 01:03:08.100
A new type, which is the UTI,
the uniform type identifier that

01:03:08.100 --> 01:03:10.400
we're going to be talking about.

01:03:10.480 --> 01:03:12.520
If you're interested in using that,
go and see that, because you'll have

01:03:12.520 --> 01:03:16.760
to use that in Panter.

01:03:16.760 --> 01:03:18.330
If you need more
information about HIView,

01:03:18.330 --> 01:03:20.740
if you have custom controls and
you'd like to take advantage

01:03:20.880 --> 01:03:24.380
of core graphics and this new
compositing view model that we have,

01:03:24.810 --> 01:03:28.240
please go to the session 425 Carbon,
where we'll talk really in detail

01:03:28.240 --> 01:03:33.820
about HIView and how your application
can take advantage of this technology.

01:03:33.820 --> 01:03:38.760
Two very important sessions this year,
we have something specific for optimizing

01:03:38.860 --> 01:03:40.660
performance for Carbon applications.

01:03:40.660 --> 01:03:43.930
We're going to be actually
taking you guys through a

01:03:43.930 --> 01:03:46.730
bunch of steps from networking,
file I/O,

01:03:46.730 --> 01:03:50.420
what you should do with Carbon events,
what type of compositing you

01:03:50.420 --> 01:03:53.020
should use when on what windows.

01:03:53.020 --> 01:03:55.980
We're going to talk about
things like APIs that maybe

01:03:55.980 --> 01:03:59.660
you should start moving out of,
that we should not be using anymore.

01:03:59.690 --> 01:04:02.060
A very, very good session.

01:04:02.060 --> 01:04:05.230
We have session 307 that's
going to be specifically for

01:04:05.230 --> 01:04:08.610
Carbon development and Xcode,
the new tools we released.

01:04:08.710 --> 01:04:14.040
The tools team has made a major effort
to actually have the tools integrate

01:04:14.040 --> 01:04:17.930
very well with what Carbon developers
are doing and with HIView,

01:04:17.930 --> 01:04:18.720
of course.

01:04:18.720 --> 01:04:21.150
You saw a little bit of that
through interface builder,

01:04:21.150 --> 01:04:23.850
but Xcode has some pretty cool
built-in support for debugging

01:04:23.850 --> 01:04:25.180
Carbon applications as well.

01:04:25.180 --> 01:04:26.180
Can I add one thing?

01:04:26.180 --> 01:04:27.150
Hey, David, what's your session number?

01:04:28.720 --> 01:04:29.600
4:23?

01:04:29.720 --> 01:04:33.180
There is one session that is not there,
which is session 4:03.

01:04:33.180 --> 01:04:34.060
Very cool session.

01:04:34.230 --> 01:04:36.910
A lot of people, primarily like you know,
are in my case,

01:04:36.910 --> 01:04:39.720
which is you know we all have
applications for Mac OS 9

01:04:39.720 --> 01:04:41.260
but are using Power Plant.

01:04:41.260 --> 01:04:43.430
And we have all these different
technologies in Carbon to

01:04:43.430 --> 01:04:46.100
use and we're wondering,
well, where should I start?

01:04:46.100 --> 01:04:49.150
That session is going to be
specifically on how to build a

01:04:49.380 --> 01:04:51.840
modern C/C++ application on Mac OS X.

01:04:51.840 --> 01:04:53.560
So you can think of it kind
of as a refresher course,

01:04:53.560 --> 01:04:56.130
if you need to kind of get reminded of
what the right way to do things are,

01:04:56.130 --> 01:04:58.020
you know,
to use run application event loop instead

01:04:58.020 --> 01:05:00.380
of wait next event and things like that.

01:05:00.380 --> 01:05:02.000
You know,
it'll give you the right pointers

01:05:02.000 --> 01:05:03.260
toward using the modern APIs.

01:05:03.260 --> 01:05:05.850
It's what makes you know
a modern C++ application,

01:05:05.850 --> 01:05:07.680
C or C++ application on Mac OS X.

01:05:07.680 --> 01:05:08.680
What should you use?

01:05:08.680 --> 01:05:13.390
We'll go through a Carbon event, HIV,
we have like a bunch of things for that.

01:05:13.670 --> 01:05:16.090
I encourage you to
assist to that session.

01:05:16.200 --> 01:05:18.580
I got him back.

01:05:18.680 --> 01:05:23.290
Should you need any questions,
you can contact me at xavieratapple.com.

01:05:23.320 --> 01:05:25.920
There is always my manager in
case I don't answer and I'm in

01:05:25.980 --> 01:05:27.130
Tahiti or something like that.

01:05:27.200 --> 01:05:30.200
And John Galenzi is also a really
good guy if you have Aqua questions.

01:05:30.200 --> 01:05:34.200
John Galenzi is actually our user
experience technology evangelist.
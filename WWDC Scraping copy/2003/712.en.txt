---
Title:  QuickTime for the Web
Year:   2003
Web:    https://nonstrict.eu/wwdcindex/wwdc2003/712/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

Good morning. I trust you've all had your coffee, or at least started to. We're just getting ready to come out with the third edition of QuickTime for the Web, and it's still a virtual book, but it's almost ready. Actually, it's at the printers now, and so if you do want to get a copy of the third edition with QuickTime 6.3, go over to the Morgan Kaufman booth in the main auditorium there in the area.

They've got a special going 20% off and free shipping if you want to order it at the show here, so it's kind of a good deal. It comes with QuickTime Pro, so you can do some authoring. This session is QuickTime for the Web, and we're going There we go.

That's me. I'm Steven Gulie, senior technical writer at Apple. And we're going to be talking about using QuickTime over the Internet. That's a really broad topic, so we're going to narrow it down some. We're really going to be talking primarily about putting QuickTime on your website. So we're going to try to bridge the gap between painfully technical and painfully non-technical, and just stick with painful. So it's mostly going to be about HTML. There will be some movie tricks for movie authors, a little bit of XML, and maybe some JavaScript if we can get that far into the presentation. We'll see how we're doing. We've got mainly HTML authors here or movie authors?

[Transcript missing]

This is going to be about how to put QuickTime movies on a web page, how to launch QuickTime Player from your web page, get those full-screen movies going, and how to play other media, MP3, MP4, anything you want to play using QuickTime besides a QuickTime movie.

Some specifics about working with MPEG-4 and QuickTime together, the way they play together and don't play together, and how to put live and pre-recorded streams on your web page, and to decide when to stream and when to use what we call Fast Start technology, and I'll get into that a little bit more. Putting media skins and chapter lists with streams, so mixing streaming and non-streaming content, which is kind of tricky, and a little bit about scripting QuickTime using JavaScript.

So, putting QuickTime on a web page. The main thing there is getting QuickTime to come up at all through the browser. You're coming through a browser interface, so the question is really how does the browser choose what player to bring up for multimedia, and how do you particularly make it choose QuickTime?

There are three HTML tags you can use inside of a web page to bring multimedia into a browser. The href tag, which is your standard hypertext link for text, the embed tag, which has been around for a long time, and the object tag, which is a little bit more recent. The href is the most obvious thing to do.

You put it in a text link, it says click here for the movie, and you link to a movie, and people click it, and why shouldn't you do that? Well, because it doesn't really work very reliably. The browser doesn't really know what file type it is here. You're not able to tell the browser what the file type is or what plug-in you want to use. You're just giving it a URL.

So the browser says, "Well, what kind of file do I have here?" And it asks the server, typically, if it's on a web server or if it's on a CD. It just looks at an internal table. But in either case, it's going to look at the file extension, either the server is or the browser is.

If it says "jpg," it goes, "Oh, it's a jpeg." If it's a PDF, it goes, "Oh, it's a PDF." If it's .mov, it goes, "Oh, it's a QuickTime movie." Hopefully. But it's up to the people who run the server to update the table, or the people who write the browser to keep that table updated. And people can fool around with those tables to some extent.

So if the extension is wrong, if you don't name your movie .mov, if it's just my movie .nothing, or if that's not in the table, then it typically shows up as text. Your movie shows up as a big screen full of text, and I think you've probably seen that sometimes.

You click a link and, "Gee, it's a screen full of text. It doesn't seem to be what they had in mind." And if the extension is in the table, then what happens? Well, let's switch over to the demo machine here. A number of things can happen, but it's not terribly predictable.

If all is well, then when you click this link, let's see if we can get a little bit bigger text here. Well, it's too big. Then what will happen is the movie will open in a blank window all by itself, which is not a terribly attractive way to display things typically. But that's not the only way it could happen.

It could happen in a window that's just specifically sized for that movie, or it could open in QuickTime Player, or it could try to open in Windows Media Player. All sorts of things can happen, and it's really up to the browser. And that's really not the choice that you want it to make. And even if it does open in QuickTime Player, then what happens?

It may download it and open it in QuickTime Player, in which case your viewer is sitting there waiting while the whole movie downloads before it starts. Or it may download it and then say, well, okay, well, that's good. If you've ever launched, click to a PDF link, you've probably seen this.

Sometimes it opens in the browser window, sometimes it opens in Preview, sometimes it opens in Acrobat, and sometimes it just downloads to your desktop and you have to double-click it. And again, those are not a lot of choices you want to leave hanging in the air. You want to be able to have some control over that.

So then what happens if QuickTime is not installed and somebody clicks that link? Well, you don't have any way to tell it what plug-in you want to use. So if the user doesn't have QuickTime, maybe they see a broken puzzle piece or they can complain and say, do you want a plug-in?

And they say yes, and then it goes thrashing around looking for a plug-in somewhere, but it doesn't know which one to get. Or it gives it the old college try. It says, well, I've heard of QuickTime movies. Maybe I can play that. And Explorer is really wonderful at that. It says, let's go for it.

I can play QuickTime movies that were authored before 1992. And usually what you see is a broken Windows media application player icon. And that's also now what you want to see. So the best way to do it is to use the embed tag. And again, if you're using a tool to do your HTML for you, you're using a... Go live or Dreamweaver then it will typically do this for you.

You drag a QuickTime movie on to the page and it will make an embed tag for you. And the way the embed tag works is it lets you specify the URL but also the file type so that it doesn't have to guess. And also the URL of the plug-in if it doesn't have one.

So, your source code looks like this. You've got your source which is the movie you want to play, the type, video QuickTime, the plug-ins page, apple.com/quicktime/download. So this and the height and width on the page. The browser gets the file type from the web server or the HTML.

If the web server doesn't know, you've put it in your HTML. If the plug-in isn't installed, it says, "Okay, I know which URL to go to to get it." And if the plug-in is installed, it opens in the current web page. I'll show you on the demo machine here.

So this is a little bit more attractive. Your movie's playing in the middle of a web The EMBED tag is almost painfully simple. You've got the source, the height and the width. The height is going to be typically the height of the controller of the movie itself plus 16. In this case, I've set it to 20 because it's just an audio movie, so the height of the movie itself is zero.

This is just a JPEG. But in this case, if this movie had opened alone in its own window, it just would have been an audio controller. And in this case, it's where it really belongs, so it looks a lot nicer. And that's the long and short of it. If that's all you do, you'll have done a lot of the right thing rather than just link to it. But there's more.

This doesn't always work just the way you want to. The notion of a plug-in was created by Netscape. When they invented the plug-in, they had this idea that browsers can display a lot of things, but people invent new media types that we can't display or don't display yet. People will create a media type and they'll create a plug-in. You'll say, my media type is Flash, so I'll have a Flash plug-in. When the browser sees a Flash media type, it'll load the Flash plug-in. All will be well.

But then things began to change so that multiple browsers, multiple plug-ins could handle the same material. MP3 and Smile are good examples. Reel handles them, QuickTime handles them, Windows Media handles them. There's all kinds of audio plug-ins that will handle an MP3. So when the browser sees an MP3 file, what plug-in should it call?

And if you look back at the EMBED tag, you'll see, we could say what plug-in to use if there was nobody who could handle that media type, or where to get it, rather. But we weren't able to say, this is the plug-in I want to use to play this media. All we can say is, it's a QuickTime movie, or it's an MP3 file. So who gets it if multiple plug-ins can handle it?

Well, with Netscape, the first one to register, with Explorer, the most recent one to register, and we kind of went through some mime type wars where different people's plug-ins would grab the mime types and put in continuous loops where at every interrupt it would look and see if somebody had taken its mime type and tried to get it back. But the answer, if you really want to use a QuickTime movie, is to use a mime type that only QuickTime registers for. And then you won't get into these conflicts.

And there are three QuickTime file types that you can use, but the two we most recommend are the .mov. Now, there were problems in the past where sometimes a Windows media player would claim the video QuickTime mime type, but that seems to be behind us pretty much now, and there are some new solutions I'll talk about a little bit further on that prevent that from happening. So that's now a good mime type to use. The other one that's really good to use is the QTIF file, which is the image QuickTime.

And nobody else registers for that. However, it's fairly rare. One of the problems you can get into is if your server doesn't know about QTIF files or PNTG files, they're not in their table, then you have to make sure that that's put in that table by your network administrator or by the webmaster. And it's not hard to do. It's a one-line command, but it's easy to get overlooked. There's also the .PNTG file, which is the ImageX Mac Paint type. And that is a mime type that I give to people, that I guarantee no one will ever take.

But if you use anything other than the .mov file to play a piece of media, you need to use the QTSource parameter. And the way this works is you say EMBED source equals, say, small QTIF. You have a small QuickTime image file. The browser says, oh, he wants to play a QTIF file. Who's registered for that MIME type? Well, only QuickTime, so it loads the QuickTime plug-in.

Then the Qt source plug-in says, this is, I'm sorry, the Qt source parameter. This is some data that you can just pass to QuickTime. Once you've passed the source and the height and the width to the browser, anything else you pass goes directly to the plug-in that gets loaded. So you can pass all kinds of information in your HTML web page to the QuickTime browser to get it to autoplay your movie, play at a different scale, do all kinds of neat stuff.

In this case, what you're telling it is, even though my source was this Qt IF file, that's not what I want you to play. I want you to play this movie. And you could also use that to play an MP3 file or an MP4 file or any of the 200 media types QuickTime can play on Windows or Macintosh. So if you wanted to use QuickTime to display a JPEG or a GIF, well, that's fine. And again, if they don't have it, you've got your plug-ins page and your height and width. Let me show you how Qt source looks on the demo machine. - 15.

And what you see here is that because we're using source and QTSource, because we're talking to the QuickTime plug-in, we can tell it to auto-play the movie and to set the volume at 25% so it's not overwhelmingly loud. And this basically says we've told it QuickTime image file is what it's going to get, but it never displays the QuickTime image file, which is good because in this case it's in another directory.

But the trick to making this work is the source file must actually exist. You really do need to have a QuickTime image file there. To make a QuickTime image file, you can open anything, like a single .gif in QuickTime Player and save it as a QuickTime image file using the exporter. So then you've got a little backup. But it doesn't really matter what it looks like because it's never displayed. QuickTime is the only plug-in that will try to display it and it knows better because you're telling it the QuickTime source is the movie, not the image file.

Now, there's a... That's the EMBED tag, and if this is what you use, then you're really going to go a long way. It's going to work in QuickTime every time QuickTime is installed. It'll get the QuickTime plug-in if it's not installed, and it will never be distracted by another MIME type.

There's also an OBJECT tag. The OBJECT tag is very useful because it lets you specify a particular plug-in, in this case an ActiveX control, using the ID, and it gives you the URL of the ActiveX control if it's not there. So on Windows, this is really terrific. You can use the class ID and code base that are here, and you can cut and paste them from our website. It's always the same. It's large, but it never changes, so it's static.

And the thing that's a little different is instead of saying the source equals my movie, you have a param whose name is source and value is my movie. But anything you would pass to QuickTime in the EMBED tag, you can pass in the OBJECT tag. It's just the parameter name and value are passed separately in a param element. And this is now getting a little closer to XML. It's a little more strict, so you have to close your OBJECT tag properly, not just leave it hanging.

But it's pretty nice. The browser gets the file type from the server. HTML, but it doesn't matter because you have told

[Transcript missing]

and David The OBJECT tag, as written here, will only work in Internet Explorer for Windows, not any other browser, not Internet Explorer on any other operating system.

However, you can put them together. And this gets to be a lot of code, but there's really not that much to it. What you've done is you've taken the OBJECT tag and stuck the EMBED tag right in the middle of it. And what this does is it says, okay, if I'm an Internet Explorer for Windows, I will use the class ID and code base, and I will get the QuickTime plug-in, period.

If I'm not, if I'm on another operating system or using another browser, then I'll use the MIME type in the source file to determine which plug-in to use, and the QT source will tell QuickTime which movie to play, and the plug-ins page will tell me what to do if QuickTime is not installed and I'm not an Internet Explorer for Windows. And let me just back up a little bit here. If you look at this EMBED tag, what if you just use the EMBED tag without the OBJECT tag? This works fine on Internet Explorer for Windows.

This works fine on all browsers and all platforms. You don't have to use the OBJECT tag. But if you're on Internet Explorer for Windows and QuickTime is not installed, You have a problem because Internet Explorer for Windows does not honor the plugins page tag anymore. Because it's not a plug-in, it's an ActiveX control.

At least I think that's the rationale. Anyway, if QuickTime is not installed, it will just say, I don't know what to do. And so the answer is to put this at least once in your website. If you have a gateway to your website, once the user gets the QuickTime ActiveX control, the embed tag works fine. So at least once they have to hit this object tag to know that this is the ActiveX control we want.

But I think you'll find that if you're using the latest generation of web generating tools, they'll surround the embed tag with the object tag anyway. There's a website, QT Bridge. They make a product called Pagiot, P-A-G-E-O-T. It's French, but it's free. And you can just drop your folder full of web pages on it, and it'll go through and turn all the embed tags into embed tags plus object tags. So there's lots of free automated help for this. You don't have to type it in every time.

But this is the belt and suspenders way to go, particularly if sometime in the future Internet Explorer decides to drop support for the embed tag and say, we're only using it for the web pages. We're only using the object. Then you'll really be glad that all your tags look like this, because they'll continue to work on every system. So don't use href, do use embed, or better still, use object and embed together. And are we, do you have any questions so far? Are we all kind of on the same page? Yeah.

Okay, the question is if Explorer takes the most recent plug-in to register for a MIME type and Netscape takes the first one, how does Safari work? Safari also takes the most recently registered for that MIME type. It's more like a Windows system now where there's a registry and the most recent person to alter the registry is the person who is listed in that registry. But let me show you here on the demo machine a little bit how that looks. Again, it acts the same. I'm going to make this a little bigger so you can see the text.

So you've got a class ID, you've got a code base, and David This is the ActiveX I want. This is where it is if you don't have it. Here's the EMBED tag. If you are not Internet Explorer for Windows, which obviously we're not, we're Safari on the Macintosh. I guarantee you that if you pass the MOV file type, Safari will bring up QuickTime. I don't think it even asked the question.

The question is, in the EMBED tag, don't we have a link to the Apple web page? And in fact, we do. It's the plug-ins page. I may have omitted it from the slide here just because it takes up a lot of space on the screen. Okay, now once you have QuickTime plugin talking to your web page, you can tell QuickTime to do a lot of interesting stuff. It's very web friendly.

You can tell it, for example, to autoplay the movie when it starts or to set a background color so that it matches the background of your web page, to have a controller on or no controller on so that you can have your own stuff going on that. Lots of stuff. Enable JavaScript so that you can have JavaScript control the QuickTime movie.

Set hotspots for a virtual reality. There's an href tag that lets you say, okay, if somebody clicks on the movie, open this URL. And that could be the URL of another movie or a different web page. Lots of things. Put it in kiosk mode so people can't save the movie. Tell it to loop the movie continuously.

If it's a virtual reality pano, you can set the pan tilt and field of view for it to open with, which is a really nice thing without having to go and alter the movie itself. QtNext. Say when this movie is done, play this other movie or open this other URL when the movie is done. Set the scale to play it twice as big, half as big as it normally is.

You can target a movie. When someone clicks on the movie, it causes the URL to open in a frame, in a browser window, in QuickTime player, or to replace the QuickTime movie itself, and I'll show you that in a moment. And you can set the volume. There's lots and lots of HTML-friendly features of QuickTime that you can access now and control directly from your web page.

So one of the first things I'm going to show you about that is using a poster movie. One of the problems with embedding movies in a web page is they're big. So if you've got a 26-megabyte movie file and somebody goes to your web page and it starts downloading, it's kind of rude, especially if they're on a dial-up.

They're kind of like, "Wait a minute, I don't know if I signed up for this." So you can use a single image to bring up the QuickTime plug-in and then warn the person that, you know, if you click this, something is going to happen, and then let that be the lead-in to play the QuickTime movie or to not.

And clicking the poster can act to do a number of things. Basically, it tells QuickTime, "I want to do something." And it could load another movie, it could load a web page, it could execute a JavaScript function, it could fire off a movie in QuickTime player. And the key to it is just the href tag.

You have a source, which is, in this case, let's see, where's--whoa, I left out the QT source, or someone did. But the QT source would be to your movie. And there's an href so that when you click on the movie, it opens that URL in the target if there's a target. Now, let me show you that. Over here on the demo machine.

Here's what we did for the Audubon Society. They didn't want the sound of the Loon, which is a big audio file, to load immediately, so here we have, it just says, click here for the QuickTime audio. This is a little poster sitting under the Loon, and if I click it, it loads a QuickTime movie.

Okay, the question is, is there a difference between the href and the Qt source? Yes. Qt source, okay. This is really kind of an interesting little tag. Look at this embed tag. The source is a small QuickTime image file, and all that does is tell the browser, I want to use QuickTime. The QuickTime source is actually a GIF. I can tell QuickTime to display any kind of file I want. I'm going to reload this page.

And you see this is a GIF, this little speaker icon in this text, this is just a GIF called Speaker GIF. It's got a height and a width. I'm opening it with QuickTime. When you open a GIF in QuickTime, it opens it as a still image, but it's now a QuickTime movie. I've turned the controller off because we don't want to play this movie, we just want to click on it.

I've set autoplay to be false because what's to play? If I click on it, that will launch the href URL, which will be loon1.move target myself. That says when I click on the movie, load this URL, and the target is the movie that I clicked on. Replace yourself with this QuickTime movie. Right now, we're looking at speaker.gif, and when I click on it, it will load loon1.move right where it is. It will replace itself with the movie.

Why am I using height 20 instead of height 16? 16 is the correct height for the controller. The reason is because the GIF was 20 pixels that I was given. I did this as a favor to some people who were doing a website. Yes? I'm sorry, I can't hear the question. Why don't we have a rollover? Why don't we use a rollover?

Sure, we could use a rollover. There are lots of ways to do this, but I'm just showing you a poster movie, which is basically a movie that you click to launch another movie. This is just one more technique in your arsenal of things to do. Yeah, but it should be included in the poster movie, in the poster frame.

Why don't you include rollover at the poster frame? Because you have to right-click on that frame. Oh, I see. Why don't I use a rollover instead of right-click on that frame? Sure, you could do that. That would be a fine thing to do. There's no particular reason why I didn't do that. Although sometimes you want people to click on the image, but yeah, a JavaScript rollover works fine there.

Okay. Now, another thing you can use a poster movie for is to launch QuickTime Player, and one of the reasons you might want to do that is so you can get a full-screen movie. Now, to launch a movie in QuickTime Player is pretty straightforward, but not terribly impressive.

You just set target equals QuickTime Player instead of target equals myself. But to get a full-screen movie, you need to have either a movie that's in full-screen mode, or you have to have some way to tell QuickTime, I want to play this movie in full-screen mode, even though it's not necessarily a full-screen movie.

But the short answer is to use target equals QuickTime Player, and... There are several ways to make a movie into a full-screen movie. There's an Apple script. You can use an Apple script to turn on full-screen movie mode for any movie and say, when this movie plays, it is to play in full-screen mode if it's in QuickTime player. There's a little free tool from Apple called Plugin Helper that will set that characteristic for you. You can use Cleaner or Live Stage to set that characteristic.

You can put a wired sprite inside the movie. Just drop it in there that's, I'm a full-screen sprite, and when I get loaded, I go to full-screen mode. Or you can use an XML text movie, and I'll show you about that in a second. Let me bring up a couple movies and show you a little bit more about that.

Here's a web page, and it's got a poster. When I click the poster, it's going to launch. Click the poster above to launch a full-screen movie in QuickTime Player. Why not use a rollover? Well, could have done that too. But the key is that you get a different view. Gee, that's a big way.

So here we set the movie to play a full-screen movie and quit when done. This is a really nice experience. When somebody comes to your web page and they click on something, it goes full-screen, the movie plays, then when it's done, they're right back at the web page like it was never there.

And it gives the impression that you've got a full-screen plug-in. There's no such thing. The browser gives a little space to the plug-in, but the plug-in now calls the QuickTime player, and QuickTime player can go full-screen and then drop back into the browser when it's done. So this is a really nice technique. here.

may show it to you in a larger way. Is this readable at all? Can you see that text? Maybe not. Okay, well, how big can we go? How's that? Getting somewhere? This is a really simple text file. This is an XML text file. And it just says, "I'm an XML text file. I'm a QuickTime media link." These first two lines are always the same, so you can cut and paste them. You don't have to remember that. Just type it in. Just cut and paste it.

All that really matters is your very last line here, "embed source equals." And here you just put in all your embed tags you would want to do. So you can set full-screen mode, autoplay, quit when done. It's really handy. This is a text file. And you can see it's a text file because I just opened it up with

[Transcript missing]

It'll warn me, "Hey, you can't just change file extensions like that." But yes, you can.

Well, so, XML, the miracle of XML. You take an XML file, you give it an MOV file extension, QuickTime will play it as a movie, and this is great. Now I can embed that movie in my web page, or I can call it from anything. It's just really terrific to have this capability at your fingertips. So that's kind of a neat technique I wanted you to know about. Okay, we've seen posters. No, no. The question is, is that only for Safari? That works in any web browser that's out there today.

Okay, we're getting some questions about this. Let me go into this a little bit more then. I think I have some other movies that illustrate this maybe just a little bit better. Obviously, I've kind of dropped a bombshell here. Everybody's going, wait a minute, what are you doing? Let's look at these.

The XML is not being interpreted by the browser at all. It's by QuickTime. We've got the browser to call QuickTime. This, by the way, is taken from the website for the book. Let's look at Special Delivery. Okay. So first we're just opening a movie in QuickTime Player. Then we're going a little step further and opening it in full screen.

Okay. Now, we didn't have to change the file type from a Text to MOV. We could have changed it to .qtl. .qtl is defined as Application QuickTime Player, and when you open a QTL file, the browser should automatically launch QuickTime Player. That's how real does it. They use .rm or .ram files, and the browser just knows to use their player. The problem is that, again, it isn't always registered for that. Sometimes it downloads and plays. It leaves what we call a mouse dropping behind. It leaves the QTL file behind on the viewer's disk.

We tend to use it as a MOV file, so it opens in the plug-in and then let the plug-in launch the player rather than ask the browser to launch the player. If you use any file extension besides MOV or QTL, the operating system is going to treat that as telling you what kind of file type it is. If you call it .jpg, it's going to try to open it as a JPEG. If you call it .txt, it's going to display it.

But if you call it a .mov file, or you use the QT source parameter to open it with QuickTime, it's going to try to open it as a .jpg. If you call it .qtl, it's going to try to open it as a .qtl. If you call it .qtl, it's going to try to open it as a .qtl.

That means you have a poster movie that calls an XML file that calls Yes, okay, here's the question. We have a poster movie that calls an XML file that specifies yet another movie, and that's right. So we're getting kind of several levels of indirection here, but that's how it works. But obviously the key is that it allows you to... The nice thing about doing it this way is that XML file can be generated by a Perl script or a CGI really easily. You don't have to actually generate movies and specify them.

You can just say play the movie of the day dot move and have a text file that spits out the right movie, which could be specific to the browser, to the user, to all kinds of things. So it's really handy to have that kind of indirection, although it is a little confusing sometimes. Okay.

Which versions of QuickTime will recognize the XML? QuickTime 4.1 and later, I believe. What we found is that since we have the auto-update in place, we're not finding old versions of QuickTime very often anymore. QuickTime 4 and later automatically update to 5, automatically updates to 6. Some people choose not to do the downloads, so you might hit QuickTime 5, but the likelihood that you'll hit something that can't interpret that XML file is very unlikely.

If you have a poster movie, a couple of things. Make the poster the size of the movie that you really want to play, plus 16, so there's room for a controller. Set the controller false for the poster, because otherwise people will try to play the poster instead of clicking on it.

Set the href parameter equal to the URL of the movie you want to play when somebody clicks on it. If you want the poster to morph into a movie, then set target equals myself. Let me show you just one more thing about that back in the demo machine.

Here we go. Multi-movie. Here we go. Here we've got a web page with three movies on it, but we really don't want to download all three movies simultaneously. So what we do is we say, "Okay, Flowers and chirping birds, sunshine and bunny rabbits all as well. Okay. So what we're seeing here is posters that link, that turn into movies when you click them. And I'll just show you something that I won't really explain, but it is in the book, which is that you can have a poster turn into a movie.

[Transcript missing]

and the poster movie doesn't have a controller because you don't want people to play it. You want people to click on it. So that's setting target equals QuickTime player. For full-screen movies, you can either make the movie itself a full-screen movie that just, when it plays, it plays in full-screen, or you can use XML to set full-screen mode to play any movie you want in full-screen. And any more questions about what we just covered?

OK, we're all on the same page, or else people are beginning to glaze over one way or the other. OK, let's look at playing some things besides QuickTime Movies in QuickTime Player or QuickTime Plugin. And why would you want to do that? MP3 audio, MP4, Flash, Smile, RTSP streams.

Some of these things, like Smile or RTSP, might be QuickTime Movies. And so you want to direct them to QuickTime, specifically because it is QuickTime. But why might you want to play an MP3 file in QuickTime? Well, because if you just load up an MP3 file and say, embed this and play it in whatever, you don't have any idea what's going to play it.

You don't know what it's going to look like. You can't really control it. You can't set autoplay or set the volume. You don't know if it's going to open an application, if it's going to download. QuickTime is pretty nice at this. It actually will play it for you, and it plays it while it's downloading.

And you can set it to auto start and set the volume level and set it to loop or set it to-- put an href on it. So if somebody clicks on your-- put a poster with it, so if somebody clicks on the poster while the song is playing, they're taken to your website with an opportunity to buy the album, that sort of thing.

So you can use QTSource to specify anything of the over 200 media types that QuickTime can play and say, no, I want to play this in QuickTime. And as we saw in this previous demo, you can display a GIF, but when somebody clicks on the GIF, take a QuickTime action based on that. So it's a really handy way to repurpose other media. And again, it's fairly straightforward. The source is some piece of media that only QuickTime registers for, and the QTSource is anything QuickTime can play. And I'll just go ahead and show you that.

Again here, this is not a QuickTime movie, it's an MP3, and we told it's QuickTime image file with the QT source as an MP3, so it's playing MP3 with QuickTime, even though QuickTime is not necessarily the registered plug-in for MP3, but we can make it play anything because we got the browser to let us talk to QuickTime.

Okay. So that brings us up to MPEG-4, which you would use similar techniques for. MPEG-4 and QuickTime are close cousins. The MPEG-4 file specification is based on the QuickTime movie file specification, and that means they're really, really similar. But they're not actually the same. So if it's an MP4 file, QuickTime imports it and makes minor changes in it before it plays it.

If it's a movie file, an MPEG-4 player is not going to be able to play it. And there's a lot of confusion around that, because people think of MPEG-4 as being a video codec or the AAC audio codec, and so they go, well, if it's an AAC audio, I can call it .mov or MP4. Not true. The files are similar but slightly different. So there are two important ways that you can use MPEG-4 in QuickTime. You can use MPEG-4 video or audio inside a QuickTime movie.

So we've got a QuickTime movie. It can show video compressed any one of a thousand ways. Well, MPEG-4 is one of those kinds of compression. It can do MP3 audio. It can do, you know, all sorts of compression techniques for audio. But AAC audio is one of them.

So if you'd use this, if you use QuickTime MPEG-4 video or audio in QuickTime movies, you have the advantage of being able to use the MOV file format, so you can mix and match with other kinds of QuickTime media. If you want AAC audio over your QuickTime virtual reality, okay, use MPEG-4 audio in a QuickTime movie. The other way to use MPEG-4 in QuickTime is you can create, play, and stream native MPEGs.

You can create MPEG-4 files. And this is really a cool way to go. It's interoperable with other ISO streams, files, and players. So you can use QuickTime to play MPEG-4 from other people's streamers or created by other applications. Or you can create MPEG-4 files in QuickTime and then play them in real or Windows Media Player with the correct plug-ins.

You can hint MPEG-4 files for streaming in QuickTime. You can author them. And you can use the MP4 file format. So it's really strong support for MPEG-4 in QuickTime, more than any other file type we've ever seen. And again, you just use the QT source if you want to play an MPEG-4 file, just like you would an MP3. Yeah?

The question is, why are we using Qt source for the MP4 file? Well, because anybody can register for MP4. You could have 100 different players. So you might not want to. You might say, hey, source equals MP4. Anybody who can play on MP4, please play it. I don't need QuickTime. I'm not worried about that. And if you want to reach the broadest possible audience, that might be a way to go.

But if you want to be sure that the MP4 is going to play in QuickTime because you want more control over the web page and that's the plug-in you want to use, then say source equals something QuickTime will play, Qt source equals the MP4. So this is a technique to play MP4 files in QuickTime or to force QuickTime player to be used to play the MP4 file. If you want to leave it up for grabs, that's also an entirely viable option.

Yes. Male #1: Okay. Here we're getting--the question is showing me that there's some confusion. An MOV file is not an MP4 file. You can't just change the file extension. If you open a movie in QuickTime and it has MP4 audio and video, you can either save it as a QuickTime movie or you can export to MP4.

And the audio and video will not be recompressed but it will be saved in the MP4 file format. If you just change MP4 to move and back and forth, bad things will happen because they're such close cousins that if you try to open an MP4 file in QuickTime and you tell it it's an MOV file, it will do a superficial look and go, "Yeah, it looks like an MOV file to me. This is a movie," and it will try to play it and then it's not going to work right.

And if you name a QuickTime movie MP4, it might open in another MP4 player or even QuickTime and it will go, "Yeah, this looks like an MP4 but it isn't." And again, things will go wrong. So it's very important not to just swap the file extension but to actually import and export. I see a question in the back.

I'm not sure I heard the question. Does it override the browser mime types? Oh, in the EMBED tag, you can set the mime type. And I think the question is, does that override the mime type of the file? Not reliably. The server will tell the browser what the mime type is, the extension will be mapped to a table, and you have the HTML.

And all three could be saying different things. So what should the browser believe? What's in its own table, what the server is telling it, or what you're telling it? It's really up to the author of the browser, and they have different opinions about that. So again, using source, you can only use the QuickTime file type.

You can't play MP4s in QuickTime using the source. If you use the source command to point to an MP4, it will go to whatever player is selected for MP4s. It might be QuickTime, it might not. If you use QTSource, it will use QuickTime to play MP4s or anything else.

MPEG-4 audio and video can be in a movie or it can be in an MP4 file. You can export movies to MP4. To force an MP4 file to use QuickTime, use Source and QTSource. Just use Source, it's up for grabs. But they're not the same. the same. More questions?

Okay, yeah. The question is, if you use QTSource, is it going to play in QuickTime even if something else is selected for MP4? Yes, because the source is what the browser looks at. The browser doesn't know anything about QTSource. It looks at that parameter and says, this is jibber-jabber to me. I know the source.

The source is a QuickTime movie or a QuickTime image file, so I'm calling QuickTime. Then QuickTime says, ah, I know what a QuickTime source is. I'll play this MP4 file. So the browser has no idea that it's dealing with an MP4 file. It just knows about the source file. By the way, make the source file small because the browser is going to download it. So just use a little image. QuickTime image file is good for that or a small QuickTime movie, a couple of K.

All right, and let me--I'm going to show you an MPEG-4 file just like the MP--actually, I'm going to open this in Internet Explorer because-- Here we've got an MPEG-4 file playing in QuickTime in Internet Explorer. I'm believing Internet Explorer does not know--this version of Internet Explorer does not know what an MPEG-4 file is, let alone know that QuickTime should play it. But it's happy to do it because it said the source is a QuickTime image file, so the QT source can be anything, it just doesn't know.

I'm sorry, can I hear that question again? Will it work if I leave the source empty, source equals MP4? Okay, will this work if you leave source equals MP4? Empty. Empty. Oh, leave the source empty? If the source tag is empty, then the browser has no idea what you want to do.

No. QuickTime will only load if the browser is told to load a file that it can't play and that the QuickTime plug-in is registered for. The file has to exist and it has to be of a MIME type that only QuickTime is registered for. And if QuickTime is not installed, then you want to have the Plugins page tagged there.

Now, there's a caveat for this. This is all somewhat less true in Internet Explorer for Windows because the OBJECT tag says, "I want the QuickTime plug-in. If it's not there, go get it." And whatever gets played is up to the plug-in. So it's less sensitive. When you use the OBJECT tag, you're saying, "We're playing it in QuickTime. I don't care."

So it's indifferent, but any other browser, any other operating system, you really need to use the source and QT source this way. But the key thing I'm trying to get across is that the movie and the MPEG-4 are a little different, and you can't just change the file extension or expect it to work the same way. Okay. So, let's change subjects all together and talk about streaming. Is everybody ready for a change in topic? Okay. Not me, I'm sorry. I'm bothering you, but I'm not clear about your answer.

I'm going to source MPEG-4 because I want to have open QuickTime. What I'm hearing is that Despite opening a source that's a QuickTime-enabled source, anyway, I have to say QuickTime source, always. Okay. The question is, if I set the source, if I understand the question, if I set the source to a QuickTime movie, can't I then set the source to an MP4 file? Why do I have to use QTSource? Because you can't have two source parameters in the same tag. If the source is one thing, that's what it is. So the QTSource is your other source. The source tag is for the browser, the QT source is for the plug-in.

All right. There's some great stuff happening in streaming, and streaming is a little different from the kind of movies we've been looking at here on our disk. It uses real-time protocols. The real difference between streaming and the movies we've been looking at is that streaming in these real-time protocols goes over the network in such a way that a one-minute movie is transmitted in one minute.

If you've got a fast Internet connection, it still takes a minute. If you've got a slow Internet connection and it can't hold the data, it's coming over in a minute. If it doesn't get through, it just doesn't get through. It just gets dropped on the floor. You can't buffer it up and watch it later. It's a real-time protocol. The good thing about that is you can carry live audio and video. Things are happening in real time, and there's no way to carry live audio and video except with streaming. You can't record it and play the recorded movie. It's happening now.

Another good thing is if you record a movie and you stream it, you can start streaming from any point in the movie. That's really nice. You've got a two-hour movie. People want to skip around, or you've got multiple lessons in a learning course. People want to go to lesson three or listen to that again. They don't have to download the whole movie to that point to watch it. They can just skip right to that point and start streaming from the middle of the movie. It supports multicast.

This is really a cool thing. If you have a movie and you've got a campus land. You've got a hundred people watching the movie. You're sending out a hundred copies of the movie over the network. You've all seen what happens when two thousand people fire up their laptops over the local airport network.

It gets pretty extreme. But if you send one copy of a stream to a multicast address, everyone can turn their computer to that multicast address and watch the movie, and you're really only sending out one copy of the movie over the network, and everybody is looking. Because a network, remember a packet network, it's kind of like postcards, right?

They go past everybody, but your computer only looks at the ones that are addressed at it. But if I say this is one that everybody can look at, then all your computers can look at it as it goes by on the bus or through the ether. You don't have to send multiple copies, so that's really nice.

That doesn't work over the Internet, but it works great over campus LANs and corporate LANs. The bad things about streaming are it has to fit within the available bandwidth. If you've got a 28 kilobit per second movie playing on a 27 kilobit per second connection, it doesn't play. You don't see anything, you don't hear anything.

The other thing is that because it's a real-time protocol, typically lost data is not retransmitted, and over the Internet there's some loss, so you have little artifacts, video, audio dropouts, things don't show up. And the third thing is it's limited to certain media types. Audio, video, text, and URL events. It sounds like a lot, gee, audio, video, and it is a lot. But there's no Flash, there's no VR, there are lots of things that you can't send, 3D models.

[Transcript missing]

So, how do you play a stream? How do you put a stream in a web page? It's a little different. Because it uses the real-time RTSP protocol, its URL is going to start with RTSP. And if you just embed it in a web page, what's going to happen is, even if it's .mov file, if it's RTSP, my server, my path, my.move, many times the browser will go, "Oh, RTSP. That means I better use Reel." Or, "Oh, that means I better use Windows Media Player." Or, "That must mean I use Joe's Streamer." So, what you do is you use source and QTSource. Ordinarily, with QTSource, QuickTime will tell the browser to get a file for it.

It will use the facilities of the browser to do the download, even though the browser isn't displaying it. So, you use QTSource, don't use browser. This is a tag which tells QuickTime not to use the browser to get the QuickTime source movie. And that way, the RTSP will not be redirected or misdirected. It says, "QuickTime, use your RTSP." So, you use your own resources to get this. It's usually pretty good. I think current versions will do that automatically for RTSP. Have I got a QuickTime engineer in the audience? Not today. Okay. I'm on my own. I believe that's correct.

So, another choice is you can use a text movie to embed a stream. And you saw how that worked with the XML. That could be an RTSP URL. There are a couple ways. A third way is to use a reference movie. If I open a stream in QuickTime Player and save as a self-contained movie, what am I saving? I can use a QuickTime movie that's basically a wrapper around a URL. And then I can embed that movie in a web page and it will open the stream when somebody clicks on it.

So let me kind of show you a couple ways to do a text movie. Let's see if this works. Go over here to the demo machine and I will once again show you a text file, the thing This is just an RTSP URL, and there are eight characters that precede that URL. RTSP, all uppercase, TEXT, all lowercase. This is known as the text atom hack, and I won't go into all the reasons for that.

But if you start a file with the characters RTSP, TEXT, and then immediately follow it with an RTSP URL, you can treat that as a QuickTime movie, and QuickTime will open that URL. But what do you have to do to make that work? Well, you have to say, "It's a movie file, not a text file. So instead of trying to display it, the browser will use, or the operating system will use QuickTime to display it."

Yeah, this is using a text movie instead of a reference movie. Again, a reference movie is I open the streaming QuickTime player, I save it, I've created a QuickTime movie. And that's a perfectly good way to go. Why would you use this instead? Maybe you don't want to create QuickTime movies, maybe you just want to generate text files because it's a hassle. It saves you a step. Again, if you're using PHP or Perl or something to generate these, you can generate these movies that are just, anything that can generate a text file can generate one of these movies. movies.

Hopefully, yeah, again, I just opened a text file. As a movie, I'm playing it. QuickTime is doing the right thing. And after a little buffering because we're coming from down under, I think we're -- -- up there with a few of his buddies like one giant lead, MaxiJazz. Steve Adubato: Live from Australia. Okay.

I'm sorry? Can you use chapters on a streaming movie like this? Can I use -- Oh, yes. Can I use chapters? Well, that--the question is, can I use chapters in that kind of a streaming movie? The answer is no, not exactly. To use chapters in a streaming movie, you really have to have a regular movie and a stream. Here's an example of a streaming movie. This is actually a webcast from Steve Jobs' keynote in 1999.

A really inspiring keynote that went on for two hours. So if you just wanted to know what he had to say about QuickTime at that point, It would be really nice to be able to just jam down there and see it. And so you can skip around. Time has become huge for us.

We announced QuickTime 4. QuickTime 4. Okay. So here's an example of a two-hour movie and how long did I have to wait to download the part I wanted. Use chapter lists with streaming movies that are long. They don't stream. Chapter lists do not stream. So what you have to do is you open the streaming movie up in QuickTime Player, then you add a chapter list.

In QuickTime Pro, this is a text file. It's really easy to do. There's free tools that will do it for you. Look around in the Internet utilities on the web. There's all kinds of cool stuff. It's really easy to do and it really enhances the value, especially for distance learning of long streaming movies. But the question was, "Can you do that with an XML file?" And the answer is, "No." The RTSP hack is just to pass an RTSP URL. If you want to do more elaborate mixtures, you really have to use a reference movie.

The first eight characters are case-sensitive. The question is, what part of the RTSP hack is case-sensitive? The first eight characters. The first four characters must be uppercase RTSP. The second four characters must be lowercase T-E-X-T. And what's happening is the QuickTime player is trying to open a QuickTime movie. It's looking for a movie atom. It says, "Well, I don't see a movie atom, but I see a text atom." It's the length of the text atom, the character's RTSP. That's why we call it a hack.

You can also use XML the way I showed you earlier, and that's a far more structured way, and that works beautifully. And then you can tell it to play it in QuickTime Player and full-screen, and you can pass all kinds of extra parameters, which is also very nice.

Oh yeah, here it is. Here's the XML version. So instead of using the RTSP hack, say you can't remember whether to use up or lowercase and it's confusing, just use the XML. It stays the same. Top first two lines are always the same. It's an XML, it's a media link. and you embed, you give it the MOV file extension and embed it just like any QuickTime movie.

[Transcript missing]

The question is, the gentleman saw earlier an XML file that you would drag and drop onto QuickTime Player that would turn into a movie file, and that was a media skin. Basically, QuickTime is moving towards XML. XML is the data format that's going to conquer the world. We thought it was MP3. We were wrong. It's XML. Basically, more and more as we go forward, you'll find that you can export anything from any format into XML and then import it into any compatible version.

What's happening here is this is a QuickTime XML, and we're giving it the EMBED tag. We're saying, okay, this is a QuickTime media link. Here's the source. If instead of QuickTime media link, it said QuickTime media skin, we would give it some image files. QuickTime has all kinds, a growing list of XML importers.

Basically, you will be able to pass all kinds of things as we go into the future to QuickTime as XML. The syntax will be very similar, but the actual parameters will typically be a little different. For skin, you'll want to give it an image file and a mask file, a drag region. For a movie, you'll just give it a URL.

Okay, embedding streamings in a web page, using a reference movie, I've pretty much talked about that. You open the stream, you save it as a self-contained movie, and it's just a wrapper for URL, it works great. The bonus is that you can then edit the movie to add things like the chapter list. And let me show you some other things you can add to streams.

Again, I don't have time to go into the techniques, and I don't mean to cheat you that way, but I think it's worth seeing some things. Here's a... Yeah. This is a QuickTime movie. It's got a media skin, so it doesn't look like a QuickTime movie. It looks like its own application.

And when we play it, We've got QuickTime VR here, so obviously this gets the media types that don't stream. I can interact with it, I can drag it around, I can drive myself crazy with it, but I can So here we've got a skinned player with a lot of things that are even more interesting, arguably, than a... This is one of those amazing Michael Schaaf productions that just blows your mind every time. Yeah, you can mix things with streams. So streaming is great and non-streaming is great, and mixing them is really--here's something a little bit--you don't have to be--something a little more understated.

Okay, the question is, how do you really do this? And the answer is, you open the streaming track in QuickTime Player and then save it as a self-contained movie. Now you've got a streaming movie. And then you can open that in QuickTime Player and edit it just as you would any other movie, to add Flash, add sprites. It's just one more media type that you're mixing in, and this media type is a streaming track, which is just basically a wrapper around a URL.

And here's Wilco. They've got really nice, high-quality MPEG-4 playing. And again, you see your player doesn't have to be... It doesn't have to be loud or abrasive. It can be just really attractive. There are some really nice ones coming out now, so it's a nice thing to do. Let me see if I can... That's for recorded streams, what I just told you. Live streams are a little different, and I will show you that now.

Pre-recorded stream, we just talked about that. When you add a media to a stream, you can either add it or you can add scaled. If you've used QuickTime Player Pro, it basically adds scale. It says, "Take the duration of the thing I've selected and add." If I want to add a still image to a streaming audio, I add scale. So you select the whole streaming audio and add this image for the duration of the audio. For live streams, it's a little trickier.

I wonder if I have a live stream I can open here. I think I do. I'm going to try to show you this, but first I'm going to explain it just in case I can't show you. You're going to open the stream in QuickTime Player and save it, but now you've got a pointer to a live stream. A live stream doesn't have a known duration. QuickTime doesn't know how long it is or where you are in the stream. It's always the eternal now.

So you have to disable the streaming track in order to do any editing, because editing is time-based. And that's the trick. If you use QuickTime Player Pro, if you're using another tool, it may be very simple. Say, open this live stream and add this media, and it just works. I think LiveStage just hides all that from you.

If you're trying to do it in QuickTime Player Pro for $30, then you have to jump through some hoops. But basically, the thing is you disable the streaming track, and that'll get your time slider back, bring in your other media, add scaled to the whole duration, and then re-enable your live track. And I'll try to show you that now. This is where the demo gets off into some interesting areas. Okay. Go right. Okay. And let's go mixing.

Okay, looks like we're getting a live stream here. Now as you can see, there's no time slider in the controls because we don't know what the story is with that. We don't know what time it is, how long it is, we can't skip backwards because it's live, we can't skip forward because it's live. But if I go into the movie, rather the edit, okay, let me do a command J, get information. Here's the movie, information, and it has one track which is a streaming track, and that's all it has. QDesign 2, it's classical music, it's lovely. All right.

And what I'm going to do now is I'm going to disable that track. Go to the Enable Tracks menu and say, "You are no longer enabled. Thank you." Now you see we have a time slider. So now if I want to open -- okay, here's Web Radio Move. Here's something that looks like a radio, and I'll extract a track from it. "The picture sounds good. Let's extract that. That's good. Okay. Now I have an image. It has a duration of... Oh, it's really long. Okay, cool. Okay.

So. Copy that. I hit Command--let me do it so you can see. Copy. And I just--when you copy with nothing selected, it copies the image that you're seeing. Okay, I didn't need to save that. Go back here and now select all, edit. I've scaled. Okay, and now I believe I can re-enable the streaming track.

Right. And now I have an image whose duration is more or less eternal right along. And so here I've basically added a picture to a live stream. It was a little tricky. I had to disable it and then re-enable it to get the slider. But obviously the principle here is pretty straightforward.

If you have a live radio station, you want to have it playing with the image of your radio station or the song that's being played. You don't want to have it just playing in the player. You can mix live streams with non-streaming media. And the book goes into great detail about other ways to do that.

Is there a QuickTime call to swap pics? There is a live sprite actions that you can use to swap things. You can have it as part of the movie. Yes, there are ways to make the image change with what's being broadcast. Okay, now, I think we've kind of gone over why you would stream versus fast start, embedding streams in a web page using source and QT source, text movies, reference movies, pre-recorded and live streams. Any questions about what we just dealt with? All right, we're on the same page. This is going good.

We have three and a half minutes. All right. Just real quick, if we had a -- if I have a live stream going like that and I want to put indexes for scene change with the question he asked about changing the picture, your standard like change the album art for the thing, but you want to do a live stream like off a radio station, not a sequence of concatenated MP3 files, how would you approach that?

What I would do is I would get ChannelStorm, which is an application that does just that. It's a live studio in software, and QuickTime supports this, but you can't do it easily from QuickTime Broadcaster. You need a little bit more sophisticated application that can say send an event stream, mix this current -- basically you're sending live -- what you're doing is you're streaming video as well as audio. It's just that your video has a very low bandwidth.

That's the short answer. And you could also send text with URLs if you wanted to load up a web page at that point. Yes? For streaming tracks, for streaming movie, can you add, can you stream href tracks? Can you add, excuse me? href tracks. href tracks. Yes, href tracks stream, actually.

So you can add an href track to a streaming movie or you can stream the href track. And an href track, for those of you who don't know, is a text track which consists of a series of URLs, but it's a QuickTime text track, so these URLs arrive at a certain time.

And basically it says, when I get to this point in the movie, load this URL. And let me, yeah, let me show you that over here. There's a little demo of it. Something like that. This is worth seeing. It's kind of cute. I'll just show it for you to see how it works. Doesn't look promising. Let's try this one.

Welcome to the audio tour. This is an example of a talking web tour. It combines an audio track and an href track. The href track loads HTML pages into the top frame, synchronized to the narration. The tour is controlled by the audio movie playing in the frame at the bottom of the page.

You can pause the audio movie at any time to explore links in the upper frame. This is live HTML and it's being driven by an href track in a movie, which is unexpected. I think we have a bug to report to Apache. Maybe I'll open this in Exploder.

Here's a tricky thing that browsers sometimes do. It's actually downloading the movie from the hard disk to a cache on the hard disk. That's another reason why you might sometimes want to use QTSource, don't use browser. If you're distributing large movies on a CD and you find that you just try to open the movie, the browser thinks that the movie is coming from the web because it's not really very intelligent sometimes.

It's trying to load this high-bandwidth movie from the disk, put it into a disk cache, play it out of the disk cache. It's basically doing three times the work it needs to do. If it's a high-bandwidth movie, it can choke or take a very long time. If you use QTSource, don't use browser, that avoids that. Bring the sound back up. Okay.

So this is as this movie plays along. The sample content for Chapter 3, "Bust a Move." So that's just to show you a little bit of some of the power of a HREF track. Other questions? Are these examples on the website? Some of them are on the website. They are all on the CD that comes with the book. And I'm putting more of them on the website all the time.

The new edition, the third edition with QuickTime 1 now and 6.3 in a couple weeks, we're just revving the CD as we go along and we'll be posting updates on the web. You can order it now from the Morgan Kaufman booth here at the show. They'll give you 20% off and free shipping. I think it's expected next week or in a couple weeks.

Two weeks. Okay. Real soon now. Male #1: Similar to the last thing that you showed, are you able in the skins to embed like HTML web functionality, kind of like a little mini browser, if you will, inside of the skin that interacts with the movie? Kind of the way this movie interacted with the page? Yes. The short answer is yes. And we're out of time. Thank you very much.

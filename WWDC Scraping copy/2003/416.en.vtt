WEBVTT

00:00:27.440 --> 00:00:29.280
I'd like to welcome you to session 416.

00:00:29.280 --> 00:00:33.530
Today we're going to be talking about
performance in your Carbon application.

00:00:33.700 --> 00:00:36.950
I suppose everybody has been seeing
what we've been doing with the G5.

00:00:37.110 --> 00:00:38.760
You probably went down to the lab.

00:00:38.820 --> 00:00:42.510
So the performance, it's a great machine.

00:00:42.710 --> 00:00:44.870
Applications are going to
get a boost in performance.

00:00:44.950 --> 00:00:46.990
You're probably all
very happy about that.

00:00:47.190 --> 00:00:48.850
It's very cool.

00:00:48.980 --> 00:00:52.920
Now you probably had a chance to install
Panther and run your application as well.

00:00:52.920 --> 00:00:55.900
You probably noticed that
actually a lot of operations are

00:00:55.900 --> 00:00:59.750
very fast in Panther because our
engineers spend a lot of cycles,

00:00:59.760 --> 00:01:02.870
a lot of resources,
and time to make sure that

00:01:02.870 --> 00:01:05.370
operations are very fast in Panther.

00:01:05.470 --> 00:01:10.670
We talked a little bit with Scott on
Monday in the Mac OS X session,

00:01:10.670 --> 00:01:13.720
the State of Union,
about things such as text

00:01:13.720 --> 00:01:15.940
drawing being twice as fast.

00:01:16.080 --> 00:01:17.800
All of this is great.

00:01:17.870 --> 00:01:20.600
But when our customers are
going to buy the next G5,

00:01:20.600 --> 00:01:23.720
the dual 2 gigahertz,
if they launch your application and

00:01:23.720 --> 00:01:27.060
they get the spinning cursor of death,
that's not good.

00:01:27.060 --> 00:01:29.940
That doesn't do us any good to have
the best machine on the planet,

00:01:29.940 --> 00:01:33.250
to have the best operating system,
if when somebody gets a

00:01:33.250 --> 00:01:36.400
third party application,
the performance level is not there.

00:01:36.400 --> 00:01:38.240
And this is really the
goal of this session,

00:01:38.240 --> 00:01:40.000
where we're going to
be talking about that.

00:01:40.270 --> 00:01:42.630
We're going to be talking about
how you guys can take your

00:01:42.630 --> 00:01:44.300
application to the next level.

00:01:44.350 --> 00:01:48.300
We're going to talk about tools,
because now we have actually very good

00:01:48.300 --> 00:01:52.290
tools to enable you to find out what
are the performance issues in your app.

00:01:52.460 --> 00:01:56.230
We're going to talk about technologies
that can help you improve the

00:01:56.330 --> 00:01:58.340
performance in your application.

00:02:03.820 --> 00:02:06.460
We're going to talk about two
different kinds of performance today.

00:02:06.460 --> 00:02:09.220
We're going to talk about
the real performance,

00:02:09.260 --> 00:02:13.710
which is how long does it take to
process an image that is 500 megabytes?

00:02:13.880 --> 00:02:15.510
How long does it take to run a filter?

00:02:15.520 --> 00:02:20.150
How long does it take to access the web,
to download a URL, to access a database?

00:02:20.240 --> 00:02:23.360
But we'll talk as well of what
we call perceived performance,

00:02:23.360 --> 00:02:25.920
which is what happens
when a person executes.

00:02:26.000 --> 00:02:29.590
Do you give feedback to your user,
or does the application

00:02:29.860 --> 00:02:31.360
look kind of hanged?

00:02:31.410 --> 00:02:35.110
And if there is one thing I want you
guys to realize and to understand

00:02:35.110 --> 00:02:39.650
with this session is that now I think
Apple has shown you that we spend

00:02:39.650 --> 00:02:42.920
a lot of cycle and resources and
we have an OS that is very fast.

00:02:42.970 --> 00:02:45.490
Mac OS X is way above mature,
and you're going to

00:02:45.490 --> 00:02:48.590
see with the hardware,
we've done an excellent job in looking at

00:02:48.590 --> 00:02:50.600
what we were doing wrong in performance.

00:02:50.970 --> 00:02:53.460
Now I think it's up to you
guys to go back to your rooms,

00:02:53.460 --> 00:02:55.850
to go back to your offices
and start using Shark,

00:02:56.060 --> 00:02:58.720
start using Sampler,
moving to Mac OS and use the

00:02:58.720 --> 00:03:00.400
latest technologies that we have.

00:03:00.450 --> 00:03:01.320
In the toolbox.

00:03:01.340 --> 00:03:02.150
In networking.

00:03:02.370 --> 00:03:03.380
In file IO.

00:03:03.440 --> 00:03:06.710
To really get the best of Mac OS X.

00:03:07.200 --> 00:03:09.860
And for that, I'd like to invite Curt.

00:03:09.970 --> 00:03:11.900
Curt is going to be talking
about all these topics,

00:03:11.900 --> 00:03:13.880
and I'll see you for a Q&A.

00:03:15.900 --> 00:03:21.100
[Transcript missing]

00:03:25.900 --> 00:03:28.740
Thank you, Xavier.

00:03:28.770 --> 00:03:34.220
So, like Xavier mentioned,
performance is critical

00:03:34.220 --> 00:03:35.660
to your application.

00:03:35.660 --> 00:03:39.060
If your app doesn't perform well,
users are going to make judgments

00:03:39.170 --> 00:03:45.240
about the quality and the polish of
your app and a Mac OS X as a system.

00:03:45.240 --> 00:03:48.280
So while we've been optimizing
parts of the toolbox and of Carbon,

00:03:48.280 --> 00:03:51.770
we've identified some techniques
to identify where there's

00:03:51.770 --> 00:03:55.460
performance problem areas,
and we'd like to share those with you.

00:03:55.700 --> 00:03:58.890
We've also identified some techniques
for improving those areas once you've

00:03:58.890 --> 00:04:01.100
identified what those problems are.

00:04:01.200 --> 00:04:02.970
And we'll share those with you as well.

00:04:02.970 --> 00:04:06.600
And also talk about new
technologies in Panther.

00:04:06.750 --> 00:04:10.670
And also to reacquaint you with some
technologies which will give you

00:04:10.670 --> 00:04:13.190
the best performance on Mac OS X.

00:04:14.480 --> 00:04:16.560
So there's four problem areas
I'm going to talk about today,

00:04:16.560 --> 00:04:19.030
and that's application launch.

00:04:19.100 --> 00:04:22.600
If it takes a long time for your app
to come up and start processing events,

00:04:22.660 --> 00:04:25.640
the user's going to feel as
if the system is sluggish.

00:04:25.770 --> 00:04:29.250
We'll talk about low-level services,
and that could be with

00:04:29.250 --> 00:04:32.650
your use of memory APIs,
how you're allocating memory,

00:04:32.810 --> 00:04:35.450
also with file network I/O and threading.

00:04:36.300 --> 00:04:37.120
Drawing.

00:04:37.120 --> 00:04:38.250
Now this is huge.

00:04:38.250 --> 00:04:40.480
This is a huge aspect
of your application.

00:04:40.480 --> 00:04:44.880
If the user clicks on a background
window and it takes a long time for that

00:04:44.880 --> 00:04:48.640
window to come up and draw its contents,
the user is definitely going to

00:04:48.740 --> 00:04:51.420
get the impression that your app
is sluggish or maybe the system

00:04:51.420 --> 00:04:52.900
is not performing very well.

00:04:52.900 --> 00:04:55.930
And finally,
we'll talk about poor responsiveness.

00:04:56.450 --> 00:05:00.310
So let's get right into talking
about application launch performance.

00:05:00.370 --> 00:05:03.470
So in identifying what you can do to
improve the performance of your app,

00:05:03.540 --> 00:05:08.480
it's good to figure out
what's going on during launch.

00:05:09.520 --> 00:05:12.000
Well, there's a lot of file I/O.

00:05:12.070 --> 00:05:15.120
The second the user clicks on your
icon or double clicks on your icon,

00:05:15.120 --> 00:05:18.680
the system starts loading in
the executable for your app,

00:05:18.700 --> 00:05:20.560
the associated resources.

00:05:20.650 --> 00:05:24.160
You're probably loading in preferences,
maybe registering and

00:05:24.160 --> 00:05:25.740
initializing plug-ins.

00:05:25.810 --> 00:05:29.560
And on top of all the file I/O,
the system or your app is doing

00:05:29.560 --> 00:05:31.900
its standard initialization.

00:05:31.900 --> 00:05:35.560
It's going through and allocating
large chunks of memory,

00:05:35.560 --> 00:05:38.960
maybe doing some table initializations,
et cetera.

00:05:40.140 --> 00:05:42.780
So how do you find
some of these problems?

00:05:42.820 --> 00:05:46.100
Well, during launch,
to identify problems with

00:05:46.100 --> 00:05:50.690
how you're utilizing the CPU,
launch it with Sampler.

00:05:50.740 --> 00:05:54.760
And Sampler's a utility that's
found in developer applications.

00:05:54.800 --> 00:05:57.280
And by launching it from the UI,
what Sampler does really is it

00:05:57.350 --> 00:06:02.060
takes a periodic snapshot of where
your app is in the execution.

00:06:02.160 --> 00:06:05.000
So when you're done sampling it,
it compiles this all together and

00:06:05.000 --> 00:06:08.710
you get a list of where most of
the time is spent in your app.

00:06:08.780 --> 00:06:13.980
And so you can identify areas that
you can focus on and optimize.

00:06:14.000 --> 00:06:18.040
Now in terms of the file I/O,
what's going on, you can use the command

00:06:18.040 --> 00:06:19.700
line utility FS usage.

00:06:19.700 --> 00:06:24.590
And this will allow you to identify
what areas are being--or what file

00:06:24.690 --> 00:06:29.020
I/O is happening on behalf of you by the
system loading in resources and whatnot.

00:06:29.200 --> 00:06:33.080
And you can identify--maybe you're
loading in files that you didn't expect

00:06:33.120 --> 00:06:36.910
to like document templates or images that
could definitely be referred to later.

00:06:36.940 --> 00:06:38.460
your time.

00:06:40.800 --> 00:06:42.240
So some solutions for this.

00:06:42.280 --> 00:06:45.050
All those areas that we talked about,
all the file I/O and all the

00:06:45.410 --> 00:06:49.530
initialization that's going on,
you have some control over.

00:06:49.710 --> 00:06:52.090
Now internally,
we compile our frameworks with

00:06:52.090 --> 00:06:55.490
the optimization for size,
and we recommend that you do that too.

00:06:55.610 --> 00:07:00.840
So this will make the binary smaller,
the system has to load less in.

00:07:01.010 --> 00:07:03.540
And you can do this in Xcode,
there's a preference

00:07:03.540 --> 00:07:06.900
for optimization level,
and you can use optimize for size,

00:07:06.900 --> 00:07:10.140
and you can also do that
using other compilers as well.

00:07:10.520 --> 00:07:13.400
What's really important is to
always provide feedback to the user.

00:07:13.470 --> 00:07:17.100
If it's going to take a really
long time for your app to launch,

00:07:17.110 --> 00:07:18.700
it's a good idea to
put up a splash screen.

00:07:18.700 --> 00:07:22.380
Let them know immediately that your app
has been loaded and things are going on.

00:07:22.400 --> 00:07:25.510
Even better than putting up a splash
screen is to provide some type of

00:07:25.700 --> 00:07:27.400
progress within that splash screen.

00:07:27.400 --> 00:07:29.910
Let them know that some
components are being initialized,

00:07:29.910 --> 00:07:31.400
new plugins are being registered.

00:07:31.410 --> 00:07:34.610
And the best solution of all
is to put up your main document

00:07:34.610 --> 00:07:36.390
window as fast as possible.

00:07:36.500 --> 00:07:38.770
This gives the user the impression,
this perception,

00:07:38.770 --> 00:07:40.400
that everything's up and running.

00:07:40.600 --> 00:07:43.050
Even if the foundation and other
parts of your app aren't really

00:07:43.100 --> 00:07:45.770
initialized and ready to go,
if you can get that document

00:07:45.770 --> 00:07:48.840
window up as fast as possible,
it gives them the impression

00:07:48.840 --> 00:07:50.200
that you're ready to go.

00:07:51.020 --> 00:07:53.660
You should also avoid I/O during launch.

00:07:53.660 --> 00:07:57.120
There's a lot, like I said,
that the system's doing on your behalf.

00:07:57.370 --> 00:08:01.050
If you can avoid reading in document
templates or some preferences that

00:08:01.050 --> 00:08:03.610
could be deferred to a later time,
that's excellent.

00:08:03.730 --> 00:08:05.930
And you should always avoid
writing during launch.

00:08:06.090 --> 00:08:09.050
Launch is considered a read-only process.

00:08:09.130 --> 00:08:11.230
You're reading in parts
of your application,

00:08:11.280 --> 00:08:12.270
getting ready to go.

00:08:12.350 --> 00:08:14.000
You shouldn't write.

00:08:14.630 --> 00:08:17.240
And then also take advantage of
lazy initialization techniques,

00:08:17.300 --> 00:08:18.970
and I'll talk about what
that means in a second.

00:08:19.080 --> 00:08:22.340
But it's a technique that allows you
to defer allocation and initialization

00:08:22.340 --> 00:08:24.830
of components to a later time.

00:08:24.910 --> 00:08:28.500
And closely coupled with this is
to avoid static class construction.

00:08:28.500 --> 00:08:34.480
If you're C++ based and you have a static
class defined in one of your modules,

00:08:34.500 --> 00:08:36.860
and what I mean by that is
a global that says static,

00:08:37.040 --> 00:08:38.500
foo, and then the instance.

00:08:38.780 --> 00:08:42.360
Keep in mind that that instance's
constructor is going to be invoked

00:08:42.580 --> 00:08:43.500
before main is ever called.

00:08:43.500 --> 00:08:46.400
So before you can even
start processing events,

00:08:46.410 --> 00:08:49.490
there may be a lot of code
that's being executed.

00:08:49.500 --> 00:08:51.500
So I mentioned lazy initialization.

00:08:51.500 --> 00:08:54.620
What does that really mean?

00:08:55.050 --> 00:08:57.780
Well,
rather than initializing a component in

00:08:57.780 --> 00:09:01.340
anticipation that it's going to be used,
just defer that until a later time,

00:09:01.340 --> 00:09:03.900
until that component is
actually going to be executed.

00:09:03.900 --> 00:09:09.300
And it's really as simple as defining
a static Boolean that's initialized

00:09:09.300 --> 00:09:12.900
to false to indicate that your
component hasn't been initialized yet.

00:09:12.900 --> 00:09:15.810
And later on during the
execution of your app,

00:09:15.980 --> 00:09:18.900
before that component is used,
check that flag.

00:09:18.900 --> 00:09:21.340
If it hasn't been initialized,
go ahead and initialize it

00:09:21.340 --> 00:09:22.900
and then toggle the flag.

00:09:22.950 --> 00:09:27.670
Now the reason lazy initialization is a
good technique on Mac OS X and was maybe

00:09:27.670 --> 00:09:30.900
not a good technique on classic Mac OS,
and what I mean by that

00:09:30.900 --> 00:09:35.250
is Mac OS 9 and earlier,
is because Mac OS 9 had really tight

00:09:35.310 --> 00:09:40.720
memory constraints and you had to deal
with the problem of memory fragmentation.

00:09:40.900 --> 00:09:43.830
So it was a good practice on Mac OS 9
and earlier to allocate as much as

00:09:43.830 --> 00:09:46.900
you needed up front that you knew
that you were going to be needing.

00:09:46.900 --> 00:09:49.620
So if that were to fail,
you could bail out as soon as

00:09:49.680 --> 00:09:52.900
possible rather than letting
the user make a document that,

00:09:52.900 --> 00:09:56.870
it may be a destructive operation
later on when you needed this memory.

00:09:56.900 --> 00:09:58.840
But on Mac OS X there's
a lot more memory,

00:09:58.840 --> 00:10:01.820
there's a huge virtual address space,
you don't need to worry about that.

00:10:01.910 --> 00:10:04.960
You should always code defensively still,
but be aware that lazy

00:10:05.020 --> 00:10:08.900
initialization is a good technique
to improve performance of launch.

00:10:11.310 --> 00:10:15.420
Now, next, we'd like to talk about the
low-level services such as threading,

00:10:15.420 --> 00:10:17.410
memory, and network and file I/O.

00:10:17.410 --> 00:10:19.100
And to do that,
I'd like to bring up the manager

00:10:19.100 --> 00:10:22.330
of the core services team,
John Iaroci.

00:10:30.750 --> 00:10:33.020
Thanks, Curt.

00:10:33.200 --> 00:10:36.280
So, threading, memory, and file I/O.

00:10:36.280 --> 00:10:38.840
What do these guys have in common?

00:10:38.840 --> 00:10:41.740
One of the things they have in
common is that they're often not

00:10:42.160 --> 00:10:46.250
very apparent when you're looking
at your application in terms of

00:10:46.340 --> 00:10:48.700
contributing to a performance problem.

00:10:48.700 --> 00:10:52.220
But the benefit in looking at problems,
performance problems in

00:10:52.220 --> 00:10:53.680
these areas is immense.

00:10:53.680 --> 00:10:58.700
You can get a lot of time back by
looking into these three general areas.

00:10:58.700 --> 00:11:04.860
I'm going to go through these areas,
both suggesting what APIs to use for

00:11:04.960 --> 00:11:11.900
these technologies and also some tips in
the areas in terms of figuring out what

00:11:11.900 --> 00:11:14.730
performance problems you have in them.

00:11:15.360 --> 00:11:19.020
So starting with threading.

00:11:19.070 --> 00:11:22.140
First of all, if any of you haven't
heard the message so far,

00:11:22.150 --> 00:11:24.880
the Cooperative Thread Manager,
the Carbon Thread Manager,

00:11:24.880 --> 00:11:28.800
is really not a...

00:11:29.200 --> 00:11:32.750
It was supported for
compatibility with OS 9,

00:11:32.760 --> 00:11:34.200
supported for the Carbon transition.

00:11:34.200 --> 00:11:38.090
It's not a great solution
for threading on Mac OS X.

00:11:38.300 --> 00:12:44.500
[Transcript missing]

00:12:44.990 --> 00:12:51.380
MPThreads and Pthreads are
both fully supported OS X APIs.

00:12:51.440 --> 00:12:54.390
There are some slight differences,
but they're very similar.

00:12:54.480 --> 00:13:00.030
It's mostly your choice
on which APIs to use.

00:13:00.140 --> 00:13:04.610
It's mostly going to be dictated
by the code base that you have.

00:13:05.570 --> 00:13:09.380
The thing to remember with
threading in general is don't,

00:13:09.560 --> 00:13:12.060
just because it's a
preemptive operating system,

00:13:12.060 --> 00:13:14.430
don't assume threads are free.

00:13:14.560 --> 00:13:19.000
They're backed by kernel resources,
so use them well.

00:13:19.000 --> 00:13:21.800
Make sure that you're making,
that you're just making

00:13:22.060 --> 00:13:23.420
good use of these threads.

00:13:23.500 --> 00:13:26.720
A lot of times,
because they're available,

00:13:26.720 --> 00:13:30.200
because they're kind of
a nice construct to use,

00:13:30.200 --> 00:13:34.500
it's convenient sometimes,
threads will be overused.

00:13:34.500 --> 00:13:37.390
And that will contribute to
your performance problems.

00:13:37.780 --> 00:13:41.500
Sometimes in a way which
is kind of hard to find.

00:13:41.600 --> 00:13:43.480
And I'm going to go into
that in the next slide.

00:13:43.500 --> 00:13:47.980
One good guideline that I'd offer you
is think about the work that you're

00:13:47.990 --> 00:13:50.370
actually going to do on that thread.

00:13:50.500 --> 00:13:53.500
Because remember,
you have to create the thread.

00:13:53.500 --> 00:13:54.420
At some point.

00:13:54.510 --> 00:13:58.300
And you have to message over in some
way to the thread to get it to do work.

00:13:58.500 --> 00:14:01.550
And oftentimes,
even if you create the thread

00:14:01.670 --> 00:14:04.710
and pass it some parameters,
you have to still wait for the

00:14:04.710 --> 00:14:07.500
thread to complete and then
message back to your main thread.

00:14:07.500 --> 00:14:11.500
So there are costs involved
just in using threads.

00:14:11.500 --> 00:14:13.820
Not to mention,
you typically have to lock

00:14:13.820 --> 00:14:15.370
when you're using threads.

00:14:15.730 --> 00:14:17.500
And there's a cost there too.

00:14:18.770 --> 00:14:22.250
Okay, in the tip area for threading,
first of all,

00:14:22.260 --> 00:14:25.450
if you're not already familiar with it,
in GDB there's some support for

00:14:25.740 --> 00:14:27.700
debugging threaded applications.

00:14:27.700 --> 00:14:33.200
The thread apply all directive
lets you do various GDB commands.

00:14:33.200 --> 00:14:37.210
The obvious one that most people
know is thread apply all stack

00:14:37.310 --> 00:14:40.200
crawl or backtrace so you can see
where all the different threads are.

00:14:40.700 --> 00:14:43.870
In Panther there were some
changes so that the ID that's

00:14:44.280 --> 00:14:47.700
reported in GDB actually maps
to your underlying Mach threads.

00:14:47.700 --> 00:14:49.750
So you can actually,
if you can't tell from the

00:14:49.790 --> 00:14:52.620
stack crawl or if you don't have
symbols for whatever reason,

00:14:52.690 --> 00:14:54.200
you can track it that way.

00:14:54.200 --> 00:14:58.140
The other tool to be
familiar with is Top.

00:14:58.180 --> 00:15:00.700
It'll tell you at least how
many threads you're using.

00:15:00.700 --> 00:15:05.700
This is good because you can actually
see if you have threads coming and going,

00:15:05.700 --> 00:15:08.320
how many threads you're getting
at kind of a high watermark,

00:15:08.320 --> 00:15:10.200
how many threads you typically have.

00:15:10.700 --> 00:15:15.170
And then look at those threads and see,
do you expect them to stay beyond

00:15:15.170 --> 00:15:17.700
the duration of a certain operation?

00:15:17.700 --> 00:15:20.160
Sometimes people just leave
the threads sitting there.

00:15:20.190 --> 00:15:21.700
They're not doing anything.

00:15:21.700 --> 00:15:27.100
There's kind of a trade off but you have
to decide in your app if it makes more

00:15:27.100 --> 00:15:29.990
sense to get rid of that thread or not.

00:15:30.200 --> 00:15:34.500
There are kernel resources associated
with it so if you're done with it,

00:15:34.510 --> 00:15:36.900
you might want to just clean that up.

00:15:37.290 --> 00:15:39.860
And then lastly,
I'd really encourage you to

00:15:39.860 --> 00:15:41.670
look at the Thread Viewer app.

00:15:41.810 --> 00:15:44.300
It's the best tool on the
system for actually visualizing

00:15:44.300 --> 00:15:46.910
what's going on with the thread.

00:15:46.990 --> 00:15:50.820
It lets you look on a per thread
basis how you're using memory,

00:15:50.930 --> 00:15:54.790
what kind of locking usage you have,
and thread priority.

00:15:55.710 --> 00:16:00.110
Okay, after threading,
I would really encourage you to take a

00:16:00.130 --> 00:16:06.340
look at how you're using memory APIs,
particularly the Carbon Memory Manager.

00:16:06.400 --> 00:16:11.170
First thing I'd like to say is
that when we looked at all of these

00:16:11.230 --> 00:16:15.210
APIs at the Carbon transition,
we actually looked at

00:16:15.210 --> 00:16:17.360
some of these and said,
"Do we really,

00:16:17.360 --> 00:16:20.870
really need them because there's some
issues there?" HLock and 9Hunlock,

00:16:20.870 --> 00:16:24.900
unfortunately, fell in the category of
they had to be there.

00:16:25.140 --> 00:16:29.580
They had to be there so your
app would continue to work on 9.

00:16:29.980 --> 00:16:32.760
So in order to enable a binary
that worked on both 9 and 10,

00:16:32.760 --> 00:16:34.820
we had to support HLock and HUnlock.

00:16:34.850 --> 00:16:37.920
There's really no good
reason to have them on 10.

00:16:37.930 --> 00:16:41.280
And there's a certain performance

00:16:42.400 --> 00:16:45.680
problem with frequent
use of HLock and HUnlock,

00:16:45.800 --> 00:16:49.500
especially when they're doing
nothing of use for your app.

00:16:49.500 --> 00:16:52.480
So take a look at how you're
using HLock and HUnlock.

00:16:52.480 --> 00:16:56.740
A lot of our apps internally we've
looked and seen we don't bother,

00:16:56.740 --> 00:17:00.800
we continue to use it and we
don't really need to use it.

00:17:00.800 --> 00:17:04.630
The only time that a handle is going to
be changed kind of out from under you,

00:17:04.720 --> 00:17:09.030
if you will, is when somebody explicitly
calls set handle size.

00:17:09.030 --> 00:17:11.560
So look and see if you're doing
that yourself or look and see if

00:17:11.560 --> 00:17:14.380
you're relying on the side effect
of calling HLock and HUnlock.

00:17:16.450 --> 00:17:20.640
And then in general,
memory and free are the APIs that you

00:17:20.670 --> 00:17:24.400
should be using for your everyday usage.

00:17:24.510 --> 00:17:27.120
The memory manager is another
layer on top of these,

00:17:27.170 --> 00:17:30.170
so it's not going to help having
that layer when you're really talking

00:17:30.220 --> 00:17:31.400
about performance sensitive code.

00:17:31.400 --> 00:17:35.060
And memory and free are what you
want to be using when you use our

00:17:35.060 --> 00:17:37.390
debugging and development tools.

00:17:39.220 --> 00:17:45.020
If you have seen Sampler
on the Panther seed,

00:17:45.020 --> 00:17:47.440
you've noticed that there's
new support in Sampler.

00:17:47.440 --> 00:17:50.600
It's really been revamped,
so it let you visualize some

00:17:50.600 --> 00:17:53.760
of your memory usage patterns.

00:17:53.760 --> 00:17:56.490
In particular,
tracing capabilities are there,

00:17:56.490 --> 00:17:57.660
which is fantastic.

00:17:57.750 --> 00:18:01.020
We've done a lot of performance
enhancements in Panther based

00:18:01.080 --> 00:18:03.300
on this technology,
being able to look and see how

00:18:03.300 --> 00:18:08.360
often we're allocating and what
kind of allocation patterns we have.

00:18:08.440 --> 00:18:12.760
You can also use Sampler directly
to look for your use of HLock and

00:18:12.760 --> 00:18:15.000
HUnlock and set and get state.

00:18:15.470 --> 00:18:19.760
And then of course, malloc-debug and the
leaks command line tool.

00:18:20.080 --> 00:18:22.730
That's both for the performance
of your app and the performance

00:18:22.860 --> 00:18:24.400
of the system in general.

00:18:24.400 --> 00:18:30.400
And I get in the habit myself of
just using top over in a side window,

00:18:30.400 --> 00:18:35.400
top-nash-w, so it shows you deltas,
so you can see if you have a leak

00:18:35.400 --> 00:18:40.260
or if you're growing larger than
you would expect to be growing

00:18:40.260 --> 00:18:42.590
during a particular operation.

00:18:43.430 --> 00:18:46.710
Okay,
so threading and memory is one area where

00:18:46.710 --> 00:18:51.130
you can really improve your performance
by looking at it with those tools.

00:18:51.290 --> 00:18:53.040
Files is another.

00:18:53.160 --> 00:18:57.020
Files is one where I really recommend
that you get involved with the tools,

00:18:57.020 --> 00:18:58.780
particularly FS usage.

00:18:58.920 --> 00:19:02.980
But let me start with the APIs.

00:19:02.980 --> 00:19:02.980
First of all,

00:19:03.500 --> 00:20:02.200
[Transcript missing]

00:20:02.530 --> 00:20:12.460
This particularly pays off over network
volumes and over non-HFS-like volumes,

00:20:12.460 --> 00:20:15.040
POSIX volumes.

00:20:15.260 --> 00:20:18.880
You'll see the benefit of using
these APIs on those kind of volumes.

00:20:18.990 --> 00:20:22.100
And I really encourage you to test
your applications on these volumes.

00:20:22.100 --> 00:20:24.000
You'll see different characteristics.

00:20:24.110 --> 00:20:28.670
It'll tend to exaggerate your file IOs,
and you'll see that it does

00:20:28.670 --> 00:20:30.070
impact your performance.

00:20:30.100 --> 00:20:33.080
In general,
the stance we've taken internally

00:20:33.080 --> 00:20:37.090
at Apple is to make sure that we
reduce the total number of IOs.

00:20:37.100 --> 00:20:41.640
Every single IO eliminated is
that much more time that you

00:20:41.640 --> 00:20:44.100
can devote to other things.

00:20:44.100 --> 00:20:48.060
And on a network, every single IO,
particularly on a flaky network,

00:20:48.100 --> 00:20:52.100
is a potential stall for your app.

00:20:52.100 --> 00:20:54.200
So consider that.

00:20:54.600 --> 00:21:59.500
[Transcript missing]

00:22:00.470 --> 00:22:04.140
And then in terms of how
to best use the APIs,

00:22:04.220 --> 00:22:07.790
make sure you use large
page line buffers.

00:22:07.910 --> 00:22:11.010
That's still a very good thing to do.

00:22:11.150 --> 00:22:14.540
And when you know you
don't want the data,

00:22:14.540 --> 00:22:16.640
you're just trying to write
something out to disk,

00:22:16.660 --> 00:22:19.150
you already have something in memory,
you're not going to go back

00:22:19.230 --> 00:22:22.340
and reread it from disk,
use that no cache bit.

00:22:22.430 --> 00:22:25.870
That'll stop us from
buffering it for you.

00:22:27.210 --> 00:22:33.440
Okay, in the area of networking,
CF Network, which has a pretty

00:22:33.440 --> 00:22:39.530
in-depth talk Friday at 5,
is our first answer for you for

00:22:39.530 --> 00:22:41.440
most of your networking needs.

00:22:41.490 --> 00:22:45.350
CF Networking is designed
to be very high performing.

00:22:45.400 --> 00:22:49.300
It's designed to work very well as an
asynchronous API with the run loop,

00:22:49.420 --> 00:22:56.280
the CF run loop or the Carbon event loop.

00:22:56.640 --> 00:22:59.330
There, again,
the guidelines are to use large

00:22:59.430 --> 00:23:03.500
buffers so that you avoid going in
and out of the kernel on your IOs.

00:23:03.500 --> 00:23:09.570
And if you really, really care about
optimizing your performance,

00:23:09.590 --> 00:23:11.620
particularly over varying
different link speeds,

00:23:11.620 --> 00:23:14.500
you probably want to look
at using adaptive solutions.

00:23:14.500 --> 00:23:17.500
So look at the size of your buffer,
see how much you read and write,

00:23:17.580 --> 00:23:22.070
maybe start with something conservative,
double it up until you get to

00:23:22.070 --> 00:23:24.480
a point where you think you're
getting a maximum throughput.

00:23:24.500 --> 00:23:28.970
This is particularly
important over slower speeds,

00:23:28.970 --> 00:23:31.890
slower speed links like modems.

00:23:32.340 --> 00:23:35.930
And then on the don't use
category of networking APIs,

00:23:35.950 --> 00:23:39.820
OpenTransport is another one of those
APIs which we brought to OS X to

00:23:39.820 --> 00:23:41.300
help you bring your apps over.

00:23:41.300 --> 00:23:44.300
It is not optimal.

00:23:44.300 --> 00:23:48.000
OpenTransport by itself has several
threads in its implementation

00:23:48.500 --> 00:23:51.300
and it's there for compatibility.

00:23:51.300 --> 00:23:52.300
We're not extending it.

00:23:52.300 --> 00:23:58.820
So the two really replacements is
either sockets if you really need that

00:23:58.820 --> 00:24:02.300
level of functionality or CF network.

00:24:02.300 --> 00:24:07.300
And then if you're at a higher
level and using URL access,

00:24:07.300 --> 00:24:10.120
there's two solutions there too.

00:24:10.310 --> 00:24:13.410
CF network if you really care
about some of the details of the

00:24:13.410 --> 00:24:17.300
protocol that you're dealing with,
so HTTP or FTP,

00:24:17.300 --> 00:24:22.300
or the new APIs in Web Foundation,
NSURL request and NSURL response.

00:24:22.300 --> 00:24:22.790
response.

00:24:25.530 --> 00:24:28.760
And then again, you can use FS Usage
for measuring network.

00:24:28.760 --> 00:24:31.830
And you'd be surprised,
just leaving FS Usage running on a

00:24:32.010 --> 00:24:38.040
terminal and just using your app lets
you see how you're using the network.

00:24:38.140 --> 00:24:40.620
And then the best tool,
particularly if you're interested in

00:24:40.690 --> 00:24:44.500
what's happening at the protocol level,
is TCP Dump.

00:24:44.970 --> 00:24:48.180
That's the best tool that
we offer to let you actually

00:24:48.220 --> 00:24:50.420
examine the packets in detail.

00:24:51.230 --> 00:24:54.050
Okay, and now I'm going to turn that
back over to Curt to talk to

00:24:54.150 --> 00:24:56.660
you about drawing performance.

00:25:02.470 --> 00:25:03.400
Thanks John.

00:25:03.400 --> 00:25:07.190
So next, we'll talk about drawing.

00:25:07.190 --> 00:25:09.700
Now like I mentioned,
this is a huge issue.

00:25:09.800 --> 00:25:12.970
If you're not drawing
as quickly as possible,

00:25:13.220 --> 00:25:16.320
and this is in terms of the
amount of your drawing or the

00:25:16.320 --> 00:25:18.580
efficiency of your drawing,
the user is definitely going to

00:25:18.680 --> 00:25:19.960
feel a sense of sluggishness.

00:25:23.680 --> 00:25:25.690
So there's three problems that
I'm going to talk about in

00:25:25.690 --> 00:25:29.200
terms of drawing performance,
and that's too much drawing,

00:25:29.220 --> 00:25:31.630
inefficient drawing,
and then there's the text

00:25:31.630 --> 00:25:33.580
performance aspect of drawing.

00:25:40.090 --> 00:25:41.480
So let's talk about too much drawing.

00:25:41.650 --> 00:25:46.750
That can be broken down into
problems of scope and frequency.

00:25:46.750 --> 00:25:49.480
And that means that in terms of scope,
let's say that you need

00:25:49.480 --> 00:25:51.820
to update one control,
and rather than updating that

00:25:51.850 --> 00:25:54.420
one control's visual state,
you're updating the user

00:25:54.630 --> 00:25:58.810
pane that contains it,
or maybe the entire contents of a window.

00:25:59.080 --> 00:26:02.600
And then in terms of frequency,
maybe that you're drawing periodically,

00:26:02.600 --> 00:26:08.180
you're drawing too much based on a timer,
or maybe you have a real

00:26:08.180 --> 00:26:12.080
time-based system that's pulling
in some information for display,

00:26:12.080 --> 00:26:14.810
but the user's disabled that,
so there's no sense in updating that.

00:26:14.920 --> 00:26:19.040
And that consumes resources from other
apps and utilities running on your system

00:26:19.040 --> 00:26:21.270
and generally slows down performance.

00:26:22.830 --> 00:26:25.100
So how do you identify whether
you're drawing too much?

00:26:25.100 --> 00:26:28.250
Well, an excellent utility
is to use Quartz Debug.

00:26:28.300 --> 00:26:31.720
Now this is in developer applications,
and this will allow you to

00:26:31.820 --> 00:26:35.800
identify problems both in
terms of scope and frequency,

00:26:35.870 --> 00:26:39.060
and it works with all Carbon drawing,
whether you're drawing

00:26:39.060 --> 00:26:40.650
with Quick Draw or Quartz.

00:26:40.950 --> 00:26:44.260
And to find problems in terms of scope,
you would check the checkbox for

00:26:44.390 --> 00:26:46.460
flash screen updates in yellow.

00:26:46.460 --> 00:26:49.000
And what this does is every
time something is drawn

00:26:49.000 --> 00:26:51.120
or flushed to the screen,
it'll show you the con-- or

00:26:51.120 --> 00:26:55.190
it'll flash in yellow that area
that's being drawn to the screen.

00:26:55.270 --> 00:26:58.540
So you can visually identify what
areas are being drawn too much.

00:26:58.600 --> 00:27:02.060
If you just need to be drawing
one control and you're drawing

00:27:02.060 --> 00:27:05.700
the whole contents of the window,
you'll be able to identify that visually.

00:27:05.930 --> 00:27:09.090
Now, in terms of frequency,
you can check the checkbox for

00:27:09.090 --> 00:27:11.260
flashing identical updates in red.

00:27:11.350 --> 00:27:15.230
And this will flash parts of your UI with
red every time the bits aren't changing

00:27:15.280 --> 00:27:17.250
but you're flushing the contents.

00:27:17.260 --> 00:27:21.640
So it'll help you identify where
you're drawing too much and these

00:27:21.660 --> 00:27:23.970
areas don't need to be flushed.

00:27:24.930 --> 00:27:27.600
So once you've identified
where you're drawing,

00:27:27.650 --> 00:27:28.690
how do you resolve this?

00:27:28.750 --> 00:27:30.200
Well, this is really up to you.

00:27:30.200 --> 00:27:32.600
You need to identify what it
is you need to be drawing,

00:27:32.750 --> 00:27:35.060
when you need to do it,
and you need to go through

00:27:35.060 --> 00:27:38.740
your own code and figure out
these areas for optimization.

00:27:38.890 --> 00:27:41.150
Now, of course,
we have technologies that we'd

00:27:41.150 --> 00:27:43.930
like you to take advantage of,
which will help in that,

00:27:43.930 --> 00:27:46.110
and I totally recommend adopting HIVU.

00:27:46.270 --> 00:27:48.230
And the reason for this,
and this is for your custom content,

00:27:48.240 --> 00:27:51.170
and this is also known
as compositing mode.

00:27:51.170 --> 00:27:54.730
And the reason I encourage you to adopt
it is because it is designed specifically

00:27:55.140 --> 00:27:56.960
to draw as little as possible.

00:27:57.040 --> 00:28:00.380
It's based, it's architected around
an invalidation model,

00:28:00.380 --> 00:28:04.400
which is superior to a drawing model,
because when multiple areas

00:28:04.400 --> 00:28:08.030
of your view need to change,
you invalidate those areas,

00:28:08.050 --> 00:28:12.490
and then the view system will come down
and call your main draw bottleneck,

00:28:12.490 --> 00:28:15.760
so you'd only be drawing when
the system is telling you to.

00:28:16.500 --> 00:28:19.190
So this encourages the use of,
if you need to update multiple

00:28:19.190 --> 00:28:22.260
parts or many parts of your
app or your view all at once,

00:28:22.370 --> 00:28:25.050
there will only be one
net draw operation.

00:28:25.060 --> 00:28:28.560
It also allows you to specify opacity.

00:28:28.560 --> 00:28:31.200
And this is important because
any view system is a hierarchy.

00:28:31.200 --> 00:28:36.220
And that your view may need to be
drawn after the views behind it.

00:28:36.340 --> 00:28:40.320
Like if it's embedded in a user pane,
which is also embedded in a window.

00:28:40.700 --> 00:28:43.580
If there's any type of
transparency with your view,

00:28:43.580 --> 00:28:46.520
all of these views behind
need to be drawn first.

00:28:46.560 --> 00:28:51.590
Well, HIV can optimize this if you
indicate to it that you are opaque.

00:28:51.590 --> 00:28:54.440
Your view is opaque or maybe
part of your view is opaque.

00:28:54.460 --> 00:28:58.420
And the view system can optimize by not
drawing the contents behind your view.

00:28:59.850 --> 00:29:03.680
I encourage you to go see session 425,
"HIV in Depth." This will give

00:29:03.680 --> 00:29:06.240
you more information about HIV.

00:29:07.410 --> 00:29:10.970
Okay, well, my content's not in HIView.

00:29:10.970 --> 00:29:12.140
It's not drawing in a composite window.

00:29:12.140 --> 00:29:13.540
What can I do then?

00:29:13.650 --> 00:29:17.580
Well, keep in mind that every time you
change the state of your controls

00:29:17.580 --> 00:29:20.240
or a value of your control,
that control's going to need to

00:29:20.240 --> 00:29:21.750
redraw in a non-composite window.

00:29:21.880 --> 00:29:23.380
For example, a scroll bar.

00:29:23.530 --> 00:29:28.240
When you set the minimum, the maximum,
and the value of that scroll bar,

00:29:28.270 --> 00:29:30.500
it's going to be drawing three times.

00:29:30.600 --> 00:29:32.750
Another good example is
the pop-up button control.

00:29:33.010 --> 00:29:35.310
When you add items to that control,
each time you do that,

00:29:35.350 --> 00:29:36.280
it's going to redraw.

00:29:36.510 --> 00:29:39.300
So if you need to do any
type of bulk value operations

00:29:39.400 --> 00:29:43.460
in a non-composite window,
hide that control.

00:29:43.460 --> 00:29:45.980
Do these bulk operations
and then show that control.

00:29:46.070 --> 00:29:48.790
So rather than having a draw
count of n for that many of

00:29:48.910 --> 00:29:52.660
operations you're going to do,
you'll have a net draw count of one.

00:29:52.660 --> 00:29:54.820
Also,
you can mimic HIView-like behavior by

00:29:54.820 --> 00:29:57.220
paying attention to update regions.

00:29:57.310 --> 00:29:59.860
So don't draw things
that are already valid.

00:29:59.860 --> 00:30:02.720
So you can pay attention to
update regions if you're paying

00:30:02.720 --> 00:30:04.390
attention to update events.

00:30:04.400 --> 00:30:08.500
Or you can mimic behavior by
using the window the valid window

00:30:08.500 --> 00:30:11.610
rect or valid window region APIs.

00:30:13.300 --> 00:30:15.850
So next area of drawing problems,
performance problems,

00:30:15.880 --> 00:30:17.800
is inefficient drawing.

00:30:17.860 --> 00:30:20.930
Now this may be because you're
doing too much work to get the

00:30:21.010 --> 00:30:23.040
bits you need onto the screen.

00:30:23.040 --> 00:30:25.210
And that could be because
you're using the wrong APIs or

00:30:25.210 --> 00:30:29.250
using APIs inefficiently,
or maybe there's some better alternatives

00:30:29.250 --> 00:30:31.370
on Panther to do your drawing.

00:30:33.120 --> 00:30:37.050
So again, how do you identify that
you're drawing inefficiently?

00:30:37.170 --> 00:30:40.590
Well, the best technique is to
sample your drawing code.

00:30:40.600 --> 00:30:43.290
And like I mentioned before,
it's going to take periodic snapshots

00:30:43.350 --> 00:30:46.280
of your app so you can identify where
most of your time is being spent

00:30:46.680 --> 00:30:48.620
and where you can optimize that.

00:30:48.630 --> 00:30:51.260
Also, visually go through your code,
inspect what's going on

00:30:51.260 --> 00:30:54.910
within your draw path,
see where you can optimize areas out,

00:30:55.020 --> 00:30:58.050
and here's some stuff you can look for.

00:30:58.520 --> 00:31:02.260
Triple buffering or multiple buffering.

00:31:02.260 --> 00:31:05.480
Now again, on classic Mac OS,
Mac OS 9 and earlier,

00:31:05.490 --> 00:31:09.160
you're dealing with constrained,
really tight memory and it was

00:31:09.160 --> 00:31:12.730
generally easier or more efficient
to redraw the contents of the window

00:31:12.730 --> 00:31:14.520
than it was to keep those bits around.

00:31:15.450 --> 00:31:20.950
Well, Mac OS X obviously has a double
buffering system so that it takes

00:31:21.230 --> 00:31:23.940
care of tearing and flicker for you.

00:31:23.940 --> 00:31:27.450
So again, like on a classic system,
if you wanted to avoid this

00:31:27.490 --> 00:31:30.580
type of tearing or flicker,
you would instead employ double

00:31:30.730 --> 00:31:34.750
buffering techniques which is to draw
into an off screen and then copy the

00:31:34.830 --> 00:31:37.230
contents of that off screen all at once.

00:31:37.320 --> 00:31:40.030
So if you're maintaining code that
was originally written for Mac OS 9 or

00:31:40.030 --> 00:31:43.150
earlier or targeted for those platforms,
keep this in mind that if you have

00:31:43.150 --> 00:31:46.940
application level double buffering,
this is completely unnecessary

00:31:46.940 --> 00:31:50.820
on Mac OS X in a sense to
avoid flicker and tearing.

00:31:53.360 --> 00:31:56.430
Also inspect your drawing code
and see if region processing

00:31:56.530 --> 00:31:58.160
is showing up in your samples.

00:32:01.970 --> 00:32:05.570
If you have complex regions,
this can be kind of expensive.

00:32:05.620 --> 00:32:09.280
Now, I should point out that on Panther,
that the internal implementation

00:32:09.280 --> 00:32:10.560
of regions has changed.

00:32:10.610 --> 00:32:14.720
So it has better performance and
there's no 64K limit anymore.

00:32:14.830 --> 00:32:17.280
But if these are showing
up in your samples,

00:32:17.360 --> 00:32:20.250
it might be a good idea,
or is actually a good idea

00:32:20.250 --> 00:32:23.310
to use simpler regions,
like rectangular regions

00:32:23.310 --> 00:32:24.740
is a good example.

00:32:24.830 --> 00:32:27.570
And if dirty region maintenance
shows up in your samples,

00:32:27.570 --> 00:32:30.380
and this is because,
let me just identify why that is,

00:32:30.440 --> 00:32:32.980
is that Quick Draw,
each time you do a draw operation,

00:32:32.980 --> 00:32:36.270
it needs to maintain this
dirty region that is going

00:32:36.330 --> 00:32:37.370
to flush to the screen later.

00:32:37.380 --> 00:32:39.950
So if you're doing a lot
of Quick Draw operations,

00:32:40.180 --> 00:32:43.070
maybe this dirty region
maintenance is going to show up.

00:32:43.150 --> 00:32:45.100
So if you know ahead of time that
you're going to be doing a lot of

00:32:45.190 --> 00:32:48.980
operations into a particular region,
you can tell Quick Draw ahead of time

00:32:48.980 --> 00:32:51.200
using the API QD set dirty region.

00:32:51.280 --> 00:32:54.740
Then perform all your drawing operations
and it completely removes the overhead.

00:32:54.760 --> 00:32:57.830
of Quick Draw dealing with
that dirty region for you.

00:33:00.570 --> 00:33:02.400
Now this is another important area.

00:33:02.400 --> 00:33:06.750
Like I mentioned on classic Mac OS,
it's easier to regenerate information,

00:33:06.750 --> 00:33:09.750
or it's more efficient to
regenerate information than it is

00:33:09.820 --> 00:33:11.380
to keep this information around.

00:33:11.400 --> 00:33:15.400
Well, redundant calculations may
show up in your drawing code.

00:33:15.400 --> 00:33:18.400
And a good example of this is when
we were optimizing the tabs control,

00:33:18.400 --> 00:33:19.400
we were looking through that.

00:33:19.400 --> 00:33:22.450
And if you think of the tab,
the tabs control, it's a user pane,

00:33:22.450 --> 00:33:25.370
it's got the tab items with
it with text drawing in there.

00:33:25.400 --> 00:33:28.300
And each time we would go draw,
we were getting the text

00:33:28.380 --> 00:33:32.400
dimensions for each of those items,
figuring out the metrics of each item,

00:33:32.400 --> 00:33:34.400
and then going through
with the draw operation.

00:33:34.450 --> 00:33:36.850
Well,
the metrics of the text and the labels,

00:33:36.850 --> 00:33:39.400
they're not going to
be changing that often,

00:33:39.400 --> 00:33:43.400
so it doesn't make sense to
recalculate that each time.

00:33:43.400 --> 00:33:46.400
It's a better idea to
cache that information.

00:33:46.580 --> 00:33:51.080
So go ahead and cache
to avoid this problem.

00:33:53.890 --> 00:33:57.000
You may be mixing
Quick Draw and Quartz drawing.

00:33:57.080 --> 00:34:00.990
Now, this can be inefficient because
the Quick Draw port is not

00:34:00.990 --> 00:34:06.180
synchronized for you with the
Quartz context that backs that.

00:34:06.280 --> 00:34:08.630
So avoid this type of drawing.

00:34:08.640 --> 00:34:10.520
So, for example,
if you're going to be using Appearance

00:34:10.520 --> 00:34:13.290
Manager APIs for your drawing,
which you should avoid,

00:34:13.290 --> 00:34:15.170
and I'll mention that in a moment.

00:34:15.720 --> 00:34:19.880
There needs to be some synchronization
that's behind your back to keep that

00:34:20.040 --> 00:34:23.720
QuickDraw port in the CG context in sync.

00:34:23.890 --> 00:34:27.800
If you must mix this type of drawing,
quick drawing, quartz drawing,

00:34:27.820 --> 00:34:30.300
do it in blocks for each
framework to avoid extra overhead.

00:34:30.300 --> 00:34:32.370
So draw with all of your
quick draw APIs first,

00:34:32.550 --> 00:34:36.590
followed by all your quartz drawing,
or vice versa.

00:34:38.020 --> 00:34:42.290
So on the front of using new APIs,
using more modern APIs,

00:34:42.350 --> 00:34:43.730
we recommend using Quartz.

00:34:43.740 --> 00:34:46.510
I mean,
for all of your primitive drawing,

00:34:46.510 --> 00:34:48.450
you should be using Quartz.

00:34:48.670 --> 00:34:55.200
So this requires you to generate your
information in Quartz native formats,

00:34:55.200 --> 00:34:57.900
and you can do this at build time.

00:34:57.970 --> 00:35:01.250
So if you can convert all of
your information to Quartz native

00:35:01.580 --> 00:35:04.090
formats like PDF at build time,
that's good.

00:35:04.170 --> 00:35:06.710
And you can also do this at run time.

00:35:06.780 --> 00:35:09.100
For example,
there's the Quick Draw API to convert

00:35:09.160 --> 00:35:11.020
or to draw a PICT into a context.

00:35:11.020 --> 00:35:14.380
So at runtime, you can take a PICT,
you can draw that into a

00:35:14.390 --> 00:35:17.110
context associated with the
PDF context and use that,

00:35:17.260 --> 00:35:19.820
cache that information,
and then use that image

00:35:19.820 --> 00:35:21.480
for subsequent drawing.

00:35:22.010 --> 00:35:24.170
So, you're probably thinking, "Well,
Curt,

00:35:24.170 --> 00:35:26.830
you're telling me to draw with Quartz,
but all my drawing code

00:35:26.840 --> 00:35:27.900
is based on Quick Draw.

00:35:27.900 --> 00:35:31.150
How do I do this?" Well,
to get a CG context from

00:35:31.150 --> 00:35:35.900
this Quick Draw port,
you'd use these APIs: Qt Begin CG Context

00:35:35.900 --> 00:35:36.900
and Qt End CG Context.

00:35:36.900 --> 00:35:40.410
And now what this does is it
will cache that context for you,

00:35:40.410 --> 00:35:41.900
so you don't have to.

00:35:41.900 --> 00:35:43.900
So this allows you to
print with both CG and

00:35:43.900 --> 00:35:45.900
Quick Draw drawing on the same page.

00:35:45.900 --> 00:35:48.540
But you should keep in mind
that in between these APIs,

00:35:48.540 --> 00:35:50.890
Quick Draw drawing is
going to be disabled.

00:35:52.740 --> 00:35:57.070
Now also, you shouldn't use the
API QD begin CG context,

00:35:57.120 --> 00:35:59.960
draw using some courts,
and then end that context,

00:35:59.960 --> 00:36:01.320
and then repeat that over and over.

00:36:01.320 --> 00:36:04.130
You should consolidate all of your
course drawing between these APIs.

00:36:05.720 --> 00:36:09.580
Also keep in mind that the CG context
and the graph port aren't synchronized,

00:36:09.580 --> 00:36:11.840
so if you need to synchronize the
origin or the clipping region,

00:36:11.840 --> 00:36:13.980
you'll have to do that on your own.

00:36:16.020 --> 00:36:19.860
So what's the difference between
a flush and a synchronize?

00:36:19.910 --> 00:36:25.360
Quite simply, if you do CG context flush,
it tells the draw system that that

00:36:25.360 --> 00:36:29.830
context is going to be flushed at
the next opportunity it can be.

00:36:29.900 --> 00:36:32.660
So it's generally an immediate response.

00:36:32.910 --> 00:36:36.240
and CG Context Synchronize
is for a delayed flush.

00:36:36.250 --> 00:36:39.900
So this is more like queuing up
different contexts to be flushed.

00:36:39.900 --> 00:36:43.400
Contexts, contuses?

00:36:43.400 --> 00:36:48.020
So what you would generally be doing
is doing all of your drawing and then

00:36:48.110 --> 00:36:52.010
call the API CG Context Synchronize
to let the draw system know that

00:36:52.080 --> 00:36:53.660
that's going to need to be flushed.

00:36:53.700 --> 00:36:58.560
And then the HI Toolbox during its draw
loop will flush the context for you.

00:37:04.760 --> 00:37:07.660
Other APIs you should be using
are the new HITHeme APIs.

00:37:07.660 --> 00:37:11.860
Now, these are new in Panther,
and it's a simple mapping

00:37:11.860 --> 00:37:16.210
between the old Appearance
Manager APIs and these new APIs.

00:37:16.330 --> 00:37:19.550
So, for example,
if you're drawing some theme primitives,

00:37:19.560 --> 00:37:23.240
like using the API Draw Theme Button,
there's an equivalent

00:37:23.240 --> 00:37:25.620
API called HITHeme Draw Button.

00:37:25.940 --> 00:37:28.480
So I encourage you to
check out hitheme.h.

00:37:28.480 --> 00:37:32.650
And the reason these APIs are
now available is because when

00:37:32.690 --> 00:37:35.420
you're using--because we're
doing all of our drawing,

00:37:35.420 --> 00:37:38.970
the toolbox is doing all of its
drawing with courts natively.

00:37:39.020 --> 00:37:41.880
So if you're drawing
with the Quick Draw APIs,

00:37:41.880 --> 00:37:45.310
the toolbox needs to either create a
context for your port or use a cache port

00:37:45.530 --> 00:37:47.250
and deal with the maintenance of that.

00:37:47.290 --> 00:37:50.620
So by exposing these APIs,
you're in charge of the context.

00:37:50.620 --> 00:37:54.960
It requires you to create a context and
maintain that context for your drawing.

00:37:55.010 --> 00:37:57.470
And all of these
APIs require an orientation.

00:37:57.470 --> 00:38:02.070
This is because the high-level toolbox
in Quick Draw deal with a top left

00:38:02.070 --> 00:38:06.990
origin-based view system and courts due
to its PDF background deals with the

00:38:07.090 --> 00:38:10.780
bottom left origin with an orientation.

00:38:12.940 --> 00:38:16.420
So you can use these APIs for
doing either types of drawing.

00:38:16.420 --> 00:38:19.740
And generally you would do this
because if you create a context,

00:38:19.740 --> 00:38:22.500
it's going to be bottom
left origin based.

00:38:22.620 --> 00:38:24.980
But if a context is given
to you by the toolbox,

00:38:25.050 --> 00:38:29.090
so for example if you have a custom view,
and during this draw Carbon event,

00:38:29.220 --> 00:38:33.360
it will hand you a CG context,
and that will already be transformed

00:38:33.510 --> 00:38:36.000
to be top left origin based.

00:38:36.130 --> 00:38:44.790
So that would be normal orientation.

00:38:44.790 --> 00:38:44.790
So also check out session 409,
Carbon AHL Toolbox for

00:38:44.790 --> 00:38:44.790
information about this.

00:38:45.870 --> 00:38:46.730
So why would you want to do this?

00:38:46.810 --> 00:38:50.020
Well, number one reason is performance.

00:38:50.150 --> 00:38:53.020
I went through personally
through many of the controls,

00:38:53.100 --> 00:38:56.360
the standard controls in the system,
and converted them from using

00:38:56.360 --> 00:38:59.740
the Appearance Manager APIs over
to the new H.I.Thema APIs.

00:38:59.810 --> 00:39:02.710
In some cases,
we were seeing the controls drawing

00:39:02.810 --> 00:39:05.040
twice as fast with respect to on Jaguar.

00:39:05.080 --> 00:39:09.280
Most of the common controls
will draw 25% faster.

00:39:09.490 --> 00:39:12.320
So this is solely for performance
and you should definitely be

00:39:12.320 --> 00:39:14.960
using these APIs rather than
old Appearance Manager APIs if

00:39:15.020 --> 00:39:17.070
you have that in your code.

00:39:19.340 --> 00:39:21.640
Text drawing.

00:39:21.700 --> 00:39:26.850
We got a lot of feedback about the
text drawing performance on Mac OS X.

00:39:28.000 --> 00:39:32.500
We want it fast, and we've done a lot of
work to improve that.

00:39:32.500 --> 00:39:35.250
So if you're going to be
drawing user interface text,

00:39:35.340 --> 00:39:38.270
rather than using the old Appearance
Manager APIs for getting the

00:39:38.270 --> 00:39:41.720
text dimensions and drawing,
which were Get Theme Text Dimensions

00:39:41.810 --> 00:39:44.790
and Draw Theme Text Box,
you should instead use

00:39:44.860 --> 00:39:48.120
the new HITHeme APIs,
HITHeme Get Text Dimensions,

00:39:48.140 --> 00:39:49.660
HITHeme Draw Text Box.

00:39:49.660 --> 00:39:54.150
Now, this is over twice as fast
on Panther than on Jaguar.

00:39:54.240 --> 00:39:57.800
And you can also see that the raw
performance of Draw Theme Text Box has

00:39:57.830 --> 00:39:59.320
definitely improved.

00:40:00.290 --> 00:40:05.570
You should definitely be using HITheme
DrawText for your user interface drawing.

00:40:05.700 --> 00:40:07.270
Not only does it give
you better performance,

00:40:07.350 --> 00:40:10.970
but it gives you better control over how
you're going to be laying out the text

00:40:10.970 --> 00:40:13.860
and drawing that in terms of flushness,
truncation,

00:40:13.870 --> 00:40:16.260
and how many lines are going to be drawn.

00:40:17.430 --> 00:40:20.140
Now let's say that you're
handling text drawing on your own.

00:40:20.140 --> 00:40:22.060
You're using Atsui for your drawing.

00:40:22.060 --> 00:40:24.990
So some tips for using Atsui.

00:40:25.060 --> 00:40:29.640
Well, keep in mind that that
API is a paragraph-based API.

00:40:29.760 --> 00:40:33.550
So you should be creating a
text layout per paragraph.

00:40:34.450 --> 00:40:39.480
Also, reuse the layout and the style
objects where appropriate.

00:40:39.480 --> 00:40:42.520
Rather than destroying a text
layout when you're done with it and

00:40:42.520 --> 00:40:47.540
then recreating another one to set
it to look at a new text buffer,

00:40:47.710 --> 00:40:52.170
keep that layout around and then set
it to look at a new run of text using

00:40:52.170 --> 00:40:55.060
the API atsu_layout_set_text_pointer.

00:40:55.140 --> 00:40:56.160
So reuse these objects.

00:40:56.160 --> 00:41:00.710
It eliminates the overhead for a lot
of redundant destruction and then

00:41:00.720 --> 00:41:03.800
reconstruction of those data structures.

00:41:04.120 --> 00:41:07.400
Also, if you need to lay out a
paragraph at a fixed width,

00:41:07.400 --> 00:41:11.870
use the batch API for breaking a line,
which is @sue-batch-breakline.

00:41:11.870 --> 00:41:14.050
Now, of course,
this is rather than manually

00:41:14.430 --> 00:41:17.760
going through a break loop and
using the @sue-breakline API.

00:41:17.760 --> 00:41:20.500
This will be much faster for doing that.

00:41:24.320 --> 00:41:27.380
Also, when you're drawing text,
if you need to get the

00:41:27.390 --> 00:41:30.200
dimensions of that text,
use ATSU Get Glyph Bounds.

00:41:30.200 --> 00:41:33.200
Now, this is a good technique also
because under the covers,

00:41:33.200 --> 00:41:35.200
it's going to cache the layout for you.

00:41:35.210 --> 00:41:39.200
So a subsequent draw using
ATSU Draw Text is going to be very fast.

00:41:41.020 --> 00:41:43.590
Also,
you should be creating and associating

00:41:43.600 --> 00:41:47.290
some font fallbacks with that
layout if performance is a concern.

00:41:47.350 --> 00:41:50.510
If you don't specify a
font fallback's object,

00:41:50.510 --> 00:41:52.390
it's going to rely on
the system fallbacks,

00:41:52.450 --> 00:41:53.860
which may be expensive to generate.

00:41:53.900 --> 00:41:56.800
And again,
keep in mind that the ATSU styles,

00:41:56.800 --> 00:41:59.900
it's not one-to-one in
terms of ATSU layouts.

00:41:59.900 --> 00:42:01.720
You don't have to have one per layout.

00:42:01.930 --> 00:42:06.620
So what you'll generally be wanting to
do is creating a style and associate

00:42:06.620 --> 00:42:08.900
that with a number of different layouts.

00:42:10.900 --> 00:42:13.150
Finally,
I'd like to talk about just general

00:42:13.220 --> 00:42:15.890
responsiveness issues on Mac OS X.

00:42:18.410 --> 00:42:19.810
Spinning Cursor.

00:42:19.880 --> 00:42:23.680
Most people are very familiar
with this spinning rainbow cursor.

00:42:23.720 --> 00:42:26.740
That's definitely a problem
that we want to avoid.

00:42:26.720 --> 00:42:29.280
Other parts of your UI may
become non-responsive while

00:42:29.290 --> 00:42:30.720
you're tracking the mouse.

00:42:30.800 --> 00:42:32.940
The user's tracking a custom control,
for example,

00:42:32.940 --> 00:42:34.470
and the app becomes non-responsive.

00:42:34.550 --> 00:42:36.900
Parts of your screen aren't updating.

00:42:36.930 --> 00:42:39.280
Maybe the CPU is pegged
while you're tracking this.

00:42:39.340 --> 00:42:42.970
This is a starvation of resources
from other utilities that

00:42:42.970 --> 00:42:44.870
are running on your system.

00:42:45.500 --> 00:42:48.090
Or maybe the app is just slow to respond,
it just feels sluggish.

00:42:48.140 --> 00:42:50.940
Now, you can find some of these
problems using Activity

00:42:50.940 --> 00:42:53.700
Monitor in Applications Utilities,
and this will allow you to

00:42:53.700 --> 00:42:56.000
identify the CPU utilization.

00:42:56.000 --> 00:42:58.900
You can see when the processor is pegged.

00:42:59.070 --> 00:42:59.990
and many others.

00:43:00.000 --> 00:43:06.400
And you can also identify problems using
developer applications spin control.

00:43:06.440 --> 00:43:08.220
Actually, that's singular.

00:43:08.320 --> 00:43:11.450
And this utility,
what it will do is when it's launched,

00:43:11.520 --> 00:43:13.560
whenever the system
spinning cursor comes up,

00:43:13.650 --> 00:43:16.420
it'll start sampling your app
or it'll start sampling that app

00:43:16.420 --> 00:43:18.440
that has caused that to spin.

00:43:18.540 --> 00:43:23.680
So you can see where the time is being
spent and why did it stop responding.

00:43:23.730 --> 00:43:27.030
Also from the command line,
you can use top.

00:43:33.170 --> 00:43:35.700
So do I identify how to resolve
this problem of the spinning cursor,

00:43:35.700 --> 00:43:37.280
which seems to be an issue?

00:43:37.280 --> 00:43:40.770
Let's understand why this is happening.

00:43:40.770 --> 00:43:40.770
Well,

00:43:41.180 --> 00:43:45.020
In general, what it is,
it's being caused because your app

00:43:45.090 --> 00:43:46.440
is no longer responding to events.

00:43:46.440 --> 00:43:49.930
So the user has input
some keys in the keyboard.

00:43:51.910 --> 00:43:55.350
And in a perfect world,
all of those events get picked up by

00:43:55.350 --> 00:43:57.670
your app and processed immediately.

00:43:57.770 --> 00:43:59.110
But sometimes your app is busy.

00:43:59.110 --> 00:44:00.880
You're processing loads of information.

00:44:00.880 --> 00:44:02.770
You're looking for intelligent life.

00:44:02.900 --> 00:44:06.720
And so events that are coming
in the system are not being

00:44:06.720 --> 00:44:09.180
picked up by your application.

00:44:09.280 --> 00:44:13.230
So what the system does is it
puts up this spinning cursor.

00:44:13.630 --> 00:44:14.890
And that really is correct behavior.

00:44:15.010 --> 00:44:19.150
What it's doing is it's telling the user
that your app is not responding anymore.

00:44:19.230 --> 00:44:23.060
If you're an event-driven application
and you are no longer picking up events,

00:44:23.080 --> 00:44:24.510
you are not responding.

00:44:24.630 --> 00:44:26.590
And that's correct behavior.

00:44:28.390 --> 00:44:29.740
So what are some solutions for this?

00:44:29.940 --> 00:44:34.410
Well, the best solution is to call into
the Event loop and start processing

00:44:34.420 --> 00:44:38.220
those events and that means that if
you're completely Carbon event based

00:44:38.220 --> 00:44:43.270
and using run application Event loop,
get into that API, start allowing events

00:44:43.280 --> 00:44:45.310
to come into the app.

00:44:45.310 --> 00:44:51.220
So that means to adopt Carbon events
or--because by adopting Carbon events,

00:44:51.220 --> 00:44:53.550
the system takes care,
the toolbox has its standard

00:44:53.550 --> 00:44:56.660
event handlers and they'll
take care of tracking for you.

00:44:56.660 --> 00:44:59.150
And if there's
improvements in the system,

00:44:59.150 --> 00:45:02.330
we can give those
improvements to you for free.

00:45:02.360 --> 00:45:03.430
And thread your app.

00:45:03.430 --> 00:45:05.480
If you do need to do
heavy duty processing,

00:45:05.480 --> 00:45:08.330
you need to do--look for
intelligent alien life,

00:45:08.860 --> 00:45:13.050
consider putting that on a worker
thread and then continue processing

00:45:13.400 --> 00:45:16.370
the user events on your main thread.

00:45:16.370 --> 00:45:18.470
And also look for polling.

00:45:19.030 --> 00:45:20.790
Of course, like, am I polling?

00:45:20.930 --> 00:45:23.590
Again, you would use the same utilities
as I mentioned earlier.

00:45:23.590 --> 00:45:27.010
You'd be using activity monitors
to see when the CPU utilization

00:45:27.250 --> 00:45:30.130
is at or near 100 percent,
or you'd be using top to

00:45:30.220 --> 00:45:32.650
find out the CPU usage.

00:45:32.760 --> 00:45:36.500
Now, if the user clicks the mouse and
the CPU goes up to being pegged,

00:45:36.500 --> 00:45:38.930
you've got a problem and you need
to figure out what to do about that.

00:45:38.940 --> 00:45:43.340
So, there's four main reasons
you'd probably be polling.

00:45:43.980 --> 00:45:45.680
And there's four
alternatives for doing this.

00:45:45.710 --> 00:45:48.230
Now, if you need to track the cursor,
for example,

00:45:48.240 --> 00:45:52.330
that the user's clicked in an area
of your view or your custom control,

00:45:52.330 --> 00:45:55.000
and you need to track where
the position of the cursor is,

00:45:55.040 --> 00:45:57.980
rather than using the very
familiar while mouse down,

00:45:58.000 --> 00:46:01.120
get the location of the mouse,
you would instead use the

00:46:01.120 --> 00:46:03.290
API track mouse location.

00:46:03.510 --> 00:46:05.760
And when you call this API,
the system blocks.

00:46:05.890 --> 00:46:09.200
So rather than pegging the CPU,
you're being extremely quiet.

00:46:09.260 --> 00:46:12.890
Nothing is happening in your app
until some user interaction happens.

00:46:13.000 --> 00:46:15.620
When the user moves the mouse,
this will return and give you

00:46:15.620 --> 00:46:18.700
an indicator of where the mouse
location is and what happened.

00:46:18.700 --> 00:46:20.300
Why did it return?

00:46:20.300 --> 00:46:23.730
Did the mouse move or did
the mouse button come up?

00:46:23.830 --> 00:46:26.360
Now,
if you need to determine where the cursor

00:46:26.360 --> 00:46:30.830
is on your screen because you want to
provide some type of rollover behavior,

00:46:30.830 --> 00:46:33.190
maybe you'd be pulling the
cursor location periodically.

00:46:33.210 --> 00:46:36.670
Well, instead of doing that,
you would want to use the

00:46:36.810 --> 00:46:38.770
APIs for tracking regions.

00:46:38.890 --> 00:46:41.200
Those are the mouse tracking region APIs.

00:46:41.200 --> 00:46:43.930
And these APIs are incredibly
cool because they will allow

00:46:43.950 --> 00:46:47.100
you to specify a region of your
window that you're interested in,

00:46:47.250 --> 00:46:50.750
and then you will get notifications
via Carbon events when the mouse

00:46:50.750 --> 00:46:53.570
has entered and exited that region.

00:46:54.810 --> 00:46:57.080
Another reason you may be pulling
is because you want to find out

00:46:57.080 --> 00:46:58.220
when a condition has changed.

00:46:58.310 --> 00:47:01.930
I want to see when preferences have
changed or a seed value has changed so

00:47:01.930 --> 00:47:04.500
I know to reload those preferences in.

00:47:04.610 --> 00:47:07.840
So, rather than doing that,
you want to watch for notifications.

00:47:07.840 --> 00:47:11.190
Now, this is as simple as
installing a callback,

00:47:11.310 --> 00:47:13.490
which is essentially what a
Carbon event notification is.

00:47:13.500 --> 00:47:15.780
You're installing a callback,
registering for certain

00:47:15.810 --> 00:47:17.880
notifications to come in,
and that callback will get

00:47:17.990 --> 00:47:19.450
called when that has happened.

00:47:19.550 --> 00:47:22.920
So you can watch for notifications, like,
let the system tell you when

00:47:22.920 --> 00:47:26.630
conditions have changed rather
than asking the system continually.

00:47:27.210 --> 00:47:30.500
And finally, you may be idling by
pulling the system clock.

00:47:30.590 --> 00:47:35.300
And what that means is you want
to wait for a specified time to

00:47:35.300 --> 00:47:37.340
elapse before continuing execution.

00:47:37.350 --> 00:47:40.690
Well, rather than pulling the
system clock and spinning,

00:47:40.690 --> 00:47:43.550
you would want to use timers,
Carbon event timers,

00:47:43.550 --> 00:47:48.940
which you would install and have some
code execute after this time has elapsed.

00:47:49.010 --> 00:47:50.940
Or just jump right into the event loop.

00:47:51.000 --> 00:47:53.320
There's an API called
Run Current Event Loop,

00:47:53.390 --> 00:47:56.100
and it allows you to
specify a timeout time.

00:47:56.110 --> 00:47:59.940
So you'd call that API and your timers
will continue to fire at that point,

00:48:00.040 --> 00:48:04.530
and then the execution will
proceed when that function returns.

00:48:06.070 --> 00:48:08.600
Finally, I'd like to mention
asynchronous window dragging.

00:48:08.600 --> 00:48:12.040
This is definitely in the
realm of perceived performance.

00:48:12.120 --> 00:48:14.720
This is a new facility
for Carbon application,

00:48:14.740 --> 00:48:18.460
and it allows the Windows Server to
deal with the dragging of the window.

00:48:18.500 --> 00:48:21.490
Now,
this frees up the app from doing this.

00:48:21.490 --> 00:48:26.790
So, if you are very busy and your
application has become unresponsive,

00:48:26.790 --> 00:48:30.660
the Windows Server will take care
of dragging the window for you.

00:48:31.110 --> 00:48:33.840
So, this will contribute to the
feeling that the user is still

00:48:33.840 --> 00:48:38.110
in control of the system,
and there are still things that they

00:48:38.110 --> 00:48:41.000
can do even when your app is hung.

00:48:44.340 --> 00:48:46.260
So you're probably tired
of listening to me talk,

00:48:46.260 --> 00:48:50.120
and so I'd like to bring up the
high-level toolbox demo boy,

00:48:50.130 --> 00:48:53.060
Guy Fullerton!

00:48:56.960 --> 00:48:59.240
Okay,
so I want to give you a brief example of

00:48:59.240 --> 00:49:02.790
how you might be able to track down some
performance problems in your application.

00:49:02.870 --> 00:49:05.400
And to do that,
I'm going to use an application

00:49:05.400 --> 00:49:07.870
we've been working on,
which is a game.

00:49:07.970 --> 00:49:10.550
Now, we've been working on this
game for a little bit,

00:49:10.550 --> 00:49:12.240
and our beta testers,
we have this extensive

00:49:12.240 --> 00:49:13.700
set of beta testers,
and they've all been

00:49:13.700 --> 00:49:15.290
complaining about two things.

00:49:15.360 --> 00:49:17.600
One, the app launches slowly.

00:49:17.670 --> 00:49:21.000
And two, after you play the game,
actually there's three things.

00:49:21.160 --> 00:49:23.590
Two, after you play the game,
the system kind of slows down.

00:49:23.590 --> 00:49:24.270
It gets sluggish.

00:49:24.310 --> 00:49:27.300
It's like our app is stealing
cycles from somewhere.

00:49:27.340 --> 00:49:29.770
And the third problem is
that on slower machines,

00:49:29.780 --> 00:49:32.270
the game doesn't deliver
a very good experience.

00:49:32.470 --> 00:49:34.040
The interface gets choppy.

00:49:34.270 --> 00:49:35.800
But to understand this,
let me go ahead and

00:49:35.800 --> 00:49:36.890
launch the application.

00:49:36.900 --> 00:49:40.440
I'm going to do it via the command line,
just because that's going to

00:49:40.550 --> 00:49:43.900
allow me to more easily do
some other tests in a second.

00:49:43.930 --> 00:49:46.900
So if you watch down on the dock,
this is the application.

00:49:46.900 --> 00:49:50.270
Watch it bounce, and it's going to take a
little while to load up.

00:49:51.340 --> 00:49:52.200
Yeah, four or five, yeah.

00:49:52.200 --> 00:49:53.140
So it took a couple of bounces.

00:49:53.140 --> 00:49:54.340
So here's the game.

00:49:54.340 --> 00:49:56.360
It's a pin the tail on the donkey game.

00:49:56.360 --> 00:49:58.620
And, you know, pin the tail on the
donkey is pretty easy.

00:49:58.620 --> 00:50:01.040
You just have to drag the
tail over to the donkey.

00:50:01.040 --> 00:50:02.620
Oh, I better start a new game first.

00:50:02.640 --> 00:50:06.860
So I start the game and the countdown,
count up, actually starts.

00:50:06.860 --> 00:50:08.380
And then I start staring at you.

00:50:08.380 --> 00:50:10.020
And that's actually the
challenge of the game.

00:50:10.020 --> 00:50:13.260
Can you possibly get the tail on
the donkey while I'm staring at you?

00:50:13.360 --> 00:50:15.020
Well, I did and I got a high score.

00:50:15.020 --> 00:50:16.000
I'm pretty good at it.

00:50:16.070 --> 00:50:17.140
But, you know, I've been riding it.

00:50:17.140 --> 00:50:18.130
I've got to be pretty good at it.

00:50:18.160 --> 00:50:20.560
So that's the game.

00:50:20.800 --> 00:50:23.210
But the main complaint that
users have been saying is that

00:50:23.210 --> 00:50:24.300
it takes a while to launch.

00:50:24.300 --> 00:50:25.710
So let's go take a look at that.

00:50:25.760 --> 00:50:28.680
And there's two ways
I want to look at this.

00:50:30.640 --> 00:50:33.720
The first way is through
the use of SpinControl.

00:50:33.800 --> 00:50:36.990
Now, SpinControl is one of our
performance test tools.

00:50:37.010 --> 00:50:39.250
It will detect when an
application is unresponsive,

00:50:39.260 --> 00:50:41.340
and it will automatically
sample that application.

00:50:41.470 --> 00:50:43.260
Now, I know my app is
unresponsive during launch,

00:50:43.260 --> 00:50:46.140
so SpinControl is going to automatically
detect that and do a sample.

00:50:46.300 --> 00:50:49.460
But I wouldn't necessarily have
to use SpinControl to generate the

00:50:49.460 --> 00:50:50.730
information I'm going to generate.

00:50:50.740 --> 00:50:53.550
I could use Sampler to
generate the same information.

00:50:53.630 --> 00:50:57.570
It just so happens that this is a little
bit more convenient for my situation.

00:50:57.860 --> 00:50:59.600
So we'll launch it again.

00:50:59.600 --> 00:51:01.640
And as it's launching,
you'll see SpinControl

00:51:01.640 --> 00:51:03.800
updated its interface,
saying, hey, it was unresponsive

00:51:03.800 --> 00:51:05.400
and it sampled the app.

00:51:05.400 --> 00:51:07.020
And then I get the results.

00:51:07.130 --> 00:51:10.080
If I double click on that and open it up,

00:51:10.980 --> 00:51:14.860
I can see the backtrace for
the time various operations

00:51:14.860 --> 00:51:16.100
took during App Bring Up.

00:51:16.220 --> 00:51:18.980
So of course I was in Maine for a
couple seconds and I was setting

00:51:18.980 --> 00:51:21.900
up my game window and setting
up my high scores dialogue.

00:51:21.900 --> 00:51:24.900
Oh, and then I started doing
some preferences operations.

00:51:25.130 --> 00:51:27.900
Well, you know, it occurs to me that
I load my preferences,

00:51:27.900 --> 00:51:30.020
my application preferences
at Bring Up time,

00:51:30.190 --> 00:51:32.900
but most of my preferences
is just a high score list.

00:51:32.900 --> 00:51:35.900
I store a really big list of all the
scores that have happened on the game.

00:51:35.900 --> 00:51:37.740
And, you know,
the high score list really doesn't

00:51:37.740 --> 00:51:38.890
matter at App Bring Up time.

00:51:38.900 --> 00:51:41.690
The only time I consult it is after
the user has played a game and

00:51:41.900 --> 00:51:44.960
I need to compare and see if it
deserves to be on the high scores,

00:51:44.980 --> 00:51:47.900
or if the user displays
the high scores window.

00:51:47.970 --> 00:51:50.280
So this real quickly,
by rethinking the way

00:51:50.380 --> 00:51:54.280
I initialize my preferences,
would allow me to cut about a second and

00:51:54.280 --> 00:51:56.900
a half off of my application launch time.

00:51:59.280 --> 00:52:03.700
So the next thing I want to look at with
respect to app launch time is FS usage.

00:52:03.700 --> 00:52:04.920
John talked about FS usage.

00:52:04.920 --> 00:52:07.120
There's a bunch of different options
you can pass to it to generate

00:52:07.120 --> 00:52:09.520
different amounts of information.

00:52:09.520 --> 00:52:12.580
And I'm going to pass the -w option,
which generates some extra

00:52:12.580 --> 00:52:16.340
info about errors and file
sizes and things like that.

00:52:16.340 --> 00:52:18.880
And I'm going to pipe that through
to grep just so I see the file

00:52:18.890 --> 00:52:22.380
system operations that happen
with respect to my application.

00:52:22.610 --> 00:52:27.800
So if I turn that on and
relaunch my application.

00:52:28.290 --> 00:52:30.540
it's going to generate
a bunch of information.

00:52:30.540 --> 00:52:34.920
Now, most of the work that is in this
log is stuff happening on my

00:52:34.920 --> 00:52:36.690
behalf because of the system.

00:52:36.700 --> 00:52:39.610
You know, my application executable
is being loaded,

00:52:39.690 --> 00:52:40.440
things like that.

00:52:40.440 --> 00:52:41.460
And that's all fine.

00:52:41.460 --> 00:52:44.740
I've already gone through this and
looked at one interesting thing.

00:52:44.740 --> 00:52:50.200
Now, I load some images in my application
in the form of PNG files.

00:52:50.200 --> 00:52:52.890
And the first one that gets loaded--
I don't know if you can read that

00:52:52.890 --> 00:52:56.380
up there-- but the first one that
gets loaded is called ddonkey.png.

00:52:56.380 --> 00:52:58.060
That's the big donkey
image in the window.

00:52:58.060 --> 00:53:00.810
I need that at app bring up because
that's part of my interface.

00:53:00.850 --> 00:53:02.100
And that's fine.

00:53:02.100 --> 00:53:04.820
And then I load the donkey tail,
and that's cool.

00:53:04.820 --> 00:53:09.300
But I find another load here,
and it's a title PNG.

00:53:09.300 --> 00:53:13.600
Well, I don't actually use that title
anywhere in my main window.

00:53:13.600 --> 00:53:16.200
I only use it in my rules dialog.

00:53:16.250 --> 00:53:18.600
So that's another way
I could actually speed up my

00:53:18.600 --> 00:53:23.870
application launch performance,
is just load that PNG file only when

00:53:23.880 --> 00:53:26.100
the user brings up the rules dialog.

00:53:26.100 --> 00:53:28.530
Now,
some of the extra information that the

00:53:28.530 --> 00:53:32.220
-w option passes back is the amount
of time this particular load took.

00:53:32.230 --> 00:53:35.240
And you can see that it's just
a fraction of a second that

00:53:35.260 --> 00:53:36.400
it took to open that file.

00:53:36.400 --> 00:53:39.680
And there is--

00:53:40.770 --> 00:53:45.600
Yeah, if I look at the file identifiers,
yeah, it's not a whole lot of time spent

00:53:45.710 --> 00:53:49.450
actually manipulating that file,
but every little bit counts.

00:53:49.600 --> 00:53:52.280
And if you look for things like this,
you might actually find that the

00:53:52.280 --> 00:53:55.250
loading of files at app bring up time
is just a symptom of a larger problem.

00:53:55.360 --> 00:53:57.830
So you should go through FSUs,
find out what sorts of things

00:53:57.830 --> 00:54:00.900
your application is doing,
and see if they really need

00:54:00.900 --> 00:54:02.970
to be done at app launch time.

00:54:04.120 --> 00:54:09.560
So once the application is
running and I play a game,

00:54:09.590 --> 00:54:13.360
I finish a game, the users say, "Hey,
you know what?

00:54:13.360 --> 00:54:17.350
Subsequent games are either sluggish or
my system just completely bogs down and

00:54:17.350 --> 00:54:22.870
let's go ahead and launch Quartz Debug
here because it's got a little CPU gauge,

00:54:22.890 --> 00:54:28.640
frame meter, and oh wow, sure enough,
it looks like my interface isn't

00:54:28.790 --> 00:54:31.820
doing much but I'm eating up
some CPU speed and I'm trying to

00:54:31.820 --> 00:54:33.620
render over 90 frames per second.

00:54:33.620 --> 00:54:35.070
So something's going wrong here.

00:54:35.360 --> 00:54:38.220
There's a couple different ways
we can look at my interface and

00:54:38.260 --> 00:54:39.870
figure out what's going wrong.

00:54:40.010 --> 00:54:43.280
The first way I want to look
at is flash identical updates.

00:54:43.400 --> 00:54:46.810
So let's get this out of the way.

00:54:48.800 --> 00:54:54.300
[Transcript missing]

00:54:54.490 --> 00:54:57.290
"My time display,
even though the game's not running,

00:54:57.290 --> 00:54:58.740
which is a first problem.

00:54:58.740 --> 00:55:01.840
But another thing I notice is
that even though the time display,

00:55:01.840 --> 00:55:05.190
if I get rid of it,
even though my text is

00:55:05.190 --> 00:55:07.710
only about 24 pixels tall,

00:55:07.700 --> 00:55:12.010
I'm repainting this entire area
every time I repaint the text.

00:55:12.110 --> 00:55:14.920
Well, so this is something I could
go in and fix in my nib.

00:55:15.010 --> 00:55:17.610
What I should really do is I should
shrink up that field that I'm

00:55:17.610 --> 00:55:19.250
using to display the time with.

00:55:19.250 --> 00:55:21.580
And that would save me
some processing cycles.

00:55:21.610 --> 00:55:25.740
The OS would not need
to render quite as much.

00:55:26.310 --> 00:55:30.090
Another thing I can look at here with
Quartz Debug is to flash screen updates.

00:55:30.090 --> 00:55:33.200
So again, we're going to see this
time rendering constantly,

00:55:33.200 --> 00:55:35.200
which is unfortunate because
I'm not playing the game.

00:55:35.200 --> 00:55:38.160
But I would expect that to flash
yellow if I actually start a game.

00:55:38.300 --> 00:55:40.170
So let's start a game
and see what happens.

00:55:40.200 --> 00:55:41.320
Okay, so far so good.

00:55:41.430 --> 00:55:43.200
Nothing entirely unexpected.

00:55:43.200 --> 00:55:46.130
But as I actually start
to drag the tail around,

00:55:46.410 --> 00:55:49.200
wow,
I'm seeing a lot of drawing happen here.

00:55:49.200 --> 00:55:50.260
And you know what?

00:55:50.270 --> 00:55:52.140
I didn't really intend to do this.

00:55:52.230 --> 00:55:55.120
Every time I move the mouse,
it's repainting the

00:55:55.120 --> 00:55:56.200
entire donkey picture.

00:55:56.320 --> 00:55:59.720
What a much better scenario for this
game would have been to only repaint

00:55:59.810 --> 00:56:03.200
the place where the tail was and
the place where the tail is now.

00:56:03.200 --> 00:56:05.420
And that's going to save
me a lot of time because,

00:56:05.430 --> 00:56:07.850
you know what,
just the delta between a tail

00:56:07.980 --> 00:56:11.180
move and its old position and
its new position is pretty small.

00:56:11.200 --> 00:56:14.200
I'd probably say easily a 40th
of that entire image size.

00:56:14.200 --> 00:56:17.910
So that's going to cut down my
draw time there by about a 40th.

00:56:18.480 --> 00:56:20.600
And that will make my users much,
much happier.

00:56:20.600 --> 00:56:24.200
And then I can spend my time working
on better things like good gameplay.

00:56:24.220 --> 00:56:29.100
So anyway, hopefully now you see a couple
ways that you can use our tools to

00:56:29.100 --> 00:56:32.420
identify and track down some of the
typical problems in your applications.

00:56:32.420 --> 00:56:33.690
Curt?

00:56:39.730 --> 00:56:40.680
Thank you Guy.

00:56:40.690 --> 00:56:42.700
That was such a great demo.

00:56:42.700 --> 00:56:45.970
He's like an excellent programmer
on the Toolbox team because of that.

00:56:47.990 --> 00:56:50.540
So, finally, I'd like to just kind of
end up on some general tips.

00:56:50.540 --> 00:56:53.750
Now,
I mentioned earlier that you should cache

00:56:53.900 --> 00:56:58.970
frequently used information or frequently
calculate information with your views.

00:56:59.130 --> 00:57:03.150
Well, this is really important to do
for frequently used information

00:57:03.150 --> 00:57:07.060
or information or data that's
very expensive to calculate.

00:57:07.060 --> 00:57:10.370
Keep in mind that there is
a time and space tradeoff.

00:57:10.370 --> 00:57:13.290
And what I mean by that is,
if you end up caching 50

00:57:13.340 --> 00:57:15.740
megabytes of information,
and then the user clicks

00:57:15.740 --> 00:57:17.630
in another application,
and then the system all of a

00:57:17.630 --> 00:57:20.070
sudden needs that 50 megabytes,
it's going to start

00:57:20.070 --> 00:57:21.070
paging it out to disk.

00:57:21.070 --> 00:57:23.330
And then when the user
clicks back into your app,

00:57:23.330 --> 00:57:25.820
it's going to page all
that information back in.

00:57:25.920 --> 00:57:28.490
And it may have been--just
been more efficient to just

00:57:28.620 --> 00:57:30.260
regenerate that information.

00:57:30.260 --> 00:57:31.610
So just be aware of that.

00:57:31.720 --> 00:57:35.070
The key here is frequently
used information or very

00:57:35.070 --> 00:57:37.020
expensive data to create.

00:57:39.360 --> 00:57:41.060
Again, always provide feedback.

00:57:41.190 --> 00:57:43.800
Now, if you're just going to be
doing a simple operation,

00:57:43.800 --> 00:57:45.600
put up some chasing arrows.

00:57:45.690 --> 00:57:50.560
For some time-consuming process,
put up a progress bar.

00:57:50.560 --> 00:57:53.720
I mean,
if the user thinks that something's

00:57:53.720 --> 00:57:56.100
going to take 10 seconds and it's
going to take them four hours,

00:57:56.110 --> 00:57:58.070
that's something that
they should probably know.

00:57:58.150 --> 00:57:59.950
And always allow them to cancel.

00:57:59.990 --> 00:58:05.120
This is really important to let the user
be in control of your application rather

00:58:05.120 --> 00:58:08.090
than your app being in control of them.

00:58:11.370 --> 00:58:14.040
So finally,
I'd just like to point out that

00:58:14.150 --> 00:58:17.200
you should get familiar with the
performance tools we have on the system.

00:58:17.200 --> 00:58:21.740
There's a lot of utilities on the system,
many of which we haven't

00:58:21.780 --> 00:58:22.530
talked about at all.

00:58:22.530 --> 00:58:27.440
But get familiar with Quartz Debug,
Sampler, Spin Control, Mallet Debug,

00:58:27.480 --> 00:58:28.300
Shark.

00:58:28.380 --> 00:58:31.300
Go check out this session
on Carbon Performance Tools.

00:58:31.300 --> 00:58:35.730
Also,
become familiar with the new modern APIs.

00:58:35.730 --> 00:58:38.300
Quartz,
which you should definitely be using.

00:58:38.300 --> 00:58:39.100
H.I.

00:58:39.130 --> 00:58:41.820
Theme, use that on Panther.

00:58:42.010 --> 00:58:43.340
Take advantage of Carbon events.

00:58:43.360 --> 00:58:45.500
This is going to give you more
control over your application,

00:58:45.500 --> 00:58:46.790
better performance.

00:58:46.890 --> 00:58:50.280
Take advantage of HIView for
all of your custom drawing.

00:58:51.720 --> 00:58:55.180
And keep in mind that we've spent
a lot of time optimizing the

00:58:55.180 --> 00:58:58.010
toolbox and other parts of Carbon,
and it's really everybody's

00:58:58.020 --> 00:59:01.190
responsibility to keep performance going.

00:59:01.400 --> 00:59:04.940
So finally, to go through the roadmap and
other reference information,

00:59:04.940 --> 00:59:06.400
I'd like to bring back Xavier.

00:59:06.400 --> 00:59:12.400
Right on time.

00:59:12.400 --> 00:59:13.400
Excellent.

00:59:13.400 --> 00:59:14.400
Thanks, Curt.

00:59:20.440 --> 00:59:22.090
Okay,
I really hope that you guys got the meat

00:59:22.090 --> 00:59:25.360
of what we're trying to achieve here,
and it gave you a couple of good

00:59:25.360 --> 00:59:27.400
ideas to go back to your offices.

00:59:27.400 --> 00:59:30.180
And I would really,
really appreciate if you could

00:59:30.190 --> 00:59:33.290
spend some time finding out what's
going on in your application.

00:59:33.300 --> 00:59:36.780
Once again, lunchtime,
try to find out about the drawing.

00:59:37.100 --> 00:59:38.790
We have great tools.

00:59:38.850 --> 00:59:41.190
I don't know if we mentioned,
but we have Shark as well,

00:59:41.320 --> 00:59:43.100
which is a very, very cool application.

00:59:43.200 --> 00:59:45.590
A little bit like Sampler,
but it's going to give you

00:59:45.590 --> 00:59:49.100
ideas as well on how you can
optimize specifically for the G5.

00:59:49.170 --> 00:59:51.190
You know,
saying maybe you should run some loops,

00:59:51.270 --> 00:59:53.400
maybe you should actually
use Altevec in that part.

00:59:53.400 --> 00:59:55.350
So remember,
we have a brand new set of tools

00:59:55.350 --> 00:59:58.290
that can help you identify the
hotspots in your application.

00:59:58.330 --> 01:00:00.500
So make good use of it.

01:00:00.610 --> 01:00:05.390
All right, just after this session,
we have a feedback forum for the toolbox.

01:00:05.440 --> 01:00:07.600
I'd encourage you to assist
if you had any questions,

01:00:07.600 --> 01:00:10.300
if you want to give us your feedback,
things that you like,

01:00:10.340 --> 01:00:13.000
or things that you really like,
or things that you really, really like,

01:00:13.140 --> 01:00:15.780
and things that you don't like, okay?

01:00:15.880 --> 01:00:17.300
Maybe.

01:00:17.300 --> 01:00:18.980
Session 305 on Tuning Software.

01:00:19.060 --> 01:00:22.450
The first session of the talk with
Performance Tools was Wednesday for

01:00:22.460 --> 01:00:24.180
those of us that can travel in time.

01:00:24.250 --> 01:00:26.600
And tomorrow morning,
we're going to have a great session,

01:00:26.600 --> 01:00:29.200
session 310,
on debugging and tuning common

01:00:29.200 --> 01:00:31.200
applications with Apple's tools.

01:00:31.200 --> 01:00:35.460
We'll be showing you a couple of
cool tricks with Xcode on how to

01:00:35.670 --> 01:00:39.120
improve a debugging experience,
how to get the most of your time

01:00:39.120 --> 01:00:41.200
while debugging common applications.

01:00:41.200 --> 01:00:43.110
I encourage you to go there.

01:00:45.890 --> 01:00:48.260
Oh, I'm forgetting the best, of course,
for the end.

01:00:48.270 --> 01:00:50.570
Session 425, where Mr.

01:00:50.570 --> 01:00:52.670
Ed will be talking about HIV in depth.

01:00:52.670 --> 01:00:58.620
HIV was introduced last year,
actually not in this room, but at WWDC.

01:00:58.810 --> 01:01:02.200
It's really the future of
drawing controls on Mac OS X.

01:01:02.200 --> 01:01:05.240
And if you have any custom
controls in your application,

01:01:05.330 --> 01:01:06.980
you really have to go there.

01:01:09.290 --> 01:01:11.940
Should you have any questions,
you guys have been

01:01:11.940 --> 01:01:13.540
changing the slides again.

01:01:13.720 --> 01:01:18.050
Anyway, should you have any questions,
please don't hesitate to send me an email

01:01:18.330 --> 01:01:23.590
at xavier@apple.com and I'll be more than
happy to find out how we can help you.

01:01:25.390 --> 01:01:28.360
We have some documentation and
I encourage you to go on our

01:01:28.420 --> 01:01:30.540
website on developer.apple.com.

01:01:30.610 --> 01:01:33.560
We're revamping completely our
website to make it easier for you

01:01:33.560 --> 01:01:35.460
guys to actually find information.

01:01:35.530 --> 01:01:39.380
So check it out, see like, you know,
all the sections that we have on Carbon.

01:01:39.450 --> 01:01:41.560
We've had it in the last month or so,
actually,

01:01:41.560 --> 01:01:45.670
a brand new sample code as well for like,
HIView.

01:01:45.690 --> 01:01:48.240
Look at it inside the Carbon sample
code and you're going to

01:01:48.240 --> 01:01:49.730
see two different sections.

01:01:49.790 --> 01:01:52.930
You're going to have HIToolbox
and HIToolbox for Mac OS X.

01:01:52.940 --> 01:01:56.010
So just check out the
HIToolbox for Mac OS X section.

01:01:56.160 --> 01:01:56.830
Great start there.

01:01:58.290 --> 01:02:02.910
A couple of technical notes:
Mac OS X Quick Draw Performance to help

01:02:02.910 --> 01:02:06.480
you find out what's going on with your
drawing in your app and what should

01:02:06.490 --> 01:02:09.480
you be doing now on Mac OS X to get
the best of performance for drawing.

01:02:09.480 --> 01:02:12.580
We have things on the file manager
and some QAs here available for

01:02:12.580 --> 01:02:14.450
improving at Suite Text Drawing.
WEBVTT

00:00:19.840 --> 00:00:20.800
Good morning everyone.

00:00:20.820 --> 00:00:22.010
My name is Travis Brown.

00:00:22.010 --> 00:00:24.400
I'm the graphics and imaging evangelist.

00:00:24.400 --> 00:00:28.800
And I want to welcome you to session 208,
Fragment Programming with OpenGL.

00:00:28.990 --> 00:00:34.210
And this session is our second
session in programmability in terms

00:00:34.230 --> 00:00:39.500
of sort of our focus on exposing the
capabilities of GPU to do interesting

00:00:39.500 --> 00:00:42.440
things like vertex operations,
and in this case doing

00:00:42.440 --> 00:00:45.260
per-pixel operations,
very advanced per-pixel

00:00:45.260 --> 00:00:46.800
operations at incredible speeds.

00:00:46.800 --> 00:00:50.720
A lot of you saw some demonstrations
using fragment programs earlier this week

00:00:50.720 --> 00:00:52.800
in the graphics and imaging overview.

00:00:52.800 --> 00:00:55.800
And what we're going to do in this
session is really sort of drill down

00:00:55.800 --> 00:00:58.800
and focus on fragment programming.

00:00:58.860 --> 00:01:01.270
And we're really looking forward
to seeing what you the developer

00:01:01.270 --> 00:01:03.800
is going to be able to do with
this incredibly new technology.

00:01:03.800 --> 00:01:07.110
So it's my pleasure to invite
James McComb to the stage to take

00:01:07.110 --> 00:01:09.010
you through the presentation.

00:01:15.200 --> 00:08:24.200
[Transcript missing]

00:08:24.370 --> 00:08:29.980
Basically, this little program that you
upload to the graphics card,

00:08:30.060 --> 00:08:36.520
it's ran once for every color
lookup during the rasterization.

00:08:36.770 --> 00:08:39.700
: Basically,
whenever the rasterizer is going

00:08:39.700 --> 00:08:42.620
across and filling in the pixels
on the surface of the polygons,

00:08:42.990 --> 00:08:47.490
normally it goes through a fixed
function which can get pixatexels

00:08:47.490 --> 00:08:49.960
from the different texture
units and blend them together.

00:08:50.370 --> 00:08:53.460
Well, this allows that process
to be totally programmable.

00:08:53.460 --> 00:08:55.970
So, yes,
you could go and get the data from

00:08:55.970 --> 00:08:59.180
the texture units or you could
just return any color you want

00:08:59.180 --> 00:09:01.210
based on a mathematical function.

00:09:04.420 --> 00:09:07.010
: Now, so, again, the output of the
fragment program is good.

00:09:07.020 --> 00:09:10.780
It's got a very well-defined output,
single RGBA color,

00:09:10.780 --> 00:09:14.000
and optionally you can specify
its position in the depth buffer

00:09:14.060 --> 00:09:18.620
so as it can be culled by later
stages in the GL pipeline.

00:09:18.620 --> 00:09:24.690
In regards to inputs to
the fragment program,

00:09:24.970 --> 00:09:27.850
The texture coordinate channels
which you would normally set

00:09:27.950 --> 00:09:30.790
up in the vertex program,
you'll note that when you

00:09:30.790 --> 00:09:34.190
write an output vertex,
you can put into the texture coordinate

00:09:34.290 --> 00:09:37.750
channels and you have the number of
channels is equal to the number of

00:09:37.750 --> 00:09:39.890
texture units on your graphics card.

00:09:39.900 --> 00:09:42.500
The values you write in
there in the vertex program,

00:09:42.500 --> 00:09:46.580
those are interpolated across the surface
that the fragment program is running on,

00:09:46.680 --> 00:09:48.900
so you get that interpolation for free.

00:09:48.900 --> 00:09:50.820
So that's one of the inputs.

00:09:50.820 --> 00:09:54.610
You also get the interpolated
vertex color and the position

00:09:54.700 --> 00:09:57.890
of that fragment in the window,
in window coordinates.

00:09:57.900 --> 00:10:02.370
Also, with our fragment program,
you can access all of OpenGL state,

00:10:02.370 --> 00:10:04.900
which is certainly very convenient.

00:10:04.900 --> 00:10:11.040
That means you get access to the matrices
and also the program parameters as well,

00:10:11.110 --> 00:10:12.900
which I'll discuss.

00:10:12.900 --> 00:10:18.900
And then the other important
input is you can sample text.

00:10:18.900 --> 00:10:22.060
So you can sample text from
any of the texture units,

00:10:22.150 --> 00:10:23.900
which is important also.

00:10:24.050 --> 00:10:27.840
Let's take a look at specifics
of our fragment program.

00:10:27.970 --> 00:10:29.900
Great news here.

00:10:29.900 --> 00:10:35.900
If you've programmed our vertex program,
the language is totally parallel to that.

00:10:35.900 --> 00:10:38.900
It was intentionally designed that way,
so if you know our vertex program,

00:10:38.900 --> 00:10:41.900
you know our fragment program as well.

00:10:41.900 --> 00:10:46.970
The only difference is that instead
of dealing with XYZW components to

00:10:46.980 --> 00:10:51.250
specify a vertex position in 3D space,
you're now defining red, green, blue,

00:10:51.250 --> 00:10:53.900
and alpha components for an output color.

00:10:53.900 --> 00:10:55.900
So the same thing applies.

00:10:55.900 --> 00:10:57.900
All these instructions,
there are a few exceptions.

00:10:57.900 --> 00:11:02.890
90% of these instructions
are vector instructions,

00:11:02.920 --> 00:11:06.890
meaning if you do an add,
it does the add for all four components.

00:11:06.900 --> 00:11:10.900
There are some of these instructions,
which we'll talk about later,

00:11:10.900 --> 00:11:15.080
which are considered scalar instructions,
and that is, for instance,

00:11:15.200 --> 00:11:16.900
the POW instruction, to the power of.

00:11:16.960 --> 00:11:18.900
That's a scalar instruction.

00:11:18.900 --> 00:11:22.900
So if you want to do a power
for all four components,

00:11:22.900 --> 00:11:23.900
you need four instructions.

00:11:23.900 --> 00:11:25.650
That's one thing.

00:11:25.900 --> 00:11:27.900
So I've grouped these together.

00:11:27.900 --> 00:11:29.900
Those are all your
arithmetic instructions.

00:11:29.900 --> 00:11:33.900
You've got some logic
instructions like other languages.

00:11:33.900 --> 00:11:38.250
Unlike programming a general-purpose CPU,
don't be expecting to be able to

00:11:38.250 --> 00:11:39.840
do bit shifts and things like that.

00:11:39.910 --> 00:11:40.790
That isn't going to happen.

00:11:40.880 --> 00:11:42.900
So you won't be able to do shift left,
shift right, any of that.

00:11:42.900 --> 00:11:44.890
But you do have some basic logic
to determine if something's

00:11:44.900 --> 00:11:46.900
equal to zero or not,
or it's greater or less than zero.

00:11:46.900 --> 00:11:48.850
So you can do that.

00:11:48.990 --> 00:11:51.900
Less than zero.

00:11:52.050 --> 00:11:54.270
The other thing, then,
is these are the important ones

00:11:54.380 --> 00:11:55.830
that our fragment program adds.

00:11:55.970 --> 00:11:57.890
They're the texture
sampling instructions.

00:11:58.100 --> 00:12:02.510
These allow you to get things
from the texture units,

00:12:02.510 --> 00:12:05.790
with text being the most common one.

00:12:06.030 --> 00:12:08.800
And then you have some miscellaneous
instructions like vertex program.

00:12:08.910 --> 00:12:11.580
You have a squizzle instruction,
so you can reorder your

00:12:11.580 --> 00:12:12.900
components in a vector.

00:12:12.900 --> 00:12:14.900
And you have this kill instruction.

00:12:14.900 --> 00:12:16.900
I haven't actually used it
yet in the fragment program.

00:12:16.900 --> 00:12:21.090
But what it actually is supposed
to do is stop a fragment from

00:12:21.150 --> 00:12:22.900
continuing down the OpenGL pipeline.

00:12:22.900 --> 00:12:25.870
It actually literally just kills it off.

00:12:25.950 --> 00:12:31.770
So there might be some possibilities
for you with that instruction.

00:12:31.900 --> 00:18:27.200
[Transcript missing]

00:18:27.780 --> 00:18:33.200
Let's switch over to the demo machine
and let me show you Shader Builder here.

00:18:40.200 --> 00:18:42.200
demo two, actually.

00:18:42.200 --> 00:18:43.560
Great.

00:18:43.560 --> 00:18:51.520
So what we have here is like
the screenshot I showed you,

00:18:51.520 --> 00:18:54.620
on the top right of the window,
we have the rendering view, which,

00:18:54.620 --> 00:18:56.200
you know, I can move it around.

00:18:56.200 --> 00:18:58.450
At the moment,
it's just showing a simple quad,

00:18:58.450 --> 00:19:01.420
which is really what you want if
you're just writing a fragment program.

00:19:01.420 --> 00:19:02.380
You want to see the pixels.

00:19:02.380 --> 00:19:05.570
You don't really care about
the geometry so much for a lot

00:19:05.570 --> 00:19:07.780
of the things you'll be doing.

00:19:07.780 --> 00:19:11.520
On the bottom right, again,
you've got the texture units inspector.

00:19:11.520 --> 00:19:14.840
So here, if I click here,
this shows me that in texture unit zero,

00:19:14.840 --> 00:19:16.440
I have this rock texture loaded.

00:19:16.490 --> 00:19:19.100
In texture unit one,
I have the water texture,

00:19:19.100 --> 00:19:21.520
which is what's currently being shown.

00:19:21.520 --> 00:19:25.890
Now, let's look at the code here.

00:19:26.500 --> 00:19:28.390
We can see basically
what's going on here.

00:19:28.400 --> 00:19:31.000
This is a very simple
pass-through fragment program.

00:19:31.000 --> 00:19:32.460
It's doing nothing special.

00:19:32.590 --> 00:19:35.020
Remember, the program's running once.

00:19:35.300 --> 00:19:38.300
I beg your pardon?

00:19:42.000 --> 00:19:43.420
Oh, it looks okay here.

00:19:43.420 --> 00:19:44.340
It must just be clipped.

00:19:44.340 --> 00:19:45.720
Sorry about that.

00:19:45.730 --> 00:19:46.600
Is that better?

00:19:46.620 --> 00:19:46.950
Okay.

00:19:47.230 --> 00:19:48.000
Sorry about that.

00:19:48.000 --> 00:19:54.500
So, what it's basically doing,
this is running once for every pixel,

00:19:54.500 --> 00:19:56.000
let's just think of it as.

00:19:56.100 --> 00:19:59.190
And what it's doing is
the text instruction,

00:19:59.570 --> 00:20:05.490
basically that acquires a color,
it gets an RGBA color from a texture

00:20:05.490 --> 00:20:07.980
unit at a specified texture coordinate.

00:20:09.000 --> 00:20:11.670
So, we can see that I have a
temporary variable declared,

00:20:11.670 --> 00:20:13.000
which I've just called T0.

00:20:13.000 --> 00:20:18.820
And I am sampling from texture unit 1,
that's the second argument,

00:20:19.000 --> 00:20:22.000
from texture unit 1 into T0.

00:20:22.000 --> 00:20:26.000
And this fragment.textCord
that you can see,

00:20:26.000 --> 00:20:29.980
that is the interpolated texture
coordinate that it's using to look up at.

00:20:30.000 --> 00:20:35.000
And then I'm simply,
in the last instruction here,

00:20:35.000 --> 00:20:38.000
I'm moving T0 into result.color.

00:20:38.070 --> 00:20:40.700
Result.color is just,
it's sort of a fixed thing in

00:20:40.760 --> 00:20:44.000
the language which defines the
output color you're writing.

00:20:44.000 --> 00:20:46.580
Let's look at, that's something I can do.

00:20:46.630 --> 00:20:50.320
So, for instance, this texture 1,
that's the texture unit

00:20:50.320 --> 00:20:52.000
that I'm sampling from.

00:20:52.000 --> 00:20:54.350
So, as I change that,
you can see it's changing.

00:20:54.350 --> 00:20:56.000
That's very straightforward.

00:20:56.000 --> 00:20:58.900
Let's look at something a
little more interesting.

00:20:59.000 --> 00:21:01.290
Let's implement,
say we wanted a fragment program

00:21:01.290 --> 00:21:04.340
that would allow a program parameter
to adjust the brightness of the

00:21:04.340 --> 00:21:05.970
image and do it all in hardware.

00:21:07.000 --> 00:21:07.680
that.

00:21:07.970 --> 00:21:08.620
Okay.

00:21:08.620 --> 00:21:11.400
Let's create a new line
of code right here.

00:21:17.900 --> 00:21:22.940
So what we've done is we've
declared a parameter p which is

00:21:22.940 --> 00:21:28.270
bound to a program parameter,
meaning that there's now a GL entry point

00:21:28.340 --> 00:21:33.430
that I can call with index 0 and I can
pass in a floating point value which is

00:21:33.430 --> 00:21:35.810
sent to the card and run in this program.

00:21:35.900 --> 00:21:38.850
So let's implement a brightness control.

00:21:38.910 --> 00:21:40.900
Pretty straightforward.

00:21:40.900 --> 00:21:42.700
A simple multiply will do that.

00:21:42.890 --> 00:21:44.900
So let's do a multiply.

00:21:45.610 --> 00:21:47.900
Remember it's like assembly here.

00:21:47.900 --> 00:21:49.900
If you've written vertex
programs you'll be familiar.

00:21:49.900 --> 00:21:51.900
It's the destination first
and then the arguments.

00:21:51.900 --> 00:21:54.900
Multiply takes a destination
and two arguments.

00:21:54.980 --> 00:21:57.900
So we multiply t0 with the x component.

00:21:57.900 --> 00:22:01.850
That's the first one last
little change to make.

00:22:02.460 --> 00:22:06.460
- Hi, I'm James McCombe,
I'm the editor at OpenGL.

00:22:06.470 --> 00:22:12.390
I'm going to show you how to create a 3D
visual effect with the X component of P.

00:22:12.620 --> 00:22:16.100
Right now,
the brightness is at the bottom,

00:22:16.100 --> 00:22:18.370
so we're seeing it as black.

00:22:18.370 --> 00:22:18.780
But watch this.

00:22:18.780 --> 00:22:18.780
If we move over here,
you notice P is in this identifier list.

00:22:18.780 --> 00:22:18.780
I'll select that.

00:22:18.780 --> 00:22:18.780
I will open up an inspector right here,
it's the symbol editor right here.

00:22:19.010 --> 00:22:21.570
This allows me to change those values.

00:22:21.570 --> 00:22:25.660
So remember, the brightness is stored
in the X component.

00:22:25.660 --> 00:22:29.570
So I'm editing P, and you can see right
here where my mouse is,

00:22:29.890 --> 00:22:33.520
I can change the minimum and maximum
value this slider will go to,

00:22:33.520 --> 00:22:37.920
and I want to set the range to
go from zero through to two,

00:22:38.020 --> 00:22:39.480
just to keep reasonable values.

00:22:39.480 --> 00:22:42.630
And as I slide this right now,
you can see it's sending that

00:22:42.630 --> 00:22:45.300
value to the graphics card,
and the graphics card,

00:22:45.300 --> 00:22:47.780
there's a brightness control
implemented in hardware.

00:22:47.980 --> 00:22:49.480
That's pretty straightforward stuff.

00:22:49.560 --> 00:22:52.230
Let's now show, okay,
I want to implement a

00:22:52.230 --> 00:22:54.060
contrast control as well.

00:22:54.090 --> 00:22:58.310
I'm going to do a pretty cheesy
implementation of contrast here.

00:22:58.310 --> 00:23:01.720
I'm going to use the,
I'm just going to basically

00:23:01.720 --> 00:23:05.140
raise the color to a power where
that power is the contrast.

00:23:05.140 --> 00:23:10.400
And as I, if you may recall,
I mentioned that the power

00:23:10.400 --> 00:23:13.110
instruction is a scalar instruction.

00:23:13.250 --> 00:23:15.580
Note,
I only had one multiply instruction,

00:23:15.600 --> 00:23:19.660
yet it multiplied all the three red,
green, and blue components for me.

00:23:19.970 --> 00:23:22.260
Power will, the power instruction
will not work like that.

00:23:22.260 --> 00:23:24.220
So I'm going to need three of them,
and I'm going to need to

00:23:24.260 --> 00:23:25.190
do it for each channel.

00:23:25.360 --> 00:23:26.600
So I'm going to do that.

00:23:26.600 --> 00:23:28.600
So I'm dealing with the red channel here.

00:23:28.600 --> 00:23:35.760
Red channel dealt with.

00:23:41.200 --> 00:23:44.100
And you notice that
Shader Builder is keeping,

00:23:44.100 --> 00:23:47.480
like before,
as I type it's all real time.

00:23:47.480 --> 00:23:50.650
It's updating on the fly and it's
showing me all the syntax information,

00:23:50.670 --> 00:23:54.010
it's highlighting the
line that the error is on,

00:23:54.010 --> 00:23:56.580
it's just great to work with.

00:23:58.920 --> 00:23:59.900
Okay, we now have a contrast control.

00:23:59.900 --> 00:24:04.200
If I now take the Y component,
I set the range like I did the other one.

00:24:04.310 --> 00:24:06.550
0 through 5 happens to work well here.

00:24:06.790 --> 00:24:11.230
It's totally low contrast right now,
hence white, but notice as I increase

00:24:11.230 --> 00:24:13.470
the contrast here,
it's becoming more and

00:24:13.470 --> 00:24:14.700
more and more contrasty.

00:24:14.820 --> 00:24:17.610
And again,
the brightness control works as before.

00:24:17.740 --> 00:24:22.650
So this is a simple example of writing
a fragment program and showing how

00:24:22.770 --> 00:24:25.600
you get program parameters into it.

00:24:25.750 --> 00:24:32.450
So let's head on with
the presentation here.

00:24:32.450 --> 00:24:32.450
Back to the slides.

00:24:34.930 --> 00:24:41.260
I'm going to try and keep the rest
of this presentation pretty example

00:24:41.260 --> 00:24:45.290
centric and get you thinking here.

00:24:45.400 --> 00:27:06.800
[Transcript missing]

00:27:06.880 --> 00:27:12.940
- I'm going to open up the other
example which I have laid out here.

00:27:28.340 --> 00:27:42.060
: Switching to the Fragment Program,
it's a pretty straightforward

00:27:42.060 --> 00:27:42.810
Fragment Program.

00:27:42.820 --> 00:27:46.620
It does much like what I described
if you follow the comments.

00:27:46.620 --> 00:27:48.800
Let's take a look at what's
in the Texture Units.

00:27:48.800 --> 00:27:51.020
In Texture Unit 0,
we have this rock texture,

00:27:51.080 --> 00:27:53.140
which is the texture
I'm going to displace,

00:27:53.140 --> 00:27:54.940
I'm going to warp it.

00:27:54.940 --> 00:27:59.670
And then in Texture Unit 1,
I wrote a little program that basically

00:28:00.020 --> 00:28:04.800
just generated a spiral sort of effect
and it encoded those vectors as colors

00:28:04.800 --> 00:28:08.290
and put them into positive space,
which is what you're seeing in

00:28:08.290 --> 00:28:11.010
the Texture Unit right there,
in Texture Unit 1.

00:28:11.020 --> 00:28:13.780
So my first instruction here
is the text instruction,

00:28:13.780 --> 00:28:15.650
which samples the displacement map.

00:28:15.820 --> 00:28:18.480
I'll just highlight that right here.

00:28:18.480 --> 00:28:22.000
And then it does what I described,
which is scaling it from

00:28:22.000 --> 00:28:24.740
color space into a vector,
which has negative and positive.

00:28:24.740 --> 00:28:30.070
And then I have a program parameter,
a bit like what I showed

00:28:30.070 --> 00:28:33.490
in my last example,
where that allows me to control

00:28:33.490 --> 00:28:35.060
the magnitude of the effect.

00:28:35.060 --> 00:28:38.710
So by multiplying that vector
with a normalized magnitude,

00:28:38.750 --> 00:28:42.090
I can control how much of a
spiral effect is going on.

00:28:42.360 --> 00:28:43.700
I add it to the original.

00:28:43.700 --> 00:28:46.120
So I'm displacing the
texture coordinates here.

00:28:46.120 --> 00:28:47.120
That's how I'm doing the lookup.

00:28:47.120 --> 00:28:50.200
I'm actually changing the texture
coordinates for each fragment.

00:28:50.200 --> 00:28:51.940
That's how you do the warping effect.

00:28:51.940 --> 00:28:54.540
And then finally,
when I have a texture coordinate.

00:28:54.540 --> 00:29:00.660
I sample from the rock
texture map in Texture Unit 0.

00:29:00.660 --> 00:29:02.240
So let me show you what it looks like.

00:29:02.240 --> 00:29:06.480
So here, I select the magnitude
parameter in the list.

00:29:06.480 --> 00:29:10.620
I open the Symbol Editor again.

00:29:10.620 --> 00:29:14.180
And as I slide this,
you'll see there's actually

00:29:14.180 --> 00:29:16.220
a spiral effect going on.

00:29:16.280 --> 00:29:18.580
It might not look as good
as the Photoshop filter.

00:29:18.620 --> 00:29:22.050
But the reason for that is
simply because the quality of the

00:29:22.050 --> 00:29:24.340
displacement map that I put in.

00:29:24.340 --> 00:29:25.340
It was crudely generated.

00:29:25.350 --> 00:29:27.280
It was a simple program.

00:29:27.280 --> 00:29:30.920
You can imagine here how this
same code is totally generic.

00:29:30.920 --> 00:29:33.670
You could create a displacement
map that was a sine wave filter or

00:29:33.670 --> 00:29:35.580
any number of other displacements.

00:29:35.580 --> 00:29:39.630
And this same fragment program,
all I'm doing is sending four values,

00:29:39.630 --> 00:29:41.770
four floating point
values across the bus.

00:29:41.780 --> 00:29:43.740
And this is all running
on the graphics card.

00:29:43.760 --> 00:29:47.110
I think that's pretty exciting.

00:29:52.530 --> 00:29:57.500
So, let's see now, okay, yeah,
let's move on.

00:29:57.500 --> 00:30:01.010
Back to the slides again.

00:30:02.500 --> 00:32:19.100
[Transcript missing]

00:32:19.200 --> 00:37:22.700
[Transcript missing]

00:37:27.530 --> 00:37:31.730
: So basically this configuration
started off as three of those little

00:37:31.730 --> 00:37:33.990
arpentamino configurations I described.

00:37:34.280 --> 00:37:37.260
You can see it's sort of entered
a stable state right now.

00:37:37.260 --> 00:37:40.940
There's a little bit of movement,
but it's totally stable right now.

00:37:40.940 --> 00:37:44.500
So that was life running
on the graphics card.

00:37:44.500 --> 00:37:48.290
It's just kind of interesting.

00:37:54.700 --> 00:38:00.390
Can we cover it at the end?

00:38:00.390 --> 00:38:00.390
Thanks.

00:38:01.800 --> 00:38:02.500
Okay.

00:38:02.500 --> 00:38:07.020
Now, let's head back to the slides here.

00:38:07.020 --> 00:38:14.300
And let's look at how does optimization
apply to this new environment.

00:38:14.300 --> 00:38:18.530
That fragment program I showed
you was hideously unoptimal.

00:38:18.630 --> 00:38:19.610
It was long.

00:38:19.850 --> 00:38:22.100
It had lots and lots of
texture sample instructions.

00:38:22.100 --> 00:38:24.560
These are the very things that
you really don't want to be

00:38:24.560 --> 00:38:25.690
doing in a fragment program.

00:38:25.700 --> 00:38:27.640
Because, yes, it's very quick.

00:38:27.640 --> 00:38:29.430
It's very, very quick.

00:38:29.670 --> 00:38:30.470
But it could be quicker.

00:38:30.500 --> 00:38:35.440
And remember,
I was only -- I had a small window.

00:38:35.440 --> 00:38:41.880
And I was only texture mapping
the face of one polygon.

00:38:41.960 --> 00:38:45.090
If I was in a complicated
3D game environment,

00:38:45.090 --> 00:38:48.470
which I'm sure some of you
work on on a daily basis,

00:38:48.500 --> 00:38:50.040
performance really, really matters.

00:38:50.120 --> 00:38:53.310
And we're going to look at how
you can make big improvements in

00:38:53.320 --> 00:38:55.220
your fragment program performance.

00:38:55.250 --> 00:38:57.050
ShaderBuilder is going
to help you here a lot,

00:38:57.080 --> 00:38:57.560
I think.

00:39:01.610 --> 00:39:03.580
So, let's look at some of the
tricks that we can do.

00:39:03.580 --> 00:39:07.920
The first thing is, if possible,
why -- instead of calculating

00:39:08.020 --> 00:39:12.100
things in the fragment program,
if it's something that isn't

00:39:12.160 --> 00:39:16.680
absolutely necessary for -- to be
calculated on a per pixel basis,

00:39:16.960 --> 00:39:19.860
remember, you've still got your
vertex program running.

00:39:20.020 --> 00:39:29.530
That's running for every vertex.

00:39:29.880 --> 00:39:29.900
Now, for that example,
there were only four

00:39:29.900 --> 00:39:29.900
vertices defining a quad.

00:39:29.900 --> 00:39:29.900
But many, many, many fragments.

00:39:30.510 --> 00:39:33.480
: Why not calculate it on a
per-vertex basis if it doesn't

00:39:33.480 --> 00:39:36.460
need to be as high resolution?

00:39:36.460 --> 00:39:40.010
You can then pick up that data in
an interpolated form in the fragment

00:39:40.010 --> 00:39:45.530
program as those values will be
interpolated across the surface.

00:39:46.400 --> 00:39:51.890
The other useful thing is using
lookup tables at this time can

00:39:51.890 --> 00:39:55.710
bring performance benefits and I'm
going to show you how to do that.

00:39:56.420 --> 00:40:00.590
Instead of doing a calculation
in the fragment program,

00:40:00.800 --> 00:40:05.980
why not pre-generate at your application
launch time a table of numbers stored

00:40:05.980 --> 00:40:10.300
into a texture map and then be able to
sample that in your fragment program

00:40:10.300 --> 00:40:14.780
and there you have a lookup table,
just like you're familiar with.

00:40:16.300 --> 00:40:21.940
The instruction set is very rich,
so I would encourage you,

00:40:22.130 --> 00:40:24.100
and I know no one likes
to read the manual,

00:40:24.130 --> 00:40:27.990
but it's a good idea in this case
to read through the instructions.

00:40:28.010 --> 00:40:30.000
Shooter Builder has a
nice instruction browser.

00:40:30.000 --> 00:40:34.590
Go through them, learn your toolkit,
learn the instructions you have

00:40:34.590 --> 00:40:37.500
because you could be implementing
something in four or five

00:40:37.500 --> 00:40:40.300
instructions and you realize,
oh, there's just a strange instruction

00:40:40.300 --> 00:40:44.390
I've never heard of that actually
does all of this in one instruction.

00:40:44.400 --> 00:40:46.200
That's going to run faster
and as good as it can be.

00:40:46.310 --> 00:40:49.720
It's going to make your code shorter,
too.

00:40:49.850 --> 00:40:52.740
So let's look at optimizing
life specifically.

00:40:52.840 --> 00:40:54.510
How did I go about that?

00:40:54.610 --> 00:40:57.700
This part I'm a little concerned about
because it's a little hard to explain,

00:40:57.700 --> 00:41:01.230
but I'm going to do my best how I did it.

00:41:01.690 --> 00:41:07.630
This is a little clipping out of
the grid that Life was running on.

00:41:07.640 --> 00:41:12.920
It's that R-Pentomino
thing I was talking about.

00:41:12.920 --> 00:41:15.870
One of the things that added a lot
of instructions to that program

00:41:16.040 --> 00:41:21.130
that I showed you when I was
running through it was the process.

00:41:21.130 --> 00:41:25.050
Remember there were eight texture sample
instructions and that was sampling the

00:41:25.270 --> 00:41:27.910
state of all the surrounding cells.

00:41:28.320 --> 00:41:31.850
Well, that's a lot of texture
sample instructions.

00:41:31.850 --> 00:41:33.840
If we could do that in less,
it would be great.

00:41:33.840 --> 00:41:36.090
Not only do we have to
sample those texture,

00:41:36.270 --> 00:41:39.370
those eight times,
we also needed to calculate the

00:41:39.680 --> 00:41:42.100
surrounding coordinates to do that.

00:41:42.100 --> 00:41:43.960
We needed to calculate the
surrounding texture coordinates

00:41:43.960 --> 00:41:45.260
and there were eight of them.

00:41:45.260 --> 00:41:48.860
Well, I'm going to show you a way that
I went about it that actually

00:41:48.860 --> 00:41:53.800
has allowed me to drastically
cut down the instructions here.

00:41:53.800 --> 00:41:57.140
If we look carefully at
the Life configuration,

00:41:57.140 --> 00:42:01.080
we realize that it exists
only in one color in.

00:42:01.080 --> 00:42:04.760
It doesn't require the
three color channels.

00:42:04.760 --> 00:42:06.420
So let's take advantage of that.

00:42:06.420 --> 00:42:12.510
We realize that in Fragment program,
the instructions, 90% of them will deal,

00:42:12.510 --> 00:42:16.200
will operate in one instruction
like AlteVec almost.

00:42:16.200 --> 00:42:19.160
It will operate on all
four components at once.

00:42:19.160 --> 00:42:24.420
So if we can pack more data into those
channels and execute one instruction,

00:42:24.420 --> 00:42:27.390
we can do the work of like three or four.

00:42:28.200 --> 00:42:32.340
So what I did was outside
of the Fragment program,

00:42:32.340 --> 00:42:36.360
just before I did the feedback
where I was feeding it,

00:42:36.360 --> 00:42:40.440
where I was doing the feedback,
I actually took the sort of one bit

00:42:40.440 --> 00:42:44.820
image and I took it and I offset
it at one pixel to the left and

00:42:44.900 --> 00:42:47.720
I stamped it into the red channel.

00:42:47.720 --> 00:42:51.780
Then I offset it at one pixel to the
right and I offset it and I stamped it

00:42:51.820 --> 00:42:55.520
into the blue channel and then in the
center it was in the green channel.

00:42:55.520 --> 00:42:59.490
So I end up with, I've magnified it,
but you can see what I've got

00:42:59.630 --> 00:43:01.620
here on the right hand side.

00:43:01.700 --> 00:43:05.620
And that shows you how
I've packed the data in.

00:43:05.650 --> 00:43:09.890
This is really good because
now if I do one texture sample

00:43:09.890 --> 00:43:13.040
in the Fragment program,
by accessing the red,

00:43:13.050 --> 00:43:17.480
green and blue channels independently,
I have got the state of

00:43:17.480 --> 00:43:19.840
the left and right pixels.

00:43:19.840 --> 00:43:21.340
Meaning to get all the
surrounding neighbors,

00:43:21.370 --> 00:43:21.830
all I need to do is read the,
is three texture samples.

00:43:21.830 --> 00:43:22.120
Instead of just one.

00:43:22.620 --> 00:43:30.220
I only need three.

00:43:30.220 --> 00:43:32.020
And then by using the red,
green and blue channels,

00:43:32.020 --> 00:43:35.210
I've got all the pixels.

00:43:35.240 --> 00:43:36.600
That's a useful thing.

00:43:36.600 --> 00:43:39.600
The other important thing is
remember that nasty logic that

00:43:39.600 --> 00:43:45.580
I implemented which was to choose
whether the cell would be on or off?

00:43:45.580 --> 00:43:47.880
Well,
that was like six or seven instructions.

00:43:47.900 --> 00:43:50.280
Let's get rid of those
with like one instruction.

00:43:50.280 --> 00:43:52.020
Let's create a lookup table.

00:43:52.020 --> 00:43:54.350
James McCombe Here is a texture map.

00:43:54.350 --> 00:43:56.780
It's a two by eight texture map.

00:43:56.890 --> 00:44:02.210
And basically what we do
is on the Y component,

00:44:02.300 --> 00:44:06.280
on the Y,
in the texture coordinate Y component,

00:44:06.280 --> 00:44:08.880
we just put in a one or a zero.

00:44:08.880 --> 00:44:10.740
Is the current cell on or off?

00:44:10.740 --> 00:44:13.830
And on the X component,
we have the number of

00:44:13.840 --> 00:44:15.600
neighbors that we calculated.

00:44:15.690 --> 00:44:20.860
And by simply doing a texture
sample with that lookup value,

00:44:20.880 --> 00:44:21.780
it's a lookup table.

00:44:21.930 --> 00:44:22.150
We get back.

00:44:22.670 --> 00:44:23.620
So,
we've got the color of the output cell.

00:44:23.620 --> 00:44:30.780
That's another pretty useful
thing to be able to do.

00:44:30.780 --> 00:44:34.100
After doing that, here was the benefit.

00:44:34.100 --> 00:44:36.560
Remember,
Shader Builder had that nice thing that

00:44:36.560 --> 00:44:40.840
would show you the number of instructions
and the number of texture samples that

00:44:40.900 --> 00:44:42.680
were going on on the graphics card?

00:44:42.930 --> 00:44:46.370
Well, I just created a chart to show you
what I was able to get it down to.

00:44:46.490 --> 00:44:48.390
And it runs exactly the same.

00:44:48.510 --> 00:44:50.020
It looks no different.

00:44:50.350 --> 00:44:51.460
Except it's faster.

00:44:51.460 --> 00:44:52.460
If you measure it.

00:44:52.460 --> 00:44:55.260
So, I'm going to measure it.

00:44:55.260 --> 00:44:58.770
What we see here is the
instructions went down from 36

00:44:58.770 --> 00:45:00.640
instructions down to 9 instructions.

00:45:00.640 --> 00:45:02.660
That's a pretty big deal.

00:45:02.660 --> 00:45:04.570
Texture samples,
those are expensive to run

00:45:04.570 --> 00:45:06.770
on the graphics hardware.

00:45:06.950 --> 00:45:09.860
Got those down from 9 down to 4.

00:45:09.860 --> 00:45:12.410
Temporary variables, well,
not 13 of them anymore.

00:45:12.410 --> 00:45:13.750
Got those down to 5.

00:45:13.760 --> 00:45:17.980
And then this last one is interesting.

00:45:18.190 --> 00:45:20.630
A DTR that expands that for you.

00:45:20.660 --> 00:45:22.790
It's a dependent texture read.

00:45:22.920 --> 00:45:27.610
What a dependent texture read is,
so I've shown you the text instruction

00:45:27.620 --> 00:45:32.730
which allows you to take a texture
coordinate and look up and get a

00:45:32.870 --> 00:45:36.090
pixel back from a texture unit.

00:45:36.110 --> 00:45:41.500
Well, imagine that the coordinate that
I used to look that up was actually

00:45:41.500 --> 00:45:45.220
derived from a previous texture sample.

00:45:45.280 --> 00:45:48.100
You can imagine that you have
dependencies between them.

00:45:48.190 --> 00:45:50.600
Well,
for every one of those dependencies,

00:45:50.600 --> 00:45:53.100
that's known as a dependent texture read.

00:45:53.100 --> 00:45:57.770
The graphics hardware has
support for four of these.

00:45:59.080 --> 00:46:03.260
I am now using one of them.

00:46:03.260 --> 00:46:06.860
It's still a huge
performance improvement.

00:46:06.860 --> 00:46:08.600
Dependent texture reads,
if you're going to use lookup

00:46:08.600 --> 00:46:11.460
tables in your program,
you're going to inevitably use these.

00:46:11.460 --> 00:46:12.220
You've got four of them.

00:46:12.280 --> 00:46:16.540
I find that is more than enough for
anything that I'm going to implement.

00:46:16.540 --> 00:46:18.830
You can look into that after.

00:46:19.000 --> 00:46:24.480
Now, this is my final part
that I'm going to look at.

00:46:24.480 --> 00:46:29.280
This part has had me most concerned
because it seems that a lot of -- when

00:46:29.280 --> 00:46:34.420
I look at other demo programs of people
who have maybe implemented per-pixel

00:46:34.420 --> 00:46:38.950
lighting models using not necessarily our
fragment program but other extensions,

00:46:38.950 --> 00:46:43.060
I find it personally very hard
to understand what they're doing.

00:46:43.100 --> 00:46:44.310
I've looked at their examples.

00:46:44.310 --> 00:46:46.340
Yeah, they look cool,
but it's like I'm not really

00:46:46.340 --> 00:46:47.470
sure what they're doing.

00:46:47.600 --> 00:46:51.650
So what I've done here is I just threw
a lot away and started from scratch,

00:46:51.650 --> 00:46:54.800
implemented my interpretation
of a lighting model,

00:46:54.800 --> 00:46:59.520
which I think is correct,
and it looks good.

00:46:59.520 --> 00:47:01.530
And I'm going to just
explain step by step.

00:47:02.000 --> 00:47:05.040
I'm going to break it apart for you,
show it how it's done,

00:47:05.040 --> 00:47:08.170
and try and dispel any
of the mystery there.

00:47:08.180 --> 00:47:11.830
So there's certainly some
3D math involved here,

00:47:11.830 --> 00:47:15.460
but I'm sure it should
be quite understandable.

00:47:15.460 --> 00:47:18.130
Before explaining it,
let's look at what the

00:47:18.130 --> 00:47:20.440
contributing entities to this are.

00:47:20.440 --> 00:47:24.300
What are the sort of inputs
to this fragment program?

00:47:24.300 --> 00:47:28.340
The first one is the position of
the fragment of the light source.

00:47:28.340 --> 00:47:31.780
Where the light source is relative
to the fragment that we're

00:47:31.780 --> 00:47:34.580
currently calculating the color of.

00:47:34.580 --> 00:47:37.040
Well, so we're going to call that LP.

00:47:37.040 --> 00:47:40.120
The other thing is I have support
for variable brightness lights,

00:47:40.210 --> 00:47:41.270
so that's another thing.

00:47:41.350 --> 00:47:46.340
For the light source, we have another,
just a scalar, which is how bright it is.

00:47:46.340 --> 00:47:51.340
The next important thing is where
is the fragment in 3D space?

00:47:51.340 --> 00:47:53.520
Where is it located?

00:47:53.560 --> 00:47:56.550
That's important to know as well,
because we're going to use

00:47:56.550 --> 00:47:58.960
it to calculate a vector from
the light to the fragment.

00:47:59.130 --> 00:48:01.520
It's important to know that.

00:48:01.520 --> 00:48:05.700
The other important thing is
the normal of the fragment.

00:48:05.700 --> 00:48:09.100
This is the key part that makes
per-pixel lighting models look so cool.

00:48:09.100 --> 00:48:14.180
And that is that the normals,
unlike the OpenGL traditional

00:48:14.180 --> 00:48:16.960
lighting model,
where normals are only

00:48:16.960 --> 00:48:21.490
exist on a per-vertex basis,
and they're interpolated across

00:48:21.600 --> 00:48:25.080
the surface of the polygon,
here the normals are

00:48:25.080 --> 00:48:27.660
on a per-pixel basis,
meaning we can create these

00:48:27.660 --> 00:48:29.310
amazing detailed surfaces.

00:48:29.390 --> 00:48:33.380
And the way it's done is if you
recall back to when I showed you my

00:48:33.380 --> 00:48:37.720
displacement map where I had encoded
a two-dimensional vector into a color,

00:48:37.720 --> 00:48:40.340
this is exactly the same thing,
except we're encoding a

00:48:40.340 --> 00:48:43.280
three-dimensional vector into each color.

00:48:43.510 --> 00:48:45.760
So not only an XY, but an XYZ.

00:48:46.140 --> 00:48:50.410
So we're able to encode a
three-dimensional normal

00:48:50.410 --> 00:48:51.920
into a texture map.

00:48:52.040 --> 00:48:55.250
And by sampling that in
the fragment program,

00:48:55.290 --> 00:49:00.050
I can get the normal at that point,
which is the large reason

00:49:00.050 --> 00:49:02.600
why this looks so good.

00:49:02.600 --> 00:49:06.220
And then finally,
we have the fragment -- we're

00:49:06.400 --> 00:49:11.140
calculating the colors of the
fragments on the surface of a polygon,

00:49:11.140 --> 00:49:14.790
so we need to know the normal of
that entire polygon so that we

00:49:14.810 --> 00:49:16.820
can transform the fragment normal.

00:49:16.820 --> 00:49:19.360
We'll cover that in a minute.

00:49:19.360 --> 00:49:23.200
Another useful thing I did to make
this program simpler was I wanted to

00:49:23.250 --> 00:49:26.040
calculate everything in model space.

00:49:26.180 --> 00:49:29.130
So the -- in your 3D game,
your light sources,

00:49:29.130 --> 00:49:33.840
you're probably going to want to define
them in world space or eye space.

00:49:33.840 --> 00:49:37.180
You're going to want to define
them relative to your world.

00:49:37.180 --> 00:49:40.490
And then what I did was
in the vertex program,

00:49:40.570 --> 00:49:45.470
I multiplied by that -- by the inverse
model view matrix to transform it into

00:49:45.470 --> 00:49:51.380
model space so the fragment program
had something easier to work with.

00:49:51.380 --> 00:49:53.350
So I've already actually
covered the normal map,

00:49:53.350 --> 00:49:56.140
kind of what it is,
but this is what it looks like.

00:49:56.140 --> 00:49:59.040
That's the base texture
map that I'm going to use.

00:49:59.040 --> 00:50:02.070
And you can see the one
below is the normal map.

00:50:02.210 --> 00:50:05.150
Well,
these psychedelic colors are the -- are

00:50:05.150 --> 00:50:08.600
what define the bumpiness of the surface.

00:50:08.600 --> 00:50:11.930
Again, the same little trick applies.

00:50:11.970 --> 00:50:15.000
I have to do this sort of -- you know,
normals are obviously they range

00:50:15.000 --> 00:50:16.340
from -- they're normalized.

00:50:16.340 --> 00:50:18.830
They range from minus one through one.

00:50:18.910 --> 00:50:21.690
I have to squash them and push
them up into positive space

00:50:21.920 --> 00:50:26.100
using this super simple equation.

00:50:26.100 --> 00:50:26.100
And I'll unpack them in the front.

00:50:26.100 --> 00:50:27.100
So I've got a little bit of time.

00:50:27.100 --> 00:50:28.480
We're going to get into
the next step here.

00:50:28.480 --> 00:50:33.950
I'm going to go back to the program.

00:50:34.000 --> 00:50:37.060
I'm going to go back to
the fragment program.

00:50:37.290 --> 00:50:41.630
So quick run through
before I demonstrate it,

00:50:42.110 --> 00:50:44.740
what's going on here.

00:50:44.740 --> 00:50:44.740
We calculate the vector from the light to

00:50:45.170 --> 00:50:49.090
: Light vector incoming, LVI.

00:50:49.170 --> 00:50:53.040
Then, when we've done that,
it's pretty trivial to

00:50:53.040 --> 00:50:55.990
calculate the distance,
just a scalar, the distance from the

00:50:55.990 --> 00:50:56.890
light to the fragment.

00:50:56.960 --> 00:50:59.210
If we know the vector,
we can get the magnitude,

00:50:59.280 --> 00:51:00.330
and that's the distance.

00:51:00.450 --> 00:51:04.340
And that we use to attenuate
the light later on,

00:51:04.340 --> 00:51:07.230
to get attenuation in here also.

00:51:07.420 --> 00:51:10.590
Then we acquire the fragment normal,
like I described,

00:51:10.590 --> 00:51:13.570
we sample the normal map,
and we get the normal.

00:51:14.010 --> 00:51:18.940
fn, then we transform that relative
to the surface of the polygon.

00:51:18.940 --> 00:51:20.540
I explained that in a moment ago too.

00:51:20.540 --> 00:51:24.660
Then the good part,
if we know the fragment normal,

00:51:24.690 --> 00:51:27.840
and we know the incoming light vector,
we want to calculate it

00:51:27.880 --> 00:51:29.080
after it's reflected.

00:51:29.310 --> 00:51:32.360
So it comes in and we get
it coming out like that.

00:51:32.460 --> 00:51:34.420
We do that for every fragment.

00:51:34.540 --> 00:51:36.560
That's important also.

00:51:36.560 --> 00:51:40.640
And then when we have that,
we do a dot product between that

00:51:40.670 --> 00:51:44.160
and with the incident light ray,
and then the direction

00:51:44.160 --> 00:51:45.300
of the light source.

00:51:45.330 --> 00:51:47.950
So in this lighting model,
you could actually not just

00:51:47.980 --> 00:51:50.520
necessarily have the light pointing
directly down on the surface,

00:51:50.530 --> 00:51:52.650
but you could have it sort
of going along the surface.

00:51:52.660 --> 00:51:53.600
You can change it.

00:51:53.620 --> 00:51:55.810
I've actually made it fixed right now,
but there's no reason

00:51:55.810 --> 00:51:56.750
I couldn't move it around.

00:51:56.760 --> 00:52:01.030
I just wanted to have not spent
so much time here on this.

00:52:01.350 --> 00:52:05.970
Then the next thing is
to do the attenuation.

00:52:05.980 --> 00:52:09.830
Remember, LD, we calculated the distance
from the light to the fragment.

00:52:09.960 --> 00:52:13.730
We're going to use that to
attenuate the light intensity,

00:52:13.730 --> 00:52:17.580
which will create sort of a fall off,
which is important also.

00:52:17.740 --> 00:52:20.320
Like for instance,
if I hold a light here,

00:52:20.320 --> 00:52:23.410
a little light here shining on this,
it's not going to have very much

00:52:23.560 --> 00:52:25.160
effect lighting up the far wall.

00:52:25.210 --> 00:52:26.360
That's the attenuation.

00:52:26.630 --> 00:52:32.460
And then we modulate that with
the light brightness control.

00:52:32.500 --> 00:52:35.540
So quickly,
a little bit of animation here.

00:52:35.540 --> 00:52:39.080
This is the surface over polygon, FP.

00:52:39.280 --> 00:52:41.180
That's the current
fragment we're calculating.

00:52:41.180 --> 00:52:46.600
Here we have the FN, the fragment normal,
which I acquired from the texture lookup.

00:52:46.750 --> 00:52:48.900
It's encoded in the red, green,
blue channels.

00:52:48.960 --> 00:52:52.280
Here's our incoming light vector,
like so.

00:52:52.290 --> 00:52:56.800
Then we calculate after
reflection with the normal.

00:52:56.810 --> 00:52:59.720
And then LD, that was the distance
I was talking about.

00:52:59.750 --> 00:53:03.040
So I think it's probably very clear in
your heads now what I'm going to do.

00:53:03.280 --> 00:53:08.120
And I'm going to move over to Shader
Builder now to illustrate this in action.

00:53:08.120 --> 00:53:10.520
I'll show you how really
pretty cool it looks.

00:53:11.180 --> 00:53:18.670
So let's close our previous example.

00:53:29.600 --> 00:53:38.400
[Transcript missing]

00:53:38.910 --> 00:53:45.290
is that in range?

00:53:45.290 --> 00:53:45.290
Can you see it?

00:53:45.290 --> 00:53:45.290
Is that good?

00:53:45.290 --> 00:53:45.290
Okay.

00:53:46.700 --> 00:53:51.230
So if you can see this,
here's the fragment program.

00:53:51.240 --> 00:53:54.400
I'm not going to go into it on
a per-instruction basis on this.

00:53:54.400 --> 00:53:56.190
It simply would take too long.

00:53:56.260 --> 00:54:00.260
This, again, this exact thing I'm editing
right now on stage will be

00:54:00.260 --> 00:54:02.200
available as a demo afterwards.

00:54:02.200 --> 00:54:04.300
So you can go home,
you can run it on ShaderBuilder

00:54:04.300 --> 00:54:09.340
on your new G5 that you buy,
and then you'll be able to see this.

00:54:09.570 --> 00:54:12.890
You'll be able to see it,
play around with it.

00:54:12.980 --> 00:54:16.640
What I've done here is I've
actually commented out.

00:54:16.690 --> 00:54:20.500
I designed the program in such a way
that the exact order of the stages

00:54:20.500 --> 00:54:24.400
I described to you are the exact order
of the instructions in this program.

00:54:24.400 --> 00:54:27.100
And I put a comment that
matches that exactly.

00:54:27.120 --> 00:54:29.830
So when you look at it and you
look at my corresponding slide,

00:54:30.070 --> 00:54:33.840
you can walk your way
through this program after.

00:54:33.940 --> 00:54:36.100
So let's take a look.

00:54:36.120 --> 00:54:39.300
Texture unit one,
there's our normal map in the

00:54:39.300 --> 00:54:41.690
bottom right corner of the screen.

00:54:41.910 --> 00:54:44.780
In texture unit zero,
I have the base texture,

00:54:44.790 --> 00:54:46.700
which is the gargoyle face.

00:54:46.710 --> 00:54:51.300
In the rendering window right now,
what you're seeing is for every fragment,

00:54:51.300 --> 00:54:55.200
you're seeing the color,
you're seeing the incoming

00:54:55.340 --> 00:55:00.380
light vectors displayed for you,
encoded and decoded as a color.

00:55:00.530 --> 00:55:05.990
So if I go here and I open
up the symbol editor,

00:55:06.200 --> 00:55:09.860
This will allow me to move
the light source around.

00:55:09.950 --> 00:55:12.150
So here I'm moving the
light position around,

00:55:12.160 --> 00:55:13.960
and you can see the vectors are updating.

00:55:14.020 --> 00:55:16.040
Let's pull the light
back from the surface.

00:55:16.040 --> 00:55:16.880
You can see it.

00:55:16.890 --> 00:55:18.020
Move it close to the surface there.

00:55:18.020 --> 00:55:18.860
It's right at the light.

00:55:18.860 --> 00:55:19.960
It's right on the plane now.

00:55:20.100 --> 00:55:22.440
You can see a little singularity there.

00:55:22.650 --> 00:55:24.040
So let's put it back.

00:55:24.080 --> 00:55:29.330
Now, let's start uncommenting some code
and watch this effect build up.

00:55:30.100 --> 00:55:34.700
Let's calculate the vectors after
they've been reflected off the surface.

00:55:34.720 --> 00:55:39.080
And this also depends
on the fragment normal,

00:55:39.080 --> 00:55:40.130
which comes from the normal map.

00:55:40.140 --> 00:55:42.830
So let's uncomment those lines.

00:55:43.030 --> 00:55:51.790
These are the light
vectors after reflection.

00:55:51.790 --> 00:55:51.790
Again, move the light around,
you can see them updating right there.

00:55:51.970 --> 00:55:54.160
Let's now do the dot product
that I described with the

00:55:54.160 --> 00:55:56.900
light direction vector,
which is a constant right now.

00:55:56.900 --> 00:55:58.900
Move it around again.

00:55:58.980 --> 00:56:00.900
You can see it moving around.

00:56:01.250 --> 00:56:03.760
And then let's do the attenuation.

00:56:03.770 --> 00:56:05.220
And you'll see this
makes a big difference.

00:56:05.470 --> 00:56:06.010
That looks better.

00:56:06.060 --> 00:56:12.930
And then the next stage is we
multiply it by the color of the light.

00:56:12.940 --> 00:56:14.810
The moment the light is just white light.

00:56:14.830 --> 00:56:16.430
Well, we want to be able to
have that controllable,

00:56:16.490 --> 00:56:17.610
so we do that.

00:56:18.680 --> 00:56:19.710
We've got a colorful light.

00:56:19.770 --> 00:56:23.700
And then finally, we modulate that with
the base texture map,

00:56:24.100 --> 00:56:25.880
which we now have.

00:56:26.100 --> 00:56:27.000
That's that.

00:56:27.000 --> 00:56:31.240
Now if we move the light source around,
you can see how good this looks.

00:56:31.240 --> 00:56:43.400
I'm going to make this window bigger
so you can see it more clearly.

00:56:48.210 --> 00:56:50.440
We pull the light away from the surface.

00:56:50.460 --> 00:56:51.460
You see it's getting far away.

00:56:51.620 --> 00:56:54.200
The light's so far away now
that it isn't even showing up.

00:56:54.380 --> 00:56:56.200
Bring it in really, really, really close.

00:56:56.200 --> 00:56:58.170
So I think it looks pretty good.

00:56:58.290 --> 00:57:03.200
And then we can also, of course,
we can change the color of the light.

00:57:03.200 --> 00:57:04.200
That's another program parameter.

00:57:04.200 --> 00:57:08.200
If I adjust that,
I can edit it as a color.

00:57:08.200 --> 00:57:10.200
You see it's changing the color as well.

00:57:10.220 --> 00:57:13.200
So multiple parameters as well
is supported in Shader Builder.

00:57:13.200 --> 00:57:22.050
So that certainly should be fun
for you to be able to look at.

00:57:22.240 --> 00:57:27.240
So, at the end of, I've reached the end
of my presentation now.

00:57:27.310 --> 00:57:30.800
I hope you all find this enlightening.

00:57:30.800 --> 00:57:34.590
And I hope that you'll go home
afterwards and we'll run the new shader

00:57:34.590 --> 00:57:37.200
builder and look at these examples.

00:57:37.690 --> 00:57:41.380
Because I think there's a lot
to learn here and a lot of scope

00:57:41.450 --> 00:57:44.050
for implementing these things.

00:57:44.050 --> 00:57:49.390
So, thanks a lot and I think I'm
going to hand back to Travis here.

00:57:52.430 --> 00:57:54.400
Thank you, James.

00:57:54.400 --> 00:57:57.870
If you have any questions on the
information that you've seen today,

00:57:57.980 --> 00:58:00.470
feel free to contact any one of
these email addresses up there.

00:58:00.600 --> 00:58:02.300
I'd like to actually add mine to it.

00:58:02.300 --> 00:58:04.400
I'm Travis at Apple.com.

00:58:04.540 --> 00:58:08.960
And again,
any questions about the graphics

00:58:08.960 --> 00:58:15.080
technologies or various things
you've seen relating to 2D

00:58:15.080 --> 00:58:15.560
and 3D graphics at WWDC,
feel free to email me

00:58:15.560 --> 00:58:15.560
with your questions.
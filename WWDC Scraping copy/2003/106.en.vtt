WEBVTT

00:00:26.580 --> 00:00:31.200
What I'm here to talk
about today is application,

00:00:31.200 --> 00:00:33.440
inter-application
communication on Mac OS X.

00:00:34.000 --> 00:00:36.900
There are a lot of
different ways of achieving

00:00:36.900 --> 00:00:40.150
inter-application communication,
but I want you to get out of this talk

00:00:40.330 --> 00:00:44.570
the understanding of what frameworks
are available and some of the different

00:00:44.570 --> 00:00:46.380
limitations of the frameworks.

00:00:46.380 --> 00:00:49.270
When we talk about
inter-application communication,

00:00:49.270 --> 00:00:52.400
when you get right down to it,
the operating system is kind of

00:00:52.400 --> 00:00:54.300
like just another application.

00:00:54.390 --> 00:00:56.800
When you request a service
from the operating system,

00:00:56.800 --> 00:01:01.270
you're making an interprocess call,
and the kernel is going to

00:01:01.270 --> 00:01:03.360
give you back some result.

00:01:03.630 --> 00:01:08.140
And it really lets you think about
the whole system as individual

00:01:08.140 --> 00:01:11.150
applications are building blocks,
just like frameworks are building blocks

00:01:11.150 --> 00:01:13.000
that let you build your application.

00:01:13.120 --> 00:01:18.800
Only when applications are participating
in interprocess communication,

00:01:18.990 --> 00:01:21.700
they can all be put together by users.

00:01:21.700 --> 00:01:24.380
That's really scripting,
and I'll get to scripting

00:01:24.380 --> 00:01:25.510
quite a bit later.

00:01:41.450 --> 00:01:41.450
So there are different
frameworks in our system.

00:01:41.450 --> 00:01:41.450
Our system has a long legacy
from Unix to Mac OS 9 APIs,

00:01:41.450 --> 00:01:41.450
7 APIs, and Objective-C APIs,
and it keeps growing into the future.

00:01:41.450 --> 00:01:41.450
And all these different APIs are
going to be available to us.

00:01:41.960 --> 00:01:45.650
So this is what I'm hoping you'll
learn coming out of this session.

00:01:45.660 --> 00:01:46.890
What frameworks are available?

00:01:46.900 --> 00:01:48.560
What APIs are available?

00:01:48.580 --> 00:01:52.770
A familiarity with these APIs and
what they're all capable of.

00:01:54.340 --> 00:01:56.390
I want you to be able to decide
whether there's an existing

00:01:56.410 --> 00:01:59.850
conversation someplace that would
make sense for you to participate in.

00:01:59.950 --> 00:02:03.340
The scripting conversations,
there's a well-established community

00:02:03.340 --> 00:02:04.860
of scripting that's available.

00:02:04.860 --> 00:02:07.920
So you would want to plug into
that with your application so that

00:02:07.920 --> 00:02:11.190
scripters can script your application.

00:02:11.310 --> 00:02:13.030
And then there's finding
someone to talk to.

00:02:13.050 --> 00:02:15.830
This is actually a
really important thing.

00:02:15.830 --> 00:02:18.750
And because of the way our
system partitions applications

00:02:18.770 --> 00:02:22.400
into their own address space,
the behavior of finding somebody to

00:02:22.400 --> 00:02:26.900
talk to is different in Mac OS X than
it's ever been in Mac OS 9.

00:02:27.040 --> 00:02:31.070
There's been a lot of confusion about
this and how things don't quite work

00:02:31.140 --> 00:02:33.200
the way they did under Mac OS 9.

00:02:33.400 --> 00:02:37.110
And I'm hoping that we'll be able
to explain some of why that is.

00:02:37.800 --> 00:02:41.210
So here are the frameworks that
we're basically going to talk about.

00:02:41.440 --> 00:02:44.880
There's the Unix and
Mach APIs that came out of,

00:02:45.110 --> 00:02:47.360
well, Darwin, basically.

00:02:47.790 --> 00:02:51.880
and Apple Events and
Objective-C distributed objects are,

00:02:51.970 --> 00:02:54.100
of course, an application layer API.

00:02:54.100 --> 00:02:57.560
It's a much higher level of
doing interprocess communication.

00:02:57.560 --> 00:03:02.180
These can both be used locally between
processes and over the network with other

00:03:02.410 --> 00:03:04.760
applications running on other machines.

00:03:04.760 --> 00:03:07.710
And then finally,
Web Services and what we're

00:03:07.780 --> 00:03:11.650
doing with Web Services in
the application frameworks.

00:03:12.940 --> 00:03:15.320
All right, so here's our bubbly diagram.

00:03:15.320 --> 00:03:21.740
It shows basically where POSIX and
UNIX live and Mach Messaging

00:03:21.740 --> 00:03:22.940
lives right at the bottom.

00:03:22.940 --> 00:03:25.750
Application frameworks live on top,
and then your applications

00:03:25.750 --> 00:03:26.750
live on top of that.

00:03:26.760 --> 00:03:30.500
So let's talk just first
about POSIX streams.

00:03:30.500 --> 00:03:31.790
All right.

00:03:33.560 --> 00:03:36.040
POSIX streams are, well,
POSIX pipes and sockets

00:03:36.140 --> 00:03:37.930
are typically stream-based.

00:03:37.930 --> 00:03:41.170
What we mean by that is you're going
to write a byte in one end and you're

00:03:41.170 --> 00:03:43.100
going to read a byte out of the other.

00:03:43.100 --> 00:03:46.620
And there are a couple of
different APIs in that space.

00:03:46.620 --> 00:03:49.600
Pipe and socket are
probably the most common.

00:03:49.600 --> 00:03:53.880
This is how you create one of these
file descriptors that you're going

00:03:53.940 --> 00:03:56.490
to write data to or read data out of.

00:03:56.530 --> 00:04:00.380
The to in parentheses, by the way,
that means there's a man page for this.

00:04:00.380 --> 00:04:02.550
I know a lot of you
are old Mac developers.

00:04:02.560 --> 00:04:04.360
Some of you are Unix developers.

00:04:04.480 --> 00:04:07.010
Man pages are going to be
somewhat new to Mac developers

00:04:07.010 --> 00:04:08.470
that haven't used Unix a lot.

00:04:08.590 --> 00:04:11.820
So when you see that to,
go ahead and type man to pipe and

00:04:11.820 --> 00:04:13.620
you'll get some information about it.

00:04:13.640 --> 00:04:17.940
So pipe and socket are ways
of creating a file descriptor.

00:04:17.940 --> 00:04:22.490
Socket can be used to create
interprocess file descriptors.

00:04:22.490 --> 00:04:25.180
That's the AF Unix address family.

00:04:25.180 --> 00:04:29.570
And it can also be used to create
TCP IP pipes so that logically you're

00:04:29.710 --> 00:04:34.150
just writing to a file descriptor,
but you're really going out over a

00:04:34.150 --> 00:04:36.580
network and talking to another site.

00:04:36.580 --> 00:04:38.850
Now the important thing about
file descriptors is that by

00:04:39.000 --> 00:04:40.980
default they're going to block.

00:04:41.000 --> 00:04:43.900
If you do a read and
there's no data available,

00:04:43.900 --> 00:04:47.640
your process is now blocked
waiting for that read to complete.

00:04:47.640 --> 00:04:51.190
So if you have multiple file
descriptors that you want to read from,

00:04:51.190 --> 00:04:52.580
you don't want to do that.

00:04:52.580 --> 00:04:56.040
You don't want to have three
threads all blocked and read.

00:04:56.040 --> 00:04:58.660
You want to use a function called select.

00:04:58.660 --> 00:05:02.440
This lets you say here are a bunch
of file descriptors that I want to

00:05:02.590 --> 00:05:06.030
know when data becomes available
or when their state changes.

00:05:06.140 --> 00:05:09.500
Select takes that array and
it blocks and then returns

00:05:09.500 --> 00:05:12.820
when there is data available.

00:05:12.820 --> 00:05:12.820
Excuse me.

00:05:13.000 --> 00:05:19.800
[Transcript missing]

00:05:35.210 --> 00:05:35.210
Well,
I'll talk about it more in a few slides,

00:05:35.210 --> 00:05:35.210
but basically it's a way of
presenting data to other applications.

00:05:35.210 --> 00:05:35.210
And typically,
you don't want that data to be changing

00:05:35.210 --> 00:05:35.210
while other applications are using it.

00:05:35.210 --> 00:05:35.210
I'll talk about that in a couple slides.

00:05:35.530 --> 00:05:38.600
Pipes and sockets are the most
portable interprocess communication

00:05:38.600 --> 00:05:41.500
mechanism on our platform,
as long as most portable

00:05:41.500 --> 00:05:42.600
means other Unixes.

00:05:42.600 --> 00:05:48.120
If you're porting a Linux application,
chances are if it's

00:05:48.120 --> 00:05:50.680
using pipes and sockets,
it's just going to work out of the box.

00:05:50.680 --> 00:05:51.410
And that's fine.

00:05:51.410 --> 00:05:52.770
There's nothing wrong with that.

00:05:52.820 --> 00:05:56.240
But it isn't well supported
by the Mac OS X application

00:05:56.240 --> 00:06:01.090
frameworks because your application,
especially applications with UI,

00:06:01.090 --> 00:06:04.270
are receiving events
from multiple sources.

00:06:04.270 --> 00:06:06.370
Events are coming in
from the Windows server.

00:06:06.370 --> 00:06:08.120
Events are coming in from IOCit.

00:06:08.140 --> 00:06:12.310
You need to be able to capture all
these events in a single place.

00:06:12.310 --> 00:06:14.540
That's what the run loop is for.

00:06:14.540 --> 00:06:18.980
So if you're trying to read
data out of a file descriptor,

00:06:18.980 --> 00:06:22.800
you're going to want to wrap it in
something that has some affinity for it.

00:06:22.900 --> 00:06:26.270
It's going to allow the run loop
to do its job of demultiplexing

00:06:26.340 --> 00:06:30.060
several incoming messages and
sending them to your application,

00:06:30.260 --> 00:06:32.610
letting your application deal with it.

00:06:32.720 --> 00:06:36.050
CFStream,
part of the core foundation network,

00:06:36.130 --> 00:06:38.960
does this by sort of emulating select.

00:06:38.960 --> 00:06:41.730
It's an implementation
detail how that works.

00:06:41.860 --> 00:06:45.650
But the upshot is you can use
a CFStream wrapped around a

00:06:45.650 --> 00:06:50.700
file descriptor and receive
notifications when data is available.

00:06:50.700 --> 00:06:52.750
And that's a really good idea
if you're trying to do that.

00:06:52.820 --> 00:06:57.440
You can use a file descriptor based
I/O within a higher level application.

00:06:57.440 --> 00:07:03.120
So pipes and sockets aren't terribly
efficient for large transfers of data,

00:07:03.120 --> 00:07:07.110
arbitrary data,
because every byte that gets written

00:07:07.190 --> 00:07:09.600
gets read out the other side.

00:07:10.410 --> 00:07:14.300
What you see then is just a
linear time to send a message,

00:07:14.390 --> 00:07:16.470
depending on the message size.

00:07:16.600 --> 00:07:20.590
So the best use for pipes and
sockets that you're going to see is

00:07:20.590 --> 00:07:22.430
reading output from a forked command.

00:07:22.770 --> 00:07:26.520
When you call fork in your application,
the child process inherits

00:07:26.560 --> 00:07:27.900
your file descriptors.

00:07:28.030 --> 00:07:30.710
So the child process
can then start reading,

00:07:30.710 --> 00:07:34.090
and you can just write bytes,
and the child process reads and

00:07:34.320 --> 00:07:36.100
communicates back and forth that way.

00:07:36.160 --> 00:07:39.670
That's typically how
you're going to see --

00:07:39.800 --> 00:07:49.900
[Transcript missing]

00:07:50.870 --> 00:07:54.590
So shared memory is, you know,
can be a great way of sharing

00:07:54.590 --> 00:07:57.430
memory between applications.

00:07:57.460 --> 00:08:00.080
But the problem here is that
typically you're going to have one

00:08:00.140 --> 00:08:03.310
person performing updates to that
memory and other people reading it.

00:08:03.310 --> 00:08:06.130
When one of the other people
reads from that memory,

00:08:06.130 --> 00:08:09.510
the most it can be guaranteed
it read atomically is 32 bits.

00:08:09.880 --> 00:08:13.510
So if application A has performed
some operation and built a

00:08:13.510 --> 00:08:17.780
certificate or something that it
wants to share among applications,

00:08:17.780 --> 00:08:22.260
it has to somehow flag that to another
application that all that memory can

00:08:22.340 --> 00:08:26.470
be read and that the other application
was able to read all that memory

00:08:26.480 --> 00:08:28.900
without it changing underneath.

00:08:28.900 --> 00:08:33.030
So that's why I say it requires some
sort of external synchronization.

00:08:33.030 --> 00:08:37.080
That could either be a checksum on
the memory that was read or perhaps

00:08:37.080 --> 00:08:40.750
using a file descriptor just saying,
okay, the data is available.

00:08:40.820 --> 00:08:42.210
Tell me when you're done reading it.

00:08:42.380 --> 00:08:44.450
Then I can unlock this
memory and keep going.

00:08:44.460 --> 00:08:50.100
So the best use for shared memory, then,
is going to be to share work that you've

00:08:50.100 --> 00:08:53.220
done among several other applications.

00:08:55.650 --> 00:08:58.540
So there's a new Unix
API in Mac OS Tim Panther.

00:08:58.650 --> 00:09:00.260
This is the Notify API.

00:09:00.260 --> 00:09:04.450
And what it allows you to do is
to subscribe for notifications

00:09:04.450 --> 00:09:06.380
that something happened.

00:09:06.380 --> 00:09:09.320
Now,
what that something is is entirely up to

00:09:09.320 --> 00:09:12.170
the notification that's being defined.

00:09:12.170 --> 00:09:15.810
The notification has no
payload associated with it.

00:09:15.880 --> 00:09:18.140
It's just an indication
that something happened.

00:09:19.200 --> 00:09:23.870
Because of this, or regardless of this,
notifications can be coalesced.

00:09:23.870 --> 00:09:27.440
If 10 things happen,
you may only hear about one of them

00:09:27.440 --> 00:09:31.340
because all these notifications
will be coalesced into one event

00:09:31.410 --> 00:09:33.740
delivered to your application.

00:09:33.760 --> 00:09:36.840
Your application subscribes
to notifications.

00:09:36.840 --> 00:09:40.610
It can either pull for them,
or it can listen on a file descriptor

00:09:40.640 --> 00:09:43.030
or receive them via a Mach message.

00:09:43.040 --> 00:09:46.240
And one way to think about this,
it's a better signal.

00:09:46.240 --> 00:09:48.840
Signal is traditionally how
you tell a Unix project.

00:09:48.840 --> 00:09:54.680
You can either go away, you're dead now,
or reread your preferences file.

00:09:54.700 --> 00:09:57.520
That would be SIG HUP a lot of times.

00:09:57.520 --> 00:10:01.380
The problem with signal is you have
no control over when your process

00:10:01.380 --> 00:10:03.240
is going to receive a signal.

00:10:03.240 --> 00:10:05.730
So when people in the
past have used signal,

00:10:05.730 --> 00:10:09.330
they might want to say, oh, well,
you know, I got my signal.

00:10:09.330 --> 00:10:11.860
I'm going to use some application API.

00:10:11.860 --> 00:10:13.170
You can't really do that.

00:10:13.170 --> 00:10:15.110
It's like interrupt time at Mac OS 9.

00:10:15.110 --> 00:10:17.630
You don't know the state
of all the frameworks.

00:10:17.660 --> 00:10:19.100
So notify.

00:10:19.200 --> 00:10:23.730
That would be a better way to architect
your processes so that you have some

00:10:23.730 --> 00:10:28.550
control over where events come in,
these specific one-off notifications.

00:10:28.560 --> 00:10:30.980
So here's a code sample.

00:10:30.980 --> 00:10:32.160
Okay, it's good and readable.

00:10:32.160 --> 00:10:37.440
This is how the client is going to
register to receive notifications.

00:10:37.440 --> 00:10:40.760
There's a new call,
notify register file descriptor.

00:10:40.760 --> 00:10:44.580
And you give it the name of the
notification you want to subscribe to.

00:10:44.580 --> 00:10:47.190
In this case,
it's handing back a file descriptor

00:10:47.190 --> 00:10:49.140
that I'm going to block and read.

00:10:49.200 --> 00:10:52.190
I already said you don't want to do that,
but this is a sample.

00:10:52.200 --> 00:10:55.220
It also hands back a token that
represents that notification

00:10:55.220 --> 00:10:56.800
so that we can delete it later.

00:10:56.880 --> 00:11:00.720
Then I'm just going to read from this,
and my read is going to block

00:11:00.950 --> 00:11:04.590
until the notification actually
is sent by another process.

00:11:04.840 --> 00:11:07.780
Notifications.

00:11:08.900 --> 00:11:10.980
How do I want to say this?

00:11:11.030 --> 00:11:14.300
Later on, we're going to see that there
are different partition spaces

00:11:14.300 --> 00:11:16.140
for applications to run in.

00:11:16.160 --> 00:11:19.200
Notifications are global
across all of those.

00:11:19.520 --> 00:11:22.900
So the server, which is typically running
in another process,

00:11:23.040 --> 00:11:24.820
just says, notify post.

00:11:24.870 --> 00:11:27.630
Anybody who subscribed to
that notification using

00:11:27.630 --> 00:11:33.600
any of file descriptor,
Mach, port delivery,

00:11:33.800 --> 00:11:48.600
[Transcript missing]

00:11:49.700 --> 00:11:52.480
Back to the architecture diagram.

00:11:52.480 --> 00:11:57.720
The next thing I want to talk
about is Mach Messaging itself.

00:11:59.080 --> 00:12:01.380
It would be the subject of a
much longer talk to discuss

00:12:01.440 --> 00:12:03.060
everything about Mach Messaging.

00:12:03.190 --> 00:12:07.720
So what I'd like to have happen is for
us to understand some of the terms that

00:12:07.720 --> 00:12:12.500
we use when we talk about Mach Messaging
so that when you run into it,

00:12:12.560 --> 00:12:17.460
you're not startled or you're able to
work with code that uses Mach Messaging.

00:12:18.840 --> 00:12:21.800
So the first thing is that Mach Messaging
allows you to implement servers.

00:12:21.800 --> 00:12:24.000
Servers exist all over the system.

00:12:24.000 --> 00:12:26.630
The Windows server,
it's even got server in the name,

00:12:26.730 --> 00:12:30.710
is responsible for handling user events
and sending them to your application.

00:12:31.470 --> 00:12:35.130
In effect, your application is a server
because it receives events and

00:12:35.140 --> 00:12:37.210
performs some action based on them.

00:12:38.140 --> 00:12:42.250
So servers exist in your process,
in other processes, and in the kernel.

00:12:42.260 --> 00:12:45.660
The kernel provides some
servers for doing things

00:12:45.660 --> 00:12:47.820
like getting the time of day.

00:12:47.820 --> 00:12:50.390
for example, could be a server.

00:12:51.400 --> 00:12:54.300
When you send a Mach Message,
these are some of the terms

00:12:54.300 --> 00:12:58.030
that you need to know,
need to understand what it is that

00:12:58.030 --> 00:13:00.460
you're sending into the kernel.

00:13:00.460 --> 00:13:03.750
Mach Message itself is the
name of the kernel trap.

00:13:03.780 --> 00:13:08.040
This is the subroutine, it looks like,
to an application developer that

00:13:08.180 --> 00:13:11.680
you call to send a message and
actually to receive a reply.

00:13:11.680 --> 00:13:12.950
It's the same trap.

00:13:13.680 --> 00:13:18.020
Mach Message Header T is the
name of a structure that contains

00:13:18.050 --> 00:13:20.440
the actual Mach Message data.

00:13:20.440 --> 00:13:23.010
It's a variable length structure.

00:13:23.030 --> 00:13:27.530
It's got a header that sort of
defines the size of the structure,

00:13:27.530 --> 00:13:31.790
and then they're going to be
in the variable length part.

00:13:31.810 --> 00:13:35.920
There's what are called
descriptors for out-of-band

00:13:35.920 --> 00:13:38.590
memory regions and Mach ports.

00:13:38.680 --> 00:13:42.960
So Mach ports, you're going to see
these all over the place.

00:13:43.680 --> 00:13:46.360
And when you get down to it,
it seems like everything is a Mach port.

00:13:46.360 --> 00:13:48.380
Tasks seem to be a Mach port.

00:13:48.380 --> 00:13:50.360
Threads seem to be a Mach port.

00:13:50.360 --> 00:13:54.260
So when you send a Mach Message,
you send it to a Mach port.

00:13:54.340 --> 00:13:57.280
Ports have writes associated with them.

00:13:57.280 --> 00:13:59.270
You can have a receive write on a port.

00:13:59.530 --> 00:14:02.620
That means you're
allowed to receive data.

00:14:02.620 --> 00:14:05.970
Somebody else has a
send write on that port.

00:14:06.220 --> 00:14:07.420
That person can send data.

00:14:07.420 --> 00:14:08.460
You can receive it.

00:14:08.520 --> 00:14:12.900
There's also a send once write,
and this is used when you send somebody.

00:14:13.680 --> 00:14:15.120
An event, and you want a reply back.

00:14:15.160 --> 00:14:18.270
You can send them a send
once write on a port.

00:14:18.270 --> 00:14:22.310
They're allowed to send you exactly
one message back on that port.

00:14:22.320 --> 00:14:25.070
You receive it,
and you deal with the reply.

00:14:25.080 --> 00:14:27.570
This is kind of a security thing.

00:14:27.600 --> 00:14:30.720
You don't want people just sort of
blasting messages out to ports that

00:14:30.730 --> 00:14:32.880
they don't have rights to do so on.

00:14:34.450 --> 00:14:38.150
There's also something called a port set,
which is itself, it looks like a port.

00:14:38.150 --> 00:14:45.120
A port set is effectively
the same as a select call.

00:14:45.130 --> 00:14:50.160
Actually, it's an FD set,
which is the parameter to a select call.

00:14:50.160 --> 00:14:53.120
You can select multiple
ports into a port set,

00:14:53.120 --> 00:14:57.000
and then with one Mach Message call,
monitor all those ports

00:14:57.000 --> 00:14:58.720
for an event to come in.

00:14:58.740 --> 00:15:04.760
What's interesting about that is the run
loop in CF run loop does that for you.

00:15:04.780 --> 00:15:08.440
So if you use the core foundation
wrappers on top of Mach Ports,

00:15:08.500 --> 00:15:11.510
you'll get the behavior of
an entire selection of ports

00:15:11.750 --> 00:15:15.220
being received upon at once,
and that's a really good thing

00:15:15.300 --> 00:15:19.730
because you don't have to have 10
people blocked in Mach Message.

00:15:21.150 --> 00:15:25.200
Out-of-band memory is a
really important concept,

00:15:25.200 --> 00:15:30.730
and it basically lets you send a message
to somebody else sharing your memory.

00:15:30.750 --> 00:15:35.170
But when the receiver gets the memory,
he doesn't strictly own it.

00:15:35.170 --> 00:15:38.280
He's allowed to read from it,
if you give him that option,

00:15:38.280 --> 00:15:39.940
and he's allowed to touch it.

00:15:40.060 --> 00:15:42.360
But if he touches it,
he's going to get a copy of the memory.

00:15:42.680 --> 00:15:45.790
Now, a lot of subsystems are
built on top of this,

00:15:45.860 --> 00:15:49.260
because typically when you
message data to someone,

00:15:49.260 --> 00:15:53.430
they're going to read from the data,
but they're not necessarily

00:15:53.430 --> 00:15:55.000
going to write to it.

00:15:56.640 --> 00:16:00.460
So that's an out-of-band
memory descriptor.

00:16:00.780 --> 00:16:04.880
It provides virtual copies of
memory between applications.

00:16:05.110 --> 00:16:08.370
You're given the option of marking
it read-only or copy-on-write when

00:16:08.370 --> 00:16:09.820
it gets messaged to the other side.

00:16:09.840 --> 00:16:15.520
One thing to note is that the memory
that you send should be page-aligned.

00:16:15.520 --> 00:16:21.090
The reason for this is that if you
message memory that's not page-aligned,

00:16:21.100 --> 00:16:24.860
then the kernel is going to
copy the first and last page,

00:16:24.860 --> 00:16:28.110
make new pages for those,
and zero out the stuff that

00:16:28.110 --> 00:16:30.070
isn't actually explicitly sent.

00:16:30.080 --> 00:16:33.820
So ideally, you're going to send multiple
pages of page-aligned data.

00:16:33.820 --> 00:16:34.820
That's not always possible.

00:16:35.000 --> 00:16:37.320
And sometimes you'll wind up
with pages copied on either side.

00:16:37.320 --> 00:16:38.810
This is a process called box-carring.

00:16:38.820 --> 00:16:42.280
You don't want, you know,
if the block beforehand

00:16:42.280 --> 00:16:44.860
is a pointer that's got,
you know, the user's password,

00:16:44.860 --> 00:16:46.800
you don't want that going
to another application.

00:16:48.280 --> 00:16:51.810
So by aligning the memory,
you'll get much better

00:16:51.810 --> 00:16:54.150
performance through Mach Message.

00:16:54.930 --> 00:16:56.960
You need to plan for memory management.

00:16:57.050 --> 00:17:00.600
When you receive a Mach message
that has out-of-band memory in it,

00:17:00.650 --> 00:17:02.980
you need to deallocate that memory.

00:17:02.980 --> 00:17:05.980
You own that memory,
or you think that you own it,

00:17:05.980 --> 00:17:09.620
but the kernel will take care
of copying it if necessary.

00:17:09.620 --> 00:17:12.770
But you need to deallocate it,
otherwise it will just leak

00:17:12.770 --> 00:17:14.490
and consume vast resources.

00:17:16.080 --> 00:17:18.650
So VM deallocate is the
call you use to do that.

00:17:18.770 --> 00:17:20.960
Whatever the address
is that came into you,

00:17:21.150 --> 00:17:23.550
use VM deallocate to deallocate it later.

00:17:23.550 --> 00:17:25.700
You don't have to do that right away.

00:17:25.700 --> 00:17:28.710
You can hang on to that memory
for as long as you want.

00:17:28.710 --> 00:17:32.550
Just be aware that you own it and
you still need to get rid of it.

00:17:33.030 --> 00:17:39.080
Okay, so a Mach Message structure,
here's gonna be an example Mach Message.

00:17:39.130 --> 00:17:43.120
Basically, it's a green box with,
at the very top,

00:17:43.150 --> 00:17:44.680
there's a Mach Message header T.

00:17:44.830 --> 00:17:46.900
This is where you specify the message ID.

00:17:47.050 --> 00:17:50.630
This is how the receiver of the
message is going to demultiplex the

00:17:50.630 --> 00:17:52.970
message and decide what to do with it.

00:17:53.220 --> 00:17:58.090
The size of the whole green
box and the reply port,

00:17:58.170 --> 00:18:05.380
the port that is going to get sent back
from the server that responds to this.

00:18:05.610 --> 00:18:08.620
Then this is all variable
length data after it.

00:18:08.810 --> 00:18:12.680
But the first thing after the header
has got to be the descriptor count,

00:18:12.680 --> 00:18:14.050
which could be zero.

00:18:14.060 --> 00:18:18.700
The descriptor count in this
case is going to be two.

00:18:18.700 --> 00:18:22.300
We're going to have two descriptors
following the Mach Message header T.

00:18:22.300 --> 00:18:24.630
The first descriptor,
we're going to send an

00:18:24.630 --> 00:18:26.320
out-of-line memory region.

00:18:29.460 --> 00:18:31.940
These descriptors are
fixed length structures.

00:18:31.940 --> 00:18:35.540
You fill in attributes of them and just
append them to the end of the message.

00:18:35.540 --> 00:18:40.590
For an out-of-line memory region,
it's just the address and the size.

00:18:40.600 --> 00:18:43.690
While it would be nice if the
address were page-aligned,

00:18:43.690 --> 00:18:47.370
if it's not, the Mach Message trap will
take care of that for you.

00:18:47.380 --> 00:18:52.050
There's also the attributes in
that memory descriptor about

00:18:52.050 --> 00:18:56.510
how to deal with the memory,
whether or not the memory should

00:18:56.510 --> 00:18:58.960
be copy-on-write or read-only.

00:18:59.460 --> 00:19:02.330
the server process.

00:19:02.680 --> 00:19:05.560
Then in this example,
I'm also going to send a Mach port.

00:19:05.560 --> 00:19:09.920
This might be the case where
I'm telling the server,

00:19:10.040 --> 00:19:11.760
"Here's some data.

00:19:12.030 --> 00:19:17.110
Process this out-of-line data,
and when you're done doing that work,

00:19:17.220 --> 00:19:22.050
you can contact me on this Mach port
that the work is complete."

00:19:23.200 --> 00:19:25.760
After that,
you can have whatever data you want.

00:19:25.850 --> 00:19:29.310
So what you're going to see a lot
of times is that a Mach message

00:19:29.310 --> 00:19:33.690
typically will have zero descriptors,
and it will have a whole bunch of

00:19:33.690 --> 00:19:35.860
just data sitting after the header.

00:19:35.860 --> 00:19:38.550
And that's really the
body of the message.

00:19:39.300 --> 00:19:43.240
Core foundation in the
CFMochPort de-muxing routines,

00:19:43.240 --> 00:19:48.900
it allocates a certain amount of space
on the stack to receive a Mach message.

00:19:48.900 --> 00:19:53.520
But if the message is too big,
it allocates a larger buffer

00:19:53.520 --> 00:19:56.310
and then does the work again.

00:19:56.960 --> 00:20:00.740
So, ideally,
you want to keep your message size small.

00:20:00.790 --> 00:20:03.950
It's kind of an implementation
detail of CFMochPort.

00:20:03.950 --> 00:20:06.950
But it's interesting that if the
message that you're receiving is

00:20:06.950 --> 00:20:10.880
too big for the buffer you supplied,
you get a chance to allocate a larger

00:20:10.880 --> 00:20:13.400
buffer and receive the message again.

00:20:13.400 --> 00:20:14.960
Obviously, that's less efficient.

00:20:14.960 --> 00:20:18.620
So you want to make sure if you're
receiving the event yourself

00:20:18.760 --> 00:20:21.110
that it is the minimum size,
or sorry,

00:20:21.110 --> 00:20:25.530
the maximum size of all the messages
that you're likely to receive.

00:20:26.330 --> 00:20:30.340
So how do you find somebody to
talk to with a Mach Message?

00:20:30.400 --> 00:20:33.160
This is probably one of the
most important things now

00:20:33.260 --> 00:20:36.310
because of fast user switching.

00:20:36.490 --> 00:20:40.440
You have to discover Mach services,
and you do this through a mechanism

00:20:40.490 --> 00:20:42.320
called the Bootstrap Server.

00:20:42.320 --> 00:20:47.290
This associates a symbolic
name with a server.

00:20:47.400 --> 00:20:49.500
There are several Bootstrap
Servers on the system.

00:20:49.500 --> 00:20:53.290
When the system is starting up,
there's the primordial Bootstrap Server.

00:20:53.410 --> 00:20:59.450
This is where demons live,
where we call them startup

00:20:59.670 --> 00:21:01.290
items in our new lingua.

00:21:02.630 --> 00:21:08.010
When a server that is running in a
startup item starts up or it registers

00:21:08.010 --> 00:21:12.990
itself with a bootstrap server,
it is then visible to other bootstrap

00:21:13.040 --> 00:21:15.350
servers that get created after the fact.

00:21:15.420 --> 00:21:18.960
So if you're running within
an application context,

00:21:19.020 --> 00:21:22.100
you're a Netscape
plug-in inside of Safari,

00:21:22.100 --> 00:21:25.230
you're allowed to see
services vended by daemons.

00:21:25.260 --> 00:21:28.360
Let me go on to the next slide.

00:21:28.380 --> 00:21:30.280
This will show it a little better.

00:21:30.520 --> 00:21:32.580
Daemons live in this
little world out here.

00:21:32.580 --> 00:21:35.460
User A applications and
User B applications are allowed

00:21:35.540 --> 00:21:37.220
to see into the daemon world.

00:21:37.220 --> 00:21:41.410
Daemons can't see into,
they cannot look up services

00:21:41.800 --> 00:21:47.260
that are vended by processes
within the user's bootstrap ports,

00:21:47.320 --> 00:21:50.180
within these bootstrap ports
that were created for the user.

00:21:50.180 --> 00:21:55.710
This is why you cannot send an
Apple event in Jaguar from a daemon

00:21:55.710 --> 00:21:59.880
or an Apache module to iTunes,
for example.

00:22:00.520 --> 00:22:02.560
Um,

00:22:02.730 --> 00:22:03.860
This is done for security reasons.

00:22:03.940 --> 00:22:08.200
We don't want just arbitrary code running
in the bootstrap server world to be able

00:22:08.310 --> 00:22:11.400
to manipulate user land applications.

00:22:12.980 --> 00:22:16.000
So, how do you write a Mach Message?

00:22:16.000 --> 00:22:19.800
How do you decide what the structure
of a Mach Message is going to be?

00:22:19.800 --> 00:22:22.090
You can do it by yourself.

00:22:22.090 --> 00:22:22.800
You can roll your own.

00:22:22.800 --> 00:22:24.800
That's a real pain.

00:22:24.880 --> 00:22:27.800
Or you can use MIG,
the Mach Interface Generator.

00:22:27.800 --> 00:22:30.800
This is an IDL for describing
the structure of a Mach Message.

00:22:30.800 --> 00:22:36.160
It handles marshaling parameters
of scalar types and descriptor

00:22:36.620 --> 00:22:39.870
types into a Mach Message,
sending it to a server,

00:22:39.870 --> 00:22:40.800
and processing the response.

00:22:40.800 --> 00:22:44.800
So, giving it back to you in a way that
fits in easily with your application.

00:22:44.800 --> 00:22:48.800
It associates a unique
ID with each message,

00:22:48.800 --> 00:22:54.040
and it provides a demuxing routine that
takes care of switching on that ID and

00:22:54.280 --> 00:22:56.800
calling your server implementation.

00:22:56.800 --> 00:22:59.930
So,
here's an example that you'll see a lot,

00:23:00.160 --> 00:23:02.800
which is a check-in on a service.

00:23:03.240 --> 00:23:07.940
Where this would be used is a
daemon that wants to provide a

00:23:07.940 --> 00:23:08.800
service for a user application.

00:23:08.800 --> 00:23:12.030
The user application will check
in with the daemon and say,

00:23:12.030 --> 00:23:12.780
"I'm here.

00:23:12.820 --> 00:23:16.800
I'm ready to do some work for you.

00:23:16.800 --> 00:23:20.800
Here's my name." That's in ID.

00:23:20.800 --> 00:23:24.720
In, obviously, is saying this is an input
parameter for the server.

00:23:24.920 --> 00:23:26.800
ID is just the variable name.

00:23:26.800 --> 00:23:29.800
And in this case,
the parameter is a C string.

00:23:29.800 --> 00:23:36.800
The server, then,
is going to provide a Mach port.

00:23:36.800 --> 00:23:36.800
In this case, let's see,
a Mach port that the user

00:23:36.800 --> 00:23:36.800
can use to send a message.

00:23:36.800 --> 00:23:37.860
that the

00:23:39.430 --> 00:23:42.960
client can then send
additional requests upon.

00:23:43.110 --> 00:23:46.550
So when requests come in on
this Mach port to the server,

00:23:46.710 --> 00:23:48.920
he's gonna be able to say, oh,
I know what port that is.

00:23:48.980 --> 00:23:52.560
I know what client checked in
and I handed that port out to.

00:23:52.650 --> 00:23:57.950
So I know like what state I had kept
for that application previously.

00:23:58.180 --> 00:24:00.680
What gets generated from
this is client glue.

00:24:00.920 --> 00:24:05.160
If you look in user include Mach,
you're going to see a bunch of defs

00:24:05.160 --> 00:24:10.060
files and also the generated header
files for those Mach services.

00:24:10.190 --> 00:24:11.480
And they basically look like this.

00:24:11.480 --> 00:24:13.380
It's just C glue code.

00:24:13.440 --> 00:24:15.350
The first parameter is the server port.

00:24:15.600 --> 00:24:20.340
This was discovered via Bootstrap lookup
or handed back from some other routine.

00:24:20.390 --> 00:24:22.140
Then just a char star ID.

00:24:22.270 --> 00:24:27.140
Meg will take care of putting that
into the body of a Mach message.

00:24:27.240 --> 00:24:29.980
And then as an out parameter,
the client port that the

00:24:29.980 --> 00:24:31.860
server is going to provide.

00:24:31.910 --> 00:24:36.160
It also generates this stub routine
for the server to implement.

00:24:36.210 --> 00:24:38.400
Now, if somebody hands you
a defs file and says,

00:24:38.460 --> 00:24:40.400
call my service,
you don't need the server glue.

00:24:40.450 --> 00:24:42.260
But if you're going to
implement the server,

00:24:42.300 --> 00:24:45.010
you have to basically provide
the body of this routine.

00:24:45.150 --> 00:24:49.870
And toward the end in the demo,
I'll show what that looks like.

00:24:50.970 --> 00:24:54.790
So how do you handle a Mach Message?

00:24:54.820 --> 00:24:57.790
You get the data,
you cast it to a Mach Message header T,

00:24:57.980 --> 00:25:01.390
and you switch on the message ID.

00:25:01.400 --> 00:25:02.890
But that's kind of a pain.

00:25:02.920 --> 00:25:05.240
So there are two utility routines
that you should know about.

00:25:05.240 --> 00:25:08.140
Mach Message Server and
Mach Message Server Once.

00:25:08.150 --> 00:25:11.750
Both of these take the Mach port that
you registered with the Bootstrap server

00:25:11.850 --> 00:25:13.980
and the DMUX routine that Meg generated.

00:25:13.980 --> 00:25:17.720
And in the first case,
Mach Message Server will

00:25:17.830 --> 00:25:20.560
sit there in a loop,
accepting messages,

00:25:20.560 --> 00:25:22.750
calling your DMUX routine,
sending the reply.

00:25:22.930 --> 00:25:25.500
Mach Message Server Once does that,
but just once.

00:25:25.560 --> 00:25:29.490
Sending replies is kind of difficult,
because you have to figure out

00:25:29.490 --> 00:25:34.820
first whether a reply is warranted,
and second, you have to deal with, well,

00:25:34.930 --> 00:25:38.060
the DMUX routine returned
a Mach Message header

00:25:38.060 --> 00:25:39.860
of an appropriate size.

00:25:39.870 --> 00:25:43.150
You have to worry about what
that size was and deal with

00:25:43.150 --> 00:25:45.590
errors that occur in sending it.

00:25:45.590 --> 00:25:49.930
What I would recommend is if you
need to send a reply directly,

00:25:49.930 --> 00:25:54.600
to go to the Darwin sources and grab the
source code to Mach Message Server and

00:25:54.790 --> 00:25:57.920
just sort of understand that,
copy and paste it into your

00:25:57.920 --> 00:26:00.620
stuff with appropriate license,
whatever.

00:26:00.670 --> 00:26:02.100
Anyway.

00:26:02.100 --> 00:26:05.340
Core Foundation has support for Mach.

00:26:05.450 --> 00:26:07.390
And it has this in a
couple of different ways,

00:26:07.520 --> 00:26:11.480
but the most important are CF Mach port,
which wraps around a port,

00:26:11.480 --> 00:26:16.120
optionally it creates it for you,
and it gives you a callback routine.

00:26:16.120 --> 00:26:21.300
So when you register a CF Mach port
run loop source with your run loop,

00:26:21.510 --> 00:26:24.110
and an event comes in,
it's going to call your

00:26:24.260 --> 00:26:28.180
callback routine and say,
hey, here's a Mach message.

00:26:28.280 --> 00:26:33.990
But like the previous slide alluded to,
it doesn't send the reply for you.

00:26:33.990 --> 00:26:37.040
In that case,
you're going to have to set up the

00:26:37.040 --> 00:26:39.000
reply structure yourself and send it.

00:26:39.000 --> 00:26:42.130
And again, going back to the
Mach Message Server routine to

00:26:42.600 --> 00:26:47.340
understand how to send that reply,
if you want to deal with Mach messages

00:26:47.340 --> 00:26:52.680
via CF Mach port generated by Meg,
that's probably the right way to do it.

00:26:52.710 --> 00:26:54.540
It gives you an invalidation mechanism.

00:26:54.540 --> 00:27:00.290
This is really important because say
somebody checks in with you and says,

00:27:00.290 --> 00:27:03.430
I'm going to -- I want
you to do some work.

00:27:03.520 --> 00:27:05.900
Call me back on this Mach port.

00:27:05.900 --> 00:27:08.760
And then that application
crashes or the user quits it.

00:27:08.760 --> 00:27:13.700
The invalidation mechanism lets you know
that the Mach port you're working with,

00:27:13.700 --> 00:27:14.770
you can't do anything with.

00:27:14.860 --> 00:27:16.350
It's now invalid.

00:27:16.350 --> 00:27:18.520
And if you're doing work on
behalf of that Mach port,

00:27:18.520 --> 00:27:21.290
you could stop now because nobody's
ever going to hear about it.

00:27:22.660 --> 00:27:26.750
CFMessagePort sits on top of CFMockPort,
and it sits on top of

00:27:26.910 --> 00:27:30.870
the Bootstrap server,
and it lets you create, basically,

00:27:30.870 --> 00:27:34.020
a Mach server that
accepts a blob of data.

00:27:34.040 --> 00:27:36.180
This is a really handy thing to do.

00:27:36.200 --> 00:27:39.610
If you just need to send data
between two applications,

00:27:39.610 --> 00:27:42.750
CFMessagePort is probably
the right way to do it.

00:27:42.860 --> 00:27:46.090
It has the restrictions of
the Bootstrap port world,

00:27:46.120 --> 00:27:46.810
though.

00:27:46.820 --> 00:27:52.180
So between sessions,
it's not going to work.

00:27:52.570 --> 00:27:52.940
It'll work.

00:27:53.040 --> 00:27:57.480
A daemon can advertise a server,
and clients inside the user

00:27:57.480 --> 00:27:59.380
application will be able to send to it.

00:27:59.460 --> 00:28:05.080
But userland applications,
or per-user applications, I should say,

00:28:05.080 --> 00:28:09.750
aren't going to be reachable from
other user sessions or from daemons.

00:28:09.800 --> 00:28:16.380
Now, what's the performance of all
these different lower-level APIs?

00:28:16.380 --> 00:28:19.030
Well, pipe is basically linear.

00:28:19.040 --> 00:28:24.570
These are the numbers that came out of
the... the test app I wrote that sent a

00:28:24.570 --> 00:28:27.610
5-meg blob to a process that was forked.

00:28:27.720 --> 00:28:33.190
MockMessage, on the other hand,
basically is completely flat.

00:28:33.200 --> 00:28:35.450
It was kind of independent
of the message size.

00:28:36.190 --> 00:28:41.060
Obviously, the memory was allocated all
beforehand and then sent along.

00:28:41.060 --> 00:28:44.530
So MockMessage seemed to be
just a great way to message

00:28:44.530 --> 00:28:47.010
arbitrarily large blobs of data.

00:28:47.020 --> 00:28:49.620
Turns out,
and I don't even know if that's visible,

00:28:49.620 --> 00:28:52.360
CFMessage is pretty
much just as efficient.

00:28:52.360 --> 00:28:56.860
It's doing the Mach port
hand-rolled MockMessage directly.

00:28:56.860 --> 00:29:01.600
That's why I would really recommend it,
especially if you don't need to

00:29:01.600 --> 00:29:04.100
do inter-session communication.

00:29:06.450 --> 00:29:11.400
Okay, so let's go up a layer,
talk about Apple Events.

00:29:11.460 --> 00:29:13.580
First, let's define what we
mean by Apple Events.

00:29:13.580 --> 00:29:16.810
It's kind of weird that
the word Apple Events means

00:29:16.810 --> 00:29:17.640
so many different things.

00:29:17.640 --> 00:29:20.120
It's like calling every product .NET.

00:29:20.430 --> 00:29:24.480
So Apple Events came around in '91,
I think,

00:29:24.480 --> 00:29:27.580
was the first time I heard about them.

00:29:27.690 --> 00:29:32.450
AppleEvents is the technology
and the name of the framework.

00:29:32.640 --> 00:29:35.800
It's also the name of a
type in the framework,

00:29:35.860 --> 00:29:37.450
an AppleEvent descriptor record.

00:29:37.450 --> 00:29:42.080
And it's also, you know, AppleEvents,
which is what we're all at today.

00:29:42.080 --> 00:29:43.180
This is an AppleEvent.

00:29:44.320 --> 00:29:46.420
It's under the application
services umbrella.

00:29:46.420 --> 00:29:49.880
What that means is it doesn't necessarily
need a process manager connection.

00:29:49.880 --> 00:29:54.350
And if you use AppleEvents and you're
linking against application services,

00:29:54.350 --> 00:29:57.550
you can get by without
doing any user interaction.

00:29:57.560 --> 00:30:00.930
User interaction is sort of
at the Carbon or Cocoa layer.

00:30:01.040 --> 00:30:04.160
But if you're linking
against application services,

00:30:04.210 --> 00:30:07.640
you can get by with writing a
daemon or writing a background

00:30:07.640 --> 00:30:09.760
process that uses AppleEvents.

00:30:11.370 --> 00:30:19.580
There is a lot of predefined
Apple Events that you can implement.

00:30:19.580 --> 00:30:30.140
Back in the old days, this was called the
required for Apple Events.

00:30:30.140 --> 00:30:30.140
Print, quit, save, something else.

00:30:30.750 --> 00:30:36.390
So there are a lot of
Apple Events that you could implement.

00:30:36.550 --> 00:30:40.380
The scripting sessions, which I guess the
AppleScript session was yesterday,

00:30:40.380 --> 00:30:43.300
would have been the place to sort
of understand how to implement

00:30:43.350 --> 00:30:46.490
scripting behaviors for your
application in terms of factoring

00:30:46.600 --> 00:30:48.600
your applications for scriptability.

00:30:48.640 --> 00:30:52.760
I would go back and review slides
from previous years' WWDC for that.

00:30:52.790 --> 00:30:59.620
A couple of things to
know about Apple Events.

00:30:59.600 --> 00:31:09.300
[Transcript missing]

00:31:10.630 --> 00:31:12.200
So when would you need
to use AppleEvents?

00:31:12.370 --> 00:31:14.140
Well, between applications.

00:31:14.160 --> 00:31:17.050
So there are a bunch of
applications on your platform,

00:31:17.170 --> 00:31:21.930
and some of them do certain things, like,
you know, flow text around an object or

00:31:21.930 --> 00:31:24.480
print with certain attributes.

00:31:24.480 --> 00:31:28.390
You can leverage those applications
because they accept AppleEvents that

00:31:28.390 --> 00:31:30.760
allow you to program that behavior.

00:31:30.760 --> 00:31:34.520
So between applications,
this is a great thing.

00:31:34.520 --> 00:31:36.640
So how do you discover
-- how do you discover

00:31:36.930 --> 00:31:39.440
An application that you can talk to.

00:31:39.440 --> 00:31:43.330
In Jaguar and previous,
it basically was bound

00:31:43.330 --> 00:31:44.600
to the process manager.

00:31:44.600 --> 00:31:47.480
Applications would check in
with the process manager,

00:31:47.480 --> 00:31:51.560
and the Apple event framework would
talk to the process manager to discover,

00:31:51.560 --> 00:31:53.840
okay, you know, here's MACS.

00:31:53.970 --> 00:31:57.930
You're trying to talk to an
application whose signature is MACS.

00:31:57.930 --> 00:31:59.420
Whoever that is, that's great.

00:31:59.420 --> 00:32:00.920
That happens to be the finder.

00:32:01.820 --> 00:32:03.910
You could also,
if you launched an application

00:32:03.910 --> 00:32:06.430
and you're giving back its
PID or process serial number,

00:32:06.430 --> 00:32:09.550
you could target an application
by PID and process serial number.

00:32:09.560 --> 00:32:16.400
In Panther, we've added a new Apple event
addressing type application bundle ID.

00:32:16.400 --> 00:32:18.640
This basically replaces signature.

00:32:18.640 --> 00:32:22.380
It's better to send to
com.apple.finder than to send to MACS,

00:32:22.380 --> 00:32:25.700
if you can get away with
targeting Panther directly.

00:32:26.840 --> 00:32:30.200
But in Jaguar,
you had to be a client of the process

00:32:30.330 --> 00:32:34.240
manager to discover applications,
and you couldn't send

00:32:34.270 --> 00:32:36.780
Apple events between sessions.

00:32:36.800 --> 00:32:41.170
Well, you still can't send, in Panther,
Apple events between sessions.

00:32:41.170 --> 00:32:42.860
We don't really allow that.

00:32:42.900 --> 00:32:45.780
But we enforce a UID-based restriction.

00:32:45.780 --> 00:32:49.340
Between user sessions,
applications owned by user A can

00:32:49.340 --> 00:32:51.860
send to applications owned by user B.

00:32:51.860 --> 00:32:52.280
Sorry.

00:32:52.280 --> 00:32:55.840
Applications owned by user A can only
send to applications owned by user A.

00:32:55.840 --> 00:32:56.780
Applications.

00:32:56.840 --> 00:32:58.460
In B are restricted to sending to B.

00:32:58.520 --> 00:33:01.310
The exception to this is that
applications owned by root,

00:33:01.390 --> 00:33:05.100
and this includes daemons running
in the startup item space,

00:33:05.100 --> 00:33:08.460
are allowed to send to any other
application on the system that's

00:33:08.460 --> 00:33:09.590
registered for Apple events.

00:33:09.600 --> 00:33:13.170
This is a very commonly requested
feature for people that are

00:33:13.170 --> 00:33:15.210
trying to write Apache plugins.

00:33:15.220 --> 00:33:17.610
They wanted to be able
to script applications,

00:33:17.610 --> 00:33:20.670
and now they'll be able to.

00:33:21.010 --> 00:33:24.680
So Apple Events are well supported,
very well supported,

00:33:24.780 --> 00:33:28.590
by both the Carbon and Cocoa frameworks
and by third party frameworks that

00:33:28.650 --> 00:33:31.070
are built on top of Carbon and Cocoa.

00:33:31.200 --> 00:33:36.600
Events are received on the run loop and
dispatched to handlers that you have

00:33:36.710 --> 00:33:39.670
registered within your application space.

00:33:39.900 --> 00:33:43.000
Events that you send are
usually sent synchronously.

00:33:43.000 --> 00:33:46.290
You send, and then you block for a reply.

00:33:46.430 --> 00:33:49.160
That's sort of the older model.

00:33:49.410 --> 00:33:52.680
There is a preferred way to do that,
which is to wait for a queued reply.

00:33:52.800 --> 00:33:55.040
You send the event waiting
for a queued reply,

00:33:55.120 --> 00:33:58.400
go off and do other things,
maybe update your UI, put up a sheet,

00:33:58.400 --> 00:34:01.500
let other windows in
your application work.

00:34:01.740 --> 00:34:04.360
And then when the reply
comes in from the server,

00:34:04.410 --> 00:34:08.360
it's delivered to you as just another
event that you then associate with

00:34:08.450 --> 00:34:10.900
the original event that you sent.

00:34:30.450 --> 00:34:30.810
On the server side,
when you receive an event,

00:34:30.810 --> 00:34:30.810
you can suspend it and then resume it
at a later time after you've done the

00:34:30.810 --> 00:34:30.810
work that the event originally requested.

00:34:30.810 --> 00:34:30.810
Thinking about suspension and
resumption is that these live in

00:34:30.810 --> 00:34:30.810
the Carbon framework layer and
may necessitate user interface.

00:34:31.010 --> 00:34:34.800
It's kind of a better model
if you can just deal with the

00:34:34.800 --> 00:34:39.710
event right away or set up the
communications so that the original

00:34:39.780 --> 00:34:43.280
event that came in had information
about how to send a reply later,

00:34:43.290 --> 00:34:46.200
had some state with it that said, "Okay,
when you're done with the work,

00:34:46.350 --> 00:34:50.530
send me an event back." Sort of
manage that asynchronous

00:34:50.530 --> 00:34:53.290
reply mechanism yourself.

00:34:53.610 --> 00:34:56.700
So scripting is not something that
comes for free in the Carbon Frameworks.

00:34:56.870 --> 00:35:00.060
You need to implement an AETE resource.

00:35:00.230 --> 00:35:05.000
This describes the classes,
the properties, or IVARs of the class,

00:35:05.020 --> 00:35:09.940
if you will, and verbs that allow you
to operate on the class.

00:35:11.340 --> 00:35:14.020
It lives in this resource,
and then the scripting implementations

00:35:14.170 --> 00:35:17.680
get the resource and are able to present
UI to the user to allow the user to pull

00:35:17.700 --> 00:35:21.570
out the things that they care about and
plug them together in interesting ways.

00:35:21.620 --> 00:35:25.070
Cocoa, on the other hand,
because the application framework

00:35:25.070 --> 00:35:28.440
has so much metadata available and so
much ability to introspect upon the

00:35:28.440 --> 00:35:32.220
framework and the application running,
allows you to use a textual description

00:35:32.280 --> 00:35:33.960
of what your application can do.

00:35:33.960 --> 00:35:37.540
That's a script suite file,
and it will actually generate the

00:35:37.540 --> 00:35:39.550
AET resource for you on the fly.

00:35:40.800 --> 00:35:43.500
This is, again,
something that we talk about at length,

00:35:43.540 --> 00:35:46.530
and probably going back over
previous years' WWDC slides,

00:35:46.550 --> 00:35:49.260
it's better to understand how
to implement the scripting.

00:35:50.650 --> 00:35:52.880
Okay, so what does an Apple event
actually look like?

00:35:52.930 --> 00:35:54.840
It's a structure.

00:35:54.840 --> 00:35:56.040
It's an 8-byte structure.

00:35:56.040 --> 00:36:02.590
It's got a 4-byte data type,
which is a 4-character code,

00:36:02.590 --> 00:36:04.060
and then a data handle.

00:36:04.060 --> 00:36:06.740
In classic Mac OS 9 land,
that was a real handle,

00:36:06.740 --> 00:36:10.270
and if somebody sent you data,
you were expected to dereference it,

00:36:10.410 --> 00:36:13.650
cast it to whatever you wanted,
and then just work with it.

00:36:14.710 --> 00:36:17.100
But when we did the
Carbon implementation,

00:36:17.100 --> 00:36:20.820
we took the opportunity to say,
it's an opaque data handle.

00:36:20.820 --> 00:36:24.100
Unfortunately, we didn't really enforce
that restriction,

00:36:24.100 --> 00:36:27.980
and so a lot of people ported their apps
to Carbon and kept looking in the handle.

00:36:27.980 --> 00:36:30.900
So when we changed that for Jaguar,
because we always said we

00:36:30.900 --> 00:36:33.900
were going to change it,
a lot of apps broke, so we have sort of a

00:36:33.900 --> 00:36:36.350
hacky workaround in place,
but it's not perfect,

00:36:36.350 --> 00:36:40.080
and you're much better off using
accessories to get into the data.

00:36:40.080 --> 00:36:43.600
Speaking of which,
there are two new APIs in Jaguar.

00:36:44.500 --> 00:36:50.400
There's an API called AECreateDesk from
External Pointer and AECetDeskDataRange.

00:36:50.400 --> 00:36:53.660
The first of these lets you say, okay,
here's an arbitrarily large

00:36:53.660 --> 00:36:56.860
blob of memory that I'd like
to send to another application,

00:36:56.860 --> 00:37:00.390
but I don't want to copy it
into the Apple Event Manager.

00:37:00.440 --> 00:37:03.740
I promise not to modify it anytime soon.

00:37:03.740 --> 00:37:06.340
It's an image or something that I got,
and I want to send it to

00:37:06.340 --> 00:37:07.730
some other application.

00:37:07.740 --> 00:37:11.010
Using AECreateDesk from External Pointer,
the Apple Event Manager will

00:37:11.010 --> 00:37:14.270
tell you when it's done with it,
when you dispose of the descriptor.

00:37:14.500 --> 00:37:16.820
It will decrement a
reference count and say,

00:37:16.820 --> 00:37:18.540
okay, that descriptor is done.

00:37:18.540 --> 00:37:19.360
You can free it now.

00:37:19.360 --> 00:37:22.840
That will actually avoid copying the
memory into the Apple Event Manager,

00:37:22.840 --> 00:37:25.700
and because the Apple Event Manager is
built on Mach messages,

00:37:25.700 --> 00:37:28.440
it'll avoid copying all
that data into the receiving

00:37:28.440 --> 00:37:30.260
application's address space.

00:37:30.260 --> 00:37:33.760
So that's a really good way to improve
performance for large messages.

00:37:33.760 --> 00:37:37.970
AECetDeskDataRange does
basically what that says.

00:37:38.000 --> 00:37:41.150
In the past,
you could look at the data handle and

00:37:41.150 --> 00:37:43.940
offset some offset and pull out a field.

00:37:44.500 --> 00:37:47.550
If you pulled out of a structure,
AECetDeskDataRange lets you do

00:37:47.550 --> 00:37:50.260
that without having to copy the
whole buffer to a local buffer.

00:37:52.260 --> 00:37:57.190
So that's sort of the
data type in Apple Events.

00:37:57.200 --> 00:38:01.800
There are also lists and records,
which are lists of those data types,

00:38:01.800 --> 00:38:05.090
or basically dictionaries,
where the key to the dictionary

00:38:05.130 --> 00:38:06.400
is another four-byte code.

00:38:06.420 --> 00:38:10.820
A lot of the existing Apple Events that
you can send and receive have

00:38:11.240 --> 00:38:13.440
well-established parameter orders.

00:38:14.840 --> 00:38:21.030
So the open Apple Event, for example,
has a list of aliases that

00:38:21.030 --> 00:38:23.240
you're supposed to open.

00:38:24.870 --> 00:38:26.160
It is opaque.

00:38:26.460 --> 00:38:26.840
Let's see.

00:38:26.840 --> 00:38:34.040
So an Apple event record then is
sort of two records slammed together,

00:38:34.040 --> 00:38:35.430
two AE records slammed together.

00:38:35.430 --> 00:38:37.440
One is the parameters for the event.

00:38:37.440 --> 00:38:40.280
That's what people typically
are going to deal with.

00:38:41.400 --> 00:38:43.920
And the other is the
attributes of the event,

00:38:43.920 --> 00:38:47.690
which is where the event came from,
what the event ID and class is.

00:38:47.700 --> 00:38:52.430
It's useful to think of it as sort of
two records slammed together instead

00:38:52.430 --> 00:38:54.890
of one sort of mysterious record.

00:38:54.900 --> 00:39:00.120
So when you message data to another,
when you perform a send,

00:39:00.120 --> 00:39:03.520
the data is copied into the other
application's address space.

00:39:03.520 --> 00:39:06.740
If it is optimizable,
then it's optimized to

00:39:06.740 --> 00:39:08.740
be a virtual memory copy.

00:39:08.740 --> 00:39:09.810
Okay.

00:39:11.180 --> 00:39:13.600
AppleEvents can be sent between machines.

00:39:13.600 --> 00:39:18.700
We do this in 10 using the type
application URL signature--

00:39:18.700 --> 00:39:25.300
application signature targeting
type thing-- targeted address type.

00:39:26.500 --> 00:39:29.860
So what that looks like,
and this is a horrible, ugly thing,

00:39:29.860 --> 00:39:33.440
but EPBC is the scheme
for remote Apple events.

00:39:33.690 --> 00:39:36.860
You can optionally add the
username and password directly

00:39:36.860 --> 00:39:38.500
to the outgoing message.

00:39:38.800 --> 00:39:41.500
Then the host,
which is a required parameter,

00:39:41.680 --> 00:39:45.490
and the app name,
which is a required parameter.

00:39:46.320 --> 00:39:49.080
And then now we've added for Panther,
optionally,

00:39:49.080 --> 00:39:50.770
the user ID and the process ID.

00:39:50.770 --> 00:39:53.340
If those are present,
those will be used in order

00:39:53.340 --> 00:39:56.900
to direct the Apple event that
comes in to a specific session.

00:39:57.700 --> 00:40:01.890
So in order to do multi-session support,
in order to target a specific session,

00:40:01.890 --> 00:40:03.490
you have to use the UID and PID.

00:40:03.630 --> 00:40:07.220
Otherwise, it goes to the, I guess,
the current console user.

00:40:07.610 --> 00:40:11.140
Panther also adds a new API,
AEList Remote Processes.

00:40:11.210 --> 00:40:15.330
This provides the data of what
processes are available on a given host.

00:40:15.560 --> 00:40:17.550
This was something we had
back in AppleTalk days.

00:40:18.120 --> 00:40:18.540
Sorry.

00:40:18.540 --> 00:40:24.920
This is something we had back in nine
days using remote Apple events over IP.

00:40:24.920 --> 00:40:28.620
You would specify the name of the
server that you want to connect to,

00:40:28.620 --> 00:40:31.740
and it would list the processes,
and then you could click

00:40:31.740 --> 00:40:33.330
on one and bring it back.

00:40:33.350 --> 00:40:35.160
This doesn't implement the UI behavior.

00:40:35.160 --> 00:40:36.620
This is just the data behavior.

00:40:36.620 --> 00:40:40.490
You'll have to implement the UI yourself,
but it should be trivial to do that.

00:40:40.540 --> 00:40:45.800
AD servers also advertise
themselves on Rendezvous.

00:40:45.800 --> 00:40:48.760
So, yes,
we're back to the AppleTalk days of being

00:40:48.760 --> 00:40:54.150
able to browse machines on your network
that have program linking turned on.

00:40:54.160 --> 00:41:00.170
So, if you need to do Rendezvous lookups,
you can use this eppc.tcp thing.

00:41:00.180 --> 00:41:01.250
All right.

00:41:01.680 --> 00:41:05.410
And it's actually pretty trivial to
use the Rendezvous APIs to discover,

00:41:05.410 --> 00:41:09.720
you know, okay, these servers have these
applications available.

00:41:10.290 --> 00:41:12.800
So, talk about the performance
of AppleEvents for a second.

00:41:12.800 --> 00:41:17.570
There's the CFMessage performance,
and the AppleEvent performance is,

00:41:17.650 --> 00:41:19.320
you know, it's good.

00:41:19.320 --> 00:41:24.100
It's right there because it's using
the same underlying mechanisms

00:41:24.100 --> 00:41:26.420
that the Mach layer provides.

00:41:26.460 --> 00:41:29.490
In comparison,
the AppleEvent performance in

00:41:29.490 --> 00:41:33.410
Puma was significantly worse
because it was copying the data

00:41:33.410 --> 00:41:35.960
between address spaces every time.

00:41:35.970 --> 00:41:38.180
It was basically linear
with message size.

00:41:38.180 --> 00:41:41.120
So,
the AppleEvent performance in Panther is

00:41:41.170 --> 00:41:46.200
actually 50% better than Jaguar as far
as number of messages it could send,

00:41:46.200 --> 00:41:49.940
and that doesn't really show
up in this chart at all.

00:41:50.240 --> 00:41:53.840
Okay, I'm gonna talk briefly about
Cocoa distributed objects,

00:41:54.030 --> 00:41:58.610
because this is another topic
for a much larger session.

00:41:59.030 --> 00:42:05.100
Cocoa distributed objects allow you
to implement a protocol that says,

00:42:05.400 --> 00:42:06.130
Here's an object.

00:42:06.130 --> 00:42:07.840
It has these behaviors.

00:42:07.880 --> 00:42:11.560
You can now look at it from
your process in another address

00:42:11.870 --> 00:42:14.660
space across the network,
make method calls upon

00:42:14.760 --> 00:42:18.740
it or send it messages,
and whatever parameters you pass to it,

00:42:18.790 --> 00:42:25.840
I will marshal those parameters into
a stream and send it over a wire.

00:42:26.180 --> 00:42:29.680
It allows you to provide
services for other applications,

00:42:29.730 --> 00:42:33.200
like the services menu uses
distributed objects in order to

00:42:33.320 --> 00:42:35.200
implement a lot of its behaviors.

00:42:35.300 --> 00:42:37.910
So what you get as a client
of distributed objects is

00:42:37.910 --> 00:42:41.780
an object that looks like an
object that you can work with,

00:42:41.910 --> 00:42:46.180
but method calls to it, messages to it,
actually go over a wire and

00:42:46.210 --> 00:42:51.250
talk to another process that
receives those messages,

00:42:51.310 --> 00:42:54.780
interprets them,
and performs an action on a local object.

00:42:54.970 --> 00:42:57.950
So between processes,
it's going to use Mach Messages

00:42:57.950 --> 00:42:59.660
typically to perform this.

00:42:59.740 --> 00:43:04.180
I guess there's also an
option to use pipes directly.

00:43:04.380 --> 00:43:07.230
Intermachine, it's going to use sockets,
TCP/IP,

00:43:07.300 --> 00:43:11.790
and it will automatically register your
object for discovery with Rendezvous.

00:43:12.100 --> 00:43:18.200
So some of the objects that
you'll see when we talk about

00:43:18.540 --> 00:43:19.400
Distributed objects.

00:43:19.500 --> 00:43:20.460
There's NSPort.

00:43:20.460 --> 00:43:25.060
This is the object that is
responsible for serializing a

00:43:25.060 --> 00:43:28.600
request given a particular transport.

00:43:28.600 --> 00:43:32.370
It's sort of created with the intention
of I'm going over a Mach message,

00:43:32.390 --> 00:43:34.720
so how should I serialize this request?

00:43:36.180 --> 00:43:39.500
There's Connection,
which allows you to discover objects.

00:43:39.500 --> 00:43:43.400
It's sort of how objects are published
from your server application.

00:43:43.400 --> 00:43:46.550
It says bound to run loop,
but actually the port is

00:43:46.590 --> 00:43:48.110
bound to the run loop.

00:43:48.190 --> 00:43:50.360
That's sort of the thing
that receives the message is

00:43:50.360 --> 00:43:51.840
actually bound to the run loop.

00:43:51.880 --> 00:43:55.650
And then there's the NSProxy protocol,
which has actually got two

00:43:55.650 --> 00:43:57.560
concrete implementations.

00:43:57.560 --> 00:44:01.660
In a client application,
you're going to look at

00:44:01.660 --> 00:44:04.360
the NSDistantObject object.

00:44:06.250 --> 00:44:09.450
It takes care of using the port and the
connection to serialize the request.

00:44:09.450 --> 00:44:12.520
On the server side,
it's called an NSProtocolChecker.

00:44:12.520 --> 00:44:16.640
That ensures that the message that
the server receives adheres to what

00:44:16.640 --> 00:44:19.200
the server really intends to publish.

00:44:21.050 --> 00:44:27.780
Now, this is sort of the flow of events
through distributed objects.

00:44:28.310 --> 00:44:30.160
And I guess it's pretty
much self-explanatory.

00:44:30.160 --> 00:44:33.690
Once an object is vended to a client,
he just makes method calls to it.

00:44:33.730 --> 00:44:40.420
It flows down that pipe across ports
between processes or machine boundaries,

00:44:40.450 --> 00:44:44.390
and then ultimately results
in the vended object.

00:44:44.630 --> 00:44:47.530
So to finish talking
about distributed objects,

00:44:47.530 --> 00:44:50.240
it allows you to vend an
Objective-C object for

00:44:50.330 --> 00:44:52.240
other applications to see.

00:44:52.240 --> 00:44:57.170
One thing to note is that
messages that are sent to

00:44:57.170 --> 00:44:59.560
Objective-C objects are synchronous.

00:44:59.560 --> 00:45:01.280
You block for a reply.

00:45:01.280 --> 00:45:04.730
If something goes wrong,
you could be blocked for a long time.

00:45:04.740 --> 00:45:06.800
So it's possible to set
a timeout on a reply,

00:45:06.910 --> 00:45:08.950
and that's probably a good thing to do.

00:45:08.960 --> 00:45:11.970
You set a timeout on the
connection object itself.

00:45:12.720 --> 00:45:17.280
And it's not as efficient as something
you could come up with yourself.

00:45:17.280 --> 00:45:20.100
If you need to send a particular
piece of data to another application,

00:45:20.100 --> 00:45:23.570
and you need a very
high-performance way of doing that,

00:45:23.600 --> 00:45:26.260
you could probably come up
with your own messaging scheme,

00:45:26.260 --> 00:45:29.830
leveraged on top of AppleEvents,
CFMessagePort, or MachPorts,

00:45:29.880 --> 00:45:33.340
that's going to be more efficient
than just using distributed objects.

00:45:33.440 --> 00:45:36.590
On the other hand,
there are a lot of existing distributed

00:45:36.590 --> 00:45:40.970
objects conversations taking place,
so it may make more sense

00:45:40.970 --> 00:45:42.270
to use one of those.

00:45:42.840 --> 00:45:50.630
It's a performance versus ability to
leverage what the framework provides.

00:45:50.680 --> 00:45:52.060
It's a decision you're
going to have to make.

00:45:52.120 --> 00:45:56.380
Distributed objects vended
inter-process have the same

00:45:56.510 --> 00:45:58.930
restrictions as AppleEvents.

00:45:59.020 --> 00:46:00.610
Well, yeah, let's see.

00:46:00.640 --> 00:46:03.340
It has the same restrictions
as CFMessagePort,

00:46:03.340 --> 00:46:06.540
in that they're isolated
within one session.

00:46:06.540 --> 00:46:09.520
Discoverability is isolated
to within one bootstrap space.

00:46:11.130 --> 00:46:14.000
Okay, so Web Services.

00:46:14.010 --> 00:46:17.200
In Puma,
we introduced Web Service Support in

00:46:17.200 --> 00:46:20.800
the Apple Event Manager,
of all places.

00:46:20.800 --> 00:46:26.460
And what this did was serialized
Apple Event records and container types

00:46:26.460 --> 00:46:28.640
into XML and send it along to a server.

00:46:28.640 --> 00:46:32.210
In Jaguar,
we moved this down a level and made it

00:46:32.310 --> 00:46:37.710
applicable to Objective-C data types
and core foundation data types for

00:46:37.720 --> 00:46:40.960
the scalar values and container types.

00:46:40.960 --> 00:46:46.580
It supports XMLRPC and SOAP and still
supports Apple Events and AppleScript by

00:46:46.580 --> 00:46:49.400
virtue of supporting Apple Events.

00:46:49.510 --> 00:46:53.000
So it's possible to write an
AppleScript application that talks

00:46:53.000 --> 00:46:58.620
to Web Services out on the Internet,
and it just reads like any message.

00:46:58.640 --> 00:47:00.350
It's not a message called
to any other application.

00:47:00.360 --> 00:47:04.650
You get back a dictionary with
some high-level constructs in it.

00:47:04.680 --> 00:47:07.450
You can look at the data as if it
were just an Apple Event record.

00:47:07.460 --> 00:47:10.440
In Panther,
we've added a message parsing API,

00:47:10.440 --> 00:47:13.150
so it's now possible to write
servers in Web Services.

00:47:15.810 --> 00:47:18.360
Okay, so how do you invoke a web service?

00:47:18.360 --> 00:47:23.980
The thing you want to look for is
called a WS Method Invocation Ref.

00:47:24.130 --> 00:47:27.810
This is the point that,
this is an object that handles

00:47:27.910 --> 00:47:30.810
serialization of outgoing requests.

00:47:30.810 --> 00:47:33.420
It's constructed with a schema and a URL.

00:47:33.420 --> 00:47:37.200
The schema specifies XMLRPC or so.

00:47:37.200 --> 00:47:40.450
The URL is, of course,
the endpoint that you're going

00:47:40.450 --> 00:47:42.320
to do the HTTP post to get to.

00:47:43.860 --> 00:47:45.750
You then set parameters on it.

00:47:45.750 --> 00:47:49.670
You have to tell it the dictionary,
which is the parameter list.

00:47:49.670 --> 00:47:51.070
It's prepositional.

00:47:51.070 --> 00:47:55.630
So you have to say parameter one,
value three, parameter two, value hello,

00:47:55.770 --> 00:47:59.610
and then the order that those
parameters should be serialized.

00:47:59.720 --> 00:48:04.620
The reason you have to do both is
because depending on the scheme you use,

00:48:04.620 --> 00:48:09.840
it may be necessary for the serializer
to emit things in a particular order.

00:48:10.080 --> 00:48:11.610
XMLRPC is positional.

00:48:12.020 --> 00:48:14.020
It doesn't care about the
name of the parameter.

00:48:14.020 --> 00:48:18.020
It cares about the positions,
whereas SOAP tends to be prepositional,

00:48:18.020 --> 00:48:22.020
where it cares about the name
but not necessarily the order.

00:48:22.330 --> 00:48:25.800
However, there are some SOAP servers that
also require that the order be as

00:48:25.930 --> 00:48:28.010
specified in the originating document.

00:48:28.010 --> 00:48:32.020
So adding the order parameter,
when you call set parameters,

00:48:32.020 --> 00:48:34.070
having the order is very important.

00:48:34.180 --> 00:48:36.180
So then you just invoke it.

00:48:36.180 --> 00:48:38.680
You can invoke it synchronously,
in which case you'll block until the

00:48:38.740 --> 00:48:40.180
reply comes back from the server.

00:48:40.180 --> 00:48:44.200
Or you can schedule it on your run loop,
and when the reply comes in,

00:48:44.200 --> 00:48:45.990
you're handed a dictionary.

00:48:46.400 --> 00:48:50.170
The dictionary contains
either the reply data,

00:48:50.180 --> 00:48:50.180
the result of this operation,
or it could contain a fault with

00:48:50.180 --> 00:48:50.180
information about what happened,
what went wrong with this request.

00:48:50.180 --> 00:48:58.650
So the reply from a web service
invocation is always a dictionary

00:48:58.710 --> 00:49:08.280
that you have to look into to extract
the actual reply that you expect.

00:49:08.340 --> 00:49:10.890
that you expect.

00:49:11.760 --> 00:49:12.920
Okay, so how to write a server.

00:49:12.920 --> 00:49:14.340
It's actually really simple.

00:49:14.340 --> 00:49:18.040
The server API isn't really a server.

00:49:18.040 --> 00:49:20.490
It does not listen on any sockets.

00:49:20.710 --> 00:49:27.780
All it does is it basically filters
a XML document into a CFDictionary,

00:49:27.780 --> 00:49:31.480
which you then implement the
sort of demuxing behavior,

00:49:31.480 --> 00:49:35.330
pull out the message name and
do something based on that.

00:49:35.580 --> 00:49:39.980
So the thing to look for in the
new API is WS Protocol Handler Ref.

00:49:39.980 --> 00:49:43.390
This is created with the
schema of XMLRPC or SOAP.

00:49:43.410 --> 00:49:47.660
You then call copy request
dictionary with this thing.

00:49:47.660 --> 00:49:51.940
You've given it a CFData XML document
that you received over the wire,

00:49:51.950 --> 00:49:54.450
and it gives you back a CFDictionary.

00:49:54.450 --> 00:49:58.160
The CFDictionary has the method name,
and it's got the parameter

00:49:58.160 --> 00:50:02.440
order and the parameter list,
the parameter order that it received.

00:50:02.480 --> 00:50:05.480
So you extract the
parameters from the list.

00:50:05.480 --> 00:50:10.160
You do something based upon them,
and then you call create reply document.

00:50:10.160 --> 00:50:14.640
The two parameters to create reply
document are the original dictionary

00:50:14.640 --> 00:50:18.920
passed back by copy request dictionary,
because that has sort of meta

00:50:18.920 --> 00:50:22.700
information about the connection,
the name of the message,

00:50:22.700 --> 00:50:25.510
which might be relevant
in forming the reply,

00:50:25.560 --> 00:50:28.470
and then a CF type,
which is the type that you wish

00:50:28.470 --> 00:50:30.640
to send back to the server.

00:50:30.640 --> 00:50:32.460
So you don't have to wrap it.

00:50:32.540 --> 00:50:35.560
It doesn't have a,
it's not prepositional.

00:50:35.580 --> 00:50:36.380
It's not prepositional at all.

00:50:36.380 --> 00:50:39.320
It's just the raw CF or NS type.

00:50:39.340 --> 00:50:42.240
So you send the reply document
using whatever server that

00:50:42.240 --> 00:50:45.220
you're embedding this in,
and then you profit, because,

00:50:45.310 --> 00:50:48.320
I don't know,
that's what they always say on Slashdot.

00:50:49.830 --> 00:50:55.880
Okay, so there is no real free lunch
with Web Services discovery.

00:50:55.880 --> 00:50:59.060
There are some standards
that are standardizing,

00:50:59.140 --> 00:51:03.690
sort of accreting over in the corner,
to allow for discovery of Web Services,

00:51:03.710 --> 00:51:05.250
but we don't support them yet.

00:51:07.360 --> 00:51:09.360
Most of the time, when somebody says,
"You need to call my web

00:51:09.360 --> 00:51:12.240
service," they're going to hand
you a textual description of

00:51:12.240 --> 00:51:15.450
what that web service expects,
and that's usually a very

00:51:15.450 --> 00:51:17.350
easy way to implement it.

00:51:17.350 --> 00:51:19.040
You just sort of go, "Okay,
parameter name this,

00:51:19.040 --> 00:51:20.830
should be this value,
parameter name this,

00:51:20.830 --> 00:51:24.100
this value." That's sort of
how the XMLRPC community works.

00:51:24.980 --> 00:51:28.140
The SOAP community is trying
to automate that a lot more,

00:51:28.140 --> 00:51:31.250
and they have the
Web Services Description Language for

00:51:31.250 --> 00:51:36.340
describing the messages and the methods
that are available via Web Services.

00:51:37.270 --> 00:51:41.880
We have a tool, WSMakesDubs,
that tries to understand WSDL documents

00:51:41.880 --> 00:51:46.690
and produce glue code that sits on top
of the Web Services core framework.

00:51:46.720 --> 00:51:50.020
So if you actually view
the slides from last year,

00:51:50.020 --> 00:51:53.650
I run that tool and describe
and show how that tool is used

00:51:53.800 --> 00:51:57.470
to create an application that
queries some Web Services,

00:51:57.540 --> 00:52:01.860
sort of automatically generating
the glue code for you.

00:52:02.230 --> 00:52:06.440
Okay, so I do have a few minutes
to go through my demo.

00:52:06.440 --> 00:52:10.090
And if I could have Demo Machine 2.

00:52:18.310 --> 00:52:18.490
There it is.

00:52:18.490 --> 00:52:19.150
So one of the things that comes
up a lot is people want to be

00:52:19.190 --> 00:52:20.300
able to write Apache plug-ins or
Apache modules to talk to applications.

00:52:20.300 --> 00:52:23.890
So I'm going to use a couple of the
technologies that I talked about

00:52:23.910 --> 00:52:26.300
today to build this application.

00:52:26.300 --> 00:52:28.270
I've got it built,
so I'll just run through it and

00:52:28.270 --> 00:52:29.290
then I'll show you the code.

00:52:29.310 --> 00:52:33.310
So the first thing is that
I have an Objective-C application

00:52:33.830 --> 00:52:38.290
that uses Web Services to talk
to a host over Web Services.

00:52:38.300 --> 00:52:40.300
So someplace there is
a Web Services server,

00:52:40.300 --> 00:52:46.160
and it is talking to
iTunes over Apple Events.

00:52:46.300 --> 00:52:48.480
So here's my little application.

00:52:48.480 --> 00:52:50.300
I get a little drawer here.

00:52:50.310 --> 00:52:54.090
I can open up these wedges,
and it's going to send a request to

00:52:54.090 --> 00:52:59.300
the server each time I open a wedge
to get the-- who created the web.

00:52:59.300 --> 00:53:03.360
the song, the title of the track,
the name of the artist.

00:53:03.550 --> 00:53:07.340
So go ahead and everybody likes polka.

00:53:07.340 --> 00:53:11.410
Go ahead and play a little polka music,
yeah.

00:53:11.470 --> 00:53:13.320
Turn it down because it's annoying.

00:53:13.420 --> 00:53:16.580
And so as you can see,
I've got a little progress bar

00:53:16.580 --> 00:53:18.110
here at the bottom that updates.

00:53:18.220 --> 00:53:20.500
It's actually doing a poll to
get that once every second,

00:53:20.500 --> 00:53:24.940
it fires a timer off,
sends a request off through Apache,

00:53:24.940 --> 00:53:29.370
and tries to sort of update
the title and the time.

00:53:29.400 --> 00:53:32.500
I click stop, and oh no,
an exception occurred.

00:53:32.520 --> 00:53:37.250
This is a good opportunity to first
mute the sound and then go into the

00:53:37.250 --> 00:53:40.650
script that implements all this.

00:53:40.950 --> 00:53:44.960
So the way the demo is put together--
and I'm actually going to make the demo

00:53:44.960 --> 00:53:48.740
available through DTS because it does
show a lot of these technologies-- is

00:53:48.740 --> 00:53:53.090
that there is an Apple script application
that receives the XMLRPC request

00:53:53.560 --> 00:53:54.940
and does something based on it.

00:53:54.940 --> 00:53:56.130
it.

00:53:56.540 --> 00:53:59.030
So here's a whole bunch of Apple scripts.

00:53:59.110 --> 00:53:59.580
Play track.

00:53:59.670 --> 00:54:02.400
This is probably the
easiest thing to understand.

00:54:02.450 --> 00:54:08.000
When my tool said play track and gave the
ID of the track that I wanted to play,

00:54:08.210 --> 00:54:09.350
it talked to Apache.

00:54:09.760 --> 00:54:14.940
Apache talked to a daemon that sent
the Apple event onto this script,

00:54:15.040 --> 00:54:18.300
which then sent the Apple event
to iTunes to play the song.

00:54:18.300 --> 00:54:23.910
So I got an exception because
I had commented this out.

00:54:25.800 --> 00:54:38.100
[Transcript missing]

00:54:39.040 --> 00:54:41.520
Polka is still playing in the background.

00:54:41.520 --> 00:54:43.900
Now I can stop it,
which I'm sure everybody

00:54:44.330 --> 00:54:46.540
is relieved about.

00:54:46.540 --> 00:54:51.810
Because I'm an uber geek,
I really don't want to take

00:54:51.820 --> 00:54:54.640
my hands off the home row.

00:54:54.640 --> 00:54:54.640
I have a Perl script.

00:54:54.840 --> 00:55:01.520
that uses one of the Perl XMLRPC things
to call my web service running in Apache.

00:55:01.520 --> 00:55:05.120
And I'm doing this to show what
the message actually looks like.

00:55:05.120 --> 00:55:09.070
So if I'm going to get the genres,
it's a simple call

00:55:09.530 --> 00:55:12.830
XMLRPC Perl subroutine.

00:55:13.030 --> 00:55:18.530
And the name of the XMLRPC method
happens to be the bundle identifier

00:55:18.580 --> 00:55:23.040
of that AppleScript application
followed by the name of the subroutine.

00:55:23.120 --> 00:55:27.940
So the architecture underneath that's
glued to Apache is actually general.

00:55:27.940 --> 00:55:32.640
It will allow you to send a
AppleScript do subroutine command

00:55:32.640 --> 00:55:38.810
to any application that implements
AppleScript attachability.

00:55:39.020 --> 00:55:42.670
So just we can demo that real quick.

00:55:43.600 --> 00:55:47.620
So I want to go to Books and Spoken.

00:55:47.620 --> 00:55:49.260
And I always like this song.

00:55:49.260 --> 00:55:50.620
It's a good song.

00:55:50.620 --> 00:55:54.690
Let's go ahead and play Polka Power.

00:55:54.780 --> 00:55:56.150
Oh, it's all about the Pentiums.

00:55:56.230 --> 00:55:56.700
OK.

00:55:56.760 --> 00:55:58.670
So anyway,
you can see that the script is just

00:55:58.690 --> 00:56:00.540
working the same way as an application.

00:56:00.540 --> 00:56:01.700
It could be running on Linux.

00:56:01.700 --> 00:56:03.330
It could be running on Windows.

00:56:03.440 --> 00:56:05.560
That's really what
Web Services is all about,

00:56:05.740 --> 00:56:07.760
having a heterogeneous environment.

00:56:07.920 --> 00:56:10.660
So I still have a couple minutes.

00:56:10.680 --> 00:56:15.300
Just going to show you some of the
source code that does all this stuff.

00:56:16.360 --> 00:56:17.030
Where to start?

00:56:17.200 --> 00:56:21.810
Let's start with the defs
file for the bridge code that

00:56:22.520 --> 00:56:25.880
runs alongside of Apache.

00:56:25.880 --> 00:56:28.770
So the thing is, you don't want Apache to
be running as root.

00:56:28.770 --> 00:56:29.860
You never want that.

00:56:29.880 --> 00:56:33.430
So instead,
Apache looks up a daemon that is

00:56:33.430 --> 00:56:39.950
running as root that is allowed to send
Apple events into this user's context.

00:56:40.320 --> 00:56:43.360
The daemon implements
this single Mach message.

00:56:43.360 --> 00:56:45.970
It takes an input
XML request and an output,

00:56:46.120 --> 00:56:48.360
and it outputs the XML RPC response.

00:56:48.360 --> 00:56:53.070
The implementation of that,
this is what Mig generated for me,

00:56:53.070 --> 00:56:55.870
this doMessage server-side stub.

00:56:55.890 --> 00:57:01.760
You can see that the input parameters
are the address of the blob of data

00:57:01.860 --> 00:57:06.800
and the size of the blob of data,
and then I'm to supply to it the size

00:57:07.020 --> 00:57:09.880
of the blob of data that I'm returning.

00:57:09.880 --> 00:57:15.970
At its count,
Mig will actually take care of

00:57:16.170 --> 00:57:20.490
sending that response for me.

00:57:20.910 --> 00:57:23.040
This is where I'm looking
up the name of the daemon.

00:57:23.040 --> 00:57:26.740
So the Apache module just gets
instantiated by Apache when

00:57:26.740 --> 00:57:30.440
I go to a specific URL,
looks up the name of the daemon.

00:57:30.480 --> 00:57:35.230
It has already gotten the
data out of the HTTP post.

00:57:35.570 --> 00:57:37.610
Then it calls my daemon right here.

00:57:37.780 --> 00:57:44.670
I'm using the CFData stuff to sort
of wrap the data that comes in.

00:57:44.820 --> 00:57:47.860
And then it gets its response,
and it forwards it back out Apache.

00:57:47.900 --> 00:57:52.330
And Apache deals with setting
up the HTTP connection,

00:57:52.440 --> 00:57:55.450
accepting it, dealing with errors,
et cetera.

00:57:55.560 --> 00:57:57.970
Okay, so like I said,
we're going to put that on the

00:57:57.970 --> 00:58:01.710
developer website so that people can,
you know, write their own daemons

00:58:01.790 --> 00:58:02.900
doing all this stuff.

00:58:02.900 --> 00:58:05.100
I forgot my clicker.

00:58:05.210 --> 00:58:09.100
And with that,
if we could have the slides back.

00:58:09.100 --> 00:58:13.090
Can I get slides?

00:58:16.600 --> 00:58:17.190
Okay.

00:58:17.200 --> 00:58:19.220
So that was the demo.

00:58:19.220 --> 00:58:22.350
Oh, there was a nice build on that
that I forgot to do last time.

00:58:22.360 --> 00:58:27.140
So showing that you can go and use all
these technologies in various places.

00:58:27.140 --> 00:58:30.000
This is really how you would
architect such a system.

00:58:30.000 --> 00:58:36.120
You would use web services to accept
incoming events from a heterogeneous

00:58:36.120 --> 00:58:40.950
environment and use XMLRPC and the
parsing APIs to figure out what

00:58:40.950 --> 00:58:44.920
the data is and use Apple Events to
talk to an application that's

00:58:45.160 --> 00:58:47.790
providing some service for you.

00:58:48.260 --> 00:58:51.980
All right, so let's summarize what
we've talked about today.

00:58:51.980 --> 00:58:55.240
It was a lot of different technologies.

00:58:55.340 --> 00:58:58.800
Pipes and sockets,
this is typically for legacy code

00:58:58.890 --> 00:59:03.590
or for tools or for things that
need stream data between processes.

00:59:03.590 --> 00:59:06.590
Notify, this is great for
broadcasting a state change,

00:59:06.680 --> 00:59:10.980
and if you're writing new code where you
might think you're going to use Signal,

00:59:10.980 --> 00:59:12.750
please use Notify instead.

00:59:12.750 --> 00:59:14.550
You'll much prefer it.

00:59:14.940 --> 00:59:18.100
Mach Message allows you to
write really complex servers,

00:59:18.100 --> 00:59:20.620
and it's very powerful,
and it's really at the

00:59:20.620 --> 00:59:23.570
core of what ROS does,
and the best reference for that is

00:59:23.720 --> 00:59:25.880
probably the source code in Darwin.

00:59:25.880 --> 00:59:28.660
CFMessagePort is a great
way of doing blobs of data

00:59:28.660 --> 00:59:30.750
messaging between applications.

00:59:30.790 --> 00:59:33.380
It's very efficient,
and it works really well

00:59:33.410 --> 00:59:35.140
with all our frameworks.

00:59:35.200 --> 00:59:38.030
Apple Events,
anytime you can add Apple Events to your

00:59:38.180 --> 00:59:40.500
application to make it more scriptable.

00:59:40.500 --> 00:59:43.120
The iTunes guys didn't know that
I was going to have a Perl script

00:59:43.230 --> 00:59:44.860
talking to their applications.

00:59:44.860 --> 00:59:46.170
They didn't need to know.

00:59:46.170 --> 00:59:48.450
They just had to implement
the scriptability,

00:59:48.530 --> 00:59:51.570
and then I can come along and
leverage the work that they did.

00:59:51.600 --> 00:59:56.190
And then Objective-C distributed objects,
if you need to participate in an

00:59:56.280 --> 01:00:00.540
existing conversation or if you have
a new application that wants to be

01:00:00.540 --> 01:00:04.820
able to create a new conversation,
Objective-C distributed objects

01:00:04.820 --> 01:00:06.590
is a fine way to do that.

01:00:06.780 --> 01:00:09.850
Okay, so we wrap up.

01:00:09.940 --> 01:00:12.580
Here are a couple of sessions
I want to point you at.

01:00:12.800 --> 01:00:15.940
Building applications for
managed network environments.

01:00:15.970 --> 01:00:19.320
A lot of what is applicable
to networking is applicable

01:00:19.320 --> 01:00:21.700
to interprocess communication.

01:00:21.700 --> 01:00:24.320
So,
sort of understanding networking both in

01:00:24.320 --> 01:00:28.700
that session and in CFNetwork in depth,
which I also highly recommend,

01:00:28.700 --> 01:00:31.670
you're going to get a much better
understanding about how to write

01:00:31.740 --> 01:00:36.800
applications that don't block when
they don't need to and perform

01:00:36.800 --> 01:00:39.700
really well on our platform.

01:00:39.730 --> 01:00:42.700
Writing threaded
applications on Mac OS X.

01:00:42.760 --> 01:00:45.700
Threads are really just kind
of like another process.

01:00:45.700 --> 01:00:48.180
Sort of the same things are
going to apply to sending a

01:00:48.180 --> 01:00:49.700
message to another thread.

01:00:49.730 --> 01:00:53.700
And then stump the experts tonight,
which we'll all go to.

01:00:53.740 --> 01:00:58.260
So, here are the names of some
of the technology people that

01:00:58.260 --> 01:01:00.700
you might want to contact.

01:01:00.700 --> 01:01:03.820
The important thing here is the
URL at the bottom where all this

01:01:03.820 --> 01:01:05.700
information ends up being anyway.

01:01:05.700 --> 01:01:09.660
So, I don't expect people to actually be
able to write all these things down.

01:01:09.770 --> 01:01:11.660
Reference library.

01:01:11.710 --> 01:01:15.080
This should be interesting because
probably the best book on Unix

01:01:15.080 --> 01:01:18.700
messaging is going to be the original
Unix book by Kernighan and Pike.

01:01:18.700 --> 01:01:21.700
There's a URL you can go
to to order that book.

01:01:21.700 --> 01:01:25.690
The Mach documentation,
I don't think Apple produces any.

01:01:25.700 --> 01:01:31.700
The best documentation I found are some
PostScript files on an FTP server at CMU.

01:01:31.700 --> 01:01:35.890
So, that's where you want to go to
learn how to write Mach servers.

01:01:36.130 --> 01:01:39.180
Inside Macintosh IEC talks
about Apple Events.

01:01:39.230 --> 01:01:42.890
It's a little dated because, you know,
it was written 12 years ago,

01:01:42.890 --> 01:01:44.660
but it's all still applicable.

01:01:44.660 --> 01:01:47.040
So if you want to understand
Apple Events better,

01:01:47.040 --> 01:01:48.200
you should go there.

01:01:48.200 --> 01:01:52.820
And then the Web Services Documentation
Online talks about the Jaguar APIs.

01:01:52.820 --> 01:01:56.220
There is no documentation up
on the new server APIs yet.

01:01:56.250 --> 01:01:58.820
It's sort of self-documented
by the header file,

01:01:58.820 --> 01:02:00.160
and it's pretty easy.
WEBVTT

00:00:27.110 --> 00:00:31.300
Thank you, Xavier.

00:00:31.460 --> 00:00:34.570
So, as Xavier said,
my name is Robin Mikawa.

00:00:34.730 --> 00:00:37.880
I'm the manager of the
Type Engineering team at Apple Computer.

00:00:37.880 --> 00:00:41.610
And I'll be talking to
you today about fonts.

00:00:41.610 --> 00:00:44.220
But not just fonts.

00:00:44.220 --> 00:00:48.840
I'm going to be talking about the font
system architecture and how it works,

00:00:48.840 --> 00:00:51.900
how it interacts with
your application software,

00:00:51.900 --> 00:00:55.420
and how you can take advantage
of it to make a really,

00:00:55.420 --> 00:00:56.980
really excellent user experience.

00:00:57.000 --> 00:01:02.320
So, let's get started.

00:01:04.710 --> 00:01:07.320
So why am I talking about fonts?

00:01:07.370 --> 00:01:09.040
Why are fonts important?

00:01:09.080 --> 00:01:11.000
Well, think about it this way.

00:01:11.000 --> 00:01:15.610
Imagine rolling the clock back 20,
30 years and think about

00:01:15.660 --> 00:01:17.130
how fonts worked back then.

00:01:17.130 --> 00:01:19.810
You would have had one
font on the system,

00:01:19.900 --> 00:01:23.160
maybe a green or amber screen,
and that's it.

00:01:23.160 --> 00:01:27.440
Maybe at best you had a handful of
fonts that you had to deal with.

00:01:27.440 --> 00:01:30.850
Well,
things have obviously changed since then.

00:01:30.850 --> 00:01:35.340
We have dozens of fonts that get
installed by default on Mac OS X.

00:01:35.340 --> 00:01:38.660
Users can install even more
fonts on their systems.

00:01:38.660 --> 00:01:42.800
Applications come with
specialized fonts along with them.

00:01:42.840 --> 00:01:45.930
So you have tons of fonts
you get to deal with,

00:01:46.060 --> 00:01:47.410
even by default.

00:01:48.830 --> 00:01:53.220
Another thing that we've gotten
feedback on with Mac OS X has

00:01:53.220 --> 00:01:56.580
been that fonts are complicated.

00:01:56.580 --> 00:02:02.340
People have to deal with a whole
variety of issues with regard to fonts,

00:02:02.400 --> 00:02:05.340
even with just installing
or previewing them.

00:02:05.340 --> 00:02:07.510
You might have encountered
that with your family members,

00:02:07.510 --> 00:02:10.110
asking, well, where do I put these fonts?

00:02:10.140 --> 00:02:13.680
I see a bunch of different
directories with the name fonts on it.

00:02:13.840 --> 00:02:14.820
Where does it go?

00:02:15.710 --> 00:02:20.360
And so what we've tried to do with
Panther is tie into that whole

00:02:20.360 --> 00:02:22.920
initiative to put the user at the center.

00:02:22.920 --> 00:02:27.460
As opposed to having fonts very
computer-centric and file-centric,

00:02:27.460 --> 00:02:31.020
we want to make it so that the users
can really take advantage of fonts

00:02:31.060 --> 00:02:35.170
and really find it easy and convenient
to use and really take advantage of

00:02:35.170 --> 00:02:40.150
all the stuff that font developers
and you guys have put in to make these

00:02:40.460 --> 00:02:44.880
things expressive and fully functional.

00:02:46.720 --> 00:02:50.950
So what I'll be talking about today,
I'm going to be starting off with a

00:02:50.950 --> 00:02:54.690
description of the font architecture.

00:02:54.760 --> 00:02:57.870
You're going to get a chance to
understand what the system does,

00:02:57.950 --> 00:03:02.430
what it does for you,
and what all the different components do

00:03:02.430 --> 00:03:05.560
and how they interact with each other.

00:03:05.620 --> 00:03:09.300
The second part of the session,
I'll be talking about what you can do

00:03:09.300 --> 00:03:14.070
to take advantage of the system and
bring it across to your applications

00:03:14.070 --> 00:03:16.290
and really make things shine.

00:03:18.890 --> 00:03:21.030
So let me just dive straight
into the first section.

00:03:21.030 --> 00:03:22.260
You can think of it this way.

00:03:22.260 --> 00:03:24.810
I'm going to be lifting
up the hood on the system,

00:03:24.850 --> 00:03:27.290
pulling out the font
engine or the font system,

00:03:27.290 --> 00:03:30.300
and showing you how all
the different pieces work.

00:03:30.420 --> 00:03:36.970
And right up here,
I've got a short list of all

00:03:36.970 --> 00:03:36.970
the different components related
to the font architecture.

00:03:37.330 --> 00:03:39.100
So let me just run through them.

00:03:39.260 --> 00:03:41.910
First off,
we've got the font database system,

00:03:42.030 --> 00:03:44.080
the font registry, as we call it.

00:03:44.190 --> 00:03:48.640
This keeps track of all the information
related to the fonts and manages all

00:03:48.650 --> 00:03:52.430
the fonts that the user can access.

00:03:52.670 --> 00:03:55.200
Secondly, we have the font rasterizers.

00:03:55.200 --> 00:03:58.100
It's the font engine that
basically takes the font data,

00:03:58.140 --> 00:04:01.340
the raw font data,
converts it over to data that can be

00:04:01.340 --> 00:04:05.310
used by other parts of the system,
such as the graphics system

00:04:05.380 --> 00:04:09.490
or the printing architecture
or even your applications.

00:04:10.200 --> 00:04:13.100
The next level up,
we've got the messaging system.

00:04:13.100 --> 00:04:16.660
One thing that you should understand
is that we have implemented a

00:04:16.660 --> 00:04:20.660
centralized font server that keeps
track of all of this information.

00:04:20.780 --> 00:04:24.750
In order for it to communicate the
font data to your applications and

00:04:24.880 --> 00:04:28.450
to other processes on the system,
it needs to send messages,

00:04:28.450 --> 00:04:32.300
and these are based on the
Mach kernel messaging system.

00:04:32.930 --> 00:04:35.410
Another level up,
we've got the caching system.

00:04:35.530 --> 00:04:39.620
We've got the caches to optimize
performance so that you don't have to

00:04:39.620 --> 00:04:44.380
always hit the lower levels of the system
to get the font data that you need.

00:04:44.830 --> 00:04:46.220
And then this is the next level up.

00:04:46.300 --> 00:04:48.390
We've got the programming interface.

00:04:48.630 --> 00:04:51.020
This is what you've traditionally
heard in the past and what

00:04:51.020 --> 00:04:52.200
we've really focused on.

00:04:52.320 --> 00:04:56.450
What I'm trying to do here is connect
you to the operating system and show

00:04:56.450 --> 00:05:01.000
you what the programming interface can
do for you and why we've told you to

00:05:01.000 --> 00:05:03.770
do certain things as opposed to others.

00:05:04.020 --> 00:05:07.220
And then finally, on top of that,
as part of this initiative to

00:05:07.390 --> 00:05:11.270
put the user at the center,
we've implemented and exposed a number

00:05:11.270 --> 00:05:15.540
of standard user interface elements
that you could take advantage of so

00:05:15.540 --> 00:05:20.950
that your applications really fit in,
have a consistent user interface,

00:05:20.950 --> 00:05:23.780
and take advantage of all
the new features that we've

00:05:23.780 --> 00:05:25.400
implemented for Panther.

00:05:29.500 --> 00:05:32.800
So what I've just described is a short
list of all the different components,

00:05:32.800 --> 00:05:34.860
or the major components
in the font system.

00:05:34.860 --> 00:05:38.800
What this diagram shows you are
how they interact with each other.

00:05:38.800 --> 00:05:43.370
So over on the far right,
you'll see two of the components.

00:05:43.410 --> 00:05:47.320
Those are the components that
reside within the font server,

00:05:47.500 --> 00:05:50.130
or the ATS server,
as you might have seen it

00:05:50.300 --> 00:05:52.080
called within the system.

00:05:52.630 --> 00:05:56.200
The ATS, by the way,
stands for Apple Type Services,

00:05:56.320 --> 00:06:00.690
and that's actually the main component
that my team is responsible for.

00:06:00.700 --> 00:06:05.440
So within the server,
centralized for all of the different

00:06:05.440 --> 00:06:10.150
processes available on the system,
we've got the font rasterizers and

00:06:10.210 --> 00:06:13.400
the font database management system,
or the font registry.

00:06:15.390 --> 00:06:18.930
On the left-hand side of the screen,
you see everything that resides

00:06:18.950 --> 00:06:23.700
mainly within your application
context as opposed to the font server.

00:06:23.810 --> 00:06:26.930
That includes the user interface,
whether you implement it or

00:06:27.030 --> 00:06:30.430
the system implements it or
some combination between that.

00:06:30.500 --> 00:06:34.690
We have the programming
interface and we have the caches.

00:06:34.800 --> 00:06:38.770
And in between the two of them,
we have messages going back and forth

00:06:38.770 --> 00:06:43.440
across to communicate the font-related
data that your applications need and,

00:06:43.440 --> 00:06:47.740
more importantly, what your users need.

00:06:49.690 --> 00:06:54.250
Okay, so let me start diving into
the details of this diagram.

00:06:54.310 --> 00:06:57.600
First off,
let me work from the very basics here.

00:06:57.700 --> 00:07:01.930
The font registry itself,
it is the central repository

00:07:02.090 --> 00:07:03.130
of font information.

00:07:03.130 --> 00:07:07.500
You can also think of it as the
interface to the file system that

00:07:07.500 --> 00:07:09.040
lives underneath everything else.

00:07:09.040 --> 00:07:11.600
So users, for example,
might install fonts.

00:07:11.600 --> 00:07:14.020
We track that information.

00:07:14.280 --> 00:07:18.220
We handle mapping in all of the
file-related information and

00:07:18.420 --> 00:07:19.580
pull it into the font registry.

00:07:19.600 --> 00:07:21.400
database.

00:07:21.760 --> 00:07:25.640
The font registry also tracks all the
different locations that are supported

00:07:25.640 --> 00:07:30.630
on Mac OS X for installing fonts,
and it also keeps track of the files

00:07:30.830 --> 00:07:35.200
that are associated with the fonts
within each of those locations.

00:07:35.890 --> 00:07:39.790
The font registry is also responsible
for managing the support for access

00:07:39.790 --> 00:07:42.020
privileges and multiple users.

00:07:42.140 --> 00:07:44.220
So for example,
we've done a considerable amount of

00:07:44.300 --> 00:07:48.670
work for Panther to support the new
fast user switching feature that

00:07:48.720 --> 00:07:51.030
you might have seen in the keynote.

00:07:52.400 --> 00:07:55.070
Another piece of information
that we keep track of with the

00:07:55.070 --> 00:07:59.500
fonts has to do with the state
and also the usage of the fonts.

00:07:59.690 --> 00:08:03.480
Part of the work that we do within
the font registry is we synthesize

00:08:03.490 --> 00:08:07.970
data and provide a canonical format
for accessing font-related data.

00:08:08.260 --> 00:08:10.250
There's a number of different
pieces of information,

00:08:10.280 --> 00:08:12.640
including the character
mapping information,

00:08:12.670 --> 00:08:17.620
the paths, the outline data,
the bitmap information, the metrics.

00:08:17.660 --> 00:08:20.590
We handle all of that through
the font registry and other

00:08:20.680 --> 00:08:22.830
parts of the font architecture.

00:08:22.930 --> 00:08:26.720
We also keep track of fonts
that somehow get corrupted

00:08:26.720 --> 00:08:28.660
or actually bad starting off.

00:08:28.680 --> 00:08:32.870
We can actually tag those fonts
as corrupted or bad or potentially

00:08:32.920 --> 00:08:37.050
causing a crash during runtime and
prevent other users or other processes

00:08:37.120 --> 00:08:39.420
from running into that problem again.

00:08:39.420 --> 00:08:44.160
And that state information is kept
track of in the font registry.

00:08:44.790 --> 00:08:47.880
One additional piece of information,
or one additional service

00:08:47.970 --> 00:08:51.410
provided by the font registry,
is keeping track of all the different,

00:08:51.410 --> 00:08:54.270
the multitude of file
formats available for fonts.

00:08:54.280 --> 00:08:58.060
So, for example,
some fonts are stored in single files,

00:08:58.060 --> 00:09:02.400
other ones are stored in multiple
files that get associated with

00:09:02.400 --> 00:09:06.220
each other in certain ways,
you know, by file name or maybe something

00:09:06.290 --> 00:09:08.000
buried deep within the font file.

00:09:09.270 --> 00:09:13.680
Another thing we keep track of
is whether or not that particular

00:09:13.680 --> 00:09:19.380
font data is stored within the data
fork or resource fork of a file.

00:09:20.050 --> 00:09:23.780
So that covers the basics of
what the font registry does.

00:09:23.850 --> 00:09:28.490
Next, I'll be describing what
the font rasterizers do.

00:09:28.560 --> 00:09:32.450
Now, you can think of these
as the basic engines.

00:09:32.610 --> 00:09:35.180
These know all the details
about the font data.

00:09:35.180 --> 00:09:38.830
They can take the font data
that's stored in the file system,

00:09:38.830 --> 00:09:41.970
run through it,
and spit out other forms of data that

00:09:41.970 --> 00:09:44.640
can be used by other parts of the system.

00:09:44.640 --> 00:09:48.050
So that includes graphic data,
the bitmaps, the paths,

00:09:48.120 --> 00:09:52.120
the outlines that get rendered
through the graphics systems.

00:09:52.120 --> 00:09:57.140
We also provide support for converting
data from what's natively stored

00:09:57.140 --> 00:10:01.720
on disk to the formats used in,
for example, PDF documents when you

00:10:01.820 --> 00:10:04.110
embed font data within them.

00:10:04.120 --> 00:10:07.120
Also,
we convert data to the form used when

00:10:07.300 --> 00:10:14.120
downloading fonts to the printing system,
generating PostScript forms of the font.

00:10:14.640 --> 00:10:16.600
for example.

00:10:18.190 --> 00:10:23.140
The other thing that we do with the
font rasterizers is very similar

00:10:23.140 --> 00:10:26.490
to the way the font registry
handles different file formats.

00:10:26.490 --> 00:10:29.830
The font rasterizers,
they actually know all the

00:10:29.830 --> 00:10:32.400
details about the different
formats available out there.

00:10:32.400 --> 00:10:35.420
So not only can fonts be stored
in different file formats,

00:10:35.420 --> 00:10:38.660
they can be stored in different
data formats themselves.

00:10:39.140 --> 00:10:43.430
So we've got the standard technologies
that are out there right now,

00:10:43.430 --> 00:10:45.240
TrueType, PostScript.

00:10:45.260 --> 00:10:50.170
We support multiple forms of them,
including the Type 1 format that you're

00:10:50.170 --> 00:10:53.000
probably used to on Mac OS 9 and older.

00:10:53.000 --> 00:10:57.670
And we also support the new CFF or
Compact Font format that's available with

00:10:57.670 --> 00:11:02.420
the OpenType form of the PostScript fonts
and also used in PDF documents.

00:11:02.460 --> 00:11:06.500
And then last but not least,
we support the older or

00:11:06.500 --> 00:11:09.120
legacy bitmap-only formats.

00:11:09.140 --> 00:11:13.580
that were available for
Quickdraw-based applications.

00:11:16.570 --> 00:11:21.380
Okay, so next,
let me talk about the messaging system.

00:11:21.480 --> 00:11:25.340
As I mentioned before,
the main thing about messages is

00:11:25.340 --> 00:11:29.440
that they are based on the lower
level kernel messaging system.

00:11:29.550 --> 00:11:33.100
They're the inter-process
communication mechanism for going

00:11:33.210 --> 00:11:36.770
back and forth between the font
server and your processes and

00:11:36.820 --> 00:11:38.960
other processes on the system.

00:11:39.350 --> 00:11:44.400
Another key thing that you can remember
from this is that pretty much any

00:11:44.500 --> 00:11:49.540
programming interface related to the
font may ultimately result in a message

00:11:49.750 --> 00:11:54.530
that goes from your application out
to the server and potentially back.

00:11:54.740 --> 00:11:57.900
Note that this can take time,
and I'll be touching on this

00:11:57.900 --> 00:12:00.670
subject a little bit later on.

00:12:01.510 --> 00:12:06.780
Now, messages can be categorized
into different classes.

00:12:06.860 --> 00:12:10.750
The one that's probably most
relevant to you is that when changes

00:12:10.790 --> 00:12:13.750
occur within the font registry,

00:12:13.960 --> 00:12:17.760
The font server will actually
broadcast messages out to any

00:12:17.760 --> 00:12:22.060
clients that are interested,
notification about these changes.

00:12:22.230 --> 00:12:26.300
Similarly, there's also support for your
applications to send notification

00:12:26.470 --> 00:12:36.100
messages back to the ATS server so
that you can notify us to do certain

00:12:36.100 --> 00:12:36.100
actions or update our font registry.

00:12:36.960 --> 00:12:44.660
There's one additional flavor
of messages or quirk on it that

00:12:44.660 --> 00:12:50.080
we've implemented through our API,
and that includes support for actually

00:12:50.080 --> 00:12:50.080
hooking into the messaging system.

00:12:50.970 --> 00:12:55.300
The way this works, for example,
is basically since a number of

00:12:55.300 --> 00:13:00.640
messages that applications can send
out for querying about missing fonts,

00:13:00.690 --> 00:13:04.320
let's say you open a document,
it doesn't have the fonts you need,

00:13:04.350 --> 00:13:08.060
what that can often do is trigger
a message across the font server to

00:13:08.060 --> 00:13:12.310
ask for a replacement or to find out
whether it's actually present or not.

00:13:13.280 --> 00:13:17.050
We've provided a mechanism so that
you can hook into that process,

00:13:17.360 --> 00:13:20.940
intercept that message,
and provide your own level of support

00:13:21.310 --> 00:13:23.550
for handling that missing font.

00:13:23.580 --> 00:13:27.960
So some font utility application vendors
have actually taken advantage of this

00:13:27.960 --> 00:13:33.240
and provided a user interface or even
automatically provide the appropriate

00:13:33.240 --> 00:13:36.460
font and activate it within the system.

00:13:36.820 --> 00:13:39.830
So this shows you some of
the strengths and benefits of

00:13:39.830 --> 00:13:42.330
going to a messaging system.

00:13:43.450 --> 00:13:46.730
The next level are the caches.

00:13:46.900 --> 00:13:49.320
Now, as I mentioned before,
there is a cost to doing

00:13:49.320 --> 00:13:53.460
messages and having this whole
font server-based architecture.

00:13:53.680 --> 00:13:59.340
What we try to do with the caches,
and what we've succeeded actually,

00:13:59.410 --> 00:14:04.620
is making sure that the most
commonly used functions and the most

00:14:04.620 --> 00:14:09.700
commonly used data that you access
is available as fast as possible

00:14:09.700 --> 00:14:09.700
through this caching mechanism.

00:14:10.220 --> 00:14:16.730
You'll notice that the key areas that
we're trying to shield you from are

00:14:16.730 --> 00:14:19.040
the lower levels in the font system.

00:14:19.160 --> 00:14:21.550
So, for example,
the font registry corresponds

00:14:21.660 --> 00:14:23.080
to the file system usage.

00:14:23.180 --> 00:14:27.550
It takes time to pull in a font file,
read it in, and handle it and process it.

00:14:27.690 --> 00:14:30.200
In fact,
processing it is the next level up

00:14:30.340 --> 00:14:34.860
that we try to reduce the impact
performance-wise on your applications.

00:14:34.860 --> 00:14:48.230
It takes time to run through.

00:14:48.230 --> 00:14:48.240
In fact, for PostScript fonts,
we have to parse through the entire

00:14:48.240 --> 00:14:48.240
PostScript font program in order
to get even basic data such as

00:14:48.240 --> 00:14:48.240
the metrics or one glyph outline.

00:14:48.610 --> 00:14:51.960
And finally, as I mentioned,
messaging takes time.

00:14:52.050 --> 00:14:56.970
It's often much faster to just do a
simple function call to access your

00:14:57.080 --> 00:15:01.360
font data locally from within a cache
than sending a message off to the font

00:15:01.500 --> 00:15:04.110
server and coming back with that data.

00:15:07.100 --> 00:15:08.710
Okay,
so this is what you're probably most

00:15:08.880 --> 00:15:14.100
familiar with and what you deal with on a
day-to-day basis when it comes to fonts.

00:15:14.260 --> 00:15:19.240
So, as I mentioned earlier, ATS,
Apple Type Services,

00:15:19.290 --> 00:15:25.720
we provide a direct API into the
font system through the ATS font API.

00:15:26.100 --> 00:15:29.930
What this programming interface
allows you to do is modify or manage

00:15:30.090 --> 00:15:32.870
the contents of the font registry.

00:15:32.940 --> 00:15:36.490
You can also query the font
registry for information.

00:15:37.070 --> 00:15:41.940
We also provide support for accessing
data directly from the font rasterizers.

00:15:42.110 --> 00:15:45.270
And finally,
you can hook into the messaging

00:15:45.270 --> 00:15:49.990
system and take advantage of it
with your own application software.

00:15:50.490 --> 00:15:54.380
There are other APIs that are
available that are built on

00:15:54.380 --> 00:15:58.870
top of the underlying ATS APIs,
and those include the text system

00:15:58.870 --> 00:16:04.080
available within Cocoa or Carbon,
and also the legacy Quickdraw-based

00:16:04.080 --> 00:16:08.660
font manager is built on
top of the ATS font system.

00:16:12.580 --> 00:16:17.250
Now this is the last block diagram from
the architecture that I'll go over.

00:16:17.350 --> 00:16:20.300
This is a description of

00:16:21.210 --> 00:16:25.110
All the features that you might want to
have the user interface with regard to

00:16:25.110 --> 00:16:28.900
fonts support for you and your customers.

00:16:29.690 --> 00:16:33.210
First and foremost,
you want to be able to select or change

00:16:33.480 --> 00:16:38.810
the font and style information in your
documents or in any piece of text.

00:16:39.070 --> 00:16:44.210
You also want to be able to access
glyph-specific information within a font.

00:16:44.460 --> 00:16:49.880
This includes stuff like what characters
does this particular font support,

00:16:49.880 --> 00:16:53.360
or can I get access to different
variants on a character.

00:16:53.530 --> 00:16:58.320
And this is especially important
in the Asian market where there

00:16:58.880 --> 00:17:03.590
are different forms of the
Han characters that people use in,

00:17:03.650 --> 00:17:06.540
for example, their last names.

00:17:06.750 --> 00:17:11.530
Another feature of the fonts that
you can get access through the user

00:17:11.530 --> 00:17:13.430
interface are the typographic features.

00:17:13.570 --> 00:17:17.640
This includes support for turning
on and off ligatures or other

00:17:17.640 --> 00:17:19.940
variant forms within the font.

00:17:20.580 --> 00:17:25.500
And then finally, as I mentioned,
one thing that people have really

00:17:25.500 --> 00:17:28.860
asked us for in the operating
system is a really easy way to

00:17:28.860 --> 00:17:32.230
manage the fonts that you have,
your collection of fonts.

00:17:32.330 --> 00:17:36.810
This includes your
entire library of fonts.

00:17:38.300 --> 00:17:44.960
There have been-- users have asked
for ways to install their fonts

00:17:45.140 --> 00:17:48.590
much more easily and to be able to
preview their fonts much more easily.

00:17:48.700 --> 00:17:53.120
And so with Panther,
we try to make that much more robust,

00:17:53.120 --> 00:17:54.440
much more simple.

00:17:54.480 --> 00:17:56.700
And also,
we want to have room for growing

00:17:56.860 --> 00:17:58.850
and providing additional services.

00:17:59.110 --> 00:18:02.750
So with that, I'd like to bring up one of
the other engineers on my team.

00:18:02.960 --> 00:18:04.670
His name is Nathan Taylor.

00:18:04.720 --> 00:18:09.530
And he'll give you a demonstration of
some of the work we've done for Panther.

00:18:13.930 --> 00:18:14.850
Thank you, Robin.

00:18:15.060 --> 00:18:16.420
As Robin said, I'm Nathan Taylor.

00:18:16.450 --> 00:18:19.060
I'm an engineer with the
Apple Type Engineering Group.

00:18:19.100 --> 00:18:23.040
And I'm very excited to show you
the new user interface and the user

00:18:23.040 --> 00:18:26.790
interfaces that you should implement
for presenting fonts in a consistent

00:18:26.790 --> 00:18:29.000
way to your users of the system.

00:18:29.000 --> 00:18:31.850
We've taken the user-centric
approach to heart here.

00:18:32.010 --> 00:18:35.500
And if you saw the keynote,
you saw a brief glimpse of something

00:18:35.500 --> 00:18:37.180
I am very excited to show you today.

00:18:37.250 --> 00:18:40.260
So with that,
I'd like to switch to demo one, please.

00:18:41.940 --> 00:18:47.410
Okay, users just bought a bunch of fonts,
downloaded some fonts from the internet,

00:18:47.690 --> 00:18:49.760
doesn't really know necessarily
what they look like,

00:18:49.970 --> 00:18:53.820
and biggest question we've gotten
is where should we put these fonts?

00:18:53.900 --> 00:18:57.900
You know, there are many font folders,
which is the best one to place them in?

00:18:57.900 --> 00:19:01.080
We've tried to tell people
how to do it in Tech Notes,

00:19:01.080 --> 00:19:04.420
but there's a much easier way,
and let me show you.

00:19:04.660 --> 00:19:09.060
I'm going to open up a folder of
fonts here and go to one that's not

00:19:09.060 --> 00:19:10.600
currently installed in Mac OS X.

00:19:10.600 --> 00:19:13.600
It's a font that you know
and love from Mac OS 9.

00:19:13.600 --> 00:19:14.600
This is the Type 1 version of it.

00:19:14.600 --> 00:19:17.590
And if the user just
double clicks the font,

00:19:18.170 --> 00:19:20.890
The FontBook application comes up
and shows a quick preview of the

00:19:21.000 --> 00:19:23.600
font where they can switch between

00:19:23.680 --> 00:19:26.040
and examine the different styles.

00:19:26.080 --> 00:19:28.380
And with a single click
of a single button here,

00:19:28.440 --> 00:19:30.380
the font will be installed in
what we consider the appropriate

00:19:30.500 --> 00:19:31.780
place at this point in time.

00:19:31.840 --> 00:19:34.150
That is the user's fonts folder.

00:19:35.390 --> 00:19:37.890
When the font is installed,
the main font book user

00:19:37.890 --> 00:19:40.180
interface comes up,
selects the font,

00:19:40.210 --> 00:19:43.550
and they can see that their
action has actually taken effect.

00:19:45.110 --> 00:19:49.530
This gives a quick and easy interface
to browse the fonts in the system.

00:19:49.530 --> 00:19:53.020
With simple arrow keys or mouse actions,
the users can look at the

00:19:53.020 --> 00:19:57.070
various fonts that are installed,
get an idea of what's available,

00:19:57.270 --> 00:20:02.080
and if there are some that they don't
want or they're never going to use,

00:20:02.080 --> 00:20:04.360
there's an option to turn them off.

00:20:04.570 --> 00:20:07.400
I don't speak Korean,
I don't read Korean,

00:20:07.430 --> 00:20:09.120
I don't write Korean.

00:20:09.140 --> 00:20:11.890
I'm never going to use the
Korean fonts that always show

00:20:12.020 --> 00:20:13.490
up at the top of the font list.

00:20:13.500 --> 00:20:18.770
Well, I can simply select them in
FontBook and disable them.

00:20:20.730 --> 00:20:25.970
Once FontBook is able to fonts,
they will no longer be available

00:20:26.110 --> 00:20:31.410
and not show up in the fonts window
in Cocoa or Carbon applications.

00:20:33.210 --> 00:20:34.680
and Koba.

00:20:34.730 --> 00:20:38.560
It's also possible to
just add a bunch of fonts.

00:20:38.590 --> 00:20:43.140
We have a breakdown of the font
library that shows how fonts

00:20:43.140 --> 00:20:44.700
are grouped and categorized.

00:20:44.730 --> 00:20:47.100
There are the user fonts
that are just my fonts.

00:20:47.100 --> 00:20:49.350
There are the computer fonts,
which are shared between

00:20:49.350 --> 00:20:50.480
all users of the system.

00:20:50.500 --> 00:20:52.460
Network and classic similarly.

00:20:52.470 --> 00:20:56.300
Users can move fonts around between
these directors if they want to.

00:20:56.360 --> 00:20:59.130
What I'm going to do now
is add a bunch of fonts,

00:20:59.280 --> 00:21:03.720
the rest of the fonts from that
big folder I took Palitino from.

00:21:05.980 --> 00:21:07.800
And just add all the fonts there.

00:21:07.820 --> 00:21:12.290
I'm going to show you building
collections and searching for fonts.

00:21:13.500 --> 00:21:15.030
So all those fonts have been added.

00:21:15.140 --> 00:21:17.100
You can see I've got Avenir, Bodoni.

00:21:17.130 --> 00:21:19.730
All the ones I just
added are all selected.

00:21:20.610 --> 00:21:22.620
What I can do now is,
I know I just installed

00:21:22.980 --> 00:21:26.180
a bunch of ITC fonts,
but I want to group them so I can

00:21:26.180 --> 00:21:28.450
easily find them within my application.

00:21:28.570 --> 00:21:33.690
So, we have collection management
in Mac OS X to do this,

00:21:33.690 --> 00:21:37.760
and using the new collection management
system provided by the Cocoa layer,

00:21:37.910 --> 00:21:40.140
we can create a new collection.

00:21:41.610 --> 00:21:44.600
Name it my ITC fonts.

00:21:44.650 --> 00:21:45.740
And I want to add fonts to this.

00:21:45.870 --> 00:21:49.100
Well, they're somewhere in this list,
right?

00:21:49.410 --> 00:21:51.090
Well, let's find them.

00:21:52.690 --> 00:21:56.620
Type ITC and I get all the fonts
that match my search string.

00:21:56.810 --> 00:21:59.310
I can then select all these fonts.

00:22:00.260 --> 00:22:04.680
and drag them over to
my collection there.

00:22:04.750 --> 00:22:10.410
If I switch back to text edit now,
you'll see that the ITC Fonts

00:22:10.410 --> 00:22:12.100
collection is available.

00:22:13.640 --> 00:22:16.800
And selecting that
collection shows those fonts.

00:22:16.800 --> 00:22:18.100
I can then simply use them.

00:22:18.100 --> 00:22:20.530
They're available immediately.

00:22:24.240 --> 00:22:28.240
Likewise, there are ways for users to
quickly manipulate collections.

00:22:28.240 --> 00:22:29.170
They can tweak the collections.

00:22:29.190 --> 00:22:30.900
They can remove individual
faces from them.

00:22:30.900 --> 00:22:32.400
They can remove families.

00:22:32.430 --> 00:22:37.180
They can also disable the collections
from within the Font Panel or

00:22:37.410 --> 00:22:40.070
from within FontBook application.

00:22:41.370 --> 00:22:45.720
Say, for example,
I don't like the heavy faces here.

00:22:45.760 --> 00:22:49.060
You can select them and
disable them from this.

00:22:49.070 --> 00:22:50.260
Let me do that again.

00:22:50.290 --> 00:22:55.710
Disable them from the ITC collection,
rather than the library,

00:22:55.810 --> 00:22:57.290
which I've already showed you.

00:22:59.450 --> 00:23:03.440
And now, if I look at that family,
Franklin Gothic,

00:23:03.500 --> 00:23:05.570
the heavy faces are not there anymore.

00:23:05.700 --> 00:23:09.440
Easily just re-enabling
them brings them back.

00:23:09.640 --> 00:23:11.900
If I don't want to use that
collection of fonts now,

00:23:11.960 --> 00:23:14.500
I can simply disable the collection

00:23:15.170 --> 00:23:17.100
and the collection is hidden from the UI.

00:23:17.310 --> 00:23:20.410
The fonts are still active
for other apps to use,

00:23:20.410 --> 00:23:20.410
but

00:23:20.500 --> 00:23:22.160
The collection has been
hidden from the UI.

00:23:22.170 --> 00:23:24.560
While you may ask,
I want to group these and

00:23:24.680 --> 00:23:26.540
disable the fonts as a whole.

00:23:26.550 --> 00:23:29.640
As optional behavior,
we do have the possibility

00:23:29.640 --> 00:23:31.420
to disable the whole thing.

00:23:31.460 --> 00:23:34.380
Pulling down the option
key and disabling this

00:23:34.590 --> 00:23:37.930
will do what the alert here
says and disable all of

00:23:37.930 --> 00:23:40.310
those fonts from the library.

00:23:40.310 --> 00:23:44.950
If I look in all fonts here,
you can see that the ITC fonts

00:23:45.170 --> 00:23:46.720
are marked off and the font is not

00:23:47.900 --> 00:23:54.100
[Transcript missing]

00:23:54.810 --> 00:23:58.650
So what do you need to do in your
applications to take advantage

00:23:59.030 --> 00:24:01.700
of this new functionality
we're providing to the users?

00:24:01.700 --> 00:24:04.460
We've made it easier for the
users to manipulate their fonts.

00:24:04.500 --> 00:24:07.120
We think this is going to
allow them to do it more often.

00:24:07.160 --> 00:24:09.180
They don't need to know where
fonts live in the system.

00:24:09.590 --> 00:24:14.180
They can just launch an application
and turn things off as they wish.

00:24:14.210 --> 00:24:17.980
If your app doesn't
react to these changes,

00:24:18.010 --> 00:24:21.490
the user interface that you present
will not be consistent across the board,

00:24:21.490 --> 00:24:24.380
and we'd like it to be user-centric
so that everything feels the

00:24:24.490 --> 00:24:26.750
same in every application.

00:24:27.710 --> 00:24:32.400
The first thing you can do,
and the least we ask you to do,

00:24:32.490 --> 00:24:36.430
is implement support for
ATS font notifications.

00:24:36.530 --> 00:24:39.460
If you have a Carbon application
or Cocoa application,

00:24:39.460 --> 00:24:42.610
but in a Carbon application,
if you implement support

00:24:42.690 --> 00:24:47.100
for notifications,
we will notify you and call

00:24:47.760 --> 00:24:50.990
back a callback that you create.

00:24:50.990 --> 00:24:52.360
And in this case,
I put up alert to be extremely obvious.

00:24:53.480 --> 00:24:58.410
If we take a look in the fonts menu,
Avenir,

00:24:58.780 --> 00:25:01.220
Badoni,
these fonts have been added to the

00:25:01.320 --> 00:25:03.500
Fonts menu and immediately updated.

00:25:03.560 --> 00:25:06.170
If I were to disable them,
they would not show up next

00:25:06.330 --> 00:25:09.450
time the font was activated
and the Fonts menu was opened.

00:25:10.170 --> 00:25:13.720
This corrects the problem of
having to quit the app and relaunch

00:25:13.830 --> 00:25:17.800
the app from the old days and
makes it so much more consistent.

00:25:17.920 --> 00:25:22.590
But there's one step further you can go,
and this is what we really ask you to do.

00:25:22.820 --> 00:25:24.500
You can implement the fonts window.

00:25:24.540 --> 00:25:26.360
If you're doing a Cocoa application,
it's pretty easy.

00:25:26.360 --> 00:25:28.200
It's right there for you.

00:25:28.260 --> 00:25:32.360
In Carbon, it's quite possible,
but it's not quite as easy,

00:25:32.360 --> 00:25:33.750
but it's not hard at all.

00:25:34.050 --> 00:25:36.080
And let me give you an example.

00:25:38.050 --> 00:25:38.860
Let me just show you real quick.

00:25:39.040 --> 00:25:43.310
I've got a similar version
of Simple Text here that has

00:25:43.310 --> 00:25:45.000
a font window implemented.

00:25:45.170 --> 00:25:48.970
Close it, bring it back up.

00:25:49.370 --> 00:25:52.910
Like the other one,
I've got the same fonts,

00:25:52.910 --> 00:25:58.090
and if I re-enable that ITC collection,
I can show you that...

00:26:00.090 --> 00:26:03.110
All the support for collection
management and the user

00:26:03.110 --> 00:26:05.430
managed collections are there.

00:26:07.960 --> 00:26:12.790
If you implement the Fonts window,
subscribing to ATS notifications

00:26:12.810 --> 00:26:15.860
actually become unnecessary because
the Fonts window handles that

00:26:15.860 --> 00:26:17.880
automatically for you behind the scenes.

00:26:17.900 --> 00:26:23.770
So what do you need to do to do this?

00:26:31.090 --> 00:26:35.600
Adding notifications is
really a piece of cake.

00:26:35.720 --> 00:26:39.490
First, I chose to implement
the standard fonts menu.

00:26:39.650 --> 00:26:44.500
Three new function calls and effectively
only three new lines of code.

00:26:45.050 --> 00:26:48.580
To add notifications,
I just created one callback

00:26:48.600 --> 00:26:51.100
and made one function call.

00:26:51.910 --> 00:26:56.320
Whenever that notification came across,
my callback updated the font menu,

00:26:56.440 --> 00:26:58.070
and that was it.

00:26:59.360 --> 00:27:04.160
It's a little more work to
put in the fonts window,

00:27:04.180 --> 00:27:06.550
but we really don't think it's that hard.

00:27:07.820 --> 00:27:10.700
If you've been moving to a
Carbon Events based application,

00:27:10.700 --> 00:27:13.260
you probably already have a
standard Carbon Event handler.

00:27:13.290 --> 00:27:15.220
But that's the first
thing you need to do.

00:27:15.230 --> 00:27:19.340
And the handler I have in here
is about 20 lines of code.

00:27:19.660 --> 00:27:25.060
Next I put in a handler attached to the
window to handle the font window events,

00:27:25.060 --> 00:27:27.880
the font changes the user
made in the Fonts Panel,

00:27:27.940 --> 00:27:31.160
and that's about 25 lines of code.

00:27:31.220 --> 00:27:35.580
The last thing you need to do is
update the Fonts Window with the user

00:27:35.580 --> 00:27:38.790
selection with one new function call.

00:27:41.780 --> 00:27:43.890
Well, Robin also mentioned that
there were a bunch of other new

00:27:43.890 --> 00:27:45.210
features to the Fonts window.

00:27:45.290 --> 00:27:47.170
You see that there's a search field here.

00:27:47.290 --> 00:27:51.680
We also have a direct
access to managing fonts.

00:27:52.970 --> 00:27:56.210
brings up Fontbook directly,
and if the user has another

00:27:56.840 --> 00:28:00.190
font management application,
we expect it to bring that up.

00:28:01.300 --> 00:28:05.500
Further, we have Typography Palette.

00:28:05.520 --> 00:28:08.630
This provides access to the
various font features that are

00:28:08.630 --> 00:28:10.920
not default and are very sensible.

00:28:11.010 --> 00:28:15.800
Zafino is a very pretty font
that we install with Mac OS X,

00:28:15.800 --> 00:28:19.260
but it has a lot of features that you
can't get to right on the surface.

00:28:19.290 --> 00:28:24.020
If you implement support
for the Typography Palette,

00:28:24.090 --> 00:28:28.010
you can get access to
specialized ligatures,

00:28:29.640 --> 00:28:36.880
Ornaments, stylistic variants,
old style figures, small caps,

00:28:36.890 --> 00:28:38.900
a whole bunch of works.

00:28:39.810 --> 00:28:46.580
Japanese fonts even have a lot more
to offer in this typographic palette.

00:28:46.580 --> 00:28:48.990
For example, Hiragino,
one of the Japanese fonts

00:28:49.030 --> 00:28:51.320
we ship with the system,
has many features.

00:28:51.320 --> 00:28:54.300
You can see this is a huge palette here.

00:28:54.300 --> 00:28:56.840
There's support for
Japanese features like kana widths,

00:28:56.840 --> 00:29:00.410
where you can have full width,
half width, or proportional widths

00:29:00.490 --> 00:29:01.940
for kana characters.

00:29:01.940 --> 00:29:06.580
There's also support for stylistic
variants and other features

00:29:06.640 --> 00:29:08.750
that the font may provide.

00:29:10.680 --> 00:29:13.100
The last thing I want to show
you is the Character Palette.

00:29:13.100 --> 00:29:15.780
You may have seen this
in other presentations,

00:29:15.780 --> 00:29:15.780
but

00:29:15.910 --> 00:29:19.690
There's direct access to get to
specific characters and to see all

00:29:19.710 --> 00:29:23.410
the characters supported by a font.

00:29:24.010 --> 00:29:25.300
Unfortunately,
we may have a little bit more work

00:29:25.300 --> 00:29:30.000
to do on the Character Palette,
but I think you've seen it before.

00:29:30.040 --> 00:29:38.010
You'll have a window,
access to all the glyphs or all

00:29:38.010 --> 00:29:38.010
the Unicode points of the font,
and you'll be able to see

00:29:38.010 --> 00:29:38.010
everything that's available.

00:29:38.460 --> 00:29:43.460
We hope you like the new user-centric
approach to managing fonts on Mac OS X,

00:29:43.470 --> 00:29:47.720
and we really hope you take two
points home from today's presentation.

00:29:47.720 --> 00:29:51.280
One, we want a user-focused approach.

00:29:51.280 --> 00:29:53.160
To do that,
we ask you to implement one of two

00:29:53.160 --> 00:29:54.820
approaches in your application.

00:29:54.820 --> 00:29:58.850
At a minimum,
respond to ATS font notifications.

00:29:58.910 --> 00:30:02.540
Don't make the user relaunch your
application to see new fonts.

00:30:02.540 --> 00:30:05.700
Or two, even better,
anywhere you would use a font menu,

00:30:06.030 --> 00:30:09.450
provide access to the Fonts Panel so
we can have a standard user interface

00:30:09.730 --> 00:30:11.920
for fonts across the entire system.

00:30:12.010 --> 00:30:12.930
Thank you.

00:30:12.960 --> 00:30:14.040
I'd now like to invite
Robin back to stage to finish

00:30:14.120 --> 00:30:14.930
the rest of the presentation.

00:30:24.410 --> 00:30:25.700
Thanks, Nathan.

00:30:25.740 --> 00:30:31.010
So you've seen some of the really cool
user-level features that we've been

00:30:31.010 --> 00:30:32.960
working on for Mac OS X in Panther.

00:30:35.040 --> 00:30:36.450
So let me recap.

00:30:36.550 --> 00:30:38.380
This is the second part
of the presentation.

00:30:38.580 --> 00:30:41.670
This is where I go into what you
can do in your application software

00:30:41.690 --> 00:30:44.530
to take advantage of some of the
features that we've implemented

00:30:44.600 --> 00:30:49.080
and also to implement newer,
cooler features in your applications.

00:30:49.080 --> 00:30:53.560
So if there's just two things you're
going to take away from this presentation

00:30:53.610 --> 00:30:57.620
and you go back home from WWDC and
implement in your applications,

00:30:57.620 --> 00:31:00.740
it's, as Nathan pointed out,
the first two items up here.

00:31:01.120 --> 00:31:04.270
One, add support for the
standard user interface,

00:31:04.270 --> 00:31:09.010
i.e., the fonts window or the
Font Panel if you're old school like me.

00:31:09.020 --> 00:31:15.750
Also, add support, number two,
for handling not font notifications.

00:31:18.370 --> 00:31:22.190
This will allow you to make sure that
your applications are as responsive

00:31:22.190 --> 00:31:27.200
as possible to any changes in the
font registry that the user initiates

00:31:27.200 --> 00:31:29.560
or other applications trigger.

00:31:29.970 --> 00:31:34.400
I'll also cover some lower level
topics that are of interest to you.

00:31:34.430 --> 00:31:37.620
The third item is particularly
important because people have asked.

00:31:37.770 --> 00:31:42.330
We have a number of different
font referencing systems

00:31:42.330 --> 00:31:44.720
in both Carbon and Cocoa.

00:31:44.880 --> 00:31:50.530
And I'll go into detail about how you
can interact with the font system,

00:31:50.690 --> 00:31:54.780
the ATS font system,
which underlies everything,

00:31:54.780 --> 00:31:54.920
and take advantage of those
features within those layers.

00:31:55.070 --> 00:31:59.460
I'll also go into some more detail
about specifics within ATS itself,

00:31:59.500 --> 00:32:03.950
such as getting access or managing
the contents of the font registry,

00:32:04.220 --> 00:32:06.840
getting access to
information stored within it,

00:32:06.960 --> 00:32:12.910
and querying the font rasterizers
for information specific to glyphs.

00:32:15.890 --> 00:32:19.560
Okay, so, as I said,
one of the key things we're asking you

00:32:19.560 --> 00:32:21.600
to do is adopt a standard user interface.

00:32:21.600 --> 00:32:25.040
Now, if you use Cocoa,
you get a lot of that for free.

00:32:25.040 --> 00:32:28.160
In fact, you get most of that for free,
as Nathan pointed out.

00:32:28.190 --> 00:32:32.630
But within Carbon applications,
you still need to do some amount of work.

00:32:32.690 --> 00:32:34.820
It's not too bad, in fact.

00:32:34.890 --> 00:32:37.520
If you look up here,
I've encapsulated the main

00:32:37.820 --> 00:32:39.360
work that you need to do.

00:32:39.360 --> 00:32:42.980
In fact, the first one's so easy,
I don't even have to make a slide for it.

00:32:43.220 --> 00:32:45.620
If you have a standard,
if you're using the

00:32:45.620 --> 00:32:49.230
standard Carbon event-based
application event handler,

00:32:49.230 --> 00:32:52.770
all you have to do is add a
menu item that triggers off

00:32:52.770 --> 00:32:57.940
of that standard command ID,
which is to show and hide the Font Panel.

00:32:57.940 --> 00:33:00.480
Once that's in place, you're done.

00:33:00.480 --> 00:33:04.450
Anytime the user selects that menu item,
it'll switch between the two

00:33:04.550 --> 00:33:07.730
different states for showing
and hiding the Font Panel,

00:33:07.740 --> 00:33:12.980
and it will initiate the Font Panel code,
pull it in, instantiate it, and show it.

00:33:13.340 --> 00:33:15.440
on screen for you.

00:33:16.140 --> 00:33:18.590
The other three items I'll go
into a little bit more detail

00:33:18.740 --> 00:33:22.400
in the next couple of slides,
but they include support for handling

00:33:22.510 --> 00:33:27.000
font selection events that come from
the Font Panel to your application.

00:33:27.000 --> 00:33:30.910
So that includes whenever a user
changes the state of the Font Panel,

00:33:30.960 --> 00:33:35.000
you get a notification about that
through a standard Carbon event.

00:33:35.260 --> 00:33:39.000
Similarly, if somehow the state of
your document changes,

00:33:39.000 --> 00:33:42.410
for example, if a user clicks through and
sets the cursor in different

00:33:42.550 --> 00:33:46.540
locations within your document,
you want the Font Panel to

00:33:46.640 --> 00:33:48.860
reflect those changes and sync up.

00:33:48.860 --> 00:33:53.000
And so there is an API to
allow you to do that.

00:33:53.120 --> 00:33:56.830
And then finally, the Font Panel,
as you can tell,

00:33:56.920 --> 00:33:59.820
is specific to the current user focus.

00:34:00.000 --> 00:34:05.000
So what you want to do is if a user
switches between different windows,

00:34:05.000 --> 00:34:07.700
you want to be able to notify
the Font Panel that something

00:34:07.810 --> 00:34:11.390
has changed and that it should
pay attention and also notify a

00:34:11.420 --> 00:34:14.360
different window or event reference.

00:34:16.090 --> 00:34:20.570
So first off,
handling font selection events is

00:34:20.570 --> 00:34:26.750
straightforward and it's built in and
integrated with the Carbon Event System.

00:34:26.950 --> 00:34:31.500
All you need to do is handle the
standard font selection event.

00:34:31.580 --> 00:34:36.070
It's of the event class fonts,
and we have a specific event

00:34:36.210 --> 00:34:38.630
type called font selection.

00:34:39.280 --> 00:34:42.590
Within that event,
you can pull out the parameters

00:34:42.700 --> 00:34:46.980
related to that event using the
standard Carbon event calls,

00:34:47.020 --> 00:34:50.710
and we provide information on the
current state of the Font Panel.

00:34:50.870 --> 00:34:55.410
So originally,
it was mainly the typeface family,

00:34:55.460 --> 00:35:00.170
the font or the typeface,
and the size that was important.

00:35:00.270 --> 00:35:02.510
Now as you can see,
we've added a bunch of additional

00:35:02.600 --> 00:35:06.200
new features with Panther,
such as the typography palette,

00:35:06.200 --> 00:35:12.390
and there's other features that
are related to stylistic effects,

00:35:12.550 --> 00:35:16.200
such as handling
strikethroughs and underlines,

00:35:16.200 --> 00:35:24.190
and other cooler effects that you might
not have been able to get natively

00:35:24.190 --> 00:35:24.190
within the font or on previous systems.

00:35:24.320 --> 00:35:28.300
So that information is stored within a
dictionary that gets passed back through

00:35:28.300 --> 00:35:33.950
the Carbon event that you can also parse
and grab standard pieces of information.

00:35:34.080 --> 00:35:38.140
So the typography,
the information about the typographic

00:35:38.150 --> 00:35:44.010
features are actually stored,
for example, as a ATSU style attribute,

00:35:44.100 --> 00:35:47.880
ATSUI style attribute,
that you can then pass to the ATSUI text

00:35:47.880 --> 00:35:51.760
system in Carbon to render appropriately.

00:35:51.890 --> 00:35:55.570
Similarly, we've added support for
the text style information,

00:35:55.650 --> 00:35:58.040
such as the strikethroughs,
the underlines,

00:35:58.090 --> 00:36:00.990
and the other cool features.

00:36:01.710 --> 00:36:04.810
There's one more thing that's pretty
cool is that we also include information

00:36:05.130 --> 00:36:06.980
about multiple master variations.

00:36:06.980 --> 00:36:09.980
So you didn't get a
chance to see it here,

00:36:09.980 --> 00:36:11.880
but if you install a
multiple master font,

00:36:11.880 --> 00:36:15.850
you can use the typography palette
to go through all the different axes

00:36:15.890 --> 00:36:20.060
in a multiple master font and take
advantage of those cool features.

00:36:20.420 --> 00:36:24.250
In fact, the Apple standard font now,
Myriad,

00:36:24.250 --> 00:36:27.450
is provided as a multiple master font.

00:36:27.450 --> 00:36:33.530
So I take advantage of that personally
all the time on my system right now.

00:36:35.950 --> 00:36:42.180
Okay, so when you set the font selection
through either changes in the cursor

00:36:42.180 --> 00:36:46.190
position or the user uses some other
mechanism in your application to change

00:36:46.190 --> 00:36:52.520
the setting of the font in your document,
what you need to do is provide

00:36:52.520 --> 00:36:56.440
notification back to the
Font Panel that something has changed.

00:36:57.100 --> 00:37:00.800
The way you do this is you use
the standard HIToolbox function

00:37:01.210 --> 00:37:03.270
to get the target event ref.

00:37:03.270 --> 00:37:06.480
This is a new data type that's available.

00:37:06.480 --> 00:37:10.510
This is what's used by the Font Panel,
and in its function to set the

00:37:11.050 --> 00:37:16.630
information for the current selection,
you pass the target event ref

00:37:16.710 --> 00:37:21.680
and an array of data types that
are specific to the text system

00:37:21.680 --> 00:37:24.400
that you're currently using.

00:37:24.400 --> 00:37:26.720
So, for example, you can pass in.

00:37:27.100 --> 00:37:31.180
An array of Atsui style
objects that correspond to the

00:37:31.230 --> 00:37:32.700
current selection of your text.

00:37:32.750 --> 00:37:35.850
It might actually just be one
if it's only a single style run,

00:37:35.870 --> 00:37:36.920
or it could be multiple ones.

00:37:36.960 --> 00:37:40.180
Once the Font Panel gets it,
it parses through that and it

00:37:40.180 --> 00:37:42.020
sets its state accordingly.

00:37:42.080 --> 00:37:44.670
So, for example,
if you had two style runs that

00:37:44.670 --> 00:37:47.890
had like Helvetica as the family,
but maybe bold and italic,

00:37:47.900 --> 00:37:51.220
you'll see that reflected
accordingly in the Font Panel,

00:37:51.220 --> 00:37:57.000
where the family will be set to Helvetica
with the style or typeface information.

00:37:57.140 --> 00:38:00.440
left blank to indicate
multiple selection.

00:38:01.460 --> 00:38:08.230
Similarly, we also support passing in
Quickdraw text information,

00:38:08.230 --> 00:38:11.220
which consists of the
traditional Quickdraw family

00:38:11.770 --> 00:38:14.350
name and the style bit array.

00:38:18.390 --> 00:38:21.730
Okay, so when users switch between
windows on your application,

00:38:21.730 --> 00:38:26.190
you need to notify the
Font Panel that that's of the change.

00:38:26.190 --> 00:38:31.520
And so within your event handler,
what you want to do is provide

00:38:31.620 --> 00:38:36.380
support for the standard Carbon event
that notifies you that the window

00:38:36.380 --> 00:38:40.680
focus has changed or that the
window focus has been relinquished.

00:38:40.700 --> 00:38:44.010
And all you have to do at that
point is call that same function

00:38:44.100 --> 00:38:50.030
to set the state of the Font Panel,
but just pass it a null event target ref.

00:38:50.170 --> 00:38:52.800
What that does is it resets
the Font Panel so it knows it

00:38:52.800 --> 00:38:57.170
doesn't need to send events out
to the previous window anymore,

00:38:57.220 --> 00:38:59.450
and it can clear its state.

00:38:59.970 --> 00:39:03.980
Usually what happens right after that
is the user has selected another window,

00:39:03.990 --> 00:39:08.890
and you get a window
focus acquired event.

00:39:08.970 --> 00:39:11.720
When you handle that event,
you basically do the same thing.

00:39:11.720 --> 00:39:15.420
You can pull out the window
reference from the event parameters,

00:39:15.560 --> 00:39:20.630
pull out the target event ref from that,
and then pass that information,

00:39:20.660 --> 00:39:23.840
plus any additional style
information that you have,

00:39:23.890 --> 00:39:27.990
to the Font Panel to indicate the
new selection within the new window.

00:39:29.360 --> 00:39:30.600
Okay, so that was it.

00:39:30.640 --> 00:39:33.250
That's all you have to do to
support the font window within

00:39:33.280 --> 00:39:35.300
your Carbon applications.

00:39:35.440 --> 00:39:38.420
So next, handling font notifications.

00:39:38.450 --> 00:39:40.260
That's the other key thing
I'd like for you to remember

00:39:40.370 --> 00:39:42.060
from this particular session.

00:39:42.090 --> 00:39:44.780
And let me go into some
more details on that.

00:39:46.980 --> 00:39:50.570
What handling font notification
does for you is it allows your

00:39:50.570 --> 00:39:55.710
applications to be much more responsive
to changes that users do or other

00:39:55.710 --> 00:40:00.270
applications do to the state of
the fonts that are in their library.

00:40:00.870 --> 00:40:04.000
So as Nathan kept pointing out,
you don't have to shut

00:40:04.080 --> 00:40:06.060
down your application,
or your users don't have to

00:40:06.060 --> 00:40:08.510
shut down your application,
just to be able to get a new

00:40:08.630 --> 00:40:11.700
font that's been dropped into
one of their fonts folders.

00:40:11.760 --> 00:40:16.120
That's a big thing, and we need your help
to be able to do that.

00:40:16.850 --> 00:40:20.230
Secondly, and I won't go into much
more detail here today,

00:40:20.310 --> 00:40:23.710
but it bears mentioning,
you can also send notifications

00:40:23.710 --> 00:40:28.060
to the font server if,
for example, your application installs

00:40:28.060 --> 00:40:30.360
fonts programmatically using,
let's say,

00:40:30.360 --> 00:40:34.260
the file manager calls or standard
Unix file system calls that pass

00:40:34.530 --> 00:40:36.580
underneath the radar of the system.

00:40:36.880 --> 00:40:40.480
We've got hooks into places
like the finder that let us

00:40:40.480 --> 00:40:43.880
know when changes occur within
the standard font directories.

00:40:43.880 --> 00:40:47.360
But if your application, for example,
at launch time installs

00:40:47.370 --> 00:40:50.710
application-specific fonts,
this is a key way to actually

00:40:50.710 --> 00:40:54.050
notify the font system that
something else has changed.

00:40:54.060 --> 00:40:56.470
And what we will do is
we'll scan the directory,

00:40:56.470 --> 00:40:59.260
identify those changes,
and then do a broadcast out to

00:40:59.260 --> 00:41:02.990
all the clients who are interested
and have subscribed for changes.

00:41:05.530 --> 00:41:08.500
So getting back to the first point,
in order to make your

00:41:08.500 --> 00:41:12.170
applications more responsive,
all you have to do is implement

00:41:12.170 --> 00:41:16.210
one callback function to
handle the notification.

00:41:17.250 --> 00:41:21.000
What you next have to do is basically
register it with the system,

00:41:21.000 --> 00:41:22.100
and you're done.

00:41:22.150 --> 00:41:26.740
All you have to do is call the standard
ATS font notification subscribe function,

00:41:26.740 --> 00:41:28.400
pass in your callback.

00:41:28.440 --> 00:41:31.190
You can also pass in a
refcon if you want to,

00:41:31.190 --> 00:41:35.220
so you can get additional data
into your callback function.

00:41:35.250 --> 00:41:37.910
But otherwise, that's all it takes.

00:41:40.340 --> 00:41:43.430
When you want to deregister,
it's not required,

00:41:43.430 --> 00:41:47.040
but if you want to get rid of
it before your app shuts down,

00:41:47.180 --> 00:41:52.260
you can certainly do that with a
similar function in the ATS font API.

00:41:54.730 --> 00:41:56.760
Okay, so the next topic.

00:41:56.800 --> 00:41:59.600
I'll be talking about how to
exchange data back and forth with

00:41:59.600 --> 00:42:02.370
the other components in the system.

00:42:04.160 --> 00:42:06.600
First and foremost,
the easiest thing to remember

00:42:06.600 --> 00:42:10.260
about exchanging data with
Cocoa and the underlying Quartz

00:42:10.310 --> 00:42:15.230
system is that fonts are uniquely
identified by PostScript name.

00:42:15.230 --> 00:42:21.650
Whenever you get a name
back from within Cocoa,

00:42:21.860 --> 00:42:24.080
it will be generally a PostScript name.

00:42:24.900 --> 00:42:28.600
Similarly, if you want to instantiate
an NSFont instance,

00:42:28.600 --> 00:42:32.130
when you're asked for a name,
you can query the ATS font

00:42:32.130 --> 00:42:37.010
system for the PostScript name,
pass it in along with the size,

00:42:37.010 --> 00:42:40.890
and you can instantiate
an NSFont reference.

00:42:41.860 --> 00:42:45.110
On Panther,
we've also implemented support for a more

00:42:45.570 --> 00:42:48.840
powerful kind of mega NS font reference.

00:42:48.940 --> 00:42:50.880
It's the NS font descriptor.

00:42:50.940 --> 00:42:52.400
You could think of it this way.

00:42:52.450 --> 00:42:55.750
As opposed to just one
instance or one font,

00:42:55.750 --> 00:43:00.340
within the Font Panel,
you can take a whole slice across it and

00:43:00.620 --> 00:43:03.640
actually specify a descriptor for that.

00:43:03.780 --> 00:43:05.860
So here's an example.

00:43:06.450 --> 00:43:10.350
You can actually specify an NSFont
descriptor just by the family name,

00:43:10.550 --> 00:43:13.620
and that will include all the
fonts that belong within that

00:43:13.620 --> 00:43:15.250
family as one descriptor.

00:43:15.300 --> 00:43:18.260
Similarly, you can go off in the other
direction and get more detail.

00:43:18.300 --> 00:43:23.400
You can specify a family or just,
let's say, a font by postscript name,

00:43:23.400 --> 00:43:25.300
and that's more like
the traditional NSFont.

00:43:25.390 --> 00:43:28.000
Or you could go even
further and specify a size,

00:43:28.060 --> 00:43:31.290
which gives you what we
traditionally call a strike.

00:43:31.340 --> 00:43:37.590
It's one specific combination of
font and size within that class.

00:43:38.470 --> 00:43:40.800
There are other attributes
that you can actually pass in,

00:43:40.830 --> 00:43:44.220
as opposed to passing in
a postscript name or other

00:43:44.220 --> 00:43:47.280
information that includes stuff.

00:43:47.280 --> 00:43:52.680
Well, the way it works is with
the font descriptor class,

00:43:52.740 --> 00:43:55.220
you can pass in a
dictionary of attributes.

00:43:55.220 --> 00:44:01.330
And the more information you put in,
the more specific the descriptor will be.

00:44:04.400 --> 00:44:09.560
Okay, so when you work with Carbon,
that's had a longer history

00:44:09.560 --> 00:44:12.280
in terms of the different font
references that are available.

00:44:12.280 --> 00:44:17.340
But one key thing to remember is that
both the ATSUI and Quickdraw components,

00:44:17.410 --> 00:44:22.020
they support identifying fonts
uniquely by the traditional Quickdraw

00:44:22.020 --> 00:44:23.950
font family name and style bit array.

00:44:24.600 --> 00:44:27.780
Note that ATSUI is actually
pretty cool in that it actually

00:44:27.780 --> 00:44:31.500
handles the core graphics,
so the quartz mechanism also.

00:44:31.500 --> 00:44:36.320
So you can handle those font references
using the PostScript name also.

00:44:38.780 --> 00:44:40.940
One thing that we provide
at both the Quick Draw,

00:44:41.100 --> 00:44:43.100
well,
primarily at the Quick Draw layer is

00:44:43.100 --> 00:44:47.070
conversion functions that allow you
to go back and forth between the newer

00:44:47.070 --> 00:44:52.680
ATS font references and the older font
references and font family references.

00:44:52.680 --> 00:44:56.200
One of the key reasons we ask you
to do that is that in the future,

00:44:56.200 --> 00:44:58.860
or also even now,
there are slight differences

00:44:58.860 --> 00:45:00.370
within the data types.

00:45:02.530 --> 00:45:06.320
Some are, there's sign differences,
and there's also size differences.

00:45:06.390 --> 00:45:10.740
Some of the references are 16-bit as
opposed to 32-bit or 32-bit signed.

00:45:10.740 --> 00:45:15.080
What these conversion functions allow
you to do is kind of shield yourself

00:45:15.080 --> 00:45:19.220
from any future changes and also any
potential changes that might happen

00:45:19.220 --> 00:45:24.090
if you simply assign one of the older
data types to the newer ATS font ones.

00:45:24.140 --> 00:45:27.710
So please, avoid typecasting,
use the conversion functions,

00:45:27.740 --> 00:45:31.060
avoid direct assignment because
you might get implicit type

00:45:31.060 --> 00:45:32.260
promotion that causes confusion.

00:45:32.280 --> 00:45:34.360
problems with the signage.

00:45:34.430 --> 00:45:36.930
Use the conversion functions.

00:45:39.380 --> 00:45:42.870
Okay, so let me get into some more
details about mucking around with

00:45:42.870 --> 00:45:44.420
the contents of the font registry.

00:45:44.420 --> 00:45:46.710
Now, why would you want to do this?

00:45:46.710 --> 00:45:48.200
Well, think of it this way.

00:45:48.200 --> 00:45:49.340
Here's a typical example.

00:45:49.340 --> 00:45:52.750
You've got a font that you've
licensed with your application,

00:45:52.750 --> 00:45:55.980
you use it in your user interface,
but you don't want to stick

00:45:56.030 --> 00:45:59.410
it for general purpose usage
out in the standard library.

00:45:59.420 --> 00:46:03.810
And so what you can do is you can
actually activate that privately just

00:46:03.950 --> 00:46:08.350
exactly the same way the file system
or the operating system would do,

00:46:08.810 --> 00:46:19.590
but just for your font.

00:46:21.020 --> 00:46:23.230
What I'll be talking about is
giving you a chance to kind of

00:46:23.230 --> 00:46:27.610
hook into that and take advantage
of that also if you're interested.

00:46:29.590 --> 00:46:34.120
So when you activate
and deactivate fonts,

00:46:34.150 --> 00:46:37.720
what we recommend that you do
is pass in a file reference.

00:46:37.750 --> 00:46:39.980
That's really the easiest
way for you to do it,

00:46:40.000 --> 00:46:42.440
mainly because there's a lot
of information there that we

00:46:42.490 --> 00:46:46.700
can actually parse through,
file types, contents of the files,

00:46:46.700 --> 00:46:50.990
even suffixes on the files,
to figure out what exact format it is.

00:46:50.990 --> 00:46:54.380
We can take care of the rest for you,
so you don't have to worry about it.

00:46:54.860 --> 00:46:59.040
Note that up here,
I'm passing in an unspecified format,

00:46:59.140 --> 00:47:01.120
mainly because I'm passing
in a file reference.

00:47:01.120 --> 00:47:04.900
Another cool thing that you can
take advantage of is if you put,

00:47:04.900 --> 00:47:08.630
let's say, your app-specific font
within your bundle someplace,

00:47:08.680 --> 00:47:11.280
maybe within the resource
folder of the bundle,

00:47:11.280 --> 00:47:15.300
you can just pass in a pointer
to the top level of the bundle.

00:47:15.300 --> 00:47:18.830
We'll trundle down through it
recursively and activate any fonts that

00:47:18.960 --> 00:47:20.900
reside in any of the subdirectories.

00:47:23.120 --> 00:47:26.680
Another part of this example is
that I've actually activated the

00:47:26.730 --> 00:47:31.090
font locally so that it's only
available for my application.

00:47:32.500 --> 00:47:36.000
What you get back from this
function is a container reference.

00:47:36.100 --> 00:47:39.500
With this container reference,
you can later deactivate exactly the

00:47:39.500 --> 00:47:44.880
same set of fonts that were stored in
that file or in that directory using

00:47:44.880 --> 00:47:48.000
this function to deactivate the fonts.

00:47:48.090 --> 00:47:51.440
There's one thing that's pretty cool,
though, is that ATS will keep track

00:47:51.440 --> 00:47:54.370
of fonts that are activated
locally within your applications,

00:47:54.530 --> 00:47:56.270
so you don't have to
get rid of it yourself.

00:47:56.400 --> 00:48:00.430
When your app shuts down,
we'll deactivate those fonts for you.

00:48:03.770 --> 00:48:08.210
Okay, so with Panther,
we've provided support for

00:48:08.210 --> 00:48:13.760
additional APIs or classes that
allow you to modify the contents

00:48:13.760 --> 00:48:19.690
and remove and add font collections,
just as the Font Book does.

00:48:20.720 --> 00:48:23.280
In Cocoa,
you simply use the NSFontManager

00:48:23.280 --> 00:48:28.160
class with a variety of new
APIs that are available to do this.

00:48:28.320 --> 00:48:32.210
Similarly, we've implemented support in
Carbon with C callable wrapper

00:48:32.210 --> 00:48:37.750
functions to those same methods that
let you call these functions from

00:48:37.820 --> 00:48:40.240
within your Carbon applications.

00:48:40.400 --> 00:48:42.970
So font collections,
they're identified uniquely by name.

00:48:43.070 --> 00:48:49.190
What you see up on the Font Panel are the
unique names for those font collections.

00:48:49.680 --> 00:48:53.530
Another cool thing is that font
collections go back to those font

00:48:53.670 --> 00:48:56.080
descriptors I described earlier.

00:48:56.200 --> 00:48:59.980
So the same actions that users can do to
kind of grab an instance of a font or,

00:48:59.980 --> 00:49:03.500
you know, a particular font strike,
drag it in and set up a

00:49:03.500 --> 00:49:07.680
font collection entry,
you can do the same thing at this level

00:49:07.740 --> 00:49:10.710
as long as you define a font descriptor.

00:49:12.470 --> 00:49:14.190
Okay, we're almost there.

00:49:14.280 --> 00:49:21.400
I've got two sections describing
how to interact directly

00:49:21.400 --> 00:49:24.110
with the ATS font system.

00:49:25.390 --> 00:49:29.850
The first one, if you notice,
I've badged this with the caches

00:49:29.850 --> 00:49:32.130
entry in the architecture diagram.

00:49:32.130 --> 00:49:36.510
The reason for this is that we've
implemented a number of high-level

00:49:36.510 --> 00:49:40.410
functions that optimize access
to this data through the caching

00:49:40.540 --> 00:49:42.380
system as much as possible.

00:49:42.380 --> 00:49:46.160
So we've identified that you guys
tend to use PostScript names a lot,

00:49:46.230 --> 00:49:50.810
especially with my recommendation on
interacting with the Cocoa Tech system.

00:49:50.810 --> 00:49:52.520
We've got that optimized.

00:49:53.400 --> 00:49:57.390
We also have an optimized function
to get at the file references

00:49:57.430 --> 00:49:59.910
associated with a particular font.

00:49:59.940 --> 00:50:03.410
All of this information is
cached so that you don't have to

00:50:03.410 --> 00:50:06.970
worry about triggering messages,
hitting file system,

00:50:06.970 --> 00:50:10.550
making file system calls,
and potentially even triggering

00:50:10.690 --> 00:50:12.800
font rasterization effort.

00:50:14.510 --> 00:50:18.220
Now, what I'll go into in more detail in
the next two slides are the lower level

00:50:18.220 --> 00:50:21.900
functions that bypass those higher level,
easy to use functions.

00:50:22.020 --> 00:50:25.310
And that includes the function
that lets you kind of go

00:50:25.310 --> 00:50:29.630
straight to the file system,
grab the font data out of those files,

00:50:29.630 --> 00:50:31.350
and parse it yourself.

00:50:31.670 --> 00:50:36.150
I'll also give you some information on
how to enumerate every single font or

00:50:36.170 --> 00:50:41.390
font family within the font registry and
do whatever you want with those entries.

00:50:43.370 --> 00:50:48.480
So when you want to pull out data related
to fonts directly from the file system,

00:50:48.610 --> 00:50:52.130
we provided a couple of
standard functions to do that.

00:50:52.890 --> 00:50:58.120
This one happens to be the
one to get the font table.

00:50:58.210 --> 00:50:59.360
Think of it this way.

00:50:59.450 --> 00:51:05.240
The way we've made a standard format for
the fonts is similar to the way TrueType

00:51:05.280 --> 00:51:07.360
fonts or OpenType fonts are defined.

00:51:07.360 --> 00:51:10.500
They consist of a
directory of font tables,

00:51:10.600 --> 00:51:14.120
each of which contain a
specific class of data.

00:51:14.770 --> 00:51:17.110
So I mentioned earlier in
the presentation that we have

00:51:17.110 --> 00:51:18.450
character mapping tables.

00:51:18.460 --> 00:51:24.140
Those are stored in tables that are
indicated by the CMAP tag or C-M-A-P.

00:51:24.140 --> 00:51:27.660
We also have support for
accessing the glyph data.

00:51:27.660 --> 00:51:32.750
You can access any of the font table
data that's available for these fonts.

00:51:34.540 --> 00:51:37.910
Now the convention is you make an
initial call to these functions,

00:51:37.990 --> 00:51:41.300
either ATS font, get table,
or the directory version.

00:51:41.300 --> 00:51:45.450
You pass it in the font ref and the
tag indicating what data you want,

00:51:45.480 --> 00:51:48.200
and you pass in a null buffer.

00:51:48.200 --> 00:51:50.960
In return,
you get back the length of the data

00:51:50.960 --> 00:51:53.480
that the function will return to you.

00:51:53.480 --> 00:51:55.530
And this is what happens
in the second call.

00:51:55.540 --> 00:51:59.040
In the second call,
you can actually malloc right then and

00:51:59.040 --> 00:52:02.500
there a buffer to hold that data based
on the size you got in the first call.

00:52:03.460 --> 00:52:08.280
Pass in the buffer this time and get it
filled in with the data that you need.

00:52:09.050 --> 00:52:13.390
Now if you have any more questions
about how to process this information,

00:52:13.450 --> 00:52:16.690
it's available in the specs
for the OpenType font format

00:52:16.810 --> 00:52:18.790
and the TrueType font format.

00:52:18.800 --> 00:52:21.460
So as you can see,
this is pretty low-level stuff,

00:52:21.460 --> 00:52:25.100
but for a lot of you out there,
this is your meat and potatoes.

00:52:25.100 --> 00:52:26.460
This is what you want to deal with.

00:52:26.540 --> 00:52:32.740
The other people involved with this
usually use the high-level functions.

00:52:32.740 --> 00:52:36.110
So if you have any requests for us,
we'd be happy to implement it.

00:52:36.710 --> 00:52:39.540
So please, use the bug reporter.

00:52:39.540 --> 00:52:43.210
Let us know what features you'd
like to have that otherwise you'd

00:52:43.290 --> 00:52:46.630
have to go through the lower levels
of the ATS font system to get at.

00:52:49.310 --> 00:52:52.360
Okay, when you enumerate
fonts and font families,

00:52:52.420 --> 00:52:56.080
there's a similar convention,
or there's a standard convention also,

00:52:56.250 --> 00:52:58.200
and they consist of iterator objects.

00:52:58.420 --> 00:53:01.810
Essentially,
all you have to do is create an iterator

00:53:01.810 --> 00:53:04.230
object based on a bunch of criteria.

00:53:04.680 --> 00:53:07.180
Set up a while loop that
calls the iterator object

00:53:07.360 --> 00:53:09.600
for each successive entry.

00:53:09.610 --> 00:53:12.040
And when it's done,
it'll give you a status code back

00:53:12.040 --> 00:53:14.280
indicating that the iteration is done.

00:53:14.280 --> 00:53:17.160
And then finally,
you release the iterator object

00:53:17.160 --> 00:53:20.790
to return the system resources
back to the operating system.

00:53:21.290 --> 00:53:24.360
So some of the different things
you can do with the iterator

00:53:24.610 --> 00:53:26.950
object include filtering them.

00:53:27.050 --> 00:53:32.680
You can pass in any of a variety
of standard predefined filters,

00:53:32.810 --> 00:53:36.640
such as filtering by font
location or by the generation

00:53:36.640 --> 00:53:38.630
in which they got activated.

00:53:38.630 --> 00:53:43.350
So if you want to find out if there
were any fonts that were activated

00:53:43.400 --> 00:53:47.010
after you last checked the registry,
you can check a generation count

00:53:47.010 --> 00:53:48.790
and then filter based on that.

00:53:49.040 --> 00:53:52.520
You can also pass in your own
custom filter function to do

00:53:52.540 --> 00:53:56.200
the filtering yourself based on
whatever criteria you specify.

00:53:58.130 --> 00:54:00.800
And if you notice here,
I'm actually using a similar way to

00:54:00.800 --> 00:54:05.230
restrict or actually in this case,
totally unrestrict the

00:54:05.230 --> 00:54:06.930
scope of the iteration.

00:54:06.950 --> 00:54:11.170
I've chosen a global context with
unrestricted scope so I can see

00:54:11.170 --> 00:54:16.760
every single font available on
the system for all the processes.

00:54:16.850 --> 00:54:19.630
Okay, one last item.

00:54:20.770 --> 00:54:23.370
When you want to access glyph data,
this is where you interact

00:54:23.580 --> 00:54:25.810
directly with the font rasterizers.

00:54:25.910 --> 00:54:30.610
Or, in this particular case,
the ATSUI text system

00:54:31.120 --> 00:54:34.800
eases the burden on you somewhat
and allows you to mimic exactly

00:54:34.800 --> 00:54:39.760
what the ATSUI tech system does,
but gets you back this data directly.

00:54:40.510 --> 00:54:48.530
So it has two functions to access two
different flavors of glyph data format,

00:54:48.530 --> 00:54:52.560
glyph paths in two different formats.

00:54:52.560 --> 00:54:55.990
Essentially,
the glyph paths define the shape of

00:54:56.210 --> 00:54:59.620
the glyphs that you can then pass into,
let's say,

00:54:59.620 --> 00:55:03.360
the court system or draw yourself
directly on screen or manipulate just

00:55:03.360 --> 00:55:06.950
as if it were a regular graphics object.

00:55:08.200 --> 00:55:13.010
Now the ATSUI APIs take advantage of
the higher levels of the ATSUI system,

00:55:13.090 --> 00:55:17.340
so you can pass in information from
a standard ATSUI text layout object.

00:55:17.480 --> 00:55:20.560
So you can take advantage
of how it specifies,

00:55:20.640 --> 00:55:23.580
let's say, a run of characters,
pass that information in,

00:55:23.710 --> 00:55:26.380
and get just the glyph
information for those characters.

00:55:26.800 --> 00:55:30.590
In addition, they match exactly the
way ATSUI would draw it,

00:55:30.750 --> 00:55:35.500
so you can still take advantage of
trying to mimic exactly what ATSUI does,

00:55:35.500 --> 00:55:39.160
but get into the lower layers
of it and directly access the

00:55:39.380 --> 00:55:41.460
font data through these APIs.

00:55:43.560 --> 00:55:46.460
So usually what you do is you
determine what the native glyph data

00:55:46.460 --> 00:55:50.170
format is for a particular font,
and there's an API to do that.

00:55:50.300 --> 00:55:53.890
If you don't do that,
the functions for accessing the

00:55:53.890 --> 00:55:56.920
glyph pass will actually convert
the data accordingly for you.

00:55:57.080 --> 00:56:01.330
So if you ask for quadratic and
you ask to get the glyph data

00:56:01.460 --> 00:56:05.520
for a PostScript font that's
normally defined in cubic data,

00:56:05.570 --> 00:56:08.650
then it will convert it accordingly.

00:56:09.790 --> 00:56:12.610
The other thing that you have to do
is implement a series of callback

00:56:12.610 --> 00:56:18.910
functions that process the standard

00:56:19.120 --> 00:56:22.280
Standard operations that
define the glyph's shape.

00:56:22.540 --> 00:56:25.080
So this includes, for example,
let's say in cubic,

00:56:25.080 --> 00:56:30.680
you have a move to operator,
a line to operator, a curve to operator,

00:56:30.680 --> 00:56:32.000
and a closed path operator.

00:56:32.000 --> 00:56:36.160
The line to operator basically
defines a straight line segment,

00:56:36.170 --> 00:56:39.310
and the curve to defines
any arbitrary curve.

00:56:39.320 --> 00:56:41.860
Okay.

00:56:44.380 --> 00:56:48.560
So just to wrap things up here,
what I've talked about today is

00:56:48.600 --> 00:56:52.680
that there's a lot going on in
the operating system that hides

00:56:52.680 --> 00:56:54.980
the complexity of fonts for you.

00:56:55.390 --> 00:56:56.780
We've implemented a lot of stuff.

00:56:56.910 --> 00:57:01.030
You've seen how the architecture works
and how they interact and how they touch

00:57:01.030 --> 00:57:06.050
on the APIs that you take advantage
of at your level in your software.

00:57:06.690 --> 00:57:11.900
The other thing I've covered is that
if you go away from WWDC and implement

00:57:12.190 --> 00:57:17.430
just these two aspects of the system,
you're going to help us push forward this

00:57:17.430 --> 00:57:21.750
idea of putting the user at the center
and making it so much easier to use their

00:57:21.770 --> 00:57:27.180
fonts and so much powerful that people
will be flocking to your applications.

00:57:27.340 --> 00:57:29.930
So adopt the standard user interface.

00:57:30.180 --> 00:57:31.920
Add support for handling
the fonts window.

00:57:31.920 --> 00:57:33.690
You see how much you'll get with it.

00:57:33.760 --> 00:57:36.340
The typography palette,
the character palette,

00:57:36.390 --> 00:57:39.340
the interaction with FontBook,
and handling support

00:57:39.460 --> 00:57:41.730
for font collections.

00:57:42.610 --> 00:57:45.210
At the very least,
you should also support handling

00:57:45.210 --> 00:57:49.220
font notifications so that your
apps become much more responsive

00:57:49.230 --> 00:57:51.040
to changes in the system.

00:57:53.220 --> 00:57:55.970
There are a couple of related
topics either later on this week

00:57:56.040 --> 00:57:58.020
or that you can review after WWDC.

00:57:58.100 --> 00:58:02.690
It includes the Unicode session
and the Cocoa Text session.

00:58:04.920 --> 00:58:07.240
Our evangelist for this
area is Xavier Legro,

00:58:07.380 --> 00:58:10.890
so you can contact him specifically
about some of those bugs or

00:58:11.040 --> 00:58:14.200
features or new APIs that you like.

00:58:15.200 --> 00:58:17.770
And something that you
guys have been asking for,

00:58:17.900 --> 00:58:20.700
documentation on this part of the system.

00:58:20.910 --> 00:58:24.840
Well, my team has worked really hard this
year to put together the documentation

00:58:24.840 --> 00:58:28.730
with the technical publications people,
and we've got them up there.

00:58:28.730 --> 00:58:29.860
So take a look at them.

00:58:29.860 --> 00:58:31.800
They're really cool.

00:58:32.170 --> 00:58:34.340
There's also related documentation
about the various text

00:58:34.450 --> 00:58:38.640
systems available on Mac OS X,
including Atsui, Cocoa,

00:58:38.710 --> 00:58:43.150
and there's also documentation
for the legacy font manager

00:58:43.150 --> 00:58:44.560
APIs available in Quickdraw.
WEBVTT

00:00:29.080 --> 00:00:31.740
Thank you all for coming out
here for this last session.

00:00:31.740 --> 00:00:34.970
You were only an hour and
a half from the margaritas.

00:00:34.990 --> 00:00:38.980
I'm here today to talk
to you about CFNetwork.

00:00:40.800 --> 00:00:42.500
And this is roughly what
we're going to cover today.

00:00:42.500 --> 00:00:46.110
We're going to start out with an
overview that shows how CFNetwork

00:00:46.110 --> 00:00:48.740
fits into the system as a whole.

00:00:48.740 --> 00:00:52.860
And then we're going to go through the
basics of how you use a CFNetwork object.

00:00:52.860 --> 00:00:55.100
All of the objects are used in
essentially the same manner,

00:00:55.100 --> 00:00:57.500
and we're just going to walk
through that basic paradigm.

00:00:58.570 --> 00:01:00.570
After that,
we're going to start looking at the

00:01:00.570 --> 00:01:02.720
actual objects provided by CFNetwork.

00:01:02.720 --> 00:01:05.280
Those can be broken down
into two categories.

00:01:05.280 --> 00:01:09.820
First, we have some basic abstractions,
and that's CFHost and CFSocketStream.

00:01:09.820 --> 00:01:13.430
And then we have some
protocol implementations,

00:01:13.430 --> 00:01:15.820
FTP, HTTP, and Rendezvous.

00:01:15.820 --> 00:01:20.400
So with that,
let's get started with the overview.

00:01:23.360 --> 00:01:26.060
So those are the questions we're
going to try to answer today.

00:01:26.080 --> 00:01:27.290
What is CFNetwork?

00:01:27.570 --> 00:01:29.600
How does it fit into the stack?

00:01:29.600 --> 00:01:31.290
And when should you use it?

00:01:31.300 --> 00:01:33.860
I know with the introduction
of Safari that we've been

00:01:33.860 --> 00:01:37.700
talking about a lot of different
internet technologies here.

00:01:37.930 --> 00:01:39.330
And CFNetwork's one of those.

00:01:39.360 --> 00:01:41.000
So how do you choose between them?

00:01:41.000 --> 00:01:45.500
How do you decide to use CFNetwork
instead of one of the other libraries?

00:01:48.080 --> 00:01:51.780
First and foremost,
CFNetwork is a library that abstracts

00:01:51.780 --> 00:01:54.380
several basic network protocols.

00:01:54.550 --> 00:01:57.060
And I've listed those protocols here.

00:01:57.060 --> 00:01:59.820
DNS host resolution,
that's new in Panther.

00:01:59.820 --> 00:02:02.190
FTP, also new in Panther.

00:02:02.190 --> 00:02:06.080
HTTP, rendezvous, and sockets,
basic sockets.

00:02:06.120 --> 00:02:10.640
The APIs are designed in the
same style as core foundation.

00:02:10.640 --> 00:02:13.900
In fact, all of our objects are
exported as CF types,

00:02:13.900 --> 00:02:16.270
so you're going to retain and
release them the same way you would

00:02:16.270 --> 00:02:18.820
retain and release any CF object.

00:02:18.820 --> 00:02:22.420
And further,
those APIs all support asynchrony.

00:02:22.700 --> 00:02:25.420
This is the other main
purpose of CFNetwork.

00:02:25.480 --> 00:02:29.050
It's to take your networking
inputs and provide the network

00:02:29.110 --> 00:02:34.560
events to you using the run loop,
using the same asynchrony model through

00:02:34.560 --> 00:02:37.740
which your user events are coming in.

00:02:40.500 --> 00:02:43.200
So what are the goals for CFNetwork?

00:02:43.390 --> 00:02:45.760
First and foremost, this is a power API.

00:02:46.030 --> 00:02:51.390
We are trying to expose the full power
of the underlying protocols to you.

00:02:51.540 --> 00:02:57.180
We're trying to also get strong
integration between the CFNetwork library

00:02:57.290 --> 00:03:00.630
and the other libraries on the system,
particularly, like I said,

00:03:00.760 --> 00:03:03.640
with the run loop,
so that you can get your network events

00:03:03.980 --> 00:03:08.330
in the same manner as all the other
events happening in your program.

00:03:09.260 --> 00:03:14.930
Part of being a Power API is
providing high performance.

00:03:15.010 --> 00:03:17.950
So one of the other goals we have
is to make sure that our objects

00:03:18.130 --> 00:03:21.800
perform with very nearly the same
performance you would get if you chose

00:03:21.800 --> 00:03:24.550
to write directly to the socket layer.

00:03:24.780 --> 00:03:28.400
But one of the consequences of
choosing to be this power API is

00:03:28.400 --> 00:03:31.140
that we're not going to protect
you from any of the details.

00:03:31.270 --> 00:03:36.220
This is not a convenience API the
way some of the other APIs you've

00:03:36.220 --> 00:03:38.460
heard about this week are.

00:03:38.590 --> 00:03:41.120
So you need to know how
to use the run loop.

00:03:41.360 --> 00:03:46.010
You need to know the basics of the
protocol that you're taking advantage of.

00:03:48.090 --> 00:03:53.000
So where does CFNetwork fit into the
overall architecture of Mac OS X?

00:03:53.000 --> 00:03:57.000
You've seen this diagram probably
a few zillion times by now.

00:03:57.000 --> 00:04:01.190
Darwin, the Core OS at the bottom,
applications all the way at the top,

00:04:01.190 --> 00:04:03.990
a couple levels of
libraries in the middle.

00:04:04.560 --> 00:04:08.260
And if we look at the networking
concepts and the networking APIs,

00:04:08.280 --> 00:04:10.040
this is sort of how it breaks down.

00:04:10.090 --> 00:04:13.820
BSD Sockets is what comes
from the low-level CoreOS.

00:04:13.960 --> 00:04:18.950
CFNetwork is the first level of
abstraction above raw sockets.

00:04:19.060 --> 00:04:23.300
And then all of the other stronger,
higher-level APIs are

00:04:23.300 --> 00:04:24.800
built on top of CFNetwork.

00:04:24.800 --> 00:04:28.660
So that includes NSURL and the WebKit,
for instance.

00:04:28.820 --> 00:04:30.470
And then the applications sit above that.

00:04:30.500 --> 00:04:33.640
And I've listed here just five of
the clients that I know of that take

00:04:33.670 --> 00:04:39.340
advantage of this networking stack:
iCal and iSync, Safari, of course, Mail,

00:04:39.340 --> 00:04:40.910
and iChat.

00:04:43.490 --> 00:04:46.800
So when should you choose to
use CFNetwork instead of one

00:04:46.800 --> 00:04:49.920
of those higher libraries,
instead of going to the

00:04:50.050 --> 00:04:52.700
NSURL APIs or the WebKit APIs?

00:04:52.830 --> 00:04:57.290
Well, use CFNetwork if you particularly
need an API that is that low

00:04:57.340 --> 00:04:59.800
level and high performing.

00:04:59.800 --> 00:05:02.300
So you would go there when
you need extra control,

00:05:02.300 --> 00:05:06.450
like needing control of exactly when the
bytes are going to come off the socket,

00:05:06.450 --> 00:05:09.950
or exactly when the bytes
are written to the socket.

00:05:10.620 --> 00:05:14.670
Use CFNetwork also if you need
detailed control of the protocol stack.

00:05:14.980 --> 00:05:19.410
The higher level APIs often
expose protocol details so that

00:05:19.410 --> 00:05:23.800
you can tweak and change things,
but that can become cumbersome

00:05:23.800 --> 00:05:26.080
if you're ending up constructing,
for instance,

00:05:26.080 --> 00:05:28.160
an HTTP request in its entirety.

00:05:28.200 --> 00:05:32.020
Sometimes it's much easier
to drop to CFNetwork and just

00:05:32.020 --> 00:05:34.140
construct it all yourself.

00:05:34.940 --> 00:05:38.600
And also, use CFNetwork if you want
to avoid higher linkage.

00:05:38.710 --> 00:05:40.040
You don't want to bring in the app kit.

00:05:40.150 --> 00:05:44.450
You don't want to bring in, in fact,
anything above that core services layer.

00:05:44.740 --> 00:05:47.960
Well, then CFNetwork can help you out.

00:05:48.020 --> 00:05:51.830
But by all means, use the higher APIs if
that fits your application.

00:05:51.890 --> 00:05:54.660
The higher APIs do more things for you.

00:05:54.660 --> 00:05:56.000
They're more convenient.

00:05:56.100 --> 00:05:57.940
They're easier to use.

00:05:58.140 --> 00:06:03.630
They provide a lot of advanced
features that we do not at this layer.

00:06:05.890 --> 00:06:09.210
So that's sort of when you would go
down to the level of using CFNetwork.

00:06:09.310 --> 00:06:12.580
But suppose you're a Unix programmer and
you've been working with raw sockets.

00:06:12.600 --> 00:06:15.100
How do you decide to climb
to the CFNetwork layer?

00:06:16.750 --> 00:06:19.220
Well,
the first and largest reason is because

00:06:19.220 --> 00:06:20.930
you want that run-loop integration.

00:06:21.040 --> 00:06:23.690
You don't want to deal with
handling the select loop yourself.

00:06:23.820 --> 00:06:26.690
You'd rather be able to integrate
with your main event loop,

00:06:27.050 --> 00:06:31.660
let CFNetwork do the work of finding
out when the socket has data available,

00:06:31.660 --> 00:06:36.180
and inform you in a way
that fits seamlessly into a

00:06:36.180 --> 00:06:39.330
regular application context.

00:06:39.970 --> 00:06:45.110
Another reason we see why people come up
to using CFNetwork is because although

00:06:45.150 --> 00:06:48.090
sockets work perfectly fine for them,
they discover that suddenly they

00:06:48.090 --> 00:06:52.150
want to secure the socket and
add SSL encryption over the top.

00:06:52.290 --> 00:06:57.510
Well, unless you want to implement an
SSL stack or get to know an SSL library,

00:06:57.770 --> 00:06:59.670
CFNetwork might help you out there.

00:06:59.930 --> 00:07:06.200
It's a simple single option to
turn on SSL on any given socket.

00:07:07.430 --> 00:07:09.640
Finally,
if you want an object abstraction,

00:07:09.640 --> 00:07:10.930
we can provide that for you.

00:07:10.980 --> 00:07:12.880
That's what we get from Core Foundation.

00:07:12.880 --> 00:07:17.790
That's just a simple reference
counting CF-type abstraction.

00:07:18.410 --> 00:07:21.950
Finally,
use CFNetwork if you know the protocol.

00:07:22.020 --> 00:07:25.280
You know HTTP, you know how to use it,
but you just don't want

00:07:25.290 --> 00:07:26.440
to write the parse engine.

00:07:26.440 --> 00:07:29.980
You don't want to write the
code that does all the details

00:07:29.980 --> 00:07:31.800
of talking the protocol itself.

00:07:35.870 --> 00:07:39.690
So when should you not use CFNetwork?

00:07:39.830 --> 00:07:41.940
Well, use NSURL connection.

00:07:41.960 --> 00:07:48.060
That's the new URL loading API that
was introduced with the Safari SDK.

00:07:48.200 --> 00:07:51.850
If you need one of these other functions,
or one of these other features,

00:07:52.020 --> 00:07:56.350
first of all,
if you want a more convenient fire

00:07:56.790 --> 00:08:01.840
and forget just get me the data API,
NSURL connection is better

00:08:01.840 --> 00:08:01.840
suited to your needs.

00:08:02.040 --> 00:08:05.240
You'll also have to use
NSURL connection if you're looking

00:08:05.240 --> 00:08:08.070
to handle any arbitrary URL.

00:08:08.200 --> 00:08:12.860
The NSURL connection
API is protocol agnostic.

00:08:13.060 --> 00:08:15.770
You don't have to know what
kind of URL you're working with.

00:08:16.010 --> 00:08:17.050
CFNetwork is not.

00:08:17.160 --> 00:08:21.990
You must know in advance that
you're doing HTTP or FTP.

00:08:22.610 --> 00:08:25.200
If you need to add your own
protocol implementation,

00:08:25.200 --> 00:08:28.820
if you've got to have a way
to implement Gopher and plug

00:08:28.820 --> 00:08:32.370
it into the existing stack,
that also happens at the

00:08:32.460 --> 00:08:34.500
NSURL connection layer.

00:08:36.360 --> 00:08:39.050
Finally,
I've just listed a couple of major

00:08:39.050 --> 00:08:44.240
features of the URL connection layer:
caching and authentication.

00:08:44.240 --> 00:08:47.890
We have the raw hooks inside
CFNetwork to add authentication.

00:08:47.890 --> 00:08:50.290
We're going to look at that today.

00:08:50.300 --> 00:08:53.370
But NSURL connection
goes way beyond that,

00:08:53.370 --> 00:08:57.800
to being able to manage your
credential store and cleanly inform

00:08:57.910 --> 00:09:02.410
you when authentication failures
occur and let you intervene in

00:09:02.410 --> 00:09:05.300
the whole authentication process.

00:09:05.440 --> 00:09:10.820
It also adds sophisticated caching
so that as URLs are accessed,

00:09:10.840 --> 00:09:15.780
you can store those on disk
or in memory automatically.

00:09:18.840 --> 00:09:21.210
So now I'm going to go on to
talk a little bit about the

00:09:21.210 --> 00:09:24.330
basic usage of CFNetwork objects.

00:09:24.640 --> 00:09:28.280
They all follow the same basic model,
and not too surprisingly,

00:09:28.280 --> 00:09:33.740
they all start with creating the
CFNetwork object you intend to use.

00:09:33.740 --> 00:09:37.600
Once you've created the object,
you set yourself up as a client.

00:09:37.600 --> 00:09:39.410
All of these APIs are asynchronous.

00:09:39.410 --> 00:09:42.250
That means they're going to
go out and monitor something,

00:09:42.250 --> 00:09:45.560
and when something interesting happens,
they're going to turn

00:09:45.560 --> 00:09:47.240
around and inform you.

00:09:47.240 --> 00:09:50.220
Well, they inform you by sending
your client a callback,

00:09:50.220 --> 00:09:52.470
and when you set yourself
up as the client,

00:09:52.640 --> 00:09:54.570
you're saying, "Hey, talk to me."

00:09:55.220 --> 00:09:58.700
Once that's done,
the CFNetwork object needs to know

00:09:58.700 --> 00:10:02.000
what thread it should talk to you on.

00:10:02.150 --> 00:10:06.100
We do that by,
you give the CFNetwork object

00:10:06.100 --> 00:10:10.300
that information by scheduling the
object on a particular run loop.

00:10:10.420 --> 00:10:13.410
Remember, with CF run loops, one thread,
one run loop.

00:10:13.510 --> 00:10:15.380
It's a one-to-one correspondence.

00:10:15.480 --> 00:10:18.890
So, when you schedule on a run loop,
effectively what you're saying is,

00:10:18.890 --> 00:10:22.490
"This is the thread
I want my callback on."

00:10:24.440 --> 00:10:27.900
Once that's done,
you start the CFNetwork object.

00:10:27.980 --> 00:10:30.050
You just tell it,
go and do the thing that

00:10:30.120 --> 00:10:32.230
I created you to do.

00:10:32.890 --> 00:10:34.960
And then you just sit back and wait.

00:10:35.070 --> 00:10:36.600
You need to keep the run loop running.

00:10:36.760 --> 00:10:40.430
If the run loop's not running,
then the CFNetwork object has

00:10:40.430 --> 00:10:45.040
no way to get time from the CPU,
and it also has no way to call you back.

00:10:45.170 --> 00:10:48.080
Most of the time,
you don't have to do that yourself,

00:10:48.250 --> 00:10:51.940
because both AppKit and HLTB keep
the run loop running for you.

00:10:52.120 --> 00:10:54.920
But if you're on a secondary thread,
or if you're not linking

00:10:54.920 --> 00:10:57.010
one of the GUI frameworks,
you're going to need

00:10:57.080 --> 00:10:59.440
to call CFRunLoop run,
or one of its variants,

00:10:59.440 --> 00:11:01.720
to get the run loop going.

00:11:02.050 --> 00:11:04.490
And eventually your
callback will be called.

00:11:04.560 --> 00:11:09.480
At that point, you find out what happened
and you field the results.

00:11:10.290 --> 00:11:12.480
Finally, when you're done with
the CFNetwork object,

00:11:12.580 --> 00:11:15.510
you need to clean it
up and dispose of it.

00:11:18.500 --> 00:11:22.000
All the different CFNetwork objects
available follow this model.

00:11:22.000 --> 00:11:24.490
In fact,
several of the other objects inside

00:11:24.540 --> 00:11:28.900
core foundation and system configuration
also follow this basic model.

00:11:28.900 --> 00:11:36.220
So I think it'll pay off to
become familiar with it and

00:11:36.220 --> 00:11:36.220
understand how it works.

00:11:37.000 --> 00:11:40.070
And now I'm going to take you
through an example of that model.

00:11:40.090 --> 00:11:42.960
We're going to talk about CFHost here,
since it's one of the

00:11:43.010 --> 00:11:44.820
new objects in Panther.

00:11:44.820 --> 00:11:48.800
CFHost allows you to do an
asynchronous DNS lookup.

00:11:48.800 --> 00:11:54.760
And here what we're going to do is look
up the IP address for www.apple.com.

00:11:54.760 --> 00:12:01.500
We start out by creating the object,
CFHost create with name,

00:12:01.500 --> 00:12:01.890
and we tell it what host
name we intend to look up.

00:12:03.410 --> 00:12:04.820
Then we set up the client.

00:12:04.900 --> 00:12:11.400
Now, all of the CFNetwork clients are
set up in these context structures.

00:12:11.400 --> 00:12:13.940
And it can be a little
confusing and daunting.

00:12:13.940 --> 00:12:19.840
The main thing to know is that your info
pointer is always the second argument.

00:12:19.960 --> 00:12:25.890
And if you want us to treat that info
pointer as just a blind void star,

00:12:25.930 --> 00:12:29.680
all the other arguments can be null.

00:12:29.750 --> 00:12:33.850
If, on the other hand,
that info pointer is a CF type,

00:12:34.300 --> 00:12:36.910
then the other argument
should be CFRetain,

00:12:36.910 --> 00:12:39.400
CFRelease, CFCopyDescription.

00:12:39.440 --> 00:12:44.380
And you can see examples of that in the
documentation in the example source.

00:12:44.380 --> 00:12:47.900
So you set up the context,
and then you call CFHostSetClient.

00:12:47.900 --> 00:12:52.070
You're going to pass the CFNetwork
object you're registering with.

00:12:52.080 --> 00:12:53.440
So here, my host.

00:12:53.440 --> 00:12:55.490
You're going to pass the
callback you want called.

00:12:55.600 --> 00:12:58.050
And then you're going to
pass this context ref,

00:12:58.460 --> 00:13:01.940
which is how you get information passed
back to you about what you're requesting.

00:13:01.940 --> 00:13:03.770
you're requesting.

00:13:06.400 --> 00:13:09.840
Once that's done,
you're ready to schedule on the run loop.

00:13:09.840 --> 00:13:13.510
Here, I'm calling CFRunLoop.getCurrent
to get the current run loop.

00:13:13.520 --> 00:13:17.840
So this essentially says,
I want my callback on this very thread,

00:13:17.840 --> 00:13:20.270
the one that I'm executing on now.

00:13:21.610 --> 00:13:25.100
Now that all of that context is set up,
we're ready to start the

00:13:25.200 --> 00:13:26.640
CFNetwork object off.

00:13:26.640 --> 00:13:30.360
And so here we call
CFHost setInfoResolution and tell

00:13:30.360 --> 00:13:35.300
it that the info we want resolved
is the host's IP addresses.

00:13:35.300 --> 00:13:37.000
And now we sit and wait.

00:13:37.040 --> 00:13:39.700
And we do that by running the run loop.

00:13:41.850 --> 00:13:43.790
So then at some point in the future,
hopefully,

00:13:43.840 --> 00:13:46.280
you're going to get a callback.

00:13:46.300 --> 00:13:48.710
And the callback's going to
look something like this.

00:13:48.950 --> 00:13:51.750
The first argument is always
going to be the CFNetwork object

00:13:51.840 --> 00:13:54.210
that's reporting the result.

00:13:54.540 --> 00:13:56.900
Then there are going to be
several arguments that tell you

00:13:57.210 --> 00:13:58.640
what result you have received.

00:13:58.660 --> 00:14:01.730
So here we have a type info
field to tell you what kind

00:14:01.770 --> 00:14:04.910
of information is coming back,
an error field in case

00:14:04.910 --> 00:14:07.440
an error has occurred,
and then the last argument

00:14:07.480 --> 00:14:12.560
is always your info pointer,
out from that context structure.

00:14:12.640 --> 00:14:15.540
And basically what you're going to do in
each of these callbacks is first check

00:14:15.560 --> 00:14:17.860
to see if an error is being reported.

00:14:17.940 --> 00:14:20.510
If it is, you have to field the error.

00:14:21.250 --> 00:14:23.930
If no error has been reported,
you look and see what

00:14:23.930 --> 00:14:28.010
information is being reported,
and you do whatever you need to do there.

00:14:28.120 --> 00:14:30.900
So here,
if the type info is host addresses,

00:14:30.990 --> 00:14:33.920
we're being told that the
addresses are available.

00:14:34.020 --> 00:14:36.320
We turn around and call
CFHost getAddressing,

00:14:36.340 --> 00:14:40.780
and this returns an array of all
of the IP addresses that we found,

00:14:41.020 --> 00:14:44.550
and you can do whatever
processing you need on that.

00:14:47.060 --> 00:14:48.880
Finally, cleaning up.

00:14:48.920 --> 00:14:52.560
With a callback-based API like this,
it's not as simple as simply

00:14:52.560 --> 00:14:57.390
calling CFRelease when you're
done with the CFNetwork object.

00:14:57.580 --> 00:15:00.500
The reason for that is that
with a reference counting API,

00:15:00.500 --> 00:15:05.700
you can never know for absolute sure
that your reference was the last one,

00:15:05.700 --> 00:15:08.180
and so when you call release,
that object's going to be destroyed.

00:15:09.280 --> 00:15:12.600
Well, since you can't know that the
object is going to be destroyed,

00:15:12.600 --> 00:15:16.970
you probably want a way to make sure that
your callback will never be called again,

00:15:17.090 --> 00:15:20.810
because the object may hang around,
but you're not planning to.

00:15:21.640 --> 00:15:24.980
So the way you do that is by
first calling setClient null.

00:15:25.120 --> 00:15:27.510
That tells the object,
forget you ever heard of me.

00:15:27.690 --> 00:15:31.290
Don't come back, don't call, don't write.

00:15:31.390 --> 00:15:34.280
Once that's done,
you unschedule from the run loop.

00:15:34.390 --> 00:15:40.590
This is not strictly necessary,
but it's a performance boost,

00:15:40.590 --> 00:15:43.770
because as long as you're
scheduled on the run loop,

00:15:43.770 --> 00:15:43.770
that object is going to keep
using the run loop to do work.

00:15:44.950 --> 00:15:48.730
After you've unscheduled,
if the object is still doing work,

00:15:48.730 --> 00:15:52.410
if you haven't told the object, okay,
stop, you're done,

00:15:52.410 --> 00:15:56.250
this is the time when you want to
call cancel or close or whatever

00:15:56.250 --> 00:16:00.800
the call is that tells the object,
you know, stop doing anything.

00:16:00.800 --> 00:16:03.650
I'm no longer interested in the work.

00:16:04.310 --> 00:16:08.400
Finally, only after all of that is done
should you call CFRelease and

00:16:08.400 --> 00:16:12.000
forget your reference to the object.

00:16:15.760 --> 00:16:21.420
So that's the basic usage model for
all of the different CFNetwork types.

00:16:21.420 --> 00:16:25.250
However,
it's not the only usage model we support.

00:16:25.380 --> 00:16:28.940
We consider that model
asynchronous event driven.

00:16:29.040 --> 00:16:31.300
The basic idea is you
tell the object to go,

00:16:31.300 --> 00:16:33.760
and at some point the object's
going to call you back and say,

00:16:33.760 --> 00:16:35.790
these interesting things have happened.

00:16:36.820 --> 00:16:39.200
However,
we do support other common models,

00:16:39.360 --> 00:16:40.860
polling and blocking.

00:16:40.920 --> 00:16:43.220
We don't recommend that you use them.

00:16:43.420 --> 00:16:47.280
They will not perform as well
as the event driven model will.

00:16:47.280 --> 00:16:51.300
But if you're adapting old code
that uses one of these models,

00:16:51.300 --> 00:16:55.200
or you're working inside an
architecture that requires it,

00:16:55.260 --> 00:16:56.670
you can use them.

00:17:00.500 --> 00:17:03.570
And now I'm going to move on to start
talking about the actual objects

00:17:03.570 --> 00:17:06.070
inside available from CFNetwork.

00:17:06.170 --> 00:17:10.260
And like I said, we're going to start out
with the basic abstractions.

00:17:10.380 --> 00:17:14.730
There are two I want to talk about,
CFHost and CFSocketStream.

00:17:15.940 --> 00:17:20.960
CFHost, like I said,
is new in Panther and allows you

00:17:20.960 --> 00:17:27.760
to asynchronously do a DNS host
lookup or a reverse DNS host lookup.

00:17:28.540 --> 00:17:33.190
You can create a CFHost either from
a host name or from an IP address,

00:17:33.190 --> 00:17:37.290
and you see the two different
CFHost create calls there.

00:17:39.360 --> 00:17:42.300
And when you're ready to start
the asynchronous resolution,

00:17:42.300 --> 00:17:45.400
you'll call CFHost start info resolution.

00:17:45.460 --> 00:17:49.320
The arguments,
as we saw in the code example,

00:17:49.390 --> 00:17:52.860
determine what it is that's
going to be resolved.

00:17:52.960 --> 00:17:53.790
You have three choices.

00:17:53.800 --> 00:17:55.280
You can resolve IP addresses.

00:17:55.330 --> 00:17:57.200
That's probably going
to be the most common.

00:17:57.200 --> 00:18:00.930
It's just a basic
asynchronous DNS lookup.

00:18:01.120 --> 00:18:02.590
You can look up DNS names.

00:18:02.620 --> 00:18:06.230
So if you started from an IP address,
you can do a reverse lookup.

00:18:06.460 --> 00:18:10.560
And finally,
you can check reachability to that host.

00:18:10.640 --> 00:18:13.750
And a word of warning there,
that reachability is defined the

00:18:13.750 --> 00:18:16.940
same way system configurations
reachability is defined.

00:18:17.100 --> 00:18:19.650
In other words,
we're not actually going out and pinging

00:18:19.650 --> 00:18:23.060
the remote host to see if we can get
a packet all the way there and back.

00:18:23.140 --> 00:18:26.150
We're just checking to make sure
there's a path configured off

00:18:26.150 --> 00:18:30.340
the machine that is likely to
get you to where you want to go.

00:18:32.600 --> 00:18:35.150
So with CFHost,
once your callback is triggered,

00:18:35.320 --> 00:18:38.490
that means that the information
you need is now available.

00:18:38.500 --> 00:18:42.040
And you can now turn around and retrieve
that information out of CFHost by

00:18:42.130 --> 00:18:44.480
calling one of these three functions.

00:18:44.620 --> 00:18:47.640
CFHost get_addressing
returns the IP addresses,

00:18:47.770 --> 00:18:52.300
CFHost get_names returns the DNS names,
and CFHost get_reachability

00:18:52.300 --> 00:18:57.010
tells you whether or not the
host is reachable at this time.

00:18:59.520 --> 00:19:01.400
Moving on to CFSocketStream.

00:19:01.540 --> 00:19:06.960
CFSocketStream is simply a
stream wrapper around a socket.

00:19:06.960 --> 00:19:10.090
So, sockets,
you can read and write to them both,

00:19:10.210 --> 00:19:11.100
so we return a pair.

00:19:11.100 --> 00:19:14.160
There's a CFReadStream and a
CFWriteStream to go with the socket.

00:19:14.160 --> 00:19:19.400
You can create such a pair of streams
to any of these different things,

00:19:19.400 --> 00:19:22.000
a CFHost,
a CFNetService that you might have

00:19:22.450 --> 00:19:28.160
gotten reported back via rendezvous,
a host name and port pair,

00:19:28.160 --> 00:19:32.160
an arbitrary socket signature if you're
comfortable working with sock adders.

00:19:32.220 --> 00:19:36.310
Or you can actually take a
preexisting raw socket and

00:19:36.310 --> 00:19:38.950
wrap the streams around them.

00:19:39.570 --> 00:19:44.640
And the one catch to remember is that
there is only one socket underneath.

00:19:44.890 --> 00:19:48.280
And any configuration you do on one
stream is going to affect the other,

00:19:48.440 --> 00:19:53.380
precisely because there is just that one
file descriptor underlying the streams.

00:19:55.540 --> 00:20:00.480
So the basic support for CFSocketStream
actually resides inside core foundation,

00:20:00.480 --> 00:20:05.500
and you can find the most basic
creation routines in CFStream.h

00:20:05.500 --> 00:20:07.340
inside the core foundation headers.

00:20:07.350 --> 00:20:11.840
But CFNetwork adds several interesting
configuration options on top of that.

00:20:11.840 --> 00:20:18.130
I already touched on one of them,
SSL or TLS encryption and authentication.

00:20:18.270 --> 00:20:21.860
That's configurable
from inside CFNetwork.

00:20:21.880 --> 00:20:25.150
We also added SOCKS proxy support.

00:20:25.160 --> 00:20:29.560
And you can find the details about how
you would use those inside CFNetwork,

00:20:29.560 --> 00:20:31.910
CFSocketStream.h.

00:20:42.910 --> 00:20:45.510
So, on the topic of proxies,
this is a common question we have.

00:20:45.610 --> 00:20:49.220
Okay, I've got this great stream,
but I don't know how to set it

00:20:49.220 --> 00:20:53.710
up so that it will navigate the
proxies configured on the computer.

00:20:53.950 --> 00:20:58.350
Well, several of the CFNetwork
APIs are set up to accept proxy

00:20:58.430 --> 00:21:00.500
configuration dictionaries.

00:21:00.700 --> 00:21:04.200
Here I listed three of them,
CFSocketStream, HTTPStream,

00:21:04.200 --> 00:21:06.090
and FTPStream.

00:21:06.230 --> 00:21:10.560
Because of the layering of this API,
because this is that low level

00:21:10.560 --> 00:21:15.200
API where we're giving you full
control over all the configuration,

00:21:15.220 --> 00:21:18.360
we will never apply a
proxy automatically.

00:21:18.540 --> 00:21:21.390
However,
we tried to make it as easy as possible

00:21:21.560 --> 00:21:23.870
for you to apply the default proxies.

00:21:24.050 --> 00:21:28.200
And the way to do that is to call
scdynamic_store_copy_proxies.

00:21:28.220 --> 00:21:32.500
That's the function that will
return the dictionary of proxies

00:21:32.500 --> 00:21:34.900
configured on the system.

00:21:34.970 --> 00:21:38.040
And then just pass that
straight through to us.

00:21:38.100 --> 00:21:40.460
If you do that,
we will automatically go through,

00:21:40.570 --> 00:21:42.490
figure out what the
right proxy to use is,

00:21:42.490 --> 00:21:44.550
and apply it.

00:21:45.130 --> 00:21:47.430
The reason why we do it this
way is so that if you're in a

00:21:47.480 --> 00:21:50.700
situation where you know you don't
want to use the default proxy,

00:21:50.700 --> 00:21:53.500
there's no reason to go
through the HTTP firewall,

00:21:53.500 --> 00:21:56.950
for instance, if you know you're
hitting a local server,

00:21:57.110 --> 00:21:59.710
you have a way to do that.

00:22:02.180 --> 00:22:03.920
So with that,
I'm going to move on to talking

00:22:03.920 --> 00:22:05.300
about the network protocols.

00:22:05.340 --> 00:22:08.460
We have three to discuss.

00:22:08.620 --> 00:22:11.010
We're going to start with FTP,
because that's new in Panther.

00:22:11.040 --> 00:22:15.440
We're going to then talk
a little bit about HTTP.

00:22:15.440 --> 00:22:17.020
And then finally,
we're going to talk about the

00:22:17.020 --> 00:22:19.060
rendezvous support inside CFNetwork.

00:22:19.060 --> 00:22:23.520
And I've listed here the types,
the CF types associated with each

00:22:23.520 --> 00:22:26.500
of those different protocols.

00:22:26.530 --> 00:22:29.340
CFFTP stream backs FTP.

00:22:29.370 --> 00:22:33.680
CFHTTP message and HTTP stream back HTTP.

00:22:33.680 --> 00:22:38.380
And rendezvous is,
you access rendezvous via CFNet service

00:22:38.390 --> 00:22:40.940
and CFNet service browser.

00:22:42.340 --> 00:22:46.250
So, FTP stream is new in Panther,
and you can use it to

00:22:46.250 --> 00:22:49.520
download an FTP URL,
or to download a directory

00:22:49.640 --> 00:22:51.670
listing for an FTP URL.

00:22:51.730 --> 00:22:54.860
We don't have upload support
on the CD that you got,

00:22:54.990 --> 00:22:58.000
but we're promising it to you by Panther.

00:22:59.510 --> 00:23:01.840
And I'm going to just walk you
through a code example of how

00:23:01.840 --> 00:23:03.490
you would download an FTP URL.

00:23:03.570 --> 00:23:05.500
It's pretty straightforward.

00:23:05.500 --> 00:23:09.600
You create the URL to the
FTP location you're interested in.

00:23:09.610 --> 00:23:12.490
You call CFReadStream,
create with FTP URL.

00:23:12.590 --> 00:23:14.770
You're getting a read stream back.

00:23:14.770 --> 00:23:18.110
And now you just use the stream
the way you would use any stream.

00:23:18.110 --> 00:23:20.460
You open it, you read from it.

00:23:20.730 --> 00:23:22.750
I do not show the
event-driven model here,

00:23:22.750 --> 00:23:26.030
but normally you would schedule
yourself and wait for the stream

00:23:26.030 --> 00:23:29.140
to inform you that there are
bytes waiting for your attention.

00:23:32.760 --> 00:23:36.590
Downloading a directory
listing is very similar.

00:23:36.720 --> 00:23:40.200
You start out by creating the URL,
but here the URL is a directory

00:23:40.200 --> 00:23:42.250
URL instead of a file URL.

00:23:42.250 --> 00:23:44.170
You can tell that because
it ends in the slash,

00:23:44.220 --> 00:23:51.700
and that's actually what we queue off
of to figure out whether we're looking

00:23:51.700 --> 00:23:51.700
at a directory or looking at a raw file.

00:23:51.910 --> 00:24:10.200
So, you need to do this extra step of
parsing out the resource listing.

00:24:10.200 --> 00:24:13.920
So, I represented that by calling this
parse resource listing function.

00:24:13.960 --> 00:24:17.590
And this is what that
function's going to look like.

00:24:18.640 --> 00:24:20.700
So you got back this
buffer from the stream.

00:24:20.700 --> 00:24:22.840
You have a length and a number of bytes.

00:24:22.840 --> 00:24:26.250
And what you're going to do
is call this other function,

00:24:26.250 --> 00:24:30.240
CFFTPCreateParsedResourceListing,
giving back the buffer.

00:24:30.240 --> 00:24:33.000
And each time you do that,
we'll scan the buffer and try

00:24:33.000 --> 00:24:34.680
to find a directory listing.

00:24:34.680 --> 00:24:39.380
If we find it, we'll tell you, OK,
I just consumed the first 80 bytes.

00:24:39.460 --> 00:24:43.050
And then we'll take those 80 bytes and
parse out a full directory listing and

00:24:43.100 --> 00:24:45.020
return that to you as a CFDictionary.

00:24:46.490 --> 00:24:47.860
So the dictionary has a bunch of keys.

00:24:47.900 --> 00:24:50.100
I'm not going to go
into all of them here.

00:24:50.100 --> 00:24:52.040
They're all documented in the headers.

00:24:52.040 --> 00:24:57.870
But I show here, CFDictionary, get value,
listing, and then the resource,

00:24:57.870 --> 00:24:59.840
KCFFTPResourceName.

00:24:59.870 --> 00:25:03.380
And that'll return the actual
name from the FTP listing.

00:25:05.110 --> 00:25:07.270
And then, of course,
because we told you we just

00:25:07.340 --> 00:25:09.450
consumed the first 80 bytes,
you need to update your

00:25:09.450 --> 00:25:12.860
internal buffers to say,
OK, next time I call this function,

00:25:12.860 --> 00:25:16.130
I'm going to start 80
bytes further downstream.

00:25:17.920 --> 00:25:22.150
And that function,
the parsed resource listing function

00:25:22.280 --> 00:25:25.440
is going to return zero if there
aren't enough bytes available

00:25:25.560 --> 00:25:29.130
for us to get a full listing,
or negative one if we can't

00:25:29.140 --> 00:25:31.490
understand the bytes we got.

00:25:34.340 --> 00:25:36.900
Moving on to HTTP.

00:25:37.000 --> 00:25:39.210
CFHttpMessage is a CF type.

00:25:39.590 --> 00:25:42.290
It's just a pure data type,
doesn't have any asynchrony built

00:25:42.290 --> 00:25:43.670
into it or anything like that.

00:25:43.860 --> 00:25:49.290
It simply represents an
HTTP request or an HTTP response.

00:25:49.520 --> 00:25:54.150
Once you have an HTTP message,
you use CFHTTP stream to actually

00:25:54.260 --> 00:25:58.300
perform the HTTP transaction,
to take the request, serialize it,

00:25:58.430 --> 00:26:01.790
ship it over a socket,
and get the response back.

00:26:01.870 --> 00:26:07.130
So your normal usage is going to be to
create an HTTP message for the request,

00:26:07.270 --> 00:26:13.460
create an HTTP stream from the request,
and then open and read from the stream.

00:26:14.650 --> 00:26:16.100
And that looks like this.

00:26:16.180 --> 00:26:22.470
Start out by creating the HTTP URL,
construct a request from that URL.

00:26:22.800 --> 00:26:24.490
Do any extra configuration.

00:26:24.500 --> 00:26:28.100
So here I'm setting the
user agent to myapp1.0,

00:26:28.100 --> 00:26:30.410
just to show you what
that would look like.

00:26:30.610 --> 00:26:34.070
Once the message has been configured
the way you want it to be,

00:26:34.210 --> 00:26:37.590
call CFReadStream
create for HTTP request.

00:26:37.720 --> 00:26:39.530
You're going to get a read stream back,
and again,

00:26:39.540 --> 00:26:43.160
you're going to use the read stream the
same way you would use any read stream.

00:26:43.220 --> 00:26:48.290
Set yourself as a client, open it,
wait to be told bytes are available.

00:26:50.420 --> 00:26:54.160
Now that's the basic
usage for the HTTP stack,

00:26:54.330 --> 00:26:57.910
but there are a couple others
that are interesting to note.

00:26:58.410 --> 00:27:02.800
Sometimes you don't want us to
build the socket connection for you,

00:27:02.960 --> 00:27:06.160
or sometimes the bytes aren't even
going to be coming from a socket.

00:27:06.260 --> 00:27:10.730
They're coming from a file sitting
on disk or from some piece of

00:27:10.730 --> 00:27:13.050
memory you got from somewhere else.

00:27:13.230 --> 00:27:18.220
You can still use CFHTTPMessage to
perform the HTTP parsing for you,

00:27:18.420 --> 00:27:22.570
and you do that by calling
CFHTTPMessage create empty,

00:27:22.570 --> 00:27:25.900
and then calling append bytes repeatedly.

00:27:25.900 --> 00:27:30.040
As the bytes are appended,
HTTP message will parse out

00:27:30.040 --> 00:27:32.190
the interesting structure.

00:27:32.590 --> 00:27:35.560
And then you can ask it
for interesting values,

00:27:35.560 --> 00:27:39.240
like you can query the header fields,
you can find out what the status code is,

00:27:39.240 --> 00:27:41.200
all of that kind of thing.

00:27:42.440 --> 00:27:45.980
Now, sometimes when you're
performing an HTTP transaction,

00:27:46.340 --> 00:27:47.740
there's a lot of payload data.

00:27:47.740 --> 00:27:50.400
You're performing a post of
some large amount of data,

00:27:50.400 --> 00:27:52.400
or you're pushing a
file back to the server,

00:27:52.400 --> 00:27:55.210
and you don't want to load
all of that into memory,

00:27:55.210 --> 00:27:58.050
which is the normal way
of handling requests.

00:27:58.540 --> 00:28:04.110
You could accommodate that by calling
CFReadStreamCreateForStreamedHTTPRequest

00:28:04.180 --> 00:28:05.900
instead of the normal creation function.

00:28:05.900 --> 00:28:09.000
One of the arguments to that
function is a read stream,

00:28:09.000 --> 00:28:13.930
and we will automatically pull from that
read stream to send the body onwards.

00:28:13.930 --> 00:28:17.160
And that's just, again,
to help you avoid having to hold

00:28:17.160 --> 00:28:19.340
these large resources in memory.

00:28:21.770 --> 00:28:26.520
Finally, CFHttpMessage can be used to
add authentication information.

00:28:26.550 --> 00:28:29.920
There's a function, add authentication,
you pass it.

00:28:29.920 --> 00:28:33.780
The request you're about to send,
the username and password

00:28:33.860 --> 00:28:35.890
that you want to apply.

00:28:36.140 --> 00:28:38.140
There are a couple
other arguments as well.

00:28:38.140 --> 00:28:41.130
And basically,
we will look at the information you gave

00:28:41.300 --> 00:28:44.520
us and put together the correct header
fields and apply them to the request.

00:28:44.520 --> 00:28:47.740
So you don't have to understand the
details of digest authentication,

00:28:47.780 --> 00:28:49.530
for instance.

00:28:52.090 --> 00:28:53.190
Moving on to Rendezvous.

00:28:53.250 --> 00:28:57.310
Rendezvous was introduced in Jaguar,
and the idea was to allow clients

00:28:57.310 --> 00:29:03.290
out there on the network to advertise
services that they had provided.

00:29:03.380 --> 00:29:08.680
Then other clients can go out and
look for those services and discover

00:29:08.770 --> 00:29:13.310
them without the user needing to
go through any configuration work.

00:29:14.390 --> 00:29:18.330
CFNetwork takes these services and
integrates it with the run loop.

00:29:18.480 --> 00:29:21.400
So again,
you can receive information about

00:29:21.450 --> 00:29:25.580
services available or advertise
your own service in a way that's

00:29:25.660 --> 00:29:30.100
well integrated with the normal
event structure on the system.

00:29:31.000 --> 00:29:35.360
There are two types,
the CFNetService and CFNetServiceBrowser.

00:29:35.380 --> 00:29:38.660
CFNetService represents
a network service.

00:29:38.740 --> 00:29:41.580
It's a single provider somewhere
out there on the network.

00:29:41.580 --> 00:29:44.910
It is a printer, it is a web server.

00:29:45.830 --> 00:29:49.530
A net service has a number of attributes,
and I've listed them here.

00:29:49.900 --> 00:29:53.800
The domain is where that
service could be found.

00:29:53.800 --> 00:29:58.370
So most often it's .local
for the local network.

00:29:58.390 --> 00:30:02.580
You can also always pass the empty
string anywhere you're asked for a

00:30:02.580 --> 00:30:04.990
domain to mean the local network.

00:30:05.190 --> 00:30:08.790
The type is what kind of
service is being provided,

00:30:08.790 --> 00:30:10.860
a printer or a web server.

00:30:10.860 --> 00:30:14.700
The name is a name you have
chosen to title your service,

00:30:14.700 --> 00:30:21.660
so Becky's web server as opposed
to Apache's as opposed to Apple's.

00:30:21.660 --> 00:30:24.930
And then the address and the port
is the IP address and the port that

00:30:24.980 --> 00:30:28.130
should be used to contact your service.

00:30:28.690 --> 00:30:31.630
So you would use a news, excuse me,
you would use a net service

00:30:31.640 --> 00:30:33.320
for two basic reasons.

00:30:33.320 --> 00:30:36.150
Either you have a service yourself
that you wish to advertise,

00:30:36.160 --> 00:30:38.910
so you want to announce your
presence on the network so that

00:30:38.910 --> 00:30:40.860
other clients can find you.

00:30:40.870 --> 00:30:44.120
Or because you've found a net service
that someone else has provided and

00:30:44.160 --> 00:30:46.830
you now want to go and connect to it.

00:30:47.360 --> 00:30:51.420
Network service browser is how you
would go out to find those services.

00:30:51.420 --> 00:30:54.500
And each service browser
represents a search.

00:30:54.500 --> 00:30:58.360
You can search either for
individual services or for

00:30:58.380 --> 00:31:01.680
service domains to find out,
in a sense,

00:31:01.900 --> 00:31:05.530
where are the different places
you could look for services.

00:31:08.390 --> 00:31:11.630
So to advertise your service,
what you're going to do is create a

00:31:11.820 --> 00:31:14.100
net service using CFNetServiceCreate.

00:31:14.100 --> 00:31:20.880
You're then going to register that
service by calling CFNetServiceRegister.

00:31:20.880 --> 00:31:24.370
Now this is a little -- this one
case is a little different from the

00:31:24.370 --> 00:31:28.720
other CFNetwork cases because the
only event that could possibly be

00:31:28.720 --> 00:31:33.300
reported to you is that an error
or a naming conflict has occurred.

00:31:33.300 --> 00:31:36.820
So usually you're hoping that your
callback isn't going to be called.

00:31:36.860 --> 00:31:39.190
If it is called,
it means that there's a name conflict and

00:31:39.290 --> 00:31:44.810
you should prompt the user for a new name
or you should choose a new name yourself.

00:31:45.060 --> 00:31:47.970
Somehow handle that conflict.

00:31:48.570 --> 00:31:53.100
The other way you use a NetService
is to resolve someone else's service.

00:31:53.100 --> 00:31:57.710
Usually that means you got the
NetService from a NetService browser.

00:31:57.980 --> 00:32:00.770
The first thing to note is that if
all you want to do is connect to it,

00:32:00.880 --> 00:32:01.210
you're done.

00:32:01.290 --> 00:32:03.890
Just take the NetService
and pass it into CFStream,

00:32:03.930 --> 00:32:06.840
create pair,
and you'll get back a read and write

00:32:06.840 --> 00:32:10.740
stream that's directly connected to
the service you're interested in.

00:32:10.780 --> 00:32:14.170
However, you might also want to know more
information about the service.

00:32:14.170 --> 00:32:17.180
You might want to know what the
name is to display it to the user.

00:32:17.180 --> 00:32:20.620
You might want to pick and choose
between the IP addresses that

00:32:20.620 --> 00:32:22.530
that service is advertised on.

00:32:22.700 --> 00:32:25.260
To do that, call CFNetService resolve.

00:32:25.260 --> 00:32:27.820
That'll start an asynchronous
resolution of all of the

00:32:27.820 --> 00:32:29.260
information about the NetService.

00:32:29.260 --> 00:32:32.340
When you get your callback,
you go back to the NetService and say,

00:32:32.340 --> 00:32:36.380
okay, tell me about yourself,
and you can get all the information then.

00:32:41.200 --> 00:32:43.670
Okay, using a Net Service Browser.

00:32:43.770 --> 00:32:46.980
Create the browser using
Net Service Browser Create.

00:32:46.980 --> 00:32:49.520
And then you decide what
you're going to search for,

00:32:49.520 --> 00:32:53.060
either domains where services
are being advertised,

00:32:53.060 --> 00:32:55.020
or services within a given domain.

00:32:55.040 --> 00:33:01.330
And your callback will be called as
domains are found out on the network.

00:33:01.680 --> 00:33:05.430
Your callback is also going to be
called as those services disappear.

00:33:05.500 --> 00:33:08.460
So if you leave a browser
running for a long time,

00:33:08.560 --> 00:33:12.180
it'll call you back and say, okay,
Becky's printer is gone now.

00:33:12.180 --> 00:33:15.560
These other printers
have become available.

00:33:15.560 --> 00:33:19.610
So you can track over a long
period of time that way.

00:33:22.520 --> 00:33:24.540
Wow, we're just sipping through this.

00:33:24.630 --> 00:33:25.960
We're going to move on to the wrap-up.

00:33:25.990 --> 00:33:31.850
All these sessions have already happened.

00:33:32.810 --> 00:33:35.840
However,
if you're looking back on the conference

00:33:35.950 --> 00:33:39.730
later and going through your DVDs,
here are some sessions that

00:33:39.730 --> 00:33:41.700
might be of interest to you.

00:33:41.700 --> 00:33:46.580
403 Safari overview talked about
all the different technology

00:33:46.580 --> 00:33:48.700
pieces that go into Safari.

00:33:49.090 --> 00:33:54.580
105 Rendezvous spent a long time
talking about Rendezvous itself.

00:33:55.190 --> 00:33:58.000
110 networking overview talked
about all the different networking

00:33:58.000 --> 00:34:01.170
APIs available on Mac OS X.

00:34:01.260 --> 00:34:05.380
There's a lot of time spent there also
talking about the basic capabilities

00:34:05.380 --> 00:34:09.140
of the Core OS networking pieces.

00:34:09.800 --> 00:34:14.590
Advanced Foundation URL APIs talked
about those new URL loading APIs that

00:34:14.590 --> 00:34:18.910
are available now with the Safari SDK.

00:34:21.210 --> 00:34:25.680
Xavier Lagros, who I'm going to invite
up to the stage now,

00:34:25.910 --> 00:34:29.840
is our evangelist,
and you can contact him with

00:34:29.840 --> 00:34:36.010
any questions or comments
about the CFNetwork APIs.

00:34:38.340 --> 00:34:40.740
Just to flash through the
documentation quickly,

00:34:40.740 --> 00:34:45.280
there's a ton of documentation
about all different aspects of

00:34:45.620 --> 00:34:49.460
the networking APIs on our system.

00:34:49.700 --> 00:34:53.200
Just go to ADC home documentation
networking and browse.

00:34:53.200 --> 00:34:55.000
You'll be amazed at how much you find.

00:34:55.150 --> 00:34:58.140
But in particular, I wanted to highlight
the CFNetwork section.

00:34:58.210 --> 00:35:03.610
And there's a very good programming
topic on using CFRunLoop.

00:35:03.770 --> 00:35:07.190
And finally,
Rendezvous also has its own section.

00:35:08.430 --> 00:35:10.700
Sample code and developer
examples networking.

00:35:10.700 --> 00:35:12.140
I'm not going to go
through this in detail,

00:35:12.140 --> 00:35:15.080
but there is a good example
of using HTTP there.

00:35:15.450 --> 00:35:19.910
There's also a good example of writing
a server and a client and getting

00:35:19.910 --> 00:35:22.570
them to connect using rendezvous.

00:35:24.220 --> 00:35:27.480
MacNetwork Prague is a
fabulous mailing list.

00:35:27.690 --> 00:35:29.280
I'm on that list.

00:35:29.370 --> 00:35:32.150
Most everybody I work with
at Apple is on that list.

00:35:32.150 --> 00:35:36.320
It's for discussing all
aspects of network programming,

00:35:36.320 --> 00:35:40.900
and just go to lists.apple.com,
and you can sign up there.
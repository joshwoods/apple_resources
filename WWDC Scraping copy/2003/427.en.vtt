WEBVTT

00:00:25.870 --> 00:00:27.960
You guys are hardcore.

00:00:27.980 --> 00:00:29.180
Excellent.

00:00:29.180 --> 00:00:34.320
It's been a long, long week,
but we got somebody here who's

00:00:34.330 --> 00:00:36.380
going to make it all worthwhile.

00:00:36.470 --> 00:00:38.940
Doug Davidson is going to talk
to you about some of the really

00:00:39.010 --> 00:00:40.440
cool stuff in Cocoa text.

00:00:40.440 --> 00:00:43.140
So help me welcome to
the stage Doug Davidson.

00:00:46.940 --> 00:00:47.880
Okay, thanks Jason.

00:00:47.890 --> 00:00:49.750
I'd like to thank you all for coming.

00:00:49.780 --> 00:00:52.910
I like to think we've saved
the best for the last.

00:00:53.670 --> 00:00:55.960
As I said, I'm Doug Davidson,
and I'm here to talk to you

00:00:56.040 --> 00:00:58.270
about the Cocoa text system.

00:00:58.360 --> 00:01:00.840
Now,
anyone who's worked with Cocoa at all

00:01:00.840 --> 00:01:05.290
has seen the text system in action,
because in almost any case

00:01:05.310 --> 00:01:08.240
where a Cocoa application
puts up text on the screen,

00:01:08.260 --> 00:01:12.120
the text system is responsible
for it in one way or another.

00:01:12.300 --> 00:01:16.690
So the Cocoa text system is
at the heart of a lot of the

00:01:16.690 --> 00:01:18.920
things that we do in Cocoa.

00:01:18.920 --> 00:01:21.170
Now, what I'm going to do in this
session is first of all,

00:01:21.240 --> 00:01:24.880
I want to go briefly through some of
the features of the Cocoa text system,

00:01:24.880 --> 00:01:29.120
then we're going to dive in and
explain how to start using them.

00:01:29.180 --> 00:01:33.830
But the primary emphasis that I want
to have is on what I think is the most

00:01:33.840 --> 00:01:37.070
interesting part of the text system,
and that is customizing it for

00:01:37.070 --> 00:01:40.440
your particular application,
because one of the principal

00:01:40.440 --> 00:01:43.630
design points of the Cocoa text
system is that it should be

00:01:43.630 --> 00:01:45.820
highly customizable throughout.

00:01:46.910 --> 00:01:50.480
Now, as far as features go,
if you've used TextEdit,

00:01:50.480 --> 00:01:53.330
you're probably familiar with
a lot of the features of the

00:01:53.330 --> 00:01:56.710
Cocoa text system already,
because most of what you get with

00:01:56.750 --> 00:02:06.640
TextEdit are things that you will get for
free whenever you use the text system,

00:02:06.650 --> 00:02:06.890
provided that you check the
appropriate boxes in Interface Builder.

00:02:07.400 --> 00:02:12.840
So showing is better than telling,
so let's move on over to the

00:02:12.840 --> 00:02:15.870
demo and let's take a look.

00:02:20.610 --> 00:02:25.080
Now, what I have here is my version
that I just wrote of a very

00:02:25.110 --> 00:02:28.820
simple editor that you've probably
seen demoed over and over.

00:02:28.920 --> 00:02:32.140
Very little code,
but it has all the features

00:02:32.390 --> 00:02:35.290
that you would expect,
features that we know and love.

00:02:35.410 --> 00:02:42.100
But now, this is running on Panther,
so we might expect something more.

00:02:42.160 --> 00:02:44.170
For example,

00:02:44.300 --> 00:02:49.740
In Panther, the Find panel is now
built into the text system.

00:02:49.740 --> 00:02:53.200
It took me zero lines of
code to add this to my app,

00:02:53.200 --> 00:02:57.700
and it's fully functional and
actually quite full-featured.

00:03:00.330 --> 00:03:06.640
Also for Panther,
we have completely redone the text ruler.

00:03:06.700 --> 00:03:13.380
The old confusing line spacing
controls that nobody can understand

00:03:13.380 --> 00:03:16.680
are gone by popular request.

00:03:16.680 --> 00:03:16.680
In their place, let me

00:03:19.700 --> 00:03:24.550
We have this neat little pop-up here
that by default allows you to pick

00:03:24.550 --> 00:03:28.430
single spacing or double spacing.

00:03:29.320 --> 00:03:34.000
Or in fact, just about any kind of
spacing you might like.

00:03:34.060 --> 00:03:37.360
Now,
we certainly didn't have user interface

00:03:37.360 --> 00:03:41.750
in Jaguar for most of these features,
and in fact some of them are

00:03:41.750 --> 00:03:43.200
completely new for Panther.

00:03:43.210 --> 00:03:46.140
So, for example,
the line height multiple.

00:03:46.210 --> 00:03:49.290
Let's try picking one
and a half line spacing.

00:03:49.720 --> 00:03:53.650
And you'll notice that when we go back,
that's now showing up on the pop-up

00:03:53.660 --> 00:03:56.670
so I can get to it easily again.

00:03:58.290 --> 00:04:01.000
We also have this other little
pop-up over on the other side.

00:04:01.000 --> 00:04:02.900
This is the styles pop-up.

00:04:02.950 --> 00:04:08.640
And what this allows you to do is to save
any styles that you might like or use

00:04:08.640 --> 00:04:12.200
frequently so you can have them right at
your fingertips whenever you want them.

00:04:12.200 --> 00:04:15.480
Now, for demo purposes,
I've already preloaded this with a

00:04:15.480 --> 00:04:19.100
number of styles because I want to
show off some of the new attribute

00:04:19.100 --> 00:04:21.190
features that we have in Panther.

00:04:21.380 --> 00:04:22.810
For example, underlines.

00:04:22.810 --> 00:04:26.090
In Jaguar, I think we had two
different underline styles.

00:04:26.090 --> 00:04:29.180
In Panther, we have, I think it's 30.

00:04:29.190 --> 00:04:34.320
For example,
you could get a double underline or a

00:04:34.320 --> 00:04:39.600
dotted underline or colored underline,
basically just about

00:04:39.600 --> 00:04:41.330
anything you'd expect.

00:04:41.830 --> 00:04:43.720
Also,
we have taken the strikethroughs and

00:04:43.870 --> 00:04:47.780
separated them from the underlines and
given them the same sort of options.

00:04:47.810 --> 00:04:52.800
So you can get double strikethrough,
co-ed strikethrough, and so forth.

00:04:53.080 --> 00:04:54.800
What else?

00:04:54.800 --> 00:04:59.580
We now have outlines, common request,
but we don't just have

00:04:59.620 --> 00:05:01.800
a single outline style.

00:05:01.800 --> 00:05:06.800
We have a fully adjustable
parameter so that you could get,

00:05:06.800 --> 00:05:07.140
for example,

00:05:07.330 --> 00:05:14.060
A heavier outline, if you like,
or a lighter outline.

00:05:14.060 --> 00:05:14.660
But that's not all.

00:05:14.660 --> 00:05:20.270
You also get to set independently
the colors of the outline and

00:05:20.270 --> 00:05:28.480
the interior of the text so
that you can get some effects,

00:05:28.480 --> 00:05:28.480
say, like this.

00:05:33.450 --> 00:05:37.250
If you went to the Cocoa Update talk,
you heard about the new class

00:05:37.250 --> 00:05:40.370
NSShadow that allows the setting
of a drop shadow on drawing,

00:05:40.380 --> 00:05:43.100
but it's also available
as a text attribute.

00:05:43.230 --> 00:05:48.670
So you could have a configurable shadow,
maybe a little tiny shadow,

00:05:48.690 --> 00:05:51.130
I'm not sure if you can
see it on this big monitor,

00:05:51.290 --> 00:05:58.570
or perhaps a somewhat larger,
somewhat blurred shadow,

00:05:58.570 --> 00:05:58.670
or essentially any shadow you want.

00:06:03.410 --> 00:06:05.680
Now,
what I'd really been intending to type

00:06:05.730 --> 00:06:09.920
here was something more spectacular,
but I forgot how to spell spectacular.

00:06:09.950 --> 00:06:14.040
But that's okay in Panther,
because I just start typing and complete.

00:06:14.040 --> 00:06:17.670
And then, oh, there it is.

00:06:21.110 --> 00:06:26.290
Now, this text completion
is fully customizable,

00:06:26.320 --> 00:06:29.920
and I'll be showing a
demo of that later on.

00:06:30.160 --> 00:06:33.500
But for this particular application,
I decided I wanted to write

00:06:33.500 --> 00:06:34.970
zero lines of code for it.

00:06:35.010 --> 00:06:40.740
And so all I got is the
default built-in functionality,

00:06:40.810 --> 00:06:43.620
which uses the system spelling
dictionary plus anything I happen

00:06:43.620 --> 00:06:43.620
to have in my document already.

00:06:44.390 --> 00:06:45.560
So let's put it all together.

00:06:45.560 --> 00:06:48.840
I have a somewhat more
complicated style here.

00:06:48.840 --> 00:06:56.650
So a little something more
spectacular for Panther.

00:07:02.400 --> 00:07:06.500
Oh yes, there's one more thing.

00:07:06.500 --> 00:07:11.890
When I go to save this document,
I can save it as rich text or plain text,

00:07:11.890 --> 00:07:15.000
just as you'd expect,
but there's one more option here.

00:07:15.000 --> 00:07:19.550
I can also save this as a Word document.

00:07:20.480 --> 00:07:25.420
So this simple 50-line application
can read and write Word documents.

00:07:25.530 --> 00:07:29.530
As a matter of fact, in Panther,
any Cocoa application can now read

00:07:29.530 --> 00:07:34.620
Word documents without changes of code,
provided it was using the standard

00:07:34.630 --> 00:07:37.920
init with path or init with URL APIs.

00:07:37.920 --> 00:07:43.180
Writing Word documents is
a little more difficult.

00:07:43.180 --> 00:07:43.180
You need to have one
line of code for that.

00:07:44.900 --> 00:07:49.400
As far as reading Word documents,
we go back as far as Word 6,

00:07:49.410 --> 00:07:52.560
I think it is.

00:07:52.560 --> 00:07:54.710
For writing,
we use the most recent format,

00:07:54.710 --> 00:07:56.800
which is roughly Word 97 and later.

00:07:56.800 --> 00:08:04.310
You may have heard that Word has a
new XML file format called WordML,

00:08:04.310 --> 00:08:04.310
and we read that, too.

00:08:08.810 --> 00:08:10.560
Now, I have to caution you, of course.

00:08:10.560 --> 00:08:14.160
There is going to be some loss of
fidelity because the Cocoa text

00:08:14.160 --> 00:08:19.800
system does not support all the
features that Word does and vice versa.

00:08:20.800 --> 00:08:25.400
Most notably, for example,
the text system doesn't

00:08:25.400 --> 00:08:28.180
have support for tables yet.

00:08:29.210 --> 00:08:31.510
Whereas before,
what you have to do is open

00:08:31.510 --> 00:08:33.970
up the document in Word,
save it as RTF,

00:08:34.070 --> 00:08:35.660
then open it in a Cocoa application.

00:08:35.660 --> 00:08:37.550
Now we've cut out that step entirely.

00:08:37.650 --> 00:08:40.150
You can just open it
directly in Cocoa application

00:08:40.200 --> 00:08:41.640
and get the same effect.

00:08:41.640 --> 00:08:45.640
Okay.

00:08:45.640 --> 00:08:48.680
So now let's go back to the slides.

00:09:00.900 --> 00:09:11.870
What I want to do is review
briefly the new features

00:09:11.870 --> 00:09:19.020
that we've added for Panther.

00:09:19.020 --> 00:09:21.900
We have the new attributes and
attribute features that I've showed you,

00:09:21.900 --> 00:09:25.030
the outlines, shadows, underlines,
strikethroughs, and so forth.

00:09:25.040 --> 00:09:29.200
We also have a couple of new attributes,
the tooltip and cursor attribute

00:09:29.200 --> 00:09:33.320
that allow you to set a tooltip or
a custom cursor and associate it

00:09:33.320 --> 00:09:35.680
with a particular region of text.

00:09:35.680 --> 00:09:38.420
And we have a little something
called the link attributes that

00:09:38.440 --> 00:09:39.920
I'll be showing you later on.

00:09:39.920 --> 00:09:43.680
We have new paragraph style features,
such as the new line spacing

00:09:43.730 --> 00:09:46.730
options that I showed you,
and there are also some new

00:09:46.730 --> 00:09:50.460
tab stop features that I won't
have time to go into right now.

00:09:50.460 --> 00:09:53.500
We have some whole new API sets.

00:09:54.680 --> 00:09:57.400
We have NSLift generator
and NSATS typesetter,

00:09:57.400 --> 00:09:58.680
I'll be discussing more later on.

00:09:58.680 --> 00:10:01.820
And then we have the most
obvious and visible new features,

00:10:02.220 --> 00:10:04.900
like the new font panel
you've probably seen,

00:10:04.900 --> 00:10:08.190
the new text ruler I showed you,
the find panel completion,

00:10:08.200 --> 00:10:10.360
reading and writing Word documents.

00:10:10.360 --> 00:10:15.040
And there are quite a few other
individual APIs that I may not be

00:10:15.040 --> 00:10:19.570
able to go into in detail here,
but I wrote a number of pages

00:10:19.570 --> 00:10:21.710
of release notes about them.

00:10:21.810 --> 00:10:24.320
So I urge you to take a
look at the release notes.

00:10:24.320 --> 00:10:26.940
And take a look at the headers,
because all the new things

00:10:26.940 --> 00:10:29.320
for Panther are clearly
marked in the headers.

00:10:29.320 --> 00:10:33.260
And I think the release notes should go
into quite a bit of detail describing

00:10:33.260 --> 00:10:35.490
what these things are and what they do.

00:10:36.360 --> 00:10:39.790
One other thing that's
new for Panther is WebKit.

00:10:39.790 --> 00:10:43.260
And some of you may be wondering,
what's the relationship

00:10:43.290 --> 00:10:47.340
between text system,
text views, and WebKit and web views.

00:10:47.380 --> 00:10:51.740
Well, the short answer is that
they're different in much the

00:10:51.810 --> 00:10:56.720
same way that a web browser is
different from a word processor.

00:10:56.720 --> 00:11:00.420
The fact of the matter is that
most web pages today don't

00:11:00.420 --> 00:11:02.580
look very much like text pages.

00:11:02.580 --> 00:11:08.100
And WebKit is -- they're full of frames
and plug-ins and JavaScript and so forth.

00:11:08.100 --> 00:11:13.600
And WebKit is aimed squarely at the
display of the most complex HTML.

00:11:13.600 --> 00:11:18.710
So if what you want is to display a
chunk of HTML in your application,

00:11:18.790 --> 00:11:21.780
probably what you want is a web view.

00:11:21.780 --> 00:11:24.220
On the other hand,
if you want -- what you

00:11:24.220 --> 00:11:26.600
want to show is really text,
or in particular,

00:11:26.640 --> 00:11:29.790
if you want editability,
then you want a text view.

00:11:29.800 --> 00:11:29.800
So, if you want to show a text view,
you want to show a text view.

00:11:29.800 --> 00:11:29.800
And if you want a text view,
you want to show a text view.

00:11:29.800 --> 00:11:29.800
And if you want to show a text view,
you want a text view.

00:11:29.800 --> 00:11:29.800
And if you want to show a text view,
you want to show a text view.

00:11:29.800 --> 00:11:29.800
And if you want to show a text view,
you want to show a text view.

00:11:29.800 --> 00:11:30.510
And if you want to show a text view,
you want to show a text view,

00:11:30.580 --> 00:11:31.040
you want to show a text view.

00:11:31.040 --> 00:11:32.940
And there's a sort of
a bridge between them,

00:11:32.940 --> 00:11:35.160
and that is that the
Cocoa Text System does have

00:11:35.160 --> 00:11:38.380
an HTML import feature,
which is necessarily lossy,

00:11:38.390 --> 00:11:41.240
but it does at least
allow you to get the text,

00:11:41.240 --> 00:11:46.180
rich text content of
HTML into the text system.

00:11:48.590 --> 00:11:51.630
So now it's time to dive in and start
showing you how to use all these

00:11:51.630 --> 00:11:53.420
features and new features and so forth.

00:11:53.420 --> 00:11:56.640
But before I do that,
I want to put some structure

00:11:56.640 --> 00:12:00.480
and organization on my
discussion of the text system.

00:12:00.520 --> 00:12:05.450
And the paradigm I like to use is model,
view, controller.

00:12:05.460 --> 00:12:08.620
Yes, you've heard it many times.

00:12:08.620 --> 00:12:13.200
Within the context of the text system,
the model is the text document,

00:12:13.320 --> 00:12:16.160
the characters and their attributes.

00:12:16.160 --> 00:12:21.460
The view is the text view you've seen
that handles the user input and display.

00:12:21.460 --> 00:12:25.170
And the controller classes
handle everything in between.

00:12:28.390 --> 00:12:32.230
You can do quite a lot in the text
system just by dealing with NSTextView,

00:12:32.240 --> 00:12:34.140
as we'll see.

00:12:34.140 --> 00:12:40.480
The TextView is the visible face of
the text system for most purposes.

00:12:40.480 --> 00:12:44.250
What a TextView is,
is a representation of a single

00:12:44.820 --> 00:12:48.130
region within which text is laid out,
such as a page,

00:12:48.130 --> 00:12:51.760
and it handles all of the display
and all of the user interaction

00:12:51.780 --> 00:12:53.460
for the text on that page.

00:12:53.510 --> 00:12:57.240
If you have, say, multiple pages,
then you would have multiple TextViews,

00:12:57.240 --> 00:13:02.360
and those sibling TextViews would know
about each other and work together and

00:13:02.360 --> 00:13:04.970
have a certain amount of shared state.

00:13:05.500 --> 00:13:08.970
There are a few other classes
that come in and work with the

00:13:08.990 --> 00:13:10.890
text system at the view level.

00:13:10.940 --> 00:13:13.920
For example,
the standard Cocoa Ruler classes are

00:13:13.920 --> 00:13:16.380
used in displaying the ruler for text.

00:13:16.380 --> 00:13:20.350
And then there's a class
called NSTextAttachmentCell.

00:13:20.390 --> 00:13:28.690
It's a special kind of cell that is
used for displaying the icons or images

00:13:28.690 --> 00:13:28.690
corresponding to inline attached files.

00:13:29.560 --> 00:13:34.120
And the most visible new features for
Panther come in at the view level.

00:13:34.120 --> 00:13:36.970
The updated font panel I mentioned,
the new text ruler,

00:13:36.970 --> 00:13:39.720
the find panel completion,
and the cursors and tool

00:13:39.720 --> 00:13:41.490
tips that I've talked about.

00:13:43.700 --> 00:15:38.600
[Transcript missing]

00:15:41.460 --> 00:15:43.750
So what are these attributes?

00:15:43.760 --> 00:15:47.830
The standard ones that are recognized
and understood by the text system

00:15:47.830 --> 00:15:53.200
are listed in an AppKit header called
NSDistributedString.h in the AppKit.

00:15:53.200 --> 00:15:56.170
And they include most
of what you'd expect:

00:15:56.290 --> 00:15:59.300
fonts, colors, underlines,
strikethroughs, and so on and so forth.

00:15:59.490 --> 00:16:03.300
There are a few things that don't appear
as individual separate attributes.

00:16:03.300 --> 00:16:07.280
For example, bold and italic are not
separate attributes.

00:16:07.300 --> 00:16:09.260
They're treated as traits of the font.

00:16:09.330 --> 00:16:12.720
And we use NSFontManager to
add these traits or remove

00:16:12.750 --> 00:16:14.290
these traits from the font.

00:16:14.300 --> 00:16:17.960
Also, anything that is part
of a paragraph style,

00:16:17.960 --> 00:16:22.050
like margins, tab stops, line spacing,
and so forth,

00:16:22.050 --> 00:16:26.110
is not a separate attribute,
but instead it's a feature

00:16:26.110 --> 00:16:29.300
of an NSParagraphStyle object
that encapsulates the text.

00:16:29.300 --> 00:16:31.300
It encapsulates all that information.

00:16:31.300 --> 00:16:35.230
And then there are some special
attributes that deal with view

00:16:35.230 --> 00:16:38.680
and display and interaction,
like the cursor and tooltip

00:16:38.680 --> 00:16:40.230
attributes that I mentioned before.

00:16:40.300 --> 00:16:43.600
And then there's a link attribute
that's used whenever text has

00:16:43.600 --> 00:16:47.300
a hyperlink associated to it,
and the attachment attribute that's used

00:16:47.300 --> 00:16:49.300
when there's an inline attached file.

00:16:51.400 --> 00:16:53.830
We have quite a lot of
new features in Panther.

00:16:53.840 --> 00:16:56.950
The attribute level,
we have the stroke width and

00:16:56.950 --> 00:17:00.140
stroke color that I demonstrated
when we used for outlines,

00:17:00.150 --> 00:17:03.910
the new underline styles and colors,
strike through styles and colors,

00:17:03.910 --> 00:17:06.730
the shadows,
a couple I haven't mentioned though,

00:17:06.730 --> 00:17:09.920
bleakness and expansion,
you can look those up,

00:17:09.920 --> 00:17:12.670
and the cursor and tooltip attributes.

00:17:13.320 --> 00:17:16.570
So now we have enough to talk about
more or less the first level of

00:17:16.570 --> 00:17:20.720
customization of the text system,
where you deal with the view and

00:17:20.720 --> 00:17:26.200
the model layers only and you don't
worry about what comes in between.

00:17:26.200 --> 00:17:30.980
So the first thing you should think about
when trying to customize at this level

00:17:31.120 --> 00:17:35.200
is receiving notifications from the text
view or acting as a text view's delegate.

00:17:35.200 --> 00:17:38.200
The text view's delegate
is actually very powerful.

00:17:38.200 --> 00:17:42.430
For example, the text view's delegate is
notified whenever the user

00:17:42.430 --> 00:17:46.200
makes any change to the text,
and the delegate has the opportunity

00:17:46.200 --> 00:17:50.190
at that point to accept or
deny or modify that change.

00:17:50.200 --> 00:17:54.200
So the text view's delegate can control
whatever the user does in the text view.

00:17:54.200 --> 00:17:58.160
The text view's delegate is also
notified if the user makes a change

00:17:58.160 --> 00:18:02.520
to the selection in the text view,
and again has the opportunity to

00:18:02.520 --> 00:18:05.200
accept or deny or modify that change.

00:18:05.320 --> 00:18:08.270
And there are many other text view
delegate methods that give the

00:18:08.400 --> 00:18:11.220
delegate control over a lot of
things that are going on with the

00:18:11.220 --> 00:18:13.200
text view and its user interaction.

00:18:13.200 --> 00:18:18.200
But in some cases you'll find you want
to do some kind of customization that

00:18:18.360 --> 00:18:21.200
you can't do as a text view's delegate.

00:18:21.200 --> 00:18:24.150
At that point,
then it's time to start thinking

00:18:24.200 --> 00:18:26.190
of subclassing NSTextView.

00:18:26.200 --> 00:18:30.200
If you went to the tips and
tricks session earlier today,

00:18:30.200 --> 00:18:35.200
I gave an example of a custom
subclass of NSTextView.

00:18:35.200 --> 00:18:38.000
That was intended to do
some additional drawing.

00:18:38.200 --> 00:18:43.340
It was drawing bubbles around the text,
somewhat the sort of way that iChat does,

00:18:43.340 --> 00:18:44.200
for example.

00:18:44.200 --> 00:18:49.090
And you can also subclass to
customize the user interaction in

00:18:49.270 --> 00:18:52.200
the text view a number of other ways.

00:18:52.200 --> 00:18:54.970
I'm going to give an example
in a minute that will,

00:18:54.990 --> 00:18:59.300
I think, show clearly the distinction
between delegation and subclassing

00:18:59.300 --> 00:19:01.290
and working with NSTextView.

00:19:02.840 --> 00:19:04.860
Now,
when you go to customize the text system,

00:19:04.860 --> 00:19:07.860
it will often happen that you'll
want to make modifications to

00:19:07.860 --> 00:19:10.190
the text that you're working on.

00:19:10.210 --> 00:19:13.030
And the way this typically
works in the text system is that

00:19:13.030 --> 00:19:17.640
user-initiated changes to the text
go first to the text view and then

00:19:17.770 --> 00:19:21.300
through it to the text storage,
whereas programmatic changes

00:19:21.300 --> 00:19:24.240
will typically go directly
to the text storage.

00:19:24.310 --> 00:19:26.670
But they all end up with
the text storage in the end.

00:19:26.700 --> 00:19:30.680
And the text storage, as I've said,
is a mutable attributed string.

00:19:30.730 --> 00:19:33.730
When you want to change it,
you just use mutable attributed

00:19:33.730 --> 00:19:35.780
string methods to alter it.

00:19:36.170 --> 00:19:39.100
But, as I also said,
it has this additional feature

00:19:39.100 --> 00:19:43.000
that it notifies the rest of the
text system whenever it changes.

00:19:43.100 --> 00:19:46.140
So if you're going to be
making multiple changes to the

00:19:46.140 --> 00:19:50.060
same text storage in a row,
what you'll want to do is wrap those in

00:19:50.060 --> 00:19:52.900
a call to begin editing and end editing.

00:19:52.900 --> 00:19:55.970
And what that will do is cause
those notifications to be

00:19:55.970 --> 00:19:59.580
coalesced into a single one at
the end for efficiency's sake.

00:19:59.590 --> 00:20:03.020
You can also subclass in as text storage,
but that's a little more difficult,

00:20:03.020 --> 00:20:04.950
and I'll be talking about that later on.

00:20:06.000 --> 00:20:09.210
So, let's go over to the demo again.

00:20:12.660 --> 00:20:16.070
I want to show an example
of customizing TextView,

00:20:16.160 --> 00:20:18.760
both as delegate and subclass.

00:20:18.760 --> 00:20:22.310
So we have here,
we're going back to text completion,

00:20:22.310 --> 00:20:26.140
and you'll recall I told you that text
completion was fully customizable.

00:20:26.140 --> 00:20:30.070
So here's a custom completion that
you might use if you were working in,

00:20:30.160 --> 00:20:31.810
say, financial reporting.

00:20:31.840 --> 00:20:34.790
Because what this will do,
if you type in the name of a

00:20:34.790 --> 00:20:37.840
company and try to complete,
it will complete the name of the company.

00:20:37.840 --> 00:20:41.590
It will also add the stock ticker symbol.

00:20:47.230 --> 00:20:53.640
And if there's more than one,
then you get a list and you get to pick.

00:20:53.640 --> 00:20:56.700
And you'll notice that these
things are -- the stock tickers

00:20:56.700 --> 00:20:58.310
here are blue and underlined.

00:20:58.340 --> 00:21:01.920
And in fact, when I mouse over them,
I get a pointy hand cursor,

00:21:01.940 --> 00:21:05.150
which is a clue that
these are actually links.

00:21:05.180 --> 00:21:08.470
And I chose to set them up
as links to the stock price.

00:21:08.470 --> 00:21:10.170
I see we're not doing so well.

00:21:13.890 --> 00:21:16.680
So how do we do this?

00:21:16.680 --> 00:21:19.870
Let's see if we can
take a look at the code.

00:21:25.090 --> 00:21:29.630
I've set this up as a
TextView that has both a delegate

00:21:29.740 --> 00:21:34.780
and it's also a custom subclass.

00:21:34.780 --> 00:21:37.840
What the TextView's delegate can
do in the context of completion,

00:21:37.840 --> 00:21:41.300
the delegate is allowed to have
complete control over the list

00:21:41.300 --> 00:21:44.240
of completions that's presented,
their order,

00:21:44.250 --> 00:21:47.520
and which one is first selected.

00:21:47.530 --> 00:21:48.760
That's the first thing we're doing.

00:21:48.810 --> 00:21:53.550
As a delegate,
we implement TextView completions

00:21:53.550 --> 00:21:57.400
for partial word ranges and so forth.

00:21:57.400 --> 00:22:02.100
We have a dictionary here whose
values are the company names

00:22:02.110 --> 00:22:05.410
and keys are the ticker symbols.

00:22:05.420 --> 00:22:09.440
The possible completions are just
the whole list of company names,

00:22:09.450 --> 00:22:11.740
all the keys in the dictionary.

00:22:11.740 --> 00:22:18.290
All we do is go through and see if
the partial word that we're completing

00:22:18.290 --> 00:22:20.220
has a prefix to one of those.

00:22:20.260 --> 00:22:22.460
Then we add it to the
list of completions,

00:22:22.460 --> 00:22:23.750
and we're done.

00:22:24.140 --> 00:22:28.760
So that's what you could do with
completion acting as a TextView delegate.

00:22:28.800 --> 00:22:31.040
But we also did something more.

00:22:31.080 --> 00:22:35.100
When the completion was
actually accepted and confirmed,

00:22:35.120 --> 00:22:39.800
we added in the stock ticker
symbol and made it a link.

00:22:39.810 --> 00:22:43.540
Now,
there are a number of methods associated

00:22:43.540 --> 00:22:48.270
with completion that are designed
to be overridable by subclasses,

00:22:48.270 --> 00:22:52.320
and one of them is this method
and search completion for partial

00:22:52.320 --> 00:22:56.240
word rank that handles putting
the completion back into the text.

00:22:58.030 --> 00:23:01.250
Now, there's one thing I just skipped
over that I probably should mention,

00:23:01.250 --> 00:23:02.820
and that is this.

00:23:02.820 --> 00:23:04.890
We made a call to set
link text attributes.

00:23:04.890 --> 00:23:07.870
Now, when you set link text
attributes on a text view,

00:23:07.870 --> 00:23:11.420
this is a special set of attributes
that the text view will automatically

00:23:11.850 --> 00:23:13.900
apply to text that has a link on it.

00:23:14.040 --> 00:23:18.860
So in this case, we're making it blue,
and we're giving it an underline,

00:23:18.860 --> 00:23:22.070
and we're adding a
pointing hand cursor to it.

00:23:22.070 --> 00:23:25.750
So all text that has a link
will automatically get those

00:23:25.750 --> 00:23:26.820
attributes applied to it.

00:23:29.590 --> 00:23:33.880
So now our subclasses method
for inserting completion,

00:23:34.200 --> 00:23:39.490
what it's going to do is it gets told
whether this is a tentative completion

00:23:39.600 --> 00:23:42.380
or a final confirmed completion.

00:23:42.460 --> 00:23:45.870
And if it's a final confirmed
completion and we have the

00:23:45.870 --> 00:23:49.860
stock ticker symbol for it,
then what we're going to do is

00:23:49.860 --> 00:23:51.850
let it be inserted as usual.

00:23:51.900 --> 00:23:53.300
We call it super method.

00:23:53.340 --> 00:23:58.100
And then we're going to create
an appropriate URL for the link.

00:23:59.360 --> 00:24:02.360
Actually, first what we do is modify
the string to be inserted,

00:24:02.360 --> 00:24:04.510
so we add the ticker symbol to it.

00:24:04.600 --> 00:24:10.390
Then we get a URL and we add this link
attribute to the appropriate range

00:24:10.490 --> 00:24:12.020
corresponding to the sticker symbol.

00:24:12.020 --> 00:24:15.170
And then the TextView automatically
does the rest,

00:24:15.170 --> 00:24:18.370
applying the blue color outline
and cursor to it because we

00:24:18.370 --> 00:24:19.590
set the link text attributes.

00:24:21.300 --> 00:24:25.380
You could also have complete
control over the list of completions

00:24:25.450 --> 00:24:28.980
presented as a TextView subclass,
but I chose to present it

00:24:28.980 --> 00:24:32.300
in a delegate in this case,
just to make the distinction clear.

00:24:32.300 --> 00:24:37.240
Okay, so let's go back to the slides.

00:24:51.420 --> 00:24:55.530
You could do quite a bit with the
Cocoa text system by dealing only with

00:24:55.540 --> 00:25:00.010
the view and the model layers and never
worrying about what happens in between.

00:25:00.190 --> 00:25:04.040
But at some point you're probably
going to get curious and wonder how

00:25:04.040 --> 00:25:10.780
it is that the Cocoa text system
actually goes from the characters and

00:25:10.780 --> 00:25:15.070
their attributes in the text storage
to the pixels you see on the screen.

00:25:15.570 --> 00:25:17.820
Before I discuss that,
I'm going to need to

00:25:17.820 --> 00:25:20.860
introduce another concept,
and that is the glyph.

00:25:20.860 --> 00:25:25.260
Now, characters in the text storage
are Unicode characters,

00:25:25.260 --> 00:25:27.540
but a glyph is something different.

00:25:27.540 --> 00:25:31.320
A glyph is a single displayable
element of a particular font.

00:25:31.350 --> 00:25:34.680
It has no meaning outside of the
particular font that it's in.

00:25:35.920 --> 00:25:38.800
So, in some sense,
the job of the text system,

00:25:38.930 --> 00:25:44.230
at least at the controller level,
is to take the characters and attributes

00:25:44.310 --> 00:25:50.050
in the text storage and to convert
them to a sequence of glyphs and

00:25:50.050 --> 00:25:53.690
their positions that can be displayed.

00:25:53.970 --> 00:25:55.800
That's not quite as
simple as it might sound.

00:25:55.800 --> 00:25:58.500
For example,
the relationship between characters

00:25:58.500 --> 00:26:00.760
and glyphs is not one-to-one.

00:26:00.790 --> 00:26:02.000
It's potentially many-to-many.

00:26:02.000 --> 00:26:05.700
So, for example,
if we look at the character

00:26:05.700 --> 00:26:08.530
we recognize as an accented A,
acute accented A,

00:26:08.530 --> 00:26:12.280
in Unicode this can be represented
either as a single accented

00:26:12.280 --> 00:26:15.740
A character or as two characters,
an A and an accent.

00:26:16.860 --> 00:26:20.480
Likewise, depending on the font,
it might potentially be represented

00:26:20.480 --> 00:26:25.090
by one accented A glyph or it
might be represented by two glyphs,

00:26:25.090 --> 00:26:26.420
an A and an accent.

00:26:26.420 --> 00:26:29.140
And the text system has to
keep track of all that and the

00:26:29.140 --> 00:26:32.420
relationship between the two,
and then it has to calculate the

00:26:32.520 --> 00:26:36.270
appropriate positions for the glyphs
so that we end up with the final

00:26:36.270 --> 00:26:39.540
displayed result that is the appropriate
glyphs in the appropriate places

00:26:39.540 --> 00:26:41.700
with the appropriate attributes.

00:26:42.540 --> 00:26:45.860
So what are the classes that are
actually involved in doing this?

00:26:45.860 --> 00:26:48.860
The principal class that's
involved here is NSLayoutManager.

00:26:48.870 --> 00:26:51.400
NSLayoutManager is the
heart of the text system.

00:26:51.500 --> 00:26:55.500
It is the controller class
in the Cocoa text system.

00:26:55.500 --> 00:27:01.190
I said that the text storage notified the
rest of the text system when it changes.

00:27:01.270 --> 00:27:04.190
Well, it's the LayoutManager that gets
notified by the text storage.

00:27:04.190 --> 00:27:08.740
And when that happens,
the LayoutManager keeps track

00:27:08.800 --> 00:27:12.480
and it arranges for all the
necessary work to be done.

00:27:12.500 --> 00:27:13.220
The LayoutManager is the controller
class that's involved here.

00:27:13.220 --> 00:27:16.280
The principal class that's
involved here is NSLayoutManager.

00:27:16.340 --> 00:27:19.800
NSLayoutManager is the
heart of the text system.

00:27:19.890 --> 00:27:23.550
It is the controller class
in the Cocoa text system.

00:27:23.550 --> 00:27:29.270
I said that the text storage notified the
rest of the text system when it changes.

00:27:29.320 --> 00:27:34.300
Well, it's the LayoutManager that gets
notified by the text storage.

00:27:34.430 --> 00:27:38.130
And when that happens,
the LayoutManager keeps track

00:27:38.230 --> 00:27:42.480
and it arranges for all the
necessary work to be done.

00:27:42.520 --> 00:27:44.350
I'll be discussing these
in more detail later on.

00:27:44.530 --> 00:27:50.200
And then the LayoutManager stores all
the information about the sequence of

00:27:50.260 --> 00:27:52.560
glyphs and where they're positioned.

00:27:52.600 --> 00:27:55.880
And it's actually the LayoutManager
that does the display,

00:27:55.880 --> 00:27:58.310
arranges for them to be
displayed as necessary when

00:27:58.380 --> 00:28:01.150
requested to do so by the view.

00:28:02.430 --> 00:28:05.600
So how is it that text gets from
the characters and attributes

00:28:05.600 --> 00:28:08.610
in the text storage to the
pixels you see on the screen?

00:28:08.610 --> 00:28:10.420
There are four separate steps.

00:28:10.420 --> 00:28:12.340
I want to go through them in order.

00:28:12.380 --> 00:28:15.060
First, attribute fixing,
where we make sure the

00:28:15.060 --> 00:28:16.690
attributes are consistent.

00:28:16.730 --> 00:28:19.880
Second, glyph generation,
where we convert the characters

00:28:20.090 --> 00:28:21.760
and their fonts into glyphs.

00:28:21.760 --> 00:28:25.230
Third, layout, where these glyphs are
broken up into lines.

00:28:25.230 --> 00:28:29.410
The glyphs are positioned in the line,
the lines are positioned in the line,

00:28:29.410 --> 00:28:32.270
and the lines are positioned in the line.

00:28:32.300 --> 00:28:36.130
Fourth, display,
where the glyphs are marshaled

00:28:36.200 --> 00:28:40.380
up and sent down to Quartz to
actually be rasterized into bits

00:28:40.380 --> 00:28:43.760
on the screen or displayed on the
printer or PDF or what have you.

00:28:43.760 --> 00:28:48.170
And in the Cocoa text system,
all these processes are usually

00:28:48.170 --> 00:28:50.300
done lazily and on demand.

00:28:50.300 --> 00:28:53.710
So what typically happens is that
although these occur in this order,

00:28:53.710 --> 00:28:55.610
they get pulled through from the end.

00:28:55.610 --> 00:28:58.280
So what will happen is that
the text view will be required

00:28:58.300 --> 00:29:00.220
to redisplay a certain region.

00:29:00.220 --> 00:29:02.280
So it will call on the layout
manager to read the text.

00:29:02.300 --> 00:29:04.300
And the layout manager,
in order to do that,

00:29:04.300 --> 00:29:05.810
needs the layout information.

00:29:05.810 --> 00:29:07.680
So the layout information
has to be calculated.

00:29:07.680 --> 00:29:10.850
But to do the layout,
you need to have generated the glyphs.

00:29:10.850 --> 00:29:12.500
So it causes that to be done.

00:29:12.500 --> 00:29:16.010
But before you generate the glyphs,
you need to have fixed the attributes.

00:29:16.030 --> 00:29:19.430
So it causes all that to occur in order,
pulled through from the end.

00:29:21.720 --> 00:29:23.200
Attribute fixing.

00:29:23.290 --> 00:29:26.810
Now attribute fixing is actually
performed by the text storage.

00:29:26.850 --> 00:29:28.600
There are several different kinds.

00:29:28.600 --> 00:29:32.460
First of all, there's font fixing,
where we make sure that the font

00:29:32.460 --> 00:29:35.760
that's applied to a particular
character is actually a font

00:29:35.980 --> 00:29:37.990
that can render that character.

00:29:37.990 --> 00:29:41.000
And we will,
the Cocoa text system will substitute

00:29:41.020 --> 00:29:45.820
fonts as necessary in order to get one
that can render the specified character.

00:29:45.840 --> 00:29:48.230
And then there's paragraph fixing.

00:29:48.230 --> 00:29:52.110
You remember I talked about the
NS paragraph style attribute

00:29:52.190 --> 00:29:55.730
that encapsulates all the
paragraph style level features.

00:29:55.770 --> 00:29:58.730
Well,
what we need to do is make sure that that

00:29:58.780 --> 00:30:03.660
attribute is actually constant over the
length of an entire paragraph of text.

00:30:03.670 --> 00:30:06.650
We can't have more than
one for a given paragraph.

00:30:06.650 --> 00:30:09.640
And then there's attachment fixing,
which makes sure that the attachment

00:30:09.640 --> 00:30:13.890
attribute applies only to the attachment
character that it's supposed to.

00:30:14.370 --> 00:30:16.620
And can all these be customized?

00:30:16.680 --> 00:30:21.240
Yes, they can be customized by
subclassing NSText storage and

00:30:21.240 --> 00:30:23.990
overriding the appropriate methods.

00:30:26.810 --> 00:30:28.390
Next, glyph generation.

00:30:28.460 --> 00:30:32.130
Now, when the Layout Manager is
informed by the text storage

00:30:32.130 --> 00:30:35.250
that things have changed,
it will have to invalidate

00:30:35.350 --> 00:30:39.370
a certain portion of any
information that it already has.

00:30:39.530 --> 00:30:40.810
due to that change.

00:30:41.120 --> 00:30:45.200
You can also manually cause the layout
manager to do this invalidation if

00:30:45.200 --> 00:30:48.000
you want to force some recalculation.

00:30:48.100 --> 00:30:53.230
And so then when that
information is needed again,

00:30:53.330 --> 00:30:58.190
the layout manager will call on the
glyph generator typesetter to recalculate

00:30:58.190 --> 00:31:02.910
the information about what the glyphs
are and where they were positioned.

00:31:02.980 --> 00:31:08.910
And it's glyph generator that
actually does a conversion from the

00:31:08.910 --> 00:31:13.050
characters and fonts to the glyphs.

00:31:13.090 --> 00:31:18.260
And then the layout manager stores the
sequence of glyphs that it has produced.

00:31:18.340 --> 00:31:23.340
And because the relationship between
characters and glyphs is not one to one,

00:31:23.340 --> 00:31:26.840
the layout manager also has to keep
track of the relationship between

00:31:27.180 --> 00:31:29.280
character indexes and glyph indexes.

00:31:29.280 --> 00:31:32.190
And if you ever need that information,
you go back to the layout

00:31:32.190 --> 00:31:33.450
manager and ask it.

00:31:35.290 --> 00:31:38.820
Then comes layout,
and the layout manager calls on the

00:31:38.840 --> 00:31:41.860
typesetter to perform the layout.

00:31:41.940 --> 00:31:46.230
The typesetter goes back to the layout
manager to find out what the glyphs are,

00:31:46.230 --> 00:31:49.690
because they've already been generated,
and it goes to the text container

00:31:49.900 --> 00:31:53.000
to determine the geometry of
the page to figure out where

00:31:53.000 --> 00:31:55.160
it can put lines on the page.

00:31:55.270 --> 00:32:01.120
The typesetter is the class that
actually calculates the layout.

00:32:01.210 --> 00:32:05.590
It breaks the text up into lines,
positions the glyphs in the lines,

00:32:05.670 --> 00:32:09.660
and it is also allowed at
this point to insert or change

00:32:09.660 --> 00:32:10.700
glyphs in the glyph stream.

00:32:10.700 --> 00:32:14.990
For example, if it's doing hyphenation,
it may need to insert a hyphen glyph.

00:32:15.190 --> 00:32:19.100
And then the typesetter calls back to the
Layout Manager and tells it what it did.

00:32:19.100 --> 00:32:23.240
It tells it where each line ended
up and which glyphs ended up in

00:32:23.240 --> 00:32:26.600
the line and where the glyphs
are positioned in the line,

00:32:26.600 --> 00:32:29.430
and the Layout Manager stores
that information.

00:32:31.480 --> 00:32:34.100
Then display.

00:32:34.100 --> 00:32:36.940
When the text view needs to
redisplay a certain region,

00:32:37.030 --> 00:32:39.380
first thing it does is go to
the layout manager and ask

00:32:39.390 --> 00:32:42.940
it what glyphs are involved,
what glyphs are needed to display

00:32:42.940 --> 00:32:45.340
that particular region of text.

00:32:45.340 --> 00:32:48.200
And then it calls back on
the layout manager again,

00:32:48.500 --> 00:32:52.250
first to cause the layout
manager to display the background

00:32:52.250 --> 00:32:54.470
appropriate to those glyphs.

00:32:54.620 --> 00:32:58.590
That's typically things like
the selection rectangles.

00:32:58.780 --> 00:33:03.300
And finally,
to ask the Layout Manager to display the

00:33:03.300 --> 00:33:07.760
glyphs along with any other additional
drawing that's needed like underlines,

00:33:07.820 --> 00:33:10.280
strikethroughs, attachments,
and so forth.

00:33:10.650 --> 00:33:13.560
Now it's not just
NSTextView that can do this.

00:33:13.680 --> 00:33:15.090
Your custom view can do it too.

00:33:15.100 --> 00:33:18.720
In fact, there's an example,
developer examples appkit

00:33:18.720 --> 00:33:20.600
circle view that does this.

00:33:20.690 --> 00:33:23.700
There are a couple things you have to
remember if you're going to do this.

00:33:23.780 --> 00:33:26.880
When you call on the Layout
Manager to do this sort of drawing,

00:33:26.880 --> 00:33:29.840
you must already have focus
locked on a flipped view.

00:33:29.840 --> 00:33:32.660
If your view is flipped and
you're in your drawRank method,

00:33:32.660 --> 00:33:33.770
that's automatic.

00:33:33.840 --> 00:33:38.600
Another thing you have to keep in
mind is that the Layout Manager keeps

00:33:38.700 --> 00:33:44.100
track of all its positions relative
to the origin of the text container.

00:33:45.100 --> 00:33:48.920
So, the Cocoa text system is a
very interesting tool for the

00:33:48.930 --> 00:33:52.600
positions of lines and so forth,
which may not be the same

00:33:52.600 --> 00:33:54.430
as the origin of your view.

00:33:54.450 --> 00:33:56.060
In fact, it often isn't.

00:33:56.220 --> 00:34:00.190
So, you'll have to translate
between coordinate systems.

00:34:00.190 --> 00:34:04.780
And it keeps track of the location of
positions of glyphs relative to the

00:34:04.780 --> 00:34:06.810
origin of the line in which they live.

00:34:06.810 --> 00:34:06.810
So, there's a certain amount of
translation that has to go on,

00:34:06.810 --> 00:34:06.810
and we'll see an example of that.

00:34:07.610 --> 00:34:10.820
So now we have enough to talk
about what is more or less the

00:34:11.050 --> 00:34:14.880
second level of customization,
where you are actually getting

00:34:15.120 --> 00:34:21.660
information about where individual pieces
of text are positioned on the screen.

00:34:21.670 --> 00:34:26.940
And the source of all such
information is the Layout Manager.

00:34:26.970 --> 00:34:29.040
Layout Manager knows all.

00:34:29.040 --> 00:34:32.640
The Layout Manager,
if you need to go from a character

00:34:32.640 --> 00:34:36.560
range to a glyph range or vice versa,
which you will often need to do,

00:34:36.560 --> 00:34:41.720
you call on the Layout Manager to get
the position of a particular glyph or

00:34:41.720 --> 00:34:45.920
position and size of a particular line,
or to go backwards,

00:34:45.920 --> 00:34:48.860
given a position to locate a glyph,
or given a rectangle to

00:34:48.920 --> 00:34:50.400
locate the glyphs in it.

00:34:50.400 --> 00:34:53.460
All that sort of thing,
you call on the Layout Manager.

00:34:53.460 --> 00:34:56.260
There are quite a few methods to do this.

00:34:57.110 --> 00:35:02.420
It's also possible to subclass the
Layout Manager if you want to customize

00:35:02.460 --> 00:35:04.660
any of its particular features.

00:35:04.660 --> 00:35:07.840
For example,
if you have a custom attribute

00:35:08.000 --> 00:35:11.200
that you want to affect drawing
at the individual glyph level,

00:35:11.200 --> 00:35:13.850
one way to do that is by
subclassing NSLayoutManager.

00:35:13.860 --> 00:35:20.620
I'll give an example of that.

00:35:20.680 --> 00:35:22.800
Let's go on over to the demo again.

00:35:27.100 --> 00:35:30.950
Let me see if I can bring this up.

00:35:48.830 --> 00:35:52.140
So here I have some Chinese text.

00:35:52.140 --> 00:35:54.860
These characters are
beautiful and concise,

00:35:55.030 --> 00:35:57.450
but one thing that they
don't necessarily do,

00:35:57.590 --> 00:36:00.920
except especially for someone like
me who doesn't read very well,

00:36:00.920 --> 00:36:04.540
is make it obvious how they're
intended to be pronounced.

00:36:04.660 --> 00:36:07.260
So over the years,
there have evolved a number of

00:36:07.260 --> 00:36:12.840
schemes for adding some sort of
phonetic annotation to characters.

00:36:12.980 --> 00:36:17.220
In some cases, the annotation appears
above the characters.

00:36:17.220 --> 00:36:21.270
or in some cases,
it appears beside the characters.

00:36:21.860 --> 00:36:26.270
But either way,
it makes it crystal clear how these

00:36:26.360 --> 00:36:28.330
are intended to be pronounced.

00:36:28.440 --> 00:36:34.590
For example, this is .

00:36:35.690 --> 00:36:40.780
: But fortunately,
the dictionary where I got these

00:36:40.910 --> 00:36:43.400
pronunciations also gave me some clue
as to the meanings of these characters.

00:36:43.820 --> 00:36:47.350
So we can display that,
and that will help us to recognize this

00:36:47.350 --> 00:36:52.250
quotation here from The Art of War,
which might be rendered as,

00:36:52.250 --> 00:36:56.700
"If you know your adversary
and you know yourself,

00:36:56.730 --> 00:37:00.010
you need not fear the result
of a hundred battles."

00:37:01.210 --> 00:37:03.780
So the text system doesn't
have any built-in facilities

00:37:03.780 --> 00:37:05.060
for this sort of thing.

00:37:05.060 --> 00:37:06.280
This is all customization.

00:37:06.280 --> 00:37:08.240
How do we do it?

00:37:08.290 --> 00:37:09.930
Let's take a look.

00:37:17.100 --> 00:37:20.480
What I've done is to define
some custom attributes,

00:37:20.480 --> 00:37:25.440
and I have some code that is fairly
simple and kind of simplistic,

00:37:25.670 --> 00:37:29.260
actually,
that sets these attributes based

00:37:29.450 --> 00:37:32.880
on a dictionary that I provided it.

00:37:32.880 --> 00:37:35.580
What I'm going to show you -- actually,
all this code should be

00:37:35.580 --> 00:37:40.710
available for download from ADC,
if not now, then very soon.

00:37:45.130 --> 00:37:48.180
What I have done is subclass
NSLayoutManager and override

00:37:48.260 --> 00:37:52.580
the primary draw method,
draw griff range at point.

00:37:52.910 --> 00:37:57.580
And so what we're going to do
here is we're given a glyph range.

00:37:57.650 --> 00:37:59.460
We need to look at some
of these attributes.

00:37:59.460 --> 00:38:02.910
So first we convert it
back to a character range.

00:38:03.360 --> 00:38:07.000
Now, before we do any of our own drawing,
we're going to call on the super method

00:38:07.170 --> 00:38:10.200
to actually draw the original glyphs.

00:38:10.200 --> 00:38:15.190
And then the next thing we're going
to do is draw all these annotations.

00:38:15.230 --> 00:38:18.590
And it's actually not that complicated.

00:38:18.720 --> 00:38:26.190
What we do is go through the text,
the characters in the text storage,

00:38:26.190 --> 00:38:26.940
and we look

00:38:27.660 --> 00:38:31.360
What we do is here,
we look for any characters

00:38:31.430 --> 00:38:34.250
that have our custom attribute.

00:38:34.580 --> 00:38:38.920
We also have calculated what glyph
corresponds to this character,

00:38:38.920 --> 00:38:41.600
and where it's located
as far as the point,

00:38:41.740 --> 00:38:43.440
and where its line lives.

00:38:43.470 --> 00:38:46.420
And then,
you'll remember I talked about all

00:38:46.420 --> 00:38:49.040
the translation that needs to be done.

00:38:49.150 --> 00:38:52.040
Well,
to get from the coordinates of a glyph,

00:38:52.040 --> 00:38:56.600
as the layout manager gives them to you,
to coordinates in your view,

00:38:56.600 --> 00:39:01.400
you need to translate by the origin of
the line rectangle that it lives in,

00:39:01.400 --> 00:39:04.480
and by the origin of the container.

00:39:04.500 --> 00:39:05.880
and all that is available.

00:39:05.880 --> 00:39:07.860
That is a very standard idiom.

00:39:09.720 --> 00:39:23.870
And we also get some information about
the glyph and the font that we're

00:39:23.870 --> 00:39:23.870
going to use in doing our sizing.

00:39:23.870 --> 00:39:23.870
So the value of this attribute is
just the little string that we're

00:39:23.870 --> 00:39:23.870
going to show as an annotation.

00:39:24.110 --> 00:39:28.430
And basically all we do is figure
out a rect where we want to put it

00:39:28.440 --> 00:39:32.190
and some attributes to draw it with,
and just draw it.

00:39:33.920 --> 00:39:39.420
The bottom annotations for the
meanings are essentially the same.

00:39:39.420 --> 00:39:43.800
The right annotations,
the are a little more complicated

00:39:43.800 --> 00:39:47.160
because in that case each glyph
has to be positioned individually.

00:39:47.240 --> 00:39:51.200
But I'll let you look at that
once you've downloaded this.

00:39:56.080 --> 00:39:58.940
That, I think, is all of this.

00:39:59.020 --> 00:40:01.500
So let us go back to the slides.

00:40:11.070 --> 00:40:14.600
Now we come to the most
difficult part of the talk,

00:40:14.700 --> 00:40:18.180
where we discuss NS-TypeSetter.

00:40:18.490 --> 00:40:25.910
As I said, NS-TypeSetter is a class that
actually performs the layout.

00:40:27.610 --> 00:40:30.980
And that's what mainly
makes this topic so complex,

00:40:31.150 --> 00:40:33.580
because layout is inherently complex.

00:40:33.600 --> 00:40:38.020
NS-Typesetter itself is a
mostly abstract superclass.

00:40:38.040 --> 00:40:41.830
If you wanted to provide your
own complete layout engine

00:40:41.830 --> 00:40:44.860
and entirely replace the one
that the text system uses,

00:40:44.860 --> 00:40:48.760
then you can subclass
NS-Typesetter directly.

00:40:48.760 --> 00:40:52.040
But most people are probably
not going to want to do that.

00:40:52.040 --> 00:40:57.320
The main concrete subclass of
NS-Typesetter is NSATS-Typesetter,

00:40:57.320 --> 00:41:03.550
which performs the
standard system layout.

00:41:03.620 --> 00:41:06.150
And if you want to use
that for the most part,

00:41:06.150 --> 00:41:11.180
but make some minor modifications to it,
then you can subclass NSATS-Typesetter.

00:41:11.220 --> 00:41:13.610
Now this is new for Panther.

00:41:13.610 --> 00:41:16.700
A new class, lots of new public API.

00:41:16.860 --> 00:41:20.270
NSATS-Typesetter actually existed before,
but it was completely private.

00:41:20.280 --> 00:41:22.040
The methods were all different,
so you can't use it.

00:41:22.040 --> 00:41:23.790
before Panther.

00:41:24.880 --> 00:41:32.000
Now, what generally happens is that when
the layout manager needs a certain

00:41:32.000 --> 00:41:34.940
portion of text to be laid out,
it calls on the typesetter and asks it

00:41:34.940 --> 00:41:36.790
to lay out a certain number of lines.

00:41:36.800 --> 00:41:43.130
Then the typesetter goes back to the
layout manager to get information about

00:41:43.130 --> 00:41:48.810
the glyphs that need to be laid out,
and it goes to the text container to

00:41:48.820 --> 00:41:49.820
get information about the geometry,
where the lines can be placed.

00:41:50.190 --> 00:41:51.690
It does its thing.

00:41:51.690 --> 00:41:55.710
It does all the layout and
it calls back to the layout

00:41:55.710 --> 00:41:58.420
manager and tells it what it did.

00:41:58.420 --> 00:42:03.380
It tells it where each line went,
which glyphs went in the line,

00:42:03.510 --> 00:42:07.640
and where all the glyphs
are positioned in the line.

00:42:07.730 --> 00:42:11.870
At this point,
the typesetter is allowed to insert or

00:42:11.900 --> 00:42:13.390
modify glyphs in the glyph stream and
it tells the layout manager about that,

00:42:13.390 --> 00:42:13.390
too.

00:42:13.390 --> 00:42:13.390
For example,

00:42:13.720 --> 00:42:20.420
As I said, if it's doing hyphenation,
it may need to insert a hyphen.

00:42:20.420 --> 00:42:23.870
Now, for those of you who
have been waiting for it,

00:42:23.870 --> 00:42:28.990
now in Panther, we have implemented
truncation with ellipses.

00:42:31.210 --> 00:42:34.190
That is now implemented
at the typesetter level,

00:42:34.260 --> 00:42:35.960
so you can use it.

00:42:35.960 --> 00:42:39.240
In that case,
the typesetter would need to work

00:42:39.350 --> 00:42:43.360
with the glyph stream to make
sure the ellipsis is in there.

00:42:43.360 --> 00:42:47.790
It may happen in a number of cases
that certain glyphs need to be modified

00:42:47.790 --> 00:42:49.950
if they appear at the end of a line.

00:42:50.200 --> 00:42:55.240
In that case, the typesetter would have
to do that at this stage,

00:42:55.240 --> 00:42:59.160
because it's only the typesetter that
knows where the end of the line is.

00:42:59.920 --> 00:43:05.730
And NSATS typesetter has a number
of methods and they're divided

00:43:05.810 --> 00:43:10.390
into several different groups
for several different purposes.

00:43:10.490 --> 00:43:15.030
There is an interface that is
intended primarily for subclassers

00:43:15.030 --> 00:43:20.200
who want to modify layout in the
text system and they're allowed

00:43:20.200 --> 00:43:24.430
to do various things to that,
I'll discuss later on.

00:43:24.430 --> 00:43:30.530
There is also a glyph storage
interface to NSATS typesetter that

00:43:30.580 --> 00:43:32.900
has a slightly different purpose.

00:43:32.900 --> 00:43:35.370
The purpose of the
glyph storage interface,

00:43:35.370 --> 00:43:41.120
it may be that in some cases you want to
use NSATS typesetter by itself without

00:43:41.120 --> 00:43:43.700
any of the rest of the text system.

00:43:43.760 --> 00:43:47.680
And what the glyph storage interface
does is to encapsulate all the

00:43:47.740 --> 00:43:50.580
calls that the layout manager,
that the typesetter, excuse me,

00:43:50.580 --> 00:43:53.150
makes back to the remainder
of the text system.

00:43:53.150 --> 00:43:58.730
So you can override that and replace
all this interaction with your own

00:43:58.730 --> 00:44:02.950
custom method of storing glyphs
or storing text or what have you.

00:44:02.950 --> 00:44:10.410
And what this allows you to do is to
make use of the system line layout

00:44:10.410 --> 00:44:13.680
algorithms without having to use
any of the rest of the text system.

00:44:13.700 --> 00:44:16.210
if that is what you want to do.

00:44:19.010 --> 00:44:23.140
But in most cases, if you're going to
subclass in ATS typesetter,

00:44:23.140 --> 00:44:26.330
it's going to be because you want
to make some custom modification

00:44:26.330 --> 00:44:27.860
to the layout that it does.

00:44:27.970 --> 00:44:34.000
So what you can do with this
is that you can be notified

00:44:34.030 --> 00:44:35.650
as the text is being laid out.

00:44:35.650 --> 00:44:40.500
You're allowed to modify the position
and size of the line fragments

00:44:40.760 --> 00:44:42.470
as the lines are being laid out.

00:44:42.470 --> 00:44:46.470
You get some control over line breaking,
hyphenation, and so forth.

00:44:47.060 --> 00:44:48.630
So I have a demo of this.

00:44:48.900 --> 00:44:53.010
Let's go back to the demo machine.

00:45:01.700 --> 00:45:04.240
This is actually the
same demo I had before.

00:45:04.240 --> 00:45:10.420
One thing you'll notice is that as
the annotations appear and disappear,

00:45:10.420 --> 00:45:14.750
the height of the line
changes correspondingly.

00:45:15.180 --> 00:45:22.390
To do that,
I actually subclassed NSTypeSetter.

00:45:23.620 --> 00:45:27.680
and implemented a
particular method it has.

00:45:27.790 --> 00:45:31.480
This is also the means, for example,
by which iChat makes sure that

00:45:31.480 --> 00:45:34.720
the paragraphs of text line
up with the little pictures

00:45:34.750 --> 00:45:37.000
of your buddy on the side.

00:45:37.220 --> 00:45:43.320
And what this method does is the
typesetter subclass gets called

00:45:43.320 --> 00:45:48.240
whenever a line has been laid out,
and you get passed by reference

00:45:48.380 --> 00:45:53.030
the rect for the line,
the glyph range, and the used rect,

00:45:53.030 --> 00:45:58.230
that is, the portion of that rectangle
that was actually occupied

00:45:58.240 --> 00:46:01.330
by text and the baseline,
and you get a chance to modify

00:46:01.330 --> 00:46:05.040
them before they get sent
off to the layout manager.

00:46:05.040 --> 00:46:07.840
So what we're doing
here is fairly simple.

00:46:07.940 --> 00:46:10.070
Again, we're passed in the glyph range.

00:46:10.070 --> 00:46:12.810
We need to convert it
back to a character range.

00:46:12.820 --> 00:46:16.920
And we go through it,
and all we do is we look for our custom

00:46:17.770 --> 00:46:20.740
attributes and see if we find them,
make a note,

00:46:20.740 --> 00:46:23.250
and we look for the font that they
appear in so we can calculate how

00:46:23.250 --> 00:46:24.710
much space is actually needed.

00:46:26.520 --> 00:46:32.970
If we found any and we have some space,
then we add it to the line

00:46:32.970 --> 00:46:34.520
fragment and adjust that.

00:46:34.600 --> 00:46:40.800
[Transcript missing]

00:46:47.720 --> 00:46:51.660
So the line fragment expands,
but only for those lines that actually

00:46:51.660 --> 00:46:54.390
have the characters with this attribute.

00:46:54.460 --> 00:46:55.590
All the rest are unaffected.

00:46:55.600 --> 00:47:03.400
All right, let's go back to the slides.

00:47:12.090 --> 00:47:14.090
So now it's time to wrap up.

00:47:14.090 --> 00:47:20.100
Of course,
there's no longer any opportunity

00:47:20.100 --> 00:47:25.080
to go to any further sessions,
but you will presumably be

00:47:25.080 --> 00:47:30.370
able to view all of these on
DVD or by some other means.

00:47:30.410 --> 00:47:32.980
There have been a number
of other sessions on Cocoa.

00:47:33.030 --> 00:47:38.950
Cocoa Update session discussed
briefly some of the changes

00:47:38.950 --> 00:47:41.050
we made to text for Panther.

00:47:43.070 --> 00:47:47.250
The Cocoa Tips and Tricks session,
as I mentioned earlier today,

00:47:47.250 --> 00:47:50.980
had an example,
actually several examples that made

00:47:50.980 --> 00:47:55.560
use of text for various things,
for adding, in particular for adding

00:47:55.660 --> 00:47:56.780
drawing to the text view.

00:47:56.780 --> 00:47:59.270
So if you're interested in that,
you should probably take

00:47:59.270 --> 00:48:00.440
a look at that session.

00:48:00.440 --> 00:48:05.250
And you can take a look
at the code from that,

00:48:05.250 --> 00:48:07.190
which is, we have verified,
now available for download already.

00:48:07.760 --> 00:48:11.320
And there are a number of other sessions
that may be interesting for those

00:48:11.320 --> 00:48:13.780
of you who want to deal with text.
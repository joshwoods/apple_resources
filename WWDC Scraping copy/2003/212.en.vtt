WEBVTT

00:00:21.210 --> 00:00:28.100
Travis Brown,
Graphics and Imaging Evangelist

00:00:51.110 --> 00:00:56.330
The latest techniques they use in
terms of programmability and various

00:00:56.480 --> 00:01:00.040
different special effects that they can
accomplish with their Radeon products.

00:01:00.100 --> 00:01:04.030
They sort of really let you know
what the outer boundaries of what

00:01:04.030 --> 00:01:07.100
you can do with visual effects,
what the state of the art currently is.

00:01:07.100 --> 00:01:10.660
Because it's also very interesting,
we've had sessions on programmability

00:01:10.660 --> 00:01:13.220
from vertex programming
and fragment programming,

00:01:13.220 --> 00:01:16.100
and that was sort of an
entree into this whole topic.

00:01:16.100 --> 00:01:20.220
The interesting thing is we're
fortunate enough to really gain

00:01:20.220 --> 00:01:21.100
all this programming knowledge.

00:01:21.160 --> 00:01:23.270
We've gained all this programmability
and fantastic graphical power

00:01:23.360 --> 00:01:25.100
through the efforts of our
hardware partners like ATI,

00:01:25.120 --> 00:01:28.160
who are really truly out there
creating the silicon that does

00:01:28.160 --> 00:01:30.100
these incredible digital effects.

00:01:30.250 --> 00:01:33.910
So it's my pleasure to invite
Alex Vlachos to the stage to take

00:01:33.910 --> 00:01:36.090
you through the presentation.

00:01:36.090 --> 00:01:36.100
Thank you.

00:01:42.000 --> 00:01:43.000
All right, good afternoon.

00:01:43.000 --> 00:01:44.640
How's everyone doing?

00:01:44.640 --> 00:01:45.240
Excellent.

00:01:45.240 --> 00:01:47.170
All right, so where are we?

00:01:47.180 --> 00:01:48.000
Sorry, my bad.

00:01:48.000 --> 00:01:48.640
We're already at that slide.

00:01:48.640 --> 00:01:49.990
So my name is Alex Vlachos.

00:01:49.990 --> 00:01:50.680
I'm from ATI.

00:01:50.750 --> 00:01:53.250
I'm part of the 3D
Application Research Group.

00:01:53.400 --> 00:01:56.310
My primary role at ATI is I'm
the lead programmer and general

00:01:56.310 --> 00:01:57.840
team lead of the demo team.

00:01:57.840 --> 00:02:01.290
So we're responsible for making all
the demos for the latest Radeon cards,

00:02:01.290 --> 00:02:03.400
the 9700 and beyond in the past.

00:02:03.440 --> 00:02:05.230
On my left is Rav Dhiraj.

00:02:05.230 --> 00:02:10.100
He's part of our Mac development team,
and he's responsible for doing

00:02:10.160 --> 00:02:11.880
the Mac-specific code in our demo.

00:02:12.000 --> 00:02:16.540
So we're going to be showing a few
different demos today running on OS X.

00:02:16.540 --> 00:02:20.470
And basically, our demo engines,
like some game engines,

00:02:20.470 --> 00:02:22.980
are cross-platform, cross-API.

00:02:22.980 --> 00:02:27.020
So our demos run on three
different sort of combinations.

00:02:27.020 --> 00:02:30.020
We run on the Mac through OS X,
and OpenGL,

00:02:30.020 --> 00:02:35.240
and we run on the PC through OpenGL,
and also on the PC through DirectX.

00:02:35.300 --> 00:02:38.290
So all our demos run on all
three platforms consistently,

00:02:38.290 --> 00:02:39.690
which is interesting.

00:02:39.700 --> 00:02:41.880
So the things I'm going
to be talking about today.

00:02:42.000 --> 00:02:44.450
are these three topics.

00:02:44.470 --> 00:02:47.080
The first thing I'm going to
talk about is Normal Mapper.

00:02:47.120 --> 00:02:52.000
So in the Radeon 9700 Car Paint demo,
we used what we call a Normal Map.

00:02:52.090 --> 00:02:55.880
And we have this Normal Map tool,
which will be available on the Mac soon,

00:02:55.880 --> 00:02:57.120
sometime in the next week or two.

00:02:57.180 --> 00:02:59.980
Then I'm going to talk about
a few video effects and more

00:02:59.980 --> 00:03:01.880
scene post-processing effects.

00:03:01.930 --> 00:03:05.250
So as graphics and hardware
gets more and more interesting,

00:03:05.360 --> 00:03:08.410
and the APIs are there,
you can post-process your scene and

00:03:08.500 --> 00:03:10.340
do some really interesting things.

00:03:10.340 --> 00:03:13.780
So we're going to show some
post-processing effects on live video.

00:03:13.780 --> 00:03:16.030
We just have a camera set
up that was all handed out,

00:03:16.040 --> 00:03:17.460
the nice new camera.

00:03:17.460 --> 00:03:20.120
So we're going to be showing
the effects on live video.

00:03:20.190 --> 00:03:22.860
Then the last thing we're going to
talk about are the shadow techniques we

00:03:22.860 --> 00:03:25.840
used in the Animusic Pipe Dream demo.

00:03:25.840 --> 00:03:27.800
How many people have
seen the Pipe Dream demo?

00:03:27.840 --> 00:03:30.570
Okay, how many people have
seen the Car Paint demo?

00:03:30.640 --> 00:03:31.540
A few?

00:03:31.540 --> 00:03:31.840
Okay.

00:03:31.840 --> 00:03:34.750
So we're going to talk about how we
did the shadow techniques in there.

00:03:34.840 --> 00:03:36.840
We didn't just brute force
do stencil shadow vinyls,

00:03:36.840 --> 00:03:38.130
we did some more interesting things.

00:03:38.140 --> 00:03:39.340
So we'll talk about those three things.

00:03:41.080 --> 00:03:43.380
All right, so the normal mapper tool.

00:03:43.400 --> 00:03:49.080
The normal mapper tool basically is a
tool to generate high-res normal match.

00:03:49.080 --> 00:03:53.410
It's a way to make your low-res
models look really high-res.

00:03:53.480 --> 00:03:55.480
And so why don't we
jump into the demo now,

00:03:55.480 --> 00:03:57.280
to the demo machine.

00:03:57.590 --> 00:04:01.340
and we got the run demo machine two.

00:04:01.430 --> 00:04:02.250
Okay, thanks.

00:04:02.390 --> 00:04:04.250
So this is the Carpain demo.

00:04:04.480 --> 00:04:07.930
It's a nice Ferrari, the car I want.

00:04:08.500 --> 00:15:06.300
[Transcript missing]

00:15:06.770 --> 00:15:08.620
The next thing we're going to talk about,
the next section,

00:15:08.620 --> 00:15:10.340
is some post-processing effects.

00:15:10.340 --> 00:15:13.150
We're going to talk about
four different effects.

00:15:13.160 --> 00:15:14.340
One is sepia tone.

00:15:14.340 --> 00:15:17.690
Sepia tone is a way to do
sort of antique pictures,

00:15:17.730 --> 00:15:18.780
basically.

00:15:18.780 --> 00:15:21.420
The next one is going to
be Sobel edge detection.

00:15:21.420 --> 00:15:24.360
Edge detection filters are really
useful for a lot of things,

00:15:24.360 --> 00:15:27.800
especially NPR rendering,
non-photorealistic rendering.

00:15:27.800 --> 00:15:31.010
Then we're going to
show posterized effect,

00:15:31.070 --> 00:15:33.940
which is an NPR effect that will
also use the edge detection.

00:15:34.200 --> 00:15:38.220
And we're just going to touch
on for a minute real-time FFTs,

00:15:38.280 --> 00:15:39.520
fast-forward transforms.

00:15:39.520 --> 00:15:42.290
So, sepia tone.

00:15:42.340 --> 00:15:44.980
Can we jump over to the demo machine?

00:15:47.540 --> 00:15:50.780
Okay, so here's some live video of me.

00:15:50.930 --> 00:15:51.190
Great.

00:15:51.200 --> 00:15:53.660
So this is basically what the camera is.

00:15:53.660 --> 00:15:54.900
We've got to apologize
for the resolution.

00:15:54.900 --> 00:15:56.600
We had to use this camera
because it's so cool.

00:15:56.600 --> 00:15:59.290
But it's only at 640 by 480.

00:15:59.300 --> 00:16:01.310
So there's sepia tone,
so I can just sort of

00:16:01.310 --> 00:16:02.560
switch back and forth.

00:16:02.600 --> 00:16:06.900
Right, so sepia tone is meant to look
like a sort of antique picture.

00:16:06.900 --> 00:16:08.500
And this can be used in games.

00:16:08.500 --> 00:16:10.500
There's a lot of times where you
want to do flashback scenes or

00:16:10.500 --> 00:16:12.980
whatnot to make it look like,
you know, you just want to go grayscale,

00:16:12.980 --> 00:16:13.900
that's kind of boring.

00:16:13.900 --> 00:16:15.790
But there's a way to,
instead of going grayscale,

00:16:15.800 --> 00:16:17.800
it's a sort of sepia way of doing things.

00:16:17.940 --> 00:16:20.330
So we jump back to the slide deck.

00:16:21.000 --> 00:19:18.500
[Transcript missing]

00:19:19.460 --> 00:19:22.600
All right, so do you want to explain the
difference between sort of the

00:19:22.600 --> 00:19:23.400
vertical and the horizontal?

00:19:23.470 --> 00:19:26.300
Yeah, so basically there's the
Sobel Edge Detection,

00:19:26.300 --> 00:19:28.630
when we flip the whole thing on,
the final result,

00:19:28.700 --> 00:19:32.700
is a way to look at your
image and find all the edges.

00:19:32.740 --> 00:19:35.160
We have this camera,
it's a little noisy right now,

00:19:35.160 --> 00:19:36.980
so you've got a lot of
extra little dots up there,

00:19:36.980 --> 00:19:39.820
but essentially it passes a filter over,
two different filters,

00:19:39.820 --> 00:19:42.540
one to find the horizontal edges
and one to find the vertical edges.

00:19:42.540 --> 00:19:45.570
Why don't we jump in and just
show the horizontal edges?

00:19:46.210 --> 00:19:48.900
Okay, so the horizontal edges,
if you look at that thing

00:19:49.220 --> 00:19:52.630
right behind me there,
you see just these sort of horizontal

00:19:52.890 --> 00:19:55.210
lines here at the top and bottom.

00:19:55.220 --> 00:19:58.030
If we go to the vertical edges,
you get those vertical,

00:19:58.040 --> 00:20:01.160
the two left sides,
and when you have both of them up there,

00:20:01.160 --> 00:20:04.020
then you get all the edges
basically in your scene.

00:20:04.040 --> 00:20:05.870
Can we go back to the slides, please?

00:20:07.460 --> 00:20:11.360
Okay, so edge detection is just,
the Sobel edge detection

00:20:11.360 --> 00:20:12.400
filter is really simple.

00:20:12.400 --> 00:20:14.460
It's just two kernels,
your horizontal kernel down

00:20:14.460 --> 00:20:15.860
here and your vertical kernel.

00:20:15.860 --> 00:20:18.930
So for the pixel in the middle,
if you're trying to calculate

00:20:18.930 --> 00:20:21.450
what the value is there,
you take into account the

00:20:21.450 --> 00:20:24.510
three pixels above and below
it and you weight them with 1,

00:20:24.510 --> 00:20:28.980
2, negative 1, negative 2 appropriately,
and you just combine those pixels and

00:20:29.070 --> 00:20:31.490
you end up with your horizontal kernel,
sorry,

00:20:31.490 --> 00:20:33.900
your horizontal edge detection value.

00:20:33.910 --> 00:20:36.520
Do the same thing for your vertical
kernel and you get the vertical value.

00:20:37.400 --> 00:20:38.920
And here's sort of the output again.

00:20:38.920 --> 00:20:41.120
If you look at the picture
down here on the lower left,

00:20:41.160 --> 00:20:44.620
you can see just the horizontal, sorry,
the vertical edges versus the horizontal

00:20:44.670 --> 00:20:46.220
ones up top and they get combined.

00:20:46.230 --> 00:20:49.980
So this is used a lot
in NPR looking effects.

00:20:49.980 --> 00:20:51.340
And here's the Sobel code.

00:20:51.340 --> 00:20:53.370
I mean, it's pretty straightforward.

00:20:53.370 --> 00:20:56.740
You basically do eight texel fetches
up front down here at the bottom,

00:20:56.740 --> 00:21:00.200
and then based on those eight fetches,
which are the eight surrounding

00:21:00.200 --> 00:21:03.020
pixels around your main pixel,
you can then take the top and

00:21:03.070 --> 00:21:07.180
bottom three and the left and right
three appropriately on the right.

00:21:07.330 --> 00:21:09.480
and combine them to do,
to come up with that value.

00:21:09.480 --> 00:21:18.780
Okay, so the next effect is
an NPR posterized style.

00:21:18.800 --> 00:21:20.680
Now, we're going to use the
edge detection on this,

00:21:20.680 --> 00:21:22.400
and this is sort of,
this is sort of inspired

00:21:22.400 --> 00:21:23.940
by this movie Walking Life.

00:21:24.020 --> 00:21:27.340
There's this edge preserving,
it's called a Kuwahara filter,

00:21:27.340 --> 00:21:32.680
that basically does,
gives you this nice look, right,

00:21:32.680 --> 00:21:35.090
that gives you this sort
of NPR posterized look,

00:21:35.150 --> 00:21:36.060
which I'll talk about in a second.

00:21:36.390 --> 00:21:38.070
What we're going to do is
we're going to composite our,

00:21:38.080 --> 00:21:39.730
so our edges on top of that.

00:21:39.800 --> 00:21:42.250
So, can we jump over to the demo?

00:21:42.260 --> 00:21:42.760
Here we go.

00:21:42.760 --> 00:21:43.450
All right.

00:21:43.500 --> 00:21:45.760
All right,
so here's the non-posterized output.

00:21:45.760 --> 00:21:46.910
We're going to turn it on.

00:21:46.920 --> 00:21:48.060
I'm going to have to apologize.

00:21:48.060 --> 00:21:48.960
It's going to be hard to see.

00:21:48.960 --> 00:21:50.940
The lighting conditions aren't ideal.

00:21:50.940 --> 00:21:51.800
There you go.

00:21:51.800 --> 00:21:54.280
So, unposterized, posterized.

00:21:54.280 --> 00:21:56.470
You can do a couple
different passes to sort of,

00:21:56.540 --> 00:21:59.980
so if Alex can just sort of jump around,
you can kind of see him.

00:21:59.980 --> 00:22:00.530
Jump around.

00:22:02.700 --> 00:22:04.200
I'll pass on the jumping.

00:22:04.200 --> 00:22:04.660
There you go.

00:22:04.710 --> 00:22:08.190
That's posterization in real time.

00:22:08.210 --> 00:22:11.780
Okay, so if we go back to the slides,

00:22:12.380 --> 00:22:16.140
So this is the posterized output when
we have really good lighting conditions.

00:22:16.140 --> 00:22:22.000
This is part of our Mac driver
team coming out of a meeting,

00:22:22.000 --> 00:22:23.200
and we snagged them and said,
stand there,

00:22:23.200 --> 00:22:24.330
we need an image for our slide.

00:22:24.340 --> 00:22:27.900
So that's what the output looks like.

00:22:27.960 --> 00:22:30.880
Okay, so a core Hara filter is this.

00:22:30.920 --> 00:22:33.450
Essentially, for the pixel in the middle
of this kernel here that

00:22:33.450 --> 00:22:35.390
we're trying to calculate,
here's what we have to do.

00:22:35.400 --> 00:22:38.050
We take four quadrants of pixels.

00:22:38.060 --> 00:22:40.370
Each quadrant is a 3x3 pixel area.

00:22:40.620 --> 00:22:42.820
The upper left quadrant
is sort of the pink area,

00:22:42.820 --> 00:22:47.820
and we have the green area, the,
I guess it's orangish, and blue.

00:22:47.820 --> 00:22:49.690
And they all overlap
by one row of pixels.

00:22:49.700 --> 00:22:52.800
So each 3x3 kernel,
each 3x3 quadrant there,

00:22:52.800 --> 00:22:57.180
what we do is we calculate the mean
and the variance for each one of those.

00:22:57.180 --> 00:23:04.600
The mean color and the total variance
of color in that 3x3 quadrant.

00:23:04.600 --> 00:23:07.250
Once we have those four values,
for each one of these quadrants

00:23:07.250 --> 00:23:09.900
we have the mean and variance,
we then look at them and say,

00:23:10.030 --> 00:23:13.070
and we figure out which one has,
which one of those four quadrants

00:23:13.200 --> 00:23:14.580
has the smallest variance.

00:23:14.580 --> 00:23:17.410
Whichever one does, that's,
we just use the mean

00:23:17.410 --> 00:23:18.850
color from that section.

00:23:18.900 --> 00:23:20.140
And it's that simple.

00:23:20.180 --> 00:23:25.620
We just look at those four quadrants,
figure out which one has

00:23:25.620 --> 00:23:27.790
the smallest variance,
and pick that one's color.

00:23:28.050 --> 00:23:28.370
Done.

00:23:28.440 --> 00:23:29.450
It's that simple.

00:23:29.460 --> 00:23:31.510
So here's basically, that's the idea.

00:23:31.520 --> 00:23:33.060
The implementation is basically that.

00:23:33.120 --> 00:23:36.560
We do this two pass effect,
and essentially the way we speed this up,

00:23:36.560 --> 00:23:38.340
instead of doing these
brute force calculations,

00:23:38.720 --> 00:23:41.990
is we do, we basically do two passes
over the final image.

00:23:42.260 --> 00:23:46.000
The first pass calculates the
mean and variance for each unique

00:23:46.000 --> 00:23:48.210
3x3 area in the whole image.

00:23:48.280 --> 00:23:49.320
That's one pass.

00:23:49.320 --> 00:23:52.630
We store that off and we render
that into an off screen texture.

00:23:52.680 --> 00:23:56.680
Then we do another pass through
it and we fetch from that texture

00:23:56.750 --> 00:23:59.380
to get the four quadrants out.

00:23:59.400 --> 00:24:03.040
Those four mean and variance values.

00:24:03.120 --> 00:24:05.750
And in our shader we then
do the comparison and just

00:24:05.750 --> 00:24:07.300
write out the right color.

00:24:07.360 --> 00:24:08.500
So we can get this down to two.

00:24:08.500 --> 00:24:09.330
So we get this down to two passes.

00:24:09.340 --> 00:24:09.840
Really simple.

00:24:09.840 --> 00:24:10.640
It's all image space.

00:24:10.640 --> 00:24:11.540
It's a constant overhead.

00:24:11.600 --> 00:24:14.940
The interesting thing about post
processing effects is that it

00:24:15.280 --> 00:24:17.400
really is just constant overhead.

00:24:17.400 --> 00:24:19.600
It doesn't matter what
you rendered that scene,

00:24:19.600 --> 00:24:21.680
whether you rendered one
polygon or two million polygons,

00:24:21.680 --> 00:24:23.910
it's the same overhead because
you're just doing the same math.

00:24:24.000 --> 00:24:25.260
It's a fixed number of pixels.

00:24:25.260 --> 00:24:27.000
So it's great for games.

00:24:27.000 --> 00:24:29.180
You don't have to worry about the
complexity of your game as long

00:24:29.180 --> 00:24:30.870
as you have a few frames to spare.

00:24:30.940 --> 00:24:32.400
You can do that kind of stuff.

00:24:32.400 --> 00:24:39.360
So here's the fragment shader code,
which basically shows how do we

00:24:39.360 --> 00:24:40.560
compute the mean and variance.

00:24:40.580 --> 00:24:42.000
You can rip through this later.

00:24:42.000 --> 00:24:42.970
There's slides online.

00:24:43.120 --> 00:24:45.270
But basically you just
kind of go through,

00:24:45.520 --> 00:24:49.200
fetch your full three by three area
of pixels and do your computations.

00:24:49.200 --> 00:24:51.940
Then we have the variance selection,
how we actually fetch from those,

00:24:52.010 --> 00:24:53.380
make those so dead center here.

00:24:53.380 --> 00:24:54.810
You have those four text operations.

00:24:54.880 --> 00:24:57.400
We fetch four pixels from
that off screen buffer.

00:24:57.460 --> 00:25:00.490
And then we do the comparisons down
at the bottom half here and say,

00:25:00.490 --> 00:25:03.430
which one has the lowest variance?

00:25:03.520 --> 00:25:06.050
And then we use the
color for that to output.

00:25:06.160 --> 00:25:08.000
Pretty straightforward.

00:25:08.060 --> 00:25:09.380
forward.

00:25:10.750 --> 00:25:15.030
Okay, the last section of this,
the last part of this

00:25:15.030 --> 00:25:17.860
middle section is FFTs,
Fast Fourier Transforms.

00:25:17.860 --> 00:25:19.100
These are really useful.

00:25:19.100 --> 00:25:23.350
Anyone that's vaguely familiar with image
processing knows that this is used a lot,

00:25:23.390 --> 00:25:26.840
and this is something that we
can actually now do in hardware.

00:25:26.840 --> 00:25:30.560
The Radeon 9700 family products
and other similar products that can

00:25:30.560 --> 00:25:34.120
actually do full floating point,
that has full floating point precision

00:25:34.120 --> 00:25:37.140
and able to render out to a texture,
32-bit float textures,

00:25:37.250 --> 00:25:39.820
you can do some really
interesting stuff now.

00:25:39.820 --> 00:25:44.230
So here's basically a test
pattern on the left here,

00:25:44.230 --> 00:25:47.970
a very common test pattern for FFTs.

00:25:48.120 --> 00:25:49.570
And this is pasting,
this is output from one

00:25:49.570 --> 00:25:50.450
of our in-house demos.

00:25:50.450 --> 00:25:53.520
We haven't released this one yet,
but it's coming soon.

00:25:53.520 --> 00:25:56.250
And this basically
shows the two different,

00:25:56.740 --> 00:25:59.350
the frequency domain and the
spatial domain of the FFT.

00:25:59.390 --> 00:26:01.650
That's all I really want to say about it.

00:26:01.660 --> 00:26:03.760
It's something that we're working on
that we can actually start to apply.

00:26:03.760 --> 00:26:06.820
So this is sort of stuff that's
in the works right now at ATI.

00:26:06.820 --> 00:26:11.690
We're starting to apply this,
use to do some image processing effects.

00:26:12.560 --> 00:26:13.950
Okay,
so we talked about those four things:

00:26:13.970 --> 00:26:17.400
sepia tones, edge detection,
posterization, and FFTs.

00:26:17.650 --> 00:26:23.240
Which brings us to the final section,
which is the shadow techniques we

00:26:23.260 --> 00:26:25.650
used in the PipeDream Animusic demo.

00:26:25.930 --> 00:26:28.740
How many people have
seen this demo already?

00:26:28.790 --> 00:26:29.400
A few of you.

00:26:29.400 --> 00:26:34.280
Okay, why don't we jump over to
Demo Machine 2 with audio.

00:26:35.220 --> 00:26:37.340
Do we have the audio hooked up for this?

00:26:37.390 --> 00:26:38.490
Okay.

00:26:38.670 --> 00:26:38.800
Great.

00:26:38.800 --> 00:26:41.830
So this Pipe Dream demo,
this is something we first saw at

00:26:41.900 --> 00:26:45.320
SIGGRAPH Electronic Theater 2001,
I think.

00:26:45.580 --> 00:26:46.740
Yeah, 2001.

00:26:46.770 --> 00:26:49.440
And we were watching that, and we looked,
sitting there in the audience and said,

00:26:49.440 --> 00:26:52.340
"We have to do this in real time as
soon as we can." And as it turns out,

00:26:52.380 --> 00:26:53.910
the next trip we were doing,
we kind of went back to the

00:26:53.910 --> 00:26:55.860
office and thought about it,
and I realized, "You know what?

00:26:55.860 --> 00:27:01.630
I think we can do this demo in real
time." And so here's it running on OS X.

00:27:01.700 --> 00:27:04.300
This was one of the launch demos for the,
this was the main launch

00:27:04.300 --> 00:27:06.100
demo for the 9700 product.

00:27:06.300 --> 00:27:09.020
Family,
I'll let this run for a minute for

00:27:09.020 --> 00:27:10.780
those of you who haven't seen it.

00:27:21.300 --> 00:27:25.300
We're going to do the beta build
of our demo engine on OS X.

00:27:25.300 --> 00:27:28.910
So we're pretty much feature
complete at this point.

00:27:44.300 --> 00:27:46.000
So if you notice all the
shadows that are happening,

00:27:46.000 --> 00:27:48.660
the dynamic shadows and the
shadows globally in this scene.

00:27:48.660 --> 00:27:52.620
So we wanted to implement this and do
this as one of our main launch demos.

00:27:52.620 --> 00:27:54.860
And one of the things we realized was,
the first thing we asked

00:27:54.860 --> 00:27:57.310
ourselves was how are we going
to do the shadows in this scene?

00:27:57.320 --> 00:27:59.280
Because the geometric
complexity is really high.

00:27:59.280 --> 00:28:02.610
This scene, on average,
we render about 400,000

00:28:02.660 --> 00:28:04.460
polygons per frame in this demo.

00:28:04.460 --> 00:28:07.070
It peaks at around 550,000
polygons per frame.

00:28:07.080 --> 00:28:09.320
So there's quite a bit
of geometry in here.

00:28:09.320 --> 00:28:12.200
And yeah, here we're at about 400,000.

00:28:12.320 --> 00:28:15.100
So we're trying to figure out
how do we do the shadows in this?

00:28:15.100 --> 00:28:19.390
We wanted to, as writing graphics demos,
we wanted to sort of keep up with what

00:28:19.390 --> 00:28:23.220
games will look like in a year down
the road as developers start to take

00:28:23.350 --> 00:28:25.380
advantage of these latest features.

00:28:25.380 --> 00:28:28.120
So we looked at a few games that are in
development and games out there and said,

00:28:28.140 --> 00:28:30.790
let's stick with full-scene
stencil shadow volumes.

00:28:30.800 --> 00:28:32.680
How many people are familiar
with stencil shadow volumes?

00:28:32.680 --> 00:28:38.550
Okay, so basically it's a technique that
lets you render hard shadows globally,

00:28:38.550 --> 00:28:39.280
right?

00:28:39.370 --> 00:28:42.140
In the past,
developers have used shadow textures.

00:28:42.320 --> 00:28:43.420
Light maps, right?

00:28:43.420 --> 00:28:45.810
That sort of bake in
your lighting globally.

00:28:45.820 --> 00:28:47.180
But it's sort of soft.

00:28:47.210 --> 00:28:49.600
It's not very exact.

00:28:49.600 --> 00:28:50.590
It's not hard shadows.

00:28:50.600 --> 00:28:54.120
And there's a way to do dynamic shadows,
dynamic objects that cast shadows

00:28:54.120 --> 00:28:55.450
that look nice and hard and crisp.

00:28:55.460 --> 00:28:59.080
And that's sort of how games are going to
be looking for the next couple of years.

00:28:59.080 --> 00:28:59.980
So we wanted to stick with that.

00:28:59.980 --> 00:29:02.060
So we first went through this.

00:29:02.110 --> 00:29:02.960
We got the scene up and running.

00:29:02.960 --> 00:29:05.340
And we turned on stencil
shadow volumes globally.

00:29:05.340 --> 00:29:08.340
And our performance was somewhere
around two frames a second.

00:29:08.360 --> 00:29:10.500
And we realized we can't do that.

00:29:10.520 --> 00:29:12.270
There's just way too much geometry.

00:29:12.290 --> 00:29:16.840
The overdraw on any given pixel
on average was near 100 at points.

00:29:16.840 --> 00:29:19.740
Because of all these different volumes,
all these different pieces of geometry.

00:29:19.740 --> 00:29:23.520
These things up here are just insane,
the amount of overdraw.

00:29:23.520 --> 00:29:25.300
Especially if you look
at that from the side,

00:29:25.340 --> 00:29:26.740
you get a lot of overdraw there.

00:29:26.740 --> 00:29:29.060
So I'll talk a bit about
that in a minute or so.

00:29:29.060 --> 00:29:34.390
Rav, can you sort of pause this or
come out of the fly-through mode?

00:29:34.400 --> 00:29:36.660
Yeah, and fly over here to the left.

00:29:36.720 --> 00:29:37.420
Okay, there we go.

00:29:37.420 --> 00:29:38.320
Let's zoom up on this area here.

00:29:38.320 --> 00:29:40.070
So here's what we do.

00:29:40.080 --> 00:29:41.640
We have to zoom out.

00:29:42.320 --> 00:29:44.230
There's two different kinds
of geometry in our engine.

00:29:44.240 --> 00:29:47.320
There's something we call static
geometry and then dynamic geometry.

00:29:47.320 --> 00:29:49.850
So static geometry,
so this is the dynamic geometry.

00:29:49.860 --> 00:29:51.850
This is the geometry in our
world that actually moves,

00:29:51.880 --> 00:29:53.070
that's animated in some way.

00:29:53.080 --> 00:29:53.630
Right?

00:29:53.660 --> 00:29:56.620
So these are the only pieces of
geometry that cast shadows dynamically.

00:29:56.620 --> 00:29:58.080
This is our static geometry.

00:29:58.080 --> 00:29:59.880
This is all the geometry
that never changes.

00:29:59.880 --> 00:30:00.460
It's baked in.

00:30:00.460 --> 00:30:00.930
It's not moving.

00:30:00.940 --> 00:30:01.920
There's nothing animated about it.

00:30:01.920 --> 00:30:04.650
So this, we can do something
different with for shadows.

00:30:04.680 --> 00:30:08.960
We have two different shadow techniques
that we combine to do our overall shadow.

00:30:08.960 --> 00:30:11.270
Shadow.

00:30:11.280 --> 00:30:12.090
So if you zoom in here.

00:30:12.100 --> 00:30:12.280
Rav, can you zoom in?

00:30:12.280 --> 00:30:14.220
Rav, on the left,
if we look at that shadow

00:30:14.220 --> 00:30:15.520
area right up here.

00:30:15.520 --> 00:30:17.950
So we use this technique that
I'm calling shadow cutting.

00:30:17.960 --> 00:30:21.570
So what we do is we actually cut
the shadows directly into the scene.

00:30:21.580 --> 00:30:24.300
So if you turn on wireframe here,
these are static shadows here.

00:30:24.300 --> 00:30:25.780
This is geometry.

00:30:25.800 --> 00:30:29.650
We actually cut the shadows
directly into the scene right here.

00:30:29.680 --> 00:30:32.250
Hit page up a bunch.

00:30:32.280 --> 00:30:34.420
So we just press A to pause the lighting.

00:30:34.420 --> 00:30:37.120
So you'll see we actually,
the artists don't do this manually.

00:30:37.120 --> 00:30:38.600
They would.

00:30:38.600 --> 00:30:40.030
They'd quit if I made them do that.

00:30:40.040 --> 00:30:41.540
So we.

00:30:42.160 --> 00:30:43.860
So we automatically generate this stuff.

00:30:43.930 --> 00:30:44.580
We figure out.

00:30:44.690 --> 00:30:45.480
We basically cache.

00:30:45.480 --> 00:30:48.560
Do shadow cutting,
which I'll explain now.

00:30:48.560 --> 00:30:51.060
Can we jump back to the slides, please?

00:30:52.800 --> 00:30:53.800
Thanks.

00:30:53.800 --> 00:30:58.370
OK, so static shadows, like I said,
it's a great opportunity to not do

00:30:58.440 --> 00:31:00.560
stencil shadow volumes globally,
because their shadow

00:31:00.560 --> 00:31:01.540
volumes don't change.

00:31:01.540 --> 00:31:02.380
They don't ever change.

00:31:02.380 --> 00:31:07.590
And a lot of those shadows won't
cast geometry onto dynamic objects.

00:31:07.590 --> 00:31:09.640
So you don't need their shadow volumes,
right?

00:31:09.640 --> 00:31:12.270
So for a lot of those things,
you can optimize this out.

00:31:12.350 --> 00:31:15.800
So here's where we just
showed the before and after.

00:31:15.800 --> 00:31:17.990
This is what you see,
which looks like shadow volumes,

00:31:17.990 --> 00:31:19.280
which I'll get to in a minute.

00:31:19.320 --> 00:31:21.380
But instead,
we're actually cutting the shadows

00:31:21.380 --> 00:31:22.960
straight into our scene geometry.

00:31:22.960 --> 00:31:27.100
And so the advantage is, like I said,
is it looks just like

00:31:27.100 --> 00:31:29.700
stencil shadow volumes,
right?

00:31:29.700 --> 00:31:33.180
This is what some very well-known,
soon-to-be-released games

00:31:33.180 --> 00:31:34.980
are going to be doing,
right?

00:31:35.000 --> 00:31:35.940
Global stencil shadow volumes.

00:31:35.940 --> 00:31:37.740
So it's going to look
hard shadows everywhere,

00:31:37.740 --> 00:31:38.680
which is what we wanted.

00:31:38.680 --> 00:31:40.240
But we obviously have to cheat a lot.

00:31:40.260 --> 00:31:42.250
We're not going to do
full shadow volumes.

00:31:42.280 --> 00:31:43.810
We need to run more than
two frames a second.

00:31:43.820 --> 00:31:48.980
So the interesting thing is that
since we separate out our geometry,

00:31:48.980 --> 00:31:52.070
so you're probably thinking,
isn't it more expensive?

00:31:52.080 --> 00:31:54.210
You have more geometry now that
you diced your geometry up,

00:31:54.220 --> 00:31:54.660
right?

00:31:54.660 --> 00:31:55.960
Isn't that slower to render?

00:31:55.960 --> 00:31:58.600
The answer turns out to be no,
because if you compare

00:31:58.600 --> 00:32:01.180
it to shadow volumes,
you're rendering these huge

00:32:01.180 --> 00:32:04.160
volumes to your back buffer
that have a lot of overdraw.

00:32:04.160 --> 00:32:06.810
Instead, we're just going to have a
few more vertices to process,

00:32:06.810 --> 00:32:08.400
which is the same,
but a lot less than the

00:32:08.400 --> 00:32:09.580
shadow volume verts.

00:32:09.580 --> 00:32:13.320
And those polygons that...
that we know are in shadow,

00:32:13.320 --> 00:32:15.090
we can actually draw
with a simpler shader,

00:32:15.100 --> 00:32:18.030
because we know that none of our dynamic,
our dominant lights

00:32:18.350 --> 00:32:20.320
really hit those polygons.

00:32:20.350 --> 00:32:23.530
So we don't have to do all the math
that's required for those polygons

00:32:23.540 --> 00:32:25.200
that are in shadow permanently.

00:32:27.830 --> 00:32:29.490
So, here's how we do it.

00:32:29.500 --> 00:32:30.370
We do it with shadow cutting.

00:32:30.380 --> 00:32:31.710
So, it requires beams.

00:32:31.720 --> 00:32:33.840
So, here's just some basics
on what a beam is,

00:32:33.840 --> 00:32:35.120
for those of you who aren't familiar.

00:32:35.120 --> 00:32:36.400
A beam is basically this.

00:32:36.400 --> 00:32:40.590
So, a beam is sort of a
pyramid-shaped volume,

00:32:40.590 --> 00:32:43.510
in a sense, with three sides.

00:32:43.510 --> 00:32:46.280
And so, you have a light position,
this yellow thing up here,

00:32:46.280 --> 00:32:47.500
that's a light source.

00:32:47.500 --> 00:32:50.280
And this polygon, this sort of horizontal
edge at the bottom,

00:32:50.280 --> 00:32:53.270
if you think that the polygon is
actually popping out of the screen,

00:32:53.330 --> 00:32:56.340
right, out of this screen here,
the volume is basically

00:32:56.340 --> 00:33:00.920
the position of the light,
and you calculate four total planes.

00:33:01.020 --> 00:33:04.850
One plane is the point of
the light with each edge,

00:33:05.030 --> 00:33:05.160
right?

00:33:05.160 --> 00:33:07.300
So, each of the three,
three of the four planes are

00:33:07.360 --> 00:33:10.980
calculated by the light position
and the edges of that polygon.

00:33:10.980 --> 00:33:15.700
And the fourth clip plane is the
actual plane of the polygon itself.

00:33:15.700 --> 00:33:19.020
And that gives you,
so depending on which way you

00:33:19.030 --> 00:33:22.550
look at that polygon's plane,
you can have a near beam,

00:33:22.560 --> 00:33:26.060
which is basically anything
in that triangular volume,

00:33:26.550 --> 00:33:28.450
and the third clip plane
is the point of the light,

00:33:28.450 --> 00:33:29.930
which is basically the
position of the light.

00:33:29.940 --> 00:33:36.560
So, you can have a near beam,
which is basically anything

00:33:36.560 --> 00:33:42.210
in that triangular volume,
and the fourth clip plane

00:33:42.210 --> 00:33:47.270
is the point of the light,
which is basically anything

00:33:47.270 --> 00:33:49.950
in that triangular volume,
and the third clip plane is basically

00:33:49.960 --> 00:33:52.940
anything in that triangular volume,
and the fourth clip plane is basically

00:33:53.010 --> 00:33:56.020
anything in that triangular volume,
and the fourth clip plane is basically

00:33:56.020 --> 00:33:57.930
anything in that triangular volume,
the algorithm takes about 20 minutes for

00:33:57.930 --> 00:34:00.130
the entire scene to cut those shadows in.

00:34:00.410 --> 00:34:02.680
That's a pretty complex scene.

00:34:02.690 --> 00:34:05.180
So that timing's not too bad.

00:34:05.180 --> 00:34:06.520
So basically here's what we do.

00:34:06.550 --> 00:34:10.260
For every polygon in our scene,
one at a time, we're going to dice it up.

00:34:10.280 --> 00:34:12.690
We're going to take all the other
polygons in the scene and cut the

00:34:12.690 --> 00:34:15.300
shadows into it based on that geometry,
one at a time.

00:34:15.300 --> 00:34:17.150
So what we do is we'll
call that polygon A.

00:34:17.160 --> 00:34:19.200
Polygon A is for each
polygon in our scene,

00:34:19.200 --> 00:34:22.040
we're going to find all the
polygons that live between that

00:34:22.040 --> 00:34:23.390
polygon and the light source.

00:34:23.420 --> 00:34:28.060
So everything in that polygon's near
beam we're going to say has to cut into

00:34:28.060 --> 00:34:30.900
that polygon and dice it up for shadows.

00:34:30.900 --> 00:34:35.130
So for each polygon A,
we have a bin of polygon Bs.

00:34:35.140 --> 00:34:38.060
For each one of these polygon Bs,
we take its far beam.

00:34:38.060 --> 00:34:40.480
So for polygon B is between.

00:34:40.480 --> 00:34:44.250
So in the case of if this is our
light source here and we're trying to

00:34:44.250 --> 00:34:47.700
cast shadows onto this table surface,
this microphone here has

00:34:47.700 --> 00:34:49.380
to cast shadows onto it.

00:34:49.430 --> 00:34:52.860
So for a given polygon B here,
we're going to beam into polygon A,

00:34:52.860 --> 00:34:54.810
which is the table,
and we're going to take its

00:34:54.810 --> 00:34:59.240
far beam and cut into this
table with those three planes,

00:34:59.260 --> 00:35:01.070
which is what's happening here.

00:35:01.080 --> 00:35:03.220
Polygon B, this blue one being
the microphone polygon,

00:35:03.220 --> 00:35:05.090
down into the table.

00:35:05.100 --> 00:35:07.230
And those end up cutting it
into three different polygons.

00:35:07.240 --> 00:35:10.400
What happens is on the right here,
you can then tag each resulting

00:35:10.400 --> 00:35:12.350
polygon as in or out of light.

00:35:12.380 --> 00:35:14.690
So if it falls in polygon
beams far frustum,

00:35:14.690 --> 00:35:17.020
far beam frustum, we tag it as in shadow.

00:35:17.020 --> 00:35:18.210
Otherwise, we just leave it alone.

00:35:18.220 --> 00:35:19.440
And it's that simple.

00:35:19.440 --> 00:35:21.400
You just keep doing that
over and over and over.

00:35:21.400 --> 00:35:23.930
And you just have an optimization
step that optimizes your

00:35:23.930 --> 00:35:24.980
mesh every step of the way.

00:35:24.980 --> 00:35:32.320
And you end up with what we just saw,
the button here, the final shadow.

00:35:32.320 --> 00:35:34.640
So here's the interesting thing
is a lot of the literature,

00:35:34.640 --> 00:35:36.280
a lot of different ways
to solve shadow lines,

00:35:36.290 --> 00:35:39.910
to do shadow cutting in a sense,
can't solve these cases.

00:35:39.920 --> 00:35:43.940
Cyclically overlapping polygons
are the root of all evil for anyone

00:35:43.940 --> 00:35:45.360
doing research in this topic.

00:35:45.360 --> 00:35:48.160
It's polygons that overlap each other,
three of them.

00:35:48.210 --> 00:35:49.320
There's no order.

00:35:49.320 --> 00:35:51.920
You can't possibly sort these
three polygons and figure out

00:35:51.930 --> 00:35:54.310
which one's on top because
they're each on top of each other.

00:35:54.760 --> 00:36:00.170
And so this breaks a lot of ways,
different methods.

00:36:00.200 --> 00:36:04.010
This brute force method of just
cutting everything up works fine.

00:36:04.020 --> 00:36:05.670
You end up with what's
on the right there,

00:36:05.680 --> 00:36:07.620
exactly what you want to see,
everything cut up perfectly.

00:36:07.620 --> 00:36:10.240
And there's the results.

00:36:10.240 --> 00:36:13.170
So those are our static shadows.

00:36:13.180 --> 00:36:15.460
We cut them into the scene,
nice and simple.

00:36:15.460 --> 00:36:17.510
Now we have to deal with
our dynamic shadows.

00:36:17.540 --> 00:36:19.710
And in a second,
we're going to talk about how we

00:36:19.780 --> 00:36:22.940
combine both of them so they look right,
they look like they belong together.

00:36:22.960 --> 00:36:24.540
So let's talk about the dynamic shadows.

00:36:24.540 --> 00:36:30.040
So dynamic shadows are basically
done with shadow volumes.

00:36:30.080 --> 00:36:31.760
Let's take one week.

00:36:31.820 --> 00:36:34.540
Can we jump into the demo, please?

00:36:35.020 --> 00:36:37.880
Okay, so, um, okay,
why don't you pull the

00:36:37.880 --> 00:36:38.850
camera back a little bit?

00:36:38.920 --> 00:36:40.030
Okay, that's good.

00:36:40.120 --> 00:36:42.260
And now, turn on just objects.

00:36:42.260 --> 00:36:45.550
So here's our dynamic objects,
and if we turn on wireframe,

00:36:45.770 --> 00:36:48.270
these blue wireframes
are the shadow volumes.

00:36:48.270 --> 00:36:52.380
So a shadow volume is basically,
given our piece of geometry,

00:36:52.400 --> 00:36:56.500
we can generate a volume that
represents what's in shadow.

00:36:56.500 --> 00:36:59.340
So anything that falls into the symbol,
for example, here,

00:36:59.420 --> 00:37:01.690
anything that falls into
that symbol's volume,

00:37:01.690 --> 00:37:03.690
this volume generated, is in shadow.

00:37:03.700 --> 00:37:04.700
We tag that as in shadow.

00:37:04.700 --> 00:37:08.030
We can do tricks with how we render
these volumes into the stencil

00:37:08.030 --> 00:37:11.350
buffer to make it look like,
to actually tag the pixels properly,

00:37:11.350 --> 00:37:14.100
if you're saying what's in
shadow and what's not in shadow.

00:37:14.120 --> 00:37:17.850
So those are basically
what a shadow volume is.

00:37:17.850 --> 00:37:20.660
If you turn, actually,
if you turn wireframe off and go back

00:37:20.700 --> 00:37:23.850
to the full scene and object geometry,
yeah.

00:37:24.000 --> 00:37:44.900
[Transcript missing]

00:37:46.330 --> 00:37:49.890
Okay, so here's just a wireframe
shot of these instruments going

00:37:49.890 --> 00:37:53.580
over the drum machine there,
and here's their shadow volumes.

00:37:53.580 --> 00:37:56.200
And you can see where their
shadow volumes intersect the wall,

00:37:56.200 --> 00:38:00.410
those pixels are tagged as in shadow,
with sense of volume.

00:38:00.420 --> 00:38:03.200
So here's what a shadow volume is.

00:38:03.220 --> 00:38:04.740
Shadow volume basics,
for those of you who aren't

00:38:04.740 --> 00:38:07.510
that familiar with it,
is given a light position and, say,

00:38:07.510 --> 00:38:11.280
a sphere, what you do is you figure
out the silhouette edges from

00:38:11.280 --> 00:38:12.980
the light's point of view.

00:38:13.700 --> 00:38:15.940
What you want to do is you want to
basically break that sphere in half,

00:38:15.940 --> 00:38:16.660
right?

00:38:16.660 --> 00:38:19.630
Keep anything that gets hit by the
light in place and take the bottom

00:38:19.690 --> 00:38:22.950
half of that sphere and shoot it down,
far away from the light,

00:38:22.960 --> 00:38:24.640
and at the angle of the light as well.

00:38:24.640 --> 00:38:27.640
So what you end up with is this
sphere turns into this sort of

00:38:27.660 --> 00:38:30.930
this weird-looking pill shape,
this full pill shape,

00:38:30.940 --> 00:38:33.160
and that is your shadow line,
which is a closed volume,

00:38:33.160 --> 00:38:37.270
and it's sort of, and that,
you can use that to render into

00:38:37.270 --> 00:38:39.880
the stencil buffer to render,
to mark each pixel as

00:38:39.880 --> 00:38:42.000
in or out of shadow.

00:38:42.240 --> 00:38:46.200
Here's just sort of a brief look
at one way to do this in hardware.

00:38:46.200 --> 00:38:49.970
Essentially,
you have to... so there's this

00:38:49.970 --> 00:38:52.760
method... how many people here
are familiar with this method of

00:38:52.820 --> 00:38:56.200
doing shadow vimes with degenerate
quads along the edge of primitives?

00:38:56.200 --> 00:38:58.200
Not many.

00:38:58.200 --> 00:39:01.200
Okay, so the idea is basically this.

00:39:01.200 --> 00:39:05.200
So you have this model, this sphere,
right?

00:39:05.200 --> 00:39:07.820
For each edge in your model,
what you want to do is you want

00:39:07.820 --> 00:39:11.290
to stick a degenerate quad,
an infinitely thin quad there,

00:39:11.290 --> 00:39:13.190
just two triangles
that connect that edge.

00:39:13.200 --> 00:39:18.180
Okay, so you want to take your sphere,
basically separate out all these vertices

00:39:18.210 --> 00:39:20.200
and add up two polygons along each edge.

00:39:20.200 --> 00:39:21.170
That is basically a quad.

00:39:21.200 --> 00:39:25.340
So the idea is when you take this
sphere and you split it at the seams and

00:39:25.390 --> 00:39:29.940
stretch it... and then stretch it apart,
those quads along those edges,

00:39:29.940 --> 00:39:32.200
those silhouette edges, get stretched.

00:39:32.720 --> 00:39:32.900
Right?

00:39:33.200 --> 00:39:35.200
And so if we go back one
slide to this... Okay.

00:39:35.200 --> 00:39:38.200
over here,
these represent sort of the quads.

00:39:38.200 --> 00:39:41.400
Each one of those vertical
areas represent a quad that was

00:39:41.400 --> 00:39:42.970
originally stuck on an edge.

00:39:43.270 --> 00:39:44.200
Right?

00:39:44.200 --> 00:39:46.160
And when we split it apart,
it's like putting like Elmer's glue

00:39:46.160 --> 00:39:48.910
there and it gets... and you just pull
it apart and it sort of just fills in

00:39:48.920 --> 00:39:50.200
the gap or you just stretch it open.

00:39:50.200 --> 00:39:51.920
So the idea is this.

00:39:52.200 --> 00:39:55.200
So we stick these infinitely
thin quads along these edges.

00:39:55.200 --> 00:39:58.200
So for... here's two
polygons in our given model.

00:39:58.200 --> 00:39:59.970
And that shared edge there,
we stick these infinitely thin

00:39:59.970 --> 00:40:01.190
polygons right in the middle there.

00:40:01.200 --> 00:40:04.200
Now, they're actually right
on top of each other.

00:40:04.200 --> 00:40:05.180
I'm just spreading them
apart so you can see.

00:40:05.200 --> 00:40:06.200
You can visualize it.

00:40:06.410 --> 00:40:09.200
And what we do is we stick the
face normals of each polygon.

00:40:09.200 --> 00:40:11.980
So polygon A,
we take its face normal... Sorry.

00:40:12.200 --> 00:40:13.200
Oh.

00:40:13.310 --> 00:40:18.100
We take its face normal and we embed it
into the three vertices of polygon A.

00:40:18.200 --> 00:40:22.270
And we take polygon B's face
normal and embed that face

00:40:22.280 --> 00:40:24.200
normal into those three verts.

00:40:24.200 --> 00:40:25.200
And the idea is this.

00:40:25.200 --> 00:40:30.200
The idea is that in your vertex shader,
as you're running a vertex shader,

00:40:30.200 --> 00:40:34.200
you want to basically be able to
shoot each vertex back one at a time.

00:40:34.200 --> 00:40:37.200
So you want to either keep it in place
if it's front facing to the light

00:40:37.200 --> 00:40:41.190
or you want to take the vertex and
shoot it back to generate this volume.

00:40:41.200 --> 00:40:44.190
So the idea is that since you have your
face normals embedded in your vertices,

00:40:44.200 --> 00:40:48.200
if you shoot back the lower
left vertex for polygon A,

00:40:48.200 --> 00:40:50.120
you're going to end up shooting
back the other two as well

00:40:50.240 --> 00:40:51.200
because it's the same normal.

00:40:51.200 --> 00:40:54.200
It's the same face normal
you're doing the math with.

00:40:54.200 --> 00:40:56.080
You're going to basically do
a dot product with the light

00:40:56.080 --> 00:40:57.190
vector and that face normal.

00:40:57.200 --> 00:40:59.200
So if one shoots back,
they all shoot back.

00:40:59.200 --> 00:41:02.850
And in the end, you end up basically...
Either each primitive stays in

00:41:02.850 --> 00:41:03.200
place or it gets moved back.

00:41:03.200 --> 00:41:05.170
One at a time.

00:41:05.350 --> 00:41:08.200
This is sort of a brute force approach
to doing shadow volumes in hardware.

00:41:08.200 --> 00:41:09.190
Fully in the hardware.

00:41:09.330 --> 00:41:11.200
There's no CPU work happening here.

00:41:11.220 --> 00:41:15.110
All happens in your vertex shader.

00:41:15.420 --> 00:41:19.380
So we render this into
the stencil buffer.

00:41:19.970 --> 00:41:22.070
and so they're in there.

00:41:22.080 --> 00:41:24.290
So now we can render these shadow
lines in there and you have

00:41:24.290 --> 00:41:25.300
this in your stencil buffer.

00:41:25.300 --> 00:41:27.800
You can basically test it to
say which pixel is in shadow,

00:41:27.800 --> 00:41:29.800
which pixel is out of shadow.

00:41:29.800 --> 00:41:32.500
So which brings us to the question
is how do you get those shadows into

00:41:32.500 --> 00:41:35.670
the color buffer and make them look
good and make them blend in with

00:41:35.670 --> 00:41:37.300
the shadows that we have baked in.

00:41:37.300 --> 00:41:39.790
Right, you have these baked in shadows,
you want to make sure that you

00:41:39.790 --> 00:41:40.800
don't double darken pixels.

00:41:40.800 --> 00:41:43.800
If something's already in
shadow from the scene geometry,

00:41:43.800 --> 00:41:45.300
you don't want to have
it go into shadow again.

00:41:45.300 --> 00:41:47.000
It's going to look bad,
it's going to look obvious

00:41:47.050 --> 00:41:49.300
that you're doing something
different for dynamic geometry.

00:41:49.300 --> 00:41:52.400
So we're at the stage
right now where we have,

00:41:52.400 --> 00:41:56.570
we essentially have our full
scene drawn into the back

00:41:56.570 --> 00:41:59.290
buffer with no dynamic shadows.

00:41:59.310 --> 00:42:02.570
Everything is drawn without the shadows
and our stencil buffer lives each

00:42:02.570 --> 00:42:04.190
pixel tagged as in or out of shadow.

00:42:04.300 --> 00:42:07.140
So now we have to combine these,
the back buffer with our stencil buffer

00:42:07.150 --> 00:42:08.800
in some way to get them to look right.

00:42:08.800 --> 00:42:12.000
So what we do is,
one thing you could do is just

00:42:12.010 --> 00:42:16.090
draw a full screen quad over your
scene and for each pixel that's

00:42:16.090 --> 00:42:18.800
in shadow just dim the color by,
you know, 0.5.

00:42:18.800 --> 00:42:20.300
Just dim it in half, right.

00:42:20.300 --> 00:42:21.870
You're going to get some
really bad artifacts like that,

00:42:21.870 --> 00:42:22.800
it's not going to look right.

00:42:22.800 --> 00:42:26.260
So what we're going to do
is we use Destination Alpha.

00:42:26.300 --> 00:42:29.780
How many games here, how many,
who uses Destination Alpha for anything?

00:42:29.840 --> 00:42:32.800
Actually stores real values
in Destination Alpha?

00:42:34.330 --> 00:42:34.860
Perfect.

00:42:34.890 --> 00:42:36.860
So, four, sorry.

00:42:36.860 --> 00:42:39.960
So, Destination Alpha,
you can think of this as a whole

00:42:39.960 --> 00:42:42.560
other channel you can store data in.

00:42:42.680 --> 00:42:45.420
As you render your scene,
as you render each polygon,

00:42:45.420 --> 00:42:47.700
you're writing to RGB,
also write something to Alpha.

00:42:47.700 --> 00:42:52.200
You can write something useful to Alpha,
and then use it later in a separate pass.

00:42:52.290 --> 00:42:54.390
So this is a way you can do
a lot of interesting things.

00:42:54.400 --> 00:42:56.900
So we're using Destination
Alpha to do our shadows.

00:42:56.980 --> 00:43:00.460
And the idea is this,
is instead of drawing a

00:43:00.460 --> 00:43:02.290
quad over your screen,

00:43:02.400 --> 00:43:51.700
[Transcript missing]

00:43:52.000 --> 00:43:53.890
If you zoom back and
just sort of... Yeah,

00:43:53.890 --> 00:43:54.200
what is it?

00:43:54.200 --> 00:43:55.100
G, is that the color?

00:43:55.100 --> 00:43:56.460
Yeah, I go two more times.

00:43:56.460 --> 00:43:57.170
There we go.

00:43:57.200 --> 00:43:59.130
So, here is what the scene looks like.

00:43:59.170 --> 00:44:01.100
Now, you're going to notice it
looks counterintuitive.

00:44:01.120 --> 00:44:02.900
Where there's no lights
up at the ceiling,

00:44:02.900 --> 00:44:04.190
there's no real dominant
lights hitting that,

00:44:04.200 --> 00:44:04.700
you have white.

00:44:04.760 --> 00:44:06.720
What white means is it's just one.

00:44:06.720 --> 00:44:10.840
You're going to basically take...
If you multiply that pixel by one,

00:44:10.840 --> 00:44:13.240
it's not going to change,
which is what we want.

00:44:13.330 --> 00:44:15.810
If that falls into shadow up there,
it doesn't matter because there's

00:44:15.810 --> 00:44:18.090
no light already hitting it,
so there's nothing to mask out.

00:44:18.140 --> 00:44:19.980
So, you want to just multiply
by one and leave it alone.

00:44:20.450 --> 00:44:24.470
For the pixels in here,
in these dark areas,

00:44:25.100 --> 00:45:32.000
[Transcript missing]

00:45:32.160 --> 00:45:34.680
and what you're going to see is we have,
we're going to, these are baked in

00:45:34.680 --> 00:45:36.030
shadows here on the wall.

00:45:36.040 --> 00:45:39.280
We now have two different lights
casting shadows in this area.

00:45:39.300 --> 00:45:41.140
Okay,
if you turn on the wireframe quickly,

00:45:41.140 --> 00:45:44.030
so this is going to show you,
we actually cut in,

00:45:44.030 --> 00:45:47.140
in our shadow cutting,
to back up for a minute, we have,

00:45:47.140 --> 00:45:50.760
we cut into our geometry
shadows from multiple lights,

00:45:50.760 --> 00:45:56.040
and we can preserve which polygons
fall into one light source,

00:45:56.040 --> 00:45:58.480
two light sources, or are shadowed by one
light or two lights.

00:45:59.020 --> 00:46:00.190
So if we turn the
wireframe off for a minute,

00:46:00.470 --> 00:46:04.200
turn it, go into the Dest Alpha,
view Dest Alpha there.

00:46:06.300 --> 00:46:06.850
There we go.

00:46:06.880 --> 00:46:08.450
So if you notice,
this is what we write into

00:46:08.540 --> 00:46:10.040
DestAlpha for this area.

00:46:10.530 --> 00:46:12.460
So the interesting thing is,
for the pixels right

00:46:12.460 --> 00:46:15.560
here in this darker gray,
there's no baked in shadows.

00:46:15.560 --> 00:46:19.290
This is just a pixel being
hit by the light full on.

00:46:19.760 --> 00:46:24.280
The pixels down here that are lighter
gray are being hit by just one light.

00:46:24.600 --> 00:46:41.600
[Transcript missing]

00:46:42.200 --> 00:46:43.540
It's already fully in shadow.

00:46:43.540 --> 00:46:44.690
There's nothing to shadow there.

00:46:44.700 --> 00:46:47.560
So we can write out,
when we pre-process and

00:46:47.570 --> 00:46:49.700
do our shadow cutting,
we tag each polygon,

00:46:49.700 --> 00:46:52.910
and we know how many lights
is already being shadowed by,

00:46:52.960 --> 00:46:55.080
or how many lights is being hit by.

00:46:55.100 --> 00:46:56.550
And we write out the right value.

00:46:56.580 --> 00:46:58.900
So what we end up with,
can we go to the right

00:46:58.900 --> 00:47:00.340
over the drum machine?

00:47:00.340 --> 00:47:00.950
On the left?

00:47:00.960 --> 00:47:01.980
Yeah, right there.

00:47:01.980 --> 00:47:05.240
Let's page down a little bit
and get these guys up here.

00:47:05.240 --> 00:47:05.750
Okay, good.

00:47:05.760 --> 00:47:08.650
So I want you to notice,
this is the whole reason for

00:47:08.650 --> 00:47:10.630
doing this dim factor thing,
right?

00:47:10.720 --> 00:47:13.250
With this sort of Dest Alpha is,
as these shadows go out

00:47:13.390 --> 00:47:16.520
of this light source,
they dim and they blend in perfectly.

00:47:16.520 --> 00:47:20.440
This bar here, this big horizontal bar,
that shadow is baked in.

00:47:20.440 --> 00:47:21.700
That's from our shadow cutting, right?

00:47:21.700 --> 00:47:26.160
And the idea is that those shadows
blend in with that bar fine,

00:47:26.160 --> 00:47:27.640
and they disappear nice and smoothly.

00:47:27.640 --> 00:47:30.790
You never know that right when
it gets out of that volume,

00:47:30.790 --> 00:47:32.020
that disappears.

00:47:32.020 --> 00:47:34.420
We don't actually draw that
shadow line because we do culling

00:47:34.420 --> 00:47:35.740
based on our light sources.

00:47:35.740 --> 00:47:37.850
So we end up with these
nice shadow volumes,

00:47:37.850 --> 00:47:41.470
these nice shadows that work perfectly,
that just integrate with the scene well.

00:47:41.480 --> 00:47:43.740
So can we go back to the slides?

00:47:46.010 --> 00:47:49.870
Okay, so the shadow quad.

00:47:50.000 --> 00:47:52.690
So now that we basically
have our Dest Alpha drawn,

00:47:52.690 --> 00:47:55.750
right, everything,
all the contents of our Destination

00:47:55.750 --> 00:47:59.920
Alpha and our RGB channels are
filled with all the right data.

00:47:59.920 --> 00:48:01.540
We have our stencil buffer
filled with the right data.

00:48:01.540 --> 00:48:05.260
Now we have to basically draw a
quad over our full screen to get

00:48:05.340 --> 00:48:07.610
the shadows for the right pixels.

00:48:07.930 --> 00:48:09.460
And so what we do is this.

00:48:09.460 --> 00:48:10.860
This is our blending.

00:48:10.860 --> 00:48:13.430
In OpenGL,
you set your source color to zero

00:48:13.430 --> 00:48:15.630
and your Dest Color to Dest Alpha.

00:48:15.640 --> 00:48:18.560
Sorry,
you set your source factor to zero and

00:48:18.560 --> 00:48:21.280
your Destination Factor to Dest Alpha.

00:48:21.340 --> 00:48:25.430
So the equation you end up with when
you plug this into your Alpha Blending

00:48:25.640 --> 00:48:28.570
algorithm is you end up with,
this turns out to be zero,

00:48:28.570 --> 00:48:31.800
and you end up with this
Dest Color times Dest Alpha.

00:48:31.820 --> 00:48:33.960
Right, Dest Alpha is your dim factor.

00:48:34.000 --> 00:48:36.860
So you just end up with
the equation that you want.

00:48:36.900 --> 00:48:37.750
And you turn on stencils.

00:48:37.830 --> 00:48:40.280
You turn on your stencil,
your stencil test as well,

00:48:40.280 --> 00:48:42.670
and you only write to the
pixels that are in shadow.

00:48:42.670 --> 00:48:43.760
And it's that simple.

00:48:43.760 --> 00:48:45.680
And you get those shadows in the end.

00:48:45.680 --> 00:48:48.730
So, to summarize on the shadows,
we basically have,

00:48:48.730 --> 00:48:52.810
we talked about the differences
between the static and dynamic shadows.

00:48:53.250 --> 00:48:58.960
Went into some shadow cutting algorithm
and some of the shadow volume basics.

00:48:58.960 --> 00:49:01.630
So,
and that's how we do shadows in Animusic.

00:49:01.840 --> 00:49:04.380
So, I'm looking at the clock
and I have another,

00:49:04.380 --> 00:49:06.320
I have a few minutes to burn here.

00:49:06.320 --> 00:49:07.920
So I want to show one other effect.

00:49:07.920 --> 00:49:12.270
which is, if we could go back to the
demo machine and add a music.

00:49:13.200 --> 00:49:16.750
So, if we press 1, press 1,
start this over.

00:49:16.750 --> 00:49:20.630
If you watch this,
the balls in that music are

00:49:20.630 --> 00:49:21.420
actually motion blurred.

00:49:21.420 --> 00:49:25.620
When we first got the DVD in our hands
from SIGGRAPH to watch this video,

00:49:25.620 --> 00:49:29.110
I stepped through every frame
and I watched everything they

00:49:29.290 --> 00:49:31.040
were doing in the full video.

00:49:31.040 --> 00:49:33.310
And the only thing they
motion blurred were the balls,

00:49:33.310 --> 00:49:35.360
because those were the
only things moving fast.

00:49:35.360 --> 00:49:36.920
Everything else was moving slow.

00:49:37.010 --> 00:49:39.540
So we said, well,
how do we do motion blur on balls

00:49:39.540 --> 00:49:41.300
that make it look realistic?

00:49:42.050 --> 00:49:47.320
And so,
we came up with this vertex shader

00:49:47.320 --> 00:49:49.920
to do what looks like motion blur.

00:49:49.920 --> 00:49:51.680
So if we press A to pause the animation.

00:49:51.680 --> 00:49:53.100
Okay, so here's the pause.

00:49:53.100 --> 00:49:54.640
Here's the actual geometry.

00:49:54.640 --> 00:49:55.530
Okay, that's good.

00:49:55.530 --> 00:49:57.200
Actually, back up just a little bit.

00:49:57.200 --> 00:49:59.480
Okay,
so the ball right in the middle there,

00:49:59.480 --> 00:50:02.030
down on the bottom,
is almost a full ball shape.

00:50:02.040 --> 00:50:03.780
And that's moving pretty slow.

00:50:03.780 --> 00:50:07.090
The ones that are moving
faster look like hot dogs,

00:50:07.090 --> 00:50:07.740
right?

00:50:07.740 --> 00:50:10.960
So what we do is we hit wireframe.

00:50:12.000 --> 00:50:12.680
One more time.

00:50:12.680 --> 00:50:14.480
Okay, so it's going to be hard to see.

00:50:14.480 --> 00:50:14.980
Turn off.

00:50:14.980 --> 00:50:15.680
Press D.

00:50:15.680 --> 00:50:17.420
Turn off the... One more time.

00:50:17.420 --> 00:50:19.820
Okay,
so the ball shape here looks like a pill.

00:50:19.820 --> 00:50:22.980
What we basically do is we take our ball
and we split it at one of those seams.

00:50:22.980 --> 00:50:26.320
And we generate... It looks
like it's motion blurred.

00:50:26.320 --> 00:50:27.580
We have the right shape for it, right?

00:50:27.660 --> 00:50:32.470
And what we do is we then use...
When we fetch from our environment map,

00:50:32.580 --> 00:50:34.060
because these things are
all environment mapped,

00:50:34.270 --> 00:50:38.870
we lower the MIP level bias,
the LOD bias.

00:50:38.960 --> 00:50:42.760
So... So when we fetch the textiles
from the... From our environment map,

00:50:42.790 --> 00:50:43.280
it's blurrier.

00:50:43.280 --> 00:50:46.220
We also change the opacity
value on those pixels.

00:50:46.220 --> 00:50:48.800
So as the more round
it is and not moving,

00:50:48.800 --> 00:50:50.150
it's a solid ball.

00:50:50.160 --> 00:50:53.000
As it becomes more and more stretched,
we make it more transparent.

00:50:53.000 --> 00:50:55.930
So it looks like you can
still see through it,

00:50:56.050 --> 00:50:56.590
right?

00:50:56.850 --> 00:50:58.720
Because if you keep it solid,
it's going to look like

00:50:58.720 --> 00:51:00.320
you're launching hot dogs,
right?

00:51:00.320 --> 00:51:00.820
You...

00:51:01.710 --> 00:51:02.540
- Which isn't good.

00:51:02.540 --> 00:51:04.660
So you want to make it look like you're
going to be able to see through it.

00:51:04.690 --> 00:51:06.140
Because motion blur,
you can sort of see through

00:51:06.140 --> 00:51:08.580
anything that's motion blurred.

00:51:08.620 --> 00:51:11.580
So now you're probably wondering, well,
this is a cool technique,

00:51:11.590 --> 00:51:14.210
but not a lot of games
have balls launching out of

00:51:14.230 --> 00:51:15.780
machines and instruments.

00:51:15.780 --> 00:51:17.120
But you do have other projectiles.

00:51:17.120 --> 00:51:17.840
You have rockets.

00:51:17.850 --> 00:51:20.120
You have someone's going to
throw a grenade over something.

00:51:20.120 --> 00:51:23.060
Whatever things that are going to be
moving in your scene in your games,

00:51:23.060 --> 00:51:25.020
you can apply this technique to it,
right?

00:51:25.030 --> 00:51:28.640
Especially things,
even things that are like a...

00:51:28.700 --> 00:51:52.100
[Transcript missing]

00:51:53.200 --> 00:51:56.740
So that's motion blur and then music.

00:51:56.750 --> 00:52:01.160
All right,
can we go back to the slides please?

00:52:02.000 --> 00:52:03.200
OK, for more information.

00:52:03.200 --> 00:52:04.500
So here's some references.

00:52:04.500 --> 00:52:05.500
These will be on the web.

00:52:05.500 --> 00:52:10.520
These are some books I highly recommend
as far as current graphics go.

00:52:10.610 --> 00:52:13.950
And some links to-- the normal mapper
tool will be on ATI's developer

00:52:13.950 --> 00:52:17.190
website sometime in the next few weeks.

00:52:17.550 --> 00:52:19.170
And here's us.

00:52:19.500 --> 00:52:20.690
That's me, Rav.

00:52:20.700 --> 00:52:23.120
Marwan is another guy in our office that
worked on some of the video shaders.

00:52:23.120 --> 00:52:26.120
And if you have any questions,
feel free to drop us an email.

00:52:26.120 --> 00:52:28.120
And that's it.
WEBVTT

00:01:42.230 --> 00:01:44.420
You don't have to install any drivers.

00:01:44.590 --> 00:01:45.520
It works automatically.

00:01:45.600 --> 00:01:48.210
So, can we go to demo four, please?

00:01:50.140 --> 00:01:53.030
Just a couple of quick
devices I want to show off.

00:01:53.040 --> 00:01:56.000
These are products that
are coming to the Mac.

00:01:56.000 --> 00:01:58.130
Thanks.

00:01:58.180 --> 00:02:01.650
The first one is made by a
company called 3D Connection.

00:02:01.650 --> 00:02:03.340
Ignore the Lab Tech label on here.

00:02:03.340 --> 00:02:04.450
3D Connection bought them.

00:02:04.450 --> 00:02:08.460
It's a six degree of freedom controller,
and it allows you to move objects in

00:02:08.460 --> 00:02:10.480
three-dimensional space automatically.

00:02:10.540 --> 00:02:13.290
I have a demo app here.

00:02:25.700 --> 00:02:40.000
[Transcript missing]

00:02:54.780 --> 00:02:57.540
Still not working, Jeff.

00:02:57.590 --> 00:02:59.500
All right, well,
I'm going to skip that demo.

00:02:59.500 --> 00:03:00.730
I can assure you that it does work.

00:03:01.160 --> 00:03:05.540
The other product that we
have from the same company,

00:03:05.620 --> 00:03:07.740
3D Connection,
is a keyboard that has one of the

00:03:07.740 --> 00:03:10.720
6-degree freedom controllers built in,
which is very cool.

00:03:10.720 --> 00:03:13.590
These kinds of keyboards can
be used to do video editing.

00:03:13.700 --> 00:03:16.040
Almost anything where you
need a jog channel would work.

00:03:16.040 --> 00:03:19.330
But what I'm mostly interested in
seeing happen is CAD CAM applications

00:03:19.340 --> 00:03:21.440
adopt 6-degree freedom controllers.

00:03:22.600 --> 00:03:24.310
Afterwards,
if you've got an interest in that,

00:03:24.310 --> 00:03:25.960
please come up and talk
to Jeff Lowe and I.

00:03:26.030 --> 00:03:28.700
We'd be really keen to work
with you to make that happen.

00:03:28.700 --> 00:03:32.740
The final sample device that I have
I want to show off is from ATI.

00:03:32.740 --> 00:03:35.920
So probably a lot of you think that
ATI makes really great video cards,

00:03:35.920 --> 00:03:38.730
maybe the occasional TV tuner,
but they also make a remote.

00:03:38.760 --> 00:03:41.940
And the remote has buttons on it
that will bring up a web browser.

00:03:41.940 --> 00:03:45.270
It will play music as well.

00:03:45.280 --> 00:03:48.130
Oh,
I'm going to the Apple internal website.

00:03:50.150 --> 00:03:53.000
You can play music,
you can control iTunes,

00:03:53.180 --> 00:03:56.500
control TV if you've got a TV tuner.

00:03:56.500 --> 00:03:57.820
It's a really great little remote.

00:03:57.820 --> 00:03:59.980
So with that,
let me turn it over to the guys and

00:03:59.980 --> 00:04:02.090
they will go into Hidden Force Feedback.

00:04:02.290 --> 00:04:02.480
Thanks.

00:04:20.500 --> 00:04:23.860
and Fabio Paz,
the HIID Manager Engineer on

00:04:23.860 --> 00:04:25.950
the I/O Kit team for Apple.

00:04:26.070 --> 00:04:30.090
And today we're just going to
briefly go over the HIID Manager.

00:04:30.260 --> 00:04:35.700
Basically what we'll do is
we'll talk about what HIID is,

00:04:36.020 --> 00:04:42.120
the HIID implementation on Mac OS X,
some improvements that we've

00:04:42.120 --> 00:04:42.250
added since Jaguar 10.2,
and some techniques for

00:04:42.250 --> 00:04:42.250
using the HIID Manager.

00:04:42.720 --> 00:04:46.790
Hopefully what you'll learn here is
how HIID fits into Mac OS X and how

00:04:46.870 --> 00:04:49.540
to effectively use the HIID Manager.

00:04:50.550 --> 00:04:52.900
So first off, what is HIID?

00:04:52.920 --> 00:04:56.010
Well,
HIID stands for Human Interface Device.

00:04:56.260 --> 00:05:03.290
It was a specification developed
by the USB Implementers Forum to

00:05:03.290 --> 00:05:03.290
cover devices that humans use
to interact with the system.

00:05:04.180 --> 00:05:08.000
Some examples are your
standard keyboard and mouse,

00:05:08.000 --> 00:05:12.410
front panel controls,
which actually might be your controls

00:05:12.420 --> 00:05:17.580
on the front of your monitor,
or controls on your USB speakers,

00:05:17.640 --> 00:05:20.510
gamer simulation devices like
this steering wheel over here,

00:05:20.510 --> 00:05:23.500
or devices that don't actually
require human interaction.

00:05:23.500 --> 00:05:30.790
So that would be like uninterruptible
power sources or credit card

00:05:30.870 --> 00:05:32.570
swipers or badge readers.

00:05:33.960 --> 00:05:37.520
So let's cover some brief terminology.

00:05:37.590 --> 00:05:39.090
The first thing is a HIID report.

00:05:39.330 --> 00:05:42.010
And basically what this is,
is the raw data that's actually

00:05:42.010 --> 00:05:43.900
sent to or received from the device.

00:05:43.990 --> 00:05:45.870
It can actually be pulled
or interrupt driven.

00:05:45.890 --> 00:05:47.910
And there's really
three types of reports.

00:05:47.910 --> 00:05:50.760
Input report,
which is basically reports that

00:05:50.850 --> 00:05:53.770
are received from the device,
and it's pretty much read only.

00:05:53.770 --> 00:05:56.680
An output report is a report
that's sent to the device,

00:05:56.680 --> 00:05:57.820
and it's write only.

00:05:57.820 --> 00:06:01.190
And the feature report is
actually a combination of the two.

00:06:01.190 --> 00:06:03.690
It can be sent to or
received from the device.

00:06:07.060 --> 00:06:09.400
The next term is an element.

00:06:09.460 --> 00:06:12.900
And basically an element covers
the parsed items from the report.

00:06:12.900 --> 00:06:17.900
The behaviors are actually covered
by its usage and usage page.

00:06:17.900 --> 00:06:21.310
And there's really two
different types of elements.

00:06:21.470 --> 00:06:23.970
The data element,
which there's three subtypes of,

00:06:23.970 --> 00:06:26.830
the input, output,
and feature that we covered earlier,

00:06:26.950 --> 00:06:28.400
and a collection element.

00:06:30.290 --> 00:06:34.090
and collections actually are useful
for representing relationships

00:06:34.120 --> 00:06:36.070
between two or more data objects.

00:06:36.070 --> 00:06:39.100
And there's five different
types of collections.

00:06:39.100 --> 00:06:43.980
The physical, application, logical,
report, and named array.

00:06:44.040 --> 00:06:51.880
The first two we'll actually
cover in more detail.

00:06:51.880 --> 00:06:53.230
So this is an example descriptor of a,
of a HID mouse.

00:06:55.580 --> 00:07:00.100
So the first item we're looking at here
is actually the application collection.

00:07:00.150 --> 00:07:03.750
And what this does is actually
tip off the system of what the

00:07:03.750 --> 00:07:06.250
intended behavior of this device is.

00:07:07.640 --> 00:07:10.190
The next collection is a physical
collection for the pointer.

00:07:10.190 --> 00:07:12.910
And basically what we're doing here
is we're grouping together the buttons

00:07:13.060 --> 00:07:16.390
and the axes because it makes sense for
them to be grouped together that way.

00:07:18.650 --> 00:07:23.140
And the next example here
is the declaration of the

00:07:23.140 --> 00:07:24.860
actual button elements.

00:07:24.960 --> 00:07:28.260
So as you see here, we've got a...

00:07:28.940 --> 00:07:31.690
A report count of three
and a report size of one.

00:07:31.700 --> 00:07:34.240
So basically what we're
doing here is declaring three

00:07:34.240 --> 00:07:36.780
objects that are one bit each.

00:07:36.830 --> 00:07:40.090
And basically what this will represent
is buttons one through three.

00:07:43.030 --> 00:07:46.680
The next items that we're declaring
here are the X and Y axes.

00:07:47.010 --> 00:07:53.880
And basically these are two 8-bit values
that represent both the X and Y axes.

00:07:53.970 --> 00:07:58.180
Now one thing you'll notice
is that for the buttons,

00:07:58.260 --> 00:08:03.010
the input was actually absolute,
and for the axes they're relative.

00:08:03.140 --> 00:08:06.360
So basically the absolute type
elements are based on a fixed origin,

00:08:06.430 --> 00:08:10.610
or absolute is based on a fixed origin.

00:08:10.710 --> 00:08:18.760
- Absolute is based on a fixed
origin and Relative is based on

00:08:18.760 --> 00:08:18.760
changing origins from different,
or changing axes from different...

00:08:19.400 --> 00:08:24.520
So an example of this would be a mouse
would be a relative type of value,

00:08:24.520 --> 00:08:27.430
whereas a tablet would
probably want a fixed origin

00:08:27.440 --> 00:08:29.980
or absolute coordinate system.

00:08:32.090 --> 00:08:35.260
So now that we've got pretty much a
basic understanding of what HIID is,

00:08:35.410 --> 00:08:38.590
we'll kind of jump into how the
stack is actually implemented

00:08:38.680 --> 00:08:40.540
on OS X and the HIID Manager.

00:08:40.640 --> 00:08:43.840
So basically the HIID Manager is the
abstraction layer of how to interact with

00:08:43.840 --> 00:08:46.380
the device for receiving the raw events.

00:08:46.460 --> 00:08:48.470
It basically consists of three layers.

00:08:48.550 --> 00:08:53.040
The HIID drivers at the lowest layer,
the kernel architecture,

00:08:53.210 --> 00:08:55.610
and the user space API.

00:08:57.050 --> 00:09:01.210
and this is kind of a diagram showing how
these actually interact with each other,

00:09:01.480 --> 00:09:03.610
the application being
up at the top portion,

00:09:03.650 --> 00:09:06.850
communicating with the IOHID lib,
which then again crosses the

00:09:06.950 --> 00:09:10.370
kernel boundary and communicates
directly with the devices.

00:09:13.090 --> 00:09:16.140
So basically,
a HIID driver is an I/O service that's

00:09:16.160 --> 00:09:18.880
subclassed off of I/O HID device.

00:09:19.570 --> 00:09:23.670
The transport is not
actually restricted to USB,

00:09:23.670 --> 00:09:31.080
and it actually provides an opportunity
for other developers to provide support

00:09:31.080 --> 00:09:31.080
for serial and FireWire devices.

00:09:31.340 --> 00:09:34.200
One thing is, we are normalized on the
USB HIID specification.

00:09:34.200 --> 00:09:37.590
So then if you are creating
a third-party driver,

00:09:37.970 --> 00:09:41.870
We do ask that you translate the report
descriptor and reports to actually

00:09:42.210 --> 00:09:46.060
work with the USB spec so that it
can work fully with the HID Manager.

00:09:46.240 --> 00:09:48.840
So an example of a device
that might want to be,

00:09:48.910 --> 00:09:52.580
have its own HID driver is
a serial whiteboard device.

00:09:52.620 --> 00:09:54.140
Right now, by default,
when you plug it in,

00:09:54.160 --> 00:09:56.020
it will not work with the system.

00:09:56.050 --> 00:10:00.060
But if somebody writes a specific
driver and goes ahead and creates

00:10:00.060 --> 00:10:03.660
a USB report descriptor and
handles and translates the reports,

00:10:03.660 --> 00:10:07.400
it'll go ahead and behave like,
similar to a USB tablet.

00:10:09.510 --> 00:10:13.310
So the next layer is the I/O HId family,
and it is actually the kind of

00:10:13.310 --> 00:10:15.830
the meat of the whole HId Manager.

00:10:15.890 --> 00:10:18.180
It's responsible for
doing a lot of the work.

00:10:18.240 --> 00:10:21.150
And essentially what it does is it'll
parse the HId reports and split them up

00:10:21.240 --> 00:10:25.620
into the individual elements that make
more sense to an application developer.

00:10:25.620 --> 00:10:28.820
It also interacts directly
with the I/O HId lib,

00:10:28.890 --> 00:10:33.300
and allows like the bridging between
the application and the device itself.

00:10:33.340 --> 00:10:35.830
It maintains a shared memory that,

00:10:36.030 --> 00:10:43.890
contains the current
values of the elements,

00:10:43.890 --> 00:10:43.890
and it also is responsible for
publishing the properties of

00:10:43.890 --> 00:10:43.890
that device in the I/O registry.

00:10:44.110 --> 00:10:47.030
So this is useful for when you want
to actually match up the device,

00:10:47.160 --> 00:10:50.840
locate a device or locate the
different elements within the device.

00:10:50.950 --> 00:10:54.190
So when going through the registry,
there are certain key value

00:10:54.190 --> 00:10:57.940
pairs that are defined,
and these are located in iohidkeys.h.

00:10:58.000 --> 00:11:01.420
So for device-wide constants,
they start with kioHID,

00:11:01.460 --> 00:11:04.820
and element-wide constants
start with kioHID_element.

00:11:04.880 --> 00:11:08.220
And this will show up later on
as we show examples of what these

00:11:08.220 --> 00:11:10.870
things look like in the IO registry.

00:11:12.820 --> 00:11:16.900
So this is the example IR registry
entry for a HID device.

00:11:17.110 --> 00:11:19.160
Right here, this is just the mouse.

00:11:19.210 --> 00:11:22.190
And you know, it has the vendor ID,
the location, transport,

00:11:22.200 --> 00:11:25.970
and any other properties you'd
expect for a USB device or any

00:11:25.970 --> 00:11:27.970
other device that's a HID device.

00:11:28.070 --> 00:11:31.890
The two properties that
you're gonna be interested in

00:11:32.390 --> 00:11:34.500
as an application developer,
are the primary usage

00:11:34.500 --> 00:11:36.060
and primary usage page.

00:11:36.170 --> 00:11:41.140
And essentially what this does is it is
the top level application collection.

00:11:41.210 --> 00:11:44.570
And what it is is it tips off to you,
the developer,

00:11:44.580 --> 00:11:46.950
what this device actually does.

00:11:47.410 --> 00:11:50.880
So right here, the primary usage page of
one is a generic desktop,

00:11:50.880 --> 00:11:53.890
and the primary usage two is a mouse.

00:11:54.850 --> 00:12:01.000
As you see also at the bottom,
there's an elements property as well,

00:12:01.000 --> 00:12:01.000
and that's pretty much the

00:12:01.200 --> 00:12:03.980
The I-Registry is an array of
elements that are defined as well.

00:12:03.980 --> 00:12:06.150
And so when we go to
the next example here,

00:12:06.150 --> 00:12:09.920
this is a collection element and
how it looks inside the registry.

00:12:09.920 --> 00:12:11.530
Pretty basic.

00:12:11.820 --> 00:12:14.840
It has an element cookie,
which is basically our unique

00:12:14.840 --> 00:12:18.290
identifier for that particular element,
and it describes the

00:12:18.450 --> 00:12:19.880
usage page and usage.

00:12:19.880 --> 00:12:22.710
So you see here,
this is the application collection

00:12:23.370 --> 00:12:25.550
that has the usage page of one and two.

00:12:25.630 --> 00:12:29.990
So pretty much the mouse,
or describing the behavior of the mouse.

00:12:32.790 --> 00:12:36.730
And then here is an example
of the registry entry for

00:12:36.730 --> 00:12:38.880
an actual data element.

00:12:38.980 --> 00:12:41.200
So once again,
it does have an element cookie again.

00:12:41.340 --> 00:12:44.140
So this is the unique identifier
for this particular button.

00:12:44.140 --> 00:12:46.550
This is actually button one of a mouse.

00:12:47.290 --> 00:12:50.120
And it shows all the other
properties such as the type,

00:12:50.200 --> 00:12:52.580
the size, the min, max,
and unit exponent,

00:12:52.580 --> 00:12:55.370
anything that would be more
helpful for you to actually

00:12:55.370 --> 00:12:57.530
use that particular element.

00:13:00.310 --> 00:13:04.300
So now we'll go to the higher
level portion of the HIID Manager.

00:13:04.300 --> 00:13:06.600
And this is mostly what
you'll be concerned with as

00:13:06.600 --> 00:13:08.910
an application developer,
is the IOHID lib.

00:13:08.930 --> 00:13:11.200
And basically it's a
CFPlugin architecture,

00:13:11.200 --> 00:13:15.180
sort of like the USB CFPlugin or
FireWire CFPlugin that communicates

00:13:15.450 --> 00:13:19.140
directly with the device itself,
or with the IOHID family.

00:13:19.140 --> 00:13:21.480
And it's broken up into
three different interfaces.

00:13:21.570 --> 00:13:25.650
The IOHID device interface,
the IOHID queue interface,

00:13:25.670 --> 00:13:27.820
the output transaction interface.

00:13:27.830 --> 00:13:31.940
And each interface is
actually defined by a UUID,

00:13:31.990 --> 00:13:35.590
or Universally Unique Identification.

00:13:38.920 --> 00:13:42.920
So the first interface, of course,
is the IOHID device interface.

00:13:42.960 --> 00:13:46.250
And basically what this is is a
CFPlugin interface that communicates

00:13:46.300 --> 00:13:49.590
directly to the device and establishes
its connection to the device.

00:13:49.640 --> 00:13:52.960
You use this to read and
post element values directly.

00:13:52.960 --> 00:13:55.720
So there's basically two types of APIs.

00:13:55.720 --> 00:13:59.600
The standard APIs,
which rely on the parsed items

00:13:59.670 --> 00:14:01.930
or parsed elements of the device,
and this is something,

00:14:01.980 --> 00:14:04.250
as an application developer,
probably you're going to use

00:14:04.260 --> 00:14:07.140
more because you're not really
concerned about how data is actually

00:14:07.140 --> 00:14:09.180
laid out in terms of the report.

00:14:09.180 --> 00:14:12.980
Now, for more advanced APIs,
getReport and setReport,

00:14:12.980 --> 00:14:15.940
these are intended for developers
that actually know that the device

00:14:16.040 --> 00:14:19.150
that they're communicating with and
actually know how the data is laid out.

00:14:19.200 --> 00:14:23.580
And so you're probably going to want
to use these more advanced APIs.

00:14:27.310 --> 00:14:30.530
So the next thing is the Q interface,
and this is extremely useful

00:14:30.530 --> 00:14:33.400
for applications that need to
respond to every hit event.

00:14:33.400 --> 00:14:36.320
So for example, it would be a,
suppose you have a first

00:14:36.510 --> 00:14:37.790
person shoot-em-up game.

00:14:37.790 --> 00:14:41.550
You don't want to actually respond to
the current value of that element or,

00:14:41.640 --> 00:14:44.750
you know, the trigger button,
but in fact you want to queue up

00:14:44.750 --> 00:14:46.630
the trigger button events coming in.

00:14:46.770 --> 00:14:49.600
So this will allow you
to effectively do that.

00:14:50.120 --> 00:14:52.860
It can actually,
the queue can be set up to be pulled

00:14:52.860 --> 00:14:55.010
or receive asynchronous notifications.

00:14:55.010 --> 00:15:00.110
And we actually recommend that you use
async notifications as your application

00:15:00.160 --> 00:15:04.020
will do less work pulling the queue,
and you almost receive events

00:15:04.090 --> 00:15:05.850
almost instantaneously.

00:15:07.820 --> 00:15:13.400
And the last kind of interface we have
here is the Output Transaction Interface.

00:15:13.510 --> 00:15:16.550
And essentially what this does is it kind
of consolidates the number of reports

00:15:16.550 --> 00:15:18.110
that you're sending to the device.

00:15:18.200 --> 00:15:22.290
So let's say, for example,
you have a keyboard device and you have

00:15:22.290 --> 00:15:26.520
basically three LEDs defined on there,
and you want to toggle the Caps

00:15:26.670 --> 00:15:28.700
Lock LED and the Num Lock LED.

00:15:29.380 --> 00:15:32.160
Well, if you use just the
IOHID device interface,

00:15:32.270 --> 00:15:34.870
you'd set the element value
for the Caps Lock and set the

00:15:34.870 --> 00:15:36.080
element value for the Num Lock.

00:15:36.380 --> 00:15:39.870
What this does is actually send
two separate reports to the device,

00:15:39.900 --> 00:15:41.210
and you might actually be blocking.

00:15:41.220 --> 00:15:44.650
What we do here is you would just
add it to Output Transaction,

00:15:44.650 --> 00:15:47.150
and now instead of sending
two separate reports,

00:15:47.250 --> 00:15:48.460
you'll just send the one down.

00:15:48.460 --> 00:15:52.840
And this is kind of a replacement for
Set Report for less advanced users

00:15:52.920 --> 00:15:57.500
who don't actually care about how
it's laid out in terms of the report.

00:16:01.810 --> 00:16:06.200
So we've had some improvements to the
HIID Manager since Jaguar or 10.2,

00:16:06.330 --> 00:16:09.400
and one of the major things
we've added is the ability to

00:16:09.460 --> 00:16:11.170
see a HIID events from a device.

00:16:11.490 --> 00:16:14.990
And essentially what this does is,
suppose you have a credit card

00:16:15.040 --> 00:16:16.590
swiper or a barcode reader.

00:16:16.680 --> 00:16:20.260
These devices actually behave
and look similar to keyboards,

00:16:20.260 --> 00:16:24.070
and so when you swipe a credit card
or you read a barcode or whatever,

00:16:24.070 --> 00:16:26.820
it actually spews out
key events to the system.

00:16:26.820 --> 00:16:31.630
And this isn't necessarily behavior
that you actually want to achieve.

00:16:31.740 --> 00:16:32.620
It's just a way for the
system to see what happens.

00:16:32.690 --> 00:16:38.460
So if you just want your application
to interact with it directly

00:16:38.460 --> 00:16:40.620
and only see those events,
you would go ahead and seize

00:16:40.620 --> 00:16:43.080
that device and make sure that
the events only come to you.

00:16:45.120 --> 00:16:47.790
We've also added some
improvements to the API.

00:16:47.910 --> 00:16:51.780
Of course, as you may have known,
in 10.3, to support Force Feedback,

00:16:51.780 --> 00:16:55.230
we added two new APIs for
GetReport and SetReport,

00:16:55.230 --> 00:16:58.580
which are the more advanced
APIs that I mentioned earlier.

00:16:58.630 --> 00:17:01.190
And then new in Panther,
what I've added is the

00:17:01.190 --> 00:17:02.860
copy matching elements.

00:17:02.860 --> 00:17:05.380
And essentially what this does is
instead of you having to traverse

00:17:05.520 --> 00:17:08.760
through the registry to find what
the capabilities are of the device,

00:17:08.820 --> 00:17:10.560
all you would do is set
up a matching dictionary,

00:17:10.560 --> 00:17:12.960
like you do for finding
a particular device,

00:17:13.020 --> 00:17:17.020
to find an actual element,
or to see if that device contains

00:17:17.030 --> 00:17:19.260
the behavior that you're expecting.

00:17:19.310 --> 00:17:24.340
And another API that we've added is
SetInterruptReportHandlerCallback.

00:17:24.380 --> 00:17:28.350
And essentially what this lets you do,
instead of polling a device via GetReport

00:17:28.580 --> 00:17:33.340
to get the current report of that device,
this allows you to actually be notified

00:17:33.340 --> 00:17:38.320
every time an incoming report comes in
from the interrupt in pipe of the device.

00:17:38.420 --> 00:17:42.520
So it's extremely useful for people who
need to know that advanced behavior.

00:17:44.860 --> 00:17:47.800
And so, let's start off with some basic
techniques on how to use the

00:17:47.800 --> 00:17:51.070
HID Manager in some simple code.

00:17:51.320 --> 00:17:54.840
So, if you guys have already messed
around with I/O Kit and know

00:17:54.840 --> 00:17:57.940
how to actually match a device,
essentially what we're doing here

00:17:58.120 --> 00:18:02.050
is go ahead and creating a matching
dictionary to find a HIID device.

00:18:02.630 --> 00:18:08.770
What we're doing though is refining
the search to actually look for a mouse

00:18:08.890 --> 00:18:12.200
or all mice devices on the system.

00:18:12.200 --> 00:18:16.720
So, what we've done here is create a
usage page and usage number ref,

00:18:16.860 --> 00:18:18.600
and then added it to
the matching dictionary,

00:18:18.640 --> 00:18:21.870
and then gone ahead and tried to
find all services matching that

00:18:21.870 --> 00:18:24.470
particular dictionary or criteria.

00:18:27.150 --> 00:18:29.810
Now that we've gone ahead
and grabbed the iterator,

00:18:29.810 --> 00:18:33.300
we go ahead and try to cycle through
all the devices that we found,

00:18:33.390 --> 00:18:34.990
or services that we found.

00:18:37.720 --> 00:18:41.070
Now that we've found a device and
we're on that particular device,

00:18:41.070 --> 00:18:43.390
the first thing we'll have
to do is actually create

00:18:43.390 --> 00:18:44.700
the IOCF plugin interface.

00:18:44.700 --> 00:18:47.190
And this is something that
you might be used to if you've

00:18:47.270 --> 00:18:50.560
messed around with USB devices or
FireWire devices from user land.

00:18:50.560 --> 00:18:53.920
Once you've acquired the
IOCF plugin interface,

00:18:53.920 --> 00:18:58.170
let's go ahead and create an
interface to the HIID device itself.

00:18:58.260 --> 00:19:00.990
And so we query the interface
of that plugin to acquire

00:19:00.990 --> 00:19:02.590
the interface of the device.

00:19:06.890 --> 00:19:09.390
Now that we've acquired the interface,
the first thing we need to do is

00:19:09.390 --> 00:19:11.820
actually open a device for communication.

00:19:11.930 --> 00:19:14.540
So like I mentioned earlier,
we have actually two different

00:19:14.540 --> 00:19:16.360
options here for opening the device.

00:19:16.420 --> 00:19:18.780
We can do a standard open,
which will just allow it to

00:19:18.780 --> 00:19:22.620
communicate like it does before,
and everyone, all clients receive events.

00:19:22.700 --> 00:19:25.120
Or you can actually perform
the seize right here,

00:19:25.180 --> 00:19:28.290
which will just maintain
that you will get direct

00:19:28.420 --> 00:19:29.940
communication with that device.

00:19:30.000 --> 00:19:32.540
If you do actually aren't
able to seize the device,

00:19:32.650 --> 00:19:35.340
you will get an error return back to you.

00:19:38.570 --> 00:19:40.830
Now that we've had the device open,
we actually want to find the

00:19:40.920 --> 00:19:43.180
capabilities of this device.

00:19:43.180 --> 00:19:45.820
And so let's go ahead and
set up a matching dictionary

00:19:45.820 --> 00:19:47.590
to find all the elements.

00:19:47.600 --> 00:19:50.660
So what we do here is go ahead
and allocate a CFDictionary,

00:19:50.680 --> 00:19:53.850
and then add-- let's say here
that we want to find all the

00:19:54.120 --> 00:19:56.060
button elements on this device.

00:19:56.150 --> 00:20:00.120
So what we do is go ahead and
add a usage page item inside the

00:20:00.120 --> 00:20:07.010
dictionary covering the buttons page,
and then go ahead and try to find

00:20:07.240 --> 00:20:10.680
all the buttons on that device.

00:20:10.680 --> 00:20:14.150
And what it should do is return
back to you a CFArray containing

00:20:14.150 --> 00:20:17.090
all the CFDictionary,
you know, registry entries for that

00:20:17.090 --> 00:20:20.670
device or for that element,
particular elements.

00:20:22.380 --> 00:20:24.860
Now that we've found all the elements,
we essentially want to

00:20:24.870 --> 00:20:27.040
store all the cookies,
and the cookies are the unique

00:20:27.110 --> 00:20:30.080
identifier to actually communicate
with that particular element.

00:20:30.080 --> 00:20:33.990
And so we just kind of cycle through
the array and store all the cookies

00:20:33.990 --> 00:20:35.990
into our own internal storage.

00:20:36.520 --> 00:20:38.740
As kind of a quick test,
we should just go ahead

00:20:38.740 --> 00:20:41.010
and grab the value,
the current value of the

00:20:41.010 --> 00:20:44.330
first button that we saw,
and you could easily just do that.

00:20:48.670 --> 00:20:51.240
Now that we've basically
interacted with the device,

00:20:51.240 --> 00:20:54.050
we kind of want to see how to
actually create a queue interface,

00:20:54.050 --> 00:20:58.960
or grab all the values from that
button behavior that we've seen before.

00:20:58.960 --> 00:21:02.000
So what we want to do is
first create the queue.

00:21:02.000 --> 00:21:05.330
So we allocate the queue
from the device interface,

00:21:05.330 --> 00:21:08.790
and then we go ahead and create
an internal queue within there.

00:21:08.800 --> 00:21:12.220
And so in this example,
we're only really creating a queue

00:21:12.370 --> 00:21:15.310
that's about eight fields deep,
and that's pretty much

00:21:15.310 --> 00:21:16.520
what we really need.

00:21:17.500 --> 00:21:20.280
It's all that's essential for
us to interact with that device.

00:21:20.360 --> 00:21:24.570
Now let's go ahead and cycle through all
the buttons that we've collected before

00:21:24.750 --> 00:21:26.380
and add them individually to that queue.

00:21:32.170 --> 00:21:34.150
Now that we've added the
elements to that queue,

00:21:34.250 --> 00:21:38.240
we go ahead and set ourselves
up for asynchronous operation.

00:21:38.500 --> 00:21:40.600
So what we do first is create
the async event source,

00:21:40.730 --> 00:21:43.740
and what we do is we use this in
conjunction with the CF run loop.

00:21:43.810 --> 00:21:47.960
And kind of what we set up here with
the HId Manager is we expect this

00:21:47.960 --> 00:21:50.700
to work only with a CF run loop.

00:21:50.770 --> 00:21:53.520
So after we've added the
event source to the run loop,

00:21:53.590 --> 00:21:55.680
we go ahead and send the event call out.

00:21:55.790 --> 00:22:00.420
And this is the callback function
that will call into your application

00:22:00.420 --> 00:22:03.160
to go ahead and drain the queue.

00:22:05.410 --> 00:22:07.730
So as soon as, you know,
events come on the queue,

00:22:07.730 --> 00:22:11.320
we go ahead and trigger your application,
and we call your callback.

00:22:11.440 --> 00:22:13.890
And now that we've got
this callback being called,

00:22:14.110 --> 00:22:17.970
you go ahead and cycle through the queue
and determine and do whatever operation

00:22:18.070 --> 00:22:20.300
you want to do on that particular event.

00:22:20.420 --> 00:22:22.700
And it's pretty straightforward.

00:22:26.490 --> 00:22:30.160
So now that we've covered
both device and queues,

00:22:30.190 --> 00:22:32.540
let's go into the output
transaction interface.

00:22:32.540 --> 00:22:35.100
And for this one,
we're not actually going to be using

00:22:35.100 --> 00:22:37.710
the mouse that we described earlier,
but instead kind of a keyboard,

00:22:37.720 --> 00:22:40.100
and assume that we've set
it up in the same manner.

00:22:40.100 --> 00:22:45.180
So essentially what we have here
is a keyboard has both a caps lock,

00:22:45.240 --> 00:22:49.160
an LED, and a scroll lock,
or a caps lock LED, a scroll lock LED,

00:22:49.230 --> 00:22:50.400
and an unlock LED.

00:22:50.400 --> 00:22:54.780
So what we do is go ahead and
create the transaction interface,

00:22:55.970 --> 00:22:58.970
and then add those items
to the transaction.

00:23:01.330 --> 00:23:03.960
Also what I'm going to do
is set the default values.

00:23:03.990 --> 00:23:07.080
So basically what this is,
is after you've committed a transaction,

00:23:07.080 --> 00:23:11.510
this is the value that this element
will revert to for the next time,

00:23:11.510 --> 00:23:15.690
or each subsequent commit that
you do on this transaction.

00:23:15.690 --> 00:23:19.180
So right now we're just
going to zero it all out.

00:23:24.770 --> 00:23:26.960
Now that we've gone ahead and
set the default values and added

00:23:26.960 --> 00:23:29.170
those elements to the transaction,
what we want to do is

00:23:29.170 --> 00:23:30.320
set the element values.

00:23:30.320 --> 00:23:34.050
So basically all we're concerned about
doing here is setting the LED values

00:23:34.220 --> 00:23:35.570
for the caps lock and num lock.

00:23:35.650 --> 00:23:38.740
So we go ahead and turn those
on and then set the values.

00:23:38.780 --> 00:23:41.810
After we've done that,
we go ahead and commit the transaction.

00:23:41.840 --> 00:23:45.330
And essentially what will happen
here is both the num lock LED and

00:23:45.330 --> 00:23:48.890
the caps lock LED will turn on,
and the scroll lock LED will remain off.

00:23:49.340 --> 00:23:54.030
Had we not actually included the
scroll lock LED into the transaction,

00:23:54.080 --> 00:23:56.690
the value would have remained
the same value that it would

00:23:56.690 --> 00:23:57.900
have been prior to the commit.

00:23:57.920 --> 00:24:00.720
Because basically what we do is we do
not go ahead and change that value,

00:24:00.780 --> 00:24:02.300
it just remains the same value.

00:24:06.500 --> 00:24:12.500
So basically in summary,
I hope you've got a better understanding

00:24:12.580 --> 00:24:15.420
of what a Human Interface Device is.

00:24:15.690 --> 00:24:20.440
kind of a basic understanding of how
HIID is implemented on Mac OS X and basic

00:24:20.490 --> 00:24:23.590
techniques for using the HIID Manager.

00:24:24.830 --> 00:24:27.780
Some additional references are,
you can look at the HIID pages that

00:24:27.780 --> 00:24:32.180
we have on our developer tech pubs,
or you can look at how to write a

00:24:32.180 --> 00:24:34.850
device driver if you're so inclined.

00:24:34.860 --> 00:24:40.320
And if you want a more in-depth
knowledge of how HIID actually works,

00:24:40.420 --> 00:24:42.870
you can look at the USB IF's HIID pages.

00:24:45.170 --> 00:24:47.140
With that,
I'll turn it over to Fernando Urbin,

00:24:47.220 --> 00:24:50.210
of our USB team, to cover Force Feedback.

00:24:55.310 --> 00:24:57.120
Thank you, Rob.

00:24:57.220 --> 00:25:02.200
We're going to change gears a little bit
here and I'll talk about Force Feedback

00:25:02.210 --> 00:25:05.540
and what we've done on Mac OS X.

00:25:05.600 --> 00:25:11.080
I will start with a brief introduction
on what Force Feedback really is and

00:25:11.080 --> 00:25:17.520
how we implemented an architecture to
support Force Feedback in our system.

00:25:18.000 --> 00:25:22.940
Then I'm going to give some hints
to application developers on some

00:25:22.950 --> 00:25:27.720
of the APIs and what they need
to do to support Force Feedback.

00:25:27.720 --> 00:25:30.800
And then for those of you,
if there are any,

00:25:30.800 --> 00:25:35.960
that have Force Feedback devices that are
not supported on the system right now,

00:25:36.170 --> 00:25:41.720
what you will need to do in order
to provide support for your devices.

00:25:43.560 --> 00:25:48.500
You'll see how Force Feedback
fits in our system.

00:25:48.590 --> 00:25:54.890
Hopefully you'll understand why we
did what we did and the way we did it.

00:25:55.610 --> 00:25:58.620
Perhaps you also know how
you can now take advantage of

00:25:58.790 --> 00:26:03.040
Force Feedback and how you,
as I mentioned, will be able to develop a

00:26:03.160 --> 00:26:05.660
plugin to work in our system.

00:26:05.850 --> 00:26:08.240
So what is Force Feedback?

00:26:08.330 --> 00:26:14.600
The official definition by those who
know is that it is a technology that

00:26:14.610 --> 00:26:19.880
enhances the human computer interface
by engaging your sense of touch.

00:26:20.130 --> 00:26:25.250
Over here on the podium we have
this Force Feedback steering wheel,

00:26:25.450 --> 00:26:28.770
but it is important to know
that Force Feedback devices are

00:26:28.770 --> 00:26:32.300
not limited to gaming devices.

00:26:32.430 --> 00:26:39.190
Immersion has this medical
device that is used to train

00:26:39.530 --> 00:26:48.000
medical professionals on how to perform
or how to put an injection on a person.

00:26:48.000 --> 00:26:55.930
And it actually provides feedback when
the needle pierces the simulated skin.

00:26:55.930 --> 00:27:02.360
And once it goes through the skin
when it actually finds the vein.

00:27:02.630 --> 00:27:04.720
And it's really cool.

00:27:04.720 --> 00:27:08.470
I am not a doctor nor
do I play one on TV.

00:27:08.470 --> 00:27:12.120
But it feels just like the real thing.

00:27:12.120 --> 00:27:15.470
And personally, you know,
I would like more nurses to...

00:27:16.880 --> 00:27:20.330
Use this type of devices.

00:27:20.600 --> 00:27:22.260
I mentioned Immersion.

00:27:22.360 --> 00:27:26.890
They are the leader in
Force Feedback technology.

00:27:26.960 --> 00:27:32.260
They have several patents,
and they actually license

00:27:32.260 --> 00:27:35.580
their technology to several
hardware manufacturers.

00:27:35.580 --> 00:27:41.140
So you'll see Force Feedback devices
that do not have the Immersion,

00:27:41.140 --> 00:27:44.940
are not produced by Immersion,
but they have what they call their

00:27:45.090 --> 00:27:47.400
TouchSense technology logo on the boxes.

00:27:49.800 --> 00:27:53.930
Before we delve further into the APIs,
I would like to go through some

00:27:53.930 --> 00:27:58.940
terminology so that you can understand
better what I'm talking about later on.

00:27:59.020 --> 00:28:05.610
A Force Feedback Device is, first of all,
a USB HIID compliant device.

00:28:05.700 --> 00:28:12.410
Now, the USB HIID working group has
a specification for what they

00:28:12.410 --> 00:28:19.070
call Physical Interface Devices,
which are Force Feedback Devices.

00:28:20.340 --> 00:28:24.820
Force Feedback devices do not have
to be compliant to this physical

00:28:24.820 --> 00:28:29.130
interface device specification
in order to work in the system.

00:28:29.470 --> 00:28:31.980
That's why we,
as we're going to see later,

00:28:32.050 --> 00:28:34.770
have this hardware plugin architecture.

00:28:34.910 --> 00:28:39.420
These devices are capable
of creating a force,

00:28:39.450 --> 00:28:43.720
or what is called an effect,
that the user can feel when

00:28:43.720 --> 00:28:46.280
they're using the device.

00:28:46.940 --> 00:28:50.840
The effects themselves have
to be played through software.

00:28:50.840 --> 00:29:00.680
You have to do something in order to
make that device create that feeling.

00:29:01.050 --> 00:29:03.400
They can be done in either of two ways.

00:29:03.400 --> 00:29:06.740
You can have a programmatic
interface where you download the

00:29:06.740 --> 00:29:09.720
effect and then you massage it,
modify it, start, stop, etc.

00:29:09.720 --> 00:29:15.030
Or actually,
if you can download something to the

00:29:15.030 --> 00:29:22.120
device and have that device respond
automatically to an action by the user.

00:29:22.120 --> 00:29:24.330
So, you know,
the most obvious one is when you

00:29:24.330 --> 00:29:29.440
have a shoot-em-up game and the
person playing hits the trigger

00:29:29.730 --> 00:29:33.300
and you get a recoil right away.

00:29:33.300 --> 00:29:38.590
And it's a benefit that the device
does it automatically because you

00:29:38.650 --> 00:29:42.550
don't have the latency of going up
to the application and coming back

00:29:42.560 --> 00:29:45.860
down and setting up the effect.

00:29:46.610 --> 00:29:50.300
There are really four
basic types of effects.

00:29:50.350 --> 00:29:52.700
A constant force effect,
not surprisingly,

00:29:52.700 --> 00:29:59.360
is a constant effect that
varies in any one direction.

00:29:59.670 --> 00:30:05.870
A ramp effect is an effect that increases
in strength or decreases in strength,

00:30:05.870 --> 00:30:09.130
again, in one direction.

00:30:09.180 --> 00:30:12.980
Not surprisingly,
a periodic effect is one that

00:30:12.980 --> 00:30:17.710
varies over time or over strength.

00:30:17.840 --> 00:30:23.290
And then the final one are the condition
effects that are as shown on the slide,

00:30:23.370 --> 00:30:25.540
the spring or the damper.

00:30:25.570 --> 00:30:32.020
And those effects increase
in force as the device moves

00:30:32.120 --> 00:30:34.790
away from the center line.

00:30:34.960 --> 00:30:38.480
So, you know,
if you have a spring effect and

00:30:38.490 --> 00:30:40.760
you're pulling away from the spring,
you know,

00:30:40.760 --> 00:30:45.380
the force is going to increase as
you're going farther and farther down.

00:30:46.160 --> 00:30:49.490
Briefly, some example of effects.

00:30:49.500 --> 00:30:54.920
On a racing simulation,
you can have the pavement vary,

00:30:55.020 --> 00:31:01.810
and your feedback is going to change
depending on whether you are driving

00:31:01.810 --> 00:31:08.600
on the paved road or you're going
off-road and you're on a dirt road.

00:31:08.600 --> 00:31:12.780
And if you have a flight simulation,
if you have turbulence, of course,

00:31:12.780 --> 00:31:14.940
your stick can start
shaking and everything.

00:31:16.000 --> 00:31:19.040
Again, this is not limited just
to gaming simulations.

00:31:19.140 --> 00:31:25.050
There are some programs that make use of
Force Feedback on educational settings,

00:31:25.050 --> 00:31:30.280
and you can have a pendulum or a...

00:31:30.400 --> 00:31:37.200
We present details on the HID Manager and
the new Force Feedback Framework

00:31:37.200 --> 00:31:44.220
delivered in Mac OS X 10.2.3,
and show you how to use both to give

00:31:44.690 --> 00:31:47.640
users the ability to control and
feel your application's environment.

00:31:47.640 --> 00:31:47.640
For Force Feedback device developers,
we describe how to add

00:31:47.640 --> 00:31:47.640
support for your products.

00:31:50.450 --> 00:31:54.600
So, how does Force Feedback
work on our system?

00:31:54.640 --> 00:32:00.820
Last fall,
we decided to work with Immersion.

00:32:01.070 --> 00:32:04.380
As I mentioned, they are the leaders on
Force Feedback technology.

00:32:04.700 --> 00:32:12.760
And we work with them in order to bring
Force Feedback support on Mac OS X.

00:32:13.500 --> 00:32:17.140
What we arrived at was
a two-pronged approach.

00:32:17.310 --> 00:32:21.100
There's a Force Feedback Framework
for application developers,

00:32:21.110 --> 00:32:28.040
and that Force Feedback Framework uses
some hardware vendor-specific drivers,

00:32:28.100 --> 00:32:33.220
which we'll see later,
that are actually just CFPlugins,

00:32:33.310 --> 00:32:39.690
to abstract the hardware so that the
Force Feedback Framework itself can

00:32:39.690 --> 00:32:39.950
use any type of Force Feedback device.

00:32:40.210 --> 00:32:44.080
We actually shipped support
for Force Feedback in the

00:32:44.090 --> 00:32:49.100
December of last year,
the 10.2.3 release.

00:32:49.100 --> 00:32:53.790
And initially we had support for
several devices with Immersion

00:32:53.790 --> 00:32:58.260
TouchSense technology from Logitech,
from Immersion themselves,

00:32:58.420 --> 00:33:03.200
from SciTech and several others.

00:33:04.020 --> 00:33:09.990
A couple of weeks after release,
two games came out actually

00:33:10.090 --> 00:33:14.470
supporting Force Feedback,
and that was the F1

00:33:14.470 --> 00:33:18.490
Championship Series and
NASCAR Racing 2002.

00:33:19.950 --> 00:33:24.390
Our goals when we started
looking into supporting

00:33:24.490 --> 00:33:31.610
Force Feedback on Mac OS X was,
number one, we had a time to market.

00:33:31.800 --> 00:33:56.300
[Transcript missing]

00:33:57.470 --> 00:34:00.290
These were F1
Championship Series and NASCAR,

00:34:00.290 --> 00:34:02.840
you know, those games existed on the PC.

00:34:02.880 --> 00:34:06.660
We wanted to bring them over
and have wheels work with them.

00:34:06.660 --> 00:34:09.870
And of course,
we wanted hardware manufacturers

00:34:10.020 --> 00:34:15.600
to be able to support their
device on Mac OS X fairly easily.

00:34:17.860 --> 00:34:21.310
I'm a big proponent on not having
to reinvent the wheel when there's

00:34:21.330 --> 00:34:23.750
something that is acceptable and works.

00:34:24.400 --> 00:34:28.500
Unfortunately,
we had as a partner Immersion,

00:34:28.510 --> 00:34:34.100
and they have large expertise
in supporting Force Feedback

00:34:34.100 --> 00:34:37.360
in different systems,
and they knew what worked in other

00:34:37.360 --> 00:34:39.450
platforms and what didn't work.

00:34:39.540 --> 00:34:44.370
So, we were fairly lucky to work
with them and leverage their

00:34:44.370 --> 00:34:46.580
expertise in this field.

00:34:48.830 --> 00:34:51.520
We came up with then the
following architecture.

00:34:51.520 --> 00:34:54.690
As you see here at the top,
we have an application,

00:34:54.690 --> 00:34:58.440
be it a game or an educational title.

00:34:58.440 --> 00:35:03.600
And of course,
it is using the HIID Manager to

00:35:03.600 --> 00:35:06.930
control the application.

00:35:07.300 --> 00:35:47.800
[Transcript missing]

00:35:48.530 --> 00:35:53.970
The vendor driver itself
then uses mostly set reports,

00:35:53.970 --> 00:36:00.240
and this is why we had to add this
advanced APIs to the HIID Manager,

00:36:00.240 --> 00:36:06.220
to send reports over to the device
so that it can do its effects.

00:36:06.360 --> 00:36:12.780
Over the bubble on the right is the...

00:36:13.110 --> 00:36:21.470
Vendor-specific code-less kegs,
and as we'll see later

00:36:21.470 --> 00:36:29.060
for hardware developers,
it's just a method of allowing

00:36:29.060 --> 00:36:29.060
the Force Feedback Framework
to find the driver that is

00:36:29.060 --> 00:36:29.060
used by a particular device.

00:36:30.430 --> 00:36:37.010
So let's go into the Force Feedback
Framework itself and what it is.

00:36:37.250 --> 00:36:42.440
First of all, it is fairly similar to the
Force Feedback API that is

00:36:42.440 --> 00:36:45.730
found in other architectures.

00:36:45.880 --> 00:36:50.800
We have three basic types
of APIs in the framework.

00:36:50.850 --> 00:36:58.200
One section is system-wide APIs,
and for your convenience,

00:36:58.200 --> 00:37:03.100
we named them to start just with FF for,
not surprisingly, Force Feedback.

00:37:03.160 --> 00:37:10.500
Then we have device-wide APIs that
deal just with effects on one device,

00:37:10.500 --> 00:37:13.450
and those start with FF device.

00:37:14.450 --> 00:37:17.950
And finally,
we have effect-wide APIs that, again,

00:37:17.960 --> 00:37:21.210
not surprisingly,
deal with effects on a single device,

00:37:21.210 --> 00:37:24.710
and those API names start with FF effect.

00:37:24.820 --> 00:37:28.030
And try saying that three times fast.

00:37:28.040 --> 00:37:30.680
System-wide Force Feedback APIs.

00:37:30.680 --> 00:37:35.470
There are really only those
three APIs that are on the slide.

00:37:35.530 --> 00:37:42.080
The most important one, actually,
is the FF is Force Feedback API.

00:37:43.080 --> 00:37:48.590
As noted on the diagram earlier,
the application is already using a

00:37:48.600 --> 00:37:52.420
HIT device to get input from the user.

00:37:52.420 --> 00:37:58.120
And so you can use the IO service
object for that device to inquire

00:37:58.120 --> 00:38:04.440
from the Force Feedback framework
on whether that device actually

00:38:04.620 --> 00:38:07.530
has Force Feedback support or not.

00:38:07.600 --> 00:38:10.840
And what the Force Feedback
framework then does,

00:38:10.840 --> 00:38:13.030
as we'll see later, is look for the FF.

00:38:13.080 --> 00:38:15.860
And then you can use the
CFPlugin for that device and see

00:38:15.860 --> 00:38:18.480
if it exists and if it's available,
et cetera.

00:38:18.480 --> 00:38:22.510
But, of course, if it's not supported,
then this will return false,

00:38:22.510 --> 00:38:25.430
and you don't have to
provide Force Feedback.

00:38:25.450 --> 00:38:30.080
Then the other two calls are,
and as you'll see there later,

00:38:30.080 --> 00:38:32.020
everything matches.

00:38:32.040 --> 00:38:35.440
You have a create device,
and once you're finished with it,

00:38:35.440 --> 00:38:37.140
you have a release device.

00:38:39.800 --> 00:38:45.790
Device-wide APIs are those that deal
with effects on a single device.

00:38:45.800 --> 00:38:50.540
These are some examples
of the APIs themselves.

00:38:50.540 --> 00:38:56.980
Again, we have a create effect and a
destroy effect or release effect API.

00:38:56.980 --> 00:39:03.180
Some of the other APIs that you
encounter are the Get Force Feedback

00:39:03.180 --> 00:39:10.060
capabilities that will allow a game to
actually know what the device can do.

00:39:10.060 --> 00:39:14.220
Not all devices support all
types of effects at all.

00:39:14.220 --> 00:39:19.330
If you're a racing game,
you need to know which

00:39:20.180 --> 00:39:23.980
effects you can support.

00:39:23.980 --> 00:39:29.320
The APIs also allow you to actually
send an effect to that device.

00:39:30.420 --> 00:39:34.960
Now,
effect-wide APIs allows you to actually

00:39:35.200 --> 00:39:41.300
send the effect down to the device,
and then to start, stop it, modify it,

00:39:41.300 --> 00:39:45.790
and essentially manage
that effect on that device.

00:39:45.800 --> 00:39:50.060
These devices are fairly
complex themselves,

00:39:50.060 --> 00:39:55.170
and they have memory, and memory,
there's just a limited amount,

00:39:55.250 --> 00:39:58.460
and so you sometimes have to
manage that memory yourself.

00:39:58.560 --> 00:40:02.620
The plugin will do some of it for you,
but you'll have to manage some

00:40:02.620 --> 00:40:05.440
of that yourself in some cases.

00:40:05.440 --> 00:40:11.800
Again, some of the examples of this
API is download the effect,

00:40:12.000 --> 00:40:17.070
unload the effect,
get the current parameters for that

00:40:17.070 --> 00:40:23.450
effect that is already in the device,
so that you know what you need to change,

00:40:23.760 --> 00:40:26.150
and you can start and stop it.

00:40:29.890 --> 00:40:37.730
I'd like to say that the devil in
all these APIs are these structures.

00:40:37.930 --> 00:40:42.420
They're quite complex if
you're not familiar with

00:40:42.500 --> 00:40:44.740
Force Feedback implementation.

00:40:45.210 --> 00:40:49.250
However,
you have to set up all these different

00:40:49.310 --> 00:40:53.210
structures to have the right data,
so the devil is in the details or

00:40:53.240 --> 00:40:55.960
in the structures used by the API.

00:40:57.250 --> 00:41:02.000
Fortunately, these structures are very
similar to the structures that

00:41:02.670 --> 00:41:05.810
are used in other platforms.

00:41:05.830 --> 00:41:10.510
And if you remember my earlier
slide where one of our goals was

00:41:10.590 --> 00:41:16.460
to make it easy for porting houses
to add Force Feedback to the

00:41:17.230 --> 00:41:21.720
Mac OS X version of their games,
you can understand why this is so.

00:41:21.720 --> 00:41:26.720
We have HeaderDoc'd the header
files pretty extensively.

00:41:26.720 --> 00:41:32.720
And so you'll be able to grasp
some of the details from that.

00:41:32.900 --> 00:41:37.640
And as I understand it,
the Microsoft developer side has

00:41:37.640 --> 00:41:43.710
an extensive and quite complete
documentation on Force Feedback.

00:41:45.890 --> 00:41:53.810
This is not to scare you,
but it's just a sample of what

00:41:53.810 --> 00:42:01.860
sort of things need to be set
up in order to create an effect.

00:42:02.270 --> 00:42:08.510
When we were working with Immersion,
Immersion created a tool to

00:42:08.510 --> 00:42:12.080
test the Force Feedback API.

00:42:12.100 --> 00:42:15.300
And now I'm going to give you
a little demo of this tool.

00:42:15.300 --> 00:42:19.630
As you can see,
it's almost as complicated

00:42:19.770 --> 00:42:23.530
as the slide I just showed.

00:42:23.530 --> 00:42:23.530
But,

00:42:23.730 --> 00:42:29.150
It allows you to test, you know, well,
it allowed us initially to test

00:42:29.250 --> 00:42:31.180
whether our API was working.

00:42:31.180 --> 00:42:34.600
Then hardware vendors used it
to test whether their hardware

00:42:34.600 --> 00:42:38.750
plugin was doing the right thing,
because it's an easy way of

00:42:38.750 --> 00:42:43.490
setting up all the parameters,
and I can tell you it's

00:42:43.670 --> 00:42:44.380
all the parameters.

00:42:44.380 --> 00:42:50.190
We are going to make this the binary
for this tool available on the developer

00:42:50.370 --> 00:42:53.100
website in the very near future.

00:42:53.830 --> 00:42:57.270
And then later on, actually,
we're going to release the

00:42:57.270 --> 00:42:59.060
source code to this tool.

00:42:59.060 --> 00:43:03.480
I'm just going to go
through a quick demo.

00:43:03.480 --> 00:43:07.250
It'll be hard maybe for you
to see the wheel shaking,

00:43:07.270 --> 00:43:07.910
but...

00:43:08.750 --> 00:43:10.910
I want to make sure that
you know that it is real.

00:43:10.910 --> 00:43:14.840
Here on the right are the
APIs related just like

00:43:14.930 --> 00:43:21.070
I mentioned in the earlier slide,
just Force Feedback APIs,

00:43:21.180 --> 00:43:23.480
device and effect APIs.

00:43:23.480 --> 00:43:27.360
The first thing that you
need to do is create device.

00:43:27.360 --> 00:43:32.540
This actually is going to go and tell us
whether this is a Force Feedback device.

00:43:32.620 --> 00:43:35.470
Over here on the left,
it tells us that this is

00:43:35.480 --> 00:43:37.410
the Logitech Momo Force.

00:43:37.410 --> 00:43:42.280
It doesn't tell us that it's
the nice leather version of it,

00:43:42.280 --> 00:43:44.790
but it's the expensive one.

00:43:44.800 --> 00:43:47.170
We went and we created that device.

00:43:47.260 --> 00:43:52.610
I'm just going to make simple calls.

00:43:53.490 --> 00:43:55.330
That uses the default values.

00:43:55.520 --> 00:44:00.440
So we go and we create an
effect that is a square effect,

00:44:00.440 --> 00:44:04.120
a square wave effect,
and we go and start it.

00:44:05.400 --> 00:44:10.400
and I will be presenting the
first part of this session.

00:44:10.400 --> 00:44:13.200
- Hi, I'm Craig Keithley,
and I'm the Director of the Office of

00:44:13.320 --> 00:44:15.400
the Human Interface Device Development.

00:44:15.400 --> 00:44:20.250
I'm here to talk about the
new Force Feedback Framework.

00:44:20.650 --> 00:44:25.390
The first thing we're gonna
do is to create a new Format,

00:44:25.400 --> 00:44:27.410
and we're gonna create a new Format.

00:44:28.040 --> 00:44:32.380
And now it shakes a little harder.

00:44:32.470 --> 00:44:37.230
And finally,
we are going to change the duration

00:44:37.240 --> 00:44:41.530
from three gazillion to nine gazillion.

00:44:42.950 --> 00:44:48.710
And I need to release that
effect and create and start,

00:44:48.710 --> 00:44:54.380
and now it'll go ahead and run
for a longer period of time.

00:44:55.100 --> 00:44:59.650
So again, for application developers,
this is useful sort of to test the

00:44:59.650 --> 00:45:05.830
kind of effects that you can use on the
device that you're targeting supports.

00:45:05.900 --> 00:45:10.490
And of course, for hardware vendors,
it's a way of verifying that

00:45:10.500 --> 00:45:14.570
their plugin does everything
that they expect it to do.

00:45:14.580 --> 00:45:16.700
So we can go back to the slides.

00:45:18.660 --> 00:45:23.080
Now I'm going to go and talk for
a little bit about what hardware

00:45:23.080 --> 00:45:29.280
vendors need to do in order to support
their devices in our architecture.

00:45:29.280 --> 00:45:33.840
As I mentioned earlier,
the hardware plugin abstracts

00:45:33.850 --> 00:45:38.520
the hardware so that the
Force Feedback Framework can use

00:45:38.520 --> 00:45:41.640
any type of Force Feedback device.

00:45:43.260 --> 00:45:46.920
Second bullet, not surprisingly again,
this is very similar to the

00:45:46.920 --> 00:45:50.770
Force Feedback drivers that are
supported in other architectures.

00:45:50.930 --> 00:45:55.780
So if you have experience with those,
you'll feel right at home.

00:45:55.780 --> 00:46:01.820
I actually,
with some of the hardware vendors that

00:46:01.820 --> 00:46:10.010
I worked with when we were developing
their drivers and our support,

00:46:10.700 --> 00:46:15.350
One of them has exactly the
same code base for both the

00:46:15.350 --> 00:46:17.420
Wintel platform and our platform.

00:46:17.540 --> 00:46:21.600
And of course that is a big win.

00:46:21.600 --> 00:46:28.900
And he was able to give us his driver
in a very short amount of time.

00:46:28.900 --> 00:46:30.940
But compatible and everything.

00:46:30.940 --> 00:46:35.800
It is a CFPlugin just like IOHitLib,
IOUSBlib.

00:46:35.800 --> 00:46:42.580
Like I mentioned on the diagram,
how we use to inform the force

00:46:42.580 --> 00:46:45.180
feedback framework that a,

00:46:45.450 --> 00:46:50.040
Particular device supports
the Force Feedback is we

00:46:50.040 --> 00:46:51.940
use this code like text.

00:46:51.940 --> 00:46:55.300
And if you're not familiar
with the USB matching criteria

00:46:55.470 --> 00:47:02.100
that is used in our system,
there's Q&A 1076, if I'm not mistaken,

00:47:02.100 --> 00:47:08.150
that abstracts what the
USB Common Class Specification 1.0

00:47:08.580 --> 00:47:15.000
says with respect to how USB devices
and interfaces should match.

00:47:15.690 --> 00:47:22.030
And we use this to,
and a code like text just means

00:47:22.030 --> 00:47:26.650
that it's a text with no binaries,
it's just a plist.

00:47:26.650 --> 00:47:31.350
And we use this plist to
merge a dictionary into a

00:47:31.350 --> 00:47:37.350
USB interface node of the device,
and the Force Feedback Framework

00:47:37.350 --> 00:47:39.750
later will find this node.

00:47:39.780 --> 00:47:45.360
And what this dictionary has
is a UUID path key value.

00:47:45.500 --> 00:47:49.770
And it's a UUID pair that tells
the Force Feedback Framework where

00:47:50.300 --> 00:47:56.550
the plugin for this device is,
and what the UUID it is,

00:47:56.720 --> 00:48:00.470
so that it can go ahead and open it.

00:48:02.010 --> 00:48:09.860
This is a project builder sample
of the P-List for a Codelex text,

00:48:09.970 --> 00:48:14.250
and actually this is a sample project,
the WhizzyBank Force Feedback

00:48:14.250 --> 00:48:15.340
device that we have.

00:48:15.400 --> 00:48:19.880
As you can see highlighted,
we have a dictionary,

00:48:19.880 --> 00:48:23.490
the IO-CF Plugin Types Dictionary,
and again,

00:48:23.490 --> 00:48:27.920
this is a standard I/O Kit name
for this dictionary,

00:48:27.920 --> 00:48:32.920
and it has a UUID and
a path to the plugin,

00:48:32.920 --> 00:48:37.920
and in this case,
it lives at sampleforcefeedback KEXT.

00:48:37.920 --> 00:48:42.360
Notice that it starts at the KEXT level,
so you don't have to put

00:48:42.450 --> 00:48:43.890
system library extensions.

00:48:43.940 --> 00:48:50.380
It assumes that it is there,
and so it needs to be there.

00:48:50.950 --> 00:49:01.100
Again, the matching criteria over here
is the matching criteria for

00:49:01.100 --> 00:49:01.100
an I/O USB interface device.

00:49:02.120 --> 00:49:08.680
You should also note that our
class for this driver is the system

00:49:08.680 --> 00:49:16.150
supplied I/O USB HIID driver,
com.apple.iop.iousb_hiddriver.

00:49:16.150 --> 00:49:21.140
And because we added support for
setReport and getReport in 10.2.3,

00:49:21.230 --> 00:49:29.570
you have to depend on version 1.9.4
of the HIID driver and on version

00:49:29.600 --> 00:49:30.890
1.2.1 of the I/O USB HIID driver.

00:49:32.000 --> 00:49:39.980
Finally, the last item there is
the OS bundle required,

00:49:40.000 --> 00:49:43.000
and it says that it is SafeBoot.

00:49:43.000 --> 00:49:46.550
And you have to do this
because our system supplied

00:49:46.550 --> 00:49:50.730
HIID driver is SafeBoot as well,
and if you didn't do it,

00:49:50.730 --> 00:49:56.770
then you wouldn't participate
in the matching for your device,

00:49:57.180 --> 00:50:00.430
and it wouldn't work.

00:50:02.770 --> 00:50:08.420
Finally, the hardware plugin,
as I mentioned earlier,

00:50:08.420 --> 00:50:14.030
the IO Force Feedback lib.h defines
the interface for the plugin.

00:50:14.040 --> 00:50:18.590
It is a CFPlugin architecture,
so it's a COM interface,

00:50:18.590 --> 00:50:24.200
very similar to other platforms.

00:50:24.690 --> 00:50:28.720
You need to generate your
own UUID for your plugin.

00:50:29.080 --> 00:50:33.920
Universally unique identifier.

00:50:34.020 --> 00:50:38.920
Do not use the UUID that
is in the sample project.

00:50:38.920 --> 00:50:44.510
In fact, it won't compile without having
to remove a comment from the

00:50:44.510 --> 00:50:46.220
UUID that I provide there.

00:50:46.400 --> 00:50:49.040
So you know that you have
to go and generate your own.

00:50:49.040 --> 00:50:53.710
If not, it's not unique,
and another vendor that

00:50:53.790 --> 00:50:59.600
uses it will clash with it,
and things won't work.

00:50:59.600 --> 00:51:05.600
The system provides a
tool to generate a UUID,

00:51:05.600 --> 00:51:10.350
and so all you need to do is UUID gen,
and there you go, it has it.

00:51:10.360 --> 00:51:16.060
As I mentioned also,
the interface file itself

00:51:16.060 --> 00:51:18.370
is pretty well HeaderDoc'd.

00:51:18.910 --> 00:51:24.300
The Microsoft developer site has, again,
some good information on Force Feedback.

00:51:24.300 --> 00:51:30.860
And we will be making available a sample
Force Feedback plugin project that,

00:51:30.930 --> 00:51:38.480
you know, there's a lot of overhead
involved in creating a CFPlugin,

00:51:38.480 --> 00:51:42.050
and, you know, it doesn't change
between implementations.

00:51:42.060 --> 00:51:48.980
So, there's just a skeleton project
that provides the required methods,

00:51:49.070 --> 00:51:53.660
and you just have to go and do
the hard part and fill in the

00:51:53.730 --> 00:51:57.900
blanks to actually use your device.

00:51:59.100 --> 00:52:01.560
So I hope that you've gotten
an understanding of what

00:52:01.560 --> 00:52:06.440
Force Feedback devices are and why
you would use them in our system,

00:52:06.580 --> 00:52:10.900
how we actually implemented

00:52:11.370 --> 00:52:13.560
Force Feedback in Mac OS X.

00:52:13.590 --> 00:52:18.590
And if you are an application
developer or a hardware developer,

00:52:18.590 --> 00:52:22.300
you know how to start
using Force Feedback.

00:52:22.300 --> 00:52:29.530
Again, I would like to thank Immersion
for their partnership in developing

00:52:29.530 --> 00:52:30.900
the Force Feedback Framework.

00:52:30.900 --> 00:52:35.810
We did it in, I believe, record time.

00:52:35.810 --> 00:52:35.810
It was like,

00:52:36.050 --> 00:52:38.860
- Three months or four
months from when we started,

00:52:38.860 --> 00:52:44.000
when we decided to support Force Feedback
and when we actually delivered it.

00:52:44.040 --> 00:52:48.630
And we missed an earlier
update just by that much,

00:52:48.630 --> 00:52:48.630
so.

00:52:51.810 --> 00:52:56.740
Just for the DVD benefit,
those are some sessions that

00:52:57.300 --> 00:53:02.700
would be useful for you if you
are learning about Force Feedback.

00:53:02.700 --> 00:53:06.030
And with that, we'll close the session.

00:53:07.830 --> 00:53:11.800
There's the emails of the usual suspects.
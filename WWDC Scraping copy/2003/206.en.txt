---
Title:  ColorSync Update
Year:   2003
Web:    https://nonstrict.eu/wwdcindex/wwdc2003/206/

[!] This transcript was generated using Whisper, it has known transcription errors.
---

I'm Travis Brown, I'm the graphics and imaging evangelist, and I'm really sort of pleased to talk to you about some of the directions that Apple's going on in terms of color management because one thing that's really important for Apple is getting correct color for our users and our developers because nothing is more frustrating for a user when they have all these color input devices, color output devices, and they try to use them and they get different color on their screen, they get different color on their inkjet printer or someone views a different color when they send a PDF to another platform.

So I think it's important that you understand that Apple's very serious about color and we've delivered pretty much the only color managed operating system that's on the market today and how we've accomplished that feat is by taking our ColorSync technology which has been with us for a significant period of time which was essentially an opt-in technology, a technology that developers had.

We had to go to extra lengths to embrace and utilize and certainly that made sense in high end publishing but now what we want to do is make sure that the whole OS reacts the proper way to color management, image profiles, and whatnot. And so what we've been doing is essentially building ColorSync in at lower and lower levels, fundamental integration in the operating system and as, you know, for example one major announcement that was made, I think it was yesterday, was the fact that QuickTime image importers, you know, are going to respect color profiles which is very significant because that means that practically any application that uses QuickTime image importer for services is now going to do the right things with regards to profiles.

But in the fact that we continue to build ColorSync more and more in as sort of the core DNA of the operating system, we wanted to make sure that we continue to innovate and express ColorSync in interesting ways for both our users and our professional users in particular in addition to developers with lots of new ways to access the functionality. pleasure to invite David Hayward to the stage to take you through the session.

Hello everyone, welcome to the ColorSync session. We have a big room and lots of big topics to talk about today. On a wide range of subjects, let me kind of start out with a basic outline of what we'll be talking about today. First of all, for those of you that are new to ColorSync or new to color management, I'll start out with a general overview.

And then we'll start to talk about some of the foundations upon which ColorSync is built, such as ColorSync and its device integration layers, how it ties in with Quartz. After that, we'll take a trip through some of the high-level functionality that ColorSync provides through ColorSync utility and integration with other systems like OpenGL and display calibration. After that's over, I'll be talking about something new today, which is something called SIPs. We'll save that for last.

So first of all, an overview of ColorSync for those of you that are new to the subject. All of you are, I'm sure, aware that there's a wide variety of devices that we all work with now, from scanners to cameras to displays, big projectors, printers, both PostScript and Inkjet. And all of these devices that you've all seen before represent colors in different spaces and with widely different behaviors and different gamuts or range of colors that they can represent.

And this presents a fundamental problem that makes it very difficult for content to move between one device and another. And the solution to this problem is ColorSync. And ColorSync provides a complete color management system that's been designed to provide consistent color across this spectrum of devices. That said, in addition to doing device-level color correction, it can also be used to do abstract special effects, such as hue rotation and contrast enhancement. These kind of changes that may be very important. And it's important to you as a content creator, but may not be associated with any particular device. We'll come back to that throughout the presentation.

So this is an outline of how ColorSync fits into the overall system on Mac OS X. At the top, we have high-level applications, such as the ones that use Uwrite, and also applications such as ColorSync Utility and other tools that we provide. These are all built upon high-level application frameworks, such as Carbon and Cocoa, which all in turn use our variety of graphics technologies that we have on the system, such as image capture, quartz, quick time, and printing.

The key thing about all these graphics technologies is that they all now make use of ColorSync, and this provides a core service to the rest of the system for dealing with color consistently and correctly. ColorSync is based on three key foundations. One is profiles. Profiles are binary data files which hold the device characterization. It describes the way the device responds to color in a device-independent way.

The other key foundation that ColorSync is based upon is device integration, and this I'll talk about in more detail in a bit, but the basic idea is to be able to make it so that ColorSync and client applications can know what the current profile for all the devices that are connected to a computer are. The other third piece of foundation that ColorSync is dependent upon are CMMs, or Color Management Modules. And these are the computational engines which are used to actually perform color transformations between one source profile and another profile.

So that's the basic outline of how ColorSync fits into the system. Let me give a brief, simple example of how ColorSync is used in everyday practice. For example, we have an application that's calling ColorSync. It's either calling it directly or it's calling it indirectly through other graphics APIs. But the scenario is basically the same.

The idea is we want to be able to acquire images, for example, from a camera. And we want to make sure that when we get the image from the camera that we also have a profile that describes the way that camera responds to color. This profile can be embedded in that image, so now wherever that image travels, it'll always be possible for ColorSync to know the behavior of that device and how that image represents color and how the image is supposed to look.

So once we have an image with an embedded profile, a ColorSync application is going to then want to display that on a screen, for example. ColorSync can determine the profile for the screen, and now given these two profiles, the source profile for the camera and the destination profile for the display, ColorSync can concatenate these two data files and create what they call a color world. This color world can then be used to match all the RGB values from the original color space to the display color space in a manner that creates the best possible consistent color.

Similar process occurs when it comes time to print. In this case, ColorSync determines what the best profile is for the current printer and its current settings. And again, the source data is now matched from the source color space to the destination printer profile. This is a very simple example here. In reality, documents can be much more complicated, and the life of a document can be much more long and drawn out.

So, for example, this is a very conceivable operation, for example. An image can be acquired through the image capture architecture, and it can then be edited in a Carbon application. After that, it could be converted to a different file format using some QuickTime tool, and then maybe sent in an email to another user who opens it in preview and prints it.

As soon as printing occurs, there's a whole new set of operations that start to occur, such as the data being rasterized by Quartz, sent through the printer driver, and ultimately sent as bits to the inkjet printer. So this is a long chain of operations, and each one of these steps, color management may be involved, or should be involved if you want to get the best possible output.

Under Jaguar, however, there were a few places in this chain where there were potential weak links, places where applications had to go to a little extra effort in order to make sure that the correct color management occurred. For example, image capture architecture was hindered by the minor fact that some cameras didn't register profiles. This meant that when an image was first brought into the system, there was no profile to describe the image, which could cause problems later.

Similarly, when QuickTime APIs were invoked to modify an image, apps had to go to a little extra effort in order to explicitly check for embedded profiles. This created a persistent problem, which was that oftentimes the same document could be opened up in different applications, and depending on whether that application respected the profile or didn't, you could get different results.

Similarly, there was a dilemma that occurred when it came time to print, which was that not all print drivers register profiles. So one of our major objectives for Panther was to solve these problems and make it as easy as possible for applications to get the right output, which is, after all, what we all want. So we've made several changes in the system to solve these problems. One was, in image capture, we now associate a generic camera profile for all cameras if they don't register a profile otherwise.

Also, as we mentioned earlier, QuickTime now makes an effort to respect embedded profiles. This is a very important change to the system and means that documents will now look very consistent no matter how they're opened up. Lastly, it is now possible for CUPS PostScript and Raster drivers to register profiles. So this is also a great story in that it completes the picture at the output side, making sure that we have the correct profile at every step in the process.

So, as I mentioned before, one of the key foundations upon which ColorSync is based is device integration. Let me speak a little bit about that in detail. Again, as I showed in the previous diagram, we have ColorSync, which is based on one key thing, which is device integration, and this allows ColorSync to be able to know what the profiles are for devices.

The key feature of the device integration is for novice users in the sense that now, with proper device integration, when a device is connected, a profile will be automatically registered with the system on behalf of the user. This means that even users who do not even know about ColorSync will get good color output on their devices. The way this is accomplished is by automatic registration. Automatic registration involves registration of devices with their name and their ID, different modes of the devices based on ID and name, and a specification of a default or factory profile for each device.

Again, the objective of this is to make it so that novice users will automatically get good color results without having to do any special settings or options. However, we also want to make this a powerful feature that expert users can take advantage of as well. And this is done by supporting overrides of profiles with device integration. Overrides are something that calibration applications will use in order to change the factory profile with a calibrated profile.

It is also something that an administrator can do to override the default profile for all users of the machine. Or, of course, users as well can change the profiles to their liking. Lastly, there is an API for device integration, so your applications can become aware of profiles as they become attached to the machine through their devices.

Let me talk a bit more detail about the automatic registration. Again, this is the key functionality that makes it very easy for new users to get good color output. This is accomplished in three ways based on the three different device managers. First of all, the Windows server, whenever a display device is detected, will automatically query the display and ask the display for its EDID information. From that EDID information, it will create a profile and register that device.

For image capture, a similar process occurs whenever a camera is plugged in. If the driver supports profiles, it will tell image capture about that profile and that will be registered. If it doesn't, then a generic camera profile will be registered instead. Lastly, for the print manager, profiles are registered for devices whenever a print queue is created.

This happens in two ways, depending on what type of printer driver you have. For Tioga printer drivers, the print driver returns to ColorSync a dictionary of device names and device modes and the profiles for each mode. For CUPS drivers, this information is specified in a PostScript printer description file, which I'll talk about in a little bit more detail now.

So now with PPDs, there's a new entry that we're proposing. This is very important for CUPS drivers, both for PostScript and for raster drivers. Because now it is possible in the PPD for the file to specify what the modes of a device are and what the profiles are for each mode.

The format for this is the new keyword CUPS ICC profile, followed by a mode specifier and a profile specifier. The mode specifier is a concatenation of three fields, the color model, the media type, and the resolution. Any of these fields can be emitted, and it means that that mode will apply to any model media or resolution.

The profile specifier is very simple as well. All it is is a standard path that's relative to the user share CUPS profiles directory. We recommend that if you are going to be installing profiles in this directory, that you should create a subdirectory for your own driver so that you do not conflict with other drivers' profiles. Let me show a simple example of this in practice.

Here we have a PostScript printer PPD file that is registering two modes, one for 600x600 DPI and one for 1200x1200 DPI. and then the profile for that. So it's very simple. So the best way to show all this is to show it in action. So I'd like to bring up to the stage Luke Wallis, who will be demonstrating the device integration and speaking more on other subjects.

Thank you, David. Can I get the machine number one on the screen, please? All right. So the automatic registration of the device is really a great story that we are promoting on Mac OS X. But what I would like to start with is to show you how a user can get access to the ColorSync device integration database, and how he or she can decide what kind of profiles are going to be used with the devices known to the system.

So all this information is available in ColorSync Utility under the Devices tab. As you see, there are different types of devices listed here: scanners, cameras, displays, printers, and proofers. And if, for example, I open the cameras tab, you can see that the Canon Powershot S100, my favorite camera, is known to this system.

The information that I'm looking here for is the profile. This camera, or its device manager, in this case image capture, registered for me a default mode and a factory profile. And in the same time, me as a user, I have an opportunity here, an option given by ColorSync utility, to override this factory profile.

And I could do that if I desired so, by assigning any of the profiles that I can choose. But in this particular case of the camera, I was quite pleased with the results, so I didn't need to do that. The next on the list are displays. Same information is available here.

I have the same option to override the factory profile, register automatically. And as a curiosity, we actually had to override it because we wanted to have colors look right on the display. The video is just split through the splitter and the same image is displayed on the screen. So in order to get the colors better, as you see, we overrode the original automatically registered profile with the profile that we created just a few moments before the session started.

And the next group of devices I would like to talk about are printers. As you heard from David, there are different types of printers supported in Mac OS X. There are Tioga raster printers, which typically comes with OEM custom drivers. There are PostScript printers, and last but not least, the CAPS raster printers. So I selected one representative for each of those.

The first on the list is Canon S450, which is controlled by the Tioga driver. And this driver registered one mode and one factory profile. When I was browsing through the contents of the driver package, I discovered that there is a slightly newer version of the profile for this printer, so I used my option here, and I overwrote the original one with slightly newer profile.

The next on the list is probably very well known for you, Apple LaserWriter Pro 630. This is a very old printer manufactured at some point of time by Apple, but the reason I chose this particular printer was that I was able to find a PPD which would declare a profile for this printer the way David described it a moment ago. As you see, the name of this profile is LaserWriter Pro 630 Profile and is located in user share caps profiles LaserWriter, but looks like we didn't do here what David was suggesting. We did not create our subfolder for those profiles.

The next on the list is Stylus C80, which is controlled by the CAPS GIMP print driver. And the reason why I chose this particular printer is because I wanted to show you what is going to happen if there are no profiles in the PPD. In this case, the printing system will find out all the color models supported by this printer and will by default register these as the mode of operations with ColorSync.

So, even though there are no factory profiles available, me as a user, I as a user have an option to assign my own profile to this device for a specific mode. And as a matter of fact, I had built two profiles for this printer, CMYK and RGB. And I used CMYK. color sync utility to assign these profiles.

In the case when there is no profile available for a given mode of operation, the printing system will provide on the fly a default profile which will be used in the case when we need to do color conversion to this particular process color model. So, in conclusion of this little demonstration, I would like to say that all devices, color devices, known to this system will be represented by a set of ICC profiles corresponding to their modes of operation.

And the most important use of these profiles is obviously to do the color matching. But in the same time, these profiles are available to other system components and to applications and can be used in a variety, for a variety of reasons. For example, a very color-savvy application can figure out the device gamut or find other properties of this device. Or the profile can be used for device simulation, soft-proofing, and things like that. So now let's switch to slides so I can get the projector up.

Let's start with taking a look at the very typical scenario of an application, which goal is to acquire the data from the color device input and reproduce it on a variety of different color output devices like displays, printers, or export this data in the PDF format. There are two main points that I would like to make using this slide.

First of all, as you can see, there is one common component for all the operations that I described, and this component is ColorSync. Another point is that, as you see, the application doesn't have to necessarily go all the way to ColorSync, but it can use other system components which handle things like color data acquisition or color data creation because ColorSync is integrated into those components.

Let's take a look at the color data acquisition. The component which is the closest to the input device, in this case the camera, the image capture device module, is responsible for transferring the data from the device into the system. And if the camera happens to attach a profile to each individual image, then this module will take care of passing that profile through all layers of image capture to the application. But if there is no profile attached to the image, image capture will consult ColorSync device integration database and it will retrieve appropriate profile for this device.

When we take a look at the process of color data creation, we can see that there are two components which are always present here. Besides ColorSync, there is Quartz, which is the Mac OS X graphics system based on the PDF imaging model. In this particular scenario, ColorSync will be used into full extent of its functionality. We'll provide the profiles for the destination devices, but in the same time, we'll be used for converting the data using profiles for the devices' source color spaces and using the registered CMMs.

So this slide leads me to the topic I would like to focus on today, which is the integration of ColorSync and Quartz. Our high-level objective here is to integrate graphics and color management by satisfying several basic requirements. First of all, we would like to have a centralized color matching for consistent results. Another very important requirement is the ability to composite different color spaces and opacity.

To satisfy this requirement, ColorSync will be used to convert the data from many different source color spaces into quartz compositing space. This also has to be a scalable solution in the sense of working with a variety of different applications. On one end, we may have those old legacy applications which don't know anything about color management or they don't want to participate in color management. So for these, Quartz needs to provide some default settings and make sure that these applications can work seamlessly with the rest of the system, which is very color management-centric.

The most desirable model for the application is the one in which application uses calibrated color. What I mean is everything is properly tagged and so the system can easily Collect this data from the application and do the right thing when the data is to send to different kind of output devices. In this realm of calibrated color, we may have the very high-end applications which may desire to do the color management completely on their own. So Quartz also has to work with applications like that. Other important requirements are color accuracy, performance, and PDF compatibility.

For those of you who may be new to this topic like me, very quickly go through the few of basic ideas pertaining to color in PDF, compare them to those in ICC and ColorSync, and then see how we implemented that in Quartz. As you may know, the color spaces in PDF are defined by the set of known color spaces, which can be divided into three different groups. There are legacy device color spaces, calibrated color spaces, and finally ICC-based color spaces.

As you may know, this list also reflects, in some sense, the history of color management, where initially only device color spaces were known, but as we know today, they were really very bad for any kind of color management because the color appearance is device-dependent. To address this problem, calibrated color was invented along with the idea of color matching through device-independent color spaces.

And over the years, the concept of calibrated color evolved into ICC profiles, which now are the de facto standard among color professionals and can be embedded in almost all known data formats supporting color. Another concept important from the color management point of view in PDF are color conversions. Color conversions can be described as a function of source, destination, and rendering intent.

The similar concepts exist in ColorSync and ICC, but the only form of the color space that we use there is the ICC profile. And as I mentioned a moment ago, today this is the most general form of the color space description. The color conversions in ICC and ColorSync are somewhat similar to those in PDF, with the option for inserting intermediate profiles between the source and destination.

In Quartz, the color space, in essence, is represented by one or more ICC profiles. This way, we can preserve the original PDF concept of matching a single source to a single destination, but in the same time, we can build those multi-stage and complex color transform which are suitable for more advanced color management like soft proofing, special effects, color device simulation, et cetera, et cetera. And if the need arises to embed such a color space in the document, the sequence of profiles can be concatenated by ColorSync into a single profile and embedded in the document.

Another important rule that Quartz, in some sense, inherited from PDF is the color space equivalence. This rule says that the color conversions are necessary only if the source color space is different from the destination. And Quartz is using this very simple rule to organize properly the flow of the color data through multiple stages of rendering.

So in a summary, all color spaces inside Quartz will end up as ICC profiles. The easiest way to operate, as you see, is by using ICC-based color spaces, because we are just simply extracting the profile from the color space definition. In the case of calibrated color spaces, those can be very easily repacked using their calibration record in the form of a profile. And in the same time, we still have to support those legacy device color spaces, and in order to work with these, Quartz is going to use some predefined default profiles.

There is a wide variety of ICC-based color spaces provided by Quartz, but I would like to focus on those which allow you to access the ColorSync device integration database. An example are the color spaces which allow for drawing directly to the screen. Examples of these color spaces, more specifically, are Display RGB color space, which is in essence a wrapper around the primary display profile.

Another color space like this is Display Gray, which as you can see is composed of two profiles, device link converting gray to RGB and then attached to the primary display profile. And for more advanced use, there are Display Color Spaces with ID, which are wrappers for Display by AV ID profiles.

Quartz also, in Panther, helps to solve the problem of drawing to multiple screens. There are two basic choices that applications can make. One, as I call it, a simple model in which color is matched only to the main display, and the application doesn't take any or makes any updates on the screen on the profile change.

On the other end, the application can use what I call a complete model in which the color will be matched to individual displays. The application can register for notifications on the screen or profile change and make the proper updates when necessary. And obviously, there are some possibilities for combining these two profiles and come up with the application-specific solution to this problem.

A very important aspect of color management in Mac OS X is color management in printing. Many of you may already know that the printing in Mac OS X consists of two main components, the front-end and the back-end. The main role of the front-end is to choose the printer and collect the print options, for example, through the interface.

And in the same time, to spool the print job into PDF. The backend job is to convert the spooled PDF into appropriate format For the printer that we are going to print our job on. If we take a closer look at what is happening at the printing front end, we may notice that all color data in this pool PDF is tagged with profiles. By definition, we are not doing any printer-specific color conversions at the front end, but another important step is that we are consulting the ColorSync device integration database and extracting the profile matching the current printing condition.

What is happening at the backend depends on the type of the printer. For the raster printers, what we have to do is to convert the spooled PDF into printer profile from the color management's perspective. And for that, we extract the printer profile from the print job. And if the profile is not there, printing system will provide a default profile so this matching can occur.

For PostScript, we have two options. The first is traditional color matching in the printer. For this case, all the profiles from the spoof PDF are converted to PostScript CSAs. But in Panther, we added a new option for PostScript printers. Now we can do color matching on the computer using ColorSync.

In this case, we need to retrieve, similarly as in the case of raster printers, the profiles for the current print job from the print job. And if there are no profiles available, but we still want to do the computer color matching by ColorSync, we'll be using some default profiles.

In this light, a new addition of drawing directly in printer color space, I think, is also very important that comes with Panther. This color space is based on the printer instance and current print settings. This way, when the user clicks on the print button in the print dialog, an application has a chance to find out what are exact printing conditions in terms of the color space and make the proper adjustments if necessary. Thank you.

Another addition is Printer Calibration API. This API allows a calibrator to submit a calibration target in the form of a PDF file through the calibration path to a specified printer. It requires specific calibration target information through which the calibrator can instruct the system which color conversions have to happen and which color conversion must not happen.

A very important subject that I would like to mention here is importing and tag data to Mac OS X platform. As you know, for many years, we've been evangelizing usage of the ColorSync default profiles for documents, and Quartz is exporting these profiles in the form of user default color spaces.

If the application makes this first step of assigning the user profile, the whole color story on Mac OS X looks much better because very often it's impossible from the depth of the operating system to find out where this device data is coming from. And assigning those profiles in the depths of courts are sometimes difficult.

The next very powerful addition to Panther are quartz filters. In a nutshell, I would define the Quartz filter as a new optional component in the Quartz imaging and color matching pipeline, which allows to associate a sequence of imaging or color correction operation with a single drawing. The Quartz filter can act on all drawings operations or only on a specified set, can be configured to perform very specialized imaging and color operations, and finally can be defined and saved in XML so the applications and users can easily exchange those.

When we look at the Quartz architecture, where the Quartz filter fit, we see that they are located right in the middle of this structure. And this is the main reason why, in Panther, we will make the Quartz filters available to the end user only through the use of system-built utilities and applications. But we will be working on the proper API to provide access for applications to the filters. So this access is safe for both the system and the application.

What I'd like to do now is to give you a quick demo of how the filters can be used on Mac OS X, how those quartz filters can be used in Panther. Let's start with a very simple example. What I like to do is to print the image which I acquired with my camera. And when I go to the print dialog, if the system, yes, and As you see, a new thing added to printing is the automatic soft proofing.

My chosen profile was a monochrome printer, and what I do is I soft-proof it in the print preview, which is in addition to previous print previews, which mostly were concerned with the page layout. I can switch between the unmodified image and the soft-proof image. So this is the first example of using Quartz Filter. The soft-proofing is implemented using soft-proofing.

Now, let's take a look at this image. As you can tell, it's very, very dark. So I wonder if there is something that I could do about that. If you go and you open the print dialog one more time, you will notice that on Panther, we added a new PDE for ColorSync. And this PDE allows me to, first of all, on the PostScript printer, to choose which option of color matching I'm going to exercise. I can perform color matching on the computer using the printer profile, or I can fall back on the traditional matching in printing path.

In addition to that, I can apply quartz filters right before the job is going to be spooled into PDF. And not quite by coincidence, I have a filter which I called lighter color here, which I'm going to apply to this image before it's being spooled to PDF. And if I do that, and I preview... My image now, I can see that it's much more readable and I would print rather this image than the previous one.

Let's make one more trip to the print dialog and look at the last option in ColorSync PDE. As you saw at the bottom of the Quartz filter menu, there is an option for adding filters to printing. If I do that, the document is pulled into PDF and sent with the OpenApple event to ColorSync Utility, which opens it along with the filter inspector.

As you see, I have several filters existing on the system. And if I want to see what they do, I simply check the preview checkbox. And as you see, I can convert everything to blue tone. I can use the opposite of the filter I applied in the previous example, which I call darker color. I can convert everything to gray tone and so forth.

As you see, I can add and remove filters, but what I would like to concentrate on is the usage of filters for color conversions. There are many different options that I can set with defaults, but I don't think we have time to go and examine all of these. So let's stick for now to using the filters just for color conversion.

The first thing which I can decide... Here is if I want to do all my color correction on all objects in the document the same way, or I want to do different color correction on different types of objects. The next thing is I can decide how to use the rendering intent. If I leave it in the automatic setting, the rendering intent from the original document will be used. If not, I can override it with my choice of the rendering intent.

Next, what I can do is to define the intermediate transform, which I want to be applied to my document or the object, depending on the setting. And in this pop-up, you will see all the profiles available on your system, which are appropriate to be used as an intermediate transform. And finally, I can convert the data to a specified target. And in this case, the list will be populated with all the profiles that are suitable for destination of the color matching.

So, as you saw, ColorSync Utility was able to open a PDF document, and indeed, it can open many different file formats, including PDF and PostScript. And what I would like to do now is to show you how I can use Quartz filters to color manage a PDF document. So, I selected this particular document, which has all typical components of a PDF. I have text, I have vector graphics, and I have images. In order to demonstrate that, let me create some PDF.

Oh, sorry. Let's run it. Filter. And where I will put all the settings for this particular document. So, first thing which I would like to do is perhaps to change the appearance of the graphics. What I will do, I will choose the blue tone abstract profile, which, if I previewed it, changed quite a bit of the appearance of the graphics.

This is the color component in this document. Now, I don't want to leave the images, which are really very vibrant in color. So, what I will do, I will choose a little bit different correction for the images. And in this case, I will use the sepia. As you see, my original document changed very dramatically from the original, but just by a few mouse clicks.

So, what I see now that I haven't noticed, before that I have a little text in the headline in the yellow color. And since I wanted to use as few colors as possible, I think I can take care of this text by applying some other transform to text.

And the rest of the text on this page is black and white. So, I will use the gray tone abstract profile. And as you see now, I have only a few colors on this page. And indeed, this is what I wanted to do to it, to this document. So, now I'm ready to apply this text. filter and save it.

When I take the last final look at my new document, I think that the image is perhaps a little bit too saturated. So let me try to change that a little bit, and I'll go and select the images one more time, and I'll use a custom transform. And if I lower the saturation, the result has changed even more. And this is the format that I like to save, and ColorSync utility allows me to save it in many different file formats.

I can save it in most of the known bitmap formats, but also I can export it, for example, to PostScript. So let me do that. And... And now I can save my document I started with by applying all the filters that I showed you, but I can also just save this document for some other situation when I want to start with the original. So I'll simply revert. And, whoops, didn't revert.

Not quite, because the top is still duotone. Sorry, I must have... Oh, no, I see what's happening. I was applying the filter all the time. Okay, so this document came to this original form, and now if I go and look for my new document in the PostScript format and I open it with ColorSync utility, you can compare the results of applying a filter and changing quite dramatically the appearance of it.

Looks like my demo didn't... I forgot about one step that I should have saved the last adjustment of the images, but you have an idea what can be done with the filters. And this concludes my talk on ColorSync and Quartz, so thank you very much for your attention, and it's all yours, David. Great, great.

Great job, Luke. So, as you know, Luke was showing ColorSync Utility and showing the new filters capability of ColorSync Utility. We have some other changes in there as well, so I'd like to use this opportunity to speak about them. First of all, ColorSync Utility is now the new home for the ColorSync preferences.

We've added the filter support, which Luke just demonstrated. We have some administration features, which allows an administrator user to specify the profiles that can be used by default by other users on the same machine. Also, we have profile first aid and some new 3D view options. Let me just take this opportunity to demonstrate these real quickly. So, if we can go over to demo machine number two, please. Okay.

So I'm just going to launch in the new ColorSync utility on Panther. Let me hide this. And as you can see now, the ColorSync preferences are now here. They used to be in the system preferences, and now they're here. So ColorSync utility, more than ever, is now the one-stop shopping for all ColorSync-related settings.

One thing to be aware of is, for example, a lot of applications like to be able to provide a button in their UI to send users to the ColorSync preferences. This was accomplished in the past via an API, CM Launch ColorSync Preferences. This API will still work on Panther. Instead of launching system preferences, it will now launch ColorSync utility.

One of the other features that we've always evangelized is ColorSync Profile First Aid. I always like to mention this because it's a great utility that developers should run on any profiles they ship with their applications or that their applications create to make sure that they are valid ICC profiles. Similarly, if you ever come across any bad profiles that are not correctly flagged by ColorSync Profile First Aid, feel free to send them to us and we'll add more tests in the future.

The last thing I wanted to show in ColorSync Utility is some new things we've added to the profile viewer. This is some fun stuff that we've added to make viewing of profiles more interesting. So as before, we were using OpenGL in order to take all the content of an ICC profile and show it in three dimensions. So we can look at it and spin it around, zoom in, zoom out.

What we've added now is a new contextual menu on this so that you can add more options. For example, instead of just showing it in LAB space, you can see it in LUV space, if that's your favorite space. Or you can see it in YXY space, which is kind of neat. Usually people see XY plots from above. It's always kind of neat to see it from the sides, too.

One of the other features we added was, let me go back to LAB space, is the ability, this has been often requested, the ability to compare the gamuts of two profiles. We've accomplished that in a very simple, elegant way. What we do now is we have a contextual menu that allows us to hold a profile for comparison. So let's say I want to take this generic RGB profile and compare it against the other profiles that are installed in the system. All I do is command-click, select hold for comparison, and you can see it kind of changes slightly.

What that is is an indication that now as I switch to other profiles, we can see how the generic RGB profile compares to it. So for example, I can go to the display profile and see the two of them next to each other. Let me zoom it in a bit. And you can see the overlap between the two color spaces.

So here you can see all of our WebSafe profiles as points and how they compare to the outline of the other profile. You see the sepia tone profile, which is kind of cool to look at in 3D. So that's one of the key features that we've added. So let me go back to my slides.

So it's interesting that the last thing I was showing was ColorSync using OpenGL to show profiles. Well, there's another way that you can integrate ColorSync and OpenGL together, and that is to be able to do real-time color correction and enhancement of video real-time. And this is something we showed for the first time last year at WWDC. I want to refresh what we spoke about then and also tell you about some of the new APIs we've added to ColorSync to make it easier for you to do this in your own applications.

So for a bit of review, the basic idea is to be able to provide real-time color correction of video, which has been something in the past that's only been able to be accomplished on very high-end hardware. And now we can do that today on desktop machines because we have very advanced hardware available on video cards.

Modern video cards, some of them have support for per-pixel 3D texture lookup. And these are available on NVIDIA GeForce TI cards and also on ATI Radeon 9000 series cards. And by loading into these tables color correction transformations, we can actually accomplish real-time color correction. The great thing about this is it actually is a great story because it shows the integration between all the graphics technologies available on Mac OS X.

Because what we're doing is we're combining the advantages and powers of ColorSync, OpenGL, Quartz, and QuickTime, all in one example. The basic premise is that we want to be able to play QuickTime content onto a Quartz OpenGL surface. And attached to that surface will be a 3D texture that's been built from a ColorSync ColorWorld reference.

In order to make this easier for your applications to achieve this, we've added some new API to ColorSync. The first is a new API called CM Make Profile. And this API is useful in several ways. First of all, you can use it to create abstract profiles, which can be used for doing hue rotation or contrast or other things like sepia tone. You can also be used to make standard RGB profiles, such as profiles for NTSC standards and other standard color spaces.

So it's a general-purpose function for creating profiles given a CFDictionary of attributes. It's a very simple function to use. I'll show it a little bit later in one example. The other function we provided is an API called CW Fill Lookup Table. And what this function does is takes a ColorSync color world reference and fills in a table that is suitable for being loaded up to a video card.

So let me give an example of using our CM Make Profile API. Again, as I mentioned before, the way the CM Make Profile API works is you pass in a profile to modify and a dictionary of attributes that will tell ColorSync how to modify and create that profile.

In this case, we want to create an abstract profile that will rotate all the colors in a color space by a specific hue angle. So this function here that I've outlined, you pass in a profile and you pass in a float, which is the angle of rotation. So what I want to do is build up a dictionary with key-value pairs. The first key-value pair is going to be the key proc, which is the callback proc. And then I need to give, as the value, the address of a function, which in this case is the function myLabToLab proc.

Well, CF doesn't have, Core Foundation does not have a way to pass an address as a CF type. So what we do instead is we take that address and coerce it to an SN64 and then create a CF integer number for that integer and put that in the dictionary. The reason why we use an N64 is so that way the same code will work unaltered under 64-bit addressing in the future.

Similarly, the other thing we need to add to the dictionary is a refcon, where we could provide a pointer to a structure of interesting parameters. In this case, the parameter is not very interesting. It's just the address of a float value for the angle to rotate. But the idea is the same. We take the address of the angle, we coerce it to a 64-bit integer, and add that to the dictionary with the key refcon.

Once we've created the dictionary, we call cmMakeProfile, and that does all the work. What that API then does is it unpacks the dictionary, gets the refcon and the callback proc out of it, and calls that proc repeatedly for all the possible values in order to build the abstract profile. This is a very, very easy way to create an abstract profile. Once they're done, the function does a little cleanup, but perhaps what would be slightly interesting to look at is what our lab-to-lab proc looks like.

This is a very simple callback proc. What it takes as parameters are pointers to L, A, and B values, and a refcon, of course. The function's responsibility is to take those values, look at the initial values, and alter them and return the new values, and that value will be used in the profile. This function is very simple. All it does is take the initial AB coordinates and rotates them by the angle provided.

The other code snippet I wanted to show was an example of using the new CWFillLookupTexture API. Again, this function I'm describing here is a function that will make a 3D texture given three profiles: a source profile, an abstract profile, for example, one that we created using the hue rotation code earlier, and a destination profile.

In order to do that, first of all, we need to create a color world. I haven't shown that here. There's other examples for how to create color worlds, but I've just, in place of that, put in a function to create a color world. Once you have a color world, we need to call the CW fill lookup texture, call twice. The first time we call it, all we need to do is determine the size of the data that it's going to require, given the number of grid points that we desire.

Once we get back the size, we allocate the memory of that size and then call ColorSync CW fill lookup texture to populate that table with the appropriate values. Then there's existing code snippets, which we will provide in order to show you how to apply that texture to an OpenGL surface, but it's fairly trivial.

So all that's good to see on the screen, but perhaps the best thing to do is to whet your appetite and show you a brief example of how this works in a real live demo. So if I go back to demo two, please. So what I have here is an example application called ColorWorld. Excuse the pun. And what I can do with this, in addition to opening images, is open up movies.

And then what I can do is I can bring up a little inspector window, which allows me to show what profiles I'm going to be applying to that window. I have four profiles to choose from. I can specify source, destination, abstract, and proofing profiles. Today I'm just going to show you a little bit about the source and destination. If I know that this profile would be more appropriate for an sRGB profile for this movie, I can just change the source profile, and we can already see the difference between the left half and the right half.

But this is not really all that interesting. Let's start playing the movie and start putting an abstract profile in between. And what you can see already is that we can start rotating the hue, and we're all doing this real time, or we can adjust the saturation down. So let's say we want to bring the saturation down or bring it up.

So as you know, this is the trailer for finding Nemo. And what I want to use is I want to use this application as an example for how to make it easier to find Nemo. So what we're going to do is I'm going to desaturate this image way down, but then what I'm going to do is I'm going to limit it to only desaturate the colors that aren't Nemo.

So let's see if I can get these colors right. Oh, I've got it backwards. So now you can see everything in the image is very desaturated, but Nemo still looks nice and bright. So now I can go and-- I could have been doing this live, I suppose, but it's hard when he's moving. So now I have an example of the application.

showing real-time color correction of video content, doing selective, very complex abstract profile generation, and it's all very responsive. I can change Nemo's hue as well. I can go back and just... Disney Pictures presents a Pixar animation. So that gives you an idea. So hopefully this inspires you guys to add 3D hardware texture support to support color management in your applications.

So back to slides, please. So one of the next things I'd like to talk about is display calibration. One of the features that ColorSync has provided in the past on Mac OS X is the ability for the users not only to have automatic profiles generated for their displays, but also for users to calibrate their own displays in an easy-to-use fashion. This was achieved by users going to the display preferences in the system preferences UI and clicking on the calibrate button. In the past, that calibrate button would simply launch the Apple calibrator.

Third-party calibrators were supported, obviously, but they were not integrated into the system in the same fashion. What I'd like to talk about today is adding support for third-party calibrators into this architecture. This is very, very simple to do. All you do is you build your Carbon or Cocoa calibrator application the same way you have before. You just need to make a few small changes. One is there is a key you can add to your info.png.

This is the key you can add to your info.png. This is the key you can add to your info.png. This key is the CS display calibrator key, and that tells ColorSync that your application is, in fact, a display calibrator. Second, there is a new optional property that's associated with the open application that your application will receive. This property will be sent to tell your application what display to be calibrated.

Third, you need to install your calibrator or a SIM link to your calibrator in a standard location so that we can find it. That location is library ColorSync calibrators. And again, just to get you started on this, we have an example calibrator that's installed in the system that's very easy to use as a starting point. Let me give a quick demo of this to show you what we're talking about. Back to demo two, please.

So first of all, let me go and show you on the system that if you go into Panther, Developer, Examples, ColorSync, we have a new project in here called Demo Calibrator. And we have all the sources in here, and it's a good example for how to do assistant-type UI in Cocoa. And it has all the basic stuff you need to do in order to support the property list entry and the InfoP list entry and the custom Apple event correctly.

We already have the calibrator already pre-built, and what I've done is I've, instead of getting things set up, is I've actually installed a SIM link to that calibrator in system library ColorSync calibrators. So this would be what your calibration app would want to do as well. What that now means is if we go to the system preference and click on the display's color settings, if we now click on the calibrate button, there's a new dialog that appears. That allows you... It allows the user to choose which of the installed calibrators to be used.

So just to complete the example, I can click on the Demo Calibrator, click Calibrate, and it'll launch it, and you can see what this Demo Calibrator's all about. It's actually a very simple calibrator. All it does is take the profile that was already for the display and ask the user to rename it and saves it as a new profile. So not much of a calibration, but it's a good starting point for your app. So let me go back and quit.

Since I'm here, I'd also like to take the opportunity to show some new features we have in our calibrator, because we've made some important enhancements there that I think you'd like to see. So if we go and calibrate this calibrator, it looks very similar at the start. You might be able to tell it's built in Cocoa now, but where the changes really show up is if we turn on expert mode.

Because now, instead of showing the three apples, the red, green, and blue apples side-by-side, we now have finer, more advanced controls. What we have is the ability to show a single patch and the ability to adjust the brightness and the tint of those separately, which allows for much better control. The main reason for this is it's very hard for users to adjust the blue gamma, because the blue is so much less visible to the human eye.

So this is a bit of audience precipitation time, so if you guys can tell me if that looks good. I think that looks pretty good. That looks pretty good to me so far. And then we can adjust the tint around to make sure it looks neutral. What do you guys think? Does that look good?

So that was the first change we made, but then in addition we now allow for multiple steps. Instead of just adjusting the mid-tones, we can now adjust the highlights, the shadows, and the dark shadows, so you can get a really good calibration on LCD displays, which have very complex gamma curves. So you can go through here and step through this calibration process. And actually, I should be calibrating the big screen, not the small screen. Anyhow, you got the idea. That one looks good.

One of the other new advanced features is we now also allow for the profile to be used by other users on the same machine. So as an admin user, you can say, allow other users to use this calibration. And then we can save it. All done. So that's the new calibrator architecture for third-party calibrators and a peek at our newest calibrator. So back to slides.

So, as I said, I was saving something called CIPS for last. And what does CIPS mean? Well, actually, the name's probably going to change. But for now, what CIPS stands for is Scriptable Image Processing System. And what I want to talk about today is why we're doing something called CIPS, and what its features are, how it's architected, and how you can use it.

So what we noticed is that we needed a common place to go to perform common operations on image files in a scriptable manner. This was evidenced by the fact that today we had kind of a mixed story. For example, we had ColorSync scripting, which could do a lot of great ColorSync operations on images, but it could not rotate or scale or convert images between file formats. We had image capture scripting, which could rotate and scale, but it couldn't do color matching or convert between formats.

And then we had the preview application, which could do everything. It could do rotation and conversion, but it wasn't scriptable. So all this was saying to us that we needed to have a single central place that would provide a tool for scripters or batch processing in order to do common operations on images. So what are the features that we're going after in the first release?

Well, one of the features is going to be a good name. That'll come later. The other features will be we want to be able to read and write between common image file formats, JPEG, variations of JPEG, TIFF, GIF, and PNG. We also wanted to support basic image operations, such as rotate and flip and crop.

And, of course, since this is a ColorSync discussion today, we want to support proper color management operations, embedding profiles, extracting profiles, and matching between color spaces. We want to be able to support between common metadata tags and support reading and writing of those. And also, we wanted to, as a general rule, we wanted to preserve the fidelity and content of the original document as much as possible.

Of course, this is just the beginning for this tool. There's lots of places where we can go with it in the future. In the subsequent releases, we're considering in the future adding support for more complex file formats like multi-layer or multi-page formats and other more advanced image operations such as blur or sharpen or enhance. Also, the list of metadata tags that people are using is an always increasing number, so we'd like to support more of those in the future as well.

Here's the basic architecture that we're working on. Currently, it's implemented as a simple compiled tool that's installed in Userbin. It's called Userbin Cepts for now. And this is a tool that links against Core Graphics, QuickTime, and ColorSync. It links against Core Graphics for high-quality rotation and scaling. It links against QuickTime for a wide variety of image file importing and exporting. And it links against ColorSync for the best quality color management.

It can operate on one file or multiple files at a time. It can be used to both query or modify images or profiles. Queries can either return properties as simple text or can also return it in XML format for special operations. The actions can be used to modify profiles or images in place or can also be used to modify them to an output directory.

So, next question is, well, how can you use this? Well, it's a simple command line tool, so there's lots of ways to use this. For example, you can just go into Terminal and use it. However, it's also going to be usable from AppleScript. We won't be showing that today, but there's going to be an AppleScript veneer on top of SIPs, which will create an AppleScript dictionary, which will be very easy to use and to expose all this functionality.

Also, it'll be available for other scripting languages, any scripting language that can support command line tools. And, of course, it's also possible for you to call this tool from your own app by using standard either CF or NS or AppKit or POSIX calls to launch executables. So, let me give you a demonstration of this.

Okay. So I'm going to start out in Terminal. And what I want to do first is just going to type sips-help, just to give an idea of what we have. Eventually we need to have a man page, but for now this is a good start. As you can see, you can call it to basically do get properties or set properties. And in addition, on images, there's several other actions that can be performed, such as embedding profiles, rotating, flipping, cropping, you name it.

So let's say, let's see, let's try to think of some things we want to do here. I'm currently in a directory that has a bunch of images in LS. Let's say I want to see all the information about this image, Big Ben. So I can do sips-get property all on Big Ben.

And it quickly returns all the information it was able to obtain. So the height and width of the image, the DPI of the image, the model of the camera that it was produced on. Here's another type of query I can do. Let's say I want to see which of all these images have profiles in them. So I can just do SIPs.

[Transcript missing]

And this will show me the list of all the images that are in this directory. Some of them have profiles, some of them don't. But it gives you a good idea of the kind of the way that you would use SIPs in actual usage. Well, let's go and look at this directory and I'll see if I can come up with another example of how to use this tool. So let me go to my photos directory and view it in icons.

And I've got a bunch of images here, and coincidentally, one of them is upside down. Gasp. So what I would like to do is use SIPs to fix that. So what I'm going to do is I'm going to do, let's see, which photo is it? It's Nevis' picture. So I'm going to do SIPs-Rotate180, and I'm going to pass in And I'm going to make a copy of it and I'll call it dash out to the-- oops.

And we're done. So now if I go back to this directory and the finder will update, and we have the new image which has been rotated. So those are just some very simple operations, and it's quite handy. However, there's some more advanced things you could do as well.

Let me go back and view this in column mode. As you see, we have a bunch of images in this directory. And what I'd like to do is to build a web page that contains thumbnails of all these images along with the information about these images. So what I've done is I've created a simple script, in this case, this example, using a Python.

You could have done this in any number of scripts, either shell scripting or eventually we'll be able to do this in Apple script as well. But all this is is a simple, you know, slightly more than one screen of text that will take a parameter from the input, assume it's a directory, and take all the images in that directory, create thumbnails.

Creating thumbnails is interesting because that involves several operations. Nailing the image down to a reasonable size, and in this case, converting them all to JPEGs and converting them all to standard color space, in this case, sRGB. Once it's done, created all the thumbnails, it will then query each image -- let me actually start this going -- and produce a web page from it. So I've called this script build info.jpg.

image info web page, and I'll pass in volumes, three, photos. So again, as I said before, it's going to build thumbnails for all these images. And actually, some of these images are pretty big, so it takes a bit. And then once it's done creating the thumbnails, it's going to take each of those images and query them and return information about them.

So hopefully you can read this well enough, but this is the web page that it created and opened, and you can see all the photos along with all the information about them, including what camera it was created with, what the embedded profile is, when the creation date is. So hopefully that'll inspire you to create all sorts of other tools based on this foundation technology.

So that's our discussion for the day. I think we have a really good story. I think now more than ever we have a story where we're continuing to add new high-level functionality to ColorSync, as well as increase the integration with the rest of the system so that you get correct behavior by default. So I think if you had any other words to wrap up, that would be great.

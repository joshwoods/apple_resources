WEBVTT

00:00:23.050 --> 00:00:24.200
Hi, everybody.

00:00:24.200 --> 00:00:27.540
My name is Xavier Legro,
and I'm the Mac OS X evangelist

00:00:27.600 --> 00:00:29.300
in developer relations.

00:00:29.350 --> 00:00:33.100
And I'd like to welcome
you to session 404,

00:00:33.150 --> 00:00:35.620
Unicode for Japanese, Chinese,
and Everything Else!.

00:00:35.830 --> 00:00:36.700
I had to look at the title.

00:00:36.700 --> 00:00:39.180
It's kind of long.

00:00:39.420 --> 00:00:42.370
Before we start with this session,
where we have great content,

00:00:42.460 --> 00:00:44.530
we're going to give you an update
on what we've been doing with

00:00:44.580 --> 00:00:47.460
regards to Unicode in Panther.

00:00:47.500 --> 00:00:49.660
I'd like to take just a moment,
because yesterday night--I don't

00:00:49.670 --> 00:00:54.410
know if you went--but we had the
Meet the Evangelist event downstairs.

00:00:54.570 --> 00:00:59.160
And I represent a lot of technologies
on Mac OS X to developers,

00:00:59.230 --> 00:01:01.820
but most of the time,
I get a lot of questions on, "Well,

00:01:01.820 --> 00:01:02.760
why should I use Unicode?

00:01:02.870 --> 00:01:06.550
Why, as a developer,
should I really focus on using Hatsui,

00:01:06.550 --> 00:01:09.400
or using the Cocoa layout engine,
or using MLT?

00:01:09.790 --> 00:01:12.490
Why do I need to use Unicode
in my application?" And that

00:01:12.490 --> 00:01:15.360
was very interesting,
because it seems still a lot

00:01:15.360 --> 00:01:18.260
of developers don't understand
all the benefits with Unicode.

00:01:18.260 --> 00:01:21.700
We've been talking about it
since the beginning of Mac OS X.

00:01:21.700 --> 00:01:24.040
We had sessions for the last three years.

00:01:24.090 --> 00:01:26.570
But let me give you just
a quick rundown on why,

00:01:26.650 --> 00:01:29.530
as a developer,
you should really focus and use Unicode

00:01:29.530 --> 00:01:31.800
as much as possible in your application.

00:01:31.930 --> 00:01:34.330
First,
if you're a CDK developer and you're

00:01:34.450 --> 00:01:38.200
developing an application for China,
Japan, or Korea,

00:01:38.250 --> 00:01:39.940
you just have to do it now.

00:01:40.010 --> 00:01:43.890
Apple has been investing a lot of money
and effort in our Japanese support,

00:01:43.890 --> 00:01:46.560
for instance,
and the only way you can take

00:01:46.560 --> 00:01:49.790
advantage of some of the features
we're going to be talking today,

00:01:49.880 --> 00:01:52.280
like, for instance,
accessing the 32,000 glyphs

00:01:52.280 --> 00:01:55.840
that we have in Hiragino,
is by using Unicode.

00:01:55.930 --> 00:01:57.490
But then, second,
it's important for you to

00:01:57.490 --> 00:01:59.280
understand that Unicode is where,
actually,

00:01:59.280 --> 00:02:01.480
Apple is putting all its efforts.

00:02:01.530 --> 00:02:02.950
We're not doing any more things.

00:02:02.990 --> 00:02:05.680
We're not supporting any new
languages in Word Script.

00:02:05.730 --> 00:02:07.620
And for you,
you have to see that as a way

00:02:07.670 --> 00:02:09.300
of evolving your application.

00:02:09.410 --> 00:02:11.950
So please take good note of all
the content of these sessions.

00:02:11.980 --> 00:02:15.780
We have brand-new features for our
customers in the CDK countries.

00:02:15.780 --> 00:02:20.590
And for that, I'd like to invite on
stage Deborah Goldsmith.

00:02:21.900 --> 00:02:24.480
who's the manager of a font
and is the UniCode liaison

00:02:24.530 --> 00:02:25.950
with the UniCode consortium.

00:02:25.980 --> 00:02:27.300
Deborah.

00:02:27.300 --> 00:02:29.410
DEBORAH GILLETT: Thank you, Xavier.

00:02:33.510 --> 00:02:34.500
Good afternoon, everyone.

00:02:34.500 --> 00:02:38.000
Today we're going to talk
about Unicode and Mac OS X.

00:02:38.100 --> 00:02:43.440
So here's a quick introduction to what
we're going to be discussing today.

00:02:43.440 --> 00:02:45.280
The market in Japan and
China has changed,

00:02:45.280 --> 00:02:48.110
and in order for your application
to be competitive there,

00:02:48.110 --> 00:02:49.910
you need to support Unicode.

00:02:50.300 --> 00:02:53.570
Luckily for all of you,
Mac OS X has great Unicode support,

00:02:53.570 --> 00:02:59.120
and we'll talk today about the tools
that are available for your application.

00:03:02.800 --> 00:03:07.350
Specifically,
we'll be discussing how governments

00:03:07.350 --> 00:03:11.440
and customers in Japan and
China are asking for new features

00:03:11.440 --> 00:03:14.120
and new characters in particular.

00:03:14.160 --> 00:03:19.000
We're going to discuss why only Unicode
can meet those new requirements.

00:03:19.000 --> 00:03:22.500
We'll talk about some great new
features in Panther that are

00:03:22.500 --> 00:03:26.380
only available through Unicode
and to Unicode applications.

00:03:26.400 --> 00:03:30.310
We'll talk a little bit about how Unicode
is different from WorldScript from

00:03:30.330 --> 00:03:34.040
what you may have been doing before and
what you need to do in your application

00:03:34.040 --> 00:03:36.650
in order to work with Unicode.

00:03:39.120 --> 00:03:41.780
So there are a lot of reasons
to move to Unicode for the

00:03:41.870 --> 00:03:46.760
Japanese and Chinese markets,
but here's the biggest problem by far,

00:03:46.960 --> 00:03:50.810
and that is that customers
are demanding more characters.

00:03:50.900 --> 00:03:52.530
Well, why is that?

00:03:52.620 --> 00:03:56.700
In order to give you -- if you're
not literate in Japanese or Chinese,

00:03:56.700 --> 00:04:02.670
in order to explain by analogy,
suppose that your name is Smith,

00:04:02.770 --> 00:04:05.720
but you spell it S-M-Y-T-H-E.

00:04:05.820 --> 00:04:09.590
Now, you may go to a website,
maybe it's Amazon.com,

00:04:09.590 --> 00:04:12.620
and you want to enter your
name to give an order,

00:04:12.620 --> 00:04:16.110
but when you do that,
the website comes back and says,

00:04:16.110 --> 00:04:20.120
"I'm sorry, in order to use this website,
you have to spell your

00:04:20.310 --> 00:04:24.220
name S-M-I-T-H." Well,
that's pretty bogus, you think.

00:04:24.220 --> 00:04:26.290
Why should I have to change
the way I spell my name in

00:04:26.290 --> 00:04:28.100
order to use this website?

00:04:28.380 --> 00:04:32.140
Well, that's exactly the situation
that many customers in Japan and

00:04:32.140 --> 00:04:34.380
China find themselves in.

00:04:34.490 --> 00:04:37.430
And the reason is that -- I think
it's interesting that the number

00:04:37.430 --> 00:04:41.840
-- the variety of characters that
people use to write their names

00:04:41.840 --> 00:04:45.480
is much larger than what has
traditionally been in the Japanese and

00:04:45.480 --> 00:04:48.760
Chinese character sets on Mac OS.

00:04:48.770 --> 00:04:51.720
So I have an example here.

00:04:51.720 --> 00:04:56.690
This is five different ways -- let me
see if I can use the laser pointer.

00:05:00.500 --> 00:05:04.050
That's kind of tiny,
but that third line there is

00:05:04.050 --> 00:05:07.780
five different ways of writing
the Japanese family name,

00:05:08.400 --> 00:05:09.700
Watanabe.

00:05:09.700 --> 00:05:12.410
And you may not even think that
some of them even look different,

00:05:12.410 --> 00:05:16.900
but all of them are different,
and there's actually a lot more ways

00:05:16.900 --> 00:05:19.520
than that for writing that family name.

00:05:19.520 --> 00:05:23.760
And so customers, not surprisingly,
want to be able to write their name the

00:05:23.820 --> 00:05:25.680
way they write it on everything else.

00:05:25.780 --> 00:05:29.660
They don't want to have to fall back to
some different standardized form of the

00:05:29.660 --> 00:05:32.040
character when they're using a computer.

00:05:32.220 --> 00:05:34.760
And this doesn't just
affect people's names.

00:05:34.900 --> 00:05:38.370
For example, using the Mac traditional
Chinese character set,

00:05:38.640 --> 00:05:41.930
it's not possible to write the
names of all the subway stops in

00:05:41.930 --> 00:05:45.270
Hong Kong or even the name of the
new international airport there.

00:05:45.270 --> 00:05:46.500
So it's a big problem.

00:05:46.500 --> 00:05:50.000
There's just not enough
characters for what customers

00:05:50.000 --> 00:05:52.270
want to do with computers today.

00:05:52.940 --> 00:05:55.340
Governments are also
specifying more characters.

00:05:55.620 --> 00:05:59.600
All of the major character set
standards in Japan and China have

00:05:59.600 --> 00:06:01.520
been revised over the last few years.

00:06:01.520 --> 00:06:05.720
There's new versions of all
of these character sets,

00:06:05.810 --> 00:06:09.460
and they all specify many more
characters than were in those

00:06:09.650 --> 00:06:12.040
character set standards before.

00:06:12.160 --> 00:06:14.310
Some of them are not just specifications.

00:06:14.370 --> 00:06:18.850
In particular,
the GB18030 character set in

00:06:18.940 --> 00:06:24.020
China and the HKSCS character set in
Hong Kong are government requirements.

00:06:24.220 --> 00:06:28.890
The government requires that software
support these character sets.

00:06:29.170 --> 00:06:32.010
So in order to meet all
these new requirements,

00:06:32.010 --> 00:06:34.430
we have to support more characters.

00:06:34.640 --> 00:06:37.340
The problem is that
the WorldScript system,

00:06:37.340 --> 00:06:40.300
which has been in Mac OS for a long,
long time,

00:06:40.350 --> 00:06:42.760
can't support any more characters.

00:06:42.940 --> 00:06:45.790
It has limitations,
and it just can't support the number

00:06:45.790 --> 00:06:47.530
of characters that are needed.

00:06:51.780 --> 00:06:54.490
So the answer is Unicode.

00:06:54.570 --> 00:06:57.840
Unicode is an industry standard.

00:06:58.020 --> 00:07:04.060
It's one encoding that handles all the
living languages in the world today and

00:07:04.060 --> 00:07:06.520
a large number of dead ones besides.

00:07:07.050 --> 00:07:09.120
Because it's a single encoding,
a character is a

00:07:09.190 --> 00:07:10.550
character is a character.

00:07:10.550 --> 00:07:16.250
The meaning of the character doesn't
change depending on what font you have.

00:07:16.370 --> 00:07:21.500
If you've used Japanese or Chinese or
Korean or what have you on Mac OS 9,

00:07:21.500 --> 00:07:25.120
you might have been in the situation
where you used the wrong font

00:07:25.120 --> 00:07:28.220
and you see something like that,
garbage characters.

00:07:28.220 --> 00:07:33.100
Would anybody like to
guess what that really is?

00:07:34.130 --> 00:07:37.990
It's Korean, but you wouldn't know that
unless you chose the right font.

00:07:38.290 --> 00:07:42.080
With Unicode, this doesn't happen,
because the meaning of a character

00:07:42.080 --> 00:07:44.400
doesn't change depending on the font.

00:07:44.530 --> 00:07:48.200
Unicode solves the character
problem because it's got plenty of

00:07:48.200 --> 00:07:51.960
room for all the characters that
customers and governments need.

00:07:52.070 --> 00:07:56.400
The latest version of Unicode, 4.0,
which was just released

00:07:56.480 --> 00:08:02.040
a couple of months ago,
has over 96,000 graphic characters.

00:08:02.160 --> 00:08:06.550
So that easily covers all the
needs that customers have,

00:08:06.550 --> 00:08:10.600
and it covers all of the new
Asian character set standards.

00:08:13.450 --> 00:08:18.980
Let's talk a little bit about what kind
of UniCode support we have in Mac OS X.

00:08:18.980 --> 00:08:23.010
Our main human interface
font is Lucida Grande,

00:08:23.010 --> 00:08:28.290
and in Panther, it now covers all of the
Roman characters in UniCode,

00:08:28.290 --> 00:08:30.660
and all of the Greek characters.

00:08:30.660 --> 00:08:34.090
And it covers several
other scripts besides.

00:08:36.050 --> 00:08:39.490
Our other core Roman fonts,
like Times and Helvetica,

00:08:39.490 --> 00:08:44.220
also have a large Roman repertoire,
although they don't cover the entire

00:08:44.290 --> 00:08:46.840
set of Roman characters in UniCode.

00:08:47.320 --> 00:08:52.060
But beyond this, we've got lots of great
font coverage in Mac OS X.

00:08:52.060 --> 00:08:54.440
Our Japanese support is outstanding.

00:08:54.460 --> 00:08:59.030
We have six beautiful
Japanese desktop publishing fonts.

00:08:59.060 --> 00:09:00.600
The family name is Hiragino.

00:09:00.600 --> 00:09:02.540
They're in Type 1 format.

00:09:02.540 --> 00:09:04.580
And as you can see,
they're really beautiful.

00:09:04.690 --> 00:09:06.400
There's an example up
there on the screen.

00:09:06.400 --> 00:09:10.910
And these fonts have greater
character coverage than any other

00:09:10.910 --> 00:09:14.550
Japanese fonts on the market today,
and they cover all of the major

00:09:14.600 --> 00:09:18.480
standards that you might be
interested in for the Japanese market.

00:09:18.480 --> 00:09:24.000
Not just 213, but also Adobe Japan 1.5,
characters that are used

00:09:24.000 --> 00:09:26.730
for photo typesetting,
and even the complete set of

00:09:26.730 --> 00:09:30.800
government shape recommendations
from the National Language Committee.

00:09:33.280 --> 00:09:36.360
But we don't support just Japanese.

00:09:36.470 --> 00:09:39.400
We also have great Chinese support.

00:09:39.640 --> 00:09:42.450
Mac OS X,
since Jaguar has had support for

00:09:42.580 --> 00:09:47.550
the Chinese GB18030 standard--these
are also beautiful fonts,

00:09:47.630 --> 00:09:49.500
there's another example up there.

00:09:49.500 --> 00:09:57.480
The GB18030 fonts have over 32,000 glyphs
and support all of the Chinese characters

00:09:57.500 --> 00:10:00.260
in plain zero of UniCode,
every single one,

00:10:00.260 --> 00:10:03.500
as well as minority languages like Yi.

00:10:03.520 --> 00:10:08.640
For Mac OS X Panther,
we're adding support for HKSCS from

00:10:08.640 --> 00:10:13.550
Hong Kong and Big Five E from
Taiwan for traditional Chinese,

00:10:13.710 --> 00:10:17.890
and these new fonts have
over 22,000 characters.

00:10:21.000 --> 00:10:23.500
But we support even more languages.

00:10:23.810 --> 00:10:27.510
Also new for Panther,
we've extended our Arabic coverage.

00:10:27.660 --> 00:10:30.680
It doesn't cover all of
the Arabic in Unicode,

00:10:30.750 --> 00:10:33.820
but we cover a bigger
chunk than we did before,

00:10:33.820 --> 00:10:35.690
and support more languages.

00:10:35.820 --> 00:10:40.600
We support some of the scripts you see
here that we also supported in Jaguar.

00:10:40.660 --> 00:10:45.240
We've also added support for
native North American languages,

00:10:45.270 --> 00:10:47.630
like Inuktitut and Cherokee.

00:10:47.800 --> 00:10:52.370
And we've also added a new font that
we built ourselves to cover a lot

00:10:52.370 --> 00:10:54.000
of the symbol blocks in Unicode.

00:10:54.020 --> 00:10:57.100
And I won't read all these off,
but you can see that we have a lot

00:10:57.100 --> 00:11:03.770
more symbol coverage that we had
in earlier releases of Mac OS X.

00:11:10.320 --> 00:11:11.260
Okay, this time it went.

00:11:11.260 --> 00:11:14.400
But we haven't just added fonts.

00:11:14.400 --> 00:11:17.510
We've also made other improvements
to our international support.

00:11:17.510 --> 00:11:22.860
As you may have heard at the State of the
Union session yesterday from Mac OS X,

00:11:22.860 --> 00:11:28.330
Unicode text drawing is much faster,
over twice as fast as it was in Jaguar.

00:11:29.060 --> 00:11:32.100
We've also improved our
bidirectional support.

00:11:32.250 --> 00:11:35.940
You no longer have to specify to
the system whether a paragraph is

00:11:35.940 --> 00:11:37.970
left to right or right to left.

00:11:38.110 --> 00:11:39.490
It will figure it out heuristically.

00:11:39.590 --> 00:11:42.770
So your users can just type,
and it will determine whether

00:11:42.770 --> 00:11:45.800
it's a right to left or a left
to right paragraph and put the

00:11:45.870 --> 00:11:47.920
punctuation in the right place.

00:11:47.920 --> 00:11:52.490
We've updated our bi-die algorithm
to the Unicode 4.0 standard,

00:11:52.620 --> 00:11:55.210
and we've also made several bug fixes.

00:11:55.220 --> 00:11:59.040
Now, I should mention that the seed
that you see here is a bug fix.

00:11:59.040 --> 00:12:01.400
The one that you folks have
received doesn't have all the

00:12:01.430 --> 00:12:05.050
latest stuff that we're working on,
so you may not see some of this until

00:12:05.050 --> 00:12:07.120
you get the GM release of Panther.

00:12:09.140 --> 00:12:13.810
We've also made some fixes to
our support for Indic languages.

00:12:13.960 --> 00:12:18.960
In 10.2.4, we introduced dictionary-based
Thai word break.

00:12:18.960 --> 00:12:21.760
But with Panther,
we're now adding the ability for

00:12:21.890 --> 00:12:25.850
users to specify their own dictionary
and supplement the built-in one,

00:12:25.950 --> 00:12:28.760
so users can now put their
own list of Thai words in,

00:12:28.790 --> 00:12:33.100
and that will affect word break in
every application in the system.

00:12:33.100 --> 00:12:38.000
And finally, Apple supports 16
languages for localization,

00:12:38.070 --> 00:12:41.230
and we have an expanded
that list in Panther.

00:12:41.810 --> 00:12:45.960
However, we've always had a longer
list of languages than the

00:12:45.960 --> 00:12:49.100
ones we support ourselves,
so that you, the developers,

00:12:49.240 --> 00:12:52.860
can localize your languages
into languages we don't support.

00:12:53.010 --> 00:12:56.230
Just as an example,
I noticed that somebody released

00:12:56.230 --> 00:12:58.770
a Serbian localization for Safari.

00:12:58.770 --> 00:13:03.050
We don't support Serbian ourselves,
but because of the extra

00:13:03.050 --> 00:13:07.680
languages that are available,
you can do that if you want to.

00:13:07.680 --> 00:13:11.170
And we've expanded that list for Panther.

00:13:15.040 --> 00:13:18.880
Well, Arabic and Hebrew and
Japanese and Chinese are fine,

00:13:18.880 --> 00:13:22.600
but you say, if I don't have Hanunu's
support in my application,

00:13:22.720 --> 00:13:24.020
my company is toast.

00:13:24.020 --> 00:13:25.700
What are you going to do?

00:13:25.700 --> 00:13:31.430
Well, it's not a problem because
Mac OS X allows you to add support

00:13:31.430 --> 00:13:33.760
for new languages yourself.

00:13:33.760 --> 00:13:34.920
There's two easy steps.

00:13:34.940 --> 00:13:38.700
All you need to do is add a font,
and we have a font developer

00:13:38.700 --> 00:13:42.450
website that you can go to to find
out how to build fonts and how to

00:13:42.450 --> 00:13:45.320
enable them to work with Mac OS X.

00:13:45.320 --> 00:13:50.190
And then you need a way for
users to input your new language,

00:13:50.190 --> 00:13:55.000
and you can do that either via
keyboard or via an input method.

00:13:55.110 --> 00:13:57.260
And we have a tech note
on how to do keyboards,

00:13:57.280 --> 00:14:00.970
and we have sample
code for input methods.

00:14:02.080 --> 00:14:07.500
So, rest assured you can add
Hanunu support yourself.

00:14:07.540 --> 00:14:11.790
Hanunu is a Philippine writing system,
by the way, in case you were wondering.

00:14:14.150 --> 00:14:16.860
We've made improvements at the API level.

00:14:16.950 --> 00:14:21.280
In Jaguar, we introduced the Variant
Glyph Access Protocol.

00:14:21.280 --> 00:14:26.260
And the reason that we have
that is that even though Unicode

00:14:26.260 --> 00:14:31.990
has over 96,000 characters,
there are some ways of writing

00:14:31.990 --> 00:14:36.700
Chinese ideographs where you have
different variants even though they're

00:14:36.700 --> 00:14:38.720
considered the same Unicode character.

00:14:38.740 --> 00:14:41.490
There are still slightly
different ways of writing it.

00:14:41.490 --> 00:14:45.300
And that's actually very similar
to what you see in Roman fonts.

00:14:45.430 --> 00:14:49.120
You can have Roman fonts
that have different ways of

00:14:49.120 --> 00:14:50.650
writing the same character.

00:14:50.770 --> 00:14:53.470
Some of the fonts that
we include in the system,

00:14:53.470 --> 00:14:58.020
like Zapfino or Apple Chancery,
have multiple versions of the same letter

00:14:58.020 --> 00:15:00.880
that are useful in different situations.

00:15:00.880 --> 00:15:05.620
So the Variant Glyph Access Protocol lets
you specify exactly which

00:15:05.620 --> 00:15:10.650
variant of a character you want,
or lets the user specify that.

00:15:10.650 --> 00:15:14.470
In Panther,
we're also introducing a new protocol

00:15:14.470 --> 00:15:23.620
that gives an input method access to the
entire contents of a user's document.

00:15:23.620 --> 00:15:26.350
And that lets the input
method do two things.

00:15:26.350 --> 00:15:29.580
It lets it give much better
accuracy for conversion,

00:15:29.580 --> 00:15:32.500
and it also supports some
new human interface features,

00:15:32.500 --> 00:15:36.200
and we'll actually see
that a little later on.

00:15:36.200 --> 00:15:43.320
And our Japanese input method, Kotori,
takes advantage of this.

00:15:43.470 --> 00:15:44.680
We've also made extensions
of the Japanese input method,

00:15:44.680 --> 00:15:48.050
Kotori, to allow access to a lot more of
the capabilities that fonts have

00:15:48.190 --> 00:15:51.090
that have been hidden up until now.

00:15:51.160 --> 00:15:53.110
So you can now get at those
through the font panel,

00:15:53.110 --> 00:15:56.120
and that information can be
passed to your application.

00:16:01.380 --> 00:16:03.500
We've also improved the input menu.

00:16:03.620 --> 00:16:06.140
For those of you who are
not familiar with it,

00:16:06.220 --> 00:16:09.450
the input menu is the little
menu that looks like a flag,

00:16:09.500 --> 00:16:13.350
or at least it did in Jaguar,
that you get when you have more than one

00:16:13.350 --> 00:16:17.650
keyboard layout enabled or if you have
input methods or so on and so forth.

00:16:18.140 --> 00:16:21.760
We've greatly streamlined it and
improved the human interface.

00:16:21.760 --> 00:16:24.440
There's no longer a pencil menu.

00:16:24.440 --> 00:16:27.060
The pencil menu is specific
to each input method,

00:16:27.160 --> 00:16:30.250
but we've taken the contents
of the pencil menu and merged

00:16:30.250 --> 00:16:33.370
it into the input menu,
so now there's just one menu.

00:16:33.380 --> 00:16:37.230
And input methods that have been
revised to take advantage of this

00:16:37.230 --> 00:16:41.140
new human interface can have a much
more streamlined UI and have their

00:16:41.310 --> 00:16:45.500
modes appear individually so that
instead of having to choose the input

00:16:45.500 --> 00:16:47.850
method and then choose the mode,
you can just go through the

00:16:47.850 --> 00:16:48.120
menu and see what's going on.

00:16:48.140 --> 00:16:49.290
It goes straight to the mode you want.

00:16:49.350 --> 00:16:52.020
Of course,
older input methods continue to

00:16:52.020 --> 00:16:54.520
work flawlessly and transparently.

00:16:54.520 --> 00:16:57.800
There's no need to revise an
input method unless you want to.

00:17:02.780 --> 00:17:05.520
We've also made improvements in
our input methods themselves.

00:17:05.770 --> 00:17:10.930
As I mentioned, Kotori has much better
accuracy and a better interface

00:17:11.170 --> 00:17:14.940
with lots of new features,
which we'll see in a moment.

00:17:14.940 --> 00:17:18.030
In 10.2.4,
we introduced a new traditional

00:17:18.030 --> 00:17:21.550
Chinese input method,
HANIN, which has much easier input

00:17:21.650 --> 00:17:23.800
for traditional Chinese.

00:17:23.800 --> 00:17:26.550
For Panther,
we've expanded our simplified

00:17:26.590 --> 00:17:31.450
Chinese input method to allow access
to all of the characters in GB18030.

00:17:31.460 --> 00:17:32.360
And that's a lot of them.

00:17:32.360 --> 00:17:37.890
As I mentioned, our GB18030 fonts have
over 32,000 glyphs.

00:17:38.000 --> 00:17:41.240
And finally,
we've added more plain keyboards

00:17:41.240 --> 00:17:43.400
for more language support.

00:17:46.100 --> 00:17:48.200
And now to show you some
of these new features,

00:17:48.200 --> 00:17:54.380
I'd like to bring up Yasuo Kida and
Michael Grady for a demonstration.

00:17:54.530 --> 00:17:56.110
Michael?

00:17:59.540 --> 00:18:03.100
If we can switch to demo machine three,
please.

00:18:03.100 --> 00:18:03.730
Hello, everybody.

00:18:03.730 --> 00:18:08.560
I'd like to give you a brief demo of
the UI improvements we've been making

00:18:08.620 --> 00:18:11.780
to the text input menu for Panther.

00:18:12.070 --> 00:18:13.820
This is not a Panther machine.

00:18:13.820 --> 00:18:14.750
This is Jaguar.

00:18:14.820 --> 00:18:18.800
I just wanted to go over some of
the problems we tried to solve

00:18:18.800 --> 00:18:22.360
with the input menu in Jaguar.

00:18:22.500 --> 00:18:24.870
You have the US flag.

00:18:24.870 --> 00:18:29.900
One problem we found from a
focused user group study was

00:18:29.960 --> 00:18:32.920
discoverability was a big problem.

00:18:32.920 --> 00:18:40.220
Non-Mac users had no idea that this menu
contained anything to do with input.

00:18:40.220 --> 00:18:45.580
And many of them could not figure out
how to switch from US or a Roman keyboard

00:18:45.580 --> 00:18:48.980
layout to the Japanese input.

00:18:48.980 --> 00:18:52.670
So it was clear in Panther that
we had to improve the icons

00:18:52.670 --> 00:18:55.300
we used throughout the system.

00:18:55.500 --> 00:19:07.600
[Transcript missing]

00:19:09.900 --> 00:19:24.130
The first problem is that the
presence of the menu itself in the

00:19:24.130 --> 00:19:27.500
menu bar can sometimes interfere
with the apps menu list and sometimes

00:19:27.500 --> 00:19:34.480
even clip portions of it off.

00:19:35.410 --> 00:19:35.560
So it's clear that we had to bring
down the amount of real estate

00:19:35.560 --> 00:19:35.560
that we use in the menu bar.

00:19:36.320 --> 00:19:38.390
So let's switch over
to machine number two,

00:19:38.490 --> 00:19:42.270
please, and show what things
look like on Panther.

00:19:46.120 --> 00:19:47.380
Here is an icon.

00:19:47.510 --> 00:19:49.700
You'll notice there's only one of them.

00:19:49.810 --> 00:19:51.620
And, uh, are we there yet?

00:19:51.810 --> 00:19:52.090
No.

00:19:52.150 --> 00:19:54.570
Machine number two, please.

00:19:56.270 --> 00:19:58.040
There we are.

00:19:58.120 --> 00:20:00.360
There's the icon I was speaking about.

00:20:00.460 --> 00:20:03.280
It's much more obvious,
intuitive to users that there

00:20:03.280 --> 00:20:08.150
might be access to additional input
modes or input sources in there.

00:20:08.240 --> 00:20:12.320
And it's in the right side of the menu,
so it will not follow along at

00:20:12.400 --> 00:20:16.350
the end of the ask menu list and
cause distraction to the user.

00:20:16.420 --> 00:20:18.540
Let's see how this works.

00:20:18.590 --> 00:20:23.940
How can we take what used to be
implemented as two menus into one?

00:20:23.940 --> 00:20:24.480
And here's the answer.

00:20:25.510 --> 00:20:30.500
You'll notice that we have a
number of input sources here.

00:20:30.550 --> 00:20:32.610
And you wonder, what are those?

00:20:32.690 --> 00:20:33.900
They're not keyboard layouts.

00:20:33.900 --> 00:20:35.120
They're not input methods.

00:20:35.270 --> 00:20:40.800
They are the input modes implemented by
a particular input method--in this case,

00:20:40.800 --> 00:20:43.890
Apple's Japanese input method, Kotoweri.

00:20:44.000 --> 00:20:45.400
They're all there.

00:20:45.400 --> 00:20:46.040
They all belong to the same input method.

00:20:46.130 --> 00:20:49.680
And what we referred to in
the past as a pencil menu,

00:20:49.730 --> 00:20:55.600
the second menu in the Jaguar menu bar
is flattened into this menu right here.

00:20:59.030 --> 00:21:02.580
Now,
it's interesting that these input modes

00:21:02.640 --> 00:21:08.320
have become first-class input sources,
the same level as what input methods

00:21:08.320 --> 00:21:09.980
used to be and keyboard layouts.

00:21:09.980 --> 00:21:16.170
They are the preferred input
source that the user should see.

00:21:18.780 --> 00:21:22.750
and in any system UI,
they will be shown side by side with

00:21:22.890 --> 00:21:24.940
those other input sources at that level.

00:21:24.980 --> 00:21:30.490
Another system provided UI is a new
palette reminiscent of the pallets,

00:21:30.530 --> 00:21:35.330
the input mode pallets provided by the
input methods themselves in the past.

00:21:37.040 --> 00:21:39.240
And lastly,
we can bring up the international

00:21:39.240 --> 00:21:42.820
prefs and have a look at
the improvements there.

00:21:43.510 --> 00:21:46.820
Before we get into that,
I'd like to note that for

00:21:46.820 --> 00:21:50.170
those applications that have
particularly large menu lists,

00:21:50.270 --> 00:21:53.080
or if you just don't like the
input menu around anymore,

00:21:53.080 --> 00:21:56.740
you can command drag
the menu out of the way.

00:21:56.790 --> 00:22:01.310
And that can simply be reinserted
by this checkbox in the press panel.

00:22:01.970 --> 00:22:04.790
You'll notice the hierarchical
nature of input methods,

00:22:04.790 --> 00:22:08.690
and how they advertise input modes,
letting the user choose subsets of

00:22:08.700 --> 00:22:11.110
input modes they would like in the menu.

00:22:12.990 --> 00:22:18.540
And you'll also notice the US layout,
by the way, still has the old flag icon,

00:22:18.540 --> 00:22:19.940
but this is being changed actively.

00:22:19.940 --> 00:22:22.830
We didn't have it ready for this demo.

00:22:22.890 --> 00:22:26.550
It can be inserted in
the menu and removed,

00:22:26.620 --> 00:22:28.820
which is not something
we could do in the past.

00:22:28.960 --> 00:22:32.140
In the past,
whether or not you were using input

00:22:32.140 --> 00:22:36.620
modes specific to a single input method,
the US layout or the Roman default

00:22:36.620 --> 00:22:40.480
layout always showed up in the menu,
and it can now be removed.

00:22:41.870 --> 00:22:48.480
The input method itself can be disabled,
but the modes that would be enabled if

00:22:48.570 --> 00:22:51.390
you were to reactivate it also show up.

00:22:55.320 --> 00:22:58.630
You might be wondering about the
existing input methods and what

00:22:58.740 --> 00:23:00.740
compatibility we have with those.

00:23:00.750 --> 00:23:03.620
You'll notice that they
are fully supported.

00:23:03.650 --> 00:23:05.980
It's completely transparent.

00:23:08.230 --> 00:23:09.900
Choose that input method.

00:23:09.910 --> 00:23:12.540
And you'll notice that the input
method-specific pencil menu

00:23:12.540 --> 00:23:14.140
shows up here automatically.

00:23:14.150 --> 00:23:17.920
The input method did not have to change,
but of course we want to encourage

00:23:17.920 --> 00:23:23.030
input method developers to adopt this
new input mode protocol to give the

00:23:23.030 --> 00:23:27.650
users the benefit of a single user
interface for choosing input modes.

00:23:27.710 --> 00:23:30.770
And that's what I have
for the text input menu.

00:23:30.770 --> 00:23:35.050
Now I'd like to bring up Yasuo Kida,
who will discuss improvements

00:23:35.050 --> 00:23:36.230
in our Japanese input method.

00:23:36.230 --> 00:23:36.230
Thank you.

00:23:46.670 --> 00:23:47.640
Hello, everybody.

00:23:47.700 --> 00:23:51.830
I'm very glad to be here with you
because I'm very excited about the great

00:23:51.830 --> 00:23:54.940
improvements we are making for Panther.

00:23:54.940 --> 00:24:05.410
One of the big changes is the text
input menu Michael just mentioned.

00:24:05.410 --> 00:24:05.410
And I'll tell you about--I'll
show you Kotori 4.

00:24:12.350 --> 00:24:16.380
There are three major
new features in Kotari.

00:24:16.440 --> 00:24:20.170
One of them is very high
conversion accuracy.

00:24:20.180 --> 00:24:28.640
We've been continuously improving the
conversion accuracy since Mac OS X 10.1,

00:24:28.640 --> 00:24:32.580
and we believe we achieved a
milestone with this release.

00:24:32.580 --> 00:24:39.620
Not only we improved the engine itself,
we applied a new technology

00:24:39.620 --> 00:24:47.670
called Latent Semantic Mapping,
or LSM, in order to resolve the class

00:24:47.730 --> 00:24:53.000
of ambiguity which no other
input method can right now,

00:24:53.290 --> 00:24:59.780
which is to find out a topic
of the document you have.

00:24:59.780 --> 00:24:59.780
Say, "I'm going to use this document to

00:25:01.170 --> 00:25:06.180
Consider a word "hot."
If you're talking about summer,

00:25:06.200 --> 00:25:08.990
the "hot" probably
means about temperature.

00:25:09.230 --> 00:25:12.490
But if you're talking about Thai food,
for example,

00:25:12.560 --> 00:25:14.700
it's probably about spicy hot.

00:25:14.700 --> 00:25:17.840
It's like that.

00:25:17.840 --> 00:25:21.000
I'll show you how it works.

00:25:23.540 --> 00:25:28.470
Say, the document in the left-hand
side says--talking about

00:25:28.530 --> 00:25:31.980
the Jazz Festival--it says,
"Monterey Jazz Festival is

00:25:31.980 --> 00:25:35.740
the oldest jazz festival in
the world," which is true.

00:25:35.860 --> 00:25:41.400
The document at the right-hand side says,
"Boston Marathon." Boston Marathon

00:25:41.590 --> 00:25:46.020
is one of the most oldest
marathons in the world.

00:25:46.700 --> 00:25:55.470
And in Japanese, both player and runner
are pronounced the same,

00:25:55.470 --> 00:25:56.580
"sousha."

00:25:56.830 --> 00:26:02.580
And when they entered in a
different sentence like this,

00:26:03.110 --> 00:26:07.730
The traditional input method
couldn't resolve those ambiguities.

00:26:07.850 --> 00:26:14.780
But in case of this new Kotori 4,
it can look at this context and find out

00:26:15.260 --> 00:26:18.930
the correct conversion for each cases.

00:26:22.600 --> 00:26:26.840
Socia, here, and Socia, here.

00:26:26.840 --> 00:26:33.020
And Covert, Covert.

00:26:33.030 --> 00:26:34.560
Please.

00:26:37.200 --> 00:26:41.340
Please look at this first character.

00:26:41.340 --> 00:26:45.380
This means "play," and
at the right-hand side,

00:26:45.380 --> 00:26:50.570
this "play" means "run." It converts
the word correctly depending

00:26:50.700 --> 00:26:53.000
on the context of the document.

00:26:54.760 --> 00:27:02.200
The other improvement we are making
for Kotori is UI to correct conversion

00:27:02.200 --> 00:27:06.480
errors and typical mistyping.

00:27:06.600 --> 00:27:14.410
The first one is reconversion,
which is "saihenkan" in Japanese.

00:27:14.700 --> 00:28:15.800
[Transcript missing]

00:28:25.900 --> 00:28:34.500
[Transcript missing]

00:28:34.850 --> 00:28:38.060
Click and double-type the Kanaki.

00:28:38.140 --> 00:28:40.140
Oops.

00:28:40.140 --> 00:28:41.020
Oh, yeah.

00:28:41.020 --> 00:28:43.880
It gets you the candidate window.

00:28:54.850 --> 00:28:59.400
Say you confirmed the
text before you meant to.

00:28:59.420 --> 00:29:05.290
By double-typing the Kanaki,
you can get back the conversion state.

00:29:06.400 --> 00:29:14.200
[Transcript missing]

00:29:14.510 --> 00:29:21.150
Say you start typing "konnichiwa"
and you suddenly notice that,

00:29:21.150 --> 00:29:23.200
oh, this is a wrong, incorrect mode.

00:29:23.220 --> 00:29:29.850
You type "kanaki" two times,
and you can continue typing.

00:29:33.380 --> 00:29:36.400
The third--thank you.

00:29:36.410 --> 00:29:43.420
The third feature is we put an
MSI/ME compatible mode for those people

00:29:43.420 --> 00:29:49.840
who switch from Windows and comfortable
with using MSI/ME compatible keystrokes,

00:29:49.900 --> 00:29:55.800
and also those who are using
two environments back and forth,

00:29:55.880 --> 00:30:01.840
and so that they want to the same
keystroke between Mac and Windows.

00:30:02.430 --> 00:30:08.630
And please note that many of
those features require your help.

00:30:09.800 --> 00:30:15.920
Many of those features uses--fully
utilizes the Document Access Protocol,

00:30:15.920 --> 00:30:17.140
the new API.

00:30:17.150 --> 00:30:21.700
So in order to provide a constant
user interface for your customers,

00:30:21.810 --> 00:30:25.440
you need to--you need
to adopt those APIs.

00:30:25.780 --> 00:30:29.110
Deborah will mention those in details.

00:30:29.190 --> 00:30:31.460
I'll--yeah.

00:30:31.460 --> 00:30:35.290
Return the talk back to Deborah.

00:30:35.290 --> 00:30:35.290
Thank you, Kida-san.

00:30:40.590 --> 00:30:43.900
Okay, so those are great new features,
and as Kidasan mentioned,

00:30:43.940 --> 00:30:49.900
we need your help in order to make
them available in all applications.

00:30:53.180 --> 00:30:56.810
There are even more improvements at
the API level that I'll go into now.

00:30:57.020 --> 00:31:00.820
One big one that people
have been asking us for,

00:31:01.480 --> 00:31:04.950
people who've converted their
Carbon applications to Unicode have

00:31:05.070 --> 00:31:09.040
found that there's a sticky point.

00:31:09.190 --> 00:31:15.040
There has been no support up till
now for formatting or parsing dates,

00:31:15.040 --> 00:31:17.040
times, and numbers in Unicode.

00:31:17.060 --> 00:31:20.160
If you wanted to do that in
a Carbon Unicode application,

00:31:20.310 --> 00:31:23.640
you had to use the old
Script Manager APIs and then

00:31:23.640 --> 00:31:25.670
convert the text to Unicode.

00:31:26.020 --> 00:31:28.000
Well, in Panther,
we're introducing a new set of

00:31:28.050 --> 00:31:32.120
APIs in Core Foundation that
lets you format and parse dates,

00:31:32.120 --> 00:31:37.400
times, and numbers, CFLocale,
CFDateFormatter, and CFNumberFormatter.

00:31:37.550 --> 00:31:42.180
So now you can have a
totally Unicode application.

00:31:42.700 --> 00:31:47.360
For both for formatting and
parsing and also for sorting,

00:31:47.400 --> 00:31:50.220
we're now supporting many
more locales for Unicode.

00:31:50.220 --> 00:31:54.650
And the reason we're able to do that
is that we're taking advantage of

00:31:54.650 --> 00:31:59.840
an open source library called ICU or
International Components for Unicode,

00:32:00.290 --> 00:32:02.200
which is now part of Panther.

00:32:02.200 --> 00:32:08.220
Now, we're not yet allowing applications
to access this library directly.

00:32:08.310 --> 00:32:12.760
The reason is we want to make sure
that we're capable of supporting binary

00:32:12.760 --> 00:32:17.220
compatibility from release to release,
but that is something we're looking at,

00:32:17.220 --> 00:32:20.210
so that may become available to your
applications in future releases.

00:32:20.220 --> 00:32:25.810
Another side benefit of using ICU is
that our collation is three times

00:32:25.870 --> 00:32:28.950
faster than it was in Mac OS X Jaguar.

00:32:28.950 --> 00:32:32.820
So sorting applications
will get much faster.

00:32:36.700 --> 00:33:37.400
[Transcript missing]

00:33:37.630 --> 00:33:41.300
Another thing that you have to watch out
for is when you save attributed text.

00:33:41.370 --> 00:33:48.000
A lot of the information that implements
the new features that we've been showing,

00:33:48.000 --> 00:33:52.790
things like variant glyphs or font
features and font capabilities,

00:33:52.790 --> 00:33:55.680
those are saved as attributes on text.

00:33:56.060 --> 00:33:59.680
So if you save attributed text yourself
and you enumerate what you think

00:33:59.680 --> 00:34:03.130
is the complete set of attributes,
you might lose this information

00:34:03.130 --> 00:34:04.920
when you save it to a document.

00:34:04.920 --> 00:34:08.140
So it's important when you
save attributed text to save

00:34:08.140 --> 00:34:11.920
all of the attributes so that
information that the user enters,

00:34:11.920 --> 00:34:15.840
like a particular variant glyph
that they use to write their name,

00:34:15.840 --> 00:34:19.600
doesn't get lost when they save
and then reopen the document.

00:34:23.530 --> 00:34:26.480
Things are pretty easy for
Carbon applications too,

00:34:26.530 --> 00:34:30.500
especially if they're using MLTE,
the Multilingual Text Engine,

00:34:30.500 --> 00:34:34.610
or the new HITextView,
which is based on MLTE.

00:34:34.630 --> 00:34:38.880
That makes things pretty easy because
all of this stuff is supported by MLTE,

00:34:38.880 --> 00:34:41.320
and you don't have to do very much.

00:34:41.320 --> 00:34:45.190
If you use CFString for
your UniCode text storage,

00:34:45.190 --> 00:34:48.480
support the font panel,
and allow access to

00:34:48.590 --> 00:34:51.850
advanced font features,
and you're set.

00:34:51.850 --> 00:34:53.250
It's pretty easy.

00:34:55.590 --> 00:35:00.650
A lot of you for historical or
performance or what have you reasons

00:35:00.650 --> 00:35:06.520
have your own custom text engine that's
necessary for your specific application.

00:35:06.590 --> 00:35:10.310
And in those cases,
things are a little bit harder but

00:35:10.310 --> 00:35:15.370
it's still possible to support all
these features and we'll go through how

00:35:15.370 --> 00:35:17.810
you can do that in your application.

00:35:17.930 --> 00:35:20.790
You still need to store your
text as Unicode because many

00:35:20.830 --> 00:35:25.960
of these new features are only
available to Unicode applications.

00:35:25.960 --> 00:35:29.000
You can use either CFString,
the core foundation class for

00:35:29.000 --> 00:35:33.880
Unicode text or you can just
store an array of 16-bit Unicars.

00:35:33.960 --> 00:35:35.320
Either way works.

00:35:35.320 --> 00:35:39.660
If you have Unicode text,
you need to draw your text using

00:35:39.700 --> 00:35:45.290
a Unicode text drawing API and
for Karbin that means Atsui.

00:35:45.520 --> 00:35:49.840
Fortunately, as I mentioned in Panther,
Atsui is over two times faster,

00:35:49.840 --> 00:35:53.250
so there's really no reason not
to use Atsui for UniCode text

00:35:53.300 --> 00:35:55.830
drawing in your application.

00:35:56.040 --> 00:35:58.770
For input of UniCode text,
you need to use the

00:35:58.820 --> 00:36:00.430
Text Services Manager.

00:36:00.650 --> 00:36:05.380
And if you were already supporting
Japanese or Chinese input methods,

00:36:05.440 --> 00:36:07.900
you're probably already using TSM.

00:36:07.900 --> 00:36:11.890
One thing that's new for
Panther is that new features,

00:36:11.890 --> 00:36:14.900
like the
Document Content Access Protocol,

00:36:14.900 --> 00:36:19.480
are only available via Carbon Events,
not via the Apple Events that

00:36:19.480 --> 00:36:20.890
we also supported in the past.

00:36:20.900 --> 00:36:25.780
So if your application is using
Apple Events to interact with TSM,

00:36:25.920 --> 00:36:28.770
you'll have to move to
Carbon Events in order to take

00:36:28.770 --> 00:36:30.900
advantage of the latest features.

00:36:30.900 --> 00:36:35.040
And once you support TSM,
there's basically three categories of

00:36:35.040 --> 00:36:37.900
interaction that you need to worry about.

00:36:37.900 --> 00:36:40.600
One is supporting the active area,
which has always been

00:36:40.600 --> 00:36:41.900
true for input methods.

00:36:41.900 --> 00:36:47.900
Another is the new
Document Content Access Protocol,

00:36:47.900 --> 00:36:50.830
and we'll talk in more detail
about that in a moment.

00:36:50.900 --> 00:36:54.780
And the final one is supporting
input and storage of variant glyphs,

00:36:54.860 --> 00:36:56.850
and we'll also talk about that.

00:36:56.900 --> 00:37:00.970
And finally, as for the other,
as for the easier approach

00:37:00.970 --> 00:37:05.080
to Carbon applications,
you want to support the Font Panel so

00:37:05.080 --> 00:37:10.900
that users have access to all the
capabilities that fonts have to offer.

00:37:14.000 --> 00:37:16.540
So before I go into a
little bit more detail,

00:37:16.540 --> 00:37:21.450
I want to give a quick review of
what it is about Unicode that makes

00:37:21.450 --> 00:37:24.950
it a little bit more challenging
to implement an application.

00:37:25.090 --> 00:37:27.950
It's quite different from
the WorldScript approach

00:37:28.020 --> 00:37:29.660
that you might be used to.

00:37:29.660 --> 00:37:35.310
The most important concept for Unicode is
what's called the character glyph model.

00:37:35.310 --> 00:37:39.930
And it makes a distinction
between characters and glyphs.

00:37:39.930 --> 00:37:44.300
You can think of characters as the
form of language that's spoken.

00:37:44.300 --> 00:37:46.330
It's the semantic content.

00:37:46.370 --> 00:37:49.580
It's the way you would
speak the language.

00:37:49.750 --> 00:37:52.280
Glyphs, on the other hand,
are the shapes that show up

00:37:52.290 --> 00:37:55.970
on the printed page or that
you see on a display monitor.

00:37:56.050 --> 00:37:59.440
And you can think of them as the
written form of the language.

00:37:59.650 --> 00:38:02.670
Now, usually there's a very direct
correspondence between the

00:38:02.670 --> 00:38:06.060
spoken form and the written form,
but that's not always the case.

00:38:06.170 --> 00:38:09.650
It's certainly not the case
for complicated writing systems

00:38:09.650 --> 00:38:13.150
like Arabic or Indic languages,
but there are even cases in

00:38:13.150 --> 00:38:17.480
English and Japanese where there is
not a direct one-to-one relationship

00:38:17.600 --> 00:38:19.700
between characters and glyphs.

00:38:20.060 --> 00:38:23.240
And it's the job of a Unicode
text rendering engine like

00:38:23.240 --> 00:38:28.380
ATSUI or CocoText to map
between characters and glyphs.

00:38:28.380 --> 00:38:32.560
And here are a few examples that show
why that's a challenging problem.

00:38:32.560 --> 00:38:38.180
The first line is Hindi,
and in Hindi between the characters

00:38:38.180 --> 00:38:41.540
and the glyphs things move around
and in fact some of the things that

00:38:41.540 --> 00:38:45.490
are independent characters when
they're rendered as glyphs wind

00:38:45.490 --> 00:38:48.100
up as decorations on other glyphs.

00:38:48.100 --> 00:38:53.520
So there's both rearrangement and
formation of clusters and ligatures.

00:38:53.520 --> 00:38:57.530
The second line is Arabic,
and as we all know Arabic is a right

00:38:57.530 --> 00:39:03.110
to left language and so the characters
and the glyphs are in opposite orders.

00:39:03.110 --> 00:39:06.240
But beyond that,
Arabic is also a cursive writing

00:39:06.240 --> 00:39:11.900
system and so the glyphs flow
together to form ligatures.

00:39:11.900 --> 00:39:15.940
And you can't really map directly
between characters and glyphs.

00:39:16.080 --> 00:39:18.590
There's ordering and ligature
issues that you have to deal with.

00:39:20.150 --> 00:39:23.600
But even for Roman text,
here's an example where we have the

00:39:23.600 --> 00:39:30.400
word "resume," and the "e" with an acute
accent is stored in character space

00:39:30.760 --> 00:39:33.280
as an "e" with a combining acute accent.

00:39:33.370 --> 00:39:36.380
And when that's drawn,
that has to become an accented

00:39:36.380 --> 00:39:42.300
"e." So there's an example
of where in a Roman language,

00:39:42.300 --> 00:39:43.970
there isn't a straightforward mapping
between characters and glyphs.

00:39:44.490 --> 00:39:46.880
So what are some of the problems
that you can run into in an

00:39:46.880 --> 00:39:51.370
application if you don't keep the
character glyph model in mind?

00:39:53.110 --> 00:39:56.200
Well,
one thing that's particular to Unicode,

00:39:56.200 --> 00:39:58.600
we all think of Unicode
as a 16-bit character set.

00:39:58.600 --> 00:40:00.480
Whoops.

00:40:00.530 --> 00:40:01.180
Okay.

00:40:01.510 --> 00:40:04.490
I didn't press the bad button, so.

00:40:11.420 --> 00:40:13.010
There we go.

00:40:13.080 --> 00:40:13.670
OK.

00:40:13.910 --> 00:40:16.740
We think of Unicode as
a 16-bit character set.

00:40:16.760 --> 00:40:21.420
But I mentioned earlier that there's over
96,000 characters in the latest version.

00:40:21.420 --> 00:40:25.540
And a little arithmetic shows that
you can't fit that in 16 bits.

00:40:25.590 --> 00:40:30.050
So what we think of as the 16-bit
version of Unicode is called Plane Zero,

00:40:30.050 --> 00:40:32.180
or the basic multilingual plane.

00:40:32.200 --> 00:40:35.240
And that's where all the
commonly used characters go.

00:40:35.270 --> 00:40:39.780
But Unicode also supports a lot of
rare and less commonly used characters.

00:40:39.810 --> 00:40:44.600
And those are allocated
in planes 1 through 16.

00:40:44.630 --> 00:40:47.680
And in order to represent
those characters in your text,

00:40:47.700 --> 00:40:50.030
you need to use two 16-bit values.

00:40:50.180 --> 00:40:51.630
That's called a surrogate pair.

00:40:51.840 --> 00:40:52.800
And there's an example.

00:40:52.800 --> 00:40:54.800
That's from our Hidagino font.

00:40:54.800 --> 00:40:58.590
It looks like any other
ideographic character.

00:40:58.910 --> 00:41:02.740
But it's stored as two 16-bit values,
because it comes from

00:41:02.740 --> 00:41:04.450
plane two of Unicode.

00:41:05.140 --> 00:41:07.960
So that's one issue you
have to worry about.

00:41:08.150 --> 00:41:11.190
As we saw in the previous slide,
you can have composing sequences

00:41:11.550 --> 00:41:16.300
where multiple characters in the
UniCode sense form a single--what the

00:41:16.300 --> 00:41:18.470
user thinks of as a single character.

00:41:18.470 --> 00:41:22.440
So the base character E with a
combining acute accent is one example.

00:41:22.560 --> 00:41:25.770
There's lots of other
combining marks like that.

00:41:25.900 --> 00:41:27.510
There's clusters in Indic.

00:41:27.760 --> 00:41:30.980
There are ligatures in
Arabic and in English.

00:41:30.980 --> 00:41:35.510
For Korean, there are jamos that come
together to form hangul,

00:41:35.780 --> 00:41:37.200
and so forth and so on.

00:41:37.200 --> 00:41:41.030
So there's really not a
direct one-to-one relationship

00:41:41.100 --> 00:41:43.780
between characters and glyphs.

00:41:43.780 --> 00:41:47.760
In addition, UniCode also has multiple
ways of doing the same thing.

00:41:47.760 --> 00:41:51.640
So on the last slide,
we saw the E with combining acute accent,

00:41:51.920 --> 00:41:56.550
but UniCode also has a single character
that's an E with an acute accent.

00:41:56.780 --> 00:42:00.710
And that's mostly for historical
reasons and for compatibility with

00:42:00.710 --> 00:42:02.670
earlier character set standards.

00:42:02.800 --> 00:42:05.340
And there are a lot of cases like that.

00:42:05.340 --> 00:42:08.590
So there are often multiple--you
can think of them as spellings

00:42:08.590 --> 00:42:10.600
for the same string of text.

00:42:10.600 --> 00:42:13.390
It can be represented in
UniCode in multiple ways.

00:42:13.630 --> 00:42:14.680
So here's one example.

00:42:14.680 --> 00:42:19.970
On the left, I have Korean hangul,
and on the right, I have the three jamos

00:42:19.970 --> 00:42:23.210
that make up that hangul,
and they're both equally valid

00:42:23.210 --> 00:42:25.010
ways of representing the text.

00:42:25.050 --> 00:42:27.950
So of course,
that makes things like comparison and

00:42:28.570 --> 00:42:31.260
searching a little bit more challenging.

00:42:31.260 --> 00:42:32.350
And finally,
for more complicated writing systems,

00:42:32.400 --> 00:42:34.430
you can use the same string of text as
you would use in other writing systems.

00:42:34.430 --> 00:42:36.120
You have issues of directionality.

00:42:36.410 --> 00:42:38.660
Languages like Arabic and
Hebrew go right to left.

00:42:38.660 --> 00:42:42.760
You can have them in the same paragraph
with text that goes left to right.

00:42:42.760 --> 00:42:47.640
Languages--the whole Indic family
of languages has rearrangement where

00:42:47.640 --> 00:42:54.790
characters move around when you write
them compared to when you speak them.

00:42:55.210 --> 00:42:59.220
And so the glyphs and the characters
are really--you can't count on them

00:42:59.220 --> 00:43:00.900
being in the same order at all.

00:43:01.090 --> 00:43:05.060
And that doesn't just affect the
order of glyphs within a style run,

00:43:05.220 --> 00:43:08.280
it also affects the order of
style runs within a paragraph.

00:43:08.520 --> 00:43:12.980
So if you have a paragraph of
mixed English and Arabic or

00:43:13.270 --> 00:43:18.130
English and Hebrew text,
whole style runs can move around,

00:43:18.130 --> 00:43:20.250
and you really need the system's help
to figure out where everything belongs.

00:43:22.000 --> 00:43:24.270
So fortunately,
so that you can avoid these

00:43:24.270 --> 00:43:27.380
problems in your application,
we have lots of APIs in the

00:43:27.420 --> 00:43:32.000
system that you can use to make
sure you do the right thing.

00:43:32.000 --> 00:43:35.530
In terms of figuring out where
characters begin and end,

00:43:35.570 --> 00:43:38.640
there are lots of system
APIs for finding text boundaries.

00:43:38.640 --> 00:43:45.720
Not just characters, but also clusters,
words, lines, and paragraphs.

00:43:45.720 --> 00:43:50.120
There are APIs-- and I'm not
going to go into great detail on

00:43:50.330 --> 00:43:53.610
this-- all of the documentation
for this is available online.

00:43:53.670 --> 00:43:57.790
But there's APIs in Cocoa for finding
character and cluster boundaries,

00:43:57.790 --> 00:44:00.960
in Carbon for finding
boundaries of all sorts.

00:44:00.960 --> 00:44:03.420
And if the reason you're looking
for a character boundary is

00:44:03.530 --> 00:44:07.580
in order to truncate text,
you don't even have to do that yourself.

00:44:07.580 --> 00:44:11.440
You can actually ask ATSUI to
truncate your text for you.

00:44:11.440 --> 00:44:14.980
You just pass it an option,
tell it how wide you want the text to be,

00:44:15.030 --> 00:44:19.190
and it will find a linguistically
correct place to truncate the

00:44:19.190 --> 00:44:20.620
text and add a truncation.

00:44:20.620 --> 00:44:22.470
. character.

00:44:26.300 --> 00:44:29.960
Because of the problems with multiple
spellings that I talked about before,

00:44:29.960 --> 00:44:32.780
there are system APIs that
can help you with that,

00:44:32.900 --> 00:44:35.580
that will do comparison
or searching of text.

00:44:35.580 --> 00:44:39.380
As I mentioned,
due to directional issues,

00:44:39.380 --> 00:44:43.020
text can move around within a paragraph.

00:44:43.020 --> 00:44:46.890
And so when you're drawing,
you need to deal with an

00:44:46.890 --> 00:44:49.220
entire paragraph at a time.

00:44:49.220 --> 00:44:53.500
And there are APIs in Cocoa and
Carbon that will help you do that.

00:44:54.740 --> 00:44:57.350
For Cocoa,
you can use the text system directly or

00:44:57.460 --> 00:44:59.810
use attributed strings and typesetters.

00:44:59.820 --> 00:45:02.680
For Carbon, of course, there's Atsui.

00:45:02.680 --> 00:45:06.530
And as long as you let the system
know about an entire paragraph,

00:45:06.530 --> 00:45:09.480
it will figure out where
everything belongs,

00:45:09.480 --> 00:45:11.720
and then you can figure out
where the line breaks are and

00:45:11.920 --> 00:45:13.210
draw the lines individually.

00:45:14.780 --> 00:45:19.260
Of course, because there isn't one-to-one
mapping between characters and glyphs,

00:45:19.400 --> 00:45:23.120
that's also an issue for moving
the cursor with the arrow keys,

00:45:23.240 --> 00:45:26.330
or clicking with the mouse,
or highlighting text,

00:45:26.330 --> 00:45:29.290
and there are APIs that
can help you do that.

00:45:33.040 --> 00:45:36.370
One issue that every Unicode
application has to deal with,

00:45:36.370 --> 00:45:39.290
unless it's brand new,
is how to handle legacy

00:45:39.290 --> 00:45:41.400
data that's not in UniCode.

00:45:41.460 --> 00:45:43.680
Now,
we've had APIs in the system for a long,

00:45:43.680 --> 00:45:46.950
long time to convert between
UniCode and other character sets,

00:45:46.950 --> 00:45:48.670
so I'm not going to go into that.

00:45:48.710 --> 00:45:52.060
One issue, though, is to figure out what
character set should I use?

00:45:52.230 --> 00:45:54.820
What character set should
I assume the text is in?

00:45:54.820 --> 00:45:58.040
Well, if the character set is marked
in the document somehow,

00:45:58.040 --> 00:45:58.670
then you're set.

00:45:58.760 --> 00:46:00.070
You know what the character set is.

00:46:00.110 --> 00:46:02.650
But very often,
you're dealing with plain text or

00:46:02.690 --> 00:46:06.940
other text that doesn't have any
information on what the old character

00:46:06.980 --> 00:46:10.320
set was that it's encoded in.

00:46:10.320 --> 00:46:12.270
So then you have to guess,
and there are a couple of

00:46:12.320 --> 00:46:15.210
APIs that can help you do that.

00:46:15.310 --> 00:46:17.700
If you think it's going to
match the language that your

00:46:17.700 --> 00:46:20.150
application is running in,
then you can call

00:46:20.150 --> 00:46:22.090
getApplicationTextEncoding.

00:46:22.270 --> 00:46:26.850
That will return an encoding that
usually matches the language that's

00:46:26.950 --> 00:46:30.970
been selected--the localization that's
been selected for your application.

00:46:30.980 --> 00:46:32.190
Okay.

00:46:32.320 --> 00:46:36.560
It might be more appropriate to pick
an encoding that's associated with

00:46:36.650 --> 00:46:39.930
the user's most preferred language,
because maybe your application

00:46:39.930 --> 00:46:43.850
doesn't support that language,
but the user's data is quite likely to

00:46:43.850 --> 00:46:46.660
be an encoding that's associated with it.

00:46:46.810 --> 00:46:50.620
And CFStringGetSystem encoding
will return an encoding that

00:46:50.620 --> 00:46:52.860
usually matches that language.

00:46:52.920 --> 00:46:54.720
Now, why do I say usually?

00:46:55.010 --> 00:46:58.300
Well,
the reason is that there are languages

00:46:58.300 --> 00:47:02.520
that Mac OS X knows about that were
never supported in WorldScript,

00:47:02.640 --> 00:47:06.660
that were never supported on OS 9,
and they don't have legacy

00:47:06.660 --> 00:47:09.130
encodings associated with them.

00:47:09.250 --> 00:47:13.170
Some of them, like Vietnamese,
do have a WorldScript encoding,

00:47:13.350 --> 00:47:16.690
but that doesn't mean that you can
draw the data with QuickDraw text.

00:47:16.700 --> 00:47:21.840
It's just something that you can convert
using an encoding conversion API.

00:47:21.840 --> 00:47:25.720
Other languages, like Hawaiian,
have no non-Unicode encoding

00:47:25.720 --> 00:47:27.430
associated with them at all.

00:47:27.640 --> 00:47:30.040
So if your application
is running in Hawaiian,

00:47:30.040 --> 00:47:32.640
or the user's most preferred
language is Hawaiian,

00:47:32.700 --> 00:47:38.210
you're not going to get a sensible
answer from these two APIs.

00:47:39.610 --> 00:47:41.600
If you're writing an
internet application,

00:47:41.720 --> 00:47:44.480
then you shouldn't be using
Mac OS encodings at all.

00:47:44.530 --> 00:47:47.220
You should be using the standard
encodings that are defined

00:47:47.220 --> 00:47:48.800
by internet standards bodies.

00:47:48.910 --> 00:47:56.480
And you can go to IETF and
IANA websites to find out about those.

00:47:56.480 --> 00:48:01.320
And there are APIs that will help
you convert those names into a text

00:48:01.320 --> 00:48:01.320
encoding that you can use internally.

00:48:05.990 --> 00:48:12.440
I'll talk a little bit more about the new
APIs for formatting and parsing dates,

00:48:12.440 --> 00:48:13.380
times, and numbers.

00:48:13.480 --> 00:48:15.340
It's in core foundation.

00:48:15.340 --> 00:48:20.840
You can either get the current locale,
or you can get a locale from

00:48:20.840 --> 00:48:27.080
a standard ISO locale string,
which has a language code

00:48:27.080 --> 00:48:27.080
followed by a country code.

00:48:27.380 --> 00:48:30.670
You can also take information
from the WorldScript world,

00:48:30.670 --> 00:48:35.420
like language, region, or script,
and convert that to an ISO string,

00:48:35.420 --> 00:48:38.060
which you can then use to get a locale.

00:48:38.070 --> 00:48:40.630
The new classes in Core Foundation,
as I mentioned,

00:48:40.650 --> 00:48:42.700
support both formatting and parsing.

00:48:42.700 --> 00:48:46.350
There's support for currencies,
and you can go back and forth

00:48:46.520 --> 00:48:52.350
between internal representations,
including Core Foundation types,

00:48:52.350 --> 00:48:56.420
but also standard C types,
and a formatted CFString.

00:48:56.420 --> 00:49:01.760
And there's also lots of customization
options you can take advantage of.

00:49:01.760 --> 00:49:04.280
And for more information,
you can look at the seed

00:49:04.280 --> 00:49:05.800
release that you all received.

00:49:10.580 --> 00:49:13.720
And the last topic I'd like to
cover is to -- the last couple

00:49:13.720 --> 00:49:20.120
of topics I'd like to cover are
TSM and variant glyph access.

00:49:20.140 --> 00:49:24.430
So for those of you who supported the
tech services manager in the past,

00:49:24.430 --> 00:49:28.960
the thing that's different for
Unicode support is that you need to

00:49:28.960 --> 00:49:31.660
create a TSM document of type UDOC.

00:49:31.660 --> 00:49:35.750
To take advantage of the latest features,
you need to move to Carbon events

00:49:35.750 --> 00:49:38.330
instead of Apple events,
but as I'm sure you've been hearing

00:49:38.330 --> 00:49:42.250
elsewhere at the conference,
there's lots of good reasons to move

00:49:42.250 --> 00:49:45.380
your application to Carbon events.

00:49:45.380 --> 00:49:48.600
Supporting the input method
active area is something that's

00:49:48.760 --> 00:49:52.160
been around for a long time,
but if your application is

00:49:52.160 --> 00:49:54.940
not a Unicode application yet,
you'll also need to move to

00:49:54.940 --> 00:49:57.940
supporting Unicode input,
and again,

00:49:57.940 --> 00:50:02.270
GNU and Panther is the protocol
for accessing the entire

00:50:02.440 --> 00:50:06.670
contents of your document,
and that's critical to provide

00:50:06.670 --> 00:50:10.650
some of the user interface and
conversion accuracy features

00:50:10.670 --> 00:50:12.370
you saw demonstrated earlier.

00:50:12.550 --> 00:50:17.280
KotoAdi can't analyze the content of
your document to give great conversion

00:50:17.280 --> 00:50:20.460
results unless it can find out what
the content of your document is.

00:50:25.370 --> 00:50:28.960
So I'm going to go through
some of this rather quickly,

00:50:29.030 --> 00:50:33.300
because we don't really have
time to dive into it in detail.

00:50:33.300 --> 00:50:35.820
For Unicode input,
there's a single Carbon event

00:50:35.880 --> 00:50:37.240
that has Unicode text.

00:50:37.290 --> 00:50:40.190
It can also have glyph
variant information,

00:50:40.190 --> 00:50:42.980
and we'll talk about
that in a little bit.

00:50:43.180 --> 00:50:47.250
The input method active area
support protocol is pretty much

00:50:47.320 --> 00:50:49.350
the same as it's always been.

00:50:49.350 --> 00:50:52.880
There's just a few Carbon events
you have to handle,

00:50:52.880 --> 00:50:52.880
and there's nothing new here.

00:50:54.690 --> 00:50:58.220
The big new thing is the
document access protocol,

00:50:58.220 --> 00:51:01.600
and I don't have time to go
into this in great detail.

00:51:01.600 --> 00:51:04.580
You might think from this
long list of Carbon events

00:51:04.650 --> 00:51:07.390
that it's pretty complicated,
but it's not.

00:51:07.740 --> 00:51:09.600
The model is really simple.

00:51:09.710 --> 00:51:13.360
The way this works is that it
makes your document look like

00:51:13.360 --> 00:51:17.460
a CFString to the input method,
so the Carbon events that you

00:51:17.460 --> 00:51:21.440
respond to are just the same
things that CFString supports.

00:51:21.660 --> 00:51:23.510
It's really a very straightforward model.

00:51:23.600 --> 00:51:26.600
So if you implement support
for these Carbon events,

00:51:26.600 --> 00:51:29.600
input methods can access the
contents of your document,

00:51:29.600 --> 00:51:33.360
and you get the improved
conversion accuracy and new

00:51:33.360 --> 00:51:37.600
UI features like easy reconversion.

00:51:41.630 --> 00:51:45.180
I'll talk a little bit now
about variant glyph access.

00:51:45.180 --> 00:51:49.410
This is optional information that
comes with a Unicode text input event.

00:51:49.560 --> 00:51:55.270
You get an array of glyph
information records,

00:51:55.270 --> 00:51:58.780
and each record has
this information in it.

00:51:58.780 --> 00:52:02.110
First of all, there's a range of text,
and that can be more

00:52:02.160 --> 00:52:04.420
than one 16-bit Unicar.

00:52:04.450 --> 00:52:06.820
And the reason for that is,
it could be a variant

00:52:07.190 --> 00:52:09.320
version of a surrogate pair.

00:52:09.390 --> 00:52:12.000
So it could be more than
one Unicar for that reason.

00:52:12.060 --> 00:52:15.550
Or it could be a variant version
of something like a ligature.

00:52:15.650 --> 00:52:20.880
For example, the Zapfino font that comes
with Mac OS X has different

00:52:20.880 --> 00:52:22.860
versions of the Fi ligature.

00:52:22.900 --> 00:52:25.930
And to allow the user to
pick which one they want,

00:52:26.020 --> 00:52:29.160
they can do that via the
variant glyph access protocol.

00:52:29.420 --> 00:52:32.720
In that case, the range of text would
be the F and the I.

00:52:32.870 --> 00:52:35.600
So it can be more than one character.

00:52:35.600 --> 00:52:39.170
You also have to specify the font
that the variant is coming out of.

00:52:39.320 --> 00:52:43.550
There's two ways to identify
which particular glyph you want.

00:52:43.560 --> 00:52:48.460
One is via a font-specific glyph ID,
and that's used, for example,

00:52:48.460 --> 00:52:50.260
with TrueType fonts.

00:52:50.260 --> 00:52:54.740
But it can also be a glyph ID from
a published glyph collection,

00:52:54.740 --> 00:52:57.050
like Adobe Japan 1.5.

00:52:57.120 --> 00:53:01.880
And the record will identify which of
those two approaches is being used.

00:53:01.880 --> 00:53:04.100
You don't have to worry
about that too much,

00:53:04.100 --> 00:53:06.700
because AtSuite provides a style tag,
and all you have to do is take the

00:53:06.700 --> 00:53:07.720
information out of the -- you don't
have to worry about that too much,

00:53:07.720 --> 00:53:08.730
because AtSuite provides a style tag,
and all you have to do is take the

00:53:08.730 --> 00:53:11.910
information out of the Carbon event,
stuff it in this style tag,

00:53:11.910 --> 00:53:13.400
and give it to AtSuite.

00:53:13.400 --> 00:53:15.840
And this is all covered in Techno 2079.

00:53:21.440 --> 00:53:23.000
I won't talk about this very much at all.

00:53:23.000 --> 00:53:27.680
This will be covered in a session
that's coming up right after this

00:53:27.760 --> 00:53:31.520
one across the hall--what you need
to know about fonts in Mac OS X.

00:53:31.760 --> 00:53:35.280
This is how to support
advanced font attributes via

00:53:35.280 --> 00:53:38.760
the new font panel in Panther.

00:53:38.900 --> 00:53:43.500
There's already a Carbon event for
font selection via the font panel,

00:53:43.630 --> 00:53:45.400
and we've just added
more information to it.

00:53:45.400 --> 00:53:49.040
There's now a complete dictionary
with all the information that's

00:53:49.040 --> 00:53:52.710
specified in the font panel,
and all you need to do is extract the

00:53:52.760 --> 00:53:54.830
data from that and just pass it to Atsui.

00:53:54.970 --> 00:53:56.490
You don't have to worry
about what it means,

00:53:56.490 --> 00:54:00.500
you just basically have to funnel
it through your application.

00:54:00.610 --> 00:54:03.640
And for more details on that,
you can go to the FON session,

00:54:03.640 --> 00:54:06.900
which is session 406,
and coming up right after

00:54:07.280 --> 00:54:09.100
this one across the hall.

00:54:12.570 --> 00:54:16.630
Okay, I'd like to bring Kida-san back
up on stage one more time to

00:54:16.630 --> 00:54:20.460
talk about our Chinese input
methods and the character palette.

00:54:20.480 --> 00:54:21.740
Kida-san?

00:54:21.740 --> 00:54:23.500
Here.

00:54:23.500 --> 00:54:28.040
Let me get rid of those windows.

00:54:28.040 --> 00:54:34.380
And let me add one more thing here.

00:54:37.020 --> 00:54:38.480
Hello again.

00:54:38.550 --> 00:54:41.900
I'll show you a few more
features before wrap-up.

00:54:41.900 --> 00:54:44.900
The first one is simplified Chinese.

00:54:44.900 --> 00:54:50.530
No, traditional Chinese.

00:54:53.670 --> 00:55:01.370
On system 10.2.4 we added HanNin
traditional Chinese input method,

00:55:01.470 --> 00:55:04.590
which is very popular
input method online,

00:55:04.590 --> 00:55:10.270
and we were providing this input
method only for localized system 9,

00:55:10.400 --> 00:55:15.150
Mac OS 9, and we are offering to
everybody on Mac OS X.

00:55:15.720 --> 00:55:20.820
This is a word-based pin-in input method,
pin-in and both of them are input method,

00:55:20.910 --> 00:55:24.440
and it's much, much easier to use.

00:55:24.600 --> 00:55:32.440
I'll show you how, even I can use.

00:55:32.440 --> 00:55:34.440
I need a cheat sheet.

00:55:34.440 --> 00:55:43.440
One, e, e, da.

00:55:43.440 --> 00:55:45.300
Ja, lai, ta.

00:55:45.450 --> 00:55:46.520
No.

00:55:53.800 --> 00:56:07.500
[Transcript missing]

00:56:07.600 --> 00:56:19.100
[Transcript missing]

00:56:19.740 --> 00:56:25.630
The next one for traditional
Chinese is we added support

00:56:25.740 --> 00:56:29.260
for HKSC-S and Big Five-E.

00:56:29.630 --> 00:56:34.970
Those are additional character
sets on top of what we have today.

00:56:36.500 --> 00:56:50.200
[Transcript missing]

00:56:51.030 --> 00:56:58.420
Those characters marked in red
were missing in previous standard,

00:56:58.420 --> 00:57:00.400
which is peak 5.

00:57:00.490 --> 00:57:03.630
And you might be surprised how
many characters are missing.

00:57:03.710 --> 00:57:08.690
And actually, this thing,
this is the name of the

00:57:09.070 --> 00:57:15.890
new airport in Hong Kong,
Hong Kong International Airport.

00:57:15.890 --> 00:57:15.890
And these two at the bottom,

00:57:16.590 --> 00:57:20.790
asked names of subway
stations in Hong Kong.

00:57:20.890 --> 00:57:27.680
You couldn't even write your
airport name or subway station

00:57:27.680 --> 00:57:30.780
name without this extension.

00:57:30.870 --> 00:57:34.800
And if your application doesn't support

00:57:35.100 --> 00:57:44.600
[Transcript missing]

00:57:45.950 --> 00:57:48.970
Our simplified Chinese input method.

00:57:49.210 --> 00:57:54.390
We extended the input method--ABC
input method--so that it covers

00:57:54.440 --> 00:58:00.230
all the characters in GB 180 or 30.

00:58:01.300 --> 00:58:07.600
Um, let me pick simplified,
and let me pick the mode.

00:58:07.690 --> 00:58:10.030
And by the way,
you don't need to do this if the

00:58:10.190 --> 00:58:19.560
simplified Chinese input method are
revised and support a flattened mode.

00:58:20.330 --> 00:58:25.300
Yeah, this is one of the characters
which is only in GB 80 or 30.

00:58:25.350 --> 00:58:32.600
And the other example is Mu-Ti.

00:58:32.600 --> 00:58:33.500
Mu-Ti?

00:58:33.500 --> 00:58:34.400
Mu-Ti?

00:58:34.710 --> 00:58:35.320
Maybe?

00:58:35.320 --> 00:58:36.550
Oh, yes.

00:58:36.550 --> 00:58:36.550
This is too.

00:58:38.000 --> 00:58:40.600
Thank you.

00:58:40.600 --> 00:58:43.820
The last one is our character palette.

00:58:44.480 --> 00:58:51.100
We introduced the character palette first
in Jaguar and we found out many customers

00:58:51.220 --> 00:58:54.500
loved it and we also got many feedbacks.

00:58:54.500 --> 00:58:59.150
One of the feedback we got is some
of you want to enter character,

00:58:59.150 --> 00:59:03.010
exactly what you see on the screen,
I mean character palette.

00:59:03.350 --> 00:59:06.910
Because character palette honors
the font setting in application,

00:59:07.040 --> 00:59:12.700
usually you get different font between
character palette and application.

00:59:12.780 --> 00:59:17.980
But we got a feedback that you want
exactly the same character between

00:59:17.980 --> 00:59:20.820
the application and character palette.

00:59:22.390 --> 00:59:28.810
So here's a character palette,
which looks like one we have in Jaguar.

00:59:29.190 --> 00:59:33.460
And you have this little
disclosure triangle here.

00:59:33.460 --> 00:59:35.990
It says font variation.

00:59:37.410 --> 00:59:43.420
If you open it,
here's a list that lists the selected

00:59:43.420 --> 00:59:46.850
character in all fonts in the system.

00:59:46.860 --> 00:59:51.590
So you can browse this character
A using all fonts in the

00:59:51.590 --> 00:59:54.380
system and pick one you like.

00:59:54.600 --> 01:00:02.000
And if the character you've selected in
this list happen to have variant glyphs,

01:00:02.170 --> 01:00:06.730
it lists those variants
in this variant field.

01:00:06.780 --> 01:00:08.960
So, for example,

01:00:09.630 --> 01:00:11.260
This is Apple Chancelary.

01:00:11.390 --> 01:00:15.350
And you want a different A for this,
like, say, here.

01:00:15.800 --> 01:00:17.840
A long head.

01:00:17.970 --> 01:00:24.840
And here you have insert with
font at the bottom right.

01:00:25.020 --> 01:00:29.720
And if you press this button--oh.

01:00:30.280 --> 01:00:33.260
You insert the character
into the document.

01:00:33.330 --> 01:00:36.020
Let me try a different one.

01:00:37.450 --> 01:00:39.900
Say this one.

01:00:39.950 --> 01:00:43.030
And you insert a different glyph.

01:00:43.110 --> 01:00:44.390
Let me try to find one.

01:00:44.500 --> 01:00:52.110
You can drag the character to
this area to go to that character.

01:00:56.200 --> 01:01:01.400
Say I want Hiragino Minture Pro W6.

01:01:01.410 --> 01:01:08.900
And here you have different
. And say your name is,

01:01:09.060 --> 01:01:14.280
say, the one which have-- oh,
I already did that.

01:01:14.290 --> 01:01:19.300
Say two dots up here.

01:01:19.300 --> 01:01:23.590
You can insert,
and you now have two dots.

01:01:32.110 --> 01:01:36.660
Also, you can track the character,
rare character,

01:01:36.660 --> 01:01:42.220
and find which one has this character,
like this.

01:01:42.250 --> 01:01:46.640
So now I bring Deborah back
to the stage for the wrap up.

01:01:46.870 --> 01:01:48.480
Thank you.

01:01:53.450 --> 01:01:54.740
Thank you, Kida-san.

01:01:54.870 --> 01:01:59.260
I'd like to emphasize again how
important it is to support Unicode and

01:01:59.260 --> 01:02:04.520
the document content access protocol
on your applications so that your users

01:02:04.520 --> 01:02:07.540
have access to all these great features.

01:02:09.290 --> 01:02:13.220
So I didn't have a prop
budget for this talk,

01:02:13.220 --> 01:02:15.960
so I don't have a coffin
to roll out on stage,

01:02:15.960 --> 01:02:18.390
but WorldScript is dead.

01:02:18.450 --> 01:02:21.380
Quick Draw Text is dead.

01:02:21.380 --> 01:02:25.640
They can't begin to cover some of the
requirements that we're seeing in the

01:02:25.640 --> 01:02:28.230
Japanese and Chinese markets today.

01:02:28.400 --> 01:02:32.600
We're spending all of our efforts,
all of our focus is on Unicode.

01:02:32.600 --> 01:02:35.620
We're not spending any
time on WorldScript.

01:02:35.620 --> 01:02:39.380
We're not spending any time on making
enhancements to Quick Draw Text.

01:02:39.490 --> 01:02:41.000
So Unicode is it.

01:02:42.530 --> 01:02:46.960
Unicode will give your application
great competitive advantages in

01:02:46.960 --> 01:02:50.390
the Japanese and Chinese markets,
so you really should

01:02:50.390 --> 01:02:51.910
focus on adding that.

01:02:52.150 --> 01:02:58.460
And if you do that as a side benefit,
you get the rest of the world besides,

01:02:58.460 --> 01:03:01.060
which is not a small thing.

01:03:01.110 --> 01:03:03.040
Thank you, everyone.

01:03:07.870 --> 01:03:10.450
So I'd like to wrap up now.

01:03:10.670 --> 01:03:13.240
Here's a couple of other sessions,
or more than a couple,

01:03:13.240 --> 01:03:15.060
that you might be interested in.

01:03:15.070 --> 01:03:19.800
Immediately after this session is what
you need to know about fonts in Mac OS X.

01:03:19.800 --> 01:03:22.100
The whole name didn't fit on the slide.

01:03:22.100 --> 01:03:25.390
You can find out about the font panel,
and the typography panel,

01:03:25.630 --> 01:03:30.440
and lots of other useful information
about using fonts on Mac OS X.

01:03:30.450 --> 01:03:34.720
And that's in the Mission Room,
starting at 3:30.

01:03:34.750 --> 01:03:37.240
On Friday at 5 o'clock,
in the Presidio Room,

01:03:37.280 --> 01:03:38.740
there's the Cocoa Text session.

01:03:38.740 --> 01:03:41.360
You can find out about
new features for Panther,

01:03:41.360 --> 01:03:46.040
and all the other great things that are
going on in the world of Cocoa Text.

01:03:46.060 --> 01:03:50.680
Unfortunately, at the exact same time,
also at Friday at 5:00 PM, in Nob Hill,

01:03:50.680 --> 01:03:56.620
is a session on our new Ink APIs, which,
if you're interested in enhancing your

01:03:56.620 --> 01:04:00.290
application support for handwriting,
you can find out about how to

01:04:00.290 --> 01:04:02.340
use these new APIs to do that.

01:04:02.370 --> 01:04:06.720
And finally,
if you want to let us know what's bugging

01:04:06.720 --> 01:04:10.650
you or what you think is going great,
our International Technologies Feedback

01:04:10.830 --> 01:04:14.400
Forum is Friday at 10:30
in the North Beach Room.

01:04:14.400 --> 01:04:18.130
And we'd love to have you come and
give us feedback on what we could do

01:04:18.130 --> 01:04:20.500
better and what we're doing right.

01:04:22.210 --> 01:04:25.560
So if you have further questions,
the first person you should

01:04:25.560 --> 01:04:28.230
be talking to is Xavier,
and his email address

01:04:28.230 --> 01:04:29.530
is easy to remember.

01:04:29.550 --> 01:04:31.700
It's xavier@apple.com.

01:04:31.730 --> 01:04:35.400
If you have any questions when
you're done talking to Xavier,

01:04:35.400 --> 01:04:36.950
you can also contact me.

01:04:36.950 --> 01:04:41.030
And my email address is goldsmith,
without the H, at apple.com.

01:04:42.950 --> 01:04:45.940
You don't need to scribble a
lot of stuff down because the

01:04:45.940 --> 01:04:50.240
URL that you see at the bottom of
the screen-- developer.apple.com,

01:04:50.240 --> 01:05:00.390
WWDC2003urls.html-- will have all
the contact information and all the

01:05:00.390 --> 01:05:00.390
URLs from all the talks at WWDC.

01:05:03.250 --> 01:05:06.920
Here are some places you
can go for more information.

01:05:06.960 --> 01:05:09.760
There's our documentation library,
of course.

01:05:09.760 --> 01:05:13.700
We also have a nice summary page
for international technologies.

01:05:13.710 --> 01:05:17.860
That's developer.apple.com/intl.

01:05:17.860 --> 01:05:21.360
If you want to develop fonts,
we have a font developer web page.

01:05:21.390 --> 01:05:25.140
That's developer.apple.com/fonts.

01:05:25.140 --> 01:05:29.560
There's, of course,
references for the app kit and for Atsui.

01:05:29.830 --> 01:05:33.450
UniCode Utilities,
which is used for finding text

01:05:33.450 --> 01:05:36.680
boundaries and comparison and searching.

01:05:36.790 --> 01:05:41.170
There's a specialized set of
topics on Cocoa text handling.

01:05:41.320 --> 01:05:44.580
There's documentation on CFString.

01:05:46.930 --> 01:05:51.500
Here's a handful of useful
Tech Notes and sample code.

01:05:51.520 --> 01:05:54.920
Tech Note 2056 is on how to
do your own keyboard layouts.

01:05:55.240 --> 01:05:59.330
2079, the Variant Glyph Access Protocol,
it has much more detail

01:05:59.330 --> 01:06:00.800
than I was able to go into.

01:06:01.200 --> 01:06:07.980
There's a sample app for Atsui
and how to draw UniCode text,

01:06:07.980 --> 01:06:07.980
and how to do your own input method.

01:06:09.580 --> 01:06:14.640
and some pointers outside of Apple,
the Unicode Consortium has a website

01:06:15.090 --> 01:06:16.840
for more information about Unicode.

01:06:16.840 --> 01:06:18.220
That's the best place to start.

01:06:18.280 --> 01:06:21.930
There's a new version of the Unicode
book coming out for the new 4.0

01:06:22.050 --> 01:06:26.690
version of the standard and much more
readable than the standard itself is

01:06:26.820 --> 01:06:28.920
Unicode Demystified by Richard Gillum.

01:06:28.920 --> 01:06:32.160
I highly recommend that as an
introduction to Unicode if you

01:06:32.160 --> 01:06:33.830
want to learn more about it.

01:06:33.900 --> 01:06:36.420
And finally,
the open source international

01:06:36.420 --> 01:06:40.530
components for Unicode Library has
its own website that's hosted by IBM.
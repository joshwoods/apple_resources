WEBVTT

00:00:26.130 --> 00:00:27.000
Thank you very much.

00:00:27.000 --> 00:00:29.970
It's my pleasure to
welcome you to session 200,

00:00:30.000 --> 00:00:32.680
which is a Graphics and Imaging Overview.

00:00:32.680 --> 00:00:36.340
What we typically do at the
sort of overview session for

00:00:36.450 --> 00:00:39.720
the Graphics Track at WWDC is we
followed a formula in the past,

00:00:39.720 --> 00:00:43.090
and that formula is essentially tell
you about the new announcements for

00:00:43.100 --> 00:00:46.650
the upcoming technology announcements
for the upcoming version of Mac OS X,

00:00:46.650 --> 00:00:50.370
and then point you to various
sessions that are going to talk

00:00:50.370 --> 00:00:53.960
about those particular technologies.

00:00:54.080 --> 00:00:57.830
And we're actually going to change
things up a little bit this year.

00:00:57.830 --> 00:01:00.320
And what we're going to do is
sort of recast the session.

00:01:00.320 --> 00:01:04.640
And we're going to actually recast it as
a Graphics and Imaging Direction session.

00:01:04.640 --> 00:01:07.690
Because there's a very important
thing that's happening at Apple,

00:01:07.720 --> 00:01:11.430
that our rate of innovation in terms
of the graphics technologies that we

00:01:11.510 --> 00:01:13.550
build into Mac OS X is incredible.

00:01:13.560 --> 00:01:16.390
We have fantastic technologies
such as Quartz Extreme,

00:01:16.390 --> 00:01:19.820
a compositing windowing system
that gives us the ability to create

00:01:19.920 --> 00:01:23.740
dramatic visual effects such as expose,
and also the fast user switching that

00:01:23.740 --> 00:01:25.200
everyone seemed to like yesterday.

00:01:25.200 --> 00:01:28.590
And we're going to be able to create a
lot of different kinds of visual effects,

00:01:28.590 --> 00:01:31.510
such as the image that we're seeing here,
and the image that we're

00:01:31.600 --> 00:01:32.670
seeing on the screen.

00:01:32.670 --> 00:01:37.270
And we're going to be able to create a
lot of different kinds of visual effects,

00:01:37.270 --> 00:01:41.410
and we're going to be able to create a
lot of different kinds of visual effects.

00:01:41.410 --> 00:01:45.900
And we're going to be able to create a
lot of different kinds of visual effects.

00:01:45.970 --> 00:01:51.510
And we're going to be able to create a
lot of different kinds of visual effects.

00:01:51.740 --> 00:01:55.560
And we're going to be able to
create a lot open graphics.

00:01:55.650 --> 00:01:58.290
And with your release cycles being
anywhere from 12 to 24 months,

00:01:58.290 --> 00:02:01.290
it's often difficult for you
guys to see where the trend is,

00:02:01.300 --> 00:02:05.030
to see which technologies you guys
need to really invest in in terms

00:02:05.160 --> 00:02:08.670
of building your products on to make
sure you make maximum use of the

00:02:08.790 --> 00:02:13.320
platform and create really compelling
applications for our mutual users.

00:02:13.320 --> 00:02:15.700
So what we're going to do with this
session is we're going to focus on

00:02:15.700 --> 00:02:19.160
two main themes that we have that
run through our sort of technology

00:02:19.160 --> 00:02:21.240
innovation and graphics at Apple.

00:02:21.330 --> 00:02:25.380
That's going to be PDF and also the
ascendancy of the GPU as a way to

00:02:25.380 --> 00:02:28.160
do a lot of even 2D graphics work.

00:02:28.190 --> 00:02:30.330
So what I'd like to do is
invite Peter Graffagnino,

00:02:30.330 --> 00:02:32.840
the director of graphics and
imaging software to the stage,

00:02:32.850 --> 00:02:34.840
and he's going to take
you through the session.

00:02:34.880 --> 00:02:35.830
Thank you.

00:02:35.850 --> 00:02:36.840
PETER GRAFFANINO: Thanks, Travis.

00:02:36.840 --> 00:02:37.840
Great.

00:02:37.840 --> 00:02:38.840
Thanks, Travis.

00:02:38.840 --> 00:02:39.840
Thanks, Travis.

00:02:39.840 --> 00:02:40.840
Thanks, Travis.

00:02:43.110 --> 00:02:44.400
Thank you very much, Travis.

00:02:44.400 --> 00:02:45.800
Good to be here at WWDC.

00:02:45.800 --> 00:02:47.760
Good to see all you guys here.

00:02:47.760 --> 00:02:51.400
I think we've got a
great week for you today,

00:02:51.420 --> 00:02:53.000
this week at WWDC.

00:02:53.000 --> 00:02:55.440
And today in particular,
we're going to take you

00:02:55.440 --> 00:02:58.000
through the overview of the
graphics and imaging sessions,

00:02:58.000 --> 00:03:02.180
which are always fun sessions at WWDC.

00:03:02.260 --> 00:03:06.110
The first thing I'm going to do is,
for those of you who are new

00:03:06.110 --> 00:03:09.570
to Mac OS X or new to WWDC,
is do a brief overview of the

00:03:09.680 --> 00:03:12.160
graphics architecture of Mac OS X.

00:03:12.220 --> 00:03:14.380
Then I'm going to go into,
as Travis said,

00:03:14.450 --> 00:03:18.180
two kind of central themes,
underlying themes that we see in the

00:03:18.180 --> 00:03:21.800
industry and that we're taking advantage
of in Mac OS X that I think it's really

00:03:21.800 --> 00:03:24.190
important for you guys to understand.

00:03:24.250 --> 00:03:28.200
The first one is about PDF,
which we call Mac OS X's digital paper.

00:03:28.330 --> 00:03:32.810
The next is the GPU computing revolution,
which I think is a real

00:03:32.930 --> 00:03:35.190
significant development.

00:03:35.210 --> 00:03:38.650
And finally,
we'll go and do the tour of technologies

00:03:38.650 --> 00:03:41.110
and show you what's new in Panther.

00:03:41.900 --> 00:03:45.560
So first of all,
the block diagram review to all of you.

00:03:45.600 --> 00:03:50.560
We've got our Core OS, Darwin,
at the bottom, based on FreeBSD and Mach.

00:03:50.640 --> 00:03:52.340
Graphics layers on top of that.

00:03:52.600 --> 00:03:58.800
And then the frameworks, Cocoa, Carbon,
and on top of that the user interface,

00:03:58.800 --> 00:03:59.520
Aqua.

00:04:00.220 --> 00:04:04.100
In the graphics areas,
we've got all of our technologies:

00:04:04.100 --> 00:04:08.940
Quartz 2D for 2D graphics,
OpenGL for 3D graphics,

00:04:09.090 --> 00:04:13.190
QuickTime for multimedia and video,
and our compositing windowing

00:04:13.200 --> 00:04:15.770
system called Quartz Compositor.

00:04:16.710 --> 00:04:19.400
QuickTime you heard about if
you were in the session before.

00:04:19.400 --> 00:04:22.170
It was a general overview
of QuickTime directions.

00:04:22.340 --> 00:04:25.520
They've combined the QuickTime live
conference with WWDC this year,

00:04:25.520 --> 00:04:30.480
so there's a lot of great
content on QuickTime,

00:04:30.480 --> 00:04:30.480
but I'm not really going to
talk about it right here.

00:04:30.900 --> 00:04:35.320
Quartz 2D, I'll give you a brief overview
of what's in Quartz 2D.

00:04:35.320 --> 00:04:39.600
Basically, it's our 2D imaging model
based on the industry standard

00:04:39.600 --> 00:04:41.340
PostScript and PDF model.

00:04:41.340 --> 00:04:44.170
This imaging model's been
around for a number of years,

00:04:44.180 --> 00:04:45.780
almost 20 years now.

00:04:45.780 --> 00:04:48.730
And it's really kind of a credit
to the original designers that it's

00:04:48.730 --> 00:04:51.540
able to describe basically every
page that's ever been printed.

00:04:51.540 --> 00:04:56.780
In fact, Adobe is celebrating the 20th
anniversary of PostScript,

00:04:56.780 --> 00:05:00.030
and they published a nice book that
was kind of an interesting read if

00:05:00.120 --> 00:05:01.340
you're into the history of this stuff.

00:05:01.410 --> 00:05:05.040
But anyway,
our Quartz 2D imaging model is based

00:05:05.040 --> 00:05:08.070
on the industry standard PostScript,
and it's really just a lightweight

00:05:08.280 --> 00:05:12.300
C library that implements the
PostScript imaging model primitives.

00:05:12.340 --> 00:05:18.560
And so there's no display PDF,
as some people have asked about,

00:05:18.560 --> 00:05:20.430
or display PostScript or
anything like that.

00:05:20.650 --> 00:05:23.760
It's really just a lightweight C library.

00:05:26.420 --> 00:05:28.890
We can read and write
PDF with that library,

00:05:28.890 --> 00:05:31.670
so you can think of PDF as
kind of the meta-file format

00:05:32.110 --> 00:05:33.730
for the graphics library.

00:05:33.740 --> 00:05:36.570
In fact, we knew we wanted PDF to
be the meta-file format,

00:05:36.660 --> 00:05:38.880
so we kind of worked backward
from that to figure out what

00:05:38.880 --> 00:05:40.430
the good API would be for that.

00:05:40.540 --> 00:05:42.830
We've got really fast anti-aliasing.

00:05:42.870 --> 00:05:46.530
As you see in the Acquius interface,
the quality of the presentation

00:05:46.530 --> 00:05:49.540
of the line art and graphics
and icons is really important,

00:05:49.680 --> 00:05:53.540
so we spent a lot of time making
things look good and run real fast.

00:05:53.540 --> 00:05:56.310
It has Destination Alpha,
which allows us to record

00:05:56.470 --> 00:05:58.320
coverage information as we draw.

00:05:58.510 --> 00:06:02.590
This allows us to do composited
icons and sprites that can carry

00:06:02.720 --> 00:06:07.510
along their anti-aliasing information
as they animate or move around.

00:06:07.880 --> 00:06:11.450
One of the great things about PostScript,
it really revolutionized

00:06:11.460 --> 00:06:14.330
digital typography,
invented outline fonts,

00:06:14.360 --> 00:06:17.050
device-independent fonts,
and over the years there's

00:06:17.050 --> 00:06:21.460
of course been Type 1,
the original Adobe digital font format.

00:06:21.530 --> 00:06:23.690
There's been TrueType
that Apple invented,

00:06:23.700 --> 00:06:25.900
and OpenType, and others have come along.

00:06:25.960 --> 00:06:29.610
And Apple has a great technology called
Apple Type Services that Quartz 2D

00:06:29.610 --> 00:06:35.100
leverages to bring you all the typefaces
and just handle them seamlessly for you,

00:06:35.100 --> 00:06:37.490
including a full Type 1 scaler.

00:06:37.880 --> 00:06:41.000
ColorSync is also built into Quartz 2D.

00:06:41.070 --> 00:06:44.250
It's our implementation of the
ICC standard for color-managed

00:06:44.250 --> 00:06:48.760
workflow and allows us to manage color
end-to-end in the Quartz 2D library.

00:06:48.800 --> 00:06:51.360
And obviously one of the big
things about a 2D library is

00:06:51.360 --> 00:06:52.790
how it relates to printing.

00:06:52.800 --> 00:06:57.340
Basically the whole WYSIWYG notion of
being able to have the same imaging

00:06:57.340 --> 00:06:58.800
model for screen and printing.

00:06:58.800 --> 00:07:01.810
And so Quartz and PDF play
very much a central role in the

00:07:01.810 --> 00:07:03.630
printing architecture as well.

00:07:03.800 --> 00:07:07.090
The spool file we create when
you go to draw into your printing

00:07:07.240 --> 00:07:08.800
context is just a PDF file.

00:07:08.800 --> 00:07:12.660
And then that PDF file is rasterized
for inkjet printers using the same

00:07:12.670 --> 00:07:16.470
high-quality Quartz rasterization,
or converted to PostScript for

00:07:16.550 --> 00:07:17.800
a PostScript printer.

00:07:17.800 --> 00:07:20.180
And again,
we can use the end-to-end color

00:07:20.190 --> 00:07:24.770
management we have in the system to
manage color through the whole process.

00:07:24.900 --> 00:07:28.140
And the infrastructure we build
all the core graphics conversion

00:07:28.140 --> 00:07:30.740
around that's part of printing,
and just important,

00:07:30.810 --> 00:07:33.860
is sort of the spooling and sequencing
architecture and the networking

00:07:33.860 --> 00:07:35.800
architecture around printing.

00:07:35.800 --> 00:07:38.890
And for that we're using an open
source technology called CUPS,

00:07:38.910 --> 00:07:40.800
which stands for
Common Unix Printing System,

00:07:40.800 --> 00:07:44.800
which is an implementation of
an open standard called IPP.

00:07:44.800 --> 00:07:48.100
And it's kind of an upgrade if you're
familiar with the LPR/LPD suite

00:07:48.240 --> 00:07:49.800
that comes along with Unix.

00:07:49.840 --> 00:07:51.800
This is kind of an upgrade to that.

00:07:51.800 --> 00:07:58.900
There are still command line utilities
that do the same LPD/LPR functions,

00:07:59.020 --> 00:08:01.800
but CUPS provides much more
modern infrastructure for that.

00:08:01.800 --> 00:08:03.490
for that.

00:08:04.280 --> 00:08:07.700
So that's Quartz 2D to give you
a brief framework in which to

00:08:07.750 --> 00:08:09.740
think about our 2D graphics.

00:08:09.740 --> 00:08:11.940
For 3D graphics, it's OpenGL.

00:08:12.020 --> 00:08:15.970
Again, industry standard technology,
been around for maybe 15 years as

00:08:16.150 --> 00:08:20.200
the original Iris graphics library
on the silicon graphics machines.

00:08:20.400 --> 00:08:24.750
And Apple's implementation is really
a state-of-the-art implementation.

00:08:24.800 --> 00:08:28.690
We took our job very seriously in terms
of building an OS infrastructure around

00:08:29.090 --> 00:08:34.700
driving graphics cards and virtualizing
resources like video memory usage.

00:08:34.700 --> 00:08:38.200
And we have a lot of data flow
optimizations to make sure things

00:08:38.200 --> 00:08:42.400
like multimedia and video can flow
through the system very quickly.

00:08:45.600 --> 00:10:24.700
[Transcript missing]

00:10:25.900 --> 00:10:27.870
So that's OpenGL.

00:10:28.160 --> 00:10:31.930
Last kind of review bullet here
is about the Quartz Compositor.

00:10:31.990 --> 00:10:35.680
The Quartz Compositor is our
implementation of the windowing system.

00:10:35.700 --> 00:10:39.080
Basically composites all the
layers together on the screen.

00:10:39.190 --> 00:10:41.290
It's based, again,
on some pretty tried and true

00:10:41.330 --> 00:10:42.960
techniques in the industry.

00:10:42.960 --> 00:10:47.460
A seminal paper,
a 1984 SIGGRAPH about the compositing

00:10:47.460 --> 00:10:49.390
algebra by Porter and Duff.

00:10:49.540 --> 00:10:51.960
They basically introduced the
notion of the alpha channel,

00:10:52.000 --> 00:10:55.840
RGBA compositing,
and a whole algebra for doing that.

00:10:55.870 --> 00:10:58.160
And in those days,
they were doing things like they

00:10:58.160 --> 00:11:01.320
had one program that could render
fractals and one program that could,

00:11:01.320 --> 00:11:02.360
say, render spheres.

00:11:02.360 --> 00:11:05.290
And you didn't want to run them
both every frame if one was static.

00:11:05.300 --> 00:11:08.190
And so you needed a way to combine
the results after the rendering

00:11:08.190 --> 00:11:10.350
with high quality anti-aliasing.

00:11:10.370 --> 00:11:13.620
And that's where the compositing
algebra came into play.

00:11:13.620 --> 00:11:16.280
And it's been used pretty
much ever since as a real

00:11:16.390 --> 00:11:18.720
fundamental primitive of graphics.

00:11:18.800 --> 00:11:21.680
And what we're doing is just using
that in real time on the display.

00:11:22.000 --> 00:11:24.830
And we're using that to composite
the output of all the applications to

00:11:24.910 --> 00:11:27.340
make up the graphical user interface.

00:11:27.680 --> 00:11:29.500
So here's a block diagram
of Quartz Extreme,

00:11:29.500 --> 00:11:32.830
which we announced last year,
which is the implementation of the

00:11:32.950 --> 00:11:35.080
Quartz compositor on top of OpenGL.

00:11:35.410 --> 00:11:38.810
So the application can be drawing in
whatever graphics library it wants,

00:11:38.950 --> 00:11:42.130
whether it's Quartz 2D, OpenGL,
QuickTime.

00:11:42.150 --> 00:11:45.030
And basically,
the compositor will blend those

00:11:45.200 --> 00:11:48.870
together using GL into the frame buffer.

00:11:49.610 --> 00:11:52.390
Now, Panther is kind of our third
generation of this sort of

00:11:52.500 --> 00:11:54.380
desktop compositing engine.

00:11:54.380 --> 00:11:57.360
We originally,
in the first release of Mac OS X,

00:11:57.360 --> 00:12:00.330
it was all software-based
solution with some hardware

00:12:00.330 --> 00:12:03.600
acceleration for like moving opaque
windows and things like that.

00:12:03.670 --> 00:12:05.760
In Jaguar,
we put everything on top of GL.

00:12:05.830 --> 00:12:08.280
In Panther,
we've been refining it further to

00:12:08.300 --> 00:12:13.500
make it suitable for things like
the expose feature that you saw.

00:12:13.500 --> 00:12:16.100
And it's really the natural
evolution of windowing systems.

00:12:16.120 --> 00:12:19.440
I really think people and users
just expect Windows to composite

00:12:19.500 --> 00:12:23.180
and I think everyone's going
to be doing this eventually.

00:12:23.230 --> 00:12:26.260
And Apple OpenGL,
since we've proven in Jaguar and

00:12:26.280 --> 00:12:31.440
been running the desktop compositor
on top of GL ever since Jaguar,

00:12:31.440 --> 00:12:38.240
I think it's obvious that Apple GL is
robust enough for 24 by 7 operation.

00:12:38.280 --> 00:12:41.670
And the other thing that's key
to understand about the Quartz

00:12:41.750 --> 00:12:45.290
Extreme implementation is once
it gets the textured polygons it

00:12:45.390 --> 00:12:48.430
needs to draw to make up the GUI,
there's really no special

00:12:48.800 --> 00:12:50.300
OpenGL calls it makes.

00:12:50.300 --> 00:12:54.540
All of the acceleration in terms of
minimal CPU copies and getting data

00:12:54.540 --> 00:12:57.240
to the frame buffer and the blending
modes and all of those things are

00:12:57.250 --> 00:12:58.980
accessible to OpenGL developers.

00:12:58.980 --> 00:13:02.440
So we did a lot of tuning on the data
paths to make sure we did minimal copies

00:13:02.510 --> 00:13:05.890
because when you're throwing around,
you know, megabytes per window,

00:13:05.890 --> 00:13:08.060
you really can't copy any data.

00:13:08.080 --> 00:13:11.180
But all of those advantages,
advances are usable by you.

00:13:11.180 --> 00:13:13.490
And in fact,
the keynote guys take advantage of a

00:13:13.490 --> 00:13:17.110
lot of those because they have pretty
big textures when they're compositing

00:13:17.110 --> 00:13:19.100
and doing transitions as well.

00:13:19.100 --> 00:13:23.640
So the big thing that we did new
with Quartz Extreme this year,

00:13:23.900 --> 00:13:26.320
one of the main things was the expose.

00:13:26.320 --> 00:13:29.620
I'm not going to give you a demo
because you saw it in the keynote,

00:13:29.620 --> 00:13:34.300
but basically the idea of animating all
your windows so you can see everything,

00:13:34.300 --> 00:13:38.380
have a nice ability to pick
up an icon off the desktop

00:13:38.380 --> 00:13:42.850
and without having to drop it,
release the windows and be able

00:13:42.890 --> 00:13:44.340
to drag it into something else.

00:13:44.340 --> 00:13:47.700
So that's basically
the Quartz compositor.

00:13:51.710 --> 00:13:54.900
So there you have all the
graphics technologies in

00:13:54.970 --> 00:13:58.380
Mac OS X in sort of a brief review.

00:14:00.390 --> 00:14:04.450
Let me go into now one of my
first kind of extended themes that

00:14:04.450 --> 00:14:06.730
I'm going to talk about today,
and that's PDF,

00:14:06.860 --> 00:14:09.040
what I call Mac OS X's digital paper.

00:14:09.130 --> 00:14:13.140
And this is not really a general kind
of PDF in the industry discussion,

00:14:13.140 --> 00:14:17.560
but kind of how we view PDF as
an OS implementer and provider,

00:14:17.560 --> 00:14:20.430
and what we're using it for in
terms of the OS and the kind of

00:14:20.430 --> 00:14:25.000
opportunities we're trying to make
available for you guys as developers.

00:14:26.430 --> 00:14:28.860
So first off, this digital paper notion.

00:14:28.860 --> 00:14:33.660
PDF, the best way I can always think of
to describe to someone what PDF is,

00:14:33.660 --> 00:14:35.300
is just to say digital paper.

00:14:35.460 --> 00:14:38.280
Because it really is a digital
representation of a printed page.

00:14:38.280 --> 00:14:41.460
So in other words,
it's got pagination built in,

00:14:41.460 --> 00:14:47.550
and it can basically represent
the output from any application,

00:14:47.610 --> 00:14:49.300
so it's application independent.

00:14:49.300 --> 00:14:52.130
It can present output to
any number of devices.

00:14:52.140 --> 00:14:53.900
It can handle any color
spaces or whatever,

00:14:53.900 --> 00:14:55.260
so it's device independent.

00:14:55.260 --> 00:14:57.290
And it's extremely high fidelity.

00:14:57.290 --> 00:15:00.360
I mean, basically,
the imaging model behind PDF is the same

00:15:00.360 --> 00:15:02.120
as the imaging model behind PostScript.

00:15:02.250 --> 00:15:04.080
And as I said before,
it's been able to describe

00:15:04.080 --> 00:15:07.420
basically every page ever printed
in the last 20 years or so.

00:15:07.420 --> 00:15:09.760
So that's pretty high fidelity.

00:15:09.780 --> 00:15:13.510
And there's 500 million
viewers distributed,

00:15:13.510 --> 00:15:15.780
so it's obviously universal.

00:15:15.780 --> 00:15:18.270
You can send someone a PDF file
and be pretty guaranteed that

00:15:18.270 --> 00:15:21.720
no matter what platform on,
they'll be able to look at it.

00:15:21.850 --> 00:15:27.010
So the way I think about it is,
PDF is really universal sort

00:15:27.010 --> 00:15:31.100
of view level abstraction
in the MVC paradigm world.

00:15:31.120 --> 00:15:34.460
And when I put these slides together,
I didn't know MVC was going to be

00:15:34.460 --> 00:15:36.540
such a theme at WWDC this year.

00:15:36.540 --> 00:15:41.340
So I have a brief review of MVC from
a graphics guy's standpoint.

00:15:41.370 --> 00:15:46.180
So MVC is a standard way
object-oriented programmers have

00:15:46.390 --> 00:15:52.490
thought about factoring code into
a model of view in a controller.

00:15:52.490 --> 00:15:55.640
And my example is, basically,
the model is the application data.

00:15:55.640 --> 00:15:58.050
So the model is the application
data structures like the variables

00:15:58.140 --> 00:16:04.040
and the algorithms and the data
behind the model of the program.

00:16:04.060 --> 00:16:06.080
The view is a visual representation.

00:16:06.180 --> 00:16:09.720
So it could be a pie
chart or a bar graph,

00:16:09.730 --> 00:16:11.860
whatever you want.

00:16:11.860 --> 00:16:14.560
The idea is you can have multiple
views of the same model data.

00:16:14.700 --> 00:16:17.860
And the controller might be a
user interface area where you let,

00:16:17.860 --> 00:16:20.990
you know,
the user type into a field to change

00:16:21.070 --> 00:16:23.730
the data to manipulate the model.

00:16:24.430 --> 00:16:27.340
And so basically,
the value of MVC is the fact that

00:16:27.450 --> 00:16:31.380
you've factored your code so you have
a model that can have multiple views.

00:16:31.540 --> 00:16:33.670
So if you have a pie
chart or a bar graph,

00:16:33.760 --> 00:16:35.740
you don't have to change
your implementation of how to

00:16:35.740 --> 00:16:37.280
recalculate the spreadsheet.

00:16:37.320 --> 00:16:40.430
Models can have multiple controllers,
so you can have a simple user interface,

00:16:40.430 --> 00:16:42.880
an advanced user interface,
or even a scripting interface,

00:16:42.880 --> 00:16:44.580
and have your model code be the same.

00:16:44.580 --> 00:16:48.300
And kind of from a graphics standpoint,
the interesting thing is that any model,

00:16:48.700 --> 00:16:51.650
whether it's spreadsheet, database,
audio file, or whatever,

00:16:51.710 --> 00:16:55.670
can project themselves into a 2D
representation to show to the user.

00:16:55.780 --> 00:16:57.300
Otherwise,
the user wouldn't be able to run the

00:16:57.300 --> 00:17:01.080
app because they couldn't see the data.

00:17:01.290 --> 00:17:05.160
And so views of vastly different models
can share a common visual language.

00:17:05.160 --> 00:17:08.050
And this is how graphical user
interfaces work when you think about it.

00:17:08.050 --> 00:17:10.680
I mean, you basically have
similar-looking windows,

00:17:11.040 --> 00:17:15.140
but presenting vastly different
models of--depending upon

00:17:15.200 --> 00:17:17.780
which application is being run.

00:17:17.780 --> 00:17:19.990
The same thing with documents,
compound documents,

00:17:19.990 --> 00:17:22.630
where you may have part of a
document coming from a spreadsheet,

00:17:22.860 --> 00:17:24.560
part of a document
coming out of a database,

00:17:24.560 --> 00:17:26.840
part of a document from a text flow.

00:17:26.870 --> 00:17:30.640
And because you can project all those
things down to a view-level format,

00:17:30.700 --> 00:17:33.580
which is, say, a PDF file,
you can have them all share

00:17:33.580 --> 00:17:36.960
the common visual language,
even though the actual data

00:17:37.040 --> 00:17:39.400
backing them is pretty different.

00:17:39.400 --> 00:17:44.200
So let's move on here.

00:17:46.410 --> 00:17:49.230
I might have to use the
old fashioned way here.

00:17:49.420 --> 00:17:50.150
OK.

00:17:50.490 --> 00:17:56.540
So document-based applications
are really MVC in their nature.

00:17:56.570 --> 00:17:59.900
You can think of the model as
kind of the application file.

00:17:59.900 --> 00:18:04.260
The data structures of the application,
in this case Excel-- the Excel file is

00:18:04.260 --> 00:18:06.280
really you can think of as the model.

00:18:06.310 --> 00:18:08.960
The view would be like the
document window that comes up,

00:18:08.970 --> 00:18:11.660
where you get the row and column
representation of the model.

00:18:11.810 --> 00:18:13.420
The controller would
be the user interface,

00:18:13.500 --> 00:18:16.930
the application, all the menus and panels
that you interact with.

00:18:16.940 --> 00:18:18.180
I'll try this one more time.

00:18:18.180 --> 00:18:19.640
There we go.

00:18:20.050 --> 00:18:23.580
So the interesting thing to realize
from a graphic standpoint is when you

00:18:23.700 --> 00:18:27.020
create a PDF from your spreadsheet,
it's no longer a spreadsheet.

00:18:27.120 --> 00:18:30.630
You've projected that model into a view,
and you really just have a

00:18:30.650 --> 00:18:32.640
representation of a spreadsheet.

00:18:32.670 --> 00:18:35.300
And I think it's really important
to keep the difference between

00:18:35.300 --> 00:18:40.220
models and views and look at
it this way and how PDF serves.

00:18:41.090 --> 00:18:43.290
So model versus view.

00:18:43.300 --> 00:18:45.540
You can imagine if I'm
interacting with someone,

00:18:45.540 --> 00:18:49.250
I have a choice of whether to send them
the Excel file or send them the PDF that

00:18:49.250 --> 00:18:51.870
represents the data in the Excel file.

00:18:52.130 --> 00:18:54.520
And really both are valid choices.

00:18:54.670 --> 00:18:57.620
On the left-hand with the model,
I get a very high fidelity

00:18:57.710 --> 00:18:59.530
model representation.

00:18:59.530 --> 00:19:03.040
I can exchange data and they
can modify the model if they

00:19:03.040 --> 00:19:04.170
want or change the formulas.

00:19:04.170 --> 00:19:07.550
It requires that they're going to
have that application and also have

00:19:07.550 --> 00:19:11.850
any fonts or plug-ins that I may
have used in creating that model.

00:19:12.050 --> 00:19:14.700
On the other hand,
on the view exchange side,

00:19:14.810 --> 00:19:17.790
if I send them a PDF,
I can guarantee that they're going

00:19:17.790 --> 00:19:20.480
to be able to see it because there's
500 million viewers out there.

00:19:20.520 --> 00:19:21.390
They're going to see the right fonts.

00:19:21.390 --> 00:19:22.440
They're going to see everything.

00:19:22.440 --> 00:19:25.010
They're not going to be able to
interact with the data or change

00:19:25.280 --> 00:19:27.060
the basic calculations that go on.

00:19:27.110 --> 00:19:29.630
In fact, in many cases,
you don't want that.

00:19:29.630 --> 00:19:33.280
But they are going to get a high
fidelity view representation.

00:19:38.120 --> 00:19:42.280
So one of the reasons why this is,
I think, important to lay out is that

00:19:42.310 --> 00:19:46.300
if you look at the typical
file menu of a application,

00:19:46.320 --> 00:19:49.620
sometimes we get asked why save
as PDF isn't just in there.

00:19:49.620 --> 00:19:53.630
And I think the reason has to do
with this model versus view idea.

00:19:54.110 --> 00:19:57.420
Normally in the file menu,
when you're talking about open, close,

00:19:57.420 --> 00:20:00.750
save, or even export,
you're talking about exporting or saving

00:20:00.870 --> 00:20:05.750
the actual model data of the application,
which could be, you know, anything.

00:20:05.770 --> 00:20:07.990
But when you talk about saving as PDF,
what you're really talking

00:20:08.000 --> 00:20:10.830
about is essentially going
through the print process,

00:20:10.830 --> 00:20:14.110
the mapping of the model data
to a paginated representation,

00:20:14.120 --> 00:20:16.920
but just not sending it to any device,
just keeping that as

00:20:16.940 --> 00:20:18.710
a digital file around.

00:20:18.780 --> 00:20:21.990
And so saving the PDF,
I really conceptually think of as

00:20:21.990 --> 00:20:24.100
just printing the digital paper.

00:20:24.100 --> 00:20:27.470
And that's really the notion, I think,
that carries us the furthest in

00:20:27.490 --> 00:20:30.090
terms of how to think about this.

00:20:30.230 --> 00:20:32.210
And so what really
hasn't been said before,

00:20:32.220 --> 00:20:36.970
but I think is a really important point,
is that Mac OS X is the first commercial

00:20:36.970 --> 00:20:40.410
OS to have a system-wide standard
for digital paper that's universal.

00:20:40.470 --> 00:20:44.370
And PDF truly is universal in
terms of being able to view it.

00:20:46.040 --> 00:20:49.140
So PDF is not a great
model-level construct,

00:20:49.140 --> 00:20:54.540
and there are some cases where
maybe it's possible to encode

00:20:54.690 --> 00:20:58.780
sort of flowable text in PDF,
and this can be interesting in

00:20:58.780 --> 00:21:02.030
sort of closed-loop situations,
but basically the thing to remember

00:21:02.030 --> 00:21:05.940
here is that you are starting to
impose model-level constructs on what

00:21:05.950 --> 00:21:10.640
is essentially a view-level idea,
and if you think about a text-flow model,

00:21:10.640 --> 00:21:14.630
actually, they're quite complicated,
and a precise specification

00:21:14.640 --> 00:21:18.510
would include your styling model,
your obstacle-avoidance model,

00:21:18.510 --> 00:21:21.880
how your containers connect and flow,
a pagination model,

00:21:21.880 --> 00:21:25.060
whether you allow widows and
orphans and those kind of things,

00:21:25.060 --> 00:21:27.680
justification model,
and a hyphenation model,

00:21:27.680 --> 00:21:30.910
which is then going to require
a whole-language dictionary so

00:21:30.910 --> 00:21:32.150
you know how to break up words.

00:21:32.180 --> 00:21:37.910
So a complete specification of an
actual text flow is fairly complicated,

00:21:37.920 --> 00:21:40.720
and I think kind of beyond
the scope of what PDF,

00:21:40.720 --> 00:21:44.400
and it's certainly not a universally
agreed-to notion of how to do it.

00:21:44.640 --> 00:21:46.570
flow text.

00:21:47.500 --> 00:21:49.660
So, and the main reason I think
that's true is it kind of

00:21:49.730 --> 00:21:51.150
sacrifices the universality.

00:21:51.160 --> 00:21:54.720
I mean, the amazing thing about PDF is
that everyone agrees that

00:21:54.810 --> 00:21:59.350
it's a universally agreed-to
abstraction for marks on a page.

00:21:59.500 --> 00:22:03.220
I don't think everyone necessarily agrees
that there is one universal abstraction

00:22:03.350 --> 00:22:07.740
for global text documents or spreadsheets
or even that there should be one.

00:22:07.740 --> 00:22:11.520
So our basic idea is that models
are precisely where applications

00:22:11.740 --> 00:22:13.890
innovate and differentiate,
and we want apps to

00:22:13.890 --> 00:22:16.880
innovate and differentiate,
but just always be able to print

00:22:16.880 --> 00:22:21.440
down to a PDF because then we can
take that through the PDF workflow.

00:22:22.800 --> 00:22:26.180
So again, our strategy is basically
to use PDF as digital paper,

00:22:26.180 --> 00:22:32.400
use it as a final format of paginated
documents and also vector artwork.

00:22:32.400 --> 00:22:36.580
Use other formats such as
XML to encode model data.

00:22:36.580 --> 00:22:37.600
That's kind of our advice.

00:22:37.620 --> 00:22:40.200
I mean, that's what we do with Keynote
and other applications.

00:22:40.200 --> 00:22:43.220
And really build a rich framework
for processing this digital

00:22:43.220 --> 00:22:44.760
paper in the operating system.

00:22:44.760 --> 00:22:48.010
And encourage applications to
differentiate themselves by

00:22:48.010 --> 00:22:49.910
developing innovative models.

00:22:49.920 --> 00:22:52.390
So long live MVC separation.

00:22:52.720 --> 00:22:55.080
So that's my little talk on MVC.

00:22:55.080 --> 00:22:58.730
And let's see how that,
once we get all the applications

00:22:58.900 --> 00:23:02.520
projecting their models into PDF,
how that really benefits

00:23:02.520 --> 00:23:03.980
the graphic arts workflow.

00:23:05.500 --> 00:23:07.800
So here I've drawn a sample
graphic arts workflow.

00:23:07.800 --> 00:23:11.020
You can think of it starting
with application-dependent files,

00:23:11.200 --> 00:23:14.430
removing the application-dependence
to get to some kind of digital

00:23:14.430 --> 00:23:18.390
marks on a page representation,
and then finally going device-dependent

00:23:18.490 --> 00:23:23.460
and either rasterizing to a set
of TIFFs for CMYK separations.

00:23:23.510 --> 00:23:29.800
Basically going from device-independence
to device-dependence and

00:23:29.800 --> 00:23:30.800
application-dependence to
application-independence.

00:23:31.200 --> 00:23:32.950
So one of the traditional
ways this is done,

00:23:32.960 --> 00:23:35.980
and this is really kind of the
key that made PDF possible,

00:23:35.980 --> 00:23:39.090
is that all applications,
whether it's Word, Illustrator, Quark,

00:23:39.090 --> 00:23:40.780
whatever, can make PostScript.

00:23:40.780 --> 00:23:43.860
And what Adobe realized is that
if they can make PostScript,

00:23:43.860 --> 00:23:46.600
we can sort of rebind the
PostScript language to this format

00:23:46.660 --> 00:23:51.280
called PDF that's easier to read
and have a reader application for.

00:23:51.280 --> 00:23:57.170
And so this is kind of the workflow that
was popular when PDF initially came out.

00:23:57.700 --> 00:23:59.430
Basically everything
projected into PostScript,

00:23:59.470 --> 00:24:03.510
then you'd run a process,
a distiller process, and create your PDF,

00:24:03.510 --> 00:24:07.780
and you could maybe tune it for the
web and downsample the image or tune

00:24:07.780 --> 00:24:09.920
it for print optimization or pre-press.

00:24:11.630 --> 00:24:15.650
Now that's great, but there's really a
better way to do things,

00:24:15.660 --> 00:24:16.380
I think.

00:24:16.500 --> 00:24:20.700
I talk about creating a purposed
PDF for the web or for print,

00:24:20.750 --> 00:24:24.480
but isn't PDF itself device-independent?

00:24:24.550 --> 00:24:28.190
Suppose I create my web-optimized
PDF and later I realize I'd

00:24:28.190 --> 00:24:30.470
rather have it print-optimized.

00:24:30.490 --> 00:24:34.680
Well, then do I keep that PostScript file
around so that I can go

00:24:34.680 --> 00:24:37.300
back to it and repurpose it?

00:24:37.500 --> 00:24:41.370
Or do I keep the application file around?

00:24:41.370 --> 00:24:43.760
Then I need the application.

00:24:43.770 --> 00:24:49.350
So do we really want PS to be the
application-independent digital master?

00:24:49.500 --> 00:24:51.490
I think it's pretty
clear the answer is no.

00:24:51.490 --> 00:24:56.310
If you think about taking this picture
and just replacing the hub with PDF,

00:24:56.630 --> 00:25:01.290
that's really the architecture that
we've been going for in Mac OS X.

00:25:02.080 --> 00:25:04.880
And the nice thing about putting
PDF in the middle there is it's

00:25:04.980 --> 00:25:08.610
really a better suited kind of
digital master format than PostScript.

00:25:08.620 --> 00:25:12.340
Again, it's viewable on all these
copies of Acrobat out there,

00:25:12.340 --> 00:25:16.040
and it really can losslessly encode the
application intent since it's exactly

00:25:16.040 --> 00:25:17.710
the same imaging model as PostScript.

00:25:17.740 --> 00:25:22.970
That digital master PDF that sits in the
middle doesn't have to pass judgment on

00:25:22.970 --> 00:25:25.820
what the application is trying to draw.

00:25:25.820 --> 00:25:30.080
If the application is trying to draw
high-definition images or high-resolution

00:25:30.080 --> 00:25:36.740
images or weird color spaces,
or true type fonts or open type fonts,

00:25:36.780 --> 00:25:40.570
I don't really have to care because
I just want to record what the

00:25:40.570 --> 00:25:42.080
application is telling me to draw.

00:25:42.080 --> 00:25:46.040
And then later on,
I can purpose it out if I need to.

00:25:46.040 --> 00:25:51.720
And so the nice thing about adding PDF as
that center of the hub of just recording

00:25:51.720 --> 00:25:56.540
what the application drew is not only can
I now later make a late-binding decision

00:25:56.540 --> 00:25:59.930
whether I want to go web or print,
but I can also develop all these

00:26:00.170 --> 00:26:03.710
device-independent PDF processing
tools instead of this opaque

00:26:03.870 --> 00:26:06.200
PostScript file in the middle that
I need a language interpreter,

00:26:06.200 --> 00:26:09.600
and I can't even tell you how many pages
are in it until I execute the document.

00:26:09.600 --> 00:26:12.600
I now have a much better
device-independent representation there,

00:26:12.600 --> 00:26:15.560
and I can write little tools
that do cover page or imposition

00:26:15.580 --> 00:26:16.920
or whatever on top of that.

00:26:16.920 --> 00:26:21.460
So that's really why I think it's key
to have PDF in the center of that.

00:26:21.500 --> 00:26:25.140
And PDF processing on Mac OS X is
a pretty popular thing.

00:26:25.140 --> 00:26:30.080
There's over 50 little PDF applications,
some not so little, on Mac OS X,

00:26:30.080 --> 00:26:31.950
some from big names,
some from small names,

00:26:31.960 --> 00:26:34.320
and Panther is going to
bring new opportunities.

00:26:34.320 --> 00:26:37.310
And this is kind of one of the
thrusts with Panther on the 2D

00:26:37.320 --> 00:26:42.640
side is really getting to leverage
the possibilities with PDF.

00:26:42.640 --> 00:26:46.080
So we add a bunch of new
PDF workflow tools in Panther,

00:26:46.080 --> 00:26:50.830
addressing PostScript file handling,
user-level scripting.

00:26:50.840 --> 00:26:53.280
We have something called
Quartz PDF filters,

00:26:53.280 --> 00:26:58.000
printing to a PDF workflow,
and PDF introspection APIs.

00:26:58.000 --> 00:26:59.500
And let me go through
each of those briefly.

00:27:03.480 --> 00:27:06.970
PostScript to PDF conversion
basically allows us to deal with

00:27:07.090 --> 00:27:09.140
the PostScript legacy files,
not necessarily put

00:27:09.140 --> 00:27:11.970
PostScript in the middle,
but provide a graphically lossless

00:27:11.970 --> 00:27:14.320
transformation from PostScript to PDF.

00:27:14.320 --> 00:27:16.430
It works with EPS files as well.

00:27:16.430 --> 00:27:19.150
It's based on a real
PostScript interpreter,

00:27:19.220 --> 00:27:21.150
and it's not a replacement for Distiller.

00:27:21.150 --> 00:27:25.050
It doesn't do a lot of the finishing
options you have in Distiller.

00:27:25.050 --> 00:27:30.560
But it basically allows us to
graphically transform PostScript to PDF.

00:27:30.560 --> 00:27:33.740
The other nice thing on the printing
side is it allows us to accept

00:27:33.740 --> 00:27:36.350
PostScript jobs to any printer from,
say,

00:27:36.350 --> 00:27:39.170
a Windows client or a Mac OS 9 client.

00:27:41.210 --> 00:27:44.390
So again, back to the picture,
now PostScript can feed that hub,

00:27:44.400 --> 00:27:47.420
so we can take PostScript files,
convert them to PDF,

00:27:47.580 --> 00:27:51.050
and then have them in that hub and
subject to all the transformations

00:27:51.050 --> 00:27:56.520
that all the great PDF tools you
guys are going to write can do.

00:27:56.860 --> 00:28:00.280
Another aspect of the PostScript legacy
that was kind of lost along the

00:28:00.280 --> 00:28:05.290
way was the ability to have some
level of user-level programmability.

00:28:05.420 --> 00:28:07.660
PostScript was actually
a programming language,

00:28:07.680 --> 00:28:10.700
and some people used it to
dynamically generate graphics.

00:28:10.700 --> 00:28:13.950
So the PostScript program would
calculate the picture rather than

00:28:13.950 --> 00:28:15.940
just being the output from a driver.

00:28:16.050 --> 00:28:20.060
PDF can't really do this,
but the reverse Polish notation of

00:28:20.060 --> 00:28:24.590
PostScript and its abilities as a
language also kind of made this a bear,

00:28:24.590 --> 00:28:30.080
and this always turned out to be more
difficult than you'd like it to be.

00:28:30.120 --> 00:28:32.330
But nonetheless,
some people found this incredibly

00:28:32.340 --> 00:28:38.280
useful - the ability to have simple
scripting based down to the 2D graphics.

00:28:38.320 --> 00:28:41.390
And although I never used
PostScript as a pickup line,

00:28:41.460 --> 00:28:46.520
I found this on the web,
which I thought was pretty amusing.

00:28:46.520 --> 00:28:49.230
So what we've done actually
is take the Quartz 2D API and

00:28:49.230 --> 00:28:52.950
use a real scripting language,
Python, and to create Python bindings

00:28:52.950 --> 00:28:54.460
for the Quartz 2D API.

00:28:54.460 --> 00:28:58.470
It's basically the C language
API entry points that you can

00:28:58.570 --> 00:29:01.800
see in the Quartz header files,
but just bound into a

00:29:01.800 --> 00:29:05.620
Python interpreter with a module.

00:29:05.620 --> 00:29:08.280
And this allows simple
PDF processing from scripts.

00:29:08.300 --> 00:29:11.850
We've added some convenience
functions for dealing with QuickTime,

00:29:11.850 --> 00:29:15.870
for getting images in and out,
for dealing with Cocoa in

00:29:15.870 --> 00:29:19.410
terms of drawing HTML,
RTF, and Unicode,

00:29:19.410 --> 00:29:23.620
and also for dealing with our
PostScript to PDF converter so you

00:29:23.780 --> 00:29:26.100
can read PostScript and EPS files.

00:29:26.100 --> 00:29:27.730
So basically,
I think this is going to allow a

00:29:27.730 --> 00:29:30.500
new generation of script writers
to really write simple tools

00:29:30.620 --> 00:29:32.820
to be able to manipulate PDF.

00:29:32.840 --> 00:29:35.420
And it's really handy for small
one-off processing scripts.

00:29:35.420 --> 00:29:38.050
And one of the reasons we did this
ourselves is we had a bunch of places

00:29:38.050 --> 00:29:41.660
in the printing path where we just
need to make a simple change to the

00:29:41.670 --> 00:29:45.900
document and rather than write code,
it's just easier to do it this way.

00:29:45.900 --> 00:29:50.330
So you can imagine some examples
like rasterizing an EPS file to a

00:29:50.330 --> 00:29:54.700
bitmap and exporting it via QuickTime,
doing some advanced imposition

00:29:54.700 --> 00:29:56.650
algorithms for booklet typefaces,
and then booklet printing

00:29:56.650 --> 00:29:57.920
or something like that.

00:29:57.940 --> 00:30:00.080
Just concatenating two
PDF files together,

00:30:00.140 --> 00:30:02.700
it's pretty--a few lines of code.

00:30:02.700 --> 00:30:06.060
Adding a cover page or watermarks
to a PDF is pretty easy.

00:30:06.090 --> 00:30:08.570
Dynamically generating graphics on
a server is something I think that's

00:30:08.570 --> 00:30:11.570
going to be very interesting in
terms of being able to have all this

00:30:11.570 --> 00:30:13.610
power in a server-based application.

00:30:15.040 --> 00:30:16.680
Unlike PostScript,
you can't really override

00:30:16.690 --> 00:30:19.880
the marking operators,
you can't redefine show and show page,

00:30:20.040 --> 00:30:23.770
but for now we consider that
to be a feature because it's

00:30:23.820 --> 00:30:26.220
a little bit unmaintainable.

00:30:26.530 --> 00:30:30.160
So as an example, I actually did this,
went off and looked at the

00:30:30.160 --> 00:30:31.400
old PostScript Blue book.

00:30:31.430 --> 00:30:32.900
I don't know if any of you
guys remember that book,

00:30:33.060 --> 00:30:36.010
but there's a simple example
in there called Wedge,

00:30:36.090 --> 00:30:38.280
and it draws this little starburst here.

00:30:38.320 --> 00:30:41.980
And that's the PostScript code on the
right and the Python code on the left.

00:30:42.050 --> 00:30:47.880
Python code's a little bit longer,
but probably more readable,

00:30:47.880 --> 00:30:50.200
certainly these days.

00:30:50.200 --> 00:30:50.200
So.

00:30:50.540 --> 00:30:53.140
Next thing I'm going to mention
briefly is Quartz PDF filters.

00:30:53.140 --> 00:30:56.840
Quartz PDF filters allow us to
do some transformations on PDF,

00:30:56.840 --> 00:30:59.200
mostly dealing with color
space transformations.

00:30:59.220 --> 00:31:02.440
And you create these recipes
in the ColorSync utility.

00:31:02.440 --> 00:31:04.480
And at the ColorSync session,
they're going to demo

00:31:04.510 --> 00:31:05.610
this and talk about it.

00:31:05.680 --> 00:31:09.610
And it can be used for color conversion
effects or even just we use it in the

00:31:09.700 --> 00:31:13.950
printing path when we're going to a
black and white printer over a slow link.

00:31:14.000 --> 00:31:16.750
We want to get rid of all the color
and just bring it down to black and

00:31:16.750 --> 00:31:18.480
white before we send it over the wire.

00:31:19.100 --> 00:31:23.970
It does have some imagery sampling and
compression options built in as well.

00:31:24.710 --> 00:31:27.930
Print-to-PDF workflow - this
is something we announced back

00:31:27.940 --> 00:31:29.720
in one of the Jaguar updates.

00:31:29.720 --> 00:31:34.760
It allows you to extend the print panel,
again leveraging print as the hub

00:31:34.760 --> 00:31:37.600
of where PDF workflow takes off.

00:31:37.600 --> 00:31:41.840
And basically that "Save as PDF"
button in the print panel can grow

00:31:41.840 --> 00:31:46.230
to any number of options that the
user wants in terms of applications

00:31:46.300 --> 00:31:48.220
that can open and deal with PDF.

00:31:48.640 --> 00:31:50.340
For example,
you could send the PDF off to

00:31:50.340 --> 00:31:53.000
Illustrator and work on it,
or send it to Mail to bring

00:31:53.000 --> 00:31:56.460
it up in a Compose window,
or Encrypted, or whatever.

00:31:56.780 --> 00:32:00.460
So this is a great place to
hook in if you're writing a

00:32:00.470 --> 00:32:03.040
little PDF processing tool,
and some of you guys

00:32:03.040 --> 00:32:07.410
have already done this,
a great way to leverage into the system.

00:32:07.570 --> 00:32:12.140
And lastly, our PDF introspection APIs,
which are new APIs in Panther which

00:32:12.140 --> 00:32:16.580
allow you to have complete access
to the PDF document structure

00:32:16.580 --> 00:32:18.810
as kind of the tree of objects.

00:32:18.880 --> 00:32:23.110
It basically models the dictionaries,
streams, strings,

00:32:23.110 --> 00:32:26.100
arrays that are in the PDF file itself.

00:32:26.480 --> 00:32:29.470
It doesn't go and model the
internal of the graphic streams,

00:32:29.470 --> 00:32:32.180
but it is useful for
extracting things like links,

00:32:32.180 --> 00:32:35.460
annotations,
and metadata and stuff like that.

00:32:36.010 --> 00:32:37.320
So enough talking for now.

00:32:37.320 --> 00:32:41.460
Let's bring Ralph up to the
stage and give you a demo of some

00:32:41.530 --> 00:32:47.900
of the stuff we have as far as
PDF processing in preview in Panther.

00:32:47.900 --> 00:32:48.380
Welcome, Ralph.

00:32:48.440 --> 00:32:52.340
Ralph Bezir: Hello.

00:32:53.910 --> 00:32:58.140
So what I'm going to show you
first is preview in Panther,

00:32:58.140 --> 00:33:01.720
which makes use of these new
PDF introspection APIs that

00:33:01.870 --> 00:33:03.640
Peter was mentioning.

00:33:03.760 --> 00:33:05.600
So I'm opening a PDF document here.

00:33:05.600 --> 00:33:08.210
It's one of my favorite documents.

00:33:08.330 --> 00:33:12.840
And it has a table of content
information embedded in the file.

00:33:12.910 --> 00:33:17.750
And in Panther, if that's the case,
then the drawer to the right pops open

00:33:17.750 --> 00:33:20.630
and shows you the table of contents.

00:33:20.720 --> 00:33:23.350
You can navigate through
chapters and see,

00:33:23.500 --> 00:33:27.790
for example, all the instructions that
the Velocity Engine has.

00:33:27.980 --> 00:33:29.680
Click on one of them.

00:33:29.750 --> 00:33:32.320
And, well, there's the back floor.

00:33:32.980 --> 00:33:38.560
But similarly,
we also added search for PDFs.

00:33:38.560 --> 00:33:43.200
So I can actually look for string not,
oops.

00:33:44.400 --> 00:33:55.000
[Transcript missing]

00:33:57.780 --> 00:34:03.300
Well, one thing that Peter was mentioning
is the PostScript to PDF conversion.

00:34:03.300 --> 00:34:06.660
And what I'm going to do is
I essentially just double click a

00:34:06.780 --> 00:34:09.620
PostScript document from Finder,
and the PostScript to

00:34:09.710 --> 00:34:14.720
PDF conversion kicks in,
and it will open in preview briefly.

00:34:14.750 --> 00:34:16.360
Yes, here it is.

00:34:16.360 --> 00:34:20.350
So what you see here...

00:34:23.650 --> 00:34:25.770
This is a paper I got from the internet.

00:34:25.890 --> 00:34:26.590
It's in PostScript.

00:34:26.600 --> 00:34:28.960
It just got converted.

00:34:29.060 --> 00:34:32.340
Text is there, line art is there,
all the mathematical formulas are there,

00:34:32.340 --> 00:34:35.180
so pretty much what you would expect.

00:34:35.380 --> 00:34:38.420
And because it's now PDF,
all those tools we have to

00:34:38.420 --> 00:34:42.040
work with PDFs now work on the
converted Postgres file as well.

00:34:42.040 --> 00:34:45.500
So, for example,
I can go and search for the word

00:34:45.500 --> 00:34:48.300
"image". Let me zoom in here.

00:34:48.300 --> 00:34:52.380
And it actually highlights it for you.

00:34:55.200 --> 00:34:58.540
And one of the coolest things, I think,
is you can even go and

00:34:58.690 --> 00:35:00.540
copy-paste out of the document.

00:35:00.540 --> 00:35:02.600
Like, I select a paragraph here.

00:35:02.820 --> 00:35:06.270
Copy.

00:35:07.920 --> 00:35:11.900
And I get a text representation
of the part I just copied out.

00:35:11.900 --> 00:35:15.640
Okay.

00:35:16.510 --> 00:35:20.160
Next thing I would like to
show you is part scripting.

00:35:20.270 --> 00:35:23.680
What I have here is a
Python script that - well,

00:35:23.700 --> 00:35:25.740
let's just go through it.

00:35:26.330 --> 00:35:29.700
It opens a PDF file,
an existing PDF file,

00:35:29.700 --> 00:35:32.040
and it creates a new PDF file.

00:35:32.060 --> 00:35:34.740
And then it enumerates all
the pages in the PDF file,

00:35:34.870 --> 00:35:38.980
gets the size of the particular page,
creates a new page in the output file,

00:35:39.110 --> 00:35:42.430
and just draws the content of the
original page into the output file.

00:35:42.490 --> 00:35:44.970
So, so far we didn't really
do anything exciting,

00:35:45.030 --> 00:35:46.930
it's pretty much a copy operation.

00:35:47.320 --> 00:35:48.930
And then we add some custom drawing.

00:35:49.020 --> 00:35:53.140
In this case, we add red text to the
margin of the page.

00:35:53.250 --> 00:35:55.320
Once we're done with it,

00:35:55.490 --> 00:36:00.450
We tell the system to open that file with
the default PDF viewer of the system.

00:36:01.320 --> 00:36:05.320
So what I'm going to do now is - well,
let me tell you first.

00:36:05.390 --> 00:36:08.520
If you put that script into
the PDF services folder,

00:36:08.550 --> 00:36:12.050
then it will appear in the print
panel as Peter was showing.

00:36:12.260 --> 00:36:15.910
So if I go to the print panel,
where is it?

00:36:19.000 --> 00:36:20.000
It takes a second.

00:36:20.170 --> 00:36:24.110
So I'm going to print this script,
and I'm going to print

00:36:24.160 --> 00:36:25.890
it through the script.

00:36:26.280 --> 00:36:29.700
So it's kind of an
Azure-esque thing to do.

00:36:29.770 --> 00:36:31.540
So let's see.

00:36:33.150 --> 00:36:34.100
And there it is.

00:36:34.100 --> 00:36:38.660
So I have to print out the script and it
added that confidential mark on the side.

00:36:43.420 --> 00:36:46.000
So just to make that
point perfectly clear,

00:36:46.000 --> 00:36:47.810
this works with everything.

00:36:47.910 --> 00:36:51.340
So I can take my PostScript file
I just had before,

00:36:51.340 --> 00:36:53.760
print it through the script.

00:36:54.300 --> 00:37:05.600
[Transcript missing]

00:37:10.100 --> 00:37:14.110
So for all of those of you who
have your theses locked away in .ps

00:37:14.110 --> 00:37:18.130
files that you can't read anymore,
you can search them there.

00:37:18.190 --> 00:37:20.400
I know a few people like that.

00:37:21.390 --> 00:37:24.440
Okay, so Quartz and PDF summary.

00:37:24.570 --> 00:37:27.200
PDF really provides
Mac OS X with a universal

00:37:27.200 --> 00:37:29.010
representation of digital paper.

00:37:29.120 --> 00:37:32.760
We plan to leverage that a lot more
in the operating system and hopefully

00:37:32.760 --> 00:37:36.300
build lots of opportunities for
you guys as well to process PDF.

00:37:36.300 --> 00:37:41.330
And our strategy is really to continue to
build on it as a view-level abstraction,

00:37:41.330 --> 00:37:44.300
final form presentation metaphor for PDF.

00:37:44.300 --> 00:37:48.040
And I hope we've convinced you that in
Panther we're adding a lot of really

00:37:48.040 --> 00:37:50.240
significant tools to the PDF toolset.

00:37:50.300 --> 00:37:53.190
And as my last comment,
I'd say if you're still

00:37:53.190 --> 00:37:56.300
thinking Pixmaps and GWorlds,
come join the Quartz 2D party.

00:37:56.300 --> 00:37:58.300
Go to the sessions, learn about it.

00:37:58.300 --> 00:38:00.300
It's pretty fun stuff.

00:38:00.860 --> 00:38:04.700
That's it for the PDF and
Quartz 2D session.

00:38:04.700 --> 00:38:07.620
I'm going to change gears a little
bit now and talk about another

00:38:08.030 --> 00:38:09.700
development in the industry.

00:38:09.700 --> 00:38:12.190
This one's much bigger than Apple.

00:38:12.200 --> 00:38:13.540
It's going on right now.

00:38:13.540 --> 00:38:19.970
I'm going to call that the
GPU computing revolution.

00:38:20.430 --> 00:38:24.050
There's really something going on now
in terms of the ability of graphics

00:38:24.060 --> 00:38:31.090
processors to compute graphics at
much higher rates than even CPUs can.

00:38:33.900 --> 00:40:17.700
[Transcript missing]

00:40:18.300 --> 00:44:20.800
[Transcript missing]

00:44:22.440 --> 00:44:25.640
Then the fragments are processed,
so we apply texture mapping,

00:44:25.640 --> 00:44:29.330
we calculate what the final
color in Z for that particular

00:44:29.390 --> 00:44:32.330
pixel is going to be,
and then the last step

00:44:32.430 --> 00:44:34.970
is fragment rendering,
where we do the Z check

00:44:34.970 --> 00:44:38.860
against the frame buffer,
we do alpha blending, compositing, fog,

00:44:38.870 --> 00:44:40.410
those kinds of things.

00:44:40.710 --> 00:44:42.450
And so that's the whole
graphics pipeline,

00:44:42.460 --> 00:44:46.100
and this is sort of the
way it's been for a while.

00:44:48.290 --> 00:44:53.240
And what's happening is the GPU vendors
are opening up these two parts of the

00:44:53.400 --> 00:44:56.000
graphics processor as being programmable.

00:44:56.100 --> 00:45:00.390
So you can think of that little
stream execution unit kind of getting

00:45:00.400 --> 00:45:04.040
plugged into the vertex processing
and fragment processing areas.

00:45:04.160 --> 00:45:07.320
So when you hear those terms,
that's really what's going on.

00:45:07.320 --> 00:45:09.680
You have a little,
a small little data flow engine

00:45:09.680 --> 00:45:14.500
that can do a small calculation
per vertex or per fragment.

00:45:14.700 --> 00:45:17.720
When I talk about fragments,
I also sometimes talk about pixels,

00:45:17.720 --> 00:45:20.250
so I think sometimes it's
easier for people who are new

00:45:20.250 --> 00:45:23.600
to 3D to think about pixels,
and that's okay with me.

00:45:23.600 --> 00:45:26.600
So I'm going to talk
about pixel programming.

00:45:26.600 --> 00:45:31.540
So pixel programming uses a
data model similar to AltaVec.

00:45:31.670 --> 00:45:35.600
The programmable units operate on
128-bit four vectors of floats.

00:45:35.940 --> 00:45:38.600
Obviously, your texture lookups may
come from 8-bit data,

00:45:38.600 --> 00:45:40.600
but it's all expanded for
you into the floating point.

00:45:40.600 --> 00:45:44.820
And you basically get to write a small
program that's executed per pixel to

00:45:45.150 --> 00:45:47.600
calculate the result of the output pixel.

00:45:47.600 --> 00:45:49.560
So you don't get control over
the blending and the Z test

00:45:49.560 --> 00:45:52.940
and all that sort of stuff,
but you can get total control over

00:45:53.010 --> 00:45:55.300
the source color of the pixel.

00:45:55.430 --> 00:46:01.290
You get access to the iterated values,
so those little, the vertex attributes at

00:46:01.290 --> 00:46:03.380
the corners of the triangle.

00:46:03.380 --> 00:46:05.940
You get access to what that
value is for the particular

00:46:05.940 --> 00:46:07.240
picture that you're drawing.

00:46:07.240 --> 00:46:08.860
You can look in some global data.

00:46:08.860 --> 00:46:11.260
You can look at,
do memory reads off of textures.

00:46:11.260 --> 00:46:13.210
You can't look at the
destination picture.

00:46:13.210 --> 00:46:15.960
You can't know what
you're going to draw to.

00:46:16.080 --> 00:46:18.870
You just leave your output
in a special result register.

00:46:18.870 --> 00:46:21.660
And there's a lot of
powerful ALU instructions,

00:46:21.660 --> 00:46:26.800
like power, reciprocal square root,
cross product, all these kind of things,

00:46:26.800 --> 00:46:30.770
and a bunch of swizzling
instructions for changing order

00:46:30.770 --> 00:46:33.420
on the data units and the vectors.

00:46:33.420 --> 00:46:34.520
So this is pseudo code.

00:46:34.520 --> 00:46:37.880
This is not in any particular language,
just to try to communicate the

00:46:37.890 --> 00:46:43.720
simplicity and the job of a pixel
program or a fragment program.

00:46:43.750 --> 00:46:46.800
Basically, they all have the same
function signature.

00:46:46.800 --> 00:46:50.900
Calculate pixel, returns a result,
gets the iterated values,

00:46:50.900 --> 00:46:53.080
and it can do whatever
computation it wants.

00:46:53.170 --> 00:46:55.760
It has access to some global constants,
as read only,

00:46:55.760 --> 00:46:58.720
and a global set of textures
that it can go look up values in.

00:46:58.750 --> 00:47:00.200
And that's really all it does.

00:47:00.260 --> 00:47:00.260
1

00:47:02.230 --> 00:47:04.920
Now I'm going to explain to
you why I think that once you

00:47:05.030 --> 00:47:08.760
constrain the problem like that,
you can make it go real fast,

00:47:08.900 --> 00:47:12.860
and why GPU designers kind of have
this advantage with the parallelism.

00:47:12.900 --> 00:47:14.710
So this isn't how any
particular chip works,

00:47:14.900 --> 00:47:18.680
but just how if you've constrained
the calculation like that,

00:47:18.760 --> 00:47:21.530
how you might be able to design
hardware to make it go fast.

00:47:21.640 --> 00:47:25.940
So first let's consider just a four
instruction-long fragment program,

00:47:26.220 --> 00:47:29.200
and I have one vector unit right now,
so I'm going to just do

00:47:29.320 --> 00:47:30.920
sequential processing through it.

00:47:30.990 --> 00:47:33.700
I'm going to send my fragment
values into the vector unit,

00:47:33.900 --> 00:47:38.190
and then basically clock
the instructions through.

00:47:58.990 --> 00:47:59.000
So, I'm basically doing one
operation per clock.

00:47:59.000 --> 00:47:59.000
I'm able to keep the
processor busy every cycle,

00:47:59.000 --> 00:47:59.000
and I get one result every four clocks.

00:47:59.000 --> 00:47:59.000
So, no big news there.

00:47:59.000 --> 00:47:59.000
That's just sequential processing.

00:47:59.930 --> 00:48:03.460
Now there's a lot of data level
parallelism in this problem.

00:48:03.460 --> 00:48:05.520
Pixel calculations,
because of the way fragment

00:48:05.640 --> 00:48:07.900
programs are constructed,
are independent.

00:48:08.070 --> 00:48:11.480
So the result pixel at a particular
location can't depend on the

00:48:11.480 --> 00:48:13.600
result pixel at another location.

00:48:13.600 --> 00:48:16.190
The pixel calculations can
basically execute in parallel.

00:48:16.190 --> 00:48:19.220
So call this parallelism in space,
because it's kind of in

00:48:19.300 --> 00:48:20.680
the plane of the triangle.

00:48:20.800 --> 00:48:26.590
What I can do here is just replicate
the fragment execution unit in width

00:48:26.590 --> 00:48:32.330
and just do the same instruction
on multiple vectors at one time.

00:48:32.340 --> 00:48:34.800
So here's how I might have that laid out.

00:48:34.800 --> 00:48:36.220
Now I have eight vector units.

00:48:36.270 --> 00:48:42.420
I can feed in simultaneously eight
fragment values into the pipeline.

00:48:44.320 --> 00:48:50.020
and then basically sequence through
my instructions one at a time and

00:48:50.020 --> 00:48:52.190
at the end get my eight results out.

00:48:52.300 --> 00:48:54.390
So that gives us eight
vector operations per clock.

00:48:54.500 --> 00:48:57.130
We're able to keep all eight
of those busy every clock.

00:48:57.200 --> 00:49:01.200
We get eight results every four clocks
because it's four instructions long.

00:49:01.380 --> 00:49:05.540
So on average,
throughput of two pixels per clock.

00:49:06.810 --> 00:49:08.700
But wait, there's more.

00:49:08.700 --> 00:49:10.940
Instruction-level
parallelism is also true,

00:49:10.940 --> 00:49:12.210
because again, we're constrained.

00:49:12.260 --> 00:49:14.590
We can't really write to any memory.

00:49:14.720 --> 00:49:17.750
The machine state's only going to
differ between one instruction and

00:49:17.770 --> 00:49:21.140
the next by the register that was
written to in the previous instruction.

00:49:21.300 --> 00:49:26.310
So you can imagine compilation
techniques or even maybe some hardware

00:49:26.310 --> 00:49:31.420
register renaming techniques coming
into place to just build a little

00:49:31.420 --> 00:49:36.260
pipeline out of - or assembly line
out of a sequence of instructions.

00:49:36.470 --> 00:49:37.600
So let's look at how that might work.

00:49:37.600 --> 00:49:40.040
Now we're going to line up
the vector units in time,

00:49:40.190 --> 00:49:44.140
and basically I'm going to teach each
vector unit about an instruction.

00:49:44.220 --> 00:49:48.160
So vector unit one gets instruction one,
vector unit two gets instruction two,

00:49:48.190 --> 00:49:48.880
and so on.

00:49:48.900 --> 00:49:51.460
And now I'm going to feed my
fragment value in the top,

00:49:51.480 --> 00:49:54.540
operate on it with instruction
one in the first vector unit,

00:49:54.570 --> 00:49:56.640
move it on to instruction unit two.

00:49:56.680 --> 00:49:59.830
Meanwhile I feed the next fragment
value into vector unit one and

00:49:59.890 --> 00:50:02.050
kind of keep the pipeline full.

00:50:02.240 --> 00:50:06.030
And once the pipeline is full,
I'm really just processing, again,

00:50:06.030 --> 00:50:09.050
keeping all the units
busy at the same time.

00:50:09.210 --> 00:50:12.080
And so now I'm fully
utilizing all my four units,

00:50:12.130 --> 00:50:15.330
four operations per clock,
and I'm getting one result every

00:50:15.330 --> 00:50:18.760
clock once the operation is full.

00:50:19.000 --> 00:50:22.280
So obviously the next thing, no surprise,
I can put both of these things together

00:50:22.610 --> 00:50:27.460
and basically exploit the time and
the space dimension at the same time.

00:50:27.550 --> 00:50:32.110
So I just get a bigger chip,
drag out more vector units,

00:50:32.110 --> 00:50:37.780
and make sort of a 32 element fabric
where I've got them four by eight

00:50:37.780 --> 00:50:40.140
just for illustration purposes.

00:50:40.190 --> 00:50:43.770
And now basically I can feed, you know,
teach each row about

00:50:43.770 --> 00:50:46.490
a single instruction,
feed the fragments in,

00:50:46.520 --> 00:50:50.820
fill up the pipeline,
and then basically get eight results per

00:50:50.820 --> 00:50:55.750
clock with doing 32 operations per clock.

00:50:55.810 --> 00:50:58.510
So eight results per clock.

00:50:59.010 --> 00:51:02.020
So I think you can see
that as time goes on,

00:51:02.020 --> 00:51:05.790
and maybe today is number 32,
tomorrow the number is 64,

00:51:05.790 --> 00:51:10.830
you're not going to run out of gas in
the time dimension until the average

00:51:10.870 --> 00:51:13.250
size of a triangle you begin to approach.

00:51:13.390 --> 00:51:16.440
Which for image processing things
where you're rendering big triangles,

00:51:16.440 --> 00:51:18.140
there's lots of parallel fragments.

00:51:18.170 --> 00:51:20.650
And in space,
this is only a four instruction program,

00:51:20.650 --> 00:51:24.080
you can obviously imagine
much longer instructions.

00:51:24.120 --> 00:51:27.370
So there's a lot of headroom
just in terms of parallelism.

00:51:27.560 --> 00:51:29.800
So basically my argument
is it will sustain,

00:51:29.800 --> 00:51:32.410
and I think the chip capabilities
certainly hasn't peaked.

00:51:32.530 --> 00:51:35.280
I think the parallel computing
possibilities haven't even

00:51:35.280 --> 00:51:36.710
come close to peaking yet.

00:51:36.810 --> 00:51:40.210
We've got sort of 8x4 as I drew here,
and I think there's still

00:51:40.280 --> 00:51:42.120
lots of headroom for that.

00:51:42.280 --> 00:51:46.360
And I think the entertainment industry
is going strong and has not peaked.

00:51:46.360 --> 00:51:48.920
And as operating systems and
applications get into the game,

00:51:49.000 --> 00:51:53.820
I think we're just going to add fuel to
this fire and really have an interesting

00:51:54.320 --> 00:52:00.250
world where people are doing massively
parallel computations on the GPU to free

00:52:00.350 --> 00:52:03.460
up their CPU to do other stuff as well.

00:52:05.110 --> 00:52:07.390
So you might ask yourself,
"That sounds great.

00:52:07.400 --> 00:52:11.560
How do I do it?" And the
answer is you use OpenGL.

00:52:11.560 --> 00:52:15.560
In Panther, we have standard cross-vendor
programming languages at both the

00:52:15.640 --> 00:52:17.740
vertex level and the fragment level.

00:52:17.770 --> 00:52:20.960
Those begin with the ARB prefix,
which is the architecture

00:52:20.960 --> 00:52:23.630
review board for OpenGL,
so you don't have to learn

00:52:23.730 --> 00:52:25.680
vendor-specific extensions.

00:52:25.730 --> 00:52:28.090
There are higher-level
language being worked on,

00:52:28.090 --> 00:52:29.620
and those will come out as well.

00:52:29.750 --> 00:52:32.150
But assembly-level language
will always be available,

00:52:32.150 --> 00:52:34.280
and I think these
architectures are so new.

00:52:34.320 --> 00:52:38.090
We found you get rid of one temporary,
and the thing runs twice as fast.

00:52:38.300 --> 00:52:39.960
So people are probably going
to be tweaking assembly on

00:52:40.000 --> 00:52:41.400
these things for a while.

00:52:41.460 --> 00:52:45.520
Programs are relatively small,
so maybe that's not a big deal.

00:52:45.580 --> 00:52:49.670
But the higher-level
languages are coming as well.

00:52:49.870 --> 00:52:53.710
So, without further ado,
let's bring Ralph back up and

00:52:53.710 --> 00:52:56.120
show you some Fragment programs.

00:52:56.280 --> 00:53:02.540
We've got a Radeon 9700 plugged
into this machine over here,

00:53:02.540 --> 00:53:05.500
which is running our Fragment program.

00:53:06.390 --> 00:53:07.180
Go ahead, Raoul.

00:53:07.220 --> 00:53:08.500
Okay.

00:53:08.600 --> 00:53:11.900
So the first thing I'm going to show
you is the OpenGL Shader Builder

00:53:11.900 --> 00:53:14.610
application that is in Pantor.

00:53:14.800 --> 00:53:17.480
And well, you see it here.

00:53:17.480 --> 00:53:20.150
On the left side,
you have your little fragment program,

00:53:20.150 --> 00:53:24.380
and on the right side,
you have a very complex OpenGL scene,

00:53:24.460 --> 00:53:28.230
which consists of a single rectangle.

00:53:28.610 --> 00:53:32.610
So that rectangle has a texture on it,
and there's actually a fragment

00:53:32.700 --> 00:53:36.100
program running right now
that does that texturing.

00:53:36.110 --> 00:53:40.420
So if you look on the left side,
what this fragment program does,

00:53:40.420 --> 00:53:45.680
it goes to the texture zero,
uses the current texture coordinate

00:53:45.790 --> 00:53:50.600
to look up the color at that point,
and then copies that color to the result.

00:53:50.770 --> 00:53:53.820
So you get a textured quad.

00:53:53.850 --> 00:53:56.960
Well, this isn't terribly exciting
because non-programmable hardware

00:53:56.970 --> 00:54:00.380
does exactly that for you,
so there's no point to

00:54:00.470 --> 00:54:01.820
actually write this program.

00:54:01.850 --> 00:54:05.180
But we can go and modify it a bit.

00:54:05.280 --> 00:54:08.700
So for example,
instead of copying the color back

00:54:08.700 --> 00:54:14.230
to the destination pixel unmodified,
I can say, well, only copy the green

00:54:14.230 --> 00:54:15.690
and the alpha channel.

00:54:15.760 --> 00:54:18.140
And, well,
the red and the blue channels are lost,

00:54:18.250 --> 00:54:19.770
so you see the result here.

00:54:19.820 --> 00:54:23.820
It is this rather unhealthy-looking cat.

00:54:25.050 --> 00:54:28.830
Okay, so let's add an instruction
in the middle here.

00:54:28.860 --> 00:54:33.260
After we did the texture lookup,
we take the red component

00:54:33.310 --> 00:54:36.550
of the color and square it,
and then copy that to green

00:54:36.550 --> 00:54:40.000
and blue to produce some kind
of a sapient tone effect.

00:54:40.020 --> 00:54:41.640
But it doesn't look right.

00:54:41.770 --> 00:54:43.680
So let's tweak the exponent a bit.

00:54:43.680 --> 00:54:51.050
Let's say we take that one to the fifth,
yeah, one point two, something like this,

00:54:51.050 --> 00:54:52.130
until you have the look you're going for.

00:54:52.560 --> 00:54:56.490
Now what you noticed is whenever
I type in the background,

00:54:56.620 --> 00:55:02.530
the program is compiled and run
and shown to you right away.

00:55:02.530 --> 00:55:04.640
So you get immediate feedback
what your program does,

00:55:04.850 --> 00:55:09.230
which is very nice to experiment
and to get into things.

00:55:10.430 --> 00:55:12.390
Okay, that's it for Shader Builder.

00:55:12.390 --> 00:55:14.830
Now that I've shown you what you
can do with three instructions,

00:55:14.830 --> 00:55:17.300
let me show you what you can do if
you put a bit more effort into things.

00:55:20.590 --> 00:55:26.250
Okay, so by the way,
this picture has been called Demo Monkey,

00:55:26.250 --> 00:55:28.620
and so have I.

00:55:31.790 --> 00:55:34.480
So the first thing I'm going to
show you is a motion blur effect

00:55:34.600 --> 00:55:37.170
implemented as a fragment program.

00:55:37.170 --> 00:55:40.210
The interface is essentially
I click somewhere and drag

00:55:40.320 --> 00:55:43.910
the mouse in some direction,
and I get a motion

00:55:43.910 --> 00:55:45.700
blur in that direction.

00:55:45.700 --> 00:55:50.700
So the first thing you notice,
it's pretty smooth frame rate.

00:55:52.590 --> 00:55:58.950
And really the GL operations,
the GL commands that are going on

00:55:58.950 --> 00:56:03.790
here is there are four vertices,
four corners of that big rectangle,

00:56:03.890 --> 00:56:05.000
and then it says draw.

00:56:05.000 --> 00:56:07.780
So how you run your fragment
program is you draw a rectangle,

00:56:07.780 --> 00:56:08.620
essentially.

00:56:08.620 --> 00:56:11.800
And then for every pixel,
the fragment program gets

00:56:11.880 --> 00:56:13.820
executed to do that effect.

00:56:14.820 --> 00:56:18.390
So another effect we
tried is an axial blur,

00:56:18.400 --> 00:56:18.840
like this.

00:56:18.840 --> 00:56:23.860
And you can set the focus point
to wherever you want it to be,

00:56:23.860 --> 00:56:25.010
like this.

00:56:27.170 --> 00:56:31.590
So because what the CPU does
here is really negligible.

00:56:31.620 --> 00:56:35.000
I mean, it says, you know,
here are four vertices, go.

00:56:35.000 --> 00:56:37.290
And from then on it just waits
until the result is done.

00:56:37.300 --> 00:56:41.360
So this is pretty much, this is a very,
very nice effect that is

00:56:41.360 --> 00:56:45.940
fairly expensive to compute,
but it has pretty much zero CPU cost.

00:56:47.780 --> 00:56:51.740
Let me show you a different one,
a glass distortion effect.

00:56:51.740 --> 00:56:54.290
So you can make the bumps
bigger and smaller and

00:56:54.360 --> 00:56:56.800
actually move the glass around.

00:56:56.800 --> 00:56:59.790
Like this.

00:57:05.550 --> 00:57:11.000
The last effect I would like to
show is like an emboss effect.

00:57:11.050 --> 00:57:14.370
So what this does is it takes
the picture we had before

00:57:14.460 --> 00:57:18.120
and interprets the brightness
values as hills and valleys in,

00:57:18.120 --> 00:57:23.500
you know, like some kind of relief thing,
and then puts a spotlight on it.

00:57:23.650 --> 00:57:30.070
So you can actually go and
drag the spotlight around.

00:57:30.070 --> 00:57:30.070
Like this.

00:57:31.980 --> 00:57:35.700
"Make the beam wider, narrower,
things like that.

00:57:35.700 --> 00:57:38.590
And again,
you have to do that in a while to

00:57:38.590 --> 00:57:41.240
realize you don't use any CPU at all.

00:57:41.240 --> 00:57:45.130
The only thing the CPU does
is update the sliders."

00:57:47.550 --> 00:57:53.320
Okay, I think that's it for
the Fragment Program.

00:57:56.910 --> 00:58:00.340
Thanks, Ralph.

00:58:00.500 --> 00:58:05.480
So in summary,
for this section of the GPU talk,

00:58:05.620 --> 00:58:09.410
I really hope I've convinced you
that GPUs for certain classes of data

00:58:09.410 --> 00:58:13.820
parallel workloads and algorithms
really have an advantage over CPUs.

00:58:13.820 --> 00:58:16.940
And I think that this advantage
is going to be sustainable for

00:58:16.940 --> 00:58:18.880
at least the foreseeable future.

00:58:19.110 --> 00:58:22.810
And you can use this access
to this power via OpenGL.

00:58:23.270 --> 00:58:28.260
And my advice to you is learn how to do
this stuff before your competitors do.

00:58:28.270 --> 00:58:31.710
Because there's some pretty cool
things that are going to be happening.

00:58:33.300 --> 00:58:36.260
So the last section I'm going
to talk about today is another

00:58:36.260 --> 00:58:40.300
effort we've been working on,
which is Quartz 2D on OpenGL.

00:58:41.520 --> 00:58:47.140
Quartz 2D on OpenGL basically accelerates
Quartz 2D by turning it into GL calls,

00:58:47.220 --> 00:58:50.940
and it's really the logical
next step after Quartz Extreme.

00:58:51.030 --> 00:58:54.000
It ties together the two key
thrusts we've talked about today

00:58:54.000 --> 00:58:59.460
of programming the graphics
processor and PDF/2D implementation.

00:58:59.460 --> 00:59:01.190
And in Panther,
we're going to have an initial

00:59:01.190 --> 00:59:04.550
implementation of this that really
focuses mostly for GL developers who

00:59:04.890 --> 00:59:08.800
want to get high-quality text and
line art into their applications,

00:59:08.820 --> 00:59:11.300
which has always been a really
difficult thing to do with GL.

00:59:11.400 --> 00:59:12.430
Okay.

00:59:13.110 --> 00:59:16.430
So the way that you do this is you
take your GL context and you pass it

00:59:16.430 --> 00:59:19.220
to a function called cgGLContextCreate.

00:59:19.280 --> 00:59:22.530
You give the size of the
CG context you want and the color

00:59:22.540 --> 00:59:25.430
space you want to render into,
and you just make CG calls

00:59:25.440 --> 00:59:27.210
on that CG context ref.

00:59:27.260 --> 00:59:29.360
It's high-quality 2D rendering.

00:59:29.360 --> 00:59:32.240
It's virtually identical
to software quality.

00:59:32.240 --> 00:59:35.440
We do use the alpha
blending in the hardware,

00:59:35.440 --> 00:59:36.380
so it's not pixel.

00:59:36.380 --> 00:59:39.200
The values aren't going
to be exactly the same,

00:59:39.200 --> 00:59:41.780
but it basically looks
indistinguishable from software.

00:59:43.050 --> 00:59:45.490
And it's anywhere from 2 to
10 times faster than Quartz

00:59:45.490 --> 00:59:47.060
2D's software rendering.

00:59:47.060 --> 00:59:51.980
The way it gets to be on the order of
10 times faster is when we can actually

00:59:51.980 --> 00:59:53.650
cache things in the graphics unit.

00:59:53.660 --> 00:59:59.040
So we'll cache fonts, glyphs as textures.

00:59:59.040 --> 01:00:03.420
And if you hold on to your CG image
refs or CG pattern refs and reuse them,

01:00:03.420 --> 01:00:06.320
the implementation will cache
those in video memory as well.

01:00:06.320 --> 01:00:09.550
So you can draw very quickly with that.

01:00:11.630 --> 01:00:15.800
The reason we're kind of calling
it an initial implementation right

01:00:15.810 --> 01:00:19.010
now is because there are certain
Quartz 2D operations that are not

01:00:19.070 --> 01:00:20.510
yet supported by this context.

01:00:20.580 --> 01:00:23.090
For one thing,
we can't do the high quality LCD text

01:00:23.210 --> 01:00:26.920
that we have in the system without
relying on fragment programming.

01:00:26.920 --> 01:00:30.340
And since fragment programming is
kind of at the high end right now and

01:00:30.340 --> 01:00:34.370
it's coming down through the system,
we can't really kind of turn on Quartz

01:00:34.430 --> 01:00:36.940
2D acceleration everywhere right now.

01:00:36.940 --> 01:00:38.820
The other thing is the
PDF 1.4 blend modes,

01:00:38.820 --> 01:00:41.080
which are also going to
require fragment programming.

01:00:41.080 --> 01:00:44.020
We also,
you have to be using the Core Graphics

01:00:44.080 --> 01:00:46.720
API only or the Quartz 2D API only.

01:00:46.720 --> 01:00:50.060
You can't turn around and draw
some quick draw with this thing.

01:00:50.060 --> 01:00:52.260
You can't ask for the
locking the port bits.

01:00:52.260 --> 01:00:55.530
And you can't use high level
frameworks on this context.

01:00:55.550 --> 01:00:58.660
So you pretty much have to be going
right at it with the Quartz 2D API.

01:00:58.660 --> 01:01:01.000
We do require Quartz
Extreme capable hardware,

01:01:01.020 --> 01:01:03.070
so we have the non-power
of two texturing,

01:01:03.070 --> 01:01:06.300
which is important for drawing
images and things like that.

01:01:06.340 --> 01:01:09.610
And generally,
as this path becomes available,

01:01:09.610 --> 01:01:13.330
I think applications,
are going to have to revisit some of

01:01:13.340 --> 01:01:18.360
their assumptions about the cheapness
of accessing the drawing buffer,

01:01:18.360 --> 01:01:19.320
the window buffer.

01:01:19.360 --> 01:01:23.730
So it's another thing to be aware
of in your usage model if you want

01:01:23.730 --> 01:01:25.790
to use this kind of acceleration.

01:01:25.840 --> 01:01:30.840
So the basic way I tell this story is
that having a wide pipe is really great,

01:01:30.850 --> 01:01:35.340
but it also increases the cost
of reading back pixels and

01:01:35.360 --> 01:01:36.380
turning everything around.

01:01:36.480 --> 01:01:38.980
So if you imagine you're on a
little stream towards the frame

01:01:38.980 --> 01:01:41.030
buffer and you drop a few pixels in,
and you realize you want them back,

01:01:41.060 --> 01:01:41.060
you're going to have
to go back and forth.

01:01:41.060 --> 01:01:41.190
So if you imagine you're on a
little stream towards the frame

01:01:41.190 --> 01:01:41.350
buffer and you drop a few pixels in,
and you realize you want them back,

01:01:41.350 --> 01:01:41.560
you're going to have
to go back and forth.

01:01:41.600 --> 01:01:44.340
Yeah, maybe you can just reach down
the stream and grab them,

01:01:44.360 --> 01:01:46.700
but if you drop them over
the top of Niagara Falls,

01:01:46.780 --> 01:01:49.150
we've got to stop the falls,
let all the water fall down,

01:01:49.240 --> 01:01:51.490
climb down there, get the pixels,
bring them back up.

01:01:51.500 --> 01:01:54.260
You're not going to be running
any faster than software,

01:01:54.260 --> 01:01:55.670
in fact, in some cases slower.

01:01:55.700 --> 01:02:00.670
So to use Quartz 2D on OpenGL,
you have to buy into the whole

01:02:00.670 --> 01:02:02.400
asynchronous and the pixels.

01:02:02.400 --> 01:02:04.200
They'll show up when they show up.

01:02:04.300 --> 01:02:06.890
I never want to look back
at pixels I've drawn,

01:02:07.020 --> 01:02:08.600
except very rarely.

01:02:09.010 --> 01:02:11.600
Otherwise, it's just not going to
be any faster for you.

01:02:11.600 --> 01:02:12.740
Thank you.

01:02:13.630 --> 01:02:19.890
So I'll invite Ralph up one last time
for a demo of Quartz 2D on OpenGL.

01:02:24.170 --> 01:02:28.710
Okay, the first application I'm
going to show you is iChat.

01:02:28.710 --> 01:02:32.120
As you've seen in the keynote,
iChat has now this video

01:02:32.120 --> 01:02:34.210
conferencing feature.

01:02:35.510 --> 01:02:38.170
The way that video conferencing
view is implemented is

01:02:38.170 --> 01:02:39.990
actually fairly interesting.

01:02:40.100 --> 01:02:42.370
It is an OpenGL scene.

01:02:42.930 --> 01:02:47.220
So there is a video is put on a
texture and this is displayed.

01:02:47.220 --> 01:02:47.800
Oops, I think.

01:02:47.800 --> 01:02:49.800
I'll be your cameraman.

01:02:49.800 --> 01:02:50.800
Please be my cameraman.

01:02:50.800 --> 01:02:52.800
That's a good point.

01:02:52.800 --> 01:02:54.800
Okay.

01:02:54.950 --> 01:02:58.800
So video is put on a texture and
then GL composites that texture.

01:02:58.890 --> 01:03:03.850
And the reason why that is done is if
you have a two-way conference going,

01:03:03.850 --> 01:03:05.800
you have this little picture-in-picture
which has a drop shadow.

01:03:05.800 --> 01:03:10.990
And sometimes there is content being
shown as translucent alert messages

01:03:11.170 --> 01:03:13.800
lying on top of live video and stuff.

01:03:13.800 --> 01:03:17.350
So GL is really good at these kind
of things and it also does the

01:03:17.460 --> 01:03:19.800
conversion from a video YUV to RGB.

01:03:19.800 --> 01:03:23.820
So that takes all that load off
the CPU so the CPU is free to do

01:03:23.870 --> 01:03:28.800
the actual video encoding and the
networking stuff that is necessary.

01:03:29.330 --> 01:03:35.400
So this is a slightly modified
version of iChat to make this demo.

01:03:36.380 --> 01:03:40.410
What I'm doing here is I'm
drawing text on top of it.

01:03:40.460 --> 01:03:43.640
And this is text drawn
into an OpenGL scene.

01:03:43.710 --> 01:03:45.790
And it's not text on a texture.

01:03:45.860 --> 01:03:51.440
It is essentially CG show text at point
and then point it at that texture.

01:03:51.440 --> 01:03:57.270
So you just draw into it and
you get all the font management,

01:03:57.270 --> 01:03:59.640
the kerning,
and all these kind of things that are

01:03:59.640 --> 01:04:01.510
usually very hard to get in OpenGL.

01:04:03.600 --> 01:04:07.940
My second example I have here,
I have a PDF document.

01:04:08.000 --> 01:04:08.800
This one here.

01:04:08.890 --> 01:04:11.010
It has a little frame and a
bit of line art in the corner.

01:04:11.140 --> 01:04:13.480
By the way,
the way I made this PDF document,

01:04:13.480 --> 01:04:17.610
I wrote a little Quartz scripting script,
a Python script that takes the place

01:04:17.610 --> 01:04:19.600
of the line art and draws an oval.

01:04:19.600 --> 01:04:29.450
So, I'm going to take that
and drag it into my view.

01:04:34.210 --> 01:04:37.270
So we put a little oscillator
on it to change size.

01:04:37.270 --> 01:04:40.640
But the point here is, again,
this is not drawn into a texture.

01:04:40.740 --> 01:04:44.420
Every single frame, we reinterpret that
PDF and draw it on top.

01:04:44.430 --> 01:04:47.100
So the scaling you get here
is not scaling of a bitmap.

01:04:47.100 --> 01:04:49.710
It's vector art scaling.

01:04:55.030 --> 01:04:58.900
So, let me show you something about
the performance of these things.

01:04:58.900 --> 01:05:05.270
What I'm running here is a PDF document.

01:05:05.270 --> 01:05:08.400
It's the AppKit reference manual,
which is 1,300 pages long.

01:05:08.400 --> 01:05:11.990
And I'm just trying to flip
through the pages as fast as I can.

01:05:12.000 --> 01:05:14.990
And this is the standard

01:05:15.120 --> 01:05:19.100
"Quartz software renderer
that you get in Panther.

01:05:19.100 --> 01:05:22.440
And you see that little frame rate
meter in the top right corner?

01:05:22.600 --> 01:05:25.270
Yeah, we're getting, you know, between...

01:05:25.400 --> 01:05:26.400
"It's kinda low.

01:05:26.400 --> 01:05:28.590
50 to 60 frames per second.

01:05:28.700 --> 01:05:30.990
So, that's actually,
when you think about it,

01:05:31.050 --> 01:05:31.800
pretty impressive.

01:05:31.800 --> 01:05:34.110
It's, you know, 60 pages per second.

01:05:34.240 --> 01:05:37.550
That definitely beats the LaserWriter."

01:05:39.400 --> 01:05:44.980
Okay, but now I will replace the content
view here with an OpenGL view

01:05:44.990 --> 01:05:50.590
and then point the same PDF file
at the Quartz OpenGL renderer.

01:05:54.470 --> 01:05:55.770
"It gets a bit better.

01:05:55.900 --> 01:06:00.880
So, we're around 160 to 180
pages per second now.

01:06:00.880 --> 01:06:03.960
And literally the piece of code
that needed to be done there is

01:06:03.960 --> 01:06:06.220
something like three lines of setup.

01:06:06.220 --> 01:06:09.560
So the rest of the actual rendering
code is exactly the same."

01:06:10.940 --> 01:06:12.220
So, why is it fast?

01:06:12.310 --> 01:06:15.980
Well, it's what Peter said about
that asynchronous model.

01:06:15.980 --> 01:06:19.160
So, what PDF parsing involves, well,
you have to do the parsing and you

01:06:19.160 --> 01:06:22.880
have to do decompression of the stream,
and then you draw.

01:06:22.880 --> 01:06:26.090
So, what happens in this case,
once you did the decompression

01:06:26.090 --> 01:06:28.990
of a graphics primitive,
you just submit it to the GPU,

01:06:28.990 --> 01:06:33.010
and while the GPU is doing the graphics,
you're ready to decompress the next

01:06:33.010 --> 01:06:35.360
part and do the additional parsing.

01:06:35.380 --> 01:06:39.420
So, you have now the CPU and the
GPU running in parallel very nicely.

01:06:39.420 --> 01:06:41.960
So, that's, by the way,
the little CPU meter you see there.

01:06:41.980 --> 01:06:45.480
This is a two-CPU machine,
so it runs at 50%, so

01:06:45.480 --> 01:06:47.590
one CPU is fully busy.

01:06:48.670 --> 01:06:52.200
Well, you might wonder now, well,
if I take all that parsing and

01:06:52.210 --> 01:06:56.300
decompression stuff out of the loop,
because when I, my application draws,

01:06:56.300 --> 01:06:56.950
it doesn't do that.

01:06:57.000 --> 01:06:58.500
It just calls the CG APIs.

01:06:58.500 --> 01:07:03.310
So, and then I will say, well,
I'm glad you asked.

01:07:04.650 --> 01:07:08.510
Because that's what we did,
we essentially took out all the

01:07:08.510 --> 01:07:11.600
graphics primitives off that
PDF file and wrote in a big list,

01:07:11.720 --> 01:07:14.250
and then just called the
CG APIs to do the same drawing.

01:07:14.420 --> 01:07:18.030
So it's technically no longer
a PDF - the drawing of a PDF is

01:07:18.100 --> 01:07:20.200
a drawing of the PDF content.

01:07:20.370 --> 01:07:26.190
And when I do that,
things start to look like this.

01:07:28.600 --> 01:07:30.480
See that the CPU is still busy.

01:07:30.590 --> 01:07:35.680
We're actually still - the CPU is
still completely saturated with

01:07:35.680 --> 01:07:38.260
sending these commands over to the GPU.

01:07:38.400 --> 01:07:41.380
So I would consider that
a tuning opportunity,

01:07:41.380 --> 01:07:42.320
but we'll see.

01:07:42.850 --> 01:07:45.700
Okay, that's it for this demo.

01:07:45.700 --> 01:07:48.200
Thanks Ralph.

01:07:53.280 --> 01:07:54.200
Yeah, that's pretty amazing.

01:07:54.200 --> 01:07:58.240
I think Ralph was telling
this story about when we were

01:07:58.240 --> 01:07:59.830
bringing this demo together.

01:08:00.000 --> 01:08:02.570
I think he had to go back, what,
twice to make the frame

01:08:02.570 --> 01:08:03.560
counter go higher?

01:08:04.040 --> 01:08:07.690
100, that should be enough.

01:08:07.780 --> 01:08:09.200
No, 200, that should be enough.

01:08:09.200 --> 01:08:11.700
400, okay.

01:08:11.710 --> 01:08:14.530
So anyway,
so the recap of kind of the talk today

01:08:14.680 --> 01:08:18.700
is basically that there's really a new
era of innovation in platform graphics

01:08:18.700 --> 01:08:20.700
that's happening in the industry.

01:08:20.770 --> 01:08:23.950
And I think Mac OS X is kind
of leading the charge here.

01:08:24.070 --> 01:08:27.000
And it's really kind of a
state-of-the-art visual computing

01:08:27.000 --> 01:08:30.420
platform for all your applications.

01:08:30.710 --> 01:08:32.880
So in your apps,
please leverage all the great

01:08:32.880 --> 01:08:36.700
infrastructure we're building in,
of Quartz 2D and OpenGL.

01:08:36.730 --> 01:08:38.490
And I think unlike sort
of in the old days,

01:08:38.490 --> 01:08:41.320
there was a period where people
had to work around operating

01:08:41.320 --> 01:08:44.700
system infrastructure to try to
do what they wanted to because of

01:08:44.700 --> 01:08:48.200
limitations in Quick Draw or GDI or
whatever platform graphics was there.

01:08:48.230 --> 01:08:52.000
But I think we're kind of coming upon
a new era where the platform graphics

01:08:52.050 --> 01:08:56.200
is getting good enough that you build
on top of it and really can go places.

01:08:56.200 --> 01:08:59.040
You don't have to go back and
reinvent all of your blit loops again.

01:08:59.390 --> 01:09:03.200
Let us do that work and you guys
add great value on top of that.

01:09:03.370 --> 01:09:05.780
And with all these new things
going on in the industry,

01:09:05.780 --> 01:09:08.130
particularly with
OpenGL and Fragment program,

01:09:08.190 --> 01:09:12.610
it's really fun to go just learn a
few new tricks and crack open the

01:09:12.610 --> 01:09:16.200
GL book or something like that and
teach yourself some new techniques.

01:09:16.200 --> 01:09:17.200
Because there's a lot
of new stuff happening.

01:09:17.200 --> 01:09:21.540
So for the last few minutes of the talk,
what I'm going to do is briefly whiz

01:09:21.540 --> 01:09:25.590
you through some of the pointers to
other sessions that you'll want to

01:09:25.600 --> 01:09:30.160
check out if hopefully we've piqued
your interest during the talk today.

01:09:30.200 --> 01:09:32.200
I'll start with Quartz 2D.

01:09:32.200 --> 01:09:36.200
Some of the new things in Panther for
Quartz 2D is PDF 1.4 support,

01:09:36.200 --> 01:09:38.140
the PDF introspection
API we talked about,

01:09:38.210 --> 01:09:41.200
the Quartz scripting
with the Python bindings,

01:09:41.240 --> 01:09:44.410
CMYK rendering context so now
we can drive raster printers

01:09:44.410 --> 01:09:46.200
in their native color space.

01:09:46.200 --> 01:09:47.100
Numerous performance optimizations and
of course as you saw Quartz 2D on OpenGL.

01:09:47.200 --> 01:09:51.560
There's a Quartz 2D in depth
session on Thursday and then an

01:09:51.560 --> 01:09:55.990
intro to Quartz services which
talks about some of the display

01:09:56.060 --> 01:09:59.200
management infrastructure on Friday.

01:09:59.200 --> 01:10:03.430
For Panther obviously we're shipping
1.0 of our X11 implementation

01:10:03.430 --> 01:10:05.200
as we talked about yesterday.

01:10:05.200 --> 01:10:11.200
This will be a merge with a
4.3 X386 that's on your seed.

01:10:11.200 --> 01:10:15.200
We have double clickable X11 applications
now in full screen mode operating.

01:10:15.200 --> 01:10:17.200
And a lot of bug fixes.

01:10:17.200 --> 01:10:20.200
So check this out in the seed
if you're an X developer.

01:10:20.200 --> 01:10:22.200
It's all in the disk you have.

01:10:23.260 --> 01:10:26.340
Also new for Panther in printing,
we've got PostScript support.

01:10:26.350 --> 01:10:29.200
We're really excited about that -
the ability to basically have any

01:10:29.200 --> 01:10:33.100
Mac OS X attached printer be seen on
the network as a PostScript printer.

01:10:33.100 --> 01:10:35.900
User interface improvements -
we've got an improved version

01:10:36.010 --> 01:10:39.100
of the old desktop printers,
which is coming out in Panther.

01:10:39.100 --> 01:10:41.090
We have job submission APIs.

01:10:41.100 --> 01:10:44.960
If you know how to calculate your own
PDF file or your own PostScript file,

01:10:45.100 --> 01:10:48.090
you can just hand that to the spool
system directly and not have to watch

01:10:48.140 --> 01:10:49.900
that page counting dialogue go by.

01:10:50.100 --> 01:10:56.100
We're merging with CUPS 1.1.19,
the latest version of CUPS.

01:10:56.100 --> 01:10:57.950
And we're also going to be
shipping the GIMP drivers this time

01:10:57.950 --> 01:11:01.030
around - the GIMP print drivers,
which are great for legacy printers.

01:11:01.180 --> 01:11:03.050
It supports a whole bunch of printers.

01:11:03.110 --> 01:11:06.310
And the drivers are really
first-class citizens with their

01:11:06.310 --> 01:11:08.340
user interface and integration.

01:11:09.160 --> 01:11:12.860
The printing session is on Thursday,
so you'll want to check that out.

01:11:12.900 --> 01:11:14.660
For ColorSync, some of the new things.

01:11:14.720 --> 01:11:17.450
If you went to the QuickTime talk,
you saw Tim talk a little bit

01:11:17.450 --> 01:11:20.390
about ColorSync and its relation
to QuickTime Graphics Importer

01:11:20.390 --> 01:11:21.930
to apply profiles by default.

01:11:22.190 --> 01:11:31.170
Cameras are going to embed profiles
by default with a standard profile.

01:11:31.350 --> 01:11:34.490
Cups and GIMPrint drivers can be
integrated with ColorSync and Vend

01:11:34.600 --> 01:11:36.300
profiles and have matching occur.

01:11:36.300 --> 01:11:39.140
We've got the Quartz
PDF filters that I talked about.

01:11:39.140 --> 01:11:40.900
You'll want to go see those.

01:11:40.910 --> 01:11:43.180
And Sips, which is a command line
image processing tool,

01:11:43.230 --> 01:11:45.240
which is meant to
interface with AppleScript.

01:11:45.290 --> 01:11:50.420
So AppleScripters can do basic image
operations like crop and rotate without

01:11:50.620 --> 01:11:53.300
having to launch preview or whatever.

01:11:53.300 --> 01:11:57.300
New APIs for abstract profile generation.

01:11:57.320 --> 01:12:01.330
ColorSync has the facility to do
actual manipulations in abstract color

01:12:01.330 --> 01:12:03.280
spaces like the sepia tone and LAB.

01:12:03.430 --> 01:12:06.080
There's going to be new APIs to
how to express those kinds of

01:12:06.080 --> 01:12:09.260
color transformations in Panther.

01:12:09.410 --> 01:12:13.220
And also a new display
calibrator that's tuned for LCDs.

01:12:13.220 --> 01:12:15.770
So go hear about that on Wednesday.

01:12:16.210 --> 01:12:18.390
For image capture, a bunch of new stuff.

01:12:18.600 --> 01:12:21.880
There are new ways to integrate your
applications with image capture.

01:12:21.880 --> 01:12:22.920
There's automatic task.

01:12:23.000 --> 01:12:25.370
Image capture services,
which is the Cocoa and

01:12:25.380 --> 01:12:28.080
Carbon Service menu,
you can integrate that

01:12:28.090 --> 01:12:29.580
with image capture.

01:12:29.580 --> 01:12:32.920
There's also a common UI layer
for if you want to do scanning

01:12:32.920 --> 01:12:35.540
from within an application,
you can call on that.

01:12:35.540 --> 01:12:38.890
There's also network support
for sharing and monitoring image

01:12:39.300 --> 01:12:42.300
capture devices over the web,
so that's kind of cool as well.

01:12:44.020 --> 01:12:48.290
on Wednesday,
session 204 is image capture.

01:12:49.240 --> 01:12:52.800
and OpenGL... Excuse me.

01:12:52.800 --> 01:12:54.790
I need my water.

01:12:56.590 --> 01:12:58.370
OpenGL, new for Panther.

01:12:58.550 --> 01:13:01.590
There's Fragment Program,
Pixel Buffer support,

01:13:01.690 --> 01:13:05.330
lots of optimizations about copy
text image and copy text subimage.

01:13:05.450 --> 01:13:08.500
We have recoverable GPU support
for drivers that support it.

01:13:08.500 --> 01:13:12.070
The ability to reset the GPU on the
fly without bringing the machine down,

01:13:12.080 --> 01:13:15.500
which is pretty handy,
especially if you're debugging drivers.

01:13:15.800 --> 01:13:19.220
OpenGL Shader Builder and Profiler.

01:13:19.500 --> 01:13:22.500
These are two really great tools
we have for OpenGL developers,

01:13:22.520 --> 01:13:25.500
and I think you want to go to
the sessions and see those,

01:13:25.500 --> 01:13:28.490
because those are really making
great strides in Panther.

01:13:28.500 --> 01:13:32.170
Again, the ability to use Quartz
2D in an OpenGL context,

01:13:32.170 --> 01:13:35.510
and just lots of bug fixes
and optimization techniques

01:13:35.510 --> 01:13:36.940
you can hear about.

01:13:37.450 --> 01:13:42.000
So this is a bunch of sessions
that we have for OpenGL.

01:13:42.000 --> 01:13:43.610
I'll point out in
particular the last one,

01:13:43.610 --> 01:13:45.270
Session 212, on Friday.

01:13:45.300 --> 01:13:48.880
We're actually going to have some of
the demo engineers from ATI come and

01:13:48.880 --> 01:13:52.350
show you how they built their demo
engine and run through a couple of the

01:13:52.350 --> 01:13:54.300
techniques they used in their demos.

01:13:54.300 --> 01:13:58.990
Last year we had NVIDIA do this,
and it was a great session,

01:13:58.990 --> 01:13:58.990
and it's going to be
great again this year.

01:13:59.760 --> 01:14:03.240
Another special session later on today,
we thought it would be really fun to

01:14:03.240 --> 01:14:07.310
have the keynote engineers come and
talk about Keynote as an application

01:14:07.540 --> 01:14:11.080
and how they really leverage the
platform services in terms of Quartz 2D,

01:14:11.240 --> 01:14:15.080
OpenGL, QuickTime, Cocoa,
to build what I think is really a

01:14:15.080 --> 01:14:19.690
great application that really kind
of swims downstream with all the

01:14:19.690 --> 01:14:25.020
technology and builds on top of what
we're doing in the operating system.

01:14:25.020 --> 01:14:26.380
So that'll be a really interesting
session to attend as well.

01:14:28.020 --> 01:14:32.900
So, and last but not least,
our feedback forum, which is at 5:00,

01:14:33.130 --> 01:14:36.700
the last thing in the conference
in the North Beach conference room.

01:14:36.700 --> 01:14:38.680
So come to there,
tell us what we're doing right,

01:14:38.830 --> 01:14:40.900
what we're doing wrong,
what you'd like to see

01:14:40.900 --> 01:14:43.410
us do in the future,
and we always enjoy talking to you

01:14:43.480 --> 01:14:45.340
guys and getting your feedback.
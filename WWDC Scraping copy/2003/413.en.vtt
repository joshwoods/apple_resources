WEBVTT

00:00:26.180 --> 00:00:27.490
Well, is my mic on?

00:00:27.600 --> 00:00:28.130
Can you all hear me?

00:00:28.560 --> 00:00:31.540
Okay,
I want to thank Jason for introducing me.

00:00:31.540 --> 00:00:34.340
I know he just had to jog down
here from a very long QA session

00:00:34.340 --> 00:00:37.450
in the Cocoa UI techniques part.

00:00:37.600 --> 00:00:40.950
So I'm here to talk about
Cocoa 2D Drawing Techniques.

00:00:41.090 --> 00:00:43.990
That's me, John Randolph,
a senior engineer in a

00:00:43.990 --> 00:00:47.080
marketing department,
which is kind of fun.

00:00:47.900 --> 00:00:53.630
And what I'm going to cover in
this talk is how the Cocoa classes

00:00:53.630 --> 00:00:58.190
that reflect the Quartz drawing
model are used in 2D rendering.

00:00:58.200 --> 00:01:01.930
So I'll talk a little bit about images,
paths, and text, how we manipulate the

00:01:01.930 --> 00:01:04.580
coordinate space in Cocoa,
generally how to draw

00:01:04.580 --> 00:01:06.380
using the Cocoa frameworks.

00:01:07.720 --> 00:01:10.600
I'll talk a little bit about
more sophisticated drawing

00:01:10.660 --> 00:01:13.910
techniques than I did last year,
particularly combining

00:01:13.910 --> 00:01:15.700
vector and image drawing.

00:01:15.700 --> 00:01:19.480
And then my colleague Troy will come
up and discuss the changes to the

00:01:19.480 --> 00:01:22.310
Cocoa 2D Drawing API for Panther.

00:01:22.450 --> 00:01:26.800
So there are a couple of additions to
existing classes and some new APIs,

00:01:26.800 --> 00:01:29.580
and maybe I'll get a
demo or two into this.

00:01:30.260 --> 00:01:32.800
So where does this all fit in?

00:01:32.800 --> 00:01:38.160
Before we get to GUIs, we just have the
BSD API and we have Darwin.

00:01:38.160 --> 00:01:43.470
And then we've added all of these amazing
graphics technologies like Quartz 2D,

00:01:43.470 --> 00:01:46.710
OpenGL,
and QuickTime for time-based media.

00:01:47.860 --> 00:01:52.010
So, Java can use them,
Carbon can use them, Cocoa can use them,

00:01:52.240 --> 00:01:55.810
and we use these frameworks
talking to the graphics layers to

00:01:55.830 --> 00:01:58.160
implement Aqua in your applications.

00:01:58.160 --> 00:02:02.090
And today we're going to talk
specifically about Cocoa and

00:02:02.090 --> 00:02:06.780
Quartz and how you use them to
comply with John Galenzi's desires.

00:02:06.780 --> 00:02:09.440
And you all comply, right?

00:02:09.520 --> 00:02:10.290
Good.

00:02:10.400 --> 00:02:14.700
So, Quartz 2D gives us a couple
of very powerful features.

00:02:14.700 --> 00:02:18.400
We get window management,
a very nice... complete

00:02:18.490 --> 00:02:21.590
vector drawing API,
a lot of image handling code,

00:02:21.590 --> 00:02:25.950
compositing of those images,
and that's actually pervasive in our OS,

00:02:25.950 --> 00:02:29.200
and I believe that we are the
only vendor that offers that.

00:02:29.430 --> 00:02:32.380
And we've got a lot of powerful
text rendering capabilities

00:02:32.390 --> 00:02:34.150
also in the Quartz 2D layer.

00:02:35.660 --> 00:02:39.680
The Quartz 2D compositor,
what we call Quartz Services now,

00:02:39.680 --> 00:02:42.960
is the Windows server that
takes care of blending those

00:02:42.960 --> 00:02:44.780
windows together on the screen.

00:02:44.780 --> 00:02:47.560
We have hardware accelerated
window compositing.

00:02:47.560 --> 00:02:49.600
We have transparency of windows.

00:02:49.600 --> 00:02:52.330
We have windows mapped
into OpenGL texture memory,

00:02:52.330 --> 00:02:54.580
and you've seen that in other sessions.

00:02:55.890 --> 00:02:58.530
Besides that,
we have the PostScript PDF style

00:02:58.660 --> 00:03:01.600
vector-based drawing model,
which you all should be

00:03:01.600 --> 00:03:04.900
familiar with from your days
with the Apple LaserWriter,

00:03:04.900 --> 00:03:07.300
some, what, 20 years ago now?

00:03:07.300 --> 00:03:11.820
And this is based on paths
that can be filled or stroked.

00:03:11.820 --> 00:03:14.830
They are resolution independent,
and on Mac OS X,

00:03:14.860 --> 00:03:17.180
you get that anti-aliasing for free.

00:03:17.180 --> 00:03:22.570
The coordinate system that we get
from Quartz 2D and that we use in

00:03:22.600 --> 00:03:27.630
Cocoa views when we're drawing,
is based on a floating point system.

00:03:28.000 --> 00:03:32.700
The origin is in the lower left corner,
just like it is in math.

00:03:32.700 --> 00:03:36.320
I want to make the point
that on today's displays,

00:03:36.440 --> 00:03:40.980
the whole number of values land
exactly between screen pixels.

00:03:40.980 --> 00:03:44.090
And sometimes you might adjust your
drawing to make sure that lines that

00:03:44.090 --> 00:03:46.500
you draw exactly take one pixel.

00:03:46.520 --> 00:03:48.670
I'm going to tell you not to
rely on this because you're not

00:03:48.670 --> 00:03:50.890
always drawing to the screen.

00:03:50.900 --> 00:03:52.640
Sometimes you're going to be
drawing for a printing context.

00:03:52.640 --> 00:03:55.540
You're going to be drawing
in much higher resolution.

00:03:55.540 --> 00:03:57.540
You're going to be drawing in
much higher resolution contexts,

00:03:57.540 --> 00:04:00.270
like when you're imaging for a
printer or when you're imaging

00:04:00.740 --> 00:04:02.690
for a high-priced typesetter.

00:04:02.700 --> 00:04:04.740
So when you're doing
these drawing techniques,

00:04:04.880 --> 00:04:07.180
please check to see whether
you actually need to do them.

00:04:08.990 --> 00:04:10.900
More features of Quartz 2D.

00:04:10.900 --> 00:04:13.240
We can scale and rotate images.

00:04:13.280 --> 00:04:15.770
We can map them to what other
color depth is available on the

00:04:15.770 --> 00:04:17.000
display where they're being drawn.

00:04:17.000 --> 00:04:19.060
We've got color managed
rendering of images,

00:04:19.060 --> 00:04:22.480
which you might have just seen across
the hall in the QuickTime session.

00:04:22.480 --> 00:04:26.390
We've got JPEG decoding,
and all of this has been optimized

00:04:26.500 --> 00:04:30.360
to use the velocity engine
on the G4s if it's present.

00:04:30.360 --> 00:04:32.770
And, of course,
we've got people working very

00:04:32.770 --> 00:04:35.990
hard on making that go as fast
as it possibly can on the G5s.

00:04:37.940 --> 00:04:40.400
So, more about Quartz 2D features.

00:04:40.400 --> 00:04:43.240
We've got a very rich set
of compositing operators.

00:04:43.240 --> 00:04:45.020
There are 14 different modes.

00:04:45.020 --> 00:04:48.290
The original Porter Duff paper on
the subject described 12 modes,

00:04:48.290 --> 00:04:49.640
and we invented two more.

00:04:49.640 --> 00:04:52.870
Our compositing takes into
account both the source and

00:04:52.870 --> 00:04:54.940
the destination alpha values.

00:04:54.940 --> 00:04:57.410
Again,
this is all optimized to use whatever

00:04:57.680 --> 00:04:59.520
hardware you have in the machine.

00:05:00.120 --> 00:05:04.030
And I'm going to point out
a couple of examples here.

00:05:04.140 --> 00:05:07.640
On any machine that's got the
Mac OS X developer tools installed,

00:05:07.640 --> 00:05:11.550
you can go to
Developer Examples App Kit Composite Lab,

00:05:11.550 --> 00:05:14.040
and there's an app there that lets
you try out all the compositing

00:05:14.040 --> 00:05:15.620
modes and see what their effects are.

00:05:15.620 --> 00:05:19.610
And then there's a simpler app
on the DTS sample code website,

00:05:19.630 --> 00:05:23.250
actually two of them,
Tinted Image and Cropped Image,

00:05:23.250 --> 00:05:27.400
which both show you things
that you can do by compositing.

00:05:29.370 --> 00:05:33.700
Quartz 2D also gives us text rendering,
as I described before.

00:05:33.700 --> 00:05:36.820
I'm not going to get much into text
because it's a pretty big subject.

00:05:36.930 --> 00:05:40.160
I urge you to go to
the Cocoa text session.

00:05:40.200 --> 00:05:43.750
I will just mention that the
anti-aliasing and the LCD text and so

00:05:43.860 --> 00:05:46.360
forth is also velocity engine optimized.

00:05:46.360 --> 00:05:52.430
Let me just grab a little drink here.

00:05:57.380 --> 00:06:01.620
So in the Cocoa framework,
we do window management through

00:06:01.620 --> 00:06:04.300
instances of the NSWindow class.

00:06:04.300 --> 00:06:10.300
We do vector drawing mostly
with the NSBezierPath class.

00:06:10.300 --> 00:06:14.190
Images and compositing are done with
the NSImageRep and NSImage class.

00:06:14.310 --> 00:06:17.860
Text is done with NSText, NSString,
NSAttributedString,

00:06:17.860 --> 00:06:21.410
and a lot of other classes that
I won't be going into here.

00:06:22.120 --> 00:06:27.950
So when you're going to start
rendering the images or the vector

00:06:27.950 --> 00:06:31.220
art that makes your app unique,
you need to know where

00:06:31.220 --> 00:06:32.320
you're going to draw.

00:06:32.320 --> 00:06:37.320
Now, if you're down at the Quartz level,
you'd be drawing into a CG window,

00:06:37.320 --> 00:06:39.700
but if you're a Cocoa coder,
it's a little simpler than that.

00:06:39.760 --> 00:06:43.720
You have an NSWindow object
that manages the CG windows.

00:06:43.720 --> 00:06:45.480
It will get your events.

00:06:45.480 --> 00:06:48.130
It will talk to the Windows server
and tell it when something has

00:06:48.130 --> 00:06:49.660
changed and needs to be updated.

00:06:50.300 --> 00:06:54.320
And it has a drawing context,
so it has things like what image

00:06:54.320 --> 00:06:59.430
interpolation is in effect,
what the current line drawing width is,

00:06:59.450 --> 00:07:01.160
what the current drawing color is,
and so forth.

00:07:01.470 --> 00:07:05.320
Most of the drawing in your apps is
going to happen in NSView instances.

00:07:05.320 --> 00:07:10.790
A drawing destination in Cocoa basically
is anything that can react to

00:07:10.790 --> 00:07:13.300
lock focus and unlock focus.

00:07:13.300 --> 00:07:17.520
And NSImage is also a place to draw
that you'll use if you want to build

00:07:17.520 --> 00:07:20.020
something in an off-screen buffer.

00:07:20.140 --> 00:07:24.520
the way you might have done in the
G world in earlier versions of Mac OS.

00:07:26.350 --> 00:07:28.530
So let me mention NSView here.

00:07:28.840 --> 00:07:33.560
I like to think of NSView as a rectangle
of responsibility within a window.

00:07:33.560 --> 00:07:37.810
It owns some portion of the window,
and any events that happen in that area

00:07:37.810 --> 00:07:40.030
are going to come to this NSView object.

00:07:40.160 --> 00:07:45.000
Things like keystrokes,
things like mouse events, and so forth.

00:07:45.350 --> 00:07:47.410
Things like drags into
that part of the window.

00:07:48.120 --> 00:07:53.560
NSView's got its own coordinate space,
not necessarily its own drawing context.

00:07:53.740 --> 00:07:56.930
Views live in a hierarchy,
so every view has a super view

00:07:56.930 --> 00:07:58.800
and any number of sub views.

00:07:58.800 --> 00:08:02.650
Most of the drawing in NSViews
are going to happen within the

00:08:02.650 --> 00:08:06.250
context of the draw rect method,
and some changes to the

00:08:06.290 --> 00:08:09.660
way NSView objects behave
are coming up in Panther,

00:08:09.660 --> 00:08:12.090
and Troy will fill you in on that.

00:08:13.870 --> 00:08:18.110
So let me go over something here that
seems to be a point of confusion for

00:08:18.110 --> 00:08:20.760
a number of new Cocoa developers.

00:08:21.680 --> 00:08:24.880
There are two rectangles that are
very significant for NS views.

00:08:25.310 --> 00:08:28.000
There are the frame and
the bounds rectangles.

00:08:28.140 --> 00:08:30.980
The bounds determines
your coordinate space.

00:08:31.050 --> 00:08:35.310
It tells you how big you are and where
your coordinate space origin is as far

00:08:35.410 --> 00:08:37.600
as your point of view is concerned.

00:08:37.810 --> 00:08:41.640
Determines the scaling and the
rotation of your coordinate space.

00:08:41.930 --> 00:08:47.730
You can change it around to suit your
drawing with methods like set bound

00:08:48.010 --> 00:08:48.790
size and rotate by angle and so forth.

00:08:49.210 --> 00:08:51.790
So let's say we've got a view
that's going to draw this

00:08:51.790 --> 00:08:56.070
nice little farmhouse here,
and the bounds of this obviously

00:08:56.080 --> 00:08:57.950
are the borders of the image.

00:08:58.270 --> 00:09:01.100
Now if I go and put
that in a scroll view,

00:09:01.100 --> 00:09:06.180
well, it's still this big.

00:09:09.260 --> 00:09:14.720
But it's only going to draw in this area
that's outlined by the solid rectangle,

00:09:14.760 --> 00:09:20.150
even though it thinks it's still
as big as the outer rectangle.

00:09:20.360 --> 00:09:23.340
The frame is what's actually going
to enclose the area that gets drawn.

00:09:23.690 --> 00:09:28.810
The bounds is the largest
area that you might ever draw.

00:09:30.050 --> 00:09:33.380
Let me give a little bit of
advice for writing NS views.

00:09:33.520 --> 00:09:36.370
Something that's very tempting is
when there's a change in your model,

00:09:36.390 --> 00:09:39.410
in your code,
you're going to want to draw immediately.

00:09:39.410 --> 00:09:43.400
And I'm going to ask you,
for performance reasons, to not do that.

00:09:43.920 --> 00:09:48.110
Calling lock focus and unlock
focus is usually not necessary.

00:09:48.110 --> 00:09:50.330
Now,
there are times when it is necessary,

00:09:50.420 --> 00:09:54.080
like if you have a live animation going,
or like we do in the kit where we

00:09:54.080 --> 00:09:56.110
have that default button pulsing.

00:09:56.280 --> 00:09:58.450
So if you must draw right away,
you can go ahead and use

00:09:58.450 --> 00:09:59.890
lock focus and unlock focus.

00:10:00.000 --> 00:10:04.600
But most of the time, in your apps,
it's not going to be necessary.

00:10:04.600 --> 00:10:06.900
And all you'll need to do
is call set needs display or

00:10:06.900 --> 00:10:09.680
set needs display in rect,
and then the view updating

00:10:09.680 --> 00:10:11.680
machinery can take it from there.

00:10:11.680 --> 00:10:15.090
And the main piece of advice
I want to give you here is let

00:10:15.090 --> 00:10:17.060
the framework do the driving.

00:10:17.260 --> 00:10:21.480
It really is a benefit for performance
to do that wherever you can.

00:10:21.520 --> 00:10:25.530
Okay.

00:10:29.180 --> 00:10:31.120
So whenever you're going to do
the kind of drawing that you

00:10:31.120 --> 00:10:35.400
used to do with PostScript code,
you use the NS BezierPath class.

00:10:35.400 --> 00:10:39.340
It's got the familiar path construction
operators such as move2 and line2 and

00:10:39.340 --> 00:10:41.320
relative line2 and curve2 and so forth.

00:10:41.380 --> 00:10:45.170
It also has convenience methods such
as BezierPath with oval and rect,

00:10:45.230 --> 00:10:48.830
or BezierPath,
there are convenience methods

00:10:48.920 --> 00:10:51.340
that will give you a rectangle.

00:10:51.340 --> 00:10:54.820
And I happen to like to add
methods to BezierPath to give

00:10:54.880 --> 00:10:59.000
me other kinds of shapes that
I might use frequently in an app.

00:10:59.100 --> 00:11:05.760
You can use a path as an object that
will add to your clipping boundaries,

00:11:05.760 --> 00:11:09.990
and you can make it the current
clipping path with setclip,

00:11:10.060 --> 00:11:13.050
or add it to the current
clipping path with addclip.

00:11:13.140 --> 00:11:16.860
NS BezierPath can also give
you character glyph outlines.

00:11:16.860 --> 00:11:21.510
You can ask for these from NS BezierPath
after you've gotten a glyph from NS font.

00:11:21.570 --> 00:11:24.340
And one thing that I've
seen happen very often,

00:11:24.340 --> 00:11:27.840
and in fact I've made this
mistake myself in a lot of code,

00:11:28.230 --> 00:11:31.740
is that people will often create
paths and then just throw them away,

00:11:31.740 --> 00:11:33.520
and this isn't actually necessary.

00:11:33.520 --> 00:11:36.830
Since the NS BezierPath
object is a container for

00:11:36.880 --> 00:11:41.130
these path building commands,
you can just empty it and reuse it,

00:11:41.160 --> 00:11:42.400
and that's a little
more memory efficient.

00:11:44.390 --> 00:11:47.210
BezierPath, of course,
does Bezier cubic lines,

00:11:47.210 --> 00:11:48.900
thus the name of the class.

00:11:48.900 --> 00:11:51.450
And it's got the other PostScript marking
features that you might expect,

00:11:51.570 --> 00:11:55.230
like setting the line caps,
setting the flatness of

00:11:55.230 --> 00:11:57.710
curves when you render them,
and so forth.

00:11:57.780 --> 00:12:02.350
So most of the things that you would
look for in PostScript or in PDF,

00:12:02.350 --> 00:12:06.820
when you're drawing in a Cocoa view,
you probably want to look

00:12:06.820 --> 00:12:08.720
to the NSBezier class.

00:12:10.810 --> 00:12:14.560
And let me also mention there are a
lot of really simple and convenient

00:12:14.560 --> 00:12:16.530
drawing functions in the app kit.

00:12:16.580 --> 00:12:19.170
If you just need to fill up a
rectangle with a color or fill it with

00:12:19.250 --> 00:12:23.530
a color using a compositing operation,
whenever you think that there

00:12:23.530 --> 00:12:27.480
probably should be a function
to do what you're about to do,

00:12:27.580 --> 00:12:30.470
take the time to look for it,
because it probably is there.

00:12:31.820 --> 00:12:33.790
We're going to mention NSImage.

00:12:33.790 --> 00:12:37.630
Now, I often hear the question,
how do I get to this particular

00:12:37.630 --> 00:12:39.580
pixel of my NSImage instance?

00:12:39.580 --> 00:12:43.850
And the answer is, you don't,
because NSImages don't have pixels.

00:12:43.850 --> 00:12:48.190
Not all NSImages are just lists of
values over space and a color space.

00:12:48.190 --> 00:12:52.320
A lot of NSImages, for example,
PDF or resolution independent.

00:12:52.320 --> 00:12:56.880
So some NSImage reps have pixels,
not all do, and whenever you're going to

00:12:56.880 --> 00:13:01.680
try to get the values right,
you're going to have to do a lot of work.

00:13:01.700 --> 00:13:04.360
If you're going to try to get the value
of the color at any particular location,

00:13:04.360 --> 00:13:06.790
you're going to have to actually
render that image first and

00:13:06.800 --> 00:13:08.120
then try to read the value back.

00:13:08.120 --> 00:13:13.870
So the point I wanted to emphasize here
is that some NSImage reps have pixels,

00:13:13.900 --> 00:13:17.220
some don't, but NSImages,
the containers for

00:13:17.530 --> 00:13:21.300
NSImage reps themselves,
do not have pixels.

00:13:21.350 --> 00:13:23.840
Now,
NSImage is also something you can use

00:13:23.840 --> 00:13:27.270
as a destination for off-screen drawing,
and in my demo,

00:13:27.340 --> 00:13:30.800
I'll show you a little example
of how I did that in one case.

00:13:31.700 --> 00:13:34.890
Something to remember,
when you're drawing into an NSImage,

00:13:35.100 --> 00:13:38.290
it's not an NSView,
so the NSView methods for manipulating

00:13:38.290 --> 00:13:40.380
the coordinate space are not there.

00:13:40.400 --> 00:13:48.530
The Quartz2D functions for manipulating
your coordinate space are still there,

00:13:48.530 --> 00:13:53.130
and you can still call
all of those functions,

00:13:53.140 --> 00:13:56.320
and whenever you've got
focus locked on a view,

00:13:56.320 --> 00:14:01.360
you have an active Quartz drawing
context in all of the coordinates.

00:14:01.820 --> 00:14:07.540
So you can use that to draw any
of those functions that directly

00:14:07.580 --> 00:14:11.900
manipulate that context are still valid.

00:14:11.900 --> 00:14:15.390
Now, another thing that's kind of
handy here is that you can use the

00:14:15.390 --> 00:14:19.770
NSAffineTransform class to describe any
linear transformation of coordinates,

00:14:19.770 --> 00:14:23.370
and NSAffineTransform can be
applied in any drawing context.

00:14:24.180 --> 00:14:27.260
A couple more things about NSImage.

00:14:27.640 --> 00:14:33.740
In Jaguar, we gained the ability to
draw NSImages progressively,

00:14:33.750 --> 00:14:36.810
so if you're loading something
expensively over the net,

00:14:36.860 --> 00:14:40.160
you can get notifications that tell you,
I know enough about it to

00:14:40.160 --> 00:14:43.280
tell you how big it is,
I know enough to render a band of pixels,

00:14:43.360 --> 00:14:46.240
I know enough to actually
render the entire image.

00:14:46.240 --> 00:14:50.070
And every time you get this notification,
you can just draw the image,

00:14:50.070 --> 00:14:53.090
and it will draw as much of
it as you have at that point.

00:14:54.160 --> 00:14:58.940
We've also got features added in
Panther for multi-frame images,

00:14:58.970 --> 00:15:03.620
so if you have an NSPDF image rep
that you've loaded from a PDF file,

00:15:03.790 --> 00:15:07.980
you can set the current page that it
will draw when it's told to draw by

00:15:07.980 --> 00:15:10.540
calling the set current page method.

00:15:10.540 --> 00:15:15.280
And if you're going to go through
something like a PNG or GIF file

00:15:15.340 --> 00:15:20.210
that's got multiple frames,
you actually can set them, well,

00:15:20.210 --> 00:15:23.260
you go through set property with value.

00:15:23.680 --> 00:15:28.110
to get to the individual frames and
set which frame you're looking at.

00:15:28.210 --> 00:15:31.110
The other thing that you
would have in a GIF image,

00:15:31.140 --> 00:15:33.670
for example,
is the current frame duration,

00:15:33.670 --> 00:15:34.900
which you can query.

00:15:34.900 --> 00:15:37.920
So if you're going to
animate a GIF in Jaguar,

00:15:37.920 --> 00:15:41.350
this is how you'd get at it,
basically as a dictionary of

00:15:41.350 --> 00:15:42.600
attributes of the image rep.

00:15:44.920 --> 00:15:48.850
I want to talk a bit about
the compositing of NS images.

00:15:48.900 --> 00:15:52.910
The one I tend to use most
often is Composite to Point from

00:15:52.910 --> 00:15:54.940
Rect Operation Fraction.

00:15:54.940 --> 00:15:57.580
And you could also use Draw in Rect.

00:15:57.580 --> 00:16:02.010
I will point out that the Composite
to Point and the Draw in Rect

00:16:02.010 --> 00:16:04.830
functions do not behave the same way.

00:16:04.830 --> 00:16:07.990
One is more expensive than the other.

00:16:08.590 --> 00:16:11.120
Draw in Rect will honor the
fact that you've rotated the

00:16:11.120 --> 00:16:13.100
coordinate space if you've done so.

00:16:13.140 --> 00:16:15.350
Composite to Point doesn't bother.

00:16:15.350 --> 00:16:18.220
It's the fast path,
so if you don't need to actually fit

00:16:18.220 --> 00:16:21.930
that image into a rectangle that's
different from its original size,

00:16:21.930 --> 00:16:24.200
then that's the one you would prefer.

00:16:24.200 --> 00:16:26.780
If you want to just
composite a solid color,

00:16:26.830 --> 00:16:29.330
you can call NS Fill Rect
Using Operation,

00:16:29.330 --> 00:16:33.540
which apparently a number of people
never found while they were reading

00:16:33.540 --> 00:16:38.200
through all of the AppKit functions
that I just suggested everyone read.

00:16:38.360 --> 00:16:39.930
up on.

00:16:40.270 --> 00:16:46.090
And let me just give you my
little demonstration of combining

00:16:49.060 --> 00:16:54.420
Vector and Raster Drawing.

00:16:55.570 --> 00:17:00.400
So this is a sample that is just sitting
out there at the DTS website right now.

00:17:00.400 --> 00:17:05.840
You can go to the DTS sample code
page and go to Cocoa and pick this

00:17:05.940 --> 00:17:07.550
project up called Cropped Image.

00:17:07.570 --> 00:17:12.320
And what it will do is
it will take a path,

00:17:12.330 --> 00:17:18.980
draw it into an image,
and then use that image as a map.

00:17:19.000 --> 00:17:22.580
And then it will take a mask
to composite another image.

00:17:22.580 --> 00:17:27.010
So if I want to, for example,
just select the mandrel's eyes here.

00:17:27.320 --> 00:17:32.180
What's happening here is that that
path that I showed you before is being

00:17:32.180 --> 00:17:35.030
composited against the mandrel image,
and this is the result.

00:17:35.080 --> 00:17:38.970
Now I can turn edge
smoothing on or off here,

00:17:38.970 --> 00:17:42.560
that's a graphics context function.

00:17:42.560 --> 00:17:47.120
But the point I'm trying to get to
here is that this kind of thing,

00:17:47.120 --> 00:17:50.520
combining the vector
with the image drawing,

00:17:50.520 --> 00:17:52.810
is a way to get some fairly
sophisticated effects,

00:17:52.910 --> 00:17:55.000
and it's not a terribly
expensive thing to do.

00:17:55.800 --> 00:17:59.320
Let me just show you the code for that.

00:18:00.270 --> 00:18:06.630
So I have a path here that
I got from those mouse events.

00:18:06.630 --> 00:18:12.310
And what I do to make that cropped
image is I make a new image that is

00:18:12.310 --> 00:18:18.420
the same size as the image that I'm
going to be cutting down with the path.

00:18:19.620 --> 00:18:26.580
I lock focus on that new image,
fill it up with a solid color,

00:18:26.580 --> 00:18:31.500
and then I take the existing image,
composite with the source in operator,

00:18:31.500 --> 00:18:34.960
and the result is that basically
that mask punches out the

00:18:35.380 --> 00:18:36.940
area that I've selected.

00:18:39.510 --> 00:18:43.160
Let me show you one other thing that
I was able to do by compositing.

00:18:43.370 --> 00:18:48.880
Actually,
I wanted to show you the running app,

00:18:48.920 --> 00:18:50.590
not the project here.

00:18:53.760 --> 00:18:57.080
Okay,
here's another copy of the traditional

00:18:57.080 --> 00:18:59.790
mascot of image processing code.

00:18:59.790 --> 00:19:03.620
And what I've done here is I've taken
this original image and basically

00:19:03.620 --> 00:19:08.510
composited against solid colors using
the plus darker method to extract

00:19:08.510 --> 00:19:10.960
each of the components in turn.

00:19:10.960 --> 00:19:15.280
And then back here I reassemble
them using the plus lighter method.

00:19:15.300 --> 00:19:21.380
So I can just turn these on and off
and see the effects of various color

00:19:21.390 --> 00:19:26.180
components being composited back or not.

00:19:26.180 --> 00:19:29.780
So let's go back to the slides, please.

00:19:35.290 --> 00:19:37.990
Okay, I will mention,
as I always do in my demos,

00:19:38.000 --> 00:19:39.380
the things that I did wrong in that demo.

00:19:39.380 --> 00:19:42.520
First of all, I was drawing way too much,
and if you go and get that code,

00:19:42.620 --> 00:19:44.230
you'll see where I made the mistakes.

00:19:44.280 --> 00:19:48.740
Basically, every time I was drawing
the cropped image,

00:19:48.750 --> 00:19:53.540
I was redrawing the entire
area covered by the image view.

00:19:54.200 --> 00:19:56.960
Also,
I'm pretty sloppy with the Bezier paths.

00:19:56.960 --> 00:19:58.820
I'm actually creating them
and throwing them away every

00:19:58.820 --> 00:20:00.200
time there's a mouse event.

00:20:00.250 --> 00:20:03.650
I can get away with that on G4,
but probably not on

00:20:03.650 --> 00:20:05.530
like a Bondi Blue iMac.

00:20:05.620 --> 00:20:07.820
I also didn't bother
with scaling the path,

00:20:07.820 --> 00:20:10.700
but you can see that when you
go get the sample yourself and

00:20:10.700 --> 00:20:12.470
try resizing those image views.

00:20:16.890 --> 00:20:18.430
will just briefly mention text.

00:20:18.470 --> 00:20:22.130
It's a pretty big subject,
and Doug Davidson is going to be

00:20:22.170 --> 00:20:26.150
talking about that in session 427,
which will be the last session in

00:20:26.150 --> 00:20:27.850
the big room upstairs on Friday.

00:20:27.860 --> 00:20:31.900
There's a lot of power
in the Cocoa text system,

00:20:31.960 --> 00:20:36.310
and if you really want to
dig into the meat of that,

00:20:36.450 --> 00:20:38.210
Doug can fill you in on how to do that.

00:20:38.250 --> 00:20:41.660
I'll just mention that if you just
want to draw a label or something,

00:20:41.660 --> 00:20:44.800
you can just send messages to
NSString or NSAttributedString

00:20:44.800 --> 00:20:46.060
to have them render in your view.

00:20:46.800 --> 00:20:50.110
If you're going to do text that
has maybe a couple of lines to it,

00:20:50.110 --> 00:20:53.200
or maybe you want to edit the
text in your custom views,

00:20:53.200 --> 00:20:57.020
NSL objects are kind of handy for this
because they know how to deal with that.

00:20:57.270 --> 00:21:01.170
For more information on the text,
please catch Doug's session.

00:21:03.050 --> 00:21:06.140
A couple more AppKit classes that
are involved in 2D rendering.

00:21:06.140 --> 00:21:09.500
There's the Affine Transform, which,
as I said,

00:21:09.500 --> 00:21:13.520
will contain any combination of rotation,
scaling, and shearing,

00:21:13.520 --> 00:21:15.640
and you can apply it to the
current graphics context.

00:21:15.640 --> 00:21:19.260
There's the NSGraphicsContext method,
which is where you store

00:21:19.260 --> 00:21:21.880
current drawing attributes,
such as what your

00:21:21.880 --> 00:21:24.290
current drawing color is,
what your current

00:21:24.400 --> 00:21:28.760
transformation matrix is,
and what level of image interpolation

00:21:28.770 --> 00:21:30.620
quality you may have on.

00:21:31.180 --> 00:21:34.500
There's the NSScreen class,
which you use to get information about

00:21:34.560 --> 00:21:38.870
just what displays are available on your
particular system that you're running on.

00:21:40.560 --> 00:21:45.130
And Troy Stephens is going to come up
now and talk about the details of what's

00:21:45.190 --> 00:21:48.930
changed in NSVU and how you may want to
alter your drawing when you're getting

00:21:49.140 --> 00:21:50.780
ready to deploy your apps for Panther.

00:21:50.840 --> 00:21:51.140
So Troy?

00:21:52.180 --> 00:21:53.550
Thank you, John.

00:21:54.700 --> 00:21:56.630
Thanks very much for that.

00:21:56.690 --> 00:21:57.240
Hello, everyone.

00:21:57.240 --> 00:21:58.390
My name's Troy Stephens.

00:21:58.420 --> 00:22:01.750
I'm a software engineer in the
Cocoa Frameworks group at Apple.

00:22:01.870 --> 00:22:04.770
And among other things there,
I work on the NSView class.

00:22:04.860 --> 00:22:08.770
NSView, as you may know,
is the base class for NSControl,

00:22:08.770 --> 00:22:11.200
as well as for pretty much
every other kind of object in a

00:22:11.260 --> 00:22:14.660
Cocoa application that has some
notion of where it lives in a window,

00:22:14.660 --> 00:22:17.980
that has the ability to receive
and process mouse events,

00:22:17.980 --> 00:22:21.700
keyboard events,
and that can draw itself.

00:22:23.670 --> 00:22:26.110
So there are a couple of topics
relating to NSView that I want

00:22:26.110 --> 00:22:27.130
to address with you today.

00:22:27.240 --> 00:22:29.900
First of all,
we'll touch on a technique-- actually,

00:22:29.900 --> 00:22:33.940
a couple of techniques-- for hiding
views when you want them to temporarily

00:22:33.940 --> 00:22:36.690
disappear from your user interface.

00:22:36.790 --> 00:22:38.140
So we'll talk briefly about that.

00:22:38.200 --> 00:22:40.620
And then for the meat of today's talk,
we're going to talk about some

00:22:40.710 --> 00:22:44.440
techniques that you can use,
both on shipping versions of Mac OS X,

00:22:44.490 --> 00:22:47.240
on Jaguar and earlier,
and then starting on Panther,

00:22:47.240 --> 00:22:49.960
some new features that we've
added to help you to actively

00:22:49.970 --> 00:22:53.920
optimize your view drawing,
to draw as little as possible so that you

00:22:53.960 --> 00:22:58.780
can really have your application scream,
even if you're only running on, say,

00:22:58.780 --> 00:23:00.140
a G4.

00:23:01.100 --> 00:25:45.300
[Transcript missing]

00:25:45.380 --> 00:25:48.560
One thing you can do to very easily
get around this is to take some

00:25:48.560 --> 00:25:52.100
sort of a proxy view and replace it,
substitute it, for your hidden view.

00:25:52.100 --> 00:25:55.460
You take the hidden view out,
and you put, say, an instance of NSView,

00:25:55.530 --> 00:25:57.320
which doesn't draw anything by default.

00:25:57.370 --> 00:25:58.280
That'll do fine.

00:25:58.280 --> 00:26:01.290
You take an instance of NSView,
set it up with the same

00:26:01.290 --> 00:26:04.140
spring settings in code,
give it the same origin and

00:26:04.290 --> 00:26:06.240
same frame size as your view.

00:26:06.240 --> 00:26:09.640
And as the super view is resized,
as the user drags the corner

00:26:09.640 --> 00:26:12.980
of the window to resize things,
your proxy view will get the

00:26:12.980 --> 00:26:14.840
effects of the auto sizing.

00:26:14.840 --> 00:26:17.740
Then when you want to show
your hidden view once again,

00:26:17.740 --> 00:26:20.890
you simply take the size and
position of the proxy view,

00:26:21.050 --> 00:26:24.220
swap them onto the hidden view,
reinsert it in super view,

00:26:24.220 --> 00:26:26.210
so you've solved that problem.

00:26:27.590 --> 00:26:29.250
Another thing you may need
to be concerned about,

00:26:29.280 --> 00:26:30.970
however, is your key loop.

00:26:31.090 --> 00:26:34.350
Interface Builder enables you
to explicitly define a tabbing

00:26:34.350 --> 00:26:36.000
order for your controls.

00:26:36.000 --> 00:26:38.180
When users hit Tab or
Shift Tab on the keyboard,

00:26:38.180 --> 00:26:41.040
they may want to be able to
navigate among your controls

00:26:41.040 --> 00:26:43.620
without using the mouse,
without clicking in them.

00:26:43.620 --> 00:26:46.420
If you've defined an explicit key loop,
you take the view out of its parent,

00:26:46.420 --> 00:26:48.860
well,
it's lost its position in the key loop.

00:26:48.860 --> 00:26:52.070
So when you go to show it again,
you may need to figure out where

00:26:52.390 --> 00:26:53.960
does it go in the key loop.

00:26:53.970 --> 00:26:58.980
You'll have to reinsert it explicitly
where it belongs in the key loop.

00:26:58.990 --> 00:27:00.620
Also, if the view,
if you're using tool tips,

00:27:00.690 --> 00:27:03.190
if you have any cursor rects
or tracking rectangles that

00:27:03.190 --> 00:27:06.620
you've defined on that view,
you may also need to manage them

00:27:06.620 --> 00:27:08.700
when you hide and show the view.

00:27:08.700 --> 00:27:12.210
Now, it's pretty rare that you'll have
a given view that you want to hide

00:27:12.210 --> 00:27:13.640
for which all these things apply.

00:27:13.640 --> 00:27:15.480
You may not be using
all of these features.

00:27:15.480 --> 00:27:18.380
So in general, the remove from super view
technique works quite well,

00:27:18.380 --> 00:27:21.220
and you usually don't have to
worry about all this complexity.

00:27:21.220 --> 00:27:22.440
John Randolph,
Troy Stephens Another thing you

00:27:22.440 --> 00:27:22.440
may need to be concerned about,
however, is your key loop.

00:27:22.440 --> 00:27:22.440
Interface Builder enables you
to explicitly define a tabbing

00:27:22.440 --> 00:27:22.440
order for your controls.

00:27:22.440 --> 00:27:23.440
When you hit Tab and you hit Save,
it will automatically show the key loop.

00:27:23.440 --> 00:27:24.840
However,
you may be wondering at this point, well,

00:27:24.840 --> 00:27:27.680
this is a little strange for Cocoa,
a little atypical.

00:27:27.680 --> 00:27:30.320
Usually,
Cocoa makes simple things simple, right?

00:27:30.320 --> 00:27:32.080
So can't we make this a little simpler?

00:27:32.080 --> 00:27:35.490
Can't we have a simpler way where
we can just send a message to a

00:27:35.490 --> 00:27:39.200
view and ask it to hide itself,
let AppKit take care of all of it?

00:27:39.200 --> 00:27:41.560
Something maybe sort of like this.

00:27:41.560 --> 00:27:44.450
Well, by popular demand,
this is a new API in Panther,

00:27:44.450 --> 00:27:46.950
as Elie Ozer mentioned
in the Cocoa update talk,

00:27:47.270 --> 00:27:47.850
set hidden.

00:27:47.850 --> 00:27:51.870
You'll notice the method signature
is the same as the set enabled call.

00:27:51.930 --> 00:27:51.940
That's a new API.

00:27:51.940 --> 00:27:51.940
And you'll notice that the method
signature is the same as the set enabled

00:27:51.940 --> 00:27:51.940
call that's available in the app.

00:27:51.940 --> 00:27:51.940
And you'll notice that the method
signature is the same as the set enabled

00:27:51.940 --> 00:27:51.940
call that's available in the app.

00:27:51.940 --> 00:27:53.050
And you'll notice that the method
signature is the same as the set enabled

00:27:53.050 --> 00:27:54.440
call that's available on NS Control.

00:27:54.440 --> 00:27:58.730
You send the same message to show a
view again as you send to hide it.

00:27:58.770 --> 00:28:00.390
You simply vary the bool parameter.

00:28:00.520 --> 00:28:02.540
So to hide a view,
you send it a set hidden

00:28:02.540 --> 00:28:04.270
message with a parameter of yes.

00:28:04.270 --> 00:28:08.550
The view immediately disappears
from the user's perspective.

00:28:08.550 --> 00:28:09.690
It's gone.

00:28:09.960 --> 00:28:13.180
In addition,
any subviews that that view may have,

00:28:13.180 --> 00:28:15.750
and any subviews that
they may in turn have,

00:28:15.750 --> 00:28:16.760
will also disappear.

00:28:16.760 --> 00:28:19.800
Those views are implicitly
hidden by virtue of being

00:28:19.800 --> 00:28:22.180
contained within that view.

00:28:22.720 --> 00:28:24.880
From your perspective as a developer,
however,

00:28:24.880 --> 00:28:26.660
that view is still very much there.

00:28:26.780 --> 00:28:30.100
If you look in the views
parents subviews list,

00:28:30.370 --> 00:28:31.720
you will still see it there.

00:28:31.850 --> 00:28:37.760
As a result, it gets auto-sizing behavior
when its parent view is resized.

00:28:37.870 --> 00:28:39.210
It also stays in the key loop.

00:28:39.300 --> 00:28:40.260
You don't have to worry about it.

00:28:40.260 --> 00:28:42.980
It's ignored when the user
is tabbing through control,

00:28:42.980 --> 00:28:46.290
so you don't go off into the weeds,
as Ali said.

00:28:46.300 --> 00:28:47.630
You don't have to worry about that.

00:28:47.670 --> 00:28:50.940
And also, AppKit automatically takes
care of any tool tips,

00:28:51.130 --> 00:28:53.070
cursor wrecks,
or tracking wrecks you may have.

00:28:53.080 --> 00:28:55.540
Those are temporarily disabled
while the view is hidden.

00:28:55.540 --> 00:28:58.330
Pretty much everything that you
would expect to have to worry about,

00:28:58.330 --> 00:29:00.870
AppKit will automatically
take care of for you.

00:29:00.990 --> 00:29:03.780
In addition,
if you have a view such as an

00:29:03.780 --> 00:29:08.320
OpenGL view or an NSMovie view
that renders to a hardware surface,

00:29:08.320 --> 00:29:10.870
that surface will be ordered
out and automatically ordered

00:29:10.880 --> 00:29:13.570
back in as appropriate.

00:29:13.710 --> 00:29:16.010
So on Jaguar and earlier,
you can use the remove

00:29:16.010 --> 00:29:17.450
from super view technique.

00:29:17.600 --> 00:29:20.150
We've seen some ways that you
can deal with some of the details

00:29:20.150 --> 00:29:22.600
that you may have to worry
about when you're doing that.

00:29:22.630 --> 00:29:24.570
So that works fine on Jaguar and earlier.

00:29:24.630 --> 00:29:29.240
On Panther going forward,
we have the set hidden API that takes

00:29:29.240 --> 00:29:31.750
care of all of this stuff for you.

00:29:31.750 --> 00:29:34.200
It works with any NS view class.

00:29:34.200 --> 00:29:37.590
Hiding views is dead simple in Panther.

00:29:39.480 --> 00:29:42.380
We've given you a way to set a
new kind of state on an object,

00:29:42.520 --> 00:29:45.940
the concept of being hidden,
so it's only natural that we should

00:29:45.940 --> 00:29:49.720
provide some getter accessor methods,
and we have two in this case.

00:29:49.720 --> 00:29:53.150
The reason for this is the
fact that I mentioned earlier,

00:29:53.160 --> 00:29:57.240
that hiding a view is, in effect,
hiding the entire view hierarchy

00:29:57.240 --> 00:29:59.420
that may be rooted at that view.

00:29:59.420 --> 00:30:01.520
An ordinary control
doesn't have subviews,

00:30:01.520 --> 00:30:04.720
but you may have a box or some other
type of view that has subviews.

00:30:05.700 --> 00:30:08.460
When you hide that view, setHidden,
I want to clarify,

00:30:08.460 --> 00:30:10.140
is not a recursive operation.

00:30:10.140 --> 00:30:13.380
When you send setHidden to a view,
it's not like setHidden is then

00:30:13.380 --> 00:30:15.440
recursively sent to all its subviews.

00:30:15.530 --> 00:30:18.220
We don't do it that way,
but rather we implicitly

00:30:18.220 --> 00:30:21.660
take that knowledge that some
superview of a view is hidden,

00:30:21.660 --> 00:30:24.160
and we apply that as state to the view.

00:30:24.160 --> 00:30:28.000
So you can think of isHidden,
the main accessor method,

00:30:28.000 --> 00:30:30.930
as the atomic counterpart to setHidden.

00:30:31.880 --> 00:30:36.260
The value that it returns reflects the
state of the object you are asking,

00:30:36.260 --> 00:30:37.270
and no other.

00:30:37.280 --> 00:30:40.360
By contrast,
we also have this method isHidden,

00:30:40.420 --> 00:30:42.100
or hasHiddenAncestor.

00:30:42.100 --> 00:30:45.110
This answers the question that
you probably more commonly will

00:30:45.110 --> 00:30:46.700
want to be asking about a view.

00:30:46.700 --> 00:30:50.820
I don't care if it's hidden because
somebody asked it specifically to hide,

00:30:50.820 --> 00:30:55.330
or if it has some other view in the view
hierarchy that has been asked to hide.

00:30:55.340 --> 00:30:58.050
I just want to know if
it's hidden from my window.

00:30:58.060 --> 00:31:01.790
And so isHidden, or hasHiddenAncestor,
is the message.

00:31:01.910 --> 00:31:03.210
You can use this message to
send when you want to do that.

00:31:03.250 --> 00:31:05.480
We try to be concise when
we choose method names,

00:31:05.480 --> 00:31:07.700
but above all else,
we also like to be clear.

00:31:07.700 --> 00:31:11.980
So isHidden, or hasHiddenAncestor,
answers that question.

00:31:11.980 --> 00:31:14.500
This is, in some sense,
sort of a convenience method.

00:31:14.500 --> 00:31:17.790
You could implement this yourself
in terms of isHidden quite easily

00:31:17.790 --> 00:31:20.690
by walking up the view hierarchy,
but it's such a common

00:31:20.720 --> 00:31:22.110
question to want to ask.

00:31:22.170 --> 00:31:25.190
We've implemented this for you,
and in fact, that state is cached,

00:31:25.260 --> 00:31:28.440
so it's a very inexpensive
constant time operation to ask

00:31:28.440 --> 00:31:31.850
a view if it's been hidden,
if it has a hidden ancestor, whatever.

00:31:31.880 --> 00:31:35.940
So that's view hiding in Panther.

00:31:36.860 --> 00:31:37.940
That was view hiding in Panther.

00:31:37.940 --> 00:31:41.430
Now I'd like to move on to talking
about optimizing view drawing.

00:31:41.520 --> 00:31:44.860
John showed us some fantastic things
that you can do with the spectacular

00:31:44.860 --> 00:31:47.500
drawing capabilities of Quartz in Cocoa.

00:31:47.500 --> 00:31:52.280
There are some, all of these things,
all of these drawing operations

00:31:52.300 --> 00:31:53.680
have an associated cost.

00:31:53.700 --> 00:31:56.710
And whenever possible,
you of course want to avoid doing

00:31:56.710 --> 00:31:58.240
work that you don't have to do.

00:31:58.550 --> 00:32:02.720
You want to avoid sending instructions
to the Quartz graphics pipeline that

00:32:02.720 --> 00:32:04.500
don't really have to be processed.

00:32:04.500 --> 00:32:06.500
Maybe that drawing is
going to be clipped out.

00:32:06.500 --> 00:32:09.500
And if you can figure that
out at a much higher level,

00:32:09.580 --> 00:32:11.960
then your applications can run
much more quickly and be more

00:32:11.960 --> 00:32:16.500
responsive when the user drags
things around in your view and so on.

00:32:17.840 --> 00:32:20.700
So we'll look at some techniques
that you can use to optimize view

00:32:20.700 --> 00:32:23.440
drawing on all versions of Mac OS X.

00:32:23.490 --> 00:32:26.080
And then we'll also look at some of
the improvements we've been working

00:32:26.080 --> 00:32:30.210
on for Panther to help automatically
improve performance for you.

00:32:30.620 --> 00:32:32.990
Whenever possible,
we like to try to make optimizations

00:32:32.990 --> 00:32:36.240
that require no work on your part,
that enable your applications to

00:32:36.300 --> 00:32:39.440
automatically inherit the benefit
with full compatibility and

00:32:39.440 --> 00:32:42.880
without having to do any additional
using of new API and so on.

00:32:42.900 --> 00:32:48.030
But we also do provide new API that
we'll see that can help you to more

00:32:48.030 --> 00:32:51.720
tightly constrain the drawing you're
doing so that you're sending less down

00:32:51.720 --> 00:32:55.390
to the Quartz graphics pipeline and your
applications can respond faster when the

00:32:55.390 --> 00:32:58.560
user's dragging objects around and so on.

00:32:59.290 --> 00:33:03.330
So first, some things you can do
on all versions of OS X.

00:33:03.640 --> 00:33:07.950
The first thing I want to encourage
you to do here today is to be lazy.

00:33:08.030 --> 00:33:11.120
And you can go back and tell
your manager that I said that.

00:33:11.400 --> 00:33:13.600
I mean this in the most
positive sense of the word.

00:33:13.600 --> 00:33:17.590
As developers, we all know that
laziness can be a virtue.

00:33:17.910 --> 00:33:20.510
Aversion to doing work on
your applications part,

00:33:20.510 --> 00:33:24.150
anyhow, can help you to avoid--

00:33:24.400 --> 00:33:28.320
Having the system, having the CPU,
having the graphics system do work

00:33:28.320 --> 00:33:30.860
that is unnecessary or redundant.

00:33:30.990 --> 00:33:34.480
In particular,
and John touched on this earlier,

00:33:34.530 --> 00:33:37.260
you may have noticed that
NSView has some display methods.

00:33:37.260 --> 00:33:40.620
There is display, display if needed,
display in rect,

00:33:40.620 --> 00:33:42.260
display if needed in rect.

00:33:42.420 --> 00:33:47.260
What these methods do is effectively
demand that a view immediately

00:33:47.480 --> 00:33:49.930
display some portion of itself.

00:33:50.300 --> 00:33:52.230
In other words,
this is a synchronous call.

00:33:52.230 --> 00:33:55.020
By the time the message
send returns to you,

00:33:55.160 --> 00:33:56.570
that view has been drawn.

00:33:56.600 --> 00:34:00.820
But instead, instead of invoking those
display methods directly,

00:34:00.820 --> 00:34:03.420
although they are there for
you to use when appropriate,

00:34:03.420 --> 00:34:06.680
when that's really what you want,
we recommend that you mark areas

00:34:06.680 --> 00:34:08.640
of a view as needing display.

00:34:08.640 --> 00:34:11.260
You can use set needs display in rect,
preferably.

00:34:11.260 --> 00:34:14.520
Rectangles are the primitive
for invalidating parts of views

00:34:14.520 --> 00:34:17.620
when some state in the view
or its object model changes.

00:34:18.310 --> 00:34:20.500
And we also have the set
needs display method,

00:34:20.500 --> 00:34:23.140
which you can use more
generically to just say,

00:34:23.140 --> 00:34:24.260
well, draw this whole view.

00:34:24.260 --> 00:34:26.730
This view needs drawing at
some point in the future.

00:34:26.740 --> 00:34:29.230
This is, of course,
a common paradigm that you'll be

00:34:29.340 --> 00:34:32.540
familiar with from other graphic systems,
other windowing systems.

00:34:32.540 --> 00:34:35.560
By deferring drawing until later, until,
say,

00:34:35.560 --> 00:34:40.130
the end of the current run loop cycle,
what you're doing is enabling the

00:34:40.250 --> 00:34:46.200
app kit to potentially coalesce,
to combine, to satisfy multiple requests,

00:34:46.360 --> 00:34:50.580
to draw a single view or part of a
view with a single drawing operation.

00:34:50.600 --> 00:34:54.830
If you tell a view to
display itself three times,

00:34:54.830 --> 00:34:57.050
it's going to draw itself three times.

00:34:57.080 --> 00:35:01.070
If it receives 100 set
needs display in rect calls,

00:35:01.080 --> 00:35:04.400
it will draw itself at the
end of the run loop once.

00:35:04.480 --> 00:35:07.330
So use set needs display in rect.

00:35:07.450 --> 00:35:09.540
Defer your drawing until
later when possible.

00:35:09.610 --> 00:35:12.420
One of the things that we've
seen on the mailing list is

00:35:12.420 --> 00:35:15.440
people have recommended display,
use of the immediate display methods,

00:35:15.440 --> 00:35:19.520
as a means to get around a problem
we call the coalescing problem,

00:35:19.520 --> 00:35:24.080
an inefficiency that occasionally
appears in certain applications

00:35:24.080 --> 00:35:25.280
in the drawing system.

00:35:25.280 --> 00:35:27.620
We have fixed that
inefficiency in Panther,

00:35:27.620 --> 00:35:28.610
and so we're encouraging you.

00:35:28.620 --> 00:35:30.770
We're saying you no longer
really need to do that.

00:35:30.820 --> 00:35:33.220
Those methods are there for
you to use when you need them,

00:35:33.330 --> 00:35:35.220
when you really need immediate display.

00:35:35.220 --> 00:35:38.220
When you don't,
use set needs display in rect and so on.

00:35:39.710 --> 00:35:43.930
Another thing that you can do to help
us out is only invalidate areas of your

00:35:43.930 --> 00:35:46.260
views that really need to be drawn.

00:35:46.370 --> 00:35:50.490
Ask yourself, is set needs display, yes,
really the best that I can do?

00:35:50.630 --> 00:35:52.830
Oftentimes,
that is the case when you're a

00:35:52.830 --> 00:35:55.240
client external to the view object.

00:35:55.370 --> 00:35:58.400
But if you're the view itself,
and some part of your state has changed,

00:35:58.400 --> 00:36:01.980
well, maybe you know that you only need
to repaint some corner of yourself,

00:36:01.980 --> 00:36:03.720
and you don't need to
redraw your text label.

00:36:03.720 --> 00:36:06.270
Maybe you just need to change
your icon to a different state.

00:36:06.320 --> 00:36:09.290
So rather than marking your entire
self generically-- I know that's

00:36:09.290 --> 00:36:13.440
always the easiest thing to do,
just say, I need display-- mark specific

00:36:13.440 --> 00:36:14.940
areas as needing display.

00:36:15.080 --> 00:36:17.740
And that will save you drawing
work when your drawRect method gets

00:36:17.740 --> 00:36:20.300
called further on down the line.

00:36:20.630 --> 00:36:24.380
In addition,
sometimes people as an optimization have

00:36:24.780 --> 00:36:29.380
consolidated multiple rectangles on their
end before sending a set needs display

00:36:29.380 --> 00:36:35.000
and rect method message to the app kit
in order to avoid method call overhead.

00:36:35.000 --> 00:36:40.000
Let's say you may have a list of
rectangles that you need to draw,

00:36:40.000 --> 00:36:43.610
and you may simply take their union,
take a bounding rectangle that

00:36:43.710 --> 00:36:46.620
contains all those rectangles,
and make only one set needs

00:36:46.620 --> 00:36:50.410
display and rect call to that view,
telling it just draw everything in here.

00:36:50.540 --> 00:36:54.920
We want to encourage you to send those
individual rects to the app kit now,

00:36:54.920 --> 00:36:58.850
because as of Panther and later,
we can now take advantage of that

00:36:58.850 --> 00:37:00.980
information to help you draw less.

00:37:00.980 --> 00:37:02.790
A couple of other things you can do.

00:37:02.790 --> 00:37:06.820
On the receiving end,
when your application

00:37:06.820 --> 00:37:09.010
receives a draw rect call,

00:37:09.240 --> 00:37:10.850
Note that you get a parameter.

00:37:11.050 --> 00:37:14.420
DrawRect gives you a bounding
rectangle that asks you what to draw.

00:37:14.420 --> 00:37:17.790
There are a lot of applications out
there where we see people are just

00:37:17.840 --> 00:37:19.910
drawing the entire contents of the view.

00:37:19.920 --> 00:37:22.200
For some views,
that's not very expensive if

00:37:22.210 --> 00:37:25.280
their content isn't very complex,
but whenever possible,

00:37:25.350 --> 00:37:28.250
you should try to only draw
whatever's in that rectangle,

00:37:28.250 --> 00:37:31.140
because that's all you're
really being asked to do.

00:37:31.140 --> 00:37:34.890
Any other drawing you do is going to
be clipped out automatically anyway,

00:37:34.890 --> 00:37:38.470
so it's cheaper to eliminate it
higher up in the drawing pipeline.

00:37:39.100 --> 00:37:41.630
So here we have an example
DrawRect implementation.

00:37:41.630 --> 00:37:45.100
Supposing we have a view here,
say like SketchView,

00:37:45.250 --> 00:37:49.310
if you've seen the Sketch example,
that draws a list of objects,

00:37:49.410 --> 00:37:53.380
has a set of objects that it draws,
so we simply have a loop where

00:37:53.380 --> 00:37:56.840
we iterate over those objects,
and for each object,

00:37:56.840 --> 00:37:59.700
we use the NSIntersectsRect method.

00:37:59.700 --> 00:38:04.200
Hopefully you're familiar with
the convenience functions that

00:38:04.200 --> 00:38:06.680
are present in NSGeometry.h.

00:38:06.680 --> 00:38:09.080
That's a good place to look if you're
looking for geometry functions.

00:38:09.100 --> 00:38:11.500
It's a function, not a method.

00:38:11.500 --> 00:38:15.930
And so for each object that
we're potentially going to draw,

00:38:15.930 --> 00:38:17.690
we ask, well,
is it inside this rectangle?

00:38:17.700 --> 00:38:20.150
If not, well,
then don't even bother drawing it,

00:38:20.150 --> 00:38:22.450
because it's just going
to get clipped out.

00:38:22.500 --> 00:38:27.490
Doing this alone can save
you a fair amount of drawing.

00:38:28.900 --> 00:38:31.450
One other thing you can use is isOpaque.

00:38:31.750 --> 00:38:35.700
And this is somewhat mysterious
maybe because of the name.

00:38:35.770 --> 00:38:39.060
isOpaque is defined by the NSView class.

00:38:39.060 --> 00:38:41.100
There's a default
implementation that returns no.

00:38:41.100 --> 00:38:45.540
You'll note that most of the
controls in Aqua require some

00:38:45.670 --> 00:38:49.440
drawing to be done behind them in
order to show their complete image.

00:38:49.440 --> 00:38:50.670
Things have rounded corners.

00:38:50.700 --> 00:38:53.260
Even if they don't
really use transparency,

00:38:53.310 --> 00:38:55.990
they don't cover the entire
rectangle that they own.

00:38:56.000 --> 00:38:58.690
They don't cover their entire
frame rectangle with drawing.

00:38:58.780 --> 00:39:02.460
By default, therefore,
the app kit cannot assume that a view

00:39:02.460 --> 00:39:06.680
can be drawn without also having to
cause drawing of all the views behind it,

00:39:06.680 --> 00:39:08.260
because they may provide the background.

00:39:08.260 --> 00:39:12.020
You may have the window itself trying
to draw a textured metal background

00:39:12.160 --> 00:39:15.210
so that then your checkboxes,
checkbox image,

00:39:15.210 --> 00:39:18.710
and then text can be drawn over that.

00:39:19.090 --> 00:39:20.760
So we can't make that
assumption by default,

00:39:20.880 --> 00:39:25.670
but by overwriting isOpaque to return
yes in your custom view classes,

00:39:25.840 --> 00:39:28.180
you can potentially save
a great deal of drawing.

00:39:28.180 --> 00:39:32.770
You tell the app kit that you're
going to cover all of the pixels

00:39:32.860 --> 00:39:37.010
in your view with 100% opacity,
so you don't need any drawing

00:39:37.010 --> 00:39:38.500
to be done behind you.

00:39:38.570 --> 00:39:42.850
This can obviously be a savings if
you're implementing a document view,

00:39:42.880 --> 00:39:44.670
like, say, Sketch View.

00:39:45.010 --> 00:39:48.860
And you have this large document view
that's often covering your entire window,

00:39:48.860 --> 00:39:51.730
and your user maximizes your
window on a cinema display,

00:39:51.950 --> 00:39:53.560
and maybe your window is a metal window.

00:39:53.780 --> 00:39:55.580
I mean,
you obviously want app kit to know that

00:39:55.650 --> 00:39:59.650
it doesn't have to draw that entire
textured metal pattern behind every

00:39:59.950 --> 00:40:03.750
part of your view that is asked to draw,
because it's never going to show through.

00:40:03.860 --> 00:40:07.000
So if the first thing you do in your
DrawRect implementation is to cover

00:40:07.000 --> 00:40:10.770
everything with 100% opaque fill,
then overwrite isOpaque,

00:40:10.770 --> 00:40:13.140
this one line of code,
will be one of the most worthwhile

00:40:13.160 --> 00:40:16.080
things that you've done in your drawing.

00:40:17.090 --> 00:40:18.330
So what's new in Panther?

00:40:18.420 --> 00:40:20.020
What have we changed?

00:40:20.320 --> 00:40:23.510
One of the important things we've
done in the view system is that

00:40:23.610 --> 00:40:28.170
we're preserving areas marked as
needing display in greater detail.

00:40:28.240 --> 00:40:31.600
In Jaguar and earlier,
you may have noticed by experiment that

00:40:31.610 --> 00:40:37.060
each view really only kept a single
rectangle that was marked as needing

00:40:37.060 --> 00:40:39.800
to be drawn for each view instance.

00:40:39.940 --> 00:40:43.380
Any time we would get a set
needs display in rect method,

00:40:44.170 --> 00:40:46.560
every time we would get a set
needs display in rect message,

00:40:46.560 --> 00:40:51.370
we would cumulatively union that
rectangle into any existing rectangle

00:40:51.370 --> 00:40:52.940
that was marked as needing drawn.

00:40:52.940 --> 00:40:57.510
This could lead to unnecessary drawing,
in particular,

00:40:57.770 --> 00:41:01.280
Going to a more sophisticated,
more detailed representation of areas

00:41:01.280 --> 00:41:04.480
needing drawing enabled us to solve
what's called the coalescing problem.

00:41:04.480 --> 00:41:05.760
And you may have seen this in your app.

00:41:06.060 --> 00:41:08.740
Very simply,
you would sometimes see drawing of

00:41:08.740 --> 00:41:13.100
views that were in between other views
that had been asked to draw within

00:41:13.100 --> 00:41:15.220
the same trip through the run loop.

00:41:15.280 --> 00:41:17.680
For example,
we have a UI here where we have

00:41:17.680 --> 00:41:20.900
a checkbox in the upper left
and a button in the lower right

00:41:20.900 --> 00:41:22.760
and a table view in between.

00:41:22.760 --> 00:41:25.700
And let's say that this is wired
up in code so that toggling

00:41:25.700 --> 00:41:28.950
the checkbox toggles the button
to be enabled and disabled.

00:41:29.020 --> 00:41:31.400
So when you toggle the checkbox,
it needs drawing to

00:41:31.400 --> 00:41:32.590
reflect its new state.

00:41:32.650 --> 00:41:34.640
The button needs drawing
to reflect its new state.

00:41:34.710 --> 00:41:38.300
And in the old system,
we would end up drawing the table view

00:41:38.300 --> 00:41:42.760
also because we have to clear the window
background behind that entire rectangle.

00:41:42.800 --> 00:41:46.480
So the fact that we were only maintaining
a single rectangle per view and only

00:41:46.480 --> 00:41:50.350
clipping to that rectangle would
sometimes lead to unnecessary drawing.

00:41:50.360 --> 00:41:51.340
No more in Panther.

00:41:51.860 --> 00:41:54.970
We've addressed this problem,
and we've enabled views to draw

00:41:55.040 --> 00:41:57.340
their contents much more selectively.

00:42:00.250 --> 00:42:01.790
A lot hasn't changed, however.

00:42:01.800 --> 00:42:04.070
We try not to change things
when we don't have to.

00:42:04.250 --> 00:42:06.530
Rectangles are still the
invalidation primitive.

00:42:06.540 --> 00:42:09.710
You still use set needs display
in rect to mark areas of

00:42:09.710 --> 00:42:11.840
your view as needing drawing.

00:42:11.880 --> 00:42:14.770
DrawRect is still the basic
method to override when you're

00:42:14.770 --> 00:42:16.340
creating a custom view subclass.

00:42:16.340 --> 00:42:18.550
So that's where you put
your drawing instructions.

00:42:18.650 --> 00:42:21.480
It is still called once each
time the view needs drawing,

00:42:21.480 --> 00:42:24.630
even though we have this list of
rectangles that need to be drawn.

00:42:24.640 --> 00:42:29.250
We're only calling DrawRect once to ask
you to do all your drawing for that pass.

00:42:29.440 --> 00:42:31.480
In addition, of course,
for compatibility,

00:42:31.480 --> 00:42:34.420
we had to make sure that your
existing DrawRect implementations

00:42:34.420 --> 00:42:39.360
required no modification whatsoever
for your apps to work on Panther.

00:42:40.690 --> 00:42:42.980
So your applications,
I want to emphasize,

00:42:42.980 --> 00:42:47.790
will inherit a great deal of the
benefit of this automatically.

00:42:47.950 --> 00:42:50.860
But we do provide API for you
to get at this information.

00:42:50.860 --> 00:42:54.310
We're keeping around more information
about what's dirty in a view,

00:42:54.310 --> 00:42:55.760
what needs to be drawn.

00:42:55.850 --> 00:42:59.300
And should you take an interest in
that information and want to use it to

00:42:59.300 --> 00:43:01.960
more tightly constrain your drawing,
it is available to you.

00:43:02.040 --> 00:43:04.660
We have this new API,
this new method on NSView,

00:43:04.710 --> 00:43:07.280
getRectsBeingDrawnCount.

00:43:07.320 --> 00:43:11.630
It returns by reference a C style
array and a count of elements in

00:43:11.700 --> 00:43:14.310
that array of NSRect structures.

00:43:14.430 --> 00:43:17.420
You call this on entry
into your drawRect method,

00:43:17.450 --> 00:43:20.410
and it gives you back a list
of rectangles that more tightly

00:43:20.410 --> 00:43:22.180
bounds the area needing drawing.

00:43:22.200 --> 00:43:25.620
AppKit automatically clips
to that list of rectangles.

00:43:25.910 --> 00:43:29.380
This is how we're compatible with
existing drawRect implementations.

00:43:29.410 --> 00:43:31.600
So even if you draw
everything in your view,

00:43:31.600 --> 00:43:34.380
you can even ignore the
arect parameter to drawRect.

00:43:34.680 --> 00:43:39.150
You will be clipped down to just the
area that AppKit wants you to draw.

00:43:40.530 --> 00:43:44.000
Also, you'll note that NS Rect,
that Draw Rect's existing NS Rect

00:43:44.120 --> 00:43:48.300
parameter is still useful as a
bounding box on the area on the set

00:43:48.300 --> 00:43:50.520
of rectangles that you're retrieving.

00:43:50.620 --> 00:43:52.720
So you can use it to do
trivial rejection testing,

00:43:52.720 --> 00:43:55.980
as we'll see,
and more easily reject objects

00:43:55.980 --> 00:43:59.860
very quickly that can't possibly be
within the list that we need to draw.

00:43:59.990 --> 00:44:02.820
Also, you don't need to worry about
managing memory for the Rect list.

00:44:03.110 --> 00:44:04.280
That's taken care of for you.

00:44:04.510 --> 00:44:07.980
It exists for the lifetime
of the Draw Rect invocation.

00:44:08.410 --> 00:44:10.600
So to help make this more concrete,
hopefully,

00:44:10.600 --> 00:44:12.470
here's an illustration we can look at.

00:44:12.580 --> 00:44:15.200
Let's say we have a view,
and we have a list of rectangles

00:44:15.200 --> 00:44:16.920
that have been marked dirty.

00:44:16.920 --> 00:44:22.120
Each of these corresponds to a set needs
display and rect call for the view.

00:44:22.480 --> 00:44:24.260
And there's some redundancy there.

00:44:24.310 --> 00:44:26.450
What would happen on Jaguar and earlier,
as I said,

00:44:26.460 --> 00:44:29.580
is these would be coalesced into
a single rectangle that would be

00:44:29.690 --> 00:44:31.820
sent to draw rect as its parameter.

00:44:31.850 --> 00:44:35.340
That is the rectangle we would clip to,
and that is the rectangle that

00:44:35.340 --> 00:44:36.750
you're being asked to draw.

00:44:36.970 --> 00:44:40.710
Beginning on Panther, however,
we have a list of rectangles

00:44:40.710 --> 00:44:41.890
that we are clipping to.

00:44:42.160 --> 00:44:45.780
We have a list of rectangles that
really more accurately bounds the

00:44:45.780 --> 00:44:47.990
area you're being asked to draw.

00:44:48.610 --> 00:44:52.140
As I said, you still get the bounding
rectangle of those rectangles

00:44:52.470 --> 00:44:55.210
as your parameter to draw rect.

00:44:55.270 --> 00:44:57.580
And you'll notice that there's
some simplification that goes on.

00:44:57.580 --> 00:45:00.310
This isn't just the same thing
as the list of rectangles that's

00:45:00.400 --> 00:45:02.210
been marked as needing display.

00:45:02.470 --> 00:45:04.060
We've eliminated the redundancy.

00:45:04.120 --> 00:45:06.700
And also, these rectangles do
not overlap each other.

00:45:06.700 --> 00:45:10.010
They may abut one another exactly,
but they do not overlap.

00:45:10.090 --> 00:45:12.410
So there's no redundancy there.

00:45:13.400 --> 00:45:15.210
So how would you use this API?

00:45:15.300 --> 00:45:17.720
Well, here we have a sample
drawRect method for a view,

00:45:17.720 --> 00:45:20.610
like a sketch view,
that draws some objects.

00:45:20.680 --> 00:45:24.020
The first thing we do, you'll note,
on entry into drawRect,

00:45:24.080 --> 00:45:26.370
is we invoke getRectsBeingDrawnCount.

00:45:26.560 --> 00:45:28.600
We get the list of rectangles
that are being drawn.

00:45:28.680 --> 00:45:32.010
And then we go into that same loop
over the list of objects that we know

00:45:32.010 --> 00:45:34.290
we need to display in our document.

00:45:34.560 --> 00:45:37.000
For each of those objects,
we first intersect it,

00:45:37.110 --> 00:45:38.840
not with any of the
rectangles in the list,

00:45:38.950 --> 00:45:41.290
but with the single rectangle
parameter to draw rect,

00:45:41.400 --> 00:45:42.140
with the bounding rect.

00:45:42.220 --> 00:45:44.360
This is called the
Trivial Rejection Test.

00:45:44.360 --> 00:45:48.480
We know that if that object that we're
trying to draw does not intersect

00:45:48.480 --> 00:45:52.720
that overall bounding rectangle,
there's no possible way that it could

00:45:52.720 --> 00:45:57.400
intersect any of the sub-rectangles
that we're really needing to draw here.

00:45:57.400 --> 00:45:59.620
So we can reject the object out of hand.

00:45:59.880 --> 00:46:02.100
If it does pass that test,
we then go in and test it

00:46:02.100 --> 00:46:04.830
against the list of rectangles,
usually unless you have a

00:46:04.830 --> 00:46:06.560
pathological case of invalidation.

00:46:06.560 --> 00:46:09.430
That is a list of a
handful of rectangles,

00:46:09.430 --> 00:46:13.220
and if the object intersects
any of those rectangles,

00:46:13.230 --> 00:46:15.410
you go ahead and draw it then.

00:46:15.500 --> 00:46:17.480
So it's sort of a weeding out process.

00:46:17.480 --> 00:46:20.000
In 3D graphics,
this is often called culling,

00:46:20.000 --> 00:46:23.380
to distinguish it from the much
lower level process of clipping,

00:46:23.380 --> 00:46:25.460
where you're talking about
actual fragments being drawn,

00:46:25.460 --> 00:46:26.440
being clipped out.

00:46:26.620 --> 00:46:29.990
At the graphic system level,
if we can eliminate things at

00:46:29.990 --> 00:46:33.200
the document object model level,
then we can eliminate a lot of

00:46:33.200 --> 00:46:35.760
potential processing that would
have to be done for nothing,

00:46:35.760 --> 00:46:37.400
because it's just going
to be clipped out anyway.

00:46:39.100 --> 00:46:40.900
Oh, jumped the gun on myself.

00:46:41.000 --> 00:46:45.300
So this is a common thing to want to do,
to first do the trivial rejection test,

00:46:45.380 --> 00:46:49.280
and then test against a list of
rectangles only if necessary.

00:46:49.380 --> 00:46:53.010
So we provided a convenience
API to make this easier to do.

00:46:53.150 --> 00:46:54.570
Needs to draw rect.

00:46:54.730 --> 00:46:59.100
You pass it in a rectangle that bounds
the thing that you want to draw or want

00:46:59.110 --> 00:47:02.130
to find out if you really need to draw.

00:47:02.520 --> 00:47:06.960
And if that method returns a Boolean yes,
you go ahead and you draw the object.

00:47:06.960 --> 00:47:10.360
So we've taken this code and reduced
it down to this for the simple case.

00:47:10.490 --> 00:47:12.960
You'll note that if you're
running on Panther and later,

00:47:13.080 --> 00:47:16.980
you know that this is really no
more complicated than testing

00:47:16.980 --> 00:47:20.800
against the arect parameter
that we get to draw arect.

00:47:21.030 --> 00:47:22.720
We've got the same
number of lines of code,

00:47:22.720 --> 00:47:25.920
so you can take advantage of
this to very easily weed out

00:47:25.920 --> 00:47:30.110
stuff with almost no effort that
you really don't need to draw.

00:47:30.810 --> 00:47:33.100
So maybe we don't have a list of objects.

00:47:33.100 --> 00:47:35.440
What if we have sort
of a monolithic object,

00:47:35.480 --> 00:47:39.080
like, say,
a PDF image or some other type of image?

00:47:39.190 --> 00:47:42.730
How can we take advantage of this list
of rectangles to draw more efficiently,

00:47:42.740 --> 00:47:46.330
to reduce the amount of drawing
we do to the absolute minimum?

00:47:46.500 --> 00:47:50.030
Well, for an image, for example,
we can look at that rectangle list

00:47:50.080 --> 00:47:53.680
as specifying sections of the image
that we can sort of cookie cutter

00:47:53.680 --> 00:47:58.120
out and blit into just the areas
that we're being asked to draw.

00:47:58.210 --> 00:48:00.540
And that's what we do here
in this draw rec method,

00:48:00.540 --> 00:48:03.140
which is somewhat more complex,
but I want to focus your attention

00:48:03.310 --> 00:48:04.800
on just the parts in orange.

00:48:04.860 --> 00:48:08.080
Again, on entry into draw rec,
we're getting a list of rectangles

00:48:08.080 --> 00:48:10.500
that we're being asked to draw.

00:48:10.900 --> 00:49:20.900
[Transcript missing]

00:49:21.100 --> 00:49:23.760
However, if you have something
like a document view,

00:49:23.760 --> 00:49:26.300
like a sketch view that draws
a lot of complex objects,

00:49:26.300 --> 00:49:30.710
maybe an iCal calendar view,
each of those objects

00:49:30.710 --> 00:49:32.510
in an iCal calendar,
well,

00:49:32.570 --> 00:49:36.020
it's got nice rounded corners to it,
and it's got both fill and an outline,

00:49:36.100 --> 00:49:38.720
and it can be semi-transparent,
and it's got text on it,

00:49:38.720 --> 00:49:40.860
and maybe another little icon in there.

00:49:40.860 --> 00:49:44.870
Each of those things is costly to draw,
and you potentially have a lot of them,

00:49:44.870 --> 00:49:48.800
and maybe you can have this view size
pretty large on your cinema display,

00:49:48.800 --> 00:49:53.000
and be dragging calendar items around,
and for each drag,

00:49:53.080 --> 00:49:55.330
for each time the mouse
moves a little bit,

00:49:55.330 --> 00:49:57.750
you're going to have
to do some redrawing.

00:49:57.760 --> 00:49:59.970
Erase the thing in the old position,
draw it in the new position,

00:49:59.980 --> 00:50:01.410
that's potentially a lot of drawing.

00:50:01.410 --> 00:50:03.420
If you're dragging big
distances in one jump,

00:50:03.420 --> 00:50:05.480
that can be coalesced
into a lot of drawing.

00:50:05.480 --> 00:50:07.940
So, cases like that,
complex document views that

00:50:07.940 --> 00:50:10.780
have a lot of drawing to do,
that have complex content.

00:50:11.140 --> 00:50:14.400
Those are cases where you would
expect that you can get some benefit

00:50:14.480 --> 00:50:18.160
from this slightly additional
complexity in your draw rec method.

00:50:20.180 --> 00:50:23.260
There are some observations we
can make about this last example.

00:50:23.410 --> 00:50:26.560
For one thing,
since we're doing this sort of cookie

00:50:26.560 --> 00:50:30.010
cutter technique that I described of
just drawing sections of the image,

00:50:30.010 --> 00:50:33.290
we don't really need the clipping
that AppKit is providing for us.

00:50:33.370 --> 00:50:36.970
AppKit is enforcing clipping
to the list of rectangles that

00:50:36.970 --> 00:50:38.860
we're being asked to draw.

00:50:38.860 --> 00:50:41.460
But clipping is an expensive operation,
potentially.

00:50:41.460 --> 00:50:46.130
It costs a certain amount to set
up that clipping state in Quartz.

00:50:46.340 --> 00:50:50.230
And if you have a disjoint set of
rectangles that you're clipping to,

00:50:50.230 --> 00:50:53.500
that can be more expensive than, say,
clipping to a single rectangle,

00:50:53.500 --> 00:50:55.870
or better yet, not clipping at all.

00:50:55.880 --> 00:50:59.710
So if we don't need this clipping,
isn't there some way we can avoid

00:50:59.710 --> 00:51:02.870
the performance cost that's involved
in setting it up and using it?

00:51:02.880 --> 00:51:05.880
And in fact,
we can now with a new API in Panther,

00:51:05.900 --> 00:51:07.880
wants default clipping.

00:51:07.880 --> 00:51:11.000
NSView has a default
implementation that returns yes.

00:51:11.000 --> 00:51:15.130
You can override this to return no
to tell the AppKit that your view is

00:51:15.190 --> 00:51:18.010
going to be responsible for itself,
that you promise you're

00:51:18.210 --> 00:51:20.270
not going to draw,
that you're not going to draw anything

00:51:20.350 --> 00:51:21.660
that lies outside of those recs.

00:51:21.660 --> 00:51:24.580
You're going to draw exactly
within those boundaries.

00:51:24.580 --> 00:51:27.880
And by doing so,
you can reap the benefits of not

00:51:27.880 --> 00:51:30.040
having that clipping set up for you.

00:51:30.040 --> 00:51:33.590
Whether this is important or not, again,
whether this makes a difference in your

00:51:33.650 --> 00:51:38.570
application depends a great deal on
how often your view is asked to draw,

00:51:38.570 --> 00:51:41.420
how much it's asked to draw,
how complex its content is.

00:51:41.560 --> 00:51:45.490
But this is something that's there
for you to try out if you're really

00:51:45.490 --> 00:51:50.970
focused in on optimizing drawing
performance in a particular view class.

00:51:51.690 --> 00:51:54.680
There are some different possible
implementation strategies that this WANs

00:51:54.680 --> 00:51:56.790
default clipping method frees you to use.

00:51:56.800 --> 00:52:00.100
For example, one thing that we could do,
as we did with the image view,

00:52:00.240 --> 00:52:04.380
we can make our outer loop be over
the list of rectangles to be drawn,

00:52:04.380 --> 00:52:07.020
rather than some list
of objects to be drawn.

00:52:07.140 --> 00:52:08.820
And we can choose to clip.

00:52:09.070 --> 00:52:11.650
We can enforce our own clipping
to one rectangle at a time.

00:52:11.670 --> 00:52:15.620
Just because you override WANs default
clipping and you return no doesn't mean

00:52:15.620 --> 00:52:17.660
you can't enforce your own clipping.

00:52:17.660 --> 00:52:19.720
And maybe you want to
use simpler clipping,

00:52:19.820 --> 00:52:21.760
clipping to a single rectangle at a time.

00:52:21.890 --> 00:52:23.760
Again,
this is very application dependent.

00:52:23.900 --> 00:52:25.540
Depends on the content of your view.

00:52:25.610 --> 00:52:27.300
You have to use your own judgment.

00:52:27.300 --> 00:52:30.130
We encourage you to use
profiling tools like Quartz

00:52:30.130 --> 00:52:33.960
Debug and Sampler to figure out,
well, is your app spending

00:52:33.960 --> 00:52:35.510
a lot of time drawing,
first of all?

00:52:35.770 --> 00:52:39.170
And which views is it spending a lot of
time drawing during different activities?

00:52:39.380 --> 00:52:44.010
Figure out where you can get the benefit,
and then try using these APIs.

00:52:44.530 --> 00:52:48.340
So we've seen a few new APIs in
Panther that we hope you'll find useful.

00:52:48.340 --> 00:52:51.360
We have the concept of being
hidden that is now supported.

00:52:51.360 --> 00:52:54.480
Makes it very easy to hide
views on Panther going forward.

00:52:54.480 --> 00:52:58.560
And we also looked at some techniques
that you can use to almost as easily

00:52:58.560 --> 00:53:01.990
hide your views in Jaguar applications.

00:53:02.240 --> 00:53:05.780
We also introduced some new APIs that
you should be aware of that can

00:53:05.780 --> 00:53:09.450
enable you to do less drawing,
to avoid unnecessary or redundant

00:53:09.450 --> 00:53:11.500
drawing in your custom view classes.

00:53:11.500 --> 00:53:14.540
These are there for you
to use if you want to.

00:53:14.540 --> 00:53:16.640
I don't want you to have
to worry about them.

00:53:16.640 --> 00:53:19.130
If you're implementing a
simple little custom control

00:53:19.140 --> 00:53:21.800
that just draws a few things,
covers a very small area,

00:53:21.800 --> 00:53:23.960
you're probably not going to
get much benefit from these.

00:53:23.960 --> 00:53:27.610
You don't need to worry about it,
and particularly for new Cocoa developers

00:53:27.610 --> 00:53:30.620
who may be with us today,
we want to emphasize that

00:53:30.620 --> 00:53:33.320
you can implement your
draw rec methods as before,

00:53:33.320 --> 00:53:36.520
you can ignore this list of rectangles,
you don't even have to ask for it,

00:53:36.660 --> 00:53:39.200
you can draw and we will
automatically clip for you.

00:53:40.810 --> 00:53:43.400
But it's there for you
to use if you'd like to.

00:53:43.630 --> 00:53:45.370
And with that,
I'd like to invite John Randolph

00:53:45.490 --> 00:53:47.930
back up to do the wrap up,
after which we'll be happy

00:53:47.980 --> 00:53:49.200
to take your questions.

00:53:49.260 --> 00:53:49.700
John?

00:53:49.700 --> 00:53:53.850
Oh.

00:53:55.300 --> 00:53:56.240
Okay, thank you, Troy.

00:53:56.240 --> 00:53:59.240
And I will just mention that all
we've talked about today about

00:53:59.240 --> 00:54:02.180
optimizing your view drawing,
the easiest way to optimize all your

00:54:02.180 --> 00:54:04.430
drawing is just deploy only on new G5s.

00:54:09.090 --> 00:54:10.870
We're working on it.

00:54:11.090 --> 00:54:13.160
Believe me,
there are people in production who

00:54:13.160 --> 00:54:15.370
are burning the midnight oil on that.

00:54:15.490 --> 00:54:18.200
So we talked a little bit today
about how to draw using classes

00:54:18.200 --> 00:54:22.320
in the Cocoa framework and how
that's changing for Panther.

00:54:22.320 --> 00:54:25.790
And I did show you one example of
how to do some fairly sophisticated

00:54:25.860 --> 00:54:27.600
things without a lot of code.

00:54:27.600 --> 00:54:31.080
So we'll just repeat
the Cocoa mantra here.

00:54:31.080 --> 00:54:34.680
Simple things simple and
complex things possible.

00:54:36.180 --> 00:54:38.220
Let me mention the roadmap here.

00:54:38.220 --> 00:54:39.890
Some of these we've already gone past.

00:54:39.920 --> 00:54:43.650
Here are the ones that are coming
up that you might be interested in.

00:54:43.960 --> 00:54:46.560
Cocoa Performance Techniques
tomorrow morning.

00:54:46.560 --> 00:54:49.370
Cocoa Tips and Tricks,
which has a lot of the details about how

00:54:49.370 --> 00:54:55.730
particular clever things were drawn in
some Cocoa apps that Apple has put out.

00:54:56.120 --> 00:55:00.320
Doug Davidson will be giving you
the in-depth talk on what's new

00:55:00.420 --> 00:55:03.280
in Cocoa Text in session 427.

00:55:03.360 --> 00:55:06.920
If you want to talk to us about
what you'd like to see in Cocoa,

00:55:06.920 --> 00:55:10.820
what you'd like changed and so forth,
you can come to the Cocoa Feedback Forum.

00:55:10.820 --> 00:55:14.410
Who to contact about this,
you can reach me often on

00:55:14.660 --> 00:55:16.700
the Cocoa Dev mailing list.

00:55:16.770 --> 00:55:22.000
If you have questions about our 2D
drawing API and our 3D drawing API,

00:55:22.000 --> 00:55:26.260
Travis Brown is the Graphics and Imaging
Evangelist in Apple Developer Relations.

00:55:26.260 --> 00:55:30.210
His boss, John Galenzi,
is the guy to go to for other questions

00:55:30.210 --> 00:55:36.910
having to do with how... how we're
evolving our software offerings.

00:55:37.210 --> 00:55:40.560
John is also the guy to go to
to get a UI review of your app.

00:55:40.870 --> 00:55:44.460
He is still the user
experience evangelist.

00:55:44.470 --> 00:55:48.140
And you can also send your
Cocoa questions to developer

00:55:48.140 --> 00:55:50.460
tech support at DTS@apple.com.

00:55:52.140 --> 00:55:57.480
So there's also this mailing list called
Cocoa Feedback at group.apple.com.

00:55:57.480 --> 00:56:02.390
I know the managers of the
Cocoa Frameworks teams read that list.

00:56:02.450 --> 00:56:04.140
Most of the engineers do, too.

00:56:04.140 --> 00:56:08.860
If you want to get an idea into
our collective consciousness,

00:56:08.860 --> 00:56:12.080
then you can send it to Cocoa Feedback.

00:56:12.080 --> 00:56:14.690
I would suggest that you
also file feature requests

00:56:14.690 --> 00:56:16.560
at bugreporter.apple.com.

00:56:16.580 --> 00:56:20.350
And for more information on Cocoa,
there's a host of documentation

00:56:20.400 --> 00:56:23.790
on any machine that's got the
developer tools installed.

00:56:23.800 --> 00:56:27.930
Well, the AppKit reference and so forth.

00:56:28.100 --> 00:56:30.620
There's a lot of sample code
right there on your machine

00:56:30.620 --> 00:56:32.280
in Developer Examples AppKit.

00:56:32.350 --> 00:56:35.180
There's a lot of other
samples up on the DTS website,

00:56:35.180 --> 00:56:39.220
so if you go to developer.apple.com,
click the sample code link,

00:56:39.260 --> 00:56:42.130
click Cocoa after that,
a lot of examples and more

00:56:42.130 --> 00:56:43.590
being added all the time.

00:56:43.600 --> 00:56:46.560
Today, there's a very good selection.

00:56:46.580 --> 00:56:47.770
We're going to take a look at the
collection of Cocoa books out.

00:56:47.890 --> 00:56:49.840
This was not the case two years ago.

00:56:50.120 --> 00:56:51.840
Today,
there are a lot of them to choose from.

00:56:51.950 --> 00:56:55.140
I see some of the authors
in the audience here.

00:56:55.380 --> 00:57:00.500
And let's see,
there's a couple more book titles here.

00:57:00.680 --> 00:57:04.420
I suggest that you join
the Cocoa Dev mailing list.

00:57:04.470 --> 00:57:07.380
It's a very good place to get
help when you're learning how

00:57:07.500 --> 00:57:10.680
to code in Cocoa or when you're
going for more advanced subjects.

00:57:10.800 --> 00:57:13.810
And I also recommend the
mailing list that's run by

00:57:13.860 --> 00:57:16.020
our friends at the Omni Group,
which you can get at

00:57:16.060 --> 00:57:16.400
the Omni Group website.

00:57:16.400 --> 00:57:16.400
It's a very good place to get
help when you're learning how

00:57:16.400 --> 00:57:16.400
to code in Cocoa or when you're
going for more advanced subjects.

00:57:16.400 --> 00:57:16.400
I also recommend the mailing list that's
run by our friends at the Omni Group,

00:57:16.400 --> 00:57:16.400
which you can get at
the Omni Group website.

00:57:16.400 --> 00:57:18.690
can get to at omnigroup.com.
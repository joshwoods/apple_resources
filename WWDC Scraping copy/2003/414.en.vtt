WEBVTT

00:00:24.660 --> 00:00:25.130
Good morning.

00:00:25.390 --> 00:00:26.300
Thank you for coming.

00:00:26.300 --> 00:00:27.400
My name is John Comiskey.

00:00:27.400 --> 00:00:29.150
I'm an engineer in the
Apple Script Group.

00:00:29.180 --> 00:00:33.350
I want to talk to you
today about three things.

00:00:33.360 --> 00:00:36.700
We're going to talk about
designing a dictionary for a

00:00:36.770 --> 00:00:39.090
newer and existing application.

00:00:39.100 --> 00:00:40.580
We're going to spend
most of our time on that.

00:00:40.610 --> 00:00:44.740
We're also going to talk about
implementing scriptable objects

00:00:44.740 --> 00:00:47.030
to bring that design to reality.

00:00:47.040 --> 00:00:49.390
We're going to focus
mostly on Cocoa scripting.

00:00:49.390 --> 00:00:51.400
That's what I do most of the time myself.

00:00:51.540 --> 00:00:54.340
We're going to talk a little
bit about Carbon at the end.

00:00:54.500 --> 00:00:57.610
And we're also going to talk
about developing tests for your

00:00:57.610 --> 00:00:59.300
scriptability as you go along.

00:00:59.300 --> 00:01:03.730
So you make sure that you don't
backtrack or have any regressions.

00:01:04.090 --> 00:01:07.800
Designing a dictionary is the most
important part of the entire operation.

00:01:07.800 --> 00:01:12.490
Once you've done that,
writing the code is not as hard.

00:01:12.900 --> 00:01:15.780
The thing that we really want to
encourage you to do is to use an

00:01:15.780 --> 00:01:17.280
object model in your dictionary.

00:01:17.280 --> 00:01:20.860
AppleScript functions best when
applications have an object

00:01:20.970 --> 00:01:22.960
model in their dictionary.

00:01:22.980 --> 00:01:25.920
And why do you want to use an
object model in your dictionary?

00:01:26.120 --> 00:01:28.030
Well, I think you already know
the reasons for that.

00:01:28.150 --> 00:01:31.720
You use object-oriented
programming languages yourself.

00:01:31.730 --> 00:01:32.920
You know the benefits of them.

00:01:32.920 --> 00:01:35.940
You wouldn't go back to the old
ways of doing things anyway.

00:01:36.060 --> 00:01:39.840
What we want you to do is to let
scripters have all those same advantages.

00:01:39.860 --> 00:01:42.960
We want them to be able
to reuse your objects.

00:01:42.980 --> 00:01:46.640
You've put time and
effort into those objects.

00:01:46.650 --> 00:01:50.920
If you give the scripter the
opportunity to leverage that,

00:01:50.930 --> 00:01:53.850
that adds value,
helps you sell your product,

00:01:53.960 --> 00:01:57.370
helps you make money,
which is why you're in this business.

00:01:57.950 --> 00:02:00.740
Scriptable applications
are interoperable.

00:02:00.750 --> 00:02:02.590
I like to say two plus two is five.

00:02:02.850 --> 00:02:07.050
Two scriptable applications can do things
that neither one of them can do alone,

00:02:07.270 --> 00:02:11.020
neither one of them can do
while being worked by hand.

00:02:11.050 --> 00:02:15.080
If you've got two or more
scriptable applications,

00:02:15.080 --> 00:02:19.330
they can be combined together into a
super application that does something

00:02:19.330 --> 00:02:21.470
that no one of them can do alone.

00:02:22.200 --> 00:02:24.560
Scriptability,
an object model for scriptability

00:02:24.560 --> 00:02:26.300
offers your user's flexibility.

00:02:26.300 --> 00:02:30.050
When I talk to people about making
their applications scriptable,

00:02:30.060 --> 00:02:32.620
they often say, "Well,
why would anybody want to

00:02:32.620 --> 00:02:35.810
do that?" And my answer is,
"I don't know why and you

00:02:35.920 --> 00:02:39.450
don't know why either,
but your customer knows.

00:02:39.570 --> 00:02:40.840
He knows what he wants to do.

00:02:40.840 --> 00:02:42.870
He knows what problem he needs solved.

00:02:42.900 --> 00:02:46.310
If you give him powerful, recombinable,
reusable objects,

00:02:46.310 --> 00:02:48.320
he can build a solution for himself.

00:02:48.320 --> 00:02:50.540
And you might be surprised
sometimes at what your own

00:02:50.570 --> 00:02:51.990
customers do with your products.

00:02:52.140 --> 00:02:55.870
They can also create new
functionality that's missing.

00:02:55.980 --> 00:02:57.820
Sooner or later,
you have to ship your product

00:02:57.820 --> 00:03:00.570
and you always have a cool new
feature that's almost done,

00:03:00.690 --> 00:03:03.490
but it isn't ready to go and
so you have to leave it out.

00:03:03.620 --> 00:03:08.500
That's always a disappointment,
but it's a reality of being in business.

00:03:08.510 --> 00:03:11.380
AppleScript is the
feature that you forgot.

00:03:11.380 --> 00:03:15.870
Your customers can take AppleScript and
use it to create features that

00:03:15.870 --> 00:03:18.220
are missing from your application.

00:03:18.300 --> 00:03:21.130
If you went to the
AppleScript Studio session yesterday,

00:03:21.230 --> 00:03:23.080
you saw a demo of a-- Yes.

00:03:23.080 --> 00:03:26.390
--application of your application.

00:03:26.390 --> 00:03:29.700
And you saw a demo of your application.

00:03:29.800 --> 00:03:30.720
And you saw

00:03:30.960 --> 00:03:34.450
We were able to create a feature
that's really nice to have,

00:03:34.450 --> 00:03:36.000
but it's missing from Xcode.

00:03:36.040 --> 00:03:38.140
Maybe someday it'll be a
native feature of Xcode,

00:03:38.140 --> 00:03:40.460
but in the meanwhile,
you can use AppleScript to

00:03:40.460 --> 00:03:43.560
write a plugin,
plug it into Xcode, and get a cool new

00:03:43.560 --> 00:03:45.360
feature that wasn't there.

00:03:47.330 --> 00:03:51.860
There are several reasons why you want
to use an object-oriented language,

00:03:52.210 --> 00:03:54.060
an object model in your dictionary.

00:03:54.060 --> 00:03:55.990
And the biggest one is
that AppleScript is an

00:03:56.100 --> 00:03:58.300
object-oriented language itself.

00:03:58.300 --> 00:04:02.240
It's got all the cool things that are in
all the other object-oriented languages:

00:04:02.270 --> 00:04:05.300
inheritance, data hiding,
all of those kinds of things.

00:04:05.300 --> 00:04:08.300
But you only get those benefits
if you use an object model.

00:04:08.300 --> 00:04:11.220
AppleScript is also an
English-like language.

00:04:11.300 --> 00:04:16.200
You write simple declarative sentences
with a verb acting on a direct object

00:04:16.760 --> 00:04:19.300
modified by one or more clauses.

00:04:19.510 --> 00:04:22.920
But you only get that nice
English-like flow if you use an

00:04:22.920 --> 00:04:25.370
object model in your dictionary.

00:04:26.690 --> 00:04:29.060
When you're writing an AppleScript,
you always use tell blocks,

00:04:29.060 --> 00:04:30.390
at least to tell applications.

00:04:30.520 --> 00:04:34.200
But you can also use tell blocks
to shorten the Apple events

00:04:34.200 --> 00:04:35.130
that you have to write.

00:04:35.190 --> 00:04:38.360
If you've got a complex or
deep containment hierarchy,

00:04:38.460 --> 00:04:41.740
you can nest tell blocks,
and then the Apple events that

00:04:41.740 --> 00:04:44.810
you write inside those tell
blocks are shorter and smaller,

00:04:44.910 --> 00:04:47.980
easier to read, easier to understand.

00:04:48.100 --> 00:04:51.740
But this only works if you've
got a containment hierarchy

00:04:51.740 --> 00:04:53.410
in your object model.

00:04:53.720 --> 00:04:57.100
And as I mentioned before,
applications can interoperate.

00:04:57.230 --> 00:04:58.940
There's synergy between applications.

00:04:59.000 --> 00:05:00.600
They already share data.

00:05:00.720 --> 00:05:04.600
What we're talking about is inviting
them into a workflow together.

00:05:04.670 --> 00:05:09.120
You can create a workflow across several
different programs from one vendor or

00:05:09.120 --> 00:05:14.720
several vendors that solve your problem,
your end user's problem.

00:05:14.820 --> 00:05:17.630
And once you've got a workflow like that,
it can be wrapped up in an

00:05:17.630 --> 00:05:21.260
AppleScript Studio application
and become one of these super

00:05:21.370 --> 00:05:22.990
applications that I mentioned.

00:05:23.130 --> 00:05:26.760
You could do something,
some kind of post-production job that has

00:05:26.770 --> 00:05:29.160
to be done over and over and over again.

00:05:29.330 --> 00:05:31.440
It doesn't require a lot
of artistic expertise,

00:05:31.440 --> 00:05:33.920
but it needs to be done,
and it needs to be done a lot.

00:05:34.010 --> 00:05:36.380
That can be turned into
an automated workflow.

00:05:36.490 --> 00:05:40.010
While we're talking about this today,
we're going to be developing some

00:05:40.010 --> 00:05:42.220
regression tests for your own software.

00:05:42.300 --> 00:05:45.510
Those can be put together into
a workflow so that a tester can

00:05:45.520 --> 00:05:49.710
just fire up a Studio application,
run it, come back later and find out what

00:05:49.710 --> 00:05:51.300
the results of the tests were.

00:05:51.770 --> 00:05:52.480
But none of this works if you don't
have a software that's able to do that.

00:05:52.480 --> 00:05:56.760
works unless you use an object
model in your dictionary.

00:05:57.490 --> 00:05:58.860
So what is an object model?

00:05:58.860 --> 00:06:01.420
It's a lot easier to say what it's not.

00:06:01.480 --> 00:06:06.100
This is the implementation of
folder actions from system nine.

00:06:06.130 --> 00:06:07.520
It's not an object model.

00:06:07.520 --> 00:06:09.040
It's five different verbs.

00:06:09.040 --> 00:06:11.880
And you can see pretty
quickly what goes wrong here.

00:06:11.880 --> 00:06:16.720
Two of these verbs have
remove and add in them.

00:06:16.850 --> 00:06:20.380
You could have used make and delete,
which are already standard

00:06:20.380 --> 00:06:22.120
verbs in the standard suite.

00:06:23.060 --> 00:06:28.140
You can also see that these events
have things that ought to be objects

00:06:28.140 --> 00:06:29.760
just embedded right into the verb.

00:06:29.820 --> 00:06:36.220
It takes away the flexibility and the
recombination that an end user can do

00:06:36.220 --> 00:06:41.580
when the verb and the object are sealed
together into a single event like this.

00:06:41.580 --> 00:06:44.990
And you'll also see that a lot
of these end with a preposition.

00:06:45.020 --> 00:06:48.770
And you all know you should never
end a sentence with a preposition.

00:06:48.820 --> 00:06:52.940
Again, this takes away flexibility.

00:06:53.060 --> 00:06:57.190
Prepositional phrases in Apple script
should be parameters and they should

00:06:57.190 --> 00:06:58.810
usually be optional parameters.

00:06:58.820 --> 00:07:02.060
You shouldn't force the user to
describe prepositional phrases

00:07:02.160 --> 00:07:03.800
whether he needs them or not.

00:07:03.820 --> 00:07:07.240
So this is a good
example of a bad example.

00:07:07.280 --> 00:07:11.940
In Panther,
we have done something about this.

00:07:11.940 --> 00:07:15.790
All the old verbs for folder
actions are still there and they

00:07:15.860 --> 00:07:18.340
still work and we actually still
use them ourselves internally.

00:07:18.380 --> 00:07:22.360
But we've also provided an
object model for folder actions.

00:07:22.380 --> 00:07:26.140
The first thing you notice
is the rectangle got smaller.

00:07:26.420 --> 00:07:31.690
You can express all the same
operations in a smaller dictionary

00:07:31.690 --> 00:07:33.140
if it's an object model.

00:07:33.320 --> 00:07:36.130
These two objects can do all
the things that those five

00:07:36.130 --> 00:07:38.130
verbs did plus a lot more.

00:07:38.250 --> 00:07:41.070
You get more for your
money with an object model.

00:07:43.500 --> 00:07:45.690
When you start to design
your object model,

00:07:45.740 --> 00:07:48.710
you should plan for a
full implementation.

00:07:48.790 --> 00:07:49.740
Look into the future.

00:07:49.740 --> 00:07:52.780
We know that you've got to
ship something and you've got a

00:07:52.780 --> 00:07:55.000
limited amount of time to do that.

00:07:55.020 --> 00:07:59.210
But your life's going to be better and
easier a year from now if you've planned

00:07:59.210 --> 00:08:01.250
an object model with room to grow.

00:08:01.560 --> 00:08:09.190
Map out as big an object hierarchy as you
think is meaningful for your application.

00:08:09.260 --> 00:08:11.740
Decide now what things are going
to be called in the future so that

00:08:11.740 --> 00:08:16.020
we don't run into the problem of
all the good names have been taken.

00:08:16.040 --> 00:08:18.390
And define as much
functionality as possible.

00:08:18.540 --> 00:08:21.700
Everything that someone can do by
hand with your program is a very

00:08:21.700 --> 00:08:23.560
good candidate for scriptability.

00:08:23.820 --> 00:08:27.150
Some high-powered operations
that might not be suitable to

00:08:27.150 --> 00:08:31.070
be done by hand might also be
targets for scriptability as well.

00:08:31.500 --> 00:08:34.690
Your scripting implementation
may in the end actually be more

00:08:34.780 --> 00:08:36.960
powerful than your GUI presentation.

00:08:39.070 --> 00:08:41.240
Now you've planned for the future.

00:08:41.240 --> 00:08:44.010
You've planned this huge object model,
and now you don't have

00:08:44.400 --> 00:08:46.350
time to implement it all.

00:08:46.630 --> 00:08:49.420
You're going to have to scale
back for your first release

00:08:49.420 --> 00:08:50.740
and only do part of it.

00:08:50.910 --> 00:08:54.570
When you decide what you are going to do,
it's important to include

00:08:54.950 --> 00:08:58.970
a minimal functional set,
enough objects and enough verbs to do

00:08:59.020 --> 00:09:02.350
at least one interesting operation,
something that some customer's

00:09:02.350 --> 00:09:03.490
been bugging you about.

00:09:03.520 --> 00:09:07.590
If you pick a set of objects that
allows you to perform that function,

00:09:07.590 --> 00:09:09.490
you know you've got a
minimal functional set.

00:09:11.510 --> 00:09:15.000
There's sometimes things
in your application,

00:09:15.000 --> 00:09:18.500
it's hard to think how you might
use them through scriptability.

00:09:18.500 --> 00:09:21.500
There's complex interactions.

00:09:21.500 --> 00:09:26.570
One example in network setup,
you've got an IP address and

00:09:26.610 --> 00:09:27.810
you've got a router address,
and they're not

00:09:27.810 --> 00:09:28.500
independent of each other.

00:09:28.500 --> 00:09:31.500
If you change one,
you might have to change the other,

00:09:31.500 --> 00:09:34.370
and you have to do it in
a synchronous fashion.

00:09:34.370 --> 00:09:37.490
It's not easy to see how you're
going to do that with AppleScript.

00:09:37.500 --> 00:09:40.500
Maybe the solution for release one is
to just leave those properties running.

00:09:41.500 --> 00:09:44.300
If you make that read-only,
chances are you're using

00:09:44.300 --> 00:09:45.520
a DHCP server anyway.

00:09:45.520 --> 00:09:49.300
You need to know what the IP address is,
but you don't need to change it.

00:09:49.300 --> 00:09:52.380
If you make that read-only,
the information is available,

00:09:52.460 --> 00:09:55.680
the value is there for your user,
and you've skipped a complex

00:09:55.760 --> 00:09:59.320
problem until later when you
have more time to think about it.

00:10:00.290 --> 00:10:04.200
Even if you have a largely read-only
implementation in your first release,

00:10:04.220 --> 00:10:08.200
you should always provide at least
one powerful read-write function

00:10:08.200 --> 00:10:10.200
that can actually do something.

00:10:10.200 --> 00:10:14.170
In the instance of network setup,
that would be the location.

00:10:14.170 --> 00:10:18.310
If a user can switch his
location through scriptability,

00:10:18.530 --> 00:10:21.140
then he really has the power he
needs to do whatever he wants.

00:10:21.200 --> 00:10:24.330
He's got to sit down in advance,
create a number of configurations,

00:10:24.330 --> 00:10:27.200
organize them into locations
that are meaningful for him.

00:10:27.200 --> 00:10:30.110
But once he's done that,
all he needs to do is change the

00:10:30.110 --> 00:10:34.170
location as he moves from city to city,
or from work to home,

00:10:34.280 --> 00:10:38.200
or into a conference room,
or anywhere else he might go.

00:10:40.620 --> 00:10:44.660
The standard suite has a number of
verbs that cover almost everything

00:10:44.660 --> 00:10:46.600
you're ever going to want to do.

00:10:46.600 --> 00:10:51.440
Get and set are used on
properties of your objects.

00:10:51.600 --> 00:10:57.550
Exists, count, make,
and delete are pretty much implemented

00:10:57.760 --> 00:11:00.130
for you by Cocoa scripting.

00:11:00.130 --> 00:11:02.020
There's not a lot that you have to do.

00:11:02.080 --> 00:11:05.090
If you create scriptable
objects according to the pattern

00:11:05.120 --> 00:11:10.000
that Cocoa scripting expects,
these four verbs are just going to work.

00:11:10.000 --> 00:11:12.220
Then in the standard suite,
all that's left is six other

00:11:12.220 --> 00:11:14.690
verbs that act on objects,
things like print and save,

00:11:14.690 --> 00:11:17.500
where you're going to really
have to write some code yourself,

00:11:17.530 --> 00:11:20.130
and quit to quit the entire application.

00:11:20.360 --> 00:11:23.950
We think the 13 verbs in the
standard suite will cover most of

00:11:23.950 --> 00:11:27.170
what you're going to want to do,
and you should always try

00:11:27.170 --> 00:11:30.580
to use them first before you
create a verb of your own.

00:11:30.920 --> 00:11:34.030
If you use an object model
along with the standard suite,

00:11:34.110 --> 00:11:37.000
you get this multiplicative effect.

00:11:37.120 --> 00:11:40.240
If your object model has, say,
three objects with an average

00:11:40.240 --> 00:11:43.980
of ten properties each,
and they can all be get and set,

00:11:44.160 --> 00:11:46.600
that's 60 operations you
can perform right there.

00:11:46.800 --> 00:11:50.980
If those three objects also respond to
the ten other verbs that act on objects,

00:11:50.980 --> 00:11:53.760
and remember,
four of those ten are done for you,

00:11:53.800 --> 00:11:58.250
that's another 30 operations that
your application can perform,

00:11:58.250 --> 00:11:59.620
plus one more, quit.

00:11:59.800 --> 00:12:03.080
So that's 91 things that
your application can do,

00:12:03.130 --> 00:12:06.800
and you've hardly written any
code at all at this point.

00:12:09.390 --> 00:12:12.790
One thing we tell people not to
do is to create a bunch of verbs.

00:12:12.820 --> 00:12:15.390
You saw what happened
with folder actions.

00:12:15.400 --> 00:12:17.060
We created a bunch of verbs.

00:12:17.060 --> 00:12:17.720
It worked.

00:12:17.920 --> 00:12:20.440
It covered the problem
that we needed solved,

00:12:20.600 --> 00:12:21.680
but it was kind of a dead end.

00:12:21.680 --> 00:12:23.300
It couldn't do anything more than that.

00:12:23.300 --> 00:12:28.790
So we discouraged the
creating of a lot of verbs.

00:12:29.090 --> 00:12:33.420
The temptation is there to do that,
to just take an existing API and expose

00:12:33.570 --> 00:12:37.020
it as a lot of AppleScript verbs,
but it doesn't give you the

00:12:37.020 --> 00:12:39.300
power that an object model does.

00:12:40.000 --> 00:14:18.400
[Transcript missing]

00:14:20.340 --> 00:14:24.440
If you do need a verb,
go ahead and create it.

00:14:24.540 --> 00:14:27.140
First, you should look at the standard
verbs and make sure there's

00:14:27.210 --> 00:14:29.180
nothing there that you can use.

00:14:29.360 --> 00:14:31.220
But once you've decided
that that's the case,

00:14:31.280 --> 00:14:34.600
yeah, it's okay to go ahead
and make your own verbs.

00:14:34.640 --> 00:14:38.890
They should be simple
operations that your application

00:14:38.890 --> 00:14:41.210
performs on its own objects.

00:14:41.390 --> 00:14:46.390
And the names of these verbs are going to
come from probably buttons and menu items

00:14:46.450 --> 00:14:48.390
that you already have in your program.

00:14:48.550 --> 00:14:51.390
Now, that doesn't mean you should
take every button and every menu

00:14:51.390 --> 00:14:52.760
item and turn it into a verb.

00:14:52.790 --> 00:14:55.290
But when you're trying to
figure out what to call a verb,

00:14:55.300 --> 00:14:58.760
you should call it the same
thing you call it in your UI.

00:15:01.610 --> 00:15:05.900
You should try to create verbs that
can be reused on multiple objects.

00:15:05.940 --> 00:15:07.680
That's what the standard
suite is all about.

00:15:07.690 --> 00:15:12.250
It's 13 verbs that we think
you can use everywhere.

00:15:12.570 --> 00:15:15.570
You should try to do the same thing
when you create verbs of your own.

00:15:15.650 --> 00:15:20.270
If you create a verb that only acts
on one object or one kind of object,

00:15:20.320 --> 00:15:25.940
you're slipping back into that procedural
verb problem that we talked about.

00:15:27.330 --> 00:15:30.460
And one thing that you want,
and you want verbs that can

00:15:30.460 --> 00:15:33.640
be reused in your application,
a good place to find them is to

00:15:33.640 --> 00:15:35.640
reuse verbs from other applications.

00:15:35.670 --> 00:15:39.220
Look at the scriptable apps from
Apple and see what's there that

00:15:39.220 --> 00:15:41.610
you might already be able to use.

00:15:41.630 --> 00:15:45.530
If you copy a verb or any other
term from another application,

00:15:45.530 --> 00:15:49.250
you should copy the human readable
term and the four byte code,

00:15:49.250 --> 00:15:49.700
both.

00:15:49.890 --> 00:15:54.010
That's going to make your program
interoperate better with other programs.

00:15:54.010 --> 00:15:58.000
Your dictionary is scoped to your
application and you won't end up in

00:15:58.000 --> 00:16:02.480
collisions with other applications,
but you also won't end up

00:16:02.480 --> 00:16:04.740
in synergy with them either.

00:16:04.740 --> 00:16:07.070
And you should definitely
choose reusable parameters.

00:16:07.070 --> 00:16:09.550
There's a lot of things in
the standard dictionary,

00:16:09.780 --> 00:16:12.390
little prepositional phrases
that modify the verbs,

00:16:12.420 --> 00:16:14.790
that are going to be
of use to you anywhere.

00:16:14.790 --> 00:16:18.950
There's one in there for naming the
target file that you want to write to.

00:16:18.960 --> 00:16:20.220
That can be reused.

00:16:20.220 --> 00:16:22.300
There's others in there for--.

00:16:22.300 --> 00:16:26.200
Or ask me if I should do
something before I quit.

00:16:26.240 --> 00:16:27.710
That might be useful to you.

00:16:27.970 --> 00:16:33.310
Reuse those parameters too and recombine
them with your verbs in different ways.

00:16:35.200 --> 00:18:37.400
[Transcript missing]

00:18:37.590 --> 00:18:42.920
Definitely avoid just exposing
your raw internal API.

00:18:43.000 --> 00:18:48.630
Don't just take all of the commands,
all of the routines in your

00:18:48.630 --> 00:18:51.260
API and just turn them into verbs.

00:18:51.300 --> 00:18:54.940
This is how you end up with a dictionary
with two or three hundred verbs in it.

00:18:54.940 --> 00:18:58.920
It leads to these clunky,
one-dimensional procedural

00:18:58.920 --> 00:19:00.790
verbs that we don't like.

00:19:02.330 --> 00:19:04.100
How do I decide what I'm
going to call these things?

00:19:04.160 --> 00:19:07.100
Where do I get the words that I'm
going to use in my dictionary?

00:19:07.100 --> 00:19:12.990
How do I decide what these things
are and what they're called?

00:19:13.090 --> 00:19:16.540
The best way to do this if you can,
if you've got an existing application

00:19:16.630 --> 00:19:20.500
and you've got users that have
been bugging you for automation,

00:19:20.550 --> 00:19:21.720
interview one of them.

00:19:21.890 --> 00:19:25.120
Sit them down,
maybe sit facing away from them,

00:19:25.120 --> 00:19:28.950
and have them describe to
you what it is they're doing.

00:19:30.020 --> 00:19:33.760
the what they'll do is they'll lead you
through the steps that it takes for them

00:19:33.760 --> 00:19:39.690
to perform an operation by hand write
down what they're saying that that's your

00:19:40.000 --> 00:19:44.520
apple script it's not gonna compile and
it's not gonna run you're gonna have to

00:19:44.520 --> 00:19:49.090
change the the wording so that it fits
in the apple script form but that's not

00:19:49.090 --> 00:19:52.730
the most important part most important
parties you can have to pull out of

00:19:52.830 --> 00:19:57.490
that description the objects that the
person's talking about and make those the

00:19:57.520 --> 00:20:01.860
scriptable objects in your dictionary use
the same words that your customers are

00:20:02.070 --> 00:20:06.160
already using to describe these things
and then they don't have to relearn

00:20:06.160 --> 00:20:10.240
your program for scriptability they look
in the scripting dictionary and they say

00:20:10.240 --> 00:20:14.860
oh i know what that is and they know what
it is because you got the word from them

00:20:15.480 --> 00:20:21.150
So then you define in your dictionary
those objects and properties that

00:20:21.150 --> 00:20:26.220
the user says he needs to do his job,
and you only create new verbs when

00:20:26.240 --> 00:20:31.070
he's doing something that your program
does and other programs don't do that.

00:20:32.210 --> 00:20:35.290
If you don't have the opportunity
to talk to a real live user

00:20:35.360 --> 00:20:40.010
about how he does his work,
maybe your company has technical writers

00:20:40.010 --> 00:20:42.700
and produces some nice documentation.

00:20:42.720 --> 00:20:46.580
In those documents,
there's very often a tutorial

00:20:47.150 --> 00:20:51.400
or a sample session of a user
sitting down using the program.

00:20:51.400 --> 00:20:54.960
This is the same kind of information
that came from the interview.

00:20:54.960 --> 00:20:59.520
That step-by-step tutorial of how
to do something with the program,

00:20:59.520 --> 00:21:02.160
again, that could be in AppleScript.

00:21:02.170 --> 00:21:06.200
You've got to massage the syntax
into the AppleScript form,

00:21:06.250 --> 00:21:09.780
but much more importantly,
you have to create the objects

00:21:10.140 --> 00:21:13.760
that the user is manipulating
so that scriptability will be as

00:21:13.760 --> 00:21:16.050
powerful and more so than the GUI.

00:21:16.160 --> 00:21:19.330
So you define those objects
and properties that are

00:21:19.330 --> 00:21:23.160
in your documentation,
create new verbs if you have to.

00:21:23.160 --> 00:21:27.190
Now you don't have to have separate
documentation for your scripting and for

00:21:27.190 --> 00:21:32.120
the rest of your program because whatever
it's called in the documentation,

00:21:32.120 --> 00:21:32.120
that's what it's called
in the dictionary.

00:21:32.120 --> 00:21:33.570
dictionary.

00:21:35.660 --> 00:21:40.840
If you're out there by yourself
and you don't have customers that

00:21:40.840 --> 00:21:44.680
you can sit down and interview on
a frequent basis and you don't have

00:21:44.680 --> 00:21:48.540
a big tech writing organization,
you can look at your own object model.

00:21:48.540 --> 00:21:51.230
We started out by saying you know
what's good about object models.

00:21:51.280 --> 00:21:52.600
You use them yourself.

00:21:52.710 --> 00:21:55.720
You're using one in your application.

00:21:55.760 --> 00:22:01.030
Look at it and abstract from that
the objects and properties that your

00:22:01.090 --> 00:22:04.390
customers are most likely to need
to do what it is they want to do.

00:22:04.790 --> 00:22:09.450
But if you take this approach,
the most important thing is humanizing

00:22:09.900 --> 00:22:13.420
the programmatic terms that you've used.

00:22:13.620 --> 00:22:16.100
Just reading your source code,
it's too techy,

00:22:16.100 --> 00:22:17.880
it's too hard to understand.

00:22:17.990 --> 00:22:20.710
You have to put this in a
form that an end user is going

00:22:20.710 --> 00:22:22.390
to be able to understand.

00:22:22.820 --> 00:22:25.270
You definitely don't want to
expose absolutely everything

00:22:25.270 --> 00:22:26.400
that's in your program.

00:22:26.490 --> 00:22:29.670
You've probably got a few main objects
that represent the concepts that

00:22:29.730 --> 00:22:31.700
the end user is trying to work with.

00:22:31.870 --> 00:22:35.140
You've also probably got a bunch of
helper objects that do interesting

00:22:35.140 --> 00:22:38.660
and important things that the
customer doesn't need to know about.

00:22:38.790 --> 00:22:41.560
Those helper objects don't belong
in your AppleScript dictionary.

00:22:41.690 --> 00:22:44.700
Just the main conceptual objects do.

00:22:44.700 --> 00:22:47.550
When you're pulling terminology
out of your application,

00:22:47.600 --> 00:22:48.890
you've got to humanize it.

00:22:48.990 --> 00:22:51.570
One of the most important things
is get rid of the inner caps.

00:22:51.690 --> 00:22:58.210
Use separate words with white
space in between them instead.

00:22:58.400 --> 00:23:02.440
Good terminology in AppleScript doesn't
use a lot of capital letters.

00:23:02.440 --> 00:23:06.940
You only want to use capital letters
for acronyms and proper nouns.

00:23:06.940 --> 00:23:10.180
The reason for this is
AppleScript is English-like.

00:23:10.180 --> 00:23:13.420
These terms show up in different
places in an Apple event,

00:23:13.420 --> 00:23:17.560
and if you've got a capital letter
in the middle of an Apple event,

00:23:17.560 --> 00:23:18.740
it looks funny.

00:23:18.810 --> 00:23:21.050
If that capital letter is there
because it's a product name,

00:23:21.070 --> 00:23:21.850
it makes sense.

00:23:21.850 --> 00:23:25.440
But if it's there because it's one
of your verbs or one of your objects,

00:23:25.440 --> 00:23:27.300
it's going to confuse people.

00:23:27.300 --> 00:23:30.120
If you have Boolean properties,
you might have the

00:23:30.120 --> 00:23:31.850
word "is" in your code.

00:23:31.850 --> 00:23:33.180
Leave that out.

00:23:33.210 --> 00:23:34.930
"Is" means something in AppleScript.

00:23:35.000 --> 00:23:36.750
You don't want to make it
part of your terminology.

00:23:36.750 --> 00:23:43.220
And again, only make new verbs if
you really need them.

00:23:43.840 --> 00:23:48.380
The last way that you can go about
it is to look at your own GUI and

00:23:48.380 --> 00:23:50.030
extract an object model from that.

00:23:50.030 --> 00:23:58.650
This one's tricky because you might have
a tendency to script the user interface,

00:23:58.650 --> 00:24:00.600
and that's something
you don't want to do.

00:24:00.770 --> 00:24:03.200
There's a session tomorrow at 3:11
where we're going to talk about

00:24:03.310 --> 00:24:06.960
scripting the user interface and
try to convince you further that

00:24:06.960 --> 00:24:08.700
that's not what you want to do.

00:24:08.700 --> 00:24:12.150
So don't just describe the little
widgets that are on the screen and give

00:24:12.150 --> 00:24:14.700
the user the ability to poke at them.

00:24:14.700 --> 00:24:15.620
Conceptualize it.

00:24:16.120 --> 00:24:18.690
Figure out what it is
that widget represents.

00:24:18.690 --> 00:24:21.490
Maybe it's a property,
maybe it's an object.

00:24:21.780 --> 00:24:24.700
Give it a name and put
it in your dictionary.

00:24:24.700 --> 00:24:26.960
Don't just inventory everything.

00:24:26.960 --> 00:24:29.640
Again,
you'll end up with a long dictionary

00:24:29.640 --> 00:24:31.700
that's hard to find things in.

00:24:31.710 --> 00:24:32.700
Conceptualize.

00:24:32.700 --> 00:24:34.700
What are these things
that I'm manipulating?

00:24:34.700 --> 00:24:36.690
What is it that I'm
trying to do with them?

00:24:36.810 --> 00:24:38.700
What properties do they
have that can be gathered?

00:24:38.700 --> 00:24:42.060
and set.

00:24:42.250 --> 00:24:47.950
When you form the terms themselves,
don't use articles like a, an, and the.

00:24:47.950 --> 00:24:49.210
Leave those out.

00:24:49.490 --> 00:24:52.310
They can be sprinkled in
to your AppleScript later.

00:24:52.410 --> 00:24:55.720
They don't affect the way
that the AppleScript executes,

00:24:55.750 --> 00:24:57.550
but they can make it easier to read.

00:24:57.600 --> 00:25:00.000
If you've embedded them
in your terminology,

00:25:00.100 --> 00:25:03.890
then it's hard for a person writing an
AppleScript to shift them and shuffle

00:25:03.900 --> 00:25:06.370
them to where they ought to belong.

00:25:06.760 --> 00:25:10.030
Also,
avoid personal pronouns like me and my.

00:25:10.510 --> 00:25:13.640
Again,
me and my mean something in AppleScript.

00:25:13.640 --> 00:25:17.040
You don't want to stick
them in your terminology.

00:25:17.040 --> 00:25:18.920
And again,
if you do need to define some verbs,

00:25:18.920 --> 00:25:21.660
you're probably going to find
the terminology for them on an

00:25:21.660 --> 00:25:25.560
existing button or an existing menu
item somewhere in your program.

00:25:25.670 --> 00:25:28.300
Again, don't expose everything.

00:25:28.300 --> 00:25:31.260
Not every menu item
needs to become a verb.

00:25:31.410 --> 00:25:37.080
And the menu items that do need to become
a verb are already in the standard suite.

00:25:37.080 --> 00:25:38.540
At least that's our

00:25:39.630 --> 00:25:42.920
When you're mapping stuff off of
the screen into your dictionary,

00:25:42.920 --> 00:25:45.670
most of the stuff you're looking at is
going to be properties of an object.

00:25:45.680 --> 00:25:49.740
Generally, one window or one pane within
a window is going to represent

00:25:49.740 --> 00:25:53.590
an object and everything inside
that is going to be a property.

00:25:53.600 --> 00:25:58.320
When you map that to your dictionary,
you're going to need to

00:25:58.420 --> 00:26:00.800
pick data types for those.

00:26:00.810 --> 00:26:03.390
The most important one here on
this slide is radio buttons.

00:26:03.700 --> 00:26:07.050
If you have a small,
finite set of values that

00:26:07.180 --> 00:26:10.810
a property can take on,
that should be expressed

00:26:10.810 --> 00:26:12.520
as an enumeration.

00:26:12.520 --> 00:26:16.510
It makes your Apple scripts look nice,
makes them easier to read,

00:26:16.520 --> 00:26:20.370
and it gives the scripter the
notion that he can't set this

00:26:20.370 --> 00:26:22.500
value to just any old thing.

00:26:22.500 --> 00:26:23.960
He's got to pick from this list.

00:26:26.200 --> 00:26:31.800
[Transcript missing]

00:26:31.960 --> 00:26:35.300
to richer relationships
in your object model.

00:26:35.300 --> 00:26:38.660
Some pop-ups are just
replacements for radio buttons.

00:26:38.710 --> 00:26:41.220
And in that case they ought
to be rendered in your

00:26:41.220 --> 00:26:44.580
dictionary as an enumeration,
just like the radio buttons were.

00:26:44.710 --> 00:26:47.680
But other pop-ups actually
represent an element relationship.

00:26:47.720 --> 00:26:50.000
If you change a pop-up at
the top of your window,

00:26:50.040 --> 00:26:52.860
and it changes the entire
contents of the screen,

00:26:52.930 --> 00:26:55.440
and now you're looking at
a different set of data,

00:26:55.480 --> 00:26:59.520
then that pop-up really represents
an element relationship.

00:26:59.570 --> 00:27:03.460
And to go back to our
example of network setup,

00:27:03.460 --> 00:27:09.220
the location is a pop-up in the UI,
but it actually represents an element

00:27:09.280 --> 00:27:12.790
relationship in the object model.

00:27:13.420 --> 00:27:15.050
Same thing with scrolling lists.

00:27:15.160 --> 00:27:17.520
Sometimes a list is
just a list of strings,

00:27:17.540 --> 00:27:20.130
and if that's all it is,
then maybe that's what you should

00:27:20.130 --> 00:27:21.450
be passing back to your user.

00:27:21.450 --> 00:27:25.300
This is a property,
the property is an array of strings.

00:27:25.300 --> 00:27:27.100
But that's not always the case.

00:27:27.100 --> 00:27:31.290
Sometimes a scrolling list actually
represents an element relationship.

00:27:31.300 --> 00:27:34.300
For instance, in the finder,
you've got a scrolling list of files.

00:27:34.300 --> 00:27:38.860
That you would want to render in your
dictionary as an element relationship,

00:27:38.860 --> 00:27:41.300
a relationship between two objects.

00:27:41.750 --> 00:27:48.560
Table views are a rich source
of element relationships.

00:27:49.440 --> 00:27:52.440
This is a simple spreadsheet.

00:27:52.720 --> 00:28:00.740
There's already a table view suite
defined in the standard headers.

00:28:00.740 --> 00:28:04.520
It's got a table which
contains rows and columns.

00:28:04.520 --> 00:28:06.500
The intersection of a
row and column is a cell.

00:28:06.500 --> 00:28:13.240
And each cell can in turn be a container
for an entirely new object hierarchy.

00:28:13.380 --> 00:28:16.790
The contents of a cell in a
spreadsheet might be a chart.

00:28:16.790 --> 00:28:20.660
And the chart has an entire
object hierarchy of its own.

00:28:20.660 --> 00:28:25.210
So this is somewhat of a physical
mapping from your screen to a dictionary.

00:28:25.210 --> 00:28:29.620
If you do something like a spreadsheet
where the user has the opportunity

00:28:29.620 --> 00:28:32.670
to put all different kinds of
data in here and you don't know

00:28:32.670 --> 00:28:35.160
in advance what it's going to be,
a physical mapping like

00:28:35.160 --> 00:28:39.600
this might be appropriate.

00:28:39.600 --> 00:28:39.600
If you...

00:28:40.640 --> 00:28:44.630
If you do know a little bit about the
data that's expressed in a table view,

00:28:44.710 --> 00:28:46.890
then you can make an abstraction.

00:28:47.080 --> 00:28:50.350
In this instance,
this is a page from a database program

00:28:50.350 --> 00:28:52.610
that I wrote just as an experiment.

00:28:52.610 --> 00:28:56.330
The object here, the table itself,
represents a database.

00:28:56.430 --> 00:29:00.560
Instead of calling each line a row,
we're going to call it a record.

00:29:00.580 --> 00:29:03.360
And instead of a row
being divided into cells,

00:29:03.500 --> 00:29:05.140
we're going to have fields.

00:29:05.140 --> 00:29:08.770
And the fields are going to have names,
which happen to be the

00:29:08.770 --> 00:29:10.570
same names as a row.

00:29:10.600 --> 00:29:11.600
The columns are going to
be the same as the columns.

00:29:11.600 --> 00:29:15.220
This is one step up from
the physical mapping.

00:29:15.350 --> 00:29:21.070
The most interesting thing about this
is that Jim Mora is one of the 25

00:29:21.120 --> 00:29:22.190
winningest coaches in NFL history.

00:29:24.950 --> 00:29:27.150
One step up from that
is a conceptual mapping.

00:29:27.280 --> 00:29:28.810
We really know what this is all about.

00:29:28.840 --> 00:29:30.510
This table is for one purpose.

00:29:30.510 --> 00:29:35.280
It's a database, but it's my database and
I control what's in it.

00:29:35.280 --> 00:29:39.970
This is part of the folder
action setup user interface

00:29:39.970 --> 00:29:42.840
that's going to be in Panther.

00:29:42.840 --> 00:29:45.070
Here the container is
the application itself.

00:29:45.070 --> 00:29:45.990
Nobody owns this.

00:29:46.010 --> 00:29:47.500
There isn't a table anymore.

00:29:47.500 --> 00:29:51.960
There's just folder actions and the
application has a bunch of them.

00:29:51.960 --> 00:29:54.400
And every folder action has
a name and a switch that says

00:29:54.440 --> 00:29:56.060
whether it's enabled or not.

00:29:56.130 --> 00:29:59.350
The thing that's not showing here is
there's another scrolling list right

00:29:59.450 --> 00:30:03.230
next to it where every folder action
has a set of scripts attached to it

00:30:03.310 --> 00:30:05.720
and that's an element relationship.

00:30:08.680 --> 00:30:12.940
So when you're designing your dictionary,
we definitely want you

00:30:12.940 --> 00:30:14.670
to use an object model.

00:30:15.110 --> 00:30:19.040
It makes your program fit
in better with AppleScript.

00:30:19.250 --> 00:30:22.760
It makes your program fit in better
with other scriptable applications.

00:30:22.840 --> 00:30:26.800
AppleScript Studio lets
you be part of a workflow,

00:30:27.030 --> 00:30:29.220
lets you be part of a super application.

00:30:29.240 --> 00:30:31.940
Only create new verbs when you have to.

00:30:32.050 --> 00:30:34.740
Use something in the
standard suite if you can.

00:30:34.840 --> 00:30:45.180
Omit certain words from your
terminology that make a mess of things.

00:30:46.220 --> 00:30:46.350
And don't use uppercase unless
it's a proper noun of some kind.

00:30:46.760 --> 00:30:49.950
Go ahead and take things
from other programs.

00:30:50.060 --> 00:30:56.650
The reason scriptable applications
interact the way they do is because

00:30:56.650 --> 00:30:58.850
they use similar terminology.

00:30:58.900 --> 00:31:03.440
This allows you to interact with
other programs at a level above just

00:31:03.440 --> 00:31:06.020
passing back numbers and strings.

00:31:06.210 --> 00:31:09.690
Lay out the entire future as far as you
think you're ever going to be able to go,

00:31:10.170 --> 00:31:12.800
and then implement what you
can in the first release,

00:31:12.800 --> 00:31:16.330
remembering to give your
scripter at least one really

00:31:16.330 --> 00:31:18.100
interesting thing that he can do.

00:31:18.220 --> 00:31:21.320
You have to write a sample script,
so you need at least one

00:31:21.320 --> 00:31:23.440
really interesting thing to do.

00:31:24.350 --> 00:31:29.380
Now you've got your dictionary
and you need to write some code.

00:31:29.380 --> 00:31:31.370
There's three cases that
you can find yourself in.

00:31:31.370 --> 00:31:33.940
If you're really lucky
you're starting from scratch.

00:31:33.940 --> 00:31:37.570
You're building a whole new
application from the ground up.

00:31:37.570 --> 00:31:39.410
You can do whatever you want.

00:31:39.530 --> 00:31:44.850
Much more likely you've got an existing
application and you've been tasked

00:31:44.850 --> 00:31:47.300
with adding scriptability to it.

00:31:47.340 --> 00:31:49.750
You're going to have
to keep what's there,

00:31:49.750 --> 00:31:52.760
keep the GUI functionality,
and add scripting to it.

00:31:52.900 --> 00:31:55.550
You're going to need to
do a little retrofitting.

00:31:55.560 --> 00:32:00.000
The toughest situation is when you've
got a big existing framework that is

00:32:00.000 --> 00:32:05.170
not itself scriptable and you don't have
the opportunity to make it scriptable.

00:32:05.280 --> 00:32:09.500
Perhaps your application is cross
platform and you use a framework that

00:32:09.500 --> 00:32:14.190
makes being cross platform real easy,
but it makes being scriptable real hard.

00:32:19.110 --> 00:32:22.690
So the first case, maximum freedom,
starting from scratch,

00:32:22.690 --> 00:32:26.520
I can do anything I want,
except interview a user who is using the

00:32:26.520 --> 00:32:28.860
program because it doesn't exist yet.

00:32:28.960 --> 00:32:30.200
So how do I do this?

00:32:30.200 --> 00:32:32.600
How do I find,
how do I develop my terminology if

00:32:32.600 --> 00:32:35.000
the program itself doesn't even exist?

00:32:35.320 --> 00:32:39.560
Well, if you're from a large corporation
that has a powerful marketing

00:32:39.560 --> 00:32:44.680
department and they provide you with
detailed specifications in advance,

00:32:44.680 --> 00:32:48.790
that information can be used
to develop the object model for

00:32:48.890 --> 00:32:50.990
your AppleScript dictionary.

00:32:51.060 --> 00:32:53.920
That's not normally the case,
the situation I find myself in.

00:32:53.920 --> 00:32:57.150
I've got some direction,
I've got some goals,

00:32:57.150 --> 00:33:02.480
but I don't have a lot
of real specifications.

00:33:02.600 --> 00:34:20.900
[Transcript missing]

00:34:21.760 --> 00:34:24.900
And when you're done,
you'll have an AppleScript dictionary,

00:34:24.930 --> 00:34:28.600
which is an object model of the
conceptual objects that your

00:34:28.600 --> 00:34:31.700
end user is going to be using,
whether they're scripting

00:34:31.700 --> 00:34:33.400
or using the GUI.

00:34:33.430 --> 00:34:36.930
This can actually be a design
document for your entire application.

00:34:37.140 --> 00:34:43.390
You've got a running start here of how
the entire application should look,

00:34:43.500 --> 00:34:45.570
regardless of scripting.

00:34:46.640 --> 00:34:52.240
One of the things that I do to make
my life easier is I implemented

00:34:52.240 --> 00:34:55.800
a scriptable base class that does
a lot of the common functions.

00:34:55.840 --> 00:34:59.350
This is the promise of
object-oriented programming,

00:34:59.350 --> 00:35:00.600
reusable code.

00:35:00.600 --> 00:35:04.600
So my scripting is mostly done
by this reusable base object.

00:35:04.600 --> 00:35:08.490
It gives me consistent
behavior across all my objects.

00:35:08.630 --> 00:35:12.390
All the objects in a particular program
are going to behave very much the same.

00:35:12.390 --> 00:35:14.610
You won't get a lot of
chattering between them that

00:35:14.610 --> 00:35:15.990
makes them hard to use together.

00:35:16.740 --> 00:35:20.650
If your company develops a
suite of applications and you

00:35:20.720 --> 00:35:24.840
have a scriptable base class,
this is going to give you consistent

00:35:24.840 --> 00:35:26.550
behavior across your applications.

00:35:26.580 --> 00:35:28.940
This is beginning to build the synergy.

00:35:28.950 --> 00:35:31.390
Now these applications
can talk to each other.

00:35:31.400 --> 00:35:32.990
They have similar object models.

00:35:33.000 --> 00:35:35.680
They have similar ways of
describing those object models.

00:35:36.020 --> 00:35:38.160
They can pass things back
and forth that are a level up

00:35:38.260 --> 00:35:39.900
from just strings and numbers.

00:35:39.900 --> 00:35:42.420
Less code is less bugs.

00:35:42.460 --> 00:35:45.800
If you've got a base class that works,
you find you're spending

00:35:45.800 --> 00:35:46.380
very little time on it.

00:35:46.430 --> 00:35:51.040
time debugging it and that's great
because then you can do other stuff.

00:35:51.910 --> 00:35:56.930
My scriptable base class is called
Element because every object in a

00:35:56.930 --> 00:36:01.800
scriptable application's dictionary
is an element of some other object.

00:36:01.800 --> 00:36:05.800
The top-level objects are all
elements of the application itself.

00:36:06.560 --> 00:36:12.710
Good scriptable objects have names,
so I have a way to set and

00:36:12.720 --> 00:36:15.790
get the name of my object.

00:36:27.320 --> 00:36:29.640
In some applications,
you may find that you want

00:36:29.710 --> 00:36:31.380
unique IDs for your objects.

00:36:31.380 --> 00:36:35.170
Databases, especially,
the objects will have

00:36:35.170 --> 00:36:37.270
persistent unique IDs.

00:36:37.520 --> 00:36:41.130
Unique IDs in AppleScript are
guaranteed to be good for one

00:36:41.130 --> 00:36:42.940
launch of the application.

00:36:43.060 --> 00:36:45.880
And in order to create a unique ID that's
good for one launch of the application,

00:36:45.950 --> 00:36:47.500
all you need is a serial number.

00:36:47.640 --> 00:36:52.730
Just never give the same number out to
two different objects and you're okay.

00:36:52.880 --> 00:36:54.200
There's a slight problem with that,
though.

00:36:54.420 --> 00:36:56.920
If somewhere in the
execution of a script,

00:36:56.920 --> 00:36:59.440
that application quits
and then relaunches,

00:36:59.480 --> 00:37:02.100
it will start reusing those unique IDs.

00:37:02.250 --> 00:37:05.540
If you've saved an object specifier
in a script variable and it's

00:37:05.760 --> 00:37:09.450
still hanging around after the
application has quit and relaunched,

00:37:09.590 --> 00:37:15.000
it might now refer to a different object,
and that could be bad.

00:37:15.050 --> 00:37:17.120
One way to get around that
is just use a timestamp.

00:37:17.270 --> 00:37:20.230
You can get the timestamp once when
your application launches or every

00:37:20.230 --> 00:37:21.670
time somebody creates an object.

00:37:21.920 --> 00:37:24.950
Now, even if your application
quits and relaunches,

00:37:25.000 --> 00:37:27.990
it will never generate
the same unique ID again.

00:37:28.070 --> 00:37:31.710
If you need unique IDs for
something like a database,

00:37:32.580 --> 00:37:36.550
That need to persist across several
launches of the application and

00:37:36.550 --> 00:37:40.590
need to stay the same across
several launches of the application.

00:37:40.590 --> 00:37:43.730
Core Foundation provides
something called a UUID,

00:37:43.730 --> 00:37:44.790
and it's great.

00:37:44.790 --> 00:37:47.320
It's got a timestamp in it,
so it has all the

00:37:47.320 --> 00:37:49.030
qualities of a timestamp.

00:37:49.140 --> 00:37:51.860
It's got your Ethernet
hardware address in it,

00:37:51.860 --> 00:37:56.330
so it can even be differentiated from
objects created on other machines.

00:37:56.370 --> 00:38:00.080
And the first part of it is a hash key,
which means if you stick it

00:38:00.080 --> 00:38:04.440
into a hash table or a binary,
the IDs will spread out across

00:38:04.440 --> 00:38:08.580
the range and they won't cluster
together like if you were just

00:38:08.580 --> 00:38:10.770
using a plain old timestamp.

00:38:12.930 --> 00:38:17.170
Every good scriptable object needs to be
able to send back an object specifier to

00:38:17.180 --> 00:38:25.340
describe itself so that that same object
can be retrieved later in the script.

00:38:25.820 --> 00:38:31.090
In my ScriptableBase class,
I've implemented a cascade that

00:38:31.090 --> 00:38:35.420
creates an object specifier for
every object and tries to create the

00:38:35.420 --> 00:38:37.340
best object specifier that it can.

00:38:37.340 --> 00:38:41.010
If unique ID is defined in the
dictionary for this object,

00:38:41.010 --> 00:38:45.110
I go ahead and use that, unless,
of course, there isn't one.

00:38:45.160 --> 00:38:48.760
If there is no unique
ID defined in the dictionary,

00:38:48.870 --> 00:38:52.980
then I look and see if name
is defined in the dictionary.

00:38:53.690 --> 00:38:56.590
Every good Apple Scriptable object
should have one or the other of

00:38:56.590 --> 00:38:58.400
those defined in the dictionary.

00:38:58.400 --> 00:39:02.440
If it turns out that neither
of those is available,

00:39:02.440 --> 00:39:05.700
then I use an index specifier instead.

00:39:05.700 --> 00:39:07.560
Index specifiers are weak.

00:39:07.560 --> 00:39:11.130
They may not even be good for
one launch of the application.

00:39:11.140 --> 00:39:15.620
If you add or delete any objects at all,
your index specifiers

00:39:15.620 --> 00:39:18.620
are going to change,
and any that you might have stored

00:39:18.680 --> 00:39:21.860
in script variables just aren't
going to be any good anymore.

00:39:21.860 --> 00:39:27.040
Or, they're going to point to a different
object and that could be bad.

00:39:29.130 --> 00:39:33.780
In order to create an object specifier,
you're going to call an API that's

00:39:33.780 --> 00:39:35.680
going to need two pieces of information.

00:39:35.680 --> 00:39:39.220
What container do I belong in?

00:39:39.230 --> 00:39:42.100
And what does my container call me?

00:39:42.260 --> 00:39:44.340
And that's what these
first two things are about.

00:39:44.520 --> 00:39:48.740
Every scriptable object I create
has a pointer back to its parent.

00:39:48.920 --> 00:39:50.920
Do not retain your parent pointer.

00:39:51.040 --> 00:39:53.800
This creates a loop,
and your objects will never go away.

00:39:57.890 --> 00:40:01.350
An object also needs to know
what its parent calls it.

00:40:01.440 --> 00:40:04.620
What element relationship
does it belong to?

00:40:04.670 --> 00:40:06.510
I have a method called siblings.

00:40:06.590 --> 00:40:14.200
It simply passes back the name of
the method that vends this collection

00:40:14.200 --> 00:40:17.410
of objects back to the container.

00:40:17.630 --> 00:40:20.540
These two pieces of information
are going to be necessary to

00:40:20.540 --> 00:40:23.670
create your own object specifier,
so I keep them around all

00:40:23.670 --> 00:40:25.290
the time in all my objects.

00:40:37.400 --> 00:40:43.720
Another thing I do as a favor to myself
is every one of my scriptable objects has

00:40:43.720 --> 00:40:48.160
an NSDictionary in it called attributes.

00:40:48.160 --> 00:40:52.860
And I use this to store the data for
all the properties of the object.

00:40:52.910 --> 00:40:57.580
Now I can take this NSDictionary,
flatten it, write it out to the disk,

00:40:57.800 --> 00:40:59.490
read it back in later.

00:40:59.560 --> 00:41:04.600
If I used a UUID to give it a unique ID,
I've now got a persistent object

00:41:04.600 --> 00:41:09.820
that I can use across several
launches of the application,

00:41:09.820 --> 00:41:13.350
several runs of a script,
several days from now.

00:41:13.460 --> 00:41:18.260
I can go back and get that same data
and use it in a scriptable way again.

00:41:18.310 --> 00:41:20.750
This does not show up in
my AppleScript dictionary.

00:41:20.960 --> 00:41:23.930
Each individual property shows
up in my AppleScript dictionary,

00:41:23.940 --> 00:41:26.570
but physically inside I keep
them all in an NSDictionary.

00:41:26.780 --> 00:41:29.180
It's nice, it's easy,
does a lot of stuff for you.

00:41:32.080 --> 00:41:36.760
Now you need to create
your actual model objects,

00:41:36.810 --> 00:41:39.590
the things that you've decided
to define in your dictionary.

00:41:39.590 --> 00:41:42.140
You're going to want to create
an object that inherits from

00:41:42.140 --> 00:41:44.460
your scriptable base class,
so now you don't have to worry about

00:41:44.460 --> 00:41:45.830
names or IDs or object specifiers.

00:41:45.870 --> 00:41:47.480
That's all done.

00:41:48.280 --> 00:41:51.200
You are going to need to
initialize this object.

00:41:51.230 --> 00:41:55.440
The way Cocoa scripting works,
it creates an object first,

00:41:55.490 --> 00:42:00.200
then it calls the various set
methods to set the parameters.

00:42:00.210 --> 00:42:03.560
To work with this,
you need to have an init method

00:42:03.560 --> 00:42:06.200
that doesn't take any parameters.

00:42:06.200 --> 00:42:10.200
It has to create an object
that's ready to use right now.

00:42:10.200 --> 00:42:15.190
To do that, you might need to do some
defensive programming.

00:42:15.200 --> 00:42:18.190
Make sure that checking pointers
for nil and things like that.

00:42:18.280 --> 00:42:22.190
That object has to be safe to use right
away because the way Cocoa is going to

00:42:22.190 --> 00:42:25.580
use it is it's going to allocate it,
it's going to initialize it,

00:42:25.580 --> 00:42:29.200
and then it's going to call the
set methods to set what's in it.

00:42:29.200 --> 00:42:32.100
If it's not safe to do that,
you're going to have trouble.

00:42:32.770 --> 00:42:37.240
Cocoa scripting is also, well,
not just Cocoa scripting,

00:42:37.240 --> 00:42:39.950
but Cocoa itself,
is going to expect you to have

00:42:39.950 --> 00:42:44.410
a deallocate method so that
you can put away all your toys.

00:42:45.180 --> 00:42:49.500
AppleScript is very memory intensive.

00:42:49.500 --> 00:42:51.220
Cocoa scripting is very memory intensive.

00:42:51.220 --> 00:42:56.040
You create and delete a lot of objects
to process a particular Apple event.

00:42:56.090 --> 00:42:58.920
You want to make sure
that you're not leaking.

00:42:59.430 --> 00:43:03.910
So you want to make sure that you chain
to any deallocation methods from any

00:43:04.090 --> 00:43:07.070
base classes you inherit from as well.

00:43:08.740 --> 00:43:12.100
You want your scriptable
objects to have properties.

00:43:12.100 --> 00:43:16.790
And the way you do that in
Cocoa scripting is by creating a method.

00:43:16.990 --> 00:43:27.900
"The property name is the part
that you want to change to the

00:43:27.980 --> 00:43:30.730
property names that you've selected
when you designed your dictionary."

00:43:33.230 --> 00:43:36.510
Your dictionary also has
element relationships.

00:43:36.610 --> 00:43:40.560
And there's varying levels of
support for that that you can do

00:43:40.650 --> 00:43:42.630
in your Cocoa Scriptable Objects.

00:43:42.700 --> 00:43:47.260
The most basic one is to
provide a method that has the

00:43:47.260 --> 00:43:50.180
same name as the element name.

00:43:50.820 --> 00:43:58.310
And it bends back to whoever calls
it an array of objects of that type.

00:43:58.510 --> 00:44:04.600
This is the minimum amount necessary
for a Cocoa scripting application.

00:44:04.640 --> 00:44:07.540
There are more things that you can do
to make your application more efficient,

00:44:07.650 --> 00:44:08.510
but this is the start.

00:44:08.660 --> 00:44:10.550
You have to start here.

00:44:10.600 --> 00:44:14.600
The first time you come through this,
I just want you to create the methods.

00:44:14.600 --> 00:44:16.870
They don't really have to do anything.

00:44:18.750 --> 00:44:22.170
But the element relationships have
to at least fake it a little bit

00:44:22.230 --> 00:44:24.150
so that you can test this stuff.

00:44:24.150 --> 00:44:27.510
We're trying to get to the point
where we can write some test scripts,

00:44:27.700 --> 00:44:30.820
see if our program even works at all,
and then we're going to go back,

00:44:30.890 --> 00:44:33.690
we're going to create this skeleton,
and then we're going to go back

00:44:33.690 --> 00:44:34.950
and put some muscles on it.

00:44:35.480 --> 00:44:38.820
You also, every, everything is an element
of some other object.

00:44:39.130 --> 00:44:42.940
Your top-level objects are going to
be elements of the application itself.

00:44:43.000 --> 00:44:45.420
In order to do that,
you're going to have to add

00:44:45.420 --> 00:44:49.500
element relationship methods
to the NSApplication object.

00:44:49.610 --> 00:44:52.810
We don't want you to have to subclass
NSApplication if you don't want to.

00:44:52.830 --> 00:44:56.120
If you do that for some other reason,
great, but you don't have to

00:44:56.120 --> 00:44:57.300
do it for scripting.

00:44:57.370 --> 00:45:02.240
You can use an Objective-C category
or a delegate to add the methods that

00:45:02.240 --> 00:45:04.580
you need to the application object.

00:45:05.510 --> 00:45:09.750
You may also have properties
of the application.

00:45:09.930 --> 00:45:11.000
There's no place to put these.

00:45:11.000 --> 00:45:15.390
You can't change the list of
IVARs in the NSApplicationObject.

00:45:15.470 --> 00:45:18.840
You could if you subclassed it,
but we want to try to avoid that.

00:45:18.870 --> 00:45:22.000
But since there's only
one application object,

00:45:22.050 --> 00:45:24.900
it's okay to go ahead and
use globals for these,

00:45:24.900 --> 00:45:29.430
for any persistent properties that
the application itself might have.

00:45:29.460 --> 00:45:32.230
Normally,
you want to avoid using globals,

00:45:32.230 --> 00:45:32.790
but this is an instance
where it might be okay.

00:45:35.330 --> 00:45:38.290
Now, you want to be able to
create and delete objects.

00:45:38.330 --> 00:45:40.110
You want to be able to insert
them into collections and

00:45:40.110 --> 00:45:41.360
remove them from collections.

00:45:41.360 --> 00:45:46.560
And Cocoa Scripting, again,
takes the element names that you've

00:45:46.650 --> 00:45:48.890
decided to use in your dictionary,

00:45:49.170 --> 00:45:53.610
creates method names out of them,
and then you write those methods.

00:45:53.780 --> 00:45:58.750
So you want to be able to insert
elements into the element relationship,

00:45:58.760 --> 00:45:59.920
and there's two ways to do that.

00:45:59.990 --> 00:46:03.500
You can do it positionally,
or you can do it independent of position.

00:46:03.500 --> 00:46:07.550
Sometimes doing it
positionally is important.

00:46:07.600 --> 00:46:10.320
If you're creating and deleting windows,
you might want to create

00:46:10.320 --> 00:46:11.470
them in the front,
you might want to

00:46:11.470 --> 00:46:13.310
create them in the back,
you might want to create them

00:46:13.310 --> 00:46:14.540
in between existing windows.

00:46:14.540 --> 00:46:17.200
So you'd want to insert things at index.

00:46:18.630 --> 00:46:22.020
Other things that you create,
there's really no implicit order to them.

00:46:22.020 --> 00:46:23.600
It's okay if they just go at the end.

00:46:23.620 --> 00:46:26.250
In that case,
you can do a simpler insertion

00:46:26.250 --> 00:46:28.260
routine that doesn't take an index.

00:46:28.260 --> 00:46:29.870
Either one of these will work.

00:46:29.980 --> 00:46:33.270
For various reasons,
you may end up wanting to do both.

00:46:33.360 --> 00:46:36.850
These are both going to be
used anytime you make a new

00:46:36.850 --> 00:46:38.400
object in your Apple script.

00:46:38.400 --> 00:46:42.500
You also want to be able to
remove things from the collection.

00:46:42.500 --> 00:46:44.410
That's always done by index.

00:46:44.420 --> 00:46:46.900
That's the way Cocoa scripting works.

00:46:47.700 --> 00:46:50.700
The object may be found in
any one of a number of ways,

00:46:50.710 --> 00:46:53.080
but when it finally gets deleted,
it's going to get deleted

00:46:53.080 --> 00:46:54.540
by index inside your code.

00:46:54.540 --> 00:46:58.210
This gets called by the delete verb.

00:47:00.200 --> 00:47:05.180
There's enhanced element accessors
that can make things more efficient.

00:47:05.180 --> 00:47:09.730
For instance, if you are implementing a
database and you are using

00:47:09.730 --> 00:47:14.880
UUIDs to identify the records,
you could potentially

00:47:14.880 --> 00:47:16.550
have millions of these.

00:47:16.770 --> 00:47:19.280
You don't simply want to have
a method that creates an array

00:47:19.280 --> 00:47:20.520
and passes them all back.

00:47:20.680 --> 00:47:22.290
That's not practical.

00:47:22.290 --> 00:47:25.530
Your program is not
going to work very well.

00:47:25.670 --> 00:47:31.670
There are enhanced methods that allow
you to get objects directly by index,

00:47:31.760 --> 00:47:34.210
by name, and by unique ID.

00:47:34.330 --> 00:47:37.420
These can be a whole lot more
efficient than just searching a big,

00:47:37.420 --> 00:47:38.160
huge array.

00:47:38.290 --> 00:47:41.320
The decision of whether or
not you want to do this is

00:47:41.320 --> 00:47:43.220
a performance consideration.

00:47:43.520 --> 00:47:45.840
You want to build your
program the simple way first,

00:47:45.840 --> 00:47:47.600
measure it, and see if you need it.

00:47:47.690 --> 00:47:50.260
But in the case of millions
of records in a database,

00:47:50.260 --> 00:47:52.980
it's pretty obvious you're
going to need to do this.

00:47:53.160 --> 00:47:55.560
The details for this were
covered in last year's session.

00:47:55.560 --> 00:47:58.360
If you've got the DVDs,
it was session 303.

00:47:58.420 --> 00:48:01.290
If not,
there's a webpage on the developer

00:48:01.290 --> 00:48:03.680
site that tells you a lot about this.

00:48:03.800 --> 00:48:07.920
And on your CDs,
there's Cocoa Scripting release notes,

00:48:08.000 --> 00:48:10.750
which also describes how to do this.

00:48:13.060 --> 00:48:14.370
Now we want to test our objects.

00:48:14.620 --> 00:48:15.620
We've got this skeleton.

00:48:15.620 --> 00:48:17.690
It doesn't really do anything yet.

00:48:17.780 --> 00:48:18.670
We've got a bunch of objects.

00:48:18.700 --> 00:48:20.140
They've got a bunch of phony properties.

00:48:20.140 --> 00:48:22.840
They've got some phony elements.

00:48:22.880 --> 00:48:25.940
We can't really do anything useful yet,
but we can start writing

00:48:25.940 --> 00:48:26.830
our test scripts.

00:48:27.080 --> 00:48:30.980
First thing that I do--

00:48:32.880 --> 00:48:36.780
I put a logging macro in every
single method that I write.

00:48:36.980 --> 00:48:39.790
All the getters, all the setters,
all the element accessors.

00:48:39.790 --> 00:48:43.370
I put a logging macro in there,
and I have a switch here

00:48:43.370 --> 00:48:44.800
that I can turn on and off.

00:48:45.440 --> 00:48:48.750
Whenever I want to test my application,
see what it's doing,

00:48:48.880 --> 00:48:52.150
try to figure out why it's not
handling an Apple event correctly,

00:48:52.180 --> 00:48:55.360
I turn this switch on and run it,
and I get all sorts of

00:48:55.360 --> 00:48:56.740
stuff in the console log.

00:48:56.740 --> 00:48:59.310
But it tells me line by line
where I've been in my program,

00:48:59.320 --> 00:49:01.800
what I did, what I did right,
and what I did wrong.

00:49:06.570 --> 00:49:08.920
It's nice to know where
you've been in your program.

00:49:09.110 --> 00:49:11.680
It's nicer still to know why.

00:49:11.930 --> 00:49:14.020
Cocoa Scripting will help you out there.

00:49:14.140 --> 00:49:16.340
This first line here,
if you type it into your

00:49:16.710 --> 00:49:20.140
terminal application,
it will turn on Cocoa Scripting's

00:49:20.140 --> 00:49:21.640
own logging facility.

00:49:21.670 --> 00:49:24.860
Every time Cocoa Scripting
gets an incoming Apple event,

00:49:24.880 --> 00:49:27.200
it uses your dictionary to parse it,
pull it apart,

00:49:27.260 --> 00:49:29.240
figure out what all the pieces are.

00:49:29.250 --> 00:49:31.540
As soon as Cocoa Scripting
has reached that point,

00:49:31.730 --> 00:49:34.690
if this switches on,
it logs what it thinks that message,

00:49:34.790 --> 00:49:37.600
what it thinks that Apple event says.

00:49:37.620 --> 00:49:41.710
Now that you've got that information of
what the incoming Apple event looks like,

00:49:41.710 --> 00:49:44.400
and then a log of everything
that your program did to try

00:49:44.400 --> 00:49:49.770
to respond to that Apple event,
it can help you a lot in debugging it.

00:49:50.000 --> 00:49:53.830
If you have certain kinds of
errors in your dictionary,

00:49:53.830 --> 00:49:57.800
Cocoa Scripting may not be able
to form a script command out

00:49:57.800 --> 00:49:59.600
of what it is it's received.

00:50:00.020 --> 00:50:02.520
In that case,
you're going to have to go down

00:50:02.520 --> 00:50:05.580
one layer lower and get the
Apple Event Manager to tell you

00:50:05.580 --> 00:50:07.540
what that Apple event looks like.

00:50:07.560 --> 00:50:13.360
Again, you type these commands into
your terminal application.

00:50:13.360 --> 00:50:16.320
You need the first one and
one or more of the others.

00:50:16.400 --> 00:50:20.710
Then you have to launch your
application from inside the terminal.

00:50:20.720 --> 00:50:24.400
Then in the terminal scroll,
you will see Apple Event Manager doing

00:50:24.400 --> 00:50:25.330
the same thing.

00:50:25.780 --> 00:50:29.970
Every time he gets an Apple event,
he tears it apart, looks at it.

00:50:30.370 --> 00:50:34.120
says what he thinks it means
and puts it in the terminal log.

00:50:34.120 --> 00:50:36.310
This is all at a lower level.

00:50:36.320 --> 00:50:38.320
All you're going to see at
this level is four byte codes,

00:50:38.320 --> 00:50:40.600
not very much in the
way of interpretation.

00:50:40.750 --> 00:50:45.220
But it can tell you probably the
reason why Cocoa Scripting is

00:50:45.220 --> 00:50:48.630
having a hard time with that event.

00:50:49.750 --> 00:50:52.000
So then you want to start
writing some scripts.

00:50:52.210 --> 00:50:54.380
And the first script you want
to write is one that probes

00:50:54.380 --> 00:50:57.120
your entire object hierarchy,
touches every object,

00:50:57.140 --> 00:51:00.920
touches every property,
gives you maximum coverage so you can

00:51:00.920 --> 00:51:05.380
see if your program is written correctly.

00:51:06.410 --> 00:51:08.340
With AppleScript,
that's a relatively easy thing to do.

00:51:08.340 --> 00:51:15.300
AppleScript supports the Every modifier,
which is a range specifier that

00:51:15.300 --> 00:51:19.060
says I want to act over the
entire collection of objects.

00:51:19.190 --> 00:51:25.040
And Cocoa Scripting supports for you,
for free, the Properties property,

00:51:25.110 --> 00:51:28.550
which returns a record of all
the properties of a given object.

00:51:28.640 --> 00:51:33.060
So here in the course of just
about nine lines of AppleScript,

00:51:33.330 --> 00:51:38.600
I've managed to probe the entire object
hierarchy of the folder action suite.

00:51:38.680 --> 00:51:41.630
This script tells me
that everything's there,

00:51:41.630 --> 00:51:44.370
everything works,
it's time to go back and

00:51:44.370 --> 00:51:46.230
start writing some code.

00:51:46.950 --> 00:51:50.660
So I'm going to want to go back to
all the methods that I created before,

00:51:50.660 --> 00:51:52.980
all the properties,
all the set properties,

00:51:53.080 --> 00:51:54.570
all the element relationships.

00:51:54.760 --> 00:51:57.330
And I want to populate
them with real data now.

00:51:57.410 --> 00:52:03.390
The element relationships are going
to get their data from various

00:52:03.630 --> 00:52:09.160
APIs or collections of data inside
your program that may already exist.

00:52:11.590 --> 00:52:35.110
And the properties are going to draw
their data from those actual objects.

00:52:35.110 --> 00:52:35.110
Once you've put some
muscles into these routines,

00:52:35.110 --> 00:52:35.110
you can go back and you can
rerun all of your test scripts.

00:52:35.110 --> 00:52:35.110
And you'll see a big
change from the first time.

00:52:35.110 --> 00:52:35.110
The first time, you just got back a bunch
of zeros and missing values.

00:52:35.110 --> 00:52:35.110
This time,
you'll start to get back some real data,

00:52:35.110 --> 00:52:35.110
objects with real names,
and real properties set to real values.

00:52:36.080 --> 00:52:40.000
Once you've reached this point,
you want to write even more test scripts.

00:52:40.000 --> 00:52:43.380
You want to be able to make sure
you don't have any regressions.

00:52:43.400 --> 00:52:45.800
As you add more features,
as you add more capability,

00:52:45.800 --> 00:52:49.000
you want to make sure you don't break
anything that was already working before.

00:52:49.000 --> 00:52:53.350
And one of the things you want to do is
test accessing your objects by all the

00:52:53.350 --> 00:52:56.000
various means that they can be accessed.

00:52:56.000 --> 00:52:58.000
Simplest is index.

00:52:58.000 --> 00:52:59.860
You can just count them and
loop through them and get each

00:52:59.930 --> 00:53:00.950
one and get its properties.

00:53:01.000 --> 00:53:03.930
To do a thorough test
here for folder actions,

00:53:03.930 --> 00:53:08.430
you'd have to have an inner loop that
did the same thing to every script,

00:53:08.430 --> 00:53:10.870
but I ran out of room on this slide.

00:53:11.210 --> 00:53:13.590
You can also access things by name.

00:53:13.600 --> 00:53:15.400
You want to make sure that that works.

00:53:15.580 --> 00:53:21.100
This is going to test an
important part of your program.

00:53:21.100 --> 00:53:25.390
AppleScript does not require
that object names be unique.

00:53:25.600 --> 00:53:28.400
You may,
in the implementation of your program,

00:53:28.400 --> 00:53:30.600
require that these names be unique.

00:53:30.600 --> 00:53:33.600
But one way or the other,
you need to run this test.

00:53:33.640 --> 00:53:35.820
If you've got two objects
with the same name,

00:53:35.820 --> 00:53:39.430
if you allow that,
you should find in this test that you can

00:53:39.430 --> 00:53:40.990
only ever really get to the first one.

00:53:43.530 --> 00:53:45.900
If you support unique IDs,
you want to make sure that

00:53:45.900 --> 00:53:47.260
that kind of access works.

00:53:47.330 --> 00:53:51.420
So you want to write nested
loops here that access every

00:53:51.570 --> 00:53:53.800
object by its unique ID.

00:53:55.830 --> 00:53:57.150
And this is one of the most important.

00:53:57.290 --> 00:54:01.840
Every scriptable object needs to offer
up an object specifier for itself so

00:54:01.940 --> 00:54:05.700
that you can find that same object
again later and do something new to it.

00:54:05.700 --> 00:54:08.700
You've got to make sure that those
object specifiers really work,

00:54:08.700 --> 00:54:12.700
that they really get you back to the same
object that they were supposed to be.

00:54:12.700 --> 00:54:14.550
And so you want to write a test for that.

00:54:14.800 --> 00:54:18.810
Loop through every object,
get an object specifier for it,

00:54:18.810 --> 00:54:22.500
then go back and get the properties
using that object specifier and make sure

00:54:22.500 --> 00:54:25.130
that it's the object you thought it was.

00:54:27.390 --> 00:54:28.890
And you want to make something new.

00:54:29.000 --> 00:54:32.770
You want to create a new element and
insert it into a collection of elements.

00:54:32.890 --> 00:54:37.080
You do that with the make new verb
that's part of the standard suite.

00:54:37.350 --> 00:54:40.990
This is particularly interesting.

00:54:40.990 --> 00:54:40.990
If you do this,

00:54:42.370 --> 00:54:45.380
If you do this with all
of the logging turned on,

00:54:45.410 --> 00:54:47.480
you'll find out a lot about
how your program works,

00:54:47.550 --> 00:54:50.400
you'll find out a lot about
how Cocoa scripting works,

00:54:50.430 --> 00:54:57.080
and you'll see that just to create
a single object and insert it into

00:54:57.100 --> 00:55:00.730
a collection will end up calling

00:55:00.980 --> 00:55:03.680
Every property accessor on
that object and every element

00:55:03.680 --> 00:55:07.680
accessor in the hierarchy all
the way back to the application.

00:55:08.920 --> 00:55:11.870
One of the most powerful features
of AppleScript are "whose"

00:55:11.960 --> 00:55:15.730
clauses that allow you to select
objects based on whether or

00:55:15.730 --> 00:55:17.800
not they satisfy a certain test.

00:55:17.800 --> 00:55:21.730
So you want to make sure that you write
some good tests of "whose" clauses.

00:55:21.800 --> 00:55:25.800
The folder actions supports an
enabled flag for every object.

00:55:25.800 --> 00:55:29.780
So here I've written some "whose" clauses
based on the setting of the enabled flag.

00:55:29.800 --> 00:55:33.170
If you go into your folder actions,
set some of the enabled flags

00:55:33.300 --> 00:55:35.920
to "on," some of them to
"off," and run this script,

00:55:35.920 --> 00:55:37.790
you should get varying results.

00:55:37.800 --> 00:55:43.640
And even though the last two
events look very similar,

00:55:43.960 --> 00:55:44.780
there is a subtle difference.

00:55:44.860 --> 00:55:49.060
The presence of those parentheses will
cause those last two events to actually

00:55:49.380 --> 00:55:51.790
return different collections of objects.

00:55:54.210 --> 00:55:57.500
We talked about some other scenarios
that you could find yourself in.

00:55:57.540 --> 00:56:02.010
Most common is adding scriptability
to an existing application.

00:56:02.090 --> 00:56:05.740
It's a little bit less
flexibility than you had when

00:56:05.830 --> 00:56:10.930
you were starting from scratch,
but you do a lot of the same things.

00:56:11.780 --> 00:56:16.830
One thing that I would suggest is
that you use Objective-C categories

00:56:17.180 --> 00:56:20.300
to add the scripting methods
to an existing application.

00:56:20.300 --> 00:56:24.540
You don't have to go into the
source files for the existing

00:56:24.540 --> 00:56:26.090
objects and actually change them.

00:56:26.090 --> 00:56:28.580
You can put your scripting
in a separate file,

00:56:28.580 --> 00:56:31.700
create it in the form of a category.

00:56:31.860 --> 00:56:36.100
It's a very powerful way of
modifying existing objects,

00:56:36.120 --> 00:56:37.700
but it's also non-intrusive.

00:56:37.700 --> 00:56:41.120
If there's any point in the development
cycle where you have a crisis

00:56:41.130 --> 00:56:44.430
of faith and you think that your
scripting implementation has horribly

00:56:44.430 --> 00:56:47.700
screwed up your application and
you don't know what to do about it,

00:56:47.860 --> 00:56:51.700
you can go into Xcode and simply
uncheck the scripting files,

00:56:51.740 --> 00:56:54.260
rebuild your app,
and try it again and find out

00:56:54.310 --> 00:56:57.060
that maybe it was that guy
next to you that messed it up,

00:56:57.060 --> 00:56:57.660
not you.

00:56:57.670 --> 00:57:00.490
Or maybe it was you,
and then you can fix it.

00:57:00.870 --> 00:57:05.560
Objective-C categories are a great way
of building scriptability alongside your

00:57:05.560 --> 00:57:06.700
existing objects without mucking them up.

00:57:07.700 --> 00:57:13.700
You still do have the issue of an init
method that doesn't take any parameters.

00:57:13.700 --> 00:57:16.690
You might find that your existing
objects aren't built that way,

00:57:16.700 --> 00:57:19.950
that your existing objects
have an init method that takes

00:57:19.950 --> 00:57:22.080
a whole bunch of parameters,
basically setting all of the

00:57:22.080 --> 00:57:26.700
properties at once at the same
time that the object is created.

00:57:26.900 --> 00:57:28.700
Cocoa scripting isn't
going to work that way.

00:57:28.700 --> 00:57:30.690
It's going to want an init
method with no parameters.

00:57:30.690 --> 00:57:32.940
And again,
you've got to make sure that the

00:57:32.940 --> 00:57:35.880
result at the end of that init
method is a safe object whose

00:57:36.240 --> 00:57:36.700
methods can be called right now.

00:57:36.700 --> 00:57:37.700
Objective-C categories are a great
way to build a scripting application.

00:57:37.700 --> 00:57:41.930
and it isn't going to
dereference any nil pointers.

00:57:42.170 --> 00:57:44.400
And again,
you're going to need a deallocate method

00:57:44.400 --> 00:57:46.980
because you're going to be creating
and deleting a lot of these things in

00:57:46.980 --> 00:57:50.860
the course of handling Apple events,
and you don't want to leak.

00:57:53.820 --> 00:57:58.050
Once you've created your categories
alongside your existing objects,

00:57:58.050 --> 00:58:00.410
you're going to have to implement
all of your various properties,

00:58:00.460 --> 00:58:03.400
the getters and setters,
and your element names and

00:58:03.400 --> 00:58:05.200
your element relationships.

00:58:05.230 --> 00:58:07.530
You may find that some of
the properties that you need

00:58:07.580 --> 00:58:10.860
already exist in the objects,
and you just go ahead and reuse them.

00:58:10.890 --> 00:58:15.090
The way that a dictionary is constructed,
the external name for a property

00:58:15.090 --> 00:58:18.280
and its internal name don't
have to be closely related.

00:58:18.460 --> 00:58:21.750
So if you've got a getter
and a setter for the name,

00:58:21.750 --> 00:58:25.170
for instance,
you can just go ahead and reuse that.

00:58:25.410 --> 00:58:30.960
If you find that the AppleScript version
of this getter and setter need to be

00:58:30.960 --> 00:58:34.980
slightly different than the other,
then you can wrap one around the other.

00:58:35.120 --> 00:58:38.070
But one way or another,
you have to satisfy all of

00:58:38.430 --> 00:58:41.350
these properties by creating
methods to access them.

00:58:41.580 --> 00:58:44.220
Same thing with the
element relationships.

00:58:44.230 --> 00:58:46.620
You'll need to create the
element relationships in

00:58:46.620 --> 00:58:47.960
your scripting categories.

00:58:47.970 --> 00:58:50.740
You can't reuse any of the existing ones.

00:58:50.800 --> 00:58:57.300
For instance, NSApplication already has
an ordered documents method,

00:58:57.300 --> 00:58:59.960
and Cocoa Scripting reuses
that for its own purposes.

00:58:59.960 --> 00:59:01.380
There's no reason to create a new one.

00:59:01.400 --> 00:59:04.620
And again,
you want to extend the NSApplication

00:59:04.620 --> 00:59:09.240
so that your top level objects are
all elements of the application.

00:59:09.320 --> 00:59:14.400
And again, we would suggest you use an
Objective-C category or a delegate

00:59:15.110 --> 00:59:17.480
to do that for the same reason.

00:59:17.480 --> 00:59:21.320
You don't have to mess with
the real NSApplication object.

00:59:21.460 --> 00:59:25.360
And while you're doing this,
you should add your logging macro

00:59:25.500 --> 00:59:27.940
to every method that you create.

00:59:28.430 --> 00:59:30.600
Then we're going to want to go through
the same steps we went through before.

00:59:30.600 --> 00:59:33.200
We're going to want to write a
bunch of scripts to test this with,

00:59:33.280 --> 00:59:36.600
even though some of the
functionality might not be there yet.

00:59:36.760 --> 00:59:40.400
Then we want to go back and
add some muscle to our objects,

00:59:40.400 --> 00:59:43.890
fill in those property accessors
so that they get at real data,

00:59:44.080 --> 00:59:49.300
fill in those element accessors so they
pass back collections of real objects.

00:59:49.440 --> 00:59:51.700
Then go back and rerun
all of your scripts,

00:59:51.770 --> 00:59:54.040
and make sure that the differences
you see in the results are

00:59:54.050 --> 00:59:56.200
the ones that you expected.

00:59:58.330 --> 01:00:05.040
The last situation is the toughest one,
and that's adding scriptability

01:00:05.650 --> 01:00:11.950
To a large application that depends on a
framework that is not itself scriptable

01:00:12.290 --> 01:00:16.280
and cannot easily be made scriptable.

01:00:17.750 --> 01:00:19.900
Again, though, you want to go through
most of the same steps.

01:00:19.900 --> 01:00:23.520
You want to define a real
good dictionary first.

01:00:23.710 --> 01:00:27.940
Then you want to define
the scriptable objects,

01:00:27.940 --> 01:00:32.500
properties,
and element relationships that

01:00:32.500 --> 01:00:35.110
bring that dictionary to life.

01:00:35.290 --> 01:00:38.070
And you want to do this as if
you were starting from scratch.

01:00:38.250 --> 01:00:43.110
You've got this existing framework
that you can't penetrate too easily,

01:00:43.110 --> 01:00:45.170
and you want to add
Cocoa Scripting to it.

01:00:45.270 --> 01:00:48.800
Just create the Cocoa Scripting objects
as if you were starting from scratch,

01:00:48.800 --> 01:00:51.200
as if this other application
didn't even exist.

01:00:51.200 --> 01:00:53.200
Do the same thing we did before.

01:00:53.200 --> 01:00:54.950
Give them just enough
functionality so that you can

01:00:54.950 --> 01:00:56.200
write some interesting tests.

01:00:56.200 --> 01:01:00.320
Then you're going to want to go back
and add muscle to these objects by

01:01:00.520 --> 01:01:04.530
taking all of the property accessors and
element accessors and tying them back

01:01:04.530 --> 01:01:10.150
into existing APIs and existing objects
inside the impenetrable framework.

01:01:10.200 --> 01:01:13.200
This is where the complexity can arise.

01:01:13.200 --> 01:01:16.900
The object model that you chose to
express in your AppleScript dictionary

01:01:17.450 --> 01:01:20.880
and the object model that
exists in this impenetrable

01:01:20.880 --> 01:01:22.930
framework might not match up.

01:01:23.200 --> 01:01:27.060
You might have to do some sorting
and searching and recombining of

01:01:27.060 --> 01:01:29.120
things to get them to work right.

01:01:29.200 --> 01:01:31.200
This is where this scenario
can become difficult.

01:01:31.200 --> 01:01:36.160
But when you're done,
or you think you're done,

01:01:36.220 --> 01:01:38.860
you can go back and rerun all of your
scripts that you wrote and see if you

01:01:38.950 --> 01:01:41.200
got the results that you were expecting.

01:01:41.200 --> 01:01:46.200
It should give you an indication
that you've done it correctly.

01:01:49.380 --> 01:01:52.200
We promised that we would
talk about Cocoa and Carbon,

01:01:52.200 --> 01:01:54.640
and we haven't said
anything about Carbon yet.

01:01:54.710 --> 01:01:56.300
So what about Carbon?

01:01:56.610 --> 01:01:59.540
Well,
you can still script a Carbon application

01:01:59.700 --> 01:02:01.620
in the same way that you always have.

01:02:01.750 --> 01:02:06.710
The OSL is still there, it still works,
and you can use it.

01:02:06.930 --> 01:02:11.750
And that's very well documented in the
inter-application communication document.

01:02:11.800 --> 01:02:17.010
Mac Tech is now the guardian of
all the old develop articles.

01:02:17.040 --> 01:02:20.640
This one is a particularly good one,
a cookbook,

01:02:20.740 --> 01:02:24.760
a recipe for taking a Carbon application
and making it scriptable.

01:02:24.900 --> 01:02:27.380
They weren't even called
Carbon applications back

01:02:27.380 --> 01:02:28.720
when this was written.

01:02:28.860 --> 01:02:32.080
So you can do it that way.

01:02:32.470 --> 01:02:35.640
It's not easy,
but we've all done it at least once,

01:02:35.720 --> 01:02:36.790
and it can be done.

01:02:36.790 --> 01:02:42.790
I would suggest that you seriously
consider migrating to Cocoa.

01:02:42.790 --> 01:02:44.800
I know it's not trivial.

01:02:44.910 --> 01:02:53.370
Carbon is a first-class citizen,
and it's going to be supported forever.

01:02:53.890 --> 01:02:58.400
But Cocoa is the way we encourage
you to develop new apps.

01:02:58.440 --> 01:03:00.610
If you reach a point in your
development cycle where you're

01:03:00.610 --> 01:03:03.740
really considering just chucking
it all in and starting over again,

01:03:03.910 --> 01:03:05.880
consider starting over again in Cocoa.

01:03:05.880 --> 01:03:09.310
I wouldn't start over
again just for scripting,

01:03:09.420 --> 01:03:11.030
but it's certainly a factor.

01:03:11.040 --> 01:03:14.350
If you do rewrite your
application in Cocoa,

01:03:14.550 --> 01:03:20.830
Objective-C and Cocoa scripting will make
the scripting part of your job very easy.

01:03:23.100 --> 01:03:26.950
A year ago,
we promised that we would come up

01:03:26.950 --> 01:03:32.000
with an API for Carbon scripting that
was just as easy to use as Cocoa,

01:03:32.000 --> 01:03:34.890
just as powerful,
did all the same things for you,

01:03:34.990 --> 01:03:39.000
leveraged all of that existing power.

01:03:39.000 --> 01:03:41.690
And we thought and thought
and thought of how to do this,

01:03:41.690 --> 01:03:44.380
and it was really hard,
and we were going to end up having

01:03:44.380 --> 01:03:47.000
to rewrite almost everything
that Cocoa scripting did.

01:03:47.000 --> 01:03:52.000
And it occurred to us, well,
maybe we could just use Cocoa scripting.

01:03:52.000 --> 01:03:54.820
So we conducted an experiment
and found out that,

01:03:54.820 --> 01:03:58.000
yes, as a matter of fact,
it pretty much just works.

01:03:58.210 --> 01:04:03.000
You can use Cocoa scripting in
an otherwise Carbon application.

01:04:03.000 --> 01:04:06.960
This is really a special
case of the third scenario.

01:04:07.000 --> 01:04:12.000
You've got this big impenetrable
framework that's hard to make scriptable.

01:04:12.000 --> 01:04:16.500
You want to build a Cocoa scripting
implementation alongside of it and tie

01:04:16.820 --> 01:04:20.150
it into the existing implementation.

01:04:20.430 --> 01:04:23.900
You can actually do that with
any existing Carbon application.

01:04:23.900 --> 01:04:25.900
It's not hard, but it's not trivial.

01:04:25.900 --> 01:04:28.140
There's a few tricks
that you need to know,

01:04:28.140 --> 01:04:32.000
a few modifications you need to make
to your application's startup code.

01:04:32.120 --> 01:04:37.250
But once you've done that,
Cocoa Scripting just works.

01:04:37.630 --> 01:04:39.060
There is a price, though.

01:04:39.280 --> 01:04:42.050
You don't get this for free.

01:04:42.260 --> 01:04:45.890
It can have a performance
impact on your application,

01:04:46.020 --> 01:04:49.500
and the only way for you to find out what
that is is to just measure it yourself.

01:04:49.630 --> 01:04:52.450
And the two things that you're
going to need to measure are

01:04:52.590 --> 01:04:54.290
launch time and memory usage.

01:04:54.380 --> 01:04:58.000
So you want to get a baseline for
those before you start your work.

01:04:58.060 --> 01:05:01.860
You don't have to do your entire
scripting implementation to find

01:05:01.860 --> 01:05:05.280
out what this impact is going to be,
but you do have to make the

01:05:05.370 --> 01:05:06.740
changes to your startup code.

01:05:08.030 --> 01:05:11.230
Once you've changed your startup code,
you can relaunch your application

01:05:11.230 --> 01:05:14.820
and you'll get a pretty good idea
of what pulling in Cocoa Scripting

01:05:14.830 --> 01:05:16.500
is going to do to your application.

01:05:16.500 --> 01:05:19.490
It'll slow down the launch,
it'll increase the footprint.

01:05:19.490 --> 01:05:23.530
Now, you haven't written your code yet,
but you haven't written any

01:05:23.620 --> 01:05:26.100
Carbon Scriptability code yet either,
and the presumption is that

01:05:26.100 --> 01:05:27.480
they will be about equivalent.

01:05:27.500 --> 01:05:30.650
That the hit that you're taking is
the overhead for Cocoa Scripting,

01:05:30.650 --> 01:05:33.800
and you can measure that without
having to write all the code first.

01:05:33.900 --> 01:05:38.700
If you really want to do this,
contact developer technical

01:05:38.700 --> 01:05:44.010
support and put "scripting hybrid"
in the subject of your email,

01:05:44.010 --> 01:05:47.240
and you will get a response
from John Monprion about

01:05:47.240 --> 01:05:48.750
how to go about doing this.

01:05:48.980 --> 01:05:52.660
Like I said, it's not hard,
but you've got to know a few things.

01:05:55.360 --> 01:05:58.370
There's lots and lots of
documentation to help you make

01:05:58.370 --> 01:06:03.400
your application scriptable.

01:06:03.400 --> 01:06:06.980
The most important part of it is
the design of your dictionary,

01:06:06.980 --> 01:06:13.020
and these places here are good places to
go to find out information about that.

01:06:14.560 --> 01:06:19.410
You also need to implement
Objective-C or other objects to

01:06:19.410 --> 01:06:23.340
bring your dictionary to life.

01:06:23.340 --> 01:06:27.720
There's more detailed information
about how to do that at these places.

01:06:30.310 --> 01:06:36.150
Um, Cocoa and Carbon are both, uh,

01:06:36.250 --> 01:06:38.460
are both documented here.

01:06:38.460 --> 01:06:41.710
And the AppleScript language
guide is going to be valuable to

01:06:41.770 --> 01:06:46.760
anybody that's writing scriptable
applications or writing AppleScripts.

01:06:46.850 --> 01:06:52.120
Anybody along the line, end users,
testers, engineers, marketers,

01:06:52.170 --> 01:06:55.370
everybody should be looking at
the AppleScript language guide.

01:06:55.660 --> 01:07:00.780
It teaches you how AppleScript itself
works and teaches you a lot

01:07:00.780 --> 01:07:04.670
about how your object model
needs to interface with that.

01:07:05.460 --> 01:07:08.320
Each time we release new software,
we keep you up to date

01:07:08.320 --> 01:07:09.710
on the latest changes.

01:07:09.710 --> 01:07:13.400
Those are in these release notes,
which should be on your CDs.

01:07:13.400 --> 01:07:17.150
And the Interapplication
Communication Tech Note is kind of an

01:07:17.150 --> 01:07:21.890
umbrella where you'll find almost all
the rest of this stuff that we mentioned,

01:07:21.890 --> 01:07:26.210
plus a whole bunch of other stuff
about Apple Events and AppleScript.

01:07:26.470 --> 01:07:30.360
If you're afraid you don't want
to ask any newbie questions,

01:07:30.360 --> 01:07:35.200
you can go to the AppleScript Q&A and
see if maybe the answer's already there.

01:07:35.350 --> 01:07:37.030
But don't be afraid to
ask newbie questions.

01:07:37.160 --> 01:07:41.280
They're real easy for us to answer,
and we feel like we've done a good deed.

01:07:41.370 --> 01:07:45.200
And you can get sample code also.

01:07:47.280 --> 01:07:49.350
And you can get information from outside.

01:07:49.360 --> 01:07:52.950
The AppleScript website has
a wealth of information,

01:07:53.000 --> 01:07:56.370
including dozens and dozens of
sample scripts for Apple applications

01:07:56.790 --> 01:07:59.690
and other applications,
creating synergy between them.

01:07:59.690 --> 01:08:01.200
You should definitely visit that site.

01:08:01.200 --> 01:08:06.640
And there's books and websites
published by third parties that

01:08:07.100 --> 01:08:10.130
also have very valuable information.

01:08:10.130 --> 01:08:13.200
And the AppleScript website is a good
place to start to find most of those.

01:08:13.200 --> 01:08:17.000
There's a section in there that's
just all about third-party websites

01:08:17.000 --> 01:08:19.200
that you can go to to learn even more.

01:08:22.290 --> 01:08:27.750
These are all the sessions
that you've missed.

01:08:27.750 --> 01:08:30.760
But if you get the DVDs,
you can watch them there,

01:08:30.810 --> 01:08:33.180
or maybe some of you guys were at them.

01:08:33.870 --> 01:08:36.480
This is today's session and the rest
of the ones that we're going to have.

01:08:36.480 --> 01:08:40.040
I mentioned tomorrow we're going
to talk about using AppleScript to

01:08:40.040 --> 01:08:41.800
test your applications.

01:08:42.060 --> 01:08:46.180
And also there's going to be a
session where Sal Sigournian is

01:08:46.270 --> 01:08:49.690
going to talk about AppleScript for
system administrators.

01:08:49.800 --> 01:08:51.800
AppleScript is a tremendous
tool for system administrators.

01:08:51.800 --> 01:08:53.800
It saves them a lot of time.

01:08:53.800 --> 01:08:56.450
If you want your system
administrator to love you,

01:08:56.450 --> 01:08:58.690
you should write a good scriptable app.

01:08:59.710 --> 01:09:04.400
And if you need to get to us directly,
Todd Fernandez is my boss,

01:09:04.400 --> 01:09:09.280
Sal Segoyan is our marketing manager,
Jason is our technology manager,

01:09:09.280 --> 01:09:12.440
and John Monprion is our DTS contact.

01:09:12.440 --> 01:09:15.120
You should always go
through John Monprion first.

01:09:15.250 --> 01:09:19.150
He's going to have the quickest answer
for you if it's already been asked,

01:09:19.260 --> 01:09:23.270
and he's going to direct it to the right
person if it hasn't already been asked.
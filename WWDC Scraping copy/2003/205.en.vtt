WEBVTT

00:00:14.310 --> 00:00:15.960
Good afternoon everyone,
my name is Travis brown,

00:00:15.960 --> 00:00:19.400
I'm the graphics and imaging evangelist
and it's my pleasure to welcome you

00:00:19.400 --> 00:00:22.190
to Vertex Programming with OpenGL,
session 205.

00:00:22.200 --> 00:00:27.430
And sort of the theme that we
have at this year's WWC is the

00:00:27.430 --> 00:00:30.200
aspect of leveraging the GPU.

00:00:30.350 --> 00:00:33.300
And in the graphics and imaging
overview yesterday we showed a lot

00:00:33.300 --> 00:00:37.270
of examples of using programmability
to do interesting things,

00:00:37.270 --> 00:00:38.200
interesting visual effects.

00:00:38.240 --> 00:00:42.280
Those were fragment programs,
but there's also sort of a companion

00:00:42.360 --> 00:00:47.200
technology or another way to program
the GPU called Vertex Programming.

00:00:47.200 --> 00:00:50.180
Which instead of touching
fragments and therefore pixels,

00:00:50.210 --> 00:00:53.310
it's actually going to be
using the GPU to do very high

00:00:53.310 --> 00:00:55.200
speed geometry calculations.

00:00:55.200 --> 00:00:58.270
And the two go hand in hand in
terms of the ways you can really

00:00:58.270 --> 00:01:02.650
offload the burden of doing the
graphics from the CPU and allow

00:01:02.650 --> 00:01:04.200
the GPU to do what it does best.

00:01:04.200 --> 00:01:07.200
Which is work with geometry and
then obviously draw that geometry.

00:01:07.200 --> 00:01:08.180
So, let's get started.

00:01:08.230 --> 00:01:10.600
So, it's my pleasure to
welcome our speaker today,

00:01:10.600 --> 00:01:14.200
Michael Larsen up to the stage so he
can take you through the presentation.

00:01:20.650 --> 00:01:22.350
Thanks Travis.

00:01:22.350 --> 00:01:25.880
Today we're here to talk about
Vertex Programming with OpenGL.

00:01:25.920 --> 00:01:30.130
It's been around for a couple years,
starting with the ATI RV200

00:01:30.130 --> 00:01:31.850
in that generation.

00:01:31.850 --> 00:01:34.550
So we'll talk about it a little bit.

00:01:34.600 --> 00:01:37.250
Let's start out,
we're going to go through an

00:01:37.300 --> 00:01:39.600
introduction to Vertex Programs.

00:01:39.600 --> 00:01:43.720
We're going to talk about Vertex
Programs in the OpenGL pipeline,

00:01:43.720 --> 00:01:47.760
the computation model used
by the Vertex Programs,

00:01:47.760 --> 00:01:50.600
the program syntax for
the RVertex Program,

00:01:50.600 --> 00:01:55.230
and go through a number of examples,
starting from simple ones using Shader

00:01:55.230 --> 00:01:59.600
Builder and some more complicated
ones using the Project Builder.

00:01:59.600 --> 00:02:06.990
So starting out, why use Vertex Programs?

00:02:12.140 --> 00:02:16.330
Say you're using fragment programs,
a lot of the inputs that go

00:02:16.330 --> 00:02:20.110
into a fragment program come
out of the vertex program.

00:02:20.130 --> 00:02:23.270
You might have texture coordinates,
you might have some varying position

00:02:23.270 --> 00:02:27.340
coordinates that come through,
or just in general,

00:02:27.340 --> 00:02:31.170
you'll probably end up using
vertex programs if you're

00:02:31.170 --> 00:02:32.990
using fragment programs.

00:02:34.520 --> 00:02:38.430
Say your application doesn't fit into
the standard OpenGL lighting pipeline,

00:02:38.470 --> 00:02:42.070
you've got an existing lighting
model that you want to implement in

00:02:42.070 --> 00:02:45.430
Vertex Programs and you don't want
to change that to the OpenGL one,

00:02:45.530 --> 00:02:50.070
you can use a Vertex Program for that.

00:02:55.530 --> 00:03:00.130
Say your application is
pre-processing vertex arrays,

00:03:00.130 --> 00:03:04.580
or every time you draw an object,
you're touching the data.

00:03:04.890 --> 00:03:07.320
One way to get rid of that,
touching the data,

00:03:07.340 --> 00:03:10.790
and see-view time is actually
moving up to the vertex program,

00:03:11.020 --> 00:03:15.090
isolate that part of your program that
actually does that and move it up.

00:03:15.140 --> 00:03:19.000
Examples would be surfaces
and vertex tweening.

00:03:20.620 --> 00:03:25.810
in between is from keyframe animation.

00:03:25.810 --> 00:03:25.810
It's an old term.

00:03:33.630 --> 00:03:33.630
You know,
you have the general cartoonists and the

00:03:33.630 --> 00:03:33.630
people who drew everything in between,
so it's called tweening.

00:03:39.810 --> 00:03:44.750
So the benefits of vertex programs,
essentially you're going to be offloading

00:03:44.760 --> 00:03:48.480
functionality from the CPU to the GPU.

00:03:48.500 --> 00:03:51.930
You have more flexible per
vertex geometric operations,

00:03:52.010 --> 00:03:55.500
higher performance,
and lower memory usage.

00:03:56.340 --> 00:04:01.350
So let's talk about Vertex
Programs and the OpenGL pipeline.

00:04:03.180 --> 00:04:05.160
So here's the old fixed model.

00:04:05.190 --> 00:04:09.300
You start out with the OpenGL vertices.

00:04:09.510 --> 00:04:11.370
You have your standard model
view of transformation,

00:04:11.370 --> 00:04:14.490
the color materials and
the lighting effects,

00:04:14.490 --> 00:04:17.010
and your perspective division.

00:04:17.320 --> 00:04:21.200
and that's been replaced
with Vertex Programs.

00:04:21.200 --> 00:04:25.200
Essentially,
your Vertex Program replaces a lot

00:04:25.200 --> 00:04:28.640
of the same functionality that was "a
fixed functionality". A lot of that

00:04:28.680 --> 00:04:30.380
was actually implemented in microcode.

00:04:30.380 --> 00:04:34.200
You're just essentially allowing
you to use that as microcode.

00:04:34.200 --> 00:04:39.200
The SGI machines for years used
microcode for all these transforms.

00:04:39.200 --> 00:04:42.410
So what changes?

00:04:43.180 --> 00:04:45.970
Your program,
if you're using Vertex Program,

00:04:46.050 --> 00:04:48.960
you're now responsible for
doing all the transformation,

00:04:48.980 --> 00:04:54.130
the color materials and lighting,
and a whole slew of other

00:04:54.280 --> 00:04:57.940
issues if you're using the
OpenGL Color Lighting Model.

00:04:58.140 --> 00:05:02.810
And if you're using them
and you disable them,

00:05:04.700 --> 00:05:06.060
Here's a scenario.

00:05:06.110 --> 00:05:09.380
Say you're switching out of Vertex
Program and you're expecting the standard

00:05:09.700 --> 00:05:11.280
OpenGL lighting model to be there.

00:05:11.430 --> 00:05:14.810
You have to disable them or
you'll get everything run through

00:05:14.810 --> 00:05:16.700
the Vertex Program regardless.

00:05:16.700 --> 00:05:22.040
So let's talk about
the computation model.

00:05:25.020 --> 00:05:28.000
So what invokes a vertex program?

00:05:28.000 --> 00:05:32.000
Well, there's a number of standard
methods to find the ARB spec.

00:05:32.360 --> 00:05:36.920
Say that you're issuing
a GL vertex command,

00:05:36.920 --> 00:05:41.930
which usually kicks off some
kind of operation indirectly

00:05:41.940 --> 00:05:47.870
through OpenGL vertex draw
elements or draw arrays commands.

00:05:47.880 --> 00:05:52.190
The current raster position is changed.

00:05:52.490 --> 00:05:56.260
and essentially a vertex
program terminates at the end of

00:05:56.260 --> 00:05:57.510
reaching the end of the program.

00:05:59.180 --> 00:06:05.430
The computation model is you have
independent execution on each vertex.

00:06:05.630 --> 00:06:11.830
There can be, and there likely are, two,
four vertex units in each GPU.

00:06:12.230 --> 00:06:17.550
temporary data so from when you
write a program you kind of feel

00:06:17.550 --> 00:06:22.030
there's going to be data left over but
verdicts program you run the program,

00:06:22.030 --> 00:06:23.690
you're done it's all gone

00:06:25.830 --> 00:06:31.550
So, the input/output model,
you have your Vertex Program,

00:06:32.410 --> 00:06:38.530
You have Vertex Data Inputs,
which be your position, color, textures,

00:06:38.620 --> 00:06:41.400
coordinates, and those kinds of values.

00:06:41.400 --> 00:06:43.810
Environment parameters.

00:06:45.980 --> 00:06:48.120
OpenGL State.

00:06:48.120 --> 00:06:51.580
Let me talk about
Environment Parameters real quick.

00:06:51.580 --> 00:06:55.970
Environment Parameters are values
that you can load up to your Vertex

00:06:56.230 --> 00:07:03.900
Program through GL or across all
Vertex Programs or for a single one.

00:07:03.900 --> 00:07:11.420
And OpenGL State information which is
the current lighting model and a number

00:07:11.500 --> 00:07:14.890
of matrices available from OpenGL.

00:07:16.160 --> 00:07:23.260
In addition,
you have a number of temporary registers.

00:07:34.280 --> 00:07:38.280
available for use while you're
executing the Vertex Program.

00:07:38.350 --> 00:07:41.960
And then once your program completes
computation for each value,

00:07:42.050 --> 00:07:45.080
say the color, the position,
and everything else,

00:07:45.140 --> 00:07:48.000
you spit it to the Vertex data output.

00:07:48.070 --> 00:07:50.080
And once you reach the
end of the Vertex Program,

00:07:50.120 --> 00:07:52.240
you spit out everything
to your output registers,

00:07:52.290 --> 00:07:54.930
you hit an end,
Vertex Program stops and it kicks

00:07:54.930 --> 00:07:57.040
it off to the rest of the engine.

00:07:57.870 --> 00:08:01.200
What's available to Vertex Programs?

00:08:01.290 --> 00:08:07.180
Standard attributes, position, color,
textures, coordinates,

00:08:07.180 --> 00:08:11.340
and additional programmable
attributes that you can set.

00:08:11.340 --> 00:08:15.330
OpenGL Transformer Lighting State.

00:08:18.230 --> 00:08:22.700
So the parameter information
is read only by the program.

00:08:22.700 --> 00:08:24.390
It's defined in the spec.

00:08:24.440 --> 00:08:28.590
Essentially constant values from the

00:08:28.990 --> 00:08:30.990
from the sense of the program.

00:08:30.990 --> 00:08:35.900
From outside you can program them up
using environment commands from OpenGL.

00:08:35.900 --> 00:08:38.900
There's two types.

00:08:38.900 --> 00:08:41.210
There's global parameters,
which say you have

00:08:41.210 --> 00:08:46.320
multiple vertex programs,
you can load up these environment

00:08:46.460 --> 00:08:47.900
parameters across all vertex programs.

00:08:47.900 --> 00:08:52.610
Or you have local parameters,
which only affect the current

00:08:52.620 --> 00:08:54.810
vertex program running.

00:08:59.090 --> 00:09:04.620
The instruction set is limited
to about 27 instructions.

00:09:04.710 --> 00:09:06.520
They're focused on transformer lighting.

00:09:06.710 --> 00:09:08.930
Remember,
this is kind of like a microcode

00:09:08.930 --> 00:09:12.440
implementation exposed out,
so they're very limited.

00:09:12.800 --> 00:09:15.850
There's no loops, no branches.

00:09:15.920 --> 00:09:17.160
You have limited program length.

00:09:17.280 --> 00:09:21.520
Some instructions are macros,
which means you have instructions

00:09:21.800 --> 00:09:25.830
that are complicated that might do
multiple things in one operation.

00:09:25.990 --> 00:09:30.010
They might actually be two instructions,
or two or three instructions,

00:09:30.090 --> 00:09:32.260
and they are defined by the spec.

00:09:32.380 --> 00:09:38.990
So not all instructions will
require two instructions or more.

00:09:42.510 --> 00:09:48.390
There's data operands.

00:09:48.510 --> 00:09:52.200
There's scalar operands,
which are standard floating point values,

00:09:52.200 --> 00:09:55.020
and SIMD operations,
which are AlteVec-type values,

00:09:55.020 --> 00:10:00.440
for floating point values indexed by X,
Y, Z, and W.

00:10:00.700 --> 00:10:17.400
[Transcript missing]

00:10:21.030 --> 00:10:24.040
So data component selection,
you have a normal SIMD operation

00:10:24.040 --> 00:10:26.040
like an AlteVec instruction.

00:10:26.040 --> 00:10:28.440
A equals B.

00:10:28.550 --> 00:10:32.080
You've got some input parameter,
goes through some operation,

00:10:32.080 --> 00:10:35.070
gets flushed out at the bottom,
and they all get set.

00:10:35.460 --> 00:10:38.720
You have a Swizzle SIMD selection
which allows you to move

00:10:38.720 --> 00:10:40.360
data between components.

00:10:40.680 --> 00:10:43.190
So it's on the input select,
it's not on the output select.

00:10:43.390 --> 00:10:48.660
So if you have a two source component,
you might have source A might be

00:10:48.730 --> 00:10:50.990
XYZ and source B might be ZZZ.

00:10:51.150 --> 00:10:53.700
You can select them all at the same one.

00:10:55.350 --> 00:10:58.030
You have a scalar mass operation,
which is,

00:10:58.230 --> 00:11:00.140
these are the scalar operations.

00:11:00.140 --> 00:11:04.510
You can select which source operation,
or source component you

00:11:04.510 --> 00:11:05.900
want for the operation.

00:11:06.050 --> 00:11:09.300
So if you're doing like a
reciprocal divide and you want

00:11:09.430 --> 00:11:12.890
to see the reciprocal of y,
you essentially select y.

00:11:17.300 --> 00:11:21.730
The instruction set has a number of
standard scalar and SIMD instructions,

00:11:21.780 --> 00:11:22.960
like you see in AlteVec.

00:11:23.200 --> 00:11:26.300
You have your standard add, subtract,
multiply and add.

00:11:26.300 --> 00:11:29.300
Multiply and add is a very
important instruction.

00:11:29.300 --> 00:11:32.300
It's not a macro, it's a one instruction.

00:11:32.420 --> 00:11:36.300
You can do a lot with multiple adds and
you'll see in the examples I'll show you.

00:11:36.300 --> 00:11:40.670
You have absolute value,
minimum and maximum, dot product,

00:11:40.670 --> 00:11:43.300
disinfectors, so real lighting.

00:11:43.300 --> 00:11:47.300
You can see the lighting in
here and reciprocal functions.

00:11:47.300 --> 00:11:51.070
Math functions are pretty limited.

00:11:51.070 --> 00:11:57.420
You have the exponent base two,
floor fraction and log base two.

00:11:58.510 --> 00:12:01.580
And then the more complex
instructions you have:

00:12:01.640 --> 00:12:09.450
component selection, lighting,
conditional set on compare,

00:12:09.450 --> 00:12:11.000
doesn't operate like you think it does,
but I'll show you how it works,

00:12:11.000 --> 00:12:12.240
and indirect registers
load from parameter space.

00:12:12.300 --> 00:12:16.260
So you can't modify your
temporary registers,

00:12:16.300 --> 00:12:20.770
you can't index them
through indirect addressing,

00:12:20.770 --> 00:12:24.250
only parameters can be indirect values.

00:12:25.300 --> 00:12:28.200
So, let's look at the constraints.

00:12:28.420 --> 00:12:33.200
These are the base requirements for
all Vertex Program Implementations.

00:12:33.200 --> 00:12:37.070
So, if you write a Vertex Program,
the base implementation

00:12:37.070 --> 00:12:38.720
will have this many values.

00:12:38.720 --> 00:12:47.330
It has 96 Program Environments,
96 Local Values, 8 Program Matrices,

00:12:47.490 --> 00:12:49.710
1 Address Register,

00:12:49.850 --> 00:12:55.920
128 instructions and twelve temporary
registers now spec allows for anything

00:12:55.920 --> 00:12:58.480
more than that but you do the base
requirements that you can you can you

00:12:58.480 --> 00:13:01.040
can look look to have all implementations

00:13:03.790 --> 00:13:07.420
So how do you find out what your
new piece of hardware has to you,

00:13:07.430 --> 00:13:10.090
R300 or whatever you put in there?

00:13:10.300 --> 00:13:16.690
using GLProgramArb and query
the interface and what's there.

00:13:16.690 --> 00:13:24.490
There's a whole bunch of anumes that you
can ask for and see what's out there.

00:13:24.490 --> 00:13:27.730
So let's talk about syntax.

00:13:31.100 --> 00:13:38.880
All programs must start with the version
signature of our Vertex Program 1.0.

00:13:38.940 --> 00:13:41.430
Must terminate with an end statement.

00:13:43.470 --> 00:13:46.500
and just about anything
in between is okay.

00:13:46.570 --> 00:13:51.220
It has loose temporary and
parameter variable definitions.

00:13:51.220 --> 00:13:52.760
You don't have to find
all your temps at top.

00:13:52.890 --> 00:13:55.760
You can define them in
line just as long as,

00:13:55.760 --> 00:13:58.630
you know, before you use them,
just like C++.

00:14:02.240 --> 00:14:04.160
So, what is a syntax?

00:14:04.410 --> 00:14:07.960
It's effectively a
GPU independent assembly language.

00:14:07.970 --> 00:14:12.900
It's not targeting any specific GPU,
it's independent of all types.

00:14:12.990 --> 00:14:15.600
It's not C, and it's not pure assembly.

00:14:15.780 --> 00:14:17.620
There's no fixed registry allocation.

00:14:17.620 --> 00:14:23.210
It's independent.

00:14:25.310 --> 00:14:28.130
Like I said, it's GPU independent.

00:14:28.180 --> 00:14:33.200
They're loaded as strings,
they're runtime compiled by the driver,

00:14:33.200 --> 00:14:37.550
ATI, Nvidia, whoever,
and there's no fixed

00:14:37.580 --> 00:14:39.400
allocation of GPU registers.

00:14:44.050 --> 00:14:45.790
Three kinds of parameters.

00:14:45.830 --> 00:14:48.680
You have the constant parameters,
which are not programmable

00:14:48.680 --> 00:14:51.100
from your program.

00:14:51.100 --> 00:14:54.610
You have the environment parameters,
which are programmable

00:14:54.790 --> 00:14:56.910
across all Vertex programs.

00:14:56.940 --> 00:15:00.330
And you have local parameters,
which are specific to the

00:15:00.330 --> 00:15:03.000
currently bound Vertex program.

00:15:04.410 --> 00:15:07.550
You have temporary registers,
essentially they start out with a

00:15:07.740 --> 00:15:09.940
temp and you can name off up to 12.

00:15:09.950 --> 00:15:12.400
You'd be surprised how few
you actually have to use.

00:15:12.400 --> 00:15:16.970
The key thing about using temporary
registers is you get a mindset from

00:15:16.970 --> 00:15:21.200
AlteVec or whatever you're used
to programming on of creating a

00:15:21.200 --> 00:15:24.400
whole bunch of data and then having
a result and storing them away.

00:15:24.400 --> 00:15:28.670
The key thing about using the temporary
registers for Vertex programs is

00:15:28.670 --> 00:15:32.310
compute your result and stick it
in the result as fast as you can

00:15:32.310 --> 00:15:34.400
and reuse that temporary register.

00:15:39.280 --> 00:15:43.360
Then a number of urinary, binary,
and ternary instructions.

00:15:43.600 --> 00:15:47.320
You know, reciprocals and maths
and adds and multiplies,

00:15:47.320 --> 00:15:47.920
those things.

00:15:49.750 --> 00:15:53.440
So, just to look at the
instruction set real quick,

00:15:53.440 --> 00:15:56.700
this comes out of the ARB spec.

00:15:56.700 --> 00:15:59.700
You see the instruction,
you have a defined set of inputs,

00:15:59.700 --> 00:16:04.590
everything, just pretty much everything
takes a vector input.

00:16:05.000 --> 00:16:06.590
Might have two sources.

00:16:06.720 --> 00:16:10.930
The output, that's the important part
by looking at the spec,

00:16:10.930 --> 00:16:14.110
is you might have,
it might be a scalar function

00:16:14.240 --> 00:16:16.960
or it might be a vector,
a SIMD operation.

00:16:18.670 --> 00:16:23.970
You can see the flavor of the
instructions and the syntax that's used.

00:16:24.870 --> 00:16:27.760
and more additional instructions.

00:16:27.760 --> 00:16:29.480
You can look at some
of the math functions,

00:16:29.480 --> 00:16:31.800
the power, the reciprocal,
the reciprocal square root.

00:16:32.140 --> 00:16:35.190
All those instructions
are scalar outputs.

00:16:35.190 --> 00:16:42.170
So you have to select a particular,
if you want a square root of some value,

00:16:42.170 --> 00:16:47.780
like a square root of the y value,
it's going to be spread

00:16:47.780 --> 00:16:48.470
across all the outputs.

00:16:48.470 --> 00:16:48.470
And that's what it shows in this example.

00:16:49.090 --> 00:16:56.000
So, where do you get more information
on our Vertex programs?

00:16:56.090 --> 00:16:59.000
Well, the shader builder and the
development tools comes for free,

00:16:59.010 --> 00:17:01.000
and it's a great place to start.

00:17:01.000 --> 00:17:01.990
It has active syntax checking.

00:17:02.030 --> 00:17:05.900
You don't have to build a framework
and build a program to make it work.

00:17:06.020 --> 00:17:09.990
You can just turn it on,
start dialing away, and things work.

00:17:12.310 --> 00:17:15.420
So let's talk about loading programs
and controlling the execution

00:17:15.420 --> 00:17:18.500
environment for Vertex programs.

00:17:18.830 --> 00:17:21.620
So,
Vertex programs are loaded as strings.

00:17:21.700 --> 00:17:25.700
Like I said,
they're runtime compiled by the driver.

00:17:25.860 --> 00:17:29.090
Essentially,
there's only one way to do it today.

00:17:29.100 --> 00:17:33.380
They've left ways to do it
different ways in the future,

00:17:33.380 --> 00:17:34.700
but strings are the only way today.

00:17:34.700 --> 00:17:37.270
It has active syntax checking.

00:17:37.300 --> 00:17:40.620
So,
after you try a load of Vertex Program,

00:17:40.700 --> 00:17:44.290
you can test the GL_GET error,
and if you call a

00:17:44.300 --> 00:17:49.270
GL_GET string with its new,
it'll actually come back with a string

00:17:49.420 --> 00:17:54.410
reporting the actual position in
the code where the error was found.

00:17:55.170 --> 00:17:57.310
which is very useful.

00:17:57.420 --> 00:17:58.880
You'll find out.

00:17:59.000 --> 00:18:03.620
So loading, like I said,
there's parameters.

00:18:03.620 --> 00:18:05.130
You have environment parameters.

00:18:05.130 --> 00:18:08.200
There's a specific call for
loading environment parameters.

00:18:08.210 --> 00:18:10.000
It's Program A and B parameter.

00:18:10.110 --> 00:18:12.040
And they're all loaded up SIMD values.

00:18:12.040 --> 00:18:13.950
There's no way to load a scalar value.

00:18:14.060 --> 00:18:15.790
Everything gets loaded as SIMD.

00:18:16.450 --> 00:18:20.190
Also, there's an equivalent
call for local parameters,

00:18:20.190 --> 00:18:25.160
you know, GL, local parameters,
and they also get loaded as SIMD.

00:18:25.260 --> 00:18:27.790
So let's go through a
basic Vertex Program.

00:18:28.550 --> 00:18:41.490
Michael Kors: What it's going to do,
it's effectively the

00:18:41.490 --> 00:18:41.490
shader build example,
maybe a little bit simplified.

00:18:41.490 --> 00:18:41.490
We're going to do a model view
perspective transform of an input vertex

00:18:41.490 --> 00:18:41.490
and set the result and move it on.

00:18:54.610 --> 00:18:56.800
So here we have Shader Builder.

00:18:56.800 --> 00:18:58.300
Let me bring it up a little bit.

00:18:58.300 --> 00:19:04.620
Let's look around here a little bit.

00:19:04.620 --> 00:19:09.470
You have essentially
your code input here.

00:19:14.990 --> 00:19:19.080
This is actually loaded
as a vertex program.

00:19:19.080 --> 00:19:20.860
You have to load it before
any begin end statement,

00:19:20.860 --> 00:19:21.400
by the way.

00:19:21.400 --> 00:19:24.580
You can't change it
while doing a begin end.

00:19:24.580 --> 00:19:28.080
Even, well, you know,
draw arrays and draw elements

00:19:28.240 --> 00:19:32.550
have implied begin ends,
but effectively before a begin statement,

00:19:32.640 --> 00:19:38.510
you have to have this
loaded as a program.

00:19:38.700 --> 00:19:40.860
So let's go through this again.

00:19:40.890 --> 00:19:43.900
You have your editor
interface right here.

00:19:43.900 --> 00:19:46.760
You can enable/disable
the Vertex Program.

00:19:46.980 --> 00:19:51.300
You have a number of objects
available to draw your test

00:19:51.410 --> 00:19:53.570
your vertex program out on.

00:19:53.580 --> 00:20:02.510
You have a sphere, teapot, a hedron,
plane, I think it's actually called that,

00:20:02.510 --> 00:20:02.510
I don't know.

00:20:04.960 --> 00:20:14.170
- Everybody draws teapots.

00:20:14.170 --> 00:20:14.170
And you have your GL parameters.

00:20:14.170 --> 00:20:14.170
And you can dial up your color,
you can change the color on the fly,

00:20:14.170 --> 00:20:14.170
go to

00:20:21.210 --> 00:20:24.900
uh... you can also select uh... a
number texture units available for

00:20:24.900 --> 00:20:29.940
input uh... you can load them up and
select them through this interface but

00:20:29.940 --> 00:20:32.200
today we're just going to use uh...

00:20:32.780 --> 00:20:35.060
Texturing unit zero.

00:20:35.060 --> 00:20:37.310
And you can enable it or disable it.

00:20:37.310 --> 00:20:38.520
Turns things on.

00:20:38.520 --> 00:20:38.520
So.

00:20:39.000 --> 00:20:42.630
Then over here you have a
bunch of debugging information.

00:20:42.670 --> 00:20:43.750
I'm not going to go through it.

00:20:43.840 --> 00:20:47.740
It essentially allows you to
step through a Vertex Program and

00:20:47.740 --> 00:20:49.330
watch the values change.

00:20:49.530 --> 00:20:54.040
In addition,
ShaderBuilder has an instruction

00:20:54.040 --> 00:20:56.110
reference that comes up over here.

00:20:56.110 --> 00:20:57.840
So you're not digging
around the ARB spec.

00:20:57.840 --> 00:21:02.830
It's 64 pages long and
it's really detailed.

00:21:02.830 --> 00:21:02.830
You don't want to read it.

00:21:03.110 --> 00:21:06.280
Read it when you get there, you know,
okay.

00:21:06.280 --> 00:21:11.450
But you can essentially have online
documentation of all the instructions

00:21:11.550 --> 00:21:13.500
and what they're supposed to do.

00:21:13.500 --> 00:21:17.460
So let's go back.

00:21:17.460 --> 00:21:17.460
Turn that off.

00:21:21.170 --> 00:21:27.010
Start the program out,
the R Vertex Program 1.0.

00:21:27.010 --> 00:21:30.140
I have an offset, a scale,
and a zero value.

00:21:30.300 --> 00:21:33.100
This is a constant thrown in here.

00:21:33.260 --> 00:21:36.380
Once you program enough,
you start throwing in your

00:21:36.380 --> 00:21:39.660
standard cut and paste,
and I have a whole bunch of

00:21:39.660 --> 00:21:42.040
standard values I use all the time.

00:21:42.290 --> 00:21:46.050
Here's a temporary value,
the vertex position.

00:21:46.470 --> 00:21:51.710
Let's show you an example
of the runtime compile.

00:21:52.480 --> 00:21:56.040
"Inline error checking"
comes up with an error saying

00:21:56.080 --> 00:21:58.370
there's something wrong here.

00:21:58.370 --> 00:22:01.290
If you look at the bottom it says line 9.

00:22:01.290 --> 00:22:06.260
Actually if you did the DL error check
and actually pulled that string out

00:22:06.260 --> 00:22:11.660
like I showed in the previous example,
it would return this same value.

00:22:13.960 --> 00:22:17.480
So as you work into project
builder examples and you

00:22:17.480 --> 00:22:20.670
start doing it by yourself,
just about all your Vertex

00:22:20.670 --> 00:22:24.650
programs will pull that string
out just to help you out.

00:22:24.910 --> 00:22:27.170
So, let's start out.

00:22:27.580 --> 00:22:32.220
Right here I'm just adding a,
here's the vertex position right here.

00:22:33.440 --> 00:22:38.160
That's an input value that
comes from the program.

00:22:38.440 --> 00:22:43.460
Here's a temporary called
VFOS and a zero value.

00:22:43.510 --> 00:22:47.030
So I can inline actually add an offset.

00:22:48.340 --> 00:22:51.300
and actually automatically
adds it to the program.

00:22:51.300 --> 00:22:54.600
I can change that offset real time.

00:22:54.870 --> 00:22:58.020
These are great tools, by the way.

00:23:17.210 --> 00:23:17.210
You know,
one thing I do a lot is I actually

00:23:17.210 --> 00:23:17.210
get a program up and running here,
cut and paste it, stick it in a file,

00:23:17.210 --> 00:23:17.210
and add it to my project builder.

00:23:17.210 --> 00:23:17.210
And then once I,
if I develop errors in the program,

00:23:17.210 --> 00:23:17.210
I always come back and paste it in here,
see where the error's at.

00:23:17.470 --> 00:23:22.280
And right here,
so I'm taking the vertex position,

00:23:22.280 --> 00:23:26.830
the vertex from the input,
assigning it to a temporary

00:23:27.000 --> 00:23:32.710
by doing an add of an offset,
and then multiplying by some scale value.

00:23:32.740 --> 00:23:35.700
And you can comment all this stuff out.

00:23:35.800 --> 00:23:56.400
[Transcript missing]

00:24:04.300 --> 00:24:06.780
and then also set the text coordinate.

00:24:06.820 --> 00:24:10.960
So that's an example of a basic
Vertex Program within Shader Builder.

00:24:10.960 --> 00:24:16.040
It's pretty simple,
it's probably 10 instructions,

00:24:16.110 --> 00:24:17.780
five instructions long.

00:24:17.780 --> 00:24:21.730
So, let's go back.

00:24:24.350 --> 00:24:25.830
So we're going to go through next,
we're going to go through

00:24:26.050 --> 00:24:28.180
lighting vertex program,
that's another major use

00:24:28.360 --> 00:24:34.310
for vertex programs for,
like I said, if you don't have a standard

00:24:34.310 --> 00:24:36.710
GL lighting model that you want to use.

00:24:36.920 --> 00:24:40.140
What we're going to do is we're
going to use Shader Builder.

00:24:40.240 --> 00:24:42.200
It's essentially the same
example that comes out of

00:24:42.200 --> 00:24:44.620
your development example area.

00:24:44.740 --> 00:24:48.900
We're going to model view the
transform of an input vertex,

00:24:48.900 --> 00:24:53.560
perform some lighting computations,
and then move on.

00:24:53.560 --> 00:24:58.140
Let's do the demo.

00:24:58.140 --> 00:25:04.120
A little more complex.

00:25:14.690 --> 00:25:19.060
So I wanted to remove some functionality
here before I moved on too much.

00:25:19.080 --> 00:25:21.160
I'll leave that over there.

00:25:21.210 --> 00:25:26.880
So you can look at this in stages,
this thing being applied in stages.

00:25:27.260 --> 00:25:29.800
A Trib, you know,
effectively it's a pound to find.

00:25:30.040 --> 00:25:31.100
I mean, it really is.

00:25:31.330 --> 00:25:34.750
So if you want to use nice
names for standard input values,

00:25:34.860 --> 00:25:36.200
you can call them a Tribs.

00:25:36.200 --> 00:25:42.010
You have, now I have two parameters here,
and if you notice,

00:25:42.340 --> 00:25:46.290
in this parameter right here,
I'm sharing a whole bunch of values,

00:25:46.290 --> 00:25:49.360
rather than creating
multiple parameter variables,

00:25:49.360 --> 00:25:55.800
I'm jamming four scalar values,
three scalar values into one SIMD value.

00:25:56.120 --> 00:25:57.600
- This is a parameter space.

00:25:57.600 --> 00:26:00.460
And here's your light position.

00:26:00.480 --> 00:26:04.220
So what we go through here,
we do our Model-Viewed

00:26:04.230 --> 00:26:06.430
Perspective Transform.

00:26:06.710 --> 00:26:10.240
We start computing the lighting value.

00:26:10.500 --> 00:26:26.700
[Transcript missing]

00:26:26.990 --> 00:26:30.390
The nice thing about this tool
is you can do things right in

00:26:30.420 --> 00:26:32.200
line and test them as you go.

00:26:32.200 --> 00:26:37.580
Say you develop a bug through here,
you can comment it out real time

00:26:37.580 --> 00:26:41.810
and actually see what part of the
program is actually messing up.

00:26:42.280 --> 00:26:46.150
and then we go through and
we move the result to the

00:26:46.150 --> 00:26:48.980
output position and the color.

00:26:49.600 --> 00:26:54.320
So those are two simple
examples of how to use vertex

00:26:54.510 --> 00:26:56.530
programs in the Shader Builder.

00:26:56.600 --> 00:26:59.530
We're not going to talk about
Shader Builder too much.

00:26:59.530 --> 00:27:04.370
We're going to move on to some new ideas.

00:27:04.600 --> 00:27:08.310
So as far as Shader Builder goes,
it's a great place to start.

00:27:08.310 --> 00:27:09.600
It's a great tool.

00:27:09.600 --> 00:27:11.530
You load up textures,
you don't have to build a framework.

00:27:11.530 --> 00:27:13.600
You can get started today.

00:27:13.600 --> 00:27:21.600
It also provides active syntax checking
of your vertex program as they develop.

00:27:21.730 --> 00:27:27.030
In addition, as you start out,
it has online instruction information.

00:27:28.440 --> 00:27:35.080
So, as far as program possibilities,
you know, a lot of people

00:27:35.330 --> 00:27:39.000
You look at the instruction set,
it's rather small, lighting focused.

00:27:39.070 --> 00:27:41.570
The code space is pretty small,
we're all used to having

00:27:41.570 --> 00:27:42.830
as much code as we want to.

00:27:42.980 --> 00:27:46.440
And the number of temporary
registers is actually pretty small.

00:27:46.540 --> 00:27:49.560
But you'd be surprised what
you can actually do with that.

00:27:49.730 --> 00:27:52.590
You can do surfaces,
you can do active displacements,

00:27:52.590 --> 00:27:57.770
you can do real-time displacements,
you can do advanced lighting effects,

00:27:57.890 --> 00:28:02.010
keyframe animation,
and visual computation.

00:28:02.880 --> 00:28:07.650
So let's go through some real quick
tips from an application standpoint.

00:28:07.700 --> 00:28:12.720
Best way to use Vertex Programs is
using Vertex Arrays combined

00:28:12.720 --> 00:28:14.670
with Vertex Array Ranges.

00:28:14.700 --> 00:28:19.520
Key thing about this is you're moving
all the CPU from the issuing and

00:28:19.520 --> 00:28:22.460
fetching of all the Vertex Arrays.

00:28:22.460 --> 00:28:25.900
So you're keeping the
CPU out of the equation.

00:28:28.000 --> 00:28:32.640
Use compound selection
to save parameter space.

00:28:32.640 --> 00:28:35.160
Rather having multiple
parameters defined,

00:28:35.160 --> 00:28:37.360
like one, two,
the runtime compiler is not going

00:28:37.510 --> 00:28:38.990
to be able to figure this out.

00:28:39.000 --> 00:28:41.000
Stick them together.

00:28:41.210 --> 00:28:45.000
In addition, use compound parameters.

00:28:45.030 --> 00:28:47.810
Save yourself reciprocal multiply.

00:28:48.140 --> 00:28:51.100
Save it by actually pre-computing
these fixed values and

00:28:51.230 --> 00:28:53.000
combining them in one array.

00:28:53.000 --> 00:29:00.450
So here I have factorial 6, 720,
negative 720, the inverse of that and

00:29:00.450 --> 00:29:02.300
the negative of that.

00:29:05.800 --> 00:29:09.290
Additional programming tips,
these are things I've had

00:29:09.290 --> 00:29:11.560
to figure out how they went.

00:29:11.560 --> 00:29:14.670
Only one value for some
instructions can be selected.

00:29:14.670 --> 00:29:17.470
At some point,
you might want to merge all of those

00:29:17.610 --> 00:29:21.540
values back into the same vector,
or SIMD value and start computing

00:29:21.640 --> 00:29:25.030
again rather than generating
a single scalar value and then

00:29:25.040 --> 00:29:28.900
doing a whole bunch of work on it,
generating another SIMD scalar value

00:29:28.900 --> 00:29:30.550
doing a whole bunch of work on it.

00:29:30.550 --> 00:29:34.010
You might want to merge all
back together and compute them

00:29:34.020 --> 00:29:36.240
like you would using AlteVec.

00:29:36.240 --> 00:29:40.130
You can use the select parameter
and multiply add instruction to

00:29:40.130 --> 00:29:42.140
merge everything back together.

00:29:42.260 --> 00:29:47.310
This shows how you're using -- you're
doing a reciprocal on three values,

00:29:47.350 --> 00:29:52.160
and then you're starting to
merge them back together by doing

00:29:52.160 --> 00:29:54.500
multiply add back into one value.

00:29:54.500 --> 00:29:56.870
This actually is quite helpful.

00:29:57.470 --> 00:30:00.430
Conditional selection.

00:30:00.530 --> 00:30:03.840
There is no branches,
so how do you do conditional selection?

00:30:03.900 --> 00:30:06.400
Well, the only way to really do
it is through multiplies.

00:30:06.430 --> 00:30:11.170
So you have a value,
say you want to do if

00:30:11.350 --> 00:30:13.460
A greater than or equal to B,
then assign C equals

00:30:13.460 --> 00:30:15.760
A or something like that.

00:30:15.940 --> 00:30:18.520
You have to do, you know,
set greater than equal,

00:30:18.520 --> 00:30:22.980
which actually sets, it doesn't actually,
what it does, it sets the, if it's true,

00:30:22.980 --> 00:30:24.320
it sets the output to ones.

00:30:24.360 --> 00:30:28.540
So you're going to use that ones value
to multiply against the input value,

00:30:28.570 --> 00:30:32.860
so it's either going to be one or zero,
and a MAT instruction in between

00:30:32.860 --> 00:30:36.700
that merges the two together
like a conditional would.

00:30:36.740 --> 00:30:40.580
So I've got it down to four instructions,
and there's no branches.

00:30:43.420 --> 00:30:48.310
So let's talk about vertex
programs for surfaces.

00:30:51.150 --> 00:30:56.470
So a lot of the lighting functionality
for vertex programs is actually

00:30:56.540 --> 00:30:58.320
moved down to fragment programs.

00:30:58.400 --> 00:31:00.540
You can get per-pixel lighting.

00:31:00.540 --> 00:31:01.980
So what else can you do with this?

00:31:01.980 --> 00:31:04.100
This is a pretty powerful
little tool you have here.

00:31:04.100 --> 00:31:09.450
So rather than tweaking with
your vertices every time you want

00:31:09.450 --> 00:31:12.810
to move somebody's position or
you want to define a new shape,

00:31:12.920 --> 00:31:18.390
just use UV mesh,
essentially two-dimensional mesh that you

00:31:18.390 --> 00:31:19.840
create once and you never touch it again.

00:31:21.120 --> 00:31:25.210
So the vertex program is going to compute
the XYZ position of all the values.

00:31:25.260 --> 00:31:27.200
You can be surprised
what you can do with it.

00:31:27.220 --> 00:31:32.860
You can do quadratic surfaces,
implicit surfaces, parametric surfaces.

00:31:32.860 --> 00:31:38.820
You can do bilinear interpolation,
Bezier, B-splines, and NURBS,

00:31:38.820 --> 00:31:40.160
all with vertex programs.

00:31:41.930 --> 00:31:45.420
So, what's a UV mesh?

00:31:45.470 --> 00:31:47.370
Well, a UV mesh is a 2D mesh.

00:31:47.540 --> 00:31:48.610
It's bounded by UNV.

00:31:49.010 --> 00:31:52.480
UNV can be bounded between
any kind of fixed value.

00:31:53.310 --> 00:31:56.740
A parametric surface,
such as base area surfaces, or nerves,

00:31:56.840 --> 00:32:01.200
or B-splines, are bound between 0 and 1
implicitly for the whole surface.

00:32:01.240 --> 00:32:07.200
So, why would you want to use a
vertex program for a surface?

00:32:07.200 --> 00:32:09.200
Well, you have to define one mesh.

00:32:09.330 --> 00:32:11.200
One mesh for all your objects.

00:32:11.200 --> 00:32:13.850
And by using that,
you never have to touch

00:32:13.850 --> 00:32:17.200
your vertices again,
you can load them up in VRAM,

00:32:17.200 --> 00:32:18.200
and you'll never see them again.

00:32:18.200 --> 00:32:22.200
You can animate surfaces
using control parameters.

00:32:22.210 --> 00:32:24.200
We'll show an example of that.

00:32:24.280 --> 00:32:28.200
And you're offloading the
work from the CPU to the GPU.

00:32:28.200 --> 00:32:35.500
So, let's talk about an implicit
surface vertex program.

00:32:38.110 --> 00:32:43.160
school math thingy picked it off a web
page uh... you know that's three sign

00:32:43.160 --> 00:32:48.040
values I got a u and v for x and y,
sign of u and v for x and y and then

00:32:48.040 --> 00:32:53.930
uh... four control parameters combined
uh... with u and v for the final z value

00:32:56.260 --> 00:32:59.860
So we're going to build a
UV mesh as a vertex array,

00:32:59.860 --> 00:33:02.550
and we're going to bound it
between negative pi and pi,

00:33:02.550 --> 00:33:05.200
and have some number of steps in between.

00:33:05.240 --> 00:33:09.000
So, and then we're going to fill in
the position with the UV mesh,

00:33:09.080 --> 00:33:10.790
u and v.

00:33:11.060 --> 00:33:13.760
I see Z is zero is actually right here.

00:33:13.760 --> 00:33:17.910
The U and V are just input
parameters to the vertex program.

00:33:19.390 --> 00:33:26.170
So we're going to create our program,
debug it through ShaderBuilder,

00:33:26.170 --> 00:33:28.450
and load it as a program string.

00:33:29.140 --> 00:33:31.960
Then we're going to load the
shape control parameters,

00:33:31.990 --> 00:33:35.110
the A, B, C,
and D you've seen in the previous

00:33:35.110 --> 00:33:37.980
equation as local parameters.

00:33:38.030 --> 00:33:43.050
And then we're going to submit a
number of quad strips for drawing.

00:33:54.300 --> 00:33:59.200
So here's our object in line format.

00:33:59.210 --> 00:34:05.440
This is actually a two-dimensional
UV mesh being input and it's finely

00:34:05.440 --> 00:34:10.570
tessellated and all the positions are
being computed by the Vertex Program.

00:34:10.580 --> 00:34:14.540
Right here are our control parameters.

00:34:14.540 --> 00:34:19.410
We can dial in anything we want,
change the shape,

00:34:22.330 --> 00:34:24.940
So these are the A, Bs and Cs.

00:34:24.940 --> 00:34:31.130
Everybody who sees this wants to go
out and do knots and stuff like that.

00:34:31.130 --> 00:34:32.250
Good luck.

00:34:32.250 --> 00:34:34.570
You do a lot of cool stuff.

00:34:34.570 --> 00:34:37.600
So let's do a little demo here.

00:34:45.600 --> 00:34:49.790
Now we're computing the shape on the fly.

00:34:49.790 --> 00:34:52.120
It's been loaded once in the VRAM.

00:34:52.120 --> 00:34:54.680
It's not coming across AGP at all.

00:34:54.700 --> 00:35:03.320
Text recorders are being completed
by the vertex program this is

00:35:03.320 --> 00:35:11.280
an opengl context right here i'm
pulling the input from a quicktime

00:35:11.280 --> 00:35:15.430
and here's the volume indicated.

00:35:15.430 --> 00:35:15.430
It's kind of fun.

00:35:22.200 --> 00:35:27.970
Michael Kors: What's that example?

00:35:27.980 --> 00:35:28.010
It's fun.

00:35:28.040 --> 00:35:29.160
So what did you see there?

00:35:29.160 --> 00:35:33.230
You've seen a vertex program that
computed the object shape and

00:35:33.230 --> 00:35:35.880
color and the texture coordinates.

00:35:36.070 --> 00:35:39.880
The control values, A, B, and C, D,
were fed up as control parameters.

00:35:39.880 --> 00:35:45.660
So one SIMD value per frame was
loaded up and it computed everything

00:35:45.660 --> 00:35:48.440
else based on that one value.

00:35:48.440 --> 00:35:49.780
There's no sine function.

00:35:49.780 --> 00:35:51.070
So how did I compute that?

00:35:51.070 --> 00:35:52.680
I used a McLaren power series.

00:35:52.680 --> 00:35:55.940
You can do a lookup,
but it's just about as much work

00:35:55.940 --> 00:35:59.510
as doing McLaren because you're
going to do indirect address

00:35:59.510 --> 00:36:01.960
register loads and all that stuff.

00:36:02.040 --> 00:36:07.270
And then once I had the values computed,
I computed all three sine values at the

00:36:07.340 --> 00:36:10.510
same time using an ultimate similar code.

00:36:12.880 --> 00:36:14.740
So let's take a look at the program.

00:36:14.740 --> 00:36:16.080
It's rather small up here.

00:36:16.080 --> 00:36:18.810
You guys see that?

00:36:20.600 --> 00:36:27.820
and the lights, maybe.

00:36:28.160 --> 00:36:29.810
So there's an input parameter, ABCD,
four temporary values, not a whole lot.

00:36:33.700 --> 00:36:39.670
So the surface is described by
two fixed UV values for X and Y,

00:36:39.670 --> 00:36:43.380
and then the control parameters
for the shape are in the Z.

00:36:43.500 --> 00:36:48.580
So I had to compute those on the vertex
program rather than stuffing the vertex

00:36:48.590 --> 00:36:50.930
array every time with new values.

00:36:51.040 --> 00:36:54.670
So that's about six instructions there.

00:36:54.730 --> 00:36:57.050
That's the example of the syntax.

00:36:57.300 --> 00:36:59.620
It's very assembly-like.

00:37:00.750 --> 00:37:03.610
Then I'm cranking on and I'm
starting to compute the sign

00:37:03.850 --> 00:37:07.410
values through a number of terms.

00:37:07.860 --> 00:37:11.220
so if you notice i'm doing a
multiply and a mat instruction

00:37:11.650 --> 00:37:13.050
and i'm continually moving on

00:37:16.010 --> 00:37:17.900
Then we do a few more terms.

00:37:17.900 --> 00:37:20.600
We set the output position.

00:37:20.610 --> 00:37:23.900
So once I have the output position,
I jam it away, because I'm going to use

00:37:23.900 --> 00:37:25.430
that temporary value again.

00:37:27.250 --> 00:37:30.500
And then I set the texture
coordinates to some input value,

00:37:30.720 --> 00:37:33.400
which is actually get time.

00:37:33.500 --> 00:37:37.270
I jammed it in the EQ0123x value.

00:37:37.270 --> 00:37:39.270
And then I add it to
the vertex coordinate,

00:37:39.390 --> 00:37:43.100
and that value's been
normalized between 0 and 1.

00:37:43.240 --> 00:37:44.630
And that's it.

00:37:45.810 --> 00:37:47.910
So, where do you go from here?

00:37:47.910 --> 00:37:49.220
Try doing waves.

00:37:49.230 --> 00:37:51.730
Waves are actually pretty simple.

00:37:51.800 --> 00:37:54.460
Very similar, use cosine functions.

00:37:54.620 --> 00:37:58.050
You can have essentially
multiple emitters.

00:37:58.200 --> 00:38:00.910
You think about things
bobbing up in the water,

00:38:00.910 --> 00:38:03.900
you have three,
four of them bobbing in the water,

00:38:04.070 --> 00:38:08.190
and for each point on your water,
you just simply compute how far you are

00:38:08.330 --> 00:38:12.780
away from that cosine emitter and compute
your Z value on that and sum across

00:38:12.780 --> 00:38:15.450
all the emitters in the whole thing.

00:38:15.970 --> 00:38:17.860
There's a demo tomorrow that shows this.

00:38:17.860 --> 00:38:19.610
It's pretty cool.

00:38:22.230 --> 00:38:24.400
So let's go through NURBS.

00:38:25.160 --> 00:38:28.000
Actually, I had bilinear surfaces,
B-splines,

00:38:28.000 --> 00:38:29.500
and everything else figured out.

00:38:29.550 --> 00:38:33.170
NURBS took a while to
figure out how to do them.

00:38:33.800 --> 00:38:37.770
So why use a vertex program for NURBS?

00:38:37.860 --> 00:38:43.990
Most people who use NURBS in OpenGL have
already figured out that NURBS is slow.

00:38:43.990 --> 00:38:46.820
You have to do a multiply,
accumulate across a number of

00:38:46.820 --> 00:38:52.800
control points and they've either
rolled their own NURBS evaluators.

00:38:52.800 --> 00:38:59.070
You can store multiple patches as
a single vertex array and just load

00:38:59.070 --> 00:39:02.080
up control points for each patch.

00:39:02.890 --> 00:39:06.850
You can do automatic level of detail
based on how close the patch is

00:39:06.850 --> 00:39:13.290
to the user or to the screen by
selecting multiple different UV meshes.

00:39:14.350 --> 00:39:15.580
So, what's a NIRB?

00:39:15.600 --> 00:39:18.900
Actually,
I was going through the airport,

00:39:18.900 --> 00:39:22.970
and my book dropped out,
and a guy comes up and goes,

00:39:23.020 --> 00:39:23.950
what's a NIRB?

00:39:24.000 --> 00:39:29.240
And I got to about non-uniform rational,
and his eyes glazed over,

00:39:29.240 --> 00:39:29.960
and he walked away.

00:39:29.960 --> 00:39:33.940
So... Most people say that.

00:39:34.040 --> 00:39:35.140
Nobody really understands NIRBs.

00:39:35.160 --> 00:39:36.240
Actually, that's what it means.

00:39:36.240 --> 00:39:39.560
So,
it's a surface defined by interpolating

00:39:39.560 --> 00:39:40.560
a number of control points.

00:39:40.560 --> 00:39:42.280
It's used a lot in CAD.

00:39:43.120 --> 00:39:49.360
It's dominant in CAD for... Because it
can do sphericals and a number of things

00:39:49.360 --> 00:39:50.660
you can't do with Bayes-Zier surfaces.

00:39:50.660 --> 00:39:53.650
If you want more information on NIRBs,
I'm not going to explain

00:39:53.650 --> 00:39:54.290
how they work here.

00:39:54.300 --> 00:39:58.510
Go search for Introduction
to NIRBs on the web,

00:39:58.520 --> 00:40:03.980
or Rogers has a pretty good book on it,
and it's very simple to read.

00:40:06.270 --> 00:40:11.960
So, we're going to do an outline of how
to draw NURBS using a vertex program.

00:40:11.990 --> 00:40:15.800
We're going to compute the
B-spline basis functions for

00:40:15.960 --> 00:40:18.240
that particular NURB on the host.

00:40:18.250 --> 00:40:20.070
It's a recursive evaluator.

00:40:20.070 --> 00:40:22.390
That's the biggest problem
I had with figuring out how to

00:40:22.470 --> 00:40:24.200
do it on the vertex shaders.

00:40:24.200 --> 00:40:25.760
It's a recursive function.

00:40:25.760 --> 00:40:28.480
There's no branches, there's no calls,
there's no jumps.

00:40:28.510 --> 00:40:30.240
So it had to be computed on the host.

00:40:30.270 --> 00:40:32.440
That's actually a pretty good
thing because you only compute it

00:40:32.440 --> 00:40:34.600
once and you never use it again.

00:40:34.620 --> 00:40:40.520
So, you're going to load the control
points as local program parameters.

00:40:40.590 --> 00:40:43.920
And then you can do the same
thing for your position,

00:40:44.100 --> 00:40:45.920
your normal, your texture coordinates.

00:40:45.990 --> 00:40:47.320
They just get loaded
as control parameters.

00:40:47.430 --> 00:40:49.440
They don't get loaded as a new mesh.

00:40:49.490 --> 00:40:52.400
It's essentially just
control point parameters.

00:40:53.020 --> 00:40:58.310
So you're only loading 16 points
for each parameter that you

00:40:58.650 --> 00:41:00.700
want to load in this example.

00:41:02.910 --> 00:41:07.100
This example is a 4x4 controlled mesh.

00:41:07.160 --> 00:41:10.440
The position information is
interpolated by the Vertex Program.

00:41:10.440 --> 00:41:14.510
A real simple example.

00:41:15.740 --> 00:41:22.700
On the implementation side,
so you have four by four

00:41:22.940 --> 00:41:25.310
control mesh,
if you don't know anything about nerves,

00:41:25.330 --> 00:41:27.770
that means you're going
to have 16 control points,

00:41:28.230 --> 00:41:32.100
16 basis functions per UV value,
and that's a lot of storage.

00:41:32.180 --> 00:41:37.560
So what I do is I actually
post-multiply the basis functions

00:41:37.560 --> 00:41:41.520
in terms of rows and columns on
the vertex program as I go along,

00:41:41.520 --> 00:41:46.010
and that essentially reduces the
requirements down to eight floats.

00:41:46.010 --> 00:41:50.510
So if you look at the little, you know,
formula right here, you see, you know,

00:41:50.560 --> 00:41:54.390
the UV point is the sum of
your number of control points,

00:41:54.430 --> 00:41:58.660
which is 16, and then you have two
sets of basis functions,

00:41:58.660 --> 00:42:00.370
one for the rows and one for the columns.

00:42:00.420 --> 00:42:03.300
Let's do a demo.

00:42:09.580 --> 00:42:15.700
so we're here we are surface i put
a texture on it uh... just uh...

00:42:15.880 --> 00:42:19.930
Here's a UV values coming in there.

00:42:20.080 --> 00:42:23.080
It's actually quite a
few number of points.

00:42:23.110 --> 00:42:23.960
It's 10,000 points.

00:42:24.020 --> 00:42:25.950
It's 100 by 100 grid.

00:42:26.230 --> 00:42:28.820
There's a number of the
control points right here.

00:42:28.980 --> 00:42:32.120
You can grab the control points.

00:42:32.180 --> 00:42:34.610
You can move the surface real time.

00:42:34.980 --> 00:42:39.110
This is all being computed
on the Vertex Program.

00:42:39.110 --> 00:42:42.330
It's been loaded as a UV mesh in VRAM.

00:42:42.570 --> 00:42:45.800
It never goes across the
AGP bus more than once.

00:42:45.800 --> 00:42:50.800
And you can do a lot
of fun things with it.

00:42:50.800 --> 00:42:53.990
NURBS are actually a
very flexible surface.

00:42:58.100 --> 00:43:05.100
[Transcript missing]

00:43:09.680 --> 00:43:12.660
So, let's talk about what we've seen.

00:43:12.840 --> 00:43:17.280
Mesh was 100 by 100, it's 10,000 points.

00:43:17.290 --> 00:43:20.780
If you do the math,
just for the position only,

00:43:20.780 --> 00:43:25.100
that's 96,000, 960,000 flops that the
host didn't have to do.

00:43:25.220 --> 00:43:30.240
A full-screen application
running at 1280 by 1K,

00:43:30.310 --> 00:43:33.740
75 frames per second, blah, blah, blah,
blah, is about a gigaflop,

00:43:33.770 --> 00:43:34.980
just for the position only.

00:43:35.060 --> 00:43:37.600
So if you want to add
textures and normals to that,

00:43:37.600 --> 00:43:40.400
you can add on an entry
of three gigaflops.

00:43:40.420 --> 00:43:42.810
And the GPUs can do it.

00:43:45.360 --> 00:43:48.100
So let's talk about
the program real quick.

00:43:48.100 --> 00:43:50.540
Hopefully you're not straining your eyes.

00:43:50.550 --> 00:43:55.050
I have two inputs,
a U basis and a V basis.

00:43:55.070 --> 00:43:57.540
There's four floating
point SIMD values there.

00:43:57.780 --> 00:44:02.980
Bring them in through the
vertex position and the color.

00:44:02.980 --> 00:44:06.340
And I have a number of control
points as program locals.

00:44:06.420 --> 00:44:09.300
I didn't show them all,
there's a number of them.

00:44:09.300 --> 00:44:10.760
16.

00:44:10.760 --> 00:44:15.770
So here I am, I'm pre-computing,
post-multiplying the basis functions to

00:44:15.980 --> 00:44:22.540
come up with the required basis functions
I need for each row-column combination.

00:44:22.540 --> 00:44:28.900
So I multiply, post-multiply,
and then I start my multiply-accumulate

00:44:28.900 --> 00:44:32.650
on all the control points
as I go along for each

00:44:36.560 --> 00:44:40.730
For this example, it's a four by four,
so there's four rows,

00:44:40.920 --> 00:44:43.160
so there's four sets of these things.

00:44:43.350 --> 00:44:47.980
I go along continually computing
the new basis functions,

00:44:48.000 --> 00:44:51.090
and I finally end up
with a final position.

00:44:51.480 --> 00:44:57.040
Do a transform, I have a result position,
and then I start, then I just move the

00:44:57.040 --> 00:44:58.130
texture coordinate along.

00:44:58.230 --> 00:45:00.620
The texture was normalized
between zero and one,

00:45:00.710 --> 00:45:02.980
so it fit across the whole surface.

00:45:05.420 --> 00:45:11.570
so where do you go from
here pretty cool stuff

00:45:12.020 --> 00:45:14.690
Michael Kahn: Well,
you can import the position and

00:45:14.760 --> 00:45:18.050
normals and the color information,
texture information,

00:45:18.100 --> 00:45:20.510
from a modeler program
directly into this.

00:45:20.510 --> 00:45:23.740
You can design vertex programs
for different size meshes,

00:45:23.750 --> 00:45:26.910
you know, 3x5s,
anything in that value if you look at

00:45:26.910 --> 00:45:30.810
the number of instructions it takes,
once you figure out how it works,

00:45:30.810 --> 00:45:33.230
you know that you're
bound to a certain size.

00:45:33.460 --> 00:45:36.560
You can't interpolate
10x10 control measures.

00:45:36.560 --> 00:45:39.950
There's not enough space in
the vertex program to do that.

00:45:40.380 --> 00:45:42.490
Michael Kahn:
And then you can actually do,

00:45:42.490 --> 00:45:45.700
I haven't figured out how,
but I know I can do it,

00:45:45.700 --> 00:45:47.430
subdivision surfaces.

00:45:47.470 --> 00:45:50.560
Subdivision surfaces,
people have always said

00:45:51.000 --> 00:45:53.890
that they're algorithmic,
they're always,

00:45:53.890 --> 00:45:56.370
they're like similar to B-splines.

00:45:56.610 --> 00:46:00.030
Michael korsan: But if you look for it,
there's an exact solution for

00:46:00.050 --> 00:46:03.440
subdivision surfaces in SIGGRAPH98,
in the backend of it.

00:46:03.440 --> 00:46:05.870
Somebody actually sat
down and figured it out.

00:46:05.970 --> 00:46:09.990
So that was one of the biggest problems
of implementing subdivision surfaces.

00:46:10.510 --> 00:46:14.480
Michael korsan: You know,
if you want to do very simple demos,

00:46:14.480 --> 00:46:18.760
bilinear surfaces are easy,
basiar surfaces you can put the basis

00:46:18.760 --> 00:46:23.920
functions on the vertex program,
and NURBS get a little more complicated.

00:46:24.030 --> 00:46:28.200
Michael korsan: Like I said,
it uses recursion, but basiar are simple.

00:46:28.320 --> 00:46:30.610
So let's do a wrap-up.

00:46:31.800 --> 00:46:34.080
So Vertex Program,
they're a powerful tool

00:46:34.170 --> 00:46:37.020
for shading and lighting.

00:46:37.050 --> 00:46:42.280
You can use custom lighting models
outside the OpenGL lighting model.

00:46:42.320 --> 00:46:46.120
You can add additional complexity to
your geometries using Vertex Programs.

00:46:46.160 --> 00:46:49.190
And also you can actually go
to a lot finer level of detail.

00:46:49.190 --> 00:46:51.380
I mean if you look at some
of the games out there today,

00:46:51.400 --> 00:46:54.890
the level of detail is horrific.

00:46:55.110 --> 00:46:59.500
You can use UV meshes
to define most surfaces.

00:46:59.530 --> 00:47:02.300
And once a UV mesh is defined,
you can load it in VRAM and it'll

00:47:02.300 --> 00:47:04.970
never go across the AGP bus again.

00:47:05.170 --> 00:47:12.350
and Michael Larson,
who is the executive director of

00:47:12.580 --> 00:47:18.090
the OpenGL Graphics Processing Unit.

00:47:18.090 --> 00:47:18.090
Michael Larson: Thank you, Michael.

00:47:18.090 --> 00:47:18.090
I'm going to go ahead and
turn it over to Michael.

00:47:19.570 --> 00:47:21.880
So where do you start?

00:47:22.050 --> 00:47:25.000
Start with Shader Builder.

00:47:25.070 --> 00:47:27.860
Start with simple transforms, you know,
play with the scale,

00:47:27.860 --> 00:47:29.950
play with the position,
move those things around,

00:47:30.010 --> 00:47:34.340
change the color,
get a feeling for how the language works.

00:47:34.850 --> 00:47:36.260
and move on to lighting models.

00:47:36.260 --> 00:47:38.380
I actually skipped the lighting models,
I wanted to write the services,

00:47:38.380 --> 00:47:40.690
but that's just the way I am.

00:47:40.700 --> 00:47:43.700
And then move on to simple UV meshes.

00:47:43.700 --> 00:47:48.190
Try implicit surface models,
come up with your crazy

00:47:48.260 --> 00:47:52.260
cool math thingies,
and then start exploring B-splines

00:47:52.260 --> 00:47:54.730
and NURBS and everything else.

00:47:55.360 --> 00:47:58.700
So, more information on
the Arb Vertex Program.

00:47:58.700 --> 00:48:00.480
You can read the spec.

00:48:00.700 --> 00:48:03.440
It's 60 pages long and very detailed.

00:48:03.500 --> 00:48:05.180
Lots of information in there.

00:48:05.260 --> 00:48:09.090
It gives you kind of a guideline
of what things are supposed to do.

00:48:09.240 --> 00:48:12.200
Or you can use Shader Builder.

00:48:12.200 --> 00:48:15.200
I'm going to try and have these
posted in the next couple weeks.

00:48:15.360 --> 00:48:16.200
Hopefully.

00:48:16.200 --> 00:48:19.200
. Yeah.

00:48:19.200 --> 00:48:20.200
Yeah.

00:48:20.200 --> 00:48:24.700
And then,
or through the Mac OpenGL mailing list.

00:48:34.480 --> 00:48:39.400
Now I'd like to do a quick
twirl through the roadmap here.

00:48:39.400 --> 00:48:41.610
We have planned for
the remaining sessions,

00:48:41.610 --> 00:48:49.110
talking about OpenGL and also the
graphics technology in MacOSX.

00:48:49.200 --> 00:48:51.190
on Wednesday obviously.

00:48:51.200 --> 00:48:56.760
So what we have remaining for
you tomorrow in the OpenGL track

00:48:56.760 --> 00:48:59.100
is essentially fragment
programming with OpenGL.

00:48:59.100 --> 00:49:03.340
This is the sort of more pixel-specific
companion to programmability.

00:49:03.340 --> 00:49:04.820
It's also going to be
a really cool session,

00:49:04.820 --> 00:49:06.480
lots of interesting demos.

00:49:06.480 --> 00:49:07.680
So if you're interested
in programmability,

00:49:07.680 --> 00:49:12.060
unlocking the power of the GPU,
you should also attend that session.

00:49:12.060 --> 00:49:14.040
We also have,
obviously we're going to talk tomorrow

00:49:14.050 --> 00:49:18.410
about our course 2D technology,
which is also relevant

00:49:18.420 --> 00:49:21.030
for OpenGL developers,
'cause one of the things we announced

00:49:21.030 --> 00:49:23.750
in our graphics and imaging overview
session yesterday is the ability

00:49:23.750 --> 00:49:28.180
to use 2D drawing API to draw
directly into an OpenGL context.

00:49:28.180 --> 00:49:30.340
That can also be very exciting
for OpenGL developers,

00:49:30.340 --> 00:49:35.080
'cause it can make things like doing
high-quality text in OpenGL very easy.

00:49:36.280 --> 00:49:39.500
Then we have a great session that if
you're doing any OpenGL development,

00:49:39.510 --> 00:49:43.200
you have to attend session 209,
which is the OpenGL optimizations.

00:49:43.200 --> 00:49:47.110
One thing that I've realized in
working with a lot of developers who

00:49:47.140 --> 00:49:50.780
are using OpenGL is in many cases,
they're leaving performance

00:49:50.780 --> 00:49:52.200
on the floor on the platform.

00:49:52.200 --> 00:49:56.050
And it's in many cases we have a great
tool set and this session will provide

00:49:56.050 --> 00:50:00.200
a lot of information for you to learn
how to take a look at your applications

00:50:00.200 --> 00:50:03.200
and figure out how to unlock the true
performance potential of both the GPUs

00:50:03.200 --> 00:50:06.200
and also the Macintoshes of the platform.

00:50:06.200 --> 00:50:11.080
And then another thing that might
be interesting is session 211,

00:50:11.080 --> 00:50:16.200
which is going to be on Friday,
which is introduction to Quartz Services.

00:50:16.200 --> 00:50:19.320
Now this is a non-drawing API in Quartz,
but one of the things it does that's very

00:50:19.320 --> 00:50:21.060
important is it manages the displays.

00:50:21.200 --> 00:50:24.870
So a lot of OpenGL developers
have need to find out what the

00:50:24.870 --> 00:50:29.180
configuration of the display is,
what display modes available

00:50:29.180 --> 00:50:31.200
on the particular display are.

00:50:31.350 --> 00:50:34.400
And this is the core APIs that we
really want developers to adopt

00:50:34.400 --> 00:50:36.180
and use in their applications.

00:50:36.250 --> 00:50:41.200
To do things such as screen capture
and display reconfiguration.

00:50:41.200 --> 00:50:43.200
So you should attend that.

00:50:43.200 --> 00:50:46.260
And then also we have
our hardware partners,

00:50:46.260 --> 00:50:48.040
ATI, are here this year.

00:50:48.240 --> 00:50:51.200
And then session 212,
which is also on Friday,

00:50:51.200 --> 00:50:53.320
they're going to sort of push the
envelope and show what you can do with

00:50:53.410 --> 00:50:58.200
their latest generation of GPU hardware
and also programmable features.

00:50:58.400 --> 00:51:01.560
Because their demo team is going
to essentially show what they do to

00:51:01.560 --> 00:51:05.200
create their incredibly captivating
demonstrations that they do.

00:51:05.200 --> 00:51:06.200
Thank you.

00:51:06.200 --> 00:51:09.200
To support their announcements
of their hardware.

00:51:09.200 --> 00:51:12.200
So it's going to be a
really cool session.

00:51:12.200 --> 00:51:14.970
And it's going to leverage a lot
of what you've learned today and

00:51:14.970 --> 00:51:17.700
tomorrow in fragment programming
with fragment programming

00:51:17.700 --> 00:51:19.200
session and vertex programming.

00:51:21.000 --> 00:51:25.130
And then, obviously we have a
feedback forum on Friday,

00:51:25.140 --> 00:51:27.220
our traditional spot,
the last feedback forum.

00:51:27.220 --> 00:51:30.140
But we urge you to come back,
come to the feedback forum and

00:51:30.140 --> 00:51:33.240
let us know what sort of things
you want to see in MacOSX from

00:51:33.240 --> 00:51:34.400
a technology perspective.

00:51:34.400 --> 00:51:38.780
Because a lot of the feedback we get
at WWC is what we take back and start

00:51:38.780 --> 00:51:43.400
working from to figure out what goes
in the next major release of MacOSX.

00:51:43.400 --> 00:51:47.390
So I think we have a QA,
or we have contact information.

00:51:47.390 --> 00:51:49.400
If you have questions
about what you've learned,

00:51:49.400 --> 00:51:53.400
you can contact Michael Larsen,
who is the presenter today.

00:51:53.400 --> 00:51:56.590
And if you have other questions,
Jeff Stahl is very active

00:51:56.670 --> 00:51:59.610
with developers directly,
and you can also use him as

00:51:59.610 --> 00:52:01.390
a contact reference point.

00:52:01.400 --> 00:52:03.550
I'd also like to add
my name to this list,

00:52:03.600 --> 00:52:06.920
if you had questions about this
session or any of the graphics

00:52:06.990 --> 00:52:09.400
technologies on MacOSX,
you can feel free to contact me,

00:52:09.400 --> 00:52:12.400
Travis Brown, at Travis@apple.com.

00:52:12.400 --> 00:52:12.400
Thank you.

00:52:14.910 --> 00:52:17.280
So we have some additional information.

00:52:17.520 --> 00:52:21.660
These are essentially where the
R Vertex programming spec can be found.

00:52:21.690 --> 00:52:24.040
And I'll leave this up
here for a little bit.

00:52:24.040 --> 00:52:26.110
And what I'm actually going
to do is I'm going to go ahead

00:52:26.130 --> 00:52:28.880
and invite the Q&A team up,
the OpenGL engineering

00:52:28.880 --> 00:52:29.800
team up to the stage.

00:52:29.800 --> 00:52:31.290
And we'll actually engage
in a question and answer.

00:52:31.300 --> 00:52:32.500
And I'll leave this up here.

00:52:32.500 --> 00:52:36.490
So if you want to copy
information down off this,

00:52:36.490 --> 00:52:36.490
you'll have plenty of time.

00:52:45.800 --> 00:52:48.520
Okay, so we have some microphones
in the center right here.

00:52:48.610 --> 00:52:50.240
If you have any questions
about what you've seen today,

00:52:50.260 --> 00:52:51.800
please feel free to go to microphone.

00:52:51.800 --> 00:52:56.020
You know,
basically announce your name and your

00:52:56.020 --> 00:52:59.430
company and we'll field your question.
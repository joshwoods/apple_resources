WEBVTT

00:00:25.570 --> 00:00:28.560
Well, good afternoon,
ladies and gentlemen.

00:00:28.600 --> 00:00:33.010
Welcome to the
QuickTime feedback session.

00:00:33.580 --> 00:00:35.440
If you really want the
QuickTime feedback session,

00:00:35.450 --> 00:00:36.600
though, you shouldn't be in here.

00:00:36.600 --> 00:00:39.020
You should be in the
room right behind us,

00:00:39.070 --> 00:00:39.890
the marina.

00:00:39.900 --> 00:00:43.230
So does anybody want to take this
opportunity to get up and leave?

00:00:45.650 --> 00:00:51.610
Okay, so welcome to the FireWire
Reference Platform session.

00:00:52.580 --> 00:00:58.430
My name is Colin Whitby-Strevens,
and I speak with an English accent.

00:00:58.540 --> 00:01:02.950
So this is really just a few words
for you to get yourself calibrated

00:01:02.950 --> 00:01:05.880
to listening to an English accent.

00:01:05.880 --> 00:01:08.910
The other thing I should perhaps
warn you about is that when

00:01:08.910 --> 00:01:12.760
I get excited about technology,
I tend to speak faster and faster,

00:01:12.910 --> 00:01:16.910
so you may have to slow me down as well,
or else it'll be totally impossible

00:01:16.910 --> 00:01:18.860
to understand what I'm saying.

00:01:27.730 --> 00:01:34.120
So what I'm intending to tell you
about over the next hour or so is

00:01:34.120 --> 00:01:39.110
to give you an overview of what
the FireWire Reference Platform is,

00:01:39.980 --> 00:01:46.310
and then to tell you in some detail
about two or three of its components.

00:01:47.660 --> 00:01:49.870
In particular,
I'm going to tell you about

00:01:50.360 --> 00:01:53.270
something called TNF Kernel,
which is the heart of it.

00:01:53.290 --> 00:01:56.800
TNF Sys, TNF Link Drivers.

00:01:56.850 --> 00:01:59.000
This is the heart of the platform.

00:01:59.000 --> 00:02:04.560
I'm going to be giving two examples
of the code which is included in the

00:02:04.560 --> 00:02:09.650
platform for supporting protocols,
FireWire protocols.

00:02:09.660 --> 00:02:13.140
There are many protocols
supported in the platform,

00:02:13.160 --> 00:02:15.910
and these are really just two examples.

00:02:17.640 --> 00:02:22.500
and TNF gets used very
frequently in this presentation.

00:02:22.850 --> 00:02:28.500
And what it means is just
a little acronym for 1394.

00:02:28.940 --> 00:02:31.800
So we talk about TNF this,
TNF that all the time.

00:02:31.850 --> 00:02:37.140
And you'll find that all the APIs have
got the letters TNF at the beginning.

00:02:37.200 --> 00:02:40.110
And that really was just a little
attempt to make sure we didn't get

00:02:40.110 --> 00:02:42.230
nasty name clashes and the like.

00:02:42.460 --> 00:02:46.690
But just to say that really the
objective I have this afternoon

00:02:47.070 --> 00:02:52.060
is not to train you in every fine
detail of the reference platform,

00:02:52.410 --> 00:02:55.950
but to give you a flavor
of how it is constructed,

00:02:56.060 --> 00:02:58.990
how it is architected,
and how you can use it,

00:02:58.990 --> 00:03:03.250
and how you might go about
building your applications using

00:03:03.250 --> 00:03:05.580
the TNF reference platform.

00:03:07.880 --> 00:03:09.200
So, what is it?

00:03:09.230 --> 00:03:14.770
Well, in a single sentence,
the reference platform is the

00:03:15.130 --> 00:03:22.280
source code and documentation for
a pile of software which enables

00:03:22.280 --> 00:03:27.450
you to develop what we might call
end-of-the-wire FireWire devices.

00:03:27.620 --> 00:03:32.110
So these are products that you
would like to build which are

00:03:32.110 --> 00:03:35.060
complementary to the main Mac products.

00:03:36.660 --> 00:03:41.850
This also means that this software is
not related to other Apple operating

00:03:41.940 --> 00:03:44.680
system FireWire stack software.

00:03:44.680 --> 00:03:49.580
It is independent of that,
and it's intended to be freestanding

00:03:49.580 --> 00:03:52.220
in end-of-the-wire products.

00:03:53.800 --> 00:03:59.000
Indeed, it's been designed very much
with the embedded system in mind.

00:03:59.000 --> 00:04:03.740
It needs some form of
real-time operating system,

00:04:03.740 --> 00:04:08.740
but really its requirements on real-time
operating system are pretty small,

00:04:08.740 --> 00:04:12.160
and a lightweight real-time
operating system will do.

00:04:12.160 --> 00:04:16.270
There are a variety of
RTOSs that are supported,

00:04:16.270 --> 00:04:21.790
and there's a very easy way of
porting it to other RTOSs as well.

00:04:22.410 --> 00:04:25.070
It also supports a variety
of 1394 link chips.

00:04:25.070 --> 00:04:31.680
You may be aware that in
a computer like a Mac,

00:04:31.680 --> 00:04:34.390
you find a link chip
which is called OHCI,

00:04:34.390 --> 00:04:36.840
Open Host Controller Interface.

00:04:36.840 --> 00:04:43.780
And that is very much a chip which is
optimized to use in that sort of device,

00:04:43.930 --> 00:04:46.000
in a Mac of some sort.

00:04:46.000 --> 00:04:49.040
But there are many other
link chips around which are,

00:04:49.040 --> 00:04:52.260
again,
optimized towards embedded applications.

00:04:52.300 --> 00:04:58.230
And the FireWire Reference
Platform really is designed to be equally

00:04:58.230 --> 00:05:03.460
suitable for use in an OHCI environment
or in other link chip environments.

00:05:03.480 --> 00:05:08.550
So there are several drivers provided,
and in essence there's a kit

00:05:08.970 --> 00:05:14.450
provided which you can use in order
to drive other 1394 link chips.

00:05:16.590 --> 00:05:21.020
But the great thing about it
is that it supports multiple

00:05:21.020 --> 00:05:25.440
FireWire application protocols,
and it supports them simultaneously,

00:05:25.440 --> 00:05:32.210
in that you can build an
application which requires,

00:05:32.210 --> 00:05:35.930
in order to work properly,
several different FireWire

00:05:35.930 --> 00:05:40.040
application protocols,
and you can have those all running

00:05:40.040 --> 00:05:44.670
simultaneously within your application
using the reference platform.

00:05:49.250 --> 00:05:55.480
So, what actually is in the box,
or when you go and download from the web,

00:05:55.480 --> 00:05:56.450
what do you find?

00:05:56.460 --> 00:06:00.430
Well, first of all,
you find some software for a number of

00:06:00.770 --> 00:06:03.110
modules which we call the class services.

00:06:03.120 --> 00:06:06.990
The heart of the whole system
is a thing called the kernel,

00:06:07.050 --> 00:06:08.060
TNF kernel.

00:06:08.060 --> 00:06:12.550
There are then some services
for supporting different

00:06:13.030 --> 00:06:15.340
classes of protocols.

00:06:16.160 --> 00:06:20.460
One, the main one,
first one we mention here is AVC General.

00:06:20.460 --> 00:06:26.000
The audio-visual control protocols
is a large family of protocols

00:06:26.000 --> 00:06:28.960
that have been standardized
by the 1394 Trade Association.

00:06:28.960 --> 00:06:33.630
We provide the support for all of those,
the general underlying

00:06:33.920 --> 00:06:37.250
support for all of those,
and then we provide

00:06:37.360 --> 00:06:42.660
specific protocols for disk,
DVD, panel, and tape sub-units.

00:06:44.320 --> 00:06:47.800
We provide software for
asynchronous connections.

00:06:47.800 --> 00:06:54.460
That's a method of streaming
data from one device to another,

00:06:54.460 --> 00:06:57.020
but by using asynchronous operations.

00:06:57.020 --> 00:07:00.500
That again is a standardized protocol.

00:07:00.500 --> 00:07:05.000
We provide support for
something called EIA-775,

00:07:05.550 --> 00:07:10.380
which is an EIA protocol for
on-screen display for digital TVs.

00:07:11.910 --> 00:07:19.200
We provide IP 1394,
in particular RFC 2734, which is IPv4.

00:07:20.600 --> 00:07:25.030
PPDT,
point-to-point data transport protocol,

00:07:25.090 --> 00:07:30.680
and last but not least, SPP2,
which is a protocol specifically

00:07:30.720 --> 00:07:33.020
for devices like disks and printers.

00:07:35.100 --> 00:07:40.310
You'll find all of those in the
FireWire Reference Platform.

00:07:41.200 --> 00:07:46.100
For RTOS interfaces,
there's a module called TNF-SYS,

00:07:46.100 --> 00:07:49.140
which is the module which,
a single module,

00:07:49.140 --> 00:07:52.500
which provides the RTOS independence.

00:07:52.500 --> 00:07:56.300
And we provide
TNF-SYS implementations for VxWorks,

00:07:56.430 --> 00:08:01.380
MicroiTron, Nucleus,
a rather early version of MicroCOS,

00:08:01.390 --> 00:08:05.760
and there's also a generic
template so that you can port

00:08:05.870 --> 00:08:07.910
to your own favorite RTOS.

00:08:08.160 --> 00:08:13.590
We provide a board support package
so that you can bring up the whole of

00:08:13.590 --> 00:08:17.820
the FireWire Reference Platform and
actually make it tick and do something,

00:08:17.820 --> 00:08:20.700
even though it may not be working
on your particular hardware.

00:08:20.700 --> 00:08:29.050
And that's been engineered around a
standard PC x86 platform with VxWorks.

00:08:31.810 --> 00:08:35.420
For link drivers,
you find link drivers for OHCI,

00:08:35.420 --> 00:08:40.260
for the Texas Instruments
CE-Links and GP-Links,

00:08:40.260 --> 00:08:46.780
for the MD8412,
and also a generic link driver toolkit.

00:08:46.780 --> 00:08:50.010
The link driver also
features some plug-ins,

00:08:50.010 --> 00:08:54.820
because quite often you have some
specialized hardware that you also want

00:08:54.820 --> 00:08:56.820
to be able to access at the driver level.

00:08:57.960 --> 00:08:59.480
And in particular,
there's a couple of examples.

00:08:59.480 --> 00:09:03.210
One is for the global unique identifier,
which will be implemented in a

00:09:03.210 --> 00:09:05.380
system-dependent way in your hardware.

00:09:05.380 --> 00:09:09.160
And the other one is for DMA features.

00:09:15.850 --> 00:09:21.550
In order to exercise
this pile of software,

00:09:21.900 --> 00:09:28.210
we have a generic command line interface,
which is called ZShell.

00:09:28.390 --> 00:09:34.740
Using ZShell, we then provide a number of
little command-line applications,

00:09:35.830 --> 00:09:42.920
which essentially implement
various 1394 transactions,

00:09:42.920 --> 00:09:45.690
exercise various protocols, and so on.

00:09:45.700 --> 00:09:49.920
There's a generic one called TMA,
and when you get to use the

00:09:49.920 --> 00:09:53.600
FireWire Reference Platform,
you probably find yourself

00:09:53.600 --> 00:09:54.990
using TMA really quite a lot.

00:09:55.880 --> 00:10:00.100
It's a rather low-level thing,
but it allows you to directly

00:10:00.670 --> 00:10:05.970
generate 1394 transactions on a bus
so that you can do reads and writes.

00:10:06.100 --> 00:10:08.160
You can go and view devices.

00:10:08.160 --> 00:10:09.460
You can find out what's on the bus.

00:10:09.530 --> 00:10:13.170
You can find out which devices route,
and so on and so forth.

00:10:13.270 --> 00:10:19.340
You can generate bus resets by typing
appropriate command lines commands at it.

00:10:19.340 --> 00:10:25.800
There are then command-line applications
for an AVC tape controller and target.

00:10:25.820 --> 00:10:28.410
In other words,
you can pretend to be an AVC tape

00:10:28.510 --> 00:10:32.520
controller and give the sorts of commands
that an AVC tape controller will do,

00:10:32.520 --> 00:10:34.790
or you can pretend to
be an AVC tape target.

00:10:34.800 --> 00:10:39.640
There's somewhat embryonic,
but it's there, a 1394 bridge manager.

00:10:39.640 --> 00:10:42.570
That's in anticipation
of the 1394.1 standard,

00:10:42.700 --> 00:10:44.340
which is still not yet finished.

00:10:44.380 --> 00:10:51.500
AVC disk controller and target, DVD,
PBDT, SPP2 disk, et cetera.

00:10:51.500 --> 00:10:52.620
There are a few others as well.

00:10:52.620 --> 00:10:55.620
All of these are rather low-level.

00:10:55.820 --> 00:10:59.010
There are other low-level ways of
exercising these functions from

00:10:59.120 --> 00:11:00.870
the FireWire Reference Platform.

00:11:04.200 --> 00:11:06.530
We also have a number of
demonstration applications built

00:11:06.650 --> 00:11:07.860
into the reference platform.

00:11:07.860 --> 00:11:12.410
There's one for the on-screen
display features of EIA-775

00:11:12.410 --> 00:11:14.250
for digital televisions.

00:11:14.250 --> 00:11:19.370
There's actually a couple of applications
for personal video recorders,

00:11:19.490 --> 00:11:23.200
essentially emulating a
tape recorder using a disc.

00:11:24.050 --> 00:11:29.640
There's some demonstration of IP3094,
AVC panel.

00:11:29.910 --> 00:11:37.050
There's another PVR application which
is really using AVC disk directly,

00:11:37.160 --> 00:11:42.800
SVP2 disk, SVP2 initiator,
where you're on the host

00:11:42.890 --> 00:11:47.240
side controlling a disk,
and some more.

00:11:47.260 --> 00:11:49.810
So a whole range of
demonstration applications which,

00:11:49.830 --> 00:11:51.950
with a bit of luck,
you ought to be able to get up

00:11:51.950 --> 00:11:53.750
and running really quite quickly.

00:11:53.870 --> 00:11:58.240
Again, to sort of get you started,
get you with the right sort

00:11:58.240 --> 00:12:02.350
of feel for what it's like to
either drive or to implement a

00:12:02.350 --> 00:12:05.140
FireWire end-of-the-wire device.

00:12:07.940 --> 00:12:11.270
And of course,
there's a ton of documentation.

00:12:11.540 --> 00:12:14.440
I actually went through and
counted that there's a total of

00:12:14.450 --> 00:12:18.610
20 PDF manuals in this thing,
and also various release notes

00:12:18.610 --> 00:12:20.790
with the various modules.

00:12:20.800 --> 00:12:23.660
And then there's a whole
lot of assorted other things

00:12:23.660 --> 00:12:27.110
which are helpful and useful,
like make files and various other

00:12:27.170 --> 00:12:29.060
little tools all bound up in it.

00:12:30.590 --> 00:12:32.830
and all comes in a tile.

00:12:34.140 --> 00:12:40.410
Now, the architecture of all of this

00:12:40.970 --> 00:12:44.150
is given in this slide.

00:12:44.610 --> 00:12:47.750
The heart of it all, as I said,
is TNF Kernel.

00:12:47.960 --> 00:12:54.140
TNF Kernel provides transaction
services for the 1394 bus.

00:12:54.430 --> 00:13:02.100
It operates on a client-server model,
so it can support a number of clients.

00:13:02.320 --> 00:13:06.500
And the client, if you like,
logs into TNF Kernel, gets some IDs,

00:13:06.500 --> 00:13:09.000
and then does what it wants to do.

00:13:09.020 --> 00:13:13.750
And so examples of clients are
our protocols to support SPP2,

00:13:13.750 --> 00:13:19.250
or our protocols to support AVC, IP1394,
or whatever.

00:13:20.320 --> 00:13:24.560
TNF Kernel also includes some
bus management utilities,

00:13:24.560 --> 00:13:27.290
which in fact operate as clients as well.

00:13:28.950 --> 00:13:31.720
So you can have any number of clients,
and this is extensible.

00:13:31.720 --> 00:13:33.600
You can invent your own
clients if you like.

00:13:35.710 --> 00:13:40.510
Then each of our protocols actually
operates in the same sort of model.

00:13:40.510 --> 00:13:46.220
Each protocol itself can
have one or more clients.

00:13:46.430 --> 00:13:49.410
So we have some software to
support disks and printers,

00:13:49.410 --> 00:13:52.270
for example, which run on top of SPP2.

00:13:52.270 --> 00:13:57.760
AVC,
we've got some software modules which

00:13:57.760 --> 00:14:02.440
support very specific AVC devices.

00:14:05.000 --> 00:14:10.060
On top of all of this,
you build then your application.

00:14:10.170 --> 00:14:12.620
And in general,
you will use the interfaces sort

00:14:12.620 --> 00:14:17.370
of up here to the particular
protocols that you want to support.

00:14:17.700 --> 00:15:41.900
[Transcript missing]

00:15:43.110 --> 00:15:45.680
So let's start peeling
the onion a little bit,

00:15:45.760 --> 00:15:47.920
tell you a little bit more about
two or three of these modules.

00:15:47.920 --> 00:15:50.200
As I said, really,
the objective here is not to

00:15:50.200 --> 00:15:53.380
give you every last detail,
but to give you a flavor of how

00:15:53.420 --> 00:15:55.990
these things are constructed,
how they're used,

00:15:56.040 --> 00:15:58.850
and how you can build an
application with them.

00:15:58.860 --> 00:16:01.870
And we start off with TNF Kernel.

00:16:03.120 --> 00:16:05.690
So the main features of TNF Kernel.

00:16:05.800 --> 00:16:16.080
First of all, it provides transaction
support for 1394 operations.

00:16:16.100 --> 00:16:20.930
And a FireWire transaction is
something like a read or a write.

00:16:21.130 --> 00:16:23.680
So you get quad-lit reads,
quad-lit writes, block reads,

00:16:23.690 --> 00:16:27.410
block writes to other devices on the bus.

00:16:27.430 --> 00:16:29.700
And this is actually both
incoming and outgoing,

00:16:29.820 --> 00:16:37.840
so other devices on the bus can send
reads and writes to your device.

00:16:38.000 --> 00:16:39.800
And Kernel will pick up
those reads and writes,

00:16:39.800 --> 00:16:42.030
and will decide what to do with them.

00:16:42.700 --> 00:16:44.990
It has command and indication queues.

00:16:44.990 --> 00:16:48.900
So if you like the model,
as far as you're concerned,

00:16:48.900 --> 00:16:51.660
as far as the clients
of Kernel are concerned,

00:16:51.660 --> 00:16:55.630
are that several transactions can
be outstanding at the same time.

00:16:55.630 --> 00:16:58.060
You know that's a nice
feature of FireWire.

00:16:58.060 --> 00:17:00.860
It's very good for bus efficiency
that you don't have to wait for one

00:17:00.860 --> 00:17:04.280
transaction to finish before another
one can start with split transactions.

00:17:04.280 --> 00:17:06.840
And Kernel supports that.

00:17:08.970 --> 00:17:12.870
Indication queues are essentially
the queues for the request

00:17:12.870 --> 00:17:17.600
transactions that are coming into
this device from across the bus.

00:17:17.600 --> 00:17:20.330
And of course,
if you get a request coming in,

00:17:20.330 --> 00:17:23.590
like a read request,
you need to generate a response.

00:17:23.620 --> 00:17:25.460
So there's the response generation.

00:17:25.460 --> 00:17:29.850
And you can also sign up for the handlers
so that you can see the requests and

00:17:29.850 --> 00:17:32.360
generate the appropriate responses.

00:17:34.410 --> 00:17:40.000
So essentially,
everything you need in order to

00:17:40.060 --> 00:17:46.200
be able to do normal 1394 bus
transactions is in TNF Kernel.

00:17:46.540 --> 00:17:49.340
And of course,
it does a whole lot of nice things to

00:17:49.340 --> 00:17:52.540
make sure that these transactions are
properly formatted and you get them right

00:17:52.640 --> 00:17:57.140
and they are dealt with correctly across
bus resets and a few things like that.

00:17:57.210 --> 00:17:59.790
It sort of deals with some
nitty-gritty issues of that sort.

00:18:01.340 --> 00:18:05.880
Second feature in TNF Kernel
is bus management functions.

00:18:05.880 --> 00:18:09.870
Main function of bus management
is to do things like optimize

00:18:09.870 --> 00:18:15.300
the bus by optimizing gap counts,
making sure that the most capable node

00:18:15.310 --> 00:18:18.600
on the bus is indeed the bus manager,
and so on.

00:18:19.900 --> 00:18:22.270
So we provide serial bus management.

00:18:22.270 --> 00:18:24.710
And by and large, that's autonomous.

00:18:24.790 --> 00:18:29.060
You just say to the kernel,
I want you to be bus manager capable.

00:18:29.060 --> 00:18:30.420
And it'll go and do it.

00:18:30.490 --> 00:18:33.090
And you don't have to
worry about it again.

00:18:37.250 --> 00:18:39.830
CSR services.

00:18:39.960 --> 00:18:44.300
There's this wonderful misnomer in
1394 which is called configuration ROM,

00:18:44.350 --> 00:18:45.080
which is always changing.

00:18:45.080 --> 00:18:49.220
Essentially,
the configuration ROM is an area

00:18:49.220 --> 00:18:54.640
in your address space where you
advertise to the outside world

00:18:54.640 --> 00:18:57.460
what you're capable of doing.

00:18:58.930 --> 00:19:05.240
This can be built up dynamically
using kernel services.

00:19:05.240 --> 00:19:08.240
You can say,
I want a configuration ROM that

00:19:08.380 --> 00:19:12.420
says I'm an SVP2 target,
and kernel will go away and build

00:19:12.420 --> 00:19:15.930
the right sort of configuration ROM,
taking into account the fact that

00:19:16.000 --> 00:19:19.520
some other client of kernel has
also asked for something else to

00:19:19.520 --> 00:19:21.830
be advertised in configuration ROM.

00:19:21.840 --> 00:19:25.200
The configuration ROM specification
has got a complicated structure

00:19:25.210 --> 00:19:28.580
of pointers and the like,
and the kernel will build the

00:19:28.580 --> 00:19:31.620
right structure given all the
requests that have been made of it.

00:19:31.720 --> 00:19:35.270
And you can go and add capabilities
dynamically if you wish to.

00:19:37.570 --> 00:19:42.400
Sort of complementary to
that are reset services.

00:19:42.410 --> 00:19:51.540
A bus reset on FireWire is essentially
the hint that something's changed.

00:19:51.810 --> 00:19:53.760
There's a new device on the bus.

00:19:53.760 --> 00:19:56.840
Perhaps the device has gone
away that used to be there.

00:19:56.900 --> 00:20:02.200
Or perhaps a device that's on the bus,
was there before, has actually changed

00:20:02.200 --> 00:20:04.030
what it can and can't do.

00:20:04.030 --> 00:20:07.950
It's got an extra capability or
maybe a capability that's gone away.

00:20:10.570 --> 00:20:13.470
So there's a bus reset on the bus,
and that's sort of a hint for

00:20:13.590 --> 00:20:16.390
everybody else to go out and
look at the configuration ROMs,

00:20:16.400 --> 00:20:18.620
see what's changed,
and then understand what

00:20:18.680 --> 00:20:20.190
the bus now looks like.

00:20:20.260 --> 00:20:24.870
And there's a whole pile of
reset services which deal with

00:20:24.870 --> 00:20:27.260
that for you in TNF Kernel.

00:20:28.780 --> 00:20:33.840
Now, one of the ways that Kernel
helps the application is that

00:20:33.840 --> 00:20:42.680
it provides a device reference,
which is not the PHYID.

00:20:42.680 --> 00:20:45.910
It's not the node number on the bus,
because actually the node

00:20:45.910 --> 00:20:47.890
number changes every time,
or can change every time

00:20:47.940 --> 00:20:48.840
you have a bus reset.

00:20:48.900 --> 00:20:53.660
What Kernel has is a device reference,
which it holds constant.

00:20:53.660 --> 00:20:55.990
So by and large,
when you want to go and talk

00:20:56.100 --> 00:20:58.140
to a device across the bus,
you don't say,

00:20:58.250 --> 00:20:59.950
I want to send it to node number five.

00:20:59.950 --> 00:21:03.340
You say, I want to send it to
this device reference.

00:21:03.390 --> 00:21:08.370
And Kernel maintains track of what
node number is the correct node

00:21:08.380 --> 00:21:11.430
number for this particular device
reference at this moment in time.

00:21:11.460 --> 00:21:13.810
So it looks after all of that
sort of stuff for you as well.

00:21:16.750 --> 00:21:22.710
What I've talked about
so far has basically been

00:21:23.650 --> 00:21:27.140
looking after the aspects of
asynchronous transactions,

00:21:27.180 --> 00:21:28.960
the ones that use the
memory address space.

00:21:28.960 --> 00:21:33.060
But there's a whole lot of isochronous
services as well provided by Kernel.

00:21:33.060 --> 00:21:36.800
Again, as part of serial bus management,
there's a thing called the

00:21:36.800 --> 00:21:39.530
isochronous resource manager,
which tracks what

00:21:39.530 --> 00:21:42.900
channels are being used,
what bandwidth has been used,

00:21:42.950 --> 00:21:45.220
what's available to be allocated.

00:21:45.350 --> 00:21:50.390
And TNF Kernel provides the
isochronous resource manager function.

00:21:52.060 --> 00:21:55.340
It provides support for something
called function control protocol.

00:21:55.340 --> 00:22:02.470
This is a protocol defined in IEC 61883,
which is the basis for all of the

00:22:02.470 --> 00:22:06.270
AVC protocols and some others as well.

00:22:07.710 --> 00:22:13.660
So the basic function control protocol
support is implemented in TNF Kernel.

00:22:13.660 --> 00:22:18.280
There are isochronous services for
doing isochronous transactions.

00:22:18.280 --> 00:22:21.300
So depending on the
nature of your link chip,

00:22:21.300 --> 00:22:24.630
you can send and receive
isochronous packets.

00:22:26.300 --> 00:22:28.710
Some link chips,
this may sort of go completely

00:22:28.710 --> 00:22:32.030
through hardware to a side port
and kernel needn't get in the way.

00:22:32.090 --> 00:22:34.590
For other link chips,
it may well be that software

00:22:34.590 --> 00:22:37.160
gets involved at a fairly
low level with sending and

00:22:37.170 --> 00:22:39.330
receiving of isochronous packets.

00:22:39.340 --> 00:22:42.280
And basically,
the isochronous services that you

00:22:42.360 --> 00:22:44.540
need are provided in TNF Kernel.

00:22:44.540 --> 00:22:48.450
Then there are wonderful
things called plugs,

00:22:48.450 --> 00:22:53.980
which is a way of managing the
isochronous channels on FireWire.

00:22:54.020 --> 00:22:56.020
And we provide input output.

00:22:56.350 --> 00:23:01.060
And output plug handlers and plug input
and output plug management for FireWire.

00:23:01.060 --> 00:23:03.740
That again is defined in IEC 61883.

00:23:08.080 --> 00:23:13.000
So, looking at how all this fits
in with the rest of the system,

00:23:13.000 --> 00:23:15.920
here's kernel.

00:23:15.920 --> 00:23:18.900
We basically have three main APIs.

00:23:18.900 --> 00:23:23.370
We have a protocol client API,
which goes to these clients,

00:23:23.370 --> 00:23:27.500
mainly the ones implementing
specific protocols.

00:23:27.500 --> 00:23:31.300
We have a system services API,
and we have a kernel

00:23:31.300 --> 00:23:35.000
services link driver API.

00:23:40.250 --> 00:23:41.850
Text to go with previous file.

00:23:41.900 --> 00:23:50.520
So just a moment or two
sort of on the marketing.

00:23:50.670 --> 00:23:52.220
When are you going to use TNF kernel?

00:23:52.220 --> 00:23:54.580
When is this sort of
thing going to be useful?

00:23:54.650 --> 00:23:58.630
Well, what does it do for you?

00:23:59.220 --> 00:24:03.900
The main thing it does for you is
indeed to abstract a whole lot of

00:24:03.900 --> 00:24:09.520
nitty-gritty details of what it
is to be a good citizen on 1394.

00:24:09.520 --> 00:24:12.120
And it abstracts that from the clients.

00:24:12.120 --> 00:24:15.090
In other words,
it looks after that for you.

00:24:15.360 --> 00:24:21.020
So there's actually quite a lot in
FireWire which you have to get right.

00:24:21.020 --> 00:24:24.200
And it's great just to go with
TNF kernel because then you know

00:24:24.200 --> 00:24:28.220
there's a pile of well-proven software
which is going to get it right for you.

00:24:28.220 --> 00:24:30.140
You don't have to worry too much.

00:24:30.490 --> 00:24:37.600
We isolate all the hardware-specific
code to the particular link driver.

00:24:37.600 --> 00:24:43.420
So all the APIs that are
at the top of TNF kernel,

00:24:43.420 --> 00:24:46.480
all the client APIs,
are essentially independent of

00:24:46.480 --> 00:24:48.100
whatever link chip might be underneath.

00:24:48.100 --> 00:24:52.440
So you may well be able to develop
some software which is generic

00:24:52.440 --> 00:24:56.880
across a range of products,
or across an evolving

00:24:56.880 --> 00:25:00.010
sequence of products,
which may well have new and

00:25:00.310 --> 00:25:02.060
different and improved link chips.

00:25:02.060 --> 00:25:07.880
And your application software is
protected against those changes.

00:25:07.920 --> 00:25:08.810
It'll stay the same.

00:25:10.580 --> 00:25:15.210
And of course,
the same thing goes for different

00:25:15.210 --> 00:25:16.280
RTOSes and different hardware.

00:25:16.280 --> 00:25:20.320
You can recompile and
go to a different CPU.

00:25:20.320 --> 00:25:23.260
You can move all your software
onto a different RTOS.

00:25:23.260 --> 00:25:27.320
So again, you may well have a family of
products of different complexities,

00:25:27.420 --> 00:25:30.010
which for good reasons
have different RTOSes.

00:25:30.010 --> 00:25:32.810
And still,
your application can look the same.

00:25:32.960 --> 00:25:34.600
It can look and feel the same.

00:25:34.600 --> 00:25:38.540
So there's both a support advantage
and a usability advantage.

00:25:45.070 --> 00:25:48.580
So going into the architecture
in a little bit more detail,

00:25:48.580 --> 00:25:51.000
we find ourselves with
initialization services,

00:25:51.000 --> 00:25:54.310
reset services, our Sokka services,
CSR services,

00:25:54.310 --> 00:26:00.730
and then various queues and clients,
which essentially take you directly from

00:26:00.730 --> 00:26:05.300
the client APIs down to the link driver,
or in the other direction,

00:26:05.300 --> 00:26:06.770
as the case may be.

00:26:11.090 --> 00:26:12.680
So first of all,
a word on the link driver.

00:26:12.680 --> 00:26:14.810
I've only got one slide on this.

00:26:15.870 --> 00:26:21.520
But as I said before, it does support a
variety of link devices.

00:26:21.520 --> 00:26:27.620
And one of the ways it does this
is that it has a capability call.

00:26:27.620 --> 00:26:32.390
And so a link driver essentially
reports what it's capable of doing.

00:26:32.420 --> 00:26:36.210
This link can transmit isochronous,
or perhaps this link can't

00:26:36.210 --> 00:26:37.770
transmit isochronous.

00:26:37.770 --> 00:26:41.230
This link does isochronous
completely independently.

00:26:41.230 --> 00:26:44.710
This link has various levels
of queuing or whatever.

00:26:46.660 --> 00:26:54.300
So the link capability is derived by the
link driver itself saying what it can do,

00:26:54.300 --> 00:26:57.500
and then there are various features
in kernel which essentially use

00:26:57.500 --> 00:27:01.200
that information to make sure
that a bus utilization is as

00:27:01.210 --> 00:27:03.600
optimal as the link chip allows.

00:27:04.160 --> 00:27:07.420
And it is very much the case that
some link chips allow much more

00:27:07.420 --> 00:27:09.530
efficient use of the bus than others.

00:27:09.620 --> 00:27:13.830
That may or may not be an issue,
but it's good to know that you actually

00:27:13.830 --> 00:27:18.210
are going to use the bus as well as
a particular link chip does allow.

00:27:19.640 --> 00:27:21.860
Then, in fact,
essentially it's got one API,

00:27:21.860 --> 00:27:25.360
one main API,
which is a single command for

00:27:25.360 --> 00:27:27.210
all of the bus sub-actions.

00:27:27.250 --> 00:27:29.510
By the time you get
down to the link driver,

00:27:29.550 --> 00:27:32.240
you're talking in terms of sub-actions,
not transactions.

00:27:32.280 --> 00:27:35.620
A transaction is something
like a read request and then

00:27:35.700 --> 00:27:37.450
the response coming back.

00:27:37.560 --> 00:27:41.780
At this level in the link driver,
you're talking about the read request

00:27:41.780 --> 00:27:43.980
going out or a response going out.

00:27:46.200 --> 00:27:51.660
And the link driver has some specific
plugins for specific hardware support,

00:27:51.660 --> 00:27:54.660
which you may well have.

00:28:02.140 --> 00:28:10.290
The system interface API is the place at
which we try to isolate everything which

00:28:10.420 --> 00:28:16.390
is going to be dependent on the system
and the real-time operating system.

00:28:17.130 --> 00:28:19.780
There is a module which
is called TNF Sys.

00:28:21.100 --> 00:28:25.440
And if you want to port to a
different operating system,

00:28:25.460 --> 00:28:30.660
basically you go and pull out TNF Sys
and you go through it API by API and

00:28:30.660 --> 00:28:34.250
work out exactly how the system works.

00:28:34.970 --> 00:28:39.280
The APIs are going to be implemented
for this particular RTOS.

00:28:40.300 --> 00:28:44.520
And Kernel is a real-time system.

00:28:44.530 --> 00:28:47.050
It's a concurrent system.

00:28:47.350 --> 00:28:52.200
So it does need support of concurrency,
but really there's not very much

00:28:52.200 --> 00:28:54.740
in the way of APIs that it needs,
and they're pretty conventional,

00:28:54.740 --> 00:28:56.320
pretty familiar.

00:28:56.320 --> 00:28:58.430
So we have...

00:29:04.500 --> 00:29:07.530
We have a system initialize, create task.

00:29:07.600 --> 00:29:09.430
We use semaphore.

00:29:09.430 --> 00:29:12.160
So you create a semaphore,
you post to a semaphore,

00:29:12.160 --> 00:29:13.300
you pend on a semaphore.

00:29:13.300 --> 00:29:18.460
You can create a queue, delete a queue,
you can send a message on a queue,

00:29:18.460 --> 00:29:21.860
you can receive a message from a queue,
pend on a queue for a message.

00:29:21.860 --> 00:29:26.560
And that essentially is the
main interface that we expect

00:29:26.630 --> 00:29:28.360
an RTOS to provide for us.

00:29:28.360 --> 00:29:32.400
There are memory allocation
operations as well.

00:29:32.560 --> 00:29:38.780
Basically, there's a TNF malloc,
which in many systems just gets

00:29:38.780 --> 00:29:40.720
implemented straightforward as malloc.

00:29:40.820 --> 00:29:46.060
There is a facility for doing
a DMA-safe memory allocation.

00:29:46.080 --> 00:29:49.320
In some cases,
you need to make sure that the

00:29:49.780 --> 00:29:54.380
memory is not going to be taken
away from you by some all-powerful

00:29:54.380 --> 00:29:57.790
memory management system,
which really has got no place

00:29:57.790 --> 00:29:59.360
in an embedded system anyway.

00:29:59.360 --> 00:30:01.870
And those sorts of things.

00:30:01.930 --> 00:30:06.510
there are some system calls
for atomic operations.

00:30:06.880 --> 00:30:14.540
But essentially, it's a pretty simple and
straightforward set of APIs,

00:30:14.580 --> 00:30:19.790
easily portable to a new RTOS.

00:30:23.930 --> 00:30:27.280
Moving on to the client services,
the client services support an

00:30:27.280 --> 00:30:29.370
arbitrary number of clients.

00:30:29.460 --> 00:30:32.970
There's no particular limit
built into the software.

00:30:33.000 --> 00:30:36.710
In fact,
this runs through a thread through much

00:30:36.780 --> 00:30:41.180
of TNF Kernel and the TNF software,
is that by and large,

00:30:41.310 --> 00:30:43.090
we haven't built in artificial limits.

00:30:43.100 --> 00:30:48.170
Instead, we've gone for things which
go and allow configuration.

00:30:48.960 --> 00:30:53.020
So you can set limits which are
relevant to your particular application

00:30:53.020 --> 00:30:55.160
in its particular circumstances.

00:30:55.260 --> 00:30:57.180
And by and large,
those limits are set dynamically

00:30:57.300 --> 00:30:58.400
rather than statically.

00:30:58.400 --> 00:31:02.320
They are set in initialization
calls rather than hash defines.

00:31:05.120 --> 00:31:11.480
So the typical clients are the
transport protocols for applications.

00:31:11.480 --> 00:31:12.750
They operate independently.

00:31:12.760 --> 00:31:14.910
They operate in parallel.

00:31:15.160 --> 00:31:20.110
And also some of the features
that Kernel itself provides you,

00:31:20.110 --> 00:31:27.620
such as the bus manager, the FCP,
function control protocol implementation.

00:31:27.620 --> 00:31:30.580
Those actually are implemented, again,
as clients,

00:31:30.590 --> 00:31:34.170
because what they want to do is
to do ordinary bus transactions.

00:31:34.180 --> 00:31:35.570
Thank you.

00:31:38.270 --> 00:31:43.960
So what happens is that a client,
which is one of these protocols maybe,

00:31:43.960 --> 00:31:50.040
or maybe your own application,
a task in your own application,

00:31:50.040 --> 00:31:54.880
will introduce itself to Kernel,
it'll log in, and it'll get a client ID.

00:31:54.880 --> 00:31:59.280
And then it'll use that in future calls,
so Kernel can keep track of which

00:31:59.280 --> 00:32:03.200
clients are asking for which
features and which capabilities,

00:32:03.200 --> 00:32:05.970
which callbacks, and so on and so forth.

00:32:10.290 --> 00:32:12.160
So the sorts of things
that a client can do,

00:32:12.160 --> 00:32:17.270
having got its ID, is that it can sign up
for unit notification.

00:32:17.300 --> 00:32:22.540
A unit is a capability in a
device somewhere on the bus.

00:32:22.540 --> 00:32:27.010
And when there's a bus reset and
some new device joins the bus,

00:32:27.010 --> 00:32:32.110
a client of TNF kernel can say,
I want to be told when an SPP2

00:32:32.160 --> 00:32:34.260
target turns up on the bus.

00:32:34.440 --> 00:32:38.480
I want to be told when an AVC tape
recorder turns up on the bus.

00:32:39.600 --> 00:32:43.990
So you can sign up for unit notification.

00:32:45.030 --> 00:32:48.100
It can sign up for cable
event notification.

00:32:48.250 --> 00:32:53.410
For some purposes,
things like bus reset are important.

00:32:53.420 --> 00:32:56.420
Many applications,
it's the case it doesn't matter.

00:32:56.420 --> 00:33:02.160
And you can often get away with
your application not even knowing

00:33:02.160 --> 00:33:04.550
about bus resets on FireWire.

00:33:04.560 --> 00:33:06.810
But for some applications,
it is important.

00:33:06.810 --> 00:33:10.180
And so you can sign up for that.

00:33:12.170 --> 00:33:16.810
You can read CSR locations on 1394 nodes.

00:33:16.880 --> 00:33:21.270
You can actually go and read the
configuration ROM on some other node.

00:33:21.300 --> 00:33:27.300
You can go and search the
ROMs for specific entries.

00:33:27.300 --> 00:33:29.410
Essentially, it's the same sort of thing
as client notification.

00:33:29.420 --> 00:33:35.720
You can say,
find me a tape recorder if there is one.

00:33:35.840 --> 00:33:39.350
And there's a whole pile of
other functions similarly.

00:33:42.000 --> 00:33:47.820
Now, if a client wants to access a
particular device that's on the bus,

00:33:47.820 --> 00:33:52.130
what it does is to say to the kernel,
I want to be able to do this.

00:33:52.740 --> 00:33:56.360
Give me a device reference.

00:33:56.900 --> 00:33:59.220
So it gets a device
reference ID from kernel.

00:33:59.360 --> 00:34:01.800
I mean,
essentially that's a pointer to an

00:34:01.800 --> 00:34:03.480
internal data structure of kernel.

00:34:04.510 --> 00:34:07.030
And...

00:34:07.210 --> 00:34:10.870
Normally it does this by, sorry,
within kernel,

00:34:11.270 --> 00:34:15.990
kernel tracks particular devices
by global unique identifier.

00:34:17.640 --> 00:34:20.070
The device reference remains
the same for all time.

00:34:20.260 --> 00:34:26.530
And then the sorts of services
that Kernel provides to a device

00:34:26.940 --> 00:34:32.100
with such a device reference is
all the asynchronous request types,

00:34:32.270 --> 00:34:34.180
create isoquinous stream descriptors.

00:34:34.550 --> 00:34:40.500
It can also do things like allocate
isoquinous channels and bandwidth,

00:34:40.500 --> 00:34:45.970
sign up to receive isoquinous events,
and bus reset notifications and the like.

00:34:47.480 --> 00:34:53.030
There are, in fact,
two sorts of device references.

00:34:53.330 --> 00:34:55.740
One is the standard way,
the way I've been talking about so far,

00:34:56.740 --> 00:35:01.910
where kernel tracks it all
for you and you just use an

00:35:01.910 --> 00:35:03.720
abstract device reference.

00:35:03.720 --> 00:35:07.210
Alternatively,
there's a type called unspecified,

00:35:07.210 --> 00:35:09.820
which provides you maximum control.

00:35:09.820 --> 00:35:13.280
In other words,
you can actually then go and

00:35:13.320 --> 00:35:18.110
access a device by its specific
device address on the bus.

00:35:19.380 --> 00:35:21.540
But that, of course,
requires you to go and

00:35:21.900 --> 00:35:23.260
track the changes to that.

00:35:23.260 --> 00:35:26.840
So if for some reason you don't want to
use the kernel services for doing this,

00:35:26.840 --> 00:35:31.800
we're not sort of blocking you off
from a lower level access to the bus.

00:35:31.800 --> 00:35:33.430
You can do that if you really wish to.

00:35:33.440 --> 00:35:36.120
In general, you won't need to.

00:35:39.860 --> 00:35:42.910
The reset services,
I said you can sign up for bus reset.

00:35:43.040 --> 00:35:44.610
Well, you can sign up for all bus resets.

00:35:44.610 --> 00:35:48.510
You can sign up for a bus reset
notification when a particular

00:35:48.520 --> 00:35:52.170
device or unit joins the bus,
or if it leaves the bus.

00:35:55.570 --> 00:35:59.160
There's some initialization you do.

00:35:59.180 --> 00:36:05.500
You can set the number of outstanding
requests in the outbound request queue.

00:36:05.500 --> 00:36:08.870
You can set the number of incoming
requests that can be queued.

00:36:08.900 --> 00:36:12.980
You can set the number
of client procedures.

00:36:12.980 --> 00:36:17.250
And these basically just limit
the internal data structures that

00:36:17.250 --> 00:36:19.540
the kernel will build for itself.

00:36:21.920 --> 00:36:27.500
One minor point I should make when
we're talking about request queues.

00:36:27.500 --> 00:36:34.130
The kernel model to its clients is
that outbound requests are queued.

00:36:34.200 --> 00:36:36.200
And yes, they are queued.

00:36:36.200 --> 00:36:39.570
But in fact,
it turns out that they're not

00:36:39.590 --> 00:36:42.390
queued actually in the kernel.

00:36:42.400 --> 00:36:46.310
The kernel goes and passes on the queuing
responsibilities to the link driver.

00:36:46.320 --> 00:36:48.960
And that might seem a
rather odd thing to do,

00:36:48.960 --> 00:36:51.650
because it makes link drivers
more difficult to write.

00:36:51.900 --> 00:36:54.720
But it turns out that
there are some link chips,

00:36:54.720 --> 00:36:57.440
and more and more link chips,
which basically support

00:36:57.630 --> 00:36:59.330
queuing in hardware.

00:36:59.460 --> 00:37:02.330
OHCI is a very good example,
but there are others as well.

00:37:02.340 --> 00:37:06.740
So by passing on the queuing
responsibilities down to the link driver,

00:37:06.740 --> 00:37:10.590
this allows the link driver in
turn to take advantage of any

00:37:10.730 --> 00:37:14.570
queuing capabilities that might be
in the hardware of the particular

00:37:14.660 --> 00:37:16.060
chip that it's a driver for.

00:37:21.700 --> 00:37:24.600
You want to be able to
configure the node as well.

00:37:24.730 --> 00:37:25.860
What's this node doing?

00:37:25.910 --> 00:37:27.090
You can set its OUI.

00:37:27.300 --> 00:37:33.750
You can set busy retry codes,
appending controls and things,

00:37:33.980 --> 00:37:38.740
say whether you want to do appendings,
app busies or whatever.

00:37:38.770 --> 00:37:41.360
And then there's a whole
pile of optional features,

00:37:41.400 --> 00:37:45.580
which you can decide whether they're
going to go into your device or not.

00:37:45.580 --> 00:37:51.100
And of course, these are optional
features which are dynamic.

00:37:51.490 --> 00:37:56.140
So you can build bus registries,
you can contend for being bus manager,

00:37:56.140 --> 00:37:58.680
you can decide that this device
is going to be a bus manager,

00:37:58.680 --> 00:38:01.380
or potentially,
you can optimize gap count,

00:38:01.380 --> 00:38:03.560
decide that it's going to
be isochronous capable,

00:38:03.560 --> 00:38:05.900
power manager capable,
and so on and so forth.

00:38:05.900 --> 00:38:08.280
You can decide it's
going to be cycle master.

00:38:11.600 --> 00:38:15.890
As I said, these are dynamic,
which means that you can build

00:38:15.890 --> 00:38:22.680
software which maybe itself goes
and loads capabilities dynamically.

00:38:22.780 --> 00:38:26.770
And so, you know,
for some time you may decide that you

00:38:26.790 --> 00:38:31.600
don't want to be ISOP and resource
manager capable or something until some

00:38:31.650 --> 00:38:37.670
other software has actually managed to
get loaded or something of that sort.

00:38:37.700 --> 00:38:41.530
So you can decide as the capabilities
come and go whether you wish to

00:38:41.530 --> 00:38:45.680
have these features advertised
and these capabilities supported.

00:38:50.880 --> 00:38:57.280
Another class of services that are
provided are to be able to access the

00:38:57.430 --> 00:39:00.200
fire chips that are across the bus.

00:39:00.500 --> 00:39:02.720
Your local chip or a remote chip.

00:39:02.730 --> 00:39:08.330
So you can do things like set the
force root bit to persuade a particular

00:39:08.430 --> 00:39:09.900
device that it wants to be root.

00:39:09.950 --> 00:39:14.800
You can send a link on which goes
and turns on the link layer device,

00:39:14.800 --> 00:39:17.930
link layer hardware in a remote device.

00:39:17.930 --> 00:39:19.490
You can set gap counts.

00:39:19.490 --> 00:39:20.790
You can ping nodes.

00:39:20.790 --> 00:39:26.150
You can engage and suspend,
resume power management stuff,

00:39:26.150 --> 00:39:27.960
enable fire ports.

00:39:28.940 --> 00:39:31.140
And you can read and write
remote fire registers.

00:39:31.140 --> 00:39:39.710
So if you have a need for being able
to access fire chips across the bus,

00:39:39.710 --> 00:39:41.170
you can do that.

00:39:41.180 --> 00:39:44.010
Now, I have to admit,
the main user of this is

00:39:44.010 --> 00:39:47.600
going to be a bus manager,
which is in kernel anyway.

00:39:47.600 --> 00:39:49.820
So it's unlikely that you will
actually need these services,

00:39:49.820 --> 00:39:50.970
but they're there if you do.

00:39:50.980 --> 00:39:54.230
And they're the ones that are going
to be used by some of the other

00:39:54.230 --> 00:39:56.480
features that kernel provides anyway.

00:40:01.500 --> 00:40:03.020
Looking at this sort of
from the other way around,

00:40:03.020 --> 00:40:07.300
you can be a target device
advertising a CSR ROM,

00:40:07.300 --> 00:40:14.090
and so we provide the capabilities
to build the CSR ROM and to modify or

00:40:14.090 --> 00:40:16.370
add units to the CSR ROM dynamically.

00:40:16.420 --> 00:40:21.080
So essentially,
if a read to CSR ROM comes into the node,

00:40:21.330 --> 00:40:26.990
then Kernel will actually provide
the response based on what you've

00:40:26.990 --> 00:40:30.060
asked Kernel to set up in CSR ROM.

00:40:30.610 --> 00:40:35.380
And your application doesn't actually
directly get involved in servicing

00:40:35.380 --> 00:40:39.840
those CSR read and write commands,
unless for some reason it wants to.

00:40:39.840 --> 00:40:42.450
It can choose to,
but in general it won't want to.

00:40:44.970 --> 00:40:48.040
There's a direct memory client.

00:40:48.040 --> 00:40:57.720
This allows you to designate an area of
your memory and hand it over to kernel.

00:40:58.050 --> 00:41:03.840
and say, well,
what I want you to do is to allow

00:41:03.840 --> 00:41:11.430
access to this area of memory from
remote devices across the bus.

00:41:11.570 --> 00:41:13.610
So reason writes to this area of memory.

00:41:13.940 --> 00:41:15.340
We'll go straight to that memory.

00:41:15.400 --> 00:41:19.180
And by and large,
your application needn't get involved.

00:41:19.420 --> 00:41:22.700
Now, sometimes this can be directly
supported by hardware.

00:41:22.720 --> 00:41:25.640
OHDI has a facility for supporting this.

00:41:25.640 --> 00:41:27.860
Some other link chips can support
this sort of thing as well.

00:41:28.020 --> 00:41:31.650
Otherwise, it's supported by software.

00:41:32.280 --> 00:41:35.560
But then the question is, okay,
so there are other devices reading

00:41:35.560 --> 00:41:37.480
and writing from this lump of memory.

00:41:37.480 --> 00:41:40.240
There are going to be times
when I do actually want to be

00:41:40.240 --> 00:41:44.190
able to know what's going on,
put things in that memory,

00:41:44.190 --> 00:41:45.980
get things out of that memory.

00:41:45.980 --> 00:41:49.320
So what I'd like is,
I'd like to be told when other

00:41:49.760 --> 00:41:51.760
devices do access that memory.

00:41:51.760 --> 00:41:57.250
I can be told, I can say,
I want to be told every time.

00:41:57.260 --> 00:42:00.920
I want to be told never.

00:42:01.580 --> 00:42:04.180
Or perhaps I want to be
told every N packets.

00:42:04.260 --> 00:42:08.160
So if there are N packets
that are read from memory,

00:42:08.160 --> 00:42:10.350
then I'm going to go back
and I'm going to go and fill

00:42:10.350 --> 00:42:11.830
it up with some more stuff.

00:42:11.940 --> 00:42:16.100
Or perhaps every N bytes that
are read from that memory,

00:42:16.100 --> 00:42:18.190
or written to that memory,
I want to be told.

00:42:19.650 --> 00:42:22.250
And there's optional
support for posted writes.

00:42:22.360 --> 00:42:27.140
In other words,
a posted write is one where

00:42:27.140 --> 00:42:30.790
the transaction comes in...

00:42:31.300 --> 00:42:36.350
and it's acknowledged
with an at-complete.

00:42:36.630 --> 00:42:39.840
Even before the data
that's in that transaction,

00:42:39.920 --> 00:42:43.370
that write transaction,
has been physically pasted in the memory,

00:42:43.370 --> 00:42:46.910
the device at the far end
thinks it's got there.

00:42:48.370 --> 00:42:52.870
And that's a good optimization which
is used quite a lot in FireWire.

00:42:52.880 --> 00:42:59.130
So the kernel sends the right complete
whatever may be needed to finish that.

00:43:03.340 --> 00:43:07.220
For isoquinous services,
you can allocate and deallocate

00:43:07.260 --> 00:43:08.260
channels and bandwidth.

00:43:08.260 --> 00:43:14.130
You can initialize an isoquinous stream,
you can start an isoquinous stream,

00:43:14.190 --> 00:43:15.770
you can stop one.

00:43:16.520 --> 00:43:21.320
and then you can sign up for
isochronous event notification.

00:43:21.320 --> 00:43:24.220
And the sorts of events are
start of isochronous data,

00:43:24.220 --> 00:43:27.970
end of isochronous data,
and then some odd things to

00:43:28.050 --> 00:43:31.820
do with channels and managing
what happens with cycle starts.

00:43:37.730 --> 00:43:40.900
The FCP services,
those are the underpinning

00:43:40.900 --> 00:43:45.580
services for AVC,
and the functions that are

00:43:45.680 --> 00:43:49.730
provided there are to send an
FCP command or an FCP response.

00:43:49.760 --> 00:43:51.160
You have to be careful.

00:43:51.240 --> 00:43:53.860
An FCP response is not
a serial bus response.

00:43:54.560 --> 00:44:04.520
FCP uses directed writes in its protocol,
and one FCP initiator will send an

00:44:04.520 --> 00:44:10.870
FCP directed write to the target,
and then the target will

00:44:10.870 --> 00:44:14.800
send an FCP response,
which is an FCP directed write,

00:44:14.800 --> 00:44:16.690
back to the initiator.

00:44:16.700 --> 00:44:19.440
So you can send
FCP commands or responses.

00:44:19.480 --> 00:44:24.540
You can add an FCP command
handler for incoming commands.

00:44:24.560 --> 00:44:28.320
You can add a response handler.

00:44:28.970 --> 00:44:34.120
And then there are plugs which
you can deal with as well.

00:44:36.680 --> 00:44:39.480
Odd little features of the way
that kernel's been put together.

00:44:39.480 --> 00:44:43.930
Little Endian, big Endian support,
whatever processor you

00:44:43.930 --> 00:44:44.740
happen to be using.

00:44:44.740 --> 00:44:48.240
Sort of whatever reasonable size
processor you happen to be using.

00:44:48.240 --> 00:44:51.990
There are some compile
time optimizations.

00:44:52.000 --> 00:44:56.300
So, for example,
if you decide that you're never, never,

00:44:56.300 --> 00:44:59.950
ever going to be bus manager,
you needn't compile it in.

00:45:00.000 --> 00:45:03.690
And a few things of that sort in
order to get the footprint down.

00:45:05.480 --> 00:45:09.490
And there is this multi-threaded,
multi-tasking support.

00:45:12.670 --> 00:45:14.320
So, how do you use Kernel?

00:45:14.320 --> 00:45:17.220
Well, the steps are...

00:45:18.920 --> 00:45:21.760
that first of all, you configure it.

00:45:21.760 --> 00:45:24.220
You configure kernel,
your application sort of at the

00:45:24.220 --> 00:45:29.550
master application level goes and

00:45:30.010 --> 00:45:36.910
sets the various queue sizes,
the various parameters that are needed.

00:45:38.750 --> 00:45:41.880
- You then complete
the node configuration.

00:45:42.090 --> 00:45:46.080
You say whether you want the
node to be bus manager capable,

00:45:46.360 --> 00:45:48.570
IRM, whatever.

00:45:49.460 --> 00:45:53.570
Then you create CSR ROM,

00:45:55.120 --> 00:46:00.140
ready for the various clients that
are going to want to advertise

00:46:00.140 --> 00:46:01.660
their capabilities in CSI ROM.

00:46:02.720 --> 00:46:06.580
Around about that time,
TNF goes and gets capabilities

00:46:06.620 --> 00:46:10.550
of the link driver and does
a link driver configuration.

00:46:10.680 --> 00:46:15.000
And then your various clients,
protocol clients,

00:46:15.000 --> 00:46:19.090
will individually register
for required services.

00:46:19.100 --> 00:46:22.560
So basically you go and set the
clients going as independent

00:46:22.670 --> 00:46:25.660
tasks in your application,
and they'll go and register

00:46:25.660 --> 00:46:26.840
for their services.

00:46:26.840 --> 00:46:30.170
And then you just sit back and enjoy it,
watch it all work.

00:46:35.090 --> 00:46:35.690
So that's Kernel.

00:46:37.410 --> 00:46:47.410
Second module that I'd like to
introduce you to is TNF AVC.

00:46:50.710 --> 00:46:55.750
And this provides an API for
AVC controllers and AVC targets.

00:46:56.240 --> 00:46:59.790
And actually, this presentation,
this part of the presentation

00:46:59.880 --> 00:47:01.800
feels just like the previous
part of the presentation.

00:47:01.800 --> 00:47:03.990
It's the same model all over again.

00:47:03.990 --> 00:47:07.590
Same sorts of things,
same feel all over again.

00:47:07.660 --> 00:47:10.500
First of all,
we're supporting multiple sub-units,

00:47:10.500 --> 00:47:14.850
so your AVC device can have several
personalities simultaneously.

00:47:14.900 --> 00:47:22.750
There are notification mechanisms for
AVC-related bus and remote unit events.

00:47:23.160 --> 00:47:27.720
You can construct appropriate
unit and sub-unit descriptors

00:47:27.720 --> 00:47:30.350
if you're an AVC target to go
into your configuration ROM.

00:47:30.360 --> 00:47:34.080
You publicize your AVC unit directory.

00:47:34.080 --> 00:47:40.760
You can be a controller,
and AVC provides support for

00:47:40.840 --> 00:47:45.540
parsing the descriptors that
you'll find in some other target

00:47:45.540 --> 00:47:46.960
somewhere else on the device.

00:47:47.800 --> 00:47:50.820
And again,
the API provides references to units

00:47:50.820 --> 00:47:57.860
and sub-units and plugs and so on and
so forth by logical references which

00:47:57.920 --> 00:48:05.100
will remain unchanged through bus resets
and through things which might actually

00:48:05.100 --> 00:48:10.940
change the physical representation
of these as known on FireWire.

00:48:10.980 --> 00:48:14.340
So again,
it insulates the application or the

00:48:14.340 --> 00:48:17.780
higher-level protocol from those changes.

00:48:17.800 --> 00:48:18.800
Thank you.

00:48:20.890 --> 00:48:28.970
AVC supports AVC 3.0,
the 1394 Trade Association specification.

00:48:29.030 --> 00:48:32.870
It provides a complete set of
APIs for both controllers and targets,

00:48:32.870 --> 00:48:34.990
multiple sub-units.

00:48:34.990 --> 00:48:39.120
It does automatic mapping of
addresses and plugs and so on

00:48:39.120 --> 00:48:41.400
and so forth after bus reset.

00:48:41.620 --> 00:48:46.860
provides dynamic
construction of descriptors.

00:48:46.960 --> 00:48:51.010
And there are also some interesting
rules for open and closed descriptors.

00:48:51.090 --> 00:48:54.840
And again, it ensures that those
rules are complied with.

00:48:58.470 --> 00:49:03.300
It provides IEC 61883
connection management.

00:49:03.300 --> 00:49:07.360
It provides support for FCP or
asynchronous connections

00:49:07.360 --> 00:49:08.340
for command transport.

00:49:08.340 --> 00:49:11.040
Both of those are used in
different circumstances.

00:49:11.040 --> 00:49:15.400
You can have multiples of
those command transports,

00:49:16.060 --> 00:49:20.410
multiple outstanding transactions,
and a target can service

00:49:20.410 --> 00:49:22.490
multiple controllers.

00:49:22.490 --> 00:49:25.400
It's quite an important feature.

00:49:26.790 --> 00:49:30.770
and multiple devices outside on the
bus can find that this is a target.

00:49:30.770 --> 00:49:35.330
And it won't fall over if two or three
of them start trying to poke at it.

00:49:36.810 --> 00:49:40.580
So the block diagram amazingly looks
just like the previous block diagram.

00:49:40.700 --> 00:49:45.510
AVC sitting down here,
it's got its interface to kernel

00:49:45.900 --> 00:49:49.460
using those kernel APIs that
I was talking about a moment ago.

00:49:49.490 --> 00:49:56.410
It's got its interface to TNF Sys,
and its interface then provides the

00:49:56.410 --> 00:50:02.900
APIs to the particular protocols,
particular AVC protocols

00:50:02.900 --> 00:50:04.790
that you want to support.

00:50:07.500 --> 00:50:10.620
And again, the sort of the block
diagram looks similar.

00:50:10.620 --> 00:50:18.620
We have our various services
essentially going between the AVC device

00:50:19.060 --> 00:50:23.560
API and the transport controller,
which goes down to kernel.

00:50:26.510 --> 00:50:31.160
System API, actually hardly used at all.

00:50:31.160 --> 00:50:34.780
The only thing that it does is
to provide memory allocation.

00:50:34.780 --> 00:50:39.320
It goes TNF malloc for memory allocation.

00:50:39.600 --> 00:50:43.540
Incidentally,
I should have mentioned that the fact

00:50:43.670 --> 00:50:48.600
that TNF Malak is provided and that
everything that we provide in FireWire

00:50:48.690 --> 00:50:52.300
Reference Platform goes through TNF Malak
means that you can choose just to

00:50:52.370 --> 00:50:54.280
go and call Malak if you want to.

00:50:54.300 --> 00:50:57.840
But if there's some good reason why
you want to control the memory areas

00:50:57.840 --> 00:51:01.440
that are used for all of the FireWire
Reference Platform data structures

00:51:01.530 --> 00:51:06.400
and buffers and so on and so forth,
you can go and implement your own special

00:51:06.400 --> 00:51:12.450
version of TNF Malak with your own
specific system-dependent capabilities.

00:51:12.460 --> 00:51:15.600
And the rest of the FireWire
Reference Platform will just go

00:51:15.600 --> 00:51:17.550
and use that all automatically.

00:51:17.560 --> 00:51:18.850
Thank you.

00:51:21.160 --> 00:51:26.100
Support multiple transports and
we support them simultaneously.

00:51:26.100 --> 00:51:28.260
You don't get any deadlocks
or anything horrible like that

00:51:28.260 --> 00:51:30.500
as a result of doing this.

00:51:36.380 --> 00:51:40.960
You want to access a
particular target device,

00:51:40.960 --> 00:51:46.790
a particular target unit that's
somewhere else on the bus,

00:51:46.790 --> 00:51:50.400
you go and get an AVC reference ID.

00:51:50.400 --> 00:51:56.500
And then you'll use that in
all future calls to go and make

00:51:56.500 --> 00:52:01.390
accesses to that target device,
getting its unit information,

00:52:01.450 --> 00:52:04.810
sub-unit information, plug information,
and so on and so forth.

00:52:09.860 --> 00:52:14.800
Now, if you look at the layers of
connection management protocols

00:52:14.800 --> 00:52:21.360
that are defined for FireWire,
there's a set of protocols called

00:52:22.030 --> 00:52:27.200
connection management protocols,
which uses this model of a plug.

00:52:27.220 --> 00:52:30.730
So two devices sort of share a
plug if they're going to send

00:52:30.740 --> 00:52:33.050
asynchronous data to each other.

00:52:36.480 --> 00:52:40.100
And that's supported in kernel.

00:52:40.100 --> 00:52:47.360
Then what AVC does is that it extends
that model so that if you push into a

00:52:47.360 --> 00:52:51.100
device and you get to some sub-units,
essentially you put a plug on a

00:52:51.190 --> 00:52:55.620
sub-unit and you plug that to some
other sub-unit in some other device.

00:52:55.800 --> 00:53:00.970
And in fact, you can even go and plug one
sub-unit to another sub-unit on the

00:53:00.970 --> 00:53:03.560
same device if you really want to.

00:53:04.480 --> 00:53:07.590
So AVC, in general,
goes and extends this model

00:53:07.700 --> 00:53:09.920
to sub-units from just units.

00:53:09.920 --> 00:53:15.300
And so our AVC supports all of that.

00:53:18.680 --> 00:53:22.000
So we find ourselves being able to do
things like configure the output plugs,

00:53:22.000 --> 00:53:26.660
master plugs, configure the input plugs,
connect and disconnect plugs,

00:53:26.660 --> 00:53:29.820
the serial blast plugs, if you like,
at the device level.

00:53:29.820 --> 00:53:35.870
And most important of all, perhaps,
is that we can connect and disconnect

00:53:36.000 --> 00:53:41.660
between sub-unit plugs and other
sub-unit plugs and or unit plugs.

00:53:41.660 --> 00:53:44.740
So you can sort of plug your
system together whatever

00:53:44.740 --> 00:53:46.580
way around is appropriate.

00:53:51.410 --> 00:53:56.540
All references to a device are
made by a device reference ID.

00:53:57.350 --> 00:54:02.100
and you can then go and get the
various units and information

00:54:02.100 --> 00:54:05.490
from an ABC reference.

00:54:05.500 --> 00:54:10.910
We have basically, again,
references for units and

00:54:10.910 --> 00:54:12.600
for sub-units and for plugs.

00:54:12.600 --> 00:54:18.290
So all of that, again,
is handled in a way which

00:54:18.420 --> 00:54:23.630
won't change over bus resets,
won't change over 1394 topology

00:54:23.640 --> 00:54:26.540
changes or reconfigurations.

00:54:31.260 --> 00:54:35.600
So essentially, what you do is to
initialize an AVC device.

00:54:35.670 --> 00:54:37.640
You say it's going to be a controller,
it's going to be a target,

00:54:37.640 --> 00:54:38.440
or perhaps it's going to be both.

00:54:38.540 --> 00:54:43.570
You register for the unit event
notifications that you're interested in.

00:54:43.580 --> 00:54:46.740
You deal with sub-units.

00:54:46.960 --> 00:54:52.660
You can construct AVC command headers
for sending commands to other devices.

00:54:52.660 --> 00:54:54.350
And you can get plug references.

00:54:54.360 --> 00:54:57.700
If you're a target...

00:54:58.660 --> 00:55:04.110
Then you can create a target unit
with a reference ID for yourself.

00:55:04.110 --> 00:55:07.540
You can create sub-units
within your target.

00:55:07.540 --> 00:55:10.940
You can create AVC plugs,
and you can register to

00:55:11.060 --> 00:55:12.840
be a command handler.

00:55:12.840 --> 00:55:17.350
And you'd want to do this because
somebody else on the bus is going to

00:55:17.350 --> 00:55:19.940
send you as a target an AVC command.

00:55:19.980 --> 00:55:22.730
So you can have a command handler
which goes and deals with that

00:55:22.730 --> 00:55:24.420
AVC command when it comes across.

00:55:28.260 --> 00:55:30.420
So that's a look at AVC.

00:55:30.440 --> 00:55:37.280
And finally, another protocol is SPP2.

00:55:37.480 --> 00:55:40.040
This is just slightly
different from the other two,

00:55:40.040 --> 00:55:42.850
but it gives you, again,
to give you a feel for the sorts

00:55:42.910 --> 00:55:46.160
of software and the sorts of ways
we've gone about constructing the

00:55:46.750 --> 00:55:51.630
support for various protocols in
the FireWire Reference Platform.

00:55:51.640 --> 00:55:54.650
I do want to emphasize,
in this presentation,

00:55:54.650 --> 00:55:56.960
I'm talking about SPP2 Target.

00:55:56.960 --> 00:56:05.160
We provide excellent support for both
SPP2 Initiators and for SPP2 Targets.

00:56:05.960 --> 00:56:11.590
And the fact that I'm picking out on
Target for this presentation is simply

00:56:11.590 --> 00:56:14.710
a matter of my time and your patience.

00:56:17.890 --> 00:56:22.750
So, SPP2 target, well,
we provide full target support.

00:56:22.810 --> 00:56:27.760
It's a generic API for
all types of SPP2 targets,

00:56:27.810 --> 00:56:30.070
disks, printers, whatever you like,
plotters.

00:56:30.080 --> 00:56:40.480
SPP2 is defined in end sites 325,
and it's fully compliant with that.

00:56:40.480 --> 00:56:43.970
And of course,
it operates as a client of TNF kernel.

00:56:44.970 --> 00:56:49.230
So in this particular case,
it only uses the TNF kernel APIs.

00:56:49.580 --> 00:56:52.110
It's operating system independent.

00:56:52.260 --> 00:56:58.540
It uses the TNF malloc,
and I think it uses TNF DMA safe.

00:56:58.640 --> 00:57:02.630
So it's using the main
APIs that we provide,

00:57:02.630 --> 00:57:04.080
no others.

00:57:04.080 --> 00:57:08.350
It'll run in any environment
in which TNF kernel runs then.

00:57:09.750 --> 00:57:13.290
It provides callback functions
for CSR event handling.

00:57:13.410 --> 00:57:18.020
So in fact, the application does,
in this case, have to get involved.

00:57:18.070 --> 00:57:20.110
And this is one of those
cases where actually a bus

00:57:20.210 --> 00:57:24.040
reset has to be significant.

00:57:24.080 --> 00:57:28.180
Unfortunately,
a bus reset is a significant event as

00:57:28.290 --> 00:57:31.840
far as a client of SPP2 is concerned.

00:57:31.980 --> 00:57:35.490
We can't hide the bus resets.

00:57:38.520 --> 00:57:42.670
Full range of configuration
functions and buffers as needed

00:57:42.670 --> 00:57:44.640
are allocated dynamically.

00:57:44.640 --> 00:57:51.270
And that's whenever some initiator
across the bus goes and initiates

00:57:51.270 --> 00:57:52.330
a session with this target.

00:57:52.340 --> 00:57:55.150
At that point,
we then go and allocate all the

00:57:55.220 --> 00:57:59.990
necessary buffers for that particular
login that the initiator has made.

00:58:05.490 --> 00:58:09.680
So the architecture for this is, well,
here's kernel.

00:58:09.720 --> 00:58:14.160
Here's SPP2 API.

00:58:14.500 --> 00:58:20.500
[Transcript missing]

00:58:20.700 --> 00:58:32.800
[Transcript missing]

00:58:34.200 --> 00:58:39.960
The system task deals with CSR accesses,
control and status ROM accesses.

00:58:39.960 --> 00:58:45.700
So this is where an initiator is
finding out about this SPP2 target,

00:58:45.740 --> 00:58:48.090
what it's capable of and what
it can do and what it can't do.

00:58:49.560 --> 00:58:53.580
There's a management agent,
and that deals with initiator login.

00:58:53.660 --> 00:58:59.340
A device across the bus
logs into an SPP2 target,

00:58:59.380 --> 00:59:02.220
logs into the disk or whatever,
before it starts to do reads

00:59:02.220 --> 00:59:03.500
and writes to that disk.

00:59:05.240 --> 00:59:08.750
So this management agent
task deals with those logins.

00:59:08.760 --> 00:59:13.680
Then the application
tasks deal with ORBS,

00:59:13.800 --> 00:59:16.340
Operation Request Block Processing.

00:59:16.340 --> 00:59:22.320
So the actual requests to go and
read blocks from disk or whatever,

00:59:22.320 --> 00:59:27.940
for disks it would tend to
be a command protocol such as

00:59:27.940 --> 00:59:31.270
the... I've forgotten its name.

00:59:31.280 --> 00:59:33.820
There's a specific command
protocol for disks.

00:59:34.460 --> 00:59:37.240
That interpretation would have to
be done by the application task,

00:59:37.240 --> 00:59:39.650
which you, the application writer,
would write.

00:59:44.000 --> 00:59:46.320
And we have to issue a sort of
little health warning here as well.

00:59:46.340 --> 00:59:53.110
There are some aspects of SPP2
compliance which actually depend on

00:59:53.110 --> 00:59:54.760
appropriate application behavior.

00:59:54.760 --> 00:59:57.540
We're not able to shield
you entirely from these.

00:59:57.540 --> 01:00:01.150
And so, for example,
every time the initiator sends

01:00:01.150 --> 01:00:05.330
you an operation request block,
you are required to return

01:00:05.540 --> 01:00:06.890
status for that block.

01:00:06.900 --> 01:00:11.140
And we rely on the application
doing that correctly.

01:00:13.540 --> 01:00:16.950
But the reason why we've done this
is to allow application flexibility.

01:00:17.020 --> 01:00:22.840
But we do have a sample
target application.

01:00:22.840 --> 01:00:29.880
You can actually go and run the
application code and do accesses

01:00:29.880 --> 01:00:35.530
to a real disk if you wish to,
so that you can see how to

01:00:35.550 --> 01:00:38.260
implement a compliant application.

01:00:41.400 --> 01:01:01.800
[Transcript missing]

01:01:04.910 --> 01:01:06.400
Although this is sitting
on top of kernel,

01:01:06.400 --> 01:01:10.480
there's nothing in this which prevents
the application from getting directly

01:01:10.480 --> 01:01:13.690
to the kernel APIs if it wishes to.

01:01:18.410 --> 01:01:20.880
For the data transfer APIs,
one of the things we do

01:01:20.880 --> 01:01:25.500
provide is automatic support
for initiator page tables.

01:01:25.500 --> 01:01:29.760
In other words, in the SPP model,
there are various models of when

01:01:30.200 --> 01:01:35.020
you're sending writes across the bus,
exactly where they go to and how

01:01:35.080 --> 01:01:40.490
you deal with the fact that the
initiator might have page tables

01:01:40.500 --> 01:01:41.520
or might have a linear memory.

01:01:41.520 --> 01:01:46.660
And the code that we provide
actually deals with that.

01:01:47.240 --> 01:01:51.620
Essentially, the API to the application
is a start data transfer,

01:01:51.620 --> 01:01:57.480
and then our code determines whether
a page table or direct memory is being

01:01:57.480 --> 01:02:01.980
used and translates that into the
appropriate bus transactions to be able

01:02:01.980 --> 01:02:04.210
to enable the right thing to occur.

01:02:07.710 --> 01:02:12.540
So the application will make repeated
calls to rebuffer or write buffer,

01:02:12.540 --> 01:02:17.390
and then call stop data transfer.

01:02:19.820 --> 01:02:21.440
Status APIs.

01:02:21.460 --> 01:02:24.020
There are various times when an
application needs to send status.

01:02:24.820 --> 01:02:27.100
There's a thing for
sending unsolicited status.

01:02:27.100 --> 01:02:34.170
You need to send status in
response to our orbs that come in,

01:02:34.170 --> 01:02:39.530
and command error and orb error statuses.

01:02:43.420 --> 01:02:46.880
In order to achieve these functions,
the application provides

01:02:46.880 --> 01:02:51.020
some event handlers,
and we'll have a quick

01:02:51.080 --> 01:02:54.570
look at the management and
command agent event handlers.

01:03:02.590 --> 01:03:07.830
The event handler is provided
when there's real work to be done.

01:03:07.830 --> 01:03:10.640
For example, operation request blocks.

01:03:10.640 --> 01:03:13.550
An event handler for
things like bus reset.

01:03:13.600 --> 01:03:16.080
And some of the event
handlers are optional.

01:03:25.090 --> 01:03:30.080
So the configuration of these
callbacks works by the application

01:03:30.080 --> 01:03:36.140
calling SPP2 target initializer,
target init, with one callback parameter,

01:03:36.140 --> 01:03:38.240
which is called onOpenSession.

01:03:38.600 --> 01:03:46.940
So the idea here is that whenever an
initiator initiates a new session,

01:03:46.940 --> 01:03:53.280
then this callback will be provided.

01:03:54.500 --> 01:03:58.490
and the login descriptors provided
as a parameter to that callback.

01:03:58.500 --> 01:04:04.000
Entries for all the other callbacks
that you might need are provided

01:04:04.440 --> 01:04:06.850
within that data structure.

01:04:07.110 --> 01:04:13.450
So on the on open session callback,
you initiate those entries,

01:04:13.450 --> 01:04:17.980
which are then set up according to
however your application wants to

01:04:17.980 --> 01:04:21.220
configure all those other callbacks
for this particular session.

01:04:21.240 --> 01:04:24.540
So you can actually use
different callbacks for different

01:04:24.540 --> 01:04:26.110
sessions if you wish to.

01:04:29.260 --> 01:04:31.500
So the callback functions
are on open session,

01:04:31.510 --> 01:04:39.180
on end session, set password,
abort task set, reset target.

01:04:39.410 --> 01:04:43.280
All buffer-full stuff to do.

01:04:43.280 --> 01:04:44.230
Get on with it, please.

01:04:44.230 --> 01:04:48.810
There's Doorbell,
which basically says go and read the

01:04:48.950 --> 01:04:52.380
host descriptors for more commands.

01:04:52.380 --> 01:04:55.280
You needn't actually do
anything about Doorbell in the

01:04:55.360 --> 01:04:57.320
application if you don't want to.

01:04:57.320 --> 01:05:00.830
You can rely on the SVP2
code doing that for you.

01:05:03.710 --> 01:05:07.400
There are also some callbacks
that may be called as a result of

01:05:07.400 --> 01:05:11.860
internal conditions like agent dead,
bus reset, unit attention.

01:05:14.260 --> 01:05:17.590
So that's a quick look at SPP2.

01:05:17.940 --> 01:05:22.970
And just as a final slide,
the FireWire Reference

01:05:23.140 --> 01:05:25.160
Platform is available on the web.

01:05:25.230 --> 01:05:27.060
You can go download it.

01:05:27.060 --> 01:05:31.590
There are some mailing lists
where people who are using this

01:05:31.670 --> 01:05:36.080
are putting all their experience,
questions,

01:05:36.130 --> 01:05:43.190
and indeed swapping their own good hints
as to how to make best use of this.

01:05:44.030 --> 01:05:49.280
So that's the end of a quick
gander through all the facilities

01:05:49.280 --> 01:05:51.260
that are provided in the
FireWire Reference Platform.
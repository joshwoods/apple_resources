WEBVTT

00:00:23.740 --> 00:00:29.130
All right, well, welcome to session 417,
Address Book Framework.

00:00:29.200 --> 00:00:34.840
The Address Book Framework provides you
with the functionality that's needed

00:00:34.890 --> 00:00:38.160
by your application to deliver a really
great user experience and consistent

00:00:38.160 --> 00:00:43.910
user experience because it enables
your users to get access to contacts

00:00:43.940 --> 00:00:48.000
in a consistent manner between your
application and the way they would

00:00:48.000 --> 00:00:49.840
access contacts in another application.

00:00:49.960 --> 00:00:51.600
And that's particularly
true in Panther as we

00:00:51.600 --> 00:00:54.270
introduce the People Picker,
which gives you consistent

00:00:54.270 --> 00:00:55.940
user interface for that.

00:00:55.940 --> 00:00:59.230
So this session-- I love this
technology because it's just really

00:00:59.230 --> 00:01:03.240
well-- it's nicely self-contained
and it's a straightforward API.

00:01:03.240 --> 00:01:04.500
I think that works great.

00:01:04.720 --> 00:01:07.110
And the feedback we've gotten
from developers is that

00:01:07.120 --> 00:01:09.300
it really confirms that.

00:01:09.300 --> 00:01:14.790
So I would like to introduce
l'incroyable Henri Lamiraux to the

00:01:14.790 --> 00:01:17.200
stage to talk you through this stuff.

00:01:24.130 --> 00:01:25.260
Good afternoon.

00:01:25.260 --> 00:01:26.930
That's not me.

00:01:26.970 --> 00:01:27.850
That's me.

00:01:27.950 --> 00:01:31.650
So we're going to talk this afternoon
about the Address Book Framework.

00:01:32.140 --> 00:01:34.760
So this is the agenda for the session.

00:01:34.760 --> 00:01:37.560
The first thing we're going to do is
that I'm going to give you an overview

00:01:37.560 --> 00:01:39.620
of the Address Book Framework APIs.

00:01:39.770 --> 00:01:42.850
I'm not going to go into a lot
of details like I did last year,

00:01:42.870 --> 00:01:46.180
because also I want to concentrate
on what's new in Panther for

00:01:46.180 --> 00:01:47.860
the Address Book Framework.

00:01:47.860 --> 00:01:51.290
So I'm going to talk about the
new properties and APIs we've

00:01:51.290 --> 00:01:54.730
introduced for Panther,
and also talk about the enhancement

00:01:54.730 --> 00:01:58.380
to the AppleScript we've made,
and talk about the People Picker,

00:01:58.380 --> 00:02:02.040
which I think other people
seem to want to have,

00:02:02.410 --> 00:02:05.270
and also talk about the Action Plugins.

00:02:06.300 --> 00:02:08.650
So let's start with the Address
Book Framework overview.

00:02:08.800 --> 00:02:10.840
So before Jaguar, this was a situation.

00:02:10.890 --> 00:02:14.470
We had a lot of applications,
and each one of them was managing

00:02:14.470 --> 00:02:18.170
their contact in a different manner,
which was giving the end

00:02:18.170 --> 00:02:21.610
user a very bad experience,
because they had to re-enter

00:02:21.610 --> 00:02:26.230
the same information over and
over in several applications.

00:02:26.360 --> 00:02:31.200
So for Jaguar, we decided to say, OK,
we're going to create a

00:02:31.290 --> 00:02:35.440
centralized storage for contacts,
so the user has only one place.

00:02:35.440 --> 00:02:39.970
He can enter the information once,
and then any other application

00:02:39.970 --> 00:02:42.660
can reuse this information.

00:02:42.660 --> 00:02:45.190
So this was the situation on Jaguar.

00:02:45.200 --> 00:02:49.200
We introduced that on Jaguar,
and it's been very successful.

00:02:49.760 --> 00:02:55.640
We had a lot of third-party clients
adopting the Address Book Framework.

00:02:55.680 --> 00:02:56.600
And we had a lot of shareware.

00:02:56.600 --> 00:03:00.740
As soon as we shipped Jaguar,
we saw a lot of shareware coming out

00:03:00.740 --> 00:03:04.740
using the Address Book Framework API,
which was a great thing.

00:03:04.780 --> 00:03:07.640
Internally, we have several applications
using the framework.

00:03:07.650 --> 00:03:09.920
Address Book, for sure,
which we introduced a brand new

00:03:10.080 --> 00:03:13.300
Address Book application for Jaguar.

00:03:13.340 --> 00:03:13.890
We have mail.

00:03:13.900 --> 00:03:17.520
We use the Address Book to do mail
completion when you type an email.

00:03:17.550 --> 00:03:22.300
iChat uses it to map the email
to the real name of your bodies.

00:03:22.480 --> 00:03:27.200
Akal uses it to pick up people
so you can have meetings.

00:03:27.320 --> 00:03:29.840
Sherlock in Panther also
uses Address Book now.

00:03:30.040 --> 00:03:33.020
And Safari also uses Address Book.

00:03:33.220 --> 00:03:36.140
And Safari has a great feature,
which is the autofill web form,

00:03:36.140 --> 00:03:39.130
which you can turn on in a preference.

00:03:39.210 --> 00:03:45.170
And it allows you to very quickly fill
up a form using Safari from your Mi Card.

00:03:45.270 --> 00:03:46.940
You can automatically fill up your form.

00:03:46.940 --> 00:03:48.160
It's a great, great feature.

00:03:48.160 --> 00:03:50.890
It works very, very, very well.

00:03:51.950 --> 00:03:55.400
So what is the Address Book Framework?

00:03:55.460 --> 00:03:57.840
The Address Book Framework
is a set of APIs,

00:03:57.890 --> 00:04:02.570
and it's accessible from
Objective-C for Cocoa Developer,

00:04:02.660 --> 00:04:06.700
C and C++ for Carbon Developer,
and also AppleScript.

00:04:06.750 --> 00:04:08.180
It's thread-safe.

00:04:08.380 --> 00:04:10.020
We made sure of that.

00:04:10.390 --> 00:04:13.160
It was very, very important for us
that it was thread-safe.

00:04:13.260 --> 00:04:15.330
And also,
it has concurrency-- it supports

00:04:15.420 --> 00:04:18.690
concurrency to access the database,
which means several applications

00:04:18.780 --> 00:04:21.890
can access the database at the
same times and hopefully the

00:04:21.910 --> 00:04:23.680
database will be OK at the end.

00:04:23.780 --> 00:04:25.600
So we support concurrency very well.

00:04:25.850 --> 00:04:29.360
We have already several applications
in the system using the Address

00:04:29.360 --> 00:04:33.430
Book Framework altogether,
and this is a very important

00:04:33.430 --> 00:04:35.130
feature of the framework.

00:04:35.270 --> 00:04:40.040
We want it also to be extensible,
because we want you to use the framework.

00:04:40.340 --> 00:04:43.040
We want you to be able to add your
own properties and not be limited

00:04:43.040 --> 00:04:46.500
to the properties Apple decided
that they were the right properties.

00:04:46.600 --> 00:04:49.900
So you can extend the
property set of the database.

00:04:50.000 --> 00:04:51.120
Thank you.

00:04:54.210 --> 00:04:57.550
So I'm going to go a little bit
deeper now and look at several of

00:04:57.550 --> 00:05:03.780
the classes and API that are part
of the Address Book Framework.

00:05:03.840 --> 00:05:06.860
Let's start with ABRecord.

00:05:07.070 --> 00:05:12.100
So ABRecord is basically a row,
one row in Address Book Database.

00:05:12.400 --> 00:05:16.590
The Address Book Database is a very basic
type of database with rows and columns,

00:05:16.730 --> 00:05:19.980
columns being the properties,
and each row is represented

00:05:19.980 --> 00:05:22.340
in memory by an ABRecord.

00:05:22.390 --> 00:05:28.770
Every ABRecord has a unique ID,
which so you can easily remember this ID,

00:05:28.920 --> 00:05:31.170
comment back the deleter,
reopen the database,

00:05:31.280 --> 00:05:32.940
and ask for the record
with this unique ID.

00:05:32.940 --> 00:05:34.180
This is the unique ID.

00:05:34.180 --> 00:05:36.590
It's completely unique.

00:05:37.150 --> 00:05:41.230
The A/B record has two
important subclasses,

00:05:41.350 --> 00:05:45.900
which are A/B Person and A/B Group.

00:05:46.180 --> 00:05:48.220
So as I said,
think of the A/B record as a

00:05:48.220 --> 00:05:51.200
dictionary of property-value pairs.

00:05:51.250 --> 00:05:53.860
You have a property and it has a value.

00:05:56.250 --> 00:05:59.600
So some of the API on AB record.

00:05:59.790 --> 00:06:01.540
The first one is unique ID.

00:06:01.540 --> 00:06:04.280
You can get access to the
unique ID for this record.

00:06:04.330 --> 00:06:05.980
There is no set unique ID.

00:06:06.020 --> 00:06:09.240
Unique ID is a read-only property.

00:06:09.290 --> 00:06:12.130
And a unique ID is just a string.

00:06:12.590 --> 00:06:16.620
And then you have a set
of APIs to set a value,

00:06:16.880 --> 00:06:19.980
so set value for property,
for a given property,

00:06:20.030 --> 00:06:24.120
set the value for this property,
be able to retrieve a property

00:06:24.120 --> 00:06:25.960
using value for property.

00:06:26.060 --> 00:06:28.440
Property are just strings.

00:06:28.500 --> 00:06:31.290
And the last one is
remove value for property.

00:06:31.430 --> 00:06:34.340
We have this notion in the Address
Book Framework where there is a

00:06:34.340 --> 00:06:38.330
difference between a zero and not set.

00:06:38.610 --> 00:06:41.310
So we have this notion of
if a property is not set,

00:06:41.370 --> 00:06:43.720
you're going to get nil,
which is different than returning

00:06:43.720 --> 00:06:44.940
zero or an empty string.

00:06:44.940 --> 00:06:46.940
This is a very important notion.

00:06:47.000 --> 00:06:51.280
So you can really remove a value,
which means it's not anymore set,

00:06:51.320 --> 00:06:55.370
which is different than set it to
zero or the empty string or whatever.

00:06:57.990 --> 00:06:58.950
So let's take an example.

00:06:59.000 --> 00:07:03.170
Let's say that I have a record,
which I obtain some other

00:07:03.170 --> 00:07:04.730
way we'll see later on.

00:07:04.890 --> 00:07:09.810
And what I can do here is that I can
ask for the value for some property,

00:07:09.930 --> 00:07:12.100
and I will be returned a value.

00:07:12.420 --> 00:07:13.440
And here I can test.

00:07:13.480 --> 00:07:17.040
If the value is nil,
it means it was never set before.

00:07:17.070 --> 00:07:18.240
So I can do something.

00:07:18.250 --> 00:07:22.040
Or if it was not set, I can do something.

00:07:22.370 --> 00:07:26.180
If it was set, it was different of nil,
I can do something else.

00:07:26.200 --> 00:07:32.000
And then I can set back this
value for the given property.

00:07:32.060 --> 00:07:33.580
So very straightforward.

00:07:33.590 --> 00:07:35.270
Value for property,
set value for property.

00:07:35.300 --> 00:07:40.580
So what are those properties?

00:07:46.730 --> 00:07:50.300
So a property has a unique name.

00:07:50.300 --> 00:07:52.760
They have to be unique,
so you can't have two

00:07:52.760 --> 00:07:53.770
first name properties.

00:07:53.850 --> 00:07:56.760
It has to be a unique
name across the database.

00:07:56.870 --> 00:08:00.210
So it's a name, like first name,
last name, et cetera.

00:08:00.420 --> 00:08:03.730
And it has also a type,
which can be integer, string, data,

00:08:03.740 --> 00:08:05.250
dictionary.

00:08:05.440 --> 00:08:08.160
So that's what a property is.

00:08:08.160 --> 00:08:10.820
This is a list of the data we support.

00:08:10.820 --> 00:08:15.800
And here it says single value types,
because a property of type

00:08:15.970 --> 00:08:19.920
KAB string property means there is
only one string in this property.

00:08:20.000 --> 00:08:24.600
So we have string, integer, real, date,
data, dictionary, array,

00:08:24.840 --> 00:08:29.620
everything that Core Foundation supports,
all the standard types.

00:08:29.660 --> 00:08:30.370
So this is important.

00:08:30.440 --> 00:08:31.980
This is for single value property.

00:08:31.980 --> 00:08:35.810
It means the value
contains only one value,

00:08:35.900 --> 00:08:38.850
one string, one integer, one real.

00:08:40.220 --> 00:08:42.300
So example of single value property.

00:08:42.600 --> 00:08:44.460
First name is a string property.

00:08:44.470 --> 00:08:46.260
Last name is a string property.

00:08:46.260 --> 00:08:47.860
Birthday, you only have one.

00:08:47.920 --> 00:08:49.990
It's a date property.

00:08:51.200 --> 00:08:54.740
But we discovered very quickly
that doesn't always work.

00:08:54.870 --> 00:08:57.280
For example,
I'm sure most of you have more than one

00:08:57.290 --> 00:08:59.900
email and more than one phone number.

00:09:00.030 --> 00:09:04.230
So we could have said, OK,
we're going to have home one property,

00:09:04.230 --> 00:09:08.540
or home email one property,
home email two property, et cetera.

00:09:08.590 --> 00:09:10.430
But that didn't work very, very well.

00:09:10.680 --> 00:09:13.450
What we wanted to be able to
do is having one property and

00:09:13.450 --> 00:09:18.620
associate with this property
multiple pairs of label and value.

00:09:18.730 --> 00:09:21.010
So for example,
this person has three emails.

00:09:21.100 --> 00:09:24.250
He has two home emails
and one work email.

00:09:24.620 --> 00:09:29.720
So we wanted to have one property
associated with multiple instances

00:09:29.720 --> 00:09:32.570
of label and value pairs.

00:09:35.790 --> 00:09:38.620
So we've introduced this
notion of multivalue,

00:09:38.640 --> 00:09:40.560
single value, multivalue.

00:09:40.580 --> 00:09:43.500
And the class that encapsulates
the notion of multivalue

00:09:43.500 --> 00:09:47.830
is called ABMultivalue,
which is kind of straightforward.

00:09:47.920 --> 00:09:50.350
I'll capture the notion of a multivalue.

00:09:50.880 --> 00:09:54.830
Think of a multivalue as another
type of collection classes

00:09:54.830 --> 00:09:57.260
like NSDictionary or NSArray.

00:09:57.260 --> 00:10:01.840
And the same way you have a
NSDictionary and NSMutableDictionary,

00:10:01.840 --> 00:10:07.940
we have also a mutable and non-mutable
flavor of the ABMultivalue.

00:10:08.430 --> 00:10:12.440
So what are those multivalues exactly?

00:10:12.450 --> 00:10:16.640
A multivalue is just
an array of triplets.

00:10:16.640 --> 00:10:20.700
For each value inside this multivalue,
there are three things.

00:10:20.780 --> 00:10:25.160
There is a label, an identifier,
and a value.

00:10:25.810 --> 00:10:26.650
So what's a label?

00:10:26.710 --> 00:10:29.400
A label is a label, like home, work.

00:10:29.400 --> 00:10:30.540
It doesn't have to be unique.

00:10:30.580 --> 00:10:32.040
It can be anything you want.

00:10:32.040 --> 00:10:35.330
It can be anything the user decides,
my vacation, home, whatever.

00:10:35.330 --> 00:10:40.040
It doesn't have to be unique.

00:10:40.090 --> 00:10:41.890
And that's a label.

00:10:43.400 --> 00:10:44.270
The identifier.

00:10:44.590 --> 00:10:47.160
So,
wondering why do I have this identifier?

00:10:47.420 --> 00:10:48.650
Label and value should be enough.

00:10:49.080 --> 00:10:50.800
The problem is the following.

00:10:50.800 --> 00:10:52.530
The label is not unique.

00:10:52.600 --> 00:10:54.900
So,
you can't say I want my own phone number.

00:10:54.900 --> 00:10:56.330
You may have two or three in there.

00:10:56.350 --> 00:11:00.530
So, using the label to be able to
identify which value you're

00:11:00.530 --> 00:11:02.710
talking about is not enough.

00:11:03.380 --> 00:11:05.130
The index also doesn't work.

00:11:05.130 --> 00:11:09.100
You can't say I want the third
phone because at one point,

00:11:09.160 --> 00:11:12.380
another application can come and
completely reorder this multivalue

00:11:12.380 --> 00:11:16.060
and your third email doesn't point to
what you thought it was pointing to.

00:11:16.060 --> 00:11:19.650
So, you can't use the label and you can't
use the index to be able to reference

00:11:19.730 --> 00:11:21.480
a value within the multivalue.

00:11:21.480 --> 00:11:24.060
So,
we introduced this notion of identifier,

00:11:24.080 --> 00:11:28.360
which is a way for you to remember which
phone number you were talking about.

00:11:28.360 --> 00:11:32.520
Let's say that you had an application
that you had the selection of one email.

00:11:33.090 --> 00:11:36.240
And you want to remember the selection
between launch of your application.

00:11:36.260 --> 00:11:39.500
So, what you can do is remember
the identifier for this email.

00:11:39.500 --> 00:11:41.640
And next time you
launch your application,

00:11:41.640 --> 00:11:44.610
you can find which email was
selected the previous time.

00:11:44.620 --> 00:11:48.230
You cannot use the label for that and
you cannot use the index for that.

00:11:50.630 --> 00:11:53.850
And finally, you have the value,
which is really what the user really

00:11:53.850 --> 00:11:56.260
wants to have in the multivalue.

00:11:56.300 --> 00:11:59.580
And the value is the only thing
that's important with the value is

00:11:59.580 --> 00:12:02.900
that all value within the multivalue
has to be of the same type.

00:12:03.120 --> 00:12:13.790
So if you have a multi-string property,
all the value within this multivalue

00:12:13.790 --> 00:12:13.790
has to be strings or date or whatever.

00:12:15.090 --> 00:12:21.310
So the same way we have a single value,
we have also a multivalue.

00:12:21.360 --> 00:12:25.970
So for string, we have multistring value,
multiinteger property, multireal,

00:12:26.000 --> 00:12:28.720
et cetera, and multidate,
multidictionary.

00:12:28.770 --> 00:12:30.960
So we have,
for each type of single value,

00:12:30.960 --> 00:12:34.000
we have also a corresponding multivalue.

00:12:35.630 --> 00:12:39.400
So let's take a couple of examples
to see exactly how this stuff works.

00:12:39.530 --> 00:12:45.220
Let's say that I want to display
all email addresses of a person.

00:12:45.620 --> 00:12:49.950
So I have a person,
which I got from some other way.

00:12:50.100 --> 00:12:54.740
And first thing I want to do is say, OK,
give me the email of this person.

00:12:54.740 --> 00:12:57.140
So you call person value for property.

00:12:57.180 --> 00:13:00.700
And the property name for
email is kabemailproperty.

00:13:00.910 --> 00:13:06.040
And we return you an ABMultiValue,
which is all the email of this person.

00:13:06.220 --> 00:13:09.800
So now you can say, OK,
tell me how many emails are in there.

00:13:09.800 --> 00:13:13.430
So email counts,
and you get a number of emails.

00:13:13.790 --> 00:13:17.900
And now I can do a little loop
and print each one of them.

00:13:18.220 --> 00:13:21.550
I can use an index here because
when I call value for property,

00:13:21.550 --> 00:13:23.760
I return my own copy of those values.

00:13:23.760 --> 00:13:25.320
So this is mine.

00:13:25.640 --> 00:13:28.890
If someone else changes the
database while I'm iterating,

00:13:29.230 --> 00:13:30.040
it's fine.

00:13:30.280 --> 00:13:33.300
This is an in-memory copy of
all the emails of this person.

00:13:33.300 --> 00:13:35.730
So here you can use an index.

00:13:35.950 --> 00:13:41.080
So I can say emails labeled at index,
print the index, print the label,

00:13:41.080 --> 00:13:42.730
and print the value.

00:13:42.930 --> 00:13:45.910
And I will list all the
emails of this person.

00:13:46.100 --> 00:13:50.280
So let's see how you can
change someone's data.

00:13:50.630 --> 00:13:54.950
So I want to add an email
address to a given person.

00:13:55.580 --> 00:13:57.510
So I have a person.

00:13:57.830 --> 00:13:59.120
I do the same thing.

00:13:59.150 --> 00:14:03.720
Person, value for property,
KAB email property.

00:14:03.740 --> 00:14:09.020
And I'm written on the multivalue
corresponding to all the emails.

00:14:09.290 --> 00:14:12.890
The thing here is that I'm getting
here a non-mutable multivalue.

00:14:13.130 --> 00:14:16.360
So before I can change it,
I have to make a copy.

00:14:16.360 --> 00:14:17.680
I have to make a mutable copy.

00:14:17.700 --> 00:14:20.790
This is the same kind of thing
you have to do with dictionaries

00:14:20.790 --> 00:14:23.740
of array when you're programming
in Cocoa or in Core Foundation.

00:14:23.790 --> 00:14:25.720
So I have to do a mutable copy first.

00:14:25.750 --> 00:14:29.620
And now I'm getting an
AB mutable multivalue.

00:14:29.630 --> 00:14:32.290
And now I can add a new value in there.

00:14:32.660 --> 00:14:40.060
So I can say, mutable emails,
add a value, the email, and give a label.

00:14:40.080 --> 00:14:43.540
The Address Book framework
provides a bunch of predefined

00:14:43.540 --> 00:14:47.620
labels for common things,
like home email, work email.

00:14:47.670 --> 00:14:50.910
So here I'm just going
to use a built-in label,

00:14:50.910 --> 00:14:52.960
which is the home email label.

00:14:55.960 --> 00:14:59.170
When I modify my multivalue,
I can now set it back using

00:14:59.170 --> 00:15:01.140
set value for property.

00:15:01.190 --> 00:15:06.240
And because I made a mutable copy,
I have to release the mutable emails.

00:15:06.410 --> 00:15:10.770
And here I added an email.

00:15:10.860 --> 00:15:13.490
So let's talk now about AB Person.

00:15:20.870 --> 00:15:23.550
So, AB Person, as I said,
is a subclass of AB Record.

00:15:23.670 --> 00:15:26.990
So,
all the API I showed you on AB Record are

00:15:26.990 --> 00:15:28.630
also available on AB Person.

00:15:28.710 --> 00:15:31.610
And an AB Person represents a person.

00:15:33.210 --> 00:15:36.100
And here are some of
the properties that we,

00:15:36.140 --> 00:15:39.840
just a sample of the property
we support for person.

00:15:39.840 --> 00:15:43.640
We have first name, last name, birthday,
email, phone, addresses.

00:15:43.670 --> 00:15:46.180
We have a lot more,
but this is just an example.

00:15:46.250 --> 00:15:50.630
I just want to point out to the last one,
address property, which is of type

00:15:50.950 --> 00:15:52.190
multi-dictionary property.

00:15:52.270 --> 00:15:57.860
So, first of all,
a person can have multiple addresses.

00:15:57.860 --> 00:16:01.020
I mean, like my home address,
my work address, my vacation address.

00:16:01.020 --> 00:16:02.600
So, it needs to be a multi-value.

00:16:03.100 --> 00:16:04.780
But then, what is an address?

00:16:04.780 --> 00:16:08.960
Sometimes you want to, you think about an
address as a whole thing.

00:16:08.960 --> 00:16:10.740
It says, what is your address?

00:16:10.740 --> 00:16:13.960
And you don't think about the
part that composes the address.

00:16:13.960 --> 00:16:16.020
You're just thinking about
the address as a whole.

00:16:16.020 --> 00:16:18.560
So, this is why we're using
a dictionary for address.

00:16:18.560 --> 00:16:22.740
Like that, you can use a dictionary
as just my address.

00:16:22.740 --> 00:16:25.560
But then, you can also dig into
the address and say,

00:16:25.560 --> 00:16:26.940
what is your zip code?

00:16:26.940 --> 00:16:28.300
What is your street?

00:16:28.300 --> 00:16:29.020
What is your city?

00:16:29.020 --> 00:16:32.680
And we have key defined for each
one of those fields for the address.

00:16:33.100 --> 00:16:37.040
So, KAB address property is one of
the most complex property we have,

00:16:37.040 --> 00:16:38.160
which is a multi-dictionary.

00:16:38.160 --> 00:16:40.780
So, you have this three level of data.

00:16:40.780 --> 00:16:42.180
You have the multi-value.

00:16:42.180 --> 00:16:44.240
You have a dictionary for each address.

00:16:44.240 --> 00:16:47.020
And then,
you can dig to the field of each address.

00:16:47.020 --> 00:16:48.290
Thank you.

00:16:52.360 --> 00:16:54.300
The next one is AB Group.

00:16:54.300 --> 00:17:00.540
AB Group, like AB Person,
is a subclass of AB Record,

00:17:00.540 --> 00:17:03.110
and it represents a group
of people or records.

00:17:03.110 --> 00:17:06.090
You can mix records and
people within a group.

00:17:06.140 --> 00:17:11.300
The only thing we don't allow
is to have circular references,

00:17:11.300 --> 00:17:14.800
so we flag for that,
and we won't be able to add groups

00:17:14.820 --> 00:17:17.250
inside each other and make loops.

00:17:19.580 --> 00:17:23.170
There is only one standard
property for a group,

00:17:25.140 --> 00:17:27.370
which is the name of the
group of type string.

00:17:29.140 --> 00:17:33.280
So let's now move on on the
Address Book class itself.

00:17:33.280 --> 00:17:35.300
A/B Address Book.

00:17:35.910 --> 00:17:41.080
The A/B Address Book represents
the Address Book database itself.

00:17:41.140 --> 00:17:45.300
And it's located in the user library
application support Address Book.

00:17:45.300 --> 00:17:48.640
There is a folder there that
contains the database plus a bunch

00:17:48.640 --> 00:17:52.010
of indexes and things like that,
and the images.

00:17:52.120 --> 00:17:54.620
But for the user,
everything is in application

00:17:54.760 --> 00:17:56.010
support Address Book.

00:17:56.310 --> 00:17:58.550
Within your application,
there is only one unique shared

00:17:58.580 --> 00:18:00.260
instance of the Address Book class.

00:18:00.260 --> 00:18:06.900
You cannot create multiple
instances of the Address Book class.

00:18:11.190 --> 00:18:12.120
So let's look at the API.

00:18:12.140 --> 00:18:18.450
The first one is,
how do I get to this instance?

00:18:18.470 --> 00:18:22.520
So we have a class method
called Shared Address Book.

00:18:22.650 --> 00:18:28.310
It allows you to get access
to the Address Book instance.

00:18:28.880 --> 00:18:30.880
So what you can do on the Address
Book is that you can save.

00:18:30.880 --> 00:18:31.910
You make a bunch of changes.

00:18:31.920 --> 00:18:35.460
I didn't show that before,
but you make a bunch of changes,

00:18:35.460 --> 00:18:37.040
set value, set value, set value.

00:18:37.060 --> 00:18:40.750
And at one point,
you need to be able to save your changes,

00:18:40.790 --> 00:18:41.940
to commit your changes to the database.

00:18:42.040 --> 00:18:47.140
So we have this save method on Address
Book that allows you to commit all

00:18:47.140 --> 00:18:49.300
the changes you've made so far.

00:18:49.340 --> 00:18:53.890
So for performance reason,
it's much better to do

00:18:53.990 --> 00:18:56.850
a bunch of set value,
set value, set value, set value,

00:18:56.850 --> 00:18:58.200
and then do your save.

00:18:58.220 --> 00:19:00.880
Don't do a change, save, change, save.

00:19:00.900 --> 00:19:02.560
That's not too efficient.

00:19:02.590 --> 00:19:05.410
Do a bunch of changes and just
save all your changes at once.

00:19:05.440 --> 00:19:10.390
We also have a method that says,
are there any pending changes?

00:19:11.350 --> 00:19:13.710
There is one special person
in your Address Book,

00:19:13.720 --> 00:19:16.970
which is yourself, or myself, I think.

00:19:17.170 --> 00:19:19.980
And that goes at the MiCard.

00:19:20.030 --> 00:19:23.420
So we have a method
that returns the MiCard,

00:19:23.420 --> 00:19:27.620
the card for the user of this account.

00:19:27.630 --> 00:19:30.300
So you can get the MiCard,
and you can also set the MiCard if you

00:19:30.300 --> 00:19:32.730
want to change it to another person.

00:19:35.940 --> 00:19:38.880
As I said earlier,
every record has a unique ID.

00:19:38.980 --> 00:19:42.600
So you may imagine your application
wanted to save away some

00:19:42.600 --> 00:19:44.820
reference to some specific person.

00:19:44.900 --> 00:19:48.400
So to do that, you will save the unique
ID of this person.

00:19:48.450 --> 00:19:51.010
And you have a way to go back to
the record corresponding to this

00:19:51.100 --> 00:19:53.520
person by calling recordForUniqueId.

00:19:53.560 --> 00:19:57.120
You have a unique ID that you
save in your preference somewhere.

00:19:57.160 --> 00:20:01.520
And you can get back the record
by calling recordForUniqueId.

00:20:03.350 --> 00:20:08.500
You can add a record and remove
record from the database.

00:20:08.540 --> 00:20:11.840
And so you can get access
to all the people or all the

00:20:11.840 --> 00:20:14.690
groups that are in the database.

00:20:18.050 --> 00:20:20.640
So let's get some example here.

00:20:20.670 --> 00:20:25.510
Let's say that I want to add a
person named John Doe to my database.

00:20:26.050 --> 00:20:28.790
The first thing I'm going to do,
define a couple of variables,

00:20:28.800 --> 00:20:30.940
an address book and a new
person I'm going to create.

00:20:31.000 --> 00:20:34.530
I get access to the address book.

00:20:34.740 --> 00:20:39.940
And I create a new person
by allocating a new person.

00:20:40.470 --> 00:20:42.220
And now I can set the value.

00:20:42.220 --> 00:20:46.670
So I can say set value
for first name John.

00:20:47.470 --> 00:20:51.300
And I also can say set
value for the last name,

00:20:51.300 --> 00:20:51.960
Doe.

00:20:52.040 --> 00:20:54.460
So now I have this person,
but it's just there.

00:20:54.460 --> 00:20:56.100
It's not added yet to the database.

00:20:56.100 --> 00:20:57.580
So I have to add it.

00:20:57.890 --> 00:21:00.580
I say Address Book, add this record.

00:21:00.800 --> 00:21:03.040
As a good Cocoa programmer,
I have to release the

00:21:03.360 --> 00:21:06.040
person I just created,
because it's been added to the database,

00:21:06.040 --> 00:21:07.540
so I don't care.

00:21:07.630 --> 00:21:08.270
And I have to save.

00:21:08.460 --> 00:21:11.480
I have to save my changes that
will save this new record and

00:21:11.490 --> 00:21:15.300
insert it into the database.

00:21:15.380 --> 00:21:16.460
Searching.

00:21:16.520 --> 00:21:19.890
Searching is an important
part of the Address Book API.

00:21:23.900 --> 00:21:27.100
And the API you have to use
to do searching is called

00:21:27.100 --> 00:21:29.400
Record Matching Search Element.

00:21:29.500 --> 00:21:34.060
What it does is that you build a query,
and it will return an array of the

00:21:34.070 --> 00:21:36.720
people that match your request.

00:21:36.820 --> 00:21:38.900
So it will return an
NSArray of people or groups,

00:21:38.970 --> 00:21:41.070
depending what you're looking for.

00:21:41.250 --> 00:21:47.790
And how you build this query is by
using what we call an AB Search Element.

00:21:48.340 --> 00:21:51.190
which I'm going to talk right now about.

00:21:51.490 --> 00:21:57.720
So the A/B search element is the
brilliant block to make for queries.

00:21:57.910 --> 00:21:59.400
Let's take an example.

00:21:59.470 --> 00:22:01.920
Let's say you want to find
all the people that live in

00:22:01.920 --> 00:22:06.810
New York and have a Mac.com account,
a Mac.com email address.

00:22:06.980 --> 00:22:09.720
So you have to build
three search elements.

00:22:09.810 --> 00:22:13.000
The first one which says find
all the people that have their

00:22:13.000 --> 00:22:15.200
home city being New York.

00:22:15.200 --> 00:22:17.890
And the second one would be
find all the people that have

00:22:17.940 --> 00:22:20.600
an email containing Mac.com.

00:22:20.630 --> 00:22:21.900
And then you combine those two sets.

00:22:21.900 --> 00:22:25.180
Find all the people
that have one and two.

00:22:25.210 --> 00:22:28.800
So by building those
small search elements,

00:22:28.870 --> 00:22:34.690
combining them together using and and or,
you can build more complex queries.

00:22:36.300 --> 00:22:40.000
So how do you create one
of those search elements?

00:22:40.050 --> 00:22:42.940
It depends if you want to
search on person or group.

00:22:43.070 --> 00:22:48.990
So we have class method on AB person
and AB group to create those--

00:22:49.120 --> 00:22:52.630
Those search elements and the method
is search element for properties,

00:22:52.630 --> 00:22:55.150
for property label, key value comparison.

00:22:55.260 --> 00:22:58.900
So the easiest thing is to get,
take an example and see

00:22:58.900 --> 00:23:00.340
how does that works.

00:23:00.400 --> 00:23:04.970
So let's say that I want to search for
all people that have John as first name.

00:23:07.180 --> 00:23:09.760
So define a bunch of variables,
Address Book.

00:23:09.760 --> 00:23:13.360
I want to create a search element,
so I define a search element,

00:23:13.380 --> 00:23:18.280
and I define my resulting array where
I'm gonna get the result of the query.

00:23:18.300 --> 00:23:23.800
I want to search for all the people,
so I'm calling the method on AB_PERSON.

00:23:26.120 --> 00:23:27.620
on AB Person.

00:23:27.670 --> 00:23:30.920
So I'm calling on AB Person,
and I'm calling search element.

00:23:30.920 --> 00:23:34.540
I'm looking for the first name.

00:23:34.890 --> 00:23:38.280
So search element for property,
first name.

00:23:38.380 --> 00:23:40.630
I'm skipping the label and key.

00:23:40.640 --> 00:23:42.140
We'll talk about that later.

00:23:42.290 --> 00:23:43.170
And the value is John.

00:23:43.170 --> 00:23:47.380
So every person searching for property,
first name, value John.

00:23:47.380 --> 00:23:50.180
And I'm going to do a
case-insensitive search.

00:23:50.180 --> 00:23:53.300
You never know how I spell the name.

00:23:53.300 --> 00:23:56.920
So case-insensitive search.

00:23:57.010 --> 00:23:59.810
And I'm going to call-- I'm
going to get access to my address

00:24:00.080 --> 00:24:03.900
book instance and can call now
record matching search element.

00:24:03.940 --> 00:24:07.920
And I will be returned an array
containing either empty or containing a

00:24:07.920 --> 00:24:11.780
list of people whose first name is John.

00:24:12.890 --> 00:24:14.720
So let's do something more complex.

00:24:14.770 --> 00:24:18.040
I want to search all
people living in New York.

00:24:18.940 --> 00:24:19.500
Same thing here.

00:24:19.500 --> 00:24:20.380
I'm looking for people.

00:24:20.580 --> 00:24:24.540
So I'm going to call the
class method on abPerson.

00:24:24.570 --> 00:24:26.260
I'm looking for people
living in New York,

00:24:26.260 --> 00:24:28.910
so this is the address property.

00:24:29.240 --> 00:24:31.820
And I say, living in New York,
so most likely,

00:24:31.850 --> 00:24:35.040
I want people with their home
label-- their label is home,

00:24:35.040 --> 00:24:37.810
so I'm searching for label AB home label.

00:24:38.170 --> 00:24:40.030
And I say for the city of New York.

00:24:40.140 --> 00:24:44.500
So here, I'm using one of the key I was
telling you before about the address,

00:24:44.650 --> 00:24:46.740
the street address,
which is a dictionary.

00:24:46.740 --> 00:24:49.940
And the key for city is
KAB address city key.

00:24:50.260 --> 00:24:51.680
So I pass that.

00:24:51.940 --> 00:24:53.840
The value is New York.

00:24:54.150 --> 00:24:57.500
And I'm doing also here
a case-sensitive search.

00:24:57.520 --> 00:25:01.820
And I can call record matching
search element with my element.

00:25:01.870 --> 00:25:05.770
So you can build those little
search element and combine them

00:25:05.770 --> 00:25:09.500
also to create more complex queries.

00:25:09.500 --> 00:25:13.870
So there is an API to do that,
which is search element for conjunction.

00:25:13.930 --> 00:25:17.280
So conjunction being either or an end.

00:25:17.300 --> 00:25:18.710
And you pass it a list of children.

00:25:18.840 --> 00:25:23.310
So if you want to end two search element,
you pass an array of two search

00:25:23.330 --> 00:25:25.040
elements you've created before.

00:25:25.050 --> 00:25:27.200
And you can end them together.

00:25:27.500 --> 00:25:31.140
and get another search element,
which is the union of those two.

00:25:35.400 --> 00:25:38.200
So I've been showing
you the Objective-C API,

00:25:38.310 --> 00:25:44.060
but for people who are using Carbon,
we have this full set also of

00:25:44.060 --> 00:25:45.850
API for C and also for AppleScript.

00:25:45.910 --> 00:25:51.200
So the C API are basically
identical to the Objective-C.

00:25:51.200 --> 00:25:54.210
They are functionally
identical to Objective-C.

00:25:54.240 --> 00:25:57.380
Everything that I show you in
Objective-C can be done also in C.

00:25:57.380 --> 00:26:03.150
We use the same CF naming convention
and style that Core Foundation uses,

00:26:03.930 --> 00:26:07.970
and objects are represented by
opaque types like AB Person Ref,

00:26:07.970 --> 00:26:11.850
AB Group Ref, AB Multi-Value Ref,
same way that we have

00:26:11.890 --> 00:26:14.040
CFStringRef or CFArrayRef.

00:26:14.140 --> 00:26:15.100
So it's the same.

00:26:15.100 --> 00:26:17.660
If you're used to the
CF naming convention,

00:26:17.750 --> 00:26:19.200
it's exactly the same.

00:26:21.540 --> 00:26:23.270
So let's take an example.

00:26:23.370 --> 00:26:26.380
This is, for example,
adding a person whose name is John Doe.

00:26:26.380 --> 00:26:29.780
So instead of being Objective-C,
this is C.

00:26:29.780 --> 00:26:31.700
And the method is a, b,
get shared address book.

00:26:31.730 --> 00:26:34.160
And you get an address book ref.

00:26:34.500 --> 00:26:37.530
I can create a person by calling a, b,
person, create.

00:26:37.590 --> 00:26:40.080
And I get back a person.

00:26:40.440 --> 00:26:42.980
And I can call-- because
a person is a record,

00:26:42.980 --> 00:26:46.980
the method to set a value
is ab_record_set_value,

00:26:47.000 --> 00:26:51.250
giving the person, giving the string,
and the property is

00:26:51.350 --> 00:26:55.330
kab_firstname_property,
something for the last name.

00:26:55.560 --> 00:26:59.830
And now I can add my
record to the database.

00:27:00.270 --> 00:27:01.390
I'm missing two things here.

00:27:01.490 --> 00:27:05.940
I should release--
I call ab_person_create,

00:27:06.250 --> 00:27:08.960
so I should have a cf_release_person.

00:27:09.270 --> 00:27:12.810
Otherwise, you're going to have a leak,
and that should also save.

00:27:13.200 --> 00:27:17.720
The CF release is important because
if you call any create method,

00:27:17.720 --> 00:27:20.620
you should have a release
method somewhere in your code.

00:27:20.620 --> 00:27:24.890
Otherwise, you will be leaking a
bunch of references.

00:27:27.890 --> 00:27:29.910
AppleScript support.

00:27:30.010 --> 00:27:30.890
Same thing with the C.

00:27:31.050 --> 00:27:36.620
We have full access to all the API of the
Address Book Framework in AppleScript.

00:27:36.720 --> 00:27:39.440
The only difference is that here
you're not talking to the framework.

00:27:39.540 --> 00:27:41.590
You can't say,
"Tell Address Book Framework."

00:27:41.690 --> 00:27:43.840
You have to say,
"Tell Address Book Application." So you

00:27:43.840 --> 00:27:48.840
have access to all the AppleScript,
all the Address Book API through

00:27:48.840 --> 00:27:51.030
the Address Book Application.

00:27:51.360 --> 00:27:56.730
and I will show you later some
enhancements we made to AppleScript.

00:27:57.190 --> 00:28:00.440
So I have an example here.

00:28:00.480 --> 00:28:02.960
Tell application Address Book.

00:28:02.980 --> 00:28:06.020
What I'm doing here is that all
people will contain an array of

00:28:06.020 --> 00:28:07.700
all the people in my database.

00:28:07.740 --> 00:28:09.960
Set all people to people.

00:28:10.010 --> 00:28:15.220
So now I'm going to iterate
through each person in this array.

00:28:15.220 --> 00:28:18.980
And here, what I'm doing is that I'm
getting the multivalue containing

00:28:18.980 --> 00:28:20.230
all the email of this person.

00:28:20.360 --> 00:28:23.420
Set all emails to emails of a person.

00:28:23.450 --> 00:28:27.100
So all emails will be a multivalue
containing all the email of this person.

00:28:27.240 --> 00:28:31.430
And I can go through each value
within this multivalue and

00:28:31.480 --> 00:28:35.170
extract the email and print it.

00:28:35.680 --> 00:28:38.930
So you have the same functionality
you have in AppleScript that

00:28:38.930 --> 00:28:41.290
you have with C or Objective-C.

00:28:41.690 --> 00:28:46.500
So this was kind of a quick
overview of the Address Book API.

00:28:46.640 --> 00:28:49.100
I think that covers basic functionality.

00:28:49.410 --> 00:28:52.660
There is a lot more,
but I'm not showing it here today.

00:28:52.910 --> 00:28:57.340
I want to concentrate now on what's
new in Panther for Address Book.

00:29:03.220 --> 00:29:06.140
So for Panther, we listened to you.

00:29:06.140 --> 00:29:09.090
We had a lot of good feedback
from developers about the

00:29:09.090 --> 00:29:10.400
Address Book Framework.

00:29:10.420 --> 00:29:12.920
And so for Panther,
we decided to plug some

00:29:12.920 --> 00:29:16.370
of the hole in the APIs or
property that we had in Jaguar.

00:29:16.650 --> 00:29:19.500
So we've added a couple
of APIs or properties.

00:29:19.510 --> 00:29:22.220
And also, we've enhanced the performance.

00:29:22.240 --> 00:29:24.440
The Panther version is
much faster at saving,

00:29:24.440 --> 00:29:26.100
at doing search.

00:29:26.100 --> 00:29:30.010
So better performance, and for sure,
we fixed a couple of bugs.

00:29:32.490 --> 00:29:38.280
So let's talk about the new properties
and API that we've introduced in Panther.

00:29:39.500 --> 00:29:42.840
So in Jaguar, we had one property called
the birthday property,

00:29:42.840 --> 00:29:46.960
which was a single
value for the birthday.

00:29:46.960 --> 00:29:50.310
We've added a new property
in Panther that has we

00:29:50.470 --> 00:29:52.060
called it author dates.

00:29:52.060 --> 00:29:55.760
We didn't find a better name for that,
which basically author dates.

00:29:55.760 --> 00:29:58.870
And there is one predefined
label which is the anniversary.

00:29:58.870 --> 00:30:02.310
We kept the birthday because after
all people have only one birthday.

00:30:02.310 --> 00:30:04.790
So we say, yeah,
that should be a single value.

00:30:04.840 --> 00:30:09.260
So we kept the birthday property as is,
but we've added this new property which

00:30:09.310 --> 00:30:12.480
can contain whatever dates you want.

00:30:13.460 --> 00:30:17.800
We've also added a property
called RelatedNamesProperty,

00:30:17.830 --> 00:30:19.660
which is just a multi-string.

00:30:19.770 --> 00:30:23.300
And we are defining a bunch
of labels on that-- father,

00:30:23.300 --> 00:30:26.420
mother, friend, associate.

00:30:26.810 --> 00:30:29.200
You should check out the
Panther version of Address Book.

00:30:29.310 --> 00:30:32.760
We have a nice usage of this
property where we can link cards.

00:30:32.760 --> 00:30:38.320
So you can jump from one card to
the other using this property.

00:30:41.180 --> 00:30:45.580
We value the department property
to be more compatible with other

00:30:45.580 --> 00:30:48.580
contact management applications.

00:30:50.660 --> 00:30:54.810
And we finally made available
the Person versus Company flag.

00:30:54.850 --> 00:30:59.240
I think it was one of the most
requested features in Jaguar.

00:30:59.540 --> 00:31:01.380
In Address Book,
you have this notion of a person

00:31:01.480 --> 00:31:03.560
can be a person or a company.

00:31:03.620 --> 00:31:06.080
And that was not available in Jaguar.

00:31:06.300 --> 00:31:09.390
We made that public in Panther,
so now you can decide if

00:31:09.390 --> 00:31:11.440
it's a person or a company.

00:31:11.490 --> 00:31:14.740
And also,
we made available the name ordering,

00:31:14.810 --> 00:31:18.780
which in Address Book application,
the user can-- for each card,

00:31:18.780 --> 00:31:22.140
they can decide if the name should be
first name first or last name first.

00:31:22.160 --> 00:31:25.880
And that was not also
available in the API in Jaguar.

00:31:25.940 --> 00:31:29.030
So there is a property
called KAB Person Flags,

00:31:29.030 --> 00:31:30.480
which is just an int.

00:31:30.510 --> 00:31:35.200
And we provide also all the mask
for you to be able to test if this

00:31:35.320 --> 00:31:38.210
card is a person or a company.

00:31:41.630 --> 00:31:44.780
Also, with AIANTS,
the notification that we are sending,

00:31:44.800 --> 00:31:46.780
in the Jaguar,
we're sending two notifications.

00:31:46.860 --> 00:31:48.760
One that says, the database has changed.

00:31:48.760 --> 00:31:50.820
It means your process
has changed the database.

00:31:50.820 --> 00:31:52.020
You've just changed the database.

00:31:52.020 --> 00:31:55.120
And there is another one called
database change externally,

00:31:55.490 --> 00:31:58.620
which means some other process
has changed the database.

00:31:58.620 --> 00:32:01.380
In the Jaguar,
we were just sending them and say, OK,

00:32:01.380 --> 00:32:02.880
go figure out what changed.

00:32:02.880 --> 00:32:05.240
We were not telling
you what was changing.

00:32:05.780 --> 00:32:08.160
In Panther,
now we were telling you what changed.

00:32:08.160 --> 00:32:13.060
And the info object that sends the
notification is now a dictionary,

00:32:13.060 --> 00:32:16.810
and it can contain three keys,
KAB inserted records,

00:32:16.840 --> 00:32:20.200
KAB updated records,
or KAB deleted records.

00:32:20.200 --> 00:32:24.120
And each one of these keys has
an array associated with it,

00:32:24.120 --> 00:32:28.160
which contains a unique ID of
the record that has changed.

00:32:28.160 --> 00:32:31.320
So, like that,
you can optimize your refresh.

00:32:31.320 --> 00:32:33.230
Before,
you basically had to refresh everything

00:32:33.340 --> 00:32:35.060
because you didn't know what had changed.

00:32:35.160 --> 00:32:36.810
Now,
you can tell if what you're displaying

00:32:36.810 --> 00:32:38.160
on the screen has changed or not.

00:32:38.220 --> 00:32:41.950
We may send you,
in a case where everything changed,

00:32:41.950 --> 00:32:45.420
for example,
the user reversed from backup.

00:32:45.420 --> 00:32:47.490
We have this backup mechanism
in the address book.

00:32:47.640 --> 00:32:50.540
If the user reversed from backup,
basically everything changed.

00:32:50.540 --> 00:32:53.520
So, in this case,
the info object will be nil.

00:32:53.520 --> 00:32:55.600
So, if it's nil,
it means everything changed.

00:32:55.600 --> 00:32:57.870
So, do like we were doing in Jaguar.

00:33:00.830 --> 00:33:04.460
We also give you now a way to figure
out what a unique ID is pointing to.

00:33:04.460 --> 00:33:08.220
So you have this method called
recallClass from unique ID.

00:33:08.450 --> 00:33:11.740
Given the unique ID as inside
the class of the object.

00:33:11.790 --> 00:33:14.940
So this method allows you
to retrieve the class.

00:33:14.940 --> 00:33:18.860
So we can either say it's
an AB person or an AB group.

00:33:18.970 --> 00:33:21.740
This is very useful for the
notification I was talking before,

00:33:21.740 --> 00:33:25.780
because in the case of deleted records,
we send you an ID,

00:33:25.780 --> 00:33:27.900
but this ID doesn't point
to anything anymore.

00:33:27.980 --> 00:33:29.570
So if you want to know
if it was a record,

00:33:29.570 --> 00:33:32.880
a person, or a group that was deleted,
you can use this method to

00:33:32.880 --> 00:33:35.570
figure out what was deleted.

00:33:38.660 --> 00:33:42.290
We also now expose some of
the preferences that are in

00:33:42.290 --> 00:33:44.460
the Address Book application.

00:33:44.730 --> 00:33:46.210
If you go to the Address
Book application,

00:33:46.220 --> 00:33:53.870
the user can decide what the country
to use to format street addresses.

00:33:53.980 --> 00:33:59.990
We have a method now that we can
tell you what was the user setting,

00:33:59.990 --> 00:34:05.830
and we return you an ISO country code,
US, FR, UK, so you can know which

00:34:06.390 --> 00:34:07.880
country the user is in.

00:34:11.000 --> 00:34:14.140
By the way, we use this country code to
format the address differently

00:34:14.140 --> 00:34:16.080
depending on the country code.

00:34:16.210 --> 00:34:19.600
The order of the fields are
different when you format it.

00:34:19.890 --> 00:34:21.560
You have the same thing
for name ordering.

00:34:21.600 --> 00:34:26.040
The user can decide globally for
his address book if he wants first

00:34:26.040 --> 00:34:27.920
name first or last name first.

00:34:28.180 --> 00:34:33.110
So now you can figure out that
using the default name ordering API.

00:34:34.720 --> 00:34:39.780
Finally, we have this formatted
address from dictionary.

00:34:39.860 --> 00:34:43.870
So remember, an address is represented as
a dictionary in Address Book.

00:34:43.960 --> 00:34:46.050
So if you pass one of those
dictionaries to this method,

00:34:46.230 --> 00:34:49.680
we're going to return you a string
that's formatted correctly depending

00:34:50.100 --> 00:34:52.460
on the country code of this address.

00:34:52.740 --> 00:34:55.600
And this string can be
printed on a label as is.

00:34:55.890 --> 00:34:57.660
So we do all the formatting for you.

00:34:57.720 --> 00:35:00.580
We go even farther.

00:35:00.640 --> 00:35:02.320
Notice that we don't return a string.

00:35:02.320 --> 00:35:03.600
We return an attributed string.

00:35:03.600 --> 00:35:08.820
So we use attribute to embed inside
the string where are each field.

00:35:08.820 --> 00:35:11.610
So we put the key-- the
key of the attribute is a

00:35:11.610 --> 00:35:13.300
key we use in a dictionary.

00:35:13.300 --> 00:35:16.590
So for example, zip code, street one,
city.

00:35:16.990 --> 00:35:21.030
And we also embed in there the
localized description of the field,

00:35:21.160 --> 00:35:23.720
code postal for
France instead of zip code.

00:35:23.810 --> 00:35:26.050
So we put all this
information into this string.

00:35:26.130 --> 00:35:28.280
If you don't care,
you can just print it as a string.

00:35:28.360 --> 00:35:32.190
But if you want to format it differently,
put the zip code in bold,

00:35:32.540 --> 00:35:36.460
you can parse this attributed
string and find exactly where

00:35:36.460 --> 00:35:38.790
is the zip code in this string.

00:35:41.690 --> 00:35:44.100
Enhanced AppleScript support.

00:35:44.260 --> 00:35:48.480
So we've also enhanced AppleScript,
as I was mentioning.

00:35:48.540 --> 00:35:50.840
So now we have much better
parity with Objective-C and

00:35:50.840 --> 00:35:53.050
CPI that we had in Jaguar.

00:35:53.120 --> 00:35:56.370
We have support for all the new
properties we've introduced in Panther.

00:35:56.530 --> 00:35:59.250
And now you can do things in
AppleScript you could not do in Jaguar.

00:35:59.260 --> 00:36:03.220
For example, get and set the MiCard,
get and set the company flag,

00:36:03.240 --> 00:36:04.780
a person is a company or a person.

00:36:04.960 --> 00:36:09.600
Get and set the image for this person,
and also have access to

00:36:09.600 --> 00:36:13.300
the Address Book selection,
so you can see exactly what's selected

00:36:13.300 --> 00:36:14.840
in the Address Book application.

00:36:14.870 --> 00:36:18.590
And we can also export
vCard using AppleScript.

00:36:20.080 --> 00:36:23.160
We've added an AppleScript menu
to the Address Book application.

00:36:23.160 --> 00:36:25.980
So if you write script,
now the user can put their script in

00:36:25.980 --> 00:36:31.510
their library Address Book script,
and they will show up in this menu.

00:36:33.570 --> 00:36:36.410
And let's move on to the People Picker.

00:36:36.580 --> 00:36:41.620
So the People Picker is something we made
available internally at Apple in Jaguar.

00:36:41.620 --> 00:36:44.120
And it was used by
Mail and iChat and iCal.

00:36:44.120 --> 00:36:47.550
The People Picker is basically a
read-only version of the Address Book.

00:36:47.800 --> 00:36:51.280
It's a smaller version
of the Address Book.

00:36:51.280 --> 00:36:54.000
What's very interesting with
the People Picker is that it

00:36:54.000 --> 00:36:57.970
provides a consistent UI for
people to pick people or groups,

00:36:57.970 --> 00:37:01.600
like the same way we have a
phone chooser or a color picker.

00:37:01.800 --> 00:37:05.650
And so we decided to make that public
in Panther so your application doesn't

00:37:05.750 --> 00:37:10.510
have to reinvent the wheel and can
just use this UI very quickly and

00:37:10.510 --> 00:37:12.920
integrate it into your application.

00:37:13.830 --> 00:37:16.730
So the People Picker,
this is the email People Picker.

00:37:17.030 --> 00:37:18.860
The UI,
the look hasn't changed from Jaguar.

00:37:18.860 --> 00:37:20.520
It's the same look.

00:37:20.570 --> 00:37:23.460
And there are several
areas in the People Picker.

00:37:23.460 --> 00:37:25.340
There is a group column,
similar to the group

00:37:25.410 --> 00:37:27.400
column in Address Book.

00:37:27.730 --> 00:37:30.650
We have the name column,
which lists all the people that are in a

00:37:30.650 --> 00:37:33.500
group that's selected in a group column.

00:37:33.540 --> 00:37:37.430
We have the value column,
which in this case only has one property,

00:37:37.430 --> 00:37:38.180
which is the email.

00:37:38.180 --> 00:37:41.210
But you can have multiple
one if you decide to.

00:37:41.420 --> 00:37:44.500
We have the search field that
works exactly like in Address Book.

00:37:44.560 --> 00:37:50.580
So people can use it to search and
limit the number of displayed people.

00:37:50.580 --> 00:37:52.880
And for Koku only,
we have an auxiliary view

00:37:52.880 --> 00:37:55.520
where you can add your own
control to the People Picker.

00:37:55.520 --> 00:38:01.430
Mail adds a To and CC button,
but you can add your own

00:38:01.510 --> 00:38:03.630
controls there if you want.

00:38:04.600 --> 00:38:06.870
People Picker is available
for Carbon and Cocoa.

00:38:07.060 --> 00:38:10.060
For Carbon,
the People Picker is a window.

00:38:10.100 --> 00:38:14.180
And the header is in abpeoplepickerc.h.

00:38:14.230 --> 00:38:18.240
And it's a view for Cocoa,
so you can put it in any window you want.

00:38:18.280 --> 00:38:23.220
And also, for Cocoa Developer,
we've also built an interface

00:38:23.220 --> 00:38:26.270
builder palette to be able
to use the People Picker.

00:38:26.520 --> 00:38:28.530
The palette is not
automatically loaded in IB.

00:38:28.660 --> 00:38:31.620
You have to load it manually
using the preference.

00:38:31.690 --> 00:38:34.420
But it's in Developer Extra Palettes.

00:38:34.460 --> 00:38:37.100
And I'm going to show you that right now.

00:38:37.220 --> 00:38:39.570
Can I have the demo one?

00:38:42.480 --> 00:38:45.420
So I'm launching Interface Builder.

00:38:45.430 --> 00:38:50.520
And I'm going to create an
empty nib and drag a panel.

00:38:52.040 --> 00:38:57.410
I'm going to make my panel,
I'm going to call it People Picker,

00:38:57.410 --> 00:38:59.170
and I want it to be pre-sizeable.

00:38:59.180 --> 00:39:02.960
So now I have this palette here,
which is the People Picker.

00:39:02.960 --> 00:39:04.200
I can drag it in.

00:39:10.640 --> 00:39:14.240
I'm going to set the spring and
strut so it resets correctly.

00:39:14.280 --> 00:39:16.540
And I can go to the Attribute Inspector.

00:39:16.610 --> 00:39:19.060
So here I can set up my
People Picker the way I want.

00:39:19.110 --> 00:39:21.400
So I want to allow multiple selection.

00:39:21.440 --> 00:39:24.190
And I want to have
multiple value selections,

00:39:24.260 --> 00:39:26.960
so I can select multiple
emails or whatever.

00:39:26.990 --> 00:39:31.560
And I can add-- I want to display email,
phone.

00:39:31.730 --> 00:39:34.150
And I'm happy with that.

00:39:34.390 --> 00:39:39.410
I can test my interface and
I have a beautiful People Picker.

00:39:45.120 --> 00:39:47.560
And it works the way you expect.

00:39:47.640 --> 00:39:51.200
You can search.

00:39:51.600 --> 00:39:53.210
You can search and everything,
and it really works.

00:39:53.340 --> 00:39:57.490
Basically,
the Address Book in one little view.

00:39:57.680 --> 00:40:01.440
For Carbon,
you're going to get the same thing,

00:40:01.480 --> 00:40:05.960
except it's going to be a window instead
of being a view you can put anywhere.

00:40:08.380 --> 00:40:11.530
So let's go back to the slides.

00:40:11.890 --> 00:40:19.370
So the People Picker APIs are
grouped in four groups.

00:40:19.880 --> 00:40:23.400
APIs dealing with the
behavior of the People Picker,

00:40:23.400 --> 00:40:26.940
APIs dealing with the
value column content,

00:40:27.010 --> 00:40:30.310
APIs dealing with the selection,
and API dealing with the action,

00:40:30.310 --> 00:40:34.220
what happens when the user
double-clicks or things like that.

00:40:34.220 --> 00:40:38.990
So the behavior,
you can allow or not group selection.

00:40:39.340 --> 00:40:41.460
You may have an application
that only deals with groups.

00:40:41.500 --> 00:40:43.060
You don't want to deal with people.

00:40:43.080 --> 00:40:45.450
You don't want to be able, the user,
to select groups.

00:40:45.590 --> 00:40:48.460
So you can turn on that, saying,
I want to allow group selection.

00:40:48.460 --> 00:40:52.060
In this case,
you'll be able to only select groups.

00:40:52.070 --> 00:40:56.900
You may want also to allow or not
multiple selection of group or people.

00:40:56.900 --> 00:41:00.210
Depending on your application,
you may only allow one person

00:41:00.210 --> 00:41:01.410
to be selected and not two.

00:41:01.730 --> 00:41:05.160
So you can turn on and off multiple
selection of group or selection,

00:41:05.260 --> 00:41:07.220
or group of people or people.

00:41:07.230 --> 00:41:11.230
And for the value column,
you may not want selection there.

00:41:11.240 --> 00:41:14.680
You may decide that you're not really
interested by this column because,

00:41:14.800 --> 00:41:17.300
after all,
you only want to select a person,

00:41:17.320 --> 00:41:19.550
but you still want to be
able to display the email.

00:41:19.710 --> 00:41:23.680
So you don't want to select a
single value within the value.

00:41:23.730 --> 00:41:24.680
So you can say no.

00:41:24.680 --> 00:41:27.220
You can say,
I only want to select one value or

00:41:27.220 --> 00:41:30.600
multiple value at the same time.

00:41:30.600 --> 00:41:34.570
So you have a really full range
of possibilities regarding

00:41:34.570 --> 00:41:38.530
the selection with those APIs.

00:41:39.720 --> 00:41:42.050
You can also set up,
if you don't use IB or

00:41:42.050 --> 00:41:46.720
if you're using Carbon,
you can also set up the

00:41:46.720 --> 00:41:48.200
content of the value column.

00:41:48.200 --> 00:41:51.460
You can also not having a
value column if you decide to.

00:41:51.460 --> 00:41:54.900
If you just want to have
groups and people and no value,

00:41:54.900 --> 00:41:56.180
that's fine too.

00:41:56.180 --> 00:41:58.620
But also you can set what
value you want to be,

00:41:58.620 --> 00:42:01.920
what property you want to
display in your value column.

00:42:01.920 --> 00:42:04.760
You can choose as many as you want and
you're going to have a pop-up at the top

00:42:04.760 --> 00:42:06.290
and be able to switch back and forth.

00:42:06.820 --> 00:42:11.080
And so you can set which value you want
to be shown by default when the first

00:42:11.080 --> 00:42:14.280
time you launch your People Picker.

00:42:16.660 --> 00:42:19.100
You can also have access,
you can set and get the

00:42:19.100 --> 00:42:22.440
selection for the group,
for the person, for the people column,

00:42:22.440 --> 00:42:23.460
for the values.

00:42:23.600 --> 00:42:27.790
So you can get what's
selected in the current state.

00:42:28.330 --> 00:42:31.440
And also,
you can react to the user action.

00:42:31.460 --> 00:42:34.200
So for Cocoa,
we use a regular target action paradigm,

00:42:34.210 --> 00:42:36.680
so you can make connection
between the People Picker and

00:42:36.680 --> 00:42:38.560
the rest of your controllers.

00:42:38.580 --> 00:42:40.140
And also,
you're going to get notification

00:42:40.140 --> 00:42:43.960
when something is redrawn
or something gets selected,

00:42:43.980 --> 00:42:46.400
like you get for the table
view or things like that.

00:42:46.400 --> 00:42:50.810
The same kind of paradigm you're used to.

00:42:50.970 --> 00:42:53.090
For Carbon, we're using Carbon Events.

00:42:53.160 --> 00:42:56.820
So we have a suite of Carbon Events that
you can install handlers,

00:42:56.860 --> 00:43:00.390
and you're gonna call you
every time something happens.

00:43:02.410 --> 00:43:06.820
So now, I would like to bring
on the stage Scott Herz,

00:43:06.820 --> 00:43:10.680
who is going to be talking
about the new Action Plugins.

00:43:17.920 --> 00:43:19.900
Can we go back to the slides real quick?

00:43:19.900 --> 00:43:23.970
That would be me.

00:43:24.670 --> 00:43:26.600
That would also be me?

00:43:26.600 --> 00:43:28.600
Okay.

00:43:28.600 --> 00:43:31.490
So I want to talk a little
bit about our action plug-ins.

00:43:32.020 --> 00:43:34.590
Some of you may have seen kind
of what I'm talking about.

00:43:34.600 --> 00:43:37.600
If you go into the actual
Address Book application,

00:43:37.600 --> 00:43:40.580
you can see those little
rollover menu jobbies.

00:43:40.580 --> 00:43:42.580
And rather than... Oh,
that's what that's for.

00:43:42.610 --> 00:43:47.220
I'm supposed to be
showing you this stuff.

00:43:47.220 --> 00:43:48.590
That's what I'm supposed to be doing.

00:43:48.590 --> 00:43:48.590
Can we go back to the...

00:43:55.610 --> 00:43:58.280
All right,
this is much more entertaining.

00:43:58.470 --> 00:44:00.840
So we've got our card here.

00:44:00.890 --> 00:44:03.950
And these are the rollers I was
sort of telling you about.

00:44:03.970 --> 00:44:07.210
The user can move their mouse
over certain data elements,

00:44:07.210 --> 00:44:10.150
like homepages, emails, phones,
and things.

00:44:10.150 --> 00:44:13.590
And when they click, a menu will pop up.

00:44:13.660 --> 00:44:15.480
And before, that was just our menu.

00:44:15.480 --> 00:44:18.980
And now the point is that we want
this to be your menu as well.

00:44:18.980 --> 00:44:22.960
So I've made a little plug-in
here that's going to do a

00:44:23.000 --> 00:44:25.520
mnemonic for a phone number.

00:44:25.600 --> 00:44:29.080
And we can just sort
of cycle through them,

00:44:29.190 --> 00:44:30.040
pick the one that we want.

00:44:30.040 --> 00:44:33.240
I'll grab that one.

00:44:33.240 --> 00:44:36.110
And there's all sorts of other ones.

00:44:37.410 --> 00:44:40.540
So that's what we're going to
try to build here in a second.

00:44:40.600 --> 00:44:44.330
So can we switch back
to the slides for real?

00:44:50.970 --> 00:44:54.100
The reason we want to do this is
we've already doubled the number of

00:44:54.270 --> 00:44:56.330
plugins that we've added since Jaguar.

00:44:56.340 --> 00:45:01.070
And the fact that we came up with six or
so new ones and there's only two of us,

00:45:01.300 --> 00:45:03.110
three of us,
we figured you guys would be able to

00:45:03.200 --> 00:45:07.500
come up with all sorts of cool stuff,
especially in terms of things like

00:45:07.550 --> 00:45:10.610
SOAP and web services type things.

00:45:10.620 --> 00:45:14.400
A lot of those are really people-driven,
and so we think this is a really good

00:45:14.400 --> 00:45:16.480
way to get at some of those things.

00:45:16.480 --> 00:45:20.480
So plugins can be written
in all sorts of languages.

00:45:20.860 --> 00:45:24.580
Objective-C, C/C++, or AppleScript.

00:45:24.640 --> 00:45:30.410
The Objective-C ones are
going to be NSBundles,

00:45:30.520 --> 00:45:34.140
and the C/C++ ones are
going to be CFBundles.

00:45:34.140 --> 00:45:36.080
And then the AppleScripts,
they're just scripts.

00:45:36.140 --> 00:45:40.240
You go ahead and throw
those guys in -- I'm sorry,

00:45:40.240 --> 00:45:44.720
the headers you'll need to figure out how
to do the Objective-C and the C++ ones

00:45:44.720 --> 00:45:50.040
can be found in addressbook abactions.h
and addressbook abactions.c.h.

00:45:52.820 --> 00:45:55.880
So once you've made one of
these bundles or a script,

00:45:55.880 --> 00:45:59.790
you can put it in the usual search
paths if you want it available

00:45:59.940 --> 00:46:01.880
for everybody on the system.

00:46:01.880 --> 00:46:05.190
You can put it in
/library/addressbookplugins.

00:46:05.240 --> 00:46:09.020
If you only want-- it's a little unstable
or whatever and you're just testing it,

00:46:09.020 --> 00:46:13.300
you can put it in your home directory
until the library address book plugins.

00:46:14.550 --> 00:46:15.520
So how does this work?

00:46:15.660 --> 00:46:17.550
What's the process like?

00:46:17.760 --> 00:46:20.280
The first thing that's gonna happen
is Address Book has to be running,

00:46:20.350 --> 00:46:22.080
so Address Book is gonna launch.

00:46:22.100 --> 00:46:26.060
And what we're gonna do is we're gonna
go through all of those two source paths,

00:46:26.070 --> 00:46:28.620
and we're gonna try and come across,
try and find all the bundles

00:46:28.620 --> 00:46:29.800
that you've put in there.

00:46:29.810 --> 00:46:33.310
And we're gonna kind of

00:46:33.840 --> 00:46:36.610
iterate through them and we're
going to ask each one of them

00:46:36.640 --> 00:46:39.020
which property do you work with.

00:46:39.020 --> 00:46:42.020
You're going to return I work
with phone so return something

00:46:42.290 --> 00:46:43.810
like KAB phone property.

00:46:44.040 --> 00:46:46.070
We're going to remember that.

00:46:46.070 --> 00:46:50.200
At some point the user is going to
click on one of those rollovers.

00:46:50.200 --> 00:46:52.620
When they do we need to
start building that menu.

00:46:52.620 --> 00:46:56.940
We're going to go through the
plug-ins again that correspond to

00:46:56.940 --> 00:47:00.260
in this case let's say it's e-mails.

00:47:00.290 --> 00:47:05.220
We're going to say okay, plug-in,
what title do you want to be?

00:47:05.220 --> 00:47:10.190
You're going to say I want to be
Bob's cool e-mail plug-in or whatever.

00:47:10.310 --> 00:47:11.460
You'll return that.

00:47:11.460 --> 00:47:14.880
Then we'll ask you okay,
do you want to be enabled?

00:47:14.880 --> 00:47:17.260
We'll pass you some information
you'll see in a little bit.

00:47:17.260 --> 00:47:22.030
You can decide maybe for -- a good
example of where we do this in address

00:47:22.110 --> 00:47:27.630
book ourselves is if you roll over
an e-mail and it's an AOL.com e-mail,

00:47:27.630 --> 00:47:31.120
one of the plug-ins we
have is show AOL home page,

00:47:31.120 --> 00:47:35.820
so the actual text is show AOL home
page versus if it's a .mac it

00:47:35.820 --> 00:47:38.340
will say show .mac home page.

00:47:38.340 --> 00:47:40.680
You can tweak yourself there.

00:47:40.680 --> 00:47:44.630
Or if it's something you don't -- sorry,
if it's something you don't know you can

00:47:44.730 --> 00:47:49.810
say I'm not -- I don't know what I would
do for this case and you can return no.

00:47:51.270 --> 00:47:54.260
If they do finally click on you,
you can say,

00:47:54.260 --> 00:47:57.470
we'll call your perform action,
and then you can go do stuff.

00:47:57.960 --> 00:48:01.490
So here's the Objective-C API for it.

00:48:01.750 --> 00:48:03.970
It's pretty much just like I described.

00:48:05.180 --> 00:48:06.980
We'll call you,
we'll call your action property.

00:48:06.980 --> 00:48:09.100
You'll return the property
that you're interested.

00:48:09.100 --> 00:48:11.660
These are pretty much any of
the properties that you're

00:48:11.660 --> 00:48:13.920
going to find in abglobals.h.

00:48:14.280 --> 00:48:17.040
The limitation there being,
you've probably noticed in Address Book,

00:48:17.040 --> 00:48:19.620
we don't do roll-ins for
things like first name,

00:48:19.730 --> 00:48:21.660
last name,
some of those things up across the top.

00:48:21.660 --> 00:48:24.450
So we don't do roll-overs
for things like notes.

00:48:24.570 --> 00:48:26.800
Not to say that at some
point in the future we won't,

00:48:26.940 --> 00:48:28.680
but we just don't right now.

00:48:28.810 --> 00:48:30.820
So don't expect it.

00:48:31.260 --> 00:48:33.770
So here's the call that we're going
to call when we want your title.

00:48:34.040 --> 00:48:37.260
And we're going to pass you the
person of the currently selected card.

00:48:37.380 --> 00:48:39.740
And then we're going to
pass in an identifier.

00:48:39.840 --> 00:48:42.780
So what you can do is you can
pull out from that person using

00:48:43.160 --> 00:48:46.140
the identifier the exact item,
the exact data item that

00:48:46.140 --> 00:48:47.890
the user has rolled over.

00:48:50.920 --> 00:48:52.800
And once again,
if you want to be enabled,

00:48:52.800 --> 00:48:53.560
this is optional.

00:48:53.560 --> 00:48:56.610
If you don't implement this,
we just assume that you want

00:48:56.710 --> 00:48:58.270
to be enabled all the time.

00:48:58.410 --> 00:49:02.220
And so maybe your plugin only works
with Canadian addresses or something,

00:49:02.220 --> 00:49:03.900
and you can look in the
identifier and figure out,

00:49:03.900 --> 00:49:06.590
oh, this is a US address, and return no.

00:49:07.340 --> 00:49:13.640
And then, if the user,
if you're lucky enough and the

00:49:13.640 --> 00:49:19.930
user's actually chosen your item,
they'll go ahead and we'll

00:49:19.930 --> 00:49:19.930
call perform action for person,
passing all the same information again,

00:49:19.930 --> 00:49:19.930
and you can go, like in that case,
we put up our panel.

00:49:20.330 --> 00:49:22.200
do that kind of thing.

00:49:22.240 --> 00:49:24.040
So that was Objective-C.

00:49:24.250 --> 00:49:27.460
C plugins work pretty much the same way,
the exact same flow.

00:49:27.480 --> 00:49:30.100
The difference is that
every bundle that you make,

00:49:30.100 --> 00:49:33.500
you're gonna have a function
called AB_ActionRegisterCallbacks,

00:49:33.540 --> 00:49:35.920
and it's gonna return
a pointer to a struct.

00:49:35.950 --> 00:49:38.590
And this struct you're gonna
fill out with your own function

00:49:38.590 --> 00:49:40.280
pointers of these callbacks.

00:49:40.280 --> 00:49:44.260
So your property, your title,
your enabled if you want, if not,

00:49:44.380 --> 00:49:45.650
just put null in there.

00:49:45.990 --> 00:49:50.140
And then the function that you want us
to call when you're actually selected.

00:49:51.720 --> 00:49:54.650
So I'm not going to walk
through all of these,

00:49:54.650 --> 00:49:56.600
but this is the API there.

00:49:56.660 --> 00:50:01.200
Same thing, you're just returning
CFStringRefs instead of NSStrings.

00:50:01.290 --> 00:50:03.680
Very much the same kind of idea.

00:50:03.740 --> 00:50:06.720
So AppleScript's a little bit different,
but same process.

00:50:06.720 --> 00:50:09.960
We're just going to call your
different-- your handlers for

00:50:09.960 --> 00:50:11.080
trying to get your property.

00:50:11.080 --> 00:50:12.840
We're going to get you your title,
and we're going to give you--

00:50:12.840 --> 00:50:16.820
we're going to fill up a variable,
you know, a person and a value with the

00:50:16.820 --> 00:50:20.710
same kind of items that you saw
in the previous two examples.

00:50:22.450 --> 00:50:24.620
So that's all I have,
and I'm going to bring

00:50:24.620 --> 00:50:25.640
up John Geleynsse here.

00:50:25.640 --> 00:50:28.500
The evangelist,
so great they gave him two titles,

00:50:28.560 --> 00:50:29.500
it looks like.

00:50:32.460 --> 00:50:35.400
Hey, I want to thank you for not
rejecting Canadian addresses.

00:50:35.460 --> 00:50:38.280
Never Canadian, always Canadian.

00:50:41.830 --> 00:50:45.470
Right, so the conclusion sort of
is that Address Book is,

00:50:45.470 --> 00:50:49.500
the framework has been
adopted widely in Jaguar,

00:50:49.500 --> 00:50:52.540
and we think it's going to continue to be
adopted widely and hope that everybody in

00:50:52.540 --> 00:50:54.790
this room uses it in their application.

00:50:54.800 --> 00:50:55.850
I think it's going to deliver great.

00:50:55.910 --> 00:50:59.910
It'll make Panther that
much more consistent to use.

00:50:59.920 --> 00:51:04.540
And use the People Picker.

00:51:04.790 --> 00:51:05.820
Don't roll your own UI for that stuff.

00:51:07.020 --> 00:51:09.090
and, you know,
take advantage of the developer

00:51:09.090 --> 00:51:10.950
opportunity for the Action Plugins.

00:51:10.950 --> 00:51:14.010
More information,
basically go to the user experience

00:51:14.010 --> 00:51:18.130
portal on developer.apple.com and
click on the Address Book link.

00:51:18.180 --> 00:51:24.550
There's just,
there's tons of stuff there and there'll

00:51:24.550 --> 00:51:27.310
be even more specific to what we've
talked about at the conference here.

00:51:27.310 --> 00:51:27.310
And, uh...

00:51:27.700 --> 00:51:31.360
There's other sessions that we think
would be of interest to some of you.

00:51:31.360 --> 00:51:34.590
This stuff is pretty self-contained,
so most of the information you need

00:51:34.610 --> 00:51:36.310
is pretty much given in this session.

00:51:36.320 --> 00:51:39.550
But if you're new to Cocoa,
then check out some of the --

00:51:39.550 --> 00:51:46.010
if you're watching the DVD,
check out Introduction to Cocoa.

00:51:46.010 --> 00:51:48.360
If you're new to Carbon,
check out the How to Write a

00:51:48.360 --> 00:51:49.700
Modern Carbon app or whatever.

00:51:49.700 --> 00:51:52.830
There's other stuff that you want
to go to if you don't understand

00:51:53.260 --> 00:51:55.720
any of the code that's up here.

00:51:55.720 --> 00:51:56.680
And then send me feedback.

00:51:56.740 --> 00:51:59.780
If there's anything about this
API that's not meeting your needs

00:51:59.780 --> 00:52:02.720
or if there's something you'd
like to see added or anything

00:52:02.720 --> 00:52:06.000
from a developer's point of view,
please contact me and I'll

00:52:06.000 --> 00:52:07.000
get it through to the team.
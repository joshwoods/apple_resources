WEBVTT

00:00:22.590 --> 00:00:24.400
Good morning, everyone.

00:00:24.400 --> 00:00:27.140
Welcome to session 207,
Quartz 2D In-Depth.

00:00:27.140 --> 00:00:29.520
And in this session,
we're going to talk about our fully

00:00:29.520 --> 00:00:35.820
modern 2D drawing API that we created
when we brought Mac OS X into being.

00:00:35.820 --> 00:00:38.910
And it's important to realize that
we're an interesting position,

00:00:38.990 --> 00:00:41.720
because Mac OS X actually
has two drawing APIs that are

00:00:41.780 --> 00:00:43.320
typically used by developers.

00:00:43.320 --> 00:00:46.620
We have, obviously, Quartz 2D,
which is our new drawing API.

00:00:46.620 --> 00:00:50.240
We obviously have Quick Draw,
which is our legacy drawing API.

00:00:50.240 --> 00:00:52.600
And one thing I think that's
important to understand is where

00:00:52.730 --> 00:00:54.280
we're investing our time and effort.

00:00:54.280 --> 00:00:55.810
And that's behind Quartz 2D.

00:00:55.820 --> 00:00:58.460
And as you're going to see
in today's presentation,

00:00:58.460 --> 00:01:02.200
we're adding lots of new features
into Quartz 2D to meet the future

00:01:02.200 --> 00:01:05.620
needs of what application developers,
such as yourselves, want.

00:01:05.620 --> 00:01:09.540
What's important to understand as you sit
and listen and take in this presentation,

00:01:09.610 --> 00:01:13.390
that your take home from WWC this
year with regards to 2D graphics is

00:01:13.530 --> 00:01:17.160
to start thinking about if you have
a product that leverages Quick Draw,

00:01:17.220 --> 00:01:22.240
to come up with a strategy on how you can
move your product over to use Quartz 2D.

00:01:22.280 --> 00:01:25.200
Because that's really where
our focus is on the operating

00:01:25.260 --> 00:01:27.620
system in terms of 2D graphics.

00:01:27.660 --> 00:01:30.920
So at this point,
I'd like to invite Derek Clegg,

00:01:30.920 --> 00:01:33.320
a graphics imaging engineer,
to the stage to take

00:01:33.320 --> 00:01:35.010
you through the session.

00:01:36.420 --> 00:01:38.420
Good morning.

00:01:38.430 --> 00:01:40.140
Welcome to WWDC Day 4.

00:01:40.140 --> 00:01:42.350
I hope you're enjoying the conference.

00:01:42.500 --> 00:01:44.070
My name is Derek Clegg.

00:01:44.070 --> 00:01:48.550
I work in the Quartz
Engineering Technologies Group.

00:01:50.560 --> 00:01:54.380
Today I'm going to talk about Quartz,
what it is,

00:01:54.430 --> 00:01:57.060
sort of a rough overview of what it is,
a little bit about the

00:01:57.060 --> 00:01:57.850
Quartz architecture.

00:01:57.940 --> 00:02:00.400
I'm going to focus most of
the time on the Quartz APIs,

00:02:00.400 --> 00:02:02.720
particularly some of the
things we've added for Panther,

00:02:02.870 --> 00:02:05.750
and along the way I'm
going to have a few demos.

00:02:06.370 --> 00:02:09.600
So I'm going to briefly
cover what Quartz is.

00:02:09.630 --> 00:02:12.960
Those of you who have been to
previous WWDCs have probably

00:02:12.960 --> 00:02:14.390
seen some of this material.

00:02:14.510 --> 00:02:17.080
Quartz is our Mac OS X, that is,
imaging model,

00:02:17.140 --> 00:02:22.620
the way we get from the things
you want to draw onto the screen.

00:02:22.630 --> 00:02:25.800
It's been influenced by a couple of
very powerful industry standards,

00:02:25.840 --> 00:02:27.250
such as PostScript and PDF, of course.

00:02:27.260 --> 00:02:30.120
That's a pretty fundamental
piece of Quartz 2D.

00:02:30.120 --> 00:02:33.130
We also, of course, have adopted parts of
QuickDraw and parts of Java 2D.

00:02:33.280 --> 00:02:35.860
And we really think of it as the
next generation imaging model for

00:02:35.860 --> 00:02:38.480
your next generation applications.

00:02:38.530 --> 00:02:41.530
So the key thing to keep in mind,
as Travis mentioned,

00:02:41.560 --> 00:02:45.230
is that here's a graph that
we think is very important.

00:02:45.500 --> 00:02:47.620
On the y-axis is innovation.

00:02:47.690 --> 00:02:49.760
And as you see,
we're really putting a lot of

00:02:49.760 --> 00:02:52.380
energy into innovating in Quartz 2D.

00:02:52.400 --> 00:02:56.400
QuickDraw,
it's not a flat ramp or a negative

00:02:56.400 --> 00:02:57.330
ramp or anything like that.

00:02:57.490 --> 00:03:00.300
But you can tell that we're really
focusing a lot of energy on Quartz 2D.

00:03:00.300 --> 00:03:05.200
We're really letting QuickDraw,
in terms of innovation at any rate--

00:03:05.280 --> 00:03:07.190
follow as far along as Quartz 2D is.

00:03:07.200 --> 00:03:09.670
With Quartz 2D, we're really pushing
everything we can there,

00:03:09.670 --> 00:03:11.510
as you've seen in other talks.

00:03:11.600 --> 00:03:13.420
We're adding support for OpenGL.

00:03:13.420 --> 00:03:15.070
We're adding all sorts
of interesting things,

00:03:15.110 --> 00:03:17.270
some of which I'll touch on today.

00:03:18.140 --> 00:03:23.350
So the thing, what Quartz 2D is,
sometimes it's also called Core Graphics.

00:03:23.350 --> 00:03:24.800
I'll use both terms interchangeably.

00:03:24.800 --> 00:03:27.450
Core Graphics is a slightly older name,
but the APIs and so on live in

00:03:27.450 --> 00:03:28.770
the Core Graphics framework.

00:03:28.800 --> 00:03:32.450
Quartz 2D is a low-level,
lightweight 2D rendering library.

00:03:32.450 --> 00:03:35.560
What that means is it's low-level,
it's just C functions,

00:03:35.560 --> 00:03:38.240
not a lot of complicated
C++ goop or anything else,

00:03:38.240 --> 00:03:40.720
very simple, low-level C functions.

00:03:40.720 --> 00:03:43.270
It's lightweight,
there's not a lot of API that you have

00:03:43.270 --> 00:03:46.420
to learn to do very complicated things,
it's pretty easy to use.

00:03:48.230 --> 00:03:55.100
The 2D API is built up front as a
resolution and device independent API.

00:03:55.100 --> 00:03:57.970
So what that means is resolution
independent means if you're

00:03:58.110 --> 00:04:01.650
going to a 72 DPI screen,
96 DPI screen, or a 300 DPI printer,

00:04:01.650 --> 00:04:05.300
1400 DPI printer, you use the same APIs,
you make the same calls,

00:04:05.420 --> 00:04:07.960
you do exactly the same thing,
but your output comes out

00:04:07.960 --> 00:04:09.380
beautiful in both cases.

00:04:09.380 --> 00:04:12.950
It's device independent,
same sort of sense, going to the screen,

00:04:12.950 --> 00:04:16.100
going to your printer, same API calls,
same work you do,

00:04:16.100 --> 00:04:17.980
but the output comes out
appropriately on the two devices.

00:04:17.980 --> 00:04:20.000
So you can use it for different devices.

00:04:20.000 --> 00:04:21.880
Of course, we want to have really
high-quality fonts,

00:04:21.930 --> 00:04:24.090
so we use Apple type services
to do all our font management,

00:04:24.100 --> 00:04:28.290
and we want color independence,
high-quality, high-fidelity color,

00:04:28.290 --> 00:04:31.210
and so we use ColorSync
for color management.

00:04:32.140 --> 00:04:35.820
So some people have asked in
the past who uses Quartz 2D.

00:04:35.820 --> 00:04:39.570
Of course, Carbon, Cocoa, and Java,
all our implementations inside

00:04:39.570 --> 00:04:42.260
Mac OS X rely very heavily on Quartz 2D.

00:04:42.260 --> 00:04:44.040
And some of them, for example,
in the Cocoa case,

00:04:44.040 --> 00:04:46.300
is pretty much implemented
entirely on top of Quartz 2D.

00:04:46.300 --> 00:04:49.240
So it's actually the underlying
framework for everybody.

00:04:50.780 --> 00:04:53.080
Many Apple applications not
only use it indirectly through

00:04:53.080 --> 00:04:55.750
their use of Carbon and Cocoa,
but often will do direct

00:04:55.750 --> 00:04:57.980
API calls into the Quartz 2D API.

00:04:57.980 --> 00:05:01.360
For example, Safari does an awful lot of
stuff with Quartz 2D APIs.

00:05:01.360 --> 00:05:04.020
That's one of the reasons
it's so fast and powerful.

00:05:04.020 --> 00:05:06.920
All our iApps, one way or another,
tend to use Quartz 2D,

00:05:06.930 --> 00:05:09.390
sometimes directly,
sometimes indirectly just

00:05:09.390 --> 00:05:12.500
through Cocoa or Carbon,
but they leverage that very heavily,

00:05:12.510 --> 00:05:16.580
particularly things like iPhoto, iDVD,
those types of applications.

00:05:16.580 --> 00:05:19.320
Keynote, for those of you who
saw the talk on Tuesday,

00:05:19.320 --> 00:05:20.560
uses Quartz 2D.

00:05:20.580 --> 00:05:25.490
And of course,
third-party applications use

00:05:25.650 --> 00:05:33.440
Quartz 2D very frequently to do
interesting effects or techniques.

00:05:33.440 --> 00:05:40.070
Mathematica, Microsoft Office, of course,
DeltaGraph,

00:05:40.070 --> 00:05:44.200
and your application can as well.

00:05:44.200 --> 00:05:46.270
And for those of you who
saw Peter's talk on Tuesday,

00:05:46.270 --> 00:05:48.830
your application might want to
consider Quartz 2D before your

00:05:48.830 --> 00:05:50.420
competitor's application does.

00:05:50.780 --> 00:05:51.900
Thank you.

00:05:52.890 --> 00:05:57.380
So the general thing about Quartz,
the whole architecture of Quartz,

00:05:57.440 --> 00:05:59.400
is Quartz 2D,
which is the APIs you talked to,

00:05:59.400 --> 00:06:02.170
underneath that on a lower
level is Quartz Compositor.

00:06:02.180 --> 00:06:04.030
So it's really sort of two pieces.

00:06:04.040 --> 00:06:06.660
Quartz Compositor is the part
that handles all the window

00:06:06.670 --> 00:06:09.550
management that sort of says,
oh, okay, I want to take these multiple

00:06:09.620 --> 00:06:11.040
windows and put them on the screen.

00:06:11.040 --> 00:06:13.360
It's the thing that does
all the expose cool stuff,

00:06:13.420 --> 00:06:16.340
thing that sort of makes your
terminal window 20% alpha,

00:06:16.340 --> 00:06:18.640
for example,
and composites under the background so

00:06:18.640 --> 00:06:20.140
you see things through it and so on.

00:06:20.160 --> 00:06:22.580
I'm not going to really
focus on that too much.

00:06:22.800 --> 00:06:24.480
In fact,
I'm not going to focus on it at all.

00:06:24.480 --> 00:06:27.370
There's a session tomorrow, session 211,
which we'll go into that in more detail,

00:06:27.370 --> 00:06:30.220
so you might want to check into that if
you're interested in Quartz Compositor,

00:06:30.220 --> 00:06:32.520
sort of the window management
part of the system.

00:06:34.900 --> 00:06:36.640
So again, what do we have in Quartz 2D?

00:06:36.640 --> 00:06:38.830
Well, the things I've already mentioned,
device resolution, independence,

00:06:38.830 --> 00:06:39.220
and so on.

00:06:39.220 --> 00:06:42.560
Of course, we also have very high
quality 2D graphics.

00:06:42.560 --> 00:06:45.340
All the anti-aliased rendering,
both line art and text is

00:06:45.340 --> 00:06:47.170
anti-aliased at very high quality.

00:06:47.170 --> 00:06:49.710
All the special effects such
as LCD text rendering and

00:06:49.760 --> 00:06:51.320
so on for your LCD displays.

00:06:51.320 --> 00:06:54.430
Transparency, of course,
is a big part of our feature set.

00:06:56.340 --> 00:06:59.370
Off-screen rendering,
so you can create a bitmap off-screen,

00:06:59.370 --> 00:07:02.760
draw into it using exactly the same APIs,
get the same beautiful effects,

00:07:02.760 --> 00:07:05.400
and then composite the result
either to your screen or maybe

00:07:05.400 --> 00:07:08.230
write it out as a PDF file,
I mean, as some sort of TIFF file or

00:07:08.240 --> 00:07:10.070
JPEG file or something like that.

00:07:10.110 --> 00:07:13.220
And then we also have
support for PDF document.

00:07:13.220 --> 00:07:15.910
As Peter mentioned on
the talk on Tuesday,

00:07:15.910 --> 00:07:19.300
we really think of PDF as
our digital paper format.

00:07:19.300 --> 00:07:25.160
And to allow you to get the same
power that we see present in PDF,

00:07:25.160 --> 00:07:25.780
we allow you to get the same
power that we see present in PDF.

00:07:26.340 --> 00:07:29.030
You get access to the PDF document,
to render it on the screen

00:07:29.030 --> 00:07:31.840
or to some other destination,
and to create it directly.

00:07:34.190 --> 00:07:39.060
So, let's go over a little bit the
types that we have available

00:07:39.080 --> 00:07:41.720
in the Core Graphics API.

00:07:44.780 --> 00:07:49.480
Here's a set of the basic sort
of fundamental pieces of the

00:07:49.510 --> 00:07:52.370
Core Graphics API that we have
available for you to work with.

00:07:52.440 --> 00:07:54.740
Of course, the context,
the context is sort of the

00:07:55.080 --> 00:07:56.410
central switching point.

00:07:56.500 --> 00:07:59.880
Everything that gets drawn to the screen,
to a PDF file, whatever,

00:08:00.090 --> 00:08:02.020
goes through a context.

00:08:02.020 --> 00:08:05.440
And when you work with context,
you need to use various pieces,

00:08:05.440 --> 00:08:09.570
various other objects to talk to the
context to get things done for you.

00:08:09.670 --> 00:08:11.240
So we have support for a path.

00:08:11.240 --> 00:08:13.710
A path is just a collection
of lines and curves.

00:08:13.710 --> 00:08:16.820
Fonts, of course, are important for text,
clearly.

00:08:16.840 --> 00:08:19.520
Images, as you know,
PDF documents are a native

00:08:19.580 --> 00:08:21.390
type in the Core Graphics API.

00:08:21.390 --> 00:08:24.190
Colors and color spaces, shading,
sort of gradients,

00:08:24.190 --> 00:08:27.900
you can think of them as
radial axial fills of regions.

00:08:27.900 --> 00:08:31.520
Patterns, repeated drawing operations.

00:08:31.680 --> 00:08:34.490
Geometry and affine transforms
for convenience to allow you to

00:08:34.490 --> 00:08:37.390
do arbitrary transformations,
rotations, and so on.

00:08:37.400 --> 00:08:38.990
And data managers,
those are the type we use

00:08:38.990 --> 00:08:45.930
in Core Graphics to get data
in and out of the program.

00:08:45.940 --> 00:08:45.940
So we can get into and out,
in from your program

00:08:45.940 --> 00:08:45.940
and out to your program.

00:08:47.310 --> 00:08:51.430
So, as I mentioned earlier,
I'm not going to go into a huge amount

00:08:51.430 --> 00:08:53.800
of depth in some of these various types.

00:08:53.800 --> 00:08:56.640
The session last year,
we covered all of these in detail.

00:08:56.640 --> 00:08:59.040
It's available on the DVD,
so I definitely recommend that you

00:08:59.040 --> 00:09:01.740
go check that out if you're not that
familiar with some of the details,

00:09:01.740 --> 00:09:03.560
some of the things I talked about today.

00:09:05.380 --> 00:09:07.760
So let's look at the CG context.

00:09:07.780 --> 00:09:11.580
A CG context is sort of, as I said,
the switching point.

00:09:11.640 --> 00:09:16.300
So your application's up here,
the purple oval, and it's going to call

00:09:16.300 --> 00:09:18.420
into the Core Graphics API,
either directly just

00:09:18.420 --> 00:09:20.480
by calling CG context,
blah, blah, blah,

00:09:20.580 --> 00:09:24.800
or indirectly by calling a
Cocoa or Carbon or Java function.

00:09:24.800 --> 00:09:28.620
And the Core Graphics API will then
take what call you've made and switch

00:09:28.620 --> 00:09:32.040
it out to the appropriate destination
that you might be drawing to.

00:09:32.040 --> 00:09:33.610
So you might have a window context,
in which case all your

00:09:33.610 --> 00:09:34.650
drawing will go to the screen.

00:09:34.650 --> 00:09:36.860
You might have a PostScript context,
in which case all of your drawing

00:09:36.860 --> 00:09:40.430
will go to a PostScript file,
PDF to a PDF document, or bitmap,

00:09:40.430 --> 00:09:41.960
an off-screen bitmap.

00:09:42.040 --> 00:09:46.160
So the context is sort of the fundamental
piece that we use to push data through

00:09:46.340 --> 00:09:51.080
the appropriate points so it comes out
to the destination that you care about.

00:09:52.380 --> 00:09:54.160
Now, in terms of drawing primitives,
as I mentioned,

00:09:54.160 --> 00:09:57.620
there's a number of auxiliary
objects that we support that you

00:09:57.670 --> 00:09:59.500
use to do drawing in a context.

00:09:59.500 --> 00:10:01.080
Paths is one example.

00:10:01.080 --> 00:10:02.250
Here are some texts.

00:10:02.250 --> 00:10:03.650
You can have fancy fonts.

00:10:03.690 --> 00:10:05.190
You can have rotated text.

00:10:05.220 --> 00:10:07.700
Images, of course,
pretty simple idea there.

00:10:07.700 --> 00:10:10.700
PDF pages,
pages from a PDF file that you can draw.

00:10:10.700 --> 00:10:13.720
Just like any other primitive,
you can draw it rotated, scaled,

00:10:13.780 --> 00:10:14.790
however you want.

00:10:14.790 --> 00:10:16.780
All the content will show up correctly.

00:10:17.880 --> 00:10:18.530
Patterns.

00:10:18.620 --> 00:10:20.840
Here you see an oval with
a bunch of stars in it,

00:10:20.910 --> 00:10:22.580
just a repeated set of stars.

00:10:22.580 --> 00:10:24.230
That's just obviously what a pattern is.

00:10:24.260 --> 00:10:27.300
Shadings, radial or axial shadings.

00:10:28.770 --> 00:10:33.030
This year in Panther we're adding
two new drawing primitives.

00:10:33.030 --> 00:10:35.240
One is shadows.

00:10:35.240 --> 00:10:38.020
Some of you have seen the
cool looking shadows inside

00:10:38.020 --> 00:10:40.700
Mac OS X in general in the Aqua UI.

00:10:40.700 --> 00:10:43.900
We've added a primitive inside
CG to let you do shadowed,

00:10:43.920 --> 00:10:46.690
support shadow drawing for any primitive.

00:10:46.740 --> 00:10:49.700
Whenever you draw anything,
if you want to, you can have it shadowed.

00:10:49.700 --> 00:10:52.660
So here you see on the left
a bunch of fancy circles and

00:10:52.850 --> 00:10:54.700
some sort of logo type design.

00:10:54.820 --> 00:11:00.520
And as you can see there's a shadow on
the lower left edge that is providing

00:11:00.700 --> 00:11:03.700
sort of a sense that this thing is
on top of the checkered background.

00:11:03.700 --> 00:11:05.650
An additional thing that
we've added as well,

00:11:05.650 --> 00:11:08.700
and I'm going to go into this a little
bit more in detail down the road.

00:11:08.850 --> 00:11:13.700
Another thing we've added for
Panther is transparency layers.

00:11:13.700 --> 00:11:19.700
And transparency layers is a
way to sort of temporarily,

00:11:19.930 --> 00:11:24.030
draw to another destination and then
have the whole entire result composited

00:11:24.030 --> 00:11:25.450
back with a particular effect.

00:11:25.710 --> 00:11:31.060
So in this case I might want
to get these nice circles all

00:11:31.060 --> 00:11:33.700
drawn with a nice transparency.

00:11:33.700 --> 00:11:36.290
And so I can sort of use a transparency
layer to draw the circles off

00:11:36.290 --> 00:11:39.060
screen and then when I composite
it back the entire result will

00:11:39.360 --> 00:11:41.700
be drawn in with a particular alpha.

00:11:41.700 --> 00:11:45.170
And I'm going to go into that in a
little bit more detail later as well.

00:11:45.510 --> 00:11:47.920
So now let's look at the types
that I talked about and talk

00:11:47.950 --> 00:11:49.720
about those a little bit more.

00:11:49.930 --> 00:11:51.740
Of course,
vector geometry is very important.

00:11:51.740 --> 00:11:53.250
That's what I was
talking about with paths.

00:11:53.250 --> 00:11:55.910
A path can be just a straight line.

00:11:55.910 --> 00:11:57.740
It can have a dash,
as you see on the left.

00:11:57.820 --> 00:11:59.890
A path can be a collection of curves.

00:11:59.910 --> 00:12:01.720
It doesn't have to be closed.

00:12:01.720 --> 00:12:04.450
If you want, it can be closed,
like the state of California there,

00:12:04.450 --> 00:12:05.850
as you see, is a closed path.

00:12:05.950 --> 00:12:09.500
And in addition, that's a filled path,
so paths can be either stroked or filled.

00:12:10.940 --> 00:12:12.880
Of course,
a path doesn't have to be stroked.

00:12:12.880 --> 00:12:14.240
It can just be simply filled.

00:12:14.240 --> 00:12:18.240
As you see on the bottom right,
you have a circle with the red circle,

00:12:18.240 --> 00:12:22.090
which actually consists of two paths,
an inside circle and an outside circle.

00:12:22.100 --> 00:12:24.300
And when you fill it,
you just get the interior part filled.

00:12:24.300 --> 00:12:26.960
And that brings up an interesting thing,
a question about filling.

00:12:26.960 --> 00:12:28.870
For those of you who know a
little bit about graphics,

00:12:28.870 --> 00:12:30.440
there's two different ways of filling.

00:12:30.440 --> 00:12:33.260
There's what's called even-odd
and winding-number fill.

00:12:33.260 --> 00:12:37.080
That's the illustration of the
star in the lower left corner.

00:12:37.080 --> 00:12:40.370
And core graphics supports
either flavor or fill operation.

00:12:40.940 --> 00:12:42.030
Okay.

00:12:42.460 --> 00:12:46.310
Another thing you can do with paths
that's very powerful is use them to clip.

00:12:46.310 --> 00:12:48.580
You can use them as a
vector geometry clip.

00:12:48.580 --> 00:12:52.000
So here you see on the left an arrow,
which we're going to use as just

00:12:52.000 --> 00:12:53.940
a path that we want to clip to.

00:12:53.940 --> 00:12:56.280
And when I say clip,
what that means is once you

00:12:56.280 --> 00:12:59.430
set that as a clipping region,
everything that's subsequently

00:12:59.540 --> 00:13:02.620
drawn is clipped through that
path and only shows up where that

00:13:02.800 --> 00:13:04.360
path would be normally filled.

00:13:04.360 --> 00:13:07.240
So here you see the arrow,
and we set that as a clipping region,

00:13:07.240 --> 00:13:10.520
and then we draw an image,
and what we have is only the part

00:13:10.520 --> 00:13:12.730
inside the arrow that's drawn.

00:13:12.740 --> 00:13:16.700
So this can be a very powerful technique
for complicated drawing operations,

00:13:16.700 --> 00:13:18.510
for simple drawing operations.

00:13:18.510 --> 00:13:21.740
It's very useful to use paths
as a clipping region like this.

00:13:30.380 --> 00:13:33.020
So in addition to paths, of course,
we have text.

00:13:33.280 --> 00:13:38.860
Text is a very important part of
any graphics API because most of the

00:13:38.920 --> 00:13:40.920
things that you draw tend to be text.

00:13:40.920 --> 00:13:43.970
We have support for all the font
flavors that Mac OS X supports.

00:13:44.060 --> 00:13:46.570
As you can see,
we can use pretty much any font

00:13:46.570 --> 00:13:49.300
that's available in the system.

00:13:49.300 --> 00:13:52.540
Text doesn't have to be just sort of
laid out vertically or horizontally.

00:13:52.590 --> 00:13:53.960
It can be rotated at an arbitrary angle.

00:13:53.960 --> 00:13:55.290
You have complete freedom over that.

00:13:55.300 --> 00:13:57.380
Of course, you get all the
high-quality anti-aliasing,

00:13:57.380 --> 00:13:59.240
so when you do rotate it,
it looks very beautiful.

00:13:59.240 --> 00:14:02.180
It doesn't look sort of bitmappy,
jaggy type.

00:14:02.190 --> 00:14:04.940
Text can be stroked or filled,
as you can see with the stroked

00:14:04.940 --> 00:14:08.040
text example where you have a
white border on the outside.

00:14:08.040 --> 00:14:11.610
And of course, you don't have to restrict
yourself just to Roman text.

00:14:11.670 --> 00:14:15.070
You can also have Chinese, Japanese,
Korean, any of those flavors.

00:14:16.950 --> 00:14:20.550
So the important thing to know about
the way the Quartz 2D API works,

00:14:20.580 --> 00:14:24.860
we're really, like I said before,
we're a low-level, lightweight thing.

00:14:24.860 --> 00:14:27.400
That means we don't
work on Unicode strings.

00:14:27.400 --> 00:14:31.360
Instead, we work on sort of the processed
Unicode strings after they go

00:14:31.370 --> 00:14:35.380
through ATSUI or the Cocoa text
rendering system to end up to Glyphs.

00:14:35.450 --> 00:14:38.150
The Glyph is just an index into
a font that tells you the path

00:14:38.230 --> 00:14:39.780
you use to draw the character.

00:14:39.780 --> 00:14:41.340
It's a very simple API.

00:14:41.340 --> 00:14:42.760
So we work at that level.

00:14:42.760 --> 00:14:44.640
We're not really a Unicode
text rendering engine.

00:14:44.640 --> 00:14:46.180
We're not a layout text rendering engine.

00:14:46.490 --> 00:14:48.410
All of that stuff you should
use either with Cocoa or

00:14:48.470 --> 00:14:49.860
ATSUI to get the right result.

00:14:49.860 --> 00:14:52.250
And in both cases,
there's ways to funnel all of

00:14:52.260 --> 00:14:53.880
your drawing down to Glyphs.

00:14:53.880 --> 00:14:56.240
And once you have Glyphs, then you could,
if you wanted to,

00:14:56.240 --> 00:14:59.220
you could use the Core Graphics API to
draw directly to the screen to a bitmap,

00:14:59.290 --> 00:14:59.980
whatever.

00:14:59.980 --> 00:15:01.980
Of course, they also have,
both ATSUI and Cocoa,

00:15:01.980 --> 00:15:04.960
have a way to draw directly to a context
without you having to get involved,

00:15:04.970 --> 00:15:06.260
which is very powerful.

00:15:06.260 --> 00:15:09.610
The good thing about Panther,
we've improved the text rendering,

00:15:09.620 --> 00:15:13.160
or the Glyph rendering, I should say,
at the Core Graphics level.

00:15:13.160 --> 00:15:14.840
In some cases, it's up to twice as fast.

00:15:14.840 --> 00:15:16.110
It was already pretty fast.

00:15:16.300 --> 00:15:19.490
So this is actually a
pretty significant speedup.

00:15:19.760 --> 00:15:23.030
And of course, as I mentioned before,
we support all the standard flavors,

00:15:23.040 --> 00:15:26.380
TrueType, Type 1, OpenType, CID,
which is for Chinese, Japanese,

00:15:26.450 --> 00:15:27.000
and Korean.

00:15:27.000 --> 00:15:30.290
All of those come through ATS,
and we use the ATS very heavily

00:15:30.290 --> 00:15:33.060
to get the glyph data out,
and then we go render it,

00:15:33.060 --> 00:15:36.270
and we put it to the destination
in a high-quality way.

00:15:38.210 --> 00:15:41.030
Of course, images as well are part
of the Core Graphics API.

00:15:41.040 --> 00:15:44.010
Here you see that images don't
have to be necessarily just

00:15:44.010 --> 00:15:46.300
rectangular blobs of data.

00:15:46.300 --> 00:15:47.370
They can be rotated.

00:15:47.490 --> 00:15:49.030
You can have a clipping
region associated with it.

00:15:49.120 --> 00:15:51.060
The image itself can
have a clipping region.

00:15:51.190 --> 00:15:53.830
You can sort of see the ticket has a
nice little notch cut out of its edge.

00:15:53.830 --> 00:15:59.280
So images can be used to do
lots of complicated drawing,

00:15:59.330 --> 00:16:03.630
and you don't have to restrict
yourself to just a straight

00:16:03.630 --> 00:16:03.630
rectangular region of data.

00:16:04.620 --> 00:16:08.670
So the, as I mentioned,
we have an alpha channel support so you

00:16:08.670 --> 00:16:11.800
have images that have some transparency,
some non-transparency.

00:16:11.800 --> 00:16:17.680
In Panther we have support for images
which have 1 to 32 bits per component.

00:16:17.680 --> 00:16:22.340
That means that each component of
your pixel can have up to 32 bits.

00:16:22.390 --> 00:16:25.420
So you can have a 32 bit red component,
a 32 bit green component,

00:16:25.490 --> 00:16:28.150
a 32 bit blue component for
a total of 96 bits per pixel.

00:16:28.240 --> 00:16:29.360
So that's very powerful.

00:16:29.360 --> 00:16:32.100
We think it's going to give us a
lot of headroom for a long time.

00:16:34.080 --> 00:16:37.800
Color space support, in other words,
the way the image data is interpreted,

00:16:37.800 --> 00:16:41.760
whether it be RGB or CMYK,
we support all the standard color spaces.

00:16:41.760 --> 00:16:45.290
So as I mentioned, red, green, blue,
cyan, magenta, yellow, black.

00:16:45.290 --> 00:16:48.980
Index color spaces such as what you
find with GIF images where each pixel

00:16:49.090 --> 00:16:51.220
is really an index into a color table.

00:16:51.220 --> 00:16:56.090
And of course, ICC profiles,
those are the way of doing color, sorry,

00:16:56.100 --> 00:16:58.900
device independent color management.

00:16:58.900 --> 00:17:02.260
We use ColorSync to allow
us to give us access to the

00:17:02.260 --> 00:17:03.660
ICC profiles and do a lot of work.

00:17:03.660 --> 00:17:10.750
We also support image mask
which range from 1 to 8 bits.

00:17:10.830 --> 00:17:13.560
An image mask is
effectively just a stencil.

00:17:13.560 --> 00:17:16.710
It's just a way of specifying
where you want paint or color

00:17:16.710 --> 00:17:18.600
to appear on the destination.

00:17:18.600 --> 00:17:20.560
And so you can think of it as a stencil.

00:17:20.560 --> 00:17:23.300
And in Panther we have support
for 1 to 8 bit image masks.

00:17:25.100 --> 00:19:09.200
[Transcript missing]

00:19:10.670 --> 00:19:15.230
So in addition to the standard image
support that we've had in the past,

00:19:15.230 --> 00:19:18.430
for this year, for Panther,
we're adding new API to

00:19:18.570 --> 00:19:22.780
QuickTime to give us access to
a lot of what QuickTime supports

00:19:22.780 --> 00:19:24.590
in terms of image formats.

00:19:24.680 --> 00:19:28.720
So the QuickTime guys have added
graciously some API to create a

00:19:28.810 --> 00:19:32.610
CG image ref directly from any graphics
importer that you might happen to have.

00:19:32.660 --> 00:19:36.170
And this means that any image format
that's supported by QuickTime can now

00:19:36.170 --> 00:19:38.080
be drawn directly into a CG context.

00:19:38.220 --> 00:19:40.710
You don't have to sort of go and
create a G world and do all the

00:19:40.840 --> 00:19:42.360
dance that you used to have to do.

00:19:42.360 --> 00:19:46.690
So that means we now support,
through this QuickTime API, JPEG 2000,

00:19:46.690 --> 00:19:50.960
GIF images, pretty much anything that
QuickTime supports is now supported

00:19:50.960 --> 00:19:53.620
in CG directly drawn into a context.

00:19:53.620 --> 00:19:55.970
And the important part
about it is that QuickTime,

00:19:55.970 --> 00:19:59.300
excuse me, the QuickTime API preserves as
much of the information of the

00:19:59.300 --> 00:20:01.060
original source image as it can.

00:20:01.060 --> 00:20:03.290
So if there was transparency
in the original source image,

00:20:03.290 --> 00:20:04.280
it will preserve that.

00:20:04.280 --> 00:20:06.380
If there's a color sync profile,
it will preserve that.

00:20:06.380 --> 00:20:08.140
Anything that makes sense to preserve.

00:20:08.270 --> 00:20:09.720
Through the Core Graphics API,
it will preserve.

00:20:09.720 --> 00:20:13.200
And the API itself is pretty trivial.

00:20:13.200 --> 00:20:14.640
It's a very nice, simple API.

00:20:14.640 --> 00:20:16.960
Graphics import creates CG image.

00:20:16.980 --> 00:20:19.920
You take a graphics importer
and hand it to this API,

00:20:19.920 --> 00:20:21.600
and out pops a CG image ref.

00:20:21.690 --> 00:20:24.310
And then you can use that just
as you would any other CG image

00:20:24.610 --> 00:20:28.360
ref to draw to any context,
to PDF, to PostScript, whatever you wish.

00:20:35.970 --> 00:20:40.270
Another thing that we can do with a
context is we can draw PDF documents.

00:20:40.270 --> 00:20:43.200
We can draw pages of a
PDF document into a context.

00:20:43.200 --> 00:20:51.480
We support importing of PDF 1.0, 1.1,
PDF 1.4 flavors of documents.

00:20:51.480 --> 00:20:55.710
One thing that's very useful is a lot
of times people want to create PDF.

00:20:55.780 --> 00:20:59.290
We also have API to allow you
to create PDF from the drawing.

00:20:59.400 --> 00:21:02.520
A PDF context lets you
do PDF document creation.

00:21:03.260 --> 00:21:07.340
When we create PDF content,
we always will export PDF 1.3,

00:21:07.440 --> 00:21:13.070
which means that it's more widely
supported on older Acrobat readers.

00:21:13.070 --> 00:21:15.400
If we need to,
if there are cases where we have to,

00:21:15.400 --> 00:21:17.320
we will bump it up to PDF 1.4.

00:21:17.320 --> 00:21:20.360
For example, if you use transparency,
that's only a PDF 1.4 feature.

00:21:20.360 --> 00:21:24.700
We try to keep the PDF document as widely
distributable as possible because we do

00:21:24.710 --> 00:21:27.450
think of it as something that's very,
as we said,

00:21:27.450 --> 00:21:29.270
the digital paper of Mac OS X.

00:21:30.620 --> 00:21:33.270
An important part about our
PDF document support is that we have

00:21:33.270 --> 00:21:34.830
full round tripping of the CG API.

00:21:34.860 --> 00:21:38.090
What that means is that if you
draw anything in Core Graphics

00:21:38.410 --> 00:21:42.120
and then to a PDF context,
what comes out is a PDF document that

00:21:42.120 --> 00:21:47.060
will view correctly in Preview and
in Acrobat exactly as you originally

00:21:47.060 --> 00:21:48.930
specified the drawing in the context.

00:21:48.940 --> 00:21:52.120
We get a full round tripping so
you don't lose any information

00:21:52.120 --> 00:21:53.790
when you draw to a PDF context.

00:21:53.800 --> 00:21:57.320
It will show up correctly as you
want it in Acrobat and Preview.

00:21:57.980 --> 00:22:00.170
For those of you who worry
about this sort of thing,

00:22:00.170 --> 00:22:04.830
we also have support for prepressed data
interchange via PDF X3 if you provide the

00:22:04.980 --> 00:22:09.400
right keys and additional dictionaries
when you create the PDF context.

00:22:10.260 --> 00:22:14.310
New this year for Panther, in addition,
in the past the API has

00:22:14.380 --> 00:22:16.280
been pretty monolithic.

00:22:16.280 --> 00:22:18.700
There's a PDF document and you have to do
a bunch of stuff with the PDF document.

00:22:18.700 --> 00:22:19.340
It's a little bit awkward.

00:22:19.340 --> 00:22:23.520
So we've added some convenience
APIs to do page-based access so

00:22:23.520 --> 00:22:25.280
you can get information directly.

00:22:25.280 --> 00:22:28.650
There's now a new type,
a CG PDF page ref,

00:22:28.700 --> 00:22:30.870
which you can work with.

00:22:30.910 --> 00:22:31.950
So it's a little bit more convenient.

00:22:31.960 --> 00:22:34.150
You get the standard
things such as media box,

00:22:34.160 --> 00:22:36.030
crop box, and so on from the PDF page.

00:22:36.100 --> 00:22:38.200
Things like the rotation
angle and the page number.

00:22:39.400 --> 00:22:42.460
And then what I think is
actually even more interesting,

00:22:42.460 --> 00:22:48.570
we have also decided to unlock
the inside of the PDF file.

00:22:48.580 --> 00:22:54.170
So we now have new API which will give
you access directly into the PDF document

00:22:54.170 --> 00:22:56.790
itself in more of its native form.

00:22:56.800 --> 00:23:00.020
And the idea,
for those of you who aren't familiar

00:23:00.020 --> 00:23:03.100
with the way PDF is structured,
you can sort of think

00:23:03.100 --> 00:23:04.210
about it as a big tree.

00:23:04.220 --> 00:23:06.770
And it's a big tree that starts
out with the very top with a

00:23:06.770 --> 00:23:08.340
root node called the catalog.

00:23:08.700 --> 00:23:10.700
And this catalog is a dictionary.

00:23:10.700 --> 00:23:13.570
And all the entries in the dictionary
are either more dictionaries

00:23:13.570 --> 00:23:16.910
or arrays or values of integers
and reals and stuff like that.

00:23:16.960 --> 00:23:18.180
So it's just this big tree structure.

00:23:18.180 --> 00:23:19.310
It's like a property list.

00:23:19.320 --> 00:23:25.340
So in order to mirror that structure,
we have new API -- or sorry,

00:23:25.340 --> 00:23:29.740
new types such as like CG PDF dictionary,
CG PDF array, and so on,

00:23:29.740 --> 00:23:33.110
which allow you to sort of model
the contents of the PDF file.

00:23:33.120 --> 00:23:36.330
We have new API for a
PDF document to get its catalog,

00:23:36.530 --> 00:23:38.000
sort of its root node.

00:23:38.000 --> 00:23:42.510
And we have new API to get the
dictionary directly from a page.

00:23:42.590 --> 00:23:44.650
A lot of times,
you don't necessarily care so much

00:23:44.650 --> 00:23:46.580
about the entire overarching structure.

00:23:46.580 --> 00:23:48.800
You just want to know,
does this page have a thumbnail

00:23:48.800 --> 00:23:51.110
or does this page have any
annotations and stuff like that?

00:23:51.240 --> 00:23:54.730
So those are the convenience
APIs that we have available.

00:23:55.290 --> 00:23:56.960
As you can see,
here's a very simple example

00:23:56.960 --> 00:23:58.180
of how to use this API.

00:23:58.210 --> 00:24:01.630
In this case, we are thinking, "Oh,
we'd like to get the thumbnail for

00:24:01.630 --> 00:24:04.670
this page." So we declare two types,
a dictionary and a stream.

00:24:04.680 --> 00:24:07.000
The stream is sort of the way
PDF represents an arbitrary

00:24:07.060 --> 00:24:08.470
collection of just data.

00:24:08.560 --> 00:24:11.240
In this case,
it's going to be image data.

00:24:11.240 --> 00:24:13.150
We get the dictionary for
the page that we care about,

00:24:13.150 --> 00:24:14.680
that we want to get the thumbnail from.

00:24:14.750 --> 00:24:17.760
And then that's just a dictionary
that we can look up values in.

00:24:17.880 --> 00:24:19.530
And here we're going to
look up the thumbnail.

00:24:19.540 --> 00:24:23.600
The key, the way the PDF specification
defines the thumbnail is via

00:24:23.600 --> 00:24:29.380
the key "thumb." So here we say,
"Does this dictionary have an entry

00:24:29.380 --> 00:24:34.450
called 'thumb' that's a stream for
the page dictionary?" And if it does,

00:24:34.450 --> 00:24:36.520
then we want to get the
data from the stream.

00:24:36.640 --> 00:24:38.990
And once we get the data,
then we may want to go off

00:24:38.990 --> 00:24:40.140
and draw that to the screen.

00:24:40.140 --> 00:24:43.040
We may want to pretend like we're
previewing and draw the little

00:24:43.040 --> 00:24:44.640
thumbnail in the drawer on the side.

00:24:44.950 --> 00:24:46.800
The format key just says, "Is it JPEG?

00:24:46.800 --> 00:24:50.440
Is it not JPEG?" Currently in Panther,
you have one flavor or the other.

00:24:50.560 --> 00:24:53.690
We do all of the decryption, decoding,
stuff like that for you,

00:24:53.770 --> 00:24:59.860
except in the case of JPEG,
where it doesn't make as much sense.

00:24:59.860 --> 00:25:01.370
So just a simple demo of this.

00:25:01.500 --> 00:25:04.700
I'll go over to the

00:25:11.400 --> 00:25:15.480
So here I have a very simple PDF file.

00:25:15.530 --> 00:25:19.920
It just has some text,
"Hello World" in Times Roman.

00:25:19.960 --> 00:25:22.940
And I'll take that to my

00:25:24.250 --> 00:25:25.670
PDF introspection app.

00:25:25.670 --> 00:25:28.650
This is actually about a
two hour worth of work.

00:25:28.710 --> 00:25:32.840
Most of it was figuring out what to
do in Cocoa to do the right thing.

00:25:32.840 --> 00:25:34.930
As you can see,
what I've done is all I'm doing is just

00:25:35.000 --> 00:25:38.410
displaying the contents of the PDF file,
sort of what it looks like when

00:25:38.410 --> 00:25:40.950
you actually open it up and look
at the real structure inside it.

00:25:41.010 --> 00:25:43.080
So here you see we're
at the top root node.

00:25:43.080 --> 00:25:43.960
We have the catalog.

00:25:43.960 --> 00:25:46.000
This is the dictionary for the catalog.

00:25:46.180 --> 00:25:47.960
And the root node has the pages.

00:25:48.040 --> 00:25:49.520
In this case, there's just one page.

00:25:49.520 --> 00:25:50.670
That's the count.

00:25:50.830 --> 00:25:54.790
Kids is the PDF way of talking
about each page in the document.

00:25:54.840 --> 00:25:55.990
So we can open it up.

00:25:55.990 --> 00:25:59.400
Kids is just an array,
obviously indexed by zero.

00:25:59.400 --> 00:26:01.600
And it has a dictionary in it,
which is the first page.

00:26:01.710 --> 00:26:06.060
So I can bring up my inspector,
which I have.

00:26:06.060 --> 00:26:08.030
And all of this is just
with public Panther API.

00:26:08.030 --> 00:26:10.690
None of this is special or
hidden or anything like that.

00:26:10.690 --> 00:26:12.820
It just allows you complete
access to the PDF file.

00:26:12.820 --> 00:26:18.630
Here you can see that the page has a
bunch of entries in it that are related

00:26:18.630 --> 00:26:20.640
to how the page gets drawn and so on.

00:26:20.640 --> 00:26:22.090
As you can see, here's the resources.

00:26:22.120 --> 00:26:23.550
The resources have some fonts.

00:26:23.610 --> 00:26:24.590
Here's the font.

00:26:24.590 --> 00:26:26.900
You can see, oh, look, it's Times Roman.

00:26:26.900 --> 00:26:28.800
So you say, oh, it's drawing Times Roman.

00:26:28.860 --> 00:26:29.160
Good.

00:26:29.270 --> 00:26:30.610
It's doing the right thing.

00:26:30.620 --> 00:26:35.520
And here's the contents of the actual
drawing operations for this PDF file.

00:26:35.520 --> 00:26:37.690
Basically, it's sort of like set
the font to 36 point.

00:26:37.710 --> 00:26:40.070
F1 means Times Roman in this case.

00:26:40.070 --> 00:26:42.620
Position it 1010 and draw Hello World.

00:26:42.820 --> 00:26:44.550
So it's a pretty trivial PDF file.

00:26:44.720 --> 00:26:47.610
But this--and this is
a pretty trivial app.

00:26:47.610 --> 00:26:51.050
But we think that this,
allowing developers to get access to the

00:26:51.050 --> 00:26:55.410
contents of the PDF and introspect in
interesting ways will be very powerful

00:26:55.410 --> 00:26:58.340
and provide a lot of interesting
application opportunities for you.

00:27:00.180 --> 00:27:05.850
Okay, let me quit that and
go back to the slides.

00:27:11.410 --> 00:27:12.400
Okay.

00:27:12.400 --> 00:27:14.740
So that's the,
we're still sort of trundling through

00:27:14.740 --> 00:27:16.590
the things you can do with a context.

00:27:16.620 --> 00:27:19.390
Another thing you can work with
a context is a color space.

00:27:19.480 --> 00:27:22.560
The color space type,
as I mentioned earlier,

00:27:22.560 --> 00:27:26.760
tells Core Graphics how
to interpret color data.

00:27:26.760 --> 00:27:29.510
So as I showed you
before with that profile,

00:27:29.590 --> 00:27:33.000
one of the profiles showed you that
was an example where the color space,

00:27:33.140 --> 00:27:34.700
the profile said,
oh the first component's red,

00:27:34.770 --> 00:27:36.510
the second one's green,
the third one's blue.

00:27:36.630 --> 00:27:39.120
Another one was a profile that said,
oh the first component's blue,

00:27:39.120 --> 00:27:41.320
the second one's green,
the third one's red.

00:27:41.400 --> 00:27:45.650
So color profiles are used
in order to provide data and

00:27:45.900 --> 00:27:48.860
interpretation of the color data.

00:27:48.860 --> 00:27:52.660
And a better example perhaps is a
profile for a camera which might say,

00:27:52.660 --> 00:27:55.120
oh here's how you tweak things
when you draw it so it looks

00:27:55.120 --> 00:27:57.680
the right way on your monitor.

00:27:57.700 --> 00:28:02.430
New for Panther,
we're adding two new convenience APIs.

00:28:02.430 --> 00:28:06.390
One is a way to get the
document default color space.

00:28:06.390 --> 00:28:09.070
A user, if they choose,
can set the way they want

00:28:09.070 --> 00:28:09.470
the document to look.

00:28:09.490 --> 00:28:09.600
So that's the first one.

00:28:09.600 --> 00:28:09.600
The second one is a profile that says,
oh here's how you tweak things

00:28:09.600 --> 00:28:09.600
when you draw it so it looks
the right way on your monitor.

00:28:09.600 --> 00:28:09.600
New for Panther,
we're adding two new convenience APIs.

00:28:09.600 --> 00:28:09.600
One is a way to get the
document default color space.

00:28:09.600 --> 00:28:09.600
A user, if they choose,
can set the way they want

00:28:09.600 --> 00:28:09.600
the document to look.

00:28:09.600 --> 00:28:12.710
document by default to
specify colors if in fact the

00:28:12.710 --> 00:28:14.810
document doesn't do it itself.

00:28:14.820 --> 00:28:17.860
There's no profile embedded.

00:28:17.860 --> 00:28:20.420
This is a convenience function
because it turned out in the past.

00:28:20.420 --> 00:28:22.250
This was actually difficult to get.

00:28:22.330 --> 00:28:24.140
It's information that's available.

00:28:24.160 --> 00:28:27.030
It used to be the ColorSync
Preferences Panel,

00:28:27.030 --> 00:28:29.520
now it's in the ColorSync Utility.

00:28:29.600 --> 00:28:33.500
It was a little bit more complicated
to get that information so now

00:28:33.500 --> 00:28:36.940
we have a simple way of getting
it directly through the CGAPI.

00:28:36.970 --> 00:28:42.620
We're also adding a new API to allow
you to get a display color space.

00:28:42.620 --> 00:28:45.070
A display color space is our term
for a color space which is very

00:28:45.090 --> 00:28:46.360
fast in drawing to the screen.

00:28:46.360 --> 00:28:47.560
There's no matching.

00:28:47.560 --> 00:28:51.220
What that means is there's no special
conversions that happen in order

00:28:51.220 --> 00:28:52.760
to draw something to the screen.

00:28:52.830 --> 00:28:54.820
As you specify it,
it's drawn to the screen.

00:28:54.820 --> 00:28:57.050
You get very fast drawing to the screen.

00:28:57.050 --> 00:29:00.670
It's very appropriate for something
like UI or something like that

00:29:00.680 --> 00:29:04.250
where the precise color that you
get on the screen may not be that

00:29:04.250 --> 00:29:06.610
critical relative to the color.

00:29:06.620 --> 00:29:07.380
It's very important to get the precise
color that you get on the screen.

00:29:07.380 --> 00:29:08.620
You don't want to have a
lot of color in the drawing.

00:29:08.620 --> 00:29:08.900
You want to have a lot of color
in the drawing to the time it

00:29:08.900 --> 00:29:09.610
might take to do the drawing.

00:29:09.620 --> 00:29:10.730
For example,
if you had a screen saver or something,

00:29:10.740 --> 00:29:12.750
you don't really care that
much about precise color but

00:29:12.860 --> 00:29:15.620
you just want it to be fast.

00:29:15.620 --> 00:29:18.510
The important thing too is that you
get a consistent profile any time

00:29:18.530 --> 00:29:20.340
you go to another output device.

00:29:20.340 --> 00:29:22.890
When you're printing, for example,
you get what's called in ColorSync

00:29:23.010 --> 00:29:25.630
products the generic profile.

00:29:25.720 --> 00:29:29.410
That is just some profile that's
been specified which means that from

00:29:29.480 --> 00:29:32.500
any device that you're printing,
you'll always get a consistent result.

00:29:32.500 --> 00:29:34.860
You won't get different results or crazy
results when you're printing to different

00:29:34.860 --> 00:29:36.290
types of printers and stuff like that.

00:29:36.360 --> 00:29:38.300
You'll always get a constant look.

00:29:38.300 --> 00:29:39.700
This is, I think,
something that will be very

00:29:39.700 --> 00:29:43.200
powerful for developers who
want to do fast screen drawing.

00:29:43.260 --> 00:29:45.600
If they do need to print,
if it does happen that they need to,

00:29:45.600 --> 00:29:48.900
they'll get a constant consistent
result on the output side.

00:29:48.900 --> 00:29:50.880
There's a lot more information,
much more than I can go

00:29:50.930 --> 00:29:54.080
into here in session 206,
the ColorSync update.

00:29:54.080 --> 00:29:55.910
If you're interested in
color management and so on,

00:29:55.970 --> 00:29:57.180
I recommend that you go to that.

00:30:02.550 --> 00:30:08.090
Another thing that we're adding this
year for Panther is a new primitive type,

00:30:08.130 --> 00:30:09.040
the CGColorRef.

00:30:09.120 --> 00:30:13.760
It turns out in the Jaguar APIs,
sometimes it was a little

00:30:13.760 --> 00:30:15.220
bit awkward to set colors.

00:30:15.220 --> 00:30:17.930
Well, not necessarily awkward,
but the API didn't actually match

00:30:17.930 --> 00:30:19.310
what was going on internally.

00:30:19.320 --> 00:30:22.470
Internally, we use a CGColorRef,
this primitive type,

00:30:22.600 --> 00:30:24.520
for all of our color management.

00:30:24.520 --> 00:30:27.070
And so all the API before,
you sort of had to specify

00:30:27.070 --> 00:30:29.700
in terms of components,
and we'd end up allocating ColorRef,

00:30:29.770 --> 00:30:30.890
and we'd do all this little dance.

00:30:31.360 --> 00:30:33.600
And the truth is,
what we ended up with internally

00:30:33.600 --> 00:30:34.830
always was CGColorRef.

00:30:34.900 --> 00:30:38.120
It's just a container that
holds both the color space,

00:30:38.120 --> 00:30:41.880
the way to interpret data,
and the components for the color.

00:30:41.880 --> 00:30:44.680
So you might, for example,
have a CGColorRef which is red

00:30:45.040 --> 00:30:49.000
with this particular profile,
and it would be 100 RGB plus the

00:30:49.350 --> 00:30:51.480
profile that you're interested in.

00:30:52.760 --> 00:30:55.600
As I mentioned, it's the fundamental type
for colors in Quartz 2D.

00:30:55.600 --> 00:30:56.940
It's a thing that we
use always internally.

00:30:56.940 --> 00:31:00.520
So anytime you are calling the old APIs,
you will end up internally

00:31:00.520 --> 00:31:02.440
getting the CG color ref.

00:31:02.500 --> 00:31:04.280
Well,
if you can create one yourself and use

00:31:04.280 --> 00:31:07.250
it yourself and manage it yourself,
then as you can imagine,

00:31:07.370 --> 00:31:09.300
we don't have to do that work internally.

00:31:09.550 --> 00:31:12.640
We can just use the color ref
that you provide us directly.

00:31:12.800 --> 00:31:14.230
So it is in fact very fast.

00:31:14.230 --> 00:31:17.380
It's much faster to use a color
ref than it is to sort of go

00:31:17.380 --> 00:31:19.250
through the original APIs.

00:31:19.280 --> 00:31:23.060
That said, there are cases when it's
not as maybe as powerful.

00:31:23.170 --> 00:31:28.390
There are some cases where it's more
powerful than it is in other cases.

00:31:28.450 --> 00:31:30.960
So in particular,
if you use a constant color,

00:31:30.960 --> 00:31:34.510
if you draw a lot of text in red with
this particular profile or a lot of

00:31:34.510 --> 00:31:38.980
text in purple with this other profile,
creating a CG color ref

00:31:38.980 --> 00:31:42.840
that you hang on to,
that you reuse over and over and over,

00:31:42.840 --> 00:31:45.560
will be much faster than
setting that every single time.

00:31:45.560 --> 00:31:47.490
Part of the reason for that
is we can do all sorts of

00:31:47.520 --> 00:31:48.900
optimizations in the back end.

00:31:48.900 --> 00:31:51.230
So if you want to, for example,
we might cache the color,

00:31:51.230 --> 00:31:54.430
we might do pre-conversions to a known
set of color spaces because we're always

00:31:54.650 --> 00:31:56.540
going to some particular destination.

00:31:56.540 --> 00:31:58.980
Who knows, we might upload it to OpenGL.

00:31:59.000 --> 00:32:00.880
It could be anything in the world.

00:32:00.890 --> 00:32:02.990
But if you can reuse
the color over and over,

00:32:02.990 --> 00:32:06.660
it will be somewhat faster than if
you had to set it and recreate a new

00:32:06.660 --> 00:32:09.870
thing and then discard it at the end.

00:32:09.900 --> 00:32:11.780
If on the other hand,
you use lots and lots

00:32:11.780 --> 00:32:14.270
of different colors,
if you're using every color of

00:32:14.280 --> 00:32:17.090
the rainbow all over the place,
then you don't get as big

00:32:17.100 --> 00:32:19.240
a speed advantage because
we can't reuse the color.

00:32:19.240 --> 00:32:23.060
We're sort of creating one, using it,
discarding it, creating one, using it,

00:32:23.060 --> 00:32:25.450
discarding it,
so you don't get quite as much advantage.

00:32:25.540 --> 00:32:28.050
But there are cases where
it would be very powerful.

00:32:28.180 --> 00:32:30.220
A typical case would be black text.

00:32:30.350 --> 00:32:33.310
Almost every piece of text
that's ever drawn is in black,

00:32:33.380 --> 00:32:35.900
the slides here notwithstanding.

00:32:35.950 --> 00:32:40.790
So creating a black color and reusing
that over and over every time you draw

00:32:40.790 --> 00:32:42.040
a black text makes a lot of sense.

00:32:42.080 --> 00:32:44.960
Of course,
there's some new API to allow you to

00:32:44.990 --> 00:32:47.390
set the color directly into the context.

00:32:47.480 --> 00:32:51.190
CGContext.setFillColorWithColor
is a little bit awkward names,

00:32:51.190 --> 00:32:53.280
but the better names were already taken.

00:32:57.180 --> 00:33:00.640
Okay, another thing that you can do with
a context is specify a shading.

00:33:00.640 --> 00:33:05.600
Shadings are just a way of doing axial
or radial gradients where you provide a

00:33:05.600 --> 00:33:11.630
function that tells us what colors you
want to be drawn across the gradient.

00:33:11.630 --> 00:33:15.370
So here you see on the left you
see a radial shading where you

00:33:15.640 --> 00:33:19.990
start out with a white bright dot
in the sort of offset from the

00:33:19.990 --> 00:33:26.360
center of the circle and you sort of
transition outward smoothly to pink.

00:33:26.360 --> 00:33:29.790
And on the right you have an axial
shading which goes through a number of

00:33:29.870 --> 00:33:33.980
different colors all provided by the
function that you might provide yourself.

00:33:34.090 --> 00:33:35.980
So we don't really restrict
what colors you can use,

00:33:36.050 --> 00:33:36.770
how you work with it.

00:33:36.910 --> 00:33:39.480
We also don't do any restriction
in terms of things like,

00:33:39.590 --> 00:33:41.760
you know, here you can see that the
circles don't have to be

00:33:41.850 --> 00:33:43.030
concentric or anything like that.

00:33:43.060 --> 00:33:46.060
They can sort of be pretty much
two different circles anywhere in

00:33:46.060 --> 00:33:49.380
space that you want and you'll get
a nice transition between them.

00:33:51.510 --> 00:33:53.780
For Panther,
we've put an awful lot of effort

00:33:53.780 --> 00:33:58.800
into improving our performance of
axial and radial shading drawing.

00:33:58.800 --> 00:34:03.710
We want to, well,
the truth is that we want to have what

00:34:03.710 --> 00:34:07.490
we call keynote quality gradients.

00:34:07.500 --> 00:34:10.040
And by keynote quality,
I mean satisfy the

00:34:10.080 --> 00:34:11.750
principal user keynote.

00:34:11.760 --> 00:34:18.300
And so, you know,
that takes a bit of work, it turns out.

00:34:18.740 --> 00:34:22.230
And so our goal has been for
Panther to be keynote quality.

00:34:22.240 --> 00:34:27.590
And I believe that we've reached
that goal in the current release.

00:34:30.850 --> 00:34:34.590
So one of the things that we allow
you to do is actually specify

00:34:34.590 --> 00:34:38.250
the level of quality you want
because there are cases when you

00:34:38.420 --> 00:34:41.880
actually just sort of want a fast,
as fast as possible shading,

00:34:41.920 --> 00:34:46.090
not necessarily super high quality
because it's just a one-off or you're

00:34:46.090 --> 00:34:48.270
doing some small little drawing
in the corner or who knows what.

00:34:48.400 --> 00:34:51.360
The typical way that this
works is through dithering.

00:34:51.360 --> 00:34:53.120
As you might know,
if you're doing a gradient,

00:34:53.120 --> 00:34:56.120
when you zoom it up very large,
you can sometimes get banding.

00:34:56.190 --> 00:34:59.360
And so dithering is an
approach to solve this problem.

00:34:59.360 --> 00:35:02.880
So you can now control the
shading and the way it's drawn

00:35:02.880 --> 00:35:04.690
via the interpolation quality.

00:35:04.690 --> 00:35:08.050
Same sort of way you control the quality
of images when they're scaled up or

00:35:08.130 --> 00:35:09.780
scaled down by the interpolation quality.

00:35:09.780 --> 00:35:14.360
And then also in Panther,
we've added the ability to

00:35:14.360 --> 00:35:18.440
have a transition between
opaque and non-opaque colors.

00:35:18.440 --> 00:35:20.740
In the past, in Jaguar,
all the colors were treated as

00:35:20.740 --> 00:35:22.800
if they were just 100% opaque.

00:35:22.980 --> 00:35:26.740
So you can do a nice transition
with a transparent color.

00:35:26.740 --> 00:35:30.090
Now in Panther, we've added the ability
to use transparent,

00:35:30.130 --> 00:35:31.030
non-opaque colors.

00:35:31.100 --> 00:35:34.280
So you can have a transition
from 0%, maybe 0% alpha,

00:35:34.540 --> 00:35:37.280
so completely transparent,
to fully opaque.

00:35:37.380 --> 00:35:40.320
So you get a nice transition
across where you start out with

00:35:40.320 --> 00:35:41.480
seeing the stuff in the background.

00:35:41.480 --> 00:35:43.480
And by the time you get to the end,
you see nothing from the background.

00:35:46.740 --> 00:35:49.680
Another thing that we've added,
as I mentioned earlier, is shadows.

00:35:49.680 --> 00:35:54.770
Shadows are basically applied
to any drawing you do.

00:35:54.900 --> 00:35:58.630
We'll take the result of the drawing
and we'll create a shadow from it

00:35:58.660 --> 00:36:03.220
and we'll write it down essentially
underneath the object that you're

00:36:03.250 --> 00:36:07.130
drawing at the offset you provide
with the blur radius you provide.

00:36:07.130 --> 00:36:10.260
That way you can do shadows to
all sorts of things that you want.

00:36:10.260 --> 00:36:12.380
Anything that's standard CG API,
you can shadow.

00:36:13.760 --> 00:36:16.810
As you see here on the right,
I have some text shadowed

00:36:16.810 --> 00:36:18.070
in an ordinary way.

00:36:18.160 --> 00:36:20.040
On the left, it may be hard to see.

00:36:20.150 --> 00:36:21.850
Maybe you can see it.

00:36:21.960 --> 00:36:26.870
On the left, the top figure,
this little logo that I've created,

00:36:27.050 --> 00:36:28.830
has a shadow that has a hard edge.

00:36:28.850 --> 00:36:31.020
On the bottom, it has a softer edge.

00:36:31.020 --> 00:36:33.170
The blur radius,
the amount of blur you get in your

00:36:33.170 --> 00:36:37.930
shadow is controllable so that you
can set that as you want depending

00:36:37.930 --> 00:36:41.160
on the effect you're trying to get.

00:36:41.420 --> 00:36:45.380
As I mentioned, the API that is available
allows you to specify an offset,

00:36:45.380 --> 00:36:48.820
sort of the position relative
to the object you're drawing,

00:36:48.820 --> 00:36:52.540
how far off the shadow appears,
the position around as well,

00:36:52.540 --> 00:36:55.140
and also the blur radiance, of course.

00:36:55.140 --> 00:36:57.890
And this is part of the graphic state,
which means that you can

00:36:57.900 --> 00:37:00.650
save the graphic state,
set up your shadow, do some drawing,

00:37:00.670 --> 00:37:03.630
and restore the graphic state,
and then the shadow's gone.

00:37:03.640 --> 00:37:06.590
So you can do just very
precise shadowing of objects.

00:37:07.850 --> 00:37:11.410
Here's a code example of actually
how you would use a shadow,

00:37:11.440 --> 00:37:13.260
how you'd actually set it up.

00:37:13.730 --> 00:37:15.370
In this case,
we're imagining that we've already

00:37:15.370 --> 00:37:17.880
set up a path that we want to
stroke in the context somewhere.

00:37:17.880 --> 00:37:20.580
Somebody's done that for us,
and we want to do a shadow of it.

00:37:20.580 --> 00:37:24.480
So you can see here we start out
by just doing a save G state.

00:37:24.480 --> 00:37:27.270
We're going to save the graphic state
because we just want this path's shadow,

00:37:27.270 --> 00:37:27.950
nothing else.

00:37:27.950 --> 00:37:28.970
We set up the offset.

00:37:28.970 --> 00:37:32.680
Here it's going to be 5.5 in default user
space relative to what we're drawing,

00:37:32.790 --> 00:37:34.270
so it's going to be sort of shifted.

00:37:34.280 --> 00:37:36.740
Actually,
it's going to be shifted up this way.

00:37:37.540 --> 00:37:42.460
So it's as if the light source
were down here shooting up.

00:37:42.460 --> 00:37:45.450
And then we just call
CGContextSetShadow with the context,

00:37:45.490 --> 00:37:47.850
of course,
the offset that we've just created,

00:37:47.860 --> 00:37:48.610
and the blur radius.

00:37:48.610 --> 00:37:52.210
And we imagine someone has specified
the blur radius that they want to use.

00:37:52.240 --> 00:37:56.170
And then we call CGContextStrokePath
and CGContextRestoreGState.

00:37:56.270 --> 00:37:57.300
So it's as simple as that.

00:37:57.300 --> 00:38:00.870
It's nothing very fancy or complex,
but now you get a shadowed path.

00:38:01.050 --> 00:38:04.320
And all of the nice anti-aliasing
that happens with regular,

00:38:04.460 --> 00:38:05.600
everything else will happen.

00:38:05.600 --> 00:38:08.140
All of the pretty drawings,
the interpolation,

00:38:08.140 --> 00:38:09.980
anything that happens that
needs to happen will happen.

00:38:09.980 --> 00:38:12.510
And you'll just have a shadow
underneath the object you were drawing.

00:38:12.620 --> 00:38:14.870
So this can be very, very powerful.

00:38:14.920 --> 00:38:18.890
And here's a simple demo
I'm going to show of this.

00:38:29.980 --> 00:38:32.810
So here's just a bunch of
objects that are animating.

00:38:32.870 --> 00:38:34.880
This is just a simple Cocoa app
that just animates the object.

00:38:34.980 --> 00:38:38.920
You can see all the objects
have shadows underneath them.

00:38:38.950 --> 00:38:40.620
And you get,
and the shadows don't really incur

00:38:40.630 --> 00:38:42.080
a tremendous performance penalty.

00:38:42.080 --> 00:38:44.010
This is in fact very little of one.

00:38:44.020 --> 00:38:46.320
This is animating a pretty good clip.

00:38:46.360 --> 00:38:49.890
And as you can see here,
we have the shadow.

00:38:49.890 --> 00:38:54.400
You can sort of see that in this
case the shadow is sort of drawn.

00:38:54.420 --> 00:38:55.950
It looks as if it's a 3D effect.

00:38:56.040 --> 00:38:57.010
Of course it's not.

00:38:57.050 --> 00:38:59.760
It's just sort of whatever is
drawn later will cast a shadow

00:38:59.850 --> 00:39:01.140
on what was drawn before.

00:39:01.140 --> 00:39:03.360
So it looks,
here you see that it looks as

00:39:03.360 --> 00:39:04.920
though this is on top of this.

00:39:04.920 --> 00:39:06.540
But of course it's not really.

00:39:06.540 --> 00:39:07.800
This was just drawn later.

00:39:07.920 --> 00:39:10.340
But you do have the shadow
on top of the other objects.

00:39:10.370 --> 00:39:12.600
As you can see here a little bit
where the shadows intersect you

00:39:12.600 --> 00:39:14.110
get a slightly darker appearance.

00:39:14.140 --> 00:39:17.380
And as I mentioned you can set the
shadow position anywhere you want.

00:39:17.380 --> 00:39:19.270
You can sort of play
around with it and say,

00:39:19.270 --> 00:39:20.160
"Oh, I like it there.

00:39:20.160 --> 00:39:21.940
That's really pretty."
Or whatever you like.

00:39:22.170 --> 00:39:25.610
And as I said before you can
set the blur radius so you

00:39:25.760 --> 00:39:28.500
can get it to be more fuzzy,
more diffuse light.

00:39:28.500 --> 00:39:29.840
Or a sharper light.

00:39:29.850 --> 00:39:30.900
Whatever you'd like.

00:39:30.930 --> 00:39:34.620
So it's actually,
it's a pretty simple API and then

00:39:34.620 --> 00:39:36.910
you can just use it for anything
that you might want to draw.

00:39:36.920 --> 00:39:44.260
Okay, so back to the slides.

00:39:49.930 --> 00:39:52.280
Okay, so another thing that
we've added for Panther,

00:39:52.280 --> 00:39:55.020
as I mentioned earlier,
is transparency layers.

00:39:55.020 --> 00:40:00.420
And the problem we're trying
to solve is this math equation.

00:40:00.690 --> 00:40:03.260
What do you get when
you want to do a logo?

00:40:03.510 --> 00:40:06.500
Let's say we're going to combine
these three circles in a way that

00:40:06.500 --> 00:40:08.870
we would like to combine them so
that they're overlapping each other,

00:40:08.870 --> 00:40:11.700
but we want to have the results shadowed,
okay?

00:40:11.700 --> 00:40:14.660
How do we do that so that it looks right?

00:40:14.990 --> 00:40:18.120
As a clear example,
here you see on the left,

00:40:18.120 --> 00:40:20.990
you have our logo,
our three circles drawn,

00:40:20.990 --> 00:40:23.740
but we've tried to shadow it and
we get this horrible result where

00:40:23.740 --> 00:40:27.120
every circle shadows the ones
underneath it or ones drawn earlier.

00:40:27.120 --> 00:40:27.980
It looks awful.

00:40:27.980 --> 00:40:31.050
What we really want is the one
on the right where we have this

00:40:31.050 --> 00:40:33.890
nice little logo that I've created
and the whole thing is shadowed.

00:40:35.340 --> 00:40:39.970
What we've added in Panther is
what we call a transparency layer.

00:40:39.970 --> 00:40:43.720
I've been mentioning
shadows and you might think,

00:40:43.720 --> 00:40:45.610
"Well, why isn't it called a
shadow layer?" Well,

00:40:46.060 --> 00:40:48.300
both names are actually
sort of misnomers.

00:40:48.340 --> 00:40:52.330
It's really just a way of,
you can sort of think of it as a layer.

00:40:52.380 --> 00:40:54.290
It's really a way to
sort of temporarily say,

00:40:54.370 --> 00:40:56.830
"Okay,
take what I'm going to draw for a while

00:40:56.870 --> 00:41:01.190
until I tell you to stop and collect
it all up in whatever form makes sense.

00:41:01.340 --> 00:41:02.820
Then after I say stop,
take the result and bring it back

00:41:02.820 --> 00:41:07.340
to the table." You can draw it
back with the effect that you want.

00:41:07.340 --> 00:41:09.380
Here,
what we're sort of doing is we're saying

00:41:09.380 --> 00:41:12.170
we're going to begin a transparency
layer where we're going to draw

00:41:12.170 --> 00:41:13.340
the three circles all together.

00:41:13.340 --> 00:41:16.990
Then when we say,
"Now we're done," we take the three

00:41:16.990 --> 00:41:22.540
circles as they're drawn and then take
the whole thing and shadow the result.

00:41:24.330 --> 00:41:27.990
So, so it's, it, as I've mentioned here,
it's good if you want to do a

00:41:28.010 --> 00:41:30.410
bunch of objects all simultaneously
and just applying this,

00:41:30.490 --> 00:41:33.900
the effect to the entire aggregate,
not to sort of each one independently.

00:41:33.990 --> 00:41:36.540
And it really is just like a
layer in a graphics application.

00:41:36.540 --> 00:41:38.300
You can sort of think of it that way.

00:41:38.530 --> 00:41:43.050
The important thing that makes it
really simple to use is that you can

00:41:44.110 --> 00:41:48.590
is that the graphic state parameters
in your context aren't changed

00:41:48.640 --> 00:41:52.950
except for the ones that actually
affect the final compositing result.

00:41:53.190 --> 00:41:56.940
So that means you can sort of just set
up your G-state the way you want to,

00:41:56.990 --> 00:42:00.300
begin a transparency layer,
draw some stuff in a transparency layer,

00:42:00.300 --> 00:42:01.370
and bam, you have the right result.

00:42:01.380 --> 00:42:03.910
And it's nestable,
so you can do transparency layer

00:42:04.150 --> 00:42:06.860
inside a transparency layer
inside a transparency layer,

00:42:06.860 --> 00:42:09.530
do the whole thing all the way back,
and you'll get the right result as well.

00:42:11.290 --> 00:42:13.640
So as a simple example
here you see again,

00:42:13.680 --> 00:42:17.880
this is sort of the origin of why
we call it the transparency layer.

00:42:18.030 --> 00:42:21.700
Here on the left is sort of what
I would consider the wrong thing.

00:42:21.750 --> 00:42:25.530
I don't want each circle 50%
alpha drawn on top of each other

00:42:25.530 --> 00:42:28.200
because then I get this sort of,
I don't know, it doesn't even look right

00:42:28.320 --> 00:42:29.430
on the left hand side.

00:42:29.520 --> 00:42:34.400
What I really want is all the circles
drawn essentially simultaneously

00:42:34.400 --> 00:42:38.520
and then the final result composited
to the destination with the

00:42:38.520 --> 00:42:38.520
alpha value that I've chosen.

00:42:38.820 --> 00:42:40.780
The code to do that is really,
really simple.

00:42:40.780 --> 00:42:45.710
Here you see what I start out
with is I tell the context what

00:42:45.800 --> 00:42:48.940
alpha I'm going to be using,
and then I begin transparency layer.

00:42:48.940 --> 00:42:50.580
I just say, "Begin a transparency layer.

00:42:50.650 --> 00:42:52.900
That's all I have to do."
And I presume I have some

00:42:52.900 --> 00:42:55.410
subroutine that does my little logo,
draw circles in rect,

00:42:55.410 --> 00:42:57.560
which will go off and draw
them in the right way,

00:42:57.560 --> 00:43:00.770
and basically draw one on top of
the other on top of the other.

00:43:00.950 --> 00:43:03.890
And then I just say,
"CG context in transparency layer."

00:43:04.220 --> 00:43:07.640
And what I end up with is all of that
drawing that I've done is composited

00:43:07.640 --> 00:43:11.320
to the destination with the alpha .7,
so I get the effect I'm

00:43:11.320 --> 00:43:12.310
actually looking for.

00:43:12.320 --> 00:43:16.390
So again, a little demo.

00:43:27.070 --> 00:43:29.310
Here's my simple application.

00:43:29.400 --> 00:43:31.630
So you can see this is wrong.

00:43:31.660 --> 00:43:35.750
I'm imagining that I'm an artist and I'm
going to make my logo and I'm trying to,

00:43:35.750 --> 00:43:40.000
and then it's, oh, it's just all wrong,
everything's shadowed, it's terrible.

00:43:40.070 --> 00:43:42.340
So what I'm going to do is
I'm going to click here.

00:43:42.340 --> 00:43:45.590
And now when I do the drawing,
it's as if each of these is drawn and

00:43:45.590 --> 00:43:49.760
it's all drawn sort of simultaneously
and just the result is shadowed.

00:43:49.760 --> 00:43:53.040
So I don't have this bad effect
of everything sort of being

00:43:53.040 --> 00:43:54.880
shadowed one on top of another.

00:43:54.880 --> 00:43:58.990
As you can see, it works just the same
as any other shadow.

00:43:58.990 --> 00:44:01.580
It just sort of can move around.

00:44:01.580 --> 00:44:03.620
And of course only the
aggregate is shadowed,

00:44:03.620 --> 00:44:05.360
not each thing independently.

00:44:05.470 --> 00:44:08.320
And of course blur radius
works the same way.

00:44:08.380 --> 00:44:10.800
So it actually can be pretty
powerful for doing groups of

00:44:10.800 --> 00:44:13.310
objects and applying effect to the,
just to the result,

00:44:13.310 --> 00:44:15.560
not to the each individual
object independently.

00:44:15.560 --> 00:44:19.470
Okay, back to the slides.

00:44:25.570 --> 00:44:31.540
Okay, so that's sort of all of the types,
all of the primitive things you can

00:44:31.540 --> 00:44:35.730
work with with a context to do drawing,
do actually relatively

00:44:35.730 --> 00:44:36.560
complicated drawing.

00:44:36.560 --> 00:44:39.520
And so now we want to step back
a little bit and look at just

00:44:39.520 --> 00:44:40.940
the context idea in general.

00:44:40.940 --> 00:44:44.460
So in Jaguar we have,
again as I showed you earlier,

00:44:44.460 --> 00:44:49.480
you can pretty much go to a window,
post group, PDF, bitmap context.

00:44:49.480 --> 00:44:55.480
And the one thing is that the bitmap
context is restricted in Jaguar.

00:44:55.500 --> 00:44:57.400
You can only have an RGB destination.

00:44:57.400 --> 00:45:00.000
So no matter what,
anytime you're doing drawing,

00:45:00.000 --> 00:45:02.270
you just get RGB out,
which is good in many cases.

00:45:02.270 --> 00:45:03.380
It's very powerful.

00:45:03.380 --> 00:45:07.290
But for Panther,
we're also going to let you create

00:45:07.290 --> 00:45:12.370
a CMYK bitmap context so you can,
for those of you who are clapping,

00:45:12.460 --> 00:45:15.880
hooray,
so that you can do direct output from

00:45:16.020 --> 00:45:19.420
your core graphics API to a CMYK bitmap.

00:45:19.420 --> 00:45:21.800
And of course, obviously,
you can still do an

00:45:21.800 --> 00:45:23.150
RGB bitmap if you want.

00:45:23.150 --> 00:45:25.480
And this can be very powerful
in some printing applications.

00:45:25.500 --> 00:45:27.640
And it's very simple, again.

00:45:27.640 --> 00:45:29.320
You don't have any new API.

00:45:29.320 --> 00:45:31.360
You just create a CMYK color space.

00:45:31.380 --> 00:45:34.580
This is a parameter that you pass
to the bitmap creation function.

00:45:34.580 --> 00:45:38.080
And you just create a CMYK color space,
pass it to the bitmap

00:45:38.150 --> 00:45:41.540
context creation function,
and now you have a CMYK context.

00:45:41.540 --> 00:45:44.780
And it will just work exactly
the way any other context does.

00:45:47.370 --> 00:45:50.270
In addition, so we have this little
nice diagram on the bottom,

00:45:50.270 --> 00:45:51.790
window, PostScript, PDF, bitmap.

00:45:51.870 --> 00:45:54.440
And for those of you who
saw Peter's talk on Tuesday,

00:45:54.440 --> 00:45:56.640
one of the key things was OpenGL.

00:45:56.640 --> 00:45:59.540
And you might say, wow,
I'd like to be able to draw with the

00:45:59.540 --> 00:46:01.360
CG context into my OpenGL context.

00:46:01.360 --> 00:46:02.150
Why can't I?

00:46:02.150 --> 00:46:03.920
Well, you can in Panther.

00:46:03.920 --> 00:46:07.440
We have support now
for an OpenGL context.

00:46:07.440 --> 00:46:11.550
So you take your GL context obj and
you pass it to a special creation

00:46:11.550 --> 00:46:14.000
function and out pops a CG context.

00:46:14.000 --> 00:46:17.280
And again, it works just like every
other context you can do.

00:46:17.300 --> 00:46:18.860
You can do high quality text drawing.

00:46:18.860 --> 00:46:22.300
You can do all the shadows and
shadings and stuff like that

00:46:22.370 --> 00:46:23.960
that I showed you earlier,
transparency layers.

00:46:23.960 --> 00:46:26.960
Everything works the same as
every other context in the system.

00:46:29.170 --> 00:46:31.790
The API is again pretty simple.

00:46:31.790 --> 00:46:38.630
There's CG, it's a mouthful to say.

00:46:38.630 --> 00:46:38.630
I'm going to take

00:46:39.290 --> 00:46:44.340
It's CGGL Context Create,
and it takes a CGL context obj.

00:46:44.340 --> 00:46:47.090
That's the thing that you work
with for the OpenGL for those

00:46:47.090 --> 00:46:48.080
of you who are familiar with it.

00:46:48.150 --> 00:46:51.080
A size, which is the viewport size,
and a color space.

00:46:51.080 --> 00:46:55.140
The color space says how to convert
device independent colors to the

00:46:55.530 --> 00:46:57.860
actual destination of the GL context.

00:46:57.890 --> 00:47:00.070
And what you get back
is a CG context ref,

00:47:00.070 --> 00:47:03.530
just like any other CG context ref,
so you can start immediately

00:47:03.530 --> 00:47:07.010
drawing your high-quality text
on your GL context and so on.

00:47:07.020 --> 00:47:11.880
It has an additional API,
CGGL Context Update Viewport Size,

00:47:12.020 --> 00:47:16.890
in case your viewport size changes,
you can call that.

00:47:18.130 --> 00:47:23.480
In addition to all of that,
we're also adding in Panther,

00:47:23.480 --> 00:47:27.080
although it's not in the seed that
you're going to get or that you have yet.

00:47:27.260 --> 00:47:31.720
We're adding API to do sort of
a scroll rect and copy bits.

00:47:31.720 --> 00:47:34.100
For those of you who are
familiar with QuickDraw,

00:47:34.190 --> 00:47:34.560
light.

00:47:34.650 --> 00:47:42.370
When I say light, what I mean is actually
it's really a copy.

00:47:42.370 --> 00:47:44.050
It doesn't go through
any special effects,

00:47:44.050 --> 00:47:46.010
doesn't do anything crazy
or anything like that.

00:47:46.100 --> 00:47:47.980
It just takes bits here and there.

00:47:48.000 --> 00:47:49.170
It copies them to here.

00:47:49.180 --> 00:47:51.770
But this is very powerful for the
situations when you need that,

00:47:51.870 --> 00:47:55.060
when you want to do a scroll yourself
or some sort of copy yourself.

00:47:57.580 --> 00:48:02.180
You can do a scroll,
which means that you're copying

00:48:02.180 --> 00:48:04.590
from one context back to itself.

00:48:04.640 --> 00:48:07.450
So if you just wanted to
slide some content up.

00:48:07.630 --> 00:48:08.760
Or you can do a copy.

00:48:08.760 --> 00:48:12.810
So you take a rectangle of bits from one
context and copy them to another context,

00:48:12.930 --> 00:48:13.960
another destination.

00:48:15.690 --> 00:48:18.340
And in addition,
we will have API which lets

00:48:18.340 --> 00:48:21.840
you create a CG image directly
from a region in a context.

00:48:21.840 --> 00:48:26.210
You might do some drawing to the screen,
grab the area you're interested in,

00:48:26.210 --> 00:48:27.340
and create a CG image from that.

00:48:27.340 --> 00:48:32.440
And maybe you write that as a JPEG or
TIFF or something else as you wish.

00:48:33.800 --> 00:48:37.940
Okay, so that's the sort of the general
thing of context for Panther.

00:48:37.940 --> 00:48:39.750
The directions we're going,
as you can see,

00:48:39.750 --> 00:48:42.450
we're sort of trying to innovate more,
add things that people need.

00:48:42.630 --> 00:48:45.840
We've got a lot of new
APIs for you to work with.

00:48:45.890 --> 00:48:47.980
We've had the PDF metadata access.

00:48:47.980 --> 00:48:52.500
You can actually crack open PDF files
and start working with them directly.

00:48:52.500 --> 00:48:55.100
Pixel copying, as I mentioned.

00:48:55.100 --> 00:48:57.910
And we've put in a lot of performance
and quality improvements and we're

00:48:57.980 --> 00:48:59.340
going to continue doing that.

00:48:59.370 --> 00:49:02.170
We view performance as a very
critical thing in Panther and

00:49:02.170 --> 00:49:03.500
certainly at our level.

00:49:03.700 --> 00:49:06.240
We're pretty much nowadays,
everything funnels through us.

00:49:06.260 --> 00:49:07.490
Performance is key for us.

00:49:07.490 --> 00:49:11.660
And so we spend a lot of effort
making things very fast and very high

00:49:11.660 --> 00:49:14.270
quality where that is appropriate.

00:49:14.970 --> 00:49:17.540
Okay, so that's sort of what's
new in Panther for context.

00:49:17.540 --> 00:49:20.190
So now let's sort of step back even
farther and look at what you can

00:49:20.190 --> 00:49:21.920
do with the Quartz API in general.

00:49:21.920 --> 00:49:24.310
One of the things that we've added,
which we found people have

00:49:24.390 --> 00:49:26.540
been very interested in,
is Python bindings.

00:49:26.540 --> 00:49:29.130
So since Quartz is so powerful
and rich and has all those

00:49:29.130 --> 00:49:32.180
nice things you can do with it,
it'd be great if you didn't have to

00:49:32.180 --> 00:49:34.220
actually write a program to do anything.

00:49:34.220 --> 00:49:37.210
If you could just write a simple
script to have things come out,

00:49:37.210 --> 00:49:39.420
the drawing that you might want to do.

00:49:39.420 --> 00:49:42.180
And so we've added some
Python bindings that let you get

00:49:42.180 --> 00:49:44.780
access directly to the CG APIs to
do anything that you can do with it.

00:49:44.800 --> 00:49:48.640
So that's what you can do with
a regular ordinary program.

00:49:48.640 --> 00:49:50.800
As I mentioned here,
the fact that it's an object-oriented

00:49:50.800 --> 00:49:53.130
interpreted language makes
it really simple to do quick

00:49:53.530 --> 00:49:56.880
sort of one-off programs,
little tests or examples and so on.

00:49:56.880 --> 00:50:00.090
And there's lots of
ways you could use this.

00:50:00.110 --> 00:50:02.840
Here I mentioned scripting
a PDF manipulation.

00:50:02.840 --> 00:50:06.090
For example,
you might want to take a PDF file and do,

00:50:06.090 --> 00:50:09.240
say, a 4-up version of it or
put a watermark on it,

00:50:09.240 --> 00:50:10.810
something like that.

00:50:10.920 --> 00:50:15.260
Or you might want to take some sort of
complicated PDF file or maybe just some

00:50:15.260 --> 00:50:19.010
complicated drawing of your own and
draw directly to a bitmap and then take

00:50:19.060 --> 00:50:20.730
the result and create a JPEG out of it.

00:50:20.840 --> 00:50:22.490
So rather than having to go
through the whole process of

00:50:22.490 --> 00:50:24.960
writing a program to do that,
you could just use a script

00:50:24.960 --> 00:50:26.310
language to do that for you.

00:50:28.560 --> 00:50:33.630
The, as I say, the APIs that we have,
almost all the APIs are wrapped

00:50:33.710 --> 00:50:38.700
so you can use them just like you
would use them in your C program.

00:50:38.780 --> 00:50:39.940
Most of them are wrapped,
not all of them,

00:50:39.940 --> 00:50:42.140
but we're probably going to
end up adding all of them.

00:50:42.140 --> 00:50:51.200
And then because the CG API is powerful,
it's still not everything you need to do,

00:50:51.200 --> 00:50:54.410
sort of really what you want in
terms of some convenience functions.

00:50:54.420 --> 00:50:58.580
So, for example, CG doesn't support a lot
of the QuickTime image IO,

00:50:58.580 --> 00:51:02.010
but we've added wraps for that
via the new API so that you can

00:51:02.010 --> 00:51:03.980
get IO from QuickTime easily.

00:51:03.980 --> 00:51:06.560
And then because, again,
as I mentioned earlier,

00:51:06.560 --> 00:51:08.000
we don't really work at the text level.

00:51:08.080 --> 00:51:08.860
We work at the glyph level.

00:51:08.860 --> 00:51:13.420
We've also added some wraps to do
layout and rendering of text via Cocoa.

00:51:13.420 --> 00:51:16.930
So you can do regular text layout, HTML,
RTF, anything like that.

00:51:17.000 --> 00:51:21.000
And so you can sort of get high-quality
text layout through the Python bindings.

00:51:22.680 --> 00:51:25.440
So here's a code example
of how you might,

00:51:25.490 --> 00:51:28.070
in this case, we're going to draw a red
circle in the middle of,

00:51:28.420 --> 00:51:31.710
well, near the middle of a page and
create a PDF file from it.

00:51:31.780 --> 00:51:33.240
So it's a really very simple example.

00:51:33.240 --> 00:51:35.370
As you can see,
we start out by doing from

00:51:35.370 --> 00:51:38.360
core graphics import star,
which is the Python way of saying

00:51:38.360 --> 00:51:40.000
bring in everything that has
to do with the core graphics.

00:51:40.100 --> 00:51:40.810
Thank you.

00:51:40.820 --> 00:51:43.720
And then we create a rectangle.

00:51:43.720 --> 00:51:46.070
So this looks just like your
regular C code that you might write

00:51:46.100 --> 00:51:47.270
if you're using core graphics.

00:51:47.280 --> 00:51:49.540
Cgrec make without the semicolon.

00:51:49.540 --> 00:51:50.640
That's the only part that's missing.

00:51:51.380 --> 00:51:55.000
In this case, it's going to be 8.5 by 11,
612 by 792 points.

00:51:55.060 --> 00:51:57.880
We create a PDF context with a file.

00:51:57.880 --> 00:52:00.330
So we're going to write to
the file called circle.pdf,

00:52:00.420 --> 00:52:01.950
and we pass in the default page rect.

00:52:02.050 --> 00:52:04.060
So if we don't specify a page rect,
that's going to be the

00:52:04.210 --> 00:52:05.150
rectangle that's used.

00:52:05.160 --> 00:52:07.680
And then we do Cgcontext begin page.

00:52:07.700 --> 00:52:08.850
We start out with the first page.

00:52:09.070 --> 00:52:10.020
Set RGB fill color.

00:52:10.020 --> 00:52:13.980
In this case, it's going to be red,
no green, no blue, and fully opaque.

00:52:13.980 --> 00:52:14.680
Alpha is one.

00:52:14.680 --> 00:52:16.660
And then we add an arc.

00:52:16.740 --> 00:52:18.580
The arc is positioned at 300, 300.

00:52:18.580 --> 00:52:19.340
That's the center.

00:52:19.340 --> 00:52:20.440
Its radius is 100.

00:52:20.440 --> 00:52:21.280
And it goes from 0.

00:52:21.380 --> 00:52:22.400
To 2 pi radians.

00:52:22.400 --> 00:52:24.620
And we're going to make
it counterclockwise.

00:52:24.620 --> 00:52:26.390
And then we just fill the path.

00:52:26.480 --> 00:52:29.340
Now we have a red circle in the PDF file.

00:52:29.340 --> 00:52:31.130
And when we do end page, we're done.

00:52:31.140 --> 00:52:31.670
That's it.

00:52:31.800 --> 00:52:36.180
So now we have done a very simple
drawing of a red circle in a PDF file.

00:52:36.180 --> 00:52:38.270
Of course, this is a simple example,
but you can do much more

00:52:38.320 --> 00:52:39.480
complicated things than this.

00:52:42.440 --> 00:52:44.120
Okay, so that's Python bindings.

00:52:44.340 --> 00:52:49.200
Then we've also found that a lot of
people have legacy PostScript files.

00:52:49.200 --> 00:52:52.510
PDF is a great digital paper format,
but there's people who

00:52:52.510 --> 00:52:54.450
have written theses,
that have used tech

00:52:54.450 --> 00:52:56.810
to produce PostScript,
and who knows what all, right?

00:52:56.900 --> 00:53:00.040
There's all this PostScript files
that sort of are still around that you

00:53:00.200 --> 00:53:02.070
might like to move forward into PDF.

00:53:02.070 --> 00:53:04.640
Or you might just want to
have an application that

00:53:04.640 --> 00:53:07.360
displays PostScript files
if you wanted to accept it.

00:53:07.450 --> 00:53:12.010
So we have new API in Panther that
will convert PostScript to PDF so

00:53:12.010 --> 00:53:15.550
that you can call it directly and
you can do all the conversions

00:53:15.610 --> 00:53:17.820
you want from PostScript to PDF.

00:53:17.820 --> 00:53:22.140
You provide a set of callbacks which are
a way for us to tell you things like,

00:53:22.140 --> 00:53:25.200
oh, I'm finished page one,
I'm going to start on page two, or oh,

00:53:25.280 --> 00:53:28.870
I'm finished the document, or by the way,
there's this warning that occurred,

00:53:28.870 --> 00:53:31.740
or I couldn't find this font,
or I'm aborting because you've

00:53:31.740 --> 00:53:33.680
used an invalid operator,
whatever.

00:53:33.680 --> 00:53:36.910
The callback mechanisms are there so
that you get as much information that you

00:53:36.910 --> 00:53:39.320
might normally think you would get from,
say, a PostScript printer.

00:53:40.740 --> 00:53:43.160
The one thing,
the things to remember are that

00:53:43.160 --> 00:53:46.010
because it is a PostScript interpreter,
it brings in the entire

00:53:46.010 --> 00:53:48.680
PostScript VM into your process,
which is, you know,

00:53:48.680 --> 00:53:51.120
can be pretty big actually, to be frank.

00:53:51.120 --> 00:53:57.130
It's not,
it's a non-zero cost to your application.

00:53:57.310 --> 00:53:59.130
And again,
because you are bringing up this VM and

00:53:59.130 --> 00:54:01.930
it's got to figure out about fonts
and all that sort of information,

00:54:02.040 --> 00:54:03.550
it can be a little slow to start up.

00:54:03.630 --> 00:54:05.250
So that's one thing to
keep in mind as well,

00:54:05.390 --> 00:54:09.960
that those two things are things
that you might want to be aware of.

00:54:09.960 --> 00:54:12.300
But once it's started up, bam,
off you go.

00:54:12.300 --> 00:54:15.090
All the conversion happens pretty fast.

00:54:15.700 --> 00:54:18.640
So here's an example,
a code example of what you might do.

00:54:18.640 --> 00:54:22.790
And it turns out the astute among you or
the awake perhaps will notice that I'm

00:54:22.870 --> 00:54:25.230
writing and reading from the same file,
which is a bug.

00:54:25.230 --> 00:54:29.930
But if you imagine that in the first line
I'm actually creating a data provider,

00:54:29.930 --> 00:54:33.180
a way to get data into
Core Graphics from your application

00:54:33.280 --> 00:54:35.000
with some PostScript URL.

00:54:35.000 --> 00:54:38.010
In the second line I'm going
to create a data consumer,

00:54:38.110 --> 00:54:41.160
a way for Core Graphics to
give information to you with,

00:54:41.160 --> 00:54:43.780
in this case let's
imagine a different URL,

00:54:43.780 --> 00:54:45.580
a different PDF URL let's suppose.

00:54:45.600 --> 00:54:48.470
So we have an in and an out and then
we're going to create a converter.

00:54:48.590 --> 00:54:51.240
CGPS converter create
creates the converter.

00:54:51.380 --> 00:54:54.030
We presume the callbacks have been
specified by you so that you want

00:54:54.030 --> 00:54:57.330
information about warnings or pages
being completed and stuff like that.

00:54:57.390 --> 00:55:00.940
And once we've created the converter
then we can just use it to create,

00:55:00.940 --> 00:55:02.670
to convert PostScript files.

00:55:02.680 --> 00:55:06.560
And so here you see CGPS converter
convert takes the converter

00:55:06.560 --> 00:55:10.110
and an input file and an output
file and returns success if

00:55:10.130 --> 00:55:12.490
it succeeds and false if it fails.

00:55:14.660 --> 00:55:17.050
And what's good about this is that
once you've started this up and

00:55:17.050 --> 00:55:19.610
converted the PostScript file then
you can just reuse the converter.

00:55:19.650 --> 00:55:22.550
It's all ready to go and you can just
sort of convert more PostScript files

00:55:22.600 --> 00:55:25.970
if you have a thousand of them or just
have this sort of ready to go so that

00:55:25.970 --> 00:55:28.800
when someone drags in a PostScript file
you can do the conversion automatically.

00:55:28.900 --> 00:55:33.290
So it has a pretty flexible
interface in that respect.

00:55:34.710 --> 00:55:37.850
Okay, so to sum up,
we have lots of API that you

00:55:37.850 --> 00:55:39.940
can play with for Panther.

00:55:39.940 --> 00:55:42.050
Of course, there's all the API we've
already had in Jaguar.

00:55:42.050 --> 00:55:44.660
So for those of you who
haven't been using Quartz 2D,

00:55:44.680 --> 00:55:46.600
I encourage you to experiment
with some of this and play

00:55:46.600 --> 00:55:48.340
around and see what you can do.

00:55:48.340 --> 00:55:52.450
We're going to keep adding
more API where it makes sense,

00:55:52.610 --> 00:55:55.420
and part of the way that makes
sense is for you to tell us what

00:55:55.420 --> 00:55:58.180
you need and what is missing that
you find would be really useful.

00:55:58.180 --> 00:56:00.800
A lot of things we've added this
year have been based directly on

00:56:00.870 --> 00:56:03.990
feedback we've gotten last year,
so your feedback is very important

00:56:03.990 --> 00:56:07.540
to us and is very useful for helping
us direct where we're innovating

00:56:07.540 --> 00:56:09.720
to satisfy the needs of you,
the developers.

00:56:11.580 --> 00:56:19.620
And so now I'm going to bring Travis back
up to wrap up and give you the roadmap.

00:56:23.260 --> 00:56:28.340
So remaining today in the roadmap
for the graphics imaging track,

00:56:28.340 --> 00:56:31.180
our next session is
going to be session 2.8,

00:56:31.350 --> 00:56:34.180
which is Fragment
Programming with OpenGL.

00:56:34.390 --> 00:56:36.830
In the graphics and imaging overview,
you saw us do a lot of really

00:56:36.830 --> 00:56:40.580
incredible real-time pixel operations
and hosting those in the GPU.

00:56:40.580 --> 00:56:43.120
And this is a session that's
going to talk about the techniques

00:56:43.120 --> 00:56:44.570
that you use to do that.

00:56:45.240 --> 00:56:49.070
Then we also have session 209,
which is OpenGL optimizations.

00:56:49.110 --> 00:56:54.140
If you are interested in finding out how
to use OpenGL to its best on Mac OS X,

00:56:54.210 --> 00:56:55.160
please attend that session.

00:56:55.160 --> 00:56:59.570
And then to people doing 2D graphics,
obviously a good companion session

00:56:59.570 --> 00:57:03.220
that you'll want to attend is 210,
which is Mac OS X printing update.

00:57:03.750 --> 00:57:08.200
Obviously a significant client to
the Quartz 2D technology inside

00:57:08.290 --> 00:57:11.380
Mac OS X is the printing system,
because our printing system

00:57:11.380 --> 00:57:14.070
does use Quartz to do both
its PostScript generation

00:57:14.070 --> 00:57:15.860
and also its rasterization.

00:57:15.880 --> 00:57:18.800
So there's going to be lots of
information relating to Quartz

00:57:18.810 --> 00:57:22.430
2D and how it all interacts with
our whole printing architecture.

00:57:22.440 --> 00:57:24.720
So 210 is going to be a great
session for you to attend.

00:57:24.720 --> 00:57:28.970
And then we have 211,
which is talking about the parts of

00:57:29.130 --> 00:57:33.410
Quartz that do not deal with drawing,
but deal with the other services.

00:57:33.440 --> 00:57:38.380
That the system needs, for example,
handling displays and whatnot.

00:57:38.380 --> 00:57:40.820
And then also we have
an interesting session,

00:57:40.820 --> 00:57:43.750
212,
which is cutting edge OpenGL techniques,

00:57:43.750 --> 00:57:46.750
which is going to be presented
by our hardware partners,

00:57:46.750 --> 00:57:47.320
ATI.

00:57:47.320 --> 00:57:51.060
They have their sort of OpenGL heavy
hitters who are coming to present and

00:57:51.060 --> 00:57:55.080
let you know what you can do when you
really push the envelope with OpenGL.

00:57:55.080 --> 00:57:56.760
So that's going to be
an exciting session.

00:57:56.760 --> 00:58:03.220
And then we have a feedback
forum at our traditional time.

00:58:03.220 --> 00:58:04.700
Which is... The feedback
is Friday at 5:00 PM.

00:58:05.200 --> 00:58:07.590
Obviously you can give us feedback
when you see us in the hallway

00:58:07.590 --> 00:58:08.800
or at the end of this Q&A.

00:58:08.860 --> 00:58:11.020
But if you have more significant
feedback you want to get us,

00:58:11.220 --> 00:58:12.560
please attend the feedback forum.

00:58:12.710 --> 00:58:15.300
Because it's a great time to
basically let us know what you

00:58:15.370 --> 00:58:18.010
want to see in Mac OS X in terms of
graphics technology in the future.

00:58:18.060 --> 00:58:22.420
So now what I want to do is give
you some contact information.

00:58:22.520 --> 00:58:27.020
I'm your best point of contact for any
of the graphics technologies in Mac OS X.

00:58:27.020 --> 00:58:28.920
I can be found at travis@apple.com.

00:58:28.920 --> 00:58:33.380
And so please contact me
with any questions you have.

00:58:33.380 --> 00:58:35.510
Regarding the technologies
you've seen thus far.

00:58:35.540 --> 00:58:38.860
Let me bring the Q&A panel up.

00:58:38.900 --> 00:58:41.480
Actually we do have some references here.

00:58:41.480 --> 00:58:47.240
But... So we have some additional
documentation on the ADC site.

00:58:47.240 --> 00:58:51.680
And we also have a developer web page
that addresses Quartz as a general

00:58:51.680 --> 00:58:55.310
umbrella technology for our windowing
system and our 2D drawing APIs.
# Wwdc2022 10160

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Program Metal in C++ with metal-cppYour C++ games and apps can now tap into the power of Metal. We'll show you how metal-cpp helps you bridge your C++ code to Metal, explore how each manages object lifecycles, and demonstrate utilities that can help these language cooperate in your app. We'll also share best practices for designing app architecture to elegantly integrate Objective-C and C++ together.ResourcesDownload the LearnMetalCPP projectGetting started with Metal-cppMetalHD VideoSD VideoRelated VideosWWDC22Discover Metal 3

Your C++ games and apps can now tap into the power of Metal. We'll show you how metal-cpp helps you bridge your C++ code to Metal, explore how each manages object lifecycles, and demonstrate utilities that can help these language cooperate in your app. We'll also share best practices for designing app architecture to elegantly integrate Objective-C and C++ together.

Download the LearnMetalCPP project

Getting started with Metal-cpp

Metal

HD VideoSD Video

HD Video

SD Video

Discover Metal 3

Search this video…♪ Mellow instrumental hip-hop music ♪♪Hi, my name is Keyi Yu,and I'm an engineer from the Metal Ecosystem team.Today, it's my pleasure to introduce metal-cpp.We created metal-cpp for anyone who uses C++ and wants to buildMetal applications for Apple platforms.Metal-cpp is a low-overhead librarythat connects your C++ applications to Metal.First, I'll start with an overview of what metal-cpp isand how it works, and then I'll cover some detailsabout the lifecycles for Objective-C objects.C++ and Objective-C handle lifecycles a bit differently,and I'll show you how to handle those differences.Xcode and metal-cpp have some great utilitiesthat can help you manage the object lifecyclesin your apps.And finally, I'll show you how to integrate C++ codewith Objective-C classes.So here's a look at metal-cpp and how it works.Metal is the foundation for accelerated graphicsand compute on Apple platforms, enabling your apps and gamesto tap into the incredible power of the GPU.It was originally designed using the powerful featuresand the conventions offered by Objective-C.But if your code base is in C++, you may need something to bridgebetween your code and Metal's Objective-C code.Introducing metal-cpp!It serves as a hub between your C++ applicationand Objective-C Metal.With metal-cpp in your application,you can use Metal classes and functions in C++,and metal-cpp can help you call Objective-C functionsin runtime.metal-cpp is a lightweight Metal C++ wrapper.I say it's lightweight, because it's implementedas a header-only library with inline function calls.It provides 100 percent coverage of the Metal APIby implementing a one-to-one mapping of C++ callsto Objective-C APIs.To do this, metal-cpp wraps parts of the Foundationand CoreAnimation frameworks.It's open source under Apache 2 License,so you can modify the library and include itto your applications, easily.metal-cpp uses C to call directlyinto the Objective-C runtime.This is the exact same mechanism that the Objective-C compileruses to execute Objective-C methods.So this wrapper introduces little overhead.Since metal-cpp implements a one-to-one mapping of C++to Objective-C calls,it follows the same Cocoa memory-management rules.I will discuss this in more detail later.This one-to-one mapping also allowsall of the developer tools to work seamlessly,including GPU Frame Capture and the Xcode debugger.These are the series of calls necessary to draw a trianglewith metal-cpp.If you are familiar with C++, it's a good time to learn Metal,because you don't need to worry about language syntax.If you've already used Metal with Objective-C,in terms of function calls, there's very little differencebetween the Objective-C interface of Metaland metal-cpp.I am going to demonstrate how easy it is to use metal-cpp.First, I create a command buffer,which I will fill with commands for the GPU to execute.I can simply use the raw pointer in C++as a mapping to ID in Objective-C.I can create a render command encoderand write render commands with a command buffer.The C++ function renderCommandEncoderand the Objective-C methodrenderCommandEncoder WithDescriptor are the same.The only differences are the name conventionsof the languages.I then set a render pipeline state objectwhich contains the vertex and fragment shadersand various other rendering states.Then I encode my draw call to render a single triangle.Then I indicate thatI've finished encoding render commands.I present the drawable, so the triangle is displayed onscreen.Finally, I commit my command buffer.This tells the GPU that it can begin executing my commands.Obviously, metal-cpp and Objective-C Metalare almost the same.You don't need to worry about language syntax nowwith metal-cpp,you can directly look into the Metal documentationto learn the concepts and usage of Metal.You may have already playedwith this deferred lighting sample before.We now provide a new version of this deferred lighting samplewhich uses metal-cpp.We hope this can help you learn how to code with metal-cppin practice.I'm also excited to introduce a seriesof incremental C++ samples that introduces the Metal APIand shows you how to accomplish different tasks with it.So now that you know a little bit about metal-cpp,how do you actually use it?We published metal-cpp last year.Here's the webpage where you can find the downloadsand instructions.Let me show you the steps you will need to take.After downloading metal-cpp,you should tell Xcode where to find it.Here, I put metal-cpp under the current project.Then, you need to set C++17 or higheras the C++ language dialect.Next, add three frameworks to the project:Foundation, QuartzCore, and Metal.Now there's only one thing left to dobefore using C++ interfaces of those frameworks.There are three headers in metal-cpp.Since metal-cpp is a header-only library,you need to generate their implementationsbefore importing the header files.To do this, define three macros: NS_PRIVATE_IMPLEMENTATION,CA_PRIVATE_IMPLEMENTATION, AND MTL_PRIVATE_IMPLEMENTATION.If you are interested in what metal-cpp does with the macrosunder the hood,please check out header bridge files in the metal-cpp folder.You can use the headers separatelyor put them in a single header.You can import the header files whenever you need them.But remember, do not define the NS, CA,or MTL_PRIVATE_IMPLEMENTATION macros more than once.Otherwise, you may cause duplicate definition errors.To use metal-cpp effectively,you'll need to know Cocoa's memory management rules,how to use the great utilities that can help youmanage object lifecycles, and how to designyour application architecture when you interfacewith other frameworks.I'll start with object lifecycle management.During your application's operation,you typically need to allocate and release memory.You also need to manage command buffers,pipeline objects, and resources.To help manage this memory,Objective-C and Cocoa objects include a reference count.This is also present in metal-cpp.Reference counting helps you manage your memory.Using reference counting,all objects contain a retainCount property.Components in an app increase the countto keep objects they're interacting with aliveand decrease it when they are done with them.When the retainCount hits zero,the runtime deallocates the object.There are two types of reference counting in Objective-C.One is called Manual Retain-Release -- MRR;the other is Automatic Reference Counting -- ARC.When compiling code with the ARC feature,the compiler takes the references you createand automatically inserts callsto the underlying memory-management mechanism.metal-cpp objects are manually retained and released.So you need to understand Cocoa's conventionsto know when to retain and release objects.Unlike creating objects in C++, metal-cpp objectsare neither created with new nor destroyed with delete.With Cocoa's conventions, you own any object you createwith methods starting with the alloc, new, copy,mutableCopy, or create.You can take ownership of an object using retain.When you no longer need it, you must relinquish ownershipof an object you own.You can release it immediately or release it afterwards.You must not relinquish ownership of an objectyou do not own as you risk a double free.Next, I'll walk through an exampleof these Cocoa conventions.In class A, a method uses alloc to create an objectand init to initialize this object.Remember, never call init on an object twice.Class A takes the ownershipand is responsible for deallocating it.Now the retain count for this object is one.Next, class B uses retain to get the objectand takes ownership of this object.So far, I have two objects that share the ownershipof this object represented by the orange cube.The retain count increases by one.Class A doesn't need this object anymore,so class A should manually call release for it.As a result, the retain count decreases by one.Now, only class B owns the object.OK, finally, class B wants to release this object too.Now the retain count is zero, so the runtime frees the object.Here's a situation where a method in class Breturns an object.You still need this object in the rest of the programs.In other words, you want to relinquish ownershipof an object in a method in class B,but you don't want it to be deallocated immediately.In this case, you should call autorelease in class B.The retain count is still one after you call autorelease,and thus, you can still use the object later.Here's the question:since class B does not own this object anymore,who is responsible for deallocating it?The Foundation Framework provides an important object,called the AutoreleasePool.The Autorelease API puts the object into an AutoreleasePool.Now, the AutoreleasePool takes the ownership of the object.The AutoreleasePool decrements the receiver's retain countwhen the AutoreleasePool is destroyed.You are not the only one who can create autoreleased objects.Metal creates several autoreleased objectsas part of its operation.All methods that create temporary objectsadd them to AutoreleasePoolsby calling autorelease under the hood.It is the AutoreleasePool's responsibility to release them.In other words, with an AutoreleasePool,you can code in a more elegant way.You can have an AutoreleasePool for the main application.We also encourage you to create and manageadditional AutoreleasePools at smaller scopesto reduce your program's working set.You also need AutoreleasePools for every thread you create.Here's an example showing how to use an AutoreleasePooland autoreleased objects.In this sample, an AutoreleasePoolis created by alloc, which means you take the ownershipand it should be manually released.Now we have an AutoreleasePool.As we discussed in the beginning,you should create a command buffer.It's not created with alloc or create,so you don't own it.Instead, it's an autoreleased object created by Metal.This command buffer will be put into the AutoreleasePool.It's the AutoreleasePool's responsibility to deallocate it.You can use it as you wishuntil you release the AutoreleasePool.Then you need to create a RenderPassDescriptor.This RenderPassDescriptor will be put into the AutoreleasePoolas well.Same to RenderCommandEncoder.It's also an autoreleased object created by Metal.Don't forget this currentDrawable object.It will be put into the AutoreleasePool too.At the end of the piece of code, I use pPool->releaseto release the AutoreleasePool.Before being deallocated, the AutoreleasePoolreleases everything that it owns,in this case, it releases the CommandBuffer,RenderPassDescriptor, RenderCommandEncoder,and currentDrawable.Then the AutoreleasePool is released.So far, you got to know Cocoa's conventions,autoreleased objects, and AutoreleasePools.It's important to correctly manage object lifecyclesto avoid memory leaks and zombie objects,and we have great tools to help you avoidand debug these issues.I'll focus on two utilities:NS::SharedPtr and NSZombie.NS::SharedPtr is a new utility that can help you managethe object lifecycle.You can find it under Foundation frameworkin the metal-cpp folder.Notice that it is not exactly the sameas std:shared_ptr.So there's no dependency on the C++ standard libraryand no extra cost on storing the reference count.Here's what NS::SharedPtr is like.Transfer and retain functions clearly expressthe intent of consuming an object.Transfer creates a SharedPtrwithout increasing the pointee's referenceCount,effectively transferring ownership to the SharedPtr.The retain function sends a retain to the passed-in object.Use this function to keep alive objectsthat are in AutoreleasePoolsand to express that the pointer's ownerhas a vested interest in the pointee's lifecycle.You can access the underlying objectas expected via get and via the operator->.SharedPtr copy, move, construction,and assignment work as expected,with copy increasing the retainCount.Moves are fast and do not affect the retain countin the general case.SharedPtrs always send exactly one releaseto the pointee on destruction.You can avoid this if you wantby calling the detach function.Going back to the top,it's important to know the differences betweencreating a pointer by transferring or retaining it.So for TransferPtr,suppose I have an MRR object, with a reference count of 1.After I pass it to the TransferPtr function,the SharedPtr takes ownership of the object,but its retainCount doesn't change.When the pointer goes out of scope,the SharedPtr's destructor runsand calls release on the MRR object,which decrements the retainCount to 0.Another function is NS::RetainPtr.When you want to avoid deallocating an objectbecause you want to use it later,you should use NS::RetainPtr.Suppose we have this MRR object; the retainCount is one.After we pass it to the RetainPtr function,the retainCount increases by one.After running out of the scope,this RetainPtr calls release for this MRR object.So the retainCount is one.In general, NS::TransferPtr takes the ownershipof an object for you.But NS::RetainPtr helps you retain an objectwhen you don't want it to be deallocated.When you pass an object to these two functions,NS::TransferPtr doesn't change the reference countbut NS::RetainPtr increases reference count by oneas it calls retain for you under the hood.The destructor of these two functionsboth call release for the passed-in objectand, therefore, reference count decreases by one.If the reference count hits zero,the object will be freed in runtime.Here's an example of NS::TransferPtr.When I talked about the render pass,which drew a single triangle,I needed this render pipeline state.Here are the calls to create a render pipeline state object.These are the attributes that a render pipeline descriptor needs.According to Cocoa's conventions,since these calls starts with new and alloc,I own these objects.So I need to call release for these objects.With NS::SharedPtr, I don't need to call releasefor those MRR objectsbecause NS::SharedPtrs takes the ownership of these objects.So here, I pass raw pointers to the TransferPtr function.After doing that, there's no need to call releaseas I did in the previous slide.If you are familiar with ARC,you may find that MRR used with NS::SharedPtris similar to using ARC.You may encounter use-after-free bugswhen handling memory manually.They occur when you are trying to use an objectwhich has been already released.NSZombie is a good way to check for those bugs.When use-after-free bugs occur,it triggers a breakpoint and provides you with a stack trace.You can enable Zombies very easilywith an environment variable.Just set NSZombieEnabled to YES.Or If you're using Xcode,you can enable Zombies in a scheme.Here's how it works.I want to create a new render pipeline state objectwith the same render pipeline settings.So in this newRenderPipelineState function,I reuse the pDesc object.After clicking on run, Xcode triggers a breakpointand shows me the stack trace.That means I got something wrong.Hm, what's the problem?Maybe NSZombie can help here, so I enable NSZombie in scheme.When I run the program again, NSZombie triggers a breakpoint.I get something new in the console output:"message sent to deallocated instance."Oh, I reused an object that I have already released.And it's the render pipeline descriptor.So I need to use this render pipeline descriptorbefore calling release.By doing that, I fix the problem.More tools and details are covered in this year's talk,"Profile and optimize your game's memory."For example, you can learn how to track retainCountin allocations in instruments.Feel free to check out other tools on Apple platforms.You will find out that they can help you debug your gameand improve performance.Now you know how to manage object lifecycles in metal-cpp.But you may still need to interface with other frameworks,like game controller and audio.These are still in Objective-C.How can you interface with those APIsand design an elegant application architecture?Say you wrote a ViewController in Objective-C,but you wrote a renderer in C++ with metal-cpp.You need to call renderer methods, like draw,from the ViewController.The challenge here is to nicely separate the two languagesbut have them work together.The solution is to create an adapter classwhich calls C++ from Objective-C files.By doing this, you can focus on Objective-C or C++in files where you implement features.For example,I can create a RendererAdapter class in Objective-C.And down in the implementation,I add an Objective-C method so that I can call itdirectly from the ViewController.Inside of the interface,I declare a C++ pointer to a renderer object.Inside the body of the method,I directly call the renderer's C++ method.This method needs to pass the MTK::Viewas a C++ object into the draw method,so it casts the view as a C++ typeby using the __bridge keyword.I'll talk more about this cast later.In contrast, you need to call MTKView which is writtenwith Objective-C in Renderer which is written with C++.It's challenging as well.Similarly, the solution is to create an adapter class.With this class, in C++ files,you can call Objective-C methods using C++ interface.For example, I can create a ViewAdapter class.I write the interfaces in C++,so in the Renderer class,I can call those C++ view methods easily.While in the implementation,I call Objective-C methods from MTKView,including currentDrawable and depthStencilTexture.You may notice there're some __bridge keywords here.I use them to cast between metal-cpp objectsand Objective-C objects.As you learned in the beginning,metal-cpp objects are manually retained and released,but objects created by Objective-Cuse automatic reference counting.You need to move objects from MRR to ARCand from ARC to MRR.Here are three types of bridge castingwhich can help you cast between Objective-C and C++.They can also help you transfer ownership_bridge casting casts between Objective-Cand metal-cpp objects.There is no transfer of ownership between them.__bridge_retained casting casts an Objective-C pointerto a metal-cpp pointer and takes the ownership from ARC.__bridge_transfer casting moves a metal-cpp pointerto Objective-C and transfers the ownership to ARC.Going back to the problem, you need to castbetween metal-cpp objects and Objective-C objects.If there's no transfer of ownership,you can use __bridge cast.If you want to cast from metal-cpp to Objective-C objectsand transfer the ownership to Objective-C,you should use __bridge_transfer cast.If you want to cast from Objective-C to metal-cpp objectsand take the ownership out of ARC,you should use __bridge_retained cast.Here's a case when I have to use MetalKitto leverage the asset loading code.That means in my C++ application,I need a texture as a metal-cpp object,but it is created by Objective-C methods.I need the ability to transfer ownership out of ARCso I can manually release it.And in this case,I need to pick __bridge_retained cast.I have this C++ function that loads a texture from the catalogand I want to return a metal-cpp texture.But inside, I'm calling some Objective-C functionsin MetalKit.I need to define the options that a texture loader needs.Then I create a texture loader by calling an Objective-C methodfrom MetalKit.With that loader, I can create a texture objectand load a texture from the catalog.This method is also an Objective-C methodfrom MetalKit.Now I have an Objective-C type texture,I need to cast it to the metal-cpp objectand take it out of ARC.With these steps in mind, it's time to code,and I'll show you how casting works in practice.First step is to define the texture loader optionsthat a texture loader needs.I can safely cast the metal-cpp storage mode and usageto the Objective-C type,as the metal-cpp type defines them to the same values.Here I create a texture loader.I have a device that is a metal-cpp object,and I need to pass it to the initWithDevice method.Because the metal-cpp object is an Objective-C object,I can cast it like a toll-free object.There is no transfer of ownership.Now I use the texture loader optionsand a texture loader to create a texture.And I want to return the loaded texture as a metal-cpp object.So I need to take it out of ARCand cast it to the corresponding pointer type.This is done with a __bridge_retained cast.After this, I can use this textureas any metal-cpp object.I am responsible for releasing it.In this section, I provided an adapter patternwhich can help you handle two different languagesin your program.I also showed how to interface with Objective-C and C++with three types of casts.To summarize, metal-cpp is a lightweightand very efficient Metal C++ wrapper.I talked about how to manage object lifecycleswhen using metal-cpp,how to interface with Objective-Cin an elegant manner,and how our developer tools can help you debug.Download metal-cpp and play with all the amazing samples now!See what you can create with Metal.We look forward to seeing your C++ applicationsrunning across all Apple platforms.Thanks for watching!♪

♪ Mellow instrumental hip-hop music ♪♪Hi, my name is Keyi Yu,and I'm an engineer from the Metal Ecosystem team.Today, it's my pleasure to introduce metal-cpp.We created metal-cpp for anyone who uses C++ and wants to buildMetal applications for Apple platforms.Metal-cpp is a low-overhead librarythat connects your C++ applications to Metal.First, I'll start with an overview of what metal-cpp isand how it works, and then I'll cover some detailsabout the lifecycles for Objective-C objects.C++ and Objective-C handle lifecycles a bit differently,and I'll show you how to handle those differences.Xcode and metal-cpp have some great utilitiesthat can help you manage the object lifecyclesin your apps.And finally, I'll show you how to integrate C++ codewith Objective-C classes.So here's a look at metal-cpp and how it works.Metal is the foundation for accelerated graphicsand compute on Apple platforms, enabling your apps and gamesto tap into the incredible power of the GPU.It was originally designed using the powerful featuresand the conventions offered by Objective-C.But if your code base is in C++, you may need something to bridgebetween your code and Metal's Objective-C code.Introducing metal-cpp!It serves as a hub between your C++ applicationand Objective-C Metal.With metal-cpp in your application,you can use Metal classes and functions in C++,and metal-cpp can help you call Objective-C functionsin runtime.metal-cpp is a lightweight Metal C++ wrapper.I say it's lightweight, because it's implementedas a header-only library with inline function calls.It provides 100 percent coverage of the Metal APIby implementing a one-to-one mapping of C++ callsto Objective-C APIs.To do this, metal-cpp wraps parts of the Foundationand CoreAnimation frameworks.It's open source under Apache 2 License,so you can modify the library and include itto your applications, easily.metal-cpp uses C to call directlyinto the Objective-C runtime.This is the exact same mechanism that the Objective-C compileruses to execute Objective-C methods.So this wrapper introduces little overhead.Since metal-cpp implements a one-to-one mapping of C++to Objective-C calls,it follows the same Cocoa memory-management rules.I will discuss this in more detail later.This one-to-one mapping also allowsall of the developer tools to work seamlessly,including GPU Frame Capture and the Xcode debugger.These are the series of calls necessary to draw a trianglewith metal-cpp.If you are familiar with C++, it's a good time to learn Metal,because you don't need to worry about language syntax.If you've already used Metal with Objective-C,in terms of function calls, there's very little differencebetween the Objective-C interface of Metaland metal-cpp.I am going to demonstrate how easy it is to use metal-cpp.First, I create a command buffer,which I will fill with commands for the GPU to execute.I can simply use the raw pointer in C++as a mapping to ID in Objective-C.I can create a render command encoderand write render commands with a command buffer.The C++ function renderCommandEncoderand the Objective-C methodrenderCommandEncoder WithDescriptor are the same.The only differences are the name conventionsof the languages.I then set a render pipeline state objectwhich contains the vertex and fragment shadersand various other rendering states.Then I encode my draw call to render a single triangle.Then I indicate thatI've finished encoding render commands.I present the drawable, so the triangle is displayed onscreen.Finally, I commit my command buffer.This tells the GPU that it can begin executing my commands.Obviously, metal-cpp and Objective-C Metalare almost the same.You don't need to worry about language syntax nowwith metal-cpp,you can directly look into the Metal documentationto learn the concepts and usage of Metal.You may have already playedwith this deferred lighting sample before.We now provide a new version of this deferred lighting samplewhich uses metal-cpp.We hope this can help you learn how to code with metal-cppin practice.I'm also excited to introduce a seriesof incremental C++ samples that introduces the Metal APIand shows you how to accomplish different tasks with it.

So now that you know a little bit about metal-cpp,how do you actually use it?We published metal-cpp last year.Here's the webpage where you can find the downloadsand instructions.Let me show you the steps you will need to take.After downloading metal-cpp,you should tell Xcode where to find it.Here, I put metal-cpp under the current project.Then, you need to set C++17 or higheras the C++ language dialect.Next, add three frameworks to the project:Foundation, QuartzCore, and Metal.Now there's only one thing left to dobefore using C++ interfaces of those frameworks.There are three headers in metal-cpp.Since metal-cpp is a header-only library,you need to generate their implementationsbefore importing the header files.To do this, define three macros: NS_PRIVATE_IMPLEMENTATION,CA_PRIVATE_IMPLEMENTATION, AND MTL_PRIVATE_IMPLEMENTATION.If you are interested in what metal-cpp does with the macrosunder the hood,please check out header bridge files in the metal-cpp folder.You can use the headers separatelyor put them in a single header.You can import the header files whenever you need them.But remember, do not define the NS, CA,or MTL_PRIVATE_IMPLEMENTATION macros more than once.Otherwise, you may cause duplicate definition errors.To use metal-cpp effectively,you'll need to know Cocoa's memory management rules,how to use the great utilities that can help youmanage object lifecycles, and how to designyour application architecture when you interfacewith other frameworks.I'll start with object lifecycle management.During your application's operation,you typically need to allocate and release memory.You also need to manage command buffers,pipeline objects, and resources.To help manage this memory,Objective-C and Cocoa objects include a reference count.This is also present in metal-cpp.Reference counting helps you manage your memory.Using reference counting,all objects contain a retainCount property.Components in an app increase the countto keep objects they're interacting with aliveand decrease it when they are done with them.When the retainCount hits zero,the runtime deallocates the object.There are two types of reference counting in Objective-C.One is called Manual Retain-Release -- MRR;the other is Automatic Reference Counting -- ARC.When compiling code with the ARC feature,the compiler takes the references you createand automatically inserts callsto the underlying memory-management mechanism.metal-cpp objects are manually retained and released.So you need to understand Cocoa's conventionsto know when to retain and release objects.Unlike creating objects in C++, metal-cpp objectsare neither created with new nor destroyed with delete.With Cocoa's conventions, you own any object you createwith methods starting with the alloc, new, copy,mutableCopy, or create.You can take ownership of an object using retain.When you no longer need it, you must relinquish ownershipof an object you own.You can release it immediately or release it afterwards.You must not relinquish ownership of an objectyou do not own as you risk a double free.Next, I'll walk through an exampleof these Cocoa conventions.In class A, a method uses alloc to create an objectand init to initialize this object.Remember, never call init on an object twice.Class A takes the ownershipand is responsible for deallocating it.Now the retain count for this object is one.Next, class B uses retain to get the objectand takes ownership of this object.So far, I have two objects that share the ownershipof this object represented by the orange cube.The retain count increases by one.

Class A doesn't need this object anymore,so class A should manually call release for it.As a result, the retain count decreases by one.Now, only class B owns the object.OK, finally, class B wants to release this object too.Now the retain count is zero, so the runtime frees the object.Here's a situation where a method in class Breturns an object.You still need this object in the rest of the programs.In other words, you want to relinquish ownershipof an object in a method in class B,but you don't want it to be deallocated immediately.In this case, you should call autorelease in class B.The retain count is still one after you call autorelease,and thus, you can still use the object later.Here's the question:since class B does not own this object anymore,who is responsible for deallocating it?The Foundation Framework provides an important object,called the AutoreleasePool.The Autorelease API puts the object into an AutoreleasePool.Now, the AutoreleasePool takes the ownership of the object.The AutoreleasePool decrements the receiver's retain countwhen the AutoreleasePool is destroyed.You are not the only one who can create autoreleased objects.Metal creates several autoreleased objectsas part of its operation.All methods that create temporary objectsadd them to AutoreleasePoolsby calling autorelease under the hood.It is the AutoreleasePool's responsibility to release them.In other words, with an AutoreleasePool,you can code in a more elegant way.You can have an AutoreleasePool for the main application.We also encourage you to create and manageadditional AutoreleasePools at smaller scopesto reduce your program's working set.You also need AutoreleasePools for every thread you create.Here's an example showing how to use an AutoreleasePooland autoreleased objects.In this sample, an AutoreleasePoolis created by alloc, which means you take the ownershipand it should be manually released.Now we have an AutoreleasePool.As we discussed in the beginning,you should create a command buffer.It's not created with alloc or create,so you don't own it.Instead, it's an autoreleased object created by Metal.This command buffer will be put into the AutoreleasePool.It's the AutoreleasePool's responsibility to deallocate it.You can use it as you wishuntil you release the AutoreleasePool.Then you need to create a RenderPassDescriptor.This RenderPassDescriptor will be put into the AutoreleasePoolas well.Same to RenderCommandEncoder.It's also an autoreleased object created by Metal.Don't forget this currentDrawable object.It will be put into the AutoreleasePool too.At the end of the piece of code, I use pPool->releaseto release the AutoreleasePool.Before being deallocated, the AutoreleasePoolreleases everything that it owns,in this case, it releases the CommandBuffer,RenderPassDescriptor, RenderCommandEncoder,and currentDrawable.Then the AutoreleasePool is released.So far, you got to know Cocoa's conventions,autoreleased objects, and AutoreleasePools.It's important to correctly manage object lifecyclesto avoid memory leaks and zombie objects,and we have great tools to help you avoidand debug these issues.I'll focus on two utilities:NS::SharedPtr and NSZombie.NS::SharedPtr is a new utility that can help you managethe object lifecycle.You can find it under Foundation frameworkin the metal-cpp folder.Notice that it is not exactly the sameas std:shared_ptr.So there's no dependency on the C++ standard libraryand no extra cost on storing the reference count.Here's what NS::SharedPtr is like.Transfer and retain functions clearly expressthe intent of consuming an object.Transfer creates a SharedPtrwithout increasing the pointee's referenceCount,effectively transferring ownership to the SharedPtr.The retain function sends a retain to the passed-in object.Use this function to keep alive objectsthat are in AutoreleasePoolsand to express that the pointer's ownerhas a vested interest in the pointee's lifecycle.You can access the underlying objectas expected via get and via the operator->.SharedPtr copy, move, construction,and assignment work as expected,with copy increasing the retainCount.Moves are fast and do not affect the retain countin the general case.SharedPtrs always send exactly one releaseto the pointee on destruction.You can avoid this if you wantby calling the detach function.Going back to the top,it's important to know the differences betweencreating a pointer by transferring or retaining it.So for TransferPtr,suppose I have an MRR object, with a reference count of 1.After I pass it to the TransferPtr function,the SharedPtr takes ownership of the object,but its retainCount doesn't change.When the pointer goes out of scope,the SharedPtr's destructor runsand calls release on the MRR object,which decrements the retainCount to 0.Another function is NS::RetainPtr.When you want to avoid deallocating an objectbecause you want to use it later,you should use NS::RetainPtr.Suppose we have this MRR object; the retainCount is one.After we pass it to the RetainPtr function,the retainCount increases by one.After running out of the scope,this RetainPtr calls release for this MRR object.So the retainCount is one.In general, NS::TransferPtr takes the ownershipof an object for you.But NS::RetainPtr helps you retain an objectwhen you don't want it to be deallocated.When you pass an object to these two functions,NS::TransferPtr doesn't change the reference countbut NS::RetainPtr increases reference count by oneas it calls retain for you under the hood.The destructor of these two functionsboth call release for the passed-in objectand, therefore, reference count decreases by one.If the reference count hits zero,the object will be freed in runtime.Here's an example of NS::TransferPtr.When I talked about the render pass,which drew a single triangle,I needed this render pipeline state.Here are the calls to create a render pipeline state object.These are the attributes that a render pipeline descriptor needs.According to Cocoa's conventions,since these calls starts with new and alloc,I own these objects.So I need to call release for these objects.With NS::SharedPtr, I don't need to call releasefor those MRR objectsbecause NS::SharedPtrs takes the ownership of these objects.So here, I pass raw pointers to the TransferPtr function.After doing that, there's no need to call releaseas I did in the previous slide.If you are familiar with ARC,you may find that MRR used with NS::SharedPtris similar to using ARC.You may encounter use-after-free bugswhen handling memory manually.They occur when you are trying to use an objectwhich has been already released.NSZombie is a good way to check for those bugs.When use-after-free bugs occur,it triggers a breakpoint and provides you with a stack trace.You can enable Zombies very easilywith an environment variable.Just set NSZombieEnabled to YES.Or If you're using Xcode,you can enable Zombies in a scheme.Here's how it works.I want to create a new render pipeline state objectwith the same render pipeline settings.So in this newRenderPipelineState function,I reuse the pDesc object.

After clicking on run, Xcode triggers a breakpointand shows me the stack trace.That means I got something wrong.Hm, what's the problem?Maybe NSZombie can help here, so I enable NSZombie in scheme.

When I run the program again, NSZombie triggers a breakpoint.I get something new in the console output:"message sent to deallocated instance."Oh, I reused an object that I have already released.And it's the render pipeline descriptor.So I need to use this render pipeline descriptorbefore calling release.By doing that, I fix the problem.More tools and details are covered in this year's talk,"Profile and optimize your game's memory."For example, you can learn how to track retainCountin allocations in instruments.Feel free to check out other tools on Apple platforms.You will find out that they can help you debug your gameand improve performance.Now you know how to manage object lifecycles in metal-cpp.But you may still need to interface with other frameworks,like game controller and audio.These are still in Objective-C.How can you interface with those APIsand design an elegant application architecture?Say you wrote a ViewController in Objective-C,but you wrote a renderer in C++ with metal-cpp.You need to call renderer methods, like draw,from the ViewController.The challenge here is to nicely separate the two languagesbut have them work together.The solution is to create an adapter classwhich calls C++ from Objective-C files.By doing this, you can focus on Objective-C or C++in files where you implement features.For example,I can create a RendererAdapter class in Objective-C.And down in the implementation,I add an Objective-C method so that I can call itdirectly from the ViewController.Inside of the interface,I declare a C++ pointer to a renderer object.Inside the body of the method,I directly call the renderer's C++ method.This method needs to pass the MTK::Viewas a C++ object into the draw method,so it casts the view as a C++ typeby using the __bridge keyword.I'll talk more about this cast later.In contrast, you need to call MTKView which is writtenwith Objective-C in Renderer which is written with C++.It's challenging as well.Similarly, the solution is to create an adapter class.With this class, in C++ files,you can call Objective-C methods using C++ interface.For example, I can create a ViewAdapter class.I write the interfaces in C++,so in the Renderer class,I can call those C++ view methods easily.While in the implementation,I call Objective-C methods from MTKView,including currentDrawable and depthStencilTexture.You may notice there're some __bridge keywords here.I use them to cast between metal-cpp objectsand Objective-C objects.As you learned in the beginning,metal-cpp objects are manually retained and released,but objects created by Objective-Cuse automatic reference counting.You need to move objects from MRR to ARCand from ARC to MRR.Here are three types of bridge castingwhich can help you cast between Objective-C and C++.They can also help you transfer ownership_bridge casting casts between Objective-Cand metal-cpp objects.There is no transfer of ownership between them.__bridge_retained casting casts an Objective-C pointerto a metal-cpp pointer and takes the ownership from ARC.__bridge_transfer casting moves a metal-cpp pointerto Objective-C and transfers the ownership to ARC.Going back to the problem, you need to castbetween metal-cpp objects and Objective-C objects.If there's no transfer of ownership,you can use __bridge cast.If you want to cast from metal-cpp to Objective-C objectsand transfer the ownership to Objective-C,you should use __bridge_transfer cast.If you want to cast from Objective-C to metal-cpp objectsand take the ownership out of ARC,you should use __bridge_retained cast.Here's a case when I have to use MetalKitto leverage the asset loading code.That means in my C++ application,I need a texture as a metal-cpp object,but it is created by Objective-C methods.I need the ability to transfer ownership out of ARCso I can manually release it.And in this case,I need to pick __bridge_retained cast.I have this C++ function that loads a texture from the catalogand I want to return a metal-cpp texture.But inside, I'm calling some Objective-C functionsin MetalKit.I need to define the options that a texture loader needs.Then I create a texture loader by calling an Objective-C methodfrom MetalKit.With that loader, I can create a texture objectand load a texture from the catalog.This method is also an Objective-C methodfrom MetalKit.Now I have an Objective-C type texture,I need to cast it to the metal-cpp objectand take it out of ARC.With these steps in mind, it's time to code,and I'll show you how casting works in practice.First step is to define the texture loader optionsthat a texture loader needs.I can safely cast the metal-cpp storage mode and usageto the Objective-C type,as the metal-cpp type defines them to the same values.Here I create a texture loader.I have a device that is a metal-cpp object,and I need to pass it to the initWithDevice method.Because the metal-cpp object is an Objective-C object,I can cast it like a toll-free object.There is no transfer of ownership.Now I use the texture loader optionsand a texture loader to create a texture.And I want to return the loaded texture as a metal-cpp object.So I need to take it out of ARCand cast it to the corresponding pointer type.This is done with a __bridge_retained cast.After this, I can use this textureas any metal-cpp object.I am responsible for releasing it.In this section, I provided an adapter patternwhich can help you handle two different languagesin your program.I also showed how to interface with Objective-C and C++with three types of casts.To summarize, metal-cpp is a lightweightand very efficient Metal C++ wrapper.I talked about how to manage object lifecycleswhen using metal-cpp,how to interface with Objective-Cin an elegant manner,and how our developer tools can help you debug.Download metal-cpp and play with all the amazing samples now!See what you can create with Metal.We look forward to seeing your C++ applicationsrunning across all Apple platforms.Thanks for watching!♪

3:10 -Draw a single triangle in C++

3:27 -Draw a single triangle in Objective-C

6:10 -Generate the implementation

11:46 -How to use autoreleased objects and AutoreleasePool

11:47 -How NS::TransferPtr works

17:19 -How NS::RetainPtr works

20:43 -Create an adapter class calling C++ from Objective-C files

21:49 -Create an adapter class calling Objective-C from C++ files

24:59 -Cast between Objective-C and C++ objects and transfer ownership

## Code Samples

```swift
MTL::CommandBuffer* pCmd = _pCommandQueue->
commandBuffer
();
MTL::RenderCommandEncoder* pEnc = pCmd->
renderCommandEncoder
( pRpd );
pEnc->
setRenderPipelineState
( _pPSO );
pEnc->
drawPrimitives
( MTL::PrimitiveTypeTriangle, 
                      NS::
UInteger
(
0
), 
                      NS::
UInteger
(
3
));
pEnc->
endEncoding
();
pCmd->
presentDrawable
( pView->
currentDrawable
() );
pCmd->
commit
();
```

```swift
id
<
MTLCommandBuffer
> cmd = [_commandQueue commandBuffer];

id
<
MTLRenderCommandEncoder
> enc = [cmd renderCommandEncoderWithDescriptor:pRpd];
[enc setRenderPipelineState:_pPSO];
[enc drawPrimitives:
MTLPrimitiveTypeTriangle
 
        vertexStart:
0
 
        vertexCount:
3
];
[enc endEncoding];
[cmd presentDrawable:view.currentDrawable];
[cmd commit];
```

```swift
#
define
 NS_PRIVATE_IMPLEMENTATION


#
define
 CA_PRIVATE_IMPLEMENTATION


#
define
 MTL_PRIVATE_IMPLEMENTATION



#
include
 
<Foundation/Foundation.hpp>


#
include
 
<Metal/Metal.hpp>


#
include
 
<QuartzCore/QuartzCore.hpp>
```

```swift
NS::AutoreleasePool* pPool = NS::AutoreleasePool::
alloc
()->
init
();
MTL::CommandBuffer* pCmd = _pCommandQueue->
commandBuffer
();
MTL::RenderPassDescriptor* pRpd = pView->
currentRenderPassDescriptor
();
MTL::RenderCommandEncoder* pEnc = pCmd->
renderCommandEncoder
( pRpd );
pEnc->
endEncoding
();
pCmd->
presentDrawable
( pView->
currentDrawable
() );
pCmd->
commit
();
pPool->
release
();
```

```swift
{
   
auto
 ptr = NS::
TransferPtr
( pMRR );
   
// Do something with ptr 

   . . . 
}
```

```swift
{
   
auto
 ptr = NS::
RetainPtr
( pMRR );
   
// Do something with ptr 

   . . . 
}
```

```swift
@interface
 
AAPLRendererAdapter
 () 

{
    AAPLRenderer* _pRenderer;
}

@end



@implementation
 
AAPLRendererAdapter

- (
void
)drawInMTKView:(
MTKView
 *)pMtkView
{
    _pRenderer->draw((__bridge MTK::View*)pMtkView);
}


@end
```

```swift
CA::MetalDrawable* 
AAPLViewAdapter::currentDrawable
()
 
const


{
    
return
 (__bridge CA::MetalDrawable*)[(__bridge MTKView *)m_pMTKView currentDrawable];
}


MTL::Texture* 
AAPLViewAdapter::depthStencilTexture
()
 
const


{
    
return
 (__bridge MTL::Texture*)[(__bridge MTKView *)m_pMTKView depthStencilTexture];
}
```

```swift
MTL::Texture* 
newTextureFromCatalog
( MTL::Device* pDevice, 
const
 
char
* name,   
                                     MTL::StorageMode storageMode, MTL::TextureUsage usage )


{
    NSDictionary<MTKTextureLoaderOption, id>* options = @{
            MTKTextureLoaderOptionTextureStorageMode : @( (MTLStorageMode)storageMode ),
            MTKTextureLoaderOptionTextureUsage : @( (MTLTextureUsage)usage )
    };

    MTKTextureLoader* textureLoader = [[MTKTextureLoader alloc] 
                                        initWithDevice:(__bridge id<MTLDevice>)pDevice];
    
    NSError* __autoreleasing err = nil;
    id< MTLTexture > texture = [textureLoader 
                        newTextureWithName:[NSString stringWithUTF8String:name] 
                               scaleFactor:
1
 
                                            bundle:nil 
                                           options:options 
                                             error:&err];

    
return
 (__bridge_retained MTL::Texture*)texture;
}
```


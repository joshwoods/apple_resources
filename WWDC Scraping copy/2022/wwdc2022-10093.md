# Wwdc2022 10093

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Integrate your custom collaboration app with MessagesDiscover how the SharedWithYou framework can augment your app's collaboration infrastructure. We'll show you how to send secure invitations to collaborative content and synchronize participant changes. We'll also cover displaying content updates within the relevant conversation.

For an introduction to SharedWithYou, watch "Add Shared with You to your app" from WWDC22. For an overview of the collaboration UI APIs, watch "Enhance collaboration experiences with Messages" from WWDC22.

(Note: API will be available in an upcoming beta.)ResourcesHD VideoSD VideoRelated VideosWWDC22Add Shared with You to your appEnhance collaboration experiences with MessagesMeet TransferableWhat's new in AppKitWhat's new in SwiftUI

Discover how the SharedWithYou framework can augment your app's collaboration infrastructure. We'll show you how to send secure invitations to collaborative content and synchronize participant changes. We'll also cover displaying content updates within the relevant conversation.

For an introduction to SharedWithYou, watch "Add Shared with You to your app" from WWDC22. For an overview of the collaboration UI APIs, watch "Enhance collaboration experiences with Messages" from WWDC22.

(Note: API will be available in an upcoming beta.)

HD VideoSD Video

HD Video

SD Video

Add Shared with You to your app

Enhance collaboration experiences with Messages

Meet Transferable

What's new in AppKit

What's new in SwiftUI

Search this video…♪ Mellow instrumental hip-hop music ♪♪Devin Clary: Hi. I'm Devin, an engineer on the Messages team.Lance Parker: And I'm Lance, also a Messages engineer.Devin: Welcome to "Integrate your custom collaboration appwith Messages."Collaboration starts with a conversation,and in iOS 16 and macOS Ventura,you can bring your app's custom collaboration experienceright into the fabric of the conversation.In this video, we'll go over the life cycle of a collaboration.Then, we'll show you how to prepareyour app's collaborative content to be shared through Messages.Next, we'll give you everything you need to instantly verifyrecipient access, and respond to participant changes,all without compromising privacy.Finally, we'll show you how your app can post noticesabout the content right to the Messages conversation.This video assumes your apphas existing collaboration infrastructure,and has already adopted universal links.We'll also build on some concepts introduced in"Add Shared with You to your app"and "Enhance collaboration experiences with Messages."First up, I'll go over the life cycleof a custom collaboration messageto illustrate how this API allows your usersto start collaborating faster than ever.When a user decides to share a collaborationfrom your app through Messages,you first create metadata to represent the content.The metadata includes share options the user can configureprior to sending the message,and a number of other properties you can customize.Next, you provide that metadata to the share sheet,or to drag and drop.This allows a draft of the content to be stagedin the Messages compose field.The collaboration needs to be represented by a universal link.That can be created immediately, but it's best deferreduntil right before the message is sent.This is useful if your app's link creationdepends on the selected share options, or recipients,as configured in the Messages compose field.The user chooses the recipients and share optionsand taps the send button.Before the message is sent,Messages asks your app for the universal linkand a device independent identifier for the content.Using that identifier, Messages provides a set ofcryptographic identities representing the recipientsof that specific collaboration message.Your app will use these identities laterto allow the recipients to immediately open the linkon any of their devices.Your app stores those identities on its serversand associates them with the shared content.Once your app finishes this step,the message is sent to the recipients.Now, here's what happens on the receiving device.The goal is to instantly verify access,pairing a recipient identity with an account on your server.When the recipient opens the link,your app receives a call to open the URL,just like it does for any other link.When your app detects that a user accountdoesn't yet have access to the document,it queries the system for a proof of user identitycryptographically signed by the recipient device.Your app sends that signed identity proofto your server for validation.If the signature is valid, the server compares the proofagainst the identities previously providedby the sending device.If there's a match, your server grants accessto the user's account.And with that, the recipient has gainedinstant and secure access to the content,all without exchanging account information!And that's the life cycle of a collaboration message!Next, let's look more closelyat the API for starting a collaboration.The system needs some metadata about the collaboration.And for that, you use a new classin the Shared with You framework called SWCollaborationMetadata.This class has a few properties for you to configure:the content's title, a local identifierto reference the content before its been shared;the initiator name and account handle,to provide transparency to the userabout the account they're sharing from;and the default share options, for the user to configure.Here's how to create a metadata objectand configure its properties.Create a local identifier using SWLocalCollaborationIdentifierinitialized with a string.The string only needs to be sufficient for your appto identify the content locally, not across devices.Initialize a new metadata instanceusing the local identifier.Set the content title, the initiator's account handle,and their name using PersonNameComponentsfrom the foundation framework.The handle and name are only displayed locallyso the user can confirm the account they're sharing from.Next, set the defaultShareOptions.Before I show you how to do that,I'll first describe how options work.Share options are the settings a user configureson the collaboration in Messages or the share sheet.The options selected by the user are provided to youbefore the message is sent.Share options might include settings likewho can make edits to a collaborationor who should have access to the content.You use a few classes to define options,starting with SWCollaborationOption.Depending on how they're grouped,options represent individual switches,or mutually exclusive values for a setting.Options have a title and an identifier,and they are either selected or unselected.There are two classes to represent a group of options:SWCollaborationOptionsGroupand SWCollaborationOptions PickerGroup.You use SWCollaborationOptionsGroupto represent a collection of switches,while SWCollaborationOptions PickerGrouprepresents mutually exclusive values for a setting.Finally, SWCollaborationShareOptionsdefines the full set of option groups,to be set on the metadata's defaultShareOptions property.You can also provide a summary string to describe the options.Now that I've described the option classes,here's an example showing how to use them.This code defines two option groups.The first group is initialized with an identifierand two possible options.The identifier is an arbitrary stringyou later use to identify which option was selected by the user.Since this is a picker group,the options are mutually exclusive.This group represents the permission settingsfor the content: readwrite or readonly.Then, the first option in that group is selected by default.And the title is set to a string describing this group.The second option group is initialized the same way,and also contains two options.But since this is a generic option group,the user will be able to configurewhether to allow mentions and comments independently.Finally, the two option groups are used to initializean instance of SWCollaborationShareOptions,which is then set on the metadata.Next, the metadata is provided to the share sheetor drag and drop, depending on how the userdecides to share the content.If your app uses SwiftUI, SWCollaborationMetadatais compatible with the new ShareLink API.Watch "Meet Transferable" and "What's new in SwiftUI"to learn more about Transferable and ShareLink.Here's how easy it is to support collaborationon a proxy representation in SwiftUI!From within a Transferable model object,set up a ProxyRepresentationto return a collaboration metadata instance.Then, from a view,initialize ShareLink with that model object.For UIKit and AppKit apps, you use NSItemProviderto support sharing.And SWCollaborationMetadata conforms toNSItemProviderReading and writing.So you simply register a metadata instancewith an item provider, to support collaboration.It's also good practiceto register multiple representations of the contentto support sharing through as many channels as possible.For example, Messages automaticallyoffers an option to send the content as a copyif you provide a file representation.You'll use the NSItemProvider API withUIActivityViewController and UIDragItem on iOS and iPadOSand NSSharingServicePicker on macOS.Here's how to set that up with the share sheet on iOS.Create an NSItemProvider instance.Register the collaboration metadatacreated in the previous example,with visibility set to all processes on the system.Initialize UIActivityItemsConfigurationwith the item provider,then initialize UIActivityViewControllerwith that configuration.And finally, present the view controller.It's just as easy to support drag and drop.Initialize NSItemProviderand register the metadata the same way,then create a UIDragItem with the item providerto use with the drag and drop APIs.The API is similar on macOS for the sharing popover.Again, set up the item provider.And this time, use it to initializeNSSharingServicePicker.And then show the picker relative to a target view.Drag and drop on macOS utilizes NSPasteboardItemrather than NSItemProvider.To support this, SharedWithYou exportsan NSPasteboardItem extension.Using that extension, set the collaboration metadatadirectly on a new NSPasteboardItem instancein order to support drag and drop.And that's all you need for a draftof your collaborative content to be staged in Messages!Next, when the user taps the send button,the system coordinates with your app to set up the share.It does this through a new class calledSWCollaborationCoordinator.SWCollaborationCoordinator is a singleton,meaning there is a global shared instance.That shared instance coordinates the collaborationthrough a delegate you define called an actionHandler.To ensure your app is always availableto coordinate collaborations,it will be launched in the background when needed.So you should register the delegate soon after launchand handle actions immediately to avoid timeouts.Here's how to set up the collaboration coordinatorafter your app finishes launching.Access the singleton coordinator instancethrough the shared property.Then, in the app delegate'sdidFinishLaunchingWithOptions method,set the actionHandler propertyto an object that conforms to theSWCollaborationActionHandler protocol.The action handler protocol uses a new classcalled SWAction.SWActions represent work your app is expected to perform.You fulfill actions to mark them as complete,and fail them otherwise.The first action your app needs to handleis the start collaboration action.SWStartCollaborationActioncontains the collaboration metadata you set up earlier,updated with the user's selected share options.Once you've performed the necessary setup,you fulfill the start action with the universal linkand a device-independent identifierfor the collaboration.If you explicitly fail the start action,the message is canceled.Here's an implementation to handle the start actionusing an example server request.First, retrieve the local identifier,and user-selected share optionsfrom the action's metadata property.Set up a server request to prepare the collaborationusing the identifier and options.Then, send the request to the server.This example uses async await.Finally, fulfill the action with the universal linkand the device independent identifier from the response.Or, if there was an error,fail the action to cancel the message.If the start action was successful,the system sends your app a second actionto update the collaboration participants.The SWUpdateCollaboration ParticipantsActioncontains the cryptographic identitiesfor the participants.The identities are derived from the collaboration identifierfulfilled by the start action in the previous step.Store the identities on your serverassociated with the content.You'll use this data for verifying accesson the recipient devices.Finally, fulfilling this actionwill send the universal link in Messages.This example shows how to handlethe update participants action.Retrieve the collaboration identifierfrom the action's metadata.This is the identifier you fulfilledwhile handling the start action.Next, retrieve the participant data to store on your serversusing the action's addedIdentities property.Each identity has a Data property called a root hash.This is the data you should store on your serverfor later use.Lance will go over more of the detailsabout this property in the Verifying Access section.Set up another server request, this time to addthe participants to the collaborationwith the target identifier.And just like before, send the request to your server,and fulfill or fail the action.This time, the fulfill method does not take any parameters.Now that you've set up the collaboration,your app has everything it needs to grant immediate accessto the recipients of the message.I'll hand it over to Lance to show you how to do that!Lance: Thanks, Devin. In this section,I'll show how to provide immediate accessto the recipients using the identity datayou stored on your server in the previous step.The rootHash property on SWPersonIdentityis used to do this verification.A rootHash is a secure value used to uniquely identifya participant on their devices.In order to perform verification,you'll need to understand how to compute a root hash.I'll take you through that now.When a collaboration message is sent,it's actually sent individually to each of a person's devices.Messages identifies each deviceusing a cryptographic public key.Since the goal is to allow accessonly on this set of devices, the root hash is derivedfrom the set of public keys registered to each recipient.The root hash is the root node of a data structurecalled a Merkle tree.A Merkle tree is a binary tree that is builtby performing a sequence of hashing operations.In order to derive an identity for the user based on theirpublic keys, the keys are used as the leaves of this tree.The hashing algorithm used in the Merkle tree ensuresthat the root node can only be computed from that set of keys.In this example, this user has three devicesand three public keys.The keys will be unique for each collaboration identifierprovided by your app,using a process called key diversification.To prevent tracking the number of devices registered to a user,the set is padded with random keys up to a fixed size.The leaf nodes of the tree are created by hashingthe padded set of diversified keys.The SHA256 algorithm is used for the hashing operationsin this tree.Then, each pair of leaf nodes are concatenatedand then hashed to derive their parent nodes.This process is repeated with the parent nodesand repeated again until a single root node remains.This is the root hash used to uniquely representthis recipient's identity across their devices.Notice that it's possible to generate a root hashusing a subset of the nodes from a complete Merkle tree.The root hash in this tree can be reproduced using justthe hashes H4, 7, and 11,along with the diversified public key P3.First, hash the public key to get the missing leaf node H3.Use H3 and H4 to generate H8.Use the given H7 node with H8 to generate H10.And finally, H10 and H11 produce the root hash.It's important to note that you can prove the public key P3was used to generate a given root hash,without needing to reconstruct the entire tree.The subset of nodes needed to do this is calleda proof of inclusion.Verification begins when a universal linkis opened in your app.To do this, you first need to checkthat the link is collaborative.SWCollaborationHighlight represents a collaborative linkand is retrieved from SWHighlightCenter.Use that collaboration highlightto generate the proof of inclusion.To represent a proof of inclusion,use a class called SWPersonIdentityProof.To perform verification, you'll first generatethis object along with a cryptographic signatureto send to your server.Retrieve the proof using the getSignedIdentityProof methodon SWHighlightCenter.It takes an SWCollaborationHighlightand some arbitrary data to be signed by the device.Use the signature to ensure the request cannot be replayedby a bad actor to gain access to your collaboration.The data could be a challenge you request from your server,or a nonce generated on the device.This example uses the challenge approach.The URL is passed to this method on your app'sUIApplicationDelegate.This URL is the universal linkassociated with the collaboration.The URL is used to fetch the associatedSWCollaborationHighlight from the SWHighlightCenter.Next, I'll request the challenge from my server,and pass the data I get backto the getSignedIdentityProof method on SWHighlightCenter,along with the highlight.This method returns a signed identity proof.I'll discuss what your server should doto validate this data later on.Now I can send the signed proof to my server for verification.Finally, I update my user interface with the result.The app sends the proof to the server,along with the public key and the signed data.The data is signed using the elliptic curvedigital signature algorithm over the P-256 elliptic curve,using SHA256 as a hash function.Verify the signature on the datausing the public key in the identity proof.You can do this with most commonly usedencryption libraries.Once you have verified the signature,you can trust that the identity proof was sentfrom the device associated with that public key.Next, you use the identity proof to recompute the root hash.Here is an example of what an SWPersonIdentityProofwould contain using the example tree we looked at before.Use it to reconstruct the root hash of a Merkle tree.The public key is P3.The inclusion hashes are H4, 7, and 11.A local key index of 2 indicates the positionof the public key in the tree.Here is an example implementation that reconstructsa root hash from the properties on the proof.A recursive algorithm works nicely when workingwith tree data structures, so that's what I've done here.On the initial invocation, pass in the hash of the public key,the set of inclusion hashes, and the public key index.Next, the first inclusion hash is pulled out.The public key index is checked to see if the keyis on the left or the right of its sibling.The selected hashes are concatenatedin the correct order, and then hashed.Next, the consumed node in the inclusionHashes arrayis removed, and the rest are passedto a recursive call to this same function.The public key index is also updatedso that it's ready for the next node in the tree.With this simple function, you can quickly computea root hash given an identity proof.The server can now check that this generated root hashis in the list of root hashes the owner of the documentuploaded during sending.The hash is present in the list of known hashes,so the server can grant access to the document.Now you can grant access to the document with confidence!To recap the steps you'll follow to verify an identity:first, look up the collaboration highlightfor your content while handling its universal link.Next, sign some data and retrieve the proof of inclusion.Send the signed data and proof to your server.Verify the signature on the data.Using the proof of inclusion, generate the root hash.Finally, compare the root hash to the list of known identitiesassociated with that content.Now that you know all about verifying accessto your collaboration links, I'll talk abouthow to coordinate participant changes with Messages.When the participants in a Messages group change,and that group is collaborating together,a user can choose to propagate those changes to your app,right from a banner in the Messages thread.In this scenario, your app receives anotherSWUpdateCollaboration ParticipantsActioncontaining the added and removed identities.You'll use the same code you wrote to handle this actionwhen setting up a collaboration,but you'll also need to handle removed participants.For removal, simply look up any account associatedwith a removed identity and revoke their access.If no account is yet associated,simply delete the root hash from your database.Here's the implementation forthe update participants action that Devin went over earlier.This example usesthe removed identities property on the actionand passes them to a similar removal API request.Note that this code only shows handling removed identities,but a complete implementation should handleboth added and removed identities.And that's all you need to handle participant changes!Lastly, when changes are made to a collaboration,your app posts notices about those changesto be shown directly in Messages.There are a few types of supported noticesI'll go over in this section.Notices are displayed as a bannerright in the conversation where the link was shared.The banner includes a description of what changed,as well as who made the change.In this conversation, Charlie made editsto the Baking Recipes document.Tapping the show button connects themright back to the content.To represent a notice, the SharedWithYou frameworkhas a protocol named SWHighlightEvent.Highlight events are initialized with SWHighlightsretrieved from the SWHighlightCenter API.Messages supports several categories of events.A change event for content updates or comments,a membership event when a participant joins or leaves,a mention event when a user is mentioned in a collaboration,and a persistence event when content is moved or deleted.Here's an example showing how to post a change eventfor an edit to a collaboration.Using the highlight center API,retrieve a collaboration highlightfor the target identifier.Remember, this identifier is one you defined duringthe collaboration initiation, so your app should have thisavailable for use when a content change is made.Next, create a highlight change event instance.The initializer takes a highlight,and a trigger enum value;in this case, set it to the edit type.Finally, again using the highlight center,post the notice for that event.Similarly, for membership changes,post a membership event,this time passing the addedCollaboratoror removedCollaborator trigger type.Next, if your app supports user mentions,you can post a mention event.Initialize a person identitywith the root hash of the mentioned user.Recall that you associated a person identitywith a user account in your app while verifying access.Then, post the mention event in the same way,this time passing the mentioned identity as a parameter.This notice will only be shown in Messagesto the mentioned user.Finally, use the persistence event typewhen content is moved, renamed, or deleted.Here, the renamed trigger type is used,to signify that the user changed the name of the content.And that is how your app can notify collaborators,and they will get those updates right in Messages.Devin: And with that, you're ready to integrateyour app's collaboration experience with messagesby following a few steps.Set up your content to be shared collaboratively,cryptographically verify participant access,keep track of participant changes,and post notices in Messages to connect your usersright back to the content.Be sure to check outthe "Enhance collaboration experiences with Messages" videoto learn more about the new UI elementsyou can display for collaborations.Lance: We can't wait to get collaborating with your apps!Devin and Lance, cryptographically signing off.Devin: Thanks for watching!♪

♪ Mellow instrumental hip-hop music ♪♪Devin Clary: Hi. I'm Devin, an engineer on the Messages team.

Lance Parker: And I'm Lance, also a Messages engineer.

Devin: Welcome to "Integrate your custom collaboration appwith Messages."Collaboration starts with a conversation,and in iOS 16 and macOS Ventura,you can bring your app's custom collaboration experienceright into the fabric of the conversation.

In this video, we'll go over the life cycle of a collaboration.

Then, we'll show you how to prepareyour app's collaborative content to be shared through Messages.

Next, we'll give you everything you need to instantly verifyrecipient access, and respond to participant changes,all without compromising privacy.

Finally, we'll show you how your app can post noticesabout the content right to the Messages conversation.

This video assumes your apphas existing collaboration infrastructure,and has already adopted universal links.

We'll also build on some concepts introduced in"Add Shared with You to your app"and "Enhance collaboration experiences with Messages."First up, I'll go over the life cycleof a custom collaboration messageto illustrate how this API allows your usersto start collaborating faster than ever.

When a user decides to share a collaborationfrom your app through Messages,you first create metadata to represent the content.

The metadata includes share options the user can configureprior to sending the message,and a number of other properties you can customize.

Next, you provide that metadata to the share sheet,or to drag and drop.

This allows a draft of the content to be stagedin the Messages compose field.

The collaboration needs to be represented by a universal link.

That can be created immediately, but it's best deferreduntil right before the message is sent.

This is useful if your app's link creationdepends on the selected share options, or recipients,as configured in the Messages compose field.

The user chooses the recipients and share optionsand taps the send button.

Before the message is sent,Messages asks your app for the universal linkand a device independent identifier for the content.

Using that identifier, Messages provides a set ofcryptographic identities representing the recipientsof that specific collaboration message.

Your app will use these identities laterto allow the recipients to immediately open the linkon any of their devices.

Your app stores those identities on its serversand associates them with the shared content.

Once your app finishes this step,the message is sent to the recipients.

Now, here's what happens on the receiving device.

The goal is to instantly verify access,pairing a recipient identity with an account on your server.

When the recipient opens the link,your app receives a call to open the URL,just like it does for any other link.

When your app detects that a user accountdoesn't yet have access to the document,it queries the system for a proof of user identitycryptographically signed by the recipient device.

Your app sends that signed identity proofto your server for validation.

If the signature is valid, the server compares the proofagainst the identities previously providedby the sending device.

If there's a match, your server grants accessto the user's account.

And with that, the recipient has gainedinstant and secure access to the content,all without exchanging account information!And that's the life cycle of a collaboration message!Next, let's look more closelyat the API for starting a collaboration.

The system needs some metadata about the collaboration.

And for that, you use a new classin the Shared with You framework called SWCollaborationMetadata.

This class has a few properties for you to configure:the content's title, a local identifierto reference the content before its been shared;the initiator name and account handle,to provide transparency to the userabout the account they're sharing from;and the default share options, for the user to configure.

Here's how to create a metadata objectand configure its properties.

Create a local identifier using SWLocalCollaborationIdentifierinitialized with a string.

The string only needs to be sufficient for your appto identify the content locally, not across devices.

Initialize a new metadata instanceusing the local identifier.

Set the content title, the initiator's account handle,and their name using PersonNameComponentsfrom the foundation framework.

The handle and name are only displayed locallyso the user can confirm the account they're sharing from.

Next, set the defaultShareOptions.

Before I show you how to do that,I'll first describe how options work.

Share options are the settings a user configureson the collaboration in Messages or the share sheet.

The options selected by the user are provided to youbefore the message is sent.

Share options might include settings likewho can make edits to a collaborationor who should have access to the content.

You use a few classes to define options,starting with SWCollaborationOption.

Depending on how they're grouped,options represent individual switches,or mutually exclusive values for a setting.

Options have a title and an identifier,and they are either selected or unselected.

There are two classes to represent a group of options:SWCollaborationOptionsGroupand SWCollaborationOptions PickerGroup.

You use SWCollaborationOptionsGroupto represent a collection of switches,while SWCollaborationOptions PickerGrouprepresents mutually exclusive values for a setting.

Finally, SWCollaborationShareOptionsdefines the full set of option groups,to be set on the metadata's defaultShareOptions property.

You can also provide a summary string to describe the options.

Now that I've described the option classes,here's an example showing how to use them.

This code defines two option groups.

The first group is initialized with an identifierand two possible options.

The identifier is an arbitrary stringyou later use to identify which option was selected by the user.

Since this is a picker group,the options are mutually exclusive.

This group represents the permission settingsfor the content: readwrite or readonly.

Then, the first option in that group is selected by default.

And the title is set to a string describing this group.

The second option group is initialized the same way,and also contains two options.

But since this is a generic option group,the user will be able to configurewhether to allow mentions and comments independently.

Finally, the two option groups are used to initializean instance of SWCollaborationShareOptions,which is then set on the metadata.

Next, the metadata is provided to the share sheetor drag and drop, depending on how the userdecides to share the content.

If your app uses SwiftUI, SWCollaborationMetadatais compatible with the new ShareLink API.

Watch "Meet Transferable" and "What's new in SwiftUI"to learn more about Transferable and ShareLink.

Here's how easy it is to support collaborationon a proxy representation in SwiftUI!From within a Transferable model object,set up a ProxyRepresentationto return a collaboration metadata instance.

Then, from a view,initialize ShareLink with that model object.

For UIKit and AppKit apps, you use NSItemProviderto support sharing.

And SWCollaborationMetadata conforms toNSItemProviderReading and writing.

So you simply register a metadata instancewith an item provider, to support collaboration.

It's also good practiceto register multiple representations of the contentto support sharing through as many channels as possible.

For example, Messages automaticallyoffers an option to send the content as a copyif you provide a file representation.

You'll use the NSItemProvider API withUIActivityViewController and UIDragItem on iOS and iPadOSand NSSharingServicePicker on macOS.

Here's how to set that up with the share sheet on iOS.

Create an NSItemProvider instance.

Register the collaboration metadatacreated in the previous example,with visibility set to all processes on the system.

Initialize UIActivityItemsConfigurationwith the item provider,then initialize UIActivityViewControllerwith that configuration.

And finally, present the view controller.

It's just as easy to support drag and drop.

Initialize NSItemProviderand register the metadata the same way,then create a UIDragItem with the item providerto use with the drag and drop APIs.

The API is similar on macOS for the sharing popover.

Again, set up the item provider.

And this time, use it to initializeNSSharingServicePicker.

And then show the picker relative to a target view.

Drag and drop on macOS utilizes NSPasteboardItemrather than NSItemProvider.

To support this, SharedWithYou exportsan NSPasteboardItem extension.

Using that extension, set the collaboration metadatadirectly on a new NSPasteboardItem instancein order to support drag and drop.

And that's all you need for a draftof your collaborative content to be staged in Messages!Next, when the user taps the send button,the system coordinates with your app to set up the share.

It does this through a new class calledSWCollaborationCoordinator.

SWCollaborationCoordinator is a singleton,meaning there is a global shared instance.

That shared instance coordinates the collaborationthrough a delegate you define called an actionHandler.

To ensure your app is always availableto coordinate collaborations,it will be launched in the background when needed.

So you should register the delegate soon after launchand handle actions immediately to avoid timeouts.

Here's how to set up the collaboration coordinatorafter your app finishes launching.

Access the singleton coordinator instancethrough the shared property.

Then, in the app delegate'sdidFinishLaunchingWithOptions method,set the actionHandler propertyto an object that conforms to theSWCollaborationActionHandler protocol.

The action handler protocol uses a new classcalled SWAction.

SWActions represent work your app is expected to perform.

You fulfill actions to mark them as complete,and fail them otherwise.

The first action your app needs to handleis the start collaboration action.

SWStartCollaborationActioncontains the collaboration metadata you set up earlier,updated with the user's selected share options.

Once you've performed the necessary setup,you fulfill the start action with the universal linkand a device-independent identifierfor the collaboration.

If you explicitly fail the start action,the message is canceled.

Here's an implementation to handle the start actionusing an example server request.

First, retrieve the local identifier,and user-selected share optionsfrom the action's metadata property.

Set up a server request to prepare the collaborationusing the identifier and options.

Then, send the request to the server.

This example uses async await.

Finally, fulfill the action with the universal linkand the device independent identifier from the response.

Or, if there was an error,fail the action to cancel the message.

If the start action was successful,the system sends your app a second actionto update the collaboration participants.

The SWUpdateCollaboration ParticipantsActioncontains the cryptographic identitiesfor the participants.

The identities are derived from the collaboration identifierfulfilled by the start action in the previous step.

Store the identities on your serverassociated with the content.

You'll use this data for verifying accesson the recipient devices.

Finally, fulfilling this actionwill send the universal link in Messages.

This example shows how to handlethe update participants action.

Retrieve the collaboration identifierfrom the action's metadata.

This is the identifier you fulfilledwhile handling the start action.

Next, retrieve the participant data to store on your serversusing the action's addedIdentities property.

Each identity has a Data property called a root hash.

This is the data you should store on your serverfor later use.

Lance will go over more of the detailsabout this property in the Verifying Access section.

Set up another server request, this time to addthe participants to the collaborationwith the target identifier.

And just like before, send the request to your server,and fulfill or fail the action.

This time, the fulfill method does not take any parameters.

Now that you've set up the collaboration,your app has everything it needs to grant immediate accessto the recipients of the message.

I'll hand it over to Lance to show you how to do that!Lance: Thanks, Devin. In this section,I'll show how to provide immediate accessto the recipients using the identity datayou stored on your server in the previous step.

The rootHash property on SWPersonIdentityis used to do this verification.

A rootHash is a secure value used to uniquely identifya participant on their devices.

In order to perform verification,you'll need to understand how to compute a root hash.

I'll take you through that now.

When a collaboration message is sent,it's actually sent individually to each of a person's devices.

Messages identifies each deviceusing a cryptographic public key.

Since the goal is to allow accessonly on this set of devices, the root hash is derivedfrom the set of public keys registered to each recipient.

The root hash is the root node of a data structurecalled a Merkle tree.

A Merkle tree is a binary tree that is builtby performing a sequence of hashing operations.

In order to derive an identity for the user based on theirpublic keys, the keys are used as the leaves of this tree.

The hashing algorithm used in the Merkle tree ensuresthat the root node can only be computed from that set of keys.

In this example, this user has three devicesand three public keys.

The keys will be unique for each collaboration identifierprovided by your app,using a process called key diversification.

To prevent tracking the number of devices registered to a user,the set is padded with random keys up to a fixed size.

The leaf nodes of the tree are created by hashingthe padded set of diversified keys.

The SHA256 algorithm is used for the hashing operationsin this tree.

Then, each pair of leaf nodes are concatenatedand then hashed to derive their parent nodes.

This process is repeated with the parent nodesand repeated again until a single root node remains.

This is the root hash used to uniquely representthis recipient's identity across their devices.

Notice that it's possible to generate a root hashusing a subset of the nodes from a complete Merkle tree.

The root hash in this tree can be reproduced using justthe hashes H4, 7, and 11,along with the diversified public key P3.

First, hash the public key to get the missing leaf node H3.

Use H3 and H4 to generate H8.

Use the given H7 node with H8 to generate H10.

And finally, H10 and H11 produce the root hash.

It's important to note that you can prove the public key P3was used to generate a given root hash,without needing to reconstruct the entire tree.

The subset of nodes needed to do this is calleda proof of inclusion.

Verification begins when a universal linkis opened in your app.

To do this, you first need to checkthat the link is collaborative.

SWCollaborationHighlight represents a collaborative linkand is retrieved from SWHighlightCenter.

Use that collaboration highlightto generate the proof of inclusion.

To represent a proof of inclusion,use a class called SWPersonIdentityProof.

To perform verification, you'll first generatethis object along with a cryptographic signatureto send to your server.

Retrieve the proof using the getSignedIdentityProof methodon SWHighlightCenter.

It takes an SWCollaborationHighlightand some arbitrary data to be signed by the device.

Use the signature to ensure the request cannot be replayedby a bad actor to gain access to your collaboration.

The data could be a challenge you request from your server,or a nonce generated on the device.

This example uses the challenge approach.

The URL is passed to this method on your app'sUIApplicationDelegate.

This URL is the universal linkassociated with the collaboration.

The URL is used to fetch the associatedSWCollaborationHighlight from the SWHighlightCenter.

Next, I'll request the challenge from my server,and pass the data I get backto the getSignedIdentityProof method on SWHighlightCenter,along with the highlight.

This method returns a signed identity proof.

I'll discuss what your server should doto validate this data later on.

Now I can send the signed proof to my server for verification.

Finally, I update my user interface with the result.

The app sends the proof to the server,along with the public key and the signed data.

The data is signed using the elliptic curvedigital signature algorithm over the P-256 elliptic curve,using SHA256 as a hash function.

Verify the signature on the datausing the public key in the identity proof.

You can do this with most commonly usedencryption libraries.

Once you have verified the signature,you can trust that the identity proof was sentfrom the device associated with that public key.

Next, you use the identity proof to recompute the root hash.

Here is an example of what an SWPersonIdentityProofwould contain using the example tree we looked at before.

Use it to reconstruct the root hash of a Merkle tree.

The public key is P3.

The inclusion hashes are H4, 7, and 11.

A local key index of 2 indicates the positionof the public key in the tree.

Here is an example implementation that reconstructsa root hash from the properties on the proof.

A recursive algorithm works nicely when workingwith tree data structures, so that's what I've done here.

On the initial invocation, pass in the hash of the public key,the set of inclusion hashes, and the public key index.

Next, the first inclusion hash is pulled out.

The public key index is checked to see if the keyis on the left or the right of its sibling.

The selected hashes are concatenatedin the correct order, and then hashed.

Next, the consumed node in the inclusionHashes arrayis removed, and the rest are passedto a recursive call to this same function.

The public key index is also updatedso that it's ready for the next node in the tree.

With this simple function, you can quickly computea root hash given an identity proof.

The server can now check that this generated root hashis in the list of root hashes the owner of the documentuploaded during sending.

The hash is present in the list of known hashes,so the server can grant access to the document.

Now you can grant access to the document with confidence!To recap the steps you'll follow to verify an identity:first, look up the collaboration highlightfor your content while handling its universal link.

Next, sign some data and retrieve the proof of inclusion.

Send the signed data and proof to your server.

Verify the signature on the data.

Using the proof of inclusion, generate the root hash.

Finally, compare the root hash to the list of known identitiesassociated with that content.

Now that you know all about verifying accessto your collaboration links, I'll talk abouthow to coordinate participant changes with Messages.

When the participants in a Messages group change,and that group is collaborating together,a user can choose to propagate those changes to your app,right from a banner in the Messages thread.

In this scenario, your app receives anotherSWUpdateCollaboration ParticipantsActioncontaining the added and removed identities.

You'll use the same code you wrote to handle this actionwhen setting up a collaboration,but you'll also need to handle removed participants.

For removal, simply look up any account associatedwith a removed identity and revoke their access.

If no account is yet associated,simply delete the root hash from your database.

Here's the implementation forthe update participants action that Devin went over earlier.

This example usesthe removed identities property on the actionand passes them to a similar removal API request.

Note that this code only shows handling removed identities,but a complete implementation should handleboth added and removed identities.

And that's all you need to handle participant changes!Lastly, when changes are made to a collaboration,your app posts notices about those changesto be shown directly in Messages.

There are a few types of supported noticesI'll go over in this section.

Notices are displayed as a bannerright in the conversation where the link was shared.

The banner includes a description of what changed,as well as who made the change.

In this conversation, Charlie made editsto the Baking Recipes document.

Tapping the show button connects themright back to the content.

To represent a notice, the SharedWithYou frameworkhas a protocol named SWHighlightEvent.

Highlight events are initialized with SWHighlightsretrieved from the SWHighlightCenter API.

Messages supports several categories of events.

A change event for content updates or comments,a membership event when a participant joins or leaves,a mention event when a user is mentioned in a collaboration,and a persistence event when content is moved or deleted.

Here's an example showing how to post a change eventfor an edit to a collaboration.

Using the highlight center API,retrieve a collaboration highlightfor the target identifier.

Remember, this identifier is one you defined duringthe collaboration initiation, so your app should have thisavailable for use when a content change is made.

Next, create a highlight change event instance.

The initializer takes a highlight,and a trigger enum value;in this case, set it to the edit type.

Finally, again using the highlight center,post the notice for that event.

Similarly, for membership changes,post a membership event,this time passing the addedCollaboratoror removedCollaborator trigger type.

Next, if your app supports user mentions,you can post a mention event.

Initialize a person identitywith the root hash of the mentioned user.

Recall that you associated a person identitywith a user account in your app while verifying access.

Then, post the mention event in the same way,this time passing the mentioned identity as a parameter.

This notice will only be shown in Messagesto the mentioned user.

Finally, use the persistence event typewhen content is moved, renamed, or deleted.

Here, the renamed trigger type is used,to signify that the user changed the name of the content.

And that is how your app can notify collaborators,and they will get those updates right in Messages.

Devin: And with that, you're ready to integrateyour app's collaboration experience with messagesby following a few steps.

Set up your content to be shared collaboratively,cryptographically verify participant access,keep track of participant changes,and post notices in Messages to connect your usersright back to the content.

Be sure to check outthe "Enhance collaboration experiences with Messages" videoto learn more about the new UI elementsyou can display for collaborations.

Lance: We can't wait to get collaborating with your apps!Devin and Lance, cryptographically signing off.

Devin: Thanks for watching!♪

4:21 -Configure SWCollaborationMetadata

6:34 -Configure SWCollaborationShareOptions

7:58 -SWCollaborationMetadata SwiftUI TransferRepresentation

8:16 -Using a collaboration metadata TransferRepresentation with ShareLink

9:08 -iOS Share Sheet

9:42 -iOS Drag and Drop

9:58 -macOS Sharing Popover

10:18 -macOS Drag and Drop NSPasteboardItem extension

11:22 -Set up SWCollaborationCoordinator

12:27 -SWStartCollaborationAction

13:40 -SWUpdateCollaborationParticipantsAction

19:12 -Retrieve a signed identity proof for a highlight

21:20 -Example code for root hash generation

24:12 -SWUpdateCollaborationParticipantsAction - removing participants

25:54 -Post an SWHighlightChangeEvent Notice

26:39 -Post an SWHighlightMembershipEvent Notice

26:50 -Post an SWHighlightMentionEvent Notice

27:23 -Post an SWHighlightPersistenceEvent Notice

## Code Samples

```swift
let
 localIdentifier 
=
 
SWLocalCollaborationIdentifier
(rawValue: 
"identifier"
)

let
 metadata 
=
 
SWCollaborationMetadata
(localIdentifier: localIdentifier)
metadata.title 
=
 
"Content Title"

metadata.initiatorHandle 
=
 
"user@example.com"



let
 formatter 
=
 
PersonNameComponentsFormatter
()

if
 
let
 components 
=
 formatter.personNameComponents(from: 
"Devin"
) {
    metadata.initiatorNameComponents 
=
 components
}

metadata.defaultShareOptions 
=
 
...
```

```swift
let
 permission 
=
 
SWCollaborationOptionsPickerGroup
(identifier: 
UUID
().uuidString, 
                                                   options: [
    
SWCollaborationOption
(title: 
"Can make changes"
, identifier: 
UUID
().uuidString),
    
SWCollaborationOption
(title: 
"Read only"
, identifier: 
UUID
().uuidString)
])
permission.options[
0
].isSelected 
=
 
true

permission.title 
=
 
"Permission"



let
 additionalOptions 
=
 
SWCollaborationOptionsGroup
(identifier: 
UUID
().uuidString, 
                                                    options: [
    
SWCollaborationOption
(title: 
"Allow mentions"
, identifier: 
UUID
().uuidString),
    
SWCollaborationOption
(title: 
"Allow comments"
, identifier: 
UUID
().uuidString)
])
additionalOptions.title 
=
 
"Additional Settings"


let
 optionsGroups 
=
 [permission, additionalOptions]
metadata.defaultShareOptions 
=
 
SWCollaborationShareOptions
(optionsGroups: optionsGroups)
```

```swift
struct
 
CustomCollaboration
: 
Transferable
 {
    
var
 name: 
String


    
static
 
var
 transferRepresentation: 
some
 
TransferRepresentation
 {
        
ProxyRepresentation
 { customCollaboration 
in

            
SWCollaborationMetadata
(
                localIdentifier: .
init
(rawValue: 
"com.example.customcollaboration"
),
                title: customCollaboration.name,
                defaultShareOptions: 
nil
,
                initiatorHandle: 
"johnappleseed@apple.com"
,
                initiatorNameComponents: 
nil

            )
        }
    }
}
```

```swift
struct
 
ContentView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
ShareLink
(item: 
CustomCollaboration
(name: 
"Example"
), preview: .
init
(
"Example"
))
    }
}
```

```swift
func
 
presentActivityViewController
(
metadata
: 
SWCollaborationMetadata
) {
    
let
 itemProvider 
=
 
NSItemProvider
()
    itemProvider.registerObject(metadata, visibility: .all)
    
let
 activityConfig 
=
 
UIActivityItemsConfiguration
(itemProviders: [itemProvider])
    
let
 shareSheet 
=
 
UIActivityViewController
(activityItemsConfiguration: activityConfig)
    present(shareSheet, animated: 
true
)
}
```

```swift
func
 
createDragItem
(
metadata
: 
SWCollaborationMetadata
) -> 
UIDragItem
 {
    
let
 itemProvider 
=
 
NSItemProvider
()
    itemProvider.registerObject(metadata, visibility: .all)
    
return
 
UIDragItem
(itemProvider: itemProvider)
}
```

```swift
func
 
showSharingServicePicker
(
view
: 
NSView
, 
metadata
: 
SWCollaborationMetadata
) {
    
let
 itemProvider 
=
 
NSItemProvider
()
    itemProvider.registerObject(metadata, visibility: .all)
    
let
 picker 
=
 
NSSharingServicePicker
(items: [itemProvider])
    picker.show(relativeTo: view.bounds, of: view, preferredEdge: .minY)
}
```

```swift
func
 
createPasteboardItem
(
metadata
: 
SWCollaborationMetadata
) -> 
NSPasteboardItem
 {
    
let
 pasteboardItem 
=
 
NSPasteboardItem
()
    pasteboardItem.collaborationMetadata 
=
 metadata
    
return
 pasteboardItem
}
```

```swift
private
 
let
 collaborationCoordinator 
=
 
SWCollaborationCoordinator
.shared


func
 
application
(
_
 
application
: 
UIApplication
, 
didFinishLaunchingWithOptions
 
launchOptions
: [
UIApplication
.
LaunchOptionsKey
 : 
Any
]
?
) -> 
Bool
 {
    
// Conform to the SWCollaborationActionHandler protocol

    collaborationCoordinator.actionHandler 
=
 
self

}
```

```swift
func
 
collaborationCoordinator
(
_
 
coordinator
: 
SWCollaborationCoordinator
, 
                              
handle
 
action
: 
SWStartCollaborationAction
) {
    
let
 localID 
=
 action.collaborationMetadata.localIdentifier.rawValue
    
let
 selectedOptions 
=
 action.collaborationMetadata.userSelectedShareOptions
    
let
 prepareRequest 
=
 
APIRequest
.
PrepareCollaboration
(localID: localID, selectedOptions)
    
Task
 {
        
do
 {            
            
let
 response 
=
 
try
 
await
 apiController.send(request: prepareRequest)
            
let
 identifier 
=
 response.deviceIndependentIdentifier
            action.fulfill(using: response.url, collaborationIdentifier: identifier)
        } 
catch
 {
            
Log
.error(
"Caught error while preparing the collaboration: 
\(error)
"
)
            action.fail() 
// cancels the message

        }
    }
}
```

```swift
func
 
collaborationCoordinator
(
_
 
coordinator
: 
SWCollaborationCoordinator
, 
                              
handle
 
action
: 
SWUpdateCollaborationParticipantsAction
) {
    
let
 identifier 
=
 action.collaborationMetadata.collaborationIdentifier
    
let
 participants: [
Data
] 
=
 action.addedIdentities.compactMap { 
$0
.rootHash }
    
let
 addParticipants 
=
 
APIRequest
.
AddParticipants
(identifier: identifier, participants)
    
Task
 {
        
do
 {            
            
try
 
await
 apiController.send(request: addParticipants)
            action.fulfill() 
// sends the URL provided by the start action

        } 
catch
 {
            
Log
.error(
"Caught error while adding participants to collaboration: 
\(error)
"
)
            action.fail() 
// cancels the message 

        }
    }
}
```

```swift
func
 
application
(
_
 
app
: 
UIApplication
, 
open
 
url
: 
URL
, 
               
options
: [
UIApplication
.
OpenURLOptionsKey
 : 
Any
] 
=
 [:]) -> 
Bool
 {
    
let
 highlightCenter: 
SWHighlightCenter
 
=
 
self
.highlightCenter
    
let
 challengeRequest 
=
 
APIRequest
.
GetChallengeData
()
    
Task
 {
        
do
 {
            
let
 highlight 
=
 
try
 highlightCenter.collaborationHighlight(for: url)
            
let
 challenge 
=
 
try
 
await
 apiController.send(request: challengeRequest)
            
let
 proof 
=
 
try
 
await
 highlightCenter.getSignedIdentityProof(for: highlight, 
                                                                       using: challenge.data)
    
let
 proofOfInclusionRequest 
=
 
APIRequest
.
SubmitProofOfInclusion
(for: proof)
            
let
 result 
=
 
try
 
await
 apiController.send(request: proofOfInclusionRequest)
            documentController.update(currentDocument, with: result)
        } 
catch
 {
            
Log
.error(
"Caught error while generating proof of inclusion: 
\(error)
"
)
        }
    }
}
```

```swift
func
 
generateRootHashFromArray
(
localHash
: 
SHA256Digest
, 
inclusionHashes
: [
SHA256Digest
], 
                       
publicKeyIndex
: 
Int
) -> 
SHA256Digest
 {
    
guard
 
let
 firstHash 
=
 inclusionHashes.first 
else
 { 
return
 localHash }
    
// Check if the node is the left or the right child

    
let
 isLeft 
=
 publicKeyIndex.isMultiple(of: 
2
)
    
// Calculate the combined hash

    
var
 rootHash: 
SHA256Digest

    
if
 isLeft {
        rootHash 
=
 hash(concatenate([localHash, firstHash]), using: .sha256)
    } 
else
 {
        rootHash 
=
 hash(concatenate([firstHash, localHash]), using: .sha256)
    }
    
// Recursively pass in elements and move up the Merkle tree

    
let
 newInclusionHashes 
=
 inclusionHashes.dropFirst()
    rootHash 
=
 generateRootHashFromArray(
        localHash: rootHash,
        inclusionHashes: 
Array
(newInclusionHashes),
        publicKeyIndex: (publicKeyIndex 
/
 
2
)
    )
    
return
 rootHash
}
```

```swift
func
 
collaborationCoordinator
(
_
 
coordinator
: 
SWCollaborationCoordinator
, 
                              
handle
 
action
: 
SWUpdateCollaborationParticipantsAction
) {
    
// Example of removing participants only. Handle the added identities here too.

    
let
 identifier 
=
 action.collaborationMetadata.collaborationIdentifier
    
let
 removed: [
Data
] 
=
 action.removedIdentities.compactMap { 
$0
.rootHash }
    
let
 removeParticipants 
=
 
APIRequest
.
RemoveParticipants
(identifier: identifier, removed)
    
Task
 {
        
do
 {            
            
try
 
await
 apiController.send(request: removeParticipants)
            action.fulfill()
        } 
catch
 {
            log.error(
"Caught error while adding participants to collaboration: 
\(error)
"
)
            action.fail()
        }
    }
}
```

```swift
func
 
postContentEditEvent
(
identifier
: 
SWCollaborationIdentifier
) 
throws
 {
    
let
 highlightCenter: 
SWHighlightCenter
 
=
 
self
.highlightCenter
    
let
 highlight 
=
 
try
 highlightCenter.collaborationHighlight(forIdentifier: identifier)

    
let
 editEvent 
=
 
SWHighlightChangeEvent
(highlight: highlight, trigger: .edit)

    highlightCenter.postNotice(for: editEvent)
}
```

```swift
func
 
postMentionEvent
(
identifier
: 
SWCollaborationIdentifier
, 
mentionedRootHash
: 
Data
) 
throws
 {
    
let
 mentionedIdentity 
=
 
SWPerson
.
Identity
(rootHash: mentionedRootHash)

    
let
 highlightCenter: 
SWHighlightCenter
 
=
 
self
.highlightCenter
    
let
 highlight 
=
 
try
 highlightCenter.collaborationHighlight(forIdentifier: identifier)

    
let
 mentionEvent 
=
 
SWHighlightMentionEvent
(highlight: highlight,
                                               mentionedPersonIdentity: mentionedIdentity)
    highlightCenter.postNotice(for: mentionEvent)
}
```

```swift
func
 
postContentRenamedEvent
(
identifier
: 
SWCollaborationIdentifier
) 
throws
 {
    
let
 highlightCenter: 
SWHighlightCenter
 
=
 
self
.highlightCenter
    
let
 highlight 
=
 
try
 highlightCenter.collaborationHighlight(forIdentifier: identifier)

    
let
 renamedEvent 
=
 
SWHighlightPersistenceEvent
(highlight: highlight, trigger: .renamed)
    highlightCenter.postNotice(for: renamedEvent)
}
```


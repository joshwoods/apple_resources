# Wwdc2022 10072

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Use SwiftUI with UIKitLearn how to take advantage of the power of SwiftUI in your UIKit app. Build custom UICollectionView and UITableView cells seamlessly with SwiftUI using UIHostingConfiguration. We'll also show you how to manage data flow between UIKit and SwiftUI components within your app.

To get the most out of this session, we encourage basic familiarity with SwiftUI.ResourcesManaging model data in your appselfSizingInvalidationselfSizingInvalidationUIHostingConfigurationUIHostingControllerUIViewControllerUsing SwiftUI with UIKitHD VideoSD VideoRelated VideosWWDC22Hello Swift ChartsWhat's new in UIKitWWDC22 Day 4 recapWWDC20Data Essentials in SwiftUIModern cell configuration

Learn how to take advantage of the power of SwiftUI in your UIKit app. Build custom UICollectionView and UITableView cells seamlessly with SwiftUI using UIHostingConfiguration. We'll also show you how to manage data flow between UIKit and SwiftUI components within your app.

To get the most out of this session, we encourage basic familiarity with SwiftUI.

Managing model data in your app

selfSizingInvalidation

selfSizingInvalidation

UIHostingConfiguration

UIHostingController

UIViewController

Using SwiftUI with UIKit

HD VideoSD Video

HD Video

SD Video

Hello Swift Charts

What's new in UIKit

WWDC22 Day 4 recap

Data Essentials in SwiftUI

Modern cell configuration

Search this video…♪ Mellow instrumental hip-hop music ♪♪Hello, I'm Sara Frederixon, an engineer on the Health app,and I'm here to talk to you about using SwiftUI with UIKit.Like many of you, I work on an existing UIKit app.For me, this is the Health app.The Health app has many visualizationsto help people understand their health data,but building these views can be quite complex.I've been interested in taking advantage of SwiftUI,so I worked with the UIKit and SwiftUI teamsto learn how to integrate both into the same app.In this video, I will teach you how easy it isto start using SwiftUI in your own UIKit apps.First I'll cover the existing UIHostingController,which has some new updates that add even more flexibility.Next I'll dive into populating SwiftUI viewswith data that already exist in your app,and how to ensure the SwiftUI views updatewhen that data changes.Then, I'll talk about some exciting new functionalitythat lets you build UICollectionViewand UITableView cells using SwiftUI.Finally, I'll walk through the unique aspects of data flowwith collection and table viewswhen you're using SwiftUI inside cells.Let's get started by talking about UIHostingController.UIHostingController is a UIViewControllerthat contains a SwiftUI view hierarchy.You can use a hosting controlleranywhere you can use a view controller in UIKit.This makes UIHostingControlleran easy way to start using SwiftUI.Let's examine how a hosting controller works.A hosting controller is a view controller,which means it has a UIView stored in its view property.And inside that viewis where your SwiftUI content is rendered.Let's go through an example of how to use a hosting controller.Here, we create a HeartRateView, a SwiftUI view.We then create a hosting controller with HeartRateViewas its root view, and present it.UIHostingController works withall of the UIKit view controller APIs.Let's go through another example.We have the same HeartRateViewand hosting controller as before.Here we add the hosting controlleras a child view controller.Then we can position and size the hosting controller's view.When your SwiftUI content inside UIHostingController changes,it may cause the view to need to be resized.New in iOS 16, UIHostingControllerallows you to enable automatic updatesof the view controller's preferred content sizeand the view's intrinsic content size.You can enable this using the new sizingOptions propertyon UIHostingController.Let's go through an example.To start, we make our HeartRateView,and create the hostingController.We use the new sizingOptions API to tell the hostingControllerto automatically update its preferredContentSize.Then, we set the modalPresentationStyleto popover.Using the new sizingOptions API ensures that the popoveris always sized appropriately to fit the SwiftUI content.Now that you're familiar with UIHostingController,let's talk about how to get data into SwiftUIfrom other parts of your UIKit app,and ensure that your SwiftUI views updatewhen that data changes.Here's a diagram of your UIKit app,It contains an existing model layerthat owns and manages your app's data model objects.Your app also contains a number of view controllers.If you want start using SwiftUI, you'll need a hosting controllerwith a SwiftUI view inside one of the view controllers.You will want to populate this SwiftUI view with datathat is still owned by your existing model layer.In this section, we're going to focus on how to bridge dataacross the boundary between UIKit and SwiftUI.SwiftUI offers a variety of data flow primitivesto help you manage the data in your app.Let's go through the different options.To store data that is created and owned by a SwiftUI view,SwiftUI provides the @State and @StateObject property wrappers.Since we're focused on data owned outside of SwiftUI,these property wrappers aren't the right choice.So, I'm not going to cover these in this video.Watch "Data Essentials in SwiftUI"to learn more about data owned by a SwiftUI view.One way to handle data external to SwiftUIis to pass values directly when you initialize your views.Because you are just passing raw datathat is not owned or managed by SwiftUI,you are responsible for manually updating the UIHostingControllerwhen the data changes.Let's go through an example.Here is a SwiftUI view named HeartRateView.This view has a single property --the heart rate beatsPerMinute stored as an integer --and it displays the value as text.We're displaying this HeartRateViewby embedding a UIHostingControllerinside an existing view controllernamed HeartRateViewController.We save a reference to the hosting controllerso we can update its root view later.Remember, the SwiftUI HeartRateView is a value type,so storing it by itself would create a separate copy,and wouldn't allow us to update the UI.The HeartRateViewController owns the dataused to populate the HeartRateView.This data is stored in the beatsPerMinute property,and when the beatsPerMinute value changes,we call a method to update the view.Inside of the update method, we create a new HeartRateViewusing the latest beatsPerMinute value,and then assign that view as the rootViewof our hosting controller.This is a simple way to get data from UIKit into SwiftUI,but it requires manually updating the rootViewof the hosting controller any time the data changes.Let's go through some other SwiftUI data primitivesto make these updates happen automatically.The @ObservedObject and @EnvironmentObjectproperty wrappers allow you to referencean external model objectthat conforms to the ObservableObject protocol.When you use these property wrappers,SwiftUI automatically updates your view when the data changes.We're going to focus on the @ObservedObject property wrapperin this video,but you can learn more about EnvironmentObject in the"Data Essentials in SwiftUI" video mentioned earlier.Let's go through how to create an @ObservedObject.The first step is to take a model objectthat is owned by an existing part of your appand make it conform to the ObservableObject protocol.Next, we store the model as an @ObservedObject propertyin our SwiftUI view.Connecting the ObservableObject to SwiftUI allows itto update the view when one of its properties change.Let's go back to our HeartRateView exampleand wire this up.Our app has a class named HeartDatathat contains the property beatsPerMinute.We make it an ObservableObject by conforming to the protocol.Then we add the @Published property wrapperto the beatsPerMinute property.This property wrapper is what triggers SwiftUIto update our views on changes.In the HeartRateView, we store the HeartDatain a property annotated withthe @ObservedObject property wrapper.In the body of the view, we display the beatsPerMinutedirectly from the HeartData.Now, let's use these together in our view controller.Here is our HeartRateViewController.It stores the HeartData ObservableObject in a property.Because this property is not inside a SwiftUI view,we don't need to use a property wrapper here.The HeartRateViewController is initializedwith a HeartData instance,which is used to create a HeartRateViewthat becomes the rootView of the hosting controller.The diagram illustrates how this comes together.We fetch the current HeartData instance,which contains a heart rate of 78 beat per minute.Then we create a new HeartRateViewControllerwith that HeartData instance,which wires it up to the SwiftUI HeartRateView.After a few seconds,when the next heart rate data sample arrives,the heart data's beatsPerMinute property is updated to 94.Because this changes a published propertyon an ObservableObject, the HeartRateViewis automatically updated to display the new value.We no longer need to manually update the hosting controllerwhen the data changes.This is why ObservableObject is a great way to bridge datafrom UIKit to SwiftUI.Next, let's talk about using SwiftUI in collection viewand table view cells.New in iOS 16 is UIHostingConfiguration,which lets you harness the power of SwiftUIinside your existing UIKit, collection, and table views.UIHostingConfiguration makes it easy to implementcustom cells using SwiftUI, without needing to worryabout embedding an extra view or view controller.Before we dive deeper on UIHostingConfiguration,let's review cell configurations in UIKit.Cell configurations are a modern wayto define the content, styling, and behavior of cells in UIKit.Unlike a UIView or UIViewController,a configuration is just a lightweight struct.It's inexpensive to create.A configuration is only a descriptionof a cell's appearance, so it needs to be appliedto a cell to have an effect.Configurations are composable,and work with both UICollectionViewand UITableView cells.For more details, you can watch "Modern cell configuration."With that in mind, let's dive inand start using UIHostingConfiguration!UIHostingConfiguration is a content configurationthat is initialized with a SwiftUI ViewBuilder.That means we can start writing SwiftUI codeto create views directly inside it.In order to render the hosting configuration,we set it to the contentConfiguration propertyof the UICollectionView or UITableView cell.Let's start writing some SwiftUI codein this hosting configuration to build a custom heart rate cell.We'll start by creating a label with the text "Heart Rate"and the image of a heart.SwiftUI views receive default stylingbased on the context they are used in.But we can start customizing the stylingusing standard SwiftUI view modifiers.Let's make the image and text pink with a bold font,by adding the foregroundStyle and font modifiers to our label.Since we're just writing regular SwiftUI code,we can factor out our code into a standalone viewanytime we want.Here, we create a new SwiftUI viewnamed HeartRateTitleView,moved the code we had into its body,and then used that HeartRateTitleViewin the hosting configuration.As shown in the cell,it produces the exact same result.Now we can start adding more viewsinside the HeartRateTitleView.I've put the label inside of an HStack with a spacer,then added the current time in a Text view next to it.That's looking pretty good so far.Let's add some more content to this custom cellbelow the HeartRateTitleView.To do this, we'll insert a VStackinside the hosting configurationso we can add more content below the HeartRateTitleView.Then we'll put two Text views togetherin a HStack to display 90 BPMand then apply a few modifiers to style them the way we want.Just like we did before with the HeartRateTitleView,we can move this new code into its own SwiftUI view.Now the same code is extracted into the bodyof the HeartRateBPMView.Our cell is looking great,but I have an idea for another thing we could add.New in iOS 16 is the Swift Charts framework,which lets you visualize data with beautiful graphsin only a few lines of code.Let's try using it to display a small line chartright inside the cell.Using the new Chart view, we create a small line chartthat visualizes recent heart rate samplesand display that next to the BPM view in the cell.To generate the chart,we pass in a collection of heart rate samples,and draw a LineMark that connects all of the samples.We can add a circle symbolto indicate each sample on the lineand apply a pink foreground style,to tint the chart to match the HeartRateTitleView.We're only scratching the surface of what you can dowith the new Swift Charts framework,so be sure to check out the video "Hello Swift Charts"to learn more about it.Not only does our finished heart rate cell look awesome,but it was easy to make in just a couple of minutes.That's how easy it is to start building custom cellswith UIHostingConfiguration and SwiftUI.Let's talk about four special featuresthat UIHostingConfiguration supports.By default, the root-level SwiftUI contentis inset from the edges of the cell,based on the cell's layout margins in UIKit.This ensures that the cell contentis properly aligned with the content of adjacent cellsand other UI elements, such as the navigation bar.Sometimes, you may want to use different margins,or have the content extend to the edges of the cell.For these cases, you can change the default marginsby using the margins modifier on UIHostingConfiguration.If you want to customize a cell's background appearanceusing SwiftUI, you can use the background modifieron the UIHostingConfiguration.There are a few key differences betweena UIHostingConfiguration's background and its content.The background is hosted at the the back of the cell,underneath your SwiftUI content in the cell's content view.Additionally, while content is typicallyinset from the cell's edges,backgrounds extend edge to edge in the cell.Finally, when using self-sizing cells,only the cell content influences the size of the cell.Next, let's examine two more special featuresof UIHostingConfiguration that you can usewhen you have a cell inside a collection view listor table view.In a list, the separator below the cellis automatically aligned to the SwiftUI textin your hosting configuration by default.In this example, notice how the leading edge of the separatoris inset past the image so that it aligns with the textin the cell.If you need to align the separatorto a different SwiftUI view in your hosting configuration,use the alignmentGuide modifier.When inside a collection view list or table view,you can configure swipe actions for a row directly with SwiftUI.By creating your buttons inside the swipeActions modifier,you'll be able to swipe the cellto reveal and perform your custom actions.Download the sample code for this videoto find a complete example.When defining swipe actions,make sure your buttons perform their actionsusing a stable identifier for the item represented.Do not use the index path,as it may change while the cell is visible,causing the swipe actions to act on the wrong item.When you're using UIHostingConfigurationin a cell, keep in mind that the cell interactionssuch as tap handling, highlighting,and selection will still be handledby the collection view or table view.If you need to customize your SwiftUI viewsfor any of these UIKit cell states,you can create your hosting configurationinside of the cell's configurationUpdateHandler,and use the state provided in your SwiftUI code.The configurationUpdateHandler runs againany time the cell's state changes,creating a new UIHostingConfigurationfor the new state and applying it to the cell.In this example, we use the state to add a checkmark imagewhen the cell is selected.Now that you're familiar with UIHostingConfiguration,let's discuss how to manage data flow from your model layerto a UICollectionView or UITableViewfilled with cells using SwiftUI.Our goal is to build this list of medical conditions.In this example, we're using a UICollectionView,but everything we discuss applies equally to UITableView.Let's go through the components involved.Our app has a collection of MedicalCondition model objects,which we are going to display in the collection view.For each item in this collection,we want to create a cell in the collection viewto display that medical condition.In order to do this, we'll create a diffable data sourceconnected to the collection view.Then, we need to populate a diffable data source snapshotwith the identifiers of the MedicalCondition model objectsin the data collection.It's important that the diffable data source snapshotcontains the unique identifier of each MedicalCondition,and not the MedicalCondition objects themselves.This ensures that the diffable data source can accurately trackthe identity of each item,and compute the correct changeswhen new snapshots are applied later.By applying a snapshot with these item identifiersto the diffable data source,it will automatically update the collection view,which will create a new cell for each item.Each cell is configured to display one MedicalCondition,using a SwiftUI view in a UIHostingConfiguration.Now that we're displaying cells built with SwiftUI,we need to handle updating the UI when the data changes.There are two different types of changesthat we need to handle separately.The first type is when the data collection itself changes.For example, when items are inserted, reordered, or deleted.These changes are handled by applying a new snapshotto the diffable data source.Diffable data source will diff the old and new snapshots,and perform the necessary updates to the collection view,causing cells to be inserted, moved, or deleted.Because changes to the collection of data itselfdon't affect anything inside of cells,you handle these types of changes the same,whether you build your cells using UIKit or SwiftUI.The second type of change we need to handleare when the properties of individual model objects change.These changes often require updating the viewsin existing cells.Because the diffable data sourceonly contains item identifiers in its snapshot,it doesn't know when the propertiesof existing items change.Traditionally, when using UIKit, you would need to manuallytell the diffable data source about these changesby reconfiguring or reloading items in the snapshot.But when using SwiftUI in cells, this isn't necessary anymore.By storing the ObservableObject modelin an ObservedObject property in our SwiftUI view,changes to published propertiesof the model will automatically trigger SwiftUIto refresh the view.This establishes a direct connection between the modeland the SwiftUI view inside of the cell.When a change is made,the SwiftUI views in the cell are updated directly,without going through the diffable data sourceor the UICollectionView.When a cell's data changes,it may cause the cell to need to grow or shrinkto fit the new content.But if the SwiftUI cell content is being updated directlywithout going through UIKit,how does the collection view know to resize the cell?UIHostingConfiguration takes advantage of a brand-new featurein UIKit to make this work.In iOS 16, self-sizing cells in UICollectionViewand UITableView are now also self-resizing!This is enabled by default,so that when you're using UIHostingConfigurationand the SwiftUI content changes, the containing cellis automatically resized if necessary.You can learn more about how this new feature worksin the "What's New in UIKit" video from WWDC 2022.There's one more aspect of data flowthat you may need to handle, and that's sending data outfrom a SwiftUI view back to other parts of your app.Once again, ObservableObject has got you covered!You can create a two-way binding to a published propertyof an ObservableObject.Not only will data flow from the ObservableObject into SwiftUI,but SwiftUI can write back changes to the propertyon the model object.Let's go through a simple exampleof creating a two-way bindingby making the text in our MedicalCondition cell editable.Here is our ObservableObject, MedicalCondition.It stores a unique identifier in an ID property.This is the identifier used to populatethe diffable data source snapshot.And this published property stores the textof the medical condition.Here's the MedicalConditionViewthat displays the medical condition text inside each cell.Right now this text is read-only,so let's make it editable.All we need to do is to change the Text view to a TextFieldand create a binding to the text propertyof our MedicalCondition by adding a dollar sign prefix.When you type into the text field,this binding allows SwiftUI to write back changesdirectly to the ObservableObject.That's really how simple it isto set up two-way data flow with SwiftUI.UIHostingController is a powerful wayto embed SwiftUI content into your UIKit app.Your SwiftUI view is renderedinside the hosting controller's view,and you can use the hosting controlleranywhere that you can use a view controller in UIKit.When using UIHostingController,make sure to always add the view controllertogether with the view to your app.Many SwiftUI features, such as toolbars, keyboard shortcuts,and views that use UIViewControllerRepresentable,require a connection to the view controller hierarchyin UIKit to integrate properly,so never separate a hosting controller's viewfrom the hosting controller itself.For comparison, when you applya UIHostingConfiguration to a cell,your SwiftUI view is hosted in the cellwithout a UIViewController.UIHostingConfiguration supports the vast majorityof SwiftUI features.But keep in mind that SwiftUI viewsthat depend on UIViewControllerRepresentablecan't be used inside of cells.With UIHostingController and UIHostingConfiguration,you have two great ways to incorporate SwiftUIinto your UIKit app.SwiftUI integrates seamlessly into existing UIKit appsUse UIHostingController to add SwiftUI throughout your app.Create custom cells in your collection and table viewusing UIHostingConfiguration.And take advantage of ObservableObject,so your data and UI is always in sync.Add SwiftUI to your app today!Thank you for watching!♪

♪ Mellow instrumental hip-hop music ♪♪Hello, I'm Sara Frederixon, an engineer on the Health app,and I'm here to talk to you about using SwiftUI with UIKit.

Like many of you, I work on an existing UIKit app.

For me, this is the Health app.

The Health app has many visualizationsto help people understand their health data,but building these views can be quite complex.

I've been interested in taking advantage of SwiftUI,so I worked with the UIKit and SwiftUI teamsto learn how to integrate both into the same app.

In this video, I will teach you how easy it isto start using SwiftUI in your own UIKit apps.

First I'll cover the existing UIHostingController,which has some new updates that add even more flexibility.

Next I'll dive into populating SwiftUI viewswith data that already exist in your app,and how to ensure the SwiftUI views updatewhen that data changes.

Then, I'll talk about some exciting new functionalitythat lets you build UICollectionViewand UITableView cells using SwiftUI.

Finally, I'll walk through the unique aspects of data flowwith collection and table viewswhen you're using SwiftUI inside cells.

Let's get started by talking about UIHostingController.

UIHostingController is a UIViewControllerthat contains a SwiftUI view hierarchy.

You can use a hosting controlleranywhere you can use a view controller in UIKit.

This makes UIHostingControlleran easy way to start using SwiftUI.

Let's examine how a hosting controller works.

A hosting controller is a view controller,which means it has a UIView stored in its view property.

And inside that viewis where your SwiftUI content is rendered.

Let's go through an example of how to use a hosting controller.

Here, we create a HeartRateView, a SwiftUI view.

We then create a hosting controller with HeartRateViewas its root view, and present it.

UIHostingController works withall of the UIKit view controller APIs.

Let's go through another example.

We have the same HeartRateViewand hosting controller as before.

Here we add the hosting controlleras a child view controller.

Then we can position and size the hosting controller's view.

When your SwiftUI content inside UIHostingController changes,it may cause the view to need to be resized.

New in iOS 16, UIHostingControllerallows you to enable automatic updatesof the view controller's preferred content sizeand the view's intrinsic content size.

You can enable this using the new sizingOptions propertyon UIHostingController.

Let's go through an example.

To start, we make our HeartRateView,and create the hostingController.

We use the new sizingOptions API to tell the hostingControllerto automatically update its preferredContentSize.

Then, we set the modalPresentationStyleto popover.

Using the new sizingOptions API ensures that the popoveris always sized appropriately to fit the SwiftUI content.

Now that you're familiar with UIHostingController,let's talk about how to get data into SwiftUIfrom other parts of your UIKit app,and ensure that your SwiftUI views updatewhen that data changes.

Here's a diagram of your UIKit app,It contains an existing model layerthat owns and manages your app's data model objects.

Your app also contains a number of view controllers.

If you want start using SwiftUI, you'll need a hosting controllerwith a SwiftUI view inside one of the view controllers.

You will want to populate this SwiftUI view with datathat is still owned by your existing model layer.

In this section, we're going to focus on how to bridge dataacross the boundary between UIKit and SwiftUI.

SwiftUI offers a variety of data flow primitivesto help you manage the data in your app.

Let's go through the different options.

To store data that is created and owned by a SwiftUI view,SwiftUI provides the @State and @StateObject property wrappers.

Since we're focused on data owned outside of SwiftUI,these property wrappers aren't the right choice.

So, I'm not going to cover these in this video.

Watch "Data Essentials in SwiftUI"to learn more about data owned by a SwiftUI view.

One way to handle data external to SwiftUIis to pass values directly when you initialize your views.

Because you are just passing raw datathat is not owned or managed by SwiftUI,you are responsible for manually updating the UIHostingControllerwhen the data changes.

Let's go through an example.

Here is a SwiftUI view named HeartRateView.

This view has a single property --the heart rate beatsPerMinute stored as an integer --and it displays the value as text.

We're displaying this HeartRateViewby embedding a UIHostingControllerinside an existing view controllernamed HeartRateViewController.

We save a reference to the hosting controllerso we can update its root view later.

Remember, the SwiftUI HeartRateView is a value type,so storing it by itself would create a separate copy,and wouldn't allow us to update the UI.

The HeartRateViewController owns the dataused to populate the HeartRateView.

This data is stored in the beatsPerMinute property,and when the beatsPerMinute value changes,we call a method to update the view.

Inside of the update method, we create a new HeartRateViewusing the latest beatsPerMinute value,and then assign that view as the rootViewof our hosting controller.

This is a simple way to get data from UIKit into SwiftUI,but it requires manually updating the rootViewof the hosting controller any time the data changes.

Let's go through some other SwiftUI data primitivesto make these updates happen automatically.

The @ObservedObject and @EnvironmentObjectproperty wrappers allow you to referencean external model objectthat conforms to the ObservableObject protocol.

When you use these property wrappers,SwiftUI automatically updates your view when the data changes.

We're going to focus on the @ObservedObject property wrapperin this video,but you can learn more about EnvironmentObject in the"Data Essentials in SwiftUI" video mentioned earlier.

Let's go through how to create an @ObservedObject.

The first step is to take a model objectthat is owned by an existing part of your appand make it conform to the ObservableObject protocol.

Next, we store the model as an @ObservedObject propertyin our SwiftUI view.

Connecting the ObservableObject to SwiftUI allows itto update the view when one of its properties change.

Let's go back to our HeartRateView exampleand wire this up.

Our app has a class named HeartDatathat contains the property beatsPerMinute.

We make it an ObservableObject by conforming to the protocol.

Then we add the @Published property wrapperto the beatsPerMinute property.

This property wrapper is what triggers SwiftUIto update our views on changes.

In the HeartRateView, we store the HeartDatain a property annotated withthe @ObservedObject property wrapper.

In the body of the view, we display the beatsPerMinutedirectly from the HeartData.

Now, let's use these together in our view controller.

Here is our HeartRateViewController.

It stores the HeartData ObservableObject in a property.

Because this property is not inside a SwiftUI view,we don't need to use a property wrapper here.

The HeartRateViewController is initializedwith a HeartData instance,which is used to create a HeartRateViewthat becomes the rootView of the hosting controller.

The diagram illustrates how this comes together.

We fetch the current HeartData instance,which contains a heart rate of 78 beat per minute.

Then we create a new HeartRateViewControllerwith that HeartData instance,which wires it up to the SwiftUI HeartRateView.

After a few seconds,when the next heart rate data sample arrives,the heart data's beatsPerMinute property is updated to 94.

Because this changes a published propertyon an ObservableObject, the HeartRateViewis automatically updated to display the new value.

We no longer need to manually update the hosting controllerwhen the data changes.

This is why ObservableObject is a great way to bridge datafrom UIKit to SwiftUI.

Next, let's talk about using SwiftUI in collection viewand table view cells.

New in iOS 16 is UIHostingConfiguration,which lets you harness the power of SwiftUIinside your existing UIKit, collection, and table views.

UIHostingConfiguration makes it easy to implementcustom cells using SwiftUI, without needing to worryabout embedding an extra view or view controller.

Before we dive deeper on UIHostingConfiguration,let's review cell configurations in UIKit.

Cell configurations are a modern wayto define the content, styling, and behavior of cells in UIKit.

Unlike a UIView or UIViewController,a configuration is just a lightweight struct.

It's inexpensive to create.

A configuration is only a descriptionof a cell's appearance, so it needs to be appliedto a cell to have an effect.

Configurations are composable,and work with both UICollectionViewand UITableView cells.

For more details, you can watch "Modern cell configuration."With that in mind, let's dive inand start using UIHostingConfiguration!UIHostingConfiguration is a content configurationthat is initialized with a SwiftUI ViewBuilder.

That means we can start writing SwiftUI codeto create views directly inside it.

In order to render the hosting configuration,we set it to the contentConfiguration propertyof the UICollectionView or UITableView cell.

Let's start writing some SwiftUI codein this hosting configuration to build a custom heart rate cell.

We'll start by creating a label with the text "Heart Rate"and the image of a heart.

SwiftUI views receive default stylingbased on the context they are used in.

But we can start customizing the stylingusing standard SwiftUI view modifiers.

Let's make the image and text pink with a bold font,by adding the foregroundStyle and font modifiers to our label.

Since we're just writing regular SwiftUI code,we can factor out our code into a standalone viewanytime we want.

Here, we create a new SwiftUI viewnamed HeartRateTitleView,moved the code we had into its body,and then used that HeartRateTitleViewin the hosting configuration.

As shown in the cell,it produces the exact same result.

Now we can start adding more viewsinside the HeartRateTitleView.

I've put the label inside of an HStack with a spacer,then added the current time in a Text view next to it.

That's looking pretty good so far.

Let's add some more content to this custom cellbelow the HeartRateTitleView.

To do this, we'll insert a VStackinside the hosting configurationso we can add more content below the HeartRateTitleView.

Then we'll put two Text views togetherin a HStack to display 90 BPMand then apply a few modifiers to style them the way we want.

Just like we did before with the HeartRateTitleView,we can move this new code into its own SwiftUI view.

Now the same code is extracted into the bodyof the HeartRateBPMView.

Our cell is looking great,but I have an idea for another thing we could add.

New in iOS 16 is the Swift Charts framework,which lets you visualize data with beautiful graphsin only a few lines of code.

Let's try using it to display a small line chartright inside the cell.

Using the new Chart view, we create a small line chartthat visualizes recent heart rate samplesand display that next to the BPM view in the cell.

To generate the chart,we pass in a collection of heart rate samples,and draw a LineMark that connects all of the samples.

We can add a circle symbolto indicate each sample on the lineand apply a pink foreground style,to tint the chart to match the HeartRateTitleView.

We're only scratching the surface of what you can dowith the new Swift Charts framework,so be sure to check out the video "Hello Swift Charts"to learn more about it.

Not only does our finished heart rate cell look awesome,but it was easy to make in just a couple of minutes.

That's how easy it is to start building custom cellswith UIHostingConfiguration and SwiftUI.

Let's talk about four special featuresthat UIHostingConfiguration supports.

By default, the root-level SwiftUI contentis inset from the edges of the cell,based on the cell's layout margins in UIKit.

This ensures that the cell contentis properly aligned with the content of adjacent cellsand other UI elements, such as the navigation bar.

Sometimes, you may want to use different margins,or have the content extend to the edges of the cell.

For these cases, you can change the default marginsby using the margins modifier on UIHostingConfiguration.

If you want to customize a cell's background appearanceusing SwiftUI, you can use the background modifieron the UIHostingConfiguration.

There are a few key differences betweena UIHostingConfiguration's background and its content.

The background is hosted at the the back of the cell,underneath your SwiftUI content in the cell's content view.

Additionally, while content is typicallyinset from the cell's edges,backgrounds extend edge to edge in the cell.

Finally, when using self-sizing cells,only the cell content influences the size of the cell.

Next, let's examine two more special featuresof UIHostingConfiguration that you can usewhen you have a cell inside a collection view listor table view.

In a list, the separator below the cellis automatically aligned to the SwiftUI textin your hosting configuration by default.

In this example, notice how the leading edge of the separatoris inset past the image so that it aligns with the textin the cell.

If you need to align the separatorto a different SwiftUI view in your hosting configuration,use the alignmentGuide modifier.

When inside a collection view list or table view,you can configure swipe actions for a row directly with SwiftUI.

By creating your buttons inside the swipeActions modifier,you'll be able to swipe the cellto reveal and perform your custom actions.

Download the sample code for this videoto find a complete example.

When defining swipe actions,make sure your buttons perform their actionsusing a stable identifier for the item represented.

Do not use the index path,as it may change while the cell is visible,causing the swipe actions to act on the wrong item.

When you're using UIHostingConfigurationin a cell, keep in mind that the cell interactionssuch as tap handling, highlighting,and selection will still be handledby the collection view or table view.

If you need to customize your SwiftUI viewsfor any of these UIKit cell states,you can create your hosting configurationinside of the cell's configurationUpdateHandler,and use the state provided in your SwiftUI code.

The configurationUpdateHandler runs againany time the cell's state changes,creating a new UIHostingConfigurationfor the new state and applying it to the cell.

In this example, we use the state to add a checkmark imagewhen the cell is selected.

Now that you're familiar with UIHostingConfiguration,let's discuss how to manage data flow from your model layerto a UICollectionView or UITableViewfilled with cells using SwiftUI.

Our goal is to build this list of medical conditions.

In this example, we're using a UICollectionView,but everything we discuss applies equally to UITableView.

Let's go through the components involved.

Our app has a collection of MedicalCondition model objects,which we are going to display in the collection view.

For each item in this collection,we want to create a cell in the collection viewto display that medical condition.

In order to do this, we'll create a diffable data sourceconnected to the collection view.

Then, we need to populate a diffable data source snapshotwith the identifiers of the MedicalCondition model objectsin the data collection.

It's important that the diffable data source snapshotcontains the unique identifier of each MedicalCondition,and not the MedicalCondition objects themselves.

This ensures that the diffable data source can accurately trackthe identity of each item,and compute the correct changeswhen new snapshots are applied later.

By applying a snapshot with these item identifiersto the diffable data source,it will automatically update the collection view,which will create a new cell for each item.

Each cell is configured to display one MedicalCondition,using a SwiftUI view in a UIHostingConfiguration.

Now that we're displaying cells built with SwiftUI,we need to handle updating the UI when the data changes.

There are two different types of changesthat we need to handle separately.

The first type is when the data collection itself changes.

For example, when items are inserted, reordered, or deleted.

These changes are handled by applying a new snapshotto the diffable data source.

Diffable data source will diff the old and new snapshots,and perform the necessary updates to the collection view,causing cells to be inserted, moved, or deleted.

Because changes to the collection of data itselfdon't affect anything inside of cells,you handle these types of changes the same,whether you build your cells using UIKit or SwiftUI.

The second type of change we need to handleare when the properties of individual model objects change.

These changes often require updating the viewsin existing cells.

Because the diffable data sourceonly contains item identifiers in its snapshot,it doesn't know when the propertiesof existing items change.

Traditionally, when using UIKit, you would need to manuallytell the diffable data source about these changesby reconfiguring or reloading items in the snapshot.

But when using SwiftUI in cells, this isn't necessary anymore.

By storing the ObservableObject modelin an ObservedObject property in our SwiftUI view,changes to published propertiesof the model will automatically trigger SwiftUIto refresh the view.

This establishes a direct connection between the modeland the SwiftUI view inside of the cell.

When a change is made,the SwiftUI views in the cell are updated directly,without going through the diffable data sourceor the UICollectionView.

When a cell's data changes,it may cause the cell to need to grow or shrinkto fit the new content.

But if the SwiftUI cell content is being updated directlywithout going through UIKit,how does the collection view know to resize the cell?UIHostingConfiguration takes advantage of a brand-new featurein UIKit to make this work.

In iOS 16, self-sizing cells in UICollectionViewand UITableView are now also self-resizing!This is enabled by default,so that when you're using UIHostingConfigurationand the SwiftUI content changes, the containing cellis automatically resized if necessary.

You can learn more about how this new feature worksin the "What's New in UIKit" video from WWDC 2022.

There's one more aspect of data flowthat you may need to handle, and that's sending data outfrom a SwiftUI view back to other parts of your app.

Once again, ObservableObject has got you covered!You can create a two-way binding to a published propertyof an ObservableObject.

Not only will data flow from the ObservableObject into SwiftUI,but SwiftUI can write back changes to the propertyon the model object.

Let's go through a simple exampleof creating a two-way bindingby making the text in our MedicalCondition cell editable.

Here is our ObservableObject, MedicalCondition.

It stores a unique identifier in an ID property.

This is the identifier used to populatethe diffable data source snapshot.

And this published property stores the textof the medical condition.

Here's the MedicalConditionViewthat displays the medical condition text inside each cell.

Right now this text is read-only,so let's make it editable.

All we need to do is to change the Text view to a TextFieldand create a binding to the text propertyof our MedicalCondition by adding a dollar sign prefix.

When you type into the text field,this binding allows SwiftUI to write back changesdirectly to the ObservableObject.

That's really how simple it isto set up two-way data flow with SwiftUI.

UIHostingController is a powerful wayto embed SwiftUI content into your UIKit app.

Your SwiftUI view is renderedinside the hosting controller's view,and you can use the hosting controlleranywhere that you can use a view controller in UIKit.

When using UIHostingController,make sure to always add the view controllertogether with the view to your app.

Many SwiftUI features, such as toolbars, keyboard shortcuts,and views that use UIViewControllerRepresentable,require a connection to the view controller hierarchyin UIKit to integrate properly,so never separate a hosting controller's viewfrom the hosting controller itself.

For comparison, when you applya UIHostingConfiguration to a cell,your SwiftUI view is hosted in the cellwithout a UIViewController.

UIHostingConfiguration supports the vast majorityof SwiftUI features.

But keep in mind that SwiftUI viewsthat depend on UIViewControllerRepresentablecan't be used inside of cells.

With UIHostingController and UIHostingConfiguration,you have two great ways to incorporate SwiftUIinto your UIKit app.

SwiftUI integrates seamlessly into existing UIKit appsUse UIHostingController to add SwiftUI throughout your app.

Create custom cells in your collection and table viewusing UIHostingConfiguration.

And take advantage of ObservableObject,so your data and UI is always in sync.

Add SwiftUI to your app today!Thank you for watching!♪

2:09 -Presenting a UIHostingController

2:31 -Embedding a UIHostingController

3:13 -Presenting UIHostingController as a popover

5:27 -Passing data to SwiftUI with manual UIHostingController updates

7:51 -Passing an ObservableObject to automatically update SwiftUI views

8:30 -Passing an ObservableObject to automatically update SwiftUI views

9:52 -UIHostingConfiguration

11:02 -Building a custom cell using SwiftUI with UIHostingConfiguration

12:46 -Building a custom cell using SwiftUI with UIHostingConfiguration

13:41 -Building a custom cell using SwiftUI with UIHostingConfiguration, with a chart!

14:41 -Content margins

15:16 -Cell backgrounds

16:32 -List swipe actions

17:25 -Incorporating UIKit cell states

23:17 -Creating a two-way binding to data in SwiftUI

## Code Samples

```swift
// Presenting a UIHostingController



let
 heartRateView 
=
 
HeartRateView
() 
// a SwiftUI view


let
 hostingController 
=
 
UIHostingController
(rootView: heartRateView)


// Present the hosting controller modally


self
.present(hostingController, animated: 
true
)
```

```swift
// Embedding a UIHostingController



let
 heartRateView 
=
 
HeartRateView
() 
// a SwiftUI view


let
 hostingController 
=
 
UIHostingController
(rootView: heartRateView)


// Add the hosting controller as a child view controller


self
.addChild(hostingController)

self
.view.addSubview(hostingController.view)
hostingController.didMove(toParent: 
self
)


// Now position & size the hosting controller’s view as desired…
```

```swift
// Presenting UIHostingController as a popover



let
 heartRateView 
=
 
HeartRateView
() 
// a SwiftUI view


let
 hostingController 
=
 
UIHostingController
(rootView: heartRateView)


// Enable automatic preferredContentSize updates on the hosting controller

hostingController.sizingOptions 
=
 .preferredContentSize

hostingController.modalPresentationStyle 
=
 .popover

self
.present(hostingController, animated: 
true
)
```

```swift
// Passing data to SwiftUI with manual UIHostingController updates



struct
 
HeartRateView
: 
View
 {
    
var
 beatsPerMinute: 
Int


    
var
 body: 
some
 
View
 {
        
Text
(
"
\(beatsPerMinute)
 BPM"
)
    }
}


class
 
HeartRateViewController
: 
UIViewController
 {
    
let
 hostingController: 
UIHostingController
< 
HeartRateView
 >
    
var
 beatsPerMinute: 
Int
 {
        
didSet
 { update() }
    }

    
func
 
update
() {
        hostingController.rootView 
=
 
HeartRateView
(beatsPerMinute: beatsPerMinute)
    }
}
```

```swift
// Passing an ObservableObject to automatically update SwiftUI views



class
 
HeartData
: 
ObservableObject
 {
    
@Published
 
var
 beatsPerMinute: 
Int


    
init
(
beatsPerMinute
: 
Int
) {
       
self
.beatsPerMinute 
=
 beatsPerMinute
    }
}


struct
 
HeartRateView
: 
View
 {
    
@ObservedObject
 
var
 data: 
HeartData


    
var
 body: 
some
 
View
 {
        
Text
(
"
\(data.beatsPerMinute)
 BPM"
)
    }
}
```

```swift
// Passing an ObservableObject to automatically update SwiftUI views



class
 
HeartRateViewController
: 
UIViewController
 {
    
let
 data: 
HeartData

    
let
 hostingController: 
UIHostingController
<
HeartRateView
>  

    
init
(
data
: 
HeartData
) {
        
self
.data 
=
 data
        
let
 heartRateView 
=
 
HeartRateView
(data: data)
        
self
.hostingController 
=
 
UIHostingController
(rootView: heartRateView)
    }
}
```

```swift
cell.contentConfiguration 
=
 
UIHostingConfiguration
 {
  
// Start writing SwiftUI here!

}
```

```swift
// Building a custom cell using SwiftUI with UIHostingConfiguration


cell.contentConfiguration 
=
 
UIHostingConfiguration
 {
    
HeartRateTitleView
()
}


struct
 
HeartRateTitleView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
HStack
 {
            
Label
(
"Heart Rate"
, systemImage: 
"heart.fill"
)
                .foregroundStyle(.pink)
                .font(.system(.subheadline, weight: .bold))
            
Spacer
()
            
Text
(
Date
(), style: .time)
                .foregroundStyle(.secondary)
                .font(.footnote)
        }
    }
}
```

```swift
// Building a custom cell using SwiftUI with UIHostingConfiguration


cell.contentConfiguration 
=
 
UIHostingConfiguration
 {
    
VStack
(alignment: .leading) {
        
HeartRateTitleView
()
        
Spacer
()
        
HeartRateBPMView
()
    }
}


struct
 
HeartRateBPMView
: 
View
 {
    
var
 body: 
some
 
View
 {
        
HStack
(alignment: .firstTextBaseline) {
            
Text
(
"90"
)
                .font(.system(.title, weight: .semibold))
            
Text
(
"BPM"
)
                .foregroundStyle(.secondary)
                .font(.system(.subheadline, weight: .bold))
        }
    }
}
```

```swift
// Building a custom cell using SwiftUI with UIHostingConfiguration


cell.contentConfiguration 
=
 
UIHostingConfiguration
 {
    
VStack
(alignment: .leading) {
        
HeartRateTitleView
()
        
Spacer
()
        
HStack
(alignment: .bottom) {
            
HeartRateBPMView
()
            
Spacer
()
            
Chart
(heartRateSamples) { sample 
in

                
LineMark
(x: .value(
"Time"
, sample.time),
                         y: .value(
"BPM"
, sample.beatsPerMinute))
                   .symbol(
Circle
().strokeBorder(lineWidth: 
2
))
                   .foregroundStyle(.pink)
            }
        }
    }
}
```

```swift
cell.contentConfiguration 
=
 
UIHostingConfiguration
 {
    
HeartRateBPMView
()
}
.margins(.horizontal, 
16
)
```

```swift
cell.contentConfiguration 
=
 
UIHostingConfiguration
 {
   
HeartTitleView
()
} 
.background(.pink)
```

```swift
cell.contentConfiguration 
=
 
UIHostingConfiguration
 {
    
MedicalConditionView
()
        .swipeActions(edge: .trailing) { 
…
 }
}
```

```swift
// Incorporating UIKit cell states


cell.configurationUpdateHandler 
=
 { cell, state 
in

    cell.contentConfiguration 
=
 
UIHostingConfiguration
 {
      
HStack
 {
        
HealthCategoryView
()
            
Spacer
()
            
if
 state.isSelected {
                
Image
(systemName: 
"checkmark"
)
            }
        }
    }
}
```

```swift
// Creating a two-way binding to data in SwiftUI



class
 
MedicalCondition
: 
Identifiable
, 
ObservableObject
 {
    
let
 id: 
UUID

   
    
@Published
 
var
 text: 
String

}


struct
 
MedicalConditionView
: 
View
 {
    
@ObservedObject
 
var
 condition: 
MedicalCondition


    
var
 body: 
some
 
View
 {
        
HStack
 {

            
Spacer
()
        }
    }
}
```


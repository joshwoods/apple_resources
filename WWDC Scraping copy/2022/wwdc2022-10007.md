# Wwdc2022 10007

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

What's new with in-app purchaseLearn how you can make your in-app purchase experience even better on iPhone, iPad, Mac, and Apple Watch. We'll take you through enhancements to StoreKit 2 and App Store Server API, and explore improvements to App Store Server Notifications. Discover how you can verify app purchases with App Transaction API, add properties to your StoreKit models, incorporate SwiftUI-friendly APIs and StoreKit Messages, and preserve applicationUsername in transactions. For those working server-side, we'll show you how to make the most of App Store Server Notifications, additional ways to retrieve user transaction history, and recovery steps when your server experiences an outage.ResourcesenvironmentGet Notification HistoryGet Test Notification StatusGet Transaction HistoryrecentSubscriptionStartDateRequest a Test NotificationHD VideoSD VideoRelated VideosWWDC23Explore testing in-app purchasesWhat’s new in App Store server APIsWhat’s new in StoreKit 2 and StoreKit Testing in XcodeWWDC22Explore in-app purchase integration and migrationImplement proactive in-app purchase restoreWhat's new in StoreKit testingWWDC21Manage in-app purchases on your serverMeet StoreKit 2Support customers and handle refunds

Learn how you can make your in-app purchase experience even better on iPhone, iPad, Mac, and Apple Watch. We'll take you through enhancements to StoreKit 2 and App Store Server API, and explore improvements to App Store Server Notifications. Discover how you can verify app purchases with App Transaction API, add properties to your StoreKit models, incorporate SwiftUI-friendly APIs and StoreKit Messages, and preserve applicationUsername in transactions. For those working server-side, we'll show you how to make the most of App Store Server Notifications, additional ways to retrieve user transaction history, and recovery steps when your server experiences an outage.

environment

Get Notification History

Get Test Notification Status

Get Transaction History

recentSubscriptionStartDate

Request a Test Notification

HD VideoSD Video

HD Video

SD Video

Explore testing in-app purchases

What’s new in App Store server APIs

What’s new in StoreKit 2 and StoreKit Testing in Xcode

Explore in-app purchase integration and migration

Implement proactive in-app purchase restore

What's new in StoreKit testing

Manage in-app purchases on your server

Meet StoreKit 2

Support customers and handle refunds

Search this video…♪ Mellow instrumental hip-hop music ♪♪Dani Chootong: Hello, and welcome to"What's new with in-app purchase."I'm Dani, and I'm an engineer on the StoreKit team.Today I'll be presenting with my colleague Ian,and we'll be going over the new improvementswe're bringing to in-app purchase this year.Last year, we introduced StoreKit 2,a set of new APIs designed from the ground upto make it simple to integrate in-app purchases.StoreKit 2 uses modern language features,including Swift concurrency using the async/await pattern.On the server side,we complemented these new StoreKit featureswith an entirely new set of App Store Server endpoints.These server endpoints make it easy to retrievetransaction information and check subscription statuson your server.We also released Version 2 of App Store Server Notifications,to make tracking the subscription lifecycleon your server easier than ever.Today I'll be going over these new APIs,as well as enhancements we're bringingto the new StoreKit models.Then, Ian will walk you throughsome exciting new server updates,including App Store Server API enhancementsand brand-new APIs for App Store Server Notifications.First, I'll go over the new App Transaction APIfor verifying the purchase of your app.Next, I'll dig into some new properties we've addedto our StoreKit models.I'll introduce you to the new SwiftUI friendly APIsfor redeeming subscription offer codesand asking a customer to review your app.Then, I'll introduce you to StoreKit Messages,an API used to displayApp Store messages to your customers.And finally, I'll go over an enhancement we're addingto preserve Application Username when you're migratingfrom the original to the modern StoreKit APIs.Throughout this presentation, I'll be using my favorite app,Food Truck.In the Food Truck app, I manage a pop-up donut food truckthat visits various cities to make donut deliveries.So, let's get started!Meet App Transaction.The App Transaction is our new APIfor verifying the purchase of your app.The App Transaction represents the signed informationfor the purchase of your app for the device it's running on.It's signed using JWS,and it replaces the app detail portion of the app receiptfrom the original StoreKit API.Just like transaction verification,StoreKit performs automatic verificationof the app transaction for you.However, if you wish, you can also performyour own validation.Validating a JWS signature is a well-documented standard.You can refer to the public documentationto implement your own validation.StoreKit takes care of automatically updatingthe App Transaction when necessary.However, in the rare case that the userthinks there's something wrong, it can be refreshed.You should provide UI in your appto allow your customers to refresh the app transaction.This should only be used in response to user action,as refreshing the App Transactionprompts the user to authenticate.Preventing fraud isn't the only reason to love App Transaction.If you're looking to switch business models from a paid appto a free app that offers in-app purchases,if you're curious about which of your customerspreordered your app,or even if you just want to know when your app was purchased,these are all situations you can handle with App Transaction.In the app receipt, the receipt payloadcombine the purchase data about your applicationalong with all the in-app purchases that have occurred.These are now broken up into two separate componentsin StoreKit.The first of these is the Transaction History.StoreKit's transaction APIs give you insightinto the user's entire in-app purchase history,right on the device.These APIs allow you to find the exact information you need,including the user's latest transactions,unfinished transactions, and current entitlements.If you prefer to perform these calculations on your server,you can also get the user's purchase historyfrom the App Store Server API.Ian will have some exciting updates on thislater this session.And the second component is the App Transaction,which contains the data you need to make surethat your app is valid for the device it's running on.It's easy to verify the purchase of your appusing App Transaction, and in just a moment,I'll be going over an example of how you can use it.But first, let me give you some backgroundabout my favorite app.With Food Truck, I'm able to make donut deliveries,check in on a basic social feed,and visualize my sales history.Keeping all this information in a databaseis an ongoing cost for my app, so to help me cover the costs,I'm going to turn the yearly sales history chartinto a onetime purchase.Additionally, I want to enhance the social feed.So instead of just seeing what others are sayingabout my food truck, I want to provide the toolsso I can engage with my customers as well.This will be a subscription service,and I'll have a monthly and a yearly plan.Food Truck began as a paid app, but I'm going to make the switchto a free app that offers in-app purchases.But I don't want my existing customerswho already purchased Food Truck to feel left out.So, I'll be using the App Transactionto make sure that the customers who purchased Food Truckcontinue to have access to the premium content they paid for.Here's the timeline for Food Truck.At the initial release, Food Truck started outas a paid app that cost $4.99.Version 1.0 offered donut deliveries,a basic social feed, and sales history charts.Later, at the release of version 8.0,my business model changed.Food Truck is now free, but includesa variety of in-app purchases which unlock premium features.The yearly sales history chart is now a nonconsumableonetime purchase, and now there'sa new subscription service for a premium social feedthat gives you advanced engagement tools.Now let's take a look at two different types of customerswho might be affected by this.Alice found out about my Food Truck app in version 2.5,and she decided she wants to share her passion for donutsin the digital world.So, she purchased my app for $4.99and began her donut delivery journey.A second customer, Bob, finds out about my Food Truck appthough a friend and downloads it for freein the App Store in version 8.2.In this scenario, Alice, who purchased my appbefore it became free, should still have accessto all the premium content she already paid for.She still has the option to purchase the premiumsocial feed subscription, but I don't want to deny herthe yearly sales history chart that was initially included.Bob, however, got my app for free.I know then not to unlock features and contentuntil they complete the in-app purchase.So, let's see how we can achieve thiswith App Transaction in code.I'll start off by fetching the app transactionby calling AppTransaction.shared.This call gets me a VerificationResultcontaining my app transaction.Within the result, the AppTransaction typecontains the JWS payload.Next, I'll switch on the result.If the result is unverified, this would be a good timeto alert the user that their app purchasecould not be verified by the App Store,and then, I can prompt them to refresh the app transaction.At this time, I'll offer a minimal experience for my app.If the result is verified, I'm going to use this asan opportunity to check whether the user has purchased my app.Customers that purchased my appshould be granted the services they paid for.For this, I'll use the original app version property.This property lets me know the app version in whichthe customer had downloaded my app for the very first time.Version 8.0 is the version in which my app became freewith in-app purchases.I'm going to pass the customer's original app versionto my function which checks if the user purchased my appbefore version 8.0.And with that, I can make an informed decision abouthow I should go about providing premium content to my users.For customers like Alice, who purchased my app,I'm going to provide the content the user is entitled tothat they had at the time of purchase.In my case, I'm going to unlock the yearly sales history chartfor her deliveries.Also, I want to check any additional in-app purchasesthey may have made so I can provide that as well.Otherwise, I can be confident that the user downloaded my appafter I switched my business model, like Bob.This can be a good timeto check the user's current entitlementsso I can unlock the features and content they paid for.And with just a few lines of code,I was able to verify the purchase of my app,check whether the user downloadedthe paid version of my app,and I can immediately start providing my premium content,whether the customer purchased my app or not.With App Transaction, you can easily supportyour customers whether they're early supportersor if they've just recently downloaded your app.Now I'd like to move on to the new propertieswe're adding to our StoreKit models.The first of these properties is the price locale.The price locale is now included in StoreKit products.You may already be familiar with price localefrom interfacing with our original purchase APIs.Next, I'll dig into the server environment property.Now, you can tell the server environmenta transaction or renewal info occurred in.Then, I'll move onto the recent subscriptionstart date property.You can use this as a tool to make informed decisionsfor your customers based on their subscription patterns.And lastly, I'll go over some special considerationsfor these properties when you're using themwith StoreKit Testing in Xcode.These properties return sentinel valuesin older operating systems, and I'll explain what this meansin just a bit.The StoreKit APIs were designed with flexibility in mind,so I'm proud to announcethat you can take advantage of these new propertieson devices as far back as last year's operating systems,even though they did not originally ship with them.All you'll need to make this happen is to useXcode 14 to build your app, and you'll have accessto these properties in the previous operating systems.This is possible because the implementationfor these properties are compiled into your app,so when your customers update to the new version,they'll be able to get the benefits of these enhancementswithout needing to update their operating system.There is one thing to keep in mindwhen using these properties, though.These properties will return sentinel valueswhen you're using StoreKit testing in Xcodein these older operating systems.When I say sentinel values,I'm referring to placeholder values that signalthat these are not real values you should work with,and I'll explain why this occurs.The sandbox and production environmentsmake use of these properties by extracting the valuesfrom the App Store server response.StoreKit testing in Xcode, however,is a local testing environment that operates independentlyfrom the App Store server.This means we're not able to backport the value of theseproperties to the previous operating systems there.You can easily get around this limitationby updating your test device to a new operating system,and you'll be all set to test these valuesin the local environment.Let's discuss some situations that demonstratehow you can start using these new properties,the first of which is price locale.StoreKit products already have a display price propertyto label the purchase price, but with price locale,you can format numbersderiving from the product's decimal price.If you have a yearly subscription,you might use this as an opportunityto show your customers how much it would cost them per month.In this example, you can see that the yearly subscriptionamounts to $4.17 per month.Or perhaps you'd want to show themhow much they would save if they purchased your yearly serviceover your monthly service.With this information, your customers can makeinformed decisions when they're consideringyour purchase options.Now, let's move on to the environment property.The environment property is availablein the Transaction and renewal Info.This property tells you the server environmentin which the transaction or renewal info originated in,which could be Xcode, sandbox, or production.Your app may communicatetransaction information to your server after a customermakes a purchase for bookkeeping and analytics.When your app generates these transactions,it could be from any one of these server environments.Like most of you, I don't want to add noiseto my analytics with irrelevant test data.So, knowing the environment can help youfilter out unnecessary information from being sent upto your server.Finally, let's take a look atthe recent subscription start date.The recent subscription start date is availablewithin a product's subscription information,and it represents the most recent periodof continuous subscription.A subscription is considered continuous if there is no morethan a 60-day gap between any two subscribed periods.Keep in mind that this period can contain gapswhere the customer was not subscribed to your product,so don't use this as an indicatorfor the number of days a customer has been subscribed.The recent subscription start date can help youdetermine a pattern of loyalty between you and your customers.For your loyal customers, you might offer them a rewardas a way to keep them engaged with your product.Or if you notice that a customerhas unsubscribed from your service,you can use it as a chance to win back a lapsed customerby offering them an incentive to start using your product again.I mentioned earlier that we'd take a closer lookat the sentinel values for these properties.As a reminder, when I say sentinel values,I'm referring to placeholder valuesthat serve as an indicator of the absence of a real value.The sentinel values for these properties are easy to identify.When you're dealing with price locale,the sentinel value is a locale with the identifier xx_XX.For the environment property, it'll be an empty string.And finally, for the recent subscription start date,this value is Date.distantPast.Luckily, the occurrence of these sentinel valuesare predictable -- you'll only encounter themif you're using StoreKit testing in Xcodein older operating systems,and you can get around this by updating your test device.So now you've seen the enhancementswe've made to our StoreKit models.And my favorite part is, they're backward compatibleall the way back to the operating systemin which the models were introduced,so your customers can see the benefits right awayjust by updating your app.When you perform arithmetic with price values,the price locale helps you correctly format itso that it matches the App Store's locale.For transactions and subscription information,the environment tells you exactlywhere they originated from,so if you store this data on your server,you can act on it accordingly depending on the environment.The recent subscription start date helps you understandcustomer loyalty, so you can tailor specific offersto long-time customers, or maybe you can providean incentive for customers who have unsubscribed.And in case you were wondering, yes, the environmentand recent subscription start date are also availablevia App Store Server API and App Store Server Notifications,which Ian will discuss.Now I'd like talk about the new SwiftUI APIs we're providingfor redeeming offer codes and requesting a review.Offer codes can help you acquire, retain,and win back subscribers by providing subscriptionsat a discount or free for a limited time.Now in App Store Connect, you can create uniquely namedcustom codes.There, you can set a maximum redemption limitand you can choose whether or not to set an expiration.Let's look at the SwiftUI implementation to presentan offer code redemption sheet straight from your app.Here, I've got a SwiftUI viewwith a button to trigger the offer code redeem sheet.The offer code redemption sheetnow has its own view modifier in SwiftUI.The view modifier is easy to use,it just needs a binding Boolean to start the process.And once the offer code sheet is dismissed,you'll get a result representingwhether or not the sheet presented successfully.When a customer redeems an offer code for your app,the resulting transactionis sent to the transaction listener.So, be sure to set up a transaction listeneras soon as your app launches to receive newand updated transactions while your app is running.The offer code view modifier is available starting on iOS 16.Next, I'd like to talk about updates to request review.Getting customer feedback is important.Potential new customers might use reviewsas a deciding factor in their decision to download your app.Others might want to leave a review as a way to providefeedback or suggestions.Either way, we want to give you the tools to make it easyfor you to request a rating from your customers,so you can let them know you're listeningand you can continue engaging with them.Let's review the code.Here I have a very simple viewto demonstrate the Request Review APIs.In SwiftUI, there's now an environment valuecalled requestReview.You can use this value to get an instanceof the RequestReviewAction,and when you're ready to request a rating,simply call the instance as a functionto request to display the review prompt.You can decide the right time to requesta review for your app.However, you should be aware that the prompt will only bedisplayed to customers a maximum of three timeswithin a 365-day period.And you shouldn't ask customersto review the same version of your app multiple times.Avoid interrupting customers with a review prompt.A good time to ask for a review could be after they'vehad a positive interaction, such as completing a purchaseon an e-commerce app, or completing a level in a game.Finally, customers can disable requests from ever appearingon their device, so you shouldn't requesta review as a result of a user action.These APIs are really going to come in handyfor your SwiftUI apps.Next, I'd like to introduce youto our new API for StoreKit messages.A StoreKit message represents a sheet that appears overyour app to display important information to the user.Messages are vended by the App Store.Each message has a reason,which is included in the message metadata.StoreKit messages are retrievedwhen your app comes to the foreground.As an example, let's take a look atone of the message reasons -- price increase consent.When you increase the price of a subscriptionand it requires user consent, the App Store will informaffected subscribers through email, push notification,and an in-app price consent sheet.In this case, the App Store requires that the useragrees to the new price of your subscriptionbefore it renews at the higher price.So, if you decide to charge more for your subscription,a price increase consent sheet may appearwhen a user opens your app if they haven't already respondedto your price increase.By default, StoreKit messages appear over your appwhen the user brings your app to the foreground,and it may ask the user to take some actionrelating to your app.Let's review this.The entire process starts with your app.When your app enters the foreground,StoreKit knows to checkif there's pending messages to display.And if there are, StoreKit checks in with the App Store.The App Store returns information about the messageto StoreKit.At this time, StoreKit checks whether your appis set up to receive messages.You can do this by setting up a message listener in your app,which I'll get into shortly.If your app has set up a message listener,StoreKit sends information about the message to your app.Now's your chance to decide whether or not it's a good timefor your app to display the message,or if you want to defer the presentation for later.If you don't set up a message listener,StoreKit displays the message right awayby presenting the message sheet over your app.I'll go over how to do this in code.But before I do that, I'll explain a situationin which it would be useful to control the presentationof an App Store message.In the Food Truck app, I'm able to customize the donutsI'm delivering to different cities.If a message gets delivered to my app during this time,it would be confusing to the user if they're suddenlyinterrupted by a message sheet, so I'm going to be implementingthe messages API to make sure this doesn't happenby controlling when incoming messages are presented.Now let's get into the code.Here, I have a simple view for the donut editor.As I mentioned earlier, pending messages are senteach time your app comes to the foreground.So, I want to set up a message listener in each viewin which I want to defer the presentation of a message.I'll add a binding array to collect all the messagesthat are delivered to my app while I'm in the editing view.This is important, because if I don't set up a message listener,StoreKit is going to display the message sheet right awaywhen my app comes to the foreground.As soon as the view appears, I set up my message listener.I'll do this by setting up a task that iteratesover a static property on the message type.This property is an async sequence,and I'm able to receive messages as they come in.For my use case, I'm going to save the messagein the pendingMessages array.Since pending messages get delivered each timeyour app enters the foreground, your app could receivethe same message more than once, so I have this conditionto avoid adding duplicate messages to my array.Then, once the view dismisses,I'll display the messages in the parent view.This is the parent view which holds a navigation linkto the donut editor.Here, I've collected all the pending messagesI need to display in this pendingMessages array.So how do I display these pending messages?Well, now there's an environment valuedisplayStoreKitMessage.This gets you an instance of a DisplayMessageAction,which you can then use to display a given message.When the view appears,I'll iterate through the pending messagesand call displayStoreKitMessagepassing in the message I want to display.StoreKit takes care of presenting the message sheet.Earlier, I mentioned that the same messagemay get delivered to your app more than once.That's because a message doesn't get marked as readuntil it's presented to the user.So, StoreKit makes sure that each unique messageis only presented once.And that was a quick implementationof the Messages API.Remember, StoreKit messages are sent to your app each timeit comes to the foreground, so you'll want to set upa message listener in each view in which you want to controlthe timing of when the messages are presented.You can ensure customers have a great experience by making suremessage sheets don't appear at unexpected moments.Or perhaps you want to tailor your logicfor certain messages types.With a price increase consent message,you may want to educate your customerabout the additional value you're providingbefore the price increase consent sheet appears.Finally, let's review how StoreKit preservesthe applicationUsername as an appAccountTokenafter a user makes a purchase.If you have a user account system on your server,chances are you're already making useof the applicationUsername property.The applicationUsername is a string that you createto associate a transaction with a user account on your service.In the original API for in-app purchase,you set the applicationUsername value when you add a paymentto the payment queue.Although the applicationUsername accepts any string,we recommend that you provide the string representationof a UUID.When you provide it a UUID string,StoreKit persists the value and you'll see itin the transaction that the queue updates.If you don't provide a UUID stringfor the applicationUsername, StoreKit may not persist it.There's no guarantee the value will persistbetween the time you add the payment transaction to the queueand when the queue updates the transaction.When you provide the string representation of a UUID,you can identify which of your app's user accountsbegan and completed a transaction.In the modern StoreKit APIs, we implement this conceptas a purchase option called appAccountTokenand it requires a UUID format.Now, when you set the applicationUsernameto a UUID string during payment,the App Store server stores it as an appAccountToken.So you'll see its UUID appear in the signed transaction inforeturned by the App Store Server APIand in V2 App Store Server Notifications.And as a UUID, it's compatible with the appAccountTokenin the modern StoreKit transaction APIs.So, now you can be sure that when you update your codebaseto the modern StoreKit APIs,the UUID you used for the applicationUsernameis preserved as an appAccountTokenin the StoreKit transactions.We touched on a lot of things today.Before moving on to the server updates,let's review this year's StoreKit updates.We discussed validating your app's purchasewith App Transaction,redeeming an offer code and requesting a review in SwiftUI,and controlling the presentation of StoreKit messages.We talked about new price locale, environment,and recent subscription start date properties.And, we went over the importance of usinga string representation of a UUID for the applicationUsernameto persist it as an app account token.I highly recommend you check out our other session"What's new in StoreKit testing."And if you need a refresher on the StoreKit 2 APIs,check out last year's session "Meet StoreKit 2."Now I'd like to hand it over to Ianto walk you through the updates to the App Store server.Ian Zanger: Thanks, Dani.Hi, everyone. My name is Ian,and I'm an engineer on the App Store Server team.Now that you've heard the latestabout in-app purchase with StoreKit,I'm going to switch gears and talk about the server.First, I'll review some recent developments from the past yearbefore moving on to some exciting new updatescoming to the App Store Server APIand App Store Server Notifications Version 2.Let's get started.Last year was big.We brought you an entirely new suite of endpointswith the App Store Server APIand App Store Server Notifications V2,including full sandbox testing supportfor all these new features.We shared how you can use the Get Transaction History endpointto get the full history of a user's in-app purchases,or the Get All Subscription Statuses endpointto stay up to date with the current stateof a user's subscriptions.Both of these endpoints conveniently keyoff of a user's originalTransactionId,so you can access this trove of databy storing just this one simple value.We also covered how version 2of App Store Server Notificationscan simplify event processing on your serverand complement the App Store Server API.With V2 notifications,the App Store server calls your server directly,providing in-app purchase updates as they happen.The streamlined notification type and subtypemake it easy to understand what's happening.You can use these to track changesrelated to in-app subscriptions and other events.With all of these data sources,we wanted to make that data as easy as possible to parse.Receipts are now a thing of the past,as these new services provide in-app datain signed JSON format, so you can easily parse itand trust that it came from the App Store server.Last year was a big year for the App Store server.It may have been big for you as wellif you worked to update your server codeto leverage all these new features.Rest assured that effort will continue to pay offas we bring powerful new enhancements and featuresto App Store Server API and App Store Server Notifications V2.That's our year in review,but if you'd like more of a refresherafter hearing this year's updates,be sure to check out the WWDC21 sessions titled"Manage in-app purchases on your server,""Meet StoreKit 2,"and "Support customers and handle refunds."Now let's move on to brand-new updatescoming to the App Store server for WWDC22.First I'll share some updates to transactionand renewal info fields.Next I'll tell you about new enhancementsto the App Store Server API.And finally, I'll share exciting new featurescoming to App Store Server Notifications V2.Now let's dive in with the first of our new topics:new fields found in transaction and renewal info.Earlier, you heard from Dani about a couple new fieldscoming to the transaction and renewal infoof in-app purchases.These fields, environment and recentSubscriptionStartDate,are also coming to the transactionand renewal info payloadsyou receive from the App Store Server APIand in V2 App Store Server Notifications.Let's take a fresh look at the data you can expect to receivefrom the App Store server with these new fields included.First is the transaction info payload,which we can see here after decoding.Down at the bottom, you can see our new field: environment.You can use it to tell, at a glance,whether the transaction took placein the production or sandbox environment.Next is the renewal info payload,also seen here after decoding.As you can see, the environment field is also available herefor your reference.Additionally, recentSubscriptionStartDatewill now appear in every renewal info payload.This is the start date of the user's firstsubscription purchase in their most recent string of renewals,ignoring any gaps of 60 days or fewer.recentSubscriptionStartDate is an easy way to get an ideaof a customer's loyalty at a glance.But if you'd like more detail,including the timing and length of any gaps in service,you can call the Get Transaction History endpointand examine the full historyof a user's subscription renewal purchases.Or for even more detail,with App Store Server Notifications V2,the App Store server automatically sends updatesabout user subscriptions to your server.These notifications give you maximum insightinto the timing of events like renewal preference changes,offer redemptions, billing failures, and more.As you can see, recentSubscriptionStartDaterounds out a suite of optionsfor determining customer loyalty.Use these tools to target offersand reward your most loyal customers.Now let's move on to some convenient new enhancementsto the Get Transaction History endpoint.With the Get Transaction History endpoint,you can fetch the full history of a user's purchasesin your app.The endpoint response is paginatedso you can process this data in reasonable chunks.Each response contains a revision token that you providein the next request in order to get the next page.And the pages are sorted by modified date,meaning each subsequent page contains transactionsthat are more recently modified.Let's take a look at how this works.You call the Get Transaction History endpoint,and provide an originalTransactionId.The App Store server will return up to 20 signed transactionsfor that user.It will also return an updated revision valuethat you will provide in your next page request for this user.You'll know there's more data availablewhen the hasMore field in the response is true.Let's say in this casethat there's another page of data available.You make another request to the endpoint,and you include that revision value from the first response.You receive the next page of data,including an updated revision value.hasMore is now false, so you know you're up to datewith the latest transaction data.Except this time, you notice somethingabout the final transaction in the response;you've seen it before!It was one of the original 20 you receivedin response to your first request.This means the transaction must have been modified,so it was put back at the top of the sort order.Now, you can examine the data of that transactionand take note of what's changed.In this instance, you notice the revocationDateand revocationReason fields are now populated,meaning the transaction was revoked.You can take action by revoking any contentassociated with the purchase.It's a good idea to store the revision valuefrom this final response alongsidethe originalTransactionId you used to identify the user.The next time you call the endpoint for this user,you can provide that revision and knowthat you're getting back only fresh transaction datathat has been modified since your last request.As you've seen, the Get Transaction History endpointprovides you a simple way to retrieve a comprehensive setof in-app purchase data.But maybe sometimes it can be a bit too comprehensive.Some users have lengthy purchase historiesdating back several years.For these users, this endpoint could returnhundreds of purchases of a variety of types.Even with pages, this can be a lot to handle.That's why this year, we're enhancing this endpointwith a variety of new sort and filter options.Now, you can tell us exactly the data you want from the start,saving processing time on your serverand reducing the number of network callsneeded to retrieve all available pages.You can sort by descending modified dateif you're interested in seeing the most recentlymodified purchases on the first page of results.You can also filter by several useful fieldssuch as product type, product ID,Family sharing status, and more.To apply these new sort and filter options,just append them as query parameters to your requestto the Get Transaction History endpoint.Let's take a closer look at how that works.Here you can see all the new parameter options.These may look familiar, since most are taken directlyfrom the transaction info payload.You can mix and match these parametersto get very specific results.For example, maybe we want to fetchonly the nonconsumable purchases a user has madesince the beginning of this year.We also want to exclude any revoked purchases.We will build our custom requestby setting the productType to NON_CONSUMABLEand specifying the startDate as the beginning of this yearrepresented in milliseconds.Finally, we'll set excludeRevoked to true.And that's our request!Since we did not specify a sort order,the response will default to sortingby ascending modified date.Now even with a request as specific as this,there could be multiple pages of purchases to retrieve.For follow-up requests, we should make sureto include the exact same query parameters,in addition to the revision from the previous response.For even more flexibility,three of the filter fields support multiple values,so you can filter to only those purchasesthat match at least one of the provided values.These fields are productType, productId,and subscriptionGroupIdentifier.To provide multiple values for these parameters,simply define them multiple times.Next let's move on to App Store Server Notification updates.With App Store Server Notifications V2,you can take your server to the next level.V2 notifications give detailed insightsabout in-app purchase eventsthat you can't get anywhere else.These are especially useful for tracking the lifecycleof autorenewable subscriptions offered in your app.You can use these insights to retain customers,win back those that have churned,resolve customer support requests, and more.With all of these benefits, you might wonder how to get started.As with any new feature,the sandbox testing environment is the best place to start.That's why last year,we added the ability to set a separate server URLin App Store Connect for receivingApp Store Server Notifications in sandbox.After registering your server URL,you'll want to confirm your serveris receiving notifications from the App Store server.You might set up a sandbox accountjust to trigger a notification through a user action.For example, let's say you perform a first time buyof a subscription using that sandbox account.You should receive a V2 notification of type SUBSCRIBEDand subtype INITIAL_BUY.But what if that notification doesn't come?You might wonder if there was an issue with your serveror the steps you took to trigger a notification.This situation can generate a lot of uncertaintyright as you're getting started.We want to simplify this experience and give you a wayto easily verify that App Store Server Notificationscan reach your server.That's why this year, we're introducing the newRequest a Test Notification endpoint.By calling this simple endpoint,you can ask us to send a V2 Notification of type TESTto the server URL registered for your app in App Store Connect.The new TEST notification type is used exclusivelyfor this endpoint.You can call the endpoint in sandbox or productionto test your saved URL for either environment.Use this new endpoint to quickly test new server URLsand configurations.Let's see how this simplifies first-time setup.Now, if you're just looking to trigger your first notification,there's no need to set up a sandbox accountor perform a purchase.Just call the new endpointin whichever environment you want to testand you'll receive an HTTP 200 responseconfirming your request.The response will contain a new field,testNotificationToken, which identifies the test notificationyour server will receive.We will come back to this field later.Shortly afterward, your server should receive a V2 notificationof type TEST at the URL saved in App Store Connect.Now let's see how to call this endpoint.Just send a simple POST request to this new pathon the App Store server.You'll receive an HTTP 200 responseand know that your request has been submitted.The response will contain that new field I mentioned,testNotificationToken.Take note of this for later.Soon you'll receive a signed TEST Notification.Here's what that notification will look likeonce it's decoded.You'll notice it contains all the usual top-level fieldsof a V2 notification,including the new notificationType, TEST.The contents of the data object are a bit shorterthan a normal notification.Since this is just a test,there are no transaction-related data to include,so we omit transaction-specific fields,most notably the signedTransactionInfo.When calling the new Request a Test Notification endpoint,keep in mind that App Store Server Notificationsare sent asynchronously.Your successful call to the endpointwill return an HTTP 200 but the actual test notificationwill arrive separately, a short while later.Given that this endpoint is all abouttesting your server configuration,you might be wondering what to do when that test fails.In other words, what if the test notification doesn't arrive?To further enhance your testing capabilities,we're releasing the Get Test Notification Status endpoint,which you will use in conjunctionwith the Request a Test Notification endpoint.With this new endpoint, you can check on the statusof a previously requested TEST notification.The endpoint response will tell you if the App Store serverwas able to reach your serverand successfully send the TEST notification.If the send failed, it will give you an idea of why,so you can better troubleshoot your server configuration.Let's check out how you'll use this endpoint.Send a GET request to this path on the App Store server.In the path, include the testNotificationTokenyou received from the Request a Test Notification endpoint.This will tell us which test notificationyou want to check the status of.Now for the response.The signedPayload field contains the TEST notification payloadthat the App Store server attempted to sendto your server.And the firstSendAttemptResult field indicates the resultof that send attempt.Here, SUCCESS indicates that the send was successful,meaning the App Store server received an HTTP 200 responsefrom your server.If the send was unsuccessful,you'll instead see one of several different error values.These values indicate the error the App Store server experiencedtrying to reach your server with the test notification.With this information, you can troubleshoot your server issue,request new test notifications as needed,and get your server running reliably.Collectively, these test notification endpointsare simple to use and can save you a lot of troublewhen setting up or reconfiguring your serverto receive V2 App Store Server Notifications.Now with the help of these endpoints,you can set up your server and confirm it's running smoothly.But servers aren't perfect and outages happen.How do you recover when your server goes down,leading you to miss App Store Server Notifications?The current solution to this is a retry system.When the App Store server fails to reach your server,it initiates a retry process.It will retry sending the same notification up to five times,with a longer wait between each attempt.These retries take place only in the production environment.Retries help you eventually recover from an outage,but they're not perfect for every situation.For example, some outages can be extensive.If your server is down long enoughto miss the final retry attempt from the App Store server,that notification is lost.Or more commonly,your server could experience a very brief issue,during which it misses only a handful of notifications.But missing even a single notificationmeans some of your customer records are out of datefor at least an hour.Yet you don't know which ones!Clearly, server outages are stressful,and recovering from them can be a complex task.That's why we want to make it as easy as possibleto recover missed App Store Server Notifications,so you can get your server back on track as soon as possible.That's why this year, we are introducing the newGet Notification History endpoint.With this endpoint,you can fetch the history of V2 App Store Server Notificationsgenerated for your app.Whether your server successfully received a notification or not,that notification will appear in the response of this endpoint.When calling this endpoint,you'll specify a date range of notifications to fetch.With WWDC, we have started recording this data,and we will build up to the cap of the latest six monthsof rolling history being available.You can optionally filter your request by type and subtype,or fetch just a single user's notificationsby providing an originalTransactionId.And the existing retry system is still available,so you can use it in tandem with this new endpoint.Let's take a look at how you'll call this endpoint.You'll send a POST request to this new pathon the App Store server.In the request body, you'll include a startDate and endDate.The response will contain only notificationswe first attempted to send in this window.Keep in mind that the earliest notifications availablewill be those sent six months before the date of your request.Optionally, you can specify a notificationTypeand notificationSubtype.If you do, the history will be filtered to only notificationsthat match both of these values.Keep in mind that some notifications have no subtype.Alternatively, you can providean originalTransactionId of a user,to fetch the notification history of only that user.Finally, you should provide a paginationTokenas a query parameter for every follow-up requestin order to get the next page.Make sure you use the same request bodyfor follow-up requests,changing only this paginationToken.Now let's take a look at the response.The notificationHistory array contains up to 20 notifications,with the oldest notifications first.Each entry in this array represents a notificationand inside you'll find the signedPayload,which you can decode as usual to view the transaction data.The data within is identical to the payloadthe App Store server sent in the original notification.You'll see that we've also brought the newfirstSendAttemptResult field to this endpoint response.You can use this field to look for sequences of timeoutsand other errors to better understand why your servermissed notifications in the past.The response also contains a paginationTokenif there are more pages to retrieve.You should provide this in your next requestin order to get the next page of notifications.You'll know there are more pages to retrieveas long as the hasMore field is true.And that's everything you need to knowabout this useful new endpoint.That concludes our App Store server updates for today.Every server feature announced today is available nowin both sandbox and production.We hope you'll take advantage of these new featuresto make your server the best it can be.For more great content on using a server with in-app purchase,including how to use the latest featureswhile supporting legacy clients,I encourage you to check out another session at WWDC22,"Explore in-app purchase integration and migration."Both: Thanks for joining us at WWDC22!♪

♪ Mellow instrumental hip-hop music ♪♪Dani Chootong: Hello, and welcome to"What's new with in-app purchase."I'm Dani, and I'm an engineer on the StoreKit team.

Today I'll be presenting with my colleague Ian,and we'll be going over the new improvementswe're bringing to in-app purchase this year.

Last year, we introduced StoreKit 2,a set of new APIs designed from the ground upto make it simple to integrate in-app purchases.

StoreKit 2 uses modern language features,including Swift concurrency using the async/await pattern.

On the server side,we complemented these new StoreKit featureswith an entirely new set of App Store Server endpoints.

These server endpoints make it easy to retrievetransaction information and check subscription statuson your server.

We also released Version 2 of App Store Server Notifications,to make tracking the subscription lifecycleon your server easier than ever.

Today I'll be going over these new APIs,as well as enhancements we're bringingto the new StoreKit models.

Then, Ian will walk you throughsome exciting new server updates,including App Store Server API enhancementsand brand-new APIs for App Store Server Notifications.

First, I'll go over the new App Transaction APIfor verifying the purchase of your app.

Next, I'll dig into some new properties we've addedto our StoreKit models.

I'll introduce you to the new SwiftUI friendly APIsfor redeeming subscription offer codesand asking a customer to review your app.

Then, I'll introduce you to StoreKit Messages,an API used to displayApp Store messages to your customers.

And finally, I'll go over an enhancement we're addingto preserve Application Username when you're migratingfrom the original to the modern StoreKit APIs.

Throughout this presentation, I'll be using my favorite app,Food Truck.

In the Food Truck app, I manage a pop-up donut food truckthat visits various cities to make donut deliveries.

So, let's get started!Meet App Transaction.

The App Transaction is our new APIfor verifying the purchase of your app.

The App Transaction represents the signed informationfor the purchase of your app for the device it's running on.

It's signed using JWS,and it replaces the app detail portion of the app receiptfrom the original StoreKit API.

Just like transaction verification,StoreKit performs automatic verificationof the app transaction for you.

However, if you wish, you can also performyour own validation.

Validating a JWS signature is a well-documented standard.

You can refer to the public documentationto implement your own validation.

StoreKit takes care of automatically updatingthe App Transaction when necessary.

However, in the rare case that the userthinks there's something wrong, it can be refreshed.

You should provide UI in your appto allow your customers to refresh the app transaction.

This should only be used in response to user action,as refreshing the App Transactionprompts the user to authenticate.

Preventing fraud isn't the only reason to love App Transaction.

If you're looking to switch business models from a paid appto a free app that offers in-app purchases,if you're curious about which of your customerspreordered your app,or even if you just want to know when your app was purchased,these are all situations you can handle with App Transaction.

In the app receipt, the receipt payloadcombine the purchase data about your applicationalong with all the in-app purchases that have occurred.

These are now broken up into two separate componentsin StoreKit.

The first of these is the Transaction History.

StoreKit's transaction APIs give you insightinto the user's entire in-app purchase history,right on the device.

These APIs allow you to find the exact information you need,including the user's latest transactions,unfinished transactions, and current entitlements.

If you prefer to perform these calculations on your server,you can also get the user's purchase historyfrom the App Store Server API.

Ian will have some exciting updates on thislater this session.

And the second component is the App Transaction,which contains the data you need to make surethat your app is valid for the device it's running on.

It's easy to verify the purchase of your appusing App Transaction, and in just a moment,I'll be going over an example of how you can use it.

But first, let me give you some backgroundabout my favorite app.

With Food Truck, I'm able to make donut deliveries,check in on a basic social feed,and visualize my sales history.

Keeping all this information in a databaseis an ongoing cost for my app, so to help me cover the costs,I'm going to turn the yearly sales history chartinto a onetime purchase.

Additionally, I want to enhance the social feed.

So instead of just seeing what others are sayingabout my food truck, I want to provide the toolsso I can engage with my customers as well.

This will be a subscription service,and I'll have a monthly and a yearly plan.

Food Truck began as a paid app, but I'm going to make the switchto a free app that offers in-app purchases.

But I don't want my existing customerswho already purchased Food Truck to feel left out.

So, I'll be using the App Transactionto make sure that the customers who purchased Food Truckcontinue to have access to the premium content they paid for.

Here's the timeline for Food Truck.

At the initial release, Food Truck started outas a paid app that cost $4.99.

Version 1.0 offered donut deliveries,a basic social feed, and sales history charts.

Later, at the release of version 8.0,my business model changed.

Food Truck is now free, but includesa variety of in-app purchases which unlock premium features.

The yearly sales history chart is now a nonconsumableonetime purchase, and now there'sa new subscription service for a premium social feedthat gives you advanced engagement tools.

Now let's take a look at two different types of customerswho might be affected by this.

Alice found out about my Food Truck app in version 2.5,and she decided she wants to share her passion for donutsin the digital world.

So, she purchased my app for $4.99and began her donut delivery journey.

A second customer, Bob, finds out about my Food Truck appthough a friend and downloads it for freein the App Store in version 8.2.

In this scenario, Alice, who purchased my appbefore it became free, should still have accessto all the premium content she already paid for.

She still has the option to purchase the premiumsocial feed subscription, but I don't want to deny herthe yearly sales history chart that was initially included.

Bob, however, got my app for free.

I know then not to unlock features and contentuntil they complete the in-app purchase.

So, let's see how we can achieve thiswith App Transaction in code.

I'll start off by fetching the app transactionby calling AppTransaction.shared.

This call gets me a VerificationResultcontaining my app transaction.

Within the result, the AppTransaction typecontains the JWS payload.

Next, I'll switch on the result.

If the result is unverified, this would be a good timeto alert the user that their app purchasecould not be verified by the App Store,and then, I can prompt them to refresh the app transaction.

At this time, I'll offer a minimal experience for my app.

If the result is verified, I'm going to use this asan opportunity to check whether the user has purchased my app.

Customers that purchased my appshould be granted the services they paid for.

For this, I'll use the original app version property.

This property lets me know the app version in whichthe customer had downloaded my app for the very first time.

Version 8.0 is the version in which my app became freewith in-app purchases.

I'm going to pass the customer's original app versionto my function which checks if the user purchased my appbefore version 8.0.

And with that, I can make an informed decision abouthow I should go about providing premium content to my users.

For customers like Alice, who purchased my app,I'm going to provide the content the user is entitled tothat they had at the time of purchase.

In my case, I'm going to unlock the yearly sales history chartfor her deliveries.

Also, I want to check any additional in-app purchasesthey may have made so I can provide that as well.

Otherwise, I can be confident that the user downloaded my appafter I switched my business model, like Bob.

This can be a good timeto check the user's current entitlementsso I can unlock the features and content they paid for.

And with just a few lines of code,I was able to verify the purchase of my app,check whether the user downloadedthe paid version of my app,and I can immediately start providing my premium content,whether the customer purchased my app or not.

With App Transaction, you can easily supportyour customers whether they're early supportersor if they've just recently downloaded your app.

Now I'd like to move on to the new propertieswe're adding to our StoreKit models.

The first of these properties is the price locale.

The price locale is now included in StoreKit products.

You may already be familiar with price localefrom interfacing with our original purchase APIs.

Next, I'll dig into the server environment property.

Now, you can tell the server environmenta transaction or renewal info occurred in.

Then, I'll move onto the recent subscriptionstart date property.

You can use this as a tool to make informed decisionsfor your customers based on their subscription patterns.

And lastly, I'll go over some special considerationsfor these properties when you're using themwith StoreKit Testing in Xcode.

These properties return sentinel valuesin older operating systems, and I'll explain what this meansin just a bit.

The StoreKit APIs were designed with flexibility in mind,so I'm proud to announcethat you can take advantage of these new propertieson devices as far back as last year's operating systems,even though they did not originally ship with them.

All you'll need to make this happen is to useXcode 14 to build your app, and you'll have accessto these properties in the previous operating systems.

This is possible because the implementationfor these properties are compiled into your app,so when your customers update to the new version,they'll be able to get the benefits of these enhancementswithout needing to update their operating system.

There is one thing to keep in mindwhen using these properties, though.

These properties will return sentinel valueswhen you're using StoreKit testing in Xcodein these older operating systems.

When I say sentinel values,I'm referring to placeholder values that signalthat these are not real values you should work with,and I'll explain why this occurs.

The sandbox and production environmentsmake use of these properties by extracting the valuesfrom the App Store server response.

StoreKit testing in Xcode, however,is a local testing environment that operates independentlyfrom the App Store server.

This means we're not able to backport the value of theseproperties to the previous operating systems there.

You can easily get around this limitationby updating your test device to a new operating system,and you'll be all set to test these valuesin the local environment.

Let's discuss some situations that demonstratehow you can start using these new properties,the first of which is price locale.

StoreKit products already have a display price propertyto label the purchase price, but with price locale,you can format numbersderiving from the product's decimal price.

If you have a yearly subscription,you might use this as an opportunityto show your customers how much it would cost them per month.

In this example, you can see that the yearly subscriptionamounts to $4.17 per month.

Or perhaps you'd want to show themhow much they would save if they purchased your yearly serviceover your monthly service.

With this information, your customers can makeinformed decisions when they're consideringyour purchase options.

Now, let's move on to the environment property.

The environment property is availablein the Transaction and renewal Info.

This property tells you the server environmentin which the transaction or renewal info originated in,which could be Xcode, sandbox, or production.

Your app may communicatetransaction information to your server after a customermakes a purchase for bookkeeping and analytics.

When your app generates these transactions,it could be from any one of these server environments.

Like most of you, I don't want to add noiseto my analytics with irrelevant test data.

So, knowing the environment can help youfilter out unnecessary information from being sent upto your server.

Finally, let's take a look atthe recent subscription start date.

The recent subscription start date is availablewithin a product's subscription information,and it represents the most recent periodof continuous subscription.

A subscription is considered continuous if there is no morethan a 60-day gap between any two subscribed periods.

Keep in mind that this period can contain gapswhere the customer was not subscribed to your product,so don't use this as an indicatorfor the number of days a customer has been subscribed.

The recent subscription start date can help youdetermine a pattern of loyalty between you and your customers.

For your loyal customers, you might offer them a rewardas a way to keep them engaged with your product.

Or if you notice that a customerhas unsubscribed from your service,you can use it as a chance to win back a lapsed customerby offering them an incentive to start using your product again.

I mentioned earlier that we'd take a closer lookat the sentinel values for these properties.

As a reminder, when I say sentinel values,I'm referring to placeholder valuesthat serve as an indicator of the absence of a real value.

The sentinel values for these properties are easy to identify.

When you're dealing with price locale,the sentinel value is a locale with the identifier xx_XX.

For the environment property, it'll be an empty string.

And finally, for the recent subscription start date,this value is Date.distantPast.

Luckily, the occurrence of these sentinel valuesare predictable -- you'll only encounter themif you're using StoreKit testing in Xcodein older operating systems,and you can get around this by updating your test device.

So now you've seen the enhancementswe've made to our StoreKit models.

And my favorite part is, they're backward compatibleall the way back to the operating systemin which the models were introduced,so your customers can see the benefits right awayjust by updating your app.

When you perform arithmetic with price values,the price locale helps you correctly format itso that it matches the App Store's locale.

For transactions and subscription information,the environment tells you exactlywhere they originated from,so if you store this data on your server,you can act on it accordingly depending on the environment.

The recent subscription start date helps you understandcustomer loyalty, so you can tailor specific offersto long-time customers, or maybe you can providean incentive for customers who have unsubscribed.

And in case you were wondering, yes, the environmentand recent subscription start date are also availablevia App Store Server API and App Store Server Notifications,which Ian will discuss.

Now I'd like talk about the new SwiftUI APIs we're providingfor redeeming offer codes and requesting a review.

Offer codes can help you acquire, retain,and win back subscribers by providing subscriptionsat a discount or free for a limited time.

Now in App Store Connect, you can create uniquely namedcustom codes.

There, you can set a maximum redemption limitand you can choose whether or not to set an expiration.

Let's look at the SwiftUI implementation to presentan offer code redemption sheet straight from your app.

Here, I've got a SwiftUI viewwith a button to trigger the offer code redeem sheet.

The offer code redemption sheetnow has its own view modifier in SwiftUI.

The view modifier is easy to use,it just needs a binding Boolean to start the process.

And once the offer code sheet is dismissed,you'll get a result representingwhether or not the sheet presented successfully.

When a customer redeems an offer code for your app,the resulting transactionis sent to the transaction listener.

So, be sure to set up a transaction listeneras soon as your app launches to receive newand updated transactions while your app is running.

The offer code view modifier is available starting on iOS 16.

Next, I'd like to talk about updates to request review.

Getting customer feedback is important.

Potential new customers might use reviewsas a deciding factor in their decision to download your app.

Others might want to leave a review as a way to providefeedback or suggestions.

Either way, we want to give you the tools to make it easyfor you to request a rating from your customers,so you can let them know you're listeningand you can continue engaging with them.

Let's review the code.

Here I have a very simple viewto demonstrate the Request Review APIs.

In SwiftUI, there's now an environment valuecalled requestReview.

You can use this value to get an instanceof the RequestReviewAction,and when you're ready to request a rating,simply call the instance as a functionto request to display the review prompt.

You can decide the right time to requesta review for your app.

However, you should be aware that the prompt will only bedisplayed to customers a maximum of three timeswithin a 365-day period.

And you shouldn't ask customersto review the same version of your app multiple times.

Avoid interrupting customers with a review prompt.

A good time to ask for a review could be after they'vehad a positive interaction, such as completing a purchaseon an e-commerce app, or completing a level in a game.

Finally, customers can disable requests from ever appearingon their device, so you shouldn't requesta review as a result of a user action.

These APIs are really going to come in handyfor your SwiftUI apps.

Next, I'd like to introduce youto our new API for StoreKit messages.

A StoreKit message represents a sheet that appears overyour app to display important information to the user.

Messages are vended by the App Store.

Each message has a reason,which is included in the message metadata.

StoreKit messages are retrievedwhen your app comes to the foreground.

As an example, let's take a look atone of the message reasons -- price increase consent.

When you increase the price of a subscriptionand it requires user consent, the App Store will informaffected subscribers through email, push notification,and an in-app price consent sheet.

In this case, the App Store requires that the useragrees to the new price of your subscriptionbefore it renews at the higher price.

So, if you decide to charge more for your subscription,a price increase consent sheet may appearwhen a user opens your app if they haven't already respondedto your price increase.

By default, StoreKit messages appear over your appwhen the user brings your app to the foreground,and it may ask the user to take some actionrelating to your app.

Let's review this.

The entire process starts with your app.

When your app enters the foreground,StoreKit knows to checkif there's pending messages to display.

And if there are, StoreKit checks in with the App Store.

The App Store returns information about the messageto StoreKit.

At this time, StoreKit checks whether your appis set up to receive messages.

You can do this by setting up a message listener in your app,which I'll get into shortly.

If your app has set up a message listener,StoreKit sends information about the message to your app.

Now's your chance to decide whether or not it's a good timefor your app to display the message,or if you want to defer the presentation for later.

If you don't set up a message listener,StoreKit displays the message right awayby presenting the message sheet over your app.

I'll go over how to do this in code.

But before I do that, I'll explain a situationin which it would be useful to control the presentationof an App Store message.

In the Food Truck app, I'm able to customize the donutsI'm delivering to different cities.

If a message gets delivered to my app during this time,it would be confusing to the user if they're suddenlyinterrupted by a message sheet, so I'm going to be implementingthe messages API to make sure this doesn't happenby controlling when incoming messages are presented.

Now let's get into the code.

Here, I have a simple view for the donut editor.

As I mentioned earlier, pending messages are senteach time your app comes to the foreground.

So, I want to set up a message listener in each viewin which I want to defer the presentation of a message.

I'll add a binding array to collect all the messagesthat are delivered to my app while I'm in the editing view.

This is important, because if I don't set up a message listener,StoreKit is going to display the message sheet right awaywhen my app comes to the foreground.

As soon as the view appears, I set up my message listener.

I'll do this by setting up a task that iteratesover a static property on the message type.

This property is an async sequence,and I'm able to receive messages as they come in.

For my use case, I'm going to save the messagein the pendingMessages array.

Since pending messages get delivered each timeyour app enters the foreground, your app could receivethe same message more than once, so I have this conditionto avoid adding duplicate messages to my array.

Then, once the view dismisses,I'll display the messages in the parent view.

This is the parent view which holds a navigation linkto the donut editor.

Here, I've collected all the pending messagesI need to display in this pendingMessages array.

So how do I display these pending messages?Well, now there's an environment valuedisplayStoreKitMessage.

This gets you an instance of a DisplayMessageAction,which you can then use to display a given message.

When the view appears,I'll iterate through the pending messagesand call displayStoreKitMessagepassing in the message I want to display.

StoreKit takes care of presenting the message sheet.

Earlier, I mentioned that the same messagemay get delivered to your app more than once.

That's because a message doesn't get marked as readuntil it's presented to the user.

So, StoreKit makes sure that each unique messageis only presented once.

And that was a quick implementationof the Messages API.

Remember, StoreKit messages are sent to your app each timeit comes to the foreground, so you'll want to set upa message listener in each view in which you want to controlthe timing of when the messages are presented.

You can ensure customers have a great experience by making suremessage sheets don't appear at unexpected moments.

Or perhaps you want to tailor your logicfor certain messages types.

With a price increase consent message,you may want to educate your customerabout the additional value you're providingbefore the price increase consent sheet appears.

Finally, let's review how StoreKit preservesthe applicationUsername as an appAccountTokenafter a user makes a purchase.

If you have a user account system on your server,chances are you're already making useof the applicationUsername property.

The applicationUsername is a string that you createto associate a transaction with a user account on your service.

In the original API for in-app purchase,you set the applicationUsername value when you add a paymentto the payment queue.

Although the applicationUsername accepts any string,we recommend that you provide the string representationof a UUID.

When you provide it a UUID string,StoreKit persists the value and you'll see itin the transaction that the queue updates.

If you don't provide a UUID stringfor the applicationUsername, StoreKit may not persist it.

There's no guarantee the value will persistbetween the time you add the payment transaction to the queueand when the queue updates the transaction.

When you provide the string representation of a UUID,you can identify which of your app's user accountsbegan and completed a transaction.

In the modern StoreKit APIs, we implement this conceptas a purchase option called appAccountTokenand it requires a UUID format.

Now, when you set the applicationUsernameto a UUID string during payment,the App Store server stores it as an appAccountToken.

So you'll see its UUID appear in the signed transaction inforeturned by the App Store Server APIand in V2 App Store Server Notifications.

And as a UUID, it's compatible with the appAccountTokenin the modern StoreKit transaction APIs.

So, now you can be sure that when you update your codebaseto the modern StoreKit APIs,the UUID you used for the applicationUsernameis preserved as an appAccountTokenin the StoreKit transactions.

We touched on a lot of things today.

Before moving on to the server updates,let's review this year's StoreKit updates.

We discussed validating your app's purchasewith App Transaction,redeeming an offer code and requesting a review in SwiftUI,and controlling the presentation of StoreKit messages.

We talked about new price locale, environment,and recent subscription start date properties.

And, we went over the importance of usinga string representation of a UUID for the applicationUsernameto persist it as an app account token.

I highly recommend you check out our other session"What's new in StoreKit testing."And if you need a refresher on the StoreKit 2 APIs,check out last year's session "Meet StoreKit 2."Now I'd like to hand it over to Ianto walk you through the updates to the App Store server.

Ian Zanger: Thanks, Dani.

Hi, everyone. My name is Ian,and I'm an engineer on the App Store Server team.

Now that you've heard the latestabout in-app purchase with StoreKit,I'm going to switch gears and talk about the server.

First, I'll review some recent developments from the past yearbefore moving on to some exciting new updatescoming to the App Store Server APIand App Store Server Notifications Version 2.

Let's get started.

Last year was big.

We brought you an entirely new suite of endpointswith the App Store Server APIand App Store Server Notifications V2,including full sandbox testing supportfor all these new features.

We shared how you can use the Get Transaction History endpointto get the full history of a user's in-app purchases,or the Get All Subscription Statuses endpointto stay up to date with the current stateof a user's subscriptions.

Both of these endpoints conveniently keyoff of a user's originalTransactionId,so you can access this trove of databy storing just this one simple value.

We also covered how version 2of App Store Server Notificationscan simplify event processing on your serverand complement the App Store Server API.

With V2 notifications,the App Store server calls your server directly,providing in-app purchase updates as they happen.

The streamlined notification type and subtypemake it easy to understand what's happening.

You can use these to track changesrelated to in-app subscriptions and other events.

With all of these data sources,we wanted to make that data as easy as possible to parse.

Receipts are now a thing of the past,as these new services provide in-app datain signed JSON format, so you can easily parse itand trust that it came from the App Store server.

Last year was a big year for the App Store server.

It may have been big for you as wellif you worked to update your server codeto leverage all these new features.

Rest assured that effort will continue to pay offas we bring powerful new enhancements and featuresto App Store Server API and App Store Server Notifications V2.

That's our year in review,but if you'd like more of a refresherafter hearing this year's updates,be sure to check out the WWDC21 sessions titled"Manage in-app purchases on your server,""Meet StoreKit 2,"and "Support customers and handle refunds."Now let's move on to brand-new updatescoming to the App Store server for WWDC22.

First I'll share some updates to transactionand renewal info fields.

Next I'll tell you about new enhancementsto the App Store Server API.

And finally, I'll share exciting new featurescoming to App Store Server Notifications V2.

Now let's dive in with the first of our new topics:new fields found in transaction and renewal info.

Earlier, you heard from Dani about a couple new fieldscoming to the transaction and renewal infoof in-app purchases.

These fields, environment and recentSubscriptionStartDate,are also coming to the transactionand renewal info payloadsyou receive from the App Store Server APIand in V2 App Store Server Notifications.

Let's take a fresh look at the data you can expect to receivefrom the App Store server with these new fields included.

First is the transaction info payload,which we can see here after decoding.

Down at the bottom, you can see our new field: environment.

You can use it to tell, at a glance,whether the transaction took placein the production or sandbox environment.

Next is the renewal info payload,also seen here after decoding.

As you can see, the environment field is also available herefor your reference.

Additionally, recentSubscriptionStartDatewill now appear in every renewal info payload.

This is the start date of the user's firstsubscription purchase in their most recent string of renewals,ignoring any gaps of 60 days or fewer.

recentSubscriptionStartDate is an easy way to get an ideaof a customer's loyalty at a glance.

But if you'd like more detail,including the timing and length of any gaps in service,you can call the Get Transaction History endpointand examine the full historyof a user's subscription renewal purchases.

Or for even more detail,with App Store Server Notifications V2,the App Store server automatically sends updatesabout user subscriptions to your server.

These notifications give you maximum insightinto the timing of events like renewal preference changes,offer redemptions, billing failures, and more.

As you can see, recentSubscriptionStartDaterounds out a suite of optionsfor determining customer loyalty.

Use these tools to target offersand reward your most loyal customers.

Now let's move on to some convenient new enhancementsto the Get Transaction History endpoint.

With the Get Transaction History endpoint,you can fetch the full history of a user's purchasesin your app.

The endpoint response is paginatedso you can process this data in reasonable chunks.

Each response contains a revision token that you providein the next request in order to get the next page.

And the pages are sorted by modified date,meaning each subsequent page contains transactionsthat are more recently modified.

Let's take a look at how this works.

You call the Get Transaction History endpoint,and provide an originalTransactionId.

The App Store server will return up to 20 signed transactionsfor that user.

It will also return an updated revision valuethat you will provide in your next page request for this user.

You'll know there's more data availablewhen the hasMore field in the response is true.

Let's say in this casethat there's another page of data available.

You make another request to the endpoint,and you include that revision value from the first response.

You receive the next page of data,including an updated revision value.

hasMore is now false, so you know you're up to datewith the latest transaction data.

Except this time, you notice somethingabout the final transaction in the response;you've seen it before!It was one of the original 20 you receivedin response to your first request.

This means the transaction must have been modified,so it was put back at the top of the sort order.

Now, you can examine the data of that transactionand take note of what's changed.

In this instance, you notice the revocationDateand revocationReason fields are now populated,meaning the transaction was revoked.

You can take action by revoking any contentassociated with the purchase.

It's a good idea to store the revision valuefrom this final response alongsidethe originalTransactionId you used to identify the user.

The next time you call the endpoint for this user,you can provide that revision and knowthat you're getting back only fresh transaction datathat has been modified since your last request.

As you've seen, the Get Transaction History endpointprovides you a simple way to retrieve a comprehensive setof in-app purchase data.

But maybe sometimes it can be a bit too comprehensive.

Some users have lengthy purchase historiesdating back several years.

For these users, this endpoint could returnhundreds of purchases of a variety of types.

Even with pages, this can be a lot to handle.

That's why this year, we're enhancing this endpointwith a variety of new sort and filter options.

Now, you can tell us exactly the data you want from the start,saving processing time on your serverand reducing the number of network callsneeded to retrieve all available pages.

You can sort by descending modified dateif you're interested in seeing the most recentlymodified purchases on the first page of results.

You can also filter by several useful fieldssuch as product type, product ID,Family sharing status, and more.

To apply these new sort and filter options,just append them as query parameters to your requestto the Get Transaction History endpoint.

Let's take a closer look at how that works.

Here you can see all the new parameter options.

These may look familiar, since most are taken directlyfrom the transaction info payload.

You can mix and match these parametersto get very specific results.

For example, maybe we want to fetchonly the nonconsumable purchases a user has madesince the beginning of this year.

We also want to exclude any revoked purchases.

We will build our custom requestby setting the productType to NON_CONSUMABLEand specifying the startDate as the beginning of this yearrepresented in milliseconds.

Finally, we'll set excludeRevoked to true.

And that's our request!Since we did not specify a sort order,the response will default to sortingby ascending modified date.

Now even with a request as specific as this,there could be multiple pages of purchases to retrieve.

For follow-up requests, we should make sureto include the exact same query parameters,in addition to the revision from the previous response.

For even more flexibility,three of the filter fields support multiple values,so you can filter to only those purchasesthat match at least one of the provided values.

These fields are productType, productId,and subscriptionGroupIdentifier.

To provide multiple values for these parameters,simply define them multiple times.

Next let's move on to App Store Server Notification updates.

With App Store Server Notifications V2,you can take your server to the next level.

V2 notifications give detailed insightsabout in-app purchase eventsthat you can't get anywhere else.

These are especially useful for tracking the lifecycleof autorenewable subscriptions offered in your app.

You can use these insights to retain customers,win back those that have churned,resolve customer support requests, and more.

With all of these benefits, you might wonder how to get started.

As with any new feature,the sandbox testing environment is the best place to start.

That's why last year,we added the ability to set a separate server URLin App Store Connect for receivingApp Store Server Notifications in sandbox.

After registering your server URL,you'll want to confirm your serveris receiving notifications from the App Store server.

You might set up a sandbox accountjust to trigger a notification through a user action.

For example, let's say you perform a first time buyof a subscription using that sandbox account.

You should receive a V2 notification of type SUBSCRIBEDand subtype INITIAL_BUY.

But what if that notification doesn't come?You might wonder if there was an issue with your serveror the steps you took to trigger a notification.

This situation can generate a lot of uncertaintyright as you're getting started.

We want to simplify this experience and give you a wayto easily verify that App Store Server Notificationscan reach your server.

That's why this year, we're introducing the newRequest a Test Notification endpoint.

By calling this simple endpoint,you can ask us to send a V2 Notification of type TESTto the server URL registered for your app in App Store Connect.

The new TEST notification type is used exclusivelyfor this endpoint.

You can call the endpoint in sandbox or productionto test your saved URL for either environment.

Use this new endpoint to quickly test new server URLsand configurations.

Let's see how this simplifies first-time setup.

Now, if you're just looking to trigger your first notification,there's no need to set up a sandbox accountor perform a purchase.

Just call the new endpointin whichever environment you want to testand you'll receive an HTTP 200 responseconfirming your request.

The response will contain a new field,testNotificationToken, which identifies the test notificationyour server will receive.

We will come back to this field later.

Shortly afterward, your server should receive a V2 notificationof type TEST at the URL saved in App Store Connect.

Now let's see how to call this endpoint.

Just send a simple POST request to this new pathon the App Store server.

You'll receive an HTTP 200 responseand know that your request has been submitted.

The response will contain that new field I mentioned,testNotificationToken.

Take note of this for later.

Soon you'll receive a signed TEST Notification.

Here's what that notification will look likeonce it's decoded.

You'll notice it contains all the usual top-level fieldsof a V2 notification,including the new notificationType, TEST.

The contents of the data object are a bit shorterthan a normal notification.

Since this is just a test,there are no transaction-related data to include,so we omit transaction-specific fields,most notably the signedTransactionInfo.

When calling the new Request a Test Notification endpoint,keep in mind that App Store Server Notificationsare sent asynchronously.

Your successful call to the endpointwill return an HTTP 200 but the actual test notificationwill arrive separately, a short while later.

Given that this endpoint is all abouttesting your server configuration,you might be wondering what to do when that test fails.

In other words, what if the test notification doesn't arrive?To further enhance your testing capabilities,we're releasing the Get Test Notification Status endpoint,which you will use in conjunctionwith the Request a Test Notification endpoint.

With this new endpoint, you can check on the statusof a previously requested TEST notification.

The endpoint response will tell you if the App Store serverwas able to reach your serverand successfully send the TEST notification.

If the send failed, it will give you an idea of why,so you can better troubleshoot your server configuration.

Let's check out how you'll use this endpoint.

Send a GET request to this path on the App Store server.

In the path, include the testNotificationTokenyou received from the Request a Test Notification endpoint.

This will tell us which test notificationyou want to check the status of.

Now for the response.

The signedPayload field contains the TEST notification payloadthat the App Store server attempted to sendto your server.

And the firstSendAttemptResult field indicates the resultof that send attempt.

Here, SUCCESS indicates that the send was successful,meaning the App Store server received an HTTP 200 responsefrom your server.

If the send was unsuccessful,you'll instead see one of several different error values.

These values indicate the error the App Store server experiencedtrying to reach your server with the test notification.

With this information, you can troubleshoot your server issue,request new test notifications as needed,and get your server running reliably.

Collectively, these test notification endpointsare simple to use and can save you a lot of troublewhen setting up or reconfiguring your serverto receive V2 App Store Server Notifications.

Now with the help of these endpoints,you can set up your server and confirm it's running smoothly.

But servers aren't perfect and outages happen.

How do you recover when your server goes down,leading you to miss App Store Server Notifications?The current solution to this is a retry system.

When the App Store server fails to reach your server,it initiates a retry process.

It will retry sending the same notification up to five times,with a longer wait between each attempt.

These retries take place only in the production environment.

Retries help you eventually recover from an outage,but they're not perfect for every situation.

For example, some outages can be extensive.

If your server is down long enoughto miss the final retry attempt from the App Store server,that notification is lost.

Or more commonly,your server could experience a very brief issue,during which it misses only a handful of notifications.

But missing even a single notificationmeans some of your customer records are out of datefor at least an hour.

Yet you don't know which ones!Clearly, server outages are stressful,and recovering from them can be a complex task.

That's why we want to make it as easy as possibleto recover missed App Store Server Notifications,so you can get your server back on track as soon as possible.

That's why this year, we are introducing the newGet Notification History endpoint.

With this endpoint,you can fetch the history of V2 App Store Server Notificationsgenerated for your app.

Whether your server successfully received a notification or not,that notification will appear in the response of this endpoint.

When calling this endpoint,you'll specify a date range of notifications to fetch.

With WWDC, we have started recording this data,and we will build up to the cap of the latest six monthsof rolling history being available.

You can optionally filter your request by type and subtype,or fetch just a single user's notificationsby providing an originalTransactionId.

And the existing retry system is still available,so you can use it in tandem with this new endpoint.

Let's take a look at how you'll call this endpoint.

You'll send a POST request to this new pathon the App Store server.

In the request body, you'll include a startDate and endDate.

The response will contain only notificationswe first attempted to send in this window.

Keep in mind that the earliest notifications availablewill be those sent six months before the date of your request.

Optionally, you can specify a notificationTypeand notificationSubtype.

If you do, the history will be filtered to only notificationsthat match both of these values.

Keep in mind that some notifications have no subtype.

Alternatively, you can providean originalTransactionId of a user,to fetch the notification history of only that user.

Finally, you should provide a paginationTokenas a query parameter for every follow-up requestin order to get the next page.

Make sure you use the same request bodyfor follow-up requests,changing only this paginationToken.

Now let's take a look at the response.

The notificationHistory array contains up to 20 notifications,with the oldest notifications first.

Each entry in this array represents a notificationand inside you'll find the signedPayload,which you can decode as usual to view the transaction data.

The data within is identical to the payloadthe App Store server sent in the original notification.

You'll see that we've also brought the newfirstSendAttemptResult field to this endpoint response.

You can use this field to look for sequences of timeoutsand other errors to better understand why your servermissed notifications in the past.

The response also contains a paginationTokenif there are more pages to retrieve.

You should provide this in your next requestin order to get the next page of notifications.

You'll know there are more pages to retrieveas long as the hasMore field is true.

And that's everything you need to knowabout this useful new endpoint.

That concludes our App Store server updates for today.

Every server feature announced today is available nowin both sandbox and production.

We hope you'll take advantage of these new featuresto make your server the best it can be.

For more great content on using a server with in-app purchase,including how to use the latest featureswhile supporting legacy clients,I encourage you to check out another session at WWDC22,"Explore in-app purchase integration and migration."Both: Thanks for joining us at WWDC22!♪

## Code Samples


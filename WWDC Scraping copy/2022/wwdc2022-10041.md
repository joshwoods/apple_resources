# Wwdc2022 10041

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

What’s new in Wallet and Apple PayDiscover the latest updates to Wallet & Apple Pay. We'll show you how to support Orders in Wallet for your apps and websites and securely validate someone's age and identity with the Identity Verification API. We'll also explore PassKit support for SwiftUI, and discuss how you how you can improve your Apple Pay experience with Automatic Payments.ResourcesApple PayApple Pay Merchant Token Management APIApple Pay on the WebApple Pay on the Web Interactive DemoApplePayPaymentRequestExample Order PackagesHuman Interface Guidelines: WalletPassKit (Apple Pay and Wallet)Requesting identity data from a Wallet passVerifying Wallet identity requestsWallet OrdersHD VideoSD VideoRelated VideosWWDC23What’s new in Wallet and Apple Pay

Discover the latest updates to Wallet & Apple Pay. We'll show you how to support Orders in Wallet for your apps and websites and securely validate someone's age and identity with the Identity Verification API. We'll also explore PassKit support for SwiftUI, and discuss how you how you can improve your Apple Pay experience with Automatic Payments.

Apple Pay

Apple Pay Merchant Token Management API

Apple Pay on the Web

Apple Pay on the Web Interactive Demo

ApplePayPaymentRequest

Example Order Packages

Human Interface Guidelines: Wallet

PassKit (Apple Pay and Wallet)

Requesting identity data from a Wallet pass

Verifying Wallet identity requests

Wallet Orders

HD VideoSD Video

HD Video

SD Video

What’s new in Wallet and Apple Pay

Search this video…♪ Mellow instrumental hip-hop music ♪♪Lais Minchillo: Hi, my name is Lais.David Silver: And I'm David. And we will be presentingthis year's new features in Wallet and Apple Pay.We launched Apple Pay in 2014,setting a new benchmark for making fast, secure,and private payments in store, online and in-app.Since then, we've expanded Apple Pay across the globe.Apple Pay is now available in 72 countries and territoriesand handles more than a million transactions every day.Today we're introducing exciting new features and APIsinto Wallet and Apple Pay.Lais will tell you more.Lais: Thank you, David!Let's take a look at the main agenda for today.First, we'll talk about some quick updates.We are adding support for payments to multiple merchantsin a single transaction.We are also greatly improving support for automatic payments,including subscriptions,With order tracking, you can enhancethe postpurchase experience for your customers.And finally, David will talk about identity verificationwith IDs in Wallet.We have a few exciting updates to share.Tap to Pay on iPhone was announced earlier this yearand launched in iOS 15.4 in the US.Tap to Pay on iPhone provides a secure, private,and easy way to accept contactless payments.You can easily integrate this into your appto seamlessly and securely accept contactless payments.This includes Apple Pay,contactless credit and debit cards,and other digital wallets.The transaction is completedthrough a simple tap to the iPhone,removing the need for additional hardwareor payment terminals.Meanwhile, in macOS 13,we redesigned the Apple Pay experience.The iOS payment sheet redesign last yearwas a great successand this year we're bringing a similar experience to macOS.We used SwiftUI to implement this,which helped us bring new features to macOSat the same time as iOS.All of the Apple Pay features we are introducing todayare also supported on Mac.We're introducing new SwiftUI APIs.Integrating Add to Apple Wallet or Apple Pay buttonsin your SwiftUI app will be much easier.These new APIs will significantly reducethe amount of code you need to write.Let's take a look at how you can add a buttonto prompt the user to add an airline pass.First, create the pass.You should handle the case where it wasn't successfully loaded.This could happen if the pass data is malformedor if it was not properly signed, for example.Next, call AddPassToWalletButton with an array of passes.In this example, we have an array with only one element,but you can have multiple passes on the same button.The result is passed in as a Bool, and you can save,log, or trigger other actions in your appbased on whether the user has added a pass or not.In this example, I'm saving that to a state var.And that's it!You can also customize the button's size and stylewithin a set of minimum values.This is the default size: width 250 and height 50.You could also make it wider......or taller.This wraps up how you can addan Add to Apple Wallet button in SwiftUI.Now, let's see how you can add a Pay with Apple Pay button.First, create a payment requestusing the PKPaymentRequest class,setting your usual configuration on it.Then, create an authorizationChange method.Now that we have these two pieces ready,let's add code to show the button.Add a call to PayWithApplePayButton,passing in the label, the paymentRequest object,and the authorizationChange method.To handle cases where Apple Pay isn't supportedby the current device, you can pass in a fallback view.Just like the Add Pass button,you can also customize its size and style.In total, there are 17 different labels,so you are able to customize the pay buttonto align with your use case.These are available on iOS, iPadOS, macOS, and watchOS.Now, let's take a look at multimerchant payments.In iOS 16, we're introducing the ability to requestmultiple payment tokens for different merchantsin the same transaction.This is useful for things like online marketplaces,travel bookings, and ticketing services.Let's take a closer look at an example.Imagine Allison is planning a trip.She goes to a travel agency's websiteand they conveniently offer herall of the things she needs to book --flight tickets, a hotel stay, and a car rental.Allison just needs to pay a total of $500 dollars.Allison provides the travel agencyher full credit card information.Now, you might imagine that the travel agencywill charge Allison's credit card $500 dollars,and then pay the other companies involved.But what typically happens is the travel agencysimply passes along the credit card informationto each company to make their individual charges.This works, but it's not greatfor Allison's privacy and securityto have her credit card information shared around.Now, with the new multimerchant payment API,it's possible to request a payment tokenfor each merchant involved in a transaction.Using these payment tokens,the multiple companies involved can each charge Allisonfor the relevant amount she authorized.Allison can now book and pay for her tripwhile taking advantage of the privacy and security benefitsthat Apple Pay offers.The payment sheet has been updated to show customersa breakdown of the submerchants involved in a transaction.Customers can tap on the total fieldto navigate to the payment summary.Here, the customer can see a breakdownof all the merchants involved in the transaction,along with the amount authorized for each one.Now, let's look at how you can addmultimerchant payments to your app.First, create a payment requestusing the PKPaymentRequest class,setting your usual configuration on it.Then add summary items for your payment, including the total.Next, create a payment token contextfor each additional merchant involved in the transaction,using the new PKPaymentTokenContext class.Provide details for each merchant,as well as the amount to authorize for each.Finally, set the payment token contexts on the payment request.Keep in mind that the sum of the amountsfor all of your payment token contextsmust be less than or equal to the total amountof the payment request itself.Also, you should always use the same external identifierfor the same merchant any time you request a payment tokenfor that merchant in your app.For adopting multi-merchant paymentswith Apple Pay on the web,check out the Apple Pay JS API documentation.Now, let's take a look at our improvementsto automatic payments.In iOS 16, we're introducing the ability for people to viewand manage automatic payments they've set up with merchants,right from the Wallet app.In this release,we're supporting two types of automatic payments:recurring payments, which includes things likesubscriptions, installments, or recurring billing;and automatic reload payments,such as store card balance top-ups.We're introducing new APIs to allow you to requestto set up an automatic payment when you make a payment request.We're also introducing Apple Pay merchant tokens,a new kind of payment token tied to a customer's Apple ID,which can help you more reliably charge your customerson an ongoing basis.Let's take a closer look at Apple Pay merchant tokensto see how they can be useful.Imagine Julie is paying for a book club membershipusing Apple Pay on her iPhone.The book club makes a payment request,and when Julie authorizes the payment,the book club receives a payment token,and every month they can use that to charge Julieher membership fee.This payment token is linked to the device Julie usedto authorize the payment.But what happens if Julie gets a new iPhone?With the new automatic payments feature,the book club will instead receivean Apple Pay merchant token,if Julie's payment network supports it.This payment token is tied to Julie's Apple ID,rather than to her iPhone,which provides better assurances for ongoing authorizations.This means that if Julie upgrades her iPhone,or resets her current phone,the book club can continue to reliably charge Julieher monthly membership fee.If you accept Apple Pay for these types of payments,it's a great idea to adopt automatic payments to ensureyou can continue reliably charging your customers,as well as avoid any interruption to their services.The first type of automatic payment we're supportingin this release is recurring payments.Recurring payments have a fixed or variable amountthat is charged on a regular schedule,such as weekly, monthly, or annually.These payments can end on a certain dateor they can be ongoing until canceled.A trial or introductory period is also supported.Subscriptions, installment plans,and regular billing are perfect usesfor this type of payment.Let's take a look at how you can set up a recurring paymentin your app using automatic payments.Start by specifying the amount and durationof the recurring payment, using thePKRecurringPaymentSummaryItem class.For recurring payments,you can specify both a regular billing periodas well as an introductory or trial period.You can use the startDate and endDate propertiesto indicate when the trial period endsand the regular billing period starts.Next, create a recurringPaymentRequestusing the new PKRecurringPaymentRequest class.Provide a description of the payment,the regular billing period,as well as a managementURL to a web pagewhere the customer can update or delete the payment methodfor the recurring payment.You can also optionally provide a trial billing periodas well as billingAgreement textto help explain the terms of the payment to the customer.Finally, you can optionally provide a tokenNotificationURLwhere your server can receive life cycle notificationsabout the Apple Pay merchant token for the payment,if one was issued.For example, you can receive notificationsif the card issuer or the user deletes the token.For more information about merchant tokenlife cycle notifications,see the Apple Pay Merchant Token Management API documentation.Finally, set the recurringPaymentRequeston the paymentRequest object.A quick note on summary items, your recurring paymentwill not be added to the payment request's summary itemsautomatically.So be sure to add items for it to the summary items array.The total for the payment requestshould be the first amountthat the customer will be charged.So in this example, the total is set to displaythe trial period amount,as that's the first amount the customer will be charged.The payment sheet will show detailsof your recurring payment to customers,and they can tap on the Billing Details sectionto read further.Now, let's take a look at the second type of automatic paymentwe're supporting in this release:automatic reload payments.With this type of payment,a balance is automatically topped upwith a fixed amount whenever the balance drops belowa certain threshold amount.Automatic reload payments are perfect for things likestore card top-ups and prepaid balances.To request to set up an automatic reload payment,start by specifying the reload and threshold amounts,using the new PKAutomatic ReloadPaymentSummaryItem class.Next, create an automaticReloadPaymentRequestusing the new PKAutomatic ReloadPaymentRequest class,passing in a description of the payment, the billing,and a management URL,just like for recurring payments.You can also optionally provide billing agreement textand a token notification URL.Finally, set the automatic reload payment requeston the payment request object.Again, be sure to include your automatic reload paymentin the summary itemsand set the total of the paymentRequest appropriately.For adopting automatic payments with Apple Pay on the web,check out the Apple Pay JS API documentation.Here's how the automatic reload payment appearsin the payment sheet for your customers.Finally, here's a few things to rememberto help give your customers the best possible experiencewhen you adopt automatic payments in your app.Remember to include summary itemsfor your automatic payment as these are not added for you.The total amount of your payment request should bethe first amount the customer will be charged.You should keep the billing agreement text short.The payment sheet will only show the first 500 characters.The billing agreement text is not intended to replaceyour normal billing and legal agreements.It's up to you to be compliantwith your local recurring billing laws.If you have a legal agreement to show the customer,that might mean displaying it to the customerbefore you present the payment sheet.You can only request one type of automatic paymentin a single transaction.Also, automatic payments cannot be usedwith multi-merchant payments.Finally, if you want to receive life cycle notificationsfor the Apple Pay merchant token issued for the payment,be sure to provide a token notification URLand adopt the Apple Pay Merchant Token Management APIon your server.We think you'll love these new APIsand the benefits of Apple Pay merchant tokens.Here are just a few of our partnersthat will also be adopting support for automatic payments.Apple Pay merchant tokens will be supported byAmerican Express, Discover, Mastercard, and Visa,with support for other payment networks in the future.We are excited to introduce Order Trackingto enhance the postpurchase experience.New in iOS 16, order tracking allows users to track ordersplaced with participating merchants.Wallet now provides an intuitive overviewof active orders, recently completed orders,and past orders.I currently have a single active order for some bakery goods.My order is still in processing; I'll get back to that later.For now, I want to buy some toys and accessories for my catfrom Pet Avenue.I choose to check out with Apple Pay.Shortly after I authorize the payment,I receive a notification to track my order in Wallet.Interacting with that notificationtakes me to the details of my orderwhere I can check the current status.I can see the order status,including shipping and tracking information,and the list of line items I have ordered.Further below, I have multiple options to contact Pet Avenue,check the payment information, and go back to Pet Avenue's app.Now, imagine Pet Avenue is really fastin processing incoming orders and they just shipped my items.As soon as Pet Avenue shipped my order,they have updated the available information.I can see the status changed to "On the Way,"with an estimated delivery date of June 10th.They also included a custom messageand tracking information for the shipment.Oh, remember my baking goods?I just got a notification that they are ready for pickup.Let's check it out.I have ordered my bakery goods for pick up.They are ready for pick up, that's great!Bake My Breath Away has provided my pickup window,pickup instructions,and a barcode to present upon arrival.We've seen that order tracking works seamlessly with Apple Pay.Let's have a look at how you can integrate order trackinginto your customer experience.To get started with order tracking,first, you must create an Order Type IDin your developer account.An Order Type ID identifies your organization as an entitythat provides order information.You can register multiple Order Type IDs --for example, to provide order informationon behalf of multiple merchants.Also create an Order Type ID Certificate.You will use the certificate to build order packagesand update orders.Orders are distributed as order packages.An order package includes all the metadata and informationfor an order.It can represent a wide range of scenarios,including shipping, pickup, and multifulfillment orders.An order package also includes images,like your logo and line item images.You can also add localizationsto support your diverse range of customers.Every order package must be cryptographically signedto verify its origin.Once everything is in place,order packages are compressed for distribution.Check out the sample order packagesattached to this session.And for more information on order packages,see the developer documentation.Adding an order to Wallet works seamlessly with Apple Pay.When your customer authorized a payment,your app or web page receives payment information,then sends it to your server for processing.If processing the payment information succeeds,your server creates an order and some metadata.Your server then returns details about that orderto your app or web page to include in the result.The order details enable the device to asynchronously requestthe order from your server.Your server then returns the order package to the device.When your server creates an order,assign an Order ID that is uniquewithin the namespace of your Order Type ID.Your server must also generate a secure authentication token.This is a shared secret that is part of the order details.The device will use the token to authenticate itselfwhen it requests the order.Let's take a look at an examplefor returning a payment authorization result.When your customer authorized a payment,your app sends the payment information to your serverand asks it to create an order.Check whether the server result indicates successand handle any error returned by your server.If the server result does indicate success,complete the payment with an appropriateauthorization result.To return a payment authorization resultwith order details,first, extract them from the server result.Then create a PKPaymentOrderDetails objectwith the Order Ttype ID, Order ID,the URL to your server, and the authenticationToken.Assign the PKPaymentOrderDetails objectto the new orderDetails property on PKPaymentAuthorizationResult.That's it!You can complete a payment with order details on the web too.As before, extract the order details from the server result.Then include the order detailsin the data you complete the payment with.To be able to update an order,create an order package that indicates supportfor automatic updates.When the order is added,the device will register for updates to it.Your server must store information about registrations.Later on, when your server updates the order,use the registration information to notify devicesthat registered for updates to it.When the device receives the push notification,it will again request the order from your server.Your server then returns the updated order packageto the device.Only your customers and youshould know what they have ordered.We designed order tracking with privacy in mind.Order information is exchanged directlybetween devices and your server.When orders are synchronized via iCloud,they are end-to-end encrypted.Follow these practices to providethe best customer experience possible.Associate your app with orders that you provide.If your app delivers notifications and is installed,you can disable order tracking notifications.This helps to prevent duplicate notifications.Use the knowledge you have about your customer preferencesto provide relevant localizations only.Be mindful of the order package size.Try to keep the size smallto reduce expensive networking cost.When you update an order,promptly notify devices that registered for updates to it.Orders in Wallet should match the actual state of the order.Make sure to also check out the HIG for order tracking.Platforms can make your integration of order trackingmuch simpler.We are happy to announce Shopify, Narvar, and Routewill support order tracking by fall.Look out for more platforms supporting order trackingin the coming months.Order tracking is a great way to enhancethe postpurchase experience for your customers.With automatic updates,your customers will always be up to dateabout the status of their orders.We believe your customers will love this experienceand we look forward to ordering with you soon!Now, I'll pass over to David.David: Thanks, Lais!I'm super excited to talk about the new functionalitywe've added to IDs in Wallet in iOS 16.We launched IDs in Wallet earlier this year in iOS 15.4.It allows users in supported US statesto add their driver's license or State ID to Wallet.IDs in Wallet are issued by the same issuing authoritiesas users' physical IDs.in the US, that's their State's Department of Motor Vehiclesor equivalent organization.In iOS 16, we've added a new API that allows appsand App Clips to request information from IDs in Walletin order to verify a user's age or identity.Your app will request the information,the user will review and approve the request,Then your app will send the response to your serverfor decryption and verification.You can request a number of data elementsfrom the user's ID.These include their name, their address,their date of birth, their photo --known as the portrait --the issuing authority that issued their ID,the number and expiration date of their physical ID,and the driving privileges granted by their ID,if there are any.A very common use case for IDs is to verify someone's age.With a physical ID, that means looking at their date of birth.But the date of birth reveals far more informationthan is necessary just to verify age.If you're checking my age, you don't actually need to knowthe exact day or year I was born,or even how old I am.You just need to know if I'm old enough.With IDs in Wallet, you can ask that question directly.Your app can request a Boolean data elementindicating whether the user is above a certain age,providing a more privacy-preserving wayto do age verification than checking the full date of birth.When your app invokes the API, a sheet will show the userwhat information you're requesting.It will also show whether you intendto store that information,and for how long you intend to store it.This lets the user make an informed decisionabout whether to share the information with your app.No information is shared until they givetheir explicit approval using Face ID or Touch ID.The response you receive contains just the elementsyou requested.Other identity verification mechanisms,such as scanning a physical ID card,share everything that's on the ID.By limiting the sharing to just what you need,IDs in Wallet is more privacy-preserving for the userand reduces the amount of sensitive informationyou need to keep secure on your server.The response is signed by the ID's issuing authority,making it straightforward to verifythat the information in the response is authentic.Note that the issuing authority creates the IDbut is not involved at the time you invoke the API.They do not learn when users share their informationor to whom they share it with.To use the API, you need to request an entitlementthrough your developer account.You'll then need to set up a merchant IDand encryption certificate.This process is very similar to setting up in-app paymentwith Apple Pay.We'll talk more about how to use the ID and certificate in a little bit.For now, let's talk about the verification flow.At a high level, it consists of four steps.First, your app will invoke the API in the PassKit frameworkand specify the information you're requesting.The system will then display a sheetprompting the user to approve the request.Once they do, your app will receivean encrypted response.Your app will then pass that response to your serverfor decryption and verification.First, let's talk about how to use the API in PassKit.If your app uses SwiftUI, you should use theVerifyIdentityWithWalletButton SwiftUI view.This displays a button that triggersthe identity verification flow when pressed.Just like the Pay with Apple Pay and Add Pass to Wallet buttons,the Verify Identity with Wallet button provides a familiar,consistent experience across apps using the API.You can choose between four different labelsto display a button that fits your use case.It automatically switches between singleand multiline versions depending on the space available to it.When creating the button,you need to specify a PKIdentityRequest object,which describes the information you want to requestand how it should be returned.Let's take a look at how to create it.You begin by creating aPKIdentityDrivers LicenseDescriptor,which describes the data elementsthat you're looking for.Use the addElements method to specify elementsyou want to request,along with whether you intend to store them.You can invoke the addElements method multiple timesto specify different sets of elementswith different intents to store.In this example, I'm calling it twice.First, I add an age(atLeast: element,which is not going to be stored.Then, I call the addElements method again to requestthe user's givenName, familyName, and portrait,all of which may be stored for up to 30 days.The descriptor then goes into a PKIdentityRequest.The next step is to specify a merchantIdentifier to use.The merchantIdentifier indicatesthe encryption certificate to which the API responsewill be encrypted.You'll configure both the merchantIdentifierand its encryption certificate through your developer account.Finally, you'll need to specify a nonce,which will be tied to the response you receivefrom the API.Its an important security featureused to prevent replays of a responseand to bind it to a specific user session.Exactly how you manage the nonce is up to you,based on your own security requirements.Often, it comes from your server, because later on,your server will be responsible for enforcingthat the nonce is valid.With all of those properties set,you have your PKIdentityRequest.Now, let's get back to the button.If identity verification is available,the button will be displayed in your app,and tapping it will start the identity verification flowwith your request.If identity verification is not available,a fallback view you specify will be displayed instead.For example, this will happen if there isn't an ID in Walleton this iPhone.You can use the fallback viewto offer other ways to verify identity.Let's assume identity verification is available,and the user taps the button.The system will then show a sheet with your request,including the elements you requestedand your intent to store them.The user can approve the request with Face ID or Touch ID,or close the sheet without approving.Your code will then receive a result objectcontaining the outcome of the request.If the request was approved, you'll receive a success result.This comes with a PKIdentityDocument objectcontaining the encrypted response,which your app will send to your serverfor decryption and verification.If the request was not successful,you'll receive a failure result.The most common cause of failureis that the request was not approved,in which case you'll receive a cancelled error.That was VerifyIdentityWithWalletButton,the SwiftUI version of the API.Use it to display a buttonthat launches the identity verification flowand requests information from IDs in Wallet.If you're not using SwiftUI in your app,you can also use the PKIdentityButtonand PKIdentityAuthorization Controller classesto accomplish the same thing.OK, so, now you've requested the information,the user's approved the request,and your app has sent the encrypted responseto your server.Now, let's talk about what your server needs to doto decrypt and verify that response.I'm only going to skim the surface on this topic,so please check the developer documentation for more details.The response format uses several international standards,so I strongly recommend familiarizing yourselfwith those as well.The response data you'll receiveis in a CBOR-encoded encryption envelope.CBOR is a data format defined in RFC 8949.It's similar to JSONbut uses binary data to encode objects.The encryption envelope contains metadataneeded for the decryption process,along with the encrypted data itself.The data is encrypted using HPKE,an encryption scheme defined in RFC 9180.Your server will decrypt this data using its private key.Once decrypted, you'll get an mdoc response object.The mdoc response is defined in ISO 18013 part five,the ISO standard for mobile Driver's Licenses and State IDs.The mdoc response object contains the data elementsthat you requested.It also includes a number of security featuresthat your server needs to validateto ensure that the response is authentic.Note that your server will perform the decryptionand validation itself.Neither Apple servers nor the issuing authority's serversare involved.Before we can talk about decryptionand response validation,we need to talk about the session transcript.This is a CBOR structure that binds a response payloadto a specific request from a specific app.Your server will need to build this structure and use itduring both decryption and validation.The session transcript contains the same nonce and merchant IDyou used earlier in your PKIdentityRequest,as well as the team ID of your developer teamand the SHA256 hash of your encryption certificate'spublic key.When building the session transcript,your server should check that the inputs you're usingare all valid.That means the nonce shouldn't have been used already,and should be tied to the current user.The other values should match what's expectedon your developer account.Now let's talk about decrypting the encrypted data.You'll need the session transcript you just created,along with the metadata from the encryption envelope.You'll also need your private key.This is the private keycorresponding to the certificate you setup earlierin your developer account.To protect the confidentiality of user information,you need to make sure your private key stays private.Store it securely on your serverand never include it in your app.If your private key is ever compromised,revoke the certificate in your developer account immediately.After decrypting the encrypted data,you'll receive an mdoc response objectcontaining two cryptographic signatures,plus the data elements you requested.You need to check both signatures in the mdoc responsebefore you can use its data elements.First, you need to check the issuer signature.This is a signature from the issuing authorityof the user's ID.By checking this signature,you're verifying that the data in the responsecame from the real issuing authorityand wasn't tampered with.You should check that not only is the signature valid,but also that it is signed by an issuer certificate you trust.Take a look at the documentation for more detailsabout the issuer certificates used by IDs in Wallet.Next, you need to verify the device signature.This is a signature created by a keyin the Secure Element of the user's iPhone.It proves that the response you receivedcame from the same iPhone that the issuing authorityoriginally issued the ID to.Here, you'll need to use your session transcript again,along with some information covered by the issuer signature.Finally, you're ready to use the data elementsthat you requested.You should never use these elementswithout first verifying the issuer and device signatures,because otherwise you don't know whether the data you receivedis authentic.And with all those steps completed, you're done!Your app has requested the information,and your server has decrypted and verified the response.You might be wondering how to test your implementationif you don't have an ID in Wallet.We've provided a few mechanisms to help you do that.First, you can test in the iOS Simulator,where the API will return a mock response.This response is similar to a real one,but lacks real signatures.Similarly, you can use a test profileto receive a mock response on a real iPhone,even If you don't have an ID in Wallet on that iPhone.See the documentation for more details about how to do this.Note that your server should never treateither of these mock responses like a real one.To help you with your server implementation,the documentation also includes an example response,along with everything you need to decrypt and validate it.And that's how you can perform identity verificationwith IDs in Wallet in iOS 16.We discussed how to use the API in your app,how to process the response on your server,and how to test your implementation.Lais: This year, we introduced many great new featuresto Wallet and Apple Pay.These include multi-merchant payments,improved support for automatic payments,order tracking, and identity verification.Please check out the developer documentationfor more information.David: Thank you for watching, and have a great WWDC!♪

♪ Mellow instrumental hip-hop music ♪♪Lais Minchillo: Hi, my name is Lais.David Silver: And I'm David. And we will be presentingthis year's new features in Wallet and Apple Pay.We launched Apple Pay in 2014,setting a new benchmark for making fast, secure,and private payments in store, online and in-app.Since then, we've expanded Apple Pay across the globe.Apple Pay is now available in 72 countries and territoriesand handles more than a million transactions every day.Today we're introducing exciting new features and APIsinto Wallet and Apple Pay.Lais will tell you more.Lais: Thank you, David!Let's take a look at the main agenda for today.First, we'll talk about some quick updates.We are adding support for payments to multiple merchantsin a single transaction.We are also greatly improving support for automatic payments,including subscriptions,With order tracking, you can enhancethe postpurchase experience for your customers.And finally, David will talk about identity verificationwith IDs in Wallet.We have a few exciting updates to share.Tap to Pay on iPhone was announced earlier this yearand launched in iOS 15.4 in the US.Tap to Pay on iPhone provides a secure, private,and easy way to accept contactless payments.You can easily integrate this into your appto seamlessly and securely accept contactless payments.This includes Apple Pay,contactless credit and debit cards,and other digital wallets.The transaction is completedthrough a simple tap to the iPhone,removing the need for additional hardwareor payment terminals.Meanwhile, in macOS 13,we redesigned the Apple Pay experience.The iOS payment sheet redesign last yearwas a great successand this year we're bringing a similar experience to macOS.We used SwiftUI to implement this,which helped us bring new features to macOSat the same time as iOS.All of the Apple Pay features we are introducing todayare also supported on Mac.We're introducing new SwiftUI APIs.Integrating Add to Apple Wallet or Apple Pay buttonsin your SwiftUI app will be much easier.These new APIs will significantly reducethe amount of code you need to write.Let's take a look at how you can add a buttonto prompt the user to add an airline pass.First, create the pass.You should handle the case where it wasn't successfully loaded.This could happen if the pass data is malformedor if it was not properly signed, for example.Next, call AddPassToWalletButton with an array of passes.In this example, we have an array with only one element,but you can have multiple passes on the same button.The result is passed in as a Bool, and you can save,log, or trigger other actions in your appbased on whether the user has added a pass or not.In this example, I'm saving that to a state var.And that's it!You can also customize the button's size and stylewithin a set of minimum values.This is the default size: width 250 and height 50.You could also make it wider...

...or taller.

This wraps up how you can addan Add to Apple Wallet button in SwiftUI.Now, let's see how you can add a Pay with Apple Pay button.First, create a payment requestusing the PKPaymentRequest class,setting your usual configuration on it.Then, create an authorizationChange method.Now that we have these two pieces ready,let's add code to show the button.Add a call to PayWithApplePayButton,passing in the label, the paymentRequest object,and the authorizationChange method.To handle cases where Apple Pay isn't supportedby the current device, you can pass in a fallback view.Just like the Add Pass button,you can also customize its size and style.In total, there are 17 different labels,so you are able to customize the pay buttonto align with your use case.These are available on iOS, iPadOS, macOS, and watchOS.Now, let's take a look at multimerchant payments.In iOS 16, we're introducing the ability to requestmultiple payment tokens for different merchantsin the same transaction.This is useful for things like online marketplaces,travel bookings, and ticketing services.Let's take a closer look at an example.Imagine Allison is planning a trip.She goes to a travel agency's websiteand they conveniently offer herall of the things she needs to book --flight tickets, a hotel stay, and a car rental.Allison just needs to pay a total of $500 dollars.Allison provides the travel agencyher full credit card information.Now, you might imagine that the travel agencywill charge Allison's credit card $500 dollars,and then pay the other companies involved.But what typically happens is the travel agencysimply passes along the credit card informationto each company to make their individual charges.This works, but it's not greatfor Allison's privacy and securityto have her credit card information shared around.Now, with the new multimerchant payment API,it's possible to request a payment tokenfor each merchant involved in a transaction.Using these payment tokens,the multiple companies involved can each charge Allisonfor the relevant amount she authorized.Allison can now book and pay for her tripwhile taking advantage of the privacy and security benefitsthat Apple Pay offers.The payment sheet has been updated to show customersa breakdown of the submerchants involved in a transaction.Customers can tap on the total fieldto navigate to the payment summary.Here, the customer can see a breakdownof all the merchants involved in the transaction,along with the amount authorized for each one.Now, let's look at how you can addmultimerchant payments to your app.First, create a payment requestusing the PKPaymentRequest class,setting your usual configuration on it.Then add summary items for your payment, including the total.Next, create a payment token contextfor each additional merchant involved in the transaction,using the new PKPaymentTokenContext class.Provide details for each merchant,as well as the amount to authorize for each.Finally, set the payment token contexts on the payment request.Keep in mind that the sum of the amountsfor all of your payment token contextsmust be less than or equal to the total amountof the payment request itself.Also, you should always use the same external identifierfor the same merchant any time you request a payment tokenfor that merchant in your app.For adopting multi-merchant paymentswith Apple Pay on the web,check out the Apple Pay JS API documentation.Now, let's take a look at our improvementsto automatic payments.In iOS 16, we're introducing the ability for people to viewand manage automatic payments they've set up with merchants,right from the Wallet app.In this release,we're supporting two types of automatic payments:recurring payments, which includes things likesubscriptions, installments, or recurring billing;and automatic reload payments,such as store card balance top-ups.We're introducing new APIs to allow you to requestto set up an automatic payment when you make a payment request.We're also introducing Apple Pay merchant tokens,a new kind of payment token tied to a customer's Apple ID,which can help you more reliably charge your customerson an ongoing basis.Let's take a closer look at Apple Pay merchant tokensto see how they can be useful.Imagine Julie is paying for a book club membershipusing Apple Pay on her iPhone.The book club makes a payment request,and when Julie authorizes the payment,the book club receives a payment token,and every month they can use that to charge Julieher membership fee.This payment token is linked to the device Julie usedto authorize the payment.But what happens if Julie gets a new iPhone?With the new automatic payments feature,the book club will instead receivean Apple Pay merchant token,if Julie's payment network supports it.This payment token is tied to Julie's Apple ID,rather than to her iPhone,which provides better assurances for ongoing authorizations.This means that if Julie upgrades her iPhone,or resets her current phone,the book club can continue to reliably charge Julieher monthly membership fee.If you accept Apple Pay for these types of payments,it's a great idea to adopt automatic payments to ensureyou can continue reliably charging your customers,as well as avoid any interruption to their services.The first type of automatic payment we're supportingin this release is recurring payments.Recurring payments have a fixed or variable amountthat is charged on a regular schedule,such as weekly, monthly, or annually.These payments can end on a certain dateor they can be ongoing until canceled.A trial or introductory period is also supported.Subscriptions, installment plans,and regular billing are perfect usesfor this type of payment.Let's take a look at how you can set up a recurring paymentin your app using automatic payments.Start by specifying the amount and durationof the recurring payment, using thePKRecurringPaymentSummaryItem class.For recurring payments,you can specify both a regular billing periodas well as an introductory or trial period.You can use the startDate and endDate propertiesto indicate when the trial period endsand the regular billing period starts.Next, create a recurringPaymentRequestusing the new PKRecurringPaymentRequest class.Provide a description of the payment,the regular billing period,as well as a managementURL to a web pagewhere the customer can update or delete the payment methodfor the recurring payment.You can also optionally provide a trial billing periodas well as billingAgreement textto help explain the terms of the payment to the customer.Finally, you can optionally provide a tokenNotificationURLwhere your server can receive life cycle notificationsabout the Apple Pay merchant token for the payment,if one was issued.For example, you can receive notificationsif the card issuer or the user deletes the token.For more information about merchant tokenlife cycle notifications,see the Apple Pay Merchant Token Management API documentation.Finally, set the recurringPaymentRequeston the paymentRequest object.A quick note on summary items, your recurring paymentwill not be added to the payment request's summary itemsautomatically.So be sure to add items for it to the summary items array.The total for the payment requestshould be the first amountthat the customer will be charged.So in this example, the total is set to displaythe trial period amount,as that's the first amount the customer will be charged.The payment sheet will show detailsof your recurring payment to customers,and they can tap on the Billing Details sectionto read further.Now, let's take a look at the second type of automatic paymentwe're supporting in this release:automatic reload payments.With this type of payment,a balance is automatically topped upwith a fixed amount whenever the balance drops belowa certain threshold amount.Automatic reload payments are perfect for things likestore card top-ups and prepaid balances.To request to set up an automatic reload payment,start by specifying the reload and threshold amounts,using the new PKAutomatic ReloadPaymentSummaryItem class.Next, create an automaticReloadPaymentRequestusing the new PKAutomatic ReloadPaymentRequest class,passing in a description of the payment, the billing,and a management URL,just like for recurring payments.You can also optionally provide billing agreement textand a token notification URL.Finally, set the automatic reload payment requeston the payment request object.Again, be sure to include your automatic reload paymentin the summary itemsand set the total of the paymentRequest appropriately.For adopting automatic payments with Apple Pay on the web,check out the Apple Pay JS API documentation.Here's how the automatic reload payment appearsin the payment sheet for your customers.Finally, here's a few things to rememberto help give your customers the best possible experiencewhen you adopt automatic payments in your app.Remember to include summary itemsfor your automatic payment as these are not added for you.The total amount of your payment request should bethe first amount the customer will be charged.You should keep the billing agreement text short.The payment sheet will only show the first 500 characters.The billing agreement text is not intended to replaceyour normal billing and legal agreements.It's up to you to be compliantwith your local recurring billing laws.If you have a legal agreement to show the customer,that might mean displaying it to the customerbefore you present the payment sheet.You can only request one type of automatic paymentin a single transaction.Also, automatic payments cannot be usedwith multi-merchant payments.Finally, if you want to receive life cycle notificationsfor the Apple Pay merchant token issued for the payment,be sure to provide a token notification URLand adopt the Apple Pay Merchant Token Management APIon your server.We think you'll love these new APIsand the benefits of Apple Pay merchant tokens.Here are just a few of our partnersthat will also be adopting support for automatic payments.Apple Pay merchant tokens will be supported byAmerican Express, Discover, Mastercard, and Visa,with support for other payment networks in the future.We are excited to introduce Order Trackingto enhance the postpurchase experience.New in iOS 16, order tracking allows users to track ordersplaced with participating merchants.Wallet now provides an intuitive overviewof active orders, recently completed orders,and past orders.I currently have a single active order for some bakery goods.My order is still in processing; I'll get back to that later.For now, I want to buy some toys and accessories for my catfrom Pet Avenue.I choose to check out with Apple Pay.Shortly after I authorize the payment,I receive a notification to track my order in Wallet.Interacting with that notificationtakes me to the details of my orderwhere I can check the current status.I can see the order status,including shipping and tracking information,and the list of line items I have ordered.Further below, I have multiple options to contact Pet Avenue,check the payment information, and go back to Pet Avenue's app.Now, imagine Pet Avenue is really fastin processing incoming orders and they just shipped my items.As soon as Pet Avenue shipped my order,they have updated the available information.I can see the status changed to "On the Way,"with an estimated delivery date of June 10th.They also included a custom messageand tracking information for the shipment.Oh, remember my baking goods?I just got a notification that they are ready for pickup.Let's check it out.I have ordered my bakery goods for pick up.They are ready for pick up, that's great!Bake My Breath Away has provided my pickup window,pickup instructions,and a barcode to present upon arrival.We've seen that order tracking works seamlessly with Apple Pay.Let's have a look at how you can integrate order trackinginto your customer experience.To get started with order tracking,first, you must create an Order Type IDin your developer account.An Order Type ID identifies your organization as an entitythat provides order information.You can register multiple Order Type IDs --for example, to provide order informationon behalf of multiple merchants.Also create an Order Type ID Certificate.You will use the certificate to build order packagesand update orders.Orders are distributed as order packages.An order package includes all the metadata and informationfor an order.It can represent a wide range of scenarios,including shipping, pickup, and multifulfillment orders.An order package also includes images,like your logo and line item images.You can also add localizationsto support your diverse range of customers.Every order package must be cryptographically signedto verify its origin.Once everything is in place,order packages are compressed for distribution.Check out the sample order packagesattached to this session.And for more information on order packages,see the developer documentation.Adding an order to Wallet works seamlessly with Apple Pay.When your customer authorized a payment,your app or web page receives payment information,then sends it to your server for processing.If processing the payment information succeeds,your server creates an order and some metadata.Your server then returns details about that orderto your app or web page to include in the result.The order details enable the device to asynchronously requestthe order from your server.Your server then returns the order package to the device.When your server creates an order,assign an Order ID that is uniquewithin the namespace of your Order Type ID.Your server must also generate a secure authentication token.This is a shared secret that is part of the order details.The device will use the token to authenticate itselfwhen it requests the order.Let's take a look at an examplefor returning a payment authorization result.When your customer authorized a payment,your app sends the payment information to your serverand asks it to create an order.Check whether the server result indicates successand handle any error returned by your server.If the server result does indicate success,complete the payment with an appropriateauthorization result.To return a payment authorization resultwith order details,first, extract them from the server result.Then create a PKPaymentOrderDetails objectwith the Order Ttype ID, Order ID,the URL to your server, and the authenticationToken.Assign the PKPaymentOrderDetails objectto the new orderDetails property on PKPaymentAuthorizationResult.That's it!You can complete a payment with order details on the web too.As before, extract the order details from the server result.Then include the order detailsin the data you complete the payment with.To be able to update an order,create an order package that indicates supportfor automatic updates.When the order is added,the device will register for updates to it.Your server must store information about registrations.Later on, when your server updates the order,use the registration information to notify devicesthat registered for updates to it.When the device receives the push notification,it will again request the order from your server.Your server then returns the updated order packageto the device.Only your customers and youshould know what they have ordered.We designed order tracking with privacy in mind.Order information is exchanged directlybetween devices and your server.When orders are synchronized via iCloud,they are end-to-end encrypted.Follow these practices to providethe best customer experience possible.Associate your app with orders that you provide.If your app delivers notifications and is installed,you can disable order tracking notifications.This helps to prevent duplicate notifications.Use the knowledge you have about your customer preferencesto provide relevant localizations only.Be mindful of the order package size.Try to keep the size smallto reduce expensive networking cost.When you update an order,promptly notify devices that registered for updates to it.Orders in Wallet should match the actual state of the order.Make sure to also check out the HIG for order tracking.Platforms can make your integration of order trackingmuch simpler.We are happy to announce Shopify, Narvar, and Routewill support order tracking by fall.Look out for more platforms supporting order trackingin the coming months.Order tracking is a great way to enhancethe postpurchase experience for your customers.With automatic updates,your customers will always be up to dateabout the status of their orders.We believe your customers will love this experienceand we look forward to ordering with you soon!Now, I'll pass over to David.David: Thanks, Lais!I'm super excited to talk about the new functionalitywe've added to IDs in Wallet in iOS 16.We launched IDs in Wallet earlier this year in iOS 15.4.It allows users in supported US statesto add their driver's license or State ID to Wallet.IDs in Wallet are issued by the same issuing authoritiesas users' physical IDs.in the US, that's their State's Department of Motor Vehiclesor equivalent organization.In iOS 16, we've added a new API that allows appsand App Clips to request information from IDs in Walletin order to verify a user's age or identity.Your app will request the information,the user will review and approve the request,Then your app will send the response to your serverfor decryption and verification.You can request a number of data elementsfrom the user's ID.These include their name, their address,their date of birth, their photo --known as the portrait --the issuing authority that issued their ID,the number and expiration date of their physical ID,and the driving privileges granted by their ID,if there are any.A very common use case for IDs is to verify someone's age.With a physical ID, that means looking at their date of birth.But the date of birth reveals far more informationthan is necessary just to verify age.If you're checking my age, you don't actually need to knowthe exact day or year I was born,or even how old I am.You just need to know if I'm old enough.With IDs in Wallet, you can ask that question directly.Your app can request a Boolean data elementindicating whether the user is above a certain age,providing a more privacy-preserving wayto do age verification than checking the full date of birth.When your app invokes the API, a sheet will show the userwhat information you're requesting.It will also show whether you intendto store that information,and for how long you intend to store it.This lets the user make an informed decisionabout whether to share the information with your app.No information is shared until they givetheir explicit approval using Face ID or Touch ID.The response you receive contains just the elementsyou requested.Other identity verification mechanisms,such as scanning a physical ID card,share everything that's on the ID.By limiting the sharing to just what you need,IDs in Wallet is more privacy-preserving for the userand reduces the amount of sensitive informationyou need to keep secure on your server.The response is signed by the ID's issuing authority,making it straightforward to verifythat the information in the response is authentic.Note that the issuing authority creates the IDbut is not involved at the time you invoke the API.They do not learn when users share their informationor to whom they share it with.To use the API, you need to request an entitlementthrough your developer account.You'll then need to set up a merchant IDand encryption certificate.This process is very similar to setting up in-app paymentwith Apple Pay.We'll talk more about how to use the ID and certificate in a little bit.For now, let's talk about the verification flow.At a high level, it consists of four steps.First, your app will invoke the API in the PassKit frameworkand specify the information you're requesting.The system will then display a sheetprompting the user to approve the request.Once they do, your app will receivean encrypted response.Your app will then pass that response to your serverfor decryption and verification.First, let's talk about how to use the API in PassKit.If your app uses SwiftUI, you should use theVerifyIdentityWithWalletButton SwiftUI view.This displays a button that triggersthe identity verification flow when pressed.Just like the Pay with Apple Pay and Add Pass to Wallet buttons,the Verify Identity with Wallet button provides a familiar,consistent experience across apps using the API.You can choose between four different labelsto display a button that fits your use case.It automatically switches between singleand multiline versions depending on the space available to it.When creating the button,you need to specify a PKIdentityRequest object,which describes the information you want to requestand how it should be returned.Let's take a look at how to create it.You begin by creating aPKIdentityDrivers LicenseDescriptor,which describes the data elementsthat you're looking for.Use the addElements method to specify elementsyou want to request,along with whether you intend to store them.You can invoke the addElements method multiple timesto specify different sets of elementswith different intents to store.In this example, I'm calling it twice.First, I add an age(atLeast: element,which is not going to be stored.Then, I call the addElements method again to requestthe user's givenName, familyName, and portrait,all of which may be stored for up to 30 days.The descriptor then goes into a PKIdentityRequest.The next step is to specify a merchantIdentifier to use.The merchantIdentifier indicatesthe encryption certificate to which the API responsewill be encrypted.You'll configure both the merchantIdentifierand its encryption certificate through your developer account.Finally, you'll need to specify a nonce,which will be tied to the response you receivefrom the API.Its an important security featureused to prevent replays of a responseand to bind it to a specific user session.Exactly how you manage the nonce is up to you,based on your own security requirements.Often, it comes from your server, because later on,your server will be responsible for enforcingthat the nonce is valid.With all of those properties set,you have your PKIdentityRequest.Now, let's get back to the button.If identity verification is available,the button will be displayed in your app,and tapping it will start the identity verification flowwith your request.If identity verification is not available,a fallback view you specify will be displayed instead.For example, this will happen if there isn't an ID in Walleton this iPhone.You can use the fallback viewto offer other ways to verify identity.Let's assume identity verification is available,and the user taps the button.The system will then show a sheet with your request,including the elements you requestedand your intent to store them.The user can approve the request with Face ID or Touch ID,or close the sheet without approving.Your code will then receive a result objectcontaining the outcome of the request.If the request was approved, you'll receive a success result.This comes with a PKIdentityDocument objectcontaining the encrypted response,which your app will send to your serverfor decryption and verification.If the request was not successful,you'll receive a failure result.The most common cause of failureis that the request was not approved,in which case you'll receive a cancelled error.That was VerifyIdentityWithWalletButton,the SwiftUI version of the API.Use it to display a buttonthat launches the identity verification flowand requests information from IDs in Wallet.If you're not using SwiftUI in your app,you can also use the PKIdentityButtonand PKIdentityAuthorization Controller classesto accomplish the same thing.OK, so, now you've requested the information,the user's approved the request,and your app has sent the encrypted responseto your server.Now, let's talk about what your server needs to doto decrypt and verify that response.I'm only going to skim the surface on this topic,so please check the developer documentation for more details.The response format uses several international standards,so I strongly recommend familiarizing yourselfwith those as well.The response data you'll receiveis in a CBOR-encoded encryption envelope.CBOR is a data format defined in RFC 8949.It's similar to JSONbut uses binary data to encode objects.The encryption envelope contains metadataneeded for the decryption process,along with the encrypted data itself.The data is encrypted using HPKE,an encryption scheme defined in RFC 9180.Your server will decrypt this data using its private key.Once decrypted, you'll get an mdoc response object.The mdoc response is defined in ISO 18013 part five,the ISO standard for mobile Driver's Licenses and State IDs.The mdoc response object contains the data elementsthat you requested.It also includes a number of security featuresthat your server needs to validateto ensure that the response is authentic.Note that your server will perform the decryptionand validation itself.Neither Apple servers nor the issuing authority's serversare involved.Before we can talk about decryptionand response validation,we need to talk about the session transcript.This is a CBOR structure that binds a response payloadto a specific request from a specific app.Your server will need to build this structure and use itduring both decryption and validation.The session transcript contains the same nonce and merchant IDyou used earlier in your PKIdentityRequest,as well as the team ID of your developer teamand the SHA256 hash of your encryption certificate'spublic key.When building the session transcript,your server should check that the inputs you're usingare all valid.That means the nonce shouldn't have been used already,and should be tied to the current user.The other values should match what's expectedon your developer account.Now let's talk about decrypting the encrypted data.You'll need the session transcript you just created,along with the metadata from the encryption envelope.You'll also need your private key.This is the private keycorresponding to the certificate you setup earlierin your developer account.To protect the confidentiality of user information,you need to make sure your private key stays private.Store it securely on your serverand never include it in your app.If your private key is ever compromised,revoke the certificate in your developer account immediately.After decrypting the encrypted data,you'll receive an mdoc response objectcontaining two cryptographic signatures,plus the data elements you requested.You need to check both signatures in the mdoc responsebefore you can use its data elements.First, you need to check the issuer signature.This is a signature from the issuing authorityof the user's ID.By checking this signature,you're verifying that the data in the responsecame from the real issuing authorityand wasn't tampered with.You should check that not only is the signature valid,but also that it is signed by an issuer certificate you trust.Take a look at the documentation for more detailsabout the issuer certificates used by IDs in Wallet.Next, you need to verify the device signature.This is a signature created by a keyin the Secure Element of the user's iPhone.It proves that the response you receivedcame from the same iPhone that the issuing authorityoriginally issued the ID to.Here, you'll need to use your session transcript again,along with some information covered by the issuer signature.Finally, you're ready to use the data elementsthat you requested.You should never use these elementswithout first verifying the issuer and device signatures,because otherwise you don't know whether the data you receivedis authentic.And with all those steps completed, you're done!Your app has requested the information,and your server has decrypted and verified the response.You might be wondering how to test your implementationif you don't have an ID in Wallet.We've provided a few mechanisms to help you do that.First, you can test in the iOS Simulator,where the API will return a mock response.This response is similar to a real one,but lacks real signatures.Similarly, you can use a test profileto receive a mock response on a real iPhone,even If you don't have an ID in Wallet on that iPhone.See the documentation for more details about how to do this.Note that your server should never treateither of these mock responses like a real one.To help you with your server implementation,the documentation also includes an example response,along with everything you need to decrypt and validate it.And that's how you can perform identity verificationwith IDs in Wallet in iOS 16.We discussed how to use the API in your app,how to process the response on your server,and how to test your implementation.Lais: This year, we introduced many great new featuresto Wallet and Apple Pay.These include multi-merchant payments,improved support for automatic payments,order tracking, and identity verification.Please check out the developer documentationfor more information.David: Thank you for watching, and have a great WWDC!♪

2:39 -AddPassToWalletButton

3:40 -PayWithApplePayButton

6:34 -Multi-merchant payments

10:14 -Automatic Payments - Recurring payment request

12:39 -Automatic Payments - Automatic reload payment request

19:17 -Order Tracking (swift)

20:13 -Order Tracking (JS)

27:05 -VerifyIdentityWithWalletButton 2

27:18 -Create a PKIdentityRequest

27:19 -VerifyIdentityWithWalletButton 3

29:37 -VerifyIdentityWithWalletButton 4

## Code Samples

```swift
@State
 
var
 addedToWallet: 
Bool



@ViewBuilder
 
private
 
var
 airlineButton: 
some
 
View
 {
    
if
 
let
 pass 
=
 createAirlinePass() {
        
AddPassToWalletButton
([pass]) { added 
in

            addedToWallet 
=
 added
        }
        .frame(width: 
250
, height: 
50
)
        .addPassToWalletButtonStyle(.blackOutline)
    } 
else
 {
        
// Fallback

    }
}
```

```swift
// Create a payment request


let
 paymentRequest 
=
 
PKPaymentRequest
()

// ...



// Create a payment authorization change method


func
 
authorizationChange
(
phase
: 
PayWithApplePayButtonPaymentAuthorizationPhase
) { 
...
 }


PayWithApplePayButton
(
    .plain,
    request: paymentRequest,
    onPaymentAuthorizationChange: authorizationChange
) {
    
// Fallback

}
.frame(width: 
250
, height: 
50
)
.payWithApplePayButtonStyle(.automatic)
```

```swift
// Create a payment request


let
 paymentRequest 
=
 
PKPaymentRequest
()

// ...



// Set total amount

paymentRequest.paymentSummaryItems 
=
 [
    
PKPaymentSummaryItem
(label: 
"Total"
, amount: 
500
)
]


// Create a multi token context for each additional merchant in the payment


let
 multiTokenContexts 
=
 [
    
PKPaymentTokenContext
(
        merchantIdentifier: 
"com.example.air-travel"
,
        externalIdentifier: 
"com.example.air-travel"
,
        merchantName: 
"Air Travel"
,
        merchantDomain: 
"air-travel.example.com"
,
        amount: 
150

    ),
    
PKPaymentTokenContext
(
        merchantIdentifier: 
"com.example.hotel"
,
        externalIdentifier: 
"com.example.hotel"
,
        merchantName: 
"Hotel"
,
        merchantDomain: 
"hotel.example.com"
,
        amount: 
300

    ),
    
PKPaymentTokenContext
(
        merchantIdentifier: 
"com.example.car-rental"
,
        externalIdentifier: 
"com.example.car-rental"
,
        merchantName: 
"Car Rental"
,
        merchantDomain: 
"car-rental.example.com"
,
        amount: 
50

    )
]
paymentRequest.multiTokenContexts 
=
 multiTokenContexts
```

```swift
// Specify the amount and billing periods


let
 regularBilling 
=
 
PKRecurringPaymentSummaryItem
(label: 
"Membership"
, amount: 
20
)


let
 trialBilling 
=
 
PKRecurringPaymentSummaryItem
(label: 
"Trial Membership"
, amount: 
10
)


let
 trialEndDate 
=
 
Calendar
.current.date(byAdding: .month, value: 
1
, to: 
Date
.now)
trialBilling.endDate 
=
 trialEndDate
regularBilling.startDate 
=
 trialEndDate


// Create a recurring payment request


let
 recurringPaymentRequest 
=
 
PKRecurringPaymentRequest
(
    paymentDescription: 
"Book Club Membership"
,
    regularBilling: regularBilling,
    managementURL: 
URL
(string: 
"https://www.example.com/managementURL"
)
!

)
recurringPaymentRequest.trialBilling 
=
 trialBilling

recurringPaymentRequest.billingAgreement 
=
 
"""
50% off for the first month. You will be charged $20 every month after that until you cancel. \ You may cancel at any time to avoid future charges. To cancel, go to your Account and click \ Cancel Membership.
"""


recurringPaymentRequest.tokenNotificationURL 
=
 
URL
(
    string: 
"https://www.example.com/tokenNotificationURL"

)
!



// Update the payment request


let
 paymentRequest 
=
 
PKPaymentRequest
()

// ...

paymentRequest.recurringPaymentRequest 
=
 recurringPaymentRequest


// Include in the summary items


let
 total 
=
 
PKRecurringPaymentSummaryItem
(label: 
"Book Club"
, amount: 
10
)
total.endDate 
=
 trialEndDate
paymentRequest.paymentSummaryItems 
=
 [trialBilling, regularBilling, total]
```

```swift
// Specify the reload amount and threshold


let
 automaticReloadBilling 
=
 
PKAutomaticReloadPaymentSummaryItem
(
    label: 
"Coffee Shop Reload"
,
    amount: 
25

)
reloadItem.thresholdAmount 
=
 
5



// Create an automatic reload payment request


let
 automaticReloadPaymentRequest 
=
 
PKAutomaticReloadPaymentRequest
(
    paymentDescription: 
"Coffee Shop"
,
    automaticReloadBilling: automaticReloadBilling,
    managementURL: 
URL
(string: 
"https://www.example.com/managementURL"
)
!

)

automaticReloadPaymentRequest.billingAgreement 
=
 
"""
Coffee Shop will add $25.00 to your card immediately, and will automatically reload your 
\

card with $25.00 whenever the balance falls below $5.00. You may cancel at any time to avoid \ future charges. To cancel, go to your Account and click Cancel Reload.
"""


automaticReloadPaymentRequest.tokenNotificationURL 
=
 
URL
(
    string: 
"https://www.example.com/tokenNotificationURL"

)
!



// Update the payment request


let
 paymentRequest 
=
 
PKPaymentRequest
()

// ...

paymentRequest.automaticReloadPaymentRequest 
=
 automaticReloadPaymentRequest


// Include in the summary items


let
 total 
=
 
PKAutomaticReloadPaymentSummaryItem
(
    label: 
"Coffee Shop"
,
    amount: 
25

)
total.thresholdAmount 
=
 
5

paymentRequest.paymentSummaryItems 
=
 [total]
```

```swift
func
 
onAuthorizationChange
(
phase
: 
PayWithApplePayButtonPaymentAuthorizationPhase
) {
    
switch
 phase {
    
// ...

    
case
 .didAuthorize(
let
 payment, 
let
 resultHandler):
        server.createOrder(with: payment) { serverResult 
in

            
guard
 
case
 .success(
let
 orderDetails) 
=
 serverResult 
else
 { 
/* handle error */
 }
            
let
 result 
=
 
PKPaymentAuthorizationResult
(status: .success, errors: 
nil
)
            result.orderDetails 
=
 
PKPaymentOrderDetails
(
                orderTypeIdentifier: orderDetails.orderTypeIdentifier,
                orderIdentifier: orderDetails.orderIdentifier,
                webServiceURL: orderDetails.webServiceURL,
                authenticationToken: orderDetails.authenticationToken,
            )
            resultHandler(result)
        }
    }
}
```

```swift
paymentRequest.
show
().
then
(
(
response
) =>
 {
    server.
createOrder
(response).
then
(
(
orderDetails
) =>
 {
        
let
 details = { };
        
if
 (response.
methodName
 === 
"https://apple.com/apple-pay"
) {
            details.
data
 = {
                
orderDetails
: {
                    
orderTypeIdentifier
: orderDetails.
orderTypeIdentifier
,
                    
orderIdentifier
: orderDetails.
orderIdentifier
,
                    
webServiceURL
: orderDetails.
webServiceURL
,
                    
authenticationToken
: orderDetails.
authenticationToken
,
                },
            };
        }
        response.
complete
(
"success"
, details);
    });
});
```

```swift
@ViewBuilder
 
var
 verifiyIdentityButton: 
some
 
View
 {
    
VerifyIdentityWithWalletButton
(
        .verifyIdentity,
        request: createRequest(),
    ) { result 
in

        
// ...

    } fallback: {
        
// verify identity another way

    }
}
```

```swift
func
 
createRequest
() -> 
PKIdentityRequest
 {
    
let
 descriptor 
=
 
PKIdentityDriversLicenseDescriptor
()
    descriptor.addElements([.age(atLeast: 
18
)],
                            intentToStore: .willNotStore)
    descriptor.addElements([.givenName, .familyName, .portrait],
                            intentToStore: .mayStore(days: 
30
))

    
let
 request 
=
 
PKIdentityRequest
()
    request.descriptor 
=
 descriptor
    request.merchantIdentifier 
=
 
// configured in Developer account

    request.nonce 
=
 
// bound to user session

}
```

```swift
@ViewBuilder
 
var
 verifiyIdentityButton: 
some
 
View
 {
    
VerifyIdentityWithWalletButton
(
        .verifyIdentity,
        request: createRequest(),
    ) { result 
in

        
switch
 result {
        
case
 .success(
let
 document):
            
// send document to server for decryption and verification

        
case
 .failure(
let
 error):
            
switch
 error {
            
case
 
PKIdentityError
.cancelled:
                
// handle cancellation

            
default
:
                
// handle other errors

            }
        }
    } fallback: {
        
// verify identity another way

    }
}
```


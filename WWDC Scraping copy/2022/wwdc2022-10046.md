# Wwdc2022 10046

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Adopt declarative device managementDiscover how you can simplify development of your device management solution with the declarative approach. We'll take you through the latest updates to platform support and explore protocol enhancements for status and predicates.ResourcesDevice ManagementHD VideoSD VideoRelated VideosWWDC23Explore advances in declarative device managementWWDC22What's new in managing Apple devicesWWDC21Meet declarative device management

Discover how you can simplify development of your device management solution with the declarative approach. We'll take you through the latest updates to platform support and explore protocol enhancements for status and predicates.

Device Management

HD VideoSD Video

HD Video

SD Video

Explore advances in declarative device management

What's new in managing Apple devices

Meet declarative device management

Search this video…♪ instrumental hip hop music ♪♪Welcome to the "Adopt declarative device management"session.My name is Cyrus Daboo,and I am an engineer on the Device Management team.I am here to tell you about the exciting new featuresin declarative device management.At WWDC21,my colleague Melissa introduced declarative device management,a new paradigm for managing Apple devices,reenvisioning the MDM protocol itself.As we learned in that session,declarative device management is powerfulbecause it enables devices to be autonomous and proactive.The device is autonomous,as it reacts to its own state changesand then applies management logic to itself,without prompting from the server.The device is proactive,with the status channel asynchronously reportingto the server when important state changes occur,avoiding the need for servers to poll devices.There are two key elementsto the declarative device management data model:declarations and status.Declarations encompass activations and predicates,configurations, assets, and management types.And status covers status items and status reporting.Let's take a moment to talk about why this matters,what it means for you,and the organizations that use your products.We have created this technologyto support new complex management strategies,enhance the overall user experience of managed devices,alleviate the repetitive and tedious tasks of an IT admin,and empower devices to be the driverin their own management state.For you, as a developer of a device management solution,the declarative approach allows your serversto be lightweight and reactive.And with the declarative data modelmore closely mapping to how organizations are structured,that means changes to devices becomes more intuitive.Status reports provide a rich feedback channel,which enable your servers to monitor devices more closely,and present pertinent informationin a more timely and reliable fashion,without the need for complex strategiesused to implement polling.All of this means a simpler development effort,enabling you to focus on the device management featuresthat add value where it matters most,and create a solution your customers will love.For IT admins,the declarative approach inspires more confidencethat the device is in the expected state.And in the situations where it is not,that it is in a safe statethat protects any sensitive organization data,even when connectivity to the server is lost.It provides critical feedback from devices via status reports,that also improves efficiency for adminsthrough less utilization of resourcessuch as network bandwidth.For the organization's users,device management becomes a more responsiveand reliable experience with faster onboarding,quicker recovery timesand better support from their organization.With all these benefits in mind,know that the focus of future protocol featureswill be declarative device management,making it even more importantfor you to adopt declarative device managementin your products today.For an in-depth introduction to declarative device managementand the steps needed to adopt it,make sure you watch the WWDC21 session video.In this release, we have three focus areas:expanding the scope of declarative device management,enhancing status reports, and enhancing predicates.Let's start with expanding the scopeof declarative device management.When declarative device management was introduced,it was supported on only iOS with user enrollments.Now, declarative device management is availablefor every enrollment type MDM supports:automatic device enrollment,which includes supervised devices;profile-based enrollment;and profile and account-based user enrollments.Declarative device management is now also availableon Shared iPad.In iOS 16, users can now find configurationsin the MDM profile details view in the Settings app.Tapping the Configurations row reveals detailsabout the active configurations.And I am also pleased to announcethat declarative device management is availableon every platform MDM supports.macOS Ventura now supports declarative device management,for all MDM enrollment types supported on macOS.tvOS 16 now supports declarative device managementfor MDM device enrollment types.Where supported by the OS,the same set of declarations and statusthat are available on iOSare also available on macOS and tvOS.On macOS, a Configurations section is presentin the MDM profile details view,revealing the active configurations.The same goes for tvOS, where a Configurations sectionis present in the MDM profile details view.One last thing to note here:both macOS and Shared iPad deviceseach have two MDM channels.These are the device and user channel.The device channel allows managementof device level state,whereas the user channel targets management statefor specific users.To use declarative device management on any channel,it must be enabled separately for that channel.That means sending the DeclarativeManagement commandon the corresponding channel.Also, declarative device management status reportsare separately generated for each channel,so they need to be separately monitored as well.Now on to our second focus area: status reports.Let's do a quick review of status reports.Devices can incrementally report status to the server,for subscribed status items.The device tracks successful responses from the serverto ensure status updates are reliableand not missed in the case of networkingor other types of problem.Status reporting makes the device proactive.There is no need for servers to continuously poll the deviceto watch for state changes.In iOS 15, we introduced a set of status itemsfor device properties, such as model typeand operating system version.For this release we are expanding status in three areas:passcode state,accounts installed by configurations,and MDM installed apps.Let's start with passcode status.In iOS 15, we introduced a passcode policy configuration.There can be some lag between the policy being applied,and the passcode becoming compliantwhen changed by the user,just as there is with MDM passcode policy profiles.So, MDM servers have to poll the device to determinewhen the passcode becomes compliant.But with the new declarative device managementpasscode status items, there is no need to do that.We have added two status items:Passcode.is-compliant and passcode.is-present.Compliance indicates if the passcode is compliantwith all passcode policies applied via MDM profilesor configurations.These status items have Boolean valuesthat mirror the equivalent propertiesthat can be retrieved via MDM queries.Let's explore a typical server behavior.Often, an organization has security sensitive stateto apply to a device.For example, VPN or Wi-Fi profilesto allow access to protected networks.That state should only be active on a device,when a strong passcode policy is present,and the passcode is compliant with that policy.With traditional MDM, a server has to senda passcode policy profile then poll the device,to wait for the passcode to become compliantwhen the user changes it.Initially the passcode is likely not compliant,so the Wi-Fi profile cannot be sent.Eventually, the user changes the passcodeto bring it into compliance.On the server's next poll,it detects the changed compliant stateand determines it is OK to send the Wi-Fi profile,which then gets installed on the device.Declarative device management removes the needfor the server to poll by using an activation predicatethat is triggered by the passcode compliance state.The server sends both the passcode policyand the Wi-Fi profile as configurations,with the Wi-Fi configuration tied to an activationpredicated on the passcode compliance.The passcode configuration is immediately activatedand applies a strong passcode policy.Initially, the passcode is likely not compliant,so the activation predicate evaluates to false,and the Wi-Fi configuration is not activated.At some point, the user updates the passcode to be compliant.This triggers reevaluation of the activationsand the predicate now evaluates to true,resulting in the Wi-Fi configuration being activated.All this happens without any intervention from the server,and in fact can happen without any connectionto the server being present.The server does automatically get a status reportfrom the device when the configuration activates,so it knows when the change takes place.This illustrates how we have successfully movedbusiness logic from the server to the device,to avoid the need to polland get a more responsive and reliable device behavior.Now, let's turn to account status.In iOS 15, we introduced account configurationsto install accounts of various types on a device.These are typically organization accounts,giving the user access to organization data.It is useful for the admin to know when accountshave been successfully installed,and what state they are in,to help support users who might be having problems.This release adds eight account status items for mail,calendar, and other account types.Note, that status is only reported for accountsinstalled by configurationsand won't include accounts created manuallyor installed via MDM profiles.Each new status item correspondsto an account configuration type,with status for incoming and outgoing mail accountsreported separately.The new status items each use a different type of JSON object,to represent the status of the corresponding account type.Here are examples of an incoming mail status item,and a subscribed calendar status item.The value of the identifier key is a unique identifierfor an object within the array of status item objects --more on this in a minute.The value of the declaration identifier key,matches the identifier property valueof the configuration that installed the account,making it easy to cross-referencethe status item object and its associated configuration.These two keys are always presentin all types of account status item object.The other keys are specific to the type of account.For example, hostname and port for the mail server,or calendar-URL for the subscribed calendar.This release introduces status items whose value is an array,to support reporting on one or more accountsof the same type.Such array values have special behavior.Each item in the array is a JSON objectwith the same schema used for all objects in a single array.Each object type always has an identifier key,acting as the primary key for locating objectswithin the array.Other keys are presentand tied to the underlying type of status being reported.To ensure forwards compatibilitywith any keys added in future OS releases,your server must accept unknown keys in array objects.Changes to an array value are always reportedincrementally to the serveron a per-object basis, for performance reasons.Let's run through an examplethat shows how this new feature works.In this example,the server sends two mail account configurationsto the device.These are both active resulting in two mail accountspresent on the device.The server now sends a status subscriptionfor the mail account status item.When the subscription is activated,status for the accounts is collected,and the device sends a status report to the server.The status report will include the two account status objectsin the status array,giving the server a complete pictureof what is currently present on the device.Each array object has a different identifier.After processing this report,the server has status for two mail accounts,matching what is on the device.When the server adds a mail account on the deviceby sending a new configuration, the status item on the devicehas a new object added to its array value,and another status report is sent to the server.Only the new item is reported.The value of the identifier key does not matchany the server already has,so the server can infer this corresponds to a new account.After processing this report,the server has status for three mail accounts,the two initial ones and the new one,again matching exactly what is on the device.When account status changes,such as when a user toggles the mail or notes enabled state,the status item on the devicewill have an updated object in its array value,and again, a status report is sent to the server.Only the changed item is reported.In this case, the user turned off the notes featurefor the account.The value of the identifier keymatches one the server already has,so the server can infer that this is an updateto an existing account.Consequently,it replaces the existing status item array objectwith the new one.After processing this report,the server has status for three mail accounts,but one has changed.When an account configuration is removed from the device,the status item on the devicehas the corresponding object marked for removal,and another status report is sent to the server.Only the removed item is reported.To indicate removal,the array item object contains only two keys:the identifier key --whose value matches one the server already has --and the removed key, set to the value true.This allows the server to update its representationof the device state by removing the existing item.After processing this report,the server has status for only two mail accounts,correctly matching the state of the device.One last point about status reports.The device will limit the rate at which status reports are sentto avoid performance issues.The device aggregates changes to status itemsover a variable interval of up to one minutebefore sending a status report to the server.This means status is reported quickly,but it is not immediate.Next, let's turn our attentionto solving a perennial MDM-bottleneck problem:monitoring application install status.MDM servers often install apps on devices to give users accessto the tools needed for their work or education.Server-side logic is often dictatedby whether an app is installed successfully or not.So MDM servers need to monitor app installation progressand watch for the possibility of users removing managed appson their device.Currently, MDM servers can use the InstalledApplicationListor ManagedApplicationList commands to poll the deviceto observe app installation progress.We can avoid polling by having the deviceproactively send app install progress to the server.And the tool to do thatis declarative device management status reports.This release adds an mdm.app status item.Its value is an array of objects that each represent an appthat has been installed by the MDM server.Since this value is an array, it is reported incrementally,using the procedure described earlier.Note that only apps installed by MDM are reported here,even on supervised devices.This status report includes a status item for an appthat has finished installing.The identifier key is the unique identifierfor the array item object, and in this case,is the app's bundle identifier.The name key indicates the name of the app.The three version keys provide normal, short,and external version identifiers.And the state key is an enumerationthat indicates the current install phase for the app.The values of these keys correspondto the equivalent items in the MDMManagedApplicationList command response.With all this information, the server can immediately identifywhich app is being reported and what its state is.Let's examine an example of the flow of data as an app installs.On the right side, we have an iOS 16 devicethat is being managed by an MDM server.The server has already enabled declarative device managementand sent a status subscriptionfor the MDM-installed app status item.The next step for the server is to install an appusing the MDM InstallApplication command.Since this is a user enrollment, user approval is neededto install the app, so a prompt appearswhen the device processes the app install command.At this point, the installation progress is paused,waiting for user input.The device will send a status report to the server,and that will contain a single MDM-installed app status object,with the bundle ID of the app and the state set to prompting.At some point, the user taps the Install button,and the app install starts on the device.As the install proceeds, another status report will be sent,this time with the app state set to installing;indicating the app is being downloaded and installed.Eventually, the app completes installationand is ready for use.At that point, another status report will be sentwith the app state set to managed,indicating the app is properly installed and managed.Now, let's say the user manually deletes the app on the device.Again, a status report will be sent,this time with the app state set to managed-but-uninstalled.This indicates the app is no longer installed,but its management state is still being trackedon the device.Let's assume the server wants to removethe app-management state.It does that by sending a RemoveApplication commandto the device.That removes the internally maintained management state,and if the app were still present,it would be removed too.Another status report will be sent with the app objectmarked as removed from the app status array.This illustrates the power of the new MDM status itemto help improve the responsivenessand reliability of app installs,and it only takes a few steps to implement.Now, let's examine our third focus area: predicates.Let's quickly review activation predicates.Activations can include an optional predicatethat determines whether the configurationsreferenced in the activation will be applied to the device.Predicates can reference status itemsto allow the values of those status items to be tested.When a status item referenced in a predicate changes,the device will reprocess all of the activations,reevaluating any predicates.Predicates are specified as a stringusing the NSPredicate syntaxdocumented on the Apple Developer site.To support more complex predicate expressions,we have extended the predicate syntax to make it easierto detect status items in the expression.The new syntax places the status item nameinside an @status term in the predicate string.In the example, the serial number status itemappears in the predicate expression,using the new syntax.The previous syntax will continue to workfor backwards compatibility, however, it is now deprecated,so please switch to the new one.Let's examine how predicates can be usedwith status item array values.As we just described, we now have status item valuesthat are arrays for the accountsand MDM-installed app status items.It is useful to be able to predicate an activationon an item in the array.For example, we might want an activation to be triggeredwhen an app with a particular bundle identifieris installed and managed on the device.NSPredicate has a SUBQUERY termthat can be used to operate on arrays.This NSPredicate expression uses a SUBQUERYtargeting the MDM-installed app status item.The status item is used as the first argument to the SUBQUERY.The second argument defines a variablethat will refer to each element of the array.The third argument is a predicate expressionthat tests each element identified by that variable.The SUBQUERY expression returns an array of elementsthat match the predicate in the third argument.The @count operator then returns the lengthof that array, and the length is checkedto determine if there is one resulting match.When the specified app is installed and managed,this SUBQUERY expression will return an arraywith a single element,and the predicate will evaluate to true.When the app is not installed, the SUBQUERY expressionwill return an empty array,and the predicate will evaluate to false.Note that in order to reference the keysin the status item array object, the @key extension termmust be used to ensure the key paths are properly processed.The new predicate syntax is extensible,and we will now discuss how it can be usedto add predicate terms for a new type of data.Servers need to be able to more directly controlthe evaluation of predicates, so that complex server-side logiccan translate into simple state changes on the device,without the need to synchronize large sets of configurationsto trigger those changes.An example of this might be an organization that has userswith multiple roles and wants efficient,just-in-time assignment of devicesas they are handed out to users, or organizations that needto quickly distribute replacement devices,or quickly put devices into a safe modeto protect organization data.To support this, I am pleased to saywe are adding a new declaration to allow serversto set arbitrary properties on the device,that can be directly used in activation predicates.This is the new management properties declaration.The declaration consists of a JSON objectwhose key names are defined by the server.The JSON object values can be any JSON value type,including arrays or objects.The management properties declaration here,includes three properties: the name and age propertiesthat have a string and integer value,and the roles property that is an array of strings.This is an activation with a predicatethat references some management properties.First, it tests the age property to determineif its integer value is greater than or equal to 18,then it tests the roles property to determineif the string Grade12 is in the property array value.Each property is referencedusing the @property extension term,with the property key name inside the term.Multiple management properties declarationscan be sent to the device,but the keys should be unique across all of them.If there are duplicate keys, one of the valueswill be arbitrarily chosen when the property is referencedin a predicate, leading to unpredictable results.So please avoid using duplicate key names.Let's explore an example use case.This example involves a school.And of course, the school has a set of teachers.The school has two divisions: Upper and Lower.Each division has its own campus with its own Wi-Fi network.Some teachers function as an IT Adminand require access to a shared mail account.Some teachers also function as a sports coachand should have a subscribed calendarfor all the team game schedules.There are thus four different roles that a teacher may have,and sometimes they have multiple roles.Each role has a set of configurationsthat must be applied to devices based on the rolesof the teacher assigned to the device.Let's consider two teachers in our example.Teacher one teaches in Lower schooland is also a sports coach.Teacher two teaches in Upper school and is also an IT admin.How might such a use case be handledby a traditional MDM server?Typically, the server has to wait for a deviceto be assigned to a teacherbefore it can fully configure that device.The server has to determine what roles the teacher has.It then determines what profiles are linked to each role.It then has to install each profile on the deviceone at a time.If a teacher changes roles, the server has to addor remove profiles to match the new roles.This is time-consuming and can introducesignificant bottlenecks to a device-management systemparticularly at peak times,which in our case would be the first day of schoolwhen assignments are done.With the new management properties declaration,we have a more efficient alternative to this.This involves preloading a full set of declarationson the device ahead of time.Configurations are assigned to activations,with predicates that are triggered for different rolesvia management properties.When a device is assigned to a teacher, the server sends onlya management properties declarationwith the teacher's roles, which triggers activationof the configurations for those roles.This method minimizes the overall serverand network traffic and reduces the complexityof making rapid changes to device state.Let's go back to our school example.The server will preload the following sets of declarations:two activation/configuration pairsthat set up the Wi-Fi network for each division.Then, we have an activation/configuration pairfor the IT admin role, that installs a mail account.Finally, we have an activation and configurationthat installs a subscribed calendar.Each activation has a predicate that tests the divisionor function's name using the roles management property.When initially loaded on an unassigned device,all the predicates evaluate to false, so nothing is applied.Now, let's examine what happens on the day of assignment.All the server needs to do is createmanagement properties declarationscustomized to each teacher.Teacher one has a roles property that lists Lower and Sports.Teacher two has a roles property that lists Upper and IT Admin.When these declarations are separately sentto each assigned device,the preloaded activations will all be reevaluated.So teacher one's device has the configurationsfor Lower and Sports roles activated.And teacher two's device has the configurationsfor the Upper and IT Admin roles activated.Only a single declaration is needed to triggerthe application of many configurations.Finally, let's examinewhat happens when a teacher changes roles.In this case, teacher two has become a sports coachin addition to their existing roles.The management properties declarationfor the teacher's assigned device is now updatedto include the additional role name.When that declaration is updated on the device,all the activations are reevaluated.In this case, the subscribed calendar configurationfor the new Sports role will be applied.Again, only a single declaration change is needed as a trigger.This illustrateshow the management properties declarationprovides a powerful way to quickly and easily switchbetween sets of configurations on a device,so that complex server-side logiccan translate into simple state changes on the device.Now, let's wrap up.We have extended the scope of declarative device managementon iOS 16, tvOS 16, and macOS Ventura,as well as making it available for all applicable typesof MDM enrollment, including Shared iPad.This provides full support for declarative device managementacross all Apple devices that support MDM.We have added new status items for passcode, accounts,and MDM-installed apps.The MDM-installed app status provides a great solutionfor one of MDM's key bottlenecks.Finally, we have enhanced the predicate syntaxto make it more extensible and easy to useand added the new management properties declarationthat gives servers even more opportunityto move complex business logic to the device.Now is the time to add declarative device managementto your products.And we're excited to learn what you'll doto reimagine device management solutionsusing declarative device management!As always, your feedback is greatly appreciated.Thank you and enjoy the rest of WWDC.♪ ♪

♪ instrumental hip hop music ♪♪Welcome to the "Adopt declarative device management"session.

My name is Cyrus Daboo,and I am an engineer on the Device Management team.

I am here to tell you about the exciting new featuresin declarative device management.

At WWDC21,my colleague Melissa introduced declarative device management,a new paradigm for managing Apple devices,reenvisioning the MDM protocol itself.

As we learned in that session,declarative device management is powerfulbecause it enables devices to be autonomous and proactive.

The device is autonomous,as it reacts to its own state changesand then applies management logic to itself,without prompting from the server.

The device is proactive,with the status channel asynchronously reportingto the server when important state changes occur,avoiding the need for servers to poll devices.

There are two key elementsto the declarative device management data model:declarations and status.

Declarations encompass activations and predicates,configurations, assets, and management types.

And status covers status items and status reporting.

Let's take a moment to talk about why this matters,what it means for you,and the organizations that use your products.

We have created this technologyto support new complex management strategies,enhance the overall user experience of managed devices,alleviate the repetitive and tedious tasks of an IT admin,and empower devices to be the driverin their own management state.

For you, as a developer of a device management solution,the declarative approach allows your serversto be lightweight and reactive.

And with the declarative data modelmore closely mapping to how organizations are structured,that means changes to devices becomes more intuitive.

Status reports provide a rich feedback channel,which enable your servers to monitor devices more closely,and present pertinent informationin a more timely and reliable fashion,without the need for complex strategiesused to implement polling.

All of this means a simpler development effort,enabling you to focus on the device management featuresthat add value where it matters most,and create a solution your customers will love.

For IT admins,the declarative approach inspires more confidencethat the device is in the expected state.

And in the situations where it is not,that it is in a safe statethat protects any sensitive organization data,even when connectivity to the server is lost.

It provides critical feedback from devices via status reports,that also improves efficiency for adminsthrough less utilization of resourcessuch as network bandwidth.

For the organization's users,device management becomes a more responsiveand reliable experience with faster onboarding,quicker recovery timesand better support from their organization.

With all these benefits in mind,know that the focus of future protocol featureswill be declarative device management,making it even more importantfor you to adopt declarative device managementin your products today.

For an in-depth introduction to declarative device managementand the steps needed to adopt it,make sure you watch the WWDC21 session video.

In this release, we have three focus areas:expanding the scope of declarative device management,enhancing status reports, and enhancing predicates.

Let's start with expanding the scopeof declarative device management.

When declarative device management was introduced,it was supported on only iOS with user enrollments.

Now, declarative device management is availablefor every enrollment type MDM supports:automatic device enrollment,which includes supervised devices;profile-based enrollment;and profile and account-based user enrollments.

Declarative device management is now also availableon Shared iPad.

In iOS 16, users can now find configurationsin the MDM profile details view in the Settings app.

Tapping the Configurations row reveals detailsabout the active configurations.

And I am also pleased to announcethat declarative device management is availableon every platform MDM supports.

macOS Ventura now supports declarative device management,for all MDM enrollment types supported on macOS.

tvOS 16 now supports declarative device managementfor MDM device enrollment types.

Where supported by the OS,the same set of declarations and statusthat are available on iOSare also available on macOS and tvOS.

On macOS, a Configurations section is presentin the MDM profile details view,revealing the active configurations.

The same goes for tvOS, where a Configurations sectionis present in the MDM profile details view.

One last thing to note here:both macOS and Shared iPad deviceseach have two MDM channels.

These are the device and user channel.

The device channel allows managementof device level state,whereas the user channel targets management statefor specific users.

To use declarative device management on any channel,it must be enabled separately for that channel.

That means sending the DeclarativeManagement commandon the corresponding channel.

Also, declarative device management status reportsare separately generated for each channel,so they need to be separately monitored as well.

Now on to our second focus area: status reports.

Let's do a quick review of status reports.

Devices can incrementally report status to the server,for subscribed status items.

The device tracks successful responses from the serverto ensure status updates are reliableand not missed in the case of networkingor other types of problem.

Status reporting makes the device proactive.

There is no need for servers to continuously poll the deviceto watch for state changes.

In iOS 15, we introduced a set of status itemsfor device properties, such as model typeand operating system version.

For this release we are expanding status in three areas:passcode state,accounts installed by configurations,and MDM installed apps.

Let's start with passcode status.

In iOS 15, we introduced a passcode policy configuration.

There can be some lag between the policy being applied,and the passcode becoming compliantwhen changed by the user,just as there is with MDM passcode policy profiles.

So, MDM servers have to poll the device to determinewhen the passcode becomes compliant.

But with the new declarative device managementpasscode status items, there is no need to do that.

We have added two status items:Passcode.is-compliant and passcode.is-present.

Compliance indicates if the passcode is compliantwith all passcode policies applied via MDM profilesor configurations.

These status items have Boolean valuesthat mirror the equivalent propertiesthat can be retrieved via MDM queries.

Let's explore a typical server behavior.

Often, an organization has security sensitive stateto apply to a device.

For example, VPN or Wi-Fi profilesto allow access to protected networks.

That state should only be active on a device,when a strong passcode policy is present,and the passcode is compliant with that policy.

With traditional MDM, a server has to senda passcode policy profile then poll the device,to wait for the passcode to become compliantwhen the user changes it.

Initially the passcode is likely not compliant,so the Wi-Fi profile cannot be sent.

Eventually, the user changes the passcodeto bring it into compliance.

On the server's next poll,it detects the changed compliant stateand determines it is OK to send the Wi-Fi profile,which then gets installed on the device.

Declarative device management removes the needfor the server to poll by using an activation predicatethat is triggered by the passcode compliance state.

The server sends both the passcode policyand the Wi-Fi profile as configurations,with the Wi-Fi configuration tied to an activationpredicated on the passcode compliance.

The passcode configuration is immediately activatedand applies a strong passcode policy.

Initially, the passcode is likely not compliant,so the activation predicate evaluates to false,and the Wi-Fi configuration is not activated.

At some point, the user updates the passcode to be compliant.

This triggers reevaluation of the activationsand the predicate now evaluates to true,resulting in the Wi-Fi configuration being activated.

All this happens without any intervention from the server,and in fact can happen without any connectionto the server being present.

The server does automatically get a status reportfrom the device when the configuration activates,so it knows when the change takes place.

This illustrates how we have successfully movedbusiness logic from the server to the device,to avoid the need to polland get a more responsive and reliable device behavior.

Now, let's turn to account status.

In iOS 15, we introduced account configurationsto install accounts of various types on a device.

These are typically organization accounts,giving the user access to organization data.

It is useful for the admin to know when accountshave been successfully installed,and what state they are in,to help support users who might be having problems.

This release adds eight account status items for mail,calendar, and other account types.

Note, that status is only reported for accountsinstalled by configurationsand won't include accounts created manuallyor installed via MDM profiles.

Each new status item correspondsto an account configuration type,with status for incoming and outgoing mail accountsreported separately.

The new status items each use a different type of JSON object,to represent the status of the corresponding account type.

Here are examples of an incoming mail status item,and a subscribed calendar status item.

The value of the identifier key is a unique identifierfor an object within the array of status item objects --more on this in a minute.

The value of the declaration identifier key,matches the identifier property valueof the configuration that installed the account,making it easy to cross-referencethe status item object and its associated configuration.

These two keys are always presentin all types of account status item object.

The other keys are specific to the type of account.

For example, hostname and port for the mail server,or calendar-URL for the subscribed calendar.

This release introduces status items whose value is an array,to support reporting on one or more accountsof the same type.

Such array values have special behavior.

Each item in the array is a JSON objectwith the same schema used for all objects in a single array.

Each object type always has an identifier key,acting as the primary key for locating objectswithin the array.

Other keys are presentand tied to the underlying type of status being reported.

To ensure forwards compatibilitywith any keys added in future OS releases,your server must accept unknown keys in array objects.

Changes to an array value are always reportedincrementally to the serveron a per-object basis, for performance reasons.

Let's run through an examplethat shows how this new feature works.

In this example,the server sends two mail account configurationsto the device.

These are both active resulting in two mail accountspresent on the device.

The server now sends a status subscriptionfor the mail account status item.

When the subscription is activated,status for the accounts is collected,and the device sends a status report to the server.

The status report will include the two account status objectsin the status array,giving the server a complete pictureof what is currently present on the device.

Each array object has a different identifier.

After processing this report,the server has status for two mail accounts,matching what is on the device.

When the server adds a mail account on the deviceby sending a new configuration, the status item on the devicehas a new object added to its array value,and another status report is sent to the server.

Only the new item is reported.

The value of the identifier key does not matchany the server already has,so the server can infer this corresponds to a new account.

After processing this report,the server has status for three mail accounts,the two initial ones and the new one,again matching exactly what is on the device.

When account status changes,such as when a user toggles the mail or notes enabled state,the status item on the devicewill have an updated object in its array value,and again, a status report is sent to the server.

Only the changed item is reported.

In this case, the user turned off the notes featurefor the account.

The value of the identifier keymatches one the server already has,so the server can infer that this is an updateto an existing account.

Consequently,it replaces the existing status item array objectwith the new one.

After processing this report,the server has status for three mail accounts,but one has changed.

When an account configuration is removed from the device,the status item on the devicehas the corresponding object marked for removal,and another status report is sent to the server.

Only the removed item is reported.

To indicate removal,the array item object contains only two keys:the identifier key --whose value matches one the server already has --and the removed key, set to the value true.

This allows the server to update its representationof the device state by removing the existing item.

After processing this report,the server has status for only two mail accounts,correctly matching the state of the device.

One last point about status reports.

The device will limit the rate at which status reports are sentto avoid performance issues.

The device aggregates changes to status itemsover a variable interval of up to one minutebefore sending a status report to the server.

This means status is reported quickly,but it is not immediate.

Next, let's turn our attentionto solving a perennial MDM-bottleneck problem:monitoring application install status.

MDM servers often install apps on devices to give users accessto the tools needed for their work or education.

Server-side logic is often dictatedby whether an app is installed successfully or not.

So MDM servers need to monitor app installation progressand watch for the possibility of users removing managed appson their device.

Currently, MDM servers can use the InstalledApplicationListor ManagedApplicationList commands to poll the deviceto observe app installation progress.

We can avoid polling by having the deviceproactively send app install progress to the server.

And the tool to do thatis declarative device management status reports.

This release adds an mdm.app status item.

Its value is an array of objects that each represent an appthat has been installed by the MDM server.

Since this value is an array, it is reported incrementally,using the procedure described earlier.

Note that only apps installed by MDM are reported here,even on supervised devices.

This status report includes a status item for an appthat has finished installing.

The identifier key is the unique identifierfor the array item object, and in this case,is the app's bundle identifier.

The name key indicates the name of the app.

The three version keys provide normal, short,and external version identifiers.

And the state key is an enumerationthat indicates the current install phase for the app.

The values of these keys correspondto the equivalent items in the MDMManagedApplicationList command response.

With all this information, the server can immediately identifywhich app is being reported and what its state is.

Let's examine an example of the flow of data as an app installs.

On the right side, we have an iOS 16 devicethat is being managed by an MDM server.

The server has already enabled declarative device managementand sent a status subscriptionfor the MDM-installed app status item.

The next step for the server is to install an appusing the MDM InstallApplication command.

Since this is a user enrollment, user approval is neededto install the app, so a prompt appearswhen the device processes the app install command.

At this point, the installation progress is paused,waiting for user input.

The device will send a status report to the server,and that will contain a single MDM-installed app status object,with the bundle ID of the app and the state set to prompting.

At some point, the user taps the Install button,and the app install starts on the device.

As the install proceeds, another status report will be sent,this time with the app state set to installing;indicating the app is being downloaded and installed.

Eventually, the app completes installationand is ready for use.

At that point, another status report will be sentwith the app state set to managed,indicating the app is properly installed and managed.

Now, let's say the user manually deletes the app on the device.

Again, a status report will be sent,this time with the app state set to managed-but-uninstalled.

This indicates the app is no longer installed,but its management state is still being trackedon the device.

Let's assume the server wants to removethe app-management state.

It does that by sending a RemoveApplication commandto the device.

That removes the internally maintained management state,and if the app were still present,it would be removed too.

Another status report will be sent with the app objectmarked as removed from the app status array.

This illustrates the power of the new MDM status itemto help improve the responsivenessand reliability of app installs,and it only takes a few steps to implement.

Now, let's examine our third focus area: predicates.

Let's quickly review activation predicates.

Activations can include an optional predicatethat determines whether the configurationsreferenced in the activation will be applied to the device.

Predicates can reference status itemsto allow the values of those status items to be tested.

When a status item referenced in a predicate changes,the device will reprocess all of the activations,reevaluating any predicates.

Predicates are specified as a stringusing the NSPredicate syntaxdocumented on the Apple Developer site.

To support more complex predicate expressions,we have extended the predicate syntax to make it easierto detect status items in the expression.

The new syntax places the status item nameinside an @status term in the predicate string.

In the example, the serial number status itemappears in the predicate expression,using the new syntax.

The previous syntax will continue to workfor backwards compatibility, however, it is now deprecated,so please switch to the new one.

Let's examine how predicates can be usedwith status item array values.

As we just described, we now have status item valuesthat are arrays for the accountsand MDM-installed app status items.

It is useful to be able to predicate an activationon an item in the array.

For example, we might want an activation to be triggeredwhen an app with a particular bundle identifieris installed and managed on the device.

NSPredicate has a SUBQUERY termthat can be used to operate on arrays.

This NSPredicate expression uses a SUBQUERYtargeting the MDM-installed app status item.

The status item is used as the first argument to the SUBQUERY.

The second argument defines a variablethat will refer to each element of the array.

The third argument is a predicate expressionthat tests each element identified by that variable.

The SUBQUERY expression returns an array of elementsthat match the predicate in the third argument.

The @count operator then returns the lengthof that array, and the length is checkedto determine if there is one resulting match.

When the specified app is installed and managed,this SUBQUERY expression will return an arraywith a single element,and the predicate will evaluate to true.

When the app is not installed, the SUBQUERY expressionwill return an empty array,and the predicate will evaluate to false.

Note that in order to reference the keysin the status item array object, the @key extension termmust be used to ensure the key paths are properly processed.

The new predicate syntax is extensible,and we will now discuss how it can be usedto add predicate terms for a new type of data.

Servers need to be able to more directly controlthe evaluation of predicates, so that complex server-side logiccan translate into simple state changes on the device,without the need to synchronize large sets of configurationsto trigger those changes.

An example of this might be an organization that has userswith multiple roles and wants efficient,just-in-time assignment of devicesas they are handed out to users, or organizations that needto quickly distribute replacement devices,or quickly put devices into a safe modeto protect organization data.

To support this, I am pleased to saywe are adding a new declaration to allow serversto set arbitrary properties on the device,that can be directly used in activation predicates.

This is the new management properties declaration.

The declaration consists of a JSON objectwhose key names are defined by the server.

The JSON object values can be any JSON value type,including arrays or objects.

The management properties declaration here,includes three properties: the name and age propertiesthat have a string and integer value,and the roles property that is an array of strings.

This is an activation with a predicatethat references some management properties.

First, it tests the age property to determineif its integer value is greater than or equal to 18,then it tests the roles property to determineif the string Grade12 is in the property array value.

Each property is referencedusing the @property extension term,with the property key name inside the term.

Multiple management properties declarationscan be sent to the device,but the keys should be unique across all of them.

If there are duplicate keys, one of the valueswill be arbitrarily chosen when the property is referencedin a predicate, leading to unpredictable results.

So please avoid using duplicate key names.

Let's explore an example use case.

This example involves a school.

And of course, the school has a set of teachers.

The school has two divisions: Upper and Lower.

Each division has its own campus with its own Wi-Fi network.

Some teachers function as an IT Adminand require access to a shared mail account.

Some teachers also function as a sports coachand should have a subscribed calendarfor all the team game schedules.

There are thus four different roles that a teacher may have,and sometimes they have multiple roles.

Each role has a set of configurationsthat must be applied to devices based on the rolesof the teacher assigned to the device.

Let's consider two teachers in our example.

Teacher one teaches in Lower schooland is also a sports coach.

Teacher two teaches in Upper school and is also an IT admin.

How might such a use case be handledby a traditional MDM server?Typically, the server has to wait for a deviceto be assigned to a teacherbefore it can fully configure that device.

The server has to determine what roles the teacher has.

It then determines what profiles are linked to each role.

It then has to install each profile on the deviceone at a time.

If a teacher changes roles, the server has to addor remove profiles to match the new roles.

This is time-consuming and can introducesignificant bottlenecks to a device-management systemparticularly at peak times,which in our case would be the first day of schoolwhen assignments are done.

With the new management properties declaration,we have a more efficient alternative to this.

This involves preloading a full set of declarationson the device ahead of time.

Configurations are assigned to activations,with predicates that are triggered for different rolesvia management properties.

When a device is assigned to a teacher, the server sends onlya management properties declarationwith the teacher's roles, which triggers activationof the configurations for those roles.

This method minimizes the overall serverand network traffic and reduces the complexityof making rapid changes to device state.

Let's go back to our school example.

The server will preload the following sets of declarations:two activation/configuration pairsthat set up the Wi-Fi network for each division.

Then, we have an activation/configuration pairfor the IT admin role, that installs a mail account.

Finally, we have an activation and configurationthat installs a subscribed calendar.

Each activation has a predicate that tests the divisionor function's name using the roles management property.

When initially loaded on an unassigned device,all the predicates evaluate to false, so nothing is applied.

Now, let's examine what happens on the day of assignment.

All the server needs to do is createmanagement properties declarationscustomized to each teacher.

Teacher one has a roles property that lists Lower and Sports.

Teacher two has a roles property that lists Upper and IT Admin.

When these declarations are separately sentto each assigned device,the preloaded activations will all be reevaluated.

So teacher one's device has the configurationsfor Lower and Sports roles activated.

And teacher two's device has the configurationsfor the Upper and IT Admin roles activated.

Only a single declaration is needed to triggerthe application of many configurations.

Finally, let's examinewhat happens when a teacher changes roles.

In this case, teacher two has become a sports coachin addition to their existing roles.

The management properties declarationfor the teacher's assigned device is now updatedto include the additional role name.

When that declaration is updated on the device,all the activations are reevaluated.

In this case, the subscribed calendar configurationfor the new Sports role will be applied.

Again, only a single declaration change is needed as a trigger.

This illustrateshow the management properties declarationprovides a powerful way to quickly and easily switchbetween sets of configurations on a device,so that complex server-side logiccan translate into simple state changes on the device.

Now, let's wrap up.

We have extended the scope of declarative device managementon iOS 16, tvOS 16, and macOS Ventura,as well as making it available for all applicable typesof MDM enrollment, including Shared iPad.

This provides full support for declarative device managementacross all Apple devices that support MDM.

We have added new status items for passcode, accounts,and MDM-installed apps.

The MDM-installed app status provides a great solutionfor one of MDM's key bottlenecks.

Finally, we have enhanced the predicate syntaxto make it more extensible and easy to useand added the new management properties declarationthat gives servers even more opportunityto move complex business logic to the device.

Now is the time to add declarative device managementto your products.

And we're excited to learn what you'll doto reimagine device management solutionsusing declarative device management!As always, your feedback is greatly appreciated.

Thank you and enjoy the rest of WWDC.

♪ ♪

7:41 -Passcode status items

10:52 -Account status items

11:19 -Mail and subscribed calendar status item objects

17:13 -MDM app status item

17:35 -Status report with MDM app status item

22:15 -Predicate subquery using the MDM app status item

24:10 -Management properties declaration

24:40 -Management properties declaration object

24:53 -Activation with management properties predicate

## Code Samples

```swift
{

  
"management"
:
 
{

    
"client-capabilities"
:
 
{

     
"supported-payloads"
:
 
{

       
"status-items"
:
 
[

          ...
          
"passcode.is-compliant"
,

          
"passcode.is-present"
,

          ...
        
]

      
}

    
}

  
}


}
```

```swift
{

  ...
      
"status-items"
:
 
[

          ...
          
"account.list.caldav"
,

          
"account.list.carddav"
,

          
"account.list.exchange"
,

          
"account.list.google"
,

          
"account.list.ldap"
,

          
"account.list.mail.incoming"
,

          
"account.list.mail.outgoing"
,

          
"account.list.subscribed-calendar"
,

          ...
        
]

  ...

}
```

```swift
{

  
"identifier"
:
 
"592D763E-C15B-44F8-A1FC-F88EB1901646"
,

  
"declaration-identifier"
:
 
"BF8FD199-467B-4BA5-886D-D82B7849E517"
,

  
"hostname"
:
 
"mail.example.com"
,

  
"port"
:
 
443
,

  
"username"
:
 
"user01"
,

  
"is-mail-enabled"
:
 
true
,

  
"are-notes-enabled"
:
 
false


}



{

  
"identifier"
:
 
"592D763E-C15B-44F8-A1FC-F88EB1901646"
,

  
"declaration-identifier"
:
 
"BF8FD199-467B-4BA5-886D-D82B7849E517"
,

  
"calendar-url"
:
 
"https://holidays.example.com/country/US.ics"
,

  
"username"
:
 
"user01"
,

  
"is-enabled"
:
 
true


}
```

```swift
{

  
"management"
:
 
{

    
"client-capabilities"
:
 
{

     
"supported-payloads"
:
 
{

       
"status-items"
:
 
[

          ...
          
"mdm.app"
,

          ...
        
]

      
}

    
}

  
}


}
```

```swift
{

  
"StatusItems"
:
 
{

    
"mdm"
:
 
{

      
"app"
:
 
[

        
{

          
"identifier"
:
 
"com.apple.Pages"
,

          
"name"
:
 
"Pages"
,

          
"version"
:
 
"7358.0.134"
,

          
"short-version"
:
 “
12.0
",
          "
external-version-id
": "
844362702
",
          "
state
": "
managed
"
        }
      ]
    }
  },
  "
Errors
": []
}
```

```swift
SUBQUERY(
@status
(mdm.app),
         $app,
         ($app.
@key
(identifier) == "com.example.app") AND ($app.
@key
(state) == "managed")
        ).
@count
 == 1
```

```swift
{

  
"management"
:
 
{

    
"client-capabilities"
:
 
{

     
"supported-payloads"
:
 
{

       
"declarations"
:
 
{

         ...
         
"management"
:
 
[

          ...
          
"com.apple.management.properties"
,

          ...
         
]

         ...
        
}

      
}

    
}

  
}


}
```

```swift
{

  
"Type"
:
 
"com.apple.management.properties"
,

  
"Identifier"
:
 
"AAE09D73-6EF6-4F3B-9E15-11B0F86D5591"
,

  
"ServerToken"
:
 
"AB4C5B91-3E08-4D4E-A9FF-1E44FE5BFDD4"
,

  
"Payload"
:
 
{

    
"name"
:
 
"Student One"
,

    
"age"
:
 
7
,

    
"roles"
:
 
[
"grade1"
,
 
"spanish"
]

  
}


}
```

```swift
{

  
"Type"
:
 
"com.apple.activation.simple"
,

  
"Identifier"
:
 
"076F928B-9D8E-4BA2-AD34-5655805C82D7"
,

  
"ServerToken"
:
 
"4FFA91BF-85AE-4053-B8FE-B1C3E507A9CB"
,

  
"Payload"
:
 
{

    
"StandardConfigurations"
:
 
[

      
"3BBB4407-238A-44B1-ABB1-5E7AB95160E0"

    
]

  
}
,

  
"Predicate"
:
 
"(@property(age) >= 18) AND ("
Grade12
" IN @property(roles))"


}
```


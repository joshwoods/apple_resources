# Wwdc2022 110352

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Embrace Swift genericsGenerics are a fundamental tool for writing abstract code in Swift. Learn how you can identify opportunities for abstraction as your code evolves, evaluate strategies for writing one piece of code with many behaviors, and discover language features in Swift 5.7 that can help you make generic code easier to write and understand.ResourcesThe Swift Programming LanguageHD VideoSD VideoRelated VideosWWDC23Generalize APIs with parameter packsWWDC22Design protocol interfaces in SwiftWhat's new in Swift

Generics are a fundamental tool for writing abstract code in Swift. Learn how you can identify opportunities for abstraction as your code evolves, evaluate strategies for writing one piece of code with many behaviors, and discover language features in Swift 5.7 that can help you make generic code easier to write and understand.

The Swift Programming Language

HD VideoSD Video

HD Video

SD Video

Generalize APIs with parameter packs

Design protocol interfaces in Swift

What's new in Swift

Search this video…♪ Mellow instrumental hip-hop music ♪♪Hi everyone, I'm Holly from the Swift Compiler team.Welcome to "Embrace Swift generics."Generics are a fundamental toolfor writing abstract code in Swift,which is crucial for managing complexity as your code evolves.Abstraction separates ideas from specific details.In code, there are a lot of different waysabstraction is useful.One form of abstraction that you likely use all the timeis factoring code out into a function or a local variable.This can be really useful if you need to usethe same functionality or value multiple times.When you extract the functionality into a function,the details are abstracted away,and the code that uses the abstractioncan express the idea of what's happeningwithout repeating the details.In Swift, you can also abstract away concrete types.If you have a set of types that are all the same ideawith different details, you can write abstract codeto work with all of those concrete types.Today, we'll walk through the workflowof modeling code with concrete types,identifying common capabilities of a set of concrete types,building an interface to represent those capabilities,and finally,we'll dive into writing generic code using that interface.We'll dig into Swift's abstraction toolswhile building up some code to simulate a farm.So, let's start by writing some concrete types.We'll start with one struct called "Cow."Cow has a method called "eat,"which accepts a parameter of type Hay.Hay is another struct.It has a static method called "grow"to grow the crop that produces Hay,which is Alfalfa.The Alfalfa struct has a method to harvest Hayfrom an instance of Alfalfa.Finally, we'll add a struct called "Farm"that has a method for feeding a cow.The feed method can be implementedby first growing some alfalfa to produce hay,then harvesting the hay,and finally, feeding the hay to the cow.And now, I can feed cows on my farm.But I want to add more kinds of animals.I can add more structs to represent other animals,like Horse and Chicken.And I want to be able to feed cows, horses, and chickenson the farm.I could overload the feed methodto accept each type of parameter separately,but each overload will have a really similar implementation.This will become extra boilerplateas I add more types of animals,and it's mostly repeated code anyway.If you find yourself writing overloadswith repetitive implementations,it might be a sign to generalize.Fundamentally, these implementations are so similarbecause different types of animalsare similar in functionality.The next step is to identify the common capabilitiesbetween the animal types.We've built a set of animal typesthat all have the ability to eat some type of food.Each type of animal will have a different way of eating,so each implementation of the eat methodwill have differences in behavior.What we want to dois allow abstract code to call the eat methodand have that abstract code behave differentlydepending on the concrete type it's operating on.The ability of abstract code to behave differentlyfor different concrete types is called "polymorphism."Polymorphism allows one piece of code to have many behaviorsdepending on how the code is used.Appropriately, polymorphism itself comes in different forms.The first is function overloading,where the same function call can mean different thingsdepending on the argument type.Overloading is called "ad-hoc polymorphism"because it isn't really a general solution.We just saw how overloading can lead to repetitive code.Next is subtype polymorphism,where code operating on a supertypecan have different behavior based on the specific subtypethe code is using at runtime.Finally, we have parametric polymorphism,which is achieved using generics.Generic code uses type parameters to allow writingone piece of code that works with different types,and concrete types themselves are used as arguments.We've already ruled out overloading,so let's try to use subtype polymorphism.One way to represent subtype relationshipsis with a class hierarchy.We could introduce a class called "Animal."Next, we'd change each animal type from a struct to a class.Each specific animal class will inheritfrom the Animal superclass, and override the eat method.Now, we have an abstract base-class Animalthat can represent all of our specific animal types.Code that calls eat on the Animal classwill use subtype polymorphismto call the subclass implementation.But we're not done.We still haven't filled in a parameter typefor the eat method on Animal,and there are a few other red flags in this code.First, using classes forced us into reference semantics,even though we don't need or want any state to be sharedbetween different animal instances.This strategy also requires subclassesto override methods in the base class,but forgetting to do this wouldn't be caughtuntil runtime.But the bigger problem with this model of abstractionis that each animal subtype eats a different type of food,and this dependency is really difficult to expresswith a class hierarchy.One approach we could take is to have the method accepta less specific type, such as Any.But this strategy relies on subclass implementationsto make sure the correct type was passed at runtime.So, we've imposed extra boilerplatein each overridden method, but more importantly,it allows you to accidentally pass the wrong type of food,leaving you with another bugthat could only be caught at runtime.So, let's try something else.We could instead express the animal's feed typein a type-safe wayby introducing a type parameter on the Animal superclass.This type parameter serves as a placeholderfor the specific feed type for each subclass.With this approach, the Food type parametermust be elevated to the declaration of the Animal class.This seems a little unnaturalbecause though animals need food to operate,eating food isn't the core purpose of an animal,and a lot of code that works with animalsprobably won't care about food at all.Despite that, all references to the Animal classneed to specify the food type.For example, each Animal subclassneeds to explicitly specify its food type in angle bracketsin the inheritance clause.This boilerplate at each use site of the Animal classcould become onerous if we added more typesthat are specific to each animal.So, none of our approaches herehave good ergonomics or the right semantics.The fundamental problem is that a class is a data type,and we're trying to convolute a superclassto make it represent abstract ideas about concrete types.Instead, we want a language constructthat was designed to represent capabilities of typeswithout the details of how the capability works.Animals have two common capabilities.Each animal has a specific type of food,along with an operation for consuming some of that food.We can build an interface that represents those capabilities.In Swift, this is done using a protocol.A protocol is an abstraction toolthat describes the functionality of conforming types.Using a protocol, you can separate the ideasabout what a type does from the implementation details.The ideas about what a type doesare expressed through an interface.Let's translate the capabilities of an animalto a protocol interface.The name of the protocolrepresents the category of types we're describing,so I called this protocol "Animal."Each capability will map to a protocol requirement.The specific type of food will mapto an associated type of the Animal protocol.Just like a type parameter, an associated typeserves as a placeholder for a concrete type.What makes associated types specialis that they depend on the specific typethat conforms to the protocol.This relationship is guaranteed,so each instance of a specific type of animalalways has the same type of food.Next, the operation to consume food will map to a method.This method is called "eat,"and it accepts a parameter of the animal's feed type.The protocol does not have an implementation of this method,and concrete animal types are required to implement it.Now that we have the Animal protocol,we can make each concrete animal type conform to it.You can annotate a concrete type with a protocol conformanceat the declaration or in an extension.Protocols are not limited to classes,so we can use protocols with structs, enums, and actors, too.Once you write this conformance annotation,the compiler will check that the concrete typeimplements each of the protocol requirements.Each animal type must implement the eat method,and the compiler can infer what the feed type is,because it's used in the parameter list.The feed type can also be written explicitlyusing a type alias.We've successfully identified the common capabilitiesof an animal and expressed those capabilities,using a protocol interface.Now, we can start to write generic code.We can use the Animal protocolto implement the feed method on Farm.We want to write one implementationthat works for all concrete animal types.We'll use parametric polymorphismand introduce a type parameter that will be replacedwith a concrete type when the method is called.A type parameter is written after the function namein angle brackets.Just like regular variables and function parameters,you can name a type parameter whatever you like.And just like any other type,you can reference the type parameterthroughout the function signature, using its name.Here, I declared a type parameter called “A”,and I used A as the type of the animal function parameter.We always want the concrete animal typeto conform to the Animal protocol,so we annotate the type parameterwith a protocol conformance.Protocol conformances can be written in angle brackets,or they can be written in a trailing "where" clause,where you can also specify relationshipsbetween different type parameters.Named type parameters and trailing "where" clausesare really powerful, because they allow you to writesophisticated requirements and type relationships.But most generic functions don't need this generality.Let's focus on the feed method.The type parameter A appears once in the parameter list,and the "where" clause lists a conformance requirementon the type parameter.In this case,naming the type parameter and using the "where" clausemake the method look more complicated than it really is.This generic pattern is really common,so there's a simpler way to express it.Instead of writing a type parameter explicitly,we can express this abstract typein terms of the protocol conformanceby writing "some Animal”.This declaration is identical to the previous one,but the unnecessary type parameter listand "where" clause are gone,because we didn't need the expressiveness they provide.Writing "some Animal" is more straightforward,because it reduces syntactic noise,and it includes the semantic informationabout the animal parameterright in the parameter declaration.Let's break down the some Animal syntax.The "some" in "some Animal"indicates that there is a specific typethat you're working with.The "some" keyword is always followedby a conformance requirement.In this case, the specific type must conformto the Animal protocol, which will allow usto use requirements from the Animal protocolon the parameter value.The "some" keyword can be used in parameter and result types.If you've written SwiftUI code before,you've already used "some" in result positionusing "some View."A result type of "some View" is exactly the same concept.In a SwiftUI view, the body propertyreturns some specific type of view,but code that uses the body propertydoesn't need to know what the specific type is.Let's take a step back to better understandthe concept of a specific abstract type.An abstract type that represents a placeholderfor a specific concrete type is called an opaque type.The specific concrete type that is substituted inis called the underlying type.For values with opaque type,the underlying type is fixed for the scope of the value.This way, generic code using the value is guaranteedto get the same underlying type each time the value is accessed.A type using the "some" keyword and a named type parameterin angle brackets both declare an opaque type.Opaque types can be used for both inputs and outputs,so they can be declared in parameter positionor in result position.The function arrow is the dividing linebetween these positions.The position of an opaque type determineswhich part of the program sees the abstract typeand which part of the program determines the concrete type.Named type parameters are always declared on the input side,so the caller decides the underlying type,and the implementation uses the abstract type.In general, the part of the program supplying the valuefor an opaque parameter or result typedecides the underlying type, and the part of the programusing the value sees the abstract type.Let's dig into how this works,following our intuition about parameter and result values.Because the underlying type is inferred from a value,the underlying type always comes from the same placeas the value.For a local variable, the underlying type is inferredfrom the value on the right-hand side of assignment.This means local variables with opaque typemust always have an initial value;and if you don't provide one,the compiler will report an error.The underlying type must be fixedfor the scope of the variable,so attempting to change the underlying typewill also result in an error.For parameters with opaque type, the underlying type is inferredfrom the argument value at the call site.Using "some" in parameter position is new in Swift 5.7.The underlying type only needs to be fixedfor the scope of the parameter,so each call can provide a different argument type.For an opaque result type, the underlying type is inferredfrom the return value in the implementation.A method or computed property with an opaque result typecan be called from anywhere in the program,so the scope of this named value is global.This means the underlying return type has to be the sameacross all return statements;and if it isn't, the compiler will report an errorthat the underlying return values have mismatched types.For an opaque SwiftUI view, the ViewBuilder DSLcan transform control-flow statementsto have the same underlying return type for each branch.So in this case, we can fix the issueby using the ViewBuilder DSL.Writing an @ViewBuilder annotation on the methodand removing return statements will enable the resultto be built for us by the ViewBuilder type.Let's go back to the feedAnimal method.I can use "some" in the parameter listbecause I don't need to referencethe opaque type anywhere else.When you need to refer to the opaque type multiple timesin the function signature,that's when a name type parameter comes in handy.For example, if we add another associated typeto the animal protocol called "Habitat,"we might want to be able to build a habitaton the farm for a given animal.In this case,the result type depends on the specific animal type,so we need to use the type parameter Ain the parameter type and the return type.Another common place where you need to referto an opaque type multiple times is in generic types.Code often declares a type parameter on a generic type,uses the type parameter for a stored property,and again in a memberwise initializer.Referencing a generic type in a different contextalso requires you to explicitly specify the type parameterin angle brackets.The angle brackets at the declarationcan help clarify how to use a generic type,so opaque types must always be named for generic types.Now, let's build out the implementationof the feed method.We can use the type of the animal parameterto access the crop type to growthrough the Feed-associated type.We'll call Feed.grow() to get an instance of the cropthat produces this type of feed.Next, we need to harvest the produce from the crop,which we can do by calling a methodprovided by the crop type called "harvest."And finally, we can feed this produce to the animal.Because the underlying animal type is fixed,the compiler knows the relationshipbetween the plant type, the produce type,and the animal type across the various method calls.These static relationships prevent us from makingthe mistake of feeding the animal the wrong type of food.If we attempt to use a type that is not guaranteedto be the correct food type for this animal,the compiler will tell us.To learn how the other farm protocolswere crafted to express the relationshipbetween the animal-feed type and its plant,check out "Design protocol interfaces in Swift."Lastly, let's add a method for feeding all the animals.I'll add a method called feedAll that accepts an array.I know the element type needs to conformto the Animal protocol,but I want the array to be able to storedifferent types of animals.Let's see if some Animal can help us here.With "some" there is a specific underlying typethat cannot vary.Because the underlying type is fixed,all of the elements in the array need to have the same type.So, an array of some Animal doesn't express the right thing,because I want an array that can hold different animal types.Here, we really need a supertypethat can represent any type of animal.We can express an arbitrary type of animalby writing "any Animal."The "any" keyword indicates that this type can storeany arbitrary type of animal,and the underlying type of animal can vary at runtime.Just like with the "some" keyword,the "any" keyword is always followedby a conformance requirement.any Animal is a single static type that has the capabilityto store any concrete animal type dynamically,which allows us to use subtype polymorphismwith value types.To allow for this flexible storage,the any Animal type has a special representationin memory.You can think of this representation like a box.Sometimes, a value is small enoughto fit inside the box directly.And other values are too large for the box,so the value has to be allocated elsewhere,and the box stores a pointer to that value.The static type any Animal that can dynamically storeany concrete animal type is formally calledan existential type.And the strategy of using the same representationfor different concrete types is called "type erasure."The concrete type is said to be erased at compile time,and the concrete type is only known at runtime.These two instances of the existential type any Animalhave the same static type, but different dynamic types.Type erasure eliminates the type-level distinctionbetween different animal values, which allows us to use valueswith different dynamic types interchangeablyas the same static type.We can use type erasure to write a heterogeneous arrayof value types,which is exactly what we want for the feedAll method.So we'll use an array of any Animalas the parameter type.Using the "any" keyword for protocolswith associated types is new in Swift 5.7.To implement the feedAll method,we'll first iterate over the animal's array.For each animal, we want to call the eat methodfrom the Animal protocol.To call this method,we need to get the specific feed typefor the underlying animal at this iteration.But as soon as we try to call eat on any Animal,we'll get a compiler error.Because we've eliminated the type-level distinctionbetween specific animal types,we've also eliminated all type relationshipsthat depend on the specific animal type,including associated types.So, we can't know what type of feed this animal expects.To rely on type relationships,we need to get back into a contextwhere the specific type of animal is fixed.Instead of calling eat directly on any Animal,we need to call the feed method that accepts some Animal.Now, any Animal is a different type from some Animal,but the compiler can convert an instance of any Animalto some Animal by unboxing the underlying valueand passing it directly to the some Animal parameter.This capability of unboxing arguments is new in Swift 5.7.You can think of unboxing as the compiler opening the boxand taking out the value stored inside.For the scope of the some Animal parameter,the value has a fixed underlying type,so we have access to all of the operationson the underlying type,including access to associated types.This is really cool because it allows us to optfor flexible storage when we need it,while still allowing us to get back to a contextwhere we have the full expressivityof the static type system by fixing the underlying typefor the scope of a function.And most of the time,you don't have to think about the unboxingbecause it just works in the way you'd expect,similar to how calling a protocol method on any Animalreally calls the method on the underlying type.So, we can pass each animal to the feed method,where we can grow and harvest the appropriate cropto feed to the specific animal at each iteration.Throughout this process, we've seen that "some" and "any"have different capabilities.With "some," the underlying type is fixed.This allows you to rely on type relationshipsto the underlying type in your generic code,so you'll have full access to the API and associated typeson the protocol you're working with.Use "any" when you need to store arbitrary concrete types."any" provides type erasure,which allows you represent heterogeneous collections,represent the absence of an underlying type,using optionals,and make the abstraction an implementation detail.In general, write "some" by default,and change "some" to "any"when you know you need to store arbitrary values.With this approach, you'll only pay the costof type erasure and its semantic limitationswhen you need the storage flexibility it provides.This workflow is similar to writing let-constantsby default, until you know you need mutation.In this session, we walked throughthe workflow of generalizing codeas it evolves and gains more functionality.We started by writing concrete types.As the code gained more functionality,we noticed repetition between different concrete types.From there, we identified common capabilitiesand generalized them using a protocol.Finally, we wrote abstract code using "some" and "any”,and we discussed preferring "some" for more expressive code.To dig deeper into crafting protocolsand understanding type erasure,check out "Design protocol interfaces in Swift."Thank you joining me and have a great WWDC.♪

♪ Mellow instrumental hip-hop music ♪♪Hi everyone, I'm Holly from the Swift Compiler team.

Welcome to "Embrace Swift generics."Generics are a fundamental toolfor writing abstract code in Swift,which is crucial for managing complexity as your code evolves.

Abstraction separates ideas from specific details.

In code, there are a lot of different waysabstraction is useful.

One form of abstraction that you likely use all the timeis factoring code out into a function or a local variable.

This can be really useful if you need to usethe same functionality or value multiple times.

When you extract the functionality into a function,the details are abstracted away,and the code that uses the abstractioncan express the idea of what's happeningwithout repeating the details.

In Swift, you can also abstract away concrete types.

If you have a set of types that are all the same ideawith different details, you can write abstract codeto work with all of those concrete types.

Today, we'll walk through the workflowof modeling code with concrete types,identifying common capabilities of a set of concrete types,building an interface to represent those capabilities,and finally,we'll dive into writing generic code using that interface.

We'll dig into Swift's abstraction toolswhile building up some code to simulate a farm.

So, let's start by writing some concrete types.

We'll start with one struct called "Cow."Cow has a method called "eat,"which accepts a parameter of type Hay.

Hay is another struct.

It has a static method called "grow"to grow the crop that produces Hay,which is Alfalfa.

The Alfalfa struct has a method to harvest Hayfrom an instance of Alfalfa.

Finally, we'll add a struct called "Farm"that has a method for feeding a cow.

The feed method can be implementedby first growing some alfalfa to produce hay,then harvesting the hay,and finally, feeding the hay to the cow.

And now, I can feed cows on my farm.

But I want to add more kinds of animals.

I can add more structs to represent other animals,like Horse and Chicken.

And I want to be able to feed cows, horses, and chickenson the farm.

I could overload the feed methodto accept each type of parameter separately,but each overload will have a really similar implementation.

This will become extra boilerplateas I add more types of animals,and it's mostly repeated code anyway.

If you find yourself writing overloadswith repetitive implementations,it might be a sign to generalize.

Fundamentally, these implementations are so similarbecause different types of animalsare similar in functionality.

The next step is to identify the common capabilitiesbetween the animal types.

We've built a set of animal typesthat all have the ability to eat some type of food.

Each type of animal will have a different way of eating,so each implementation of the eat methodwill have differences in behavior.

What we want to dois allow abstract code to call the eat methodand have that abstract code behave differentlydepending on the concrete type it's operating on.

The ability of abstract code to behave differentlyfor different concrete types is called "polymorphism."Polymorphism allows one piece of code to have many behaviorsdepending on how the code is used.

Appropriately, polymorphism itself comes in different forms.

The first is function overloading,where the same function call can mean different thingsdepending on the argument type.

Overloading is called "ad-hoc polymorphism"because it isn't really a general solution.

We just saw how overloading can lead to repetitive code.

Next is subtype polymorphism,where code operating on a supertypecan have different behavior based on the specific subtypethe code is using at runtime.

Finally, we have parametric polymorphism,which is achieved using generics.

Generic code uses type parameters to allow writingone piece of code that works with different types,and concrete types themselves are used as arguments.

We've already ruled out overloading,so let's try to use subtype polymorphism.

One way to represent subtype relationshipsis with a class hierarchy.

We could introduce a class called "Animal."Next, we'd change each animal type from a struct to a class.

Each specific animal class will inheritfrom the Animal superclass, and override the eat method.

Now, we have an abstract base-class Animalthat can represent all of our specific animal types.

Code that calls eat on the Animal classwill use subtype polymorphismto call the subclass implementation.

But we're not done.

We still haven't filled in a parameter typefor the eat method on Animal,and there are a few other red flags in this code.

First, using classes forced us into reference semantics,even though we don't need or want any state to be sharedbetween different animal instances.

This strategy also requires subclassesto override methods in the base class,but forgetting to do this wouldn't be caughtuntil runtime.

But the bigger problem with this model of abstractionis that each animal subtype eats a different type of food,and this dependency is really difficult to expresswith a class hierarchy.

One approach we could take is to have the method accepta less specific type, such as Any.

But this strategy relies on subclass implementationsto make sure the correct type was passed at runtime.

So, we've imposed extra boilerplatein each overridden method, but more importantly,it allows you to accidentally pass the wrong type of food,leaving you with another bugthat could only be caught at runtime.

So, let's try something else.

We could instead express the animal's feed typein a type-safe wayby introducing a type parameter on the Animal superclass.

This type parameter serves as a placeholderfor the specific feed type for each subclass.

With this approach, the Food type parametermust be elevated to the declaration of the Animal class.

This seems a little unnaturalbecause though animals need food to operate,eating food isn't the core purpose of an animal,and a lot of code that works with animalsprobably won't care about food at all.

Despite that, all references to the Animal classneed to specify the food type.

For example, each Animal subclassneeds to explicitly specify its food type in angle bracketsin the inheritance clause.

This boilerplate at each use site of the Animal classcould become onerous if we added more typesthat are specific to each animal.

So, none of our approaches herehave good ergonomics or the right semantics.

The fundamental problem is that a class is a data type,and we're trying to convolute a superclassto make it represent abstract ideas about concrete types.

Instead, we want a language constructthat was designed to represent capabilities of typeswithout the details of how the capability works.

Animals have two common capabilities.

Each animal has a specific type of food,along with an operation for consuming some of that food.

We can build an interface that represents those capabilities.

In Swift, this is done using a protocol.

A protocol is an abstraction toolthat describes the functionality of conforming types.

Using a protocol, you can separate the ideasabout what a type does from the implementation details.

The ideas about what a type doesare expressed through an interface.

Let's translate the capabilities of an animalto a protocol interface.

The name of the protocolrepresents the category of types we're describing,so I called this protocol "Animal."Each capability will map to a protocol requirement.

The specific type of food will mapto an associated type of the Animal protocol.

Just like a type parameter, an associated typeserves as a placeholder for a concrete type.

What makes associated types specialis that they depend on the specific typethat conforms to the protocol.

This relationship is guaranteed,so each instance of a specific type of animalalways has the same type of food.

Next, the operation to consume food will map to a method.

This method is called "eat,"and it accepts a parameter of the animal's feed type.

The protocol does not have an implementation of this method,and concrete animal types are required to implement it.

Now that we have the Animal protocol,we can make each concrete animal type conform to it.

You can annotate a concrete type with a protocol conformanceat the declaration or in an extension.

Protocols are not limited to classes,so we can use protocols with structs, enums, and actors, too.

Once you write this conformance annotation,the compiler will check that the concrete typeimplements each of the protocol requirements.

Each animal type must implement the eat method,and the compiler can infer what the feed type is,because it's used in the parameter list.

The feed type can also be written explicitlyusing a type alias.

We've successfully identified the common capabilitiesof an animal and expressed those capabilities,using a protocol interface.

Now, we can start to write generic code.

We can use the Animal protocolto implement the feed method on Farm.

We want to write one implementationthat works for all concrete animal types.

We'll use parametric polymorphismand introduce a type parameter that will be replacedwith a concrete type when the method is called.

A type parameter is written after the function namein angle brackets.

Just like regular variables and function parameters,you can name a type parameter whatever you like.

And just like any other type,you can reference the type parameterthroughout the function signature, using its name.

Here, I declared a type parameter called “A”,and I used A as the type of the animal function parameter.

We always want the concrete animal typeto conform to the Animal protocol,so we annotate the type parameterwith a protocol conformance.

Protocol conformances can be written in angle brackets,or they can be written in a trailing "where" clause,where you can also specify relationshipsbetween different type parameters.

Named type parameters and trailing "where" clausesare really powerful, because they allow you to writesophisticated requirements and type relationships.

But most generic functions don't need this generality.

Let's focus on the feed method.

The type parameter A appears once in the parameter list,and the "where" clause lists a conformance requirementon the type parameter.

In this case,naming the type parameter and using the "where" clausemake the method look more complicated than it really is.

This generic pattern is really common,so there's a simpler way to express it.

Instead of writing a type parameter explicitly,we can express this abstract typein terms of the protocol conformanceby writing "some Animal”.

This declaration is identical to the previous one,but the unnecessary type parameter listand "where" clause are gone,because we didn't need the expressiveness they provide.

Writing "some Animal" is more straightforward,because it reduces syntactic noise,and it includes the semantic informationabout the animal parameterright in the parameter declaration.

Let's break down the some Animal syntax.

The "some" in "some Animal"indicates that there is a specific typethat you're working with.

The "some" keyword is always followedby a conformance requirement.

In this case, the specific type must conformto the Animal protocol, which will allow usto use requirements from the Animal protocolon the parameter value.

The "some" keyword can be used in parameter and result types.

If you've written SwiftUI code before,you've already used "some" in result positionusing "some View."A result type of "some View" is exactly the same concept.

In a SwiftUI view, the body propertyreturns some specific type of view,but code that uses the body propertydoesn't need to know what the specific type is.

Let's take a step back to better understandthe concept of a specific abstract type.

An abstract type that represents a placeholderfor a specific concrete type is called an opaque type.

The specific concrete type that is substituted inis called the underlying type.

For values with opaque type,the underlying type is fixed for the scope of the value.

This way, generic code using the value is guaranteedto get the same underlying type each time the value is accessed.

A type using the "some" keyword and a named type parameterin angle brackets both declare an opaque type.

Opaque types can be used for both inputs and outputs,so they can be declared in parameter positionor in result position.

The function arrow is the dividing linebetween these positions.

The position of an opaque type determineswhich part of the program sees the abstract typeand which part of the program determines the concrete type.

Named type parameters are always declared on the input side,so the caller decides the underlying type,and the implementation uses the abstract type.

In general, the part of the program supplying the valuefor an opaque parameter or result typedecides the underlying type, and the part of the programusing the value sees the abstract type.

Let's dig into how this works,following our intuition about parameter and result values.

Because the underlying type is inferred from a value,the underlying type always comes from the same placeas the value.

For a local variable, the underlying type is inferredfrom the value on the right-hand side of assignment.

This means local variables with opaque typemust always have an initial value;and if you don't provide one,the compiler will report an error.

The underlying type must be fixedfor the scope of the variable,so attempting to change the underlying typewill also result in an error.

For parameters with opaque type, the underlying type is inferredfrom the argument value at the call site.

Using "some" in parameter position is new in Swift 5.7.

The underlying type only needs to be fixedfor the scope of the parameter,so each call can provide a different argument type.

For an opaque result type, the underlying type is inferredfrom the return value in the implementation.

A method or computed property with an opaque result typecan be called from anywhere in the program,so the scope of this named value is global.

This means the underlying return type has to be the sameacross all return statements;and if it isn't, the compiler will report an errorthat the underlying return values have mismatched types.

For an opaque SwiftUI view, the ViewBuilder DSLcan transform control-flow statementsto have the same underlying return type for each branch.

So in this case, we can fix the issueby using the ViewBuilder DSL.

Writing an @ViewBuilder annotation on the methodand removing return statements will enable the resultto be built for us by the ViewBuilder type.

Let's go back to the feedAnimal method.

I can use "some" in the parameter listbecause I don't need to referencethe opaque type anywhere else.

When you need to refer to the opaque type multiple timesin the function signature,that's when a name type parameter comes in handy.

For example, if we add another associated typeto the animal protocol called "Habitat,"we might want to be able to build a habitaton the farm for a given animal.

In this case,the result type depends on the specific animal type,so we need to use the type parameter Ain the parameter type and the return type.

Another common place where you need to referto an opaque type multiple times is in generic types.

Code often declares a type parameter on a generic type,uses the type parameter for a stored property,and again in a memberwise initializer.

Referencing a generic type in a different contextalso requires you to explicitly specify the type parameterin angle brackets.

The angle brackets at the declarationcan help clarify how to use a generic type,so opaque types must always be named for generic types.

Now, let's build out the implementationof the feed method.

We can use the type of the animal parameterto access the crop type to growthrough the Feed-associated type.

We'll call Feed.grow() to get an instance of the cropthat produces this type of feed.

Next, we need to harvest the produce from the crop,which we can do by calling a methodprovided by the crop type called "harvest."And finally, we can feed this produce to the animal.

Because the underlying animal type is fixed,the compiler knows the relationshipbetween the plant type, the produce type,and the animal type across the various method calls.

These static relationships prevent us from makingthe mistake of feeding the animal the wrong type of food.

If we attempt to use a type that is not guaranteedto be the correct food type for this animal,the compiler will tell us.

To learn how the other farm protocolswere crafted to express the relationshipbetween the animal-feed type and its plant,check out "Design protocol interfaces in Swift."Lastly, let's add a method for feeding all the animals.

I'll add a method called feedAll that accepts an array.

I know the element type needs to conformto the Animal protocol,but I want the array to be able to storedifferent types of animals.

Let's see if some Animal can help us here.

With "some" there is a specific underlying typethat cannot vary.

Because the underlying type is fixed,all of the elements in the array need to have the same type.

So, an array of some Animal doesn't express the right thing,because I want an array that can hold different animal types.

Here, we really need a supertypethat can represent any type of animal.

We can express an arbitrary type of animalby writing "any Animal."The "any" keyword indicates that this type can storeany arbitrary type of animal,and the underlying type of animal can vary at runtime.

Just like with the "some" keyword,the "any" keyword is always followedby a conformance requirement.

any Animal is a single static type that has the capabilityto store any concrete animal type dynamically,which allows us to use subtype polymorphismwith value types.

To allow for this flexible storage,the any Animal type has a special representationin memory.

You can think of this representation like a box.

Sometimes, a value is small enoughto fit inside the box directly.

And other values are too large for the box,so the value has to be allocated elsewhere,and the box stores a pointer to that value.

The static type any Animal that can dynamically storeany concrete animal type is formally calledan existential type.

And the strategy of using the same representationfor different concrete types is called "type erasure."The concrete type is said to be erased at compile time,and the concrete type is only known at runtime.

These two instances of the existential type any Animalhave the same static type, but different dynamic types.

Type erasure eliminates the type-level distinctionbetween different animal values, which allows us to use valueswith different dynamic types interchangeablyas the same static type.

We can use type erasure to write a heterogeneous arrayof value types,which is exactly what we want for the feedAll method.

So we'll use an array of any Animalas the parameter type.

Using the "any" keyword for protocolswith associated types is new in Swift 5.7.

To implement the feedAll method,we'll first iterate over the animal's array.

For each animal, we want to call the eat methodfrom the Animal protocol.

To call this method,we need to get the specific feed typefor the underlying animal at this iteration.

But as soon as we try to call eat on any Animal,we'll get a compiler error.

Because we've eliminated the type-level distinctionbetween specific animal types,we've also eliminated all type relationshipsthat depend on the specific animal type,including associated types.

So, we can't know what type of feed this animal expects.

To rely on type relationships,we need to get back into a contextwhere the specific type of animal is fixed.

Instead of calling eat directly on any Animal,we need to call the feed method that accepts some Animal.

Now, any Animal is a different type from some Animal,but the compiler can convert an instance of any Animalto some Animal by unboxing the underlying valueand passing it directly to the some Animal parameter.

This capability of unboxing arguments is new in Swift 5.7.

You can think of unboxing as the compiler opening the boxand taking out the value stored inside.

For the scope of the some Animal parameter,the value has a fixed underlying type,so we have access to all of the operationson the underlying type,including access to associated types.

This is really cool because it allows us to optfor flexible storage when we need it,while still allowing us to get back to a contextwhere we have the full expressivityof the static type system by fixing the underlying typefor the scope of a function.

And most of the time,you don't have to think about the unboxingbecause it just works in the way you'd expect,similar to how calling a protocol method on any Animalreally calls the method on the underlying type.

So, we can pass each animal to the feed method,where we can grow and harvest the appropriate cropto feed to the specific animal at each iteration.

Throughout this process, we've seen that "some" and "any"have different capabilities.

With "some," the underlying type is fixed.

This allows you to rely on type relationshipsto the underlying type in your generic code,so you'll have full access to the API and associated typeson the protocol you're working with.

Use "any" when you need to store arbitrary concrete types.

"any" provides type erasure,which allows you represent heterogeneous collections,represent the absence of an underlying type,using optionals,and make the abstraction an implementation detail.

In general, write "some" by default,and change "some" to "any"when you know you need to store arbitrary values.

With this approach, you'll only pay the costof type erasure and its semantic limitationswhen you need the storage flexibility it provides.

This workflow is similar to writing let-constantsby default, until you know you need mutation.

In this session, we walked throughthe workflow of generalizing codeas it evolves and gains more functionality.

We started by writing concrete types.

As the code gained more functionality,we noticed repetition between different concrete types.

From there, we identified common capabilitiesand generalized them using a protocol.

Finally, we wrote abstract code using "some" and "any”,and we discussed preferring "some" for more expressive code.

To dig deeper into crafting protocolsand understanding type erasure,check out "Design protocol interfaces in Swift."Thank you joining me and have a great WWDC.

♪

27:10 -Complete example

## Code Samples

```swift
protocol
 
AnimalFeed
 {
  
associatedtype
 
CropType
: 
Crop
 
where
 
CropType
.
Feed
 
==
 
Self

  
static
 
func
 
grow
() -> 
CropType

}


protocol
 
Crop
 {
  
associatedtype
 
Feed
: 
AnimalFeed
 
where
 
Feed
.
CropType
 
==
 
Self

  
func
 
harvest
() -> 
Feed

}


protocol
 
Animal
 {
  
associatedtype
 
Feed
: 
AnimalFeed

  
func
 
eat
(
_
 
food
: 
Feed
)
}


struct
 
Farm
 {
  
func
 
feed
(
_
 
animal
: 
some
 
Animal
) {
    
let
 crop 
=
 
type
(of: animal).
Feed
.grow()
    
let
 produce 
=
 crop.harvest()
    animal.eat(produce)
  }

  
func
 
feedAll
(
_
 
animals
: [any 
Animal
]) {
    
for
 animal 
in
 animals {
      feed(animal)
    }
  }
}


struct
 
Cow
: 
Animal
 {
  
func
 
eat
(
_
 
food
: 
Hay
) {}
}


struct
 
Hay
: 
AnimalFeed
 {
  
static
 
func
 
grow
() -> 
Alfalfa
 {
    
Alfalfa
()
  }
}


struct
 
Alfalfa
: 
Crop
 {
  
func
 
harvest
() -> 
Hay
 {
    
Hay
()
  }
}
```


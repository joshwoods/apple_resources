# Wwdc2022 10032

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Dive into App IntentsLearn how you can make your app more discoverable and increase app engagement when you use the App Intents framework. We'll take you through the powerful capabilities of this Swift framework, explore the differences between App Intents and SiriKit Intents, and show you how you can expose your app's functionality to the system. We'll also share how you can build entities and queries to create rich App Shortcuts experiences.

To learn more about App Intents, watch "Implement App Shortcuts with App Intents" and "Design App Shortcuts" from WWDC22.ResourcesApp IntentsHD VideoSD VideoRelated VideosWWDC23Bring widgets to lifeTech TalksMigrate custom intents to App IntentsWhat's new for enterprise developersWWDC22Design App ShortcutsImplement App Shortcuts with App IntentsMeet Focus filtersWWDC21Design great actions for Shortcuts, Siri, and Suggestions

Learn how you can make your app more discoverable and increase app engagement when you use the App Intents framework. We'll take you through the powerful capabilities of this Swift framework, explore the differences between App Intents and SiriKit Intents, and show you how you can expose your app's functionality to the system. We'll also share how you can build entities and queries to create rich App Shortcuts experiences.

To learn more about App Intents, watch "Implement App Shortcuts with App Intents" and "Design App Shortcuts" from WWDC22.

App Intents

HD VideoSD Video

HD Video

SD Video

Bring widgets to life

Migrate custom intents to App Intents

What's new for enterprise developers

Design App Shortcuts

Implement App Shortcuts with App Intents

Meet Focus filters

Design great actions for Shortcuts, Siri, and Suggestions

Search this video…♪ Mellow instrumental hip-hop music ♪♪Hi, folks. My name is Michael Gorbachfrom Shortcuts Engineering.Thanks for tuning in for this deep dive into App Intents,our new frameworkfor exposing your app's functionality to the system.Here's the plan for our dive.After a quick introduction,I'll talk about intents and their parameters,and how to define entities.I'll go over some powerful finding and filtering featuresyou can build,and how your intents can interact with the user.Lastly, I'll cover App Intents architecture and lifecycle.Let's start at the beginning.In iOS 10, we introduced the SiriKit Intents framework,which lets you hook up your app's functionalityto Siri domains like messaging, workouts, and payments.Now we're introducing a new frameworkcalled App Intents.It has three key components.Intents are actions built into your appthat can be used throughout the system.Intents use entities to represent your app's concepts.App Shortcuts wrap your intentsto make them automatic and discoverable.Let's talk about a couple of the waysthat App Intents can make your app's functionality availablein more places, and benefit your customers.With App Shortcuts, everyone can useyour app's features with their voice through Siri,without needing to set anything up first.The same adoption also makes your intents appear in Spotlightwhen people search for your app and when your app's suggested.This will put your work front and center.Using App Intents, you can also build Focus Filters,letting customers customize your app for a specific Focus.For example, they might set up their Calendar appto only show their work calendar while they're actually at work.Check out this session to learn more abouthow to adopt Focus Filters.With App Shortcuts,your intents show up in the Shortcuts app automatically,without needing to be added manually.Integrating your actions into Shortcutsis incredibly valuable for customersbecause they can run shortcuts,and take advantage of your app's features,from so many places throughout the system.They can run shortcuts with a single tap on the Home Screen,from the menu bar on macOS, and in many other ways.They can even set shortcuts up to run automaticallywith automations.Supporting shortcuts multiplies the powerand capability of your app by connecting itto the entire Shortcuts ecosystem,harnessing the power of an array of apps from Appleand other developers.That's because a shortcut can combine actionsfrom multiple apps,letting users invent entirely new features and capabilitieswithout you needing to do any work.If you want to learn how to make your actionswork well with others and fit seamlessly into this ecosystem,check out our design talk.Our goal in building App Intentswas to make it a joy to develop for.App Intents is concise.Writing a simple intent can take only a few lines of code,but the API also scalesto deeper and more customizable actions.App Intents is modern.We've gone all in on Swift,leveraging result builders, property wrappers,protocol-oriented programming, and generics.These APIs just couldn't existwithout cutting-edge language features.Adopting App Intents is also easy,because it doesn't require re-architectingyour products and targets or creating a framework.It doesn't require an extensionand can be adopted right in your app.And App Intents code is maintainable.Like SwiftUI, App Intents uses your codeas the fundamental source of truth,avoiding the need for separate editors or definition files.This lets you rapidly build and iterate on your adoption,and simplifies maintenancebecause everything lives in one place.With that said, let's explore these new APIs,starting with the intent,the central building block of our new framework.An app intent -- or "intent" for short --is a single, isolated unit of functionalitythat your app exposes to the system.For example, an intent could make a new calendar event,open a particular screen, or place an order.An intent can be run by the user on request --like by running a shortcut or asking Siri --or automatically --like using Focus filters or a Shortcuts automation.When an intent is run,it will either return a result or throw an error.An intent includes three key pieces:metadata, or information about the intent,including a localized title;parameters, which are inputs that the intent can usewhen it's run;and a perform method, which does the actual workwhen the intent is executed.Our starting point today is this Library app.Since I'm a huge bookworm,it's all about tracking books I've read,want to read, or am currently reading.Each category is shown in separate tab of the appthat I call a Shelf.My users visit the Currently Reading shelfall the time,so I'm going expose an app intentto make opening it quicker and more convenient.I'll create an OpenCurrentlyReading intent hereby defining a Swift structthat conforms to the AppIntent protocol.I need to implement only one method, called perform.In my app, I've already got a navigator that can open tabs,so implementing the intent for meis only a few lines of code.I'll annotate the perform method with @MainActor,since my Navigator expects the main thread.My intent also needs a title.Like all the other strings I'll be showing you today,this will get localized automaticallyif I add the key to my strings files.This is all I need to do to get a basic app intent working.Now that it's defined in my code,it will automatically appear in the Shortcuts editor,where my user can add it to a shortcut.Just exposing this intent provides huge leverage,because once customers turn this intent into a shortcut,it can be used from a ton of places in the system,including all of these.To make my new intent easy to use and discover,I'll also add support for App Shortcuts.With a little bit of code,I can make my intent show up automatically in Spotlightand the Shortcuts app,and I can define a phrase that people can say to Sirito use this intent with their voice.Check out the "Implement App Shortcuts with App Intents"session to get all the details.So far, I've exposed an intentto open the Currently Reading shelf.Next, let's generalize it,adding a parameter so it can open any of the shelves.I have an enum that represents shelves.In order for it to be used as an intent parameter,I need to conform it to the AppEnum protocol.AppEnum requires a String raw value,so I'll add that first.It also requires that I provide localizable,human-readable titles for each of my enum cases.These must be provided as a dictionary literal,since the compiler will read this code at build time.Finally, I'll add a typeDisplayName:a user-visible, localizable namefor this enum type as a whole.I'll use "Shelf."In an intent, each parameter is declaredusing an @Parameter property wrapper,which is initialized with information about the parameter,like the title.Here, I define a new shelf parameter,which I read in my perform method.Parameters support all of these types,including numbers, strings, files, and more,as well as entities and enums from your app.Here's how this intent looks in the Shortcuts editor.Note that the shelf parameter appears in a table row.I can make the UI more streamlined,and make it fit better into Shortcuts,by using the ParameterSummary API.The Parameter Summary is a sentencethat represents your intent and its parametersin the editor, like "Open ."For best results in Shortcuts,you should always provide a Parameter Summaryfor every intent you create.You can also define which parametersshow up below the fold and which are hidden.These APIs can do some pretty cool stuff,like varying the summary based on the actual valuesof any parameter of your intent,using the When and Otherwise APIs,or the Switch, Case, and Default APIs.To add a parameter summary,I implement this static property.Here I'll return the string "Open",and interpolate the shelf parameter.The last thing I need to do to get Open Shelf workingis make sure that the intent opens the Library appwhen it's run, like this.Opening the app by is controlled by the static property,openAppWhenRun.It defaults to false, which is great for most intents.But for intents that open something in the UIlike this one, I'll need to set it to true.I just created an intent to open shelves.This is super simple because the set of shelves is fixed.But what if I wanted to build an intent that opens Books,the set of which is dynamic, not fixed?For that, I'll need entities.An entity is a concept that your app exposes to App Intents.You should use an entity instead of an enumwhen the values are dynamic, or user-defined,like a note in Notes or a photo or album in Photos.To provide instances of entities,your app can implement queries,and return entities as results from intents.I'll start by making an intent to open a book in the app.In the Shortcuts editor, it should look like this.When people tap on the Book parameter,they'll get a picker to choose a book,including a set of suggested entitiesthat my app has provided.They can also find any book in their librarywith this search field at the top of the picker.Before I build the intent itself,I'll need to create a book entityand the corresponding query.An entity contains at least three things:an identifier, a display representation,and an entity type name.To add an entity, start by conforming a structto the AppEntity protocol.Here, I'll define a new struct for the BookEntity,but I could also conform an existing type from my model.You provide an identifier by conforming your entityto the Identifiable protocol.App Intents uses this identifier to refer to your entityas it's passed between your app and other parts of the system.The identifier should be stable and persistent,since it might be saved in a shortcutcreated by your customers.The display representation is usedto show this entity to the user.This can be as simple as a string of text,like a book title.You could also provide a subtitle and an image.The typeDisplayName is a human-readable stringrepresenting the type of an entity.In this example, it's "Book."Now, to round out the book entity,I need to add a query.A query gives the system an interfacefor retrieving entities from your app.Queries can look up entities in a few ways.All queries need to be able to look up entitiesbased on an identifier.String queries support search.And later, you'll run into property queries,which are more flexible.All queries can also provide suggested entities,which allow the users to pick from a list.Every entity should be associated with a queryso the system can look up instances of that entity.You provide a query by making a Swift structthat conforms to the EntityQuery protocol.The basic query has only one required method,which you implement to resolve entitiesgiven an array of identifiers.I've implemented this by going to my model databaseand finding any books matching those identifiers.Now, I need to hook up the query to the entity.I do this by implementing the defaultQuery static propertyon the BookEntity typeand returning an instance of my BookQuery.When the user picks a book,its identifier will be saved into the shortcut.When the shortcut is run,App Intents will pass the identifier to my queryto retrieve the BookEntity instance.Now that the BookEntity typeconforms to the AppEntity protocol,I can use it as a parameter in my OpenBook intent.The perform method uses my Navigatorto navigate to the book.In order to support the book picker,my query also needs to provide suggested results.To do that, I need to implement one more method on query,returning all the books added to my Library app.Shortcuts will fill the picker with these results.Notice that the Shortcuts UI has a search field on top.My app could have a lot of book entities,so I should really run the search in my app process,against my database directly.The StringQuery API lets me do that.Adopting the StringQuery subprotocol gives meone more method to implement,called entities (matching string:),to return results given a string.Here, I've implemented it as a simple case-insensitive matchagainst the title of the book,but I could have done fancier stufflike searching through the author or series name,for example.If I have a huge list of books, and a smaller list of favorites,I could return just the favorites in suggestedEntities,and rely on entities (matching string:)to allow my users to search across the longer list.Now I've exposed a way to open books in my app,and built a book entity and book query in the process.I can use the same entity and query to create more intents.My next task is to build an intentto add books to the library.Customers can quickly add books while browsing onlineusing a share sheet shortcut,or they can tell Siri on HomePod to add a bookwithout even looking at a screen.Building intents like this that manipulate your model directlywithout showing your UI can really empower your users.Here's the implementation of my AddBook intent,taking as parameters the title of the bookand an optional name of the author.It also includes an optional noteto record which friend recommended the book.The perform method will add the book to the libraryby looking it up with an API call using async/await.It will throw an error if it can't find a match.To localize this error, I conform my error type tothe CustomLocalizedString ResourceConvertible protocol.I'll return a localized string key from this property,and add the key to my strings files.This Add Book intent is incredibly useful as is,with Siri, widgets, and more.But it gets even more flexibleif it can be combined with other intents.With a little bit of work,I can allow combining my Add Book intentwith the Open Book intent I built earlier,passing the result from one to the other.To do so, I'll have the Add Book intentreturn a value as part of its result.Notice that my perform method's return typehas picked up a new protocolto represent the value I'm returning.Now, users can connect the result value of this intentto other intents that take a book entity as a parameter.The Add Book intent and the Open Book intentpair quite naturally together,so you can make a shortcut that adds a bookand then immediately opens it in the library.It's a common pattern to return a result from an intentand open it in the app.App intents have a built-in way to express thiscalled the openIntent.If I add an openIntent, customers will geta new switch in Shortcuts called "Open When Run."If they turn the switch off,they'll be able to use this intentas part of a shortcut in the background without interruption.If they leave the switch on, the newly added bookwill be immediately opened in my Library app.Adopting openIntent is as easyas creating an instance of the Open Book intentand returning it as part of the result.When this intent is run,if the Open When Run switch is on,the Open Book intent will automatically be performedafter the Add Book intent finishes.There's a lot more you can do with entities and queries.With the next set of APIs,AppIntents opens up some powerful abilitiesyou never had before with the SiriKit Intents framework.Let's take a look at how you can expose more informationfrom your entities,and allow customers to find and filter based on that.So far, I've added all the basic requirementsto my book entity.But to let people integrate booksmore deeply into their shortcuts,I'm going to need to expose a bit more about my books.Entities support properties,which hold additional information on the entitythat you want to expose to users.In this case, I'll add the book's author,publishing date, read date, and who recommended it,so that people can use those properties in their shortcuts.I add properties to my BookEntityusing a property wrapper called @Property.Properties support all the same types that parameters do,and each one takes a localized title.With these new properties,my customers can now use magic variables in Shortcutsto pull out each new piece of informationwhen working with a book entityWhen using the earlier Add Book intent,they can use the author or publishing dateof a newly added book in their shortcuts.When you combine properties with queries,your app automatically gets these incredibly powerfulFind and Filter actions in Shortcuts,with this flexible predicate editor UI.Now, my customers will be able to find and filter booksbased on date read, title, author, and more.It's a piece of cake to findall the books by Delia Owens, for example.Using the Sort by and Limit options,you can support even more advanced queries,like find the three most recently published booksby Delia Owens.A customer can use these building blocksto do some pretty cool stuff, like findingthe three most common authors in their collection.To enable all this,I'll need to adopt another kind of querycalled a property query.Property queries find entities not based on a string,or an identifier, but on the properties within the entity.There are three steps to implementing property queries.First, you declare query properties,which specify how your entity can be searchedusing its properties.Then, you add sorting options,which define how query results can be sorted.And finally, you implement entities(matching:)to run the search.The query propertiesdeclare every way AppIntents can searchon the entity associated with this query.Each one lists a property of my entity,and the comparison operators --like contains, equal to, or less than --that are available for it.Here, I list "less than" and "greater than" comparatorsfor my date properties,and "contains" and "equal to" for my title property.Query properties map each combinationof property and comparator into a type of your choice,called the comparator mapping type.Here, I am using CoreData, so I'll use an NSPredicate.If I was using a custom database or a REST API,I could design my own comparator typeand use that instead.Here's the code to set up the query properties for my books.I conform BooksQuery to the EntityPropertyQuery protocol.Then I implement static var propertiesusing the QueryProperties result builder.Each entry specifies a keyPath of a Propertythat can be queried, and within it,each comparator that is applicable to that property.For each comparator, I provide an NSPredicate,because I've chosen NSPredicate as my comparator mapping type.When the system asks my app to return results for the query,it will provide back the NSPredicatesthat I'm constructing here.There's a similar definition for sorting.This is a list of all the propertiesmy model can sort books by.In this case, I allow sorting by title,date read, and date published.Finally, I implement entities(matching:),which queries my database and returns matching entities.This method takes an array of the comparator mapping typeI used in the previously defined query parameters --in this case, NSPredicate.These predicates are describing what criteriaon the properties of my entity I want to query by.It also takes a mode,indicating whether to combine the predicateswith "and" or with "or," key paths to sort by,and an optional limit for the number of results.My implementation uses these parametersto perform a query against my CoreData database.What can customers do with this property query?They can pick a random book from their library to read.They can find all their bookspublished in the early part of the twentieth century.They can leverage the Shortcuts ecosystemand make my app more useful by connecting it to others.For example, they can use a spreadsheet appto export all the books they read this year to a CSV file.Or, they can use a graphing app to make a chartof how many books they've read every year over the last 10.And that's just the beginning.This kind of deep App Intents adoptionreally lets customers use your appto do what they need it to do,making it a critical part of their workflow.Each of these integrations --like making graphs, for example --is a feature you don't have to build.When your intents are performed,your app may need to interact with the userto show or speak a result, or to resolve ambiguity,whether it's a Siri request or a shortcut.App Intents supports a number of these interactions:dialog for giving text and voice feedbackto your users when an intent has completed,and snippets for giving visual feedback.Request value and disambiguationfor asking the user to clarify values for intent parameters,and confirmation for verifying parameter valuesor checking with the useron intents that are transactional or destructive.Dialog provides a spoken or textual responseto the person running an intent.It's really important to provide dialogfor intents to work well in a voice experience.In my Add Book intent from earlier,I'll add a needsValueDialogthat's spoken when asking for a book titleand a result dialog returned from my perform method.These will be read or shown by Shortcuts or Siriacross our many platforms.You can think of snippets as the visual equivalent of dialog,letting you add a visual representationto the result of your intent.To use a snippet, just add the SwiftUI view of your choiceas a trailing closure to your intent result.Like with a widget, your SwiftUI view will be archivedand sent over to Shortcuts or Siri.App Intents also supports asking the user for a valueby throwing requestValue.For example, this comes in handy when you need a valuefor a parameter that is sometimes optional.Here, requestValue helps me when my string searchreturns more than one book.In this case, I prompt and ask for an authorto narrow the book search down.requestValue gives me an error I can throw,which will prompt the user,and rerun the action with the updated author name.Disambiguation, meanwhile,is great when you need the user to choosebetween a set of values for a parameter.This gives me an even better way to handlemultiple possible results in my Add Book action.Here, I get a list of author names from the generated books,and request disambiguation with those possible values.The user will be asked to pick between them,and I'll get the result back.Lastly, App Intents supports two different kinds of confirmation.The first kind is confirmation of a parameter value.You might use this when you have a guessat what that value should be but you want to confirm,just to make sure.When adding a book,sometimes the web service I call to look up books by titlereturns a couple matches,but one of them is by far the more popular.In these cases, I'm going to assumethat the user meant to add that popular book,but I'll add confirmation to make sure I got it right.To do that, I'll call requestConfirmationon the title parameter.The second kind is a confirmationof the result of an intent.This is great for placing orders, for example.If I wanted to monetize my Library appand add ordering through a bookstore,I'd want to make sure that I have the order right.To do this, I could call requestConfirmationon my intent, passing in the order to be placed.I'll specify a snippet here too, showing a preview of the order.I prefix the call with "try" because requestConfirmationwill throw an error if the user cancelsinstead of confirming.Before I leave you, there are a couple aspectsof the App Intents architecture I want to cover,which you should know as you adopt the framework.There are actually two ways to build your App Intents:within your app or in a separate extension.Of these, implementing intents directly in your appis the simplest.This is great because you don't need a frameworkor to duplicate your code,and you don't need to coordinate across processes.Using your app also gives some higher memory limits,and it gives you the ability to do some kinds of workthat are harder from an extension,like playing audio.Your app can be run in the foregroundif you implement openAppWhenRun on your intent to return true.Otherwise, it will be run in the background.When running in the background,your app will launch in a special modewithout scenes being brought up to maximize performance.In fact, if you implement background app intentsin your app,we strongly encourage you to also implement scene support.Or, you can build your app intents in an extension.This has a couple advantages.It's lighter weight,because the extension process only handles app intentsand doesn't require spinning up your app.If you are handling Focus intents,using an extension also means that you'll immediatelyget intents performed on your extensionwhen Focus changes, without the requirementthat your app is running in the foreground first.An extension is a bit more work,since you'll need to add a new target,move some code into a framework,and handle coordination between your appand the extension.To create an App Intents extension,go to File > New Target in Xcodeand choose App Intents Extension.With App Intents, your code is the only source of truth.App Intents achieves this elegant developer experienceby statically extracting information about your intents,entities, queries, and parameters at build time.Xcode will generate a metadata file inside your appor extension bundle during your build process,containing information received from the Swift compileras it runs on your code.To make sure all of this works, keep your App Intents typesdirectly in the target or extension, not in a framework.Similarly, your localized stringsshould be found in a strings filewithin the same bundle where your App Intents types live.For those of you who have existing appswith SiriKit Intents that you want to upgrade,if you adopt intents to integrate with widgets,or domains like messaging or media,you should keep using the SiriKit Intents framework.But if you add custom intents for Siri and Shortcuts,you should go ahead and upgrade to App Intents.You can start the upgrade process by clickingthe Convert to App Intent buttonin your SiriKit Intents definition file.Integrating your app into Shortcuts with App Intentsis a great way to maximize your leverage as a developer,because by doing a small amount of work to adopt App Intents,you create a large amount of value for customers.Thank you for joining!I really hope that you'll try out App Intents todayand give us your feedback.I'm excited about how this new frameworkcan help you surprise, delight, and empower folksusing your apps!Happy reading and hope your WWDC is epic!♪

♪ Mellow instrumental hip-hop music ♪♪Hi, folks. My name is Michael Gorbachfrom Shortcuts Engineering.Thanks for tuning in for this deep dive into App Intents,our new frameworkfor exposing your app's functionality to the system.Here's the plan for our dive.After a quick introduction,I'll talk about intents and their parameters,and how to define entities.I'll go over some powerful finding and filtering featuresyou can build,and how your intents can interact with the user.Lastly, I'll cover App Intents architecture and lifecycle.Let's start at the beginning.In iOS 10, we introduced the SiriKit Intents framework,which lets you hook up your app's functionalityto Siri domains like messaging, workouts, and payments.Now we're introducing a new frameworkcalled App Intents.It has three key components.Intents are actions built into your appthat can be used throughout the system.Intents use entities to represent your app's concepts.App Shortcuts wrap your intentsto make them automatic and discoverable.Let's talk about a couple of the waysthat App Intents can make your app's functionality availablein more places, and benefit your customers.With App Shortcuts, everyone can useyour app's features with their voice through Siri,without needing to set anything up first.The same adoption also makes your intents appear in Spotlightwhen people search for your app and when your app's suggested.This will put your work front and center.Using App Intents, you can also build Focus Filters,letting customers customize your app for a specific Focus.For example, they might set up their Calendar appto only show their work calendar while they're actually at work.Check out this session to learn more abouthow to adopt Focus Filters.With App Shortcuts,your intents show up in the Shortcuts app automatically,without needing to be added manually.Integrating your actions into Shortcutsis incredibly valuable for customersbecause they can run shortcuts,and take advantage of your app's features,from so many places throughout the system.They can run shortcuts with a single tap on the Home Screen,from the menu bar on macOS, and in many other ways.They can even set shortcuts up to run automaticallywith automations.Supporting shortcuts multiplies the powerand capability of your app by connecting itto the entire Shortcuts ecosystem,harnessing the power of an array of apps from Appleand other developers.That's because a shortcut can combine actionsfrom multiple apps,letting users invent entirely new features and capabilitieswithout you needing to do any work.If you want to learn how to make your actionswork well with others and fit seamlessly into this ecosystem,check out our design talk.Our goal in building App Intentswas to make it a joy to develop for.App Intents is concise.Writing a simple intent can take only a few lines of code,but the API also scalesto deeper and more customizable actions.App Intents is modern.We've gone all in on Swift,leveraging result builders, property wrappers,protocol-oriented programming, and generics.These APIs just couldn't existwithout cutting-edge language features.Adopting App Intents is also easy,because it doesn't require re-architectingyour products and targets or creating a framework.It doesn't require an extensionand can be adopted right in your app.And App Intents code is maintainable.Like SwiftUI, App Intents uses your codeas the fundamental source of truth,avoiding the need for separate editors or definition files.This lets you rapidly build and iterate on your adoption,and simplifies maintenancebecause everything lives in one place.With that said, let's explore these new APIs,starting with the intent,the central building block of our new framework.An app intent -- or "intent" for short --is a single, isolated unit of functionalitythat your app exposes to the system.For example, an intent could make a new calendar event,open a particular screen, or place an order.An intent can be run by the user on request --like by running a shortcut or asking Siri --or automatically --like using Focus filters or a Shortcuts automation.When an intent is run,it will either return a result or throw an error.An intent includes three key pieces:metadata, or information about the intent,including a localized title;parameters, which are inputs that the intent can usewhen it's run;and a perform method, which does the actual workwhen the intent is executed.Our starting point today is this Library app.Since I'm a huge bookworm,it's all about tracking books I've read,want to read, or am currently reading.Each category is shown in separate tab of the appthat I call a Shelf.My users visit the Currently Reading shelfall the time,so I'm going expose an app intentto make opening it quicker and more convenient.I'll create an OpenCurrentlyReading intent hereby defining a Swift structthat conforms to the AppIntent protocol.I need to implement only one method, called perform.In my app, I've already got a navigator that can open tabs,so implementing the intent for meis only a few lines of code.I'll annotate the perform method with @MainActor,since my Navigator expects the main thread.My intent also needs a title.Like all the other strings I'll be showing you today,this will get localized automaticallyif I add the key to my strings files.This is all I need to do to get a basic app intent working.Now that it's defined in my code,it will automatically appear in the Shortcuts editor,where my user can add it to a shortcut.Just exposing this intent provides huge leverage,because once customers turn this intent into a shortcut,it can be used from a ton of places in the system,including all of these.To make my new intent easy to use and discover,I'll also add support for App Shortcuts.With a little bit of code,I can make my intent show up automatically in Spotlightand the Shortcuts app,and I can define a phrase that people can say to Sirito use this intent with their voice.Check out the "Implement App Shortcuts with App Intents"session to get all the details.So far, I've exposed an intentto open the Currently Reading shelf.Next, let's generalize it,adding a parameter so it can open any of the shelves.I have an enum that represents shelves.In order for it to be used as an intent parameter,I need to conform it to the AppEnum protocol.AppEnum requires a String raw value,so I'll add that first.It also requires that I provide localizable,human-readable titles for each of my enum cases.These must be provided as a dictionary literal,since the compiler will read this code at build time.Finally, I'll add a typeDisplayName:a user-visible, localizable namefor this enum type as a whole.I'll use "Shelf."In an intent, each parameter is declaredusing an @Parameter property wrapper,which is initialized with information about the parameter,like the title.Here, I define a new shelf parameter,which I read in my perform method.Parameters support all of these types,including numbers, strings, files, and more,as well as entities and enums from your app.Here's how this intent looks in the Shortcuts editor.Note that the shelf parameter appears in a table row.I can make the UI more streamlined,and make it fit better into Shortcuts,by using the ParameterSummary API.The Parameter Summary is a sentencethat represents your intent and its parametersin the editor, like "Open ."For best results in Shortcuts,you should always provide a Parameter Summaryfor every intent you create.You can also define which parametersshow up below the fold and which are hidden.These APIs can do some pretty cool stuff,like varying the summary based on the actual valuesof any parameter of your intent,using the When and Otherwise APIs,or the Switch, Case, and Default APIs.To add a parameter summary,I implement this static property.Here I'll return the string "Open",and interpolate the shelf parameter.The last thing I need to do to get Open Shelf workingis make sure that the intent opens the Library appwhen it's run, like this.Opening the app by is controlled by the static property,openAppWhenRun.It defaults to false, which is great for most intents.But for intents that open something in the UIlike this one, I'll need to set it to true.I just created an intent to open shelves.This is super simple because the set of shelves is fixed.But what if I wanted to build an intent that opens Books,the set of which is dynamic, not fixed?For that, I'll need entities.An entity is a concept that your app exposes to App Intents.You should use an entity instead of an enumwhen the values are dynamic, or user-defined,like a note in Notes or a photo or album in Photos.To provide instances of entities,your app can implement queries,and return entities as results from intents.I'll start by making an intent to open a book in the app.In the Shortcuts editor, it should look like this.When people tap on the Book parameter,they'll get a picker to choose a book,including a set of suggested entitiesthat my app has provided.They can also find any book in their librarywith this search field at the top of the picker.Before I build the intent itself,I'll need to create a book entityand the corresponding query.An entity contains at least three things:an identifier, a display representation,and an entity type name.To add an entity, start by conforming a structto the AppEntity protocol.Here, I'll define a new struct for the BookEntity,but I could also conform an existing type from my model.You provide an identifier by conforming your entityto the Identifiable protocol.App Intents uses this identifier to refer to your entityas it's passed between your app and other parts of the system.The identifier should be stable and persistent,since it might be saved in a shortcutcreated by your customers.The display representation is usedto show this entity to the user.This can be as simple as a string of text,like a book title.You could also provide a subtitle and an image.The typeDisplayName is a human-readable stringrepresenting the type of an entity.In this example, it's "Book."Now, to round out the book entity,I need to add a query.A query gives the system an interfacefor retrieving entities from your app.Queries can look up entities in a few ways.All queries need to be able to look up entitiesbased on an identifier.String queries support search.And later, you'll run into property queries,which are more flexible.All queries can also provide suggested entities,which allow the users to pick from a list.Every entity should be associated with a queryso the system can look up instances of that entity.You provide a query by making a Swift structthat conforms to the EntityQuery protocol.The basic query has only one required method,which you implement to resolve entitiesgiven an array of identifiers.I've implemented this by going to my model databaseand finding any books matching those identifiers.Now, I need to hook up the query to the entity.I do this by implementing the defaultQuery static propertyon the BookEntity typeand returning an instance of my BookQuery.When the user picks a book,its identifier will be saved into the shortcut.When the shortcut is run,App Intents will pass the identifier to my queryto retrieve the BookEntity instance.Now that the BookEntity typeconforms to the AppEntity protocol,I can use it as a parameter in my OpenBook intent.The perform method uses my Navigatorto navigate to the book.

In order to support the book picker,my query also needs to provide suggested results.To do that, I need to implement one more method on query,returning all the books added to my Library app.Shortcuts will fill the picker with these results.Notice that the Shortcuts UI has a search field on top.My app could have a lot of book entities,so I should really run the search in my app process,against my database directly.The StringQuery API lets me do that.Adopting the StringQuery subprotocol gives meone more method to implement,called entities (matching string:),to return results given a string.Here, I've implemented it as a simple case-insensitive matchagainst the title of the book,but I could have done fancier stufflike searching through the author or series name,for example.If I have a huge list of books, and a smaller list of favorites,I could return just the favorites in suggestedEntities,and rely on entities (matching string:)to allow my users to search across the longer list.Now I've exposed a way to open books in my app,and built a book entity and book query in the process.I can use the same entity and query to create more intents.My next task is to build an intentto add books to the library.Customers can quickly add books while browsing onlineusing a share sheet shortcut,or they can tell Siri on HomePod to add a bookwithout even looking at a screen.Building intents like this that manipulate your model directlywithout showing your UI can really empower your users.Here's the implementation of my AddBook intent,taking as parameters the title of the bookand an optional name of the author.It also includes an optional noteto record which friend recommended the book.The perform method will add the book to the libraryby looking it up with an API call using async/await.It will throw an error if it can't find a match.To localize this error, I conform my error type tothe CustomLocalizedString ResourceConvertible protocol.I'll return a localized string key from this property,and add the key to my strings files.This Add Book intent is incredibly useful as is,with Siri, widgets, and more.But it gets even more flexibleif it can be combined with other intents.With a little bit of work,I can allow combining my Add Book intentwith the Open Book intent I built earlier,passing the result from one to the other.To do so, I'll have the Add Book intentreturn a value as part of its result.Notice that my perform method's return typehas picked up a new protocolto represent the value I'm returning.Now, users can connect the result value of this intentto other intents that take a book entity as a parameter.The Add Book intent and the Open Book intentpair quite naturally together,so you can make a shortcut that adds a bookand then immediately opens it in the library.It's a common pattern to return a result from an intentand open it in the app.App intents have a built-in way to express thiscalled the openIntent.If I add an openIntent, customers will geta new switch in Shortcuts called "Open When Run."If they turn the switch off,they'll be able to use this intentas part of a shortcut in the background without interruption.If they leave the switch on, the newly added bookwill be immediately opened in my Library app.Adopting openIntent is as easyas creating an instance of the Open Book intentand returning it as part of the result.When this intent is run,if the Open When Run switch is on,the Open Book intent will automatically be performedafter the Add Book intent finishes.There's a lot more you can do with entities and queries.With the next set of APIs,AppIntents opens up some powerful abilitiesyou never had before with the SiriKit Intents framework.Let's take a look at how you can expose more informationfrom your entities,and allow customers to find and filter based on that.So far, I've added all the basic requirementsto my book entity.But to let people integrate booksmore deeply into their shortcuts,I'm going to need to expose a bit more about my books.Entities support properties,which hold additional information on the entitythat you want to expose to users.In this case, I'll add the book's author,publishing date, read date, and who recommended it,so that people can use those properties in their shortcuts.I add properties to my BookEntityusing a property wrapper called @Property.Properties support all the same types that parameters do,and each one takes a localized title.With these new properties,my customers can now use magic variables in Shortcutsto pull out each new piece of informationwhen working with a book entityWhen using the earlier Add Book intent,they can use the author or publishing dateof a newly added book in their shortcuts.

When you combine properties with queries,your app automatically gets these incredibly powerfulFind and Filter actions in Shortcuts,with this flexible predicate editor UI.Now, my customers will be able to find and filter booksbased on date read, title, author, and more.It's a piece of cake to findall the books by Delia Owens, for example.Using the Sort by and Limit options,you can support even more advanced queries,like find the three most recently published booksby Delia Owens.A customer can use these building blocksto do some pretty cool stuff, like findingthe three most common authors in their collection.To enable all this,I'll need to adopt another kind of querycalled a property query.Property queries find entities not based on a string,or an identifier, but on the properties within the entity.There are three steps to implementing property queries.First, you declare query properties,which specify how your entity can be searchedusing its properties.Then, you add sorting options,which define how query results can be sorted.And finally, you implement entities(matching:)to run the search.The query propertiesdeclare every way AppIntents can searchon the entity associated with this query.Each one lists a property of my entity,and the comparison operators --like contains, equal to, or less than --that are available for it.Here, I list "less than" and "greater than" comparatorsfor my date properties,and "contains" and "equal to" for my title property.Query properties map each combinationof property and comparator into a type of your choice,called the comparator mapping type.Here, I am using CoreData, so I'll use an NSPredicate.If I was using a custom database or a REST API,I could design my own comparator typeand use that instead.Here's the code to set up the query properties for my books.I conform BooksQuery to the EntityPropertyQuery protocol.Then I implement static var propertiesusing the QueryProperties result builder.Each entry specifies a keyPath of a Propertythat can be queried, and within it,each comparator that is applicable to that property.For each comparator, I provide an NSPredicate,because I've chosen NSPredicate as my comparator mapping type.When the system asks my app to return results for the query,it will provide back the NSPredicatesthat I'm constructing here.There's a similar definition for sorting.This is a list of all the propertiesmy model can sort books by.In this case, I allow sorting by title,date read, and date published.Finally, I implement entities(matching:),which queries my database and returns matching entities.This method takes an array of the comparator mapping typeI used in the previously defined query parameters --in this case, NSPredicate.These predicates are describing what criteriaon the properties of my entity I want to query by.It also takes a mode,indicating whether to combine the predicateswith "and" or with "or," key paths to sort by,and an optional limit for the number of results.My implementation uses these parametersto perform a query against my CoreData database.What can customers do with this property query?They can pick a random book from their library to read.They can find all their bookspublished in the early part of the twentieth century.They can leverage the Shortcuts ecosystemand make my app more useful by connecting it to others.For example, they can use a spreadsheet appto export all the books they read this year to a CSV file.Or, they can use a graphing app to make a chartof how many books they've read every year over the last 10.And that's just the beginning.This kind of deep App Intents adoptionreally lets customers use your appto do what they need it to do,making it a critical part of their workflow.Each of these integrations --like making graphs, for example --is a feature you don't have to build.When your intents are performed,your app may need to interact with the userto show or speak a result, or to resolve ambiguity,whether it's a Siri request or a shortcut.App Intents supports a number of these interactions:dialog for giving text and voice feedbackto your users when an intent has completed,and snippets for giving visual feedback.Request value and disambiguationfor asking the user to clarify values for intent parameters,and confirmation for verifying parameter valuesor checking with the useron intents that are transactional or destructive.Dialog provides a spoken or textual responseto the person running an intent.It's really important to provide dialogfor intents to work well in a voice experience.In my Add Book intent from earlier,I'll add a needsValueDialogthat's spoken when asking for a book titleand a result dialog returned from my perform method.These will be read or shown by Shortcuts or Siriacross our many platforms.You can think of snippets as the visual equivalent of dialog,letting you add a visual representationto the result of your intent.To use a snippet, just add the SwiftUI view of your choiceas a trailing closure to your intent result.Like with a widget, your SwiftUI view will be archivedand sent over to Shortcuts or Siri.App Intents also supports asking the user for a valueby throwing requestValue.For example, this comes in handy when you need a valuefor a parameter that is sometimes optional.Here, requestValue helps me when my string searchreturns more than one book.In this case, I prompt and ask for an authorto narrow the book search down.requestValue gives me an error I can throw,which will prompt the user,and rerun the action with the updated author name.Disambiguation, meanwhile,is great when you need the user to choosebetween a set of values for a parameter.This gives me an even better way to handlemultiple possible results in my Add Book action.Here, I get a list of author names from the generated books,and request disambiguation with those possible values.The user will be asked to pick between them,and I'll get the result back.Lastly, App Intents supports two different kinds of confirmation.The first kind is confirmation of a parameter value.You might use this when you have a guessat what that value should be but you want to confirm,just to make sure.When adding a book,sometimes the web service I call to look up books by titlereturns a couple matches,but one of them is by far the more popular.In these cases, I'm going to assumethat the user meant to add that popular book,but I'll add confirmation to make sure I got it right.To do that, I'll call requestConfirmationon the title parameter.The second kind is a confirmationof the result of an intent.This is great for placing orders, for example.If I wanted to monetize my Library appand add ordering through a bookstore,I'd want to make sure that I have the order right.To do this, I could call requestConfirmationon my intent, passing in the order to be placed.I'll specify a snippet here too, showing a preview of the order.I prefix the call with "try" because requestConfirmationwill throw an error if the user cancelsinstead of confirming.Before I leave you, there are a couple aspectsof the App Intents architecture I want to cover,which you should know as you adopt the framework.There are actually two ways to build your App Intents:within your app or in a separate extension.Of these, implementing intents directly in your appis the simplest.This is great because you don't need a frameworkor to duplicate your code,and you don't need to coordinate across processes.Using your app also gives some higher memory limits,and it gives you the ability to do some kinds of workthat are harder from an extension,like playing audio.Your app can be run in the foregroundif you implement openAppWhenRun on your intent to return true.Otherwise, it will be run in the background.When running in the background,your app will launch in a special modewithout scenes being brought up to maximize performance.In fact, if you implement background app intentsin your app,we strongly encourage you to also implement scene support.Or, you can build your app intents in an extension.This has a couple advantages.It's lighter weight,because the extension process only handles app intentsand doesn't require spinning up your app.If you are handling Focus intents,using an extension also means that you'll immediatelyget intents performed on your extensionwhen Focus changes, without the requirementthat your app is running in the foreground first.An extension is a bit more work,since you'll need to add a new target,move some code into a framework,and handle coordination between your appand the extension.To create an App Intents extension,go to File > New Target in Xcodeand choose App Intents Extension.With App Intents, your code is the only source of truth.App Intents achieves this elegant developer experienceby statically extracting information about your intents,entities, queries, and parameters at build time.Xcode will generate a metadata file inside your appor extension bundle during your build process,containing information received from the Swift compileras it runs on your code.To make sure all of this works, keep your App Intents typesdirectly in the target or extension, not in a framework.Similarly, your localized stringsshould be found in a strings filewithin the same bundle where your App Intents types live.For those of you who have existing appswith SiriKit Intents that you want to upgrade,if you adopt intents to integrate with widgets,or domains like messaging or media,you should keep using the SiriKit Intents framework.But if you add custom intents for Siri and Shortcuts,you should go ahead and upgrade to App Intents.You can start the upgrade process by clickingthe Convert to App Intent buttonin your SiriKit Intents definition file.Integrating your app into Shortcuts with App Intentsis a great way to maximize your leverage as a developer,because by doing a small amount of work to adopt App Intents,you create a large amount of value for customers.Thank you for joining!I really hope that you'll try out App Intents todayand give us your feedback.I'm excited about how this new frameworkcan help you surprise, delight, and empower folksusing your apps!Happy reading and hope your WWDC is epic!♪

5:33 -Open Currently Reading

6:42 -App Shortcuts

7:11 -Shelf Enum

7:49 -Open Shelf

10:56 -Book Entity

12:29 -Book Query

13:16 -Open Book

13:40 -Suggested Entities and String Book Query

15:11 -Add Book Intent

18:21 -Book Entity with Properties

20:59 -Books Property Query

24:10 -Dialog

24:25 -Snippet

24:50 -Request Value

25:22 -Request Disambiguation

25:48 -Request Parameter Confirmation

26:26 -Request Result Confirmation

## Code Samples

```swift
struct
 
OpenCurrentlyReading
: 
AppIntent
 {
    
static
 
var
 title: 
LocalizedStringResource
 
=
 
"Open Currently Reading"


    
@MainActor

    
func
 
perform
() 
async
 
throws
 -> 
some
 
IntentResult
 {
        
Navigator
.shared.openShelf(.currentlyReading)
        
return
 .result()
    }
  
    
static
 
var
 openAppWhenRun: 
Bool
 
=
 
true

}
```

```swift
struct
 
LibraryAppShortcuts
: 
AppShortcutsProvider
 {
    
static
 
var
 appShortcuts: [
AppShortcut
] {
        
AppShortcut
(
            intent: 
OpenCurrentlyReading
(),
            phrases: [
"Open Currently Reading in 
\(.applicationName)
"
],
            systemImageName: 
"books.vertical.fill"

        )
    }
}
```

```swift
enum
 
Shelf
: 
String
 {
    
case
 currentlyReading
    
case
 wantToRead
    
case
 read
}


extension
 
Shelf
: 
AppEnum
 {
    
static
 
var
 typeDisplayRepresentation: 
TypeDisplayRepresentation
 
=
 
"Shelf"


    
static
 
var
 caseDisplayRepresentations: [
Shelf
: 
DisplayRepresentation
] 
=
 [
        .currentlyReading: 
"Currently Reading"
,
        .wantToRead: 
"Want to Read"
,
        .read: 
"Read"
,
    ]
}
```

```swift
struct
 
OpenShelf
: 
AppIntent
 {
    
static
 
var
 title: 
LocalizedStringResource
 
=
 
"Open Shelf"


    
@Parameter
(title: 
"Shelf"
)
    
var
 shelf: 
Shelf


    
@MainActor

    
func
 
perform
() 
async
 
throws
 -> 
some
 
IntentResult
 {
        
Navigator
.shared.openShelf(shelf)
        
return
 .result()
    }

    
static
 
var
 parameterSummary: 
some
 
ParameterSummary
 {
        
Summary
(
"Open 
\(\.
$shelf
)
"
)
    }

    
static
 
var
 openAppWhenRun: 
Bool
 
=
 
true

}
```

```swift
struct
 
BookEntity
: 
AppEntity
, 
Identifiable
 {
    
var
 id: 
UUID


    
var
 displayRepresentation: 
DisplayRepresentation
 { 
"
\(title)
"
 }

    
static
 
var
 typeDisplayRepresentation: 
TypeDisplayRepresentation
 
=
 
"Book"


    
static
 
var
 defaultQuery 
=
 
BookQuery
()
}
```

```swift
struct
 
BookQuery
: 
EntityQuery
 {
    
func
 
entities
(
for
 
identifiers
: [
UUID
]) 
async
 
throws
 -> [
BookEntity
] {
        identifiers.compactMap { identifier 
in

            
Database
.shared.book(for: identifier)
        }
    }
}
```

```swift
struct
 
OpenBook
: 
AppIntent
 {
    
@Parameter
(title: 
"Book"
)
    
var
 book: 
BookEntity


    
static
 
var
 title: 
LocalizedStringResource
 
=
 
"Open Book"


    
static
 
var
 openAppWhenRun 
=
 
true


    
@MainActor

    
func
 
perform
() 
async
 
throws
 -> 
some
 
IntentResult
 {
        
guard
 
try
 
await
 
$book
.requestConfirmation(for: book, dialog: 
"Are you sure you want to clear read state for 
\(book)
?"
) 
else
 {
            
return
 .result()
        }
        
Navigator
.shared.openBook(book)
        
return
 .result()
    }

    
static
 
var
 parameterSummary: 
some
 
ParameterSummary
 {
        
Summary
(
"Open 
\(\.
$book
)
"
)
    }
  
    
init
() {}

    
init
(
book
: 
BookEntity
) {
        
self
.book 
=
 book
    }
}
```

```swift
struct
 
BookQuery
: 
EntityStringQuery
 {
    
func
 
entities
(
for
 
identifiers
: [
UUID
]) 
async
 
throws
 -> [
BookEntity
] {
        identifiers.compactMap { identifier 
in

            
Database
.shared.book(for: identifier)
        }
    }

    
func
 
suggestedEntities
() 
async
 
throws
 -> [
BookEntity
] {
        
Database
.shared.books
    }

    
func
 
entities
(
matching
 
string
: 
String
) 
async
 
throws
 -> [
BookEntity
] {
        
Database
.shared.books.filter { book 
in

            book.title.lowercased().contains(string.lowercased())
        }
    }
}
```

```swift
struct
 
AddBook
: 
AppIntent
 {
    
static
 
var
 title: 
LocalizedStringResource
 
=
 
"Add Book"


    
@Parameter
(title: 
"Title"
)
    
var
 title: 
String


    
@Parameter
(title: 
"Author Name"
)
    
var
 authorName: 
String
?

    
@Parameter
(title: 
"Recommended By"
)
    
var
 recommendedBy: 
String
?

    
func
 
perform
() 
async
 
throws
 -> 
some
 
IntentResult
 & 
ReturnsValue
<
BookEntity
> & 
OpensIntent
 {
        
guard
 
var
 book 
=
 
await
 
BooksAPI
.shared.findBooks(named: title, author: authorName).first 
else
 {
            
throw
 
Error
.notFound
        }
        book.recommendedBy 
=
 recommendedBy
        
Database
.shared.add(book: book)

        
return
 .result(
            value: book,
            openIntent: 
OpenBook
(book: book)
        )
    }

    
enum
 
Error
: 
Swift
.
Error
, 
CustomLocalizedStringResourceConvertible
 {
        
case
 notFound

        
var
 localizedStringResource: 
LocalizedStringResource
 {
            
switch
 
self
 {
                
case
 .notFound: 
return
 
"Book Not Found"

            }
        }
    }
}
```

```swift
struct
 
BookEntity
: 
AppEntity
, 
Identifiable
 {
    
var
 id: 
UUID


    
@Property
(title: 
"Title"
)
    
var
 title: 
String


    
@Property
(title: 
"Publishing Date"
)
    
var
 datePublished: 
Date


    
@Property
(title: 
"Read Date"
)
    
var
 dateRead: 
Date
?

    
var
 recommendedBy: 
String
?

    
var
 displayRepresentation: 
DisplayRepresentation
 { 
"
\(title)
"
 }

    
static
 
var
 typeDisplayRepresentation: 
TypeDisplayRepresentation
 
=
 
"Book"


    
static
 
var
 defaultQuery 
=
 
BookQuery
()

    
init
(
id
: 
UUID
) {
        
self
.id 
=
 id
    }

    
init
(
id
: 
UUID
, 
title
: 
String
) {
        
self
.id 
=
 id
        
self
.title 
=
 title
    }
}
```

```swift
struct
 
BookQuery
: 
EntityPropertyQuery
 {
    
static
 
var
 sortingOptions 
=
 
SortingOptions
 {
        
SortableBy
(\
BookEntity
.
$title
)
        
SortableBy
(\
BookEntity
.
$dateRead
)
        
SortableBy
(\
BookEntity
.
$datePublished
)
    }

    
static
 
var
 properties 
=
 
QueryProperties
 {
        
Property
(\
BookEntity
.
$title
) {
            
EqualToComparator
 { 
NSPredicate
(format: 
"title = %@"
, 
$0
) }
            
ContainsComparator
 { 
NSPredicate
(format: 
"title CONTAINS %@"
, 
$0
) }
        }
        
Property
(\
BookEntity
.
$datePublished
) {
            
LessThanComparator
 { 
NSPredicate
(format: 
"datePublished < %@"
, 
$0
 
as
 
NSDate
) }
            
GreaterThanComparator
 { 
NSPredicate
(format: 
"datePublished > %@"
, 
$0
 
as
 
NSDate
) }
        }
        
Property
(\
BookEntity
.
$dateRead
) {
            
LessThanComparator
 { 
NSPredicate
(format: 
"dateRead < %@"
, 
$0
 
as
 
NSDate
) }
            
GreaterThanComparator
 { 
NSPredicate
(format: 
"dateRead > %@"
, 
$0
 
as
 
NSDate
) }
        }
    }

    
func
 
entities
(
for
 
identifiers
: [
UUID
]) 
async
 
throws
 -> [
BookEntity
] {
        identifiers.compactMap { identifier 
in

            
Database
.shared.book(for: identifier)
        }
    }

    
func
 
suggestedEntities
() 
async
 
throws
 -> [
BookEntity
] {
        
Model
.shared.library.books.map { 
BookEntity
(id: 
$0
.id, title: 
$0
.title) }
    }

    
func
 
entities
(
matching
 
string
: 
String
) 
async
 
throws
 -> [
BookEntity
] {
        
Database
.shared.books.filter { book 
in

            book.title.lowercased().contains(string.lowercased())
        }
    }

    
func
 
entities
(
        
matching
 
comparators
: [
NSPredicate
],
        
mode
: 
ComparatorMode
,
        
sortedBy
: [
Sort
<
BookEntity
>],
        
limit
: 
Int
?
    ) 
async
 
throws
 -> [
BookEntity
] {
        
Database
.shared.findBooks(matching: comparators, matchAll: mode 
==
 .and, sorts: sortedBy.map { (keyPath: 
$0
.by, ascending: 
$0
.order 
==
 .ascending) })
    }
}
```

```swift
struct
 
AddBook
: 
AppIntent
 {
    
static
 
var
 title: 
LocalizedStringResource
 
=
 
"Add Book"


    
@Parameter
(title: 
"Title"
)
    
var
 title: 
String


    
@Parameter
(title: 
"Author Name"
)
    
var
 authorName: 
String
?

    
@Parameter
(title: 
"Recommended By"
)
    
var
 recommendedBy: 
String
?

    
func
 
perform
() 
async
 
throws
 -> 
some
 
IntentResult
 & 
ReturnsValue
<
BookEntity
> & 
ProvidesDialog
 {
        
guard
 
var
 book 
=
 
await
 
BooksAPI
.shared.findBooks(named: title, author: authorName).first 
else
 {
            
throw
 
Error
.notFound
        }
        book.recommendedBy 
=
 recommendedBy
        
Database
.shared.add(book: book)

        
return
 .result(
            value: book,
            dialog:
"Added 
\(book)
 to Library!"

        )
    }

    
enum
 
Error
: 
Swift
.
Error
, 
CustomLocalizedStringResourceConvertible
 {
        
case
 notFound

        
var
 localizedStringResource: 
LocalizedStringResource
 {
            
switch
 
self
 {
                
case
 .notFound: 
return
 
"Book Not Found"

            }
        }
    }
}
```

```swift
struct
 
AddBook
: 
AppIntent
 {
    
static
 
var
 title: 
LocalizedStringResource
 
=
 
"Add Book"


    
@Parameter
(title: 
"Title"
)
    
var
 title: 
String


    
@Parameter
(title: 
"Author Name"
)
    
var
 authorName: 
String
?

    
@Parameter
(title: 
"Recommended By"
)
    
var
 recommendedBy: 
String
?

    
func
 
perform
() 
async
 
throws
 -> 
some
 
IntentResult
 & 
ShowsSnippetView
 {
        
guard
 
var
 book 
=
 
await
 
BooksAPI
.shared.findBooks(named: title, author: authorName).first 
else
 {
            
throw
 
Error
.notFound
        }
        book.recommendedBy 
=
 recommendedBy
        
Database
.shared.add(book: book)

        
return
 .result(value: book) {
            
CoverView
(book: book)
        }
    }

    
enum
 
Error
: 
Swift
.
Error
, 
CustomLocalizedStringResourceConvertible
 {
        
case
 notFound

        
var
 localizedStringResource: 
LocalizedStringResource
 {
            
switch
 
self
 {
                
case
 .notFound: 
return
 
"Book Not Found"

            }
        }
    }
}
```

```swift
struct
 
AddBook
: 
AppIntent
 {
    
static
 
var
 title: 
LocalizedStringResource
 
=
 
"Add Book"


    
@Parameter
(title: 
"Title"
)
    
var
 title: 
String


    
@Parameter
(title: 
"Author Name"
)
    
var
 authorName: 
String
?

    
@Parameter
(title: 
"Recommended By"
)
    
var
 recommendedBy: 
String
?

    
func
 
perform
() 
async
 
throws
 -> 
some
 
IntentResult
 {
        
let
 books 
=
 
await
 
BooksAPI
.shared.findBooks(named: title, author: authorName)
        
guard
 
!
books.isEmpty 
else
 {
            
throw
 
Error
.notFound
        }
        
if
 books.count 
>
 
1
 
&&
 authorName 
==
 
nil
 {
            
throw
 
$authorName
.requestValue(
"Who wrote the book?"
)
        }

        
return
 .result()
    }

    
enum
 
Error
: 
Swift
.
Error
, 
CustomLocalizedStringResourceConvertible
 {
        
case
 notFound

        
var
 localizedStringResource: 
LocalizedStringResource
 {
            
switch
 
self
 {
                
case
 .notFound: 
return
 
"Book Not Found"

            }
        }
    }
}
```

```swift
struct
 
AddBook
: 
AppIntent
 {
    
static
 
var
 title: 
LocalizedStringResource
 
=
 
"Add Book"


    
@Parameter
(title: 
"Title"
)
    
var
 title: 
String


    
@Parameter
(title: 
"Author Name"
)
    
var
 authorName: 
String
?

    
@Parameter
(title: 
"Recommended By"
)
    
var
 recommendedBy: 
String
?

    
func
 
perform
() 
async
 
throws
 -> 
some
 
IntentResult
 {
        
let
 books 
=
 
await
 
BooksAPI
.shared.findBooks(named: title, author: authorName)
        
guard
 
!
books.isEmpty 
else
 {
            
throw
 
Error
.notFound
        }
        
if
 books.count 
>
 
1
 {
            
let
 chosenAuthor 
=
 
try
 
await
 
$authorName
.requestDisambiguation(among: books.map { 
$0
.authorName }, dialog: 
"Which author?"
)
        }
        
return
 .result()
    }

    
enum
 
Error
: 
Swift
.
Error
, 
CustomLocalizedStringResourceConvertible
 {
        
case
 notFound

        
var
 localizedStringResource: 
LocalizedStringResource
 {
            
switch
 
self
 {
                
case
 .notFound: 
return
 
"Book Not Found"

            }
        }
    }
}
```

```swift
struct
 
AddBook
: 
AppIntent
 {
    
static
 
var
 title: 
LocalizedStringResource
 
=
 
"Add Book"


    
@Parameter
(title: 
"Title"
)
    
var
 title: 
String


    
@Parameter
(title: 
"Author Name"
)
    
var
 authorName: 
String
?

    
@Parameter
(title: 
"Recommended By"
)
    
var
 recommendedBy: 
String
?

    
func
 
perform
() 
async
 
throws
 -> 
some
 
IntentResult
 & 
ReturnsValue
<
BookEntity
> {
        
guard
 
var
 book 
=
 
await
 
BooksAPI
.shared.findBooks(named: title, author: authorName).first 
else
 {
            
throw
 
Error
.notFound
        }
        
let
 confirmed 
=
 
try
 
await
 
$title
.requestConfirmation(for: book.title, dialog: 
"Did you mean 
\(book)
?"
)
        book.recommendedBy 
=
 recommendedBy
        
Database
.shared.add(book: book)
        
return
 .result(value: book)
    }

    
enum
 
Error
: 
Swift
.
Error
, 
CustomLocalizedStringResourceConvertible
 {
        
case
 notFound

        
var
 localizedStringResource: 
LocalizedStringResource
 {
            
switch
 
self
 {
                
case
 .notFound: 
return
 
"Book Not Found"

            }
        }
    }
}
```

```swift
struct
 
BuyBook
: 
AppIntent
 {
    
@Parameter
(title: 
"Book"
)
    
var
 book: 
BookEntity


    
@Parameter
(title: 
"Count"
)
    
var
 count: 
Int


    
static
 
var
 title: 
LocalizedStringResource
 
=
 
"Buy Book"


    
func
 
perform
() 
async
 
throws
 -> 
some
 
IntentResult
 & 
ShowsSnippetView
 & 
ProvidesDialog
 {
        
let
 order 
=
 
OrderEntity
(book: book, count: count)
        
try
 
await
 requestConfirmation(output: .result(value: order, dialog: 
"Are you ready to order?"
) {
            
OrderPreview
(order: order)
        })

        
return
 .result(value: order, dialog: 
"Thank you for your order!"
) {
            
OrderConfirmation
(order: order)
        }
    }
}
```


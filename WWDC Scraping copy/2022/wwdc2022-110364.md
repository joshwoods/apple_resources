# Wwdc2022 110364

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Demystify parallelization in Xcode buildsLearn how the Xcode build system extracts maximum parallelism from your builds. We'll explore how you can structure your project to improve build efficiency, take you through the process for resolving relationships between targets' build phases in Xcode, and share how you can take full advantage of available hardware resources when compiling in Swift. We'll also introduce you to Build Timeline — a powerful tool to help you monitor your build efficiency and performance.ResourcesSwift Compiler Driver on GitHubHD VideoSD VideoRelated VideosWWDC22Link fast: Improve build and launch timesWhat's new in SwiftWhat's new in Xcode

Learn how the Xcode build system extracts maximum parallelism from your builds. We'll explore how you can structure your project to improve build efficiency, take you through the process for resolving relationships between targets' build phases in Xcode, and share how you can take full advantage of available hardware resources when compiling in Swift. We'll also introduce you to Build Timeline — a powerful tool to help you monitor your build efficiency and performance.

Swift Compiler Driver on GitHub

HD VideoSD Video

HD Video

SD Video

Link fast: Improve build and launch times

What's new in Swift

What's new in Xcode

Search this video…♪ ♪Hello, and welcome to WWDC 2022.My name is Ben, and I'm an engineer on the Xcode build system team.Hi, my name is Artem, and I'm an engineer on the Swift Compiler team.In this talk we're gonna give you a deep dive into Xcode's build processto demystify parallelization inside builds.Ben is going to start with an introduction of the core concepts about buildsand look at the available tools that Xcode offersto help investigate build performance issues.He will then explain how Xcode increases parallelization while building a target.Building on top of that,I will explain how Xcode parallelizes a build holisticallywhile building projects consisting of many targetsand summarize the takeaways in the end.Ben?Let's re-iterate on what happens when pressing CMD+B in Xcode to build an app.The build system, as part of Xcode,gets invoked with a representation of the whole project,including all source files, assets,build settings, and other configurations like the run destination.The build system is the single source of truth about how an app should be built.It knows which tools to invoke using which settingsand which intermediate files to produce to eventually create an app.In the next step, the build system invokes the toolsto process the project's input files, for example, the compilers.Both compilers, Clang and Swift, will produce object filesthat the linker needs to link the executable programthat represents the app.While this order makes sense, it's not obvious where it comes from.So let's take a look at one example of that processand how the build system decides in which order to execute all tasks.Using the input source-files, the Swift compiler capturesthe programmer's intent and translates it into a machine-executable binary,checking the source code for errors along the way.This process can fail, which would cancel the build,but if it succeeds, it creates an object file for each input.Those object files are used to invoke the linkerwhich combines them and adds references to externally linked librariesto produce the executable.The two tasks have a dependency based on what they consume and produce.The object files produced by the compiler get consumed by the linker.This creates a dependency on the build system graph.The file contents itself are not of interest to the build system,but the dependency between the tasks is.While executing the build, it needs to make surethat a task that produces another task's input finishes before said task can start.And since this core concept is valid for all kind of tasks,let's switch to a more generic visualizationthat shows a dependency between Task A and Task B.In this case, A produces some or all of B's inputs.Compiling and Linking are only a few of many different task typesthat need to be executed to build a whole target,so let's add some more generic tasks to the graphthat represent other types like compiling assets,copying files or codesigning.Together, they represent building a Framework target.Again, those tasks have defined dependenciesbased on their inputs and outputs.So completing executing task A unblocks running task B and C,while finishing task B unblocks task D and E.Tasks that get unblocked are called 'downstream'and tasks that block 'upstream'.Many projects contain more than one framework target,so let's add two more targets representing an app and an app extension.Targets define dependencies between each other in the projectvia explicit or implicit dependencies.For example, by getting added to the 'Link Binary with Libraries' build phase.In this case, the app embeds the app extensionand links against the Framework.The app extension is not using the Framework,so they don't have a dependency relationship.When executing the build graph, different tasks take a different amount of time.This comes down to the level of complexity that is necessary to complete the work,depending on the computation that's needed as well as the size of the input.Compiling many files takes usually much more time than copying a few header files,and taking this into consideration will end up with something like this.When the build system executes this build,it starts by running tasks that don't have dependencies.And once those completed, they unblock downstream tasks and so on,following this process until all planned tasks finished.On following builds, the build system is able to skip tasksfor which inputs haven't changed while the output is still up to date.If a task needs to re-run due to a changed input,like B of the App target in this case,downstream tasks have to re-run too if its output changed.Skipping all other tasks allows for very fast turnaround timeswhen iteratively working on the project.This is called an incremental build, but let's stick to full builds for now.The dependencies and duration of the task executiondefines the first possible time a downstream task can start.With this information it's possible to calculate the critical pathwhich is the shortest time the build needs to runwith theoretical unlimited resources.A common pattern throughout this talk will be to shorten this pathto create a highly parallelizable and scalable build graph.A shorter critical path does not necessarily resultin a shorter overall build time,but it ensures that the build scales with the hardware.The critical build path defines the limiting factorof how fast a build can be–it cannot complete faster, even if the hardware would allow it.Shortening the critical path is done by breaking up dependencies within it.When looking at how a build performed and to understand more about its execution,the data needs to be plotted based on the time they executed.The width still indicates the length of tasks.Wide elements like these two indicate a long running taskwhile narrow elements like these represent fast finishing tasks.The height of the graph shows the number of parallel executing tasksat a given time.Be aware that this does not directly map to CPU or memory utilization.Empty space originates by tasks blocking its downstream taskslike in those two scenarios.And finally, the color of the elements represent their associated target.I'm very excited to announce that this visualization is new in Xcode 14and will help understand a build's performance after it finished.The Xcode Build Timeline is a great new addition to the build log.It visualizes based on parallelization,rather than hierarchy to understand the build's performance.The number of rows at given time represents the level of parallelismduring that time.The horizontal length of individual tasksrepresent the duration they needed to finish their work.Empty space in the graph shows where unfinished tasksblocked downstream tasks from starting to execute.Different colors applied to the timeline elementshelp distinguish the different targets that were part of the build.And on incremental builds, the timeline will only contain tasksthat got actually executed,allowing to spot long-running tasks,especially ones which might not have been expected to run during this build.Here's a demo of the Build Timeline in Xcode 14.In this window I opened a copy of the swift-docc project from Githubwhich builds the documentation compiler.To get an overview about the targets that are built for the scheme,let's check out the scheme editor.To open that I click on the scheme and select "Edit scheme".The 'build' tab contains a list of all targets.Targets can explicitly get added to the schemeor implicitly by being a dependency of a targetthat is already part of the scheme.In this case I'm using a Swift package with an automatically generated schemefor the package, so all targets from the manifest are explicitly defined.This log represents a build of that scheme that I executed earlier.In contains entries for all tasks that the build system executed.The entries are organized in a hierarchybased on the targets they belong to, like the 'docc' target here.To successfully build the executable of that target,Xcode ran all tasks that are represented by the children of this node.Since the build log is currently in its 'All' state,it also shows tasks from previous buildsthat didn't need to re-run in an incremental build.Selecting 'Recent' only shows tasks that got actually executed,hiding all skipped tasks.In addition to that, the build log also supports filtersto only show tasks that had issues or even failed.To open the build timeline for this build,I go to the editor options and open the assistant.The build timeline opens next to the build log.Like usual, the editor options provide settings to show the assistanton the right or bottom.I'll stay with bottom for now.The timeline visualizes the same data as the 'recent' build logbased on the parallelization of the build.Selecting an element in one also selects it in the other.This enables to see a task's execution in context.The timeline here gives a sense about the tasksthat executed in parallel to the selected task.I'm using a pinch gesture on the trackpad to zoom out again.Selecting an element in the timeline shows it in the build log.And since the build log visualizes based on the hierarchical structure,it enables to view which files were compiledas part of this compiler invocation.It also enables to view the whole command line of that invocation.Holding down Option while selecting an area in the build timelineadjusts the view port to fit this timeframe.Here we can verify that linking of the target ArgumentParseris in fact waiting for compilation of the same target.Holding Option while scrolling up allows me to zoom out quickly.The number of rows in the timeline represents the number of tasksthat ran in parallel at that time.An empty space like this indicates tasks waiting for un-produced inputs.Ideally, the timeline is vertically filled and has as little empty space as possible.This scales the build graph the best and makes builds faster,the faster the hardware.To achieve this, Xcode comes with many improvements this yearto shorten the critical path.Next, let's check out how Xcode defines and builds individual targetsas well as how it can increase parallelization.When configuring a target, build phases describe the workthat needs to be done to produce that target's product.They are defined in the project editor and can contain a set of source code filesand assets to compile,files that need to be copied like headers or resources,as well as libraries that should be linked or scripts that should be executed.Many build phases describe tasks with inputs or outputsfrom other build phases, creating dependencies between them.For example, a target's source files must be compiled before it is linked.However, this doesn't apply to all build phases.Instead of running tasks from each build phase in a linear order,the build system will consider the inputs and outputs of build phasesto determine if they can run in parallel.For example, Compilation and Resource copying can run in parallelbecause neither depends on any outputs of the other.However, linking must still follow compilationbecause it depends on the object files produced by that phase.Now, let's consider a different target which contains 'Run Script' build phases.Unlike other build phases, the inputs and outputs of script phasesmust be manually configured in the target editor.As a result, the build system will run consecutive script phasesone at a time to avoid introducing a data race in the build process.If the scripts in a target are configured to runbased on dependency analysisand specify their complete list of inputs and outputs,then the build setting FUSE_BUILD_SCRIPT_PHASEScan be set to YESto indicate the build system should attempt to run them in parallel.However, when running script phases in parallel,the build system has to rely on the specified inputs and outputs.So be aware that an incomplete list of the inputs or outputs of a script phasecan lead to data races which are very hard to debug.To mitigate this, Xcode supports user script sandboxingto precisely declare the dependencies of each script phase.Sandboxing is an opt-in feature that blocks shell scriptsfrom accidentally accessing source files and intermediate build objects,unless those are explicitly declared as an input or output for the phase.In this example, neither input nor output.txtare declared as a dependency for that script phase.The sandbox will block the script from reading and writingto both files when building the project.When the script violates the sandbox,it will fail with a non-zero exit code causing the build to fail.In addition to that, Xcode will list all the pathsthat the script phase was trying to access without properly declaring them.Adding both files as dependency information to this script phasefixes this issue.This way the sandbox ensures that the script is not mistakenlyaccessing any file other than its declared inputs and outputs.Now, let's explore an example with more than one script phaseand see how sandboxing prevents data races and incorrect builds.There are two script phases.The first one reads a text file, calculates a checksum of its content,and writes that value to an intermediate file in DERIVED_FILE_DIR.The other script reads the same text fileas well as the produced checksumand injects them into an html file for later display in the app.If the precise set of input and output dependencies for these phasesis not declared, Xcode will run the two scripts in parallelwhen FUSE_BUILD_SCRIPT_PHASES is on.Let's inspect this problematic scenario in detail.Let's assume "Generate HTML" is missing the input declarationof "checksum.txt", but all other inputs and outputs of both scriptshave been correctly declared.Without sandboxing, this misconfiguration might stay unnoticed,causing problems in the build.It means Xcode will fail to infer the dependency relationbetween both phases, and schedule to run them in parallelwhen FUSE_BUILD_SCRIPT_PHASES is switched on.There are a few hazards here.Since checksum.txt is not listed as an input dependency for "Generate HTML"during a clean build the script will attempt to read the filewithout it being available on the filesystem.The other hazard is if checksum.txt is available on diskbecause of previous runs of "Calculate Checksum","Generate HTML" may pick up the outdated filewhen the two scripts run in parallel.This is a user error, and executing the scripts in a sandboxhelps preventing this issue.With sandboxing switched on, "Generate HTML" will fail immediatelywhen it attempts to read "checksum.txt".The error message will guide adding the missing input for that build phase.Having the inputs and outputs correctly definedguides Xcode to respect the dependency relation between both phasesso that "calculate checksum" runs before "Generate HTML".While unrelated build phases can still execute in parallel.To enable Sandboxed Shell Scripts for a target,set ENABLE_USER_SCRIPT_SANDBOXING to YES in the build settings editoror an xcconfig file.In summary, sandboxed shell scripts allow having correct dependency informationto enable faster and more robust incremental buildssince the build system has the confidence to skip script phasesif the inputs haven't changed and the outputs are still valid,while re-running the script otherwise.Enabling the build setting for a script's target blocks access to filesinside the source root of the project as well as the derived data directoryif they are not explicitly defined as inputs or outputs of the scriptin the project.The sandbox will not prevent unauthorized access to any other directory,so don't consider this a security feature.Using this feature helps to debug missing inputs or outputsof existing script phases to ensure a valid configurationAnd in combination with the previously explained build settingFUSE_BUILD_SCRIPT_PHASES,script phases with correctly defined dependency edges through sandboxingcan execute in parallel to reduce the critical path of the build.That's it for parallelizing the steps of building a target.Now Artem is going to demystify parallelizationhen building many targets.Artem: Thanks, Ben.Now that we've covered the basics of build system tasksand phases that may go into building a target in your project,let's take a more global viewand explore how Xcode uses dependencies between Swift targetsto extract the maximum amount of parallelism out of your buildsand how the structure and organization of your project can affect build times.There are likely to be several levels of hierarchy composing your project.For example, an App target depending on a collection of local librariesbroken up into targets along semantic boundaries,and in several frameworks.Each target containing many different build phases and steps,producing and consuming file dependenciesto and from build phases in other targets.As the size of your project grows,these task graphs tend to increase in size and complexity.While the Xcode Build System flattens these hierarchies,breaking down the build into a sea of tasksthat correspond to build phases of all targets.One kind of task that is special for a Swift target is compilation.Building a Swift target's source code into binary product'sis a complex operation that typically consists of many sub-tasksfor build planning, compilation, and linking.Coordination of these tasks is delegated to a specialized toolin the Xcode toolchain– the Swift Driver.The Driver has specialized knowledge on when and how to constructthe required compiler and linker invocations for the target's source code.Any target that includes Swift codealso corresponds to a unit of code distribution: a module.A binary module file capturing the public interface of this targetis a build product that is required for downstream targets to begin a compilation.Let's take a closer look at an example of what Swift Driver doesto build one of the targets.Your target probably consists of a collection of several source files.In release or optimized builds the driver will schedule one compiler taskincluding all source files to maximize opportunities for optimization.This single compile task will also produce the target's Swift module.In debug or incremental compilation modes,the Swift Driver breaks down the required compilation effortinto smaller sub-tasks which can run in parallel,some of which may not need to re-run on an incremental build.Producing a Swift module then requires an additional stepto merge together partial intermediate products of each compile task.If, like in this example,the number of source files in your target is high,individual files may also be assigned to batch compilation sub-tasks,according to the build-system's heuristics.The build log highlights which source files get assignedto batch compilation jobs,with a separate entry for each file's diagnostics.Being able to parallelize a target's build across different source files is crucialfor both faster and smaller incremental builds,so make sure your Debug builds are using the Incremental Compilation Mode setting.Before Xcode 14, because of the boundarybetween the Xcode Build System and Swift Driver,orchestration of target build phases,and compilation sub-tasks spawned by each target's instance of the Driverhappened independently of each other,with each component doing its bestto make the most of available system resources.Let's take this example build graph and dive deeperinto what goes into scheduling its compilation phaseswith respect to each other.As we've learned earlier, Swift target dependencies are resolvedby having their dependents provide a binary module filethat captures the dependent's public interface.Resolving these dependency relationships leads us to the following ordering,captured in a timeline showing the top-level Swift Driver tasksfor each target, as well as their individual sub-tasks.With Xcode 14, thanks to an entirely new implementation of Swift Driver–itself now written in Swift–the build system and the compiler are fully integrated.The Xcode Build System acts as the central schedulerfor all tasks that must be performed to compile your code.This central planning mechanism allows Xcodeto make fine-grained scheduling decisionsproviding better guarantees that building your projectwill use only as much resources as available,without oversubscribing your CPU and reducing overall system performance.And what was previously a collection of islands of sub-tasksoutside of Xcode Build System's purvieware now fully in a domain of the build-system's scheduler.With all the individual sub-tasks in a central task pool,it is important to consider the trade-offs made by the build scheduler.For example, on an 8-core machinethe scheduler's default is to assign available tasks–those tasks whose dependencies have been satisfied and are ready to go–to one of eight available execution slots.As soon as one of the slots frees up,the Build System attempts to fill it with more outstanding work.On a higher-core-count machine,we're able to perform more concurrent work.But that means we're also more likely to have idle coreswhich are available to perform more work,but all of the outstanding tasks are still awaiting their inputs,as produced by other tasks that are currently in-flight or waiting.The new integrated build system allows the schedulerto significantly reduce this idle time.To see how, let's revisit how a target's dependencies for compilation,binary module files, are resolved.As we've covered earlier,the partial results of compilation sub-tasksare merged into a target's final module product.Once this product is available, downstream targets may begin compilation.New in Xcode 14 and Swift 5.7, construction of a target's moduleis done in a separate emit-module taskdirectly from all program source files.This means a target's dependencies can begin compilationas soon as the emit-module task is completewithout waiting for all of the other compiler tasks of the dependency target.Being able to unblock downstream target compilation this much soonercuts down on the time spent waiting for available work with idle CPU cores–that empty space in between spurs of activity in the build timeline.Extending this to the rest of our projectshows that although we are performing a similar amount of overall work,the build system is able to use the computer's resources more efficiently,often completing the build significantly faster.Now, let's take a look at a second cross-target optimizationthe build system can perform when building Swift–Eager Linking.Building on the previous example,we've added the linker tasks for each target,which are both on the build's critical path.In this case, because Target B links Target A,Target B's link task must wait for Target A's linked output to be producedand its own compilation tasks to complete before it can run.However, with eager linking,Target B's link task can depend on Target A's emit-module task instead.As a result, Target B can begin linking earlier in the build,running in parallel with linking Target A and shortening the critical path.How does this work?Normally, the dependency graph of two targetswith a linked product dependency looks something like this.Linking the dependent target requires the linked product of its dependenciesin addition to the target's own compilation outputs.When linking eagerly, this dependency is broken,allowing the dependent target to start linking earlier.Instead of depending on a linked product of the dependency,it now depends on a text-based dynamic library stubproduced earlier in the build process by the emit-module task.This stub contains a list of symbols which will appearin the linked product for use by dependents.You can enable this optimization using the Xcode build setting shown on screen.Eager Linking applies to all pure Swift targetsthat are dynamically linked by their dependents.To summarize, the Xcode Build System is a sophisticated scheduling enginethat seeks to extract as much parallelism as possibleby running build phases in parallel.And features like Script Sandboxing allow you to ensure your buildsare both maximally parallel and reliable.Xcode and Swift are more integrated than ever.And project structure: its modularization, the overall shape of the graphmade up of dependencies between target productsand the number and complexity of build phases within them,combined with the available computational resources of your machine–all these are contributing factors to the degree Xcode is able to parallelizeand speed up your builds.With this knowledge, and powerful new tools like the build timeline,you are well equipped to examine your project and gain insight into your builds.And if you're curious to learn even moreof the behind-the-scenes technical details,many of the technologies we described that are used by Xcodeare developed in the open-source.You can find the repository for Swift Driver on GitHub at the link below.For more great sessions about Xcode,check out all new features and improvements from this yearin "What's new in Xcode".And learn how Xcode 14's linker improves link times up to two timesin the session "Link fast: Improve build and launch times".Thanks for following along.We hope you learned some new insights about Xcode builds.We can't wait to see what you're going to create.Have a great rest of the conference.

♪ ♪Hello, and welcome to WWDC 2022.My name is Ben, and I'm an engineer on the Xcode build system team.Hi, my name is Artem, and I'm an engineer on the Swift Compiler team.In this talk we're gonna give you a deep dive into Xcode's build processto demystify parallelization inside builds.Ben is going to start with an introduction of the core concepts about buildsand look at the available tools that Xcode offersto help investigate build performance issues.He will then explain how Xcode increases parallelization while building a target.Building on top of that,I will explain how Xcode parallelizes a build holisticallywhile building projects consisting of many targetsand summarize the takeaways in the end.Ben?Let's re-iterate on what happens when pressing CMD+B in Xcode to build an app.The build system, as part of Xcode,gets invoked with a representation of the whole project,including all source files, assets,build settings, and other configurations like the run destination.The build system is the single source of truth about how an app should be built.It knows which tools to invoke using which settingsand which intermediate files to produce to eventually create an app.In the next step, the build system invokes the toolsto process the project's input files, for example, the compilers.

Both compilers, Clang and Swift, will produce object filesthat the linker needs to link the executable programthat represents the app.While this order makes sense, it's not obvious where it comes from.So let's take a look at one example of that processand how the build system decides in which order to execute all tasks.

Using the input source-files, the Swift compiler capturesthe programmer's intent and translates it into a machine-executable binary,checking the source code for errors along the way.This process can fail, which would cancel the build,but if it succeeds, it creates an object file for each input.Those object files are used to invoke the linkerwhich combines them and adds references to externally linked librariesto produce the executable.The two tasks have a dependency based on what they consume and produce.The object files produced by the compiler get consumed by the linker.This creates a dependency on the build system graph.The file contents itself are not of interest to the build system,but the dependency between the tasks is.While executing the build, it needs to make surethat a task that produces another task's input finishes before said task can start.And since this core concept is valid for all kind of tasks,let's switch to a more generic visualizationthat shows a dependency between Task A and Task B.In this case, A produces some or all of B's inputs.

Compiling and Linking are only a few of many different task typesthat need to be executed to build a whole target,so let's add some more generic tasks to the graphthat represent other types like compiling assets,copying files or codesigning.Together, they represent building a Framework target.Again, those tasks have defined dependenciesbased on their inputs and outputs.So completing executing task A unblocks running task B and C,while finishing task B unblocks task D and E.Tasks that get unblocked are called 'downstream'and tasks that block 'upstream'.Many projects contain more than one framework target,so let's add two more targets representing an app and an app extension.Targets define dependencies between each other in the projectvia explicit or implicit dependencies.For example, by getting added to the 'Link Binary with Libraries' build phase.

In this case, the app embeds the app extensionand links against the Framework.The app extension is not using the Framework,so they don't have a dependency relationship.

When executing the build graph, different tasks take a different amount of time.This comes down to the level of complexity that is necessary to complete the work,depending on the computation that's needed as well as the size of the input.Compiling many files takes usually much more time than copying a few header files,and taking this into consideration will end up with something like this.When the build system executes this build,it starts by running tasks that don't have dependencies.And once those completed, they unblock downstream tasks and so on,following this process until all planned tasks finished.

On following builds, the build system is able to skip tasksfor which inputs haven't changed while the output is still up to date.If a task needs to re-run due to a changed input,like B of the App target in this case,downstream tasks have to re-run too if its output changed.Skipping all other tasks allows for very fast turnaround timeswhen iteratively working on the project.This is called an incremental build, but let's stick to full builds for now.

The dependencies and duration of the task executiondefines the first possible time a downstream task can start.With this information it's possible to calculate the critical pathwhich is the shortest time the build needs to runwith theoretical unlimited resources.A common pattern throughout this talk will be to shorten this pathto create a highly parallelizable and scalable build graph.A shorter critical path does not necessarily resultin a shorter overall build time,but it ensures that the build scales with the hardware.The critical build path defines the limiting factorof how fast a build can be–it cannot complete faster, even if the hardware would allow it.Shortening the critical path is done by breaking up dependencies within it.When looking at how a build performed and to understand more about its execution,the data needs to be plotted based on the time they executed.The width still indicates the length of tasks.Wide elements like these two indicate a long running taskwhile narrow elements like these represent fast finishing tasks.

The height of the graph shows the number of parallel executing tasksat a given time.Be aware that this does not directly map to CPU or memory utilization.

Empty space originates by tasks blocking its downstream taskslike in those two scenarios.And finally, the color of the elements represent their associated target.I'm very excited to announce that this visualization is new in Xcode 14and will help understand a build's performance after it finished.The Xcode Build Timeline is a great new addition to the build log.It visualizes based on parallelization,rather than hierarchy to understand the build's performance.The number of rows at given time represents the level of parallelismduring that time.The horizontal length of individual tasksrepresent the duration they needed to finish their work.Empty space in the graph shows where unfinished tasksblocked downstream tasks from starting to execute.Different colors applied to the timeline elementshelp distinguish the different targets that were part of the build.And on incremental builds, the timeline will only contain tasksthat got actually executed,allowing to spot long-running tasks,especially ones which might not have been expected to run during this build.

Here's a demo of the Build Timeline in Xcode 14.In this window I opened a copy of the swift-docc project from Githubwhich builds the documentation compiler.To get an overview about the targets that are built for the scheme,let's check out the scheme editor.To open that I click on the scheme and select "Edit scheme".

The 'build' tab contains a list of all targets.Targets can explicitly get added to the schemeor implicitly by being a dependency of a targetthat is already part of the scheme.In this case I'm using a Swift package with an automatically generated schemefor the package, so all targets from the manifest are explicitly defined.

This log represents a build of that scheme that I executed earlier.In contains entries for all tasks that the build system executed.The entries are organized in a hierarchybased on the targets they belong to, like the 'docc' target here.To successfully build the executable of that target,Xcode ran all tasks that are represented by the children of this node.Since the build log is currently in its 'All' state,it also shows tasks from previous buildsthat didn't need to re-run in an incremental build.Selecting 'Recent' only shows tasks that got actually executed,hiding all skipped tasks.In addition to that, the build log also supports filtersto only show tasks that had issues or even failed.

To open the build timeline for this build,I go to the editor options and open the assistant.The build timeline opens next to the build log.Like usual, the editor options provide settings to show the assistanton the right or bottom.I'll stay with bottom for now.The timeline visualizes the same data as the 'recent' build logbased on the parallelization of the build.Selecting an element in one also selects it in the other.This enables to see a task's execution in context.The timeline here gives a sense about the tasksthat executed in parallel to the selected task.I'm using a pinch gesture on the trackpad to zoom out again.

Selecting an element in the timeline shows it in the build log.And since the build log visualizes based on the hierarchical structure,it enables to view which files were compiledas part of this compiler invocation.It also enables to view the whole command line of that invocation.

Holding down Option while selecting an area in the build timelineadjusts the view port to fit this timeframe.Here we can verify that linking of the target ArgumentParseris in fact waiting for compilation of the same target.Holding Option while scrolling up allows me to zoom out quickly.The number of rows in the timeline represents the number of tasksthat ran in parallel at that time.An empty space like this indicates tasks waiting for un-produced inputs.Ideally, the timeline is vertically filled and has as little empty space as possible.This scales the build graph the best and makes builds faster,the faster the hardware.To achieve this, Xcode comes with many improvements this yearto shorten the critical path.Next, let's check out how Xcode defines and builds individual targetsas well as how it can increase parallelization.When configuring a target, build phases describe the workthat needs to be done to produce that target's product.They are defined in the project editor and can contain a set of source code filesand assets to compile,files that need to be copied like headers or resources,as well as libraries that should be linked or scripts that should be executed.Many build phases describe tasks with inputs or outputsfrom other build phases, creating dependencies between them.For example, a target's source files must be compiled before it is linked.However, this doesn't apply to all build phases.Instead of running tasks from each build phase in a linear order,the build system will consider the inputs and outputs of build phasesto determine if they can run in parallel.For example, Compilation and Resource copying can run in parallelbecause neither depends on any outputs of the other.However, linking must still follow compilationbecause it depends on the object files produced by that phase.Now, let's consider a different target which contains 'Run Script' build phases.Unlike other build phases, the inputs and outputs of script phasesmust be manually configured in the target editor.As a result, the build system will run consecutive script phasesone at a time to avoid introducing a data race in the build process.If the scripts in a target are configured to runbased on dependency analysisand specify their complete list of inputs and outputs,then the build setting FUSE_BUILD_SCRIPT_PHASEScan be set to YESto indicate the build system should attempt to run them in parallel.However, when running script phases in parallel,the build system has to rely on the specified inputs and outputs.So be aware that an incomplete list of the inputs or outputs of a script phasecan lead to data races which are very hard to debug.To mitigate this, Xcode supports user script sandboxingto precisely declare the dependencies of each script phase.Sandboxing is an opt-in feature that blocks shell scriptsfrom accidentally accessing source files and intermediate build objects,unless those are explicitly declared as an input or output for the phase.In this example, neither input nor output.txtare declared as a dependency for that script phase.The sandbox will block the script from reading and writingto both files when building the project.When the script violates the sandbox,it will fail with a non-zero exit code causing the build to fail.In addition to that, Xcode will list all the pathsthat the script phase was trying to access without properly declaring them.Adding both files as dependency information to this script phasefixes this issue.This way the sandbox ensures that the script is not mistakenlyaccessing any file other than its declared inputs and outputs.Now, let's explore an example with more than one script phaseand see how sandboxing prevents data races and incorrect builds.There are two script phases.The first one reads a text file, calculates a checksum of its content,and writes that value to an intermediate file in DERIVED_FILE_DIR.The other script reads the same text fileas well as the produced checksumand injects them into an html file for later display in the app.If the precise set of input and output dependencies for these phasesis not declared, Xcode will run the two scripts in parallelwhen FUSE_BUILD_SCRIPT_PHASES is on.Let's inspect this problematic scenario in detail.Let's assume "Generate HTML" is missing the input declarationof "checksum.txt", but all other inputs and outputs of both scriptshave been correctly declared.Without sandboxing, this misconfiguration might stay unnoticed,causing problems in the build.It means Xcode will fail to infer the dependency relationbetween both phases, and schedule to run them in parallelwhen FUSE_BUILD_SCRIPT_PHASES is switched on.There are a few hazards here.Since checksum.txt is not listed as an input dependency for "Generate HTML"during a clean build the script will attempt to read the filewithout it being available on the filesystem.The other hazard is if checksum.txt is available on diskbecause of previous runs of "Calculate Checksum","Generate HTML" may pick up the outdated filewhen the two scripts run in parallel.This is a user error, and executing the scripts in a sandboxhelps preventing this issue.With sandboxing switched on, "Generate HTML" will fail immediatelywhen it attempts to read "checksum.txt".The error message will guide adding the missing input for that build phase.Having the inputs and outputs correctly definedguides Xcode to respect the dependency relation between both phasesso that "calculate checksum" runs before "Generate HTML".While unrelated build phases can still execute in parallel.To enable Sandboxed Shell Scripts for a target,set ENABLE_USER_SCRIPT_SANDBOXING to YES in the build settings editoror an xcconfig file.In summary, sandboxed shell scripts allow having correct dependency informationto enable faster and more robust incremental buildssince the build system has the confidence to skip script phasesif the inputs haven't changed and the outputs are still valid,while re-running the script otherwise.Enabling the build setting for a script's target blocks access to filesinside the source root of the project as well as the derived data directoryif they are not explicitly defined as inputs or outputs of the scriptin the project.The sandbox will not prevent unauthorized access to any other directory,so don't consider this a security feature.Using this feature helps to debug missing inputs or outputsof existing script phases to ensure a valid configurationAnd in combination with the previously explained build settingFUSE_BUILD_SCRIPT_PHASES,script phases with correctly defined dependency edges through sandboxingcan execute in parallel to reduce the critical path of the build.That's it for parallelizing the steps of building a target.Now Artem is going to demystify parallelizationhen building many targets.Artem: Thanks, Ben.Now that we've covered the basics of build system tasksand phases that may go into building a target in your project,let's take a more global viewand explore how Xcode uses dependencies between Swift targetsto extract the maximum amount of parallelism out of your buildsand how the structure and organization of your project can affect build times.There are likely to be several levels of hierarchy composing your project.For example, an App target depending on a collection of local librariesbroken up into targets along semantic boundaries,and in several frameworks.Each target containing many different build phases and steps,producing and consuming file dependenciesto and from build phases in other targets.As the size of your project grows,these task graphs tend to increase in size and complexity.While the Xcode Build System flattens these hierarchies,breaking down the build into a sea of tasksthat correspond to build phases of all targets.One kind of task that is special for a Swift target is compilation.Building a Swift target's source code into binary product'sis a complex operation that typically consists of many sub-tasksfor build planning, compilation, and linking.Coordination of these tasks is delegated to a specialized toolin the Xcode toolchain– the Swift Driver.The Driver has specialized knowledge on when and how to constructthe required compiler and linker invocations for the target's source code.Any target that includes Swift codealso corresponds to a unit of code distribution: a module.A binary module file capturing the public interface of this targetis a build product that is required for downstream targets to begin a compilation.Let's take a closer look at an example of what Swift Driver doesto build one of the targets.Your target probably consists of a collection of several source files.In release or optimized builds the driver will schedule one compiler taskincluding all source files to maximize opportunities for optimization.This single compile task will also produce the target's Swift module.In debug or incremental compilation modes,the Swift Driver breaks down the required compilation effortinto smaller sub-tasks which can run in parallel,some of which may not need to re-run on an incremental build.Producing a Swift module then requires an additional stepto merge together partial intermediate products of each compile task.If, like in this example,the number of source files in your target is high,individual files may also be assigned to batch compilation sub-tasks,according to the build-system's heuristics.The build log highlights which source files get assignedto batch compilation jobs,with a separate entry for each file's diagnostics.Being able to parallelize a target's build across different source files is crucialfor both faster and smaller incremental builds,so make sure your Debug builds are using the Incremental Compilation Mode setting.Before Xcode 14, because of the boundarybetween the Xcode Build System and Swift Driver,orchestration of target build phases,and compilation sub-tasks spawned by each target's instance of the Driverhappened independently of each other,with each component doing its bestto make the most of available system resources.Let's take this example build graph and dive deeperinto what goes into scheduling its compilation phaseswith respect to each other.As we've learned earlier, Swift target dependencies are resolvedby having their dependents provide a binary module filethat captures the dependent's public interface.Resolving these dependency relationships leads us to the following ordering,captured in a timeline showing the top-level Swift Driver tasksfor each target, as well as their individual sub-tasks.With Xcode 14, thanks to an entirely new implementation of Swift Driver–itself now written in Swift–the build system and the compiler are fully integrated.The Xcode Build System acts as the central schedulerfor all tasks that must be performed to compile your code.This central planning mechanism allows Xcodeto make fine-grained scheduling decisionsproviding better guarantees that building your projectwill use only as much resources as available,without oversubscribing your CPU and reducing overall system performance.

And what was previously a collection of islands of sub-tasksoutside of Xcode Build System's purvieware now fully in a domain of the build-system's scheduler.

With all the individual sub-tasks in a central task pool,it is important to consider the trade-offs made by the build scheduler.For example, on an 8-core machinethe scheduler's default is to assign available tasks–those tasks whose dependencies have been satisfied and are ready to go–to one of eight available execution slots.As soon as one of the slots frees up,the Build System attempts to fill it with more outstanding work.On a higher-core-count machine,we're able to perform more concurrent work.But that means we're also more likely to have idle coreswhich are available to perform more work,but all of the outstanding tasks are still awaiting their inputs,as produced by other tasks that are currently in-flight or waiting.The new integrated build system allows the schedulerto significantly reduce this idle time.To see how, let's revisit how a target's dependencies for compilation,binary module files, are resolved.

As we've covered earlier,the partial results of compilation sub-tasksare merged into a target's final module product.Once this product is available, downstream targets may begin compilation.New in Xcode 14 and Swift 5.7, construction of a target's moduleis done in a separate emit-module taskdirectly from all program source files.This means a target's dependencies can begin compilationas soon as the emit-module task is completewithout waiting for all of the other compiler tasks of the dependency target.Being able to unblock downstream target compilation this much soonercuts down on the time spent waiting for available work with idle CPU cores–that empty space in between spurs of activity in the build timeline.

Extending this to the rest of our projectshows that although we are performing a similar amount of overall work,the build system is able to use the computer's resources more efficiently,often completing the build significantly faster.

Now, let's take a look at a second cross-target optimizationthe build system can perform when building Swift–Eager Linking.Building on the previous example,we've added the linker tasks for each target,which are both on the build's critical path.In this case, because Target B links Target A,Target B's link task must wait for Target A's linked output to be producedand its own compilation tasks to complete before it can run.However, with eager linking,Target B's link task can depend on Target A's emit-module task instead.As a result, Target B can begin linking earlier in the build,running in parallel with linking Target A and shortening the critical path.How does this work?Normally, the dependency graph of two targetswith a linked product dependency looks something like this.Linking the dependent target requires the linked product of its dependenciesin addition to the target's own compilation outputs.When linking eagerly, this dependency is broken,allowing the dependent target to start linking earlier.Instead of depending on a linked product of the dependency,it now depends on a text-based dynamic library stubproduced earlier in the build process by the emit-module task.This stub contains a list of symbols which will appearin the linked product for use by dependents.You can enable this optimization using the Xcode build setting shown on screen.Eager Linking applies to all pure Swift targetsthat are dynamically linked by their dependents.To summarize, the Xcode Build System is a sophisticated scheduling enginethat seeks to extract as much parallelism as possibleby running build phases in parallel.And features like Script Sandboxing allow you to ensure your buildsare both maximally parallel and reliable.Xcode and Swift are more integrated than ever.And project structure: its modularization, the overall shape of the graphmade up of dependencies between target productsand the number and complexity of build phases within them,combined with the available computational resources of your machine–all these are contributing factors to the degree Xcode is able to parallelizeand speed up your builds.With this knowledge, and powerful new tools like the build timeline,you are well equipped to examine your project and gain insight into your builds.And if you're curious to learn even moreof the behind-the-scenes technical details,many of the technologies we described that are used by Xcodeare developed in the open-source.You can find the repository for Swift Driver on GitHub at the link below.For more great sessions about Xcode,check out all new features and improvements from this yearin "What's new in Xcode".And learn how Xcode 14's linker improves link times up to two timesin the session "Link fast: Improve build and launch times".Thanks for following along.We hope you learned some new insights about Xcode builds.We can't wait to see what you're going to create.Have a great rest of the conference.

## Code Samples


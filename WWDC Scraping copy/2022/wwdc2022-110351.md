# Wwdc2022 110351

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Eliminate data races using Swift ConcurrencyJoin us as we explore one of the core concepts in Swift concurrency: isolation of tasks and actors. We'll take you through Swift's approach to eliminating data races and its effect on app architecture. We'll also discuss the importance of atomicity in your code, share the nuances of Sendable checking to maintain isolation, and revisit assumptions about ordering work in a concurrent system.ResourcesConcurrencyThe Swift Programming Language: ConcurrencyHD VideoSD VideoRelated VideosWWDC22Meet distributed actors in SwiftVisualize and optimize Swift concurrencyWhat's new in SwiftWhat's new in UIKitWWDC21Discover concurrency in SwiftUIExplore structured concurrency in SwiftMeet async/await in SwiftProtect mutable state with Swift actorsSwift concurrency: Behind the scenesSwift concurrency: Update a sample appUse async/await with URLSession

Join us as we explore one of the core concepts in Swift concurrency: isolation of tasks and actors. We'll take you through Swift's approach to eliminating data races and its effect on app architecture. We'll also discuss the importance of atomicity in your code, share the nuances of Sendable checking to maintain isolation, and revisit assumptions about ordering work in a concurrent system.

Concurrency

The Swift Programming Language: Concurrency

HD VideoSD Video

HD Video

SD Video

Meet distributed actors in Swift

Visualize and optimize Swift concurrency

What's new in Swift

What's new in UIKit

Discover concurrency in SwiftUI

Explore structured concurrency in Swift

Meet async/await in Swift

Protect mutable state with Swift actors

Swift concurrency: Behind the scenes

Swift concurrency: Update a sample app

Use async/await with URLSession

Search this video…♪ Mellow instrumental hip-hop music ♪♪Hello.I'm Doug from the Swift team, and I'm here to talk aboutSwift Concurrency's approach to eliminating data races.We introduced Swift Concurrency as a set of language featuresthat make it easier to write concurrent programs.For the mechanics of these individual language features,we refer you to the 2021 WWDC talks covering each of them.This talk takes a different,more holistic view of Swift Concurrencyas a way of structuring your program to makeefficient use of concurrency without introducing data races.But to do so, we need a great analogy,so we invite you to sail with us on the high seas of concurrency.The sea of concurrency is unpredictable,with many things going on at once,but with you at the helm and Swift helping you navigatethe waters, it can produce amazing things.Let's dive in!We'll start by talking about isolation,which is one of the key ideas of Swift's concurrency model,ensuring that data is not shared in a mannerthat can introduce data races.Let's start with task isolation.In our sea of concurrency, tasks are represented by boats.Boats are our main workers -- they have a job to do,which they perform sequentially from start to finish.They are asynchronous, and their work can be suspendedany number of times at "await" operations in the code.Finally, they are self-contained:each task has its own resources, so it can operate by itself,independently of all of the other boats in the sea.If our boats are completely independent,we have concurrency without data races,but it's not very useful without some way to communicate.Let's add some communication!For example, one boat might havea pineapple that it wants to share with another boat.So the boats meet on the open sea,and we transfer the pineapple from one boat to the other.Now, this is where the physical analogybreaks down a little bit, because this pineappleis not a physical item that moves from one boat to the next.It's data, and in Swift we have a couple of different wayswe could represent that data.How do we define our pineapple type?We like value types in Swift, so let's make the pineapplea struct that's defined by its weight and ripeness.Let's see how this works.When the boats meet on the open sea,we're really passing a copy of the pineapple instancefrom one boat to the next,and each boat goes away with its own copy.If you were to mutate the copies,such as by calling the slice() and ripen() methods,it won't have any effect on the other one.Swift has always preferred value typesfor exactly this reason --mutations have only local effects.That principle helps value types maintain isolation.Now, let's extend our data model a bit and add chickens!Unlike pineapples, which are pretty muchonly good for eating, chickens are beautiful creatureswith their own unique personalities.So, we're going to model them with a class, like this.Let's have our intrepid seafarers exchange a chicken.When our boats meet, we share the chicken,except that copying a reference type like chickendoesn't give you another full copy of the chicken,it gives you a reference to that specific object.So once our boats have gone their separate ways,we can see that we have a problem:both boats are doing their work concurrently,but they are not independentbecause they both reference the same chicken object.That shared mutable data is prone to data races,such as when one boat is trying to feed the chickenand the other wants to play with it,leading to one very confused chicken.We need a way to know that it was safe to share pineapplesamongst boats, but not chickens.And then we need some checking in place in the Swift compilerto ensure that chickens aren't accidentally passedfrom one boat to another.Swift protocols are a great way of categorizing typesso you can reason about their behavior.The Sendable protocol is used to describe typesthat can safely be shared across different isolation domains,without creating data races.A type can be made Sendable by writing a conformance.The Pineapple struct conforms to Sendablebecause it's a value type, but the Chicken class cannotbecause it's an unsynchronized reference type.Modeling Sendable as a protocol allows us to describethe places where data is going to be sharedacross isolation domains.For example, when a task returns a value,this value is provided to any of the tasksthat are waiting for that value.Here, we are trying to return a Chicken from our Task,and we get an error stating that this is unsafebecause Chicken is not Sendable.The actual Sendable constraint comes from the definitionof the Task struct itself, which specifies thatthe result type of a Task, called Success,must conform to the Sendable protocol.You should use Sendable constraintswhere you have generic parameters whose valueswill be passed across different isolation domains.Now, let's revisit the idea of sharing data among boats.When two boats meet on the high seas and want to share data,we need someone to consistently check all of the goodsto make sure they're safe to share.That's the role of our friendly customs inspector --played here by the Swift compiler --to make sure that only Sendable types are exchanged.The pineapple is fine and can be exchanged freely,because it's Sendable.However, the chicken cannot be exchanged,and our friendly customs inspector will prevent usfrom making that mistake.The compiler is involved in checking Sendable correctnessat many different points.Sendable types must be correct by construction,and cannot allow any shared data to be smuggled through them.Enums and structs generally define value types,which copy all of their instance data along with themto produce independent values.Therefore, they can be Sendableso long as all of their instance data is also Sendable.Sendable can be propagated through collectionsand other generic types using conditional conformance.An array of Sendable types is Sendable,so a Crate full of pineapples is also Sendable.All of these Sendable conformances can even beinferred by the Swift compiler for non-public types,so Ripeness, Pineapple, and Crateare all implicitly Sendable.But let's say we create a coop to house our flock of chickens.This type cannot be marked as Sendable,because it contains non-Sendable state:Chicken isn't Sendable, so the array of chickensisn't Sendable.We'll get an error message from our compiler to indicatethat this type cannot safely be shared.Classes are reference types, so they can only bemade Sendable under very narrow circumstances,such as when a final class only has immutable storage.Our attempt to make the Chicken class Sendablewill produce an error because it contains mutable state.Now, it is possible to implement reference typesthat do their own internal synchronization, for example,by using a lock consistently.These types are conceptually Sendable,but there is no way for Swift to reason about that.Use unchecked Sendable to disable the compiler's checking.Be careful with this, because smuggling mutable statethrough @unchecked Sendableundermines the data race safety guarantees Swift is providing.Task creation involves executing a closure in a new,independent task, like sending off a rowboat from your boat.When we do this, we can capture values from the original taskand pass them into the new task,so we need Sendable checkingto ensure we don't introduce data races.If we do try to share a non-Sendable typeacross this boundary, the Swift compiler has us covered,producing an error message like this one.This isn't magic for task creation.The closure is being inferred to be a Sendable closure,which could have been written explicitly with At-Sendable.Sendable closures are values of Sendable function type.At-Sendable can be written on a function type to indicatethat the function type conforms to the Sendable protocol.That implies that values of that function typecan be passed to other isolation domains and called therewithout introducing data races on their captured state.Normally, function types cannot conform to protocols,but Sendable is special because the compiler validatesthe semantic requirements for it.There is similar support for tuples of Sendable typesconforming to the Sendable protocol,which allows Sendable to be usedthroughout the entire language.The system we've described has many concurrently executingtasks that are isolated from each other.The Sendable protocol describes typesthat can be safely shared among tasks,and the Swift compiler checks Sendable conformancesat every level to maintain isolation of the tasks.However, without any notion of shared mutable data anywhere,it's hard for the tasksto coordinate in a meaningful manner.So we need some way to share data amongst our tasksthat doesn't re-introduce data races.This is where actors come in.Actors provide a way to isolate statethat can be accessed by different tasks,but in a coordinated manner that eliminates data races.Actors are the islands in our sea of concurrency.Like boats, each island is self-contained,with its own state that is isolatedfrom everything else in the sea.To access that state, your code needs to be runningon the island.For example, the advanceTime methodis isolated to this island.It lives on the island and has accessto all of the island's state.To actually run code on an island, you need a boat.A boat can visit the island to run code on the island,at which point it has access to that state.Only one boat can visit the island to run code at a time,which ensures that there is no concurrent accessto the island's state.If other boats show up, they must await their turnto visit the island.And because it might be a long time before a given boatgets a chance to visit the island, entering into an actoris a potential suspension point marked by the “await” keyword.Once the island frees up -- again, at a suspension point --another boat can visit.Just like with two boats meeting on the open sea,interactions between a boat and an island need to maintainisolation of both, by making surethat non-Sendable types don't pass between the two.For example, perhaps we try to add a chicken from our boatto the flock on the island.This would create two references to the same chicken objectfrom different isolation domains,so the Swift compiler rejects it.Similarly, if we try to adopt a pet chicken from the islandand take it away on our boat, Sendable checking ensuresthat we cannot create this data race.Actors are reference types, but unlike classes, they isolateall of their properties and code to prevent concurrent access.Therefore, having a reference to an actorfrom a different isolation domain is safe.It's like having a map to an island:you can use the map to go visit the island,but you still need to go through the docking procedureto access its state.Therefore, all actor types are implicitly Sendable.You might be wondering how to knowwhat code is isolated to the actor and what code isn't.Actor isolation is determined by the context you're in.The instance properties of an actorare isolated to that actor.Instance methods on the actor or an extension of the actorare also isolated by default, like this advanceTime method.Closures that are not Sendable, such as the closure passedto the reduce algorithm, stay on the actor and areactor-isolated when they are in an actor-isolated context.The task initializer also inherits actor isolationfrom its context, so the created task will bescheduled on the same actor as it was initiated from.Here, that grants access to the flock.On the other hand, a detached taskdoes not inherit actor isolation from its context,because it is completely independent of the contextwhere it was created.We can see that the code in the closure hereis considered to be outside the actor because it needsto use “await” to refer to the isolated “food” property.We have a term for this closure: it's non-isolated code.No-isolated code is codethat does not run on any actor at all.You can explicitly make a function that's withinan actor non-isolated by using the non-isolated keyword,putting it outside of the actor.Just like what happened implicitly with the closure usedfor the detached task.That means if we want to read some of the statethat's isolated to the actor, we'll need to use “await”to visit the island and grab a copy of the state we need.Non-isolated async codealways runs on the global cooperative pool.Think of it as only running when a boat is out on the open sea,so you have to leave the island you're visiting to do the work.That means checking to ensurethat you aren't taking any non-Sendable data with you!Here, the compiler detects the potential data race,where an instance of the non-Sendable Chickenis trying to leave the island.Let's consider one more case of non-isolated code.The “greet” operation is non-isolated, synchronous code.It knows nothing about boats or islandsor concurrency in general.And here, we're calling itfrom the actor-isolated greetOne function,and that's okay!This synchronous code,when called from the island, will stay on the island,so it's free to operate on the chicken from the flock.If instead we had a non-isolated async operationthat calls “greet,”then “greet” will run there, on a boat, in the open sea.Most Swift code is like this:synchronous, non-isolated to any actor,and only operates on the parameters it's been given,so it stays in the isolation domain where it is called.Actors hold state that is isolatedfrom the rest of the program.Only one task can run on an actor at a time,so there is no concurrent access to that state.Sendable checking applies any timea task enters or exits an actor to ensurethat no unsynchronized mutable state escapes.Altogether, this makes actors one of the building blocksfor a concurrent program in Swift.There's another special actor we often talk aboutcalled the main actor.Think of the main actor as a big islandin the middle of the sea.It represents the main thread, where all of the drawingand interaction for your user interface occurs.So if you want to draw something,you need to run the code on the main actor's island.It's so important for your UI,that maybe we should even call it the “U-I-land."When we say that the main actor is “big,”what we mean is that it contains a lot of staterelated to the program's user interface.There's a lot of code,both in the UI frameworks and in your apps,that needs to run on it.However, it's still an actor,so it only runs one job at a time.So you have to be careful not to put too muchor long-running work on the main actor,because it can make your UI unresponsive.Isolation to the main actoris expressed with the MainActor attribute.This attribute can be applied to a function or closureto indicate that the code must run on the main actor.Then, we say that this code is isolated to the main actor.The Swift compiler will guaranteethat main-actor-isolated code will only be executedon the main thread, using the same mechanismthat ensures mutually exclusive access to other actors.If one calls updateViewfrom a context that isn't isolated to the main actor,it will need to introduce an “await”to account for the switch over to the main actor.The main actor attribute can also be applied to types,in which case the instances of those typeswill be isolated to the main actor.Again, this is just like any other actor --the properties are only accessiblewhile on the main actor, and the methods are isolatedto the main actor unless they explicitly opt out.Like normal actors,references to main-actor classes are themselves Sendable,because their data is isolated.This makes the main actor annotation suitablefor your UI views and view controllers,which are necessarily tied to the main threadby the frameworks themselves.You can share a reference to your view controllerwith other tasks and actors in your program,and they can asynchronously call back into the view controllerto post results.This has a direct effect on your app's architecture.In your app,your views and view controllers will be on the main actor.Other program logic should be separated from that main actor,using other actors to safely model shared stateand tasks to describe independent work.And those tasks can shuttle between the main actorand other actors as necessary.There's a lot going on in a concurrent app,so we've built some great tools to help you make sense of it.I invite you to check outthe "Visualize and Optimize Swift Concurrency" talkto learn more.Let's dive into some deeper waters to talk about atomicity.The goal of the Swift Concurrency modelis to eliminate data races.What that really means is that it eliminateslow-level data races, which involve data corruption.You still need to reason about atomicity at a high level.As we've talked about before,actors only run one task at a time.However, when you stop running on an actor,the actor can run other tasks.This ensures that the program makes progress,eliminating the potential for deadlocks.However, it requires you to consider your actor's invariantscarefully around await statements.Otherwise, you can end up with a high-level data racewhere the program is in an unexpected state,even though no data is actually corrupted.Let's break down an example of this.Here we have a function that intends to depositsome additional pineapples on an island.It's outside of an actor, so it's non-isolated async code.That means it runs out here in the open sea.It's been given some pineapples and a map to the islandwhere it should deposit those pineapples.The first interesting operation heregets a copy of the food array from the island.To do that, the boat needs to visit the island,signaled by the “await” keyword.As soon as it has a copy of the food,the boat heads back out to the open seato continue its work.That means adding the pineapple from the pineapples parameterto the two it got from the island.Now, we can move along to the last line of the function.Our boat now needs to visit the island againto set the island's food array to those three pineapples.Here, everything worked out fine,and we have the three pineapples on the island!But things could have gone a bit differently.Let's say a pirate ship snuck in and stole all of the pineappleswhile our first boat was waiting its turn to visit the island.Now, our original ship deposits its three pineappleson the island, and we notice a problem.The three pineapples have suddenly turnedinto five pineapples!What happened here?Well, notice that we have two awaitsfor access to state on the same actor,and we're making an assumption herethat the food array on the islanddoesn't change between those two awaits.But these are awaits,meaning that our task could get suspended hereand the actor could do other higher-priority work,like battling pirates.In this specific case, the Swift compiler will rejectan attempt to outright modify the state on another actor.However, we should really rewrite our deposit operationas synchronous code on the actor, like this.Because this is synchronous code,it will run on the actor without interruption.So we can be sure that the state of the islandwill be unchanged by anyone else throughout the entire function.When you are writing your actor,think in terms of synchronous, transactional operationsthat can be interleaved in any way.Every one of them should ensure that the actoris in a good state when it exits.For async actor operations, keep them simple,forming them primarily from your synchronous,transactional operations,and take care that your actor is in a good stateat each await operation.This way, you can make full use of actors to eliminateboth low-level and high-level data races.In a concurrent program,many things are happening at once,so the order in which those things happencan vary from one execution to the next.And yet programs often rely on handling eventsin a consistent order.For example, the stream of eventsthat come in from user input or messages from a server.When these event streams come in,we expect their effects to happen in order.Swift Concurrency provides tools for ordering operations,however, actors are not the tool for doing so.Actors execute the highest-priority work first,to help the overall system stay responsive.This eliminates priority inversionswhere lower-priority work ends up happeningbefore higher-priority work on the same actor.Note that this is a significant differencefrom serial Dispatch queues,which execute in a strictly First-In, First-Out order.Swift Concurrency has several tools for ordering work.The first we've been talking about a lot already -- tasks.Tasks execute from beginning to end,with the normal control flow you're used to,so they naturally order work.AsyncStream can be used to model an actual stream of events.One task can iterate over the stream of eventswith a for-await-in loop, processing each event in turn.An AsyncStream can be sharedwith any number of event producers,which can add elements to the streamwhile maintaining order.We've talked a lot about how Swift's concurrency modelis designed to eliminate data racesusing the notion of isolation, which is maintainedby Sendable checking at task and actor boundaries.However, we cannot all just stop what we are doingto go mark all of the Sendable types everywhere.Instead, we need an incremental approach.Swift 5.7 introduces a build setting to specifyhow strictly the Swift compiler should check for Sendability.The default setting is Minimalmeaning that the compiler will only diagnose placeswhere one has explicitly tried to mark something as Sendable.This is similar to how Swift 5.5 and 5.6 behaved,and for the above, there won't be any warnings or errors.Now, if you add a Sendable conformance,the compiler will complain that the Coop typecannot be Sendable because Chicken isn't Sendable.However, this -- and other Sendable-related problems --will be presented as warnings in Swift 5, not errors,to make it easier to work through the problems one by one.To move further toward data race safety,enable the “targeted” strict concurrency setting.This setting enables Sendable checking for codethat has already adopted Swift Concurrency featureslike async/await, tasks, or actors.This will identify, for example,attempts to capture values of non-Sendable typein a newly created task.Sometimes the non-Sendable types come from another module.Perhaps it's some package that hasn't been updatedfor Sendable yet, or even your own modulethat you just haven't gotten around to.For those, you can temporarily disable the Sendable warningsfor types that come from that moduleusing the @preconcurrency attribute.This will silence Sendable warnings for the Chicken typewithin this source file.At some point, the FarmAnimals modulewill get updated with Sendable conformances.Then, one of two things will happen:either Chicken becomes Sendable somehow,in which case the preconcurrency attribute can be removedfrom the import.Or Chicken will be known to be non-Sendable,in which case the warning will come back,indicating that your assumptions about Chicken being Sendableare, in fact, not correct.The targeted strictness setting tries to strike a balancebetween compatibility with existing codeand identifying potential data races.However, if you'd like to seeeverywhere that races could occur,there is one more option: complete checking.Complete checking approximates the intended Swift 6 semanticsto completely eliminate data races.It checks everything that the earlier two modes checkbut does so for all code in the module.Here, we're not actually making useof Swift's concurrency features at all.Rather, it's performing work on a dispatch queue,which will execute that code concurrently.The async operation on a dispatch queueis actually known to take a Sendable closure,so the compiler produces a warning indicatingthat there is a data race when the non-Sendable bodyis captured by the code running on the dispatch queue.We can fix this by making the body parameter Sendable.That change eliminates this warning,and now all of the callers of doWork knowthat they need to provide a Sendable closure.That means we get better checking for data races,and we can see that the visit function nowis the source of a data race.Complete checking will help flush outthe potential data races in your program.To achieve Swift's goal of eliminating data races,we'll eventually need to get to complete checking.We encourage you to work incrementally toward that goal:adopt Swift's concurrency modelto architect your app for data race safety,then enable progressively stricter concurrency checkingto eliminate classes of errors from your code.And don't fret over marking your imports with @preconcurrencyto suppress warnings for imported types.As those modules adopt stricter concurrency checking,the compiler will recheck your assumptions.At the end of this road, your code will benefitfrom both memory safety and data race safety,helping you focus on building great apps.And thank you for sailing with me on the sea of concurrency.♪

♪ Mellow instrumental hip-hop music ♪♪Hello.

I'm Doug from the Swift team, and I'm here to talk aboutSwift Concurrency's approach to eliminating data races.

We introduced Swift Concurrency as a set of language featuresthat make it easier to write concurrent programs.

For the mechanics of these individual language features,we refer you to the 2021 WWDC talks covering each of them.

This talk takes a different,more holistic view of Swift Concurrencyas a way of structuring your program to makeefficient use of concurrency without introducing data races.

But to do so, we need a great analogy,so we invite you to sail with us on the high seas of concurrency.

The sea of concurrency is unpredictable,with many things going on at once,but with you at the helm and Swift helping you navigatethe waters, it can produce amazing things.

Let's dive in!We'll start by talking about isolation,which is one of the key ideas of Swift's concurrency model,ensuring that data is not shared in a mannerthat can introduce data races.

Let's start with task isolation.

In our sea of concurrency, tasks are represented by boats.

Boats are our main workers -- they have a job to do,which they perform sequentially from start to finish.

They are asynchronous, and their work can be suspendedany number of times at "await" operations in the code.

Finally, they are self-contained:each task has its own resources, so it can operate by itself,independently of all of the other boats in the sea.

If our boats are completely independent,we have concurrency without data races,but it's not very useful without some way to communicate.

Let's add some communication!For example, one boat might havea pineapple that it wants to share with another boat.

So the boats meet on the open sea,and we transfer the pineapple from one boat to the other.

Now, this is where the physical analogybreaks down a little bit, because this pineappleis not a physical item that moves from one boat to the next.

It's data, and in Swift we have a couple of different wayswe could represent that data.

How do we define our pineapple type?We like value types in Swift, so let's make the pineapplea struct that's defined by its weight and ripeness.

Let's see how this works.

When the boats meet on the open sea,we're really passing a copy of the pineapple instancefrom one boat to the next,and each boat goes away with its own copy.

If you were to mutate the copies,such as by calling the slice() and ripen() methods,it won't have any effect on the other one.

Swift has always preferred value typesfor exactly this reason --mutations have only local effects.

That principle helps value types maintain isolation.

Now, let's extend our data model a bit and add chickens!Unlike pineapples, which are pretty muchonly good for eating, chickens are beautiful creatureswith their own unique personalities.

So, we're going to model them with a class, like this.

Let's have our intrepid seafarers exchange a chicken.

When our boats meet, we share the chicken,except that copying a reference type like chickendoesn't give you another full copy of the chicken,it gives you a reference to that specific object.

So once our boats have gone their separate ways,we can see that we have a problem:both boats are doing their work concurrently,but they are not independentbecause they both reference the same chicken object.

That shared mutable data is prone to data races,such as when one boat is trying to feed the chickenand the other wants to play with it,leading to one very confused chicken.

We need a way to know that it was safe to share pineapplesamongst boats, but not chickens.

And then we need some checking in place in the Swift compilerto ensure that chickens aren't accidentally passedfrom one boat to another.

Swift protocols are a great way of categorizing typesso you can reason about their behavior.

The Sendable protocol is used to describe typesthat can safely be shared across different isolation domains,without creating data races.

A type can be made Sendable by writing a conformance.

The Pineapple struct conforms to Sendablebecause it's a value type, but the Chicken class cannotbecause it's an unsynchronized reference type.

Modeling Sendable as a protocol allows us to describethe places where data is going to be sharedacross isolation domains.

For example, when a task returns a value,this value is provided to any of the tasksthat are waiting for that value.

Here, we are trying to return a Chicken from our Task,and we get an error stating that this is unsafebecause Chicken is not Sendable.

The actual Sendable constraint comes from the definitionof the Task struct itself, which specifies thatthe result type of a Task, called Success,must conform to the Sendable protocol.

You should use Sendable constraintswhere you have generic parameters whose valueswill be passed across different isolation domains.

Now, let's revisit the idea of sharing data among boats.

When two boats meet on the high seas and want to share data,we need someone to consistently check all of the goodsto make sure they're safe to share.

That's the role of our friendly customs inspector --played here by the Swift compiler --to make sure that only Sendable types are exchanged.

The pineapple is fine and can be exchanged freely,because it's Sendable.

However, the chicken cannot be exchanged,and our friendly customs inspector will prevent usfrom making that mistake.

The compiler is involved in checking Sendable correctnessat many different points.

Sendable types must be correct by construction,and cannot allow any shared data to be smuggled through them.

Enums and structs generally define value types,which copy all of their instance data along with themto produce independent values.

Therefore, they can be Sendableso long as all of their instance data is also Sendable.

Sendable can be propagated through collectionsand other generic types using conditional conformance.

An array of Sendable types is Sendable,so a Crate full of pineapples is also Sendable.

All of these Sendable conformances can even beinferred by the Swift compiler for non-public types,so Ripeness, Pineapple, and Crateare all implicitly Sendable.

But let's say we create a coop to house our flock of chickens.

This type cannot be marked as Sendable,because it contains non-Sendable state:Chicken isn't Sendable, so the array of chickensisn't Sendable.

We'll get an error message from our compiler to indicatethat this type cannot safely be shared.

Classes are reference types, so they can only bemade Sendable under very narrow circumstances,such as when a final class only has immutable storage.

Our attempt to make the Chicken class Sendablewill produce an error because it contains mutable state.

Now, it is possible to implement reference typesthat do their own internal synchronization, for example,by using a lock consistently.

These types are conceptually Sendable,but there is no way for Swift to reason about that.

Use unchecked Sendable to disable the compiler's checking.

Be careful with this, because smuggling mutable statethrough @unchecked Sendableundermines the data race safety guarantees Swift is providing.

Task creation involves executing a closure in a new,independent task, like sending off a rowboat from your boat.

When we do this, we can capture values from the original taskand pass them into the new task,so we need Sendable checkingto ensure we don't introduce data races.

If we do try to share a non-Sendable typeacross this boundary, the Swift compiler has us covered,producing an error message like this one.

This isn't magic for task creation.

The closure is being inferred to be a Sendable closure,which could have been written explicitly with At-Sendable.

Sendable closures are values of Sendable function type.

At-Sendable can be written on a function type to indicatethat the function type conforms to the Sendable protocol.

That implies that values of that function typecan be passed to other isolation domains and called therewithout introducing data races on their captured state.

Normally, function types cannot conform to protocols,but Sendable is special because the compiler validatesthe semantic requirements for it.

There is similar support for tuples of Sendable typesconforming to the Sendable protocol,which allows Sendable to be usedthroughout the entire language.

The system we've described has many concurrently executingtasks that are isolated from each other.

The Sendable protocol describes typesthat can be safely shared among tasks,and the Swift compiler checks Sendable conformancesat every level to maintain isolation of the tasks.

However, without any notion of shared mutable data anywhere,it's hard for the tasksto coordinate in a meaningful manner.

So we need some way to share data amongst our tasksthat doesn't re-introduce data races.

This is where actors come in.

Actors provide a way to isolate statethat can be accessed by different tasks,but in a coordinated manner that eliminates data races.

Actors are the islands in our sea of concurrency.

Like boats, each island is self-contained,with its own state that is isolatedfrom everything else in the sea.

To access that state, your code needs to be runningon the island.

For example, the advanceTime methodis isolated to this island.

It lives on the island and has accessto all of the island's state.

To actually run code on an island, you need a boat.

A boat can visit the island to run code on the island,at which point it has access to that state.

Only one boat can visit the island to run code at a time,which ensures that there is no concurrent accessto the island's state.

If other boats show up, they must await their turnto visit the island.

And because it might be a long time before a given boatgets a chance to visit the island, entering into an actoris a potential suspension point marked by the “await” keyword.

Once the island frees up -- again, at a suspension point --another boat can visit.

Just like with two boats meeting on the open sea,interactions between a boat and an island need to maintainisolation of both, by making surethat non-Sendable types don't pass between the two.

For example, perhaps we try to add a chicken from our boatto the flock on the island.

This would create two references to the same chicken objectfrom different isolation domains,so the Swift compiler rejects it.

Similarly, if we try to adopt a pet chicken from the islandand take it away on our boat, Sendable checking ensuresthat we cannot create this data race.

Actors are reference types, but unlike classes, they isolateall of their properties and code to prevent concurrent access.

Therefore, having a reference to an actorfrom a different isolation domain is safe.

It's like having a map to an island:you can use the map to go visit the island,but you still need to go through the docking procedureto access its state.

Therefore, all actor types are implicitly Sendable.

You might be wondering how to knowwhat code is isolated to the actor and what code isn't.

Actor isolation is determined by the context you're in.

The instance properties of an actorare isolated to that actor.

Instance methods on the actor or an extension of the actorare also isolated by default, like this advanceTime method.

Closures that are not Sendable, such as the closure passedto the reduce algorithm, stay on the actor and areactor-isolated when they are in an actor-isolated context.

The task initializer also inherits actor isolationfrom its context, so the created task will bescheduled on the same actor as it was initiated from.

Here, that grants access to the flock.

On the other hand, a detached taskdoes not inherit actor isolation from its context,because it is completely independent of the contextwhere it was created.

We can see that the code in the closure hereis considered to be outside the actor because it needsto use “await” to refer to the isolated “food” property.

We have a term for this closure: it's non-isolated code.

No-isolated code is codethat does not run on any actor at all.

You can explicitly make a function that's withinan actor non-isolated by using the non-isolated keyword,putting it outside of the actor.

Just like what happened implicitly with the closure usedfor the detached task.

That means if we want to read some of the statethat's isolated to the actor, we'll need to use “await”to visit the island and grab a copy of the state we need.

Non-isolated async codealways runs on the global cooperative pool.

Think of it as only running when a boat is out on the open sea,so you have to leave the island you're visiting to do the work.

That means checking to ensurethat you aren't taking any non-Sendable data with you!Here, the compiler detects the potential data race,where an instance of the non-Sendable Chickenis trying to leave the island.

Let's consider one more case of non-isolated code.

The “greet” operation is non-isolated, synchronous code.

It knows nothing about boats or islandsor concurrency in general.

And here, we're calling itfrom the actor-isolated greetOne function,and that's okay!This synchronous code,when called from the island, will stay on the island,so it's free to operate on the chicken from the flock.

If instead we had a non-isolated async operationthat calls “greet,”then “greet” will run there, on a boat, in the open sea.

Most Swift code is like this:synchronous, non-isolated to any actor,and only operates on the parameters it's been given,so it stays in the isolation domain where it is called.

Actors hold state that is isolatedfrom the rest of the program.

Only one task can run on an actor at a time,so there is no concurrent access to that state.

Sendable checking applies any timea task enters or exits an actor to ensurethat no unsynchronized mutable state escapes.

Altogether, this makes actors one of the building blocksfor a concurrent program in Swift.

There's another special actor we often talk aboutcalled the main actor.

Think of the main actor as a big islandin the middle of the sea.

It represents the main thread, where all of the drawingand interaction for your user interface occurs.

So if you want to draw something,you need to run the code on the main actor's island.

It's so important for your UI,that maybe we should even call it the “U-I-land."When we say that the main actor is “big,”what we mean is that it contains a lot of staterelated to the program's user interface.

There's a lot of code,both in the UI frameworks and in your apps,that needs to run on it.

However, it's still an actor,so it only runs one job at a time.

So you have to be careful not to put too muchor long-running work on the main actor,because it can make your UI unresponsive.

Isolation to the main actoris expressed with the MainActor attribute.

This attribute can be applied to a function or closureto indicate that the code must run on the main actor.

Then, we say that this code is isolated to the main actor.

The Swift compiler will guaranteethat main-actor-isolated code will only be executedon the main thread, using the same mechanismthat ensures mutually exclusive access to other actors.

If one calls updateViewfrom a context that isn't isolated to the main actor,it will need to introduce an “await”to account for the switch over to the main actor.

The main actor attribute can also be applied to types,in which case the instances of those typeswill be isolated to the main actor.

Again, this is just like any other actor --the properties are only accessiblewhile on the main actor, and the methods are isolatedto the main actor unless they explicitly opt out.

Like normal actors,references to main-actor classes are themselves Sendable,because their data is isolated.

This makes the main actor annotation suitablefor your UI views and view controllers,which are necessarily tied to the main threadby the frameworks themselves.

You can share a reference to your view controllerwith other tasks and actors in your program,and they can asynchronously call back into the view controllerto post results.

This has a direct effect on your app's architecture.

In your app,your views and view controllers will be on the main actor.

Other program logic should be separated from that main actor,using other actors to safely model shared stateand tasks to describe independent work.

And those tasks can shuttle between the main actorand other actors as necessary.

There's a lot going on in a concurrent app,so we've built some great tools to help you make sense of it.

I invite you to check outthe "Visualize and Optimize Swift Concurrency" talkto learn more.

Let's dive into some deeper waters to talk about atomicity.

The goal of the Swift Concurrency modelis to eliminate data races.

What that really means is that it eliminateslow-level data races, which involve data corruption.

You still need to reason about atomicity at a high level.

As we've talked about before,actors only run one task at a time.

However, when you stop running on an actor,the actor can run other tasks.

This ensures that the program makes progress,eliminating the potential for deadlocks.

However, it requires you to consider your actor's invariantscarefully around await statements.

Otherwise, you can end up with a high-level data racewhere the program is in an unexpected state,even though no data is actually corrupted.

Let's break down an example of this.

Here we have a function that intends to depositsome additional pineapples on an island.

It's outside of an actor, so it's non-isolated async code.

That means it runs out here in the open sea.

It's been given some pineapples and a map to the islandwhere it should deposit those pineapples.

The first interesting operation heregets a copy of the food array from the island.

To do that, the boat needs to visit the island,signaled by the “await” keyword.

As soon as it has a copy of the food,the boat heads back out to the open seato continue its work.

That means adding the pineapple from the pineapples parameterto the two it got from the island.

Now, we can move along to the last line of the function.

Our boat now needs to visit the island againto set the island's food array to those three pineapples.

Here, everything worked out fine,and we have the three pineapples on the island!But things could have gone a bit differently.

Let's say a pirate ship snuck in and stole all of the pineappleswhile our first boat was waiting its turn to visit the island.

Now, our original ship deposits its three pineappleson the island, and we notice a problem.

The three pineapples have suddenly turnedinto five pineapples!What happened here?Well, notice that we have two awaitsfor access to state on the same actor,and we're making an assumption herethat the food array on the islanddoesn't change between those two awaits.

But these are awaits,meaning that our task could get suspended hereand the actor could do other higher-priority work,like battling pirates.

In this specific case, the Swift compiler will rejectan attempt to outright modify the state on another actor.

However, we should really rewrite our deposit operationas synchronous code on the actor, like this.

Because this is synchronous code,it will run on the actor without interruption.

So we can be sure that the state of the islandwill be unchanged by anyone else throughout the entire function.

When you are writing your actor,think in terms of synchronous, transactional operationsthat can be interleaved in any way.

Every one of them should ensure that the actoris in a good state when it exits.

For async actor operations, keep them simple,forming them primarily from your synchronous,transactional operations,and take care that your actor is in a good stateat each await operation.

This way, you can make full use of actors to eliminateboth low-level and high-level data races.

In a concurrent program,many things are happening at once,so the order in which those things happencan vary from one execution to the next.

And yet programs often rely on handling eventsin a consistent order.

For example, the stream of eventsthat come in from user input or messages from a server.

When these event streams come in,we expect their effects to happen in order.

Swift Concurrency provides tools for ordering operations,however, actors are not the tool for doing so.

Actors execute the highest-priority work first,to help the overall system stay responsive.

This eliminates priority inversionswhere lower-priority work ends up happeningbefore higher-priority work on the same actor.

Note that this is a significant differencefrom serial Dispatch queues,which execute in a strictly First-In, First-Out order.

Swift Concurrency has several tools for ordering work.

The first we've been talking about a lot already -- tasks.

Tasks execute from beginning to end,with the normal control flow you're used to,so they naturally order work.

AsyncStream can be used to model an actual stream of events.

One task can iterate over the stream of eventswith a for-await-in loop, processing each event in turn.

An AsyncStream can be sharedwith any number of event producers,which can add elements to the streamwhile maintaining order.

We've talked a lot about how Swift's concurrency modelis designed to eliminate data racesusing the notion of isolation, which is maintainedby Sendable checking at task and actor boundaries.

However, we cannot all just stop what we are doingto go mark all of the Sendable types everywhere.

Instead, we need an incremental approach.

Swift 5.7 introduces a build setting to specifyhow strictly the Swift compiler should check for Sendability.

The default setting is Minimalmeaning that the compiler will only diagnose placeswhere one has explicitly tried to mark something as Sendable.

This is similar to how Swift 5.5 and 5.6 behaved,and for the above, there won't be any warnings or errors.

Now, if you add a Sendable conformance,the compiler will complain that the Coop typecannot be Sendable because Chicken isn't Sendable.

However, this -- and other Sendable-related problems --will be presented as warnings in Swift 5, not errors,to make it easier to work through the problems one by one.

To move further toward data race safety,enable the “targeted” strict concurrency setting.

This setting enables Sendable checking for codethat has already adopted Swift Concurrency featureslike async/await, tasks, or actors.

This will identify, for example,attempts to capture values of non-Sendable typein a newly created task.

Sometimes the non-Sendable types come from another module.

Perhaps it's some package that hasn't been updatedfor Sendable yet, or even your own modulethat you just haven't gotten around to.

For those, you can temporarily disable the Sendable warningsfor types that come from that moduleusing the @preconcurrency attribute.

This will silence Sendable warnings for the Chicken typewithin this source file.

At some point, the FarmAnimals modulewill get updated with Sendable conformances.

Then, one of two things will happen:either Chicken becomes Sendable somehow,in which case the preconcurrency attribute can be removedfrom the import.

Or Chicken will be known to be non-Sendable,in which case the warning will come back,indicating that your assumptions about Chicken being Sendableare, in fact, not correct.

The targeted strictness setting tries to strike a balancebetween compatibility with existing codeand identifying potential data races.

However, if you'd like to seeeverywhere that races could occur,there is one more option: complete checking.

Complete checking approximates the intended Swift 6 semanticsto completely eliminate data races.

It checks everything that the earlier two modes checkbut does so for all code in the module.

Here, we're not actually making useof Swift's concurrency features at all.

Rather, it's performing work on a dispatch queue,which will execute that code concurrently.

The async operation on a dispatch queueis actually known to take a Sendable closure,so the compiler produces a warning indicatingthat there is a data race when the non-Sendable bodyis captured by the code running on the dispatch queue.

We can fix this by making the body parameter Sendable.

That change eliminates this warning,and now all of the callers of doWork knowthat they need to provide a Sendable closure.

That means we get better checking for data races,and we can see that the visit function nowis the source of a data race.

Complete checking will help flush outthe potential data races in your program.

To achieve Swift's goal of eliminating data races,we'll eventually need to get to complete checking.

We encourage you to work incrementally toward that goal:adopt Swift's concurrency modelto architect your app for data race safety,then enable progressively stricter concurrency checkingto eliminate classes of errors from your code.

And don't fret over marking your imports with @preconcurrencyto suppress warnings for imported types.

As those modules adopt stricter concurrency checking,the compiler will recheck your assumptions.

At the end of this road, your code will benefitfrom both memory safety and data race safety,helping you focus on building great apps.

And thank you for sailing with me on the sea of concurrency.

♪

1:18 -Tasks

2:31 -What is the pineapple?

3:15 -Adding chickens

4:35 -Sendable protocol

4:44 -Use conformance to specify which types are Sendable

4:57 -Check Sendable across task boundaries

5:26 -The Sendable constraint is from the Task struct

6:23 -Sendable checking for enums and structs

6:52 -Sendable checking for enums and structs with collections

7:17 -Sendable checking for enums and structs with non-Sendable collections

7:36 -Sendable checking in classes

7:58 -Reference types that do their own internal synchronization

8:21 -Sendable checking during task creation

9:08 -Sendable function types

10:28 -Actors

11:03 -Only one boat can visit an island at a time

11:34 -Non-Sendable data cannot be shared between a task and actor

12:43 -What code is actor-isolated?

14:03 -Nonisolated code

14:48 -Non-isolated synchronous code

15:15 -Non-isolated asynchronous code

17:01 -Isolating functions to the main actor

17:38 -@MainActor types

19:58 -Non-transactional code

20:56 -Pirates!

21:57 -Modify `deposit` function to be synchronous

23:56 -AsyncStreams deliver elements in order

25:02 -Minimal strict concurrency checking

25:21 -Targeted strict concurrency checking

26:53 -Complete strict concurrency checking

## Code Samples

```swift
Task
.detached {
  
let
 fish 
=
 
await
 catchFish()
  
let
 dinner 
=
 
await
 cook(fish)
  
await
 eat(dinner)
}
```

```swift
enum
 
Ripeness
 {
  
case
 hard
  
case
 perfect
  
case
 mushy(daysPast: 
Int
)
}


struct
 
Pineapple
 {
  
var
 weight: 
Double

  
var
 ripeness: 
Ripeness

  
  
mutating
 
func
 
ripen
() 
async
 { 
…
 }
  
mutating
 
func
 
slice
() -> 
Int
 { 
…
 }
}
```

```swift
final
 
class
 
Chicken
 {
  
let
 name: 
String

  
var
 currentHunger: 
HungerLevel

  
  
func
 
feed
() { 
…
 }
  
func
 
play
() { 
…
 }
  
func
 
produce
() -> 
Egg
 { 
…
 }
}
```

```swift
protocol
 
Sendable
 { }
```

```swift
struct
 
Pineapple
: 
Sendable
 { 
…
 } 
//conforms to Sendable because its a value type


class
 
Chicken
: 
Sendable
 { } 
// cannot conform to Sendable because its an unsynchronized reference type.
```

```swift
// will get an error because Chicken is not Sendable


let
 petAdoption 
=
 
Task
 {
  
let
 chickens 
=
 
await
 hatchNewFlock()
  
return
 chickens.randomElement()
!

}

let
 pet 
=
 
await
 petAdoption.value
```

```swift
struct
 
Task
<
Success
: 
Sendable
, 
Failure
: 
Error
> {
  
var
 value: 
Success
 {
    
get
 
async
 
throws
 { 
…
 }
  }
}
```

```swift
enum
 
Ripeness
: 
Sendable
 {
  
case
 hard
  
case
 perfect
  
case
 mushy(daysPast: 
Int
)
}


struct
 
Pineapple
: 
Sendable
 {
  
var
 weight: 
Double

  
var
 ripeness: 
Ripeness

}
```

```swift
//contains an array of Sendable types, therefore is Sendable


struct
 
Crate
: 
Sendable
 {
  
var
 pineapples: [
Pineapple
]
}
```

```swift
//stored property 'flock' of 'Sendable'-conforming struct 'Coop' has non-sendable type '[Chicken]'


struct
 
Coop
: 
Sendable
 {
  
var
 flock: [
Chicken
]
}
```

```swift
//Can be Sendable if a final class has immutable storage


final
 
class
 
Chicken
: 
Sendable
 {
  
let
 name: 
String

  
var
 currentHunger: 
HungerLevel
 
//'currentHunger' is mutable, therefore Chicken cannot be Sendable

}
```

```swift
//@unchecked can be used, but be careful!


class
 
ConcurrentCache
<
Key
: 
Hashable
 & 
Sendable
, 
Value
: 
Sendable
>: @
unchecked
 
Sendable
 {
  
var
 lock: 
NSLock

  
var
 storage: [
Key
: 
Value
]
}
```

```swift
let
 lily 
=
 
Chicken
(name: 
"Lily"
)

Task
.detached {
@Sendable
 
in

	lily.feed()
}
```

```swift
struct
 
Task
<
Success
: 
Sendable
, 
Failure
: 
Error
> {
  
static
 
func
 
detached
(
    
priority
: 
TaskPriority
? 
=
 
nil
,
    
operation
: 
@Sendable
 
@escaping
 () 
async
 
throws
 -> 
Success

  ) -> 
Task
<
Success
, 
Failure
>
}
```

```swift
actor
 
Island
 {
  
var
 flock: [
Chicken
]
  
var
 food: [
Pineapple
]

  
func
 
advanceTime
()
}
```

```swift
func
 
nextRound
(
islands
: [
Island
]) 
async
 {
  
for
 island 
in
 islands {
    
await
 island.advanceTime()
  }
}
```

```swift
//Both examples cannot be shared


await
 myIsland.addToFlock(myChicken)
myChicken 
=
 
await
 myIsland.adoptPet()
```

```swift
actor
 
Island
 {
  
var
 flock: [
Chicken
]
  
var
 food: [
Pineapple
]

  
func
 
advanceTime
() {
    
let
 totalSlices 
=
 food.indices.reduce(
0
) { (total, nextIndex) 
in

      total 
+
 food[nextIndex].slice()
    }

    
Task
 {
      flock.map(
Chicken
.produce)
    }

    
Task
.detached {
      
let
 ripePineapples 
=
 
await
 food.filter { 
$0
.ripeness 
==
 .perfect }
      
print
(
"There are 
\(ripePineapples.count)
 ripe pineapples on the island"
)
    }
  }
}
```

```swift
extension
 
Island
 {
  
nonisolated
 
func
 
meetTheFlock
() 
async
 {
    
let
 flockNames 
=
 
await
 flock.map { 
$0
.name }
    
print
(
"Meet our fabulous flock: 
\(flockNames)
"
)
  }
}
```

```swift
func
 
greet
(
_
 
friend
: 
Chicken
) { }


extension
 
Island
 {
  
func
 
greetOne
() {
    
if
 
let
 friend 
=
 flock.randomElement() { 
      greet(friend)
    }
  }
}
```

```swift
func
 
greet
(
_
 
friend
: 
Chicken
) { }


func
 
greetAny
(
flock
: [
Chicken
]) 
async
 {
  
if
 
let
 friend 
=
 flock.randomElement() { 
    greet(friend)
  }
}
```

```swift
@MainActor
 
func
 
updateView
() { 
…
 }


Task
 { 
@MainActor
 
in

	
// …

  view.selectedChicken 
=
 lily
}


nonisolated
 
func
 
computeAndUpdate
() 
async
 {
  computeNewValues()
  
await
 updateView()
}
```

```swift
@MainActor


class
 
ChickenValley
: 
Sendable
 {
  
var
 flock: [
Chicken
]
  
var
 food: [
Pineapple
]

  
func
 
advanceTime
() {
    
for
 chicken 
in
 flock {
      chicken.eat(from: 
&
food)
    }
  }
}
```

```swift
func
 
deposit
(
pineapples
: [
Pineapple
], 
onto
 
island
: 
Island
) 
async
 {
   
var
 food 
=
 
await
 island.food
   food 
+=
 pineapples
   
await
 island.food 
=
 food
}
```

```swift
await
 island.food.takeAll()
```

```swift
extension
 
Island
 {
   
func
 
deposit
(
pineapples
: [
Pineapple
]) {
      
var
 food 
=
 
self
.food
      food 
+=
 pineapples
      
self
.food 
=
 food
   }
}
```

```swift
for
 
await
 event 
in
 eventStream {
  
await
 process(event)
}
```

```swift
import
 FarmAnimals

struct
 
Coop
: 
Sendable
 {
  
var
 flock: [
Chicken
]
}
```

```swift
@preconcurrency
 
import
 FarmAnimals


func
 
visit
(
coop
: 
Coop
) 
async
 {
  
guard
 
let
 favorite 
=
 coop.flock.randomElement() 
else
 {
    
return

  }

  
Task
 {
    favorite.play()
  }
}
```

```swift
import
 FarmAnimals


func
 
doWork
(
_
 
body
: 
@Sendable
 
@escaping
 () -> 
Void
) {
  
DispatchQueue
.global().async {
    body()
  }
}


func
 
visit
(
friend
: 
Chicken
) {
  doWork {
    friend.play()
  }
}
```


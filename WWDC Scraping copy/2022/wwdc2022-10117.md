# Wwdc2022 10117

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Enhance voice communication with Push to TalkWe're coming in loud and clear to help you bring walkie-talkie communication to your app — over! Discover how you can add prominent system UI to your Push to Talk app, enabling rapid communication with the tap of a button. We'll introduce you to the PushToTalk framework and show you how to configure your apps to transmit and receive audio — even from the background.

To get the most out of this session, we recommend familiarity with handling audio transmission on your app backend. We also recommend a basic understanding of APNs.ResourcesPush to TalkHD VideoSD VideoRelated VideosTech TalksWhat's new for enterprise developersWWDC22Power down: Improve battery consumptionReduce networking delays for a more responsive appWWDC22 Day 2 recap

We're coming in loud and clear to help you bring walkie-talkie communication to your app — over! Discover how you can add prominent system UI to your Push to Talk app, enabling rapid communication with the tap of a button. We'll introduce you to the PushToTalk framework and show you how to configure your apps to transmit and receive audio — even from the background.

To get the most out of this session, we recommend familiarity with handling audio transmission on your app backend. We also recommend a basic understanding of APNs.

Push to Talk

HD VideoSD Video

HD Video

SD Video

What's new for enterprise developers

Power down: Improve battery consumption

Reduce networking delays for a more responsive app

WWDC22 Day 2 recap

Search this video…♪ Mellow instrumental hip-hop music ♪♪Kevin Ferrell: Hi, my name is Kevin,and I'm an engineer working on the new PushToTalk framework,which enables a walkie-talkie system experiencefor apps on iOS.Later I'll be joined by my colleague Trevorto talk about how you can enhance voice communicationin your apps with this new framework.First, I'll introduce the PushToTalk frameworkand explain how it fits into your app.Next, we'll go over how to configure your appfor PushToTalk.After that, Trevor will walk throughhow to transmit and receive audio using the framework.Finally, Trevor will wrap up with best practicesfor enhancing the Push To Talk user experiencewhile preserving battery life for your users.I'll get started by introducing key featuresof the new PushToTalk framework.The PushToTalk framework enables you to builda new class of audio communication app on iOSthat provides a walkie-talkie style experience for your users.Push To Talk apps have many usesin fields where rapid communication is essentialsuch as health care and emergency services.To provide a great Push To Talk experience,users need a way to quickly accessaudio transmission features while also being able to seewho is responding to them.At the same time, a Push To Talk appmust be power efficient to ensure that userscan maintain all-day battery life while using the app.The PushToTalk framework provides you with APIsto utilize a system UIthat users can access anywhere on the systemwithout having to directly launch your app.The system UI allows a user to quickly activatean audio transmission, which will launch your appin the background to record and stream audio to your server.The system provides transparency to usersby showing who's speakingwhen your app plays audio from your server.The PushToTalk framework accomplishes thisby introducing a new push notification typethat notifies your app when new audio is available for playback.When your app receives this notification,it is launched in the backgroundso that it can stream and play audio.The PushToTalk framework is designed to be compatiblewith existing end-to-end communication solutionsand backend infrastructure.If you've already implementeda Push To Talk workflow in your app,it should be easy for you to integratethe PushToTalk framework into your existing code.The framework allows your app to implementits own audio encoding and streaming processto transmit audio between users.This provides flexibility in how audio transmissionis handled by your app and enables compatibilitywith other platforms.Finally, many Push To Talk appsrely on wireless Bluetooth accessoriesto trigger audio recording and transmission.Your apps can continue to integrate with these accessoriesusing the CoreBluetooth frameworkand can trigger audio recording in PushToTalk.If you are building your first Push To Talk app,keep these integration considerations in mindas you begin architecting your code.Before we begin walking through the codefor the new PushToTalk framework,we want to demonstrate how the Push To Talk experiencecan work in your app.Trevor and I have built a demo appto show how PushToTalk works.To start, I'll tap the join buttonto connect to a Push To Talk session,which we call a channel.Once I'm joined to the channel,I can transmit and receive audio to other members of the channel.Trevor and a few of our colleagueshave joined the same channelso that we can communicate throughout the day.I can transmit audio directly from the appusing the microphone button, but the PushToTalk frameworkallows me to access the transmit featurefrom anywhere in the system.When there is an active Push To Talk channel,a blue pill will appear in the status bar.Tapping that pill shows the system UI.The system UI displays the name of the Push To Talk channelthat I've joined and an image provided by the appto help users quickly identify the channel.I can transmit audio to the channelby pressing and holding the Talk buttonand then waiting for the system chime to indicatethat I can begin speaking.Hey, Trevor.Are you ready to cover your WWDC slides? Over.Trevor Sheridan: When my device received Kevin's message,it displayed a notice that contained his name and image,providing transparency into who I'm receiving messages from.Once I launch the system UI,I can quickly respond to Kevin's messageor leave the channel without having to stop what I'm doing.I don't want to leave Kevin waiting, so I'll reply now.Hey, Kevin. I'll be ready in a few minutes.Over.Kevin: The PushToTalk system UI can also be accessedfrom the Lock Screen so a user can receive and respondto messages without having to unlock their device.OK, see you soon! Over.Now that we've discussed how PushToTalk works,we'll review how to integrate the framework in your own app.There are a few modifications that you need to maketo your Xcode project to support the PushToTalk framework.First, you need to add the new Push To Talk background mode.This enables your app to run in the backgroundwhen responding to Push To Talk events.Next, you must also add the Push To Talk capabilityto your app to enable the framework features.The push notification capability is required to allow APNSto wake your app in the backgroundto play received audio.Finally, your app must request recording permissionfrom the user and include a microphone purpose stringin its Info.plist file.Now we're ready to begin integrating the code.The first step in the Push To Talk workflowis to join a channel.The channel represents and describesthe Push To Talk session to the system.Your app interacts with channels through a channel manager.The channel manager is the primary interface for your appto join channels and perform actionslike transmitting and receiving audio.When you join a channel, the Push To Talk system UIbecomes available and your app receives an APNS device tokenthat can be used throughout the life of the channel.You must join a channel before you can begin transmittingand receiving audio.The first step is to create a channel managerusing the class initializer.This initializer requires that you providea channel manager delegate and a channel restoration delegate.Multiple calls to the initializerresult in the same shared instance being returned,but we recommend that you store the channel managerin an instance variable.It is important to initialize your channel manageras soon as possible during app start upin your ApplicationDelegate'sdidFinishLaunchingWithOptions method.This ensures that the channel manager is initialized quicklyso that existing channels can be restoredand push notifications will be delivered to your appwhen it launches in the background.Now we're ready to join a channel.When someone joins a channel from your app,you must provide a UUID to identify the channeland a descriptor that describes the channel to the system.The same UUID will be used when interacting with the managerthroughout the life of this channel.The descriptor includes a name and an image.Providing a unique image to represent the channelmakes it easier for your users to identify the channelwhen interacting with the system.Your app joins a channel by calling the requestJoin methodon the channel manager.Note that it is only possible to join a channelwhen your app is running in the foreground.When your app joins a channel, the channel manager delegate'sdidJoinChannel method will be called.This delegate method is your indicationthat your app has joined the channel.In addition, the delegate'sreceivedEphemeralPushToken method will be calledwith the APNS push token that can be usedto send Push To Talk notifications to this device.This token will only be activefor the life of the Push To Talk channel.Keep in mind that APNS push tokens are variable lengthand that you should not hardcode their length into your app.It is possible for the channel join request to fail,such as when attempting to join a channelwhen another channel is already active.If this occurs, the error handler will be calledand the error will indicate the reason for the failure.When the user leaves a channel,the delegate's didLeaveChannel method will be called.Your user may leave the channel as a result of eitheryour app requesting to leave programmaticallyor the user can tap the Leave Channel buttonin the system UI.The channel manager delegate has an associatedLeaveChannel error-handling method that will be calledif the request to leave the channel fails.PushToTalk supports restoring previous channelswhenever your app is relaunched after being terminatedor after a device reboot.In order for the system to accomplish this,you must provide a channel descriptor to update the system.Here we have a helper method that will fetchour cached channel descriptor in our restoration delegate.In order to keep the system responsive,you should return from this method as quickly as possibleand should not perform any long-running or blocking taskssuch as a network requestto retrieve your channel descriptor.Throughout the lifecycle of your Push To Talk session,you should provide updates to the descriptorwhenever information about the channel changes.You should also inform the system about changesto your network connection or server availabilityusing the service status object.Here we're updating the descriptor for the channel.You can call this methodwhenever you need to update the channel name or image.In this example, we are providing an updateto the system to indicate that the app's connectionto its sever is in a reconnecting state.This updates the system UI accordinglyand prevents the user from transmitting audioif the service status is connecting or disconnected.Once a connection is reestablished,you should update the service status to "ready."Now let's review how to send and receive audiousing PushToTalk.Trevor, are you ready to walk throughthe rest of the API?Over.Trevor: Yep. Send them over. Over.Now that we've seen how to configurethe PushToTalk framework,let's explore how to transmit and receive audio.A core capability of the PushToTalk frameworkis to allow your users to quickly transmit audio.Users can begin audio transmissionfrom within your app,or from the system Push To Talk UI.If your app supports Bluetooth accessoriesthrough CoreBluetooth,you can also begin transmission in the backgroundin response to a peripheral's characteristic change.When transmitting, the PushToTalk frameworkunlocks the device's microphoneand activates your app's audio sessionto enable audio recording in the background.Let's review this process in detail.To begin transmission from within your app, you can callthe requestBeginTransmitting function.This can be called whenever your app is running in the foregroundor when reacting to a changeof a Bluetooth peripheral's characteristic.If the system is not able to begin transmitting,the delegate'sfailedToBeginTransmitting InChannel method will be calledwith the reason for the failure.For example, if the user has an ongoing cellular call active,they will not be able to begin a Push To Talk transmission.To stop transmitting,call the channel manager's stopTransmitting method.To handle failures when attempting to stop transmitting,such as when the user was not in a transmitting state,the channel manager delegate has an associatedfailedToStopTransmitting InChannel method.Whether you begin transmission from within your appor if the user starts from the system UI,your channel manager delegate will receivea "Did begin transmitting" callback.The transmission source will be passed to the methodand indicate whether the transmissionwas started from the system UI,the programmatic API, or a hardware button event.Once transmission begins,the system will activate the audio session for your app.This is your signal that you can now begin recording.You should not start or stop your own audio session.When transmission ends, your channel manager delegatewill receive the end transmissionand audio session deactivation events.Keep in mind that while your transmission is active,your audio session may be interrupted by other sources,such as phone and FaceTime callsfor which you need to handle within your app.The PushToTalk framework also allows your appto receive and play audio from other userswhile in the background.This process relies on a new Apple Push Notification typethat is specific to Push To Talk apps.When your Push To Talk server has new audiofor a user to receive, it should send the usera Push To Talk notification using the device push tokenyou received when joining the channel.When the push notification is received by your app,it must report an active speaker to the framework,which will cause the system to activateyour app's audio session and allow it to begin playback.The new Push To Talk notificationis similar to other notification types on iOSand there are specific attributes that you must setto enable delivery to your Push To Talk app.First, the APNS push type must be set to "pushtotalk"in the request header.Next, the APNS topic header must be setto your app's bundle identifierwith a ".voip-ptt" suffix appended to the end.The push payload can contain custom keysthat are relevant to your app,such the name of an active speakeror an indication that the session has endedand the app should leave the Push To Talk channel.The body of the "aps" property can be left blank.Additionally, like other communication-relatedpush types,Push To Talk payloads should have an APNS priority of 10to request immediate deliveryand an APNS expiration of zero to prevent older pushesthat are no longer relevant from being delivered later.When your server sends a Push To Talk notification,your app will be started in the backgroundand the incoming push delegate method will be called.When you receive a push payload,you will need to construct a push result typeto indicate what action should be performedas a result of the push notification.To indicate that a remote user is speaking,return a push result that includesthe active participant's information,including their name and an optional image.This will cause the systemto set the active participant on the channeland indicate that the channel is in receive mode.The system will then activate your audio session,and call the didActivateaudioSessiondelegate method.You should wait for this method to be calledbefore beginning playback.If your server decides that a usershould no longer be joined to a channel,it may indicate this in the push payload,for which you can return a leaveChannel push result.It's important to note that you should returna PTPushResult from this method as quickly as possibleand not block the thread.If you are attempting to set the active remote participantand do not have their image stored locally,you can return an activeRemoteParticipantwith only the speaker's name.Then download their image on a separate thread,and once the image is retrieved,update the activeRemoteParticipantby calling setActiveRemoteParticipanton the channel manager.When the remote participant has finished speaking,you should set the activeRemoteParticipant to nil.This indicates to the system that you are no longerreceiving audio on the channeland that the system should deactivate your audio session.This will also update the system Push To Talk UIand allow the user to transmit again.Now that we've covered the basicsof how to integrate PushToTalk into your app,let's review some best practicesfor optimizing the user experienceand preserving battery life.The PushToTalk framework provides a system UIfor users to begin a transmissionand leave a channel from anywhere within the system.Additionally, it is flexible and allows you to implementyour own custom Push To Talk UIwhen your app is in the foreground.The PushToTalk frameworkutilizes shared system resources.Only one Push To Talk app can be activeon the system at a time,and Push To Talk communication will be supersededby cellular, FaceTime, and VoIP calls.Your app should handle PushToTalk failures gracefullyand respond accordingly.As mentioned earlier, the PushToTalk frameworkhandles activating and deactivatingyour audio session for you.However, you should still configureyour audio session's category to play and recordwhen your app launches.The system provides built-in sound effectsto alert the user that the microphone is activatedand deactivated when transmitting.You should not provide your own sound effectsfor these events.It is also important for your app to monitorand respond to AVAudioSession notifications,such as session interruptions,route changes, and failures.Your Push To Talk app can be affectedby these audio session eventsjust like any other audio app on the system.It's important to optimize your appto preserve battery life.The PushToTalk framework provides your appwith background runtime when needed,such as when transmitting and receiving audio.When your app is not being used by the user,it will be suspended by the system to preserve battery life.You should not activate or deactivateyour own audio sessions.The system will handle audio session activation for youat the appropriate times.This ensures that your audio sessionhas the proper priority within the systemand can be suspended when it is not being used.Your Push To Talk servershould use the new push notification typeto alert your app that there is new audio to be played,or that the Push To Talk session has ended.For more information about improvingthe battery life in your app, refer to the"Power down: Improve battery consumption" session.When your Push To Talk app is in the backgroundand the app is not transmitting or receiving audio,it will be suspended by the system.When your app is suspended,any network connections will be disconnected.You should consider adopting Network.frameworkand QUIC to reduce the steps neededto establish a secure TLS connectionand improve initial connection speed.Network.framework has built-in support for QUIC.Check out the"Reduce networking delays for a more responsive app" sessionfor more information about how to use QUIC.The PushToTalk framework enables you to buildrobust and power-efficientwalkie-talkie style communication experienceswithin your apps.If you already have an app that implementsa walk-talkie style experience on iOS,you should begin updating your existing appto use the new API.If you're implementing a new walkie-talkie app,you should use the PushToTalk framework now.Finally, please submit feedbackas you begin testing the new frameworkand integrating it with your app.Thank you and have a great WWDC!Over and out!♪

♪ Mellow instrumental hip-hop music ♪♪Kevin Ferrell: Hi, my name is Kevin,and I'm an engineer working on the new PushToTalk framework,which enables a walkie-talkie system experiencefor apps on iOS.Later I'll be joined by my colleague Trevorto talk about how you can enhance voice communicationin your apps with this new framework.First, I'll introduce the PushToTalk frameworkand explain how it fits into your app.Next, we'll go over how to configure your appfor PushToTalk.After that, Trevor will walk throughhow to transmit and receive audio using the framework.Finally, Trevor will wrap up with best practicesfor enhancing the Push To Talk user experiencewhile preserving battery life for your users.I'll get started by introducing key featuresof the new PushToTalk framework.The PushToTalk framework enables you to builda new class of audio communication app on iOSthat provides a walkie-talkie style experience for your users.Push To Talk apps have many usesin fields where rapid communication is essentialsuch as health care and emergency services.To provide a great Push To Talk experience,users need a way to quickly accessaudio transmission features while also being able to seewho is responding to them.At the same time, a Push To Talk appmust be power efficient to ensure that userscan maintain all-day battery life while using the app.The PushToTalk framework provides you with APIsto utilize a system UIthat users can access anywhere on the systemwithout having to directly launch your app.The system UI allows a user to quickly activatean audio transmission, which will launch your appin the background to record and stream audio to your server.The system provides transparency to usersby showing who's speakingwhen your app plays audio from your server.The PushToTalk framework accomplishes thisby introducing a new push notification typethat notifies your app when new audio is available for playback.When your app receives this notification,it is launched in the backgroundso that it can stream and play audio.The PushToTalk framework is designed to be compatiblewith existing end-to-end communication solutionsand backend infrastructure.If you've already implementeda Push To Talk workflow in your app,it should be easy for you to integratethe PushToTalk framework into your existing code.The framework allows your app to implementits own audio encoding and streaming processto transmit audio between users.This provides flexibility in how audio transmissionis handled by your app and enables compatibilitywith other platforms.Finally, many Push To Talk appsrely on wireless Bluetooth accessoriesto trigger audio recording and transmission.Your apps can continue to integrate with these accessoriesusing the CoreBluetooth frameworkand can trigger audio recording in PushToTalk.If you are building your first Push To Talk app,keep these integration considerations in mindas you begin architecting your code.Before we begin walking through the codefor the new PushToTalk framework,we want to demonstrate how the Push To Talk experiencecan work in your app.Trevor and I have built a demo appto show how PushToTalk works.To start, I'll tap the join buttonto connect to a Push To Talk session,which we call a channel.Once I'm joined to the channel,I can transmit and receive audio to other members of the channel.Trevor and a few of our colleagueshave joined the same channelso that we can communicate throughout the day.I can transmit audio directly from the appusing the microphone button, but the PushToTalk frameworkallows me to access the transmit featurefrom anywhere in the system.When there is an active Push To Talk channel,a blue pill will appear in the status bar.Tapping that pill shows the system UI.The system UI displays the name of the Push To Talk channelthat I've joined and an image provided by the appto help users quickly identify the channel.I can transmit audio to the channelby pressing and holding the Talk buttonand then waiting for the system chime to indicatethat I can begin speaking.

Hey, Trevor.Are you ready to cover your WWDC slides? Over.Trevor Sheridan: When my device received Kevin's message,it displayed a notice that contained his name and image,providing transparency into who I'm receiving messages from.Once I launch the system UI,I can quickly respond to Kevin's messageor leave the channel without having to stop what I'm doing.I don't want to leave Kevin waiting, so I'll reply now.Hey, Kevin. I'll be ready in a few minutes.Over.Kevin: The PushToTalk system UI can also be accessedfrom the Lock Screen so a user can receive and respondto messages without having to unlock their device.

OK, see you soon! Over.Now that we've discussed how PushToTalk works,we'll review how to integrate the framework in your own app.There are a few modifications that you need to maketo your Xcode project to support the PushToTalk framework.First, you need to add the new Push To Talk background mode.This enables your app to run in the backgroundwhen responding to Push To Talk events.Next, you must also add the Push To Talk capabilityto your app to enable the framework features.The push notification capability is required to allow APNSto wake your app in the backgroundto play received audio.Finally, your app must request recording permissionfrom the user and include a microphone purpose stringin its Info.plist file.Now we're ready to begin integrating the code.The first step in the Push To Talk workflowis to join a channel.The channel represents and describesthe Push To Talk session to the system.Your app interacts with channels through a channel manager.The channel manager is the primary interface for your appto join channels and perform actionslike transmitting and receiving audio.When you join a channel, the Push To Talk system UIbecomes available and your app receives an APNS device tokenthat can be used throughout the life of the channel.You must join a channel before you can begin transmittingand receiving audio.The first step is to create a channel managerusing the class initializer.This initializer requires that you providea channel manager delegate and a channel restoration delegate.Multiple calls to the initializerresult in the same shared instance being returned,but we recommend that you store the channel managerin an instance variable.It is important to initialize your channel manageras soon as possible during app start upin your ApplicationDelegate'sdidFinishLaunchingWithOptions method.This ensures that the channel manager is initialized quicklyso that existing channels can be restoredand push notifications will be delivered to your appwhen it launches in the background.Now we're ready to join a channel.When someone joins a channel from your app,you must provide a UUID to identify the channeland a descriptor that describes the channel to the system.The same UUID will be used when interacting with the managerthroughout the life of this channel.The descriptor includes a name and an image.Providing a unique image to represent the channelmakes it easier for your users to identify the channelwhen interacting with the system.Your app joins a channel by calling the requestJoin methodon the channel manager.Note that it is only possible to join a channelwhen your app is running in the foreground.When your app joins a channel, the channel manager delegate'sdidJoinChannel method will be called.This delegate method is your indicationthat your app has joined the channel.In addition, the delegate'sreceivedEphemeralPushToken method will be calledwith the APNS push token that can be usedto send Push To Talk notifications to this device.This token will only be activefor the life of the Push To Talk channel.Keep in mind that APNS push tokens are variable lengthand that you should not hardcode their length into your app.It is possible for the channel join request to fail,such as when attempting to join a channelwhen another channel is already active.If this occurs, the error handler will be calledand the error will indicate the reason for the failure.When the user leaves a channel,the delegate's didLeaveChannel method will be called.Your user may leave the channel as a result of eitheryour app requesting to leave programmaticallyor the user can tap the Leave Channel buttonin the system UI.The channel manager delegate has an associatedLeaveChannel error-handling method that will be calledif the request to leave the channel fails.PushToTalk supports restoring previous channelswhenever your app is relaunched after being terminatedor after a device reboot.In order for the system to accomplish this,you must provide a channel descriptor to update the system.Here we have a helper method that will fetchour cached channel descriptor in our restoration delegate.In order to keep the system responsive,you should return from this method as quickly as possibleand should not perform any long-running or blocking taskssuch as a network requestto retrieve your channel descriptor.Throughout the lifecycle of your Push To Talk session,you should provide updates to the descriptorwhenever information about the channel changes.You should also inform the system about changesto your network connection or server availabilityusing the service status object.Here we're updating the descriptor for the channel.You can call this methodwhenever you need to update the channel name or image.In this example, we are providing an updateto the system to indicate that the app's connectionto its sever is in a reconnecting state.This updates the system UI accordinglyand prevents the user from transmitting audioif the service status is connecting or disconnected.Once a connection is reestablished,you should update the service status to "ready."Now let's review how to send and receive audiousing PushToTalk.Trevor, are you ready to walk throughthe rest of the API?Over.Trevor: Yep. Send them over. Over.Now that we've seen how to configurethe PushToTalk framework,let's explore how to transmit and receive audio.A core capability of the PushToTalk frameworkis to allow your users to quickly transmit audio.Users can begin audio transmissionfrom within your app,or from the system Push To Talk UI.If your app supports Bluetooth accessoriesthrough CoreBluetooth,you can also begin transmission in the backgroundin response to a peripheral's characteristic change.When transmitting, the PushToTalk frameworkunlocks the device's microphoneand activates your app's audio sessionto enable audio recording in the background.Let's review this process in detail.To begin transmission from within your app, you can callthe requestBeginTransmitting function.This can be called whenever your app is running in the foregroundor when reacting to a changeof a Bluetooth peripheral's characteristic.If the system is not able to begin transmitting,the delegate'sfailedToBeginTransmitting InChannel method will be calledwith the reason for the failure.For example, if the user has an ongoing cellular call active,they will not be able to begin a Push To Talk transmission.To stop transmitting,call the channel manager's stopTransmitting method.To handle failures when attempting to stop transmitting,such as when the user was not in a transmitting state,the channel manager delegate has an associatedfailedToStopTransmitting InChannel method.Whether you begin transmission from within your appor if the user starts from the system UI,your channel manager delegate will receivea "Did begin transmitting" callback.The transmission source will be passed to the methodand indicate whether the transmissionwas started from the system UI,the programmatic API, or a hardware button event.Once transmission begins,the system will activate the audio session for your app.This is your signal that you can now begin recording.You should not start or stop your own audio session.When transmission ends, your channel manager delegatewill receive the end transmissionand audio session deactivation events.Keep in mind that while your transmission is active,your audio session may be interrupted by other sources,such as phone and FaceTime callsfor which you need to handle within your app.The PushToTalk framework also allows your appto receive and play audio from other userswhile in the background.This process relies on a new Apple Push Notification typethat is specific to Push To Talk apps.When your Push To Talk server has new audiofor a user to receive, it should send the usera Push To Talk notification using the device push tokenyou received when joining the channel.When the push notification is received by your app,it must report an active speaker to the framework,which will cause the system to activateyour app's audio session and allow it to begin playback.The new Push To Talk notificationis similar to other notification types on iOSand there are specific attributes that you must setto enable delivery to your Push To Talk app.First, the APNS push type must be set to "pushtotalk"in the request header.Next, the APNS topic header must be setto your app's bundle identifierwith a ".voip-ptt" suffix appended to the end.The push payload can contain custom keysthat are relevant to your app,such the name of an active speakeror an indication that the session has endedand the app should leave the Push To Talk channel.The body of the "aps" property can be left blank.Additionally, like other communication-relatedpush types,Push To Talk payloads should have an APNS priority of 10to request immediate deliveryand an APNS expiration of zero to prevent older pushesthat are no longer relevant from being delivered later.When your server sends a Push To Talk notification,your app will be started in the backgroundand the incoming push delegate method will be called.When you receive a push payload,you will need to construct a push result typeto indicate what action should be performedas a result of the push notification.To indicate that a remote user is speaking,return a push result that includesthe active participant's information,including their name and an optional image.This will cause the systemto set the active participant on the channeland indicate that the channel is in receive mode.The system will then activate your audio session,and call the didActivateaudioSessiondelegate method.You should wait for this method to be calledbefore beginning playback.If your server decides that a usershould no longer be joined to a channel,it may indicate this in the push payload,for which you can return a leaveChannel push result.It's important to note that you should returna PTPushResult from this method as quickly as possibleand not block the thread.If you are attempting to set the active remote participantand do not have their image stored locally,you can return an activeRemoteParticipantwith only the speaker's name.Then download their image on a separate thread,and once the image is retrieved,update the activeRemoteParticipantby calling setActiveRemoteParticipanton the channel manager.When the remote participant has finished speaking,you should set the activeRemoteParticipant to nil.This indicates to the system that you are no longerreceiving audio on the channeland that the system should deactivate your audio session.This will also update the system Push To Talk UIand allow the user to transmit again.Now that we've covered the basicsof how to integrate PushToTalk into your app,let's review some best practicesfor optimizing the user experienceand preserving battery life.

The PushToTalk framework provides a system UIfor users to begin a transmissionand leave a channel from anywhere within the system.Additionally, it is flexible and allows you to implementyour own custom Push To Talk UIwhen your app is in the foreground.The PushToTalk frameworkutilizes shared system resources.Only one Push To Talk app can be activeon the system at a time,and Push To Talk communication will be supersededby cellular, FaceTime, and VoIP calls.Your app should handle PushToTalk failures gracefullyand respond accordingly.As mentioned earlier, the PushToTalk frameworkhandles activating and deactivatingyour audio session for you.However, you should still configureyour audio session's category to play and recordwhen your app launches.The system provides built-in sound effectsto alert the user that the microphone is activatedand deactivated when transmitting.You should not provide your own sound effectsfor these events.It is also important for your app to monitorand respond to AVAudioSession notifications,such as session interruptions,route changes, and failures.Your Push To Talk app can be affectedby these audio session eventsjust like any other audio app on the system.It's important to optimize your appto preserve battery life.The PushToTalk framework provides your appwith background runtime when needed,such as when transmitting and receiving audio.When your app is not being used by the user,it will be suspended by the system to preserve battery life.You should not activate or deactivateyour own audio sessions.The system will handle audio session activation for youat the appropriate times.This ensures that your audio sessionhas the proper priority within the systemand can be suspended when it is not being used.Your Push To Talk servershould use the new push notification typeto alert your app that there is new audio to be played,or that the Push To Talk session has ended.For more information about improvingthe battery life in your app, refer to the"Power down: Improve battery consumption" session.When your Push To Talk app is in the backgroundand the app is not transmitting or receiving audio,it will be suspended by the system.When your app is suspended,any network connections will be disconnected.You should consider adopting Network.frameworkand QUIC to reduce the steps neededto establish a secure TLS connectionand improve initial connection speed.Network.framework has built-in support for QUIC.Check out the"Reduce networking delays for a more responsive app" sessionfor more information about how to use QUIC.The PushToTalk framework enables you to buildrobust and power-efficientwalkie-talkie style communication experienceswithin your apps.If you already have an app that implementsa walk-talkie style experience on iOS,you should begin updating your existing appto use the new API.If you're implementing a new walkie-talkie app,you should use the PushToTalk framework now.Finally, please submit feedbackas you begin testing the new frameworkand integrating it with your app.Thank you and have a great WWDC!Over and out!♪

6:52 -Creating a Channel Manager

7:33 -Joining a Channel

8:11 -PTChannelManagerDelegate didJoinChannel

8:45 -PTChannelManagerDelegate failedToJoinChannel

9:00 -PTChannelManagerDelegate didLeaveChannel

9:22 -PTChannelRestorationDelegate

10:12 -Provide channel descriptor updates

10:20 -Provide service status updates

11:48 -Start transmission from within your app

12:22 -Stop transmission from within your app

12:41 -Responding to begin transmission delegate events

13:19 -Responding to end transmission delegate events

15:29 -Receiving Push to Talk Pushes

17:03 -Stop receiving audio

## Code Samples

```swift
func
 
setupChannelManager
() 
async
 
throws
 {
    channelManager 
=
 
try
 
await
 
PTChannelManager
.channelManager(delegate: 
self
,
                                                               restorationDelegate: 
self
)
}
```

```swift
func
 
joinChannel
(
channelUUID
: 
UUID
) {
    
let
 channelImage 
=
 
UIImage
(named: 
"ChannelIcon"
)
    channelDescriptor 
=
 
PTChannelDescriptor
(name: 
"Awesome Crew"
, image: channelImage)
  
    
// Ensure that your channel descriptor and UUID are persisted to disk for later use.

    channelManager.requestJoinChannel(channelUUID: channelUUID, 
                                      descriptor: channelDescriptor)
}
```

```swift
func
 
channelManager
(
_
 
channelManager
: 
PTChannelManager
, 
                    
didJoinChannel
 
channelUUID
: 
UUID
,
                    
reason
: 
PTChannelJoinReason
) {
    
// Process joining the channel

    
print
(
"Joined channel with UUID: 
\(channelUUID)
"
)
}


func
 
channelManager
(
_
 
channelManager
: 
PTChannelManager
,
                    
receivedEphemeralPushToken
 
pushToken
: 
Data
) {
    
// Send the variable length push token to the server

    
print
(
"Received push token"
)
}
```

```swift
func
 
channelManager
(
_
 
channelManager
: 
PTChannelManager
, 
                    
failedToJoinChannel
 
channelUUID
: 
UUID
, 
                    
error
: 
Error
) {
    
let
 error 
=
 error 
as
 
NSError


    
switch
 error.code {
    
case
 
PTChannelError
.channelLimitReached.rawValue:
        
print
(
"The user has already joined a channel"
)
    
default
:
        
break

    }
}
```

```swift
func
 
channelManager
(
_
 
channelManager
: 
PTChannelManager
,
                    
didLeaveChannel
 
channelUUID
: 
UUID
,
                    
reason
: 
PTChannelLeaveReason
) {
    
// Process leaving the channel

    
print
(
"Left channel with UUID: 
\(channelUUID)
"
)
}
```

```swift
func
 
channelDescriptor
(
restoredChannelUUID
 
channelUUID
: 
UUID
) -> 
PTChannelDescriptor
 {
    
return
 getCachedChannelDescriptor(channelUUID)
}
```

```swift
func
 
updateChannel
(
_
 
channelDescriptor
: 
PTChannelDescriptor
) 
async
 
throws
 {
    
try
 
await
 channelManager.setChannelDescriptor(channelDescriptor, 
                                                  channelUUID: channelUUID)
}
```

```swift
func
 
reportServiceIsReconnecting
() 
async
 
throws
 {
    
try
 
await
 channelManager.setServiceStatus(.connecting, channelUUID: channelUUID)
}


func
 
reportServiceIsConnected
() 
async
 
throws
 {
    
try
 
await
 channelManager.setServiceStatus(.ready, channelUUID: channelUUID)
}
```

```swift
func
 
startTransmitting
() {
    channelManager.requestBeginTransmitting(channelUUID: channelUUID)
}


// PTChannelManagerDelegate



func
 
channelManager
(
_
 
channelManager
: 
PTChannelManager
, 
                    
failedToBeginTransmittingInChannel
 
channelUUID
: 
UUID
,
                    
error
: 
Error
) {
    
let
 error 
=
 error 
as
 
NSError


    
switch
 error.code {
    
case
 
PTChannelError
.callIsActive.rawValue:
        
print
(
"The system has another ongoing call that is preventing transmission."
)
    
default
:
        
break

    }
}
```

```swift
func
 
stopTransmitting
() {
    channelManager.stopTransmitting(channelUUID: channelUUID)
}


func
 
channelManager
(
_
 
channelManager
: 
PTChannelManager
, 
                    
failedToStopTransmittingInChannel
 
channelUUID
: 
UUID
, 
                    
error
: 
Error
) {
    
let
 error 
=
 error 
as
 
NSError


    
switch
 error.code {
    
case
 
PTChannelError
.transmissionNotFound.rawValue:
        
print
(
"The user was not in a transmitting state"
)
    
default
:
        
break

    }
}
```

```swift
func
 
channelManager
(
_
 
channelManager
: 
PTChannelManager
,
                    
channelUUID
: 
UUID
, 
                    
didBeginTransmittingFrom
 
source
: 
PTChannelTransmitRequestSource
) {
    
print
(
"Did begin transmission from: 
\(source)
"
)
}


func
 
channelManager
(
_
 
channelManager
: 
PTChannelManager
,
                    
didActivate
 
audioSession
: 
AVAudioSession
) {
    
print
(
"Did activate audio session"
)
    
// Configure your audio session and begin recording

}
```

```swift
func
 
channelManager
(
_
 
channelManager
: 
PTChannelManager
,
                    
channelUUID
: 
UUID
, 
                    
didEndTransmittingFrom
 
source
: 
PTChannelTransmitRequestSource
) {
    
print
(
"Did end transmission from: 
\(source)
"
)
}


func
 
channelManager
(
_
 
channelManager
: 
PTChannelManager
,
                    
didDeactivate
 
audioSession
: 
AVAudioSession
) {
    
print
(
"Did deactivate audio session"
)
    
// Stop recording and clean up resources

}
```

```swift
func
 
incomingPushResult
(
channelManager
: 
PTChannelManager
, 
                        
channelUUID
: 
UUID
, 
                        
pushPayload
: [
String
 : 
Any
]) -> 
PTPushResult
 {

    
guard
 
let
 activeSpeaker 
=
 pushPayload[
"activeSpeaker"
] 
as?
 
String
 
else
 {
        
// If no active speaker is set, the only other valid operation 

        
// is to leave the channel

        
return
 .leaveChannel
    }

    
let
 activeSpeakerImage 
=
 getActiveSpeakerImage(activeSpeaker)    
    
let
 participant 
=
 
PTParticipant
(name: activeSpeaker, image: activeSpeakerImage)
    
return
 .activeRemoteParticipant(participant)
}
```

```swift
func
 
stopReceivingAudio
() {
    channelManager.setActiveRemoteParticipant(
nil
, channelUUID: channelUUID)
}
```


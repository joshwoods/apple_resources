# Wwdc2022 10103

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Boost performance with MetalFX UpscalingDiscover MetalFX, a new API that provides platform optimized graphics effects for Metal applications. With MetalFX Upscaling, your application can now render frames at a lower resolution, reducing rendering time, without compromising rendering quality. We'll also show you how and when to use its two effects: spatial upscaling, which delivers substantial performance gains, and temporal AA and upscaling, which delivers the highest quality rendering.Resources4K Video (WWDC22-10103)Applying temporal antialiasing and upscaling using MetalFXMetalMetalFXHD VideoSD VideoRelated VideosWWDC23Bring your game to Mac, Part 3: Render with MetalTech TalksBring your high-end game to iPhone 15 ProWWDC22Discover Metal 3

Discover MetalFX, a new API that provides platform optimized graphics effects for Metal applications. With MetalFX Upscaling, your application can now render frames at a lower resolution, reducing rendering time, without compromising rendering quality. We'll also show you how and when to use its two effects: spatial upscaling, which delivers substantial performance gains, and temporal AA and upscaling, which delivers the highest quality rendering.

4K Video (WWDC22-10103)

Applying temporal antialiasing and upscaling using MetalFX

Metal

MetalFX

HD VideoSD Video

HD Video

SD Video

Bring your game to Mac, Part 3: Render with Metal

Bring your high-end game to iPhone 15 Pro

Discover Metal 3

Search this video…♪ ♪Hello and welcome.My name is Kelvin Chiu from the GPU Software team here at Apple.Today, I'll talk about how to boost your Metal application performancewith MetalFX Upscaling.MetalFX is a new API that providesplatform optimized graphics effects for Metal applications.It enables high performance upscaling,which will boost your application performancewhile retaining its rendering quality.Rendering a frame at high resolution costs GPU time.To reduce that time, rendering at a lower resolution willusually do the trick.However, the tradeoff is a lower rendering quality.With MetalFX Upscaling,your application can now render framesat a lower resolution, reducing rendering time,without compromising rendering quality.MetalFX Upscaling is optimizedto run best on Apple devices.and it is also easy to adopt in your game.MetalFX provides two upscaling effects,which I will describe in detail.Spatial upscaling is simple to useand gives a great performance boost.Temporal anti-aliasing and upscaling integrates informationfrom multiple frames to produce a higher quality output.I will then talk about best practicesfor using these effects.Finally, I will end the sessionwith demos showing them in action.Let's start with Spatial upscaling.MetalFX Spatial upscalinganalyzes the input’s spatial informationto produce new, upscaled samples.Integrating Spatial upscaling is simple.It only requires anti-aliased input color to producea spatially upscaled color output.In a typical game rendering pipeline,there are various rendering passes including anti-aliased renderand various post processing effects.Add MetalFX spatial upscalingright after the game's tone-mapping processis completed.It will perform best if the input has been tone mapped and isin a perceptual color space.Let’s checkout MetalFX spatial upscaling in action.This chess scene is produced with a high quality reference rendererin 4K resolution.It is path traced, with complex graphics effects,like ray-traced reflections and shadows.Here is a side by side comparison,with 540p input on the left...…and 1080p output with MetalFX spatial upscaling on the right.If I zoom in on the queen, on the left,the image lacks details and is low resolution.On the right, the spatially upscaled outputhas sharper reflections and more refined edges.Next, I'll walk you through how to implement MetalFX spatial upscaling.In Metal, you would normally create a command encoderto encode commands into a command bufferand produce input for the effect.Similarly, you can create a MetalFX effect objectto encode commands into a command buffer and perform the effect.Finally, create a third command encoder to encode commandsthat make use of the MetalFX output.You should only create a new spatial scaler objectwhen your application first startsor when a display switches resolutionsbecause they are expensive to create.First, create and configurea MTLFXSpatialScalerDescriptor.Then, create a scaler objectby calling the makeSpatialScaler() method.In the initialization code,start with the descriptor.Fill both the width and heightof the input and output texture.Then, set the texture format for the textures that will be set lateron the scaler object.Set the color processing mode.This tells the API which color spacethe input and output is in.You can set the value to be in either perceptual,linear, or HDR color space.Once the descriptor is filled, create the scaler object.Once the scaler object is created, you can modify the propertiesof the object as frequently as you wantand call the encode() method to start the upscaling process.In your per frame draw code, make sure the correct inputand output textures are being set on the scaler objectbefore encoding the scaling effect into the command buffer.Spatial upscaling offers a simple way to boost performance.And when you want even higher quality rendering,that's where MetalFX temporal anti-aliasingand upscaling comes in.Temporal AA and upscaling is a technique that uses datafrom previous frames to produce high-quality upscaled output.This means, the output of upscaling from the previous framewill be used as one of the inputs for the current frame upscaling.To better understand why Temporal AA and upscaling requires datafrom the previous frames,I'll first review the concept of supersampling.In supersampling,multiple samples are calculated per pixel,which is then integrated into a single pixel value.The more samples that we integrate per pixel,the better the result will be.However, it comes at a great costto calculate multiple samples per pixelwithin a single frame.Instead of sampling multiple locationsper pixel in a single frame,you can perform temporal sampling.Temporal sampling is the concept of renderinga different sample locationfor all the pixels in a given frame.This enables you to achieve supersampling qualityover multiple frames at a significantly lower cost.By accumulating samples from multiple frames and accountingfor sample positions,temporal AA & upscaling canintegrate samples appropriatelyin target resolution pixels,resulting in a high quality anti-aliased upscaled output.However, since content often changes between frames,it will require more input data to detect these changes.Besides the previous frame output,Temporal AA and upscaling also requiresa color input that is jittered,as well as motion and depth data from the scene.I'll go through each of them to explain why they are required.Let's start with the jittered color input.Here is a red triangle rendered without jitter.The bright white outline represents the triangle being rendered.Each one of the small squares represent a pixel.And the gray dot in the middle is where the pixel is sampled.This is the output of the same trianglewhen rendered with a small jitter.The gray dots show the sampling location for a given pixel.The jitter offset should be unique for a set number of framesin order to fully gather the desired number of samples.I will cover the topic of jitter sequence in detail later.Next is the motion information from the scene.Motion data from the scene indicateshow much and which directionthe objects had moved from the previous frame.Temporal AA and upscaling uses the motion information to back trackand find corresponding locations in the previous framein order to correctly gather samples.Another input is the depth information from the scene.Depth data from the sceneindicates what's in the foreground and what's in the background.This is important when prioritizing foreground edge anti-aliasingand provides clues on what other objects might be newly exposedwhen gathering samples from previous frames.The last piece of input data is the previous frame’s output.The previous frame’s output contains allof the samples that have been integrated previously,and it will be blended with the current frame’s jittered color inputin order to increase the number of samples per pixel.By combining information from both the current and previous frame,the resulting image now has more details.MetalFX keeps track of the upscaled output,so you only need to pass the color,motion, and depth from the current rendered frame.Going back to a typical game’s rendering pipeline,MetalFX temporal AA and upscaling should runbefore any post processing effects,since these effects will interferewith the result of the upscaling.Here's the chess rendering again,this time using MetalFX Temporal AA and upscaling.This is a side by side comparison of 1080p input on the leftand 4K upscaled output on the right.Zooming in closer to the queen,the input is low resolution and aliased,while the temporally upscaled output on the right is high resolutionwith a smooth outline and has more fine details in the reflections.Just as with spatial scaler, creating a new temporal scaleris expensive and should only be donewhen your application first startsor when a display switches resolutions.First, you'll need to allocate and fill ina MTLFXTemporalScalerDescriptor.Then call makeTemporalScaler() method to create the scaler object.In your initialization code, start with the descriptor.Fill in both the width and height of the input and output textures.Then set the jittered color,depth, and motion texture formatsfor the textures that will be bound later on the scaler object as inputs.Finally, set the format for the output texturewhere MetalFX will store the upscaled output.Once the descriptor is filled, create the scaler object.On the scaler object, set the motion scale properties.This helps you scale the app's motion data to what the API expects.MetalFX expects motion datain the render resolution pixel spacewith direction that goes from the current frame’s positionto the previous frame’s position.As an example,I'll use a render resolution of 1080p.Suppose you have an object that moves from clip space coordinate(-0.75, -0.75).to clip space coordinate (0.25, 0.25).The motion data is stored as (1, 1).Set the motion vector scale propertyto (-960, 540)so that MetalFX can interpret your game's motion data correctly.You can modify the properties of the scaler object as frequentlyas you want.And call the encode() method to start the upscaling process.For your per frame draw code,first set the resetHistory property.Set this to true when your application loads the first frameor when there is a scene cut.Then set the textures that are inputs for the effect,followed by the output texture.Next, set the reversedDepth propertyto indicate whether the depth values are in reversed-Z mapping.The last property to setbefore encoding the scaling effect is the current jitter offset.Getting jitter offset correctly is essentialto the quality of the output.Let us take a quick look on how to set jitter offset.As an example, on the left is a triangle rendered with jitter.On the right is a zoomed in view of a pixel.The sample is located at (0.625, 0.78).The pixel center is represented by the orange dot.It is located at (0.5, 0.5).In this example,the jitter offset is (-0.125, -0.28).Note that jitter offsets are alwaysin the range of -0.5 to 0.5.To verify that you are providing the correct jitter offset,render a scene without camera and object motionusing a sequence of different jitter offsets.On the left is an examplewhen incorrect jitter offset is specified.Static objects could shift, and fine lines are fuzzy.On the right is the outputwhen correct jitter offset is specified.Objects stay in place,and fine lines are resolved progressively.The MetalFX “temporal AA and upscaling” effectboosts your application performanceand gives an upscaling quality that’s comparable to the qualityof the native target resolution rendering.In order to get optimal quality and performancewhen using both upscaling effects,l’ll now cover implementation best practices.Starting with spatial upscaling.For the best spatial upscaling quality,the color input should be anti-aliased and noise free.This is because noise effectsand aliased images prevent good edge determination,which will worsen the spatial upscaling quality.For the best performance,use the perceptual color processing mode.This means, your input color should be tone mapped,with values from 0-1, in the sRGB color space.And finally, set the appropriate negative mip biasfor higher texture detail.The recommended mip bias calculationfor spatial upscaling is to apply log2of the render resolution width,divided by the target resolution width.For example, scaling each render resolution dimensionby 2x will result in -1 mip bias,while scaling each dimension by 1.5xwill result in -0.58 mip bias.Note that lower mip levels might result in flickering for textureswith high frequency patterns.You should adjust the mip bias for certain texturesif you spot such artifacts.I will talk next about TemporalAAand upscaling best practices.To get the best quality from Temporal AA and upscaling,it's important to choose a good jitter sequence.Look for a jitter sequencethat will provide a good distribution of samplesacross all the pixelsin an upscaled target resolution.Usually, eight jittered samples per output pixelproduces a high-quality anti-aliased upscaled output.In the case of 2x upscaling, the recommendation is to usea Halton (2,3) sequence with 32 jittersto produce your jittered color input.Here’s a plot of the first 32 sample locationsfrom Halton (2,3) sequence,producing approximately eight samples per output pixel.It's also important to set the appropriate negative mip biasfor higher texture detail.The recommended mip bias calculationfor temporal AA and upscalingis to apply log2 of render resolution width,divided by target resolution width, subtracted by 1.For example, scaling each render resolution dimensionby 2x will result in a -2 mip bias,while scaling each dimensionby 1.5x will result in a -1.58 mip bias.Next, I will show you examples of how mip bias affects your outputin different situations.Here are MetalFX temporal AAand upscaling outputs of the same sceneusing mip bias of 0, -1, and -2.Mip bias of -2 producesthe sharpest and clearest output,while mip bias of 0 producesthe softest and most blurry output.Here are three renderings of a circuit boardthat use the temporal upscaling effect.From top to bottom, the mip bias values appliedwhen sampling textures are 0,-1, and -2.Because the circuit board’s textures have high-frequency patterns,such as its tiny trace wires,mip bias of -2 generates flickeringand moire effects.However, mip bias of -1greatly reduces these effects,and mip bias of 0 completely eliminates them.Lower mip levels generally result in more details.Use our mip bias suggestion as a starting point,but be mindful when choosing a mip biasfor textures with high-frequency patterns.Follow these practices to ensure an anti-aliased,high-quality upscaled outputfrom MetalFX Temporal AA and upscaling.Finally, I will cover performance best practicewhen using MetalFX Upscaling.To get the best performance with MetalFX Upscaling,you should be careful to avoid binding the same resourcesfor reading and writing in two non-dependent renderor compute passes.Doing so creates false dependencies.In Metal, it's always a good ideato avoid false dependencies.But this is especially important for MetalFX Upscaling,as I will describe next.In this example, there are two frames.The shadow and the post processing passes are completely unrelatedand have no resource dependencies.Metal will overlap the next frame’s shadow passwith the current frame’s post processing pass.However, if the post processing pass writesto a Metal buffer while the shadow passalso reads from the same buffer,Metal will prevent the GPU from running these two passesin parallel in order to avoid the potential hazard of readingand writing to the same resource at the same time.False dependencies between framescan negatively affect performanceof MetalFX Upscaling.Notice that if there is nofalse dependency between frames,the next frame’s shadow pass could have overlappedwith the previous frame's MetalFX Upscaling.However, because of the false dependencybetween frames,the performance loss nowalso includes the timeit takes for MetalFX Upscalingto finish its process.Ideally, you should ensure thatthere are no false dependenciesbetween frames to allow overlappingof workloads between different frames,ensuring the most optimal performancewhen using MetalFX Upscaling.In this example,you can instead create a separate bufferfor the post processing and shadow passesto prevent the false dependency,resulting in parallel executionof independent passes.Avoiding false dependencies is something you always wantto keep in mind when adopting MetalFX Upscaling.When deciding which of these two effects to choose,there are some considerations you should also keep in mind.With ever-increasing shading costs and pixel counts,temporal AA and upscaling is here to stay.Amortizing pixels temporally increases visual fidelityand boosts performance.If you don’t already have a great temporal AA solutionand can render jittered color,motion, and depth buffers,MetalFX temporal AA and upscaling providesa compelling platform-optimized solutionthat you should consider.If you don’t have the necessary inputsor already have a well tuned AA solution,consider using MetalFX spatial upscaling.With that, hopefully you now have a better understandingof which upscaling effect to choose.I will next show examples of both of these effects running livein Metal applications.Here’s a side by side comparison of the “Bistro” scenefrom our “Modern Rendering with Metal” sample code,which features real-time rendering algorithms,like ambient occlusion and volumetric fog.Native rendering at 1080p on the leftversus 4K outputwith MetalFX Spatial upscaling on the right.Note that this sample has its own temporal anti-aliasing solution,which we use as input for MetalFX spatial upscaling.Zooming in more closely at the scooter...On the left, the image is a bit blurry, while on the right,the spatially upscaled output resultsin a sharper image with cleaner edges.The straight line on the handle bar is nicely antialiased.The curve on the body is also much smoother.Let's do a performance comparison.On the left is a native rendering at 4K.On the right is the 4K outputfrom MetalFX Spatial upscaling.As the camera moves, the native rendering on the leftis running at a choppy frame rate,while the spatially upscaled outputon the right is much smoother.Next is a side-by-side comparisonof a ray-traced scene with many reflections and shadows.On the left is a native rendering at 1080p.On the right is the 4K outputwith MetalFX Temporal AA and upscaling.Zooming in more closely at the chandelier...The native output on the left has an aliased look,while the temporally upscaled output on the righthas sharp edges with more fine details.The shadow is nice and crisp rather than fuzzy looking.And fine details on the chandelier can now be recognized.Performance gains are also apparentwith MetalFX Temporal AA and upscaling.On the left is native rendering at 4K.On the right is the 4K outputwith MetalFX Temporal AA and upscaling.As the camera moves, the native rendering on the leftis running at a very low frame rate,while the temporally upscaled outputon the right is much smoother.Leading game developers are excitedby the capabilities of MetalFX Upscalingand will be bringing "Grid: Legends,""Resident Evil: Village,"and "No Man’s Sky" to Mac later this year.Next, I’ll show you some early work using the framework.In this scene, we can see the incredible visualsand fluid gameplay of "No Man’s Sky"using MetalFX Temporal AA and Upscaling.To recap,MetalFX is a new API with a focus on upscaling.Spatial upscaling is easy to adoptand delivers substantial performance gains,and you can use Temporal AA and upscalingto deliver higher quality rendering.Following the best practices I talked about earlier will ensureyou get the most out of MetalFX Upscaling.Thank you for watching.♪ ♪

♪ ♪Hello and welcome.My name is Kelvin Chiu from the GPU Software team here at Apple.Today, I'll talk about how to boost your Metal application performancewith MetalFX Upscaling.

MetalFX is a new API that providesplatform optimized graphics effects for Metal applications.

It enables high performance upscaling,which will boost your application performancewhile retaining its rendering quality.Rendering a frame at high resolution costs GPU time.To reduce that time, rendering at a lower resolution willusually do the trick.However, the tradeoff is a lower rendering quality.With MetalFX Upscaling,your application can now render framesat a lower resolution, reducing rendering time,without compromising rendering quality.MetalFX Upscaling is optimizedto run best on Apple devices.and it is also easy to adopt in your game.MetalFX provides two upscaling effects,which I will describe in detail.Spatial upscaling is simple to useand gives a great performance boost.

Temporal anti-aliasing and upscaling integrates informationfrom multiple frames to produce a higher quality output.

I will then talk about best practicesfor using these effects.Finally, I will end the sessionwith demos showing them in action.

Let's start with Spatial upscaling.

MetalFX Spatial upscalinganalyzes the input’s spatial informationto produce new, upscaled samples.Integrating Spatial upscaling is simple.It only requires anti-aliased input color to producea spatially upscaled color output.In a typical game rendering pipeline,there are various rendering passes including anti-aliased renderand various post processing effects.Add MetalFX spatial upscalingright after the game's tone-mapping processis completed.It will perform best if the input has been tone mapped and isin a perceptual color space.Let’s checkout MetalFX spatial upscaling in action.

This chess scene is produced with a high quality reference rendererin 4K resolution.It is path traced, with complex graphics effects,like ray-traced reflections and shadows.Here is a side by side comparison,with 540p input on the left...

…and 1080p output with MetalFX spatial upscaling on the right.

If I zoom in on the queen, on the left,the image lacks details and is low resolution.On the right, the spatially upscaled outputhas sharper reflections and more refined edges.

Next, I'll walk you through how to implement MetalFX spatial upscaling.

In Metal, you would normally create a command encoderto encode commands into a command bufferand produce input for the effect.Similarly, you can create a MetalFX effect objectto encode commands into a command buffer and perform the effect.Finally, create a third command encoder to encode commandsthat make use of the MetalFX output.You should only create a new spatial scaler objectwhen your application first startsor when a display switches resolutionsbecause they are expensive to create.

First, create and configurea MTLFXSpatialScalerDescriptor.Then, create a scaler objectby calling the makeSpatialScaler() method.In the initialization code,start with the descriptor.Fill both the width and heightof the input and output texture.Then, set the texture format for the textures that will be set lateron the scaler object.Set the color processing mode.This tells the API which color spacethe input and output is in.You can set the value to be in either perceptual,linear, or HDR color space.Once the descriptor is filled, create the scaler object.

Once the scaler object is created, you can modify the propertiesof the object as frequently as you wantand call the encode() method to start the upscaling process.

In your per frame draw code, make sure the correct inputand output textures are being set on the scaler objectbefore encoding the scaling effect into the command buffer.

Spatial upscaling offers a simple way to boost performance.

And when you want even higher quality rendering,that's where MetalFX temporal anti-aliasingand upscaling comes in.Temporal AA and upscaling is a technique that uses datafrom previous frames to produce high-quality upscaled output.This means, the output of upscaling from the previous framewill be used as one of the inputs for the current frame upscaling.

To better understand why Temporal AA and upscaling requires datafrom the previous frames,I'll first review the concept of supersampling.

In supersampling,multiple samples are calculated per pixel,which is then integrated into a single pixel value.The more samples that we integrate per pixel,the better the result will be.However, it comes at a great costto calculate multiple samples per pixelwithin a single frame.Instead of sampling multiple locationsper pixel in a single frame,you can perform temporal sampling.Temporal sampling is the concept of renderinga different sample locationfor all the pixels in a given frame.This enables you to achieve supersampling qualityover multiple frames at a significantly lower cost.

By accumulating samples from multiple frames and accountingfor sample positions,temporal AA & upscaling canintegrate samples appropriatelyin target resolution pixels,resulting in a high quality anti-aliased upscaled output.

However, since content often changes between frames,it will require more input data to detect these changes.

Besides the previous frame output,Temporal AA and upscaling also requiresa color input that is jittered,as well as motion and depth data from the scene.

I'll go through each of them to explain why they are required.

Let's start with the jittered color input.

Here is a red triangle rendered without jitter.The bright white outline represents the triangle being rendered.

Each one of the small squares represent a pixel.And the gray dot in the middle is where the pixel is sampled.

This is the output of the same trianglewhen rendered with a small jitter.The gray dots show the sampling location for a given pixel.

The jitter offset should be unique for a set number of framesin order to fully gather the desired number of samples.

I will cover the topic of jitter sequence in detail later.

Next is the motion information from the scene.Motion data from the scene indicateshow much and which directionthe objects had moved from the previous frame.Temporal AA and upscaling uses the motion information to back trackand find corresponding locations in the previous framein order to correctly gather samples.

Another input is the depth information from the scene.

Depth data from the sceneindicates what's in the foreground and what's in the background.This is important when prioritizing foreground edge anti-aliasingand provides clues on what other objects might be newly exposedwhen gathering samples from previous frames.The last piece of input data is the previous frame’s output.

The previous frame’s output contains allof the samples that have been integrated previously,and it will be blended with the current frame’s jittered color inputin order to increase the number of samples per pixel.

By combining information from both the current and previous frame,the resulting image now has more details.MetalFX keeps track of the upscaled output,so you only need to pass the color,motion, and depth from the current rendered frame.

Going back to a typical game’s rendering pipeline,MetalFX temporal AA and upscaling should runbefore any post processing effects,since these effects will interferewith the result of the upscaling.

Here's the chess rendering again,this time using MetalFX Temporal AA and upscaling.This is a side by side comparison of 1080p input on the leftand 4K upscaled output on the right.

Zooming in closer to the queen,the input is low resolution and aliased,while the temporally upscaled output on the right is high resolutionwith a smooth outline and has more fine details in the reflections.

Just as with spatial scaler, creating a new temporal scaleris expensive and should only be donewhen your application first startsor when a display switches resolutions.First, you'll need to allocate and fill ina MTLFXTemporalScalerDescriptor.

Then call makeTemporalScaler() method to create the scaler object.

In your initialization code, start with the descriptor.

Fill in both the width and height of the input and output textures.

Then set the jittered color,depth, and motion texture formatsfor the textures that will be bound later on the scaler object as inputs.

Finally, set the format for the output texturewhere MetalFX will store the upscaled output.Once the descriptor is filled, create the scaler object.

On the scaler object, set the motion scale properties.This helps you scale the app's motion data to what the API expects.

MetalFX expects motion datain the render resolution pixel spacewith direction that goes from the current frame’s positionto the previous frame’s position.As an example,I'll use a render resolution of 1080p.Suppose you have an object that moves from clip space coordinate(-0.75, -0.75).to clip space coordinate (0.25, 0.25).The motion data is stored as (1, 1).

Set the motion vector scale propertyto (-960, 540)so that MetalFX can interpret your game's motion data correctly.

You can modify the properties of the scaler object as frequentlyas you want.And call the encode() method to start the upscaling process.

For your per frame draw code,first set the resetHistory property.Set this to true when your application loads the first frameor when there is a scene cut.Then set the textures that are inputs for the effect,followed by the output texture.Next, set the reversedDepth propertyto indicate whether the depth values are in reversed-Z mapping.

The last property to setbefore encoding the scaling effect is the current jitter offset.

Getting jitter offset correctly is essentialto the quality of the output.Let us take a quick look on how to set jitter offset.

As an example, on the left is a triangle rendered with jitter.

On the right is a zoomed in view of a pixel.The sample is located at (0.625, 0.78).The pixel center is represented by the orange dot.It is located at (0.5, 0.5).

In this example,the jitter offset is (-0.125, -0.28).

Note that jitter offsets are alwaysin the range of -0.5 to 0.5.To verify that you are providing the correct jitter offset,render a scene without camera and object motionusing a sequence of different jitter offsets.On the left is an examplewhen incorrect jitter offset is specified.Static objects could shift, and fine lines are fuzzy.

On the right is the outputwhen correct jitter offset is specified.Objects stay in place,and fine lines are resolved progressively.The MetalFX “temporal AA and upscaling” effectboosts your application performanceand gives an upscaling quality that’s comparable to the qualityof the native target resolution rendering.In order to get optimal quality and performancewhen using both upscaling effects,l’ll now cover implementation best practices.

Starting with spatial upscaling.For the best spatial upscaling quality,the color input should be anti-aliased and noise free.This is because noise effectsand aliased images prevent good edge determination,which will worsen the spatial upscaling quality.

For the best performance,use the perceptual color processing mode.This means, your input color should be tone mapped,with values from 0-1, in the sRGB color space.

And finally, set the appropriate negative mip biasfor higher texture detail.The recommended mip bias calculationfor spatial upscaling is to apply log2of the render resolution width,divided by the target resolution width.

For example, scaling each render resolution dimensionby 2x will result in -1 mip bias,while scaling each dimension by 1.5xwill result in -0.58 mip bias.

Note that lower mip levels might result in flickering for textureswith high frequency patterns.You should adjust the mip bias for certain texturesif you spot such artifacts.I will talk next about TemporalAAand upscaling best practices.

To get the best quality from Temporal AA and upscaling,it's important to choose a good jitter sequence.Look for a jitter sequencethat will provide a good distribution of samplesacross all the pixelsin an upscaled target resolution.Usually, eight jittered samples per output pixelproduces a high-quality anti-aliased upscaled output.

In the case of 2x upscaling, the recommendation is to usea Halton (2,3) sequence with 32 jittersto produce your jittered color input.Here’s a plot of the first 32 sample locationsfrom Halton (2,3) sequence,producing approximately eight samples per output pixel.

It's also important to set the appropriate negative mip biasfor higher texture detail.The recommended mip bias calculationfor temporal AA and upscalingis to apply log2 of render resolution width,divided by target resolution width, subtracted by 1.

For example, scaling each render resolution dimensionby 2x will result in a -2 mip bias,while scaling each dimensionby 1.5x will result in a -1.58 mip bias.

Next, I will show you examples of how mip bias affects your outputin different situations.

Here are MetalFX temporal AAand upscaling outputs of the same sceneusing mip bias of 0, -1, and -2.

Mip bias of -2 producesthe sharpest and clearest output,while mip bias of 0 producesthe softest and most blurry output.

Here are three renderings of a circuit boardthat use the temporal upscaling effect.From top to bottom, the mip bias values appliedwhen sampling textures are 0,-1, and -2.Because the circuit board’s textures have high-frequency patterns,such as its tiny trace wires,mip bias of -2 generates flickeringand moire effects.However, mip bias of -1greatly reduces these effects,and mip bias of 0 completely eliminates them.

Lower mip levels generally result in more details.Use our mip bias suggestion as a starting point,but be mindful when choosing a mip biasfor textures with high-frequency patterns.Follow these practices to ensure an anti-aliased,high-quality upscaled outputfrom MetalFX Temporal AA and upscaling.

Finally, I will cover performance best practicewhen using MetalFX Upscaling.To get the best performance with MetalFX Upscaling,you should be careful to avoid binding the same resourcesfor reading and writing in two non-dependent renderor compute passes.Doing so creates false dependencies.In Metal, it's always a good ideato avoid false dependencies.But this is especially important for MetalFX Upscaling,as I will describe next.In this example, there are two frames.The shadow and the post processing passes are completely unrelatedand have no resource dependencies.Metal will overlap the next frame’s shadow passwith the current frame’s post processing pass.

However, if the post processing pass writesto a Metal buffer while the shadow passalso reads from the same buffer,Metal will prevent the GPU from running these two passesin parallel in order to avoid the potential hazard of readingand writing to the same resource at the same time.False dependencies between framescan negatively affect performanceof MetalFX Upscaling.Notice that if there is nofalse dependency between frames,the next frame’s shadow pass could have overlappedwith the previous frame's MetalFX Upscaling.However, because of the false dependencybetween frames,the performance loss nowalso includes the timeit takes for MetalFX Upscalingto finish its process.Ideally, you should ensure thatthere are no false dependenciesbetween frames to allow overlappingof workloads between different frames,ensuring the most optimal performancewhen using MetalFX Upscaling.In this example,you can instead create a separate bufferfor the post processing and shadow passesto prevent the false dependency,resulting in parallel executionof independent passes.

Avoiding false dependencies is something you always wantto keep in mind when adopting MetalFX Upscaling.When deciding which of these two effects to choose,there are some considerations you should also keep in mind.

With ever-increasing shading costs and pixel counts,temporal AA and upscaling is here to stay.Amortizing pixels temporally increases visual fidelityand boosts performance.If you don’t already have a great temporal AA solutionand can render jittered color,motion, and depth buffers,MetalFX temporal AA and upscaling providesa compelling platform-optimized solutionthat you should consider.If you don’t have the necessary inputsor already have a well tuned AA solution,consider using MetalFX spatial upscaling.With that, hopefully you now have a better understandingof which upscaling effect to choose.I will next show examples of both of these effects running livein Metal applications.Here’s a side by side comparison of the “Bistro” scenefrom our “Modern Rendering with Metal” sample code,which features real-time rendering algorithms,like ambient occlusion and volumetric fog.Native rendering at 1080p on the leftversus 4K outputwith MetalFX Spatial upscaling on the right.Note that this sample has its own temporal anti-aliasing solution,which we use as input for MetalFX spatial upscaling.

Zooming in more closely at the scooter...

On the left, the image is a bit blurry, while on the right,the spatially upscaled output resultsin a sharper image with cleaner edges.The straight line on the handle bar is nicely antialiased.

The curve on the body is also much smoother.

Let's do a performance comparison.On the left is a native rendering at 4K.On the right is the 4K outputfrom MetalFX Spatial upscaling.

As the camera moves, the native rendering on the leftis running at a choppy frame rate,while the spatially upscaled outputon the right is much smoother.

Next is a side-by-side comparisonof a ray-traced scene with many reflections and shadows.

On the left is a native rendering at 1080p.On the right is the 4K outputwith MetalFX Temporal AA and upscaling.

Zooming in more closely at the chandelier...

The native output on the left has an aliased look,while the temporally upscaled output on the righthas sharp edges with more fine details.The shadow is nice and crisp rather than fuzzy looking.And fine details on the chandelier can now be recognized.

Performance gains are also apparentwith MetalFX Temporal AA and upscaling.On the left is native rendering at 4K.On the right is the 4K outputwith MetalFX Temporal AA and upscaling.As the camera moves, the native rendering on the leftis running at a very low frame rate,while the temporally upscaled outputon the right is much smoother.

Leading game developers are excitedby the capabilities of MetalFX Upscalingand will be bringing "Grid: Legends,""Resident Evil: Village,"and "No Man’s Sky" to Mac later this year.Next, I’ll show you some early work using the framework.In this scene, we can see the incredible visualsand fluid gameplay of "No Man’s Sky"using MetalFX Temporal AA and Upscaling.To recap,MetalFX is a new API with a focus on upscaling.Spatial upscaling is easy to adoptand delivers substantial performance gains,and you can use Temporal AA and upscalingto deliver higher quality rendering.Following the best practices I talked about earlier will ensureyou get the most out of MetalFX Upscaling.Thank you for watching.♪ ♪

3:39 -Spatial upscaling (initialization)

9:16 -Spatial upscaling (per frame)

9:16 -Temporal antialiasing and upscaling (initialization)

10:35 -Temporal antialiasing and upscaling (per frame)

## Code Samples

```swift
// Spatial upscaling (initialization)



let
 desc 
=
 
MTLFXSpatialScalerDescriptor
()
desc.inputWidth 
=
 
1280

desc.inputHeight 
=
 
720

desc.outputWidth 
=
 
2560

desc.outputHeight 
=
 
1440

desc.colorTextureFormat 
=
 .bgra8Unorm_srgb
desc.outputTextureFormat 
=
 .bgra8Unorm_srgb
desc.colorProcessingMode 
=
 .perceptual

spatialScaler 
=
 desc.makeSpatialScaler(device: mtlDevice)
```

```swift
// Spatial upscaling (per frame)



// Encode Metal commands to draw game frame here...



// Begin setting per frame properties for effect

spatialScaler.colorTexture 
=
 currentFrameColor
spatialScaler.outputTexture 
=
 currentFrameUpscaledColor


// Encode scaling effect into command buffer

spatialScaler.encode(commandBuffer: cmdBuffer)


// Encode Metal commands for particle/noise effects and game UI drawing for frame here...
```

```swift
// Temporal antialiasing and upscaling (initialization)



let
 desc 
=
 
MTLFXTemporalScalerDescriptor
()
desc.inputWidth 
=
 
1280

desc.inputHeight 
=
 
720

desc.outputWidth 
=
 
2560

desc.outputHeight 
=
 
1440

desc.colorTextureFormat 
=
 .rgba16Float
desc.depthTextureFormat 
=
 .depth32Float
desc.motionTextureFormat 
=
 .rg16Float
desc.outputTextureFormat 
=
 .rgba16Float

temporalScaler 
=
 desc.makeTemporalScaler(device: mtlDevice)
temporalScaler.motionVectorScale 
=
 
CGPoint
(x: 
1280
, y: 
720
)
```

```swift
// Temporal antialiasing and upscaling (per frame)



// Encode Metal commands to draw game frame here...



// Setup per frame effect properties

temporalScaler.resetHistory 
=
 firstFrameOrSceneCut
temporalScaler.colorTexture 
=
 currentFrameColor
temporalScaler.depthTexture 
=
 currentFrameDepth
temporalScaler.motionTexture 
=
 currentFrameMotion
temporalScaler.outputTexture 
=
 currentFrameUpscaledColor
temporalScaler.reversedDepth 
=
 reversedDepth
temporalScaler.jitterOffset 
=
 currentFrameJitterOffset


// Encode scaling effect into commandBuffer

temporalScaler.encode(commandBuffer: cmdBuffer)


// Encode Metal commands for post processing/game UI drawing for frame here...
```


# Wwdc2022 110356

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Meet distributed actors in SwiftDiscover distributed actors — an extension of Swift's actor model that simplifies development of distributed systems. We'll explore how distributed actor isolation and location transparency can help you avoid the accidental complexity of networking, serialization, and other transport concerns when working with distributed apps and systems.

To get the most out of this session, watch “Protect mutable state with Swift actors” from WWDC21.ResourcesSE-0336: Distributed Actor IsolationSE-0344: Distributed Actor RuntimeSwift Distributed Actors Cluster LibrarySwift Forums: Distributed ActorsTicTacFish: Implementing a game using distributed actorsHD VideoSD VideoRelated VideosWWDC22Eliminate data races using Swift ConcurrencyUse Xcode for server-side developmentWhat's new in SwiftWWDC22 Day 2 recapWWDC21Protect mutable state with Swift actorsWWDC19Advances in Networking, Part 2

Discover distributed actors — an extension of Swift's actor model that simplifies development of distributed systems. We'll explore how distributed actor isolation and location transparency can help you avoid the accidental complexity of networking, serialization, and other transport concerns when working with distributed apps and systems.

To get the most out of this session, watch “Protect mutable state with Swift actors” from WWDC21.

SE-0336: Distributed Actor Isolation

SE-0344: Distributed Actor Runtime

Swift Distributed Actors Cluster Library

Swift Forums: Distributed Actors

TicTacFish: Implementing a game using distributed actors

HD VideoSD Video

HD Video

SD Video

Eliminate data races using Swift Concurrency

Use Xcode for server-side development

What's new in Swift

WWDC22 Day 2 recap

Protect mutable state with Swift actors

Advances in Networking, Part 2

Search this video…♪ instrumental hip hop music ♪♪Hello! My name is Konradand I'm an engineer on the Swift team.Welcome to "Meet distributed actors in Swift."In this session, we'll learn how you can takeyour Swift concurrency-based apps beyond a single process.Swift actors were designed to protect youfrom low-level data races in the same process.They do this by compile time enforced actor isolation checks.Distributed actors refine the same conceptual actor modeland extend it to multiple processes,such as multiple devices or servers in a cluster.So just in case you are not yet familiar with Swift actors,we recommend you first watchthe "Protect mutable state with Swift actors" sessionfrom WWDC 2021.The app we'll work on during this sessionis a tic-tac-toe-style game I've been developing recently:Tic Tac Fish!The fun idea here is that you can selecta team you're playing for, which then corresponds to emojisthat will be used to mark your moves as you play the game.Then, as you mark your moves on the field,emojis from your team will be placed on the fielduntil one of the players wins.Right now, I have only implemented an offline mode,where I can play against a bot opponent,but I'd like to introduce a few multiplayer modesto take my app to the next level.I'm already using actors in this app to manage concurrencyand model players involved in the game.Let's see what it takes to migrate those player actorsto different processes, and how distributed actorscan help me do this.Before we jump to the code, let us take a step backand visualize why actors are so well-suitedfor building concurrent and distributed applications.Throughout WWDC sessions, you may hear us use the term"sea of concurrency" when talking about actors.This is because it's a great mental modelto think about them.Each actor is its own island in the sea of concurrency,and instead of accessing each other's islands directly,they exchange messages between them.In Swift, sending those messages across islandsis implemented as asynchronous method calls and async/await.This, in combination with actor state isolation,allows the compiler to guaranteethat once an actor-based program compiles,it is free from low-level data races.Now let us now take this same conceptual modeland apply it to our game,reimagined as a distributed system.We can think of each device, node in a cluster,or process of an operating systemas if it were an independent sea of concurrency,here marked as the smaller dark rectangles.Within those, we were able to synchronize informationrather easily since they were stillsharing the same memory space.And while the same concept of message passingworks perfectly well for concurrencyas well as distribution,there are a few more restrictionsdistribution needs to put into place for it all to work.This is where distributed actors come into the picture.By using distributed actors, we're able to establisha channel between two processes and send messages between them.In other words, if Swift actors were islandsin the sea of concurrency, distributed actors are the samein the vast sea of distributed systems.From a programming model, not much has really changed --actors still isolate their stateand still can only communicate using asynchronous messages.We could even have more distributed actorsin the same process,and for all intents and purposes,they are as useful as local actors,with the difference that they're also readyto participate in remote interactions whenever necessary.This ability to be potentially remote without having to changehow we interact with such distributed actoris called "location transparency."This means that regardlesswhere a distributed actor is located,we can interact with it the same way.This is not only fantastic for testing,as we execute the same logic in local actors,but also enables us to transparently move our actorsto wherever they should be located,without having to change their implementation.OK, I think we're ready to look at some codeand convert our first actor to a distributed actor.First, let's have a quick look at the general game UI,and how it interacts with my player actors.The view is a pretty standard SwiftUI code,and I have a few text and button elementsrepresenting the game field.As a user clicks a GameCell,we ask the player actor to generate a moveand update the view models that power the UI.Thanks to Swift concurrency,all those updates are thread-safe and well-behaved.Currently, the actor representing user inputis implemented as an offline player.Let's have a look at it next.This actor encapsulates some state that allows itto generate game moves.Specifically, it needs to track how many moves it already madeand what team it is playing for.Because each team has a number of emojisto chose from for each move, use the number of moves madeto select the emoji character ID.I also need to update the model once a move has been created.The model is a MainActor isolated class,so mutations of it are thread-safe.I do need to use "await"as I make the userMadeMove call, though.Lastly, the offline player also declares a method that isgoing to be called whenever the opponent has made a move.The only thing we need to do here is update the view model,which will make the game field active againso the human player can select their move,and the cycle continues until the game ends.Our bot player is also represented using an actor.Its implementation is actually quite a bit simplerthan the offline playersince it does not have to worry about updating the view model;it just keeps track of the GameStateand generates game moves.Since the bot player is a bit simpler,I think it's a good one to start our conversionto distributed actors.OK, I think we're ready to look at some codeand convert our first actor to a distributed actor.The first step towards our distributed Tic Tac Fish gamewill be to convert the BotPlayer typeto a distributed actor,while still only using it locally.Let's open Xcode and see how we can do that.In order to declare a distributed actor,I'll need to import the new distributed module,which we introduced in Swift 5.7.This module contains all the necessary typesI'm going to need to declare and use distributed actors.I can now add the distributed keywordin front of the BotPlayer actor declaration, like this.This will cause the actor to automatically conformto the DistributedActor protocol,and enable a number of additional compile time checks.Let's see what kind of errorsthe compiler will ask us to fix now.The compiler helpfully tells us that the BotPlayer does notdeclare an ActorSystem it can be used with.As distributed actorsalways belong to some distributed actor system,which handles all the serialization and networkingnecessary to perform remote calls;we need to declare what type of actor systemthis actor is intended to be used with.Since, for now, my only goal is to have the bot playerpass all the distributed isolation checks,without actually running it on a remote host, I can use theLocalTestingDistributedActor Systemthat comes with the Distributed module.I can tell the compilerabout the actor system we're going to useby either declaring a module-wideDefaultDistributedActorSystem typealias,or an ActorSystem typealias in the body of the specific actor.The latter bit is a bit more specific, so let's go with that.The next error is about the "id" property,that I had previously implemented manuallyin order to conform to the Identifiable protocolthat both my player actors need to conform to.The error now says that the ID propertycannot be defined explicitly as it conflictswith a distributed actor synthesized property.IDs are a crucial piece of distributed actors.They are used to uniquely identify an actorin the entire distributed actor system that it is part of.They are assigned by the distributed actor systemas the actor is initialized,and later managed by that system.As such, we cannot declare or assignthe ID property manually --the actor system will be doing this for us.In other words, I can simply leave it to the actor systemand remove my manually declared ID property.The last error we need to deal with hereis the distributed actor's initializer.The compiler says that the actorSystem propertyhas not been initialized before use.This is another compiler synthesized propertythat is part of every distributed actor.Not only do we need to declare the type of actor systemwe want to use, but we also need to initializethe synthesized actorSystem propertywith some concrete actor system.Generally, the right thing to do hereis to accept an actor system in the initializer,and pass it through to the property.This way, I could pass in a different actor systemimplementation in my tests to facilitate easy unit testing.We'll also have to pass an instance whenever we createa new bot player, so let's do this now.Awesome! We're done with all the declaration side errors.But there's still some call-site errorswe need to address though.It seems that only distributed methodscan be called on potentially remote distributed actors.This is similar to annotating only some actors in your systemas distributed actors.Not every method on a distributed actoris necessarily designed to be called remotely.They can have small helper functions,or functions which assume the callerhas already been authenticated.This is why Swift asks you to be explicit aboutthe distributed API surface,you want to expose to remote callers.Thankfully, this is also easily fixed by just addingthe distributed keyword to those functions.As both makeMove and opponentMoved methodsare intended to be called remotely,let me add the distributed keyword to them to both of them.OK! With that, there's only one last thingwe need to take care of.As distributed method calls can cross network boundaries,we need to ensure that all of their parametersand return values conform to the serialization requirementof the actor system.In our case, the actor system is using Codable,Swift's native serialization mechanism.Specifically, the compiler tells us that,"Result type GameMove does not conformto the serialization requirement Codable."Let me have a quick look at the GameMove type.Luckily, it seems that it's a clean little data typethat I can easily make Codableby just adding the necessary conformance.The Swift compiler will synthesizethe necessary Codable implementation for me.And with that, we're done!I can check the game runs as expected.OK, a point for team fish!And although the bot player still executingon the same local device, we have already paved the wayfor the exciting next step.In this step, we'll actually reap the benefitsof the bot player's newly gained location transparency powers.I have already prepared a WebSocket-basedsample actor system that we can use for this.By making use of this actor system,we'll be able to move our bot playerto a server-side Swift application,and resolve a remote reference to it from our mobile game.As far as the actor is concerned,we only need to change the declared ActorSystemfrom the LocalTesting DistributedActor Systemto the SampleWebSocketActorSystemthat I prepared for the sample app.The rest of the actor code remains the same.Next, let us resolve a remote bot player reference,rather than creating one locally.It is worth keeping in mind that the terms "local" and "remote"are a matter of perspective when it comes to distributed actors.For every remote reference, there is some correspondinglocal instance on some other nodein the distributed actor system.Creating a local instance of a distributed actoris performed much the same way as any other Swift object:by calling its initializer.Obtaining a remote reference to a distributed actor, however,follows a slightly different pattern.Instead of creating an actor,we will attempt to resolve an actor IDusing a concrete actor system.The static resolve method allows us to ask an actor systemto attempt to give us an existing actor instancefor an actor with that IDor, return a remote reference to an actor identified by it.Actor systems should not perform actual remote lookupswhen resolving identifiers because as you can see,the resolve method is not asynchronous,and therefore should return quicklyand not perform any networkingor otherwise blocking operations.If an identity looks valid, and seems to be pointingat a valid remote location, systems shall assumethat such actor exists and return a remote reference to it.Keep in mind that at the time of resolving an ID,the actual instance on the remote systemmay not even exist yet!For example, here we're making up a random identifierfor an opponent bot playerthat should be dedicated to playing a game with us.This bot does not exist yet, but it will be createdon the server-side system as the first messagedesignated to this ID is received.Now moving on to a server-side Swift application.Thanks to the sample WebSocket actor system I prepared,implementing that will be a breeze.First, we create the WebSocket actor system in server mode,which makes it bind and listen to the portrather than connect to it.And we have the app wait until the system is terminated.Next, we'll somehow need to handle the patternof creating actors on demandas we receive messages addressed to IDsthat are not yet assigned any actor instances.Generally, the actor system will receive incoming messages,attempt to resolve their recipient IDsin order locate a local distributed actor instance,and then execute a remote call on the located actor.As we just discussed though,our bot player IDs are literally made up,so the system can't possibly know about themand even less so create the right type of actor by itself.Thankfully, our sample actor system implementationhas just the right pattern prepared for us:on-demand actor creation.Please note here that this is only a pattern,and not something built in or provided bythe distributed actor module.It is, however, a great example of how flexibleand powerful actor system implementations can be.A system can offer various patternsand make complex tasks simple to deal with.Using this pattern, the actor system attemptsto resolve a local actor for all incoming IDs as usual.However, when it fails to find an existing actor,it attempts to resolveCreateOnDemand.Since we are in control of both our client codemaking up the IDs and the piece of server code,we can help the actor system outby creating the necessary actors on demand.Since the bot identifiers we have been making upon the client are using some recognizable naming scheme --like adding tags to the ActorIdentityor just using some recognizable names --we can detect those IDs and create a new bot opponentfor every message that does not have one active yet.We'll only create a new bot playerfor the first message designated to it,as subsequent remote callswill simply resolve the existing instance.And that's all there is to it!Our server implementation is completeand we can now play a game with our remote bot player.We can run the server from the command line using Swift run,or using Xcode and selecting the server schemeand clicking Run as usual.As we're done making our first move,we ask the bot player to do the same by calling makeMoveon the remote player reference we have created.This triggers a resolve in the server-side system.It can't find an existing bot for this ID,so it attempts and succeeds, creating a bot on demand.The bot receives a makeMove call,and replies with the GameMove it generated.That was pretty great already!While we did have to do some up-front workto convert our bot player to a distributed actor,actually moving it to the remote systemwas pretty straightforward.And we didn't have to deal with any networkingor serialization implementation details at all!All the heavy lifting was done for usby the distributed actor system.And while there aren't many hardenedfeature-complete implementations available just yet,this ease of going distributedis something we're striving for with this feature.Next, let's see how we can builda true multiplayer experience for our game.Our previous example used distributed actorsin a client/server scenario, which you may befamiliar with already from other apps you worked on.However, distributed actors can also be usedin peer-to-peer systems,where there isn't a dedicated server component at all.This matches another idea I had for our game.Sometimes when traveling, you end up in these locationsthat don't really have great internet,but the local Wi-Fi works great.I'd like to still be able to challengeand play with my friends --which are connected to the same network --as I end up in such a situation.I went ahead and implementedanother actor system implementation,this time using local networking featuresoffered by Network framework.While we don't dive into the implementationof that actor system in this talk, you can watch"Advances in Networking, Part 2" from WWDC 2019to learn how you would implement such custom protocol.It is also worth pointing out that access to local networkcan expose very privacy-sensitive information,so please take care to use it respectfully.Since this time we'll be dealing withalready existing distributed actors on other devices,we can no longer just make up the IDslike we did in the previous example.We have to discover the specific actoron the other device we'd like to play a game with.This problem isn't unique to distributed actors,and is generally solved using service discovery mechanisms.However, in the domain of distributed actors,there is a common pattern and style of APIactor systems are expected to offer that allows youto stick to strongly-typed APIs throughout all your code.We call it the receptionist pattern,because similar to a hotel, actors need to check in with itin order to become known and available for others to meet.Every actor system has its own receptionistand they can use whatever means most suitable for the underlyingtransport mechanisms to implement actor discovery.Sometimes this may rely on existing service discovery APIs,and only layer a type-safe API on top of them,or it may implement a gossip-based mechanism,or something else entirely.This, however, is an implementation detailfrom the perspective of the user of the actor system;all we need to care about is checking in our actorto make it discoverableand look up actors by some tag or typewhen we need to discover them.Let's have a look at a simple receptionist I have implementedfor our SampleLocalNetworkActorSystem.It allows an actor to check in, which enables all receptionistsin the distributed actor system to discover it.We can then get a listing of all actors of a specific typeand tag as they become available in that system.Let's use this receptionist to discovera concrete opponent actor we'd like to play a game with.Previously, our GameView directly created --or resolved -- an opponent in its view initializer.We can no longer do this, as we need to asynchronouslywait for an opponent to appear on the network.To do this, let me introduce a matchmaking viewthat will show a "Looking for opponent..." messagewhile we're trying to discover one.As this view appears, we'll kick off the matchmaking.The matchmaking will be donein a new unstructured task in which we'll askthe local actor system's receptionistfor a listing of all actors taggedusing the opposing team's tag.So if we're playing for team fish,we'll be looking for players from the team rodents,and vice versa.Next, we'll use an async for loopto await incoming opponent actors.As the system discovers a nearby device with an opponentwe could play with, this task loop will be resumed.Let's assume the opponent is always ready to play a gameand immediately store it in our modeland start a game with them.We use a helper function to decidewho should make the first move, and finally,tell the opponent that we want to start a game with them.Be sure to return here, in order to break outof the async for loop, as we only need one opponentto be done with our matchmaking task.For this gameplay mode, we do have to changeour OfflinePlayer implementation a little.Let's call it LocalNetworkPlayer,and it'll be using the SampleLocalNetworkActorSystem.What's most interesting about it is that the makeMove methodof the the actor representing a human playermay now be invoked remotely!But making the move is actuallythe responsibility of a human player.In order to solve this challenge,we introduce a humanSelectedFieldasynchronous function to our view model.It is powered by a @Published value that is triggeredwhen the human user clicks on one of the fields.As the human player clicks a field,our makeMove function resumes, and we complete the remote callby returning the performed GameMove to the remote caller.And again, that's all there is to it!We had to change the actor implementationa little to handle our true multiplayer game mode,but nothing really changedin the overall design of the system.And most importantly,nothing in our game logic changes was really specificto the fact we'll be using local networking.We discover an opponent and play a game with themby invoking distributed methods on player actors.To demo this game mode, I'll need an opponent to play with.Let's ask my fluffy assistant Caplin the Capybara.I heard he's pretty good at it!OK, he's pretty smart.He is pretty good at it.Let me try here.Oh, he got me!This time you win, little critter,but we'll play another session.Thanks for your help, Caplin!Last but not least,let me give you an idea of what we can achieveby combining different actor systems.For example, we can use the WebSocket system to registerdevice-hosted actor player actorsin a server-side lobby systemthat will pair them up and act as a proxyfor distributed calls between them.We might implement a GameLobby actor,with which device-hosted player actorsare able to register themselves.As devices enter the play online mode,they would discover the GameLobby using a receptionist,and call join on it.The GameLobby keeps track of available playersand starts a game sessionwhen a pair of players has been identified.A game session would act as the driver of the game,polling moves and marking themin the server-stored representation of the game.As the game completes, we can collect resultsand report back to the lobby.More interestingly though,we can scale this design horizontally.We can of course create more game session actorsto serve more games concurrently on a single server,but thanks to distributed actors,we could even create a game session on other nodesin order to load balance the number of concurrent gamesacross a cluster.That is, if only we had a cluster actor system.And, in fact, we do!We open-sourced a feature-rich Cluster Actor system libraryfor you to use in such scenarios.It's implemented using SwiftNIO, and specializedfor server-side data-center clustering.It applies advanced techniques for failure detection,and comes with it's own implementationof a cluster-wide receptionist.We encourage you to have a look at it,as it is both an advanced reference implementationof an actor system,and because of its powerful server-side applications.Let's recap what we learned during this session.First, we learned about distributed actorsand how we provide additional compiler-assistedactor isolation and serialization checking.We learned how they enable location transparency,and how we can make use of it to free our actorsfrom the necessity of being located in the same processas their caller.We also saw a few actor system implementations in actionto get you inspired about what you could buildusing distributed actors.Distributed actors are only as powerful as the actor systemsthey are used with.So for your reference,here is a list of actor systems we saw during this session.The local testing system, which ships by default with Swift,and two sample actor systems:a client/server style WebSocket-based oneand a local networking-based system.These systems are rather incomplete,and served more as an inspirationfor what you might build using distributed actors.You can view them in the sample code appassociated with this session.And last but not least, an open sourcefully featured server-side clustering implementation.Available as a beta package now,and it will be matured alongside Swift 5.7.To learn more about distributed actors,you can refer to the following resources:the sample code associated with this session,which includes all the steps of our Tic Tac Fish gameso you can deep dive into the code yourself.The Swift evolution proposalsassociated with the distributed actors language feature,which explain the mechanisms powering them in great detail.You can also reach out on the Swift forums,where you can find a distributed actors categorydedicated to actor system developers and users alike.Thanks for listening, and I'm looking forward to seeingwhat you'll use distributed actors for in your apps!♪

♪ instrumental hip hop music ♪♪Hello! My name is Konradand I'm an engineer on the Swift team.Welcome to "Meet distributed actors in Swift."In this session, we'll learn how you can takeyour Swift concurrency-based apps beyond a single process.Swift actors were designed to protect youfrom low-level data races in the same process.They do this by compile time enforced actor isolation checks.Distributed actors refine the same conceptual actor modeland extend it to multiple processes,such as multiple devices or servers in a cluster.So just in case you are not yet familiar with Swift actors,we recommend you first watchthe "Protect mutable state with Swift actors" sessionfrom WWDC 2021.The app we'll work on during this sessionis a tic-tac-toe-style game I've been developing recently:Tic Tac Fish!The fun idea here is that you can selecta team you're playing for, which then corresponds to emojisthat will be used to mark your moves as you play the game.Then, as you mark your moves on the field,emojis from your team will be placed on the fielduntil one of the players wins.Right now, I have only implemented an offline mode,where I can play against a bot opponent,but I'd like to introduce a few multiplayer modesto take my app to the next level.I'm already using actors in this app to manage concurrencyand model players involved in the game.Let's see what it takes to migrate those player actorsto different processes, and how distributed actorscan help me do this.Before we jump to the code, let us take a step backand visualize why actors are so well-suitedfor building concurrent and distributed applications.Throughout WWDC sessions, you may hear us use the term"sea of concurrency" when talking about actors.This is because it's a great mental modelto think about them.Each actor is its own island in the sea of concurrency,and instead of accessing each other's islands directly,they exchange messages between them.In Swift, sending those messages across islandsis implemented as asynchronous method calls and async/await.This, in combination with actor state isolation,allows the compiler to guaranteethat once an actor-based program compiles,it is free from low-level data races.Now let us now take this same conceptual modeland apply it to our game,reimagined as a distributed system.We can think of each device, node in a cluster,or process of an operating systemas if it were an independent sea of concurrency,here marked as the smaller dark rectangles.Within those, we were able to synchronize informationrather easily since they were stillsharing the same memory space.And while the same concept of message passingworks perfectly well for concurrencyas well as distribution,there are a few more restrictionsdistribution needs to put into place for it all to work.This is where distributed actors come into the picture.By using distributed actors, we're able to establisha channel between two processes and send messages between them.In other words, if Swift actors were islandsin the sea of concurrency, distributed actors are the samein the vast sea of distributed systems.From a programming model, not much has really changed --actors still isolate their stateand still can only communicate using asynchronous messages.We could even have more distributed actorsin the same process,and for all intents and purposes,they are as useful as local actors,with the difference that they're also readyto participate in remote interactions whenever necessary.This ability to be potentially remote without having to changehow we interact with such distributed actoris called "location transparency."This means that regardlesswhere a distributed actor is located,we can interact with it the same way.This is not only fantastic for testing,as we execute the same logic in local actors,but also enables us to transparently move our actorsto wherever they should be located,without having to change their implementation.OK, I think we're ready to look at some codeand convert our first actor to a distributed actor.First, let's have a quick look at the general game UI,and how it interacts with my player actors.The view is a pretty standard SwiftUI code,and I have a few text and button elementsrepresenting the game field.As a user clicks a GameCell,we ask the player actor to generate a moveand update the view models that power the UI.Thanks to Swift concurrency,all those updates are thread-safe and well-behaved.Currently, the actor representing user inputis implemented as an offline player.Let's have a look at it next.This actor encapsulates some state that allows itto generate game moves.Specifically, it needs to track how many moves it already madeand what team it is playing for.Because each team has a number of emojisto chose from for each move, use the number of moves madeto select the emoji character ID.I also need to update the model once a move has been created.The model is a MainActor isolated class,so mutations of it are thread-safe.I do need to use "await"as I make the userMadeMove call, though.Lastly, the offline player also declares a method that isgoing to be called whenever the opponent has made a move.The only thing we need to do here is update the view model,which will make the game field active againso the human player can select their move,and the cycle continues until the game ends.Our bot player is also represented using an actor.Its implementation is actually quite a bit simplerthan the offline playersince it does not have to worry about updating the view model;it just keeps track of the GameStateand generates game moves.Since the bot player is a bit simpler,I think it's a good one to start our conversionto distributed actors.OK, I think we're ready to look at some codeand convert our first actor to a distributed actor.The first step towards our distributed Tic Tac Fish gamewill be to convert the BotPlayer typeto a distributed actor,while still only using it locally.Let's open Xcode and see how we can do that.In order to declare a distributed actor,I'll need to import the new distributed module,which we introduced in Swift 5.7.This module contains all the necessary typesI'm going to need to declare and use distributed actors.I can now add the distributed keywordin front of the BotPlayer actor declaration, like this.This will cause the actor to automatically conformto the DistributedActor protocol,and enable a number of additional compile time checks.Let's see what kind of errorsthe compiler will ask us to fix now.The compiler helpfully tells us that the BotPlayer does notdeclare an ActorSystem it can be used with.As distributed actorsalways belong to some distributed actor system,which handles all the serialization and networkingnecessary to perform remote calls;we need to declare what type of actor systemthis actor is intended to be used with.Since, for now, my only goal is to have the bot playerpass all the distributed isolation checks,without actually running it on a remote host, I can use theLocalTestingDistributedActor Systemthat comes with the Distributed module.I can tell the compilerabout the actor system we're going to useby either declaring a module-wideDefaultDistributedActorSystem typealias,or an ActorSystem typealias in the body of the specific actor.The latter bit is a bit more specific, so let's go with that.

The next error is about the "id" property,that I had previously implemented manuallyin order to conform to the Identifiable protocolthat both my player actors need to conform to.The error now says that the ID propertycannot be defined explicitly as it conflictswith a distributed actor synthesized property.IDs are a crucial piece of distributed actors.They are used to uniquely identify an actorin the entire distributed actor system that it is part of.They are assigned by the distributed actor systemas the actor is initialized,and later managed by that system.As such, we cannot declare or assignthe ID property manually --the actor system will be doing this for us.In other words, I can simply leave it to the actor systemand remove my manually declared ID property.The last error we need to deal with hereis the distributed actor's initializer.The compiler says that the actorSystem propertyhas not been initialized before use.This is another compiler synthesized propertythat is part of every distributed actor.Not only do we need to declare the type of actor systemwe want to use, but we also need to initializethe synthesized actorSystem propertywith some concrete actor system.Generally, the right thing to do hereis to accept an actor system in the initializer,and pass it through to the property.This way, I could pass in a different actor systemimplementation in my tests to facilitate easy unit testing.We'll also have to pass an instance whenever we createa new bot player, so let's do this now.

Awesome! We're done with all the declaration side errors.But there's still some call-site errorswe need to address though.It seems that only distributed methodscan be called on potentially remote distributed actors.This is similar to annotating only some actors in your systemas distributed actors.Not every method on a distributed actoris necessarily designed to be called remotely.They can have small helper functions,or functions which assume the callerhas already been authenticated.This is why Swift asks you to be explicit aboutthe distributed API surface,you want to expose to remote callers.Thankfully, this is also easily fixed by just addingthe distributed keyword to those functions.As both makeMove and opponentMoved methodsare intended to be called remotely,let me add the distributed keyword to them to both of them.

OK! With that, there's only one last thingwe need to take care of.As distributed method calls can cross network boundaries,we need to ensure that all of their parametersand return values conform to the serialization requirementof the actor system.In our case, the actor system is using Codable,Swift's native serialization mechanism.Specifically, the compiler tells us that,"Result type GameMove does not conformto the serialization requirement Codable."Let me have a quick look at the GameMove type.Luckily, it seems that it's a clean little data typethat I can easily make Codableby just adding the necessary conformance.The Swift compiler will synthesizethe necessary Codable implementation for me.And with that, we're done!I can check the game runs as expected.

OK, a point for team fish!And although the bot player still executingon the same local device, we have already paved the wayfor the exciting next step.In this step, we'll actually reap the benefitsof the bot player's newly gained location transparency powers.I have already prepared a WebSocket-basedsample actor system that we can use for this.By making use of this actor system,we'll be able to move our bot playerto a server-side Swift application,and resolve a remote reference to it from our mobile game.As far as the actor is concerned,we only need to change the declared ActorSystemfrom the LocalTesting DistributedActor Systemto the SampleWebSocketActorSystemthat I prepared for the sample app.The rest of the actor code remains the same.Next, let us resolve a remote bot player reference,rather than creating one locally.It is worth keeping in mind that the terms "local" and "remote"are a matter of perspective when it comes to distributed actors.For every remote reference, there is some correspondinglocal instance on some other nodein the distributed actor system.Creating a local instance of a distributed actoris performed much the same way as any other Swift object:by calling its initializer.Obtaining a remote reference to a distributed actor, however,follows a slightly different pattern.Instead of creating an actor,we will attempt to resolve an actor IDusing a concrete actor system.The static resolve method allows us to ask an actor systemto attempt to give us an existing actor instancefor an actor with that IDor, return a remote reference to an actor identified by it.Actor systems should not perform actual remote lookupswhen resolving identifiers because as you can see,the resolve method is not asynchronous,and therefore should return quicklyand not perform any networkingor otherwise blocking operations.If an identity looks valid, and seems to be pointingat a valid remote location, systems shall assumethat such actor exists and return a remote reference to it.Keep in mind that at the time of resolving an ID,the actual instance on the remote systemmay not even exist yet!For example, here we're making up a random identifierfor an opponent bot playerthat should be dedicated to playing a game with us.This bot does not exist yet, but it will be createdon the server-side system as the first messagedesignated to this ID is received.Now moving on to a server-side Swift application.Thanks to the sample WebSocket actor system I prepared,implementing that will be a breeze.First, we create the WebSocket actor system in server mode,which makes it bind and listen to the portrather than connect to it.And we have the app wait until the system is terminated.Next, we'll somehow need to handle the patternof creating actors on demandas we receive messages addressed to IDsthat are not yet assigned any actor instances.Generally, the actor system will receive incoming messages,attempt to resolve their recipient IDsin order locate a local distributed actor instance,and then execute a remote call on the located actor.As we just discussed though,our bot player IDs are literally made up,so the system can't possibly know about themand even less so create the right type of actor by itself.Thankfully, our sample actor system implementationhas just the right pattern prepared for us:on-demand actor creation.Please note here that this is only a pattern,and not something built in or provided bythe distributed actor module.It is, however, a great example of how flexibleand powerful actor system implementations can be.A system can offer various patternsand make complex tasks simple to deal with.Using this pattern, the actor system attemptsto resolve a local actor for all incoming IDs as usual.However, when it fails to find an existing actor,it attempts to resolveCreateOnDemand.Since we are in control of both our client codemaking up the IDs and the piece of server code,we can help the actor system outby creating the necessary actors on demand.Since the bot identifiers we have been making upon the client are using some recognizable naming scheme --like adding tags to the ActorIdentityor just using some recognizable names --we can detect those IDs and create a new bot opponentfor every message that does not have one active yet.We'll only create a new bot playerfor the first message designated to it,as subsequent remote callswill simply resolve the existing instance.And that's all there is to it!Our server implementation is completeand we can now play a game with our remote bot player.We can run the server from the command line using Swift run,or using Xcode and selecting the server schemeand clicking Run as usual.As we're done making our first move,we ask the bot player to do the same by calling makeMoveon the remote player reference we have created.This triggers a resolve in the server-side system.It can't find an existing bot for this ID,so it attempts and succeeds, creating a bot on demand.The bot receives a makeMove call,and replies with the GameMove it generated.That was pretty great already!While we did have to do some up-front workto convert our bot player to a distributed actor,actually moving it to the remote systemwas pretty straightforward.And we didn't have to deal with any networkingor serialization implementation details at all!All the heavy lifting was done for usby the distributed actor system.And while there aren't many hardenedfeature-complete implementations available just yet,this ease of going distributedis something we're striving for with this feature.Next, let's see how we can builda true multiplayer experience for our game.Our previous example used distributed actorsin a client/server scenario, which you may befamiliar with already from other apps you worked on.However, distributed actors can also be usedin peer-to-peer systems,where there isn't a dedicated server component at all.This matches another idea I had for our game.Sometimes when traveling, you end up in these locationsthat don't really have great internet,but the local Wi-Fi works great.I'd like to still be able to challengeand play with my friends --which are connected to the same network --as I end up in such a situation.I went ahead and implementedanother actor system implementation,this time using local networking featuresoffered by Network framework.While we don't dive into the implementationof that actor system in this talk, you can watch"Advances in Networking, Part 2" from WWDC 2019to learn how you would implement such custom protocol.It is also worth pointing out that access to local networkcan expose very privacy-sensitive information,so please take care to use it respectfully.Since this time we'll be dealing withalready existing distributed actors on other devices,we can no longer just make up the IDslike we did in the previous example.We have to discover the specific actoron the other device we'd like to play a game with.This problem isn't unique to distributed actors,and is generally solved using service discovery mechanisms.However, in the domain of distributed actors,there is a common pattern and style of APIactor systems are expected to offer that allows youto stick to strongly-typed APIs throughout all your code.We call it the receptionist pattern,because similar to a hotel, actors need to check in with itin order to become known and available for others to meet.Every actor system has its own receptionistand they can use whatever means most suitable for the underlyingtransport mechanisms to implement actor discovery.Sometimes this may rely on existing service discovery APIs,and only layer a type-safe API on top of them,or it may implement a gossip-based mechanism,or something else entirely.This, however, is an implementation detailfrom the perspective of the user of the actor system;all we need to care about is checking in our actorto make it discoverableand look up actors by some tag or typewhen we need to discover them.Let's have a look at a simple receptionist I have implementedfor our SampleLocalNetworkActorSystem.It allows an actor to check in, which enables all receptionistsin the distributed actor system to discover it.We can then get a listing of all actors of a specific typeand tag as they become available in that system.Let's use this receptionist to discovera concrete opponent actor we'd like to play a game with.Previously, our GameView directly created --or resolved -- an opponent in its view initializer.We can no longer do this, as we need to asynchronouslywait for an opponent to appear on the network.To do this, let me introduce a matchmaking viewthat will show a "Looking for opponent..." messagewhile we're trying to discover one.As this view appears, we'll kick off the matchmaking.The matchmaking will be donein a new unstructured task in which we'll askthe local actor system's receptionistfor a listing of all actors taggedusing the opposing team's tag.So if we're playing for team fish,we'll be looking for players from the team rodents,and vice versa.Next, we'll use an async for loopto await incoming opponent actors.As the system discovers a nearby device with an opponentwe could play with, this task loop will be resumed.Let's assume the opponent is always ready to play a gameand immediately store it in our modeland start a game with them.We use a helper function to decidewho should make the first move, and finally,tell the opponent that we want to start a game with them.Be sure to return here, in order to break outof the async for loop, as we only need one opponentto be done with our matchmaking task.For this gameplay mode, we do have to changeour OfflinePlayer implementation a little.Let's call it LocalNetworkPlayer,and it'll be using the SampleLocalNetworkActorSystem.What's most interesting about it is that the makeMove methodof the the actor representing a human playermay now be invoked remotely!But making the move is actuallythe responsibility of a human player.In order to solve this challenge,we introduce a humanSelectedFieldasynchronous function to our view model.It is powered by a @Published value that is triggeredwhen the human user clicks on one of the fields.As the human player clicks a field,our makeMove function resumes, and we complete the remote callby returning the performed GameMove to the remote caller.And again, that's all there is to it!We had to change the actor implementationa little to handle our true multiplayer game mode,but nothing really changedin the overall design of the system.And most importantly,nothing in our game logic changes was really specificto the fact we'll be using local networking.We discover an opponent and play a game with themby invoking distributed methods on player actors.To demo this game mode, I'll need an opponent to play with.Let's ask my fluffy assistant Caplin the Capybara.I heard he's pretty good at it!OK, he's pretty smart.

He is pretty good at it.Let me try here.Oh, he got me!This time you win, little critter,but we'll play another session.Thanks for your help, Caplin!Last but not least,let me give you an idea of what we can achieveby combining different actor systems.For example, we can use the WebSocket system to registerdevice-hosted actor player actorsin a server-side lobby systemthat will pair them up and act as a proxyfor distributed calls between them.We might implement a GameLobby actor,with which device-hosted player actorsare able to register themselves.As devices enter the play online mode,they would discover the GameLobby using a receptionist,and call join on it.The GameLobby keeps track of available playersand starts a game sessionwhen a pair of players has been identified.A game session would act as the driver of the game,polling moves and marking themin the server-stored representation of the game.As the game completes, we can collect resultsand report back to the lobby.More interestingly though,we can scale this design horizontally.We can of course create more game session actorsto serve more games concurrently on a single server,but thanks to distributed actors,we could even create a game session on other nodesin order to load balance the number of concurrent gamesacross a cluster.That is, if only we had a cluster actor system.And, in fact, we do!We open-sourced a feature-rich Cluster Actor system libraryfor you to use in such scenarios.It's implemented using SwiftNIO, and specializedfor server-side data-center clustering.It applies advanced techniques for failure detection,and comes with it's own implementationof a cluster-wide receptionist.We encourage you to have a look at it,as it is both an advanced reference implementationof an actor system,and because of its powerful server-side applications.Let's recap what we learned during this session.First, we learned about distributed actorsand how we provide additional compiler-assistedactor isolation and serialization checking.We learned how they enable location transparency,and how we can make use of it to free our actorsfrom the necessity of being located in the same processas their caller.We also saw a few actor system implementations in actionto get you inspired about what you could buildusing distributed actors.Distributed actors are only as powerful as the actor systemsthey are used with.So for your reference,here is a list of actor systems we saw during this session.The local testing system, which ships by default with Swift,and two sample actor systems:a client/server style WebSocket-based oneand a local networking-based system.These systems are rather incomplete,and served more as an inspirationfor what you might build using distributed actors.You can view them in the sample code appassociated with this session.And last but not least, an open sourcefully featured server-side clustering implementation.Available as a beta package now,and it will be matured alongside Swift 5.7.To learn more about distributed actors,you can refer to the following resources:the sample code associated with this session,which includes all the steps of our Tic Tac Fish gameso you can deep dive into the code yourself.The Swift evolution proposalsassociated with the distributed actors language feature,which explain the mechanisms powering them in great detail.You can also reach out on the Swift forums,where you can find a distributed actors categorydedicated to actor system developers and users alike.Thanks for listening, and I'm looking forward to seeingwhat you'll use distributed actors for in your apps!♪

4:49 -actor OfflinePlayer

5:39 -actor BotPlayer

6:11 -distributed actor BotPlayer

12:08 -Resolving a remote BotPlayer

13:35 -Server-side actor system app

20:02 -Receptionist listing

20:23 -distributed actor LocalNetworkPlayer

## Code Samples

```swift
public
 
actor
 
OfflinePlayer
: 
Identifiable
 {
    
nonisolated
 
public
 
let
 id: 
ActorIdentity
 
=
 .random

    
let
 team: 
CharacterTeam

    
let
 model: 
GameViewModel

    
var
 movesMade: 
Int
 
=
 
0


    
public
 
init
(
team
: 
CharacterTeam
, 
model
: 
GameViewModel
) {
        
self
.team 
=
 team
        
self
.model 
=
 model
    }

    
public
 
func
 
makeMove
(
at
 
position
: 
Int
) 
async
 
throws
 -> 
GameMove
 {
        
let
 move 
=
 
GameMove
(
            playerID: id,
            position: position,
            team: team,
            teamCharacterID: team.characterID(for: movesMade))
        
await
 model.userMadeMove(move: move)

        movesMade 
+=
 
1
 
        
return
 move
    }

    
public
 
func
 
opponentMoved
(
_
 
move
: 
GameMove
) 
async
 
throws
 {
        
do
 {
            
try
 
await
 model.markOpponentMove(move)
        } 
catch
 {
            log(
"player"
, 
"Opponent made illegal move! 
\(move)
"
)
        }
    }

}
```

```swift
public
 
actor
 
BotPlayer
: 
Identifiable
 {
    
nonisolated
 
public
 
let
 id: 
ActorIdentity
 
=
 .random
    
    
var
 ai: 
RandomPlayerBotAI

    
var
 gameState: 
GameState

    
    
public
 
init
(
team
: 
CharacterTeam
) {
        
self
.gameState 
=
 .
init
()
        
self
.ai 
=
 
RandomPlayerBotAI
(playerID: 
self
.id, team: team)
    }
    
    
public
 
func
 
makeMove
() 
throws
 -> 
GameMove
 {
        
return
 
try
 ai.decideNextMove(given: 
&
gameState)
    }
    
    
public
 
func
 
opponentMoved
(
_
 
move
: 
GameMove
) 
async
 
throws
 {
        
try
 gameState.mark(move)
    }
}
```

```swift
import
 Distributed 


public
 distributed 
actor
 
BotPlayer
: 
Identifiable
 {
    
typealias
 
ActorSystem
 
=
 
LocalTestingDistributedActorSystem

  
    
var
 ai: 
RandomPlayerBotAI

    
var
 gameState: 
GameState

    
    
public
 
init
(
team
: 
CharacterTeam
, 
actorSystem
: 
ActorSystem
) {
        
self
.actorSystem 
=
 actorSystem 
// first, initialize the implicitly synthesized actor system property

        
self
.gameState 
=
 .
init
()
        
self
.ai 
=
 
RandomPlayerBotAI
(playerID: 
self
.id, team: team) 
// use the synthesized `id` property

    }
    
    
public
 distributed 
func
 
makeMove
() 
throws
 -> 
GameMove
 {
        
return
 
try
 ai.decideNextMove(given: 
&
gameState)
    }
    
    
public
 distributed 
func
 
opponentMoved
(
_
 
move
: 
GameMove
) 
async
 
throws
 {
        
try
 gameState.mark(move)
    }
}
```

```swift
let
 sampleSystem: 
SampleWebSocketActorSystem



let
 opponentID: 
BotPlayer
.
ID
 
=
 .randomID(opponentFor: 
self
.id)

let
 bot 
=
 
try
 
BotPlayer
.resolve(id: opponentID, using: sampleSystem) 
// resolve potentially remote bot player
```

```swift
import
 Distributed

import
 TicTacFishShared


/// Stand alone server-side swift application, running our SampleWebSocketActorSystem in server mode.


@main


struct
 
Boot
 {
    
    
static
 
func
 
main
() {
        
let
 system 
=
 
try!
 
SampleWebSocketActorSystem
(mode: .serverOnly(host: 
"localhost"
, port: 
8888
))
        
        system.registerOnDemandResolveHandler { id 
in

            
// We create new BotPlayers "ad-hoc" as they are requested for.

            
// Subsequent resolves are able to resolve the same instance.

            
if
 system.isBotID(id) {
                
return
 system.makeActorWithID(id) {
                    
OnlineBotPlayer
(team: .rodents, actorSystem: system)
                }
            }
            
            
return
 
nil
 
// unable to create-on-demand for given id

        }
        
        
print
(
"========================================================"
)
        
print
(
"=== TicTacFish Server Running on: ws://
\(system.host)
:
\(system.port)
 =="
)
        
print
(
"========================================================"
)
        
        
try
 
await
 server.terminated 
// waits effectively forever (until we shut down the system)

    }
}
```

```swift
/// As we are playing for our `model.team` team, we try to find a player of the opposing team


let
 opponentTeam 
=
 model.team 
==
 .fish 
?
 
CharacterTeam
.rodents : 
CharacterTeam
.fish


/// The local network actor system provides a receptionist implementation that provides us an async sequence


/// of discovered actors (past and new)


let
 listing 
=
 
await
 localNetworkSystem.receptionist.listing(of: 
OpponentPlayer
.
self
, tag: opponentTeam.tag)

for
 
try
 
await
 opponent 
in
 listing 
where
 opponent.id 
!=
 
self
.player.id {
    log(
"matchmaking"
, 
"Found opponent: 
\(opponent)
"
)
    model.foundOpponent(opponent, myself: 
self
.player, informOpponent: 
true
)
    
// inside foundOpponent:

    
// if informOpponent {

    
//     Task {

    
//         try await opponent.startGameWith(opponent: myself, startTurn: false)

    
//     }

    
// }


    
return
 
// make sure to return here, we only need to discover a single opponent

}
```

```swift
public
 distributed 
actor
 
LocalNetworkPlayer
: 
GamePlayer
 {
    
public
 
typealias
 
ActorSystem
 
=
 
SampleLocalNetworkActorSystem


    
let
 team: 
CharacterTeam

    
let
 model: 
GameViewModel


    
var
 movesMade: 
Int
 
=
 
0


    
public
 
init
(
team
: 
CharacterTeam
, 
model
: 
GameViewModel
, 
actorSystem
: 
ActorSystem
) {
        
self
.team 
=
 team
        
self
.model 
=
 model
        
self
.actorSystem 
=
 actorSystem
    }

    
public
 distributed 
func
 
makeMove
() 
async
 -> 
GameMove
 {
        
let
 field 
=
 
await
 model.humanSelectedField()

        movesMade 
+=
 
1

        
let
 move 
=
 
GameMove
(
            playerID: 
self
.id,
            position: field,
            team: team,
            teamCharacterID: movesMade 
%
 
2
)

        
return
 move
    }

    
public
 distributed 
func
 
makeMove
(
at
 
position
: 
Int
) 
async
 -> 
GameMove
 {
        
let
 move 
=
 
GameMove
(
            playerID: id,
            position: position,
            team: team,
            teamCharacterID: movesMade 
%
 
2
)

        log(
"player"
, 
"Player makes move: 
\(move)
"
)
        
_
 
=
 
await
 model.userMadeMove(move: move)

        movesMade 
+=
 
1

        
return
 move
    }

    
public
 distributed 
func
 
opponentMoved
(
_
 
move
: 
GameMove
) 
async
 
throws
 {
        
do
 {
            
try
 
await
 model.markOpponentMove(move)
        } 
catch
 {
            log(
"player"
, 
"Opponent made illegal move! 
\(move)
"
)
        }
    }

    
public
 distributed 
func
 
startGameWith
(
opponent
: 
OpponentPlayer
, 
startTurn
: 
Bool
) 
async
 {
        log(
"local-network-player"
, 
"Start game with 
\(opponent.id)
, startTurn:
\(startTurn)
"
)
        
await
 model.foundOpponent(opponent, myself: 
self
, informOpponent: 
false
)

        
await
 model.waitForOpponentMove(shouldWaitForOpponentMove(myselfID: 
self
.id, opponentID: opponent.id))
    }
}
```


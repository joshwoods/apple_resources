# Wwdc2022 110354

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

What's new in SwiftJoin us for an update on Swift. We'll take you through performance improvements, explore more secure and extensible Swift packages, and share advancements in Swift concurrency. We'll also introduce you to Swift Regex, better generics, and other tools built into the language to help you write more flexible & expressive code.ResourcesCelebrating learning experiences from the 2021 Swift Mentorship ProgramContribute to SwiftDiversity in SwiftSwift Mentorship ProgramHD VideoSD VideoRelated VideosWWDC22Create Swift Package pluginsDemystify parallelization in Xcode buildsDesign protocol interfaces in SwiftEliminate data races using Swift ConcurrencyEmbrace Swift genericsExplore more content with MusicKitImprove app size and runtime performanceMeet distributed actors in SwiftMeet Swift Async AlgorithmsMeet Swift Package pluginsMeet Swift RegexSwift Regex: Beyond the basicsVisualize and optimize Swift concurrency

Join us for an update on Swift. We'll take you through performance improvements, explore more secure and extensible Swift packages, and share advancements in Swift concurrency. We'll also introduce you to Swift Regex, better generics, and other tools built into the language to help you write more flexible & expressive code.

Celebrating learning experiences from the 2021 Swift Mentorship Program

Contribute to Swift

Diversity in Swift

Swift Mentorship Program

HD VideoSD Video

HD Video

SD Video

Create Swift Package plugins

Demystify parallelization in Xcode builds

Design protocol interfaces in Swift

Eliminate data races using Swift Concurrency

Embrace Swift generics

Explore more content with MusicKit

Improve app size and runtime performance

Meet distributed actors in Swift

Meet Swift Async Algorithms

Meet Swift Package plugins

Meet Swift Regex

Swift Regex: Beyond the basics

Visualize and optimize Swift concurrency

Search this video…♪ Mellow instrumental hip-hop music ♪♪Hi, I'm Angela.And I'm Becca.Welcome to what's new in Swift!We're really excited to talk to you todayabout all of the great new features in Swift 5.7.Many of the things we'll talk about todaydemonstrate Swift's goal to make your life as a developer easier.We'll look at new toolingto help you customize your workflowand some amazing under-the-hood improvements.Then we'll talk about the latest in Swift's concurrency modeland the road to Swift 6, including full-thread safety.Then I'll finish up by taking you throughsome language improvements that make Swift easier to readand write, including cleaner, simpler generics,and powerful new string processing facilities.But first, let's start by talking aboutone of the things that makes Swift so special --all of you.Your input and contributions are what have enabled Swiftto expand so rapidly.Community involvement is at Swift's core.This year, more of the Swift project became availableto the community when docC --the documentation generation tool announced last year --and the Swift.org website were open sourced.Open source works bestwhen you have an active community shepherding it.We've been using the workgroup model for Swift on Serverand Diversity in Swift to provide stewardshipand support for community membersinterested in specific areas.This has been working really wellso we've started two new workgroups.One for iterating on the Swift websiteand making it more of a community resource,and another for C++ interoperability,to shape the design of the model between C++ and Swift.As we venture into new areas, we all need supportfrom members within the community.As a part of that, the Diversity in Swift workgroupintroduced the Swift Mentorship Program last year.The program provides pathwaysto contribute to all of the workgroup areasfor folks who don't know how to startor are looking to deepen their expertise in a particular area.Last year's program was a huge success.There were a lot of interested mentees;and with that, we were able to create 41 mentorship pairs.This success is why the program is being brought backfor year two.The program would love to include everyonewho's interested; but to do that, we need you --the excited and experienced developers listening nowwho are ready to share their breadth of knowledgeand make new connections.Because the mentorship program is not just about the codebut about building relationships within the community.And a little guidance can have a lasting effect.Don't just take my word for it.Last year, Amrit participated in the mentorship programand focused on compiler and language design.What started off as intrigue for Amrittransformed into tangible contributions.Diving into a new domain is not easy.Even so, she walked away finding successand feeling inspired to contribute more.Like many others,this experience opened a door for Amrit.In addition to compiler and language design,last year there were a wide range of available focus areas,from technical writing and testingto contributing to Swift packages.This year, we're adding even moreand there's always opportunities for new topics.If you don't see something in this list that interests you,you can still mention it in your application.Another addition is that this year's program will offermentorship year-round for starter bug contributionsto help accommodate anyone who may have a lower capacityto participate but is still excited to get involved.If you're interested in applying,or just eager to hear more,check out the most recent Swift blog post.There, you can find links to detailed reflectionsfrom the highlighted mentees.The mentorship program is just one initiativeunder Diversity in Swift umbrella.To learn more about the mentorship programand other Diversity in Swift efforts,you can visit Swift.org/diversity.To open the door even further, we want to make itas easy as possible to use Swift with the resources you have!We have streamlined the Swift toolchain distribution processfor the Linux platformby adding support for Linux package formats.With the new native toolchain installers,you can now download RPMs for Amazon Linux 2and CentOS 7 directly from Swift.org.These toolchains are experimental,so be sure to share feedback on the Swift.org forums.Swift is primarily used for building apps.However, the vision has always been for Swift to be scalable --used from everything from high-level scriptsdown to bare-metal environments.To encourage Swift to be usedwhere it's never been used before,Swift underwent some major changes this year.To make the standard library smallerfor standalone, statically linked binaries,we dropped the dependencyon an external Unicode support library,replacing it with a faster native implementation.Smaller, faster binaries are a huge benefitwhen running on event-driven server solutions.You get static linking on Linux by defaultto better support containerized deployments for the server.This size reduction makes Swift suitablefor even restricted environments,which allowed us to use itin Apple's Secure Enclave Processor.Swift is useful from apps to serversall the way down to restricted processors;tying it all together is the package ecosystem.This year's new features in Swift packageswill make your life better.To start, Swift Package Manager has introduced TOFU.No, not the delicious snack.TOFU is an acronym that stands for Trust On First Use.It's a new security protocol where the fingerprintof a package is now being recordedwhen the package is first downloaded.Subsequent downloads will validate this fingerprintand report an error if the fingerprints are different.This is just one example of how trust and securityare built into the core of the package ecosystemto help you feel confident using it.Command plug-ins are a great way to improve the workflowfor Swift developers.They are the first step in providing more extensibleand secure build tools.Command plug-ins can be used for documentation generation,source code reformatting and more.Instead of writing your automation in a shell scriptand having to maintain separate workflows, you can use Swift!Think open source formatters and linters.Now, all of those open source tools are available within Xcodeand Swift Package Manager.Command plug-ins are the glue between open source toolsand Swift Package Manager.The Swift project is embracing developer toolsin the open source community to provide seamless integrationwith your automated workflows.docC is great tool to integrate documentationinto your source code.This year, it got even better with Objective-C and C support.Let's take a look at what it would taketo create a plug-in with docC.Plug-ins are just simple Swift code.You can define a plug-in by creating a structthat conforms to the CommandPlugin protocol.And then you just add a function that tells your plug-inwhich tool you'd like to invoke.Within this function is where we want to call docC.Once you've defined your plug-in, it becomes availablethrough the Swift PM command line interfaceand Xcode as a menu entry.Now, we can tell Swift PM to generate documentationand it knows to pass this action to the docC executable.It doesn't stop there.There's a second plug-in known as build tool plug-ins.These plug-ins are packages that allow youto inject additional steps during the build.When you implement a build tool plug-in,that will create a command for the build systemto execute in a sandbox.They differ from command plug-inswhich you execute directly at any timeand can be granted explicit permissionto change files in your package.Build tool plug-ins can be used for source code generationor custom processing for special types of files.With build tool plug-ins, this would be the package layout.In this example, the plugin.Swiftis the Swift script that implementsthe package plug-in target.The plug-in is treated as a Swift executable.And you write the plug-in in the same wayyou write any Swift executable.You can implement your plug-in by defininga set of build commands that tells the build systemwhat executable command to run and what outputs are expectedas a result.Package plug-ins are secure solutionsthat provide extensibility in your packages.You can learn more about how plug-ins workand how to implement your own plug-in, in two sessions,"Meet Swift Package plugins"and "Create Swift Package plugins."As you expand your use of packages,you might have encountered module collisions.That's when two separate packagesdefine a module with the same name.To solve this situation,Swift 5.7 introduces module disambiguation.Module disambiguation is a feature that allows youto rename modules from outside the packages that define them.Here in our Stunning application,we're bringing in two packages that define a Logging module,so they clash.To fix this for our Stunning application,you'll just need to add the moduleAliases keywordto the dependencies section of your package manifest.That way you can use two different namesto distinguish between modulesthat previously had the same name.Swift 5.7 brings some fantastic performance improvements.Let's start by looking at build times.Last year, we told you about how we had rewrittenthe Swift Driver -- the program that coordinatesthe compilation of Swift source code in Swift.Last year's rearchitectureunlocked some really important changesthat speed up builds significantly.The driver can now be used as a frameworkdirectly inside the Xcode build systeminstead of as a separate executable.This allows it to coordinate builds more closelywith the build system to allow things like parallelization.If you're someone who loves the sound of quick builds,you can get more details in the"Demystify parallelization in Xcode builds" session.To show you how much faster builds are,let's look at some examples of how long it takes to buildsome of the tools we use often that are written in Swift.On a 10-core iMac, the improvements have rangedfrom 5 percent all the way up to 25 percent.Next, there are improvements to the speed of type checking.This year, we improved the type-checker performanceby reimplementing a key part of the generics system --the part that computes a function signaturefrom things like protocols and "where" clauses.In the old implementation, time and memory usagecould scale exponentially as more protocols were involved.For example, here, we have a complicated set of protocolsthat define a coordinate system, with a lotof generic requirements on the many associated types.Previously, this would take 17 seconds to type-check this code.But now, in Swift 5.7, this example is ableto type-check significantly quicker, in under a second.We also have some equally impressive runtime improvements.Before Swift 5.7, we've seen protocol checking on app startuptake as long as four seconds on iOS.Protocols needed to be computed every time we launched apps,resulting in launch times that got longerthe more protocols you added.Now, they're cached.Depending on how an app was writtenand how many protocols it used,this can mean launch times being cut in half in some appswhen running on iOS 16.The session "Improve app size and runtime performance"will dive deeper into how you can leveragethese improvements in your own application.Now, it's time for something I'm sure a lot of youhave been eager to hear about.Last year, we introduced the new concurrency model,bringing together actors and async/await.This had a transformative effect on the concurrency architectureof your applications.Async/await and actors are safer and easier than callbacksand manual queue management.This year, we further fleshed out the modelwith data race safety at the forefront.Because concurrency was such a fundamentaland important improvement to your app's codebase,we made it possible to back-deploy these changesall the way back to iOS 13 and macOS Catalina.In order to deploy to older operating systems,your app bundles a copy of the Swift 5.5 concurrency runtimefor older OSes.This is similar to back-deploying Swiftto operating systems before ABI stability.Next, we've taken this model in new directions.We've introduced language featuresand supporting packages.First, let's talk about data race avoidance.Before I jump into that,I should probably take a step backand say that one of the really important features of Swift,is memory safety by default.Swift users can't do things with unpredictable behavior,like reading a valuewhile you're in the middle of modifying it.In this example, we're removing all of the numbers in an arraythat match the same array's count.Initially, the array's count is 3,so we'll remove the 3 from the array.But once we've done that, the count will be 2.Do we remove the 3 and the 2 from the array,or just the 3?The answer is neither.Swift will prevent you from doing thisbecause it's not safe to access the array's countwhile you're in the middle of modifying it.Our goal is to do something similar for thread safety.We envision a languagethat eliminates low-level data races by default.In other words, we want to prevent concurrency bugsthat can cause unpredictable behavior.Here's another example.Using the same number's array, we create a background taskthat appends 0 to the array,and then we remove the array's last element.But wait, does removing the last elementhappen before or after we append 0?The answer, again, is neither.Swift will block you from doing this because it's not safeto modify the array from a background taskwithout synchronizing access with something like an actor.Actors were the first major step towards eliminating data races.This year we've refined the concurrency modelto push us even further towards the end goal.You can think of each actor as its own island,isolated from everything else in the sea of concurrency.But what happens when different threads want to querythe information stored by each of the isolated actors?This metaphor will be explored in depth in the session"Eliminate data races using Swift Concurrency."From memory safety to thread safety by default;that is the goal for Swift 6.To get us there, we first improved last year'sconcurrency model with the new language featuresI just mentioned.The second thing I haven't mentioned yetis the new opt-in safety checksthat identify potential data races.You can experiment with stricter concurrency checkingby enabling it in your build settings.Let's take a look at actors again.We can take this notion of actor isolation,and take it further with distributed actors.Distributed actors put those islands on different machineswith a network between them.This new language feature makes developing distributed systemsmuch simpler.Let's say you want to create a game app;you can now easily write the back end in Swift.Here, the distributed actor is like an actorbut it might be on a different machine.In this example, we're looking at computer playerthat will maintain state during a game with a user.The distributed keyword can also be added to a functionthat we expect will need to be calledon an actor that might be on a remote machine.Let's add another function called endOfRound.It will loop over the players and call makeMove on each one.Some of these players might be local or remote,but we have the benefitof not needing to care about which is which.The only difference from a regular actor callis that a distributed actor call can potentially failbecause of network errors.In the event of a network failure,the actor method would throw an error.So, you need to add the try keywordas well as the usual await keyword that's neededwhen you call a function outside of the actor.Building on these core language primitives,we also built an open source Distributed Actors packagethat is focused on building server-side,clustered distributed systems in Swift.The package includes an integrated networking layerusing SwiftNIO and implements the SWIM consensus protocolto manage state across the cluster.The "Meet distributed actors in Swift" sessionwill go into more details on how to builddistributed systems with these new features.We also launched a new set of open source algorithmsto provide easy out-of-the-box solutions to common operationswhen dealing with AsyncSequence,which was released with Swift 5.5.Releasing these APIs as a packagegives developers flexibility in deploying across platformsand operating system versions.There are several ways to combine multiple async sequencesand to group values into collections.These are just some of the algorithmsincluded in the package.Check out the "Meet Swift Async Algorithms" talkto see how you can use this new powerful API.But there's another aspect of concurrency,which is performance.This year, with actor prioritization,actors now execute the highest-priority work first.And continuing our deep integrationwith the operating system scheduler,the model has priority-inversion prevention built in,so less important work can't block higher-priority work.Historically, it has been really hard to visualizethe performance impact of concurrency in your app.But now, we have a great new tool for doing exactly that.The new Swift Concurrency view in Instrumentscan help you investigate performance issues.The Swift Tasks and Swift Actors instrumentsprovide a full suite of tools to help you visualizeand optimize your concurrency code.At the top level, the Swift Tasks Instrumentprovides useful statistics, including the number of tasksrunning simultaneously and the total tasksthat have been created up until that point in time.In the bottom half of this window,you can see what's referred to as a Task Forest.It provides a graphical representationof the parent-child relationshipsbetween tasks in structured concurrent code.This is just one of the detailed viewsfor the Swift Actor Instrument.To learn how to use this exciting new tool,you'll want to hop over to the talk"Visualize and optimize Swift concurrency."And don't forget to give those new packages a try.Don't be shy to let us know how it's going on the forums.Now, I'll hand it over to Becca to talk aboutthe many improvements to Swift language usability.Languages are tools, and there's a funny thingabout tools -- they can really affectthe things you build with them.When all you have is a hammer,you're going to build things with nails instead of screws.And even if you have a full set of tools,if your hammer has a big, grippy handlewhile your screwdriver is plasticky and hard to hold,you might still lean towards the nails.A language is the same way.If Swift has a good tool for expressing something,people will use it more often.And this year, Swift's tools for expressing what you wantyour code to do have improved in many ways.Some of these changes are simple conveniencesfor things you do often.For example, it's really common in Swift to use if letwith the same name on both sides of the equal sign.After all, there probably isn't a better namefor the unwrapped valuethan the name you gave the optional one.But when the name is really long,that repetition starts to get cumbersome.You might be tempted to abbreviate the name,but then your code becomes kind of cryptic.And if you later rename the optional variable,the abbreviation might get out of sync.Swift 5.7 introduces a new shorthandfor this common pattern.If you're unwrapping an optionaland want the unwrapped value to have the same name,just drop the right-hand side.Swift will assume it's the same.And of course, this also works with guard, too,and even while, for that matter.We also looked at places where a feature suddenly stops workingwhen you make a minor change.For instance, Swift has always been able to figure outwhat type a call will return based on the codewritten inside a one-statement closure.In this compactMap call, the closure returns the valueof parseLine, and the parseLine functionreturns a MailmapEntry, so Swift can figure outthat entries should be an array of MailmapEntry.This now works for more complicated closuresthat have multiple statements or control flow features.So you can use do-catch, or if...else,or just add a print call, without havingto manually specify the closure's result type.Another thing we looked at is danger flagsthat aren't really flagging any actual danger.Swift is very concerned with type and memory safety.To keep you from making mistakes,it never automatically convertsbetween pointers with different pointer types,nor between raw pointers and typed pointers.This is very different from C,which allows certain conversions.For example, you can change the signed-ness of the pointee,or cast any pointer to char star to access it as bytes,without violating any of C's pointer rules.But sometimes these differences in pointer behaviorwill cause problems when a C API is imported into Swift.The original developer may have designed their APIswith slight mismatches that are handledby automatic conversions in C but are errors in Swift.In Swift, accessing a pointer of one typeas though it were a different type is very dangerous,so you have to describe what you're doing very explicitly.But that's all pointless if we're passing the pointerdirectly to C, because in C,that pointer mismatch is perfectly legal!So in this case, we've treated something really straightforwardas though it were dangerous.This matters because, as much as Swift values type safety,it also values easy access to C-family code.That's why C and Objective-C interopare so rich and seamless, and it's why the Swift projectformed the C++ working group Angela mentioned earlierto start building equally capable C++ interop.We don't want using C functions like theseto be unnecessarily painful.So Swift now has a separate set of rulesfor calls to imported functions and methods.It allows pointer conversions that would be legal in Ceven though they normally aren't in Swift.That way, your Swift code can use these APIs seamlessly.So far we've talked about small improvementsto the tools you already had.But this year, Swift also has a brand-new toolfor extracting information from strings.Here's a function that parses some informationout of a string.This sort of task has always beena bit of a challenge in Swift.You end up searching, splitting, and slicing over and overuntil you get what you want.When people notice this, they tend to focuson the little things, like how wordy it can beto manipulate string indices,but I think that's kind of missing the bigger picture.Because even if we changed this syntax,it doesn't help you answer the basic question you're askingwhen you look at this code -- what does the line variablethat's passed into it actually look like?What sort of string is it trying to take apart?If you stare at it long enough, you might realizethat it's parsing a simplified version of a mailmap --a file you put in a git repositoryto correct a developer's name in old commits.But extracting that information by searching and slicingis so involved that it's hard to figure that out.You get so lost in how to slice up the stringthat you kind of lose track of what that string is.The problem is not these two expressions;the problem is the whole thing.We need to rip out all of thisand replace it with something better.We need a different approach;one where your code sort of draws a pictureof the string you want to match,and the language figures out how to do it.A declarative approach, not an imperative one.In Swift 5.7, you can now do that by writing a regex.A regex is a way to describe a pattern in a string.For over 50 years, languages and toolshave allowed developers to write regexesin a dense, information-packed syntax.Some of you already use them in the Xcode find bar,in command-line tools like grep,in Foundation's NSRegularExpression class,or in other programming languages.That syntax is now supported by Swift's regex literals,and it works just like it does in any other developer tool.But some of you haven't used regexes beforeand you're probably going, "Is that real codeor did a cat walk across her keyboard?"And I don't blame you.Regex literals are written in symbols and mnemonicsthat you have to memorize in order to read them.To someone who knows the language,even the gnarliest parts of this regex,like the part that matches the developer's nameare just combinations of several simple matching rules.But that's a lot of behavior to cram into 11 characters.Regex literals are so compact that even experienced developerssometimes need a minute to understand a complicated one.But what if you could write the same kind of matching rules,just with words instead of symbols?That seems like it'd be easier to understand.In fact, put it all together,and you get something that looks a lot like SwiftUI.That'd be a great alternative to a regex literal, wouldn't it?So it's a good thing Swift supports that!The RegexBuilder library provides a whole newSwiftUI-style language for regexes that's easier to useand more readable than the traditional syntax.It can do the same things a regex literal can,but it describes its behavior in words you can understandor look up, instead of symbols and abbreviationsyou have to memorize.Regex builders are great for beginners,but this is far from a beginner-only feature.It has powerful capabilities that go way beyondwhat a regex literal can do.To start with, you can turn a regexinto a reusable regex component,just as you can turn a SwiftUI view hierarchyinto a view.You can use these components from other regexescreated with the builder syntax,and you can even make them recursive.Regex builders also support dropping some Swift typesdirectly into a regex.For example, string literals just matchthe exact text inside them -- no special escaping needed.You can also use regex literalsin the middle of a regex builder.So you can strike a balance between the clarityof a regex builder and the conciseness of a regex literal.And other types -- like this Foundation date-format style --can integrate custom parsing logic with regex builders,and even convert the data to a richer type before capturing it.Finally, no matter which syntax you use,regexes support a bunch of useful matching methodsand strongly typed captures that are easy to use.Now, for the regex nerds who have been squirmingin their seats,Swift Regex uses a brand-new open source matching engine,with a feature set comparableto the most advanced regex implementations.The literal syntax is compatible with the Unicode regex standard,and it has an uncommon level of Unicode correctness.For instance, dot matches a whole character by default,not a Unicode.Scalar or a UTF-8 byte.To use Swift Regex, your app will need to be runningon an OS with the Swift Regex engine built into it,like macOS 13 or iOS 16.Swift Regex is an entire language --well, two languages, really --so there's much more to say about it.These two sessions -- "Meet Swift Regex"and "Swift Regex: Beyond The Basics" --will give you lots more details about using it.Finally, there's one placewhere we took a comprehensive look at the tools we haveand made a bunch of changes to improve them.That's in generics and protocols.To show you how these tools have improved,I'll need an example protocol.Let's say you're writing a git clientand you have to represent mailmaps in two different ways.When you're displaying commits, you use a type with a dictionaryto quickly look up names.But when you're letting users edit the mailmap,you use a type with an array to keep the entriesin their original order.And you have a protocol called Mailmapthat both of them conform to,so your mailmap parser can add entries to either type.But there are two ways the parser could usethe Mailmap protocol.I've written two different versionsof this addEntries function to illustrate them,but it's actually kind of hard to explainhow they're different,because Swift is using the same syntax for two different things.It turns out that the word "Mailmap" means one thing herebut it means something subtly different here.When you name a protocol in an inheritance list,generic parameter list, generic conformance constraint,or an opaque result type,it means "an instance that conforms to this protocol."But in a variable type, a generic argument,a generic same-type constraint,or a function parameter or result type,it actually means "a box which containsan instance that conforms to this protocol."This distinction is important because the boxtypically uses more space, takes more time to operate on,and doesn't have all of the capabilitiesof the instance inside it.But the places where you're using a boxlook just like the places where you aren't,so it's hard to figure out if you're using one.Swift 5.7 fixes this oversight.When you're using one of these boxescontaining a conforming type,Swift will now expect you to write the any keyword.This is not mandatory in code that was valid before Swift 5.7,but it is encouraged and you will see itin generated interfaces and error messages,even if you don't write it out explicitly.So the preferred way to write all of those thingsin the right-hand column is with the any keyword.If you do that, you'll be able to tellwhen you're using one of these boxes.Now that the any keyword marks one of the parametersin this example, it's a lot easier to explainthe difference between these two functions.addEntries1 takes the Mailmap as a generic type;addEntries2 takes it as an any type.And it's also easier for error messagesto explain what's happeningwhen you hit one of the limitations of any types.For instance, this mergeMailmaps function tries to passan any Mailmap to a generic Mailmap parameter.This used to produce an errorsaying that Mailmap cannot conform to itself,which always seemed kind of paradoxical.But now that we have the concept of any types,we can explain what's happening more clearly.The problem is that any Mailmap --the box containing a mailmap --doesn't conform to the Mailmap protocol.But the box is what you're trying to pass,and it doesn't fit into the generic parameter.If you want to pass the instance inside the box here,you'd have to somehow open up the box,take out the mailmap inside it, and pass that instead.But actually, in simple cases like this one,Swift will now just do that for you.Open up the box, take out the instance inside it,and pass it to the generic parameter.So you won't be seeing this error messagenearly as much anymore.But there's an even more exciting improvementto any types than that one.Previously, a protocol could not be used as an any typeif it either used the self type or had associated types,or even just conformed to a protocol that did,like Equatable.But in Swift 5.7, this error is just --poof --gone.A lot of developers have struggled with this one,so we're thrilled to have fixed it at the source.Now, that's exciting enough just for protocols like Mailmap,but this goes even further.Because even very sophisticated protocols, like Collection,can be used as any types.You can even specify the element type,thanks to a new feature called "primary associated types."A lot of associated typesare basically just implementation details.You usually don't care which type a collection usesfor its index, iterator, or subsequence;you just need to use the type it supports.But its Element is a different story.You might not always care exactly which Element typea collection uses, but you're probablygoing to do something with the elements,so you'll need to constrain them or return them or something.When you have an associated type like Elementthat nearly every user of a protocol will care about,you can put its name after the protocol's namein angle brackets to make it a primary associated type.Once you do that, you can constrain the protocol'sprimary associated types with the angle bracket syntaxpretty much anywhere you can write the protocol's name,including in any Collection.Now, some of you might be looking at this type and going,"Wait a minute.Isn't there already something called AnyCollection,just run together and with the 'any' capitalized?"And you're right, there is!The old AnyCollection is a type-erasing wrapper --a handwritten struct which serves the same purposeas an any type.The difference is that the AnyCollection structis just line after line of the most boring boilerplate codeyou've ever seen in your life; whereas the any typeis a built-in language featurethat does basically the same thing --for free!Now, the AnyCollection struct will stick aroundfor backwards compatibility and because it hasa couple of features that any types can't quite match yet.But if you have your own type-erasing wrappersin your code, you might want to see if you can reimplement themusing built-in any types instead of box classes or closures.Or maybe even just replace them with type aliases.So Swift has dramatically improved any types.It's introduced the any keywordso you can see where you're using them.It allows you to pass them to generic arguments.It's abolished the restriction that kept many protocolsfrom being used with them.And it even lets you constrainan any type's primary associated types.But even with all of those improvements,any types still have limitations.For example, even though you can now use any Mailmapswhen Mailmap conforms to Equatable,you still can't use the equals operator with them,because the equals operator requires both mailmapsto have the same concrete type, but that's not guaranteedwhen you're using two any Mailmaps.So even though Swift has improved any types a lot,they still have important limitations,in both capabilities and performance.And that's why a lot of the time, you shouldn't use them --you should use generics instead.So let's go back to the two versions of addEntriesand apply that wisdom.Both versions do exactly the same thing,but the one on the top uses generic types,and the one on the bottom uses any types.The generic version will likely be more efficientand more capable, so you ought to use that one.And yet, you're probably tempted to use any types,because they're just so much easier to read and write.To write the generic version,you need to declare two generic type names,constrain them both, and finally,use those generic type names as the types of the parameters.That's just exhausting compared to writing "any Collection"and "any Mailmap."So you'd be tempted to use any types despite their drawbacks.But that's the same thing I was talking about earlier --using your hammer instead of your screwdriverbecause the hammer has a big, grippy handle.You shouldn't have to make that choice.So Swift is making generics just as easy to useas any types.If a generic parameter is only used in one place,you can now write it with the some keyword as a shorthand.And it even supports primary associated types,so you can accept all collections of mailmap entrieswith code that's a lot easier to understand.With that in your toolbox,there's no reason to avoid generics anymore.If you have a choice between generics and any types,generics will be just as easy to use --just write "some" instead of "any".So you might as well use the best tool for the job.I've only scratched the surface of these changesto protocols and generics.For an in-depth look, as well as a great reviewof all of Swift's generics features,we have two more talks for you this year:"Embrace Swift generics,"and "Design protocol interfaces in Swift."Now, Angela and I have talked aboutnearly two dozen changes to Swift,but there are lots more that we couldn't fit into this session.Every one of these changes was pitched, proposed, reviewed,and accepted publicly in the Evolution boardon the Swift Forums.And all of them were shaped and realized with the helpof community members from outside Apple.If you're one of those people, thank you for making Swift 5.7the great release it is.And if you want to help decide what comes next,visit Swift.org/contributing to find out how to participate.Thanks for your time.And happy coding.♪

♪ Mellow instrumental hip-hop music ♪♪Hi, I'm Angela.And I'm Becca.Welcome to what's new in Swift!We're really excited to talk to you todayabout all of the great new features in Swift 5.7.Many of the things we'll talk about todaydemonstrate Swift's goal to make your life as a developer easier.We'll look at new toolingto help you customize your workflowand some amazing under-the-hood improvements.Then we'll talk about the latest in Swift's concurrency modeland the road to Swift 6, including full-thread safety.Then I'll finish up by taking you throughsome language improvements that make Swift easier to readand write, including cleaner, simpler generics,and powerful new string processing facilities.But first, let's start by talking aboutone of the things that makes Swift so special --all of you.Your input and contributions are what have enabled Swiftto expand so rapidly.Community involvement is at Swift's core.This year, more of the Swift project became availableto the community when docC --the documentation generation tool announced last year --and the Swift.org website were open sourced.Open source works bestwhen you have an active community shepherding it.We've been using the workgroup model for Swift on Serverand Diversity in Swift to provide stewardshipand support for community membersinterested in specific areas.This has been working really wellso we've started two new workgroups.One for iterating on the Swift websiteand making it more of a community resource,and another for C++ interoperability,to shape the design of the model between C++ and Swift.As we venture into new areas, we all need supportfrom members within the community.As a part of that, the Diversity in Swift workgroupintroduced the Swift Mentorship Program last year.The program provides pathwaysto contribute to all of the workgroup areasfor folks who don't know how to startor are looking to deepen their expertise in a particular area.Last year's program was a huge success.There were a lot of interested mentees;and with that, we were able to create 41 mentorship pairs.This success is why the program is being brought backfor year two.The program would love to include everyonewho's interested; but to do that, we need you --the excited and experienced developers listening nowwho are ready to share their breadth of knowledgeand make new connections.Because the mentorship program is not just about the codebut about building relationships within the community.And a little guidance can have a lasting effect.Don't just take my word for it.Last year, Amrit participated in the mentorship programand focused on compiler and language design.What started off as intrigue for Amrittransformed into tangible contributions.Diving into a new domain is not easy.Even so, she walked away finding successand feeling inspired to contribute more.Like many others,this experience opened a door for Amrit.In addition to compiler and language design,last year there were a wide range of available focus areas,from technical writing and testingto contributing to Swift packages.This year, we're adding even moreand there's always opportunities for new topics.If you don't see something in this list that interests you,you can still mention it in your application.Another addition is that this year's program will offermentorship year-round for starter bug contributionsto help accommodate anyone who may have a lower capacityto participate but is still excited to get involved.If you're interested in applying,or just eager to hear more,check out the most recent Swift blog post.There, you can find links to detailed reflectionsfrom the highlighted mentees.The mentorship program is just one initiativeunder Diversity in Swift umbrella.To learn more about the mentorship programand other Diversity in Swift efforts,you can visit Swift.org/diversity.To open the door even further, we want to make itas easy as possible to use Swift with the resources you have!We have streamlined the Swift toolchain distribution processfor the Linux platformby adding support for Linux package formats.With the new native toolchain installers,you can now download RPMs for Amazon Linux 2and CentOS 7 directly from Swift.org.These toolchains are experimental,so be sure to share feedback on the Swift.org forums.Swift is primarily used for building apps.However, the vision has always been for Swift to be scalable --used from everything from high-level scriptsdown to bare-metal environments.To encourage Swift to be usedwhere it's never been used before,Swift underwent some major changes this year.To make the standard library smallerfor standalone, statically linked binaries,we dropped the dependencyon an external Unicode support library,replacing it with a faster native implementation.Smaller, faster binaries are a huge benefitwhen running on event-driven server solutions.You get static linking on Linux by defaultto better support containerized deployments for the server.This size reduction makes Swift suitablefor even restricted environments,which allowed us to use itin Apple's Secure Enclave Processor.Swift is useful from apps to serversall the way down to restricted processors;tying it all together is the package ecosystem.This year's new features in Swift packageswill make your life better.To start, Swift Package Manager has introduced TOFU.No, not the delicious snack.TOFU is an acronym that stands for Trust On First Use.It's a new security protocol where the fingerprintof a package is now being recordedwhen the package is first downloaded.Subsequent downloads will validate this fingerprintand report an error if the fingerprints are different.This is just one example of how trust and securityare built into the core of the package ecosystemto help you feel confident using it.Command plug-ins are a great way to improve the workflowfor Swift developers.They are the first step in providing more extensibleand secure build tools.Command plug-ins can be used for documentation generation,source code reformatting and more.Instead of writing your automation in a shell scriptand having to maintain separate workflows, you can use Swift!Think open source formatters and linters.Now, all of those open source tools are available within Xcodeand Swift Package Manager.Command plug-ins are the glue between open source toolsand Swift Package Manager.The Swift project is embracing developer toolsin the open source community to provide seamless integrationwith your automated workflows.docC is great tool to integrate documentationinto your source code.This year, it got even better with Objective-C and C support.Let's take a look at what it would taketo create a plug-in with docC.Plug-ins are just simple Swift code.You can define a plug-in by creating a structthat conforms to the CommandPlugin protocol.And then you just add a function that tells your plug-inwhich tool you'd like to invoke.Within this function is where we want to call docC.Once you've defined your plug-in, it becomes availablethrough the Swift PM command line interfaceand Xcode as a menu entry.Now, we can tell Swift PM to generate documentationand it knows to pass this action to the docC executable.It doesn't stop there.There's a second plug-in known as build tool plug-ins.These plug-ins are packages that allow youto inject additional steps during the build.When you implement a build tool plug-in,that will create a command for the build systemto execute in a sandbox.They differ from command plug-inswhich you execute directly at any timeand can be granted explicit permissionto change files in your package.Build tool plug-ins can be used for source code generationor custom processing for special types of files.With build tool plug-ins, this would be the package layout.In this example, the plugin.Swiftis the Swift script that implementsthe package plug-in target.The plug-in is treated as a Swift executable.And you write the plug-in in the same wayyou write any Swift executable.You can implement your plug-in by defininga set of build commands that tells the build systemwhat executable command to run and what outputs are expectedas a result.Package plug-ins are secure solutionsthat provide extensibility in your packages.You can learn more about how plug-ins workand how to implement your own plug-in, in two sessions,"Meet Swift Package plugins"and "Create Swift Package plugins."As you expand your use of packages,you might have encountered module collisions.That's when two separate packagesdefine a module with the same name.To solve this situation,Swift 5.7 introduces module disambiguation.Module disambiguation is a feature that allows youto rename modules from outside the packages that define them.Here in our Stunning application,we're bringing in two packages that define a Logging module,so they clash.To fix this for our Stunning application,you'll just need to add the moduleAliases keywordto the dependencies section of your package manifest.That way you can use two different namesto distinguish between modulesthat previously had the same name.Swift 5.7 brings some fantastic performance improvements.Let's start by looking at build times.Last year, we told you about how we had rewrittenthe Swift Driver -- the program that coordinatesthe compilation of Swift source code in Swift.Last year's rearchitectureunlocked some really important changesthat speed up builds significantly.The driver can now be used as a frameworkdirectly inside the Xcode build systeminstead of as a separate executable.This allows it to coordinate builds more closelywith the build system to allow things like parallelization.If you're someone who loves the sound of quick builds,you can get more details in the"Demystify parallelization in Xcode builds" session.To show you how much faster builds are,let's look at some examples of how long it takes to buildsome of the tools we use often that are written in Swift.On a 10-core iMac, the improvements have rangedfrom 5 percent all the way up to 25 percent.Next, there are improvements to the speed of type checking.This year, we improved the type-checker performanceby reimplementing a key part of the generics system --the part that computes a function signaturefrom things like protocols and "where" clauses.In the old implementation, time and memory usagecould scale exponentially as more protocols were involved.For example, here, we have a complicated set of protocolsthat define a coordinate system, with a lotof generic requirements on the many associated types.Previously, this would take 17 seconds to type-check this code.But now, in Swift 5.7, this example is ableto type-check significantly quicker, in under a second.We also have some equally impressive runtime improvements.Before Swift 5.7, we've seen protocol checking on app startuptake as long as four seconds on iOS.Protocols needed to be computed every time we launched apps,resulting in launch times that got longerthe more protocols you added.Now, they're cached.Depending on how an app was writtenand how many protocols it used,this can mean launch times being cut in half in some appswhen running on iOS 16.The session "Improve app size and runtime performance"will dive deeper into how you can leveragethese improvements in your own application.Now, it's time for something I'm sure a lot of youhave been eager to hear about.Last year, we introduced the new concurrency model,bringing together actors and async/await.This had a transformative effect on the concurrency architectureof your applications.Async/await and actors are safer and easier than callbacksand manual queue management.This year, we further fleshed out the modelwith data race safety at the forefront.Because concurrency was such a fundamentaland important improvement to your app's codebase,we made it possible to back-deploy these changesall the way back to iOS 13 and macOS Catalina.In order to deploy to older operating systems,your app bundles a copy of the Swift 5.5 concurrency runtimefor older OSes.This is similar to back-deploying Swiftto operating systems before ABI stability.Next, we've taken this model in new directions.We've introduced language featuresand supporting packages.First, let's talk about data race avoidance.Before I jump into that,I should probably take a step backand say that one of the really important features of Swift,is memory safety by default.Swift users can't do things with unpredictable behavior,like reading a valuewhile you're in the middle of modifying it.In this example, we're removing all of the numbers in an arraythat match the same array's count.Initially, the array's count is 3,so we'll remove the 3 from the array.But once we've done that, the count will be 2.Do we remove the 3 and the 2 from the array,or just the 3?The answer is neither.Swift will prevent you from doing thisbecause it's not safe to access the array's countwhile you're in the middle of modifying it.Our goal is to do something similar for thread safety.We envision a languagethat eliminates low-level data races by default.In other words, we want to prevent concurrency bugsthat can cause unpredictable behavior.Here's another example.Using the same number's array, we create a background taskthat appends 0 to the array,and then we remove the array's last element.But wait, does removing the last elementhappen before or after we append 0?The answer, again, is neither.Swift will block you from doing this because it's not safeto modify the array from a background taskwithout synchronizing access with something like an actor.Actors were the first major step towards eliminating data races.This year we've refined the concurrency modelto push us even further towards the end goal.You can think of each actor as its own island,isolated from everything else in the sea of concurrency.But what happens when different threads want to querythe information stored by each of the isolated actors?This metaphor will be explored in depth in the session"Eliminate data races using Swift Concurrency."From memory safety to thread safety by default;that is the goal for Swift 6.To get us there, we first improved last year'sconcurrency model with the new language featuresI just mentioned.The second thing I haven't mentioned yetis the new opt-in safety checksthat identify potential data races.You can experiment with stricter concurrency checkingby enabling it in your build settings.Let's take a look at actors again.We can take this notion of actor isolation,and take it further with distributed actors.Distributed actors put those islands on different machineswith a network between them.This new language feature makes developing distributed systemsmuch simpler.Let's say you want to create a game app;you can now easily write the back end in Swift.Here, the distributed actor is like an actorbut it might be on a different machine.In this example, we're looking at computer playerthat will maintain state during a game with a user.The distributed keyword can also be added to a functionthat we expect will need to be calledon an actor that might be on a remote machine.Let's add another function called endOfRound.It will loop over the players and call makeMove on each one.Some of these players might be local or remote,but we have the benefitof not needing to care about which is which.The only difference from a regular actor callis that a distributed actor call can potentially failbecause of network errors.In the event of a network failure,the actor method would throw an error.So, you need to add the try keywordas well as the usual await keyword that's neededwhen you call a function outside of the actor.Building on these core language primitives,we also built an open source Distributed Actors packagethat is focused on building server-side,clustered distributed systems in Swift.The package includes an integrated networking layerusing SwiftNIO and implements the SWIM consensus protocolto manage state across the cluster.The "Meet distributed actors in Swift" sessionwill go into more details on how to builddistributed systems with these new features.We also launched a new set of open source algorithmsto provide easy out-of-the-box solutions to common operationswhen dealing with AsyncSequence,which was released with Swift 5.5.Releasing these APIs as a packagegives developers flexibility in deploying across platformsand operating system versions.There are several ways to combine multiple async sequencesand to group values into collections.These are just some of the algorithmsincluded in the package.Check out the "Meet Swift Async Algorithms" talkto see how you can use this new powerful API.But there's another aspect of concurrency,which is performance.This year, with actor prioritization,actors now execute the highest-priority work first.And continuing our deep integrationwith the operating system scheduler,the model has priority-inversion prevention built in,so less important work can't block higher-priority work.Historically, it has been really hard to visualizethe performance impact of concurrency in your app.But now, we have a great new tool for doing exactly that.The new Swift Concurrency view in Instrumentscan help you investigate performance issues.The Swift Tasks and Swift Actors instrumentsprovide a full suite of tools to help you visualizeand optimize your concurrency code.At the top level, the Swift Tasks Instrumentprovides useful statistics, including the number of tasksrunning simultaneously and the total tasksthat have been created up until that point in time.In the bottom half of this window,you can see what's referred to as a Task Forest.It provides a graphical representationof the parent-child relationshipsbetween tasks in structured concurrent code.This is just one of the detailed viewsfor the Swift Actor Instrument.To learn how to use this exciting new tool,you'll want to hop over to the talk"Visualize and optimize Swift concurrency."And don't forget to give those new packages a try.Don't be shy to let us know how it's going on the forums.Now, I'll hand it over to Becca to talk aboutthe many improvements to Swift language usability.Languages are tools, and there's a funny thingabout tools -- they can really affectthe things you build with them.When all you have is a hammer,you're going to build things with nails instead of screws.And even if you have a full set of tools,if your hammer has a big, grippy handlewhile your screwdriver is plasticky and hard to hold,you might still lean towards the nails.A language is the same way.If Swift has a good tool for expressing something,people will use it more often.And this year, Swift's tools for expressing what you wantyour code to do have improved in many ways.Some of these changes are simple conveniencesfor things you do often.For example, it's really common in Swift to use if letwith the same name on both sides of the equal sign.After all, there probably isn't a better namefor the unwrapped valuethan the name you gave the optional one.But when the name is really long,that repetition starts to get cumbersome.You might be tempted to abbreviate the name,but then your code becomes kind of cryptic.And if you later rename the optional variable,the abbreviation might get out of sync.Swift 5.7 introduces a new shorthandfor this common pattern.If you're unwrapping an optionaland want the unwrapped value to have the same name,just drop the right-hand side.Swift will assume it's the same.And of course, this also works with guard, too,and even while, for that matter.We also looked at places where a feature suddenly stops workingwhen you make a minor change.For instance, Swift has always been able to figure outwhat type a call will return based on the codewritten inside a one-statement closure.In this compactMap call, the closure returns the valueof parseLine, and the parseLine functionreturns a MailmapEntry, so Swift can figure outthat entries should be an array of MailmapEntry.This now works for more complicated closuresthat have multiple statements or control flow features.So you can use do-catch, or if...else,or just add a print call, without havingto manually specify the closure's result type.Another thing we looked at is danger flagsthat aren't really flagging any actual danger.Swift is very concerned with type and memory safety.To keep you from making mistakes,it never automatically convertsbetween pointers with different pointer types,nor between raw pointers and typed pointers.This is very different from C,which allows certain conversions.For example, you can change the signed-ness of the pointee,or cast any pointer to char star to access it as bytes,without violating any of C's pointer rules.But sometimes these differences in pointer behaviorwill cause problems when a C API is imported into Swift.The original developer may have designed their APIswith slight mismatches that are handledby automatic conversions in C but are errors in Swift.In Swift, accessing a pointer of one typeas though it were a different type is very dangerous,so you have to describe what you're doing very explicitly.But that's all pointless if we're passing the pointerdirectly to C, because in C,that pointer mismatch is perfectly legal!So in this case, we've treated something really straightforwardas though it were dangerous.This matters because, as much as Swift values type safety,it also values easy access to C-family code.That's why C and Objective-C interopare so rich and seamless, and it's why the Swift projectformed the C++ working group Angela mentioned earlierto start building equally capable C++ interop.We don't want using C functions like theseto be unnecessarily painful.So Swift now has a separate set of rulesfor calls to imported functions and methods.It allows pointer conversions that would be legal in Ceven though they normally aren't in Swift.That way, your Swift code can use these APIs seamlessly.So far we've talked about small improvementsto the tools you already had.But this year, Swift also has a brand-new toolfor extracting information from strings.Here's a function that parses some informationout of a string.This sort of task has always beena bit of a challenge in Swift.You end up searching, splitting, and slicing over and overuntil you get what you want.When people notice this, they tend to focuson the little things, like how wordy it can beto manipulate string indices,but I think that's kind of missing the bigger picture.Because even if we changed this syntax,it doesn't help you answer the basic question you're askingwhen you look at this code -- what does the line variablethat's passed into it actually look like?What sort of string is it trying to take apart?If you stare at it long enough, you might realizethat it's parsing a simplified version of a mailmap --a file you put in a git repositoryto correct a developer's name in old commits.But extracting that information by searching and slicingis so involved that it's hard to figure that out.You get so lost in how to slice up the stringthat you kind of lose track of what that string is.The problem is not these two expressions;the problem is the whole thing.We need to rip out all of thisand replace it with something better.We need a different approach;one where your code sort of draws a pictureof the string you want to match,and the language figures out how to do it.A declarative approach, not an imperative one.In Swift 5.7, you can now do that by writing a regex.A regex is a way to describe a pattern in a string.For over 50 years, languages and toolshave allowed developers to write regexesin a dense, information-packed syntax.Some of you already use them in the Xcode find bar,in command-line tools like grep,in Foundation's NSRegularExpression class,or in other programming languages.That syntax is now supported by Swift's regex literals,and it works just like it does in any other developer tool.But some of you haven't used regexes beforeand you're probably going, "Is that real codeor did a cat walk across her keyboard?"And I don't blame you.Regex literals are written in symbols and mnemonicsthat you have to memorize in order to read them.To someone who knows the language,even the gnarliest parts of this regex,like the part that matches the developer's nameare just combinations of several simple matching rules.But that's a lot of behavior to cram into 11 characters.Regex literals are so compact that even experienced developerssometimes need a minute to understand a complicated one.But what if you could write the same kind of matching rules,just with words instead of symbols?That seems like it'd be easier to understand.In fact, put it all together,and you get something that looks a lot like SwiftUI.That'd be a great alternative to a regex literal, wouldn't it?So it's a good thing Swift supports that!The RegexBuilder library provides a whole newSwiftUI-style language for regexes that's easier to useand more readable than the traditional syntax.It can do the same things a regex literal can,but it describes its behavior in words you can understandor look up, instead of symbols and abbreviationsyou have to memorize.Regex builders are great for beginners,but this is far from a beginner-only feature.It has powerful capabilities that go way beyondwhat a regex literal can do.To start with, you can turn a regexinto a reusable regex component,just as you can turn a SwiftUI view hierarchyinto a view.You can use these components from other regexescreated with the builder syntax,and you can even make them recursive.Regex builders also support dropping some Swift typesdirectly into a regex.For example, string literals just matchthe exact text inside them -- no special escaping needed.You can also use regex literalsin the middle of a regex builder.So you can strike a balance between the clarityof a regex builder and the conciseness of a regex literal.And other types -- like this Foundation date-format style --can integrate custom parsing logic with regex builders,and even convert the data to a richer type before capturing it.Finally, no matter which syntax you use,regexes support a bunch of useful matching methodsand strongly typed captures that are easy to use.Now, for the regex nerds who have been squirmingin their seats,Swift Regex uses a brand-new open source matching engine,with a feature set comparableto the most advanced regex implementations.The literal syntax is compatible with the Unicode regex standard,and it has an uncommon level of Unicode correctness.For instance, dot matches a whole character by default,not a Unicode.Scalar or a UTF-8 byte.To use Swift Regex, your app will need to be runningon an OS with the Swift Regex engine built into it,like macOS 13 or iOS 16.Swift Regex is an entire language --well, two languages, really --so there's much more to say about it.These two sessions -- "Meet Swift Regex"and "Swift Regex: Beyond The Basics" --will give you lots more details about using it.Finally, there's one placewhere we took a comprehensive look at the tools we haveand made a bunch of changes to improve them.That's in generics and protocols.To show you how these tools have improved,I'll need an example protocol.Let's say you're writing a git clientand you have to represent mailmaps in two different ways.When you're displaying commits, you use a type with a dictionaryto quickly look up names.But when you're letting users edit the mailmap,you use a type with an array to keep the entriesin their original order.And you have a protocol called Mailmapthat both of them conform to,so your mailmap parser can add entries to either type.But there are two ways the parser could usethe Mailmap protocol.I've written two different versionsof this addEntries function to illustrate them,but it's actually kind of hard to explainhow they're different,because Swift is using the same syntax for two different things.It turns out that the word "Mailmap" means one thing herebut it means something subtly different here.

When you name a protocol in an inheritance list,generic parameter list, generic conformance constraint,or an opaque result type,it means "an instance that conforms to this protocol."But in a variable type, a generic argument,a generic same-type constraint,or a function parameter or result type,it actually means "a box which containsan instance that conforms to this protocol."This distinction is important because the boxtypically uses more space, takes more time to operate on,and doesn't have all of the capabilitiesof the instance inside it.But the places where you're using a boxlook just like the places where you aren't,so it's hard to figure out if you're using one.Swift 5.7 fixes this oversight.When you're using one of these boxescontaining a conforming type,Swift will now expect you to write the any keyword.This is not mandatory in code that was valid before Swift 5.7,but it is encouraged and you will see itin generated interfaces and error messages,even if you don't write it out explicitly.So the preferred way to write all of those thingsin the right-hand column is with the any keyword.If you do that, you'll be able to tellwhen you're using one of these boxes.Now that the any keyword marks one of the parametersin this example, it's a lot easier to explainthe difference between these two functions.addEntries1 takes the Mailmap as a generic type;addEntries2 takes it as an any type.And it's also easier for error messagesto explain what's happeningwhen you hit one of the limitations of any types.For instance, this mergeMailmaps function tries to passan any Mailmap to a generic Mailmap parameter.This used to produce an errorsaying that Mailmap cannot conform to itself,which always seemed kind of paradoxical.But now that we have the concept of any types,we can explain what's happening more clearly.The problem is that any Mailmap --the box containing a mailmap --doesn't conform to the Mailmap protocol.But the box is what you're trying to pass,and it doesn't fit into the generic parameter.If you want to pass the instance inside the box here,you'd have to somehow open up the box,take out the mailmap inside it, and pass that instead.But actually, in simple cases like this one,Swift will now just do that for you.Open up the box, take out the instance inside it,and pass it to the generic parameter.So you won't be seeing this error messagenearly as much anymore.But there's an even more exciting improvementto any types than that one.Previously, a protocol could not be used as an any typeif it either used the self type or had associated types,or even just conformed to a protocol that did,like Equatable.But in Swift 5.7, this error is just --poof --gone.A lot of developers have struggled with this one,so we're thrilled to have fixed it at the source.Now, that's exciting enough just for protocols like Mailmap,but this goes even further.Because even very sophisticated protocols, like Collection,can be used as any types.You can even specify the element type,thanks to a new feature called "primary associated types."A lot of associated typesare basically just implementation details.You usually don't care which type a collection usesfor its index, iterator, or subsequence;you just need to use the type it supports.But its Element is a different story.You might not always care exactly which Element typea collection uses, but you're probablygoing to do something with the elements,so you'll need to constrain them or return them or something.When you have an associated type like Elementthat nearly every user of a protocol will care about,you can put its name after the protocol's namein angle brackets to make it a primary associated type.Once you do that, you can constrain the protocol'sprimary associated types with the angle bracket syntaxpretty much anywhere you can write the protocol's name,including in any Collection.Now, some of you might be looking at this type and going,"Wait a minute.Isn't there already something called AnyCollection,just run together and with the 'any' capitalized?"And you're right, there is!The old AnyCollection is a type-erasing wrapper --a handwritten struct which serves the same purposeas an any type.The difference is that the AnyCollection structis just line after line of the most boring boilerplate codeyou've ever seen in your life; whereas the any typeis a built-in language featurethat does basically the same thing --for free!Now, the AnyCollection struct will stick aroundfor backwards compatibility and because it hasa couple of features that any types can't quite match yet.But if you have your own type-erasing wrappersin your code, you might want to see if you can reimplement themusing built-in any types instead of box classes or closures.Or maybe even just replace them with type aliases.So Swift has dramatically improved any types.It's introduced the any keywordso you can see where you're using them.It allows you to pass them to generic arguments.It's abolished the restriction that kept many protocolsfrom being used with them.And it even lets you constrainan any type's primary associated types.But even with all of those improvements,any types still have limitations.For example, even though you can now use any Mailmapswhen Mailmap conforms to Equatable,you still can't use the equals operator with them,because the equals operator requires both mailmapsto have the same concrete type, but that's not guaranteedwhen you're using two any Mailmaps.So even though Swift has improved any types a lot,they still have important limitations,in both capabilities and performance.And that's why a lot of the time, you shouldn't use them --you should use generics instead.So let's go back to the two versions of addEntriesand apply that wisdom.Both versions do exactly the same thing,but the one on the top uses generic types,and the one on the bottom uses any types.The generic version will likely be more efficientand more capable, so you ought to use that one.And yet, you're probably tempted to use any types,because they're just so much easier to read and write.To write the generic version,you need to declare two generic type names,constrain them both, and finally,use those generic type names as the types of the parameters.That's just exhausting compared to writing "any Collection"and "any Mailmap."So you'd be tempted to use any types despite their drawbacks.But that's the same thing I was talking about earlier --using your hammer instead of your screwdriverbecause the hammer has a big, grippy handle.You shouldn't have to make that choice.So Swift is making generics just as easy to useas any types.If a generic parameter is only used in one place,you can now write it with the some keyword as a shorthand.And it even supports primary associated types,so you can accept all collections of mailmap entrieswith code that's a lot easier to understand.With that in your toolbox,there's no reason to avoid generics anymore.If you have a choice between generics and any types,generics will be just as easy to use --just write "some" instead of "any".So you might as well use the best tool for the job.I've only scratched the surface of these changesto protocols and generics.For an in-depth look, as well as a great reviewof all of Swift's generics features,we have two more talks for you this year:"Embrace Swift generics,"and "Design protocol interfaces in Swift."Now, Angela and I have talked aboutnearly two dozen changes to Swift,but there are lots more that we couldn't fit into this session.Every one of these changes was pitched, proposed, reviewed,and accepted publicly in the Evolution boardon the Swift Forums.And all of them were shaped and realized with the helpof community members from outside Apple.If you're one of those people, thank you for making Swift 5.7the great release it is.And if you want to help decide what comes next,visit Swift.org/contributing to find out how to participate.Thanks for your time.And happy coding.

♪

7:19 -Command plugins

8:34 -Build tool plugins

8:39 -Implementing a build tool plugin

9:23 -Module disambiguation with module aliases

9:42 -Distinguishing between modules with the same name

11:09 -Example set of protocols

13:14 -Memory safety in Swift

14:10 -Thread safety in Swift

15:54 -A distributed actor player and a distributed function

16:20 -A distributed actor call

20:12 -Optional unwrapping

20:29 -Optional unwrapping with long variable names

20:35 -Cryptic abbreviated variable names

20:46 -Unwrapping optionals in Swift 5.7

21:07 -Closure type inference

21:33 -Type inference for complicated closures

22:15 -Mismatches that are harmless in C...

22:33 -Better interoperability with C-family code

23:41 -String parsing is hard

24:05 -String parsing is still hard with better indexing

24:20 -What's the problem?

24:55 -Drawing a picture

25:10 -Swift Regex using a literal

25:46 -Did a cat walk across your keyboard?

26:34 -Regex builder

27:05 -Turn a regex into a reusable component

27:30 -Use regex literals within a builder

27:39 -Use Date parsers within Regex builders

27:49 -Matching methods and strongly type captures in Regex

29:02 -A use case for protocols

29:26 -Using the Mailmap protocol

31:05 -`Mailmap` and `any Mailmap`

31:17 -Improvements to `any` types

32:21 -More improvements to `any` types

32:54 -Using Collection as an `any` type

33:04 -Primary associated types

33:42 -Using primary associated types in Collection

34:35 -Example of type erasing wrappers

34:38 -Replace boxes with built-in `any` types

34:44 -Or try type aliases

35:09 -`any` types have important limitations

35:44 -Using generic types vs. `any` types

36:40 -`some Mailmap` and `any Mailmap`

36:50 -`some Mailmap` and `any Mailmap` with Collection and primary associated types

## Code Samples

```swift
@main
 
struct
 
MyPlugin
: 
CommandPlugin
 {

    
func
 
performCommand
(
context
: 
PluginContext
, 
arguments
: [
String
]) 
throws
 {
        
let
 process 
=
 
try
 
Process
.run(doccExec, arguments: doccArgs)
        process.waitUntilExit()
    }

}
```

```swift
import
 PackagePlugin


@main
 
struct
 
MyCoolPlugin
: 
BuildToolPlugin
 {
    
func
 
createBuildCommands
(
context
: 
TargetBuildContext
) 
throws
 -> [
Command
] {
        
// Run some command

    }
}
```

```swift
import
 PackagePlugin


@main
 
struct
 
MyCoolPlugin
: 
BuildToolPlugin
 {
    
func
 
createBuildCommands
(
context
: 
TargetBuildContext
) 
throws
 -> [
Command
] {

        
let
 generatedSources 
=
 context.pluginWorkDirectory.appending(
"GeneratedSources"
)

        
return
 [
            .buildCommand(
                displayName: 
"Running MyTool"
,
                executable: 
try
 context.tool(named: 
"mycooltool"
).path,
                arguments: [
"create"
],
                outputFilesDirectory: generatedSources)
        ]
    }
}
```

```swift
let
 package 
=
 
Package
(
        name: 
"MyStunningApp"
,
        dependencies: [
            .package(url: 
"https://.../swift-metrics.git"
),
            .package(url: 
"https://.../swift-log.git"
)
        ],
        products: [
            .executable(name: 
"MyStunningApp"
, targets: [
"MyStunningApp"
])
        ],
        targets: [
            .executableTarget(
                name: 
"MyStunningApp"
,
                dependencies: [
                    .product(name: 
"Logging"
, 
                             package: 
"swift-log"
),
                    .product(name: 
"Metrics"
, 
                             package: 
"swift-metrics"
,
                             moduleAliases: [
"Logging"
: 
"MetricsLogging"
]),
  ])])
```

```swift
// MyStunningApp



import
 Logging           
// from swift-log


import
 MetricsLogging    
// from swift-metrics



let
 swiftLogger 
=
 
Logging
.
Logger
()


let
 metricsLogger 
=
 
MetricsLogging
.
Logger
()
```

```swift
public
 
protocol
 
NonEmptyProtocol
: 
Collection

    
where
 
Element
 == 
C
.
Element
, 
        
Index
 == 
C
.
Index
 {
    
associatedtype
 
C
: 
Collection

}


public
 
protocol
 
MultiPoint
 {
    
associatedtype
 
C
: 
CoordinateSystem

    
typealias
 
P
 
=
 
Self
.
C
.
P


    
associatedtype
 
X
: 
NonEmptyProtocol
 
        
where
 
X
.
C
: 
NonEmptyProtocol
, 
            
X
.
Element
 
==
 
Self
.
P

}


public
 
protocol
 
CoordinateSystem
 {
    
associatedtype
 
P
: 
Point
 
where
 
Self
.
P
.
C
 
==
 
Self

    
associatedtype
 
S
: 
Size
 
where
 
Self
.
S
.
C
 
==
 
Self

    
associatedtype
 
L
: 
Line
 
where
 
Self
.
L
.
C
 
==
 
Self

    
associatedtype
 
B
: 
BoundingBox
 
where
 
Self
.
B
.
C
 
==
 
Self

}


public
 
protocol
 
Line
: 
MultiPoint
 {}


public
 
protocol
 
Size
 {
    
associatedtype
 
C
: 
CoordinateSystem
 
where
 
Self
.
C
.
S
 
==
 
Self

}


public
 
protocol
 
BoundingBox
 {
    
associatedtype
 
C
: 
CoordinateSystem

    
typealias
 
P
 
=
 
Self
.
C
.
P

    
typealias
 
S
 
=
 
Self
.
C
.
S

}


public
 
protocol
 
Point
 {
    
associatedtype
 
C
: 
CoordinateSystem
 
where
 
Self
.
C
.
P
 
==
 
Self

}
```

```swift
var
 numbers 
=
 [
3
, 
2
, 
1
]

numbers.removeAll(where: { number 
in

    number 
==
 numbers.count 
})
```

```swift
var
 numbers 
=
 [
3
, 
2
, 
1
]


Task
 { numbers.append(
0
) } 

numbers.removeLast()
```

```swift
distributed 
actor
 
Player
 {
   
    
var
 ai: 
PlayerBotAI
?
    
var
 gameState: 
GameState

    
    distributed 
func
 
makeMove
() -> 
GameMove
 {
        
return
 ai.decideNextMove(given: 
&
gameState)
    }
}
```

```swift
func
 
endOfRound
(
players
: [
Player
]) 
async
 
throws
 {
    
// Have each of the players make their move

    
for
 player 
in
 players {
        
let
 move 
=
 
try
 
await
 player.makeMove()
    }
}
```

```swift
if
 
let
 mailmapURL 
=
 mailmapURL {

    mailmapLines 
=
 
try
 
String
(contentsOf: mailmapURL).split(separator: 
"
\n
"
)
    
}
```

```swift
if
 
let
 workingDirectoryMailmapURL 
=
 workingDirectoryMailmapURL {

    mailmapLines 
=
 
try
 
String
(contentsOf: workingDirectoryMailmapURL).split(separator: 
"
\n
"
)
    
}
```

```swift
if
 
let
 wdmu 
=
 workingDirectoryMailmapURL {

    mailmapLines 
=
 
try
 
String
(contentsOf: wdmu).split(separator: 
"
\n
"
)
    
}
```

```swift
if
 
let
 workingDirectoryMailmapURL {
  
    mailmapLines 
=
 
try
 
String
(contentsOf: workingDirectoryMailmapURL).split(separator: 
"
\n
"
)

}


guard
 
let
 workingDirectoryMailmapURL 
else
 { 
return
 }

mailmapLines 
=
 
try
 
String
(contentsOf: workingDirectoryMailmapURL).split(separator: 
"
\n
"
)
```

```swift
let
 entries 
=
 mailmapLines.compactMap { line 
in


    
try?
 parseLine(line)

}


func
 
parseLine
(
_
 
line
: 
Substring
) 
throws
 -> 
MailmapEntry
 { 
…
 }
```

```swift
let
 entries 
=
 mailmapLines.compactMap { line 
in

    
do
 {        
        
return
 
try
 parseLine(line)
    }
    
catch
 {
        logger.warn(
"Mailmap error: 
\(error)
"
)
        
return
 
nil

    }
}



func
 
parseLine
(
_
 
line
: 
Substring
) 
throws
 -> 
MailmapEntry
 { 
…
 }
```

```swift
// Mismatches that are harmless in C…

int mailmap_get_size(mailmap_t 
*
map);
void mailmap_truncate(mailmap_t 
*
map, unsigned 
*
sizeInOut);

void remove_duplicates(mailmap_t 
*
map) {
    int size 
=
 mailmap_get_size(map);
    size 
-=
 move_duplicates_to_end(map);
    mailmap_truncate(map, 
&
size);
}



// …cause problems in Swift.


func
 
removeDuplicates
(
from
 
map
: 
UnsafeMutablePointer
<mailmap_t>) {
    
var
 size 
=
 mailmap_get_size(map)
    size 
-=
 moveDuplicatesToEnd(map)
    mailmap_truncate(map, 
&
size)
}
```

```swift
func
 
removeDuplicates
(
from
 
map
: 
UnsafeMutablePointer
<mailmap_t>) {
    
var
 size 
=
 mailmap_get_size(map)
    size 
-=
 moveDuplicatesToEnd(map)
    
withUnsafeMutablePointer
(to: 
&
size) { signedSizePtr 
in

        signedSizePtr.withMemoryRebound(to: 
UInt32
.
self
, capacity: 
1
) { unsignedSizePtr 
in

            mailmap_truncate(map, unsignedSizePtr)
        }
    }
}
```

```swift
func
 
parseLine
(
_
 
line
: 
Substring
) 
throws
 -> 
MailmapEntry
 {
    
func
 
trim
(
_
 
str
: 
Substring
) -> 
Substring
 {
        
String
(str).trimmingCharacters(in: .whitespacesAndNewlines)[
...
]
    }

    
let
 activeLine 
=
 trim(line[
..<
(line.firstIndex(of: 
"#"
) 
??
 line.endIndex)])
    
guard
 
let
 nameEnd 
=
 activeLine.firstIndex(of: 
"<"
),
          
let
 emailEnd 
=
 activeLine[nameEnd
...
].firstIndex(of: 
">"
),
          trim(activeLine[activeLine.index(after: emailEnd)
...
]).isEmpty 
else
 {
        
throw
 
MailmapError
.badLine
    }

    
let
 name 
=
 nameEnd 
==
 activeLine.startIndex 
?
 
nil
 : trim(activeLine[
..<
nameEnd])
    
let
 email 
=
 activeLine[activeLine.index(after: nameEnd)
..<
emailEnd]

    
return
 
MailmapEntry
(name: name, email: email)
}
```

```swift
func
 
parseLine
(
_
 
line
: 
Substring
) 
throws
 -> 
MailmapEntry
 {
    
func
 
trim
(
_
 
str
: 
Substring
) -> 
Substring
 {
        
String
(str).trimmingCharacters(in: .whitespacesAndNewlines)[
...
]
    }

    
let
 activeLine 
=
 trim(line[
..<
(line.firstIndex(of: 
"#"
) 
??
 line.endIndex)])
    
guard
 
let
 nameEnd 
=
 activeLine.firstIndex(of: 
"<"
),
          
let
 emailEnd 
=
 activeLine[nameEnd
...
].firstIndex(of: 
">"
),
          trim(activeLine[(emailEnd 
+
 
1
)
...
]).isEmpty 
else
 {
        
throw
 
MailmapError
.badLine
    }

    
let
 name 
=
 nameEnd 
==
 activeLine.startIndex 
?
 
nil
 : trim(activeLine[
..<
nameEnd])
    
let
 email 
=
 activeLine[(nameEnd 
+
 
1
)
..<
emailEnd]

    
return
 
MailmapEntry
(name: name, email: email)
}
```

```swift
let
 line 
=
 
"Becca Royal-Gordon <beccarg@apple.com>       # Comment"



func
 
parseLine
(
_
 
line
: 
Substring
) 
throws
 -> 
MailmapEntry
 {
    
func
 
trim
(
_
 
str
: 
Substring
) -> 
Substring
 {
        
String
(str).trimmingCharacters(in: .whitespacesAndNewlines)[
...
]
    }

    
let
 activeLine 
=
 trim(line[
..<
(line.firstIndex(of: 
"#"
) 
??
 line.endIndex)])
    
guard
 
let
 nameEnd 
=
 activeLine.firstIndex(of: 
"<"
),
          
let
 emailEnd 
=
 activeLine[nameEnd
...
].firstIndex(of: 
">"
),
          trim(activeLine[activeLine.index(after: emailEnd)
...
]).isEmpty 
else
 {
        
throw
 
MailmapError
.badLine
    }

    
let
 name 
=
 nameEnd 
==
 activeLine.startIndex 
?
 
nil
 : trim(activeLine[
..<
nameEnd])
    
let
 email 
=
 activeLine[activeLine.index(after: nameEnd)
..<
emailEnd]

    
return
 
MailmapEntry
(name: name, email: email)
}
```

```swift
"Becca Royal-Gordon <beccarg@apple.com>       # Comment"



/
  space name space 
<
      email      
>
 space # or 
EOL
 
/


/
  \h
*
 ( [
^<
#]
+?
 )
??
 \h
*
 
<
 ( [
^>
#]
+
 ) 
>
 \h
*
 (
?
: #
|
\
Z
)  
/
```

```swift
func
 
parseLine
(
_
 
line
: 
Substring
) 
throws
 -> 
MailmapEntry
 {

    
let
 regex 
=
 
/
\h
*
([
^<
#]
+?
)
??
\h
*<
([
^>
#]
+
)
>
\h
*
(
?
:#
|
\
Z
)
/


    
guard
 
let
 match 
=
 line.prefixMatch(of: regex) 
else
 {
        
throw
 
MailmapError
.badLine
    }

    
return
 
MailmapEntry
(name: match.
1
, email: match.
2
)
}
```

```swift
/
\h
*
([
^<
#]
+?
)
??
\h
*<
([
^>
#]
+
)
>
\h
*
(
?
:#
|
\
Z
)
/
```

```swift
import
 RegexBuilder


let
 regex 
=
 
Regex
 {
    
ZeroOrMore
(.horizontalWhitespace)
  
    
Optionally
 {
        
Capture
(
OneOrMore
(.noneOf(
"<#"
)))
    }
        .repetitionBehavior(.reluctant)

    
ZeroOrMore
(.horizontalWhitespace)

    
"<"

    
Capture
(
OneOrMore
(.noneOf(
">#"
)))
    
">"


    
ZeroOrMore
(.horizontalWhitespace)
    
ChoiceOf
 {
       
"#"

       
Anchor
.endOfSubjectBeforeNewline
    }
}
```

```swift
struct
 
MailmapLine
: 
RegexComponent
 {
    
@RegexComponentBuilder

    
var
 regex: 
Regex
<(
Substring
, 
Substring
?, 
Substring
)> {
        
ZeroOrMore
(.horizontalWhitespace)

        
Optionally
 {
            
Capture
(
OneOrMore
(.noneOf(
"<#"
)))
        }
            .repetitionBehavior(.reluctant)

        
ZeroOrMore
(.horizontalWhitespace)

        
"<"

        
Capture
(
OneOrMore
(.noneOf(
">#"
)))
        
">"


        
ZeroOrMore
(.horizontalWhitespace)
        
ChoiceOf
 {
           
"#"

            
Anchor
.endOfSubjectBeforeNewline
        }
    }
}
```

```swift
struct
 
MailmapLine
: 
RegexComponent
 {
    
@RegexComponentBuilder

    
var
 regex: 
Regex
<(
Substring
, 
Substring
?, 
Substring
)> {
        
ZeroOrMore
(.horizontalWhitespace)

        
Optionally
 {
            
Capture
(
OneOrMore
(.noneOf(
"<#"
)))
        }
            .repetitionBehavior(.reluctant)

        
ZeroOrMore
(.horizontalWhitespace)

        
"<"
 
        
Capture
(
OneOrMore
(.noneOf(
">#"
)))
        
">"
 

        
ZeroOrMore
(.horizontalWhitespace)
        
/
#
|
\
Z
/

   }
}
```

```swift
struct
 
DatedMailmapLine
: 
RegexComponent
 {
    
@RegexComponentBuilder

    
var
 regex: 
Regex
<(
Substring
, 
Substring
?, 
Substring
, 
Date
)> {
        
ZeroOrMore
(.horizontalWhitespace)

        
Optionally
 {
            
Capture
(
OneOrMore
(.noneOf(
"<#"
)))
        }
            .repetitionBehavior(.reluctant)

        
ZeroOrMore
(.horizontalWhitespace)

        
"<"
 
        
Capture
(
OneOrMore
(.noneOf(
">#"
)))
        
">"
 

        
ZeroOrMore
(.horizontalWhitespace)

        
Capture
(.iso8601.year().month().day())

        
ZeroOrMore
(.horizontalWhitespace)
        
/
#
|
\
Z
/

   }
}
```

```swift
func
 
parseLine
(
_
 
line
: 
Substring
) 
throws
 -> 
MailmapEntry
 {

    
let
 regex 
=
 
/
\h
*
([
^<
#]
+?
)
??
\h
*<
([
^>
#]
+
)
>
\h
*
(
?
:#
|
\
Z
)
/

    
// or let regex = MailmapLine()


    
guard
 
let
 match 
=
 line.prefixMatch(of: regex) 
else
 {
        
throw
 
MailmapError
.badLine
    }

    
return
 
MailmapEntry
(name: match.
1
, email: match.
2
)
}
```

```swift
/// Used in the commit list UI


struct
 
HashedMailmap
 {
    
var
 replacementNames: [
String
: 
String
] 
=
 [:]
}


/// Used in the mailmap editor UI


struct
 
OrderedMailmap
 {
    
var
 entries: [
MailmapEntry
] 
=
 []
}


protocol
 
Mailmap
 {
    
mutating
 
func
 
addEntry
(
_
 
entry
: 
MailmapEntry
)
}


extension
 
HashedMailmap
: 
Mailmap
 { 
…
 }

extension
 
OrderedMailmap
: 
Mailmap
 { 
…
 }
```

```swift
func
 
addEntries1
<
Map
: 
Mailmap
>(
_
 
entries
: 
Array
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 
Map
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}


func
 
addEntries2
(
_
 
entries
: 
Array
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 
Mailmap
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}
```

```swift
func
 
addEntries1
<
Map
: 
Mailmap
>(
_
 
entries
: 
Array
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 
Map
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}


func
 
addEntries2
(
_
 
entries
: 
Array
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 any 
Mailmap
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}
```

```swift
extension
 
Mailmap
 {
    
mutating
 
func
 
mergeEntries
<
Other
: 
Mailmap
>(
from
 
other
: 
Other
) { 
…
 }
}


func
 
mergeMailmaps
(
_
 
a
: any 
Mailmap
, 
_
 
b
: any 
Mailmap
) -> any 
Mailmap
 {
    
var
 copy 
=
 a
    copy.mergeEntries(from: b)
    
return
 a
}
```

```swift
protocol
 
Mailmap
: 
Equatable
 {
    
mutating
 
func
 
addEntry
(
_
 
entry
: 
MailmapEntry
)
}


func
 
addEntries2
(
_
 
entries
: 
Array
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 any 
Mailmap
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}
```

```swift
protocol
 
Mailmap
: 
Equatable
 {
    
mutating
 
func
 
addEntry
(
_
 
entry
: 
MailmapEntry
)
}


func
 
addEntries2
(
_
 
entries
: any 
Collection
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 any 
Mailmap
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}
```

```swift
protocol
 
Collection
<
Element
>: 
Sequence
 {
    
associatedtype
 
Index
: 
Comparable

    
associatedtype
 
Iterator
: 
IteratorProtocol
<
Element
>
    
associatedtype
 
SubSequence
: 
Collection
<
Element
>
                                    
where
 
SubSequence
.
Index
 
==
 
Index
,
                                          
SubSequence
.
SubSequence
 
==
 
SubSequence


    
associatedtype
 
Element

}
```

```swift
func
 
addEntries1
<
Entries
: 
Collection
<
MailmapEntry
>, 
Map
: 
Mailmap
>(
_
 
entries
: 
Entries
, 
to
 
mailmap
: 
inout
 
Map
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}


func
 
addEntries2
(
_
 
entries
: any 
Collection
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 any 
Mailmap
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}


extension
 
Collection
<
MailmapEntry
> { 
…
 }
```

```swift
struct
 
AnySprocket
: 
Sprocket
 {
    
private
 
class
 
Base
 { 
…
 }
    
private
 
class
 
Box
<
S
: 
Sprocket
>: 
Base
 { 
…
 }
    
private
 
var
 box: 
Base


    
// …dozens of lines of code you hate

    
// having to maintain…

}
```

```swift
struct
 
AnySprocket
: 
Sprocket
 {
    
private
 
var
 box: any 
Sprocket


    
// …fewer lines of code you hate

    
// having to maintain…

}
```

```swift
typealias
 
AnySprocket
 
=
 any 
Sprocket
```

```swift
protocol
 
Mailmap
: 
Equatable
 {
    
mutating
 
func
 
addEntry
(
_
 
entry
: 
MailmapEntry
)
}


func
 
areMailmapsIdentical
(
_
 
a
: any 
Mailmap
, 
_
 
b
: any 
Mailmap
) -> 
Bool
 {
    
return
 a 
==
 b
}
```

```swift
func
 
addEntries1
<
Entries
: 
Collection
<
MailmapEntry
>, 
Map
: 
Mailmap
>(
_
 
entries
: 
Entries
, 
to
 
mailmap
: 
inout
 
Map
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}


func
 
addEntries2
(
_
 
entries
: any 
Collection
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 any 
Mailmap
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}
```

```swift
func
 
addEntries1
<
Entries
: 
Collection
<
MailmapEntry
>>(
_
 
entries
: 
Entries
, 
to
 
mailmap
: 
inout
 
some
 
Mailmap
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}


func
 
addEntries2
(
_
 
entries
: any 
Collection
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 any 
Mailmap
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}
```

```swift
func
 
addEntries1
(
_
 
entries
: 
some
 
Collection
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 
some
 
Mailmap
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}


func
 
addEntries2
(
_
 
entries
: any 
Collection
<
MailmapEntry
>, 
to
 
mailmap
: 
inout
 any 
Mailmap
) {
    
for
 entry 
in
 entries {
        mailmap.addEntry(entry)
    }
}
```


# Wwdc2023 10278

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Create practical workflows in Xcode CloudLearn how Xcode Cloud can help teams of all shapes and sizes in their development process. We'll share different ways to configure actions to help you create simple yet powerful workflows, and show you how to extend Xcode Cloud when you integrate with additional tools.Chapters1:15 -Case Study 1: Solo developer2:33 -What is a workflow6:56 -Custom scripts7:33 -Case Study 2: Medium-sized team9:38 -Pull Request build start condition14:38 -Changing the App Icon19:54 -Case Study 3: Large team24:25 -Running tests reliably26:48 -Extending Xcode CloudResourcesConfiguring webhooks in Xcode CloudConfiguring your first Xcode Cloud workflowDeveloping a workflow strategy for Xcode CloudEnvironment variable referenceImproving code assessment by organizing tests into test plansMaking dependencies available to Xcode CloudWriting custom build scriptsXcode Cloud workflow referenceXcode Cloud Workflows and BuildsHD VideoSD VideoRelated VideosTech TalksConnect your project to Xcode CloudWWDC22Author fast and reliable tests for Xcode CloudDeep dive into Xcode Cloud for teamsWWDC21Customize your advanced Xcode Cloud workflows

Learn how Xcode Cloud can help teams of all shapes and sizes in their development process. We'll share different ways to configure actions to help you create simple yet powerful workflows, and show you how to extend Xcode Cloud when you integrate with additional tools.

1:15 -Case Study 1: Solo developer

2:33 -What is a workflow

6:56 -Custom scripts

7:33 -Case Study 2: Medium-sized team

9:38 -Pull Request build start condition

14:38 -Changing the App Icon

19:54 -Case Study 3: Large team

24:25 -Running tests reliably

26:48 -Extending Xcode Cloud

Configuring webhooks in Xcode Cloud

Configuring your first Xcode Cloud workflow

Developing a workflow strategy for Xcode Cloud

Environment variable reference

Improving code assessment by organizing tests into test plans

Making dependencies available to Xcode Cloud

Writing custom build scripts

Xcode Cloud workflow reference

Xcode Cloud Workflows and Builds

HD VideoSD Video

HD Video

SD Video

Connect your project to Xcode Cloud

Author fast and reliable tests for Xcode Cloud

Deep dive into Xcode Cloud for teams

Customize your advanced Xcode Cloud workflows

Search this video…♪ ♪Romain: Hi, my name is Romain,and I'm an engineer working on Xcode Cloud.Xcode Cloud is a powerful tool,flexible enough to be integrated right into a team's development process.It can increase their productivity and help them deliver better appsto their customers.In this session, I'm going to talk about creating workflows in Xcode Cloud,based on situations you could meet in the real world.Teams come in all shapes and sizes,with diverse and unique development processes.To help us design some practical workflows,we'll imagine three hypothetical case studies.Each of these case study will resemble common situationsthat people might see when adopting Xcode Cloud.We'll start by looking at a solo developer working on a single app.Then, we'll work our way up to a large team dealing with legacy codeand a complex development process.In this session, we'll demonstrate some of the many options availableto create and customize workflows that are well-suited to any team.Let's start off with our first case study.Say we have a solo developer.They have one app that is available on both iOS and macOS.Most of their coding work is done on the main branch,where all the new code changes are pushed.Sure, they'll occasionally use a different branch when experimenting with new APIsand platform features,but for the most part, they use the main branch.Their code relies on a couple of dependenciesand they chose Cocoapods to download and integrate them into their project.Lastly, they deploy builds of their app through TestFlightto some friends and family members who can test and provide feedback on the app.Every now and then, they manually release a new version of their apponto the App Store.This developer is a one-person show.They're managing everything from building their app,to distributing it on the App Store all by themselves.For them, simplicity is going to be key.They'll need something they can rely on and maintain.With Xcode Cloud, their entire process of pushing new code,building their app, and distributing to their testerscan be achieved in one small, but mighty workflow.Before I dive into what this workflow would look like,let's pause and refresh on what an Xcode Cloud workflow is.For example, building your application, running tests,distributing to your testers, and so on.The "where" is the version of Xcode and the version of macOS you want to use,plus any other configuration such as environment variables.Together, they form the environment you want your workflow to run in.Finally, the "when" is when do you want these actions to happen.Do you want it to start when you're pushing code to a specific branch?Or say, every day at 4:00 p.m.?Defining one or more start conditions sets the criteriafor when you want a workflow to run.Great.With that now fresh in our memory, let's apply the "what","where", and "when" to our solo developer's situation.I'm going to create an Xcode Cloud workflow they can useto automate all of their process.Here, I have the project already set up in Xcode Cloud.In the report navigator, I select the cloud icon and right clickon my product name, then select "manage workflows".This opens my workflow editor where I will click on the plus sign to open the menu,and select the first item, to create a new workflow for my app.In the name field, I will enter "CI Workflow".I'm going to skip the description field,but feel free to add details.Now, let's take a look at the environment section.Over in this section, I can see that the latest version of Xcodeand the latest version of MacOS are selected by default.This looks good to me, so I won't make any changes there.Each new workflow comes with a default start condition.Let's take a look.This start condition will create a build every time changes are pushedto the default branch; in this case, main.This is almost correct, but this solo developer wants to start buildswhen code is pushed to any branch, not just the main one.I will change the source branch option to "Any Branch".The goal of this workflow is to build and distribute the application.We need an archive action, that prepares the build for distribution.I'm going to click on the plus side next to the Actions section and select Archive.As you can see, the iOS platform is already selected,so I'm just going to select the "TestFlight and App Store" optionin the Deployment Preparation section.Now that our workflow will produce a build that can be distributed,I'm going to add a post-action that uploads the build to App Store Connect.To do that, I will click on the plus sign in the post actions sectionand select "TestFlight External Testing".From there, I'm going to click on the plus sidein the Groups section and select the "Friends and Family" group of testers.And just like that, we're almost done.Our solo developer works on an application that targets iOS and macOS,so I want my workflow to archive and release the app on both platforms.To do that, I'm going to add another archive action.Select the macOS platformand the TestFlight App Store deployment preparation.Then, I'm going to add another TestFlight External Testing post-action.Select the "Archive - macOS" artifact.And choose the same group for testers.Finally, I'm going to press Save to create the workflow.We mentioned earlier that this developer uses Cocoapodsto include the dependencies their app needs.Out of the box, Xcode Cloud has support for the Swift Package Manager.It is built right into Xcode.But, other dependency managers can also be used in Xcode Cloud.All it takes is a small amount of configuration.There is some documentation on how to usesome of the more popular dependency managers.That documentation can be used as a guide on how to use others.For this solo developer, the documentation suggestsusing a post-clone custom script to install and run the Cocoapods tool.Custom build scripts provide a way to run additional actionsat specific points of an Xcode Cloud build.In this example, the post-clone script is run afterall the source code has been cloned into the temporary build environment.We'll see another example of custom script in a later case study.And that is the solo developer's workflow, ready to go!The next time they push some code, an Xcode Cloud build will start,and the app will be archived for both iOS and macOS.Then, a new build will get into the hands of a group of friends and family,who will test and provide feedback on the app.Now, let's take it up a notch and look at our second use case: a medium sized team.Let's imagine a team composed of developers,project managers, and QA engineers, all spread across the world.They build an iOS app, available on iPhone and iPad.Each developer works in their own branches.They use pull requests to merge their changes backinto a branch named "beta".Their internal QA team installs and tests builds made from that specific branchto ensure the app and its features are working as intended.When they want to release a new version of the app,they merge the beta branch into a release branchand push a new tag to mark the release.To catch bugs and avoid regression,the app is very well tested with both unit and UI tests.They use TestFlight to deploy the app to internal and external testersat different points during development.Finally, they communicate and collaborate on their work over Slack.This is a pretty common example.They're using their tools to work and collaborate in parallel,while holding themselves to a high quality bar.Their process can be implemented with three Xcode Cloud workflows.First, I will create a pull request workflow,that helps getting changes into the beta branch.Then, I will create a beta workflow,that gets internal builds into the hands of the QA team.Lastly, I will create a final workflow to release new versions of the appto external testers and onto the App Store.Let's look at each of the workflows, in that order.The team uses pull requests to manage incorporatingall new code changes into their app.When a developer opens a pull request,their teammates review their code,and they run their tests to make sure the app is working as expected.This first workflow is to make sure that when a new pull request is opened,or an existing one is updated, the tests are run.Let's create this workflow.First, I'm going to click on the plus sign to create a new workflow for my product.In the name field, I will type "Pull Requests".For this workflow, the team wants Xcode Cloud to start buildswhen a pull request is opened, but only when it targets the "beta" branch.For each of those builds, they want to run the tests.Let's start by adding a new start condition.I will click on the plus sign in the start conditions sectionand select the "Pull Request Changes" item.By default, it will start a build for any branches,so in the target branch section, I will select "custom branches"Then I will click on the plus sign button and type in "beta".We only require the one start condition,so I can go ahead and remove the "branch changes" one.Now I will add a new action to run the tests.I will click on the plus sign next to the Actions sectionand select "Test".The app targets both iOS and iPadOS,so the team wants to make sure that the tests passon devices of different screen sizes and capabilities.In the destination section, I will select one small iPhone,The iPhone 13,one large iPhone, The iPhone 14 Pro Max...…one small iPad, The iPad mini.....and finally, you guessed it, one large iPad, the iPad Pro.Then I'm going to press save.Awesome.Now, after a successful build on Xcode Cloud,and hopefully an exhaustive code review from their teammates,the developer will be able to merge their pull requests,and get their changes into the beta branch.Conveniently, this brings us to our next workflow:The beta build workflow.The beta branch is where all upcoming changes are put.When a developer merges a pull request,the QA team wants to get a build of the app with those new changes includedso that they can perform some verification tests.This will be the basis of this new workflow,deploying a build to the QA team.Let's jump back into Xcode and create this workflow.This beta workflow is a mix of the workflows that I previously created.The team wants to release a build every time a change is mergedinto the "beta" branch.They need a workflow that runs the tests, archive the app,and uploads it to App Store Connect.To achieve that, let's create a new workflow.Name it “Beta Release".And update the start condition accordingly.I will select the existing Branch Changes start conditionand change the branch from main to beta.Then, I'm going to add an archive build action.And select the "TestFlight Internal Testing" under deployment preparation.Here, we're using internal distribution,since we don't want this build to be deployed to production by mistake.Now, I'm going to add a post build action, that uploads to App Store Connect.This post action will distribute the applicationto an internal group of testers.I will add a TestFlight Internal Testing post action.Click on the plus sign under the groups section,and select "QA Team."All right, we could stop here,but we don't want to risk deploying a broken build.As a safety net, we're going to run the testsas part of that workflow as well.I'm going to repeat the testing action from the pull request workflow.Once again, I'm going to select one small iPhone,one large iPhone,one small iPad...…and one large iPad.I can now press Save to finalize the creation of this workflow.The beta build workflow gets builds into the hands of the QA team,but there is one more thing the team wants to do.They would like to use an alternative app icon for their beta build.That way, they can quickly determine between which of the builds are internal,and which are App Store ready.This is another perfect situation where Xcode Cloud's custom scripts can help.Earlier, we saw a custom script that ran after the source code has been cloned.Here, we'll use a pre-build script to change the icon.Using the environment variables available in a script,I'm going to make sure that we only swap the iconsin the build phase of our beta workflow.If you want to learn more about how to achieve this,please refer to the session from WWDC21,"Customize your advanced Xcode Cloud workflows"where this exact use case is covered in details.We've only used two of the three types of custom scripts available.If you're wondering what other script you can use,and which environment variables are available to you,our documentation explains all of this in details.And that's it for the beta build workflow.Let's now look at the final workflow for this team, the release workflow.After a number of changes have landed in the beta branchand been verified by QA, the team will prepare a new release.Their process requires one of the developers to merge the beta branchinto a release branch, then create a tag to mark the release.The name of the tag has to start with the word release, then a version.Once this is done, the apps get built,uploaded to App Store Connect,and distributed to a group of internal stakeholders,and some eager customers.Our third and final workflow is very similar to the beta workflow,except that we want builds to be created when a new release tag has been pushed.Let's go back to Xcode and create this workflow.The steps required for this workflow are almost exactly the sameas the one I created in the beta workflow.I could go through all the same steps, like creating the start condition,archiving the app and so on.Instead, I want to direct you to an Xcode Cloud featurethat will allow us to duplicate the beta workflow.First, I'm going to right-click on the beta workflow,select duplicate,then rename the workflow from Beta to Release.Then, I'm going to add a new start condition.So I will click on the plus sign in the start conditions sectionand select "Tag Changes".Similar to the branch changes,I don't want to create builds every time a tag is pushed,but only when the name of the tag starts with the word "release."I'm going to select "Custom Tags" in the "tag" section.Enter "release/"......and select "tags beginning with release/" in the menu.With this start condition created,I will go back to the existing "branch changes" start conditionand delete it.Now, let's move on to the existing Archive action.The beta workflow was created to deploy builds internally,specifically to the QA team.Here, the team wants to prepare a release for external testing and the App Store.In the Deployment Preparation section,I'm going to select the "Testflight and App Store" option.That said, we still want to deploy the buildto an internal team of stakeholders.I'm going to select the existing post build action and remove the QA team Group.Then, I'm going to click on the plus signand select the "Executive Stakeholders" group.As a last step, I'm going to add another post action,but this time select TestFlight External Testing.I will click on the plus sign in the Post Actions sectionand select TestFlight External Testing.Then, I will click on the plus sign in the Groups section,and select the Early Adopters group.Now, the release workflow is almost ready.We mentioned earlier that this team uses Slack to communicateand collaborate with each other.For this team, getting updates about their builds in Slackwill match perfectly their development process.This is especially important if the build failed and cannot be released.Let's add a final step to our workflow.In the release workflow, I will click on the plus signin the post actions section and select Notify.Xcode Cloud supports sending notifications via email and Slack.Here, I'm going to click on the plus sign under Slackand select the “Releases Feed" channel, then press OK.That concludes our second use case.Those three workflows cover all of the team's development process.They build the app and run tests continuously,allowing developers to contribute with confidence.They archive and distribute the app frequently,making sure that various groups of people are able to provide feedback.This is a fairly common situation,where teams can release apps of great qualitywith the help of tools that adapt to any processes.Let's further support this statement by looking at a third and final use case,in which a bigger team wants to migrate to Xcode Cloud.For our final case study, say we have a large team of developers.This team shares a lot of similarities with the medium-sized teamwe just looked at, with some twists.The team is bigger and the code base, much more complex.They have an app on iOS and iPadOS,which has been around since the beginning of the App Store.It has been redesigned and updated many times since then,and developers are dealing with a lot of legacy code and complexity,especially when doing QA.They have a lot of tests.Recently, they adopted a test-driven development approachand lots of new tests are being added with every new code change.A lot of people are involved in successful updates to the app,so they often distribute new builds to various TestFlight groups,both internal and external, to gather feedback.The team includes many developers working around the world,using Slack to communicate and collaborate.But here is the interesting twist.They already rely on continuous integrationand continuous deployment to get their work done.Currently, they use an in-house solutionthat one of the team member maintains and operates.Access to and knowledge of this system is limited,which makes issues hard to investigate and even harder to resolve.For these reasons, and more, they're considering switchingto Xcode Cloud to replace this in-house system.Additionally, they use a project management tool,to track, coordinate, and prioritize the work they're doing.They have also created various dashboards and status pages.That way, people not directly involved in the development of the appcan track the progress of the project.Xcode Cloud is a great fit for this kind of team,but migrating a project of this complexity onto a new CI system is hardand can feel overwhelming.In this situation, my recommendation is to break this migration downinto different milestones.Each milestone involves moving a workload from the existing system into Xcode Cloudover a period of time.The main focus here is to allow a successful migration,while keeping the team productive and happy.Instead of looking at workflow configurations,let's look at what those milestones might be.My recommendation is to split this migration into distinct milestones.The first step is creating a workflow that builds a version of the appthat can be released to the App Store.The second is to get tests working reliably.The third is establishing the remaining workflowsthat match and improve the team's development process.We'll look at each of these steps in details,beginning with creating a release workflow.When migrating to Xcode Cloud,my recommendation is to start by creating a workflowthat archives and uploads an App Store-ready build of the app.This is just like some of the example workflows we've already createdand it can be achieved with zero disruption for the rest of the team.By starting there, you'll be able to use the cloud code signing featurebuilt right into Xcode Cloud.No need to mess with certificates and provisioning profiles to sign your build.This is also a good way to see what is neededin order to build the app successfullywith respect to dependencies and other configuration changes.Once this workflow is ready, it can be includedinto the team's regular development processas the part that creates your App Store-ready build.This is the first piece of work to have moved off of the existing systemand onto Xcode Cloud.Next, its time to focus on getting tests working reliably.Testing can be very tricky in a continuous integration system.Often, tests will have been tailored to run in the CI environmentthat was being used at the time they were created.When running in a new CI environment,they may not run as reliably, causing builds to fail.During the creation of Xcode Cloud,we thought about this specific problem,and built a feature we believe can really help teamsget their tests running smoothly.This feature makes Xcode Cloud ignore failuresin some of the actions in a workflow and let the build finish.To activate this feature, select the "Not Required To Pass" optionunder "requirement" in the workflow's action.By specifying an action as Not Required To Pass,the result of this action won't affect the final result of the Xcode Cloud build.The tests could fail, but the build will succeed nonetheless.You will still see a green checkmark in Xcode Cloud,and in the commit status in your Source Code Management for your build.This is useful because it means you can continually run your testsoff of the critical path.That way, you get to aggregate datato assess how they are performing and if they're reliable enough.Let's look at how to use this feature to get tests working in Xcode Cloud.The team has quite a few tests, covering many aspects of their app.In this situation, my recommendation is to start by creating a new workflowthat runs for all pull requests.In this workflow, a build action will run all the testsbut be marked as Not Required To Pass.Whether the tests pass or fail won't block the pull requestfrom being merged just yet.Right now, the idea is to assess how reliable the tests are.Let's remember, the tests are still running in the existing solution,so the pull requests are still merged with confidence, after a week or so.The team can look at the test result data from their pull request buildsand see which tests have been passing reliably in Xcode Cloud.These tests can be moved into a new Test Plan, called Reliable Tests.Then, the team can edit the existing pull request workflowand add a new test action that will run the tests from that specific test plan.This time, the test action will be required to passbefore the pull request can be merged.For more informations about using test plans on Xcode Cloud,you can refer to the "Author fast and reliable tests for Xcode Cloud"from WWDC22.You can also refer to our documentation on improving code assessmentsusing test plans.The remaining tests,the ones that are not currently performing reliably,can be further investigatedto figure out what changes need to be made to make them reliable.As time goes on and changes are made, those tests can be trusted again.They can finally be moved into the reliable test planand be used to validate changes again.This approach allows you to move your tests to the critical path,step by step, and provide validation and test coveragein your Xcode Cloud workflows.Once you're happy the tests are running,you now have App Store-ready builds and tests,running reliably in Xcode Cloud.Those two workloads can be removed from the existing CI solution.We are now left with the third and final step:building out the rest of the workflows needed for the team's development process.Some of those workflows will be similar to what we've seen alreadyin the case studies in this session.Through the various customizations you can make to start conditions and actions,you can create some really powerful workflowsto help automating your CI and CD process.We also mentioned this team has created tools and dashboardsoutside their CI system.Those tools help them keep on top of their development process,and can also be integrated with Xcode Cloud.For example, you can use the webhook feature.After a webhook as been configured, whenever a build completes,a request will be sent to your server with information about the build,the workflow that started it, and so on.From there, if the build was created from the beta workflow and it succeeded,you could create a new ticket in your task management system,to track the QA process on this specific build.If you wish to learn more about webhooksand specifically when those requests are sentand what information are available to you,you can refer to our documentation.Another approach is to use the Xcode Cloud public API.It allows you to fetch information about the recent builds,among other things, and display them on a dashboard or a status page.Once again, you can refer to the documentationto learn how to use the Xcode Cloud's public APIand integrate it into your workflows.Xcode Cloud's public API and the webhook mechanismare features that are extra useful for teams, no matter their size.When combining all the options available, the possibilities are endless.You can refer to the session from WWDC22,"Deep dive into Xcode Cloud for teams" for more examples.In this session, we looked at various types of simple but powerful workflowsthat can be created to help your team be more productive.We showed some examples on how to customize your build processusing build scripts at various points in the build.Finally, we showed that some of the features allow you to build toolson top of Xcode Cloud and integrate with external tools.We hope that these three cases studies helped you realize how Xcode Cloud can fityour team and improve your day-to-day work.Thank you for watching.♪ ♪

♪ ♪Romain: Hi, my name is Romain,and I'm an engineer working on Xcode Cloud.Xcode Cloud is a powerful tool,flexible enough to be integrated right into a team's development process.It can increase their productivity and help them deliver better appsto their customers.In this session, I'm going to talk about creating workflows in Xcode Cloud,based on situations you could meet in the real world.Teams come in all shapes and sizes,with diverse and unique development processes.To help us design some practical workflows,we'll imagine three hypothetical case studies.Each of these case study will resemble common situationsthat people might see when adopting Xcode Cloud.

We'll start by looking at a solo developer working on a single app.Then, we'll work our way up to a large team dealing with legacy codeand a complex development process.In this session, we'll demonstrate some of the many options availableto create and customize workflows that are well-suited to any team.

Let's start off with our first case study.Say we have a solo developer.They have one app that is available on both iOS and macOS.Most of their coding work is done on the main branch,where all the new code changes are pushed.Sure, they'll occasionally use a different branch when experimenting with new APIsand platform features,but for the most part, they use the main branch.Their code relies on a couple of dependenciesand they chose Cocoapods to download and integrate them into their project.Lastly, they deploy builds of their app through TestFlightto some friends and family members who can test and provide feedback on the app.Every now and then, they manually release a new version of their apponto the App Store.This developer is a one-person show.They're managing everything from building their app,to distributing it on the App Store all by themselves.For them, simplicity is going to be key.They'll need something they can rely on and maintain.With Xcode Cloud, their entire process of pushing new code,building their app, and distributing to their testerscan be achieved in one small, but mighty workflow.Before I dive into what this workflow would look like,let's pause and refresh on what an Xcode Cloud workflow is.For example, building your application, running tests,distributing to your testers, and so on.The "where" is the version of Xcode and the version of macOS you want to use,plus any other configuration such as environment variables.Together, they form the environment you want your workflow to run in.Finally, the "when" is when do you want these actions to happen.

Do you want it to start when you're pushing code to a specific branch?Or say, every day at 4:00 p.m.?Defining one or more start conditions sets the criteriafor when you want a workflow to run.Great.With that now fresh in our memory, let's apply the "what","where", and "when" to our solo developer's situation.I'm going to create an Xcode Cloud workflow they can useto automate all of their process.Here, I have the project already set up in Xcode Cloud.In the report navigator, I select the cloud icon and right clickon my product name, then select "manage workflows".

This opens my workflow editor where I will click on the plus sign to open the menu,and select the first item, to create a new workflow for my app.In the name field, I will enter "CI Workflow".I'm going to skip the description field,but feel free to add details.Now, let's take a look at the environment section.Over in this section, I can see that the latest version of Xcodeand the latest version of MacOS are selected by default.This looks good to me, so I won't make any changes there.Each new workflow comes with a default start condition.Let's take a look.

This start condition will create a build every time changes are pushedto the default branch; in this case, main.This is almost correct, but this solo developer wants to start buildswhen code is pushed to any branch, not just the main one.I will change the source branch option to "Any Branch".

The goal of this workflow is to build and distribute the application.We need an archive action, that prepares the build for distribution.I'm going to click on the plus side next to the Actions section and select Archive.

As you can see, the iOS platform is already selected,so I'm just going to select the "TestFlight and App Store" optionin the Deployment Preparation section.

Now that our workflow will produce a build that can be distributed,I'm going to add a post-action that uploads the build to App Store Connect.To do that, I will click on the plus sign in the post actions sectionand select "TestFlight External Testing".

From there, I'm going to click on the plus sidein the Groups section and select the "Friends and Family" group of testers.

And just like that, we're almost done.Our solo developer works on an application that targets iOS and macOS,so I want my workflow to archive and release the app on both platforms.To do that, I'm going to add another archive action.

Select the macOS platformand the TestFlight App Store deployment preparation.

Then, I'm going to add another TestFlight External Testing post-action.

Select the "Archive - macOS" artifact.

And choose the same group for testers.

Finally, I'm going to press Save to create the workflow.

We mentioned earlier that this developer uses Cocoapodsto include the dependencies their app needs.Out of the box, Xcode Cloud has support for the Swift Package Manager.It is built right into Xcode.But, other dependency managers can also be used in Xcode Cloud.All it takes is a small amount of configuration.There is some documentation on how to usesome of the more popular dependency managers.That documentation can be used as a guide on how to use others.For this solo developer, the documentation suggestsusing a post-clone custom script to install and run the Cocoapods tool.

Custom build scripts provide a way to run additional actionsat specific points of an Xcode Cloud build.In this example, the post-clone script is run afterall the source code has been cloned into the temporary build environment.We'll see another example of custom script in a later case study.And that is the solo developer's workflow, ready to go!The next time they push some code, an Xcode Cloud build will start,and the app will be archived for both iOS and macOS.Then, a new build will get into the hands of a group of friends and family,who will test and provide feedback on the app.Now, let's take it up a notch and look at our second use case: a medium sized team.

Let's imagine a team composed of developers,project managers, and QA engineers, all spread across the world.They build an iOS app, available on iPhone and iPad.Each developer works in their own branches.They use pull requests to merge their changes backinto a branch named "beta".Their internal QA team installs and tests builds made from that specific branchto ensure the app and its features are working as intended.

When they want to release a new version of the app,they merge the beta branch into a release branchand push a new tag to mark the release.To catch bugs and avoid regression,the app is very well tested with both unit and UI tests.They use TestFlight to deploy the app to internal and external testersat different points during development.Finally, they communicate and collaborate on their work over Slack.This is a pretty common example.They're using their tools to work and collaborate in parallel,while holding themselves to a high quality bar.Their process can be implemented with three Xcode Cloud workflows.First, I will create a pull request workflow,that helps getting changes into the beta branch.Then, I will create a beta workflow,that gets internal builds into the hands of the QA team.Lastly, I will create a final workflow to release new versions of the appto external testers and onto the App Store.Let's look at each of the workflows, in that order.The team uses pull requests to manage incorporatingall new code changes into their app.When a developer opens a pull request,their teammates review their code,and they run their tests to make sure the app is working as expected.This first workflow is to make sure that when a new pull request is opened,or an existing one is updated, the tests are run.Let's create this workflow.First, I'm going to click on the plus sign to create a new workflow for my product.In the name field, I will type "Pull Requests".For this workflow, the team wants Xcode Cloud to start buildswhen a pull request is opened, but only when it targets the "beta" branch.For each of those builds, they want to run the tests.Let's start by adding a new start condition.I will click on the plus sign in the start conditions sectionand select the "Pull Request Changes" item.By default, it will start a build for any branches,so in the target branch section, I will select "custom branches"Then I will click on the plus sign button and type in "beta".

We only require the one start condition,so I can go ahead and remove the "branch changes" one.

Now I will add a new action to run the tests.I will click on the plus sign next to the Actions sectionand select "Test".

The app targets both iOS and iPadOS,so the team wants to make sure that the tests passon devices of different screen sizes and capabilities.In the destination section, I will select one small iPhone,The iPhone 13,one large iPhone, The iPhone 14 Pro Max...

…one small iPad, The iPad mini...

..and finally, you guessed it, one large iPad, the iPad Pro.

Then I'm going to press save.

Awesome.Now, after a successful build on Xcode Cloud,and hopefully an exhaustive code review from their teammates,the developer will be able to merge their pull requests,and get their changes into the beta branch.Conveniently, this brings us to our next workflow:The beta build workflow.

The beta branch is where all upcoming changes are put.When a developer merges a pull request,the QA team wants to get a build of the app with those new changes includedso that they can perform some verification tests.This will be the basis of this new workflow,deploying a build to the QA team.Let's jump back into Xcode and create this workflow.

This beta workflow is a mix of the workflows that I previously created.

The team wants to release a build every time a change is mergedinto the "beta" branch.They need a workflow that runs the tests, archive the app,and uploads it to App Store Connect.To achieve that, let's create a new workflow.

Name it “Beta Release".

And update the start condition accordingly.I will select the existing Branch Changes start conditionand change the branch from main to beta.

Then, I'm going to add an archive build action.

And select the "TestFlight Internal Testing" under deployment preparation.

Here, we're using internal distribution,since we don't want this build to be deployed to production by mistake.Now, I'm going to add a post build action, that uploads to App Store Connect.

This post action will distribute the applicationto an internal group of testers.I will add a TestFlight Internal Testing post action.

Click on the plus sign under the groups section,and select "QA Team."All right, we could stop here,but we don't want to risk deploying a broken build.As a safety net, we're going to run the testsas part of that workflow as well.I'm going to repeat the testing action from the pull request workflow.Once again, I'm going to select one small iPhone,one large iPhone,one small iPad...

…and one large iPad.

I can now press Save to finalize the creation of this workflow.

The beta build workflow gets builds into the hands of the QA team,but there is one more thing the team wants to do.They would like to use an alternative app icon for their beta build.That way, they can quickly determine between which of the builds are internal,and which are App Store ready.This is another perfect situation where Xcode Cloud's custom scripts can help.

Earlier, we saw a custom script that ran after the source code has been cloned.Here, we'll use a pre-build script to change the icon.

Using the environment variables available in a script,I'm going to make sure that we only swap the iconsin the build phase of our beta workflow.If you want to learn more about how to achieve this,please refer to the session from WWDC21,"Customize your advanced Xcode Cloud workflows"where this exact use case is covered in details.We've only used two of the three types of custom scripts available.If you're wondering what other script you can use,and which environment variables are available to you,our documentation explains all of this in details.And that's it for the beta build workflow.Let's now look at the final workflow for this team, the release workflow.After a number of changes have landed in the beta branchand been verified by QA, the team will prepare a new release.

Their process requires one of the developers to merge the beta branchinto a release branch, then create a tag to mark the release.

The name of the tag has to start with the word release, then a version.Once this is done, the apps get built,uploaded to App Store Connect,and distributed to a group of internal stakeholders,and some eager customers.

Our third and final workflow is very similar to the beta workflow,except that we want builds to be created when a new release tag has been pushed.Let's go back to Xcode and create this workflow.The steps required for this workflow are almost exactly the sameas the one I created in the beta workflow.I could go through all the same steps, like creating the start condition,archiving the app and so on.Instead, I want to direct you to an Xcode Cloud featurethat will allow us to duplicate the beta workflow.First, I'm going to right-click on the beta workflow,select duplicate,then rename the workflow from Beta to Release.

Then, I'm going to add a new start condition.So I will click on the plus sign in the start conditions sectionand select "Tag Changes".

Similar to the branch changes,I don't want to create builds every time a tag is pushed,but only when the name of the tag starts with the word "release."I'm going to select "Custom Tags" in the "tag" section.Enter "release/"...

...and select "tags beginning with release/" in the menu.With this start condition created,I will go back to the existing "branch changes" start conditionand delete it.Now, let's move on to the existing Archive action.The beta workflow was created to deploy builds internally,specifically to the QA team.Here, the team wants to prepare a release for external testing and the App Store.In the Deployment Preparation section,I'm going to select the "Testflight and App Store" option.That said, we still want to deploy the buildto an internal team of stakeholders.I'm going to select the existing post build action and remove the QA team Group.

Then, I'm going to click on the plus signand select the "Executive Stakeholders" group.As a last step, I'm going to add another post action,but this time select TestFlight External Testing.I will click on the plus sign in the Post Actions sectionand select TestFlight External Testing.Then, I will click on the plus sign in the Groups section,and select the Early Adopters group.

Now, the release workflow is almost ready.We mentioned earlier that this team uses Slack to communicateand collaborate with each other.For this team, getting updates about their builds in Slackwill match perfectly their development process.This is especially important if the build failed and cannot be released.Let's add a final step to our workflow.In the release workflow, I will click on the plus signin the post actions section and select Notify.Xcode Cloud supports sending notifications via email and Slack.Here, I'm going to click on the plus sign under Slackand select the “Releases Feed" channel, then press OK.That concludes our second use case.Those three workflows cover all of the team's development process.They build the app and run tests continuously,allowing developers to contribute with confidence.They archive and distribute the app frequently,making sure that various groups of people are able to provide feedback.This is a fairly common situation,where teams can release apps of great qualitywith the help of tools that adapt to any processes.Let's further support this statement by looking at a third and final use case,in which a bigger team wants to migrate to Xcode Cloud.For our final case study, say we have a large team of developers.This team shares a lot of similarities with the medium-sized teamwe just looked at, with some twists.The team is bigger and the code base, much more complex.They have an app on iOS and iPadOS,which has been around since the beginning of the App Store.It has been redesigned and updated many times since then,and developers are dealing with a lot of legacy code and complexity,especially when doing QA.They have a lot of tests.Recently, they adopted a test-driven development approachand lots of new tests are being added with every new code change.

A lot of people are involved in successful updates to the app,so they often distribute new builds to various TestFlight groups,both internal and external, to gather feedback.The team includes many developers working around the world,using Slack to communicate and collaborate.But here is the interesting twist.They already rely on continuous integrationand continuous deployment to get their work done.Currently, they use an in-house solutionthat one of the team member maintains and operates.Access to and knowledge of this system is limited,which makes issues hard to investigate and even harder to resolve.For these reasons, and more, they're considering switchingto Xcode Cloud to replace this in-house system.Additionally, they use a project management tool,to track, coordinate, and prioritize the work they're doing.They have also created various dashboards and status pages.That way, people not directly involved in the development of the appcan track the progress of the project.Xcode Cloud is a great fit for this kind of team,but migrating a project of this complexity onto a new CI system is hardand can feel overwhelming.In this situation, my recommendation is to break this migration downinto different milestones.Each milestone involves moving a workload from the existing system into Xcode Cloudover a period of time.The main focus here is to allow a successful migration,while keeping the team productive and happy.Instead of looking at workflow configurations,let's look at what those milestones might be.My recommendation is to split this migration into distinct milestones.The first step is creating a workflow that builds a version of the appthat can be released to the App Store.The second is to get tests working reliably.The third is establishing the remaining workflowsthat match and improve the team's development process.We'll look at each of these steps in details,beginning with creating a release workflow.

When migrating to Xcode Cloud,my recommendation is to start by creating a workflowthat archives and uploads an App Store-ready build of the app.This is just like some of the example workflows we've already createdand it can be achieved with zero disruption for the rest of the team.By starting there, you'll be able to use the cloud code signing featurebuilt right into Xcode Cloud.No need to mess with certificates and provisioning profiles to sign your build.This is also a good way to see what is neededin order to build the app successfullywith respect to dependencies and other configuration changes.Once this workflow is ready, it can be includedinto the team's regular development processas the part that creates your App Store-ready build.This is the first piece of work to have moved off of the existing systemand onto Xcode Cloud.Next, its time to focus on getting tests working reliably.Testing can be very tricky in a continuous integration system.Often, tests will have been tailored to run in the CI environmentthat was being used at the time they were created.When running in a new CI environment,they may not run as reliably, causing builds to fail.During the creation of Xcode Cloud,we thought about this specific problem,and built a feature we believe can really help teamsget their tests running smoothly.This feature makes Xcode Cloud ignore failuresin some of the actions in a workflow and let the build finish.

To activate this feature, select the "Not Required To Pass" optionunder "requirement" in the workflow's action.By specifying an action as Not Required To Pass,the result of this action won't affect the final result of the Xcode Cloud build.The tests could fail, but the build will succeed nonetheless.You will still see a green checkmark in Xcode Cloud,and in the commit status in your Source Code Management for your build.

This is useful because it means you can continually run your testsoff of the critical path.That way, you get to aggregate datato assess how they are performing and if they're reliable enough.Let's look at how to use this feature to get tests working in Xcode Cloud.

The team has quite a few tests, covering many aspects of their app.In this situation, my recommendation is to start by creating a new workflowthat runs for all pull requests.In this workflow, a build action will run all the testsbut be marked as Not Required To Pass.Whether the tests pass or fail won't block the pull requestfrom being merged just yet.Right now, the idea is to assess how reliable the tests are.Let's remember, the tests are still running in the existing solution,so the pull requests are still merged with confidence, after a week or so.The team can look at the test result data from their pull request buildsand see which tests have been passing reliably in Xcode Cloud.These tests can be moved into a new Test Plan, called Reliable Tests.Then, the team can edit the existing pull request workflowand add a new test action that will run the tests from that specific test plan.This time, the test action will be required to passbefore the pull request can be merged.For more informations about using test plans on Xcode Cloud,you can refer to the "Author fast and reliable tests for Xcode Cloud"from WWDC22.You can also refer to our documentation on improving code assessmentsusing test plans.The remaining tests,the ones that are not currently performing reliably,can be further investigatedto figure out what changes need to be made to make them reliable.As time goes on and changes are made, those tests can be trusted again.They can finally be moved into the reliable test planand be used to validate changes again.This approach allows you to move your tests to the critical path,step by step, and provide validation and test coveragein your Xcode Cloud workflows.

Once you're happy the tests are running,you now have App Store-ready builds and tests,running reliably in Xcode Cloud.Those two workloads can be removed from the existing CI solution.We are now left with the third and final step:building out the rest of the workflows needed for the team's development process.Some of those workflows will be similar to what we've seen alreadyin the case studies in this session.Through the various customizations you can make to start conditions and actions,you can create some really powerful workflowsto help automating your CI and CD process.We also mentioned this team has created tools and dashboardsoutside their CI system.Those tools help them keep on top of their development process,and can also be integrated with Xcode Cloud.For example, you can use the webhook feature.After a webhook as been configured, whenever a build completes,a request will be sent to your server with information about the build,the workflow that started it, and so on.From there, if the build was created from the beta workflow and it succeeded,you could create a new ticket in your task management system,to track the QA process on this specific build.

If you wish to learn more about webhooksand specifically when those requests are sentand what information are available to you,you can refer to our documentation.Another approach is to use the Xcode Cloud public API.It allows you to fetch information about the recent builds,among other things, and display them on a dashboard or a status page.

Once again, you can refer to the documentationto learn how to use the Xcode Cloud's public APIand integrate it into your workflows.Xcode Cloud's public API and the webhook mechanismare features that are extra useful for teams, no matter their size.When combining all the options available, the possibilities are endless.You can refer to the session from WWDC22,"Deep dive into Xcode Cloud for teams" for more examples.In this session, we looked at various types of simple but powerful workflowsthat can be created to help your team be more productive.We showed some examples on how to customize your build processusing build scripts at various points in the build.Finally, we showed that some of the features allow you to build toolson top of Xcode Cloud and integrate with external tools.We hope that these three cases studies helped you realize how Xcode Cloud can fityour team and improve your day-to-day work.Thank you for watching.♪ ♪

14:38 -Pre-build script that replaces the app icon for beta builds

## Code Samples

```swift
#!/bin/sh


# ci_pre_xcodebuild.sh


#



if
 [[ 
"
$CI_XCODEBUILD_ACTION
"
 == 
"archive"
 && 
"
$CI_WORKFLOW
"
 == 
"Beta"
 ]]; 
then

    
echo
 
"Replacing app icon with beta icon"

    
mv
 BetaAppIcon.appiconset ../App/Assets.xcassets/AppIcon.appiconset

fi
```


# Wwdc2023 10103

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Explore enhancements to App IntentsBring your widgets to life with App Intents! Explore the latest updates and learn how you can take advantage of dynamic options and user interactivity to build better experiences for your App Shortcuts. We'll share how you can integrate with Apple Pay, structure your code more efficiently, and take your Shortcuts app integration to the next level.

For more on App Intents and App Shortcuts, watch “Spotlight your app with App Shortcuts" from WWDC23.ResourcesApp IntentsApp ShortcutsHD VideoSD VideoRelated VideosWWDC23Bring widgets to lifeDesign Shortcuts for SpotlightSpotlight your app with App Shortcuts

Bring your widgets to life with App Intents! Explore the latest updates and learn how you can take advantage of dynamic options and user interactivity to build better experiences for your App Shortcuts. We'll share how you can integrate with Apple Pay, structure your code more efficiently, and take your Shortcuts app integration to the next level.

For more on App Intents and App Shortcuts, watch “Spotlight your app with App Shortcuts" from WWDC23.

App Intents

App Shortcuts

HD VideoSD Video

HD Video

SD Video

Bring widgets to life

Design Shortcuts for Spotlight

Spotlight your app with App Shortcuts

Search this video…♪ ♪Roman Efimov: Hello, everyone.My name is Roman Efimov, and I’m an Engineer on the Shortcuts team.Today, I'll be covering some exciting new features and enhancements in App Intents,helping you create even better apps.First, I'm going to start with widgets.As you know, widgets have become an increasingly important partof the iOS user experience.And now, App Intents and widgets work seamlessly togetherto provide new experiences through interactivity and configuration.Next, I'll move on to the improvements in developer experiencethat we made this year.I will cover some quality improvements, such as framework support,as well as some recent enhancements to static extraction.And finally, I’ll dive into updates tothe Shortcuts app integration with App Intents.We have a pretty packed agenda,so let’s get started with a couple of exciting updates to widgets.First, let's talk about widget configuration.When you create a configurable widget,you can specify the options you want the person to be able to selecton the backside of the widget.These options are called parameters,and you can define them using the same system that you useto add support for Siri and Shortcuts to your app: Intents.The configuration UI of a widget displays an ordered list of parametersthat are included in the corresponding Intent.Each parameter added to the Intentis presented as a row in the widget configuration interface.In the past, you had to declare your Intents in Xcodeusing an Intent Definition File.Now in iOS 17, we have made it even simplerto define the schema of your widget's configurationusing App Intents right in your Widget extension code.To do that, first, you will need to start using the AppIntentConfigurationWidgetConfiguration type instead of the IntentConfigurationthat you may have used previously to configure your widget.Next, define a new type that conforms to the WidgetConfigurationIntent protocol.WidgetConfigurationIntent is a sub-protocol of App Intent,and you can conform to it directly in your Widget Extension code.I've been working on a widget for my bus schedule appthat displays the time and route of the next scheduled bus for a particular stop.This would allow people to quickly check when the next bus is arrivingwithout having to open the full app.I will be using App Intents to provide the configuration Intent for my widget.To let users configure my Next Bus widget,I'm going to start by defining a structthat conforms to the WidgetConfigurationIntent protocoland includes the following parameters:a Bus Stop, chosen from the list of saved stops or by searching for a new stop,a specific bus Route,and a Direction of travel for the selected route.Once I finish defining the parameters required to configure my widget,I'll need to provide dynamic options for each of the parameter types.In the past, providing dynamic options for a parameterrequired creating a separate Intents extension.With App Intents, I can implement queries and dynamic option providersdirectly within my widget extension,leading to a cleaner and more efficient project.To learn more about dynamic options providers and queries,I would suggest checking out the “Dive into App Intents” video.Now, let's talk about migrating your existing widgetsfrom SiriKit to App Intents.Migrating your existing widget configuration to App Intents is easy.In fact, it can be done with a single click in Xcode.Migrating your widget lets you support both the latest OS version,and previous versions before you were able to convert your Widget to App Intents.Existing configured widgets can continue working.Once you no longer need to support previous OS versions,you can remove your SiriKit Intent definition file.To migrate, navigate to your SiriKit widget configuration Intentwithin your Intent definition fileand click the Convert to App Intent button.Xcode will produce App Intents codethat is equivalent to your old Intent definition.You will need to ensure that the schema stays the same,meaning that all App Intent parameter names and typesshould match what you had in your Intent definition.Feel free to add new parameters to your App Intent.You can add an optional parameter or even a required one that has a default value.Existing widgets, created before the parameter was added,will pick up an empty value for that parameteror a default value if you've provided one.If you do plan to support people on previous iOS versionsand let them use that new parameter,then you will need to maintain your SiriKit Intent definition fileand add that new parameter in there, as well.Whenever a customer updates your app,their widget will get automatically migrated.It is crucial to test that the migration goes smoothly,as your app will only have one opportunity to do so.To learn more about migration, I encourage you to watchthe “Migrate custom Intents to App Intents” video.Moving on to interactivity in widgets.Widgets can now react to button taps and toggles,allowing people to adjust settings, play media,or access any other important functionality from your appright from their homescreen.In my Next Bus widget, I would like to make the time buttons tappable.When people tap one of these buttons, I want to set an alarm in my app,ensuring that they know exactly when to leave,so they don't miss their bus!How can I do that?SwiftUI Buttons and Toggles have been updated to support App Intents,making it easy to add interactivity to widgets.If you implemented an App Intent before, you should be instantly familiar with it.First, I would need to define a struct that conforms to the App Intent protocol.Then, annotate any key properties with the Parameter property wrapperto let the system know I need the associated informationto perform the action.After that, I need to implement the perform methodthat would actually execute the action.Finally, in my Widget view,I simply associate my SetAlarm App Intent with a Button.SwiftUI integration with App Intents is not only available for interactive widgetsbut also for regular SwiftUI apps.By consolidating the code into App Intents,you can reduce redundancy and ensure consistent behavior across your app.Since App Intents serve both as a configurationand as providers of interactive actions,it is quite easy to reuse the Intent code for Shortcuts.For example, my ShowNextBus widget configuration Intentcan be used as both a widget configuration and a Shortcuts actionthat can provide me with up-to-date information when I need it.In addition, the App Intent I used to add interactivity to my widgetalso serves as a great Shortcuts action,allowing people to set the alarm for their preferred bus arrival time.To learn more about Widget Interactivity,check out “Bring your widget to life”.Let’s move on to several advanced techniquesthat can enhance the functionality and design of your Widget configuration.First, let’s talk about enhancements to Dynamic options and queries.Dynamic options is an interface for providing the available valuesfor a parameter of your App Intent,and it can be implemented by conforming to DynamicOptionsProvideror EntityQuery family of protocols.In some cases, you may want to show options that are only availablewhen a certain condition based on the value of another parameter is met.For example, in my widget configuration,I want to display only the route options that are availablebased on the Bus Stop parameter.To do that, I can use a new API in iOS 17 called IntentParameterDependency.It is a property wrapper that lets you access parameters from your Intents,within a DynamicOptionsProvider or Query.You can read these parameters and use them to createmore dynamic and context-aware options.In my example, I return the available bus routesfiltered by the user's selected bus stop.IntentParameterDependency works in all environments,such as Widgets, Shortcuts, and Focus Filters.In my example, I have a struct called BusRouteQuerythat conforms to the EntityQuery protocol.This struct has a property called ShowNextBus, which is wrapped withthe IntentParameterDependency property wrapper.This means that the Bus Route query has a dependencyon the showNextBus App Intent, specifically on the bus stop parameter.Notice the suggestedEntities method.It returns an array of suggested Route objects.It first checks if the showNextBus Intent property is non-nil.If so, it filters the available routesso that the person will only see routes that match their specified bus stop.IntentParameterDependency can also depend on multiple parameters.For example, in my direction query, I want to rely onboth the bus stop and route parameters to provide the direction options.You can also depend on multiple App Intents within the same queryor dynamic options provider.My direction query reads parameters from two Intents:ShowNextBus and ShowFavoriteRoute.The IntentParameterDependency property wrapper is used tospecify the dependencies on the busStopand route parameters for ShowNextBus Intent,and the route parameter for ShowFavoriteRoute Intent.The route computed property returns the value fromeither showNextBus or showFavoriteRoute, depending on which one is available.Widget Configurations often have array parameters.For instance, my Favorite Routes widgetcan display the bus schedules for a person's favorite routes.However, due to limited screen space,a person should be able to select only up to three routes.So how can I declare that?New in iOS 17, you can now declare the size when defining an Array parameter.The size here can also accept a mapping from the widget family to the array sizesince sometimes larger widgets can accommodate more items than smaller ones.Once I have defined my Widget Configuration App Intentand its parameters,I might want to define which of these parameters are shown to the user and when.ParameterSummary defines the visual representationof an App Intent’s parameters.It powers the appearance of your App Intent in the Shortcuts editor,Focus Filters, and now in Widget Configuration.You can use parameter summaries to define which parameters are shownand in what conditions.For Widgets, the UI will first show the parameters in the Summary sentenceand then any additional parameters listed in the closure.Here, the sentence contains the routes parameter,and the closure has includeWeatherInfo,so they're displayed in that order in the configuration UI.New in iOS 17, you can now use the When statement with the widget family,allowing your widget configuration to change based on widget size.For example, I want to display the toggle that shows weather informationonly in large widgets, while other sizes will not have this capability.So I add the includeWeatherInfo parameterto the Parameter Summary, only for large widgets.Otherwise, for small widgets, I won't add it, so the parameter is hidden.Now that I've implemented configuration for my widget using App Intents,how do I determine what happens when the person taps on it?The person is taken to my app whenever they tap anywhere in my widget.I would like to take them directly to the screen that shows informationabout the specific route that they selected in their widget configuration.When a person taps your widget and your app is launched,you can get the associated configuration Intentby calling the widgetConfigurationIntent method on the user activity.Once you have the App Intent, you can use it to update your app's UI accordingly.Here, I extract the content from my Configuration Intentand use it to navigate my app to the specific bus stop viewfor the corresponding stop and route.When you build a widget, you'll want to make surepeople see it at just the right time in their Smart Stacks.To do that, you can use the new RelevantContext APIsfor Widget suggestions on iOS and watchOS.Drawing inspiration from the previous INInteraction,INDailyRoutine, and INRelevantShortcut APIs,we have designed the new RelevantIntentManager and RelevantIntent,to be more Swift-friendly and work seamlessly with App Intents.Imagine a sports app that wants to surface its widget during games.With the new RelevantContext API,you can specify this Intent and its relevant date range.By providing this relevant date information,the sports app widget will automatically be suggested within the Smart Stack,ensuring that people have easy access to the game informationwhen it's most important.Relevance APIs are also great for surfacing your watch complications.To learn more about the watchOS side of relevance,check out "Build widgets for the Smart Stack on Apple Watch."Now that we've covered Widgets,let’s dive into the developer experience improvementsthat we’ve made in iOS 17 and Xcode 15.We’ll start with Framework Support.If your app requires the ability to perform App Intentsfrom both the main app and an App Intents extension,you currently need to compile your App Intent code into both targets.Unfortunately, this approach leads to code duplication,which can introduce maintenance issuesand increase the likelihood of errors or inconsistencies.This also bloats the binary size,which can negatively impact the app's performanceand download times for people.In iOS 17 and Xcode 15,frameworks can now expose App Intents directly,so there's no more need to compile your code twice.You can now use the AppIntentsPackage APIsto recursively import dependencies in your app.By conforming types to the AppIntentsPackage protocol,both your app and frameworks can re-export metadata from other frameworks.I'm going to use framework support to simplifythe implementation of my Bus Schedule app.I have a framework called BusScheduleIntentsthat provides various App Intents for viewing bus schedules.It makes itself available for re-exporting without any dependencies.I have another framework called BusScheduleUIthat provides custom interface elements for the Bus Schedule app.This framework depends on and re-exports the BusScheduleIntents framework.Finally, I import the BusScheduleUI framework from my Bus Schedule app.Since the AppIntentsPackage is a protocol,I can make my SwiftUI App struct conform to it.The Bus Schedule app only needs to mention its direct dependencyon the BusScheduleUI framework.I can now create a SwiftUI button within my Bus Schedule appthat displays my favorite bus route by performing the ShowSchedule App Intent.The same App Intent, ShowSchedule, is also available to Shortcuts users,which means that they can create custom Shortcutsto quickly access their favorite bus route schedules without even opening the app.Moving your App Intents into Frameworkshelps make your codebase simpler and more streamlined.The new framework support is especially greatwhen building Widgets with App Intents,since you might need to access the same Intentsfrom both your app, and your Widget extension.One more tip on keeping your App Intents code more modular:you can now create an AppShortcutsProviderand define App Shortcuts in your App Intents extensions.Previously, you had to define your App Shortcutsentirely in your main app bundle.This would mean that your app is always launched in the backgroundwhen an App Shortcut is run.Now you can define your App Shortcuts in an App Intents extension.This is great for performance because you can optimize your App Intents extensionto come up faster than your entire main appand avoid bringing up UI, analytics, or other non-critical code.All these features rely on static metadata extraction enhancementsthat we've made in Xcode 15.So let's talk about how App Intents contentis statically extracted while your code is built.The Swift compiler outputs information about the types available in your code,as well as type-level and some value-level informationfrom your App Intents implementations.Another tool then parses this informationto generate a Metadata.appIntents directory in your built product,which contains files describing your App Intents, parameters,entities, queries, and more.In Xcode 15, the static extraction process has been significantly improved.It is now faster, more reliable, and works in more cases than ever before.When building your apps with Xcode 15,if Xcode is unable to statically extract something it expects,you will now see error messages directly in the Xcode editor,along with line numbers, so you know where to go and fix the problem.Before we talk about Shortcuts integration,there are two more great abilities we've added to App Intents this yearwhich are worth mentioning.First up, is the ability to continue the execution of an Intent in your app,even if that Intent was previously running in the background.We call this the ForegroundContinuableIntent protocol.For example, if my App Intent that fetches the next busfails to retrieve the bus schedule due to invalid parameters or connectivity issues,I could ask the person to continue in the app to resolve the issue.To do that, first, I conform my App Intentto the ForegroundContinuableIntent protocol.The ForegroundContinuableIntent protocol is designed for Intents thatinitially start their work in the backgroundbut may need to request continuation in the foreground.Next, I call the needsToContinueInForegroundError method,which returns an error to me.When I throw that error, the system stops performing the App Intentand asks the user to continue execution in the foreground.I can also provide an optional continuation closurethat will be executed on the main threadto update my app's state after it comes into the foreground.Here, I'm using this closure to navigate my app to an error screen.Use needsToContinueInForegroundError when you want to stop the Intent executionand require action to continue, like in the previous example.We have another API you can use if you want to continue executing the App Intent,instead of stopping it entirely.For that case, call the requestToContinueInForeground method.I might use this when the bus app detects thata bus route is having a maintenance issue,and I want to present a custom UI in my app to choose an alternate route.Once the person has chosen the route,I can return that updated route from my app and continue the App Intent execution.This time, instead of throwing an error,I'm simply calling a method with try and await.The closure passed in can return a value, which I can get back within my perform.That allows me to continue executing the App Intentafter getting input from the user.Here, I take the alternate route the user has chosenand return a snippet showing the next bus for that route.In summary, use the throwing methodwhen you want to completely stop the execution of App Intent.Otherwise, if you want to get a result from the personand use it to complete the App Intent's perform,use requestToContinueInForeground and await its result.This year, we've also added support for Apple Pay to App Intents.You can now initiate an Apple Pay transactiondirectly within your perform method.Using Apple Pay in your perform is simple.I'm going to create a PKPaymentRequest instanceand configure it with the necessary information.Next, I use PKPaymentAuthorizationControllerto present the Apple Pay payment sheet and handle authorization.A guard statement checks if the controller is presented successfully.If not, I return a dialog with "Unable to process payment."Otherwise, the payment is processed successfully.Finally, let's dig into a couple of updates to integrationbetween App Intents and the Shortcuts app.Let's start with all the different places in the systemwhere App Intents is integrated.App Intents is a modern way to build Shortcuts actions,and App Shortcuts make it easier to discover and useyour app's functionality with Siri and the Shortcuts app.There's also integration with Focus Filtersand the Action button on Apple Watch Ultra.In iOS 17, App Intents have become even more widely accessiblethanks to the integration with Interactive Live Activities,Widget Configuration and Interactivity, and SwiftUI.App Shortcuts have grown too,to include support for Spotlight Top Hits and Automations.All these integrations mean that the same App Intents codecan be reused in lots of different ways.Since App Intents are now deeply integrated into key system components,it's very important to ensure thatthe App Intents you create are being good citizens.Providing a good parameter summary is crucial to ensure thatyour App Intents look great when they are surfaced across the system.Write your parameter summaries so that they read like a sentence,with optional parameters tucked beneath the fold.The system will then determine the optimal visual representationfor your parameter summary based on the context.While it's desirable for your App Intents to work well everywhere,there might be cases where you need to make App Intentsfor use within your app or in an interactive widget,and you want to hide them from other parts of the system.For example, when an App Intent invokes a local function in your appthat would not make a useful Shortcut action.In that case, you can set the isDiscoverable propertyon your App Intent to false.I am going to add a refresh button to my Next Bus widgetthat will retrieve the latest data from the server.While it serves a purpose in my widget, it doesn't make a useful Shortcuts action.Since I only want this App Intent to be used from my interactive widget,I will set isDiscoverable to false for it.Note that App Intents marked as undiscoverablecannot participate in App Shortcuts either.The Intents in my app perform pretty quickly,but not all Intents do.This year, we introduced a new way for youto provide progress for long-running Intents.To report progress, simply make your App Intentsconform to the ProgressReportingIntent protocol.Inside the perform() method, you can access the provided progress object.Update the progress by setting the totalUnitCountand incrementing the completedUnitCount as your Intent execution advances.The Shortcuts app will now automatically displaythe progress of your App Intent execution.Implementing progress reporting isparticularly important for long-running Intents.It is really valuable for people to have that feedback,so they know the perform of the Intent is moving forward,and when it might complete.This year, we've also improved how your app can integrate with Find actions.Shortcuts users love being able to find content within your appby specific criteria, with actions like Find Notes.The outputs of these actions can be sent on to other Shortcuts actions,like sending an email, enabling lots of powerful workflows.In iOS 16, you could automatically get a Find action for your appby implementing an EntityPropertyQuery,declaring the criteria you want users to be able to specify.Starting with iOS 17, you can now also usethe EnumerableEntityQuery protocol instead.It's really simple and easy to adopt.Implementing EnumerableEntityQuery is as simple as returningall the possible values for your entity in the allEntities() method.Shortcuts and App Intents take it from there,automatically generating find actions.The difference between EnumerableEntityQueryand EntityPropertyQueryis that with EntityPropertyQuery, we send you, the developer, the criteria,and you run the search on behalf of the user.That means you will often return a limited set of results.With EnumerableEntityQuery,you give the framework all the possible entities,and Shortcuts does the filtering.Because it returns all the entities,EnumerableEntityQuery is really simple to use,but it's also optimized for a small number of entities.It works well for cases, such as Safari's Tab Groups,but is not suitable for a large number of entities,which would be typical for the Notes app.It is also not suitable for very large entities that take up a lot of memory.In this case, use EntityPropertyQuery so you can run the search on your end,instead of returning all the possible entities at once.Lastly, I want to tell you about some updates to IntentDescription.This is the type you use to fill out the Shortcuts UIpeople see when tapping the details button to get more information on your action.IntentDescription includes description text, category name, and search keywords.In iOS 17 the Intent Description type has been updatedwith a new property called resultValueName,so you can provide a more descriptive name for the output of your action.Here, "Add Reminder" provides a resultValueName of "New Reminder"for the reminder that it has created and returned.When the "Add Reminder" action here is connected to the Show Result Action,the parameter in the Show Result action shows that name: "New Reminder."To provide a resultValueName, just use the new initializer on IntentDescription.Starting with iOS 17, you can also include an Intent descriptionfor your Find actions that are generatedusing the EntityPropertyQuery or EnumerableEntityQuery protocols.To do this, simply adopt the findIntentDescription propertywithin your query types.If you categorize your actions with categoryName,this will let you display the generated Find actionsunder your desired category in the list of actions supported by your app.To summarize, App Intents are a great way to expose functionalityof your app to the system and to your users.To learn even more about how you can turn your App Intentsinto App Shortcuts so people can use them right away,I suggest you check out the "Spotlight your app with App Shortcuts" session.This year, App Intents enable you to build configurable, interactive widgetsand live activities,and provide an even smoother developer experience,with deeper integration into the Shortcuts app.I'm truly excited to see how your apps can leveragethe new App Intents technologies to surprise and delight.Thanks for joining me.

♪ ♪Roman Efimov: Hello, everyone.My name is Roman Efimov, and I’m an Engineer on the Shortcuts team.Today, I'll be covering some exciting new features and enhancements in App Intents,helping you create even better apps.First, I'm going to start with widgets.As you know, widgets have become an increasingly important partof the iOS user experience.And now, App Intents and widgets work seamlessly togetherto provide new experiences through interactivity and configuration.Next, I'll move on to the improvements in developer experiencethat we made this year.I will cover some quality improvements, such as framework support,as well as some recent enhancements to static extraction.And finally, I’ll dive into updates tothe Shortcuts app integration with App Intents.We have a pretty packed agenda,so let’s get started with a couple of exciting updates to widgets.First, let's talk about widget configuration.When you create a configurable widget,you can specify the options you want the person to be able to selecton the backside of the widget.These options are called parameters,and you can define them using the same system that you useto add support for Siri and Shortcuts to your app: Intents.The configuration UI of a widget displays an ordered list of parametersthat are included in the corresponding Intent.Each parameter added to the Intentis presented as a row in the widget configuration interface.In the past, you had to declare your Intents in Xcodeusing an Intent Definition File.Now in iOS 17, we have made it even simplerto define the schema of your widget's configurationusing App Intents right in your Widget extension code.

To do that, first, you will need to start using the AppIntentConfigurationWidgetConfiguration type instead of the IntentConfigurationthat you may have used previously to configure your widget.Next, define a new type that conforms to the WidgetConfigurationIntent protocol.WidgetConfigurationIntent is a sub-protocol of App Intent,and you can conform to it directly in your Widget Extension code.I've been working on a widget for my bus schedule appthat displays the time and route of the next scheduled bus for a particular stop.This would allow people to quickly check when the next bus is arrivingwithout having to open the full app.I will be using App Intents to provide the configuration Intent for my widget.To let users configure my Next Bus widget,I'm going to start by defining a structthat conforms to the WidgetConfigurationIntent protocoland includes the following parameters:a Bus Stop, chosen from the list of saved stops or by searching for a new stop,a specific bus Route,and a Direction of travel for the selected route.Once I finish defining the parameters required to configure my widget,I'll need to provide dynamic options for each of the parameter types.In the past, providing dynamic options for a parameterrequired creating a separate Intents extension.With App Intents, I can implement queries and dynamic option providersdirectly within my widget extension,leading to a cleaner and more efficient project.To learn more about dynamic options providers and queries,I would suggest checking out the “Dive into App Intents” video.Now, let's talk about migrating your existing widgetsfrom SiriKit to App Intents.Migrating your existing widget configuration to App Intents is easy.In fact, it can be done with a single click in Xcode.Migrating your widget lets you support both the latest OS version,and previous versions before you were able to convert your Widget to App Intents.Existing configured widgets can continue working.Once you no longer need to support previous OS versions,you can remove your SiriKit Intent definition file.To migrate, navigate to your SiriKit widget configuration Intentwithin your Intent definition fileand click the Convert to App Intent button.Xcode will produce App Intents codethat is equivalent to your old Intent definition.You will need to ensure that the schema stays the same,meaning that all App Intent parameter names and typesshould match what you had in your Intent definition.Feel free to add new parameters to your App Intent.You can add an optional parameter or even a required one that has a default value.Existing widgets, created before the parameter was added,will pick up an empty value for that parameteror a default value if you've provided one.If you do plan to support people on previous iOS versionsand let them use that new parameter,then you will need to maintain your SiriKit Intent definition fileand add that new parameter in there, as well.Whenever a customer updates your app,their widget will get automatically migrated.It is crucial to test that the migration goes smoothly,as your app will only have one opportunity to do so.To learn more about migration, I encourage you to watchthe “Migrate custom Intents to App Intents” video.Moving on to interactivity in widgets.Widgets can now react to button taps and toggles,allowing people to adjust settings, play media,or access any other important functionality from your appright from their homescreen.In my Next Bus widget, I would like to make the time buttons tappable.When people tap one of these buttons, I want to set an alarm in my app,ensuring that they know exactly when to leave,so they don't miss their bus!How can I do that?SwiftUI Buttons and Toggles have been updated to support App Intents,making it easy to add interactivity to widgets.If you implemented an App Intent before, you should be instantly familiar with it.First, I would need to define a struct that conforms to the App Intent protocol.Then, annotate any key properties with the Parameter property wrapperto let the system know I need the associated informationto perform the action.After that, I need to implement the perform methodthat would actually execute the action.Finally, in my Widget view,I simply associate my SetAlarm App Intent with a Button.SwiftUI integration with App Intents is not only available for interactive widgetsbut also for regular SwiftUI apps.By consolidating the code into App Intents,you can reduce redundancy and ensure consistent behavior across your app.Since App Intents serve both as a configurationand as providers of interactive actions,it is quite easy to reuse the Intent code for Shortcuts.For example, my ShowNextBus widget configuration Intentcan be used as both a widget configuration and a Shortcuts actionthat can provide me with up-to-date information when I need it.In addition, the App Intent I used to add interactivity to my widgetalso serves as a great Shortcuts action,allowing people to set the alarm for their preferred bus arrival time.To learn more about Widget Interactivity,check out “Bring your widget to life”.Let’s move on to several advanced techniquesthat can enhance the functionality and design of your Widget configuration.First, let’s talk about enhancements to Dynamic options and queries.Dynamic options is an interface for providing the available valuesfor a parameter of your App Intent,and it can be implemented by conforming to DynamicOptionsProvideror EntityQuery family of protocols.In some cases, you may want to show options that are only availablewhen a certain condition based on the value of another parameter is met.For example, in my widget configuration,I want to display only the route options that are availablebased on the Bus Stop parameter.To do that, I can use a new API in iOS 17 called IntentParameterDependency.It is a property wrapper that lets you access parameters from your Intents,within a DynamicOptionsProvider or Query.You can read these parameters and use them to createmore dynamic and context-aware options.In my example, I return the available bus routesfiltered by the user's selected bus stop.IntentParameterDependency works in all environments,such as Widgets, Shortcuts, and Focus Filters.In my example, I have a struct called BusRouteQuerythat conforms to the EntityQuery protocol.This struct has a property called ShowNextBus, which is wrapped withthe IntentParameterDependency property wrapper.This means that the Bus Route query has a dependencyon the showNextBus App Intent, specifically on the bus stop parameter.Notice the suggestedEntities method.It returns an array of suggested Route objects.It first checks if the showNextBus Intent property is non-nil.If so, it filters the available routesso that the person will only see routes that match their specified bus stop.IntentParameterDependency can also depend on multiple parameters.For example, in my direction query, I want to rely onboth the bus stop and route parameters to provide the direction options.You can also depend on multiple App Intents within the same queryor dynamic options provider.My direction query reads parameters from two Intents:ShowNextBus and ShowFavoriteRoute.The IntentParameterDependency property wrapper is used tospecify the dependencies on the busStopand route parameters for ShowNextBus Intent,and the route parameter for ShowFavoriteRoute Intent.The route computed property returns the value fromeither showNextBus or showFavoriteRoute, depending on which one is available.

Widget Configurations often have array parameters.For instance, my Favorite Routes widgetcan display the bus schedules for a person's favorite routes.However, due to limited screen space,a person should be able to select only up to three routes.So how can I declare that?New in iOS 17, you can now declare the size when defining an Array parameter.The size here can also accept a mapping from the widget family to the array sizesince sometimes larger widgets can accommodate more items than smaller ones.Once I have defined my Widget Configuration App Intentand its parameters,I might want to define which of these parameters are shown to the user and when.ParameterSummary defines the visual representationof an App Intent’s parameters.It powers the appearance of your App Intent in the Shortcuts editor,Focus Filters, and now in Widget Configuration.You can use parameter summaries to define which parameters are shownand in what conditions.For Widgets, the UI will first show the parameters in the Summary sentenceand then any additional parameters listed in the closure.Here, the sentence contains the routes parameter,and the closure has includeWeatherInfo,so they're displayed in that order in the configuration UI.New in iOS 17, you can now use the When statement with the widget family,allowing your widget configuration to change based on widget size.For example, I want to display the toggle that shows weather informationonly in large widgets, while other sizes will not have this capability.So I add the includeWeatherInfo parameterto the Parameter Summary, only for large widgets.Otherwise, for small widgets, I won't add it, so the parameter is hidden.Now that I've implemented configuration for my widget using App Intents,how do I determine what happens when the person taps on it?The person is taken to my app whenever they tap anywhere in my widget.I would like to take them directly to the screen that shows informationabout the specific route that they selected in their widget configuration.When a person taps your widget and your app is launched,you can get the associated configuration Intentby calling the widgetConfigurationIntent method on the user activity.Once you have the App Intent, you can use it to update your app's UI accordingly.Here, I extract the content from my Configuration Intentand use it to navigate my app to the specific bus stop viewfor the corresponding stop and route.When you build a widget, you'll want to make surepeople see it at just the right time in their Smart Stacks.To do that, you can use the new RelevantContext APIsfor Widget suggestions on iOS and watchOS.Drawing inspiration from the previous INInteraction,INDailyRoutine, and INRelevantShortcut APIs,we have designed the new RelevantIntentManager and RelevantIntent,to be more Swift-friendly and work seamlessly with App Intents.Imagine a sports app that wants to surface its widget during games.With the new RelevantContext API,you can specify this Intent and its relevant date range.By providing this relevant date information,the sports app widget will automatically be suggested within the Smart Stack,ensuring that people have easy access to the game informationwhen it's most important.

Relevance APIs are also great for surfacing your watch complications.To learn more about the watchOS side of relevance,check out "Build widgets for the Smart Stack on Apple Watch."Now that we've covered Widgets,let’s dive into the developer experience improvementsthat we’ve made in iOS 17 and Xcode 15.We’ll start with Framework Support.If your app requires the ability to perform App Intentsfrom both the main app and an App Intents extension,you currently need to compile your App Intent code into both targets.Unfortunately, this approach leads to code duplication,which can introduce maintenance issuesand increase the likelihood of errors or inconsistencies.This also bloats the binary size,which can negatively impact the app's performanceand download times for people.In iOS 17 and Xcode 15,frameworks can now expose App Intents directly,so there's no more need to compile your code twice.You can now use the AppIntentsPackage APIsto recursively import dependencies in your app.By conforming types to the AppIntentsPackage protocol,both your app and frameworks can re-export metadata from other frameworks.I'm going to use framework support to simplifythe implementation of my Bus Schedule app.I have a framework called BusScheduleIntentsthat provides various App Intents for viewing bus schedules.It makes itself available for re-exporting without any dependencies.I have another framework called BusScheduleUIthat provides custom interface elements for the Bus Schedule app.This framework depends on and re-exports the BusScheduleIntents framework.Finally, I import the BusScheduleUI framework from my Bus Schedule app.Since the AppIntentsPackage is a protocol,I can make my SwiftUI App struct conform to it.The Bus Schedule app only needs to mention its direct dependencyon the BusScheduleUI framework.I can now create a SwiftUI button within my Bus Schedule appthat displays my favorite bus route by performing the ShowSchedule App Intent.The same App Intent, ShowSchedule, is also available to Shortcuts users,which means that they can create custom Shortcutsto quickly access their favorite bus route schedules without even opening the app.Moving your App Intents into Frameworkshelps make your codebase simpler and more streamlined.The new framework support is especially greatwhen building Widgets with App Intents,since you might need to access the same Intentsfrom both your app, and your Widget extension.One more tip on keeping your App Intents code more modular:you can now create an AppShortcutsProviderand define App Shortcuts in your App Intents extensions.Previously, you had to define your App Shortcutsentirely in your main app bundle.This would mean that your app is always launched in the backgroundwhen an App Shortcut is run.Now you can define your App Shortcuts in an App Intents extension.This is great for performance because you can optimize your App Intents extensionto come up faster than your entire main appand avoid bringing up UI, analytics, or other non-critical code.All these features rely on static metadata extraction enhancementsthat we've made in Xcode 15.So let's talk about how App Intents contentis statically extracted while your code is built.The Swift compiler outputs information about the types available in your code,as well as type-level and some value-level informationfrom your App Intents implementations.Another tool then parses this informationto generate a Metadata.appIntents directory in your built product,which contains files describing your App Intents, parameters,entities, queries, and more.In Xcode 15, the static extraction process has been significantly improved.It is now faster, more reliable, and works in more cases than ever before.When building your apps with Xcode 15,if Xcode is unable to statically extract something it expects,you will now see error messages directly in the Xcode editor,along with line numbers, so you know where to go and fix the problem.Before we talk about Shortcuts integration,there are two more great abilities we've added to App Intents this yearwhich are worth mentioning.First up, is the ability to continue the execution of an Intent in your app,even if that Intent was previously running in the background.We call this the ForegroundContinuableIntent protocol.For example, if my App Intent that fetches the next busfails to retrieve the bus schedule due to invalid parameters or connectivity issues,I could ask the person to continue in the app to resolve the issue.To do that, first, I conform my App Intentto the ForegroundContinuableIntent protocol.The ForegroundContinuableIntent protocol is designed for Intents thatinitially start their work in the backgroundbut may need to request continuation in the foreground.Next, I call the needsToContinueInForegroundError method,which returns an error to me.When I throw that error, the system stops performing the App Intentand asks the user to continue execution in the foreground.I can also provide an optional continuation closurethat will be executed on the main threadto update my app's state after it comes into the foreground.Here, I'm using this closure to navigate my app to an error screen.Use needsToContinueInForegroundError when you want to stop the Intent executionand require action to continue, like in the previous example.We have another API you can use if you want to continue executing the App Intent,instead of stopping it entirely.For that case, call the requestToContinueInForeground method.I might use this when the bus app detects thata bus route is having a maintenance issue,and I want to present a custom UI in my app to choose an alternate route.Once the person has chosen the route,I can return that updated route from my app and continue the App Intent execution.This time, instead of throwing an error,I'm simply calling a method with try and await.The closure passed in can return a value, which I can get back within my perform.That allows me to continue executing the App Intentafter getting input from the user.Here, I take the alternate route the user has chosenand return a snippet showing the next bus for that route.

In summary, use the throwing methodwhen you want to completely stop the execution of App Intent.Otherwise, if you want to get a result from the personand use it to complete the App Intent's perform,use requestToContinueInForeground and await its result.

This year, we've also added support for Apple Pay to App Intents.You can now initiate an Apple Pay transactiondirectly within your perform method.Using Apple Pay in your perform is simple.I'm going to create a PKPaymentRequest instanceand configure it with the necessary information.Next, I use PKPaymentAuthorizationControllerto present the Apple Pay payment sheet and handle authorization.A guard statement checks if the controller is presented successfully.If not, I return a dialog with "Unable to process payment."Otherwise, the payment is processed successfully.Finally, let's dig into a couple of updates to integrationbetween App Intents and the Shortcuts app.Let's start with all the different places in the systemwhere App Intents is integrated.App Intents is a modern way to build Shortcuts actions,and App Shortcuts make it easier to discover and useyour app's functionality with Siri and the Shortcuts app.There's also integration with Focus Filtersand the Action button on Apple Watch Ultra.In iOS 17, App Intents have become even more widely accessiblethanks to the integration with Interactive Live Activities,Widget Configuration and Interactivity, and SwiftUI.App Shortcuts have grown too,to include support for Spotlight Top Hits and Automations.All these integrations mean that the same App Intents codecan be reused in lots of different ways.Since App Intents are now deeply integrated into key system components,it's very important to ensure thatthe App Intents you create are being good citizens.Providing a good parameter summary is crucial to ensure thatyour App Intents look great when they are surfaced across the system.Write your parameter summaries so that they read like a sentence,with optional parameters tucked beneath the fold.The system will then determine the optimal visual representationfor your parameter summary based on the context.While it's desirable for your App Intents to work well everywhere,there might be cases where you need to make App Intentsfor use within your app or in an interactive widget,and you want to hide them from other parts of the system.For example, when an App Intent invokes a local function in your appthat would not make a useful Shortcut action.In that case, you can set the isDiscoverable propertyon your App Intent to false.I am going to add a refresh button to my Next Bus widgetthat will retrieve the latest data from the server.While it serves a purpose in my widget, it doesn't make a useful Shortcuts action.Since I only want this App Intent to be used from my interactive widget,I will set isDiscoverable to false for it.Note that App Intents marked as undiscoverablecannot participate in App Shortcuts either.The Intents in my app perform pretty quickly,but not all Intents do.This year, we introduced a new way for youto provide progress for long-running Intents.To report progress, simply make your App Intentsconform to the ProgressReportingIntent protocol.Inside the perform() method, you can access the provided progress object.Update the progress by setting the totalUnitCountand incrementing the completedUnitCount as your Intent execution advances.The Shortcuts app will now automatically displaythe progress of your App Intent execution.Implementing progress reporting isparticularly important for long-running Intents.It is really valuable for people to have that feedback,so they know the perform of the Intent is moving forward,and when it might complete.This year, we've also improved how your app can integrate with Find actions.Shortcuts users love being able to find content within your appby specific criteria, with actions like Find Notes.The outputs of these actions can be sent on to other Shortcuts actions,like sending an email, enabling lots of powerful workflows.In iOS 16, you could automatically get a Find action for your appby implementing an EntityPropertyQuery,declaring the criteria you want users to be able to specify.Starting with iOS 17, you can now also usethe EnumerableEntityQuery protocol instead.It's really simple and easy to adopt.Implementing EnumerableEntityQuery is as simple as returningall the possible values for your entity in the allEntities() method.Shortcuts and App Intents take it from there,automatically generating find actions.The difference between EnumerableEntityQueryand EntityPropertyQueryis that with EntityPropertyQuery, we send you, the developer, the criteria,and you run the search on behalf of the user.That means you will often return a limited set of results.With EnumerableEntityQuery,you give the framework all the possible entities,and Shortcuts does the filtering.Because it returns all the entities,EnumerableEntityQuery is really simple to use,but it's also optimized for a small number of entities.It works well for cases, such as Safari's Tab Groups,but is not suitable for a large number of entities,which would be typical for the Notes app.It is also not suitable for very large entities that take up a lot of memory.In this case, use EntityPropertyQuery so you can run the search on your end,instead of returning all the possible entities at once.Lastly, I want to tell you about some updates to IntentDescription.This is the type you use to fill out the Shortcuts UIpeople see when tapping the details button to get more information on your action.IntentDescription includes description text, category name, and search keywords.In iOS 17 the Intent Description type has been updatedwith a new property called resultValueName,so you can provide a more descriptive name for the output of your action.Here, "Add Reminder" provides a resultValueName of "New Reminder"for the reminder that it has created and returned.When the "Add Reminder" action here is connected to the Show Result Action,the parameter in the Show Result action shows that name: "New Reminder."To provide a resultValueName, just use the new initializer on IntentDescription.Starting with iOS 17, you can also include an Intent descriptionfor your Find actions that are generatedusing the EntityPropertyQuery or EnumerableEntityQuery protocols.To do this, simply adopt the findIntentDescription propertywithin your query types.If you categorize your actions with categoryName,this will let you display the generated Find actionsunder your desired category in the list of actions supported by your app.To summarize, App Intents are a great way to expose functionalityof your app to the system and to your users.To learn even more about how you can turn your App Intentsinto App Shortcuts so people can use them right away,I suggest you check out the "Spotlight your app with App Shortcuts" session.This year, App Intents enable you to build configurable, interactive widgetsand live activities,and provide an even smoother developer experience,with deeper integration into the Shortcuts app.I'm truly excited to see how your apps can leveragethe new App Intents technologies to surprise and delight.Thanks for joining me.

## Code Samples


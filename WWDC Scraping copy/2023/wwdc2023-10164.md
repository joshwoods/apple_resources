# Wwdc2023 10164

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

What’s new in SwiftJoin us for an update on Swift. We'll show you how APIs are becoming more extensible and expressive with features like parameter packs and macros. We'll also take you through improvements to interoperability and share how we're expanding Swift's performance and safety benefits everywhere from Foundation to large-scale distributed programs on the server.Chapters0:39 -Swift project update2:44 -Using if/else and switch statements as expressions3:52 -Result builders4:53 -type parameter packs9:34 -Swift macros19:47 -Swift foundation23:25 -Ownership27:59 -C++ interoperability32:41 -What's new in Swift Concurrency38:20 -FoundationDB: A case studyResourcesEvolving Swift Project WorkgroupsSwift CMake ExamplesSwift EvolutionThe Future of FoundationHD VideoSD VideoRelated VideosWWDC23Beyond the basics of structured concurrencyExpand on Swift macrosGeneralize APIs with parameter packsMeet SwiftDataMix Swift and C++What’s new in SwiftUIWrite Swift macrosWWDC21Swift concurrency: Behind the scenes

Join us for an update on Swift. We'll show you how APIs are becoming more extensible and expressive with features like parameter packs and macros. We'll also take you through improvements to interoperability and share how we're expanding Swift's performance and safety benefits everywhere from Foundation to large-scale distributed programs on the server.

0:39 -Swift project update

2:44 -Using if/else and switch statements as expressions

3:52 -Result builders

4:53 -type parameter packs

9:34 -Swift macros

19:47 -Swift foundation

23:25 -Ownership

27:59 -C++ interoperability

32:41 -What's new in Swift Concurrency

38:20 -FoundationDB: A case study

Evolving Swift Project Workgroups

Swift CMake Examples

Swift Evolution

The Future of Foundation

HD VideoSD Video

HD Video

SD Video

Beyond the basics of structured concurrency

Expand on Swift macros

Generalize APIs with parameter packs

Meet SwiftData

Mix Swift and C++

What’s new in SwiftUI

Write Swift macros

Swift concurrency: Behind the scenes

Search this video…♪ ♪Ben: Hi, and welcome to "What's New in Swift 5.9."I'm Ben, and together with my colleague Doug,we'll take you through some of the improvementsto the Swift language this year.We'll talk about some ways it's easier to express what you meanusing Swift's clean syntax, some powerful new featuresthat help framework authors make their new APIs more natural to use,and we'll look at some new ways to get more control over performanceand safety in low-level code.But let's start by talking about the Swift open source project.This is a great update for Swift, and it couldn't have happenedwithout the Swift community,the contributors and users of the languagewho gather at swift.org, working together to evolve the languageand support new initiatives.Swift follows an open process for language evolution.New features or significant behavior changes are proposedand reviewed in the open on the Swift forums.If you want to follow along, you can find a dashboardof all the language proposals on the Swift website.A year ago, we saw a significant restructuringof the Swift Project governance.The core team announced the formation of the Language Steering Group,which took on primary responsibility for oversight of the Swift languageand standard library evolution.Since then, the language group has overseen40 new language proposals,and we're going to talk about several of them today.But sometimes, individual language proposalscome together as part of a wider theme,like the addition of Swift concurrency,which was introduced through ten separate proposals.For cases like this, the language steering grouphas introduced a new way of tying together these proposals,through vision documents.These documents lay out a proposal for larger changes to the language.The first one to be accepted by the language steering groupwas a vision of Swift macros, a new feature in Swift 5.9that we'll be covering later in this talk.Of course, evolution of the language is only partof the work of the Swift community.A successful language needs much more than this.It needs great tooling, robust support for multiple platforms,and rich documentation.To oversee progress in this area, the core team is creatingan ecosystem steering group parallel to the language steering group.This new structure was recently laid out in a blog post on Swift.org,a look out for further announcementsabout the formation of this new group soon.Now let's talk about changes to the Swift language this year,starting with better ways to express yourself in your code.Swift 5.9 includes whatis probably our most commonly requested language enhancement,allowing if/else and switch statements to be used as expressions,providing a nice way to clean up your code.For example, if you wanted to initialize a let variablebased on some complex condition, you had to resort to tricks,like this hard-to-read compound ternary expression.If expressions let you instead use a much more familiarand readable chain of if statements.Another place where this helpsis if you're initializing a global variable or a stored property.Single expressions work fine here, but if you wanted a condition,you had to use the trick of wrapping it in a closurethat you then immediately executed.Now that an if statement can be an expression,you can just drop that clutter, leaving you with neater code.Result builders, the declarative syntax that drives features like SwiftUI,have seen significant improvements this year,including optimized type checking performance,code completion, and improved error messages.This improvement was particularly focused on invalid code.Previously, result builder code with errors would take a long time to fail,as the type checker explored the many possible invalid paths.As of Swift 5.8, invalid code type checks much faster,and error messages on invalid code are now more precise.For example, previously, some invalid code could leadto misleading errors in a completely different part of the result builder.In Swift 5.7, you'd receive an error like this,when the mistake actually lies up here.In the latest release, you now receivea more accurate compiler diagnostic identifying the real issue.Next, let's talk about how an addition to the generics systemwill allow for some great improvements to frameworks you use every day.Almost all the Swift you write is using generics in some way.Type inference enables using these types without needingto understand the advanced capabilities they're built with.For example, the standard library Array type uses genericsto provide an array that works with any type of datathat you might want to store.When you use an array, all you need to do is provide the elements.There's no need to specify an explicit argument for the element typebecause it can be inferred from the element values.Swift's generics system enables natural APIsthat preserve type informationso that your code operates seamlessly on the concrete types that you provide.Here's an example inspired by the Swift compiler's own codebase:An API that takes a request typeand evaluates it to produce a strongly typed value.So you can make a request for a Boolean valueand get back a Boolean result.Now, some APIs want to abstract not only over concrete types,but also the number of arguments that you pass in.So a function might take one request and return one resultor two requests and return two results, or three and return three results.To support this, the generics system has to be usedtogether with a mechanism to handle multiple argument lengthsso that all of the types that you pass in are linked to the types that you get out.Before Swift 5.9, the only way to accomplish this patternwas by adding an overload for each specific argument lengththe API supported.But this approach has limitations.It forces an artificial upper boundon the number of arguments you can pass,resulting in compiler errorsif you pass too many.In this case, there isn't an overload that can handlemore than six arguments, but we've passed seven.This overloading pattern and its limitations are pervasiveacross APIs that conceptually handle arbitrary argument length.In Swift 5.9, the generics system is gaining first-class supportfor this API pattern by enabling generic abstraction over argument length.This is done with a new language conceptthat can represent multiple individual type parametersthat are "packed" together.This new concept is called a type parameter pack.Using parameter packs,APIs that currently have individual overloadsfor each fixed argument lengthcan be collapsed down into a single function.Instead of accepting a single type parameter, Result,representing the result type of a single request,the evaluate function now accepts a separate request over each Result type.The function returns each result instance in parenthesis,which will either be a single value or a tuple containing each value.The evaluate function now handles all argument lengths with no artificial limit.Type inference makes APIs using parameter packs natural to usewithout needing to know that the API is using them.Calling our new evaluate functionthat can now handle any number of arguments,looks just like calling the fixed-length overloads.Swift infers the type of each argument along with the total numberbased on how you're calling the function.To learn about how to write generic library APIs like these,check out Generalize APIs using parameter packs.Calling generic APIs in a natural way demonstrates oneof Swift's fundamental design goals, clear expression through concise code.Swift's advanced language features enable beautiful APIsthat make it easier to say what you mean.You benefit from these advanced language featuresfrom the very first lines of Swift that you ever write,whether it's using generics through arrays or dictionariesor designing a UI in SwiftUI.Swift's embrace of progressive disclosure means that you can learnabout the more advanced features when you're ready to.Swift 5.9 takes this design approach to the next levelby providing library authors with a new toolboxfor expressive API design using a new macro system.Here's Doug to tell you more.Doug: With macros, you can extend the capabilities of the language itself,eliminating boilerplate and unlocking more of Swift's expressive power.Let's consider the ever-present assert function,which checks whether a condition is true.Assert will stop the program if the condition is false,but when that happens, you get very little informationabout what went wrong, just the file and line number.You'll need to add some logging or trap the program in the debugger to learn more.There have been attempts to improve on this.XCTest provides an assert-equal operation that takes the two values separately,so when things fail, you can at least see the two values that aren't equal.But we still don't know which value is wrong here.Was it a, b, or the result of max?And this approach really doesn't scale for all of the kinds of checkswe perform in asserts.If we go back to the original assertion, there is so much information herein the source code that we'd like to see in the log when our assertion fails.What was the code?What are the values of a, and b, and c?What did max produce?We couldn't improve this in Swift before without some custom feature,but macros make it possible.In this example, the "hash-assert" syntax is expanding the macro called "assert."The hash syntax might look familiarbecause Swift already has a few things with this same spelling,like hash-file, hash-selector, and hash-warning.The assert macro looks and feels like the function version,but because it's a macro, it can provide a richer experiencewhen the assertion fails.Now the program is showing the code for the failing assertion,along with each of the values that contributed to the result.In Swift, macros are APIs, just like types or functions,so you access them by importing the module that defines them.Like many other APIs, macros are distributed as packages.The assert macro here comes from the power asserts library,an open-source Swift package available on GitHub.If you were to look into the macro package,you would find a macro declaration for assert.It is introduced with the "macro" keyword,but otherwise, it looks a lot like a function.There's a single unlabeled Bool parameterfor the condition to be checked.If this macro produced a value,that result type would be writtenwith the usual arrow syntax.Uses of the macro will be type checkedagainst the parameters.That means, if you were to make a mistakein using the macro,such as forgetting to comparethe maximum value against something,you'll get a useful error messageimmediately,before the macro is ever expanded.This allows Swift to providea great development experiencewhen using macros because macros operateon well-typed inputs and produce codethat augments your programin predictable ways.Most macros are definedas "external macros,"specifying the module and type for a macro implementation via strings.The external macro types are defined in separate programsthat act as compiler plugins.The Swift compiler passes the source codefor the use of the macro to the plugin.The plugin produces new source code,which is then integrated back into the Swift program.Here, the macro is expanding the assertion into codethat captures the individual valuesand where they should be displayed in the source code.You wouldn't want to write the boilerplate yourself,but the macro does it for you.Macro declarations have one additional piece of information, their role.The assert macro here is a freestanding expression macro.It is called freestanding because it uses the "hash" syntaxand operates directly on that syntax to produce new code.It is an expression macro because it can be used anywherethat one can produce a value.The new Foundation Predicate APIs provide a great example of an expression macro.The predicate macro allows one to write predicatesin a type-safe manner using closures.The resulting predicate values can then be used with a number of other APIs,including the Swift collection operations SwiftUI and SwiftData.The macro itself is genericover the set of input types.It accepts a closure argumentthat's a function operating on valuesof those input types and producesa Boolean result,does the set of inputs match or not?And the macro returns an instanceof the new Predicate type,which can be used elsewherein the program.But there is more to macros because a lot of the boilerplatewe end up writing is because we need to augment codewe have written with something else derived from it.Let's take an example.I find that I use enums a lot in my own code,like this Path enum that captures either relative or absolute paths.But I'll often find myself needing to check for a specific case,say, by filtering all absolute paths from a collection.I can write this isAbsolute check as a computed property, of course.But sooner or later, I'm going to have to write another one.This is getting a bit tedious.Macros can help here by generating the boilerplate for us.Case detection is an attached macro,written using the same custom-attribute syntax as property wrappers.Attached macros take as input the syntax of the declaration they apply to--here it's the enum declaration itself-- and will generate new code.This macro-expanded code is normal Swift code,which the compiler integrates into your program.You can inspect the macro-generated code in your editor, debug into it,copy it out if you want to customize it further, and so on.Attached macros are classified into five different rolesbased on how they augment the declaration they are attached to.The case detection macro we just discussed is a "member" attached macro,meaning that it creates new members in a type or extension.Peer macros add new declarations alongside the declaration they're attached to,for example, to create a completion-handler versionof an async method or vice-versa.Accessor macros can turn a stored property into a computed property,which can be used to perform specific actions on property accessor abstract the actual storage in a manner similar to,but more flexible than property wrappers.And attached macros can introduce attributesonto specific members of a type, as well as add new protocol conformances.Several attached macro roles can be composed togetherto achieve useful effects.One important example of this is with observation.Observation has always been a part of SwiftUI.To be able to observe changes to the properties of a class,one need only make the type conform to ObservableObject,and mark every property at-Published,and use the ObservedObject property wrapper in your view.That's a bunch of steps, and missing a step can meanthat the UI doesn't update as expected.We can do better with macro-based observation.Attaching the Observable macro to a class provides observationfor all of its stored properties.There is no need to annotate each stored propertyor worry about what happens if you don'tbecause the Observable macro handles it all.The Observable macro works through composition of three macro roles.Let's dive into how these roles work together.Each macro role corresponds to a specific wayin which the Person class is augmented by the Observable macro.The member role introduces new properties and methods.The member attribute role will add the @ObservationTracked macroto the stored properties of the observed class,which in turn expands to getters and setters to trigger observation events.Finally, the conformance role introduces the conformanceto the Observable protocol.This may look like a lot of code, but it's all just normal Swift code,and it's neatly folded away behind the Observable macro.Whenever you need to see how any macro expandsto better understand its effect on your program,it's right there at your fingertips in Xcode.Use the "Expand Macro" actionto see the macro-expanded source code in your editor.Any error messages within macro-generated codewill automatically show the expanded code,and you can step into and out of it with your debugger.Swift macros provide a new tool for enabling more expressive APIsand eliminating boilerplate from your Swift code,helping unlock Swift's expressive power.Macros type-check their inputs, produce normal Swift code,and integrate at defined points in your program,so their effects are easy to reason about.And any time you need to understand what a macro did,its expanded source code is right there in your editor.We've just scratched the surface of macros."Expand on Swift macros" will go deep into the design of Swift macrosto answer all of those questions you must have.And you can get hands-on implementing your own macroswith "Write Swift macros."I can't wait to see what new macros the Swift community will build.Ben: From the start, Swift was designed to be a scalable language.Swift's design emphasizes expressivity with clear and concise codethat is low on ceremony and easy to read and write.By leveraging Swift's powerful features,like generics and native concurrency support,frameworks like SwiftUI or SwiftDatalet you quickly achieve the results you want,leaving you more time to focus on what matters.Despite these high-level capabilities though,Swift is also efficient.It compiles natively, and its use of value typesand of reference counting instead of garbage collection meansit's able to achieve a low memory footprint.This scalability means we're able to push Swift to more placesthan was previously possible with Objective-C,to low-level systems, where previously you might expectto have to use C or C++.This means bringing Swift's clearer code and critical safety guaranteesto more places.We recently open sourced the start of a rewriteof the Foundation framework in Swift.This initiative will lead to a single shared implementationof Foundation on both Apple and non-Apple platforms.But it also meant rewriting large amounts of Objective-C and C code in Swift.As of MacOS Sonoma and iOS 17, there are new Swift-backed implementationsof essential types like Date and Calendar,of formatting and internationalization essentialslike Locale and AttributedString,and a new Swift implementation of JSON encoding and decoding.And the performance wins have been significant.Calendar's ability to calculate important dates can take better advantageof Swift's value semantics to avoid intermediate allocations,resulting in over a 20% improvement in some benchmarks.Date formatting using FormatStyle also gainedsome major performance upgrades, showing a massive 150% improvementin a benchmark of formatting with a standard date and time template.Even more exciting are the improvements to JSON decoding in the new package.Foundation has a brand-new Swift implementationfor JSONDecoder and JSONEncoder, eliminating costly roundtripsto and from the Objective-C collection types.The tight integration of parsing JSON in Swift for initializing Codable typesimproves performance too.In benchmarks parsing test data, the new implementationis between two and five times faster.These improvements came from both reducing the bridging costfrom the old Objective-C implementation to Swift,but also by the new Swift-based implementations being faster.Let's look at one benchmark as an example.In Ventura, calling enumerateDates from Objective-C was slightly fasterthan calling it from Swift because of bridging costs.In MacOS Sonoma,calling that same functionality from Swift is 20% faster.Some of that speed up comes from eliminating bridging costs,but the new function implementation itself is also faster,as seen when calling it from Objective-C.This particular date calculation is not overly complex,so this is a great way of seeing the reductionin overhead between the two languages.Now, sometimes, when you're operating at lower levelsof the system, you need more fine-grained controlto achieve a necessary level of performance.Swift 5.9 introduces some new opt-in capabilitiesthat help you achieve this level of control.These capabilities focus on the concept of ownership, that is,what part of the code "owns" a value as it passes around your application.To see when you might want to use these features,let's first look at some example code.Here we have a very simple wrapper for a file descriptorthat would allow us to give low-level system calls a nicer Swift interface.But there’s still some easy ways to make mistakes with this API.For example, you might try to write to the file after you’ve called close.And you have to be careful to always close it manuallyby calling the close method before the type goes out of scope.Otherwise, you would get a resource leak.One solution would be to make it a classwith a deinit that closes it automatically when the type goes out of scope.But that has different downsides,like making an additional memory allocation,which is usually not a big problem,except in some very constrained systems contexts.Classes also have reference semantics.You might unintentionally end up sharing a file descriptor type across threads,leading to race conditions, or store it unintentionally.But let's go back and look at the struct version.Really, this struct also behaves like a reference type.It holds an integer that references the true value,which is an open file.Making a copy of this type could also lead to unintentional sharingof mutable state across your app in ways that could lead to bugs.What you want is to suppress the ability to make a copy of this struct.Swift types, whether structs or classes, are copyable by default.This is the right choice most of the time.While excessive unnecessary copies can sometimes be a bottleneck in your code,it's better to spend the time finding those bottlenecksin instruments occasionally than to be constantly botheredby the compiler requiring you to be explicit about those copies.But sometimes that implicit copy isn't what you want--in particular,when making copies of a value might lead to correctness issues,like with our file descriptor wrapper.In Swift 5.9, you can do that with this new syntax that can be appliedto struct and enum declarationsand that suppresses the implicit ability to copy a type.Once a type is non-copyable, you can give it a deinit,like you can a class,that will run when a value of the type goes out of scope.Non-copyable types can also be used to solve the problem of calling close,and then using other methods.The close operation can be marked as consuming.Calling a consuming method or argument gives up ownershipof a value to the method you called.Since our type is not copyable,giving up ownership means you can no longer use the value.By default, methods in Swift borrow their arguments, including self.So you can call the write method, which borrows the file descriptor,uses it to write out to the buffer, and after that,ownership of the value returns to the caller,and you can call another method, like close.But since close has been marked as consuming,not the default of borrowing, it must be its final use.This means, if you close the file first and then attempt to call another method,like write, you'll get an error message at compile time,rather than a runtime failure.The compiler will also indicate where the consuming use occurred.Non-copyable types are a powerful new featurefor systems level programming in Swift.They're still at an early point in their evolution.Later versions of Swift will expand on non-copyable types in generic code.If you're interested in following along with this work,it's being actively discussed on the Swift forums.Doug: A key to Swift's success has been its interoperability with Objective-C.From the start, developers have been ableto take incremental steps towards Swift adoption in their existing code bases,mixing in Swift a single file or module at a time.But we know a lot of you don't just have code written in Objective-C.Many apps also have core business logic implemented in C++,and interfacing to that has not been so easy.Often it meant adding an extra manual bridging layer, going from Swift,through Objective-C, and then into C++, and all the way back.Swift 5.9 introduces the ability to interact with C++ typesand functions directly from Swift.C++ interoperability works just like Objective-C interoperability always has,mapping C++ APIs into their Swift equivalentsthat you can use directly from Swift code.C++ is a large language with its own notions of ideaslike classes, methods, containers, and so on.The Swift compiler understands common C++ idioms,so many types can be used directly.For example, this Person type defines the five special member functionsexpected of a C++ value type: Copy and move constructors,assignment operators, and a destructor.The Swift compiler treats this as a value typeand will automatically call the right special member function at the right time.Additionally, C++ containers like vectors and mapsare accessible as Swift collections.The result of all of this is that we can write straightforward Swift codethat makes direct use of C++ functions and types.We can filter over the vector of Person instances,calling C++ member functions and accessing data members directly.In the other direction, using Swift code from C++is based on the same mechanism as with Objective-C.The Swift compiler will produce a "generated header"that contains a C++ view on the Swift APIs.However, unlike with Objective-C, you don't need to restrict yourselfto only using Swift classes annotated with the objc attribute.C++ can directly use most Swift types and their full APIs,including properties, methods, and initializers,without any bridging overhead.Here we can see how C++ can make use of our Point struct.After including the generated header,C++ can call Swift initializers to create Point instances,invoke mutating methods,and access both stored and computed properties,all without any change to the Swift code itself.Swift's C++ interoperability makes it easier than everto integrate Swift with existing C++ code bases.Many C++ idioms can be directly expressed in Swift,often automatically, but occasionally requiring some annotationsto indicate the desired semantics.And Swift APIs can be directly accessed from C++,no annotation or code changes required,making it possible to incrementally adopt Swift throughout a code baseusing any mix of C, C++, and Objective-C.C++ interoperability is an evolving story,guided by the C++ interoperability workgroup.For more information, please see the "Mix Swift and C++" talk,or join us in the discussion on the Swift forums.Interoperability at the language level is really important,but you also have to be able to build your code.And having to replace your existing build system with Xcodeor the Swift Package Manager to even get started with Swiftcan be just as big a barrier as rewriting a large amount of code.That's why we worked with the CMake communityto improve Swift support in CMake.You can integrate Swift code into your CMake build by declaring Swiftas one of the languages for the project and putting Swift files into a target.More importantly, you can mix C++ and Swift within a single target,and CMake will be sure to compile each separatelyand link all of the appropriate supporting libraries and runtimesfor both languages.This means you can start adopting Swift in your cross-platform C++ projects today,file by file or target by target.We're also providing a sample repositorywith CMake projects containing Swift and mixed C++/Swift targets,including using the bridging and generated headers,to help you get started.A few years ago, we introduced a new concurrency modelinto Swift based on the building blocks of async/await,structured concurrency, and actors.Swift's concurrency model is an abstract model,which can be adapted to different environments and libraries.The abstract model has two main pieces: Tasks and actors.Tasks represent a sequential unit of work that can conceptually run anywhere.Tasks can be suspended whenever there's an "await" in the program,and then resume once the task can continue.Actors are a synchronization mechanismthat provide mutually-exclusive access to isolated state.Entering an actor from the outside requires an "await"because it may suspend the task.Tasks and actors are integrated into the abstract language model,but within that model, they can be implemented in different waysto fit different environments.Tasks are executed on the global concurrent pool.How that global concurrent pool decides to schedule work is up to the environment.For Apple's platforms, the Dispatch library providesoptimized scheduling for the whole operating system,and has been extensively tuned for each platform.In more restrictive environments,the overhead of a multithreaded scheduler may not be acceptable.There Swift's concurrency model is implementedwith a single-threaded cooperative queue.The same Swift code works in both environmentsbecause the abstract model is flexible enough to mapto diverse runtime environments.Additionally, interoperability with callback-based librarieswas built into Swift's async/await support from the beginning.The withCheckedContinuation operations allow one to suspend a task,and then resume it later in response to a callback.This enables integration with existing librariesthat manage tasks themselves.The standard implementation of actors in the Swift concurrency runtimeis a lock-free queue of tasks to execute on the actor,but it's not the only possible implementation.In a more restricted environment, one might not have atomics,and instead could use another concurrency primitive such as spinlocks.If that environment were single-threaded, no synchronization is needed,but the actor model maintains the abstract concurrency modelfor the program regardless.You could still take that same code to another environmentthat is multi-threaded.With Swift 5.9, custom actor executors allowa particular actor to implement its own synchronization mechanism.This makes actors more flexible and adaptable to existing environments.Let's take an example.Here we consider an actor that manages a database connection.Swift ensures mutually-exclusive access to the storage of this actor,so there won't be any concurrent access to the database.However, what if you need more control over the specific wayin which synchronization is done?For example, what if you want to use a specific dispatch queuefor your database connection, perhaps because that queue is sharedwith other code that hasn't adopted actors?With custom actor executors, you can.Here we've added a serial dispatch queue to our actorand an implementation of the unowned executor propertythat produces the executor corresponding to that dispatch queue.With this change, all of the synchronizationfor our actor instances will happen through that queue.When you "await" on the call to pruneOldEntries from outside the actor,this will now perform a dispatch-async on the corresponding queue.This gives you more control over how individual actorsprovide synchronization, and even lets you synchronize an actorwith other code that isn't using actors yet,perhaps because it's written in Objective-C or C++.The synchronization of actors via dispatch queues is made possiblebecause dispatch queue conforms to the new SerialExecutor protocol.You can provide your own synchronization mechanism to use with actorsby defining a new type that conforms to this protocolwhich has only few core operations:Checking whether the code is already executing in the context of the executor.For example, are we running on the main thread?Extracting an unowned reference to the executor to allow access to itwithout excess reference-counting traffic.And the most core operation, enqueue,which takes ownership of an executor "job."A job is part of an asynchronous task that needsto run synchronously on the executor.At the point where enqueue is called, it's the responsibilityof the executor to run that job at some pointwhen there's no other code running on the serial executor.For example, enqueue for a dispatch queue would call dispatch async on that queue.Swift Concurrency has been in use for a few years now,and its abstract model consisting of tasks and actorscovers a large range of concurrent programming tasks.The abstract model itself is quite flexible,making it adaptable to different execution environments,from iPhones to Apple Watches, to servers and beyond.It also allowed customization at key points to enable it to interoperatewith code that hasn't fully adopted Swift Concurrency yet.For more information, please see our "Behind the Scenes" talk,as well as "Beyond the basics of Structured Concurrency."I want to wrap up with a bit of a case study of Swift operatingin an environment very different from the iOS or MacOS appswhere we are used to seeing it.FoundationDB is a distributed database, providing a scalable solutionfor very large key-value stores running on commodity hardwareand supporting a variety of platforms, including MacOS, Linux, and Windows.FoundationDB is an open-source project with a large code base written in C++.The code is heavily asynchronous,with its own form of distributed actors and runtimethat provides a critically important deterministic simulation environmentfor testing purposes.FoundationDB was looking to modernize their code baseand found Swift to be a good match for its performance,safety, and code clarity.A complete rewrite would be a big, risky endeavor.Instead, we leveraged Swift's interoperabilityto integrate into the existing code base.For example, here's a part of the C++ implementationof FoundationDB's "master data" actor.There's a lot going on here,and you don't need to understand all of this C++.However, I'd like to point out a few key aspects of the code.First, C++ doesn't have async/await,so FoundationDB has their own preprocessor-like approachto emulate it.Like many C++ code bases,they've implemented their own C++ Future typeto manage asynchronous tasks.These pair with explicit messagingto send responses to the requests.Note the careful pairing of sendinga reply with returning from the function.Finally, FoundationDB hasits own reference-counted smart pointersto help manage memory automatically.We can implement this whole thingmuch more cleanly in Swift.That's better.This function can be directly implemented as an async function in Swift.We have a normal return type and normal return statementsto provide the response to this request, so you can't ever be out of sync.We have an "await" to indicate the suspension pointin the same manner as all other Swift async code.And this Swift code ties in with the C++ Future typeadapted using continuations.We're using a number of C++ types here.The MasterData type in C++ was using a reference-counted smart pointer.By annotating the type in C++, the Swift compiler can usethis type like any other class,automatically managing reference counts for us.Other types, such as the request and reply types,are C++ value types being used directly in Swift.And the interoperability goes both ways.This asynchronous function,and indeed, all the work introduced by the Swift concurrency model,run on FoundationDB's existing deterministic runtime.So we can get the benefits of Swift where we want it,interfacing with the existing C++ to enable gradual adoption throughout.In this session, we've covered a lot of ground.We described features like parameter packsand macros that enable more expressive APIsand can help you write better code faster.We talked about the use of Swift in performance-sensitive codeand the introduction of non-copyable typesto provide resource management without reference-counting overhead.Then we dove into C++ interoperability,which provides support for using C++ APIs in Swift and vice-versa,making it easier to bring the benefits of Swift to more of your code.Finally, we talked about how Swift's flexible concurrency modelcan adapt to myriad environmentsacross devices and languages to make concurrency easier and safer.Parameter packs, macros, non-copyable types,and all of the other language enhancements in Swift 5.9 were designedand developed openly through the Swift Evolution process,and community feedback was crucial in shaping these features.Swift 5.9 is the culmination of countless contributionsfrom members across the Swift community, including active design discussions,bug reports, pull requests, educational content, and more.Thank you for making Swift 5.9 the great release it is.♪ ♪

♪ ♪Ben: Hi, and welcome to "What's New in Swift 5.9."I'm Ben, and together with my colleague Doug,we'll take you through some of the improvementsto the Swift language this year.We'll talk about some ways it's easier to express what you meanusing Swift's clean syntax, some powerful new featuresthat help framework authors make their new APIs more natural to use,and we'll look at some new ways to get more control over performanceand safety in low-level code.

But let's start by talking about the Swift open source project.This is a great update for Swift, and it couldn't have happenedwithout the Swift community,the contributors and users of the languagewho gather at swift.org, working together to evolve the languageand support new initiatives.Swift follows an open process for language evolution.New features or significant behavior changes are proposedand reviewed in the open on the Swift forums.If you want to follow along, you can find a dashboardof all the language proposals on the Swift website.

A year ago, we saw a significant restructuringof the Swift Project governance.The core team announced the formation of the Language Steering Group,which took on primary responsibility for oversight of the Swift languageand standard library evolution.Since then, the language group has overseen40 new language proposals,and we're going to talk about several of them today.

But sometimes, individual language proposalscome together as part of a wider theme,like the addition of Swift concurrency,which was introduced through ten separate proposals.

For cases like this, the language steering grouphas introduced a new way of tying together these proposals,through vision documents.These documents lay out a proposal for larger changes to the language.The first one to be accepted by the language steering groupwas a vision of Swift macros, a new feature in Swift 5.9that we'll be covering later in this talk.

Of course, evolution of the language is only partof the work of the Swift community.A successful language needs much more than this.It needs great tooling, robust support for multiple platforms,and rich documentation.To oversee progress in this area, the core team is creatingan ecosystem steering group parallel to the language steering group.This new structure was recently laid out in a blog post on Swift.org,a look out for further announcementsabout the formation of this new group soon.Now let's talk about changes to the Swift language this year,starting with better ways to express yourself in your code.Swift 5.9 includes whatis probably our most commonly requested language enhancement,allowing if/else and switch statements to be used as expressions,providing a nice way to clean up your code.

For example, if you wanted to initialize a let variablebased on some complex condition, you had to resort to tricks,like this hard-to-read compound ternary expression.

If expressions let you instead use a much more familiarand readable chain of if statements.

Another place where this helpsis if you're initializing a global variable or a stored property.Single expressions work fine here, but if you wanted a condition,you had to use the trick of wrapping it in a closurethat you then immediately executed.

Now that an if statement can be an expression,you can just drop that clutter, leaving you with neater code.

Result builders, the declarative syntax that drives features like SwiftUI,have seen significant improvements this year,including optimized type checking performance,code completion, and improved error messages.

This improvement was particularly focused on invalid code.Previously, result builder code with errors would take a long time to fail,as the type checker explored the many possible invalid paths.

As of Swift 5.8, invalid code type checks much faster,and error messages on invalid code are now more precise.For example, previously, some invalid code could leadto misleading errors in a completely different part of the result builder.In Swift 5.7, you'd receive an error like this,when the mistake actually lies up here.

In the latest release, you now receivea more accurate compiler diagnostic identifying the real issue.

Next, let's talk about how an addition to the generics systemwill allow for some great improvements to frameworks you use every day.

Almost all the Swift you write is using generics in some way.Type inference enables using these types without needingto understand the advanced capabilities they're built with.For example, the standard library Array type uses genericsto provide an array that works with any type of datathat you might want to store.When you use an array, all you need to do is provide the elements.There's no need to specify an explicit argument for the element typebecause it can be inferred from the element values.

Swift's generics system enables natural APIsthat preserve type informationso that your code operates seamlessly on the concrete types that you provide.

Here's an example inspired by the Swift compiler's own codebase:An API that takes a request typeand evaluates it to produce a strongly typed value.So you can make a request for a Boolean valueand get back a Boolean result.

Now, some APIs want to abstract not only over concrete types,but also the number of arguments that you pass in.So a function might take one request and return one resultor two requests and return two results, or three and return three results.

To support this, the generics system has to be usedtogether with a mechanism to handle multiple argument lengthsso that all of the types that you pass in are linked to the types that you get out.

Before Swift 5.9, the only way to accomplish this patternwas by adding an overload for each specific argument lengththe API supported.But this approach has limitations.It forces an artificial upper boundon the number of arguments you can pass,resulting in compiler errorsif you pass too many.

In this case, there isn't an overload that can handlemore than six arguments, but we've passed seven.

This overloading pattern and its limitations are pervasiveacross APIs that conceptually handle arbitrary argument length.

In Swift 5.9, the generics system is gaining first-class supportfor this API pattern by enabling generic abstraction over argument length.This is done with a new language conceptthat can represent multiple individual type parametersthat are "packed" together.This new concept is called a type parameter pack.

Using parameter packs,APIs that currently have individual overloadsfor each fixed argument lengthcan be collapsed down into a single function.

Instead of accepting a single type parameter, Result,representing the result type of a single request,the evaluate function now accepts a separate request over each Result type.

The function returns each result instance in parenthesis,which will either be a single value or a tuple containing each value.

The evaluate function now handles all argument lengths with no artificial limit.

Type inference makes APIs using parameter packs natural to usewithout needing to know that the API is using them.

Calling our new evaluate functionthat can now handle any number of arguments,looks just like calling the fixed-length overloads.Swift infers the type of each argument along with the total numberbased on how you're calling the function.To learn about how to write generic library APIs like these,check out Generalize APIs using parameter packs.

Calling generic APIs in a natural way demonstrates oneof Swift's fundamental design goals, clear expression through concise code.

Swift's advanced language features enable beautiful APIsthat make it easier to say what you mean.

You benefit from these advanced language featuresfrom the very first lines of Swift that you ever write,whether it's using generics through arrays or dictionariesor designing a UI in SwiftUI.Swift's embrace of progressive disclosure means that you can learnabout the more advanced features when you're ready to.

Swift 5.9 takes this design approach to the next levelby providing library authors with a new toolboxfor expressive API design using a new macro system.Here's Doug to tell you more.Doug: With macros, you can extend the capabilities of the language itself,eliminating boilerplate and unlocking more of Swift's expressive power.Let's consider the ever-present assert function,which checks whether a condition is true.Assert will stop the program if the condition is false,but when that happens, you get very little informationabout what went wrong, just the file and line number.You'll need to add some logging or trap the program in the debugger to learn more.There have been attempts to improve on this.XCTest provides an assert-equal operation that takes the two values separately,so when things fail, you can at least see the two values that aren't equal.But we still don't know which value is wrong here.Was it a, b, or the result of max?And this approach really doesn't scale for all of the kinds of checkswe perform in asserts.If we go back to the original assertion, there is so much information herein the source code that we'd like to see in the log when our assertion fails.What was the code?What are the values of a, and b, and c?What did max produce?We couldn't improve this in Swift before without some custom feature,but macros make it possible.

In this example, the "hash-assert" syntax is expanding the macro called "assert."The hash syntax might look familiarbecause Swift already has a few things with this same spelling,like hash-file, hash-selector, and hash-warning.The assert macro looks and feels like the function version,but because it's a macro, it can provide a richer experiencewhen the assertion fails.

Now the program is showing the code for the failing assertion,along with each of the values that contributed to the result.

In Swift, macros are APIs, just like types or functions,so you access them by importing the module that defines them.Like many other APIs, macros are distributed as packages.The assert macro here comes from the power asserts library,an open-source Swift package available on GitHub.

If you were to look into the macro package,you would find a macro declaration for assert.It is introduced with the "macro" keyword,but otherwise, it looks a lot like a function.There's a single unlabeled Bool parameterfor the condition to be checked.If this macro produced a value,that result type would be writtenwith the usual arrow syntax.Uses of the macro will be type checkedagainst the parameters.That means, if you were to make a mistakein using the macro,such as forgetting to comparethe maximum value against something,you'll get a useful error messageimmediately,before the macro is ever expanded.This allows Swift to providea great development experiencewhen using macros because macros operateon well-typed inputs and produce codethat augments your programin predictable ways.Most macros are definedas "external macros,"specifying the module and type for a macro implementation via strings.The external macro types are defined in separate programsthat act as compiler plugins.The Swift compiler passes the source codefor the use of the macro to the plugin.The plugin produces new source code,which is then integrated back into the Swift program.Here, the macro is expanding the assertion into codethat captures the individual valuesand where they should be displayed in the source code.You wouldn't want to write the boilerplate yourself,but the macro does it for you.Macro declarations have one additional piece of information, their role.The assert macro here is a freestanding expression macro.It is called freestanding because it uses the "hash" syntaxand operates directly on that syntax to produce new code.It is an expression macro because it can be used anywherethat one can produce a value.The new Foundation Predicate APIs provide a great example of an expression macro.The predicate macro allows one to write predicatesin a type-safe manner using closures.The resulting predicate values can then be used with a number of other APIs,including the Swift collection operations SwiftUI and SwiftData.

The macro itself is genericover the set of input types.It accepts a closure argumentthat's a function operating on valuesof those input types and producesa Boolean result,does the set of inputs match or not?And the macro returns an instanceof the new Predicate type,which can be used elsewherein the program.

But there is more to macros because a lot of the boilerplatewe end up writing is because we need to augment codewe have written with something else derived from it.Let's take an example.I find that I use enums a lot in my own code,like this Path enum that captures either relative or absolute paths.But I'll often find myself needing to check for a specific case,say, by filtering all absolute paths from a collection.I can write this isAbsolute check as a computed property, of course.But sooner or later, I'm going to have to write another one.This is getting a bit tedious.

Macros can help here by generating the boilerplate for us.

Case detection is an attached macro,written using the same custom-attribute syntax as property wrappers.Attached macros take as input the syntax of the declaration they apply to--here it's the enum declaration itself-- and will generate new code.

This macro-expanded code is normal Swift code,which the compiler integrates into your program.You can inspect the macro-generated code in your editor, debug into it,copy it out if you want to customize it further, and so on.

Attached macros are classified into five different rolesbased on how they augment the declaration they are attached to.The case detection macro we just discussed is a "member" attached macro,meaning that it creates new members in a type or extension.

Peer macros add new declarations alongside the declaration they're attached to,for example, to create a completion-handler versionof an async method or vice-versa.

Accessor macros can turn a stored property into a computed property,which can be used to perform specific actions on property accessor abstract the actual storage in a manner similar to,but more flexible than property wrappers.And attached macros can introduce attributesonto specific members of a type, as well as add new protocol conformances.

Several attached macro roles can be composed togetherto achieve useful effects.One important example of this is with observation.

Observation has always been a part of SwiftUI.To be able to observe changes to the properties of a class,one need only make the type conform to ObservableObject,and mark every property at-Published,and use the ObservedObject property wrapper in your view.

That's a bunch of steps, and missing a step can meanthat the UI doesn't update as expected.We can do better with macro-based observation.

Attaching the Observable macro to a class provides observationfor all of its stored properties.There is no need to annotate each stored propertyor worry about what happens if you don'tbecause the Observable macro handles it all.

The Observable macro works through composition of three macro roles.Let's dive into how these roles work together.

Each macro role corresponds to a specific wayin which the Person class is augmented by the Observable macro.The member role introduces new properties and methods.

The member attribute role will add the @ObservationTracked macroto the stored properties of the observed class,which in turn expands to getters and setters to trigger observation events.Finally, the conformance role introduces the conformanceto the Observable protocol.

This may look like a lot of code, but it's all just normal Swift code,and it's neatly folded away behind the Observable macro.

Whenever you need to see how any macro expandsto better understand its effect on your program,it's right there at your fingertips in Xcode.

Use the "Expand Macro" actionto see the macro-expanded source code in your editor.Any error messages within macro-generated codewill automatically show the expanded code,and you can step into and out of it with your debugger.

Swift macros provide a new tool for enabling more expressive APIsand eliminating boilerplate from your Swift code,helping unlock Swift's expressive power.Macros type-check their inputs, produce normal Swift code,and integrate at defined points in your program,so their effects are easy to reason about.And any time you need to understand what a macro did,its expanded source code is right there in your editor.We've just scratched the surface of macros."Expand on Swift macros" will go deep into the design of Swift macrosto answer all of those questions you must have.And you can get hands-on implementing your own macroswith "Write Swift macros."I can't wait to see what new macros the Swift community will build.

Ben: From the start, Swift was designed to be a scalable language.

Swift's design emphasizes expressivity with clear and concise codethat is low on ceremony and easy to read and write.By leveraging Swift's powerful features,like generics and native concurrency support,frameworks like SwiftUI or SwiftDatalet you quickly achieve the results you want,leaving you more time to focus on what matters.

Despite these high-level capabilities though,Swift is also efficient.It compiles natively, and its use of value typesand of reference counting instead of garbage collection meansit's able to achieve a low memory footprint.

This scalability means we're able to push Swift to more placesthan was previously possible with Objective-C,to low-level systems, where previously you might expectto have to use C or C++.This means bringing Swift's clearer code and critical safety guaranteesto more places.We recently open sourced the start of a rewriteof the Foundation framework in Swift.This initiative will lead to a single shared implementationof Foundation on both Apple and non-Apple platforms.But it also meant rewriting large amounts of Objective-C and C code in Swift.

As of MacOS Sonoma and iOS 17, there are new Swift-backed implementationsof essential types like Date and Calendar,of formatting and internationalization essentialslike Locale and AttributedString,and a new Swift implementation of JSON encoding and decoding.And the performance wins have been significant.

Calendar's ability to calculate important dates can take better advantageof Swift's value semantics to avoid intermediate allocations,resulting in over a 20% improvement in some benchmarks.

Date formatting using FormatStyle also gainedsome major performance upgrades, showing a massive 150% improvementin a benchmark of formatting with a standard date and time template.

Even more exciting are the improvements to JSON decoding in the new package.Foundation has a brand-new Swift implementationfor JSONDecoder and JSONEncoder, eliminating costly roundtripsto and from the Objective-C collection types.The tight integration of parsing JSON in Swift for initializing Codable typesimproves performance too.In benchmarks parsing test data, the new implementationis between two and five times faster.These improvements came from both reducing the bridging costfrom the old Objective-C implementation to Swift,but also by the new Swift-based implementations being faster.

Let's look at one benchmark as an example.In Ventura, calling enumerateDates from Objective-C was slightly fasterthan calling it from Swift because of bridging costs.In MacOS Sonoma,calling that same functionality from Swift is 20% faster.Some of that speed up comes from eliminating bridging costs,but the new function implementation itself is also faster,as seen when calling it from Objective-C.This particular date calculation is not overly complex,so this is a great way of seeing the reductionin overhead between the two languages.Now, sometimes, when you're operating at lower levelsof the system, you need more fine-grained controlto achieve a necessary level of performance.Swift 5.9 introduces some new opt-in capabilitiesthat help you achieve this level of control.These capabilities focus on the concept of ownership, that is,what part of the code "owns" a value as it passes around your application.

To see when you might want to use these features,let's first look at some example code.

Here we have a very simple wrapper for a file descriptorthat would allow us to give low-level system calls a nicer Swift interface.But there’s still some easy ways to make mistakes with this API.For example, you might try to write to the file after you’ve called close.And you have to be careful to always close it manuallyby calling the close method before the type goes out of scope.Otherwise, you would get a resource leak.

One solution would be to make it a classwith a deinit that closes it automatically when the type goes out of scope.

But that has different downsides,like making an additional memory allocation,which is usually not a big problem,except in some very constrained systems contexts.

Classes also have reference semantics.You might unintentionally end up sharing a file descriptor type across threads,leading to race conditions, or store it unintentionally.

But let's go back and look at the struct version.

Really, this struct also behaves like a reference type.It holds an integer that references the true value,which is an open file.Making a copy of this type could also lead to unintentional sharingof mutable state across your app in ways that could lead to bugs.What you want is to suppress the ability to make a copy of this struct.

Swift types, whether structs or classes, are copyable by default.This is the right choice most of the time.While excessive unnecessary copies can sometimes be a bottleneck in your code,it's better to spend the time finding those bottlenecksin instruments occasionally than to be constantly botheredby the compiler requiring you to be explicit about those copies.

But sometimes that implicit copy isn't what you want--in particular,when making copies of a value might lead to correctness issues,like with our file descriptor wrapper.In Swift 5.9, you can do that with this new syntax that can be appliedto struct and enum declarationsand that suppresses the implicit ability to copy a type.Once a type is non-copyable, you can give it a deinit,like you can a class,that will run when a value of the type goes out of scope.

Non-copyable types can also be used to solve the problem of calling close,and then using other methods.

The close operation can be marked as consuming.Calling a consuming method or argument gives up ownershipof a value to the method you called.Since our type is not copyable,giving up ownership means you can no longer use the value.

By default, methods in Swift borrow their arguments, including self.So you can call the write method, which borrows the file descriptor,uses it to write out to the buffer, and after that,ownership of the value returns to the caller,and you can call another method, like close.

But since close has been marked as consuming,not the default of borrowing, it must be its final use.

This means, if you close the file first and then attempt to call another method,like write, you'll get an error message at compile time,rather than a runtime failure.The compiler will also indicate where the consuming use occurred.

Non-copyable types are a powerful new featurefor systems level programming in Swift.They're still at an early point in their evolution.Later versions of Swift will expand on non-copyable types in generic code.

If you're interested in following along with this work,it's being actively discussed on the Swift forums.Doug: A key to Swift's success has been its interoperability with Objective-C.From the start, developers have been ableto take incremental steps towards Swift adoption in their existing code bases,mixing in Swift a single file or module at a time.But we know a lot of you don't just have code written in Objective-C.Many apps also have core business logic implemented in C++,and interfacing to that has not been so easy.Often it meant adding an extra manual bridging layer, going from Swift,through Objective-C, and then into C++, and all the way back.Swift 5.9 introduces the ability to interact with C++ typesand functions directly from Swift.C++ interoperability works just like Objective-C interoperability always has,mapping C++ APIs into their Swift equivalentsthat you can use directly from Swift code.

C++ is a large language with its own notions of ideaslike classes, methods, containers, and so on.The Swift compiler understands common C++ idioms,so many types can be used directly.For example, this Person type defines the five special member functionsexpected of a C++ value type: Copy and move constructors,assignment operators, and a destructor.The Swift compiler treats this as a value typeand will automatically call the right special member function at the right time.Additionally, C++ containers like vectors and mapsare accessible as Swift collections.

The result of all of this is that we can write straightforward Swift codethat makes direct use of C++ functions and types.We can filter over the vector of Person instances,calling C++ member functions and accessing data members directly.

In the other direction, using Swift code from C++is based on the same mechanism as with Objective-C.The Swift compiler will produce a "generated header"that contains a C++ view on the Swift APIs.However, unlike with Objective-C, you don't need to restrict yourselfto only using Swift classes annotated with the objc attribute.C++ can directly use most Swift types and their full APIs,including properties, methods, and initializers,without any bridging overhead.

Here we can see how C++ can make use of our Point struct.After including the generated header,C++ can call Swift initializers to create Point instances,invoke mutating methods,and access both stored and computed properties,all without any change to the Swift code itself.

Swift's C++ interoperability makes it easier than everto integrate Swift with existing C++ code bases.Many C++ idioms can be directly expressed in Swift,often automatically, but occasionally requiring some annotationsto indicate the desired semantics.And Swift APIs can be directly accessed from C++,no annotation or code changes required,making it possible to incrementally adopt Swift throughout a code baseusing any mix of C, C++, and Objective-C.

C++ interoperability is an evolving story,guided by the C++ interoperability workgroup.For more information, please see the "Mix Swift and C++" talk,or join us in the discussion on the Swift forums.

Interoperability at the language level is really important,but you also have to be able to build your code.And having to replace your existing build system with Xcodeor the Swift Package Manager to even get started with Swiftcan be just as big a barrier as rewriting a large amount of code.

That's why we worked with the CMake communityto improve Swift support in CMake.You can integrate Swift code into your CMake build by declaring Swiftas one of the languages for the project and putting Swift files into a target.

More importantly, you can mix C++ and Swift within a single target,and CMake will be sure to compile each separatelyand link all of the appropriate supporting libraries and runtimesfor both languages.This means you can start adopting Swift in your cross-platform C++ projects today,file by file or target by target.We're also providing a sample repositorywith CMake projects containing Swift and mixed C++/Swift targets,including using the bridging and generated headers,to help you get started.

A few years ago, we introduced a new concurrency modelinto Swift based on the building blocks of async/await,structured concurrency, and actors.Swift's concurrency model is an abstract model,which can be adapted to different environments and libraries.The abstract model has two main pieces: Tasks and actors.Tasks represent a sequential unit of work that can conceptually run anywhere.Tasks can be suspended whenever there's an "await" in the program,and then resume once the task can continue.

Actors are a synchronization mechanismthat provide mutually-exclusive access to isolated state.Entering an actor from the outside requires an "await"because it may suspend the task.

Tasks and actors are integrated into the abstract language model,but within that model, they can be implemented in different waysto fit different environments.Tasks are executed on the global concurrent pool.How that global concurrent pool decides to schedule work is up to the environment.For Apple's platforms, the Dispatch library providesoptimized scheduling for the whole operating system,and has been extensively tuned for each platform.In more restrictive environments,the overhead of a multithreaded scheduler may not be acceptable.There Swift's concurrency model is implementedwith a single-threaded cooperative queue.The same Swift code works in both environmentsbecause the abstract model is flexible enough to mapto diverse runtime environments.

Additionally, interoperability with callback-based librarieswas built into Swift's async/await support from the beginning.The withCheckedContinuation operations allow one to suspend a task,and then resume it later in response to a callback.This enables integration with existing librariesthat manage tasks themselves.

The standard implementation of actors in the Swift concurrency runtimeis a lock-free queue of tasks to execute on the actor,but it's not the only possible implementation.In a more restricted environment, one might not have atomics,and instead could use another concurrency primitive such as spinlocks.If that environment were single-threaded, no synchronization is needed,but the actor model maintains the abstract concurrency modelfor the program regardless.You could still take that same code to another environmentthat is multi-threaded.With Swift 5.9, custom actor executors allowa particular actor to implement its own synchronization mechanism.This makes actors more flexible and adaptable to existing environments.Let's take an example.

Here we consider an actor that manages a database connection.Swift ensures mutually-exclusive access to the storage of this actor,so there won't be any concurrent access to the database.However, what if you need more control over the specific wayin which synchronization is done?For example, what if you want to use a specific dispatch queuefor your database connection, perhaps because that queue is sharedwith other code that hasn't adopted actors?With custom actor executors, you can.

Here we've added a serial dispatch queue to our actorand an implementation of the unowned executor propertythat produces the executor corresponding to that dispatch queue.With this change, all of the synchronizationfor our actor instances will happen through that queue.

When you "await" on the call to pruneOldEntries from outside the actor,this will now perform a dispatch-async on the corresponding queue.This gives you more control over how individual actorsprovide synchronization, and even lets you synchronize an actorwith other code that isn't using actors yet,perhaps because it's written in Objective-C or C++.

The synchronization of actors via dispatch queues is made possiblebecause dispatch queue conforms to the new SerialExecutor protocol.You can provide your own synchronization mechanism to use with actorsby defining a new type that conforms to this protocolwhich has only few core operations:Checking whether the code is already executing in the context of the executor.For example, are we running on the main thread?Extracting an unowned reference to the executor to allow access to itwithout excess reference-counting traffic.And the most core operation, enqueue,which takes ownership of an executor "job."A job is part of an asynchronous task that needsto run synchronously on the executor.At the point where enqueue is called, it's the responsibilityof the executor to run that job at some pointwhen there's no other code running on the serial executor.For example, enqueue for a dispatch queue would call dispatch async on that queue.

Swift Concurrency has been in use for a few years now,and its abstract model consisting of tasks and actorscovers a large range of concurrent programming tasks.The abstract model itself is quite flexible,making it adaptable to different execution environments,from iPhones to Apple Watches, to servers and beyond.It also allowed customization at key points to enable it to interoperatewith code that hasn't fully adopted Swift Concurrency yet.For more information, please see our "Behind the Scenes" talk,as well as "Beyond the basics of Structured Concurrency."I want to wrap up with a bit of a case study of Swift operatingin an environment very different from the iOS or MacOS appswhere we are used to seeing it.FoundationDB is a distributed database, providing a scalable solutionfor very large key-value stores running on commodity hardwareand supporting a variety of platforms, including MacOS, Linux, and Windows.

FoundationDB is an open-source project with a large code base written in C++.The code is heavily asynchronous,with its own form of distributed actors and runtimethat provides a critically important deterministic simulation environmentfor testing purposes.FoundationDB was looking to modernize their code baseand found Swift to be a good match for its performance,safety, and code clarity.A complete rewrite would be a big, risky endeavor.Instead, we leveraged Swift's interoperabilityto integrate into the existing code base.For example, here's a part of the C++ implementationof FoundationDB's "master data" actor.

There's a lot going on here,and you don't need to understand all of this C++.However, I'd like to point out a few key aspects of the code.First, C++ doesn't have async/await,so FoundationDB has their own preprocessor-like approachto emulate it.

Like many C++ code bases,they've implemented their own C++ Future typeto manage asynchronous tasks.

These pair with explicit messagingto send responses to the requests.Note the careful pairing of sendinga reply with returning from the function.Finally, FoundationDB hasits own reference-counted smart pointersto help manage memory automatically.We can implement this whole thingmuch more cleanly in Swift.

That's better.This function can be directly implemented as an async function in Swift.We have a normal return type and normal return statementsto provide the response to this request, so you can't ever be out of sync.We have an "await" to indicate the suspension pointin the same manner as all other Swift async code.And this Swift code ties in with the C++ Future typeadapted using continuations.

We're using a number of C++ types here.The MasterData type in C++ was using a reference-counted smart pointer.By annotating the type in C++, the Swift compiler can usethis type like any other class,automatically managing reference counts for us.

Other types, such as the request and reply types,are C++ value types being used directly in Swift.And the interoperability goes both ways.This asynchronous function,and indeed, all the work introduced by the Swift concurrency model,run on FoundationDB's existing deterministic runtime.So we can get the benefits of Swift where we want it,interfacing with the existing C++ to enable gradual adoption throughout.

In this session, we've covered a lot of ground.We described features like parameter packsand macros that enable more expressive APIsand can help you write better code faster.We talked about the use of Swift in performance-sensitive codeand the introduction of non-copyable typesto provide resource management without reference-counting overhead.

Then we dove into C++ interoperability,which provides support for using C++ APIs in Swift and vice-versa,making it easier to bring the benefits of Swift to more of your code.

Finally, we talked about how Swift's flexible concurrency modelcan adapt to myriad environmentsacross devices and languages to make concurrency easier and safer.Parameter packs, macros, non-copyable types,and all of the other language enhancements in Swift 5.9 were designedand developed openly through the Swift Evolution process,and community feedback was crucial in shaping these features.Swift 5.9 is the culmination of countless contributionsfrom members across the Swift community, including active design discussions,bug reports, pull requests, educational content, and more.Thank you for making Swift 5.9 the great release it is.♪ ♪

3:06 -Hard-to-read compound ternary expression

3:19 -Familiar and readable chain of if statements

3:30 -Initializing a global variable or stored property

3:46 -In 5.9, if statements can be an expression

4:31 -In Swift 5.7, errors may appear in a different place

4:47 -In Swift 5.9, you now receive a more accurate compiler diagnostic

5:47 -An API that takes a request type and evaluates it to produce a strongly typed value

6:03 -APIs that abstract over concrete types and varying number of arguments

6:35 -Writing multiple overloads for the evaluate function

6:47 -Overloads create an arbitrary upper bound for the number of arguments

7:12 -Individual type parameter

7:36 -Collapsing the same set of overloads into one single evaluate function

8:21 -Calling updated evaluate function looks identical to calling an overload

10:01 -It isn't clear why an assert function fails

10:20 -XCTest provides an assert-equal operation

11:02 -Assert as a macro

11:42 -Macros are distributed as packages

12:07 -Macro declaration for assert

12:26 -Uses are type checked against the parameters

12:52 -A macro definition

13:11 -Swift compiler passes the source code for the use of the macro

13:14 -Compiler plugin produces new source code, which is integrated back into the Swift program

13:33 -Macro declarations include roles

13:53 -New Foundation Predicate APIs uses a `@freestanding(expression)` macro role

14:14 -Predicate expression macro

14:48 -Example of a commonly used enum

15:01 -Checking a specific case, like when filtering all absolute paths

15:09 -Write an `isAbsolute` check as a computer property...

15:12 -...And another for `isRelative`

15:17 -Augmenting the enum with an attached macro

15:36 -Macro-expanded code is normal Swift code

16:57 -Observation in SwiftUI prior to 5.9

17:25 -Observation now

17:42 -Observable macro works with 3 macro roles

17:52 -Unexpanded macro

18:05 -Expanded member attribute role

18:12 -Member attribute role adds `@ObservationTracked` to stored properties

18:16 -The @ObservationTracked macro adds getters and setters to stored properties

18:33 -All that Swift code is folded away in the @Observable macro

23:59 -A wrapper for a file descriptor

24:30 -The same FileDescriptor wrapper as a class

25:05 -Going back to the struct

26:06 -Using Copyable in the FileDescriptor struct

26:35 -`close()` can also be marked as consuming

26:53 -When `close()` is called, it must be the final use

27:20 -Compiler errors instead of runtime failures

28:52 -Using C++ from Swift

29:51 -Using Swift from C++

35:30 -An actor that manages a database connection

35:58 -MyConnection with a serial dispatch queue and a custom executor

36:44 -Dispatch queues conform to SerialExecutor protocol

39:22 -C++ implementation of FoundationDB's "master data" actor

40:18 -Swift implementation of FoundationDB's "master data" actor

## Code Samples

```swift
let
 bullet 
=

    isRoot 
&&
 (count 
==
 
0
 
||
 
!
willExpand) 
?
 
""

        : count 
==
 
0
    
?
 
"- "

        : maxDepth 
<=
 
0
 
?
 
"▹ "
 : 
"▿ "
```

```swift
let
 bullet 
=

    
if
 isRoot 
&&
 (count 
==
 
0
 
||
 
!
willExpand) { 
""
 }
    
else
 
if
 count 
==
 
0
 { 
"- "
 }
    
else
 
if
 maxDepth 
<=
 
0
 { 
"▹ "
 }
    
else
 { 
"▿ "
 }
```

```swift
let
 attributedName 
=
 
AttributedString
(markdown: displayName)
```

```swift
let
 attributedName 
=
 
				
if
 
let
 displayName, 
!
displayName.isEmpty {
            
AttributedString
(markdown: displayName)
        } 
else
 {
            
"Untitled"

        }
```

```swift
struct
 
ContentView
: 
View
 {
    
enum
 
Destination
 { 
case
 one, two }

    
var
 body: 
some
 
View
 {
        
List
 {
            
NavigationLink
(value: .one) { 
// The issue actually occurs here

                
Text
(
"one"
)
            }
            
NavigationLink
(value: .two) {
                
Text
(
"two"
)
            }
        }.navigationDestination(for: 
Destination
.
self
) {
            
$0
.view 
// Error occurs here in 5.7

        }
    }
}
```

```swift
struct
 
ContentView
: 
View
 {
    
enum
 
Destination
 { 
case
 one, two }

    
var
 body: 
some
 
View
 {
        
List
 {
            
NavigationLink
(value: .one) { 
//In 5.9, Errors provide a more accurate diagnostic

                
Text
(
"one"
)
            }
            
NavigationLink
(value: .two) {
                
Text
(
"two"
)
            }
        }.navigationDestination(for: 
Destination
.
self
) {
            
$0
.view 
// Error occurs here in 5.7

        }
    }
}
```

```swift
struct
 
Request
<
Result
> { 
...
 }


struct
 
RequestEvaluator
 {
    
func
 
evaluate
<
Result
>(
_
 
request
: 
Request
<
Result
>) -> 
Result

}


func
 
evaluate
(
_
 
request
: 
Request
<
Bool
>) -> 
Bool
 {
    
return
 
RequestEvaluator
().evaluate(request)
}
```

```swift
let
 value 
=
 
RequestEvaluator
().evaluate(request)


let
 (x, y) 
=
 
RequestEvaluator
().evaluate(r1, r2)


let
 (x, y, z) 
=
 
RequestEvaluator
().evaluate(r1, r2, r3)
```

```swift
func
 
evaluate
<
Result
>(
_
:) -> (
Result
)


func
 
evaluate
<
R1
, 
R2
>(
_
:
_
:) -> (
R1
, 
R2
)


func
 
evaluate
<
R1
, 
R2
, 
R3
>(
_
:
_
:
_
:) -> (
R1
, 
R2
, 
R3
)


func
 
evaluate
<
R1
, 
R2
, 
R3
, 
R4
>(
_
:
_
:
_
:
_
:)-> (
R1
, 
R2
, 
R3
, 
R4
)


func
 
evaluate
<
R1
, 
R2
, 
R3
, 
R4
, 
R5
>(
_
:
_
:
_
:
_
:
_
:) -> (
R1
, 
R2
, 
R3
, 
R4
, 
R5
)


func
 
evaluate
<
R1
, 
R2
, 
R3
, 
R4
, 
R5
, 
R6
>(
_
:
_
:
_
:
_
:
_
:
_
:) -> (
R1
, 
R2
, 
R3
, 
R4
, 
R5
, 
R6
)
```

```swift
//This will cause a compiler error "Extra argument in call"


let
 results 
=
 evaluator.evaluate(r1, r2, r3, r4, r5, r6, r7)
```

```swift
<
each 
Result
>
```

```swift
func
 
evaluate
<each 
Result
>(
_
: 
repeat
 
Request
<each 
Result
>) -> (
repeat
 each 
Result
)
```

```swift
struct
 
Request
<
Result
> { 
...
 }


struct
 
RequestEvaluator
 {
    
func
 
evaluate
<each 
Result
>(
_
: 
repeat
 
Request
<each 
Result
>) -> (
repeat
 each 
Result
)
}


let
 results 
=
 
RequestEvaluator
.evaluate(r1, r2, r3)
```

```swift
assert
(
max
(a, b) 
==
 c)
```

```swift
XCAssertEqual
(
max
(a, b), c) 
//XCTAssertEqual failed: ("10") is not equal to ("17")
```

```swift
#
assert
(
max
(a, b) 
==
 c)
```

```swift
import
 PowerAssert
#
assert
(
max
(a, b) 
==
 c)
```

```swift
public
 macro 
assert
(
_
 condition: 
Bool
)
```

```swift
import
 PowerAssert
#
assert
(
max
(a, b)) 
//Type 'Int' cannot be a used as a boolean; test for '!= 0' instead
```

```swift
public
 macro 
assert
(
_
 condition: 
Bool
) 
=
 #externalMacro(
    module: “
PowerAssertPlugin
”,
    type: “
PowerAssertMacro
"
)
```

```swift
#
assert
(a 
==
 b)
```

```swift
PowerAssert
.
Assertion
(
    
"#assert(a == b)"

) {
    
$0
.capture(a, column: 
8
) 
==
 
$0
.capture(b, column: 
13
)
}
```

```swift
// Freestanding macro roles



@freestanding
(expression)

public
 macro 
assert
(
_
 condition: 
Bool
) 
=
 #externalMacro(
    module: “
PowerAssertPlugin
”,
    type: “
PowerAssertMacro
"
)
```

```swift
let
 pred 
=
 #
Predicate
<
Person
> {
    
$0
.favoriteColor 
==
 .blue
}


let
 blueLovers 
=
 people.filter(pred)
```

```swift
// Predicate expression macro



@freestanding
(expression) 

public
 macro 
Predicate
<each 
Input
>(
    
_
 body: (
repeat
 each 
Input
) -> 
Bool

) -> 
Predicate
<
repeat
 each 
Input
>
```

```swift
enum
 
Path
 {
    
case
 relative(
String
)
    
case
 absolute(
String
)
}
```

```swift
let
 absPaths 
=
 paths.filter { 
$0
.isAbsolute }
```

```swift
extension
 
Path
 {
    
var
 isAbsolute: 
Bool
 {
        
if
 
case
 .absolute 
=
 
self
 { 
true
 }
        
else
 { 
false
 }
    }
}
```

```swift
extension
 
Path
 {
    
var
 isRelative: 
Bool
 {
        
if
 
case
 .relative 
=
 
self
 { 
true
 }
        
else
 { 
false
 }
    }
}
```

```swift
@CaseDetection


enum
 
Path
 {
    
case
 relative(
String
)
    
case
 absolute(
String
)
}


let
 absPaths 
=
 paths.filter { 
$0
.isAbsolute }
```

```swift
enum
 
Path
 {
    
case
 relative(
String
)
    
case
 absolute(
String
)
  
    
//Expanded @CaseDetection macro integrated into the program.

    
var
 isAbsolute: 
Bool
 {
        
if
 
case
 .absolute 
=
 
self
 { 
true
 }
        
else
 { 
false
 }
    }

    
var
 isRelative: 
Bool
 {
        
if
 
case
 .relative 
=
 
self
 { 
true
 }
        
else
 { 
false
 }
    }
}
```

```swift
// Observation in SwiftUI



final
 
class
 
Person
: 
ObservableObject
 {
    
@Published
 
var
 name: 
String

    
@Published
 
var
 age: 
Int

    
@Published
 
var
 isFavorite: 
Bool

}


struct
 
ContentView
: 
View
 {
    
@ObservedObject
 
var
 person: 
Person

    
    
var
 body: 
some
 
View
 {
        
Text
(
"Hello, 
\(person.name)
"
)
    }
}
```

```swift
// Observation in SwiftUI



@Observable
 
final
 
class
 
Person
 {
    
var
 name: 
String

    
var
 age: 
Int

    
var
 isFavorite: 
Bool

}


struct
 
ContentView
: 
View
 {
    
var
 person: 
Person

    
    
var
 body: 
some
 
View
 {
        
Text
(
"Hello, 
\(person.name)
"
)
    }
}
```

```swift
@attached
(member, names: 
...
)

@attached
(memberAttribute)

@attached
(conformance)

public
 macro 
Observable
() 
=
 #externalMacro(
...
).
```

```swift
@Observable
 
final
 
class
 
Person
 {
    
var
 name: 
String

    
var
 age: 
Int

    
var
 isFavorite: 
Bool

}
```

```swift
@Observable
 
final
 
class
 
Person
 {
    
var
 name: 
String

    
var
 age: 
Int

    
var
 isFavorite: 
Bool

  
		
internal
 
let
 
_
$observationRegistrar
 
=
 
ObservationRegistrar
<
Person
>()
    
internal
 
func
 
access
<
Member
>(
        
keyPath
: 
KeyPath
<
Person
, 
Member
>
    ) {
        
_
$observationRegistrar
.access(
self
, keyPath: keyPath)
    }
    
internal
 
func
 
withMutation
<
Member
, 
T
>(
        
keyPath
: 
KeyPath
<
Person
, 
Member
>,
        
_
 
mutation
: () 
throws
 -> 
T

    ) 
rethrows
 -> 
T
 {
        
try
 
_
$observationRegistrar
.withMutation(of: 
self
, keyPath: keyPath, mutation)
    }
}
```

```swift
@Observable
 
final
 
class
 
Person
 {
    
@ObservationTracked
 
var
 name: 
String

    
@ObservationTracked
 
var
 age: 
Int

    
@ObservationTracked
 
var
 isFavorite: 
Bool

  
		
internal
 
let
 
_
$observationRegistrar
 
=
 
ObservationRegistrar
<
Person
>()
    
internal
 
func
 
access
<
Member
>(
        
keyPath
: 
KeyPath
<
Person
, 
Member
>
    ) {
        
_
$observationRegistrar
.access(
self
, keyPath: keyPath)
    }
    
internal
 
func
 
withMutation
<
Member
, 
T
>(
        
keyPath
: 
KeyPath
<
Person
, 
Member
>,
        
_
 
mutation
: () 
throws
 -> 
T

    ) 
rethrows
 -> 
T
 {
        
try
 
_
$observationRegistrar
.withMutation(of: 
self
, keyPath: keyPath, mutation)
    }
}
```

```swift
@Observable
 
final
 
class
 
Person
 {
    
@ObservationTracked
 
var
 name: 
String
 { 
get
 { 
…
 } 
set
 { 
…
 } }
    
@ObservationTracked
 
var
 age: 
Int
 { 
get
 { 
…
 } 
set
 { 
…
 } }
    
@ObservationTracked
 
var
 isFavorite: 
Bool
 { 
get
 { 
…
 } 
set
 { 
…
 } }
  
		
internal
 
let
 
_
$observationRegistrar
 
=
 
ObservationRegistrar
<
Person
>()
    
internal
 
func
 
access
<
Member
>(
        
keyPath
: 
KeyPath
<
Person
, 
Member
>
    ) {
        
_
$observationRegistrar
.access(
self
, keyPath: keyPath)
    }
    
internal
 
func
 
withMutation
<
Member
, 
T
>(
        
keyPath
: 
KeyPath
<
Person
, 
Member
>,
        
_
 
mutation
: () 
throws
 -> 
T

    ) 
rethrows
 -> 
T
 {
        
try
 
_
$observationRegistrar
.withMutation(of: 
self
, keyPath: keyPath, mutation)
    }
}
```

```swift
struct
 
FileDescriptor
 {
    
private
 
var
 fd: 
CInt

  
    
init
(
descriptor
: 
CInt
) { 
self
.fd 
=
 descriptor }

    
func
 
write
(
buffer
: [
UInt8
]) 
throws
 {
        
let
 written 
=
 buffer.withUnsafeBufferPointer {
            
Darwin
.write(fd, 
$0
.baseAddress, 
$0
.count)
        }
        
// ...

    }
  
    
func
 
close
() {
        
Darwin
.close(fd)
    }
}
```

```swift
class
 
FileDescriptor
 {
    
private
 
var
 fd: 
CInt

  
    
init
(
descriptor
: 
CInt
) { 
self
.fd 
=
 descriptor }

    
func
 
write
(
buffer
: [
UInt8
]) 
throws
 {
        
let
 written 
=
 buffer.withUnsafeBufferPointer {
            
Darwin
.write(fd, 
$0
.baseAddress, 
$0
.count)
        }
        
// ...

    }
  
    
func
 
close
() {
        
Darwin
.close(fd)
    }
    
deinit
 {
        
self
.close(fd)
    }
}
```

```swift
struct
 
FileDescriptor
: ~
Copyable
 {
    
private
 
var
 fd: 
CInt

  
    
init
(
descriptor
: 
CInt
) { 
self
.fd 
=
 descriptor }

    
func
 
write
(
buffer
: [
UInt8
]) 
throws
 {
        
let
 written 
=
 buffer.withUnsafeBufferPointer {
            
Darwin
.write(fd, 
$0
.baseAddress, 
$0
.count)
        }
        
// ...

    }
  
    
func
 
close
() {
        
Darwin
.close(fd)
    }
  
    
deinit
 {
        
Darwin
.close(fd)
    }
}
```

```swift
struct
 
FileDescriptor
 {
    
private
 
var
 fd: 
CInt

  
    
init
(
descriptor
: 
CInt
) { 
self
.fd 
=
 descriptor }

    
func
 
write
(
buffer
: [
UInt8
]) 
throws
 {
        
let
 written 
=
 buffer.withUnsafeBufferPointer {
            
Darwin
.write(fd, 
$0
.baseAddress, 
$0
.count)
        }
        
// ...

    }
  
    consuming 
func
 
close
() {
        
Darwin
.close(fd)
    }
  
    
deinit
 {
        
Darwin
.close(fd)
    }
}
```

```swift
let
 file 
=
 
FileDescriptor
(fd: descriptor)
file.write(buffer: data)
file.close()
```

```swift
let
 file 
=
 
FileDescriptor
(fd: descriptor)
file.close() 
// Compiler will indicate where the consuming use is

file.write(buffer: data) 
// Compiler error: 'file' used after consuming
```

```swift
// Person.h


struct
 
Person
 {
    
Person
(const 
Person
 
&
);
    
Person
(
Person
 
&&
);
    
Person
 
&
operator
=
(const 
Person
 
&
);
    
Person
 
&
operator
=
(
Person
 
&&
);
    
~
Person
();
  
    std::string name;
    unsigned getAge() const;
};
std::vector
<
Person
>
 everyone();


// Client.swift


func
 
greetAdults
() {
    
for
 person 
in
 everyone().filter { 
$0
.getAge() 
>=
 
18
 } {
        
print
(
"Hello, 
\(person.name)
!"
)
    }
}
```

```swift
// Geometry.swift


struct
 
LabeledPoint
 {
    var x = 
0.0
, y = 
0.0

    var label: String = “origin”
    mutating func 
moveBy
(x deltaX: Double, y deltaY: Double) { … }
    var magnitude: Double { … }
}


// C++ client


#
include
 
<Geometry-Swift.h>



void
 
test
() {
    Point origin = 
Point
()
    Point unit = Point::
init
(
1.0
, 
1.0
, “unit”)
    unit.
moveBy
(
2
, 
-2
)
    std::cout << unit.label << “ moved to “ << unit.
magnitude
() << std::endl;
}
```

```swift
// Custom actor executors



actor
 
MyConnection
 {
    
private
 
var
 database: 
UnsafeMutablePointer
<sqlite3>
  
    
init
(
filename
: 
String
) 
throws
 { 
…
 }
  
    
func
 
pruneOldEntries
() { 
…
 }
    
func
 
fetchEntry
<
Entry
>(
named
: 
String
, 
type
: 
Entry
.
Type
) -> 
Entry
? { 
…
 }
}


await
 connection.pruneOldEntries()
```

```swift
actor
 
MyConnection
 {
  
private
 
var
 database: 
UnsafeMutablePointer
<sqlite3>
  
private
 
let
 queue: 
DispatchSerialQueue

  
  
nonisolated
 
var
 unownedExecutor: 
UnownedSerialExecutor
 { queue.asUnownedSerialExecutor() }

  
init
(
filename
: 
String
, 
queue
: 
DispatchSerialQueue
) 
throws
 { 
…
 }
  
  
func
 
pruneOldEntries
() { 
…
 }
  
func
 
fetchEntry
<
Entry
>(
named
: 
String
, 
type
: 
Entry
.
Type
) -> 
Entry
? { 
…
 }
}


await
 connection.pruneOldEntries()
```

```swift
// Executor protocols



protocol
 
Executor
: 
AnyObject
, 
Sendable
 {
    
func
 
enqueue
(
_
 
job
: consuming 
ExecutorJob
)
}


protocol
 
SerialExecutor
: 
Executor
 {
    
func
 
asUnownedSerialExecutor
() -> 
UnownedSerialExecutor

    
func
 
isSameExclusiveExecutionContext
(
other
 
executor
: 
Self
) -> 
Bool

}


extension
 
DispatchSerialQueue
: 
SerialExecutor
 { 
…
 }
```

```swift
// C++ implementation of FoundationDB’s “master data” actor



ACTOR Future<Void> 
getVersion
(Reference<MasterData> self, GetCommitVersionRequest req)
 
{
  	state std::map<UID, CommitProxyVersionReplies>::iterator proxyItr = self->lastCommitProxyVersionReplies.
find
(req.requestingProxy);
  	++self->getCommitVersionRequests;

  	
if
 (proxyItr == self->lastCommitProxyVersionReplies.
end
()) {
      	req.reply.
send
(
Never
());
    	  
return
 
Void
();
  	}
  	
wait
(proxyItr->second.latestRequestNum.
whenAtLeast
(req.requestNum - 
1
));
  
  	
auto
 itr = proxyItr->second.replies.
find
(req.requestNum);
  	
if
 (itr != proxyItr->second.replies.
end
()) {
    		req.reply.
send
(itr->second);
    		
return
 
Void
();
  	}

  	
// ...

}
```

```swift
// Swift implementation of FoundationDB’s “master data” actor


func
 
getVersion
(
    
myself
: 
MasterData
, 
req
: 
GetCommitVersionRequest

) 
async
 -> 
GetCommitVersionReply
? {
    myself.getCommitVersionRequests 
+=
 
1


    
guard
 
let
 lastVersionReplies 
=
 lastCommitProxyVersionReplies[req.requestingProxy] 
else
 {
        
return
 
nil

    }

    
// ...

    
var
 latestRequestNum 
=
 
try
 
await
 lastVersionReplies.latestRequestNum
          .atLeast(
VersionMetricHandle
.
ValueType
(req.requestNum 
-
 
UInt64
(
1
)))

    
if
 
let
 lastReply 
=
 lastVersionReplies.replies[req.requestNum] {
        
return
 lastReply
    }
}
```


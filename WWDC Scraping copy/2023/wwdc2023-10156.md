# Wwdc2023 10156

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Explore SwiftUI animationExplore SwiftUI's powerful animation capabilities and find out how these features work together to produce impressive visual effects. Learn how SwiftUI refreshes the rendering of a view, determines what to animate, interpolates values over time, and propagates context for the current transaction.Chapters1:03 -Anatomy of an update6:40 -Animatable11:36 -Animation20:00 -TransactionResourcesHD VideoSD VideoRelated VideosWWDC23Animate with springsDemystify SwiftUI performanceMeet MapKit for SwiftUIWhat’s new in SwiftUIWind your way through advanced animations in SwiftUI

Explore SwiftUI's powerful animation capabilities and find out how these features work together to produce impressive visual effects. Learn how SwiftUI refreshes the rendering of a view, determines what to animate, interpolates values over time, and propagates context for the current transaction.

1:03 -Anatomy of an update

6:40 -Animatable

11:36 -Animation

20:00 -Transaction

HD VideoSD Video

HD Video

SD Video

Animate with springs

Demystify SwiftUI performance

Meet MapKit for SwiftUI

What’s new in SwiftUI

Wind your way through advanced animations in SwiftUI

Search this video…♪ ♪Kyle: Hi, I'm Kyle a member of the SwiftUI team.Animation is a key component of modern app design.When tastefully applied, it can bring both clarity and life to your UI.Making it simple to add animation to your appwas one of our core motivations when we began developing SwiftUI.It's a big reason why SwiftUI is shaped the way that it is.This session is an overview of SwiftUI's powerful animation capabilitiesand how they work together to produce impressive visual effects.I'll cover how SwiftUI refreshes the rendering of a view,determines what to animate using Animatable,interpolates values over time using Animation,and propagates context for the current update using Transaction.In recent years, there's been debate among my colleaguesabout who makes the best furry-- or not so furry--companion.We were curious if we could come to a consensus,so we made an app to take a poll.There's a button to cast a vote for each pet.When you tap, the vote count changes,and the avatars slide around to reflect the current standings.In the last poll, as is proper, cats came in first place,but only narrowly.The stakes are too high to leave this next poll purely to chance,so I'm adding a new feature.On tap, the avatar of my choice will scale upin order to nudge people towards voting for the proper pet.And I can tap again to scale it back down.This is already working pretty well,but it would be way better with an animation.Before adding that, I'm gonna trace through how SwiftUIrefreshes the rendering of a view to give you a better understandingof the anatomy of a view update.For this exercise, I'm gonna focus on the pet avatar view in isolation.SwiftUI tracks a view's dependencies, like this selected state variable.When an event, like a tap, comes in, an update transaction is opened.If any of its dependencies change, the view is invalidated,and at the close of the transaction, the framework calls bodyto produce a new value in order to refresh the rendering.This view's body is composed of a tap gesture,a scale effect, and an image.Behind the scenes, SwiftUI maintains a long-lived dependency graphthat manages the lifetime of views and their data.Each node in this graph, called an attribute,maps to a fine-grained piece of the UI.When the selected state changed to true,the value of each of these downstream attributes became stale.They're refreshed by unwrapping the new view value one layer at a time.Once the corresponding graph attributes have been updated,the view's body value is discarded.Finally, the graph emits drawing commands on your behalf to update the rendering.I'll zoom in on just the graph in order to visualize the lifetime of an attribute.An attribute is born with an initial value.An event comes in, and an update transaction opens.An upstream dependency changes.The framework calls body.The attribute's value is updated.The transaction closes.And in this way, the current value of each attribute in the graph evolves over time.So that's the anatomy of a view update.Now I'll add an animation.If I wrap withAnimation around my state change,when the tap gesture closure fires,the animation is set for the transaction.Then selected is toggled,and the downstream attributes are invalidated.As before, body is calledto provide new attribute values.And here's where it gets interesting.scaleEffect is a special attribute,an "animatable attribute."When the value of an animatable attribute changes,it checks if an animation is set for the transaction.If so, it makes a copy and uses the animation to interpolatefrom the old value to the new valueas time passes.I'll zoom in on the scaleEffect animatable attributeto examine how this plays out.The first thing to notice is that animatable attributesconceptually have both model and presentation values.Right now they're the same.Then an event comes in, and a transaction is opened,this time with an animation.State is changed,and body is called to refresh the stale attribute values.Because the value has changed, the attribute makes a local copyof the animation to calculate the current presentation value.SwiftUI knows when the attribute graph contains running animationsand will call into the appropriate animatable attributesto produce the next frame.For built-in animatable attributes like scaleEffect,SwiftUI is very efficient.It's able to do this work off the main threadand without calling into any of your view code.Here's the animation in action.Nice.When someone uses the word "animation," they're probably referringto the overall visual experience of the way a view changes over time.What I've covered so far is that, in SwiftUI,there are two orthogonal aspectscontributing to the overall visual experience.Animatable attributes, like scaleEffect, determine the data being animated,while the Animation determines how that data changes over time.I'll dive deeper into each of these in turn,starting with Animatable, which determines what to animate.SwiftUI builds an animatable attribute for any view conformingto the Animatable protocol.The only requirement is that the view define a readwrite vectorof the data it wants to animate.The data must conform to VectorArithmetic.VectorArithmetic matches the textbook definitionof a vector from your math class.It supports vector additionand scalar multiplication.If you're rusty or not familiar with vectors,don't be discouraged.A vector is basically just a fixed-length list of numbers,and for SwiftUI animation, the purpose of dealing in vectorsis mostly just to abstract over the length of that list.For example, CGFloat and Double are one-dimensional vectors,while CGPoint and CGSize define two-dimensional vectors,and CGRect defines a four-dimensional vector.By dealing in vectors, SwiftUI is able to animate allof these types and more with a single generic implementation.So far, for the sake of simplicity, I've represented scaleEffectas if it were a one-dimensional scale factor.The Animatable conformance for a one-dimensional scaleEffectwould be straightforward.Its animatableData would just be a CGFloat.In reality, scaleEffect allows you to independently configurethe width, height, and relative anchor pointof the transformation--all animatable.So scaleEffect actually defines a four-dimensional vectorfor its animatable data,a CGSize for the width and height scale,paired with a UnitPoint for the relative anchor.AnimatablePair fuses the two vectors together into a single, larger vector.It's a public type, and you can use it too.It might come in handy if you're conforming oneof your own views to Animatable.scaleEffect is just one of the many animatable visual effectsthat come built into SwiftUI, so the vast majority of the time,Animatable is not an API you'll need to use directly.In rare circumstances, though, an advanced use case may callfor conforming one of your own views to Animatable.Consider the pet Podium view, which distributes its subviewsalong the arc of a circle using a custom RadialLayout.By default, changing the offset angle within an animationanimates the pet avatars to their new positions along a straight line.Notice how the pets are taking a shortcutand trespassing on the interior of the circle?That's not what I want.Instead, I want my avatars to animate along the perimeter of the circle.I can get this effect by conforming Podium to animatableand using the offset angle as its animatable data.Why does this result in such a different effect?To explain, I'll step through an animated updatefor each version of the Podium view, starting with the default behavior,which animates the avatars along a straight line.Podium's body is composed of a RadialLayout and three avatars.When a transaction opens,if the offset angle has changed,body is called to refresh the stale downstream attribute values.Then layout is run, updating the position of each subview.So this is what an animated update is likein the default version.The active animatable datais the view position CGPoint,which interpolates in a cartesian coordinate space,meaning each avatar moves along a straight line.In the custom version,when I conform Podium to Animatable,what changes is that bodybecomes the active animatable attribute,with the offset angleas its animatable data.How does this result in each avatarmoving along an arc?In this custom version,for every frame of the animation,body is going to be calledby SwiftUI with a new offset angle,and the layout will be rerun.This is super powerful, and sometimes,like when you're animating custom layout or drawing code,it might be the only way to achieve the effect you're going for.Just keep in mindthat a custom Animatable conformancecan be much more expensive to animatethan a built-in effect because it'llrun body for every frame of the animation.So only use this tool if you can'tachieve the effect you're going forusing the built-in effects.Next, I'll cover Animation,the generic algorithms that interpolate animatable data over time.Earlier, I added an animation to the pet avatar viewby wrapping the state change in withAnimation.You can customize this by passing an explicit animation,like a bouncy spring.SwiftUI comes with a ton of powerful animations built in.They can roughly be categorized into three buckets:Timing curve animations, Spring animations,and Higher order animations, which modify a base animation.Timing curve animations are likely the categoryof animation you're most familiar with.For example, easeInOut is a timing curve animation.All timing curve animations take a curve,which defines the speed of the animation, and a duration.A timing curve can be created using bezier control points.By adjusting the start and end control points,you change the initial and final velocity of the animation.The UnitCurve type can be used standaloneto calculate the value and the velocityat a relative point between 0 and 1.SwiftUI comes with a number of built-in timing curve presets:Linear,easeIn,easeOut,and easeInOut.All timing curve animations can also specify a custom duration.The next category of animation, Springs, determine the valueat a given point in time by running a spring simulation.You may be familiar with traditional ways of specifying a spring,for example, mass, stiffness, and damping.But we've never found these ways to be particularly intuitive,so we invented a new way.You just specify the perceived duration of the animationand how bouncy you want the spring to be.It's much more approachable.Similar to UnitCurve, the Spring type can be used standaloneto calculate the value and the velocity of a spring at a given time.SwiftUI comes with three built-in spring presets:Smooth, which has no bounce,snappy, which has a small amount of bounce,and bouncy, which has a larger amount of bounce.If you're uncomfortable parameterizing a spring animation,these presets are a reliable way to get something that feels good.Each preset can be also tuned to adjust the duration or tweak the bounciness.We highly recommend using spring animationsbecause they give your UI an organic feelby preserving velocity and naturally coming to rest.In fact, we feel so strongly about the benefits of spring animationsthat we made a smooth spring the new default when you usea bare withAnimation in iOS 17 and aligned releases.The last category of animations, Higher order, modify a base animation.They can slow it down or speed it up.They can add a delay before the base animation starts.And they can repeat a base animation any number of times,optionally toggling between playing forwards and playing in reverse.And now we're introducing an entirely new category of animation:Custom animations.The CustomAnimation protocol gives you accessto the same low-level generic entry points we use to implement all the animationsthat come built into SwiftUI.The CustomAnimation protocol has three requirements:animate, shouldMerge, and velocity.I'll start by focusing on animate.shouldMerge and velocity are optional requirements.I'll get back to them later.Animate is passed the vector to animate towards,the amount of time that has elapsed since the animation began,and the context, which includes additional animation state.Animate returns the current value of the animation,or nil if the animation has finished.Where does this value vector come from?It comes from a view's animatable data.In the pet avatar view, that's the scale effect.Recall that scaleEffect's animatable data is a four-dimensional vector,including a two-dimensional width and height scale.When the avatar is selected, it's animated to a scale factorof 1.5 by 1.5 from a scale factor of 1 by 1.Vector addition and scalar multiplication operations allow SwiftUI to subtractthese two vectors from one another to calculate the delta between them.This delta is actually what's being animated.This means, in practice, the animation runningin the scaleEffect animatable attribute isn't interpolating from 1 to 1.5,but from 0 to 0.5.Among other things, this makes it more convenientto implement the animate method.Let me show you.I'm going to implement a linear timing curve animationconfigured by a duration to interpolate over.Recall that animate is passed the delta vector to animate towards.I can use scalar multiplication to scale the vector by the proportionof the duration that has elapsed.And once the full duration has elapsed, I'll return nil to indicatethat the animation has finished and can be removed.That's it.And because this implementation is generic,it works with animatable data of any number of dimensions.So that's how Animatable and Animation work togetherto produce the impressive visual effects that appear in your UI.Next, I'll return to CustomAnimation's two optional requirements:shouldMerge and velocity.What are they for?Imagine for a moment that you're the scaleEffect animatable attribute.The user taps down, a transaction opens,your value changes, you make a local copy of the animation,and you start happily animating your delta vector.Everything is going great.That is, until the pesky user taps again before the animation has finished.What do you do?You set up a new animation,and you call shouldMerge on it.The default implementation returns false--this is what timing curve animations do--in which case both animations will be run together,and their results will be combined by the system.This is another reason why SwiftUI animationsdeal in terms of delta vectors.It makes it easy to calculate the correct combined presentation valuewhen multiple animations are running.But what if I'd chosen a spring animation,not a timing curve animation?Spring animations override shouldMerge to return trueand incorporate the state of the previous animation.This allows them to preserve velocity and retarget to the new value,which can feel more natural than combining additively,like timing curve animations.And that's what this final velocity requirement is for.Implementing it allows velocity to be preserved when a running animationis merged with a new one.So I'll finish off my linear timing curve animationby adding an implementation for velocity.I've used the term "transaction" throughout this talk to refer to the setof work that's performed for a given update to the UI.In SwiftUI code, Transaction also refers to a related,powerful data-flow construct and family of APIs.You may already be familiar with Environment and Preferences,dictionaries SwiftUI implicitly passesdown and up the view hierarchy, respectively.Transaction is similar.It's a dictionary SwiftUI uses to implicitly propagate all the contextfor the current update, most notably the animation.My explanation earlierof how an animatable attributereads the current animationwas a little vague.So I'm gonna trace through another animated update of the avatar view.This time, I'll be more specific.When the tap gesture closure fires,withAnimation sets an animation in the root transaction dictionary.Body is called to update the attribute values.The transaction dictionary is propagated across the attribute graph.When it reaches an animatable attribute,the attribute checks if an animation is set.And if so, it makes a copy to drive its presentation value.The Transaction is only relevant for a specific update,so once the stale attributes have been refreshed, it's discarded.Flowing the animation down the view hierarchywithin the transaction dictionary makes possible a number of powerful APIsfor controlling when and how animations apply to your views.Right now, the pet avatar view can only be selected via tap.I'll change the selected State variable to a Binding.That way, it can be also be selected programmatically.But how do I animate a programmatic change to a view property?I can use the transaction modifierto access the animationas it flows down the view hierarchyinside the transaction dictionary.If I set an animationfrom within this modifier,then whenever body is called,even if there is no animationor a different animationin the transaction,the attribute will override the animation.And when it reaches the scale effect,this animation will be usedto interpolate the scale factor.Pretty cool.But there's a problem with this pattern.Indiscriminately overriding the animationfor all descendantswhenever SwiftUI refreshes a viewcan lead to accidental animations.Instead, for uses cases like this,SwiftUI provides an animation view modifier.It takes an additional value argument,which allows you to scope the effectmuch more precisely.It will only write the animationinto the transactionif the value has changed.Now that that's hooked up,this withAnimation isn't accomplishing anything,so we can remove it.The animation view modifier is also a powerful tool for situationswhere you want to apply different animations to different parts of a view.For example, the pet avatar has a shadow, which I've omitted thus farfrom the example for the sake of simplicity.The shadow radius increases when the avatar is selectedto accentuate the illusion that it's elevated above the background.After playing with it, I've decided I want the shadow's animationto be more subdued than the scale effect's.To accomplish this, I can insert another animation view modifierbetween the scaleEffect and the shadow.Now the transaction picks up the bouncy springfor animating the scale effect.And it picks up the more subtle smooth springfor animating the shadow radius.Because animation modifiers are only activewhen their value has changed,the odds of an accidental animation are greatly reduced.But if the avatar's image had just happened to changein the same transaction as selected,it would have inherited the shadow's smooth spring animationfor its content transition.This is a point worth lingering on.This animation view modifier works well for leaf componentswhere the entire sub-hierarchy is under your control.But for non-leaf components, which contain arbitrary child content,it's much more likely for an accidental animation to occur.For example, if I want to reuse my avatarin another app that has nothing to do with pets,I could make it more generic by accepting arbitrary child content.In this scenario, I have less of a guaranteethat when selected changes,the child content won't also have changed.This could result in an accidental animation.Whoops.Good news.We have a new version of the animation view modifierspecifically designed for use cases like this.It narrowly scopes the animation to the animatable attributesspecified in its body closure.Here's how it works.Imagine there's no animation in the transaction.When the transaction reaches the animation view modifier's attribute,a copy is made that's populated with the specified animation.The copy is propagated downstream,but only to the scoped animatable attributes.Once it's done its job, the copy is discarded,and the original transaction picks up where it left off.So when the transaction reaches the child content,because the original transaction is unaffected by anyof the intermediate animation view modifiers,there's no risk of accidental animations.A limited set of transaction APIs have been availablesince the first version of SwiftUI.Now we're introducing the capability to define custom transaction keys,so you can leverage the transaction dictionaryto implicitly propagate your own update-specific data.If you've ever declared a custom environment key,declaring a custom transaction key will be familiar.The pattern is to create a unique type that conformsto the TransactionKey protocol.The only requirement is to provide a defaultValue.Then declare a computed property as an extension on Transactionthat reads and writes from the transaction dictionary using your key.Here, I've defined a boolean key to track whether,for the given update, the avatar was tapped or not.I'll decide which animation to use based on its value.If the avatar was selected interactively,I'll scale it up or down using a more lively spring.But if the avatar was selected programmatically,I'll scale it using a more subdued spring.I can set a value in the transaction dictionaryfor the given update by wrapping withTransaction around my state change.This should seem familiar.withAnimation is just a thin wrapper around withTransaction.The arguments passed to withTransaction are a keypathto a computed property on the Transaction and the value to set.Transaction is unique among SwiftUI's implicit data-flow constructsbecause it's discarded at the end of every update.This means, unless explicitly set for the current update,every value in the transaction dictionaryreverts to just being the default value for its key.In the avatar view, when the tap gesture closure fires,avatarTapped is set to true for the current update.The transaction also contains the default valuefor the animation key, which is nil.The transaction propagates across the view hierarchyuntil it reaches the transaction modifier.Here, the avatar view reads avatarTapped,and based on its value, sets the appropriate animation...Which propagates down the view hierarchy.This works pretty well, but just like earlier,it can result in accidental animations.To give you finer-grained control over modifying the transaction,we're introducing two new variants of the transaction modifier.One lets you scope using a value argument.And the other lets you scope to a sub-hierarchydefined in a body closure.These variants mirrorthe scoped animation view modifiers covered earlier.In this session, I explained SwiftUI's powerful animation primitives,Animatable, Animation, and Transaction.As a next step, I recommend checking out two related sessions."Animate with springs" provides more guidance on why and howto effectively use spring animations in your app.And "Wind your way through advanced animations in SwiftUI"introduces powerful new tools for constructing multi-step animations.I hope this content gives you a better understandingof how SwiftUI animation works and empowers youto more skillfully leverage animation in your app.Thanks.♪ ♪

♪ ♪Kyle: Hi, I'm Kyle a member of the SwiftUI team.Animation is a key component of modern app design.When tastefully applied, it can bring both clarity and life to your UI.Making it simple to add animation to your appwas one of our core motivations when we began developing SwiftUI.It's a big reason why SwiftUI is shaped the way that it is.This session is an overview of SwiftUI's powerful animation capabilitiesand how they work together to produce impressive visual effects.I'll cover how SwiftUI refreshes the rendering of a view,determines what to animate using Animatable,interpolates values over time using Animation,and propagates context for the current update using Transaction.

In recent years, there's been debate among my colleaguesabout who makes the best furry-- or not so furry--companion.

We were curious if we could come to a consensus,so we made an app to take a poll.

There's a button to cast a vote for each pet.When you tap, the vote count changes,and the avatars slide around to reflect the current standings.

In the last poll, as is proper, cats came in first place,but only narrowly.The stakes are too high to leave this next poll purely to chance,so I'm adding a new feature.On tap, the avatar of my choice will scale upin order to nudge people towards voting for the proper pet.And I can tap again to scale it back down.This is already working pretty well,but it would be way better with an animation.

Before adding that, I'm gonna trace through how SwiftUIrefreshes the rendering of a view to give you a better understandingof the anatomy of a view update.For this exercise, I'm gonna focus on the pet avatar view in isolation.

SwiftUI tracks a view's dependencies, like this selected state variable.When an event, like a tap, comes in, an update transaction is opened.

If any of its dependencies change, the view is invalidated,and at the close of the transaction, the framework calls bodyto produce a new value in order to refresh the rendering.

This view's body is composed of a tap gesture,a scale effect, and an image.

Behind the scenes, SwiftUI maintains a long-lived dependency graphthat manages the lifetime of views and their data.

Each node in this graph, called an attribute,maps to a fine-grained piece of the UI.When the selected state changed to true,the value of each of these downstream attributes became stale.They're refreshed by unwrapping the new view value one layer at a time.

Once the corresponding graph attributes have been updated,the view's body value is discarded.

Finally, the graph emits drawing commands on your behalf to update the rendering.

I'll zoom in on just the graph in order to visualize the lifetime of an attribute.

An attribute is born with an initial value.An event comes in, and an update transaction opens.An upstream dependency changes.The framework calls body.The attribute's value is updated.The transaction closes.And in this way, the current value of each attribute in the graph evolves over time.

So that's the anatomy of a view update.Now I'll add an animation.

If I wrap withAnimation around my state change,when the tap gesture closure fires,the animation is set for the transaction.Then selected is toggled,and the downstream attributes are invalidated.As before, body is calledto provide new attribute values.

And here's where it gets interesting.scaleEffect is a special attribute,an "animatable attribute."When the value of an animatable attribute changes,it checks if an animation is set for the transaction.

If so, it makes a copy and uses the animation to interpolatefrom the old value to the new valueas time passes.

I'll zoom in on the scaleEffect animatable attributeto examine how this plays out.The first thing to notice is that animatable attributesconceptually have both model and presentation values.Right now they're the same.Then an event comes in, and a transaction is opened,this time with an animation.State is changed,and body is called to refresh the stale attribute values.Because the value has changed, the attribute makes a local copyof the animation to calculate the current presentation value.

SwiftUI knows when the attribute graph contains running animationsand will call into the appropriate animatable attributesto produce the next frame.For built-in animatable attributes like scaleEffect,SwiftUI is very efficient.It's able to do this work off the main threadand without calling into any of your view code.

Here's the animation in action.

Nice.

When someone uses the word "animation," they're probably referringto the overall visual experience of the way a view changes over time.

What I've covered so far is that, in SwiftUI,there are two orthogonal aspectscontributing to the overall visual experience.Animatable attributes, like scaleEffect, determine the data being animated,while the Animation determines how that data changes over time.

I'll dive deeper into each of these in turn,starting with Animatable, which determines what to animate.SwiftUI builds an animatable attribute for any view conformingto the Animatable protocol.The only requirement is that the view define a readwrite vectorof the data it wants to animate.The data must conform to VectorArithmetic.

VectorArithmetic matches the textbook definitionof a vector from your math class.It supports vector additionand scalar multiplication.

If you're rusty or not familiar with vectors,don't be discouraged.A vector is basically just a fixed-length list of numbers,and for SwiftUI animation, the purpose of dealing in vectorsis mostly just to abstract over the length of that list.

For example, CGFloat and Double are one-dimensional vectors,while CGPoint and CGSize define two-dimensional vectors,and CGRect defines a four-dimensional vector.

By dealing in vectors, SwiftUI is able to animate allof these types and more with a single generic implementation.

So far, for the sake of simplicity, I've represented scaleEffectas if it were a one-dimensional scale factor.

The Animatable conformance for a one-dimensional scaleEffectwould be straightforward.Its animatableData would just be a CGFloat.

In reality, scaleEffect allows you to independently configurethe width, height, and relative anchor pointof the transformation--all animatable.So scaleEffect actually defines a four-dimensional vectorfor its animatable data,a CGSize for the width and height scale,paired with a UnitPoint for the relative anchor.

AnimatablePair fuses the two vectors together into a single, larger vector.It's a public type, and you can use it too.It might come in handy if you're conforming oneof your own views to Animatable.

scaleEffect is just one of the many animatable visual effectsthat come built into SwiftUI, so the vast majority of the time,Animatable is not an API you'll need to use directly.In rare circumstances, though, an advanced use case may callfor conforming one of your own views to Animatable.

Consider the pet Podium view, which distributes its subviewsalong the arc of a circle using a custom RadialLayout.By default, changing the offset angle within an animationanimates the pet avatars to their new positions along a straight line.Notice how the pets are taking a shortcutand trespassing on the interior of the circle?That's not what I want.

Instead, I want my avatars to animate along the perimeter of the circle.I can get this effect by conforming Podium to animatableand using the offset angle as its animatable data.

Why does this result in such a different effect?To explain, I'll step through an animated updatefor each version of the Podium view, starting with the default behavior,which animates the avatars along a straight line.

Podium's body is composed of a RadialLayout and three avatars.When a transaction opens,if the offset angle has changed,body is called to refresh the stale downstream attribute values.Then layout is run, updating the position of each subview.

So this is what an animated update is likein the default version.The active animatable datais the view position CGPoint,which interpolates in a cartesian coordinate space,meaning each avatar moves along a straight line.In the custom version,when I conform Podium to Animatable,what changes is that bodybecomes the active animatable attribute,with the offset angleas its animatable data.How does this result in each avatarmoving along an arc?In this custom version,for every frame of the animation,body is going to be calledby SwiftUI with a new offset angle,and the layout will be rerun.

This is super powerful, and sometimes,like when you're animating custom layout or drawing code,it might be the only way to achieve the effect you're going for.

Just keep in mindthat a custom Animatable conformancecan be much more expensive to animatethan a built-in effect because it'llrun body for every frame of the animation.So only use this tool if you can'tachieve the effect you're going forusing the built-in effects.

Next, I'll cover Animation,the generic algorithms that interpolate animatable data over time.

Earlier, I added an animation to the pet avatar viewby wrapping the state change in withAnimation.

You can customize this by passing an explicit animation,like a bouncy spring.

SwiftUI comes with a ton of powerful animations built in.They can roughly be categorized into three buckets:Timing curve animations, Spring animations,and Higher order animations, which modify a base animation.

Timing curve animations are likely the categoryof animation you're most familiar with.For example, easeInOut is a timing curve animation.

All timing curve animations take a curve,which defines the speed of the animation, and a duration.

A timing curve can be created using bezier control points.By adjusting the start and end control points,you change the initial and final velocity of the animation.

The UnitCurve type can be used standaloneto calculate the value and the velocityat a relative point between 0 and 1.

SwiftUI comes with a number of built-in timing curve presets:Linear,easeIn,easeOut,and easeInOut.

All timing curve animations can also specify a custom duration.

The next category of animation, Springs, determine the valueat a given point in time by running a spring simulation.

You may be familiar with traditional ways of specifying a spring,for example, mass, stiffness, and damping.But we've never found these ways to be particularly intuitive,so we invented a new way.You just specify the perceived duration of the animationand how bouncy you want the spring to be.It's much more approachable.

Similar to UnitCurve, the Spring type can be used standaloneto calculate the value and the velocity of a spring at a given time.

SwiftUI comes with three built-in spring presets:Smooth, which has no bounce,snappy, which has a small amount of bounce,and bouncy, which has a larger amount of bounce.

If you're uncomfortable parameterizing a spring animation,these presets are a reliable way to get something that feels good.

Each preset can be also tuned to adjust the duration or tweak the bounciness.

We highly recommend using spring animationsbecause they give your UI an organic feelby preserving velocity and naturally coming to rest.In fact, we feel so strongly about the benefits of spring animationsthat we made a smooth spring the new default when you usea bare withAnimation in iOS 17 and aligned releases.

The last category of animations, Higher order, modify a base animation.They can slow it down or speed it up.They can add a delay before the base animation starts.And they can repeat a base animation any number of times,optionally toggling between playing forwards and playing in reverse.

And now we're introducing an entirely new category of animation:Custom animations.The CustomAnimation protocol gives you accessto the same low-level generic entry points we use to implement all the animationsthat come built into SwiftUI.

The CustomAnimation protocol has three requirements:animate, shouldMerge, and velocity.

I'll start by focusing on animate.shouldMerge and velocity are optional requirements.I'll get back to them later.

Animate is passed the vector to animate towards,the amount of time that has elapsed since the animation began,and the context, which includes additional animation state.

Animate returns the current value of the animation,or nil if the animation has finished.

Where does this value vector come from?It comes from a view's animatable data.In the pet avatar view, that's the scale effect.

Recall that scaleEffect's animatable data is a four-dimensional vector,including a two-dimensional width and height scale.When the avatar is selected, it's animated to a scale factorof 1.5 by 1.5 from a scale factor of 1 by 1.

Vector addition and scalar multiplication operations allow SwiftUI to subtractthese two vectors from one another to calculate the delta between them.

This delta is actually what's being animated.

This means, in practice, the animation runningin the scaleEffect animatable attribute isn't interpolating from 1 to 1.5,but from 0 to 0.5.Among other things, this makes it more convenientto implement the animate method.Let me show you.

I'm going to implement a linear timing curve animationconfigured by a duration to interpolate over.

Recall that animate is passed the delta vector to animate towards.I can use scalar multiplication to scale the vector by the proportionof the duration that has elapsed.And once the full duration has elapsed, I'll return nil to indicatethat the animation has finished and can be removed.That's it.And because this implementation is generic,it works with animatable data of any number of dimensions.So that's how Animatable and Animation work togetherto produce the impressive visual effects that appear in your UI.

Next, I'll return to CustomAnimation's two optional requirements:shouldMerge and velocity.What are they for?Imagine for a moment that you're the scaleEffect animatable attribute.The user taps down, a transaction opens,your value changes, you make a local copy of the animation,and you start happily animating your delta vector.Everything is going great.That is, until the pesky user taps again before the animation has finished.What do you do?You set up a new animation,and you call shouldMerge on it.

The default implementation returns false--this is what timing curve animations do--in which case both animations will be run together,and their results will be combined by the system.

This is another reason why SwiftUI animationsdeal in terms of delta vectors.It makes it easy to calculate the correct combined presentation valuewhen multiple animations are running.But what if I'd chosen a spring animation,not a timing curve animation?Spring animations override shouldMerge to return trueand incorporate the state of the previous animation.This allows them to preserve velocity and retarget to the new value,which can feel more natural than combining additively,like timing curve animations.

And that's what this final velocity requirement is for.Implementing it allows velocity to be preserved when a running animationis merged with a new one.So I'll finish off my linear timing curve animationby adding an implementation for velocity.

I've used the term "transaction" throughout this talk to refer to the setof work that's performed for a given update to the UI.In SwiftUI code, Transaction also refers to a related,powerful data-flow construct and family of APIs.You may already be familiar with Environment and Preferences,dictionaries SwiftUI implicitly passesdown and up the view hierarchy, respectively.Transaction is similar.It's a dictionary SwiftUI uses to implicitly propagate all the contextfor the current update, most notably the animation.

My explanation earlierof how an animatable attributereads the current animationwas a little vague.So I'm gonna trace through another animated update of the avatar view.This time, I'll be more specific.When the tap gesture closure fires,withAnimation sets an animation in the root transaction dictionary.

Body is called to update the attribute values.The transaction dictionary is propagated across the attribute graph.When it reaches an animatable attribute,the attribute checks if an animation is set.And if so, it makes a copy to drive its presentation value.The Transaction is only relevant for a specific update,so once the stale attributes have been refreshed, it's discarded.

Flowing the animation down the view hierarchywithin the transaction dictionary makes possible a number of powerful APIsfor controlling when and how animations apply to your views.

Right now, the pet avatar view can only be selected via tap.I'll change the selected State variable to a Binding.That way, it can be also be selected programmatically.

But how do I animate a programmatic change to a view property?I can use the transaction modifierto access the animationas it flows down the view hierarchyinside the transaction dictionary.

If I set an animationfrom within this modifier,then whenever body is called,even if there is no animationor a different animationin the transaction,the attribute will override the animation.And when it reaches the scale effect,this animation will be usedto interpolate the scale factor.

Pretty cool.

But there's a problem with this pattern.Indiscriminately overriding the animationfor all descendantswhenever SwiftUI refreshes a viewcan lead to accidental animations.Instead, for uses cases like this,SwiftUI provides an animation view modifier.It takes an additional value argument,which allows you to scope the effectmuch more precisely.It will only write the animationinto the transactionif the value has changed.

Now that that's hooked up,this withAnimation isn't accomplishing anything,so we can remove it.

The animation view modifier is also a powerful tool for situationswhere you want to apply different animations to different parts of a view.

For example, the pet avatar has a shadow, which I've omitted thus farfrom the example for the sake of simplicity.The shadow radius increases when the avatar is selectedto accentuate the illusion that it's elevated above the background.

After playing with it, I've decided I want the shadow's animationto be more subdued than the scale effect's.To accomplish this, I can insert another animation view modifierbetween the scaleEffect and the shadow.Now the transaction picks up the bouncy springfor animating the scale effect.

And it picks up the more subtle smooth springfor animating the shadow radius.

Because animation modifiers are only activewhen their value has changed,the odds of an accidental animation are greatly reduced.But if the avatar's image had just happened to changein the same transaction as selected,it would have inherited the shadow's smooth spring animationfor its content transition.

This is a point worth lingering on.This animation view modifier works well for leaf componentswhere the entire sub-hierarchy is under your control.But for non-leaf components, which contain arbitrary child content,it's much more likely for an accidental animation to occur.

For example, if I want to reuse my avatarin another app that has nothing to do with pets,I could make it more generic by accepting arbitrary child content.In this scenario, I have less of a guaranteethat when selected changes,the child content won't also have changed.

This could result in an accidental animation.Whoops.Good news.We have a new version of the animation view modifierspecifically designed for use cases like this.It narrowly scopes the animation to the animatable attributesspecified in its body closure.Here's how it works.Imagine there's no animation in the transaction.When the transaction reaches the animation view modifier's attribute,a copy is made that's populated with the specified animation.The copy is propagated downstream,but only to the scoped animatable attributes.Once it's done its job, the copy is discarded,and the original transaction picks up where it left off.

So when the transaction reaches the child content,because the original transaction is unaffected by anyof the intermediate animation view modifiers,there's no risk of accidental animations.A limited set of transaction APIs have been availablesince the first version of SwiftUI.Now we're introducing the capability to define custom transaction keys,so you can leverage the transaction dictionaryto implicitly propagate your own update-specific data.

If you've ever declared a custom environment key,declaring a custom transaction key will be familiar.The pattern is to create a unique type that conformsto the TransactionKey protocol.The only requirement is to provide a defaultValue.Then declare a computed property as an extension on Transactionthat reads and writes from the transaction dictionary using your key.Here, I've defined a boolean key to track whether,for the given update, the avatar was tapped or not.I'll decide which animation to use based on its value.

If the avatar was selected interactively,I'll scale it up or down using a more lively spring.But if the avatar was selected programmatically,I'll scale it using a more subdued spring.I can set a value in the transaction dictionaryfor the given update by wrapping withTransaction around my state change.This should seem familiar.withAnimation is just a thin wrapper around withTransaction.

The arguments passed to withTransaction are a keypathto a computed property on the Transaction and the value to set.

Transaction is unique among SwiftUI's implicit data-flow constructsbecause it's discarded at the end of every update.This means, unless explicitly set for the current update,every value in the transaction dictionaryreverts to just being the default value for its key.

In the avatar view, when the tap gesture closure fires,avatarTapped is set to true for the current update.

The transaction also contains the default valuefor the animation key, which is nil.

The transaction propagates across the view hierarchyuntil it reaches the transaction modifier.

Here, the avatar view reads avatarTapped,and based on its value, sets the appropriate animation...

Which propagates down the view hierarchy.

This works pretty well, but just like earlier,it can result in accidental animations.

To give you finer-grained control over modifying the transaction,we're introducing two new variants of the transaction modifier.One lets you scope using a value argument.And the other lets you scope to a sub-hierarchydefined in a body closure.These variants mirrorthe scoped animation view modifiers covered earlier.

In this session, I explained SwiftUI's powerful animation primitives,Animatable, Animation, and Transaction.

As a next step, I recommend checking out two related sessions."Animate with springs" provides more guidance on why and howto effectively use spring animations in your app.And "Wind your way through advanced animations in SwiftUI"introduces powerful new tools for constructing multi-step animations.I hope this content gives you a better understandingof how SwiftUI animation works and empowers youto more skillfully leverage animation in your app.Thanks.♪ ♪

2:14 -Pet Avatar - Unanimated

4:13 -Pet Avatar - Animated

11:49 -Pet Avatar - Explicit Animation

12:48 -UnitCurve Model

13:56 -Spring Model

17:25 -MyLinearAnimation

19:50 -MyLinearAnimation with Velocity

22:44 -Pet Avatar - Animation Modifier

23:44 -Pet Avatar - Multiple Animation Modifiers

25:20 -Generic Avatar - Scoped Animation Modifiers

28:45 -Pet Avatar - Transaction Modifier

28:58 -Generic Avatar - Scoped Transaction Modifier

## Code Samples

```swift
struct
 
Avatar
: 
View
 {
    
var
 pet: 
Pet

    
@State
 
private
 
var
 selected: 
Bool
 
=
 
false


    
var
 body: 
some
 
View
 {
        
Image
(pet.type)
            .scaleEffect(selected 
?
 
1.5
 : 
1.0
)
            .onTapGesture {
                selected.toggle()
            }
    }
}
```

```swift
struct
 
Avatar
: 
View
 {
    
var
 pet: 
Pet

    
@State
 
private
 
var
 selected: 
Bool
 
=
 
false


    
var
 body: 
some
 
View
 {
        
Image
(pet.type)
            .scaleEffect(selected 
?
 
1.5
 : 
1.0
)
            .onTapGesture {
                withAnimation {
                    selected.toggle()
                }
            }
    }
}
```

```swift
struct
 
Avatar
: 
View
 {
    
var
 pet: 
Pet

    
@State
 
private
 
var
 selected: 
Bool
 
=
 
false


    
var
 body: 
some
 
View
 {
        
Image
(pet.type)
            .scaleEffect(selected 
?
 
1.5
 : 
1.0
)
            .onTapGesture {
                withAnimation(.bouncy) {
                    selected.toggle()
                }
            }
    }
}
```

```swift
let
 curve 
=
 
UnitCurve
(
    startControlPoint: 
UnitPoint
(x: 
0.25
, y: 
0.1
),
    endControlPoint: 
UnitPoint
(x: 
0.25
, y: 
1
))
curve.value(at: 
0.25
)
curve.velocity(at: 
0.25
)
```

```swift
let
 spring 
=
 
Spring
(duration: 
1.0
, bounce: 
0
)
spring.value(target: 
1
, time: 
0.25
)
spring.velocity(target: 
1
, time: 
0.25
)
```

```swift
struct
 
MyLinearAnimation
: 
CustomAnimation
 {
    
var
 duration: 
TimeInterval


    
func
 
animate
<
V
: 
VectorArithmetic
>(
        
value
: 
V
,
        
time
: 
TimeInterval
,
        
context
: 
inout
 
AnimationContext
<
V
>
    ) -> 
V
? {
        
if
 time 
<=
 duration {
            value.scaled(by: time 
/
 duration)
        } 
else
 {
            
nil
 
// animation has finished

        }
    }
}
```

```swift
struct
 
MyLinearAnimation
: 
CustomAnimation
 {
    
var
 duration: 
TimeInterval


    
func
 
animate
<
V
: 
VectorArithmetic
>(
        
value
: 
V
, 
time
: 
TimeInterval
, 
context
: 
inout
 
AnimationContext
<
V
>
    ) -> 
V
? {
        
if
 time 
<=
 duration {
            value.scaled(by: time 
/
 duration)
        } 
else
 {
            
nil
 
// animation has finished

        }
    }

    
func
 
velocity
<
V
: 
VectorArithmetic
>(
        
value
: 
V
, 
time
: 
TimeInterval
, 
context
: 
AnimationContext
<
V
>
    ) -> 
V
? {
        value.scaled(by: 
1.0
 
/
 duration)
    }
}
```

```swift
struct
 
Avatar
: 
View
 {
    
var
 pet: 
Pet

    
@Binding
 
var
 selected: 
Bool


    
var
 body: 
some
 
View
 {
        
Image
(pet.type)
            .scaleEffect(selected 
?
 
1.5
 : 
1.0
)
            .animation(.bouncy, value: selected)
            .onTapGesture {
                selected.toggle()
            }
    }
}
```

```swift
struct
 
Avatar
: 
View
 {
    
var
 pet: 
Pet

    
@Binding
 
var
 selected: 
Bool


    
var
 body: 
some
 
View
 {
        
Image
(pet.type)
            .shadow(radius: selected 
?
 
12
 : 
8
)
            .animation(.smooth, value: selected)
            .scaleEffect(selected 
?
 
1.5
 : 
1.0
)
            .animation(.bouncy, value: selected)
            .onTapGesture {
                selected.toggle()
            }
    }
}
```

```swift
struct
 
Avatar
<
Content
: 
View
>: 
View
 {
    
var
 content: 
Content

    
@Binding
 
var
 selected: 
Bool


    
var
 body: 
some
 
View
 {
        content
            .animation(.smooth) {
                
$0
.shadow(radius: selected 
?
 
12
 : 
8
)
            }
            .animation(.bouncy) {
                
$0
.scaleEffect(selected 
?
 
1.5
 : 
1.0
)
            }
            .onTapGesture {
                selected.toggle()
            }
    }
}
```

```swift
struct
 
Avatar
: 
View
 {
    
var
 pet: 
Pet

    
@Binding
 
var
 selected: 
Bool


    
var
 body: 
some
 
View
 {
        
Image
(pet.type)
            .scaleEffect(selected 
?
 
1.5
 : 
1.0
)
            .transaction(value: selected) {
                
$0
.animation 
=
 
$0
.avatarTapped
                    
?
 .bouncy : .smooth
            }
            .onTapGesture {
                withTransaction(\.avatarTapped, 
true
) {
                    selected.toggle()
                }
            }
    }
}


private
 
struct
 
AvatarTappedKey
: 
TransactionKey
 {
    
static
 
let
 defaultValue 
=
 
false

}


extension
 
Transaction
 {
    
var
 avatarTapped: 
Bool
 {
        
get
 { 
self
[
AvatarTappedKey
.
self
] }
        
set
 { 
self
[
AvatarTappedKey
.
self
] 
=
 newValue }
    }
}
```

```swift
struct
 
Avatar
<
Content
: 
View
>: 
View
 {
    
var
 content: 
Content

    
@Binding
 
var
 selected: 
Bool


    
var
 body: 
some
 
View
 {
        content
            .transaction {
                
$0
.animation 
=
 
$0
.avatarTapped
                    
?
 .bouncy : .smooth
            } body: {
                
$0
.scaleEffect(selected 
?
 
1.5
 : 
1.0
)
            }
            .onTapGesture {
                withTransaction(\.avatarTapped, 
true
) {
                    selected.toggle()
                }
            }
    }
}


private
 
struct
 
AvatarTappedKey
: 
TransactionKey
 {
    
static
 
let
 defaultValue 
=
 
false

}


extension
 
Transaction
 {
    
var
 avatarTapped: 
Bool
 {
        
get
 { 
self
[
AvatarTappedKey
.
self
] }
        
set
 { 
self
[
AvatarTappedKey
.
self
] 
=
 newValue }
    }
}
```


# Wwdc2023 111215

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

Meet UIKit for spatial computingLearn how to bring your UIKit app to visionOS. We'll show you how to build for a new destination, explore APIs and best practices for spatial computing, and take your content into the third dimension when you use SwiftUI with UIKit in visionOS.Chapters1:35 -Getting started2:56 -Platform differences5:36 -Polishing your app5:52 -Polish: Colors10:20 -Polish: Hover12:12 -Polish: Input13:47 -Outside the bounds15:03 -Outside: Presentations17:11 -Outside: Ornaments21:51 -Outside: RealityKitResourcesHD VideoSD VideoRelated VideosWWDC23Build spatial experiences with RealityKitDevelop your first immersive appElevate your windowed app for spatial computingMeet SwiftUI for spatial computingPrinciples of spatial designRun your iPad and iPhone apps in the Shared Space

Learn how to bring your UIKit app to visionOS. We'll show you how to build for a new destination, explore APIs and best practices for spatial computing, and take your content into the third dimension when you use SwiftUI with UIKit in visionOS.

1:35 -Getting started

2:56 -Platform differences

5:36 -Polishing your app

5:52 -Polish: Colors

10:20 -Polish: Hover

12:12 -Polish: Input

13:47 -Outside the bounds

15:03 -Outside: Presentations

17:11 -Outside: Ornaments

21:51 -Outside: RealityKit

HD VideoSD Video

HD Video

SD Video

Build spatial experiences with RealityKit

Develop your first immersive app

Elevate your windowed app for spatial computing

Meet SwiftUI for spatial computing

Principles of spatial design

Run your iPad and iPhone apps in the Shared Space

Search this video…♪ Mellow instrumental hip-hop ♪♪Grace Kendall: Hi everyone, and welcometo "Meet UIKit for spatial computing!"My name is Grace Kendalland I'm an engineer on the UIKit team.My colleague Andrew and I are so excited to chat with youin this video about taking your existing UIKit appsand bringing them to a brand-new dimension.The new device has a stunning platformfor spatial experiencesand introduces a ton of new 3D capabilities.And best of all, it uses the UI frameworksyou already know and love to do it.This video focuses entirely on the UIKit side of things.To learn more about SwiftUI on the platform,check out "Meet SwiftUI for spatial computing"and "Elevate your windowed app for spatial computing."In this video, we'll start by talking abouthow to build your app for the new platformand the steps that you'll take along the way.We'll then go into some of the characteristicsthat make it unique and differentfrom other Apple platformsand how to handle them in your code.After that, we'll go into polishing your appwith new API introduced in UIKit.And finally, we'll take a look at using SwiftUIin addition to UIKit to add some brand-new 3D functionality.So let's get started!Here's a demo pixel art animation appthat was written for iOS, all using UIKit.Some of my very best friends have contributed art to it.It looks and feels great on iPad,making use of a lot of system components,dynamic animations, and integrates Apple Pencil.Let's get it ready for spatial computing.The first thing that I'll need to dois to go to the General tab in the Xcode projectand add the new run destination.Now, here in the Asset catalog, I can add a new app icon.That's because icons on this platform are special.They're three images overlaid on top of each otherthat respond dynamically when someone looks at your app icon.One of our teammates, Jessica, is a super talented artistand mocked up a new icon for the appin preparation for this, so I can add these files now.Next, I'll select the new device simulator as the targetand build.OK, there are a few build errors.It looks like some of the APIs that were being usedfor the iPad app are not available on this platform.Let's talk about why.This is a brand-new platformwith brand-new capabilities and characteristicsthat make it different from other Apple platforms.So here are some things you'll need to look out forwhen bringing an app over.When bringing your app over for the first time,two common areas to investigate areAPIs that were deprecated on previous iOS releasesand APIs that don't translate well to this platform.This device does not support APIsthat were deprecated prior to iOS 14.With this brand-new platform,it's a great opportunity to move off of deprecated APIsand update your shared codebaseto adopt the latest and greatest.There's also a collection of APIsthat don't translate to this platform.For example, UIDeviceOrientation.This API assumes that the device can be usedin multiple orientations, which does not apply here.UIScreen is another example.With this device, the premise of a single representationof a hardware screen does not hold.And tab bars have a much different designand do not lay out leading-to-trailing,so its leadingAccessoryView and trailingAccessoryViewsare unavailable.These are just three examples of APIsthat have been marked unavailablebecause they don't apply, but there are others as well.Please check the documentationfor more details.Let's go back to the code nowand investigate what may have been the problem.Let's check out the error here.In the EditorViewController extensionthere's a UIPencilInteraction.This device doesn't support Apple Pencil,so this API isn't available on the platform.I can easily conditionalize out this code to make it compile.Let's go ahead and try to build and run again.OK! It looks like we're up and running!This is looking really good,and it's exciting to see the app runningin the Shared Space.But I'm already noticing some thingsthat I think I can improve.Let's take a tour now through the app to check it all outand find some things to polish.In the Simulator, clicking with the mousesimulates someone looking at that pointand tapping their fingers together.The first thing I notice is the beautiful glass backgroundof the app.And as I look at all the art,there are some really nice hover visualsthat make the app feel lively and interactive.The search bar also has a new look,with a recessed appearance.I can still open the different art workand pixellate to my heart's content.OK, one thing I think I can improveis the black text for the titleand gray text for the subtitle of the art.The black text looked really niceon the white background on iPad,but I don't love how it looks here on the glass.I think it could pop a little bit more.And I really like the appearance and dimension of the search bar.I think I want to have that for the title text fields too.Semantic colors aren't new,but they're especially valuable for this platform.It's important to use semantic colors, fonts,and materials so that the appearance of your appadapts to the platform, appearance,and accessibility settings.Many things, like UIColor.label,have new values so that everything looks pixel perfect.Semantic colors adapt to your platform,so instead of defining a color yourself with RGB values,instead use a system-provided colorthat will result in the correct appearanceno matter what platform your app is running on.For example, system cyan is a slightly differentshade of blue across iOS, macOS, and watchOS.On iPad, this has the added benefit of adaptingbetween light and dark appearance.And on this platform, systemBackgroundColoris vibrant by default when placed on top of glass.Similarly, using semantic font styles like Headline or Bodyinstead of setting a static font sizewill result in a more readable app.It's also the right thing to do for accessibility.Semantic font sizes scale with Dynamic Typeto ensure readability.Here, the colors for the TextField textand subtitle labels are using RGB defined UIColors.Instead of using those,use the primary and secondary label semantic colors here,which will better adapt to this platformwhile still looking great on iPad.Additionally, all UILabels that use semantic colorsget vibrancy by default.I can also set the text field's border styleto roundedRect.This will add the recessed appearance on this view.And after building and running......I like this much better!The labels are easy to read, and it's clearthat I can edit the titles of the art by using the text field.Next, let's talk materials.Materials are a huge cornerstone of this platform.They make your app look really beautifuland help it to feel like part of the surroundings.They also ensure legibility in any context.Materials adjust their contrast and color balancebased on lighting conditionsand the colors of objects behind them.Because of this, there is no distinctionbetween dark and light appearances on this platform.All of the built-in controls and containersuse vibrant materials by default,ensuring your app looks amazing.The glass that now serves as the background of the applooks really awesome.This comes by default for every UINavigationControllerand UISplitViewController.And this allows the details of the surroundingsto bleed through.You can also override the newpreferredContainer BackgroundStyle propertyon your UIViewController to return .automatic,.glass, or .hidden.Next, if I hover over some of the views in the app,a faint highlight appears.This really helps to make the app feel responsive.Using system components like controls or listsensures that you get these hover effects, materials,vibrancy, and more by default.Hover effects indicate interactivity.Adding a hover effect to a view will make it easier to target.One important thing about this platformis that exactly where someone is lookingis never delivered to the app's process.There's brand-new API in UIKit to add, customize,or disable hover effects.UIView has a new property, HoverStyle.Many interactive components have hover effects by default,like controls.You can customize the hoverStyle of your viewby setting the HoverStyle propertyand providing an effect: either highlight or lift.And if you want to remove the hover effect,you can set this property to nil.And to go even further, you can use the new UIShape APIto provide the shape of your hover effect.I like that I already have a hover shapeon the collection view cell,but I wish it had rounded corners.To instead use a rounded rectangleas the hover shape,I need to set the hoverStyle propertyon the cell and pass in a rounded rectangle shape.And that takes the hover shape of the cellfrom this rectangle with square corners......to this rounded rect.I think this looks really nice with the rounded cornersof the text field and the background.Now, when I look at each collection view cell,their hover shape will be rounded.There's one last thing I want to look at,and that's input.This platform introduces a totally new input systemfor interacting with content.Looking at an elementand pinching and releasing your fingersis equivalent to a TapGesture.Pinching, moving your hand, and releasing is a PanGesture.If you're close enough to the app,you can also reach out and touch it.If you pair a trackpad,you can also use that to interact with the system.And Apple's accessibility technologies are availableon device as well.VoiceOver and Switch Control bring your app to everyone.System gesture recognizers just workwith all of the input methods, including trackpad.But it's important to note that there is a maximumof two simultaneous inputs on this platformsince each hand can only produce one distinct touch.There was actually this custom gesture in the iPad appthat used a four-finger swipeto delete all of the existing art and start fresh.I want to keep the gesture, so I won't compile it out.Instead, I can change this codeto check the user interface idiom, and if it's reality,I can set the number of touches required to two.After I've made all these changes to polish the app,now I think I'm ready to take this example appto the next level.I'll hand it over to my colleague Andrewto tell you more.Andrew: Thanks, Grace!Hi! I'm Andrew and I'm an engineer on the UIKit team.It's time to bring your UIKit apps out of their 2D boundsand into three dimensions.With Grace's updates, the example app is looking good!And it, as well as your existing UIKit apps,can be taken even further with new spatial APIs.I'm going to talk about three easy ways to updatean existing app to create a great spatial experience.First, UIKit presentations have exciting new spatial stylesthat add depth to your view controller transitions.Second, there's a new API that enables you to take contentto a place it's never gone before...outside the scene!These are called ornaments.Finally, there are powerful new ways to add RealityKit contentright into your apps.Let's go over how each of these can take the example appto the next level.The UIKit presentations you know and loveare making their spatial debut.On iPad, the example app uses sheets, alerts, and popovers.Let's go over how those behave on the new platform.First, let's open the app settings.The spatial sheet pushes the presenting view controller backand dims it.Unlike iPad, it won't dismiss due to touchesoutside the bounds or other gestures,regardless of the view controller'sisModalInPresentation property.Next, let's check out the new alert style.A 2D representation of the app's iconis placed right at the top.Just like sheets, you should always present alertsfrom the view controller that should be pushed back.Finally, let's open the document details popover.Oh, this looks a little off.It's breaking outside the bounds, which is awesome,but it's presenting far from the center of the app.Let's go into the code to fix this.It looks like the view controller is being created,set to the popover style...Ah, I see the problem.The permittedArrowDirections is set to only right.On iPad, popovers are constrained to the scene,but on the spatial platform,this same constraint doesn't exist,similar to macOS.Let's update this to always use the system preferred placement.Now, when I tap the info button,I get the popover placement I was expecting.If you use standard presentationsin your iPad app, your spatial app may already bebreaking outside the bounds in a great way.UIKit handles all the detailsas long as you haven't hard codedany platform assumptions.The next way I'm going to elevate the example appis with ornaments.While the app's presentations are now spatial,the editor itself is not yet taking advantageof the extra space on the platform.The editor......eh, looks a little cramped.But with ornaments, we can take advantageof the extra room the spatial platform providesin a way we never could before.Ornaments let content be placed around an app's scenewithin reasonable limits.UIKit components use ornaments too,like popovers.That's how the example app popoverappeared outside the scene, without getting clipped.Many of the built-in apps on the deviceare also using ornaments.Here's a cool look at TV in headset.The app uses a SwiftUI tab view,which places the tab bar in an ornamenton the leading edge of the scene.Safari uses an ornament to bring their navigation barabove the web page.And Freeform uses an ornament to create their bottom toolbar.With ornaments, these apps keep their primary contentin the center, pushing controls to the edge.And ornaments are lifted forward, adding depth.They are breaking outside the bounds in all directions!For the example app, I think bringing togetherall the editing controls in a toolbar ornamentwould be perfect.Let's go back into Xcode to add this.Ornaments host SwiftUI content,I'll need to make sure to import SwiftUI,which I already have done in this file.Next, I'll define the new ornament.The alignment parameters make it easy to express the layoutof your content that best fits your needs.For example, if I want an ornamentto hang off my scene's leading edgeI would set a leading scene alignmentand a trailing content alignment.If I instead want the ornament to hang inside the scene,I'd use a leading content alignment.For the editing toolbar,I want it to hang off the bottom of the scene,but with the tools centered on the edgeso it still feels part of the editor.This means I want a bottom scene alignmentand a center content alignment.I'll add in those alignments.For the content,I already made a new EditingControlsView earlier,and I'll use that here.Ornaments don't automatically add a background.This is because choosing the right backgrounddepends on what works best for your content.I want the toolbar to have the same glass backgroundas my editor, so I'll use the new modifier.Next, I'll set the new ornaments property on UIViewControllerto an array with just the new ornament.If I had multiple ornaments,I would include them in this array too.Ornaments share their view controller's lifecycle.If a view controller is removed from the hierarchy,its ornaments are too.This association is critical for system interactions.For example, sheet presentations will keep ornaments relativeto their view controller during transitions.Lastly, use care to avoid cases where overlappingcan unintentionally occur.I have one last change to make in the code.Since I moved the controls to the ornament,I now have more room for the main editor.I'm going to make it a bit largerby using my custom edgeToEdge style.Time to run the app.Perfect!The toolbar is right where I wanted it,breaking outside the bottom of the editor.It's awesome.By taking advantage of ornaments,the example app is able to use more of the main areafor what creators care most about -- their content --while still keeping the editing tools close by.Making an ornament is so easy.It lets you focus your time and efforton what makes your app unique.Finally, I'll talk about adding RealityKit to a UIKit app.There's a new SwiftUI View, RealityView,that hosts RealityKit content.This enables entities to be parented in a SwiftUI hierarchy.To dive deeper into RealityView,make sure to check out"Build spatial experiences with RealityKit."There's also an existing API, UIHostingController,which hosts SwiftUI views.This means you can take advantage of RealityView,as well as other new APIs in SwiftUI,without needing to rewrite your UIKit app.For the example app,I want to use RealityKit to bring the pixels to life.Let's open Xcode to make some magic.I've already created a new SwiftUI Viewcalled the PixelArtEntityView.It uses a RealityView to render the art's pixelsas RealityKit entities.I'll make a new instance to start.Then I'll setup the UIHostingController,using the entity view as the root view.I'll add the hosting controlleras a child of the EditorViewControllerand add the hosting controller's view as a subviewof the EditorViewController's view.Next, I'll tell the hosting controllerthat it was moved to a new parent.Finally, I'll call my custom layout functionto position the preview.All right, the hosting controller setup is complete.It's showtime.I'll press the play button and tap 3D Previewto see the new code in action.Just like that,I've added pixels with real depth to the app.With the simulator orbit control,I can even see how the lighting changesbased on my perspective.This is so cool!And it's all happening in a UIKit app.RealityView has leveled up the animator preview.And thanks to UIHostingController,it was easy to add.Together, these APIs shorten the pathto building a great spatial app.By using standard UIKit presentations,putting the editor controls in an ornament,and adding 3D pixels with RealityKit,the example app looks great in this new spatial world.And all with just a few lines of code.To learn about the design guidancefor these spatial experiences,check out "Principles of spatial design."We covered a ton in this video,so here's what you need to do next.Start by adding the new destination to your project.Update your uses of device-specific APIs,and move off of deprecated APIs.Use semantic styles, hover effects,and standard presentations to make your appfeel consistent with the platform appearance.Extend your ideas and imaginationbeyond the bounds with ornaments.And take your app even furtherwith new spatial SwiftUI features,right from UIKit.Thanks for watching!Grace and I are so excited to see your appsin a whole new dimension.♪

♪ Mellow instrumental hip-hop ♪♪Grace Kendall: Hi everyone, and welcometo "Meet UIKit for spatial computing!"My name is Grace Kendalland I'm an engineer on the UIKit team.My colleague Andrew and I are so excited to chat with youin this video about taking your existing UIKit appsand bringing them to a brand-new dimension.The new device has a stunning platformfor spatial experiencesand introduces a ton of new 3D capabilities.And best of all, it uses the UI frameworksyou already know and love to do it.This video focuses entirely on the UIKit side of things.To learn more about SwiftUI on the platform,check out "Meet SwiftUI for spatial computing"and "Elevate your windowed app for spatial computing."In this video, we'll start by talking abouthow to build your app for the new platformand the steps that you'll take along the way.We'll then go into some of the characteristicsthat make it unique and differentfrom other Apple platformsand how to handle them in your code.After that, we'll go into polishing your appwith new API introduced in UIKit.And finally, we'll take a look at using SwiftUIin addition to UIKit to add some brand-new 3D functionality.So let's get started!Here's a demo pixel art animation appthat was written for iOS, all using UIKit.Some of my very best friends have contributed art to it.It looks and feels great on iPad,making use of a lot of system components,dynamic animations, and integrates Apple Pencil.Let's get it ready for spatial computing.The first thing that I'll need to dois to go to the General tab in the Xcode projectand add the new run destination.Now, here in the Asset catalog, I can add a new app icon.That's because icons on this platform are special.They're three images overlaid on top of each otherthat respond dynamically when someone looks at your app icon.One of our teammates, Jessica, is a super talented artistand mocked up a new icon for the appin preparation for this, so I can add these files now.

Next, I'll select the new device simulator as the targetand build.

OK, there are a few build errors.It looks like some of the APIs that were being usedfor the iPad app are not available on this platform.Let's talk about why.This is a brand-new platformwith brand-new capabilities and characteristicsthat make it different from other Apple platforms.So here are some things you'll need to look out forwhen bringing an app over.When bringing your app over for the first time,two common areas to investigate areAPIs that were deprecated on previous iOS releasesand APIs that don't translate well to this platform.This device does not support APIsthat were deprecated prior to iOS 14.With this brand-new platform,it's a great opportunity to move off of deprecated APIsand update your shared codebaseto adopt the latest and greatest.There's also a collection of APIsthat don't translate to this platform.For example, UIDeviceOrientation.This API assumes that the device can be usedin multiple orientations, which does not apply here.UIScreen is another example.With this device, the premise of a single representationof a hardware screen does not hold.And tab bars have a much different designand do not lay out leading-to-trailing,so its leadingAccessoryView and trailingAccessoryViewsare unavailable.These are just three examples of APIsthat have been marked unavailablebecause they don't apply, but there are others as well.Please check the documentationfor more details.Let's go back to the code nowand investigate what may have been the problem.Let's check out the error here.In the EditorViewController extensionthere's a UIPencilInteraction.This device doesn't support Apple Pencil,so this API isn't available on the platform.I can easily conditionalize out this code to make it compile.Let's go ahead and try to build and run again.

OK! It looks like we're up and running!This is looking really good,and it's exciting to see the app runningin the Shared Space.But I'm already noticing some thingsthat I think I can improve.Let's take a tour now through the app to check it all outand find some things to polish.In the Simulator, clicking with the mousesimulates someone looking at that pointand tapping their fingers together.The first thing I notice is the beautiful glass backgroundof the app.And as I look at all the art,there are some really nice hover visualsthat make the app feel lively and interactive.The search bar also has a new look,with a recessed appearance.

I can still open the different art workand pixellate to my heart's content.OK, one thing I think I can improveis the black text for the titleand gray text for the subtitle of the art.The black text looked really niceon the white background on iPad,but I don't love how it looks here on the glass.I think it could pop a little bit more.And I really like the appearance and dimension of the search bar.I think I want to have that for the title text fields too.Semantic colors aren't new,but they're especially valuable for this platform.It's important to use semantic colors, fonts,and materials so that the appearance of your appadapts to the platform, appearance,and accessibility settings.Many things, like UIColor.label,have new values so that everything looks pixel perfect.Semantic colors adapt to your platform,so instead of defining a color yourself with RGB values,instead use a system-provided colorthat will result in the correct appearanceno matter what platform your app is running on.For example, system cyan is a slightly differentshade of blue across iOS, macOS, and watchOS.On iPad, this has the added benefit of adaptingbetween light and dark appearance.And on this platform, systemBackgroundColoris vibrant by default when placed on top of glass.Similarly, using semantic font styles like Headline or Bodyinstead of setting a static font sizewill result in a more readable app.It's also the right thing to do for accessibility.Semantic font sizes scale with Dynamic Typeto ensure readability.Here, the colors for the TextField textand subtitle labels are using RGB defined UIColors.Instead of using those,use the primary and secondary label semantic colors here,which will better adapt to this platformwhile still looking great on iPad.Additionally, all UILabels that use semantic colorsget vibrancy by default.I can also set the text field's border styleto roundedRect.This will add the recessed appearance on this view.And after building and running......I like this much better!The labels are easy to read, and it's clearthat I can edit the titles of the art by using the text field.Next, let's talk materials.Materials are a huge cornerstone of this platform.They make your app look really beautifuland help it to feel like part of the surroundings.They also ensure legibility in any context.Materials adjust their contrast and color balancebased on lighting conditionsand the colors of objects behind them.Because of this, there is no distinctionbetween dark and light appearances on this platform.All of the built-in controls and containersuse vibrant materials by default,ensuring your app looks amazing.The glass that now serves as the background of the applooks really awesome.This comes by default for every UINavigationControllerand UISplitViewController.And this allows the details of the surroundingsto bleed through.You can also override the newpreferredContainer BackgroundStyle propertyon your UIViewController to return .automatic,.glass, or .hidden.Next, if I hover over some of the views in the app,a faint highlight appears.This really helps to make the app feel responsive.Using system components like controls or listsensures that you get these hover effects, materials,vibrancy, and more by default.Hover effects indicate interactivity.Adding a hover effect to a view will make it easier to target.One important thing about this platformis that exactly where someone is lookingis never delivered to the app's process.There's brand-new API in UIKit to add, customize,or disable hover effects.UIView has a new property, HoverStyle.Many interactive components have hover effects by default,like controls.You can customize the hoverStyle of your viewby setting the HoverStyle propertyand providing an effect: either highlight or lift.And if you want to remove the hover effect,you can set this property to nil.And to go even further, you can use the new UIShape APIto provide the shape of your hover effect.I like that I already have a hover shapeon the collection view cell,but I wish it had rounded corners.To instead use a rounded rectangleas the hover shape,I need to set the hoverStyle propertyon the cell and pass in a rounded rectangle shape.And that takes the hover shape of the cellfrom this rectangle with square corners......to this rounded rect.I think this looks really nice with the rounded cornersof the text field and the background.Now, when I look at each collection view cell,their hover shape will be rounded.

There's one last thing I want to look at,and that's input.This platform introduces a totally new input systemfor interacting with content.Looking at an elementand pinching and releasing your fingersis equivalent to a TapGesture.Pinching, moving your hand, and releasing is a PanGesture.If you're close enough to the app,you can also reach out and touch it.If you pair a trackpad,you can also use that to interact with the system.And Apple's accessibility technologies are availableon device as well.VoiceOver and Switch Control bring your app to everyone.System gesture recognizers just workwith all of the input methods, including trackpad.But it's important to note that there is a maximumof two simultaneous inputs on this platformsince each hand can only produce one distinct touch.There was actually this custom gesture in the iPad appthat used a four-finger swipeto delete all of the existing art and start fresh.I want to keep the gesture, so I won't compile it out.Instead, I can change this codeto check the user interface idiom, and if it's reality,I can set the number of touches required to two.After I've made all these changes to polish the app,now I think I'm ready to take this example appto the next level.I'll hand it over to my colleague Andrewto tell you more.Andrew: Thanks, Grace!Hi! I'm Andrew and I'm an engineer on the UIKit team.It's time to bring your UIKit apps out of their 2D boundsand into three dimensions.With Grace's updates, the example app is looking good!And it, as well as your existing UIKit apps,can be taken even further with new spatial APIs.I'm going to talk about three easy ways to updatean existing app to create a great spatial experience.First, UIKit presentations have exciting new spatial stylesthat add depth to your view controller transitions.Second, there's a new API that enables you to take contentto a place it's never gone before...outside the scene!These are called ornaments.Finally, there are powerful new ways to add RealityKit contentright into your apps.Let's go over how each of these can take the example appto the next level.The UIKit presentations you know and loveare making their spatial debut.On iPad, the example app uses sheets, alerts, and popovers.Let's go over how those behave on the new platform.First, let's open the app settings.The spatial sheet pushes the presenting view controller backand dims it.Unlike iPad, it won't dismiss due to touchesoutside the bounds or other gestures,regardless of the view controller'sisModalInPresentation property.Next, let's check out the new alert style.A 2D representation of the app's iconis placed right at the top.Just like sheets, you should always present alertsfrom the view controller that should be pushed back.Finally, let's open the document details popover.Oh, this looks a little off.It's breaking outside the bounds, which is awesome,but it's presenting far from the center of the app.Let's go into the code to fix this.It looks like the view controller is being created,set to the popover style...Ah, I see the problem.The permittedArrowDirections is set to only right.On iPad, popovers are constrained to the scene,but on the spatial platform,this same constraint doesn't exist,similar to macOS.Let's update this to always use the system preferred placement.

Now, when I tap the info button,I get the popover placement I was expecting.If you use standard presentationsin your iPad app, your spatial app may already bebreaking outside the bounds in a great way.UIKit handles all the detailsas long as you haven't hard codedany platform assumptions.The next way I'm going to elevate the example appis with ornaments.While the app's presentations are now spatial,the editor itself is not yet taking advantageof the extra space on the platform.The editor......eh, looks a little cramped.But with ornaments, we can take advantageof the extra room the spatial platform providesin a way we never could before.Ornaments let content be placed around an app's scenewithin reasonable limits.UIKit components use ornaments too,like popovers.That's how the example app popoverappeared outside the scene, without getting clipped.Many of the built-in apps on the deviceare also using ornaments.Here's a cool look at TV in headset.The app uses a SwiftUI tab view,which places the tab bar in an ornamenton the leading edge of the scene.Safari uses an ornament to bring their navigation barabove the web page.And Freeform uses an ornament to create their bottom toolbar.With ornaments, these apps keep their primary contentin the center, pushing controls to the edge.And ornaments are lifted forward, adding depth.They are breaking outside the bounds in all directions!For the example app, I think bringing togetherall the editing controls in a toolbar ornamentwould be perfect.Let's go back into Xcode to add this.Ornaments host SwiftUI content,I'll need to make sure to import SwiftUI,which I already have done in this file.Next, I'll define the new ornament.The alignment parameters make it easy to express the layoutof your content that best fits your needs.For example, if I want an ornamentto hang off my scene's leading edgeI would set a leading scene alignmentand a trailing content alignment.If I instead want the ornament to hang inside the scene,I'd use a leading content alignment.For the editing toolbar,I want it to hang off the bottom of the scene,but with the tools centered on the edgeso it still feels part of the editor.This means I want a bottom scene alignmentand a center content alignment.I'll add in those alignments.For the content,I already made a new EditingControlsView earlier,and I'll use that here.Ornaments don't automatically add a background.This is because choosing the right backgrounddepends on what works best for your content.I want the toolbar to have the same glass backgroundas my editor, so I'll use the new modifier.Next, I'll set the new ornaments property on UIViewControllerto an array with just the new ornament.If I had multiple ornaments,I would include them in this array too.Ornaments share their view controller's lifecycle.If a view controller is removed from the hierarchy,its ornaments are too.This association is critical for system interactions.For example, sheet presentations will keep ornaments relativeto their view controller during transitions.Lastly, use care to avoid cases where overlappingcan unintentionally occur.I have one last change to make in the code.Since I moved the controls to the ornament,I now have more room for the main editor.I'm going to make it a bit largerby using my custom edgeToEdge style.Time to run the app.

Perfect!The toolbar is right where I wanted it,breaking outside the bottom of the editor.It's awesome.By taking advantage of ornaments,the example app is able to use more of the main areafor what creators care most about -- their content --while still keeping the editing tools close by.Making an ornament is so easy.It lets you focus your time and efforton what makes your app unique.Finally, I'll talk about adding RealityKit to a UIKit app.There's a new SwiftUI View, RealityView,that hosts RealityKit content.This enables entities to be parented in a SwiftUI hierarchy.To dive deeper into RealityView,make sure to check out"Build spatial experiences with RealityKit."There's also an existing API, UIHostingController,which hosts SwiftUI views.This means you can take advantage of RealityView,as well as other new APIs in SwiftUI,without needing to rewrite your UIKit app.For the example app,I want to use RealityKit to bring the pixels to life.Let's open Xcode to make some magic.I've already created a new SwiftUI Viewcalled the PixelArtEntityView.It uses a RealityView to render the art's pixelsas RealityKit entities.I'll make a new instance to start.Then I'll setup the UIHostingController,using the entity view as the root view.I'll add the hosting controlleras a child of the EditorViewControllerand add the hosting controller's view as a subviewof the EditorViewController's view.Next, I'll tell the hosting controllerthat it was moved to a new parent.Finally, I'll call my custom layout functionto position the preview.All right, the hosting controller setup is complete.It's showtime.

I'll press the play button and tap 3D Previewto see the new code in action.Just like that,I've added pixels with real depth to the app.With the simulator orbit control,I can even see how the lighting changesbased on my perspective.This is so cool!And it's all happening in a UIKit app.RealityView has leveled up the animator preview.And thanks to UIHostingController,it was easy to add.Together, these APIs shorten the pathto building a great spatial app.By using standard UIKit presentations,putting the editor controls in an ornament,and adding 3D pixels with RealityKit,the example app looks great in this new spatial world.And all with just a few lines of code.To learn about the design guidancefor these spatial experiences,check out "Principles of spatial design."We covered a ton in this video,so here's what you need to do next.Start by adding the new destination to your project.Update your uses of device-specific APIs,and move off of deprecated APIs.Use semantic styles, hover effects,and standard presentations to make your appfeel consistent with the platform appearance.Extend your ideas and imaginationbeyond the bounds with ornaments.And take your app even furtherwith new spatial SwiftUI features,right from UIKit.Thanks for watching!Grace and I are so excited to see your appsin a whole new dimension.♪

16:15 -permittedArrowDirections

19:46 -Ornament

22:45 -UIHostingController

22:46 -Using Semantic Colors

22:47 -Adding a recessed appearance to a text field

22:48 -Overriding preferredContainerBackgroundStyle

22:49 -Customizing hover style

22:50 -Checking user interface idiom

## Code Samples

```swift
import
 UIKit


extension
 
EditorViewController
 {

    
@objc
 
func
 
showDocumentPopover
(
sender
: 
UIBarButtonItem
) {
        
let
 controller 
=
 
DocumentInfoViewController
(document: pixelDocument)
        controller.modalPresentationStyle 
=
 .popover
        
if
 
let
 presentationController 
=
 controller.popoverPresentationController {
            presentationController.barButtonItem 
=
 sender
            
if
 traitCollection.userInterfaceIdiom 
==
 .reality {
                presentationController.permittedArrowDirections 
=
 .any
            } 
else
 {
                presentationController.permittedArrowDirections 
=
 .right
            }
        }
        present(controller, animated: 
true
, completion: 
nil
)
    }

}
```

```swift
extension
 
EditorViewController
 {

    
func
 
showEditingControlsOrnament
() {
        
let
 ornament 
=
 
UIHostingOrnament
(sceneAlignment: .bottom, contentAlignment: .center) {
            
EditingControlsView
(model: controlsViewModel)
                .glassBackgroundEffect()
        }

        
self
.ornaments 
=
 [ornament]

        editorView.style 
=
 .edgeToEdge
    }

}
```

```swift
extension
 
EditorViewController
 {

    
func
 
showEntityPreview
() {
        
let
 entityView 
=
 
PixelArtEntityView
(model: entityViewModel)
        
let
 controller 
=
 
UIHostingController
(rootView: entityView)
        addChild(controller)
        view.addSubview(controller.view)
        controller.didMove(toParent: 
self
)
        prepareEditorInteractions()
    }

}
```

```swift
private
 
let
 titleLabelTextField: 
UITextField
 
=
 {
    textField.textColor 
=
 
UIColor
.label
    
return
 textField
}()


private
 
let
 authorLabel: 
UILabel
 
=
 {
    label.textColor 
=
 
UIColor
.secondaryLabel
    
return
 label
}()
```

```swift
textField.borderStyle 
=
 .roundedRect
```

```swift
class
 
MyViewController
: 
UIViewController
 {
    
override
 
var
 preferredContainerBackgroundStyle: 
UIContainerBackgroundStyle
 {
        
return
 .glass
    }
}
```

```swift
class
 
CollectionViewCell
: 
UICollectionViewCell
 {
    
init
(
document
: 
PixelArtDocument
) {
        
self
.hoverStyle 
=
 .
init
(
            effect: .highlight, 
            shape: .roundedRect(cornerRadius: 
8.0
))
    }
}
```

```swift
func
 
fourFingerSwipe
() {
    
let
 gesture 
=
 
UISwipeGestureRecognizer
(
        target: 
self
, 
        action: 
#selector
(
self
.deleteAll))
    gesture.direction 
=
 .left
    
if
 traitCollection.userInterfaceIdiom 
==
 .reality {
        gesture.numberOfTouchesRequired 
=
 
2

    } 
else
 {
        gesture.numberOfTouchesRequired 
=
 
4

    }
    
self
.view.addGestureRecognizer(gesture)
}
```


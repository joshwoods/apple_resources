# Wwdc2023 10140

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Code

What’s new in StoreKit 2 and StoreKit Testing in XcodeGet to know the latest enhancements to StoreKit 2 and StoreKit Testing in Xcode. Discover API updates for promoted in-app purchases, StoreKit messages, the Transaction model, the RenewalInfo model, and the App Store sheet for managing subscriptions. Learn how to upgrade to SHA-256 for on-device receipt validation and use APIs to create SwiftUI views.

We'll also help you get started with StoreKit Testing in Xcode so that you can debug and test your in-app purchases and subscriptions. Meet the Transaction Inspector, explore the latest updates to the StoreKit configuration editor, and find out how you can simulate StoreKit errors to test your app's error handling.ResourcesMessageSetting up StoreKit Testing in XcodeStoreKitSubmit feedbackSupporting promoted In-App Purchases in your appTesting failing subscription renewals and In-App PurchasesTurn on Family Sharing for in-app purchases in App Store ConnectHD VideoSD VideoRelated VideosWWDC23Explore testing in-app purchasesMeet StoreKit for SwiftUIWhat’s new in App Store ConnectWWDC22What's new in StoreKit testingWhat's new with in-app purchaseWWDC21Meet StoreKit 2

Get to know the latest enhancements to StoreKit 2 and StoreKit Testing in Xcode. Discover API updates for promoted in-app purchases, StoreKit messages, the Transaction model, the RenewalInfo model, and the App Store sheet for managing subscriptions. Learn how to upgrade to SHA-256 for on-device receipt validation and use APIs to create SwiftUI views.

We'll also help you get started with StoreKit Testing in Xcode so that you can debug and test your in-app purchases and subscriptions. Meet the Transaction Inspector, explore the latest updates to the StoreKit configuration editor, and find out how you can simulate StoreKit errors to test your app's error handling.

Message

Setting up StoreKit Testing in Xcode

StoreKit

Submit feedback

Supporting promoted In-App Purchases in your app

Testing failing subscription renewals and In-App Purchases

Turn on Family Sharing for in-app purchases in App Store Connect

HD VideoSD Video

HD Video

SD Video

Explore testing in-app purchases

Meet StoreKit for SwiftUI

What’s new in App Store Connect

What's new in StoreKit testing

What's new with in-app purchase

Meet StoreKit 2

Search this video…♪ ♪Ricky: Hello, I'm Ricky, and welcometo "What's new in StoreKit 2 and StoreKit Testing in Xcode."In this session, I'll talk about the new featureswe're bringing to StoreKit this year,as well as the enhancements to the testing experience in Xcode.StoreKit 2 was first introduced at WWDC in 2021,with new and more flexible APIs using Swift.This year, I am excited to show youthe new features that make StoreKit 2 even better.First, I will review the new StoreKit framework features,then, I'll share some updates for building SwiftUI apps using StoreKit,and finally, I will cover what's new in StoreKit Testing in Xcode.I am excited to introduce a new Swift APIfor managing promoted in-app purchases, available starting in iOS 16.4.Promoted in-app purchases is a feature that allows youto merchandise your products on your App Store product page,each with a dedicated promotional image.Promoting your in-app purchases is a great wayto increase your product's visibility,and you can easily set up promoted purchases in App Store Connect.To learn more about configuring promoted in-app purchases,check out "What's new in App Store Connect."Since promoted in-app purchases are listed on the App Store,when a customer buys a promoted product,their interaction starts here by tapping the purchase button.Then, the App Store sends the purchase data to your appwhere you can listen for this information and prompt them to complete the purchase.To listen for promoted purchases, use the Swift async sequencewhich receives a new purchase intent every time a customer initiatesthe purchase for a promoted product in the App Store.First, create a listener to receive purchase intentsusing PurchaseIntent.intents.Every time the sequence receives a new object,it contains the StoreKit Product associated with the purchase.You can prompt your customers to purchase these products as usualby calling purchase(), which displays the familiar payment sheetand allows them to complete the interaction there.If your app isn't ready to complete a purchase,you can also save the intent locally and defer it.You can always process it later.Another feature of promoting in-app purchasesis being able to customize how your products are displayed locallyon the current device.For example, if a customer buys one of these products,you can hide it, so the App Store doesn't show it again when they browse or search.You can also change the product order, or the subset of products featured,based on a current state in your app,for example, a level advancement in a game.To cover all of these cases, I am excited to show yousome new Swift APIs that you can use to customize the orderand the visibility of your promoted in-app purchases.Let's see a quick demonstration.After importing StoreKit, you can check the current promotion orderwith Product.PromotionInfo.currentOrder.This returns a sequence of PromotionInfo objects,in the order that is currently set.If this list is empty, it means there are no local overridesset for this device, and the products people seein the App Store are in the same order that you configured in App Store Connect.Each object in this sequence contains informationregarding a promoted product in your app.To set a custom order of promotions, you can use theProduct.PromotionInfo.updateProductOrder APIand pass a list of product identifiersin the order you want them to appear in the App Store for this device.You can also hide and show products without having to set a whole new order.This can be done by changing the visibility propertyassociated with promoted in-app purchases.The visibility state can be visible, hidden, or default,which follows the settings you configure in App Store Connectand applies to all devices that don't have a local override set by your app.Let's see how we can change this in code.The visibility value can be changed in a couple of different ways.Your app can callthe Product.PromotionInfo. updateProductVisibility APIand change the value for a single product by passing both the new visibility stateand the identifier of that in-app purchase.Alternatively, you can also change the visibility valueby setting a member property on each PromotionInfo object.Then, to save the changes, call update() on that same object you just modified.And that is everything you need to start using promoted in-app purchaseswith StoreKit 2.Now, I would like to show you some of the enhancements we madeto the core data model in StoreKit 2.These models are useful for managing your in-app purchasesand related information, for example, the purchase dateand the subscription status.Let's dive into the new fields we're adding to the Transactionand RenewalInfo data models, which bring great improvements many of you requested.The first new field is storefront, and it appearsin the Transaction model along with storefrontCountryCode.The next new field is called reason.It tells you whether a customer initiated a purchase,or if the transaction is an automatic subscription renewal.In the RenewalInfo model under Product.SubscriptionInfo,there is a new member called nextRenewalDate.This tells you when this subscription renewal will be processed.All of these new fields are available for apps you build with Xcode 15,and although initially released with iOS 17,most of them also work retroactively with prior versions of iOS as wellwhen you are using StoreKit 2.Next, I'd like to talk about StoreKit Messagesand the great new feature we just added.We introduced the Message API last year at WWDC 2022as a way for the App Store to notify your customers of important information.Messages have a Reason value that tells you the purpose of the message.Your app can choose whether to defer or suppress messages.For example, you may want to defer a messageif displaying it would interrupt your customers during an interaction flow.Otherwise, StoreKit displays any active messages automaticallywhen your app launches.This year, we added a new message reason called billingIssue.This message is available starting in iOS 16.4.The App Store sends this message when a subscription fails to renewbecause of a billing problem.StoreKit displays a Billing Problem sheet,and customers can resolve the issue without leaving your app.This new property is already enabled in sandbox to give you time to test it.Please check back on the Apple Developer website later this yearfor updates on when this will be enabled for all customers.When the App Store fails to renew a subscription,the subscription goes into a Billing Retry state.To learn about how to test this feature in sandbox,please refer to the WWDC session on testing in-app purchases.Now, let's review some security related updates.In order to keep StoreKit up-to-date with modern security practices,we're migrating our receipt signing certificatefrom using SHA-1 to SHA-256 for the "original StoreKit" receipt.Modern versions of cryptographic libraries, like OpenSSL,already support SHA-256, but if your app performs on-device receipt validation,it is important you verify that it handles the new certificate properly.The new SHA-256 signing certificate will be used to sign receipts in sandboxstarting on June 20th, and you will be able to teston devices running iOS 16.6 and macOS 13.5 or later.After August 14th, the new certificate will be usedto sign receipts for all new apps and app updatessubmitted to the App Store.For more details on this timeline, you can check the Apple Developer website.If your app uses StoreKit 2, you don't need to do anything.StoreKit 2's Signed Transaction, Renewal Info,and App Transaction already use SHA-256 today.And if you use App Store server APIs to do receipt validation,you also don't need to make any changes,since we handle the new format automatically.Next, I am excited to show you a whole new set of features for StoreKitthat make it very easy and quick to merchandise in-app purchasesin your app, using SwiftUI.There are new APIs to create SwiftUI views for single in-app purchases,whole stores of products, and even some custom ones specific to subscriptions.These function like normal SwiftUI views and require minimal code to implement,allowing you to get up and running with your app as quick as possible.Let's take a look at these new views.With this product view, you can represent a single in-app purchase,complete with its localized title, description,and even the optional promotional image.You can create it by passing product identifier to ProductView.And there is no need to load the StoreKit product either.You can just use the productID string.StoreKit and SwiftUI will take care of the rest.There is also a new view to display a whole collection of products,like a store right in your app.Instead of passing a single product identifier,you can use a collection of productIDs in combination with StoreViewto create a list of products to merchandise,which you can then further customize using SwiftUI components.The StoreView is a great way to get your app or game startedand support in-app purchases, since it requiresonly a few lines of code to set up, like shown here.Last but not least, there is also a new viewto merchandise subscriptions with all of their available levels of service.Use SubscriptionStoreView to quickly create a custom pagefor a subscription group, like this one.All you need is the subscriptionGroupID, which you can normally findin App Store Connect, but it's now also availablein the StoreKit configuration, right in Xcode.There are many possible customizations that can be easily addedto any of these new view types.For example, check out how changing a few lines of codeto create a custom background can significantly alterthe look of this SubscriptionStoreView.To go along with these new subscription changes, we’re also addingan additional manage subscription sheet to provide a new experienceto how people can interact and choose their subscription in a StoreKit app.Let's take a look at it.Here, you can see the familiar flow to manage subscriptions,which shows the customer a sheet with their current active tiersand provides the option to tap into each oneto see a list of the other ones available in that subscription group.To make this process faster and provide more customization,there is now another view that allows you to skip a stepand jump right into the subscription group you would like to show.You can pick the relevant subscription group in your app's context,if you have more than one, for example, and show what other levels of serviceare available for your customers to choose.This sheet can be used with the same API as the regular one:.manageSubscriptionsSheet.This time, additionally pass the subscriptionGroupID parameter.There is so much more to show you on the topic of creating SwiftUI appswith StoreKit, with lots of other views and customizationyou can apply to make it fit your app's aesthetic.If you would like to learn more,Greg will tell you about it in "Meet StoreKit for SwiftUI."After looking at the new features for in-app purchases in StoreKit,let's see how we can test them using the new tools in StoreKit Testingin Xcode, starting with Xcode 15.With StoreKit Testing in Xcode you can ensure your app using StoreKitprovides a great experience from the time you start building it,even before you set anything up in App Store Connect.This allows you to test, manage, edit, and even create actionsrelated to StoreKit while testing on your Mac,and it is supported on both the simulators and devices.Starting off with the transaction manager, there is new functionalityfor debugging and testing your apps.It now organizes all of your testing apps.In the navigator, you can see all the current connected devicesand simulators that have your current StoreKit apps installedusing a StoreKit configuration for testing.This allows you to test on multiple devices at the same timemuch more easily and quickly, and you are not requiredto run your app to see a history of purchases.Let's jump in and see what that looks like.I have both an iPhone connected to my Mac and a simulator running.And I'm using the new in-development game, Backyard Birds.When you open Xcode, no matter if you have a project opened or not,you can go to Debug, StoreKit, Manage Transactions,and be presented with the transaction manager viewyou’re already familiar with.In the navigator, you can see all the current devices connected to your Mac.In my case, this is the physical iPhone and the simulator.Notice how they both have a few apps showing in this list,including Backyard Birds.These are all apps using StoreKit Testing in Xcodethat you can inspect outside of a debug session.Clicking on an app on either of these devices,you can see a list of StoreKit transactions for that app,and with the details sidebar we showed you last year,you can inspect each one individually.This also works if I open the Xcode project for Backyard Birdsand run it on the simulator, for example.In this case, I can also see which app is actively being debuggedbecause it will have this small indicator next to the app name.This is not all that's new with the transaction manager.I am excited to show you that you now have the ability to make in-app purchasesfor your app right from your Mac using Xcode.Plus, when creating a new purchase,you can also customize various purchase parameters,such as the quantity for a consumable product,or you can pick offer codes for your subscriptions.Let's see how this works in practice using Backyard Birds.You first need to select the app you want to test.Then, click the plus button on the left of the filter barto create a new purchase.The pop-up I am presented with lists all of the available in-app purchasesfor this app.These are the same products we configured in the StoreKit configuration.I am going to purchase a consumable first,so I can select Nutrition Pellet and click Next.Now, I have the opportunity to configure this new purchase,but the default options are also valid if I wanted to skip ahead.I am satisfied with these settings,so let's click Done to complete the purchase using these parameters.Although the app is not running in the simulator,StoreKit received and processed the new purchase.If I look at the transaction list, there is now a new item at the top.Clicking on it, I can inspect the details for this new transaction.Subscriptions are different, however, so let's make another purchase.I am going to again click on the plus button to create a new purchase,and this time, I will searchfor the name of a subscription in this app,then, pick the one I am looking for, and click next.The options to configure the purchase have now changed,because this is a different type of in-app purchase.Some are the same, like the purchase date, but there's also some new ones,so let's go over what they do.The default properties are also valid here, by the way.I have the option to pick an offer code for this subscription,if it has any set up in the StoreKit configuration.Customers have to type in offer codes and promotions,but to make testing easier, we provide a list of available offersfor this productID.I would like to change the purchase date in this caseand set it to exactly one year ago,as if I had first subscribed to this serviceduring last year's WWDC.Next, I can choose if this subscription should renew automaticallyor only remain subscribed for exactly one subscription period,which, in the case of this product, would be one month.I would like to keep automatic renewals enabledso I can test how my app handles active subscriptionsbefore I even start using it.Let's click Done to complete the purchaseand look at the results by filtering the transaction list.As expected, I have one renewal for each month since last year.These are all currently marked as unfinished,because the app wasn’t running and didn’t get a chance to receive them,so I am going to run it in the simulatorand see that I now have access to the Backyard Birds Pass.The new features in the transaction manager work with all devicesand platforms that already support StoreKit Testing in Xcode,beginning with iOS 17 and macOS 14.And they are also supported on other platforms,including iPadOS, watchOS, and tvOS.If you are running an older version of the operating system,nothing changes for you:the transaction manager is still compatiblewith all the same features as before when using an active debug session.Next, I would like to introduce a new featurein the StoreKit configuration that allows for more in-depth testingof how your StoreKit app behaves in different scenarios.To demonstrate this, I am going to open the Xcode projectfor Backyard Birds and go to the StoreKit configuration.There is now a new item above the configured in-app purchasescalled Configuration Settings.This is a new menu we added to provide configurable optionsfor your app's test environment,some that you might already be familiar with,and some new ones starting with Xcode 15.This first and the second sections cover all the existing options,like the default storefront and the locale your app should usefor pricing and availability,and others such as the speed of subscription renewalsor the ability to force ask to buy, for example.In prior versions of Xcode, you can find these in the Editor menuwhen your StoreKit configuration is opened,and they are still there and can be used interchangeably.While we are talking about StoreKit Testing options,there are new subscription renewal rates we added this year in iOS 16.4.These are designed to change the subscription expirationon a per-renewal basis, helping you generateconsistent renewals quicker than the subscription's actual duration.This is really helpful for quick and reliable testingof the long-term state of your subscription.You can find these new configurable rates in both the Editor menuand in the StoreKit configuration settings in Xcode 15.The third section in the StoreKit configuration settingscovers options you can use to simulate StoreKit errors in your app,which was a highly requested feature by many of you.It expands on the Fail Transactions submenuthat used to be in the Editor menu,and it brings support for more StoreKit APIs and error types.Each option represents a StoreKit 2 API your app might be usingand allows you to pick an error that API should throwevery time when it's called by your app.Numerous APIs are supported by this feature.You can test product loading issues, purchase failures,receipt and transaction verification problems,refund requests, and so many more.Let's see what this looks like in practice.I have the Xcode project for Backyard Birds opened on the leftand the app running in the simulator on the right.In the StoreKit configuration, I can enable purchase errors using the checkboxnext to the Purchase API nameand choose the error it should throw.I would like to test how the app handles purchaseswhen the customer changes storefronts, so I will pick Product Unavailable.This file automatically saves on edit, and it also syncs to your devicewhen the app is running, so you can test the change immediatelywithout needing to re-run your app.Let's try to purchase a product and see what happens.As expected, it fails.It tells me I cannot purchase this productand I should contact the developer for more information.Let's now disable purchase errorsand try this again to ensure it completes successfully this time.With these steps, I have now effectively testedthat this app's code can handle these kinds of errorswhen making a purchase, if they should ever occur.This method can be applied to any of the APIs and error optionsin the StoreKit configuration settings to cover multiple scenariosand ensure your app is robust.These errors are all part of StoreKit,and you might have encountered them already.Each one of them represents a clear case of a failure in your app.And that is all the new features for StoreKit Testing in Xcode.Today, I showed how to inspect and manage transactionson multiple devices outside of a debug session,how to purchase products from the transaction managerto test how your app handles existing purchases,and how to simulate StoreKit errors to cover many possible failure scenarios.All of these new features in Xcode are also available in codeusing the StoreKit Test framework to write unit tests for your app,so you can write automation that performs all the same tasks.Let's have a look at the new APIs to create off-device purchasesand set simulated errors in an XCTest session.To create new in-app purchases, there is a new Swift API in StoreKitTestthat works the same way as the StoreKit purchase(_:) API,with the same purchase options as well.To support the new purchase features, like changing the purchase date,we also added new purchase options only for testing.Let's look at an example.After setting up an SKTestSession,I am making an off-device purchase for a subscriptionand overriding the purchase date to a year ago from today.This is the same purchase I made in the transaction manager,and it behaves exactly the same way, allowing you to createrepeatable results and automate the testing for your app.There are also some new APIs in StoreKitTestfor simulating StoreKit errors in an SKTestSession,and they work the same way as the simulated errorsin the StoreKit configuration settings.After creating your test session,you can call setSimulatedError with the error type you would like to testand the StoreKit API it should be simulated for.In this example, I am choosing to simulatea network error for the loadProducts API.Any time I call the loadProducts API in this test,it will always throw the same error.To disable the simulated failure, use the same setter APIand pass nil in place of the error type.Lastly, there are also APIs for the new subscription renewal rates.These can be accessed the same way as the existing ones,via a member in SKTestSession called timeRate.In this example test to make a subscription purchase,I added an extra line of code to set a faster renewal rateand generate multiple renewals quickly.A lot of new StoreKit and StoreKit Testing in Xcode features were covered today.In StoreKit, there are new APIs to support promoting in-app purchases,the data model for Transaction and RenewalInfo got some enhancementsto give you more valuable information on hand,and there is a new message type you can listen forto handle billing issues.The new StoreKit views in SwiftUI are a wonderful toolto quickly build apps that support product merchandising,and they don't require any extra code to work across all devices.And finally, you can validate all the StoreKit features in your appusing great tools provided with StoreKit Testing in Xcode.StoreKit 2 is packed with many great featuresthat allow you to build awesome apps and grow your business.We have added many tools that take full advantage of Swift,and with new APIs that are simple but powerful,you have the opportunity to focus moreon the experience you're building for your customers.Any app that want to merchandise products and subscriptionscan now be built using StoreKit 2.If you aren't using StoreKit 2 yet, give it a try, and if you are,let us know what you think of the new features I showed you today.Use the new in-app purchase merchandising viewsin your existing app to further customize the experience,or create a new one using exclusively these new APIs.And with StoreKit Testing in Xcode, you can put your code to the testand ensure everything works well and as expectedto provide your customers with the best experience under all conditions.For more information about other StoreKit features,check out these sessions linked below.We look forward to seeing what you create using StoreKit 2.Thank you for watching.

♪ ♪Ricky: Hello, I'm Ricky, and welcometo "What's new in StoreKit 2 and StoreKit Testing in Xcode."In this session, I'll talk about the new featureswe're bringing to StoreKit this year,as well as the enhancements to the testing experience in Xcode.StoreKit 2 was first introduced at WWDC in 2021,with new and more flexible APIs using Swift.This year, I am excited to show youthe new features that make StoreKit 2 even better.First, I will review the new StoreKit framework features,then, I'll share some updates for building SwiftUI apps using StoreKit,and finally, I will cover what's new in StoreKit Testing in Xcode.I am excited to introduce a new Swift APIfor managing promoted in-app purchases, available starting in iOS 16.4.Promoted in-app purchases is a feature that allows youto merchandise your products on your App Store product page,each with a dedicated promotional image.Promoting your in-app purchases is a great wayto increase your product's visibility,and you can easily set up promoted purchases in App Store Connect.To learn more about configuring promoted in-app purchases,check out "What's new in App Store Connect."Since promoted in-app purchases are listed on the App Store,when a customer buys a promoted product,their interaction starts here by tapping the purchase button.Then, the App Store sends the purchase data to your appwhere you can listen for this information and prompt them to complete the purchase.To listen for promoted purchases, use the Swift async sequencewhich receives a new purchase intent every time a customer initiatesthe purchase for a promoted product in the App Store.First, create a listener to receive purchase intentsusing PurchaseIntent.intents.Every time the sequence receives a new object,it contains the StoreKit Product associated with the purchase.You can prompt your customers to purchase these products as usualby calling purchase(), which displays the familiar payment sheetand allows them to complete the interaction there.If your app isn't ready to complete a purchase,you can also save the intent locally and defer it.You can always process it later.

Another feature of promoting in-app purchasesis being able to customize how your products are displayed locallyon the current device.For example, if a customer buys one of these products,you can hide it, so the App Store doesn't show it again when they browse or search.You can also change the product order, or the subset of products featured,based on a current state in your app,for example, a level advancement in a game.

To cover all of these cases, I am excited to show yousome new Swift APIs that you can use to customize the orderand the visibility of your promoted in-app purchases.Let's see a quick demonstration.

After importing StoreKit, you can check the current promotion orderwith Product.PromotionInfo.currentOrder.This returns a sequence of PromotionInfo objects,in the order that is currently set.If this list is empty, it means there are no local overridesset for this device, and the products people seein the App Store are in the same order that you configured in App Store Connect.Each object in this sequence contains informationregarding a promoted product in your app.To set a custom order of promotions, you can use theProduct.PromotionInfo.updateProductOrder APIand pass a list of product identifiersin the order you want them to appear in the App Store for this device.You can also hide and show products without having to set a whole new order.This can be done by changing the visibility propertyassociated with promoted in-app purchases.

The visibility state can be visible, hidden, or default,which follows the settings you configure in App Store Connectand applies to all devices that don't have a local override set by your app.Let's see how we can change this in code.

The visibility value can be changed in a couple of different ways.Your app can callthe Product.PromotionInfo. updateProductVisibility APIand change the value for a single product by passing both the new visibility stateand the identifier of that in-app purchase.Alternatively, you can also change the visibility valueby setting a member property on each PromotionInfo object.Then, to save the changes, call update() on that same object you just modified.And that is everything you need to start using promoted in-app purchaseswith StoreKit 2.Now, I would like to show you some of the enhancements we madeto the core data model in StoreKit 2.

These models are useful for managing your in-app purchasesand related information, for example, the purchase dateand the subscription status.Let's dive into the new fields we're adding to the Transactionand RenewalInfo data models, which bring great improvements many of you requested.

The first new field is storefront, and it appearsin the Transaction model along with storefrontCountryCode.The next new field is called reason.It tells you whether a customer initiated a purchase,or if the transaction is an automatic subscription renewal.In the RenewalInfo model under Product.SubscriptionInfo,there is a new member called nextRenewalDate.This tells you when this subscription renewal will be processed.All of these new fields are available for apps you build with Xcode 15,and although initially released with iOS 17,most of them also work retroactively with prior versions of iOS as wellwhen you are using StoreKit 2.Next, I'd like to talk about StoreKit Messagesand the great new feature we just added.We introduced the Message API last year at WWDC 2022as a way for the App Store to notify your customers of important information.Messages have a Reason value that tells you the purpose of the message.Your app can choose whether to defer or suppress messages.For example, you may want to defer a messageif displaying it would interrupt your customers during an interaction flow.Otherwise, StoreKit displays any active messages automaticallywhen your app launches.This year, we added a new message reason called billingIssue.This message is available starting in iOS 16.4.The App Store sends this message when a subscription fails to renewbecause of a billing problem.StoreKit displays a Billing Problem sheet,and customers can resolve the issue without leaving your app.This new property is already enabled in sandbox to give you time to test it.Please check back on the Apple Developer website later this yearfor updates on when this will be enabled for all customers.When the App Store fails to renew a subscription,the subscription goes into a Billing Retry state.To learn about how to test this feature in sandbox,please refer to the WWDC session on testing in-app purchases.Now, let's review some security related updates.In order to keep StoreKit up-to-date with modern security practices,we're migrating our receipt signing certificatefrom using SHA-1 to SHA-256 for the "original StoreKit" receipt.Modern versions of cryptographic libraries, like OpenSSL,already support SHA-256, but if your app performs on-device receipt validation,it is important you verify that it handles the new certificate properly.The new SHA-256 signing certificate will be used to sign receipts in sandboxstarting on June 20th, and you will be able to teston devices running iOS 16.6 and macOS 13.5 or later.After August 14th, the new certificate will be usedto sign receipts for all new apps and app updatessubmitted to the App Store.For more details on this timeline, you can check the Apple Developer website.If your app uses StoreKit 2, you don't need to do anything.StoreKit 2's Signed Transaction, Renewal Info,and App Transaction already use SHA-256 today.And if you use App Store server APIs to do receipt validation,you also don't need to make any changes,since we handle the new format automatically.Next, I am excited to show you a whole new set of features for StoreKitthat make it very easy and quick to merchandise in-app purchasesin your app, using SwiftUI.There are new APIs to create SwiftUI views for single in-app purchases,whole stores of products, and even some custom ones specific to subscriptions.These function like normal SwiftUI views and require minimal code to implement,allowing you to get up and running with your app as quick as possible.Let's take a look at these new views.With this product view, you can represent a single in-app purchase,complete with its localized title, description,and even the optional promotional image.You can create it by passing product identifier to ProductView.And there is no need to load the StoreKit product either.You can just use the productID string.StoreKit and SwiftUI will take care of the rest.There is also a new view to display a whole collection of products,like a store right in your app.Instead of passing a single product identifier,you can use a collection of productIDs in combination with StoreViewto create a list of products to merchandise,which you can then further customize using SwiftUI components.The StoreView is a great way to get your app or game startedand support in-app purchases, since it requiresonly a few lines of code to set up, like shown here.Last but not least, there is also a new viewto merchandise subscriptions with all of their available levels of service.Use SubscriptionStoreView to quickly create a custom pagefor a subscription group, like this one.All you need is the subscriptionGroupID, which you can normally findin App Store Connect, but it's now also availablein the StoreKit configuration, right in Xcode.There are many possible customizations that can be easily addedto any of these new view types.For example, check out how changing a few lines of codeto create a custom background can significantly alterthe look of this SubscriptionStoreView.To go along with these new subscription changes, we’re also addingan additional manage subscription sheet to provide a new experienceto how people can interact and choose their subscription in a StoreKit app.Let's take a look at it.

Here, you can see the familiar flow to manage subscriptions,which shows the customer a sheet with their current active tiersand provides the option to tap into each oneto see a list of the other ones available in that subscription group.To make this process faster and provide more customization,there is now another view that allows you to skip a stepand jump right into the subscription group you would like to show.You can pick the relevant subscription group in your app's context,if you have more than one, for example, and show what other levels of serviceare available for your customers to choose.This sheet can be used with the same API as the regular one:.manageSubscriptionsSheet.This time, additionally pass the subscriptionGroupID parameter.

There is so much more to show you on the topic of creating SwiftUI appswith StoreKit, with lots of other views and customizationyou can apply to make it fit your app's aesthetic.If you would like to learn more,Greg will tell you about it in "Meet StoreKit for SwiftUI."After looking at the new features for in-app purchases in StoreKit,let's see how we can test them using the new tools in StoreKit Testingin Xcode, starting with Xcode 15.With StoreKit Testing in Xcode you can ensure your app using StoreKitprovides a great experience from the time you start building it,even before you set anything up in App Store Connect.This allows you to test, manage, edit, and even create actionsrelated to StoreKit while testing on your Mac,and it is supported on both the simulators and devices.Starting off with the transaction manager, there is new functionalityfor debugging and testing your apps.It now organizes all of your testing apps.In the navigator, you can see all the current connected devicesand simulators that have your current StoreKit apps installedusing a StoreKit configuration for testing.This allows you to test on multiple devices at the same timemuch more easily and quickly, and you are not requiredto run your app to see a history of purchases.Let's jump in and see what that looks like.I have both an iPhone connected to my Mac and a simulator running.And I'm using the new in-development game, Backyard Birds.When you open Xcode, no matter if you have a project opened or not,you can go to Debug, StoreKit, Manage Transactions,and be presented with the transaction manager viewyou’re already familiar with.In the navigator, you can see all the current devices connected to your Mac.In my case, this is the physical iPhone and the simulator.Notice how they both have a few apps showing in this list,including Backyard Birds.These are all apps using StoreKit Testing in Xcodethat you can inspect outside of a debug session.Clicking on an app on either of these devices,you can see a list of StoreKit transactions for that app,and with the details sidebar we showed you last year,you can inspect each one individually.This also works if I open the Xcode project for Backyard Birdsand run it on the simulator, for example.

In this case, I can also see which app is actively being debuggedbecause it will have this small indicator next to the app name.This is not all that's new with the transaction manager.I am excited to show you that you now have the ability to make in-app purchasesfor your app right from your Mac using Xcode.Plus, when creating a new purchase,you can also customize various purchase parameters,such as the quantity for a consumable product,or you can pick offer codes for your subscriptions.

Let's see how this works in practice using Backyard Birds.You first need to select the app you want to test.Then, click the plus button on the left of the filter barto create a new purchase.The pop-up I am presented with lists all of the available in-app purchasesfor this app.These are the same products we configured in the StoreKit configuration.I am going to purchase a consumable first,so I can select Nutrition Pellet and click Next.

Now, I have the opportunity to configure this new purchase,but the default options are also valid if I wanted to skip ahead.I am satisfied with these settings,so let's click Done to complete the purchase using these parameters.

Although the app is not running in the simulator,StoreKit received and processed the new purchase.If I look at the transaction list, there is now a new item at the top.Clicking on it, I can inspect the details for this new transaction.Subscriptions are different, however, so let's make another purchase.I am going to again click on the plus button to create a new purchase,and this time, I will searchfor the name of a subscription in this app,then, pick the one I am looking for, and click next.

The options to configure the purchase have now changed,because this is a different type of in-app purchase.Some are the same, like the purchase date, but there's also some new ones,so let's go over what they do.The default properties are also valid here, by the way.

I have the option to pick an offer code for this subscription,if it has any set up in the StoreKit configuration.Customers have to type in offer codes and promotions,but to make testing easier, we provide a list of available offersfor this productID.I would like to change the purchase date in this caseand set it to exactly one year ago,as if I had first subscribed to this serviceduring last year's WWDC.Next, I can choose if this subscription should renew automaticallyor only remain subscribed for exactly one subscription period,which, in the case of this product, would be one month.I would like to keep automatic renewals enabledso I can test how my app handles active subscriptionsbefore I even start using it.Let's click Done to complete the purchaseand look at the results by filtering the transaction list.

As expected, I have one renewal for each month since last year.These are all currently marked as unfinished,because the app wasn’t running and didn’t get a chance to receive them,so I am going to run it in the simulatorand see that I now have access to the Backyard Birds Pass.

The new features in the transaction manager work with all devicesand platforms that already support StoreKit Testing in Xcode,beginning with iOS 17 and macOS 14.And they are also supported on other platforms,including iPadOS, watchOS, and tvOS.If you are running an older version of the operating system,nothing changes for you:the transaction manager is still compatiblewith all the same features as before when using an active debug session.Next, I would like to introduce a new featurein the StoreKit configuration that allows for more in-depth testingof how your StoreKit app behaves in different scenarios.To demonstrate this, I am going to open the Xcode projectfor Backyard Birds and go to the StoreKit configuration.

There is now a new item above the configured in-app purchasescalled Configuration Settings.This is a new menu we added to provide configurable optionsfor your app's test environment,some that you might already be familiar with,and some new ones starting with Xcode 15.This first and the second sections cover all the existing options,like the default storefront and the locale your app should usefor pricing and availability,and others such as the speed of subscription renewalsor the ability to force ask to buy, for example.In prior versions of Xcode, you can find these in the Editor menuwhen your StoreKit configuration is opened,and they are still there and can be used interchangeably.

While we are talking about StoreKit Testing options,there are new subscription renewal rates we added this year in iOS 16.4.These are designed to change the subscription expirationon a per-renewal basis, helping you generateconsistent renewals quicker than the subscription's actual duration.This is really helpful for quick and reliable testingof the long-term state of your subscription.You can find these new configurable rates in both the Editor menuand in the StoreKit configuration settings in Xcode 15.The third section in the StoreKit configuration settingscovers options you can use to simulate StoreKit errors in your app,which was a highly requested feature by many of you.It expands on the Fail Transactions submenuthat used to be in the Editor menu,and it brings support for more StoreKit APIs and error types.Each option represents a StoreKit 2 API your app might be usingand allows you to pick an error that API should throwevery time when it's called by your app.Numerous APIs are supported by this feature.You can test product loading issues, purchase failures,receipt and transaction verification problems,refund requests, and so many more.Let's see what this looks like in practice.

I have the Xcode project for Backyard Birds opened on the leftand the app running in the simulator on the right.In the StoreKit configuration, I can enable purchase errors using the checkboxnext to the Purchase API nameand choose the error it should throw.

I would like to test how the app handles purchaseswhen the customer changes storefronts, so I will pick Product Unavailable.

This file automatically saves on edit, and it also syncs to your devicewhen the app is running, so you can test the change immediatelywithout needing to re-run your app.Let's try to purchase a product and see what happens.

As expected, it fails.It tells me I cannot purchase this productand I should contact the developer for more information.

Let's now disable purchase errorsand try this again to ensure it completes successfully this time.

With these steps, I have now effectively testedthat this app's code can handle these kinds of errorswhen making a purchase, if they should ever occur.This method can be applied to any of the APIs and error optionsin the StoreKit configuration settings to cover multiple scenariosand ensure your app is robust.These errors are all part of StoreKit,and you might have encountered them already.Each one of them represents a clear case of a failure in your app.And that is all the new features for StoreKit Testing in Xcode.Today, I showed how to inspect and manage transactionson multiple devices outside of a debug session,how to purchase products from the transaction managerto test how your app handles existing purchases,and how to simulate StoreKit errors to cover many possible failure scenarios.

All of these new features in Xcode are also available in codeusing the StoreKit Test framework to write unit tests for your app,so you can write automation that performs all the same tasks.Let's have a look at the new APIs to create off-device purchasesand set simulated errors in an XCTest session.

To create new in-app purchases, there is a new Swift API in StoreKitTestthat works the same way as the StoreKit purchase(_:) API,with the same purchase options as well.To support the new purchase features, like changing the purchase date,we also added new purchase options only for testing.Let's look at an example.After setting up an SKTestSession,I am making an off-device purchase for a subscriptionand overriding the purchase date to a year ago from today.This is the same purchase I made in the transaction manager,and it behaves exactly the same way, allowing you to createrepeatable results and automate the testing for your app.There are also some new APIs in StoreKitTestfor simulating StoreKit errors in an SKTestSession,and they work the same way as the simulated errorsin the StoreKit configuration settings.After creating your test session,you can call setSimulatedError with the error type you would like to testand the StoreKit API it should be simulated for.In this example, I am choosing to simulatea network error for the loadProducts API.Any time I call the loadProducts API in this test,it will always throw the same error.To disable the simulated failure, use the same setter APIand pass nil in place of the error type.Lastly, there are also APIs for the new subscription renewal rates.These can be accessed the same way as the existing ones,via a member in SKTestSession called timeRate.In this example test to make a subscription purchase,I added an extra line of code to set a faster renewal rateand generate multiple renewals quickly.A lot of new StoreKit and StoreKit Testing in Xcode features were covered today.In StoreKit, there are new APIs to support promoting in-app purchases,the data model for Transaction and RenewalInfo got some enhancementsto give you more valuable information on hand,and there is a new message type you can listen forto handle billing issues.The new StoreKit views in SwiftUI are a wonderful toolto quickly build apps that support product merchandising,and they don't require any extra code to work across all devices.And finally, you can validate all the StoreKit features in your appusing great tools provided with StoreKit Testing in Xcode.StoreKit 2 is packed with many great featuresthat allow you to build awesome apps and grow your business.We have added many tools that take full advantage of Swift,and with new APIs that are simple but powerful,you have the opportunity to focus moreon the experience you're building for your customers.Any app that want to merchandise products and subscriptionscan now be built using StoreKit 2.If you aren't using StoreKit 2 yet, give it a try, and if you are,let us know what you think of the new features I showed you today.Use the new in-app purchase merchandising viewsin your existing app to further customize the experience,or create a new one using exclusively these new APIs.And with StoreKit Testing in Xcode, you can put your code to the testand ensure everything works well and as expectedto provide your customers with the best experience under all conditions.For more information about other StoreKit features,check out these sessions linked below.We look forward to seeing what you create using StoreKit 2.Thank you for watching.

1:42 -Create a listener for promoted in-app purchases

2:57 -Check promotion order

3:26 -Set a promotion order

4:02 -Update promotion visibility

4:17 -Update promotion visibility (alternative method)

8:32 -Product view

8:52 -Store view

9:19 -Subscription view

21:09 -Simulated off-device purchase using StoreKitTest

21:48 -Set a simulated purchase error when loading products

22:24 -Set a faster subscription renewal rate in a test session

## Code Samples

```swift
// Create a listener for promoted in-app purchases


import
 StoreKit


let
 promotedPurchasesListener 
=
 
Task
 {
    
for
 
await
 promotion 
in
 
PurchaseIntent
.intents {
        
// Process promotion

        
let
 product 
=
 promotion.product

        
// Purchase promoted product

        
do
 {
            
let
 result 
=
 
try
 
await
 product.purchase()
            
// Process result

        }
        
catch
 {
            
// Handle error

        }
    }
}
```

```swift
// Check promotion order


import
 StoreKit


do
 {
    
let
 promotions 
=
 
try
 
await
 
Product
.
PromotionInfo
.currentOrder

    
if
 promotions.isEmpty {
        
// No local promotion order set

    }

    
for
 promotion 
in
 promotions {
        
let
 productID 
=
 promotion.productID
        
let
 productVisibility 
=
 promotion.visibility
        
// Check promoted products

    }
}

catch
 {
    
// Handle error

}
```

```swift
// Set a promotion order


import
 StoreKit


let
 newPromotionOrder: [
String
] 
=
 [
    
"acorns.individual"
,
    
"nectar.cup"
,
    
"sunflowerseeds.pile"

]


do
 {
    
try
 
await
 
Product
.
PromotionInfo
.updateProductOrder(byID: newPromotionOrder)
}

catch
 {
    
// Handle error

}
```

```swift
// Update promotion visibility


import
 StoreKit


// Hide “acorns.individual”


do
 {
    
try
 
await
 
Product
.
PromotionInfo
.updateProductVisibility(.hidden, for: 
"acorns.individual"
)
}

catch
 {
    
// Handle error

}
```

```swift
// Update promotion visibility


import
 StoreKit


do
 {
  
let
 promotions 
=
 
try
 
await
 
Product
.
PromotionInfo
.currentOrder

  
// Hide the first product

  
if
 
var
 firstPromotion 
=
 promotions.first {
    firstPromotion.visibility 
=
 .hidden
    
try
 
await
 firstPromotion.update()
  }
}

catch
 {
  
// Handle error

}
```

```swift
// Product view


import
 SwiftUI

import
 StoreKit


struct
 
BirdFoodShop
: 
View
 {
    
let
 productID: 
String

    
let
 productImage: 
String


    
var
 body: 
some
 
View
 {
        
ProductView
(id: productID) {
            
BirdFoodProductIcon
(for: productID)
        }
        .productViewStyle(.large)
    }
}
```

```swift
// Store view


import
 SwiftUI

import
 StoreKit


struct
 
BirdFoodShop
: 
View
 {
    
let
 productIDs: [
String
]

    
var
 body: 
some
 
View
 {
        
StoreView
(ids: productIDs) { product 
in

            
BirdFoodIcon
(productID: product.id)
        }
    }
}
```

```swift
// Subscription view


import
 SwiftUI

import
 StoreKit


struct
 
BackyardBirdsPassShop
: 
View
 {
    
let
 groupID: 
String


    
var
 body: 
some
 
View
 {
        
SubscriptionStoreView
(groupID: groupID)
    }
}
```

```swift
// Simulated off-device purchase using StoreKitTest


import
 StoreKit

import
 StoreKitTest


func
 
testSubscriptionRenewal
() 
async
 
throws
 {
    
let
 session 
=
 
try
 
SKTestSession
(configurationFileNamed: 
"Store"
)

    
let
 oneYearInterval: 
TimeInterval
 
=
 (
365
 
*
 
24
 
*
 
60
 
*
 
60
)
    
let
 transaction 
=
 
try
 
await
 session.buyProduct(
        identifier: 
"birdpass.individual"
,
        options: [
            .purchaseDate(
Date
.now 
-
 oneYearInterval)
        ]
    )

    
// Inspect transaction

}
```

```swift
// Set a simulated purchase error when loading products


import
 StoreKit

import
 StoreKitTest


func
 
testLoadProducts
() 
async
 
throws
 {
    
let
 session 
=
 
try
 
SKTestSession
(configurationFileNamed: 
"Store"
)
    
let
 productIDs 
=
 [
        
"acorns.individual"
,
        
"nectar.cup"

    ]

    
// Set a simulated error, then load products, expecting an error

    session.setSimulatedError(.generic(.networkError), forAPI: .loadProducts)
    
do
 {
        
_
 
=
 
try
 
await
 
Product
.products(for: productIDs)
        
XCTFail
(
"Expected a network error"
)
    }
    
catch
 
StoreKitError
.networkError(
_
) {
        
// Expected error thrown, continue...

    }
    
// Disable simulated error

    session.setSimulatedError(
nil
, forAPI: .loadProducts)
}
```

```swift
// Set a faster subscription renewal rate in a test session


import
 StoreKit

import
 StoreKitTest


func
 
testSubscriptionRenewal
() 
async
 
throws
 {
    
let
 session 
=
 
try
 
SKTestSession
(configurationFileNamed: 
"Store"
)

    
// Set renewals to expire every minute

    session.timeRate 
=
 .oneRenewalEveryMinute

    
let
 transaction 
=
 
try
 
await
 session.buyProduct(identifier: 
"birdpass.individual"
)

    
// Wait for renewals and inspect transactions

}
```


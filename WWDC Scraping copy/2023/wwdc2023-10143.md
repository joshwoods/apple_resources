# Wwdc2023 10143

## Transcript

More Videos

Streaming is available in most browsers,and in the Developer app.

About

Transcript

Meet the App Store Server LibraryDiscover the App Store Server Library and learn how you can take advantage of resources and configurations for your apps. We'll show you how to set up the library, call the App Store Server API, verify App Store Server Notifications, and use app receipts. Explore insights and best practices for using App Store Server API endpoints, verifying App Store signed data, and migrating away from verifyReceipt.ResourcesApp Store Server APIApple App Store Server Java LibraryApple App Store Server Node.js LibraryApple App Store Server Python LibraryApple App Store Server Swift LibraryApple Certificate AuthorityIn-App Purchase - Promotional offersOnline Certificate Status Protocol - OCSPSubmit feedbackHD VideoSD VideoRelated VideosWWDC23Explore testing in-app purchasesWhat’s new in App Store server APIsWWDC19Subscription Offers Best Practices

Discover the App Store Server Library and learn how you can take advantage of resources and configurations for your apps. We'll show you how to set up the library, call the App Store Server API, verify App Store Server Notifications, and use app receipts. Explore insights and best practices for using App Store Server API endpoints, verifying App Store signed data, and migrating away from verifyReceipt.

App Store Server API

Apple App Store Server Java Library

Apple App Store Server Node.js Library

Apple App Store Server Python Library

Apple App Store Server Swift Library

Apple Certificate Authority

In-App Purchase - Promotional offers

Online Certificate Status Protocol - OCSP

Submit feedback

HD VideoSD Video

HD Video

SD Video

Explore testing in-app purchases

What’s new in App Store server APIs

Subscription Offers Best Practices

Search this video…♪ ♪Dave: Hi, I'm Dave Wendland,a developer advocate for our App Store Commerce team.My colleague Alex and I will discuss the new App Store Server Libraryand how its set of functions will enable your serverto utilize an array of capabilitiesfrom generating a JWT for the App Store Server APIto migrating away from the verifyReceipt endpoint for purchase validation.When we look back,the App Store launched in 2008 when apps were either free or paid.Soon, we added in-app purchases, and ever since then,the developer community has grown in size and complexity across the globe.The App Store continues to roll out updates for developers and customersto support the global and dynamic mobile app ecosystem.In 2021, we released the next era of StoreKit toolswith the revamped StoreKit Framework, App Store Server API,and App Store Server Notifications v2.With more updates in 2022 and again this year at WWDC 2023.These tools provide transactionsand status in a signed JWS format.And they are designed to provide developers robust information,client side and server side.This set of APIs inspired the App Store Server Library.We are proud to share that this library provides a set of functions,which will make it easier for our developer community to adoptand integrate the latest APIs available today and in the future.The library beta launch supports four languages:Swift, Java, Node, and Python,giving you the flexibility to choose the languagethat best supports your backend and expertise.The App Store server libraryfor each language is available on GitHub,and we look forward to your feedbackand contributions.I've broken down what the library has to offerinto four key capabilities.The first and most robust capability is with the App Store Server API.By streamlining the JWT creation,you can use any of the dozen different endpointsthe App Store Server API offers.Next is a core capability to verify JWS signed data,so you can ensure your transactions and server notificationshave been generated and signed by Apple.Next is the extract receipt transaction utility.This simple tool extracts a transaction identifier from an app receipt.Doing this can alleviate your need to use the verifyReceipt endpointand enable you to migrate to the App Store Server APIfor your purchase validation and additional capabilities.This provides a clear path to support your current and legacy app versions.Lastly, is the utility to generate subscription promotional offer signatures.This utility does the heavy lifting of signing and generating your offersusing your in-app purchase private key.If you are not familiar with the subscription promotional offers,learn more in our session titled "Subscription Offers Best Practices."Now lets deep dive into three of those core library functions.App Store Server API, signed data verification,and moving to the App Store Server API.Let's get started with the App Store Server API.The foundation to the Server API is the Get Transaction History endpoint.By simply using a transaction ID, this API provides a customer'scomplete in-app purchase transaction history.And it has even more capabilities beyond this endpoint.This API has a dozen endpoints,all of which require a form of authentication,a JSON Web Token.Generating your JWT is a critical step,and if you aren't familiar with this process,that is where the library comes in.Over to Alex to demonstrate getting the library setup for usewith the App Store Server API.Alex: Hello, I'm Alex Baker, an App Store Server Engineer.I'll demonstrate how to get started with the App Store Server Libraryand how you can use it to call the App Store Server API.This demo will walk through collecting the necessary pieces of informationto configure the App Store Server Library,then show an example of creating an API client and calling the API.I am starting in App Store Connect to get information I'll needto use the App Store Server API with the library.Go to the Users and Access module...Then the Keys tab, then the In-App Purchase option.There are a few pieces of useful information here.First, the issuer ID.Next, I am going to generate a new private key.I'll give it a name, then click Generate.Generating the key provides two pieces of information:The key ID and the option to download the private key.Downloading is only possible once.Switching to the Apple Public Key infrastructure website,focus on the Apple Root Certificates section in the upper left.Download the root certificates.Here is a simple Java project using the Gradle build system.First, add a dependency on the App Store Server Library.Moving to the ExampleApp class,here are the pieces of information I obtained earlier,the issuerId, the keyId, and the private key.Additionally, store the bundleId of the app--in this demonstration, I am using sandbox--and store the appropriate enum value.Using these pieces of information, instantiate an AppStoreServerAPIClient.With this client, call the Request a Test Notification endpoint,which requests the App Store server send a notification with type TESTto the URL you configured in App Store Connect.Last, print the testNotificationToken.Running this, we will see the testNotificationToken printed,and, as expected, we see this token.This demonstrated how to use the App Store Server libraryto simplify using the App Store Server APIand the information you need from App Store Connect.Now back to Dave.Dave: Thank you, Alex.That demo really illustrates how quickly this library gets you set upand generating a JWT for use with the Server API.This library will have a meaningful impactin reducing your implementation timelines when adopting our APIs.While using the library is helpful and simple,there is nothing more criticalthan storing your in-app purchase private key securely.And if you ever think your key has been compromised,generate a new key in App Store Connect anytime.As you begin your development, we do recommend startingwith sandbox and TestFlight transactions.And lastly, be sure to check regularlyfor updated Apple root certificate authorities.Now lets discuss why signed data verificationis a foundational action to your business with in-app purchases.First let's discuss what signed data contains and why it is important.StoreKit Signed data means it was generated and signedby the App Store in a JSON Web Signature formatand contains data about the app purchases, in-app purchases,customer events, and customer subscription status.The two most common signed data payloadsare the JWS Transactionand JWS Renewal Info.Then the appTransaction contains detailson the app version originally purchasedand the version currently installedon device.And then we havethe App Store Server Notifications V2,the notification itself is signed dataand additionally may containa JWS Transaction and JWS Renewal Info.And as a reminder,you will only find this JWS signed datain StoreKit 2 on iOS 15 and laterand in the App Store Server APIand App Store Server Notifications v2.It's recommended that you verifythe JWS signed data after anyof the following events:When delivering or unlocking content on deviceor when your server has received signed data,whether that be from your own app, another server,or App Store server notifications.And lastly, when you receive a response from the App Store server API.Here's Alex to demo how to verify JWS signed dataand how the library handles this for you.Alex: In this section, I'll show how to verify signed datafrom the App Store.I'll describe the verification process you would need to perform.Then, we'll walk through how the App Store Server Library'sSignedDataVerifier class can perform this process for you.I would like to stress that using tools like the App Store Server Libraryis highly advisable when you are not familiar with the RFCs and protocolsbehind the operations I am about to describe.Here is some signed data from the App Store.It looks like there is a lot going on here.Color coding reveals there are three sections.Each section is separated by a periodand is Base64 URL encoded.The first and largest section is the header.Once decoded, the header is a JSON structurewith fields defined by the JWS specification.In this case, our header only has two fields:First, the algorithm, which is always ES256.Next a field called x5c.This is an array of certificates that are used to calculatethe expected public key that signed the JWS.Let's review the certificate chain construction process.The first certificate in the array is the leaf certificate.This certificate's public key signed the JWS.To verify this certificate is from Apple,construct a chain of trust back to a known trusted source,in this case, an Apple root certificate authority.The next certificate in the arrayis the Apple Worldwide Developer Relations intermediate certificate authority.Think of this as a more specialized versionof the Apple Root Certificate Authority focused on developers.The last certificate in the chain is an Apple root certificate authorityso that we understand which Apple authority originated this chain.Reminder, it is important to verify the certificate exactly matchesa root certificate we previously obtainedfrom Apple's Public Key Infrastructure website.The first step is to verifythat each certificate is signedby the previous certificate in the chain.Then perform additionalverification steps,like making sure each certificate hasvalid dates, is properly formatted, etc.Next, validate that these certificatesare from Apple and that their purposeis to sign App Store data,as opposed to an unrelated use case,which would not be validto sign App Store data.To verify the leaf certificate,confirm its purpose by checkingthe presence of the object identifier,or OID, for Mac App Store Receipt Signing.For the intermediate certificate,check that the intermediate authority OIDfor Apple Worldwide Developer Relations.Last, as stated before,make sure the root certificate authorityis one of the certificates you storedas an Apple Root Certificate Authority.Now let's actually decodea leaf certificate and observe howto check these values.Here is the X.509 v3 extensions sectionof a certificate as produced by the OpenSSL x509 command.At the bottom is the OID listed on the previous slide,indicating the certificate's purpose is App Store receipt signing.However, there are some additional fields that are important to check.Here we see the authority information access section,which provides information about the issuer and, importantly,provides information for checking if the certificate was revoked.Using the Online Certificate Status Protocol, or OCSP.check if a certificate has been revokedbefore proceeding with the verification process.The process and cryptographic procedures for doing so are defined in RFC 6960.After verifying the certificate chain,check the JWS is signed by the leaf certificate's public key.Take the leaf certificate from before,extract the public key of the leaf certificate,take the key and original JWS,and pass them to a JWS signature verification function.The verification function checks that the data is signedby the public key and decodes the payload.The process is almost complete,but there is one additional verification step.Here is a decoded App Store Server TEST Notification.The previous steps verified the data came from the App Store.However, also check that the notification is targetedat your correct application and environment.Check the appAppleId and bundleId to confirm the notificationis targeted for your correct application.Check the environment matches the expected environment.Just like the other steps in the verification process,the App Store Server library also checks these when it performs the verification.That completes the process to verify signed data from the App Store.Next, I'll expand my project from earlier to verify signed datausing the SignedDataVerifier class included in the App Store Server Library.The SignedDataVerifier class performs the verification steps previously covered.In this demo, I'll get the test notification that I requested earlier,and then validate and decode the signed notification.There is a small delay between requesting the test notificationand the notification being received on my server.Therefore, add a five-second delay.Next, call the Get Test Notification Status endpointusing the testNotificationToken obtained earlier.Last, print the first few characters of the notification to confirm success.The Get Test Notification Status endpoint returns the resultof the send attempt, as well as the notification payload.The beginning of that payload is what we should see.As expected, I see the first few characters of the notification.Moving on, creating a signed data verifier.This requires three pieces of information,starting with the list of Apple Root certificate authorities.The certificates I downloaded earlier are now in the resources folder.Import the root certificates into a Set.Since I am using sandbox, I don't require an app Apple ID.Pass null instead in sandbox.Last, whether to perform revocation checking.Because the notification was just received,onlineChecks should be true.For notifications received months or years ago,this should be false because the certificates may have expired.Pass these fields into a new SignedDataVerifier.Then, pass in the notification received earlier,print the result, and then run the program.Once the program is complete, the program will displaya verified and decoded notification.Since this is a test notification, this will have a typeof TEST and the app's bundle identifier in the payload,along with a few other fields.As expected, I see a decoded notification of type TEST.I expanded on our previous demo to demonstrate the SignedDataVerifier object.Here’s Dave to review some best practices.Dave: Wow, that really illustrates all the steps requiredto verifying signed dataand how the library can handle that complexity for you,so be sure to utilize the SignedDataVerifierfor your server-side validation.An important reminder: when you verify data,you still need to confirm the app and product identifiersto ensure you are granting or revoking purchasesfor the correct app or service.Lastly, as certificates expire and can be revoked,don't hardcode any certificates,client side or server side, and always validate that they are active.Now we'll review another App Store server utility to assistwith moving your server-side app receipt validationoff the verifyReceipt endpoint and over to the App Store Server API.The App Store Server library offers a utilityto help specifically with this migration and ensures no app is left behind.When considering moving to the App Store Server API,there are many reasons to prioritize this work in your roadmap.The API supports purchase validation and contains additional endpointsuseful for customer support, appeasement,and testing App Store Server Notifications V2.As we continue to make updates and release new properties,these will be released only with the JWS signed data,which is supported by StoreKit 2, App Store Server API,and App Store Server Notifications V2.An additional benefit, the only data you need to record,is an original transaction ID or transaction ID.You no longer need to save base64 encoded receipts in your account system.And with our continued investment in the latest APIs,we have announced that verifyReceipt endpoint is now deprecated.To learn more, check out the session "What's new in App Store server APIs"for a detailed update and guidance.Now here's Alex to share how the App Store server librarywill assist in your migration.Alex?Alex: Thanks, Dave.Now let's walk through a flow diagram for App Receipts.While StoreKit 2 and the App Store Server APIare great tools to use,it is important to support clients on older devicesor users that have not updated recently,and for which only App Receipts may be provided to your server.I'll show how these devices were supported previously,and then how you can continue to support these clientsfollowing verifyReceipt's deprecation.First, the device sends a receipt to your server.In the old model, your server passes this receiptto verifyReceipt,and then receives the decoded receipt.The response contains an originalTransactionId,which is passed to the Get Transaction History endpointin the App Store Server API.The App Store Server returnssigned transactions you useto provide service to the customer.Now that verifyReceipt is deprecated,let's replace this section.The receipt utility in the App Store Server Librarydirectly extracts a transaction ID from a receipt.You pass the transaction ID to the App Store Server API,removing the need to make two round trips.After this, store the revision from the endpoint.This removes the need to re-parse the entire history each time.Because the value extracted from the app receiptmay or may not be an original transaction ID,we are excited to announce that many of our endpoints,including the Get Transaction History endpoint,now support any transaction ID as a parameter,not just an original transaction ID.Now I'll demonstrate extracting transaction IDs for usewith the Get Transaction History endpoint using the App Store Server Library.Here I will take an app receipt, extract a transaction ID,and call the Get Transaction History endpoint using the ID.First, the App Receipt.You can get an App Receipt from a device or an App Store Server Notification V1.I have one here already.Next, create an instance of the ReceiptUtility class.To extract the transaction ID,call the extract transaction ID from app receipt method.Not all receipts will have a transaction ID.It is possible the user doesn't have any purchases.Therefore, add a null check.To provide some more depth to this problem,imagine we want to get information about the most recent consumablesfor this user and exclude revoked consumables.Create a Transaction History Request object,specify that only wanted are products of type CONSUMABLEto exclude revoked transactionsand that the data should be returned in descending order.We need two helper objects, a response variable,and a list of transactions.A do while loop pages through the responsesfrom the transaction history endpoint.If this isn't the first request, fetch the revision tokenfrom the previous response to keep paging through the data.Then, call the Get Transaction History endpoint with the transaction IDfrom the app receipt, the request object, and the revision.Finally, add all the transactions from the response to the transaction list.Repeat this process until the hasMore field is false in the response.Print out the transactions to see the result.Here I see a list of transactions returned from the API.The could be decoded using the SignedDataVerifierfrom the previous demo.Thanks for joining our final demonstrationthat showed how you can use App Receipts with the App Store Server API.Back to Dave to wrap us up.Dave: I'm really excited about the new App Store Server library,and I see these capabilities easing your adoption of our APIsand transitioning to the App Store Server API.Here's a screenshot of the App Store Server APIJava repository on Github.On this page, you can find links to our documentation,submit pull requests, and find examples of how to use the library.You can download the App Store Server library BETA soonand start planning your adoption of the App Store Server API.We look forward to your feedback and feature requests.Please contact us at Feedback Assistant and on Github.Thank you.♪ ♪

♪ ♪Dave: Hi, I'm Dave Wendland,a developer advocate for our App Store Commerce team.My colleague Alex and I will discuss the new App Store Server Libraryand how its set of functions will enable your serverto utilize an array of capabilitiesfrom generating a JWT for the App Store Server APIto migrating away from the verifyReceipt endpoint for purchase validation.

When we look back,the App Store launched in 2008 when apps were either free or paid.Soon, we added in-app purchases, and ever since then,the developer community has grown in size and complexity across the globe.The App Store continues to roll out updates for developers and customersto support the global and dynamic mobile app ecosystem.

In 2021, we released the next era of StoreKit toolswith the revamped StoreKit Framework, App Store Server API,and App Store Server Notifications v2.With more updates in 2022 and again this year at WWDC 2023.These tools provide transactionsand status in a signed JWS format.And they are designed to provide developers robust information,client side and server side.

This set of APIs inspired the App Store Server Library.We are proud to share that this library provides a set of functions,which will make it easier for our developer community to adoptand integrate the latest APIs available today and in the future.The library beta launch supports four languages:Swift, Java, Node, and Python,giving you the flexibility to choose the languagethat best supports your backend and expertise.

The App Store server libraryfor each language is available on GitHub,and we look forward to your feedbackand contributions.I've broken down what the library has to offerinto four key capabilities.The first and most robust capability is with the App Store Server API.By streamlining the JWT creation,you can use any of the dozen different endpointsthe App Store Server API offers.

Next is a core capability to verify JWS signed data,so you can ensure your transactions and server notificationshave been generated and signed by Apple.

Next is the extract receipt transaction utility.This simple tool extracts a transaction identifier from an app receipt.Doing this can alleviate your need to use the verifyReceipt endpointand enable you to migrate to the App Store Server APIfor your purchase validation and additional capabilities.This provides a clear path to support your current and legacy app versions.

Lastly, is the utility to generate subscription promotional offer signatures.This utility does the heavy lifting of signing and generating your offersusing your in-app purchase private key.If you are not familiar with the subscription promotional offers,learn more in our session titled "Subscription Offers Best Practices."Now lets deep dive into three of those core library functions.App Store Server API, signed data verification,and moving to the App Store Server API.Let's get started with the App Store Server API.

The foundation to the Server API is the Get Transaction History endpoint.By simply using a transaction ID, this API provides a customer'scomplete in-app purchase transaction history.And it has even more capabilities beyond this endpoint.This API has a dozen endpoints,all of which require a form of authentication,a JSON Web Token.Generating your JWT is a critical step,and if you aren't familiar with this process,that is where the library comes in.Over to Alex to demonstrate getting the library setup for usewith the App Store Server API.

Alex: Hello, I'm Alex Baker, an App Store Server Engineer.I'll demonstrate how to get started with the App Store Server Libraryand how you can use it to call the App Store Server API.This demo will walk through collecting the necessary pieces of informationto configure the App Store Server Library,then show an example of creating an API client and calling the API.I am starting in App Store Connect to get information I'll needto use the App Store Server API with the library.Go to the Users and Access module...

Then the Keys tab, then the In-App Purchase option.

There are a few pieces of useful information here.First, the issuer ID.Next, I am going to generate a new private key.I'll give it a name, then click Generate.Generating the key provides two pieces of information:The key ID and the option to download the private key.Downloading is only possible once.Switching to the Apple Public Key infrastructure website,focus on the Apple Root Certificates section in the upper left.Download the root certificates.

Here is a simple Java project using the Gradle build system.First, add a dependency on the App Store Server Library.

Moving to the ExampleApp class,here are the pieces of information I obtained earlier,the issuerId, the keyId, and the private key.Additionally, store the bundleId of the app--in this demonstration, I am using sandbox--and store the appropriate enum value.

Using these pieces of information, instantiate an AppStoreServerAPIClient.With this client, call the Request a Test Notification endpoint,which requests the App Store server send a notification with type TESTto the URL you configured in App Store Connect.Last, print the testNotificationToken.Running this, we will see the testNotificationToken printed,and, as expected, we see this token.

This demonstrated how to use the App Store Server libraryto simplify using the App Store Server APIand the information you need from App Store Connect.Now back to Dave.Dave: Thank you, Alex.That demo really illustrates how quickly this library gets you set upand generating a JWT for use with the Server API.This library will have a meaningful impactin reducing your implementation timelines when adopting our APIs.

While using the library is helpful and simple,there is nothing more criticalthan storing your in-app purchase private key securely.And if you ever think your key has been compromised,generate a new key in App Store Connect anytime.As you begin your development, we do recommend startingwith sandbox and TestFlight transactions.And lastly, be sure to check regularlyfor updated Apple root certificate authorities.Now lets discuss why signed data verificationis a foundational action to your business with in-app purchases.First let's discuss what signed data contains and why it is important.StoreKit Signed data means it was generated and signedby the App Store in a JSON Web Signature formatand contains data about the app purchases, in-app purchases,customer events, and customer subscription status.The two most common signed data payloadsare the JWS Transactionand JWS Renewal Info.Then the appTransaction contains detailson the app version originally purchasedand the version currently installedon device.And then we havethe App Store Server Notifications V2,the notification itself is signed dataand additionally may containa JWS Transaction and JWS Renewal Info.

And as a reminder,you will only find this JWS signed datain StoreKit 2 on iOS 15 and laterand in the App Store Server APIand App Store Server Notifications v2.

It's recommended that you verifythe JWS signed data after anyof the following events:When delivering or unlocking content on deviceor when your server has received signed data,whether that be from your own app, another server,or App Store server notifications.And lastly, when you receive a response from the App Store server API.Here's Alex to demo how to verify JWS signed dataand how the library handles this for you.

Alex: In this section, I'll show how to verify signed datafrom the App Store.I'll describe the verification process you would need to perform.Then, we'll walk through how the App Store Server Library'sSignedDataVerifier class can perform this process for you.I would like to stress that using tools like the App Store Server Libraryis highly advisable when you are not familiar with the RFCs and protocolsbehind the operations I am about to describe.Here is some signed data from the App Store.It looks like there is a lot going on here.Color coding reveals there are three sections.Each section is separated by a periodand is Base64 URL encoded.The first and largest section is the header.Once decoded, the header is a JSON structurewith fields defined by the JWS specification.In this case, our header only has two fields:First, the algorithm, which is always ES256.Next a field called x5c.This is an array of certificates that are used to calculatethe expected public key that signed the JWS.Let's review the certificate chain construction process.The first certificate in the array is the leaf certificate.This certificate's public key signed the JWS.To verify this certificate is from Apple,construct a chain of trust back to a known trusted source,in this case, an Apple root certificate authority.

The next certificate in the arrayis the Apple Worldwide Developer Relations intermediate certificate authority.Think of this as a more specialized versionof the Apple Root Certificate Authority focused on developers.The last certificate in the chain is an Apple root certificate authorityso that we understand which Apple authority originated this chain.Reminder, it is important to verify the certificate exactly matchesa root certificate we previously obtainedfrom Apple's Public Key Infrastructure website.

The first step is to verifythat each certificate is signedby the previous certificate in the chain.Then perform additionalverification steps,like making sure each certificate hasvalid dates, is properly formatted, etc.Next, validate that these certificatesare from Apple and that their purposeis to sign App Store data,as opposed to an unrelated use case,which would not be validto sign App Store data.

To verify the leaf certificate,confirm its purpose by checkingthe presence of the object identifier,or OID, for Mac App Store Receipt Signing.For the intermediate certificate,check that the intermediate authority OIDfor Apple Worldwide Developer Relations.Last, as stated before,make sure the root certificate authorityis one of the certificates you storedas an Apple Root Certificate Authority.Now let's actually decodea leaf certificate and observe howto check these values.

Here is the X.509 v3 extensions sectionof a certificate as produced by the OpenSSL x509 command.

At the bottom is the OID listed on the previous slide,indicating the certificate's purpose is App Store receipt signing.However, there are some additional fields that are important to check.

Here we see the authority information access section,which provides information about the issuer and, importantly,provides information for checking if the certificate was revoked.Using the Online Certificate Status Protocol, or OCSP.check if a certificate has been revokedbefore proceeding with the verification process.The process and cryptographic procedures for doing so are defined in RFC 6960.

After verifying the certificate chain,check the JWS is signed by the leaf certificate's public key.Take the leaf certificate from before,extract the public key of the leaf certificate,take the key and original JWS,and pass them to a JWS signature verification function.The verification function checks that the data is signedby the public key and decodes the payload.The process is almost complete,but there is one additional verification step.

Here is a decoded App Store Server TEST Notification.The previous steps verified the data came from the App Store.However, also check that the notification is targetedat your correct application and environment.

Check the appAppleId and bundleId to confirm the notificationis targeted for your correct application.Check the environment matches the expected environment.

Just like the other steps in the verification process,the App Store Server library also checks these when it performs the verification.

That completes the process to verify signed data from the App Store.Next, I'll expand my project from earlier to verify signed datausing the SignedDataVerifier class included in the App Store Server Library.The SignedDataVerifier class performs the verification steps previously covered.

In this demo, I'll get the test notification that I requested earlier,and then validate and decode the signed notification.There is a small delay between requesting the test notificationand the notification being received on my server.Therefore, add a five-second delay.Next, call the Get Test Notification Status endpointusing the testNotificationToken obtained earlier.Last, print the first few characters of the notification to confirm success.The Get Test Notification Status endpoint returns the resultof the send attempt, as well as the notification payload.The beginning of that payload is what we should see.

As expected, I see the first few characters of the notification.Moving on, creating a signed data verifier.This requires three pieces of information,starting with the list of Apple Root certificate authorities.

The certificates I downloaded earlier are now in the resources folder.Import the root certificates into a Set.

Since I am using sandbox, I don't require an app Apple ID.Pass null instead in sandbox.Last, whether to perform revocation checking.Because the notification was just received,onlineChecks should be true.For notifications received months or years ago,this should be false because the certificates may have expired.Pass these fields into a new SignedDataVerifier.Then, pass in the notification received earlier,print the result, and then run the program.

Once the program is complete, the program will displaya verified and decoded notification.Since this is a test notification, this will have a typeof TEST and the app's bundle identifier in the payload,along with a few other fields.

As expected, I see a decoded notification of type TEST.

I expanded on our previous demo to demonstrate the SignedDataVerifier object.Here’s Dave to review some best practices.Dave: Wow, that really illustrates all the steps requiredto verifying signed dataand how the library can handle that complexity for you,so be sure to utilize the SignedDataVerifierfor your server-side validation.An important reminder: when you verify data,you still need to confirm the app and product identifiersto ensure you are granting or revoking purchasesfor the correct app or service.Lastly, as certificates expire and can be revoked,don't hardcode any certificates,client side or server side, and always validate that they are active.Now we'll review another App Store server utility to assistwith moving your server-side app receipt validationoff the verifyReceipt endpoint and over to the App Store Server API.The App Store Server library offers a utilityto help specifically with this migration and ensures no app is left behind.

When considering moving to the App Store Server API,there are many reasons to prioritize this work in your roadmap.The API supports purchase validation and contains additional endpointsuseful for customer support, appeasement,and testing App Store Server Notifications V2.As we continue to make updates and release new properties,these will be released only with the JWS signed data,which is supported by StoreKit 2, App Store Server API,and App Store Server Notifications V2.

An additional benefit, the only data you need to record,is an original transaction ID or transaction ID.You no longer need to save base64 encoded receipts in your account system.And with our continued investment in the latest APIs,we have announced that verifyReceipt endpoint is now deprecated.To learn more, check out the session "What's new in App Store server APIs"for a detailed update and guidance.Now here's Alex to share how the App Store server librarywill assist in your migration.Alex?Alex: Thanks, Dave.Now let's walk through a flow diagram for App Receipts.While StoreKit 2 and the App Store Server APIare great tools to use,it is important to support clients on older devicesor users that have not updated recently,and for which only App Receipts may be provided to your server.I'll show how these devices were supported previously,and then how you can continue to support these clientsfollowing verifyReceipt's deprecation.

First, the device sends a receipt to your server.In the old model, your server passes this receiptto verifyReceipt,and then receives the decoded receipt.

The response contains an originalTransactionId,which is passed to the Get Transaction History endpointin the App Store Server API.

The App Store Server returnssigned transactions you useto provide service to the customer.

Now that verifyReceipt is deprecated,let's replace this section.The receipt utility in the App Store Server Librarydirectly extracts a transaction ID from a receipt.You pass the transaction ID to the App Store Server API,removing the need to make two round trips.After this, store the revision from the endpoint.This removes the need to re-parse the entire history each time.

Because the value extracted from the app receiptmay or may not be an original transaction ID,we are excited to announce that many of our endpoints,including the Get Transaction History endpoint,now support any transaction ID as a parameter,not just an original transaction ID.

Now I'll demonstrate extracting transaction IDs for usewith the Get Transaction History endpoint using the App Store Server Library.Here I will take an app receipt, extract a transaction ID,and call the Get Transaction History endpoint using the ID.First, the App Receipt.You can get an App Receipt from a device or an App Store Server Notification V1.I have one here already.Next, create an instance of the ReceiptUtility class.To extract the transaction ID,call the extract transaction ID from app receipt method.Not all receipts will have a transaction ID.It is possible the user doesn't have any purchases.Therefore, add a null check.

To provide some more depth to this problem,imagine we want to get information about the most recent consumablesfor this user and exclude revoked consumables.Create a Transaction History Request object,specify that only wanted are products of type CONSUMABLEto exclude revoked transactionsand that the data should be returned in descending order.

We need two helper objects, a response variable,and a list of transactions.A do while loop pages through the responsesfrom the transaction history endpoint.If this isn't the first request, fetch the revision tokenfrom the previous response to keep paging through the data.Then, call the Get Transaction History endpoint with the transaction IDfrom the app receipt, the request object, and the revision.Finally, add all the transactions from the response to the transaction list.Repeat this process until the hasMore field is false in the response.

Print out the transactions to see the result.

Here I see a list of transactions returned from the API.The could be decoded using the SignedDataVerifierfrom the previous demo.

Thanks for joining our final demonstrationthat showed how you can use App Receipts with the App Store Server API.Back to Dave to wrap us up.Dave: I'm really excited about the new App Store Server library,and I see these capabilities easing your adoption of our APIsand transitioning to the App Store Server API.Here's a screenshot of the App Store Server APIJava repository on Github.On this page, you can find links to our documentation,submit pull requests, and find examples of how to use the library.

You can download the App Store Server library BETA soonand start planning your adoption of the App Store Server API.We look forward to your feedback and feature requests.Please contact us at Feedback Assistant and on Github.Thank you.♪ ♪

## Code Samples


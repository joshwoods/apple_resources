WEBVTT

00:00:00.506 --> 00:00:04.516
[ Music ]

00:00:05.516 --> 00:00:07.546
[ Applause ]

00:00:08.045 --> 00:00:10.456
>> Hello and welcome to Advances

00:00:10.456 --> 00:00:11.786
in Networking Part 2.

00:00:12.356 --> 00:00:13.686
If you couldn't join us for Part

00:00:13.686 --> 00:00:15.056
1, it will be available for

00:00:15.056 --> 00:00:16.766
streaming soon on the app and on

00:00:16.766 --> 00:00:17.046
the web.

00:00:18.486 --> 00:00:19.806
I'm Eric Kinnear from Internet

00:00:19.806 --> 00:00:20.456
Technologies.

00:00:20.706 --> 00:00:21.866
I'll be joined today by my

00:00:21.866 --> 00:00:23.506
colleagues Tommy and Stuart.

00:00:23.986 --> 00:00:26.566
We've got a lot to cover in Part

00:00:26.566 --> 00:00:26.746
2.

00:00:27.226 --> 00:00:28.336
We're going to start by

00:00:28.336 --> 00:00:29.946
expanding the horizons of what

00:00:29.946 --> 00:00:31.036
you can do with Bonjour

00:00:31.036 --> 00:00:31.466
browsing.

00:00:32.235 --> 00:00:33.146
We'll talk about how you can

00:00:33.146 --> 00:00:35.236
achieve efficient and easy

00:00:35.236 --> 00:00:36.886
message transport by building

00:00:36.886 --> 00:00:37.726
framing protocols.

00:00:38.406 --> 00:00:39.556
We'll take a look at some new

00:00:39.726 --> 00:00:41.126
and improved metric collection.

00:00:41.356 --> 00:00:42.746
And we'll finish off with some

00:00:42.746 --> 00:00:44.286
status updates and some best

00:00:44.286 --> 00:00:45.866
practices to help networking in

00:00:45.866 --> 00:00:47.766
your app become the best it can

00:00:47.766 --> 00:00:47.986
be.

00:00:49.476 --> 00:00:50.846
Before we begin, a brief

00:00:50.846 --> 00:00:51.246
reminder.

00:00:52.646 --> 00:00:54.506
If you're using URLSession and

00:00:54.506 --> 00:00:55.876
Network.framework, you'll be

00:00:55.876 --> 00:00:56.786
able to take advantage of

00:00:56.876 --> 00:00:57.946
everything we're talking about

00:00:57.946 --> 00:00:58.166
today.

00:00:59.116 --> 00:01:00.826
If you're not, these are some

00:01:00.826 --> 00:01:02.146
additional reasons why you

00:01:02.146 --> 00:01:03.256
should switch to a more modern

00:01:03.256 --> 00:01:05.525
networking API.

00:01:05.786 --> 00:01:07.546
Let's jump right in with Bonjour

00:01:09.676 --> 00:01:09.876
browsing.

00:01:09.986 --> 00:01:11.666
Bonjour is how you advertise and

00:01:11.666 --> 00:01:12.876
discover services on the

00:01:12.876 --> 00:01:13.256
network.

00:01:13.656 --> 00:01:15.666
It's used anytime you print with

00:01:15.666 --> 00:01:17.886
AirPrint, connect to an

00:01:17.886 --> 00:01:19.906
airplane-enabled device, use

00:01:19.906 --> 00:01:21.356
HomeKit to automate your home,

00:01:21.776 --> 00:01:23.356
really anytime you are

00:01:23.356 --> 00:01:24.726
connecting to something without

00:01:24.726 --> 00:01:26.456
typing in an IP address or a

00:01:26.456 --> 00:01:26.946
host name.

00:01:27.766 --> 00:01:29.306
And as you know, Bonjour is

00:01:29.306 --> 00:01:30.426
available on all Apple

00:01:30.426 --> 00:01:30.976
platforms.

00:01:31.546 --> 00:01:33.156
And it's also available on

00:01:33.156 --> 00:01:36.226
Linux, Android, Chrome OS, it's

00:01:36.226 --> 00:01:37.566
how Chromecast does discovery.

00:01:38.486 --> 00:01:39.886
What you may not know is that

00:01:39.886 --> 00:01:41.476
Microsoft also quietly added

00:01:41.476 --> 00:01:43.346
Bonjour support to Windows 10

00:01:43.346 --> 00:01:44.426
back in 2015.

00:01:45.316 --> 00:01:46.076
And since then the

00:01:46.076 --> 00:01:47.216
implementation has matured.

00:01:48.066 --> 00:01:49.416
This means that Bonjour is now

00:01:49.416 --> 00:01:51.006
available on every major

00:01:51.006 --> 00:01:51.456
platform.

00:01:53.876 --> 00:01:55.866
Today, we've got some exciting

00:01:55.866 --> 00:01:56.866
enhancements to share in this

00:01:56.866 --> 00:01:57.196
area.

00:01:57.706 --> 00:01:59.416
Sometimes you're on one network

00:02:00.006 --> 00:02:00.846
and you'd like to discover

00:02:00.846 --> 00:02:02.336
services that are available on a

00:02:02.336 --> 00:02:03.016
different network.

00:02:03.606 --> 00:02:04.996
Say you've got a device and

00:02:04.996 --> 00:02:06.226
you'd like to print to a printer

00:02:06.726 --> 00:02:08.286
that's on a different subnet and

00:02:08.286 --> 00:02:09.356
multiple hops away.

00:02:10.196 --> 00:02:11.616
Right now, you would send

00:02:11.616 --> 00:02:13.286
multicast packets on your local

00:02:13.286 --> 00:02:14.546
network and you wouldn't hear

00:02:14.546 --> 00:02:15.436
anything back.

00:02:16.606 --> 00:02:18.026
A discovery proxy solves this

00:02:18.026 --> 00:02:18.386
problem.

00:02:19.356 --> 00:02:20.986
You can now send unicast packets

00:02:21.216 --> 00:02:22.486
over to the discovery proxy.

00:02:22.956 --> 00:02:24.176
It will send out the multicast

00:02:24.176 --> 00:02:25.386
packets on the destination

00:02:25.386 --> 00:02:27.556
subnet, receive the response and

00:02:27.556 --> 00:02:28.806
proxy the results back to you.

00:02:29.636 --> 00:02:30.956
Now you can connect directly to

00:02:30.956 --> 00:02:32.736
your printer and voila, we've

00:02:32.736 --> 00:02:34.976
got our document.

00:02:35.516 --> 00:02:37.946
[ Applause ]

00:02:38.446 --> 00:02:39.756
We're excited to announce that

00:02:39.756 --> 00:02:41.506
the code for this on the client

00:02:41.506 --> 00:02:42.776
side is included in your

00:02:42.776 --> 00:02:44.846
developer seed and a server

00:02:44.846 --> 00:02:46.446
implementation along with

00:02:46.446 --> 00:02:47.846
instruction for setting it up

00:02:48.106 --> 00:02:49.176
are available on GitHub.

00:02:49.786 --> 00:02:52.596
Let's take a look at what this

00:02:52.596 --> 00:02:53.346
means for your app.

00:02:54.686 --> 00:02:55.956
Previously, it's been the

00:02:55.956 --> 00:02:57.436
recommendation that when

00:02:57.436 --> 00:02:58.566
browsing you should specifying

00:02:58.566 --> 00:02:59.416
nil for a domain.

00:03:00.166 --> 00:03:01.236
And this continues to be the

00:03:01.236 --> 00:03:02.836
case and the right answer for

00:03:02.836 --> 00:03:03.986
almost every situation.

00:03:05.096 --> 00:03:06.156
In the past you may not have

00:03:06.156 --> 00:03:07.596
noticed much difference, but now

00:03:07.596 --> 00:03:08.546
this starts to have a bigger

00:03:08.546 --> 00:03:11.226
effect, specifying local will

00:03:11.226 --> 00:03:13.716
explicitly prevent discovery of

00:03:13.806 --> 00:03:15.896
any remote or proxied services.

00:03:16.716 --> 00:03:18.046
This is probably not what you

00:03:18.046 --> 00:03:18.316
want.

00:03:18.316 --> 00:03:19.856
So double check that your browse

00:03:19.856 --> 00:03:21.226
calls aren't inadvertently

00:03:21.226 --> 00:03:22.136
specifying a domain.

00:03:23.546 --> 00:03:24.316
And while you're browsing

00:03:24.316 --> 00:03:25.316
services while building your

00:03:25.746 --> 00:03:26.616
app, let's take a look at how

00:03:26.616 --> 00:03:27.486
some new features in

00:03:27.486 --> 00:03:29.366
Network.framework can make

00:03:29.486 --> 00:03:31.346
browsing for Bonjour even easier

00:03:31.596 --> 00:03:32.696
especially in Swift.

00:03:34.226 --> 00:03:35.536
Last year, we introduced

00:03:35.536 --> 00:03:37.276
NWListener and NWConnection

00:03:37.516 --> 00:03:38.586
along with Network.framework.

00:03:39.286 --> 00:03:40.876
For example, you can have an

00:03:40.876 --> 00:03:42.646
NWListener advertising a Bonjour

00:03:42.646 --> 00:03:44.186
service and you can have an

00:03:44.226 --> 00:03:45.886
NWConnection connects to a

00:03:45.886 --> 00:03:46.996
Bonjour service endpoint.

00:03:47.986 --> 00:03:49.056
But you had to use one of the

00:03:49.056 --> 00:03:50.666
other Bonjour browsing APIs to

00:03:50.666 --> 00:03:52.366
discover the available services.

00:03:53.006 --> 00:03:54.426
And once you found one, you had

00:03:54.426 --> 00:03:55.616
to do a bunch of work to convert

00:03:55.616 --> 00:03:56.696
it into an endpoint that you

00:03:56.696 --> 00:03:57.786
could use with your connection.

00:03:59.046 --> 00:04:00.596
Today, we are thrilled to

00:04:00.596 --> 00:04:02.246
announce native browsing support

00:04:02.466 --> 00:04:03.526
in Network.framework via the

00:04:03.526 --> 00:04:04.826
NWBrowser object.

00:04:06.016 --> 00:04:07.786
Browser joints connection and

00:04:07.786 --> 00:04:09.416
listener to cover the entire

00:04:09.416 --> 00:04:11.536
workflow from advertise to

00:04:11.536 --> 00:04:13.866
discover to connect, all using

00:04:13.866 --> 00:04:14.876
the Network.framework objects

00:04:14.906 --> 00:04:15.766
that you're already familiar

00:04:15.766 --> 00:04:15.966
with.

00:04:19.156 --> 00:04:20.916
Browser provides native service

00:04:20.916 --> 00:04:22.616
discovery in Network.framework

00:04:23.276 --> 00:04:25.386
using a modern dispatch-based

00:04:25.386 --> 00:04:27.176
API that's optimized to work

00:04:27.176 --> 00:04:28.686
incredibly well in Swift.

00:04:29.486 --> 00:04:30.796
It also includes optional

00:04:30.796 --> 00:04:32.596
support for TXT records.

00:04:33.426 --> 00:04:34.816
So if your application needs it,

00:04:34.996 --> 00:04:36.476
you can ensure that a TXT record

00:04:36.476 --> 00:04:37.936
is requested for every

00:04:37.936 --> 00:04:38.736
discovered endpoint.

00:04:39.226 --> 00:04:42.396
Let's take a look at how we use

00:04:42.396 --> 00:04:42.846
our browser.

00:04:43.866 --> 00:04:45.596
We can init it using a Bonjour

00:04:45.596 --> 00:04:46.946
service type that we'd like to

00:04:46.946 --> 00:04:48.696
discover and some NWParameters

00:04:48.696 --> 00:04:50.026
which is how you tell it what

00:04:50.026 --> 00:04:51.016
you'd like to-- how you'd like

00:04:51.016 --> 00:04:52.426
to browse, the same way you do

00:04:52.426 --> 00:04:53.396
all other Network.framework

00:04:53.396 --> 00:04:53.896
objects.

00:04:54.506 --> 00:04:55.596
Next, you can set a

00:04:55.596 --> 00:04:56.916
browseResultsChangedHandler

00:04:57.876 --> 00:04:59.286
which will be called to deliver

00:04:59.546 --> 00:05:00.806
the list of available endpoints

00:05:00.806 --> 00:05:01.546
that have been discovered.

00:05:02.306 --> 00:05:03.856
And finally, just like other

00:05:03.856 --> 00:05:05.206
Network.framework objects, you

00:05:05.206 --> 00:05:07.046
start the browser on a dispatch

00:05:07.046 --> 00:05:07.866
queue where you'd like to

00:05:07.866 --> 00:05:08.956
receive those callbacks.

00:05:09.486 --> 00:05:11.906
Let's take a closer look at the

00:05:11.906 --> 00:05:13.026
browseResultsChangedHandler.

00:05:13.946 --> 00:05:14.846
You have two options.

00:05:15.176 --> 00:05:17.026
First, you can provide a handler

00:05:17.366 --> 00:05:18.846
that receives the detailed list

00:05:18.846 --> 00:05:19.966
of all changes that have

00:05:19.966 --> 00:05:20.786
happened in that update.

00:05:21.436 --> 00:05:23.206
This aligns very closely with

00:05:23.206 --> 00:05:24.546
the lower level APIs and

00:05:24.546 --> 00:05:26.066
provides you full visibility

00:05:26.276 --> 00:05:27.496
into everything that changed.

00:05:28.056 --> 00:05:29.696
Endpoints can be added or

00:05:29.696 --> 00:05:31.686
removed and they can also have

00:05:31.686 --> 00:05:32.886
their inner details changed.

00:05:33.716 --> 00:05:34.926
Those changes are represented by

00:05:34.926 --> 00:05:35.546
flags.

00:05:36.436 --> 00:05:38.076
And in this case, we'll check

00:05:38.076 --> 00:05:39.696
for interfaces being added or

00:05:39.696 --> 00:05:40.906
removed as endpoints are

00:05:40.906 --> 00:05:42.026
discovered over additional

00:05:42.026 --> 00:05:42.586
interfaces.

00:05:43.136 --> 00:05:45.996
You can also choose to provide a

00:05:45.996 --> 00:05:47.916
handler that just looks at the

00:05:47.916 --> 00:05:49.916
latest list of results that have

00:05:49.956 --> 00:05:50.596
been discovered.

00:05:51.476 --> 00:05:52.786
Be careful if you do this

00:05:52.986 --> 00:05:53.916
because this handler will be

00:05:53.916 --> 00:05:55.636
called repeatedly as the list of

00:05:55.636 --> 00:05:57.076
available endpoints changes.

00:05:57.676 --> 00:05:58.516
So make sure that you're

00:05:58.516 --> 00:05:59.846
updating the state and the rest

00:05:59.846 --> 00:06:00.626
of your application

00:06:00.626 --> 00:06:01.246
appropriately.

00:06:05.096 --> 00:06:06.566
Let's see an example of the

00:06:06.566 --> 00:06:07.576
NWBrowser in action.

00:06:08.476 --> 00:06:09.976
We're going to make an app that

00:06:09.976 --> 00:06:12.126
provides a service discovery and

00:06:12.126 --> 00:06:13.756
secure connectivity between two

00:06:13.756 --> 00:06:14.246
devices.

00:06:15.206 --> 00:06:16.236
In our case we're going to make

00:06:16.236 --> 00:06:17.426
it a tic-tac-toe game.

00:06:17.856 --> 00:06:18.856
But you could use this for

00:06:18.856 --> 00:06:19.846
pretty much anything else.

00:06:21.136 --> 00:06:22.516
We're going to use an NWListener

00:06:22.516 --> 00:06:23.666
to advertise games to nearby

00:06:23.666 --> 00:06:25.246
players, we're going to use

00:06:25.246 --> 00:06:26.866
NWBrowser to browse for the

00:06:26.866 --> 00:06:28.746
games that are available nearby,

00:06:29.036 --> 00:06:30.346
and we're going to take one of

00:06:30.346 --> 00:06:31.416
those browse results once the

00:06:31.416 --> 00:06:32.616
user picks a game they'd like to

00:06:32.616 --> 00:06:32.856
join.

00:06:32.856 --> 00:06:34.486
And we're going to pass it an

00:06:34.486 --> 00:06:36.536
NWConnection to connect back to

00:06:36.536 --> 00:06:36.946
our listener.

00:06:36.946 --> 00:06:39.416
Let's take a look at this in

00:06:39.416 --> 00:06:39.976
Xcode.

00:06:47.416 --> 00:06:49.376
Here I've got my application and

00:06:49.376 --> 00:06:50.476
we've already written a bunch of

00:06:50.516 --> 00:06:52.716
code to handle doing some

00:06:52.716 --> 00:06:54.706
different views displaying a

00:06:54.706 --> 00:06:56.006
list of available games to the

00:06:56.006 --> 00:06:57.256
user, letting them host the

00:06:57.256 --> 00:06:58.366
game, stuff like that.

00:06:58.626 --> 00:06:59.866
So, here we can just focus on

00:06:59.866 --> 00:07:00.286
the browser.

00:07:00.856 --> 00:07:02.816
I've got a class called

00:07:02.886 --> 00:07:04.656
PeerBrowser, which I'm going to

00:07:04.656 --> 00:07:06.676
use to manage my NWBrowser and

00:07:06.676 --> 00:07:08.006
provide a PeerBrowserDelegate

00:07:08.006 --> 00:07:09.716
that will pass the list of

00:07:09.716 --> 00:07:11.406
discovered endpoints too so the

00:07:11.406 --> 00:07:12.846
UI can display them to the user.

00:07:14.536 --> 00:07:15.936
First, I need to add my

00:07:15.936 --> 00:07:17.656
NWBrowser as an instance

00:07:17.656 --> 00:07:18.806
property on the PeerBrowser.

00:07:21.216 --> 00:07:22.766
Next, we see that when the

00:07:22.766 --> 00:07:24.706
PeerBrowser is initted, it will

00:07:24.706 --> 00:07:26.166
immediately call startBrowsing.

00:07:27.126 --> 00:07:28.666
We need to fill that in.

00:07:29.916 --> 00:07:31.846
First, I'm going to create some

00:07:31.846 --> 00:07:33.576
NWParameters which is the same

00:07:33.576 --> 00:07:34.916
objects that you use with other

00:07:34.916 --> 00:07:36.206
Network.framework objects to

00:07:36.206 --> 00:07:37.296
describe how you'd like to

00:07:37.296 --> 00:07:38.126
interact with the network.

00:07:38.716 --> 00:07:39.636
In this case the default

00:07:39.636 --> 00:07:41.146
parameters are just fine but

00:07:41.376 --> 00:07:43.046
we'll set includePeerToPeer to

00:07:43.046 --> 00:07:45.276
true so that we can discover

00:07:45.276 --> 00:07:46.926
other available games even if

00:07:46.926 --> 00:07:48.406
the devices aren't on the same

00:07:48.406 --> 00:07:49.066
physical network.

00:07:52.576 --> 00:07:55.006
Next, we'll create our NWBrowser

00:07:56.236 --> 00:07:58.076
browsing for a service type of

00:07:58.126 --> 00:07:59.216
tictactoe.tcp.

00:07:59.216 --> 00:08:01.356
And we'll make sure to specify

00:08:01.356 --> 00:08:02.286
nil for the domain.

00:08:03.616 --> 00:08:04.856
We'll use the parameters that we

00:08:04.856 --> 00:08:06.536
created earlier and save it off

00:08:06.536 --> 00:08:07.296
into our peer browser.

00:08:07.806 --> 00:08:10.066
Next, we'll set a

00:08:10.066 --> 00:08:11.876
stateUpdateHandler just like we

00:08:11.876 --> 00:08:12.826
do with other Network.framework

00:08:12.826 --> 00:08:14.756
objects to receive updates about

00:08:14.756 --> 00:08:15.966
the state of our browser if

00:08:15.966 --> 00:08:17.366
there's any errors, how it's

00:08:17.366 --> 00:08:18.866
going, things like that, and

00:08:20.936 --> 00:08:21.996
then we'll set our

00:08:21.996 --> 00:08:23.166
browseResultsChangedHandler.

00:08:24.226 --> 00:08:25.096
Here it's really simple.

00:08:25.436 --> 00:08:26.946
We take the list of results, we

00:08:26.946 --> 00:08:28.216
pass them off to our delegate to

00:08:28.216 --> 00:08:29.776
be displayed in the UI, and we

00:08:29.776 --> 00:08:30.806
make sure that our delegate is

00:08:30.806 --> 00:08:32.826
coded in such a way that it

00:08:32.826 --> 00:08:34.275
refreshes the UI every time this

00:08:34.275 --> 00:08:35.275
happens so we can always

00:08:35.275 --> 00:08:36.885
represent the latest list of

00:08:36.885 --> 00:08:37.736
discovered endpoints.

00:08:41.556 --> 00:08:43.785
Finally, we start the browser on

00:08:43.785 --> 00:08:44.996
the main queue since that's

00:08:44.996 --> 00:08:45.876
where we'd like to receive our

00:08:45.876 --> 00:08:46.276
updates.

00:08:46.786 --> 00:08:49.696
And that's it.

00:08:50.236 --> 00:08:51.726
With just that code, we're able

00:08:51.726 --> 00:08:53.546
to bring up an NWBrowser, have

00:08:53.546 --> 00:08:54.996
it discover nearby games

00:08:55.256 --> 00:08:56.376
potentially over peer to peer

00:08:56.376 --> 00:08:58.076
links and display a list of

00:08:58.076 --> 00:08:59.626
available games to the user so

00:08:59.626 --> 00:09:00.456
they can choose which one to

00:09:00.456 --> 00:09:00.856
connect to.

00:09:00.856 --> 00:09:05.466
We'll talk a little bit later

00:09:05.466 --> 00:09:06.226
about our listener and

00:09:06.226 --> 00:09:07.796
connection, but all of this code

00:09:07.796 --> 00:09:08.846
is available for download as

00:09:08.846 --> 00:09:10.376
sample code off the website.

00:09:10.376 --> 00:09:12.266
And there's one thing I want to

00:09:12.266 --> 00:09:13.846
touch on before we try it out.

00:09:14.786 --> 00:09:16.966
We've got our NWParameters that

00:09:16.966 --> 00:09:17.886
we're going to use with our

00:09:17.886 --> 00:09:18.926
listeners and connections.

00:09:19.506 --> 00:09:20.536
And earlier I mentioned that we

00:09:20.536 --> 00:09:21.806
want to make sure that our

00:09:21.806 --> 00:09:23.416
connection between these devices

00:09:23.416 --> 00:09:24.866
is secure so that nobody else

00:09:24.866 --> 00:09:26.066
can see what moves we're making

00:09:26.246 --> 00:09:27.636
or worse, modify one of the

00:09:27.636 --> 00:09:28.296
player's moves.

00:09:29.586 --> 00:09:30.676
We're going to do that by

00:09:30.676 --> 00:09:31.736
defining an extension to

00:09:31.736 --> 00:09:34.526
NWParameters and creating a

00:09:34.526 --> 00:09:35.666
convenience initializer.

00:09:36.976 --> 00:09:38.386
It takes a passcode as a string.

00:09:39.396 --> 00:09:40.556
We're going to display to the

00:09:40.556 --> 00:09:42.836
host of the game a passcode and

00:09:42.896 --> 00:09:44.036
ask the person that wants to

00:09:44.036 --> 00:09:45.146
play with them to type in that

00:09:45.146 --> 00:09:46.976
passcode and then use that to

00:09:46.976 --> 00:09:48.436
derive a pre-shared key that we

00:09:48.436 --> 00:09:49.806
can use to secure the connection

00:09:50.056 --> 00:09:50.346
with TOS.

00:09:50.346 --> 00:09:53.556
In order to this, we need to

00:09:53.556 --> 00:09:55.956
create both TCP and TLS options

00:09:56.336 --> 00:09:57.236
in our initializer.

00:09:57.966 --> 00:09:59.666
Let's start with TLS.

00:10:01.726 --> 00:10:03.046
Here we defined a function that

00:10:03.046 --> 00:10:04.266
creates TLS options.

00:10:04.476 --> 00:10:06.126
We pass at the passcode and for

00:10:06.126 --> 00:10:07.076
now we start with just the

00:10:07.076 --> 00:10:08.226
default TLS options.

00:10:09.656 --> 00:10:11.786
Next, we use the new CryptoKit

00:10:11.786 --> 00:10:12.976
framework, which is available

00:10:12.976 --> 00:10:14.586
this year, to derive an

00:10:14.586 --> 00:10:16.676
authentication key and code from

00:10:17.806 --> 00:10:20.656
that passcode.

00:10:20.776 --> 00:10:22.326
We'll add that pre-shared key to

00:10:22.326 --> 00:10:24.066
our set protocol options and

00:10:24.266 --> 00:10:25.556
we'll also make sure to add a

00:10:25.556 --> 00:10:27.186
TLS cipher suite that supports

00:10:27.186 --> 00:10:28.236
the use of pre-shared keys.

00:10:28.816 --> 00:10:31.716
We can return our TLS options.

00:10:32.266 --> 00:10:34.386
And up here we're ready to go

00:10:34.386 --> 00:10:35.836
with our TCP options.

00:10:38.456 --> 00:10:40.146
We'll use a default TCP options

00:10:40.146 --> 00:10:41.276
for most things but we'll also

00:10:41.276 --> 00:10:41.966
enable keepalive.

00:10:43.186 --> 00:10:45.026
We then init our NWParameters

00:10:45.026 --> 00:10:46.276
with the TLS options that we

00:10:46.276 --> 00:10:47.966
just created down below, and

00:10:47.966 --> 00:10:50.426
those pretty much default TCP

00:10:51.206 --> 00:10:51.396
options.

00:10:51.516 --> 00:10:52.656
Finally, the last thing we want

00:10:52.656 --> 00:10:55.786
to do is set include peer to

00:10:55.786 --> 00:10:57.486
peer here so that our connection

00:10:57.486 --> 00:10:58.936
and our listener will also be

00:10:58.936 --> 00:11:00.006
able to connect to nearby

00:11:00.006 --> 00:11:01.406
devices even when they're not on

00:11:01.406 --> 00:11:01.976
the same network.

00:11:02.506 --> 00:11:07.546
So that's it, let's try it out.

00:11:07.756 --> 00:11:09.206
If I go over here, we can see

00:11:09.206 --> 00:11:10.276
that I've got two devices

00:11:10.586 --> 00:11:11.966
running the app and we've

00:11:11.966 --> 00:11:13.116
already got our UI there for

00:11:13.116 --> 00:11:13.856
hosting a game.

00:11:14.416 --> 00:11:15.656
And the browser has already

00:11:15.656 --> 00:11:17.236
started browsing and is

00:11:17.236 --> 00:11:18.476
displaying searching for games

00:11:18.476 --> 00:11:19.576
since we haven't found anything

00:11:20.146 --> 00:11:20.266
yet.

00:11:21.276 --> 00:11:23.106
If I come up and type in my name

00:11:24.376 --> 00:11:26.516
and tap host game, you can see

00:11:26.596 --> 00:11:28.316
I'm given the passcode and our

00:11:28.316 --> 00:11:29.726
browseResultsChangedHandler has

00:11:29.726 --> 00:11:31.396
been called with the list of

00:11:31.396 --> 00:11:32.786
discovered endpoints, in this

00:11:32.786 --> 00:11:34.296
case the game that I'm hosting,

00:11:34.516 --> 00:11:35.456
and we've displayed that for the

00:11:35.456 --> 00:11:35.806
user.

00:11:36.116 --> 00:11:36.716
It's that easy.

00:11:37.316 --> 00:11:41.526
If I tap on join game, I'm

00:11:41.526 --> 00:11:42.866
presented the opportunity to

00:11:42.866 --> 00:11:45.526
type in the passcode.

00:11:45.526 --> 00:11:47.386
And now when I confirm that,

00:11:47.806 --> 00:11:49.276
we'll see that we've created the

00:11:49.276 --> 00:11:51.166
pre-shared key, used it to

00:11:51.166 --> 00:11:52.276
connect back to the listener,

00:11:52.746 --> 00:11:54.366
and hopefully the game will flip

00:11:54.366 --> 00:11:55.216
around and ready to play.

00:11:56.656 --> 00:11:57.036
There we go.

00:11:58.516 --> 00:12:01.500
[ Applause ]

00:12:08.236 --> 00:12:09.756
So far, we've built the

00:12:09.756 --> 00:12:11.426
beginnings of our app and

00:12:11.426 --> 00:12:12.836
established connectivity between

00:12:12.836 --> 00:12:13.646
the two devices.

00:12:14.386 --> 00:12:15.846
We used an NWListener to

00:12:15.846 --> 00:12:17.276
advertise a Bonjour service of

00:12:17.316 --> 00:12:18.246
tictactoe.tcp.

00:12:18.246 --> 00:12:21.856
We used an NWBrowser to browse

00:12:21.856 --> 00:12:23.316
for available games and display

00:12:23.316 --> 00:12:24.016
those to the user.

00:12:24.456 --> 00:12:25.866
And we were able to take the

00:12:25.866 --> 00:12:27.236
result that we got back from the

00:12:27.236 --> 00:12:29.186
browser and pass it directly to

00:12:29.186 --> 00:12:30.956
our NWConnection to connect back

00:12:30.996 --> 00:12:32.346
to the listener and establish a

00:12:32.346 --> 00:12:33.926
secure connection between those

00:12:33.926 --> 00:12:34.546
two devices.

00:12:35.596 --> 00:12:36.816
Of course in order to play the

00:12:36.816 --> 00:12:38.336
game, the two devices actually

00:12:38.336 --> 00:12:39.446
have to be able to communicate

00:12:39.686 --> 00:12:41.686
to share the game state, tell

00:12:41.686 --> 00:12:42.666
each other about moves that the

00:12:42.666 --> 00:12:44.236
players making, and things like

00:12:44.236 --> 00:12:44.456
that.

00:12:45.276 --> 00:12:46.726
In order to that, I'd like to

00:12:46.726 --> 00:12:48.216
invite Tommy up to the stage to

00:12:48.216 --> 00:12:49.496
walk us through building custom

00:12:49.496 --> 00:12:50.466
framing protocols.

00:12:51.516 --> 00:12:56.316
[ Applause ]

00:12:56.816 --> 00:12:57.556
>> All right.

00:12:57.556 --> 00:12:58.786
Thank you, Eric.

00:12:59.796 --> 00:13:01.416
So today, I'd like to share with

00:13:01.466 --> 00:13:04.006
you an exciting new way that you

00:13:04.006 --> 00:13:05.846
can extend your network

00:13:05.846 --> 00:13:08.786
connections with custom protocol

00:13:08.786 --> 00:13:10.776
framing code that you write that

00:13:10.776 --> 00:13:12.916
runs on the same thread as the

00:13:12.916 --> 00:13:13.956
rest of the protocols in the

00:13:13.956 --> 00:13:15.706
networking stack.

00:13:16.116 --> 00:13:17.806
So, in order to finish the game

00:13:17.806 --> 00:13:19.666
that Eric just started, we need

00:13:19.666 --> 00:13:21.236
to define a way for the two

00:13:21.236 --> 00:13:22.776
games to send commands between

00:13:22.776 --> 00:13:23.236
each other.

00:13:23.856 --> 00:13:24.966
When one player wants to make a

00:13:24.966 --> 00:13:26.366
move, he needs to send a message

00:13:26.366 --> 00:13:27.066
to the other side.

00:13:28.206 --> 00:13:29.896
To do this we're going to need a

00:13:29.896 --> 00:13:30.386
protocol.

00:13:30.966 --> 00:13:33.546
So here's what our protocol is

00:13:33.546 --> 00:13:34.276
going to look like.

00:13:34.836 --> 00:13:37.686
It's a simple type-length-value

00:13:37.686 --> 00:13:38.996
or TLV protocol.

00:13:40.016 --> 00:13:42.196
So we have a 4-byte type which

00:13:42.196 --> 00:13:44.156
may be make a move.

00:13:44.936 --> 00:13:47.116
The player wants to put a given

00:13:47.116 --> 00:13:48.586
character at a given location on

00:13:48.586 --> 00:13:49.716
our tic-tac-toe board.

00:13:50.296 --> 00:13:52.796
We have a 4-byte length which

00:13:52.796 --> 00:13:54.026
indicates the length of the rest

00:13:54.026 --> 00:13:54.626
of the message.

00:13:55.166 --> 00:13:57.656
And then after that we have the

00:13:57.656 --> 00:13:58.726
body of the message.

00:13:59.086 --> 00:14:00.326
And in this case it could be

00:14:00.436 --> 00:14:03.066
place the monkey face at row 1

00:14:03.066 --> 00:14:03.696
column 2.

00:14:04.506 --> 00:14:05.456
And then it's going to repeat

00:14:05.456 --> 00:14:07.546
like that on TLS byte-stream.

00:14:10.196 --> 00:14:11.706
So you may have noticed that

00:14:11.956 --> 00:14:13.906
this protocol, even though we're

00:14:13.906 --> 00:14:15.736
running on top of a TLS

00:14:15.736 --> 00:14:17.456
byte-stream which itself is not

00:14:17.456 --> 00:14:20.206
structured is using structured

00:14:20.206 --> 00:14:20.946
messages.

00:14:21.556 --> 00:14:22.906
The application is not thinking

00:14:22.906 --> 00:14:25.026
in terms of byte-streams but

00:14:25.026 --> 00:14:26.916
well-delineated pieces of

00:14:26.916 --> 00:14:27.506
information.

00:14:28.696 --> 00:14:29.976
And almost all networking

00:14:29.976 --> 00:14:31.616
applications do this.

00:14:32.806 --> 00:14:34.666
They either have a header and a

00:14:34.666 --> 00:14:37.246
body or they have a delimiter

00:14:37.666 --> 00:14:38.906
that goes somewhere to define

00:14:38.906 --> 00:14:39.686
the boundaries of their

00:14:39.686 --> 00:14:40.336
messages.

00:14:41.756 --> 00:14:45.446
However, traditional transport

00:14:45.446 --> 00:14:47.266
networking APIs like sockets

00:14:47.536 --> 00:14:49.986
didn't give you a way to easily

00:14:49.986 --> 00:14:51.806
read out messages on a

00:14:51.806 --> 00:14:52.336
connection.

00:14:52.536 --> 00:14:53.586
You had to do that all yourself

00:14:53.586 --> 00:14:54.236
in the application.

00:14:55.166 --> 00:14:57.436
So, to take a look at how this

00:14:57.466 --> 00:14:59.646
problem plays out let's look at

00:14:59.646 --> 00:15:01.026
the relationship of your

00:15:01.026 --> 00:15:02.846
application to the rest of the

00:15:02.846 --> 00:15:03.526
networking stack.

00:15:03.666 --> 00:15:05.426
So up on top you have your

00:15:05.426 --> 00:15:06.006
application.

00:15:07.186 --> 00:15:08.746
And it is communicating with the

00:15:08.746 --> 00:15:10.586
networking stack via the API.

00:15:11.806 --> 00:15:13.846
So in Network.framework, we have

00:15:14.366 --> 00:15:18.086
running TLS and TCP all within

00:15:18.086 --> 00:15:20.306
one shared thread inside your

00:15:20.306 --> 00:15:20.936
application.

00:15:21.346 --> 00:15:22.486
This is the user space

00:15:22.486 --> 00:15:23.496
networking stack that we

00:15:23.496 --> 00:15:24.706
introduced last year.

00:15:25.786 --> 00:15:27.896
Let's zoom in to see how your

00:15:27.896 --> 00:15:30.266
application reads messages when

00:15:30.266 --> 00:15:33.196
it's on top of a byte-stream.

00:15:33.376 --> 00:15:34.916
So if you have a protocol like

00:15:34.916 --> 00:15:36.146
the one that we're using for

00:15:36.146 --> 00:15:38.106
tic-tac-toe, you may have a

00:15:38.216 --> 00:15:39.086
fixed-length header.

00:15:39.796 --> 00:15:41.056
And the simple thing you can do

00:15:41.056 --> 00:15:43.246
here is to read exactly the

00:15:43.246 --> 00:15:44.186
length of your header.

00:15:45.246 --> 00:15:46.336
Receive 8 bytes.

00:15:47.236 --> 00:15:48.286
So this is a fixed length.

00:15:48.286 --> 00:15:49.266
You know what's going to happen.

00:15:49.796 --> 00:15:51.456
And the stack will call you back

00:15:51.456 --> 00:15:52.716
when you have your full header.

00:15:53.396 --> 00:15:55.156
This allows you to determine the

00:15:55.156 --> 00:15:55.986
length of the rest of the

00:15:55.986 --> 00:15:56.436
message.

00:15:56.786 --> 00:15:58.776
So you can read exactly that and

00:15:58.776 --> 00:16:00.216
then go back and forth reading

00:16:00.216 --> 00:16:02.796
body, header, body, header,

00:16:02.986 --> 00:16:03.296
body.

00:16:03.826 --> 00:16:07.796
So this is great, but you may

00:16:07.796 --> 00:16:08.966
have noticed that we have

00:16:08.966 --> 00:16:10.816
multiple back and forths at

00:16:10.816 --> 00:16:12.696
least two for every single

00:16:12.696 --> 00:16:13.226
message.

00:16:13.776 --> 00:16:15.356
If you have a more complex

00:16:15.356 --> 00:16:16.896
protocol, maybe you have a

00:16:16.896 --> 00:16:18.936
variable-length header or you

00:16:18.936 --> 00:16:20.576
have a delimiter, this can

00:16:20.576 --> 00:16:22.226
become even more inefficient,

00:16:22.726 --> 00:16:23.876
even though it's simple for your

00:16:23.876 --> 00:16:25.786
application to write its logic.

00:16:27.056 --> 00:16:28.716
If you care about efficiency a

00:16:28.716 --> 00:16:30.206
lot, you have another option.

00:16:30.836 --> 00:16:32.366
You could receive as much as

00:16:32.366 --> 00:16:33.436
possible at one time.

00:16:34.176 --> 00:16:35.936
But now you have a bunch of

00:16:35.936 --> 00:16:36.906
other problems to deal with.

00:16:37.766 --> 00:16:39.506
Now, you need to handle the case

00:16:39.506 --> 00:16:40.716
in which you don't receive a

00:16:40.716 --> 00:16:42.046
complete message all in one

00:16:42.046 --> 00:16:42.396
chunk.

00:16:43.226 --> 00:16:44.476
Or maybe you receive multiple

00:16:44.476 --> 00:16:46.856
messages in one go, or maybe you

00:16:46.856 --> 00:16:48.976
receive only part of your

00:16:48.976 --> 00:16:50.466
header, you only have two or

00:16:50.466 --> 00:16:51.536
three bytes of your length

00:16:51.536 --> 00:16:51.936
field.

00:16:51.936 --> 00:16:53.186
You need to save it off,

00:16:53.186 --> 00:16:55.186
reconstruct the field and parse

00:16:55.186 --> 00:16:55.796
it out again.

00:16:56.926 --> 00:16:58.876
Getting this fully correct and

00:16:58.876 --> 00:17:00.356
handling every possible edge

00:17:00.356 --> 00:17:02.776
case can be really difficult.

00:17:03.186 --> 00:17:04.486
And it's common to have subtle

00:17:04.486 --> 00:17:06.256
bugs that only show up when your

00:17:06.256 --> 00:17:07.656
users actually use your

00:17:07.656 --> 00:17:08.685
application in the field.

00:17:10.756 --> 00:17:11.376
All right.

00:17:11.526 --> 00:17:12.816
So, it's a bit of a bleak

00:17:12.816 --> 00:17:14.106
picture at this point.

00:17:14.506 --> 00:17:16.386
How do we get the best of both

00:17:16.386 --> 00:17:16.695
worlds?

00:17:16.695 --> 00:17:18.786
How can we have a way to be both

00:17:18.786 --> 00:17:21.425
efficient and have simple code

00:17:21.425 --> 00:17:22.675
that's easily testable and

00:17:22.675 --> 00:17:23.256
composable?

00:17:24.056 --> 00:17:25.915
Well, I'm really excited to

00:17:25.915 --> 00:17:28.215
share that now in iOS 13 and

00:17:28.215 --> 00:17:29.986
macOS Catalina, you'll be able

00:17:29.986 --> 00:17:32.226
to write your own protocol code

00:17:32.756 --> 00:17:34.466
that runs on the same networking

00:17:34.466 --> 00:17:35.986
thread to handle this problem.

00:17:36.376 --> 00:17:38.116
So, this is an unprecedented

00:17:38.116 --> 00:17:39.916
step forward in the amount of

00:17:39.916 --> 00:17:41.446
flexibility that you have to

00:17:41.446 --> 00:17:43.796
define your messages within a

00:17:43.796 --> 00:17:44.976
transport networking API

00:17:44.976 --> 00:17:45.706
[applause].

00:17:45.706 --> 00:17:50.446
Thank you.

00:17:50.446 --> 00:17:51.386
And you get to do this all

00:17:51.386 --> 00:17:52.926
within NWConnection.

00:17:53.086 --> 00:17:54.546
And so, to the application on

00:17:54.546 --> 00:17:56.126
top, it's just as if you're

00:17:56.126 --> 00:17:57.596
reading and writing datagrams

00:17:57.596 --> 00:17:59.206
like a basic connection.

00:18:00.736 --> 00:18:02.356
So let's look at the world now.

00:18:03.066 --> 00:18:04.116
Still have your application.

00:18:04.166 --> 00:18:05.686
It's still sending and receiving

00:18:05.816 --> 00:18:07.456
but now you have your framing

00:18:07.456 --> 00:18:09.556
code that's running within the

00:18:09.556 --> 00:18:11.736
same thread as TLS and TCP.

00:18:12.216 --> 00:18:13.146
So you can now call

00:18:13.886 --> 00:18:14.846
receiveMessage.

00:18:15.226 --> 00:18:16.596
And it will get exactly one

00:18:16.596 --> 00:18:17.626
callback when you have a

00:18:17.976 --> 00:18:19.346
complete message that your

00:18:19.346 --> 00:18:20.966
application can fully process.

00:18:21.596 --> 00:18:22.656
You can do this over and over

00:18:22.656 --> 00:18:22.976
again.

00:18:23.266 --> 00:18:25.466
One call per message and really,

00:18:25.466 --> 00:18:27.246
really easy to debug and

00:18:27.246 --> 00:18:28.386
understand what's going on.

00:18:28.926 --> 00:18:31.696
So, this is great.

00:18:31.866 --> 00:18:33.966
And if your-- You may be asking

00:18:33.966 --> 00:18:35.916
right now what can I actually

00:18:35.916 --> 00:18:38.046
implement as one of these

00:18:38.046 --> 00:18:38.796
framing protocols?

00:18:38.796 --> 00:18:39.746
What are the restrictions?

00:18:39.856 --> 00:18:42.076
So, the good news is, is that

00:18:42.276 --> 00:18:43.786
pretty much anything that

00:18:43.786 --> 00:18:45.976
encapsulates or encodes

00:18:45.976 --> 00:18:47.636
application data to transform it

00:18:48.176 --> 00:18:49.986
can be written as a framing

00:18:49.986 --> 00:18:50.466
protocol.

00:18:51.146 --> 00:18:53.146
You can even send your own

00:18:53.146 --> 00:18:54.916
messages that do not correspond

00:18:55.026 --> 00:18:56.736
to application data, if you need

00:18:56.736 --> 00:18:58.886
to do a handshake or if you need

00:18:59.076 --> 00:19:00.336
to implement some sort of

00:19:00.376 --> 00:19:01.606
keepalive on the connection.

00:19:02.156 --> 00:19:04.436
And the protocols that you're

00:19:04.436 --> 00:19:06.026
implementing here can be

00:19:06.026 --> 00:19:09.026
standard IETF official protocols

00:19:09.616 --> 00:19:10.476
or they could be something

00:19:10.476 --> 00:19:12.016
custom just for your app like

00:19:12.066 --> 00:19:13.326
what we're going to be doing for

00:19:13.326 --> 00:19:14.226
a tic-tac-toe game.

00:19:15.096 --> 00:19:16.456
So if you want to build a

00:19:16.456 --> 00:19:17.776
protocol, you have two steps.

00:19:18.446 --> 00:19:21.116
First, you implement a reusable

00:19:21.116 --> 00:19:22.566
piece of code that defines your

00:19:22.566 --> 00:19:23.286
message framing.

00:19:23.836 --> 00:19:24.796
This is the protocol.

00:19:25.716 --> 00:19:28.486
And then you add that protocol

00:19:28.886 --> 00:19:30.776
into your connection's protocol

00:19:30.776 --> 00:19:32.416
stacks so that you can use it

00:19:32.416 --> 00:19:34.366
for connection establishment as

00:19:34.366 --> 00:19:36.086
well as sending and receiving

00:19:36.186 --> 00:19:36.626
message.

00:19:37.176 --> 00:19:38.196
All right.

00:19:38.416 --> 00:19:40.786
So let's go on to step 1.

00:19:41.016 --> 00:19:41.596
We're going to start

00:19:41.696 --> 00:19:43.446
implementing framing protocols.

00:19:44.786 --> 00:19:47.096
What you do here is create a

00:19:47.096 --> 00:19:48.926
class that conforms to

00:19:48.926 --> 00:19:51.066
ProtocolFramerImplementation.

00:19:51.896 --> 00:19:52.846
And there are many things you

00:19:52.846 --> 00:19:54.166
can do within this class.

00:19:55.136 --> 00:19:56.886
But the two most important

00:19:56.886 --> 00:19:58.216
things to remember are to

00:19:58.216 --> 00:20:00.456
handleOutput, to send messages;

00:20:00.786 --> 00:20:02.326
and to handleInput, to parse

00:20:02.326 --> 00:20:02.956
messages.

00:20:03.516 --> 00:20:04.926
If you can do these two things,

00:20:05.256 --> 00:20:06.546
hooray, you are a framer.

00:20:07.736 --> 00:20:08.806
Let's take a look at the code.

00:20:09.506 --> 00:20:11.636
So, here we have my protocol.

00:20:12.266 --> 00:20:13.486
It's going to conform to

00:20:13.486 --> 00:20:15.276
ProtocolFramerImplementation.

00:20:16.526 --> 00:20:17.356
And the first thing that I

00:20:17.356 --> 00:20:19.976
recommend you do is create a

00:20:20.096 --> 00:20:21.346
definition object.

00:20:21.446 --> 00:20:23.476
And this is a handle to your

00:20:23.476 --> 00:20:25.046
protocol that you can use

00:20:25.366 --> 00:20:26.476
throughout the rest of your app.

00:20:27.096 --> 00:20:28.826
It refers to your protocols you

00:20:28.826 --> 00:20:30.166
can add it into connections.

00:20:30.626 --> 00:20:34.106
Next you can handle a lot of the

00:20:34.106 --> 00:20:36.156
basic callback events.

00:20:36.626 --> 00:20:37.886
One of the most important ones

00:20:37.886 --> 00:20:39.226
here is start.

00:20:39.576 --> 00:20:41.576
Start will get called anytime

00:20:41.576 --> 00:20:43.436
your protocol is loaded into a

00:20:43.436 --> 00:20:45.366
connection as being used to

00:20:45.446 --> 00:20:46.286
bring it up.

00:20:47.036 --> 00:20:48.706
If you need to do a handshake to

00:20:48.706 --> 00:20:49.806
exchange something with the

00:20:49.806 --> 00:20:51.416
other side, you can implement it

00:20:51.416 --> 00:20:51.726
here.

00:20:52.626 --> 00:20:54.636
Or if like our tic-tac-toe game

00:20:54.636 --> 00:20:55.916
you have a very simple protocol,

00:20:56.016 --> 00:20:57.386
you don't need to do any setup,

00:20:57.726 --> 00:20:58.996
just mark the connection ready

00:20:59.076 --> 00:20:59.636
immediately.

00:21:00.896 --> 00:21:02.806
So once you've done this, you

00:21:02.806 --> 00:21:04.736
now have to handleOutput and

00:21:04.736 --> 00:21:05.356
handleInput.

00:21:05.686 --> 00:21:06.796
Let's dive into these.

00:21:09.196 --> 00:21:11.156
So here is what handleOutput

00:21:11.186 --> 00:21:11.666
looks like.

00:21:12.416 --> 00:21:13.316
You will get called with

00:21:13.316 --> 00:21:16.036
handleOutput every time the

00:21:16.036 --> 00:21:17.966
application sends a message.

00:21:18.546 --> 00:21:19.906
And you'll be given the message

00:21:19.906 --> 00:21:22.116
metadata with some custom values

00:21:22.116 --> 00:21:25.036
if you need them, along with the

00:21:25.036 --> 00:21:26.106
length of the message the

00:21:26.106 --> 00:21:27.356
application is trying to send.

00:21:27.986 --> 00:21:31.016
So, if you have a header body

00:21:31.016 --> 00:21:32.626
protocol, like what we're using,

00:21:33.686 --> 00:21:35.886
you can first create your header

00:21:35.886 --> 00:21:38.186
structure and try to serialize

00:21:38.186 --> 00:21:38.666
some data.

00:21:39.686 --> 00:21:41.266
So this can include your type

00:21:41.846 --> 00:21:42.836
that you get maybe from the

00:21:42.836 --> 00:21:44.666
message metadata along with the

00:21:44.666 --> 00:21:47.166
length that was passed to you

00:21:47.166 --> 00:21:48.036
into handleOutput.

00:21:48.476 --> 00:21:51.086
You combine these into data and

00:21:51.086 --> 00:21:52.466
then you call writeOutput.

00:21:52.896 --> 00:21:54.656
WriteOutput will queue your

00:21:54.656 --> 00:21:56.506
bytes on to the output stream,

00:21:56.876 --> 00:21:58.276
but they won't get sent quite

00:22:00.596 --> 00:22:00.706
yet.

00:22:00.986 --> 00:22:03.086
Next you need to write the body.

00:22:03.226 --> 00:22:04.876
And in this case we don't need

00:22:04.876 --> 00:22:06.356
to transform the application

00:22:06.356 --> 00:22:06.916
data at all.

00:22:07.316 --> 00:22:08.136
We can just call

00:22:08.326 --> 00:22:09.876
writeOutputNoCopy.

00:22:11.086 --> 00:22:13.236
This allows us to just take the

00:22:13.236 --> 00:22:14.546
direct application bytes and

00:22:14.546 --> 00:22:15.686
then queue them on the stream.

00:22:16.496 --> 00:22:17.476
When we return from

00:22:17.476 --> 00:22:20.116
handleOutput, all of the bytes

00:22:20.166 --> 00:22:21.536
will be sent out to connection.

00:22:22.016 --> 00:22:22.206
All right.

00:22:23.276 --> 00:22:25.176
So let's move on to handling

00:22:25.246 --> 00:22:25.636
input.

00:22:26.416 --> 00:22:28.606
Handling input is similar but a

00:22:28.606 --> 00:22:29.806
little bit more complicated.

00:22:30.856 --> 00:22:31.626
You'll be called with

00:22:31.626 --> 00:22:33.906
handleInput anytime your

00:22:33.906 --> 00:22:36.806
application has received new

00:22:36.806 --> 00:22:37.896
bytes on the connection.

00:22:38.506 --> 00:22:40.346
And if you're doing a header

00:22:40.496 --> 00:22:42.556
body type protocol, you have two

00:22:42.556 --> 00:22:42.956
jobs.

00:22:42.956 --> 00:22:45.206
You need to parse the header and

00:22:45.206 --> 00:22:46.306
then you need to parse the body.

00:22:46.966 --> 00:22:48.516
So, let's start with parsing the

00:22:48.516 --> 00:22:48.756
header.

00:22:49.376 --> 00:22:50.986
Here we have a fixed-length

00:22:50.986 --> 00:22:52.036
header for our protocol.

00:22:52.036 --> 00:22:53.236
We're going to have exactly 8

00:22:53.236 --> 00:22:53.726
bytes.

00:22:54.216 --> 00:22:55.526
And what we do is we call

00:22:55.606 --> 00:22:57.436
parseInput to start inspecting

00:22:57.436 --> 00:22:58.456
the stream of bytes that have

00:22:58.506 --> 00:22:59.486
come into the connection.

00:23:00.406 --> 00:23:01.446
And we can call it with a

00:23:01.446 --> 00:23:03.556
minimum and a maximum of 8 bytes

00:23:03.586 --> 00:23:05.026
because we want to look exactly

00:23:05.026 --> 00:23:05.826
at that 8-byte header.

00:23:06.456 --> 00:23:09.076
If this succeeds, you'll be

00:23:09.076 --> 00:23:10.796
called in the block and you'll

00:23:10.796 --> 00:23:12.066
be able to look at the actual

00:23:12.066 --> 00:23:13.826
buffer bytes, parse out your

00:23:13.826 --> 00:23:15.796
values, save them off into local

00:23:15.796 --> 00:23:17.576
variables if you need to.

00:23:18.156 --> 00:23:20.706
The return value to parse input

00:23:21.416 --> 00:23:22.786
indicates how many bytes you

00:23:22.786 --> 00:23:24.486
want to increment the input

00:23:24.486 --> 00:23:25.086
cursor by.

00:23:25.186 --> 00:23:26.896
You say, I am done handling

00:23:26.896 --> 00:23:27.846
these 8 bytes.

00:23:27.916 --> 00:23:29.046
We don't need to see them again.

00:23:29.046 --> 00:23:30.196
We don't need to deliver them to

00:23:30.196 --> 00:23:30.896
the application.

00:23:31.306 --> 00:23:34.936
Move on. Now you can handle the

00:23:34.936 --> 00:23:36.986
case in which not all 8 bytes

00:23:36.986 --> 00:23:37.806
were available yet.

00:23:38.296 --> 00:23:41.346
In this case, the parseInput

00:23:41.416 --> 00:23:43.416
function will fail and you can

00:23:43.506 --> 00:23:45.246
just wait for more bytes to

00:23:45.246 --> 00:23:45.936
become available.

00:23:46.726 --> 00:23:48.616
The return value from

00:23:48.616 --> 00:23:51.216
handleInput indicates the number

00:23:51.216 --> 00:23:52.786
of bytes that need to be present

00:23:52.786 --> 00:23:54.066
before you can successfully do

00:23:54.066 --> 00:23:54.546
more work.

00:23:54.976 --> 00:23:56.476
So in this case we're telling

00:23:56.476 --> 00:23:57.796
the connection, make sure

00:23:57.796 --> 00:23:59.496
there's 8 bytes before you wake

00:23:59.496 --> 00:24:01.376
me up again.

00:24:01.556 --> 00:24:04.376
If you are able to successfully

00:24:04.376 --> 00:24:06.706
read out your header, you can

00:24:06.706 --> 00:24:09.426
create a message object that you

00:24:09.426 --> 00:24:10.276
can deliver up to the

00:24:10.276 --> 00:24:11.826
application along with the data.

00:24:12.456 --> 00:24:14.796
This allows you to put in any

00:24:14.796 --> 00:24:16.846
custom values, types or other

00:24:16.896 --> 00:24:18.446
indicators that you want to send

00:24:18.516 --> 00:24:19.326
up to your application.

00:24:19.936 --> 00:24:23.766
And then lastly you call

00:24:23.766 --> 00:24:25.326
deliverInput or

00:24:25.326 --> 00:24:27.506
deliverInputNoCopy in this case.

00:24:28.096 --> 00:24:29.866
This allows you to mark the next

00:24:29.866 --> 00:24:31.656
certain range of bytes as

00:24:31.656 --> 00:24:32.916
application data that should be

00:24:32.916 --> 00:24:34.596
delivered directly up to the

00:24:34.596 --> 00:24:35.186
application.

00:24:35.736 --> 00:24:39.086
And this returns Boolean value

00:24:39.086 --> 00:24:41.446
to indicate whether or not all

00:24:41.446 --> 00:24:43.006
of the bytes were available and

00:24:43.136 --> 00:24:45.296
successfully were sent up or if

00:24:45.296 --> 00:24:46.656
the connection is going to wait.

00:24:47.096 --> 00:24:48.766
So you can actually deliverInput

00:24:48.766 --> 00:24:50.116
of a message that's a megabyte

00:24:50.116 --> 00:24:51.506
long, a gigabyte long if you

00:24:51.506 --> 00:24:53.476
need to, and will keep on

00:24:53.476 --> 00:24:54.866
streaming those bytes up as part

00:24:54.866 --> 00:24:56.336
of that one message and you

00:24:56.336 --> 00:24:57.426
don't need to wait for all the

00:24:57.426 --> 00:24:59.166
bytes to be present or handle

00:24:59.166 --> 00:24:59.956
them yourself.

00:25:02.466 --> 00:25:04.676
OK. So, I know it's a lot of

00:25:04.676 --> 00:25:06.176
code, but I think we're ready to

00:25:06.176 --> 00:25:08.266
go and implement the protocol

00:25:08.266 --> 00:25:09.786
for our game tic-tac-toe.

00:25:19.176 --> 00:25:19.886
OK. All right.

00:25:20.806 --> 00:25:22.546
So this is the same game that

00:25:22.666 --> 00:25:24.076
Eric began earlier.

00:25:24.906 --> 00:25:26.676
But I'm now creating a new class

00:25:26.816 --> 00:25:28.326
which I'm calling game protocol

00:25:28.396 --> 00:25:29.966
and this is going to conform to

00:25:29.966 --> 00:25:31.766
ProtocolFramerImplementation.

00:25:32.266 --> 00:25:34.786
I have defined two different

00:25:34.786 --> 00:25:36.616
types for my game.

00:25:36.616 --> 00:25:37.836
I want to have two different

00:25:37.836 --> 00:25:38.726
commands that we send.

00:25:39.696 --> 00:25:41.336
One is to select the character.

00:25:41.826 --> 00:25:43.826
So the first step of the game is

00:25:43.826 --> 00:25:45.176
that the player will decide

00:25:45.276 --> 00:25:46.766
which emoji family they want to

00:25:46.766 --> 00:25:46.976
be.

00:25:46.976 --> 00:25:48.346
Do they want to be a monkey or a

00:25:48.346 --> 00:25:48.726
bird?

00:25:49.986 --> 00:25:51.496
And then once each character has

00:25:51.496 --> 00:25:53.566
selected their character, they

00:25:53.566 --> 00:25:55.216
can start sending moves.

00:25:55.516 --> 00:25:57.006
And this would be a longer body.

00:25:57.006 --> 00:25:59.026
It will include the character

00:25:59.026 --> 00:26:01.436
along with the row and column

00:26:01.436 --> 00:26:02.026
values.

00:26:03.996 --> 00:26:04.666
All right.

00:26:04.666 --> 00:26:06.826
So, I remember that the first

00:26:06.826 --> 00:26:07.936
thing I need to do when I'm

00:26:07.936 --> 00:26:10.836
implementing a protocol is

00:26:11.046 --> 00:26:12.126
create a definition.

00:26:12.126 --> 00:26:15.446
And this is a handle based on my

00:26:15.446 --> 00:26:17.846
object that registers my object

00:26:17.896 --> 00:26:20.236
with the system and allows me to

00:26:20.236 --> 00:26:21.796
use this in connections.

00:26:26.476 --> 00:26:28.476
Next, I handle all of the basic

00:26:28.476 --> 00:26:29.226
callbacks.

00:26:29.576 --> 00:26:30.876
And here again, because I don't

00:26:30.876 --> 00:26:32.646
need to have my own handshake,

00:26:32.926 --> 00:26:34.456
when I get called with start, I

00:26:35.026 --> 00:26:37.576
can return a start result of

00:26:37.576 --> 00:26:37.806
ready.

00:26:40.026 --> 00:26:42.246
Next, let's handle sending and

00:26:42.246 --> 00:26:43.796
encapsulating my messages.

00:26:47.616 --> 00:26:49.696
Here I'm going to define my

00:26:49.696 --> 00:26:51.296
implementation of handleOutput.

00:26:55.696 --> 00:26:58.416
So my header is an 8-byte header

00:26:58.666 --> 00:26:59.946
that includes a type and a

00:26:59.946 --> 00:27:00.436
length.

00:27:00.626 --> 00:27:02.366
So first I need to know what is

00:27:02.366 --> 00:27:04.786
my type, and this I get from the

00:27:04.786 --> 00:27:06.326
message that the application

00:27:06.326 --> 00:27:06.636
sent.

00:27:06.636 --> 00:27:08.426
And we'll see that later on.

00:27:08.926 --> 00:27:12.376
I've created a custom extension

00:27:12.376 --> 00:27:14.386
to the framer message to extract

00:27:14.426 --> 00:27:16.456
my particular enum type out so

00:27:16.886 --> 00:27:18.646
that I can know if this is a

00:27:18.686 --> 00:27:20.356
character selection or a move.

00:27:21.096 --> 00:27:22.896
So once I have the type, I can

00:27:22.896 --> 00:27:25.426
instantiate my struct, my game

00:27:25.426 --> 00:27:27.126
protocol header with the type

00:27:27.906 --> 00:27:29.956
and the length that I was passed

00:27:29.956 --> 00:27:30.796
in handleOutput.

00:27:32.096 --> 00:27:33.736
I've already written code to

00:27:34.096 --> 00:27:35.776
encode that data that I got the

00:27:35.776 --> 00:27:38.286
type and the length as an 8-byte

00:27:38.476 --> 00:27:39.466
range of bytes.

00:27:39.786 --> 00:27:42.006
And I call writeOutput to queue

00:27:42.006 --> 00:27:43.356
that in the output stream.

00:27:43.856 --> 00:27:47.676
And the last thing I need to do

00:27:47.706 --> 00:27:48.896
now that I've written my header

00:27:49.116 --> 00:27:50.516
is write the body.

00:27:50.986 --> 00:27:51.846
And here I just call

00:27:51.846 --> 00:27:53.606
writeOutputNoCopy and indicate

00:27:53.606 --> 00:27:55.956
that the next range bytes are

00:27:55.956 --> 00:27:57.046
going to be the body of this

00:27:57.046 --> 00:27:57.516
message.

00:27:58.736 --> 00:28:00.256
And so once this returns, those

00:28:00.256 --> 00:28:01.586
bytes will be sent and I'm ready

00:28:01.586 --> 00:28:03.306
to handle more messages either

00:28:03.306 --> 00:28:04.086
in or out.

00:28:04.676 --> 00:28:08.656
OK. So that was writing.

00:28:08.656 --> 00:28:10.746
Now on reading, I'm going to

00:28:10.746 --> 00:28:11.646
handleInput.

00:28:14.536 --> 00:28:16.886
So first I want to read out and

00:28:16.886 --> 00:28:17.676
parse my header.

00:28:18.126 --> 00:28:19.836
So have a fixed sized header.

00:28:20.066 --> 00:28:21.346
It's going to be 8 bytes.

00:28:22.546 --> 00:28:24.486
I'm going to try to parse out a

00:28:24.486 --> 00:28:26.696
minimum of eight and a maximum

00:28:26.696 --> 00:28:28.816
of eight and I'll get called

00:28:28.816 --> 00:28:32.276
with my buffer whenever those 8

00:28:32.276 --> 00:28:34.296
bytes are available.

00:28:34.916 --> 00:28:37.156
So here I validate that the

00:28:37.156 --> 00:28:39.196
buffer is valid and then I

00:28:39.196 --> 00:28:42.296
create my structure to parse out

00:28:42.296 --> 00:28:44.146
those 8 bytes into the type and

00:28:44.146 --> 00:28:44.776
length field.

00:28:46.716 --> 00:28:47.746
Once I've successfully done

00:28:47.746 --> 00:28:49.556
that, I indicate that I want to

00:28:49.586 --> 00:28:51.996
increment my input cursor by 8

00:28:52.056 --> 00:28:53.486
bytes to say that I've consumed

00:28:53.486 --> 00:28:54.166
these bytes.

00:28:54.276 --> 00:28:59.036
I'm done with them.

00:28:59.256 --> 00:29:01.236
Now, I do need to also handle

00:29:01.236 --> 00:29:02.746
the case in which I didn't

00:29:02.746 --> 00:29:04.596
successfully parse all 8 bytes.

00:29:04.786 --> 00:29:06.106
Maybe only 5 bytes were

00:29:06.106 --> 00:29:06.596
available.

00:29:07.636 --> 00:29:08.876
And so parse will have failed

00:29:09.436 --> 00:29:10.926
and I will return from handle

00:29:10.926 --> 00:29:13.726
input and indicate that I need

00:29:13.726 --> 00:29:15.246
to wait for 8 bytes to be

00:29:15.246 --> 00:29:18.166
available before I do more work.

00:29:18.716 --> 00:29:20.026
But if I did get past this

00:29:20.066 --> 00:29:21.786
point, I know that I have a

00:29:21.786 --> 00:29:23.886
valid header that I can use to

00:29:23.886 --> 00:29:25.466
deliver up the rest of the

00:29:25.466 --> 00:29:25.976
application data.

00:29:29.756 --> 00:29:31.546
So now I'm going to create a

00:29:31.546 --> 00:29:32.516
message object.

00:29:32.806 --> 00:29:34.326
I'm going to store within that

00:29:34.326 --> 00:29:36.496
message object my specific

00:29:36.496 --> 00:29:37.986
message type.

00:29:40.176 --> 00:29:44.066
And lastly, I will call

00:29:44.066 --> 00:29:47.006
deliverInput with no copying and

00:29:47.006 --> 00:29:48.976
just tell the connection those

00:29:48.976 --> 00:29:50.706
next bytes that I parsed out

00:29:50.746 --> 00:29:52.266
based on the length, those are

00:29:52.266 --> 00:29:53.506
going to be the application

00:29:53.506 --> 00:29:55.256
data, and when your application

00:29:55.256 --> 00:29:56.586
receives a message, they'll

00:29:56.586 --> 00:29:58.106
receive exactly that chunk.

00:29:59.026 --> 00:30:00.266
So that's all I need to do.

00:30:00.396 --> 00:30:01.606
That's my full protocol.

00:30:01.606 --> 00:30:04.236
I am ready to learn how to int

00:30:04.346 --> 00:30:05.316
input that into my game

00:30:05.316 --> 00:30:05.846
connections.

00:30:09.181 --> 00:30:11.181
[ Aapplause ]

00:30:11.346 --> 00:30:11.586
All right.

00:30:14.756 --> 00:30:16.706
So, the good news is that this

00:30:16.706 --> 00:30:17.826
part is really easy.

00:30:18.516 --> 00:30:20.166
So all you have to do to add

00:30:20.236 --> 00:30:21.116
your protocol into your

00:30:21.116 --> 00:30:23.966
connections and reuse it is take

00:30:23.966 --> 00:30:25.426
that definition you made earlier

00:30:26.316 --> 00:30:28.306
and create some protocol options

00:30:28.396 --> 00:30:29.516
using that definition.

00:30:30.016 --> 00:30:32.426
So protocol options are the

00:30:32.476 --> 00:30:33.966
things that protocol stacks are

00:30:33.966 --> 00:30:34.426
made out of.

00:30:35.036 --> 00:30:37.016
You have your TCP options, your

00:30:37.016 --> 00:30:38.546
TLS options, and now you have

00:30:38.546 --> 00:30:39.806
your own custom protocol

00:30:39.806 --> 00:30:40.396
options.

00:30:41.036 --> 00:30:42.576
So when you create your

00:30:42.576 --> 00:30:43.816
parameters for your connection,

00:30:43.996 --> 00:30:45.766
let's say you're using TLS as

00:30:45.766 --> 00:30:46.946
you should to be secure,

00:30:48.226 --> 00:30:50.806
alongside TLS in your protocol

00:30:50.806 --> 00:30:53.096
stack, you can add directly into

00:30:53.096 --> 00:30:54.446
that array of application

00:30:54.446 --> 00:30:56.626
protocols your own protocol on

00:30:56.626 --> 00:30:56.926
top.

00:30:57.696 --> 00:30:58.736
And you can add multiple of

00:30:58.736 --> 00:31:00.506
these to have multiple layers of

00:31:00.506 --> 00:31:01.406
framing going on.

00:31:02.046 --> 00:31:03.206
And this is the same place that

00:31:03.206 --> 00:31:04.806
if you want to use WebSocket,

00:31:05.346 --> 00:31:06.676
which is a new system

00:31:06.676 --> 00:31:07.996
implementation that we have for

00:31:07.996 --> 00:31:09.746
you this year, you can add it

00:31:09.746 --> 00:31:10.496
into your connection.

00:31:11.886 --> 00:31:14.586
So WebSocket itself is

00:31:14.766 --> 00:31:16.976
implemented as a protocol framer

00:31:17.266 --> 00:31:19.226
using exactly the same API that

00:31:19.556 --> 00:31:21.036
you have available to you now.

00:31:21.356 --> 00:31:22.506
So it shows you just how

00:31:22.506 --> 00:31:24.786
powerful a framing protocol can

00:31:24.786 --> 00:31:25.006
be.

00:31:25.736 --> 00:31:26.596
But if you don't want to go

00:31:26.596 --> 00:31:27.556
through the work of writing your

00:31:27.556 --> 00:31:29.386
own, you can use WebSocket.

00:31:33.546 --> 00:31:34.726
So one point I want to make here

00:31:34.726 --> 00:31:36.666
is that some applications need

00:31:36.666 --> 00:31:38.926
to use different protocol stacks

00:31:39.256 --> 00:31:40.456
in different situations.

00:31:41.366 --> 00:31:43.156
And framing protocols are a

00:31:43.156 --> 00:31:46.136
really great way to make the

00:31:46.136 --> 00:31:47.436
contract between your

00:31:47.436 --> 00:31:48.806
application and the networking

00:31:48.806 --> 00:31:51.006
connection the same even when

00:31:51.006 --> 00:31:52.066
you're using different protocol

00:31:52.066 --> 00:31:52.596
stacks.

00:31:53.466 --> 00:31:54.916
So to give you an example of

00:31:54.916 --> 00:31:57.176
this, we use this on our system

00:31:57.516 --> 00:31:58.026
for DNS.

00:31:58.936 --> 00:32:01.506
So DNS usually sends datagram

00:32:01.506 --> 00:32:04.206
messages over UDP.

00:32:05.876 --> 00:32:08.306
But occasionally, DNS needs to

00:32:08.306 --> 00:32:10.256
run on top of the stream like

00:32:10.256 --> 00:32:10.736
TCP.

00:32:11.236 --> 00:32:12.846
And when it does this, there's a

00:32:12.846 --> 00:32:14.596
protocol that just has a very

00:32:14.596 --> 00:32:17.356
basic length body format to

00:32:17.356 --> 00:32:19.726
encode DNS over TCP.

00:32:20.726 --> 00:32:23.206
So we wrote a framer to define

00:32:23.206 --> 00:32:26.216
this simple encapsulation so

00:32:26.216 --> 00:32:28.106
that we can have the same code

00:32:28.106 --> 00:32:31.316
on top that sends DNS datagrams

00:32:31.456 --> 00:32:32.716
that doesn't have to care about

00:32:32.716 --> 00:32:34.626
whether it's going over UDP or

00:32:34.626 --> 00:32:36.526
TCP and it can just be the same

00:32:36.526 --> 00:32:36.876
logic.

00:32:37.396 --> 00:32:38.236
So this is a great way to

00:32:38.236 --> 00:32:40.676
separate out the concerns and be

00:32:40.676 --> 00:32:41.946
able to debug the parts of your

00:32:41.946 --> 00:32:43.196
application separately.

00:32:43.766 --> 00:32:47.506
So now that we've added our

00:32:47.506 --> 00:32:48.776
framing protocol onto our

00:32:48.776 --> 00:32:50.706
connections, we're ready to send

00:32:50.706 --> 00:32:52.306
and receive messages and we can

00:32:52.306 --> 00:32:55.086
use custom values as we're going

00:32:55.086 --> 00:32:56.166
to be using in our game.

00:32:57.476 --> 00:33:00.256
So Framer.Message lets you store

00:33:00.256 --> 00:33:02.896
key value pairs of any object

00:33:02.896 --> 00:33:05.436
type so that you can add in your

00:33:05.436 --> 00:33:07.366
own custom values to decorate

00:33:07.886 --> 00:33:10.586
your send operations and receive

00:33:10.586 --> 00:33:12.196
that information inside your

00:33:12.196 --> 00:33:12.646
protocol.

00:33:13.586 --> 00:33:15.416
So you can create a message and

00:33:15.486 --> 00:33:16.906
then when you've set it up how

00:33:16.906 --> 00:33:18.516
you like, you can add it to the

00:33:18.546 --> 00:33:21.476
context that you're sending your

00:33:21.476 --> 00:33:22.126
data on.

00:33:22.676 --> 00:33:25.006
So every send operation already

00:33:25.006 --> 00:33:28.186
has content along with context.

00:33:28.526 --> 00:33:30.376
And so the context describes how

00:33:30.376 --> 00:33:31.396
you want to send your data.

00:33:31.856 --> 00:33:33.546
So your Framer.Message is just a

00:33:33.546 --> 00:33:37.096
new way to send data.

00:33:37.276 --> 00:33:38.936
Receiving is very similar.

00:33:39.046 --> 00:33:40.936
When you call receiveMessage,

00:33:41.776 --> 00:33:43.196
you receive along with your

00:33:43.196 --> 00:33:44.936
content the context that

00:33:44.936 --> 00:33:46.766
describes how this data was

00:33:46.766 --> 00:33:47.276
received.

00:33:48.056 --> 00:33:49.746
And you can look using the

00:33:49.746 --> 00:33:52.026
definition of your protocol at

00:33:52.126 --> 00:33:53.956
the specific message values that

00:33:53.956 --> 00:33:56.196
your protocol framer delivered

00:33:56.196 --> 00:33:57.116
to you.

00:33:58.006 --> 00:34:00.786
OK. I think we are ready to go

00:34:00.936 --> 00:34:04.556
finish our tic-tac-toe game.

00:34:05.316 --> 00:34:05.826
All right.

00:34:06.696 --> 00:34:08.726
So we've already finished our

00:34:08.726 --> 00:34:09.565
game protocol.

00:34:10.206 --> 00:34:12.985
To add it into our connections,

00:34:13.045 --> 00:34:14.795
I'm going to go back to the

00:34:14.795 --> 00:34:16.496
parameters that Eric set up

00:34:16.556 --> 00:34:17.025
earlier.

00:34:17.025 --> 00:34:18.166
So he already set up our

00:34:18.166 --> 00:34:21.065
connections to use TCP and TLS

00:34:21.106 --> 00:34:22.216
with our passcode.

00:34:24.106 --> 00:34:28.085
Now, all I need to do is just

00:34:28.085 --> 00:34:29.036
add these two lines in.

00:34:29.036 --> 00:34:30.406
We're going to create some

00:34:30.406 --> 00:34:32.286
options based on my game

00:34:32.286 --> 00:34:34.696
protocol definition and just

00:34:34.696 --> 00:34:36.485
insert them into the array of

00:34:36.485 --> 00:34:37.956
application protocols I want to

00:34:37.956 --> 00:34:38.716
use in my connection.

00:34:39.386 --> 00:34:41.036
Now when the connection starts

00:34:41.036 --> 00:34:42.396
up between those two devices, it

00:34:42.646 --> 00:34:44.985
will be ready to start encoding

00:34:44.985 --> 00:34:46.616
messages over that stream.

00:34:47.096 --> 00:34:51.576
Now I'm also going to do a

00:34:51.576 --> 00:34:53.346
couple convenience functions

00:34:53.346 --> 00:34:54.676
within my connection to make it

00:34:54.746 --> 00:34:56.116
easier for my application to

00:34:56.116 --> 00:34:57.896
send and receive my custom

00:34:57.896 --> 00:34:58.786
message types.

00:34:59.836 --> 00:35:01.326
So here I have a connection

00:35:01.326 --> 00:35:03.856
object that sets up an

00:35:03.856 --> 00:35:05.646
NWConnection using the

00:35:05.646 --> 00:35:07.216
parameters that we just defined.

00:35:08.346 --> 00:35:09.726
Whenever the connection becomes

00:35:09.726 --> 00:35:11.326
ready, it's going to start

00:35:11.326 --> 00:35:13.496
receiving messages from the

00:35:13.496 --> 00:35:13.786
peer.

00:35:15.286 --> 00:35:16.746
So we need to receive next

00:35:16.746 --> 00:35:17.876
message and implement this.

00:35:21.376 --> 00:35:23.316
So what I'm going to do here is

00:35:23.316 --> 00:35:24.776
take my connection and call

00:35:24.776 --> 00:35:25.766
receiveMessage on it.

00:35:26.716 --> 00:35:28.116
I'm going to get the content

00:35:28.276 --> 00:35:29.656
along with the context.

00:35:30.516 --> 00:35:31.596
So I'm going to take that

00:35:31.596 --> 00:35:34.506
context and look at the specific

00:35:34.506 --> 00:35:37.086
metadata for my protocol, the

00:35:37.086 --> 00:35:38.476
game protocol definition.

00:35:39.516 --> 00:35:40.856
And that will give me my message

00:35:40.856 --> 00:35:43.266
object and allow me to deliver

00:35:43.266 --> 00:35:44.986
the message type along with the

00:35:44.986 --> 00:35:46.146
data up to the application.

00:35:47.116 --> 00:35:48.436
And then of course once I've

00:35:48.436 --> 00:35:49.616
successfully received one

00:35:49.616 --> 00:35:51.136
message, I'm going to call

00:35:51.136 --> 00:35:52.776
receiveNextMessage to do it all

00:35:52.776 --> 00:35:53.236
over again.

00:35:56.016 --> 00:35:57.676
I'm also going to define some

00:35:57.946 --> 00:35:59.236
helpers for sending.

00:35:59.646 --> 00:36:01.096
So whenever the application

00:36:01.096 --> 00:36:02.206
decides that the player is

00:36:02.206 --> 00:36:04.466
selecting a character, we can

00:36:04.466 --> 00:36:07.716
create a message and add the

00:36:07.716 --> 00:36:09.306
selected character type to it,

00:36:10.096 --> 00:36:11.946
add that on to our context and

00:36:11.946 --> 00:36:12.406
send it.

00:36:12.916 --> 00:36:15.826
I can do the same thing for

00:36:15.826 --> 00:36:16.816
sending a move, have a

00:36:16.816 --> 00:36:18.486
convenience here to say that I

00:36:18.486 --> 00:36:20.106
wanted to send a move, and then

00:36:20.106 --> 00:36:21.846
just take the application data

00:36:22.316 --> 00:36:23.556
and send it down the connection.

00:36:24.626 --> 00:36:25.626
So that's all we need to do.

00:36:25.886 --> 00:36:27.606
I think we're ready to play the

00:36:27.606 --> 00:36:28.616
game and I think we're going to

00:36:28.616 --> 00:36:29.416
need some help to this.

00:36:29.416 --> 00:36:30.626
So Eric, come back on stage.

00:36:32.456 --> 00:36:33.156
All right.

00:36:34.336 --> 00:36:35.896
So here Eric had already started

00:36:35.896 --> 00:36:38.476
hosting a game but I want to be

00:36:38.476 --> 00:36:39.546
the one hosting this one.

00:36:40.726 --> 00:36:41.136
Here we go.

00:36:41.136 --> 00:36:42.946
So Eric, how about you type in

00:36:42.946 --> 00:36:47.406
that passcode, 5176.

00:36:47.906 --> 00:36:48.686
Don't tell anyone [laughter].

00:36:49.906 --> 00:36:51.116
All right.

00:36:51.116 --> 00:36:52.826
So now we have a secure

00:36:52.826 --> 00:36:53.896
connection set up.

00:36:54.286 --> 00:36:55.336
It's using TLS.

00:36:55.826 --> 00:36:57.666
And when Eric selects a

00:36:57.666 --> 00:36:59.746
character-- he chose birds--

00:37:00.536 --> 00:37:02.136
he's sending the select

00:37:02.636 --> 00:37:04.556
character message across and I

00:37:04.556 --> 00:37:06.806
call receiveMessage over here, I

00:37:06.806 --> 00:37:07.926
receive that he selected that,

00:37:07.926 --> 00:37:08.936
I'm going to choose to be

00:37:08.936 --> 00:37:10.246
monkeys, why not.

00:37:11.066 --> 00:37:13.566
At this point, Eric will select

00:37:14.326 --> 00:37:16.186
a box to play and choose a

00:37:16.186 --> 00:37:16.806
character.

00:37:17.846 --> 00:37:18.116
All right.

00:37:18.116 --> 00:37:20.846
So he sent the move message over

00:37:20.846 --> 00:37:21.276
to me.

00:37:21.626 --> 00:37:22.616
I can receive a message.

00:37:22.616 --> 00:37:23.846
I get that it's a move.

00:37:23.846 --> 00:37:25.946
I know where he's placed it and

00:37:25.946 --> 00:37:29.606
I can decide, all right, there's

00:37:29.606 --> 00:37:30.936
a monkey up in the top corner,

00:37:31.386 --> 00:37:32.476
what's he going to do next?

00:37:33.786 --> 00:37:35.066
Uh-oh, he's looking like he's

00:37:35.106 --> 00:37:36.076
racing for the win.

00:37:36.256 --> 00:37:36.866
I don't know.

00:37:36.906 --> 00:37:38.336
I can't look at this.

00:37:38.756 --> 00:37:39.896
Tic-tac-toe is hard.

00:37:40.376 --> 00:37:42.236
It sounds like birds got the

00:37:42.296 --> 00:37:42.736
day.

00:37:43.446 --> 00:37:45.636
But as you can see, it's really

00:37:45.636 --> 00:37:47.496
easy to build this type of game

00:37:47.496 --> 00:37:50.076
and there's hopefully a lot more

00:37:50.076 --> 00:37:51.666
nuanced games you can build with

00:37:51.666 --> 00:37:53.196
this and lots of other

00:37:53.196 --> 00:37:53.846
applications.

00:37:53.846 --> 00:37:54.896
So we're really excited to see

00:37:54.896 --> 00:37:55.236
what you do.

00:37:56.516 --> 00:38:02.616
[ Applause ]

00:38:03.116 --> 00:38:04.546
All right.

00:38:07.116 --> 00:38:08.856
So before I move on, I want to

00:38:08.856 --> 00:38:10.276
make one last comment about

00:38:10.276 --> 00:38:11.316
framing protocols.

00:38:11.936 --> 00:38:14.156
So, many of you have been asking

00:38:14.156 --> 00:38:16.976
how you can use techniques like

00:38:17.136 --> 00:38:19.236
STARTTLS with your

00:38:19.236 --> 00:38:20.326
NWConnections.

00:38:20.776 --> 00:38:23.406
So STARTTLS is a technique that

00:38:23.406 --> 00:38:25.026
comes from the SMTP mail

00:38:25.026 --> 00:38:25.556
protocol.

00:38:25.556 --> 00:38:29.586
And it allows you to talk to a

00:38:29.586 --> 00:38:31.406
legacy server that you don't

00:38:31.406 --> 00:38:32.916
know whether or not it supports

00:38:32.996 --> 00:38:35.186
TLS and secure connections and

00:38:35.186 --> 00:38:36.576
do an initial handshake with it.

00:38:37.106 --> 00:38:39.096
And then if TLS is supported,

00:38:39.096 --> 00:38:40.956
you can add it part way through

00:38:40.956 --> 00:38:41.586
your connection.

00:38:41.856 --> 00:38:43.476
Now there wasn't a good way to

00:38:43.476 --> 00:38:45.196
do this before, but framing

00:38:45.196 --> 00:38:46.456
protocols gives you a great

00:38:46.456 --> 00:38:46.876
solution.

00:38:47.856 --> 00:38:50.726
So, if you create a STARTTLS

00:38:50.726 --> 00:38:52.206
framing protocol and add it into

00:38:52.206 --> 00:38:53.526
your connection, when your

00:38:53.526 --> 00:38:55.806
application starts, you can

00:38:55.916 --> 00:38:57.186
begin a handshake with the

00:38:57.186 --> 00:38:58.376
server to determine whether or

00:38:58.376 --> 00:38:59.606
not it supports TLS.

00:39:00.416 --> 00:39:01.386
And then we allow you to

00:39:01.386 --> 00:39:02.956
dynamically add in other

00:39:02.956 --> 00:39:04.836
protocols onto the stack above

00:39:04.836 --> 00:39:06.746
your framing protocol before you

00:39:06.746 --> 00:39:07.286
call ready.

00:39:07.956 --> 00:39:09.156
This way the application can

00:39:09.156 --> 00:39:11.736
remain unchanged and not have to

00:39:11.736 --> 00:39:13.436
worry about adding TLS part way

00:39:13.436 --> 00:39:13.866
through.

00:39:14.216 --> 00:39:15.926
It can just happen automatically

00:39:16.226 --> 00:39:17.446
with your framing protocol.

00:39:18.246 --> 00:39:19.216
So we think it's a really

00:39:19.216 --> 00:39:19.936
elegant solution.

00:39:21.516 --> 00:39:22.256
All right.

00:39:23.576 --> 00:39:24.366
Let's move on.

00:39:25.006 --> 00:39:27.146
So, we've talked about Bonjour,

00:39:27.146 --> 00:39:28.836
how we can make better

00:39:28.836 --> 00:39:30.276
peer-to-peer connections and use

00:39:30.276 --> 00:39:31.456
wide-area discovery.

00:39:31.686 --> 00:39:33.406
We talked about framing

00:39:33.406 --> 00:39:34.136
protocols.

00:39:35.086 --> 00:39:36.136
But now I want to take a bit of

00:39:36.136 --> 00:39:38.166
a step back and look at how you

00:39:38.166 --> 00:39:40.096
can collect metrics about the

00:39:40.096 --> 00:39:42.306
connections within your app.

00:39:43.356 --> 00:39:45.046
So collecting metrics is really,

00:39:45.046 --> 00:39:45.726
really critical.

00:39:46.876 --> 00:39:50.006
It allows you to validate that

00:39:50.006 --> 00:39:52.836
when you add new features into

00:39:52.836 --> 00:39:54.736
your app or onto your server

00:39:55.446 --> 00:39:56.366
that are supposed to help you

00:39:56.366 --> 00:39:57.546
get better performance that

00:39:57.546 --> 00:39:58.656
they're really doing it, like

00:39:58.656 --> 00:39:59.936
you're having the effects that

00:39:59.936 --> 00:40:00.566
you want.

00:40:01.526 --> 00:40:03.756
But it also helps you identify

00:40:04.346 --> 00:40:06.196
problems that your users may be

00:40:06.196 --> 00:40:08.016
encountering out in the real

00:40:08.016 --> 00:40:09.946
world that you don't notice on

00:40:10.826 --> 00:40:12.056
your desk.

00:40:12.516 --> 00:40:14.606
So this year, we have a lot of

00:40:14.606 --> 00:40:16.206
great new metrics to help you

00:40:16.206 --> 00:40:17.396
analyze your connections even

00:40:17.396 --> 00:40:17.696
more.

00:40:18.446 --> 00:40:20.426
URLSession already has many

00:40:20.426 --> 00:40:22.236
fantastic metrics but you'll be

00:40:22.236 --> 00:40:23.476
able to get even more.

00:40:23.546 --> 00:40:24.996
And for the first time in

00:40:24.996 --> 00:40:26.496
Network.framework, you will

00:40:26.496 --> 00:40:28.286
inspect your connections to

00:40:28.286 --> 00:40:30.486
understand many aspects of their

00:40:30.486 --> 00:40:31.166
performance.

00:40:32.926 --> 00:40:35.326
So in URLSession, you can

00:40:35.326 --> 00:40:37.016
already get a timing breakdown

00:40:37.286 --> 00:40:40.896
of DNS, TCP, TLS, and HTTP

00:40:40.896 --> 00:40:43.016
messages within your app.

00:40:44.456 --> 00:40:46.086
Now you'll be able to introspect

00:40:46.386 --> 00:40:48.726
even more connection properties

00:40:49.706 --> 00:40:53.006
along with the amount of data

00:40:53.006 --> 00:40:54.146
that you're sending for

00:40:54.146 --> 00:40:55.866
individual requests and

00:40:55.866 --> 00:40:56.546
responses.

00:40:58.816 --> 00:41:00.376
And in Network.framework, you'll

00:41:00.376 --> 00:41:01.856
be able to access a connection

00:41:01.856 --> 00:41:03.506
establishment report that

00:41:03.506 --> 00:41:04.966
summarizes everything that

00:41:04.966 --> 00:41:06.396
happened during your connection

00:41:06.396 --> 00:41:08.966
bring up along with data

00:41:08.966 --> 00:41:10.946
transfer reports that allow you

00:41:10.946 --> 00:41:12.236
to look at the performance of

00:41:12.346 --> 00:41:14.386
individual periods of time over

00:41:14.386 --> 00:41:15.036
your connection.

00:41:15.106 --> 00:41:16.666
And you have multiple of these

00:41:16.666 --> 00:41:17.836
running at the same time.

00:41:18.426 --> 00:41:21.546
So let's start with URLSession.

00:41:21.996 --> 00:41:25.116
As a reminder, all of the

00:41:25.116 --> 00:41:26.596
metrics in URLSession are

00:41:26.596 --> 00:41:27.356
available in the

00:41:27.356 --> 00:41:29.226
didFinishCollectingMetrics

00:41:29.416 --> 00:41:30.116
delegate call.

00:41:32.096 --> 00:41:34.086
So, here are some of the new

00:41:34.086 --> 00:41:36.016
things that you can access are

00:41:36.016 --> 00:41:37.326
the endpoints of the connection,

00:41:38.276 --> 00:41:40.566
the local and remote addresses

00:41:40.566 --> 00:41:41.236
and ports.

00:41:41.646 --> 00:41:43.756
You can also check out the

00:41:43.756 --> 00:41:45.036
security properties.

00:41:45.396 --> 00:41:48.836
Are you using TLS 1.3, the

00:41:48.836 --> 00:41:50.986
latest most secure and most

00:41:50.986 --> 00:41:52.436
performant version of TLS?

00:41:52.436 --> 00:41:55.886
You can also check the path

00:41:55.886 --> 00:41:56.666
properties.

00:41:57.636 --> 00:41:59.546
So, this tells you things like

00:41:59.796 --> 00:42:01.606
did your connection use a

00:42:01.606 --> 00:42:03.446
constrained low data mode

00:42:03.446 --> 00:42:05.656
network, or did you use an

00:42:05.656 --> 00:42:07.586
expensive cellular network?

00:42:10.216 --> 00:42:12.266
The equivalent metrics within

00:42:12.456 --> 00:42:14.586
Network.framework are in the

00:42:14.586 --> 00:42:15.506
establishment report.

00:42:16.346 --> 00:42:17.776
So this is available to you any

00:42:17.776 --> 00:42:19.056
time after your connection has

00:42:19.056 --> 00:42:20.816
moved into the ready state.

00:42:20.926 --> 00:42:23.416
And this gives you a breakdown

00:42:23.486 --> 00:42:26.426
if your DNS times, your protocol

00:42:26.426 --> 00:42:29.216
handshakes for TCP and TLS, as

00:42:29.216 --> 00:42:30.526
well as whether or not you used

00:42:30.526 --> 00:42:31.006
a proxy.

00:42:31.536 --> 00:42:33.576
Here's how it looks in code.

00:42:33.856 --> 00:42:34.986
So you take your connection and

00:42:34.986 --> 00:42:35.476
you call

00:42:35.676 --> 00:42:37.146
requestEstablishmentReport.

00:42:37.806 --> 00:42:39.886
And this takes a queue on which

00:42:39.886 --> 00:42:41.516
it will deliver the report.

00:42:42.696 --> 00:42:43.986
Once you have that you can check

00:42:43.986 --> 00:42:45.136
the overall time that the

00:42:45.136 --> 00:42:45.776
connection took.

00:42:46.296 --> 00:42:48.486
You can check the individual

00:42:48.486 --> 00:42:49.626
resolution steps.

00:42:49.836 --> 00:42:51.306
So if you were connecting by a

00:42:51.306 --> 00:42:53.416
Bonjour name, it may be

00:42:53.416 --> 00:42:55.056
resolving Bonjour names into

00:42:55.056 --> 00:42:56.886
host names and host names into

00:42:56.886 --> 00:42:58.756
addresses, and you can look at

00:42:58.786 --> 00:42:59.966
the timing breakdown on each of

00:42:59.966 --> 00:43:00.626
those steps.

00:43:01.136 --> 00:43:03.806
And you can also look at the

00:43:03.806 --> 00:43:06.286
individual timings for a TCP,

00:43:06.346 --> 00:43:08.256
TLS, as well as the round-trip

00:43:08.256 --> 00:43:09.126
times they observed.

00:43:09.346 --> 00:43:13.476
One point that I want to

00:43:13.476 --> 00:43:14.306
highlight that's really

00:43:14.306 --> 00:43:15.386
important to the overall

00:43:15.386 --> 00:43:16.566
performance of your connection

00:43:16.566 --> 00:43:18.936
establishment is the amount of

00:43:18.936 --> 00:43:20.756
time that it takes to resolve

00:43:20.886 --> 00:43:23.376
DNS and the source of where your

00:43:23.376 --> 00:43:25.166
DNS resolution came.

00:43:27.386 --> 00:43:30.286
So, many servers have a very

00:43:30.286 --> 00:43:32.876
short time to live configured on

00:43:32.876 --> 00:43:34.046
their DNS records.

00:43:34.446 --> 00:43:36.846
And they do this such that if a

00:43:36.846 --> 00:43:39.866
server goes down or the server

00:43:39.866 --> 00:43:40.886
wants to load balance over

00:43:40.946 --> 00:43:43.246
another IP address, it can

00:43:43.246 --> 00:43:44.956
quickly change the IP address

00:43:44.956 --> 00:43:47.546
record and have clients adjust

00:43:47.546 --> 00:43:49.056
and start using the new address.

00:43:50.166 --> 00:43:52.116
The downside, though, is that

00:43:52.116 --> 00:43:53.806
this really can hurt client

00:43:53.806 --> 00:43:54.546
performance.

00:43:55.736 --> 00:43:57.666
With a short time to live, a

00:43:57.666 --> 00:43:59.546
client will almost always have

00:43:59.616 --> 00:44:01.646
to take the round trip to do

00:44:01.646 --> 00:44:04.236
DNS, to request the address for

00:44:04.236 --> 00:44:06.106
the host name that you are

00:44:06.106 --> 00:44:06.766
connecting to.

00:44:07.286 --> 00:44:11.066
And this can be particularly bad

00:44:11.366 --> 00:44:12.866
for clients that have a high

00:44:12.866 --> 00:44:13.636
latency link.

00:44:14.286 --> 00:44:16.396
This is going to add hundreds of

00:44:16.396 --> 00:44:17.946
milliseconds or even seconds on

00:44:17.946 --> 00:44:19.156
to their connection times.

00:44:19.786 --> 00:44:22.126
And the worst part is most of

00:44:22.126 --> 00:44:23.816
the time, the server address has

00:44:23.816 --> 00:44:26.256
not changed at all, and so this

00:44:26.256 --> 00:44:27.296
is a wasted round trip.

00:44:28.426 --> 00:44:30.906
So, optimistic DNS is a solution

00:44:30.906 --> 00:44:33.016
that we released last year that

00:44:33.016 --> 00:44:34.256
solves this problem.

00:44:35.786 --> 00:44:37.636
Optimistic DNS allows your

00:44:37.636 --> 00:44:39.636
connection to optimistically

00:44:39.916 --> 00:44:42.376
connect to the last known good

00:44:42.376 --> 00:44:43.846
IP address for that host name,

00:44:44.816 --> 00:44:46.716
in parallel with issuing a new

00:44:46.716 --> 00:44:48.586
query for the host name's

00:44:48.636 --> 00:44:49.766
current address.

00:44:51.146 --> 00:44:52.776
If nothing has changed, which is

00:44:52.776 --> 00:44:55.246
almost always the case, the

00:44:55.246 --> 00:44:56.456
connection will just establish

00:44:56.456 --> 00:44:58.356
to the old IP address.

00:44:58.676 --> 00:45:00.016
But if something has changed

00:45:00.016 --> 00:45:01.266
you'll still get the new IP

00:45:01.266 --> 00:45:02.316
address and connect to it

00:45:02.316 --> 00:45:02.776
instead.

00:45:03.376 --> 00:45:05.126
We have been doing a lot of

00:45:05.126 --> 00:45:06.676
measurements on this and testing

00:45:07.206 --> 00:45:08.996
and it is a really great

00:45:08.996 --> 00:45:09.456
solution.

00:45:09.456 --> 00:45:11.126
And so this year, it is on by

00:45:11.126 --> 00:45:12.976
default for connections using

00:45:12.976 --> 00:45:14.156
Network.framework and

00:45:14.156 --> 00:45:14.936
URLSession.

00:45:16.736 --> 00:45:17.866
When you're looking at your

00:45:17.866 --> 00:45:19.146
establishment report, you can

00:45:19.146 --> 00:45:21.046
tell whether or not you used

00:45:21.046 --> 00:45:22.986
optimistic DNS by looking at the

00:45:22.986 --> 00:45:23.636
source.

00:45:24.116 --> 00:45:25.216
And if it says it's from the

00:45:25.216 --> 00:45:27.746
expired cache, that means we

00:45:27.746 --> 00:45:29.656
ended up using and benefiting

00:45:29.746 --> 00:45:30.966
from optimistic DNS.

00:45:31.726 --> 00:45:34.566
I want to show you a bit how you

00:45:34.566 --> 00:45:36.416
can use metrics to look at the

00:45:36.416 --> 00:45:38.196
performance of your connections

00:45:38.196 --> 00:45:39.926
and the benefit of optimistic

00:45:39.926 --> 00:45:47.196
DNS and TLS 1.3.

00:45:47.426 --> 00:45:49.766
OK. So here I have an

00:45:49.766 --> 00:45:51.556
application that's a very basic

00:45:51.556 --> 00:45:53.666
app to collect connection

00:45:53.666 --> 00:45:54.216
metrics.

00:45:54.346 --> 00:45:56.526
All it does is run a probe to a

00:45:56.526 --> 00:45:57.286
given website.

00:45:57.756 --> 00:45:58.006
All right.

00:45:58.656 --> 00:46:00.186
So here it is.

00:46:00.186 --> 00:46:01.836
I clicked Run Probe and I

00:46:01.836 --> 00:46:03.306
connected and it's pretty fast.

00:46:03.306 --> 00:46:07.156
I'm doing this on a great Wi-Fi

00:46:07.716 --> 00:46:07.916
network.

00:46:08.506 --> 00:46:10.336
But if you want to test a more

00:46:10.336 --> 00:46:12.176
realistic scenario or see the

00:46:12.176 --> 00:46:13.496
effects of different network

00:46:13.496 --> 00:46:15.606
conditions, you are now able to

00:46:16.146 --> 00:46:18.026
within the devices and

00:46:18.026 --> 00:46:20.806
simulators panel of Xcode access

00:46:20.806 --> 00:46:23.226
device conditions and simulate

00:46:23.646 --> 00:46:24.976
different network link

00:46:24.976 --> 00:46:25.626
conditions.

00:46:25.806 --> 00:46:26.886
So you can see what it's like

00:46:26.886 --> 00:46:29.226
potentially for your users in

00:46:29.446 --> 00:46:30.416
different scenarios [applause].

00:46:31.196 --> 00:46:33.286
Yes, it's great.

00:46:35.736 --> 00:46:37.126
So let's see what it looks like

00:46:37.296 --> 00:46:39.096
to have a high latency DNS link.

00:46:40.256 --> 00:46:41.826
So I clicked Start and you can

00:46:41.826 --> 00:46:42.936
tell that it's running because I

00:46:42.936 --> 00:46:45.496
have this gray box up in the

00:46:45.496 --> 00:46:46.426
upper left hand corner.

00:46:47.546 --> 00:46:50.266
So now, let's run that probe

00:46:50.266 --> 00:46:50.716
again.

00:46:50.716 --> 00:46:53.086
So it was fast.

00:46:53.796 --> 00:46:54.326
That's great.

00:46:54.546 --> 00:46:55.926
But you'll notice that it came

00:46:55.926 --> 00:46:57.486
from the expired cache.

00:46:57.966 --> 00:46:59.226
So this means that we ended up

00:46:59.276 --> 00:47:00.616
using optimistic DNS.

00:47:01.486 --> 00:47:04.476
So optimistic DNS is on by

00:47:04.476 --> 00:47:06.196
default but you-- we let you

00:47:06.196 --> 00:47:07.626
turn it off if you don't think

00:47:07.626 --> 00:47:08.826
it's appropriate for your

00:47:08.826 --> 00:47:09.236
server.

00:47:09.956 --> 00:47:11.186
So let's run the probe again.

00:47:11.836 --> 00:47:14.796
You can feel the seconds go by.

00:47:15.796 --> 00:47:17.766
So, this is potentially a bit

00:47:17.766 --> 00:47:18.606
exaggerated.

00:47:18.696 --> 00:47:19.936
Hopefully your users don't have

00:47:19.936 --> 00:47:21.986
three seconds of DNS latency but

00:47:21.986 --> 00:47:23.526
it can make a huge difference.

00:47:24.146 --> 00:47:26.956
Let's go to a bit more realistic

00:47:26.956 --> 00:47:30.086
scenario now, something like an

00:47:30.086 --> 00:47:31.836
average 3G network.

00:47:32.496 --> 00:47:35.956
I'm going to start this and run

00:47:35.956 --> 00:47:37.166
the probe one more time.

00:47:37.766 --> 00:47:40.436
So it wasn't quite as snappy as

00:47:40.436 --> 00:47:41.356
the first time I ran it.

00:47:42.096 --> 00:47:43.726
Overall you can see that I have

00:47:43.726 --> 00:47:45.866
about 600 milliseconds for the

00:47:45.866 --> 00:47:46.846
connection to establish.

00:47:47.306 --> 00:47:51.786
And TLS alone took around little

00:47:51.786 --> 00:47:53.416
bit less than 300 milliseconds,

00:47:53.416 --> 00:47:56.826
so about half of that time.

00:47:57.016 --> 00:47:59.006
So our server is configured to

00:47:59.006 --> 00:48:00.506
support TLS 1.3.

00:48:00.906 --> 00:48:04.166
Now TLS 1.3 generally only takes

00:48:04.206 --> 00:48:06.066
one round trip to do the full

00:48:06.066 --> 00:48:06.486
handshake.

00:48:06.776 --> 00:48:08.146
It's great improvement.

00:48:09.086 --> 00:48:10.286
But if your server doesn't

00:48:10.286 --> 00:48:11.946
support TLS 1.3, if it only

00:48:11.946 --> 00:48:14.806
supports TLS 1.2 or if you're

00:48:14.806 --> 00:48:18.416
using an API on your app that

00:48:18.416 --> 00:48:22.476
doesn't support TLS 1.3, you may

00:48:22.476 --> 00:48:24.836
see scenarios more like this in

00:48:24.836 --> 00:48:27.326
which TLS alone is now taking

00:48:27.616 --> 00:48:29.466
over 500 milliseconds, taking an

00:48:29.466 --> 00:48:30.246
extra round trip.

00:48:31.166 --> 00:48:31.906
And you can see that the

00:48:31.906 --> 00:48:34.286
connection time is almost-- it's

00:48:34.286 --> 00:48:35.576
over three-quarters of a second,

00:48:35.656 --> 00:48:36.496
almost at a second.

00:48:36.926 --> 00:48:37.946
And if you have many

00:48:37.946 --> 00:48:39.796
connections, this can really add

00:48:39.796 --> 00:48:42.466
up to perceivable user latency.

00:48:43.216 --> 00:48:44.376
So we encourage you that

00:48:44.376 --> 00:48:45.326
whenever you're testing your

00:48:45.326 --> 00:48:47.576
app, do a run through network

00:48:47.576 --> 00:48:49.276
link conditioner and try out

00:48:49.276 --> 00:48:50.856
some of these scenarios and

00:48:50.856 --> 00:48:52.746
validate that your app performs

00:48:52.746 --> 00:48:53.026
well.

00:49:01.196 --> 00:49:02.476
So the other category of

00:49:02.476 --> 00:49:04.546
metrics, have to do with the

00:49:04.546 --> 00:49:05.956
data transfer after the

00:49:05.956 --> 00:49:07.186
connection is established.

00:49:08.356 --> 00:49:10.576
So in URLSession, you are now

00:49:10.576 --> 00:49:12.456
going to be able to access more

00:49:12.456 --> 00:49:13.566
metrics about the number of

00:49:13.566 --> 00:49:15.496
bytes that you sent in the

00:49:15.496 --> 00:49:17.186
header and the body of your

00:49:17.186 --> 00:49:19.606
requests as well as the number

00:49:19.606 --> 00:49:21.356
of bytes that your receive in

00:49:21.356 --> 00:49:23.856
the headers and bodies of your

00:49:23.856 --> 00:49:24.686
responses.

00:49:25.606 --> 00:49:27.286
And this is really important if

00:49:27.286 --> 00:49:29.866
you are choosing a different URL

00:49:30.126 --> 00:49:32.916
to download less data in a low

00:49:32.916 --> 00:49:35.946
data mode network scenario, use

00:49:36.026 --> 00:49:37.196
this to validate that you're

00:49:37.256 --> 00:49:38.976
actually saving your user's

00:49:39.986 --> 00:49:40.106
bytes.

00:49:42.796 --> 00:49:44.616
In Network.framework, you can

00:49:44.616 --> 00:49:46.506
now access a data transfer

00:49:46.506 --> 00:49:48.426
report that summarizes the

00:49:48.426 --> 00:49:50.536
performance in terms of bytes

00:49:50.926 --> 00:49:52.886
and packets and round trip times

00:49:53.416 --> 00:49:56.026
for a given period of time on

00:49:56.026 --> 00:49:56.606
your connection.

00:49:56.986 --> 00:49:58.136
You can have multiple of these

00:49:58.136 --> 00:49:59.156
running at the same time and

00:49:59.246 --> 00:50:00.236
they should correspond to your

00:50:00.236 --> 00:50:00.976
application's activity.

00:50:01.236 --> 00:50:03.116
So if you send a burst of

00:50:03.116 --> 00:50:05.176
traffic, have that be within a

00:50:05.176 --> 00:50:06.236
data transfer report.

00:50:06.896 --> 00:50:08.576
And it's not as interesting to

00:50:08.656 --> 00:50:11.446
take reports of idle periods.

00:50:11.976 --> 00:50:14.176
The way that you do this is that

00:50:14.176 --> 00:50:15.956
at any point you can call start

00:50:15.956 --> 00:50:18.266
data transfer report on your

00:50:18.266 --> 00:50:18.776
connection.

00:50:19.286 --> 00:50:21.896
This begins gathering data about

00:50:21.896 --> 00:50:23.366
your connection's performance.

00:50:24.336 --> 00:50:25.946
And when you're done sending a

00:50:25.946 --> 00:50:27.126
bunch of data, you can call

00:50:27.126 --> 00:50:27.606
collect.

00:50:28.316 --> 00:50:29.746
This will summarize all of the

00:50:29.746 --> 00:50:31.606
data and give you a report.

00:50:32.836 --> 00:50:34.936
Now, if you're using multipath

00:50:34.996 --> 00:50:36.996
protocols, this will give you a

00:50:36.996 --> 00:50:39.446
breakdown of the amounts that

00:50:39.446 --> 00:50:41.456
were sent over each link that

00:50:41.456 --> 00:50:42.556
the multipath protocol was

00:50:42.556 --> 00:50:42.976
using.

00:50:43.896 --> 00:50:45.006
But many of you may be

00:50:45.006 --> 00:50:46.526
interested just in the aggregate

00:50:46.656 --> 00:50:47.316
path report.

00:50:48.716 --> 00:50:50.506
Here you can look at the number

00:50:50.506 --> 00:50:51.566
of packets that you sent and

00:50:51.566 --> 00:50:53.386
received, the number of bytes

00:50:53.386 --> 00:50:55.036
that were transferred, as well

00:50:55.036 --> 00:50:56.696
as the round-trip time details

00:50:56.696 --> 00:50:57.336
that you observed.

00:50:58.806 --> 00:51:00.756
So this is metrics we were

00:51:00.756 --> 00:51:02.306
really excited to see people

00:51:02.306 --> 00:51:04.316
adopt more metrics and help

00:51:04.416 --> 00:51:05.606
improve the performance of their

00:51:05.666 --> 00:51:06.076
apps.

00:51:06.966 --> 00:51:08.726
And to leave us with some great

00:51:08.726 --> 00:51:10.386
advice and new updates, I'd like

00:51:10.386 --> 00:51:11.416
to invite Stuart up to the

00:51:11.416 --> 00:51:11.856
stage.

00:51:12.516 --> 00:51:14.866
[ Applause ]

00:51:15.366 --> 00:51:16.116
>> Thank you, Tommy.

00:51:17.516 --> 00:51:19.286
It is my pleasure and privilege

00:51:19.606 --> 00:51:21.306
to present the wrap-up for what

00:51:21.306 --> 00:51:23.326
has been two hours of really

00:51:23.326 --> 00:51:24.766
great networking information

00:51:24.766 --> 00:51:26.046
from my fellow presenters.

00:51:26.916 --> 00:51:29.986
I'm going to start off with iPad

00:51:29.986 --> 00:51:30.906
apps for Mac.

00:51:31.956 --> 00:51:33.046
I know a lot of you are excited

00:51:33.046 --> 00:51:33.666
about this.

00:51:34.206 --> 00:51:35.626
When it comes to networking,

00:51:36.296 --> 00:51:36.936
there are very little

00:51:36.936 --> 00:51:38.726
differences on Apple platforms.

00:51:39.536 --> 00:51:41.056
One thing you will want to be

00:51:41.056 --> 00:51:44.626
aware of is in your Xcode

00:51:44.626 --> 00:51:47.166
settings, when you check the box

00:51:47.166 --> 00:51:51.036
for Mac, you will now see some

00:51:51.036 --> 00:51:51.826
new options.

00:51:52.216 --> 00:51:54.786
By default, outgoing connections

00:51:54.786 --> 00:51:56.306
are allowed but if you want

00:51:56.366 --> 00:51:57.636
incoming connections for your

00:51:57.636 --> 00:51:59.296
app as well, you have to check

00:51:59.296 --> 00:51:59.916
that box.

00:52:05.696 --> 00:52:07.976
On watchOS, we have new

00:52:07.976 --> 00:52:09.396
networking capabilities.

00:52:11.036 --> 00:52:12.946
Applications that do audio

00:52:12.946 --> 00:52:16.016
streaming using AVFoundation can

00:52:16.016 --> 00:52:18.756
now use direct networking, as

00:52:18.756 --> 00:52:20.696
long as they're using URLSession

00:52:21.046 --> 00:52:22.136
or Network.framework.

00:52:23.036 --> 00:52:24.576
Sockets is not available.

00:52:30.156 --> 00:52:33.226
We are also introducing TLS 1.3

00:52:33.636 --> 00:52:34.516
which gives you lots of

00:52:34.516 --> 00:52:35.196
benefits.

00:52:36.136 --> 00:52:38.166
TLS 1.3 has better connection

00:52:38.166 --> 00:52:38.866
performance.

00:52:39.036 --> 00:52:42.106
TLS 1.2 typically has two round

00:52:42.106 --> 00:52:43.466
trips to set up a connection.

00:52:43.546 --> 00:52:46.066
TLS 1.3 almost always does it in

00:52:46.066 --> 00:52:46.806
one round trip.

00:52:48.146 --> 00:52:51.646
TLS 1.2 used cryptographic

00:52:51.646 --> 00:52:53.236
algorithms that were believed to

00:52:53.236 --> 00:52:54.896
be good at the time but have

00:52:54.896 --> 00:52:55.986
since been shown type of

00:52:55.986 --> 00:52:56.586
weaknesses.

00:52:56.586 --> 00:52:58.096
And this is not just an academic

00:52:58.096 --> 00:52:58.756
concern.

00:52:58.806 --> 00:52:59.966
These have been exploited in

00:52:59.966 --> 00:53:00.486
practice.

00:53:01.676 --> 00:53:03.566
Those have all been removed in

00:53:03.566 --> 00:53:07.026
TLS 1.3 and all the

00:53:07.026 --> 00:53:08.866
cryptographic algorithms in TLS

00:53:08.866 --> 00:53:11.726
1.3 support authenticated

00:53:11.726 --> 00:53:13.696
encryption with associated data

00:53:13.986 --> 00:53:14.996
and forward secrecy.

00:53:16.176 --> 00:53:18.626
And finally, you all know that

00:53:18.626 --> 00:53:19.966
privacy is very important to

00:53:19.966 --> 00:53:20.466
Apple.

00:53:20.986 --> 00:53:23.416
TLS 1.3 has much better privacy.

00:53:24.176 --> 00:53:26.796
Many of their header fields and

00:53:27.006 --> 00:53:30.166
certificates in TLS 1.2 was sent

00:53:30.166 --> 00:53:30.706
in the clear.

00:53:31.186 --> 00:53:32.926
Those are now all encrypted in

00:53:32.926 --> 00:53:34.076
TLS 1.3.

00:53:34.686 --> 00:53:38.276
So, the call to action is start

00:53:38.276 --> 00:53:39.736
using TLS 1.3 on your

00:53:39.736 --> 00:53:41.856
applications and of course, make

00:53:41.856 --> 00:53:43.456
sure your servers are updated to

00:53:43.456 --> 00:53:46.996
support TLS 1.3 too.

00:53:47.616 --> 00:53:49.476
Now, you all know the importance

00:53:49.476 --> 00:53:50.476
of privacy to Apple.

00:53:51.146 --> 00:53:52.936
And one of the things we

00:53:52.936 --> 00:53:56.416
realized is that accessing Wi-Fi

00:53:56.416 --> 00:53:58.456
information can be used to infer

00:53:58.456 --> 00:53:59.286
locations.

00:53:59.916 --> 00:54:02.936
So starting now, to access that

00:54:02.936 --> 00:54:05.066
Wi-Fi information, you will need

00:54:05.456 --> 00:54:07.586
the same kind of privileges that

00:54:07.586 --> 00:54:09.126
you need to get other location

00:54:09.126 --> 00:54:09.736
information.

00:54:10.786 --> 00:54:12.626
The first step is in Xcode you

00:54:12.626 --> 00:54:14.716
have to add the capability to

00:54:14.716 --> 00:54:16.846
access Wi-Fi information to add

00:54:16.846 --> 00:54:18.666
the entitlement to your project,

00:54:18.666 --> 00:54:22.266
and then your app must meet one

00:54:22.266 --> 00:54:23.706
of three other criteria.

00:54:23.706 --> 00:54:26.086
If the user has given your app

00:54:26.386 --> 00:54:28.496
location access, then you can

00:54:28.496 --> 00:54:29.786
access the Wi-Fi network

00:54:29.786 --> 00:54:30.416
information.

00:54:31.556 --> 00:54:33.356
If your app is the currently

00:54:33.356 --> 00:54:35.766
enabled VPN app on the device,

00:54:36.376 --> 00:54:37.816
you can access the information.

00:54:37.986 --> 00:54:40.146
And finally, if your app is in

00:54:40.146 --> 00:54:42.276
any hotspot configuration app,

00:54:42.676 --> 00:54:44.036
then it can also access the

00:54:44.036 --> 00:54:45.396
information but only for the

00:54:45.396 --> 00:54:47.276
networks that it has configured.

00:54:48.496 --> 00:54:49.896
For more information you can

00:54:49.896 --> 00:54:51.436
also see the Wi-Fi framework.

00:54:52.066 --> 00:54:55.996
You've heard many times today

00:54:55.996 --> 00:54:57.096
I'm going to finish with a

00:54:57.096 --> 00:54:58.846
reminder about the importance of

00:54:58.846 --> 00:54:59.896
using the network link

00:54:59.896 --> 00:55:00.356
conditioner.

00:55:02.166 --> 00:55:03.716
It's very easy when you're

00:55:03.716 --> 00:55:05.446
developing your application in

00:55:05.446 --> 00:55:08.666
the simulator on a Mac with

00:55:08.666 --> 00:55:10.296
gigabit ethernet in it or

00:55:10.296 --> 00:55:12.276
talking to a local server on

00:55:12.276 --> 00:55:12.816
loop-back.

00:55:13.396 --> 00:55:15.686
When you have a server with zero

00:55:15.786 --> 00:55:18.216
latency and infinite bandwidth,

00:55:18.776 --> 00:55:19.796
it's not surprising that it

00:55:19.796 --> 00:55:20.496
performs well.

00:55:20.496 --> 00:55:21.746
But if you build your

00:55:21.746 --> 00:55:23.276
application that way, it can be

00:55:23.276 --> 00:55:25.996
very misleading and you can find

00:55:25.996 --> 00:55:27.836
out later when your app is in

00:55:27.836 --> 00:55:29.186
the hands of real users that it

00:55:29.186 --> 00:55:30.336
doesn't perform very well.

00:55:31.006 --> 00:55:33.566
If you get in the habit of going

00:55:33.826 --> 00:55:36.736
to device conditions and

00:55:37.406 --> 00:55:40.706
selecting a realistic network

00:55:40.706 --> 00:55:42.816
link condition, right from the

00:55:42.816 --> 00:55:44.056
start when you're developing

00:55:44.056 --> 00:55:46.396
your application and always test

00:55:46.396 --> 00:55:47.626
and run your application

00:55:47.936 --> 00:55:49.516
simulating realistic network

00:55:49.516 --> 00:55:52.866
conditions, then those bugs will

00:55:52.866 --> 00:55:54.986
not even happen in the first

00:55:56.876 --> 00:55:57.106
place.

00:55:57.186 --> 00:55:59.056
Another message we've been

00:55:59.056 --> 00:56:01.706
giving you for many years is to

00:56:01.706 --> 00:56:04.966
avoid pre-flight checks.

00:56:05.186 --> 00:56:08.936
Using constraints such as allow

00:56:08.936 --> 00:56:10.696
cellular or allow expansive

00:56:10.696 --> 00:56:12.546
networks gives you much better

00:56:12.546 --> 00:56:13.216
control.

00:56:13.366 --> 00:56:14.756
It's much easier to use.

00:56:14.926 --> 00:56:16.606
Once you start writing your apps

00:56:16.606 --> 00:56:18.606
this way, you'll wonder why you

00:56:18.606 --> 00:56:19.986
ever did pre-flight checks.

00:56:20.236 --> 00:56:22.326
And besides, pre-flight checks

00:56:22.326 --> 00:56:24.156
can never work reliably because

00:56:24.156 --> 00:56:25.056
they always have raised

00:56:25.056 --> 00:56:25.636
conditions.

00:56:26.526 --> 00:56:28.666
So to illustrate that, I'm going

00:56:28.666 --> 00:56:30.556
to use an example.

00:56:30.556 --> 00:56:32.476
This is an app that I really

00:56:32.476 --> 00:56:32.776
like.

00:56:33.316 --> 00:56:36.136
And to illustrate this, I've

00:56:36.636 --> 00:56:38.356
given them a deliberately

00:56:38.626 --> 00:56:41.366
exaggerated example of what it

00:56:41.366 --> 00:56:42.506
might do if it was a badly

00:56:42.506 --> 00:56:43.166
written app.

00:56:43.736 --> 00:56:45.036
This is telling the user to make

00:56:45.176 --> 00:56:46.646
sure that we're on Wi-Fi then

00:56:46.646 --> 00:56:47.376
click the button.

00:56:48.056 --> 00:56:49.536
But the user has no way to

00:56:49.536 --> 00:56:51.836
control what path the network

00:56:51.836 --> 00:56:52.926
connection will take, what they

00:56:53.366 --> 00:56:55.556
will typically do is look for

00:56:55.556 --> 00:56:57.016
the Wi-Fi bars and hope for the

00:56:57.016 --> 00:56:57.406
best.

00:56:58.226 --> 00:57:00.016
But as you learned today,

00:57:01.536 --> 00:57:03.336
knowing in advance how Wi-Fi is

00:57:03.336 --> 00:57:04.956
going to perform until you try

00:57:05.786 --> 00:57:06.776
is impossible.

00:57:07.516 --> 00:57:09.696
And the device may think it's on

00:57:09.696 --> 00:57:11.286
Wi-Fi but when it tries to use

00:57:11.286 --> 00:57:13.396
it, it turns out not to work.

00:57:13.496 --> 00:57:15.906
Now, when Wi-Fi Assist switches

00:57:15.906 --> 00:57:18.036
you from Wi-Fi to cellular,

00:57:18.036 --> 00:57:19.776
those Wi-Fi bars will disappear

00:57:20.236 --> 00:57:21.496
but by then it's too late, your

00:57:21.496 --> 00:57:22.746
connection has already happened.

00:57:23.546 --> 00:57:28.816
So, don't make the user guess.

00:57:29.256 --> 00:57:30.436
Don't just make connections and

00:57:30.436 --> 00:57:31.136
hope for the best.

00:57:31.706 --> 00:57:32.576
Let me show you how this

00:57:32.576 --> 00:57:35.096
application actually works.

00:57:35.386 --> 00:57:36.886
It makes its connections

00:57:37.796 --> 00:57:39.656
constrained to not allow

00:57:39.656 --> 00:57:40.576
cellular access.

00:57:41.176 --> 00:57:44.816
And starting in iOS 13, it can

00:57:44.816 --> 00:57:47.186
actually use the

00:57:47.186 --> 00:57:49.036
allowsExpensiveNetworkAccess

00:57:49.186 --> 00:57:50.956
control to let the system decide

00:57:51.096 --> 00:57:52.486
which is an expensive network.

00:57:53.666 --> 00:57:55.226
It also sets

00:57:55.226 --> 00:57:56.656
waitsForConnectivity equals

00:57:56.656 --> 00:57:57.076
true.

00:57:57.466 --> 00:57:58.866
That means the application

00:57:59.196 --> 00:58:00.376
doesn't have to retry

00:58:00.446 --> 00:58:01.276
repeatedly.

00:58:01.586 --> 00:58:02.766
The system will just wait

00:58:02.766 --> 00:58:04.046
patiently for as long as it

00:58:04.046 --> 00:58:05.216
takes for that connection to

00:58:05.216 --> 00:58:05.726
succeed.

00:58:07.306 --> 00:58:09.876
When the application tries to

00:58:09.876 --> 00:58:11.896
connect, if there is no Wi-Fi,

00:58:12.526 --> 00:58:14.506
its taskIsWaitingForConnectivity

00:58:14.506 --> 00:58:16.776
delegate gets called and that's

00:58:16.776 --> 00:58:18.616
when it can display UI giving

00:58:18.616 --> 00:58:20.906
the user the choice either move

00:58:20.906 --> 00:58:22.516
to somewhere with Wi-Fi or you

00:58:22.516 --> 00:58:23.986
can press the button if you want

00:58:23.986 --> 00:58:25.166
to go ahead and use cellular

00:58:25.166 --> 00:58:25.576
data.

00:58:26.896 --> 00:58:29.126
Some news about deprecations.

00:58:30.236 --> 00:58:31.786
If any of you are still using

00:58:31.786 --> 00:58:35.046
PAC files using the file or FTP

00:58:35.226 --> 00:58:36.946
URL schemes, those are no longer

00:58:36.946 --> 00:58:37.476
supported.

00:58:38.656 --> 00:58:40.366
If any of you are still using

00:58:40.366 --> 00:58:41.906
SPDY, SPDY was a great

00:58:41.906 --> 00:58:44.176
experimental protocol, that has

00:58:44.176 --> 00:58:46.496
now been replaced by HTTP 2,

00:58:47.006 --> 00:58:48.786
that's what Apple supports and

00:58:48.786 --> 00:58:49.506
that's where everything should

00:58:49.506 --> 00:58:50.726
be moving towards.

00:58:51.516 --> 00:58:54.066
And Secure Transport does not

00:58:54.066 --> 00:58:56.906
support TLS 1.3 and it will

00:58:56.906 --> 00:58:59.636
never support TLS 1.3 so another

00:58:59.636 --> 00:59:01.646
reason to move to URLSession or

00:59:01.646 --> 00:59:02.536
Network.framework.

00:59:03.066 --> 00:59:08.156
So to wrap up, this morning we

00:59:08.156 --> 00:59:10.606
talked about wide-area Bonjour

00:59:10.606 --> 00:59:17.756
discovery and how to advertise a

00:59:17.756 --> 00:59:18.796
tic-tac-toe game.

00:59:19.076 --> 00:59:22.386
Some of you may have wondered if

00:59:22.386 --> 00:59:23.816
that service type underscore

00:59:23.816 --> 00:59:26.546
tic-tac-toe was registered with

00:59:26.546 --> 00:59:26.796
Ayana.

00:59:27.056 --> 00:59:28.786
The answer is yes it is, you can

00:59:28.786 --> 00:59:29.716
check on the website [laughter].

00:59:33.376 --> 00:59:34.736
Tommy talked about building

00:59:34.736 --> 00:59:37.086
framing protocols and collecting

00:59:37.086 --> 00:59:39.436
metrics that make it easier for

00:59:39.436 --> 00:59:40.936
you to write your applications

00:59:41.396 --> 00:59:42.536
and make it easy for you to

00:59:42.536 --> 00:59:43.616
measure performance.

00:59:44.226 --> 00:59:48.226
And this morning, we talked

00:59:48.226 --> 00:59:50.506
about low data mode that lets

00:59:50.506 --> 00:59:52.206
you respect your user's wishes

00:59:52.206 --> 00:59:53.836
about when to conserve data.

00:59:54.526 --> 00:59:56.006
We talked about combining

00:59:56.006 --> 00:59:57.636
URLSession which is a great way

00:59:57.636 --> 00:59:59.356
to chain asynchronous operations

00:59:59.356 --> 00:59:59.866
together.

00:59:59.866 --> 01:00:01.976
And we talked about WebSocket.

01:00:02.046 --> 01:00:04.776
If you have web-based

01:00:04.776 --> 01:00:06.466
applications that use WebSocket

01:00:06.466 --> 01:00:08.126
to talk to the server, you can

01:00:08.126 --> 01:00:09.726
now use that same server with

01:00:09.726 --> 01:00:11.876
your native iOS apps.

01:00:12.886 --> 01:00:14.816
And Christoph Paasch told us all

01:00:14.816 --> 01:00:16.376
about mobility improvements with

01:00:16.376 --> 01:00:20.626
multipath TCP and Wi-Fi Assist.

01:00:21.486 --> 01:00:23.946
And on that note, many of you

01:00:24.456 --> 01:00:27.446
will know that ACM SIGCOMM is

01:00:27.806 --> 01:00:30.906
the world's leading academic

01:00:31.116 --> 01:00:32.546
conference for network research.

01:00:34.036 --> 01:00:35.686
And every year they have the

01:00:35.686 --> 01:00:37.446
Networking Systems Award that

01:00:37.446 --> 01:00:39.366
recognizes the work that's had

01:00:39.366 --> 01:00:41.756
the biggest impact in the area

01:00:41.756 --> 01:00:42.586
of networking.

01:00:43.336 --> 01:00:45.286
And this year, today, they

01:00:45.516 --> 01:00:47.536
announced that this year's award

01:00:47.996 --> 01:00:49.566
goes to Christoph Paasch and the

01:00:49.566 --> 01:00:51.346
rest of the team for multipath

01:00:51.426 --> 01:00:51.676
TCP.

01:00:52.516 --> 01:01:00.886
[ Applause ]

01:01:01.386 --> 01:01:02.606
We would love to see you all

01:01:02.606 --> 01:01:04.376
tomorrow in the networking lab.

01:01:04.986 --> 01:01:07.036
And if any of you are currently

01:01:07.036 --> 01:01:08.076
writing network kernel

01:01:08.076 --> 01:01:09.786
extensions, definitely go to

01:01:09.786 --> 01:01:11.746
tomorrow's session about network

01:01:11.746 --> 01:01:13.426
extensions for modern macOS.

01:01:13.706 --> 01:01:13.976
Thank you.

01:01:14.516 --> 01:01:17.500
[ Applause ]
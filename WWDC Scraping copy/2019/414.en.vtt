WEBVTT

00:00:01.516 --> 00:00:05.500
[ Music ]

00:00:09.516 --> 00:00:14.546
[ Applause ]

00:00:15.046 --> 00:00:16.276
>> Good afternoon and welcome to

00:00:16.276 --> 00:00:17.536
our session on Developing a

00:00:17.536 --> 00:00:18.886
Great Profiling Experience.

00:00:19.316 --> 00:00:20.406
I'm Daniel Delwood and I'll be

00:00:20.406 --> 00:00:21.656
joined by Kasper Harasim

00:00:21.656 --> 00:00:22.116
[phonetic].

00:00:22.116 --> 00:00:23.036
And today we're here to talk

00:00:23.036 --> 00:00:24.286
about making great Custom

00:00:24.286 --> 00:00:25.186
Instruments packages.

00:00:26.546 --> 00:00:28.256
Now as developers, we all strive

00:00:28.256 --> 00:00:29.366
to create excellent,

00:00:29.536 --> 00:00:31.026
maintainable, modular and

00:00:31.026 --> 00:00:31.666
reusable code.

00:00:32.156 --> 00:00:33.106
And we've all used frameworks

00:00:33.166 --> 00:00:34.766
designed by others and created

00:00:34.766 --> 00:00:35.786
code that we want others to be

00:00:35.786 --> 00:00:36.786
able to use well.

00:00:38.016 --> 00:00:39.436
And good API design and

00:00:39.436 --> 00:00:40.966
documentation are critical to

00:00:40.966 --> 00:00:42.646
the user's experience with your

00:00:42.646 --> 00:00:43.136
framework.

00:00:43.596 --> 00:00:45.066
But my hope is today that you

00:00:45.066 --> 00:00:46.036
consider developing an

00:00:46.036 --> 00:00:47.196
Instruments package as well.

00:00:48.226 --> 00:00:50.276
To see why, take Metal as an

00:00:50.276 --> 00:00:50.996
example.

00:00:51.376 --> 00:00:53.106
API design is central and the

00:00:53.106 --> 00:00:54.446
calls are organized around a set

00:00:54.446 --> 00:00:56.426
of core concepts, devices,

00:00:56.476 --> 00:00:57.876
command buffers, textures and

00:00:57.876 --> 00:00:58.116
more.

00:00:58.136 --> 00:01:00.326
But that's not the whole story.

00:01:00.906 --> 00:01:02.356
An API surface expresses what's

00:01:02.426 --> 00:01:04.385
possible, but documentation and

00:01:04.385 --> 00:01:06.436
example code are how others

00:01:06.436 --> 00:01:08.116
learn to compose these concepts

00:01:08.176 --> 00:01:08.906
into a great app.

00:01:09.516 --> 00:01:10.946
But that's not the whole story

00:01:10.946 --> 00:01:11.256
either.

00:01:12.046 --> 00:01:13.006
Both of the first two help

00:01:13.006 --> 00:01:14.836
developers write code using your

00:01:14.916 --> 00:01:15.876
classes or framework.

00:01:15.976 --> 00:01:17.546
But what happens when something

00:01:17.546 --> 00:01:17.996
goes wrong?

00:01:18.726 --> 00:01:20.326
Well, custom Instruments are a

00:01:20.326 --> 00:01:22.246
way for you as the author to

00:01:22.246 --> 00:01:23.316
teach others how to debug,

00:01:23.766 --> 00:01:25.426
optimize and really get the most

00:01:25.426 --> 00:01:26.346
out of your APIs.

00:01:26.856 --> 00:01:28.096
If you've used the Metal System

00:01:28.096 --> 00:01:29.266
Trace template in Instruments,

00:01:29.686 --> 00:01:30.536
then you've seen some of what's

00:01:30.606 --> 00:01:31.126
possible.

00:01:31.406 --> 00:01:33.186
Creating visual tools designed

00:01:33.216 --> 00:01:34.836
specifically for the concepts

00:01:34.836 --> 00:01:36.396
and APIs that you define.

00:01:36.646 --> 00:01:39.216
An Instruments package is a way

00:01:39.216 --> 00:01:40.786
for you to build transparency

00:01:41.196 --> 00:01:42.416
that under the hood your

00:01:42.416 --> 00:01:43.496
framework is tested,

00:01:43.626 --> 00:01:44.446
understandable and

00:01:44.446 --> 00:01:45.066
well-supported.

00:01:45.516 --> 00:01:46.626
And investing that time to

00:01:46.706 --> 00:01:48.156
create a custom instrument helps

00:01:48.256 --> 00:01:50.216
create confidence and trust that

00:01:50.216 --> 00:01:51.676
the code's doing exactly what

00:01:51.676 --> 00:01:52.216
you expect.

00:01:53.396 --> 00:01:54.886
Tools are also a great way to

00:01:54.886 --> 00:01:56.596
develop a cost model to know

00:01:56.596 --> 00:01:58.006
which calls are expensive and

00:01:58.006 --> 00:01:58.896
which are inexpensive.

00:01:59.466 --> 00:02:00.426
And when there's a performance

00:02:00.426 --> 00:02:01.866
problem, they're the best way to

00:02:01.866 --> 00:02:02.996
differentiate between a

00:02:02.996 --> 00:02:04.496
framework bug or a bug in the

00:02:04.496 --> 00:02:06.386
client code.

00:02:06.686 --> 00:02:08.506
Most importantly though, an

00:02:08.506 --> 00:02:10.265
instrument is an opportunity for

00:02:10.265 --> 00:02:11.596
you to tell your story.

00:02:11.596 --> 00:02:14.106
An Instruments package is your

00:02:14.106 --> 00:02:15.246
chance to explain what's going

00:02:15.246 --> 00:02:17.206
on to help visualize important

00:02:17.206 --> 00:02:18.786
metrics and help users quickly

00:02:18.786 --> 00:02:20.086
find problems when they arise.

00:02:20.966 --> 00:02:23.026
So today, we're going to cover

00:02:23.026 --> 00:02:23.696
how to build great

00:02:23.696 --> 00:02:24.946
instrumentation from the inside

00:02:24.946 --> 00:02:26.266
out, starting from the inside

00:02:26.266 --> 00:02:27.946
out of developing great trace

00:02:27.996 --> 00:02:29.066
points in your framework, and

00:02:29.376 --> 00:02:30.396
then building on them with

00:02:30.396 --> 00:02:32.446
schemas, modeling and structure

00:02:32.746 --> 00:02:34.356
inside Instruments before

00:02:34.356 --> 00:02:35.426
finally moving on to talking

00:02:35.426 --> 00:02:36.846
about visualization and the

00:02:36.846 --> 00:02:37.466
instrument's UI.

00:02:38.266 --> 00:02:40.486
So with tracing, modeling and

00:02:40.486 --> 00:02:41.896
visualization as our roadmap for

00:02:41.896 --> 00:02:44.426
today, let's dive right in and

00:02:44.426 --> 00:02:46.266
talk about OSSignpost.

00:02:47.896 --> 00:02:49.746
Now OSSignpost is a low-cost

00:02:49.746 --> 00:02:51.076
tracing primitive introduced in

00:02:51.076 --> 00:02:52.086
2018.

00:02:52.486 --> 00:02:53.856
And signposts come in two

00:02:53.856 --> 00:02:55.466
different kinds: .events and

00:02:55.466 --> 00:02:56.016
intervals.

00:02:56.786 --> 00:02:58.176
Now they support recording any

00:02:58.176 --> 00:02:59.356
kind of data through their

00:02:59.416 --> 00:03:01.326
printf like formatString in

00:03:01.326 --> 00:03:01.896
arguments.

00:03:02.356 --> 00:03:03.646
And different from printf, all

00:03:03.646 --> 00:03:05.496
signposts are named with a

00:03:05.496 --> 00:03:06.106
static string.

00:03:07.926 --> 00:03:09.816
Now in Swift, OSSignpost is just

00:03:09.816 --> 00:03:11.036
one core API with three

00:03:11.036 --> 00:03:13.256
different types: begin, end and

00:03:13.256 --> 00:03:13.446
event.

00:03:13.446 --> 00:03:15.936
And in C, their interface is

00:03:15.936 --> 00:03:17.416
exposed through three helpful

00:03:17.416 --> 00:03:17.956
macros.

00:03:19.076 --> 00:03:20.646
Now it's important to note that

00:03:20.646 --> 00:03:22.826
OSSignpost is built on OSLog

00:03:23.386 --> 00:03:24.206
which means that much of the

00:03:24.206 --> 00:03:25.106
tracing behavior and

00:03:25.106 --> 00:03:27.356
configurability is determined by

00:03:27.356 --> 00:03:28.406
the provided log handle.

00:03:29.436 --> 00:03:30.816
Now log handles are effectively

00:03:30.816 --> 00:03:32.136
named spaces for your tracing.

00:03:32.676 --> 00:03:34.196
They allow you to specify

00:03:34.296 --> 00:03:36.566
subsystem and category and

00:03:36.566 --> 00:03:39.136
together with that static name

00:03:39.136 --> 00:03:41.006
for each signpost, this provides

00:03:41.046 --> 00:03:42.296
the logical structure and

00:03:42.296 --> 00:03:43.836
hierarchy for your trace points.

00:03:46.046 --> 00:03:47.036
Now custom Instruments are built

00:03:47.036 --> 00:03:48.546
on OSSignpost for two main

00:03:48.546 --> 00:03:48.946
reasons.

00:03:49.656 --> 00:03:51.026
First, they're temporal.

00:03:52.076 --> 00:03:54.016
All signposts, whether .events

00:03:54.016 --> 00:03:56.206
or intervals, implicitly record

00:03:56.206 --> 00:03:57.756
a high-accuracy timestamp.

00:03:59.816 --> 00:04:00.776
It's also important to have

00:04:00.856 --> 00:04:02.056
first class support for

00:04:02.056 --> 00:04:03.396
overlapping intervals in our

00:04:03.466 --> 00:04:04.556
highly-concurrent world.

00:04:04.786 --> 00:04:06.636
And OSSignpost does this with

00:04:06.636 --> 00:04:07.526
Signpost IDs.

00:04:08.266 --> 00:04:10.816
These record enough context for

00:04:10.816 --> 00:04:12.186
matching up the related events,

00:04:12.476 --> 00:04:14.016
even when the begin or end event

00:04:14.076 --> 00:04:15.836
happen on different threads or

00:04:15.836 --> 00:04:16.745
different dispatch queues.

00:04:17.366 --> 00:04:19.406
Now the second reason for

00:04:19.406 --> 00:04:20.906
OSSignpost is that they're

00:04:20.906 --> 00:04:21.606
low-cost.

00:04:22.236 --> 00:04:23.726
The logging mechanism is

00:04:23.726 --> 00:04:25.096
designed with efficiency in mind

00:04:25.576 --> 00:04:27.446
and it records a minimal amount

00:04:27.446 --> 00:04:28.636
of data whenever you admit an

00:04:28.636 --> 00:04:29.516
OSSignpost.

00:04:30.236 --> 00:04:31.586
Now there are optimizations

00:04:31.586 --> 00:04:33.766
around static strings, so things

00:04:33.766 --> 00:04:35.016
like your format string and your

00:04:35.016 --> 00:04:37.076
signpost name are actually

00:04:37.076 --> 00:04:38.906
emitted as just an offset into

00:04:38.906 --> 00:04:40.066
your binary text segment.

00:04:40.776 --> 00:04:41.826
Now in fact the overhead of

00:04:41.826 --> 00:04:44.716
OSSignpost is low enough that in

00:04:44.716 --> 00:04:46.486
most cases you can leave them in

00:04:46.486 --> 00:04:47.406
production code.

00:04:47.886 --> 00:04:49.056
So this is what makes them

00:04:49.056 --> 00:04:50.966
useful for building tools that

00:04:50.966 --> 00:04:52.726
debug optimized code in addition

00:04:52.726 --> 00:04:54.146
to helping you solve problems at

00:04:54.146 --> 00:04:55.546
your desk.

00:04:56.136 --> 00:04:57.136
Now when Instruments record

00:04:57.136 --> 00:04:58.666
signpost data, you'll get access

00:04:58.696 --> 00:05:00.766
to all the explicitly specified

00:05:00.866 --> 00:05:02.756
fields including that format

00:05:02.756 --> 00:05:03.796
string and then the arguments

00:05:03.796 --> 00:05:04.306
you provide.

00:05:05.226 --> 00:05:06.546
But in Instruments you'll also

00:05:06.546 --> 00:05:07.786
get access to all of the

00:05:07.786 --> 00:05:09.306
implicitly specified fields.

00:05:09.786 --> 00:05:11.766
Things like the timestamp or the

00:05:11.766 --> 00:05:12.926
calling thread which comes in

00:05:12.926 --> 00:05:13.496
really useful.

00:05:13.906 --> 00:05:15.746
If you're using a log handle

00:05:15.746 --> 00:05:17.566
that has backtraces enabled,

00:05:18.056 --> 00:05:20.136
then the call stack will also be

00:05:20.136 --> 00:05:21.746
recorded and made available to

00:05:21.746 --> 00:05:22.426
you in Instruments.

00:05:23.796 --> 00:05:25.186
So when adding tracing to your

00:05:25.186 --> 00:05:26.346
code, it's important to note

00:05:26.346 --> 00:05:28.596
that OSLog and OSSignpost

00:05:28.596 --> 00:05:30.286
behaves in three different

00:05:30.806 --> 00:05:30.926
modes.

00:05:31.366 --> 00:05:34.686
By default, OSLog is -- each

00:05:34.686 --> 00:05:36.436
OSLog handle has signposts

00:05:36.436 --> 00:05:36.866
enabled.

00:05:37.416 --> 00:05:39.096
And so they're still low-cost

00:05:39.096 --> 00:05:40.296
and only logged to a ring

00:05:40.296 --> 00:05:40.666
buffer.

00:05:41.936 --> 00:05:43.146
Now when Instruments or another

00:05:43.196 --> 00:05:45.606
client requests to display this

00:05:45.606 --> 00:05:48.506
data immediately, the OSLog

00:05:48.506 --> 00:05:49.736
system goes into a streaming

00:05:49.736 --> 00:05:51.546
mode which is a bit higher-cost.

00:05:53.106 --> 00:05:54.266
This year though there are two

00:05:54.266 --> 00:05:56.776
new dynamic categories that are

00:05:56.776 --> 00:05:57.886
only enabled when Instruments is

00:05:57.886 --> 00:05:58.386
recording.

00:05:59.126 --> 00:06:01.876
Now these dynamic categories are

00:06:01.876 --> 00:06:04.096
configured to record stack

00:06:04.096 --> 00:06:05.696
traces for the second one which

00:06:05.966 --> 00:06:07.056
adds a little bit of additional

00:06:07.056 --> 00:06:07.466
overhead.

00:06:08.006 --> 00:06:09.226
So with this in mind, what is

00:06:09.256 --> 00:06:11.376
the actual cost of OSSignpost?

00:06:13.056 --> 00:06:15.166
Well, many factors impact the

00:06:15.166 --> 00:06:16.336
real-world performance.

00:06:16.636 --> 00:06:17.946
Things like device type,

00:06:17.946 --> 00:06:20.246
hardware model, OS version,

00:06:20.246 --> 00:06:22.166
system load, thermals and more.

00:06:22.776 --> 00:06:23.936
So it's hard to give an exact

00:06:23.936 --> 00:06:24.306
number.

00:06:24.906 --> 00:06:26.116
But I'd like to give some order

00:06:26.116 --> 00:06:27.436
of magnitude approximations on a

00:06:27.436 --> 00:06:29.066
logarithmic scale, because I

00:06:29.066 --> 00:06:29.696
think it's useful for

00:06:29.696 --> 00:06:30.866
understanding the relative

00:06:30.866 --> 00:06:31.406
costs.

00:06:32.036 --> 00:06:33.636
If we look at Signposts in a

00:06:33.636 --> 00:06:35.836
release build, all of them clock

00:06:35.836 --> 00:06:37.136
in at under a microsecond.

00:06:37.476 --> 00:06:39.186
The new off-by-default dynamic

00:06:39.186 --> 00:06:40.926
categories are actually in the

00:06:40.926 --> 00:06:42.136
low nanosecond range.

00:06:43.256 --> 00:06:45.536
Now when Instruments is

00:06:45.536 --> 00:06:46.946
recording in deferred or last

00:06:46.946 --> 00:06:49.336
few second mode, these dynamic

00:06:49.336 --> 00:06:50.836
categories turn on to match the

00:06:50.836 --> 00:06:52.226
behavior of the on-by-default

00:06:52.226 --> 00:06:52.866
categories.

00:06:53.166 --> 00:06:55.336
And they are the same expense

00:06:55.336 --> 00:06:57.536
except for that dynamic stacks

00:06:57.536 --> 00:06:58.886
category which is a little bit

00:06:58.886 --> 00:07:00.076
more expensive in the low

00:07:00.076 --> 00:07:01.866
microsecond range due to the

00:07:01.866 --> 00:07:02.806
recording a call stack.

00:07:03.446 --> 00:07:05.436
Now when streaming mode is

00:07:05.436 --> 00:07:07.186
required though, all of these

00:07:07.186 --> 00:07:08.426
become significantly more

00:07:08.426 --> 00:07:10.496
expensive, moving into the tens

00:07:10.496 --> 00:07:11.426
of microseconds range.

00:07:12.086 --> 00:07:16.936
So with this in mind, what can

00:07:16.936 --> 00:07:18.126
you do to minimize the

00:07:18.126 --> 00:07:19.276
OSSignpost overhead while

00:07:19.276 --> 00:07:20.706
recording if you're concerned

00:07:20.706 --> 00:07:22.666
about that runtime cost or they

00:07:22.666 --> 00:07:23.506
start showing up in your

00:07:23.506 --> 00:07:23.986
profiles?

00:07:25.136 --> 00:07:26.446
Well, there's two easy things

00:07:26.506 --> 00:07:26.926
you can do.

00:07:27.446 --> 00:07:28.956
First of all, you can use

00:07:28.956 --> 00:07:30.386
Instruments' deferred or last few

00:07:30.386 --> 00:07:31.496
seconds mode instead of

00:07:31.496 --> 00:07:32.096
immediate mode.

00:07:32.586 --> 00:07:34.046
This keeps OSSignpost out of

00:07:34.046 --> 00:07:35.826
that streaming mode and reduces

00:07:35.826 --> 00:07:36.386
the overhead.

00:07:36.566 --> 00:07:37.796
And it's easy to configure a

00:07:37.796 --> 00:07:39.386
template to record in one of

00:07:39.386 --> 00:07:40.796
these modes when you open it.

00:07:43.506 --> 00:07:45.736
Also, if you use the new dynamic

00:07:45.736 --> 00:07:47.196
tracing categories, that's a

00:07:47.196 --> 00:07:48.686
great way to minimize overhead

00:07:48.686 --> 00:07:49.726
while not recording.

00:07:49.726 --> 00:07:51.926
Because the signposts will be

00:07:52.246 --> 00:07:53.966
off by default.

00:07:54.746 --> 00:07:55.776
They can only be enabled by

00:07:55.776 --> 00:07:57.396
custom instruments, so this data

00:07:57.396 --> 00:07:58.786
also won't crowd the tracks in

00:07:58.786 --> 00:08:01.596
the built-in OSSignpost tool.

00:08:02.476 --> 00:08:04.406
So as the author of a framework

00:08:04.406 --> 00:08:05.806
or a subsystem, just how many

00:08:05.806 --> 00:08:07.376
signposts is it reasonable to

00:08:07.376 --> 00:08:08.486
emit while you're profiling?

00:08:09.086 --> 00:08:10.086
Well, you can emit a lot.

00:08:10.086 --> 00:08:11.176
But let's assume a very

00:08:11.176 --> 00:08:12.486
conservative goal of staying

00:08:12.486 --> 00:08:15.226
under 1% CPU of even a single

00:08:15.226 --> 00:08:16.726
core while you're profiling.

00:08:17.136 --> 00:08:20.576
And then let's assume that the

00:08:20.896 --> 00:08:22.256
signposts have a rough cost,

00:08:22.256 --> 00:08:24.456
about half a microsecond per

00:08:24.456 --> 00:08:25.336
signpost enabled.

00:08:26.486 --> 00:08:28.016
Well, that math works out to

00:08:28.016 --> 00:08:29.456
20,000 signposts per second.

00:08:30.306 --> 00:08:31.956
And even in a display-link

00:08:31.956 --> 00:08:33.876
context on an iPad Pro running

00:08:33.876 --> 00:08:36.155
at 120 frames per second, that's

00:08:36.155 --> 00:08:38.076
still enough for 83 intervals

00:08:38.405 --> 00:08:39.035
per frame.

00:08:40.676 --> 00:08:43.066
Now again, the real-world

00:08:43.066 --> 00:08:45.626
performance will change and

00:08:45.626 --> 00:08:46.696
these are just estimates.

00:08:47.096 --> 00:08:48.836
So it's important to remember

00:08:48.836 --> 00:08:49.916
that signposts are a shared

00:08:49.916 --> 00:08:50.556
resource.

00:08:51.226 --> 00:08:53.046
The more you use, the more it

00:08:53.046 --> 00:08:54.246
will impact the logging system.

00:08:54.686 --> 00:08:56.706
That said, they're designed to

00:08:56.706 --> 00:08:58.146
allow for this high-rate tracing

00:08:58.146 --> 00:08:59.806
and it can come in really useful

00:08:59.806 --> 00:09:00.406
sometimes.

00:09:00.996 --> 00:09:02.216
Sometimes it's the key to

00:09:02.216 --> 00:09:04.016
figuring out a pipeline install

00:09:04.316 --> 00:09:05.746
or an ordering issue in your

00:09:05.746 --> 00:09:06.086
code.

00:09:06.956 --> 00:09:08.446
Keep in mind though that you may

00:09:08.446 --> 00:09:10.066
want to separate signposts out

00:09:10.496 --> 00:09:12.176
into different categories per

00:09:12.176 --> 00:09:12.766
audience.

00:09:13.406 --> 00:09:15.336
It's likely that your clients of

00:09:15.336 --> 00:09:16.496
your framework will need less

00:09:16.566 --> 00:09:18.046
detail than contributors of your

00:09:18.046 --> 00:09:19.686
framework who might need tracing

00:09:19.686 --> 00:09:21.016
of more implementation details.

00:09:21.336 --> 00:09:23.236
And if you split your trace

00:09:23.236 --> 00:09:24.816
points across multiple log

00:09:24.816 --> 00:09:26.796
handles, this allows your tools

00:09:26.796 --> 00:09:28.096
to only enable the necessary

00:09:28.096 --> 00:09:28.456
subset.

00:09:29.866 --> 00:09:31.636
Now as tracing is the basis for

00:09:31.636 --> 00:09:32.586
instrumentation, I want to

00:09:32.586 --> 00:09:33.656
quickly cover four best

00:09:33.656 --> 00:09:34.256
practices.

00:09:36.286 --> 00:09:37.526
First and most importantly,

00:09:38.186 --> 00:09:40.256
always end any intervals you

00:09:40.256 --> 00:09:40.636
begin.

00:09:41.326 --> 00:09:42.626
It's critical for correctness

00:09:43.536 --> 00:09:45.326
and permanently open intervals

00:09:45.326 --> 00:09:46.116
can really slow down

00:09:46.116 --> 00:09:47.406
Instruments' analysis as well.

00:09:48.426 --> 00:09:50.116
In this example, we have

00:09:50.266 --> 00:09:52.336
OSSignpost calls wrapping an

00:09:52.576 --> 00:09:53.956
expensive and potentially

00:09:53.956 --> 00:09:55.586
error-throwing piece of code.

00:09:56.456 --> 00:09:58.176
The problem is that if an error

00:09:58.176 --> 00:09:59.956
is thrown, then control flow

00:09:59.956 --> 00:10:01.926
jumps to the catch scope and

00:10:01.926 --> 00:10:03.526
skips our end signpost entirely.

00:10:05.036 --> 00:10:06.466
Now Swift's defer statement is

00:10:06.466 --> 00:10:07.696
really a great way to handle

00:10:07.696 --> 00:10:08.546
this, making sure that

00:10:08.546 --> 00:10:10.866
regardless of early returns or

00:10:10.866 --> 00:10:14.016
errors being thrown, that

00:10:14.016 --> 00:10:15.696
OSSignpost end call will still

00:10:15.696 --> 00:10:16.866
be called when we exit the

00:10:16.866 --> 00:10:17.416
current scope.

00:10:18.696 --> 00:10:21.396
So second, for efficiency, avoid

00:10:21.396 --> 00:10:22.936
logging identical data in both

00:10:23.006 --> 00:10:25.146
the begin and end trace points

00:10:25.326 --> 00:10:26.566
and log it in the first point

00:10:26.566 --> 00:10:27.306
it's available.

00:10:27.956 --> 00:10:29.396
This avoids that duplicate work

00:10:29.766 --> 00:10:31.266
and it gives Instruments a value

00:10:31.266 --> 00:10:32.196
as soon as possible.

00:10:32.576 --> 00:10:34.196
In this example, we don't need

00:10:34.196 --> 00:10:37.376
to repeat the request number or

00:10:37.376 --> 00:10:40.236
raw size, and instead of using

00:10:40.236 --> 00:10:41.826
the request number to match up

00:10:41.826 --> 00:10:43.306
the intervals in case of

00:10:43.306 --> 00:10:45.436
overlap, these points could

00:10:45.436 --> 00:10:47.906
actually use and generate a

00:10:47.906 --> 00:10:49.966
unique Signpost ID for this log

00:10:49.966 --> 00:10:51.876
handle per interval pair.

00:10:53.126 --> 00:10:55.196
So third, avoid doing

00:10:55.196 --> 00:10:57.786
unnecessary work when signposts

00:10:57.826 --> 00:10:58.496
aren't enabled.

00:10:59.366 --> 00:11:00.696
If your log handle is configured

00:11:00.696 --> 00:11:01.746
to use one of the dynamic

00:11:01.746 --> 00:11:03.326
tracing categories, then the

00:11:03.366 --> 00:11:04.716
signposts enabled property will

00:11:04.716 --> 00:11:05.536
indicate whether or not

00:11:05.536 --> 00:11:06.536
Instruments is recording at the

00:11:06.536 --> 00:11:08.466
time, which means it's a great

00:11:08.466 --> 00:11:11.126
way to put your expensive data

00:11:11.206 --> 00:11:13.026
computation behind that

00:11:13.326 --> 00:11:15.666
OSSignpost-enabled check.

00:11:16.656 --> 00:11:19.506
Fourth, only trace data that you

00:11:19.506 --> 00:11:20.516
actually need for your tools.

00:11:21.436 --> 00:11:22.266
Think about your guard

00:11:22.266 --> 00:11:23.406
statements and preconditions,

00:11:23.966 --> 00:11:25.096
because sometimes you'll want to

00:11:25.096 --> 00:11:26.686
trace these to include the short

00:11:26.686 --> 00:11:26.996
intervals.

00:11:27.526 --> 00:11:28.936
For example, if you've got a

00:11:28.936 --> 00:11:30.466
method and you want to see the

00:11:30.466 --> 00:11:31.756
difference between a cash hit

00:11:31.756 --> 00:11:32.636
and a cash miss.

00:11:33.696 --> 00:11:34.766
But other times these early

00:11:34.766 --> 00:11:36.366
returns will be uninteresting.

00:11:36.926 --> 00:11:39.156
And for these cases, consider

00:11:39.156 --> 00:11:41.146
moving the signpost after the

00:11:41.146 --> 00:11:42.846
preconditions to reduce the

00:11:42.846 --> 00:11:44.976
amount of data you send to the

00:11:44.976 --> 00:11:45.756
signpost system.

00:11:46.896 --> 00:11:48.466
Now with all these tips, it's

00:11:48.466 --> 00:11:50.126
important to remember that trace

00:11:50.166 --> 00:11:51.866
points are really the basis for

00:11:51.866 --> 00:11:52.836
all of the tools that you build

00:11:52.836 --> 00:11:53.466
on top.

00:11:53.726 --> 00:11:54.856
And most of the time they'll be

00:11:54.916 --> 00:11:56.546
present in your production code.

00:11:56.546 --> 00:11:57.996
So that's why it's important to

00:11:57.996 --> 00:11:59.526
think about performance and

00:11:59.526 --> 00:12:00.706
maintainability of your trace

00:12:00.756 --> 00:12:01.106
points.

00:12:01.916 --> 00:12:03.246
And since they're at the core,

00:12:03.576 --> 00:12:05.076
changes to your signpost calls

00:12:05.076 --> 00:12:06.116
might result in needing to

00:12:06.116 --> 00:12:07.286
change the tools that you build

00:12:07.286 --> 00:12:07.756
on top.

00:12:08.386 --> 00:12:10.546
So to keep your trace points

00:12:10.546 --> 00:12:12.196
stable, avoid tracing

00:12:12.196 --> 00:12:14.126
implementation details and try

00:12:14.126 --> 00:12:15.576
to add your OSSignpost calls

00:12:16.166 --> 00:12:17.516
closer to the API layer when

00:12:17.516 --> 00:12:18.006
possible.

00:12:18.986 --> 00:12:20.066
Now moving your trace points

00:12:20.066 --> 00:12:21.216
around your code base isn't a

00:12:21.216 --> 00:12:21.706
problem.

00:12:21.706 --> 00:12:22.776
Now you don't need to worry

00:12:22.776 --> 00:12:24.206
about compiler optimizations

00:12:24.206 --> 00:12:25.376
like inlining that might move

00:12:25.376 --> 00:12:25.896
them for you.

00:12:26.886 --> 00:12:28.616
The things that you need to make

00:12:28.616 --> 00:12:31.496
sure don't change are the static

00:12:31.496 --> 00:12:34.606
strings, specifically I mean the

00:12:34.816 --> 00:12:37.216
subsystem, the category, the

00:12:37.216 --> 00:12:39.266
signpost name or the format

00:12:39.266 --> 00:12:39.546
string.

00:12:39.786 --> 00:12:41.096
If you change any of these,

00:12:41.186 --> 00:12:41.926
you'll need to remember to

00:12:41.926 --> 00:12:43.276
update your Instruments package

00:12:43.276 --> 00:12:43.536
as well.

00:12:44.596 --> 00:12:46.326
So with that, let's move on to

00:12:46.326 --> 00:12:48.266
talking about modeling and

00:12:48.266 --> 00:12:50.386
adding structure to your data

00:12:50.386 --> 00:12:50.976
within Instruments.

00:12:53.166 --> 00:12:54.416
Instruments' architecture is

00:12:54.466 --> 00:12:55.786
based on everything being stored

00:12:55.786 --> 00:12:56.336
in tables.

00:12:56.896 --> 00:12:57.986
And schemas define the

00:12:57.986 --> 00:12:59.506
structures of those tables, all

00:12:59.506 --> 00:13:00.236
of which are measured by

00:13:00.236 --> 00:13:01.106
Instruments instant analysis

00:13:01.106 --> 00:13:01.326
core.

00:13:01.916 --> 00:13:03.996
For more in-depth intro to

00:13:03.996 --> 00:13:05.466
Instruments architecture, I'd

00:13:05.506 --> 00:13:07.046
recommend the Creating Custom

00:13:07.046 --> 00:13:08.476
Instruments talk from 2018.

00:13:08.726 --> 00:13:09.816
For now though, let's look at

00:13:09.816 --> 00:13:11.276
where modeling fits into

00:13:11.276 --> 00:13:12.946
creating a profiling experience.

00:13:13.586 --> 00:13:15.846
On the left, we've covered

00:13:15.846 --> 00:13:17.076
OSSignpost which is one of the

00:13:17.076 --> 00:13:18.326
main data sources that

00:13:18.326 --> 00:13:19.316
Instruments records from.

00:13:20.076 --> 00:13:21.056
This data is filled in the

00:13:21.056 --> 00:13:22.626
tables with the pre-defined

00:13:22.626 --> 00:13:24.016
schema for use by your Custom

00:13:24.016 --> 00:13:24.486
Instruments.

00:13:26.156 --> 00:13:27.426
Modeling is that next phase in

00:13:27.426 --> 00:13:27.906
the middle.

00:13:28.006 --> 00:13:29.946
A modeler observes data from one

00:13:29.946 --> 00:13:31.956
or more input tables, reasons

00:13:31.956 --> 00:13:34.596
about it and then emits data to

00:13:34.596 --> 00:13:36.026
one or more output tables of

00:13:36.026 --> 00:13:36.926
your specification.

00:13:38.146 --> 00:13:38.986
The modeler is where your

00:13:38.986 --> 00:13:40.696
domain-specific logic resides,

00:13:41.196 --> 00:13:42.486
and the schemas of the output

00:13:42.486 --> 00:13:45.106
tables are yours to specify

00:13:45.106 --> 00:13:46.956
which types and formatters to

00:13:46.956 --> 00:13:47.626
apply to your data.

00:13:49.406 --> 00:13:50.626
The final step on the right is

00:13:50.626 --> 00:13:52.606
visualization which is described

00:13:52.606 --> 00:13:54.376
in XML to the standard UI in

00:13:54.376 --> 00:13:54.956
Instruments.

00:13:55.456 --> 00:13:56.886
It's where you specify how to

00:13:56.946 --> 00:13:58.116
graph and display the data in

00:13:58.116 --> 00:13:59.186
your modeler's output tables.

00:13:59.886 --> 00:14:01.156
Things like which columns to

00:14:01.156 --> 00:14:02.436
plot and uses the value.

00:14:02.436 --> 00:14:03.836
Or which columns to use for

00:14:03.836 --> 00:14:04.526
labels in color.

00:14:05.596 --> 00:14:06.716
Since all of the custom

00:14:06.716 --> 00:14:07.966
instrument's visualization is

00:14:08.046 --> 00:14:10.086
based on your schemas and your

00:14:10.086 --> 00:14:12.016
modelers' output, it's important

00:14:12.016 --> 00:14:13.606
to talk through that process of

00:14:13.606 --> 00:14:15.546
checking that your OSSignpost

00:14:15.546 --> 00:14:17.486
trace point are good, and then

00:14:17.656 --> 00:14:19.066
how to get this data into your

00:14:19.066 --> 00:14:19.886
custom-defined schema.

00:14:23.056 --> 00:14:24.216
So all data in a custom

00:14:24.216 --> 00:14:25.406
instrument must be stored in

00:14:25.406 --> 00:14:27.326
tables that handle data in one

00:14:27.326 --> 00:14:27.986
of two ways.

00:14:28.836 --> 00:14:30.266
Point schemas have a timestamp

00:14:30.266 --> 00:14:32.766
column, and interval schemas

00:14:32.866 --> 00:14:34.216
have both a timestamp and a

00:14:34.216 --> 00:14:34.866
duration column.

00:14:35.706 --> 00:14:37.246
This means you'll need to define

00:14:37.246 --> 00:14:38.666
at least one pointer interval

00:14:38.666 --> 00:14:40.396
schema and then give names and

00:14:40.396 --> 00:14:41.186
types to the rest of the

00:14:41.186 --> 00:14:41.566
columns.

00:14:42.766 --> 00:14:44.226
Now the data will be filled in

00:14:44.536 --> 00:14:46.766
by modeling rules that operate

00:14:46.766 --> 00:14:47.396
on the input data.

00:14:47.396 --> 00:14:49.006
And these rules are expressed in

00:14:49.006 --> 00:14:49.756
Eclipse language.

00:14:50.446 --> 00:14:51.306
The good news is that

00:14:51.516 --> 00:14:53.616
Instruments provides a few

00:14:53.616 --> 00:14:55.546
schemas that will auto-generate

00:14:55.546 --> 00:14:56.016
modelers.

00:14:56.486 --> 00:14:57.716
So you don't have to jump into

00:14:57.716 --> 00:14:58.946
writing Eclipse code until you

00:14:58.946 --> 00:14:59.276
want to.

00:15:00.616 --> 00:15:02.466
In fact, if you're just starting

00:15:02.466 --> 00:15:03.386
and you want to make sure that

00:15:03.386 --> 00:15:05.086
your data's correct, Instruments

00:15:05.086 --> 00:15:06.626
provides a built-in OSSignpost

00:15:06.626 --> 00:15:08.606
tool in the library that's great

00:15:08.606 --> 00:15:10.196
for recording and checking that

00:15:10.196 --> 00:15:12.046
your OSSignpost intervals look

00:15:12.146 --> 00:15:12.586
reasonable.

00:15:12.586 --> 00:15:14.316
And the inspector can help you

00:15:14.316 --> 00:15:15.526
verify that the raw data is

00:15:15.526 --> 00:15:16.656
exactly what you expect.

00:15:17.766 --> 00:15:19.136
Now once you've checked your

00:15:19.266 --> 00:15:21.096
data, a new instruments target

00:15:21.576 --> 00:15:22.616
is a great way to start for

00:15:22.616 --> 00:15:23.266
building your own tool.

00:15:23.266 --> 00:15:25.506
With Xcode's built-in XML

00:15:25.506 --> 00:15:27.506
snippets for custom instruments,

00:15:27.876 --> 00:15:29.776
you're only a few elements away

00:15:30.006 --> 00:15:31.336
from an automatic modeler and an

00:15:31.436 --> 00:15:32.586
instrument in the library.

00:15:32.586 --> 00:15:34.076
And the best way to see what

00:15:34.076 --> 00:15:35.466
this looks like is with a demo.

00:15:35.466 --> 00:15:37.406
And for that, I'd like to invite

00:15:37.586 --> 00:15:38.936
up Kasper.

00:15:39.516 --> 00:15:44.546
[ Applause ]

00:15:45.046 --> 00:15:45.546
>> Thank you, Daniel.

00:15:45.546 --> 00:15:46.326
And hello, everyone.

00:15:49.046 --> 00:15:50.366
Our Solar System application on

00:15:50.366 --> 00:15:51.816
the Mac is dealing with a large

00:15:51.816 --> 00:15:53.866
amount of data about planets,

00:15:54.366 --> 00:15:56.386
images, videos and binary data.

00:15:57.116 --> 00:15:58.916
In order to optimize this usage,

00:15:59.126 --> 00:16:00.626
I built a framework called solar

00:16:00.626 --> 00:16:02.206
compression that uses samples

00:16:02.206 --> 00:16:03.546
compression library to

00:16:03.546 --> 00:16:05.296
efficiently encode and decode

00:16:05.296 --> 00:16:06.126
data from the disk.

00:16:07.166 --> 00:16:08.246
Now I want to build

00:16:08.246 --> 00:16:09.616
instrumentation for my framework

00:16:09.896 --> 00:16:11.006
to provide insights to the

00:16:11.006 --> 00:16:11.816
future users.

00:16:13.046 --> 00:16:14.206
We have two concepts that are

00:16:14.206 --> 00:16:15.616
worth tracking and presenting

00:16:15.616 --> 00:16:16.146
visually.

00:16:16.626 --> 00:16:18.816
Firstly, CompressionManager is

00:16:18.816 --> 00:16:19.886
an object that coordinates

00:16:19.886 --> 00:16:20.816
compression tasks.

00:16:21.476 --> 00:16:22.596
It's created with a number of

00:16:22.646 --> 00:16:24.266
channels which specifies how

00:16:24.266 --> 00:16:25.816
many tasks can be executed

00:16:25.816 --> 00:16:26.396
concurrently.

00:16:27.606 --> 00:16:28.986
Secondly, I would like to

00:16:28.986 --> 00:16:30.436
measure how well compression did

00:16:30.436 --> 00:16:32.086
for specific file types and

00:16:32.086 --> 00:16:33.626
algorithms by capturing

00:16:33.626 --> 00:16:34.516
compression ratio.

00:16:35.296 --> 00:16:37.166
By examining this, users can

00:16:37.166 --> 00:16:38.356
decide whether it's worth it to

00:16:38.356 --> 00:16:39.156
compress their data.

00:16:39.156 --> 00:16:41.916
I wrote intervals that represent

00:16:41.916 --> 00:16:43.636
this concept of my framework in

00:16:43.636 --> 00:16:45.836
OSSignpost API, so let's jump to

00:16:45.836 --> 00:16:46.926
the CompressionManager Swift

00:16:46.926 --> 00:16:47.876
file to take a look.

00:16:49.216 --> 00:16:50.656
Firstly, let's take a look at

00:16:50.656 --> 00:16:51.306
the log handle.

00:16:51.776 --> 00:16:53.156
My log handle specifies my

00:16:53.156 --> 00:16:54.786
framework's bundle identifier as

00:16:54.786 --> 00:16:56.906
a subsystem and my class name as

00:16:56.906 --> 00:16:57.666
a category.

00:16:59.296 --> 00:17:01.356
Compress and decompress are part

00:17:01.356 --> 00:17:02.566
of the public interface of

00:17:02.566 --> 00:17:03.516
compression manager.

00:17:04.626 --> 00:17:05.965
They both start by creating

00:17:05.965 --> 00:17:07.536
compression work item instance

00:17:07.665 --> 00:17:08.976
which encapsulates information

00:17:08.976 --> 00:17:10.415
about certain compression tasks.

00:17:11.236 --> 00:17:12.816
Next, they call into private

00:17:12.816 --> 00:17:14.026
SubmitWorkItemMethod.

00:17:15.796 --> 00:17:17.156
Because compression channels can

00:17:17.156 --> 00:17:18.705
be busy with work, there might

00:17:18.705 --> 00:17:20.486
be significant time between

00:17:20.486 --> 00:17:22.185
compression item creation and

00:17:22.185 --> 00:17:23.215
execution on the channel.

00:17:23.836 --> 00:17:24.996
And this is the perfect place to

00:17:24.996 --> 00:17:26.175
start measuring this delay.

00:17:27.236 --> 00:17:28.376
We'll do it by calling our

00:17:28.376 --> 00:17:30.346
signpost of type begin with

00:17:30.346 --> 00:17:31.576
CompressionItemWait name.

00:17:33.026 --> 00:17:34.466
Next, we can see our guard

00:17:34.466 --> 00:17:36.136
condition here which ensures

00:17:36.136 --> 00:17:37.966
that source file exists before

00:17:37.966 --> 00:17:38.976
we proceed any further.

00:17:39.866 --> 00:17:41.066
Following Daniel's advice, I

00:17:41.066 --> 00:17:42.366
will move it to the top of the

00:17:42.366 --> 00:17:43.856
function to ensure that my

00:17:43.856 --> 00:17:45.246
intervals are always closed.

00:17:46.686 --> 00:17:47.926
Next, we have

00:17:48.016 --> 00:17:50.216
ExecuteWorkItemMethod which is

00:17:50.216 --> 00:17:51.866
called when the compression task

00:17:51.866 --> 00:17:53.136
is ready to be executed on the

00:17:53.136 --> 00:17:53.486
channel.

00:17:53.776 --> 00:17:56.486
At first we need to indicate end

00:17:56.486 --> 00:17:58.256
of the wait time for the item by

00:17:58.256 --> 00:17:59.846
calling our signpost of type end

00:18:00.286 --> 00:18:01.466
with the same name as before.

00:18:02.046 --> 00:18:04.726
Next, we indicate beginning of

00:18:04.726 --> 00:18:05.936
the compression with

00:18:05.936 --> 00:18:07.396
CompressionExecution signpost.

00:18:08.256 --> 00:18:09.606
In the metadata, we have such

00:18:09.606 --> 00:18:11.466
things like algorithm, the kind

00:18:11.466 --> 00:18:13.876
of operation, information about

00:18:13.876 --> 00:18:16.306
the source, destination, channel

00:18:16.306 --> 00:18:17.156
and calling thread.

00:18:18.346 --> 00:18:20.236
As we learned before, OSSignpost

00:18:20.236 --> 00:18:22.146
implicitly records several

00:18:22.146 --> 00:18:24.386
parameters including thread so

00:18:24.386 --> 00:18:25.616
you are safe to remove the

00:18:25.706 --> 00:18:25.966
thread now.

00:18:31.456 --> 00:18:33.216
Next, we create destination file

00:18:33.766 --> 00:18:36.266
and synchronously execute

00:18:36.316 --> 00:18:37.326
compression operation.

00:18:37.806 --> 00:18:39.846
After it's finished, we log it

00:18:39.846 --> 00:18:41.436
and attach destination file

00:18:41.436 --> 00:18:41.726
size.

00:18:42.616 --> 00:18:43.686
This is another place where I

00:18:43.686 --> 00:18:44.826
can improve on my signpost

00:18:44.826 --> 00:18:45.456
invocations.

00:18:46.026 --> 00:18:46.986
You can notice that

00:18:46.986 --> 00:18:48.606
StartCompressionMethod over here

00:18:48.806 --> 00:18:49.676
is a throwing one.

00:18:50.206 --> 00:18:51.706
And if it does throw an error,

00:18:52.126 --> 00:18:53.326
the signpost invocation here

00:18:53.326 --> 00:18:54.086
will not be called.

00:18:55.066 --> 00:18:56.196
To prevent this from happening,

00:18:56.466 --> 00:18:58.006
I can introduce the defer block

00:18:58.006 --> 00:19:02.146
over here and move my code to be

00:19:02.146 --> 00:19:04.146
sure that the intervals are

00:19:04.146 --> 00:19:04.786
always closed.

00:19:07.656 --> 00:19:09.676
Now let's see our signpost in

00:19:09.676 --> 00:19:11.446
Instruments by using Xcode's

00:19:11.506 --> 00:19:11.956
Profile action.

00:19:19.416 --> 00:19:20.276
Let's start with a blank

00:19:20.326 --> 00:19:23.396
template, add our signpost

00:19:23.396 --> 00:19:26.656
instrument to it and record for

00:19:26.786 --> 00:19:27.966
just a few seconds.

00:19:32.366 --> 00:19:33.576
We can now examine the data.

00:19:33.786 --> 00:19:35.876
I will expand our signpost

00:19:35.876 --> 00:19:37.256
instrument to see all of the

00:19:37.256 --> 00:19:38.306
recorded subsystems.

00:19:39.856 --> 00:19:41.646
Here's our Solar Compression

00:19:41.646 --> 00:19:41.866
one.

00:19:42.046 --> 00:19:44.166
I can extend it further to see

00:19:44.166 --> 00:19:45.816
my Compression Manager category.

00:19:47.056 --> 00:19:48.846
Now I can resize this track to

00:19:48.846 --> 00:19:50.406
fit all of the contained graphs

00:19:50.456 --> 00:19:51.466
by using Control-Z.

00:19:52.896 --> 00:19:54.346
Let's pinch to zoom to examine

00:19:54.346 --> 00:19:55.456
the data in more detail.

00:19:56.116 --> 00:19:58.826
On the top we have all of the

00:19:58.826 --> 00:20:00.556
Compression Execution signposts.

00:20:01.416 --> 00:20:02.656
And on the bottom we see all of

00:20:02.656 --> 00:20:03.926
the intervals for the waiting

00:20:03.926 --> 00:20:04.396
tasks.

00:20:04.956 --> 00:20:06.676
And we can notice some patterns

00:20:06.676 --> 00:20:07.136
over here.

00:20:08.466 --> 00:20:10.366
For example, at most two tasks

00:20:10.436 --> 00:20:11.726
are executing at once, so

00:20:12.386 --> 00:20:14.086
probably application code is

00:20:14.086 --> 00:20:15.436
using two compression channels.

00:20:16.886 --> 00:20:19.206
Also we can see some spikes over

00:20:19.286 --> 00:20:21.396
here that indicate that a lot of

00:20:21.396 --> 00:20:22.516
tasks are waiting to be

00:20:22.516 --> 00:20:22.946
compressed.

00:20:25.446 --> 00:20:27.656
OSSignpost is a great tool for

00:20:27.656 --> 00:20:29.276
analysis of your own signposts,

00:20:29.546 --> 00:20:30.656
but usually doesn't provide

00:20:30.656 --> 00:20:32.666
enough context for analyzing

00:20:32.666 --> 00:20:33.506
them by your framework's

00:20:33.506 --> 00:20:33.936
audience.

00:20:35.076 --> 00:20:36.926
To improve on this, I built

00:20:36.926 --> 00:20:39.756
Solar Compression instrument

00:20:39.976 --> 00:20:41.426
that uses custom instruments.

00:20:42.366 --> 00:20:43.916
But putting these two signposts

00:20:44.156 --> 00:20:45.986
into two separate tables and

00:20:45.986 --> 00:20:47.136
adjusting instrument-standard

00:20:47.186 --> 00:20:48.996
UI, I managed to improve on our

00:20:48.996 --> 00:20:49.776
visualization.

00:20:50.296 --> 00:20:51.536
Let's open trace document

00:20:51.656 --> 00:20:52.946
containing this instrument now.

00:20:59.046 --> 00:21:00.616
On the bottom line we see all of

00:21:00.616 --> 00:21:01.976
the waiting tasks which are

00:21:01.976 --> 00:21:03.276
represented similarly to the

00:21:03.276 --> 00:21:04.306
OSSignpost instrument.

00:21:07.316 --> 00:21:08.926
On the top we see all of the

00:21:08.926 --> 00:21:10.536
execution intervals now

00:21:10.536 --> 00:21:12.286
separated by a channel so we can

00:21:12.286 --> 00:21:13.616
indeed see that there are two

00:21:13.616 --> 00:21:14.566
channels available.

00:21:16.216 --> 00:21:17.956
On the bottom over here I see

00:21:17.956 --> 00:21:19.296
all of the compression tasks

00:21:19.536 --> 00:21:20.416
with information on the

00:21:20.416 --> 00:21:22.596
interval, source path, file

00:21:22.596 --> 00:21:24.326
sizes, compression ratio, et

00:21:24.326 --> 00:21:24.666
cetera.

00:21:25.806 --> 00:21:27.046
There's one task that brings my

00:21:27.046 --> 00:21:27.596
attention.

00:21:27.886 --> 00:21:29.326
It's pretty long and it's

00:21:29.376 --> 00:21:31.356
colored in red, which means that

00:21:31.356 --> 00:21:32.646
the compression for this ratio

00:21:32.646 --> 00:21:34.676
for this task was slow.

00:21:34.676 --> 00:21:35.786
To easily see what kind of task

00:21:35.786 --> 00:21:37.506
it is, I can switch to active

00:21:37.506 --> 00:21:40.336
tasks detail which is set up to

00:21:40.336 --> 00:21:41.896
only show intervals that are

00:21:41.896 --> 00:21:43.476
intersecting my inspection head.

00:21:43.476 --> 00:21:45.876
I can move my inspection head

00:21:45.876 --> 00:21:48.796
and analyze a task.

00:21:48.796 --> 00:21:50.076
It seems that we are trying to

00:21:50.076 --> 00:21:52.066
compress zip archive and the

00:21:52.066 --> 00:21:53.986
file size decreased by a bit

00:21:53.986 --> 00:21:54.976
over 1%.

00:21:55.606 --> 00:21:57.016
That doesn't seem much and maybe

00:21:57.016 --> 00:21:58.036
you shouldn't be compressing it

00:21:58.036 --> 00:21:58.326
at all.

00:22:00.546 --> 00:22:02.306
Next, let's see task summary

00:22:02.306 --> 00:22:03.726
detail which aggregates all of

00:22:03.726 --> 00:22:04.766
the compression tasks.

00:22:05.286 --> 00:22:06.906
It provides three aggregation

00:22:06.906 --> 00:22:09.426
levels: compression kind, source

00:22:09.426 --> 00:22:11.046
extension and algorithm.

00:22:12.286 --> 00:22:13.666
On the right we see different

00:22:13.666 --> 00:22:15.406
statistical information such as

00:22:15.496 --> 00:22:16.786
average compression ratio,

00:22:17.086 --> 00:22:19.586
duration or total saved space.

00:22:20.556 --> 00:22:22.406
This detail is very useful for

00:22:22.406 --> 00:22:23.516
comparing between different

00:22:23.516 --> 00:22:25.206
algorithms or looking at how

00:22:25.206 --> 00:22:27.026
compression ratio changes along

00:22:27.026 --> 00:22:27.786
with the file type.

00:22:28.736 --> 00:22:30.556
For example, we can see that our

00:22:30.556 --> 00:22:33.246
JPEG file size decreased by on

00:22:33.246 --> 00:22:35.986
average by 34% which seems

00:22:35.986 --> 00:22:37.026
pretty good for already

00:22:37.026 --> 00:22:38.066
heavily-compressed file.

00:22:38.066 --> 00:22:40.966
Now let's take a look at how it

00:22:40.966 --> 00:22:42.836
all looks in the Instrument

00:22:42.836 --> 00:22:43.376
Inspector.

00:22:47.236 --> 00:22:48.996
We have OSSignpost table over

00:22:48.996 --> 00:22:51.356
here which is a point schema.

00:22:51.946 --> 00:22:54.286
It looks at all of our begin and

00:22:54.286 --> 00:22:54.986
end events.

00:22:56.356 --> 00:22:58.166
We also have two tables for our

00:22:58.166 --> 00:22:59.506
signposts.

00:23:00.256 --> 00:23:02.156
Here is our execution table.

00:23:02.446 --> 00:23:03.966
It contains all of the data

00:23:03.966 --> 00:23:05.826
about tasks that we logged, but

00:23:05.826 --> 00:23:07.396
now it's formatted according to

00:23:07.396 --> 00:23:08.736
the engineering types that we

00:23:08.736 --> 00:23:09.126
assigned.

00:23:09.696 --> 00:23:13.296
On the right over here we can

00:23:13.296 --> 00:23:14.816
see that this table is directly

00:23:14.816 --> 00:23:15.866
consumed by the UI.

00:23:19.406 --> 00:23:20.406
I'm pretty happy about my

00:23:20.406 --> 00:23:21.306
instruments so far.

00:23:21.896 --> 00:23:22.976
One thing I would like to

00:23:22.976 --> 00:23:24.556
improve on is how the waiting

00:23:24.556 --> 00:23:25.746
tasks are represented.

00:23:26.516 --> 00:23:27.736
Instead of seeing specific

00:23:27.736 --> 00:23:29.166
intervals, I would like to have

00:23:29.286 --> 00:23:31.396
some way of summarizing them to

00:23:31.496 --> 00:23:32.946
clearly point out the areas of

00:23:33.036 --> 00:23:33.536
higher load.

00:23:34.396 --> 00:23:35.366
I think that Daniel might have

00:23:35.366 --> 00:23:36.746
some ideas on how to achieve it.

00:23:37.426 --> 00:23:37.796
Daniel?

00:23:41.516 --> 00:23:45.796
[ Applause ]

00:23:46.296 --> 00:23:46.946
>> Thanks, Kasper.

00:23:46.946 --> 00:23:48.996
As Kasper showed, the OSSignpost

00:23:48.996 --> 00:23:50.276
instrument in the library and

00:23:50.476 --> 00:23:52.316
the Inspector are great ways to

00:23:52.316 --> 00:23:54.006
visualize your raw data and to

00:23:54.006 --> 00:23:55.246
check that instrument sees the

00:23:55.246 --> 00:23:56.046
data you expect.

00:23:56.646 --> 00:23:58.496
And even without diving into

00:23:58.496 --> 00:23:59.496
writing a custom Eclipse

00:23:59.496 --> 00:24:01.066
modeler, Kasper was able to

00:24:01.116 --> 00:24:02.126
present an instrument that

00:24:02.126 --> 00:24:03.306
presented his data in a more

00:24:03.306 --> 00:24:04.896
meaningful way using his

00:24:04.976 --> 00:24:05.986
framework's compression

00:24:05.986 --> 00:24:06.646
concepts.

00:24:07.066 --> 00:24:08.586
There were just four trace

00:24:08.586 --> 00:24:10.686
points and two OSSignpost

00:24:10.686 --> 00:24:11.486
interval schemas.

00:24:12.336 --> 00:24:13.906
That said, it wasn't quite the

00:24:13.906 --> 00:24:15.476
profiling experience he wanted

00:24:15.476 --> 00:24:15.846
to create.

00:24:16.596 --> 00:24:18.396
Now custom modelers are a great

00:24:18.396 --> 00:24:19.736
way for tailoring that

00:24:19.736 --> 00:24:20.406
experience.

00:24:20.826 --> 00:24:22.406
They all you to fuse data for

00:24:22.406 --> 00:24:23.926
multiple log handles and even

00:24:23.926 --> 00:24:25.296
use data from built-in tables.

00:24:25.936 --> 00:24:27.236
They enable you to embed more

00:24:27.356 --> 00:24:29.326
complex logic, to maintain

00:24:29.326 --> 00:24:31.076
state, and the reason about the

00:24:31.076 --> 00:24:32.526
order of events.

00:24:32.886 --> 00:24:33.996
Writing your own custom modeler

00:24:33.996 --> 00:24:35.306
can also be useful for some of

00:24:35.306 --> 00:24:37.416
the more custom graphing and

00:24:37.506 --> 00:24:38.576
detailed use schemas.

00:24:39.206 --> 00:24:40.826
The point schema, interval

00:24:40.826 --> 00:24:42.456
schema and modeler tags are a

00:24:42.456 --> 00:24:44.086
great way to get started, but

00:24:44.086 --> 00:24:45.016
it's a deep subject we don't

00:24:45.016 --> 00:24:45.886
have time to cover in this

00:24:45.886 --> 00:24:46.206
session.

00:24:46.526 --> 00:24:48.046
For more on custom modeling

00:24:48.046 --> 00:24:50.046
though, the 2019 Modeling and

00:24:50.046 --> 00:24:51.606
Custom Instruments talk goes

00:24:51.606 --> 00:24:52.926
into a lot more depth and it

00:24:52.926 --> 00:24:53.826
comes with sample code.

00:24:54.666 --> 00:24:56.246
So let's move on to talking

00:24:56.246 --> 00:24:58.826
about the UI part of a profiling

00:24:58.826 --> 00:25:01.056
experience, visualization.

00:25:02.426 --> 00:25:03.736
Visualization is all about the

00:25:03.736 --> 00:25:06.106
chance for you as the author to

00:25:06.106 --> 00:25:07.076
tell your story to the

00:25:07.076 --> 00:25:08.076
developers who will use your

00:25:08.076 --> 00:25:08.336
code.

00:25:08.336 --> 00:25:10.386
And the most important principle

00:25:10.386 --> 00:25:12.896
to remember is that data is not

00:25:12.896 --> 00:25:14.286
the same thing as a story.

00:25:15.216 --> 00:25:17.326
Just as Kasper showed by looking

00:25:17.326 --> 00:25:18.726
at the built-in OSSignpost

00:25:18.726 --> 00:25:20.876
graphs, raw intervals are only

00:25:20.876 --> 00:25:21.866
good at conveying meaning to

00:25:21.866 --> 00:25:22.356
their author.

00:25:23.356 --> 00:25:25.106
Users of your tool aren't going

00:25:25.106 --> 00:25:26.616
to intuitively know whether a

00:25:26.616 --> 00:25:28.896
gap in the timeline is good or

00:25:28.896 --> 00:25:31.066
bad or what processing phase was

00:25:31.106 --> 00:25:32.126
supposed to come next but

00:25:32.126 --> 00:25:32.536
didn't.

00:25:33.606 --> 00:25:34.366
As the developer of an

00:25:34.366 --> 00:25:35.966
instruments package, you get to

00:25:35.966 --> 00:25:37.416
go beyond just building

00:25:37.416 --> 00:25:38.816
visualization showing what

00:25:38.816 --> 00:25:39.326
happened.

00:25:39.946 --> 00:25:41.406
You get to teach and diagnose.

00:25:41.926 --> 00:25:43.136
You get to help your users find

00:25:43.136 --> 00:25:44.186
problems even when you're not

00:25:44.186 --> 00:25:44.416
there.

00:25:45.756 --> 00:25:47.236
And visualization isn't just

00:25:47.236 --> 00:25:48.046
about the graph either.

00:25:48.546 --> 00:25:49.606
Sometimes the best way to

00:25:49.606 --> 00:25:51.466
communicate a problem is with a

00:25:51.466 --> 00:25:53.126
right set of statistical data or

00:25:53.126 --> 00:25:55.136
with a well-crafted textual

00:25:55.136 --> 00:25:56.676
narrative of exactly what went

00:25:56.676 --> 00:25:56.976
wrong.

00:25:58.256 --> 00:26:00.196
The reason that graphing is so

00:26:00.196 --> 00:26:01.876
important though is that most of

00:26:01.876 --> 00:26:02.826
the time it's the user's

00:26:02.826 --> 00:26:03.436
starting point.

00:26:03.816 --> 00:26:04.886
It's the first page to your

00:26:04.886 --> 00:26:05.516
story's book.

00:26:06.636 --> 00:26:08.216
Visualization should help others

00:26:08.216 --> 00:26:10.266
learn, understand and debug, and

00:26:10.266 --> 00:26:11.906
the selfish motivation is that

00:26:11.976 --> 00:26:13.656
good tools also speed up triage.

00:26:14.306 --> 00:26:15.006
That's the goal of

00:26:15.006 --> 00:26:16.836
visualization, making problems

00:26:16.836 --> 00:26:17.266
apparent.

00:26:17.986 --> 00:26:19.206
Graphs are the first summary

00:26:19.206 --> 00:26:20.476
that you'll see and they should

00:26:20.476 --> 00:26:21.546
draw your eyes to areas of

00:26:21.546 --> 00:26:22.036
importance.

00:26:22.646 --> 00:26:23.896
And once you've started digging

00:26:23.896 --> 00:26:25.406
in, that's where detail views

00:26:25.406 --> 00:26:27.206
and metrics should be centered

00:26:27.206 --> 00:26:28.736
around those core concepts in

00:26:28.736 --> 00:26:29.806
your code.

00:26:29.986 --> 00:26:31.456
Now since Instruments deals with

00:26:31.926 --> 00:26:33.086
two types of time-ordered data,

00:26:33.316 --> 00:26:34.756
points and intervals, I want to

00:26:34.756 --> 00:26:35.976
talk through ways of displaying

00:26:35.976 --> 00:26:36.886
both.

00:26:37.856 --> 00:26:40.106
To summarize .events, it helps

00:26:40.106 --> 00:26:41.566
to evaluate their importance.

00:26:42.076 --> 00:26:43.766
If they're all relatively equal,

00:26:44.006 --> 00:26:45.596
then a histogram is a really

00:26:45.596 --> 00:26:46.926
great way to show the density of

00:26:46.926 --> 00:26:48.156
events on a timeline.

00:26:48.726 --> 00:26:50.346
The taller bars immediately

00:26:50.346 --> 00:26:51.556
convey at a quick glance where

00:26:51.556 --> 00:26:52.936
to start and where to zoom in.

00:26:53.416 --> 00:26:54.656
And for custom instruments, the

00:26:54.656 --> 00:26:55.706
graphing behavior is easy to

00:26:55.706 --> 00:26:56.276
customize.

00:26:57.076 --> 00:26:58.466
The histogram element allows you

00:26:58.466 --> 00:26:59.716
to specify the width of each

00:26:59.716 --> 00:27:01.626
time bucket and there's a best

00:27:01.626 --> 00:27:03.286
for resolution element that lets

00:27:03.286 --> 00:27:04.306
you use a histogram when the

00:27:04.306 --> 00:27:06.406
user zooms out and then swap for

00:27:06.406 --> 00:27:08.286
a plot of the individual events

00:27:08.426 --> 00:27:10.826
when the user zooms in.

00:27:12.036 --> 00:27:14.236
Now, when .events vary in

00:27:14.266 --> 00:27:15.956
importance, it's sometimes

00:27:15.956 --> 00:27:17.346
helpful to dedicate a lane to

00:27:17.346 --> 00:27:18.896
the critical events.

00:27:19.946 --> 00:27:21.546
Multiple graphs and detail views

00:27:21.656 --> 00:27:22.986
can reference data from the same

00:27:22.986 --> 00:27:24.916
table, so specifying the top

00:27:24.916 --> 00:27:26.696
plot just means describing to

00:27:26.696 --> 00:27:28.226
Instruments how to slice and

00:27:28.226 --> 00:27:29.756
choose which values to display

00:27:29.756 --> 00:27:30.306
from the table.

00:27:30.736 --> 00:27:32.306
Now both of these can be

00:27:32.306 --> 00:27:34.066
accomplished purely in XML and

00:27:34.066 --> 00:27:35.006
without a custom modeler.

00:27:37.216 --> 00:27:38.786
Tabular summaries of either

00:27:38.826 --> 00:27:40.406
point or interval data are your

00:27:40.406 --> 00:27:41.756
opportunity to define what

00:27:41.756 --> 00:27:42.596
metrics are important.

00:27:43.486 --> 00:27:45.116
Within aggregation detail view,

00:27:45.266 --> 00:27:46.656
there are functions like Min,

00:27:46.656 --> 00:27:48.026
Max, Average and Standard

00:27:48.026 --> 00:27:50.016
Deviation for combining values.

00:27:50.746 --> 00:27:52.256
And new users will look to these

00:27:52.296 --> 00:27:54.456
summaries that you provide for

00:27:54.456 --> 00:27:56.366
guidance on what's important and

00:27:56.366 --> 00:27:57.246
what to optimize.

00:27:57.936 --> 00:27:59.696
So even display attributes like

00:28:00.246 --> 00:28:01.456
what the title of the columns

00:28:01.456 --> 00:28:03.026
are or what order they appear in

00:28:03.336 --> 00:28:03.876
really matter.

00:28:04.536 --> 00:28:07.356
Now when users dig further into

00:28:07.356 --> 00:28:08.856
the details, the narrative

00:28:08.856 --> 00:28:10.586
engineering type is a great way

00:28:10.766 --> 00:28:11.896
to explain what's going on.

00:28:12.576 --> 00:28:14.156
It allows you to use natural

00:28:14.156 --> 00:28:15.196
language and other type

00:28:15.256 --> 00:28:17.616
formatters to explain runtime

00:28:17.616 --> 00:28:18.536
behavior in a way that's

00:28:18.536 --> 00:28:19.076
approachable.

00:28:19.706 --> 00:28:21.806
These views are a great way to

00:28:21.806 --> 00:28:23.626
tell users what was expected to

00:28:23.626 --> 00:28:25.936
happen and didn't, or when

00:28:25.936 --> 00:28:27.116
something interesting happened

00:28:27.116 --> 00:28:27.876
that they might want to

00:28:27.876 --> 00:28:28.676
investigate further.

00:28:30.046 --> 00:28:31.976
So plotting interval data can be

00:28:31.976 --> 00:28:32.536
a bit trickier.

00:28:33.736 --> 00:28:35.816
Unlike points, intervals won't

00:28:35.816 --> 00:28:36.816
usually fit within a single

00:28:36.816 --> 00:28:37.936
vertical space because of

00:28:37.936 --> 00:28:38.336
overlap.

00:28:38.766 --> 00:28:41.566
If you can plan for a fixed or

00:28:41.566 --> 00:28:42.776
bounded number of overlapping

00:28:42.776 --> 00:28:44.306
intervals, there are two ways to

00:28:44.306 --> 00:28:46.176
split a lane into multiple

00:28:46.176 --> 00:28:47.376
visual areas vertically.

00:28:48.286 --> 00:28:49.996
Qualified plots are useful for

00:28:49.996 --> 00:28:51.296
splitting lanes into multiple

00:28:51.296 --> 00:28:52.496
spaces with a single title,

00:28:53.236 --> 00:28:55.476
while instance plots are useful

00:28:55.476 --> 00:28:56.686
for each getting their own

00:28:56.686 --> 00:28:57.026
title.

00:28:57.026 --> 00:29:00.056
Now the OSSignpost tool uses

00:29:00.056 --> 00:29:00.916
both of these techniques

00:29:00.916 --> 00:29:02.436
together, but it only works well

00:29:02.436 --> 00:29:04.046
when there is a limited number

00:29:04.046 --> 00:29:05.106
of overlapping intervals to

00:29:05.106 --> 00:29:05.446
display.

00:29:06.416 --> 00:29:07.226
When there are a lot,

00:29:08.126 --> 00:29:09.986
hierarchies, new in Instruments

00:29:09.986 --> 00:29:11.446
11, may be the way to go.

00:29:12.456 --> 00:29:13.576
Separating trace data into

00:29:13.576 --> 00:29:15.776
nested tracks makes it easier to

00:29:15.866 --> 00:29:18.206
filter, to find and even pin

00:29:18.206 --> 00:29:19.146
just what you're looking for,

00:29:19.706 --> 00:29:20.776
especially when the number of

00:29:20.776 --> 00:29:22.236
graphing contexts is large.

00:29:23.176 --> 00:29:24.766
But whether or not you provide a

00:29:24.766 --> 00:29:25.786
hierarchy of tracks, it's

00:29:25.786 --> 00:29:26.906
important to plan for

00:29:26.906 --> 00:29:28.256
summarizing your interval data

00:29:28.846 --> 00:29:30.516
either at each level of your

00:29:30.516 --> 00:29:32.386
hierarchy or as the primary

00:29:32.386 --> 00:29:33.276
graph of your instrument.

00:29:33.736 --> 00:29:36.986
For simple interval data, it

00:29:36.986 --> 00:29:38.016
might be tempting to apply the

00:29:38.016 --> 00:29:39.636
same solution as for points,

00:29:40.086 --> 00:29:41.186
using a histogram element.

00:29:42.386 --> 00:29:43.706
However, this only works well if

00:29:43.706 --> 00:29:44.846
you have short intervals as the

00:29:44.846 --> 00:29:46.876
histogram element aggregates by

00:29:46.936 --> 00:29:48.106
start time.

00:29:48.336 --> 00:29:49.846
With longer intervals, this can

00:29:49.846 --> 00:29:52.276
cause a left-sided skew and it

00:29:52.276 --> 00:29:53.346
produces very large values.

00:29:54.836 --> 00:29:56.006
More importantly, when you graph

00:29:56.056 --> 00:29:59.046
things that have duration, don't

00:29:59.046 --> 00:30:01.006
graph time on the Y axis as it's

00:30:01.406 --> 00:30:02.546
already the X axis.

00:30:03.446 --> 00:30:05.206
Metrics like percent utilization

00:30:05.206 --> 00:30:06.246
are better for displaying this

00:30:06.296 --> 00:30:08.296
kind of data.

00:30:08.756 --> 00:30:10.606
Now in more real-world usage,

00:30:10.696 --> 00:30:11.866
intervals overlap a lot more,

00:30:12.386 --> 00:30:13.646
and so I want to show three

00:30:13.646 --> 00:30:16.136
examples of summary graphs and

00:30:16.136 --> 00:30:17.806
how the represented concept in

00:30:17.806 --> 00:30:18.826
your framework and usage

00:30:18.826 --> 00:30:20.686
patterns that you want can

00:30:20.686 --> 00:30:22.036
impact your table schemas and

00:30:22.066 --> 00:30:23.376
held determine the presentation

00:30:23.376 --> 00:30:23.676
style.

00:30:25.126 --> 00:30:26.586
So for some scenarios,

00:30:26.746 --> 00:30:28.566
persistent overlap indicates

00:30:28.686 --> 00:30:29.966
high resource utilization.

00:30:30.606 --> 00:30:31.816
And for this kind of data, a

00:30:31.816 --> 00:30:33.326
quantized load average is a good

00:30:33.326 --> 00:30:35.036
way to visualize it, even

00:30:35.036 --> 00:30:36.216
coloring some extreme values.

00:30:37.316 --> 00:30:39.026
Now Eclipse modelers and

00:30:39.026 --> 00:30:39.736
Instruments are great at

00:30:39.736 --> 00:30:40.836
maintaining state and fusing

00:30:40.836 --> 00:30:42.396
data, so combining that

00:30:42.396 --> 00:30:44.516
OSSignpost event stream with the

00:30:44.516 --> 00:30:46.306
input from an internal timer

00:30:46.306 --> 00:30:48.676
tag, a modeler can calculate and

00:30:48.676 --> 00:30:50.346
emit a quantized utilization

00:30:50.346 --> 00:30:51.666
average when a timer signal

00:30:51.666 --> 00:30:51.966
arrives.

00:30:52.486 --> 00:30:53.896
Now the output table of a

00:30:53.896 --> 00:30:55.956
modeler might look like this,

00:30:55.956 --> 00:30:57.166
expressing just four columns of

00:30:57.166 --> 00:30:58.926
data to draw the plot that you

00:30:58.926 --> 00:31:01.146
see, including a utilization

00:31:01.146 --> 00:31:02.706
column for determining the

00:31:02.706 --> 00:31:04.886
plot's value and a severity

00:31:04.886 --> 00:31:06.106
column for determining color.

00:31:06.656 --> 00:31:09.966
Now for other scenarios, lots of

00:31:10.006 --> 00:31:10.996
quickly running intervals might

00:31:11.026 --> 00:31:12.236
be more important because they

00:31:12.236 --> 00:31:13.786
represent inefficient use of

00:31:13.786 --> 00:31:14.286
your framework.

00:31:15.316 --> 00:31:16.796
Looking at the same data as the

00:31:16.796 --> 00:31:19.056
last example, a better graph

00:31:19.116 --> 00:31:20.486
might be based on the modeler

00:31:20.486 --> 00:31:21.956
counting the number of unique

00:31:21.956 --> 00:31:23.656
intervals seen within a specific

00:31:23.656 --> 00:31:24.236
time period.

00:31:24.986 --> 00:31:26.796
Now the modeler's output table

00:31:26.796 --> 00:31:27.806
would look very similar to the

00:31:27.806 --> 00:31:30.616
last, but the user's eye is

00:31:30.646 --> 00:31:32.156
immediately drawn to a very

00:31:32.266 --> 00:31:33.516
different area of the timeline

00:31:33.876 --> 00:31:34.906
which helps with zooming in and

00:31:34.906 --> 00:31:36.066
investigating the cause of these

00:31:36.066 --> 00:31:36.636
short intervals.

00:31:37.246 --> 00:31:39.506
And both of the first two

00:31:39.506 --> 00:31:41.576
examples summarize the data into

00:31:41.576 --> 00:31:42.796
10-millisecond groups.

00:31:43.006 --> 00:31:45.096
But what if the exact periods of

00:31:45.096 --> 00:31:46.216
the overlap are important,

00:31:46.456 --> 00:31:48.346
differentiating between one, two

00:31:48.346 --> 00:31:50.356
or more concurrent intervals?

00:31:51.396 --> 00:31:52.576
Well, instead of quantizing

00:31:52.926 --> 00:31:55.186
based on time, a more helpful

00:31:55.186 --> 00:31:58.166
graph might categorize these by

00:31:58.166 --> 00:31:59.726
degree of overlap and show the

00:31:59.726 --> 00:32:01.076
exact durations.

00:32:02.956 --> 00:32:05.136
A modeler tracking just the

00:32:05.136 --> 00:32:07.366
OSSignpost events could output

00:32:07.366 --> 00:32:08.316
an additional table with a

00:32:08.316 --> 00:32:09.226
custom interval schema.

00:32:10.436 --> 00:32:12.486
And this time, the schema would

00:32:12.486 --> 00:32:13.476
be filled in with a variable

00:32:13.476 --> 00:32:14.906
duration and a description

00:32:14.906 --> 00:32:16.016
column for use as a label.

00:32:17.236 --> 00:32:18.946
So all three of these are just

00:32:18.946 --> 00:32:20.926
examples but hopefully they help

00:32:20.926 --> 00:32:22.506
to show that when it comes to

00:32:22.506 --> 00:32:23.656
the presentation of your data,

00:32:24.176 --> 00:32:25.626
the concepts matter when you're

00:32:25.626 --> 00:32:26.626
designing a graphing schema.

00:32:26.626 --> 00:32:29.096
Now for many cases an

00:32:29.096 --> 00:32:30.546
automatically generated modeler

00:32:30.766 --> 00:32:31.606
will give you the power and

00:32:31.606 --> 00:32:33.116
flexibility you need to create

00:32:33.116 --> 00:32:33.986
the right experience.

00:32:34.706 --> 00:32:35.876
But there will definitely be

00:32:35.876 --> 00:32:37.326
times when you want to have more

00:32:37.326 --> 00:32:38.956
than one input or output.

00:32:39.506 --> 00:32:40.826
And for those cases in some of

00:32:40.826 --> 00:32:42.436
the example tables I've showed,

00:32:42.966 --> 00:32:44.816
custom modelers can provide that

00:32:44.816 --> 00:32:45.796
additional control and

00:32:45.796 --> 00:32:47.466
flexibility to express their

00:32:47.466 --> 00:32:50.006
concepts visually or textually,

00:32:50.006 --> 00:32:51.886
enrich narratives and graphs and

00:32:51.886 --> 00:32:52.206
details.

00:32:53.066 --> 00:32:54.526
So now I'm excited to hand it

00:32:54.526 --> 00:32:55.646
back to Kasper to see what

00:32:55.646 --> 00:32:56.756
visualizations he's come up

00:32:57.466 --> 00:32:57.886
with.

00:32:58.516 --> 00:33:02.376
[ Applause ]

00:33:02.876 --> 00:33:03.516
>> Thank you, Daniel.

00:33:04.216 --> 00:33:06.226
I played around with custom

00:33:06.226 --> 00:33:07.886
modelers and managed to improve

00:33:07.886 --> 00:33:09.476
on our existing instrumentation.

00:33:10.036 --> 00:33:10.656
Let's take a look.

00:33:11.126 --> 00:33:12.876
I will start with the Solar

00:33:12.876 --> 00:33:13.996
Conversion template that I

00:33:13.996 --> 00:33:14.336
crafted.

00:33:18.046 --> 00:33:19.836
It now includes a file system

00:33:19.836 --> 00:33:21.526
activity instrument to provide

00:33:21.526 --> 00:33:22.796
some additional information

00:33:23.026 --> 00:33:24.586
about I/O operations overhead

00:33:24.706 --> 00:33:26.106
when using compression library.

00:33:27.296 --> 00:33:27.886
Let's record.

00:33:30.046 --> 00:33:31.316
Now I'm recording in the

00:33:31.316 --> 00:33:33.426
windowed mode to reduce the

00:33:33.426 --> 00:33:34.836
overhead of the recording.

00:33:36.276 --> 00:33:38.606
Instrument is transferring all

00:33:38.606 --> 00:33:40.116
the data from the host and

00:33:40.116 --> 00:33:40.936
running the modelers.

00:33:46.056 --> 00:33:47.206
Let's examine the data now.

00:33:47.846 --> 00:33:50.096
I can immediately see that

00:33:50.096 --> 00:33:51.566
there's some correlation between

00:33:51.566 --> 00:33:53.436
file system activity and my

00:33:53.436 --> 00:33:54.896
execution signpost over here.

00:33:55.536 --> 00:33:57.636
Let's focus on the longer zip

00:33:57.636 --> 00:33:58.626
compression task that we

00:33:58.626 --> 00:33:59.376
analyzed before.

00:34:00.466 --> 00:34:01.826
It was good to have it colored

00:34:01.826 --> 00:34:03.266
on the red to get the user's

00:34:03.266 --> 00:34:03.756
attention.

00:34:04.056 --> 00:34:05.446
But even better it would be to

00:34:05.486 --> 00:34:06.736
provide some additional

00:34:06.736 --> 00:34:08.656
information by using narratives.

00:34:09.966 --> 00:34:11.726
I wrote modeler to detect low

00:34:11.726 --> 00:34:13.735
compression ratio situations and

00:34:13.735 --> 00:34:15.156
present some possible solutions.

00:34:15.826 --> 00:34:18.156
Let's take a look at the

00:34:18.156 --> 00:34:19.606
suggestions detail to take a

00:34:19.606 --> 00:34:20.806
look at the output of this

00:34:20.806 --> 00:34:21.505
modeler.

00:34:25.295 --> 00:34:27.246
This modeler -- and we get one

00:34:27.396 --> 00:34:27.966
suggestion.

00:34:28.366 --> 00:34:30.356
It's saying that file size for

00:34:30.656 --> 00:34:32.696
archive zip deceased by a bit

00:34:32.696 --> 00:34:33.766
over 1%.

00:34:34.386 --> 00:34:35.876
And compression may not be

00:34:35.876 --> 00:34:37.036
necessary for this file.

00:34:38.016 --> 00:34:39.716
It's also hinting that if speed

00:34:39.716 --> 00:34:41.335
is not an issue, I should try

00:34:41.335 --> 00:34:43.716
using LZMA algorithm which may

00:34:43.716 --> 00:34:45.025
provide higher compression

00:34:45.025 --> 00:34:45.466
ratio.

00:34:46.306 --> 00:34:47.186
That seems useful.

00:34:47.186 --> 00:34:49.005
I can now try to change the

00:34:49.005 --> 00:34:50.775
algorithm, record again and

00:34:50.775 --> 00:34:51.976
reevaluate the results.

00:34:54.076 --> 00:34:55.136
Let's take a look at how the

00:34:55.136 --> 00:34:56.376
waiting tasks are summarized.

00:34:57.005 --> 00:34:58.996
I'm calculating average load of

00:34:58.996 --> 00:34:59.886
the waiting tasks.

00:35:00.536 --> 00:35:03.376
This way users can clearly point

00:35:03.376 --> 00:35:04.776
out the areas of higher load.

00:35:05.926 --> 00:35:07.406
Let's take a look at this area

00:35:07.406 --> 00:35:08.786
which is colored in red.

00:35:10.216 --> 00:35:12.136
It seems that a lot of tasks are

00:35:12.136 --> 00:35:13.726
waiting on average, but as they

00:35:13.726 --> 00:35:15.236
get executed on the channels

00:35:15.236 --> 00:35:16.816
here, the number is going down.

00:35:17.976 --> 00:35:19.816
Users can analyze areas like

00:35:19.816 --> 00:35:21.906
that and if necessary increase

00:35:21.906 --> 00:35:22.886
the number of compression

00:35:22.886 --> 00:35:24.286
channels to achieve higher level

00:35:24.286 --> 00:35:25.076
of concurrency.

00:35:26.576 --> 00:35:28.256
Actually, this conclusion would

00:35:28.256 --> 00:35:29.736
be a good candidate for another

00:35:29.736 --> 00:35:31.106
suggestion in our detail.

00:35:31.106 --> 00:35:34.136
Now let's take a look at how it

00:35:34.136 --> 00:35:36.146
all plays out in Instrument

00:35:36.146 --> 00:35:36.656
Inspector.

00:35:37.776 --> 00:35:39.006
Let's search for our Solar

00:35:39.006 --> 00:35:42.096
Compression execution table and

00:35:42.186 --> 00:35:43.076
take a look at the binding

00:35:43.076 --> 00:35:43.596
solution.

00:35:46.076 --> 00:35:49.006
OSSignpost point schema data is

00:35:49.066 --> 00:35:51.656
transferred by OSSignpost

00:35:51.656 --> 00:35:53.616
auto-generated modeler into our

00:35:53.616 --> 00:35:55.006
Solar Compression execution

00:35:55.006 --> 00:35:55.416
table.

00:35:56.056 --> 00:35:57.686
It's right here as we saw before

00:35:57.686 --> 00:35:58.846
consumed by the UI.

00:35:59.546 --> 00:36:01.056
We also have this new entity

00:36:01.056 --> 00:36:02.176
over here which is our

00:36:02.176 --> 00:36:03.136
suggestions modeler.

00:36:03.596 --> 00:36:05.196
It's transferring intervals from

00:36:05.196 --> 00:36:07.206
the compression execution table

00:36:07.796 --> 00:36:10.336
into the suggestions in the

00:36:10.336 --> 00:36:11.946
point schema which is later

00:36:12.146 --> 00:36:15.516
driving the narrative detail.

00:36:15.676 --> 00:36:17.476
Now I'm happy about how this

00:36:17.476 --> 00:36:19.046
Instruments conveys the concepts

00:36:19.046 --> 00:36:20.856
of my library and I feel that we

00:36:20.856 --> 00:36:21.786
are ready to ship it to our

00:36:21.786 --> 00:36:22.246
users.

00:36:22.896 --> 00:36:23.886
Let's go back to the slides.

00:36:28.516 --> 00:36:32.776
[ Applause ]

00:36:33.276 --> 00:36:34.396
Creating great profiling

00:36:34.396 --> 00:36:36.186
experience is about giving your

00:36:36.186 --> 00:36:37.466
users a path to explore.

00:36:38.426 --> 00:36:39.956
They should start with a useful

00:36:39.956 --> 00:36:41.376
template which is set up to

00:36:41.376 --> 00:36:42.726
provide necessary instruments

00:36:42.726 --> 00:36:43.766
for looking at the issue.

00:36:44.646 --> 00:36:46.216
Remember that if your code is

00:36:46.216 --> 00:36:47.756
sensitive to information that is

00:36:47.756 --> 00:36:49.406
exposed by other instrumentation

00:36:49.756 --> 00:36:51.766
such as sampling, system tracing

00:36:51.966 --> 00:36:53.986
or priority activity, you should

00:36:53.986 --> 00:36:55.226
include this in your template.

00:36:56.326 --> 00:36:57.696
When analyzing the recording,

00:36:58.016 --> 00:36:59.436
top-level graphs should quickly

00:36:59.436 --> 00:37:01.316
draw user attention to where the

00:37:01.316 --> 00:37:02.556
problems might be in the

00:37:02.556 --> 00:37:03.416
execution timeline.

00:37:03.976 --> 00:37:05.916
And details should lead them to

00:37:05.916 --> 00:37:07.126
the main cause of the issue,

00:37:07.466 --> 00:37:08.636
often providing meaningful

00:37:08.636 --> 00:37:09.076
hints.

00:37:09.636 --> 00:37:12.016
To help you develop even better

00:37:12.016 --> 00:37:13.806
profiling experience, this year

00:37:13.806 --> 00:37:14.896
we've introduced two new

00:37:14.896 --> 00:37:16.396
features in Instruments, the

00:37:16.396 --> 00:37:17.686
first of which is the concept of

00:37:17.686 --> 00:37:18.746
hierarchical tracks.

00:37:19.666 --> 00:37:21.666
One example is OSSignpost

00:37:21.666 --> 00:37:23.316
instrument visible here which

00:37:23.316 --> 00:37:25.546
exposes underlying subsystem and

00:37:25.546 --> 00:37:27.126
category name space through the

00:37:27.196 --> 00:37:27.716
hierarchy.

00:37:29.176 --> 00:37:31.056
Hierarchies are part of custom

00:37:31.056 --> 00:37:32.616
instruments and any hierarchy

00:37:32.616 --> 00:37:34.026
that you saw today can be

00:37:34.026 --> 00:37:35.486
created by your own instrument.

00:37:37.296 --> 00:37:38.856
We also have a new way of

00:37:38.856 --> 00:37:40.056
customizing your profiling

00:37:40.056 --> 00:37:41.846
workflow through creating custom

00:37:41.846 --> 00:37:42.626
track scopes.

00:37:43.996 --> 00:37:45.176
These allow you to take a look

00:37:45.176 --> 00:37:46.536
at data gathered in your trace

00:37:46.536 --> 00:37:47.826
document from different

00:37:47.826 --> 00:37:49.596
perspectives by applying track

00:37:49.596 --> 00:37:51.476
filters or choosing different

00:37:51.476 --> 00:37:52.766
track branches for each scope.

00:37:54.176 --> 00:37:55.756
If I'm only interested in seeing

00:37:55.756 --> 00:37:57.496
system calls and signposts for

00:37:57.496 --> 00:37:59.336
compression library, or

00:37:59.336 --> 00:38:01.926
analyzing virtual memory impact

00:38:01.926 --> 00:38:03.836
of the application, I can create

00:38:03.836 --> 00:38:05.406
scopes that filter out other

00:38:05.406 --> 00:38:07.166
tracks and keep coming back to

00:38:07.166 --> 00:38:07.426
them.

00:38:08.816 --> 00:38:10.476
Like here I can save them in my

00:38:10.476 --> 00:38:12.296
template to share with my team

00:38:12.516 --> 00:38:14.246
or instrument audience.

00:38:15.616 --> 00:38:16.796
Tools in the form of

00:38:16.846 --> 00:38:18.376
instrumentation are a way to

00:38:18.376 --> 00:38:19.836
take experience of interacting

00:38:19.836 --> 00:38:21.556
with your framework from good to

00:38:21.556 --> 00:38:23.156
great and from unknown to

00:38:23.156 --> 00:38:23.726
trusted.

00:38:24.676 --> 00:38:26.036
They are your opportunity to

00:38:26.096 --> 00:38:27.466
tell stories about concepts

00:38:27.466 --> 00:38:28.576
existing in your framework.

00:38:29.766 --> 00:38:31.466
They should educate people and

00:38:31.466 --> 00:38:32.956
help catch easy mistakes.

00:38:34.056 --> 00:38:35.746
Whenever clients get performance

00:38:35.746 --> 00:38:37.566
debugging issues, they should

00:38:37.566 --> 00:38:39.076
turn to tools to see the answer.

00:38:39.426 --> 00:38:41.166
And this interaction will

00:38:41.166 --> 00:38:42.676
increase their confidence and

00:38:42.676 --> 00:38:43.646
trust in your library.

00:38:44.306 --> 00:38:46.636
To learn more about Custom

00:38:46.636 --> 00:38:48.016
Instruments, please visit

00:38:48.016 --> 00:38:49.206
Instruments Developer Help.

00:38:49.956 --> 00:38:51.106
We also recommend looking at

00:38:51.106 --> 00:38:52.056
these other sessions.

00:38:52.836 --> 00:38:54.086
Thank you and have a great rest

00:38:54.086 --> 00:38:54.706
of the conference.

00:38:55.516 --> 00:38:58.500
[ Applause ]
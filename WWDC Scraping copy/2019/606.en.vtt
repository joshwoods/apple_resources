WEBVTT

00:00:00.506 --> 00:00:04.500
[ Music ]

00:00:10.516 --> 00:00:15.086
[ Applause ]

00:00:15.586 --> 00:00:16.586
>> Good morning and welcome

00:00:16.586 --> 00:00:17.136
everyone.

00:00:17.326 --> 00:00:18.856
I am Guillem Vinals Gangolells

00:00:18.856 --> 00:00:20.356
from the Metal Ecosystem Team.

00:00:21.086 --> 00:00:22.486
This past year, we have been

00:00:22.486 --> 00:00:23.406
working with many game

00:00:23.406 --> 00:00:25.536
developers and identified some

00:00:25.536 --> 00:00:26.216
common issues.

00:00:26.896 --> 00:00:28.836
As a result, we decided to put

00:00:28.836 --> 00:00:29.746
this talk together.

00:00:30.446 --> 00:00:32.386
Today, I will be presenting a

00:00:32.436 --> 00:00:34.316
total of 18 best practices to

00:00:34.316 --> 00:00:36.246
help you improve your Metal app.

00:00:37.486 --> 00:00:39.246
Notice that I will not present

00:00:39.456 --> 00:00:42.736
OK practices or acceptable

00:00:42.736 --> 00:00:45.216
practices, and most definitely

00:00:45.566 --> 00:00:47.316
not practices that will just do

00:00:47.316 --> 00:00:47.786
the trick.

00:00:49.056 --> 00:00:51.336
The focus today will be on Metal

00:00:51.336 --> 00:00:52.196
Best Practices.

00:00:52.616 --> 00:00:55.786
So, please follow them.

00:00:55.996 --> 00:00:57.346
Before we get started, I would

00:00:57.346 --> 00:00:58.496
like to thank our friends at

00:00:58.496 --> 00:01:00.356
Digital Legends, our very

00:01:00.356 --> 00:01:01.776
talented team from Barcelona.

00:01:02.476 --> 00:01:03.936
They are the developers of

00:01:03.936 --> 00:01:04.626
Afterpulse.

00:01:05.146 --> 00:01:07.236
Afterpulse is an awesome great

00:01:07.236 --> 00:01:07.876
looking game.

00:01:08.406 --> 00:01:09.606
It uses many rendering

00:01:09.606 --> 00:01:11.266
techniques such as cascaded

00:01:11.266 --> 00:01:13.186
shadow maps, a fully-featured

00:01:13.186 --> 00:01:14.966
deferred render as well as

00:01:14.966 --> 00:01:16.566
post-process such as bloom and

00:01:16.566 --> 00:01:16.796
FXAA.

00:01:16.846 --> 00:01:19.356
We will use Afterpulse

00:01:19.356 --> 00:01:21.116
throughout this presentation to

00:01:21.116 --> 00:01:22.366
demo our tools and highlight

00:01:22.366 --> 00:01:23.606
some of our best practices.

00:01:25.206 --> 00:01:26.366
We have split the talk into

00:01:26.366 --> 00:01:28.116
three sections, general

00:01:28.116 --> 00:01:30.346
performance, memory bandwidth,

00:01:31.226 --> 00:01:32.216
and memory footprint.

00:01:33.056 --> 00:01:34.316
So, let's get started with some

00:01:34.316 --> 00:01:35.776
general performance advice.

00:01:40.076 --> 00:01:41.666
In this section, I will talk

00:01:41.666 --> 00:01:43.076
about choosing the right

00:01:43.076 --> 00:01:45.586
resolution, avoiding overdraw,

00:01:45.586 --> 00:01:46.876
reduce the amount of fragment

00:01:46.876 --> 00:01:48.396
shader invocations per pixel

00:01:48.396 --> 00:01:48.846
written.

00:01:49.876 --> 00:01:51.076
We'll also talk about GPU

00:01:51.076 --> 00:01:52.936
submissions, resource streaming,

00:01:53.206 --> 00:01:54.446
and also a bit about thermals.

00:01:55.956 --> 00:01:56.986
So, let's get started with the

00:01:57.086 --> 00:01:58.156
first best practice.

00:01:58.536 --> 00:01:59.876
Choose the right resolution.

00:02:01.006 --> 00:02:02.446
Notice that each effect in your

00:02:02.446 --> 00:02:04.036
game may require a different

00:02:04.036 --> 00:02:04.656
resolution.

00:02:05.266 --> 00:02:06.436
So, it is very important that

00:02:06.436 --> 00:02:07.836
you consider the image quality

00:02:07.836 --> 00:02:09.606
and performance trade-off of

00:02:09.606 --> 00:02:11.266
each resolution and choose them

00:02:11.296 --> 00:02:11.816
carefully.

00:02:12.626 --> 00:02:14.966
Also, composite the game UI at

00:02:14.996 --> 00:02:17.146
native resolution or close to

00:02:17.146 --> 00:02:18.966
native, so the UI will look

00:02:19.036 --> 00:02:20.526
crisp no matter the display

00:02:20.526 --> 00:02:20.916
size.

00:02:21.556 --> 00:02:23.986
We can check the resolutions

00:02:23.986 --> 00:02:25.226
with the Metal Frame Debugger.

00:02:26.676 --> 00:02:28.166
Within the metal frame debugger,

00:02:28.166 --> 00:02:29.086
we will want to use the

00:02:29.086 --> 00:02:31.066
Dependency Viewer, which will

00:02:31.066 --> 00:02:32.356
show a graph of every render

00:02:32.356 --> 00:02:32.816
pass.

00:02:33.486 --> 00:02:34.806
In this case, we are using a

00:02:34.806 --> 00:02:36.186
Metal example application.

00:02:37.216 --> 00:02:38.346
To access the Dependency Viewer,

00:02:38.346 --> 00:02:39.526
we will select the command

00:02:39.526 --> 00:02:39.916
buffer.

00:02:40.546 --> 00:02:43.626
And, in this case, you can see

00:02:43.626 --> 00:02:44.936
that this example Metal

00:02:44.936 --> 00:02:46.346
application is using several

00:02:46.346 --> 00:02:48.166
effects within different

00:02:48.166 --> 00:02:49.106
resolution each.

00:02:49.906 --> 00:02:51.836
For example, Shadow Maps and

00:02:51.976 --> 00:02:53.976
SSAO have a different resolution

00:02:53.976 --> 00:02:55.126
than the main lighting pass.

00:02:55.776 --> 00:02:57.536
Also, the UI is composed of

00:02:57.536 --> 00:02:58.676
native resolution, so it will

00:02:58.676 --> 00:02:59.336
always look sharp.

00:03:00.646 --> 00:03:02.696
These resolutions look great and

00:03:02.696 --> 00:03:04.056
perform well for this Metal

00:03:04.056 --> 00:03:04.716
application.

00:03:05.186 --> 00:03:06.306
We're asking for you to do a

00:03:06.306 --> 00:03:07.956
similar choice for your game.

00:03:08.926 --> 00:03:10.026
So, let's move on to best

00:03:10.026 --> 00:03:12.026
practice number 2.

00:03:12.436 --> 00:03:13.986
Minimize non-opaque overdraw.

00:03:15.086 --> 00:03:16.326
Overdraw is the amount of

00:03:16.416 --> 00:03:17.866
fragment shader's process for

00:03:17.866 --> 00:03:18.836
each pixel written.

00:03:19.706 --> 00:03:21.776
iOS GPUs are excellent at

00:03:21.776 --> 00:03:23.256
reducing opaque overdraw.

00:03:23.616 --> 00:03:25.006
We just need to help a bit.

00:03:25.606 --> 00:03:28.096
So, the best practice here is to

00:03:28.096 --> 00:03:30.326
render opaque meshes first and

00:03:30.326 --> 00:03:31.676
translucent meshes later.

00:03:32.296 --> 00:03:33.916
Also, do not render fully

00:03:33.916 --> 00:03:35.956
transparent or invisible meshes.

00:03:36.256 --> 00:03:38.326
We will, once again, use the

00:03:38.326 --> 00:03:40.006
Metal Frame Debugger to help us.

00:03:40.636 --> 00:03:42.176
This time, we will look at the

00:03:42.176 --> 00:03:44.656
GPU Counters gauge to verify the

00:03:44.656 --> 00:03:45.966
overdraw for a given render

00:03:45.966 --> 00:03:46.436
pass.

00:03:47.286 --> 00:03:48.486
We will want to focus on the

00:03:48.486 --> 00:03:49.946
main lighting pass of our Metal

00:03:49.946 --> 00:03:50.856
Demo application.

00:03:52.306 --> 00:03:54.126
In order to calculate overdraw,

00:03:54.506 --> 00:03:55.576
we will look at the number of

00:03:55.576 --> 00:03:57.036
fragment shader invocations

00:03:57.036 --> 00:03:58.416
divided by the amount of pixel

00:03:58.416 --> 00:03:58.756
store.

00:03:59.536 --> 00:04:00.786
We can use the filter bar at the

00:04:00.786 --> 00:04:02.066
bottom to quickly look for

00:04:02.066 --> 00:04:03.216
performance counters right

00:04:03.216 --> 00:04:03.596
after.

00:04:04.206 --> 00:04:06.866
In this case, it's a fully

00:04:06.866 --> 00:04:07.536
opaque scene.

00:04:07.536 --> 00:04:09.026
So, there's nothing else to

00:04:09.026 --> 00:04:09.516
verify.

00:04:09.516 --> 00:04:10.846
There's no overdraw and we are

00:04:10.846 --> 00:04:11.396
good to go.

00:04:11.946 --> 00:04:12.896
We're asking for you to do

00:04:12.896 --> 00:04:14.386
something similar with your game

00:04:14.756 --> 00:04:16.026
and verify that you're also good

00:04:16.026 --> 00:04:16.396
to go.

00:04:17.606 --> 00:04:19.156
So, let's move on to the next

00:04:20.206 --> 00:04:21.755
best practice.

00:04:21.846 --> 00:04:23.376
Submit GPU work early.

00:04:26.146 --> 00:04:27.556
Scheduling all the off-screen

00:04:27.556 --> 00:04:29.056
GPU work early is very

00:04:29.056 --> 00:04:29.706
important.

00:04:30.206 --> 00:04:31.576
It will improve the latency and

00:04:31.576 --> 00:04:33.076
responsiveness of your game and

00:04:33.266 --> 00:04:34.816
it will also allow the system to

00:04:34.816 --> 00:04:36.076
adapt to the workload much

00:04:36.126 --> 00:04:36.496
better.

00:04:37.456 --> 00:04:38.496
So, it is important that you

00:04:38.496 --> 00:04:40.396
have multiple GPU submissions in

00:04:40.396 --> 00:04:40.976
your frame.

00:04:41.516 --> 00:04:43.416
In particular, you will want an

00:04:43.456 --> 00:04:45.656
early GPU submission before

00:04:46.176 --> 00:04:47.626
waiting for the drawables since

00:04:47.626 --> 00:04:49.546
that stall the render thread.

00:04:50.376 --> 00:04:52.416
And after you get the drawable

00:04:52.416 --> 00:04:53.336
which will be as late as

00:04:53.366 --> 00:04:55.116
possible in the frame, you will

00:04:55.116 --> 00:04:57.626
then have a late GPU submission

00:04:58.106 --> 00:04:59.216
where you will schedule all the

00:04:59.216 --> 00:05:00.986
on-screen work, potentially, the

00:05:00.986 --> 00:05:02.306
UI Composition Pass.

00:05:03.476 --> 00:05:04.426
Since, it's a bit tricky to

00:05:04.426 --> 00:05:05.976
explain, we have demo prepared.

00:05:06.726 --> 00:05:08.186
So, let's do a quick demo and

00:05:08.186 --> 00:05:09.396
I'll show you how to identify

00:05:09.396 --> 00:05:10.746
this with Metal System Trace.

00:05:13.656 --> 00:05:16.316
Cool. What we see here is a

00:05:16.346 --> 00:05:18.366
capture of Afterpulse which we

00:05:18.366 --> 00:05:20.256
took last year with an older

00:05:20.256 --> 00:05:21.046
build of the game.

00:05:21.696 --> 00:05:23.096
This was taken with a game

00:05:23.096 --> 00:05:24.216
performance template.

00:05:24.446 --> 00:05:26.046
We introduced this template last

00:05:26.046 --> 00:05:26.296
year.

00:05:26.786 --> 00:05:28.036
So, you're already familiar with

00:05:28.036 --> 00:05:29.336
some of the instruments here.

00:05:29.336 --> 00:05:31.166
New this year, we have added the

00:05:31.166 --> 00:05:33.056
Thermal State as well as the

00:05:33.056 --> 00:05:34.506
Metal Resource Allocations.

00:05:34.676 --> 00:05:35.986
We'll talk about this later.

00:05:36.796 --> 00:05:38.166
For now, what we want to focus

00:05:38.166 --> 00:05:40.346
on, our potential stutters or

00:05:40.346 --> 00:05:40.816
issues.

00:05:41.396 --> 00:05:42.716
In this case, we want to look at

00:05:42.716 --> 00:05:44.196
the Display panel and see that

00:05:44.196 --> 00:05:46.086
there's lots of events at the

00:05:46.086 --> 00:05:48.006
bottom with-- where surfaces

00:05:48.006 --> 00:05:49.236
have been on-screen for longer

00:05:49.236 --> 00:05:49.986
than expected.

00:05:50.576 --> 00:05:51.766
So, maybe that's a problem and

00:05:51.766 --> 00:05:52.606
we should look at it.

00:05:53.276 --> 00:05:54.536
What we will do is zoom in to

00:05:54.536 --> 00:05:56.706
one of these regions holding the

00:05:56.706 --> 00:06:00.396
Option key and dragging the--

00:06:00.836 --> 00:06:02.036
our cursor over it.

00:06:02.126 --> 00:06:04.806
So, in this case, we can see

00:06:04.806 --> 00:06:07.456
that there's two frames that

00:06:07.456 --> 00:06:09.536
seem to be later than we would

00:06:09.536 --> 00:06:12.106
expect, at the same time, that

00:06:12.106 --> 00:06:14.176
the GPU is idle for a long time.

00:06:14.756 --> 00:06:16.046
So, that potentially is the

00:06:16.046 --> 00:06:17.656
cause of the issue we are trying

00:06:17.656 --> 00:06:18.306
to debug here.

00:06:18.306 --> 00:06:19.756
So, let's look into more detail.

00:06:20.576 --> 00:06:22.736
We'll do that by disclosing all

00:06:22.736 --> 00:06:24.406
the tracks in Metal System Trace

00:06:24.406 --> 00:06:25.836
which you're already familiar

00:06:25.836 --> 00:06:26.086
with.

00:06:26.976 --> 00:06:29.236
So, what we are seeing here are

00:06:30.046 --> 00:06:31.616
how our application is encoding

00:06:31.616 --> 00:06:33.716
work and also how our GPU is

00:06:33.716 --> 00:06:34.756
processing this work.

00:06:35.286 --> 00:06:36.636
So, let's focus on this orange

00:06:36.636 --> 00:06:37.036
frame.

00:06:37.746 --> 00:06:39.006
As you can see here, there's a

00:06:39.006 --> 00:06:41.176
lot of work being encoded by the

00:06:41.176 --> 00:06:42.466
apps, so we have the Shadow

00:06:42.466 --> 00:06:45.066
Maps, the Deferred Pass as well

00:06:45.066 --> 00:06:46.366
as part of the bloom chain, et

00:06:46.366 --> 00:06:46.726
cetera.

00:06:47.436 --> 00:06:50.116
So, the GPU is not actually

00:06:50.116 --> 00:06:51.836
processing that work, at the

00:06:51.836 --> 00:06:54.396
same time that the thread is

00:06:54.396 --> 00:06:55.696
waiting for the drawable.

00:06:56.206 --> 00:06:57.426
So that's what this causing this

00:06:57.426 --> 00:06:59.506
idle gap, but we already have

00:06:59.506 --> 00:07:00.586
some work encoded.

00:07:00.946 --> 00:07:02.336
We just didn't submit it.

00:07:03.136 --> 00:07:04.056
So, that's what the best

00:07:04.056 --> 00:07:05.926
practice was about you

00:07:05.926 --> 00:07:07.286
submitting all the off-screen

00:07:07.286 --> 00:07:09.356
work which you can encode ahead

00:07:09.356 --> 00:07:10.776
of time before waiting for the

00:07:10.776 --> 00:07:11.256
drawable.

00:07:11.866 --> 00:07:13.166
So, the solution would be to do

00:07:13.166 --> 00:07:14.686
one GPU submission here.

00:07:15.296 --> 00:07:16.866
Notice that there's only one GPU

00:07:16.866 --> 00:07:18.696
submission which we can see here

00:07:19.066 --> 00:07:20.256
towards the end of the frame.

00:07:20.346 --> 00:07:22.126
So, all the GPU work just

00:07:22.126 --> 00:07:23.046
happens at the end.

00:07:23.836 --> 00:07:25.616
Fortunately, this is very easy

00:07:25.656 --> 00:07:27.656
to simple-- very easy to fix.

00:07:27.686 --> 00:07:29.406
And, in fact, Digital Legends

00:07:29.406 --> 00:07:30.266
has already fixed it.

00:07:30.266 --> 00:07:31.476
So, let's look at the new trace

00:07:31.476 --> 00:07:33.186
of Afterpulse and see how it

00:07:33.186 --> 00:07:33.636
looks like.

00:07:34.876 --> 00:07:36.486
OK. So, let's zoom in.

00:07:37.546 --> 00:07:38.786
In this case, we can see that

00:07:38.786 --> 00:07:40.926
there's no idle time while we

00:07:40.926 --> 00:07:42.046
are waiting for the drawable.

00:07:42.846 --> 00:07:44.096
So, let's disclose the Metal

00:07:44.096 --> 00:07:45.506
System Trace tracks as we did

00:07:45.506 --> 00:07:45.966
before.

00:07:47.196 --> 00:07:48.456
And, in this case, we can see

00:07:48.456 --> 00:07:50.766
that the GPU is processing the

00:07:50.766 --> 00:07:52.196
work that we have already

00:07:52.196 --> 00:07:54.946
scheduled before getting the

00:07:54.946 --> 00:07:55.426
drawable.

00:07:56.266 --> 00:07:58.126
So, in this case, the idle time

00:07:58.126 --> 00:07:59.766
is much smaller.

00:07:59.766 --> 00:08:01.216
So, this allows the system to

00:08:01.216 --> 00:08:02.316
adapt to the workload much

00:08:02.316 --> 00:08:04.406
better and there's no problems.

00:08:04.926 --> 00:08:07.486
So, after this, we know we are

00:08:07.486 --> 00:08:09.466
good to go and we are-- we

00:08:09.466 --> 00:08:11.536
already have multiple GPU

00:08:11.536 --> 00:08:13.676
submissions which do not cause

00:08:13.676 --> 00:08:15.106
any stall because we do them

00:08:15.296 --> 00:08:16.476
before waiting for the drawable.

00:08:16.526 --> 00:08:17.796
So, let's go back to the slides.

00:08:19.736 --> 00:08:21.356
OK. So, the fix for that is

00:08:21.356 --> 00:08:22.876
actually quite simple much

00:08:22.876 --> 00:08:23.826
easier than explaining the

00:08:23.866 --> 00:08:25.166
problem in the first place.

00:08:25.926 --> 00:08:26.976
What we will want to do is

00:08:26.976 --> 00:08:28.616
simply create multiple command

00:08:28.616 --> 00:08:29.606
buffers per frame.

00:08:30.356 --> 00:08:31.686
So, we'll want to first create

00:08:31.686 --> 00:08:33.126
the command buffer to encode all

00:08:33.126 --> 00:08:34.856
the off-screen work which will

00:08:34.856 --> 00:08:37.176
be our early GPU submission.

00:08:37.356 --> 00:08:38.765
We will commit the command

00:08:38.765 --> 00:08:40.996
buffer and then wait for the

00:08:40.996 --> 00:08:42.926
next drawable, which will stall

00:08:42.926 --> 00:08:43.336
our thread.

00:08:43.336 --> 00:08:45.956
After we have the drawable, we

00:08:45.956 --> 00:08:48.586
will create one final command

00:08:48.586 --> 00:08:49.946
buffer where we will encode all

00:08:49.946 --> 00:08:52.026
the on-screen work and present

00:08:52.026 --> 00:08:52.606
the drawable.

00:08:53.446 --> 00:08:55.776
This will be our final CPU-- GPU

00:08:55.776 --> 00:08:56.446
submission.

00:08:57.256 --> 00:08:58.736
And this will also ensure that

00:08:58.736 --> 00:09:00.146
the frame pacing is actually

00:09:00.146 --> 00:09:01.096
good enough as well.

00:09:02.676 --> 00:09:04.126
It's as simple as that.

00:09:04.126 --> 00:09:05.286
Just use multiple command

00:09:05.286 --> 00:09:05.646
buffers.

00:09:06.496 --> 00:09:07.666
So, let's move on to the best

00:09:07.666 --> 00:09:09.716
practice number 4, stream

00:09:09.716 --> 00:09:10.836
resources efficiently.

00:09:11.746 --> 00:09:13.336
Allocating resources does take

00:09:13.386 --> 00:09:13.726
time.

00:09:14.476 --> 00:09:16.256
And streaming resources from the

00:09:16.256 --> 00:09:17.896
render thread may cause stalls.

00:09:18.346 --> 00:09:19.606
So, the best practice here is

00:09:19.606 --> 00:09:21.146
for you to consider the memory

00:09:21.146 --> 00:09:22.956
and performance trade-off of

00:09:22.956 --> 00:09:23.766
your resource streaming

00:09:23.766 --> 00:09:26.036
algorithm and make sure that you

00:09:26.116 --> 00:09:27.906
allocate and load GPU resources

00:09:27.906 --> 00:09:29.216
at launch time since you will

00:09:29.216 --> 00:09:30.426
not need to allocate them at

00:09:30.426 --> 00:09:31.006
runtime.

00:09:31.916 --> 00:09:33.316
And any resource that you need

00:09:33.316 --> 00:09:35.336
to stream at runtime, make sure

00:09:35.336 --> 00:09:36.826
you do so from a dedicated

00:09:36.886 --> 00:09:37.146
thread.

00:09:37.786 --> 00:09:39.266
It is very important that you do

00:09:39.266 --> 00:09:40.726
so in order to avoid stalls.

00:09:41.216 --> 00:09:43.266
We will revisit resource

00:09:43.266 --> 00:09:44.936
streaming later on in the memory

00:09:44.996 --> 00:09:47.216
footprint section and reevaluate

00:09:47.216 --> 00:09:48.326
the memory and performance

00:09:48.386 --> 00:09:48.936
trade-off.

00:09:49.656 --> 00:09:51.406
For now, let's just use Metal

00:09:51.406 --> 00:09:52.726
System Trace to tune our

00:09:52.726 --> 00:09:53.516
resource streaming.

00:09:54.516 --> 00:09:56.066
New this year, we're having an

00:09:56.066 --> 00:09:57.836
Allocations Track which will

00:09:57.836 --> 00:09:59.166
show you an event for each

00:09:59.166 --> 00:10:00.646
resource allocation and the

00:10:00.646 --> 00:10:02.866
allocation in the same timeline

00:10:02.866 --> 00:10:04.116
as all the other instruments.

00:10:05.046 --> 00:10:06.526
This will allow you to identify

00:10:06.526 --> 00:10:07.746
all those resources which you

00:10:07.746 --> 00:10:08.866
are streaming from the main

00:10:08.866 --> 00:10:10.476
render thread which could

00:10:10.476 --> 00:10:11.676
potentially cause a stall.

00:10:12.786 --> 00:10:14.806
Something else you should tune

00:10:14.806 --> 00:10:16.686
as well is for thermals.

00:10:17.366 --> 00:10:18.936
It is important that you design

00:10:18.936 --> 00:10:20.006
your game for sustained

00:10:20.006 --> 00:10:20.716
performance.

00:10:21.206 --> 00:10:22.466
This will improve the overall

00:10:22.566 --> 00:10:24.466
thermals of the system as well

00:10:24.466 --> 00:10:25.256
as the stability and

00:10:25.256 --> 00:10:26.666
responsiveness of your game.

00:10:27.526 --> 00:10:28.736
So, the best practice will be

00:10:28.816 --> 00:10:31.026
for you to test your game under

00:10:31.026 --> 00:10:32.166
serious thermal state.

00:10:32.906 --> 00:10:34.856
Also, consider tuning your game

00:10:35.216 --> 00:10:36.666
for this serious thermal state

00:10:36.666 --> 00:10:38.086
since that will hopefully help

00:10:38.086 --> 00:10:39.756
you to know the thermal

00:10:39.756 --> 00:10:40.186
throttle.

00:10:41.656 --> 00:10:44.256
So, new this year, we're adding

00:10:44.256 --> 00:10:46.036
Device Conditions into Xcode,

00:10:46.476 --> 00:10:47.816
which will allow you to set the

00:10:47.876 --> 00:10:50.166
serious thermal state directly

00:10:50.206 --> 00:10:51.396
from the device's window.

00:10:52.596 --> 00:10:54.106
There is a talk at the bottom

00:10:54.106 --> 00:10:55.066
where this topic we'll be

00:10:55.066 --> 00:10:56.436
covering to more detail and I

00:10:56.436 --> 00:10:57.506
encourage you to watch.

00:10:59.896 --> 00:11:01.626
Also, we can use the Xcode

00:11:01.626 --> 00:11:03.206
Energy Gauge to verify the

00:11:03.206 --> 00:11:04.736
thermal state that the device is

00:11:04.736 --> 00:11:05.166
running at.

00:11:05.976 --> 00:11:07.126
In this example, we are

00:11:07.126 --> 00:11:08.556
conditioning our device to run

00:11:08.556 --> 00:11:10.576
at serious thermal state and we

00:11:10.576 --> 00:11:11.966
are effectively verifying that

00:11:11.966 --> 00:11:13.406
the device get into serious

00:11:13.446 --> 00:11:14.056
thermal state.

00:11:14.416 --> 00:11:15.336
It just takes a couple of

00:11:15.336 --> 00:11:16.736
seconds to ramp-up to that.

00:11:17.906 --> 00:11:19.386
Cool. So, now let's move on to

00:11:19.386 --> 00:11:21.016
the second part of our talk.

00:11:21.816 --> 00:11:23.416
In this section, we'll talk

00:11:23.416 --> 00:11:25.266
about memory bandwidth.

00:11:27.016 --> 00:11:28.146
Memory bandwidth is very

00:11:28.146 --> 00:11:28.816
important.

00:11:29.236 --> 00:11:30.936
That is because memory transfers

00:11:30.936 --> 00:11:31.606
are costly.

00:11:32.156 --> 00:11:33.836
They consume power and generate

00:11:33.906 --> 00:11:34.166
heat.

00:11:35.206 --> 00:11:37.346
To help mitigate in that, iOS

00:11:37.346 --> 00:11:38.876
devices have shared system

00:11:38.876 --> 00:11:40.476
memory between the CPU and the

00:11:40.476 --> 00:11:43.056
GPU as well as dedicated Tile

00:11:43.056 --> 00:11:44.416
Memory for the GPU.

00:11:45.336 --> 00:11:46.926
Metal is designed to help you

00:11:46.926 --> 00:11:48.376
leverage both.

00:11:49.026 --> 00:11:50.786
So, now, let's see how by start

00:11:50.786 --> 00:11:52.416
looking into textures.

00:11:53.406 --> 00:11:55.166
Texture sampling is probably the

00:11:55.166 --> 00:11:57.026
main bandwidth consumer in your

00:11:57.026 --> 00:11:57.376
game.

00:11:57.956 --> 00:11:59.376
So, we have some best practices

00:11:59.376 --> 00:12:00.496
for you to configure your

00:12:00.496 --> 00:12:01.366
textures correctly.

00:12:02.416 --> 00:12:03.876
In this section, we will talk

00:12:03.876 --> 00:12:04.946
about offline texture

00:12:04.946 --> 00:12:07.466
compression for game assets, GPU

00:12:07.466 --> 00:12:09.486
texture compression as well as

00:12:09.486 --> 00:12:10.816
how to choose the correct pixel

00:12:10.816 --> 00:12:11.286
format.

00:12:11.946 --> 00:12:13.026
So, let's start with texture

00:12:13.026 --> 00:12:13.526
assets.

00:12:14.056 --> 00:12:16.756
It is very important for you to

00:12:16.756 --> 00:12:18.106
compress your texture assets.

00:12:18.846 --> 00:12:20.886
That is because sampling large

00:12:20.886 --> 00:12:23.066
textures may be inefficient and

00:12:23.066 --> 00:12:24.196
your assets may also be

00:12:24.196 --> 00:12:25.016
arbitrarily large.

00:12:25.716 --> 00:12:26.756
So make sure they are all

00:12:26.756 --> 00:12:29.446
compressed and also generate

00:12:29.446 --> 00:12:30.916
midmaps for all the textures

00:12:30.916 --> 00:12:31.996
which may be minified.

00:12:32.476 --> 00:12:34.346
So, let's see the memory savings

00:12:34.346 --> 00:12:35.396
of texture compression.

00:12:35.976 --> 00:12:38.306
This is one of the largest

00:12:38.336 --> 00:12:39.606
textures of Afterpulse.

00:12:40.486 --> 00:12:42.326
If this texture were to be

00:12:42.326 --> 00:12:44.226
uncompressed, it would take

00:12:44.226 --> 00:12:46.296
about 16 megabytes of memory to

00:12:46.296 --> 00:12:46.606
load.

00:12:47.846 --> 00:12:49.886
By using texture compression, we

00:12:49.886 --> 00:12:51.846
can lower let-- this to less

00:12:51.846 --> 00:12:54.036
than 3 megabytes including the

00:12:54.036 --> 00:12:55.106
full mipmap chain.

00:12:55.876 --> 00:12:57.446
Those are great memory savings.

00:12:58.546 --> 00:13:00.176
Notice though, that Afterpulse

00:13:00.176 --> 00:13:02.416
is using PVRTC because it runs

00:13:02.576 --> 00:13:05.496
on A7 devices such as the iPhone

00:13:05.496 --> 00:13:06.126
5S.

00:13:07.066 --> 00:13:08.496
If your game targets newer

00:13:08.496 --> 00:13:10.996
devices, using STC instead since

00:13:10.996 --> 00:13:12.496
it offers better compression

00:13:12.496 --> 00:13:13.726
ratio in image quality.

00:13:15.206 --> 00:13:16.596
To verify that our assets our

00:13:16.596 --> 00:13:18.736
compressed correctly, we can use

00:13:18.736 --> 00:13:19.596
the Memory Viewer.

00:13:21.026 --> 00:13:22.186
The Metal Memory Viewer is a

00:13:22.186 --> 00:13:23.636
great tool which I will fully

00:13:23.636 --> 00:13:24.636
introduce in the memory

00:13:24.636 --> 00:13:25.496
footprint section.

00:13:26.166 --> 00:13:28.446
For now, will you-- we will use

00:13:28.446 --> 00:13:30.086
it to inspect all of our assets.

00:13:30.566 --> 00:13:31.626
We can double check they are

00:13:31.626 --> 00:13:33.796
compressed, mipmapped, and also

00:13:33.796 --> 00:13:34.886
look great.

00:13:36.216 --> 00:13:38.246
But what happens with all those

00:13:38.246 --> 00:13:40.166
textures which you cannot

00:13:40.216 --> 00:13:42.676
compress ahead of time such as

00:13:42.676 --> 00:13:43.956
render targets or all the

00:13:43.956 --> 00:13:47.566
textures generated at runtime?

00:13:47.566 --> 00:13:49.316
The latest iOS GPU support

00:13:49.316 --> 00:13:50.626
lossless texture compression,

00:13:51.146 --> 00:13:52.706
which allows the GPU to compress

00:13:52.706 --> 00:13:54.126
textures for faster access.

00:13:55.486 --> 00:13:56.806
So, the next best practice is

00:13:57.076 --> 00:13:58.216
for you to optimize your

00:13:58.286 --> 00:13:59.906
textures so the GPU can have

00:13:59.906 --> 00:14:00.716
faster access.

00:14:01.646 --> 00:14:02.856
It is very important that you

00:14:02.856 --> 00:14:03.986
configure your textures

00:14:03.986 --> 00:14:04.466
correctly.

00:14:05.106 --> 00:14:06.406
You will want to use private

00:14:06.406 --> 00:14:08.486
storage mode, so only the GPU

00:14:08.486 --> 00:14:10.036
has access to the texture data

00:14:10.146 --> 00:14:11.986
and it allows it to optimize the

00:14:11.986 --> 00:14:12.506
contents.

00:14:12.966 --> 00:14:14.956
Also, do not set the unknown

00:14:14.956 --> 00:14:16.796
usage flag and avoid setting

00:14:16.796 --> 00:14:18.516
unnecessary usage flag such as

00:14:18.516 --> 00:14:21.056
shaderWrite or pixelView, since

00:14:21.056 --> 00:14:22.246
those may disable this

00:14:22.246 --> 00:14:22.836
compression.

00:14:23.716 --> 00:14:25.706
Shared textures which can be

00:14:25.706 --> 00:14:27.866
acces by the CPU and the GPU

00:14:28.246 --> 00:14:29.916
should explicitly be optimized

00:14:30.376 --> 00:14:32.166
after any CPU update on their

00:14:32.166 --> 00:14:32.556
data.

00:14:32.936 --> 00:14:34.226
It is also important for you to

00:14:34.226 --> 00:14:34.616
do so.

00:14:35.206 --> 00:14:36.516
So, let's see how can we do both

00:14:36.516 --> 00:14:37.446
things with a little bit of

00:14:37.536 --> 00:14:37.836
code.

00:14:38.146 --> 00:14:39.966
And it really is just a little

00:14:39.966 --> 00:14:40.476
bit of code.

00:14:41.036 --> 00:14:42.996
To create an optimal texture, we

00:14:42.996 --> 00:14:44.266
will want to set the storage

00:14:44.266 --> 00:14:45.076
mode as private.

00:14:45.276 --> 00:14:46.986
So, only the GPU has access to

00:14:48.126 --> 00:14:48.336
it.

00:14:48.336 --> 00:14:49.826
And also, we will want to set

00:14:50.296 --> 00:14:53.126
explicit yet conservative usage

00:14:53.126 --> 00:14:53.436
flags.

00:14:54.746 --> 00:14:56.156
In this case, we want to use the

00:14:56.156 --> 00:14:57.346
texture as an intermediate

00:14:57.346 --> 00:14:58.786
render targets so we do not need

00:14:58.786 --> 00:14:59.806
any other usage flag.

00:15:00.306 --> 00:15:03.106
But what about shared textures?

00:15:03.806 --> 00:15:05.076
Well, those are a bit trickier.

00:15:05.726 --> 00:15:07.016
So, shared textures can be

00:15:07.016 --> 00:15:08.836
accessed by both the CPU and the

00:15:08.836 --> 00:15:09.486
GPU.

00:15:10.386 --> 00:15:12.946
So, if the CPU updates a region

00:15:12.946 --> 00:15:14.236
of the texture or any of the

00:15:14.276 --> 00:15:16.906
texture data, we may need to

00:15:16.906 --> 00:15:18.806
explicitly ask the GPU to

00:15:18.806 --> 00:15:20.236
optimize its contents.

00:15:21.046 --> 00:15:22.406
Notice that there is a trade-off

00:15:22.406 --> 00:15:24.036
here between how many times does

00:15:24.036 --> 00:15:25.836
the CPU update the data and how

00:15:25.836 --> 00:15:27.336
many times does the GPU need to

00:15:27.336 --> 00:15:28.346
access it afterwards.

00:15:29.026 --> 00:15:32.096
So the Memory Viewer will

00:15:32.096 --> 00:15:33.556
actually be a great tool again

00:15:33.726 --> 00:15:34.796
to help us with this.

00:15:35.396 --> 00:15:37.086
That is because we can configure

00:15:37.086 --> 00:15:39.196
the Memory Viewer to show both

00:15:39.196 --> 00:15:40.756
the Storage Mode and Usage flag

00:15:40.826 --> 00:15:41.866
for all of our textures.

00:15:42.556 --> 00:15:44.096
From this single screen we can

00:15:44.096 --> 00:15:46.356
see our compressed textures and

00:15:46.356 --> 00:15:47.866
identify all of those which

00:15:47.946 --> 00:15:49.486
could be configured correctly.

00:15:50.426 --> 00:15:51.276
It is a great tool.

00:15:52.506 --> 00:15:54.596
At this point we are almost done

00:15:54.596 --> 00:15:55.796
configuring our textures.

00:15:56.516 --> 00:15:57.926
We just need to choose the right

00:15:57.926 --> 00:15:58.846
pixel format.

00:16:00.386 --> 00:16:02.006
Larger pixel format will use

00:16:02.006 --> 00:16:03.656
more bandwidth, so the best

00:16:03.656 --> 00:16:05.536
practice will be for you to

00:16:05.536 --> 00:16:07.096
avoid using pixel formats with

00:16:07.096 --> 00:16:09.346
unnecessary channels and also

00:16:09.346 --> 00:16:10.926
try to lower precision whenever

00:16:10.926 --> 00:16:11.436
possible.

00:16:12.706 --> 00:16:14.176
Notice though that the sampling

00:16:14.176 --> 00:16:16.166
rate itself will also depend on

00:16:16.166 --> 00:16:17.176
the pixel format.

00:16:18.176 --> 00:16:20.526
In this case, we can see how the

00:16:20.616 --> 00:16:22.586
pixel format has a direct impact

00:16:22.586 --> 00:16:24.166
on the texture sampling rate of

00:16:24.166 --> 00:16:24.936
our GPUs.

00:16:25.656 --> 00:16:27.566
Particularly, you will want to

00:16:27.566 --> 00:16:30.456
watch out for 128-bit formats

00:16:30.906 --> 00:16:33.576
such as RGBA 32-bit float, since

00:16:33.576 --> 00:16:34.876
those are sampled at quarter

00:16:34.876 --> 00:16:35.216
rate.

00:16:36.176 --> 00:16:37.856
Oftentimes these high precision

00:16:37.856 --> 00:16:39.236
formats are used for noise

00:16:39.236 --> 00:16:41.246
textures or lookup tables for

00:16:41.246 --> 00:16:43.086
the post-process effects.

00:16:44.406 --> 00:16:45.926
Once again we can use the Memory

00:16:45.926 --> 00:16:47.266
Viewer to help us with that.

00:16:48.116 --> 00:16:49.416
The Memory Viewer will let us

00:16:49.416 --> 00:16:51.276
filter textures by name or pixel

00:16:51.276 --> 00:16:51.726
format.

00:16:52.706 --> 00:16:54.046
So, we will verify that our

00:16:54.046 --> 00:16:56.486
Metal Demo is using 16-bit

00:16:56.586 --> 00:16:57.826
formats for the SSAO

00:16:57.826 --> 00:16:58.696
implementation.

00:16:59.536 --> 00:17:00.886
This is very important for the

00:17:00.886 --> 00:17:01.696
noise textures.

00:17:03.026 --> 00:17:04.296
Notice something else though,

00:17:04.346 --> 00:17:06.786
and this that in this example

00:17:07.226 --> 00:17:08.435
most of the textures are

00:17:08.435 --> 00:17:09.726
actually render targets.

00:17:10.746 --> 00:17:12.626
So as games become more complex,

00:17:12.626 --> 00:17:13.866
the texture used as render

00:17:13.945 --> 00:17:16.006
targets may actually consume a

00:17:16.006 --> 00:17:17.796
lot of bandwidth as well, so

00:17:17.796 --> 00:17:18.866
let's have a closer look.

00:17:19.356 --> 00:17:22.046
In this section, we will review

00:17:22.046 --> 00:17:23.195
render pass load and store

00:17:23.195 --> 00:17:25.276
actions, paying close attention

00:17:25.356 --> 00:17:27.695
to MSAA and also talk a bit

00:17:27.695 --> 00:17:28.596
about Tile Memory.

00:17:29.866 --> 00:17:31.006
So let's get started with

00:17:31.186 --> 00:17:32.446
optimizing load and store

00:17:32.446 --> 00:17:32.936
actions.

00:17:34.916 --> 00:17:36.336
You should avoid loading or

00:17:36.336 --> 00:17:37.546
storing render targets

00:17:37.546 --> 00:17:38.326
unnecessary.

00:17:39.356 --> 00:17:40.706
Render target load and store

00:17:40.706 --> 00:17:42.076
actions are very easy to

00:17:42.076 --> 00:17:44.026
overlook and may actually quite

00:17:44.026 --> 00:17:45.306
quickly become a problem.

00:17:45.996 --> 00:17:47.866
So please make sure to keep

00:17:47.866 --> 00:17:48.586
those in check.

00:17:49.516 --> 00:17:50.926
And it is actually quite easy to

00:17:50.926 --> 00:17:52.706
do so, with again just a little

00:17:52.706 --> 00:17:53.606
tiny bit of code.

00:17:54.496 --> 00:17:55.756
In this case, we are configuring

00:17:55.756 --> 00:17:57.806
a render pass descriptor and we

00:17:57.806 --> 00:17:59.296
want the color attachment 1 to

00:17:59.296 --> 00:18:00.656
be transient, which means we

00:18:00.656 --> 00:18:01.806
don't want to load or store

00:18:01.806 --> 00:18:02.536
anything from it.

00:18:03.426 --> 00:18:05.556
It is a simple as setting the

00:18:05.596 --> 00:18:07.146
correct load and store actions.

00:18:07.706 --> 00:18:09.336
We want the load action to be

00:18:09.336 --> 00:18:11.136
clear, so no later gets transfer

00:18:12.036 --> 00:18:13.166
to the on chip GPU.

00:18:13.646 --> 00:18:16.296
And we want to store action to

00:18:16.296 --> 00:18:17.106
be, DontCare.

00:18:17.686 --> 00:18:19.536
So no data needs to be written

00:18:19.536 --> 00:18:20.716
at the end of the render pass.

00:18:21.536 --> 00:18:22.726
That's all there is to it,

00:18:23.396 --> 00:18:24.676
verifying that we have done the

00:18:24.676 --> 00:18:26.456
right thing is also very simple,

00:18:27.246 --> 00:18:28.476
we can use the Dependency

00:18:28.476 --> 00:18:28.846
Viewer.

00:18:29.416 --> 00:18:32.726
In this case, our Metal example

00:18:32.806 --> 00:18:34.336
is storing the color attachment

00:18:34.336 --> 00:18:35.876
1, even though it's not used

00:18:35.876 --> 00:18:36.436
later on.

00:18:37.246 --> 00:18:38.716
The Dependency Viewer will show

00:18:38.716 --> 00:18:40.286
an issue icon to highlight this

00:18:40.326 --> 00:18:40.786
problem.

00:18:41.746 --> 00:18:42.996
We should simply set the

00:18:42.996 --> 00:18:44.786
DontCare store action as we have

00:18:44.786 --> 00:18:46.216
just seen in the previous slide

00:18:46.216 --> 00:18:48.026
and the problem will go away.

00:18:48.556 --> 00:18:51.476
It is really as simple as that.

00:18:51.996 --> 00:18:54.016
This is particularly important

00:18:54.626 --> 00:18:56.006
for multi-sampled render

00:18:56.076 --> 00:18:56.546
targets.

00:18:57.076 --> 00:19:00.446
iOS devices have very fast MSAA,

00:19:01.116 --> 00:19:02.466
that is because the result

00:19:02.756 --> 00:19:04.396
happens from Tile Memory, so it

00:19:04.396 --> 00:19:05.946
does not consume any extra

00:19:05.946 --> 00:19:06.356
bandwidth.

00:19:07.306 --> 00:19:09.046
This also allows us to declare

00:19:09.176 --> 00:19:10.726
the multisampled textures fully

00:19:10.726 --> 00:19:11.316
transient.

00:19:11.836 --> 00:19:13.216
In fact, we don't even need a

00:19:13.216 --> 00:19:14.816
system memory allocation to back

00:19:14.816 --> 00:19:15.796
it in the first place.

00:19:15.956 --> 00:19:17.816
So the best practice will be for

00:19:17.816 --> 00:19:19.766
you to consider MSAA over native

00:19:19.766 --> 00:19:21.186
resolution, since it's very

00:19:21.186 --> 00:19:23.486
efficient, and also make sure to

00:19:23.486 --> 00:19:24.646
not load or store the

00:19:24.646 --> 00:19:25.876
multisample texture.

00:19:26.686 --> 00:19:27.876
And since you're at it set the

00:19:27.876 --> 00:19:29.476
storage mode of the multisample

00:19:29.476 --> 00:19:30.766
texture to memoryless.

00:19:31.766 --> 00:19:32.746
I will fully introduce

00:19:32.746 --> 00:19:34.246
memoryless later on the talk.

00:19:34.246 --> 00:19:35.726
For now, let's see how can we

00:19:35.726 --> 00:19:37.396
configure a multisample texture

00:19:37.396 --> 00:19:38.666
and the render pass that uses

00:19:38.666 --> 00:19:38.896
it.

00:19:39.376 --> 00:19:42.066
In this case, we just need to

00:19:42.066 --> 00:19:43.616
set the memoryless storage mode,

00:19:44.516 --> 00:19:46.006
and also make sure that the

00:19:46.006 --> 00:19:48.286
render pass is using it, clears

00:19:48.286 --> 00:19:49.976
its contents and discards the

00:19:49.976 --> 00:19:50.576
samples.

00:19:51.286 --> 00:19:53.076
We only want the multisample

00:19:53.076 --> 00:19:54.676
texture to resolve from.

00:19:55.086 --> 00:19:56.426
We do not need to store it.

00:19:56.556 --> 00:19:57.936
We do not want that intermediate

00:19:57.936 --> 00:19:58.806
data to be stored.

00:19:59.476 --> 00:20:01.446
Only the final resolve texture

00:20:01.446 --> 00:20:02.116
should be stored.

00:20:03.316 --> 00:20:04.586
We can once more use the

00:20:04.586 --> 00:20:06.436
Dependency Viewer to help us

00:20:06.436 --> 00:20:08.396
verify that we are doing the

00:20:08.726 --> 00:20:10.046
right thing.

00:20:10.166 --> 00:20:12.026
In this case, our Metal example

00:20:12.026 --> 00:20:13.216
is loading and starting the

00:20:13.216 --> 00:20:15.436
multisample texture which is

00:20:15.436 --> 00:20:16.326
very costly.

00:20:17.526 --> 00:20:18.946
After setting the correct flag

00:20:19.056 --> 00:20:21.006
just as I've shown you, we will

00:20:21.006 --> 00:20:24.896
save our 85 memory, sorry, 85

00:20:24.966 --> 00:20:27.246
megabytes of memory bandwidth

00:20:27.246 --> 00:20:28.426
and also footprint.

00:20:29.536 --> 00:20:30.806
And this is very important for

00:20:30.806 --> 00:20:32.306
you to verify the multisample

00:20:32.306 --> 00:20:32.986
attachments.

00:20:33.836 --> 00:20:36.486
But notice that those savings

00:20:36.596 --> 00:20:39.156
are only possible because we are

00:20:39.156 --> 00:20:41.056
implicitly leveraging Tile

00:20:42.226 --> 00:20:44.386
Memory by using MSAA.

00:20:45.286 --> 00:20:46.776
So the next best practice is for

00:20:46.776 --> 00:20:48.636
you to explicitly leverage Tile

00:20:48.636 --> 00:20:49.036
Memory.

00:20:50.186 --> 00:20:51.696
Metal provides access to Tile

00:20:51.696 --> 00:20:53.736
Memory for several features such

00:20:53.736 --> 00:20:55.616
as programmable blending, image

00:20:55.616 --> 00:20:57.166
block, and tile shaders.

00:20:57.996 --> 00:21:00.256
The best practice is for you to

00:21:00.256 --> 00:21:01.646
explicitly utilize it,

00:21:02.146 --> 00:21:04.416
particularly to implement more

00:21:04.416 --> 00:21:05.886
advanced rendering techniques.

00:21:06.886 --> 00:21:08.926
The Modern Rendering with Metal

00:21:08.926 --> 00:21:10.536
talk will cover-- has covered

00:21:10.536 --> 00:21:11.586
some of these techniques in

00:21:11.586 --> 00:21:11.926
detail.

00:21:13.046 --> 00:21:14.366
For now we will just have a

00:21:14.416 --> 00:21:15.826
quick look at deferred shading.

00:21:17.436 --> 00:21:19.676
Deferred shading is considered

00:21:19.676 --> 00:21:22.206
to be very bandwidth heavy that

00:21:22.206 --> 00:21:24.166
is because traditionally it

00:21:24.166 --> 00:21:25.626
requires the application to

00:21:25.626 --> 00:21:27.196
store the geometry information

00:21:27.466 --> 00:21:29.846
or G-Buffer as a set of textures

00:21:29.846 --> 00:21:31.426
representing several pixel

00:21:31.486 --> 00:21:32.056
properties.

00:21:32.966 --> 00:21:34.796
Those textures are then sampled

00:21:34.796 --> 00:21:36.066
in the second lighting pass,

00:21:36.576 --> 00:21:37.826
where the final color is

00:21:37.826 --> 00:21:39.396
accumulated in a render target.

00:21:40.316 --> 00:21:42.686
Notice that we are storing and

00:21:42.686 --> 00:21:44.776
then loading all this data from

00:21:44.776 --> 00:21:46.186
the G-Buffer, so that's why it's

00:21:46.226 --> 00:21:47.016
bandwidth heavy.

00:21:47.356 --> 00:21:50.136
iOS allows you to be much more

00:21:50.136 --> 00:21:52.646
efficient than that.

00:21:53.576 --> 00:21:54.956
On iOS, we can leverage

00:21:54.986 --> 00:21:56.876
programmable blending, a feature

00:21:56.876 --> 00:21:58.606
that allows fragment shaders to

00:21:58.606 --> 00:22:01.076
access pixel data directly from

00:22:01.076 --> 00:22:01.746
Tile Memory.

00:22:02.646 --> 00:22:04.096
This means that the G-buffer

00:22:04.096 --> 00:22:05.756
data can be stored on Tile

00:22:05.756 --> 00:22:07.766
Memory and access within the

00:22:07.766 --> 00:22:10.026
same render pass by all the

00:22:10.026 --> 00:22:11.456
light accumulation shaders.

00:22:12.196 --> 00:22:13.896
It is a very powerful feature

00:22:15.116 --> 00:22:16.526
which Digital Legends has been

00:22:16.526 --> 00:22:17.936
utilizing for years.

00:22:18.776 --> 00:22:20.246
This is how the single pass

00:22:20.246 --> 00:22:21.946
deferred render of Afterpulse

00:22:22.306 --> 00:22:23.256
looks like through the

00:22:23.256 --> 00:22:24.726
Dependency Viewer, it's

00:22:24.726 --> 00:22:25.276
beautiful.

00:22:25.926 --> 00:22:27.296
The four G-Buffer attachments

00:22:27.296 --> 00:22:29.266
are fully transient, and only

00:22:29.266 --> 00:22:31.056
the final color and depth are

00:22:31.056 --> 00:22:32.146
stored, so it's not only

00:22:32.146 --> 00:22:33.806
beautiful it's also efficient.

00:22:34.686 --> 00:22:36.006
So, now, please let's welcome

00:22:36.006 --> 00:22:37.856
Samuel on stage for the demo of

00:22:37.856 --> 00:22:38.756
the Dependency Viewer.

00:22:39.516 --> 00:22:43.500
[ Applause ]

00:22:48.636 --> 00:22:49.516
>> Thanks Guillem.

00:22:50.076 --> 00:22:51.616
So, we've just captured an old

00:22:51.616 --> 00:22:53.206
version of Afterpulse and want

00:22:53.206 --> 00:22:54.106
to see if there are any

00:22:54.106 --> 00:22:55.746
optimizations that we can make

00:22:56.006 --> 00:22:57.146
to improve its performance.

00:22:58.556 --> 00:22:59.866
I'm now going to use the

00:22:59.866 --> 00:23:01.586
Dependency Viewer in the Metal

00:23:01.586 --> 00:23:03.166
Frame Debugger to show some of

00:23:03.166 --> 00:23:04.536
the issues that Guillem just

00:23:04.536 --> 00:23:04.916
mentioned.

00:23:05.676 --> 00:23:08.846
So to begin, let's click on the

00:23:08.846 --> 00:23:10.556
CommandBuffer to open the

00:23:10.556 --> 00:23:12.206
Dependency Viewer.

00:23:12.856 --> 00:23:16.576
The Dependency Viewer shows us

00:23:16.576 --> 00:23:18.856
all of the GPU passes encoded by

00:23:19.686 --> 00:23:20.646
an app.

00:23:20.926 --> 00:23:22.656
We can see that Afterpulse has

00:23:22.656 --> 00:23:24.816
one CommandBuffer and begins its

00:23:24.816 --> 00:23:26.606
frame by rendering a Shadow Map.

00:23:27.356 --> 00:23:30.606
Followed by Deferred Phase, this

00:23:30.606 --> 00:23:31.596
feeds into Luminance

00:23:31.596 --> 00:23:33.286
Calculations, Particle

00:23:33.286 --> 00:23:35.286
Simulations, and a Bloom Chain

00:23:35.886 --> 00:23:37.196
which is used by the final

00:23:37.196 --> 00:23:38.646
screen pass.

00:23:39.516 --> 00:23:40.666
Now, the Dependency Viewer is

00:23:40.666 --> 00:23:42.276
much more compact this year if

00:23:42.276 --> 00:23:44.046
you have groups, and it's really

00:23:44.046 --> 00:23:46.096
easy to see at a high level, how

00:23:46.096 --> 00:23:46.966
the frame is rendered.

00:23:48.026 --> 00:23:49.806
We can even go deeper into any

00:23:49.806 --> 00:23:51.656
group if we want more detail.

00:23:52.416 --> 00:23:54.396
So, in reality this Bloom Chain

00:23:54.956 --> 00:23:56.496
is actually 12 passes.

00:23:57.066 --> 00:24:00.016
Now, the Dependency Viewer is a

00:24:00.016 --> 00:24:01.516
great place to find some of the

00:24:01.516 --> 00:24:02.656
issues that Guillem mentioned.

00:24:03.166 --> 00:24:04.606
And we can see a few on this

00:24:04.606 --> 00:24:05.296
final screen pass.

00:24:05.296 --> 00:24:08.026
So let's click on the issue icon

00:24:08.306 --> 00:24:09.106
to find out more.

00:24:09.746 --> 00:24:12.656
So, it looks like one of the

00:24:12.656 --> 00:24:14.466
load store action issues that

00:24:14.466 --> 00:24:15.446
Guillem mentioned earlier.

00:24:16.496 --> 00:24:17.856
So they've set the store action

00:24:17.856 --> 00:24:19.866
to store, but they're not using

00:24:19.866 --> 00:24:20.936
this texture again in this

00:24:20.936 --> 00:24:21.196
frame.

00:24:22.066 --> 00:24:23.626
So the issue recommends we

00:24:23.626 --> 00:24:24.946
should instead set it to

00:24:24.946 --> 00:24:27.056
DontCare and we'll get back

00:24:27.056 --> 00:24:28.886
almost 14 megabytes of memory

00:24:28.886 --> 00:24:30.806
bandwidth for these two textures

00:24:30.806 --> 00:24:31.286
combined.

00:24:31.906 --> 00:24:34.676
So this year we've made it even

00:24:34.676 --> 00:24:36.336
easier to find all of the issues

00:24:36.376 --> 00:24:38.436
in the graph, simply click on

00:24:38.436 --> 00:24:39.966
the new issues button on the

00:24:39.966 --> 00:24:42.786
bottom right to see a list of

00:24:46.156 --> 00:24:46.316
issues.

00:24:46.466 --> 00:24:47.726
Now, another best practice that

00:24:47.726 --> 00:24:48.956
Guillem mentioned was choosing

00:24:48.956 --> 00:24:51.016
the correct pixel format.

00:24:51.556 --> 00:24:52.936
So this year on iOS we've

00:24:52.936 --> 00:24:54.756
introduced the new Depth 16

00:24:54.756 --> 00:24:56.806
Format, so let's use the new

00:24:56.806 --> 00:24:58.996
search to look for Depth 32

00:24:58.996 --> 00:25:00.246
textures.

00:25:03.266 --> 00:25:04.666
So it looks like they're using

00:25:04.736 --> 00:25:06.636
36 megabytes of memory for the

00:25:06.636 --> 00:25:07.596
Shadow Map texture.

00:25:08.506 --> 00:25:09.536
So when the team at Digital

00:25:09.536 --> 00:25:11.356
Legends gets back to Barcelona

00:25:11.356 --> 00:25:12.836
after Dub-Dub, they can

00:25:12.836 --> 00:25:14.316
investigate using this new

00:25:14.316 --> 00:25:16.646
format and potentially save half

00:25:16.686 --> 00:25:18.126
the memory if their shadow

00:25:18.126 --> 00:25:20.196
requirements allow for it.

00:25:20.746 --> 00:25:22.166
If we continue searching through

00:25:22.166 --> 00:25:24.046
the graph, where you can see

00:25:24.046 --> 00:25:25.596
that there's plenty of potential

00:25:25.596 --> 00:25:26.396
memory savings.

00:25:27.066 --> 00:25:29.436
So if you use the Dependency

00:25:29.436 --> 00:25:30.576
Viewer in the Metal Frame

00:25:30.576 --> 00:25:32.566
Debugger to find and diagnose a

00:25:32.616 --> 00:25:34.736
few issues in the old version of

00:25:34.736 --> 00:25:35.276
Afterpulse.

00:25:36.116 --> 00:25:37.146
So, Digital Legends have

00:25:37.146 --> 00:25:38.326
actually made some of these

00:25:38.326 --> 00:25:39.026
improvements.

00:25:39.386 --> 00:25:40.386
So let's take a quick look.

00:25:40.976 --> 00:25:43.906
We can immediately see that they

00:25:43.906 --> 00:25:45.226
are now using multiple command

00:25:45.226 --> 00:25:45.686
buffers.

00:25:46.376 --> 00:25:47.746
So this will fix the issue that

00:25:47.746 --> 00:25:49.196
Guillem showed us earlier where

00:25:49.196 --> 00:25:51.056
the CPU was blocked waiting for

00:25:51.056 --> 00:25:52.776
the next drawable and the GPU

00:25:52.776 --> 00:25:53.276
was idle.

00:25:53.866 --> 00:25:56.006
If we zoom in to the final

00:25:56.006 --> 00:25:58.586
screen pass, we can see that

00:25:58.586 --> 00:25:59.936
they've fixed the store action

00:25:59.936 --> 00:26:00.276
issue.

00:26:01.386 --> 00:26:02.886
In fact, because these two

00:26:02.886 --> 00:26:04.906
textures are fully transient and

00:26:04.906 --> 00:26:06.136
they've set the storage mode to

00:26:06.136 --> 00:26:08.116
memoryless, they're not using

00:26:08.116 --> 00:26:09.616
any system memory at all.

00:26:11.016 --> 00:26:13.326
So, Dependency really is a great

00:26:13.366 --> 00:26:14.916
place to start debugging your

00:26:14.916 --> 00:26:15.636
render pipeline.

00:26:16.526 --> 00:26:17.856
Back to Guillem who will talk

00:26:17.856 --> 00:26:18.926
about some amazing best

00:26:18.926 --> 00:26:20.936
practices in optimizing your

00:26:20.936 --> 00:26:21.926
apps memory footprint.

00:26:22.516 --> 00:26:29.056
[ Applause ]

00:26:29.556 --> 00:26:30.986
>> Thank you Sam that was an

00:26:30.986 --> 00:26:31.756
awesome demo.

00:26:31.886 --> 00:26:33.156
I hope you guys will also use

00:26:33.156 --> 00:26:34.116
the Dependency Viewer.

00:26:35.296 --> 00:26:36.556
Cool. So, let's move on to the

00:26:36.556 --> 00:26:38.906
last part of the talk, memory

00:26:38.906 --> 00:26:39.476
footprint.

00:26:40.786 --> 00:26:42.216
Memory footprint is actually

00:26:42.216 --> 00:26:43.676
very important for your game.

00:26:44.616 --> 00:26:46.696
That is because iOS enforces a

00:26:46.696 --> 00:26:48.436
strict application memory limit

00:26:48.896 --> 00:26:50.506
in order to keep both the system

00:26:50.506 --> 00:26:52.066
on your application responsive.

00:26:52.756 --> 00:26:56.016
As some of you may have noticed

00:26:56.016 --> 00:26:58.326
iOS 12 introduce some changes in

00:26:58.326 --> 00:26:59.706
the way memory is accounted.

00:27:00.816 --> 00:27:02.606
This accounting change affects

00:27:02.606 --> 00:27:03.946
mostly Metal resources.

00:27:04.976 --> 00:27:06.736
Metal resources such as buffers

00:27:06.736 --> 00:27:08.836
or textures may be the bulk of

00:27:08.876 --> 00:27:09.976
your application's memory

00:27:09.976 --> 00:27:10.496
footprint.

00:27:10.946 --> 00:27:12.346
So, it is important for you to

00:27:12.346 --> 00:27:13.636
measure the memory footprint of

00:27:13.636 --> 00:27:14.166
your game.

00:27:14.916 --> 00:27:16.356
You will want to do, so using

00:27:16.356 --> 00:27:17.656
the Xcode Memory Gauge.

00:27:18.746 --> 00:27:20.486
The Xcode Memory Gauge will

00:27:20.516 --> 00:27:22.576
report the existing number that

00:27:22.576 --> 00:27:24.266
the system also uses to measure

00:27:24.266 --> 00:27:25.626
your game's memory footprint.

00:27:26.396 --> 00:27:28.036
It is very important that you

00:27:28.036 --> 00:27:29.536
use it to verify where your

00:27:29.536 --> 00:27:30.176
games at.

00:27:31.126 --> 00:27:32.956
Now, new this year it will also

00:27:32.956 --> 00:27:34.496
display the application memory

00:27:34.496 --> 00:27:36.656
limit as your game gets closer

00:27:36.736 --> 00:27:37.626
to it.

00:27:38.896 --> 00:27:40.566
But what if we want to focus

00:27:40.566 --> 00:27:43.206
specifically on the memory used

00:27:43.206 --> 00:27:44.546
by our Metal resources?

00:27:45.156 --> 00:27:47.696
New this year, we are

00:27:47.696 --> 00:27:49.266
introducing the Memory Viewer.

00:27:50.496 --> 00:27:52.366
We have added it into the Metal

00:27:52.366 --> 00:27:53.106
Frame Debugger.

00:27:54.346 --> 00:27:56.006
The Memory Viewer itself has two

00:27:56.006 --> 00:27:58.776
parts, first, a bar chart at the

00:27:58.836 --> 00:28:01.006
top which shows resources, group

00:28:01.006 --> 00:28:03.146
by categories such as type,

00:28:03.596 --> 00:28:05.606
storage mode, and usage.

00:28:06.256 --> 00:28:08.136
We can also use this bar chart

00:28:08.756 --> 00:28:09.966
to quickly navigate through the

00:28:09.966 --> 00:28:11.656
largest resources which are then

00:28:11.656 --> 00:28:13.006
highlighted and the time they

00:28:13.006 --> 00:28:13.606
were shown.

00:28:14.706 --> 00:28:16.346
Second, there is a table at the

00:28:16.346 --> 00:28:18.116
bottom which will show the

00:28:18.176 --> 00:28:19.726
resources that we have filtered.

00:28:19.726 --> 00:28:22.596
It includes several properties

00:28:22.646 --> 00:28:24.786
specific to resource type such

00:28:24.786 --> 00:28:26.506
as pixel format and resolution

00:28:26.506 --> 00:28:27.216
for textures.

00:28:28.046 --> 00:28:29.686
There is also filter bar at the

00:28:29.686 --> 00:28:31.606
bottom to help you narrow down

00:28:31.606 --> 00:28:33.156
your investigation even further.

00:28:33.886 --> 00:28:36.056
It is a very powerful tool and

00:28:36.056 --> 00:28:37.606
we hope that you will utilize it

00:28:37.666 --> 00:28:38.916
to understand the memory

00:28:38.916 --> 00:28:40.716
footprint of all your GPU

00:28:40.716 --> 00:28:41.326
resources.

00:28:43.056 --> 00:28:45.476
Also another great tool that we

00:28:45.476 --> 00:28:47.456
are introducing this year is the

00:28:47.456 --> 00:28:49.016
Metal Resource Allocation

00:28:49.046 --> 00:28:49.736
Instrument.

00:28:51.086 --> 00:28:52.076
It has three different

00:28:52.076 --> 00:28:54.726
components, a Metal Resources

00:28:54.726 --> 00:28:56.226
Allocations track which will

00:28:56.226 --> 00:28:57.836
show the current Metal memory

00:28:57.906 --> 00:29:00.226
footprint of your game, an

00:29:00.226 --> 00:29:02.056
allocations track which will

00:29:02.056 --> 00:29:03.546
show an event for each resource

00:29:03.546 --> 00:29:05.606
allocation and deallocation as

00:29:05.606 --> 00:29:06.856
well as some information.

00:29:08.106 --> 00:29:10.266
And also a detailed table view

00:29:10.536 --> 00:29:11.446
which will show you more

00:29:11.446 --> 00:29:12.816
information about all the

00:29:12.816 --> 00:29:14.136
allocations captured.

00:29:15.146 --> 00:29:16.416
Both these tools are very

00:29:16.416 --> 00:29:18.506
powerful and will give you great

00:29:18.506 --> 00:29:20.596
overview of the memory footprint

00:29:20.596 --> 00:29:22.006
in your game and how-- well,

00:29:22.006 --> 00:29:23.716
also how it changes over time.

00:29:24.226 --> 00:29:26.446
But some of you have also been

00:29:26.446 --> 00:29:28.476
asking for other features, in

00:29:28.476 --> 00:29:29.726
particular, one of them you have

00:29:29.756 --> 00:29:31.146
been asking for a long time.

00:29:31.726 --> 00:29:33.006
And I'm very happy to tell you

00:29:33.006 --> 00:29:34.466
that new this year, we have a

00:29:34.466 --> 00:29:36.636
C-based API to query available

00:29:36.636 --> 00:29:37.696
memory at runtime.

00:29:38.566 --> 00:29:40.206
This will enable your game to

00:29:40.206 --> 00:29:41.266
stream resources more

00:29:41.266 --> 00:29:43.776
effectively and also avoid

00:29:43.776 --> 00:29:46.156
memory spikes which may cause

00:29:46.156 --> 00:29:47.626
the game to go over the

00:29:47.626 --> 00:29:48.566
application limit.

00:29:49.456 --> 00:29:51.296
Another cool API that we're

00:29:51.296 --> 00:29:53.206
introducing this year is the

00:29:53.286 --> 00:29:55.436
on-device GPU capture, which

00:29:55.436 --> 00:29:56.116
will allow you to

00:29:56.186 --> 00:29:57.816
programmatically trigger a GPU

00:29:57.816 --> 00:30:00.326
capture for which Xcode is not

00:30:00.326 --> 00:30:00.856
required.

00:30:01.446 --> 00:30:02.936
So we think it will be ideal for

00:30:02.936 --> 00:30:04.776
game testers in the QA process.

00:30:05.456 --> 00:30:07.286
To enable it you will just need

00:30:07.336 --> 00:30:09.136
to add MetalCaptureEnabled into

00:30:09.136 --> 00:30:10.026
the info.plist.

00:30:10.026 --> 00:30:10.856
It's very simple.

00:30:12.086 --> 00:30:13.206
So, now, let's see how we can

00:30:13.206 --> 00:30:15.876
combine both APIs into some

00:30:15.876 --> 00:30:17.466
short piece of code.

00:30:18.766 --> 00:30:20.596
In this case, we will want to

00:30:20.626 --> 00:30:22.196
check if the application is

00:30:22.196 --> 00:30:23.856
close to the memory limit, maybe

00:30:23.856 --> 00:30:25.946
because of a memory spike and

00:30:25.946 --> 00:30:27.656
capture a GPU trace of our game,

00:30:27.656 --> 00:30:29.136
so we can use the Memory Viewer

00:30:29.196 --> 00:30:30.086
to fully debug it.

00:30:30.756 --> 00:30:31.686
So let's go for it.

00:30:32.116 --> 00:30:33.876
First, we'll check if the

00:30:33.876 --> 00:30:35.166
application is getting close to

00:30:35.166 --> 00:30:35.696
the limit.

00:30:36.436 --> 00:30:38.806
And if it is we will then want

00:30:39.126 --> 00:30:41.276
to capture the next frame, which

00:30:41.276 --> 00:30:43.036
we will just render normally as

00:30:43.036 --> 00:30:44.286
we would do so otherwise.

00:30:45.716 --> 00:30:47.516
By the end of the frame, if we

00:30:47.516 --> 00:30:49.636
captured it, we will then stop

00:30:49.636 --> 00:30:51.486
the capture and handle the GPU

00:30:51.486 --> 00:30:53.506
trace, it's up to you how you

00:30:53.506 --> 00:30:54.806
handle the GPU trace.

00:30:55.516 --> 00:30:57.416
Potentially you may also want to

00:30:57.416 --> 00:30:59.836
either exit the game or disable

00:30:59.836 --> 00:31:01.346
the GPU captures for this

00:31:01.346 --> 00:31:02.716
session, since you may not want

00:31:02.716 --> 00:31:04.506
to capture every single frame at

00:31:04.506 --> 00:31:05.026
that point.

00:31:06.246 --> 00:31:08.016
So this will give you a great

00:31:08.016 --> 00:31:10.536
way to use both APIs and to, you

00:31:10.536 --> 00:31:12.076
know, like further drill down on

00:31:12.076 --> 00:31:12.856
memory footprint.

00:31:13.296 --> 00:31:15.556
Which is great, so let's do

00:31:15.556 --> 00:31:16.346
exactly that.

00:31:16.346 --> 00:31:17.776
Let's look into how can we

00:31:17.776 --> 00:31:19.286
reduce memory footprint.

00:31:19.866 --> 00:31:21.656
For that we also have a bunch of

00:31:21.656 --> 00:31:22.526
best practices.

00:31:23.516 --> 00:31:25.026
In this section, we will talk

00:31:25.026 --> 00:31:26.886
about memoryless render targets,

00:31:27.256 --> 00:31:29.486
resource streaming, a bit more

00:31:29.486 --> 00:31:31.216
about game assets and also

00:31:31.306 --> 00:31:32.656
memory-intensive effects.

00:31:33.396 --> 00:31:34.986
So, let's get started with

00:31:34.986 --> 00:31:36.406
memoryless render targets.

00:31:36.786 --> 00:31:39.206
This is kind of where we left it

00:31:39.206 --> 00:31:40.716
in the memory bandwidth section.

00:31:42.096 --> 00:31:43.466
Notice the transient render

00:31:43.466 --> 00:31:45.386
targets are not loaded or stored

00:31:45.386 --> 00:31:46.316
on system memory.

00:31:47.076 --> 00:31:49.056
So they actually do not need a

00:31:49.056 --> 00:31:50.476
system memory allocation in the

00:31:50.476 --> 00:31:52.286
first place, that's why you

00:31:52.286 --> 00:31:53.816
should use memoryless storage

00:31:53.816 --> 00:31:55.996
mode, in particular, for all the

00:31:55.996 --> 00:31:57.456
multisampled attachments.

00:31:58.316 --> 00:31:59.646
So let's see how can we do that

00:31:59.646 --> 00:32:01.716
with, again, just a little bit

00:32:02.116 --> 00:32:02.956
of code.

00:32:03.146 --> 00:32:04.806
In this case, is as simple as

00:32:04.806 --> 00:32:06.126
setting memoryless into the

00:32:06.126 --> 00:32:07.096
texture descriptor.

00:32:07.906 --> 00:32:09.726
Also we will want to make sure

00:32:09.906 --> 00:32:11.836
that our render pass configures

00:32:11.836 --> 00:32:13.066
that render target as fully

00:32:13.066 --> 00:32:13.626
transient.

00:32:14.106 --> 00:32:15.586
In this case, we want to

00:32:15.586 --> 00:32:16.856
configure the G-Buffers

00:32:16.856 --> 00:32:17.406
transients.

00:32:17.406 --> 00:32:18.776
So, we just need to set the load

00:32:18.776 --> 00:32:20.646
action clear and the store

00:32:20.646 --> 00:32:21.606
action to DontCare.

00:32:22.096 --> 00:32:23.326
So we are not storing the

00:32:23.326 --> 00:32:23.856
G-buffer.

00:32:24.426 --> 00:32:27.156
So we can see how Digital

00:32:27.156 --> 00:32:28.686
Legends did it by having another

00:32:28.686 --> 00:32:29.676
look at Afterpulse.

00:32:30.516 --> 00:32:32.406
At the top we can see an older

00:32:32.406 --> 00:32:35.006
version of Afterpulse, it has a

00:32:35.006 --> 00:32:37.096
transient G-buffer but it's

00:32:37.096 --> 00:32:38.816
being backed by system memory.

00:32:39.426 --> 00:32:41.766
At the bottom, we can see a

00:32:41.766 --> 00:32:43.396
newer version of Afterpulse

00:32:43.796 --> 00:32:45.076
which actually has a larger

00:32:45.076 --> 00:32:45.626
G-buffer.

00:32:46.446 --> 00:32:48.616
But this G-buffer though is

00:32:48.616 --> 00:32:51.336
fully transient and this time

00:32:51.706 --> 00:32:53.306
not backed by system memory,

00:32:53.766 --> 00:32:55.296
they are utilizing memoryless

00:32:55.296 --> 00:32:56.936
storage mode for all the

00:32:56.936 --> 00:32:57.996
intermediate G-buffer

00:32:57.996 --> 00:32:58.636
attachments.

00:32:58.966 --> 00:33:00.576
And this is great because the

00:33:00.576 --> 00:33:02.896
newer version of Afterpulse is

00:33:02.896 --> 00:33:04.876
saving about 60 megabytes of

00:33:04.906 --> 00:33:07.256
memory footprint just by setting

00:33:07.256 --> 00:33:09.336
that one flag, it's awesome.

00:33:10.096 --> 00:33:12.066
And it comes with no compromise,

00:33:12.656 --> 00:33:13.906
there is nothing being lost

00:33:13.906 --> 00:33:15.066
here, there's no trade-off to be

00:33:15.066 --> 00:33:16.676
made, it just works.

00:33:17.126 --> 00:33:17.676
And it's great.

00:33:18.496 --> 00:33:19.976
So, now, let's move on to the

00:33:19.976 --> 00:33:22.386
rest of the best practices,

00:33:22.616 --> 00:33:24.126
which some of those we will do

00:33:24.126 --> 00:33:26.576
come with a, you know, memory

00:33:26.576 --> 00:33:27.956
and performance trade-off or

00:33:27.956 --> 00:33:29.086
memory and image quality

00:33:29.086 --> 00:33:29.596
trade-off.

00:33:30.366 --> 00:33:31.916
In this case, we are back to

00:33:31.916 --> 00:33:32.696
resource streaming.

00:33:34.076 --> 00:33:35.306
Notice that loading all the

00:33:35.306 --> 00:33:37.246
assets into memory will increase

00:33:37.246 --> 00:33:38.806
the memory footprint, so you

00:33:38.806 --> 00:33:40.216
should consider the memory and

00:33:40.216 --> 00:33:42.596
performance trade-off and only

00:33:42.596 --> 00:33:43.856
load all the assets that you

00:33:43.856 --> 00:33:45.666
know will be used, particularly

00:33:45.666 --> 00:33:46.996
when you are memory limited.

00:33:48.036 --> 00:33:50.006
Also you may want to free all

00:33:50.006 --> 00:33:51.856
the resources as long-- as soon

00:33:51.856 --> 00:33:53.406
as they are not used anymore,

00:33:53.736 --> 00:33:55.356
potentially like splash screen

00:33:55.356 --> 00:33:56.796
or tutorial UI would be great

00:33:56.796 --> 00:33:57.826
candidates for that.

00:33:58.806 --> 00:34:00.916
And this is a hard decision to

00:34:00.916 --> 00:34:03.056
make but fortunately the Memory

00:34:03.056 --> 00:34:04.406
Viewer is also a great tool to

00:34:04.406 --> 00:34:05.326
help us with that.

00:34:06.926 --> 00:34:08.755
We can use the filters to

00:34:08.755 --> 00:34:10.166
quickly focus on unused

00:34:10.216 --> 00:34:10.846
resources.

00:34:11.996 --> 00:34:14.016
By doing so, the table at the

00:34:14.016 --> 00:34:15.716
bottom will be updated and then

00:34:15.846 --> 00:34:17.085
we can focus on all these

00:34:17.085 --> 00:34:18.636
resources which are not used in

00:34:18.636 --> 00:34:19.146
this frame.

00:34:19.315 --> 00:34:21.616
And we will talk more about this

00:34:21.616 --> 00:34:22.866
and use them off the Memory

00:34:22.866 --> 00:34:24.235
Viewer towards the end of the

00:34:24.266 --> 00:34:24.576
talk.

00:34:25.656 --> 00:34:26.976
So, now, let's move on to best

00:34:26.976 --> 00:34:28.275
practice number 14.

00:34:29.106 --> 00:34:30.505
Use smaller assets.

00:34:31.186 --> 00:34:33.246
In fact, you should only make

00:34:33.246 --> 00:34:35.426
the assets as large as necessary

00:34:36.286 --> 00:34:37.726
and consider again the image

00:34:37.775 --> 00:34:39.396
quality and memory trade-off of

00:34:39.396 --> 00:34:40.335
your asset sizes.

00:34:40.866 --> 00:34:42.335
Make sure that both textures and

00:34:42.335 --> 00:34:43.406
meshes are compressed.

00:34:44.196 --> 00:34:45.376
And potentially if you are

00:34:45.376 --> 00:34:47.666
getting memory limited you may

00:34:47.666 --> 00:34:49.886
want to only load the smaller

00:34:49.886 --> 00:34:51.525
mipmap levels of your textures,

00:34:52.306 --> 00:34:53.926
or the lower LODs for your

00:34:53.926 --> 00:34:54.386
meshes.

00:34:55.005 --> 00:34:57.456
But there is a trade-off here

00:34:57.456 --> 00:34:58.426
that we are making, between

00:34:58.426 --> 00:35:00.016
image quality and memory.

00:35:00.136 --> 00:35:02.246
It's up to you to decide, when

00:35:02.246 --> 00:35:03.746
do you want to take it?

00:35:04.496 --> 00:35:07.026
The next best practice number 15

00:35:07.106 --> 00:35:08.206
is very similar.

00:35:08.666 --> 00:35:10.806
We will want to simplify

00:35:10.996 --> 00:35:12.506
memory-intensive effects.

00:35:12.996 --> 00:35:16.066
Some effects may require large

00:35:16.066 --> 00:35:17.746
off-screen buffers, such as

00:35:17.746 --> 00:35:19.416
Shadow Maps and SSAO.

00:35:19.726 --> 00:35:21.956
So the best practice will be for

00:35:21.956 --> 00:35:23.146
you to consider the image

00:35:23.146 --> 00:35:24.736
quality and memory trade-off of

00:35:24.736 --> 00:35:25.936
all of those effects.

00:35:27.086 --> 00:35:28.726
Potentially lower the resolution

00:35:28.726 --> 00:35:29.946
of all these large off-screen

00:35:29.946 --> 00:35:30.436
buffers.

00:35:31.316 --> 00:35:32.526
And if you are very memory

00:35:32.526 --> 00:35:34.606
constrained then just disable

00:35:34.606 --> 00:35:36.026
all those effects all together.

00:35:37.506 --> 00:35:38.696
That is a trade-off to be made

00:35:38.776 --> 00:35:39.906
here and you need to be

00:35:39.906 --> 00:35:41.006
conscious about it.

00:35:41.256 --> 00:35:42.486
But sometimes there's no other

00:35:42.486 --> 00:35:42.946
choice.

00:35:44.536 --> 00:35:46.476
The next best practices that we

00:35:46.476 --> 00:35:48.256
are going to cover here are

00:35:48.256 --> 00:35:49.336
slightly different.

00:35:50.146 --> 00:35:52.896
In this last section, I will

00:35:52.896 --> 00:35:54.456
introduce a couple of more

00:35:54.456 --> 00:35:56.106
advanced concepts that will help

00:35:56.106 --> 00:35:58.036
us further reducing the memory

00:35:58.076 --> 00:35:58.586
footprint.

00:35:59.526 --> 00:36:00.946
We will talk about metal

00:36:00.986 --> 00:36:04.556
resource heaps, purgeable memory

00:36:04.806 --> 00:36:06.066
as well as pipeline state

00:36:06.066 --> 00:36:06.576
objects.

00:36:07.476 --> 00:36:09.286
So, let's get started with metal

00:36:09.286 --> 00:36:10.066
resource heaps.

00:36:11.256 --> 00:36:12.746
metal resource heaps will allow

00:36:12.746 --> 00:36:13.946
your application to take

00:36:13.946 --> 00:36:16.346
explicit control over the large

00:36:16.376 --> 00:36:18.496
memory allocation that happens

00:36:18.496 --> 00:36:19.056
up front.

00:36:20.016 --> 00:36:21.516
In this case, we will go from

00:36:21.516 --> 00:36:23.526
three separate textures which

00:36:23.526 --> 00:36:25.686
have their own allocation into a

00:36:25.806 --> 00:36:28.086
single metal resource heap which

00:36:28.086 --> 00:36:29.596
is a single allocation that will

00:36:29.596 --> 00:36:30.886
hold these three textures

00:36:30.886 --> 00:36:31.526
separately.

00:36:32.536 --> 00:36:34.406
This will also allow the system

00:36:34.406 --> 00:36:35.966
to pack those textures together,

00:36:36.066 --> 00:36:37.346
so we're already saving some

00:36:37.346 --> 00:36:37.806
memory.

00:36:38.346 --> 00:36:41.986
But the great memory savings

00:36:41.986 --> 00:36:45.096
will come from using aliasing.

00:36:46.136 --> 00:36:47.566
So, notice that rendering a

00:36:47.566 --> 00:36:49.276
frame may require a lot of

00:36:49.276 --> 00:36:51.176
intermediate memory, in

00:36:51.176 --> 00:36:52.886
particular, as your game scales

00:36:52.886 --> 00:36:54.236
in the post-process pipeline.

00:36:55.066 --> 00:36:56.486
So it is very important for you

00:36:56.486 --> 00:36:58.076
to use metal resource heaps for

00:36:58.076 --> 00:37:00.316
those effects and alias as much

00:37:00.316 --> 00:37:01.646
of that memory as possible.

00:37:02.346 --> 00:37:03.596
For example, you may want to

00:37:03.596 --> 00:37:05.396
reutilize the memory for all

00:37:05.396 --> 00:37:06.776
those resources which have no

00:37:06.776 --> 00:37:09.406
dependencies, potentially like

00:37:09.406 --> 00:37:11.076
those you would find in SSAO and

00:37:11.076 --> 00:37:11.756
Depth of Field.

00:37:12.296 --> 00:37:15.106
So, now, let's look how would

00:37:15.106 --> 00:37:15.866
that look like.

00:37:16.566 --> 00:37:18.346
In this case, we have the same

00:37:18.346 --> 00:37:19.946
metal resource heap as before.

00:37:21.116 --> 00:37:23.136
But if the three textures are

00:37:23.136 --> 00:37:24.986
not used at the same time we can

00:37:24.986 --> 00:37:26.256
potentially alias them.

00:37:26.796 --> 00:37:28.156
And by doing so, we will save a

00:37:28.156 --> 00:37:29.076
lot of memory.

00:37:30.146 --> 00:37:31.886
And this will really help your

00:37:31.886 --> 00:37:33.956
game scale with a much more

00:37:33.956 --> 00:37:35.786
complex post-process pipeline

00:37:36.346 --> 00:37:37.946
without having to pay a huge

00:37:37.946 --> 00:37:39.646
memory price for all those

00:37:39.646 --> 00:37:41.136
intermediate render targets and

00:37:41.136 --> 00:37:42.276
all the intermediate memory.

00:37:43.266 --> 00:37:44.576
So it is great, it's a great

00:37:44.576 --> 00:37:45.886
feature that you should consider

00:37:45.886 --> 00:37:46.506
leveraging.

00:37:47.076 --> 00:37:49.426
Now, let's talk about another

00:37:49.426 --> 00:37:50.706
advanced concept that of

00:37:50.856 --> 00:37:51.816
purgeable memory.

00:37:53.306 --> 00:37:54.826
Purgeable memory has three

00:37:54.826 --> 00:37:58.186
states, non-volatile, volatile,

00:37:58.626 --> 00:37:59.336
and empty.

00:38:00.576 --> 00:38:02.516
Notice that volatile and empty

00:38:02.516 --> 00:38:05.156
allocations do not count towards

00:38:05.156 --> 00:38:06.246
the application memory

00:38:06.326 --> 00:38:06.826
footprint.

00:38:07.806 --> 00:38:09.506
That is because the system can

00:38:09.506 --> 00:38:10.976
either reclaim that memory at

00:38:10.976 --> 00:38:12.366
some point, in the case of

00:38:12.396 --> 00:38:14.366
volatile or has already

00:38:14.426 --> 00:38:15.806
reclaimed it in the past, in the

00:38:15.806 --> 00:38:16.676
case of empty.

00:38:17.216 --> 00:38:18.766
So you may need to regenerate

00:38:18.766 --> 00:38:19.656
those resources.

00:38:21.106 --> 00:38:22.456
But that makes this kind of

00:38:22.496 --> 00:38:24.756
memory ideal for resource

00:38:24.756 --> 00:38:25.176
caches.

00:38:26.226 --> 00:38:28.616
So the best practice number 17

00:38:28.616 --> 00:38:30.226
is for you to mark resources as

00:38:30.226 --> 00:38:30.936
volatile.

00:38:31.676 --> 00:38:33.836
Temporary resources may become a

00:38:33.836 --> 00:38:35.126
large part of your game's

00:38:35.126 --> 00:38:35.646
footprint.

00:38:36.936 --> 00:38:38.526
And Metal will allow you to

00:38:38.526 --> 00:38:40.566
explicitly manage those, set the

00:38:40.566 --> 00:38:41.726
purgeable state of all the

00:38:41.726 --> 00:38:43.686
resources explicitly.

00:38:44.516 --> 00:38:46.136
So you will want to focus on

00:38:46.136 --> 00:38:48.406
your caches particularly all of

00:38:48.406 --> 00:38:49.836
those which hold mostly idle

00:38:49.836 --> 00:38:52.006
memory and carefully manage

00:38:52.036 --> 00:38:54.076
their purgeable state, so they

00:38:54.076 --> 00:38:55.066
will not count towards the

00:38:55.066 --> 00:38:55.956
game's footprint.

00:38:56.976 --> 00:38:59.336
Let's see a very short bit of

00:38:59.446 --> 00:39:01.036
code that will give you an

00:39:01.036 --> 00:39:02.336
example on how to do so.

00:39:03.026 --> 00:39:04.446
In this case, we have a texture

00:39:04.446 --> 00:39:06.116
cache, could have also been a

00:39:06.116 --> 00:39:06.876
buffer cache.

00:39:07.686 --> 00:39:09.456
And we will set the purgeable

00:39:09.456 --> 00:39:10.766
state of all the textures in

00:39:11.116 --> 00:39:13.456
that cache as volatile because

00:39:13.456 --> 00:39:15.716
we know that cache is mostly

00:39:15.716 --> 00:39:16.086
idle.

00:39:16.216 --> 00:39:18.386
We only use a texture now

00:39:18.386 --> 00:39:19.836
and then but not very often.

00:39:20.296 --> 00:39:22.786
So if we need to use a resource

00:39:22.786 --> 00:39:24.736
from that cache, we will then

00:39:24.736 --> 00:39:26.686
need to mark it as non-volatile

00:39:27.246 --> 00:39:28.916
that will ensure that the system

00:39:29.296 --> 00:39:30.806
doesn't remove its backing data.

00:39:32.166 --> 00:39:34.166
And in the case, it was empty

00:39:34.656 --> 00:39:36.636
which was the previous state

00:39:36.776 --> 00:39:37.926
that the one we just said.

00:39:38.556 --> 00:39:39.776
We may actually need to

00:39:39.776 --> 00:39:42.256
regenerate the data potentially

00:39:42.256 --> 00:39:42.496
not.

00:39:42.496 --> 00:39:44.116
It depends on what type of cache

00:39:44.116 --> 00:39:44.826
you're managing.

00:39:45.446 --> 00:39:47.676
But after we do so, we can just

00:39:47.676 --> 00:39:49.236
utilize the resource normally as

00:39:49.236 --> 00:39:50.196
we would otherwise.

00:39:52.256 --> 00:39:56.676
A very good practice will be for

00:39:56.676 --> 00:39:58.406
you to also check the common

00:39:58.406 --> 00:40:01.416
buffer completion and get to

00:40:01.416 --> 00:40:02.936
handle when the common buffer is

00:40:02.936 --> 00:40:04.876
completed and then potentially

00:40:04.876 --> 00:40:06.936
you flag that resource as

00:40:06.936 --> 00:40:07.936
volatile again.

00:40:08.486 --> 00:40:10.006
So it does not keep counting

00:40:10.006 --> 00:40:11.346
towards your memory footprint.

00:40:12.516 --> 00:40:14.786
You can be explicit and in fact

00:40:14.786 --> 00:40:16.116
you should be very aggressive

00:40:16.226 --> 00:40:17.926
particularly when you have lots

00:40:17.926 --> 00:40:19.716
of caches of mostly idle memory.

00:40:20.306 --> 00:40:23.596
So let's introduce one last

00:40:23.596 --> 00:40:25.746
concept that of pipeline state

00:40:25.746 --> 00:40:26.306
objects.

00:40:27.486 --> 00:40:28.846
Most of you are already familiar

00:40:28.846 --> 00:40:29.466
with those.

00:40:29.946 --> 00:40:32.216
PSOs encapsulate most of the

00:40:32.216 --> 00:40:33.226
Metal render state.

00:40:34.276 --> 00:40:35.326
They are constructed with a

00:40:35.326 --> 00:40:36.826
description-- a descriptor which

00:40:36.826 --> 00:40:38.486
contains vertex and fragment

00:40:38.486 --> 00:40:40.306
functions as well as other

00:40:40.306 --> 00:40:42.366
states such as the blend state

00:40:42.796 --> 00:40:44.016
and the vertex descriptor.

00:40:45.026 --> 00:40:46.636
All of these will get compiled

00:40:46.636 --> 00:40:48.286
into final Metal PSO.

00:40:49.686 --> 00:40:51.906
We only need this final Metal

00:40:51.906 --> 00:40:53.796
PSO in order to render.

00:40:54.466 --> 00:40:56.466
So the next best practice is for

00:40:56.466 --> 00:40:58.506
you to explicitly leverage that.

00:40:59.456 --> 00:41:00.606
Since Metal allows your

00:41:00.606 --> 00:41:02.336
application to load most of the

00:41:02.336 --> 00:41:04.176
rendering state up front, you

00:41:04.176 --> 00:41:04.896
should do so.

00:41:05.386 --> 00:41:06.246
That will be great for

00:41:06.246 --> 00:41:07.166
performance.

00:41:07.966 --> 00:41:09.536
But then consider the memory

00:41:09.536 --> 00:41:10.716
trade-off of doing that.

00:41:11.656 --> 00:41:12.756
If you are getting memory

00:41:12.756 --> 00:41:15.016
limited make sure do not hold on

00:41:15.016 --> 00:41:17.556
to PSO references that you know

00:41:17.556 --> 00:41:18.856
they are not needed anymore.

00:41:19.616 --> 00:41:21.876
And very important also do not

00:41:21.876 --> 00:41:23.246
hold on to Metal function

00:41:23.246 --> 00:41:24.946
references after you have

00:41:25.026 --> 00:41:26.426
created the PSO cache.

00:41:26.936 --> 00:41:28.326
Since those are not needed to

00:41:28.326 --> 00:41:29.926
render they are only needed to

00:41:29.926 --> 00:41:30.936
create new PSOs.

00:41:31.766 --> 00:41:33.456
So let's see what I mean by

00:41:33.456 --> 00:41:35.316
looking at the descriptor again.

00:41:36.086 --> 00:41:37.466
This is the pipeline state

00:41:37.466 --> 00:41:38.756
object as well as the pipeline

00:41:38.756 --> 00:41:39.946
state object descriptor.

00:41:40.326 --> 00:41:41.616
And what this best practice is

00:41:41.616 --> 00:41:43.826
asking you to do is to free the

00:41:43.826 --> 00:41:45.616
reference of both the vertex and

00:41:45.616 --> 00:41:46.966
fragment functions after you

00:41:46.966 --> 00:41:49.136
create the PSOs, potentially

00:41:49.136 --> 00:41:50.356
only hold on to those when

00:41:50.356 --> 00:41:52.896
you're populating the main PSO

00:41:52.896 --> 00:41:53.866
cache at load time.

00:41:54.926 --> 00:41:56.876
And then consider also freeing

00:41:56.876 --> 00:41:58.976
the PSO itself when you are

00:41:58.976 --> 00:42:00.866
getting memory limited if you

00:42:00.866 --> 00:42:02.736
know that that PSO is no longer

00:42:03.886 --> 00:42:04.056
needed.

00:42:04.616 --> 00:42:06.136
Now, let's, please welcome

00:42:06.136 --> 00:42:07.716
Onyechi on stage for an awesome

00:42:07.716 --> 00:42:08.936
demo of the Memory Viewer.

00:42:09.516 --> 00:42:15.006
[ Applause ]

00:42:15.506 --> 00:42:16.256
>> Thank you Guillem.

00:42:16.466 --> 00:42:17.646
Hello everyone.

00:42:19.086 --> 00:42:21.076
So you already have the brief

00:42:21.076 --> 00:42:22.066
introduction to the Memory

00:42:22.066 --> 00:42:23.136
Viewer from the previous slides.

00:42:23.276 --> 00:42:24.846
Now, I'm going to show you how

00:42:24.846 --> 00:42:26.246
to use it to understand your

00:42:26.246 --> 00:42:27.566
memory footprint that's

00:42:27.566 --> 00:42:28.746
optimized for better memory

00:42:28.746 --> 00:42:29.466
performance.

00:42:29.986 --> 00:42:32.816
So here we are again with a

00:42:32.816 --> 00:42:34.486
capture of a frame from the same

00:42:35.026 --> 00:42:36.086
early version of the game

00:42:36.296 --> 00:42:37.016
Afterpulse.

00:42:37.786 --> 00:42:39.026
Then the top left there are the

00:42:39.026 --> 00:42:40.746
debug navigator that you'll find

00:42:40.746 --> 00:42:42.716
in your Memory Gauge which when

00:42:42.716 --> 00:42:44.856
I click on it, it takes me into

00:42:44.856 --> 00:42:45.436
the Memory Viewer.

00:42:45.436 --> 00:42:48.326
Now this shows us the state of

00:42:48.326 --> 00:42:50.116
all live Metal resources for the

00:42:50.116 --> 00:42:50.616
captured frame.

00:42:51.386 --> 00:42:52.596
And my goal is to find

00:42:52.596 --> 00:42:53.886
opportunities to reduce its

00:42:53.886 --> 00:42:54.526
memory footprint.

00:42:55.326 --> 00:42:57.956
So to begin, let's take a look

00:42:57.956 --> 00:42:59.956
at the orange bars in the graph.

00:42:59.956 --> 00:43:01.336
This shows how our resources are

00:43:01.336 --> 00:43:02.606
distributed by type.

00:43:02.606 --> 00:43:04.856
And we can see that textures

00:43:04.856 --> 00:43:05.956
make up the largest proportion,

00:43:05.956 --> 00:43:06.156
right?

00:43:07.186 --> 00:43:08.916
There's about 440 megabytes of

00:43:08.916 --> 00:43:09.116
them.

00:43:09.506 --> 00:43:10.946
Now, I want to focus in these

00:43:10.946 --> 00:43:12.186
sections and I can simply do

00:43:12.186 --> 00:43:14.236
that by clicking on the filter

00:43:14.236 --> 00:43:14.666
button.

00:43:15.046 --> 00:43:18.176
Now, both the graph and the

00:43:18.176 --> 00:43:19.576
table have been updated to show

00:43:19.576 --> 00:43:20.276
textures only.

00:43:20.926 --> 00:43:23.266
So, next, Guillem mentioned that

00:43:23.266 --> 00:43:24.336
when looking to reduce our

00:43:24.336 --> 00:43:26.666
memory footprint starting at

00:43:26.666 --> 00:43:28.276
unused resources that was a

00:43:28.336 --> 00:43:29.346
great place to begin.

00:43:29.536 --> 00:43:30.736
So, let's do that.

00:43:30.736 --> 00:43:33.266
Let's look at the blue bars this

00:43:33.856 --> 00:43:33.966
time.

00:43:34.186 --> 00:43:36.596
This represents our usage and we

00:43:36.596 --> 00:43:37.926
see that we have about 200

00:43:37.926 --> 00:43:39.356
megabytes, so unused texture.

00:43:40.476 --> 00:43:43.406
So as a reminder, unused

00:43:43.406 --> 00:43:44.616
resources are resources that do

00:43:44.616 --> 00:43:45.936
not contribute to the final

00:43:45.936 --> 00:43:47.566
output of this rendered frame.

00:43:47.566 --> 00:43:49.296
That means they're not accessed

00:43:49.296 --> 00:43:49.996
by the GPU.

00:43:51.806 --> 00:43:54.176
OK. So, I can easily do that

00:43:54.176 --> 00:43:55.156
again by just clicking on the

00:43:55.156 --> 00:43:56.276
unused filter, so that we're

00:43:56.276 --> 00:43:57.986
looking on unused textures now.

00:43:59.276 --> 00:44:01.096
Next, I will sort the table by

00:44:01.096 --> 00:44:03.076
allocated size, so that we're

00:44:03.076 --> 00:44:04.286
focused in our largest texture.

00:44:04.286 --> 00:44:07.046
And we can see straight away

00:44:07.046 --> 00:44:08.606
that our largest texture which

00:44:08.606 --> 00:44:10.956
is about 13 megabytes has an

00:44:10.956 --> 00:44:11.386
issue.

00:44:12.176 --> 00:44:13.816
So, issues work here just like

00:44:13.816 --> 00:44:15.406
in Dependency Viewer you saw in

00:44:15.406 --> 00:44:16.226
the previous demo.

00:44:16.766 --> 00:44:17.856
So let's click it to see what

00:44:17.856 --> 00:44:18.396
it's about.

00:44:20.026 --> 00:44:21.436
OK. So, this says we have a

00:44:21.436 --> 00:44:22.546
large unused texture.

00:44:23.406 --> 00:44:25.106
It's not accessed by the CPU and

00:44:25.556 --> 00:44:26.796
has never been bound to a

00:44:26.796 --> 00:44:28.486
command encoder with a

00:44:28.486 --> 00:44:30.246
recommendation to avoid loading

00:44:30.246 --> 00:44:32.076
the resource or to make it

00:44:32.076 --> 00:44:32.636
volatile.

00:44:33.806 --> 00:44:35.476
So, we can also confront this by

00:44:35.476 --> 00:44:37.256
looking at the properties, CPU

00:44:37.256 --> 00:44:38.576
Access and Times since Last

00:44:38.576 --> 00:44:38.976
Bound.

00:44:38.976 --> 00:44:41.366
And we can clearly see that this

00:44:41.366 --> 00:44:42.536
section is definitely never been

00:44:42.536 --> 00:44:44.396
accessed by either the CPU or

00:44:44.396 --> 00:44:44.946
the GPU.

00:44:45.406 --> 00:44:46.396
So, therefore, we can say with

00:44:46.396 --> 00:44:47.506
confidence now this is a

00:44:47.736 --> 00:44:49.406
resource that it should be unloaded,

00:44:49.406 --> 00:44:51.756
till it's actually needed.

00:44:52.066 --> 00:44:53.186
OK. So, that's encouraging, we

00:44:53.186 --> 00:44:54.686
very quickly identify 13

00:44:54.726 --> 00:44:56.086
megabytes of memory savings.

00:44:56.846 --> 00:44:58.226
Let's check out the next issue.

00:44:58.866 --> 00:45:01.476
So, in this case, texture has

00:45:01.476 --> 00:45:03.036
been identified as a temporary

00:45:03.036 --> 00:45:03.566
resource.

00:45:03.886 --> 00:45:05.726
It's not accessed by the CPU and

00:45:05.726 --> 00:45:06.966
has not been bound to a command

00:45:06.966 --> 00:45:08.966
encoder for over 47 seconds.

00:45:09.666 --> 00:45:10.936
So, in other words, this texture

00:45:10.966 --> 00:45:12.606
has not been using this frame or

00:45:12.606 --> 00:45:13.986
in any other frame in the last

00:45:13.986 --> 00:45:14.986
47 seconds.

00:45:15.536 --> 00:45:16.606
So this is a pretty good

00:45:16.606 --> 00:45:18.196
candidate for a resource that

00:45:18.196 --> 00:45:19.846
should be made volatile if

00:45:19.886 --> 00:45:21.796
possible since it occasionally

00:45:21.796 --> 00:45:22.916
contributes to a frame.

00:45:23.816 --> 00:45:26.726
OK. So, this is fantastic.

00:45:27.056 --> 00:45:30.826
We've very quickly found about

00:45:30.826 --> 00:45:32.526
14 megabytes of memory savings

00:45:33.006 --> 00:45:35.796
and indeed when looking to

00:45:35.796 --> 00:45:36.876
reduce our memory footprint

00:45:37.256 --> 00:45:39.086
looking at unused resources is a

00:45:39.086 --> 00:45:41.026
great place to begin, and issues

00:45:41.026 --> 00:45:41.926
that will help you to quickly

00:45:41.926 --> 00:45:43.586
identify the best candidates to

00:45:43.586 --> 00:45:43.906
remove.

00:45:44.976 --> 00:45:45.916
But you should also pay

00:45:45.916 --> 00:45:47.166
attention to the properties

00:45:47.566 --> 00:45:51.256
Times since Last Bound to figure

00:45:51.256 --> 00:45:52.246
out which of your unused

00:45:52.246 --> 00:45:53.456
resources have never been

00:45:53.456 --> 00:45:55.396
submitted to the GPU even though

00:45:55.396 --> 00:45:56.556
they may have been accessed by

00:45:56.556 --> 00:45:57.156
the CPU.

00:45:59.196 --> 00:46:00.236
OK. Let's switch things up a

00:46:00.236 --> 00:46:00.506
bit.

00:46:00.836 --> 00:46:02.726
Let's see what issues or what

00:46:02.726 --> 00:46:04.736
memory savings we can discover,

00:46:04.736 --> 00:46:06.096
where textures are actually in

00:46:06.096 --> 00:46:06.476
used.

00:46:06.786 --> 00:46:08.696
OK. I'm going to switch to the

00:46:08.696 --> 00:46:09.876
used filter this time, so we're

00:46:09.876 --> 00:46:11.166
looking at used textures.

00:46:11.956 --> 00:46:12.996
And we see that one of our

00:46:12.996 --> 00:46:14.446
largest textures which is about

00:46:14.446 --> 00:46:16.536
18 megabytes has two issues.

00:46:17.296 --> 00:46:18.306
So, let's see what they are.

00:46:18.306 --> 00:46:20.666
OK. So, the first one is about

00:46:20.736 --> 00:46:22.586
lossless compression.

00:46:22.666 --> 00:46:24.176
Texture has opted out of

00:46:24.206 --> 00:46:26.106
lossless compressions because of

00:46:26.106 --> 00:46:27.466
the presence of a ShaderWrite

00:46:27.526 --> 00:46:29.486
usage flag, even though it's

00:46:29.486 --> 00:46:31.026
being used exclusively as a

00:46:31.026 --> 00:46:31.696
render target.

00:46:32.706 --> 00:46:34.566
The second issue is about

00:46:34.566 --> 00:46:35.156
storage mode.

00:46:36.086 --> 00:46:37.996
Our texture the render target

00:46:37.996 --> 00:46:39.246
has been identified as being

00:46:39.246 --> 00:46:41.316
transient which obviously means

00:46:41.316 --> 00:46:42.766
that no loads to actions are

00:46:42.766 --> 00:46:43.586
required for this texture.

00:46:44.176 --> 00:46:45.586
But unfortunately it has a

00:46:45.586 --> 00:46:47.496
storage mode shared when really

00:46:47.496 --> 00:46:48.676
it should be memoryless.

00:46:49.826 --> 00:46:51.596
So, we have two different

00:46:51.596 --> 00:46:52.386
recommendations here.

00:46:53.196 --> 00:46:55.186
And if you think about it, we

00:46:55.186 --> 00:46:56.416
can only really choose one of

00:46:56.416 --> 00:46:56.506
them.

00:46:57.596 --> 00:46:58.536
But at this point I should

00:46:58.536 --> 00:46:59.626
emphasize that these

00:46:59.626 --> 00:47:01.446
recommendations presented by the

00:47:01.446 --> 00:47:03.496
Memory Viewer are based on data

00:47:03.496 --> 00:47:04.686
gathered up to the current

00:47:04.686 --> 00:47:04.996
frame.

00:47:05.906 --> 00:47:07.836
However, you know better about how

00:47:07.836 --> 00:47:09.226
you intend to use your resource

00:47:09.296 --> 00:47:10.306
beyond the current frame.

00:47:11.386 --> 00:47:13.876
So, with that said if we are

00:47:13.876 --> 00:47:15.386
certain that this texture will

00:47:15.386 --> 00:47:17.336
remain transient and say a

00:47:17.336 --> 00:47:19.416
future render passes then

00:47:19.556 --> 00:47:20.786
switching to memoryless is the

00:47:20.786 --> 00:47:21.586
superior option.

00:47:21.706 --> 00:47:23.716
And doing so would reduce our

00:47:23.716 --> 00:47:24.956
memory footprint by the size of

00:47:24.956 --> 00:47:26.186
the texture which is 18

00:47:26.186 --> 00:47:26.736
megabytes.

00:47:27.676 --> 00:47:29.426
If on the other hand, our

00:47:29.426 --> 00:47:32.276
texture will not be transient in

00:47:32.276 --> 00:47:34.436
future render passes then we

00:47:34.436 --> 00:47:36.056
should seriously consider opting

00:47:36.056 --> 00:47:37.246
into lossless compression

00:47:37.876 --> 00:47:39.076
because doing so would have a

00:47:39.076 --> 00:47:40.426
positive impact on our memory

00:47:40.426 --> 00:47:41.656
bandwidth as suggested by

00:47:41.656 --> 00:47:42.006
Guillem.

00:47:42.866 --> 00:47:44.706
And, in this case, simply

00:47:44.706 --> 00:47:46.016
removing the redundant

00:47:46.016 --> 00:47:48.206
ShaderWrite flag should do the

00:47:49.336 --> 00:47:49.476
trick.

00:47:49.656 --> 00:47:52.636
So, we've only just scratched

00:47:52.636 --> 00:47:54.116
the surface of what's possible

00:47:54.236 --> 00:47:54.996
with the Memory Viewer.

00:47:55.556 --> 00:47:56.556
You've seen how with just a few

00:47:56.556 --> 00:47:57.716
mouse clicks it makes it very

00:47:57.716 --> 00:47:59.496
easy for you to understand your

00:47:59.496 --> 00:48:01.266
memory usage and also it makes

00:48:01.266 --> 00:48:02.596
it very quick for you to

00:48:02.596 --> 00:48:04.516
identify those hard to find

00:48:04.516 --> 00:48:05.696
issues that may affect your

00:48:05.696 --> 00:48:06.266
performance.

00:48:06.536 --> 00:48:07.876
And with that I'm going to

00:48:07.876 --> 00:48:09.096
welcome Guillem back to the

00:48:09.096 --> 00:48:09.456
stage.

00:48:09.666 --> 00:48:09.856
Thank you.

00:48:10.516 --> 00:48:14.886
[ Applause ]

00:48:15.386 --> 00:48:16.856
>> Thank you that was also an

00:48:16.856 --> 00:48:17.516
awesome demo.

00:48:18.856 --> 00:48:22.146
Cool. So, we have seen a lot of

00:48:22.146 --> 00:48:23.126
best practices today.

00:48:23.126 --> 00:48:25.666
We've been through a total of 18

00:48:25.666 --> 00:48:27.146
of them which is quite a lot of

00:48:27.146 --> 00:48:28.506
content to go through really.

00:48:29.416 --> 00:48:30.916
Notice that most of this best

00:48:30.916 --> 00:48:32.336
practices are actually quite

00:48:32.336 --> 00:48:33.146
related, right?

00:48:33.206 --> 00:48:35.656
So, most of the memory bandwidth

00:48:35.656 --> 00:48:37.426
best practices, will also help

00:48:37.426 --> 00:48:38.416
you reducing the memory

00:48:38.466 --> 00:48:39.086
footprint.

00:48:39.866 --> 00:48:42.496
So, maybe the best way to

00:48:42.496 --> 00:48:44.056
actually think about all this

00:48:44.056 --> 00:48:46.506
content, this is a checklist of

00:48:46.506 --> 00:48:48.166
optimizations for your Metal

00:48:48.166 --> 00:48:49.236
game or application.

00:48:50.386 --> 00:48:53.416
And when you carefully take all

00:48:53.416 --> 00:48:56.076
of these elements, you too will

00:48:56.076 --> 00:48:58.236
be delivering optimized Metal

00:48:58.266 --> 00:49:00.396
games and apps, which was all

00:49:00.396 --> 00:49:02.486
that this talk is all about.

00:49:02.836 --> 00:49:05.026
For more information please see

00:49:05.026 --> 00:49:07.146
our documentation online and

00:49:07.146 --> 00:49:08.996
come visit us at the lab today

00:49:08.996 --> 00:49:09.406
at 3.

00:49:10.456 --> 00:49:11.696
Thank you very much and I hope

00:49:11.696 --> 00:49:12.766
you enjoy the rest of the show.

00:49:12.766 --> 00:49:12.956
Thank you.

00:49:13.508 --> 00:49:15.508
[ Applause ]
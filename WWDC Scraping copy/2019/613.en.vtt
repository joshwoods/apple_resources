WEBVTT

00:00:01.176 --> 00:00:04.500
[ Music ]

00:00:10.516 --> 00:00:14.546
[ Applause ]

00:00:15.046 --> 00:00:15.836
>> Good morning everyone.

00:00:16.245 --> 00:00:17.746
My name is Sean and I'm an

00:00:17.746 --> 00:00:19.376
engineer on Apple's GPU Software

00:00:19.376 --> 00:00:19.736
Team.

00:00:20.856 --> 00:00:21.686
In this session we're going to

00:00:21.686 --> 00:00:22.706
talk about Ray Tracing.

00:00:23.336 --> 00:00:24.606
So, let's first review what Ray

00:00:24.606 --> 00:00:25.866
Tracing is.

00:00:26.556 --> 00:00:27.976
Ray Tracing applications are

00:00:27.976 --> 00:00:29.346
based on tracing the paths the

00:00:29.346 --> 00:00:30.816
rays take as they interact with

00:00:30.816 --> 00:00:31.296
a scene.

00:00:32.076 --> 00:00:33.796
So, Ray Tracing has applications

00:00:33.796 --> 00:00:35.666
in rendering, audio, physics

00:00:35.666 --> 00:00:36.836
simulation, and more.

00:00:37.926 --> 00:00:39.336
In particular Ray Tracing is

00:00:39.336 --> 00:00:41.016
often used in offline rendering

00:00:41.016 --> 00:00:42.686
applications to simulate

00:00:42.686 --> 00:00:43.886
individual rays of light

00:00:43.886 --> 00:00:44.886
bouncing around a scene.

00:00:45.586 --> 00:00:47.086
This allows these applications

00:00:47.086 --> 00:00:48.166
to render photo realistic

00:00:48.196 --> 00:00:49.756
reflections, refractions,

00:00:49.926 --> 00:00:51.706
shadows, global illumination,

00:00:51.976 --> 00:00:56.336
and more.

00:00:56.556 --> 00:00:58.076
Recently, Ray Tracing has also

00:00:58.076 --> 00:00:59.336
started to be used in real-time

00:00:59.336 --> 00:01:00.366
applications such as games.

00:01:00.366 --> 00:01:02.606
And this actually introduces

00:01:02.606 --> 00:01:03.596
some new requirements.

00:01:05.016 --> 00:01:07.036
First, in real-time applications

00:01:07.036 --> 00:01:08.256
objects tend to move around.

00:01:08.326 --> 00:01:09.436
So, we need to be able to

00:01:09.436 --> 00:01:10.926
support both camera and object

00:01:10.926 --> 00:01:11.406
motion.

00:01:12.376 --> 00:01:14.466
Second, performance is now even

00:01:14.466 --> 00:01:15.136
more critical.

00:01:15.896 --> 00:01:16.726
This means that the ray

00:01:16.726 --> 00:01:18.206
intersection itself has to be as

00:01:18.206 --> 00:01:20.016
efficient as possible and we

00:01:20.016 --> 00:01:21.406
also have to make effective use

00:01:21.406 --> 00:01:22.546
of our limited ray budget.

00:01:23.576 --> 00:01:24.746
So, we need to careful with our

00:01:24.746 --> 00:01:26.196
sampling strategies, random

00:01:26.196 --> 00:01:28.256
number generation, and so on.

00:01:29.236 --> 00:01:30.746
Finally, even with these

00:01:30.746 --> 00:01:31.956
techniques we won't be able to

00:01:31.956 --> 00:01:33.376
cast enough rays to remove all

00:01:33.376 --> 00:01:33.756
the noise.

00:01:34.386 --> 00:01:35.446
So, we need a sophisticated

00:01:35.446 --> 00:01:36.606
noise reduction strategy.

00:01:37.366 --> 00:01:39.336
Fortunately, Metal has built in

00:01:39.336 --> 00:01:41.006
support for Ray Tracing and

00:01:41.006 --> 00:01:41.576
Denoising.

00:01:41.766 --> 00:01:42.876
So, it's easy to get started.

00:01:43.956 --> 00:01:45.146
So, let's first review how Ray

00:01:45.146 --> 00:01:46.686
Tracing works in Metal and then

00:01:46.686 --> 00:01:47.496
we'll move on to some more

00:01:47.496 --> 00:01:48.306
advanced topics.

00:01:48.866 --> 00:01:51.656
So, if you look at a typical Ray

00:01:51.656 --> 00:01:53.246
Tracing application, they all

00:01:53.246 --> 00:01:54.686
follow roughly the same outline.

00:01:55.516 --> 00:01:56.946
First, we generate some rays.

00:01:57.646 --> 00:01:58.846
Each ray is defined by its

00:01:58.886 --> 00:02:00.206
origin point and its direction

00:02:00.206 --> 00:02:00.616
vector.

00:02:01.816 --> 00:02:03.086
Those rays are then intersected

00:02:03.086 --> 00:02:04.136
against the geometry in the

00:02:04.136 --> 00:02:05.566
scene, which is usually made of

00:02:05.566 --> 00:02:06.076
triangles.

00:02:06.746 --> 00:02:08.286
The intersection data could just

00:02:08.286 --> 00:02:09.076
be the distance to the

00:02:09.076 --> 00:02:10.536
intersection point, but it

00:02:10.606 --> 00:02:11.726
typically includes additional

00:02:11.726 --> 00:02:13.186
data such as the index of the

00:02:13.186 --> 00:02:14.636
triangle that was hit and the

00:02:14.636 --> 00:02:15.766
very center coordinates of the

00:02:15.766 --> 00:02:17.206
intersection point.

00:02:18.636 --> 00:02:19.906
The next step consumes the

00:02:19.906 --> 00:02:20.846
intersection results.

00:02:21.106 --> 00:02:22.176
For example, in a rendering

00:02:22.176 --> 00:02:23.866
application this is typically a

00:02:23.866 --> 00:02:25.436
shading step which outputs an

00:02:25.436 --> 00:02:25.806
image.

00:02:26.566 --> 00:02:27.876
And this step may also generate

00:02:27.876 --> 00:02:29.646
additional rays, so we repeat

00:02:29.646 --> 00:02:31.056
this process however many times

00:02:31.056 --> 00:02:33.996
we need until we're done.

00:02:34.176 --> 00:02:35.676
Applications typically intersect

00:02:35.786 --> 00:02:37.116
millions of rays with the scene

00:02:37.116 --> 00:02:37.736
every frame.

00:02:38.786 --> 00:02:40.166
And this core intersection step

00:02:40.226 --> 00:02:41.536
is common to all Ray Tracing

00:02:41.536 --> 00:02:42.246
applications.

00:02:42.936 --> 00:02:44.326
So, this intersection step is

00:02:44.326 --> 00:02:47.426
what we accelerate in Metal.

00:02:47.566 --> 00:02:49.136
Last year, we introduced the

00:02:49.136 --> 00:02:51.486
MPSRayIntersector API, which is

00:02:51.486 --> 00:02:52.486
part of the Metal performance

00:02:52.486 --> 00:02:53.226
shaders framework.

00:02:54.296 --> 00:02:55.806
This API accelerates ray

00:02:55.806 --> 00:02:57.946
intersection on the GPU on all

00:02:57.946 --> 00:02:59.456
of our Mac and iOS devices.

00:03:00.366 --> 00:03:01.556
We talked a lot about this API

00:03:01.626 --> 00:03:02.866
in last year's talk, so we'd

00:03:02.866 --> 00:03:03.926
encourage you to go back and

00:03:03.926 --> 00:03:05.056
review this talk for more

00:03:05.056 --> 00:03:05.526
information.

00:03:06.486 --> 00:03:08.336
At a high level, this API takes

00:03:08.336 --> 00:03:09.496
in batches of rays through a

00:03:09.496 --> 00:03:10.176
Metal buffer.

00:03:10.996 --> 00:03:11.846
It finds the closest

00:03:11.846 --> 00:03:13.406
intersection along each ray and

00:03:13.406 --> 00:03:14.746
returns the results in another

00:03:14.746 --> 00:03:15.136
buffer.

00:03:15.666 --> 00:03:18.376
And all of this work is encoded

00:03:18.416 --> 00:03:20.006
into a Metal commandBuffer at

00:03:20.006 --> 00:03:21.146
the point in your application

00:03:21.146 --> 00:03:21.716
where you'd like to do

00:03:21.716 --> 00:03:22.626
intersection testing.

00:03:23.236 --> 00:03:26.016
Much of the speed up comes from

00:03:26.016 --> 00:03:27.106
building a data structure we

00:03:27.106 --> 00:03:28.466
call an acceleration structure.

00:03:29.156 --> 00:03:30.546
This data structure recursively

00:03:30.546 --> 00:03:32.426
partitions triangles in space so

00:03:32.976 --> 00:03:34.266
that we can quickly eliminate

00:03:34.266 --> 00:03:35.756
triangles which cannot possibly

00:03:35.756 --> 00:03:37.306
intersect a given ray during the

00:03:37.306 --> 00:03:38.196
intersection search.

00:03:38.706 --> 00:03:41.036
Metal takes care of building

00:03:41.036 --> 00:03:42.326
this data structure for you.

00:03:42.746 --> 00:03:44.066
All you have to do is specify

00:03:44.066 --> 00:03:44.996
when you'd like to build the

00:03:44.996 --> 00:03:46.616
acceleration structure, then

00:03:46.616 --> 00:03:47.486
simply pass it to the

00:03:47.486 --> 00:03:48.696
intersector for intersection

00:03:48.696 --> 00:03:49.126
testing.

00:03:50.266 --> 00:03:51.436
Now, building this data

00:03:51.436 --> 00:03:52.756
structure is typically a fixed

00:03:52.756 --> 00:03:54.156
cost paid when your app starts

00:03:54.156 --> 00:03:54.366
up.

00:03:55.666 --> 00:03:56.536
In last year's version of the

00:03:56.536 --> 00:03:58.106
API this data structure was

00:03:58.106 --> 00:03:59.386
always built on the CPU.

00:04:00.056 --> 00:04:01.156
This year, we've moved the

00:04:01.156 --> 00:04:02.756
acceleration structure build to

00:04:02.756 --> 00:04:04.716
the GPU, which can significantly

00:04:04.716 --> 00:04:06.076
reduce the startup cost.

00:04:06.646 --> 00:04:08.006
And even better, the GPU will be

00:04:08.006 --> 00:04:09.226
used automatically whenever

00:04:09.226 --> 00:04:09.726
possible.

00:04:09.856 --> 00:04:10.726
So, you don't need to do

00:04:10.726 --> 00:04:12.166
anything to see the speed up in

00:04:12.166 --> 00:04:12.796
your applications.

00:04:14.406 --> 00:04:15.796
So, let's now revisit our

00:04:15.796 --> 00:04:17.305
typical Ray Tracing application

00:04:17.396 --> 00:04:18.315
and see what we need to do to

00:04:18.315 --> 00:04:19.466
translate it into a Metal Ray

00:04:19.466 --> 00:04:20.375
Tracing application.

00:04:21.005 --> 00:04:23.346
So, like I said, we'll start by

00:04:23.376 --> 00:04:24.106
generating rays.

00:04:24.896 --> 00:04:26.076
This is typically done using a

00:04:26.076 --> 00:04:27.326
compute kernel, but it could

00:04:27.326 --> 00:04:28.416
also be done from a fragment

00:04:28.416 --> 00:04:30.286
shader or really any mechanism

00:04:30.286 --> 00:04:31.116
that can write to a Metal

00:04:31.116 --> 00:04:31.486
buffer.

00:04:32.676 --> 00:04:33.946
We then pass the ray buffer to

00:04:33.946 --> 00:04:34.646
the intersector.

00:04:35.596 --> 00:04:37.196
It'll find the intersections and

00:04:37.196 --> 00:04:38.236
return the result in our

00:04:38.236 --> 00:04:39.116
intersection buffer.

00:04:39.556 --> 00:04:40.956
And remember that to use the

00:04:40.956 --> 00:04:42.486
intersector we need to provide

00:04:42.486 --> 00:04:43.596
an acceleration structure.

00:04:44.386 --> 00:04:45.926
We can often build this just one

00:04:46.076 --> 00:04:47.186
and reuse it many times.

00:04:48.496 --> 00:04:50.056
Finally, we'll launch one last

00:04:50.056 --> 00:04:52.016
compute kernel which will use

00:04:52.016 --> 00:04:53.456
the intersection data to write a

00:04:53.456 --> 00:04:55.026
shaded image into a texture.

00:04:55.986 --> 00:04:57.616
And this compute kernel can also

00:04:57.616 --> 00:04:59.006
write additional rays back into

00:04:59.006 --> 00:05:00.176
the ray buffer for iterative

00:05:00.176 --> 00:05:00.846
applications.

00:05:02.286 --> 00:05:03.166
So, let's see how this works in

00:05:03.166 --> 00:05:03.936
a real application.

00:05:05.226 --> 00:05:06.676
For this example, we'll talk

00:05:06.676 --> 00:05:08.006
about how Ray Tracing is being

00:05:08.006 --> 00:05:09.236
used in AR Quick Look.

00:05:09.686 --> 00:05:11.236
AR Quick Look was introduced

00:05:11.236 --> 00:05:12.436
last year and allows you to

00:05:12.506 --> 00:05:14.346
preview 3D assets in augmented

00:05:14.346 --> 00:05:14.676
reality.

00:05:15.996 --> 00:05:17.176
We talked a lot about AR Quick

00:05:17.176 --> 00:05:18.456
Look in this morning's session.

00:05:18.526 --> 00:05:19.686
So, I'd encourage you to watch

00:05:19.686 --> 00:05:20.436
that talk as well.

00:05:20.436 --> 00:05:22.336
For this talk, we'll focus on

00:05:22.336 --> 00:05:23.816
how AR Quick Look is using Ray

00:05:23.816 --> 00:05:25.446
Tracing to render an Ambient

00:05:25.446 --> 00:05:26.146
Occlusion effect.

00:05:27.076 --> 00:05:28.086
We'll talk more about Ambient

00:05:28.086 --> 00:05:29.766
Occlusion later, but for now,

00:05:29.766 --> 00:05:31.116
what you need to know is that

00:05:31.156 --> 00:05:32.356
Ambient Occlusion computes an

00:05:32.356 --> 00:05:34.326
approximation of how much light

00:05:34.386 --> 00:05:35.436
can reach each point in the

00:05:35.506 --> 00:05:35.816
scene.

00:05:36.616 --> 00:05:37.376
So, this results in the

00:05:37.376 --> 00:05:38.316
darkening of the ground

00:05:38.316 --> 00:05:39.926
underneath the robot model as

00:05:39.926 --> 00:05:41.436
well as soft contact shadows

00:05:41.486 --> 00:05:42.776
between the robot's legs and the

00:05:42.776 --> 00:05:43.136
ground.

00:05:43.656 --> 00:05:46.236
The effect is somewhat subtle,

00:05:46.236 --> 00:05:47.556
but if we turn it off, we can

00:05:47.556 --> 00:05:48.766
see that it actually goes a long

00:05:48.766 --> 00:05:50.066
way towards grounding the robot

00:05:50.066 --> 00:05:50.606
in the scene.

00:05:51.206 --> 00:05:52.566
And this is really important for

00:05:52.566 --> 00:05:54.226
AR applications to prevent

00:05:54.226 --> 00:05:55.126
objects from looking like

00:05:55.126 --> 00:05:56.876
they're floating above the

00:05:58.496 --> 00:05:58.656
ground.

00:05:58.806 --> 00:05:59.946
In last year's version of AR

00:05:59.946 --> 00:06:01.036
Quick Look, the shadows are

00:06:01.036 --> 00:06:02.876
actually precomputed, so they

00:06:02.936 --> 00:06:04.246
wouldn't move as objects moved

00:06:04.246 --> 00:06:04.606
around.

00:06:05.956 --> 00:06:07.736
This year, we've used Metal

00:06:07.776 --> 00:06:09.466
support for dynamic scenes to

00:06:09.466 --> 00:06:10.606
render these shadows in real

00:06:10.606 --> 00:06:10.956
time.

00:06:11.426 --> 00:06:13.226
So now as objects move their

00:06:13.226 --> 00:06:14.276
shadows will move with them.

00:06:14.836 --> 00:06:17.106
And this even works for

00:06:17.106 --> 00:06:18.516
deforming objects such as

00:06:18.516 --> 00:06:19.246
skinned models.

00:06:19.686 --> 00:06:20.886
We can see the shadows follow

00:06:20.886 --> 00:06:22.176
the motions of the fish as it

00:06:22.176 --> 00:06:23.706
swims around the scene.

00:06:25.916 --> 00:06:27.326
So, what we just saw actually

00:06:27.326 --> 00:06:28.456
has three types of animation

00:06:28.456 --> 00:06:28.946
going on.

00:06:28.946 --> 00:06:30.486
If we were just using the

00:06:30.486 --> 00:06:31.796
rasterizer, we'd simply

00:06:31.796 --> 00:06:33.006
rasterize the triangles in their

00:06:33.006 --> 00:06:33.576
new position.

00:06:34.346 --> 00:06:35.266
But because we're using Ray

00:06:35.266 --> 00:06:36.646
Tracing, we need to maintain an

00:06:36.646 --> 00:06:37.726
acceleration structure.

00:06:38.826 --> 00:06:40.446
So, the first type of animation

00:06:40.446 --> 00:06:41.476
is simple camera movement.

00:06:41.476 --> 00:06:43.186
And this is movement due to just

00:06:43.326 --> 00:06:44.436
moving the iPad around.

00:06:45.516 --> 00:06:46.386
We don't need to update the

00:06:46.386 --> 00:06:47.436
acceleration structure just

00:06:47.436 --> 00:06:48.586
because the cameras moved.

00:06:48.876 --> 00:06:49.956
So, we actually get this type of

00:06:49.956 --> 00:06:50.916
animation for free.

00:06:51.646 --> 00:06:53.056
We can simply start firing rays

00:06:53.056 --> 00:06:54.006
from the new camera position.

00:06:55.156 --> 00:06:56.436
The other two types of animation

00:06:56.436 --> 00:06:57.536
do require updating the

00:06:57.536 --> 00:06:58.476
acceleration structure.

00:06:58.666 --> 00:07:00.746
So, the first is Vertex

00:07:00.746 --> 00:07:01.286
Animation.

00:07:02.236 --> 00:07:03.346
This could be skinned models

00:07:03.346 --> 00:07:04.876
like the fish, but it could also

00:07:04.876 --> 00:07:06.226
be plants blowing in the wind,

00:07:06.376 --> 00:07:07.676
cloth, or other types of

00:07:07.676 --> 00:07:08.206
deformation.

00:07:09.276 --> 00:07:10.336
Metal includes a special

00:07:10.336 --> 00:07:11.636
acceleration structure update

00:07:11.636 --> 00:07:13.166
mechanism optimized for cases

00:07:13.166 --> 00:07:13.646
like this.

00:07:14.176 --> 00:07:16.446
And the last type of animation

00:07:16.446 --> 00:07:17.626
is rigid body animation.

00:07:18.346 --> 00:07:19.566
This is where objects can move,

00:07:19.646 --> 00:07:21.556
rotate, and scale, but otherwise

00:07:21.556 --> 00:07:22.796
completely maintain their shape.

00:07:23.606 --> 00:07:24.496
So, a large portion of the

00:07:24.496 --> 00:07:25.646
acceleration structure is

00:07:25.646 --> 00:07:26.566
actually still valid.

00:07:27.266 --> 00:07:28.406
So, Metal also includes a

00:07:28.406 --> 00:07:30.006
special mechanism to reuse the

00:07:30.006 --> 00:07:30.976
parts of the acceleration

00:07:30.976 --> 00:07:32.186
structure that hasn't changed.

00:07:33.456 --> 00:07:34.316
So, let's first talk about

00:07:34.316 --> 00:07:35.086
Vertex Animation.

00:07:36.206 --> 00:07:38.166
As the geometry changes, we need

00:07:38.166 --> 00:07:39.176
to update the acceleration

00:07:39.176 --> 00:07:39.626
structure.

00:07:40.616 --> 00:07:42.046
We could rebuild it from scratch

00:07:42.046 --> 00:07:43.706
every frame, but we can actually

00:07:44.496 --> 00:07:45.246
do better.

00:07:45.436 --> 00:07:47.146
In Vertex Animation use cases

00:07:47.446 --> 00:07:48.896
objects tend to mostly retain

00:07:48.896 --> 00:07:49.306
their shape.

00:07:49.646 --> 00:07:50.986
For example, a character's hands

00:07:50.986 --> 00:07:51.816
will stay connected to their

00:07:51.816 --> 00:07:52.186
arms.

00:07:52.546 --> 00:07:53.606
Their arms will stay connected

00:07:53.606 --> 00:07:54.866
to their body and so on.

00:07:55.506 --> 00:07:57.046
So, the spatial hierarchy

00:07:57.046 --> 00:07:58.406
encoded into the acceleration

00:07:58.406 --> 00:08:00.326
structure is mostly still valid.

00:08:00.856 --> 00:08:02.046
It just needs to be adjusted to

00:08:02.046 --> 00:08:02.866
the new geometry.

00:08:03.636 --> 00:08:04.586
Let's look at an example.

00:08:06.046 --> 00:08:06.966
So, here's the acceleration

00:08:06.966 --> 00:08:08.036
structure we saw earlier.

00:08:09.356 --> 00:08:10.656
If the triangles move, we can

00:08:10.656 --> 00:08:11.806
see that the bounding boxes no

00:08:11.806 --> 00:08:12.586
longer line up with the

00:08:12.586 --> 00:08:13.026
triangles.

00:08:13.786 --> 00:08:15.086
But the tree structure itself

00:08:15.086 --> 00:08:16.226
mostly still makes sense.

00:08:16.596 --> 00:08:18.006
So rather than rebuild it from

00:08:18.006 --> 00:08:19.566
scratch, we can simply snap the

00:08:19.566 --> 00:08:20.816
bounding boxes to the new

00:08:20.816 --> 00:08:22.616
triangle positions from bottom

00:08:23.066 --> 00:08:24.286
to top.

00:08:24.496 --> 00:08:25.456
We call this operation

00:08:25.456 --> 00:08:25.956
Refitting.

00:08:26.786 --> 00:08:27.766
As we can see, this still

00:08:27.766 --> 00:08:29.146
results in a valid acceleration

00:08:29.146 --> 00:08:31.016
structure, but it's much faster

00:08:31.016 --> 00:08:32.256
than building from scratch

00:08:32.385 --> 00:08:33.356
because we can reuse the

00:08:33.356 --> 00:08:34.126
existing tree.

00:08:34.666 --> 00:08:37.186
This also runs entirely on the

00:08:37.186 --> 00:08:39.216
GPU, which makes it even faster,

00:08:39.296 --> 00:08:40.426
but also means that we can

00:08:40.476 --> 00:08:41.666
safely encode a Refitting

00:08:41.666 --> 00:08:43.596
operation after say a compute

00:08:43.596 --> 00:08:44.986
kernel which updates the

00:08:44.986 --> 00:08:45.606
vertices.

00:08:46.136 --> 00:08:48.406
The downside is that we can't

00:08:48.406 --> 00:08:49.886
add or remove any geometry

00:08:49.886 --> 00:08:50.866
because the tree will still

00:08:50.866 --> 00:08:52.086
encode references to the old

00:08:52.086 --> 00:08:52.646
geometry.

00:08:54.156 --> 00:08:55.786
This also potentially degrades

00:08:55.786 --> 00:08:56.856
the acceleration structures

00:08:56.856 --> 00:08:58.206
quality which can impact Ray

00:08:58.206 --> 00:08:59.156
Tracing performance.

00:08:59.966 --> 00:09:00.946
This is because the triangles

00:09:00.946 --> 00:09:02.136
were originally partitioned

00:09:02.316 --> 00:09:03.636
using a set of futuristics which

00:09:03.636 --> 00:09:04.786
won't be accurate after the

00:09:04.786 --> 00:09:05.536
triangles move.

00:09:06.016 --> 00:09:08.376
The impact is usually minor, but

00:09:08.376 --> 00:09:09.886
extreme cases like teleporting

00:09:09.886 --> 00:09:11.396
geometry could cause performance

00:09:11.396 --> 00:09:11.826
problems.

00:09:12.606 --> 00:09:13.766
Nonetheless, this works great

00:09:13.766 --> 00:09:15.456
for typical deformation and

00:09:15.456 --> 00:09:16.796
character skinning use cases.

00:09:17.236 --> 00:09:18.606
So, let's see how to set this up

00:09:18.606 --> 00:09:18.976
in code.

00:09:20.056 --> 00:09:21.526
First, before we build the

00:09:21.526 --> 00:09:22.856
accelerations structure, we need

00:09:22.856 --> 00:09:24.336
to enable support for Refitting.

00:09:24.886 --> 00:09:26.306
And note that just enabling

00:09:26.306 --> 00:09:27.606
Refitting is enough to reduce

00:09:27.646 --> 00:09:28.636
the acceleration structure's

00:09:28.636 --> 00:09:29.056
quality.

00:09:29.056 --> 00:09:31.006
So definitely only turn this on

00:09:31.036 --> 00:09:32.136
if you really need to refit the

00:09:32.136 --> 00:09:33.076
acceleration structure.

00:09:34.536 --> 00:09:36.376
Then we simple call encodeRefit

00:09:36.376 --> 00:09:37.596
into a Metal commandBuffer.

00:09:38.176 --> 00:09:39.786
And that's all we need to do for

00:09:39.786 --> 00:09:40.736
Vertex Animation.

00:09:41.636 --> 00:09:43.176
So next, let's talk about Rigid

00:09:43.176 --> 00:09:43.826
Body Animation.

00:09:44.936 --> 00:09:46.526
So as the name implies, this is

00:09:46.526 --> 00:09:47.576
animation where objects can

00:09:47.576 --> 00:09:49.396
move, rotate, and scale, but

00:09:49.396 --> 00:09:50.676
otherwise completely maintain

00:09:50.676 --> 00:09:51.086
their shape.

00:09:51.876 --> 00:09:53.166
So, in the example on the right,

00:09:53.436 --> 00:09:54.246
even though it looks like the

00:09:54.246 --> 00:09:55.846
robot is deforming, actually all

00:09:55.846 --> 00:09:57.366
of its joins are moving rigidly.

00:09:57.776 --> 00:09:58.906
So, this is still an example of

00:09:58.906 --> 00:09:59.856
Rigid Body Animation.

00:10:01.316 --> 00:10:02.816
So, in a typical scene, most of

00:10:02.816 --> 00:10:04.036
the geometry is probably only

00:10:04.036 --> 00:10:04.846
moving rigidly.

00:10:05.546 --> 00:10:07.026
In fact, most of the geometry is

00:10:07.026 --> 00:10:08.196
probably not moving at all.

00:10:09.636 --> 00:10:11.346
We may also have multiple copies

00:10:11.436 --> 00:10:12.596
of the same objects in the

00:10:12.656 --> 00:10:13.006
scene.

00:10:13.426 --> 00:10:14.766
It would be wasteful to

00:10:14.766 --> 00:10:16.196
replicate these objects multiple

00:10:16.196 --> 00:10:17.256
times in the accelerations

00:10:17.256 --> 00:10:18.976
structure and it would also be

00:10:18.976 --> 00:10:20.506
inefficient to refit or rebuild

00:10:20.506 --> 00:10:21.556
the entire acceleration

00:10:21.556 --> 00:10:23.306
structure just because a subset

00:10:23.306 --> 00:10:24.346
of the geometry is moving.

00:10:25.526 --> 00:10:26.816
So, to solve both of these

00:10:26.846 --> 00:10:28.176
problems, we can use what we

00:10:28.176 --> 00:10:29.486
call a Two-Level Acceleration

00:10:29.486 --> 00:10:29.956
Structure.

00:10:30.526 --> 00:10:33.586
So, what we'll do is first build

00:10:33.586 --> 00:10:34.766
a high-quality triangle

00:10:34.766 --> 00:10:36.186
acceleration structure for each

00:10:36.186 --> 00:10:37.626
unique object in the scene.

00:10:37.626 --> 00:10:38.896
And we can do this just once

00:10:38.896 --> 00:10:41.326
when the app starts up.

00:10:41.356 --> 00:10:42.826
We'll then create two copies of

00:10:42.826 --> 00:10:44.296
those -- of those triangle

00:10:44.296 --> 00:10:45.936
acceleration structures using a

00:10:46.016 --> 00:10:47.266
second acceleration structure.

00:10:47.976 --> 00:10:49.876
Each copy is called an instance

00:10:49.876 --> 00:10:51.166
of one of the original triangle

00:10:51.166 --> 00:10:52.156
acceleration structures.

00:10:53.866 --> 00:10:55.196
Each instance is associated with

00:10:55.196 --> 00:10:56.396
a transformation matrix,

00:10:57.126 --> 00:10:58.356
describing where to place it in

00:10:58.356 --> 00:10:58.796
the scene.

00:10:59.696 --> 00:11:00.786
So, we'll do this all using two

00:11:00.786 --> 00:11:02.106
buffers and each buffer will

00:11:02.106 --> 00:11:03.556
contain one entry for each

00:11:03.556 --> 00:11:04.526
instance in the scene.

00:11:05.846 --> 00:11:06.806
The first buffer will contain

00:11:06.806 --> 00:11:08.146
the transformation matrices for

00:11:08.146 --> 00:11:08.926
all the instances.

00:11:10.376 --> 00:11:11.816
The second buffer will contain

00:11:11.816 --> 00:11:13.286
indices into an array of

00:11:13.286 --> 00:11:14.256
triangle accelerations

00:11:14.256 --> 00:11:16.056
structures describing which

00:11:16.056 --> 00:11:17.286
acceleration structure to use

00:11:17.286 --> 00:11:18.096
for each instance.

00:11:18.716 --> 00:11:21.246
We'll then build a second

00:11:21.246 --> 00:11:22.976
acceleration structure over just

00:11:22.976 --> 00:11:24.466
the instances in the scene.

00:11:25.556 --> 00:11:26.926
We can then quickly rebuild just

00:11:26.926 --> 00:11:28.016
the instance acceleration

00:11:28.016 --> 00:11:29.446
structure as the objects move.

00:11:30.346 --> 00:11:31.346
So, let's see how to set this

00:11:31.346 --> 00:11:31.666
up.

00:11:32.566 --> 00:11:33.816
First, we'll create what's

00:11:33.816 --> 00:11:34.266
called an

00:11:34.266 --> 00:11:35.606
AccelerationStructureGroup.

00:11:36.386 --> 00:11:37.566
All the acceleration structures

00:11:37.566 --> 00:11:38.746
in the instance's hierarchy must

00:11:38.746 --> 00:11:39.796
belong to the same group.

00:11:39.796 --> 00:11:41.126
And this allows them to share

00:11:41.126 --> 00:11:42.166
resources internally.

00:11:42.786 --> 00:11:45.106
Next, we'll create an array to

00:11:45.106 --> 00:11:46.436
hold our triangle acceleration

00:11:46.436 --> 00:11:46.916
structures.

00:11:47.866 --> 00:11:49.206
Then finally, we'll loop over

00:11:49.206 --> 00:11:50.376
all the unique objects in the

00:11:50.376 --> 00:11:51.776
scene, building a triangle

00:11:51.776 --> 00:11:52.926
acceleration structure for each

00:11:52.926 --> 00:11:53.246
of them.

00:11:53.526 --> 00:11:55.496
Adding them to the array as we

00:11:56.896 --> 00:11:56.976
go.

00:11:57.216 --> 00:11:58.006
We're now ready to create the

00:11:58.006 --> 00:11:59.076
second level acceleration

00:11:59.076 --> 00:11:59.526
structure.

00:12:00.156 --> 00:12:02.006
We do this using the NPSInstance

00:12:02.006 --> 00:12:03.286
AccelerationStructure class.

00:12:04.266 --> 00:12:05.446
We'll start by attaching our

00:12:05.446 --> 00:12:06.746
array of triangle acceleration

00:12:06.746 --> 00:12:08.686
structures as well as the two

00:12:08.686 --> 00:12:09.606
buffers I talked about

00:12:09.606 --> 00:12:10.136
previously.

00:12:10.836 --> 00:12:12.146
Then finally, we'll specify the

00:12:12.146 --> 00:12:15.106
num of instances in the scene.

00:12:15.306 --> 00:12:16.916
Then, whenever the objects move

00:12:16.916 --> 00:12:18.086
or if an object is added or

00:12:18.086 --> 00:12:19.816
removed from the scene, we can

00:12:19.816 --> 00:12:21.256
simply rebuild just the instance

00:12:21.256 --> 00:12:22.256
acceleration structure.

00:12:23.246 --> 00:12:24.326
This acceleration structure is

00:12:24.326 --> 00:12:25.566
typically much smaller than a

00:12:25.566 --> 00:12:27.016
triangle acceleration structure,

00:12:27.336 --> 00:12:28.336
so we can afford to do this

00:12:28.336 --> 00:12:28.956
every frame.

00:12:29.236 --> 00:12:30.366
But note that similar to

00:12:30.366 --> 00:12:31.506
Refitting, there is some

00:12:31.506 --> 00:12:32.896
overhead when using instancing.

00:12:33.696 --> 00:12:34.776
So, if your scene only has one

00:12:34.776 --> 00:12:36.446
object or a handful of objects,

00:12:36.526 --> 00:12:37.496
or especially if none of the

00:12:37.496 --> 00:12:39.156
objects are moving, it might be

00:12:39.156 --> 00:12:40.446
worthwhile to pack those into a

00:12:40.446 --> 00:12:41.776
single triangle acceleration

00:12:41.776 --> 00:12:42.226
structure.

00:12:43.026 --> 00:12:43.966
This will increase your memory

00:12:44.016 --> 00:12:45.806
footprint, but it should gain

00:12:45.806 --> 00:12:46.856
back some of the performance.

00:12:47.226 --> 00:12:48.686
So, you need to experiment to

00:12:48.716 --> 00:12:49.806
find the right tradeoff for your

00:12:49.806 --> 00:12:50.286
application.

00:12:50.286 --> 00:12:53.386
So that's it for dynamic scenes.

00:12:53.826 --> 00:12:54.736
We talked about how to support

00:12:54.736 --> 00:12:56.146
Vertex Animation and Skinning

00:12:56.146 --> 00:12:57.006
using Refitting.

00:12:57.606 --> 00:12:58.816
As well as how to support Rigid

00:12:58.816 --> 00:13:00.306
Body Animation using a Two-Level

00:13:00.306 --> 00:13:01.276
Acceleration Structure.

00:13:02.196 --> 00:13:03.726
So next, let's switch gears and

00:13:03.726 --> 00:13:04.676
talk about Denoising.

00:13:05.306 --> 00:13:08.516
So far, all the images that we

00:13:08.516 --> 00:13:09.396
have seen have been free of

00:13:09.396 --> 00:13:09.766
noise.

00:13:10.326 --> 00:13:11.556
That's because they've all been

00:13:11.556 --> 00:13:12.786
using a denoising filter.

00:13:13.676 --> 00:13:14.966
If we turn it off, we could see

00:13:14.966 --> 00:13:15.896
what it would have looked like

00:13:15.896 --> 00:13:16.796
without the denoiser.

00:13:17.826 --> 00:13:19.036
We can see that these images are

00:13:19.036 --> 00:13:20.276
too noisy to use in a real

00:13:20.276 --> 00:13:20.986
application.

00:13:21.526 --> 00:13:22.576
That's because we're only using

00:13:22.576 --> 00:13:23.966
a handful of samples per pixel.

00:13:25.266 --> 00:13:26.516
Usually we would just solve this

00:13:26.516 --> 00:13:27.506
by averaging together more

00:13:27.506 --> 00:13:28.526
samples over time.

00:13:28.926 --> 00:13:30.236
But if the camera or objects are

00:13:30.236 --> 00:13:31.466
moving it's not quite that

00:13:31.466 --> 00:13:31.846
simple.

00:13:32.226 --> 00:13:34.236
Fortunately, Metal now includes

00:13:34.236 --> 00:13:35.506
a sophisticated Denoising

00:13:35.546 --> 00:13:35.936
filter.

00:13:36.726 --> 00:13:37.566
Let's see how this works.

00:13:37.676 --> 00:13:40.376
Ideally what we'd be able to do

00:13:40.376 --> 00:13:41.856
is simply take the noisy image

00:13:41.856 --> 00:13:43.556
output by a renderer, run it

00:13:43.556 --> 00:13:44.766
through a denoiser and get back

00:13:44.766 --> 00:13:45.506
a clean image.

00:13:46.236 --> 00:13:47.436
In practice, the denoiser needs

00:13:47.436 --> 00:13:48.736
a little more information about

00:13:48.736 --> 00:13:49.186
the scene.

00:13:50.296 --> 00:13:51.236
We'll start by providing the

00:13:51.236 --> 00:13:52.296
depths and normal for the

00:13:52.296 --> 00:13:53.616
directly visible geometry.

00:13:54.386 --> 00:13:55.586
Many renderers have these

00:13:55.586 --> 00:13:57.156
textures lying around, and if

00:13:57.156 --> 00:13:59.076
not, it's easy to produce them.

00:13:59.716 --> 00:14:00.946
The denoiser will then run a

00:14:00.946 --> 00:14:01.926
bunch of image processing

00:14:01.926 --> 00:14:03.326
operations and output a cleaner

00:14:03.326 --> 00:14:03.696
image.

00:14:04.336 --> 00:14:05.466
But since we started with just a

00:14:05.466 --> 00:14:06.846
handful of samples per pixel,

00:14:06.846 --> 00:14:07.926
the result will still have some

00:14:07.926 --> 00:14:08.196
noise.

00:14:08.936 --> 00:14:10.316
So, we'll revisit the idea of

00:14:10.316 --> 00:14:11.706
combining samples over multiple

00:14:11.706 --> 00:14:12.116
frames.

00:14:12.786 --> 00:14:14.646
So, we'll first set aside the

00:14:14.646 --> 00:14:16.246
clean image to reuse in the next

00:14:16.246 --> 00:14:16.566
frame.

00:14:17.726 --> 00:14:18.866
We'll also set aside the depth

00:14:18.866 --> 00:14:20.356
and normal so we can compare

00:14:20.356 --> 00:14:21.186
them to the next frame.

00:14:22.256 --> 00:14:23.336
Then finally, we'll provide a

00:14:23.336 --> 00:14:24.886
motion vector texture which

00:14:24.886 --> 00:14:26.266
describes how much each pixel

00:14:26.266 --> 00:14:27.476
has moved between frames.

00:14:28.116 --> 00:14:30.916
In the next frame, the denoiser

00:14:30.916 --> 00:14:32.126
will churn through all of these

00:14:32.126 --> 00:14:33.406
textures to produce an even

00:14:33.406 --> 00:14:34.136
better image.

00:14:34.706 --> 00:14:35.856
And this image will continue to

00:14:35.856 --> 00:14:37.506
get better over time even if the

00:14:37.506 --> 00:14:38.686
camera or objects move.

00:14:39.076 --> 00:14:41.156
The denoiser will use the depths

00:14:41.156 --> 00:14:43.116
and normal to detect cases where

00:14:43.116 --> 00:14:44.296
the history for a pixel has

00:14:44.296 --> 00:14:46.426
become invalid due to an object

00:14:46.426 --> 00:14:47.656
moving or getting in the way.

00:14:49.196 --> 00:14:50.056
So, this is all implemented

00:14:50.056 --> 00:14:51.946
using the MPSSVGF family of

00:14:51.986 --> 00:14:52.506
classes.

00:14:53.456 --> 00:14:54.756
This is an implementation of the

00:14:54.756 --> 00:14:56.246
popular MPSSVGF denoising

00:14:56.246 --> 00:14:56.716
algorithm.

00:14:57.356 --> 00:14:58.276
This algorithm makes a good

00:14:58.276 --> 00:14:59.536
tradeoff between high quality

00:14:59.536 --> 00:15:00.596
and real-time performance.

00:15:01.236 --> 00:15:03.146
So, the denoising process is all

00:15:03.146 --> 00:15:04.386
coordinated by the

00:15:04.386 --> 00:15:06.096
MPSSVGFDenoiser class.

00:15:07.206 --> 00:15:08.976
Meanwhile, low-level control is

00:15:08.976 --> 00:15:10.896
provided using the MPSSVGF

00:15:10.896 --> 00:15:11.316
class.

00:15:12.186 --> 00:15:12.996
This class provides the

00:15:12.996 --> 00:15:14.516
individual compute kernels used

00:15:14.516 --> 00:15:16.516
by the denoiser and exposes many

00:15:16.516 --> 00:15:17.726
parameters you can use to fine

00:15:17.726 --> 00:15:18.736
tune the Denoising in your

00:15:18.736 --> 00:15:19.236
application.

00:15:20.006 --> 00:15:21.026
And you also just call this

00:15:21.026 --> 00:15:22.306
classes' methods directly to

00:15:22.306 --> 00:15:23.526
build a customized denoiser.

00:15:24.126 --> 00:15:26.416
Now the denoiser creates and

00:15:26.416 --> 00:15:27.706
destroys quite a few temporary

00:15:27.706 --> 00:15:28.576
textures throughout the

00:15:28.576 --> 00:15:29.566
Denoising process.

00:15:30.246 --> 00:15:32.456
To the MPSSVGF texture allocator

00:15:32.456 --> 00:15:34.216
protocol serves as a cache for

00:15:34.216 --> 00:15:35.346
these memory allocations.

00:15:36.536 --> 00:15:37.646
You can either use the default

00:15:37.646 --> 00:15:39.416
implementation or implement this

00:15:39.416 --> 00:15:40.606
protocol yourself to share

00:15:40.606 --> 00:15:41.356
memory with your own

00:15:41.356 --> 00:15:41.966
application.

00:15:42.986 --> 00:15:44.376
So as usual, we've optimized

00:15:44.376 --> 00:15:45.666
these classes for all of our Mac

00:15:45.666 --> 00:15:46.646
and iOS devices.

00:15:47.536 --> 00:15:48.836
The denoiser can process two

00:15:48.836 --> 00:15:49.736
independent images

00:15:49.736 --> 00:15:50.576
simultaneously.

00:15:50.706 --> 00:15:51.966
For example, you might want to

00:15:51.966 --> 00:15:53.346
split your direct and indirect

00:15:53.346 --> 00:15:54.576
lighting terms into separate

00:15:54.576 --> 00:15:55.066
textures.

00:15:56.036 --> 00:15:57.166
There's also a fast path for

00:15:57.166 --> 00:15:58.756
single channel textures such as

00:15:58.756 --> 00:15:59.946
Ambient Occlusion or shadow

00:15:59.946 --> 00:16:01.456
textures, which is faster than

00:16:01.456 --> 00:16:03.146
Denoising a full RBG image.

00:16:04.276 --> 00:16:06.706
Let's see how to set this up.

00:16:06.706 --> 00:16:08.016
So first we'll create the

00:16:08.096 --> 00:16:09.996
MPSSVGF object and configure its

00:16:10.036 --> 00:16:10.516
properties.

00:16:11.136 --> 00:16:12.106
All we need to provide is the

00:16:12.106 --> 00:16:13.366
Metal device we want to use for

00:16:13.366 --> 00:16:13.946
Denoising.

00:16:14.416 --> 00:16:16.146
Next, we'll create the

00:16:16.146 --> 00:16:16.996
TextureAllocator.

00:16:17.276 --> 00:16:18.296
In this case we'll just use the

00:16:18.296 --> 00:16:19.446
default implementation.

00:16:20.616 --> 00:16:21.716
Then finally, we'll create the

00:16:21.716 --> 00:16:23.256
high level Denoiser object which

00:16:23.256 --> 00:16:24.216
will manage the denoising

00:16:24.246 --> 00:16:24.696
process.

00:16:26.146 --> 00:16:27.086
So now we're ready to do some

00:16:27.086 --> 00:16:27.636
denoising.

00:16:28.156 --> 00:16:29.406
We'll start by attaching all of

00:16:29.406 --> 00:16:30.446
the input textures to the

00:16:30.446 --> 00:16:30.896
Denoiser.

00:16:31.546 --> 00:16:32.866
Now we simply encode the entire

00:16:32.866 --> 00:16:34.366
denoising process to a Metal

00:16:34.366 --> 00:16:34.996
commandBuffer.

00:16:35.876 --> 00:16:37.146
And finally, we can retrieve the

00:16:37.146 --> 00:16:38.516
clean image from the denoiser.

00:16:39.106 --> 00:16:40.416
And that's all you need to do to

00:16:40.416 --> 00:16:41.306
enable denoising your

00:16:41.306 --> 00:16:41.926
applications.

00:16:42.646 --> 00:16:45.086
So, we now talked about all of

00:16:45.086 --> 00:16:46.136
the basic building blocks

00:16:46.136 --> 00:16:47.246
available in Metal for Ray

00:16:47.246 --> 00:16:48.416
Tracing and Denoising.

00:16:48.646 --> 00:16:50.186
We reviewed how to do basic

00:16:50.186 --> 00:16:52.476
ray/triangle intersection using

00:16:52.526 --> 00:16:53.826
the MPS Ray Intersector API.

00:16:54.996 --> 00:16:55.816
We then talked about how to

00:16:55.816 --> 00:16:57.196
extend this to dynamic scenes

00:16:57.196 --> 00:16:58.866
using Refitting and Two-Level

00:16:58.866 --> 00:16:59.886
Acceleration Structures.

00:17:00.876 --> 00:17:02.156
And finally, we talked about how

00:17:02.156 --> 00:17:03.376
to remove the noise from your

00:17:03.376 --> 00:17:04.856
images using the MPSSVGF

00:17:04.945 --> 00:17:05.376
classes.

00:17:05.376 --> 00:17:07.406
Now, don't worry if this is all

00:17:07.406 --> 00:17:09.096
a little bit overwhelming.

00:17:09.396 --> 00:17:10.576
We've written a sample, which

00:17:10.576 --> 00:17:11.695
demonstrates how to use all of

00:17:11.695 --> 00:17:12.656
these concepts which is

00:17:12.656 --> 00:17:13.566
available online.

00:17:14.146 --> 00:17:16.316
Now, I mentioned earlier that we

00:17:16.316 --> 00:17:17.116
need to be careful with

00:17:17.116 --> 00:17:17.715
performance.

00:17:17.715 --> 00:17:18.705
Especially in a real-time

00:17:18.705 --> 00:17:19.086
setting.

00:17:19.626 --> 00:17:20.536
So next, I'd like to bring out

00:17:20.536 --> 00:17:22.036
my colleague Wayne who will talk

00:17:22.036 --> 00:17:22.996
about how to make all of this

00:17:22.996 --> 00:17:24.796
work on real devices with real

00:17:24.796 --> 00:17:25.576
performance budgets.

00:17:27.516 --> 00:17:31.636
[ Applause ]

00:17:32.136 --> 00:17:32.556
>> Hi everyone.

00:17:33.106 --> 00:17:34.596
Now, what I'd like to show you

00:17:34.596 --> 00:17:36.556
in this part of the talk is how

00:17:36.596 --> 00:17:38.416
to use the Ray Tracing features

00:17:38.416 --> 00:17:40.006
that we have in Metal to

00:17:40.006 --> 00:17:41.126
implement a few different

00:17:41.126 --> 00:17:42.486
rendering techniques in your

00:17:42.486 --> 00:17:43.266
applications.

00:17:43.746 --> 00:17:45.316
So, in particular, I'll be

00:17:45.316 --> 00:17:46.506
focusing on hard and soft

00:17:46.506 --> 00:17:48.566
shadows, Ambient Occlusion, and

00:17:48.696 --> 00:17:49.756
global illumination.

00:17:49.896 --> 00:17:52.176
So, let's start with hard

00:17:52.176 --> 00:17:52.656
shadows.

00:17:52.656 --> 00:17:54.956
Now, the way that we model this

00:17:54.956 --> 00:17:56.516
with Ray Tracing is to take

00:17:56.516 --> 00:17:58.366
points on our surface and fire

00:17:58.366 --> 00:17:59.566
rays up in the direction of the

00:17:59.566 --> 00:17:59.806
sun.

00:18:00.616 --> 00:18:02.616
If a ray hits something, then

00:18:02.616 --> 00:18:03.816
the associated point is in

00:18:03.816 --> 00:18:04.126
shadow.

00:18:04.776 --> 00:18:06.266
Otherwise, it's in sunlight.

00:18:07.476 --> 00:18:10.066
Now, to incorporate this into an

00:18:10.066 --> 00:18:11.946
existing application, I'm going

00:18:11.946 --> 00:18:12.896
to assume that you're starting

00:18:12.896 --> 00:18:15.106
with something a bit like this.

00:18:15.106 --> 00:18:16.986
You've rasterized a G-Buffer and

00:18:16.986 --> 00:18:17.896
run a compute pass for your

00:18:17.896 --> 00:18:18.286
lighting.

00:18:18.466 --> 00:18:19.936
And the output of that is your

00:18:19.936 --> 00:18:21.106
final shaded image.

00:18:21.856 --> 00:18:24.036
Now, to take advantage of Ray

00:18:24.036 --> 00:18:25.516
Tracing here we'll start by

00:18:25.516 --> 00:18:27.416
taking the G-Buffer and then run

00:18:27.416 --> 00:18:28.826
a compute shader to generate

00:18:28.826 --> 00:18:29.226
some rays.

00:18:30.836 --> 00:18:31.836
We'll then pass those rays to

00:18:31.836 --> 00:18:33.256
Metal to intersect with an

00:18:33.256 --> 00:18:34.256
acceleration structure.

00:18:34.956 --> 00:18:35.906
And Metal will output the

00:18:35.906 --> 00:18:37.076
results to an intersection

00:18:37.076 --> 00:18:37.356
buffer.

00:18:38.786 --> 00:18:40.026
You can now use this buffer in

00:18:40.026 --> 00:18:41.356
your shading kernel to decide

00:18:41.356 --> 00:18:42.336
whether your surface points are

00:18:42.336 --> 00:18:42.816
in shadow.

00:18:43.446 --> 00:18:46.066
Now the main part I'd like us to

00:18:46.066 --> 00:18:47.776
focus on here is Ray Generation.

00:18:48.626 --> 00:18:49.916
So, let's start with a quick

00:18:49.916 --> 00:18:51.196
reminder of how rays are

00:18:51.196 --> 00:18:52.006
described in Metal.

00:18:54.256 --> 00:18:55.606
So, Metal provides a few

00:18:55.606 --> 00:18:56.616
different ray structures for you

00:18:56.616 --> 00:18:58.456
to use, and at a minimum these

00:18:58.456 --> 00:18:59.676
contain fields for your ray

00:18:59.676 --> 00:19:01.406
origin and your ray direction.

00:19:02.496 --> 00:19:03.596
So just fill out one of these

00:19:03.596 --> 00:19:04.986
structures for each ray that you

00:19:04.986 --> 00:19:06.566
want to trace and write it out

00:19:06.566 --> 00:19:09.346
to your ray buffer.

00:19:09.926 --> 00:19:10.896
Now, the way in which you

00:19:10.896 --> 00:19:12.176
arrange your rays in your ray

00:19:12.176 --> 00:19:13.926
buffer, that has a performance

00:19:13.926 --> 00:19:14.326
impact.

00:19:15.436 --> 00:19:16.446
So, often you might start like

00:19:16.446 --> 00:19:16.876
this.

00:19:17.166 --> 00:19:18.506
We call this row linear order.

00:19:19.246 --> 00:19:22.326
Now, the problem here is that as

00:19:22.326 --> 00:19:23.506
Metal works its way through

00:19:23.506 --> 00:19:25.336
these rays, they tend to hit

00:19:25.336 --> 00:19:26.556
very different nodes in the

00:19:26.556 --> 00:19:28.166
internal data structures that

00:19:28.166 --> 00:19:29.586
Metal uses to accelerate ray

00:19:29.586 --> 00:19:30.126
traversal.

00:19:30.606 --> 00:19:32.646
Now this in turn can flash the

00:19:32.646 --> 00:19:33.816
underlying hardware caches.

00:19:33.816 --> 00:19:37.116
So, a better approach is to use

00:19:37.116 --> 00:19:38.386
block linear ordering.

00:19:39.646 --> 00:19:40.946
So, rays from nearby pixels on

00:19:40.946 --> 00:19:42.336
the screen, they tend to hit the

00:19:42.336 --> 00:19:43.606
same parts of your acceleration

00:19:43.606 --> 00:19:45.626
structure, and so by storing

00:19:45.626 --> 00:19:47.136
your rays like this it enables

00:19:47.136 --> 00:19:48.536
Metal to drive the hardware much

00:19:48.536 --> 00:19:49.246
more efficiently.

00:19:49.616 --> 00:19:52.226
Now, in the visualization here,

00:19:52.226 --> 00:19:53.826
I'm showing you a block size of

00:19:53.886 --> 00:19:54.716
4 by 4.

00:19:55.056 --> 00:19:56.446
In practice we found that 8 by 8

00:19:56.446 --> 00:19:58.026
works really, really well.

00:19:59.796 --> 00:20:01.526
So, optimizing your ray storage

00:20:01.526 --> 00:20:02.796
is a great way to improve

00:20:02.796 --> 00:20:03.686
performance.

00:20:03.776 --> 00:20:05.216
But where possible, an even

00:20:05.216 --> 00:20:06.836
better way is just not to fire

00:20:06.836 --> 00:20:07.336
rays at all.

00:20:07.336 --> 00:20:10.246
Now, in the context of shadows,

00:20:10.246 --> 00:20:11.826
the reason that you might want

00:20:11.826 --> 00:20:13.386
to do this is because not all

00:20:13.386 --> 00:20:14.646
pixels need a shadow ray.

00:20:14.986 --> 00:20:16.786
For example, pixels on your

00:20:16.786 --> 00:20:18.656
background, on your skybox, or

00:20:18.656 --> 00:20:19.976
on surfaces that are facing away

00:20:19.976 --> 00:20:22.876
from the sun.

00:20:23.056 --> 00:20:24.056
Now, it's likely that your ray

00:20:24.056 --> 00:20:25.716
buffer contains a ray structure

00:20:25.986 --> 00:20:27.416
for each pixel on the screen.

00:20:27.676 --> 00:20:29.496
So, what we need here is a way

00:20:29.496 --> 00:20:31.156
to tell Metal to skip firing

00:20:31.156 --> 00:20:32.616
ways for the pixels that we just

00:20:32.616 --> 00:20:33.866
don't care about.

00:20:34.456 --> 00:20:35.696
Now, there's a few ways to do

00:20:35.696 --> 00:20:36.076
this.

00:20:36.076 --> 00:20:37.316
The approach I'm showing you

00:20:37.316 --> 00:20:38.656
here is simply to set the

00:20:38.656 --> 00:20:39.966
maxDistance field in your ray

00:20:39.966 --> 00:20:41.776
structure to a negative value.

00:20:42.346 --> 00:20:45.146
And that's the main things you

00:20:45.146 --> 00:20:46.446
need to know for Hard Shadows.

00:20:47.506 --> 00:20:48.636
As you can see, Ray Tracing

00:20:48.636 --> 00:20:50.036
gives really great results.

00:20:50.106 --> 00:20:51.376
The shadows are very crisp and

00:20:51.376 --> 00:20:52.346
they're very precise.

00:20:53.386 --> 00:20:56.316
But in reality, shadows cast by

00:20:56.316 --> 00:20:58.636
the sun, they tend not to look

00:20:58.636 --> 00:20:59.196
that sharp.

00:20:59.976 --> 00:21:00.736
they look more like this.

00:21:01.726 --> 00:21:02.916
They're soft around the edges

00:21:03.156 --> 00:21:04.276
and that softness varies with

00:21:04.276 --> 00:21:04.926
distance.

00:21:05.686 --> 00:21:07.316
And you can see a great example

00:21:07.316 --> 00:21:08.436
of this on the left there.

00:21:09.356 --> 00:21:10.446
the shadow from the lamp post

00:21:10.446 --> 00:21:11.896
starts off hard at the base and

00:21:11.896 --> 00:21:13.356
it softens as the distance to

00:21:13.356 --> 00:21:14.176
the ground increases.

00:21:14.846 --> 00:21:17.116
So, to model that with Ray

00:21:17.116 --> 00:21:18.776
Tracing, instead of using the

00:21:18.776 --> 00:21:19.966
parallel rays that I was showing

00:21:19.966 --> 00:21:21.556
you earlier, we'll instead

00:21:21.726 --> 00:21:23.056
extend the cone from our surface

00:21:23.126 --> 00:21:24.596
point all the way up to the sun.

00:21:25.506 --> 00:21:27.176
And then, we'll generate some

00:21:27.176 --> 00:21:28.666
ray directions randomly within

00:21:29.606 --> 00:21:31.066
this cone.

00:21:31.286 --> 00:21:32.446
Now you can see there that some

00:21:32.446 --> 00:21:34.096
rays intersect geometry and some

00:21:34.156 --> 00:21:34.396
don't.

00:21:34.396 --> 00:21:36.356
And it's this ratio that

00:21:36.356 --> 00:21:37.506
controls the softness of your

00:21:37.506 --> 00:21:38.136
shadow.

00:21:38.866 --> 00:21:41.186
So, here's what that looks like.

00:21:42.066 --> 00:21:44.496
What I'm showing you here is the

00:21:44.496 --> 00:21:46.556
raw direct lighting term ray

00:21:46.556 --> 00:21:48.006
traced with one ray per pixel.

00:21:49.006 --> 00:21:50.386
So, in this image, all other

00:21:50.386 --> 00:21:52.716
effects such as reflections and

00:21:52.716 --> 00:21:54.616
global illumination, they're all

00:21:54.616 --> 00:21:56.216
disabled so we can focus purely

00:21:56.216 --> 00:21:56.726
on the shadow.

00:21:57.876 --> 00:22:00.096
And as you can see, the result

00:22:00.096 --> 00:22:01.406
is really quite noisy.

00:22:02.086 --> 00:22:04.856
Now, to deal with that, we could

00:22:04.856 --> 00:22:06.086
just keep firing more and more

00:22:06.086 --> 00:22:06.346
rays.

00:22:06.756 --> 00:22:08.086
But since that's something we're

00:22:08.086 --> 00:22:09.486
really trying to avoid in a real

00:22:09.486 --> 00:22:11.706
time application, what we can do

00:22:11.706 --> 00:22:13.786
instead is use the Denoiser that

00:22:13.786 --> 00:22:14.706
Sean was telling us about

00:22:14.706 --> 00:22:14.926
earlier.

00:22:15.606 --> 00:22:19.266
And here's the results of that.

00:22:19.346 --> 00:22:20.376
Most of the noise is filtered

00:22:20.376 --> 00:22:21.796
away and we get these great

00:22:21.796 --> 00:22:23.166
looking soft shadows with just

00:22:23.166 --> 00:22:24.066
one ray per pixel.

00:22:24.956 --> 00:22:26.666
And I'll be showing you this in

00:22:26.666 --> 00:22:28.226
action in our live demo later

00:22:28.226 --> 00:22:28.426
on.

00:22:29.026 --> 00:22:33.466
So now let's talk about Ambient

00:22:33.466 --> 00:22:33.956
Occlusion.

00:22:34.606 --> 00:22:37.016
So essentially, this is an

00:22:37.016 --> 00:22:38.346
approximation of how much

00:22:38.406 --> 00:22:39.776
ambient light is able to reach

00:22:39.776 --> 00:22:40.446
the surface.

00:22:41.306 --> 00:22:42.946
And as you saw in our AR Quick

00:22:42.946 --> 00:22:44.506
Look demo earlier, it's a really

00:22:44.506 --> 00:22:45.716
great technique for grounding

00:22:45.716 --> 00:22:47.266
objects in their environments.

00:22:48.596 --> 00:22:50.176
So, let's visualize how this

00:22:50.176 --> 00:22:51.126
works with Ray Tracing.

00:22:52.066 --> 00:22:53.866
We have a surface point in the

00:22:53.866 --> 00:22:54.736
middle of the screen there and

00:22:55.556 --> 00:22:57.206
there's a blue block over on the

00:22:57.206 --> 00:22:58.216
right that's going to play the

00:22:58.216 --> 00:22:59.146
role of our occluder.

00:23:00.676 --> 00:23:01.686
We define an imaginary

00:23:01.686 --> 00:23:03.176
hemisphere around our surface

00:23:03.216 --> 00:23:04.916
points and then we fire some

00:23:04.916 --> 00:23:05.136
rays.

00:23:05.836 --> 00:23:09.106
If a ray hits something, and we

00:23:09.106 --> 00:23:10.426
found that object is blocking

00:23:10.426 --> 00:23:11.616
ambient light from reaching the

00:23:11.726 --> 00:23:11.886
surface.

00:23:14.376 --> 00:23:15.866
Now, as I've mentioned a couple

00:23:15.866 --> 00:23:17.356
of times now, in a real time

00:23:17.356 --> 00:23:18.826
application, we're really trying

00:23:18.826 --> 00:23:20.186
to limit ourselves to just one

00:23:20.186 --> 00:23:21.156
or two rays per pixel.

00:23:22.136 --> 00:23:23.616
So, we need to use these rays as

00:23:23.616 --> 00:23:26.616
efficiently as we can.

00:23:26.646 --> 00:23:28.236
Now, one of the ways to do this

00:23:28.236 --> 00:23:29.246
is importance sampling.

00:23:29.846 --> 00:23:31.446
And the general idea here is to

00:23:31.446 --> 00:23:33.286
fire rays in the directions

00:23:33.286 --> 00:23:34.036
where we expect they'll

00:23:34.036 --> 00:23:35.626
contribute most to our final

00:23:35.626 --> 00:23:36.066
image.

00:23:36.666 --> 00:23:39.536
Now with Ambient Occlusion the

00:23:39.536 --> 00:23:40.836
most important rays are the ones

00:23:40.836 --> 00:23:41.826
closer to the normal.

00:23:43.026 --> 00:23:44.676
So instead of firing rays evenly

00:23:44.676 --> 00:23:45.776
in a hemisphere like you see

00:23:45.776 --> 00:23:47.216
here, we instead use cosine

00:23:47.216 --> 00:23:47.946
sampling.

00:23:48.546 --> 00:23:51.196
Now, this distributes fewer rays

00:23:51.196 --> 00:23:52.656
around the horizons and more

00:23:52.656 --> 00:23:53.876
rays around the surface normal.

00:23:54.256 --> 00:23:54.786
And that's great.

00:23:54.786 --> 00:23:56.766
That's exactly where we need

00:23:58.836 --> 00:23:58.946
them.

00:23:59.156 --> 00:24:00.536
Now in addition to this angular

00:24:00.536 --> 00:24:02.626
falloff, Ambient Occlusion also

00:24:02.626 --> 00:24:03.666
has a distance term.

00:24:04.326 --> 00:24:05.576
So, objects close to the

00:24:05.576 --> 00:24:06.786
surface, they tend to block the

00:24:06.786 --> 00:24:07.196
most light.

00:24:07.196 --> 00:24:09.226
And there's usually a fall off

00:24:09.226 --> 00:24:10.286
function in there too,

00:24:10.286 --> 00:24:11.536
proportional to the square of

00:24:11.536 --> 00:24:12.226
distance.

00:24:13.876 --> 00:24:15.376
Now, interesting thing we can do

00:24:15.376 --> 00:24:16.976
here is bake that fall off

00:24:16.976 --> 00:24:18.336
function right into the ray

00:24:18.336 --> 00:24:19.476
distribution itself.

00:24:20.316 --> 00:24:21.736
And the way we do this is by

00:24:21.846 --> 00:24:22.936
firing rays of different

00:24:23.856 --> 00:24:24.036
lengths.

00:24:25.076 --> 00:24:26.676
So, as you can see here, because

00:24:26.676 --> 00:24:28.446
of that distance squared fall

00:24:28.446 --> 00:24:29.376
off function I was telling you

00:24:29.376 --> 00:24:31.426
about, the majority of rays end

00:24:31.426 --> 00:24:32.256
up being quite short.

00:24:32.256 --> 00:24:33.956
Now this is great for

00:24:33.956 --> 00:24:34.656
performance.

00:24:34.726 --> 00:24:36.366
Short rays are much easier for

00:24:36.366 --> 00:24:37.366
Metal to trace through the

00:24:37.366 --> 00:24:38.366
acceleration structures.

00:24:38.986 --> 00:24:43.386
So, a couple of times now, I've

00:24:43.386 --> 00:24:45.186
talked about generating rays in

00:24:45.186 --> 00:24:46.666
various shapes and various

00:24:46.666 --> 00:24:48.596
distributions, such as the cones

00:24:48.596 --> 00:24:49.826
we were using for Soft Shadows

00:24:50.006 --> 00:24:51.186
and the hemisphere's that we're

00:24:51.186 --> 00:24:52.366
using for Ambient Occlusion.

00:24:52.966 --> 00:24:55.606
Now, the way that this works in

00:24:55.606 --> 00:24:57.366
practice is we begin by

00:24:57.396 --> 00:24:58.866
generating points in 2D

00:24:58.866 --> 00:25:00.556
parameter space and then we map

00:25:00.716 --> 00:25:02.206
that space with whichever ray

00:25:02.206 --> 00:25:03.516
distribution you want to use.

00:25:04.106 --> 00:25:06.826
Now the position of these points

00:25:06.826 --> 00:25:08.426
in parameter space can have a

00:25:08.426 --> 00:25:09.796
big effect on image quality.

00:25:11.206 --> 00:25:12.856
If you choose them randomly, you

00:25:12.856 --> 00:25:14.056
tend to end up with regions

00:25:14.056 --> 00:25:15.076
where sample points clump

00:25:15.076 --> 00:25:15.366
together.

00:25:15.366 --> 00:25:18.896
Now this causes us to fire rays

00:25:18.896 --> 00:25:19.896
in pretty much the same

00:25:19.896 --> 00:25:21.296
direction and that's just

00:25:21.296 --> 00:25:21.926
wasting rays.

00:25:22.576 --> 00:25:26.536
You can also get areas without

00:25:26.536 --> 00:25:27.606
any sample points at all.

00:25:28.106 --> 00:25:30.226
Now this impacts image quality

00:25:30.226 --> 00:25:31.346
because we're undersampling the

00:25:31.346 --> 00:25:32.266
scene in these areas.

00:25:32.946 --> 00:25:35.336
So, a better approach to

00:25:35.336 --> 00:25:37.046
generate sample points is to use

00:25:37.046 --> 00:25:37.846
something called a low

00:25:37.846 --> 00:25:39.206
discrepancy sequence.

00:25:39.906 --> 00:25:40.726
So, the one I'm showing you up

00:25:40.756 --> 00:25:41.986
on the screen here is the Halton

00:25:41.986 --> 00:25:43.286
2,3 sequence.

00:25:44.756 --> 00:25:46.206
You can see that sample points

00:25:46.206 --> 00:25:47.406
generated in this way, they

00:25:47.556 --> 00:25:49.446
cover the space far more evenly

00:25:49.446 --> 00:25:50.746
and we vanish the void by

00:25:50.896 --> 00:25:52.436
plumping and undersampling.

00:25:53.046 --> 00:25:57.856
So that's how to generate good

00:25:57.856 --> 00:25:59.406
rays for a single pixel.

00:26:00.036 --> 00:26:01.216
And what we need to do now is

00:26:01.316 --> 00:26:02.936
scale that to generate good rays

00:26:02.936 --> 00:26:04.406
for all pixels on the screen.

00:26:04.496 --> 00:26:06.846
Now, the way that we're doing

00:26:06.846 --> 00:26:08.586
this is by taking one of those

00:26:08.586 --> 00:26:10.336
low discrepancy sample points I

00:26:10.336 --> 00:26:12.206
was just showing you and then we

00:26:12.206 --> 00:26:13.726
apply a random delta for each

00:26:13.726 --> 00:26:14.106
pixel.

00:26:14.726 --> 00:26:18.426
Now, the effect of that is that

00:26:18.466 --> 00:26:20.396
each pixel still runs through a

00:26:20.396 --> 00:26:22.556
low discrepancy sequence, but

00:26:22.556 --> 00:26:23.676
the exact positions of the

00:26:23.676 --> 00:26:25.326
sample points are offset from

00:26:25.326 --> 00:26:26.176
neighboring pixels on the

00:26:26.176 --> 00:26:26.726
screen.

00:26:27.206 --> 00:26:29.826
Now, there's a couple of

00:26:29.826 --> 00:26:31.116
different ways to generate these

00:26:31.116 --> 00:26:31.706
deltas.

00:26:32.646 --> 00:26:34.826
One way is just to sample an RG

00:26:34.826 --> 00:26:36.856
texture full of random numbers.

00:26:37.386 --> 00:26:40.026
What we saw previously that

00:26:40.026 --> 00:26:41.446
random numbers aren't always a

00:26:41.446 --> 00:26:42.796
great choice for Ray Tracing.

00:26:43.376 --> 00:26:44.796
And an alternative that works

00:26:44.856 --> 00:26:45.836
really well for Ambient

00:26:45.836 --> 00:26:47.266
Occlusion is blue noise.

00:26:47.376 --> 00:26:49.966
So, you can see on the right

00:26:50.026 --> 00:26:51.906
there that the randomness is the

00:26:51.906 --> 00:26:53.366
blue noise texture, it's

00:26:53.396 --> 00:26:55.436
distributed far more evenly and

00:26:55.576 --> 00:26:56.936
that's great for image quality.

00:26:56.936 --> 00:26:58.726
Particularly when we're limited

00:26:58.836 --> 00:26:59.856
to just a couple of rays per

00:26:59.856 --> 00:27:00.096
pixel.

00:27:00.096 --> 00:27:03.886
So, let's look at the effect of

00:27:03.886 --> 00:27:05.416
all of this on the Ambient

00:27:05.416 --> 00:27:06.396
Occlusion result that we were

00:27:06.396 --> 00:27:07.136
trying to generate.

00:27:07.886 --> 00:27:09.896
So, here's what we started with.

00:27:11.036 --> 00:27:12.066
This is using hemisphere

00:27:12.066 --> 00:27:14.186
sampling and random deltas for

00:27:14.186 --> 00:27:14.786
all pixels.

00:27:15.396 --> 00:27:18.546
And this is what we get with

00:27:18.546 --> 00:27:20.196
cosine sampling and the blue

00:27:20.196 --> 00:27:21.136
noise that I was telling you

00:27:21.136 --> 00:27:21.446
about.

00:27:21.446 --> 00:27:23.506
So, I'll flip between these

00:27:23.506 --> 00:27:24.396
images so you can see.

00:27:25.816 --> 00:27:27.146
Now, both of these images are

00:27:27.146 --> 00:27:28.846
generated using just two rays

00:27:28.846 --> 00:27:29.346
per pixel.

00:27:29.406 --> 00:27:31.896
But you can see by being

00:27:31.946 --> 00:27:33.576
selective about how we use those

00:27:33.576 --> 00:27:35.836
rays, the amount of noise is

00:27:35.836 --> 00:27:37.246
significantly reduced.

00:27:37.246 --> 00:27:38.396
And we've managed to capture

00:27:38.396 --> 00:27:39.856
much more of the fine surface

00:27:39.856 --> 00:27:40.266
detail.

00:27:40.856 --> 00:27:43.456
And if we were to keep firing

00:27:43.456 --> 00:27:45.316
rays, eventually the two

00:27:45.316 --> 00:27:46.516
approaches would converge on

00:27:46.516 --> 00:27:47.746
exactly the same image.

00:27:48.136 --> 00:27:49.846
But using importance sampling

00:27:49.846 --> 00:27:51.616
gets us there much faster.

00:27:53.516 --> 00:27:55.386
So that's Shadows and Ambient

00:27:55.386 --> 00:27:55.846
Occlusion.

00:27:56.386 --> 00:27:58.046
And for these effects we were

00:27:58.046 --> 00:27:59.636
really only interested in

00:27:59.636 --> 00:28:00.916
whether our rays hit something

00:28:00.916 --> 00:28:01.976
or whether they missed.

00:28:02.826 --> 00:28:04.866
Now, for many of the other

00:28:04.866 --> 00:28:06.036
effects that we typically

00:28:06.036 --> 00:28:07.756
associate with Ray Tracing, such

00:28:07.756 --> 00:28:09.766
as Global Illumination, you need

00:28:09.766 --> 00:28:10.676
to model your rays as they

00:28:10.676 --> 00:28:11.856
bounce around the scene.

00:28:11.856 --> 00:28:13.896
And to talk some more about that

00:28:13.896 --> 00:28:14.876
I'll invite up my colleague

00:28:14.876 --> 00:28:14.976
Matt.

00:28:16.516 --> 00:28:23.346
[ Applause ]

00:28:23.846 --> 00:28:25.916
>> Thanks Wayne.

00:28:26.456 --> 00:28:28.846
So, we're going to cover a few

00:28:28.846 --> 00:28:30.336
topics in this section, starting

00:28:30.336 --> 00:28:31.486
with a brief overview of Global

00:28:31.486 --> 00:28:32.046
Illumination.

00:28:32.546 --> 00:28:34.126
Then, we'll go into some best

00:28:34.126 --> 00:28:35.306
practices for memory and ray

00:28:35.306 --> 00:28:35.796
management.

00:28:36.426 --> 00:28:38.036
Finally, we'll cover some

00:28:38.036 --> 00:28:39.206
strategies for debugging your

00:28:39.206 --> 00:28:40.186
Ray Tracing application.

00:28:41.486 --> 00:28:43.256
So, what is Global Illumination?

00:28:44.866 --> 00:28:46.056
Conceptually it's pretty simple.

00:28:46.626 --> 00:28:47.876
Light enters the scene and

00:28:47.876 --> 00:28:48.786
directly illuminates the

00:28:48.786 --> 00:28:49.926
surfaces that it hits.

00:28:50.646 --> 00:28:51.846
And rasterization, that's

00:28:51.876 --> 00:28:52.546
typically the end of the

00:28:52.546 --> 00:28:53.476
rendering process.

00:28:53.866 --> 00:28:55.066
But in the real world, those

00:28:55.066 --> 00:28:56.416
objects absorb some of the light

00:28:56.416 --> 00:28:58.026
and then the rays bounce off and

00:28:58.026 --> 00:28:59.196
keep traveling around the scene.

00:28:59.686 --> 00:29:00.896
And as they bounce around, some

00:29:00.896 --> 00:29:01.926
interesting visual effects

00:29:01.926 --> 00:29:02.366
emerge.

00:29:03.656 --> 00:29:05.986
After light has bounced once we

00:29:05.986 --> 00:29:06.876
start to see specular

00:29:06.876 --> 00:29:07.786
reflections on the mirrored

00:29:07.786 --> 00:29:09.456
surfaces like the ball and wall

00:29:09.456 --> 00:29:09.896
to the right.

00:29:10.446 --> 00:29:12.916
You can also see that objects

00:29:12.916 --> 00:29:14.166
and shadows get brighter as they

00:29:14.166 --> 00:29:14.916
pick up light that's been

00:29:14.916 --> 00:29:16.366
reflected off nearby surfaces.

00:29:16.886 --> 00:29:19.406
After the light has bounced

00:29:19.406 --> 00:29:20.286
twice, we start to see

00:29:20.286 --> 00:29:21.476
reflections between mirrored

00:29:21.476 --> 00:29:23.906
surfaces and eventually, some

00:29:23.906 --> 00:29:25.176
rays have refracted all the way

00:29:25.176 --> 00:29:26.946
through transparent objects, and

00:29:26.946 --> 00:29:27.816
they're showing the surfaces

00:29:27.816 --> 00:29:29.206
behind them giving us the glass

00:29:29.206 --> 00:29:30.136
effect of the box.

00:29:30.726 --> 00:29:32.956
Now, if we tried to model all

00:29:32.956 --> 00:29:33.766
the light bouncing around the

00:29:33.766 --> 00:29:35.746
scene only a small portion of it

00:29:35.746 --> 00:29:36.946
would actually make it back to

00:29:36.946 --> 00:29:38.066
the camera and that would be

00:29:38.066 --> 00:29:38.706
pretty inefficient.

00:29:38.986 --> 00:29:41.296
So instead, we'll work backwards

00:29:41.446 --> 00:29:42.576
from the camera towards the

00:29:42.576 --> 00:29:43.446
light source.

00:29:44.376 --> 00:29:46.236
We cast rays from the camera

00:29:46.236 --> 00:29:47.606
towards the pixels in our image.

00:29:49.386 --> 00:29:51.316
The intersection points of those

00:29:51.316 --> 00:29:52.666
rays tell us what objects are

00:29:52.666 --> 00:29:53.036
visible.

00:29:53.036 --> 00:29:54.376
But we'll need to figure out how

00:29:54.376 --> 00:29:55.516
much light is reaching them in

00:29:55.516 --> 00:29:56.416
order to figure out what their

00:29:56.416 --> 00:29:57.666
color in the final image should

00:29:57.666 --> 00:29:57.956
be.

00:29:59.036 --> 00:30:00.396
Earlier, Wayne described how to

00:30:00.396 --> 00:30:02.296
calculate soft shadows and here

00:30:02.296 --> 00:30:03.156
we're going to be performing

00:30:03.156 --> 00:30:04.616
exactly the same process.

00:30:05.956 --> 00:30:07.136
We cast shadow rays from the

00:30:07.136 --> 00:30:08.546
intersection points towards the

00:30:08.546 --> 00:30:09.826
lights in the scene in order to

00:30:09.826 --> 00:30:10.946
approximate how much light's

00:30:10.946 --> 00:30:11.366
reaching them.

00:30:12.606 --> 00:30:13.496
That's used as the light

00:30:13.496 --> 00:30:14.706
contribution towards the final

00:30:14.706 --> 00:30:15.026
image.

00:30:15.526 --> 00:30:19.336
Next, from the intersection

00:30:19.336 --> 00:30:21.166
points we cast secondary rays in

00:30:21.166 --> 00:30:22.136
random directions.

00:30:22.676 --> 00:30:24.226
We use Metal to figure out what

00:30:24.306 --> 00:30:25.706
those rays hit and then cast

00:30:25.706 --> 00:30:26.866
shadow rays to determine their

00:30:26.866 --> 00:30:28.216
direct lighting and then use

00:30:28.216 --> 00:30:29.396
that to add light to the final

00:30:29.396 --> 00:30:29.726
image.

00:30:30.366 --> 00:30:31.816
By repeating this process, we

00:30:31.816 --> 00:30:32.866
can simulate light bouncing

00:30:32.866 --> 00:30:34.056
around the room.

00:30:34.486 --> 00:30:35.856
We described this extensively in

00:30:35.856 --> 00:30:37.126
last year's talk, so I'll refer

00:30:37.126 --> 00:30:38.206
you to that for more details on

00:30:38.206 --> 00:30:39.476
how to go through this process.

00:30:39.996 --> 00:30:42.586
Our pipeline for this will look

00:30:42.586 --> 00:30:43.456
a little bit different than the

00:30:43.456 --> 00:30:44.656
hybrid pipelines that we've seen

00:30:44.656 --> 00:30:45.156
so far.

00:30:46.316 --> 00:30:47.526
First, we set up rays and use

00:30:47.526 --> 00:30:48.226
Metal to find their

00:30:48.226 --> 00:30:51.496
intersections with the scene.

00:30:51.966 --> 00:30:53.216
Then, we write a shader to

00:30:53.216 --> 00:30:54.236
process the results of those

00:30:54.236 --> 00:30:55.916
intersection tests to tell us

00:30:55.916 --> 00:30:57.506
what surfaces we hit.

00:30:58.956 --> 00:31:01.226
Then, we generate shadow rays

00:31:01.226 --> 00:31:02.066
from those intersection

00:31:02.066 --> 00:31:03.266
locations towards the lights in

00:31:03.266 --> 00:31:03.636
the scene.

00:31:04.136 --> 00:31:05.456
I'll write a shader to figure

00:31:05.456 --> 00:31:06.516
out which of those rays hit the

00:31:06.516 --> 00:31:07.806
light and then add their light

00:31:07.806 --> 00:31:08.566
to the final image.

00:31:10.016 --> 00:31:11.656
Finally, we use the hit surfaces

00:31:11.656 --> 00:31:12.776
as the starting positions for

00:31:12.776 --> 00:31:13.766
our next set of rays.

00:31:14.326 --> 00:31:15.666
We repeat this process over and

00:31:15.666 --> 00:31:16.686
over again until we've modeled

00:31:16.686 --> 00:31:17.996
as many ray bounces as we like.

00:31:18.626 --> 00:31:20.996
So that's how Global

00:31:20.996 --> 00:31:22.156
Illumination works.

00:31:22.826 --> 00:31:24.536
Now we'll discuss some best

00:31:24.536 --> 00:31:25.606
practices that come up with

00:31:25.606 --> 00:31:27.446
memory for this programing

00:31:27.446 --> 00:31:27.736
model.

00:31:28.976 --> 00:31:31.026
As any ray bounces around the

00:31:31.026 --> 00:31:31.486
scene.

00:31:31.836 --> 00:31:33.186
Its state changes depending on

00:31:33.186 --> 00:31:34.106
its interactions with the

00:31:34.106 --> 00:31:35.106
objects that it hits.

00:31:35.766 --> 00:31:37.276
For instance, if a ray hits a

00:31:37.276 --> 00:31:38.906
red material that surface

00:31:38.906 --> 00:31:40.496
absorbs everything but the red

00:31:40.496 --> 00:31:41.266
component of the light.

00:31:41.836 --> 00:31:42.986
So, the secondary rays that

00:31:42.986 --> 00:31:44.616
reflect off of that surface will

00:31:44.616 --> 00:31:45.636
only carry red light.

00:31:46.146 --> 00:31:47.586
So, we'll have to keep track of

00:31:47.586 --> 00:31:48.736
that information in order to

00:31:48.736 --> 00:31:50.056
pass it to the next iteration of

00:31:50.056 --> 00:31:50.666
our pipeline.

00:31:51.366 --> 00:31:51.996
That means we'll have to

00:31:51.996 --> 00:31:53.346
allocate a bunch of resources to

00:31:53.346 --> 00:31:54.816
keep track of ray and scene

00:31:54.816 --> 00:31:55.516
properties.

00:31:56.136 --> 00:31:57.646
To the right, I've listed a few

00:31:57.646 --> 00:31:59.446
examples of scene properties you

00:31:59.446 --> 00:32:02.636
may want to keep track of.

00:32:03.146 --> 00:32:04.116
With all these new buffers

00:32:04.116 --> 00:32:05.626
relocated we're going to be

00:32:05.626 --> 00:32:06.676
using a lot of memory.

00:32:07.186 --> 00:32:08.836
For a 4K image, the ray buffer

00:32:08.836 --> 00:32:11.096
alone would be 250 MB.

00:32:11.416 --> 00:32:12.576
In one of our demos, we're using

00:32:12.576 --> 00:32:13.906
almost 80 bytes per ray.

00:32:14.536 --> 00:32:15.756
And this approach can quickly

00:32:15.756 --> 00:32:16.836
exceed the amount of available

00:32:16.836 --> 00:32:17.586
GPU memory.

00:32:19.396 --> 00:32:20.946
One solution to this is just to

00:32:20.946 --> 00:32:22.476
batch up your rays into smaller

00:32:22.476 --> 00:32:23.266
groups or tiles.

00:32:23.926 --> 00:32:25.066
And by restricting the number of

00:32:25.066 --> 00:32:25.816
rays that you're launching

00:32:25.816 --> 00:32:26.916
simultaneously you can

00:32:26.916 --> 00:32:28.156
drastically reduce the memory

00:32:28.156 --> 00:32:29.396
footprint of your resources.

00:32:29.846 --> 00:32:32.336
Because the data in these

00:32:32.336 --> 00:32:33.396
buffers is going to be passed

00:32:33.496 --> 00:32:35.316
between pipeline iterations,

00:32:36.256 --> 00:32:37.546
storing that data out and then

00:32:37.546 --> 00:32:38.736
reading it in, in the next pass

00:32:38.736 --> 00:32:39.906
is going to be a major limiting

00:32:39.906 --> 00:32:40.276
factor.

00:32:40.906 --> 00:32:42.956
For 4K image we're using over 8

00:32:42.956 --> 00:32:43.756
million rays.

00:32:44.276 --> 00:32:45.486
And for that number of rays,

00:32:45.486 --> 00:32:46.626
we're reading and writing almost

00:32:46.626 --> 00:32:50.006
5 gigabytes of data per pass.

00:32:50.286 --> 00:32:51.466
There's no one solution to every

00:32:51.466 --> 00:32:52.736
bandwidth problem, but we can

00:32:52.736 --> 00:32:53.796
give you some best practices

00:32:53.796 --> 00:32:54.936
that worked well for us.

00:32:55.206 --> 00:32:57.066
First, don't index into your

00:32:57.066 --> 00:32:57.946
data buffers randomly.

00:32:58.996 --> 00:33:00.606
It's much more efficient if you

00:33:00.606 --> 00:33:02.196
can index by thread ID, so the

00:33:02.196 --> 00:33:03.636
compiler can coalesce all of the

00:33:03.636 --> 00:33:05.456
loads and stores since the

00:33:05.456 --> 00:33:06.746
memory the threads are accessing

00:33:06.746 --> 00:33:07.936
will be in adjacent buffer

00:33:07.936 --> 00:33:08.576
positions.

00:33:09.796 --> 00:33:10.966
This is really going to improve

00:33:10.966 --> 00:33:11.946
your cache coherency.

00:33:13.146 --> 00:33:14.756
Next, for variables where you

00:33:14.756 --> 00:33:15.786
don't need full precision,

00:33:16.376 --> 00:33:17.726
consider using smaller data

00:33:17.726 --> 00:33:18.586
types where possible.

00:33:19.316 --> 00:33:20.736
Try to use half instead of float

00:33:20.736 --> 00:33:22.196
data types for ray and scene and

00:33:22.196 --> 00:33:23.366
material properties if you can.

00:33:24.806 --> 00:33:26.566
Finally, split up structs if

00:33:26.566 --> 00:33:27.836
possible, to avoid loading or

00:33:27.836 --> 00:33:28.996
storing data you're not going to

00:33:28.996 --> 00:33:29.446
use.

00:33:29.696 --> 00:33:31.506
For example, we have a struct

00:33:31.506 --> 00:33:32.586
that contains material

00:33:32.586 --> 00:33:33.206
properties.

00:33:33.776 --> 00:33:35.026
We get a nice performance boost

00:33:35.026 --> 00:33:35.706
by stripping out the

00:33:35.706 --> 00:33:37.316
transparency variables because

00:33:37.316 --> 00:33:38.926
not every ray hits a transparent

00:33:38.926 --> 00:33:39.446
surface.

00:33:39.446 --> 00:33:40.626
And we didn't want those rays to

00:33:40.626 --> 00:33:41.756
have to pay the penalty for

00:33:41.756 --> 00:33:42.806
reading and writing that data.

00:33:43.626 --> 00:33:44.356
We're going to see a more

00:33:44.356 --> 00:33:45.716
concrete example of this later

00:33:45.716 --> 00:33:46.916
in the GPU debugging section.

00:33:46.916 --> 00:33:51.476
It might be counter intuitive,

00:33:51.576 --> 00:33:52.586
but it may be more efficient to

00:33:52.586 --> 00:33:53.886
allocate your own buffers to

00:33:53.886 --> 00:33:55.996
store origin and direction data

00:33:56.356 --> 00:33:57.586
rather than reusing the Metal

00:33:57.586 --> 00:33:58.506
ray buffer structs.

00:33:59.816 --> 00:34:00.996
This is because the Metal ray

00:34:00.996 --> 00:34:02.566
buffers may contain extra data

00:34:02.566 --> 00:34:03.636
numbers that you don't want to

00:34:03.636 --> 00:34:05.516
have to load and store for every

00:34:05.516 --> 00:34:06.806
shader that may access the ray.

00:34:09.576 --> 00:34:12.096
To maximize your GPU usage, you

00:34:12.096 --> 00:34:12.985
need to be mindful of your

00:34:12.985 --> 00:34:13.856
shader occupancy.

00:34:14.545 --> 00:34:16.306
Occupancy is a huge topic, so we

00:34:16.306 --> 00:34:17.565
won't go into it in depth here.

00:34:18.266 --> 00:34:19.525
But if you are getting occupancy

00:34:19.525 --> 00:34:20.746
problems the easiest way to

00:34:20.746 --> 00:34:22.156
improve it is to reduce your

00:34:22.156 --> 00:34:22.896
register pressure.

00:34:24.246 --> 00:34:25.735
So, be conscious of the number

00:34:25.735 --> 00:34:27.255
of simultaneously live variables

00:34:27.255 --> 00:34:28.096
that you have in your shader.

00:34:28.876 --> 00:34:30.326
Be careful with loop counters,

00:34:30.326 --> 00:34:32.505
function calls, and don't hold

00:34:32.505 --> 00:34:33.626
on to full structs if you can

00:34:33.626 --> 00:34:34.585
avoid it.

00:34:35.156 --> 00:34:38.766
When we process ray intersection

00:34:38.766 --> 00:34:40.485
points we need to evaluate the

00:34:40.485 --> 00:34:41.826
surface properties of whatever

00:34:41.826 --> 00:34:42.866
object a ray hits.

00:34:43.116 --> 00:34:44.755
And graphics applications

00:34:44.755 --> 00:34:45.686
typically store a lot of the

00:34:45.686 --> 00:34:47.335
material properties in textures.

00:34:47.976 --> 00:34:49.456
The problem here is that because

00:34:49.456 --> 00:34:51.446
a shader may need access to any

00:34:51.446 --> 00:34:52.346
texture that an object

00:34:52.346 --> 00:34:54.936
references, and we don't know in

00:34:54.936 --> 00:34:56.696
advance what object a ray is

00:34:56.696 --> 00:34:58.246
going to hit, we may potential

00:34:58.246 --> 00:35:00.296
he need access to every -- every

00:35:00.296 --> 00:35:01.246
texture that's in the scene.

00:35:02.006 --> 00:35:03.026
And this can get out of hand

00:35:03.026 --> 00:35:03.356
quickly.

00:35:03.846 --> 00:35:05.386
For instance, the commonly used

00:35:05.386 --> 00:35:07.406
Sponza Atrium scene has 76

00:35:07.406 --> 00:35:09.236
textures, which is over double

00:35:09.306 --> 00:35:10.426
our available number of bind

00:35:10.426 --> 00:35:10.746
slots.

00:35:11.376 --> 00:35:12.666
So, we'll pretty quickly run out

00:35:12.666 --> 00:35:13.866
of binding locations.

00:35:15.756 --> 00:35:17.796
One way to address this is by

00:35:17.796 --> 00:35:19.566
using Metal Argument Buffers.

00:35:19.906 --> 00:35:20.766
A Metal Argument Buffer

00:35:20.766 --> 00:35:22.566
represents a group of resources

00:35:22.566 --> 00:35:23.526
that can be collectively

00:35:23.526 --> 00:35:24.946
assigned as a single argument to

00:35:24.946 --> 00:35:25.316
a shader.

00:35:26.466 --> 00:35:27.786
We gave a talk on this at WWDC

00:35:27.786 --> 00:35:29.006
two years ago.

00:35:29.276 --> 00:35:30.786
So, I'll refer you to that for

00:35:30.786 --> 00:35:33.106
more details on how to use them.

00:35:33.546 --> 00:35:34.926
Assuming we have one texture per

00:35:34.926 --> 00:35:36.706
primitive, our argument buffer

00:35:36.706 --> 00:35:38.166
will be a struct that contains a

00:35:38.166 --> 00:35:39.006
reference to a texture.

00:35:40.376 --> 00:35:41.596
Here, we've set up a struct that

00:35:41.596 --> 00:35:43.196
we called material that contains

00:35:43.196 --> 00:35:44.536
a texture reference and any

00:35:44.536 --> 00:35:45.576
other information we'd like to

00:35:45.576 --> 00:35:46.206
access.

00:35:47.566 --> 00:35:48.896
Next, we bind our argument

00:35:48.896 --> 00:35:49.916
buffer to a compute kernel.

00:35:50.206 --> 00:35:51.846
It will appear as an array of

00:35:51.846 --> 00:35:52.726
material structs.

00:35:54.506 --> 00:35:55.646
We read from our intersection

00:35:55.646 --> 00:35:56.676
buffer to find out what

00:35:56.676 --> 00:35:59.206
primitive the ray hit and then

00:35:59.206 --> 00:36:00.596
we index into our argument

00:36:00.596 --> 00:36:01.936
buffer using that index.

00:36:02.626 --> 00:36:04.126
That lets us access a unique

00:36:04.126 --> 00:36:04.976
texture for every primitive.

00:36:08.646 --> 00:36:10.106
That covers our memory topics.

00:36:11.186 --> 00:36:12.336
Now we'll discuss managing the

00:36:12.336 --> 00:36:13.436
lifetime of your rays.

00:36:14.516 --> 00:36:16.066
As your ray bounces around the

00:36:16.066 --> 00:36:17.716
scene it can stop contributing

00:36:17.716 --> 00:36:19.026
to the final image for a variety

00:36:19.026 --> 00:36:19.646
of reasons.

00:36:20.156 --> 00:36:21.546
First, it may leave the scene

00:36:21.546 --> 00:36:22.036
entirely.

00:36:22.736 --> 00:36:23.936
Unlike the real world, your

00:36:23.936 --> 00:36:25.156
scene takes up a finite amount

00:36:25.156 --> 00:36:26.956
of space, and if the ray exits

00:36:26.956 --> 00:36:28.096
it there's no way for it to make

00:36:28.096 --> 00:36:28.866
its way back in.

00:36:29.386 --> 00:36:31.386
If that happens, we typically

00:36:31.386 --> 00:36:32.716
evaluate an environment map to

00:36:32.716 --> 00:36:34.336
get a background color, but that

00:36:34.336 --> 00:36:35.376
ray is effectively dead.

00:36:36.806 --> 00:36:39.166
Second, as the ray bounces, the

00:36:39.166 --> 00:36:40.136
light it carries will be

00:36:40.136 --> 00:36:41.566
attenuated by the surfaces is

00:36:41.566 --> 00:36:42.266
interacts with.

00:36:42.936 --> 00:36:45.456
If it loses enough light it may

00:36:45.456 --> 00:36:46.576
not be able to have a measurable

00:36:46.576 --> 00:36:47.716
impact on the final image.

00:36:48.686 --> 00:36:50.276
And finally, with transparent

00:36:50.276 --> 00:36:51.516
surfaces, there are some rays

00:36:51.516 --> 00:36:53.026
that can get trapped in

00:36:53.026 --> 00:36:54.066
position, such that they can

00:36:54.066 --> 00:36:55.166
never get back to the camera.

00:36:55.786 --> 00:36:58.826
So how quickly to rays become

00:36:58.826 --> 00:36:59.236
inactive?

00:37:00.116 --> 00:37:01.136
Well, depending on the kind of

00:37:01.136 --> 00:37:02.706
scene it can be quite rapid.

00:37:03.396 --> 00:37:04.996
For example, this scene has an

00:37:04.996 --> 00:37:06.626
open world and a lot of the rays

00:37:06.626 --> 00:37:07.866
will exit quickly by hitting the

00:37:07.866 --> 00:37:08.456
environment map.

00:37:09.156 --> 00:37:10.156
On the right, we're showing a

00:37:10.156 --> 00:37:11.696
simplified representation of a

00:37:11.696 --> 00:37:13.666
fully active ray buffer as it

00:37:13.666 --> 00:37:14.696
would exist for the first

00:37:14.696 --> 00:37:15.956
iteration of our pipeline.

00:37:16.346 --> 00:37:17.886
This is the step where we cast

00:37:17.886 --> 00:37:19.246
rays from the camera towards the

00:37:19.246 --> 00:37:19.546
scene.

00:37:20.136 --> 00:37:23.096
Some of those rays will hit the

00:37:23.096 --> 00:37:24.016
environment map and become

00:37:24.016 --> 00:37:24.436
inactive.

00:37:25.156 --> 00:37:26.336
Here, we've colored inactive

00:37:26.336 --> 00:37:27.986
rays yellow and we've removed

00:37:27.986 --> 00:37:28.826
them from the ray buffer.

00:37:29.626 --> 00:37:31.626
After the first pass only 57

00:37:31.626 --> 00:37:32.746
percent of our rays are still

00:37:32.746 --> 00:37:33.046
active.

00:37:34.526 --> 00:37:36.046
When we let the rays continue

00:37:36.046 --> 00:37:37.276
traveling, some of the rays that

00:37:37.276 --> 00:37:39.006
initially hit the ground bounce

00:37:39.006 --> 00:37:40.076
up and hit the environment map.

00:37:40.636 --> 00:37:41.916
Now we're down to 43 percent of

00:37:41.916 --> 00:37:44.566
rays that -- left active.

00:37:45.286 --> 00:37:46.796
Now, some of the rays travel all

00:37:46.796 --> 00:37:47.826
the way through the transparent

00:37:47.826 --> 00:37:49.126
objects and eventually exit the

00:37:49.126 --> 00:37:49.536
scene.

00:37:50.036 --> 00:37:50.956
We've only got about a third

00:37:50.956 --> 00:37:51.556
remaining active.

00:37:52.646 --> 00:37:53.816
And of course, the more we

00:37:53.816 --> 00:37:55.016
iterate, the more rays become

00:37:55.016 --> 00:37:55.386
inactive.

00:37:56.086 --> 00:37:58.896
In this example we know a lot of

00:37:58.896 --> 00:38:00.116
the rays in our ray buffer will

00:38:00.116 --> 00:38:01.406
be inactive, and anytime we

00:38:01.406 --> 00:38:02.466
spend processing them will be

00:38:02.466 --> 00:38:02.886
wasted.

00:38:03.376 --> 00:38:04.916
But because we don't know in

00:38:04.916 --> 00:38:06.156
advance which rays are going to

00:38:06.156 --> 00:38:07.896
be inactive, the Metal Ray

00:38:07.896 --> 00:38:09.366
Intersector and all of the

00:38:09.366 --> 00:38:10.896
shaders that process its results

00:38:10.896 --> 00:38:12.126
are still going to have to be

00:38:12.126 --> 00:38:13.276
run on all of them.

00:38:13.696 --> 00:38:14.296
That means we'll have to

00:38:14.296 --> 00:38:15.486
allocate thread group memory,

00:38:15.626 --> 00:38:16.756
the compiler may be prefetching

00:38:16.756 --> 00:38:18.176
data, and we may have to add

00:38:18.176 --> 00:38:20.056
control flow statements to cull

00:38:20.056 --> 00:38:21.146
inactive rays.

00:38:22.026 --> 00:38:23.676
Our occupancy here stays the

00:38:23.676 --> 00:38:25.676
same, but our thread groups have

00:38:25.676 --> 00:38:27.076
become sparsely utilized.

00:38:27.486 --> 00:38:28.756
And we're wasting all that

00:38:28.756 --> 00:38:29.676
processor capacity.

00:38:30.216 --> 00:38:33.386
Our solution to this is to the

00:38:33.386 --> 00:38:34.736
compact the ray buffers.

00:38:35.536 --> 00:38:37.396
For every pass we only add

00:38:37.396 --> 00:38:39.256
active rays to the next passes

00:38:39.256 --> 00:38:39.726
ray buffer.

00:38:40.426 --> 00:38:41.856
This adds some overhead, but it

00:38:41.856 --> 00:38:43.166
results in the cache lines and

00:38:43.166 --> 00:38:44.136
thread groups being fully

00:38:44.136 --> 00:38:45.926
utilized so there's less waste

00:38:45.926 --> 00:38:47.566
of processing and less bandwidth

00:38:47.566 --> 00:38:48.056
required.

00:38:48.746 --> 00:38:50.446
It's also important to note that

00:38:50.446 --> 00:38:51.666
this can be used for shadow rays

00:38:51.666 --> 00:38:52.286
as well.

00:38:52.756 --> 00:38:54.066
Some rays will hit surfaces that

00:38:54.066 --> 00:38:55.186
are pointing away from a light

00:38:55.436 --> 00:38:56.436
or they may hit the background.

00:38:56.546 --> 00:38:57.406
So, we won't want to cache

00:38:57.406 --> 00:38:58.776
shadow rays for them.

00:38:59.936 --> 00:39:01.966
The downside is that because

00:39:01.966 --> 00:39:03.196
we're shuffling ray positions

00:39:03.196 --> 00:39:04.856
within the ray buffers, the

00:39:04.856 --> 00:39:06.836
indices in our ray buffer no

00:39:06.836 --> 00:39:08.206
longer map to constant pixel

00:39:08.206 --> 00:39:08.846
locations.

00:39:09.336 --> 00:39:10.256
So, we'll need to allocate a

00:39:10.256 --> 00:39:11.546
buffer to start tracking pixel

00:39:11.546 --> 00:39:12.876
coordinates along with each ray.

00:39:12.876 --> 00:39:15.386
Even though we're using extra

00:39:15.386 --> 00:39:17.026
buffers, we'll actually be using

00:39:17.026 --> 00:39:18.616
much less memory if we factor in

00:39:18.616 --> 00:39:19.726
all of the rays that we don't

00:39:19.726 --> 00:39:20.636
have to process.

00:39:21.886 --> 00:39:23.976
When we're compacting the rays,

00:39:24.316 --> 00:39:25.846
we don't want two shaders to try

00:39:25.846 --> 00:39:27.136
to add rays to the new ray

00:39:27.136 --> 00:39:28.506
buffer at the same location.

00:39:29.296 --> 00:39:30.476
Therefore, we need to produce a

00:39:30.476 --> 00:39:32.126
unique index into the ray buffer

00:39:32.126 --> 00:39:33.286
for every ray that remains

00:39:33.286 --> 00:39:34.916
active between passes.

00:39:35.996 --> 00:39:37.406
We use an atomic counter to do

00:39:37.406 --> 00:39:37.756
this.

00:39:38.536 --> 00:39:39.836
Here, the atomic integer

00:39:39.946 --> 00:39:41.446
outgoingRayCount contains the

00:39:41.446 --> 00:39:43.036
current number of rays in the

00:39:43.036 --> 00:39:43.756
new ray buffer.

00:39:45.376 --> 00:39:47.506
We use atomic fetch add explicit

00:39:47.506 --> 00:39:48.836
to grab the current value of

00:39:48.836 --> 00:39:50.786
outgoing ray count and increment

00:39:51.396 --> 00:39:52.606
it by one.

00:39:52.606 --> 00:39:54.156
Using that value as the index

00:39:54.156 --> 00:39:55.306
into the outgoing ray buffer

00:39:55.406 --> 00:39:56.376
ensures that we don't get

00:39:56.376 --> 00:39:57.086
conflicts.

00:39:57.556 --> 00:39:58.806
It has the added benefit of

00:39:58.806 --> 00:39:59.936
leaving the number of rays that

00:39:59.936 --> 00:40:02.516
remain active in outgoing ray

00:40:03.416 --> 00:40:03.556
count.

00:40:04.096 --> 00:40:05.446
Now, Ray Compaction doesn't help

00:40:05.446 --> 00:40:06.666
you much if you can't restrict

00:40:06.666 --> 00:40:07.426
the number of threads that

00:40:07.426 --> 00:40:07.906
you're launching.

00:40:08.076 --> 00:40:09.476
The outgoing ray count buffer we

00:40:09.476 --> 00:40:11.046
just produced contains the total

00:40:11.046 --> 00:40:12.806
number of active rays in our

00:40:12.806 --> 00:40:13.686
outgoing ray buffer.

00:40:14.836 --> 00:40:16.286
We can use that to fill out an

00:40:16.356 --> 00:40:17.646
MTLDispatch ThreadGroups

00:40:17.686 --> 00:40:19.026
IndirectArguments object.

00:40:19.956 --> 00:40:21.266
That just specifies launch

00:40:21.266 --> 00:40:22.476
dimensions to be used with the

00:40:22.476 --> 00:40:23.026
dispatch.

00:40:24.146 --> 00:40:25.836
Then, by using IndirectDispatch

00:40:25.836 --> 00:40:27.056
with that indirectBuffer object

00:40:27.496 --> 00:40:28.596
we can restrict the number of

00:40:28.596 --> 00:40:29.666
threads that we're launching to

00:40:29.666 --> 00:40:30.896
only process the rays that

00:40:30.896 --> 00:40:31.416
remain active.

00:40:31.416 --> 00:40:33.506
There's also a version of the

00:40:33.506 --> 00:40:34.436
ray intersection function that

00:40:34.466 --> 00:40:34.976
corresponds to this.

00:40:35.066 --> 00:40:37.576
The important point here is that

00:40:38.266 --> 00:40:40.966
we can pass our ray count via a

00:40:40.966 --> 00:40:42.356
buffer, so we can feed the

00:40:42.356 --> 00:40:43.626
result of our ray compaction

00:40:43.626 --> 00:40:45.216
step in as the number of threads

00:40:45.216 --> 00:40:45.796
to launch.

00:40:47.596 --> 00:40:49.776
After Ray Compaction we get

00:40:49.776 --> 00:40:51.326
about a 15 percent performance

00:40:51.326 --> 00:40:52.216
gain in this scene.

00:40:52.346 --> 00:40:54.096
But of course, your results will

00:40:54.096 --> 00:40:55.616
depend on the complexity of the

00:40:55.616 --> 00:40:56.876
scene you're using and the

00:40:56.876 --> 00:40:57.926
number of ray bounces.

00:40:58.486 --> 00:41:02.036
So that covers ray lifetime and

00:41:02.036 --> 00:41:02.396
culling.

00:41:03.696 --> 00:41:05.386
Now we're going to discuss

00:41:05.386 --> 00:41:07.806
debugging your application with

00:41:08.536 --> 00:41:08.706
Xcode.

00:41:09.346 --> 00:41:10.496
Debugging on the GPU is

00:41:10.496 --> 00:41:12.176
notoriously difficult process.

00:41:12.756 --> 00:41:14.126
And this is especially true for

00:41:14.126 --> 00:41:14.546
Ray Tracing.

00:41:15.346 --> 00:41:16.436
Any change you make may get

00:41:16.436 --> 00:41:18.016
invoked multiple times per ray

00:41:18.016 --> 00:41:19.286
and you might have to write a

00:41:19.286 --> 00:41:20.726
lot of code to dump out buffers

00:41:20.726 --> 00:41:22.196
and textures for a bunch of

00:41:22.196 --> 00:41:23.046
different stages of your

00:41:23.046 --> 00:41:24.676
algorithm to get a clue about

00:41:24.676 --> 00:41:25.916
where an error was introduced.

00:41:26.736 --> 00:41:28.566
Xcode's frame capture tools are

00:41:28.566 --> 00:41:30.226
amazing for debugging exactly

00:41:30.226 --> 00:41:31.446
these kinds of issues.

00:41:31.896 --> 00:41:32.966
It's incredibly powerful and a

00:41:32.966 --> 00:41:33.766
real time saver.

00:41:34.746 --> 00:41:36.356
So, I'm going to walk you

00:41:36.356 --> 00:41:37.586
through debugging a real-world

00:41:37.586 --> 00:41:38.856
issue that we hit when we

00:41:38.856 --> 00:41:40.246
implemented super sampling in

00:41:40.246 --> 00:41:40.976
our ray tracer.

00:41:41.606 --> 00:41:43.256
We implemented the ability to

00:41:43.256 --> 00:41:44.776
sample a single pixel multiple

00:41:44.776 --> 00:41:46.336
times per frame and all of a

00:41:46.336 --> 00:41:47.476
sudden, our ray tracer is

00:41:47.476 --> 00:41:48.746
producing a blown-out image.

00:41:50.096 --> 00:41:52.356
The first step is just to do a

00:41:52.356 --> 00:41:53.386
frame capture as your

00:41:53.386 --> 00:41:54.276
application is running.

00:41:55.716 --> 00:41:56.756
This records the state of the

00:41:56.756 --> 00:41:58.686
GPU for every API call and

00:41:58.686 --> 00:41:59.686
shader over the course of a

00:41:59.686 --> 00:42:00.046
frame.

00:42:01.076 --> 00:42:03.106
By selecting any shader, we can

00:42:03.106 --> 00:42:04.266
examine the resources that are

00:42:04.266 --> 00:42:06.206
bound to it so we can really

00:42:06.206 --> 00:42:07.716
quickly narrow down exactly what

00:42:07.716 --> 00:42:09.176
shader's failing by just

00:42:09.176 --> 00:42:10.376
selecting all of the shaders

00:42:10.376 --> 00:42:11.346
that write to the frame buffer

00:42:11.486 --> 00:42:12.636
and examining the frame buffer

00:42:12.636 --> 00:42:13.546
contents directly.

00:42:13.956 --> 00:42:15.556
So here we can see the first

00:42:15.556 --> 00:42:16.316
image is pretty light.

00:42:16.866 --> 00:42:18.006
The second image is pretty

00:42:18.006 --> 00:42:18.486
washed out.

00:42:18.486 --> 00:42:19.716
And the third is almost white.

00:42:20.326 --> 00:42:23.186
But here we're going to select

00:42:23.186 --> 00:42:24.166
the shader that outputs the

00:42:24.166 --> 00:42:26.206
lightest image and we're going

00:42:26.206 --> 00:42:27.526
to take a look at the two input

00:42:27.526 --> 00:42:28.426
buffers that we used to

00:42:28.466 --> 00:42:29.736
calculate the frame buffer.

00:42:30.566 --> 00:42:31.826
And the first buffer just

00:42:31.826 --> 00:42:32.956
contains the sum of all the

00:42:32.956 --> 00:42:34.736
light a ray has accumulated.

00:42:36.796 --> 00:42:38.346
The second buffer contains our

00:42:38.346 --> 00:42:38.836
new variable.

00:42:38.836 --> 00:42:40.456
And that's just the number of

00:42:40.456 --> 00:42:41.506
times we've sampled a given

00:42:41.506 --> 00:42:41.816
pixel.

00:42:42.786 --> 00:42:43.916
Both of these buffers look like

00:42:43.916 --> 00:42:45.386
they have valid data in them, so

00:42:45.386 --> 00:42:46.406
we'll go directly to the shader

00:42:46.406 --> 00:42:47.456
debugger to examine what our

00:42:47.456 --> 00:42:48.476
shader is doing with this data.

00:42:49.116 --> 00:42:51.846
Our color calculation is just

00:42:51.846 --> 00:42:52.956
that some of the luminance for

00:42:52.956 --> 00:42:54.076
all the rays that were launched

00:42:54.076 --> 00:42:54.936
for a given pixel.

00:42:55.546 --> 00:42:57.246
When we only had one ray per

00:42:57.246 --> 00:42:58.676
pixel, this worked just fine.

00:42:59.636 --> 00:43:00.586
But now, we're failing to

00:43:00.586 --> 00:43:01.566
compensate for the fact that

00:43:01.566 --> 00:43:02.896
we're sampling multiple times

00:43:02.936 --> 00:43:03.346
per pixel.

00:43:03.346 --> 00:43:05.576
So, we're going to change that

00:43:05.576 --> 00:43:06.986
code in the shader debugger to

00:43:07.126 --> 00:43:08.486
divide the total luminance by

00:43:08.486 --> 00:43:09.746
the number of input samples.

00:43:10.586 --> 00:43:12.146
We reevaluate directly in the

00:43:12.146 --> 00:43:14.176
shader debugger and we can

00:43:14.176 --> 00:43:15.266
instantly see that our output

00:43:15.266 --> 00:43:16.226
image has been fixed.

00:43:16.606 --> 00:43:19.836
It's just that easy.

00:43:20.486 --> 00:43:21.666
Another issue we hit frequently

00:43:21.666 --> 00:43:22.636
was trying to understand the

00:43:22.636 --> 00:43:23.556
performance impact of our

00:43:23.556 --> 00:43:24.246
changes.

00:43:24.476 --> 00:43:26.776
Xcode frame captures tools make

00:43:26.816 --> 00:43:27.886
this easy as well.

00:43:29.136 --> 00:43:30.226
Here's an example of a struct

00:43:30.226 --> 00:43:31.046
that tracks surface

00:43:31.046 --> 00:43:32.366
characteristics across ray

00:43:32.366 --> 00:43:33.066
bounces.

00:43:33.826 --> 00:43:35.116
Not every surface in our scene

00:43:35.116 --> 00:43:36.206
uses transparencies.

00:43:36.206 --> 00:43:37.186
The final two values,

00:43:37.246 --> 00:43:38.566
transmission and index of

00:43:38.566 --> 00:43:40.206
refraction, won't be used for

00:43:40.206 --> 00:43:40.986
some rays.

00:43:41.566 --> 00:43:43.056
But, because we've packed all of

00:43:43.056 --> 00:43:44.546
that data into a single struct,

00:43:44.986 --> 00:43:46.406
rays that don't hit transparent

00:43:46.406 --> 00:43:47.896
surfaces are still going to have

00:43:47.896 --> 00:43:49.676
to pay the penalty for reading

00:43:49.676 --> 00:43:50.976
and writing those fields out

00:43:51.906 --> 00:43:53.376
between passes.

00:43:53.876 --> 00:43:55.896
Here, we've refactored the index

00:43:55.896 --> 00:43:57.096
of refraction variables into

00:43:57.096 --> 00:43:57.746
their own struct.

00:43:58.556 --> 00:44:00.036
By separating the structs only

00:44:00.036 --> 00:44:01.166
rays that hit transparent

00:44:01.166 --> 00:44:02.326
surfaces will have to touch the

00:44:02.326 --> 00:44:03.756
refraction data.

00:44:06.156 --> 00:44:07.636
But we can still do a bit

00:44:07.636 --> 00:44:07.926
better.

00:44:08.606 --> 00:44:09.626
Now we've changed all of our

00:44:09.626 --> 00:44:11.306
variables to half data types to

00:44:11.306 --> 00:44:12.346
save even more space.

00:44:13.096 --> 00:44:14.226
We've reduced our memory usage

00:44:14.226 --> 00:44:16.236
from 40 to 20 bytes, and rays

00:44:16.236 --> 00:44:17.256
that don't hit transparent

00:44:17.256 --> 00:44:18.776
objects will only need 12 bytes.

00:44:19.326 --> 00:44:21.526
So how do we understand the

00:44:21.526 --> 00:44:22.706
performance impact of this?

00:44:23.386 --> 00:44:25.666
Here we grab GPU traces using

00:44:25.666 --> 00:44:26.726
the frame capture tool both

00:44:26.756 --> 00:44:28.306
before and after our change.

00:44:29.216 --> 00:44:30.666
The most basic version of

00:44:30.666 --> 00:44:31.946
performance analysis we can do

00:44:31.946 --> 00:44:33.256
takes place at this phase.

00:44:34.036 --> 00:44:35.536
By comparing the shader timings

00:44:35.866 --> 00:44:37.056
in our before and after

00:44:37.056 --> 00:44:38.976
captures, we can isolate shaders

00:44:38.976 --> 00:44:40.076
whose performance has changed.

00:44:40.796 --> 00:44:41.906
Here, we can see that the shader

00:44:41.906 --> 00:44:43.026
that we've labeled sample

00:44:43.026 --> 00:44:45.136
surface has gone from 5.5

00:44:45.136 --> 00:44:46.756
milliseconds to 4 milliseconds.

00:44:47.396 --> 00:44:48.536
That's almost a 30 percent

00:44:48.536 --> 00:44:49.546
savings for one of our more

00:44:49.546 --> 00:44:50.516
costly shaders.

00:44:51.546 --> 00:44:53.726
If we want to quantify exactly

00:44:53.726 --> 00:44:54.926
why we're getting a performance

00:44:54.926 --> 00:44:56.836
gain, Xcode helpfully displays

00:44:56.836 --> 00:44:57.756
the results of all the

00:44:57.756 --> 00:44:58.756
performance counters that it

00:44:58.756 --> 00:44:59.846
inserts when it does a frame

00:44:59.846 --> 00:45:00.146
capture.

00:45:00.526 --> 00:45:02.176
Because we're interested in how

00:45:02.176 --> 00:45:03.626
we've affected our memory usage,

00:45:04.386 --> 00:45:05.246
we can take a look at the

00:45:05.246 --> 00:45:07.266
texture unit statistics and we

00:45:07.266 --> 00:45:08.496
see that our average texture

00:45:08.496 --> 00:45:10.096
unit stall time has gone down

00:45:10.096 --> 00:45:11.836
from 70 percent to 54 percent.

00:45:12.476 --> 00:45:13.686
And we've reduced our L2

00:45:13.686 --> 00:45:16.686
throughput by almost two-thirds.

00:45:17.506 --> 00:45:18.986
Even more helpfully Xcode will

00:45:18.986 --> 00:45:20.336
do some analysis of its own and

00:45:20.336 --> 00:45:21.576
report potential problems to

00:45:21.576 --> 00:45:21.726
you.

00:45:22.246 --> 00:45:23.846
Here, it's telling us that our

00:45:23.846 --> 00:45:25.086
original version had some real

00:45:25.086 --> 00:45:26.366
problems with memory and that

00:45:26.366 --> 00:45:27.476
our new version's performing

00:45:27.476 --> 00:45:29.806
much better.

00:45:30.456 --> 00:45:31.526
One more tip that you may find

00:45:31.526 --> 00:45:33.106
useful, is that the compute

00:45:33.106 --> 00:45:34.116
pipeline state had some

00:45:34.116 --> 00:45:35.376
interesting telemetry as well.

00:45:36.346 --> 00:45:36.616
Look at

00:45:36.616 --> 00:45:37.966
MaxTotalThreadsForThreadgroup.

00:45:38.356 --> 00:45:39.746
This is an indication of the

00:45:39.746 --> 00:45:40.876
occupancy of a shader.

00:45:41.576 --> 00:45:42.866
You should target 1024 as the

00:45:42.866 --> 00:45:44.346
maximum and anything less means

00:45:44.346 --> 00:45:45.386
that there may be an occupancy

00:45:45.386 --> 00:45:46.426
issue that you can fix.

00:45:46.926 --> 00:45:50.166
So that's debugging in Xcode.

00:45:50.706 --> 00:45:51.996
It makes developing Ray Tracing

00:45:51.996 --> 00:45:52.896
and Global Illumination

00:45:52.896 --> 00:45:54.296
algorithms on the Mac platform

00:45:54.296 --> 00:45:55.116
incredibly easy.

00:45:55.876 --> 00:45:56.986
And now, here's Wayne to give

00:45:56.986 --> 00:45:57.966
you a live demo of all of this.

00:45:58.516 --> 00:46:01.056
[ Applause ]

00:46:01.556 --> 00:46:03.206
>> Thanks Matt.

00:46:04.386 --> 00:46:06.086
So, you may recognize this scene

00:46:06.176 --> 00:46:07.736
from our platform State of the

00:46:07.736 --> 00:46:09.636
Union session earlier this week.

00:46:10.826 --> 00:46:12.546
To render it here, I'm using a

00:46:12.546 --> 00:46:14.176
MacBook Pro along with four

00:46:14.176 --> 00:46:14.606
external GPUs.

00:46:14.606 --> 00:46:17.986
And everything you can see on

00:46:18.016 --> 00:46:19.386
the screen there is being ray

00:46:19.386 --> 00:46:20.546
traced in real time.

00:46:21.106 --> 00:46:22.696
So, I can just take hold of the

00:46:22.696 --> 00:46:23.706
camera and move around the

00:46:23.706 --> 00:46:23.976
scene.

00:46:25.216 --> 00:46:26.936
So, let's start over here.

00:46:26.936 --> 00:46:29.306
You can see these great shadows

00:46:29.306 --> 00:46:30.076
that we're getting with Ray

00:46:30.076 --> 00:46:30.616
Tracing.

00:46:30.826 --> 00:46:32.386
They're hard at the contact

00:46:32.386 --> 00:46:33.836
points and they become softer

00:46:33.836 --> 00:46:35.356
and softer as the distance to

00:46:35.356 --> 00:46:36.326
the ground increases.

00:46:37.736 --> 00:46:40.186
And remember, for these shadows

00:46:40.186 --> 00:46:41.666
we're firing just one ray per

00:46:41.666 --> 00:46:43.236
pixel and then we're using the

00:46:43.236 --> 00:46:44.576
Denoiser that Sean was telling

00:46:44.576 --> 00:46:45.786
us about to get this great

00:46:45.826 --> 00:46:46.506
filtered result.

00:46:47.126 --> 00:46:49.176
And this is all calculated

00:46:49.176 --> 00:46:49.816
dynamically.

00:46:49.816 --> 00:46:51.136
So, I can just take hold of the

00:46:51.136 --> 00:46:52.966
light and move it around.

00:46:54.066 --> 00:46:56.096
And I can see the effect of that

00:46:56.096 --> 00:46:57.026
pretty much immediately.

00:46:57.596 --> 00:47:00.256
There's a really great effect

00:47:00.256 --> 00:47:01.056
going on here too.

00:47:01.056 --> 00:47:02.636
If we fly over and look in the

00:47:02.636 --> 00:47:04.346
window of the tram here, you can

00:47:04.346 --> 00:47:05.856
actually see the reflections of

00:47:05.856 --> 00:47:07.606
our shadows, and again, you can

00:47:07.606 --> 00:47:09.126
see the shadow moving around as

00:47:09.126 --> 00:47:10.826
I take control of the light.

00:47:13.226 --> 00:47:15.326
And if we head over to this part

00:47:15.326 --> 00:47:16.296
of the scene now, there's a

00:47:16.296 --> 00:47:18.036
really great reflection effect

00:47:18.076 --> 00:47:18.656
going on here.

00:47:19.306 --> 00:47:21.866
So, if we look at the left most

00:47:21.866 --> 00:47:24.276
tram you can see the reflection

00:47:24.276 --> 00:47:25.446
of the tram behind this.

00:47:26.296 --> 00:47:28.106
But you can also see reflections

00:47:28.196 --> 00:47:29.636
in the windshield of the tram

00:47:29.636 --> 00:47:30.276
behind us.

00:47:30.396 --> 00:47:31.846
So, there's reflections within

00:47:31.846 --> 00:47:33.856
reflections going on here and we

00:47:33.856 --> 00:47:35.136
have to simulate a couple of ray

00:47:35.136 --> 00:47:36.896
bounces per pixel to achieve

00:47:37.106 --> 00:47:38.006
that effect.

00:47:39.856 --> 00:47:41.226
So, I'm going to zoom out here a

00:47:41.226 --> 00:47:41.606
bit now.

00:47:41.886 --> 00:47:43.896
And of course, in this scene

00:47:43.896 --> 00:47:45.676
it's not just the camera and the

00:47:45.676 --> 00:47:46.526
lights that can move.

00:47:47.486 --> 00:47:48.636
Sean was telling us about

00:47:48.636 --> 00:47:50.086
Metal's Two-Level Acceleration

00:47:50.086 --> 00:47:50.806
structures earlier.

00:47:51.156 --> 00:47:52.556
And we're using those here to

00:47:52.676 --> 00:47:53.926
enable the trams to move around

00:47:53.926 --> 00:47:54.226
the scene.

00:47:54.846 --> 00:47:57.966
What I really want to show you

00:47:57.966 --> 00:47:59.576
now though is this fantastic

00:47:59.576 --> 00:48:01.076
lighting effect we have going on

00:48:01.116 --> 00:48:01.656
up on the roof.

00:48:01.656 --> 00:48:05.266
So, if we focus on the wall on

00:48:05.266 --> 00:48:07.006
the right there you can see that

00:48:07.006 --> 00:48:08.486
currently it's being lit

00:48:08.626 --> 00:48:10.206
primarily by direct sunlight.

00:48:10.866 --> 00:48:13.266
But as I take control of the sun

00:48:13.396 --> 00:48:15.636
and I rotate it around you can

00:48:15.636 --> 00:48:16.996
see the wall falls into shadow

00:48:16.996 --> 00:48:18.756
and now it's being lit by this

00:48:18.846 --> 00:48:20.606
really great indirect

00:48:20.606 --> 00:48:21.206
illumination.

00:48:22.176 --> 00:48:24.336
So, what's going on here is

00:48:24.866 --> 00:48:26.116
sunlight is hitting the roof on

00:48:26.116 --> 00:48:28.246
the left and it's bouncing and

00:48:28.246 --> 00:48:29.246
illuminating the wall on the

00:48:29.246 --> 00:48:29.576
right.

00:48:29.576 --> 00:48:30.756
Giving us this great color

00:48:30.756 --> 00:48:31.476
bleeding effect.

00:48:31.956 --> 00:48:35.226
And if I continue to rotate the

00:48:35.226 --> 00:48:36.556
sun you can see these really

00:48:36.556 --> 00:48:38.026
dramatic shadows start to come

00:48:38.026 --> 00:48:39.626
in and they travel across the

00:48:39.626 --> 00:48:40.356
surface of the roof there.

00:48:41.016 --> 00:48:43.506
If I spin the camera around a

00:48:43.506 --> 00:48:44.516
bit you can really see the

00:48:44.516 --> 00:48:45.956
reflections as well hitting the

00:48:45.956 --> 00:48:47.366
roof on the left.

00:48:47.976 --> 00:48:49.246
So, this is -- I really like

00:48:49.246 --> 00:48:49.796
this shot.

00:48:49.796 --> 00:48:51.636
There's a lot of Ray Tracing

00:48:51.636 --> 00:48:53.056
effects all going on at the same

00:48:53.056 --> 00:48:53.706
time here.

00:48:53.706 --> 00:48:54.686
We have the indirect

00:48:54.686 --> 00:48:55.766
illumination, we have the

00:48:55.766 --> 00:48:56.696
shadows, we have the

00:48:56.696 --> 00:48:57.426
reflections.

00:48:58.126 --> 00:48:59.516
And it's all being ray traced in

00:48:59.516 --> 00:49:01.666
real time with Metal and multi

00:49:01.666 --> 00:49:01.976
GPU.

00:49:02.976 --> 00:49:04.176
So, I'm going to switch back to

00:49:04.176 --> 00:49:05.516
the keynote now and it's this

00:49:05.516 --> 00:49:07.206
multi GPU aspect that I'd like

00:49:07.206 --> 00:49:08.396
to talk a bit more about.

00:49:09.516 --> 00:49:16.516
[ Applause ]

00:49:17.016 --> 00:49:18.146
So, for the demo that we just

00:49:18.146 --> 00:49:20.666
saw, the way that we implemented

00:49:21.006 --> 00:49:23.066
multi GPU was by dividing the

00:49:23.066 --> 00:49:25.546
screen into a set of small tiles

00:49:26.536 --> 00:49:27.676
and then we mapped these tiles

00:49:27.676 --> 00:49:29.036
onto the different GPUs.

00:49:29.636 --> 00:49:32.396
Now in the visualization here

00:49:32.396 --> 00:49:33.826
I'm using different colors to

00:49:33.826 --> 00:49:35.066
show you how the tiles are

00:49:35.066 --> 00:49:35.716
distributed.

00:49:36.256 --> 00:49:38.166
So, one GPU renders the tiles in

00:49:38.166 --> 00:49:38.716
red.

00:49:39.316 --> 00:49:40.176
Another does the tiles in

00:49:40.176 --> 00:49:40.696
yellow, and so on.

00:49:40.696 --> 00:49:43.286
And after all GPUs are finished,

00:49:43.286 --> 00:49:45.906
we just composite those results

00:49:45.906 --> 00:49:47.396
together to form our final

00:49:47.396 --> 00:49:47.766
image.

00:49:47.766 --> 00:49:50.716
So, if we take a step back and

00:49:50.716 --> 00:49:53.186
look at what we have here

00:49:53.226 --> 00:49:54.546
there's two things that jump

00:49:54.546 --> 00:49:54.826
out.

00:49:54.826 --> 00:49:57.806
So firstly, in the image on the

00:49:57.806 --> 00:49:59.126
left, so the way that we're

00:49:59.126 --> 00:50:00.006
assigning tiles to GPUs, it

00:50:00.006 --> 00:50:00.716
looks a bit strange.

00:50:01.086 --> 00:50:03.766
So why are we doing it like

00:50:03.766 --> 00:50:04.156
that?

00:50:05.066 --> 00:50:08.136
And secondly, for those small

00:50:08.136 --> 00:50:11.056
tiles the implication of that is

00:50:11.056 --> 00:50:12.736
that each GPU is going to render

00:50:12.736 --> 00:50:14.436
a block of pixels there and then

00:50:14.436 --> 00:50:15.336
a block of pixels somewhere

00:50:15.336 --> 00:50:15.546
else.

00:50:16.476 --> 00:50:17.646
And that just feels like it's

00:50:17.646 --> 00:50:19.246
going to be bad for things like

00:50:19.246 --> 00:50:21.336
ray coherency, cache hit ratios.

00:50:21.336 --> 00:50:22.126
All that kind of stuff.

00:50:23.116 --> 00:50:25.036
So, let's deal with these in

00:50:27.016 --> 00:50:27.126
turn.

00:50:27.326 --> 00:50:30.226
So, imagine we have four GPUs.

00:50:30.226 --> 00:50:31.986
The simple way to do multi GPU

00:50:31.986 --> 00:50:34.046
here is just to split the screen

00:50:34.046 --> 00:50:34.886
into quadrants.

00:50:35.826 --> 00:50:38.156
Now the issue with that is that

00:50:38.156 --> 00:50:39.506
some parts of a scene will be

00:50:39.506 --> 00:50:40.816
much easier to render than

00:50:40.816 --> 00:50:41.106
others.

00:50:41.986 --> 00:50:43.896
So, if we assume that the street

00:50:43.896 --> 00:50:45.226
and the building on the left

00:50:45.226 --> 00:50:47.026
there are much easier to render

00:50:47.026 --> 00:50:48.266
than the tram on the right.

00:50:49.316 --> 00:50:50.946
It stands to reason that the red

00:50:50.946 --> 00:50:52.316
and yellow GPUs will finish

00:50:52.316 --> 00:50:54.046
before the green and purple

00:50:54.046 --> 00:50:54.226
GPUs.

00:50:54.226 --> 00:50:57.926
Now we can fix this just by

00:50:57.926 --> 00:50:59.116
splitting the screen into

00:50:59.116 --> 00:50:59.926
smaller tiles.

00:50:59.926 --> 00:51:02.866
Then we can split each of those

00:51:02.866 --> 00:51:05.286
into smaller tiles and so on.

00:51:05.436 --> 00:51:06.946
Until we reach some minimum tile

00:51:06.996 --> 00:51:07.326
size.

00:51:07.946 --> 00:51:10.836
Now this has the effect of

00:51:10.836 --> 00:51:13.706
distributing work really evenly

00:51:13.706 --> 00:51:14.196
across the GPUs.

00:51:14.926 --> 00:51:16.456
So, if one part of the screen is

00:51:16.456 --> 00:51:17.566
particularly difficult to

00:51:17.566 --> 00:51:19.276
render, it just doesn't matter,

00:51:19.626 --> 00:51:21.586
because every GPU will be

00:51:21.586 --> 00:51:24.026
assigned tiles from that part of

00:51:25.056 --> 00:51:25.506
the screen.

00:51:25.956 --> 00:51:27.406
Now in practice, this regular

00:51:27.406 --> 00:51:29.126
tiling pattern that you see here

00:51:29.126 --> 00:51:30.616
probably isn't the way to go.

00:51:31.166 --> 00:51:32.506
Because you can get cases where

00:51:32.506 --> 00:51:33.886
the tiling aligns with the

00:51:33.886 --> 00:51:34.936
geometry in your scene.

00:51:36.396 --> 00:51:37.606
And so, we randomize a bit.

00:51:38.186 --> 00:51:39.936
And I'll give a few more details

00:51:39.936 --> 00:51:40.726
on how we're doing that in a

00:51:40.726 --> 00:51:41.126
second.

00:51:41.626 --> 00:51:44.606
And one of the really

00:51:44.606 --> 00:51:45.826
interesting things about this

00:51:45.826 --> 00:51:47.956
approach is that the mapping of

00:51:47.956 --> 00:51:50.106
tiles to GPUs, it does not

00:51:50.106 --> 00:51:50.616
change.

00:51:51.886 --> 00:51:53.716
So, the same GPU will process

00:51:53.716 --> 00:51:55.586
the same tiles every frame.

00:51:56.316 --> 00:51:57.566
And this is great.

00:51:57.626 --> 00:51:59.106
So, you can just calculate that

00:51:59.106 --> 00:52:00.666
mapping when your application

00:52:00.666 --> 00:52:02.666
initializes or when you resize

00:52:02.666 --> 00:52:04.066
the window and that's it.

00:52:04.636 --> 00:52:05.906
You don't need to think about

00:52:05.906 --> 00:52:07.946
multi GPU load balancing anymore

00:52:07.946 --> 00:52:09.056
and there's nothing to monitor.

00:52:09.056 --> 00:52:10.626
Nothing to recalculate in your

00:52:10.626 --> 00:52:12.226
application's main loop.

00:52:14.176 --> 00:52:17.366
So, if we know that small tiles

00:52:17.616 --> 00:52:19.126
distribute the work more evenly,

00:52:19.576 --> 00:52:20.626
why not just take it to the

00:52:20.626 --> 00:52:22.306
extreme and make them a pixel.

00:52:22.946 --> 00:52:25.956
So, the problem with that is

00:52:25.956 --> 00:52:27.446
that we need to give each GPU

00:52:27.766 --> 00:52:29.356
nice coherent blocks of pixels

00:52:29.356 --> 00:52:30.076
to be working on.

00:52:31.326 --> 00:52:33.476
So, the tradeoff there between

00:52:33.476 --> 00:52:35.276
balancing the load evenly and

00:52:35.276 --> 00:52:36.786
making sure that each GPU can

00:52:36.786 --> 00:52:38.166
run as efficiently as possible.

00:52:38.746 --> 00:52:41.606
So, to better understand that

00:52:41.606 --> 00:52:43.276
tradeoff we did a simple

00:52:43.276 --> 00:52:43.866
experiment.

00:52:44.446 --> 00:52:46.756
We took one of the new Mac Pros

00:52:46.756 --> 00:52:49.336
with a pair of the Vega II Duo

00:52:49.336 --> 00:52:51.066
GPUs, so that's four GPUs in

00:52:51.066 --> 00:52:53.386
total, and we tried rendering

00:52:53.386 --> 00:52:54.496
the same scene with various

00:52:54.496 --> 00:52:56.146
tiles sizes to see how that

00:52:56.146 --> 00:52:57.256
effected performance.

00:52:57.476 --> 00:53:00.826
Now of course, your mileage may

00:53:00.826 --> 00:53:03.756
vary here, but what we found is

00:53:03.756 --> 00:53:05.056
that the performance window is

00:53:05.056 --> 00:53:06.116
actually really wide.

00:53:07.076 --> 00:53:09.566
So, efficiency drops off if you

00:53:09.566 --> 00:53:11.486
make your tiles very small or if

00:53:11.486 --> 00:53:12.856
you make them very, very large.

00:53:13.766 --> 00:53:15.446
But anywhere in the middle keeps

00:53:15.446 --> 00:53:16.626
us pretty close to peak

00:53:16.626 --> 00:53:17.246
performance.

00:53:20.936 --> 00:53:22.386
So now we have our tile size

00:53:22.386 --> 00:53:23.966
pinned down, what we need to do

00:53:23.966 --> 00:53:25.686
next is assign them to the

00:53:25.686 --> 00:53:27.486
various GPUs.

00:53:28.196 --> 00:53:30.186
Now to do this, we start by

00:53:30.186 --> 00:53:31.936
generating a random number for

00:53:31.936 --> 00:53:34.236
each tile and then we compare

00:53:34.236 --> 00:53:36.006
those random numbers to a set of

00:53:36.006 --> 00:53:36.736
thresholds.

00:53:38.036 --> 00:53:39.406
And whichever range the random

00:53:39.406 --> 00:53:41.106
number lands in, that gives us

00:53:41.106 --> 00:53:43.066
the GPU to use for that tile.

00:53:43.506 --> 00:53:46.606
So as an example, here, if the

00:53:46.606 --> 00:53:49.026
random number is .4, we assign

00:53:49.026 --> 00:53:49.786
it to GPU 1.

00:53:50.796 --> 00:53:53.736
If it's .55, it goes on GPU 2.

00:53:54.146 --> 00:53:54.886
And so on.

00:53:56.236 --> 00:53:58.186
Now, once we've done this for

00:53:58.186 --> 00:54:00.406
every tile the output is a list

00:54:00.406 --> 00:54:01.876
of tiles that we need each GPU

00:54:01.876 --> 00:54:02.266
to render.

00:54:03.016 --> 00:54:06.676
As you can see down the bottom

00:54:07.226 --> 00:54:08.146
there the ranges that we're

00:54:08.146 --> 00:54:10.216
using for each GPU are equal.

00:54:11.476 --> 00:54:13.616
So, when assigning tiles to GPUs

00:54:13.716 --> 00:54:15.016
they are all equally likely to

00:54:15.016 --> 00:54:15.486
be chosen.

00:54:16.146 --> 00:54:19.346
But in practice, you almost

00:54:19.346 --> 00:54:20.936
certainly don't want this.

00:54:20.936 --> 00:54:23.346
For example, you might need to

00:54:23.346 --> 00:54:25.536
reserve capacity on one of your

00:54:25.536 --> 00:54:27.286
GPUs for non-ray tracing tasks

00:54:27.806 --> 00:54:29.736
such as denoising or tone

00:54:31.206 --> 00:54:31.366
mapping.

00:54:31.916 --> 00:54:33.536
Or you might be using GPUs with

00:54:33.536 --> 00:54:34.536
different performance.

00:54:34.906 --> 00:54:35.866
In which case you'll want to

00:54:35.866 --> 00:54:37.246
send more tiles to the more

00:54:37.246 --> 00:54:37.976
powerful GPUs.

00:54:39.846 --> 00:54:41.096
And you can account for this

00:54:41.346 --> 00:54:43.226
really easily by just adjusting

00:54:43.226 --> 00:54:43.676
the ranges.

00:54:44.996 --> 00:54:46.416
So now if we go ahead and

00:54:46.416 --> 00:54:47.906
reassign the same tiles we used

00:54:47.906 --> 00:54:49.946
before, you can see here that

00:54:49.946 --> 00:54:51.886
now GPU 2 takes on a much

00:54:51.886 --> 00:54:52.886
greater share of the work.

00:54:52.886 --> 00:54:57.966
Now, for the actual implantation

00:54:57.966 --> 00:54:59.696
of this there was a lot of

00:54:59.696 --> 00:55:01.296
really useful information in our

00:55:01.296 --> 00:55:02.696
Metal for Pro Apps session

00:55:02.696 --> 00:55:03.466
earlier this week.

00:55:03.766 --> 00:55:05.256
So, I won't go over that again

00:55:05.256 --> 00:55:05.496
here.

00:55:06.086 --> 00:55:08.356
But it is definitely useful to

00:55:08.356 --> 00:55:10.016
highlight just a couple of areas

00:55:10.106 --> 00:55:11.016
that can have a really big

00:55:11.016 --> 00:55:12.286
impact on performance.

00:55:12.846 --> 00:55:16.616
So firstly, you'll probably want

00:55:16.616 --> 00:55:17.976
to composite your tiles together

00:55:17.976 --> 00:55:19.436
on the GPU that's driving the

00:55:19.436 --> 00:55:19.896
display.

00:55:21.216 --> 00:55:22.886
So, it's important to find out

00:55:22.886 --> 00:55:25.056
which GPU that is and then work

00:55:25.056 --> 00:55:27.086
backwards to figure out how to

00:55:27.086 --> 00:55:28.416
get your data there efficiently.

00:55:28.936 --> 00:55:31.326
So, if the GPUs are in the same

00:55:31.326 --> 00:55:33.176
peer group then you can copy

00:55:33.176 --> 00:55:34.916
between them directly using our

00:55:34.916 --> 00:55:36.196
new peer group APIs.

00:55:37.186 --> 00:55:38.646
Otherwise you'll need to go by

00:55:38.646 --> 00:55:39.216
the CPU.

00:55:41.926 --> 00:55:44.476
Now secondly, it can often take

00:55:44.476 --> 00:55:46.056
a few milliseconds to copy data

00:55:46.056 --> 00:55:48.156
between GPUs and we definitely

00:55:48.276 --> 00:55:50.016
don't want to block waiting for

00:55:50.016 --> 00:55:51.126
those transfers to complete.

00:55:52.356 --> 00:55:54.526
So, to give you an example of

00:55:54.526 --> 00:55:56.426
how we're dealing with that we

00:55:56.426 --> 00:55:58.256
have two GPUs here and we're

00:55:58.256 --> 00:55:59.466
using the tiling scheme that I

00:55:59.466 --> 00:56:01.136
was just talking about to spread

00:56:01.136 --> 00:56:02.786
the rendering across the two

00:56:02.786 --> 00:56:02.956
GPUs.

00:56:04.666 --> 00:56:06.876
Now in GPU 0 at the top there we

00:56:06.876 --> 00:56:08.066
have two queues.

00:56:08.306 --> 00:56:10.066
One is just flat out doing

00:56:10.066 --> 00:56:11.146
back-to-back Ray Tracing.

00:56:11.876 --> 00:56:13.116
And then we have a second queue

00:56:13.606 --> 00:56:15.076
that copies the completed tiles

00:56:15.076 --> 00:56:16.976
over to GPU 1 asynchronously.

00:56:20.266 --> 00:56:21.956
Now, we'll assume that GPU 1 at

00:56:21.956 --> 00:56:23.166
the bottom there is the one

00:56:23.166 --> 00:56:24.206
that's driving our display.

00:56:24.896 --> 00:56:26.246
And here things are a bit

00:56:26.246 --> 00:56:26.596
different.

00:56:27.086 --> 00:56:30.626
This GPU is also Ray Tracing

00:56:30.746 --> 00:56:32.996
part of frame 0, but we can't go

00:56:32.996 --> 00:56:34.596
ahead and present that frame

00:56:35.076 --> 00:56:36.746
until the rest of our tiles have

00:56:36.746 --> 00:56:37.936
been copied over from the other

00:56:37.936 --> 00:56:38.476
GPU.

00:56:39.596 --> 00:56:42.076
So rather than wait, we just

00:56:42.076 --> 00:56:43.226
start work on the next frame.

00:56:44.716 --> 00:56:46.126
And then a bit later on when our

00:56:46.126 --> 00:56:47.996
tiles arrive from the other GPU,

00:56:48.836 --> 00:56:50.186
that's when we go ahead and

00:56:50.186 --> 00:56:51.386
composite everything together.

00:56:52.716 --> 00:56:53.906
So, I'll show you that one more

00:56:53.906 --> 00:56:54.286
time here.

00:56:54.286 --> 00:56:57.396
So, you can see that we end up

00:56:57.396 --> 00:56:59.316
in this steady state where we

00:56:59.316 --> 00:57:01.146
render frame N and then we

00:57:01.146 --> 00:57:02.756
composite frame N minus 1.

00:57:04.376 --> 00:57:06.326
So essentially, what we're doing

00:57:06.326 --> 00:57:07.656
here is latency hiding.

00:57:08.796 --> 00:57:10.186
And this together with the

00:57:10.186 --> 00:57:11.626
tiling scheme I was showing you

00:57:11.626 --> 00:57:13.196
to load balance between the

00:57:13.596 --> 00:57:15.236
GPUs, this is enabling us to

00:57:15.236 --> 00:57:16.796
achieve really great performance

00:57:16.796 --> 00:57:18.526
for our Ray Tracing workloads on

00:57:18.526 --> 00:57:19.886
our multi GPU systems.

00:57:20.396 --> 00:57:23.186
And with that, we come to the

00:57:23.186 --> 00:57:23.796
end of the talk.

00:57:24.926 --> 00:57:26.896
We began with a quick refresher

00:57:26.896 --> 00:57:28.286
of how Ray Tracing works in

00:57:28.286 --> 00:57:30.696
Metal and then we focused on a

00:57:30.756 --> 00:57:31.696
few features of the

00:57:31.696 --> 00:57:33.536
MPSRayIntersector that are there

00:57:33.616 --> 00:57:34.846
to really help with dynamic

00:57:34.846 --> 00:57:35.376
scenes.

00:57:35.796 --> 00:57:36.886
So that's the Two-Level

00:57:36.886 --> 00:57:38.886
Acceleration Structures along

00:57:38.886 --> 00:57:40.226
with our GPU Accelerated

00:57:40.226 --> 00:57:41.766
Rebuilds and Refitting.

00:57:42.376 --> 00:57:45.216
We also introduced the new Metal

00:57:45.216 --> 00:57:45.656
Denoiser.

00:57:45.786 --> 00:57:48.026
And then we talked through a few

00:57:48.026 --> 00:57:49.716
Ray Tracing use cases such as

00:57:49.716 --> 00:57:51.826
Shadows, Ambient Occlusion, and

00:57:51.826 --> 00:57:52.716
Global Illumination.

00:57:53.716 --> 00:57:55.806
When then showed you how to

00:57:55.806 --> 00:57:57.736
debug and profile Ray Tracing

00:57:57.736 --> 00:57:58.866
workloads using Xcode.

00:57:58.866 --> 00:58:00.856
And then, we finished by talking

00:58:00.856 --> 00:58:02.946
about how to take advantage of

00:58:02.946 --> 00:58:05.086
multiple GPUs in your Ray

00:58:05.086 --> 00:58:06.136
Tracing applications.

00:58:06.166 --> 00:58:08.026
Now, for more information be

00:58:08.026 --> 00:58:08.606
sure to visit

00:58:08.606 --> 00:58:10.996
developer.apple.com and there

00:58:10.996 --> 00:58:12.666
you'll also find a new sample

00:58:12.666 --> 00:58:13.646
demonstrating some of the

00:58:13.646 --> 00:58:14.826
features that we've talked about

00:58:14.826 --> 00:58:15.046
today.

00:58:16.066 --> 00:58:17.926
If you're new to Ray Tracing be

00:58:18.226 --> 00:58:19.506
sure to check out our talk from

00:58:19.506 --> 00:58:20.236
last year.

00:58:20.586 --> 00:58:21.926
And finally, we have our lab

00:58:21.926 --> 00:58:23.336
session coming up next at 12.

00:58:23.446 --> 00:58:24.886
So, I hope you can join us for

00:58:24.886 --> 00:58:24.976
that.

00:58:26.366 --> 00:58:27.456
So, thank you all for coming and

00:58:27.456 --> 00:58:28.796
I'll see you in the lab shortly.

00:58:29.016 --> 00:58:31.000
[ Applause ]
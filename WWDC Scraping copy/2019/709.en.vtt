WEBVTT

00:00:00.506 --> 00:00:04.500
[ Music ]

00:00:12.516 --> 00:00:14.636
[ Applause ]

00:00:15.136 --> 00:00:15.666
>> Good afternoon.

00:00:16.366 --> 00:00:17.206
Good afternoon everyone.

00:00:18.456 --> 00:00:22.546
Welcome to the bitcoin session

00:00:22.546 --> 00:00:23.156
[laughter].

00:00:23.156 --> 00:00:25.276
Kidding. Welcome to Cryptography

00:00:25.276 --> 00:00:26.306
and Your Apps session.

00:00:27.206 --> 00:00:29.126
Today, my colleague, Frederic,

00:00:29.126 --> 00:00:31.326
and I are here to show you that

00:00:31.326 --> 00:00:33.026
using cryptography on Apple

00:00:33.026 --> 00:00:34.936
products has never been easier.

00:00:35.776 --> 00:00:36.636
I am Yannick Sierra.

00:00:36.636 --> 00:00:37.846
I manage the Cryptographic

00:00:37.846 --> 00:00:39.496
Engineering Team at Apple.

00:00:39.496 --> 00:00:43.466
So today on one hand we have a

00:00:43.466 --> 00:00:45.756
set of great system features

00:00:45.926 --> 00:00:47.606
which solve a set of common

00:00:47.636 --> 00:00:48.456
security problems.

00:00:49.326 --> 00:00:51.306
On the other hand, we have an

00:00:51.446 --> 00:00:54.406
exciting new Swift API for

00:00:54.406 --> 00:00:55.576
cryptographic operation.

00:00:56.336 --> 00:00:58.476
We're really excited about it.

00:00:58.476 --> 00:01:00.056
If you here, it's probably

00:01:00.056 --> 00:01:01.506
because there's some information

00:01:01.506 --> 00:01:02.766
you want to protect, right.

00:01:05.476 --> 00:01:08.246
We know that you as developers

00:01:08.396 --> 00:01:11.016
and as users find it really

00:01:11.016 --> 00:01:12.526
important to protect user's

00:01:12.526 --> 00:01:13.976
information, your information.

00:01:16.656 --> 00:01:17.806
There are different kind of

00:01:17.806 --> 00:01:19.326
information, which are all

00:01:19.426 --> 00:01:19.826
sensitive.

00:01:19.866 --> 00:01:21.966
It starts with profile

00:01:21.966 --> 00:01:23.796
information such as phone

00:01:23.796 --> 00:01:25.746
numbers and email addresses.

00:01:26.636 --> 00:01:28.156
Your applications may also be

00:01:28.156 --> 00:01:31.866
handling user information such

00:01:31.866 --> 00:01:34.386
as photos or music by using an

00:01:34.386 --> 00:01:36.256
application to process and

00:01:36.256 --> 00:01:36.686
improve.

00:01:38.196 --> 00:01:39.976
Your application may also be

00:01:39.976 --> 00:01:41.596
handling business assets.

00:01:42.826 --> 00:01:44.846
This could be paid content your

00:01:45.026 --> 00:01:46.266
app is making available to

00:01:46.266 --> 00:01:46.886
users.

00:01:47.716 --> 00:01:49.586
Or account information like in

00:01:49.586 --> 00:01:51.626
the mobile banking scenarios.

00:01:53.136 --> 00:01:54.836
For all of this information, it

00:01:54.836 --> 00:01:56.636
is critical to keep them secure,

00:01:57.106 --> 00:01:58.926
and you need to have great tools

00:01:58.926 --> 00:01:59.346
for that.

00:01:59.986 --> 00:02:04.436
At Apple, security and privacy

00:02:04.716 --> 00:02:06.146
are core values.

00:02:06.826 --> 00:02:08.406
We built it in all of the

00:02:08.406 --> 00:02:11.056
features that we work on.

00:02:12.356 --> 00:02:14.626
Cryptography is a big part of

00:02:15.416 --> 00:02:15.486
it.

00:02:16.036 --> 00:02:18.086
For example, with device

00:02:18.086 --> 00:02:20.476
integrity we use cryptography to

00:02:20.476 --> 00:02:21.886
validate the integrity of the

00:02:21.886 --> 00:02:23.506
software running on the platform

00:02:23.876 --> 00:02:25.206
to make sure it has not been

00:02:25.206 --> 00:02:27.216
tampered with and guarantee its

00:02:27.216 --> 00:02:28.936
security properties are not

00:02:28.936 --> 00:02:29.376
changed.

00:02:30.746 --> 00:02:32.236
We use cryptography to protect

00:02:32.236 --> 00:02:32.996
data at rest.

00:02:34.086 --> 00:02:36.236
We use cryptography across a

00:02:36.476 --> 00:02:38.166
wide variety of applications

00:02:38.666 --> 00:02:42.416
users love, use extensively for

00:02:42.616 --> 00:02:44.736
capturing very personal moments

00:02:44.866 --> 00:02:45.816
and sharing them.

00:02:46.426 --> 00:02:47.946
This is a case of Messages,

00:02:48.766 --> 00:02:50.876
Safari, and iCloud.

00:02:51.876 --> 00:02:53.806
With over a billion device, we

00:02:53.806 --> 00:02:55.346
operation cryptography at a huge

00:02:55.386 --> 00:02:55.726
scale.

00:02:57.056 --> 00:02:58.806
The stakes, as you can imagine,

00:02:59.186 --> 00:03:00.206
are really high too.

00:03:00.626 --> 00:03:02.936
Performance is critical for a

00:03:02.936 --> 00:03:04.066
great user experience.

00:03:05.016 --> 00:03:07.006
Energy is fundamental for that

00:03:07.136 --> 00:03:09.296
full-day battery life, and

00:03:09.296 --> 00:03:10.966
security, it's a cornerstone

00:03:10.966 --> 00:03:11.166
here.

00:03:12.526 --> 00:03:13.856
Now, let's have a closer look at

00:03:13.856 --> 00:03:14.516
cryptography.

00:03:16.196 --> 00:03:17.896
Cryptography is really a tool.

00:03:18.286 --> 00:03:20.116
It provides solution to a set of

00:03:20.306 --> 00:03:21.956
basic properties.

00:03:23.186 --> 00:03:25.096
It starts with authentication as

00:03:25.096 --> 00:03:27.356
an example, knowing who sent you

00:03:27.356 --> 00:03:27.776
a message.

00:03:29.456 --> 00:03:31.406
Encryption, knowing that that

00:03:31.406 --> 00:03:34.546
message only you can decrypt it.

00:03:35.456 --> 00:03:37.836
And Integrity, knowing that no

00:03:37.836 --> 00:03:39.536
one else could have modified the

00:03:39.536 --> 00:03:41.316
content of that message before

00:03:41.316 --> 00:03:42.506
it got to you.

00:03:43.456 --> 00:03:45.636
To solve broader security

00:03:45.636 --> 00:03:47.166
problem, we combine

00:03:47.166 --> 00:03:48.916
cryptographic functions into

00:03:48.916 --> 00:03:51.376
cryptographic protocol, and

00:03:51.376 --> 00:03:52.466
that's no easy task.

00:03:54.036 --> 00:03:56.266
Actually, many of you, most of

00:03:56.266 --> 00:03:57.316
you have probably heard the

00:03:57.356 --> 00:03:58.476
saying, don't [inaudible]

00:03:58.476 --> 00:03:59.426
crypto, right.

00:04:00.206 --> 00:04:01.616
There are good reasons for that.

00:04:01.616 --> 00:04:04.256
A lot of things can go wrong.

00:04:05.456 --> 00:04:07.476
It starts with maybe not picking

00:04:07.476 --> 00:04:09.116
the right primitives and

00:04:09.116 --> 00:04:09.946
therefore not getting the

00:04:09.946 --> 00:04:11.766
security you want to achieve.

00:04:12.636 --> 00:04:14.566
It may also be adding the right

00:04:14.566 --> 00:04:16.745
primitives but not using them

00:04:16.745 --> 00:04:19.656
the right way, and the lowest

00:04:19.656 --> 00:04:22.366
level, the implementation may

00:04:22.366 --> 00:04:23.526
give away the secrets or the

00:04:23.526 --> 00:04:23.916
keys.

00:04:24.296 --> 00:04:25.476
That could be the case of timing

00:04:25.476 --> 00:04:27.016
attacks or padding oracle

00:04:27.016 --> 00:04:27.556
attacks.

00:04:28.886 --> 00:04:30.696
This is why cryptography is

00:04:30.696 --> 00:04:32.056
incredibly difficult.

00:04:32.386 --> 00:04:35.046
There are endless examples of

00:04:35.186 --> 00:04:36.356
failures of cryptographic

00:04:36.356 --> 00:04:39.636
protocols in the news, and the

00:04:39.636 --> 00:04:41.236
worst thing is, security

00:04:41.236 --> 00:04:42.656
vulnerabilities may take a while

00:04:42.656 --> 00:04:43.426
to be discovered.

00:04:43.426 --> 00:04:45.186
It may take years before someone

00:04:45.186 --> 00:04:46.306
reports finding an issue.

00:04:47.656 --> 00:04:50.386
This is why the risks are really

00:04:50.386 --> 00:04:53.146
high, and so it's an effort to

00:04:53.146 --> 00:04:53.736
get it right.

00:04:55.026 --> 00:04:56.286
Designing a robust protocol

00:04:56.636 --> 00:04:59.336
takes a lot of time, skills, and

00:04:59.336 --> 00:05:01.446
expertise you need to be a

00:05:01.446 --> 00:05:02.166
cryptographer.

00:05:03.306 --> 00:05:04.686
Even when you got the protocol,

00:05:05.056 --> 00:05:06.226
the work is not done yet.

00:05:06.946 --> 00:05:07.996
There is a continuous amount of

00:05:07.996 --> 00:05:10.576
work to monitor new attacks, see

00:05:10.576 --> 00:05:12.156
what is applicable to your own

00:05:12.156 --> 00:05:14.806
code, and then respond to it,

00:05:15.476 --> 00:05:16.746
but sometimes it's not even that

00:05:16.746 --> 00:05:17.096
easy.

00:05:17.486 --> 00:05:18.676
It can be dependencies.

00:05:19.226 --> 00:05:20.606
Those libraries that you picked

00:05:20.606 --> 00:05:23.846
to integrate in your app.

00:05:24.106 --> 00:05:25.856
And in some situation, you also

00:05:25.856 --> 00:05:27.006
need to revise and carry the

00:05:27.006 --> 00:05:29.196
protocol and manage all kind of

00:05:29.196 --> 00:05:30.916
interpretability scenarios.

00:05:31.516 --> 00:05:35.436
All of this is a lot of work,

00:05:36.076 --> 00:05:38.326
and it's taking time and energy

00:05:38.326 --> 00:05:40.106
away of the big ideas you may

00:05:40.106 --> 00:05:42.546
have or the next cool features.

00:05:44.416 --> 00:05:46.936
This is why you can truly

00:05:46.936 --> 00:05:49.136
benefit from native features.

00:05:50.256 --> 00:05:51.766
Our philosophy has been to

00:05:51.766 --> 00:05:55.306
provide full solutions for a set

00:05:55.646 --> 00:05:57.836
of common problems so that we do

00:05:57.836 --> 00:05:59.416
the hard work and you don't have

00:05:59.466 --> 00:05:59.626
to.

00:06:00.936 --> 00:06:03.726
For you, it raises the risk and

00:06:03.726 --> 00:06:05.586
the effort, and we can even

00:06:05.586 --> 00:06:07.716
achieve better security through

00:06:07.716 --> 00:06:09.856
the assistance of delegated

00:06:09.856 --> 00:06:11.406
hardware features we have on our

00:06:11.406 --> 00:06:11.936
platforms.

00:06:14.686 --> 00:06:17.046
Now, we actually look through a

00:06:17.046 --> 00:06:18.626
set of very common scenarios

00:06:19.156 --> 00:06:20.406
many of you may be familiar

00:06:20.406 --> 00:06:20.646
with.

00:06:20.646 --> 00:06:24.146
We're going to start with how to

00:06:24.146 --> 00:06:25.736
protect data on a device.

00:06:26.366 --> 00:06:28.676
Then we can look at protecting

00:06:28.676 --> 00:06:30.206
credentials and keys.

00:06:30.766 --> 00:06:34.446
After that, sharing data across

00:06:34.446 --> 00:06:36.456
devices and users.

00:06:38.256 --> 00:06:40.106
Then, securing network

00:06:40.106 --> 00:06:42.196
connections, and finally,

00:06:42.346 --> 00:06:44.126
verifying remote parties with

00:06:44.166 --> 00:06:44.846
certificates.

00:06:46.426 --> 00:06:48.186
Now, I'm going to look into the

00:06:48.276 --> 00:06:49.276
first example.

00:06:49.406 --> 00:06:50.456
Like I'm sure many of you have

00:06:50.546 --> 00:06:54.106
found that scenario and find

00:06:54.106 --> 00:06:55.196
yourself trying to protect data

00:06:55.716 --> 00:06:56.556
on device.

00:06:57.406 --> 00:07:00.496
Well, the best advice is not to

00:07:00.496 --> 00:07:01.586
just copy and paste what you

00:07:01.586 --> 00:07:03.246
find on some of those websites.

00:07:03.896 --> 00:07:06.436
You're better off using data

00:07:06.436 --> 00:07:06.976
protection.

00:07:08.016 --> 00:07:09.276
Data protection combines the

00:07:09.276 --> 00:07:11.046
strengths of the passcode with

00:07:11.046 --> 00:07:12.766
the hardware technologies in the

00:07:12.766 --> 00:07:14.696
Secure Enclave to make sure the

00:07:14.816 --> 00:07:16.966
keys are well secured, and the

00:07:16.966 --> 00:07:19.886
encrypted data cannot be used to

00:07:19.886 --> 00:07:20.796
brute-force the passcode.

00:07:21.396 --> 00:07:23.816
But there's even more.

00:07:24.526 --> 00:07:26.586
Data protection provides post

00:07:26.586 --> 00:07:27.556
compromise recovery.

00:07:28.726 --> 00:07:30.656
Post compromise recovery, also

00:07:30.656 --> 00:07:31.806
known as forward secrecy,

00:07:32.156 --> 00:07:34.166
guarantees that if adversary

00:07:34.456 --> 00:07:35.666
gets his hand on the keys on the

00:07:35.666 --> 00:07:37.736
device and the users change the

00:07:37.736 --> 00:07:40.276
passcode, well, all the data

00:07:40.276 --> 00:07:42.086
encrypted after that cannot be

00:07:42.086 --> 00:07:43.346
recovered from those old keys.

00:07:44.496 --> 00:07:47.296
This is important, critical, and

00:07:47.296 --> 00:07:48.476
if you want to learn more,

00:07:49.086 --> 00:07:49.996
there's even more data

00:07:49.996 --> 00:07:51.946
protection does, and you can

00:07:51.946 --> 00:07:53.276
look at the iOS security white

00:07:53.276 --> 00:07:56.086
paper to get more information.

00:07:56.926 --> 00:07:58.386
The one thing you need to know

00:07:59.166 --> 00:07:59.996
is that there are different

00:07:59.996 --> 00:08:02.336
protection attributes you can

00:08:02.396 --> 00:08:03.626
set when your app fails.

00:08:04.276 --> 00:08:07.876
It starts from until first

00:08:07.876 --> 00:08:08.736
authentication.

00:08:09.496 --> 00:08:12.776
Even the data is protected until

00:08:14.096 --> 00:08:15.526
the first time the user unlocks

00:08:15.526 --> 00:08:17.096
the phone after boot.

00:08:18.346 --> 00:08:19.126
It's great.

00:08:20.136 --> 00:08:21.576
Today is a lot better you can

00:08:21.576 --> 00:08:21.766
do.

00:08:22.316 --> 00:08:23.716
There is the complete file

00:08:23.716 --> 00:08:24.236
protection.

00:08:24.766 --> 00:08:26.076
Complete file protection means

00:08:26.546 --> 00:08:28.746
the data is only available after

00:08:28.796 --> 00:08:30.876
the user unlocks his phone.

00:08:31.326 --> 00:08:32.836
As soon as the user locks his

00:08:32.836 --> 00:08:33.846
phone back, put it back in the

00:08:33.846 --> 00:08:35.826
pocket or in a bag, the data is

00:08:35.866 --> 00:08:36.336
secure again.

00:08:36.885 --> 00:08:39.846
And it's really easy to use.

00:08:40.145 --> 00:08:40.775
Here's an example.

00:08:41.566 --> 00:08:42.686
The only thing you need to use

00:08:42.846 --> 00:08:43.606
is this option,

00:08:43.916 --> 00:08:44.966
completeFileProtection.

00:08:44.966 --> 00:08:46.496
It can't be easier than that,

00:08:46.496 --> 00:08:46.706
right.

00:08:47.216 --> 00:08:48.376
If you're not using this option

00:08:48.376 --> 00:08:49.686
yet, please go ahead and look in

00:08:49.686 --> 00:08:50.906
your application where you could

00:08:50.906 --> 00:08:52.866
use it to get that best level of

00:08:52.866 --> 00:08:53.446
security.

00:08:55.576 --> 00:08:58.506
Now, in addition to files, there

00:08:58.506 --> 00:08:59.616
may be more sensitive

00:08:59.616 --> 00:09:00.746
information that you may want to

00:09:00.746 --> 00:09:01.066
protect.

00:09:02.076 --> 00:09:03.596
There could be credentials like

00:09:03.836 --> 00:09:05.906
authentication tokens used to

00:09:05.906 --> 00:09:08.216
authenticate on services or

00:09:08.216 --> 00:09:09.006
cryptography keys.

00:09:09.546 --> 00:09:13.986
But for those, please don't

00:09:13.986 --> 00:09:15.436
write them in defaults that you

00:09:15.436 --> 00:09:16.936
could see on all the platforms.

00:09:17.736 --> 00:09:19.666
Instead, there is Keychain.

00:09:21.106 --> 00:09:22.826
Keychain in the Secitem APIs

00:09:23.356 --> 00:09:24.826
allows you to write those items

00:09:25.446 --> 00:09:27.036
as in the local Keychain, which

00:09:27.036 --> 00:09:28.146
means they stay on that one

00:09:28.146 --> 00:09:30.976
device or on iCloud Keychain

00:09:31.836 --> 00:09:33.076
where they synchronize across

00:09:33.076 --> 00:09:34.426
all of the devices for a

00:09:34.546 --> 00:09:36.916
seamless experience in the user

00:09:36.916 --> 00:09:37.306
account.

00:09:37.946 --> 00:09:40.086
This requires user accounts with

00:09:40.306 --> 00:09:41.286
two-factor authentication

00:09:41.286 --> 00:09:41.706
enabled.

00:09:42.306 --> 00:09:45.006
For Keychain, you find very

00:09:45.006 --> 00:09:47.466
similar protection as for the

00:09:47.466 --> 00:09:48.906
files that I mentioned before

00:09:49.576 --> 00:09:50.696
and a few extra ones.

00:09:51.246 --> 00:09:52.556
Here, again, I will recommend

00:09:52.556 --> 00:09:53.786
you to look at the documentation

00:09:53.786 --> 00:09:54.286
to learn more.

00:09:55.686 --> 00:09:56.946
In addition to when a key is

00:09:56.986 --> 00:09:58.136
cryptographically available,

00:09:58.636 --> 00:10:00.306
sometimes important for you to

00:10:00.306 --> 00:10:01.676
know how the user authenticated

00:10:01.676 --> 00:10:01.976
it and when.

00:10:03.656 --> 00:10:05.576
This is why we have

00:10:05.576 --> 00:10:06.976
LocalAuthentication.

00:10:08.256 --> 00:10:10.196
LocalAuthentication allows you

00:10:10.196 --> 00:10:12.446
to put restrictions as to when

00:10:12.446 --> 00:10:14.726
an operation can be executed.

00:10:15.306 --> 00:10:16.746
For example, you could define

00:10:16.886 --> 00:10:18.336
that it is required for the user

00:10:18.336 --> 00:10:19.646
to authenticate with biometrics

00:10:19.646 --> 00:10:20.296
with Face ID.

00:10:21.256 --> 00:10:22.906
It can be very handy, and in

00:10:22.906 --> 00:10:25.336
this world, on macOS we have

00:10:25.336 --> 00:10:26.446
some exciting news.

00:10:27.036 --> 00:10:31.066
On macOS, you're used to device

00:10:31.146 --> 00:10:33.776
authentication properties, and

00:10:33.776 --> 00:10:35.986
it gives two way for the user to

00:10:35.986 --> 00:10:38.256
authenticate, the password or

00:10:38.256 --> 00:10:39.886
biometrics for Macs which

00:10:39.886 --> 00:10:41.286
support biometrics with Touch

00:10:41.286 --> 00:10:41.496
ID.

00:10:42.466 --> 00:10:43.606
This year we're really excited

00:10:43.606 --> 00:10:46.006
to announce that now without any

00:10:46.006 --> 00:10:48.746
change in your application, the

00:10:48.746 --> 00:10:50.446
user can authenticate with Apple

00:10:50.446 --> 00:10:52.186
Watch and [inaudible] Apple

00:10:52.186 --> 00:10:52.496
Watch.

00:10:53.376 --> 00:10:54.606
It's a great new experience,

00:10:54.796 --> 00:10:56.506
which is going to reduce the use

00:10:56.506 --> 00:10:57.986
of the password and reduce the

00:10:58.026 --> 00:10:59.356
friction, improves user

00:10:59.356 --> 00:10:59.926
experience.

00:11:00.916 --> 00:11:02.366
Now, with these new capabilities

00:11:02.536 --> 00:11:04.306
we added two new policies.

00:11:05.236 --> 00:11:08.386
The first one, to reduce the

00:11:08.386 --> 00:11:10.416
authentication to biometrics

00:11:10.416 --> 00:11:11.926
only and Watch.

00:11:12.506 --> 00:11:15.586
And the second one to the Watch

00:11:15.936 --> 00:11:16.426
alone.

00:11:17.696 --> 00:11:18.686
We are looking forward to see

00:11:18.776 --> 00:11:19.946
how you're going to use those in

00:11:20.076 --> 00:11:21.566
your application on macOS.

00:11:25.196 --> 00:11:26.386
Now, I mentioned the Keychain,

00:11:27.316 --> 00:11:28.186
there is an easy way to

00:11:28.236 --> 00:11:30.376
synchronize items across all of

00:11:30.376 --> 00:11:32.286
the devices of an account.

00:11:33.196 --> 00:11:34.066
What if you have data?

00:11:35.086 --> 00:11:36.636
Well, for data we have a great

00:11:36.636 --> 00:11:37.236
solution too.

00:11:38.626 --> 00:11:41.436
CloudKit. CloudKit allows you to

00:11:41.436 --> 00:11:43.336
encrypt assets in the Private

00:11:43.336 --> 00:11:46.856
CloudKit Database, and the data

00:11:46.856 --> 00:11:48.556
will be available across all of

00:11:48.556 --> 00:11:50.156
the devices without the user

00:11:50.156 --> 00:11:51.656
having to sign in into the

00:11:51.656 --> 00:11:52.376
application.

00:11:52.936 --> 00:11:56.296
It is great, and even more, you

00:11:56.296 --> 00:11:57.926
can also use it to share to all

00:11:57.926 --> 00:11:58.636
the users.

00:12:00.796 --> 00:12:02.896
The way it works is Apple as a

00:12:02.936 --> 00:12:05.746
trusted party help manage the

00:12:05.846 --> 00:12:08.046
iCloud identities and the

00:12:08.046 --> 00:12:09.886
control to the data.

00:12:10.596 --> 00:12:13.776
And I have an example here

00:12:13.776 --> 00:12:15.656
again, to show it's easy to set

00:12:15.656 --> 00:12:15.786
up.

00:12:16.946 --> 00:12:17.856
From the file, we create an

00:12:17.856 --> 00:12:17.976
asset.

00:12:20.556 --> 00:12:22.206
With this asset, we created a

00:12:22.206 --> 00:12:22.626
record.

00:12:23.496 --> 00:12:24.846
And then we upload this record

00:12:24.906 --> 00:12:25.976
into the Private CloudKit

00:12:25.976 --> 00:12:26.476
Database.

00:12:27.166 --> 00:12:31.386
And this is it, and if you want

00:12:31.436 --> 00:12:32.816
to add sharing to other users,

00:12:32.816 --> 00:12:33.886
it is possible for a [inaudible]

00:12:33.886 --> 00:12:34.486
APIs.

00:12:34.486 --> 00:12:36.326
If you haven't looked into

00:12:36.356 --> 00:12:38.076
CloudKit before, it's great time

00:12:38.376 --> 00:12:39.366
to go have a look at the

00:12:39.366 --> 00:12:40.656
documentation and see how

00:12:40.656 --> 00:12:42.046
powerful it can be for you.

00:12:42.046 --> 00:12:45.326
Now, with this, we talked about

00:12:45.326 --> 00:12:47.846
protecting data inside of

00:12:47.846 --> 00:12:49.876
devices, share it across

00:12:49.876 --> 00:12:52.626
devices, even devices from

00:12:52.626 --> 00:12:55.756
another user, what when you want

00:12:55.756 --> 00:12:57.086
it done on data from your own

00:12:57.086 --> 00:12:58.206
server for example.

00:12:59.436 --> 00:13:00.986
Where for that you want to

00:13:00.986 --> 00:13:02.276
establish a secure connection.

00:13:03.556 --> 00:13:04.646
A secure connection is really,

00:13:04.646 --> 00:13:06.956
really important because it

00:13:07.126 --> 00:13:08.916
helps guaranteeing the

00:13:08.916 --> 00:13:10.376
confidentiality of all of the

00:13:10.376 --> 00:13:12.076
information that the user is

00:13:12.076 --> 00:13:12.826
accessing through your

00:13:12.826 --> 00:13:14.896
application as well as guarantee

00:13:14.896 --> 00:13:16.676
the trustworthiness of that

00:13:16.676 --> 00:13:18.066
information, make sure it does

00:13:18.066 --> 00:13:18.976
not be tampered with.

00:13:21.226 --> 00:13:22.346
And the first thing you should

00:13:22.346 --> 00:13:23.936
not do here again, you're just

00:13:23.936 --> 00:13:25.266
trying to use your custom own

00:13:25.266 --> 00:13:25.696
protocol.

00:13:26.296 --> 00:13:27.776
There is a great solution.

00:13:28.626 --> 00:13:29.696
It's a standard solution.

00:13:30.946 --> 00:13:32.446
Transport Layer Security.

00:13:33.236 --> 00:13:35.206
And it's really easy to use on

00:13:35.206 --> 00:13:35.826
our platforms.

00:13:36.246 --> 00:13:37.966
We have two great APIs that make

00:13:37.966 --> 00:13:39.096
that really easy.

00:13:39.906 --> 00:13:41.076
The first one is network

00:13:41.076 --> 00:13:42.796
framework, which you may have

00:13:42.796 --> 00:13:44.156
discovered last year with a

00:13:44.156 --> 00:13:46.316
great talk at WWDC.

00:13:47.036 --> 00:13:48.946
The second one is URL Sessions,

00:13:49.286 --> 00:13:51.356
which you may know about as part

00:13:51.356 --> 00:13:53.236
of the App Transport Security.

00:13:55.116 --> 00:13:56.726
For URL Session, the only thing

00:13:56.726 --> 00:13:59.816
you need to do is use an https

00:14:00.656 --> 00:14:00.986
TPS endpoint.

00:14:00.986 --> 00:14:02.926
In either of those cases, it

00:14:03.786 --> 00:14:07.106
relies on [inaudible] TLS with

00:14:07.866 --> 00:14:09.496
great defaults underneath.

00:14:10.336 --> 00:14:12.876
Defaults ensures [inaudible] to

00:14:13.436 --> 00:14:14.676
provide strong security

00:14:14.966 --> 00:14:16.486
including [inaudible] secrecy as

00:14:16.556 --> 00:14:18.796
well as the algorithm that would

00:14:18.796 --> 00:14:20.656
be the most efficient on Apple

00:14:20.656 --> 00:14:21.276
products.

00:14:21.816 --> 00:14:24.576
Or implementation of TLS also

00:14:26.156 --> 00:14:28.086
use TLS 1.3 by default.

00:14:28.086 --> 00:14:30.766
If you're not familiar with TLS

00:14:30.766 --> 00:14:32.936
1.3, it has a lot of

00:14:32.936 --> 00:14:34.596
improvements from the previous

00:14:34.596 --> 00:14:37.446
revisions, a lot better security

00:14:37.726 --> 00:14:39.156
and even better efficiency by

00:14:39.156 --> 00:14:40.236
reducing some of those run

00:14:41.096 --> 00:14:41.246
trips.

00:14:42.996 --> 00:14:45.166
If you are not using TLS 1.3,

00:14:46.026 --> 00:14:46.876
please go ahead and try to

00:14:46.876 --> 00:14:48.816
deploy that on your servers and

00:14:48.816 --> 00:14:50.526
without any change of the

00:14:50.526 --> 00:14:51.556
[inaudible] application, you

00:14:51.556 --> 00:14:52.846
will have the benefit of it in

00:14:52.846 --> 00:14:53.826
your app.

00:14:55.456 --> 00:14:56.836
And now, to show you it's really

00:14:56.836 --> 00:14:58.936
easy, I have two examples to

00:14:58.936 --> 00:15:01.206
show you with Network Framework

00:15:02.026 --> 00:15:04.016
and URL Session, but before

00:15:04.016 --> 00:15:05.586
jumping into those, I want to

00:15:05.586 --> 00:15:06.826
highlight that Secure Transport

00:15:07.096 --> 00:15:08.376
is not the recommended way

00:15:08.376 --> 00:15:10.886
anymore, and we ask you to

00:15:10.886 --> 00:15:12.576
migrate to Network Framework and

00:15:12.576 --> 00:15:13.776
URL Sessions if you're already

00:15:13.776 --> 00:15:14.776
using Secure Transport.

00:15:15.686 --> 00:15:17.186
With that, here's a couple of

00:15:17.186 --> 00:15:17.806
examples.

00:15:18.776 --> 00:15:20.896
With Network Framework, when you

00:15:20.896 --> 00:15:22.676
establish a connection, the only

00:15:22.676 --> 00:15:24.926
thing you need to do is using

00:15:25.006 --> 00:15:27.926
:.tls, and here we go, you add

00:15:27.926 --> 00:15:30.516
that TLS connection, providing

00:15:30.516 --> 00:15:32.226
great security and performance.

00:15:33.296 --> 00:15:35.356
For URL Session, the only thing

00:15:35.356 --> 00:15:38.186
here, it's https endpoint, and

00:15:38.236 --> 00:15:40.866
this is it.

00:15:41.136 --> 00:15:43.636
In some situation, you may not

00:15:44.286 --> 00:15:45.736
have the possibility to use TLS.

00:15:45.986 --> 00:15:47.566
For example, if you have trying

00:15:47.566 --> 00:15:49.876
to secure data through a content

00:15:49.876 --> 00:15:51.356
delivery network, for example.

00:15:52.146 --> 00:15:54.116
In this case, you manage those

00:15:54.116 --> 00:15:56.296
certificates, and for

00:15:56.456 --> 00:15:59.606
certificates, one of the things

00:15:59.606 --> 00:16:01.816
to avoid is using it on parser

00:16:01.816 --> 00:16:02.896
or trying to take a parser you

00:16:02.896 --> 00:16:04.416
find somewhere on a website.

00:16:05.066 --> 00:16:06.626
Parsers are incredibly

00:16:06.626 --> 00:16:08.606
vulnerable by providing a great

00:16:08.606 --> 00:16:09.526
attack exposure.

00:16:10.956 --> 00:16:12.026
They're critical.

00:16:13.216 --> 00:16:15.866
On a platform, we have SecTrust

00:16:15.866 --> 00:16:16.286
for that.

00:16:17.126 --> 00:16:18.466
SecTrust provides you an easy

00:16:18.466 --> 00:16:20.436
way to validate the certificate

00:16:21.056 --> 00:16:22.286
against a trust policy.

00:16:23.086 --> 00:16:24.286
The trust policy may contain

00:16:24.286 --> 00:16:26.096
information about expiration,

00:16:27.006 --> 00:16:29.786
revocation, and until

00:16:29.786 --> 00:16:31.666
certificate has been validated,

00:16:31.836 --> 00:16:36.386
you know that you can use a key.

00:16:36.636 --> 00:16:38.196
Note that if using TLS you don't

00:16:38.196 --> 00:16:40.056
have a need to worry about

00:16:40.056 --> 00:16:40.566
certificate.

00:16:40.736 --> 00:16:42.236
It's all handled for you

00:16:42.696 --> 00:16:43.326
underneath.

00:16:43.886 --> 00:16:47.546
Now, in this release, we're

00:16:47.546 --> 00:16:49.606
happy to introduce a new

00:16:49.606 --> 00:16:51.846
function in SecTrust.

00:16:52.716 --> 00:16:54.256
This new function combines two

00:16:54.256 --> 00:16:56.426
things you were able to do

00:16:56.426 --> 00:16:56.686
before.

00:16:57.286 --> 00:16:58.476
On one hand, it's a function,

00:16:58.476 --> 00:17:00.206
which allows to asynchronously

00:17:00.656 --> 00:17:02.796
through an explicit action, do a

00:17:02.796 --> 00:17:04.806
certificate validation so that

00:17:04.806 --> 00:17:06.026
your application can do

00:17:06.026 --> 00:17:07.336
something else while the

00:17:07.336 --> 00:17:09.026
certificate is being validated.

00:17:09.626 --> 00:17:11.925
But also this function gives you

00:17:11.925 --> 00:17:13.026
a richer handling.

00:17:13.685 --> 00:17:15.996
So, as a developer, you know

00:17:16.705 --> 00:17:18.726
what is going on in case of

00:17:18.776 --> 00:17:20.665
failure, and you can debug it.

00:17:21.306 --> 00:17:22.675
But also, you can build logic

00:17:22.675 --> 00:17:25.215
into your application to respond

00:17:25.215 --> 00:17:26.556
to different error scenarios.

00:17:27.146 --> 00:17:29.086
So this new function is going to

00:17:29.086 --> 00:17:30.736
make things even more convenient

00:17:30.736 --> 00:17:31.856
and easier for you to debug.

00:17:31.856 --> 00:17:33.046
We're looking forward to you

00:17:33.046 --> 00:17:34.106
adopting it.

00:17:34.656 --> 00:17:37.626
So, with this, I just walked you

00:17:37.626 --> 00:17:40.336
through a set of five different

00:17:40.336 --> 00:17:42.466
scenarios for which we have

00:17:42.836 --> 00:17:44.976
really easy to use solutions,

00:17:45.456 --> 00:17:47.536
which provide great security by

00:17:47.536 --> 00:17:50.186
defaults or you're only a few

00:17:50.186 --> 00:17:52.756
attributes away from great

00:17:52.756 --> 00:17:53.306
security.

00:17:53.876 --> 00:17:57.546
And here again, we benefit from

00:17:58.156 --> 00:17:59.326
deep integration with the

00:17:59.326 --> 00:18:00.756
hardware to provide security

00:18:00.816 --> 00:18:02.326
features which otherwise are

00:18:02.326 --> 00:18:03.396
very challenging to provide.

00:18:04.026 --> 00:18:06.646
So, in any of the scenarios,

00:18:06.906 --> 00:18:09.496
when you encounter them, go

00:18:09.496 --> 00:18:10.406
ahead and use the system

00:18:10.406 --> 00:18:11.986
frameworks, and if you already

00:18:11.986 --> 00:18:13.296
do, go ahead and make sure

00:18:13.296 --> 00:18:14.016
you're using those best

00:18:14.016 --> 00:18:14.936
attributes so that you can

00:18:14.936 --> 00:18:17.656
protect users and business

00:18:17.656 --> 00:18:19.466
assets the best possible way.

00:18:20.086 --> 00:18:24.056
And we understand that in some

00:18:24.056 --> 00:18:26.186
situations it may not be

00:18:26.186 --> 00:18:28.386
practical for you to use the

00:18:28.386 --> 00:18:29.216
system features.

00:18:29.746 --> 00:18:32.556
For example, you may need to

00:18:32.926 --> 00:18:35.236
have interoperability outside of

00:18:35.236 --> 00:18:35.726
the [inaudible] system.

00:18:35.856 --> 00:18:38.626
You may to authenticate with

00:18:38.626 --> 00:18:41.936
your service or simply you're

00:18:41.936 --> 00:18:44.096
given a specification you will

00:18:44.096 --> 00:18:46.386
need to implement.

00:18:46.386 --> 00:18:49.536
For all of these cases, we now

00:18:49.536 --> 00:18:50.766
have a great solution for you.

00:18:51.976 --> 00:18:53.006
Apple CryptoKit.

00:18:53.936 --> 00:18:57.026
Apple CryptoKit is new Swift

00:18:57.096 --> 00:18:59.576
cryptographic API which has been

00:18:59.576 --> 00:19:00.956
designed to follow the same

00:19:00.956 --> 00:19:02.866
philosophy as for those features

00:19:02.866 --> 00:19:05.396
we talked about and give you an

00:19:05.396 --> 00:19:06.886
easy access to cryptographic

00:19:06.886 --> 00:19:09.616
functions and hard to misuse

00:19:09.616 --> 00:19:10.096
functions.

00:19:11.006 --> 00:19:13.146
We're really excited to give

00:19:13.146 --> 00:19:14.966
that in this release.

00:19:16.106 --> 00:19:17.766
And now, I'm going to hand over

00:19:17.886 --> 00:19:18.916
to Frederic who is going to tell

00:19:18.916 --> 00:19:20.136
you all about this exciting new

00:19:20.136 --> 00:19:20.386
API.

00:19:21.076 --> 00:19:22.306
So please join me in welcoming

00:19:22.306 --> 00:19:22.976
Frederic on stage.

00:19:23.516 --> 00:19:29.546
[ Applause ]

00:19:30.046 --> 00:19:30.846
>> Thanks Yannick.

00:19:31.776 --> 00:19:32.386
Hello everyone.

00:19:32.796 --> 00:19:34.946
My name is Frederic Jacobs, and

00:19:34.946 --> 00:19:36.526
I'm working on the Cryptographic

00:19:36.526 --> 00:19:37.936
Engineering Team here at Apple.

00:19:38.646 --> 00:19:40.536
I'm excited to tell you more

00:19:40.536 --> 00:19:42.546
today about Apple CryptoKit.

00:19:43.386 --> 00:19:44.866
We think you're really going to

00:19:44.866 --> 00:19:46.676
like implementing cryptographic

00:19:46.676 --> 00:19:49.346
protocols in Swift.

00:19:49.396 --> 00:19:51.786
There are four aspects of Apple

00:19:51.786 --> 00:19:53.376
CryptoKit I would like to share

00:19:53.376 --> 00:19:54.346
with you this afternoon.

00:19:55.216 --> 00:19:57.596
First, we are going to talk

00:19:57.786 --> 00:19:59.656
about CryptoKit and Swift.

00:20:00.876 --> 00:20:03.876
Second, we will talk about the

00:20:03.876 --> 00:20:06.016
curated set of algorithms that

00:20:06.016 --> 00:20:07.566
is available in CryptoKit.

00:20:08.556 --> 00:20:11.016
Third, we are going to discuss

00:20:11.126 --> 00:20:14.146
about the Secure Enclave and

00:20:14.146 --> 00:20:16.016
biometric authentication, and

00:20:16.586 --> 00:20:18.136
finally, we'll talk about

00:20:18.186 --> 00:20:18.746
performance.

00:20:19.706 --> 00:20:21.006
Let's dive right in.

00:20:22.096 --> 00:20:23.806
In the past, you might have had

00:20:23.856 --> 00:20:25.556
to write code that looks like

00:20:25.556 --> 00:20:28.726
this when you were calling into

00:20:28.726 --> 00:20:30.366
C crypto API from Swift.

00:20:31.126 --> 00:20:33.326
You had to allocate buffers,

00:20:33.596 --> 00:20:34.806
figure out for each of the

00:20:34.806 --> 00:20:36.706
buffers what size it had to be,

00:20:37.406 --> 00:20:39.576
and there were values such as

00:20:39.576 --> 00:20:42.246
the nonce that you might have to

00:20:42.246 --> 00:20:44.456
search what the safe value for

00:20:44.456 --> 00:20:45.366
that value was.

00:20:46.326 --> 00:20:47.836
And then you have all of these

00:20:47.836 --> 00:20:50.406
nested calls into the encryption

00:20:50.406 --> 00:20:52.746
function where you're passing

00:20:52.746 --> 00:20:54.346
pointers, and there are no

00:20:54.346 --> 00:20:56.556
argument labels that help you

00:20:56.846 --> 00:20:58.996
figure out which pointer needs

00:20:58.996 --> 00:21:01.426
to go into which argument.

00:21:02.306 --> 00:21:04.716
In contrast, with Apple

00:21:04.716 --> 00:21:07.556
CryptoKit, you can do exactly

00:21:07.556 --> 00:21:09.246
the same operation with a single

00:21:09.246 --> 00:21:09.836
line of code.

00:21:11.086 --> 00:21:12.696
In this-- isn't this cool?

00:21:13.516 --> 00:21:18.506
[ Applause ]

00:21:19.006 --> 00:21:21.746
So, in order to do so, you're

00:21:21.746 --> 00:21:23.036
passing the data you want to

00:21:23.036 --> 00:21:24.666
encrypt to cipher.

00:21:24.786 --> 00:21:26.836
In this case we're using

00:21:26.836 --> 00:21:29.536
AES.GCM, and you're using the

00:21:29.536 --> 00:21:31.616
key you want to encrypt the data

00:21:31.616 --> 00:21:34.716
with and that's it.

00:21:35.926 --> 00:21:38.276
Something else you might have

00:21:38.276 --> 00:21:40.016
had to do is generating your own

00:21:40.016 --> 00:21:42.036
cryptographic key when you were

00:21:42.036 --> 00:21:43.826
calling into a C crypto API from

00:21:43.826 --> 00:21:44.146
Swift.

00:21:44.766 --> 00:21:46.796
And that involved first

00:21:47.116 --> 00:21:48.646
converting a number of bits and

00:21:48.646 --> 00:21:50.456
bytes because cryptographic keys

00:21:50.456 --> 00:21:52.996
are commonly expressed in bits.

00:21:54.066 --> 00:21:56.446
Then you have to allocate a

00:21:56.446 --> 00:22:01.416
buffer for that amount of bytes

00:22:01.576 --> 00:22:03.576
and use the system, random

00:22:03.576 --> 00:22:05.606
number generator to fill that

00:22:05.666 --> 00:22:08.096
buffer with cryptographically

00:22:08.096 --> 00:22:09.556
secure random numbers.

00:22:11.216 --> 00:22:14.606
Then, if an error occurred you

00:22:14.606 --> 00:22:15.666
had to handle that.

00:22:16.726 --> 00:22:19.646
You're then finally ready to use

00:22:19.646 --> 00:22:22.816
that key, and when you're done

00:22:22.816 --> 00:22:24.706
with that key, you don't have to

00:22:24.706 --> 00:22:27.556
forget to zeroize it to remove

00:22:27.556 --> 00:22:28.216
it from memory.

00:22:28.836 --> 00:22:32.956
In contrast the CryptoKit,

00:22:32.956 --> 00:22:34.986
generating a key is just a

00:22:34.986 --> 00:22:37.906
single line of code.

00:22:38.636 --> 00:22:40.376
You call the SymmetricKey

00:22:40.906 --> 00:22:42.796
initializer, and you pass the

00:22:42.796 --> 00:22:45.386
number of bits you want the key

00:22:45.386 --> 00:22:45.836
to hold.

00:22:50.096 --> 00:22:52.666
We're able to zeroize this key

00:22:52.666 --> 00:22:55.966
on release for you because

00:22:56.566 --> 00:22:58.916
knowing about the auto reference

00:22:58.916 --> 00:23:02.626
counting of this value whenever

00:23:03.096 --> 00:23:04.806
it is getting deallocated, we're

00:23:04.806 --> 00:23:09.246
zeroizing that buffer for you.

00:23:09.456 --> 00:23:11.376
So, CryptoKit and Swift.

00:23:12.266 --> 00:23:15.426
We have a strongly typed API,

00:23:16.366 --> 00:23:18.726
and whenever you're initializing

00:23:19.426 --> 00:23:22.436
a value, we are verifying that

00:23:22.436 --> 00:23:24.826
the data you're passing is a

00:23:25.076 --> 00:23:26.596
strong value for that argument.

00:23:28.116 --> 00:23:32.706
Thanks to Swift's memory

00:23:32.706 --> 00:23:34.506
management model, we're able to

00:23:34.946 --> 00:23:38.376
zeroize on release all of the

00:23:38.376 --> 00:23:40.156
secret values allocated within

00:23:40.156 --> 00:23:40.656
CryptoKit.

00:23:41.986 --> 00:23:43.646
We perform equitable

00:23:43.646 --> 00:23:46.846
conformances for values like

00:23:47.066 --> 00:23:49.416
message authentication code if

00:23:49.736 --> 00:23:50.746
you're familiar with that

00:23:50.746 --> 00:23:52.756
content so that you're able to

00:23:52.756 --> 00:23:53.966
verify two-message

00:23:53.966 --> 00:23:56.006
authentication codes in constant

00:23:56.006 --> 00:23:58.786
time by just using the equals

00:23:58.786 --> 00:23:59.866
equals operator.

00:24:03.556 --> 00:24:06.516
CryptoKit also defines protocols

00:24:06.806 --> 00:24:09.296
so that you can write generic

00:24:09.296 --> 00:24:12.336
code over a hash function H, and

00:24:12.426 --> 00:24:14.176
if in multiple places of your

00:24:14.176 --> 00:24:16.136
code base you have to pass

00:24:16.136 --> 00:24:17.656
different hash functions, you

00:24:17.656 --> 00:24:19.346
can write the code once and then

00:24:19.496 --> 00:24:21.036
parametrize the function call on

00:24:21.036 --> 00:24:21.976
a different hash function.

00:24:24.776 --> 00:24:27.456
So, we talked about CryptoKit

00:24:27.456 --> 00:24:29.836
and Swift, and now I want to

00:24:29.836 --> 00:24:32.996
dive into the curated set of

00:24:33.066 --> 00:24:36.166
algorithms that is supported in

00:24:36.166 --> 00:24:36.716
CryptoKit.

00:24:37.756 --> 00:24:40.716
All algorithms are standard and

00:24:40.716 --> 00:24:41.896
peer-reviewed algorithms.

00:24:42.526 --> 00:24:45.726
Let's see what's available in

00:24:45.726 --> 00:24:46.216
CryptoKit.

00:24:47.716 --> 00:24:49.066
We have support for hash

00:24:49.066 --> 00:24:51.276
functions, message

00:24:51.276 --> 00:24:53.056
authentication codes,

00:24:53.696 --> 00:24:56.796
authenticated encryption, key

00:24:57.026 --> 00:25:01.126
agreement, and signatures.

00:25:02.876 --> 00:25:05.096
Some of these algorithms are

00:25:05.096 --> 00:25:06.686
algorithms we have supported

00:25:06.686 --> 00:25:09.316
before in frameworks such as

00:25:09.316 --> 00:25:11.576
Common Crypto or SecKey, but

00:25:11.576 --> 00:25:13.136
some of these algorithms are

00:25:13.136 --> 00:25:14.546
algorithms we're supporting for

00:25:14.546 --> 00:25:15.206
the first time.

00:25:15.726 --> 00:25:17.206
Those are highlighted in green

00:25:17.206 --> 00:25:17.816
on the slide.

00:25:18.466 --> 00:25:21.656
Note that we also have an

00:25:21.656 --> 00:25:22.596
insecure module.

00:25:23.936 --> 00:25:27.216
This module provides algorithms

00:25:27.216 --> 00:25:30.776
such as MD5 and SHA1 so that you

00:25:30.776 --> 00:25:32.806
can adopt CryptoKit even if you

00:25:32.806 --> 00:25:35.356
need to be using some algorithms

00:25:35.356 --> 00:25:37.356
that no longer meet the best

00:25:37.446 --> 00:25:38.526
security standards.

00:25:42.836 --> 00:25:46.306
Let's focus on a few examples to

00:25:46.636 --> 00:25:47.986
see how CryptoKit works.

00:25:48.806 --> 00:25:50.356
Let's start with hash functions.

00:25:50.926 --> 00:25:53.406
Hash functions produced

00:25:53.406 --> 00:25:56.456
deterministic fixed-size output

00:25:56.616 --> 00:25:58.816
that is called a digest, and

00:25:58.996 --> 00:26:01.526
unlike hashable in Swift, hash

00:26:01.526 --> 00:26:04.326
functions in CryptoKit provide

00:26:04.726 --> 00:26:06.636
cryptographic properties such as

00:26:06.716 --> 00:26:07.686
collision resistance.

00:26:08.626 --> 00:26:10.876
This means that it is hard to

00:26:10.876 --> 00:26:13.426
find two inputs that will hash

00:26:13.466 --> 00:26:16.986
to the same digest.

00:26:16.986 --> 00:26:19.606
In order to compute the hash, it

00:26:19.606 --> 00:26:22.926
is as easy as calling the hash

00:26:22.926 --> 00:26:24.976
method on the hash function you

00:26:24.976 --> 00:26:27.386
want to use, passing the data

00:26:27.386 --> 00:26:28.166
you want to hash.

00:26:29.196 --> 00:26:32.016
Here, I have some audio data I

00:26:32.016 --> 00:26:35.496
want to hash, and I use the

00:26:35.496 --> 00:26:38.636
SHA256 hash function to compute

00:26:38.636 --> 00:26:38.976
a digest.

00:26:42.906 --> 00:26:45.146
If you're streaming a file, you

00:26:45.146 --> 00:26:47.086
might be reading it from an

00:26:47.086 --> 00:26:47.676
input stream.

00:26:49.096 --> 00:26:50.416
In that case, you want to

00:26:50.416 --> 00:26:53.216
compute the digest

00:26:53.216 --> 00:26:53.906
incrementally.

00:26:55.096 --> 00:26:57.566
You start by initializing a

00:26:57.566 --> 00:26:59.836
hasher by calling the MT

00:26:59.836 --> 00:27:01.336
initializer on the hash

00:27:01.336 --> 00:27:01.746
function.

00:27:02.236 --> 00:27:07.016
You then pass the data you want

00:27:07.016 --> 00:27:09.146
to hash, and you call the update

00:27:09.146 --> 00:27:11.286
method one or multiple times in

00:27:11.286 --> 00:27:14.516
order to do so.

00:27:14.756 --> 00:27:17.966
And when you want the digest to

00:27:17.966 --> 00:27:20.446
be computed, you just call the

00:27:20.446 --> 00:27:22.226
finalize method on the hash for

00:27:22.226 --> 00:27:23.916
instance, and that will return

00:27:23.916 --> 00:27:24.466
the digest.

00:27:24.886 --> 00:27:29.396
Next, let's talk about

00:27:29.636 --> 00:27:30.886
authenticated encryption.

00:27:31.716 --> 00:27:33.456
This is something you've long

00:27:33.456 --> 00:27:34.446
been asking for.

00:27:35.106 --> 00:27:37.496
As its name suggests, it

00:27:37.496 --> 00:27:39.326
provides both authentication and

00:27:39.326 --> 00:27:39.896
encryption.

00:27:41.436 --> 00:27:44.146
The lack of authentication in

00:27:44.146 --> 00:27:46.686
cryptographic protocols can lead

00:27:46.686 --> 00:27:49.276
to a variety of attacks, and

00:27:49.836 --> 00:27:51.316
manually combining

00:27:51.436 --> 00:27:53.636
authentication with encryption

00:27:54.356 --> 00:27:56.266
can lead to things like padding

00:27:56.266 --> 00:27:58.076
oracle attacks.

00:27:58.436 --> 00:28:00.586
So, instead we're really happy

00:28:00.656 --> 00:28:02.426
to provide it to you as a single

00:28:02.426 --> 00:28:03.036
API call.

00:28:07.076 --> 00:28:08.846
I'm working on the site project.

00:28:09.096 --> 00:28:10.586
It's a hiking app.

00:28:11.216 --> 00:28:12.786
Most of the content on the app

00:28:12.786 --> 00:28:15.316
is free, but there's additional

00:28:15.316 --> 00:28:17.006
content you can purchase through

00:28:17.006 --> 00:28:21.276
the in-app purchase.

00:28:21.386 --> 00:28:22.876
Once you purchase the content,

00:28:23.216 --> 00:28:24.696
you can retrieve the additional

00:28:24.696 --> 00:28:25.156
content.

00:28:26.576 --> 00:28:27.936
I'm using a content delivery

00:28:27.936 --> 00:28:29.706
network in order to keep the

00:28:29.706 --> 00:28:32.516
downloads fast, as my user base

00:28:32.556 --> 00:28:32.776
grows.

00:28:35.436 --> 00:28:37.776
In order to obtain the content,

00:28:38.026 --> 00:28:41.366
I first check with my server if

00:28:41.366 --> 00:28:44.976
the in-app purchase is valid.

00:28:45.596 --> 00:28:49.706
Then, the key is retrieved from

00:28:49.706 --> 00:28:50.966
the server and passed on the

00:28:50.966 --> 00:28:51.296
phone.

00:28:52.656 --> 00:28:54.836
I download the encrypted data

00:28:55.136 --> 00:28:56.286
from the content delivery

00:28:56.286 --> 00:29:00.686
network, and I use the key in

00:29:00.686 --> 00:29:02.326
order to decrypt the encrypted

00:29:02.326 --> 00:29:02.736
content.

00:29:03.136 --> 00:29:06.346
And if the key is right, and the

00:29:06.346 --> 00:29:08.276
data wasn't tampered with on the

00:29:08.276 --> 00:29:10.816
content delivery network, I'm

00:29:10.866 --> 00:29:12.696
able to retrieve the map data.

00:29:13.306 --> 00:29:17.376
Let's see how this translates to

00:29:19.056 --> 00:29:19.166
code.

00:29:19.336 --> 00:29:22.166
First, we start by initializing

00:29:22.166 --> 00:29:24.366
a SymmetricKey from the key data

00:29:24.366 --> 00:29:26.696
that was retrieved from the

00:29:28.856 --> 00:29:29.036
server.

00:29:29.186 --> 00:29:31.256
Then we are initializing a

00:29:31.256 --> 00:29:31.976
sealed box.

00:29:32.996 --> 00:29:35.576
In this case, it doesn't really

00:29:35.576 --> 00:29:37.246
matter what's in the sealed box,

00:29:37.306 --> 00:29:39.216
but know that if you're working

00:29:39.556 --> 00:29:42.106
on implementing a specification

00:29:42.106 --> 00:29:44.066
that requires you to combine the

00:29:44.066 --> 00:29:46.146
nonce, the cipher text and the

00:29:46.146 --> 00:29:48.286
tag in a specific way, you can

00:29:48.286 --> 00:29:49.986
use the sealed box to do that.

00:29:50.816 --> 00:29:52.216
If you're implementing a

00:29:52.216 --> 00:29:54.446
protocol that requires you to

00:29:54.446 --> 00:29:57.146
pass specific nonce values we're

00:29:57.366 --> 00:29:59.176
also able to support that.

00:29:59.336 --> 00:30:01.376
But, in this example, we'll

00:30:01.416 --> 00:30:02.676
focus on the simple case.

00:30:04.096 --> 00:30:06.216
So, we're passing the downloaded

00:30:06.216 --> 00:30:08.086
data as a combined

00:30:08.086 --> 00:30:09.636
representation to the sealed

00:30:09.636 --> 00:30:12.156
box, and now that we have a box,

00:30:12.896 --> 00:30:15.496
we can simply open it by calling

00:30:15.496 --> 00:30:18.936
the open method on the cipher.

00:30:19.566 --> 00:30:22.816
And we're passing the key.

00:30:23.426 --> 00:30:23.976
It's that easy.

00:30:26.916 --> 00:30:28.366
Next, let's talk about

00:30:28.366 --> 00:30:28.896
signatures.

00:30:30.196 --> 00:30:31.946
Signatures are used to

00:30:31.946 --> 00:30:34.036
authenticate data using a

00:30:34.036 --> 00:30:36.616
private key, and using the

00:30:36.616 --> 00:30:38.926
signature, we are able to verify

00:30:38.926 --> 00:30:41.106
data using the associated public

00:30:41.166 --> 00:30:41.346
key.

00:30:41.866 --> 00:30:45.856
Let's take an example where we

00:30:45.856 --> 00:30:47.846
want to use the signature in

00:30:47.846 --> 00:30:49.366
order to authorize and

00:30:49.366 --> 00:30:49.976
operation.

00:30:50.796 --> 00:30:54.496
The operation here can be a

00:30:54.496 --> 00:30:56.866
two-factor log-in or some

00:30:56.916 --> 00:30:58.916
sensitive transaction such as

00:30:58.916 --> 00:31:00.866
wiring money to another user of

00:31:00.866 --> 00:31:01.536
the application.

00:31:03.666 --> 00:31:07.096
In order to do so, we start by

00:31:07.406 --> 00:31:08.976
generating a private key on the

00:31:08.976 --> 00:31:09.466
device.

00:31:10.956 --> 00:31:12.566
We then retrieve the associated

00:31:12.566 --> 00:31:13.246
public key.

00:31:13.816 --> 00:31:16.666
The associated public key is

00:31:16.666 --> 00:31:20.826
registered with your service,

00:31:20.956 --> 00:31:24.016
and once we want to perform that

00:31:24.016 --> 00:31:25.926
operation, we're using the

00:31:25.926 --> 00:31:27.536
private key to generate the

00:31:27.536 --> 00:31:29.516
signature on the transaction

00:31:29.516 --> 00:31:33.056
data and then sending over the

00:31:33.056 --> 00:31:34.226
transaction data and the

00:31:34.226 --> 00:31:35.456
signature to the server.

00:31:36.866 --> 00:31:40.566
The server will verify that the

00:31:40.566 --> 00:31:44.686
signature is correct, and if the

00:31:44.686 --> 00:31:47.636
signature is right, it will

00:31:47.636 --> 00:31:51.276
proceed to doing the operation.

00:31:51.756 --> 00:31:54.806
Let's see what this code looks

00:31:54.806 --> 00:31:54.976
like.

00:31:54.976 --> 00:31:57.676
In order to generate a

00:31:57.676 --> 00:32:00.066
cryptographically strong private

00:32:00.066 --> 00:32:02.896
key, we call the PrivateKey

00:32:02.896 --> 00:32:03.566
initializer.

00:32:06.876 --> 00:32:09.546
Then we want to register some

00:32:09.546 --> 00:32:11.316
public key data on the server.

00:32:12.176 --> 00:32:14.556
We start by retrieving the

00:32:14.806 --> 00:32:17.506
public key by just calling

00:32:17.596 --> 00:32:19.326
public key on the private key,

00:32:19.956 --> 00:32:24.536
and then we want to say what

00:32:24.596 --> 00:32:26.766
representation we want to get

00:32:27.156 --> 00:32:28.346
from the public key.

00:32:29.026 --> 00:32:30.546
Multiple representations of

00:32:30.546 --> 00:32:32.406
public keys exist, and we have

00:32:32.456 --> 00:32:35.916
support in CryptoKit for a lot

00:32:35.916 --> 00:32:36.216
of them.

00:32:37.536 --> 00:32:39.886
In this case, we're taking the

00:32:39.886 --> 00:32:41.106
compact representation.

00:32:41.776 --> 00:32:44.106
As always, we're storing the

00:32:44.106 --> 00:32:45.586
private key in the Keychain.

00:32:46.676 --> 00:32:48.996
Sample code in order to do that

00:32:48.996 --> 00:32:50.236
will be available on the

00:32:50.236 --> 00:32:51.266
developer portal.

00:32:51.266 --> 00:32:54.946
In order to produce the

00:32:54.946 --> 00:32:57.456
signature, we are calling the

00:32:57.516 --> 00:32:59.346
signature method on the private

00:32:59.346 --> 00:33:02.446
key, and we're passing the

00:33:02.446 --> 00:33:03.796
transaction data we wish to

00:33:03.796 --> 00:33:05.486
sign, and this returns the

00:33:05.486 --> 00:33:05.926
signature.

00:33:09.136 --> 00:33:13.126
Now, this key that protects

00:33:13.266 --> 00:33:16.416
these operations is of high

00:33:16.416 --> 00:33:19.366
value, so we want to give it the

00:33:19.366 --> 00:33:21.416
best security it can.

00:33:21.906 --> 00:33:23.316
That's where the Secure Enclave

00:33:23.396 --> 00:33:23.846
comes in.

00:33:25.716 --> 00:33:27.726
The Secure Enclave is s

00:33:27.726 --> 00:33:29.156
hardware-based key manager

00:33:29.466 --> 00:33:30.886
that's isolated from the main

00:33:30.886 --> 00:33:32.816
processor to provide an extra

00:33:32.816 --> 00:33:33.766
layer of security.

00:33:34.466 --> 00:33:36.316
It is used as part of critical

00:33:36.316 --> 00:33:38.106
system features, such as Touch

00:33:38.106 --> 00:33:39.606
ID or Face ID.

00:33:41.336 --> 00:33:45.186
Let's see how to improve on or

00:33:45.186 --> 00:33:48.156
code that uses signatures to

00:33:48.156 --> 00:33:49.576
take advantage of the Secure

00:33:49.576 --> 00:33:49.986
Enclave.

00:33:50.596 --> 00:33:54.726
We start by checking if a Secure

00:33:54.726 --> 00:33:56.186
Enclave is available on the

00:33:56.186 --> 00:33:56.496
device.

00:33:57.206 --> 00:34:00.476
We do so by calling isAvailable

00:34:00.476 --> 00:34:01.446
on SecureEnclave.

00:34:01.936 --> 00:34:07.286
And from there, we can use

00:34:07.286 --> 00:34:09.565
exactly the same code as before

00:34:10.886 --> 00:34:14.356
in order to produce, to generate

00:34:14.356 --> 00:34:15.516
the key and produce the

00:34:15.516 --> 00:34:17.696
signature within the Secure

00:34:17.696 --> 00:34:18.076
Enclave.

00:34:18.606 --> 00:34:20.966
Note that in order to do so, we

00:34:21.016 --> 00:34:24.656
simply prefix or call to the

00:34:24.656 --> 00:34:27.985
PrivateKey initializer call that

00:34:27.985 --> 00:34:30.016
generates the key, and we prefix

00:34:30.016 --> 00:34:31.356
it with Secure Enclave dot.

00:34:32.596 --> 00:34:34.735
It's that easy to take advantage

00:34:34.835 --> 00:34:35.746
of the Secure Enclave.

00:34:37.755 --> 00:34:41.646
An advantage of using the Secure

00:34:41.646 --> 00:34:43.456
Enclave is that you can

00:34:43.456 --> 00:34:44.536
constrain key usage.

00:34:45.096 --> 00:34:48.045
In this case, we want to say

00:34:48.045 --> 00:34:50.126
that the key that we're

00:34:50.126 --> 00:34:51.755
generating on the Secure Enclave

00:34:52.656 --> 00:34:54.866
is only accessible when the

00:34:54.866 --> 00:34:58.596
device is unlocked and that this

00:34:58.596 --> 00:35:01.026
key will be available on this

00:35:01.026 --> 00:35:01.786
device only.

00:35:02.886 --> 00:35:04.706
We can further constrain key

00:35:04.706 --> 00:35:06.816
usage by saying that when we're

00:35:06.816 --> 00:35:09.556
performing an operation with the

00:35:09.556 --> 00:35:11.566
private key, we want to require

00:35:11.566 --> 00:35:12.326
user presence.

00:35:13.496 --> 00:35:16.076
Requiring user presence means

00:35:16.076 --> 00:35:18.006
that the user will either be

00:35:18.006 --> 00:35:19.186
prompted for biometric

00:35:19.186 --> 00:35:22.336
authentication or they will be

00:35:22.336 --> 00:35:24.316
requested for their device

00:35:24.386 --> 00:35:24.846
password.

00:35:25.466 --> 00:35:29.956
Now that we have composed an

00:35:29.956 --> 00:35:32.156
access control policy, we are

00:35:32.216 --> 00:35:33.726
simply passing it to the

00:35:33.726 --> 00:35:35.426
initializer of the key we're

00:35:35.426 --> 00:35:39.106
generating, and that policy will

00:35:39.106 --> 00:35:39.616
be enforced.

00:35:40.626 --> 00:35:41.846
You might want to give some

00:35:41.846 --> 00:35:43.576
additional context to your users

00:35:43.656 --> 00:35:45.646
about why they're required to

00:35:45.646 --> 00:35:46.236
authenticate.

00:35:46.886 --> 00:35:49.216
In order to do so, you can pass

00:35:49.216 --> 00:35:51.126
a LocalAuthentication context.

00:35:51.696 --> 00:35:56.206
In this case, we say that we

00:35:56.236 --> 00:35:58.166
want the LocalAuthentication

00:35:58.166 --> 00:36:00.376
context to be valid for ten

00:36:00.376 --> 00:36:02.476
seconds, so the user will not be

00:36:02.476 --> 00:36:03.896
required to reauthenticate

00:36:04.426 --> 00:36:06.746
during that amount of time, and

00:36:07.116 --> 00:36:09.056
we want to tell the user that

00:36:09.056 --> 00:36:10.546
they're required to authenticate

00:36:10.656 --> 00:36:12.476
because they're authorizing a

00:36:12.476 --> 00:36:14.066
$10 transfer to Bob.

00:36:14.576 --> 00:36:17.506
In order to use that

00:36:17.786 --> 00:36:19.516
authentication context, you

00:36:19.556 --> 00:36:22.236
simply pass it to the key's

00:36:22.316 --> 00:36:23.136
initializer.

00:36:26.976 --> 00:36:28.766
Finally, let's talk about

00:36:28.766 --> 00:36:29.456
performance.

00:36:32.226 --> 00:36:33.876
CryptoKit is built on top of

00:36:33.876 --> 00:36:34.546
corecrypto.

00:36:35.386 --> 00:36:37.556
Corecrypto is Apple's native

00:36:38.056 --> 00:36:40.286
cryptographic library that

00:36:40.286 --> 00:36:41.816
features all of the system

00:36:41.816 --> 00:36:42.916
frameworks that Yannick has

00:36:42.916 --> 00:36:43.726
described before.

00:36:44.306 --> 00:36:47.676
With the help of the team that

00:36:47.676 --> 00:36:48.726
brought you the Accelerate

00:36:48.726 --> 00:36:50.826
framework and the CPU design

00:36:50.866 --> 00:36:53.216
team, corecrypto has hand-tuned

00:36:53.216 --> 00:36:55.196
assembly code, squeezing every

00:36:55.196 --> 00:36:57.646
cycle out of each of the support

00:36:57.646 --> 00:36:58.646
micro architectures.

00:37:00.636 --> 00:37:03.466
In addition to that, because it

00:37:03.466 --> 00:37:05.776
uses corecrypto, it takes

00:37:05.776 --> 00:37:07.916
advantage of security

00:37:07.916 --> 00:37:10.886
mitigations in corecrypto such

00:37:10.886 --> 00:37:13.986
as side-channel resistance, and

00:37:14.356 --> 00:37:16.446
because corecrypto is FIPS

00:37:16.446 --> 00:37:19.156
validated, that means that you

00:37:19.156 --> 00:37:21.496
can use CryptoKit in the FIPS

00:37:21.496 --> 00:37:22.196
compliant way.

00:37:22.996 --> 00:37:24.576
Yannick opened with this slide

00:37:24.716 --> 00:37:27.586
showing large categories of bug

00:37:27.586 --> 00:37:31.006
classes that are available in

00:37:31.006 --> 00:37:32.236
cryptographic protocols and

00:37:32.236 --> 00:37:33.076
implementations.

00:37:34.116 --> 00:37:36.086
With CryptoKit, we are starting

00:37:36.086 --> 00:37:37.896
to eliminate some of these bug

00:37:37.896 --> 00:37:40.036
classes, but CryptoKit remains a

00:37:40.036 --> 00:37:42.036
low-level crypto API that's

00:37:42.036 --> 00:37:44.226
powerful to let you implement a

00:37:44.226 --> 00:37:46.236
wide range of protocols, even

00:37:46.236 --> 00:37:48.906
broken ones.

00:37:49.076 --> 00:37:50.726
Not all cryptographic weaknesses

00:37:50.726 --> 00:37:52.046
can be addressed at the level of

00:37:52.046 --> 00:37:53.136
the cryptographic library.

00:37:53.496 --> 00:37:55.266
Therefore, we strongly recommend

00:37:55.266 --> 00:37:56.706
you to rely on higher level

00:37:56.706 --> 00:37:59.626
system frameworks when you can.

00:38:00.176 --> 00:38:01.786
This is only the beginning, and

00:38:01.786 --> 00:38:03.586
we want to continue helping you

00:38:03.686 --> 00:38:05.646
ship the safest apps as possible

00:38:05.846 --> 00:38:07.646
by delivering on APIs that help

00:38:07.646 --> 00:38:08.856
you prevent secure legal

00:38:08.856 --> 00:38:09.846
vulnerabilities in your

00:38:09.846 --> 00:38:10.526
applications.

00:38:11.056 --> 00:38:13.486
We can't wait for you to start

00:38:13.486 --> 00:38:15.566
adopting CryptoKit in your apps.

00:38:15.896 --> 00:38:17.146
On the page of this session,

00:38:17.446 --> 00:38:18.546
you'll find a link to the

00:38:18.546 --> 00:38:20.986
CryptoKit documentation, and it

00:38:20.986 --> 00:38:22.536
comes with Xcode Playground.

00:38:23.746 --> 00:38:25.866
Download it, play with it for an

00:38:25.866 --> 00:38:28.096
hour, and see what's available.

00:38:28.756 --> 00:38:30.596
See how you could take advantage

00:38:30.596 --> 00:38:32.366
of CryptoKit in your apps.

00:38:34.156 --> 00:38:36.016
We will be at the labs tomorrow

00:38:36.376 --> 00:38:38.466
to answer any of your questions,

00:38:38.466 --> 00:38:39.816
and we're looking forward to

00:38:39.816 --> 00:38:40.366
your feedback.

00:38:40.926 --> 00:38:41.636
Thank you.

00:38:42.016 --> 00:38:44.000
[ Applause ]
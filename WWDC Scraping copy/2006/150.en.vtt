WEBVTT

00:00:12.550 --> 00:00:13.840
Good morning, everybody.

00:00:13.900 --> 00:00:16.150
I'm Doug Davidson,
and I'm here to talk to you about

00:00:16.400 --> 00:00:19.340
internationalization in Cocoa.

00:00:19.430 --> 00:00:23.790
Now, what is internationalization?

00:00:23.970 --> 00:00:28.130
Probably everybody who's ever built
a Cocoa application has encountered

00:00:28.130 --> 00:00:32.620
our model for localization,
single binary multiple localization,

00:00:32.620 --> 00:00:36.580
where you have a single code
base and then multiple localized

00:00:36.680 --> 00:00:40.030
versions of your resources for
each different localization.

00:00:40.180 --> 00:00:41.990
And that's very important
for the user experience.

00:00:42.100 --> 00:00:46.990
But internationalization is a somewhat
different and perhaps more subtle matter.

00:00:47.120 --> 00:00:51.280
Internationalization covers making
sure that your application handles your

00:00:51.430 --> 00:00:56.700
user's data in the manner they expect,
no matter what their language,

00:00:56.750 --> 00:00:59.440
no matter which localization
they may be using,

00:00:59.520 --> 00:01:02.370
even if your application
is never localized at all.

00:01:02.440 --> 00:01:03.510
This is important.

00:01:03.640 --> 00:01:05.240
Why should you be interested in this?

00:01:05.360 --> 00:01:08.380
Because it's important for making
sure that your application is

00:01:08.380 --> 00:01:10.320
suitable for a world-wide audience.

00:01:10.380 --> 00:01:13.580
If you have international problems,
you could potentially cut

00:01:13.580 --> 00:01:16.660
yourself off from a significant
portion of your audience.

00:01:18.850 --> 00:01:22.800
Now we're going to talk about some of the
areas that are most important for this,

00:01:22.960 --> 00:01:25.550
key event handling,
we'll talk about strings,

00:01:25.610 --> 00:01:27.800
we'll talk about date
and time formatters,

00:01:27.800 --> 00:01:30.380
and then we'll talk a bit about text.

00:01:30.580 --> 00:01:35.110
Now, the fortunate thing here is that the
Cocoa frameworks try very hard to

00:01:35.160 --> 00:01:39.770
make sure that everything is fully
internationalizable by default.

00:01:39.780 --> 00:01:43.440
So in a certain sense,
all you have to do is not break that.

00:01:43.460 --> 00:01:47.620
However, there are some assumptions
that are very easy to make,

00:01:47.620 --> 00:01:50.070
particularly for someone like me.

00:01:50.070 --> 00:01:51.260
I'm a native English speaker.

00:01:51.260 --> 00:01:55.180
I came into this field a
long time ago before Unicode,

00:01:55.330 --> 00:01:57.980
and ASCII was the hot new standard.

00:01:58.920 --> 00:02:01.520
And so there are certain assumptions
that it's very easy to fall into

00:02:01.520 --> 00:02:04.140
that cause real problems from
an international perspective.

00:02:04.140 --> 00:02:07.140
And we've been dealing with
these issues for a long time,

00:02:07.140 --> 00:02:09.620
and we've encountered
quite a few of these.

00:02:09.620 --> 00:02:15.140
And so I decided to see how many
of these sorts of problems I could

00:02:15.140 --> 00:02:18.160
fit into a single application.

00:02:18.160 --> 00:02:20.830
Here's the application
that I came up with.

00:02:20.830 --> 00:02:23.310
If we could go over to the demo machine.

00:02:25.500 --> 00:06:08.800
[Transcript missing]

00:06:10.760 --> 00:06:14.810
I know possibly not all of you have
had a chance to really work with

00:06:14.810 --> 00:06:19.540
some of these complex input methods,
so I wanted to just give a really basic

00:06:19.540 --> 00:06:22.740
demonstration of one of them to show,
I think this will help make clear

00:06:22.740 --> 00:06:24.250
some of the issues involved here.

00:06:24.370 --> 00:06:29.450
And the method I've chosen to use here is

00:06:29.750 --> 00:06:31.910
is used for Chinese text.

00:06:32.150 --> 00:06:35.660
And what the user does in this
particular method is to type in

00:06:35.660 --> 00:06:41.070
a phonetic representation of the
character that they're interested in.

00:06:41.130 --> 00:06:44.570
And then they hit space,
and they're presented with a

00:06:44.650 --> 00:06:48.740
list of characters that they can
arrow through and choose from.

00:06:48.740 --> 00:06:52.250
And then when they find the
character they really want,

00:06:52.250 --> 00:06:54.490
they can hit return and select it.

00:06:54.490 --> 00:06:57.500
And at that point,
it finally gets accepted and

00:06:57.500 --> 00:06:57.980
entered into the text view.

00:06:58.590 --> 00:07:01.640
The thing here is that there are lots
of keystrokes that are coming in that

00:07:01.650 --> 00:07:05.200
are really intended for the input
method and not for the text view proper.

00:07:05.200 --> 00:07:08.120
And if you intervene
at the keydown level,

00:07:08.120 --> 00:07:10.340
you can interfere with this.

00:07:10.340 --> 00:07:13.770
At worst, at best,
you're going to get a lot of spurious

00:07:14.210 --> 00:07:16.790
keystrokes that you didn't want.

00:07:16.800 --> 00:07:19.060
At worst, you can completely
break this input method.

00:07:19.060 --> 00:07:22.360
And that's what this application
that I showed you does.

00:07:22.360 --> 00:07:25.820
By overriding keydown and
swallowing these return characters,

00:07:25.820 --> 00:07:29.470
it swallows the return character
that this input method wants

00:07:29.480 --> 00:07:31.380
to accept the character.

00:07:31.380 --> 00:07:36.060
And not all input methods are like this,
but this is fairly typical.

00:07:36.060 --> 00:07:38.900
They can do almost
arbitrary key handling.

00:07:38.900 --> 00:07:41.410
So let's go back to the slides.

00:07:41.420 --> 00:07:42.650
Here we go.

00:07:45.680 --> 00:07:49.600
I'm going to explain something
that you can do instead.

00:07:49.670 --> 00:07:54.300
I talked about keystrokes that
are bound to particular methods.

00:07:54.300 --> 00:07:56.250
What are these methods
that they're bound to?

00:07:56.250 --> 00:07:58.840
They're mostly defined in NSResponder.

00:07:58.840 --> 00:08:03.120
NSTextView is probably the class
that implements the most of these

00:08:03.120 --> 00:08:05.360
various NSResponder methods.

00:08:05.360 --> 00:08:08.440
There's a list of which keys
are bound to which methods.

00:08:08.440 --> 00:08:12.400
These are methods of things
like insert new line,

00:08:12.400 --> 00:08:15.580
insert tab, move left, right, up, down,
and so forth.

00:08:15.600 --> 00:08:18.960
In particular,
the method that's bound to the

00:08:18.960 --> 00:08:21.330
return key is insert new line.

00:08:21.330 --> 00:08:25.690
How could I improve this little demo app?

00:08:25.690 --> 00:08:29.070
Here's one example of
something you can do.

00:08:29.080 --> 00:08:33.780
Instead of subclassing NSTextView,
we're acting as a TextView's

00:08:33.780 --> 00:08:37.160
delegate and implementing
TextView do command by selector.

00:08:37.160 --> 00:08:39.330
Then we look for this selector,
insert new line,

00:08:39.330 --> 00:08:41.030
that indicates a return was pressed.

00:08:41.070 --> 00:08:42.940
If we see it, we do something special.

00:08:42.940 --> 00:08:45.160
In this case, we're returning no.

00:08:45.600 --> 00:08:49.420
Returning no means the
TextView should go ahead and continue

00:08:49.890 --> 00:08:51.710
handling this event normally.

00:08:51.940 --> 00:08:54.140
If we return yes,
then that would mean we've

00:08:54.170 --> 00:08:58.040
completely handled it and the
TextView shouldn't do its normal thing.

00:08:59.320 --> 00:09:03.500
Okay, so now that you've got the
text into your application,

00:09:03.500 --> 00:09:05.020
you probably want to
do something with it.

00:09:05.040 --> 00:09:08.640
And to talk about string handling,
I brought in an expert, Mr.

00:09:08.730 --> 00:09:11.230
Anna String himself, Akki Inoue.

00:09:15.030 --> 00:09:15.860
Thank you, Doug.

00:09:16.000 --> 00:09:19.020
Hi, I'm Aki Inoue.

00:09:19.340 --> 00:09:23.370
I'd like to discuss string handling,
mainly focusing on pitfalls

00:09:23.390 --> 00:09:25.710
you might stumble on.

00:09:30.710 --> 00:09:34.920
These are the topics I'm covering today.

00:09:34.970 --> 00:09:38.050
Let's get started with basics.

00:09:40.060 --> 00:09:46.900
Cocoa provides rich string handling
capabilities via the NSString class.

00:09:47.090 --> 00:09:51.900
NSString is the string object in Cocoa.

00:09:51.920 --> 00:09:56.380
It's accepted virtually
anywhere from foundation class

00:09:56.640 --> 00:09:59.930
to Android's book framework.

00:10:00.880 --> 00:10:08.010
And it allows us to provide
efficiency both in API design

00:10:08.110 --> 00:10:10.160
and performance point of view.

00:10:10.230 --> 00:10:16.640
So you don't have to use different
string representation depending

00:10:16.640 --> 00:10:19.150
on the framework you are using.

00:10:20.790 --> 00:10:27.040
Also, Cocoa is designed to work
exclusively with UniCode standards,

00:10:27.040 --> 00:10:34.780
and it also gives us coherent,
consistent, clear API.

00:10:34.830 --> 00:10:38.610
So,
we don't have to do something like this.

00:10:41.560 --> 00:10:46.440
The UniCode standard is the
industry standard character set.

00:10:46.490 --> 00:10:51.450
It's used by all the
cool latest technologies.

00:10:51.450 --> 00:10:56.750
And the latest version,
recently finalized version 5,

00:10:56.750 --> 00:11:03.190
covers more than 99,000
characters from over 60 scripts.

00:11:03.800 --> 00:11:10.040
A unique feature of UniCode standard
is it's not merely assigning

00:11:10.040 --> 00:11:18.490
numeric values to each characters,
but it also defines rules and behaviors

00:11:18.930 --> 00:11:20.600
dealing with those characters.

00:11:20.700 --> 00:11:25.390
For example,
comparison or case mapping behaviors.

00:11:25.480 --> 00:11:31.400
One of those rules is a
standard encoding form.

00:11:31.500 --> 00:11:33.580
UniCode has

00:11:33.740 --> 00:11:37.760
Three standard encoding
intervals defined:

00:11:37.760 --> 00:11:41.440
UTF-8, UTF-16, and UTF-32.

00:11:43.100 --> 00:11:50.390
The numbers represent the bit width
of an atomic unit in the encoding.

00:11:50.470 --> 00:11:57.460
For example, UTF-16 is a two byte entity,
just like Chopin.

00:11:58.150 --> 00:12:06.190
And a string is conceptually
an array of UTF-16 characters,

00:12:06.190 --> 00:12:11.500
and it provides various string-hunting
capabilities from comparison,

00:12:11.500 --> 00:12:14.510
searching, so on and so forth.

00:12:15.120 --> 00:12:20.250
And you could extend the capability
of NSString using one of companion

00:12:20.250 --> 00:12:26.390
objects like NSCharacterSet,
NSAttributeString, or NSCannons.

00:12:28.390 --> 00:12:32.100
Now we cover the basics.

00:12:32.160 --> 00:12:35.150
I'd like to discuss HP Folds.

00:12:35.150 --> 00:12:37.300
Now with the C-strings.

00:12:37.300 --> 00:12:39.960
C-strings.

00:12:39.960 --> 00:12:41.540
What is that?

00:12:43.750 --> 00:12:45.700
Simply, it's this.

00:12:45.730 --> 00:12:48.050
Now, what about it?

00:12:48.180 --> 00:12:51.720
Probably,
this is one of the most familiar

00:12:51.930 --> 00:12:55.250
C data type for most of you.

00:12:55.360 --> 00:12:58.990
But I'd like to forget about it.

00:13:03.180 --> 00:13:12.690
C-strings are mostly relying on some
implicit string encoding definition.

00:13:12.690 --> 00:13:12.690
So,

00:13:13.220 --> 00:13:19.220
It could be Mac Roman, UTF-8, Japanese,
or anything.

00:13:19.310 --> 00:13:24.080
So at some point,
probably you are forced to guess

00:13:24.900 --> 00:13:31.850
the encoding you are using with
some arbitrary C string pointers.

00:13:34.340 --> 00:13:41.300
Another issue with
C-String is by using that,

00:13:41.330 --> 00:13:44.490
you are unnecessarily limiting
the number of characters you can

00:13:44.580 --> 00:13:47.410
represent in your application.

00:13:49.730 --> 00:13:57.670
And if you want to have multi-lingual
capability in your application,

00:13:57.670 --> 00:14:02.290
it's much,
much harder to keep track of each

00:14:02.520 --> 00:14:08.220
encoding used in portions of C string.

00:14:08.220 --> 00:14:08.220
Also,

00:14:08.590 --> 00:14:15.210
In order to make sure your
application works with some arbitrary

00:14:15.290 --> 00:14:20.400
encodings like Cyrillic or Arabic,
you have to probably test

00:14:20.400 --> 00:14:25.010
your application with the 22
MacÂ OS encoding we are shipping.

00:14:26.680 --> 00:14:33.060
So I know you might be tempted,
but stick with

00:14:33.060 --> 00:14:37.730
NSString whenever possible.

00:14:37.730 --> 00:14:37.730
It provides

00:14:37.920 --> 00:14:41.750
Higher-level operation so you
don't have to access each of the

00:14:42.050 --> 00:14:44.380
individual characters by yourselves.

00:14:44.380 --> 00:14:50.840
And we consider the performance
of NSString pretty seriously.

00:14:50.840 --> 00:14:58.000
And in fact, we know that NSString is one
of the most efficient Unicode

00:14:58.050 --> 00:15:01.250
handling libraries in the industry.

00:15:02.540 --> 00:15:11.040
And we keep track of the
change in UniCode standard.

00:15:11.130 --> 00:15:14.600
So we're going to apply the
change whenever possible

00:15:14.670 --> 00:15:17.730
to the major OS releases.

00:15:21.800 --> 00:15:25.100
There are cases you might
still need to use C string.

00:15:25.100 --> 00:15:27.830
These are the recommendations we have.

00:15:28.020 --> 00:15:32.840
Always keep track of
the encoding explicitly.

00:15:33.000 --> 00:15:36.600
So if you need to pass
around C string pointer,

00:15:36.620 --> 00:15:43.710
we recommend to also pass around
corresponding encoding explicitly.

00:15:43.810 --> 00:15:46.690
We have API to help you.

00:15:51.400 --> 00:16:00.770
Another thing to note is if you
need to use one of POSIX-like API,

00:16:00.770 --> 00:16:04.000
like Open System Code,

00:16:04.150 --> 00:16:07.820
You need to use specialized
methods like file system

00:16:07.960 --> 00:16:15.680
representation to get file system
compatible C string by the pointer.

00:16:16.930 --> 00:16:22.900
And no,
we have already deprecated C string

00:16:22.900 --> 00:16:27.070
method that use implicit encoding.

00:16:31.000 --> 00:16:33.080
Now we cover the strings.

00:16:33.090 --> 00:16:36.910
I'd like to mention case operations.

00:16:38.550 --> 00:16:42.370
For English, lower casing,
upper casing is pretty simple,

00:16:42.460 --> 00:16:45.310
one-to-one mapping.

00:16:45.700 --> 00:17:00.600
[Transcript missing]

00:17:01.880 --> 00:17:05.750
Case mapping operation being worked on.

00:17:05.830 --> 00:17:09.730
So let me show some of the examples here.

00:17:12.160 --> 00:17:19.990
The #s character in German language
only has lowercase representation.

00:17:21.300 --> 00:17:27.530
So if you want to uppercase
the word like "Strauss" here,

00:17:28.490 --> 00:17:28.490
the character that--

00:17:28.920 --> 00:17:36.990
becomes two capital S characters,
thus changing the length of strength.

00:17:39.270 --> 00:17:40.300
Another example.

00:17:40.300 --> 00:17:47.720
It looks like two characters,
but actually, it's a ligature,

00:17:47.740 --> 00:17:52.580
a single character looking
like two characters.

00:17:52.590 --> 00:17:58.480
UniCode has those characters so
that in addition to lower case,

00:17:58.480 --> 00:18:03.780
upper case, it needs to have title case.

00:18:03.820 --> 00:18:07.930
So UniCode has three cases, not just two.

00:18:10.670 --> 00:18:14.190
Another example,
you need to have the context in

00:18:14.190 --> 00:18:16.930
order to do the correct mapping.

00:18:17.210 --> 00:18:22.790
The Greek Sigma character,
the Greek capital Sigma character here,

00:18:23.050 --> 00:18:27.500
requires a context in order
to get the correct mapping.

00:18:27.520 --> 00:18:31.410
It could become lowercase
sigma character,

00:18:31.410 --> 00:18:35.140
or it could be lowercase
final sigma form,

00:18:35.180 --> 00:18:40.120
depending on its inward location.

00:18:40.240 --> 00:18:44.720
Even innocent-looking
ASCII characters are not safe.

00:18:46.230 --> 00:18:49.060
If you're in a lowercase,
the capital I character,

00:18:49.060 --> 00:18:56.970
it's going to be a special dotless I if
you're writing in Turkish language.

00:18:59.190 --> 00:19:05.530
So, casing operation is not a
simple one-to-one mapping.

00:19:05.860 --> 00:19:11.980
It could change the length of string,
and often requires the

00:19:12.840 --> 00:19:15.990
context of the whole string.

00:19:17.460 --> 00:19:26.190
And surprisingly, lower casing and upper
casing is not symmetrical.

00:19:26.190 --> 00:19:26.190
So,

00:19:26.800 --> 00:19:31.980
You cannot expect a round-trip
fidelity between these operations.

00:19:32.020 --> 00:19:40.560
And that caused interesting point that
if you want to have case insensitivity,

00:19:40.590 --> 00:19:45.340
just by lower-casing and upper-casing
character doesn't give you that.

00:19:45.370 --> 00:19:51.640
You have to have specific case
ins-- you need to use specific case

00:19:51.640 --> 00:19:55.490
insensitive functionalities in NSString.

00:19:57.900 --> 00:20:03.200
So if you want to do case operation,
we provide these methods,

00:20:03.200 --> 00:20:07.770
uppercase string or lowercase string,
and capitalized string,

00:20:07.880 --> 00:20:12.000
supporting the title case
we mentioned earlier.

00:20:12.100 --> 00:20:17.400
So please don't look at individual
characters when you want to

00:20:17.400 --> 00:20:19.780
change the case of string.

00:20:23.070 --> 00:20:27.330
Next,
I'd like to cover character clusters.

00:20:27.720 --> 00:20:31.500
Probably,
it's one of the biggest mysteries

00:20:31.620 --> 00:20:37.750
in UniCode standards that multiple
characters could comprise a semantic,

00:20:37.750 --> 00:20:40.470
grouped together character.

00:20:42.730 --> 00:20:46.930
Next,
I'd like to cover character clusters.

00:20:46.930 --> 00:20:51.140
Probably,
it's one of the biggest mysteries

00:20:51.180 --> 00:20:57.350
in UniCode standards that multiple
characters could comprise a semantic,

00:20:57.350 --> 00:20:58.020
grouped together character.

00:20:59.630 --> 00:21:05.440
One of the common composition
is combining marks.

00:21:05.920 --> 00:21:09.600
It's commonly used to
represent accent marks.

00:21:09.600 --> 00:21:15.400
For example, this Gryff Alpha character
has three accents.

00:21:15.420 --> 00:21:23.270
Thus, you can have six patterns to
represent this character in UniCode.

00:21:23.550 --> 00:21:29.700
And the string handles all correctly
and recognizes them as equal.

00:21:32.440 --> 00:21:38.730
So you don't have to worry,
but there are some exceptions.

00:21:39.620 --> 00:21:45.890
is equal and hash do not take
composition difference into account.

00:21:47.000 --> 00:21:52.530
So when you want to put
these strings into collection

00:21:52.530 --> 00:21:59.720
classes such as NSDictionary,
you need to take extra steps beforehand.

00:22:01.550 --> 00:22:06.510
So when you want to put
these strings into collection

00:22:06.510 --> 00:22:06.510
classes such as NSDictionary,
you need to take extra steps beforehand.

00:22:08.390 --> 00:22:12.680
From arbitrary composition
state string into free-composed

00:22:12.790 --> 00:22:16.230
or free-decomposed string.

00:22:16.600 --> 00:22:20.220
We recommend using the decomposed
string with canonical mapping for

00:22:20.220 --> 00:22:26.220
compatibility with file system
and also efficiency reasons.

00:22:28.530 --> 00:22:31.720
There are other types of compositions.

00:22:31.720 --> 00:22:42.620
One is there are characters that can
actually combine arbitrary characters,

00:22:42.620 --> 00:22:44.630
surrounding combining characters.

00:22:44.730 --> 00:22:52.560
So you cannot expect that combining
only happens with the form of a

00:22:52.560 --> 00:22:54.430
base character followed by accent.

00:22:54.440 --> 00:22:59.700
Actually, you know,
a character could bind

00:22:59.700 --> 00:23:02.120
any surrounding character.

00:23:02.820 --> 00:23:06.450
Combining Graphium Joiner is one of them.

00:23:06.510 --> 00:23:13.130
And another type of composition is Hangul
characters used in Korean language.

00:23:14.580 --> 00:23:20.130
Each character could have at
least two representations,

00:23:20.260 --> 00:23:22.690
combined or decomposed.

00:23:25.490 --> 00:23:30.220
Yet another type of
composition is solid pairs.

00:23:30.310 --> 00:23:35.590
Solid pairs are a combination
of two UTF-16 characters,

00:23:35.610 --> 00:23:41.010
so it takes two slots inside a string.

00:23:41.910 --> 00:23:48.950
They are used to represent characters
outside of 16-bit range by combining

00:23:48.950 --> 00:23:54.270
those two 16-bit data into a 32-bit data.

00:23:54.500 --> 00:24:00.300
[Transcript missing]

00:24:01.740 --> 00:24:06.720
Beyond 60-bit ranges used by
customers in China and Japan.

00:24:07.050 --> 00:24:11.600
So if you're planning
going to this market,

00:24:11.610 --> 00:24:14.620
this is pretty essential to support.

00:24:16.200 --> 00:24:21.150
Furthermore, the same combining behavior
I mentioned earlier applies to

00:24:21.150 --> 00:24:24.240
the surrogate characters too.

00:24:24.240 --> 00:24:29.640
So there are already characters
assigned in this area that can

00:24:29.640 --> 00:24:32.410
combine with other characters.

00:24:35.450 --> 00:24:41.860
In Unicode,
there are those types of composition, but

00:24:44.110 --> 00:24:46.600
You can forget all the
details I mentioned today

00:24:46.730 --> 00:24:49.310
if you stick with NSString.

00:24:49.370 --> 00:24:53.910
NSString handles all
of them transparently.

00:24:56.030 --> 00:25:00.640
If you need to process a
character cluster all by yourself,

00:25:00.860 --> 00:25:08.380
you can use range of composed
character sequence app index.

00:25:08.420 --> 00:25:13.690
The method maps character
index into a range of character

00:25:13.870 --> 00:25:17.590
cluster containing the index.

00:25:18.580 --> 00:25:23.820
You can process each TurkTurk cluster
from the beginning of the string,

00:25:23.820 --> 00:25:26.690
like the code up here.

00:25:30.640 --> 00:25:33.690
I'd like to mention source
file encodings here.

00:25:33.690 --> 00:25:42.260
Xcode supports any type of encoding,
but we recommend keeping

00:25:42.370 --> 00:25:45.310
your source code asking only.

00:25:46.720 --> 00:25:55.120
For example, if you use Noasci byte
in NSString literals,

00:25:55.130 --> 00:26:01.560
represented by a double-code format,
the behavior is simply undefined.

00:26:01.610 --> 00:26:05.750
And often,
what you get is garbled text like

00:26:05.780 --> 00:26:09.290
this in some other localization.

00:26:12.410 --> 00:26:18.740
So if you need to embed some
NoSQL characters into your source code,

00:26:18.750 --> 00:26:24.650
use one of those methods that takes
one of the Unicode encoding forms.

00:26:26.930 --> 00:26:34.160
And if you have NoASCII characters,
and that can be visible to users,

00:26:34.190 --> 00:26:38.330
the chances are you might want to
try the localized string facility

00:26:38.340 --> 00:26:43.630
instead of trying to hard-code
NoASCII characters into your source code.

00:26:45.300 --> 00:26:47.100
Some examples.

00:26:47.560 --> 00:26:51.010
If you want to embed UTF characters
into your source code,

00:26:51.030 --> 00:26:58.620
you can use simple C numeric values
instead of using the actual bytes inside

00:26:58.620 --> 00:27:02.350
the source code and calling the UTF-8.

00:27:03.810 --> 00:27:05.800
Another example.

00:27:05.810 --> 00:27:10.640
This example,
we're using the %C format directive so

00:27:10.640 --> 00:27:20.210
that you can include a UTF-16 character
like ellipsis here into your NSString.

00:27:24.250 --> 00:27:29.350
I'd like to mention NS-attributed
string here a little.

00:27:29.590 --> 00:27:35.320
If you are looking for some
string handling operation and

00:27:35.320 --> 00:27:40.550
you can't find it in NS-string,
the chances are you can find it

00:27:40.660 --> 00:27:43.120
in NS-attributed string instead.

00:27:43.600 --> 00:27:47.110
For example, it can provide

00:27:47.460 --> 00:27:53.090
Grammatical analysis like word
or line break information.

00:27:53.350 --> 00:27:57.690
And also,
it's capable of reading and writing a

00:27:57.690 --> 00:28:01.850
number of plain and rich text formats.

00:28:01.860 --> 00:28:08.600
So you might just skip the headache of
dealing with plain text encoding issue

00:28:08.650 --> 00:28:12.010
just by using NSF attribute string.

00:28:13.990 --> 00:28:16.950
String Handling Wrap-up.

00:28:17.020 --> 00:28:20.720
Cocoa provides string-rich
string handling.

00:28:20.730 --> 00:28:23.550
And it's multilingual.

00:28:26.020 --> 00:28:30.140
It makes your application world-ready,
transparent.

00:28:30.260 --> 00:28:33.320
So by sticking to NSString,

00:28:33.890 --> 00:28:37.730
It makes your application world-ready,
transparent.

00:28:38.040 --> 00:28:41.220
So by sticking to NSString,

00:28:42.820 --> 00:28:46.250
Now I'd like to bring
back Doug Davidson to talk

00:28:46.250 --> 00:28:48.620
about locale and formatus.

00:28:48.730 --> 00:28:50.180
Thank you.

00:28:55.180 --> 00:28:56.240
Thanks, Akki.

00:28:56.320 --> 00:29:00.220
So the next set of issues I want to
talk about have to do with locale.

00:29:00.380 --> 00:29:01.330
What is locale?

00:29:01.330 --> 00:29:04.180
Locale is not the same
thing as localization.

00:29:04.180 --> 00:29:08.840
Localization refers to the
language that your application

00:29:08.840 --> 00:29:10.660
uses to communicate with the user.

00:29:10.660 --> 00:29:16.870
The locale has to do with the
user's preferences for how they want

00:29:16.870 --> 00:29:19.640
their data organized and presented.

00:29:19.640 --> 00:29:24.380
And the object that we use to
identify a locale is NSLocale.

00:29:25.100 --> 00:29:28.330
And it has information about
things like choice of calendar,

00:29:28.380 --> 00:29:32.330
date formats, time formats, sort orders,
English versus metric

00:29:32.330 --> 00:29:34.620
measurement systems,
and so forth.

00:29:34.620 --> 00:29:39.960
And you can use the class method
CurrentLocale to get the user's

00:29:39.960 --> 00:29:43.240
CurrentLocale set of preferences.

00:29:43.240 --> 00:29:47.720
And this may be one of the
predefined sets of formats,

00:29:47.720 --> 00:29:52.720
or the user might have customized
it by choosing variations

00:29:52.720 --> 00:29:54.950
for some of these items.

00:29:55.100 --> 00:30:00.340
And in most cases, you're not going to be
using NSLocale directly.

00:30:00.340 --> 00:30:03.300
You might probably use it
indirectly through a number of

00:30:03.360 --> 00:30:08.890
locale-savvy classes like NSString,
NSNumberFormatter, NSDateFormatter,

00:30:09.020 --> 00:30:10.550
and so forth.

00:30:11.440 --> 00:30:15.140
And so let's talk about
NSNumberFormatter.

00:30:15.400 --> 00:30:20.180
The most important thing for our number
formatting is to use NSNumberFormatter.

00:30:20.500 --> 00:30:25.210
And NSNumberFormatter has
been around for a long time,

00:30:25.460 --> 00:30:29.250
but it's only really been
fully locale savvy since 10.4.

00:30:29.390 --> 00:30:30.760
So it has two different behaviors.

00:30:30.800 --> 00:30:35.140
There's an older compatibility behavior,
and then there's the 10.4 behavior,

00:30:35.140 --> 00:30:36.780
which is the one you want to use.

00:30:36.810 --> 00:30:39.360
This is the default behavior for
applications that are linked on Leopard,

00:30:39.420 --> 00:30:42.630
but if you're running back to Tiger,
you need to explicitly specify this,

00:30:42.660 --> 00:30:45.040
and it's probably a good idea to do so.

00:30:45.100 --> 00:30:51.960
And now, in the 10.4 behavior,
it still supports format strings,

00:30:52.020 --> 00:30:56.190
but better than that,
the better thing to do is to use

00:30:56.190 --> 00:31:00.140
one of the enumerated styles,
like decimal style, currency style,

00:31:00.140 --> 00:31:01.940
and so forth,
because these are things that will

00:31:02.070 --> 00:31:07.080
fully participate in the user's choice
of preferences for the format that

00:31:07.080 --> 00:31:09.700
they want their numbers displayed in.

00:31:11.190 --> 00:31:13.100
For NSDateFormatter,
it's somewhat similar.

00:31:13.100 --> 00:31:17.610
Again, it's been around a long time,
but it's fully locale-savvy,

00:31:17.610 --> 00:31:21.060
starting in 10.4,
and you want to use the 10.4 behavior.

00:31:21.060 --> 00:31:24.410
And again, the best thing is to
use enumerated styles,

00:31:24.410 --> 00:31:28.800
and for NSDateFormatter,
there are two sets of enumerated styles.

00:31:28.800 --> 00:31:32.880
There's a date style and the time style,
and these have values like full, long,

00:31:32.880 --> 00:31:35.460
medium, short,
or none if you want to have a date,

00:31:35.460 --> 00:31:37.260
but not a time, or vice versa.

00:31:39.490 --> 00:31:44.560
And these will fully participate
in the user's choice of preferences

00:31:44.560 --> 00:31:46.860
for their display of dates.

00:31:46.860 --> 00:31:51.690
We recommend against using
NSCalendarDate because,

00:31:51.690 --> 00:31:58.220
again, this is an older class and
has the pre-10.4 behavior.

00:31:58.220 --> 00:32:02.670
Another thing that people sometimes
do that we recommend against,

00:32:02.670 --> 00:32:07.560
and that is using format strings
and making them localizable strings.

00:32:07.580 --> 00:32:11.110
The problem there is that, as I said,
the localization is not

00:32:11.110 --> 00:32:12.820
the same thing as locale.

00:32:12.820 --> 00:32:16.130
For example,
many users around the world may

00:32:16.130 --> 00:32:19.680
use the English localization,
not because it's not

00:32:19.760 --> 00:32:22.570
their first language,
but it may be the second language

00:32:22.600 --> 00:32:23.600
they're most comfortable with.

00:32:23.640 --> 00:32:27.810
But they still will have their
own preferences and requirements,

00:32:27.810 --> 00:32:30.560
indeed, for date format, time format.

00:32:30.560 --> 00:32:34.100
They'll have their own data,
which is maybe in their own language

00:32:34.100 --> 00:32:36.450
that they'll need handled properly.

00:32:39.300 --> 00:32:41.700
If you need to do
calendrical calculations,

00:32:41.700 --> 00:32:45.770
we have the class NSCalendar,
which handles a variety of different

00:32:45.870 --> 00:32:47.320
calendars in use around the world.

00:32:47.360 --> 00:32:50.570
And you can use the current
calendar method to get the

00:32:50.570 --> 00:32:52.990
current user's preferred calendar.

00:32:53.040 --> 00:32:56.870
Now, if you're using NSCalendar
for calendrical calculations,

00:32:56.870 --> 00:33:00.880
it handles all these different
calendars in a sort of generalized way.

00:33:00.880 --> 00:33:04.660
So you have to avoid making assumptions
that might be valid only for,

00:33:04.660 --> 00:33:06.560
say, the Gregorian calendar.

00:33:08.130 --> 00:33:11.440
They don't all have the same number
of days or months and so forth.

00:33:11.440 --> 00:33:14.480
Years don't necessarily
start at the same point.

00:33:14.480 --> 00:33:17.840
And again,
NSCalendarDate is an older class that

00:33:17.840 --> 00:33:20.720
handles only the Gregorian calendar.

00:33:20.800 --> 00:33:25.590
So I would like you to move
forward from that to NSCalendar.

00:33:26.860 --> 00:33:28.860
sorting of strings.

00:33:28.900 --> 00:33:34.020
Now,
the basic NSString compare method is a

00:33:34.020 --> 00:33:38.140
default locale independent sort order.

00:33:38.310 --> 00:33:41.390
It's useful for programmatic sorting.

00:33:41.390 --> 00:33:45.130
If you are sorting data
to present to the user,

00:33:45.500 --> 00:33:51.270
then you probably will want to use a
fully locale savvy comparison method.

00:33:51.270 --> 00:33:54.990
We have some basic convenience ones,
localized compare,

00:33:55.040 --> 00:33:57.540
localized case and sensitive compare.

00:33:57.540 --> 00:34:01.690
Then we have the full options,
compare options range locale

00:34:01.720 --> 00:34:06.790
into which you can pass
NSLocale current locales locale.

00:34:07.230 --> 00:34:13.430
It's important to assume as little
as possible about what these

00:34:13.430 --> 00:34:15.100
sort orderings are going to do.

00:34:15.360 --> 00:34:19.100
The sort orderings can vary quite a bit,
not just with language,

00:34:19.100 --> 00:34:26.010
but even in a writing system,
but from country to country within

00:34:26.010 --> 00:34:28.100
the same language or writing system.

00:34:28.100 --> 00:34:31.090
Different sort orders handle
things like accents differently.

00:34:31.150 --> 00:34:33.100
Some of them sort them
with the base character,

00:34:33.100 --> 00:34:34.100
some of them sort them separately.

00:34:34.100 --> 00:34:39.100
Some of them will combine multiple
characters for purposes of sorting.

00:34:39.100 --> 00:34:41.830
So you should assume as little as
possible about what they're going

00:34:41.830 --> 00:34:46.050
to do and just let the comparison
method handle comparison for sorting.

00:34:46.100 --> 00:34:50.350
So the little application I showed
you just used the standard obvious

00:34:50.350 --> 00:34:53.100
compare method for sorting its strings.

00:34:53.100 --> 00:34:56.540
But these were going to
be presented to the user,

00:34:56.540 --> 00:34:59.700
so what we really want
is a locale-savvy sort,

00:34:59.870 --> 00:35:02.390
case-insensitive in this case.

00:35:02.950 --> 00:35:06.400
and that's the thing we prefer.

00:35:06.410 --> 00:35:09.930
So the next thing that little sample
application did was to measure the

00:35:09.930 --> 00:35:12.720
width of the words in the text.

00:35:12.720 --> 00:35:15.290
And right away it runs into a problem.

00:35:15.360 --> 00:35:16.730
So what does it do?

00:35:16.940 --> 00:35:21.910
It asks the text view for its font,
and it goes through and finds each word,

00:35:21.910 --> 00:35:27.300
and then it calls font width of string
string to get the width of that string.

00:35:27.310 --> 00:35:29.040
Again, simple, obvious, and wrong.

00:35:29.960 --> 00:35:33.810
The NSString method, no, excuse me,
the NS font method with

00:35:33.900 --> 00:35:37.040
the string is deprecated,
and I want to explain why.

00:35:37.720 --> 00:35:41.040
Most obvious is that

00:35:41.280 --> 00:35:43.950
Given an arbitrary string,
it can be an arbitrary UniCode string,

00:35:43.950 --> 00:35:48.610
and a single font is not going to
be able to represent any character

00:35:48.690 --> 00:35:49.760
that might be in a string.

00:35:49.760 --> 00:35:53.140
And in general,
the Cocoa text system is going to

00:35:53.170 --> 00:35:57.660
substitute in a suitable font whenever
it finds a character that can't be

00:35:57.660 --> 00:35:59.650
represented in a specified font.

00:35:59.660 --> 00:36:06.170
So you can't necessarily just rely on
the font to measure a particular string.

00:36:07.050 --> 00:36:09.540
But even more important from
an international perspective,

00:36:09.540 --> 00:36:13.670
even if you know that the string can
be represented with a given font,

00:36:13.680 --> 00:36:17.300
just adding up the width of
the glyphs in a string is not

00:36:17.300 --> 00:36:19.720
sufficient to measure its width.

00:36:19.820 --> 00:36:24.980
The glyphs will often have different
contextual forms depending on

00:36:24.980 --> 00:36:28.910
where they appear and what the
characters around them are.

00:36:28.920 --> 00:36:32.280
They may need to be reordered
depending on the writing system.

00:36:32.280 --> 00:36:35.390
They may need to be repositioned.

00:36:36.320 --> 00:36:39.260
So in general,
you need to have text layout in

00:36:39.390 --> 00:36:42.820
order to properly measure text or
in order to properly display it.

00:36:44.350 --> 00:36:47.680
Now, fortunately,
Cocoa has some simple convenience methods

00:36:47.910 --> 00:36:52.860
that make it very easy to measure and
draw strings and attributed strings.

00:36:52.870 --> 00:36:55.680
These are what we call the
string drawing methods,

00:36:55.780 --> 00:36:58.280
things like NSString's
size with attributes,

00:36:58.300 --> 00:37:01.260
where you specify an attribute
dictionary and get back size.

00:37:01.260 --> 00:37:05.370
And there are various methods
for these for NSStrings or

00:37:05.370 --> 00:37:09.180
NSTributed strings for sizing,
drawing at points and rects and so forth.

00:37:09.210 --> 00:37:13.160
And you can look through
NSStringDrawing.h for these.

00:37:13.380 --> 00:37:17.440
If you have needs that are more
complicated than these simple

00:37:17.440 --> 00:37:22.230
convenience methods will handle,
then you can go to NSLayoutManager,

00:37:22.280 --> 00:37:25.860
which gives you full control
over the layout process.

00:37:25.860 --> 00:37:27.020
I'm going to talk about that in a minute.

00:37:27.030 --> 00:37:31.200
So what should our little sample
application have been doing?

00:37:31.200 --> 00:37:34.420
In this case,
we can use NSString's size with

00:37:34.420 --> 00:37:39.300
attribute method as a drop-in
replacement for what it was doing.

00:37:40.050 --> 00:37:42.520
In this case,
we create an attribute dictionary

00:37:42.520 --> 00:37:45.830
with the font that we specify,
and we go through, and for each string,

00:37:45.830 --> 00:37:50.800
we call sizeWithAttributes with that
attribute dictionary and get the width.

00:37:51.580 --> 00:37:55.500
Okay, so I mentioned the use
of NSLayoutManager.

00:37:55.500 --> 00:38:00.970
And this gives you a great
deal more control than these

00:38:00.970 --> 00:38:02.400
simple convenience methods.

00:38:02.400 --> 00:38:06.590
With NSLayoutManager,
you can get complete information

00:38:06.770 --> 00:38:09.560
about the contents of the layout,
about all the glyphs and all

00:38:09.560 --> 00:38:11.340
their positioning and so forth.

00:38:11.340 --> 00:38:13.770
It also has a lot more options.

00:38:13.770 --> 00:38:17.520
You can get complete
control over the process.

00:38:17.520 --> 00:38:20.930
Now, you've probably used
NSLayoutManager already,

00:38:20.930 --> 00:38:22.500
just not known about it.

00:38:22.500 --> 00:38:25.790
NSLayoutManager normally is
part of the hidden machinery

00:38:25.790 --> 00:38:27.480
that goes into NSTextView.

00:38:27.480 --> 00:38:31.170
But if you need it,
if you need that sort of power,

00:38:31.200 --> 00:38:33.580
then you can use it on its own.

00:38:35.650 --> 00:38:37.240
So how do you get a layout manager?

00:38:37.280 --> 00:38:41.270
Well, the simple and easiest method
is if you have a text view,

00:38:41.270 --> 00:38:43.930
or if you create a text view,
then you automatically get all

00:38:43.990 --> 00:38:47.780
the pieces of the Cocoa text
system provided for you.

00:38:47.800 --> 00:38:51.660
And these are NSTextStorage,
which is the contents of the text,

00:38:51.660 --> 00:38:55.460
the document, that is,
the characters and their attributes,

00:38:55.470 --> 00:38:57.270
the fonts, and so forth.

00:38:57.300 --> 00:39:00.270
NSTextContainer,
which describes the region within

00:39:00.270 --> 00:39:02.100
which the text is to be laid out.

00:39:02.220 --> 00:39:05.200
And then on the last, NSLayoutManager,
which is a central object that

00:39:05.290 --> 00:39:07.940
manages everything and will give
you all the information you need.

00:39:09.440 --> 00:39:13.000
If you don't want to have an
S-text view or if you want

00:39:13.060 --> 00:39:16.570
to completely customize this,
then you can create all these

00:39:16.620 --> 00:39:18.370
objects yourself and hook them up.

00:39:18.370 --> 00:39:19.900
It's a few more lines of code.

00:39:19.900 --> 00:39:23.480
Fortunately, we have some good examples,
such as the circle view example

00:39:23.480 --> 00:39:25.930
that shows exactly how to do that.

00:39:26.310 --> 00:39:28.800
So what does NS Layout Manager do?

00:39:29.010 --> 00:39:33.010
The basic job of the Layout
Manager is to take the text,

00:39:33.010 --> 00:39:37.300
that is, characters and their
attributes such as fonts,

00:39:37.300 --> 00:39:40.600
as described by an attributed string,
that is a text storage,

00:39:40.600 --> 00:39:46.500
and to convert them into a sequence
of glyphs and glyph positions.

00:39:46.500 --> 00:39:48.070
What is a glyph?

00:39:48.260 --> 00:39:53.220
A glyph is the fundamental displayable
element in a particular font.

00:39:53.250 --> 00:39:58.520
It might be a letter, an accent,
or a ligature combining multiple letters.

00:39:58.520 --> 00:40:03.330
So NS Layout Manager manages
the process of taking the text,

00:40:03.330 --> 00:40:07.700
the characters and their attributes,
and converting them into

00:40:07.860 --> 00:40:09.480
glyphs and their positions.

00:40:09.870 --> 00:40:14.510
And it provides all
this information to you.

00:40:14.800 --> 00:40:17.420
The most fundamental thing is
it provides the mapping from

00:40:17.420 --> 00:40:19.800
the characters to the glyphs.

00:40:19.800 --> 00:40:22.800
And in general, this is not necessarily
a one-to-one mapping.

00:40:22.800 --> 00:40:25.460
In fact, it can be many-to-many.

00:40:25.460 --> 00:40:29.820
A single character may require
multiple glyphs to represent it.

00:40:29.820 --> 00:40:35.080
Or a set of characters may be
represented by a single glyph.

00:40:35.080 --> 00:40:37.480
And Aslant Manager handles
all this for you.

00:40:37.480 --> 00:40:42.060
It makes sure that the
mapping is always in order.

00:40:42.060 --> 00:40:45.480
But in general, it's many-to-many.

00:40:45.490 --> 00:40:48.020
And whenever you have
a range in the text,

00:40:48.020 --> 00:40:51.960
you need to know whether you have a
range of characters or a range of glyphs.

00:40:51.960 --> 00:40:56.460
And you use Aslant Manager to
convert back and forth between these.

00:40:59.300 --> 00:41:03.800
And as I said,
NSLayoutManager also keeps track

00:41:03.800 --> 00:41:07.280
of the positions of these glyphs
as they're laid out in the text.

00:41:07.320 --> 00:41:11.800
And it will tell you, for example,
the size and position of any

00:41:11.820 --> 00:41:14.550
particular line in the text.

00:41:14.690 --> 00:41:19.710
And it will tell you the position of
any particular glyph within that line.

00:41:19.950 --> 00:41:24.640
And the thing to remember here from an
international perspective is that the

00:41:24.740 --> 00:41:29.010
ordering of glyphs within a line does
not necessarily bear any particular

00:41:29.010 --> 00:41:33.540
relationship to the ordering of
the characters that generated them.

00:41:33.600 --> 00:41:38.330
So some writing systems
write from left to right,

00:41:38.430 --> 00:41:39.930
some of them write from right to left.

00:41:40.100 --> 00:41:44.330
In some cases you will have text that
combines both of these in a single line.

00:41:44.360 --> 00:41:51.790
So it may start out from one end and then
turn around and go the other direction.

00:41:52.730 --> 00:41:57.130
So when you inquire of NS Layout
Manager about the positions of glyphs,

00:41:57.140 --> 00:42:00.980
you just need to make sure that you
do not assume that the positions of

00:42:00.980 --> 00:42:05.060
these glyphs are in any particular
order based on the ordering of the

00:42:05.060 --> 00:42:06.470
characters that generated them.

00:42:06.480 --> 00:42:07.620
So here's an example.

00:42:07.620 --> 00:42:10.130
Here at the top, we have the characters.

00:42:10.130 --> 00:42:13.760
We start off with some English,
and then we include some Arabic.

00:42:14.720 --> 00:42:18.150
And the glyphs down at the bottom,
let me point out a couple

00:42:18.150 --> 00:42:19.560
of things about these.

00:42:19.810 --> 00:42:23.820
First of all, right here,
we have an FI ligature glyph.

00:42:23.840 --> 00:42:26.710
That is two characters, F and I,
represented by a single glyph.

00:42:26.750 --> 00:42:30.970
So right here, even in English,
we have an example of a situation where

00:42:31.190 --> 00:42:35.890
the mapping between characters and
glyphs is not going to be one-to-one.

00:42:36.910 --> 00:42:41.130
Then when we go over to the Arabic,
what happens is that these

00:42:41.130 --> 00:42:44.600
Arabic characters at the
top are in logical order,

00:42:44.600 --> 00:42:47.800
in the order they appear in the text,
but then when they're

00:42:47.800 --> 00:42:51.560
going to be displayed,
their order will be from right

00:42:51.560 --> 00:42:53.220
to left within this line.

00:42:53.500 --> 00:42:56.660
So the positional ordering of
the glyphs is different from the

00:42:56.660 --> 00:42:58.750
logical ordering of the characters.

00:42:58.820 --> 00:43:03.340
And another thing to notice
is that these glyph forms,

00:43:03.340 --> 00:43:07.070
as they appear in context here,
are quite a bit different from

00:43:07.340 --> 00:43:12.910
the context-independent appearance
that I've shown up at the top.

00:43:12.940 --> 00:43:17.100
So these glyphs change shape depending
on where they appear in a word.

00:43:20.300 --> 00:43:23.630
NSLayoutManager also provides
some higher level information.

00:43:23.630 --> 00:43:27.160
Things like you can go from ranges
of characters and glyphs in the

00:43:27.210 --> 00:43:31.960
text to rects within the layout.

00:43:32.080 --> 00:43:34.630
And here again,
the thing to remember is that

00:43:34.630 --> 00:43:39.110
even within a single line,
within a single range of glyphs,

00:43:39.120 --> 00:43:44.170
because they can be reordered,
you may end up with multiple rects

00:43:44.330 --> 00:43:46.880
that you need to represent them.

00:43:47.460 --> 00:43:50.800
NSLayout Manager provides
information about insertion points,

00:43:50.800 --> 00:43:54.640
potential insertion points in the text,
and it can go the other direction.

00:43:54.640 --> 00:43:59.450
If you're given a location in the layout,
it can go back and determine

00:43:59.450 --> 00:44:01.140
what glyph that corresponds to.

00:44:01.140 --> 00:44:05.470
Or if you're given a rect in the layout,
it can go back and determine the

00:44:05.560 --> 00:44:07.840
glyph range that it encompasses.

00:44:09.410 --> 00:44:13.950
So here is a brief example of
how we might have used that if

00:44:13.950 --> 00:44:17.960
we wanted to measure the width
of certain pieces of text.

00:44:18.020 --> 00:44:22.620
In this case, we have a text view,
suppose, and from the text view,

00:44:22.620 --> 00:44:24.520
we get the layout manager
and the text container.

00:44:24.520 --> 00:44:29.540
And then if we've determined a particular
range of text that we want the width for,

00:44:29.560 --> 00:44:33.640
then we can go through and call
this method rect array for character

00:44:33.640 --> 00:44:35.890
range and so forth and so forth.

00:44:35.900 --> 00:44:39.230
And it returns a C array of rect.

00:44:39.300 --> 00:44:43.140
And then, as I said,
there may be multiple rects

00:44:43.140 --> 00:44:47.620
even needed to represent one
contiguous range in the text.

00:44:47.620 --> 00:44:53.420
So we go through and add up the widths
of all these rects to get the total

00:44:53.420 --> 00:44:56.470
width of this portion of the text.

00:44:59.760 --> 00:45:03.780
So, points I want you to take away.

00:45:03.780 --> 00:45:08.500
You should let the Cocoa framers
do as much as possible for you,

00:45:08.600 --> 00:45:12.860
handling internationalization
and international issues.

00:45:12.950 --> 00:45:16.840
And you need to avoid any of
the problematic assumptions,

00:45:16.880 --> 00:45:19.220
things like assuming that a
single keystroke corresponds

00:45:19.280 --> 00:45:22.320
to a single character,
or that a single character

00:45:22.540 --> 00:45:25.750
corresponds to a single glyph,
or that the locale is

00:45:25.750 --> 00:45:28.430
equivalent to the localization.

00:45:28.690 --> 00:45:34.960
or that all the glyphs in a line
are ordered from left to right.

00:45:35.010 --> 00:45:36.560
Use UniCode.

00:45:36.960 --> 00:45:41.020
Use NSString as much as possible to
handle the heavy lifting for you.

00:45:41.140 --> 00:45:45.220
Use the date and number formatters
for user-visible dates and numbers,

00:45:45.240 --> 00:45:47.480
and use the 10.4 behavior for these.
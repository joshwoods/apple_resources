WEBVTT

00:00:10.490 --> 00:00:12.090
Hello!

00:00:12.090 --> 00:00:16.470
And welcome to the strawberry-themed
Core Animation session.

00:00:17.140 --> 00:00:19.460
The animation you see in the
background here has not been

00:00:19.460 --> 00:00:22.200
made with Core Animation,
but it could be.

00:00:22.200 --> 00:00:26.270
I bet it's like 500 lines of code.

00:00:27.590 --> 00:00:30.690
Anyway, yeah, that's me.

00:00:31.030 --> 00:00:35.300
So let me talk a bit about the
entertainment for the coming hour.

00:00:35.810 --> 00:00:39.320
So I will give you a brief
introduction of what Core Animation is,

00:00:39.350 --> 00:00:41.670
an architectural overview,
what is in the system,

00:00:41.670 --> 00:00:44.700
and what are the key
components that make it work.

00:00:44.820 --> 00:00:49.390
And we're going to talk about layers
and their APIs and the animation model.

00:00:50.070 --> 00:00:53.880
And towards the end,
we're going to talk a bit about how

00:00:53.880 --> 00:00:57.200
it fits in with the higher-level
frameworks like AppKit and how Interface

00:00:57.200 --> 00:01:06.190
Builder helps you to get to these
features a bit easier than writing code.

00:01:06.810 --> 00:01:08.990
Kind of the motivation.

00:01:09.150 --> 00:01:11.670
So it turns out that doing
these composite animated

00:01:11.750 --> 00:01:14.080
dynamic UIs is kind of hard.

00:01:14.220 --> 00:01:18.420
And what you think about--
somebody got that joke.

00:01:18.420 --> 00:01:19.880
OK.

00:01:22.720 --> 00:01:25.020
So if you think about, say,
the Keynote Canvas that

00:01:25.020 --> 00:01:27.130
you're seeing here,
or iChat U+3 where you

00:01:27.140 --> 00:01:31.030
see a picture here,
or Front Row, you tend to have a lot of

00:01:31.030 --> 00:01:33.080
images and text moving around.

00:01:33.080 --> 00:01:37.160
You try to get smooth animation
and seamless compositing

00:01:37.220 --> 00:01:38.380
and these kind of things.

00:01:38.400 --> 00:01:41.310
And you have to do quite
a bit of work to get that.

00:01:41.510 --> 00:01:46.180
So we thought, well,
that is the kind of type of work

00:01:46.180 --> 00:01:46.180
that the OS could do for you.

00:01:46.380 --> 00:01:49.950
Let me give you a short demo
to give you a kind of visual

00:01:49.950 --> 00:01:51.610
of what I'm talking about.

00:02:01.380 --> 00:02:04.580
Okay, so this is kind of a toy app.

00:02:04.690 --> 00:02:06.100
It's a recipes browser.

00:02:06.270 --> 00:02:10.630
So you select a dessert, then move over,
and then scroll through

00:02:10.810 --> 00:02:14.300
your list of something,
and you scroll further,

00:02:14.300 --> 00:02:15.900
and this kind of thing.

00:02:15.900 --> 00:02:17.740
And you notice it's smooth animation.

00:02:17.740 --> 00:02:21.200
There are definitely several
layers being composited here.

00:02:22.870 --> 00:02:24.270
That's all for the demo for now.

00:02:24.360 --> 00:02:28.460
Just keep that image in
mind as I'm going forward.

00:02:35.590 --> 00:02:38.080
So a bunch of examples, yeah,
you can read those.

00:02:38.080 --> 00:02:42.870
It is used in Leopard for a slideshow,
the time machine, the workspaces,

00:02:42.870 --> 00:02:47.250
preferences pane,
and the composition picker, the image,

00:02:47.250 --> 00:02:50.260
what is it, picture taker panel now?

00:02:50.260 --> 00:02:52.900
These kind of things.

00:02:53.090 --> 00:02:56.440
Here's kind of the architecture
diagram how this all fits in.

00:02:56.450 --> 00:03:00.280
So Core Animation sits
primarily on top of Core Image,

00:03:00.300 --> 00:03:03.520
and which in turn then
sits on top of OpenGL,

00:03:03.520 --> 00:03:06.950
and some of it sits on top of Quartz.

00:03:07.370 --> 00:03:10.890
So this is kind of an interesting
point that Core Animation,

00:03:10.950 --> 00:03:14.300
every single frame,
will build a filter chain in

00:03:14.430 --> 00:03:17.600
Core Image that then renders its output.

00:03:18.320 --> 00:03:21.600
On top of Core Animation,
there are essentially the clients.

00:03:21.610 --> 00:03:24.370
So the dot dot dot is your app.

00:03:29.390 --> 00:03:31.720
Cocoa sits on top of it,
QuickTime sits on top of it,

00:03:31.800 --> 00:03:36.300
and as I mentioned before,
a bunch of system apps are using it.

00:03:38.450 --> 00:03:42.550
Okay, so this is kind of the goals
for the framework slide.

00:03:42.700 --> 00:03:45.900
So the goal is really to get
high-performance compositing animation,

00:03:45.900 --> 00:03:49.160
which really means 60 frames per second,
or whatever the refresh

00:03:49.300 --> 00:03:50.900
rate of your display is.

00:03:51.280 --> 00:03:53.300
It's also important to have
something that one can,

00:03:53.460 --> 00:03:56.400
you know, is in kind of a manageable
state to work with,

00:03:56.400 --> 00:04:00.430
and for that we chose an
NSU-like recursive abstraction.

00:04:00.510 --> 00:04:02.860
So you have a layer and it has
a bunch of sub-layers and it

00:04:02.910 --> 00:04:04.380
kind of does what you expect.

00:04:04.460 --> 00:04:07.100
So if you move that layer,
all its children layer move with it,

00:04:07.100 --> 00:04:08.150
these kind of things.

00:04:08.200 --> 00:04:16.190
Also important is to have an
abstract interface for animations.

00:04:16.190 --> 00:04:20.330
And what that really means,
you don't have a callback that says,

00:04:20.340 --> 00:04:23.500
"Okay, what do I do this frame,
and then this time, this time,

00:04:23.500 --> 00:04:26.850
and once more." So nothing that
really runs at 60 frames per second,

00:04:26.960 --> 00:04:30.200
you want to have a sufficiently
abstract representation of that,

00:04:30.200 --> 00:04:33.200
which is, "Okay,
this object needs to move from A to B,

00:04:33.200 --> 00:04:36.190
and it takes half a second."

00:04:36.930 --> 00:04:40.130
So the key message on this
slide is the animation is done

00:04:40.180 --> 00:04:42.000
for you by Core Animation.

00:04:42.000 --> 00:04:43.800
And it happens on a separate thread.

00:04:43.800 --> 00:04:46.860
The key there is if you do
animation in your run loop,

00:04:47.020 --> 00:04:49.180
well,
you're kind of at the mercy of the other

00:04:49.180 --> 00:04:50.820
workload that the run loop has to do.

00:04:51.210 --> 00:04:53.540
Every now and then an application
goes and hits the disk and reads

00:04:53.620 --> 00:04:55.560
the database and stuff like that,
and that's really not

00:04:55.560 --> 00:04:56.690
good for smooth animation.

00:04:56.850 --> 00:05:00.540
So that's why all the animation
happens on a separate thread.

00:05:01.190 --> 00:05:03.760
So how to get performance?

00:05:03.780 --> 00:05:06.200
Well, first rule is minimize redraw.

00:05:06.200 --> 00:05:09.600
And what I mean with that is the
layer has to produce content.

00:05:09.600 --> 00:05:12.760
Well, there's a function being called,
and you're doing your

00:05:12.760 --> 00:05:14.120
drawing essentially.

00:05:14.120 --> 00:05:15.700
And the key is you do that only once.

00:05:15.720 --> 00:05:19.540
Essentially,
you get a key when the layer content

00:05:19.540 --> 00:05:24.200
is needed for the first time,
you get that callback, and from then on,

00:05:24.330 --> 00:05:26.890
The contents of the layer
is stored in a buffer,

00:05:26.940 --> 00:05:31.060
so all the animation can happen
without application code.

00:05:31.060 --> 00:05:33.160
That ties into my second
bullet point here,

00:05:33.160 --> 00:05:36.800
which is to minimize application
code during resize and re-layout.

00:05:36.860 --> 00:05:39.960
If you resize your window,
most of the content actually

00:05:39.960 --> 00:05:42.540
doesn't need to be redrawn,
it just needs to be repositioned.

00:05:42.600 --> 00:05:45.210
Imagine you have a title
and the title just slides,

00:05:45.380 --> 00:05:49.140
it has to be centered in the window,
but other than that,

00:05:49.140 --> 00:05:53.160
having bits for the title
is perfectly sufficient.

00:05:53.370 --> 00:05:58.090
So in the case where essentially the
application doesn't do anything special,

00:05:58.100 --> 00:06:01.150
so it doesn't process an event,
then essentially there

00:06:01.150 --> 00:06:04.300
should be no application code
running at the frame rate.

00:06:04.300 --> 00:06:07.510
So everything has been
described in advance,

00:06:07.510 --> 00:06:10.540
all the motion and so on,
and the application just does

00:06:10.620 --> 00:06:12.300
nothing and waits for events.

00:06:12.300 --> 00:06:17.000
And all these together then
ensure a consistent frame rate,

00:06:17.000 --> 00:06:19.190
well, as you can expect.

00:06:19.300 --> 00:06:24.780
So let me talk a bit more about how
that actually happens under the covers.

00:06:25.590 --> 00:06:29.330
So first, there is a concept we
call the layer tree,

00:06:29.370 --> 00:06:32.000
which is the representation
that the application sees.

00:06:32.000 --> 00:06:34.830
So you have layers, you have sub-layers,
and you have the nice

00:06:34.830 --> 00:06:36.500
visual here in orange.

00:06:36.500 --> 00:06:39.300
And that's the application-exposed API.

00:06:39.300 --> 00:06:42.280
So this is the data
structure you work with.

00:06:42.320 --> 00:06:45.440
And it has this concept of implicit
animation and implicit layout,

00:06:45.440 --> 00:06:46.680
which I will explain a bit later.

00:06:46.680 --> 00:06:51.070
Kind of the man behind the
curtain is the green tree here,

00:06:51.110 --> 00:06:55.280
which we call the render tree,
which is a copy of that data structure.

00:06:55.280 --> 00:06:58.850
And that's the data structure that is
being traversed at 60 frames a second.

00:06:58.850 --> 00:07:04.160
And it all does the explicit animation
and is managed by the runtime.

00:07:04.160 --> 00:07:07.440
So your application will
never see the render tree,

00:07:07.440 --> 00:07:10.360
but it's kind of important
to know that it's there.

00:07:10.360 --> 00:07:13.160
Because this is what it does.

00:07:13.160 --> 00:07:16.660
So we have a kind of a visual here.

00:07:16.690 --> 00:07:21.180
On the left side,
imagine this is your code.

00:07:21.300 --> 00:07:23.940
And you want to change
the position of a layer.

00:07:24.050 --> 00:07:29.190
So you essentially say,
set frame origin to some xy value.

00:07:29.190 --> 00:07:33.260
And that is instantaneous from
your application's perspective.

00:07:33.260 --> 00:07:35.400
So your layer data structure has updated.

00:07:35.400 --> 00:07:36.870
It's now at position xy.

00:07:36.870 --> 00:07:41.190
But the render tree is doing
the animation from the original

00:07:41.190 --> 00:07:43.320
point to the new location.

00:07:43.340 --> 00:07:46.640
Similarly, if you add an animation
to the new location,

00:07:46.640 --> 00:07:46.640
it's going to do the same thing.

00:07:46.640 --> 00:07:50.870
So if you want to remove a layer,
what happens is there is, for example,

00:07:50.870 --> 00:07:52.590
a fade-in animation going on.

00:07:53.380 --> 00:07:56.310
And the third example I have
is if you replace an entire

00:07:56.310 --> 00:08:00.970
subtree with a new subtree,
you get a transition effect.

00:08:03.720 --> 00:08:07.170
So, the first bullet point is
kind of the most important

00:08:07.240 --> 00:08:09.360
piece of the entire session.

00:08:09.360 --> 00:08:12.670
If you change the
properties of your layer,

00:08:12.670 --> 00:08:15.560
it triggers implicit animation.

00:08:15.560 --> 00:08:15.560
And the key is,

00:08:15.970 --> 00:08:19.390
On your side,
that change is instantaneous,

00:08:19.390 --> 00:08:21.960
and the fact that there is
animation going on happens

00:08:21.960 --> 00:08:24.280
completely transparently to you.

00:08:24.700 --> 00:08:30.140
So there's also an ability to
batch multiple animations together.

00:08:30.140 --> 00:08:31.150
Essentially,
you say something like "begin

00:08:31.240 --> 00:08:34.330
transaction" and add two layers,
remove two others,

00:08:34.480 --> 00:08:36.660
and change the content of a fifth one.

00:08:36.680 --> 00:08:38.980
And then you say "commit
transaction" and then all of these

00:08:38.980 --> 00:08:40.760
animations happen at the same time.

00:08:40.860 --> 00:08:48.590
So this ensures that even though all the
rendering is done on a second thread,

00:08:48.590 --> 00:08:48.590
that they're never part of
a partial update visible.

00:08:49.370 --> 00:08:53.800
I'd also like to make the point
that layers are lightweight.

00:08:53.800 --> 00:08:58.290
That kind of sounds odd if you actually
have bits around representing the bitmap,

00:08:58.440 --> 00:09:03.300
but what I mean with that is the actual
layer data structure is around 100 bytes.

00:09:03.300 --> 00:09:06.940
And the reason for that is you can
actually build systems that have

00:09:06.940 --> 00:09:10.300
fairly large numbers of layers,
like in the thousands.

00:09:10.300 --> 00:09:14.300
So, the example I just showed,
the recipe browser, that's in the dozens,

00:09:14.300 --> 00:09:19.410
but the example you saw in the keynote
with the album art building the city,

00:09:19.410 --> 00:09:21.300
it's about 6,000 layers.

00:09:21.300 --> 00:09:23.580
So, at that point,
even though most of these

00:09:23.580 --> 00:09:26.260
layers reference the same bits,
there aren't actually

00:09:26.350 --> 00:09:29.480
6,000 albums in that demo,
but the state of the

00:09:29.480 --> 00:09:32.490
layers needs to be present,
so having that small

00:09:32.490 --> 00:09:33.900
is kind of important.

00:09:34.310 --> 00:09:36.040
And yeah, all of this is configurable.

00:09:36.040 --> 00:09:39.720
So when you set the position,
you get the slide animation

00:09:39.720 --> 00:09:42.700
for free by a week.

00:09:42.750 --> 00:09:48.040
But you can specify durations,
timing curves, motion paths,

00:09:48.040 --> 00:09:51.030
transition types,
and these kind of things.

00:09:52.030 --> 00:09:53.740
And yeah, all of this is configurable.

00:09:53.740 --> 00:09:57.420
So when you set the position,
you get the slide animation

00:09:57.420 --> 00:09:57.910
for free by a week.

00:09:58.150 --> 00:10:03.570
The entire scene is described as a
Core Image processing graph essentially,

00:10:03.570 --> 00:10:07.210
and that in turn sits on top of OpenGL.

00:10:07.700 --> 00:10:10.990
There is also a second render
implementation available,

00:10:10.990 --> 00:10:13.990
which is essentially rendering
into a Core Graphics context.

00:10:14.040 --> 00:10:18.890
What that enables is you can
render your scene into a PDF file,

00:10:18.890 --> 00:10:22.460
which then is your spool file format,
and you can actually print this stuff.

00:10:22.790 --> 00:10:26.510
There's a caveat here:
Core Image filters at this point

00:10:26.510 --> 00:10:30.620
cannot be expressed in a PDF,
so these layers that have

00:10:30.770 --> 00:10:34.090
Core Image filters on
it will get rasterized.

00:10:37.060 --> 00:10:39.560
Okay, a word about the compositing model.

00:10:39.830 --> 00:10:40.690
It's kind of what you expect.

00:10:40.770 --> 00:10:41.470
It's back to front.

00:10:41.520 --> 00:10:44.900
So if you have a bunch of pure layers,
the first one in the array is

00:10:45.030 --> 00:10:47.200
the one that goes to the back,
the next one goes on top of it,

00:10:47.200 --> 00:10:49.360
and the next one goes
on top of the other two,

00:10:49.360 --> 00:10:49.870
and so on.

00:10:49.880 --> 00:10:53.160
And because everything is
sitting on top of Core Image,

00:10:53.740 --> 00:10:58.510
you can add filter effects.

00:10:58.570 --> 00:11:01.520
There are actually three
different hooks on the layer data

00:11:01.520 --> 00:11:03.600
structure to add filter effects.

00:11:03.600 --> 00:11:05.530
Let me give you an example of those.

00:11:06.490 --> 00:11:08.780
So the most obvious one
is the content filter,

00:11:08.780 --> 00:11:11.780
which is a filter that gets run
on the content of the layer.

00:11:11.820 --> 00:11:15.920
And so I tried to visualize
that here by having a text layer

00:11:15.920 --> 00:11:19.120
which has a distortion on it,
and underneath there is

00:11:19.120 --> 00:11:21.280
the flower picture layer.

00:11:22.760 --> 00:11:25.630
Similarly, there is a background filter,
which is the filter that gets

00:11:25.760 --> 00:11:28.700
applied before the layer is
composited into the scene.

00:11:28.700 --> 00:11:32.700
It's reasonably visible on the screen.

00:11:32.730 --> 00:11:38.700
An example here is you can put a
blur underneath that Seattle 2002

00:11:38.700 --> 00:11:42.940
badge to essentially reduce the
contrast of the scene underneath and

00:11:43.000 --> 00:11:46.050
give it a bit more polished look.

00:11:46.790 --> 00:11:50.320
And the third filter is the
compositing filter itself.

00:11:50.380 --> 00:11:53.430
So you specify how the contents
of your layer is merged

00:11:53.430 --> 00:11:54.700
into the rest of the scene.

00:11:54.700 --> 00:11:58.670
And most likely you're
going to use the default,

00:11:58.720 --> 00:12:02.590
which is Source Over,
which is good for 95% of all cases.

00:12:02.700 --> 00:12:07.700
There are some cases where it can change,
and I have an example here.

00:12:07.700 --> 00:12:12.700
So if you want to add this mirror flare,
then this is an object

00:12:12.700 --> 00:12:14.700
that kind of emits light.

00:12:14.700 --> 00:12:18.760
So it's better to use the addition
compositing mode instead of source over.

00:12:20.360 --> 00:12:25.820
Okay, in the keynote you saw a lot of 3D,
which was kind of misleading.

00:12:25.830 --> 00:12:28.520
So although you can 3D,
and let me talk a bit

00:12:28.520 --> 00:12:31.560
about what that means,
the concept is really a

00:12:31.570 --> 00:12:34.180
layer can have a transform,
perspective transform.

00:12:34.180 --> 00:12:36.780
So it's the concept of you
have a bunch of planes stacked,

00:12:36.850 --> 00:12:38.330
somehow arranged in space.

00:12:38.330 --> 00:12:42.520
And Core Animation will do
the depth sorting for you.

00:12:42.550 --> 00:12:45.260
However,
it will not handle layer intersections.

00:12:45.260 --> 00:12:50.230
So if you have two layers that intersect,
then you will get corrupt rendering.

00:12:50.300 --> 00:12:51.460
Thank you.

00:12:53.970 --> 00:12:57.540
That essentially makes sure that
transparency works as expected,

00:12:57.580 --> 00:12:59.390
but I'd really like to
stress the latest point:

00:12:59.420 --> 00:13:01.750
it's not a 3D engine,
it really works with layers

00:13:01.820 --> 00:13:02.810
and not with 3D objects.

00:13:02.920 --> 00:13:04.740
There is no Z-buffer,
and if you're trying to

00:13:04.740 --> 00:13:08.740
implement Doom 3 with this,
you're probably going to be in trouble.

00:13:09.920 --> 00:13:15.680
With that, I would like to go back
to the strawberry demo.

00:13:21.340 --> 00:13:25.200
and explain a bit more about what
this application is actually doing.

00:13:25.200 --> 00:13:28.440
So at this point, what you notice,
there is a selection layer which

00:13:28.520 --> 00:13:30.500
has this little pulsing glow on it.

00:13:30.500 --> 00:13:33.460
So this is the CI Bloom filter that
is running there and there is an

00:13:33.460 --> 00:13:37.860
animation set up which just pulses
it up and down every once a second.

00:13:37.860 --> 00:13:40.780
So the application is not doing anything
once it's set up that animation,

00:13:40.780 --> 00:13:42.260
it's just running by itself.

00:13:42.260 --> 00:13:45.680
What the application is
doing is waiting for events.

00:13:45.680 --> 00:13:50.770
And if I hit the arrow down key,
all it is doing here,

00:13:50.770 --> 00:13:57.100
it is setting the XY position of that
selection layer to be on the new item.

00:13:57.100 --> 00:13:59.880
So the animation that's
happening is implicit,

00:13:59.880 --> 00:14:04.110
it's done in the render tree and as
far as the application is concerned,

00:14:04.280 --> 00:14:08.270
as soon as I hit that key,
the layer is at the new position.

00:14:09.000 --> 00:14:12.420
That allows you to do things,
let me add the shift key here

00:14:12.420 --> 00:14:14.460
to make a bit of slow motion.

00:14:14.460 --> 00:14:19.940
So if I actually Q up two key
upstrokes or QD two key downstrokes,

00:14:19.940 --> 00:14:22.000
you see there's a single
animation going on because from

00:14:22.270 --> 00:14:25.220
the application perspective,
it set it to the second position

00:14:25.220 --> 00:14:27.900
and then right after that
set it to the third position.

00:14:28.140 --> 00:14:30.970
While the render tree is interpolating
from the current position to whatever

00:14:30.970 --> 00:14:35.770
the goal state is so it will slide
two elements up in this case.

00:14:37.030 --> 00:14:41.620
Similarly, if I move sideways,
what's happening here is there's

00:14:41.680 --> 00:14:42.880
a transition effect going on.

00:14:42.900 --> 00:14:45.110
So there's a subtree which
makes up these layers,

00:14:45.110 --> 00:14:46.850
and there's a subtree which
makes up these layers,

00:14:46.920 --> 00:14:49.630
and essentially all I'm doing
is I'm replacing the original

00:14:49.630 --> 00:14:52.730
subtree with a new subtree,
and yet transition

00:14:52.730 --> 00:14:54.640
animation is set to slide.

00:14:54.670 --> 00:14:56.740
That's how you get this effect.

00:14:56.740 --> 00:15:00.190
Note that the title actually
is doing a crossfade.

00:15:01.090 --> 00:15:04.760
Let me do that in slow
motion to make it obvious.

00:15:04.830 --> 00:15:07.390
So actually two different--

00:15:08.060 --> 00:15:12.240
Transition effects are set
for that single keystroke.

00:15:12.250 --> 00:15:15.240
And one interesting detail,
the slide animation needs to know whether

00:15:15.240 --> 00:15:16.930
it has to slow the slide left or right.

00:15:17.050 --> 00:15:18.110
So that's what happens as well.

00:15:18.190 --> 00:15:20.720
So once we get the keystroke,
we set the transition to be

00:15:20.720 --> 00:15:23.360
left or right to give us the
illusion that this is actually

00:15:23.360 --> 00:15:25.470
some kind of spatial arrangement.

00:15:26.390 --> 00:15:30.590
One pane over,
what we have here an image with alpha,

00:15:30.620 --> 00:15:34.380
we have resizing, we mentioned that.

00:15:34.380 --> 00:15:40.420
So I can just take this window and go
resize it and you see text is reflowing.

00:15:40.420 --> 00:15:44.080
And what's happening is most of
these layers don't get redrawn

00:15:44.080 --> 00:15:47.960
on a resize because in fact the
title just moves to a new position,

00:15:47.960 --> 00:15:51.060
the image just moves to
a new position and so on.

00:15:51.060 --> 00:15:54.820
It's the center layer which has
the text which needs to reflow.

00:15:54.820 --> 00:16:00.300
So that one gets an event to
redraw and everything else is,

00:16:00.300 --> 00:16:01.940
oops that was an interesting glitch.

00:16:02.200 --> 00:16:09.370
So everything else is just working.

00:16:10.460 --> 00:16:14.920
Last item I would like to show is
you can also put movies in layers.

00:16:14.920 --> 00:16:19.830
So, I don't know, it's a masterpiece.

00:16:20.160 --> 00:16:26.140
So note that the movie has rounded
corners and they're nicely anti-aliased,

00:16:26.160 --> 00:16:29.940
so you can add a mask to a
movie and essentially things

00:16:29.940 --> 00:16:31.720
just happen as they should.

00:16:31.970 --> 00:16:34.940
It's going to go on like this and
it's not particularly interesting.

00:16:34.940 --> 00:16:46.270
So with that, the demo is over.

00:16:49.470 --> 00:16:54.240
I'm going to invite John Harper up to
talk about a really important thing,

00:16:54.240 --> 00:16:59.830
which is code.

00:17:01.910 --> 00:17:06.800
OK, so now we're going to talk
about the APIs involved here.

00:17:06.880 --> 00:17:11.900
So the key thing to remember is
that core animation is basically a

00:17:11.900 --> 00:17:15.700
property-based kind of data-driven model,
which means that you set up

00:17:15.760 --> 00:17:18.900
this tree of these objects,
which Ralf was talking about,

00:17:18.900 --> 00:17:20.660
and you set a bunch of properties.

00:17:20.770 --> 00:17:23.550
Maybe set some animations
up and let it run.

00:17:23.620 --> 00:17:27.560
So you've probably seen the new
property stuff in Objective C2.

00:17:27.570 --> 00:17:30.000
And we take a huge amount of use of that.

00:17:30.030 --> 00:17:32.450
And that basically means you
can say let or something instead

00:17:32.760 --> 00:17:35.160
of using these weird brackets.

00:17:35.160 --> 00:17:38.900
And the other important thing is,
since we have this database model,

00:17:38.900 --> 00:17:42.560
we have kind of the
idea of a transaction.

00:17:42.560 --> 00:17:45.610
And a transaction basically is a way of
batching up changes to the render tree

00:17:45.920 --> 00:17:49.080
such that you never see kind of little
partial updates or anything like that.

00:17:49.120 --> 00:17:52.370
So the idea is that you basically
have one transaction per event loop,

00:17:52.410 --> 00:17:54.380
or per run through the event loop.

00:17:54.380 --> 00:17:58.020
And then everything is committed from the
layer tree to the render tree in one go.

00:17:58.020 --> 00:17:59.960
And you just see this kind
of nice atomic update.

00:17:59.960 --> 00:17:59.960
So you can see that you can
actually run through the event loop.

00:17:59.960 --> 00:17:59.960
And then everything is committed from the
layer tree to the render tree in one go.

00:17:59.960 --> 00:18:00.160
And you just see this kind
of nice atomic update.

00:18:00.160 --> 00:18:02.320
on screen.

00:18:02.320 --> 00:18:03.060
OK.

00:18:03.100 --> 00:18:06.740
So now we're going to go
through basically the different

00:18:06.740 --> 00:18:08.600
things that make up a layer.

00:18:08.600 --> 00:18:10.830
These are all basically
Objective C properties.

00:18:10.840 --> 00:18:14.990
And they break down into a few groups,
which we're going to step through.

00:18:15.090 --> 00:18:17.820
First of all,
you give your layer some geometry.

00:18:17.820 --> 00:18:21.420
And this is pretty similar to NSView,
where you have a bound direct.

00:18:21.420 --> 00:18:23.320
In our case,
the frame is slightly different in that

00:18:23.320 --> 00:18:27.420
it's based as a position and a transform.

00:18:27.420 --> 00:18:30.900
And the position is basically
a point in the super layer

00:18:30.900 --> 00:18:33.480
where the layer will show up.

00:18:33.480 --> 00:18:37.440
We also allow you to have kind of rounded
corners and this kind of 4 by 4 matrix.

00:18:37.440 --> 00:18:41.200
And this OK transform is basically
like CG Afro and transform,

00:18:41.350 --> 00:18:43.140
except it's a 4 by 4.

00:18:43.630 --> 00:18:47.710
OK, so once you've set up the geometry,
if you think of these kind of multiple

00:18:47.710 --> 00:18:51.390
components forming the Les image,
the next point is the background.

00:18:51.440 --> 00:18:54.980
And this is an arbitrary CG color,
so you can have things like shadings,

00:18:54.980 --> 00:18:59.080
which are gradients, or patterns,
or just solid colors.

00:18:59.080 --> 00:19:01.510
Once you have the background,
on top of the background,

00:19:01.630 --> 00:19:03.310
you get the content.

00:19:03.530 --> 00:19:08.260
And typically the content is a CG image,
or a few other types of object.

00:19:08.280 --> 00:19:12.090
This little guy here is too
small to fill his actual bounds.

00:19:12.260 --> 00:19:18.680
So we've aligned them to the bottom
right-hand side of the bounds.

00:19:18.840 --> 00:19:21.720
And we've done that through
this contents gravity property.

00:19:21.730 --> 00:19:22.780
And there's a bunch of options.

00:19:22.780 --> 00:19:24.670
You can just align it,
or tell it to resize,

00:19:24.670 --> 00:19:27.540
or whatever you feel is the right thing.

00:19:27.660 --> 00:19:31.250
So as Ralph mentioned,
it's a fully recursive compositing model,

00:19:31.250 --> 00:19:34.400
so every layer has a set of sub-layers.

00:19:34.520 --> 00:19:36.810
And you can either just set
this array directly by saying

00:19:36.820 --> 00:19:39.570
layer.sublayers equals something,
or we give you a bunch of

00:19:39.570 --> 00:19:43.700
convenient methods to say,
kind of add sub-layer, remove sub-layer,

00:19:43.700 --> 00:19:45.440
things like that.

00:19:45.440 --> 00:19:50.710
OK, finally, we let you put a border,
which is just a stroked line, basically,

00:19:50.740 --> 00:19:51.980
on top of the content.

00:19:51.980 --> 00:19:53.670
This is kind of nice,
because often you want to have some

00:19:53.720 --> 00:19:56.500
kind of border around your content.

00:19:56.510 --> 00:19:58.450
And you want to be able to animate it,
so it's just nice not to

00:19:58.500 --> 00:20:00.580
have to draw it with CG,
or something like that.

00:20:00.580 --> 00:20:02.410
Again,
this can be any type of color object.

00:20:02.620 --> 00:20:05.580
So you can have gradient-based borders,
or whatever.

00:20:05.580 --> 00:20:09.400
OK, so now we've basically made
up the content for the layers.

00:20:09.400 --> 00:20:11.170
We've got the background,
and the content,

00:20:11.180 --> 00:20:14.300
the actual image content,
and the sub-layers, and the border.

00:20:14.300 --> 00:20:16.360
We basically turn that
into a single CI image,

00:20:16.360 --> 00:20:18.590
and then kind of pass it
through these next stages,

00:20:18.590 --> 00:20:20.750
the first of which is we
let you apply filters,

00:20:20.750 --> 00:20:23.460
as Rob showed in some of his slides.

00:20:23.470 --> 00:20:25.070
So in this case,
it's just a simple morphology

00:20:25.070 --> 00:20:30.020
filter to give it something
that stands up on the stage.

00:20:30.060 --> 00:20:32.910
The next stage after filters
is you can apply a shadow,

00:20:32.930 --> 00:20:34.160
typically not a red one.

00:20:34.160 --> 00:20:38.820
But in the shadow,
you have these various parameters.

00:20:38.820 --> 00:20:41.780
It's pretty simple stuff,
just to blur the layer and

00:20:41.780 --> 00:20:43.660
colorize to Southwood Channel.

00:20:43.830 --> 00:20:47.470
Okay, finally,
you get to supply a global opacity.

00:20:47.510 --> 00:20:49.600
So obviously,
this is proper group opacity

00:20:49.600 --> 00:20:52.370
and you don't have to worry
about any of that stuff.

00:20:53.070 --> 00:20:58.550
OK, so once we've finished this
filtered layer and we've applied

00:20:58.640 --> 00:21:01.240
the opacity on the filter,
we use the compositing filter

00:21:01.300 --> 00:21:03.220
to put this into the backdrop.

00:21:03.530 --> 00:21:06.600
But I guess the one interesting
thing is that it's not the backdrop.

00:21:06.670 --> 00:21:10.340
It's potentially the filtered backdrop.

00:21:10.440 --> 00:21:12.750
And we'll come to what that
means on the next slide,

00:21:12.970 --> 00:21:15.110
where you can apply a mask to the layer.

00:21:15.290 --> 00:21:17.890
And a mask is not just something
that cuts out the shape,

00:21:17.910 --> 00:21:22.860
it's actually dissolving the content
of the previous stage through the

00:21:22.860 --> 00:21:25.100
mask into the unfiltered backdrop.

00:21:25.140 --> 00:21:26.720
So you can have things like,
this is basically how you

00:21:26.720 --> 00:21:29.300
apply your background blurs,
because you can blur the entire

00:21:29.320 --> 00:21:34.120
backdrop and then mask out everything
that's outside the layer itself.

00:21:34.140 --> 00:21:35.510
And there are two ways
to specify the mask.

00:21:35.560 --> 00:21:38.920
You can either just say,
give me a mask the size of my layer,

00:21:38.950 --> 00:21:42.870
or supply another kind of sub-layer,
which can be anything,

00:21:42.870 --> 00:21:44.100
we just take it as alpha channel.

00:21:44.380 --> 00:21:47.160
So this means you can actually
have animating layers,

00:21:47.160 --> 00:21:49.140
animating masks,
or Quartz Composer masks,

00:21:49.140 --> 00:21:49.980
or whatever you want.

00:21:51.480 --> 00:21:55.480
Okay, so that was basically the layer
kind of-- the layer as it's

00:21:55.480 --> 00:21:57.750
represented in the render tree.

00:21:57.750 --> 00:22:03.310
And this is mostly just the OK layer,
which is the base class.

00:22:03.460 --> 00:22:06.820
OK obviously doesn't
have a Core Animation,

00:22:06.820 --> 00:22:06.820
but...

00:22:07.000 --> 00:23:09.100
[Transcript missing]

00:23:09.580 --> 00:23:13.490
Okay, so now we know a little
bit about what a layer is,

00:23:13.560 --> 00:23:15.500
we can look at how you actually use them.

00:23:15.500 --> 00:23:18.230
So obviously first of all,
it's just like any Objective C object,

00:23:18.310 --> 00:23:19.500
you allocate one.

00:23:19.500 --> 00:23:22.550
And then you configure it
to basically look like,

00:23:22.560 --> 00:23:25.250
or rather to have the properties
that will end up making it

00:23:25.330 --> 00:23:26.500
look like what you want.

00:23:26.550 --> 00:23:30.270
So you would, for example,
set the background color or set the

00:23:30.270 --> 00:23:32.920
border width or the shadow or whatever.

00:23:33.200 --> 00:23:35.510
And then once you're happy with that,
you add it to a parent layer,

00:23:35.610 --> 00:23:39.450
which is kind of like adding it
as one of the sub-layers of the

00:23:39.540 --> 00:23:41.980
parent sub-layer's property.

00:23:42.190 --> 00:23:45.790
And once it's added to a super layer,
then at some point it will be

00:23:45.890 --> 00:23:48.070
committed into the render tree,
typically when the event

00:23:48.070 --> 00:23:50.630
loop next iterates around.

00:23:50.600 --> 00:25:16.300
[Transcript missing]

00:25:16.530 --> 00:25:18.480
And finally, we add it to the lettering.

00:25:18.480 --> 00:25:21.530
We've already created a super layer,
and adding it to this layer will

00:25:21.530 --> 00:25:23.280
make sure it gets committed.

00:25:23.280 --> 00:25:24.290
OK, what's next?

00:25:24.300 --> 00:25:27.910
OK, so--

00:25:28.140 --> 00:25:30.120
Like I said,
layout is this thing that happens as

00:25:30.120 --> 00:25:32.000
one of the steps of the commit process.

00:25:32.170 --> 00:25:34.990
And typically you just get
to set the position and size

00:25:34.990 --> 00:25:37.000
of the sublays of the layer.

00:25:37.000 --> 00:25:41.900
But basically it's just a hook,
so if you want to do something else,

00:25:41.900 --> 00:25:43.230
that's fine.

00:25:43.730 --> 00:25:47.460
And so basically,
whenever you change the size of a layer,

00:25:47.460 --> 00:25:50.000
we mark that the layer
needs to be re-layered.

00:25:50.000 --> 00:25:52.880
That's a word.

00:25:53.020 --> 00:25:56.460
Or you can do this explicitly
by saying set needs layout.

00:25:56.470 --> 00:25:58.840
And then what that does is it
kind of marks the layer as saying,

00:25:58.920 --> 00:26:02.620
next time you commit it,
call this layout sub-layers method.

00:26:02.720 --> 00:26:05.880
And the layout sub-layers are something
you can override in a subclass.

00:26:05.910 --> 00:26:08.020
And then basically just kind of
look at the sub-layers and say,

00:26:08.040 --> 00:26:09.860
do any of them need to be repositioned?

00:26:09.860 --> 00:26:12.960
And if so, move them around.

00:26:13.030 --> 00:26:15.180
And the other thing is that--

00:26:15.770 --> 00:26:19.050
If every layer subclass was to
define its own layout behavior,

00:26:19.050 --> 00:26:20.560
you end up with a lot of duplicated code.

00:26:20.700 --> 00:26:21.940
For example,
lots of things have something

00:26:21.940 --> 00:26:24.790
that looks like a grid,
or something that looks like a box,

00:26:24.960 --> 00:26:26.080
or whatever.

00:26:26.140 --> 00:26:29.710
So we have this kind
of layout manager idea,

00:26:29.710 --> 00:26:32.270
which is basically layout via delegation.

00:26:32.400 --> 00:26:34.740
So every layer has a
LayoutManager property,

00:26:34.780 --> 00:26:36.940
which you can set to some other object.

00:26:36.970 --> 00:26:38.940
And then when layout
happens on this layer,

00:26:39.070 --> 00:26:42.170
the default sublayer's implementation
will just call the LayoutManager.

00:26:42.300 --> 00:26:45.280
And this is a nice way of, you know,
if you have a bunch of things

00:26:45.280 --> 00:26:48.410
that you want to do grid layout
or circles or whatever you want,

00:26:48.410 --> 00:26:51.800
you can kind of encapsulate those
algorithms in a single class and then

00:26:51.910 --> 00:26:54.300
just kind of add them to each layer.

00:26:54.300 --> 00:26:56.630
And currently we only provide
one default LayoutManager,

00:26:56.640 --> 00:26:58.280
sorry, one built-in LayoutManager.

00:26:58.310 --> 00:27:01.230
And it's a constraint-based system.

00:27:01.460 --> 00:27:04.300
So what that means is you
can add the constraint

00:27:04.300 --> 00:27:07.820
LayoutManager to your superlayer,
and then on every layer you can describe

00:27:07.820 --> 00:27:12.300
the relationships between itself
and its siblings and its superlayer.

00:27:12.300 --> 00:27:15.080
So for example,
you can say that this layer has to be,

00:27:15.350 --> 00:27:18.240
sorry, the right edge of this layer
is aligned to the left edge

00:27:18.440 --> 00:27:20.300
of a sibling called something.

00:27:20.300 --> 00:27:23.300
So this is very, we found this to be
very kind of flexible.

00:27:23.390 --> 00:27:24.290
And this was how we were able to do it.

00:27:24.300 --> 00:27:27.300
So the graphs resizing
thing was actually working.

00:27:27.300 --> 00:27:30.870
And finally, if you want to use the
app get style stuff,

00:27:30.870 --> 00:27:32.390
we have that as well.

00:27:32.700 --> 00:27:36.360
Okay, so next we do drawing.

00:27:36.380 --> 00:27:37.930
And as I showed in the example,
if you want to,

00:27:37.930 --> 00:27:39.700
you don't have to do any of
this kind of subclassing stuff.

00:27:39.700 --> 00:27:43.700
You can just set the contents
of the layer to be an image.

00:27:43.850 --> 00:27:46.390
And that's pretty straightforward.

00:27:46.580 --> 00:27:48.630
Otherwise,
we have basically the same method

00:27:48.680 --> 00:27:51.620
which you have for layout and
very similar to how NSView works,

00:27:51.650 --> 00:27:55.180
which is you can say setNeedsDisplay
and then sometime later the

00:27:55.190 --> 00:27:57.140
display method will be called.

00:27:57.210 --> 00:28:03.450
And by default, that creates some kind of
CG context which matches the type

00:28:03.450 --> 00:28:05.900
of data we would prefer to render.

00:28:05.980 --> 00:28:12.090
And then you get the chance to render
whatever you want into the CG context.

00:28:13.110 --> 00:28:16.160
So the next point is that there
are some types of layers which

00:28:16.160 --> 00:28:19.570
need to render every time they,
or rather need to redraw

00:28:19.570 --> 00:28:21.660
every time their size changes.

00:28:21.720 --> 00:28:24.910
So since that's such a common thing,
we let you basically just set

00:28:24.920 --> 00:28:27.500
this needsDisplayOnBalanceChange
property to true.

00:28:27.520 --> 00:28:30.250
And when you do that,
we automatically call the

00:28:30.260 --> 00:28:32.070
setNeedsDisplay method.

00:28:32.870 --> 00:28:37.110
Okay, so the next big thing
obviously is animation.

00:28:37.420 --> 00:28:39.750
As Ralph said,
all our animation is declarative.

00:28:39.760 --> 00:28:42.710
What that basically means is you
describe what you want it to do,

00:28:42.710 --> 00:28:47.000
not provide some code that does it.

00:28:47.490 --> 00:28:49.520
So first of all,
you create an animation object.

00:28:49.710 --> 00:28:53.930
There's a number of built-in classes
which describe types of animations,

00:28:54.210 --> 00:28:56.620
like From To or Keyframe or whatever.

00:28:56.620 --> 00:28:58.410
So first of all,
you create your animation,

00:28:58.410 --> 00:29:02.360
you set the properties which
describe what you want it to do.

00:29:02.360 --> 00:29:03.960
For example,
what property you want it to change,

00:29:04.110 --> 00:29:06.750
the from, the two values, the duration,
things like that.

00:29:06.850 --> 00:29:09.540
And then you add it to allow
using one of these methods.

00:29:09.700 --> 00:29:11.720
And then after that, it's all autonomous.

00:29:11.720 --> 00:29:13.520
You don't have to worry about it.

00:29:13.520 --> 00:29:17.520
So basically, we have two ways of really
triggering animations.

00:29:17.520 --> 00:29:19.320
The underlying model is the same.

00:29:19.320 --> 00:29:21.640
We have these animation objects.

00:29:21.720 --> 00:29:26.180
But you can either have it
set up so that-- excuse me.

00:29:26.560 --> 00:29:30.780
So basically, we have two ways of really
triggering animations.

00:29:30.780 --> 00:29:32.260
I mean, the underlying model is the same.

00:29:32.260 --> 00:29:34.520
We have these animation objects.

00:29:34.520 --> 00:29:39.110
But you can either have it
set up so that-- excuse me.

00:29:48.400 --> 00:30:16.500
[Transcript missing]

00:30:17.040 --> 00:30:19.110
Okay, some more animation.

00:30:19.430 --> 00:30:21.020
So like I mentioned,
there are a number of

00:30:21.200 --> 00:30:22.170
different animation types.

00:30:22.290 --> 00:30:27.970
Firstly, we have the Basic Animation,
which is a way of specifying a from value

00:30:28.100 --> 00:30:32.900
and a to value and a property to change,
and some other timing parameters.

00:30:32.900 --> 00:30:34.500
And similar to that,
there's a Keyframe Animation,

00:30:34.500 --> 00:30:38.580
and these two are very closely related,
except that the keyframes are an array

00:30:38.750 --> 00:30:41.100
of values rather than just two endpoints.

00:30:41.150 --> 00:30:44.120
So this lets you do
very kind of intricate,

00:30:44.980 --> 00:30:46.900
kind of multi-frame animations.

00:30:46.900 --> 00:30:52.130
So this is how a lot of the
things on the city demo were done.

00:30:52.100 --> 00:31:27.000
[Transcript missing]

00:31:28.600 --> 00:31:30.990
And I guess one of the big
things we haven't talked

00:31:31.090 --> 00:31:33.140
about at all yet is timing.

00:31:33.170 --> 00:31:38.220
And Lackit is a composition model
not only in space but also in time.

00:31:38.610 --> 00:31:44.080
So every object in the system is part
of this hierarchical timing model.

00:31:44.120 --> 00:31:47.020
And what that basically means is
that everything has a begin time,

00:31:47.160 --> 00:31:51.120
which is relative to the
timeline of its parent object.

00:31:51.430 --> 00:31:54.360
So for Lairs,
every Layer can have a start time,

00:31:54.400 --> 00:31:57.200
and then that's some number of
seconds since its parent started.

00:31:57.200 --> 00:32:01.480
Something which should repeat,
and a number of other properties.

00:32:01.480 --> 00:32:03.920
And obviously,
animations fit this nicely as well,

00:32:03.960 --> 00:32:07.690
because they are just kind of a
sub-object of the Layer in some sense.

00:32:07.780 --> 00:32:12.380
So the animation's timeline is
relative to the Lairs timeline.

00:32:12.380 --> 00:32:13.920
And animations also
have an extra feature,

00:32:13.920 --> 00:32:16.930
which you can kind of
specify a timing curve.

00:32:16.990 --> 00:32:21.470
So you get your ease in, ease out,
or you can basically actually specify

00:32:21.590 --> 00:32:25.780
anything that fits a Bezier spline,
one segment Bezier spline.

00:32:25.780 --> 00:32:26.020
OK.

00:32:26.020 --> 00:32:27.190
And as I said, let's also do that.

00:32:27.200 --> 00:32:29.540
So we're going to do a little
bit of a simulation here.

00:32:29.540 --> 00:32:31.550
So here's some actual code,
which is trying to animate the

00:32:31.560 --> 00:32:34.130
opacity property of a Layer.

00:32:34.150 --> 00:32:36.220
Simple thing you can do
with the animation system.

00:32:36.420 --> 00:32:38.560
So basically,
we're going to create the animation.

00:32:38.580 --> 00:32:40.900
We're going to set the
property we want to change.

00:32:40.980 --> 00:32:43.820
We're going to set the values,
which is basically 1 for

00:32:43.820 --> 00:32:45.880
opaque and 0 for transparent.

00:32:45.900 --> 00:32:49.000
And we're going to say do this
over the duration of a second.

00:32:49.050 --> 00:32:52.750
And then once we've done that,
we just kind of add it to the Layer.

00:32:52.780 --> 00:32:54.630
And the key argument
is kind of important.

00:32:54.690 --> 00:32:58.150
Basically, the animation system for each,
or rather the set of animations attached

00:32:58.160 --> 00:33:00.260
to each Layer is kind of a dictionary.

00:33:00.350 --> 00:33:05.480
So every Layer can only
have one animation per key.

00:33:05.480 --> 00:33:08.480
And this is kind of crucial for
the implicit animations because,

00:33:08.600 --> 00:33:12.100
as Ralph showed,
if you hit the key more than once,

00:33:12.230 --> 00:33:17.800
and the Layer moves five times,
one animation moving from the current

00:33:17.880 --> 00:33:20.660
screen value to the target state,
you don't want to have

00:33:20.770 --> 00:33:21.820
five animations queued up.

00:33:21.840 --> 00:33:24.640
So basically, that's what the key is for.

00:33:24.640 --> 00:33:25.160
OK.

00:33:25.160 --> 00:33:26.120
What else?

00:33:26.120 --> 00:33:27.200
All right.

00:33:27.200 --> 00:33:30.340
So we haven't talked at all about
how you actually use these things.

00:33:30.340 --> 00:33:33.320
We've told you how to create a tree
when you have to actually take the

00:33:33.320 --> 00:33:35.660
root of the tree and make it visible.

00:33:35.690 --> 00:33:38.870
And in Leopard,
NSView will basically support

00:33:38.870 --> 00:33:42.540
rendering from Layers directly,
which you'll hear more about later.

00:33:42.560 --> 00:33:44.720
But for now,
what we really need to know about

00:33:44.720 --> 00:33:50.140
is that you can take a Layer and
assign it as the kind of the

00:33:50.140 --> 00:33:52.140
visual representation of a View.

00:33:52.150 --> 00:33:56.010
And then the View system will
take that and do the most optimal

00:33:56.010 --> 00:33:57.060
thing to get it to the screen.

00:33:57.060 --> 00:33:59.260
And it's going to do
as much as it needs to.

00:33:59.320 --> 00:34:00.220
So there's these two methods.

00:34:00.220 --> 00:34:01.340
One, set the Layer.

00:34:01.340 --> 00:34:03.780
And then there's this other
one called setOnceLayer.

00:34:03.790 --> 00:34:08.160
And it's the setOnceLayer which
actually turns on the rendering model.

00:34:08.160 --> 00:34:09.060
OK.

00:34:09.070 --> 00:34:11.250
So now I think I'm going
to do a couple of demos,

00:34:11.270 --> 00:34:15.860
which just basically just show
a few features of the system.

00:34:15.860 --> 00:34:18.040
OK.

00:34:18.050 --> 00:34:20.210
So this one.

00:34:22.990 --> 00:34:26.950
So first of all, this little application,
which is just a red window.

00:34:27.600 --> 00:34:31.090
And we can open a bunch of icons in here.

00:34:31.480 --> 00:34:33.360
And so what we did is we
loaded a bunch of images,

00:34:33.470 --> 00:34:38.550
created a number of layers,
set each image as the

00:34:38.600 --> 00:34:41.160
content of each layer,
and then added this kind of rotation

00:34:41.350 --> 00:34:43.800
animation just to give it some life.

00:34:43.850 --> 00:34:48.090
And then we have a mouse-down,
mouse-drag event handler which looks

00:34:48.090 --> 00:34:54.600
for the thing under the mouse and
is going to set the transform to

00:34:54.650 --> 00:34:58.200
do a scaling effect on the layer,
so you get this kind of

00:34:58.200 --> 00:35:00.620
Doc Magnify type thing.

00:35:00.710 --> 00:35:04.270
The other thing is that we're using the
layout system to do all the positioning.

00:35:04.340 --> 00:35:09.680
So we have this layout manager which
packs the layers into a 1D box.

00:35:09.780 --> 00:35:13.270
So we change the transform and then
at some point the layout manager will

00:35:13.300 --> 00:35:15.300
be called to reposition everything.

00:35:15.390 --> 00:35:16.930
So that's kind of nice,
and I can do this.

00:35:17.070 --> 00:35:20.770
The other thing obviously is we
have a selection filter which is

00:35:20.860 --> 00:35:26.490
a CI filter generator type thing,
which has a Gaussian Blur and

00:35:26.490 --> 00:35:29.880
some kind of exposure adjusting
just to give it some pop.

00:35:29.880 --> 00:35:33.810
And I guess the other thing is that
we can change the layout manager.

00:35:34.010 --> 00:35:37.650
That's the nice thing about these
things is I can set it to kind of

00:35:37.650 --> 00:35:43.120
instead of flowing horizontally,
I can just say wrap across the window.

00:35:43.150 --> 00:35:44.120
So I can do this.

00:35:44.320 --> 00:35:48.170
Obviously I'm still using the exact
same code to set the scale factor and

00:35:48.180 --> 00:35:50.590
the filters and all that kind of stuff.

00:35:50.690 --> 00:35:56.040
And so as an experiment we can
kind of add a bunch more icons

00:35:56.060 --> 00:35:59.120
and see what we can get going.

00:35:59.120 --> 00:36:01.890
I needed to copy these a few times.

00:36:04.130 --> 00:36:05.330
I haven't actually tried
it on this machine,

00:36:05.330 --> 00:36:06.410
so I hope it works.

00:36:06.580 --> 00:36:10.820
OK, so we have a 50 or so.

00:36:10.820 --> 00:36:15.360
You can get a lot more than this,
but it's not really stressing it at all.

00:36:16.410 --> 00:36:16.950
OK.

00:36:16.970 --> 00:36:21.150
So next demo is totally different,
and this one has 3D,

00:36:21.150 --> 00:36:27.430
which I guess you saw a bit of this
in Peter's part in Bertrand's talk.

00:36:27.810 --> 00:36:30.620
But this is basically a 3D
file browser of some sort.

00:36:30.690 --> 00:36:34.850
So you can kind of position these
things in space and rotate them.

00:36:34.860 --> 00:36:38.800
And basically, it's planes in space,
as we like to say.

00:36:38.830 --> 00:36:43.740
And what that means is that
there are a number of layers,

00:36:43.740 --> 00:36:46.680
one layer per item in the stack.

00:36:46.690 --> 00:36:48.240
And each of those has
a number of sub layers.

00:36:48.240 --> 00:36:49.820
Obviously,
each sub layer has a border color,

00:36:49.820 --> 00:36:52.090
which is yellow, and some text.

00:36:52.100 --> 00:36:55.690
The text is being resized
as we select and unselect.

00:36:55.780 --> 00:37:11.700
The animation is a mix of implicit
and explicit animations to move

00:37:11.700 --> 00:37:14.640
the thing along the z-axis.

00:37:14.660 --> 00:37:19.560
The other thing I should mention
about animations is that there's also

00:37:19.630 --> 00:37:23.220
a notification system so you can get
messages when they start and finish.

00:37:23.220 --> 00:37:25.770
That's what we're using in this
case to know that at some point

00:37:25.830 --> 00:37:31.740
the layer has actually moved out
of the scene and we can delete it.

00:37:31.740 --> 00:37:35.640
I think that's about
all I wanted to share.

00:37:35.640 --> 00:37:44.640
I think I'm going to
hand it back to Ralph.

00:37:44.660 --> 00:37:45.680
- Okay.

00:37:53.750 --> 00:37:58.800
Okay, so first I would like to mention
that you heard the word "layer kit"

00:37:58.800 --> 00:38:02.360
in this presentation sometimes,
which was kind of referring

00:38:02.790 --> 00:38:04.360
to Core Animation.

00:38:04.430 --> 00:38:07.060
The reason for that is that
was the code name for this

00:38:07.150 --> 00:38:11.060
project till last Friday and,
you know, the context switch in my mind

00:38:11.060 --> 00:38:13.300
is not happening that quickly.

00:38:14.060 --> 00:38:17.680
That's also the reason why
all the APIs start with LK,

00:38:17.720 --> 00:38:19.920
just in case you wonder.

00:38:19.920 --> 00:38:23.910
Okay, a word about AppKit.

00:38:25.710 --> 00:38:28.990
So in Leopard, AppKit has a mode where
you can essentially have

00:38:29.170 --> 00:38:32.780
NSViews backed by LK layers.

00:38:32.780 --> 00:38:38.060
And what this essentially means is it's
a flag on a view that says "host this

00:38:38.060 --> 00:38:44.590
on a layer" and then that view and all
its subviews get hosted on LK layers.

00:38:44.630 --> 00:38:48.440
And that has really nice effects
that can make use of all of

00:38:48.440 --> 00:38:51.110
the Core Animation animation.

00:38:51.120 --> 00:38:53.240
That didn't sound right.

00:38:53.870 --> 00:38:57.560
Usually that is a one-to-one mapping,
so every view gets a layer.

00:38:57.580 --> 00:39:00.620
And for you,
essentially what changes is instead

00:39:00.620 --> 00:39:04.990
of getting the drawRect call every
single time something happens,

00:39:04.990 --> 00:39:09.960
you get it once and then the
content of that view is cached.

00:39:09.960 --> 00:39:14.570
In some cases you don't want that,
so imagine you want to pop up some,

00:39:14.700 --> 00:39:18.930
you drag an object around and you
want to pop up a snapping guide,

00:39:19.050 --> 00:39:23.680
then that would be a good example of
taking a layer which is just that guide,

00:39:23.790 --> 00:39:28.450
add it to the view temporarily to give
some visual feedback and then once on

00:39:28.760 --> 00:39:31.640
mouse up you would remove it again.

00:39:31.640 --> 00:39:34.820
And go to session 132,
Cocoa Animation Techniques,

00:39:34.930 --> 00:39:37.830
tomorrow at 3:30,
which talks all about how to

00:39:37.850 --> 00:39:40.360
get this stuff into Cocoa.

00:39:40.570 --> 00:39:44.130
Unfortunately, it's at the same time as
the Core Image session,

00:39:44.240 --> 00:39:49.380
so if you're interested in making new
filters to add effect to your layers,

00:39:49.380 --> 00:39:51.300
then you're in a pickle.

00:39:51.600 --> 00:39:53.190
Okay.

00:39:54.590 --> 00:39:58.500
So in Interface Builder that's
actually exposed in a checkbox,

00:39:58.500 --> 00:40:02.550
so it's this once-layer checkbox
that you have to add to the view

00:40:02.550 --> 00:40:07.520
and then from then on everything
happens pretty much automatically.

00:40:07.520 --> 00:40:11.260
And with that, we'll go to another demo.

00:40:20.990 --> 00:40:25.180
Okay, so let me go back to
my strawberries here.

00:40:25.740 --> 00:40:29.220
One thing I did forget to
show in the last demo is

00:40:29.290 --> 00:40:31.900
actually that LK scroll layer.

00:40:32.520 --> 00:40:33.380
Which is used here.

00:40:33.400 --> 00:40:38.750
So there's a group layer,
which is an LK scroll layer that

00:40:38.920 --> 00:40:42.030
manages all these different entries
and the entries are actually

00:40:42.110 --> 00:40:47.370
created on demand so they're not
visible at the beginning of the app.

00:40:47.400 --> 00:40:53.960
Okay, another example I would
like to make here is...

00:40:54.760 --> 00:41:00.250
So this is a movie playing on a
layer and it has the audio spectrum,

00:41:00.250 --> 00:41:04.100
gets represented by our,
by my boss essentially.

00:41:04.100 --> 00:41:07.810
It gets squeezed and
scratched appropriately.

00:41:08.090 --> 00:41:12.790
So the kind of important part of
this piece is that it's actually the

00:41:13.590 --> 00:41:16.980
controls that are on top of this view,
the frequency and

00:41:16.990 --> 00:41:18.870
background filter and...

00:41:19.110 --> 00:41:24.500
So the kind of important part of
this piece is that it's actually the

00:41:24.500 --> 00:41:28.000
controls that are on top of this view,
the frequency and

00:41:28.000 --> 00:41:29.880
background filter and...

00:41:32.040 --> 00:41:37.400
So the kind of important part of
this piece is that it's actually the

00:41:37.400 --> 00:41:37.910
controls that are on top of this view,
the frequency and

00:41:37.910 --> 00:41:37.910
background filter and...

00:41:42.600 --> 00:42:08.500
[Transcript missing]

00:42:08.870 --> 00:42:14.300
So the kind of important part of
this piece is that it's actually the

00:42:14.300 --> 00:42:18.960
controls that are on top of this view,
the frequency and background

00:42:18.960 --> 00:42:41.390
filter and... image image units,
because Core Animation will load

00:42:41.390 --> 00:42:46.090
image units and you can just specify
any filter that you have as a plugin.

00:42:46.090 --> 00:42:49.750
So you saw the glow effect
in the strawberries demo.

00:42:49.900 --> 00:42:52.120
You could have arbitrary
filters going in there.